Ну что, давайте, наверное, начнем.
Я напомню, что я сформулировал две важные теоремы, что
множество общезначимых формул неразрешимо и что
множество формул истинных в арифметике неперечислимо.
Ну вот сегодня, наконец, мы доберемся до доказательств
этих теорем.
Начнем с неразрешимости общезначимых формул.
Я напомню, что в прошлый раз, ну я там две буковки
использовал, напомню, обе, я ввел ассоциативные
исчисления, в том числе симметричные, вот тут имеется в виду как
раз симметричная, давайте я какой-нибудь значок поставлю,
и мы связываем с этими исчислениями такую задачу, проверка
равенства, дано исчисление, то есть алфавит, правило
и два слова.
И спрашивается, можно ли построить одно слово, превратить
одно слово в другое, подстановками, с помощью этих правил, применяемых
в любом из направлений.
Напомню также, что мы обсудили в прошлый раз, что с таким
симметричным исчислением связана полугруппа, то
есть множество с бинарной операцией, которая ассоциативна
и в сущности вопрос о достижимости слова, это вопрос о равенстве
слов в полугруппе.
То есть мы смотрим на слова как на элементы, как представители
классовой эквивалентности, которые сами по себе элементы
полугруппы.
И теперь я напомню обозначение, через valet обозначал множество
описаний общезначимого формул, и сейчас я собираюсь
доказать такую теорему, что вот это вот равенство
слов в полугруппах сводится, м сводится к множеству
общезначимых формул.
Ну и тогда отсюда мы сразу получаем следствие, что
множество общезначимых формул неразрешимо.
Друзья, у нас получается такой более длинный путь
для оказательства неразрешимости.
Мы начинаем не с проблемой остановки машины тюринга,
промежуточным образом доказываем эту вот проблему равенства
слов в полугруппе, и ее уже сводим valet, но сводимость
транзисивна, поэтому мы все равно получаем то, что
нам нужно.
Мы свели неразрешимую задачу к нашей, значит, наша тоже
неразрешима.
Ну, уже в прошлый раз у нас сводимости были, и на параллельном
курсе теории алгоритма у вас сводимости тоже были,
вы понимаете в целом, что нужно делать.
Вот у нас есть, то есть что должна делать сводящая
функция.
Она должна получать описание полугруппы в виде порождающихся
соотношений и строить как-то формулу.
Ну, так, чтобы формула была общезначима тогда и только
тогда, когда слово у достижимое и слово вы.
Нужно, как обычно, побеспокоиться о тех словах, которые не
являются описаниями симметричных исчислений.
Ну, с этими словами мы поступим так же, как поступали в
прошлый раз, отправим их в какую-нибудь формулу, которая
не является общезначимой.
На них ответ отрицательный, поэтому все что нам нужно
это сопоставить им к какой-то конкретной формулу, которая
не общезначима.
Интересная часть, конечно, как задать, то есть по сути
дела вопрос такой, как задать утверждениями первого
порядка равенство слов в полугруппе.
Ну, оказывается, это можно сделать.
Я сейчас объясню как.
Значит, наша формула будет состоять из нескольких
частей.
Да, нет, надо начать, конечно, с сигнатуры, это я поторопился.
Такие части, если нет сигнатуры.
Значит, сигнатура у нас будет бинарный предикатный символ
и много унарных функциональных.
Значит, сколько много?
Я считаю, что алфавит, исчисление, это как раз вот эти символы
есть.
То есть для каждого символа алфавита я буду заводить
специальный функциональный символ.
И будет некоторый общепинарный символ, который, ну, по сути
дела, будет отвечать за равенство.
Ну, давайте выписывать, еще будет состоять формула.
Значит, во-первых, нужно будет включить три конкретные
формулы, ни от чего независящие, которые выражают просто
условия рефлексивности, симметричности и транзитивности.
Того отношения, которое задается этим предикатным
символом.
Ну, и что у нас там транзитивность?
Условия совершенно обычные, я их особо подробно и не
комментирую, потому что они уже и у нас встречались,
и на упражнениях они встречались.
Ну, и вообще это свойство, те свойства хорошо известны.
Сами формулы, хотя последняя довольно длинная, но ничего
в ней сложного нет.
Эти части точно будут ходить в ФИ.
Значит, я прямо где-нибудь здесь буду выписывать ФИ.
В ФИ будет устроена так, конъюнция рефлексивности,
симметричности и транзитивности, но это, конечно, не все.
А что еще нам нужно?
Нам понадобятся такие формулы.
Их уже будет много, и они будут уже зависеть от алфавита
исчисления.
Для любого х, для любого у, из того, что х равен у,
ну, я, говоря словами, буду не стесняясь говорить,
что в отношении е находятся равные объекты, хотя это,
в отношении эквивалентности, ну, что это за формулы?
Они говорят, что функции, которые будут задаваться
функциональными символами, согласованы с отношением
эквивалентности.
Если мы с новым эквивалентным x и y применяем функцию одну
и ту же, то мы получаем снова эквивалентную.
Эти условия согласования мы часто уже с этим сталкивались.
По сути дела, мы хотим этим утверждением объяснить,
что аито это функция не просто на носителе модели,
ну, когда мы будем интерпретировать это, а она функция на классах
эквивалентности, потому что это условие согласования
гарантирует, что на всем классе эквивалентности
это значение будет попадать в один и тот же класс эквивалентности.
Ну и наконец, нам понадобятся сложные формулы.
Давайте, значит, я вначале задам некоторый шаблон.
Значит, вот есть, ну, раз у и в это у нас так и будет,
у это, скажем там, у1, уn, v это v1, vn, и мы хотим написать
такое равенство, ну, не равенство, формулу, значит, u1, u2, u3, еще
вот мы так, сколько у нас тут есть символов, их разное
может быть количество, разумеется, я извиняюсь,
к иксу, скобки закрыли, это вот получается такой терм,
то есть мы, это у нас функциональные символы, мы их применяем
в том порядке, в котором они записаны в слове, ну, и в
конце применяем к иксу.
Да, и я извиняюсь, я забыл квантор.
Тут стоит квантор.
Но поскольку бинарный предикатный символ, надо писать
вот что-то второе, второе это аналогичная цепочка
применения функций, но уже тоже к иксу в конечном счете,
но уже функции из второго слова.
Вот такая формула, и давайте я где-нибудь здесь напишу
сразу, как у нас устроены правила, правила это множество
вот пар вот такого вида, u1, v1, и теперь к формуле я должен
приписать, ну, во-первых, конъюнцию по всем и вот этих
формул аитах, а во-вторых, конъюнцию по, ну, допустим,
правила у нас там, не знаю, сколько, ну, там, r штук,
конъюнцию там, значит, ну, тоже пусть будет по i, единицы
до r, вот таких вот как раз формул, которые вот здесь
вот написаны в виде шаблона, это все, вот это вот все,
вся такая большая конъюнция, посылка нашей формулы,
сама формула имеет вид импликации, а в заключение импликации
мы напишем вот такую же формулу r, u, v, которая уже
определяется по двум словам, которые у нас здесь даны,
то есть по исчислению мы определяем посылку, а в
заключение мы пишем вот то, что определяется этими
двумя словами. Вот так будет выглядеть формула. Ну,
понятно, что такая сводимость вычислима. Имея исчисления,
написать такую формулу не очень сложно. Вот эти
первые три формулы вообще константы, эти формулы,
ну, надо просто знать набор функциональных символов,
они выписываются, ну, а эти зависят от правил, но если
у нас дано правило какое-то, что можно заменять на v и
наоборот, ну, эта формула записывается вполне очевидным
образом. Таким образом, мы построили сводимость,
но теперь, чтобы она была корректной, нам нужно доказать
вот это равенство. Давайте доказывать. Первое наблюдение.
Поскольку формула является импликацией, если в какой-то
модели посылка импликации ложна, формула истина. И
такие модели никак не повлияют на то общезначимая формула
или нет. Ну, в этих моделях она всегда истина, то есть
если она и не общезначима, то по причине какой-то
другой модели, где посылка все-таки истина. Значит,
что значит, что посылка истина? Это означает, что у нас
есть модель, и на этой модели есть отношение эквивалентности,
как задают нам первые три формулы, и функции, которые
задаются функциональными символами, их, естественно,
продолжить до функции на отношениях эквивалентности.
Вот эти правила согласования гарантируют нам, что для
каждого класса эквивалентности применение функции АИТ будет
давать элементы из какого-то определенного класса эквивалентности.
Значит, определенная функция. А что нам говорят вот эти
вот формулы? Ну, они говорят, что если я взял композицию
в каком-то порядке функций и другую композицию, они
говорят, что результаты одинаковые, то есть для
любого х вот это равно, если мы переходим к классам
эквивалентности, но это и означает, что функции
просто одни и те же. То есть в любой модели, если посылка
истины, мы получаем на самом деле вот некоторое множество
классовых эквивалентности носителя этой модели, на
нем функции, и вот теперь уже чтобы доказывать корректность,
нужно разбираться вот с этими остальными формулами.
Ну, хорошо, давайте посмотрим, пусть нам нужно два случая
разобрать. Первый случай, что U такие равняются V вот
в этой вот полугруппе G. А, проще не равняется начать.
Давайте не равняется начать. Пусть U не равняется. Что
тогда? Тогда я в качестве модели возьму саму полугруппу,
а E это просто отношение равенства. На полугруппе
определены функции. Как определены функции? Если
у нас есть элемент полугруппы, мы просто умножаем слева
в той записи, которая у меня используется на этот
элемент. Конечно, это функция на полугруппе, левое умножение.
Давайте посмотрим на посылку. Мы знаем, что слова UIT и VIT
равны в полугруппе. Ну, тогда равны и соответствующие
функции. Наблюдение очень простое, что если U равняется
V, это равносильно тому, что U умножить на X, ну, я так
пишу U умножить на X, чтобы не писать вот эту длинную
композицию, а равняется, поскольку это просто в данном
случае это просто умножение в полугруппе, равняется
V на X для любого X. Ну, в одну сторону очевидно, если U
равняется V, то, конечно, если вы еще справа на что-то
умножаете, то ничего не испортится. А в другую
сторону достаточно взять подходящий X и, например,
пустое слово. U с пустым словом это U, V с пустым словом
это V, значит, U равняется V. То есть посылка вся истинна.
Но заключение как раз ложно, потому что мы же видим вот
из этой эквивалентности, раз U не равняется V, то и
вот эта вот формула R от U, V, она тоже ложна. Значит,
мы получаем, что phi ложна. Ну, это такая более простая,
сводимость в более простую сторону. Теперь давайте
посмотрим в более сложную. Пусть уравняется V. Тогда
мы знаем, что есть цепочка преобразований. Давайте
как-нибудь переобозначим, скажем, Wn. Это вот наши правила
нашего исчисления. В конце у нас что-то там, какое-то
Wt, которое как раз равняется V. Мне в этом случае надо
доказать, что формула абсолютно значима. То есть какая бы
ни была модель, тут я мог выбрать модель, когда нужно
доказать, что формула не общезначима, просто достаточно
в одной модели сделать ее ложной. Теперь мне надо
доказать, что она всегда истинна. Но опять-таки, если посылка
ложна, то мы про это не думаем. Если посылка истинна, вот
мы смотрим на эту ситуацию, у нас есть функции на классах
эквивалентности. И что нам теперь нужно доказать?
Нам нужно доказать, что если посылка истинна, то композиции
слов, функции, отвечающих словам ui и vi равны. И тогда
нужно доказать, что и композиции этих слов равны. Для этого
надо проверить доказательства индукции по длине вот такого
преобразования. Надо проверить, что на каждом шаге, если
у нас было равенство, то и будет. То есть, если w i t получилось
из w… w i plus 1 получилось из w i t, а то функции одни и
те же. Ну, смотрите, давайте запишем w i t как что-то там
w i plus 1 получается заменой u i t на v i t. Ну, я сейчас пишу
применение правила слева направо, то есть u i t заменяется
на v i t. Второй случай совершенно симметричный, если мы v i t заменяем
на u i t. В чем рассуждение? Мы знаем, что функция… Давайте
теперь я для краткости вот эти вот функции прям так
и буду записывать, что это функция, отвечающая слову
u, а это функция, отвечающая слову v. И вот мы знаем, что
функция, отвечающая слову u i t и v i t одинаковая, а остальные
вот эти две функции, они просто одни и те же. Мы же
меняем только в одном месте. Ну, тогда функция, которая
отвечает слову w i t, как она устроена? Она устроена
как композиция функции p i t, композиция с функцией
u i t и композиция с функцией s i t. А функция, которая отвечает
и плюс первому, устроена как другая композиция
p i, где просто в середине записана другая буква.
Но вот эти функции равны, поскольку посылка наша
истинна. И мы получаем, что w i t и w i plus 1 задают одну
и ту же функцию, потому что мы берем композицию одной
и той же функции, еще пары одинаковых функций и еще
пары одинаковых функций. Ну, естественно, получаем
одинаковые функции. Композиция – это функциональное преобразование
функций. Значит, мы получаем, что все w i t от x совпадают
и с u и с v. u и v – это начало и конец нашей цепочки, поэтому
равенство транзитивно. Мы по транзитивности проходим
по этой цепочке и получаем равенство. Значит, формула
phi – истинна, потому что мы доказали, что истина
заключения. Ну вот и все. Пришлось, в общем-то, довольно
много потрудиться. Эта сводимость сама по себе не самая сложная
часть. Прошлый раз было сложнее с этими счислениями,
с переходом к симметричному варианту. Заметьте, что
если не переходить к симметричному варианту, так просто записать
формулы первого порядка уже не получится, потому
что для отношений эквивалентности у нас есть простой способ
задать их формулам первого порядка, а для произвольного
ориентированного графа непонятно, как его задавать.
И когда у нас есть какие-то подстановки односторонние,
они могут задавать довольно сложный граф, и какие у
него свойства мы заранее сказать не можем. А отношения
эквивалентности обладают хорошими свойствами, легко
выразивыми в терминах первого порядка.
Я бы сказал не совсем. Что нам нужно доказать? Нужно
доказать, что формула общезначима. Для этого мы должны взять
какую-то модель и проверить, что формула истина. Мы
сразу разбиваем на два случая. Первый случай
посылка ложна, тогда формула истина. С этим случаем
все очень просто. Второй случай посложнее, когда посылка
истина. Но тогда мы сразу очень много знаем про модель.
Мы знаем, что предикат E задает отношение эквивалентности,
а функции a и t их можно определить и на классах эквивалентности.
Они переносятся на классы эквивалентности. И более
того, мы знаем, что композиции функций, отвечающих правилам
замены, они задают одни и те же функции. Вот это
последняя часть посылки. А нам нужно отсюда заключить,
что тогда и у и в. Теперь мы утверждаем, что если вот
такие композиции таких функций равны, то тогда и
композиции функций, отвечающих у и в, равны. В сущности,
по сути дела, мы так и поступаем. Но просто когда у и в недостижимы,
то есть они неравны в полугруппе, нам проще просто предъявить
пример вот саму полугруппу и сразу увидеть, что есть
пример, когда они неравны. А если…
Для любого икса тут существенно, что это же у нас функциональные
символы, их надо к чему-то применить, поэтому мы переписываем
равенство слов как равенство соответствующих функций.
Ну и это применимо всегда, потому что мы дальше будем
говорить о композициях этих функций, которые применимы
к любому иксу. В модели на полугруппе это прям умножение
на икс, ну а в другой модели это может… В общем, не сильно
отличается, потому что все достаточно жестко задано,
но там надо аккуратнее говорить, что там получается.
Таким образом мы доказали. Давайте я где-нибудь здесь
зафиксирую это. Вот оно у меня тут написано, но мне
место будет нужно, в этом я хочу оставить. Теорема
неразрешимых. И мы помним, что оно перечислимо, то есть
это еще один пример, их много, перечислимых, неразрешимых
множество. Следующая теорема, которую я собирался доказать,
называется теорема Тарского, она утверждает, что неперечислимо
множество формул, которые истинны в арифметике. Ну
я сейчас напомню определение. Значит, арифметика это такая
модель натуральных чисел, стандартная модель натуральных
чисел с равенством, с умножением, со сложением, с нулем и единицей.
И r это множество формул в сигнатуре арифметики,
таких, что phi истинно. Тут, как мы видим, ситуация
даже хуже. Мы перечислить эти формулы не можем, но
как это доказать? Идея, конечно, остается той же. Нужно
строить сводимость. Но сводимость чего? Значит, я сразу напишу
чего, а потом сейчас немножко обсудим. Значит, сводимость,
мы будем строить такой подходящей задачи. Это описание машин
тьюринга, которые не останавливаются на пустом входе. То есть
мы фиксируем вход и запускаем машину. Сейчас я напишу определение.
Давайте я напомню, что h это язык остановки. h эпсилон
это язык остановки на пустом входе. Ну и вот это вот h.
No эпсилон это описание тех машин, которые не останавливаются
на пустом входе. И нам, конечно, нужна лемма, что вот это самое множество, что оно
неперечислимо. Потому что я буду потом доказывать, сводить это множество формулам
арифметики. И мы знаем из теории алгоритмов, мы знаем, что m-сводимость
уважает перечислимость. То есть если мы свели неперечислимое множество к какому-то,
это множество тоже неперечислимо. То есть нам нужно знать неперечислимость
этого множества. Ну это по сути дела упражнение уже в теории алгоритмов. Я поэтому
только коротко напомню. У вас не было прям буквально такого в теории алгоритмов?
Нет, не арифметику, что машины Тюринга, которые не останавливаются на пустом входе,
неперечислимны. Ну я тогда очень быстро просто напомню, как это делается. Мы вначале строим
сводимость проблем и остановки, проблем и остановки на пустом входе. Это тоже у вас
почти заведомо было. Нам очень простая сводимость. Надо просто из машины и входа построить машину,
которая работает так. Она вначале пишет эти символы х на вход, на пустом входе, а потом работает
как предыдущая машина. Ясно, что это работает и с этим все хорошо. Дальше мы помним, что сводимость
языков дает одновременно и сводимость дополнений. То есть у нас получается сводимость дополнения k
к дополнению k. Тут есть единственная тонкость. Дополнение k это не совсем наш язык ашноу,
потому что туда еще входят мусорные слова, которые не являются описаниями машин. Но эта
проблема решается легко, потому что описание машин Тюринга разрешимы язык, поэтому нам
нужно сводимость доопределить, отправив куда нужно мусорные слова, и мы получим как раз сводимость
к тому, что нужно. А с арифметикой конечно у вас не было, это я сейчас буду объяснять. Это дело не
такое быстрое на самом деле, но я надеюсь, что мы справимся. Тут конечно нужно... То есть фактически
неформально, что мы утверждаем? Мы утверждаем, что высказывание о том, что машина Тюринга какая-то
конкретная машина Тюринга не останавливается на пустом входе, можно выразить формулой первого
порядка в арифметике. Неверно. Оно и дополнение к нему тоже неперечислимо. Ну смотрите, в арифметической
иерархии. Сейчас, секунду. Хороший вопрос, не задумывался он. Нет, ну как, конечно, она
потому и называется арифметическая. То есть нам нужен клантор всеобщенности, ну допустим,
не останавливается. Для любого момента времени Т машина не останавливается. А условие неостановки,
оно когда уже задано, оно мы сейчас увидим, оно записывается достаточно легко. Так что да, нет.
Ну да, внутри будут кванторы, но можем посчитать глубину формулы, которая получится.
Нет, она должна быть конечной. Сейчас напишем и увидим. Что не коперечислимо, на самом деле очень
легко понять, потому что мы формулы от неформулы отличаем легко. То есть формулы образуют
разрешимое множество. А что у нас с замкнутыми формулами может быть? Ну они либо истины,
либо ложны. Поэтому дополнение с точностью довод разрешимого довеска это просто ложные формулы.
Но формула истина тогда и только тогда, когда ее отрицание ложно. Поэтому дополнение это просто
ложные формулы. То есть тут очень легко строится свадимость. То есть это и в одну, и в другую сторону,
просто нарешиванием знака равенства. Что? Ну да, она где-то, она симметричная, то есть она в каком-то
симметричном классе должна лежать. У нас получится какая-то формула, но будет симметрична,
потому что за счет этой свадимости мы можем переписать с другими кванторами. Потому что когда мы
навешиваем отрицание, потом, если мы навесили отрицание на формулу, которая начинается с квантора
всеобщенности, когда мы это отрицание через квантор и перенесем, у нас получится квантор
существования. Поэтому получится другой класс арифметической иерархии. Хорошо, а что значит нам
нужно сделать? Нам нужно как-то выразить арифметические условия неостановки машины
Turing. Ну и более-менее понятно, что основная сложность состоит в том, что машина Turing работает как-то
долго. То есть мы не можем написать формулу, которая перечисляет все такты работы машины. Тем более,
если она не останавливается, их будет бесконечно много. Эта проблема решаемая, и мы ее сейчас решим,
но только начать надо с еще более простых предикатов. Вот у нас была алгебратарская,
и она разрешимая, потому что там иллюминируется квантор. И это не доказывал, так только объяснил,
что общая схема иллюминации кванторов тоже работает. Почему она проще, чем арифметика? Там
разрешима, здесь даже не перечислима. Дело в том, что в арифметике есть деление с остатком. Это
принципиальный момент. С действительными числами никакого аналога деления с остатком нет. У вас
всегда все делится с остатком 0, если не равно нулю. А тут мы получаем такую формулу. Давайте я ее как
-нибудь res обозначу. Там x и y, то есть y делим на x, частная q, остаток r. Что это означает? Это
означает, что y мы можем представить как q умножить на x плюс r. Ну и вдобавок, это у нас все натуральные
числа, поэтому достаточно написать вот такое неравенство. Про неравенство давайте я сразу напомню,
что хотя у меня его в сигнатуре нет, но что такое x меньше y, это мы понимаем такую формулу,
что существует z. Меньше либо равно давайте я напишу. Ну а строгое неравенство естественно
тоже выражается. Существует такой z, что y равняется x плюс z. То есть в случае натуральных чисел у нас
нет проблемы, что мы ограничиваемся только равенством. Неравенство тоже выражается. Ну вот,
это утверждение, что четверка чисел дает нам деление с остатком y на x. Отсюда сам остаток
легко написать. А, тут лучше конечно давайте как-нибудь я div здесь напишу. Хочется рез сохранить
для... собственно для остатка, потому что это мне придется писать какие-то формулы. Там лучше
конечно рез иметь. Существует такое q, что div x, y, q, r. Ну я думаю понятно. Но отсюда можно написать
утверждение о делимости. Тоже конечно слово div может появиться, но я исхищаюсь. Дивизор, делитель.
Это значит, что существует такое q, что div x, y, q, 0. Ну самые обычные наши формулы. Значит в первой
формуле я конечно написал наш обычный математический жаргон. По-хорошему надо написать формулу первого
порядка. То есть как всегда в префиксной форме. То есть написать равенство как предикатный символ,
затем два аргумента. Один y, а другой вот такой сложный терм, где мы применяем функцию умножения
вначале, потом функцию сложения. Ну а там где написано меньше, надо вот ту формулу подставить.
Но это достаточно очевидное преобразование. Я их для наглядности пропускаю. Отсюда я думаю понятно,
что можно выразить предикат, что x простое. Просто взять определение простого числа и записать там
ничего кроме отношения делимости не нужно. Более интересный вопрос возникает, если мы хотим выразить,
ну скажем, такой предикат. Тернарный предикат, что x это какая-то степень y. Ну если это z
фиксировано, скажем, 5, ну тогда это легкая формула. x равняется y, ну может на y там 5 раз. А если она
произвольная? Не очень понятно, как записывать. Заметьте, что проблема проще, но близка к той,
которую мы должны решать для машин тюринга, потому что тоже возникает, если мы будем писать
обычным способом, то нам надо написать что-то такое. Нам нужно писать последовательность. Ну как
определяется степень индуктивно, мы пишем вот так вот, и последнее у нас будет z. То есть вот
такая рекуррентная последовательность, и x просто будет равен последнему члену этой последовательности.
Вот нам нужно записать такую вещь. Но проблема в том, что последовательность это функция. Если бы
у нас был функциональный символ, если бы у нас была логика второго порядка, и можно было бы
брать кванторы по функциональным символам, могли бы сказать что-то такого типа. У нас есть функция,
которая обладает вот такими вот свойствами. То есть f от i плюс 1 равняется y умножить на f от
i, а x равняется f от z. И это и задавало бы нам соответствующее равенство. Но у нас был бы квантор
по функциям, которые у нас запрещены. То есть вся проблема фактически в этом и состоит. Мы хотим
ограничиться очень примитивной логикой и тем не менее доказать неперечислимость. Ну можно, конечно,
спросить зачем связывать все руки. Ответ примерно такой. Мы не случайно логику первого порядка такую
простую рассматриваем. Математики хотели убедиться, что они понимают, о чем они говорят, когда говорят о
доказательствах. Поэтому они ограничили себя очень слабыми выразительными средствами, но
достаточными, чтобы любые математические теоремы у них были выразимы. И я напомню, я про это уже
говорил, программа была такая. Теперь мы, конечно, можем содержательно изучать математику, но если
нас волнует вопрос, нет ли там ошибок, то нужно сделать очень просто. Можно все это переписать в
таком формализме. И все математические теоремы превращаются в утверждение, что мы можем из одной
цепочки символов по некоторым правилам сделать другую цепочку символов, построить доказательства. И тогда,
если нам удастся построить такую аксиоматику, скажем, для арифметики, ну мы победили. Конечно,
никто прям такие цепочки в таком примитивном виде строить не будет, но мы по крайней мере знаем,
что если у нас какие-то сомнения будут потенциальные, мы такую цепочку написать можем. Эта программа не
работает. Этим мы выясним. И теория Матарского это простейший намек на то, что эта программа не
работает, потому что мы не можем перечислить истинные формулы. Это очень серьезное препятствие. И проблема в
том, что, хотя наши формулы выглядят очень слабыми, там только кванторы по натуральным числам,
а не по функциональным символам, но мы можем контрабандой поместить в эту самую арифметику
первого порядка кванторы по конечным последовательностям. То есть прям в полном объеме
логику второго порядка мы не можем лизовать произвольные функциональные символы. Но если
нас интересует просто конечная последовательность, существует конечная последовательность, ну как в
этом примере. Ну тогда мы это можем реализовать формулами первого порядка. Это удивительное
открытие, которое сделал Гедель. И соответствующая лемма называется лемма бета функции Геделя. У него
было много функций. Это вот называется бета функция. Но сейчас, наверное, будет перерыв. Давайте
я даже формулировку не буду перед перерывом писать. Напишу после перерыва, докажу, и мы продолжим.
А и прямо уже. Значит, в чем состоит лемма бета функции? Представьте, что у нас есть последовательность
натуральных чисел. Утверждается, что ее можно задать тремя числами. В каком смысле? Вот в каком.
Что для любого и, ну и понятно от единицы до n, разумеется, то есть для этой последовательности,
выполняется такая вещь, что x и t сравнимо вот с этим числом a по модулю и умножить на b плюс 1. То есть
мы задаем нашу последовательность так, мы задаем некоторое одно число, а потом берем его остатки
по модулю некоторых чисел, принадлежащих некоторой в геометической прогрессии с разностью b. И остатки
будут правильные. Это вот даже я давайте припишу именно остаток, ну чтобы была однозначность,
потому что вообще-то сравнимость по модулю это неоднозначно, там много элементов сравнимо,
а вот прямо остаток. Ну и это, заметьте, что вот я еще не стер на предыдущей доске, вот ясно,
что вот эта формула, это условие точнее выразимо в арифметике. Ну одно число сравнимо с другим по
модулю какого-то там несложного арифметического выражения, которое будет термом. Ну и получается так,
что если мне нужно сослаться, мы чуть-чуть, когда я докажу Лему, мы это еще раз разберем, но я прямо
сразу скажу, чтобы сослаться на x и t, мне нужно написать какую-то формулу такого вида и все будет
хорошо. Как это сделать более конкретно, мы посмотрим. Давайте докажем бета-функцию. Ну Лему, а бета-
функция это на самом деле не сложное упражнение в теории чисел или в алгебре. Давайте смотреть. Во-первых,
я хочу гарантировать, чтобы b было больше любого x и t. Ну у меня остатки получаются по модулю b
плюс 1, 2b плюс 1 и так далее, и я сразу хочу гарантировать, что b больше, чем x и t. Для этого я
сделаю вот, что я возьму произведение всех x и t плюс 1, ну и по другой причине умножу, наверное,
факториал. Вот такое b возьму. Просто b совершенно конкретно. С a чуть сложнее. Значит, чтобы найти a,
я вначале хочу доказать такое утверждение, что числа в этой арифметической прогрессии взаимно
просты, ну если они различные, если одинаковые, конечно, не могут быть взаимно просты. То есть,
вся эта арифметическая прогрессия, ну первая ее энчленов, на самом деле невозможно писать
бесконечную арифметическую прогрессию, в которой все члены были бы взаимно просты, но сколь угодно
длинную, вот мы написали. Сейчас мы проверим. Почему так? Ну, смотрите, давайте рассмотрим разность этих
двух чисел. Это будет и минус g, прошу прощения, на b. Правильно? Разность двух таких чисел, единички
сократятся, останется разность и g умножить на b. Так вот, если есть простой делитель общий у этих
чисел, то он, конечно, будет и простым делителем вот этого числа. Куда деваться. Но, смотрите, он тогда
обязательно будет делителем b. Почему? Потому что он либо сразу делитель b, либо делитель вот этой
разности. Но эта разность меньше n, а мы взяли b специально, так заранее умножили на n факториал,
поэтому любое число меньше n, оно точно делитель b. Мы об этом позаботились. Значит, приходим к
противоречию, потому что вот этот простой делитель, он будет делителем b, но, смотрите, тут у нас число,
которое дает в пределении на b остаток 1. Не может простое число быть делителем b и делителем числа,
которое дает остаток 1. Если оно делит b, то тогда число, которое мы единичку добавили, оно уж точно не
будет на это простое число делиться. Вот такое доказательство от противного. Подождите, это мы
проверили, что они взаимопростые, а что дальше? Ну, а дальше известное дело, дальше китайская
тарелма об остатках. У нас есть условия, много условий, n штук, но эти условия позаимно простым
модулем. Китайская тарелма нам говорит, есть такое число, а что мы все эти условия удовлетворим.
Ну и все. Теперь давайте вернемся. Значит, это такая важная функция. Давайте вот посмотрим на примере
возведения степень, как ее использовать. Смотрите, я хочу задать эту последовательность. Я это делаю так.
Ну, длина у меня уже есть, поэтому я просто пишу, что существует a, существует b. Такие, что
для любого и из того, что и, ну я опять-таки пишу обычные математические записи,
и лежит вот в таком диапазоне, следует, что следует, следует, что, вот смотрите, мне теперь надо
записать рекуррентное соотношение, как я это делаю. Я пишу, существует u, существует там, не знаю, t. Такие,
что остаток отделения, значит, а у меня кодирует последовательность, а тут я должен написать и b плюс
1, а остаток должен там равняться u, скажем, и остаток i плюс 1, b плюс 1, a, t, значит,
вот должны выполняться такие условия, и, нет, лучше следует, лучше тут импликацию написать,
то тогда t больше, t равняется y. Это я записал рекурренту, и нужно еще написать отдельно формулу,
но я могу с теми же переменными, потому что это, тут вот будет вот такое вот условие, что остаток по
модулю z, b плюс 1, а какой-то u, а, ну тут достаточно одного u, и u равняется x. Давайте смотреть,
что эта формула означает. Ну, вот эта вот часть, она как раз задает нам рекуррентные условия. Я
хотел бы в этом месте написать, вот как я там писал, что следующий член равен предыдущему умножить
на y, но буквально я так написать не могу, потому что мне пришлось бы писать что-то такого типа
t и плюс первое равно t и t умножить на y. Это вот если вводить функциональные символы,
было бы вот так, очень просто записано. Что я делаю вместо этого? Я заменяю, используя функцию
йодоля, я заменяю обращение к функциональному символу на такую формулу. Я приписываю кванторы
существования по вспомогательным переменным, которые будут как раз указывать на вот эти вот
значения вот этих термов. Я говорю, что для них выполняются условия бета функции йодоля, а потом
пишу. Нет, тут все-таки нужно конъюнсу написать, а то будет плохо. Нам нужно, чтобы все эти три условия
выполнялись. Ну да, как я и написал во второй части. И дальше я пишу уже вот с подставленными
этими вспомогательными переменными вместо соответствующих функциональных символов.
Почему это одно и то же? Смотрите, мы считаем, что у нас существует вот некоторые a и b,
которые кодируют нашу последовательность. А дальше вот здесь остаток же определен однозначно,
поэтому такое у, чтобы это было истинным, оно единственное. И ты оно единственное. И у нас
конъюнс еще с третьим условием, что они друг другом соотносятся к умножению на какое-то число.
Поэтому это получается равносильное утверждение. Ну и последнее, это просто другая тамарная формула,
что последний член последовательности равен x, вот как у меня здесь написано. Здесь мне тоже нужно
заменить обращение к члену последовательности по индексу на вот такую вот выражение, что у нас
есть квантор существования по вот такому предикату. Ну это конкретный пример с возведением степени.
Но я надеюсь, становится понятным, что так же можно действовать всегда. Если у вас есть какое-то
логическое условие, в котором есть квантор по конечным последовательностям, тут существенно,
что мы должны знать ограничение длину последовательности, то мы его можем, мы соответствующую формулу,
можем превратить формулу первого порядка, заменив квантор по, вот у нас по-хорошему должен
был быть квантор, существует t с некоторым свойством. А я его заменяю такую вот формулу,
дальше что-то, вот на такую, где в каждую атомарную формулу делается вот подстановка
такого же вида, как здесь. Получаем равносильную формулу, то есть мы получаем возможность выразить
утверждение, которое требует использования каких-то последовательностей в виде формулы первого
порядка. Вот это очень мощный прием, он на самом деле объясняет, почему арифметика очень выразительная.
В арифметике можно самые разные утверждения сформулировать. Ну, например, можно сформулировать
формулу арифметики, которая задает асимпатический закон распределения простых чисел. Если вы помните
это вот что такое, это π от n это количество простых чисел, которые не превосходит n. Значок
эквивалентности здесь, это самый обычный смысл анализа, то есть отношения с тремецкие единицы. Ну,
а n это n, а ln это натуральный алгорифм. То есть кажется удивительным, что натуральный алгорифм
появляется в пределы. Вот это можно записать в виде формулы арифметики. Используя последовательности.
И идею вы уже можете так примерно оценить, что такое предел. Ну, это предел последовательности,
значит мы знаем, что для любого эпсила найдется достаточно длинная последовательность, которая
хорошо приближает, так можно задать логарифм. Также можно примерно задать саму функцию π от n.
То, что их отношения близко к единице тоже можно задать, это тоже некоторое предельное соотношение,
которое вот таким вот образом выражается. Нет, у нас только натуральные числа. То есть асинтетические
законы распределения простых чисел это про натуральные числа утверждение. Логарифм это так.
Логарифм можно выразить, но опять-таки в сущности нужно научиться выражать,
число е, которое является пределом, замечательным пределом. Это тоже можно выразить как последняя
степень, точнее как отношение. Нам все время нужны рациональные числа, но смотрите, рациональное число
это пара целых. И в сущности переписать что-то про рациональные числа в виде утверждений про
натуральные достаточно легко. А если нам нужны знаки, ну это еще один бит. Знак всегда можно к
натуральному числу добавить. Итак, исторически удобно считать, что мы имеем натуральные числа,
которые начинаются с нуля, для индукции. Поскольку для нас основной прием, я говорил про рифметику
Пиано, там помимо тривиальных свойств, свойств рифметических операций есть аксиома индукции,
а ей нужен ноль. Поэтому логики предпочитают смотреть только на неотрицательные целые числа. Но
выразить отрицательный никакой труда нет, если у нас есть все эти возможности формул первого
порядка. Хорошо, но нам симпатический закон не нужен, нам нужна машина тюринга, точнее условия,
что она не останавливается. И вот теперь я наконец выхожу на финишную прямую в доказательстве
теории Амитарского. И тут придется повозиться, потому что ну это так не то чтобы это кажется
очень удивительным, но что-то надо сделать, потому что как представить в виде формулы, рифметики,
утверждение о том, что машина тюринга не останавливается. Ну давайте представлять,
то есть фактически мне нужно построить сводимость. У меня есть машина, которая я напомню, у нас
значит там что, алфавит, множество состояний, пустой символ, маркер начала, начальное состояние,
финальное состояние, ну и функция переходов. И вот нам надо по такой машине строить опять-таки
такую-то формулу в рифметике, которая истинна в рифметике, если машина не останавливается.
Ну как это сделать? Во-первых, конечно, нужно как-то машинокомбинаторное понятие,
хорошо бы его как-то в числовое превратить. Сейчас я покажу как. Это удобная такая вещь. Я напомню,
что конфигурации машины я задавал вот такими словами, где у и в это слова в алфавите, а q это
состояние. То есть правило то же самое, что было в прошлый раз. Мы у и в записываем подряд и считаем,
что головка находится на первом символе слова v, а правее на ленте, правее символа слова v уже
только пусты. Вот такое соглашение. Это конфигурация. Ну теперь мне нужны числа, и я сопоставлю этой
конфигурации три числа. Напишу их как функции. Ну q, а c это q. Это легко. У нас всегда есть выделенный q.
Чтобы писать дальше, мне сразу нужно договориться о том, какие множества являются алфавитом,
какие множеством состояний. Давайте считать, что символы алфавита это числа от нуля до какого-то
n-1. Состояние это, ну, следующее число. То есть от n до какого-то числа q. И сразу договоримся,
что пустой символ у нас означает ноль, это нам будет удобно, ну а маркер начала-конца пусть
будет обозначать единицу, это уже не столь существенно. То есть я первым делом привожу алфавит к числовому
виду. Ну понятно, что вопрос об остановке и неостановке машины Тюринга от того, что я переименовал
символы алфавита, и состояние никак не изменится. Ну потому что я точно также естественную функцию
переходов переопределю. Теперь давайте смотреть. Вот у нас есть лента, вот сюда смотрит головка,
вот это вот слово V, это слово U. И вот L это такое число. Мы смотрим на U, как на иночную запись
некоторого числа. Ну самым обычным образом, младший бит справа. А R, C определяется чуть хитрее. Это
тоже запись, но в другом порядке. Вот тут у нас младшие биты вот здесь, а тут у нас младшие биты
слева стоят. Ну я это записал с помощью функции обращения, то есть V от R это значит, что мы слово
записали просто в другом порядке. Ну и я предполагаю обычный для математики способ записи, когда старшие
разряды идут левее. На самом деле удобнее, чтобы они левее шли, и младшие разряды, но так уж мы
привыкли. Давайте какой-нибудь конкретный пример. Вот пусть у нас есть конфигурация. Ну какая, значит
у нас маркер конца, во-первых, должен быть, потом 2, 2, 4, 2, 2. Вот это слово задает конфигурацию. Значит,
здесь у нас мы видим, что N, ну мы можем положить 3 или, нет, 4 уже не можем. N должно равняться 3,
потому что смотрите, у нас хотя бы один символ должен быть в символовом состоянии, а то 4. Но тогда,
а нет, ну можем, нет, можем 3. Ну пусть будет равно 3. Для простоты тогда нам нужно что сделать,
значит Q это 4, а L это что? Это троичная запись, число, троичная запись, которого 1, 2, 2, это значит 2,
это 6, это 8 и еще 9, 17. Ну а R, а ну тут вот давайте я, чтобы было понятно, несимметрично напишу,
0, 2. R тогда я должен прочитать в другом порядке, справа налево, снова взять троичную запись,
и это будет просто 3 умножить на 2, 6. Вот такие функции. Эти функции почти однозначно задают
конфигурацию. Давайте подумаем, какую информацию о конфигурации мы теряем. Вот пусть у нас есть
3 числа. Состояние просто задано, это одна из функций. Теперь смотрим на L и R. L это то, что написано
слева от головки, причем последний символ должен быть обязательно единицей. У нас есть маркер
конца, я напомню, слева. Так что тут все однозначно. А справа немножко сложнее, потому что у нас
конечно есть вот это вот слово, которое отвечает о нычной записи R, C. Но вообще говоря, тут могли
стоять еще нули, допустим. Ну и на ленте тоже вот может быть такой бесконечный суффикс из нулей,
из пустых символов. Но это не страшно, потому что мы знаем, что если мы дописываем нулевые цифры
в нычное представление числа, то этого не изменится. Ну в смысле, дописываем самые старшие разряды. Мы
же теперь читаем справа налево, то есть у нас это попадает в старшие разряды, допустим, 2, 0 и,
там скажем, 0, 2, 0. Но это одно и то же число. Поэтому теряем мы информацию, которая нам и не
очень нужна. На самом деле состояние ленты мы по этой тройке чисел восстанавливаем однозначно.
Ну это хороший шаг. Что дальше? Дальше нужно понять, как меняются эти функции за такт работы.
Я утверждаю, что они меняются просто. Просто в том смысле, что изменения можно арифметическими
условиями задавать. Ну так же, как в прошлый раз. У нас есть разные команды переходов,
поэтому мы должны рассмотреть несколько случаев. Допустим, исполняется такая команда.
То есть у нас было вот это вот слово В, самый левый его символ А, вот тут вот слово У. Оно никак не
меняется, значит у нас что изменилось? Тут стало а штрих, у не изменилось, ну оставшаяся часть В
тоже не изменилась. Что произойдет с функциями? Ну давайте смотреть. Значит это у нас была
конфигурация С, это стала конфигурация С штрих. Q от С штрих чему равно? Ну Q штрих, ясное дело,
у нас состояние поменялось на Q штрих. Чему равняется L от С штрих? Тому же самому, что и было.
Слово У у нас вообще не изменилось, головка не сдвинулась. А R изменяется. Давайте посмотрим,
как оно изменяется. Мы должны в самом младшем бите, ну не бите, а там нити,
слово В заменить цифру А на цифру А штрих. Как это делается? Делается это так, мы должны взять
это R от С штрих, взять R от С, вычесть А. А что такое А? А у нас нет. Но у нас есть возможность взять
остаток по модулю N. То есть мы берем R от С и берем остаток по модулю N. Что такое первая цифра в
н-ичной записи? Это остаток отделения числа на N. Так всегда, в любой системе счисления. Ну вот,
то есть мы вычили А, а добавить должны А штрих. Это мы уже можем вот прям так написать, потому что
А штрих — это некоторый конкретный символ, мы его просто так вот как число и добавим. Отлично.
Давай теперь посмотрим, что будет, если мы хотим выразить команду движения, ну куда. Ну давайте,
обычно проще вправо. Давайте посмотрим. Значит, снова решу такую картинку. Значит,
тут у нас А, вот тут В штрих, тут У, тут стоит головка. Теперь мы сдвинулись вправо. Вот само
слово В штрих, от этого движения не изменилось. Изменился вот этот символ. У тоже не изменился,
но изменилось положение головки. Значит, что у нас произойдет с нашими функциями,
которыми кодируется конфигурация. Ну, у изменилось так, как написано в правиле перехода, это всегда так.
А как Р изменилось? Давайте смотреть. Было У, теперь мы сдвинули все на разряд, увеличили,
и на самый младший разряд добавили А штрих. Что это такое? Это такая вещь. Это мы добавили А
штрих плюс Н умножили на РС. А штрих теперь часть У. Мы вправо сдвинули. То есть Р от С
штрих, это Н ищенная запись вот такая. У, а потом А штрих. Все, извиняюсь, извиняюсь,
извиняюсь. Все правильно. Я имел в виду Л, а говорил Р. Все, прошу прощения. С Р хитрее. С Р надо
подумать, что будет, но не сказать, что очень сложно. Мы должны просто-напросто поделить. Смотрите,
мы забываем последний разряд. Это то же самое, что целочистное деление на Н. То есть мы должны
взять Р от С, ну и давайте я как-нибудь это напишу вот так. Див на Н. Заметьте, что все эти условия,
которые я выписываю в рифметике, очень легко выражаются. Ну вот я уже стер вот эти вот простейшие
предикаты. Ну ясно, что целочистное деление, взятие остатка, это все выражается с помощью тех предикатов,
которые я описал. Теперь последний случай. Как мы помним с прошлого раза, он менее приятный.
С 2х влево. Ну тут нужно, значит вот у нас где-то стоит головка. В штрих, тут у, а с штрих. Теперь у
нас головка переехала на один символ сюда. Здесь написано штрих, ну а здесь по-прежнему написано
в штрих. Как это записать? Ну опять-таки нет проблем записать функцию Q, потому что просто Q
штрих. Теперь давайте смотреть с L. Что у нас получается с L? Мы оставляем, ну вот так же как вот
здесь, мы оставляем только часть Q, которая отвечает всему за исключением младшего разряда. Значит мы
должны писать L с, ну вот поделить на N. Потому что вот это уже будет входить в новое V. А что
такое это? Давайте теперь вот самое сложное, это записать R с штрих. Значит тут у меня написано
что-то, давайте я B обозначу. Ну что такое B, мы знаем. B это просто-напросто L с по модулю N. Это
вот B. Оно заведомо добавится. Дальше нам нужно заменить A штрих на A, но это вот как в самом первом
случае. Мы должны писать вот такую довольно замысловатую формулу. Никуда нам от этого не
деть сам R с минус R с по модулю N. Нет, ну можно сразу, можно сразу здесь написать плюс A штрих. То есть можно
же себе это представить так, что мы вначале заменили A на а штрих, вот как в самом первом случае,
не двигая головку. А потом головку сдвинем. Сдвиг головки даст нам умножение на N и добавится вот
это вот самое B. Ну формулы выглядят уже все сложнее и сложнее, но они закончились. Значит у нас
команды трех типов. И этих команд конечное количество. Давайте вернемся к началу, к машине.
Там есть функция дельта, функция переходов. Это набор пар. Первый элемент пары символ алфавита,
то есть число от 0 до N-1. Второе состояние число от N до Q. Соответственно мы можем написать формулу.
От шести параметров. Которая истина тогда и только тогда, когда штрихованные параметры выражаются
через нештрихованные, ну вот соответственно с таблицей перехода в машины Q. Почему мы это можем
сделать? Для того, чтобы применять эти правила нам нужно знать A. Ну про A мы знаем, что это такое,
мы это уже использовали. Это просто-напросто R от C по модулю N. Соответственно мы должны взять
дизьюнцию по всем правилам, там по парам AQ. Каких условий? Что A вот равняется R от C по модулю N.
Ну по Q даже можно не брать, Q у нас есть. Давайте Q я сотру вот дизьюнцию по A. Но конечно не только
это условие, а нужно еще дописать вот условия, как-нибудь звездочка напишу. Одну из этих трех
условий. Какое зависит от пары Q и A? То есть тут будет как-то так выглядеть. Значит,
ну да, все-таки мне нужно написать дизьюнцию еще и по каким-нибудь там tilde Q и A таким,
что вот сдвиг 0. И тут дописывать еще условия, что tilde SQ равняется Q. Потом аналогичную дизьюнцию
сдвиг плюс 1 и аналогичную дизьюнцию сдвиг минус 1. То есть у нас получится такая довольно сложная
логическая формула, но булева. То есть мы получаем дизьюнцию условий. Почему нас устраивает дизьюнция?
Потому что это же однозначно определенная вещь. То есть из этих членов будет истинной только 1. То
есть мы A и Q выберем однозначно способом. А потом уже есть условия связи штрихованных и не
штрихованных. Если какое-то из условий нарушается, ну формула ложна. То есть мы неправильно записали
переход. Прошу прощения. Я заговорился и написал ерунду. Нет, чтобы было понятно из предыдущего,
нужно конечно писать LR и Q'L'R'. Прошу прощения. То есть у нас функции Q, L и R. И вот мы их и задаем.
Но вот этот момент, он очень важный. То есть в сущности он критически важный. Теперь у нас
появилась арифметическая формула, которая выражает корректность перехода от одной тройки к другой.
Тройка задает состояние машины. Как теперь записать условия, что машина остановилась за Т-тактов?
Нам нужно писать так. Для любого И из того, что И меньше Т, следует
вот этот вот, что у нас корректно выполнен шахт перехода.
Но это еще не все. Еще нужно потребовать выполнения начального условия. Какие у нас начальные условия?
Но я напомню в начале. У нас состояние это N, а тут пусто, но вот здесь есть единица, маркер конца.
Поэтому мы должны написать так, что L от нуля равно единице и R от нуля равно нулю и код нуля равно N.
Это начальные условия. Чего нам еще не хватает? Еще нам не хватает условий остановки, что И по Q,
принадлежащим множеству финальных состояний, должно выполняться вот такое условие. Q равняется код T.
Последнее состояние финальное. Вот это условие остановки за Т-тактов. Конечно, я его пишу,
используя функциональные символы. Но для этого вспомним про лему йоделя. То есть на самом деле,
вместо вот этих трех функциональных символов мне пришлось бы написать так.
И дальше, там, где вот я пишу, у меня есть вот такая формула, куда входит 6 выражений с атомарными символами.
Я должен также, как в примере со степенями, повесить соответствующее количество кванторов, выразить,
что вот эти вот места, которые у нас заполнены, они выражаются по бета-функции йоделя через номера.
Ну и дописать то условие, которое у нас в формуле степь, там будут какие-то условия. Вот получается
такая достаточно сложная вещь. Ну и здесь то же самое нужно сделать, избавиться от L, R и Q.
Ну получается вот такая достаточно сложная формула, но она выражает остановку за Т-тактов.
А нам нужна формула, которая выражает не остановку. Давайте вот эту вот всю формулу с остановкой
стоп назову. Ну даже Т я не буду писать, потому что и так параметры-то видно. Для любого Т не стоп.
Вот нужная нам формула. Смотрите, если я по машине построил такую формулу, вот как у меня написано,
что она означает? Что какое бы я не взял число Т, условие остановки будет нарушено.
Условие остановки означает, что мы можем подобрать такие функции или вот такие 6 чисел, чтобы
выполнялись вот эти вот условия. Машины останавливаются тогда и только тогда, когда мы
такой подбор можем сделать. Ну значит она не останавливается за Т-тактов, если взять отрицание этой
формулы. Ну и это доказывает сводимость. То есть мы построили по машине Тюринга, построили
формулу, которая истинна в арифметике, если и только если машина не останавливается на входе.
Ну значит и ремонтарского доказано. Заодно можем выяснить на какой уровне арифметической
иерархии это все дело попадает. Смотрите, мы берем отрицание этой формулы, значит кванторы
существования превратятся в кванторы всеобщенности. Тут появится квантор существования, но здесь опять
появятся кванторы всеобщенности. Вот когда мы делали постановки, помните, там нам были нужны кванторы
существования. Значит получится что-то такого типа. Для любого существует это вот этот, и потом
еще раз для любого. Ну и мне кажется, что все. Нет, он нужен, конечно, значит тут будет стоять
существует, но он вот сюда вот сюда уйдет, как квантор всеобщенности. В общем, я не поручусь,
но вроде бы на третий уровень. То есть это надо, конечно, аккуратнее расписать. Не поручусь,
потому что там еще нужно посмотреть, не произойдет ли какого-то взаимодействия. Вроде бы нет,
мы все кванторы существования просто запишем однородно. Здесь действительно есть квантор
всеобщенности. Он отсюда уйдет, как квантор существования, а когда мы будем брать отрицание,
это превратится в всеобщность. Из посылки, когда мы кванторы существования, мы выносим их как
кванторы существования, они тоже заменятся на кванторы всеобщенности. То есть вроде бы лишнего
уровня там не возникает. Ну вот как-то так. То есть на третий уровень попадает. Ну желающие,
те, кто хорошо понимают по рифметическую иерархию, могут попробовать доказать,
что истинные в рифметике формулы полны на этом уровне. То есть я не думаю, что есть какое-то
препятствие, раз уж оно попало на какой-то уровень, оно, скорее всего, должно быть полным. То есть
любая задача с третьего уровня рифметической иерархии, по идее, должна сводиться. Но там могут быть нюансы,
я не уверен, я, честно говоря, никогда про это не думал. Тут же еще дело такое,
но все, конечно, с рифметической иерархией хорошо, но на самом деле я вас обманываю немножко.
Это же ограниченные все кванторы. Вот и меньше t. Здесь, когда мы будем брать квантор существования.
А вот эти вот кванторы уже не очень понятно, чем ограничены, потому что это коды в бета-функции,
они, бог знает какие, непонятно. То есть у нас есть неограниченная переменная t, и вот здесь вот коды,
которые мы используем, они тоже не очень, а нет, ну подождите, они не понятно, чем ограничены,
потому что lr, они должны кодировать lr, а lr, вообще говорят, сколь угодно, большие числа.
Поэтому, да, у нас, да, ну тогда это квантор существования, вот этот пои пропадает.
Все-таки копии перечислим? Не, ну что не копии перечислим, вроде бы убедительно на уши повесил.
Ой, так, а время уже вышло, я прошу прощения. Ну это мы уже обсуждаем детали, доказательства я
закончил. Сейчас, ну подождите, ну все-таки, ну очевидно, что истинные к ложным сводятся,
просто мы берем навешиваю на отрицание. Соответственно, ложные тем самым тоже не перечислим.
С другой стороны, они отличаются на разрешимое множество, поэтому дополнение к r, оно тоже
не перечислимо, конечно. Что-то я немножко запутался. Ну, тут надо внимательнее посмотреть на определение
арифметической иерархии, может быть, там, мне казалось, что если какой-то квантор ограничен,
уже, ну там, переменная, которая...
