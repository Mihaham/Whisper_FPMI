Что мы научились кодировать эффективно под множество
маленького множества, то есть если у меня есть множество
из этих n элементов, то я могу любому под множество
сопоставить битовую строчку, где на этом месте стоит
единица, если элемент включен в множестве, ноль если не
включен.
Ну и соответственно эту битовую строчку могу воспринимать
как число в дольше системе числения и хранить подножие
как числа.
Ну вот, я буду жить обычно в парадигме, что n там какой-нибудь
маленький, а пора это 30 или 60, так чтобы это число помещалось
в какой-нибудь простой тип, маленький там int или long
clonk.
Ну давайте начнем с такой видимо задачи, поиск максимальных
клики в графе.
Задача такая, у вас есть граф, наверное, на вершинах,
и между какими-то парами из них проведены ребра,
то есть просто какие-то вершины соединены отрезками,
соединили ребрами.
Еще вам сказано, какие есть ребра, ну скажем, граф
задан на матрице смежности своей, вот, и кликой в графе
называется какое-то множество вершин, которые попарно
соединены ребрами.
Например, вот эти три вершинки образуют клику, потому что
между каждой парой из них есть ребро, есть такое-такое-такое
ребро, между каждой парой есть ребро.
А, например, если бы я рассмотрел вот эти три вершины, то они
клик уже не образуют, потому что вот здесь вот нет ребра.
Ну и задача, собственно, найти клику максимального
размера в данном графе, на вершинах.
Вот, ну давайте сразу напишем решение за что-то в стиле
два в степени N.
Ну, значит, про эту задачу тоже известно, что она NP-трудная,
то есть пока что никому никаких полинональных алгоритмов
для нее не известно, и, ну, в общем, есть большой
скептицизм в отношении того, что они вообще, такие
алгоритмы существуют.
Поэтому, ну, вот экспонентов в таких случаях обычно
лучше, на что можем рассчитывать.
Вот, ну, остальная идея здесь очень простая.
Давайте просто переберем все возможные подножия
вершин, их будет ровно два в степени N, и для каждого
подножия проверим, хорошее оно или нет, то есть проверим,
является оно клик или нет.
И затем просто из всех хороших подножий, всех клик
выберем максимальное по мощности, то, где наибольшее
число битов хранится.
Вот, ну, как проверить, что данное множество вершин
является кликой?
То есть надо, видимо, проверить, ну, наивно, можно было просто
пробежаться по всем вершинам и проверить, что между каждой
парой вершин есть ребро, если они в множестве лежат.
Вот, ну, это было бы что-то в стиле два в степени N на
N в квадрате, потому что если я каждую пару вершин перебираю,
то там N в квадрате будет все множить.
Ну, можно как-то делать.
А что мы делаем в прошлом семестре?
Ну тут они отрезки, тут же как бы комбинаторный
прямоугольник, типа у вас там 1, 10, 13 вершина, ну в смысле
вот такие столцы, такие строки, это как бы, ну,
подматрица вот такого именно, вот такого вида, да, это
уже не прямоугольник, а что-то вот такое.
И тут считать сумму как-то быстро непонятно как.
Вот.
Ну, мы давайте сделаем примерно следующее.
Давайте мы ведем динамику, которая нам для любого множества
вершин говорит множество тех, которые являются соседями
всех вершин этого множества.
Ну, и правильно давайте напишу, что dp вот в какой-нибудь
маске, где маска это множество вершин, да, какое это множество
вершин, значит, это множество всех вершин графа,
которые соединились со всеми вершинами из маски.
Так, мы, видимо, на всякий случай давайте еще вторую
динамику.
Значит, это будет что-то типа int, да, потому что у меня,
ну, я буду хранить множество, но множество я храню как
число, да, как обычно.
Вот, поэтому это будет что-то intовское, и мне нужна еще
видимо вторая динамика, булевская, просто является
ли множество клика.
Да, это просто булевский флаг является ли множество
клика или нет.
Вот, тогда что можно сделать?
Смотрите, вот представьте, что мы рассматриваем какое-то
множество вершин маск, мы хотим проверить, является
ли оно клика или нет.
Тогда нам достаточно сделать на самом деле следующее,
мы можем отщипать отсюда одну-любую вершинку v и проверить
во-первых, что все остальное это клика, во-вторых, что
v соединяется с ними со всеми.
Так, это я даже получается лишним, ну ладно, бог с ним,
пусть останется.
Значит, еще раз, чтобы маска была кликой, я могу выкинуть
любую вершину из нее, проверить, что все, что осталось, это
клика, а также, что v со всеми ними соединена.
Это как раз и будет означать, что все ребра в этом множестве
есть, то есть все ребра внутри здесь есть и между v и всеми
ними тоже есть.
Вот, тогда мне достаточно сделать следующее.
Клик от маски равно true, если, ну давайте пишем, равно
true, если для некоторой вершины v, лежащей в маске, выполнено
две вещи.
Во-первых, маска без вершины v это клика, ее так очень
вольно напишу.
Ну понятно, чем я имею в виду маска, это множество
вершин, set-minus это разность множеств, v это множество
вершин.
В коде это надо было бы, наверное, реализовать как-то
маск, xor, 1 меньше меньше v.
Ну вот что-то такое, потому что 1 меньше меньше v это как
раз маска, отвечающая только вершинке v, потому что здесь
есть только один бит на v этом месте, это как раз маска,
содержащая только v.
Ну и поскольку v лежала в маске, то их xor как раз вот
эту вот единичку на v этом месте уничтожит и останется
как раз маской без v.
Значит, это нормально?
Во-первых, вот эта штука должна быть равна true, во-вторых,
v должна принадлежать dp от маск без v.
Да, мне нужно, чтобы v была вот в этом множестве как
раз, чтобы v попало в множество вершин, каждая из которых
соединяется с каждой вершиной маск без v.
Похоже на правду.
Второе слово как раз означает, что все вот эти вот ребра есть.
Так, ну хорошо.
Значит, тогда как бы клик мы более-менее через клик
уже пересчитали, выразили, точнее, надо теперь понять,
как dp-шку посчитать, то есть как для данного множества
вершин найти множество тех, которые с ними со всеми соединены.
Ну давайте тоже какие-нибудь предложения жду.
Вот, если у нас есть какая-нибудь v, то как выразить dp-маск
через dp-маск без v?
Ну пересечь скорее, да, пересечь.
Значит, можно заметить, что dp-маск это dp для маски
без v, а в пересечении с, ну по факту можно просто
описать dp просто для v, да, фигурную скобку все-таки дорисую
для приличия.
Ну а потому что еще раз, что такое dp от маски?
Это все такие чуваки, все такие вершины, которые соединены
со всеми вершинами этого множества.
Но при этом, если я для вот этой меньшей маски, для маски
для множества меньшего размера знаю все вершины,
соединенные с ними со всеми, то есть вот есть у меня маска
без v, есть все вершины, которые соединены со всеми вершинами
этого множества, вот они.
Тогда если у меня в маску вот этого добавляется новая
вершина v, то мне нужно, у меня появляется новое требование,
что все эти вершины должны быть не только соедены,
но еще и с v-шкой.
Поэтому на них докладываются допусловия, ну и по факту
я пересекаю просто два множества, те, которые соединены
со всеми здесь, и еще и соедены с v.
Вот это у меня есть dp-шка v.
Ну, что-то такое.
Значит, тогда можно сделать следующее.
Давайте напишем алгоритм.
Как он будет устроен?
Ну, во-первых, раз я выражаю dp для каждой маски через dp
по одноэлементным множествам, давайте я изначально для каждого v
найду dp от множества из вершинки v.
Ну, это понятно, как сделать, можно за квадрат.
Это просто сделать.
Я для каждой вершины v перебираю все вершинки u.
Если есть ребро uv, то я в эту маску включаю, иначе не включаю.
Да, это еза за квадрат.
Для каждой вершины насчитываю маску соседей, по факту.
Вот. Дальше мне нужно...
Ну, и можно здесь же написать, что, скажем, клики
от одноэлементных множеств.
Ну, точнее, любое одноэлементное множество это клика.
Если мы берем одну вершину, то там любые две вершины соединены ребром между собой,
потому что там всего одна вершина.
Значит, каждое одноэлементное множество это клика, ну и все.
А дальше вот эти формулы пересчета для dp для клики.
Дальше для всех маск в порядке...
Ну, явно все в порядке возрастания.
Мы, собственно, пишем вот эти две штуки, вот это и вот это.
Насчитываем.
Вот.
Вот. По формулам с прошлой доски.
Вот. Ну, и когда я пишу в порядке возрастания, можно буквально написать цикл
для всех масок от нуля до два степени на минус один.
Ну, и буквально перебирать их как чисто в порядке возрастания,
потому что, смотрите, у нас обе dp и клика, и dp выражаются через маски,
которые являются под множеством текущей маски.
То есть маска без какой-то вершины v.
Ну, понятно, что если мы просто маской перебираем в порядке возрастания как чисел,
тогда в момент рассмотрения маски вот это уже будет рассмотрено,
потому что это меньшее число просто.
Оно включено сюда, значит, как число, ну там, в дешней системе числения.
Оно меньше.
Поэтому к моменту рассмотрения маски мы все предыдущие уже рассмотрели,
все предыдущие нужные значения уже посчитаны.
Так. Нормально?
Вот. Теперь вопрос, да, как находить вот это?
Ну, нам на самом деле не нужно перебирать все вершины, нам достаточно какую-то одну найти.
То есть чтобы завершить решение, мне нужно показать, как я для любой маски
нахожу какой-нибудь bit в ней,
какую-нибудь вершина, которая в ней включена.
Ну, делается тоже не очень сложно.
Можно делать, например, так.
Давайте раз мы маской перебираем в порядке возрастания,
давайте хранить старший включенный bit в маске.
Давайте не пишу oldest.
Это старший bit в текущей маске.
Ну, поскольку у меня здесь есть некая свобода выбора,
я в качестве V могу выбирать любую вершину множества,
давайте я буду выбирать вершину с наибольшим номером.
Ну, то есть по факту старший bit в маске, который там есть, старшую 1.
Ну, а этот oldest очень легко насчитывать,
если мы перебираем маски в порядке возрастания, 1, 2, 3, 4 и так далее.
Потому что когда у вас меняется oldest,
вот вы перебираете маски в порядке возрастания,
когда у вас в этом двоичном числе сменяется старший bit?
Ну понятно, когда.
Понятно же?
Когда?
Можно сказать так, да.
Можно сказать так, да, действительно.
Начну, давайте еще что-нибудь напишу.
Вот у меня есть сначала такая маска, потом вот такая маска,
потом вот такая маска, потом такая маска, ну и так далее.
Понятно, что старший bit переключается, когда мы переходим к следующей степени двойки.
Вот у меня здесь старший bit был, теперь вот этот старший bit,
когда мы перешли в степень двойки такую-то.
Следующий старший bit, когда мы переходим в следующую степень двойки и так далее.
Вот, ну то есть у нас старший bit переключается, когда у нас маска переваливает за новую степень двойки.
Да, можно, например, чтобы проверить, что текущий число этой степени двойки,
ну мы когда это делали, когда спар стейбл писали, кажется,
как проверить, что число является степень двойки?
Например, можно поцелуете его с предыдущим,
и если получится 0, то значит степень двойки.
Давайте напишем, что oldest увеличивается на 1.
И, да, спасибо, спасибо.
Когда маска и маска минус 1 равно 0.
Ну, потому что если маска это степень двойки,
то маска минус 1 это как раз 0 и все единички, их AND будет нулевой.
Если маска не степень двойки, то там, ну, старшая единица сохранится.
Если маска не степень двойки, то там есть по крайней мере две единицы в личной записи,
и эта старшая единица останется здесь и здесь, и тогда AND будет не нулевой.
Ну вот, поэтому мы получили критерий переключения старшего бита.
Но если мы знаем старший бит, то мы можем просто сказать,
что вот этот вот V здесь – это просто тот oldest, который мы насчитали.
Так, понятно?
Хорошо.
Вот, ну, мы получили даже получается для каждого множества,
мы узнали, является нуклика или нет.
То есть по факту у меня есть отдельный массив,
человек, который хранит просто флаг того, является ли это множество клика или не является.
Дальше нужно из всех этих множеств выбрать самое большое,
являющийся кликой.
Ну, это, наверное, как-нибудь тоже можно сделать.
Либо найти какую-нибудь встроенную функцию в вашем языке программирования,
которая для маски находит количество включенных в ней бит,
то есть размер множества узнает.
Либо можно просто насчитать еще одну динамику,
которая для каждого множества хранит размер множества.
То есть можно для каждой маски просто хранить размер.
И тоже понятно, как он пересчитывается.
Если вы знаете, что V – это один из битов,
тогда размер маски – это размер маски без V плюс один,
потому что одна вершинка новая добавится.
Либо просто как-нибудь понять,
по факту нам надо узнать, сколько в этом числе единичек удачной записи.
Ну, 32 – это все-таки не от единицы, наверное.
Ну, константа. Все константа.
Нет, тут так лучше не говорить,
потому что у нас получается на самом деле N действия.
Вы сделаете.
Поэтому лучше это либо предпочитать,
либо вызвать какую-нибудь функцию,
которая это у меня делать.
В плюсах такое точно есть.
Какой-то поп-каунт считает как раз число единичек.
Ну вот.
Еще раз? Да, да, да.
Еще раз?
Потому что вот здесь я никаких условий на V не накладываю.
V была произвольной вершиной из маски.
То есть какая бы V ни была,
вот это все является клика, если только если верно вот это вот.
Это верно для любого V.
Ну и дальше я просто для удобства выбираю V таким,
какой мне удобнее всего хранить.
Ну, могу им сказать для любого.
Ну, это типа одно и то же.
Ничего не меняется.
Просто, ну, смотрите, вот здесь я как бы…
Тут слово «некоторое» можно понять на «любое».
Ничего не поменяется от этого.
Не то что надо, нам достаточно получить для oldest.
Можно было бы для любого другого бита,
можно было бы, например, как-нибудь по-умному
вычислять младший включенный бит в маске.
Это как-то тоже наверное делается, но более сложно.
И можно было бы вместо V использовать младший включенный бит.
Ну вот я использую старший, потому что его проще всего находить.
Можно любой другой.
Так. Понятно? Да.
Ну вот, это я говорю.
Либо вы вызываете какую-то встроенную функцию,
которая по числу определяет, сколько в нем единичек.
Либо вы еще одну DP-шку насчитываете,
которая для маски возвращает количество единиц.
И она как-то так же пересчитывается,
что если вы знаете вот сколько единиц здесь,
то вот здесь на одну больше и все.
Так.
Хорошо. Теперь давайте обсудим решение
за ассинточку покруче.
Два степени напополам.
Соответственно, если это адекватно работало там
для N порядка 20-25,
то здесь уже N порядка 50-60 возможно.
Будет нормально работать.
Вот.
Ну, здесь основная идея называется
meet in the middle.
То есть давайте мы разделим
нашу задачу на две примерно равные части.
Поделим нашу задачу пополам.
Скажем, вот здесь N пополам
первых решенграфов,
и здесь N пополам оставшихся решенграфов.
Ну, если они нечетные, то там
примерно поровну поделим.
Давайте поделим все вершины
на две равные части, например.
Тогда любая клика выглядит
ну, как-то так.
Ну, это сколько-то вершин в левой доле
и сколько-то вершин в правой доле.
Причем для того, чтобы все это вместе
была клика, мне нужно выполнить
три условия.
Во-первых, вот это вот эта клика.
Во-вторых, вот это вот эта клика.
И в-третьих, для любой пары
отсюда и отсюда есть ребро.
Чтобы были все попарные ребра,
мне нужно, чтобы это было кликой,
это было кликой.
Ну, и все ребра слева направо тоже.
Ну, тогда давайте сделаем примерно следующее.
Смотрите, мне нужно будет
несколько вещей.
Первая идея такая. Давайте перебирать
вот это вот множество.
Потому что эта левая доля
имеет размер примерно на пополам,
то под множество у него как раз примерно
два степени на пополам. Давайте переберем
какое-нибудь под множество, которое является кликой.
Давайте переберем здесь какое-то под множество.
Дальше мне хочется понять,
как его можно продолжить
до клики справа. То есть какие вершины
из правой доли можно к нему подсоединить,
чтобы все вместе была одна большая клика.
Мне нужно вот здесь там кого-то взять,
во-первых, это была кликой,
во-вторых, они все были попарно соединены
между долями.
Мне нужно как-то найти вот такое самое большое множество
из правой доли, которое, во-первых,
само клика, во-вторых, соединено
вот с этими со всеми товарищами.
Так.
Окей.
Значит, иду дальше. Давайте я
для удобства реализации введу
одинаковую нумерацию на обеих долях, скажу,
что здесь вершины пронумерованы
числами от навязанных пополам у нас один.
И здесь тоже вершины также пронумерованы.
Теперь я введу
первую штуку.
Давайте я ее назову DP просто.
Значит, первая DP-шка следующая.
Это вот как раз
для каждой маски вершин левой доли, пусть вот
этот вот маск.
Первое, что я хочу сделать, это определить множество
всех вообще допустимых вершин справа.
То есть я хочу узнать, какие
вершины справа соединены со всеми вершинной
маски.
Это вот на самом деле то, что у меня было
в прошлом случае.
DP вот маск, где маска это какое-то под множество
левой доли, это множество
всех вершин
из R,
которые соединены со всеми вершинами маски.
Но это буквально то же, что было
в прошлый раз, только там у меня
не было такого разделения на левую и правую долю,
а здесь я ищу как бы не все вершины,
а только те, которые в правую долю лежат.
Ну это вот понятно, у меня
две доли левая и правая, я их просто
назвал так неярко.
Насчитывается тоже примерно так же.
Если я
для всех меньших масок знаю DP-шку,
то как посчитать DP от маски?
Ну вот если у меня какая-то маска
в левой доле,
я могу в ней точно так же выбрать любую
вершину V, для удобства
буду выбирать старший бит.
Чтобы посчитать DP от этой объединенной маски,
мне достаточно взять DP
для маски без V,
взять DP
для вершинки V, ну то есть по факту
множество соседей этой вершинки V вот здесь,
и пересечивать два множества. То есть я знаю
всех чуваков, которые соединены вот с этим множеством
вершин, и знаю все вершины,
которые соединены с V-шкой.
Значит их пересечение и будет как раз множество
тех, которые соединены со всеми.
Ну это вот то же самое, что было раньше, пока что.
Хорошо?
Вот.
Это первая вещь.
А дальше, смотрите, мне нужно, ну DP-шка
это хорошо, но это не всем то, что мне нужно.
Пока что DP от маски,
это множество всех допустимых
вершин справа, которые со всеми из маски соединены.
Но теперь мне нужно в этом множестве
выбрать какую-то подмаску,
которая является кликой сама по себе.
То есть если я фиксирую, что маска
это клика, если я взял
DP от маски как множество всех потенциально
возможных соседей, мне осталось
здесь выбрать самую большую подмаску,
самую большую клику, самую большую под клику.
Остается
выбрать
максимальную
клику
внутри
DP от маски.
Вот.
И если я это еще как-то сделаю,
если я для каждого множества вершин
правой доли смогу найти в нем самую большую
под клику, лежащую
внутри этого множества, если я смогу найти самую большую
под клику для вот этой вот
объемлющей маски,
то я просто перебираю маску слева, узнаю
с кем потенциально можно ее соединить и дальше
выбираю в ней наибольшую подмаску, наибольшую
под клику. Тем самым я перебираю
вообще все возможные максимальные клики. То есть я перебираю
вершины слева
и дальше справа выбираю максимальное
по размеру множество, которое с ними
со всеми соединено.
Теперь как вот это насчитать?
Давайте подумаем.
То есть я что хочу?
Давайте я еще как-нибудь назову
subclick как-нибудь.
Значит давайте я
еще как-нибудь
назову это множество, не маск,
чтобы было.
Давайте я назову set.
Я хочу для каждого множества вершин правой
доли, где set это подносит
вершин правой доли,
я хочу определить максимальную
размеру подмаску, размер
под клику точнее,
размер максимальной
клики
внутри set.
Если у вас идея, как можно
это посчитать?
Смотрите, я свел задачу
к следующему. Мне достаточно
для каждого
подмножества вершин правой доли,
для каждого множества set, найти максимальную
под клику внутри него.
Сейчас я рассматриваю эту задачу. Для каждого
подмножества вершин правой доли, найти
максимальную под клику в ней.
Как предыдущая задача
поможет?
Не совсем, она
определяла,
булистский флаг является
множество клика или нет.
А здесь надо максимальное
подмножество являющееся клика выбрать.
Не совсем это
делала, но
как-то должно помочь, наверное.
Давайте фиксируем какой-нибудь set,
давайте фиксируем какой-то множество вершин из
правой доли.
Во-первых, понятно, что если она
сама по себе клика, то
subclick вот сет просто ее размер.
Если
set клика
и
подмножество вершин
правой доли,
то сет просто его размер.
Если
сет клика
то
размер максимальной
под клики в ней, это она сама.
Да, это просто
размер множества сет.
Ну, размер опять как-нибудь мы умеем считать, наверное.
Теперь, если она
не клика,
если она не клика, то из нее явно надо
что-то удалить.
Чтобы получить
максимальную под клику,
по крайней мере, одну вершину точно надо удалить.
Но давайте рассмотрим какую-то одну.
Давайте пусть v какать вершину.
Тогда, как выглядят
все подмножества, как выглядят все
под клики, они либо v содержат, либо
не содержат, тогда
с одной стороны, можно попробовать v просто выкинуть
и взять максимальную под клику в сете
без v. Во-первых, мы можем
взять просто максимальную под клику
в сет
без вершинки v.
Можно просто сказать, что v не существует.
Если у меня
определена максимальная под клика для этого множества,
то, в частности, одним из вариантов является
просто выкинуть v и взять вот здесь максимальную
под клику.
Либо же,
если это действие не опсимально,
то мне нужно
обязательно v взять.
То есть, если v выкинуть не имею права,
я ее тогда обязательно оставляю.
И что можно
сделать тогда?
Да, да, да, все верно.
Значит, если у меня, соответственно,
давайте подпишу, что это v не лежит
в под клике.
Если
она лежит в под клике, если я выбираю
под клики содержащий v, то
под клика обязательно включена в множество
соседей вершинки v. То есть, вот есть
ее какие-то соседи,
то есть она с кем-то соединена, с кем-то не соединена.
Ну и понятно тогда, что
если мне нужно выбрать максимальную под клику содержащую v,
то я v беру,
и дальше просто нахожу максимальную под клику вот здесь.
Это какое-то меньшее множество.
Если я действую по индукции, для меньших множеств
уже нашел максимальную под клику,
то здесь оно тоже посчитано.
Либо я
пишу единичку плюс
subclick
для множества
set
в пересечении с
ну давайте пишу n от v,
где n от v это маска
соседей вершины v.
Вот.
И из этих двух чисел выбираю максимум.
Потому что
максимальная под клика
либо содержит v,
либо не содержит v,
тогда это вот этот вот случай.
Ну как-то это тоже посчитаем там.
Ну как писать маску соседей,
можно просто в самом начале
для всех вершин, ну как мы в самом начале
делали тоже просто задачу.
Мне нужно для каждой v обращать
маску соседей,
просто задачу. Мне нужно для каждой v
определить маску, с кем она соединяется здесь.
Ну за n квадрата легко посчитать. В самом начале
для каждой v я просто насчитываю n от v за n квадрат.
Вот.
Ну мы как бы
сами этого не знаем, но мы точно знаем,
что ответ от либо вот это, либо вот это.
То есть если v лежит в максимальной
под клике, то ответ это вот это, с ней лежит вот это.
Но если я возьму максимум из этих двух вещей,
я как раз переберу оба варианта.
Итого. Получается,
что я теперь
научился считать вот эту вот динамику subclick.
Я умею для каждого множества вершин
правой доли, для каждого сета внутри
правой доли умею находить
максимальный размер под клики внутри нее.
Ну по факту здесь
три случая. Первый случай,
когда сет сам ап себе клика, а это мы проверять умеем.
Мы в прошлой задаче за
два в степени размера множества
научились определять
для каждого подножия, является ли он клик или нет.
Если клика, то можно сразу положить,
что она сама по себе является максимальной
под кликой. Дальше я выбираю
любую вершинку v. Опять же, любую вершину
я умею выбирать. Например, можно
oldest брать. Oldest мы насчитывать умеем.
И для вот этого старшего бита
я выбираю просто максимум из этих двух величин.
И тем самым я вот этот subclick
насчитал за два в степени
n пополам.
Потому что это столько, сколько
всего есть под массой в правой доле.
Теперь, если я вот эту динамику
под кликом посчитал,
остальное уже очень просто
доделывается. Я просто перебираю
все вершины левой доли,
у меня есть все под множество вершин
левой доли. Для них
с помощью
DP-шки нахожу множество допустимых
соседей справа,
я нахожу множество тех
вершин справа, которые соединяются
со всеми вершинами текущей маски
с помощью DP-шки еще одной.
А дальше, внутри этой DP-шки выделяю
максимальную под клику
с помощью gsubclick.
Получается, что чтобы найти ответ,
я делаю следующее.
Значит, ответ
это максимум
по всем маскам
вершин левой доли
являющимся кликой.
Размер маски
плюс,
ну, видимо, subclick
от DP
от маски.
Потому что я буквально выбрал сначала
какую-то маску слева,
затем посчитал DP-шку
это тех, с кем оно в принципе может быть
соединено справа,
и дальше
внутри этого множества, внутри вот этого сета
выбрал максимальную под клику
с помощью subclick.
На этом у меня есть еще отдельная динамика,
которая тоже это считает.
Ну что?
Номана? Нет?
Что?
Что с этим точком? Давайте аккуратно
посчитаем.
Смотрите, вот давайте начнем
с subclick.
Вот я утверждаю, что subclick считается за 2 в степени пополам.
Хорошо.
Просто потому что я перебираю все подносы,
что сет, и вот этот динамик я насчитываю
за вот единицы. Там три случая,
это все за единицу обрабатывается.
Теперь мне что нужно? Мне нужно для каждой
маски слева, во-первых, проверить, что она клика,
это мы умеем делать за 2 в степени
размер множества. Значит, я
еще одну DP-шку за 2 в степени
пополам проверяю, для каждой маски является она клик или нет.
Размер маски я умею
искать.
DP от маски, точнее subclick у меня
почитано, осталось только DP от маски работает.
За сколько работает DP от маски?
Ну, это мы тоже
писали. Давайте повторю формулу,
что DP от маски
это
DP от маски без
произвольной вершинки v
пересечь с
DP от этой самой
вершинки v.
Это тоже еще одна динамика,
которая работает еще за 2 в степени пополам.
Ну и в итоге вот такая симпатичка.
Без всяких умножений
на n.
За чисто 2 в степени пополам,
на какую-то константу, потому что несколько DP-шек,
там типа 4 или 5 DP-шек,
ну все констант.
Ну, потому что я несколько
заметаю под ковер, мне нужно еще
для каждой маски знать,
является она клика или нет. Это еще DP-шка
на самом деле внутренняя.
И вот здесь
мне это нужно тоже сделать, для каждой
сет из правой доли
надо тоже определять, она клика или нет.
Ну, это мы в прошлой задаче делали за 2 в степени размером
множества, мы это умеем делать. Но это вот
еще какая-то внутренняя DP-шка, которая там есть.
Ну вот.
Аманна?
Еще раз?
Хороший вопрос, но он вроде не получается.
Он вроде не получается.
Ну,
а что же все время делить пополам?
Ну вот там, ну не знаю, пусть мы посчитали, да,
нашли здесь максимальную клику, здесь максимальную клику,
а как их склеить?
То есть даже если мы там вот эти как-то
рекурсивные еще поделили и нашли ответ
внутри них, то как мне склеить ответ
отсюда и отсюда?
Ну вот быстрее, чем за столько, непонятно как.
А я
такого ни разу не утверждал.
Я
говорю, что максимальная клика во
всем графе, понятно, ну
слева содержит какую-то клику.
То есть ее прищение слевой доли, как клика.
Вот я все перебираю.
Я перебираю все возможные маски слева, которые являются
кликами, соответственно, которые являются левыми
частями максимальной клики. И дальше их
оптимально, ну
в каком-то смысле жадно, продолжаю направо.
Так, ну ладно, давайте перерыв
тогда сделаем, пять минут.
Значит, постановка следующая. У нас опять
есть какой-то граф на вершинах.
И мы хотим
раскрасить все вершины в
несколько цветов,
в как можно меньше число цветов.
Так, чтобы концы любого ребра были
разноцветные.
То есть формально
нужно найти такое минимальное k,
для которого существует раскраска
всех вершин, не больше чем в k цветов.
Раскраска вершин
в k цветов.
Ну такая, что для любого
ребра его концы разных цветов.
То есть нет одноцветных ребер.
Вот.
Значит, это тоже
NP трудная задача.
Пока что никто ее решать быстро не умеет.
Мы научимся за что-то в стиле
ну давайте я вот так вот
напишу. Два степени
на полинома, там какая-то
N или N квадрата будет, ну там
неважно.
Посмотрим по дороге.
Вот. Задача понятна?
Хорошо.
Значит здесь основное соображение следующее.
Любую
раскраску, любую правильную раскраску
графа можно воспринимать
как разбиение всех вершин на множество
точнее на несколько независимых
множеств.
Потому что если я скажем
для каждого цвета рассмотрю множество
вершин покрашенных в этот цвет.
Вот я нарисую все вершины первого цвета, все вершины
второго цвета, все вершины третьего цвета
и так далее.
То понятное дело, что каждое это множество
является независимым, то есть внутри множества нет ребер.
Множество, внутри которого
нет ребер я буду называть независимым.
То есть это все независимые множества.
И по факту у меня задача
ее можно переформулировать
так. Нужно найти минимальное
K, для
которого все вершины можно разбить на
K не пересекающихся независимых
множеств.
То есть переформулировка
найти минимальное
K
такое, что
V можно разбить
на K
независимых множеств.
Вот.
Хорошо.
Ну, на самом деле
вот эта вот оговорка
про то, что V нужно разбить
на
не пересекающие множества,
на самом деле ее можно опустить.
И вот эта вот формировка
эквалентна такой, что
V просто покрывается
несколькими независимыми множествами.
Вот.
Вот.
Независимыми множествами.
V можно покрыть
K
независимыми множествами.
То есть мне не обязательно требовать, что они
не пересекаются. Они, в принципе, могут как-то пересекаться.
Почему?
Ну, понятно, что если есть разбиение на K независимых,
то есть и покрытие с помощью K независимых.
Разбиение является покрытием.
Кождая вершина где-то участвует.
Ну и, наоборот, если есть покрытиe независимыми,
то если какие-то два независимых
пересекаются,
можно просто из одного подадать вершинки так, чтобы это
вершинeulate исчезла, и будет
как раз разбиение.
То есть можно сделать так, чтобы они не пересекались,
потому что независимым множеством можно удалять вершинки,
оно останется при этом независимым.
Будет вот эта вот множество и вот это.
И как раз мы избавимся от пересечения,
и таким образом пересекаются множества,
пересекающиеся. Поэтому как бы найти минимальное k такое, то же самое, что найти
минимальное k такое. Но это считать будет попроще, потому что ну как бы мы
избавились от дополнительного требования. Мы избавились от требований того, что они не
пересекаются, теперь мы можем просто покрыть все вершины В, возможно по несколько
раз, то есть каждая вершина может войти в несколько независимых множеств, но главное, чтобы
каждый блакок раз покрыть. Понятно? Вот, ну давайте это считать. Моя цель, это вот здесь мне
удобно будет посчитать не просто узнать, существует такое покрытие или нет, а
посчитать количество будет проще всего. Давайте я скажу, что скажем c от k, c от k это
количество наборов, давайте назову их g1, g2 и так далее, gkt, таких, что все жишки, это
независимое множество, их объединение это В. Вот, ну я просто определяю, сколько существует
таких вот покрытий. Ну и понятно тогда, что минимальное, мне по факту нужно теперь найти
минимальное k, такое, что c от k положительно, на что существует хотя бы один набор из ка независимых
множеств, который покрывает суммарно все вершины. Вот, такую задачу теперь будем решать.
Так, ну хорошо. Да, c от k, смотрите, я хочу посчитать, сколькими способами можно покрыть В с помощью k независимых
множеств. То есть формально, сколько существует таких кортежей длины k, что каждая g и t это независимое
множество, и при этом их объединение покрывает все В, то есть их объединение равно В. Каждая вершина
вошла хотя бы в какое-то независимое множество. Ну и тогда понятно, что положительность c от k
равносильна тому, что можно так покрыть все k независимым множествами, а значит хроматическое
число не больше чем k. То есть можно их вот так вот разбить, можно покрыть этими k цветами. Вот,
значит хроматическое число не больше чем k. Если я найду минимальное, то я найду ответ. Вот. А считать вот
это количество наборов, я буду с помощью формулы включения исключений. Потому что проверять вот это
требование надо думать как, а с помощью формулы включения исключения это делается довольно просто.
Смотрите, ну вот вообще сколько, вот если я отброшу вот это условие про объединение, про то,
что объединение равно В, то сколько существует таких наборов из k множеств, что каждая из них
независимая. Вот если я это отброшу, то наверное это как-то можем посчитать. Если я знаю сколько
вообще всего в графе независимых множеств, то количество наборов без вот этого условия,
это просто там m в степени k, где m это количество независимых множеств. Значит пусть в графе всего,
м независимых множеств. Как найти m, ну мы на самом деле знаем. У нас есть алгоритм,
который находит все клики в графе за два в степени n или даже за два в степени n пополам. Нет,
там не все, ну короче не важно. За два в степени n мы точно умеем узнавать все клики. Но клика и
независимое множество очень похожие объекты. В клике все ребра должны быть, а в независимом
обороте всех должно не быть. Поэтому как бы это задача абсолютно эквивалентная. Если мы умеем
находить все клики, то все независимые множества мы точно также умеем находить. Вот, ну вот пусть их
всего m. Значит тогда всего наборов таких, что каждая жижка это независимое множество, их m в
степени k. На каждый из k мест можно поставить одно из независимых множеств. Я не буду заботиться о
том, что они должны быть все попарно различные. Этого здесь у меня не написано. Если там даже
что-то повторяется, ну и бог с ним. Вот их в степени k. Но какие-то из них плохие, какие-то из них
не накрывают все v. То есть их объединение может быть слишком маленьким, может не покрывать все v.
Давайте их вычтем. Давайте вычтем те, которые не накрывают v. То есть которые вложены во что-то
меньше. Вычтем те, которые, ну объединение которых, да, точнее, объединение которых вложено в v без v и
для каждого i. Ну то есть как бы мне нужны те, которые в объединении дают все v, но если я просто
рассмотрю все это, какие-то плохие, плохие те, которые скажем, какой-то v-тей не содержат. Вот я их все
вычту. Потом мне нужно добавить те, которые вложены в v без двух элементов. Добавим обратно те,
объединения которых вложено в v без v и v жития. Потому что если объединение вот этих штук вложено вот
сюда вот, то я его здесь один раз учел, здесь два раза вычтил. То есть мне нужно еще раз его вычесть,
чтобы был коэффициент нулевой. Ну и так далее. Вот. Ну и все дальше. Я просто перебираю все
подносства v, считаю сколько есть наборов вложенных в полностью. Ну, точнее, не в, а в подносство v.
И беру их там с нужным коэффициентом плюс или минус один. Вот. И так по пробам в включении
исключений я насчитываю количество хороших наборов. Такая идея. Вот. Идея понятна. Сейчас я буду
это доформализовывать. Почему наборов в раме степеника? Ну, смотрите, я считаю, я хочу посчитать,
вот если я вот эту условию отбросил, вот эту последнюю, если я про него забуду, то мне нужно
просто узнать сколько есть наборов из k независимых множеств. Ну, если всего в природе m независимых
множеств, то сколько есть кортежей длинный k, каждый из которых независимый множество. На каждый из них
можно поставить одно из m множеств. Вот. Я не заботюсь о том, чтобы они были различные, просто даже
если есть одинаковые, я считаю это хорошим набором. Еще раз? Не, вообще все, вообще все. Ну, можно было бы
брать, видимо, максимализ по включению, но я для простыди беру просто все, чтобы лишних условий
не писать, просто все. Потому что вот здесь, когда я вот это говорю, я здесь нигде не следил за
максимальностью по включению, и лучше, ну, короче, можно этого не делать. Вот, значит, идея такая,
теперь давайте формализуем. Значит, смотрите, давайте я введу какое-нибудь обозначение.
Пусть a от s это количество наборов g1 и т.д. и gk таких, что их объединение вложено в v без s.
Значит, тогда ответ равен, тогда c от k равно следующей сумме m в степени k минус, значит, сумма
по одноэлементным множествам, давайте напишу, по всем s размера 1, а вот s плюс сумма по всем
s размера 2, а вот с минус сумма по всем s размера 3, а вот с ну и т.д. вплоть до минус 1 в степени v на
ну единственное множество размера v, а вот с. Ну почему это так? Это в точности формы включения
исключений. Мне что нужно? c от k это все такие наборы, которые покрывают все. Как они выглядят?
Ну давайте сначала возьмем вообще все возможные наборы искания зависимых множеств. Из них нужно
выкинуть те, которые хоть что-то не содержат, то есть нужно выкинуть те, объединения которых не все
v, то есть они вложены в какое-то меньшее под множество, не содержат хотя бы какую-то вершину. Но давайте
переберем ту вершину, которая не содержит. Мы знаем сколько таких наборов есть, мы знаем сколько
из наборов, объединения которых вложено в v без одной вершинки. Давайте их вычтем. Это все плохие
наборы, они нас не интересуют, потому что их объединений меньше, чем все v. Но при этом мы что-то
выкинули дважды. Например, если объединение было в v без двух вершин, тогда мы его здесь дважды
выкинули и добавили один раз. Надо его один раз вернуть. Ну вот вернем все а от s под двум
элементам под множеством. Но потом то же самое с тремя и так далее. Ну вот, поэтому если я каким-то
образом смогу насчитать вот это вот а от s, то я свою задачу для фиксированного ка решил за два
степени n примерно. Ну потому что здесь, здесь примерно два степени н слагаемых, даже ровно два
степени н слагаемых, потому что каждое множество встречается ровно в одной сумме и всех множеств
ровно два степени с. Значит тогда вот эта вот штука вычисляется за два степени n, ну там,
в сложении слэш вычитаний. Вот.
Осталось как-то быстро насчитать ашки.
Давайте посчитаем.
Так, давайте еще одно обозначение веду. Пусть b от, пусть будет от s также. Это просто количество
независимых множеств, вложенных в v без s. Тогда а от s, это просто к этой степени b.
К это вот, вот то самое к, у меня фиксированное какое-то число. Я пытаюсь проверить, можно ли
покрасить в к цветов. Вот. Ну почему? Ну понятно, у меня как бы мне нужно а от s, это буквально
количество таких наборов, что их объединение вложено в v без s. Объединение вложено в v без s,
если только если каждый из них вложено в v без s. Если я посчитаю, сколько есть таких g, которые
вложены в v без s и дальше, ну просто возведу в какую-то степень, это будет в точности число
таких наборов. Это вот тут написано. Поэтому достаточно вот эти b посчитать. Вот. Что-то
похоже должно было быть на семинаре, по идее. То есть, смотрите, у меня есть какие-то независимые
множества. Мне нужно для каждого s, для каждого подмножества множества v, найти количество
независимых лежащих вот здесь вот. Вот это буквально следующее. Значит b вот s. Это сумма
по всем подмножествам v без s. Но здесь написано единица, если маска это независимое множество,
если не является независимым. Если маска это независимое множество, нулик иначе. Это буквально
количество подмасок v без s, которые являются независимым множеством. Ну а симптотика у меня
будет вот как у нас. Мы уже вот за столько это считаем, поэтому два в степени мы себе позволяем.
Тут не очень хорошая симптотика, но я вначале написал, что два в степени наполиноматен.
Вот. Ну что, узнаете, нет?
Ой, как хочется переобозначить еще разочек. Давайте я,
давайте я просто напишу b'. Ну я просто переобозвал. Вот я сказал, что вот здесь вместо
v без s я буду писать просто t. Ну и тогда понятно, что b от s и b' от t очень легко связаны,
надо просто с поменять на v без s и получится что там. Если я сюда поставлю вместо t в v без s,
у меня получится как раз b от s. То есть это по факту тоже самое. Но теперь смотрите,
теперь b' от t это сумма по подмаскам чего-то там. Вот.
Ну связь простая. Ну я по факту просто переобозначил вот это вот за t. Но теперь
смотри, теперь b' от множества t это по факту просто количество независимых подмножеств множество t.
Это сумма по всем подмаскам под множество t, единица если маска независима,
ноль если не независима. Поэтому по факту b' от t это просто количество независимых
внутри t. Вот. Ну такое мы вроде умеем делать.
Ну нет. Ну все-таки в мебесе еще минцы единички бывают?
Ну понятно, но кажется здесь она не помогает. Но неважно. Нет, мебес тут не нужен точно.
Так это что-что? Кто она? Да блин, это обозначение просто. Давайте b' с волной,
если вас это путает. Это непроизводно. B' от s это количество клик в s? Почему? Это правда.
Но при инверсии всего графа, когда вы ребра заменяете на отсутствие ребра,
а наоборот если не было ребра, то добавляете его. Не совсем оно. Ну окей. Так или иначе,
давайте я сформулирую следующую задачу. Такая задача. Вот просто давайте у меня для каждой
маски, то есть смотрите, мне по факту для каждой маски определено какое число 1 или 0. Является
оно независимо нашим или нет. Давайте это обзову за какой-нибудь x. Пусть x от маск даёт какое-то
число для каждой маски. Число, отвечающее каждой маске. Каждой маске. А дальше мне нужно для каждого
множества t определить сумму x по подмаскам. Дальше B' от t это сумма по всем подмаскам x от
маски просто. То есть у меня есть какая-то величина определенная для каждого множества,
для каждой маски. И дальше мне нужно найти сумму вот этих x внутри, по всем подмостам t. Вот такой
был на семинарах или должно быть. Как решается? Давайте решим с помощью динамики. Давайте я веду
вот такую вещь. Для каждого множества t и для, скажем, и битов, я определю такую же сумму,
только наложу на маску ограничение, что нас совпадает с t, по крайней мере, в первых и битах.
Это та же самая сумма x по маскам, где маска вложена в t. Но при этом первые и бит у них
совпадают, по крайней мере первые и бит у них совпадают. Ну вот этих двух товарищей. Давайте
я словами напишу лучше. Старшие i, бит, маск и t совпадают. Вот. Тогда скажите мне,
пожалуйста, чему равно dp t n, где n – это число битов во всех масках. Вся маска, да, просто x от
всей маски t. Потому что если я в индексе суммирования накладываю дополнительные ограничения,
что маска – это не просто подмаска t, но еще и совпадает с ней в первых и битах, то просто
маска равно t. Единственное слагаемое во всей сумме – только x от t. Хорошо. Теперь давайте,
зная вот эту вот вещь, давайте попробуем считать dp, ну, короче, там какие-то другие маски, будем
уменьшать n. Потому что по факту понятно, что вот это вот просто dp, t – это и нулевое. С другой
стороны. То есть ответ будет вот здесь. Ну, потому что если я здесь напишу вместо i ноль, то это все
подмаски, у которых совпадают хотя бы первые ноль битов. Но это просто все подмаски. Вот. Теперь
как я буду считать эту dp-шку? Ну, вот есть какая-то маска t. Вот сколько-то первых и битов у нее
фиксированы, точнее наоборот, сколько-то много битов у нее фиксированы, я хочу перейти к i на 1
поменьше. Ну понятно, надо тогда просто перебирать какое значение вот этого бита в подмаске и все.
А именно я утверждаю следующее, что dp, t, t и минус первое – это примерно следующее. Давайте вот я
рассмотрю вот этот вот бит. И ты бит сначала. Если он ноль, то он и в маске должен быть нулем.
Значит можно было бы сказать, что если у меня первый i минус 1 бит совпадает, а здесь стоит
ноль, то они и в битах просто совпадают. Потому что если здесь в маске t ноль, то значит он в
подмаске тоже должен быть нулем. И значит, если у них i минус 1 совпадает, то и тоже
подобно совпадает. Я могу написать, что вот это просто dp, t, t и t. Если и ты бит в маске t – это ноль.
Если и ты бит t равен нулю. Ну а иначе, если здесь стоит единица, в этом бите в этом стоит единица,
то тогда как выглядит подмаска, у которой первый i минус 1 бит совпадает с t? Надо просто перебирать
значение вот этого бита, здесь стоит 0 или 1. Если 1, то значит она просто совпадает с t,
опять-таки в i битах уже. А если здесь стоит ноль, то она совпадает с t без этого бита,
а таки в i первых битах. В этом случае dp, t и t, точнее t и минус 1, это что такое? Еще раз,
первый случай – это когда я продлеваю вот эти первые i минус 1 бит на еще один битик и говорю,
что это тоже совпадает. Это просто dp, t и t. Либо же, то есть это все такие маски,
которые совпадают не просто в i минус 1 битах, а в i битах сразу. В i первых битах. Плюс мне
нужно учесть те маски, которые в первых i минус 1 совпали, а в i там уже не совпали. Значит у них
здесь стоит ноль. Но если у них здесь стоит ноль, то можно было бы просто взять dp, t без i бита,
в параметр мы. Потому что вот эта слагаемая отвечает всем таким маскам, которые вот здесь
такие же как t, а здесь нолик. Ну потому что если они вот с этой маской совпадают в i битах,
то они как раз ровно такие. Первые i минус 1 бит такие же как были в t, здесь нолик, но дачка те
угодно. А потому что если здесь стоит ноль, то мы никак по-другому не можем продолжить,
кроме как нулем. А поскольку мы рассматриваем под маски, то сюда единицу в маске, ну как бы вот,
если в t этот бит нулевой, то в маске он тоже нулевой. Потому что мы под множество рассматриваем.
Ну что? Ну вроде все. Тогда смотрите, мы получается ввели такую динамику, вот это вот ее база,
мы считаем как бы динамику от больших и к меньшим. То есть я знаю для n, вычисляю,
что это форма для n минус 1, н минус 2 и так далее вплоть до нуля. Ну если вот просто я делаю такие
переходы, то в конце я для каждого t знаю дп t нулевое. А это и есть тот самый больший штрих,
который я искал. Значит в итоге получилось следующее. За 2 в степени n на n, я посчитал всю вот эту
дпшку, ну почему за столько? Потому что у меня первый аргумент это произвольное множество,
то есть тут 2 в степени n возможных аргументов, здесь n возможных аргументов, ну n плюс 1. И
переход у меня за единичку работает, поэтому вся дпшка насчитывается за 2 в степени n на n.
За такое время я по факту насчитал все больших штрихи. За такое время найдем все больших штриха t.
Ну вот, а это то, что мне было нужно. Если я знаю больших штриха t, то я знаю, вот у меня там есть
форму выражения a через b, ну а дальше у меня есть форму выражения c через а. Профит. Сейчас алгоритм
такой. Давайте быстренько еще раз произведу. Я перебираю всевозможные k за вот столько. Кстати,
вот это можно вынести, потому что это от k не зависит. Это можно вынести в самое начало. Давайте
я сначала это и сделаю. Насчитаем b штрих от t и b от s. Да, потому что здесь я внутри никак не
пользовался значением k. Это вообще не зависит от задачи, не зависит от хроматического числа. Это
просто отдельная k-дп-шка вспомогательная. Ну а дальше уже как раз перебираю всевозможные k.
В порядке возрастания вычисляем а от s как k-той степень b. Вычисляем c от k. Если c от k положительно,
то значит k это ответ. Ну что, сойдет?
Там была формула, я вот стер. Там была явная формула через ашки. Вот вроде все.
Тут еще надо сделать пара замечаний на самом деле, потому что вот если мы посмотрим внимательно
формулу для c от k, как мы ее считали, там были довольно большие числа. Там было m в степени k
слагаемое, но и вот эти все ашки тоже там это какая-то k-той степень чего-то. Эти все числа
могут быть довольно большие. В частности, вот здесь было слагаемое m в степени k, где про m я
знаю только лишь, что оно не больше 2 в степени n, потому что было количество независимых множеств.
Если возвожу ее в k-той степень, где k может быть вплоть до n видимо, то это будет что-то в стиле 2
в степени квадрат может быть довольно много, даже если он маленько. Вот и поэтому тут надо сказать
примерно следующее. Либо мы, то есть здесь чтобы аккуратно оценить симпатику, мне в идеале нужно
было бы сказать, какого размера у нас получаются все числа, потому что если считаем степени k,
то мне видимо ни нитов, ни лонг-лонгов ничего не хватит. Нужно переходить в какую-то длинную
рифметику, считать длину от этого числа. И соответственно, чем длиннее числа, тем дольше
работает алгоритм. И поэтому надо было бы аккуратно посчитать длину от этого числа, посчитать,
за сколько мы это умножаем, вычитаем и так далее. Либо можно поступить хитрее и сказать следующее.
Ну, смотрите, давайте не считать точный ответ, а давайте посчитаем его в большом модулю, 10-9 или
что-нибудь такое. Тогда все эти числа, они остаются маленькие, их можно спокойно в инде хранить и
возродить. В степенях можно быстро, и складывать, вычитать можно довольно быстро. Ну, тогда понятно,
что если у вас было какое-то положительное число, и вы взяли его в какую-нибудь модулю,
случайному модулю например, вместо 10-9 давайте иду в случайный модуль. Тогда с какой вероятностью
положительное число занулиться по случайному модулю? Ну, с маленькой, наверное. А если вы взяли
достаточно большой модуль, но при этом случайный, тогда вероятность того, что положительное число
занулилось, она при небрежиме маленькая. И вместо того, чтобы явным образом считать длинную рифметику,
можно было бы просто посчитать ответ по модулю П, для большого П. Если он не нулевой, то значит,
то исходное число не нулевое. А если нулевой, то исходное тоже было, наверное, нулевое.
Понятно? Вот, хорошо. Ну, тогда давайте последнее, что скажу. Это очень родственная задача, называется
set cover. Задача, собственно, о покрытии множественной. Задача о покрытии множественной.
Set cover. Значит, задача такая. Представьте, что у вас есть несколько множеств, с 1, с 2 и так далее,
с к, объединение которых, ну это там какой-нибудь универсум у. То есть они все лежат в коробочке у
и как-то его накрывают. В объединении дают все у. Задача такая. Нужно выбрать минимальные их
подмножества, которые по-прежнему в объединении дают все у. Ка у меня уже занято, давайте назову
д. Минимальное д такое, что объединение каких-то д из них дает все у. Вот, то есть у вас есть много
множеств, к множеств, объединения которых есть у. Вам нужно выбрать как можно меньше из них,
чтобы сохранить это условие, что их объединение все еще у. Вот. Решается точно так же. Ну, например,
можно так же решать. Ну, можно так, можно так, можно так, да, можно так. А можно, если у вас к
большое универсум маленький, вот если я скажу, что у вот эту штуку у вас маленькая достаточно,
то можно за подобным алгоритмом, ну то же самое сделать с помощью формулки исключения,
посчитать сколько есть накрытий у с помощью там к из них, с помощью д из них. Решается аналогично.
Потому что в прошлой задаче я как раз ровно это и делал. Да, у меня было несколько хороших множеств,
вот теперь с-ками выступают все независимые, как бы можно взять вместо с независимые множества. Да,
и мне как раз нужно было взять как можно меньше из них, так чтобы в объединении они покрыли все
множество вишен В. Ну, то же самое, просто как бы, просто об общении. Я по факту ровно эту
задачу решил. Вот, значит, проект-задача тоже известна, что она, наверное, трудная. И лучше,
на что можно надеяться, это вот что-то такое экспенсиальное. Ну, у нас и получается что-то в стиле
2n на n. Ну, короче, что-то примерно такое по симптомике. Вот, тогда все. Спасибо.
