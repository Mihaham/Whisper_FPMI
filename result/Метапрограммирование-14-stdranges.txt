Итак, всем добрый день.
Как вы можете видеть с экрана, у нас сегодня максимально
подробный разбор ранжей, кто-то из вас что-то про
них уже знает.
Наверное, стоит сказать, почему на этом курсе мы
внезапно идем разбирать такую прикладную библиотеку,
которая нужна тупо, чтобы в одну строчку олимпиадные
задачки решать, как в питоне, принт, трансформат, мап,
от инпута, сплит, вот это все.
Кто-то на них когда-нибудь запилить стримы.
Стримы?
Зачем стримы?
Да когда они есть функциональные стримы эти ранжи?
Кто-то запилить библиотеку, которая станет на карте.
Вот она уже есть, вот эта библиотека.
А синхронность еще.
А синхронность, это STD execution, да, там это будет технически
в какой-то момент.
Но это неважно.
Даже у нас на курсе не в этом мотивация, а в том,
что вот это вот очень мощная метапрограммистская библиотека.
Там очень много разной метапроги, во-первых, а во-вторых,
там много такой штуки, как generic design.
Вот я как-то в прошлых годах больше на этом акцентировал
внимание, а в этом забил.
Как вы думаете, в чем разница между метапрограммированием
и обобщенным программированием или generic design?
Слова разные.
Слова разные.
Ну, нету идеи, да?
Ну, это конкретика, и ты почти полиморфизм сейчас описал.
Ну, в общем и целом, метапрограммирование – это вот тупые инструменты,
которые у нас есть в языке, чтобы что-то в compile-time делать.
Это создание программ, которые порождают другие программы.
Вот это метапрограммирование.
С самого начала я сказал какое-то определение из книжки
на первой лекции, что ли.
А вот generic design – это более общая штука.
Это создание алгоритмов и структур данных, обобщенных
по чему-то, которые работают для многих разных ситуаций.
STD-вектор – это обобщенный алгоритм или структура данных.
Я последнее время перестал различать, в чем разница,
если честно.
Если задуматься, вектор – это просто какая структура данных?
Ну, вводит звездочка, а дальше на нем какие-то алгоритмы,
которые там какие-то пушбеки делают и еще что-то.
Поэтому не суть важна.
Ну, вот вектор – это обобщенная структура данных.
Она может работать независимо от того, какой тип данных
внутри положите, мапчик какой-нибудь и то же самое.
И вот для конкретных данных не шаблонный код, который работает
в одном конкретном случае.
Вы писать все умите, вас там долго учили.
Окей, вопрос возникает, а как это обобщить, чтобы работало
со многими типами данных?
Ну, ответ простой, навешивай шаблон и погнали, поехали.
Не хочешь шаблон, делаешь интерфейс и тоже погнали, поехали.
То есть вот дженерик дизайнов не только про шаблоны,
да, можно обобщать с помощью чего угодно.
Но возникает куча вопросов.
Какую абстракцию выделить?
И вот ну абстракция – это центральное тут вообще понятие.
Что будет единицы абстракции?
Что включить, методы какие в интерфейс?
Или там в концепт какие требования наложить?
Требовать там какой-нибудь регулярности или не требовать?
Ну и вообще какую иерархию концептов или интерфейсов сделать?
И вот на все эти вопросы нет простого ответа.
Народ просто сидит и долго и усердно думает, разбирая разные частные случаи
и пытаясь подогнать такой дизайн, который их все покрывает.
И вот тут люди много-много лет сидели и разбирали разные случаи того,
как разным людям нужно работать с,
ну казалось бы, просто викторочками, по сути, или массивчиками.
Ну вот в Питоне достаточно мощная библиотека для итерации всякой,
по-моему, итертулс называется.
Но она далеко не все кейсы все равно покрывает,
а тут пытаются все кейсы покрыть.
Ну и в первую очередь это связано с перфом.
В Питоне могут забить на перф, в плюсах ни в коем случае.
И вот много-много-много лет обсуждали, какие абстракции выбрать,
как лучше обобщать эти алгоритмы, на чем все строить.
И придумали.
И вот мы сейчас на все это будем смотреть и пытаться какие-то мысли вынести
про то, как надо самостоятельно обобщать алгоритмы,
если вам это в жизни когда-то придется делать, выделять абстракции.
Ну я не думаю, что этому возможно научить в принципе,
только вот тут почувствовать надо, приходит с годами.
Но какие-то важные уроки, кажется, мы отсюда вынесем.
Плюс сколько они не думали, там очень много подводных камней,
которые вот если кто-то не расскажет, и вы наткнетесь на практике,
то раздебажить будет крайне сложно, и вы будете очень гореть.
Смешные ошибки в компиляции?
Да, смешные ошибки в компиляции и сюрпризы в поведении тоже могут быть.
Еще нарушения конскорректности могут быть в каких-то местах.
Но по-моему, сегодня нарушения конскорректности мы смотреть не будем,
но после этой презентации на 150 слайдов вы и сами должны будете
смочь прочитать что там с конскорректностью неправильно.
Копи-он-райт всегда.
Копи-он-райт – это ошибка селекции.
Тут немножко по-другому.
Ладно, давайте начинать уже к делу.
Мы разбираем эстедеренджерс, надеюсь, он понятно зачем и почему,
и что мы хотим вынести из них.
Понятное дело, что сейчас будет куча концептов,
а они используют базовые концепты стандартной библиотеки,
поэтому повторим их.
Помните их? Да? Нет? Да.
Movable – базовый концепт, класс, в котором вообще хоть что-то можно делать.
Его можно мувать.
Это нормальный такой концепт.
Тут UniquePtr туда лежит.
То есть копиабл концепт.
Его еще копировать можно. И мувать, и копировать класс.
Тут на самом деле сложно придумать какой-то…
Процесс. Что? Какой-нибудь процесс.
Процесс? Поток. Тред нельзя копировать.
Ну, бывают такие классы, у которых нет конструктора по умолчанию.
Тут дальше после копиабл идет semiRegular.
Это класс, у которого есть конструктор по умолчанию.
Ну, и копируются, и муваются.
Любую кодовую базу на клешах откройте,
вы найдете там классы, у которых конструктор от чего-то конкретного,
ну а копировать, мувать можно, и все нормально.
На ингредиентности Regular – это самая пацанская категория типов,
которая вообще ведет себя нормально.
Потому регулярное… вот такое слово использовали.
Оказалось бы, общее – регулярный класс.
Они все ведут себя как стандартные типы данных.
Можно сравнивать, дефолтно инициализировать, копировать, мувать – все есть.
Вот. Сейчас это все у нас пойдет в обиход.
Будем внезапно в какие-то моменты навешивать поверх всего
требования какой-нибудь регулярности к чему-нибудь,
или копируемости, или еще чего-нибудь.
Зачем наличие конструктора по умолчанию в отдельных концепциях?
Потому что бывают кейсы, когда тебе не нужен конструктор по умолчанию.
Но ты же можешь создать optional на штуку, которую нельзя конструировать по умолчанию?
Может быть, может быть… сейчас.
Может быть, подключение по концепту нужно, потому что для некоторых проверок
нам нужно именно вычислять выражение, а не просто смотреть типы.
Там нельзя писать decal law, поэтому там нужно писать дефолтно инициализацию.
Например, по концептам проверять constexpr функцию, там можно вычислять.
Там нельзя писать decal law, потому что дефолтно инициализовал.
Нет, это вообще не к этому, это проблема языка.
И вообще, ты говоришь нельзя, а на самом деле можно.
Ты же все равно в Requires это все впишешь.
Ну или если не впишешь, то впиши в Requires, и вот тебе…
Ну у тебя из круглых скобок появится из воздуха переменная, и все.
Короче, это не про это.
Просто есть алгоритмы в стандартной библиотеке, у которых требование ровно вот такое.
Ну им просто не нужно дефолтно конструировать.
Поэтому они требуют copyable.
А есть алгоритмы, которым обязательно надо дефолтно конструировать,
это они по-другому не могут. Для них есть этот.
Ну, конкретные примеры надо просто вот, как бы, CTRL-F по стандарту сделать
или по cpp-reference вы найдете. Это уж сами.
Окей. Что было при Степанове? Кто такой Степанов?
Нет, не угадали.
Ну, Александр Степанов это…
Да, стандартную библиотеку придумал.
Вот именно он придумал абстракцию траторов C++.
Вот такая абстракция вам давно знакома.
Но вообще говоря, ни разу не очевидно, что эта абстракция должна быть именно такой,
какой она есть в C++.
Если вы какие-нибудь другие языки знаете, типа питон или раста,
то там итератор, как бы, слово тоже, а значение совсем другое.
Кто-то итераторами называет генераторы вообще.
У кого-то там итератор можно к булю кастить,
и он говорит, вам дошел до конца или нет.
Ну, в джаве что-то такое есть.
Кто-то вообще стримы использует вместо итераторов, как джава.
Ну, у нас итераторы. Есть вот такие категории итераторов.
Ну, что это такое? Это named requirements.
Те самые, про которые мы уже говорили, когда концепты впервые смотрели.
Ну, конечно, теперь никаких named requirements нет.
Они обзавелись префиксом legacy и вообще помещено как deprecated.
И более того, они не совпадают с тем, что теперь в концептах написано.
Поэтому они вот совсем deprecated и, скорее всего, там removed в каких-нибудь 23-26-ых будут.
Ну, почему? Потому что... А, нет.
Не мог-то они быть removed, потому что у нас есть legacy-функции в стандартной библиотеке.
Ну, короче, да.
Требования отличаются, потому что когда вот эти вот требования придумывали,
ну, не до конца все додумали.
И теперь все чуть-чуть поменялось, чуть-чуть усложнилось,
больше случаев покрыли, и некоторые баги, крайние,
урнеркейсы тоже пофиксили.
Поэтому, в принципе, когда вы там на 20-х плюсах пишете,
вот эти вот вещи не смотрите, если вы хотите написать итератор.
Надо смотреть концепты.
Вот. Но проблема-то в чем?
Когда лекция про концепты была, мы уже видели, что там вот такие бывают концепты.
Сейчас все то же самое будет.
Перед тем, как даже определить, что такое итератор,
нам нужно определить, что такое weakly incrementable.
Давайте посмотрим на этот концепт.
Ну, он default initializable внезапно, и movable.
OK.
Он требует, чтобы был некоторый тип IterDifferenceT,
и он был знаковым.
Ну, вот эту вот штуку, это типа...
Да, вот signedDifferenceT – это, ну, опять trade,
опять там ходим, пытаемся так-сяк.
Мы это уже видели, не будем застрять внимание,
если будете сами писать, на ЦП-референс есть.
Signed integral like – это вот...
У меня тут так в презентации написано,
но на самом деле это гораздо большая пушка.
Там в разделе про weakly incrementable
на две страницы определение того, что такое целое число.
Что там типа целые числа – это штуки, которые ведут себя в принципе
как встроенные целые числа, но может быть чуть иначе, но не совсем.
Встроенные целые числа – это вот эти вот типа...
Встроенные.
Встроенные. Чего-чего?
А бигендер же проходит, можно все бигендер же...
Да. Кажется, в этом и суть, что...
Ну, вообще, что такое intuitive IterDifferenceT, вы понимаете?
Это что-то вперед побежал. Думаю, не все.
Что?
Ну да, то есть вот это weakly incrementable –
какая-то такая совсем база-база,
которая объединяет в себе и итераторы, и числа.
То есть итераторы и числа похожи тем, что их можно там
двигать вперед-назад, и можно друг из друга вычитать.
Вот числа складывать еще можно, а итераторы складывать нельзя.
Ну и вот тут выделены все общие для них свойства,
и вот IterDifferenceT – это то, что получается,
когда вы вычитаете друг из друга как бы итератор.
Но итератор нельзя так же выучить.
Ну как бы нельзя, но если очень постараться, то можно.
Ты можешь двигать один вперед, пока не дойдешь до второго.
Либо до Энда.
Что?
Либо до Энда, но в смысле там же можно.
Ну, считаем, что нормальные итераторы.
Двигаем один вперед, пока не дешали до второго,
и вот сколько насчитали – это между ними расстояние.
Вот.
И я хотел спросить, почему здесь минуса не требуется,
а вот некоторые типы, которые как бы для разницы
между итераторами требуются?
Потому что мы можем из большего итератора
начать с меньшего и большего числа.
Нет, почему это?
Что это нам мешает потребовать здесь, чтобы был минус определен?
Стоп.
Мы не всегда можем определить минусы.
Ну да.
Кто бы уже сказал про forward list, да, forward итераторы.
То есть тут не определено, как именно мы можем найти расстояние пока что.
Ну и, вернее, как.
Явно в тексте не прописано, но подразумевается,
что вы всегда можете найти расстояние,
просто двигаясь вперед и записывая, сколько вы инкрементов сделали.
Вопрос, в какой тип нужно записывать количество инкрементов,
чтобы гарантированно влезло.
Вот в этот.
За этим здесь этот тип и требуется.
Ну и он знаковый, потому что вообще-то у вас и в другую сторону
может потребоваться двигать, и...
Ну, общий алгоритм такой, что вы и тот, и другой одновременно двигаете,
пока там один до другого не дойдет, либо другой до первого.
Что-нибудь такое.
Ну, он тоже не всегда работает.
Ладно.
Ты промахнешься.
Короче, кажется вообще тут общего алгоритма нет.
Если мы двигаем по единичке,
но каждый раз бач, это степень последствий в токен.
А, окей.
И если мы знаем, что тогда он бесконечный,
потому что у нас бесконечный итератор,
тогда рано или поздно не встретиться.
Ну окей, да.
Ну вот что-то такое.
Но вам же две разные копии надо двигать.
Да, мы до этого пока не дошли.
Тут только плюс-плюс, и постфиксные, и префиксные есть.
То есть в обратную сторону двигать мы не можем вообще-то.
Там, по-моему, если мы дойдем уже до Энда,
и мы проверим, наверное, и пойдем дальше,
это будет УБ.
Но это очень абстрактный концепт.
И предполагается, что ты вот это расстояние
будешь искать только для двух корректных.
А, нет, даже если не корректные,
даже если не корректные,
ты просто дошел до Энда.
А, говоришь УБ.
И если мы будем дальше, это вроде бы УБ.
Ну, беда.
Ну, короче, ладно.
Ну вот ровно такими вопросами,
как вот мы сейчас задаемся,
задавались люди, которые это придумывали,
написали про это,
толмут на 250 страниц,
про то, как правильно и почему,
и не один, по-моему.
Это итоговый документ,
только с формулировками 250 страниц.
Перед этим еще десятки статей были.
Ну и выбрали вот такой.
Догадаться до всего, почему тут так написано,
мы вряд ли сможем, но многие мысли увидим.
Никак не гарантируется качество это состояние,
но гарантируется, что если мы его можем посчитать,
то ответ на корректных таким.
Да, что ответ можно хранить в таком типе.
Вот что нам гарантирует.
Ну и как бы это нужно для всех концептов,
которые дальше будут,
потому что дальше мы собрались над этим что-то строить,
и там, конечно, расстояние считать нужно будет.
Вот, и да, как мы уже говорили,
пока не прервались, Signed Integral Like
включает в себя даже
симдешные int 128t
и даже беганты,
формально говоря.
Не знаю, кому нужно
два в 128 степени
байтиков считать итераторами,
но кому-то, видимо, нужно.
Ну есть пропозлы,
ну, холевары,
пропозлы холевары,
как обычно.
Вот на любой вопрос собираются ли в стандарт добавить
ответ холевары,
бюрократия, споры,
ну, вот так вот.
Да, плюсы,
префиксный и постфиксный.
Ну, префиксный прямо требуется,
что у нас все нормальные
префиксные инкременты, они возвращают ссылку
на себя.
От постфиксного ничего не требуется.
Почему?
Может вам разрешить революции объекта?
Нет.
Ну что вот постфиксный инкремент?
В плане?
Копию.
Видите, чтобы здесь копируемость требовалась?
Нету.
Мы можем здесь просто взять и потребовать, чтобы вернули копию.
Потому что копируемость
не требуется.
Тут вообще ничего не просят возвращать.
То есть можно void поставить.
Так, прошу прощения, у меня
пиликает.
Все, теперь не будет пиликать.
А, тогда получается, что мы допускаем,
что i++, вот справа,
он может работать как-то
необычно. Да, может.
Викле-инкремент был, он может работать необычно.
Зачем это
требовать, чтобы это вообще было?
А есть стандартные типы, у которых они
работают необычно.
А как ты ее в концепте
напишешь?
Требования есть, сейчас они будут.
Секунду, вот перед тем, как требования
перейти, заметьте, что
слово wikli, мы помним,
что оно значит, да?
Что-что?
Да.
Про equality preservation.
Про то, что
выражения сохраняют равенство.
Любое wikli сразу выражение
не сохраняет равенство. И вот
операторы i++ тут не требуется, чтобы они
сохраняли равенство. Почему?
И вот к этому
вопросу тоже. Почему
вот здесь ничего не требуется и почему настолько
слабый его концепт вообще нужен?
Может, таких типов не бывает, настолько слабых
и зачем нам это все?
Вот есть в стандартной библиотеке тип, у которого
вот эти вещи...
Input итератор и Output итератор.
Как мы здесь...
Типа
не знаю.
Я не помню. Может Void?
От Input итератора
++ возвращает
себя же, который префиксный.
Префиксный? Да, постфиксный.
Что у него?
В Void или
Bool? Ну вот, то есть это все сделано
для того, чтобы Input и Output итератора
поддерживать. И на этом
интуиция, и конечно же equality preservation никакого
не может быть, потому что
мы уже много раз обсудили, что
Input и Output итераторы
equality не сохраняют, потому что
с внешним миром взаимодействуют.
Окей.
Семантические требования.
Тут внезапно
вводится понятие incrementable.
Ну вот вы могли подумать,
что это как концепт incrementable, но концепт
incrementable это другое.
А это определение incrementable.
Слова одни и те же, но
смысл разный.
Значит, говорят, что если у
префиксного и постфиксного
оператора incrementa одинаковый
domain, то есть область определения,
то есть либо
одновременно оба определены,
либо одновременно оба undefined behavior,
то вот называем incrementable.
Итак,
требования. Во-первых,
внезапно у них
один и тот же domain.
То есть, ну,
странная формулировка уже, да, что
типа... Во-первых,
мы определяем, что incrementable, а потом
говорим, что у них один и тот же domain,
а потом говорим if
incrementable.
А, стоп.
Я неправильно вам перевел, вы...
Я вас обманул.
Сейчас. Во-первых, да,
вот это пока игнорируем. Во-первых,
плюс-плюс, префиксный и постфиксный
можно делать либо оба,
либо не один из них. Вот
domain — это область определения, для каких
i маленьких эти операции определены,
они там кидают исключения.
Вот про это речь, да?
Ну, одновременно они должны быть.
То есть либо оба кинули бы
исключения, либо оба нормально отработают.
Да, а дальше говорят,
что если i маленькое значение
в этом самом домене лежит, то оно называется incrementable.
Вот так вот.
Если...
Нет. Domain — это область определения,
математическое понятие. Функция есть область
определения, значение для которых функция
определена, вне этой области она
не определена.
Вот. И называют incrementable, когда он лежит
в области определения этих двух операторов.
Вот.
И для всех i маленьких, которые
импровизируют incrementable,
оба постфиксные
интераты, инкременты
должны продвигать и
на следующий элемент.
Ваши теории, что значит
продвигать на следующий элемент?
Что такое следующий элемент?
Вот это вот S, вот это следующий.
Ну, это...
...реализуют математическую идею
вполне упорядоченных множеств,
где на нас гарантируется наличие следующего
элемента. Нет.
В вполне упорядоченных множествах
гарантируется наличие минимальных
элементов. Если я еще что-то помню в этой
жизни, правда ведь?
Подтвердите кто-нибудь.
В каждом множестве
наименьшее.
Вот. Вполне упорядоченное множество.
Но тут не гарантирует вполне упорядоченность.
Если у нас у каждого элемента есть следующий,
но он кажется сложнее,
тогда это будет...
Ну, просто смотри,
я что утверждаю, что
для типов этого концепта,
что такое следующий элемент, определяется
как раз вот этими вот...
вот этими вот операторами.
А потом говорят,
что эти операторы на самом деле...
Зацикленное определение.
Зацикленное определение, да.
Я попытался в чат с крифеями
плюсов задать этот вопрос. Там вообще не поняли
про что я говорю, начали думать,
что я дурак, и кидать ссылки на стандарт,
вот, почитай. Ну,
неудача произошла, к сожалению.
Может быть, здесь просто имеется...
Здесь имеется в виду, что
если обратиться
к оператору
после поста
и после крифи,
то мы получим ссылку
на...
Возможно, именно это и хотели сказать.
Тогда вопрос,
а почему такая формулировка странная?
To the same нельзя, потому что
мы, во-первых, скопировать и маленькое не можем,
и проверить это, а во-вторых,
как бы increment он ломает, поэтому обратно
откатить тоже не можем. Возможно,
они пытаются выкрутиться из того, чтобы
что, ну, типа, когда у вас
вик и нету копируемости, то невозможно
говорить о том, что вообще происходит,
и вот... Сейчас они тут явно говорят,
что plus plus i и
i plus plus продвигает i
на какой-то следующий элемент.
То есть, на один.
То есть, to the same точно есть.
A booth
продвигают на...
Ну, нет,
все равно непонятно.
Ну, штуки при иной и красной
свете...
Ну, нет, observable штуки, да,
их нету пока что.
Вот непонятно.
Мне вообще кажется, что это баг стандарта,
и что вот таких размывчатых,
расплывчатых формулировок быть не должно.
То есть, возможно, здесь имеется как то,
я про равенство вам рассказывал.
Помните прекрасное заклинание?
Если bool a равно равно b
является true,
то обязательно
a равно b и наоборот.
То есть, a равно b тогда и только тогда,
когда a равно b.
Помните это? Нет?
Было такое. Ну, один человек помнит,
остальные нет.
Да.
Там было вот так вот, что
bool a равно равно b
is true
равно сильно
a equals
b.
Вот это вот заклинание,
что вот это true,
тогда и только тогда, когда a равно b.
В каком смысле справа слово equals употреблено
в стандарте? Непонятно.
Ну, я пришел к выводу, что
мы сами решаем, что это значит.
Это value equality.
То есть, мы пишем тип, мы понимаем, что для него
value, мы сами определяем равенство.
Ну да, что у тебя есть оператор
сравнения.
Эквиваленс, может, ты хочешь сказать.
Эквиваленс это совсем
про другое.
Да, наверное.
И должно
существовать какое-то абстрактное
определение next element.
И какое бы мы определение
не выбрали,
результат... Нет, нет, нет.
Какое бы не выбрали.
Какое бы мы не выбрали определение next element,
у нас должно быть так, что
и постфиксные, и префиксные
переносят нас к одному и тому же next element.
Я бы...
Next нужно было заменить на same.
Ну вот да, тут нигде нет
подразумевания, что это same.
То есть,
формулировка ужасная.
Я склонен считать, что
тут и тут идея одинаковая.
Вы сами садитесь писать тип,
и вы понимаете, что для вашего типа value.
Я надеюсь, кто-нибудь еще помнит,
в чем разница между value и object representation.
И полями. Все тут разные вещи.
В value это ваше абстрактное в голове.
Вы придумали value,
вы должны в голове у себя понимать,
что такое для этого value равенство.
И вы должны закодить оператор сравнения,
чтобы он был согласован с тем,
что у вас в голове, с вашей интуицией.
Тут то же самое подразумевают,
что когда вы пишете
weakly incrementable class, у вас в голове должно быть
понимание, какую последовательность
он как бы моделирует по факту,
что вы хотите написать интуитивно
или математически.
И должно быть понимание, что там такое значит advance
и что значит nextElement.
И тогда ваши операторы++
и только они должны именно
делать то, что вы подразумеваете.
То есть пытаются сказать вам,
что не надо делать какую-нибудь
функцию nextElement в оператор++
пихать какую-то дичь, которая вообще
не имеет отношения к делу.
Что-то вот такое. Так же, как не надо в оператор
сравнения писать какую-то дичь
и потом отдельно делать метод isEqual.
Вот nextElement как-то стыкуется с тем,
что у нас профессионально может
последовательность закончится или она не может здесь закончиться?
Тут может
не закончиться, вообще говоря.
Но ничего ни с чем здесь не стыкуется, понимаешь?
Я буду выяснять это дальше,
наверное.
У нас есть еще элементы?
У нас есть еще элементы?
А int не в домейне получается, да?
Что?
int он не в домейне,
потому что++ до него нельзя сделать.
int не в домейне.
Ну да, кажется, что.
Да, разумно.
Ну да, да, да, да, да, да.
То есть он исключение не кидает, конечно,
но это все равно считается undefinedBehaviour,
поэтому да, он не в домейне.
Ну если там не зациклено какое-нибудь контейнер.
Да, такие бывают.
Но это ты уже сам можешь для своего контейнера
определить, какой у твоих утераторов домейн.
Вот у стандартных...
В общем, странно выглядит, что int может быть
в домейне, может не в домейне.
Ну, тут же написано, что ты написал
свои функции++.
Чувствуется слово int в этом месте?
Да, в этом месте пока еще нету
ни бегины, ни энда, ни утераторов, ничего.
Но теоретически вы сами
определяете домен для ваших функций++.
Вы сами написали.
И как бы вот.
Можно вам сказать, что дюйм был определен
просто если выше size, то no off.
Ну окей, да, можно.
Получается вот как будто для
итераторов, например, sender, что
если бы прямо перед эндом,
то nextElement это самый энд,
а этот nextElement он уже не инкредентный был.
Для него nextElement это нет.
Ты сказал хотя бы хотя бы для контейнеров.
Да, нет, внимание.
Ну да, тут если мы указываем
на последний элемент контейнера,
ну и вот в этой ситуации у нас nextElement
это как бы что?
Это же конец контейнера.
NextElement
это не значение, на которое
указывает итератор, это самый итератор.
То есть энд это и будет nextElement.
А вот для энда уже
не определено
эти операции, поэтому вне домейна,
поэтому нет никакого nextElement.
В общем, очень странно,
но вот так вот сложилось,
возможно когда-нибудь пофиксить это,
поменяют, если кто-нибудь, может даже Яна
пишет пейпер.
Ну вряд ли, конечно.
Так, и последнее.
Вот это вот уже совсем понятно.
Не понятно? Последнее.
Совсем просто.
Префиксный.
Increment возвращает указатель на this,
ну ссылку на this.
Поэтому адрес того, что вернут нам,
должен быть равен адресу i.
Ну все, совсем тупо.
Что, что? Я не понял сейчас.
Так. Почему не postfixny?
Postfixny возвращает старое значение
итератора. Ну да.
И? А плюс плюс и?
Postfixny возвращает
копию старого значения.
Префиксный возвращает
себя, то есть this.
А, все. Да.
Префиксный итератор,
префиксный ингримент, это значит увеличь на единицу
и верни, что получилось.
Вот.
Окей, все поняли, все поняли. Едем дальше.
Дальше таких затыков не будет.
А, у меня тут вот обведено было даже, но неважно.
Да, про
ип и вот это все мы сказали.
Equality preservation.
Не требуется, чтобы там как-то равенство
сохранялось
после и до инкремента.
Про острый мы сказали, все прекрасно.
Проговорили без слайдов. Бывает.
А вот это концепт инкрементабл.
Там было понятие инкрементабл,
а теперь концепт инкрементабл.
Никак не связанные вещи.
Нет.
Это понятие инкрементабл определялось для конкретного
значения типа И.
Вот это вот шняга, да?
А вот этот концепт
он для типов определяется.
Ну, о.
Ну, что-то написано,
что он еще и копируемый, да и вообще регулярный,
да.
Wecl incrementable, плюс теперь уже ЕП требуется,
потому что больше не Wecl.
И уже
нормальные условия на postfix,
на increment, да.
Ну, то есть всего этого стоило ожидать.
Wecl incrementable
нужен для вот этих ребят.
Поэтому тут куча требований отпилена.
Equality preservation отпилен, вот здесь ничего не требуется,
да.
А incrementable нужен для всего остального.
Здесь же мы нормально можем написать,
что И++ вернет
другое значение типа И.
Ну, и там дальше
будет сказано, какое значение.
Ну, и копируемость тоже требовать надо.
Потому что...
И равенство тоже требуется.
И равенство требуется.
А то этого мы не требуем, то есть input иterator на равенство мы не требуем.
Да.
Сейчас определяем какие-то подложения
для этих итераторов, да? Да, такие базовые
building блоки, из которых потом построятся
концепты новые для
input итераторов,
output итераторов,
support, bidirectional и так далее.
То есть вот все
named requirements, которые я в самом начале
показал, они превратились в концепты,
но сложные концепты. И нам сейчас нужно вот снизу
вверх пройтись по буквально
четырем или пяти концептам, чтобы дойти
до них. Может больше.
Окей.
Ну, то есть сейчас интуитивно должно быть понятно, что вот эту шнягу
мы потребуем в input итераторе
и в output итераторе, а вот эту во всех остальных.
Окей.
И театрические требования на нее
уже понятные. То есть ну тут буквально
equality preservation написан.
Как бы.
А что значит implies? Подразумевает.
То есть если у нас было a равно b,
то postfix на increment вернет
то же самое старое значение.
То же самое, которое было раньше.
Ну, в техе
сложно значок следствия написать,
там надо вспоминать буквы.
Вот, если...
Да.
Если a было равно b,
то заклинание.
Понятно кому-нибудь это заклинание?
Да.
Да.
Да, это...
Вот так не надо писать код.
Это оператор запятая,
каст к Вайду
не знаю.
А, если...
Нет, нет, нет, я знаю зачем.
Тут нигде не ограничено,
что нельзя написать атрибут
node-discard.
Да, окей.
A++, окей.
Если каст к Вайду, чтобы заигнорить
node-discard и записать.
Можно еще раз объяснить?
Знаешь, что такое node-discard?
Короче можно...
Аркадий, давай я буду объяснять, потому что
у меня микрофон и то, что ты говоришь, не будет
на записи слышно, и
нужно подумать о наших коллегах, которые
не ходят на пары.
Да, атрибут node-discard,
его можно повесить на функцию,
которая возвращает что-то кроме Вайда,
и тогда компилятор будет тебе писать ошибку,
если ты возвращенное значение
не использовал как-то.
Ну, то есть, а-ля
ты написал вот этот вот A++,
оно тебе вернуло значение, а ты просто точку
с запятой после этого написал и никуда его не запомнил,
не пихнул. Например,
в цикле 4.
Вот последним этим написал A++,
возвращенное значение не использовал.
Вот если бы node-discard висел
на операторе A++,
то тебе выдали бы ошибку.
Чтобы эту ошибку подавить, можно сделать
вот так. Прикастить к Вайду.
Это подавление ворнинга.
Значит, что мы с ним что-то делаем и...
Ну, как бы что-то, но на самом деле ничего.
То есть, такой странный
синтаксис в плюсах используется, чтобы...
Вроде, в ингейде
в некоторых местах вот ставил
что-то типа
Ну, может быть.
Оператор запятая,
вычисляет... Сначала левое
вычисляет, потом вычисляет правое
и возвращает правое.
Вот.
Чё?
Да.
Да, да.
Именно так. Поэтому тут, видимо,
для этого. Ну, что тут написано?
Что если мы сначала сделаем
постфиксный инкремент для A,
а потом сравним A с
A++B, префиксным,
то будет одно и то же.
Ну, то есть, после постфиксного инкремента
увеличится точно так же,
как после префиксного.
Вот очень сложный
способ сказать вот эту мысль.
Можно было на двух разных строчках написать,
что если мы сделаем сначала
A++, то
A будет равно
++B, если при этом
A и B изначально были равны.
Всё, ничего интеллектуального, но написано, как всегда,
через пятую точку.
Давайте двигаться дальше.
Наконец-то мы определяем свой первый
итератор. Это будет прям вот
the итератор. Вот
теперь просто слово
итератор в коде
заменяется на вот этот концепт.
Всё, что ему
подходит, является итератором. Всё, что не подходит,
не является.
Ну, и тут требования очень тупые.
WicleIncrementable и можно
звёздочку навесить,
и получится некоторый
тип, очень
хитрый. Ну, сейчас...
Нет, это всё, что написано
какими-то через тире, странные,
красным текстом или комментарием,
или вот italics, ну, наклонным
текстом, это как бы концепт,
но которого нет в стандарте.
То есть, который чисто нужен, чтобы
сформулировать, что происходит.
Вот, и тут вот
так выглядит этот концепт,
вообще говоря. То есть, тип,
на который можно навесить амперсант,
то есть ссылку, и получить тоже нормальный
тип. На что нельзя навесить амперсант?
На Void.
Ну, ещё на что-то, наверное, нельзя.
Ну, нам неважно.
На incomplete, как раз-то можно.
Наоборот,
это смысл incomplete-тайтов.
Вот. То есть, вам должно
вернуться что-то, на что можно навесить ссылку.
Не Void.
Кроме не Void,
ну, не помню, по-моему, нет таких.
Ну, в общем, для всех ваших типов всё пройдёт и нормально.
Главное, Void не возвращайте.
Окей.
Input и Output-этератор.
Простой как пробка, самый общий.
Ничего не требуется, кроме плюс-плюса,
который что-то делает,
вообще непонятно чё. И звёздочки,
которые тоже непонятно чё делают.
Вот. А чтобы дальше
что-то хоть чуть-чуть понятно
стало про то, что все эти
операции должны делать, нам нужны ещё
два вот таких смешных определения.
Да.
Да.
Where the incrementable, кроме
Input и Output-этератора где-то используется?
Не помню. Скорее всего, где-то есть.
Надо посмотреть.
Ну,
в одном месте точно есть increment,
а нет. Wicle, наверное.
Да, используется, в самом конце у нас будет.
Ну, если мне память не изменяет,
может там просто incrementable написан.
Хотя ничто не должно мешать Wicle,
поэтому... Окей.
Два
новых концепта, которые тут даже без определения,
а просто так интуитивно.
Потому что там слишком сложное определение
и, ну,
дебри. Indirectly readable
Indirectly writable. И это на самом деле
целое такое. Семейство,
целое семейство концептов,
как вот есть концепты со словом Wicle,
это значит, что там и Quality Preservation
выкинут. Слово indirectly
значит, что после разыменования
итератора.
То есть что-то можно сделать
с тем, что вам вернёт итератор после разыменования.
Или указатель.
Или там smart pointer.
То есть это очень общий класс.
Ну, и значит, что вот
то, что звёздочка возвращает оператор.
С ним можно сделать что-то.
И вот indirectly readable I
значит, что существует
некоторый тип T,
что можно как бы прочитать
из вот этого типа такую
T путём разыменования.
То есть, в принципе, все indirectly
они описывают похожесть на указатель
чем-то.
Вот readable похож на указатель тем,
что можно прочитать. То есть
написать справа от знака равенства.
Да, да, да.
И то же самое indirectly writable.
Ну, следите
за T.
T здесь нет, а тут есть.
Поэтому тут квантера, здесь его нет.
То есть тут мы не знаем,
какой T прочитаем.
А здесь мы точно знаем, что
writable в смысле можно записать
вот такой конкретно T, а не
любой.
Ну, как бы да, тут
тоже формулировка такая, но по сути
должно скомпилироваться
звёздочка I равно T.
Ну, окей, здесь можно ли вот этот концепт
сформулировать, если ты не знаешь,
какой T собрался записать?
Ну, если бы вот его здесь явно
не написали, получится какой-то такой концепт
написать?
Не получится.
Потому что ты в концепте должен...
Ты хочешь написать выражение, а звёздочка I
равно что?
Что ты туда записываешь?
Вот непонятно.
Ну, а считываю я всегда понятно.
Да, потому что ты можешь взять деколтай
под звёздочка I.
Да, да.
Да, у звёздочка I нету никаких перегрузок.
Это один конкретный оператор всегда.
Поэтому ты точно знаешь, какой тип тебе
вернут. А вот оператор присваивания,
который вы вызовете после того, как
разыменуете, у него могут быть
перегрузки. И вы не знаете, какой из этих
перегрузок взять. Поэтому здесь необходимо
указать T конкретный.
Вот один человек понял, кажется,
наверное, даже два или три.
Но это такая мелочь. Давайте
пойдём дальше. Ну, и да, если
вы пытаетесь посмотреть внутрь, да?
Кажется, что можно сделать
более частный,
когда
indirectly readable, который уже с T.
Можно. Он, наверное,
есть даже в стандарте, но не знаю.
Ну, ты можешь сделать indirectly readable
плюс звёздочка I, same,
st, вот что-нибудь такое.
Ну, да, потому что у тебя
есть
объект типа I,
и маленькая, ты можешь оператор звёздочка
к нему применить. У него не бывает
перегрузок, потому что оператор звёздочка нет
аргументов, кроме самого I.
Ну, у тебя вернётся один конкретный тип.
Вариантов нет.
И ты этот тип точно знаешь.
И вот этот вот квантор, он как раз про него.
Ну, то есть
я так упрощённо объясняю,
если вы реально полезете смотреть, там
опять вот столько буков,
и очень сложно, но мораль
понятна. И это за нас кто-то выяснил, как
нормально сформулировать.
И как только у вас интуитивное понимание есть,
в своих алгоритмах можете это использовать,
если когда-то понадобится.
Но на самом деле они используются, как
несложно догадаться, в input и
output итераторах.
То есть вот был раньше input
or output итератор, это и то
и другое. А теперь
мы уточняем до input итератора.
Это input or output итератор,
который при этом indirectly readable,
определён некоторый
iter-concept,
и вот этот iter-concept наследуется
от input итератора тега.
Сложно, да?
Indirectly readable, indirectly write,
вполне формализованные концепты. Да-да-да,
это прям настоящие концепты, можно
preference открыть, если интересно.
Ну, во-первых,
вопрос к вам смешной,
который я раньше забыл задать.
Что если вот эту вот строчку
с type-name iter-concept
зачеркнуть, убрать отсюда?
Изменится ли что-то в этом концепте?
Ошибка может быть
некрасивая, по-моему. Ошибки
будут некрасивые. Ну да,
именно так. А ещё?
Здесь он
инстанцирует
по правилам, что, допустим, наследники там
корректные. Так, а тут тоже инстанцируют.
Я говорю, вот одну строчку, где requires type-name
вот эту зачеркнуть,
остальную оставить.
Type-name
слот.
Ну а зачем?
Ну, на самом деле
правильный ответ уже сказали, но
не уверена.
Действительно, никакой разницы с точки зрения
семантики языка не будет.
Потому что по дефолту, если вы
какой-то тип написали, где-то внутри
концепта, то концепт
будет false, если этот тип не валидный.
Всё. То есть ошибки компиляции
вы не получите, даже если вот эту строчку уберёте.
Может ещё вызвать специализация,
когда вы используете концепт и тератор,
есть какой-нибудь другой концепт, который
имеет вероятность ровно, но имеет и интерконцепт.
И тогда, чтобы
он выбирался как-то более часто в случае...
Нет, нет, нет. Я говорю, с точки зрения
механики языка ничего не изменится.
Просто вы будете получать более
понятные ошибки.
Потому что, ну вернее,
когда вы напишете
статик, ассорт,
input и тератор от чего-то
равно true, вот в этот момент
вы получите более понятную ошибку,
если написать так.
Что вам скажут сразу, у вас итерконцепт не нашёлся.
Я объясню это почему. Если написать вот так,
вам скажут, не получилось
распарсить что-то там,
потому что мы не знаем,
это шаблон или не шаблон. Короче, ошибка плохая
будет. Вот и всё.
Вот, а теперь по делу. А что это
за итерконцепт такой, input и тератор
теги, зачем это всё?
Ну, итерконцепт
это нечто похожее
на итератор категории.
Помните такую?
Вам точно про неё рассказывали
когда-то давно. Но это
легко вылетающая
из головы информация.
Но суть тут в чём?
Есть теги, соответствующие
каждой категории итераторов.
Есть input итератор тег,
есть output итератор тег,
есть там random access
итератор тег, и для всех
видов, которые вы помните, они есть.
И внезапно, внезапно,
чтобы стать input итератором,
вам нужно хотя бы
явно прописать где-то,
что ваш тип
является input итератором,
и вот где-то нужно вписать input итератор
тег. А вот этот итерконцепт
это просто способ найти,
куда вы там вписали этот тег,
что у вас всё нормально.
Ну и draft втором тут почему?
Мы такой трюк уже видели.
Потому что очень часто
что-то можно написать. Да,
потому что, например, random access итератор тег
он наследуется от
input итератор тега.
Там такое дерево наследования у них.
А где этот
итератор концепт находит этот тег?
Ну, итератор trades.
Уже видим.
И внезапно он сначала смотрит в итератор концепта,
а потом в итератор категории.
Почему переименовали итератор
категории, который был раньше,
в итератор концепт?
Идеи?
Там порядок выставляется
между концептами?
И раньше, по-моему, был.
Ну, я вначале
чуть-чуть об этом сказал, когда про legacy
named requirements и говорил.
А, сейчас, ещё раз.
Вот тут есть итератор концепт,
мы сначала сюда идём, потом идём
в итератор категории.
Итератор категории это очень старое.
Да.
Да, старое.
Да, вот.
В этом суть.
С named requirements у нас
чуть-чуть поменялась семантика.
Вот миллиметр.
Большинство пользователей это не затронет.
Но для тех, кого это затронет,
возможно, у них внезапно
их итераторы перестанут удовлетворять
какой-то категории.
Например, перестанут bidirectional быть
или вообще input итераторами перестанут быть.
И вот, чтобы у них
не ломались стандартные алгоритмы,
которые теперь полагаются на эти новые
требования,
им дали возможность явно
типа переписать вот эту вот старую...
Ну, во-первых, разделили их, да, старая категория
и новая, чтобы
и старые алгоритмы работали, и новые.
Во-вторых, дали возможность разно их поставить.
Да.
Если вы пишете свежий код на C++20,
итератор категории вам не нужен.
Вам нужен итератор концепт.
Вот.
И оно идет туда, идет сюда.
А если ничего не подошло,
то, кажется, идет в random access
итератор тег внезапно.
И то и другое,
там должно лежать
значение типа
input итератор тег
или output итератор тег.
Это просто типа.
Структурки пустые.
А раньше же были...
А сейчас.
Так, еще раз.
Семантика
вот этих категорий итераторов
немножко поменялась.
Чуть-чуть.
Но, если быть честным, то старые
алгоритмы, они полагались на старую
семантику и использовали итератор категории.
Новый алгоритм будет полагаться
на новую семантику.
Нельзя переиспользовать старый
type def итератор категории.
А теги те же, получается?
Теги те же.
Нет, это абсолютно нормально.
Теги те же, но в другом месте
написано для старых алгоритмов
и для новых. Ну, вот так вот.
Нет, все старые алгоритмы
используют итератор категории.
Все, что в алгоритм хедрил лежит,
используют итератор категории, как и раньше.
Новые алгоритмы лежат в хедри-ранжес,
и они используют вот в таком порядке.
Просто как будто
переименовали поле, и все.
Да.
Нет, потому что нельзя переиспользовать
старое поле. Оно для того,
чтобы лего сжило, должно остаться
и не измениться.
Там просто теперь разные деления на...
Да, чуть-чуть другое.
Теперь, если
для какой-то итератора раньше был
иностранный процесс,
он будет перелететь в рейтинг-дирекцию.
Да.
Или перестал быть итератором.
Что?
Смотри, если ты внимательно...
Внимательно пос...
Да, equality preservation какой-нибудь,
или еще что-нибудь такое, да?
То есть, если ты внимательно посмотришь на
named requirements
для разных итераторов
и на новые концепты, и сравнишь их,
то ты поймешь, в каких случаях оно ломается,
долго, муторно и не нужно.
Ужесточили требования, получается?
Да.
Уточнили их.
То есть, если ты хочешь,
чтобы у вас не работало на старых версиях,
пишем концепт.
Итератор, концепт.
Кажется, да.
Не уверен, кстати.
Может, они и в хедре-алгоритм
тоже закостыляли,
чтобы оно умело и с новыми работать
и как-то в compile-тайме понимало,
это legacy итератор или новый итератор
за счет этого.
Надо посмотреть. Ну, в общем, вот такая судьба.
Предполагаем, что у вас нет legacy.
Если есть, то для вас кастыль есть,
вы внимательно подсчитайте цп референс,
там написано, или стандарт.
Если у вас legacy нет, то вы пишите итер концепт
и радуйтесь жизни. Проблем нету.
Да, и внимание, по дефолту
будет random access итератор tag.
То есть, любая шняга, которая
всему этому удовлетворяет, она по дефолту
будет внезапно.
Почему такой узкий?
Какой-то общий, по-дефолту?
Самый общий?
Нет, общий — это самый частый,
который у тебя в коде встречается.
Самый частый итератор в коде —
это random access.
Я могу забыть и забыть написать,
и у меня вот это, типа, сделается.
Ну да.
Короче, сейчас про это поговорим еще.
Почему тут такой дефолт
и почему такие теги?
Там как раз вот здесь
где-то кроется очень важная мысль
про дизайн, но пока мы
до нее не дошли.
Согласились, что вот input иterатор есть,
все хорошо. Вот теги наши прекрасные.
Input иterатор tag,
output иterатор tag, вот forward
наследует
только input иterатор
tag внезапно.
Почему, кстати, непонятно.
Надо же output иterатор
tag, наверное,
следовать, а тут только input.
Что? Ну нет, forward иterатор является
input и output иterатором, правда?
Ну так, идеино, концептуально.
А почему нет?
Ну как бы...
Нет.
Нет, input и output иterатор
принципиально разный. В один ток
писать, в другой ток читать, да?
Один с консоли читает,
другой в консоль пишет. В обратную сторону
их как бы нельзя. А вот любой forward иterатор
он же и то, и другое имеет. Это вот прям уже
нормальный итератор. По списку, например,
бегайте, forward-листу, связанный
список, да? Идете вперед, можете
писать, можете читать. Чего хотите делать?
Почему не наследуется output иterатор
tag? Непонятно.
Потом дойдем.
Bidirectional, random access, contiguous.
Ну, эти категории вам знакомы, да?
Вы понимаете.
А тут никто не наследуется. Внезапно.
Да, contiguous,
по-моему, новая категория. Слышали
про нее раньше? Нет? Была?
Все, окей.
Окей, это хорошо.
Да, тут подчеркнуто. Ну раз
изучали, то окей. Никому не надо проговорить.
Окей.
Окей. Random access
Сказалось бы, что еще можно хотеть, кроме
random access? Вот вы в любое место прыгаете,
зовут единицы, все двигается, все хорошо.
Contiguous добавляет дополнительное
требование, что все элементы в памяти
расположены подряд.
То есть contiguous итератор — это
обертка над указателем и только
она. И ничего больше.
Ну, какой есть контейнер, у которого
итераторы random access, но не contiguous?
Deck.
Deck — это набор блоков памяти.
В каждом из блоков двигаться
можно, ну, типа, просто
передвигая указатель.
А вот следующий блок перепрыгнуть — там уже что-то надо
сложное делать. Поэтому вот он...
Что?
Кто?
Ну да.
Подряд виртуальные памяти лежат.
Что? Нет, вообще не думаем
про страницы.
Виртуальная память
машины C++ абстрактной —
это последовательность байт подряд
идущая. Ничего больше.
Никаких страниц не существует для языка
C++. Как только они у вас
существуют, вы уже, как бы, на уровень ниже
смотрите под язык C++.
Наверное, было предложение,
что у дека каждый кусок размером
со страницы, поэтому эффективно
получается, что он, как бы, contiguous.
Нет. Ну, contiguous нужен,
чтобы мем-копии использовать.
Для итераторов на дек вы не можете
использовать мем-копии.
Да, да, да.
То есть STD array и STD vector — у них contiguous.
Вы можете мем-копии копировать всякую
шнягу по итераторам.
Тут можно было по-другому
сформулировать не contiguous, а
mem-copiable. Имеется в виду именно это.
Окей.
Output итератор.
На него посмотрим.
On input or output. Он
indirectly writable.
Ожидаемо.
И требуется, чтобы вот такая
шняга компилировалась.
Ну, вот ровно это присвоение. Что разминовали,
присвоили. Причем можно
par-value ссылки, можно pl-value.
И equality-preservation не потребовали
при этом.
Да, помним, по дефолту все выражения
в стандартных концептах требуют
equality-preservation. Если не сказано обратного,
тут сказано.
Чего не хватает?
Ой.
Дико извиняюсь
перед человеком, который будет это
монтировать, или теми, кто слушает на запися.
Ну, надеюсь, на монтаже вырежут,
и страдать будет монтажер.
Но вопрос-то ответьте мне.
Чего не хватает здесь?
Только что смотрели на input
operator, да?
Тут примерно то же самое было.
Ну, мы там разминование уже потребовали, да?
А вот, типа, ставим random access
stack, а он самый
derived, если
здесь...
Нет, что?
Ну, вот, просто чисто на концепт смотрите.
Input
or output, indirectly
readable. Ну, и все.
Input or output, indirectly readable.
И что-то еще, но...
тега нету.
Тега не требуется. Output
тег здесь не используется.
Да!
Да! Внезапно!
Еще, output-утератор от двух шаблонных
параметров. Он хочет
сразу знать, что мы туда можем outputить.
И тега output-утератор не
требует.
Ну, казалось бы...
Когда тебе нечего больше
написать, от безысходности ты можешь его написать.
Но это тебе
никак не поможет.
Нет, смотри.
Random access дефолтный возникает тогда,
когда ты, в принципе,
пытаешься понять, какой концепт
у итератора.
Вот эта вот категория. Чего?
А тут мы даже понять
не пытаемся. Ничего не пытаемся понять.
Мы не пытаемся найти никакой тег,
мы пытаемся его сравнить с output-утератор
тегом.
Загадочная вещь.
Вот меня это тоже в ступор
поставило, когда я наткнулся.
Надеюсь, вы сейчас не заснули
и действительно в ступоре.
Правда?
Давайте окно откроем, а можете
вот, ребят, там как-то чутка
пора.
Сейчас как-то морозит.
Да нет, нифига.
Спится хорошо, когда
душно.
Сейчас очень душно.
И дальше будет душнее.
Итак,
поговорим с вами про апгрейды
итераторов в алгоритмах
стандартной библиотеки и не только.
Вот это вот как раз очень важное
наблюдение про
generic design и то, как писать
хорошие обобщенные библиотеки.
Если вы
успехаете в алгоритм стандартный,
который требует некоторого уровня
итераторов,
то есть constraint написан и требуется
random access итератор или
forward итератор,
вы гарантируете
не кто-то там, а именно вы
компилятору и всему миру, что
либо тип этого объекта
не удовлетворяет
концепту полностью,
именно концепту,
то есть если вы спросите концепт
true или false, он вернет false,
либо что тип моделирует концепт.
Помните слово
моделирует?
Семантические требования.
То есть вы должны
гарантировать, когда зовете
любой алгоритм стандартной библиотеки,
что не возникнет такой ситуации,
что концепт сработал ложно-положительно,
что
семантические требования не выполнены,
а концепт по синтаксису
говорит, что да, мне подходит,
я готов над этим работать.
Ну, короче, мы не обманываем концепт.
Что? Да.
Да, мы гарантируем, что мы
не обманываем концепты синтаксисом.
Ну, как бы,
понятное дело, что другого выхода
нет в принципе, кроме как вот это вот потребовать.
И вот это вот неявное требование всей
стандартной библиотеки, не только про итераторы,
а вообще про все алгоритмы,
все концепты и все алгоритмы стандартной библиотеки.
А дальше идет некоторая рекомендация
или принцип дизайна.
Для любых двух концептов,
где из одного следует другой,
а мы только что их видели,
ну, окей, пока не видели,
но считаем, что видели.
Из концепта contiguous следует
очевидно random access. Из random access
следует forward. Из forward
следует output и input.
В любых таких ситуациях,
когда вы уточняете концепты,
требуете что-то предыдущее,
есть импликация, и вот если это есть,
то чтобы вот это вот свойство,
вот этот принцип гарантировать,
от нас
нам рекомендуют
либо давать возможность явно отписываться
от концепта A,
либо явно вписываться
в A.
Ничего не понятно, да?
А как у нас будет
из forward следовать output?
Что?
Из forward будет следовать output,
мы потом пониже увидим.
Просто это вот так вот работает.
А как мы давим возможность явно отписываться?
Через трейты какие-то.
Ну, сделайте там
для своего концепта трейты,
где там флажок bool или какие-то
теги тоже, которые позволяют
типу, который
подходит под A синтаксически,
но не подходит под него семантически,
выписаться из A.
Ну, то есть ситуация вот такая вот.
Надо, наверное, сюда смотреть в самый низ.
Представим себе алгоритм, который принимает что-то
концепта B.
И он
внутри может пытаться апгрейдить
эту вот штуку концепта B
до чего-то концепта A.
Зачем?
Ну, зачем алгоритму внутри пытаться посмотреть,
а не удовлетворяет ли
еще какому-то концепту
то, что нам дали?
Да, вот STD копия.
По дефолту STD копия принимает
forward iterator. И как оно копирует?
Ну, просто
по очереди идет в цикле.
Инкрементит и копирует.
Но если вам дали contiguous iterator,
можно
Memcopy бахнуть.
Да,
и вам дали contiguous iterator.
Вы можете бахнуть Memcopy.
Копия будет быстрее.
Внутри STD копии написано
if constexpr,
contiguous iterator
и tip.
Так вот, может так чисто случайно
получиться, что ваш
forward iterator
по синтаксическим требованиям
удовлетворяет
contiguous.
Потому что в принципе
то, что iterator contiguous невозможно
проверить как-то синтаксисом.
Да, это в голове у нас.
То есть с точки зрения
языка, если бы мы без всяких
этих тегов писали, у вас бы
концепт contiguous и random access
они вообще равны были.
Поэтому вот этот if был бы
бессмысленным абсолютно.
То есть
вот этот вот апгрейд, он мог произойти
случайно. Этот if на более эффективную
реализацию мог сработать просто так.
Но
бывают и более плохие ситуации.
Бывают, что у вас те же самые операторы,
что требуются в каком-то уточненном
концепте a,
они просто есть у
вашего класса, потому что так исторически
сложилось. Но они там есть
совсем другой семантикой, нежели
требуется концепту a.
Класс концепту b удовлетворяет и моделирует
и удовлетворяет. А концепту
a он случайно удовлетворил, потому
что конфликтами он возник.
Одно и то же имя используется
в концепте a и еще где-то там просто так.
Как тогда быть?
Потому что очевидно, что оно моделировать
а не будет, но удовлетворять ему будет.
Вот нам
дают совет как быть. Нужно всегда
предоставлять некоторый механизм либо
отписки, либо подписки.
Ну, отписка это значит, что
мы можем явно где-то в трейтах написать
я не a.
Вот к концепту a я
не принадлежу. И в сам концепт a
вписать требование, что там
должно быть написано в трейтах, что принадлежишь.
Ну, либо наоборот, явно отписку.
И вот эти...
Это тогда получается, мы для всех
потенциальных таких a,
что из них следует b, должны отписываться.
Да.
Потенциально, да, это каждый концепт
в стандартной библиотеке. По факту
это нужно делать, конечно же,
только в местах, где у вас есть подозрение,
что могут такие вообще вещи происходить.
Вот эти вот апгрейды, да?
То есть если у вас есть алгоритмы,
которые внутри пытаются апгрейдить
с одного концепта до другого,
сделайте возможность
отписки или подписки. Надеюсь, вы все
поняли, почему и зачем.
А если у вас таких алгоритмов нет, то может ничего не делать.
В Голливе делать
gRPC, например.
Там нужно, чтобы был метод
с длинным названием, типа
«я действительно...»
Потому что там дактайпинг...
Вот, да. У нас тоже дактайпинг.
Ну, по отношению
к моделированию. И нам тоже нужно
писать длинный метод, который «да, я действительно
контигиус-атератор». И вот эти теги,
про которые мы только что говорили, это ровно
есть этот механизм подписки
или отписки. Он нужен не просто
там, чтобы уточнить, или для
читаемости, или еще для чего-то, а строгого
для этого, чтобы, когда в алгоритме
вы пытаетесь проапгрейдить итератор до более
мощного, вы случайно не ошиблись.
Чтобы
не было ложно-положительных срабатываний.
Итак, random access
итератор — это дефолт
в нашем случае. Почему? Потому что
больше всего в программе указателей.
Любой указатель — это random access.
И он был выбран дефолтом.
Возможно, исторически. Возможно, и с другим
дефолтом тоже неплохо бы работало.
Ну, вот эта вот историческая данность.
— Указатель, наверное, скорее контигиус?
— Ну, нет.
Потому что ты же не знаешь, куда ты указываешь.
Указатель контигиус,
если он указывает в массив.
А если это указатель в мапчик,
и чтобы его подвинуть,
нужно по указателю прочитать что-то.
И random access
тогда не обязательно.
Ну, не знаю.
Плохое обоснование.
Давайте скажем, что исторический дефолт
сложился.
Но мне все равно ощущение,
что он действительно самый частый.
Мы больше всего орудуем
в жизни с векторами.
А уж я только с векторами.
Как и многие разработчики игр,
потому что вместо мапа у нас есть
vector-map.
Это массив, который автоматически сортируется
на вставке с помощью insertion-сорта.
То есть такой массив с bin-поиском.
Это типа мапчик.
И vector-set, и вот такие вещи.
Они там на малых размерах,
до 32 работают
в разы быстрее, чуть ли не в 100 раз,
чем std-map или std-set.
Не поможет.
Не поможет.
Хэши все равно медленнее считать,
чем положить до 8 элементов
так точно. Всегда быстрее
вектор-set и при вставке сортировать,
а потом
bin-поиск.
Линейный поиск даже быстрее,
чем bin-поиск до 5 элементов
или до 10, в зависимости от размера.
Короче, ладно, все в этом мире
это вектор. Вам рассказывают
про какие-то списки связанные,
мапы, сеты.
Все вектор. Хэши таблицы тоже вектор,
если что.
Ну...
Окей.
Все вектор, возможно, спарс.
Потому что иногда вам нужно
расширяться, не мувая старые
элементы из-за многопоточных соображений.
Поэтому вы делаете что-то вроде
дека. Ну и, короче,
какое-то такое обоснование дурацкое.
Давайте по существу
input forward bidirectional,
вот эти вот теги, это отписка
от того, что мы являемся рандомэксис
итератором. Зачем эта отписка нужна?
Чтобы можно закручить все античистое
инициативное.
Чтобы ложно-положительные
срабатывания подушить,
по синтаксису
можно посмотреть, являемся ли мы input forward
bidirectional, но может быть...
Окей. Можно посмотреть, являемся ли мы
forward, bidirectional или рандомэксис итератор,
но этот взгляд по синтаксису
может дать ложно-положительное срабатывание.
Поэтому у нас всегда должна быть
возможность отписаться до самого
простого, до input итератора.
То есть вот эти теги – это отписки.
Потому что их свойства,
что у forward, что у bidirectional,
что у рандомэксис,
они только по синтаксису не детектятся.
Там есть еще семантические требования.
У
contiguous итератор тега явная
подписка, то есть в обратную сторону.
Мы по дефолту рандомэксис,
но если мы уж уверены, что у нас подряд
байты в памяти идут, то мы можем сказать,
нет, я даже более сильный, я
contiguous.
И вот это уж вообще не детектится
по синтаксису никак, потому что это
чисто семантическое требование.
А вот output итератор
оказывается, никаких
семантических
требований не имеет.
И он всегда
однозначно детектится по синтаксису.
Вот всегда.
Если у вас
по синтаксису подходит
к output итератору,
ко всему остальному не подходит, то все,
вот вы output итератор.
И тут не нужны никакие механизмы
ни апгрейда, ни отписки, ни подписки.
И второй пункт,
то есть вообще, когда у вас
output итератор тег,
когда у вас по факту output итератор, а вы поставите
рандомэксис итератор тег,
все сломается, конечно.
Но не факт, может все сломаться,
если у вас сложно положительное срабатывание
по синтаксису.
Поэтому отписка как бы есть.
Есть output итератор тег, вы его должны
не вписать, если у вас output итератор.
Но почему там нет унаследования
и почему нет всех этих проверок?
То есть вот помните, в концепте не было
проверки, что есть output итератор тег.
И forward итератор
тег не наследует
output итератор тег. Почему?
Потому что ни один алгоритм в жизни
не будет пытаться апгрейдить output итератор
до какого-то другого.
Почему-то так сложилось.
Да, то есть внезапно
почему-то
алгоритмы не хотят апгрейдить
output итераторы ни до чего.
По-моему,
с тд копии не output итераторы требуется.
А может и требуется, а может и апгрейдится.
Хороший вопрос, конечно.
Я нашел это обоснование не сам, конечно же,
а читал...
Да, тут
важное подчеркнуто.
Сейчас.
Ладно.
Короче, потом скажу, где я это нашел.
Вы можете сами еще пересерчить,
потому что тут все еще однозначного ответа
такого удовлетворяющего нет на самом деле,
как это полагается.
Но вот ключевое отличие в этом
согласно некоторым людям.
Что вот эти вещи
мы не можем явно проверить, что
куда мы здесь попадаем
только по синтаксису, а здесь
можем.
Почему-то.
Ну, окей.
На самом деле понятно почему,
потому что вы можете для удобства
определить все методы
random access итератора
для даже
forward итератора.
Можете же, да?
Или для bidirectional.
Они будут неэффективны, но определить можете.
Но
тогда получите
ложноположительное срабатывание на концептах.
И поэтому есть эта отписка.
А для output итератора невозможно
определить какие-то операции,
которые там есть у random access или
у contiguous, потому что он настолько...
Ну, имплементации обычно такие,
что ты пишешь в поток.
Ты там никакие прыжки на n не можешь делать,
ничего не можешь делать.
Возможно, в этом как по сути.
А то, что ты говорил про то, что у нас там может быть
эти плюсы, они на самом деле
исторически сложились, они не то вообще
значат, но они есть.
Ну, да. В этой ситуации.
Ну,
все равно же есть механизм отписки
на самом деле, вот этот output итератор tag.
Сейчас.
Вот output итератор tag был.
Если у вас
эти рандомные исторические плюсы есть,
и вы хотите как-то
безопасить себя, чтобы случайно не сработал концепт
на random access, вот вы этот
output итератор tag все равно пишете.
И тогда вы запретите во все остальные
категории попадать.
А?
Ну, или попадать, или апгрейдиться.
Ну, да.
То есть, это делается.
Вот здесь вот написано про
отписку, вообще вы делаете
для любого a, из которого следует b.
А здесь мы рассмотрели
вперед, мы рассмотрели
только концепты
итераторские. Но наш потенциаль
может быть какой-то другой концепт,
из которого неожиданно следует random access.
Не может, потому что импликация,
мы про это говорили подробно, импликация
строится только если у тебя
явно упомянут
другой концепт в твоем концепте.
Если вот сюда вписать то,
что внутри input or output итератора
написано, то импликации не будет.
Импликация будет только если ты явно
написал именно input or output итератор.
Вот тогда есть импликация из
output в input or output.
Вот.
Да, еще мысль
последняя
на эту тему.
Почему все-таки вот здесь не обязательно
детектится, а вот здесь прям детектится?
Потому что когда мы делаем
indirectly readable, у нас
кванторсуществование, и мы
на самом деле просто типа
не особо понимаем, что у нас конкретно будет.
А вот
когда у нас output итератор,
у нас
в indirectly writable и вообще в концепте
output итератор указан T.
Конкретный T.
Да? Внимание!
Еще раз. Output итератор, здесь конкретный
T указан.
А вот здесь не указан.
И вот из-за этого еще
по синтаксису детектить вот это не получается,
как-то апгрейды туда-сюда.
А output итератор он особенный, он в стране.
У него есть конкретное T, и мы
можем прям проверить, и все нормально
будет. То есть вот какое-то такое
обоснование я составил из
своего гуглежа, здесь
есть прекрасная ссылка, как всегда там
в папочке на Google Drive презентацию уже есть,
они все всегда там. Можете по ней
пройти и перечитать оригинал
мысли, откуда
взялись эти рассуждения,
там еще линки есть всякие.
Ну, надеюсь, я вас смог убедить,
что... Во-первых, донести
некоторые мысли. Первая мысль,
что вот это.
Если вы в алгоритмах
собрались что-то апгрейдить, дайте возможность
подписки или отписки. Пример,
вот он. Вы есть дефолт, есть явная
отписка, есть явная подписка. Где
выбрать дефолт, это вы уже сами должны
решить на основании того, что чаще
используется.
То есть, условно говоря, более частные
случаи, это
мы организуем подписку на них,
от более общих
отписков? Да.
То есть, random access это более частные случаи
input, forward и
direction? Да, и от него должна быть возможность
отписаться как бы.
Это симметричные слова,
просто в зависимости от того, где дефолт,
мы либо подписка, либо
отписка говорим. Во-первых,
делайте так, если вам суждено
когда-то все-таки писать обобщенные
библиотеки.
Во-вторых, иногда вот эта вся система
дает некоторый избой, когда у вас
есть такие вещи, как output, iter, tag.
И тут все становится чуть хитрее,
но зато
меньше боли, да? То есть,
в каком-то смысле
вообще думать не надо, если у вас output
итератор. Просто ни о чем
думать не надо. Он просто работает и все.
Потому что это Т известен ему.
Вот.
То есть, это было сделано специально
или так получилось просто? А по-другому
и нельзя, потому что мы не знаем, что
мы собираемся туда писать, если не требуемо.
Конкретно вот это.
Вот как только у нас будет input и output
итератор, мы как бы сможем
потребовать, чтобы писать можно было
ровно то, что мы прочитали оттуда.
А тут мы читать ничего
не можем, а что-то писать надо.
Надо указать, что писать, и за счет этого
как бы вот
чуть-чуть асимметрия в системе возникла.
Во-первых,
не наследуется вот эта вот штука
output итератор тега. Во-вторых,
вот здесь нету никакого реквайерса,
потому что зачем?
Вот.
Давайте пойдем дальше.
Над этим вам нужно подмозговывать
над output итератором.
Возможно, почитать,
если вам, конечно, все это интересно и вас
это волнует, и станет
лучше. Ну или смириться просто.
Вот по некоторым вопросам я, возможно,
уже смирился, а не понял
на самом деле. Смирился с этой
взглядой реальностью, где происходит какая-то дичь,
и вас пытаюсь тоже так убедить,
что все нормально, но на самом деле
происходит дичь.
Это я не контролирую, это возможно,
но надеюсь, что это не так.
Какой час, кстати, у нас?
Ровно пара прошла.
Ровно пара прошла.
Тогда давайте сделаем перерыв на 10 минут
перед тем, как приходить уже к ранжам-ранжам.
Только мы медленно как-то идем,
надеюсь, дальше ускоримся.
Итак.
Мы подошли к самого важного.
К ранжам.
Но перед тем, как определять ранжи, нам нужно
определить сентинел.
Его мы уже спилерили
на одной из прошлых лекций, да.
Это некоторая штука,
которая при этом
сентинел для чего-то,
ну, s это
сентинел и это итератор.
И вот тип s является сентинелом
для итератора, если он
регулярный,
при этом и это input-output
итератор, и
можно сравнивать s и e,
но
weekly и вот там
with.
Помните ли вы наши долгие беседы про то,
что такое концепт, окончающийся
на with?
И кто такой common type, with
и вот эти вещи?
Common reference with.
Ну, даже если не помните, наверное,
неважно. Суть
можно на оператор равенства
сравнивать инстанции s и e.
Именно в таком порядке
и негарантированной
quality preservation, то есть
с всякими
ice-tream итераторами все
работать будет.
Внутренний, да.
Внутренний, который наружу не вылезает.
Возможно, это из старой версии
стандарта я скопировал.
Вот так вот.
Возможно, разные люди формулировки
писали, поэтому в одном месте
наклонными буквами, а в другом месте
вот так написали. Не знаю.
Да,
мы уже, кажется, про это говорили.
Сантинеллы — это такие
шняги, которые
позволяют по странному алгоритму
проверять, дошли ли мы до конца
контейнера или нет.
Например, с сантинеллом может быть конец файла.
То есть для
ice-tream итератора, который что-то читает
из файла, может быть сантинелл, который
просто при сравнении
итератора с ним смотрит,
был ли последний прочитанный элемент
e, o, f.
Вот так вот.
Может быть бесконечность.
То есть сантинелл, который всегда при сравнении
говорит false — мы еще не дошли.
Это вам внезапно позволяет
сделать итератор, который идет по всем
натуральным числам до бесконечности
и дальше.
Зачем?
Увидим. Полезно, оказывается.
Также может быть сантинелл, который
разыменовывает итератор
и смотрит, лежит ли там
backslash 0.
То есть сантинелл для конца всей строки.
Очень полезная штука.
И теперь
мы можем forward итератор определить.
Я соврал. Еще не ранжи.
После forward итератора ранжи.
Ну да, внезапно для forward итератора
требуется
input.
Аутпут итератора не требуется.
Слушайте, память меня обманула.
Вот видите, как все хорошо.
Аутпут итератора вообще нельзя апгрейдить. Ни до чего.
Да. Ну ладно.
Input итератора требуется. Тег, конечно же.
Incrementable требуется.
Вот тут уже сильный incrementable.
Раньше был wick все это время у нас.
Потому что input-output.
А тут strong и
сантинелл для самого себя.
Что значит сантинелл для самого себя?
Да, вот это
ладно. Это просто значит, что он
регулярный, по сути.
Ну если мы посмотрим на концепт
сантинелла, подставим сюда
i и i, одинаковые
два типа, то
вот это, ну у нас там уже
и итератор, ничего значит не будет.
Ну окей, вернее это будет там
импликацию какую-то делать, не важно.
Вот это тоже ничего значит не будет.
Потому что
нет, будет.
Да, будет.
Потому что да, будет просто оператор сравнения с самим собой.
И semi-regular плюс
оператор сравнения с самим собой это
regular.
Почему не написать regular?
Почему сюда не написать regular, а
сантинелл for сам себя?
Чтобы импликация была.
Чтобы компилятор умел вводить,
что forward итератор, следовательно,
сантинелл для самого себя.
Вот это
regular,
регуляр.
Слушайте, да, наверное
это пофиксили в каком-нибудь c
плюс плюс 23 или 26.
Потому что тут, конечно, хочется иметь импликацию
в regular, а тут ее нету, кажется,
действительно.
Ну...
Да.
Нет, в reg... Нет, просто
должно где-то быть явно выписан концепт
regular. Импликации не берутся из ниоткуда,
они берутся только если вы прям руками
вписали.
А равны, потому что вот здесь equality preservation
не требуется, а вот здесь уже требуется.
Forward итератор
и equality preservation, потому что поэтому все эти
вики слетают, все strong
и все нормально. Forward итератор он
прям совсем нормальный, он регулярный,
он там сравнивается
хорошо, инкрементиться нормально,
никаких проблем с ним нету.
И больше итератора смотреть мы
не будем, потому что мы бы здесь уснули
смотреть все эти разные
bidirectional, random access.
Ну, мы и так уснули, да.
Но они не такие
проблематичные. Их вы сами можете
посмотреть и увидеть, что там
не так все сложно. Там просто
добавляются какие-то простые требования,
вполне резонные и
в общем самостоятельно.
А вот мы наконец-то к ранжапе
пришли, теперь вот все точно.
Итак, определение.
Ранжом со звездочкой,
не просто ранжом, а именно со звездочкой
называется пара из input
итератора и сентинела,
которая такова, что
если они не равны,
то разыменование валидно
и при этом
если сделать инкремент,
то мы все еще получим ранж
со звездочкой.
Рекурсивное определение.
Ранж это что-то,
что можно прочитать его начало
и пойти дальше.
И получить все еще то же самое.
И дальше прочитать еще раз, еще раз, еще раз.
Такая штука.
В принципе, да.
На удивление.
А теперь есть valet range.
А, это опечатка.
Чем отличается valet range
от range со звездочкой?
Да. То есть мы можем
за конечное число плюсиков дойти до конца.
А вот тут не требуется,
как и в наших списках
типов.
И вот как бы зачем нам
бесконечные сентинелы?
Потому что мы можем делать бесконечные ранжи.
Например, все натуральные числа.
А дальше с ними работать
как с тейп-листами и
на слово вы мне не поверите,
что это круто, пока сами не поработаете с этим.
Так что едем дальше.
Concept range.
Простой, как пробка.
Наконец-то.
Ranges begin работает и ranges end.
Все.
И quality preservation требуется
только если вот этот begin вернет что-то
вроде forward итератора
или круче.
Для end ничего.
Для end там все не явно.
Begin очевидно
возвращает итератор end-сентинел.
Но здесь это не написано.
Написано это на самом деле
в самих функциях.
Но еще есть
семантические требования.
Перед тем, как посмотреть функции begin и end,
семантические требования range.
Они немножко
взрывают мозг.
Begin и end
оба
не модифицируют
E и имеют
константное время работы, амортизировано.
Они не модифицируют E,
они константы.
Они не константные методы,
они не изменяют состояние E.
Вот так вот.
В каком случае у нас
амортизировано, значит в каком-то случае
у нас там можно занять
end-акцию.
Begin.
Если вы много-много-много
раз будете звать begin и end,
то у вас амортизировано
зовут единицы они зовут.
В среднем.
Монетки, потенциалы.
Помнишь еще что-то?
Begin.
У вектора Begin знаешь, как работает?
Он зовут единицы честно.
Да,
когда может быть
нечестная единица
амортизированная,
это чуть попозже.
Такое...
Сплей деревья?
Да нет, закашируй просто и все.
Ты хочешь найти
первый элемент сплей дерева,
и выше на каждой вставке будешь обновлять.
В чем проблема?
Ну бывает, короче...
Ладно, на самом деле твой пример правильный.
И все примеры примерно такие будут.
Что в лоб по самой структуре данных
нельзя найти.
Но мы хотим, чтобы у нас begin и end
не ходили ни по каким сплей деревьям.
Мы хотим, чтобы они быстро работали.
Поэтому требуем его от единицы.
Но вот
вопрос в какой момент
вычислять этот кэш.
И вот амортизация нам позволяет
кэш вычислять прямо в Begin.
Но чуть попозже увидим причину
почему именно так. Почему мы не можем
сказать всегда заранее кэш вычисляйте
или что-нибудь такое.
Да,
так же я пропустил, но
значения, которые
возвращают begin и end, они вместе
должны образовывать range,
который не вот этот
range, а вот этот range
со звездочкой.
Что?
Не обязательно valid.
Да, и
тыры-пыры-пыры.
Ну, короче, да, тут про equality preservation
это уже мелочи. Если forward,
то все equality preserving все довольны. Если
нет, то и сюда нет.
Окей.
Да, причем на самом деле
тут забавное уточнение,
что
мы говорим про выражение,
а не про тип конкретный.
Вот я это не тип, а выражение,
которое может быть там l-value,
может быть r-value.
Это не внезапно
влияет.
А что значит
амортизированная константа от
рв выражения?
Что? Нет, ну амортизированная константа
относительно размера контейнеров.
В смысле, амортизированная
константная линия?
Да.
Я это понимаю, но если у нас r-value, то мы не можем
много раз применить.
Ну, может быть, в теории, но
не как все значения, мы можем много раз применить.
Ты такие вопросы не задавай.
Ты чертовски прав, и ответа на меня
нету. Ну,
нет, ты можешь...
Ну, окей,
ты к r-value вообще не можешь
на begin и end применить
вообще-то, потому что
как только ты begin применил, у тебя, типа,
невалидно и...
Ну, получается, e должно быть l-value expression.
Ну, нет, на самом деле нет.
То есть, окей, тебе дали r-value,
но ты как бы используешь на нём
begin и end много раз, но само
сам объект,
сам объект, он не модифицируется,
несмотря на то, что ты как бы
move делаешь.
Да.
Нет.
Ну, да.
Чёрт.
Нет, это...
Окей, нет, это может быть
и std move от чего-то.
Всё выражение вместе будет r-value.
И...
Да, такое
можно написать, и это тоже
осмыслено в некоторых ситуациях. Кажется, что
сейчас точно не скажу. Давайте ехать дальше.
Такой спойлер
на будущее. Вот теперь пришло
время посмотреть время. Мы уже смотрели чуть-чуть.
Вот эта цепошка такая, там
по универсальной ссылке берёт. Действительно
можно передать туда по r-value.
И она вот в таком порядке
и делает свои кастомизации.
Во-первых, она пытается т плюс ноль
сделать. Что это значит?
Это значит, что это надо максимально...
Нет, что... Что это за выражение
дурацкое? Нам дали контейнер,
begin что он принимает? Контейнер
возвращает тератор.
Мы... Чего? Копирует?
Нет, begin дали контейнер
на вход. Здесь t это контейнер.
Мы к контейнеру прибавили ноль. Что это значит?
Что?
Эператор плюс...
Контейнер
tt
это контейнер, это
вектор или рей.
Да!
Это сишные массивы.
Потому что указатель на begin
сишного массива, это
ну просто вот
он плюс ноль.
Ну, окей.
Это действительно делается там
специализациями, но, по-моему,
это, цитата чуть ли не из стандарта,
что там вот так написано.
Это 1 в 1 трюк как с лямбами
делают? Да, типа того.
Чтобы прикастить тип массива к типу
указателя.
Не знаю. А плюс, по-моему,
определённо нарный для массивов.
Плюс ноль определённо.
Ну, не важно.
Просто мы хендлим массивы сишные.
Потом мы пытаемся вызвать метод,
а потом... Что это такое?
Вот это последнее.
Что-то написано. Зачем это?
Ага, это каратский точек астомизации. Да.
Как механизм называется, который
вот тут что-то находит.
Что-то с dl. А?
А dl.
Окей. Ну, со скрипом.
То же самое с эндом.
Только он уже не атератор возвращает
внезапно. Энд возвращает сентинел.
Ну и тут такой же костыль,
где extent-v по типу
массива, у которого указан размер,
возвращает этот размер.
Если не вышло, то мы дальше идём, пробуем так,
пробуем так.
Вот. Да, обратите внимание,
тут ещё требуется, чтобы каждый контейнер
мог говорить, какой у него итератор будет.
То есть это от любого контейнера
нормального требуется, а значит
и от range. Напоминаю,
мы с чего начали. Что мы смотрим,
что такое range, а range просто требуется,
чтобы begin и end были валидными,
а begin и end валидные вот в одном из этих трёх
случаев, где везде
требуется итератор t
и чтобы
итератор вернулся.
То есть если так подытожить,
то range – это
штука, у которой есть методы begin и end,
первая из которых возвращает
input route под итератор,
а вторая возвращает sent and alphore
для ассоциированного типа
итератор t, который должен
тоже быть.
Можно уточнить,
что у нас есть типа end,
not forward,
это в чём-то какая-то функция?
Это как... Короче, тут
чёрт пойми, что написано.
Это не синтаксис плюсов, но
вот эта строчка end от forward – это
синтаксис вызова
неквалифицированного вызова
функции, который ещё и ADL включает.
Если вниз не смотреть.
А вот это я просто написал,
что...
Потому что
неквалифицированный вызов
end. Тут не std end
вызывается, а просто end.
Неквалифицированный вызов значит
работает ADL. Если у нас вот это вот
t и t в каких-то namespace, то там
будет тоже иск от send.
Окей.
Вью.
Вью – это
некоторый
легковесный range, с которым
можно работать, в принципе, как с парой
итераторов, но оно не обязательно
на самом деле является парой
итераторов. То есть это range,
который movable.
Обратите внимание,
в общем случае, ринжи могут быть
immovable.
Default initializable и
явная подписка.
Почему
явная подписка? Потому что есть
семантические требования.
От единицы – всё.
Все действия, которые
совершаются над view, над ринжами,
которые являются view, они должны
делаться за от единицы.
Если копируемо, то и копирование
за от единицы.
Move, конструкторы, деструкторы
от единицы.
Вот. То есть
давайте кто-нибудь
своими словами объяснит
из этого и
того, что я раньше рассказывал,
зачем здесь enable view?
Чтобы случайно тут ещё могли быть такие свойства,
если не стало view, пока мы явно не написали, чтобы
был view, потому что мы не можем
сказать, то есть компилятор не может проверить, что это
выполняется. Да, компилятор не может проверить,
что у нас копирование
за от единицы.
Да. То есть
без enable view вектор стал бы view,
потому что movable, movable, default
initializable – ну да.
Ринжом вектор, очевидно, является.
Это базовый вид ринжа.
View должен
за от единицы копироваться и прочее.
Он не владеет данными, он только на них
смотрит. Такая
ссылка, не владеющая на данные.
Эти требования
проверить невозможно.
Поэтому мы явную подписку делаем.
Вектор конструкции за от единицы.
Вектор конструкции за от единицы.
Mova тоже за от единицы.
Нет. Ладно, нет.
Нет.
Можно написать такую имплементацию Mova у вектора,
которая будет за от единицы.
Своп.
А вот деструктор уже тогда будет не за
от единицы, потому что нам надо освободить
эти элементы.
Копироваться точно вектор будет не за от единицы,
поэтому вьюхой вектор не
является.
T это контейнер.
Мы начали говорить про контейнеры.
Контейнер является ринжом, если у него
есть вот такие штуки.
Контейнер является
вьюхой, если у него есть вот такие
штуки.
Да.
Что касается того, что считается
сложностью.
СТД рэй является вьюхой,
потому что в рантайне у него
константная сложность.
Такие вопросы ты не задавай.
Да, копируется за от единицы.
Если каждый его объезд
остается на...
Это абсолютно корректный вопрос, который у меня есть.
Это получается, что
рэй от некопируемого
контейнера
будет вьюхой.
А ну да, будет.
Это
центральный вопрос,
на который у меня ответа нет.
В стандарте просто берут
и пишут от единицы.
Что вас учили на матане целый год
не делать.
Писать вот так.
Чего здесь не хватает?
Да, при каком
стремлении чего куда от единицы.
Вдалбливали, вдалбливали, вдалбливали, вдалбливали.
Не пишите просто ошки.
Должно написать от единицы
запятая, н стремится к бесконечности.
А еще уточнить,
что за н, какая н.
Здесь это нигде не уточнено.
Поэтому черт его знает.
Интуитивно вы должны себя
удивить, что это от единицы.
Все.
Ну да.
Ну то есть,
я не знаю.
По-моему в стандарте для STD Rea
не сделано enable view, поэтому все-таки
Rea не вьюшка.
А по тюплу одинаковых типов
ты не можешь пройти с итератором?
А, можешь.
Ну это то же самое, что Rea, ну короче тоже нет.
Вот, ну я вам скажу не только
что стандартизация от этого страдает.
Я там для своей научной работы
статьи время от времени читаю.
Я знаю страшные вещи, но там тоже все пишут.
Математики, профессиональные.
Просто от там того-то от, сего-то.
Кто и куда стремится, никто не уточняет.
Ты сидишь и
пытаешься угадать, что было в голове у авторов,
что они и куда стремили,
когда это написали. И там порой такие
нетривиальные ответы бывают,
что они рассматривали произвольную
последовательность случайных графов,
которые сгенерированы там вот как-то так-то и сяк-то.
И вот когда номер
графа в этой последовательности стремится
к бесконечности, то у нас будет
от чего-то. О!
Конечно это писать не надо.
Это абсолютно очевидно. Здесь такая же ситуация.
Сделать ничего с ней не можем.
Поэтому просто пойдем дальше и посмотрим на
EnableView
и вообще откуда он берется.
Вот есть такая штука ViewBase.
И EnableView
требует ровно этого, чтобы вы
в этот ViewBase наследовались.
То есть каждый раз, когда вы пишете View,
View надо писать
с нуля. Потому что это совершенно новое
понятие стандартной библиотеки.
Раньше такого понятия не было. Поэтому
ни через какие трейты
ничего старого сделать
вьюхой нельзя.
Потому что вы, скорее всего, нарушите вот эти вот
семантические требования и все полетит.
А надо переписать SliceView
и просто расследоваться?
Ну, формально да. Формально вы должны
в свой SliceEspance впихнуть EnableView
через ViewBase.
Но есть второй вариант.
Вот есть тут DerivedFromViewInterface.
Вот это очень
классная штука. Но тут опять через
тире написано, поэтому никакой не концепта
так словами описывается.
Да?
Да.
Да.
Вы должны публично отнаследоваться
от ViewBase.
Ну, вот так решили.
Ну, такой код
никто точно не напишет.
Я бы не так делал.
Я бы потребовал объявления
поля. Или объявления
типа ViewBase внутри структурки.
Но тут почему-то вот так решили сделать.
Ну, или сделать
какой-нибудь ViewBaseTrade,
в котором нужно специалистов.
Вот.
Нет, нет.
Вот этот вот
Trade, где Bool выставляется,
вот это вот мы не хотим.
Потому что у нас есть всякие legacy-типы
старые, до плюсов двадцатых
сделанные, которые как бы похожи
на View и всякие
не очень внимательно читающие стандарт программисты
могут захотеть из них сделать View.
А там STD Begin
за линию высчитывается.
Или там копируйня за
логарифм. И вот чтобы этого избежать,
мы требуем
не указывать старым
типам, особенно если они из других
библиотек, через какие-то
там трейты, где-то там непонятно
где, что они являются View.
Да?
Исбейзов.
Исбейзов.
Он же работает
и только при публичном.
Не знаю.
Не знаю. Можно дефект репорт
отправить. Ну, или это и поменяли
в двадцать третьем, двадцать шестом.
А если хочешь пересчитать, чтобы что-то считалось с View,
то есть оно расследовался с чего-то,
при этом ты им пересел метод, а он пересел с View.
Ну, бери наследование. Короче,
это такая мелочь. Ребят,
давайте не зациклються на этом.
Вот мы и так уже много времени тратим.
View Interface. Это CRTP.
Наш любимый.
Он требует от вас сделать свой
Begin и End. И автоматом вам
все вот эти вот методы нагенеривает.
Через CRTP.
Это супер удобно.
То есть половина методов, которые вы писали
ручками в слайсе, можете их не писать.
Все вот это вот вам
дают бесплатно.
В слайсе,
а как это квадратные скобки?
Что?
Begin плюс... У вас же
random access стератор.
Begin плюс End.
В слайсе тоже random access.
Но стератор...
Не contiguous, но random access.
Какие проблемы?
Ну, то есть как бы...
Короче, все это нормально будет.
Вот эти вот штуки они генерируются
только если соответствующий
концепт удовлетворен.
И там всякие хитрости немножко есть.
И вот там
кое-где еще там вот эти точнения,
что size за от единицы должен работать,
поэтому он только для random access
сгенерируется. И оператор
квадратной скобки тоже, по-моему, только
для random access сгенерируется.
То есть он на ваш Begin посмотрит, вы random access
вернули. Если да, то все.
А view требует...
В view требует
contiguous стератор? Нет.
А как мы этот дат возвращаем?
Ну, смотри,
вот этот view
interface,
в нем есть дата, и там написано
requires contiguous
стератор декалтай под Begin.
Вот. Ну и все.
Если у вас Begin, который вы написали
возвращает contiguous стератор, то вот этот метод
будет включен. Иначе выключен.
И все.
Окей.
Давайте разбираться, кто из них в view?
Нет.
Спан точно, string view точно.
Спан точно, string view точно, slice.
Удивительно, судя по личику, нет?
Да нет, да.
Ну, то есть...
Ну, мы сами slice написали.
Прикольно.
Но это наш slice, сами придумали.
Но, в общем-то, правильно.
Спан, string view и slice — это вот это в view-хе.
Было бы забавно сказать, когда в view
не было бы view.
Да, было бы немножко неловко.
String array
и vector, конечно же, не в view.
Ну, по разным причинам.
Копируемость и прочее.
Не от единицы.
Теперь
мы плюс-минус поняли, что такое RNG
и что такое view, я надеюсь.
Как с ними работать?
Первая категория способов
работать с ренджами или view-хами —
это создать новую view-ху.
Для этого есть семейство функций,
не функций, cpo-шек,
не cpo-шек, непонятно чего,
которое нам умеет возвращать
новые view-хи.
Да, ну...
Короче, в чем проблема? Вы смотрите
в cpp-референс, там написано.
Ну, что такое empty-view?
empty-view — это inline constexpr
unspecified empty-view
равно unspecified.
Или empty.
Могут быть.
Поэтому
все эти вещи — это объекты,
которые типа unspecified со значением unspecified.
Но неважно.
Я думаю, вы можете догадаться, что они делают, правда?
Что все эти штуки делают?
Вот иота.
Вот иота не очевидна, да.
Давайте смотреть.
empty-view — это пустая вьюха
на ноль элементов.
Тип обязательно надо указать,
потому что нетипизированных вьюх RNG.
Всегда есть 200 тип.
Single-view оборачивает один элемент.
Тут тип тоже обязательно нужен,
но он выводится.
В single-view
думаю, что нет.
Почему?
Да тоже, наверное, нет.
А, ну стоп.
Вспоминаем, вью всегда должен муваться.
Так.
Значит, single-view, ну где
хранит свой один единицный элемент?
Наверное, внутри себя. По значению.
А если он
не мувается за от единицы?
Если он не мувается за от единицы,
то
ну, ты проиграл.
Нагомо считается, что
все-таки элементы вьюхи
муваются за от единицы.
Да, да, да. Кстати, вот это вот
от единицы вьюха мувается,
введу, что относительно
количества, относительно
времени мувания одного элемента.
Но тут и так один элемент, поэтому
во всяком случае зовут единицы, и все хорошо.
Можно не париться.
Да, еще
вот такой синтак
сейчас вы встречали когда-нибудь? На всякий случай хочу
его упомянуть хоть раз в наших лекциях.
Inplace.
Что это такое?
Это же конструктор какой-нибудь.
Ну, чем отличается
вот это от вот этого?
А, заменить прям.
Ничего.
Что он зовут конструктор 3 и аж 3?
Да.
Внутри SingleView лежит свой
стринг, поле. И вызов вот такого
конструктора, он прямо
у этого поля, которое внутри
SingleView лежит, у этого поля
вызовет его конструктор от аргументов,
которые после inplace.
Чем это отличается от этого?
А тем, что здесь будет move произведен.
Ну, на int это без разницы.
А вот на стринге move это
чуть более жалко может быть.
Или на каком-нибудь array.
Ну или там даже копия может быть.
То есть это способ
избежать лишнего вызова move конструктора,
если вам жалко.
Или если у вас немувабельный тип.
Хотя тут конечно
да, немувабельных не бывает.
Но такой же есть optional и еще некоторых
контейнеров, вот если вы не видели.
Это тот самый tag-based
dispatch, который
мы видели где-то,
я уже забыл где, но видели.
Inplace это тег и есть отдельная
std lockguard.
Вот мы там его видели.
Тут такой же тег inplace, это
именно значение, а тип у него
inplace.t
Вот здесь
ты обязан вот это значение, которое тебе
дали, move-нуть в свое поле.
Вот single view у него есть поле, туда нужно move-нуть
вот это значение. А тут ты конструируешь
этот стринг,
прям это поле, типа стринг, конструируешь
аргументов.
Ну да, мы move-аем аргументы
для конструктора.
У самого типа move конструктор не вызываем.
Это может быть быстрее.
Тоже верно, да.
Что?
А да, тут временная
переменная конструируется, у нее тоже
деструктор зовется, это тоже может быть там
нехорошо. Yota, вот то, что
не очевидно, вот числа будут.
1, 2, 3, 4, 5.
Теперь все очевидно.
Yota
это греческая буква.
Видите там
яблоко.
Это Apple, но не тот, о котором вы подумали.
Это язык программирования
такой парадигмы,
как array-oriented programming.
То есть есть object-oriented
programming, а есть array-oriented
programming. Это совсем
типа чуждая нам
современным людям парадигма, но когда-то она
была очень модной.
Как ты угадал.
Больше всего эта парадигма похожа
на нампай.
Когда у вас есть тензор или массив,
и все операции сразу
бродкастятся на весь массив,
всякие тензорные произведения берете
и махаете с данными руками.
Это язык, который нативно
для этого делался, а не библиотечка
на питоне, черт пойми как работающая.
И там
чем он знаменит?
Когда-то давно
компьютер это был
mainframe, стоит в подвале в вашем
университете, а у вас в кабинете стоит
терминал.
В Яндексе
так до сих пор.
Есть сервер, который где-то далеко,
а есть терминал. И терминал это не
компьютер, это просто монитор, а раньше
это была не монитор, а печатная машинка.
И вы кнопки вбиваете, нажимаете
enter, по проводу на mainframe
отправляется ваша строчка, возвращается
новая строчка, и печатная машинка
вам печатает сама, что вам сервер
ответил.
Собственно, вот эти 31 символы,
32 символы в начале кодировки ASCII,
это с тех времен.
Вот, это вот
телетайп, как раз оттуда слово пошло,
и в чем проблема такого подхода?
Блин, ждать долго. Пока у вас
распечатается этот код на C++, 200
строк, чтобы Hello World
напечатать.
Да-да-да-да.
Да-да-да-да.
Вот
очень проблематично.
Поэтому языки старались делать
максимально компактными. Ребят, вы можете
пожалуйста не переговариваться параллельно со мной,
я теряю мысль, и на записи может быть слышно,
и короче...
Итак.
Как решить проблему? Долго
печатается. Надо сделать языки,
в которых меньше символов.
Ну, язык Apple очень
хитро решил эту проблему.
Он сказал, давайте мы несколько
символов будем комбинировать,
друг на друга нашлепывать, и говорить, что это отдельные
символы. У нас есть плюс
и есть буква O. Давайте
напечатаем плюс, нажмем Backspace,
напечатаем O, и будет плюс
в кружочке, типа как там
прямая сумма.
Да. Вот.
И отличная идея. И там
код на языке Apple выглядит как какое-то древнее
заклинание на неизвестном языке. В том
числе там греческие буквы используются, всякие
диагритики какие-то.
Да. Йота пошла
оттуда. Стандартные
функции Apple. Была буква
Йота, одна буква.
Надеюсь, вы знаете, как она
выглядит, как буква I, только
без палки. Вот это Йота.
И вот этот символ, эта буква,
она как раз распечатывала последовательность
чисел. И с тех пор
традиционно во многих языках
используется Йота.
Так вот. Вот про это мы проговорили,
что от одного до пяти не
включая пять. А можно вот так еще написать.
Что это значит?
Несконечность не придет.
Да, это range всех натуральных
чисел от одного и так далее.
Внезапно
n будет unreachable
sentinel. Прям стандартной
библиотеке, специальный тип для
сентинела, до которого никогда невозможно дойти.
Он всегда при сравнении false возвращает.
И вот этот view, она
ленивая. Вы могли
подумать, что view внутри себя заводит
массив чисел от одного до пяти. Ничего
подобного. Просто оно возвращает
итератор, в котором запоминает текущий
элемент. При разминовании его возвращает
и при
инкременте просто увеличивает.
То есть оно работает
лениво, как в Хаскеле, например.
Вы можете
сделать Йоту на миллиард элементов,
памяти займет восемь байт.
Это и позволяет бесконечные списки
делать. То есть точно так же, как мы ленивые
тейп-листы изобретали, в ренджах все
вьюхи ленивые.
И
немножко про требования
Йота-вью.
Ну,
я тут так писал.
Йота-вью – это класс.
Вот тот самый викли-инкрементабл, который
мы все ждали.
Тот тип, который мы из
этой Йоты будем доставать,
вот он указывает первым аргументом
викли-инкрементабл.
Может быть int, а может быть другой итератор.
Внезапно можно сделать
Йота-вью на все инкременты нашего
итератора.
И есть тиктри-баунд,
который по дефолту там unreachable-sentinel,
но может быть что-то другое,
если вы там вдруг хотите что-то хитрое
делать. Не уверен, зачем это нужно.
Да, и внезапно еще самиреглар
требуется поверх викли-инкрементабл.
Что, ну,
немножко странно, почему не требовать
инкрементабл, но, видимо,
не хотят.
Так, про айстрим-вью.
Вот такая штука.
Вот представим,
что из консоли ввели вот это вот.
То есть какие-то флоты и какие-то
символы пробелов там, странные.
Вот это все, если что, это разные символы
пробелов. Мы можем
взять и сделать копии из айстрим-вью
в
oStream-итератор на cout и
нам как бы распарсят
флоты
подряд идущие через пробел
и сделают из них вьюху,
а потом из этой вьюхи мы переложим
все на выход, но уже через запятую.
То есть, как бы,
вот этот алгоритм, он все, что делает,
это заменяет пробелы на запятые вот в этой строке.
Где?
Айстрим-вью и oStream-итератор?
Ну, ты их один раз,
скорее всего, в программе напишешь.
Ты не так часто по айстриму
итерируешься.
Ну, вот, собственно, на этом все с тем, откуда брать вьюхи.
На самом деле у вас должны закрадываться
какие-то подозрения, что должно быть
какое-то вью на целый контейнер.
Но об этом чуть позже.
Есть
адаптеры.
Адаптеры берут на вход другой,
один рендж,
один вью, на выход выдают другой вью.
Ну, то есть, такие
обертки над другим вью и делают
какое-то преобразование.
Фильтры transform, take,
take while, все прочее. Кажется, эти слова
мы уже где-то видели.
Поэтому мы должны интуитивно понимать, что делают все эти вещи.
Есть претензии к фильтру.
К фильтру? Сейчас будет наша претензия
к фильтру, не спилди, пожалуйста.
К всему есть претензии.
Тут везде все
достаточно нетривиально.
Ну, вот, дроп, ну, понятно,
что такое. Дропнуть первые
n элементов. Или там
take. Это взять первые 5 элементов.
То есть, например, вы можете сделать
бесконечный список на все натуральные числа,
а потом сделать take 5.
И возьмете первые 5.
Ну, вот, начиная с этих
адаптеров,
начинаются танцы с бубном,
с тем, как их вызывать.
Потому что, вообще говоря,
вообще говоря, это все классы.
И вы можете спокойно создать инстинкты с этого класса,
вызовы конструктора, и все будет работать,
как вот здесь написано. То есть, фильтр view,
вы ему даете какой-то range или view,
и он
не какой-то предикат,
он фильтрует.
Можете написать
просто фильтр. Можете
написать фильтр и аргументы
переставить местами и в круглых скобках
написать. А можете
range, который вы запихиваете,
пайпнуть, как в башее,
в фильтр от предиката.
Да, это самый крутой способ,
потому что это вам позволяет делать длинные
пайплайны обработки данных.
Прекрасно читаемые.
Слева-направо читаешь?
Нет, на новой строчке.
Сейчас, короче, будет пример.
Сейчас пример будет, как это выглядит.
Пока давайте
с тем, что вот это вот за шняга такая.
Вот это вот range adapter object называется.
И он не bloat.
Не точка кастомизации.
Вот фильтр
begin-end были точками
кастомизации, а это нет. Это просто
не bloat.
И вызвать его можно от двух аргументов,
можно от одного.
То есть это вот объект, у которого есть
деператор круглые скобки, с двумя аргументами,
а также с одним.
И если вы вызовите его с одним
аргументом, вам вернут то, что называется
range adapter closure.
Замыкание.
То есть мы
как бы вернули
лямду, по сути,
у которой уже зафиксирован первый аргумент
предикат.
А вот такой синтаксис позволяет эту лямду
вызвать от range.
Ну или можно просто как обычную функцию вызвать.
Коррирование.
Говорили мы с вами про коррирование что-нибудь?
Ну вот это оно.
Ну вот мы
захотели применить частично
функцию, только к одному аргументу.
Один зафиксировать, другой оставить.
Так, всем кроме первого.
Ну это коррирование.
Почему удивленный взгляд такой?
Ну вот не коррированная версия.
Вот коррированная версия.
Ты вызвал только от предиката.
Тебе вернули функциональный объект.
У которого уже один аргумент.
Range.
Ровно коррирование.
Можешь.
Можешь сохранить переменную
и потом куда-то пихнуть
или вызвать.
Да.
Все эти строчки эквалентны.
Все это одно и то же значение.
Все, пропало удивление.
Давайте дальше.
А, да.
Тут тоже прям явно написано,
что C это название
какого-то адаптера.
И тогда вот C подчеркивание вью,
C от аргументов, C от коррированных
аргументов и вот такой пайп.
Оно все эквивалентно.
То есть для всех, что я там показывал,
фильтр, дробь,
все это эквивалентно.
То есть все это эквивалентно.
То есть для всех, что я там показывал,
фильтр, дробь, тейк, трансформ.
Че?
Нет, стрим это
айстрим вью.
Это не адаптер.
Это фактори, да.
Адаптер они берут один вью на вход
или один рендж на вход и возвращают вью.
То есть вот это вот просто
некорректное будет определение
для того, что не является адаптером.
Потому что всегда первый аргумент на вход
это другой рендж.
Все остальные аргументы не коррируются.
Руками закостыли на да.
Примерчик, по-моему, у нас.
Вот мы взяли йота 0.
Это все числа натуральные.
Ну, матложные натуральные числа.
С нуля начинаем.
Палка, фильтр.
Ну вообще рекомендуется палку на следующей строке писать.
Я не знаю, почему тут на этой же написано.
В общем, запихнули йоту
в фильтр, который
выкинет элементы,
которые
не 0 по моделю 3.
Наоборот.
Наоборот оставят те, которые
выкинет то, что по моделю 3
ноль.
Это все еще вьюшка.
Одна вьюшка стала другая, теперь третья.
Ты о правильных вещах думаешь.
Но ты не дошел до истины пока.
Сейчас дойдем.
Трансформ, ну это как мап.
Вот в задачи тайп-листов оно мап
называлось.
Пока да.
Это важно, кстати, почувствовать
душой. Все эти вещи,
они не запускаются
вообще. Они конструируют
некоторую сложную луковицу из вью,
которая оборачивает вью,
причем все они оборачивают друг друга
шаблонно.
Нет.
Уходи со своими сэндерами.
Не пугай детей.
Были.
Забыли уже.
Троп-пайл.
И выкинули первые
несколько элементов.
Все, которые меньше 20.
Пускай троп-пайл что-то или нет.
Правильные вопросы
сдаешь. Я на них пока ответов не даю.
Взяли тейк 5.
И вот получили.
То есть, в какой момент все эти
вычисления, которые мы здесь написали,
запускаются?
Вот только здесь, да.
Да,
все эти вычисления...
Интуитивно
все эти вычисления запускаются только в момент,
когда мы начали итерироваться.
Причем более того, каждый элемент
лениво вычисляется.
Очень просто.
Все эти ребята запоминают
в новом типе,
какую операцию они должны произвести,
и какая операция была предыдущая.
Что-то типа того.
Ну да,
потому что здесь все статическое.
Потому что ты буквально,
когда ты делаешь фильтр от вот этой йоты,
у тебя в тип
вьюхи, которая вернет вот эту функцию,
вшивается, что
у нее есть поле йота,
и эта йота там хранится просто как элемент.
Ну и...
Вот это все в шаблонах.
Потом все схлопывается и оптимизируется,
и тут оверхеда ноль.
Вот этот код работает с такой же скоростью,
как если бы вы руками написали тот же код на C
или даже быстрее.
Ну то есть, вот сейчас про
InlineLand,
если в том же фильтр у меня вот там
процент 3,
если у меня это процент N,
и N вводится из консоли.
Да все равно инлайнится.
Инлайнится не значит предпочитываться
инлайн просто значит, что здесь
очень хорошо заоптимизируется код
до цикла, в котором все вот
как бы вот прям вот здесь в цикле
будет высчитываться следующий элемент последовательности.
То есть нужного функции тут ни одного не будет?
Ну да, да, да.
Ни одного.
Ленивость за счет того,
что ничего мы не вычисляем.
Мы просто строим сложный объект вью,
в который внутри как-то зашита
схема, по которой считать его
элементы. Вот внутри вью...
А это runtime scheme или compile time scheme?
Наполовину compile time,
наполовину runtime, потому что такие вещи
как вот этот ноль,
он как бы runtime прокидываться должен,
а вот в каком порядке
мы операции применяли,
это compile time.
Давайте, да,
небольшой комментарий, вот это вот мусор,
вот эти символы выделенные,
их надо выкинуть отсюда.
И тогда язык будет хороший.
Никак. В том-то и проблема.
То есть пока что у нас немножко плоховатый
язык на самом деле.
Ноль должен прокидываться в compile time,
а... На самом деле, да, тут все вы записаны
новыми символами выражения.
Да. Вообще тут весь будет numbers,
он его константный, если не шавайзер.
Да, да, да, по факту все будет
в compile time, но теоретически мы могли с консоли
ввести первые элементы, тогда вот эта штука
это очевидно должно быть прям поле.
То есть переводы определяются в compile time,
а вот то откуда,
то сколько раз...
Да, там прям есть поля.
Да, runtime поля, сколько,
чего, куда.
Сейчас мы посмотрим на то, как это разворачивается.
Да, можем
взять 10, можем взять 5,
все это будет работать, то есть можно даже
переиспользовать эту вьюху.
Окей.
Что там дальше?
Вопрос.
А...
Да, это концепт range,
все, у меня мозговой затоп
произошел, выведет ли нам true или false?
Видите код, вот vector сделали,
vv, decal type
его является range'ом?
Ну, это без подвоха пока.
Всегда первый вопрос
без подвоха. Да, действительно, range все нормально.
А вот
вьюха является vector?
Не является,
потому что нет enable view,
потому что копирование не зовут единицы.
А вот этот вот, я
пофильтровал этот vector и получил
какую-то шнягу.
Вот она view, да?
Тут range спрашивают.
Да, и range тоже.
И view тоже, но потому что даже
название как-то, filter view, вот это все.
Окей.
Ну, пока все более-менее очевидно.
Подожди, то есть можно
использовать vector в view,
если применить filter,
который всегда true возвращает?
Есть более нормальный способ.
Есть более нормальный способ.
Вообще я сказал, что вьюхи принимают
на вход другие, ну, view адаптеры
принимают на вход другие вьюхи.
А здесь у нас каким-то волшебным образом
vector, какой-то range,
не вьюха, сконвертировался во вьюху.
Вот этот волшебный образ пока
за скобками отпускаем,
сейчас дойдем до него.
Вот так летит по векторам,
например, вектор, то результат
затирается, походу затирается вектор.
Сейчас поговорим про это.
Сейчас поговорим про это.
Ты в правильную сторону копаешь,
и тебя ожидает разочарование в жизни.
В жизни или в плюсах?
В плюсах в жизни не уверен.
Вот, про типы.
Все, наконец-то про типы чуть-чуть поговорим.
Вот это вот
от элемента нечетное.
Тип какой будет?
Вот эту штуку вы должны были уже
видеть где-то.
Подвох в том, что 25 и 26
выбраны неправильно.
Подвоха
нету.
Это pretty function,
мы про него говорили, он позволяет нам
посмотреть к строку типа.
Давайте ее посмотрим.
Строка будет вот такая.
FilterView от refView,
от вектора
и лямбда.
То есть внимание,
мы в FilterView
вот здесь запихали сколько аргументов?
Два. Во-первых, вектора,
во-вторых, лямбду.
И типы обоих этих аргументов
вшились в тип FilterView.
К вопросу, за счет чего
эта ленивость достигается.
За счет того, что у нас
типы аргументов каждого адаптера
вшиваются в тип самого шаблона адаптера.
И хранятся как поля,
соответственно, то, что нам прислали.
И мы все статически
в compile-time композируем
в одну большую толстую структуру
без всяких динамических локаций
или виртуальных каких-то функций.
И компилятор это все в пух и прах
рвет и все работает.
И оптимизится отлично.
Тут возникает
вопрос к этому.
Казалось бы, мы передали просто вектор
на вход, а он обернулся у нас в refView
какой-то автоматом.
Но кажется, мы не сейчас
будем говорить про это.
Чуть позже.
Но тем не менее, догадаться можно,
что это, наверное, view на весь вектор,
но почему он здесь и почему не как-то по-другому
рассказ позже будет.
Да, вот мы с этим
разобрались, да.
Кто view, кто range.
Теперь начинаем творить непотребство.
Const.Vector является ли он
range'ом и является ли view'хой?
Const.Vector является view'хой.
Так тут пока про сам vv,
вектор.
Ну да, ничего не поменялось.
А теперь про od.
Как будто бы
не должно ничего поменяться.
Два человека заявляют
провокационно, что это
не является range'ом. Почему вы так думаете?
Const.View у нас.
То есть вектор, он обычный.
Const.View.
И range'ом и view осталось.
Андрей, ты не давай подсказок.
Ну ты, скорее всего, додумаешься правильно.
Людям, которые впервые это слушают,
подумать.
Там что-то с move'ом, нет?
С move'ом?
Ну нет, технически
все равно даже const можно
move'ать и копировать это все можно.
Нет, не с этим проблема.
Да-да-да, там все стандартные view'и, они
копия был, по-моему, и поэтому
просто вместо move'а копия будет.
А в чем проблема?
А вот в чем.
Действительно, внезапно
это не будет являться ни range'ом,
ни view'ой.
Просто const навесили, оно уже не range.
Давайте часать репы
и вспоминать, какие требования были к range'у.
Begin и end.
Они const должны быть.
Non-modifying, begin и end.
И за от единицы работают.
Что-то из этого
именно у filter view
нарушается.
Каширование
за от единицы.
Вот.
Теперь нужно, чтобы все остальные поняли.
Да, вот у нас такой концепт
был.
И внезапно, внезапно,
тут вот такое требуется,
тыры-пыры, внезапно
у begin и end
у filter view
нету константных перегрузок.
Вот у них begin и end
они модифицируют что-то.
У filter view и еще у нескольких
вот filter view, drop while view,
drop view.
У всех из них begin и end
что-то внутри модифицируют.
С как бы общечеловеческого
точки зрения они non-modifying,
но при этом
они не могут быть range'ом,
если на них const навесить тогда.
Да, вопрос.
А как у этих
view за от единицы считается
begin? Задумайтесь.
Вот оно место для использования mutable
в структу.
Казалось бы, но нет.
Давайте, как посчитать
begin у filter view?
Идти вперед, пока не найдем подходящую.
Будет ли это амортизированного
от единиц? Не будет.
Мы каждый раз можем до конца дойти и ничего не найти.
При конструировании
по-моему нельзя,
а может и можно.
Почему
при конструировании
нельзя считать?
Конструирование за от единицы
должно быть, да.
Конструктор у view всегда должен
быть за от единицы.
Амортизированного
от единицы, а это другое.
Амортизированно относительно 10 разных
вызовов begin. Конструктор ты один раз
вызываешь. Он тупо за от единицы
работает строго.
А begin работает амортизированно за от единицы.
Если ты 10 раз
разных begin вызываешь
и делишь на 10, то должна константа получиться.
Ну что мы сделаем?
Мы в первом вызове begin пробежимся
за линию и найдем этот begin
и закашируем его внутри filter view.
А в последующих
begin мы просто будем из каша доставать.
Вот мы амортизировали.
Я не знаю, почему.
Не mutable.
Может там
оптимизация уйдет.
Меня самого этот вопрос интересует,
но вот говорят
mutable плохо.
Более конкретного нет у меня.
Ну в этих тоже понятно, что тоже самое
происходит, да.
Но только drop view со звездочкой.
Почему со звездочкой?
Ну drop view
дропает первые 10 элементов, скажем.
Да, если
итератор у нас нормальный,
там contiguous или random access даже,
мы можем на 10 элементов вперед
продвинуть и все. Больше ничего делать
не надо.
Что?
Да, да.
Cons drop view будет нормальной view
если у вас внутри лежит
random access итератор. А вот если у вас
forward итератор или bidirectional,
то там шагать надо за линию.
И тогда опять нужен cache.
Вот такие фокусы
и подводы и камни внезапно.
Но эффектов у этого на самом деле
еще больше, чем вам кажется.
То есть помимо того, что там вот эти
cons штуки не являются view,
давайте еще такой код рассмотрим.
Все еще там чиселки, взяли
нечетные и поменяли
уже после того, как мы составили
фильтр, поменяли на 5 нулевой
элемент. Что выведет?
А если он расширится, то это begin не const?
Begin не const.
Вот у
begin и end
вот у этих ребят
нету константного begin и нету
константного end.
Нельзя кашировать при конструировании.
Мы только что выяснили.
Вот единицы.
Начинается
считаться в момент вызова.
Он будет считать, что первый момент 5.
Да, то есть вот ровно так.
5, 1, 3, 5.
Сейчас я что-то хотел сказать.
Да, тут ты начал говорить
про то, что рекомендации так не делать есть
в стандарте.
Begin и end non-modifying.
С точки зрения внешнего мира.
А cache наш внешний мир
наблюдать не может, поэтому
как бы они non-modifying.
То есть вот это non-modifying оно
было не про константность строгую,
а про человеческую
интерпретацию, грубо говоря.
Опять неточные формулировки.
Теперь
усложним задачу.
Мы сделали так. Сначала вывели
то, что в этой вьюхе лежит,
потом поменяли изначальный вектор,
а потом опять вывели.
А здесь он пропустил
на первый элемент.
Да, в обоих случаях
причем?
Из этого
рекомендация.
Коль скоро у вас хоть одна вьюха
на ваш контейнер жива, ни в коем случае
не модифицируйте его.
В гораздо более
непонятном виде.
В гораздо более
непонятном виде.
Какой мув?
Нет, ну просто
вы какую-то вьюху
сделали, чтобы какие-то данные
завьювить, а потом их вынести
оттуда, видимо.
Есть что-нибудь типа
дот рефреш,
которое скидывает все куши?
Нет.
Напиши бумагу.
Ну да.
Сейчас такого нет.
Да?
Я понимаю, что у нас
в первом форе от уже там
подставляется и все считается.
Мы бегин здесь вызовем, мы пройдемся
насквозь и каши сгенерируем.
Да, и во втором форе
уже не будет пересчитываться.
Да, каши не пересчитываются.
А вот значения
пересчитываться будут, внимание.
Есть каши для бегинов,
а есть вот эти итоговые значения,
которые мы здесь посчитали.
Вот эти итоговые значения не кашируются.
Кашируется только то, что бегин дает.
То есть здесь каждый раз мы заново будем
все-таки проходиться от бегина до энда
и проверять каждый элемент, делится
ли он на 2 или нет.
Это так можно?
Не знаю.
Наверное, не уверен.
Но кажется, это не УБ, ничего.
Это прям по стандарту так.
Он специфируется.
Он специфируется.
Еще раз.
Вот у нас
фор, второй,
будет вести к тому, что у нас фильтр
снова применится к УБ.
Да, вот эту функцию мы снова будем вызывать,
но не ко всем элементам,
а начиная с бегина, который закаширован.
То есть мы в первом цикле
найдем бегин, вот он, бегин,
и закашируем его.
Во втором цикле мы уже с этого бегина
будем дальше идти.
То есть если мы вот здесь бы
поменяли не нулевой элемент, а
второй, например,
тоже на 5, то он бы
появился.
Почему так важно все-таки иметь бегин
за амортизированного?
Расчехляя архивы,
читая эти мега срачи
на тысячи и тысячи страниц, про то,
почему он все-таки должен быть
за вот единицы.
Амортизируете, что бегин совсем так работает?
Нет, он так работает.
То есть мы в первом...
У нас не будет, что мы за 10...
Ну, если мы поделим на 10,
то у нас не будет, что мы за 1.
Потому что мы на первом шаге могли там
все обойти и...
От единицы
приближается тремя, шесть, воскресенье,
секретов, количество вызовов, пятенок.
В вопрос фильтров, например, мы
фильтруем... Фильтры, я вам представлю,
витер X равно
равно 5. И запускаю
там массив, где у нас только одна пятенка.
Фильтр работает
не за от единицы, в принципе,
и итерация.
Амортизировано.
А если можно было менять...
А, когда ты...
Например, я встречу генератор, который
вместит 2 в степь ИИ,
ставит пятенку в остальных лодках.
Я ставлю фильтр X равно равно 5,
и вот он выдает...
Так, инкримент никто не требует,
чтобы работал у итератора за от единицы.
Но амортизировано...
Не, амортизировано то, что мне единицы требуют за у итератора.
Да, да, да.
Или нет?
Сейчас, кстати.
Я не помню, чтобы в презентации
было что-то про
амортизиру... про там
от единицы на инкримент. Инкримент сколько угодно
может работать.
И менять
контейнер и
опять вызывать. Если мы будем менять,
пробавиваешься,
так он будет ограничиваться. Каждый раз он будет
двигаться на сколько-нибудь, слушай.
Нет, он...
Что? Я не понял,
что ты хочешь сделать.
Бегин, вым, ломать...
Нет, бегин...
Это элемент, который указал, бегин, вым,
заменяем на что-то плохое, бегин дальше,
ищи, находим, потом сразу заменяем.
Нет, кэш не обновляется
после первого вычисления, насколько я помню.
То есть, ну, короче...
Да, кэш один раз считается
и больше не обновляется.
А вот если мы в этом примере
сделаем не
vv от 0 равно 5,
а vv от 1 равно 2,
То оно заново пересчитает
и не выведет первый элемент,
но кэш не обновится.
Если оно будет неправо,
то есть, если он уходит в кредитат,
и раздует...
Еще раз, кэшируется то, откуда
поиск начинается,
с какого элемента мы начинаем поиск.
А дальше мы каждый раз, при каждом вызове,
заново ходим от этого элемента
и дальше, проверяя, делится или нет.
Насколько я помню, это работает так.
Может, потому что мы заново перепроверяем,
а если не перепроверяем, то...
Не знаю.
Проверьте это, пожалуйста, сами.
Нам надо дальше ехать,
у нас еще столько вообще взрывного
с времени-то уже...
Все, давайте меньше
вещей, которые вы можете сами проверить
за 5 минут, потому что я их
многие не знаю
или не помню наизусть.
Take view. Зачем я вам
показываю?
View interface, view...
Да, у нас там был вопросик,
который мы все хотели утрести.
Откуда там какой-то ref view берется?
Вот вообще, что take view оборачивает?
Внезапно view.
Как тогда в take view можно запихать
вектор? Ну никак нельзя.
Вектор нельзя запихать в take view. Нужна
некоторая обертка промежуточная.
Да, тут
принимаются нернжи.
Но когда мы так пишем,
появляется обертка
волшебная, из воздуха.
Откуда же она появляется?
Если посмотреть на
дедакшн гайд для take view,
а здесь же мы это, на самом деле
дедакшн гайдом пользуемся.
То есть у нас вывод аргументов
шаблона типа
из типов аргументов конструктора.
Мы такое уже видели, умеем,
вот оно, дедакшн гайд.
Итак, если нам дали range
и какое-то число,
сколько брать,
мы должны выбрать своим аргументом
шаблоном views all t
от этого ренджа.
All t
это некоторое...
Сейчас, куда?
Да,
ничего.
Давай еще раз.
Написали такой код.
Take view.
Пихаем туда векторы 3. Первые 3 элемента
берем.
Смотрим тип
вот этого 3,
которая тут будет. Он вот такой.
Другой
странно было ожидать, потому что
в сигнатуре в классе take view
уже написано, что range
нельзя запихать, только view.
И вот мы когда просто вызвали take view,
его конструктор,
мы получили,
что там промежуточный ref view какой-то
обертка. Откуда она возникла?
На самом деле
take view is дедакшн гайд,
который говорит, что в случае, если тебя
от ренджа, используй
в качестве своего типа поля
вот какой-то all t.
Его инициализируют от этого самого ренджа.
Что такое all t?
Пока попридержим коней,
но к вам вопрос.
Будет ли то же самое, если мы вот так
напишем?
Кажется, это будет очень плохая вещь,
когда у нас создастся временный объект
и он же сломается
сразу же.
Ну, ты не прав. Разработчики
стандарта нас
разработчики стандарта нас позаботились.
Если бы вот такой код мгновенно
вёл к
протухшей ссылке,
что мол вот временный объект разрушился и всё
пропало, то это было бы
как-то мега тупо.
Наверное, тогда бы просто запретили
от airvalue вызывать конструктор take view.
Ну или вот если бы мы
так писали, то как бы это вот
тоже запретили и вообще зачем
это так делать? Но нет,
это делать можно.
И будет даже разумный результат.
Сейчас мы увидим, какой.
Вот этот самый alt-t, вот мы о чём
сказали,
take view будет смотреть в alt-t, какой
на самом деле тип view в качестве обёртки
использовать.
А вот этот вот alt-t,
он на вход берёт что-то
концепта viewable range.
То есть был range, был view, теперь viewable range.
Это третий концепт, совсем другой,
не путайте.
И с помощью какой-то дополнительной
функции all, как-то
понимает, какую
обёртку использовать над нашим
range. Ну там был
refview, по-моему, у нас, то есть
как-то тут что-то определяется.
А вот эта функция all, которая
тут использована, она следующим образом
определена, что если
е без всяких там ссылок
и констов view,
то и оставляем view.
А если
refview от е
корректно,
то его используем, а иначе subrange
е. Вот refview
это то, что у нас там выбралось,
когда мы вектор вкинули просто.
Да?
Вот оно.
То есть, видимо, refview для
вектора работает, поэтому оно использовано.
Но в каких-то случаях refview
видимо не работает и используется
subrange. То есть вот эта вот
функция all, она как раз используется,
чтобы выбрать обертку.
А
перед тем, как понять, что такое refview,
мы накидали еще один концепт.
Был range, view,
там где-то промелькнуло вот этот вот
viewable range, но даже перед тем,
как про него говорить, нам нужно ввести
понятие borrowed range.
Так я вижу здесь пройски
языка хорошей. Да, пройски
крабов, проклятые крабы пробрались
в наши ряды. Borrowed range
это range
как
раст,
крабы.
Borrowed range это range,
который является еще при этом
lvalue ссылкой.
То есть lvalue ссылка
на range это borrowed range.
Всегда.
То есть когда мы там вектор пихали
в фильтр, это был range, это
было lvalue. Значит это lvalue ссылка.
Значит это был
borrowed range.
А еще
можно явно сказать enabled borrowed
range руками
для любого range
и включить этот концепт.
Наверное он все-таки семантический,
раз тут такой бред написан, что вообще ни черта
не понятно, что хотел сказать автор.
И действительно он полностью семантический.
Вот.
Ну как вам перевести
со стандартного на русский то?
Короче borrowed range это такая штука,
у которой можно взять итераторы,
итераторы взяли, сохранили,
а сам range выкинули, удалили.
И итераторы все еще будут
валидные.
Логично.
Я правильно понял, что borrowed range это нет?
Нет, конечно.
Borrowed range это штука,
у которой можно взять итераторы, штуку
выкинуть, итераторы останутся
валидными. Да?
Вот это не всегда верно.
Констекс про рей?
Нет.
Если у тебя объект удален,
то итераторы перестают быть валидными.
Вообще говоря. Да?
Зачем на самом деле этот концепт нужен?
Тут есть заметка прекрасная.
Смысл в том, что вы в функцию хотите
пихнуть range, а из функции
вернуть итераторы в этот range.
Где мы такое видели?
Где в функцию пихали range и наружу
вытаскивали какие-то итераторы?
Пара...
Пара две назад было.
Что?
Any? Нет, раньше.
А про что мы вообще тогда говорили?
Когда спылили что-то
про ranges, там копий был.
Помните?
Зачем мы про копий говорили?
Что ты...
Ну, значит, три.
А, про неблоиды.
Про неблоиды, когда мы говорили, вот.
Про неблоиды и CPO, когда говорили,
там был копия.
Копия новая из ranges, что возвращал?
Он возвращал какие-то итераторы внутрь контейнера.
А теперь задумайтесь,
что если мы внутрь копия
что-то?
Вдруг у нас move only range,
который нельзя копировать,
можно только мувать или там вот...
Ну, и мы мувнули почему-то его в копии.
Он вам наружу может вернуть
итераторы?
Ну, нет. Вообще-то это небезопасно.
Могло удалиться то,
что он внутри и сохранился в копии,
потом удалился и все.
Итераторы вы на мусор вернете.
A borrowed range — это такой range, который можно
мувнуть прямо внутри функции,
вернуть наружу итераторы на него,
и это будет работать.
Конкретный пример,
где это делается, увидим чуть позже.
Но пока что вот есть такой
borrowed range.
Viewable range — это range,
который при этом либо borrowed,
либо является view после
удаления референсов.
Вот.
И вот этот вот alt,
который используется для выбора,
он в любом адаптере,
на самом деле, когда вы в него
запихиваете range или вообще что угодно
запихиваете, от того, что вы запихиваете,
требуется viewable range.
То есть либо это view,
либо borrowed range.
В
адаптеры
можно пихать, помимо других
вьюх, только borrowed range.
А в borrowed range было сказано, что это range,
который
вот эта вот опция
интересна,
range, который
lvalue-reference.
То есть пока все сходится с тем,
что мы вектор пихаем, и оно работает.
Но саму lvalue-reference
ты можешь выкинуть, это же ссылка,
а не сам объект. Вот ее выкидываешь и
пока не понятно, почему не умирает
объект.
Да, lvalue ссылку выкинул, а сам объект
он где-то в другом месте живет, в этом
задумка.
А
мувнули его внутрь,
вьюхе в смысле?
Сейчас до этого дойдем.
Refview, вот
та обертка, которая у нас
используется, когда мы по lvalue-вектор
передаем.
Ну, это такая замысловатая обертка.
Тут вот говорят,
что она оборачивает какой-то range r,
она у себя его там как поле посылки
хранит.
Что?
Из object...
А, что это не указатель
на функцию или что-нибудь такое,
короче, нормальный класс.
Требует, чтобы то, чего мы конструируем,
было там, ну, convertible-to, это вот какие-то
уже такие костыли невнятные.
Короче, это lvalue-ранжи.
Вот, любой lvalue-range
можно обернуть в lvalue-сылку
на range, можно обернуть в refview
и начать пихать в другие вьюхи, и, типа,
все предполагается будет нормально у вас, потому что
вы сами этот объект завели где-то,
ссылку взяли, с ней поработали,
потом выкинули ссылку, все окей.
А вот если у вас
rvalue-сылка на range,
rvalue-сылка на range,
это значит у вас какой-то промежуточный temporary
объект, который может удалиться,
у вас ссылка пропадет.
Вот, и нужно где-то это все продлить
жизни, как-то сохранить.
И тут
есть вот такая вот штука как subrange,
которая внутри себя
хранит просто пару итераторов.
Вот сюда надо смотреть.
То есть, она как бы конструируется
от пары итераторов. Пара итераторов
вам, например, equal-range из
multimap может вернуть.
Да, то есть, ну, как бы с equal-range
хочется, чтобы он вернул range, он вместо
этого пару итераторов возвращает. Ну, вот теперь
subrange еще умеет возвращать,
по-моему. Либо вам самим
надо упаковывать, не важно.
Вот, и
к чему я все это веду?
Теперь нам понятно
эта функция, что
когда мы хотим превратить range во Vue,
чтобы ее куда-то дальше пихнуть,
надо думать, что это за range.
Если этот range уже является Vue,
то, ну, без разницы, просто ее и кидаем.
Если это lvalue-ссылка
на другой range,
то мы используем rev-vue.
Или там, если это...
Сейчас.
Да.
А вот если это
какой-нибудь borrow-range, то мы
subrange внезапно используем.
Вот.
Subrange не shert-ссылка.
Сейчас конкретный пример чуть попозже будет.
Блин, мы так не успеваем. Такая
беда.
Вопрос такой, когда вот это вот
стригерится на самом деле.
То есть я только что наговорил кучу всякой хитрости,
которая сейчас, наверное, вообще не понятна,
потому что я и сам себя немного запутал.
Но вопрос такой, когда
будет все-таки subrange выбран, а не rev-vue.
Вот утверждается, что
в каких-то супер-идиотских случаях,
например, когда у вас есть
shert-вектор, который внутри
себя хранит shert-поинтер
на массив.
И он как бы ни рыбы, ни мяса.
И, наверное, для него borrow-range
имеет смысл включить.
Потому что
удалили вы один из shert-векторов,
но другой-то где-то живет, и все будет
нормально.
Вот почему-то у меня нету слайда про это.
И меня это крайне бесит.
Меня тоже этот вопрос стал интересовать.
На owning-vue все понятно в целом.
Он уже живет, вот этого товарища.
Не, на subrange может быть по-русски.
Subrange, кажется, нет.
Кажется, он все-таки...
А, хорошо.
Тут что-то поизменилось
с 23-ми или 26-ми плюсами.
Возможно, нам стоит это
на следующий раз отложить.
Где она живет?
Как она живет?
Кто?
Когда мы муваем v-vector
в vue, там, кажется,
owning-vue вот этот используется,
до которого тут мы не дошли.
И, видимо, не дойдем.
Давайте быстро по алгоритмам пробежимся.
Их буквально два тут будет рассказано.
А про owning-vue
я, видимо, в следующий раз расскажу,
потому что уже убойная, у нас там, скорее всего,
минус 5 минут осталось.
Алгоритмы.
Раньше были в алгоритме алгоритмы, был
std сам алгоритм с begin-end
и аргументами. Теперь вместо этого
есть в ренджах сам алгоритм.
std range сам алгоритм,
и вместо begin-end просто range.
В целом все. Сигнатуры некоторые
поменялись, и некоторые алгоритмы проапгрейдились.
Про апгрейд копии мы уже с вами
говорили долго и тщательно.
Другой важный класс
апгрейдов, которые очень полезны,
очень классные, относятся
ко всяким структуркам, которые там ключ
значения.
ID и value. Вот мы такой вектор сделали,
как вектор map.
Вектор, пар, ключ значения.
Хотим отсортировать по ключу.
Теперь можно писать вот так.
Вот это компаратор.
А вот это что?
Справа от компаратора.
Проекция. Да.
Теперь можно тупо брать и делать проекцию.
Это может быть функция какая-то, которая принимает
на вход элементы, возвращается что угодно.
Ну, как в питоне.
А можно просто указатель на
мембр.
Чего?
Нет, никакого каста и KSTD
функшн, все статическое.
For rich вывели,
отсортировалось.
По value отсортировалось.
Потом еще раз по ID-шнику посортируем.
Вывели, все по ID-шнику отсортировано.
Если на слайдах не отсортировано,
игнорируйте.
По-моему нормально.
Так вот.
Sort.
Берет компаратор, берет проекцию.
Ну, тут что-то random access range.
OK. Sortable.
Какой-то убойный концепт.
Да.
Итератор T, мы помним, что он возвращает
итератор для ренджа.
Sortable.
Требует, чтобы можно было переставлять
местами то, что лежит в итераторе
и чтобы было
indirect strict quick
order. Что вы думаете
про indirect strict quick order?
Нет.
Нет indirect, потому что
через разыменование итератора.
Ну,
да.
А strict, почему?
Почему weak? Как может быть strict,
но weak?
Строго меньше, но при этом
свойство Erwin. Да,
строго меньше, но при этом без equality preservation.
Но сейчас про permutable. Тут просто опять
indirectly что-то можно делать.
Можно indirectly swap-ать местами
и можно indirectly movable
storable какой-то, ну вот еще там
forward iterator, это неважно.
Movable storable это лютая жесть.
Туда...
Все больше напоминает
еще племян копий sometimes
в одну фазу.
Так и есть. Это все не шутки, блин.
Вот эта штука,
короче, означает, что вы можете как бы
прочитать, записать во временную
переменную, а потом эту временную
переменную обратно в другое место
записать. Вот такой концепт.
Почему он именно такой?
Я не знаю.
Но проигнорируем его. Indirect strict
recorder, ну вот как уже правильно сказали,
это
после разоминования итератора
те элементы, которые мы
получим, имеют строгий порядок
на себе, которые поменьше,
но при этом equality preservation
не гарантируется. А тут какой-то класс
внутрь пихается, projected от
итератора и p. Ну вот это класс
обертка, который делает псевдо
итератор, который
ну скорее indirectly readable
только, а даже не итератор.
И вот он как бы оборачивает итератор
и превращает его в новый
итератор, где
применена проекция. То есть вот как бы
итератор и он возвращал
какой-то тип T,
а вот эта вот
обертка projected будет вместо T
возвращать indirect
result T, ну то есть
применение проекции к T.
Indirect result T то же самое, что
result T, только indirect.
То есть мы сначала разоминовываем
итератор и то
значение, тот тип, который он нам вернул
впихаем в проекцию.
Ну и вот так вот он как-то выглядит
invoke result
от там применения
вот этой функции к
iterreference T от
аргументов, ну
итераторов нескольких.
Вот.
И тут кое-где
да, кое-где
где-то в глубинах стандартах
инвука есть вот такая смешная
строчка, что он умеет работать
с указателями
на мембера теперь.
Вот внезапно STD инвук
научился использовать...
Всегда думаете?
Окей.
Окей.
Но, по-моему, все-таки
не всегда, где-то давно
а может в нашей
ESTL библиотеке просто плохо
STD инвук реализован.
Вот он умеет брать указатель на мембер
и применять его к
ну то есть как бы берет указатель на мембер
берет указатель на this
применяет, получаем указатель на
или там ссылку на поле.
Ура.
Да, напоминаем.
Теперь вот последний алгоритм осталось посмотреть
мы расходимся, который
ну такой прототипный пример
мучения с BORUT range.
Итак, вот мораль какая была раньше.
BORUT range является
BORUT range, тогда и только тогда,
когда можно оставить его итераторы
даже когда сам range выкинули, удалили.
Да?
Представляю
вашему вниманию, что
unique. Вот название
здесь, что этой гадости.
Это алгоритм
unique. Ну что он делает?
Ему дают какую-то сравнивалку
и она как бы выкидывает
повторения, да, подряд идущие.
Да, да, да.
Но даем ему range, который forward range.
Даем ему проекцию.
И даем ему лютую вещь.
Вот этот синтаксис распарсить,
это просто застрелится. Я вчера вечером
сидел минут пять.
Ну то есть
вот все
вот это вот, да, вот буквы
C это концепт
indirect equivalence relation, то есть
что после разыминования итератора,
а также после проекции
можно сравнить на равенство
при помощи
C, да,
потому что весь этот концепт он применен
к вот этому шаблонному аркументу.
Да, а значение
по умолчанию просто оператор равенства
используется. Жуткая
вещь.
Что нас тут интересует?
Возвращает эта шняга BORUT subrange
внезапно.
Это конкретный тип.
Который, ну вот здесь универсальная
ссылка на любой range, да.
И мы
по этой универсальной ссылке как-то понимаем,
что нам надо возвращать из уника.
Ну и тут делается как бы ровно
то, что я говорил.
Мы смотрим, вот этот range, который
нам пришел, он является BORUT
range. Если да, то мы будем
возвращать subrange.
Пару итераторов.
То есть уник, он
после своей работы вернет пару итераторов
на начало и конец того, где
валидные элементы. То есть вот мы сказали,
что он там подряд идущие элементы выкидывает.
Но он их не выкидывает, он их в конец
передвигает, да.
То есть чтобы их
еще и выкинуть, нужно после уника
запустить arrays. Вы
сталкивались такой, где-то должны были
сталкиваться с такой идиомой, да, что
find arrays вот это все.
Нет, смотри, у тебя есть группы
подряд идущих элементов, равных друг другу.
Ну group by по сути.
И вот ты их вот вместе сплющиваешь,
выкидываешь все равные
кроме первого.
Он не возвращает их, он
прямо модифицирует R.
А возвращает наружу
subrange. Но возвращает наружу
subrange, только если R изначально
был BORUT range.
То есть вспоминаем, что
lvalue ссылка на любой range
это BORUT range.
То есть мы можем
спокойно lvalue ссылку сюда
запихнуть, и оно отработает и вернет
нам пару итераторов. А вот если мы
туда мувнем range
внутрь уника,
то это тоже может отработать.
Но lvalue ссылка на range она даже
BORUT range не будет, потому что
это temporary, как только мы ссылку дропнем,
объект тоже удалится.
Поэтому тут с помощью conditional
t выбирают, что если у нас не
BORUT range, мы выберем
RNG-данглинг.
А это просто пустая
структура.
То есть алгоритм unique
в зависимости от того, далее ли вы ему
BORUT range или нет, даст вам
либо пару итераторов наружу,
либо пустую структуру.
То есть если у вас есть этот
мифический вектор, внутри которого
лежит shared
pointer на сишный массив,
и вы мувнули
внутри этого алгоритма
такой shared
вектор, мувнули его внутрь,
чтобы лишний раз refcounter не
уменьшать для копирования,
вот тогда
вы должны явно пойти
и пометить, что это у вас BORUT
range, и поэтому
ты алгоритм unique, std unique,
не пугайся, что в тебя мувнули
это rvalue-референс.
Так и задумано, пусть он умирает,
после этого контейнер не исчезнет,
верни мне все равно, пожалуйста,
пару итераторов.
Он скомпилируется, он скомпилируется и выдаст
ничего.
Возвращаемый тип ничего, он скомпилируется,
но итераторов вам не вернет.
Что за страшное такое поведение?
Почему там не выгибается ошибка?
Потому что вдруг ты так и хотел, чтобы
тебе контейнер поменяли,
там какие-то свопы
делали.
А он делает свопы, даже если
не он внули?
Кажется, что да.
Алгоритм отрабатывает, но вернуть он ничего он не может.
И вот как бы
вот главное,
зачем вся эта машинерия жуткая.
И вот собственно
да, если сюда пришло lvalue, то
автоматом вернется пара, если нет, то
фигня вернется.
Окей,
и того,
кто является вообще бару дранжами
внезапно. Любая lvalue ссылка
на контейнер,
refview сам является бару дранжом,
потому что это view, ну и в принципе любой
view, даже string view или empty
view и так далее.
Но
тут есть вот это
примечание,
что на самом деле
есть вьюхи,
которые как фильтр view,
они в себе что-то кашируют.
И вот вы взяли
бигину какой-то другой вьюхи,
она как бы могла случайно
вернуть ссылку на какой-то кэш
внутри. И вот в этом случае
все может сломаться, поэтому там
далеко не во всех ренджах
стандартной библиотеки
проставлено, что они бару дранж.
Но вот эти вот как бы точно.
Ну тут
странно. И в 23 плюсах еще
что-то меняют, до сих пор
у меня актуальной информации нету,
предлагаю вам самостоятельно, и сюда
уже и не влезает эту презентацию.
Вот, if the argument
is inner value, то
ill-formed.
Да.
Зачем это сюда вставлено?
Я забыл.
Если enabled borrow range
не помечено, вот так вот.
То есть outer value
брать begin можно только если у вас enabled
borrow range.
А на кого цвет пойдет
бурл дранж?
Ну да, и там вот для этого
овнинг вью автоматом
подпихивает. По-моему
да, тут все в очень
странном положении застряло,
потому что я еще не играл с 23 плюсами,
и вот да.
Когда мы сказали, что
будет утечка памяти,
это было правдой.
Там будет ссылка, продуша.
По-моему нет, оно потом
почистится все. Нет, тут точно нигде
протекающих ссылок нет, все нормально.
Окей.
Да, тут важное замечание,
что вот это все верно для ranges
begin, а std begin и std end
всю эту технологию не учитывают
и забивают на нее. Поэтому
если вы хотите писать
современный к алгоритмический код
с рейнджами, не используйте std begin.
Все, последний слайд.
В 23 плюсах добавили еще
кучу прикольных вьюх, которые вот раньше
не были упомянуты. Например, zip, суперважное.
В питоне zip видели, все хотят
zip, но он только в 23. Group by
наш любимый, даже декартовое
произведение внезапно. И главное
это вот ranges to, на который я даже все-таки
вставил пример, потому что это супер круто.
Иногда вы сделали
огромное вью и хотите это вью
все-таки в памяти где-то сохранить.
Взять, посчитать и сохранить.
Раньше это было сделать неудобно,
непонятно, как это сделать эффективно,
ну и много букв.
Теперь есть ranges to,
std vector и vector будет вектором.
Только с 23? С 23.
То есть получается
он вычитает все? Да, да, да.
To прям схлопнет всю эту ленивость
и прям вычислит и прям вектор
положит. Я считаю, что
нужно до конца, если зараза перетягивать,
нужно type deduction нормально
поставить. Не будет.
Нет, ну не будет.
Короче, в to вот здесь указываем
куда. А еще
заметьте, что в to можно кажется
указать и шаблон и конкретную
специализацию. То есть там указан
лист даблов, а здесь просто вектор.
Вот здесь оно догадается, что изначально int
были, значит и вектор int будет.
А вот там мы как бы насильно
вектор даблов хотим, и оно скастит.
Вначале он смотрит
на самые последние цепочки,
потому что можно transform, который
да, да, да, да, да. Ну то есть оно по цепочке
проходит и понимает, какой type будет.
Все. На этом
итог надо подвести. У нас вначале
был вопрос, какова цена
того, чтобы вот это все привнести.
Так вот, в Java у нас
был simple bin factory aware aspect
instance factory.
Знакомо, да?
Теперь мы тоже клоуны. У нас
directly regular
and re-invocable.
Так что мы
больше не можем шутить над джавистами.
По количеству символов
уже все плохо. Видишь там
только слово factory дописать не хватает.
Мы еще тут resolution
arrangement написали.
Кого они написали?
Ну как какой?
Стой, да.
Тут должен быть...
А нет, это не для...
Это VSTD.
Ну, в общем,
на этой веселой ноте мы наконец-то
заканчиваем. Мы задержались
на 15 минут. Черт.
