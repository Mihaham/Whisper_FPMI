У нас, так или иначе, все это зацеплено на теорию множеств, и в теории множеств есть три понятия.
Их три штуки. Это элемент
множество
и одна
Тогда в теории формальных языков мы начинаем с того, что потеряем просто что такое язык. Мы говорим, что язык
не язык. Начинаем с алфавита
fit- произвольное множество
Тогда мы называем элемент алфавита символами
Хорошо
Так, алфавит символы
Дальше мы вводим операции
Нам нужна операция конкатонации
Слов
Где слова
Это последовательности
И символов алфавита
Хороший вопрос будет в том, что такое последовательности
Последовательности это
по сути отображение из N некоторое множество X
Dix мы сами выбираем
То есть слова, по сути, будут являться отображениями из N в какой-то алфавит
Алфавит, как правило, обозначается за главную букву sigma
Так вот, что такое конкатонация слов?
У нас есть слово
Слово A это sigma 1, так далее sigma N
Есть слово B это tau 1, tau N
Как правило, мы будем работать с конечными последовательностями
Даже не как правило, всегда будем работать с конечными последовательностями
Поэтому слова мы можем количествоить не просто последовательности, а конечными
Тогда это не из N sigma, а из какого-то конечного
Конечно, от множества N такого префикса
Чуть позже поговорим про что такое префикс
Тогда мы называем A конкатонация B следующую строку
sigma 1 sigma N tau 1 tau N
Хорошо
После этого мы можем взять, вести понятие языка
Зелененько уже написано
Язык
Множество слов
Это первое определение, по сути, которое мы можем дать
У нас есть какой-то алфавит, на нем есть слова
Слова это какие-то конечные последовательности из префикса N в sigma
И, соответственно, если мы их как-то насыпем, мы получим множество их языков
Это первый вариант
Второй вариант будет использовать под собой понятие конкатонации
У нас есть конкатонация двух слов
Дальше мы можем обобщить понятие конкатонации на языки
Изыки обычно обозначаются заглавными латинскими, слова строчными латинскими, символы строчные греческие
Афавит, как я сказал, заглавный греческий, как правило, это sigma, gamma, pi
Потом, когда мы с этим встретимся, вторым семейством отловим
Итого, у нас есть два языка, язык L и язык M, и мы хотим их конкатонировать
Что значит конкатонация языков L и N?
Это есть множество всех слов, давайте сделаем так, всех слов L на слова M, где L принадлежит L и M принадлежит N
Как-то так
Тогда мы можем что сделать?
Мы можем начать конкатонировать, например, язык с самим собой
L, так далее, мы конкатонируем с собой K раз
Такую вещь мы будем называть KT степенью языка
Хорошо
Подобные языка мы можем конкатонировать N раз само собой
Это уже слово обозначается точно так же, но только мы понимаем, что это строка из A
Также у нас будет некоторая двойственность в том, что есть символ, а что есть слово
Потому что сам по себе символ подпадает под определение слова, конечная последовательность
Это последовательность, по сути, что отображение из нуля в сам этот символ
Благодаря этому мы можем писать здесь даже символы, но при этом все будет работать
Аналогично с конкатонацией языков мы можем таким образом конкатонировать, например, афавиты
Потому что в чем проблема?
Символы это тоже строки, слова, а множество слов это языки, получается правильно
Двойственность
Хорошо
Теперь что мы вводим? Мы вводим звезда к линии и плюс к линии
Звезда к линии
Вводим мы ее вообще на языках
Вот у нас язык R, звезда к линии
Это есть объединение по всем степеням от iota равного нуля до плюс бесконечности
К такому значку привыкли, уже понимаете, или нужно объяснить, что это?
Можете объяснить еще?
Ничего не слышу
Отзовите кто-нибудь, пожалуйста
Ничего не слышу
Проясните, пожалуйста
Значит, Дима, я не слышу
Алло, можете сказать еще раз?
А можете что-нибудь сказать, пожалуйста?
Просит объяснить поподробнее
Сейчас, давайте тогда я вернусь к компьютеру, потому что, видимо, технические шоколадки
Да
Да, спасибо
Звезда к линии объяснить поподробнее или что?
Да, можете, пожалуйста
Все супер
Так, пожалуйста
Мы пофиксили такие
В общем, у нас...
В общем, с такими знаками Sumo в школе работали?
Или еще нет?
Было что-нибудь такое в школе?
Да, было
Супер
В общем, у нас с такими знаками Sumo в школе работали?
Или еще нет?
К равно в нуля, по n, какой-нибудь x-кат
Было что-нибудь такое в школе?
Вот у нас есть здесь, что это, по сути, означает
Что мы берем k равный нулю, подставляем здесь какое-то выражение, завищееся от k
И суммируем все такие вот выражения, где k равняется нулю, так далее, k равняется n
Здесь же, что мы делаем?
Здесь у нас вместо Sumo выступает операция объединения на множествах
Но только теперь у нас есть множество, завищещее от yod переменной
Мы берем по всем yod, которые от нуля до бесконечности, то есть все натуральные числа
Если расписать, то эта штучка будет равняться l в нулевой, plus l в первой, plus l во второй, plus и так далее
Все возможные натуральные числа пробежали
Да, очень важное напоминание, что натуральные числа, они с нуля и до бесконечности
Не соединятся, почему-то так, узнаем во втором семестре
Извините, а получается, что plus это как объединение работает в данном случае?
Плюс? Да, спасибо, хорошее замечание
Да, это объединение
Хорошо, это называется зисторик линии
У нас есть, по аналогии зисторика линии есть, плюс к линии
Только теперь мы начинаем конконтонировать не от нулевой степени языка, а от первой
Здесь уже будет l1, так далее, l2, так далее
То есть, можно сказать, что l звезда, это есть l plus, plus l степени нулевой
А теперь давайте посмотрим, что такое l степени нулевой
У нас...
Блин, вы ординалов еще не знаете, трудно
Ну давайте думать вообще
У нас на числах есть свойство, что число k в степени 0, это равняется единице
Математика хороша тем, что то, что работает в одном, это, вероятно, какой-то частный случай абстракции, который работает везде
Вот здесь у нас нулевая степень, и поэтому наша задача понять, что такое 0 во множествах, и что такое единица
В данном случае у нас множество это языки
Вот есть предположение, что будет нулем
Пустое множество
Да, вот 0 у нас во множествах, это пустое множество
Что же такое единица?
Понятно же, что пустое множество быть само собой единицей не может
Это должно быть что-то, что содержит хотя бы какой-то элемент
Какой же элемент мы можем дать настолько глупый, что это будет просто единица?
А единица, да?
Пустая строка, эпсилон
Да
Вот, и мы получили единицу
И действительно, если мы посмотрим, то здесь будет выполнено свойство, что
r в степени m умножить на r в степени n равняется r в степени n плюс n
Существо для языков
Нулевая степень не должна поменять ничего
А единственный способ, конкатенируя строки между собой, не изменить
Это конкатенироваться с пустой строкой, то есть с эпсилоном
Тогда вот эта вот штучка запишется в r плюс объединить с языком единицей
Второй же вариант, это мы определили звезду к линии через плюс к линии
Второй вариант определить плюс к линии через звезду к линии
Есть идея, как это сделать?
Ну, для этого давайте посмотрим
Домножить на l
То есть здесь у нас что?
Если мы домножим на l, то мы увеличим степень на единицу во всем вот этом вот
разном объединении
Тогда у нас начнется не с нуля объединяться, а с единицы
Это равно то, что нам нужно
Это l конкатенация на l звезда, то же самое, что l звезда на l
Пока кажется, что, ну, это очень глупо записывается с двух сторон
Но чуть позже на линейной алгебре вам покажут, что
в зависимости от того, с какой стороны мы домножаем или складываем
в определенных случаях у нас абсолютно все ломается
Хорошо
У нас звезда к линии плюс к линии есть
А теперь мы приходим к второму определению того, что такое язык
И именно это будут использовать потом на курсе формальных языков
Я немножко формально запишу
Это некоторое множество l, которое является под множеством
Возможно совпадающим
Над итерацией к линии алфавитом
Даже часто уточнять язык над алфавитом
Алфавитом сигма
Ну, в целом, это у нас второе определение
В целом, понять эквивалентность этих
Ну, довольно непонятно
Просто что такое звезда к линии над алфавитом
Это мы берем всеми возможными способами контенируем между собой символы из алфавита
Так мы получим всевозможные слова из символов выбранного алфавита
Хорошо
Это объяснил, это объяснил, это объяснил, это объяснил
Давайте я гляну на, что у нас будет
Контрольная, все ли я казала, еще нужно что-то
Так, это осень первая
И теперь мы после того, как ввели какой-то алфавит
Мы начинаем рассматривать правильные исключенные последовательности
По сути, это уже язык
Но язык, на котором заданы определенные правила
Потому что говорить в общих чертах и языках довольно бессмысленно
Потому что это какая-то довольно-таки глупая структура
Ну, просто мы набрали множество каких-то элементов
Потому что глобально у нас язык может совпадать с алфавитом, алфавит — это произвольное множество
То есть все, что угодно, мы можем назвать языком
И чтобы хоть как-то было это применимо, мы должны задать ограничения
Задать какие-то правила, как можно стола строить, как со столами оперировать
И для этого мы рассмотрим язык правильных исключенных последовательств
Так, язык ПСП
Давайте сначала разберемся, что такое алфавит в правильных исключенных последовательствах
Есть предположения?
Открытый язык, видеоскопка
Все
Открытый язык, видеоскопка
Все, все очень просто, да, две круглые скопки
Так, у нас есть две скопки
Соответственно, мы можем сказать, что это некоторое под множество уже
Вот это вот симма звезды
Первый вопрос, на который очень легко ответить
Совпадает ли это с самой интерацией к линии?
Конечно же нет, потому что здесь, например, получится вот такая строка, которая не будет правильной
Соответственно, как нам определять правильность?
Для этого мы вводим правила, как их строить
У нас их есть целых три
Первое правило, как мы можем задать правильность к обычной последовательности
Эпсилон, правильность к обычной последовательности
Дальше, Фи, Пси, ПСП
Тогда, Фи конкретонация, Пси, ПСП
Фи конкретонация, Пси, ПСП
Фи, ПСП
Тогда, скобочки над Фи тоже ПСП
Все
Данное определение
Хорошо, с точки зрения того, что мы точно задали
Хорошие скобочные последовательности, которые ничего не нарушат
Но у них есть существенный недостаток
Вот скобочная последовательность, вот такая вот
Идейно нам нужен язык правильных скобочных последовательностей
Чтобы позже всунуть в скобки какие-то операции математические
Чтобы мы могли правильно выполнять их
Вот представим, что внутри скобок лежат какие-то математические операции
Здесь вот стоят их две
Какую скобку нам выполнить первой?
Данное определение, оно не дает никаких формализаций
Никаких формализаций по данному вопросу
Поэтому мы можем как сначала левую скобку выполнить, потом правую
А можем выполнить сначала правую, а потом левую
Но понятно же, что может случиться так, что нам нужно выполнять именно каким-то одним определенным образом
Ну, например, здесь у нас будет, давайте что-нибудь параллельное, здесь будет что-то вида
Ретерн 2, а здесь будет
Ретерн 2 делить на нот
Ну вот, если мы сначала упадем правую, мы упадем с ошибкой
Выполним левую, все успешно выполнится
И чтобы задать хоть как-то этот порядок
Лучше использовать два других определения
Есть, безусловно, база, это Эпсилон
Является правильной скобочной последовательностью
Дальше, ФИ
ФИ и ПСИ, ПСП
Тогда конконтонация ФИ
Скобках на ПСИ-ПСП
Это второе
Третье это Епсилон ПСП
ФИ и ПСИ ПСП
Тогда ФИ
В скобках ПСИ тоже ПСП
Тогда два данных определения дадут нам гарантируемость того, что порядок будет исполняться именно четким фиксированным образом
Второе даст нам то, что называется математики, левоассоциативностью
То есть мы сначала будем слева выполнять операция, потом справа
Ну это практически все стандартные математические операции, когда мы пишем
А, плюс Б, плюс С
Когда все такое написано в компьютере, мы начинаем сначала выполнять первое, потом второе, к результату третье и так далее и тому подобное
А есть правоассоциативные, это тройка
То, что сначала исполнится справа
Вот, например, во втором случае мы успешно завершимся, в третьем случае мы упадем с ошибкой
Примером правоассоциативной операции будет что?
А равняется, Б равняется С
То есть у нас есть какая-то переменная С, ее результат сначала присвоится Б
Потом данная операция вернет то, что было присвоено Б, и это присвоится А
Также, наверное, в школе была такая штука как математическая индукция
Общий принцип математической индукции заключается в чем?
Что у нас есть некоторая база, есть и есть правила перехода от n-1 к
Математическая индукция хороша, но не всегда у нас правила перехода одно
То есть мат-индукция
У нас была база
Что-то там, какое-то свойство для нуля
И переход
От n к n плюс один, ну или n-1 к n, оно не имеет смысла
Здесь же в словах можно заметить, что у нас базы везде это епсилон
А вот количество переходов во втором и третьем определении оно одно, а в первом два
А иногда может быть еще больше количество переходов
И в таких случаях использовать просто мат-индукцию нельзя
Поэтому мы используем метод индукции, просто убирали слово математическое
И заключательное в том, что теперь мы переход проверяем не для одного, а для каждого из вариантов перехода
Выполнимость свойства
Тогда если для каждого перехода свойство будет выполнено, то мы доказали что-то
Ну, точнее, что свойство выполнено для всего множества
Вот здесь будет переход, переход, переход, переход
Подобные определения, заданные нами, называются еще индуктивными
Можно еще сказать, что так или иначе это как-то связано с понятием грамматики, но это будет через год
У нас есть PSP
И в конце, после того как мы начали говорить, что появился язык, правильные скобочные последовательности, мы их как-то задали
То теперь хочется их как-то проверять
Но проверять, что построим то, что называется дерево разбора
Говорим сейчас чуть позже про него
Но помимо дерева разбора мы уже косвенно столкнулись с проблемой неотозначенности разбора
Вот как я сказал, непонятно какой порядок выполнять
А это порядок
Но ведь может получиться так, что я задам правила перехода так, что
Давайте пример
Я возьму первое определение
И я добавлю еще одно правило
Давайте phi и psi
И возьму строку какую-нибудь
Ну пусть будет уже просто
Вот такую
Разбором, под разбором мы будем понимать последовательность переходов
То есть правил, по которым мы построили
Мы можем сказать, как из базовых приметилов мы получили конечный символ
Данную строку у нас есть не один вариант того, как не прийти
Первый это epsilon-epsilon
А здесь второй вариант это epsilon-epsilon
Вместе далее
Далее
Скопка epsilon-epsilon-epsilon
И понять, по какому именно пути мы попали мы не можем
Соответственно данный способ задания языка не гарантирует однозначности разбора
И третий номер будет именно на то, что вам заданный язык, в котором правила его построения приводят к неоднозначности разбора
Поговорим про дерево разбора
Как устроено дерево разбора?
Как любое дерево, у него есть какие-то листья
Это элементы...
Ладно, не получится вам так сказать
Просто есть листья
Это вершинки, от которых только идут ребра, к которым никакие ребра не пришли
Соответственно листьями дерева разбора могут быть только базовые элементы
В нашем случае это epsilon-epsilon, если мы говорим про PSP
Дальше мы можем соединять все вершины по правилам перехода, которые заданы в индуктивного потеряния
Мы можем взять и объединить две вершины по правилу конкатенации
Получим epsilon
Очень продуктивно, конечно
Дальше с epsilon мы можем получить две скобки, их вместе собрав мы можем сделать скобки скобки скобки и так далее
И вот это всё
И вот это всё
И вот это всё
И вот это всё
И вот это всё
И вот это всё
И вершины дерева получится исходная строка
Простите, вы что-то пишите сейчас, а этого не видно на экране
Или вы сейчас ничего не пишите?
Я сейчас ничего не пишу
А, простите, я не пишу
Да, ничего страшного
вот теперь давайте еще раз вот проверим кого-нибудь вопросы по теоретической части были
остались что-то непонятное разберем мы и переходим сразу к решению номеров
а пустая строка epsilon у нас содержится в алфавите пустая строка epsilon содержится ли в алфавите
смотри по определению что такое пустая строка это отображение из пустого множества в множество
символов алфавита и само по себе
сейчас скажу само по себе оно не может быть в алфавите если мы просто рассматриваем алфавит
но можно сделать как что у нас есть алфавит над этим алфавитом есть пустая строка и чисто
формально мы можем сказать что ну алфавит же это что произвольное множество мы можем
составить множество из вот таких вот пустых слов которые на самом деле они все будут различны
потому что это как бы пустой множество отображается другое но при этом в чем проблема возникнет что
на самом деле отображая пустое множество во что-то произвольное по смыслу у тебя ничего не
изменится если мы изменим множество в которое идет отображение ну у нас не будет никаких пар то есть
в пустом множестве нет никаких элементов соответственно мы ничему не сопоставим ничего ну какая
разница вот это вот ничего сопоставлять множество из русского алфавита из латинского из греческого
арабского ничего не изменится и поэтому пустую строку мы в алфавит никогда не заносим и считаем
что во всех языках вот это вот пустая строка она плюс минус одинаково спасибо большое
алфавит или язык может быть бесконечным да конечно мы смотри мы вводили понятие алфавита
как произвольное множество у нас это множество может быть не просто бесконечное оно может
сколько угодно и мощности оно может быть еще одном может быть континуальным может более чем
континуально какое угодно аналогично и если алфавит бесконечен то ну над ним
над ним язык будет может быть тоже бесконечным но при этом слова всегда конечны давайте считать
так ну потому что если действительно проводить прикол математики что мы идем по уровню абстракции
как можно вверх вот если мы на более практичном уровне мы говорим что слова конечны потому что
на практике ну нигде вы с бесконечными словами по сути работать не будете но можно спокойно
думать про слова как бесконечные это то что называется вот в программировании есть например
такой термин есть понятие константы есть эффективно константные переменные то есть
которые не помечено как константы но в коде они по сути выполняют роль констант точно также
можно смотреть на что на слова они могут быть бесконечные но только мы сопоставили что-то
только конечному префиксу последовательность из натуральных чисел дальше мы просто ничего не
сопоставили это будет использоваться до определения что это не отображение а частично определенная
функция но в целом можно построить язык из конечных слов но такое ну математические сыске
которые на практике не особо имеют смысл с неоднозначно разбираемыми с кубичного последовательства
можно сделать и так и конца полюсали что в третьем задании будет там что сделать с ними если у
вас задан язык таким образом что у вас не дается однозначности разбора то значит нужно
задавать язык другим образом это единственный способ это исправить а задачи у вас просто такой
ну плохой так плохо задан язык что вам нужно найти два варианта разбора я сейчас посмотрю
покажу как это делать все то есть там вас не будут просить а теперь сделайте как-нибудь чтобы
язык однозначно разбирался меня потемнело сейчас
но кстати на вопрос про того что слова конечны или бесконечны мы будем использовать
определение формальных языках вот такое sigma звезда и sigma звезда она даст нам именно
конечно всех этих строк и поэтому не появится просто могут быть ли слова бесконечно все здесь
sigma звезда наконкатинирует нам лишь конечное число раз еще можно вот вопрос нашего значка когда
мы обозначаем что одно множество является подножием другого а мы не можем когда он первое множество
совпадают использовать обычный значок без дополнительной черточки снизу ну когда множество
совпадают тогда мы хотим смотри по поводу этих значков в общем у нас есть значок у нас
и значок равенства или равняется м что значит или равняется им по определению это значит что
м под множество м и м под множество это что такое под множество что все элементы и есть м
как писать значок под множество есть есть различные варианты то как кто как кто предпочитает там в
школе скорее всего был значок просто такой это под множество дальше есть вариант писать вот такое
под множество я как правило пишу такой значок потому что я его использую именно для того чтобы
почеркнуть что эти множество могут совпадать то есть вот это вот равенство специально здесь
написано чтобы почеркнуть что возможно что вариант совпадения этих множеств тоже допускается а
когда вот специально мы хотим сказать что никогда не будет равенства вот есть перечеркнутая как я
помню на лекции должны были быть вот эти вот два значка но лично я буду использовать вот эти два
это уже знаете момент в кусовщины кто-то любит действительно почеркивать что равенство допускается и
равенство не отпускается
хорошо еще вопросы по теории
тогда давайте начнем решать вот
слова ассоциативность коммутативность уже режут слух еще режут слух и уже привыкли к ним
привыкли вроде можно задать вопрос про звезду к линии плюс к линии да получается они задают
ну вы бесконечный язык но язык бесконечный количество слов получается да понял понял ну да
так смотри как минимум это следует из того что если ну вообще вообще на то что ты сказал есть
контр пример вот всегда нужно помнить что существует язык ноль язык единицы вот что
такое звезда к линии от нуля тоже самое нет а это пустой язык с пустым словом типа да это
единица но при этом ноль плюс это ноль но из определения понятно почему да поэтому
иногда будут конечно единица но единица понятно что единица звезда равняется единица плюс
равняется вот про эти два языка очень важно помнить я сейчас скажу потому что это лучший
источник контр примеров когда что-то казалось бы что должно в нормальном понимании выполняться
будет наоборот не выполняться вот вы сравняли число и множество в этот момент можно прояснить не
совсем понял номера но пустого множество вполне понятно это не это не сравнял да тут это да
значок но должен быть немножко другой это я сказал что вот я буду вы значать нулём из язык пустой
множества единицы язык из пустого слова да правда ли что я двойка будет ну бесконечную множество
разных множеств такого рода вещь и ну или для единицы найдется куча множеств которые состоят из
одного элемента бесконечных я не совсем понимаю с роль этой самой единички нуля и других натуральных
чисел когда мы задаем это не это не натуральные числа это просто обозначение я вот сказал что я
нулём назову такое множество единицы за такое множество все все понял извините это просто
ну представь что переменная название переменной понял понял благодарю почему это 0 единица мы
поговорим вот следующем семестре там станет понятно почему это именно 0 почему это единица
что такое двойка тройка и вообще все натуральные числа хотя у вас же лектор лукашова он должен
был вам вот это вот затереть по-моему на первой лекции он любит тратить модель 3 раз вроде
рассказывал такое ну вообще я не знаю надо ли это фе кого-то там это называется теоретика
множественная подходка преди этот ординальный подход к определению натуральных чисел их там
несколько я с индукцией пиано и вот такой и кстати на лекциях по кутыче возможно тоже там показывали
там было множество из пустого множество еще множество из множества из пустого множество
и стоим множество так далее вот вот это вот это все натуральные числа да показывать был да
поэтому вот именно поэтому я называю мы стоим множество 0 множество из пустой последовательности
пустого слова это единица тогда не хорошо я хрен в общем первая задача она про что про то
что конкуренция языков не является коммутативной операцией то есть если мы поменяем местами у нас
все сломается примеру других некоммунативных ну наверное в школе если кому-то поездово вы
матрицы перемножали и если вспомнить что матрицы вот цель того как вы их перемножите в общем
случае вы можете получить различные ответы начисто все слишком хорошо там можно их нет
в общем по первому номеру первое что нужно делать вспомнить язык 0 то есть пустое множество и
просто проверить из тех где можно потому что как правило на пустом но сейчас потому что для
пустого множества коммутативность выполнена для пустого множества очень хорошо пустой
множество что она является под множеством любого множества соответственно везде
где только вы видите значок под множество будет уже вариант что да возможно здесь плюс здесь
плюс здесь плюс здесь плюс просто потому что значок под множеством а дальше все свойствует
потому что мы пытаемся найти, а когда же нет. Если мы долго думали и не придумали, ну значит нет.
Либо пользуемся какими-то свойствами. Давайте смотреть на L звезду. M равняется L звезда.
Тогда вместо M прямо сразу запишем L звезду. Действительно ли это так? Ну да.
И то и то является языком L+. Поэтому здесь точно да. Вот давайте если M это
некоторое под множество L. Будут ли случаи, когда нет? Будут. Супер, напримерчик. Ну,
например у нас L это множество из A и B, а M это из B. Тогда M на L всегда будет
начинаться на B, а L может начинаться на A. Супер, прекрасно и оба. И мне понравилось то,
что ты отметила. Если у нас язык состоит из одного символа, то если мы его сконкатенируем с чем-то,
где он первый в конкатенации, то все слова будут начинаться именно с этого символа. Вот эти вот
можно пользоваться для того, чтобы концентрировать контрпримеры. Этот прием поможет, он упростит.
L под множество M звезда. Ну, абсолютно тот же пример. Если здесь мы сделаем что? Если L под множество
M, то очевидно L под множество M звезда. Тогда разницы. Тогда если мы доказали, что B есть
контрпример, то этот контрпример подойдет для случивая. Какие варианты по букве M?
Ну, то же самое. А тут как раз, что у нас есть некоторые слова, double V. То есть L это все
возможные степени этого слова. L это язык. А M, значит, это будет какие-то степени этого
слова из какого-то под множество M. И поэтому пример, где что мы использовали, что здесь только один
символ и с него все будет начинаться. А в другом языке появляется абсолютно новый символ, который
появляется другой символ, которого нет в первом. А проблема языков M и L тут в том, что у них везде
это просто степени одного и того же слова. У нас не появится ничего нового. И простое свойство
W в степени K на W равняется W на W в степени K равняется W в степени K. Ну, если мы одно и
то же слово припишем, ну какая разница? Мы в конец его припишем или в начало. Поэтому для данного
примера, что мы L сначала приконкатинируем к L, что мы L приконкатинируем к L, разница не имеет.
Мы просто либо в начало допишем какой-то дополнительный отрезочек из N-ного количества
слов W, либо в начало. Мы слова не поменяем. Можно вопрос? Вот звездочка это же звезда к линии,
да? То есть у нас алфавит состоит из пустой строки и различного рода слов остальных. Ну,
то есть смысл в том, что есть пустая строка. Если у нас M состоит, допустим, из слова, в котором,
ну, которое просто представляет собой одну букву, вот это вот W, то получается, что когда мы
конкатинируем, у нас же пропадет этот самый пустое слово. Да, но оно пропадет в обоих случаях.
Здесь мы сконкатинируем вот, дай посмотрим тебя, вот Epsilon, W и так далее. Вот мы в первом случае
мы сконкатинируем так, то есть у нас будет что? У нас появится здесь слово W, здесь W, W и так
далее. А второй раз мы будем конкатинировать в конец. Ну, теперь мы припишем к пустой строке
в конец W, мы все равно получим W. А, все, я понял. То есть здесь идея на в чем, что у нас строки,
они просто какие-то вот повторяющиеся кусочки и без разницы, куда их можно приписывать. С
пунктом G всем понятно? Можно еще вот вопрос, а как объяснить, что вот когда мы L конкатинируем
с пустым множеством, мы получаем пустую множество. Как объяснить? Ну, смотри, давай.
По определению, это что такое? Это множество всех слов L, на все слова O, где L принадлежит
языку L и O принадлежит пустому языку. Поехали. Сколько таких слов, которые принадлежат пустому
языку? Их ноль. Супер. Какое множество у нас имеет мощность ноль? Это только пустое множество,
оно потому и называется пустым, что в нем никаких элементов, поэтому здесь, поэтому это пустой множество.
Понятно? Да. Супер. Тогда последний пункт D. Вот, M уже является под множеством плюс к линии
слово W, а L это sigma звезда, где sigma входит хотя бы с двух букв. Совет, когда пишут хотя бы с двух
букв, как правило, если есть контрпример, его можно найти на двух буквах, не надо плюсовать.
Поэтому можно сделать хотя бы это. Также, когда вот написано из некоторого слова, из некоторых букв,
если контрпример есть, ну без разницы, вы найдете каких-то других и потом переименуете его A, B,
G, D, либо вы сразу будете искать LBW, поэтому здесь мы можем сразу говорить, что это алфавит из A и B и
не пытаться там что-то придумать, потому что, так или иначе, придумав что-то более сложное, можно
будет переименовать эти символы на ABW и все сработает. Так что здесь хотя бы из двух символов,
ну тут уже спойлер был, так что может это контрпример? Мы можем взять слово AB? Да, все супер.
Тогда у нас все слова, где у нас сначала перемножается M на L, будут начинаться с AB,
а где L на M, они могут начинаться не с AB. Можно вопрос? То есть мы считаем,
что пустое множество это под множество любого языка? Мы не считаем это теоретиком множественный
факт, что пустое множество является под множеством любого множества. Почему так,
что для любого M его является? У нас по определению, что значит, что множество M под множество
L. По определению это значит, для любого M из множества M выполнено, что M принадлежит
для любого элемента множества пустого множества. Тут важный факт про пустое множество. Для любого
элемента пустого множества выполнено все что угодно, поэтому данные выполнены.
Понятно, спасибо.
Слово A тоже бы подошло? Да, тут даже любое слово подойдет.
А можно еще раз, какой ответ в A? Точно да, потому что вот смотри,
мы смотрели тогда, звезда к линии, что слева, что вправо, это будет…
То есть первое, что в этом номере сделать, мы берем пустое множество и просто проверяем,
и просто везде, где вот написано под множеством, везде сразу проставляем то, что возможно. А дальше,
ну у вас уже, даже если ничего не получается, у вас вероятность того, что вы ответите повысилась
с 33% до 50%. На угад, по натыков. Можно тыкать везде один вариант, тогда точно где-то попадете.
Кстати, про систему оценивания вот таких вот задач вы знаете или вам рассказывали, не рассказывали?
По-моему, не рассказывали. В общем, там файлики вроде есть.
Ну, я сейчас кратко еще раз напомню, что если вы отмечаете на все пять пунктов верно,
вы получаете полный балл за задачу. За тестовые задачи вы получаете 0,8 баллов. Если вы не ответили
правильно на все, но ответили правильно на четыре пункта из пяти, вы получите половину баллов,
то есть 0,4. Если не ответили ничего, то вы получаете 0 и у вас просто сгорела задача,
больше вы эти баллы не вернете. По тестам так. Соответственно, если вы проболели, вам потом эти
тестовые задания улетят в последнюю контрольную надписывание. Это по тестам задача. Будут задачи
развернуты. За них можно получить максимум один балл. Причем он либо вам ставится, либо не ставится.
Первый раз, получая задачу, вы получаете один балл. После этого задача считается закрыта и больше
никогда вы с ней не встретитесь. Если вы в первый раз на нее не решили ее верно, то задача вам
прилетит с другим, ну того же плана, но просто с другими условиями, прилетит на следующий контрольный
вдобавок ко всему тому, что должно быть на этой контрольной. То есть у вас количество задач
увеличится, времени нет. И количество баллов, которое вы можете получить во второй раз,
решив эту задачу, ужасно ценится на 0,8. Если вы во второй раз не решили, эта задача с другим
условием прилетит вам в домашнюю. И интересное наблюдение, что если у вас в первый раз
получилась задача сложная, во второй раз вам дадут задачу более простого плана, она будет чуть
более проще. А в домашнюю вам прилетит задача сложнее, чем та, которая была в первый раз. Поэтому
как бы сложность сначала чуть упадет, а потом разы возрастет. На домашнюю прилетают задачи сложнее,
чем в первый раз и встречаясь. Так что из советов, если у вас прилетели там задачки на следующую
контрольную, вы сначала решите вот старые, вы получите 0,8 и они будут чуть более простые,
нежели потом получите домашнюю. А потом уже решайте новое. Ну и плюс к тому, что если вы
в домашнюю решите, вы получите не 0,8, а 0,5. То есть вы потеряете не 0,2 балла, а уже 0,5.
Как-то так. Ну и получается особенность. Чем больше задачек вы решили, тем раньше вам прилетит
задачки D. Это дополнительные задачи, они оцениваются в полтора баллов и с их помощью можно
налутать баллов на десятку без дорежки. Это возможно. Да, это возможно, у меня такое было,
но я делал дорежку чисто ради удовольствия. Я бы мог сказать про приблизительные пороги,
какие были раньше, но я в прошлом году уже так сказал, в итоге там и контрольные форматы
поменяли, и порога упала, все попереставали, поэтому в этот раз ничего такого не скажу.
Там сама судьба все определит. Вот. Я, возможно, плохо слышу. Задача отлетает, если ты частично
решил, и сгорает, если ты вообще не решил. Смотри, тестовая задача у тебя никогда не
идёт в домашнюю, и не на следующую контрольную. Ты её либо решил сразу и получил баллы,
либо ты не решил и всё, потерял балл. А задача с развернутым ответом контрольная. Вот у нас
первые три задачи, как правило, нет, это первые контрольные, да. Здесь первые две задачи,
это тестовые. Дальше идёт третья, это всё, это уже текстовая задача, тут будет развернута ответ.
Соответственно, за неё будет максимум один балл. Те, кто сейчас её решат, получат один балл. Те,
кто сейчас не решат, у них отлетит задача на следующую контрольную, вдобавка всем тем,
которые будут тогда, если вы решите, получите 0,8 баллов. И есть уже второй раз, не решите,
вам летит в домашнюю она, и будет за 0,5 баллов. Особенность какая? Что если вы не решаете,
вот эти вот задачи с развернутым ответом, то вам не прилетят задачи D за полтора балла дополнительные.
И если все задачи будут постепенно летать в домашнюю, то без задач D вы не сможете набрать
утку. Ну или хор. Я думаю, сейчас всё же первый семестр все будут за хор стараться наливать хотя бы.
Поэтому советую, как можно раньше эти задачи развернуты решать. На тест, если понимаете,
что ну просто не можете догадаться, сначала решайте вторую часть, а потом уже ну на тест просто
понатыкайте нога. Так хотя бы у вас не отлетит на следующую контрольную задачу. А здесь, ну если
не знали, то знания ниоткуда не возьмутся. Так что как-то так. Извините, а вернуться в предыдущие можно,
где мы... ну там была последняя буква, вот. Да-да, под буквой D. Можете, пожалуйста, повторить пример,
когда выполняется. Пустое множество. Пустое множество? Смотри, видишь, вот метка того,
что пустое множество здесь подходит. Значок под множество. Вот я сразу поставил везде выполнено,
есть значок под множество. Потому что частный случай под множество это пустое множество.
Я понял. Всё хорошо, спасибо. Всё, пожалуйста. Это вот такой хороший индикатор того,
что здесь прям. Вот, например. Главное, чтобы потом на контрольной не дописали,
что им это не пустое. Ну если... ну, честно, в мой год там не дописывали, в прошлый год, по-моему,
не скидывали штуки, но в прошлом году там очень сильно сочинялись на контрольных. Я не знаю,
что будет в этом году. В этом году, хотя для по-моему, информатика что-то сделает новое.
Кому как повезёт. В общем, здесь мы вспоминаем, что мы обсуждали PSP. Там три правила,
ещё их напомню. Epsilon phi, phi, phi, phi. И это первое правило, второе правило.
Эти пользуются лево-социативным, право-социативным, оно просто поменяет первый сход,
поэтому оно бесполезно. Нам два правила достаточно будет запасом. Вот. У нас заданы рекурсивные правила.
У нас есть условия, что пустое слово является PSP, а дальше уже вот новые собираются показанным
правилом. И нам нужно определить, что получится все PSP, но не все. Получится все PSP, только они.
Все PSP, но не только они. Все PSP не получаются. Получается не только PSP. Ну, то есть, если
посмотрим, у нас есть. Не посмотрим. Как делать такой номер? В общем, способ, который я предлагаю,
он заключается в том, что у нас есть первое правило. У нас есть. Ещё раз я его выпишу.
Вот. Эпсилон. Дальше правила контрдонации и навешивания скобок. Здесь у нас везде есть правила
Эпсилон и вот ещё дополнительные правила. Дальше как мы можем сказать, что одно множество может
быть получено при помощи другого множества. Давайте посмотрим как-нибудь. Ну, вот такое множество.
Оно построено как Эпсилон, С1, С2. Это то, что я в своё время назвал там выводом одного правила
из другого правила. То есть, можем ли мы получить и, пользуясь вот этим правилом, следующее правило?
Ну да, конечно. Да. То есть, что... Ну да, как мы это сделаем? Мы здесь делаем сначала.
Фи. Фи. Пси. Пси. Вместе наконконтонируем мы их как Фи. Пси. То есть, да, это было значимым как 1 и 2.
Здесь это 1 и 1. Здесь 2. Ух ты. Нет, наоборот. Вот 2 здесь и 1. Что, по сути, сейчас мы сделали?
Мы сказали, что имея слово... Вот, если мы имеем слово, построенное по данному правилу, то мы можем его также разобрать по правилам справа.
А что это означает? Что любое слово отсюда принадлежит слово справа. У кого-то фонит.
Итак, мы получим, по сути, вложение. Вот. Получается, если мы можем вывести из правила A правило B, то множество слов, сдаваем правилом B, будет вложено в множество слов, сдавая их правилом A.
Как доказать эквалентность двух множеств? Доказать вложение в обе стороны. И как доказать, что они не вложены? Просто привести пример, когда принадлежит этому множеству, но не принадлежит другому.
На этом метод решения этой задачи все. Здесь что мы знаем? Мы знаем, что В будет вложено в ПСП.
Вопрос. А ПСП вложено ли в В? Нет. Ну правильно, да. Потому что здесь у нас всегда количество скобок, которые мы добавим, оно будет кратно четырем. А если мы возьмем ПСП из двух скобок, мы никогда не получим.
Вот такой случай. Давайте осмотреться на пункт A.
Можем ли... Ну тут, наверное, даже пытаться вводить правила не имеет смысла. Какие у нас отношения пункт А из ПСП?
Ну если взять и сытые и пустыми, то понятно будет не ПСП. Да, то есть у нас появится не ПСП. Здесь есть. Не ПСП. А у нас могут ли получиться ПСП?
Сейчас скажу. У нас получается не ПСП. А могут ли получиться ПСП? Не могут. Тоже не могут, да.
Ну из первого правила могут. Могут, вот. Я могу получить ПСП. Прикол в том, что у нас получится ПСП могут.
То есть это тот самый случай, когда я могу получить какие-то ПСП, но не все. Плюс я получу еще какой-то дополнительный мусор. Это четвертый пункт.
Смотрите, как можно понять, что получится какие-то ПСП? Мы можем из какого-то правила получить другое правило.
Вот у нас же есть. Тут наследуется правило второе. Если наследится правило второе, то значит какую-то часть ПСП мы получим.
Почему нельзя получить все ПСП? Ну потому что по данному правилу ты не сможешь получить строку вот так вот.
Мы бы могли, знаешь, что сделать? Получить все ПСП. Если бы мы могли вывести еще второе правило.
Получить все ПСП, тогда нам нужно доказать вложение в другую сторону.
Значит нам нужно из правил, предложенных в пункте А, вывести правило, предложенное в определение ПСП.
Ну вообще получится такую строку получить. Если сначала первым правилом со всеми простыми строками, потом закрыть скобочками.
Тогда давай я тебе приведу не пример, потому что пример сейчас. Я тебе докажу из...
Сейчас, хотя может быть, может быть сейчас подумаем. Хороший вопрос.
Давайте подумаем. Сначала я залезу в свои разборы прошлых лет.
Елки-палки. Они еще поменяли тренировочный вариант. Сейчас скажу.
Извините, пожалуйста, а разве если вот будет получаться такая скобочка по второму правилу, то С1 будет просто одной скобочкой, а значит она не будет ПСП?
А по моему по условию С1, С2, С3 ПСП или нет?
Смотри. Мы говорим, что здесь, давай смотреть, у нас задается какие-то слова, какое-то множество.
Какой-то язык. Вот слова из языка. Вот С1, С2, С3 это слова из какого-то языка. Вот так вот мы используя эти правила мы соберем сам язык.
А потом мы смотрим, этот язык будет ПСП или не будет ПСП.
Поэтому мы смотрим эти слова сами по себе. Мы можем смотреть на них как на ПСП, а можем смотреть как на них на ПСП.
Возвращаемся с того, что мы хотим сделать. Доказать, что неравны, неравны.
Да, вероятно немножко мозгодорвительно.
Сейчас давай про пункт А подумаем.
Зачем они это сделали?
А можно спросить, что значит все или не все получаются?
Получится все или не все. У нас есть...
Вот наш появился язык, который мы задали этими правилами. Есть язык ПСП.
У нас есть два варианта того, что может быть. Вложенность в одну сторону, вложенность в другую сторону.
Дальше на каждой из этих два варианта. У нас есть вариант выполнена или не выполнена.
Тогда мы получили четыре варианта и здесь они названы словами.
Вот что такое получается правильность к облачной последовательности, но не все.
Значит получается правильность к облачной последовательности.
Это означает, что А вложено в ПСП, но не все, но в обратную сторону исключения нет.
Получается все ПСП не только они. Значит А вложено в ПСП, но А не вложено в ПСП. В А есть что-то кроме ПСП.
Получается все ПСП, но не только они. Då есть, получается все ПСП и только они. Есть вложение в обе стороны.
И последнее, не все ПСП получается, но получается не только ПСП. В обе стороны вложения отсутствуют.
Вот что, по сути, это за ответы. Понятно или не очень? Нет. Правило, которое мы задали, оно...
Что это такое? Оно на экране сейчас присутствует? Которое мы задали. Ну вот, например, сейчас
рассматриваем правило A. А, это правило. Да, вот, их два правила. Их S1, вот, раз правило,
которые... Скопки на вещь. И второе. Как могут получиться вообще PSP? Ну, ну вот, смотри, по A...
По первому пункту мы можем получить PSP, если мы будем просто применять только первое правило.
Мы получим скопки, которые будут правильными скопочными. А если мы начнем применять второе,
ну как-то бездумным, мы можем получить не PSP. А как это правило вообще понимать,
что это значит? S1, скопка закрывается, S2, скопка закрывается, S3. Есть Epsilon. Дальше у
нас есть S1, тогда мы можем получить строку S1. S1, S2, S3. Это вот S1, S2, S3. Вот правило построения.
Дима, можно получить твою строку. Вот так вот я получу. Дальше, что я сделаю? Я получу строку вот
такую вот, просто понавешивав Epsilon. И дальше получу вот так вот, навешивав сверху,
поэтому можно. Соответственно, что мы можем сказать? У нас в одну сторону, вот из пункта A,
немножко так, пойдем к более хорошей терминологии. Из пункта A мы знаем, что в PSP у нас вложения нет,
потому что нас, например, может получить строка вот такая. Теперь вопрос. Всякую ли PSP мы
можем построить по правилу A? То есть для этого что нам нужно сделать? Посмотрим. То есть нам
нужно из правил вот этих вот получить правила. Давайте я возьму второе определение. Сейчас я
буду доказывать. Определение, что у нас есть FIPSY. Тогда я могу получить вот такую вот штучку.
Моя задача получить как-нибудь вот это добро из вот этого всего. С конкретноцией будет чуть
более неприятно. То есть, как я могу это сделать, по идее? Я могу, во-первых, убрать из два. Тогда
у меня останется здесь из один, как вот ST. Пока номер не надо. Ну, пока вроде так я буду делать.
Дальше я могу что сделать? Я далее могу навесить наверх скобки. По правилу первому.
Я получу 1, S1, S3. Хорошо. По-хорошему, здесь S3. Сверху снять скобки. Есть два варианта.
Либо они действительно были получены сверху наложением скобок. Тогда мы можем просто снять.
Либо это была конкретноцией каких-то штучек. Я теперь вспоминаю про первое определение. Вот я
смотрю сюда. Первое определение мне говорит, что вот что такое S3. S3 могло получиться как из
некоторой строки S4. Тогда в чем проблема? Мне будет просто... Сейчас скажу. Эти скобки...
Скажу. Вот у меня такое правило. Я хочу так. Я хочу объединить скобки и S3 в одну вместе
переменную. Сказать, что это может соответствовать какой-то другой, которая была получена.
Может быть, S4. Это возможно в двух случаях. Когда само S4 было получено так, либо само S4
могло быть получено как? Фикон, конкретноция С. Тогда две эти крайние скобки могли получиться из...
Какого-то, сейчас скажу. И вот так вот. И тогда мы спустимся на уровень индукции ниже и все будет
работать. А теперь нужно подумать, как сказать все это докладно. Сейчас скажу. Можно вопрос?
Разве из того, что мы из правила A доказали, что мы можем прийти к первому правилу задачи всех PSP,
разве не следует то, что мы можем получить все PSP? Еще раз. Ну вот мы из цепочки превращений,
что мы сначала оставили S1, скобочка закрывающая, скобочка открывающая, S3, и потом приписали слева,
справа скобочки. Мы как бы пришли к первому правилу задачи всех PSP, когда мы записывали их.
Когда мы только ввели PSP. Ну смотри, какой тут момент, что правила у нас... Давай рассмотрим
пункт B. Пункт B, он хороший. Да, у нас есть S1, S2 и есть S1, S2. Вот у меня есть правило это,
правило конкатинации я могу легко вывести, а теперь как бы не вывести это правило,
просто возьму, дополню одну эпсеном, сделаю строку и все будет хорошо. Так вот здесь я получу в точности
так правило, как оно здесь написано. Когда я дописал сюда скобки, что я сделал? Я на самом деле,
я получил комбинацию этих правил, то есть я взял второе два раза и к нему применил единицу,
и проблема в том, что теперь мне нужно здесь лишние скобки их снять, чтобы получить в точности то,
что написано в правиле, сдающем PSP, иначе будет несколько не край. То есть нам обязательно нужно
несколько операций применять. Если одна операция, то это не считается. Нет, не совсем. Давай, вот,
смотри, я применил операцию, я получил такую строку, но в правилах у меня именно такой строки нет,
у меня есть конкетинация двух произвольных. Сами же две эти произвольные, они не обязательно
были получены как конкетинация именно двух полученных таким образом. Они сами могли
быть получены как конкетинации некоторых других. Да, мы можем сказать, что в какой-то момент времени
вот этой конкетинации мы не можем бесконечно что-то просто конкетинировать, потому что если
был бы Epsilon, но конкетинируя Epsilon самим собой, мы ничего нового не получим. То есть если мы
получили что-то отличное от Epsilon, в какой-то момент мы должны были на Epsilon навесить вот эти
вот скобки круглые. А значит, в какой-то момент мы сведемся к тому, что у нас будет конкетинация
вида что-то там, так далее, вот, что-то там. Сколько-то раз вот эти вот конкетинации были
скобочек навешанных. Ну и а эти исходные скобочки, вот такие вот конкетинации, мы можем
получить путем того, что вот в S1 скобку здесь делаем по этому правилу, так вот понадобляем двойные
внутренние. Но это значит, что мы можем получить все по SP? Да. Но у нас же не получится по нашему
правилу, чтобы у нас как бы было просто вот как бы phi1, phi2 без скобок. Да, это то, что мы сделали,
мы явно правила не получили, но мы спустились на один уровень индукции вниз. То есть мы посмотрели,
а откуда из происходит вот это вот правило, как сами слова phi и psi могут быть устроены. Явно мы
получить действительно не можем, поэтому мы теперь пытаемся смотреть, а вот по ссылке как они могли
быть получены. И вот мы, когда посмотрели, мы поняли, что в какой-то момент они должны
быть получены по правилу 2. Конкетинация рано или поздно у нас ведется к тому, что мы должны
были сконкетинировать правила 2. Иначе, если бы у нас не было конкетинации правил 2, мы бы
конкетинировали epsilon, а значит ничего не изменяли. А правило 2 у нас уже разрешено, мы можем применять
что-то правил 2. Правил 2 у нас разрешено. И теперь, когда мы так посмотрели в истории, как мы
получили эту строку, мы думаем, а теперь как нам вот этот весь ужас наконкетинированных скобочек,
как нам это сделать? То есть здесь у нас будут переменные, какие-то произвольные, там alpha,
beta, gamma, delta. Вот они все хорошо, мы сможем их как-то использовать. Вопрос, как нам
теперь вот навесить вот эти ужасные скобки? А мы узнаем теперь как это сделать. Вот здесь у
boot мы s2 просто затрем epsilon, здесь мы проставим все переменные, а потом сверху навесим двойные
скобки. Сейчас было понятно вроде или нет? Ну не очень понятно, как бы как сделать изначально
строчку, если у нас нету скобок, как нам получить такую строчку? Давай тогда я заново начну писать.
У меня есть правило навесить. А нам не проще начать рассуждение от того, что взять правильную скобочную
последовательность и доказать, что мы ее можем получить по этим правилам? Круто говоря, мы это и
делаем. Вот у меня есть два, вот есть здесь как-то правило задают и здесь как-то правило. Вот понятно,
что слова получены по этому правилу, я легко могу получить используя это правило. Вот все,
то есть здесь все хорошо. Теперь мне чтобы показать, что я могу все слова построить по данным правилам,
я могу разобрать по этим правилам. Мне нужно показать, что правила FICON комбинации PSI можно
получить используя вот этот ужас. Как это делать? Давайте смотреть на то, как были получены FIC.
Смотрим на шаг раньше, как они были получены. FIC они могли получены по конкотинации. Ну,
значит, теперь мы просто сконкотинировали еще несколько раз. Либо они были получены
по правилам по правил 2. Вот, значит, они будут представлены в виде как-то скобок и внутри них
переменная какая-то другая. Понятно, что все эти переменные в какой-то момент должны были быть
получены по правил 2, либо это EPSION, но конкотинация с EPSION нам не даст никаких скобок. Ну, это просто
не изменяет строку никак. Значит, в какой-то момент вот шагая назад и изучая то, как были
получены FIC, мы придем к тому, что у нас получится строка вот alpha, beta, так далее там, пусть будет
вот. Это следует к тому, что у нас есть какие-то PSP alpha, beta, mu, и на них сверху навешаны вот эти
вот скобки. Это, по сути, вот это правило, которое мы здесь получили, но только за несколько шагов до. Вот
как нам теперь его получить? Эту мы можем уже разобрать строку по правилам левым. Мы возьмем вот
здесь вот это навесим, потом это навесим, потом это навесим, а потом в самом конце мы вот так вот
наверх. И таким образом мы сможем вывести это правило. Сейчас было понятно? Да, спасибо. Супер. В общем,
да, действительно, здесь будут какие-то моменты, когда нам придется шагать в историю назад и искать
то, как были получены сами вот предпослуги PSP. Можно ли было воспользоваться правилам префиксных
сумм для PSP? Смотри, правила префиксных сумм, префиксные суммы, они могут сказать о том,
что строка PSP или нет. А здесь несколько другое то, что мы делали. Мы проверяли PSP это строка
полученная по правилам A или нет. Вот в обратную сторону, да, можно было воспользоваться, когда мы
проверяем, получается ли строки PSP. Здесь мы делаем обратно. Так что, да, здесь мы вот знаем,
что так будет. Это какой у нас пункт? Здесь что мы сказали? Здесь PSP, но не все. Получается,
получается все. Здесь один был у нас. Здесь мы получили PSP, но не только они. 3, хорошо. Смотрим
на пункт B. Пункт B, да, я вот показал, как его легко вывести. Поэтому мы получили что из этого? Мы
вывели из правил B правило PSP. Значит, теперь PSP вложено в B. Значит, теперь нам нужно в обратную
сторону попытаться вывести. Из правил PSP правило B. Правило 2 у нас есть. Правило 1
получается путем применения правила, путем сборка опять стилу правил. Мы сначала их сконкатенировали,
получили PSP. Соответственно, для него мы теперь можем получить правило 2. И получим таким
образом правило B. Так что они в обе стороны получили вложение, значит равенство. Сейчас
прочитаю комментарий. Мы доходим до момента, когда сумма ноль, и выделяем им под строку в скобках.
Не совсем понимаю, что ты написал в плане том, чтобы доказать именно, что любую PSP мы можем
изобрать по правилу A. Вот если ты это как-то распишешь, то я попытаюсь понять, пока я не особо понимаю,
просто идею. Там такое же разделение, как и с этими подпоследовательностями. Только мы просто идем
по префиксам, доходим до момента, когда префикс ноль, сумма в префиксе ноль. И тогда мы говорим,
что у нас есть вот этот префикс, и он является под строкой в скобках. То есть вот здесь отмечена
альфа в скобках, потом так далее, потом мю в скобках. Мы делаем такое же разбиение,
только через префиксную сумму. Мне надо подумать, я подумаю, сейчас не скажу так сходу. В общем,
в случае оно не работает, но возможно тут оно сработает. Так сразу я подумаю. Пока про пункт G подумаем.
Ну из сил того, что у нас просто одна скобка, понятно, что у нас появится какой-то мусор.
Уже знаем, что здесь G не вложено в PSP. Будет ли вложено PSP в G? Какие варианты?
Ну да, это вроде второе правило наше. Да, все. Здесь присутствуют все правила,
соответственно мы получим это все. PSP в G или на G. Получается все PSP, но не только они. И пункт D.
Это правило про создание PSP. Да. Поэтому будет PSP и все они. Да, супер. В одну сторону мы
получим наше правило, которое второе просто взяв epsilon, а в обратную сторону мы получим из
правила двойного, дважды сконкатенировав получив три строчки и потом прируниться.
Не совсем так, ошибаюсь. В общем, правильно, формально делаем как? Мы делаем phi, делаем
конкатонацию phi. Дальше у нас есть psi, вместе получили phi, psi. Дальше есть какой-нибудь rho,
вместе получили rho, phi, psi. Так что здесь, да. Кстати, по номеру второму здесь реально будут
вопросы. Или не будут? Видимо нет, супер. Формально доказывать нужно именно с двух сторон, то есть
сначала то, что пункт принадлежит PSP и наоборот. Да, но это номер тестовый, от вас никто доказательств
этого не будет. Если понимаете, что что-то типа как пункт A, что-то очень неприятное, на это время
тратить не надо. Вот как интуиция подсказывает, так пишешь и потом, если время есть, сядешь,
подробнее разберешь, но не нужно сидеть на тестовом. Не люблю этот номер.
У тебя шоу с микрофоном. Можно писать в чат. Не, еще раз про пункт A. Ух, без проблем, еще раз скажу.
В общем, нафига они его дали, как я не люблю. В общем, прикол с пунктом A. Вот пункт A. Синим
написаны правила, по которым можно построить справа PSP, слева пункт A. Мы сразу можем сказать,
что если я понатыкаю EPSY в третье правило, то я получу скобку, вот такую последовательность скобок.
Она не является PSP, соответственно, у нас уже точно A не вложена в PSP. Теперь мы смотрим,
а как же ведет себя PSP? Оно вложено в A или не вложено? Для этого в данном пункте мы не сможем
явно вывести правила, как делали во всех других, просто подставив EPSY или пару раз накомбинировав
правила. Здесь нам придется рассматривать, как были получены phi и psi. Здесь, смотри, вот второе
правило, оно как звучит, что если phi и psi и PSP, то phi конкотинация psi, это PSP. Но с очередь же,
если phi и psi были PSP, то они были получены по одному из правил, либо где навешаются скобки,
либо где конкотинируются. Тогда рассмотрим два случая, они были получены либо как навесили скобки,
либо как конкотинация. Если были навешаны скобки, то тогда мы сведемся вот к истории,
что будет альфа и даже проконкотинировали какую-то переменную. Если была конкотинация,
они были получены конкотинация двух строк, то давайте посмотрим еще один ход раньше,
как они были получены. И если так разбираться, то конкотинация в какой-то момент должна была
свистись к элементам, которые получаются либо по этому правилу, либо являются EPSY. То есть мы
взяли и по возможности все эти верхние конкотинации, мы их раскрыли. Все, как только мы всех раскрыли,
мы получим что? Мы получим либо EPSY, либо вот эти правила. Соответственно, все переменные,
которые были не EPSY и сконкотинированы по первому правилу, они дадут вот такую вот строчку.
И теперь наша задача как-нибудь распарсить эту строчку по правилам слева. Если мы сможем это
сделать, то мы вывели по сути второе правило. Мы сделали что? Мы посмотрели, мы просто немножко
развернули по истории, как была получена эта строчка. Ничего больше. Хорошо. Как мне получить такую,
имея A, B, так далее, mu, например. Что я сделаю? Я сначала везде розы меню на EPSY, получу правила
phi, две скобки psi. И дальше что я буду делать? Я сюда подам alpha, b, сейчас. Я сюда подам alpha,
здесь получится alpha, psi. Вместо psi подам мне это правило. Там будет alpha, beta, что-то там новое,
psi, так далее, до alpha, скобки beta, скобка, так далее, там, до mu. А теперь мне нужно навесить верхние
скобки, чтобы укрить в точности то, что у нас есть. Это я могу сделать по первому правилу. Все. Я
получил эту стропу, значит, я получил это правило. Значит, мы любое слово,
которое является PSP, можем разобрать при помощи A. Потому что я вывел это правило,
вывел это правило. Все. Понятно? Тебя не слышно.
Напишу в чате, понятно, непонятно. Мы пойдем дальше, если непонятно.
Ну, в общем, будем считать, что понятно. Давайте смотреть пункт номер третий, последний в контрольной.
Он про то, как разбирать формулу, когда есть неоднозначность разбора. У нас есть два правила.
Хоп и хоп. В какой-то момент у нас должны были вместо phi и psi попасть в формулы,
переменные. Тогда давайте смотреть снизу. Вот. Найдем момент, в который могло
получиться первый раз две переменные объединиться, и потом как-то из этого получать варианты.
Что у нас есть? У нас есть уже либо одна палочка между переменными, либо две. У нас таких моментов
ровно два. Это QR и RS. То, что их получилось два, ну, наверное, такая фраза подскажет то,
что мы начнем разбирать QR, получим один способ RS, получим второй способ. Давайте разбирать QR.
Для этого строим дерево разбора снизу. QR вместе дадут. Дальше. Это новая какая-то переменная. Мы
могли что сделать? Мы можем попытаться с П соединить, но тогда мы захватим эту скобку,
и уже С мы не сможем никуда применить, потому что каждая переменная должна быть окружена своей
палочкой с двух сторон. Тогда, значит, нам придется брать С. Хорошо. С. Вместе дадут палка QR, палка С.
Ну, теперь понятно, что нужно будет брать П. Берем П. Палка, П, палка, палка, палка, К,
палка, палка, палка, палка, палка, палка, палка, палка, палка, палка, палка, палка. Ну и
теперь, сделаем сюда вниз. Сидел. Вот сюда. Теперь у меня, ну, просто остался Т. Значит,
сюда навешу t, здесь две палки, как раз с точностью второе правило. вместе это палка, палка-палка-п,
палка-палка-п, палка-палка-ку, палка-палка-р, палка-палка-с, палка-палка-палка-п, палка-т-палка. Всё.
Я получу формулу. Всё. Первый разбор получилось. Написав такой дерево-разбора, можно показать правил,
какой здесь примерно здесь палка палка палка здесь палка палка здесь палка полка
что я применял. Вот так вот. Показали правила, по которым получены деревья, построили деревье
разбора, всё, показали как это деревье разбирается. Почему мы решили начать именно Square? Ну, смотри,
я показал, что есть два варианта, как можно начать. Потому что в какой-то момент мы начали
объединить переменные. Переменные можно объединить либо палкой между ними, либо две палки. Смотрим,
где такие случаи есть. Их ровно два. Есть две палки между Square и две палки между RS. И я сказал
тогда, что вот, похоже, это два кандидата на Doc можно разобрать. Вот я начал Square просто потому,
что выбрал так. Теперь вот я разберусь с RS. Это будет второй разбор. Я сейчас сделаю RS. Палка,
палка, палка, палка, палка. Шлёп, шлёп. Отмечаем. Теперь по аналогии с RS нам придется теперь взять
Q. Палка, Q, палка, палка, R, палка, палка, к палкам, бух, бух, бух. Теперь что? Если я возьму T,
то я вот захлопну здесь и не смогу навесить P. Значит мне придется взять P. Как я беру P? Я
беру по правилам двух палок. Палка, палка, палка, палка, Q, палка, палка, палка, R, палка, палка,
S, палка, палка, палка. Теперь у меня T просто навесить. Я получу палку, палку, P, палку, палка,
earlier. Палку, палку, палку, палку, палка. Палка, палка, палка, палка, палка. Жук, жук. Всё.
Пожалуйста, получено два разбора. Можете ли будет после этой задачи еще разknуться к пункту D,
задача два? Да? Спокойно. Вопросы по этому номеру есть organizations? Это какой-то лёгкий номер
номер по сравнению со вторым? Да, я очень не люблю второй номер, он очень неприятный,
в тест высложный, и это радость, действительно. Следующий контрольный будет все номера легче.
У вас показывают, как у меня чёрный экран стал? Чёрный.
Не знаю, как это работает, но когда у меня экран гаснет, у меня прекращается там связь
экрана. В общем, пункт 2D. Смотри, требуется ли снять построение деревьев? Достаточно просто
построить. Их достаточно просто построить. Там даже будут решения прошлых лет у меня.
Давайте, ну сейчас покажу чуть позже про них. Там прям так вот решение, которое вот отлекто.
В общем, пункт D еще раз два. Смотрим, можем ли вывести из этого правила правила PSP? Давай я возьму
S1 эпсилоном и я получу второе правило построения. Ну или что это? S3 эпсилоном. Вот я получил здесь
это правило. Эпсилон там есть. Всё. Значит, я получил, что все PSP будут разбираться по правилам D.
Всё. PSP вложено в D. А откуда взяты вот эти вот правила с синим цветом под номером 1 и 2?
Так вводится PSP. Помнишь, когда я рассказывал про PSP? Это из теории, понятно. Да, вот их три правила.
Вот всё. Это вот второе и третье. На самом деле, ну блин. Ну ладно, да, 2 и третье помните. Когда-то
будет удобнее использовать 2, когда-то используется удобнее 3. И первое правило, которое с конкатенацией
навешивания сколько? Ну и в пункт D как мне получить? В пункт D я получу из первого правила. Вот мне
приятнее получать вот с этого. Что я сделаю? Я сделаю вот навешу, а потом дважды сконкатенирую,
получу правило D. Поэтому D вложено в PSP. А это пункт 2. Не пункт 2, это ответ 2.
В целом, с надлогом всё. Вот если есть вопросы, давайте сейчас их объясним. А можете пояснить по
поводу оформления на контрольной работе? Оформление. В общем, в первом вы прям тут будете писать,
что точно да, точно нет, возможно два варианта. Может быть у вас будет матрица ответов, там будут
типа строчки A, B, V, и вы там пишете. Но обычно здесь просто вот, прям так и будет написано,
вы просто будете писать рядом. Точно да, точно нет, возможно оба. В номере 2 просто рядом
проставите циферки. В мой год так было. Может быть вам сделают там табличку, проставите циферки.
И именно формально расписывать решение вам нужно только в третьем. Для этого достаточно построить
дерево разбора. Вот давайте сейчас покажу. Можно вопрос? То есть получается, рассматривая PSP,
можно взять любой из трёх правил, которые мы ввели, и уже сравнивать относительно него? Да. Более того,
мы можем в одну сторону посмотреть по одному правилу, в другую сторону по другому. Это всё
абсолютно возможно. Потом при этом это сейчас, давайте я сделаю вот так вот.
Вот теперь я сделаю так. И получается вот у меня будет решение. Это решение моих прошлых годов.
Чуть позже, здесь записи появятся чуть позже. Здесь можно так искать, можно просто млта,
и тут будет всё, что нужно. Здесь будут всё про всем промотоньки, все материалы, я сюда выложу.
Давайте как-нибудь так. Вот, например, решение прошлых лет. Здесь было некоторое пояснение
про то, и вот, например, что. Вот прям да, решение от Вертера, пожалуйста. Всё. Так что,
если просто на всю дерево разбора, всё будет супер. Ещё вопросы по мат-логике есть? Если нет,
мы просто начнём. Ну хорошо, у нас вопросов нет. Показываем. В общем,
что я хотел сказать. В общем, да,
контрольная по КТЧ в тренировочном варианте очень простая для её решения. Ну, в общем,
есть по сути три метода их всех решений. Первый метод – метод пристального взгляда, просто смотрим,
замечаем, используем. Дальше для одного номера будет метод разбиений, который я вот придумал,
и до оставшихся двух номеров в общем случае задачи решаются при помощи, гарантированно
решаются при помощи метода характеристических функций. Вот про метод характеристических
функций сейчас мы посмотрим. Метод разбиений будет очень простой. Для этого надо вспомнить
более функция. Давайте, во-первых, вспомним теоретика множественной операции. Какие кто помнит.
Ничего не помните? Ладно, их пересечение, объединение, разность и просто разность,
но есть ещё дополнение. Всё. Соответственно, в булевой алгебре у нас есть такая штучка,
как А-конъюнция В, А-дизъюнция В, А-ксор В. Все четыре кроме среднего в школе точно были.
А-ксор уже был на мотогике на лекциях или ещё нет? Да, нам говорили. Супер-прекрасно. Полиномы
Жигалкина были? Нет пока. Значит, это будет прямо на следующей неделе, потому что следующий
контроль уже, по идее, должно быть там что-то про полиномы Жигалкина. В общем, поэтому сейчас
про КНФ, ДНФ слышали все. У нас есть таблицы истинности. Да, и здесь вот что-то у нас будет
там как-то написано. Соответственно, кnf и dnf мы можем просто построить и убирать там 0 единицы и
брать конъюнции соответствующих отрицаний или просто самих переменных. Но проблема кnf и dnf в том,
что в школе на алгебре мы работали с обычными полиновами, и мы могли спокойно их там складывать
вычитать, то в кnf и dnf вычитать мы уже не можем, поэтому как-то приятно решать уравнение мы не сможем.
Данную проблему решает вот этот вот потрясающий значок. Сор. Или исключающий или. Но я буду
исключающий или слишком долго говорить. В общем, почему он такой прекрасный? Потому что исключающий
или, иликсор, он одновременно является в буревой алгебре и суммой, и вычитанием. И когда мы называем
что-то полиновами Жигалкина, мы называем их просто этаполиновами, потому что аналогия с обычными
алгебраическими полиновами, которые были в школе, тогда они назывались многочленами теперь этаполиномами.
С ними можно перерывать абсолютно так же. А умножение, то есть это своего рода сложение в
школьных многочленах. Умножение в буревой алгебре будет конъюнцией. Так как писать каждый раз
конъюнцию в символ, то мы будем писать прям как с умножением, пуская знак. То есть, например,
запишем. Аксор БС это, по сути, запись аксор Б конъюнция С. Просто мы опускаем знаки конъюнции.
Хорошо. Несколько правил про аксор, что вот, например, аксор А, аксор БС. Аксор А, он одновременно
и сложение вычитания. Соответственно, мы можем как это складывать, так мы можем за вычитать А и
убирать А. Это то, что еще называется правилом аннигиляции аксора, что для любого А аксор А равняется
ноль. Ноль аксор А равняется А. Если мы ноль прибавим к чему-то, это все равно останется самим
собой. Ноль, в которой бурева константа ноль. Плюс у нас есть бурева константа единица,
провел связь с теоретико-множественной операцией, мы поговорим позже. Итак,
у нас есть единица и теоретико-множественные операции. Когда мы говорим про множество,
особенно в рамках операции дополнения, нам нужно понять, до чего мы дополняем. И в такие моменты
мы вводим понятие U. Множество, в рамках которого мы живем. То есть, например, дополнение А
— это дополнение А до множества универсума. Мы говорим, что такое универсум А? Это вот такая
штучка. Но просто такой штучки в математике быть не может, поэтому для этого существует некоторое
множество У, до которого А дополняется. Что тогда не А? Это У без А. В этой контрольной, как правило,
самого У не будет. Почему не будет самого У? Потому что… не скажу. В общем, в данном
моменте У не будет. Если У будет, я сейчас скажу, что надо делать. Попробуем. Множество У, универсум,
по сути, это будет своего рода в булевой алгебре единица, константа единицы. А пустое множество
будет нулем, стандартно, как в матлоге. Дальше мы хотим перейти от теоретико-множественных
операций к операциям булевым, потому что на булевой алгебре мы умеем как-то красиво работать.
Вот давайте рассмотрим. Просто на двух множествах. На больших все абсолютно
аналогично. Давайте войдем в понятие характеристической функции. Вот у меня есть множество А. Для него я
веду характеристическую функцию. Что она будет значить? А от х. Она будет равняться нулю, если х
не принадлежит А, и единицы, если х принадлежит А. Данный метод будет особенно часто использоваться
в теории меры, теории веры и так далее и тому подобное. Вот там вот прям это вообще любят. Даже
во втором смене снимать она у вас будет. Вот у меня есть множество А, множество Д. Соответственно,
давайте порасставим в единичке там, где закодируем все эти области словами из двух символов,
или это 0 либо единицы, где единицей первая будет, если это содержится в А, а в втором случае единица
будет, если это содержится в В. Поехали исполнять области. Здесь это принадлежит А, но не принадлежит В,
это 1, 0. Принадлежит А принадлежит В, это 1, 1. Не принадлежит А, но принадлежит В, 0, 1. Не принадлежит
ничего. Тогда, если я просто построю таблицу истинности 0, 0, 0, 1, 1, 0, 1, 1, это А, это В,
то произвольная область на этой карте я могу как-то закодировать некоторые булевые функции,
просто поставив, что 1 отмечен там вот 1, не отмечен 0. И получается, я дальше смогу довозить через
переменные А и В. На самом деле, эти переменные А и В, это есть характеристические функции, которые единицы,
когда принадлежит А, 0, когда не принадлежит В. Дальше, из некоторых соответствий, что мы знаем,
у нас пересечение множество соответствует функции конъюнции, то будет, если мы пересечем,
то мы отметим только область 1, 1, и мы получим следующую булевую функцию, и это действительно
конъюнция. Аналогично, у нас объединение соответствует дизюнции, симметрическая разность к Сару,
дополнение соответствует отрицанию, а теперь давайте посмотрим, что такое А без В. А без В,
это только область 1, 0. Давайте вспомним, как выглядит из А следует В. Из А следует В,
импликация имеет следующую таблицу истинности. Тогда А, дополнение В, по сути, является отрицанием
импликации. Отрицание импликации это хорошо, но всегда лучше, когда есть ксор. Для этого мы
запомним несколько интересных теоретиков множества фактов. Один из самых приятных,
что симметрическая разность В, это А без В объединить с В без А. Дальше у нас есть факты вида А,
это есть А без В. Вот, сейчас этот значок еще подниму и поговорю. Пересечь с В, что А объединение с В
есть А без В. Когда мы делаем объединение вот таким вот квадратным точком, мы, по сути, пишем
объединение, подчеркивая, что эти множества не пересекаются и называем это дизъюнтным объединением.
Например, метод характеристических функций помогает очень удобно доказывать все эти равенства.
Только давайте сначала поговорим про полиному Жигалкина. Полином Жигалкина мы можем по любой
бульевой функции построить его по лином Жигалкена. Пусть у нас есть таблица истинности 0.0.1.1.
У нас была таблица истинности 0.0.1.1. Это А, это В. Смотрите, как работают. Первая строчка будет
соответствовать единице, потому что здесь нет ни одной переменной. Здесь есть переменная В,
поэтому соответствует переменная В. Здесь есть переменная А, соответствует. Здесь единичка
в переменной А, соответствует поэтому в переменной А. Здесь есть единицы В и В, поэтому это АВ.
Выписываем вот так вот. 1.0.1.1.0.1. Дальше мы начинаем ксорить соседние числа. 0 ксор 0 это 0.
Ксор это по-другому сложение по модуль 2. То есть, если они различные у нас единицы,
одинаково 0. Поэтому здесь 1, здесь 1. Дальше здесь 1, здесь 0, здесь 1. Все. Теперь мы берем,
создавляем полином Жигалкина. Как он делается? Очень просто. Смотрим на вот левую часть
треугольника и проверяем, что если 0 мы не берем соответствующую ей переменную А с единицей,
то берем. В данном случае мы получим А ксор АВ. Вот. Например, тогда в полином Жигалкина это АВ,
АВ это А ксор, В это А ксор АВ. Что же такое объединение? Это А ксор В ксор АВ.
А отрицание это будет 1 ксор А. И как раз функция единица, почему она единица? Потому что
она будет здесь 1, 2, 3, 4 все содержать. И она будет говорить, что это весь универсум.
Хорошо. А, ну и получается про то, что я говорил, что удобно ими пользоваться. Как показать,
что это равно? Слева у нас в характеристических функциях записано А ксор В. Справа же что
у нас написано? А ксор АВ ксор В ксор АВ. Как мы понимаем, ксор это на временное сложение учитания,
поэтому одинаково просто убираем. Справа записано А ксор В. Все. В одну строчку доказали.
Есть вариант расписывать там х принадлежит, рассмотреть сети сучий, но по мне это быстрее
и приятнее. Все. Теперь, зная вот эту магию, мы можем что делать? Решать контрольную. Вот первый номер.
Кто-то шумит. Поехали. А без В. Ну на самом деле мы вот рассмотрели уже А без В. А без В это А ксор АВ
на характеристических функциях. А теперь мы просто берем заменяем все эти характеристические
функции на соответствующие множество и знаки теоретика множества. Это А симметрическая разность,
А пересечение с В. Все. Разность А пересечение с В. Что такое объединение? Объединение. Ну,
как делать это все? Берем вот таблицу, составляем таблицу истинности по этому.
Области 1.1.1.0.1.0.0.0.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.0.1.1.0.1.0.1.0.1.0.1.0.1.0.1.0.1.0.1.0.1.0.1.0.1.0.1.0.0.1.0.1.0.0.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0
Оsheetavim.
Тогда мы возьмем вот эти вот и
переменные.
Значит, мы получим, что мы получим?
А, XOR, B, XOR, AB.
А теперь просто записываем на языке
теоретикам и арсферам.
А, XOR, B, XOR, A, P, XOR, B.
Сечение СП. Последнее. Вот. Теперь уже у нас будет
три множества. Соответственно, теперь у нас области всё
появится 16. Это 1.0.1. Сейчас. 1.0.0. 1.0.0. Это 0.1.0. 0.1.
Здесь 1.0.1. Здесь 0.1.1. Здесь 1.1.0. Здесь 1.1.0. Здесь 0.0.0. Начинаем рисовать на
диаграмме L-ровенно, как выглядит наше множество. Это объединение без C. Значит, вот оно.
Всё. Быстро рисуем таблицу истинности. Раз, два, три, четыре. Раз, два, три, четыре. Раз, два, раз, два.
Раз, два, раз, два. У меня единицы помечено множество 1.0.0, 1.1.0 и 0.1.0. Всё. Всё остальное
у меня помечено 0.0. Всё. Теперь расписываю, какие будут соответственно здесь вот переменные.
Здесь все 0.0.0. Это единица. Здесь только C. Здесь только B. Здесь B и C. Здесь только A. Здесь A-C.
Здесь только AB. Здесь AB-C. Всё. Расписал. Начинаю строить вот этот треугольник. 1.0.1. 1.0.1.
Что еще раз? Что такое полином Жигалкина? Полином Жигалкина – это запись из единицы,
ксора и конъюнции. То есть мы любую булевую функцию можем представить, используя вот единицу,
ксор, переменные и еще конъюнцию. Всё. Используя вот эти три символа и еще переменные,
мы можем абсолютно произвольную булевую функцию представить в такой вот записи удобной. Она
похожа в своем роде на полином. В школе, если помнишь, было A плюс BC. Только теперь мы в
булевой алгебре живем, поэтому у нас плюсик у нас в кружочке, и при этом одновременно у нас
плюсик и минусик. Такая немножко большая особенность булевая алгебра. Что мы делали?
Мы здесь, когда нас попросили симметрическую разность и пересечение, нас, по сути,
в точности попросили построить там полином Жигалкина. Как сделать полином Жигалкина?
Вот можно было, знаешь, даже не строя таблицу естественности, считаю это, A без B. Мы знаем,
что... ладно, не совсем, не получится. Нет, я хотел показать, но не совсем получится,
в другом месте получится. В чем супер. Да, я вроде закончил. Сейчас понятно, в чем вообще смысл,
что такое полином Жигалкина. Просто такая вот запись. Это такой способ ее расчета быстрой.
Как нам быстро найти... Вот мы выписываем вот строчку всю таблицу естественности, вот видишь,
вот строчка значений функции, мы туда записали, вот строчку теперь транспонировали. А дальше
просто берем, если совпадают, мы посередине пишем ноль, не совпадают в единицах, делаем XOR.
Здесь XOR. И так вот заполняем треугольник. И дальше смотрим на его левое ребро. Везде,
где единицы, мы просто берем соответствующие переменные и получаем таким образом запись.
Здесь мы получили AXOR, AXOR, AB. Вот здесь вот у нас немножко сложнее, у нас три переменных.
Зачем это делать? Сейчас скажу. Ну, зачем это делать?
Потому что вот как раз в номерах 1 и 3 у вас может быть использоваться это.
Если вас как раз могут попросить использовать симметрическую разность пересечения,
либо вас будут использовать вот эти вот вещи. Объединение, пересечение, дополнение. Если
объединение, пересечение, дополнение, то при помощи метода характеристических функций мы
можем использовать KNF, DNF строить. Но KNF, DNF умеют строить все со школы. Здесь это...
В общем-то, здесь мы берем все, кроме первых двух. Здесь у нас BC, BVC6C, симметрическое дополнение.
То есть пленом Жигалкина использовать можно только, когда нас через симметрическую разность
и пересечение просят, что-то выразить? Да. В других случаях, в общем, раньше была задача на то,
чтобы решать уравнение в, сейчас скажу, уравнение в теоретике множественной. То есть при каких х у вас
там выполнено равенство. И тогда переход к пленому Жигалкину и решение через него, оно было в разы
проще, чем пытаться расписывать все эти случаи. Пленом Жигалкина, по сути, да, он применим,
если у вас пересечение симметрической разности. Если у вас объединение, объединение, пересечение
дополнения, используйте KNF, DNF. Что удобнее на ваш выбор? Грубо говоря, все это сводится к тому,
что вот теперь мы вместо теоретика множественных операций, мы хотим одни более функции выжать
через другие. Задачи аналогичны. В этом заключается метод характеристических функций. И зачем он
используется? Просто мы знаем про был функций немножко чуть больше, там закономерности чуть
больше, и нам удобнее пойти работать с ними в какой-то момент, чтобы потом обратно вернуться к
Могли вы повторить, что такое KNF и DNF? KNF и DNF это запись в помощи конъюнции и дезюнции. Сейчас
я, наверное, покажу в том последнем номере. Давайте пока это добьем. Вот что у меня здесь. Меня
просят все кроме 1 и C. То есть это будет B и C, и A и C, и A и B. Нет, C нельзя. И A, B, C. И
я еще что-то забыл. И AB. Вот. И этот номер так решается вот, например, быстро. У вас вполне реально
может быть по аналогии номер, где вас подпребуют выразить это как-то, например,
используя пресечение, дополнение, там, пресечение, объединение, дополнение. Давайте смотреть. Вот нас,
допустим, такое множество. Нас, таблица, истинность такая. Вы долго сидели, думали, вот,
но не приходит вам в голову как явно выразить из методом пристального взгляда использовать операции.
Это действительно нетреально. Здесь мы используем более общий случай, который нам гарантирует,
что так можно. Как это сделать? Ну, если нас просят так, то давайте делать что? Давайте строить
KNF-MNF. Вот у нас получилась такая таблица истинности. Так, как мы строим KNF? Эти просто KNF
будем сейчас строить, я вспомню только. KNF – это конъюнцы и там дисюнцы. Хорошо. Вот давайте про
KNF напомним, что конъюнцы – это конъюнцы вот таких вот скобочек, где внутри скобок стоят либо
переменные, либо их отрицание, и между ними может соединяться дисюнция. Всё. Вот такая вот
запись. Она строится по таблице истинности следующим образом. Да, конъюнцы будут нас фиксировать
нули. Соответственно, мы убираем строчки, где нули. Так запомнить, как строить KNF. KNF – она то,
что называется сохраняет ноль. То есть, если… или это не сохранение нуля. Нет, другое, да. В общем,
KNF – она обладает свойством, что если одна из переменных ноль, то все выражение сразу ноль.
Поэтому мы берем при помощи KNF, фиксируем значения, которые будут нули. Вот их пять
штук. Можем фиксировать. Конечно, на данном случае лучше KNF, но без разницы. Выбираем,
где нули. Тогда смотрим, здесь настоят нули. У нас теперь дисюнцы. Мы берем переменные,
и там, где нули, мы берем сами переменные, а где единицы, мы берем отрицание этих переменных.
То есть, если мы возьмем здесь дисюнцию a, b и c, то мы получим бурю функцию, которая будет
верна везде, кроме этой строки. А это ровно то, что нам и нужно. Возьмем a или b или c. Дальше там
конюнция будет, что a или b или c. Конюнция и так далее. Она вечно для всех странных строк.
А дальше мы что сделаем, когда нас попросили записать, используя эти знаки. Мы конюнцию
поменяем на пересечение, дисюнцию на объединение, отрицание на дополнение. На этом все.
С номером третьим вот мы сейчас попробуем что-то такое сделать. ДНФ это просто другой
вариант получается? В данном случае действительно будет проще искать ДНФ. Мы будем брать там,
где единицы. То есть, наоборот, там, где единицы. И мы будем делать так, чтобы вот переменные,
имея эти значения, давали единицу. То есть, конюнции. То есть, нам нужно будет сделать a,
сделать b и 0 превратить в единицу. Это будет не c. Все. Идея такая, что конюнция, она, сейчас скажу,
и что это сейчас. Конюнция, она фиксирует 0. А дисюнция, она фиксирует единицы. То есть,
если у нас есть где-то единицы, то при объединении единица, она сохранится. Значит, для дисюнции
мы будем убирать там единицы. Дальше нам нужно сделать так, чтобы вот теперь соответствующая
конюнция обращалась к единице на данном наборе. Где-то мы подбираем соответствующим образом
переменные. И все. Теперь, да, я покажу, зачем я выбрал КНФ в тот момент. Номер 6. Он решается
как? Первый вариант методом пристимного взгляда. Как решать методом пристимного взгляда? Ну,
смотрим. Да-да. Смотрим внимательно то, что нарисовано. Разбиваем на кусочки,
которые мы можем понять, как мы получили. Например, есть вот такой вот кусочек. Я знаю,
что это A без B или C. Ну, просто я так вижу. Этот кусочек это пересечение B и C. А этот
кусочек C без A или D. Дальше я это все объединил и получил это множество. Аналогично здесь это
пересечение без C, пересечение A и C. Вот это будет без B, а это C без объединения B. То,
что я сейчас говорю, на самом деле это... Что это? Это своего рода КНФ. Давайте смотреть. Я возьму
первый момент. Первый пример. У меня здесь 0.1.0.0.0. Даже не так. Я просто сделаю эти какие-то
закрашеные. Не будет понятна
единица, единица, единица, все остальные нули, что я предлагаю строить, я предлагаю
строить кнf, хоть это невозможно будет где-то не оптимально, строить в данном случае
просто все кнf, выбираем нули и выбираем так чтобы данный набор обнурялся, то есть
у нас будет ab, a или b или c, дальше здесь a или не b или c, здесь не a или не a или b или не c,
здесь не a или не b или не a или не b или c,
дальше мы вспомним свойства, что a следует b, это не a плюс b,
сейчас я скажу, а мы помним, что разность у нас была, а мы хотим разность,
что разность это три цани импликации, жух, жух, жух, жух на весе этой цани, раскрываем под
дымом, но это а и не b, поэтому надо будет строить dnf, да мы выбираем единички, это не а и не b и
c, не а и b и c, а и не b и не c, а и b и c, супер, что теперь я буду делать, я теперь буду эти кусочки,
зная, что у меня есть такая штучка, я их буду объединять, сворачивать вот в такие вот записи,
давайте я вот это специально сделаю значок, для этого а не следует b, он специальный значок
веду, чтобы не писать такую ужасную запись, вот это у меня станет не а и из b не следует c,
но вот теперь я могу сделать просто такую штучку и сюда применить снова это правило,
здесь c не следует b, вот, отметите, что здесь у нас а не следует b, а здесь а и не b, вот здесь не b,
значит нужно будет их поменять местами, аналогично здесь, это будет превратиться в вот c не следует b,
не следует а, все, по сути, что я сейчас сделал, я привел вот эту вот ужасную запись к запись,
которую я могу легко перевести в теоретику множественную операцию, вот эта вот операция,
это а не следует b, это множество а без b, теперь вот второе, второе что я сделаю,
я сделаю просто, здесь я сделаю c и из b не следует а, хорошо, у меня осталась еще эта штучка,
аналогично это b не следует а, объединение не c, это из c не следует b, вот, да, не это,
и это превратится в из а не следует b, не следует c, а последнее просто так остается,
а везде стоит disun c, тогда что я теперь делаю, я заменяю вот этот вот значок не следования на
разность, я получаю в точности ответ, то есть не будет c без b без а, объединение с c пересечь с b
без a, объединение с a без b без c, объединение с a пересечь b пересечь c, и действительно,
если мы посмотрим, то это именно те кусочки, которые мы хотели, вот например c без b без a,
это вот этот вот кусочек, мы вот так вот поняли как его задать, там вот пересечение кусочек,
а без b без c вот кусочек, остался кусочек, что там у нас, c пересечь с b без a, ну действительно,
это вот этот маленький кусочек, аналогично построив dnf и преобразовав данным способом,
мы можем получить для второго случая, для третьего случая. Понятно,
как будет делать третий номер, если прям совсем этот пристальный взгляд не работает.
А насколько обычно сложностей на контрольной и выше пробного варианта?
Ой, по УКТЧ, в общем, это абсолютно непонятно, то есть матлог, красота контрольных по матлогу,
что тренировочный вариант, он действительно отражает суть задачи. По УКТЧ, там у вас могут,
особенно дальше будут задачи, которые типа, это плюс-минус тестовые, типа считается, там будут
задачи, которые разровнуты, там вообще никак подготовиться, какой-то понять план, решение нельзя.
Поэтому вот здесь я просто вам рассказал про метод, который действительно дает,
гарантированно дает ответ, просто нужно будет выбрать, к какому варианту нам нужно прийти там,
КНФ ДНФ или, по-людному, Жигалкина. Ну и, конечно, есть вариант того, что, а, но на записи нету. Вот,
да, в прошлом году-то была запись, поэтому можно было случайно посмотреть и понять,
что если такое рассказывали, придумать специально контрольное то, что не рассказывали.
Всё, и последний номер. Да неужели мы такими темпами закончим? В общем, задача, на первый
взгляд, выглядит абсолютно устрашающе, непонятно как ее решать. Первое, что попробуйте сделать,
вы, вероятно, это... В общем, давайте так будем решать. Я могу показать сначала метод, который,
ну, мы просто попробуем решить по условным, то есть руководствуясь мыслям, а потом попробуем
сразу использовать прикольный метод, понять насколько он в разы быстрее и что там все быстро решается,
как что хотите, или сразу мы решаем быстрым способом. Лучше первое. Хорошо. В общем, быстрый
способ там, я, ну, я предполагал, что он будет быстрым, но когда я пробовал его применить,
там вообще слишком быстро, то есть если вы используете в 13, в 3, мы прям закончим. Ну,
давайте думать. В общем, у нас в обоих частях стоят что? Стоят декарта произведения.
Нет, это для моего метода. В общем, декарта произведения, когда вот декарта произведения
будут равны, когда обе части с двух сторон будут совпадать, соответственно, мы сможем теперь разбить
вот это равенство на одновременное выполнение равенства для двух сторон. Что я предлагаю делать? Вот.
Здесь вот рисуем, здесь рисуем. Будем писать слева то, что по левую часть декарта произведения,
справа то, что по правой части декарта произведения. Объединение, ну, понятно,
что это просто система, когда совокупность называется. Поэтому первый случай у нас какой,
когда A объединяется с B, а здесь C объединяется с D. Здесь у нас A объединилась с B, здесь C пересеклась с D.
B, C, A, B, D без C, A без B, C и D. Поехали. Все. Теперь наша задача будет заключаться в чем?
Что равенство у нас выполнено тогда и только тогда, когда обе стороны вложены друг в друга.
Все. И у нас есть дополнительные условия. Начинаем с этих вот условий. Давайте посмотрим.
Если A вложено в B, то мы посмотрим, как можно простить A объединить с B, а пересечь с B.
Что такое A пересечь с B, если A вложено в B? В B просто. Пересечь? А, нет, пересечь, наоборот,
А. Да, здесь будет B. Все. По сути, да, мы таким образом можем выкинуть вообще задаром одну
переменную. Смотрим, A вложено в B. Это у нас упростится в A, это у нас упростится в B,
это у нас упростится в A. А что такое, если A вложено в B, а без B? Пустое множество. Да. А пустое
множество до карты на что-то, это пустое множество. Поэтому, по сути, в данном случае мы сбавляемся от
третьего условия. Поехали, смотрим. Есть ли у нас вложение с права налево? Вот здесь вот A,
а здесь C или D. Давайте посмотрим, что если мы лежим в C или D, то есть два варианта. Мы можем
лежать в D без C, тогда мы войдем сюда. Но у нас есть свойство, что C или D, это D без C,
объединить с C. Либо второй вариант у нас, тогда мы попадем в C, то есть у нас второй элемент будет
лежать в C. Но если мы лежим в C, а A вложено в B, то эти пары содержатся здесь. Хорошо. То есть все пары
отсюда, они будут лежать в правом множестве. Смотрим второй случай. A или B? Это B. Точнее,
вот B и C и D. Но если эти пары из пересечения C и D, то они точно лежат в C, а значит они будут
вложены у тебя. То есть множество слева, оно содержится в множестве справа. Смотрим в обратную
сторону, что творится. В обратную сторону у нас творится следующее. Вот здесь вот A и D без C.
Ну да, вот здесь мы тривиально вложились. Все. Теперь нам нужно вложить второе множество.
А второе множество, если мы возьмем элемент B и C, такое, что если это будет B без A, это первое,
а второе будет C без D, то что? B без A, значит, единственное, где оно может держаться,
это вот только тут. Тут его точно не будет. Но здесь C пересечение с D, а мы взяли то,
что не лежит в этом пересечение. Значит, у нас здесь не гарантируется выполнение. Есть какое-то
множество, которое лежит справа, но не лежит слева. Все. Плохо. Смотрим второй случай. Да,
еще сразу скажу, что могло показаться так, что у нас есть вот 4 условия, даже так 12 штук,
и нужно будет проверять все 12. Ну, конечно же, нет. Нам нужно проверить первые 4. Как нам,
зная первые 4, ответить на вот последние 4? Сейчас мы рассматриваем без каких-то дополнительных
условий на второе множество. Мы рассматриваем в общем случае. Соответственно, если это будет
выполнено для того, что слева, то справа здесь... Сейчас. В общем, если мы докажем для, например,
C и D, то везде, где здесь C вложено в D, для всех этих случаев это тоже будет выполнено. С другой
же стороны, когда или, мы объединяем. Поэтому, если мы нашли контр-пример в каком-то здесь,
мы сразу нашли контр-пример там, где есть это условие справа. Вот, например, сейчас,
здесь мы нашли контр-пример, и здесь нашли мы контр-пример. Все. А у меня повисла демонстрация
экрана, что ли? Либо у меня на таком повис. Все. Да, мы нашли вот два контр-примера, уже все.
Пошли дальше. B вложено в A. Если B вложено в A, мы просто поменяем буковку B на буковку A. Здесь
буковка B вложена в A. A без B. Ну, A без B это какое-то лорусто может быть. Поехали смотреть,
что творится. Здесь B, C или D. Первый случай это лежит C. Тогда мы здесь оказались. Второй случай
это C или D. Это C, а второй случай это D без C. Мы оказались здесь. Все. Мы вложили первые пары.
Вторые пары A или B. Это C и D. Так как вот у нас устроено A, внутри него B. У нас первый случай это,
что A без B, тогда пара тут тривиально выполнена. Второй случай это будет лорусто B содержать,
пары C, D. Но они будут вложены туда. Все. Получили вложение с левого направо. В обратную сторону
смотрим. B, C войдет сюда. Здесь это сюда. A без B войдет сюда. Справа-налево вообще просто.
Поэтому здесь плюс. А если здесь плюс, то у нас плюс здесь-здесь.
Да, все хорошо пока. Дальше смотрим. C вложено в D. Для этого стираем все эти записи. C вложено в D.
Тогда объединение это D, пересечение это C. D без C. Это что-то имеющее смысл? Это C.
О, смотрите. Здесь B, а здесь A без B. И здесь C. То есть здесь A или B и C. Вот как раз точно все то,
что нам нужно. Но здесь B, а здесь D без C. Поэтому надеюсь, что это вошло. Получили вложение
вот справа-налево. Смотрим в обратную сторону. В обратную сторону у нас пересечение. У нас
пересечение. Пересечение это может быть D. Объединение это D. Вот D есть C. Это может
быть D без C. Тогда мы войдем вот сюда. А в другом случае это может быть само C. Но это же под множество
B. Значит они войдут вот сюда. Все. Это первая часть будет вложена вправо. Второе условие A или B и C.
Но опять же два варианта. Это либо A без B, либо B. Вот так вот разбилось у нас. Поэтому в другую
сторону тоже есть вложение, значит есть равенство. C и D. Тогда там, где оба выполнены, их или тоже
будет выполнено. B вложено A, C вложено в D. Супер. Хорошо. И последний случай, который нам осталось
рассмотреть. Это D вложено в C. D вложено в C, значит здесь C, здесь D. D вложено в C. Я избавлюсь
условия. Смотрим. Слева направо. A пересечь с B в C. Вот оно войдет сюда. Потому что это под множество
B. A или B и D. Есть два варианта. Либо это A без B, оно войдет сюда. Либо это B. Но так как D это
под множество C, то оно войдет вот сюда. Все. Левые пары есть в правом множестве. В обратную сторону
смотрим. A без B, D вот сюда. Войдет легко, потому что под множество пересечения этого условия нет.
Осталось условие B без C. Хорошо. У нас C более мощный, поэтому если возьмем C без D, то сюда
пары эти не уйдут. Они могут войти только сюда. Но здесь B пересечь с A. Давайте снова возьмем вот
это вот множество. И оказывается, что здесь вот оно присутствует, а здесь его нет. Поэтому нету и,
соответственно, здесь это вот так. Все. Не могли бы еще раз пробоиться, объяснить почему оно не вножено?
Давай рассмотрим вот под множество вот этих вот пар, а именно которые слева у нас это B без A,
а справа C без D. Первое B без R, а значит они не могут войти вот сюда. Значит единственное,
куда они могут войти, это сюда. Но с другой стороны у нас здесь D, а здесь мы специально исключили D,
поэтому здесь содержаться не может. Значит место им слева нигде они нашлись, они не могли ниоткуда
прийти. Поэтому они будут здесь, вот здесь. Все. Ну можно было заметить, что потратили мы на
решение этого добра минут 15. Можно вопрос, почему в втором столбце в последней строчке у нас минус?
Потому что соли.
То есть или у нас когда оба условия выполняются, а и хотя бы одна. Да, потому что или оно расширяет
класс этих множеств, и соответственно теперь нам нужно будет, сейчас скажу, или это по сути
расширяет это объединение. Если у нас есть контр-пример в каком-то из частей, то контр-пример
найдется везде. А и это значит что? Это мы возьмем какое-то под множество, но если во всем множестве
выполнено, значит взяв его какое-то под множество, а и это пересечение, то есть под множество, то для него
тоже будет выполнено. Поэтому надо достаточно проверить только левую. А теперь рассказываю метод,
который решает это за две секунды. Отчасти мы его использовали, когда говорили, но только мы его
использовали не особо рационально. У нас есть замечательные свойства. Сейчас скажу. Давайте даже
так. Метод называется разбиение на, так скажем, атомарные кусочки неделимые. Вот мы не можем
больше потерять. Какие у нас есть неделимые? Давайте рассмотрим это множество. У нас неделимых кусочков...
Ладно, бог с ним. У нас есть из неделимых кусочков, у нас есть А без В, у нас есть А пересечение с В,
есть В без А. Тогда если мы сделаем, воспользуемся еще одним свойством, что объединение В до картового
С есть А до картового С, объединить В до картового С, то если мы возьмем, разобьем каждую из частей
здесь, на вот эти вот атомарные кусочки, дальше воспользуемся вот этим вот свойством, называем
дистрибутивностью, то мы расплодим количество систем, но при этом у нас появится много перекрытий,
которые есть и там, и там, и мы их сразу отметем. И за счет этого у нас останется проверять куда
меньше. Причем сейчас настолько меньше, что удивитесь. Поехали. Давайте разбивать лево.
Нам нужно учиться разбивать объединение на атомарные. Вот, что такое объединение? Вот мы
разбили объединение на атомарные кусочки. То есть левая часть нам подарит что? А пересечет
с Б здесь С без Д, А пересечет с Б здесь С и Д, А пересечет с Б с Д без С. Дальше и аналогичный
триггер А, Б. Бум. А без Б, А пересечет с Б, Б без А, здесь С, Д, С, Д, С, Д. Что бы было удобнее читать,
везде, где разности, у нас порядок не важен, поэтому давайте писать там по алфавиту. Налично
У нас Б и С. Уф. Б и С неприятные. У нас будет Б без С, Б, С. Я извиняюсь. Б без А,
А, Б. Здесь будет С без Д, С, Д. Дальше Б без А, А без А пересечь, здесь С пересечь, здесь С убрать. Дальше, а остальные два
условия они так уже атомарны. А и Б. Д без С. А симметрическая разность. Ой, просто разность. И С и Д.
Все. Мы расписали теперь все в элементарных кусочках, все возможные пары. Теперь давайте
зачеркивать все эти пары, которые есть и там, и там. Вот, например, у меня есть пересечение, вот двойное.
Ой, у меня даже здесь два таких. Теперь у меня А пересечь Б есть и С пересечь, и С без Д. Зачеркну.
А пересечь Б, Д без С. Вот у меня есть. А без Б, С пересечь Д. Жух-жух. Б без А объединение этого добра.
Вот, смотрите, что мы заметили. Мы заметили так, что вообще лево вложено вправо. И единственное
отличие этих множеств, вот вот это вот плохом кусочке элементарном, атомарном, давайте назвать
элементарным, чтобы нам потом не было проблем. Вот этот кусочек. И теперь, когда он у нас будет
тождественно наравны, когда этот кусочек обратится в ноль, а в какие моменты он обратится в ноль,
когда одна из частей их будет пустым множеством, а чтобы она стала пустым множеством, она нужна
либо чтобы было Б под множеством А, либо С под множеством Д. Всё. На этом моменте мы решили
задачу. Дальше просто осталось выбрать условия, где хотя бы одно из этих условий присутствует.
Слева выписан А без Б. Слева не может быть такого множества.
Слева не может быть такого множества. И кстати, то множество, которое мы вот заметили,
контрпример, неспроста вот мы его постоянно его встречали, когда проверяли. Вот оно сплю.
Поэтому, во-первых, когда у вас такие ужасные квадратные, эти, декартовые произведения имеют
смысл расписать вот эти элементарные кусочки. И дальше что мы делать? Дальше смотреть,
вычеркнуть общие и смотреть, когда вот те или иные обращаются в ноль. Или когда они оба равны.
Ой, когда они оба присутствуют. Так что, на этом… А можно ли ещё раз как неделимые части разбили?
А, рассказывай. В общем, откуда вообще берутся неделимые вот эти тамарные части? Вспомним,
что мы когда здесь делали. Мы вот эти вот частички, по сути, задавали так или иначе,
стартаной болевой таблицы. Так вот, здесь корни все те же. То есть, мы берём, выделяем кусочки,
вот с диаграммы L равенны, например. Мы можем выделить, сколько? Два в степени N, где N количество
множество этих тамарных кусочков. Дальше у нас есть теоретика множественной операции. Объединение
пересечения разности. Разность, она нам даст уже элементарный кусочек. Пересечение тоже. А вот
объединение само по себе состоит из трёх таких кусочков. Вот. Равно как множество, например,
A это A без B, объединить с A пересечь с B. Вот элементарные кусочки. Теперь мы берём вот это всё
добро, записываем вместо самих множеств. А дальше мы используем просто правила дистрибутивности,
которая гласит, что A объединить с B до карты A на C, есть A объединить с B до карты A на C. То есть,
мы теперь вот это объединение взяли, раскрыли и получили просто дополнительных строчек в нашей
системе. Здесь у меня было пересечение элементарных кусочек, справа будет 3 элементарных. Ну вот я
записал их все 3. Пересечь с одной разностью, с другой разностью, с пересечением. Аналогично
и с точностью до наоборот случись с C и D. Всё. Получил ли я вытаблицу? Справа у меня были B. B это
объединение B без A и пересечение B и A. Вот оно. C это объединение пересечения C и D и C без D.
Получается тут два варианта, тут два варианта. 2 на 2 равно 4. Соответственно, беру сервионную
сложность и совпособно комбинирую. Получил вот 4 комбинации. И осталось ещё два условия, но эти
кусочки уже сами по себе отомарны, поэтому их просто дописал. А дальше, ну, только вычёркивание
одинаковых кусочков. Всё. Скажите, пожалуйста, как ещё раз называется тундром? А, это называется полином
шигалкера. Это значит будет на следующей лекции по мат-логике. Это буквально общая тема,
которая только-только. Можно последний раз по какому принципу вычёркивали эти отомарные кусочки?
Я вычёркивал, которые есть и справа, и слева. Вот прям можем ещё раз повторить.
Просто это нормально, что они с разными кусочками в парах стоят? Они же из декартового произведения
образуются с разными кусками. Я что-то не понимаю. Ну, смотри, у нас отомарный кусочек будет тогда,
когда обе части отомарны. Ну, вот мы понособирали отомарные кусочки друг на друга из двух ножей.
Перекомбинировали. Где-то мы раскрывали только одну часть, где-то мы обе части раскрывали.
Можно ещё раз показать в таблице снизу, где развернута A или B, точнее C и D. Слева у нас
было уже отомарный A пересечь с B. Объединение это три кусочка, поэтому я беру их сюда
просто раз-два-три. Три дубли. Супер. После того, как я вот всё разбил на элементарные кусочки,
я беру и вычёркиваю те, которые есть слева и справа, потому что они всегда есть и там, и там,
они всегда... На этих кусочках эти множества всегда совпадают тому, что есть тождественность,
поэтому они на решение задачи не влияют. Вот у меня есть здесь пересечение обоих и здесь. Дальше
у меня есть слева, например, A пересечь B, C без D. Вот это вот всё я убрал. Они есть там и там,
они не влияют на хоть решение. У меня есть пересечение A и B и D без C. Убрал. Есть A без B,
пересечение. Убрал. B без A и пересечение. Убрал. Всё. Слева я все кусочки убрал,
значит, левое множество всегда свяжется с правым. Когда у нас правое множество будет совпадать
с левым? Когда вот из вишек будет пустым? Соответственно, данное множество будет пустым,
когда вот B под множеством A или C под множеством D. Хотя бы одно из этих совех есть. Всё. На этом
задача решилась. В целом теперь просто у кого вопрос есть задавайте. Извините, а на матлоге
будет три задачи? Да. А вот четвертая и пятая в листочке это что? Это домашка. Какая будет
домашка? Она будет очень похожа на те, которые написаны здесь. А где можно найти? Это кидали
в чате телеграмма. Там будет ссылочка. Вот последняя, которая там была. Тренировочные варианты
контрольным по КТЧ. Просто первая открывайте, вот она есть. Ну, то есть, а домашку надо будет потом
в письменном виде сдавать? Да, самому семинаристу. Но это лучше у него точно. Может быть,
усну придётся, если особо не повезло. Всё, давайте тогда вопрос ещё есть.
Ну, если нет, тогда всё. Домашка постиконтрольная получается? Создавать постиконтрольный или на
следующем семинаре эту домашку сдать? Нет. Смотрите, вот это то, что домашку тут написали,
это не та домашка, которая у вас будет. У вас будет немножко другая домашка. По постиконтрольной
будет. Да, там вышли вздоровочные файлы с домашкой, скажут когда дедлайн, вот это вот всё. Всё,
понял. Пока домашкинка нет. Это просто примерный вид домашки. Какой будет реальный? Он будет не
перестекаться с отой вообще. Там, ну, либо рассказывать, как решать домашку. Какие-то
здесь методы, но я не смогу сказать, какие здесь есть методы. Там, где есть, я постараюсь рассказать.
Тут метод пристану взглядом. Скажите про пленок Жигалкина. Мы когда строим эту таблицу
естественности, нам важно в каком порядке мы записываем 0 единицы для каждого элемента?
Смотри, у нас вот мы получили таблицу естественности. Таблица естественности,
понятно как получается, она единственным образом может построить. Да. Всё. А дальше,
вот тебя есть столбец. Вот возьми этот столбец, транспонируй и получишь строку. Берёшь,
прям пишешь 0, 0, 0, 0, вот прям по очереди писаешь. Вроде транспонирование вам уже
должно было рассказать. Да. Супер. Просто я не очень понимаю, вот я пыталась построить для
обычного объединения, и у меня не получается, если, ну, то есть... Давай построим сейчас. У нас
объединение 0, 0, 0, 1, 1, 0 или 0, 1. Объединение будет иметь вот такую таблицу естественности. Тогда
что мы делаем? Мы транспонируем строку значений функции, столбец получаем, строку, вот такую вот.
Теперь мы дырём соседние к сорям и получаем новую строку. 0 к сору 1 это 1, здесь одинаково,
поэтому 0, 0. Аналогично повторяем ещё раз, 1, 0, 0, получаем 1. Всё. Получили треугольниче.
Дальше, теперь смотрим какие здесь у нас... А и Б. Какие здесь у нас будут одна члены. 1,
это здесь единичка написана, поэтому это и Б, здесь единичка это А, здесь единичка, поэтому это и Б.
То есть смысл, какие здесь будут многочлены? Везде, кроме строки 0, просто пишем все те буквы,
до которых в данной строке есть единицы, там, где все нули, пишем единицу. Всё. Теперь просто
берём, собираем к сорами. Да, но если мы, например, таблица естественности, сначала будем писать
вот 1, 1, а, например, вот этот вариант, что у нас А и Б, 0, будет самым последним. А, я понял. Я вот в этом смысле.
Всё. Нет, таблица естественности, она единственным образом пишется. Она пишется, что вот, по сути,
у тебя начинается 0, 0, 0, а дальше ты начинаешь в двоичной системе прибавлять единицу, и только так.
Понятно, спасибо. То есть это, ну, в информате, когда переводили, вот, из одной системы
из десятичной в двоичную, четверичную, восьмиричную, шестнадцатиличную, вот, там ровно только так идут единицы.
Если вам рассказывали про порядки, но вряд ли, у вас уже были порядки много, это еще нет?
Нет. Тогда я не смогу рассказать, почему еще так.
Просто считайте, что от нуля начнем прибавлять единицу бинарную.
Еще удобный способ, как быстро писать таблицу истинности. В общем, у нас, там, скорее всего,
у вас будет либо три, либо две переменные. Если у вас три переменные, четыре раза ноль, потом два раза ноль,
потом две единицы, а потом просто один раз ноль, один раз единица. То есть каждый раз мы пишем два
в степени n, где n количество от переменных сверху, от слева до края, и так вот их чередует.
Так она заполняется быстро и легко.
Можете пояснить, пожалуйста, почему в первой строке второго столбца минус, а не плюс.
В второй строке... Сейчас, в первой строке второго столбца минус. Ну, смотри. Пример, когда...
Пример, когда... Сейчас скажу. Смотри, или. Или подразумевает того, что эту
условия может быть выполнена, может быть, не выполнена. Вот давай я сотру. Ну, или я хочу без или.
Я возьму только такое множество. На нем мне не выполнено слева, поэтому здесь тоже будет не выполнено.
То есть или говорит нам о том, что я могу добавить еще какие-то дополнительные пары,
но старые-то останутся. Для старого у меня неверно, потому что есть вот такой вот...
Контракт-пример. Вот почему неверно в втором столбце. Супер. Еще может быть какие-то вопросы.
А что если попадет единица в XOR? А если попадет единица в XOR, то все будет плохо,
потому что единица, как я говорил, это множество универсум. А нигде вам не дано использовать
множество универсум. Поэтому ваши задачи будут записаны так. Ваши задачи будут таковы, что единица не
попадется. Ну, то есть в худшем случае, если у вас попадается единица, значит у вас начинает
быть закрашенным вот этот вот ужас. Вот такое попадание единицы. А если попался этот ужас,
ну он как может быть получен? Он может быть получен только, если у вас есть отрицание,
то есть дополнение операции без С. Операцию без С как делать на вот здесь? Это один XOR
какой-то множестве. Это есть вот такая операция отрицания. Все. То есть если попала единица,
то значит у вас есть дополнение, а значит, наверное, даже все еще проще будет, чем без него.
Потому что без него, там, где мы делали, здесь мы, да, нам приходилось вот делать это отрицание
импликации. Это как-то сворачивать не очень-то ядно, а там даже будет еще проще.
А скажите тогда, пожалуйста, почему в полиноме Жиговского у нас ставится один,
где OP переменная равна нулю? Зачем там единица? Почему не ноль?
В полином Жигалкина. Почему там единица, а не ноль? Потому что ноль, XOR, что-либо,
это есть что-либо. Это полином. Прям как мы начали, вот у тебя в числах, когда были вот
многочлены какой-то степени, плюс ноль, ну ты просто получишь ноль. А здесь, поэтому,
чтобы что-то добавить, ну только единицу можно. И это, если вот такой чистый рукомахательский
способ. Почему так именно, точки зрения будевой логики, на это вас, на это лучше подождать лекции,
там это все должно быть, либо это будет вообще вопрос Домашки. Не знаю, пока как в этом году будет.
Возможно, это вам всем придется доказывать, почему там единица. Понятно, спасибо. По-моему,
даже так и будет. Вопрос. Вот в последнем номере мы же вот нашли, что если у нас B это подможство A,
то это пустое множество, ну B. И все хорошо, да. Да. Ну почему тогда, если вот в таблице нашей,
там B принадлежит A или D, ну в смысле B это подможство A или D это подможство C,
почему там минус? А давай рассмотрим тот случай, когда B не является подможством A,
а D является подможством C. Тогда у нас это условие выполнено, но при этом у нас станет пусто.
То есть прикол в том, что да, это то, что вы просто говорили. Да, как бы не казалось, что или должно
наоборот все лучше, или наоборот все испортить, а и сохранить. Ну тогда давайте все, что ли.
Да не за что. Записи я выложу туда, где решение прошлых лет. Всем спасибо, всем пока.
