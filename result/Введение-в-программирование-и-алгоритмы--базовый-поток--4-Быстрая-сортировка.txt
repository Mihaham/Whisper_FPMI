И сегодня наша тема — это быстрая сортировка.
Быстрая сортировка. Скорее всего, кто-то из вас уже слышал эти слова,
может быть, даже что-то такое писал, может быть, видел, но не представляет, как это работает точно
и почему это работает. Вот поэтому сегодня мы обсудим полностью и посвятим всю лекцию именно
быстрой сортировки и оценки этого алгоритма. Как он происходит, какие у него есть модификации,
что мы можем сделать. Вот. И этот алгоритм быстрой сортировки вы будете писать, но не в этом
контесте, а в следующем. Вот. В этом у вас будет все чуть-чуть полегче. Вот. А это то, что касается вообще
того, что вас ожидает впереди. У вас еще ждет задачи по алгоритмам, но их будет много потом.
Пока что их немного. Быстрая сортировка. Кто из вас знает, что там самое главное? Выбрать
барьерный элемент. А как он по-английски называется обычно? Пивот. Вот. Кто представляет,
что такое пивот? Пивот — один из самых главных элементов, который мы должны всегда выбирать и
что-то с ним делать. Кто представляет, что такое пивот? Хорошо. Вот сейчас некоторые люди опаздывают
периодически. И вот. Так получилось. Вот. И до этого вы рассаживались. Вот девушка. Нет. А в очках
с рыжими волосами. Сложно. Ну не с рыжими, но сложно. А как вас зовут? Вот вы, да, да, да. Как
вас зовут? Я не слышу. Так. Ладно, хорошо. Рядом сидит Миша. Я хотя бы это знаю. Вот. Окей.
А раз уж я не услышал, то буду говорить, что у нас Миша будет опорным элементом того ряда. Когда
вы садились на ряд, вот для того, чтобы пропустить Мишу, вам бы всем по-хорошему бы встать и пропустить
его на его место. И он является вот таким вот опорным элементом — тиранией Миши такая некоторая.
Вот он приходит, и вам приходится вставать, чтобы он туда прошел. Ровно так же вам необходимо ставить
какой-то конкретный элемент на его место и рекурсивно убирать отрезки. Вот молодой человек рядом,
который сидит. Как вас зовут? А? Рядом с Мишей. Вы на меня, да. Ваня? Вот. А когда Миша сел за свое
место, все усели, все хорошо. Но вот Ваня решил выйти куда-то. И включилась тирания Вани, но уже на
другом маленьком отрезке. Вот таком вот подотрезке правой части вообще не нравится, видимо, там жить и там
находиться, потому что постоянно то вставать надо, то садиться. И Ваня выходит, а потом обратно заходит
и опять на свое место. Таким образом мы усадили сначала Мишу, а после этого и сел Ваня туда,
куда он захотел и куда ему необходимо. Именно так работает по факту наша быстрая сортировка.
Быстрая сортировка делает следующее. Первым действием выбирается так называемый пивот.
Выбирается опорный элемент.
Вторым действием. Что происходит вокруг этого опорного элемента? Мы ищем то место, куда должен он встать.
Причем так, чтобы слева от него были элементы все меньше него, справа от него все больше него,
ну либо больше, либо равны. То есть он занимает свое место в этом массиве где-то конкретно,
посерединке, может быть чуть дальше, может быть чуть ближе, может быть в самом начале.
Но он все равно занимает свое место, поэтому нам необходимо определить его место.
Миша с Ваней точно определили свои места сразу же. Хорошо, мы определили место пивота, причем оно должно быть следующее.
Все элементы левее меньше пивота.
Все элементы правее больше пивота.
Больше нашего опорного элемента. Вот, таким образом мы установили место, где находится данный элемент.
Теперь давайте те отрезки, которые у нас остались, которые левее меньше пивота и которые правее больше пивота,
запустим для них рекурсивно функцию, аналогичную тому же, что и здесь. То есть мы просто повторим ровно то, что мы хотели.
Ровно то, что мы хотели.
То есть мы повторяем наш алгоритм для левой и правой частей.
Севдо кодом. Это выглядит достаточно просто, примерно так. Давайте на ту доску.
Квик-сорт. Это рекурсивная функция. Это первый момент, который надо понять. Второе. Квик-сорт.
Что принимает себя? Он принимает массив данных, левую и правую границу того, что он пытается отсортировать.
То есть первый элемент, который мы выбраем, он будет отвечать за весь массив, дальше мы будем отвечать за части массива,
после этого еще за меньшей части. И рекурсивно будем постоянно это делать.
Поэтому, когда передается массив, левая и правая граница.
Когда мы с вами это передаем, то все хорошо. Какое условие остановки рекурсии?
Как вы думаете, какое условие остановки рекурсии?
Должна остановиться? Наверное, да.
Когда длина равны единице?
Можно сказать, что пока мы будем делать рекурсию, то пока у нас левая меньше правая.
То есть, если у нас левая граница больше либо равна, чем правая, если левая и правая совпадают,
это один элемент как раз. Если левая граница больше либо равна правой, то
я буду немного вставлять в псевдокод плюсовых вещей, то мы просто заканчиваем.
Иначе мы с вами должны выбрать наш элемент и распределить все элементы левее и правее нашего пивота.
И вот это все делает нам следующий пивот. Это все называется partition, то есть расстановка наших элементов.
Поэтому мы здесь запускаем с вами partition.
Зачем противное? Ну тут return, он так и закончит.
Но partition у нас будет возвращать как раз таки сам пивот.
Пивот это тот элемент, относительно которого мы пытаемся что-то делать, его местоположение.
После этого мы должны
рекурсивно от чего-то что-то вызвать. А, ну давайте еще будем кого-нибудь узнавать и спрашивать.
Вот вы девушки, вот вы общаетесь как раз. Давайте.
От чего нужно вызвать рекурсию? Одна скажет одно, другая другое как раз.
От чего?
От левой стороны. Левая сторона от чему равна? Ну массив А также передается. Левая сторона какая?
Какие у нее границы?
От левой до пивота.
А теперь скажите мне, что здесь не так?
От пивота минус один до пивота плюс один, потому что мы уже наш пивот поставили на нужное место.
Поэтому минус один и плюс один. То есть у нас границы сдвигаются, мы один элемент поставили на нужное ему место.
Вот, а теперь нам нужно понять, а что делать вообще с этим partition, что это такое и для чего он нам нужен.
Давайте попробуем его и написать.
Смотрите, в качестве опорного элемента можно выбирать любой элемент из вашего массива.
Любой. Но я буду просто выбирать первый.
Просто вот первый элемент на этой границе и будет моим опорным элементом.
И с помощью него я и буду сортировать.
Пока что мы напишем такой самый обычный, возможно тривиальный алгоритм быстрой сортировки.
Давайте представим наш массив.
Первый элемент, это как раз таки тот самый пивот, который у нас будет необходим.
А что будет идти дальше? Вот как раз молодой человек, вот вы засыпаете.
Да, как будет распределен массив и что у нас будет происходить?
Вот мы выбрали пивот и первый элемент.
Ну, для начала левая и правая границы определены.
Так, как нам нужно раскидать массив?
И заметьте, что вот эта правая граница не обязательно входит во весь массив.
Вы можете лишь часть взять и отсортировать.
Хорошо.
Смотрите, еще раз, мы должны разделить наш массив на две части.
Левая часть меньше пивота, правая больше пивота.
Тогда мы наш пивот должны поставить как раз таки вот сюда.
Вот в это место мы поставим пивот, поменяем его на это место и тогда он определит свое местоположение.
Если встречается элемент равный пивоту, мы можем определить его и в правую, и в левую часть.
Пока что.
Пока для нас это без разницы.
Он может оказаться чисто в начале или чисто в конце.
У нас одна часть может быть вообще пустой, а одна часть может быть полностью.
Да, это возможно.
Еще раз, мы пивот определяем его место.
Если элементов, например, у меньших пивота нет, мы останавливаемся на том, что он здесь и остается.
Если вдруг у нас все наоборот больше пивота.
Ой, все меньше пивота, тогда я его беру и ставлю в конец этого отрезка.
То есть смотрите, мы пытаемся найти его место.
Ну, примерно так и будет.
Вот.
То есть смотрите, давайте опишем наш partition.
У него есть левые и правые границы.
Я сказал, что мы выбираем опорным элементом наш первый элемент массива.
Пусть это значение, которое там хранится, равно пивот-вэлью.
Это было просто пояснение, что это массив.
Вы будете вообще передавать его по указателю.
Так.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вы будете вообще передавать его по указателю.
Ну, как бы все.
Вот.
После этого мы должны с вами пойти по всем элементам и найти, грубо говоря, место нашего пивота.
Как это делать?
Давайте как только встретим элемент, ну, предположим...
Давайте так.
Пусть будет вот такой вот массив.
Давайте так.
Вот.
А что мы будем пытаться здесь делать?
Мы говорим о том, что пусть у нас есть, так сказать, место, куда нам необходимо вставить пивот.
Первоначально это место так же указывает на самое начало.
Там в начале.
Ну, там.
Pivot point.
А как только мы встретили элемент, который...
Вот этот меньше элемент, а этот больше элемент уже нашего пивота.
Правильно?
Что нам необходимо в этом случае сделать?
Мы говорим о том, что если элемент меньше, мы двигаем наше место, куда должен стать пивот.
Если элемент меньше, то мы его не двигаем.
Больше, да, извините.
Вот.
И тогда мы будем постоянно свопать наш пивот с какими-то элементами, которые меньше него.
Постоянно свопать между собой.
И тогда мы получим с вами необходимое нам место.
То есть, что я подразумеваю?
Вот у меня пять, вот один.
Я их...
Элемент один меньше.
Я их поменял местами.
Так?
После этого я прохожусь эти элементы больше моего пивота.
Я их не трогаю.
Но я встречаю элемент меньше.
Тогда...
Я получу вот такую последовательность.
Но мне останется написать свой пивот в нужное мне место.
Для того, чтобы это произошло, мне необходимо поменять вот эти места.
Поменять между собой вот эти элементы.
Первоначальный пивот-поинт в этом случае был ноль.
Здесь уже один, здесь уже два.
То есть, это индекс пивота.
Таким образом, в конце я должен просто их свопнуть еще раз между собой.
И тогда я получу, что относительно пивота, во-первых, все лежит слева.
Все, что слева, оно меньше.
Все, что справа, оно больше.
Давайте допишем это.
Мы идем от левой нашей границы плюс 1.
То есть, кроме элемента пивота, до самой правой нашей границы.
М Animation такая же, не это?
Этоblic yeux.
Это прин travailler.
Ну-
что мы говорим если а у этого и от этого индекса меньше значение пивота пивот
вал вэлью правильно да давайте пример да пивот поинт верно спасибо
пивот поинт левая граница первоначально он стоит как будто бы на своем месте
если это так и тот элемент меньше тогда
я увеличиваю свой пивот поинт и меняю какие элементы между собой
ну а от этого индекса и а пивот поинт
почему
Так, первый. Правильно. Да, правильно.
Но чтобы здесь сильно много не писать. Хотя, стойте, подождите. Сейчас left. Да,
я понял. Можно. Да. Это я начал съезжать немножко. Вот, но после того, как у нас
все это произойдет, нам необходимо с вами еще вот после этого фора взять и поменять.
А от каких элементов? От pivot point. И что еще раз?
Да. Вот. Именно поэтому я и писал в обратном порядке. Я сейчас объясню. Смотрите,
когда мы нашли элемент меньше, то есть, ну вы сказали, я сделал, как хотели. А вот,
но только теперь почему-то не работает. Смотрите, у нас есть с вами элемент pivot, вот этот. Да. Я
хочу в конце взять и поменять его вот с этим. Он меньше, потому как я разделил. Я хочу, чтобы
я в конце знал, где лежит мой pivot. А мой pivot лежит влево. Скажите, если я вот этот вот pivot
point несчастный, который мы таскаем туда-сюда. Если я этот pivot point сделаю на единицу и буду
менять даже первый с первым элементом или первый там с пятым, который меньше, то ли у нас будет
хорошо работать? Да, все. Почему? Потому что вот здесь появится элемент, который меньше нашего pivot.
А если он меньше, то в конце концов я могу их просто между собой потом в конце поменять,
потому что у меня pivot point стал left plus 1. И тогда слева от него будет стоять меньше элементы,
справа больше, а здесь сам pivot. Понятно или непонятно? Еще раз. Смотрите, я вот эту часть
просто не трогаю. Я ее резервирую под свой pivot пока. Мне необходимо пройтись по вот этим вот
элементам. Я их между собой раскидываю относительно пивота. Самые маленькие кидаю сюда,
которые меньше пивота. Самые большие ничего с ними не делают. Они стоят-стоят. Вот, как только нашел
маленький элемент, у меня pivot point сначала стоял на left. Я делаю plus-plus, показываю на первый. Самый
маленький элемент, который меньше пивота, ну один из маленьких, я кидаю на первое место, вот сюда.
Давайте это сделаем на примере. Понятно, что я примером вас запутал. Так, давайте.
Можно. Я сегодня расскажу, какие есть еще способы.
На самом деле, кстати, быструю сортировку, ну так, небольшая новостная справка.
Быстрая сортировка, если вы где-то найдете название сортировка хара, это ровно она же. Он
придумал ее в стенах МГУ, если что. Он приехал сюда на конференцию, и вот придумал в 1960-м году,
и все до сих пор ее и пользуются. И она действительно одна из самых быстрых. Давайте еще раз на примере.
Пусть у меня есть такой вот массив. Вот мой pivot. Этот pivot я начинаю сравнивать со всеми
элементами. Pivot pointer в начале ноль. Давайте его. Я его назову PP. Хорошо? Вот. В начале он ноль.
Как только мы встретим единицу, он сначала станет единица, только потом поменяет единицу
саму собой. Ну ничего страшного, она осталась на месте. Дальше мы смотрим. 6 больше, 8 больше,
9 больше, 11 больше. Пойнтер наш не двигаем. 3 оказалось меньше. Pivot pointer равен одному. Я
прибавляю к нему единицу, получаю 2, и поэтому я тройку меняю со вторым элементом. То есть на
вот этот момент у меня массив 5, 1, 3, 8, 9, 11, 2, 6. А, да, спасибо. 6, 2, да. Здесь точно правильно.
Вот. После этого мы идем к двойке и видим, что двойка опять меньше. У меня pivot pointer
становится равным 3. И в этом случае мы берем и меняемся.
То есть смотрите, перед тем как, например, тот же Миша решил сесть, он всех подвинул,
выбрал себе самое хорошее место, вот это, и только потом туда уселся. Поэтому в самом
конце мы меняем между собой вот эти вот два элементика. Получаем 2, 1, 3, 5, 9, 11, 6 и 8. Понятно?
То есть вот этот swap в конце от pivot pointer и от left. У меня же pivot pointer 3. То есть последний
минимальный элемент, который мы слева вставили, это был вот на индексе 3. Все, отлично. На индексе
3. Значит, если я поменяю с pivot, у меня не изменится здесь порядок, потому что слева все и так меньше
pivot. Я останавливаюсь. Все, получаю вот такой вот массив. Вот мой pivot встал на нужное мне место.
Вернуть мы должны pivot pointer. Да, все правильно.
Таким образом, мы взяли и отсортируем наш массив. Потому что после этого мы рекурсивно
вызываем от вот этой части и от вот этой части. Здесь pivot будет 2, здесь pivot будет 9. Относительно
них сортируем каким-то образом. Получим примерно следующее, что после вызова рекурсии здесь у нас
будет 1, 2, 3. Здесь у нас после рекурсии будет 6, 6, 9, 11. Останется здесь еще до
рекурсии доделать, потому что мы не дойдем до вот этого условия иначе. Здесь мы уже дойдем.
Вот так работает quicksort. Непонятно? Понятно. Тогда давайте с вами говорить о том,
насколько он работает. Но давайте усно с вами решим наихудший случай. Наихудший случай здесь,
представьте, что он должен сделать так, что какая-то из тестей полная, а другая пустая. То есть все
элементы, которые были здесь, они есть отсортированные относительно pivot. Если я каждый раз буду
выбирать слева, то у меня все плохо, потому что, к примеру, если у меня будет все больше pivot,
я буду их свопать туда, свопать, свопать, свопать, свопать бесконечно много. И это плохо. То есть для того,
чтобы у меня это не сработало, мне достаточно взять отсортированный массив. И тогда в этом
случае сначала я возьму здесь так, что у меня n-1 своп будет, потом для другой будет n-2 свопов,
для следующего n-3. Я буду потому что рекурсивно вызывать от вот этих частей, а другая часть пустая.
Когда она пустая, мы там ничего не делаем. И тогда каждый раз, когда я буду вызывать n-1, n-2, n-3 для
всех n-чисел, у нас, к сожалению, с вами будет сортировка работать за n квадрат. Понятно,
почему? Сумма i-1 от 1 до n. Если посчитать, то это будет n на n-1 пополам. Вот n квадрат.
Да, в этом случае. Вот. И тогда у нас все плохо. Как вы думаете, как это можно избежать?
Рандомные элементы. Действительно, есть два способа избежать таких вот багов,
чтобы она не работала просто так за квадрат. Первый способ выбрать пивот рандомно. У нас же
здесь ничего по факту не зависит просто так от пивота. Ну, немножко алгоритм может поменять. Но
все равно мы узнаем место пивота и туда его поставим. Правильно? Ну, здесь чуть-чуть надо
будет переделать. Как это переделать? Сейчас сделаем. Второй способ – это рандомизировать
данные перед тем, как мы начнем писать наш click sort. То есть рандомизировать весь массив.
Если мы рандомизируем весь массив, нам не надо будет вызывать функцию run там n раз,
а просто перемешаем массив между собой. Зачем другой partition? Другой partition – это не важно,
но любой partition, если вы фиксируете пивот, у вас в любом случае есть алгоритм, который сделает
это за n квадрат. Даже когда вы рандомно делаете, с очень маленькой долей вероятности,
но он тоже возможен. Для любого такого массива все возможно. Поэтому, когда вы будете делать
сортировку быструю, возможно такое, что на одном один раз запустите у вас бутель, отправите такой
же код, и он зайдет, так как у вас будут там пограничные случаи. Вот, так что с этим нужно
быть аккуратным. Но давайте сейчас оценим как-то, за сколько работает в среднем случае и почему эта
сортировка так хороша. Пусть у нас есть список из n элементов. А в чем принципиальная разница
будет наихудшего и среднего случая. Наихудшем случае мы говорили о том, что мы передвигаем
элемент, а дальше мы опять делаем n-2 операции. Было до этого n-1, потом n-2 swap. В рандомизированном
случае, когда мы делаем, у нас возможен следующий. То есть мало того, что у нас не факт, что оно встанет
в самый конец, но даже если встанет в самый конец, есть вероятность того, что здесь находится минимальный
элемент. Если их поменяем мы между собой, то в этом случае у нас будет такое, что тот элемент
тоже двигаться не будет больше. Он так и останется. Иногда свопы стоят гораздо дороже проверки,
поэтому здесь число n-версий может измениться благодаря тому, что мы что-то рандомизировали.
Исходя из этого, мы говорим о том, что, видимо, не всегда оно работает за n-2. Для того, чтобы это
оценить, необходимо будет решить рекуррентное соотношение. Сейчас объясню, что это такое,
но как его решать, вам не скажу. Объясню сейчас следующее. Давайте скажем, что так как у нас
пивот встает на любое из места, то пусть он встанет на место p. В этом случае у нас левая
граница, у нас левая часть, от которой мы будем вызывать рекурсивный наш quicksort и правая часть,
от которой будет вызываться quicksort, чему равна по длине? p-1, если мы для всего массива из n
элементов смотрим. И n-p. Что это означает? Представьте, что количество сравнений,
которое было для нашего элемента пивота, равно n-1. Все правильно? Так как мы должны сравнить его
с каждым из этих элементов, этим формам. Если мы это делаем, то мы говорим, что наше рекурсивное
от n, чему равно n-1, плюс, так как у нас все рендомизировано, нам необходимо взять и
все возможные какие-то версии посчитать. Мы просто усредняем все результаты и говорим,
что это усредненный результат от, если мы вызовем слева рекурс, у нас будет p-1, правильно?
p может быть любое от 0 до n-1, поэтому мы можем сказать, что у нас именно вот так вот это считается.
Точнее, давайте сделаем вот так. Что еще раз? Как у нас считается? Все нормально, да? Вот, то есть
мы рекурсивно взяли и сказали, что количество действий для n элементов равно n-1 сравнение,
плюс количество действий, которое будет с левого куска и количество действий,
которое будет с правого куска. Так как нам необходимо посчитать для всех возможных случаях,
мы берем и усредняем это по всем n-вариантам. n-вариантов, потому что p может занимать от 1 до n.
Хорошо. Настроение константа. Мы взяли и усреднили эту сумму. Дальше нам необходимо просто посчитать
здесь кое-что. Ну, смотрите, мы знаем с вами, что a от 1 элемента равно 0 и a от 0 равно 0.
Все у нас там по времени успеем. Давайте замечем следующее, что a от i-1 и a от n-ы пробегают одни
значения. Просто в разном порядке. При i равном единице, а здесь при i равном n, это 0. При i равном
2, это 1. При n-1, это тоже 1. И так далее. Мы можем здесь на это всегда смотреть. И тогда это получается,
что у нас двойная сумма просто. Я изменил порядок. Да, n-1 теперь.
От 0. Получили такую штуку. Но какая-то не очень приятная рекурренту с учетом того,
что здесь у нас a и n. Оно зависит от суммы всех возможных. Правда? Или вам нравится? Вы готовы
анализировать эти штуки? Да, все верно. Смотрите, для того чтобы решить данную рекурренту и вывести
a от n, от зависимости от a, n-1, достаточно посмотреть на вот это и посмотреть на a от n-1.
Ну а здесь мы получим, что это
а. Если мы вычтем друг из друга, то у нас все с вами будет хорошо. Единственное,
что лучше бы добавить n-1? Это на n умножить, это на n-1. И тогда, если мы вычтем, то вот эти
куски друг от друга уйдут. Это понятно? Ну вот. Давайте, чтобы сильно много выкладок каких-то
не было, я вам напишу итоговую штуку. Я думаю, вы дома сможете разобраться с этим. Вот. Как
домножить и что вычесть. Это я понимаю, что математика вас убивает. Тогда, в этом случае мы
получим следующую рекурренту, что? Плюс. Ой, что? Спасибо, n-1.
Если мы там все распишем, мы получим такую рекурренту. А вот следующий шаг, это будет точно вам
упражнение. Как решить рекурренту и вывести зависимость от просто n. Есть два способа. Первый
это разложение в ряды Taylor через производящую функцию. Второй способ это... Понимаю. Второй способ
это немножко диффуров необходимо, поэтому здесь такое... А n делить на n-1? А на n-1. Так, и что тогда?
Так тоже можно. Действительно. Вот. И получается, что если все это взять и посчитать, то в среднем
случае у нас получится... Ну да, вы посмотрите, как решаются рекурренты, типа в общем случае,
попробуйте самостоятельно еще порешать. Вот. А вы получите, что а от n это примерно...
Примерно вот так. Вот это? Еще раз, смотрите. Когда у нас... Ребят, мы сейчас будем еще
модификацию писать quicksort. Вот. Еще раз, смотрите. I and n. I and n. Это количество операций,
количество сравнений, которое мне необходимо сделать для того, чтобы найти partition. Их всегда n-1. У меня
цикл так построен. Их всегда n-1. Мне необходимо посчитать еще количество операций у p-1, у участка,
который слева, и у n-p, участка, который справа. Он плюс-минус... Он константный сам по себе,
в зависимости от размера. Тогда я беру их и суммирую между собой и усредняю. То есть,
представь, ты получила все результаты. Там 10 различных результатов. Ты хочешь получить средний.
Мы же средний случай считаем. Мы их усредняем по n, потому что их n штук, потому что partition может
занимать место от 0 до n-1. Тогда все. Мы получили с вами вот такое вот рекуррентное соотношение.
Вопросы? Нет. Смотрите. Момент. Сейчас. Ну ладно.
У QuickSort есть две хорошие модификации, которые могут вам помочь. Потому что с такой модификации,
если вы такое напишите в контест, поверьте, оно не зайдет. И я подозреваю, что часть из вас
видела, когда там внутри цикла два вайла. Внутри вайла. Это тоже не зайдет. Вот. Там
необходима немного другая вещь. Первая модификация звучит следующим образом. А давайте, а давайте,
мы будем идти не только с начала всего вот этого списка, который у нас с вами был, и до конца,
а с левой и справа. И с левой мы будем искать элементы больше, с правой мы будем искать
элементы меньше. Если их найдем, мы свапнем их между собой. Вот о чем нам говорит первая часть.
И это, возможно, и это будет первый partition, который мы с вами можем написать и сделать.
В этом partition будут как раз-таки те два вайла, о которых, которые все очень сильно любят,
и, чаще всего, именно такой quicksort и пишут. Давайте я напишу L и R, чтобы, ну давайте лучше left
and right. Ладно. У нас есть массив левых и правых. Первая модификация. Два указателя.
Этот partition, что он делает? Он говорит, ну хорошо, пусть у нас есть какой-то pivot,
какой-то. Мы не знаем, какой. Иногда, так как я сказал, что мы можем pivot использовать любые
штуки, ну любую вещь на самом деле, то pivot value это может быть любое. Очень часто вы можете
встретить, что это просто средний элемент, и к нему тоже есть антимассив, на котором он будет
работать за n квадрат, если вы не делали рандомизацию какую-то. Когда вы выберете
средний элемент pivot, все будет действовать примерно аналогично. У вас будет какое-то
какое-то и, равное левому, и ж, равное правому. Вы пишите while. Смотрите, в том суть этого метода,
что как только у нас наши указатели на левую и правую часть начинают пересекаться, мы заканчиваем
наш quicksort. Почему? Потому что указатель, который шел слева, он пытался найти элементы, которые
больше, чтобы выкинуть из своей части. Указатель, который шел справа, он пытался найти элементы,
которые будут меньше, чтобы выкинуть их влево. И тогда в этом случае мы пытались с ними что-то
делать. А ровно это же здесь и необходимо. Однако, когда они начинают пересекаться, то вот в этом
пересечении может лежать только pivot. Поэтому мы не должны больше там ничего делать. Поэтому мы
пишем следующее. Пока и меньше, либо равно g. То есть пока наш указатель на левую часть такой же,
как и на правую. Ну меньше, чем на правую. Да. Но если они равны, ну ладно. Хорошо. Пока это так.
Что мы делаем? Нам необходимо найти место, которое нам не нравится с левой части и место, которое нам
не нравится с правой части. Значит, мы пишем partition. Пивот-поинт был. Да. Но здесь pivot-поинт левый,
pivot-поинт справа. Мы еще раз. Мы идем одним слева, другим справа указателем. Вот. Поэтому мы
пытаемся левую часть освободить от всех элементов большую правую, а от всех элементов меньше. И
чтобы у нас pivot стал, ну вот, в серединку, например. Ну попробуем, мало ли получится. Здесь пишутся
также два цикла while. Пока it меньше, чем pivot-value. Пока вот оно меньше пивота, мы делаем плюс-плюсы.
Мы и увеличиваем на единичку. Пока. А житое больше pivot-value. Пока житое больше, чем pivot-value.
Мы делаем плюс-плюс жи. Ой, минус-минус, да. Извините, мы влево идем, да. Минус-минус жи. Мы это
делаем с вами. После этого, когда у нас эти два цикла прошли, мы нашли элементы здесь, которые меньше,
здесь, которые больше или бы равен. Это означает, что нам необходимо их между собой поменять местами.
Однако, скажите мне, когда эти it-ы и j-ты перешли через друг друга, есть ли нам смысл менять их?
Нет. Поэтому здесь пишется if, который предотвращает этот swap.
Если и больше, либо равно жи, то мы останавливаем наш цикл. И после этого нам необходимо сделать swap.
Давайте я туда перейду. Там осталось две строчки. После этого брейка, нам осталось сделать swap.
Мы делаем этот swap, после чего мы говорим, что у нас плюс-плюс и минус-минус жи. Мы же поменяли эти
элементы, значит уже рассматриваем только следующее. Понятно? Ну и после этого вне цикла, что должны
вернуть? Или это еще не все, что мы сделали? Что нам нужно еще сделать?
Пивот поставить на место и или жи. Как нам понять, где находится теперь пивот?
Да, это правда. Нет разницы, потому что они одинаковые, если они вышли. То есть если они прошли,
они же дойдут до каких-то равных уже в серединке. Нет разницы it или j-ты. Но в этом случае нам
необходимо сделать swap. Все верно. Это такой partition. L plus R, no, left plus right.
Все ли корректно или нет? Что некорректно? Где? Что еще раз?
Пивот вэлью нам зачем посерединке? Здесь именно для этого пивот вэлью делается,
а на серединке точно остановится. Пивот вэлью это L plus R пополам. В зависимости от того,
какую архитектуру вы рассматриваете массивов. Что еще раз? А вот это вот будет вопрос к вам,
когда вы будете его писать. Смотрите, здесь необходимо понять, вот это правильный swap или нет?
Или же что-то здесь все-таки не так? Это достаточно такая больная тема обычно. Поэтому с ней лучше всего
проработать. Будет работать это или нет? Достаточно будет всего лишь проверить. Вы на семинарах и так
напишите вот такой вот quicksort. Но есть еще одна проблема. Где такой quicksort не работает? Вот вы,
молодой человек. На чем плохо работает такой quicksort? Да. Причем считаем, что это не так,
что там мы специальный массив подали. А вот просто, какой случай здесь не очень хорошо подходит?
Ну, так вы продолжаете общаться, но я не услышал ответа. Так какой случай?
Есть ли кто, кто знает? Нет. Данная сортировка плохо работает с массивом, в котором почти все
константное, потому что он пытается их свопать между собой. Когда у нас абсолютно все, что есть,
оно так и продолжает быть с этой константой. В чем эта проблема? В том, что мы просто делаем
бесполезную работу. И все. Кто понял почему? Так, ладно. Давайте еще вопрос. Хорошо.
Давайте вернемся к этому, пожалуйста. Скажите мне. Давайте, раз уж что сложно, давайте разберемся
здесь, как этот своп пишет. А раз уж здесь мы с вами пишем, что у нас меньше пивота,
сам пивот когда-то здесь может оказаться. Верно? И мы можем взять его и поменять. Но нам
все равно необходимо поставить на его место. Скажите мне, если я его встречу где-то посерединке,
я поставлю его на свое место или нет? Поставлю. Грустно. Поэтому в действительности каждый раз,
когда мне говорят, а для чего здесь это, и мы что-то исправим, может что-то не заработать. Нам
необходимо просто взять и меньше, либо равно же. На середине они так или иначе встретятся. И
когда это произойдет, он может поменяться с необходимым мне местом. И сам пивот встанет на
нужное нам место. Потому что мы будем постоянно их между собой свопать. Если пивот встанет на
место какое-нибудь там подальше, чем необходимо, он все равно потом перейдет в другое место,
потому что G его встретит. Потом его встретит И, потом опять G. Они будут перекидываться между
собой пивотом, как горячая картошка, но по итогу он встанет на свое место. Ну и да, здесь просто
необходимо что-то вернуть. Что касается задачи, когда у нас есть одинаковые элементы. Я, видимо,
сейчас расскажу лишь суть. Возможно, попрошу семинаристов тогда вам рассказать на экзамене,
господи. На экзамене вы будете рассказывать про это. Смотрите, а суть примерно в следующем.
Только что объясню, почему мы не свапаем пивот. Это нормально, потому что ты же хотел как раз другой
партийший написать, но, видимо, что-то не пишется. Почему? Нет, мы можем его менять. В том и суть,
что вот этот while работает пока меньше и пока больше. Как только он встретит такой же,
он может его поменять местами и остановится в этом циклу. Что же касается разбиения массива на три части.
Когда у вас происходит такое, что в массиве много однотипных элементов и вам необходимо
его отсортировать, хотя он на 7 минут может даже успеть. Нам необходимо разбивать массив на три
части. Меньше, равное и больше. И вот эта часть больше случайно может оказаться очень большой,
по факту, ко всему массиву. А когда она очень большая, у нас может что-то не заработать из-за этого
всего. Поэтому нам необходимо понять, а как нам модифицировать алгоритм так, чтобы мы могли
разбивать его на три части. Представим следующее. Вот у меня есть массив, вот у меня есть левая
граница, правая граница. Предположим, я буду теперь пивот выбирать вот отсюда. У нас каждый
раз новый алгоритм, новый выбор. Очень удобно. Я буду выбирать пивот отсюда. Пусть у меня есть
еще P и Q, какие-то элементы, которые будут делать следующее. Вот здесь вот у меня будут элементы
равные пивоту. Вот здесь вот у меня будут элементы меньше пивота. Вот здесь вот у меня будут
элементы равные пивоту, а вот здесь вот элементы будут больше, чем пивот. Вот. И G, U. Вот. И после этого
мне необходимо переделать свой массив так, что посередине стоит все равная пивота,
лево стоит все меньше пивота, а справа стоит все больше пивота. Для начала мне нужно получить вот
это, а потом мне нужно получить вот это. Почему так? Потому что мы пытаемся модифицировать вон ту
машину, которая у нас с вами была. Мы с вами идем с левого и правого края друг к другу, поэтому нам
необходимо, чтобы вот этот указатель E и вот этот указатель G, а как-то внутри себя пока идут,
расправлялись с теми, которые равные пивоту. Мы не знаем их количество и сколько в центре им
понадобится, тоже не знаем. Поэтому нам необходимо их где-то собирать. Так как E идет слева направо,
мы будем левой границы собирать. Так как G идет справа налево, мы будем собирать их у правой
границы. А все элементы больше кидать сюда. Почему это выгодно? Потому что представьте, что я вот здесь
где-то встретил элемент равный пивоту. Так как я до сюда дошел, вот до сюда, и он у меня больше
пивота. Он и должен здесь стоять по-хорошему, значит все хорошо. Иду дальше и встречаю элемент равный
пивоту. Вот он равен пивоту. С чем мне его поменять? Так я возьму просто и вот с этим вот Q на
место Q и поставлю пивот. А если я возьму и поменяю эту ячейку с этой, то что у меня произойдет?
Ничего плохого, потому что также здесь будет все больше пивота. Аналогично слева работает. Понятно?
А потом нам необходимо все перегнать в середину. И вот этот алгоритм работает корректно и быстро.
И эта штука нам поможет. Что там добавляется? Смотрите, помимо того, что мы здесь написали,
вот эти два указателя здесь. Назовем эту модификацию три части. Вот что добавляется.
По факту лишь добавляется вот сюда еще пару условий. А так как этот while доходит и до равных
элементов, то нам необходимо здесь добавить if на равный элемент. Если он равен, то мы должны
его менять с p. Если мы дошли аито, которое равно нашему пивоту. Если мы его нашли,
мы меняем с p и пет двигаем на единичку. Аналогично g. Если мы нашли элемент g какой-то,
который у нас равен пивоту, то мы ставим его на место q и q двигаем на единичку вперед. То есть
мы добавляем вот эти свопы. Этого будет достаточно, чтобы мы разделили на вот эту часть. Я думаю,
вы сможете написать вот эту часть. Да? Или я зря вас верю? Ну хорошо, проверим тогда где-то
через месяц, видимо. Ну может чуть поменьше. Что касается просто сдвига. Смотрите, у нас с
вами p и q будет показывать количество равных пивоту. Нам необходимо
просто взять и свопать все элементы сначала отсюда сюда, потом отсюда сюда. Мы их друг дружку
свопаем по количеству равных здесь. А так как у нас p и q говорит сколько их здесь благодаря
этим указателям, мы понимаем, что делать. То есть здесь таких четыре указатель.
Спасибо. Понимаю. Видимо, quicksort не понравился. Вот. Контест. Значит от меня во все группы
пришли сообщения. Всем большое спасибо. До следующей недели.
