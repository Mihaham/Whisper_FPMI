Всем доброго дня, мы с вами продолжаем сегодня проходить наш курс.
Некоторые объявления, возможно, кого-то оно порадует, кого-то оно не порадует.
Следующая лекция будет в записи.
Мне придется уехать, поэтому я заранее сделаю запись и ее выложу.
Поэтому мы сможем пообедать.
В том числе, да.
У всех режим питания свой.
Я даже считаю, что это хорошо, что эта лекция будет в записи.
Потому что это, на самом деле, одна из самых сложных лекций, которые есть в первой части курса.
Чтобы лучше разобрались.
Есть же это замечательное выражение, когда красная шапочка к волку к бабушке приходит.
Она спрашивает, а зачем тебе большие уши?
Для того, чтобы я тебя хорошо слышал.
Вот точно так же и здесь будет.
Сегодня мы с вами говорим про свойства конечных автоматов.
И разберем кое-что, что было уже на семинарах.
Я надеюсь, вы все уже разобрались с регулярными языками.
С регулярными выражениями было.
Мы тем продолжим.
Результатным вопросом, который у нас был, я его сейчас открою.
У вас есть последний момент переголосовать на него.
Скорость лекции оставляем такой же темп.
Проголосала 27%.
Немного медленнее проголосовала 30%.
Поэтому мы замедлим, но на эпсилу.
Но эпсил может быть очень большой.
Эпсилу можно срезать?
Скорее, нет чем, да.
А если вычитаете, что на экзамен тоже поменьше будет?
То, что мы прочитаем, то будет на экзамен.
То есть доп-материалов не будет.
Мы все голосуем зачитать в 100 раз в месяц.
А, конечно, разбежались.
Мы носим на экзамен одну теорию.
Так, давайте вспомним, что было в предыдущих сериях.
Еще что?
arden не 32?
Как этоורически diferூ?
Ну да.
Вообще, определили, что такое недetermинированный конечный автомат.
Далее, мы поняли, что можно сделать недetermинированный конечный автомат с одним завершающим состоянием.
И отдельно мы поняли, что можно построить недetermинированный конечный автомат с однобуквенными переходами.
В домашнем задании, которое будет сейчас, вам нужно будет разобраться, можно ли эти два требования совместить.
Собственно, мы с вами определили недetermинированный конечный автомат с однобуквенными переходами и одним завершающим состоянием.
А сегодня мы с вами будем говорить про то, можно ли этот автомат детерминировать.
То есть сделать так, чтобы из каждого состояния по каждой буквы было не более чем один переход.
Вот это наша цель сегодняшняя.
Но прежде чем мы с вами начнем, у нас все-таки курс немного алгоритмический.
Поэтому мы с вами сейчас берем алгоритм.
Значит, в чем будет состоять алгоритм?
У нас с вами есть автомат с однобуквенными переходами.
И наша цель – научиться по нему определять, лежит ли слово в языке или нет.
Это план наших занятий, да?
Он такой сегодня достаточно большой.
То есть смотрите, у нас с вами есть автомат с однобуквенными переходами.
И у нас есть слово W в онлайке.
Нам надо определить, лежит ли слово в языке, занимаем этим автоматом.
Автомат, значит слово W какое-то.
Да, это однобуквенный по-моему обозначает так.
Значит, и нам надо ответить на вопрос.
Лежит ли слово в языке, задаваем автоматом.
Давайте придумаем алгоритм.
За кой сегодня?
Пока затупую.
Но храним множество всех состояний, которые мы смогли дойти и делаем из всех переходов.
Да, именно так.
То есть смотрите, идея такая.
Сустроим изначально НК с однобуквенными переходами.
А дальше для слова WН храним следующее множество.
Дельта КТ равно дельта от Q0 в КТ.
Помните, что это за дельта?
Это множество состояний, из которых, из Q0, по слову,
в КТ мы можем дойти до состояния Q, прочитав слово целиком.
Вот такой переход.
Значит, как строится переход для Q из Q КТ, Q К плюс первое?
Собственно, нам нужно взять переход Q, Q КТ, взять все переходы вида Q в К плюс один, Q штрих.
И тогда у нас Q К Т плюс один.
По факту это будет все такие Q штрих, что...
Дельта Q прям Q К Т.
Нет, дельта это множество переходов по самому автоматику.
Да, на проекте Риверда.
Так, смотрите, здесь нужно доказать один факт, чисто строго математически.
Смотрите какой.
Нам нужно доказать, что на самом деле Q К Т плюс один при этом будет равняться дельта Q0 В1 и так далее ВК плюс первое.
То есть нам нужно будет доказать вот этот факт.
Что вот такое множество, которое мы с вами построили, оно будет таким.
Это если мы говорим формальным.
Как это сделать?
Давайте просто распишем это все дело.
Дельта Q0 ВК Т.
Да, я сейчас... Зачем это делаю? Этот факт просто нам еще раз понадобится в одном месте в доказательстве.
Какое что? Q.
Q штрих.
То есть у нас появляется вот такой переход.
Мы просто написали, что у нас с вами такое дельта К Т.
А что такое дельта К Т?
Вот смотрите, важный трюк.
Мы говорим, что существование мы можем расписать вот таким образом.
ВК Т Q Эпсилон.
А вот это можно расписать как переход.
Q штрих Эпсилон.
А из этого, смотрите, из свойства определения будет следовать, что Q0 ВК Т ВК плюс один будет следовать Q ВК плюс первое.
А из этого будет следовать Q штрих Эпсилон.
То есть это как раз то самое дельта от Q0 ВК плюс один.
Только, наверное, в предпоследнем множестве надо еще квантор по Q поставить.
Существует Q, да?
Да, оттуда Q берется.
Да, согласен.
Вот такой переход.
На самом деле, зачем я его расписал?
Мы просто такой же переход будем писать уже несколько минут позже.
Поэтому можно считать, что это такая небольшая лемма, которая нам понадобится для доказательств дальнейших фактов.
Собственно, а дальше нам необходимо третий шаг, нам необходимо проверить, является ли QН в пересечении может он в завершающем состоянии не пустой.
То есть, что это означает?
Это означает на самом деле следующее, что дельта от Q0 не пустая.
Это равносильно.
А это что значит?
Это означает что?
Что это означает?
Сейчас, секунду.
Ну да, что существует Qрезf такое, что вот так.
А это относительно тому, что наше слово принадлежит языку A.
Так, понятно, да?
Вопрос.
За сколько обновляется у нас Qкт?
Утверждение, что это происходит за мощность Q плюс мощность дельта.
Почему?
Потому что нам нужно пройти по всем вершинам и собрать это множество Qкт.
Сохраним Qкт в виде анордера сета или чего-нибудь там.
Давайте считать, что симпотика в среднем.
А это что?
Qкт это множество в состоянии в нашем автомате изначально.
Да, дельта это множество переходов.
И мы будем хранить вот эти переходы по слоям.
Ну все наверное писали BFS.
Или алгоритм на нахождение кратчащих расстояний на граф.
В принципе алгоритм будет ровно такой же.
Так, в итоге, а симпотика какая у нас будет?
Всего алгоритма целиком.
Для нахождения слова.
Qв плюс е умножить на l.
Так, длина слова и каждый переход у нас с вами.
На самом деле кажется просто е умножить на l.
Потому что мы больше чем q различных мы не попадем.
Ну, все-таки в автомате может быть один переход.
Ну, а если у нас е перехода, то мы изначально вершины не пойдем больше, чем q вершины.
Ну, да, скорее всего это можно каким-то образом упростить.
Но в целом можем считать, что симпотика такая.
То есть у нас получается симпотика квадратичная.
Ну, плюс-минус квадратичная.
А сколько допамяти нам требуется?
Q. Нам нужно qкт хранить.
О, большое, а вот длины словаку.
Вот такой алгоритм.
Понятна суть?
Да?
В презентации, вы только говорите, что у нас уже однобухленные презентации.
Написано, что мы строим его.
Да, ну вот.
Мы не обсуждали с точки зрения алгоритма.
А, ну давайте обсудим.
Собственно, хорошая идея.
Обсудим, как строится автомат с однобухленными переходами.
Значит, давайте считать, что пока что мы строим уже автомат
с не более, чем однобухленными переходами.
На самом деле, из следующего будет понятно, как это сделать.
Что нам необходимо уметь, чтобы мы строили автомат
с однобухленными переходами?
Что нам необходимо уметь встроить в автомате
с однобухленными переходами?
Так, смотрите.
Это...
Смотрите, а у нас точно не должно быть нигде суммарной длины
строк на ребра?
Где? Вот там?
У нас там на ребре всегда одна буква.
У нас там на каждом ребре одна буква написана.
Так, теперь обсудим это.
Значит, что нам необходимо построить?
Нам необходимо построить следующую вещь.
Учиться быстро отвечать на вот такой вопрос.
Находить множество дельта куэрсов.
То есть все состояния, из которых мы можем перейти
по пустому слову.
Логично?
Потому что, напоминая, в чем заключается алгоритм.
Мы берем все переходы
и добавляем дополнительный переход по букве.
Для каждого состояния нам нужно уметь
эффективно находить дельт куэрсов.
А по факту что мы можем сказать?
Что это у нас некоторый граф.
Ве, где В равняется наше множество состояний.
А Е
состоит из пар
В1, В2.
Таких.
Давайте все-таки это состояние у нас.
Ку1, Ку2.
Что у нас есть эффективные переходы.
Ну и тогда нам нужно на самом деле уметь считать
следующую величину.
Ну да, да, да. То есть нам нужно научиться
на вопрос, умеем ли из определенной вершины
дойти до другой вершины по общему переходу.
Все.
Дельта от чего?
Ну а здесь можно уже использовать любой алгоритм,
который вам нравится.
Хоть Флойда, хоть Форд Малмана.
Ну любой, в общем.
В общем, любой алгоритм, который за Ве отработает.
Ну а здесь будет количество
вершин, количество ребер.
В этом всем процессе.
Для каждой пары нужно найти ответ.
Вот. Обсудили алгоритм.
Понятно суть?
Хорошо. Ладно.
Значит, не поверите.
Наша сегодняшняя цель
будет избавиться от вот этого страшного кракера.
Восьмой точке.
У нас тогда и дельта переприсвоилась, получается, в Ве.
Где? Там?
Да.
Есть такое.
Только смотрите, давайте еще один важный тезис,
который я подчеркну. Не поверите,
нам здесь вообще, если честно,
на асимптотику построения вот этих вот алгоритмов с переходами
будет ей, честно, плевать.
Знаете почему?
Потому что такие алгоритмы зачастую строятся один раз.
И тут мы касаемся темы компиляторов.
Что такое компилятор?
Это программа, которая берет что-то из языка А,
переводит это в язык Б.
И наша цель как раз, когда мы пишем компилятор,
собственно, научиться строить вот какой-то автомат,
образно говоря. Этот автомат строится один раз.
На сборку этого компилятора.
Все эти алгоритмы будут происходить
на стадии сборки проекта.
На стадии сборки нашего компилятора.
Поэтому на самом деле здесь асимптотика нагнаться не надо,
потому что следующий алгоритм, который будет убирать
вот там вот и дничку, он, собственно,
будет нам сильно вредить.
То есть, точнее, не то, что сильно вредит,
вообще, будет важно именно на обработку определенного слова.
Итак, смотрите.
Значит, где медленным? Здесь, в данном моменте,
нам необходимо хранить неоднозначность пояса перехода по буквам.
Для этого у нас множество куката есть.
А далее нам нужно хранить неоднозначность
нашего разбора слова.
Поэтому давайте введем следующее определение,
которое заключается в том, что мы введем в такое понятие
конечный и конечный автомат.
ДК!
Это такое НК,
что для любого,
во-первых, он с однобуквенными переходами.
Так, мощность
так,
длина нашего слова
равняется единице.
Я хотел объединить два определения.
И дальше
сигма
не больше единиц.
То есть получается,
если мы говорим на картинках,
то мы запрещаем себе вот такую картинку.
Вот такую мы запрещаем.
Хорошо?
Эпсилоны разрешаем?
Эпсилоны мы запретили здесь.
Хорошо.
Давайте подумаем, что у нас станет
со симптотикой алгоритма.
Ой, это я уже пропалил.
Вот у нас есть ДК,
вот такой автомат.
Чему у нас будет равняться мощность Кукатова?
Давайте предпочитаем для всех слов не больше, чем N,
куда они приходят и будем отвечать за вот это вот.
Только слов два в степени N.
Ну да.
Смотрите, мощность Кукатова у нас равняется единице.
Соответственно,
у нас по каждому состоянию
будет ровно один переход.
То есть у нас здесь мощность дельта,
мощность вот этого штука превратится
по факту в единицу.
То есть у нас со симптотикой будет
длина слова.
Ну на самом деле, если честно говорить,
причем может быть количество состояния в автомате,
если мы ее не считаем за константу.
Из алгоритма будет понятно,
когда мы построим этот автомат.
Значит, доп. память.
Не поверите, доп. память будет ровно такая же.
Количество состояния в автомате.
А это будет следовать из того автомата,
который мы построим.
Смотрите, для хранения,
давайте скажем так.
Относительно НКА с однобукленным переходом.
Для самого ДКА это будет от единицы.
Это предпочитанная доп. память.
А теперь самое прикольное.
Время построения этого автомата.
Здесь я вас обрадую.
Ну это еще не страшно.
Ну да, мы его строим в один раз, как говорится.
Нет, просто будет жить страшнее симптотики.
Ну да, но все равно.
Два в степени надо закладывать.
На самом деле, вот эта два в степени
количество состояния в автомате намекает
на то, как будет работать наш алгоритм.
То есть у нас в состоянии будет что-то интересное.
Здесь говорится вот такие термины,
что за ерунда.
Будем строить автомат наш.
В общем, теория, которую мы сегодня будем доказывать,
она заключается в следующем.
Что для любого НКА существует ДКА,
а m' такой, что l от m равняется l от m'.
Давайте на словах расскажу идею.
Идея как раз выходит из этого алгоритма.
Мы хранили множество кукаты,
когда обрабатывали в онлайне.
А можем ли мы заранее это множество кукаты
предпочитать?
То есть какие гипотетические кукаты
у нас есть?
Какие кукаты у нас есть?
Какие гипотетические кукаты у нас могут появиться?
Понятна идея?
Давайте я начну рассказывать доказательства.
m' будет начинаться из такого.
То есть множество состояний в новом автомате
будет два в степени количества состояний no.
Это множество из-под множества всех состояний.
То есть мы будем по факту,
если мы будем реализовывать этот алгоритм,
он будет реализовываться как раз из того,
что мы будем собирать наше множество.
То есть у нас есть переход по букве a,
он перешел в два состояния,
то есть будет тоже новое состояние.
Вот это множество из этих двух вершин
будет в новом автомате.
То есть у нас новая память,
это алгоритм отчисла состояние?
Алгоритм отчисла состояние в новом автомате,
то есть количество состояний относительно старого автомата.
Переходы сейчас определим.
Нужно будет картинку посмотреть.
Старт будет вот такой.
То есть стартовать будем из нашего набора вершин.
Так, сейчас вы ничего не поняли.
Я же правильно понимаю?
Такой-то непонятный набор букв.
Давайте посмотрим на картинку.
Собственно пример, который поясняет, что происходит.
Вот у нас есть такой автомат.
Давайте мы сделаем следующее.
Сделаем дополнительный переход
из состояния q0 по букве a
в множество q1, q2.
То есть вот у нас был такой автомат.
Мы что делаем?
Мы с вами говорим,
что давайте мы будем строить множество состояний.
То есть мы начали из q0,
по букве a могли перейти гипотетически
либо в q1, либо в q2.
Храним всевозможное множество переходов
по этой букве a.
А дальше из этого гипотетического перехода по букве b
куда мы переходим здесь?
В q3, а из q2 мы переходим в q4.
То есть берем множество вершин,
в которые мы гипотетически могли попасть.
Смотрим переход по букве
и смотрим множество вершин,
в которые мы могли попасть из нее.
Смотрите, какое состояние будет здесь в завершающем?
Есть мысли?
q3, q4.
Потому что на самом деле,
по слову a, b
мы могли перейти из стартового состояния
в какое-то из завершающих.
Вот мы делаем переход из стартового состояния
в какое-то из завершающих.
Пока что это рукомахание
на уровне того, как работает эта конструкция.
Сейчас мы просто будем ее определять
строго математически.
Чтобы вы не захлебнулись,
давайте мы это и сделаем.
Изначально
что нам необходимо понять,
это нам необходимо определить
дельта штрих.
Но при этом,
до этого давайте возьмем еще одно обозначение,
где s некоторое подносит
в q.
Это объединение
по q из s
дельта qv.
То есть мы дельту теперь определяем
не только для состояния в автомате,
но и для некоторого множества состояния в автомате.
Ага, как нам переписать терминах кванторов?
Это множество тех q штрих,
что существует q2 штриха
из s,
такое, что дельта q2 штриха
v, ой,
терминоконфигурация
выводит
q.
Теперь следствие, которое мы с вами сделали
на самом деле на текущий момент,
из этого всего выходит интересный факт.
Если вы вспомните переход,
то оказывается, смотрите,
дельта q0
по слову va,
это замечание у нас.
Смотрите, чему равняется.
Кто понимает, что мы это уже показали?
Где мы это показали уже?
Да, когда мы это доказали,
вот смотрите, вот тут даже остался мелом на доске,
когда мы делали переход в qk в плюс первое
из кукатого,
построение алгоритма,
мы ровно то же самое написали и здесь.
Здесь был переход по букве a.
Просто я это подчеркиваю, чтобы вот оно осталось,
просто в предыдущие годы я не объяснял,
почему это вот так работает.
Сейчас мы это пояснили.
Итак, теперь смотрите, мы можем наконец-таки
после всего этого определить дельта штрих.
Не поверите, это следующее,
s, a,
дельта s, a.
То есть мы берем множество,
берем букву и переходим
кипотетически туда, куда мы можем перейти.
Из этого множества по определенной букве.
Зачем это нам нужно сделать?
Может быть, мы зафиксировали,
что у нас количество переходов является конечным.
Переход по букву,
где забыли?
Ну, окей.
Смотрите, пример дельты св.
Дельты из q1, q2 по b, это q3, q4.
Дельты из q0 по ab,
будет q3, q4.
Вот такой у нас автомат получается.
То есть в нашем случае,
если мы s берем, равное множеству q1, q2,
то дельта от q1, q2 по b
будет равняться q3, q4.
Осталось определить множество
но на самом деле это все состояния,
в которые пересекаются
с им может завершать состояние.
То есть мы могли дойти до нашего состояния
каким-то образом завершающим.
Так.
Давайте осознаем.
Работает ли вот это...
Понятно ли, что здесь произошло?
Давайте вопросы задавать,
потому что это такой фазовый переход
обычно от множества ко множеству всех под множество
он дается с трудом.
Это множество переходов
в новом автомате.
Ну, из состояния в новом автомате
по букфре в новом автомате
идет переход в некоторое тоже
вот это множество состояния и в старом автомате.
S это вершина в автомате,
по которой мы позволили подносить.
Если у нас это поднос, то в старом автомате.
Нет, S это поднос, что в старом автомате.
Тут ничего нет.
Конечно.
Вот.
Так, осознали?
Так, хорошо.
Теперь будет некоторый взрыв мозга,
потому что вот сейчас, не поверите,
будет ровно почти то же самое доказательство,
которое было у нас уже до этого.
Но мы его пропишем для множества всех состояний в автомате.
Давайте мы поймем следующее.
Во-первых, надо понять,
почему у нас с вами
наш автомат M4
с детерминированной.
Во-первых, потому что у нас явно
задана функция перехода.
То есть, видите, у нас
это прямо можно работать как функция.
По всем под множеством.
В смысле?
Это переход из состояния в другое состояние.
Да.
В смысле перехода?
В смысле перехода?
Еще раз.
Это множество переходов в новом автомате.
Вот оно, здесь мы его определяем.
Как оно определяется?
Мы берем состояние в новом автомате,
которое является под множеством в состоянии в старом автомате.
Берем букву и делаем переходы
во все возможное множество.
Вот это тоже множество будет.
Оно будет лежать в под множестве КО.
Мы берем все возможные вершины,
которые у нас были в С.
Смотрим, куда по ним можно перейти
по букве А.
Фиксируем их.
И записываем, что это новое наше состояние.
Давайте еще один пример.
Вот смотрите.
Допустим, у нас есть С.
Здесь есть переход по букве А сюда,
по букве А сюда,
и по букве Б сюда.
Тогда вот это будет у нас дельта СА.
Вот такая картинка у нас получается.
Здесь будет один тонкий момент,
который мы будем доказывать.
Он заключается в том, что мы будем доказывать
определенную лему.
Вот такую вот.
Значит, лему заключается в том,
что дельта штрих...
Смотрите, дельту штрих мы тоже можем определить
для нового автомата.
Ровно так же.
У0 по В
равняется.
И вот здесь, смотрите,
будет некоторый взрыв мозга,
потому что на презентации тут лажа.
Точнее, лажа на уровне единственного
отождествления.
Кто видит здесь лажу?
Здесь математически, так сказать, есть баг.
Да, смотрите, здесь не хватает фикурных
столбочек.
Потому что, смотрите,
этот элемент
под множество два в степеню ко
степеню ко.
Смотрите...
Так, сейчас, секунду.
Рубрика математика.
Вот эта штука из ко.
Под множество ко.
Значит, мы берем, делаем
переходы по набору букв.
То есть, это будет под множество всех
под множество всех
состояний в дельта штрих.
То есть, вот эта штука,
это будет некоторое под множество два
А вот это у нас под множество ко.
То есть, поэтому здесь фигурные столбки должны быть.
Но здесь можно сказать,
давайте это,
некоторые замечания.
Мы понимаем, что в ДК
мощность дельта штрих, вот.
Сейчас, секунду.
Мощность дельта штрих из ко ноль,
по любому слову W, не больше, чем 1.
Понятно, под каким причином?
Потому что каждый раз мы переходим ровно по одной букве.
Чем по одной букве?
Не более или ровно?
На самом деле, не более.
Ну, хотя, на самом деле,
если так подумать, вот, и мысль доказать,
на самом деле, будет ровно единичка.
А что такое?
Как у нас вот эта вот дельта штрих
для множества определяется?
Состояние, множество всех
состояний в автомате.
Состояние в автомате,
это под множество, множество состояний.
То есть, вот эти вот ребята, они ИСКУ?
А вот это под множество КУШТРИХА.
А КУШТРИХА, это у нас два все пенико.
Что, давайте докажем этот факт?
А почему всегда единица,
если у нас кукол, который вообще не встречается в автомате?
На самом деле, не поверите,
мы такой переход построим тоже.
Тут будет просто пустое множество.
Ага.
Вы не поверите,
я вот сейчас это впервые за третий год
в чтении лекции осознал, что мы сейчас можем
пропустить одну теорему, по ходу дела.
Да.
То есть, просто рассказать, как это работает алгоритмически,
но в целом мы с вами
можем так обсуждать доказательства.
Индукция по длине слова.
Вот мы и познакомились с этим фактом
уже в доказательствах.
Так, база.
Слово пустое.
Давайте размышлять.
Что такое дельта штрих
от Q0 по пустому слову?
Мы доказываем вот это вот равенство слева.
Да, да, да. Вот это вот мы лему доказываем.
Что это такое?
Это множество всех
таких S,
что из Q0,
ε
мы можем перейти S
по пустому слову.
Подождите, а нам точно...
А, ну ладно.
Ну короче говоря, вот в
дельта справа мы на самом деле можем убрать
вот эти фигурные словочки.
Честно мы их можем убрать.
Да, они мешают на самом деле.
То есть, мы можем сказать, что дельта штрих и дельта мы можем отрадистрить.
Да, да, да.
Вот, смотрите.
У нас что получается?
У нас, поскольку автомат
детерминированный,
что это означает?
То у него вся переход однобуквенная.
Получается, что S это у нас что?
Это у нас с вами просто множество из Q0.
А что такое дельта
из множества Q0, ε?
Это множество всех
состояний
таких, что
ε мы можем дойти
в Q, ε.
Да, кстати, я забыл сказать, что
у нас с вами
M
с однобуквенными переходами.
Да, давайте зафиксируем, что здесь
однобуквенные переходы, иначе у нас будет лажа.
Потому что здесь у нас получается как раз
множество из Q0.
Собственно, если мы допишем фигурные скобки,
то получим требуемое.
Хорошо.
База понятна?
Тут обычно любят шутить,
база понятна, переход очевиден, но
переход не очевиден.
Как мы строго сделали
второе?
Какое? Вот это?
Вот это?
Вот это?
Вот это отсюда вниз. Ну, смотрите.
У нас в автомате M' все переходы однобуквенные.
Вопрос. За какое количество переходов мы можем считать
пустое слово и на выходе получить пустое слово?
За сколько переходов?
За ноль.
За ноль можем.
То есть мы неформально
делим? Да, да.
Вот так, что это однобуквенный переход.
Переход.
Итак.
Давайте рассмотрим следующее множество.
Дельта штрих
ВА.
По словам ВА.
Смотрите, что я сделаю.
Воспользуемся вот этим замечанием.
Оно верно для любого автомата.
Что у нас получается?
Получаем вот такое вот анимативное свойство.
Теперь
давайте подумаем, что у нас здесь находится.
Тонкий момент.
Тут главное не проморгать, где мы сейчас
дельту пробавлим.
Ой, точнее, штрих.
То есть наша цель сейчас убрать отсюда все штрихи.
Давайте думать.
Что у нас получается?
У нас идут переходы по штриху.
И здесь нам надо их убрать.
Давайте подумаем, что же это такое?
Внутренние будут убираться из предположения индукции.
Что это такое?
Это у нас с вами получается фигурные скобки
из дельта.
Вот чего?
У ноль В.
Переход по букве А.
Вот это у нас множество.
А что такое дельта?
Это объединение по Т
у следующих В.
Дельта
у ноль В.
Так.
Дельта ТА.
Я же правильно написал определение?
Вы имеете в виду, что можно просто
внешние скобки убрать?
Да, да, да.
Смотрите, сейчас секунду.
Да, я согласен.
Их нельзя убирать.
Так получается.
А что такое дельта?
А что такое объединение?
Вот этого множества,
состоящего из одного элемента.
Так, сейчас, секунду.
У вас просто убрались вот эти фигурные скобки
самые внешние.
Вот так.
Что? Давайте пояснять.
Давайте разбираться.
Смотрите, вот это что?
Это объединение по множеству, которое
из одного элемента.
Собственно, это значение этого элемента есть.
Нет, здесь скобки не нужны.
Дальше они раскроются.
А теперь, теперь.
Смотрите, вот теперь важный момент.
Воспользуемся определением того,
когда дельта штриха у нас определяется в множестве автоматов.
То есть у нас вот это вот элемент,
это элемент множества...
Это элемент множества ку штрих.
Согласны?
А что значит, что это элемент множества ку штрих?
Это означает,
что это объединение...
Сейчас, секунду.
Аккуратненько сделаю.
Значит, это объединение.
Аккуратненько сделаю.
Ммм...
Сейчас.
Тут главное сомножить вымени на косячи где-то с фигурными скобками.
Просто у меня есть желание написать сразу вот так.
Ну а давайте разбираться,
почему это так.
Тут надо написать, смотрите, что.
Что дельта штрих вот из-за вот этого.
Сейчас мы в рубрике черновик.
Стоп, мы где-то фигурные скобки фрукты.
Стоп, мы где-то фигурные скобки продолбали.
Вокруг Т.
Сейчас, секунду.
Ну где-то да.
Ммм...
Сейчас, давайте проверять.
Ну да, не, просто не хочется их снимать,
потому что иначе это будет лажа полная.
Да, да, да.
Дельта.
Мы только что сделали то же самое снятое место.
Сейчас.
Секунду, нам нужно просто понять,
почему здесь выявляются фигурные скобки вот тут вот.
Потому что в конце, в итоге получится,
что это просто дельта от х0,
по слову W A.
И на этом доказательства закончатся.
Теперь нам нужно разобраться, почему мы сделаем такой переход.
Так, давайте размышлять.
Что это за элемент?
Значит, это у нас множество,
под множество вот два в степеньку.
Два в степеньку, два в степеньку.
Здесь у нас тоже вроде так.
Здесь переход по...
Здесь вроде все так.
Так.
Здесь что у нас получается?
Из этого множества каждый раз
у нас есть один переход по определению.
Да, да.
Я говорю, что это да, что из под множества есть переход
по одному определению.
Это штука,
почему мы просто убрали знак множества
от того, что было два перехода.
Вот это? Где?
Вот у нас было обедение, вот у нас было написано...
Это определение дельта.
То есть это определение дельта штрих.
То есть что такое дельта от множества?
Это объединение
всех дельты
по элементам вот этого множества.
Вот этого множества.
Просто я не очень понимаю,
в чем разница между этой штукой.
Короче, я понял.
Там хватает индукции по словам длины один,
и тогда это будет просто шаг, вот этот шаг будет...
Не-не-не, но это из определения должно уже следовать.
Сейчас, у вас это в большинстве лемма
для слова а.
Да, но хочется лемму для слова а применить все-таки вот этим фактом.
Нет, сейчас, у вас вот этот переход
справа, сверху, до низ, лево,
это в точности лемма для в равного а.
Вот да, но хочется...
А уже однобукленное, поэтому если у нас будет база для однобукленных слов,
то мы сможем это применить.
У нас есть информация, потому что у нас
переходного приоритета один.
Так, давайте рубрика проверка размерностей.
Вот этот элемент из 2 в степени...
Так, 2 в степени 2 в степени Ко.
Вот этот элемент
тоже 2 в степени 2 в степени Ко.
Значит, здесь мы вроде ничего
такого криминального не делали,
то есть, что такое вот этот вот элемент?
Это элемент из 2 в степени
2 в степенику, значит, вот это все из 2 в степени, 2 в степенику.
Значит...
Блин.
Секунду. Так, давайте это...
Ммм...
Че, правда, что ли?
Ну да. Не, мне просто не нравится вот этот вот переход.
Ну вот, он должен следовать, следовать из этого. Сейчас.
Значит...
Ну давайте, пожалуйста, покажем, что значит, что значит, что это штрих от вот этой штрихи.
Давайте переобозначим то, что у вас там стоит за s.
То есть вот эту тетту внутреннюю давайте за s переобозначим, чтобы было удобнее.
Да, давайте.
Это s.
То есть дельта штрих от из s и a равняется множеству из дельта са.
А это переходка.
Да, спасибо большое. То есть нам нужно... Смотрите.
Все. Тупняк, тупняк. Бывает.
Смотрите. Михаил Дила говорит.
Давайте обозначим за s множество дельта от дельта ку 0 в.
Тогда давайте... Тогда вот эта штука, это у нас дельта штрих от са.
А вот это, это множество от са.
Множество от са.
Теперь смотрите, что такое дельта штрих по определению.
Собственно, это множество состояний, в которые мы можем попасть из состояния s по букве a.
А в какое множество состояний из множества s мы можем попасть по букве a из состояния?
Сейчас, извините, а вот у нас сейчас написано не просто определение дельта штриха.
Да, да, да. Вот это ровно определение дельта штриха, просто записанное другими терминами.
Тонкий момент.
В общем, если что, давайте я это оставлю на доске, чтобы вот оно у нас было.
Если, допустим, кто-то захочет подойти в конце, разобраться с этим, без проблем.
То есть здесь вот тонкий момент, что мы говорим, что вот это множество и это множество s в нашем старом автомате.
И дальше по определению мы можем написать вот этот переход.
Честно просто расскажу, что в предыдущих доказательствах просто везде фигурные скобки опускались,
и давайте мы просто будем работать без фигурных скобок. Это нечестно.
Все-таки математическое свойство есть.
Да, видите, тут в презентации, если посмотреть, тут везде просто скобки будут пропущены, а это некрасиво.
Поэтому надо презентацию поправить.
Здесь вот этот фазовый переход делается.
Так, теперь давайте докажем следующую вещь.
Довершим наше доказательство.
Смотрите.
В m принадлежит языку задаваемого автомата m.
Когда?
Старым автоматом.
Когда это работает?
Смотрите.
Это эквалетно тому, что у нас дельта q0 по слову w не равно пустому множеству.
Логично?
Вот, хорошо.
Вот оно написано.
Теперь смотрите.
А теперь давайте поймем, почему это так.
Что такое дельта q0v?
Это на самом деле, что такое дельта штрих от множества q0v в новом автомате.
То есть вот этим мы пользуемся.
Сейчас мы будем пользоваться тут определенной леммой, которая у нас была.
Все еще понимают, наверное, следующий факт.
Давайте пропустим.
Вот это эквалетно тому, что мы можем здесь скобки взять.
Почему здесь мы можем фигурные скобки добавить?
Думаю, это в принципе уже много раз вот там делали.
Ну, там мы ни разу не делали.
Просто множество из одного элемента состоящее.
Теперь мы пользуемся нашей леммой.
И получаем следующую вещь.
Это дельта штрих от q0v.
Давайте напишем это все.
Это что у нас такое?
Дельта q0v вот так.
Это же вот такая штука, да?
И вот эта вот штука, если мы обозначим ее t, то у нас t пересечь с f не пустое.
Вот, собственно, здесь хочется сказать, что мы обозначили за t.
За t мы обозначаем вот эту вот величину.
То есть элемент.
Вот.
Давайте теперь размышлять.
Почему из этого дальше можем написать, что дельта штрих от q0v пересечь с f штрих не пустое?
Что такое у нас f штрих?
Напомню.
У нас сейчас, кстати, есть презентация.
f под множество q не равно пустому.
Это у нас определение.
В частности, там лежит вот этот элемент t, который в пересечении с f дает не пустое.
Вот этот элемент t, который в пересечении с f дает не пустое слово.
Да, то есть вот этот элемент t как раз нам говорит, что у нас есть пересечение по не пустому слову.
А это эквалентно тому, что слово w лежит в языке сдаваемого штриха.
Все, доказали теорему.
Еще раз, тонкий момент, который здесь есть.
Есть переход по слову.
Соответственно, переход по слову, который возникает здесь, у нас множество из определенного элемента.
И этот элемент как раз у нас лежит по множеству f.
Соответственно, t лежит в f штрих.
То есть у нас в нашем множестве есть элемент из f штрих.
Пересекая с ним, мы получаем не пустое множество.
И в итоге получаем принадлежно слово языка.
Кажется, я вас довел.
Нет, вроде все нормально.
То есть тут такая муторня с множествами, но в целом главный факт это вот это.
Так, давайте следствие некоторое выведем.
Тут это прям следствие.
Из этого факта оно заключается в следующем.
Потому что для любого НК с одновуховными переходами можно построить эквивалентный ПДК.
Полный ДК.
То есть для него можно построить полный детерминированный конечный автомат.
Что это означает?
Это означает, что для любого Q из Q, а из Сигма равняется единица.
Ровная единица.
Мы его как раз построили.
Потому что мы для каждого под множество, для каждого перехода сделали переход ровно по одной букве.
Ну, по одной и то же множеству.
Теперь практическая вещь, которая важна следующим вещам.
Теория Маштрих, назовем ее.
Для любого ДК можно построить эквивалентный ПДК.
Как это сделать?
Да, на самом деле можно запустить алгоритм детерминирования, но есть более практический алгоритм.
Давайте поймем, каких переходов не хватает в ДК.
Переходы в пустое множество.
Поэтому давайте просто добавим это пустое множество.
Ну, неважно.
Просто повторим ту же самую идею для тех переходов, которых у нас не было.
Так, сложности мы уже вернулись, когда мы говорили про это.
Из-за того, что у нас количество состояния увеличилось двое в степень двойки, то мы понимаем с вами, что 8 точки у нас вот такие.
Почему количество состояния в втором переходе?
Потому что нужно хранить ID-шник вершины.
Собственно, идея алгоритма такая.
Добавляем стоковую вершину, и из всех вершин перехода по недостающим буквам мы добавляем сток.
Картинка вот такая.
То есть, если бы мы запустили алгоритм детерминирования для этого автомата, то у нас бы как раз не хватило бы из Q0 перехода по букве А,
из Q2 не хватило бы перехода по букве А.
Мы добавляем эту стоковую вершину, которая в доказательстве теоремы о детерминизации соответствовала пустому множеству.
На семинарах вы еще это будете все строить. Мы будем строить это все дело.
Зафиксировали картинку. Понятно картинка?
Теперь докажем некоторые свойства автоматных языков.
Будем уберить, как строить вот это вот ПДК.
В смысле, как строить ПДК?
Картинка.
Я не уверен, что там получится за два в степени.
Там даже быстрее получится.
А, два в степени Q.
Скорее всего два в степени Q на мощность еще чего-нибудь.
Смотрите, суть в чем.
Этот алгоритм расскажут на семинарах.
Он называется алгоритм Томпсона.
Он заключается в том, что нужно запустить BFS от вершины из состояния Q0.
Алгоритм детерминизации.
Давайте расскажем, в чем заключается алгоритм детерминизации.
Запускаем BFS
от Q0
встроим
по X, принадлежащим сигмалу.
Дальше смотрим.
Если у нас множество, было ли у нас это множество уже,
если множество не было, то добавляем его в очередь.
Если множество было, ну все, забиваем его.
И в итоге вот как раз у нас вот эти вот дельты,
все вот такого вида перехода.
Давайте я так напушу.
То есть достаем из очереди элемент,
смотрим все его переходы,
устроим дельта штрих.
Если у нас элемент был, закладем его в очередь.
Если элемент был, мы его в очередь не кладем,
иначе мы его в очередь не кладем.
Если мы не встретили элемент, то мы кладем его в очередь в множество, если мы множество встретили, то в очередь мы его не кладем.
Еще раз, нам нужно построить множество дельта штрихов, множество переходов к новому автоматику.
Мы начнем строить его рекурсивно. Начнем строить все из кумоль.
Настроим множество кумоль. Дальше смотрим переходы по букве А, которые куда-то ведут.
Соответственно, у нас появляется множество вот такое. При этом храним очередь, по которой мы будем отслеживать все такие элементы, все вот такие накапливающиеся множества.
Если у нас есть это множество, уже мы его обрабатывали, не с ним ничего не делаем, если у нас этого множества нет, то мы берем достаем его из очереди и продолжаем делать следующие переходы.
Повторяем до победного.
А почему нельзя пробежаться по всем подмножествам? Для каждого подмножества можно просто поставить переходы в QA и сказать, что это есть сиквер.
Можно, просто на практике эта штука будет работать намного быстрее, в среднем, потому что она будет проходить не все подмножества вашего множества.
Тут, скорее всего, два цепеньку умножить на Q получается будет.
Ну да, на множество дельта. Согласен.
Так, давайте тогда сейчас еще посмотрим вот этот факт, сделаем некоторую затравку.
Кто-нибудь знаком вот с этими товарищами?
С Клини?
Да, со всеми этими. Кто был на первом семинаре?
С Клини лично не знаком.
Отлично, ничего это вам не напоминает?
Все напоминает.
Операции над чем это напоминает?
Регулярными выражениями.
Только дополнения и пересечения.
Ну дополнения и пересечения, да, не было.
Значит, смотрите.
Конкатинация. Давайте посмотрим на картинке.
Их еще на раз в семинаре рассмотрят.
Как построить конкатинацию двух автоматов?
Да, то есть мы строим два автомата.
У нас завершающее одно, это начальное второе.
Объединение как построить?
Просто.
Из одной вершинки пустить туда?
Да, вспоминаем физику, параллельное соединение.
Делаем переход в завершающее состояние другое.
Итерация к линии.
Цикл.
Цикл, причем хитрый цикл.
То есть мы отделяем отдельный автомат и делаем переход по эпсилону туда.
И из завершающего состояния второго автомата переводим в новый.
Вот.
Пересечение.
Господи.
Берем два автомата с однобуквенными переходами.
И строим их декартовое произведение.
Собственно, считайте, что у вас один автомат по горизонтали, другой автомат по вертикали.
Собственно, переход делается тогда, когда у вас в автомате есть переход и по одной букве, и по второй букве.
Вот смотрите, пример.
Видите, переход вот красненький из Q01 в Q101.
То есть в первом автомате мы переходим из Q0 в Q1.
А в втором автомате по букве А мы переходим из Q0 в Q0.
То есть получается, мы меняем номер столбца, но номер строки не меняем.
Какая?
В первом автомате петелька по букве B.
Смотрите, в первом автомате петелька по букве B. Давайте обсудим, куда она делась.
Вот здесь у нас переход остается в пределах одной строки.
А здесь мы меняем номер, точнее, переход по B не меняет столбец, но вот отсюда переход по B меняет строку.
То есть у нас получается переход отсюда, вот сюда.
Да, то есть получается, в одном автомате мы не поменяли состояние, в другом автомате мы поменяли состояние.
Вот, опять же, индукция по длине слова может доказать, что эта конструкция работает.
Или индукция по длине вывода.
Дополнение как строить?
Можно поменять семантик, допустим, сказать, когда она выпускает, значит не выпускает.
Да, для дополнения важно полный, детерминированный конечный автомат.
Полный, детерминированный, для того, чтобы у нас не было тупиков.
Меняем завершающее и незавершающее состояние между собой.
Вот для этого нам нужен был полный автомат.
Вопрос, почему нельзя делать это в обычном ДК?
Он может сломаться.
Пример.
ДК?
Какое слово он принимает?
А.
Меняем завершающее стартовые места.
Какое теперь слово он принимает?
Для сравнения с ДК.
Для сравнения П ДК.
Так, как он устроится там?
Вот так.
Это полный ДК.
Вот так.
Вот полный ДК.
Дополнение его какое?
Из трэш в трэш в А, ну вот оно.
Красота же, да?
И вот здесь уже не принимается слово А, но принимаются все остальные.
Картинку зафиксировали.
Как построить разность?
Ну да, пересечение вместо дополнения.
И давайте вот такая затравка будет у нас.
В чем проблема автомата?
О, нифига себе она звучит.
Ну это раз.
Человек вот может понять, что он нарисован на детерминированном, конечно, автомате?
Да.
Так, ладно.
Так, вы, видимо, компилятор не писали.
Если у вас размер, ну как выигрышин до десяти, еще нормально.
Да.
Да.
Есть проблема в том, что автоматы – это язык понимания компуктеров.
Иногда, да.
Людям, какой механизм люди придумали?
Регулярное выражение.
Регулярное выражение.
То есть, когда мы обычно пишем компилятор, мы пишем какое-то регулярное выражение на входе.
Вот.
И мы пишем это регулярное выражение, и получаем в итоге результат.
А, да.
Ну, да.
Ну, да.
Ну, да.
Ну, да.
И мы пишем это регулярное выражение, и получаем в итоге результат.
Регулярное выражение же вообще непонятно пошло.
Да.
Но поэтому при регулярном выражении их можно в строчку записать.
Вот в чем их польза.
Соответственно, в чем суть?
Мы можем с вами по регулярному выражению написать автомат.
Построить автомат.
Собственно, по-моему, на семинарах, вам рассказывали уже, у тех, у кого были семинары?
Да.
Не, а у кого был второй семинар уже?
Рассказали.
Да, рассказали, да, как по регулярному выражению строится автомат.
Собственно, давайте я как раз это сделаю еще на дополнительной записи, да,
которую я потом выложу.
Ну, вот, напоминание некоторое здесь есть.
Как это строится все?
Вам должны табличку такую были на первом семинаре строить.
Вот.
Вот.
И как раз из регулярного выражения мы можем построить автоматное,
а из автоматного мы можем построить обратное.
Собственно, это делается, давайте это мы сделаем уже не сегодня,
потому что сегодня у нас конец.
Да, значит, что мы сегодня с вами осознали?
Мы с вами поняли, что у нас любой автомат может задаваться некоторым
детерминированным конечным автоматом, более того, полным детерминированным конечным автоматом.
После этого мы с вами поняли, что эти автоматы запутаны относительно теоретика множественных операций и итераций к линии.
То есть они поддерживаются полным механизмом как и у регулярных выражений.
Следующий раз, напоминая, будет запись. Я ее постараюсь выложить где-то в воскресенье и в ней мы как раз уже будем разбирать разные регулярные выражения.
И закажем, что они эквалютны.
Все, приношу извинения за затуп в середине лекции. Если есть вопросы, по этому затупу можно обращаться.
