У меня остался небольшой долг с прошлого раза, про
очередь я не успел рассказать.
Значит, очередь очень похожа на стэк структура, только
с другого конца приходят запросы.
Значит, очередь это такая структура данных, которую
мы будем отвечать опять-таки на запросы.
Мы очень часто будем структуру описывать функционалом,
то есть, что мы от них требуем, на какие запросы они должны
отвечать.
Вот очередь один из таких примеров.
Значит, во-первых, мы хотим уметь добавлять элемент
в очередь, push x, это добавить x в очередь.
Давайте я пишу в конец очереди, в конец, значит, front это
узнать элемент из начала очереди, узнать элемент
из начала, начальный элемент, самый первый из начала.
И последний pop это удалить начальный элемент.
То есть, это буквально реализация очереди.
Представьте себе, у вас есть очередь к кассе, вот
здесь стоит кассир, сюда приходят люди, они добавляются
в конец, то есть, когда происходит push они добавляются
в конец очереди, а обслуживаются, она начинает с начала.
То есть, есть начало, начало очереди.
И клиенты обслуживаются, начиная вот отсюда.
Первой, второй, третий и так далее.
Добавляются в конец, удаляются из начала.
В отличие от 스�ека, где удаление и добавление происходили
в одной и той же стороне.
В стэке и удаление, и добавление были вот здесь, здесь удаления
в одной стороне, продон, добавление в одной стороне, удаление в другой. Вот. Ну, как бы, не
шибко сложнее, чем stack. Опять-таки, можно очень легко реализовать на списке. Можно реализовать на
списке. Ну, просто вот все вот эти вот объектики представляем отдельными коробочками, да,
отдельными нодами, которые друг на друга ссылаются в порядке слева направо. Добавляем в конец,
удаляем из начала. Все так же, как в обычном списке происходит. Вот. Ну и, соответственно,
все такие операции будут работать за единицу, а за вот единицу. Вот. Давайте посмотрим на то,
как можно было бы очередь по-другому реализовать. А именно, очередь на двух stack.
Вот. Это нам будет нужно для того, чтобы уметь поддерживать минимум в очереди. Потому что мы
знаем, как в stack поддерживать минимум. В прошлый раз у нас это было, что если мы просто каждый раз
будем добавлять не только элемент, но и минимум во всем, что под ним, среди всего, что под ним,
то у меня в stack можно будет поддерживать минимум из всего, что там есть. Тогда, соответственно,
если я научусь реализовывать очередь через stack, ну или через два stack, тогда я сразу научусь
поддерживать минимум в очереди. Потому что вообще говоря, минимум в очереди на такой
тривиальной реализации на списке не очень понятно, как делать. Потому что когда у вас добавляются
элементы здесь, а удаляются отсюда, у вас есть некое окошко, в которое сейчас активные элементы,
то есть оно двигается влево при удалении и вправо при добавлении. И непонятно,
как в нем поддерживать минимум, потому что удаляются отсюда, а добавляются вот здесь.
Минимум здесь, ну как минимум, не очень ясно, как делать. Я не умею за единицу это делать на списке,
скажем так. Вот, а со stack все просто. Значит, смотрите, какая идея. Давайте мы заведем два stack,
ну я их назову просто первый-второй. В первый stack мы будем добавлять элементы,
ну то есть делать операцию push. Если приходит push x, то мы его просто добавляем в первый stack,
а из второго будем удалять. И тогда смотрите, как будет выглядеть история работы с такой очередью,
реализована на двух stack. Вот представьте, сначала у нас приходит несколько push, несколько элементов
мы добавляем сначала в очередь. Ну приходят люди в очередь, мы их добавляем в первый stack. Причем
они в stack добавляются, но они в этом stack будут в перевернутом порядке. Если первый элемент
пришел, самым первым будет лежать на дне stack, над ним второй, третий, четвертый и так далее. То есть
если я их буду доставать, они будут доставаться в неправильном порядке, в противоположном, потому
что надо было бы их доставать порядка 1, 2, 3, 4. Ну окей, пока как есть, пока мы их не достаём,
пока мы их просто сложили. Дальше, в момент, когда впервые меня просят удалить начальный элемент или
просто узнать его значение, то есть front или pop запрос приходит, я буду смотреть на второй stack и
буду работать с его верхним элементом. Если этот stack пустой, как в самом начале, я сделаю следующее,
я все элементы из первого stack переложу во второй. Ну вот просто пока первый stack не пустит, я все
элементы перекладываю из него во второй. Я отсюда достаю четверку, кладу его на дно второго stack,
достал тройку, переложил сюда, двойку, единицу. И теперь смотрите, здесь порядок элементов такой,
как мне нужно. На как раз 1, 2, 3, 4. Удалять я буду первый прошедший элемент, потом за ним второй,
третий и так далее. То есть когда я добавлял в stack, у меня порядок элементов заменился на
противоположный. Теперь я еще раз добавляю в stack, и он еще раз меняется на противоположный,
то есть становится правильным. Я как бы два раза перевернул список, он стал таким, как надо. Теперь
в начале вот этого stack будет правильный элемент, тот, который самым первым пришел. Ну и тогда,
по крайней мере, первые четыре операции удаления я точно смогу правильно обработать. Удаляю pop,
pop, pop, pop. У меня удалится все в правильном порядке. Вот, параллельно этим pop приходят push
какие-то. Пришел push 5, 6, 7, 8 и так далее. Я все push делаю в первый список, в первый stack.
Потом, когда этот stack опустошился, то есть у меня произошло четыре запроса pop, все эти
элементы удалились, и опять приходит запрос front или pop. Давайте я опять все вот эти элементы,
которые успели накопиться в первом stack, я их переложу во второй, они опять поменяют
свой порядок с неправильного на правильный, потому что развернется список. Будет на донышке 9,
потом 8, потом 7, потом 6, потом 5. И первый stack опустошится. И здесь опять такие в правильном
порядке все элементы лежат. Ну а понятная идея. Да, вот давайте я это быстренько напишу,
что если приходит push x, то я просто добавляю x в первый stack, добавляем x в первый stack,
а когда приходит pop или front, я делаю запрос ко второму stack. Но если внезапно второй stack
пустой, то я перекладываю все с первого во второй. Но если второй stack пуст,
то сначала перекладываем все элементы с первого во второй. Все элементы из 1 в 2. Все,
вот такая нехитрая реализация. Понятно? Вот, супер. Ну и теперь понятно, что если мы на stack
умеем поддерживать минимумы, то мы умеем и в очереди тоже поддерживать минимум. Потому что
если у меня вот здесь вот, там следующие числа приходят, я знаю на них минимум,
я знаю на них минимум, тогда минимум во всей очереди, глобальный минимум, это минимум из
минимума здесь и здесь. То есть если я знаю минимум здесь, минимум здесь, то мне нужно взять
из них самое маленькое вывести в качестве ответа. Поэтому в дополнение к этим операциям я еще
научился отвечать на запросы минимума во всей очереди. Минимум во всей очереди. Так, хорошо.
На stack мы в прошлый раз научились поддерживать минимум на stack. Если я знаю минимум здесь и здесь,
то минимум во всей очереди, это минимум из этих двух минимумов. Хорошо. Строится у меня только
перекладываниями из первого. Если второй stack пустой, я останавливаю все выполнение и по одному
перекладываю элементы из первого во второй. Достаю, достаю, достаю, пока первый не пустошится.
Да, ровно так мы и делаем. Если второй stack не пустой, то я в него ничего не перекладываю,
я из него только удаляю. Я в него что-то перекладываю только в момент, когда второй пустой и к нему
поступает запрос удаления или посмотреть первый элемент. Если второй stack пустой, то я перекладываю,
иначе ничего не делаю. Надо сделать еще замечание насчет времени работы, потому что если раньше на
списках у меня все операции работали за чистую единицу, добавить ноду, удалить ноду, посмотреть
на первый элемент, это все работало за единицу. Теперь, как видим, у меня вот эта штука перекладывания
элементов из одного stack в другой, она работает не за единицу, она работает за столько, сколько было
элементов в первом stack. Поэтому, в принципе, каждая конкретная операция может работать довольно
долго, потому что мне нужно весь первый stack вычерпать, исчерпать и положить во второй. Но понятно,
что суммарно это будет тоже быстро, это будет линейное время, если мне поступает n запросов,
то суммарно работает за o от n. Потому что каждый элемент, давайте проследим историю каждого
элемента x. Он сначала один раз попал сюда, потом он переместился один раз сюда, и потом он один
раз удалился. То есть время, затрачиваемое на каждый конкретный элемент x, это константа. Это push
в первый stack, pop из первого stack, push во второй, pop из второго stack. То есть это 4 действия на
элемент. Значит, хотя каждая конкретная операция, вот эти вот операции, они работают, каждая конкретная
может работать долго, но суммарно все эти n операции, если к очереди такой поступит n операции, то
суммарно они работают за o от n. Потому что каждый элемент поучаствовал максимум в четырех перекладываниях.
Согласны? Это то, что у нас будет, я чуть позже буду вводить, амортизированное время работы, это когда
каждая конкретная операция может работать долго, но суммарно, то есть я могу долго перекладывать,
но суммарно, если я много переложил, тогда здесь, в течение многих следующих операций, я сюда ничего
перекладывать не буду, потому что здесь большой stack, я могу отсюда спокойно удалять. И вот эта
вот логика, что мы за счет какой-то дорогой операции, то есть если я долго перекладываю с первого
во второй, я потом в течение многих операций не буду нуждаться опять с перекладыванием. То есть если
я сделаю одну долгую операцию, то много следующих будет дешевыми, я смогу отсюда удалять по одному
без проблем. Такая вот идея баланса, что если была дорогая операция, то потом много следующих простые,
это то, что у нас чуть позже будет, как амортизированное время работ. Давайте я пока это оставлю,
просто как заклинание. Добавили, ну что такое переложили? Это надо, значит, сделать pop и потом push.
Ну это не важно, как бы константа, амортизированное время работы каждого запроса.
Четыре действия с объектом. Мы сначала положили сюда, потом достали отсюда, потом положили,
потом достали. Вот, значит, амортизированное время работы за единицу, то есть если к очереди,
давайте так напишу, то есть n операций обрабатываются за вот n. Каждая конкретная может быть дорогой,
но суммарно не больше, чем n на константу, n на 4 в нашем случае, потому что каждый объект
участвует в четырех действиях. Окей? Давайте я вот здесь еще поставлю звездочку. Я буду амортизированно
всегда звездочку обозначать. Так, вопросы есть? После pop slash front. Запрос ко второму стэку.
Так, хорошо. Тогда переходим к еще одной структуре данных, которая называется куча.
Опять давайте подойдем с функциональной точки зрения. Чего мы хотим от кучи? Мы пока ничего не
хотим, но в принципе, чего люди могут хотеть? Это следующий набор операций. Мы будем хранить,
давайте напишу, что в скобочках хранится мультимножество s. То есть множество, возможно
с повторениями. Там конкретный элемент x может несколько раз туда входить. Чтобы не запариваться
про кратность, я скажу, что это мультимножество. Запрос первый. Insert x. Это просто добавить x в
наше множество s. Запрос второй. Узнать минимум. Get min. Вывести значение минимального элемента,
который есть в s. Давайте так напишу. Узнать минимальное значение y по всем y из s. Формальная
запись. Надо найти самое минимальное по значению элемент в множестве s. Третье. Этот элемент удалить.
Extract min. Extract от слова извлечь. Извлечение минимума. Давайте так напишу. Удалить минимум из кучи.
Удалить минимум из s. Четвертый. Декрески. Запрос. Уменьшить какой-то элемент. То есть в множестве
s было какое-то число, был какой-то элемент. Я хочу научиться уменьшать. Какой синтаксис у
этой процедуры, у этого запроса? Он принимает, давайте напишу, ptr и дельту, которые значат следующее.
ptr это указатель на тот элемент, который хочется уменьшить. То есть смотрите, в s как-то лежат
элементы. Вот я хочу, чтобы мне сообщали указатель на то место в памяти, где лежит конкретный
элемент, который пользователь хочет удалить. У нас такого же было, когда мы удаляли из списка.
Нам надо, чтобы нам показывали на конкретный элемент, на конкретную ноду, на конкретную
вершину. То же самое здесь показывают на конкретный элемент в s. Не просто говорят число x уменьшить,
а говорят, где оно лежит в s. Это указатель, ссылка, адрес уменьшаемого элемента. Дельта это
какое-то неотрезательное число, на которое надо элемент уменьшить. Напишу, давайте здесь.
Уменьшить элемент, лежащий по адресу ptr, на дельту.
То есть был какой-то элемент, я его хочу сделать чуть поменьше, на дельту. Пока такая магия. Смотри,
зачем это может быть, например, нужно. Ну это нужно, например, при обработке более-менее
чего угодно. При обработке каких-то заказов, задач, чего-то. Вот представьте, в s у вас лежат какие-то
объекты, которые вам надо делать. Детальки какие-нибудь на заводе вы сидите, вам надо делать детальки. И вы
каждый раз, вы один человек, вы в любом момент времени можете делать только одну детальку, и вам
надо каждый раз действовать как-то оптимально. Выполнять деталь, которая, например, приносит
максимальную стоимость или там, у которой наиболее близкий дедлайн. В этом смысле вам нужно уметь
добавлять элементы в ваше множество, то есть добавлять задания, детали в ваше множество. Узнавать
и извлекать самый ближайший, тот, который самый выгодный, в каком-то смысле оптимальный из кучи,
например, самую дорогую деталь или ту, которой дедлайн ближе всего. И до крески, ну пока выглядит
несколько абстрактно, ну, например, там у какой-то детали изменилась какая-нибудь характеристика,
ее надо сделать раньше. Дедлайн перенесли пораньше, надо ее сделать пораньше. Ну что-то такое. Как бы
странно это ни было. Вот. Ну, это такая более-менее притяжка за уши к реальной жизни. На самом деле это
нужно будет нам в куче других алгоритмов. Во втором семестре у нас будут всякие алгоритмы
на графах. Давайте напишу, что в частности это нужно в алгоритмах прима и дэкстры. Вот. Это будет
там через полгода. Ну и в этом сместоре чуть позже нам это тоже будет нужно, когда будем
рассматривать деревья поиска, там кучи тоже будут очень нужны в какой-то момент. Так, есть вопросы
к тому, что надо от кучи? Хорошо, а давай тогда ее реализуем. Давайте напишем конкретную бинарную
кучу. Бинарная, она же двоичная куча. Это следующее. Я буду моемножство s хранить на самом деле просто
в массиве. И сегодня, извините, у меня будет опять один индексация от 1 до n. Элементы s я буду хранить
в массиве от 1 до n. И в голове у себя буду представлять, что эти элементы на самом деле сложны каким-то
образом в дерево. А именно следующим образом. А1 лежит в корне дерева, дальше у него есть два ребенка.
Так, давайте я картинку здесь нарисую побольше.
А1 в корне, дальше у А1 есть два сына, А2 и А3. Дальше у А2 опять есть два сына, А4 и А5. У А3 будут
сыновья А6 и А7. Ну и так далее. Например, давайте нарисую картинку. Если n равно 10, у меня будет вот
такое дерево. То есть я буду строить это дерево сверху вниз, слева направо. Это получается такое
бинарное дерево в том смысле, что у каждой вершины есть два сына, левый и правый. Ну и вот оно так сверху вниз
жадно построено. Мы идем слева направо по вершинам одного уровня, строим у них сыновей. Дальше переходим
к следующему уровню, продолжаем строить сыновей, пока весь массив не исчерпается. Важно, что это
дерево я явным образом не строю. Я не завожу отдельных каких-то классов, которые бы хранили это
дерево. Я не провожу эти ребра. Я просто говорю, что вот тот массив соответствует этому дереву. И
эта картинка у меня будет всегда на самом деле в голове только. Она будет виртуальная. Я это дерево
нигде не храню. Потому что я показал, как они однозначно друг другу соответствуют. Что по такому
массиву можно построить такое дерево. Ну и понятно, если есть такое дерево, то надо просто выписать число
лежащие вот в этих вершинах, получится массив.
Скажите, пожалуйста, почему такое построение дерева корректно? Почему, допустим, два разных элемента случайно не положим в какой-то один?
Не очень понял вопрос. Смотрите, как устроено дерево. Оно устроено так, что если есть какая-то вершина, в которой написано число с индексом v,
то у него есть два сына. Левый сын это a с индексом 2v, правый сын это a с индексом 2v плюс 1.
Смотрите, давайте скажу так. Давайте построим полное бесконечно-бинарное дерево. Вот такое бесконечное. У каждой вершины два сына до бесконечности.
Тогда что такое куча на одном элементе? Это вот этот элемент. Что такое куча на двух? Это вот это. На трех вот это, на четырех вот это, ну и так далее.
То есть у вас для любого n вам нужно взять целиком несколько первых слоев на несколько первых уровней, а потом несколько вершин на следующем уровне.
Вот, окей. Так всегда для любого n, собственно, это дерево будет устроено. Если я просто вот таким образом провожу ребра, то у меня ровно так дерево и всегда и будет выглядеть.
Так, хорошо. Значит, это виртуальное представление такого дерева, нашего массива точнее. И давайте я скажу следующее, что на этом дереве должно выполняться требование кучи.
Требование кучи. Это следующее простое требование. Что элементы, лежащие ниже конкретного, его больше либравны.
Значит, а1 должно быть меньше либравно, чем все вот в этом вот по дереву, то есть чем все остальные элементы, а2 должно быть меньше либравно, чем все вот это вот по дереву.
То есть все, что лежит, все, что ниже его, все, что достижено из него вниз по ребрам, все должно быть его больше либравно. То есть а2 самое маленькое вот в этом по дереве.
Дальше, вот здесь а3 меньше чем а6, ну, меньше либравно, чем а6 меньше, меньше, чем а7, а4 меньше либравно, чем это и это, ну и так далее.
Значит, давайте спишу так, что для любой вершины v, av меньше либравно, чем au, для любой u в под дереве v.
Ну, что такое в под дереве, значит, что если я вот, вот есть у меня какая-то вершина v, где написано число av, все, что достижимо вниз по каким-то путям, вниз, влево, вправо, могу ходить.
Вот если я могу вниз дойти до вершины au, сверху вниз от v до u, тогда обязательно должно выполняться вот такое вот неравенство, av не больше чем au.
То есть всегда, когда я прохожу вниз в моем этом дереве, у меня значение может только возрастать. Ну, не строго.
Вот. Значит, это будет требование кучи. Ну и давайте сразу напишу, что я буду называть массив корректной кучей, вот тот вот массив корректной кучей, если в этом дереве выполняется требование кучи.
Значит, a1 и так далее, an назовем корректным, назовем корректной кучей, если в соответствующем дереве выполнено требование кучи.
Так, ну вроде все, определение ввел. Теперь скажите, пожалуйста, можем ли мы хотя бы на какой-то из этих запросов быстро отвечать?
Да. Мы теперь очень быстро умеем отвечать на getmin, потому что это всегда a1. Потому что, коль скоро массив удовлетворяет требованию кучи, ну точнее, является корректной кучей, то в корне всегда число меньше либо равно, чем все остальные, то есть минимум.
Ну хорошо, уже хоть что-то. Еще раз? Да, там еще придется позаморачиваться с этим. Да, в итоге будет лог везде, но тут везде надо будет повозиться. Пока давайте с getmin, остановимся.
Значит, для остальных запросов мне будут нужны две вспомогательные процедуры, которые будут чинить кучу, если она внезапно поломалась. Давайте введем две вспомогательные процедуры.
Ну хорошо, давайте вообще поймем, зачем они нужны. Ну вот вы говорите про extract min. Вот давайте сделаем вот здесь. Вот у меня была корректная куча, допустим. Здесь был минимум.
Как этот элемент можно из кучи удалить? Ну хотелось бы типа его удалить, поставить на его место какое-то другое число и кучу перестроить.
Ну типа, например, на a10 я могу вот отсюда удалить, переместить его сюда. Но тогда у меня a10, число, которое по идее должно быть довольно большим, раз оно вот здесь вот низко лежит, когда я его переставляю в корень, у меня наверняка какие-то неравенства нарушатся.
У меня в корень поместилось большое число. Мне нужно как-то кучу перестроить. Мне нужно опять как-то его, наверное, опустить, что-то поменять. Короче, непонятно.
Вот ровно для этого я ввожу две вспомогательные процедуры, которые будут чинить мою кучу, если я с ней что-то непристойное сделаю.
Первая очень простая, называется сифтап. Сифтап, сифт, от слова просеивать. Смысл такой, вот есть какая-то v, вершина, где мы что-то испортили, мы поменяли значение этого av, и причем мы его уменьшили.
Тогда понятно, что этот элемент будет стремиться всплывать вверх в этом дереве. Если я значение элемента уменьшил, понятно, что меньше элементы у меня лежат ближе к корню.
Корень минимальный, здесь там какие-то вторые по минимальности, грубо говоря. То есть минимальные они будут стремиться всплывать вверх. Вот давайте я буду просеивать элемент наверх.
Значит работает следующим образом. Ну, во-первых, если внезапно v равно единице, то делать нечего.
Нам всплывать некуда, мы и так уже в корне, выше некуда. Дальше. Дальше давайте посмотрим на v и родителя v.
Давайте сначала поймем, какой у него номер вообще. Вот если v это не корень, то какой номер у его родителя?
v пополам, да, нацело, все верно. Значит a с индексом v пополам, где это округление вниз.
Ну понятно, что если у вершины v дети это 2v и 2v плюс 1, то как раз обратный переход от детей к родителю, это деление пополам, нацело с отбрасыванием остатка, чтобы 2v плюс 1 тоже перешло в v.
Поэтому давайте сделаю следующее. Давайте я заведу номер родителя, то есть v пополам, и сделаю следующую простую штуку.
Если в av значение меньше, чем в родителя, то их надо будет поменять. А это неправильно, как раз плохой случай.
Вот представьте себе. Представьте, что вот здесь значение меньше, чем в родителя. Так не должно быть.
У нас, наоборот, сверху должны быть маленькие элементы. По требованию кучи, чем выше, тем меньше.
А тут, наоборот, вот сломалось неравенство. Давайте его починим простым свопом. Просто поменяем местами эти два числа.
Значит если av меньше, чем ap, так, ну я в строчку напишу, извините, не хватает места.
Значит я просто свопну эти два значения. Своп av, ap и запущу севта под p.
Севта под p. Конец.
То есть процедура по смыслу очень простая. Она берет элемент и поднимает его наверх, пока текущий элемент меньше родителя.
То есть пока он меньше родителя, его есть смысл поднимать выше, ближе к корню.
То есть мы посмотрели на v и родителя. Если у них было плохо неравенство, то давайте я их свопну и запущусь рекурсивно от родителя p.
Если опять у ap и его родителя, то есть у ap пополам была проблема, то я их опять свопаю и опять продолжаю подниматься рекурсивно отсюда.
Если это неравенство было не нарушено, то здесь было правильное неравенство, p было меньше, чем av, тогда у меня рекурсивный вызов заканчивается и выше не идет.
Так, хорошо. Ну теперь sieve down.
Вы забегаете вперед. Я еще пока не описывал, как мы будем удалять. Давайте пока вот вспомогать и потом их будем применять к тому, чтобы отвечать на запросы, которые были.
Так, sieve down. Это, соответственно, движение в обратную сторону. Это когда нужно вершину просеять вниз.
Когда у нее значение большое, больше, чем надо, ее нужно, наоборот, ниже к листьям протолкнуть, просеять вниз.
Так, ну опять давайте напишем условия выхода, что если, внезапно, у v вообще нет детей, когда у v нет детей, скажите, пожалуйста.
Ну давайте без логарифмов. n меньше, чем 2v, да. Ну давайте напишу 2v больше, чем n.
Потому что у v два ребенка, 2v и 2v плюс 1, их нет, когда оба числа больше, чем n, то есть когда меньше из них больше, чем n. Нет детей.
Ну опять, по смыслу, дальше вниз некуда, и так на дне уже, ниже некуда.
Вот. Хорошо, картинка. Было вот у меня av. Дальше у меня есть либо два сына, либо один сын.
Потому что вот при n равно 10 у меня у каких-то совершенно один сын всего. То есть может быть у меня два сына, может быть один только левый.
Значит 2v, это 2v плюс 1. Давайте я сначала посчитаю, какой из них минимальный.
То есть если у меня два сына, давайте я пойму, в каком из них лежит меньшее число.
А дальше, ну представьте, не знаю, давайте картинка. Пусть здесь 5, а здесь 3 лежит.
Тогда понятно, что мне нужно свопнуть вот эти два числа местами, ну по крайней мере интуитивно хочется вот эту тройку поднять и пятерку опустить.
Ну ровно так я и сделаю. Я найду, какой из этих двух сыновей меньше и перемещу вот эту пятерку в того сына, который меньше.
Ровно так мне сейчас и сделаю. Я это делаю следующим образом.
Я сначала говорю, что u это 2v. То есть я по умолчанию считаю левого сына меньшим.
А дальше, если правый сын существует и еще меньше, тогда u равно правому сыну.
Значит как проверить, что правый сын существует?
Видимо вот так, что его номер не больше, чем размер кучи.
И число там лежащее меньше, чем число лежащее в 2v.
В таком случае я сделаю u равно 2v плюс 1.
Ну то есть теперь в u лежит наименьшее из двух сыновей.
Причем я это сделал безопасно. То есть я по умолчанию считаю, что левый сын минимальный.
А дальше, если правый существует и там еще меньшее число, то я говорю, что u это правый сын.
Вот, значит в u всегда минимальный сын.
Ну и теперь я делаю следующее, что если в au число меньше, чем в av, то есть как раз нарушается требование кучи ниже,
то значит число меньшее, чем в v.
Тогда мне их нужно свопнуть, поменять местами эти два числа, ауто и авото.
Ну и видимо рекурсивно запустится вот в этот раз.
Всегда нату.
Конец.
Так, вопросы есть по реализации?
Пока вот просто две такие процедуры, которые интуитивно делают вот ровно это.
Маленькие числа с помощью севтапа я поднимаю вверх, ближе к корню.
Большие с помощью севдауна просеиваю вниз, ближе к листьям.
Так, хорошо.
Теперь давайте попробуем, давайте сначала попробуем реализовать наши вот эти операции.
Предполагаю интуитивно, что вот севтап и севдаун в каком-то смысле правильно чинят кучу.
Потом мы все правильно, потом мы все докажем.
Давайте сначала интуицию слоем здесь.
Значит, давайте пропишу все еще раз.
Гетмин мы умеем отвечать.
Знаете, гетмин это всегда просто ретёрн, а первая.
Давайте с экстрактом попробуем придумать, что делать.
Здесь был корень, минимальное значение.
Надо его как-то удалить из кучи.
Но давайте я начну так.
Давайте мы найдем, где лежит АН.
Ну, то есть, да, вот самый низкий лист, последний элемент просто кучи.
Давайте мы поменяем местами А1 и АН.
Тем самым, что мы сделали?
Мы то число, которое раньше было минимальным, поместили куда-то в хвост.
Ну, вот сюда.
А в корень подняли какое-то большое число.
Что теперь нужно сделать, чтобы починить кучу?
Просеять вниз корень.
Севдаун единицы.
Ну, все очень интересно.
Ну, вот так вот.
Ну, вот так вот.
Вниз корень.
Севдаун единицы.
Ну, все очень естественно.
Мы подняли в корень большое число.
Теперь давайте его просеем вниз так, чтобы все неравенства починились.
Ну, и оно спустилось куда надо.
Вот.
Ну, и здесь я еще добавлю строчку.
Минус минус N.
Ну, или там N минус равно единица.
Что одно и то же.
Уменьшаю размер кучи.
То есть, если раньше у меня в куче было N элементов,
то теперь у меня в ней N минус один элемент.
То есть, у меня в перемене N всегда будет храниться текущий размер кучи.
Справедливо.
Не буду чистить.
Я ленивый.
Это вам надо будет санитайзерами,
а я буду делать, как хочу.
Сейчас.
Да, конечно.
Формально, как это у меня в памяти лежит,
я считаю, что у меня есть, на самом деле, бесконечный массив.
Ну, понятно, на самом деле.
Массив элементов.
Куда я буду складывать все мои
элементы массива?
А 1, а 2, и так далее, а.
Потом, если что-то внезапно удаляется,
то я просто говорю, окей, у меня массив теперь не здесь заканчивается,
а вот здесь вот.
А здесь продолжает лежать то число.
Потом, если мне приходит инсерт,
то я буду его вот сюда вот расширять,
и эти элементы буду перезаписываться.
То есть, я как бы эту память не теряю,
она все еще моя.
Я в нее, если не надо, что-то еще буду записывать.
Да.
Мы сделали вот это, поэтому не может.
Абсолютно согласен.
Да.
Да, спасибо, это важно.
Да.
То есть, я сначала уменьшил n,
чтобы как раз сказать, все, дальше вот этой границы
не ходи дальше, память куда не надо лезть.
А потом уже севдаун, и он это n воспринимает
как правильный текущий размер.
Поэтому сначала уменьшить, потом сделать так.
Да, спасибо.
Хорошо, с экстрактом разобрались.
Да.
Еще раз.
Да, да, да.
У нас было вот это, мы его поместили сюда,
а это, наоборот, сюда поменяли их местами.
Забыли про i и n, уменьшили,
сдвинули указатель на 1, забыли про это число.
Дальше про семя вниз,
потому что в корне число больше, чем надо.
Может быть.
Так, теперь инсерт x.
Ну, начало очень похоже.
Представьте, что у меня была какая-то куча.
Давайте я сначала вот сюда,
вот в конец, после последнего элемента, добавлю x.
То есть, по факту, я просто дорисую
еще один лист, положу в него значение x.
Что тогда надо сделать?
Сифтап отсюда.
У меня появилась новая вершина,
где какое-то значение лежит.
Понятно, что вниз его просеивать
нет смысла, потому что оно и так внизу.
Возможно, оно достаточно маленькое,
чтобы подняться вверх.
Поэтому давайте мы от него запустимся сифтапу.
Это делается следующим образом.
Я сначала увеличу n.
Потом положу в последний элемент
тот самый x, который меня просят добавить.
Ну и запущу x.
И добавить.
Ну и запущу сифтап от n.
Тем самым этот элемент x, возможно,
поднимется на какое-то количество шагов наверх,
потому что, если он достаточно маленький,
он будет подниматься наверх.
Так, ну и остался дикрестки, тоже очень простой.
Значит, дикрестки уменьшить ключ,
уменьшить значение
по указателю и дельте.
Что такое указатель в нашем смысле?
По факту это просто номер вершины,
номер элементов в массиве.
У меня однозначно
по индексу в массиве
восстанавливается вершина в дереве.
У нас есть очень простые между ними соответствия.
Поэтому в качестве ПТР
я буду просто воспринимать
номер вершины,
индекс элементов.
В этом смысле
как раз опять, смотрите,
это не значение
числа, которое нужно изменить.
Мне нужно поменять не 5
на 3, например, а мне нужно поменять
АВТ, то есть вот тот конкретный момент,
который лежит ровно на В этой позиции.
Не просто какую-то пятерку найти в куче и уменьшить,
а именно тот число, который лежит на месте В.
Потому что пятерку
найти в массиве это сложно.
Представьте, у вас большой массив, вас просят
найдите в нем пятерку, поменяйте на тройку.
Но это более сложная задача, чем я вас тыкаю
лицом в конкретный индекс В
и вам надо вот это конкретное АВТ
поменять. Ну понятно, разная задача.
Не-не, никакого бинпоиска у вас
массив-то не отсортированный.
Тут как раз вот в куче поиск
вообще никак не работает.
Поэтому кроме вот этого особо
других способов и нет.
Ну чего, тут все совсем просто.
Мы уменьшаем на дельту
и запускаем видимо сифтап,
потому что значение уменьшилось.
Единственное, что могло произойти, это оно могло подняться наверх.
Сифтап от В.
Кажется, все.
Вот, здесь уточню, что дельта всегда
не отрицательная. У нас не даром
называется процедура дикризские от слова уменьшить.
Мы уменьшаем значение элемента.
Уменьшаем ключ.
Потенциально, если бы дельта
могла быть отрицательной, то есть
меня просили бы увеличивать, наоборот, ключ,
тогда надо было бы запускать сифтдаун.
Потому что вот был элемент, мне нужно, наоборот,
ближе к одну просеять.
Надо было бы тогда вызывать сифтдаун.
Но мне на самом деле,
где нужно вот это все, там достаточно дикризские.
Инкризские в каких-то кучах можно писать,
но на практике это не нужно.
То есть во всех реальных задачах,
если у вас есть такой пакет операций,
то вам хватает дикриза, а инкриз вам не нужен.
Вот как-то так волшебно получается, что инкриз обычно не нужен.
Так, вопросы есть?
Потому что мы вот здесь делали?
Хорошо.
Так, ну тогда давайте
доказывать.
Давайте доказывать, что это все корректно.
Что такая реализация запросов
через вспомогательный сифтап и сифтдаун
на самом деле всегда
делает наш куч корректный.
Ну давайте
лемма это назовем.
Лемма.
Значит, пусть
a1 и так далее, an
был корректной кучей.
Представьте, что у нас был
массив, который был корректной кучей.
То есть для него выполнялось требование,
что все вершины ниже данной,
ее могут быть только больше.
Больше равны.
Значит, пусть
av
изменилась
ну давайте
напишу так, становится x.
Становится x.
То есть я меняю значение одного
элемента.
Тогда
пункт 1
если x
ну если av уменьшилось,
то, то есть у меня было
какое-то значение, я поменял
его на что-то меньшее.
Да, я утверждаю, что после сифтапа
от v
после сифтапа от v
куча вновь станет корректной.
Массив вновь станет корректной кучей.
Вновь станет
корректным.
Ну и аналогично наоборот,
если av увеличилась, то есть я положил число
больше, чем то, что там было,
то после сифтдауна массив станет
корректной кучей.
В противном случае
если
после сифтдаун
от v
массив станет корректной кучей.
Если мы это докажем,
то мы докажем корректность всего,
что мы делали до этого.
У меня в самом начале была корректная куча.
Вот представьте, что до выполнения, например,
декрестки у меня была корректная куча.
Приходит запрос декрестки
по указателю, по номеру вершины v.
Тогда что?
Тогда я меняю значение в av,
ну и вызываю сифтап, по лемме
куча вновь станет корректной.
Экстракт мин.
Я забыл про существование a1,
на место корня поставил
какое-то большее число.
Понятно, что an большее равно, чем a1,
вызвал сифтдаун.
По лемме куча вновь стала корректной,
потому что если число увеличил и вызвал сифтдаун,
то куча стала корректной.
Все остальные тривиально будут следовать за этой леммой.
Да?
Ну, я бы не сказал.
Давайте доказывать.
Случа 1, когда av уменьшается,
я буду доказывать индукция по v.
Ну, она не сложная,
но тут надо какие-то рассуждения привести, тем не менее.
Значит, индукция по v.
База v равна 1.
Тривиально.
Потому что если v равна 1,
то мы в корне,
и значение в корне уменьшилось.
Так это вообще прекрасно.
Если значение в корне уменьшилось,
то куча осталась точно корректной.
В корне и так лежит минимум,
мы меняем минимум, он становится еще меньше,
от этого куча корректной быть не перестает.
А у нас все неравенства по-прежнему выполнены,
потому что чем ниже, тем больше.
Ну, понятно, что в случае v равной 1
куча не перестает быть корректной,
а, как мы помним,
shift-up от единицы,
туда же до сих пор написано,
shift-up от единицы ничего не делает.
Поэтому, что в куче ничего не произошло,
что shift-up ничего не сделал, все хорошо.
Переход.
Вот какой-то av.
Давайте была такая картинка.
Вот было av,
был у него родитель ap.
Ну, понятно, p это v пополам,
не хочу писать v пополам,
будет p, родитель.
И вот это вот число
меняется на x.
Но давайте рассмотрим два случая.
Во-первых, если x внезапно
больше равной, чем ap.
Тогда я утверждаю, что куча остается корректной,
и shift-up тоже ничего не делает.
Ну, смотрите, вот у меня была корректная куча,
внезапно вот это значение уменьшилось,
стало x.
Но вот это вот неравенство
осталось верным.
То есть как оно было верно раньше,
потому что была корректная куча,
чем ниже, тем больше.
Ну и теперь, если x по-прежнему
больше равной, чем ap,
то здесь такое неравенство,
то здесь такое неравенство,
ниже больше, чем выше,
тогда я утверждаю,
что куча остается корректной.
Ну, потому что более-менее понятно,
мы только это неравенство могли нарушить.
Справедливо.
Мы потенциально могли нарушить эти два неравенства.
Но, смотрите, что такое неравенство?
Мне нужно, чтобы здесь было меньше, чем здесь.
Но я это-то уменьшил, значит здесь
подавно все неравенства остались.
А я предположил, что я уменьшил до х, который тем не менее больше в ноль, чем ап.
То есть я поменял только это значение. Очевидно, что неравенство с детьми у меня не испортились,
потому что здесь стало только меньше, а неравенство с этим не испортилось по предположению.
Я говорю, что х больше в ноль, чем ап.
В этом случае куча остается корректной, и все хорошо.
Куча остается корректной, но соответственно севтап ничего не делает, и все правильно делает.
Севтап ничего не делает.
То есть х меньше, чем ап предыдущая, но больше, чем ап.
Да, да, да, все правильно.
Так, случай второй как раз менее приятный, когда х меньше, чем ап.
То есть когда вот это неравенство нарушилось.
Давайте картинка.
Тут ав, которое поменялось на х, и ап, и теперь х меньше, чем ав.
Ну тогда понятно, его хочется как раз поднимать.
Так, давайте картинку побольше нарисую.
Вот у меня есть ап, вот у меня есть ав, которое заменилось на х,
и вот там есть еще куда-то выше и ниже есть наша большая куча.
Смотрите, давайте я сделаю две следующие вещи.
Действие первое. Давайте я заменю вот это вот на ап.
Согласны ли вы, что это корректная куча?
Да, потому что я уменьшил значение здесь, не нарушив этого неравенства.
Здесь по-прежнему это число меньше, чем вот это.
То есть менять ав на родителя всегда можно.
То есть это неравенство остается таким, как надо.
А с детьми опять-таки ничего не нарушилось, потому что это стало еще меньше.
Значит с детьми точно проблемы не было.
Дальше возьму и поменяю вот это вот на х.
Тогда с одной стороны я сделал ровно то, что нужно.
Потому что по сравнению с исходным деревом я избавился от ав, но поставил х.
А ап просто спустился вниз.
То есть я избавился от ав, но добавил х в мое дерево, но я этот х уже поставил на место ап.
А дальше предположение индукции.
То есть у меня в этот момент, смотрите, в момент, когда у меня куча вот такая,
когда здесь и здесь ап, это корректная куча,
дальше я меняю число на меньшее, я меняю ап на меньшее число х.
Значит по предположению индукции рекурсивный запуск сифтапа от п сделает кучу корректной.
Давайте еще раз.
Значит давайте я в два шага это сделал.
Шаг первый.
Заменить ав на ап.
То есть картинка сейчас вот такая.
Да, у меня на месте ав стоит такое же число, которое в родителе ап стояло.
Значит понятно, что это будет корректная куча.
Получим корректную кучу.
Получим корректную кучу.
Ну потому что по сравнению с исходной кучей все, что я поменял, это ав поменялось на ап.
Понятно, что если поменять это число на родителя, то все не равны сохраняться такими, как надо.
Значит у меня есть корректная куча.
Второй шаг.
Я заменяю верхнее ап.
Значит заменить верхнее ап.
Ну из вот этих двух верхнее ап.
На х.
А этот шаг я уже умею делать по предположению индукции.
То есть я что сделал?
По факту я заменяю уже не вот это вот более низкое число на х, а более высокое число меняю на х.
И поскольку я из корректной кучи одно число уменьшил на х,
то по предположению индукции для этой вершины я же иду в порядке увеличения номеров вершин.
Ну в частности, п меньше чем v,
п меньше чем все его дети.
Поэтому по предположению индукции, когда сифта прикурсивно запускается вот этой вершины,
она ее поднимает вверх и восстанавливает корректность кучу.
А их два, как видите.
После первого шага их как будто бы два.
Вот я вот это вот заменяю на х.
И это то же самое, что с кучей происходит.
Я спустил верхнее ап вниз, а х поднял вот сюда.
По предположению индукции,
после сифтапа от п,
куча вновь станет корректной.
Вот.
Ну и собственно, ровно это и делает наш сифтап.
Потому что сифтап,
ну то есть он на самом деле, конечно, сюда ап явным образом не ставит.
Он говорит следующее.
Он видит, что это число, которое здесь х,
меньше чем в родителе,
поэтому оно свопает и рекурсивно запускается от п.
Ну мы по факту ровно это и сделали.
Мы сюда записали ап, сюда х, и рекурсивно запустились от родителя.
Ровно это, то, что мы здесь это писали,
ровно это делает сифтап.
Он сначала поменял местами х и ап,
потом запускается рекурсивно от п.
Да.
Еще раз?
Вот этот?
Или ребенок?
Так а что его рассматривать?
Смотрите.
В момент, когда я заменяю av на ap,
я поменял только вот это число.
Понятно, что мне надо рассматривать
только вот эти три неравенства с детьми и с родителем.
Они не испортились, потому что это
число уменьшилось, значит с детьми всё только лучше
стало, а с родителем тоже не испортилось,
потому что они равны.
Теперь у меня была корректная куча. Я поменял это число
на х.
Но опять, это число уменьшилось, по предположению,
х меньше, чем ап, значит это число уменьшилось,
и нарушение может быть только
с родителем, а нарушение с родителем
у меня как раз фиксится сифтапом.
Отлично.
Ну это неважно, конечно. Здесь я нигде не пользовался тем, что это слева, а не справа.
Я пользовался только тем, что вы это сын пей и все.
Как они друг от друга относительно расположены, слева справа, я не пользовался.
Проверите, если не верите.
Ау?
А вроде и не надо пока.
Так, все, идем дальше. Доказываем про увеличение.
Ну тут как бы более-менее та же логика, только у меня будет индукция, наоборот, от листьев к корню.
Если сейчас я рассуждал от корня к листьям, доказал для корня, потом для более низких вышин и все, более-более низких сверху вниз шел.
Теперь, наоборот, будет индукция снизу вверх.
Значит, индукция.
Я напишу от листьев к корню,
ну то есть формально, по типу n-v.
Чем больше в этом, раньше я рассматриваю этот элемент.
Вот.
Ну чего, база.
База, если v-лист, то все тривиально.
Потому что если мы находимся в листе, и там значение увеличилось, то никакие неравенства не нарушились.
Сивдаун ничего не делает, все хорошо.
Вот я был листом, у меня есть только родитель, с которым неравенство могло нарушиться, а детей нет.
Если я здесь число только увеличиваю, то неравенство с родителем становится еще только более хорошим,
то есть оно еще более строго становится, сын меньше, чем родитель.
А с детьми ничего не нарушается, потому что их нет.
Ну и сивдаун делает то же самое, сивдаун смотрит, проверяет, что детей нет, сразу делает ретёрн.
Поэтому в этом случае все хорошо.
Если v-лист, то у нас все тривиально, ничего не происходит, куча остается корректной.
Переход.
Пусть у v есть дети.
Так, ну тут нужна опять картинка.
Значит, вот пусть есть ap, а v, которая потом меняется на x, есть какие-то дети.
Ну, детей 2 или 1, давайте в общем случае рассмотрю 2 ребенка.
Случай одного ребенка ничем не отличается.
Второй случай.
У меня число увеличилось.
Уменьшилось, это первый случай.
Я рассмотрю второй, когда значение увеличилось только.
Так, вот, значит, av увеличилось, стало x.
Значит, давайте я скажу, что au – это минимальный из двух сыновей.
Ну, мы помним, что в процедуре сивдаун я из двух детей выбираю минимальный, пусть au – это как раз минимальный.
Пусть au – это минимальный из сыновей.
au – минимальный из сыновей.
Минимальный в смысле значение в нём меньше и равно, чем в другом сыне, если он есть.
То есть не важно, что он стоит справа?
Не важно, конечно, он может быть здесь.
Здесь на ориентацию мне пофиг, кто слева, кто справа.
Может быть здесь.
Конечно.
Абсолютно не важно.
Неравенство уже выполняются?
Что слева направо?
Нет, это значение я.
Это не индексы, а значение.
Ага, хорошо.
Так, ну опять два случая.
Значит, случай первый.
Представьте себе, что x, хоть это число и увеличилось до x, но x всё равно меньше и равно, чем au.
То есть вот такое вот неравенство есть.
Тогда я утверждаю, что куча осталась корректной.
Куча осталась корректной.
Но вроде понятно, это значение только увеличилось, поэтому это неравенство осталось.
А поскольку au минимальный из сыновей и x меньше и равно, чем au, то x тем более меньше и равно, чем другой сын, потому что сын больше.
Да.
Нет, нет, было av стало x.
Там даже написано, становится x.
Я специально переписывал, именно становится x.
Вот.
Значит, в этом случае все неравенства сохранились.
И shift down ничего не делает.
Там была отдельная проверка.
Если значение в вершине меньше и равно, чем в минимальном сыне, то return.
Ну, точнее, там ничего не делаем.
И опять-таки shift down ничего не делает.
Что и надо.
Shift down 2 ничего не делает.
Как и надо.
Так.
Ну, второй случай.
x больше, чем au.
Ну, давайте опять я сделаю трюк с заменой.
Давайте я рассмотрю вот такое вот дерево.
Ну, точнее, такую кучу.
Значит, я в этой вершине напишу au.
Первый шаг опять заменить av на au.
Куча останется корректной.
Потому что, смотрите, я поднял сюда.
То есть я вместо av написал au, которое было больше обыкновенной, чем av.
Я считаю, что в этой вершине у меня остался ау.
То есть я вместо av написал au, которое было больше обыкновенной, чем av.
Я считаю, что куча изначально была корректной.
Поэтому это число больше обыкновенной, чем differentiate.
Я сюда поднял его же.
Значит, это неравенство стало более грубым.
Если я это число увеличил, значит, это неравенство точно сохранилось.
Но поскольку из двух детей я выбрал наименьшего,
то и это неравенство тоже сохранилось.
Поскольку я сюда поднял наименьшего из двух детей,
значит, m меньше равен другого сына.
Значит, здесь неравенство сохранилось.
поэтому куча осталась корректной. Ну а дальше я заменяю нижнее вхождение ау на х, заменить
нижнее вхождение ау на х. А дальше предположение индукции. У меня была корректная куча, я поменял
это число на х, увеличил его причем. Заметь, х больше чем старое значение ау, я увеличиваю это
значение и запускаю рекурсивно си в даун от у. Значит по предположению индукции я починю всю
кучу. После завершения этого запуска у меня куча станет корректной по предположению индукции
просто потому что эта вершина ближе к листьям чем в. Кажется конец. Тот же самый трюк я на самом деле
сделал. Я просто сказал, что вместо того чтобы их посвопать, я сначала подниму вот это число сюда,
куча будет корректной, а потом это заменю на х. А дальше по предположению индукции, потому что
вот в этом поддереве это уже более низкая вершина чем это, то по индукции вот это вот станет
корректной кучей, значит все станет корректной кучей. Успех? Нет? Давайте вопрос тогда. Да,
написано где-то было. Мы же сказали, что ав стало х и оно увеличилось, т.е. х больше чем ав, да,
это правда. Мы живем, пункт 2 это значит х больше чем ав. А 2 что вы сказали? Нет, х больше чем ав,
не нравится написано. Как раз нарушится, но нарушится также как в этом пункте 2. У меня
было ау, я его меняю на х, т.е. я его увеличиваю. Это ровно то, что я сейчас доказываю. У меня была
корректная куча, я поменял какое-то значение на х, причем оно увеличилось. В случае 2. А дальше
там рекурс или индукция, вот здесь вот станет корректная куча по индукции. Вы про индукцию?
А, ну это вы передоказали принцип мат индукции? Да, можно и так конечно, но мне не очень хочется
сделать. Так, ну чудно. Вот, все доказали. Значит, с корректностью разобрались, теперь давайте про
асимптотику скажу. Ну а асимптотика ответов на все запросы, кроме гетмина, это будет логарифом.
Значит, гетмин у меня будет за единицу, потому что это просто обращение к ячейке памяти,
а остальные, значит, экстрактмин, инсерт и декрески, у меня работают от логарифма. Ну логарифм,
потому что у меня у дерева будет логарифмическая глубина, и каждый из них я свел по факту либо к
севтапу, либо к севдауну. Они работают за время пропорциональной глубине дерева. Понятно,
почему глубина логарифма, или надо это расписать? Ну отлично. Потому что так работает. Ну я где-то
это использовал. Я использовал, что ау минимальный, потому что, например, вот здесь вот я когда меняю
это на х, и это не больше, чем ау, то оно точно не больше, чем это, потому что ау минимальный.
Ну вот тут если аккуратно проследить, то минимальность, ну, играет роль. Если бы я
брал произвольно, то там бы что-то сломалось. Так, ну супер, супер. Так, хорошо. Дальше давайте
тогда перейдем к сортировке кучей. Она же хип-сорт. Ну хип, потому что по-английски куча это хип.
Так, значит очень простой алгоритм сортировки кучей. Вот представьте себе, что у вас есть
последовательство элементов а1, а2 и так далее, ан. Как ее отсортировать с помощью кучи? Решение,
давайте мы n раз сделаем insert, insert а1, insert а2 и так далее, insert ан, потом n раз сделаем
экстракт мин. На каждом шаге мы выводим минимум из оставшихся, то есть и ту статистику, и ту
упрятную статистику на каждом шаге. Значит insert а1 и так далее ан, потом n раз экстракт мин.
Поскольку экстракт сначала вывел минимум, удалил его из кучи, потом получается минимум из оставшихся,
то есть второй минимум, а вторую порядку статистику, потом его удалил, потом минимум из оставшихся,
то есть третью порядку статистику, ну и так далее. Значит в конце вот то, что выведут все эти
экстракт-мин, это как раз порядок сортировки. Согласны? Что? Да, что? Надо сделать что еще раз?
Сначала экстракт вывести, а потом же удалять. А, да, ну в смысле вы имеете в виду get-min, да,
выводить? Ну, я имею в виду, ну понятно, что как бы экстракт с печатанием элемента, да, да,
это справедливо, что надо скорее делать get-min, потом экстракт-min, но можно сказать, что экстракт
выводит сразу число, он удаляет и выводит число, которое удалил. Вот. Ну и работает, конечно, за n
log n, потому что, как мы сказали, все запросы, что insert, что экстракт, работают за единицу в кучу.
Фу ты, за алгорифм, за алгорифм. У нас n insert, n extract, sum of n log n. Вот, очень простой такой алгоритм
получился. Следствие, очень интересное, что в частности, если ваша куча основана на сравнениях,
то есть так же, как и раньше, про числа мы умеем говорить только то, что их можно сравнивать,
про элементы мы умеем только сравнивать их, тогда не существует такой реализации кучи,
который бы insert и extract обрабатывал за единицу. Не существует кучи, я скажу так, реализации кучи,
реализации кучи, основаны на сравнениях, в которой экстракт и insert работают за единицу.
Insert работает за от единицы, потому что иначе мы бы научились сортировать числа за от n.
Даже не числа, а просто объекты. А мы знаем, что если мы умеем их только сравнивать, то быстрее,
чем мы их сравниваем, не обойтись. Да? Вот, очень простое следствие. Хорошо. Ну, еще раз, доказательства,
потому что иначе, если бы и insert, и extract я бы делал за единицу, тогда бы я научился сортировать
за линию. n insert за единицу, n extract за единицу, суммарно-линиейное время работы, а я бы сортировал
массив. Не понял? Не, еще раз, еще раз, смотрите, мне достаточно, наоборот, здесь достаточно какой-то
реализации сортировки, потому что если вдруг существует куча, в которой insert и extract работают
за единицу, то я умею сортировать за от n. Неважно, возможно еще более эффективные алгоритмы,
тогда еще быстрее, чем за линию мне сортировать. Ну и бог с ним. Уже противоречие. Да, по отдельности,
по отдельности, ну по крайней мере, с insert точно, да, с extract если заморочишься, тоже можно за единицу,
да, ну это по крайней мере за учетную, за амортизировано вот это вот. Так, хорошо, значит вот это в принципе
есть какой-то результат. Теперь, смотрите, hip-сорт можно еще несколько соптимизировать. Давайте мы
первое, что сделаем, это научимся вот это вот делать за от n. То есть вместо того, чтобы n раз
вставлять, давайте мы сразу воспользуемся тем знанием, что у меня все элементы даны заранее,
и давайте опишем процедуру hipify, как это обычно называется, это процедура, строящая кучу на
массиве заранее заданном. Ну по факту построить кучу, построить кучу на а1 и так далее а n. Вот, ну то есть
мы не будем пользоваться insert, который уже встроен в кучу и по одному элементу добавляет,
давайте мы напишем отдельную процедуру, которая по массиву строит кучу на нём. Алгоритм работает
следующим образом. В порядке убывания всех ишек запустите в даун, а ты. Конец. То есть смотрите,
вот пусть у меня был массив а1 и так далее а n. Я хочу на этой же памяти, вот в этих же ячейках
памяти так их переставить, эти элементы, чтобы выполнялось требование кучи. Но вот я утверждаю,
что если просто написать вот эти две строчки, то после их выполнения здесь станет корректной куча.
Нет, нет, там более тонкой будет. Да, вопрос какой-то ещё был. Севдаун и, да, вот то и,
которое бежит по циклу, оно ж севдаунец. Значит, давайте сначала докажем, что это вообще корректно.
Но это не очень сложно. Я утверждаю, что после и-то итерации цикла под дерево вершины и будет
корректной кучей. Почему? Ну индукция опять в порядке убывания и.
Понятно, что если и это лист, то после севдауна ты и всё под дерево будет кучей. Потому что если
и это лист, у него в под дереве ничего нет, это корректная куча. Здесь никакие неразрешения
нарушаются. Возможно с родителями, но они выше, они не в под дереве. Значит, для листи всё хорошо.
Дальше. Представьте, что мы доказали для всех и, там не знаю, n, n-1 и так далее, там n-200. Давайте
докажем для n-201. То есть вот у меня есть какой-то аи. Для всех больших и, для всех больших индексов
я уже севдаун и вызвал, и там у всех корректные кучи. В частности, у детей корректные кучи. Вот
это вот а2и, это а2и плюс один. Поскольку у них индексы больше, я от них запускал севдаун раньше,
и по предположению индукции могу считать, что здесь корректная куча. Здесь корректная куча,
и здесь корректная куча. Ну а дальше, что я делаю? Смотрите, у меня есть две корректные кучи. Я их
склеиваю через одно какое-то число. Фиг пойми какое. Единственное, что может нарушаться, это то,
что это число может быть слишком большим, чтобы быть корнем этого дерева. Потому что, если оно
меньше равно обоих сыновей, то делать ничего не надо, и так корректная куча. Единственное, что
может сломаться, это что, если это число больше, чем какой-то из сыновей, тогда севдаун это исправит.
Потому что, если бы это у меня была корректная куча, потом я сюда ставлю аи и запускаю севдаун
от и. Единственное, что может сломаться, это что, если это число слишком большое. Вот севдаун это
починит. Убедительно? Ну вроде все. Значит, тогда после всех этих севдаунов у меня куча будет корректной.
Так, еще раз. Почему идем в таком порядке? Потому что так работает. Второй вопрос не понял про индекса.
Упражнений на семинар. Что если делать в другом порядке, или если запускать сифтап, то можно
подобрать пример, на котором это будет некорректно. А в таком порядке будет корректно. Вот это только
что пытаюсь доказывать, по крайней мере. После и-тетрации цикла под дерево вершины и будет
корректной кучей. То есть вот и и все, что ниже, все, что в под дереве, это корректная куча. С индексами
не очень понял вопрос. Наверное, вы про то, что вот, ну как бы, я считаю, что это уже уже куча. То есть я
представляю этот массив как кучу вот в том смысле, что это дерево большое, в котором, возможно,
какие-то неравенства нарушаются. Дальше я беру и запускаю севдауны в обратном порядке. Для n, n-1,
и так далее, вплоть до единицы. Не обязательно, но довольно большой элемент, который меньше,
чем вот все, что выше. Да, это правда. Да, конечно, извините, да, больше, чем все его предки. Хорошо.
Мы не меняем, не меняем индекса. Всегда он меняет значение элементов, но не индексы.
Да, мне так и надо. У меня вот здесь было нарушение неравенства. Там, не знаю, здесь 5, здесь 3.
Но я их беру и меняю местами. Числа меняю местами. Да. Да.
В дереве отрезка длина массива n. Ну, еще раз, это у меня индексация такая же, как в кучу. У меня
всегда сыновья i, это 2i и 2i плюс 1. Я здесь никакого откровения не делаю. У меня всегда номерация такая.
Давайте без дерева отрезков, пожалуйста. Давайте без дерева отрезков, пожалуйста. Мы в куче сегодня живем.
Еще раз. Да, да, да. Можно здесь оптимизировать и запускаться от первого нелеста, например. Да,
можно не париться. В этот момент я считаю, что я доказал, что Hippie-Fi строит корректную кучу на той же памяти,
где исходно был массив. Причем, заметьте, еще раз, я переставляю исходные элементы, я не завожу новый
массив, куда я складываю кучу, как было вот в этой реализации. У меня были числа, я заводил отдельно
память для кучи и туда все сваливал заново, как будто бы с чистого листа. Так вот, нет, в этой
реализации я все делал на той же памяти, где исходно был массив. Так, это была корректность.
Теперь докажем, что это все работает суммарно за O от N. Вот этот цикл работает за O от N.
Ну, понятна оценка N log N. Мы знаем, что каждый севдаун работает за логарифм, за O от логарифма.
Если суммировать, получится O от N log N. Но это грубая оценка, потому что понятно, что севдауны,
например, для листьев работают за единицу. Если и это лист, то там нечего делать, мы работаем за единицу.
Ну и вообще, если вершина внезапно находится на глубине там, то есть если от нее расстояние до
листьев это K, то время севдауна ограничено точным числом K. Это O от K. Если от вершины и до листьев
вниз расстояние K, то севдаун работает за O от K. Давайте вот это тогда аккуратненько просуммируем.
Значит, смотрите, давайте я нарисую какое-то дерево. Я понимаю, что у него, ну давайте полное.
Давайте для простоты буду считать, что у меня дерево полное, то есть на первом уровне одна вершина,
на втором два и так далее до степени двойки. Ну такая, самая красивая картинка. Тогда понятно,
что на последнем уровне у меня будет N пополам вершин. Ну примерно N пополам, округлите верх,
ну короче примерно N пополам. На них на всех время работы будет единица. Ну это вот как раз то
замечание, что севдаун от листьев ничего не делает, и суммарное время работы севдаун на всех
листьях это N пополам на единицу. Дальше, когда мы запускаем севдаун от вот этих вот вершин,
да, спредпоследнем уровне, их здесь уже понятно в два раза меньше. Их здесь N на четыре и севдаун для
каждого из них работает за два, ну потому что надо как бы, глубина до листьев это два,
окей, там один, два, неважно, два, буду считать, что два, время работы будет двойка. Значит, здесь
на следующем уровне вверх будет N на 8 умножить на 3, ну и так далее. То есть по факту суммарное
время моих вот этих вот севдаунов всех, это следующий ряд. Согласны? Ну опять повторю,
это все в идеальной парадигме, что у меня дерево полное, если оно не полное, то, ну окей,
здесь просто будет не N пополам, а еще меньше будет листьев. На листьев тогда будет еще меньше вот
на этом уровне, поэтому здесь даже еще меньшее время получается. Здесь меньше N пополам,
здесь N на четыре на два или даже на один вот для этих вершин. Ну короче, тогда будет еще только
проще мне это делать, поэтому я рассматриваю худший случай. Так, хорошо, ну давайте я вот с этим
рядом немножко какую-то магию сделаю. Давайте из всех этих слагаемых вытащу одно из них. То есть
вот здесь вот я представлю N на четыре как N на четыре плюс N на четыре, вот это слагаемое,
здесь N на 8 плюс 2 N на 8, здесь N на 16 плюс 3 N на 16 и так далее. Что у меня получится? У меня
получится с одной стороны, то есть я вот из всех этих множителей вытаскиваю одно слагаемое. У меня
тогда будет N пополам плюс N на четыре плюс N на 8 плюс N на 16 плюс так далее, а останется вот
этот вот ряд с уменьшенными на один вот этими вторыми множителями. Останется в скобках N на
четыре на один плюс N на 8 на два плюс N на 16 на три плюс так далее. Еще раз, я все вот эти вот
произведения из всех этих произведений расщепил на два слагаемых. Просто первый
множитель и соответственно произведение вот этого на это минус 1. Тогда сумма сохранилась.
Вы знаете, что это? Это N. Ну там N минус немножечко, давайте напишу, что это не больше, чем N,
потому что это сумма геометрической прогрессии просто. Что дальше? Давайте вот с этой штукой
сделаем то же самое. Давайте здесь извлечем, давайте здесь разобьем все эти произведения. Ну так
что отщепим по одному слагаемому из каждого из них. Здесь будет тогда N на четыре плюс N на
восемь плюс N на 16 плюс по степеням двойки, плюс останутся вот эти вот все слагаемые с на
единичку меньшим вторым множителем. N на восемь на один, N на 16 на два, ну и так далее. Вы знаете,
что вот это такое? Это N пополам даже, ну N пополам, ну потому что это в два раза меньше, чем вот это.
Если с этим сделать то же самое, то получится там N на восемь плюс N, pardon, N на четыре, N на восемь
и так далее. И это мы опять знаем, что это 2N. Так что вот это все, не больше 2N. Такой хак.
То есть еще раз, я рассматриваю вот так вот сумму такого вида, разбиваю все произведения,
так что я отщепляю первый множитель, ну и все, что осталось. Тогда сначала у меня вылезет
сумма N, что-то останется. Если я здесь сделал то же самое, у меня вылезет сумма N пополам,
что-то останется. Здесь, ну то есть это по факту то же самое, только поделенное вот это вот от
исходного. Отличается типа на, просто делением на четыре. Вот это поделение на четыре, это вот это.
Ну соответственно то же самое, когда выделяю, здесь получается на четыре, потом еще раз выделяю на восемь
и так далее. В сумме вот эти все слагаемые дадут 2N. Хорошо?
А можете еще раз объяснить, почему такой ряд?
Почему такой ряд? Смотрите, вот давайте, вот рассмотрим вот такое дерево. В нем листьев примерно
половина, N пополам вот всех вершин. Ну потому что здесь один, два, четыре, восемь, на последнем
уровне половина от всех. Для них всегда он работает за единицу, поэтому суммарное время работает
всегда он на листьях вот это, N пополам на один. Сколько вершин на предпоследнем уровне? Вот столько,
в два раза меньше. Но на них всегда он работает за два действия. Ну не больше, чем за два действия.
На третьем с конца уровня вершин N на восемь, и там всегда он работает за три действия. Ну и так далее.
Вот, вот и ряд получился. Так, хорошо. Давайте быстренько, я попробую, ну поскольку все равно мы
больше не успеем, сейчас или успеем, а что надо-то? Нет ладно, давайте я скажу следующее. То есть мы
доказали, что хиппифай работает за линию. Вот, хиппифай работает за линию. Все, а дальше давайте
вернемся вот к хипсорту. Что мы получается сделали? Мы вот эту вот часть заменили на хиппифай за линию,
хиппифай за ОАТН. Так, дальше остается N раз экстракт минов. Ну, это мы сильно оптимизировать не
будем, но мы сделаем следующее замечание. Смотрите, вот экстракт мин выдает какое-то число. Ну то есть я
считаю, что там перед экстрактом я сначала getMin вызываю, он печатает число, которое удаляет, потом
его удаляет из кучи. Так вот, но мы знаем, что экстракт на самом деле, он не совсем удаляет
число из кучи, он на самом деле его перемещает на последнее место и как бы про него забывает,
уменьшает размер массива на один. То есть на самом деле само это число никуда не девается, оно в массиве
лежит. Получается, что после первого экстракт мина, какое число будет на N месте? Минимум. Потому что я
извлекаю минимум и кладу его на N место, на последнее место массива. То есть после первого экстракт мина
у меня в последней клетке будет лежать первая порядка статистика. Я извлекаю минимум, вспоминаем,
как работает экстракт мин. Он меняет местами корень и N элемент и уменьшает размер массива на один.
То есть он корень поместил вот сюда, он минимум поместил сюда. Что делает второй экстракт мин? Он
корень, то есть минимум в оставшемся массиве, помещает вот сюда. Поскольку корень это минимум,
то есть вторая порядка статистика, вторая порядка статистики перемещается ровно вот сюда и так далее.
На и-том шаге мы достаем из кучи и-ту статистику и кладем ее на и-тое с конца места. Поэтому N раз
применен на экстракт мин, по факту тоже сортирует массив только в порядке убывания. Если его теперь
развернуть, то мы получим сортировку этого же массива. И ее прелесть в том, что это так названа
сортировка in place. На месте, то есть без доп памяти. В отличие от всяких там сортировок типа слиянием,
когда мне нужно было для слияния двух массивов построить третий, куда надо сливать, здесь никакой
доп памяти нет, потому что хиппи-фай у меня без доп памяти. Я кучу построил на том же массиве,
который мне был дан. Потом я вызываю экстракты, но они эти элементы просто перемещаются в порядке
справа налево. И опять на той же памяти у меня лежит отсортированная версия массива. Только нужно
в конце будет поменять порядок, сделать реверс, поменять местами это и это, это и это и так далее.
И получается у меня сортировка на месте без доп памяти. А то есть от единицы дополнительной памяти.
Еще раз, чем плоха доп память? Ну, типа, ну вдруг она дорогая, вдруг у вас ее нет, вдруг у вас
настолько большой массив, что вы не можете себе позволить ничего еще выделять. Все, спасибо,
