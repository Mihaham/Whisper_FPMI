Ладно, ну наконец-то вот мы и дожили до дерева доминаторов. Значит, поехали. Что это вообще такое?
Значит, мы снова живем в нашем любимом flow-графе jr. Ну, то есть, как всегда, то есть у нас есть
вершина R, из которой доступно все. И мы сейчас будем этим пользоваться. Значит, смотрите,
значит, базовое определение. Здесь такое, значит, определение. Значит, вершина U доминирует над
вершиной V. Если любой путь от R до V, угадайте два последних слова.
Ну, правда, это три слова, а два слова, это называется содержит. Но суть, конечно, абсолютно такая.
Вот, вот, оказывается, в науке действительно бывает интересно рассмотреть и такие вещи.
Вот почему? Вот как-то не странно, на самом деле, эта штука возникает при построении компиляторов.
То есть, внезапно, если вы там будете читать какую-нибудь там книжку, там какой-нибудь Аха Ульманна,
еще какого-нибудь соавтора про компиляторы, то там неожиданно в какой-то момент ссылки на
доминирование будут. Мотивируются они чем? Потому что, ну, при компиляторе, то есть,
тут даже важно не столько построить компилятор, сколько оптимизатор. Вот, но оптимизаторы отчасти
иногда работают за счет того, что он обнаруживает, что у вас там есть какие-то ветки работы,
и какую-то ветку он неожиданно обнаруживает, вы не зайдете никогда. Ну, там так получилось,
там случайно. Вот, и тогда эту ветку неплохо было бы убрать. Вот, но для этого бывает тогда полезно
понять, действительно, для любой точки кода иногда бывает полезно. Вот верно ли, что если мы
придем вот в эту точку кода, то это означает, что мы были вот в этой обязательно? То есть, могли ли мы
как-то вот обойтись там без нее? Вот, ну, а корень, соответственно, это точка начала программы. Вот,
поэтому оказывается, что вот подобные вещи там вот очень, ну, вот действительно могут быть полезные,
действительно возникают, и их вот интересно рассматривать даже из точки зрения практического
применения. Ну, подробности это в соответствующих книжках про компиляторы, но я думаю, в свое время
вы обязательно на них наткнетесь. Ну, потому что у вас есть курс про компиляторы. Он называется,
он, правда, «Формальные языки», но... Ну, по крайней мере, про «Идейное начало» компилятор. Нет, есть
«Идейное начало». Скажите, у нас в рамках этого курса было, там, напишите с помощью флексовой
Бизона свой компилятор. Да, немного, не мало. Компилятор, ну, по-разному. В нашем случае это было,
ну, в моем случае это был какой-то компилятор такой урезанной версии Паскаля. Правда, тут оговор,
как компилятор Паскаля в Си, конечно, а не в Оссеблер. Да, тут важно, компилятор, да, просто если взять
словарное определение слова «компилятор», то это переводчик. С одного языка на другой. То есть чаще
всего у нас, когда мы говорим «компилятор», там, «глушный», он обычно переводит из языка С++ там,
на язык, ну, в лучшем случае, Оссеблеров, в худшем, просто на язык машинных кодов напрямую. Ну вот,
но на самом деле они могут быть промежуточные варианты. Вот. Так что вот. Ну вот, вот поэтому нам
это может, поэтому, скорее всего, в каком-то видео у вас это будет. Ну, а может быть,
если у вас там более техническая направленность, может быть, даже вы там более, как поаккуратно,
вы там глубоко вот копнете. Вот. Ну, а давайте вот пробовать. Вот нам очень хочется уметь
понимать. Вот дан граф, как всегда, там, как всегда, 100 тысяч вершин, 200 тысяч ребер, ну, или там
нольки накиньте сами. И нам очень хочется понимать, кто над кем доминирует. Ну, там что-нибудь в духе.
Данные две вершины, верно ли, что одна доминирует на другой, да или нет. Вот. Значит, как же это делать?
Ну, на самом деле, можно рассмотреть такое разминочное утверждение. Давайте попробуем
брать такую нумерацию. Такое. Лемма ноль. Лемма ноль. Во-первых, обозначение этого мероприятия.
Обозначение у нас будет У, Дом, В. Вот. Дом, В. Вот так это будем познаки. То есть осторожно, у нас тут сейчас будут обозначения,
и мы там с ними будем так хорошо развлекаться. Вот. И так, лемма ноль будет говорить так.
Ну да, если предполагать, что еще кто-то, можно стол было это отодвинуть.
Итак. Ладно, пока пишу. Значит, если У доминирует В и В доминирует В, то что?
Это называется екклидовость. Тут же нет неравенств треугольника. Тут скорее, если бы я тут
и писал В, то мог бы написать, то У доминирует В, была бы транзитивность. Но это очевидно, там такие вещи нет смысла прописывать.
Есть более интересные свойства. Если две вершины доминируют одну, то, в общем, я тут напишу заклинание, которое означает следующее,
что одна из них доминирует другую. Ну нет, это не екклидовость.
Но это отношение, оно обычно подразумевает определенную симметричность. А в данном случае у нас симметричности нет.
Поэтому я бы тут слово екклидовость употреблять по астерокси.
Это ориентированное свойство, что ли?
Ну не важно, ладно. Ну это симметричность.
Так вот. Но давайте для начала поймем, а почему это вообще так? Вот почему это вообще так?
Но давайте в общем рассмотрим. Доказательство очень простое. Давайте приблизим себя к тому, как это вообще выглядит.
Вот рассмотрим какой-нибудь путь до вершины W. На нем лежат У и В.
Ну без ограничений общности допустим, что У лежит выше. Я утверждаю, что У доминирует на В.
Почему? Ну мало ли. А вдруг найдется какой-нибудь другой путь, до которого В будет выше?
Ну да, можно и так. Но давайте тогда не плодить сущности, а просто применим такое простое рассуждение,
логика из которого нам пригодится еще сегодня не раз. Рассуждение очень простое. Пусть У не доминирует на В.
Тогда мы просто рассмотрим путь от Р до В обходной, который через У не проходит.
Тогда я утверждаю, что мы нашли путь до W, который не проходит через У. То есть дойти вот так до В, а потом от В до W.
Обратите внимание, кстати, эти пути могут и пересекаться, но ничего страшного в этом нет.
Ну помните, если есть какой-то путь, то есть и простой. Вот. И соответственно никакая вершина У в нем лежать не будет.
То есть, следовательно, У не доминирует на W. Противоречие. Следовательно, У доминирует на D.
То есть вот такое вот простое утверждение. На самом деле это утверждение можно даже усилить.
Может быть, не будем делать это в явном виде. Но теперь заметим вот что.
Дело в том, что если мы можем, на самом деле вот если у нас есть R и W, то мы можем рассмотреть все вершины, которые доминируют на W.
Кстати, а может ли быть так, что никто не доминирует на W?
Да, вот важный момент. На самом деле уж корень точно всегда доминирует.
Но все остальные, да, тут дальше нужна аккуратность.
Ну вот, дальше нужна аккуратность, потому что по-хорошему тут возникает вопрос, вершина доминирует ли вершина сама над собой.
Ну, как бы тут, как договориться, но там всегда в зависимости от этого надо оговариваться.
То есть по умолчанию, на самом деле, конечно, считается, что все-таки, когда мы говорим о доминации, все-таки вершина сама над собой не доминиет.
Вот, и тогда получается, что у любой, ну вот, получается, здесь обычно тоже сразу в определении помечают по понятным причинам, что U не равна корню. Обратите внимание.
Ну, потому что понятно, что над корнем по этой лодке не доминирует никто, да и бессмысленно.
Вот, но тогда получается, на W хоть кто-нибудь доминирует.
Ну, точнее, на G доминирует W и, возможно, еще кто-то.
Ну, давайте их вот, этих доминаторов и обозначим. A1, A2, A3, и так далее там какой-нибудь.
Вот. Ну, на самом деле, то есть доказательство, аналогичное это Лемме, говорит нам о том, что по факту, на самом деле, каждый из них доминирует над каждым.
Ну, кто выше доминирует над каждым из тех, кто ниже. Ну, просто с абсолютно тем же самым доказательством, правда?
Понимаете? Вот.
И тогда, ну вот. Ну, тогда вот идея такая. Нас будет сейчас интересовать самый нижний, вот эта вот вершинка.
То есть получается, можно вести такое определение.
Пусть, значит, у W не равно R.
Тогда непосредственным, вот внимание, непосредственным доминатором W или обозначение, вот мы его будем называть I'd'ом от W.
Да, это новое обозначение.
Значит, этим называется вершина.
Называется такая вершина, там V, что для любой вершины U, значит, которая доминирует W.
Значит, верно, что либо U равно V, или U доминирует над V.
Ну, и соответственно, простое утверждение. I'd'ом от W существует и единственный.
Да, давайте.
Вот стоит гнигнуть.
Ну, да. Ну, то есть, по сути, да. То есть, почему она существует?
Ну, доказательство такое. Рассмотрим вершину W, рассмотрим все, что над ней доминирует.
Как мы уже сказали, вот абсолютно аналогичным вот этому рассуждению образом, можно показать, что любая доминаторка, которая выше, доминирует на любой вершине, которая ниже.
Ну, да. То получается, что вот рассмотрим эту самую низкую окату, то получается, что это не просто он доминирует W, а все другие доминаторы W доминируют над ним.
Поэтому он существует. Ну, очевидно, он единственный. Нет, он существует. То есть, все, что...
Нет, наоборот, все остальные доминируют W, а вот их он больше не доминирует ни над кем.
Поэтому он единственный. Вот так. То есть, только он и больше никто.
То есть, по сути, вот самый низкий доминатор. Ну, самый низкий, конечно, можем обратить внимание, что мы еще не запускали DFS.
Но обратите внимание, что если бы, как бы мы не запустили DFS, тут, конечно, дерево DFS. Да, обратите внимание, мы говорим о дереве DFS, а не о лесе на этот раз.
Ну, DFS мы, естественно, запускаем только от корня.
Ну, тогда заметим, что, конечно, деревья там могут быть самые разные, но что мы можем точно гарантировать, так это то, что все вот эти вершины там обязательно на пути от Rw будут, причем ровно в этом порядке.
То есть, там где-то между ними, понятно, там они могут плясать любую кокозябу.
Вот. Поэтому получается, что item существует и единственный.
Конечно. Да, корень, то есть корень R доминирует над всеми вершинами.
Более того, заметим, что если я составлю ребра, то есть, если я возьму граф на N вершинах тех самых и добавлю N-1 ребро, соединяющее непосредственный доминатор вершины со вершиной, то получится дерево.
Ну, вот.
Значит, пусть у нас, я так-то пишу, T дом – это такой граф.
Это граф, значит, из тех же самых вершин и множество ребер item A w w, где w – это вершина, и вот так напишу, и, конечно же, некой.
Я утверждаю, что это дерево.
Почему я это утверждаю?
Ну, просто в силу транзитивности.
Ну, как-то странно было бы, чтобы, скажем, A доминировала над B.
Ну, потому что, заметим, что в данном случае это либо подвешенное за корень дерева, либо будет где-то за цикл.
Как мы сегодня утром, кстати, уже обсуждали.
Ну, потому что в каждую вершину входит ровно одно ребро.
То есть, поэтому там либо будут циклы, либо это будет подвешенное дерево.
Но если будут циклы, то получится что-то странное, что-то в духе A доминирует над B, B доминирует над C, C доминирует над A.
Это как?
Ну, как-то вот не очень.
То есть, поэтому циклов здесь не будет.
Вот. Циклов здесь не будет, а что это значит?
Ну, вот. Ну, это значит, что это действительно дерево.
Это дерево и...
Ну, вот. Ну, то есть, так вот.
Тут надо так написать. Утверждение.
T дом дерево.
Дерево с корнем В.
И? Нет.
Нет. Это не дерево отрезков.
Дерево чего?
Правильно. Да, вот и оно.
Да, забавно.
Да.
В общем, короче, это вот T дом.
Дерево доминаторов это, ну, короче, T дом.
Это дом.
Т дом. Нет, дом от слова доминация, а не от слова дом.
Собственно, дом в английском языке по-другому звучит.
А так это...
Вы рискуете нарваться, это как, знаете, там вам потребовалось что-то заклеить в самолете, вы подходите к справедливости и говорите скотч.
I want скотч.
И потом удивляетесь, что там что-то...
Что там пассажиры улыбающие улыбаются, ведут в бар и начинают чем-то угощать.
Попытки намекнуть, что I'm Russian приводят к тому, что вам просто убирают виски и предлагают водку.
Только потом приходит стюардесса и, наконец, объясняет вам на русском языке, что то, что вы искали, называется tape.
Ну, а так вот с домом тут может быть то же самое.
Так вот.
В чем дерево доминаторов?
В чем действительно очень приятная штука.
Потому что заметим, что если мы откуда-то возьмем такое дерево, то на запросы про доминацию теперь тогда мы там будем отвечать за мгновенно.
Потому что по сути речь будет идти о том, что даны две вершины, кто там предок, кто там чей предок.
Ну да, DFS-ик, in-out и там вложенные отрезки, в общем, элементарно.
Так что вопрос только один.
Как же нам это построить?
А, ой, я неправ.
Это не утверждение.
Это теорема один.
Ух.
Да.
Да, тут надо пояснить это просто.
Тут будем придерживаться номерации оригинальной статьи.
Угадайте, какого автора.
Тарьяна?
Да.
Впрочем, я не знаю.
Или нет.
Нет, дело в том, что нет, нет, там такие-то.
Тарьян там соавтор.
Там первый автор, там кто-то на букву L.
Вот.
Так что там соавтор.
Так.
Там кто-то на букву L.
Вот.
Так что там совместно какая-то разработка.
Но Тарьян тут тоже есть.
Да.
Да, поэтому и в их терминологии это называется теорема один.
Но я не буду полностью в нее писать, потому что тут они вообще говорят, запустим DFS и перенумируем вершины в порядке входа в них.
Ну короче, нотом.
То есть в нашем случае давайте забегем название вершины ее таймыном, по сути.
Но мы с вами этим заниматься не будем.
Ну вот.
Ну теперь возникает вопрос.
Что же нам тут делать?
Вот.
Ну разные там варианты могут быть.
Ну значит.
Ну давайте смотреть.
Как же это можно построить?
Как же это можно построить?
Вот.
Ну в принципе конечно да.
В принципе можно построить ZNM.
Как построить ZNM?
Ну очень просто.
Для каждой вершины можно легко понять за один DFS, над кем она не доминирует.
Логично, да?
Ну да.
Ну там условно говоря, выкинуть ее из рафа и запустить DFS.
До кого дошли, над тем она не доминирует.
Вот.
Ну это вот.
Да.
Ну это вот NM.
Ну не начинается это, потому что там кто-то предлагает там делать какой-то упихон с масочками.
Не-не-не, мы это не будем.
Нет, тут просто надо упомянуть, потому что в этом месте сами там авторы статьи говорят, что там разные алгоритмы есть.
На тему того, что давайте в каждой вершине хранить N-битную масочку, на тему того, кто над ней еще доминирует.
Еще?
Да.
Ну там просто идея в том, что изначально как...
Ну там так.
Там уже написано, изначально все единички, ну кроме нолика, ну там изначально единички, ну в том числе и она сама, ну и там будет идея, iyi, что идиничка может вместо еще доминировать, но если нолик, значит соответствующий, вершина точно не доминирует.
Ну вот, и там будет идея, что если у вас тут в вершине У хранится масочка и вида триб disfrragt большину, то значит эту Масочку можно проэндить вот этой масочкой.
Ну конечно в нее надо вершину У только добавить.
То есть можно про entity, тогда все это будет корректно. Ну и, конечно, в вершине r, естественно,
масочка состоит только из вершины r. Но утверждается, что, а давайте пропихивать
эти операции пока можем. То есть получается там, если точка что-то в духе там, если втупую n
квадрата m поделить на 32, ну бит маски потому что. Но тут, как они говорят, что иногда бывает,
вон там. Тут ссылаются даже на книжку такую, давайте тоже на всякий случай помянем,
может вы встретитесь. Значит, такая есть книжечка. Акхо Уильямс. Ну я не знаю, может, конечно,
там было два ахо, но мне об этом не известно. Скорее всего, альфред ахо он все-таки один. Ну вот,
principal of, вот внимание, кажется, что я сейчас напишу компьютер, но я заменю две буквы. Да,
такие похожие слова. Principle Compiler Design. Вот есть такая книжечка, на нее тут почему-то
ссылаются. Ну вот, видимо, этот алгоритм взят оттуда вот с n квадрата m поделить на 32. Но при этом они
говорят, что если говорить о том, ради чего это разрабатывается, то часто, то есть ради того,
чтобы там оптимизировать какие-то программы, видимо, уже в ассемблере, то в ассемблере часто
бывает, что граф устроен примерно следующим образом. То есть утверждается, что у вас есть,
то есть может быть у вас есть, собственно, дерево DFS, и зачастую оказывается, что граф устроен так,
что в этом графе есть, по сути, помимо дерева DFS, только прямые и обратные ребра. То есть там
условно только вот такого рода ребра и вот такое вот. Тут утверждается, не будем сейчас это продумывать,
что на самом деле там подобного рода алгоритм с масочками можно упихать за не n квадрата m
поделить на 32, а nm поделить на 32. Ну и, конечно, нельзя не ответить, что на практике, конечно,
в реальных графах этот алгоритм, возможно, работает еще быстрее. Ну а, к счастью, может быть, из-за
того, что тут не так много ребер. Ну здесь это такие вот практические сведения вот тут. Так что,
если подробно, видимо, это вот вопросы к аховинемсу, соответственно. Так что может когда-нибудь вам
пригодится. Впрочем, это все нам не важно. Наша ставка все равно как минимум n лог m или хотя бы,
скажем так, e лог v, ну хотя бы. А на самом деле голубая мечта у нас е на обратную функцию Акермана.
Построение дерева доминаторов. Вот такая вот наша ставочка. Так что редкий случай, мы тут
поговорили, зачем это надо вообще. Вот, значит, поехали. Так, ну, определение можно стирать.
Да, вроде тут уже все все поняли. Собственно, до этого момента, в общем, ничего сложного-то и не было.
Значит, смотри, происходит следующее. Так, значит, далее, далее, далее. Значит,
нам поможет тоже мистическая лемма. Значит, мы ее будем называть лемма-1, хотя иногда на нее ссылка
идет как на лемму-9. Ну, потому что, ну, возможно, она просто лемма-9 из другой статьи какой-то,
я уж не помню какой. Но мистическая лемма следующая. Значит, говорит она так. Все-таки
запустим DFS из, соответственно, R. Значит, пусть у нас есть ребро, пусть у нас есть ребро УВ,
причем у этого ребра есть... Нет, вру-вру-вру-вру, неправда. Не так. Пусть, значит, ребро тут не
причем. Значит, пусть time in от V меньше, чем time in от W. Тогда любой путь, ну, бывает же такое,
что между ними будет. Любой путь из V в W. Ваши ставки. Что тут дальше будет написано? Вот, кстати,
что можно сказать про путь, который ведет из вершины с меньшим time in, из вершины с большим time in?
Нет, ну, не настолько. Ну, не обязательно. Ну, если вы прямым считаете ребро дерева DFS,
то, конечно, да. Ну, может быть, просто V пред W. Тогда просто по дереву. Ну, в противном случае,
да, без перекрестных или обратных ребр не обойдешься, конечно. Тут есть более интересные
свойства. Да нет, нет, нам она пригодится. Любой путь из V в W содержит какого-то кодовое
слово, какого-то общего предка. Внимание, не наименьшего, а какого-то общего предка.
Нет, причем тут дерево-доминатор? Нет. Давайте уточним. Да ладно, у нас два дерева. В дереве DFS.
Нет, мы продолжим, видимо, мыслить в основном терминах, что у нас есть DFS, есть дерево DFS,
есть вот это все. То есть в дереве доминаторов нам обычно таймыны не понадобится. Вот такая красота.
Осталось только выяснить, да, почему. Ну, идея очень простая. Ну, во-первых,
ну, если, ну, очевидно, если кто-то из них является чьим-то предком, то все очевидно, правда?
Ну, утверждение, если V предок W, то любой путь из V в W содержит общего предка V и W в лице
самого V. Да, если W предок W, то тоже самое. Поэтому нетривиальный случай, когда V и W
никем друг другу не являются. Ну, давайте воображать себя, ну, воображаем интуитивно,
как всегда, да, что когда мы нарисовали какое-то дерево, то есть DFS обходил слева-направо, да.
Значит, тогда у нас было так. Жила была вершина R, она тут ходила-ходила-ходила. Вот нашелся вот
это вот LCA от V и W, там вот где-то вот тут V, где-то вот тут W. Ну да, между ними может быть все что угодно,
значит вот тут, тут ребрышка и поддерево, тут ребрышка и поддерево. Вот. Ну, теперь давайте думать.
Мы догадываемся, что рано или поздно вершина V, то есть из вершины V, то есть вот из этого поддерева,
даже не V, а вот этой вот вершины, которая передал LCA, мы должны из этого поддерева как-то
выйти, правда? Вот. Но теперь давайте думать, куда мы могли выйти? Ну, главное, по какому ребру?
Ну, выйти мы, как мы уже выяснили, мы могли либо по обратному ребру, либо по перекрестному ребру,
правда? Но если мы вышли по обратному ребру, то, собственно, в общий предок, собственно, мы,
то есть в предка LCA мы попали, может даже в сам LCA. Если же нет, то мы попали в какое-то, то есть это было перекрестное
ребро, то есть шел у нас тут вот какой-то путь, и тут бабах, перекрестное ребро. Как мы помним,
перекрестное ребро у нас ведет из вершины с большим таймином в вершину с меньшим таймином, правда?
Вот. То есть, соответственно, еще меньше. Но тогда это нас, ну, чему это нас приводит? Но приводит
нас это к следующему, смотрите, что на самом деле мы можем теперь рассматривать, что тут вот, как бы
мы в корне рассмотрели некоторые поддеревья, потом перешли к этой вершине, еще вот тут рассмотрели,
потом еще вот тут рассмотрели, ну и так далее, да? То есть вот эти деревья, в чем они рассмотрены,
можно сказать, в порядке возрастания тайминов, да? То есть это, в принципе, все вершины, которые были
рассмотрены там, соответственно, до, понимаете, да? То есть, заметим, что, то есть, на самом деле,
заметим, что если мы вот рассматриваем вершины с таймином меньше, чем вот это хотя бы, да, то что
это за вершины? Это вот эти все вершины и, соответственно, вот эти вот все деревья слева, правда?
Но заметим, что если у нас из этого поддерева перекрестное, то оно ведет вот в какой-то из этих
поддеревьев. И в принципе, да, то есть оно попадет в какое-то вот тут поддерево, ну я не знаю, вот такое,
тут оно тоже погуляет и из него тоже как-то выйдет. Если оно выйдет вот там из него через обратное
то, соответственно, оно тоже окажется в общих предках. Если нет, то оно пойдет в еще одно поддерево,
но поддереве, но поддереве рано или поздно закончится. Ну вот, вот, ну соответственно,
ну выйти-то, ну вот, ну оно выйти-то обязательно из всех этих поддеревьев должно, потому что оно
должно попасть в вершину с таймином больше. Ну вот, следовательно, действительно получается,
что рано или поздно, то есть из этих, то есть из всех этих поддеревьев в совокупности выйти можно
только в общие предки. То есть как бы из каждого поддерева можно выйти в соседние,
но из всех их можно выйти только через обратное ребро. Вот такая логика простая. То есть возможно,
да, можно подумать, может быть как-то можно и по-другому это доказать. Ну там что-нибудь в
духе, да, то есть там не знаю. Ну что не в духе, предположим, ни одного общего предка нет,
тогда там рано или поздно мы там впервые попадем в вершину, у которой таймин больше, ну у которой там,
не, но есть вот как минимум лца вот это, да. Ну нет, общий-то предок у них по-любому есть,
вопрос не в этом. Я имею в виду, пусть есть путь, рассмотрим путь от В до W, в котором этих вот
общего предка В и W нет, вот фантастически повезло. Вот, и тогда вот. Чего-чего? Ну да, таймин,
да, правильно, то есть таймин увеличивается только либо по дереву DFS и по прямым ребрам. Ну да,
то есть поэтому да, ну поэтому можно сказать так. Ну вот, то есть действительно, ну вот, хотя тут
как бы вопрос, мало ли где это прямое, где это прямое ребро было. Да, поэтому тут возможно доказать,
допил доказательств, все равно приведет к этой картинке. Ну собственно не суть, хотя может быть,
может быть я просто запамятовал в конкретной статье, может там и более простые доказательства есть,
но это неважно. Как бы, ну смотри, все это вот лемма, то есть полезное утверждение, нам его стоит
запомнить. Давайте, давайте, главное мне их не забыть потом, но почему-то решаем и вот так вопрос.
Так вот, и так запомнили лему, будет она у нас такая, лемма 1. Вот и теперь смотрите,
ведем, ну вот, значит как же нам, а мы ищем дерево доминатора, то есть это пока такое просто
веселое утверждение из теории DFS. Ну а что, ну DFS супер концепт, как видите, да, это сколько,
сколько всего, дайте, то есть в принципе, да, в принципе еще чуть-чуть так покопать и, может быть,
вам надо было бы давать там теоретический листочек, там определение DFS, там и 15 задач
подобного рода. Да, ну там третий из которых идет лемма о белых путях, например. Ну может и да,
кстати, да, может и действительно даже было бы очень весело. Так, вот, надо будет подумать об этом.
Так вот, но для того, чтобы найти доминаторы, нужно будет найти полудоминаторы.
Ну да, стандартные шутки. Так, и так, определение. Пусть, как всегда, w не равно r. Тогда смотрите,
тогда, значит, мы введем такое понятие, значит, asdom a w. Это будет называться полудоминатор. Тут
даже понятная темология, semi-dominator, точнее semi-dominator. Почему asdom, честно говоря, я не знаю.
А, immediate, thank you. So, asdom. Что это такое? Значит, это, ну, мы напишем так, argmin таймы на t.
То есть, минимальная по таймыну вершина, обладающая некоторым свойством.
Значит, существует путь v равно v0, v1, v2, vk равно w. Но не просто существует путь, а такой что?
То есть, ну вот, что time in от v этого строго больше, чем time in от w, где i равно 1, 2 и так далее,
k минус 1. То есть, обратите внимание. Тут очень оригинально обратите внимание, что все, то есть,
должен, если на русский язык перевести, то хорошей назовем вершину, из которой можно дойти до w,
используя в качестве промежуточных, именно промежуточных, только вершины больше по таймыну,
чем w. Но для самой вершины v такого требования нет. Сама вершина v может быть по таймыну меньше w.
Ну, как-нибудь там, я не знаю, например, скакануть там по обратным, спуститься в соседнее, нет, по обратным нельзя.
Нет, почему? Тут вопрос, где мы стартуем. Тут как бы...
Даже не мистическим образом. Если у вас есть, например, просто прямое ребро из корня в w, то корень, да,
вполне может оказаться. Вот, ну, конечно же, если это не ребро дерева DFS. Хотя если ребро дерева DFS,
то это нам тоже подойдет, обратите внимание. То есть, это означает, что, по идее, хоть один
кандидат есть. Это родитель в дереве DFS. То есть, обратите внимание, это утверждение верно,
если промежуточных вершин нет вообще. То есть, это в принципе означает, что вот этот таймын от v
окажется меньше, чем таймын от w. Обязательно, потому что родитель нам подходит. То есть, либо он,
либо еще меньше. Но тогда отсюда возникает такая лемма 3. S дом от w. Ну, так скажем, давайте,
собственный предок. Предок w, ну, естественно, в дереве DFS. Так, давайте я T DFS буду писать. Вот,
давайте я веду понятие T DFS в смысле дерева DFS. Думают понятно, да? Как T дом, только T DFS.
Собственный это означает не совпадающий сам с собой. Ну, собственно, так же, как и
собственный суффикс. Ну, часто употребляют такие выражения, когда обсуждают префикс функции.
Собственный префикс.
Счастливые люди, мы как-то без этого обошлись.
То да, тут и проблемы не было. У меня в конспекте ее нет, но судя, потому что у меня прям жестко
написано, что это лемма 3 и лемма 4, видимо, я решил просто писать номера в том порядке, в котором они
идут в статье, чтобы там, если будете открывать статью, собственно, чтобы ориентировались. Я подозреваю,
что леммой 2, там могло быть утверждение о том, что там таймын S дом меньше, чем таймын от w.
Но мы это просто проживали, это утверждение, мы его используем в доказательстве леммы 3.
Да, кстати, а как мы ее доказываем? Очень просто. Дело в том, что мы...
Нет, да, мало ли, но там могут быть вершины из соседних деревьев. Но там идея очень простая.
Мы знаем, что S дом от w по таймыну меньше. Но еще мы знаем, что любой путь из него в w тогда,
по лемме 1, вот любой вот этот вот путь, будет содержать общего предка в A и W.
То есть, ну вот, будет содержать... Но кто может быть общим предком в A и W?
Ну, заметим, что вот эти промежуточные вершины быть предками w не могут, потому что они по таймыну
побольше. Значит, этим общим предком в A и W может быть либо вершина сама в A, либо w. Но w вряд ли
будет это родителем в A, потому что в этом случае тогда вершина в A окажется по таймыну больше,
чем w опять. Следовательно, вершина в A будет общим предком в A и w. То есть, вершина в A будет
предком в W, доказательство окончено. Нет, просто там вот я поэтому подчеркивал слово какой-то
общий предок, именно какой-то. Нет, лемма была в том, что если у вас есть две вершины и у первой
из них таймын меньше, чем и второй, то любой путь от первой до второй содержит их общего предка
какого-то. Ну, вы можете легко привести просто в уме пример, что это не обязан быть лца. Ну,
пример такой, вы ведете в любого общего предка обратное ребро, а оттуда ведете прямое. Вот,
например, так. Поэтому там никакой конкретный общий предок там лежать не обязан. Так что вот
такая вот, такой вот веселый лемма. Вот, собственный предок. Значит, лемма поинтереснее.
Ну, хотя нет, это тоже неплохая. Нет, на самом деле тут логика такая. То есть, на самом деле,
смотрите, у нас просто какая возникла ситуация, я уже могу начать рисовать картинку. Вот жила была
W, жила была R. У нас есть айдом, который, очевидно, является собственным предком. И есть эздом.
Вот, оба лежат на пути от R до W в дереве DFS, правда? Да. Ну, точнее так, эздом мы доказали,
что лежат, айдом, ну, потому что где ему еще быть? Вот. Теперь внимание, вопрос, а кто выше? Ну,
если они не совпадают, конечно. А такое может быть. Ну, вот ваши ставки, кто может быть выше,
если они не совпадают? То есть, лемма формулируется так. Дом от W, предок,
не обязательно собственный. Дом от W. Да, задача. Вот в эти два места надо вставить буквы I и S.
Внимание, вопрос. Куда надо вставить I, а куда S?
А, эздом, очевидно. Почему? У нас есть путь из эздома в W, в котором все промышленные вершины имеют I,
да, прям вот все правее. Вот мы вот так вот нарисовали. Ну да. Да, то есть, действительно, если эздом лежит выше айдома,
то тогда у нас есть путь из R в эздом, а из эздома вот по пути справа, то есть по всем пути с промежуточными вершинами больше W в W.
Но тогда мы ухитрились обойти айдом, потому что здесь вот противоречие с определением айдома. Следовательно, сюда мы пишем букву I и сюда мы пишем букву S.
Да. То есть, оказывается, что айдом не ниже эздома, а может с ним и совпасть. Что? Что может совпасть? Ну, привести пример.
Ну, лемма 5 я вот не знаю. В правиле мы называть это леммой 5. У меня тут на эту тему не написано, хотя, конечно, очень хочется.
Ладно, придется писать утверждение, хотя оно по важности не менее важно. Ну, ничего страшного. Нет, вопрос не в этом.
Нет, на самом деле интересное свойство такое. Интересное свойство. Ладно, с леммой мы с этим разобрались, тут доказательств вопросов нету.
Значит, смотрите теперь. Лемма, ладно, утверждение. Возможно, лемма 5, может быть, я не знаю. Но суть там следующая.
Если заменить, ну вот, у меня вот написано это так. Если заменить в графеже ребра не из дерева,
а ребра с дома w запятая w, ну и как всегда w лежит в без корня. То есть, смотрите, мы берем граф, оставляем в нем только дерево DFS,
и к нему добавляем ребра в каждую вершину из вот бывшего полудоминатора. Вот, понимаете, да?
То есть, если я утверждаю, то айдомы, да и эсдомы, в общем-то, не поменяются. Да, это пожалуй даже не лемма, а скорее неформальное объяснение того, что будет дальше происходить.
Хотя, в общем-то, мы сейчас можем попробовать это доказать. То есть, вот утверждается, что граф можно упростить. То есть, заметим, что если у нас останется вот такой граф, то у нас будет только ребра дерева DFS и еще несколько прямых ребр.
Именно прямых.
Нет, вообще все уберем. Нет, вообще все, еще прямые тоже уберем. А взамен оставим вот эти. Хотя, если мы там прямые оставим, то хуже не будет. На самом деле.
Но лучше убрать и оставим только эти прямые. И вот утверждается, что айдомы от этого не поменяются. И эсдомы тоже.
Ну давайте думать. Ну давайте начнем с разминочки. А почему эсдомы не поменяются?
Да, но тут, конечно, надо, особенно про эсдомы, надо оговориться. Дело в том, что эсдомы по определению, определение эсдомов привязано не только к самому графу, но и к тому, каким образом мы запустили в нем DFS, правда?
Ну, к таймэнам. Но, очевидно, в таком графе можно запустить DFS так, что дерево DFS будет ровно тем же, правда? И обход будет ровно в том же порядке. Согласны?
Ну вот, то же самое. Ну просто главное оставить те же ребра дерева DFS в том же порядке и к ним только уже потом приписать все прямые. Тогда DFS их обойдет ровно так же.
Так вот, с учетом этой оговорки, эсдомы, то есть ни у какой вершины W, эсдом не поменяется. Почему он не поменяется?
Ну, во-первых, заметим, да, но заметим теперь следующее. Давайте вот смотреть. Вот у нас опять R, вот у нас был W, да?
Теперь, если у нас в новом графе, ну, точнее так, вот был старый, и вот давайте вот для понятности, стал новый. Да, путь дерева DFS один и тот же.
Ну, во-первых, старое эсдомы мы не потеряем, потому что из старого эсдома тут просто прямое ребро, это нормально.
Да, ну теперь возникает вопрос, да, то есть не окажется ли, то есть если тут вот был эсдом вот этот вот, да, если тут был эсдом с каким-то там путем вот это вот эсдом от W, да, то тут как бы...
Значит, я догадываюсь, тут просто прямое ребро то же самое, то есть кандидатом он будет. Тут возникает вопрос, а не может ли так оказаться, что тут кто-нибудь выше?
Неожиданно в новом графе оказалось. Ну да, то есть заметим, что у нас есть, да, то есть заметим, что у нас есть только один путь.
Помните, да, то у нас есть только один путь из промежуточной вершины, которая больше, это тупо прямое ребро прямо в W.
А почему не может быть час? В предко W нельзя, у него что-нибудь больше, чем в W?
В предко W там N меньше.
В потомном смысле, может ли быть прямое ребро, которое ведет ниже, чем в W и потом наверх?
Да, а ведь действительно. Нет, тут все еще хуже. В потом, когда W, то ничего страшного, потому что мы из этого дерева потом не выкарабкаемся без обратных,
потому что у нас только прямые ребра есть.
Ну тогда понятно.
Ну да, то есть теперь, да, заметим, что у нас в этом графе нет ни прямых, ни обратных ребер, ни перекрылстых.
Поэтому если случайно, этот путь, конечно, может отправиться в какое-нибудь другое поддерево или даже в поддерево W, но просто он из него потом не выйдет.
Поэтому, то есть единственный путь, который мы тут можем пройти, это...
То есть это да, но у нас двух таких ребер прямых быть не может.
Иначе бы ошибка была.
Ну да, потому что у нас только одно такое ребро.
Вот.
Поэтому другой никто не окажет. То есть мы, конечно, могли бы спустить...
Там может быть это прямое ребро тут идет в какого-нибудь соседа, да, и потом, но мы из этого поддерева потом не выберемся.
Так что хорошо, разминочка проведена.
Эздомы не поменялись.
А теперь ставочка.
А теперь ставочка. Ну вот, а теперь более интересное.
Почему айдомы не поменялись?
Доминатор непосредственный.
Ну в принципе для этого, конечно, достаточно показать, что на самом деле кто доминировал, тот доминирует, а кто не доминирует, тот не доминирует.
Но давайте думать.
Жила была вершина.
Вот как всегда давайте сказка.
Про красивого, умного, смелого юзера.
Ну вот, и теперь смотрим.
Давайте думать.
Предположим, что у доминирует w.
Рассмотрим теперь тут вершину у.
Я утверждаю, что и в этом графе у доминирует w.
Почему так?
А просто давайте подумаем. Предположим, что у не доминирует.
Тогда, то есть если у не доминирует, то это означает, что мы тут идем от r, причем вариантов-то у нас нет, помните, мы идем-идем по этому пути и там иногда делаем обход.
То есть единственный вариант, когда здесь у не доминирует над w, значит было прямое ребро, которое ведет из предка у в потомка у.
Ну в смысле появится, я имею в виду в этом графе.
Я справа это то, что новый граф, а это то, что было.
Но если рассмотрим вот это ребро, тут какая-то вершина x, а тут какой-то s дом от x.
Но тогда это означает, что у нас тут был какой-то вершина x.
Тут была s дом от x, тут какой-то x.
И получается очень интересная вещь.
Ведь от s дома от x до x был какой-то путь заведомо в обход у.
Почему в обход у? Потому что по таймы тут все вершины были больше, чем x.
Следовательно, если у не доминировало тут, то у не доминирует и тут.
Ну и как следствие, то есть если у доминирует тут, то у доминирует тут.
Так что теперь остается доказать, что наоборот, если у не доминирует тут, то оно не доминирует тут.
Ну мы доказываем, что у не доминирует над w в этом графе.
Справа налево пусть оно не доминирует.
Пусть у не доминирует над w.
Тогда есть путь от r до w.
Но заметим, что этот путь, единственный способ обойти w, это скакнуть по прямому ребру из предка у в потомка у.
Рассмотрим это ребро.
Что?
Обойти у, да. Если я иначе сказал, прошу прощения.
Тогда рассмотрим, пусть это ребро ведет из издома x, бывшего издома x, в x.
А что бывшего, мы доказали, что издомы не меняются.
Тут может показаться, что издома x обязательно корень, но это конечно же не обязательно так.
Так вот, хорошо.
Тогда я утверждаю, что мы и в этом графе могли обойти у.
Следующим образом, идем от r до издома, потом идем по этому обходному пути в x, то есть по всем этим вершинам, которые по таймыну больше, чем x.
А потом из x доходим до w.
То есть если обход есть здесь, то обход есть здесь.
А теперь надо наоборот, что если есть обход здесь, то есть обход здесь.
Понимаете, да?
Ну, значит, давайте смотреть.
Теперь тут уже придется чуть-чуть поработать, но наша Великая Лемма-1 сейчас спасет и здесь.
Мужская Лемма, да.
Так, ну, значит, давайте разбираться.
Предположим, что здесь какой-то обход у есть.
Вот.
Ну, предположим, мы говорим так, что пусть рассмотрим вершину у, вот предка w, и пусть она не доминирует w в этом графе.
Тогда, значит, существует какой-то тут путь на этот раз, ходящий там вообще как угодно.
Но тогда, да, я утверждаю, что он и тут доминатором не будет.
Ну, соответственно, доказательства может быть примерно следующим.
Какое тут может быть доказательство?
Ну, вот, значит, смотрите.
Какая тут диспозиция?
Значит, сейчас мы к этому w будем...
Что ж там?
Да, значит, существует путь.
Ну, тут надо рассуждать аккуратно, потому что...
Ну, что значит сам по себе путь?
Сам по себе путь может ходить тут как угодно.
Да, то есть вообще, вообще рандомный этот раз.
Ну, утверждается, что что-то про эздомы выжить здесь все-таки можно.
Чего?
Ну, какие-то вот...
Ну, хочется показать, ну, на самом деле нам что хочется показать?
Нам хочется показать, что здесь шестеренчатый путь, который мы уже нашли.
Ну, мы уже нашли.
Что здесь найдется какое-то ребро в обход.
Причем желательно, чтобы оно еще и не выше w шло.
Значит, как же мы это докажем?
Как же мы это докажем?
Ну, вот.
Но давайте смотреть так.
Итак.
Значит, рассмотрим.
Вот давайте воспользуемся LMA1.
Помните, LMA1 нас говорила, что любой путь от вершины с меньшим таймином к большим таймином
будет проходить через какого-то их общего предка, правда?
Тогда теперь смотрите.
Давайте на этом пути у нас есть...
Значит, на этом пути у нас обязательно найдутся какие-то предки u, правда?
Тогда давайте на этом пути рассмотрим с точки зрения внимания этого пути предка u.
Да, вот в нашем случае он вообще вот это.
Да, он не обязательно, конечно, именно самый высокий или самый низкий,
но просто давайте идти по этому пути, какие-то из этих вершин будут предками u.
Давайте рассмотрим того предка, который встретился последним.
Что ж там?
Вот пусть это самый последний.
Более того, без ограничений общества...
На самом деле я вот даже давайте соседнюю картинку нарисую.
Мы вообще можем считать, что у нас путь...
То есть вот у нас жил был r, жил был w, жил был u, да?
И в общем-то без ограничений общества можно считать, что мы пришли в какой-то вот это вот последнего предка.
На самом деле пришли вот так, да?
Потом как-то пообходили.
И пришли в w.
Но не просто как-то пообходили, а обнаружили, что ни одной вершины между u и r после этой вершины нет.
Вот такое мы утверждаем.
Вот.
С одной стороны.
С другой стороны, рано или поздно мы наткнемся на вершинку, которая лежит между u и w, правда?
Ну в худшем случае это будет сама вершина w, правда?
Ну мы в w придем, потому что мы в него идем.
То есть знаете это там из...
Да, сегодня день глубокий.
Нет.
Нет, ну да.
Нет, на самом деле это еще...
Можно отсталаться уже еще с задорного, потому что там было еще там про войну в Ираке.
Там говорилось так, что там север Багдада просили не бомбить, потому что там снимается сериал там что-то с Хусейном в большом городе.
Там на роль Хусейна там, называется, пробовались там что-то типа там Кирана и Джулия Робертс, там и Макали Калкин.
Но гонорар был такой, что согласился сняться сам с Адам Хусейн.
Вот.
Ну вот здесь примерно то же самое.
То есть в худшем случае в роли вершины w, может быть, предка вершины w, может выступить сама вершина w.
Так вот.
Рассмотрим первую из них на пути.
То есть первую после вот этой.
То есть тогда получается этот путь тоже без ограничения общности.
Вот.
А можно сказать, что у нас есть путь.
То есть который шел-шел-шел по этому пути, потом куда-то там ушел, потом пришел в между w и после этого уже дошел до w.
Что ж тут сопротивляться, да?
И вот эти все вершины никакого отношения к пути от w не имеют от слова вообще.
Понимаете, да?
Тогда смотрите.
Тогда интересно так.
Если это вершина x, то я утверждаю, что это кандидат Вестомы.
Нет, именно кандидат.
Нет гарантии, что это.
Мало ли там какие пути еще могут быть.
Но я утверждаю просто следующее.
Я утверждаю, что все вот эти вершины, они по таймыну больше, чем x.
Почему так?
Потому что если кто-то из них меньше, вот допустим, вот этот вот меньше, да?
Ну вот.
То тогда заметим, что вот на этом вот пути должен быть их общий предок.
От этой вершины до x должен быть общий предок этой вершины x.
То есть должен быть предок x.
Но так как эта вершина не является предком x,
ну потому что она на этом пути не лежит, то получается, что общий предок это кто-то еще.
Она не является ни его предком, ни его...
Ну, я не знаю, разве что его потомком каким-нибудь.
А, нет, она не является потомком.
Потому что мы напоминаем, что пусть эта вершина x должна быть общей предок этой вершины x.
А, нет, она не является потомком.
Потому что мы напоминаем, что мы говорим, пусть у нас на этом пути в качестве промежуточной вершины нашлась вершина по таймыну меньше, чем x.
То есть такой x' и оказалось, что таймын от x' меньше, чем таймын от x.
Таймын от x.
Во.
Тогда заметим, то есть пусть такое произошло.
Мы знаем, именно промежуточное.
Тогда мы знаем, что x' не может быть потомком x, потому что у нее таймын меньше.
Но она не может быть предком x просто по определению этого пути.
Точнее, по построению, помните, мы его так строили.
Но, то есть она не является ни потомком, ни предком, но так как у нее таймын меньше, то по лейме 1 тут какой-то общий предок у них найдется.
И это какая-то вот промежуточная вершина.
Но тогда это промежуточная вершина, ведь напоминаю, это же кусок исходного пути, помните?
То есть это кусок исходного пути между, то есть сначала это была вот последняя вершина предок у, а это была после этого первая вершина потомок у на этом пути.
И тогда получается, что эта вершина должна быть предком x, а то есть лежат либо здесь, либо здесь, оба раза противоречие.
Но здесь противоречие, потому что она идет в этом пути раньше, чем x, а здесь противоречие, потому что она тут идет позже, чем вот эта вершина.
Нет, проблема в том, что х, напоминаю, то есть мы когда вот обрезали путь, вот это начало здесь, мы сказали, что пусть мы идем по этому пути, и х это первая вершина, которая лежит между у и w включительно.
Первая вершина, которая лежит между у и w на пути. А так получается, что если бы она лежала тут, то получается вот эта была бы вершина раньше, и тогда противоречие.
В смысле первая вершина, которая лежит на у и w на пути чего? На каком пути?
Нет, черненький.
Первая вершина, которая будет лежать на у и w, это либо пред w, либо потом непосредственно у?
Нет, посмотрите еще раз, что мы хотели. У нас был DFS и был путь от r до w. На нем была вершина у. Мы предполагаем, что у нее она не доминирует на w.
Мы рассмотрели какой-то путь от r до w. Мы нашли последнего встречающегося на этом пути предка у. Обрезали путь, сказав, что путь вместо этого будет вот такой.
Идем, смотрим, что после этого пути. После этого пути мы натыкаемся на вершину х, это первая вершина х, которая лежит на черном пути от r до x, то есть между у и w.
Вот по определению. Теперь я утверждаю, что вот на этой части пути отсюда до x все промежуточные вершины потаймы, но больше, чем x.
Вот доказательства, что пусть промежуточная нашлась, которая меньше, тогда на этом пути есть их общий предок.
Это не x' и не x. Тогда получается, что у них где-то между ними есть предок x. И тогда он либо лежит здесь, и тогда это получается х и не первая вершина такая, либо он лежит здесь, и тогда получается, что вот эта вершина была такая и не последняя.
Все. Следовательно, то есть это противоречие. И тогда получается, что все эти вершины больше, это означает, что это, я так напишу, кандидат в полупрезидент.
Да, в полупрезидент, да. Ну вот, то есть это кандидат в Эздаме.
Чего вторая картинка? Что такое вторая картинка? Нет, мы ее не отменяли. Мы доказали, что просто если существует какой-нибудь путь, существует путь вот такого вида.
То есть по сути мы доказали, что есть тот путь, который просто идет сначала по направлению к У, потом исчезает с этого пути, потом возвращается, причем уже между У и В, и по нему уже доходит до конца.
По сути мы доказали, что просто вместо этого пути можно рассматривать вот такой путь. То есть если существует какой-нибудь, то существует вот такой.
Ну да, то есть доказательство было, что давайте на этом пути рассмотрим последнюю вершину предка У и заменим часть пути до нее вот на это.
А потом рассмотрим это и насмотрим первую вершину, которая оттуда лежит. То есть так мы смейку превращаем в ухо.
Ну или там половинку сердечка.
Значит, он не может... Ну общий предок, то есть путь от х' и х содержит какой-то общий предок.
Общий предок может быть либо х' либо х либо кто-то между ними.
х' как по имшуточному вершину предком ха не является.
Почему? Ну потому что либо х' лежало бы ниже У и тогда это была бы...
И тогда получается х был бы не первой вершиной на пути от УДВ в этом пути.
Либо х' лежал бы выше У и тогда это была бы не последний предок У на исходном пути.
Значит х' не предок ха.
х не предок ха тупо потому что у х больше таймин.
Следовательно, промежуточный общий предок он тоже на этом пути находится.
То есть на этом пути есть еще один какой-то предок ха и в общем-то тоже самое рассуждение.
То есть можно было даже сократить рассуждение и сказать, что этим общим предком е является х,
значит это является кто-то из промежуточных вершин этого пути, ну и противоречие.
Если ваша задача сократить в доказательстве количество слов.
Суть в общем-то одна.
Но что это значит? Это еще не конец доказательства.
Знаете, как-то была у Левша на описывается ситуация, он просто когда-то, как он рассказывает,
он когда-то пытался доказать великую термину фирма.
И у него было две попытки такие. Сначала один раз он там написал доказательства,
принес его к какому-то крутому математику. Математикой он ознакомился и сказал,
что очень крутое доказательство, но, к сожалению, в логическом построении есть одна маленькая
незначительная ошибка, но если ее исправить, доказательства не получится.
Но как бы товарищ не сдавался, и вот получилось вот, собственно, то, что я вспомнил.
Он написал еще одно абсолютно независимое, безошимченное доказательство,
принес другому математику. Математик так его почитал-почитал,
его звали там Александр Яковлевич Хинчин, но это неважно,
и он почитал и говорит, доказательства абсолютно правильные.
Я тоже хотел кричать ура, но вовремя сдержался.
Доказательства абсолютно правильные, только доказали вы не теряемую фирму,
а нечто совершенно другое, впрочем, давно известное.
Ну, в данном случае вот что-то похоже, на самом деле,
само по себе мы еще доказательства не довели.
Но довести его очень просто.
Если у нас есть выше, то есть мы доказали, что на пути от У до В,
не считая У, есть вершина Х, у которой полудоминатор лежит заведомо выше У.
Видите, да? Ну, точнее, мы доказали, что у него есть кандидат в полудоминаторе
сегодня что-то вuesta выше У, но это означает,
что и сам полудоминатор лежит выше У.
Но это означает, что если тот полудоминатор еще где-то выше,
то тогда это означает, что тут еще где-то выше сам
полудоминатор лежит, а это означает, что вот тут объезд есть
И значит, тут это тоже не доминат.
Неплохо так, правда?
То есть таким образом отсюда получается.
То есть получается вот вытекает чейсь, что на самом деле если мы найдем s дом,
то на самом деле нахождение айдомов мы себе очень сильно упростим, не правда ли?
Нет такого ощущения?
Нет, ну не только.
Вот давайте просто, то есть там лем мы можно еще подоказывать, и мы это еще будем делать,
а давайте пока просто представим себе, что предположим, что вот откуда-то, вот с небес по факсу,
к нам прислали s домы, и мы построили вот этот граф.
То есть представьте, у нас есть только дерево и прямые рёбра.
Ну вот, а я за что?
Значит смотрите, что у нас тогда происходит.
Значит, происходит примерно следующее.
Не, не в смысле это происходит.
Нет, это тоже происходит, конечно, иногда.
Не, доминатор не делает, доминатор доминирует.
Знаете, доминитор доминирует, жужжалка жужжит, стерка стирает, ботинки жмут на монтаже, сократим.
Вот, значит представим себе такую картинку.
Жил был вот такая штука, жил был w.
Так, ну тут всякое дерево, дерево, но мы знаем, что у нас существует только прямые рёбра.
Тогда заметим следующее, что если мы хотим найти доминатора от w, то заметим, что все эти ответвления нам вообще ни к чему,
потому что если у нас какой-то путь пошел в эти ответвления, или даже в потомка w, то в w он уже не вернется никогда,
потому что мы всегда ходим только вниз.
То есть вопрос у нас, то есть мы все равно всегда идем вниз, вопрос только, что мы можем обойти, а что не можем.
Но теперь вот возникает такая интересная штука.
Вот жил был w, теперь вот возникает такая ситуация.
Вот давайте думать.
Вот жил был у.
Внимание, вопрос.
Можем ли мы обойти?
Верно ли, что у не доминирует w?
Ну да, то есть на самом деле можно сформулировать это так, тут даже такая лемма есть, мы ее даже попробуем чуть позже написать.
Получается очень интересный факт.
Рассмотрим все вот эти вершины, и рассмотрим все их s дома.
Вот такие, мало ли как они там пересекаются, я не в курсе.
Да, в том числе и самого w, конечно же.
Да, тут теоретически может быть, кстати, у этого s дома может быть само у, если что.
Ну так вот, если хоть одно из этих ребер обходит у, то есть там начинается выше у, то есть вот из этих вот, то тогда у заведомо не доминируется.
Согласны?
Но с другой стороны наоборот.
Но теперь интересный другой факт.
Если ни одно из этих ребер выше у не идет, то у доминирует.
Неплохо так, правда?
В принципе это уже приводит нас на самом деле к маленькой приятной штуке.
В принципе уже на основании этого там можно придумать алгоритм, который быстро нам сообщает, кто там кого доминирует, который работает в оффлайне за n log n.
Ну и правда в оффлайне.
То есть алгоритм такой.
Значит запускаем DFS.
Ну у нас уже понятно, есть это дерево, есть все полудоминаторы.
У нас еще будет отдельная задача, как эти полудоминаторы вообще найти.
Но мы пока себе вот воображаем.
То есть запускаем DFS.
И храним стэк серых вершин.
Прям стэк с pushback, с pullback на входе и pullback на выходе.
А на этом стэке мы храним дерево отрезков.
Дерево отрезков на минимум, где в каждой вершине пишем таймы на ее sдома.
И когда мы доходим до очередной вершины w, мы теперь можем все запросы про то, кто ее доминирует, обработать каждый за логарифом.
Как? Да очень просто.
Берем минимум на соответствующем отрезке.
Понимаете, да?
Ну если у нас несколько таких запросов, то берем на соответствующем префиксе запрос.
То есть смотрим минимум, если он больше либо равен u, а точнее равен u, то значит мы победили.
То есть значит u доминирует, нет, нет.
То есть таким образом, если вы sдом откуда-то из какой-то черной магии выкопали,
то айдемы вы теперь вон за n лог n, обратите внимание, легко нашли.
Правда, можно еще даже задуматься, а нельзя ли быстрее?
Все айдемы.
Все айдемы.
Нет, айдемы мы еще не нашли.
Мы сделали хитрее.
Не айдемы мы нашли, а вот предположим, что у нас есть куча запросов.
И в каждом запросе даны две вершины, и нас спрашивается, доминирует ли там кто-то над кем-то.
Да, вот это мы умеем.
Да, находить прямо айдемы, но это конечно пока проблематично.
Вот, хотя, конечно, вот.
Но тут, конечно, можно задумываться.
Нет, ну надо-то надо.
Акапелятор же надо строить.
Нет, ну то есть, действительно, нам бы, то есть у нас, конечно, была бы мечта,
то есть определенная мечта, конечно, найти какой-нибудь айдем, действительно.
Логично, да?
Какой?
Ну никакой, ну вот, ну а просто.
Вот, хотя, нет, тут, конечно, действительно, айдем, конечно, можно тут по-разному находить.
Потому что айдем, то есть на уровне идеи, по крайней мере, можно себе представить, что айдем мы можем находить так.
Что там жил-был-дабл-ю, да?
Ну вот, то есть как найти айдем от w?
Значит, мы находим, идем-идем-идем.
Ну там сначала идем из w в s дом от w.
Видим, да?
Теперь внимание, вопрос.
Мы отсюда можем куда-нибудь скакануть еще выше?
Вот если мы из этих вот подвершин не можем скакануть выше, чем это, то тогда вот эта штука и есть айдем, согласны?
Вот, понимаете, да?
Ну вот, если можем скакануть.
Ну, допустим, вот тут нашлась вершина, и мы тут очень высоко скаканули, да?
Что мы делаем?
Тогда говорим, что да.
То есть это теперь тоже.
Теперь у нас какая-то вопрос.
Мы отсюда можем скакануть еще выше?
То есть ну отсюда не можем, уже выяснили?
Наоборот, не выше.
Но это и неважно.
Сейчас мы уже более точно говорим, что мы можем такой алгоритм, который хоть как-нибудь найдет айдем.
Хоть как-нибудь.
А хоть как-нибудь это будет работать так.
То есть как бы мы вот отсюда нашли, а насколько высоко мы можем отсюда скакануть?
Если выше сюда не получилось, то это и есть айдем.
А если выше, то предположим, что самое высоко откуда можем скакануть сюда.
Теперь вот сейчас вопрос.
Мы отсюда можем скакануть еще выше?
Если не можем, то значит это idem. Если можем, то скачем. И там получается вот что-то вот такое уже, ну и так далее.
Но я утверждаю, что да, то есть это тупой алгоритм, который там за какой-то там квадрат найдет вам idems.
Но на самом деле я утверждаю, что мы его теперь можем искать тоже за n log n.
По одной простой причине. Дело в том, что вот предположим, что вы нашли вот это w.
Нашли вот этот esdom w и нашли на его пути вершину x такую, что у нее esdom находится выше всех.
Если это выше всех оказалось выше esdom от w, то я утверждаю, что в этом случае тогда полудоминатор w тот же, что и у x.
Не полудоминатор, просто idem от w и то же самое, что idem от x.
Причина очень проста, потому что idem от x мы будем искать ровно тем же методом, что и дальше бы мы делали вот тупо.
Логично, да? То есть это позволяет нам уже в принципе, если нам esdom мы прислали, то вот тем же методом за n log n со stack радоваться жизни.
Во-первых, надо найти esdom, во-вторых, может быть как-то это, то есть честно скажу, у нас будут леммы, которые по факту закрепят вот это вот все.
Там на самом деле по факту получится, что можно будет одновременно искать esdom и idem.
А самая интрига, а нельзя ли обойтись без деревоотресков?
Ну, с олимпиадной точки зрения, в принципе, скорее всего там за e log w нам искать, конечно, вот этого уже вот так хватит.
Но на самом деле нет, на самом деле нам будет эта задача, которая сводится с snm.
Да, еще одна такая интрига будет.
Ну вот, нет, ну что, пусть сводится, ну вот, ну а пока...
Значит, смотрите, но идея будет такая, еще раз, давайте вот рисую заново.
Жил-был w, да?
Рассмотрим, просто скаканем от w к esdom от w.
Рассмотрим все вершины между esdom от w не включительно и w включительно.
Вот, то есть эту мы не рассматриваем, рассматриваем вот эти вершины.
Утверждение, если из этих вершин, вот из этих вершин мы думаем, где находятся esdom.
Если esdom этих вершин, ни один esdom не находится выше, чем вот это, то я утверждаю, что этот esdom и есть idem от w.
Логично, да? Вот давайте найдем тут максимум, насколько высоко можно скакнуть. Если выше не получилось, значит это есть idem.
А если можно, пусть вершина x, это вершина, из которой можно скакануть выше всех.
То есть вот это esdom от x, и тут выясняется, что вот это все уже неинтересно.
То есть тут можно скакануть сюда, тут можно скакануть сюда, ну и так далее.
Теперь утверждение следующее.
Ни одна из вершин ниже esdom x, конечно, уже не может быть доминатором, правда?
Ну доминатором w.
Теперь возникает вопрос, а esdom от x не может ли нам подойти?
Ну теперь да. То есть теперь надо понять, вот мы отсюда можем скакануть?
Но заметим следующее, что вот этот отрезок можно отсечь, потому что отсюда мы уже знаем, что выше esdom от x вы не скаканете отсюда.
Поэтому берем только отрезок от esdom от x не включить, надо x включить, и смотрим уже на нем, куда можно скакануть.
И так повторяем операцию много раз.
Это алгоритм работает долго, но теперь заметим, что когда мы искали idem для x, мы делали ровно то же самое, просто начинали прямо с этого ребра.
Поэтому по факту в этом месте можно просто запомнить, если мы использовали рекурсию с запоминанием, то мы просто сказали, что в этом случае на самом деле idem от w это тупо idem от x.
Просто потому что алгоритмы там будут делать начиная с какого-то момента просто одно и то же буквально.
Все.
Нет, ну почему пока у нас будет просто дерево отрезков.
Ну то есть алгоритмы, то есть будет у нас дерево отрезков, то есть то же самое дерево отрезков, но только в каждой вершине мы делаем только один запрос к дереву отрезков, минимум на суффиксе у esdom, таймы на esdom.
Если этот минимум меньше, ниже esdom от w, значит он и есть ответ.
В противном случае находим, откуда мы этот минимум взяли, и у этой вершины берем у нее idem, мы его раньше уже нашли, и присваиваем его в idem от w.
Все.
Вот.
Так что получается вот за, так сказать, за n log n вроде и нашли.
Понимаете, да?
Вот собственно и все.
Это пока n log n.
Но как я уже сказал, хочется обойтись без, научиться обойтись без дерево отрезков, и хочется находить esdom.
Потому что пока не без esdom мы не изобрели.
Ну вот конечно сейчас и пришло время небольшого перерывчика.
Значит поехали дальше.
Итак.
Ну а первое, да, как бы это можно было бы попытаться сделать быстрее, чем за n log n, но самое главное, как же эти esdomы найти?
Вот.
Вот.
Ну в принципе да, можно тут чуть-чуть еще поразвлекаться и поформулировать еще пары лем, но мы пожалуй не будем это делать.
Потому что мы уже и так поняли, что да, если там примерно, по крайней мере поняли, что если esdomы там, esdomы нашли, то вот idem понятно там максимум на чем, соответственно, искать.
Понимаете?
То имеется в виду, что ну, ну собственно, если esdomы нашли, то как idem искать мы поняли.
Ну по крайней мере за n log n.
По крайней мере за n log n.
Это мы в конце попробуем это усилить.
Тем более, что в конце нам потребуется еще это, еще думать, потому что, честно скажу, мы сегодня не сможем полностью так это, так сказать, совсем под ключи это сделать, потому что нам придется поверить в какую-то мистическую структу.
Ну до следующего раза поверить, если что.
Вот.
Потому что в следующий раз как бы мы уже обсудим мистическую структуру, но там нам придется поверить в мистическую функцию Акермана.
В мистическое утверждение.
Хотя, возможно, если успеем, то и до функции Акермана доберемся.
В смысле доказать? Нет, до определения мы доберемся так и так.
И то это не совсем функция Акермана, конечно, обратно, там ее такая модификация.
Вот.
Гипероператор.
Гипероператор.
Да, увидел сложно, как это открывать статью.
Функция называется гипероператором, если закрыл статью.
Так, значит, поехали, да, знакомая ситуация, да.
Вот.
И так.
Значит, пока суд доделал.
Давайте вот еще чуть-чуть поразминаем.
Ладно, не будем разминаться.
Поехали прямо.
Потом воспомним.
В случае чего в оригинальной статье тоже еще там теоремы есть, которые вот закрепляют это все.
Там формулировка теоремы.
Рассмотрим W с дам и рассмотрим максимум, минимум по таймы из s дамов.
Если он больше либо равен таймы на s дам, то тогда s дам от W равен i дам от W.
В противном случае там пусть x это аргумент, тогда i дам от W равно i дам от x.
Вот.
Вот такие теоремы вы там увидите.
Ну, собственно, суть мы уже увидели.
А теперь как же искать s дамы?
Знаете, смотрите.
Итак, теорема 4.
Теорема 4.
Значит, утверждается следующее, что для любого W не равно r s дам от x, твой s дам от W, равно.
То есть это не присваивание, это теорема.
Это утверждение.
Ну, максимум.
Таймы и на от.
Какая у меня там буковка?
От z.
Где z лежит в объединении множеств s1 от W и s2 от W.
Вот.
Где?
В объединении множеств s1 от W?
s1 от W и s2 от W.
То есть надо перебрать все вершины, которые лежат в объединении множества s1 от W и s2 от W и выбрать из них,
посмотреть их таймыны и выбрать вершину с минимали.
Где s1 и s2?
А, в этом смысле да.
Вот.
Где?
Значит, поехали.
Значит, поехали.
Значит, смотрите.
s1 от W.
Это вот что.
Это...
Значит, s1 это множество таких вершин, шо, из которых можно просто напрямую по ребру попасть в W.
И при этом, конечно же, таймин.
От W оказался меньше, чем таймин от W.
Вот.
Ну то есть, в переводе говоря, естественными кандидатами и вездами являются все вершины, из которых ведут ребра в W.
Ну, из них мы рассматриваем только те, у кого таймы меньше, естественно, потому что понятно, почему.
Еще раз.
Ну это да.
Да, но если что, это не тот краф.
Не тот краф.
Потому что у нас...
Нет, это исходный краф, потому что, вы видите, эта теорема будет помогать нам этот s1 искать вообще.
Но это еще не все.
Значит, еще есть.
Значит, s2 от W.
Вот.
Значит, смотрите.
Значит, что тут еще?
Чего?
Значит, еще s2 это множество s домов от вершин У.
Где?
Таймы над У больше, чем таймы над W.
Вот.
Далее.
Значит, тут вот аккуратно сформулируем.
Значит, это больше.
Значит, а также существует такая вершина В.
То есть существует вершина В, которая является потомком.
Такая, что из этого потомка можно
попасть по ребру в W.
То есть переводим на русский язык.
Смотрите.
Жила-была.
То есть вершина W.
Значит, и были в нее входящие ребра.
Да?
И были они двух типов.
Те, кто был меньше W, и те, кто больше W.
По таймыну.
Значит, если они были меньше, то вот сами эти вершины.
Да, ну вот это ребра просто какие-нибудь.
Не только, не только.
Нет, есть еще варианты потомок.
Это могло быть обратная ребра.
То есть да.
То есть были там всякие вот эти вот там какие-нибудь перекрестные ребра.
И обратные ребра.
Вот.
А эти были, ну соответственно, одно ребро дерева DFS обязательно.
И, конечно, парочка прибых.
Ой, как хорошо.
Четыре марки.
Четыре типа.
Вот.
Но вот в этих всех ребрах, вот давайте зелененькое рассмотрим.
Да, зелененькое давайте рассмотрим.
Мы рассматриваем кандидат.
Это не сама вершина.
Это мы делаем вот что.
Мы берем эту вершину.
Идем из нее, идем до какого-то предка.
Но при этом этот предок должен быть больше самой W.
То есть если у них тут вот есть лцашка какая-то, то вот мы только вот эти вот вершины рассматриваем.
И вот у этих вершин X мы рассматриваем S дом от X.
Во.
Далеко, конечно.
Ну, что вы хотите, Тарья.
Значит, давайте проверять.
Вот теперь я утверждаю, что среди, что его, что надо S дом искать среди вот этих вершин.
И только среди них.
Ну, здорово, мы очень рады.
Почему мы просто не пишем, что добудем потомок.
А где?
А, потомок, понятно.
Кто чей потомок?
А потомок они говорят, потомок они, а не ребенок.
Вот.
А потомок они говорят, потомок они, а не ребенок.
Вот.
Вот.
Да, ты чей тут даже?
Ага.
А, тут все.
А, тут, да, тут все еще круче.
Да, только надо тут еще это.
Да, вот теперь должно быть все понятно.
Ну, потому что вот это, ой, вот это, ой, это одно и то же.
Да, а это вершина W, да.
Ну, давайте для разминочки.
Для начала поймем, что каждая из этих вершин действительно кандидат в S доме.
Ну, поехали.
Легче всего это сделать в S1.
Ну, очевидно, все эти, если вы помните, помните определение S дома-то вообще?
Ну, это так, да, S дом.
Ну, это вершины?
Да.
Да, которые есть путь до нашей, проходящей только по вершинам, у которых ты им больше чем больше.
Да, именно промежуточные.
Ну, действительно, когда промежуточных вершин нет вообще, то вершина автоматический кандидат.
Вот.
Значит, ну вот, почему вот эти все вершины кандидата вообще?
Да, просто потому что, ну, смотрите, ну, давайте думать.
S дом откуда?
Тогда вот, смотрите, все, теперь заметьте, все промежуточные вершины, потому что заметьте, что сама U больше W,
все вот эти вершины, тем более больше, правда?
А вот эти все еще больше, чем U по таймену.
Ну, по определению S дома-то, правда?
Так что получается, что да, S дома-то это действительно реальный кандидат.
Вот, понимаете?
Еще Morning Tree, пожалуйста.
Ну, смотрите, то есть, еще раз- то есть еще раз рассмотрим.
Рассмотрим вот это перекрестное ребро.
Или даже не перекрестное, это может быть, кстати, обратное ребро на самом деле.
То есть альтернативная ситуация, может быть, когда, на самом деле, вот это вершина.
вершина в то есть на самом деле тут вот то есть это обратное ребро то есть на
самом деле тут есть вот такой потомок да и мы вот там то есть вот это
получается какая-то вершина в вот где-то здесь какая-то вершина у и тут вот
какой-то s да моту это нас тоже может устроить еще вот так может быть значит
но утверждается что что вот это что вот это это реально кандидат в этом почему
я утверждаю что вот этот вот путь который мы нашли а тестом от удовод как-то
вот куда но вот и плюс если к нему приписать путь до от в да в этом паре бруда
в то весь этот путь кроме вот все вершины кроме из дома ту будут по
таймы ну больше чем в почему ну у больше эти все больше по определению
а здесь больше ну потому что все потомки у по таймы но еще больше к нему все так
что вот такая красота
ему меньше больше таймы на ту должен быть больше чем таймы на дабл и обратите
внимание да но если он больше то эти все еще больше про нет таймы на ту больше
по определению у нас определение с 2 смотрите внимательно но первичного у нет
первое мы выбираем рассматриваем вершины у которая по таймы ну больше чем w это
из них мы выбираем такую что из них можно из вершины у спуститься в каком-то потомка
в и по ребру скакнуть в чем это может быть вот как обратное ребро так и перекрестные
и еще из из дома от у нот и тогда но и утверждает что из дома ту вполне себе
кандидат почему кандидат просто потому что тогда вот на этой части отрезки пути тогда
просто все это еще больше чем это определение определение этого все тут вершины все вершины
оттуда у дайны пути должны быть больше чем но смысл такой путь существует не на любом
конечно пути это так но вот значит поехали все остается только самая малость показать что это
не просто что все это кандидаты а то что правильный ответ обязательно найдется среди них
но давайте смотреть ну давайте думать как же это сделать ну доказательства конечно простое
вот ну пока и мере ну начала тут всех доказательств одинаково рассмотрим w рассмотрим
с дома дабы вот пусть он тот сно вот с дома дабы и у него есть тот самый путь
вот видите да более того мы даже давайте его обзавел в 0 в 1 в 2 в 3 и так далее и это вот в
равно vk понимаете да это vk минус 1 но если кара и у нас два случая если к равно 1 то есть давайте
так и пишем если к равно 1 то тогда из этого следует что вот этот вот с дом от дабы то тогда из
этого следует что в 0 тупо лежит в множестве с 1 от дабы но то что при кара в 0 1 это пути то
тупо прямое ребро видите да то есть прям вот с 1 что и лежит понимаете да и играем дальше
вот значит что там что там у нас еще вот так что там у нас еще вот но если к больше единиц
тогда смотрите какая ситуация тогда идея такая опять же сейчас рассмотрим будем рассматривать
самое раннее что-нибудь или самое позднее что-нибудь смотрите вот у нас есть вершина vk минус
1 она по таймыну больше чем vk она же w а теперь заметим что на этом пути у нее могут быть предки
правда у vk минус 1 более это ну хоть один обязательно да будет в смысле она сама давайте найдем
самого раннего предка вот из этих v1 v2 v3 и так далее на пути пусть это вот vg то есть это
можно так сказать то есть пусть g это то есть g там допустим 3 там g штрих это допустим пусть
минимум минимальное такое g больше нуля такое что v житая предок vk минус 1 ну в худшем случае
это k минус 1 тогда заметим следующее что вместо этого да то есть я теперь могу опять облегчить
себе чуть-чуть жизнь и сказать что жил был r жил был w жил был s дам жил был путь вот дошел он
до vg то есть тут v1 v2 и так далее да после этого он идет напрямую вот видите прав в потомка vk
минус 1 и вот это финальное ребро понимаете да да я бы мог нарисовать зеленым в принципе потому
что нотка хотя нет хотя нет не могу его нарисовать зеленым оно может быть и красным понимаете да то
есть вот путь у нас теперь вот так выглядит причем не просто так а на самом деле да не в ж 4
вот а теперь я утверждаю следующее на этом пути вот опять мужа сегодня с этим сталкивались
обратите внимание на этом пути нет ни одного вот не вот на пути v1 v2 и так далее нет ни одного
предка вы же и правда конечно не не сам пути именно черный да да он предок вот мы его
подменили да то есть но теперь смотрите раз вот на этой части на этой части пути подправить
ни одна не является предком тогда я утверждаю что все эти вершины по таймыну больше чем выжив
чем выживая причина проста если хоть если хоть хоть одна вершина по таймыну меньше то тогда есть
но да то есть поэтому но правда есть одна оговорочка а вдруг кто-то из них это потомок
чего а ну тем более да да то есть если хоть кто-то меньше значит кто-то найдется какой-то значит
тут еще но даже это неважно даже кто-то найдется это не будет в ж 3 значит понятно значит найдется
предок противоречия все эти вершины больше следовательно sdm от w sdm от w это кандидат
v кандидат в sdm от vj 3 понимаете да но больного я утверждаю что sdm от w и будет на самом деле
с домом он будет еще sdm от в ж этого почему потому что если у него sdm еще выше то тогда и у
w sdm был бы еще выше да просто обошли бы вот так вот так вот так то есть следовательно
sdm от w равен sdm от vj 3 и соответственно поздравляю он 2 вот такой вот прият вот такой вот
приятный теория мо чего кого нашли но потому что 3 sdm от w как мы выяснили это кандидат
в sdm от vj 3 предположим что sdm еще круче но то есть он еще круче значит он тут еще вот где-то
вот тут находится да но тогда если бы у нас существовал еще какой-то вот такой вот обходной
путь то тогда мы по этому обходному пути пришли бы в ж это об том спустили бы сюда и пришли в
w и таким образом это оказался бы еще то есть оказалось просто что sdm от w это не
потому что мы нашли еще лучше да потому что он тупо выше вот и все собственно вот и вся магия
вот все что нам остается теперь все что нам остается это вот этот sdm но вот но теперь
на самом деле вот пришло время теперь давайте думать как же нам теперь значит как же нам
теперь sdm находить вот вот вот давайте теперь думать как же нам теперь его находить ну на
самом деле очень просто ну давайте вот просто давайте для вот давай давайте так ну ладно
подоказательство вопроса есть еще ну я вот выражаю что просто sdm от него равен sdm от w а дает
это нам то что это означает что это у вас w попадет множество с 2
да значит sdm от w кандидат vzh3 но предположим что тут нашелся кто-то кто меньше чем vzh3 тогда
как мы если вот этот вот меньше чем то у нас была первая лемма который говорит о том что на этом
пути есть какой-то общий предок вот этой этой вершины да но так какой это имеет то есть это
vzh3 быть не может потому что она больше по таймину чем вот это а vzh3 по определению но тогда просто
vzh3 по определению это самая первая вершина на этом пути из v1 v2 и так далее которая предок
если это не vzh3 значит тут еще есть ее предок а следствие вот такая вот радость приятная то
есть прямо такая вот кодовая лемма которая все решает значит она все решает вот и получается
примерно следующее что у нас получается то есть получается теперь так ладно если подоказательство
нет вопросов тогда давайте я это сотру оставлю только лему и давайте внимательно смотреть как
она нам будет помогать как она нам будет помогать находить s до
ну на самом деле но в принципе мы ну смотрите как это себе вообразить на
самом деле давайте вот вообразим себе но на самом деле садatri но дерево dfs вообразим себе дерево
ДФС. Видите, да? Вот это вот, вот это вот там, вот там все красивое, красивое, красивое, красивое 0 ДФС.
Вот это вот слева направо было, да? То есть по таймы, ну они будут там понятно, 0, 1, 2, 3, 4, 5, 6, 7, 8, там 9, ну вы поняли. Вот.
Вот. А теперь идея такая. А давайте мысленно СДМ будем считать не слева направо, а наоборот, справа налево. Почему? А вот почему, смотрите. Вот допустим, вот именно, причем вот именно справа налево и как бы сначала потомки, потом предки.
Ну, видимо, потому что С2 мы пересчитали, считали вершину как бы больше.
Ну вот, да, потому что, смотрите, потому что если мы вот возьмем, ну, например, так, давайте я вот еще чуть-чуть дорисую. Вот, допустим, я захотел найти таймын по СДМ вот у этой вершины, да? И предположим, что я знаю, и предположим, что я вот для этой всей веточки нашел, там вот для вот этих всех вот веточек еще нашел, да, и вот для этого всего нашел, да?
Так, сейчас вот давайте тут надо, нет, даже ладно, давайте не для этой, не для этой, не для этой, не хорошо, наверное, что-то просто мало ответвлений.
А, нет, давайте вот для этой, вот давайте, вот для этой. Тогда, смотрите, что у нас тут пока получилось? Получилось следующее, что мы должны, фактически, С1 и С2 говорят, что мы должны перебирать входящие в нас ребра, да?
Входящие в W ребра. Значит, что это может быть? Это могут быть ребра дерева DFS и прямые ребра, вот эти вот, да? Какие-нибудь вот такие, но их, они вот, это у нас, эти вершины лежат в С1, мы их перебираем напрямую, да?
Еще могут быть обратные ребра, то есть из-под дерева, или тут даже вот еще какие-то веселья могут быть, то есть вот как-то вот, аж вот так вот, я не знаю.
И, а могут быть перекрестные ребра из вот соседних, что все эти вершины объединяет? Эти вершины объединяет то, что S-домы, по крайней мере, от них мы уже нашли, но даже еще круче.
Дело вот в чем, то есть на самом деле еще могут быть вот какие-то ребра, ну скажем, вот такие, или там вот такие, вот это вот все, да?
Главное, что они справа налево.
Да, но они идут справа налево. Фактически, теперь наша идея такая, для каждого зеленого ребра нам нужно взять вот эту вершину, дойти, фактически, идти в родители, родители, родители, до тех пор, пока не наткнемся на предка, общего предка с нами, да?
Вот на этом вот пути. Вот здесь этого предка, и на этом пути выбрать минимального S-дома. Видите, да?
Ну да, вот здесь так, здесь этот путь вот так вот будет.
Правда, что у родителей, например, S-дом не больше, чем у S-дома его ребенка?
Сейчас еще раз.
Правда, что у родителей S-дом выше, чем у ребенка?
Или вообще ничего так сказать нельзя?
Нельзя. Нет, там нельзя, потому что вы все можете вообразить, просто порисовать прямые ребра. Они могут быть вложены, а могут быть пересекаться.
Поэтому там, поэтому S-домы у родителей и детей не связаны в этом смысле никак.
Но это нам и не нужно, потому что у нас опять, когда мы тут перебираем все вот эти прикрестные ребра, у нас фактически опять запрос.
Данная вершина, найдите, пожалуйста, минимум что-то там, так сказать, на отрезке.
То есть в принципе это опять дает решение, как это сделать за логарифом.
Потому что тогда у нас задача, найдите что-нибудь, то есть, во-первых, нам нужно найти для каждой вершины длину этого пути на текущий момент.
Но для этого вам просто достаточно найти LCA.
Ну LCA вы там как-нибудь найдете.
Скорее всего даже за логарифом.
Да, вы можете за O от единицы.
Но на самом деле потом-то вы говорите, что вам нужно рассмотреть этот путь и на этом пути рассмотреть минимум.
Поэтому тут скорее двоичные подъемы допрашиваются.
Ну вот. То есть можно сделать и так.
Поэтому в принципе это уже приводит вас к тому, что S дом вы нашли и можно там I дом либо отдельно искать, либо прямо здесь.
Но на самом деле, теперь я утверждаю, что на самом деле никакие деревоотрески LCA не нужны.
А нужна?
Смекалка.
Да, смекалка. Что это?
Нет, на самом деле нам потребуется мистическая структура данных.
Значит, смотрите какая.
Это будет допиливание алгоритма Тарьяна для поиска LCA что ли?
Нет. Какой? Офлайновый?
Нет, еще хуже.
Я сейчас сформулирую мистическую структуру данных, которая сводится вот это алгоритм Тарьяна поиска LCA.
Хотя нет, алгоритм поиска Тарьяна сводится к SNM, а SNM сводится к тому, что я сейчас скажу.
Вот, даже так будет.
Ну там еще круче на самом деле.
Значит, смотрите там какая ситуация.
Нет, ну там на самом деле может быть достаточно просто, может быть даже...
То есть у нас еще будет упрощенная версия.
Так, ну ладно, вот это вот запомни.
Так, вот это я на всякий случай стирать пока не буду.
Или вы уже себе это записали?
Кто записывал, записал, да.
Кто не записывал, тот.
Снял.
Нет, вопрос просто в том, что сейчас я вот скажу...
Сейчас мы просто временно абстрагируемся, я сформулирую мистическую структуру.
А потом надо будет вернуться к этому и увидеть на самом деле то, что я напишу вот в этом.
Вот с этой точки зрения.
Вот.
Ну ладно.
Как бы ладно.
Как бы ладно.
Как бы в конце концов у нас это...
Сейчас будет величественная структура, к которой сводится все.
Она должна быть написана повыше.
Чтобы мы это написали.
Значит, мистическая структура.
Значит, храним.
Значит, вообще все, временно забыли про всякие деревья-доминаторов.
А вместо этого представьте себе.
У нас есть множество каких-то вершин.
И мы храним на них подвешенное дерево.
Точнее, лес.
Лес.
Лес.
В каждой вершине В написано нечто.
Ну, оно вот.
То есть в каждой вершине, ну там допустим, тут написано там.
Там L1, L2, L3, какой-нибудь.
В общем, короче, по вершине В мы пишем так называемую метку.
Лейбл от В.
Да.
Ну, точнее, сейчас она немножко усиленная.
А нет, пока еще не усиленная.
То есть в каждой вершине написана какая-то метка.
Ну, как значение, да.
Ну, в первую очередь.
Ну, как сказать, когда мы ее будем изучать, она у нас будет там это.
То есть это элемент какой-то полугруппы.
Да, у нас будет такое слово, да.
Не, столько полугрупп, я знаю.
Ну, вот, да.
Что она забыла.
Ну, вот, да.
Так вот, а забыла она следующее.
То есть, ну да, то есть действительно лейбл, это она у нас лежит в какой-то полугруппе.
То есть у нас есть полугруппа S с оператором ыть.
Ну, я не знаю, как это называть, поэтому пусть будет ыть.
И определение там такое.
Значит, структура данных.
На этих n или, значит, есть n вершин, в каждой есть меточка,
и она поддерживает следующие операции.
Операция номер раз.
Значит, она хочет поддерживать операцию.
Да.
Ну, давайте в этом порядке.
Эвол.
Эвол от V.
То есть это означает.
Ну, вот.
Ну, то есть это означает, что хочется пройти от вершины V до корня.
Кстати, до дерева мы храним на этот раз в очень тупом виде.
Для каждой вершины храним родителя.
Ну, по крайней мере мысленно, да.
Ну, и понятно, а у корня, ну, там храним, скажем, что у него родителей нет.
Ну, я знаю, да, вы обычно храните, что родители его это я, но...
Ну, там как бы тут в науте считаем, что у него родителей нет.
Да.
Да.
То есть label это вот лежит вот в этой вот с.
Вот.
Значит, и операции там такие.
Значит, по умолчанию.
Эвол, значит, если у нас есть такой вот путь до вершины V, которая равна VKT,
и вот есть корень этого дерева, который равен будет V0, V1, там V2 и так далее VK,
то хотим мы найти...
И, то есть хотим найти такую штуку, как label от V0, ыть label от V1, ыть и так далее,
ыть label от VK.
Чтобы ыть будет прям реально полугруппа, но для нас самые интересные случаи,
когда ыть это максимум или минимум.
Ну, на усмотрение, короче.
Вот.
Ну, полугруппа, да, то есть по сути у нас есть S и ыть, ассоциативная операция на ем.
Все.
Это просто буквально определение полугруппы.
То есть никаких этих ваших там обратных элементов, там никаких этих ваших нулей.
Хотя нет, нули могут быть в принципе, а могут и не быть.
Так вот.
Далее у нас будет операция link.
Так, вот здесь есть два варианта определения.
Ну да.
Рассмотрим путь от вершины до корня.
Точнее, все в порядке от корня к этой вершине.
И по ыть, по ыть, да.
Ну, тут вот так скажем, знаете, я вот сейчас ботаю соответствующую статью.
Там, знаете, мне не всегда было удобно мыслить так, как Тарьян.
В результате начинается рассуждение, начинается путаница.
Вот.
Так вот, link от u, v.
Это, ну, по сути, это называется подвесить, подвесить корень v к корню u.
Оба раза подчеркиваю, что u и v должны быть корнями.
Вот.
Чего?
Да.
Ну, потому что они хранятся там, в виде, что в каждой вершине хранится родитель.
Вот так.
Да, у нас лес, совершенно верно.
Логично.
Вот.
И вот, в принципе, вот этого нам, для наших-то целей нам хватит.
Ой, ой, ой, не в том порядке я вам пишу, но, впрочем, это неважно.
Но на самом деле есть еще операция update.
Вот, у нас этой операции не будет.
Update там какой-нибудь vx.
То есть, это означает, что label от v, вам нужно присвоить x и label от v.
Вот.
Ну, вот.
Ну, по сути, в случае максимума это называется, возьмите корень и сделайте max равно.
Понимаете, да?
Вот.
Вот представьте себе такую вот, есть такая мистическая структура данных.
Вот, мистическая.
Вот.
Ну, как она работает?
Ну, как ее можно реализовать?
Ну, можно реализовать в тупую, конечно, и каждый eval прям в тупую вот так насчитывать, да?
Но это долго.
Ну, вот.
Ну, вот.
Ну, можно реализовать в тупую, конечно, и каждый eval прям в тупую вот так насчитывать, да?
Но это долго.
Ну, выражаясь языком S&M.
У этой структуры, конечно, к этой структуре вот в таком виде легко применять евристику сжатия путей, правда?
Так, понятно, что это такое?
Ну, мы пока его не будем обсуждать.
Ну, в общем, сжать можно, да?
Ну, нет.
Нет, я пока говорю просто на уровне идеи, что сжать можно.
Ну, то есть в том плане, что если у вас есть родители, а у родителей есть дедушка, то я вместо того, чтобы ссылаться на родителей, я могу сослаться на дедушку.
И у меня тут лейбл просто «это, ить меня».
И это, ну, вот.
Ну, и более того, если вы можете сжать даже целую цепочку, причем у этих тоже на самом деле тут рекурсизм.
А обдейтер считаем?
А обдейтер такой, если мы делаем только евристику сжатия путей, то обдейтер вообще делается за единицу по одной простой причине.
Да, вот спасибо, что напомнили.
В.
Что В обязана быть коркин.
Да, да, да, это важно.
Да, это очень важно.
Если была рандомная вершина, то вы, конечно, пофейлились.
Вот.
Вот.
Но В обязана быть коркин.
Тогда, конечно, без труда.
Это зал от единицы, это зал от единицы, это сжатие путей.
Вот.
Ну, а здесь такой анонс.
Так, сколько у нас времени, кстати?
А, у нас еще есть время.
Вот.
Ну, в общем, ладно, давайте пока попробуем нот.
Ну, пока скажем так.
Добой анонс такой говорит, что, в принципе, как вы уже знаете, что SNN...
Ну, то есть, на самом деле, да, это похоже на SNN, но, в принципе, на самом деле SNN, по сути, к этому сводится.
Ну, если вы умеете вот эту структуру реализовывать, да?
Где ИТ равно...
Ну да, к чему оно там равно, кстати?
SNN?
А, ну, в общем...
А, ну, в общем, ИТ равно...
Ну, можно так сказать.
ИТ равно такой замечательной функции, такая f от x, y равно x.
Ну, ИТ ассоциативно.
Понимаете, да?
Вот.
Но вам, впрочем, и не принципиально, потому что...
Ну, там просто суть, на самом деле, просто суть этой структуры...
Давайте вот поговорим вот о чем.
Суть такая.
Если вы просто реализуете эту структуру,
то утверждается, что тогда среднее время работы каждой операции будет логарифом.
Вот тупо сжатие путей, больше без всяких заморочек.
Вот.
Нет, ну, я честно говорю, конкретно сегодня я не хочу этим заниматься.
А вот в следующий раз я хочу этим заниматься и подробно.
Вот.
Хотя нет.
В следующий раз, да, ну, в идеале.
Потому что я боюсь, в следующий раз мы будем еще обсуждать следствие этой структуры.
Потому что пока мы когда-то...
Но там просто фишка такая, ладно, допустим, смотрите, доказать то, что логарифом, это не очень сложно.
Вот.
Но там есть более страшное.
Если гарантируется, что деревья, которые у вас тут получаются сбалансированы,
то тогда среднее время будет не логарифом, а обратная функция керманом.
Если гарантируется, что они сбалансированы.
А что такое сбалансированы?
Вот как мы еще раз с сжатием будем...
Вот, допустим, мы...
Может, я забыл, как сжатие работает, но вот, допустим, мы взяли одну вершину в другую
и потом мы хотим от той, в которую сжимали запустить вал.
Как мы отделим значение на лейбу, которая с ней...
Ну, сжатие путей, это не то, что мы две вершинки в одном сжимаем,
это мы просто переподвешиваем вершинки в корни.
Да, да, да.
Вот.
Но тут смысл в том, что, что такое сбалансированность?
Ну, сбалансированность на будущее, скажу так.
Это мы говорим так.
Вот у нас есть вершины, у которых по дереве достаточно большая глубина.
Так вот.
Нет, вот если без сжатия путей, вот просто мы себе выберем.
Если мы гарантируем, что у нас подвешивания будут выполнены так,
что, скажем так, вершин, у которых глубина под дерево h,
внимание, именно глубина под дерево, максимальная h,
их не более, то есть количество таких вершин не более, чем
СН поделить на А в степени h,
где А это какая-то константа больше единицы, да и СМ, в общем-то, тоже,
но Ц просто больше нуля.
Ну, в общем-то, если С больше нуля, то можно и Ц больше ни.
То есть, если вот найдутся такие константы, что вот это так,
то тогда оказывается, что эти все сжатия путей при этом обеспечивают какую-то эпическую обратную функцию Германа.
Ну, я не знаю, то есть, если останется время, я сформулирую более точную тиремму,
там даже первая тиремма как-то экзотически формулируется,
но она формулируется так, что там, если m очень-очень-очень-очень-очень большое,
то на самом деле там логарифом превращается в единицу.
Вот. Ну, с интегрировал, да?
Ой, но это я еще не писал, собственно, определение обратной функции Германа.
Точнее, как бы вы сказали, не обратной функции Германа,
а единицы.
Точнее, как бы вы сказали, не обратной функции Германа,
а ее модификации, называются помогающие в этой задаче.
Вот так. То есть, может быть, обратная функция Германа – это чеу, чуть другое очень сильно.
Вот, такая красота у нас.
Вот, так вот. То есть, если удастся подвешивать так, что вот все мало,
то там обратная функция Германа.
если мы верим вот в эту структуру как-то, то дальше там, то snm в общем-то получается из нее очень просто.
Ну потому что что нам в snm-е-то надо? То есть в snm-е нам по сути надо объединять два множества
и для каждой вершины давать какого-нибудь представителя желательно, чтобы для одной вершины одного это ложе, правда?
Ну и тогда у нас идея будет, что там скажем, операция it будет равна f от x и как равно x,
ну это даже не важно, то есть по сути, ну то есть это даже идти не обязательно.
Ну а так как нам, когда объединяем вершины нам по барабану, кто конкретно будет предок,
то мы подвешиваем просто, скажем, меньшее по сайзу под дерево к большему.
Понимаете, да? Ну и там будет, скажем, достаточно легко доказать, что в этом случае тогда получается,
что каждый раз, когда вы переходите от вершины к следу, как к родителю,
то у вас размер по дереву увеличивается в два раза.
Ну вот, хотя нет, это отдельно еще надо доказывать.
Хотя нет, тут самое главное, мы корень к корню подвешиваем, поэтому это будет так.
То есть заметим, что если мы тут подвесили вот эту вершину к этой, то для этой вершины сайз вот этой вершины этой
больше не поменяются никогда, если это не корень, а у этой сайз может только увеличиться.
Поэтому если тут было в два раза больше, то как бы будет тем более.
Отсюда уже достаточно легко будет.
То есть это будет уже достаточно легко показать по индукции, что тут действительно А будет что-то типа два.
Вот понимаете, да?
Вот поэтому как бы СНМ к этой структуре легко сводится.
Ну а с помощью СНМа можно уже забабахивать алгоритм Тарьяна, этот офлайновый.
Вот. Ну мы посмотрим, давайте вот.
Это так, это немножко анонса. Может быть сегодня, если у нас еще много времени останется.
Сколько у нас там времени еще? Ну вообще, да, 20 минут у нас осталось.
Не, ну мало ли, знаете, там что-нибудь за 10 минут, чтобы не думать, хотя я бы скорее лучше отпустил пораньше.
А в следующий раз тогда занялись бы этой структурой прям вот с ножовочкой.
Ну тем более, что СНМ это краскал сразу, да?
Ну вот, ну не важно. Так что ладно, это мы еще обсудим.
Но самое главное, давайте увидим вот эту структуру данных в дереве доминаторов.
Для этого давайте подумаем вот о чем.
Значит, я утверждаю, что мы должны увидеть эту структуру, где операция ИТ равна минибуму.
А теперь смотрите, откуда же мы ее увидим?
В общем, да, напоминаю, нам не только СНМ, но нам желательно с помощью СНМ потом еще айдомы найти.
Мы пока айдомы тоже злые логеры ищем, помните?
Ну сейчас увидим.
Значит, давайте начнем с айдомов.
Давайте все по порядочку.
Давайте откручиваем, раскручиваем пружинку назад.
Смотрите.
Итак, жила была у нас дерево, да?
Жила была дерево.
Как называются сказки?
Жили-были, ходили-бродили.
Ну и прочее-то.
Каких коротышек?
Какого коротышки в сказках Носова не было?
Незнайка, сиропчик, пончик, япончик.
Последний я только знаю.
Но это уже другая история.
Да, совершенно.
Ну там уже начинаются грустные.
Одесситы очень горят все свои истории, но кажется, как-то да.
Там такая история, что из топ-10 самых популярных одесситов не связана с уголовкой только Анна Ахматова.
И то, возможно, ютуба не поймали.
И там такая картинка, что может быть это там вокзал.
Значит, кто-то там сидит такой, засыпает.
Однако его подходит, там начинает читать свои стихи.
Он засыпает совсем.
Ну и соответственно просыпается.
Красивый вариант, конечно.
Ну вот.
Так вот, теперь давайте себе представим, как у нас будет выглядеть.
Так.
Что-то еще надо.
Какая-то мука, примеры рисовать.
Давайте смотреть.
Итак, предположим, что мы ищем эсдомы в обратном порядке.
Вот ищем, ищем, ищем.
И давайте в каждый момент времени хранить вершины, для которых мы эсдомы нашли.
Ну вот для этой вершины нам эсдомы ищутся.
Значит, что нам нужно было?
Нам нужно было перебирать все входящие ребра.
Если они ведут из вершины с меньшим таймэйном, то мы просто ее используем.
А если больше, то мы там используем какие-то пути.
А теперь смотрите, как же эти вершины будут выглядеть вообще.
Значит, давайте смотреть.
Ну смотрите, сейчас увидите.
Вот давайте, как эти вершины, которые больше, будут вообще выглядеть?
Они будут выглядеть так.
Вот для этой вершины пусто.
Потом появится вот эта вершина.
Потом вот эта, потом вот эта.
Там потом вот эта.
Это еще пока не появилось.
Я перебираю вершины в обратном порядке DFS.
Там сначала вот эта, потом вот эта, потом вот эта, потом вот эта, ну и так далее.
Потом вот эта, потом вот эта, потом вот эта, потом вот эта.
то есть у нас получается следующее, дальше у нас будет вот эта вершина, потом вот эта, потом вот эта, потом вот эта.
Видите, в каждый момент времени у нас есть какие-то поддеревья, видите, и вот давай, ну вот, потом мы идем, давайте я еще чуть-чуть прогуляюсь, вот я сейчас в какой-то...
Ну разве мы последний еще рассматриваем про этот вход DFS будет родителем?
Ну да, ну да, поэтому я говорю, сначала это, потом это, потом родитель.
Да, но это если бы было в порядке таймы нам и в обратном порядке рассматриваем.
Видите, мы еще идем справа-налево, потому что мы считаем, что DFS ходил сюда-сюда-сюда-сюда, потом сюда-сюда-сюда-сюда, потом сюда-сюда-сюда, сюда-сюда-сюда, вот это.
А мы теперь, да, наоборот, идем справа-налево и снизу и вверх.
Вот, значит идем, идем-идем-идем, потом идем вот сюда, потом сюда, потом сюда, потом сюда, и вот смотрите.
Вот давайте, давайте в качестве примера рассмотрим вот эту вершину.
Вот эту вот вершину, и мы хотим для нее esdomy найти.
Так что у нас уже есть? У нас уже есть, значит перебираем.
По каким ребрам мы вообще могли найти?
Ну, во-первых...
А, ой, пардон, пардон, пардон, да, безусловно.
Значит, смотрите, какая ситуация. Мы перебираем, чтобы найти esdomy, мы перебираем ребра, да?
Мы перебираем ребра в нее входящие. Что это за ребра?
Ну, это, безусловно, вот это ребро, и эту вершину мы прям напрямую проверяем, да?
Или это может быть прямое ребро, ну, скажем, вот отсюда?
Ну, там отсюда, или там вот отсюда еще, ну, и мы их перебираем, да?
А еще могут быть ребра обратные, вот такие вот.
И перекрестные ребра откуда-нибудь, оттуда.
Отсюда, или там вот отсюда, наоборот, точнее, да, вот так, да.
Или там вот даже вот отсюда еще бывает.
Понимаете, да?
Ну, теперь смотрите вот так.
Что нам нужно сделать для каждой из этих вершин?
Нам нужно из каждой вершины подниматься до тех пор, пока мы не попадем...
А, пардон, забыл еще.
Так, а еще мы вот эту вершину должны...
То есть мы обрабатываем, то есть вот в каждой из этих вершин мы идем, идем, идем.
Ой, что ж я не все-то дорисовал?
А, потому что этого родителя мы еще не рассмотрели.
Мы должны идти до тех пор, пока не пойдем в общего предка с этой вершиной.
Не включительно.
И найти тут минимум, да?
Но по факту заметим теперь следующее.
Давайте я их так нарисую, что эти вершины на самом деле образуют вот такие деревья подвешенные.
Собственно, это будет наша...
Да, ну да.
Я просто хочу, чтобы вы это увидели.
Почувствовали.
Ага, именно, именно.
Вот.
То есть вот такая вот штука.
А, и еще главное, зеленые ребра так, а вот то, что под деревья, вот они.
И в каждой из этих под деревьев, когда вы идете к какой-то вершину, вам этот минимум нужно идти прям до конца этого...
Не до куда-то дофиксированного момента, а прям пока не кончится.
То есть вот теперь отсюда мы прям вот до сюда должны идти.
А вот отсюда, ну вот до сюда.
То есть получается, есть подвешенные деревья, и нам нужно искать минимумы именно от вершины до корня.
Но когда мы найдем S от этой вершины, соответствующим образом, как у нас деревья поменяются?
Очень просто.
То есть мы просто возьмем все вот эти вершины и вызовем линк.
Ну то есть по сути, потому что деревья будут теперь вот так вот выглядеть.
То есть просто была вершина и к ней что-то подвесили.
Понимаете, да?
То есть в точке зрения интерфейса.
Вот.
То есть вот так вот получается.
То есть дальше потом вот для этой вершины мы там тоже все найдем и потом объединятся вот эти два дерева подвеситься к ней.
Потом вот это и так далее.
То есть заметим, что все эти операции мы будем выполнять с помощью вот eval будет искать минимум.
Link будет подвешивать.
Update даже нет.
То есть на самом деле это не структура eval-link-update, а даже просто структура eval-link.
Потому что мы ни разу не меняем, то есть вот содержимое мы вообще не меняем ни разу.
Понимаете, да?
Не то чтобы нам там, по-моему, это сильно облегхит жизнь, честно скажу, но вот.
То есть таким образом получается, что s.
Да мы, обратите внимание, так как мы все делали за v плюс e до этого, то вот эту штуку мы сделаем за, получается, n-1.
Ну то есть смотрите, eval у нас будет ну сколько?
От e.
Ну точнее не более, чем e, если быть точнее.
Или даже не более, чем может быть e минус v плюс 1.
Ну потому что eval с зеленым красным ребром не может оказаться ребро дерева dfs.
Поэтому v минус 1 я на всякий случай вычил.
Ну чтоб совсем точная оценка была.
А то вдруг это ноль.
Тогда задача вообще не интересная.
Значит сколько будет link-ов?
Ну link-ов будет ровно 0.
Но link-ов будет ровно v минус 1.
Ну тут без вопросов.
Потому что по факту мы занимаемся тем, что мы просто с помощью link-ов строим просто исходное дерево.
Update.
А их нет.
Просто их ноль.
Тогда получается, что если мы научимся делать link-и и eval-ы за какое-нибудь адекватное время, скажем за обратную функцию кермана,
то тогда, обратите внимание, кроме обратной функции кермана мы все за v плюс e делаем.
Мы все делаем за v плюс e и все.
Ну вот, то есть это означает, что по крайней мере esdomy мы с вами успешно нашли за обратную функцию кермана.
Остается теперь только воспомнить.
А мы же помнится idem-ы.
А теперь остается помнить.
А как же теперь с помощью esdomy найти idem-ы?
Вот, по крайней мере esdomy мы за адекватное время нашли.
Причем более это, ну вот.
А как же нам теперь сделать?
А теперь по esdomy idem-ы.
Вопрос на миллион.
Ну, практически да.
Ну, можно на миллион или как это бывает в диалогах о рыбалке.
Как это, да, как установить эту насадку?
На самом деле это сложный вопрос, как говорят, как говорим, мы, профессиональные рыбаки, без пол-литра не разберешься.
Но конкретно сегодня я тут как раз немножко подготовился, вот у меня реквизит, так достает бутылочку с стаканом.
Вот сейчас давайте я попробую так выпивать стаканчик.
Ну, в принципе, на самом деле эта задача не представляет из себя ничего сложного.
Ну вот, мы берем вот эту вот деталь, обратите внимание, вот ставим и начинаем вот крутить вот эту ручку.
Да, деталь отваливается.
Ну, я тут пока еще поразбираюсь, а вы пока смотрите сюжет.
Не, очень добрая пародия, на самом деле, я очень рекомендую.
Ну, в общем-то, видимо и передача была добрая.
Сейчас, по-моему, это уже только на отдельных тематических каналах подобное выпускают.
Ну, а когда-то, может, оно на первом и было.
Нет, просто такое, такое показывали там на этом предшественникам МАЧ-ТВ, как ее там Россия-2, Спорт-1, вот это все.
Вот, ладно.
Теперь финалочка.
Что нам нужно, чтобы по Эздумам найти айдомы?
Нет, напоминаю.
Не, на самом деле, идея такая, то есть напоминаю, что с точки зрения, когда у нас появились Эздумы,
у нас вообще есть только дерево ДФС и прямые ребра, в чем в каждой вершине оно одно.
Вот, вот есть такие ребра и, соответственно, там всякие прямые.
Вот такие, там такие и так далее.
И напоминаю, у нас идея была в следующем.
Идея была у нас в том, чтобы когда у нас, если мы хотим для какой-то вершины w определить ее айдом,
то мы должны были взять айдом,
рассмотреть подотрезок между айдомом не включительно и w включительно,
то есть рассмотреть все эти вершины и рассмотреть минимальный айдом на них, то есть самый высокий.
Если мы его найдем, то, соответственно, там все за о от единицы, то есть либо он выше Эздумы,
и тогда мы айдом копируем прямо отсюда, либо он окажется не выше, чем Эздум от w,
ну тогда мы этот Эздум в айдомы пишем.
То есть, по сути, у нас есть вот такие запросы.
Как же нам этот минимум находить?
Идея такая, слава богу, нам нужны эти минимумы, они от айдомов не зависят, правда?
По сути, у нас мы можем эти все запросы обработать в оффлайне, согласны?
То есть, если Эздум есть, значит будем обрабатывать в оффлайне.
А как это сделать? Так вот, у меня идея такая.
Давайте запустим DFS,
давайте запустим DFS, и будем говорить так.
Когда я пришел в вершину, то есть моя цель будет следующим.
Я сначала запущусь рекурсивно от всех под деревьев,
а потом переберу все ребра, все такие вершины w, что я это их Эздом,
но я же могу для всех вершин заранее предоставить.
Я же могу для всех вершин заранее предзаписать чьей я Эздом,
а могу даже в этом же DFS записывать.
И тогда после этого...
Какую? Где структура?
А вот, смотрите.
Вот у нас опять то же самое дерево.
Вот опять то же самое дерево.
Но тогда идея у нас такая.
То есть идея будет такая, что каждую вершину,
то есть мы опять будем пытаться с помощью линков строить то же самое дерево.
Ну и в каждой вершине в качестве лейбла хранить таймы на Эздома.
И идея такая.
Когда мы приходим в вершину, наша цель, чтобы у нас на выходе из этой вершины
образовывалась, то есть вот линки образовали под дерево,
вот это вот под дерево со всеми вершинами корнем в ней.
То есть в этом случае, тогда если мы так будем делать,
значит мы тут идем, и тогда у нас образовалась...
На момент, когда мы вышли из всех, пришли в эту вершину,
обработали тут каждое под дерево,
и все эти под деревья объединили с помощью линков вот в такие деревья.
Ну тут еще всякая вот эта, тут всякая еще вот такая.
Нет, это мы не объединили.
И тогда идея будет очень простая.
То есть тогда в этих деревьях,
то есть эти деревья мы храним в нашей линковал структуре,
и тогда каждый раз, когда у нас, если это Эздома w,
берем w, запускаем из него эвал,
и соответственно по этому по результату,
золота единицы определяем, кто у него айдам, правда?
Вот, понимаете?
А потом после того, как мы все это перебрали аккуратненько,
все, что нам остается, это прицепить эти деревья к этой вершине.
Более того, кстати, в качестве добивочки скажу,
в оригинальной статье Эздомы и айдамы ищутся одновременно.
Ну, ищутся одновременно по одной простой причине.
Вот эту операцию, которую делаем по барабану,
просто в таком ДФС искать,
или просто перебирать вершины в порядке убывания.
Ну, будет-то то же самое.
Нам же самое главное, чтобы мы вот эти все вершины обработали до этой вершины, правда?
То есть там будет идея,
то есть мы строим одну и ту же структуру на одних и тех же Эздомах,
потому что нам все равно и там и там надо жила-была вершина,
и вал должен искать там минимум Эздомов от нее до текущего корня.
Ну вот тогда мы просто одновременно там найдем соответственно и Эздом от нее,
ну вот, соответственно и с одной стороны Эздом,
а с другой стороны для всех вершин, для которых она Эздом,
мы найдем айдам и потом прицепим.
То есть это можно вот одновременно делать.
Ну, можете неодновременно, если вам сложнее, вы можете написать,
сначала найти по Эздому, потом по Эздому айдам,
или вы делаете одно и то же.
Ну вот, то есть таким образом мы тоже здесь справились
за в плюс е умножить на а там,
за сколько вы там делаете эти вал с линками.
Ну вот и вся магия.
