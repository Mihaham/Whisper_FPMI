Ну, сформулируем так, так как сейчас будут достаточно
простые вещи, то мы ускорим процесс с помощью презентации.
Ну, пока сейчас точно просто, значит, во-первых, так мы
живем в строках, поэтому у нас появляется понятие
алфавит.
Что такое алфавит?
Ну, это просто набор таких, то есть чего-то, что мы будем
воспринимать за буквы или символы.
Ну вот, мы будем жить с конечными алфавитами.
То есть алфавит, какие у нас бывают, от а до z, от 0 до
9, бывает 0 и 1, ну и в общем как угодно.
То есть обычно в каждой задаче оговаривается, здесь
перечислены самые типичные.
Вот, значит, строки.
Что такое строка?
Это конечная последовательность символов, не более того.
Значит, единственная маленькая оговорочка заключается
в том, что иногда строки, символы в строке будем
набирать в один индексации, иногда в ноль.
То есть иногда оказывается, что в z функции удобно все
делать в ноль индексации, а в префикс функции в один
индексации.
Вот, начнем мы сегодня с один индексации.
Конечно, не одинобразно делать?
Ну, в плане…
Ну, нет, просто…
Если не одинобразно, то меньше бабов.
Нет, ну это, конечно, да, но с другой стороны, с точки
зрения теории иногда вот как-то префикс функции,
она на самом деле просто такую значительную часть
своей красоты теряет, если вы начинаете работать
в ноль индексации.
Вот.
Так что тут момент такой.
Да, значит, еще у нас будет понятие подстрока, и тут
у нас действительно важный момент.
Да, то есть мы будем писать вот какую-то такую штуку,
то есть s от и g, это будет означать, что у нас в эту
строку входят все символы от it включительного до
z включительного.
Ну, сразу еще давайте оговоримся, что может быть, конечно,
не гарантируем, что мы иногда будем употреблять там
всякие вещи типа, значит, вот такие, то есть типа
полуинтервал от и включительно, даже не включительно, но
там может быть вот так вот, где-нибудь, когда-нибудь
встретятся вот, то есть вот, то есть такие вот обозначения
строчек у нас будут.
Ну и здесь пока, соответственно.
Так, ну и, конечно, будем считать, что пустая строка является
подстрокой любой строки.
Вот.
По соответствии.
По соответствии.
То есть это вот мы тоже так считать будем.
Итак.
Ну какие еще тут, какие у нас тут еще классические
определения есть?
Классические определения еще говорят, что вот есть
длина строки, значит, ну длина строки это модулес,
значит, и есть, соответственно, также префикс длины l и суффикс
длины not и суффикс длины l.
Так, вот здесь обратите внимание, здесь произошел
перенос.
Суффикс длины l у нас это подстрока вот, видите,
модулес минус l плюс один.
Ну понятно, да?
Чего?
Смешной получилось с переносом.
Ну вот.
Да.
То есть, на самом деле, не путайте.
Еще мы сразу скажу, будем иногда употреблять такое
словосочетание, как l-ты суффикс.
Так вот, обычно под l-ты суффикс я подразумеваю суффикс, который
начинается в l-тым символе.
Но это я просто предупреждаю, что вот такое может быть,
если что.
В l-тым символе.
Ну любой суффикс у вас это вся строка, да?
Да.
Ну если строка в ноль индексации, разумеется.
Ладно.
Вот так.
Ну то есть, скорее всего, так, по контексту будет понятно,
что имеется в виду, вот просто предупреждаю, что тут, возможно,
разные терминологи.
Да.
Не очевидно, как бы.
Да.
Ну поэтому я вот и проговариваю, что это возможно.
И?
Ну интуитивно.
Не знаю.
Вот.
Вот интуитивность тут проблема.
Мне это как раз интуитивно, поэтому, соответственно.
Ну просто интуитивно делать все единообразно и с суффиксами
работать справа-налево, как бы, и тогда нулевой суффикс.
А вот мы будем работать с суффиксами немножко слева-направо.
Вот уже, Сергей, уже сейчас префикс функции мы с этим
даже познакомимся.
Ну в суффмассе не тоже слева-направо.
Ну вообще, да.
То есть там и там с суффиксом считается то, что начинается
в l-тым символе.
Ну там опять вопрос терминологии.
Так это можно назвать не l-тым суффиксом.
Но это логично.
Но там, оказывается, удобнее.
Ну
slowed у 그것 дали в
мы ищем подстроков таки двумя указателями на самом деле, да, собственно как
говорится, да, возможно удивляет, но собственно покажу откуда это берется, но пока
значит немножко терминологии, значит s у нас является, да, ну понятно сама строка
является как своим префиксом, только своим суфиксом, но все остальные префиксы
суфиксы мы будем называть собственными, вот, ну конечно у нас классическая задача
о поиске под строке, то есть дана строка p и s, скажите, пожалуйста, ну такая
простая постановка могла быть, входит ли строка p в строку s как подстрока, да или
нет, ну или там, или вот нас так же будет интересовать, а найдите, пожалуйста, где,
вот прям по списку, знаете, как вот, когда алгебры говорят, решение, что такое
решить уравнение, найти все его корни и доказать, что других нет, да, вот, вот здесь
примерно то же самое, но у нас, ну фактически такая задача в некотором смысле у нас будет
просто красной нитью проходить по всему нашему блоку строковых алгоритмов, то есть как бы
уровень easy это ищем одну подстроку в одной строке, уровень medium, так сказать, значит ищем много
подстрок, но в одной строке они все заданы заранее и, конечно, уровень hard мы ищем подстроки в строке в онлайне.
А это не принципиально, потому что искать много подстрок в многих строках, это то же самое,
как искать много подстрок в одной строке сконкатинированной из кучи, так что это и
не hard, это когда строка, в которой вы ищете, тоже задается в онлайне, но там смотря в
каком смысле, то есть если у вас там приходят даже запросы вида поменяйте символ строки,
то это, конечно, расстрел, это да, кстати, уже задача, дан текст, и приходят два запроса,
первая, дана строка penid, входит ли она в текст как подстрока, и второй запрос,
а поменяй, пожалуйста, и ты символ на вот это. Время пошло.
Ещё лучше это операция с такой, как с дикарточком. Да, тут хоть один символ поменял.
При свой на отрезке, там начинается мясо. Ну, конечно. Итак, мы пока начнём с простого
уровня, просто дана одна строка, дана один шаблон и дан один текст.
А мы будем искать в домашнем задании идеи? Чего искать? Идеи. Какие идеи? Как решать? Как решать D2 2019.
Что такое D2 2019? Поиск идеи. Так, ну понятно. Видимо, я с Лётой не помню задачу. Ну понятно,
возможно, я не помню или даже не знаю задачу. Ну, разберёмся отдельно, может быть и будем,
не гарантирую, потому что я пока не видел задачу. Может быть, в будущем мы столкнёмся с ней,
почему бы нет. Скорее всего, я должен был что-то подобное видеть, но дойдём. Момент понял. Хорошо,
значит D2 2019 вас интересует. Хорошо. А что, там-то прям что-то страшное? Ну, там типа строка можно,
ну короче, там персидентное 2-3 дерева. А, ой-ой-ой, а это точно? Знаете, это Миша как блокирующую задачу и
остальные поймают. Нет, погодите, погодите, нет. А, это так, это ЗДД. А, я что-то не вспоминал,
как задачу на строке. Ну, формулировки там строки. Ну да, но в итоге мы приходим к персидентному 2-3,
сначала декорточок, потом 2-3 дерева, как оптимизация, как у пихон по памяти. А это я примерно
помню, это веселье. Окей, ладно, идём дальше. Вот, значит, смотрим, что это значит, как решать такую
задачу. Ну, самое тупое, самое тупое, конечно, это давайте переберём действительно у нас все строки,
то есть переберём все подстроки и каждую ту по сравним. Кстати, в общем случае, это может
оказаться не самое плохое решение. То есть да, сим-точка, конечно, п на с, и действительно перебирать
придётся, ну и там можно придумать пример, когда мы реально будем сток перебирать. Но в некотором
условно-рандомном случае, на самом деле, скорее всего, если это не подстрока, то отсекаться будем
быстро. Вот, то есть это как бы вещь такая. Вот, но, значит, но оказывается, у нас есть более быстрое
решение, в которое мы вводим префикс функции. Вот, так, ну возникает вопрос, что такое префикс
функция? Ну, здесь вот, да, здесь написан какой-то текст, давайте нарисуем картинку и поймём,
что он вообще значит. Ну, значит, он примерно следующее. Жила была строка P, вот нам жутко
интересно. Вот, и нам в каждой позиции И очень интересно найти максимальной длины префикс,
длины меньше, чем И, который совпадает с подстрокой заканчивающейся в этом символе. Вот, то есть,
в общем-то, вот там написано ровно это, то есть остаётся только добавить, что тут вот L и L.
Нет, то строго в И он должен заканчиваться. Да, да, как я говорю, да, вот именно поэтому,
то есть указывает, что L должно быть строго меньше, чем И. Наоборот, как раз, собственный. То есть,
скажем так, собственный, то есть как бы L это должен быть собственный суффикс префикса длины И,
вот так. Вот я избегаю такого словосочетания, потому что это немножко расстреляно звучит,
но тем не менее. Не, он и собственный префикс, и собственный суффикс. Да, на самом деле, да. Вот,
ну а теперь возникает вопрос просто, откуда эта штука взялась? Ну, на самом деле, давайте попробуем,
вот прежде чем двигаться дальше, то есть на самом деле сейчас я могу, можно просто попробовать
сказать, откуда это вообще берется. А берется вот откуда. Смотрите, то есть, на самом деле,
предположим, что у нас есть мистический черный ящик. Вот есть мистический черный ящик,
который умеет брать какие-нибудь две подстроки и сообщать, равны ли они, да или нет. В принципе,
возможно, вы даже в некотором смысле писали такой черный ящик в виде полимеральных хэшей. Но мы
сейчас не будем, конкретно сейчас мы не будем прописывать, что это вообще такое, как-то пишется.
Ну а теперь возникает вопрос, как искать подстрок в строке с помощью такого черного ящика?
Надо было, наверное, здесь сказать, что между РС и П плюс С есть решение бинпоиск с хэшами.
Нет, бинпоиск даже не нужен. Нет, бинпоиск даже не нужен, потому что в данном случае,
если вы ищете подстроку с помощью хэшей, то вы просто перебираете все подстроки длинной
П и проверяете. Так что, соответственно, да, это, наверное, это действительно может быть не так
хорошо. Хотелось бы, наверное, чего-то еще. А теперь давайте попробуем, собственно,
применить, попробовать искать этот метод двух указателей. Раньше говорили, что магия просто говорит
о том, что мы умеем просто взять две рандомные подстроки. А теперь идея такая. Давайте вообразим
себе, что мы идем в тупую. А именно, вот берем самое начало строки С и честно сравниваем,
совпадает ли, совпадает ли, значит, там подстрока, начинающаяся с первого символа строки С,
с соответствующим префиксом строки П. Вот она идет, совпадает, совпадает, и опа! И вот очередной
символ не совпал. Видно, да? Вот. Ну, теперь мы начинаем думать. Вот такая подстрока совпадает,
но дальше мы как бы этот правый указатель сдвинуть не можем. А теперь идея такая. Давайте сдвинем
левый указатель, давайте нот. То есть для первой строки такой, для строки начинается со следующего
символа вот. Сейчас, это вы зафиксировали префикс? Чего я зафиксировал? На плане книги у вас
фиксированная, да? Нет. Нет, я вообще уже сейчас другое... Нет, забыли давайте об этом. Нет,
я делаю вообще другое. То есть у меня как бы идея теперь такая. То есть я вот с какой стороны
начинаю на это смотреть. Я начинаю на это смотреть следующим образом. То есть я попытался рассматривать
же не позицию... То есть я сейчас не ищу префикс функцию, я ищу подстроку в строке. То есть я не
знаю никакой префикс функции, я пытаюсь ее придумать. Ну, может даже не ее. И поэтому я начинаю вот тут
просто тупо сказать, случайно эта строка П вот здесь прямо не входит в строку С случайно. Вот.
Ну вот, допустим, я тут шел-шел-шел и выяснилось, что у меня вот какой-то префикс совпадает,
но вот, но не более. Тогда какая у меня идея возникает? Тогда давайте посмотрим с первым,
то есть вот со следующим символом. То есть это был первый, начиная с первого и со второго. Вот.
Ну что здесь можно сказать? То есть теперь идея такая. То есть давайте тоже используем ту же магию,
вот этот черный ящик, но мы его будем использовать чисто внутри строки П. Вот предположим,
что нас теперь черный ящик не может нас отсылать к подстроке С, но он может нас отсылать к двум
подстрокам строки П. Такой черный ящик. Тогда мы просто, мы хотим проверить, а верно ли,
что вот эта строка совпадает с префиксом строки П? Ну, заметь, ну вот. Ну, заметим, что это то же
самое, что проверить, верно ли, что вот эта подстрока совпадает с вот этой подстрокой, правда?
Вот. То есть заметим, что если она, ну если она не совпадает, то с этого символа на самом деле
ходить бессмысленно, потому что значит до конца П мы отсюда точно не дойдем, правда? Вот. А если
совпадает, то наоборот, мы уже здесь проскочили, получается правый указатель, можно двигать дальше.
То есть, по сути, тогда идея приобретает следующий вид. То есть, мы двигаем левый указатель до тех пор,
пока вот эта подстрока, соответственно, не совпадет с префиксом строки П. Как только она совпадет,
значит правый указатель двигаем до тех пор, пока не упремся. Да, ну или, кстати, упираться она
может еще потому, что строка П закончится, это означает, что мы вхождение нашли. Это не значит,
что мы остановимся просто значит двигаем левый указатель и ищем следующее вхождение вот то есть
оказывается есть у нас есть черный ящик с хэшами только для строки п то вот таким вот простым методом
двух указателей на самом деле мы можем решить задачу понимаете да осталось только выяснить как
избавиться от черного ящика а черного ящика избавиться оказывается очень просто потому что
вот мы в данном случае получается с этим взять минимально вот у этой строки максимальной длины
собственный суффикс который совпадает с префиксом правда вот ну вот собственно мы и пришли к
определению префикс функции удобно правда да нет наверное вот то есть вот получается что и действительно
то есть отсюда тогда и получается что если вы насчитали префикс функцию для строки п то в принципе
тогда с помощью префикс функции вы тогда явно уже вот например вот этими двумя указателями можете
найти под строку строки с остался только понять а как саму префикс функцию вообще найти вот как же
ее найти но давайте смотреть так так ну тут написано какая-то параллель ну первая лепка
штаб п от леденицы равно очевидно нулю ну там без вариантов в общем-то да а вот дальше написано
что п от и плюс первой не превосходит п от и плюс один вот ну тут написан какой-то текст опять вот
но его доказательства на самом деле но как всегда у нас сейчас будет это все в стиле там доказательстве
написано какой-то формальный текст давайте нарисуем его на картинке и все будет и все станет видно
и поймем почему даже обсуждать его не надо ну вот нет то почему-то обсудить то стоит вот ну
значит давайте посмотрим потому что вот у меня есть и и плюс один действительно давайте рассмотрим
префикс функцию для позиции плюс один то есть вот эта подстрока совпадает допустим с вот этой
но тогда заметим что и вот эта подстрока на единичку меньше тоже совпадает с префиксом то
следует на п от и это как минимум вот эта штука минус 1 нет у нас нет наоборот у нас есть строка
для и плюс один и вы вытянули по последнему символу получилось строка для отсюда следует
что п а ты больше либо равно чем при плюс один минус один более того даже сразу можно заявить
что если на самом деле вот этот символ совпал с вот этим то есть там с там вот это вот то есть
вот этой длины плюс первым символом то тогда это п и плюс один равно в точности п и плюс один
прям в самом начале когда вы читаете префикс функцию можно прям то есть допустим мы будем
вычислять префикс функцию как вы уже догадываетесь лево направо то и плюс первый символ то когда мы
уже знаем присутствия и и всех раньше кто мы говорим что если x совпадает тут так сказать
п от и плюс там п от и заканчиваем скобочку плюс первым символом строки то есть как бы это
получается и плюс первый символ а этот символ получается значит п от и плюс 1 то есть если они
совпали то значит мы п и плюс один тоже прекрасно вычислил вот остается только внимание вопрос а
что делать если он не совпадает вот ну формально говоря возникает что дальше то есть если п и
плюс первое не равно п и плюс один то следующее что надо проверить это п от п и плюс один
почему так очень просто то есть на самом деле то есть вот эти вот леммы можно расписать следующим
образом то есть даже без формального текста но я думаю так формальный текст можно не переписывать
просто потому что презентацию я вам естественно вышли вот чего не веришь
наверное может быть но это да такой телефончик может уберешься
ну что нет именно уберешь они там это большой соблазн его опять заглянуть что там писать как
и вот перерывы будут не волнуйся вот так смотреть то есть на самом деле все до дальнейшей леммы
имеют следующий смысл то есть вот действительно давайте посмотрим вот мы у нас есть вот такой
и ты символ там есть и плюс первое вот мы хотим найти префикс функцию то есть максимальной длины
вот какую-то такую строчку которая совпадает с префиксом но что для этого но что это означает
но то есть если отпилить по одному символу то есть вот тут получается такой x или да то
получается подходящая строка для и то есть получается что должно быть что вот и должна
быть строка на единичку меньше совпадать соответствующим префикс и тогда будет какая-то
идея такая а давайте переберем все такие строки то есть как перебрать для и для и все такие под
все такие суффиксы которые совпадают с префиксами в чем желательно давайте переберем в порядке
убывания то есть сначала самый первый ну самый самый первый проверим там получается ли с ним
если не получается то второй потом третий и так далее и так далее пока не сойдется да понимаете
да что не так сейчас у нас есть вот это вот вот мы знаем что какая-то величина этой штуки есть
мы знаем что последний символ не совпадает ну нету это значит что нам нужно попробовать взять
какую-то чуть меньшую длину суффикса который совпадает с префиксом и попробовать приписать
к нему этот символ здесь и здесь проверить совпадают ли они ну почему нет ну хорошо
можно как бы формальное доказательство так провести но на самом деле суть от этого не
поменяется ну давайте еще раз то есть задача надо найти какой-то такое как какую-то такую
подстроку заканчивается в плюс первым символе которая совпадает с префиксом правда да максимально
возможной длины всех таких но что она из себя представляет а да то есть если она там длины
какой-то и она представляет из себя под строку длины l-1 заканчивающиеся в этом символе которая
совпадает с префиксом да вот и причем после которой еще идет символ символ икс а теперь
идея такая рассмотрим таких строчек ну про икс конечно я ничего не знаю но вот строчек но
для и таких строчек которые совпадают с префиксом вот заканчивается в этом символе
спадают префиксом их может быть несколько правда так вот давай идея такая а давайте переберем
каким-то образом все такие строки в порядке убывания длины и для каждой из них проверим
не идет ли у соответствующего префикса за ним символ икс если если нам какие-то небеса по
факсу будут присылать эти длины в порядке убывания просто будут при ноте в порядке то тогда заметим
что мы эту префикс функцию будем искать за линейное время почему а вот почему потому что то есть
работать это будет примерно так потому что значит сам по штабу но опять чем с того что самая длинная
такая подстрока но мы же ищем сам префикс функцию то есть самую длинную только по строчку да это
что такое это есть префикс функция найденная ранее то есть раньше мы работали вот с этой подстрокой
если нам вот эта штука не помогла то тогда мы ищем вторую совпадающую какие-то небеса нам присылают
и она на самом деле уже вот такая то есть мы ну скажем так можно и так но как бы а можно через
метод двух указатель сразу это увидеть потому что да можно понятно там в презентации будет
конечно введен метод потенциалов и действительно введение через потенциалы но это нам не нужно на
самом деле то есть по большому счету то есть то есть как бы если мы перебираем все подстройки
вот заканчивается совпадающий префиксом то есть берем когда вторую то есть получается мы левые
указатели сдвинули и смотрим можем ли сейчас сдвинуть правый вот эта идея да вот поэтому
собственно префикс функции на самом деле такой метод двух указателей но осталось только выяснить
откуда нам эти вот такие подстройки вот по порядочку брать ну классическая идея конечно давайте
просто в тупую перебирать и проверять совпадает ли подстрока с префиксом но это мы делаем отсылку
к черным ящику для строки п да но на самом деле в этом нет необходимости потому что в реальности
вот мы думаем вот у вас есть подстрока просто даже какая-то длины длины допустим даже не
эля там какой-нибудь там л штрих которая совпадает с префиксом как найти следующую такую длину
л 2 штриха которая совпадает с префиксом как вы найти нет а это не там надо смотреть это от
смотреть здесь посадите мы же уже знаем что вот это строка равна вот этой строке да это означает
что вот эта строка равна вот этой строке то есть получается у префикса длины л штрих надо найти
максимальной длины собственный суффикс который совпадает с префиксом то есть в переводе говоря
л 2 штриха это просто префикс функция от л штриха удобно правда то есть более того когда после
л 2 штриха надо найти следующую мы тоже должны просто взять там п то есть п от л штриха то есть
п от л штриха и так далее то есть в результате это приводит нас то есть действительно к
достаточно простому следствию то есть вот идем идем идем вот то есть получается там код просто
вот ну совсем простой а нет это не совсем то хотя нет это тоже на самом деле то сейчас вот давайте
это не совсем то так так сейчас ну да нет все нормально просто мы для стратегии с ищем
префикс функция то есть префикс функция получается ищется вот очень простым вот таким методом вот
то есть по большому счету идти то есть мы как бы то есть вот то есть видите то есть мы тут
скайон вот то есть фактически вот обратить внимание тут ваил так очень удобно сделать то есть
вайла скачет пока у нас этот вот длина это его префикса суффикса не сожмется в ноль вот но в
конце мы правда префикс функцию там увеличиваем на 1 от текущего g именно когда вот но вот именно
совпадают но тут это вот интересное такое за замечание получается если g равно нулю
то оно тоже работает вот то есть получается вот такой простой код то есть можно ввести метод
потенциалов и доказать что это работает за линию ну потому что по классике увеличивается nicto
то есть никогда не станов Moses 0 меньше но они становятся и анн раз увеличивается на один и
никогда он не уходит минус следовательно Orthodox skating уменьшается значит скачков
суммарно не более чем n, но на самом деле можно просто заметить, что это
простые два указателя. То есть тут десятью способами можно это
увидеть. То есть вот так мы нашли префикс функции. Понятная идея, да?
Что тут еще тогда важно знать про префикс функции?
Еще важный терминологический момент еще есть. Как с помощью префикс функции
искать подстроку в строке? Но тот вот, смотрите, есть тонкий момент. Потому что
самый тупой, потому что в принципе есть вот такое понятие как алгоритм Кнута
Мориса Пратта. Но он означает, возможно, обычно предельно тупую вещь.
Это не совсем то, что я объяснял. Он говорит просто. Давайте возьмем строки P и S,
сконкатинируем их через доллар, ну или диезик, там как вам будет угодно. Любой
символ, которого нет ни в строке P, ни в строке S. И после этого насчитаем для
всей этой строки префикс функции. И тогда просто прибираемся по зоне строки S,
где она равна модуль P, там и под строка. Где нет, там нет. Обычно по поискам
подстроки префикс функции или там под алгоритмом КМП подразумевается ровно это.
Ну вот, то есть так по идее тоже можно. Это самое тупое. То есть это если для вас
префикс функции просто черный ящик, у которого вы просто выучили код, то как бы да, так работает.
Но на самом деле, если в префикс функции поразбираться, то можно сделать небольшую
оптимизацию. То есть пару оптимизаций. Ну во-первых, тут еще важный вопрос в какой-то
момент возникает. А сколько дополнительной памяти вы используете для поиска подстроки в строке?
Вот дополнительной памяти. Да, здесь P плюс S. Ну на самом деле, ну заметим в шоке,
что в явном виде вот эту конкатинацию можно не хранить, правда? То есть не надо там,
условно говоря, копировать там P и S куда-то в одно место вам не надо. То есть на самом деле,
конечно, можно там написать какую-нибудь функцию, которая там по числу И возвращает вам символ
либо строки P, либо строки S, либо доллар. Ну там просто И в чекам, да? То есть это как бы
симпточку вам не ухудшит, но по памяти вам... Ну и утверждение. Но по хорошему, чтобы сконкретинировать
две строки, нужно тоже потратить P плюс S в дополнительной памяти. Вот. Но я просто сказал
только что, что от этого, то есть от этого можно избавиться. Но кажется, у нас от префикс-функции
нужна не больше, чем... Да, но на самом деле, но на самом деле, да. Я утверждаю, что на самом
деле нам префикс-функцию реально хранить надо только для строки P. Да, почему? Ну просто обратите
внимание, что когда мы тут, мы к ней вот обращаемся вот в этих местах, но на самом деле вот эта штука,
это просто предыдущая префикс-функция, то есть на самом деле надо было просто здесь написать
типа, что если вот верно вот эту равенство, то просто плюс-плюс G, а иначе G равно нулю. Вот. И тогда,
на самом деле, вот в этом присваивании необходимости бы не было. То есть таким образом,
реально префикс-функция нужна только здесь. Вот. Но заметим, что если... Но заметим, что как бы,
если у нас есть P доллар S, то легко заметить, что у нас префикс-функция больше, чем модуль P,
не становится никогда в принципе. Правда? Поэтому получается, что в реальности, оказывается,
удобно сделать даже по-другому. Удобно сделать, посчитать префикс-функцию для строки P вот таким
образом, а для строки S после этого взять G равно нулю и делать абсолютно тот же самый проход.
Понимаете, да? То есть делать проход, но просто каждую новую префикс-функцию, то есть каждое
новое значение префикс-функции не сохранять. А просто говорить, так, если у меня получился модуль P,
значит, ой, ура, мы нашли под строку. Но записывать ее не обязательно. То есть более того,
это получается алгоритм даже в некотором смысле в онлайне, потому что мы можем даже строку S
не хранить, а просто приходит новый символ, мы там пересчитываем префикс-функцию.
Да, то есть он онлайн относительно текста, да. То есть мы фактически нам дали шаблон P,
мы сделали на нем какое-то шаманство, и после этого мы теперь любой текст можем обрабатывать
условно в онлайне. Да, но мы умеем не просто только добавлять, а только pushback. Совершенно верно.
Но уже, тем не менее, неплохо. Более того, на самом деле, то есть на самом деле можно это еще
пооптимизировать, и это иногда помогает даже. Там даже не оптимизация, а следующая логика,
что если мы добавляем в строку S символы по одному, то у нас может, алгоритм может зависнуть.
Ну потому что у нас же алгоритм работает за линию, но он амортизированный, правда? То есть на
каждой конкретный вайл может работать за O от P. Но на самом деле с этим тоже можно справиться.
Нет, на самом деле тут идея такая. Потому что на самом деле заметим, что вот этот проход,
вот этот вайлер, на самом деле можно тупо сжать до функции go. На самом деле, смотрите,
заметим следующее, что у нас в этом коде происходит. Мы берем предыдущую функцию,
префикс-функцию, и пытаемся приписать ей какой-то символ. Теперь заметим,
что от самого по себе И, вот эта вот штука вся, не зависит от слова никак. То есть она зависит
только от самого символа. То есть если бы я тут написал charge равно SE, то в общем-то дальше код
никак бы и не использовал, правда? Да, то есть более того, если быть точнее, я хочу написать
auto. То есть у меня ощущение, что у меня есть структура такая, что у меня есть текущая
префикс-функция. Я приписываю символ, и префикс-функция как-то меняется. Причем новая префикс-функция зависит только от
предыдущей, ну там внутри строке S, новая префикс-функция зависит только от предыдущей префикс-функции и символа.
Что это значит? Префикс-функции автоматной префикс-функции. Более того, мы это будем называть
автомат префикс-функции. То есть речь идет об автомате. Можно сказать и так. То есть действительно можно
заметить, что эту функцию можно узнать до функции go соответственно, которая по сути более того,
она в некотором смысле даже ее можно рекурсивно реализовать. Потому что мы говорим, вот мы хотим,
вот смотрите, у нас сейчас префикс-функция в строке S. Давайте вот на эту строчку посмотрю. То есть мы
говорим, что жила была у нас опять строка P, жила была строка S. Мы прошли из символа в строке S,
и у нас оказалась какая-то строка длины L, которая совпадает с префиксом строки P.
Окей, говорим мы. Так, теперь говорим, если мы к этой строке теперь припишем новый символ,
там какой, ну, например, X, то есть и плюс первый, то как у нас поменяется вот это вот суффикс этой
имеющейся строки, совпадающий с префиксом P? Ну, поменяется он тут два варианта. Но он будет либо,
тут окажется, что тут тоже символ X, и тогда мы делаем вывод, что там L плюс один, либо,
значит, нужно искать какие-то меньшие строки. Как их искать? Ну, очень просто, как мы уже ранее
убедились, нам просто нужно перебрать все, получается, суффиксы, которые совпадают с префиксами,
мы это делаем с помощью префикс-функции, правда? То есть мы знаем, что если у нас это L,
то следующая строка имеет вид там префикс-функция там P от L, и тут P от P от L, ну и так далее. Понята
логика, да? Вот, и так перебираем до тех пор, пока не найдем строчку, то есть префикс, у которого
следующий символ X, ну или не убедимся, что это 0. Понятно, да? Но заметим, что, ну, как мы уже сказали,
но только идея такая, на самом деле, что после L, то есть если мы от L, значит, на L плюс один
перейти не смогли, то, получается, мы говорим, что, то есть надо фактически делать то же самое,
просто от строки P от L. То есть, по большому счету, мы знаем, что наш ответ не больше,
чем P от L, но там P от L теоретически мог бы подходить, если там символ совпадает, но, в общем-то,
суть делать то же самое, поэтому просто запускаемся рекурсивно. То есть, заметим,
что если бы тут было не L, а P от L, то мы бы дальше делали абсолютно то же самое. Поэтому,
получается, что go от, в нашем случае, там ИА равно go от P от ИА, ну и так далее. Вот, то есть, как бы,
там получается только ифтики, что про вот это вот условие, естественно, неверно, если и уже равно
модуль P, тогда следующего символа тупо не существует. Вот, но это такая маленькая техника. То есть,
вот получается такой автомат префикс функции. То есть, он иногда удобен, там бывают какие-то
задачи, в которых это вот, в которых, как бы, от амортизации лучше избавляться. То есть, знаете,
там есть классическая задача под bore называется. То есть, когда дан bore, по сути, надо находить
подстроки уже в bore. Вот. Вот оказывается, то есть, на самом деле, в чем даже не подбор, а хуже дерево,
потому что, на самом деле, там, то есть, если bore состоял из, там, суммарной длины,
там, адекватных строк, то, как бы, там тоже все в порядке, на самом деле, можно показать по
симптомике. Но, даже если бы в тупую делали. Но, в данном случае, но вот, но если там рандомное
дерево, то лучше, конечно, просто написать автомат и не думать об этом. Вот. Так что, вот такая,
вот штука автомат префикс функции. Вот. Понятная идея. С автомата, что такое автомат строк?
О господи. Существуют ли у заданного текста подстроки, которые удовлетворяют вот этому
автомату? Чего? Это такое, что ли, имеется в виду? Вот. Ну вот. Так что получается такая красота.
Так это вот была у нас префикс функции. Существуют ли у этого автомата подстроки? Да-да-да-да-да-да-да-да.
Да. Так, ну что, есть ли тут какие-то вопросы?
Хорошо. Хорошо. Так, ну ладно. Тут, соответственно, все понятно, да? Ну,
тогда давайте попробуем пойти дальше. Почему честные в кавычках? Ну, потому что, честные,
ну, потому что у нас нет официально, ну, обычно в кавычках придется писать термин, которые как бы
не, то есть мы не вводим там, то есть как бы там, от единицы времени называются честными, если там вот
определение. То есть как бы честное тут имеется в виду, что вот такие, то есть мы как бы пытаемся
неформально донести смысл, считая, что это будет удобнее, чем если мы его распишем формально.
Вот. То есть это, конечно, определенный риск, потому что если это будет непонятно, то там как бы
там читающие вашу статью люди там начнут вылькать, что так, ну, значит, вы пишете неформально,
надо писать формально. Ай-ай-ай. Вот. То есть объяснением, что я написал неформально,
что так понятнее, ну, вот для них это не довод, потому что им оказалось непонятно. Вот. Так что
такие вот проблемы тоже есть. Вот. Но это у нас была префикс функции. Вот. Запомнили, да? Но на самом
деле два указателя можно вывести и в другую сторону. Вот. Так. В какую? Ну, впрочем, можно два
указателя на самом деле вывести в Z функцию. Но там два указателя, конечно, более явные будут.
То есть альтернативой у нас служит такая Z функция. Ну, формальное определение тоже вывести на
экране. Вот. Не, ну, в данном случае честно являлась она не потому, что честно, а в том плане,
что там как бы нет амортизации. То есть как бы это не учетная стоимость, а реальная.
Кто? Z функция N функция называлась? А, ну, правильно. Ну, потому что Z функция это официальное
название, просто научное. Так что, общепринято. То есть понятно, можно там N функцию можно вводить,
в конце концов, есть там очень старая задача A функция в строчке. Нет, ну, в смысле, скажем так,
там многие задачи сдаются тупо хэшами на самом деле. Ну, главное просто местами их нужно сделать
двойными или тройными, но как бы все равно сдаются. Нет, ну, эти дальше по Константе может не влазить.
Зачем нужны птикатные хэши? Потому что меня Дима ломал. Ну, шубы. Ну, просто кажется, что в любой
задаче это невозможно. Ну, скорее всего, да. Ну, там как повезет. Может, проблема в том, что как бы
если вы замените одинарные хэши на трехкратной, значит у вас время работы, скорее всего,
увеличится раза в три. Ну, в смысле, Дима может не хватить корень из 10 до 27. Не, ну, там же неправда,
что прям в три раза увеличивается. Ну, вот хороший вопрос. Ну, и то правда, да. Ну,
можно и так, но тогда дальше надо анализировать, как там совпадает. Ну, я понял, да, согласен,
хорошо, уговорил. Аккуратно везде это написать, самое сложное. Нет, то обычно такие вещи пишутся,
давай напишем функцию, которая просто это делает, там данные две под строки, проверь, пожалуйста,
совпадают ли они. Ну, обычно это делается, просто напиши класс stringHash и создай три таких класса.
Так что это все, ну понятно, это все технические детали, конечно, да. Так вот, значит, идейно z
функция. Так, ну z функция, она в некотором смысле мыслит так назад. Ну, она обычно считается
интуитивно проще. Вот, что в ней происходит? Да, ну, хэшами да, потому что, как минимум,
да, она ищется хэшами и бинпоиском. Потому что на этот раз, то есть на этот раз, если у нас есть
позиция и какая-нибудь, то нас интересует подстрока, начинающаяся, максимальная длина подстрока,
которая начинается в символе и совпадает с префиксом. Ну, картинка вас не должна вводить в
заблуждение, потому что, как бы, эта штука может, как бы префикс, может вполне себе накладываться на
это символ. Вот, вот такая идея. Значит, вот у нас есть префикс функция, вот у нас есть такая,
такой z функция. Вот. Ну, заметим, что, конечно, с помощью ее подстройки в строке тоже можно
достаточно легко искать, правда? Потому что, если такая z функция уже насчитана для всех символов,
то тогда, опять же, p диезик s, то есть делаем вот такой p диезик s, насчитываем z функцию,
и где вот тут z функция у нас хорошая, то есть, где у нас z функция равна модуле p, там мы победили.
Ну вот, то есть, да, только с той лишь разницы, что там начало, вхождение, а не конец. Да,
только такая мелкая, мелкая техническая деталь. Но как же эту z функцию вычислять?
Ну, оказывается двумя указателями. Ну, как ее вычислять? Ну, просто теми же двумя указателями,
потому что, ну, то есть, формально можно расписать вот такую лему. И получается вот так и да. Такое
большое количество букв. Ну а что делать? Да. Но, как бы, я думаю, видимо, сейчас, да, видимо,
как в этом случае происходит на типичных формалках, мы сейчас нарисуем картинку и поймем,
что это вообще значит. То есть, значит, оно на самом деле следующее. Да, там прямо без картинки.
Ну, это уже отдельная задача. Нет, ну, на самом деле можно. Нет, вопрос тут был наоборот,
можно ли по z функции восстановить префикс функции? Ну, нет. Ну, у меня был вопрос когда-то,
как считать функцию хешами. По-моему, это можно было, но не особо тременно. Ну, утверждение нет. Ну,
на самом деле, нет, сформулируем так. Заметим, что z функция, нет, смотрите, тут видимо имеется
в виду идея, что если у вас есть z функция, то как бы сравнивать под строку с префиксом на равенство
вы можете теперь за вот единиц. Да, но правда, к сожалению, рандомные две строки вам сравнить
не удастся, но ничего страшного. Нет, это да, но это уже немножко другая история. Вот, значит,
смотрите, ищем z функцию у мистической строки s. Лемма говорит нам о следующем. Смотрите,
Лемма говорит следующее. То есть пусть у нас есть какая-то позиция i, в которой есть под строка
длины k, вот длина k, вот эта вот позиция i плюс k получается, которая совпадает с префиксом. Вот,
видно, да? Да. Ну вот, то есть идея на Лемма говорит следующее. То есть дальше она говорит так,
что пусть у нас есть какой-то символ, ладно, не здесь, вот давайте пусть у нас есть какой-то символ j
внутри этой подстроки. Так, ну вот, тогда я утверждаю, что если, то есть теперь, давайте
кать вопрос, когда мы начинаем проверять, то есть находить максимальный, максимальную подстроку
совпадающую с префиксом, мы как бы идем, идем, идем и вот до какого-то момента доходим, да? Ну,
теперь, давайте кать вопрос, этот момент, он может быть как бы позже этой границы, а может быть раньше
этой границы, да? Ну, может совпадать, конечно. Так вот, идея такая, если он не доходит до этой
границы, то я утверждаю, что из ранее найденных z функций мы уже прекрасно можем его найти. То есть,
ну, предположим, что мы z функции, вот там идея такая, предположим, что мы z функцию ищем слева направо,
как всегда, вот до сюда дошли. Тогда я утверждаю, что на тему того, дойдет ли она до конца вот этой
подстроки или не дойдет, если не дойдет, то куда, мы можем уже сказать и старые z функции. Почему? А вот
почему. Потому что заметим, что в принципе, когда вы идете здесь до какого-то момента, то это примерно
то же самое, как вы идете в символ, получается вот какой, и плюс к, минус g, да? Видите, вот тут и плюс
к. Нет, не так. То есть, нет, смотрите, вот это длина строки k, то есть здесь получается, то есть, ну да, и плюс
к, минус g, по сути. Нет, вру, вру, вру, неправда, неправда, неправда. Вот давайте, то есть, смотрите,
то есть, вот эта подстрока равна вот этой. То есть, тут и плюс к, а тут g, но тухая нот, то есть,
на самом деле, а, хотя можно и наоборот, тут и ты символ, а тут g, то есть, значит, если тут условно,
там какой у нас первый символ, то тут получается, какой g, минус и плюс первый. То есть, тогда можно
заметить, можно заметить, что вот эта подстрока просто равна вот этой, согласны? Ну, если у нас тут
вот с один адексации. И тогда к чему это нас приводит? Приводит нас к этому, что тогда получается,
мы можем посмотреть z функцию вот этой штуки, g, минус и плюс первый. И, оказывается, следующее,
что если оказывается, что z функции этой штуки меньше, чем вот эта длина, а эта длина, это и плюс
к, минус g, то есть, получается, у нас как бы вот тут где-то все обрубается, да, то есть, вот тут
получается пуп и обрубается, и тут вот тут оба раза х, а тут получается игр. То тогда мы вынуждены
заключить, что и здесь z функцию можно тупо скопипастить отсюда и не париться. То есть,
на самом деле, вот эта лемма, если разобраться ровно, это означает. То есть, там другое,
потому что это все на языке буквок там написано. И более того, вторая идея возникает, что может
выясниться, что тут z функция больше либо равно, чем эта длина, но тогда мы про вот эту z же знаем
только одно, мы знаем, что у нее z функция хотя бы вот столько. То есть, помните, тут вот бывает
ошибка такая, что кто-то хочет прям, то есть, бывает реализация, что кто-то хочет прям скопипастить
сюда прям значение отсюда, но если тут значение какое-то больше, то это означает, что здесь значение
не меньше вот этой длины, потому что мы вот про вот эти две совпадающие строки знаем, что они
совпадают, а то, что они будут совпадать дальше, мы не знаем. Вот. И это, кстати, иллюстрируется
второй леммой. Вот. То есть, в принципе, здесь как бы все то же самое, только в формальном виде.
То есть, я имею в виду, что вот эти строки равны и бла-бла-бла-бла-бла-бла-бла. Вот. И в результате
получается такой достаточно классический алгоритм поиска префикс функции с помощью двух указателей.
Он говорит так. Мы идем слева направо и считаем z функцию, начиная со второго символа. В каждый
момент времени мы храним, то есть, мы храним такую подстроку, совпадающую с префиксом,
которая заканчивается как можно позже. Вот. И дальше говорим, что мы находимся в очередной,
то есть, мы находимся в очередной позиции. Но если она уже вышла за пределы этой строки,
то мы ее начисляем в тупую. Прям вот совсем в тупую. Ну вот, если она попала еще внутрь вот этой
его длинной строчки, то значит, тогда у нас два варианта. Мы берем вот, то есть, мы берем z,
вот g минус и плюс первое. Если оно меньше, чем эта длина, значит, мы его тупо копируем.
Если оно не меньше, то значит, мы копируем вот эту длину и далее в тупую. Вот. Понятная идея, да?
Вот. Ну и, конечно, не забываем обновлять l и r, но и в общем-то получается, что фактически вот эта
строка i и плюс k, она на самом деле держится на двух указателях по сути, потому что по сути получается
каждая в тупую на самом деле вот это вот правый конец этой строки увеличивает хотя бы на 1. Вот.
И тогда получается, что и отсюда тогда становится очевидно, что это, что суммарное время поиска
такой z функции, это линия. Вот. Понятная идея. Вот. То есть, вот даже и код, в общем-то, получается,
не сильно сложно. То есть, более того, можно даже в тупую делать всегда. То есть, по большому счету
писать так, что z и t стартует либо с нуля, если у нас под строка не дошла до i, либо вот взять
просто минимум из длины этой строки z и далее идти в тупую. То есть, можно даже тут не заморачиваться,
потому что вот в этом случае, если она тут не доходила до сюда, то на самом деле у вас просто на
первом же шаге будет фейл. Поэтому в коде это можно не писать. Вот. То есть, вот такая получается
не сильно сложная штука. Вот. Так, ну что, есть ли тут какие-то вопросы? Да нет, наверное.
Да нет, наверное. Нет, наверное. Ну хорошо. Да, ну здесь уже. Вот. Ну и, конечно, теперь, да,
пришло время немножко обсудить, собственно, сам этот черный ящик знаменитый. То есть,
теперь каким образом, вот, ВАЗК действительно тупая идея, да, как сравнивать две подстроки. Ну идея,
на самом деле, берется вот откуда. Предположим, что нам так фантастически повезло, что мы умеем
работать с произвольными числами. Вот знаете, такая мечта. Вот иногда, кстати, всегда верим,
что давайте поверим, что мы умеем работать с натуральными числами произвольной длины. Вот. То есть,
вообще абсолютно там нам плевать, какой величины. То есть, никаких там лонг-лонгов у нас нет,
никаких длинной рифметики нет, просто все за вот единицы. Так. Ну вот. И предположим,
что мы верим, что это за вот единицы работает, а не за какую-то там зашитую адскую фурятину.
Тогда, оказывается, тогда, на самом деле, идея такая. То есть, тогда каждую строчку можно кодировать,
ну просто, вообразите, что каждый символ это такая цифра в какой-нибудь системе
счисления с основанием. Ну, например, 257. Или даже 256. Или сколько у нас там в АСКе кодировки символов?
Ну, погодите, погодите, погодите. Нет, ведущая нулитка, конечно, да, но с другой стороны,
мы же обычно и в хэшах можем подстройки срагивать по принципу. Так, погодите, а длину не совпадают.
Нет, сразу до свидания. То есть, подстройки не совпадают. То есть, можно просто гарантировать,
что мы хэш начинаем, пытаемся вычислять, так сказать, какую-то величину только для строк
одинаковой длины. Вот. Но так можно действительно, но в принципе, хотя с другой стороны,
ну, на самом деле, в принципе, можно, потому что если вы кодируете число в таком варианте,
то есть, фактически, воображаете строку длины n как n-разрядное число такое, то по большому счету
длина не принципиальна. То есть, как бы чем больше длина, тем фактически больше число будет. Ну,
если только у вас, ну, правда, с оговоркой, если, конечно, только у вас первая буква не кодируется
числом 0. Ну, я про это и говорю. Да. Ну, поэтому, ну, в принципе, да, тут два варианта можно. Либо длины
тоже хранить, либо говорить, что давайте у нас, если у нас в Аске, там, допустим, в чаре 256 символов,
да, там, ну, сколько там? Он же, там, сколько? Двубайтный обычно, да? А, нет. Ну, вот. Нет, а нет.
300 тысяч. Нет, зачем 300 тысяч? Вот 257 достаточно. И кодировать все символы от 1 до 256. Тем более,
что часто в этом нет необходимости, потому что у вас в строках обычно нету символа номер ноль.
Потому что у нас, как всегда, как вы помните, в языке си это обычно знак конца строки такой. Понимаете,
да? Поэтому, в принципе, как, поэтому даже можно не заморачиваться. Но, к сожалению, ну, в чем
проблем? Да, то есть, как бы, если мы с такими числами умели работать, то никаких проблем бы у нас
не было. То есть, каждая строка, это вот такое число, можно с ними как-то даже работать, можно там
какие-то подстроки с помощью, даже иногда, даже битовых операций выковыривать. Давайте сделаем
основание, там 512 и не будем париться. Вот. Но, как вы понимаете, в реальной жизни, к сожалению,
это не так. Сейчас. Будем доказывать? Ну, в плане, то, что вставали в степень двойки, оно не повлияет
негативно на то, что если оно, если было простое? Нет, ну, доказывать не будем, но известный факт
повлияет. Хотя, смотря, как считать. Потому что, да, так, ну, давайте официально скажу, что такое хэш,
да? То есть, обычно классические применяемые хэш, это когда мы такие числа все-таки вычисляем,
но вычисляем не его, а остаток в какой-нибудь модулю. Ну, тогда, то есть, он как бы хэш, он как бы тогда...
А, вы пока не берете по модулю. Ну, до этого момента не брал. То ты прикол, я говорю, что если бы у нас была
такая счастье, что мы сколь угодно большие числа берем, то тогда это было бы даже не... То есть,
это была бы не подхачка какая-то с вероятностью коллизии, а как бы абсолютно работающий метод,
и не надо было бы париться и изобретать там какие-то префиксы функции. Почему же мы их изобретаем?
Потому что, на самом деле, оказывается, что такие большие числа мы хранить не можем. Но мы можем
хранить остаток по какому-нибудь модулю. Но идея вот такая. А давайте действительно заведем какие-нибудь
основания A, основания M, и будем сравнивать. Ну, и с точки зрения какой-то интуитивной... Ну,
вообще, интуитивной рандомности говорим, что если строки одинаковые, то хэши точно совпадут,
а если строки не одинаковые, то они, наверное, где-то с вероятностью один делить на M. Ну, может,
нам не повезет. И тогда чем больше M, тем лучше. Ну, там дальше что такое M? Ну, потому что самое...
Ну, тут, конечно, по-разному. Ну, здесь давайте первое, что хочется. Ну, наверное, хотелось бы,
чтобы если строка поменялась на один символ, то хэш изменялся, да? Но как бы это обычно делается,
ну, в идеале хочется просто, что если есть какой-нибудь S, то хотим бы прибегаться по A,
подомножать его на A разной степени, чтобы он там прибегал как можно больше значений по модулю M,
правда? Ну, короче, нам, во-первых, чтобы A было больше, чем размер ассоциации. Ну, нет. Ну,
может быть, даже не обязательно. Нет, если не обязательно, то мы подставляем два разных символа.
Нет, понимаешь, что фишка такая. Нет, а, ну, в этом смысле, да. А, конечно, желать,
чтобы больше был, чем размер алфавита, да, наверное. Хотя принципиально ли это?
Сейчас, если мы храним длину... Нет, то есть храним длину, то, наверное, не принципиально. Потому
что мы шли по модулю A берем по модулю M. Да, если не храним длину, то нас просто... То есть, в принципе,
если мы хотим пока, если у нас пока цель просто, то есть давайте так просто, давайте мысль такая,
то есть поредите мысль просто, мыслите немножко не туда, то есть... Нет, тут идея... То есть,
тут, как бы, да, заметим, что если мы возьмем A, как вы уже, наверное, из каких-нибудь УКТЧ знаете,
да, если мы A возьмем взаимно простым с M, то, в общем-то, там, видимо, примерно какие-то
остатки прибегутся. Если M еще и простое, то, как бы, тогда он прибегает вообще все остатки,
не нулевые. Ну, а простое, с этой точки зрения, даже не принципиально, на самом деле. То есть,
если M простое, то вот так. То есть, можно, в принципе, сделать, чтобы M было не простое,
а взаимно простое с ним. Тогда мы таким образом прибежим все взаимно простые с M остатки. Тоже,
в принципе, вариант. Вот, на самом деле одно время некоторое было популярен в этом месте. Ну, там вот,
да, тут есть, Рейше. Да, есть такая вот некоторая теремка, конечно, веселая, да. Но это, как бы,
я думаю, не будет сейчас... Я думаю, из УКТЧ вам все это там не то, чтобы очевидно, но прекрасно
известно. Ну, как очевидно? Ну, там не очевидно. Мне кажется, там, как бы, с нуля вот эти все остатки,
свойства всякие по модулю, это не так быстро. Ну, если не с нуля, то, естественно, не очень
интересно. Да. Так что не важно. Так что ладно, я думаю, тут можем особо не копать. Вот. Но просто
хочется сказать следующее, что на самом деле когда-то был очень популярный такой хэш по модулю
264. Потому что как? Чего? Ну, возможно, не знаю. Нет, ну это просто летает. Нет, ну да, потому что это
летает почему? Потому что как провести сложение-вычитание-умножение в языке C++ по модулю 264?
Нет, храним в онсайн плонглон и просто позволяем переполняться, потому что оказывается
переполнение в онсайн плонглон, железобетонно работает так, как надо. Вот. Более того, по факту и в
лонглоне тоже. Правда, да, это просто стандартом это уже не гарантируется, но по идее там часто в
лонглоне. На самом деле да. Но это сейчас это непопулярно. Потому что возникла, к сожалению,
маленькая подлянка. Нет, на самом деле просто хэши 244, к сожалению, вам могут и забанить. Потому что,
к сожалению, там есть некоторые такие свойства, которые говорят, что если вот сгенивить строку
вот таким вот нехитрым образом. Вот. Видно каким? Да, видно. Но то есть идея такая, что мы берем строку 0,
потом значит на каждом шаге мы берем предыдущую строку и приписываем сзади ее же, но инвертированно.
То есть вот 0, 0, 1, вот 0, 1, 1, 0, потом сюда там 1, 0, 0, 1, ну и так далее.
Ну сформулируем так, ну для любого не гарантирую, но по примеру конкретно для 244, значит есть подробная
роспись. Кстати, можете найти там пост на Codeforces, автор Макс Ахмедов, значит в котором-то это
показывает, что там огромное количество будет совпадающих там по модуле 244 строк, у которых
хэши будут совпадать. Для любого основания. Нет, это вот именно по основанию степень 2. В чем-то
абсолютно все равно какое основание вы выберете. Да, именно. А вот не важно. Вот утверждается,
что там вообще при любом нечетном там фейлы начнутся. А при четном как вы просто сокращаете
его с модулем. Так что не суть важна. А там даже еще хуже будет. Если у вас, извините,
основание четное, то основание в степени 64, это уже, простите, 0. Так что, поэтому основание четное вы
тем более не возьмете. Поэтому, то есть претекают проблемы. То есть нет, то есть на самом деле,
но правда сам Макс Ахмедов говорит, что он такие тесты никогда не вставляет. Вот мы в этом смысле
грешны, мы вот свои контесты такие тесты пару раз вставляли. Вот. Но на самом деле, да, Макс
Ахмедов говорит, что я такие тесты себе никогда в тесты не вставляю. Почему? Ну просто потому,
что очень тупо, потому что это примерно то же самое, как валить хэш в предположении, что вы его
пишете по модулю миллиард семь. Потому что тогда задача сдается так. Заменяем миллиард семь на
миллиард девять и у вас неожиданно окей. То есть поэтому, естественно, валить конкретные модули
хэшей, естественно, никто не будет. То есть никто не будет просто потому, что это нечестно. То есть
тогда надо либо валить все возможные хэши, коих бесконечно много. Потому что лично я вообще часто
люблю, когда писать не миллиард семь, миллиард девять, а пишу там первое пришедшее мне в голову
число в районе миллиарда и там буквально фориком накажу ближайшее простое. Есть же прекрасные числа,
состоящие 179, с добавлением чего-то там. Ну вот да, ну можно и так. Это не то, которое все используют, там есть другое, которое еще на него похоже. Ну понятно, понятно, но да. Так же всякое такое, ну можно вообще... Нет, а это неважно, а все равно как бы, ну то есть... Не, ну там просто нет. Дальше как бы фишка по кодфольсису, конечно. Да, на кодфольсе, если вы в явном виде написали хэш, то вас в явном виде могут взломать конкретно. Фишка в том, что вы пишете
массив на 20 хэшей, рандомно выбираете там пару... А вот это уже... Ну, проблема в том, что рандом тоже, как показала практика,
неправильно написано рандом тоже прекрасно предподсчитывается, потому что это псевта. Во-во-во-во. Через хрона почтишь, что любой колок типо нормально работает. Ну да. В секундах тебе отдается время.
Ну это да. Оно уже не ломается как бы. Ну так просто уже не ломается. В секунду уже не угадаешь. Нет, ну там отдельная песня, там на кодфольсе была на самом деле как-то дана такая задача,
которая, по-моему, принципиально нельзя сдать без угрозы взлома. Ну почти нельзя. Потому что там задача, потому что там задача, по-моему, там примерно такая.
То есть у вас... Чего? Сейчас, нет. Там немного другое. Там дано так. Вам дано досвязанный список. Он состоит из, по-моему, 50 тысяч вершин, но фишка в том,
что вы не знаете, в каком порядке эти вершины идут друг с другом. То есть у вас есть интерактор, который вам сообщает, что там для каждой вершины может сообщить, какое число на нем написано и какое следующее.
И какая следующая вершина. То есть также было известно, что там на них написаны какие-то числа, и известно, что если вы идете вдоль списка, то у вас получается...
То этот массив получается цартирован. Так вот, задача. Дано n, то есть длина этого списка, и дано число x. Найдите lower bound от x. У вас тысяча запросов.
Тысяча?
Да.
На сколько вершин?
На 50 тысяч.
Чего? Зачем? Сколько?
Ну, может там, ну и, может там, может там чуть поточнее. Не помню.
То есть типа 40 не хватает?
Нет, ну так кто-то и прикроет, что вы не знаете заранее порядка. То есть там, может, идет за первым, идет там на пятый, за пятым десятый, за десятым второй.
То есть кажется, что либо логарифм, либо ОАТМ?
Ну, формально ОАТМ, да.
А.
Нет, потому что никакого логарифма нет, потому что вы не можете найти элемент, который находится в середине списка.
Ну да.
Да, получается, что как бы, то есть получается, то есть эпическая ситуация. То есть как бы честного решения, видимо, не существует в природе.
Вот. То есть по факту там как бы начинает пихаться там что-то в духе.
Давайте там условно сгенерим там что-то типа 500 рандомных значений, выберем из них максимальное, которое меньше, это меньше икса.
И после, а с него будем идти честно.
Тем временем.
Вот. Но проблема в том, что это все упирается в рандом, и дальше любой рандом может быть завален.
Тем временем задача касс-квалификация CPC.
Ну это уже да. Нет, я ее не читал, но как бы наслышан. Да.
Да, наслышан как-то, да.
У нас есть любители этой задачи.
Да.
Рандомные.
Да.
Гарантируется, что входные тесты можно зарифать, да.
Ну понятно, понятно. Да, да, да, да.
Вот.
Так что тут так же получилась такая эпическая задача, то есть как бы практически, то есть надо очень аккуратно писать рандом, чтобы вас не завалили.
То есть потому что там, то есть там любители найдутся, да.
Но там надо читать, потому что у меня было ощущение, что там едва ли не даже с какими-то ходят там, то есть с какими-то там даже рандомными эстрандами или чем-то еще, даже это там ухитрялись валить.
Вот. То есть это эпическая абсолютно задача.
То есть это я бы назвал, это просто идеально, просто идеально, можно сказать, взлом самой системы Код Форсиса на самом деле.
Просто, то есть это прям вот лучшая задача.
Просто я помню, это называется IMT-Храунд 2 или что-то в этом роде очень рекомендую.
То есть там специально сделали максимально мерзкую вещь, да?
Ну это не мерзкая вещь, но вот, да.
Ну это нет, конечно, авторы какие-то говорят, а мы умели взламывать там кучу технологий там генерации рандома, но мы все такие тесты, естественно, из тестов удалили.
Ну вот.
Взламывали участник?
Да. Но участника взламывать не запретишь, да, поэтому.
Чего?
Можно запретить участнику взламывать в дачу.
Да.
Но как минимум в задачах B1-B2 B1 взламывать нельзя.
Да.
Потому что без дачи B2.
Без дачи B2, ты стоишь в B1 и держишь взламывать, видишь решение B2, даешь B2.
А.
Потому что человек в B1-B2 заслал, да.
Ну часто в дачах, если нет реально, как сделать взлом, там просто говорят, что взламывать нельзя.
Понятно.
А, ну бывает.
Чтобы не думать.
Нет, просто честно, я на такое не наталкивался, видимо, я редко пишу код форсиса.
Хорошо.
Знаете, да типа каждый десятый раунд.
Ну я понял, я понял.
Ладно, хорошо.
Ладно, то есть вот такие вот рандомы и засудили, но что еще тут надо обсудить?
Таким образом, значит.
Просто как еще можно валить хэши глобально?
Потому что на самом деле есть подлянки.
Какие еще подлянки?
Потому что ладно, по модуле 2,64 поняли.
Казалось бы, можно брать по модуле какие-нибудь 10, 9, 7.
Ну такой хэш.
Ну как бы, на самом деле, как завалить такой хэш?
Просто по модуле...
Нет, ну строку не обязательно.
Просто как минимум, просто проблема в другом.
Просто по модуле миллиард 7, на самом деле, просто фишка будет такая.
То есть если вы просто сравниваете там две строки и совпадут ли у них хэши, то это одно дело.
А так, на самом деле, если у вас была задача,
дано, например, 10 в пятый строк.
Дано 10 в пятый строк.
Скажите, пожалуйста, сколько из них попало на различных.
И тогда...
То есть у вас может возить тут такая идея.
А давайте-ка сгенерируем хэши и запихнем их в какой-нибудь сет.
И сколько там в сете различных элементов будет, столько и окей.
Но есть маленькая подлянка.
То есть, к сожалению, независимо от того,
какой вы там выберете хэш по модулю,
конкретно миллиард 7 или порядка миллиарда,
скорее всего, у вас будут левые коллизии.
Почему?
Потому что есть действительно такой парадокс.
То есть важно отметить, что есть такая вещь,
как парадокс нерождений.
В чем он заключается?
То есть суть действительно заключается в том,
что, например,
то есть он формулируется так же.
Если мы возьмем
какой-то рандомных N людей,
то утверждается, что начиная с какого-то момента,
с большой вероятностью найдутся
два человека, у которых
день рождения совпадет.
Так хорошо, что в нашей аудитории это не работает.
Да, в нашей аудитории сейчас это, конечно, не работает.
Но если бы я спросил вас где-нибудь там
где-нибудь год назад,
то, скорее всего, такое бы произошло.
Нет, на самом деле там медленно бывает вероятность.
То есть мой папа один раз
на этом погорел, у него было
в аудитории человек сорок,
он рассудил интуитивно, что
наверняка должны быть люди с днем рождения.
Так.
И проспалил шоколадку, потому что
там вероятность больше 50%
становится быстро, а вот убывает она не очень быстро.
А, понятно, понятно.
Прикольно.
Ух ты!
А там было
четыре человека или восемь?
А, математика.
Ну, ладно.
Ну, значит,
ну, значит, вот соответственно твоего папу
скомпенсировали где-то, да?
Да.
Шоколадку-то не вернули?
Ну, господи.
Ну, да.
Ну, ладно, это уже мелочи.
Ну, вот.
Ну, действительно, да, всякое такое бывает.
Но что, действительно, там
парадокс такой, действительно, что если прям там где-то
посчитать, то там, оказывается,
вероятность 50% достигается
где-то в районе 23.
То есть даже есть какая-то
легенда, на самом деле, что
на каком-то званом ужине
там Давид Гильберт
даже рассказывал про этот парадокс,
люди не поверили и стали проверять.
Там за столом сидело 22
человек и стали проверять, ни у кого не совпало.
И она, да ладно, ничего не работает.
А потом так подходит и горничная
вот эта, которая подносила им еду
и говорит, слушайте, я прошу прощения, но я тут 23
и у меня день рождения вот такой же, как у
вон того генерала.
Да, вот.
Есть такая, да, есть такая еще,
маленькая там такая баечка.
Гильберт заплатил.
Нет, знаете,
давайте прежде чем перерыв, я скажу, там на самом деле
заплатили, бывает еще шедевральне.
Знаете, классический анекдот звучит так,
как еще советский анекдот.
Приехал в Советский Союз какой-то крутой
американский математик.
Его аналогичный советский коллега,
принимающий, позвал его
в ресторан, и ему захотелось похвастаться,
что у нас математическое образование самое
крутое в мире.
Поэтому он сделал так, перед тем, как вести
американцев в ресторан, он так, позвал
официан, говорит, смотрите,
я сейчас приведу коллегу, мы там будем сидеть,
когда вы меня поднесете нам
напитки, я вам задам
какой-то вопрос, значит, абсолютно
неважно, какой вопрос,
абсолютно неважно, просто вы ответите
Треть Икс Куб.
Она как?
Треть Икс Куб?
Нет, Треть Икс Куб.
Треть Икс Куб, да?
Треть Икс Куб, запомните,
выучите.
Треть Икс Куб.
Все, договорились.
Хорошо.
И так находит следующий день,
приходит он американца, приходит официантка,
он говорит, слушай, девушки,
на самом деле у нас вообще вся страна
на самом деле знает мотоанализ.
Он говорит, да, вообще все,
прям все, даже он официант,
давай девушку плывем, давай.
Вот девушка, идите сюда. Подходит девушка
и говорит, вот скажите, пожалуйста, девушка,
а чему равен
интеграл от х квадрат?
Девушка.
Треть Икс Куб.
Она мне говорит, вау,
ничего себе.
Вот так, да, девушка ставит напитки,
а забыла добавить
плюс константа.
Так, господа, ладно, прежде чем мы двинемся дальше,
я должен упомянуть еще
так, ребят, все, поехали.
Ну, прикол еще раз такой,
я напомню, значит, прикол.
Ну, прикол ее в том,
что у нее, что если вы делаете
модуль какой-нибудь степень двойки
244, то он начинает
с какой-то длины, причем меньше,
какой-то одиннадцатый, тут у этой
строти находится огромное количество подстрока
этой длины с одинаковым хэшом,
то есть с хэшом равным ноль.
Причем парадокс заключается
в том, что этот прикол
работает с абсолютно любым нечетным
основанием хэша,
под не модулем, а основанием.
Ну, то есть я это
говорю как черную магию,
я это не доказываю,
на экзамен естественно тоже не потребую,
но факт такой есть, то есть отсылка
на кодфорсе, вот есть пост на эту
тему, никнейм,
вот так, ну, никнейм, если вы
возможно уже не застали Макса Ахмедова,
ну,
вырос.
Знаете, как часто
бывает, люди там занимаются некоторым
время олимпиадами, а потом там начинают работать, там вырастают
и больше к олимпиадам отношений не имеют.
Такое на самом деле очень часто случается.
Может он просто никнейм?
Ну, потому что в конце концов
вы сталкивались с таким человеком, как Иван
Смирнов, например?
Скорее нет.
А, ну да,
тут с именем не повезло, да.
Нет, я имею ввиду Иван Смирнов, который был еще
моим сокомандником в свое время, там пару
сезонов, там, он
двукратный медалист и CPC от
Фистеха, там золотая и серебряная медаль.
Вот.
То есть вот как бы, казалось бы, со мной участвовал,
но как бы, скорее всего, вы его
не знаете, он в принципе там еще ведет, по-моему,
там семинары,
что-то как бы ему ведет в вышке еще.
Так что в принципе вышка его знает.
Вот. Но это
или там, кого еще вы можете так знать?
А, ну я имею ввиду, что
или, например, там, кого еще
можно было знать, там Саша Голованов,
теперь может там Костя Семенов, или там
или там
Голованов,
ну,
периодически, ну, скажем так, он работает в
МТехе и, собственно, там собралась
такая компашка из Фистеха, на самом деле, ну, в том
числе из Фистеха, там не только Фистехи, но там
наших там много.
И, значит, они там периодически
делают раунды. То есть МТех,
сейчас они Пайнели называются, там и так
далее. Иван Смирнов, случайно, не вот этот?
Нет.
Голованов почти всегда только один инкутренер.
Ну, нормально.
Иван Смирнов, семинарист по
Матлогову.
Это так, скорее всего,
ну, рискну предположить, что это другой
Иван Смирнов. Нет, или там
скорее всего знаком...
Иван Смирнов,
нет, то Иван Смирнов, нет, в данном случае
четкое совпадение. Да, потому что нет, можно тогда
по-другому, хорошо. Ладно, потому что там
парадокс такое. Знаете ли вы такого человека, как Владислав
Епифанов? Нет, Владислав Епифанов тоже эпическое
совпадение, конечно, есть.
Потому что есть Владислав Епифанов, просто вот мой
ровесник, после одной вот
треххратной призер Мишнара.
Вот, то есть мой
ровесник. Есть там Владислав Епифанов, какой-то более
молодой, из Питера, потому что тот-то из Нижнего Новгорода.
Вы его, возможно, знаете, потому что тот Владислав Епифанов
ездит как тренер из Нижнего Новгорода.
Короче, у нас опять вот тема
лекции. Коллизия. Да.
Ладно.
Я уже писал чат про Александра
Некрасова-Павловича. Да, да, да.
Да. Ладно.
Значит, хорошо.
Тут мы про Коллизию поговорили, с Лобобером упомянули,
ладно, пойдемте дальше.
Но на самом деле с хэшами есть еще один поиск
под строк-строки. Можно просто хэши проверять,
но есть как бы... Но на самом деле тут по-разному
можно проверять. Потому что наш алгоритм
обычно подразумевает, что если хэши совпали,
то мы свято верим, что и строки совпали.
Потому что мы считаем, что вероятность того,
что хэши совпали, а строки нет, крайне
мала.
Вот.
Соответственно. Но есть
более точный алгоритм, который
говорит о том, что если Коллизия произошла,
то есть там, например, если хэши совпали,
то давайте в тупую проверим.
Вот.
И тут, в принципе, получается достаточно
интересно.
Потому что на самом деле, если предположить, что для
двух различных строк у нас вероятность Коллизии
равна 1 делить на q,
то тогда... Ну, вы уже знакомы
с понятием математическое ожидание, да?
Знакомы?
Ну, нам его на дискране обвели,
а на ВИКМе нет.
А...
Да, даже еще не ввели?
Какое безобразие. Ну, ладно.
Ну, хорошо, ладно. Нет, ну, на дискране
нам ввели в дозажском уровне. Ну, на дискране.
Чтобы мы и так его... На продвинутом ВИКМе
не ввели, на основном уже ввели давно.
А, ну, короче, на продвинутом нет. Понятно.
Хорошо. Вот.
Ну,
отлично. Молодцы.
Вот.
Ну, почему? Ну, логично, да.
Ну, вот. Ну, и тогда получается, действительно, просто маленькая
простая вещь, что тогда у нас в среднем
это будет работать за, получается, сколько.
Вот.
Но тогда получается, что...
Значит, у нас... Мы
тогда получается... Работаем за О
от П, плюс С, плюс работа с коллизиями.
А сколько у нас будет вообще коллизий?
Но тогда получается... То есть, каждую коллизию мы обрабатываем
за О от П, но коллизию у нас
бывает... Ну, даже не коллизия, если
честно совпало из троки, а
бывает, когда они не совпали, но тогда их
бывает в среднем, модул С
поделить на К получается.
Условно говоря, каждая кутая подстрока, видимо, в среднем
совпадет просто потому, что повезет.
А мне повезет вот это вот.
Так что в принципе тоже на практике могут часто
это использовать, тем более, что на самом деле асимпточка
еще может где-то не совсем точно, потому что там часто
еще будет бывает, что если хэши совпали, строки не
совпали от слова совсем, поэтому и вы это поймете
там за несколько первых символов на самом деле.
Но это если брать на реальной практике, то есть на реальной
практике, где никто там вам специальные контртесты
придумывать не будет.
Более того, на самом деле это анонс, видимо, уже на
следующее занятие.
Есть вообще совершенно эпический алгоритм, который
будет искать подстроку строкеза от единицы дополнительной
памяти.
По умолчанию, без хэшей.
Хэши сами тратят дополнительную память.
Да, ну во-первых хэши сами тратят дополнительную память.
Нет, чего?
А потому что в этом алгоритме хэшей нет.
И рандома нет.
Нет.
Ну потому что у нас нет официального понятия слова
честно, потому что кто сказал, что хэши не честно?
Мы же честно говорим, что бывает, что иногда нам может
не повезти, но мы верим, что это не в нашей жизни.
Ну для этого есть слово детерминированное.
Ну хорошо, хорошо.
Нет, не детерминированный алгоритм абсолютно, ты не
путай.
Да, но правда нам с хэшами может не повезти.
Да, у нас все детерминированный, но это все еще.
Так, ладно, давайте сейчас это все стоп-занудство,
ребят, давайте это, такая формализм, потому что в
данном случае суть, думаю, понятна, в данном случае
действительно имеет в виду, что это абсолютно
детерминированный алгоритм, nightmares...
То есть не использующий, тогда у тебя нигде.
Так, ребят, так, так ребят, я понимаю, что интересно
беседа, давайте меня перебивать не будем, да.
Ну вот, то есть понятно, что данной случае имеет в
виду абсолютно детерминированный алгоритм не использующий
никакихistle, никаких вероятостей, никаких хэшей, ничего
такого, Thanksgiving, и еще он использовuelт от единицы
дополнительной памяти破чать как horizon.
То есть это да, в какой-тоyer aposthhferntulu�, буквально недавно
в одном из там, буквально два поколения назад он у нас появился, и, собственно, оказалось, что очень полезно
говорить, потому что попутно мы еще очень много вообще интересного про строки узнаем, на самом деле.
Про всякие строки, про их периодичность, так что не пропустите, так что это называется реклама, не пропустите
следующее занятие.
На практике, ну, нет, я бы сказал, что к счастью, конечно, бегают хэшами, потому что редко бывает,
что надо прям вот под строку прям вот в строке искать.
Нет, потому что чаще бывает, что там что-нибудь быстрое надо найти, обычно, до нас строка,
найди ее по базе, там, я не знаю.
Ну, в какой-нибудь редакторе, скорее всего, вам там надо, то есть, ну, обычно, если у вас там поиск
какой-нибудь файла, то вы там, наверное, то есть, обычно надо пробежаться по компьютеру, что-то
найти.
Ну, или там, например, или там какой-нибудь поисковик, например, да, то есть, как вот, например,
как вот написать поисковик по Библии, да, вы знаете, это легенда основания Яндекса, да, то есть,
легенда говорит о том, что просто Яндекс начался с того, что просто к молодым программистам просто
пришли представители церкви и попросили написать поисковик по Библии там в 96-м, но там просто, ну,
фишка была, ну, нет, просто, нет, фишка была абсолютно естественная, то есть, как бы священники
хотели просто действительно подкреплять свои слова действительно конкретными цитатами из Библии,
но часто бывало, что они там действительно примерно помнят, но очень сложно там вот найти, поэтому
вот очень хочется, собственно, так сказать, найти, то есть, да, Гугла тогда не было более того,
утверждается, что вот российская версия Гугла вот с этого и началась, потому что, в принципе, ну,
просто в те времена, как бы интернет был такой маленький, что он, в принципе, там все, что
хранилось в интернете на самом деле могло поместиться просто в одном процессоре у вас под столом,
то есть, тогда немного всего было, то естьorm now, of course, it's already impossible,
уже невозможно, в те времена, как бы все было сильное, это сильно меньше,
сильно медленнее, то есть, да, динозавры по улицам уже не бегали, но, тем не менее,
да, вот, но все временные мобильники, в общем-то, тогда только появлялись, если что,
то есть, вот знаете, все эти вот времена, времена были, так что вот легенда говорит,
шо вот яндекс с этого и начался, но вот, причем, более того, как они это сделали,
то есть они просто значит понятно действительно вбили всю библию значит взяли там конкретные может
быть там конкретные слова где-то и вот и там допустим для каждого для каждого слова там записали
где оно встречается вот то есть это иду примерно вот это назвали индекс вот ну собственно примерно
кстати название яндахс примерно тоже из этой логики и возникло где-то то есть я не помню как
конкретно они там из индекса сделал яндекс но вот судьба примерно такая вот поэтому исходя уже то
есть уже proced bathing но вот то есть поб佐 formulation более того ведьau pesco
век яндекс работает до сих пор то есть потому что по большому счету супер чем примерно такаяаша то есть
у них то есть действительно есть интернет то есть есть такой паук яндекс которые там периодически
там qualité ходить по интернету и сохранять себе какие-то странички с него ну вот и соответственно
потом идти там то есть найденное значит вот как-то обрабатывается это вы в этот индекс наносит
к индекс естественно уже не в одной компе хранится в большом кластере эти классы но вот и там в кластере
там хранятся какие-то слова по как раз тем самым хэшам то есть вычислим хэши поэтому хэшу там
поймем на каком в каком процессоре он лежит вот то есть ну там основа но основные вот там
в общей детали то есть вот то есть как бы основная база вот вот такая вот так соответственно так
что же у нас будет дальше ну что ж пришло время начать говорить о полиндромах вот но начнем мы
конечно не с дерева полиндромов а вот а с кое-чего более интересного это более простого ну а первых
начнем давайте давайте скажем что такое вообще полиндром ну вот ну во первых научимся введем
операцию как бы с с верхним индексом это типа разворот строки то есть записываем теперь символы
в обратном порядке ну и будем говорить что строка называется полиндромом если строка равна своей
развернутой версии пока вроде логично ну и задача поиски полиндромов может быть такая смотрите то
есть можно сфагулировать так давайте в некотором смысле найдем все пары чисел и жи такая что
подстрока с и по жи является полиндромом ну формально конечно скажете что быстрее чем за квадрат
такую задачу решить нельзя почему потому что размер ответа может быть в таком виде квадрат
но с другой стороны мы можем заметить маленькую и приятную вещь что если какая-то подстрока
является полиндромом то любая подстрока с тем же центром тоже является полиндромом правда
правда что такое центр под строки ну если для нас трак по цы drinks четные длины то центр это
один символ а если подстро fifty по цык отчетное то центр это какая-то позиция между двумя символами
ну это уже это уже техническая деталь там по разному бывает да то есть мы мы в какой-то
момент при примере применим и этот лайфхак но как бы пока но идейно мы понимаем что у каждой
подстроки из центра он как бы либо символ либо что-то между ними вот это вот и тогда идея такая
что если она то есть тогда получается для каждого центра можно найти так называемый размах крыла
то есть максимальная подстрока с таким центром который является полиндрома то есть как ее найти
очень просто давайте начиная с этого центра будем идти влево и вправо на один символ на два символа
на три символа до тех пор пока эти символы совпадают понятно да то есть пока это естественно в
тупую работает за квадрат ну или пока или или по факту за общие то есть на самом деле за
общее число под полиндромов строке на самом деле вот но но но но но на самом деле но заметим что
для хранения этой информации нам уже нужно всего отн памяти правда и тогда если и тогда мы после
этой отн памяти можем уже отвечать на запросы вида вот там спросит является ли подстрока с
лп лр полиндромом тогда мы просто берем центр берем размах крыла и проверяем это крыло рот
дотягивается да или если да то значит полиндром если нет нет так это идея понятна это идея
понятна отлично но раз уж мы храним отн памяти то наверное хотелось бы и работать побыстрее как
же это сделать но мы значит но но формализуем что мы хотим искать мы хотим искать массивы пал
и пал зелен так видно да это вы там контесты ведете лишь вы делаете если там что-то делаете
давайте лучше уберем а то знаете очень сложно рассказывать людям которые там что-то параллельно
делают активный ходит просто как бы если у вас там сейчас так это занятие надо это делать то как
бы зачем вы сюда пришли вообще давайте так что давайте убираем ноутбуки так что давайте закрывать
так что закрываем ноутбуки закрываем давайте так что закрываем или просто идем с этими
ноутбуками как и в более удобное место где нету какого-то этого заварливого лектора который
вам там уши еще какую-то информацию пытается донести вот и так значит пытаемся делать пал
и пал и значит соответственно вот но в принципе то есть так как у нас пустая строка действительно
является полиндромом тогда как минимум можно сделать вывод что массивы корректно
определены хаха но в принципе так понятно да и хочется задача на заключается в том чтобы
эти массивы как-то за уатес найти как же это сделать ну на самом деле миша уже предложил как
по крайней мере как бы уменьшить себе интуитивно работу в два раза то есть давайте вставим между
любыми двумя символами диезики тогда можно заметить мистическую формулу
ну как бы понятно что она означает идеи на идеи она означает что как бы все то есть по сути
теперь четные палиндромы как бы получается увеличились где-то в два раза и превратились
в нечетные палиндромы с центром диезики они четные палиндромы тоже увеличились примерно в
два раза но центры у них остались символах своих да и в принципе я то есть формулы это просто как
точным образом восстановить на самом деле четные нечетные палиндромы строки с по только лишь
нечетным палиндромом вот этой строки вот этой вот диезнутой строки с во хорошее название
вот и таким образом получается мы свели задачу к поиску исключительно пал от но на самом деле
если вам нужно поэкономить память то часто конечно бывает что пал от и пал ивер просто делаются
одинаковым кодом там просто в одном месте плюс-минус и денечка и так свели задачу к пал от то есть
ищем только нечетные палиндромы как же у нас ну как бы больше памяти вроде а ну только на
саму строку да ну ну то есть можно как всегда конечно мысли в принципе да да да да так вот
значит смотреть что же у нас теперь с пал отдами получается пал отдами получается следующее вот
но здесь опять написано какой-то мистический текст и давайте как всегда напишем в нем кое-что
еще то есть давайте разберемся что он значит вот но картинка практически та же на самом деле сейчас
вот ее сотру чтобы нарисовать заново с лобобером и тоже убираем вот так
значит смотреть вот и так получается примерно следующим вот жила была то есть он говорит
так жила была строка с дам и мы говорим пусть у нас в какой-то и ты позиции обнаружился палиндром
да ну можно и так мысли дам и теперь вот идея такая давайте рассмотрим какую-нибудь позицию вот
какую-нибудь вот эту и плюс сель где л меньше к мы очень хотим но тогда вот идея такая вот есть
как бы позиция вот это и плюс сель есть как бы в принципе симметричная ей позиция и минус
вот и лема говорит примерно следующее что пусть у нас есть пал полиндромность здесь и выяснилось
что размах крыла здесь не доходит вот до этой границы к тогда оказывается что в общем тогда
утверждается что просто в этом смысле полиндромный здесь та же что полиндромный здесь
в такой формулировке в общем-то очевидно правда ну потому что как бы заметим что здесь все то
же самое что здесь только развернутая правда то есть палиндробности то есть палиндробности
будут одинаковые если вы и минус л поля вот эти крылышки нет строго не дотягиваются досюда то
есть формально это называется то есть вот эта вот штука меньше чем к-л строго меньше
вот она вот такая п тогда оказывается что в этом случае тогда она просто оказывается буквально
такой же но естественно если крылышки здесь дотягиваются до к-л или дальше то есть здесь
тогда крылышки дотягиваются хотя бы то к-л и это позволяет нам пал отды искать буквально тем
же методом что и в z функции то есть вы как бы храните крылышки которые то есть как бы всех
посчитанных крылышек вы храните те которые справа дотягиваются как можно дальше и когда
доходите до черного символа вот вы говорите так какие у нас крылышки по симметрии так если они
дотягиваются досюда значит пишем что тут хотя бы к-л и дальше насчитываем в тупую а если не
дотягиваться значит копипастим то что есть и идем дальше вот так что вот такая вот достаточно
такая классическая идея то есть в общем-то то есть как бы да если вы с этим не сталкивались можно
на самом деле за функцию тут не придумать нет на самом деле самое смешное что у меня с этим
тоже был эпический прецедент потому что давным-давно когда я был в 10 классе далее там на на
тогда это называется на заочной олимпиаде которой сейчас называется открыты на такие назад каждый
завала ставочный этап открытой олимпиады тогда далее веселую задачу до на строк Piece но тысяч
найдите максимальные длины под строку которое является полиндромом чего найдите м settlers
максимальный длины под строку продолжается полиндрома почему это не является халявой
потому что тогда ну лично я тогда вот этого алгоритма не знал он тогда он тогда еще популярным
являлся хеши написать хеши ой ну с хешами у меня отдельная история поэтому вот знаете вы знаете я
даже в этом месте потрачу время и расскажу вам что что я написал почему я скажу потому что это
тоже будет полезно потому что в будущем это тоже нам пригодится может даже и сегодня так вот на
самом деле я этого не знал то есть я потом то как то есть я написал следующий так смотрите давайте
сделаем разделяем властвой ну то есть ну как бы чтобы как бы рассмотрим строку с так вот задачи
еще раз найти максимальной длины под строку которая является полиндромом но если длины найти ее
длину только надо ну там так вот но идея такая давайте распилим строку пополам тогда надо
найти ответ слева найти справа и через храницу ну понятно слева справа запустились рекурсивно
если мы сейчас научимся искать через храницу за линию то получится суммарно н лог и неправда
хэши я говорю а теперь но а теперь представьте себе что я не знаю что такое хэши ну ладно я
знаю что такое хэши но я честно говоря до какого-то второго третьего курса ими по каким-то вот своим
внутренним причинам не пользовался вот то есть я по я помню я им у меня был такое сначала им не
пользовался потом где-то на втором курсе я столкнулся с задачей которые без хэшей не сдавалась
принципиально и потом так обрадовался что начал эти хэши сдавать везде вот кончилась кончилась
но да но потом кончилась это тем когда на одном контесте я написал хэши бин поиск за н логен
и получил тл там вздохнул написал префикс функцию за линию получил окей не знаю но тогда нет я бы
не сказал что мне в конце хэши прям фигня этого это нот это не так было но то есть это не так то
есть теперь как бы то есть я как бы хэши для меня это тоже метод но вот но как бы условно говоря там
поклонение тому что там тот хэши это наше все и там за это хэши это полная шляпа нет у меня ни того
ни другого уже нет так что скорее вот так вот да да если не хочешь становиться не знаю победам
но нет в наши времена это по-другому было я же я уже вам рассказывал мемас про то что задача вида
дан массив на 100 тысячи сделать 100 тысяч за 100 тысяч реверсов и выведи ответ тогда никто не
решил вот сборы на межах 2008 года это задача одна из четырех на контесте ее сдали только на 35
баллов за квадратичные решения да это сейчас сейчас это даже сейчас это как называется да но
тогда это да тогда это был уже приходило то есть потом я уже это преподаватели там пришли и сказали
что ребят ну байси пи си это как бы такие задачи на завтра кушают потому что понятно что в дикарте
это легко делается вот но вот ну вот да хотя ну вот так что соответственно вот но это ну знаете
как я говорю вот вы вот почувствуете насколько за это сейчас уровень продвинулся по сравнению с
2008 так что да да да да да да так что вот а вот значит смотрите это еще кто-то плод так вот
значит как я но это значит поэтому так вот я тут хэши не делал так что же я сделал а я говорю так
но у меня бывают два случая нет я сказал без ограничений обществе центр справа вот у меня
будет справа ну слева естественно аналогично так вот ребят тихо тихо тихо значит смотрите тогда
я думаю так говорю я так значит у меня центр где-то из центр допустим где-то справа да тогда
смотрите что у меня происходит тогда вот у меня префикс этой строке с1 и с2 нет нет вообще нет но
хотя в цит функция сейчас тоже будет потому что смотрите то есть у меня значит тут получается
префикс полиндром и вот эта строчка равна вот этой вот развернутой строки да так ну теперь первая
задача как давайте для начала найдем так найдем все префиксы этой строки который является полиндромы
такой за такая задача там когда-то давалось в группе б на зачете в лкш все префиксы строки заданной
строки которые для с полиндромом но обычно задача называется там про приведение петь там либо
приведение петь либо она еще бывает иногда называется носки вот известная такая думаю сталкивались
такой задачи да но мы сейчас а как вы решаете вы не знаете не хеши ничего нет ну если ну ничего
они нет префиксы за эту функцию я прекрасно знал и сейчас мне понадобится обе а префикс функции
и так вот задача другая задача дан да на строка т найдите все ее префиксы которые являются
полиндромом это значит делят делается так берем строку т добавляем диезик добавляем строку т но
развернутая тогда утверждается что вам теперь нужно найти все префиксы которые совпадают
супиксы как это сделает стандартная задача вида посчитай префикс функцию и вот от этой позиции
бери там пятно все паят конец пет пет конец пет веопед Qin's и так далее кому как от23 но
нет нет почему но дляظать функции тебе ну как исполнится за функции убедиться что полиндром
этот полиндром я сказал так то есть можно да то есть но да то есть как то Kara- aim
Смотрите, давайте, префикс-функция это значит, то есть как бы педлины, педлины, педлины и так далее, это в точности они.
Как проверить z-функцию?
Да, то есть префикс-функция делается так.
Как делается z-функция?
Как проверить, что суффикс совпадает с префиксом?
Очень просто взять z-функцию в начале и проверить, что она дотягивается до конца.
То есть можно и так, и так.
То есть я в данном случае за то, чтобы уметь это делать и тем, и другим способом.
То есть про все там вот эти простенькие задачи, на самом деле рекомендую подумать,
можно ли решить с помощью только префикс-функции, только z-функции или только хэшей.
Все, что решается с помощью хотя бы одной из этих функций, решается второй, как минимум.
Да, но это как бы то же самое, что как бы гвоздь можно забить молотком, а можно забить головой.
Но как бы это не оно вот.
Ну вот, то есть просто как бы молоток просто где-то, ну вот, так что соответственно.
Но с другой стороны там всякие, если вы складываете все столбиком, можно писать на бумаге, а можно писать на молотке.
То есть значит ли это, что молоток интуитивно очевиден и пользоваться только молотком будем.
Ну или там наоборот.
Писать на стене можно мелом, а можно вот это молотком дырки выбивать.
То есть мы говорим молотком-то тоже это делается, так давайте забьем.
Вообще мел это все, мел это елись, давайте пользоваться молотком, он везде решает.
Ну, в олигардах нормальный подход в целом?
Нет.
Ну, на самом деле нет.
Когда вам нужно быстро решить кучу задач, вы не хотите?
Вы не хотите тратить на забивание, на написание текст на стене молотком кучу времени?
То есть, на самом деле, да, но более оптимальная подходка, молотка же более сложная,
что изучить на самом деле все варианты и в каждом именем выбирать наилучший.
Вот это, конечно, хорошее решение и сложно поспорить.
Почему вы так себе сделали, да?
Ну, все такие не всегда, потому что это сложно действительно.
Во-вторых, как бы интуитивно себя в этом сложно убедить в том, что это стоит делать,
потому что окажется, что ты и так умный, и сам все это придумаешь.
Не то что и так умный, а просто кажется эффективнее научиться пользоваться молотком.
Ну, вопрос где?
Все-таки правильно пользоваться молотком там, где им действительно хорошо пользоваться.
Дальше это сводится к каким холиварам, в духе нужно ли изучать дерево отрезков с операциями снизу.
Многие считают, что просто вообще про это нужно забыть как страшный сон и не использовать, потому что это с точки зрения изучения программирования просто потеря времени.
Наоборот, фенвик потеря времени, а вот дерево отрезков...
Нет, фенвик не потеря времени, потому что его полезно иногда быстро писать, чтобы быстро работать.
Он заменяется на дерево отрезков.
Ну скажем так, у меня вот за тому его олимпиадную жизнь, ни в одной реальной олимпиаде, в контесте у меня не было такого, что я из-за того, что я фенвика и ДО снизу не писал особо, у меня не было проблем.
Ну понятно.
Я просто не писал ДО сверху и в целом все.
Нет, ну понятно, нет, ну там вот есть конкретные задачи, где все-таки фенвик... ну как бы все-таки там какой-нибудь фенвика написать лучше, там фенвик фенвиков, но...
Ну тут у кого как?
Ну по-разному бывает.
У кого-то нет, у кого-то там у кого-то может быть, но это уже, я говорю, тоже такие холиварные вопросы на самом деле.
Потому что дальше можно обсуждать еще.
То есть как мне кажется, что дерево снизу все-таки тоже полезно изучать, потому что там дерево отрезков, то есть тогда можно лучше понимать, как дерево отрезков устроено.
Еще так немножко с другой стороны посмотреть.
Но как бы с другой стороны...
Это другое.
Ну вот.
Так вот.
Значит хорошо, что префикс функции, что z функции, все префиксы, которые являются полиндромами мы здесь за линию нашли.
Но для каждого такого полиндрома теперь хочется сказать, хочется получается найти, насколько максимально его теперь можно вот так раздвинуть, чтобы это был все еще полиндром.
Как это сделать?
Очень просто.
Если это половина s1, это s2, то по большому счету давайте рассмотрим такую строчку, как s1 развернутая, там какой-нибудь диезик s2.
И тогда получается, что в такой строке, то есть надо найти максимальную, то есть вот если вот эту длину мы нарисуем вот так, то по большому счету надо найти вот такой максимальной длины,
ну ладно, префикс, то есть такая под строку в какой-то позиции s2 начинающейся, которая совпадает с префиксом развернутой строки.
То есть получается, если вы насчитаете, во-первых, вот эту функцию, то есть там префикс или z для вот такой строки и префикс, и там скажем z функцию в данном случае для вот такой строки за линию, то получается на все запросы вида, там какой у меня максимальный полиндром вот в этом центре стоит, вы легко ответите.
При условии, что это полиндром такой. Вот, собственно, такое решение, собственно, я за NLogin-чика написал, вот оно радостно зашло со временем работы полторы секунды при TL2.
Ну, может, и сигара, может, тогда были медленные, ну там, может, и я на Паскале писал тогда, хотя Паскаль, по-моему, незначительно медленнее сей, на самом деле.
Да, Паскаль на самом деле не летает.
Да, нет, Паскаль хороший. Вот, но на поверху, потом где-то я услышал и даже потом будущему сакоманику так еще и там, потом быстром дело рассказал, что на самом деле, то есть на что на самом деле, то есть это вот полиндромности можно искать просто аналогично z функции, просто с той же идеей.
Вот, но, как ни странно, на самом деле эта идея тоже в какой-то момент помогла, потому что на самом деле есть такая красивая, потому что есть еще две красивые задачи, которые решаются тем же подходом.
Одну я расскажу, другая у вас будет в домашнем задании.
Задача называется, задача, ну раз уж зашла речь, давайте перейдем сюда, задача о тандемном повторе.
А, ну-ка, кто сталкивался с задачей о тандемном повторе?
А сколько раз сталкивались с задачей о тандемном повторе?
Ну, я не помню конкретно.
Значит, смотри, сейчас я сформулирую задачу.
Нет, то есть, да, есть дерево тандемных повторов, но с ним, с ним, по крайней мере, пока не сталкивался я.
Я сталкивался.
Буду благодарен.
Давай.
О, глядишь, у нас новинка в курсе будет.
Да, значит, Рознецов говорит спасибо.
Нет, ну да, нет, ну да, а я, почему бы нет, собственно, чего.
Денис, отбирай битую ссылку.
Зачем?
Чтобы у нас не было дерева тандемных повторов.
Значит, смотри.
Тихо, тихо.
Значит, смотри.
Давай, смотри, как у нас будет новинка в курсе.
Господи, да, тут еще таких новинок накинешь, и у меня полночье ощущение, что, видимо, в четвертом семестре нужно устраивать вообще там это, то есть, это продолжение этого курса, но уже в формате спецкурса.
Нет, нет, у меня даже была мысль, а может быть, действительно, то есть такое вот сделать и рассказывать там вот совсем какой-нибудь расстрел, типа там алгоритм Торупа, например, какой-нибудь.
Ну вот, ну что-нибудь, что сюда не вошло, потому что на самом деле там есть куча вещей, которые вот сюда не входят, на самом деле.
Ну вот, а может, например, доказательства мастер-теремы, например.
Чего?
Почему неинтересно, ну так.
Нет, ну это да.
Нет, ну с этой точки зрения, да, давайте тогда копать там это лучшие алгоритмы поиска максимального потока еще.
О-о-о, то есть вот там.
То есть этих расстрел.
Правда, проблема в том, что каждый из этих алгоритмов нужно примерно месяц рассказывать.
Как может, спецкурс на несколько идет.
О-о-о, да.
Ну теоретически можно практически.
Ой, как говорится, практически, чтобы я, да, практически, конечно, чтобы это делать мне на самом деле свою текущую работу научиться нормально делать, конечно.
Ну вот там, дзэ там вовремя.
Ну как бы, ну дзэ там вовремя проверять вот это все, да.
Вот.
Так вот, смотрите.
Значит задача о тандемном повторе звучит так.
Смотрите.
Дана строка S.
Найти максимальной длины под строку, которая состоит из двух одинаковых подстрок.
С конкретегированных.
Вот хочется найти такого вида под строку, где длина T как можно больше.
То есть вот такая задача.
То есть вот такая задача.
Вот тоже на самом деле.
Значит как ее искать?
Так вот, оказывается.
То есть в принципе, вот сейчас парадокс будет, потому что как бы мы вот с вами столкнулись вот с этим вот разделяем и властвуем, казалось вроде просто.
Хотя вот обычно, когда я это вот сейчас рассказываю, обычно что-то люди застреливаются.
Потому что почему-то кажется, что вот то, что я сейчас расскажу, это прям супер больно.
Ну и то, что я уже рассказал, я сейчас расскажу на самом деле идеи, например, на то же самое.
То есть идея такая.
То есть опять же давайте распилим строку на пополам.
Найдем ответ рикусивно слева, рикусивно справа.
И теперь будем искать тандемный повтор, который проходит через границу.
Так, ну давайте без ограничений общности считать, что у нас как бы стыковка находится где?
Ну естественно справа.
Вот.
Как же мы это будем делать?
Так, ну допустим мы...
А, ну мы опять без ограничений общности считаем, что у нас длина L.
Значит давайте переберем и предположим, что у нас длина L.
Как проверить, что есть ли тандемный повтор длины L?
Я скажу, я это сделаю так.
Вот смотрите, вот есть у меня вот эта граница.
Давайте я вот предположу, что у меня вот эта вот длина L.
Тогда фактически что я должен проверить?
Ну, во-первых, у меня идея такая.
Давайте, во-первых, я проверю просто, насколько я вот сюда с этой позиции могу пойти.
Ну, если я могу пойти прям на L или более.
Ну, как я это проверю?
Я просто Z-функцию здесь насчитаю и проверю, правда?
Вот.
И допустим, я вот...
То есть, допустим, если у меня вот эта длина L,
Так.
Вот.
И допустим, я вот...
То есть, допустим, я тут докуда-то дошел.
До какого-нибудь там, я не знаю, X.
Да?
То есть, у меня вот X совпадает вот тут с префиксом.
Вот.
Тогда...
Ну, вот.
То есть, нот...
Тогда что мне нужно?
Тогда, если X тут совпадает,
То тогда, получается, я как минимум...
Вот.
То есть, что у меня еще должно быть?
Тогда, получается, если дальше это так, чтобы это повторялось,
вот так сказать, с периодом L, проходило дальше,
я должен сделать так, чтобы у меня вот оставшаяся часть L-X
вот здесь вот совпадала.
Логично, да?
Да.
Как я это буду проверять?
На самом деле, очень просто.
Я, опять же...
То есть, если...
Нет, даже не префикс функции, а просто Z-функция.
То есть, я возьму просто функцию S1-реверснутая,
диезик S2, иначе...
Реверснутая.
Иначе считаю Z-функцию.
Да.
Потому что, если я теперь нарисую, что такое S1-развернутая,
диезик S2-развернутая,
то тогда вот эти две зеленые стрелочки превращаться в вот такую стрелочку
и где-то вот такую стрелочку.
И мне, то есть, мне останется просто насчитать Z-функцию,
и получается, мне просто надо проверить,
верно ли, что Z-функция строки S2,
плюс Z-функция в позиции вот эта длина этого всего – L,
они больше либо равны L.
Сейчас, какую вы конкретно задачу решаете?
Ну и не в том плане, какая промылировка, а...
Конкретно сейчас я пытаюсь найти тандемный повтор, хоть какой-нибудь.
Который начинается в каком-то конкретном символе.
Да.
То есть, за квадрат, кажется.
Нет, почему за квадрат? Нет.
Просто для каждого L я это сделаю за линию, за единицу.
При подсчете правильных Z-функций.
Сейчас.
Нет.
Что?
У вас же вот этот символ середины может быть где угодно.
Да.
Но меня интересует не он, меня интересует длина.
Смотрите, по большому счету я сформулирую...
Смотрите, давайте я введу определение.
Значит, смотрите, прям давайте записываем.
Определение.
Строка T.
Строка T.
Значит, допустим, L периодическая.
L периодическая.
L периодическая.
Если...
То есть, для любого I такое...
Вам нужно просто проверить, что у вас сумма этих двух Z-функций больше, чем L.
Не меньше, чем L.
Сейчас.
Давайте введу формулировать, чтобы было удобнее.
Потому что в будущее после этого я тоже сейчас ввожу то, в чем мы будем жить.
Значит, для любого I такое, что...
Короче говоря, I и I плюс L символы строки T существуют.
Верно, что T и T равно T и плюс L.
Вот.
Вот я назову такую строку L периодической.
Вот.
Так вот, по большому счету теперь моя задача найти...
То есть, для каждого L понять, существует ли L периодическая подстрока длины хотя бы 2L с вот этой вот границей.
А, L периодическая.
Ого.
Да, у вас какое-то неинтуитивное определение.
Ну вот.
Интуитивное определение, это типа L раз повторяется.
Нет.
Вот.
Нет, я...
Так, вот поэтому мы вводим определение.
Для меня вот это интуитивно.
Причем тут вот это определение?
А вот причем.
То есть, по большому счету, смотрите, если у меня...
То есть, вот эта строка, она модуль T периодично.
Да, просто два раза T стоит.
Да, но это означает, что...
Нет, просто, смотри, утверждение.
Смотри, вот эта строка, она имеет длину 2 модуль T и она модуль T периодично.
Это эквивалентно тому, что она состоит из двух одинаковых копий.
Ну, в принципе, вообще можно сказать, что пусть у вас есть строка длины N,
там она K периодично, и N делится на K.
На K.
Тогда...
То есть, пусть N делится на K.
Тогда эта строка K периодично, тогда и только тогда, когда она состоит из одинаковых копий длины K.
Можно на экзамене вот эту?
Да, как угодно.
Ну вот.
Нет, у вас тут другое определение.
У вас необязательно делитесь.
Да.
Вот это более общее.
То есть, я утверждаю, что у меня строка длины 9 вполне может быть 2 периодично.
Ну, если она типа A, B, A, B, A, B, A.
Да, это...
А не может быть 10 периодично, потому что там...
Чего и плюс L?
Ну, строка длины 9 не может быть 10 периодичной.
10 периодичной...
Наоборот.
Ну, формально говоря, получается, что она 10 периодична.
Потому что просто для любого и удовлетворяющего такого условия это верно.
Да.
Вот.
Но давайте так.
Обычно интуитивно, конечно, считают, что строка 9 все-таки не 10 периодично.
Нет, но интуитивно она да.
Да, да, да.
Да, но обычно так не говорят, и это не очень интересно.
Там начинаются там всякие свойства.
Давайте про периодически говорить так.
Так вот, наша задача найти под строку хотя бы длины 2L,
которая является L периодической.
И которая проходит через вот эту границу.
Так, не надо туда читать.
Вы можете делать криты с телекрамой, тогда они будут проходить.
Ну, могу.
Да, ладно.
Нет, но, кстати, эта новость, между прочим, ладно,
для вас тоже будет вполне интересна на самом деле.
Уже была.
Хотя...
Ну, она уже была.
Нет, я вам скажу, я ничего не скрываю.
В общем, грядет новый технокубок.
Ну вот.
И как бы...
Нет, но...
Нет, ну, скажу так, для вас ничего.
Ну, если новость заключает, что это будет заниматься
просто не ЦРТО, а непосредственно ФПМИ,
но как бы для вас идея на то же самое.
То есть, короче, Call for problems.
Филипп Грибов сказал, что в этом году
будут выбирать хорошие задачи на технологию.
А не как в прошлом смысле.
Осталось только выяснить, почему это сказал Филипп Грибов,
какое он имеет отношение к технокубку.
Игры в ВТИ.
Нет, я могу...
Ну, как бы не передавали, на самом деле,
как в ВКонтакте, на самом деле,
там очень понравилась работа в прошлом году, кстати.
Так что...
Так что тут все бы...
А участникам олимпиады очень не понравилась
работа составителей, да?
Нет.
Ну, как сказать...
По модулю...
Нет, по модулю стандартной нелюбимой,
там массовых людей, геометрии.
Ну, тут тяжелая доля, к сожалению,
любого составителя задач по геометрии.
Хотя там, по-моему, не было.
Но там претензии...
Ребят, так тихо, не перебивайте меня, пожалуйста.
Основные претензии там были, по-моему,
не к составителям задач, а к тому,
как работал тестирующий систем.
Ну, скорее к тому, чтобы и составление
просто протестировали где-то
на левой системе,
и там все ограничения подогнали,
а потом...
Да, но, по-моему,
это вопрос как бы не к самим задачам.
То есть к самим задачам тоже, конечно, были,
потому что иногда в каких-то раундах
перезроп случался.
Почему это вопрос целый к ограничениям,
то есть к части условий?
Ну, там технический момент,
что как бы это...
Это просто нужно тестировать...
Ну, да, но там
это сложилось так, что, к сожалению,
не от нас зависело, а там просто ВК разрабатывает
новую систему, и это называется...
Они вот наткнулись просто на эти детские болячки.
Так что, увы.
На этот раз надеется,
что все ошибки эти были учтены,
поэтому в будущем будет нормально.
То есть, но прав...
Нет, там просто единственное решение тестировать.
Они собираются ВК КАП туда же переносить.
ВК КАП? Ну, мне об этом не известно.
Вот. Да.
Единственное только для всех, то есть все
активно приглашаются в этом участвовать,
естественно, это тоже оплачиваемо.
То есть, я думаю, как минимум,
не хуже, чем в прошлый раз.
Единственное только будет мелкая оговорка.
Оговорка будет заключаться в том,
что на этот раз они заказывают все-таки задачи с баллами.
Ага.
Сколько часов длится контеста?
Нет. Да. Нет.
Нет. Контесты, длительность контеста
может быть примерно столько же,
и задача тоже требуется, кстати, столько же.
Ага. И еще все с подгруппами.
С подгруппами, да. Слушайте, ловко они
придумали. А что такое?
А шоги так?
Двухчасовой контест
на семь задач с подгруппами
даже не знаю, сколько. Хорошо. Нет, ну ладно.
Скорее всего, будет уже, наверное,
двухчасовой, все-таки побольше, но соответственно.
Так что в том плане...
Трехчасовой, вроде.
Ну, у нас
в прошлом году было так, раунды были
по два часа, финальный три.
Да. Да.
Не, но отборы как бы не рассчитаны на то, чтобы
их закрывали. В целом кажется, что...
Так же, соответственно. Есть вот несколько людей талантливых.
Так же, соответственно. Так что все
ноты. Не, ну нет.
Ну как всегда, тут активно приглашаем всех,
потому что как бы задачи нужны
разного уровня,
как самые сложные,
так и, собственно, попроще.
И с реги, то есть все нужны. Но там совсем сложные, может быть,
даже не нужны. Потому что, как показала практика
прошлого технокубка, возможно, там задача
на какой-нибудь там конвекс халт три может быть там...
Может быть дана там... Может быть
в финальном туре
в каком-то последнем слоте.
И то не факт, что оно там нужно.
Вот. Но, соответственно.
Так что вот, соответственно, такое
вот объявление есть. Так что, соответственно,
всех, так что всех, соответственно, активно
приглашаем. Вот. Ну объявление.
Так что вы, соответственно, просто первые, кто об этом
узнает. Вот.
Так что все сделаем все это.
Ну вот. Так что
спасибо Димиду, что тут сообщение высветилось
на эту тему. Да.
Это как раз не секретная информация.
Вот.
Вот.
Так вот. Значит, вернемся
к тандемным повторам.
Значит, смотрите. Ищем... То есть, смотрите,
для каждого l мы хотим понять
за от единицы каким-то образом.
Есть ли у нас 2l
периодическая подстрока,
которая проходит
через вот эту границу.
То есть, строка длины 2l,
которая является l периодической.
l периодической длины хотя бы 2l.
Тогда мы
идейно делаем так.
Найдем максимальной длины префикс
строки s2, который является
l периодическим.
Вот задача, как найти
префикс,
то есть максимальной длины
префикс, который является l периодическим.
Да. Ага. Не, ну,
если вы поняли... Не, боже упаси.
На самом деле все гораздо проще.
Заметим, что строка l
периодическая,
ну, тогда и только тогда,
когда префикс длины
n минус,
там, модуль t минус l,
совпадает
с l плюс
первым суффиксом.
Вот, я вот вижу, что это на самом деле
буквально одно и то же. Да?
Сейчас. Что? Что?
Нет.
В смысле, если длины 2l, то окей.
Нет, вообще, я вот это определение
переписал. Если не кратная l длина, это ж вроде
неправда. Правда, правда.
Потому что... Смотрите.
А, у вас там модуль
n минус l. Модуль t.
Ладно, хорошо. Ну,
у нас n нет. Да, пойдет.
Или что то же самое.
Ну, это почти как задача про то,
что все лошади одной масти.
Ну, типа, докажем по индукции,
что все лошади одной масти. База одна,
лошади одной масти. Шаг.
Если n плюс 1 лошадь
берем первые на одной масти и
последние на одной масти, естественно, они все
того же цвета, что и средние. Ага, ну да.
Бага в том, что пересечение может быть
пустым, да. А тут...
Какое может произойти случайно? Не,
ну не очень понятно. Нет, ну смотри,
просто давай... Ну, тут можно, наверное...
Проблема при n равно 2, да.
Ну, вот. То есть, на самом деле, тут надо уточнять,
что, видимо, это все предполагается, когда
у нас, допустим, 1 меньше
либо равно n, видимо, там,
чтобы это было адекватно. Ну, надо, меньше
либо равно модуль t, вот так.
Да, ошибка в рассудении при n равно 2,
просто и все. Потому что первое
лошадь, второе, одно и до свидания.
Да, точно.
Ну, отлично. Ну, вот там
да, там бага такая. Тут бага не
совсем здесь. Но тут заметим,
что, вот, если вы будете
распишите, что означает, что вот эта подстрока равна
вот этой? Это как раз означает, что первый символ
равен l плюс 1, второй l
l плюс 2, третий l плюс 3 и так далее.
Но это, по сути, вот это.
Так, ладно. Вот.
Вот.
Классно. Вот.
Но заметим, что вот эти вот проверки,
это, на самом деле, можно сделать на языке
просто z функции. Видно, да?
То есть, в принципе, это означает, что если
вы посчитаете z функцию для строки
s2, то как бы все
ее периодичности, то есть, все числа
x, для которых она x периодичная,
вы, получается, за линию и найдете.
То есть, можно, если даже
сказать, что в этом случае мы назовем l
периодом строки t,
то получается, да, что
периодом являются те и только те l,
для которых верно
вот это вот.
Ну, ладно.
На самом деле, формально мы должны
написать...
Ну, я
объясню,
я, можно сказать, я объясняю алгоритм,
правда,
ну, можно сказать и так, да.
Да, да, да.
На самом деле, можно сказать и так, да.
Вот.
Поэтому исходя...
Ну, на самом деле, формально это должен написать, что
либо так, либо l равно 0t еще,
потому что z от t плюс 1 мы не определили,
к сожалению. Вот.
Но это уже такие уже
формалистические детали. Вот, кстати, еще возникает
вопрос. Хорошо, с помощью z функции мы научились
искать все периоды.
А как искать периоды с помощью
префикс-функции, кстати?
Надо просто где-то недоразвернуться.
Да нет.
Вот задача.
У вас вам дана строка
и дана префикс-функция строки.
Найдите ее минимальный период.
Предположим, вам дана даже строка не дана,
дана только префикс-функция.
Найдите ее минимальное.
У меня есть ощущение, что это префикс от конца.
Нет. Но только l минус.
Вот, совершенно верно. То есть
минимальный период строки это...
Ну, потому что, да, заметим, что строка...
То есть давайте оговоримся, что строка
у нас на самом деле l периодично,
тогда и только тогда, когда
как бы
префикс длины модуль s минус l совпадает
с суферсом длины модуль
s минус l.
Поэтому отсюда
автоматически получается, что
периодами строки s являются
в точности. Модуль s
минус там p от модуль s.
Модуль s
минус p от p
от модуль s.
Там модуль s
минус p от p от p, ну и так далее.
В общем, так вот все периоды вы переберете.
Вот.
Вот. То есть вот так
с помощью префикс функции тоже все периоды
прекрасно ищутся.
Так вот.
Что еще... Что еще можно
с помощью этого... Ну вот. Как это нам
помогает? Ну, теперь задача о тандемдах
повторок говорим так. Давайте найдем максимальный
префикс строки s2,
который является l периодично.
Как мы это сделаем?
Ну, просто возьмем z функцию
вот в этой точке и посмотрим, до куда
она нас доведет.
Я вот решаю, что ровно
до куда она дойдет, вот ровно этот
префикс является l периодично. А дальше
нет.
Я вот не очень
понял про...
Ну, давайте попробуем. Что означает,
что префикс является l периодичным,
да? Префикс длины
x является l периодичным, да? Это означает,
что этот символ совпадает с вот этим,
да? Этот символ
совпадает с этим и так далее. То есть, по сути,
вот эти x символов совпадают с префиксом длины
x.
И что?
Строка a, b, c, d, e,
a, b, c, d является
5 периодичной.
А, все, да, да, да,
да, просто у нас a другое.
Ну, ну да.
У нас a не совпадает с длиной, но да,
в таком виде да, в таком виде согласен.
Вот. То есть, получается, все, что нужно,
это... То есть, находимся, функцию находимся.
Но правда, если tx уже оказался l
или более, то ура,
тандемный повтор длины l найден.
Ну, это правда. А теперь,
если это не так, то что нам нужно сделать?
Тогда нам нужно просто
взять, что вот максимальный префикс
длины l, то есть
максимальный префикс строки s2, который l периодичен,
он дошел
вот до сюда. Да?
Теперь наша задача... Хорошо.
То есть, l периодичным образом мы дальше не пойдем
вправо, но насколько мы
можем пройти l периодичным путем влево?
Но для этого мы возьмем вот z функцию
вот из этой строки и поймем,
можем ли мы вот пройти
отсюда хотя бы длину l,
так, чтобы это совпадало с вот этой строкой?
Ну, если мы хотя бы l
тут найдем, то, конечно, тандемный повтор
найден.
У нас же насчитана z функция не из любого символа,
а только из конца. Да, но...
Нет, смотрите. Да, но мы...
Да, но здесь, смотрите,
здесь из любого символа, а здесь
вот это вот, откуда мы идем влево, оно
фиксировано. Ну, короче говоря,
с z функциями понятно,
но зачем это сводить периодично,
не очень понятно. Ну, видимо...
Сейчас еще раз,
Дмитрий, почему не можем сделать следующее?
Вот мы вот эту правую
позицию двигаем,
и проверяем, что если сумма 2z функций,
ну, которую вы сказали,
хотя бы l,
то тогда
мы учитываем. Ну,
тогда тандемный повтор длины 2l найден.
Да.
Так и есть. Но в итоге
так и есть. Мы лишь объясняем, почему
это так.
Так что вот такая вот красота,
вот так вот мы идем, вот так вот хорошо.
Понятно?
То есть как бы если мы вот так вот,
то есть совпадает ли этот с этим, этот с этим,
ну, насколько мы так можем пройти, мы вот
из z функции для этой строки и выкопаем.
Короче, за линию здесь решаем.
Получается, да.
Да, совершенно верно.
Причем так и быстро.
Потому что вот у этой задачи есть
напарник, то есть у этой задачи есть напарник, собственно,
в домашнем задании.
Не супер-быстрый, но нормально.
Ну да, то есть у этой задачи есть напарник. Я даже спалю там
условия сразу, то есть решение сейчас
рассказывать какие будут. Там суть такая, что дана строка длины
тоже там стоили 200, там может даже миллион.
И найдите, пожалуйста,
под строку,
которая наоборот состоит из
конкретинации одинаковой
одной и той же строки,
так, чтобы количество экземпляров этой
строки было как можно больше.
То есть найдите под строку, которая равна
t в степени k, где t не пустая строка,
а k максимально большая.
Понятно.
То есть вот такая задача.
Пораду ли, что ручной проигрок не будет, и можно
везде пихать хэши? Удачи.
Спасибо.
Потому что фишка была такая, потому что в этой задачи
было два решения. Автор задачи уже упоминавшейся ранее
Иван Смирнов.
То же история была такая. То есть мы ее дали на контесте
в Петрозаводске.
И было, и у автора было
вообще два решения. То есть у автора было
решение.
Какой-то там суфмасс
и какой-то с ним анализ. Или можно там пытаться
пихать хэшами.
Вот.
Тоже решение n log n, все хорошо.
Но только у меня сразу возникла
идея, соответственно, вот это вот.
Ну такая же.
Вот. Такого же рода.
Вот. В итоге, когда я в какой-то момент
написал
свое решение, выяснилось, что решение
Иване пришлось отсекать по туэлю. Потому что
мое решение работает в десять раз быстрее.
Да, при той же асимптотике.
То есть, более того, выяснилось,
что у него там даже еще и багов в решении
дошлось. Бывает. Да, потому что
мое решение оказалось просто так.
Еще и проще пишется, помимо всего прочего.
Так я даже сильно удивился, насколько
оно проще пишется.
Вот. То есть фантастика.
Вот. То есть, на самом
контесте, по-моему, задачу
то есть там, по-моему,
возможно, сдал только Геннадий Короткевич.
И то он какие-то двойные
хэши едва-едва там обеими
ногами запихал.
Вот.
Да. Ну вот. То есть такое.
Но на этом контесте была эта байка,
когда он там в какой-то момент прислал там
в какой-то момент сдал задачу,
включает ВА-8. Он там
по брутфорсел, ну там, с его стороны
по брутфорсел у него все работает. Смотрит
в таблице, никто не сдает эту задачу.
То есть, он так передшлёт.
А вы уверены, что у вас там все правильно? Эту по брутфорсел
у меня все работает.
Так. Ну мы смотрим. Ага. Так. Ответ
по модуле миллиард семь. Так. Что выводит Гена?
Ага. Семнадцать цифр. Ага. Ага.
Да. С чистой совестью
написали нол комец.
Вот. Совесть.
Да. Чистота совести подкрепилась
рецептом через три минуты.
Так шаманная вот. Но это была по мне эта задача,
естественно. Ну вот.
Так что вот. Ну это такие вот. Веселые.
Так что делайте контесты в Тетрозаводске.
Будут у вас самих такие истории.
Да.
Так что.
Так что вот. То есть, такая задача.
То есть, вот неожиданным
образом там никаких суфмассов этих ваших
тамуканинов и так далее. То есть, нет, это у нас
все тоже будет, но...
На самом деле общение вот на таких контестах с жюри
иногда выглядит очень
интересно, потому что у жюри буквально
два-три возможных ответа. И они
чаще всего дают однозначное понимание,
что именно, ну как это интерпретировать.
Ну да.
Там варианты
понятны. Да-да-да. Так. Ладно.
Что-то мы опять забалтываемся. Ладно.
То есть, на самом деле серьезно просто вот это
вот. То есть, вот эта вот штука в экзамене будет, если
что. Протендемный повтор.
Поэтому как бы есть ли
тут какие-то вопросы по этому алгоритму?
Вот.
Так что... А? Нет?
Ну там можно просто везать функции и рассказать
нормально. Ну вот эти,
в экзамене. Ну да. Нет, ну
более того, это и будет подразумеваться.
То есть, там...
То есть, Боже упаси
вас в основном упичивать какие-то там...
То есть, там какие-нибудь суфмассы адские.
Я про то, что
периодичность тут на самом деле не нужно рассказывать.
Ну,
на ваше усмотрение. Ну, как бы терминология
это уже другой вопрос.
То есть, другой вопрос, что как бы, да.
Напоминаю, мне эль периодичность интуитивно поняки.
И поэтому, если вы будете
употреблять слова эль периодичности,
понимая принципиально другое, то будьте готовы
к тому, что моя ваша
понимать будет не очень.
Поэтому, как бы,
такие вещи лучше прописывать.
У меня есть
противоположная история, когда в задачу
можно было там вывести небольшой ответ,
а уже по условию, а уже и в тестах
как раз было 17 цифр.
Понятно. Ой-ой-ой.
Бывает. Так, сколько там времени?
Ой-ой-ой. А, ну нет.
Это еще пока не перерыв вроде.
Так.
Так, ну хорошо. Ладно.
Эту задачу мы тоже обсудили.
Обычно я ее обсуждаю ближе к конце, но сейчас, по-моему,
она как раз очень к месту пришлась,
и мы кое-что еще полезное обсудили.
Так же, соответственно,
то есть если вы там ищете какую-нибудь периодичность,
то есть лучше там,
то есть можно там лишними хэшами и не бегать.
Вот.
Так.
Ну, впрочем.
Так. Что же у нас дальше?
Хорошо. Монакера
с полиндробами мы обсудили.
Что же у нас пойдет дальше?
Так.
Ну, это мы обсудили.
Да, алгоритм понятия. Там код, я думаю, тоже понятия.
В общем, ничего интересного такого нет.
Так.
Что-что?
Страна слова обрезались.
Где?
Где?
Полинод.
А, ну это картинка.
Полинод и полиневин
даже могут вычислить.
Вот. Ну, как бы тут отмечается,
что хэши и бинпольск тут тоже
в принципе тащат, но с меньшей асимптотикой.
С большей.
Скажешь так, с менее хорошей асимптотикой.
Вот так.
В этом ты колхоз.
Да.
Ну, да, да, да, да, да.
Ну, то есть это такая.
Это молоток.
Да.
Думал, да.
Дубинка, я бы сказал.
То есть тупая такая, да.
Такая бита, соответственно.
Не, молоток. Если хочешь написать, нужно
обмакнуть где-то голову.
Ладно.
Так, ну что у нас вообще идет дальше?
Вообще по-хорошему дальше, видимо,
я должен вам рассказывать про
ахакарасик.
Ну, вот начинаю думать.
А хочу ли я вам рассказывать про ахакарасик?
Вообще или сегодня?
Нет, именно сейчас.
Ну, просто идейно вообще план
лекции такой. То есть мы сейчас как бы
обсуждали задачу, где нужно искать
поиск одной строки в другой.
По идее,
дальше мы должны перейти на уровень медиум,
где мы должны
искать много подстрок
в одном тексте. Вообще подстроки
заданы заранее. Это, как раз, задача, которая
решает ахакарасик.
Вот.
А потом мы должны перейти к
суффиксным структурам, которые ищут все в онлайне.
И одним из этих алгоритмов
там самым сложным, может быть, будет алгоритм
Уканина.
Нет.
Зянь? Буду.
А мы будем на экзамене.
Я его писал один раз.
Я не хочу
больше его видеть.
Не, вы знаете, он
на самом деле очень красивый. Тем более, что конкретно
Уканина мы, кстати, почти, наверное,
сами напишем. Он очень красивый,
если его не кодит и не дебатит.
Не знаю. Ну, не знаю.
Мне нормально.
Вот. Но вопрос не в этом. На самом деле
просто он действительно сложный.
Но просто исторически
тут
появляется такая красивая вещь, как дерево
полиндровов.
А дерево полиндровов уже нормально пишется.
Ну, вот. Потому что... Ну, как?
Кто знает, что такое дерево полиндровов?
В смысле, слышал?
Ну, давайте. Пока для начала слышал.
Я слышал название. Кто знает, что это такое?
Так кто умеет
его писать?
Вот.
Ну, в идеале
давайте, кто напишет натуре без бумажки?
Ну, за какое время?
Я просто тот
интересный. Вы же у меня просто дерево полиндровов
и запрашивали. Может, по этой причине мы сейчас строки обсуждаем,
а не геома.
В гебаге вопрос. А если вы
это умеете писать с бумажкой, то как бы
зачем оно вам?
А, то есть
ты как заклинание писал?
Ну, я один раз разбирался, но это было
год назад, я уже ничего не помню.
Ну, хорошо.
Ну, хорошо. Ладно.
Так вот. Значит,
к чему я, собственно, это?
Потому что, на самом деле, идея оказалась
интересной факт.
Потому что обычно, на самом деле,
часто дерево полиндровов рассказывается, как такая
идейная перемычка между алгоритмом
Ахакарасика и алгоритмом Уканины.
Вот.
То есть такая.
То есть, в принципе, но исторически
он, конечно, создавался как...
То есть, идеи, основанные
в основе алгоритма обстроения,
это что-то среднее между Ахакарасиком и Уканиным.
Как говорит нам автор, просто автор
статьи в своей же статье.
Вот. Поэтому я вот и думаю.
Вот мне сейчас Ахакарасик вам
рассказывать?
Или рассказать вам дерево полиндровов?
Перемычку. Сразу.
Ну, вот. Ладно.
Вот давайте. Что-то хочется мне сегодня
дерево полиндровов вам рассказывать, да?
Потому что, ладно, Ахакарасик, ну он тоже, конечно,
такой гадостный алгоритм, но его, кажется, знают чуть больше.
Или нет?
Тоже гадостный? Это хорошее начало.
Не, но тоже гадостный,
как Уканин в смысле.
Ну ладно. Полиндромы так полиндромы.
Значит, смотрите. Итак.
Ну, то есть, давайте, как всегда,
прежде чем решать задачу для
каких-то произвольных подстрок, будем
решать задачу для обычных подстрок...
Для полиндромов.
Типа более простая.
Ладно. Итак.
Переходим к дереву полиндровов.
В принципе, для этого можем даже вот эту штуку,
думаю, убрать, потому что у меня нет презентации
на дерево полиндровов.
Вот.
Ну, ничего. Так что, в принципе,
сейчас давайте это выключим.
Спасибо.
Удивительно, на стене, кажется, даже лучше.
Да, но на стене.
А.
О, Господи.
В этом смысле, да?
Ладно. Ой, ребят, а можете свет тогда
включить? Я думаю. Ой.
Давайте тогда.
А, в этом плане. Ну, можно и так.
Значит, смотрите. Так дерево полиндровов.
Значит, о чем речь? Значит, мы хотим решать
такую задачу.
Дана строка С.
Ладно.
Да, дана строка С.
Что мы сейчас еще
будет делать? Дерево полиндровов строить.
То есть, там, то есть, новое, так.
Так, это дети записываем новую тему.
Дерево полиндровов.
Вот.
Так вот, задача будет такая.
Значит, мы, по крайней мере, попытаемся решить такую
интересную задачу.
Дана строка С.
Я хочу сделать на ней какой-нибудь
логический предподсчет.
И после этого отвечать
на запросы. Запрос такой.
Допустим, дана строка
П. В чем именно запрос?
И я хочу где-нибудь там
за О от П
понять, входит ли строка
П в строку С,
как подстрока?
А почему она полиндрома? А полиндромы
при том, что мне известно, что
строка П является
полиндромом.
Вы хотите сказать, что эта задача проще решать,
чем просто входит ли, как подстрока?
Да.
Я утверждаю так.
А входит ли, как подстрока?
Ну, то есть, что существует
подстрока в строке С, существует подстрока
равная П.
Ну, то есть,
суф-автомат.
Ну, в принципе, это задача решать суф-автомат.
Но для этого нам придется там строить суф-автомат
и доказывать, почему он работает.
Это сложно.
Возможно.
Хотя нет, с точки зрения доказательства
не факт.
Да нет, там
не сложно. То есть, код там пишется
на муа, но
с доказательством там может быть сложно.
Много символов, мало идей.
Тихо-тихо, ну понятно, ладно, посмотрим.
Ладно, тут уже на вкус
и цвет. А мы вот, ну я утверждаю,
что если мы ищем полиндромы в строке С,
то все проще.
И первая идея,
почему это так,
она такая. А сколько
вообще различных подполиндромов
являются подстроками строки С?
То есть, обратите,
вот раньше мы смотрели, сколько подстрок
строки С могут быть полиндромными? Мы знали, что
порядка квадрата.
Ну, потому что все подстроки могут быть
полиндромами. Но
если мы возьмем строку А,
то куча из этих подполиндромов
будут одинаковыми.
Так вот, а теперь
меня интересуют, как бы подстроки различаются,
если они различаются на как строки, а не по позиции.
Вы хотите вносить все, посчитать на всех,
и потом просто хрешами издать?
Ну,
нет, мы видим на 7 полиндромов
и решить. Нет, все еще круче будет.
Но хотя бы я вот думаю
так, а сколько их различных вообще? Может быть,
хотя бы их хрешмап покидать и действительно.
Тихо-тихо, спокойно.
Спокойно.
Ой, да ладно, вы на C++
не писали хрешмап, что тебе не поверить?
Хрешмап это как раз отличный.
А нордеритмап писали.
Так вот, смотрите.
Так вот, мистическая идея.
Я утверждаю, что
различных подполиндромов не пустых
в строке S
не более чем
модуль S.
Почему так?
Очень просто.
Давайте припишем к строке S
символ C.
Я утверждаю,
что от этого приписывания
в строке S появится
не более чем один
новый подполиндром.
Но это
очевидно доказывается.
Но спокойно.
Возьмем самый большой, возьмем все остальные,
заметим, что все остальные встречались ранее.
Спокойно. Мы уже поняли, что ты уже все знаешь.
Спокойно, дай другим узнать.
Не все с этим сталкивались.
Так вот, да.
Но доказательства Денис обрисовал совершенно верно.
Предположим, что добавилось
два подполиндрома.
Тогда один из них большей длины, другой
меньшей длины. Но тогда заметим, что
вот эта строка равна вот этой
развернутой строке, так как это полиндром.
Но так как это тоже полиндром,
то эта строка оказывается равна вот этой.
Следовательно, она
уже была.
Все.
То есть, получается, с добавлением
каждого нового символа
мы выясняем,
что у нас
подполиндром
новый не более чем один.
Пока все просто.
Более того, давайте
мысленно можем попытаться
выписать даже все
подполиндромы и запихать их хэшмап.
Это уже похоже на квадрат.
Но тем не менее, давайте это сделаем.
Для строки
какой?
А-ба-ца-ба-а-ба-ба.
Вот давайте
это, значит, смотрите. Чего мы будем делать?
Это кажется хуже, чем квадрат,
потому что для каждой строки мы ищем от ее длины.
Нет, ну, смотри.
Нет, смотри. Выписать
мы можем из эква...
У нас всего строк С.
Ну, смотрите, давайте выписывать.
Давайте выпишем, причем я выпишу
даже отдельно
четные подполиндромы, отдельно нечетные.
Вот нечетные я буду выписывать красным цветом.
Какие у меня есть нечетные полиндромы?
Ну, поехали.
Ну, во-первых, А, Б, С.
Во-вторых, что еще есть?
Ну, давайте вот так. Пум-пум.
Очевидно А-ба.
А-ца.
Так, тут Аут, тут А-ца.
И сразу Ба-цаб.
Давайте вот от этого центра не уходить.
А-баб еще есть?
Дойдем. Мы же не в порядке длинный.
Я хочу идти вот так слева направо
и выписывать то, что вижу.
Вот.
То есть с этой точки зрения даже я вот сделаю.
Но так, чтобы точно ничего не упустить,
тогда надо написать вот так.
Сначала А-ба, потом Ц.
Тут мы пишем Ба-цаб.
Так, и дальше. Ой.
Даже до А-бацаба мы и дошли.
Наша любимая А-бацаб.
Так, что дальше?
Так, тут мимо. Так, А-ба.
Аут. А-ба было дальше. Аут.
Так, тут Аут.
Аут и Ба-б.
Ба-б и потом А-баб.
Да.
И А-баба тоже есть.
Все.
Так, что у нас еще есть?
Так, нечетные мы вроде
все запомнили.
А как сделать четные?
Вот, у нас только в одном месте
две буквы совпадают.
Поэтому пишем А-а.
Дальше пишем
Ба-аб.
И дальше пишем А-ба-аба.
Так, тут еще вроде все.
Так, но на самом деле здесь легко убедиться,
что все. Заметим, что мы нашли 12
подполингромов, а для нас в ряке 12.
Так что у нас теория
уже говорит, что больше мы ничего не найдем.
Так редко бывает, конечно.
Но теперь возникает
естественный вопрос.
Как эти строки вообще...
Что же это за такая структура данных
мистическая,
в которой можно искать строки?
Ну, кроме хэш-сета, конечно.
Ну да, что это за структура данных,
в которой можно добавить строку, например,
удалить строку и
спрашивать, есть ли такая строка.
Но есть такая известная
структура данных, называется
БОР.
Надо ли рассказывать, что такое БОР?
Кто знает, что такое БОР?
Кстати, парадокс. БОР является
детерминированным автоматом.
То есть это такой
автомат, у которого никакие две стрелочки
в одну вершину не ведут.
Просто у нас есть другие предметы,
на которые мы только и занимаемся,
что задаем автоматом множество слов.
Ну понятно, да-да, я знаю.
Идея такая, в принципе, мы могли бы
запихнуть все эти слова в БОР
и сказать, что давайте
теперь любой полиндром искать
в этом БОРе. Но размер такого
БОРа будет квадрат.
Логично, да?
Ну если прям вот так
строки писать.
Ну тут у нас возникает интересная фишка.
Так как строка полиндром, то в общем-то
проверять можно не строку, а только
ее половинку.
Потому что если мы это равно.
То есть давайте проверять, допустим, правую
половинку.
Ну а в нечетных строчках
будем искать, будем эту правую половинку
брать, типа большую половину, начиная
с полиндрома.
И давайте их запишем в БОР.
Но тогда я утверждаю, что вот этот
БОР на 9...
Сколько у нас? Раз, два, три, четыре, девять
символов. Я утверждаю, что нам потребуется
всего девять... В этом БОРе
будет всего девять вершин, плюс корневая.
Почему так?
Ну очевидно почему.
Потому что если какое-то слово
является правой половинкой полиндрома,
то очевидно, что если от него отпилить один символ,
то это слово тоже
будет правой половинкой полиндрома.
И все его префиксы.
То есть когда я, например, САБа
добавлю в этот БОР потенциальный,
то у меня и
добавлю не один
под полиндром, а сразу четыре.
Так у меня и получится.
У меня тут получится а, у меня получится
б, у меня получится с,
у меня получится са, у меня
получится са.. САБа, короче.
короче, что-то еще у меня получится, або у меня получится, и або у меня получится,
так что-то, и ба.
Причем все состояния конечны.
Но по сути да.
То есть каждое состояние задает под полингром.
Да.
Вот.
Но правда заметим, что у нас половинка А может означать
и нечетный полингром, и четный полингром.
Давайте два отдельных дерева замесить.
Нет, давайте просто решетки поставим.
Нет, мы не будем ставить решетки.
Мы действительно заведем два дерева.
И получается определение.
Дерево полингромов, то есть дерево полингромов для
строки, это два бора правых половинок.
Да, парадокс, что дерево – это по факту два дерева.
Хотя вы правильно заметили, что если бы вставили диезики,
то можно было бы сделать единое дерево полингромов.
Ну, это чисто нанечетные полингромы.
Но обычно как-то не странно все-таки строят имена.
Либо мы можем какой-нибудь условный там опсилон-переход
нарисовать из одной корневой борьбы.
Не-не-не, он будет не опсилон-переход.
Вот.
Так смотрите, более…
То есть длинный переход.
Значит, если мы такую мистику построим, то есть каким-то
образом, то искать полингромные подстройки в строке можем…
То есть искать полингромные подстройки в строке можем
за один проход по этому бору.
Правда?
Да.
Вот.
Осталось только это построить.
Внимание, вопрос.
Как же это построить?
Ну, хочется сказать, что у него суммарная величина
будет маленькая.
Нет, ну суммарная…
Нет, мы уже выяснили, что суммарная величина этих
двух деревьев не более чем модуле с плюс два.
Потому что а, каждая вершина задает под полингром.
А, каждая вершина задает под полингром.
Вот.
А всего у нас под полингром не более чем модуле с.
Поэтому получается, что размер этой штуки линеен.
Ну, это уже было…
Но, я скажу больше.
Если вы к строке с…
То есть у нас будет такая идея, можно сказать, украниновская.
То есть потому что как мы это будем строить?
Мы будем строить так.
Мы начнем с пустой строки и будем приписывать к ней
по одному символу.
И при каждом приписывании я буду модифицировать
уже существующее дерево полингромов.
Почему у нас есть надежда, что все будет хорошо?
То есть у нас эта надежда сейчас подкрепляется тем,
что, смотрите, когда мы приписываем новый символ,
у нас появляется не более чем один новый подполингром.
Более того, с точки зрения дерева полингромов
можно легко заметить, что у нас оно будет…
То есть по сравнению со старым будет только одно отличие.
Появится одна новая вершинка.
Потому что если вот этот полингром, самый длинный подполингром,
который является сейчас суффиксом, он новый,
то заметим, что если отпилить символ в конце и символ в начале,
то получится подполингром, который там в строке S уже был.
Там опять какие-то суффиксные ссылки фигачить надо.
Что значит опять? У нас еще не было суффиксных ссылок.
Мы впервые в жизни еще не обсуждали ахкарасик,
поэтому у нас еще не было суффиксных ссылок.
Так что впервые мы сейчас познакомимся именно здесь,
с ними.
Но ничего страшного.
То есть получается, что когда вы добавили новый символ,
то есть просто надо найти этот максимальный, получается, суффикс
и где-то вот этот переходик приписать.
Или неожиданно выяснить, что это на самом деле подполингром,
он не является новым,
поэтому на самом деле дерево полингромов не поменялось.
То есть вот такая мистическая идея.
Вот как же эту мистическую идею реализовать?
И причем тут два указания?
Но для этого мы ответим на такой вопрос.
Надо ли перед этим сделать перерыв?
Давайте попробуем строить вот такое дерево полингромов
с помощью, допустим, хэш-мапы.
Где... Смотрите.
Ну, подполингромов-то у нас не сильно много, правда?
Давайте я хэш каждого подполингрома буду хранить в какой-нибудь мапе.
Почему мапе, а не сете?
Ну, чем мапа от сета отличается?
Помните, да?
Ну да, напоминаю, мапа отличается от сета тем,
что в сете есть только ключи,
а в мапе рядом с ключом находится значение какое-то.
Ну, это в сете null-type.
А в мапе это значение, оно будет вершина.
В уже построенном дерево полингромов.
Понимаете, да?
Потому что, смотрите, как тогда, если мы верим в эту хэш-мапу,
то на самом деле мы сейчас без всяких суффиксных ссылок,
без всяких заморочек построим дерево полингромов
с помощью уже полюбившегося нам методу двух указателей.
Значит, магия очень простая.
Итак, предположим, что у нас уже есть строка S.
Значит, сейчас мы предположим, что у нас уже есть строка S.
И для строки S дерево полингромов построено.
А также соответствующая хэш-мапа тоже есть.
Теперь мы приписываем к строке S символ C
и хотим понять, как нам надо поменять дерево полингромов и хэш-мап.
Но поменять ее надо понятно каким образом.
Все, что нам нужно, это получается понять,
нашелся ли у нас какой-то новый подполингром, правда?
Задача фактически теперь такая.
Надо найти максимальный суффикс этой строки,
который является полингромом.
И просто проверить, есть ли он в хэш-мапе,
если нет, добавить.
Причем как добавить? Не просто в хэшах добавить,
а еще и заметить, что вот этот полингром у нас уже был,
и от него получается вот есть вот этот новый переход
по символу C получается.
Так что вот такая идея.
Как же мы это будем делать?
Как мы это будем делать двумя указателями?
Идея будет такая.
Мы будем в явном виде.
Все, есть кто-нибудь?
Или вы опять это на финише контеста
параллельно две задачи решаете?
На очереди? На какой очереди?
А в плавающем окне?
Ой-ой-ой.
Ну, удачи, да.
Ну, значит, смотрите.
Как без очеред делать, вы уже поняли.
Молодцы.
Попробуем сравнить, совпало ли у меня представление с вашим.
Идея такая. В каждый момент времени мы храним не только
дерево полингромов и хэш-мапу, но и вот эти два указателя.
То есть два указателя, которые...
Ну, один указывает тупо на конец строки, а вот левый
будет указывать на начало вот такой максимальной
подлине суффикса, который является полингромом.
Понятно, да?
То есть мы будем это в явном виде хранить.
Потому что первая идея вот такая.
Когда вы приписываете к строке символ C, то какой
самый длинный суффикс полингром может быть?
Это тот же самый полингром, что был раньше,
только расширенный на два символа, правда?
То есть тогда получается так.
Смотрите, мы сдвигаем, получается, левый указатель
на один влево, правый на один вправо.
То есть два указателя, но при этом левый указатель
может двигаться назад.
Но адекватно двигается, потому что он на каждом шаге
будет двигаться налево-влево не более чем на один.
Но тогда, смотрите, идея получается такая.
Значит, проверяем, является ли это строка полингромом.
Давайте это просто то есть с помощью хэшей.
Да, кстати, хэши такая приятная штука, что при
приписывании символа справа хэш легко пересчитывается.
Так вот, проверяем.
Если это полингром, то значит мы его там добавляем
в дерево полингромов, если надо.
Если это оказался не полингром, то что делать?
Тогда сдвигаем этот указатель на один, проверяем,
является ли это строка полингромом.
Если нет, то проверяем, является ли это строка полингромом.
Это и так до тех пор, пока вот строка реально
являющейся полингромом не найдется.
И тогда все, что нам теперь останется, то есть максимально
этот подполингром мы нашли, остается только с помощью
хэш-мапы проверить, есть ли он у нас уже среди полингромов,
если нет, добавить и в дерево полингромов тоже его
добавить. А проверка, что то, что в конце полингромов
мы тоже с помощью хэш-мапы делаем? Даже просто с помощью
хэшей. Мы же умеем с помощью хэшей проверять,
является ли под строка полингромов.
Ну смотрите, у нас идея такая, мы все хэши
полингромов храним в хэш-мапе.
Для удобства мы завозим даже не один хэш-мап,
а Н хэш-мапов, где в каждом хэш-мапе номер L мы храним
только хэши для подполингромов длины L.
Ну это чтоб совсем удобно было.
Что мы храним в хэш-мапе? Для каждого полингрома
хэша, полингрома потенциального мы храним,
ну мы можем хранить, где этот полингром мы вообще
откопали, в какой подстроке. Ну то есть такая идея,
что мы в хэш-мапе можем хранить не сам полингром,
а только индексы его вхождения в строку S.
Во-первых, это можно хранить, а во-вторых,
что самое главное, мы храним в какой вершине дерева
полингромов, какая вершина дерева полингромов соответствует
именно этому подполингрому.
То есть вот такая идея.
Теперь идея такая, предположим, что нам пришел
символ C, и мы нашли подполингром,
который раньше не встречался.
Но это очевидно, это может быть только самый длинный
суффикс этой строки S+, который является полингромом.
Получается, нужно N в четвертой относительно длины строки
хэш, чтобы проверять, что
все подстроки были различные.
В смысле? Зачем?
Ну у нас типа N квадрат подстрок и вероятность коллизии и корень.
Ну, если корень... Ну погоди, давайте так, я использую
сейчас хэши как черный ящик. Я предполагаю, что у меня хэши
идеальные и коллизий нет.
Потому что моя идея будет заключать в том, что потом я расскажу технологию,
как избавиться от этих хэшей.
Вот, поэтому пока предполагаем, что хэши идеальны.
Нет, пока мы считаем, что они идеальны.
Тогда идея такая.
Значит, тогда получается, как добавить новый подполингром?
Идея очень простая.
Ну, заметим, что этот подполингром, если он не из одного символа
С, то он как бы состоит из символа С в начале, символа С в конце
и вот уже имеющегося у нас в хэшмапе деревья полингромов
полингрома, который был раньше.
То есть надо просто найти его вершину через хэшмапу
и построить из него переход по символу С в новую вершину.
Или убедиться, что там переход по символу С и так и есть
и понять, что этот подполингром в хэшмапе уже тоже есть.
Понятно, да?
То есть получается вот так с помощью N хэшмапа
ну или там одного хэшмапа, как вам удобно,
мы можем построить дерево полингромов,
обратите внимание, за два указателя, то есть за лигию.
Но теперь...
Так, есть тут до этого момента вопросы?
Да нет, наверное.
Нету?
Ну, так вот.
Но тогда идея...
Тогда этот алгоритм понятен,
остается только придумать, а как бы сделать так,
чтобы в этом алгоритме хэшмап не фигурировал?
Вот как это сделать?
Ну, на самом деле идея заключается в следующем.
Потому что мы говорим,
что мы тут двумя указателями перебираем.
То есть мы пытаемся перебрать все суффиксы,
все суффиксы, начиная с какого-то подполингрома,
там подполингрома длины,
предыдущий максимальный подполингром плюс два,
перебираем тут все длины до тех пор,
пока не наткнемся на полингром, правда?
А на самом деле давайте это сформулируем по-другому.
Рассмотрим все подполингромы,
которые были суффиксами строки до появления нового символа С.
Вот они, все подполингромы.
Первый по длине, третий, четвертый по длине.
Вот.
Нам нужно тогда, в принципе,
если бы нам кто-то с небес по факсу умел сообщать эту последовательность,
хотя бы по одному чиселке,
то мы бы просто тогда перебирали все эти подполингромы
и для каждого проверяли.
А слева от него случайно не символ там С завалялся.
Там еще нужно находить номер этой вершины.
Ну вот.
Ну еще желательно года, чтобы подполингром еще и номер в боре был.
Вот.
Но тогда идея такая. Для того, чтобы это перебирать,
заметим так, что в этом списке самый большой подполингром
мы откуда-то, допустим, знаем.
Но заметим, что каждый следующий подполингром
зависит только от предыдущего, правда?
Потому что по большому счету каждый следующий это что такое?
Собственный суфикс вот этого полингрома,
который тоже является полингромом, правда?
А почему в слове суфикс 2 я пообстрою префикс 1?
Ну видимо, да.
Ну да.
Например.
Нет, ну или просто как бы в английском есть слово фикс?
То есть типа где фиксировать?
В прее видимо фиксировать и суфиксировать.
То есть видимо.
Нет, не суба.
Нет, там как бы прее и пост там.
Ну и наверное.
Да, но по суфиксам непонятно.
Ну хороший вопрос на самом деле, если честно, не знаю.
Тут я, тут я прокомментировать не могу.
Так вот. Значит, идея такая.
То есть каждый следующий полингром.
Отделяется предыдущим получается.
То есть каждый следующий шаг мы можем делать так.
Ну тогда выNOISEт следующие идеи, то есть как это дело?
Нуdeep.
А первым заметим, что мы полингром в принципе.
То есть эти все ж полингромы у нас уже есть в нашем дереве полингромов, правда?
Тогда мы можем кодировать каждый полингром.
Просто соответствующий вершинкой дерева полингромов, правда?
И тогда получается для того, чтобы понять, какой у нас полингром следующий,
нам нужно просто в каждой вершине дерева полиндромов хранить ссылку, то есть хранить
указатель, ну, такие номер вершины, которые вершины вот собственного суффикса полиндрома
этого полиндрома. Итак, да, пришло время ввести официально это понятие. Так, давайте, будет такой
чернорабочее у нас понятие. Давайте, для этого я достану коричневый маркер. Не, ну, я обычно
такое рыжим пишу, но рыжий с красным. Ладно, как будете, коричневым или рыжим будем писать?
Так, ну, давайте так попробуем. Вот, выбирайте.
Это рыжий, это коричневый. Хорошо, ладно. Рыжий так рыжий. Ну, отлично. Значит, да,
двое застальны, да. Двое, да, просто про одном явно воздержавшимся, да. Хорошо. Итак, внимание,
объявляем суффиксную ссылку. Так, ну, во-первых, сначала нужно объявить такое понятие, как допустим,
то есть, если у нас есть вершина В деревополиндромов, то мы можем ввести такое понятие, собственно,
пал от В. Пал. Ну, пал от В, видите, я как функцию пишу, то есть, я не буду это в явном виде хранить,
но я обозначу запал от В это полиндром, соответствующий вершине В.
Какие классные сегодня марки. Вот. Вот. Теперь берем рыженький. Теперь, внимание, введем такое
суфф от В. Значит, определение такое, при В не равно, там, не равно рут, имейте в виду,
ни одному из рутов. Вот так. Вот я даже вот так напишу. То есть, пусть у меня В не равно ни одному из,
ни одной из вершин. Тогда мы говорим, что суфф от В это такая вершина У, что, внимание,
пал от нее. То есть, пал от У. Вот давайте, сейчас я черненький возьму. Это собственный суффикс.
Пал от В. Вот. При этом, значит, модуль этого пал от У. Максимально возможно.
Вот так. По сути, да. Я бы сказал, что это, но я это обозначаю, конечно, мы этому одному элементу суффиксную ссылку и прислаиваем.
Вот. То есть, это такое официальное определение. Да, еще, конечно, оговоримся. Или что то же самое,
А заметим еще, можно еще сказать так, что пал от В мы хранить не будем. Но лен от В, которое будет равно длине пал от В, мы в каждой вершине в явном виде храним.
Но с мелкой оговоркой. Точнее, двумя мелкими оговорками. Что лен от, нет, да. Ну, не совсем. Нет, можно, но оказывается, скажем так, учитывая, что когда вы просто попали в вершину, вы заранее даже не знаете, в каком дереве вы находитесь.
Вот. То есть, на самом деле, это тоже понятно, что можно сказать, для каждой вершины в явном виде хранить, в каком дереве она находится и на какой глубине, но это то же самое, но просто удобнее, оказывается, давайте просто длину хранить и все.
Вот. По большому счету, это такие параметры, что из каждого восстанавливаются другие, вопрос только что удобнее. Вот обычно удобнее лен писать.
Так вот. Я напишу так. Смотрите.
Значит, лен от, от нечетного корня удобно считать равно минус единицей, а лен от root-even удобно считать ноль. То есть, смотрите.
То есть, фишка будет такая, что всякие однобуквенные, то есть, из однобуквенных полиндромов суффиксная ссылка всегда будет вести в root-even, потому что максимальная длина собственного суффикса, который полиндром, это, конечно, ноль, а не минус один.
Вот. Но, оказывается, значит, то есть, в этом случае мы тогда скажем, что по определению, что суффиксная ссылка от, значит, root-even будет равна, соответственно, root-o'do.
Вот так я напишу.
То есть, пару символов реализации это нам скушает.
Во.
То есть, вот так мы определим суффиксную ссылку.
Ну, это просто, чтобы не...
Теперь давайте предположим, что нам эта суффиксная ссылка присылается с небес по факсу.
Тогда, то есть, если, то есть, как бы, то есть, предположим, что у нас там какая-нибудь появилась новая вершина, и тут мы, бабах, у чуда в ней появилась суффиксная ссылка сразу.
Так вот.
Тогда я утверждаю, что этих иши нам не нужны.
Потому что идея будет такая.
То есть, в каждый момент времени мы храним самый длинный суффикс-полиндром в виде вершины, которые ему соответствуют.
И тогда мы знаем его длину и проверяем, верно ли, что слева от него тут символ c.
Если да, то, значит, получается, вот мы нашли самый длинный полиндром, если надо, создаем.
Если нет, то мы еще берем следующий суффикс.
То есть, скачиваем по суффиксной ссылке, знаем ее длину, проверяем, есть ли тут символ c.
Вайл здесь упадает, мы переходим, и в итоге обязательно совпадет, потому что мы дойдем до...
Да, да.
И там один символ получится, что символ равен самому символу.
Да, да, да, да, совершенно верно.
Именно поэтому мы суффиксную ссылку и проставили, чтобы сначала там попытаться два символа набрать, а потом один, если совсем.
То есть, да, идея тут будет заключаться в том, что когда в худшем случае, если там совсем будет не переть, мы дойдем до длины 0 и проверим, не равны ли тут два символа c.
А потом длины минус 1 и сравним с собой.
А потом найдем префикс длины минус 1, но просто если строку длины минус 1 добавить с в начало и с в конец, то получится строка длины 1.
И тогда получится, что она под полиндром, и ее мы получаем рацнуки.
Ну да, то есть это скорее вот такой трюк.
То есть получается, что если суффиксная ссылка откуда-то у нас небес по факсу взялась, то тогда получается, что мы победили.
И в общем-то из вот этих вот двух указателей автоматически становится понятно, что мы действительно нашли суффиксную ссылку.
Что мы, получается, построили дерево полиндромов за линию.
Но нам осталось только придумать, как суффиксную ссылку насчитывать.
Да, да, да, я вот ровно это и сказал.
Да, что если суффиксную ссылку мы откуда-то берем, то мы победили.
Согласны?
Вот.
Но теперь возникает вопрос.
Да, откуда же мы найдем эту суффиксную ссылку?
Не надо никаких потенциалов даже вводить.
Ну точнее потенциал в некотором смысле придет, потому что у нас такие интересные два указателя, в которых левый указатель все-таки имеет право двигаться влево.
Но там рассуждение из цикла, что левый указатель двигается не становится...
То есть он начинает с нуля, заканчивается не позже n, и двигается влево не более чем n раз, каждый раз по единичке.
Но так-то два указателя тоже нужно с помощью потенциала?
Ну можно так сказать.
Нет, ну не совсем так.
Когда два указателя двигаются только вправо, то мы говорим, что каждый указатель двигается вправо не более чем n раз, поэтому победа суммарна у АТМ.
Причем, кстати, на причет суффиксной ссылки тупые идеи приходят сразу.
Типа не супер тупые, но такие конструктивные.
Как там, например, за логарифм это сделать?
Там конструктивные варианты типа бинт-подъемов и хранить массив.
Я боюсь тут с бинт-подъемами напряг, потому что если ты имеешь в виду с помощью бинт-подъемов для каждого символа, чтобы в завод единица было написано.
Не, нам уметь подниматься за логарифм и уметь просто дальше...
Ну подниматься за логарифм куда, если ты все равно на каждом должен прям последовательно их проверять.
Нет, ну просто там придумываются какие-то странные объемные конструктивные способы.
Ну вот, ну спокойно.
Нет, ну мы хотим...
Нет, на самом деле мы ничего умного-то не хотим.
Потому что вот у нас, допустим, возникла задача.
То есть задача такая.
Вот мы тут шли-шли-шли по суффиксным ссылкам, и вот, наконец, неожиданно нашли новый красивый зеленый полиндром.
Вот даже не здесь нашли, а вот неожиданно вот здесь нашли.
Я хочу у этого полиндрома найти суффиксную ссылку.
Как я это буду делать?
Ну на самом деле получается, если я отпилю эти символы С обратно, у меня опять получится полиндром здесь.
А если я возьму какой-нибудь суффикс, который является полиндромом, то отпилив символ С здесь и здесь, я опять найду суффикс полиндром вот этого полиндрома.
То есть идея такая, давайте получается от этого полиндрома, от которого мы только что стрелочку построили, давайте тоже идти по вот этим суффиксным ссылкам.
До тех пор, пока мы здесь не найдем там какой-нибудь суффикс, который расширяется до символа С.
Осталось только...
Да, сейчас, спокойно.
Ну то есть у нас было два указателя, мы этими двумя указателями нашли вот этот суффикс и расширили его на С.
Мы по суффиксным ссылкам нашли суффикс, который нам нужен.
Соответственно, мы нашли наш полиндром.
Тут нам еще не нужна наша суффиксная ссылка.
Нет, то есть мы только что создали эту вершину, и мы теперь для нее должны не считать суффиксную ссылку.
А как она выглядит?
Выглядит она так.
То есть она тоже выглядит как уже суффикс собственной, суффикс полиндром вот этого полиндрома, родительского.
Какого-то родительского, который можно расширить влево и вправо на символ С.
Ну вообще, да.
Ну тогда как их перебрать?
Так давай начнем с префикс функции по суффиксной ссылке родителя.
И будем по ней идти, идти, идти до тех пор, пока не наткнемся на расширение.
Почему это плохо?
Это же за квадрат может быть.
Не факт.
Вам может показаться, что это работает за квадрат.
Потому что у нас сломалось.
Ну в плане мы будем делать лишнюю работу, потом откатывать, потом еще раз ее делать.
Нет, почему лишнюю работу?
Ну на самом деле заметил, что в некотором смысле лишнюю мы не делаем, потому что мы как бы продолжаем идти.
Хотя да, если вам кажется, что мы работаем только с двумя указателями, этот указатель мы сдвинули сюда, потом вернули на место, то да.
Но, ну вот да, такой анализ нам победы не дает.
Но мы более хитрые.
Дамы и господа, метод трех указателей.
А давайте вообразим себе следующее.
Смотрите.
В каждый момент времени на самом деле заметим, что у нас есть, значит, какой-то два указателя, которые указывают на, значит, начало и конец самого большого, там какого-то суффикса полиндрома, правда?
То есть мы как бы когда этими двумя указателями мы говорили, что мы тут идем, идем, идем, в какой-то момент останавливаемся и два указателя вот так расширяем, правда?
А теперь у меня следующий идея.
Давайте мысленно добавим третий указатель.
Да, третий указатель, зелененький, красивый, ладно, вру, рыженький, который будет указывать на мысленно, на, так сказать, суффиксную ссылку вот этого полиндрома синего.
Ладно.
Давайте мысленно будем считать, что это рыжий указатель с нами.
Заметим, что, как тогда все это будет быть?
Когда мы будем искать, собственно, вот это расширение, то есть как бы у нас синий указатель двигается вперед, но вместе с ним вперед двигается и рыжий.
То есть как бы это синий указатель скачет по суффиксным ссылкам, а рыжий бежит впереди него.
Да, то есть такой глошатый такой кричит, что сейчас сюда придет король.
Ну, там король или там, я не знаю, фантомас может там, я не знаю.
Ну, знаете, это ситуация, вы приходите домой, там вам звонит телефон, вы берете трубку, а там, внимание, сейчас с вами будет говорить фантомас.
Повторяю, с вами сейчас будет говорить фантомас.
Ну, вот что-то такое.
Да, потом дубинкой по голове и вы появляетесь в комнате дворца и с вами реально начинает говорить фантомас.
Да, потом требуется 15 минут фильма, чтобы понять, что это был не сон.
Ну, подробнее смотрите фильм про...
Ну, я вас уверяю, не про просто кваш.
Да, на самом деле такой веселый фильмец, на самом деле, смешной.
Жалко, потом во втором фильме фантомас все-таки убивать начинает, это становится грустно.
До этого было смешно.
Ладно, значит, смотрите, то есть такой глошатый значит идет вперед.
И вот в какой-то момент, значит, вы тут шли-шли-шли и наткнулись.
Наткнулись на то, что надо что-то расширить.
Вот.
Но как мы дальше ищем суффиксную ссылку?
То есть, да, хорошо, синие указатели чуть-чуть раздвигаются.
Значит, синие указатели чуть-чуть раздвигаются.
Вот.
Пока.
Потому что, чтобы он стал корректным, мы должны реально найти для этого нового полиндрома суффиксную ссылку.
Ну ладно.
Вот.
Давайте мы можем сейчас даже предполагать, что мы ее всегда будем в тупую искать, даже если эта вершина уже существовала.
А как мы ее будем искать?
Мы будем, начиная с вот внимания ровно этого момента,
скакать по префикс-функциям дальше, до тех пор, пока очередной не расширится.
Но тогда получается, что, видите, рыжий в этой ситуации до сих пор, пока ни разу назад не сдвинулся.
То есть он тоже двигается вперед-вперед-вперед-вперед.
И только вот там двигается вперед-вперед-вперед.
И в какой-то момент он сдвинется на один назад.
Вот.
Ну можно даже сказать, правильно было, что мы тут тоже два рыжих указателя храним, то есть этот как бы фиксирован, но потом он вот так сдвигается.
Да.
Да.
Ну метод двух пар, двух указателей, по сути.
То есть как бы, если вы храните два указателя, двумя указателями, не только вот сам этот префикс,
не только вот эту суффиксную ссылку, то оказывается, что эти два указателя тоже двигаются по принципу,
что там правый указатель двигается только вперед,
левый указатель там двигается иногда налево, но исключительно в рамках ампилотерапии по чайной ложке, там не более чем 1 раз суммарно.
Вот.
И поэтому...
Рыжий на что формально указывается?
На суффикс...
Ну на начало и конец самого большого собственного суффикса нашего синего полиндрома,
который тоже является полиндромом.
То есть давайте назовем синем полиндромом самый большой суффикс полиндрома.
Кстати, обратите внимание, он может совпадать со строкой S от слова вполне.
То есть если строкается полиндром, то синие указатели просто указывают на все вот это вот.
Вот.
Рыжий указатель...
Значит это назовем синем полиндромом.
То есть рыжий указатель указывает на самый большой собственный суффикс синего полиндрома,
который является тоже полиндромом.
И тогда оказывается, что, двигаясь вот так рыжим указателем, получается красиво.
То есть получается, что суммарно эти скачки по суффиксным ссылкам тоже работают за линией.
По сути так, да.
Вот. То есть боль то, я думаю, да.
Так что получается, после этого можно теперь бежать и кодить, и мы, пожалуй, даже это сделаем.
То есть получается, когда мы находим вот это вот совпадающий символ, мы не останавливаемся, а продолжаем прыгать?
Ну нет, синим останавливаемся, рыжим нет.
Да, но имеется в виду мы можем не останавливаться, а продолжаем прыгать.
Мы не останавливаемся, а продолжаем прыгать?
Ну нет, синим останавливаемся, рыжим нет.
Да, но имеется в виду мы потом, чтобы еще насчитать от нас, мы еще дальше прыгаем, чтобы найти второе совпадение.
Да. То есть по сути мы не одно...
То есть можно считать так, мы ищем не только первое, не только самый большой суффикс, но практически два самых больших суффикса.
Прикольно.
То есть на самом деле оказывается вот так.
Да, можно ввести потенциал, конечно, но на самом деле вот...
А почему странно-то?
Ну что за бред?
Ну вот.
Нет, у меня такая интерпретация.
Ты можешь почитать, собственно, оригинальную статью Рубинчика, а может быть там будет менее странно.
Вот, я не знаю.
Но просто как по мне...
То есть как бы тут вопрос, можно ввести формально потенциал и доказать, что все работает?
Нет, понятно, почему работает.
Ну вот.
Ну как бы сказать, да.
Мне кажется вот так вот тоже должно быть как бы тоже интуитивно красиво, хоть и немножко разрывает шаблон.
Ну вот.
Ну с другой стороны.
Как это называется?
Так что давайте попробуем.
А, да-да-да.
Забыл, забыл, забыл.
Давайте.
Какую?
Да, вот самая левая.
Вот эта?
Да, ой.
Ну скажи так, она двигается, но не тривиально.
Она кажется должна.
Нет, она по-моему так двигается.
Ее можно вот, да, вот она двигается вот так.
Вот так.
И вот так.
Да, ну вот.
Вот.
Но эту придется вот так сдвинуть, да.
Хануйские башни.
Не, хануйские башни другое.
Чего?
Бануйские хашни?
Чего?
Бануйские хашни?
Чего?
О боже.
Ага, да-да-да.
Нет, там уже начинается теря Махана-Бахана.
Там какого-нибудь.
Ну а как еще там будет как бы?
Кажется вот так должно быть достаточно,
потому что она пересекалась.
Так ладно, давайте сейчас попробуем.
Так, Вася, включайся.
Ой, давненько, да.
Вася сегодня нет.
Да я вижу. Ее вообще что-то давно уже нету.
Вася сегодня пришел на испанское действие.
Сказал тему.
Видимо шел дальше спать.
А, Вася профессионал, да.
Ну да-да-да.
Да я знаю, мы так вчера на КВН сходили.
Мы там, как это?
Официальное начало в билете 18.30.
Мы вошли в 19.07.
КВН начался где-то там по-моему 19.15.
Блин.
Ну.
О, Валебульчик, так.
Выключи свет, пожалуйста.
Так.
Смотрите, сейчас мы это узнаем.
Потому что если это
не так.
Так.
Да, именно вот
таким образом можно сделать первую оптимизацию
в ФФТ.
Но для вас новой информацией не является.
Мы уже с вами в прошлом году.
Там ровно год назад делали.
Нет, еще.
Не-не-не, это я в 11 классе
рассказал. Так.
Пока проектор прогреется.
Ну а что делать?
Я с ними уже четвертый год.
Так что пришло время и это ладно.
Вот.
Когда вы ставим ФФ2,
почему не ФФТ2?
Это в смысле, это
самое первое ФФТ.
Это два ФФ2.
Я ФФТ назвал.
Вектор Олд.
Вектор Олдов, да.
Ну что? Так. Ну что?
Лучше видно?
Да я знаю, за фотоша, да-да-да.
Ой.
Полинтромик 3.
Ну хорошо,
не занудствуй.
Вот.
Е-3.
Е-3.
Чтоб полинтром был.
А!
Это какой-то 800-й кирю-юмор.
Ну это лучше, чем Курева, конечно.
Ой.
Ладно.
Ну да-да-да.
Поэтому Куреву называют да-да-да.
Так. Ну ладно, давайте.
Так, значит, смотрите.
Давайте посмотрим, что нам нужно хранить
в нашей ноде.
Ну давайте смотреть, что мы храним в ноде.
Так. Ну, во-первых, храним Инт.
Значит храним Лен.
Да.
Значит храним Лен.
Так, что нам, да, ну вообще
переходы надо. Так, ну переходы можно
двумя способами хранить. Можно в мапчике
хранить, можно
в массивчике.
Как правильно? Ну естественно зависит
на самом деле от размера алфавита.
Потому что есть подозрение, что если у вас алфавит размера 26,
то мапчик может выиграть.
Если у вас размер алфавита 2, то очевидно
нужно хранить в массивчике.
Вот. Не, еще зависит
от того, что вы хотите оптимизировать память или время.
И то, правда.
Потому что если вы хотите оптимизировать время,
вам мап нужен никогда.
Ну вот. Значит смотрите,
храним.
Так, Лен и соответственно СУФ.
Значит поехали. Такое вот ноде.
Значит смотрите.
Ну вот.
Ну вот.
Значит заводим ER3.
Вот.
Значит что я тут буду хранить?
Ну естественно я буду хранить вектор нодов.
Неправильная большая буква.
Первая маленькая,
ты большая. О господи.
Нет, ну классы у нас все-таки
с большой буквы пишут.
А, это вообще неправильно, да.
Так, хорошо, нодис.
Значит что нам нужно, чтобы хранить еще?
Нам ну INT.
Ну так, как хранить эту?
Значит INT, ну допустим.
О.
Значит я заведу.
Нет, хотя вот нет,
просто проблема в том, что мы этот,
ладно.
Да.
Ну, как сказать, мы с вами
только что обсуждали, что мы храним вот этот вот,
называем синий суффикс, да?
Вот.
Тогда в нашем контексте мы это можем назвать синию вершину.
Ну правильно, конечно,
а там по-другому это называть, наверное.
Ну можем, хорошо, в укоренении мы будем это называть
last. Ничего.
Или, а, мы это хуже будем называть,
last, not suf, мы это будем называть
или first, not suf.
И в этот момент просто кто-то лицет головой в окно.
Да, да, да.
Да, кого-то кукнул.
Ну, как хотите, можно last, можно blue суффикс оставить.
И тогда у нас потом будет orange суффикс.
Значит, смотрите.
А, ну и конечно же мы не забываем,
так, еще нам конечно надо хранить
саму строчку, наверное, да?
Так, во-первых,
ER3, собственно, конструктор.
Так, ну здесь все просто.
Nodes мы храним, у нас будет две вершины.
И last.
Так, ну last, в принципе, можно хранить от нуля.
Хотя, о,
пришло время сделать красивую
штуку.
Нет, курс по посторонней,
это TP.
О,
смотри,
какая красота.
О,
смотри,
там еще int, наверное, было.
Ну, четный корень,
нечетный корень.
Нет, я думал написать красный корень и синий корень,
но, пожалуй, я не буду этого делать.
Конечно, да.
Давайте, сейчас мы хотим
минус один, так?
Нет, нет, смотрите, нет, почему минус один?
Сами вершины,
которые будут вот этим корнем E,
и тем корнем они будут 0,1.
Оформляем нечетный корень.
Нечетный корень, дети,
так, ну, во-первых, давайте тут напишем,
что это нодя, чтобы красиво было.
Вот так вот напишем. Значит,
нулевой вершине, значит, ну, мапчик
пустой, естественно, len равен
минус один, суффиксная ссылка равна
ну, допустим, минус один.
Далее.
Значит,
учетного корня
мапчик пустой, len равен ноль,
суффиксная ссылка равна
odd root.
Вот, я так и напишу.
Понятно, да?
Вот, ну, минус один, на самом деле,
тоже можно написать.
Вот.
О, можно еще вот так написать,
чтобы совсем красиво было.
Вот, потому что тут минус один как бы
у нас уже осмысленно, а тут как бы я могу
написать минус один, минус 57,
там, что угодно.
Вот. Так вот.
И теперь нам нужно написать функцию
как бы
push back
чара.
Хорошо, хорошо, да.
Значит, теперь push back m symbol.
Можно, но
не очень-то нужно.
Вот.
Итак, поехали.
Значит, смотрите. Итак, я хочу, чтобы этот чар
был n-ым символом строки.
Для этого я сделаю так.
Так.
Так. Тихо-тихо-тихо, ребят.
Значит, поехали.
Итак, у нас n-ый s, значит,
это чар, это n-ый символ строки s, я его уже
push back, чтобы потом не говорить об этом.
Last это сейчас
он указывает, то есть это на максимальный
полиндром, который заканчивается в n-1
символе.
Значит, я теперь
говорю, что while
там какой-то, то есть
пока у меня текущий полиндром
last-овый нельзя расширить
на два символа,
что я делаю?
Я просто говорю, что
last равно
suf от last.
Да, знаете, в таких
случаях, кстати, очень удобно вводить
такие функции.
Вот.
Вот, знаете, просто, ну, такие вот
коротенькие такие
функции, чтобы просто
быстрее писать.
Да, знаете, вот, может быть, даже
имеет смысл их вот так писать, смотрите.
Вот.
Лен еще вот так можно писать.
Не, но приватные все-таки.
Зависит от вашего
код-стайла. В моем код-стайле все
приватное с нижним подчеркиваем.
Потому что в некоторых код-стайлах
и push, ну вот, в моем код-стайле
все приватное с нижним подчеркиваем.
В некоторых код-стайлах и push, ну вот,
в некоторых push-back и push-back
не так пишут.
Вот.
Ну, это как бы, то есть там,
если у вас там на код C++ и другой код-стайл,
то значит вы будете пользоваться другим код-стайлом.
Или там, ну, как бы, как всегда
он может быть один, там C++ и другой,
в гугле третий, в яндексе четвертый,
у вас в команде пятый.
Ну, я имею в виду курс,
ваш курс C++, естественно.
Вот.
Да, у STL, конечно, есть.
Нет, у STL есть код-стайл.
Так же, соответственно.
Значит, смотрите.
Так.
Ну вот, значит, смотрите.
Значит, что мы видим от last?
Значит, что же тут за условие должно быть?
Надо просто проверить, верно ли,
что слева от этого полиндрома
находится
какой-то чаровый символ.
Ну, значит, проверять
это надо так.
Ну, во-первых, что это за символ?
Ну, давайте подумаем,
вот что это у нас за символ,
что, вообще, какой номер
в строке этот символ имеет?
Если у нас в конце
вот сейчас полиндром, который находится
в вершине last.
Так.
Так, минус 1.
Нет, мы в ноль индексации.
Но суть-то одна.
Но суть-то одна. Н-ный символ — это сам ч.
То есть по-хорошему мы должны написать,
что пока вот этот символ
не равен
ч.
В чем проверка такая,
что в конце, в самом конце, если будет
никогда не вести last, должен,
лен от last должен стать минус 1,
и тогда вот эта штука должна сойтись
с н-ное, что должно быть равно ч.
Но, к сожалению, есть мелкая проблема.
Да, мелкая проблема бывает,
лен от last бывает n, и
тогда, получается, нам придется все-таки написать,
что вот лен
от last,
к сожалению,
бывает
отрицательная, поэтому
нам придется вот так написать.
Даже вот так.
Вот, да.
Но, наверное, да, кстати,
видимо, для оптимизации не помешает
еще тут const написать.
Тогда больше вероятно, что
оптимизатор как бы вот это
два раза вычислять не будет.
Чтобы еще
повыстроить,
можно там, наверное, даже inline.
Типа того, да.
Так что вот такая красота, получается.
Не люблю.
Вот. Ну, допустим, ладно,
это мои, допустим, какие-то.
Ну, понятно.
Окей.
Смотрите.
Next, дальше, while, соответственно,
хорошо. Значит, что будет дальше?
Дальше, получается,
ваил, соответственно, хорошо.
Ваил, соответственно, хорошо.
Значит, что будет дальше?
Дальше, получается, примерно, следующее.
Так, ну, хорошо.
Сам суффикс мы, значит,
этот суффикс, который можно найти до q, мы нашли,
и даже last уже находится в нем.
Значит, дальше мы напишем,
можно написать следующее.
Значит, теперь,
если нельзя пойти из вершины
last по символу q,
то мы тут
делаем. Вычисляем, ищем префикс функцию.
Но в конце мы говорим,
что last равно go
от last х.
Ну, здесь мне просто удобно писать,
что can go, пусть я там лезу в это дерево,
можно ли из этой вершины пройти,
если у меня есть переход из этой вершины
по символу q, да или нет?
Понятно, да?
Вот.
Ну, а go он просто берет и идет по этому
символу, он у меня будет даже небезопасный.
То есть он будет подразумевать, что переход есть,
я просто туда пойду.
Обычно я такие функции реализую в конце,
потому что мне все равно компилятор скажет,
что их надо там дописать.
Ну, а это уже вопрос
к тому,
какие у вас настройки редактора.
Как бы мне не сильно принципиально.
Ладно, это не принципиально.
Итак, поехали.
Итак, что же делать?
Ну, понятно, что здесь, в общем-то, не интересно,
потому что как бы да.
Итак, что же делать, если перехода нет?
Так, что же делать, если перехода нет?
Значит,
пишем int
n last
равно, ну, точнее,
создаем
новую вершину.
Она будет, естественно, номер точнее.
Так, она будет
nodis.size.
Пишем nodis,
значит, pushback-аем новую вершину.
Значит, внимание,
pushback-аем новую вершину.
В этой вершине
будет
пустой мапчик,
len будет равен
len от n last
плюс два
и что-то еще.
Чего?
Ну, пока
undefined.
Понятно, да?
Ну, можно так,
там, любители оптимизации
могут там placeback написать,
если есть желание.
Так, ну, теперь пришло время посчитать
суффиксную ссылку.
Undefined у нас
специально, вообще, отдельно
прописывается, чтобы что?
Чего?
Да нет, просто...
Так, ну, во-первых,
значит, сразу предупреждаю,
нам придется здесь разобрать
один вредный случай.
Смотрите, дело в том, что нам
надо как бы пойти в родителя
этой вершины, которая сейчас в власти.
Вот.
Значит, который, соответственно, в власти.
Вот.
Из этого родителя хотя бы один раз
скакнуть по суффиксной ссылке,
а потом еще скакать до тех пор, пока не дойдем.
Отсюда возникает случай.
А что делать, если этот родитель
уже с lenом равным минус один
по суффиксной ссылке скакнуть нельзя?
То есть, к сожалению, вот тут лишний
ифчик придется написать.
Значит, придется написать, что если
last
оказался
вот этим вот нечетным
корнем,
то тогда что мы сделаем?
То есть, мы тогда сделаем, что nodis от
suf
nodis от
last
точка
back у вектора.
Ну, нет, ну мы просто, тут лучше,
что мы вот это новое, т.е. last это новая вершина.
Вот, nodis last suf,
тогда пишем, что она равна просто чему
правильно, соответственно,
к счетному корке.
В противном случае
начинаем что-то делать.
Правда, смотрите, вот на самом деле, если не хочется
вот это присваивание делать,
смотрите, есть один наглый чит, который в большинстве
случаев работает.
Чит знаете, как называется?
Вот так.
Ну, хорошо, хорошо.
Ну, в таком случае мы подразумеваем, что мы ссылки имеем.
Очень удобно.
Правда, есть одна
nod. Правда, смотрите,
правда, на самом деле,
это надо использовать с большой оговорой,
с большой осторожностью.
Потому что,
на самом деле, дело в том, что мы
работаем с вектором.
И вам, если вы вычисляете
вот эту ссылку,
то надо следить,
что пока вы что-то присваиваете и работаете,
надо следить за тем, чтобы эта
ссылка не инвалидировалась.
Потому что, знаете, у меня,
когда я писал как-то, потому что я в Петроводске
так полдня украни надебажил.
Значит, прям сидел.
Чего?
Нет, и во время, и на контесте, и потом
еще полдня в дорежке.
А причина оказалась следующим.
Дело в том, что я написал там
вот какую-то строчку, вида
нет, я написал там
nodisware.suf
равно, там условно, calc
suffixlink.
Вот так.
Вот.
Значит, какая бага
потенциально
здесь зашита? То есть я даже вот
этого суфа я не делал, я просто вот так
сделал. Оказалось
следующее, что
он, значит, компилятор оказался
просто в укранине, вот я вам заранее
скажу, есть подлянка в том, что вот эта функция
сама по себе создает новые вершины.
Может даже не одну.
Может даже несколько.
Вот. Ну вот.
А кто когда-нибудь писал
укранина, кстати?
К сожалению.
О господи. Слушай, это ты
тогда так удачно в лошадь ездил?
Или где-то еще?
Вы мне читали, но я тогда не писал,
я писал в ЛКШ.
А, окей.
Хорошо.
Понятно. Хорошо.
Ну понятно, да. Зачем это?
Понятно. Значит, я понял алгоритм
с 19-го раза. Ну это нормально.
Я укранина в ЛКШ вообще не понял.
Я его так писал еще в 8 часов.
О да.
Я просто терпеть не могу
укранина после этого.
Ну тут у кого как, потому что я помню, я в 10 классе
я был в ЛКШ, у меня я Капелевич его рассказал.
Сначала я рассказал Капелевич, я ничего не
понял, слово в ноль.
Не, просто сначала вам его 4 часа читают,
вы в дупле идите, как оно работает,
задаете миллиарды вопросов, потом
еще 8 часов и вы пишете с дебагом.
Так вот, да, твой опыт мы допоняли.
Отвечаю, значит, мой. Значит, там
Капелевич рассказывал полтора часа, я ничего
не понял. Но правда со мной ничего не понял
никто, а это была группа А вообще.
Понял то, видимо, написать это
после этого смог только один человек, возможно
он просто тупо знал до этого.
Ну почти, нет,
Лев Толбачев. Значит, после
его когда-то мы отдельно собрались, и это алгоритм
рассказал Станкевич.
Честно скажу, я тоже вообще ничего не понял, но количество
аксептов в контесте увеличилось до 10.
Видимо, я был тогда тупенький.
Ну, а прошло так, прошло несколько
там, пошло получается, сколько там,
где-то там почти 2,5 года.
На втором курсе
я пришел на лекцию по алгоритмам,
собственно, к моему, вот, собственно, преподаватель
алгоритмов, это Виталий Борисович Эльштейн.
Ну, я уже рассказывал о нем, ну вот.
И он рассказал Уканина. Рассказал он его
примерно за час, в чем рассказал так,
чтобы, по крайней мере, лично я все сразу понял.
Ну и, собственно, как он
конкретно рассказывал, вот я, наверное, примерно вам
и расскажу.
Кроме понять,
еще большая проблема его написать.
Просто нам нюансов именно
вот реализации такой точно
много. Ну вот мы, вот мы и
посмотрим, потому что потом, когда я
впервые написал Уканину, даже на джаве.
И никаких проблем даже не возникло.
Там столько вот всяких
мерзких ифов, которые
можно пропустить. Познакомимся.
Понятно. Так вот.
Ребят, давайте не будем это тратить
время. Значит, смотрите. Так вот.
Я просто к чему? Значит, я вот писал
это в Укане. Так вот, в Укане возникла такая подлянка.
Значит, Калк Суферслинк менял
то есть вера, то есть
как бы добавлял вершины, то есть
пушбекал их в вектор.
Получилось так, что компилятор сначала вычислил
вот эту ссылку, куда присваивать,
да.
А потом
запустил эту функцию и инвалидировал
вектор. То есть вот эту ссылку
инвалидировалась.
То есть очень сложно было дебагать,
потому что когда я написал там
что-то дебаггерское типа int у равно
вот там,
то есть типа написал, что это мы потом
взяли после, то оно не совпадало.
Так. Ркал Катве, значит,
ср у соответственно
нодис
от v.suf равно у
все почему-то начинало работать.
Ну вот вы уже поняли почему.
То есть поэтому просто вот
есть такая вот подлянка есть.
То есть чисто
сишная вот подлянка такая есть.
Поэтому вот будьте внимательны.
То есть поэтому надо
поэтому я просто сказал, пользуйтесь
вектором, то есть два варианта. Можете на самом деле
вместо вектора создать статический массив
и там pushback просто сдвигая
указатель.
Компилятор должен
понимать, что оно
никому он ничего не должен.
Он вычисляет левую функцию, вычисляет правую
функцию. Все.
Это просто значение левой функции
и value-value это ссылка. Так что
как бы
просто так работает C++.
Просто там с годами некоторые
гарантии заводят, что что-то вычисляется раньше,
может быть. Так вот.
Это я просто предупредил.
Просто чтобы какие
аккуратности нужны. А так вот в принципе можно
сув тоже вот так присваивать.
Значит поехали.
То есть желательно, чтобы когда используете ссылку
у вас там никаких вектор точно
не изменялся.
Так вот поехали.
Значит поехали. Здесь надо сказать, если
last равно true, то тут все просто.
В противном случае пишем
int, значит скачем вот этим рыжим указателем
Как мы его назовем
этот рыжий указатель?
Ну да.
Ну да.
Получился апельсиновый указатель.
Ну тоже позитивчик какой-то.
Ну да, вот почему orange
а не brown.
Orange PTR for
значит orange
brown PTR
значит orange
PTR равно
suv от last
значит получается suv от last
orange PTR
нет, хотя нет.
В данном случае давайте уже copy
paste while.
То есть фактически он пишем
suv от last
Значит пишем абсолютно
то же самое, только вот вместо last
пишем orange PTR
То есть пока вот выполняется ровно
то же самое, хотя вот это тут по идее можно
не писать, потому что это будет уже заведомо
как бы больше либо равно нуля,
но тем не менее.
То же пишем orange PTR
равно suv
от orange PTR
Обратите внимание, кстати тут большой
соблазн на самом деле написать
знаете у меня вот была такая когда-то бара
когда я вместо вот этой штуки
написал там
что-то типа can go из orange PTR
по символу chart
То есть просто проверять нельзя
Что?
Сейчас
А, окей, да
То есть мы тут проверяем как
мы в самой строке проверяем
можно ли соответствующий suv продлить на символ
chart влево и вправо
Так вот, бывает соблазн
на самом деле, особенно после всяких
карасиков с уконенными
проверять это просто
нельзя ли из вершины orange PTR
пройти в символ chart
Так вот, это ошибка
Потому что из того, что
есть такой же полиндром orange PTR
плюс символ
chart влево и вправо никак не следует
что именно этот полиндром является
суффиксом нашего нового полиндрома
у которого мы эти суффиксы ищем
и там можно придумать, и там вы получите
VA8 в котором стоит
и там в соответствующей задаче будет
VA8 и с контратест
в котором есть тест в котором это действительно работает
Если у нас символ совпадает
то мы можем перейти, но если он не совпадает
то нам никуда идти нет
то есть тут лучше вот
поэтому так
ну и в конце соответственно мы говорим, что
да
ой, совсем забыл
надо же не просто по push back
а надо еще сказать
nodis от соответственно last
точка children
от символа ch должно быть
равно n last
ну это так или иначе
а, ну конечно
значит скачем
знаем, что так как мы стартовали не изодруто
то мы рано или поздно найдем куда
то есть получается мы это заведомо ищем
не для полиндрома длины 1
то есть мы заметим, что вот это случае работает тогда и только тогда
когда новая вершина имеет длину 1
то есть мы новый символ добавили
а в противном случае нам все что тут остается
это написать, что
ну вот
значит чего тут написать
last равно go от last
это мы сказали
тогда написать suv
от orange ptr
точнее от pardon
от n last
равно
просто go
из orange ptr
мы гарантируем, что там уже можно пройти
по символу ch
все
не сильно много кода получилось, да?
я почему-то не учею в этом пару строк
особенно вот про
давай посмотрим
давай
давай узнаем почему
не, может просто не понял
конкретно ваш вариант
как оно выглядит, но
не знаю
я не знаю
я не знаю
я не знаю
как оно выглядит, но
а ну ладно
это go и can go еще надо написать
но это еще две строчки
буквально
а просто у нас если наш родитель
это od root
ну да
тогда тут все просто
это будет тогда и только тогда
когда у нас полиндром длины 1
в противном случае у нас полиндром
длины 2 или более и тогда этот код прекрасно
работает
вот
ну просто там тогда мы
в противном случае мы гарантируем, что там хотя бы одна
суффиксная ссылка у родителя
это реально есть
и мы обязательно в какой-то момент упремся в строку длины
минус 1
так если last равно, то есть мы обрабатываем
полиндром длины 2 и родитель у нас even root
давайте смотреть
что тогда произойдет, он пойдет по суффиксной ссылке
отправится в минус 1
то есть в od root
то есть нечетный
из него переход
это было уже заведомо есть и он по нему пройдет
вот и все
вот так что
ну go и значит эти две строчки
там go вы там уже напишите в качестве упражнения
сами
вот
да
ну да по-разному вопрос только
какая-то там как мапа
я бы рекомендовал писать аккуратно
то есть bool can go конечно
лучше писать там int v
char ch
ну естественно нужно писать как
return
значит
nodis от v точка
children точка
count от ch
ну то есть
да чтобы не создать лишнюю вершину
ну я так на всякий случай пропишу
причина писать на массиве
ну при условии что алфавита
пожалуйста да
потому что по памяти оно почти везде заходит
ну да да да да да
конечно
но да
ну и здесь соответственно return nodis
от v точка children
от ch все
то есть на указателях оно может не зайти
ну можно
как хотите
ну я из-за нет смысла в данном случае в указателях
наверное все таки хотя на вашу смотреть
да то есть дальше
ну то есть дальше как
позже ну
не знаю
тут
на вкус и цвет всегда можно и так
и так
так что вот получается и все дерево
полидромов в общем так оказалось не сильно сложно
вот
то есть более того чем
это нам вообще помогает
ну здесь давайте в конце я все таки
добавлю еще это чтобы мы не просто
строили а на самом деле можно отметить что дерево
полидромов конечно позволяет с этими полидромами
очень красиво работать
ну например самая тупая задача
на самом деле такая
то есть например нам вот
допустим нам очень захочется
до нас строка она фиксирована
и нам приходят запросы про вот эту
строку p которая полидромов
и нас спрашивают является ли она под строкой
ну мы это теперь сделаем без труда
да
а теперь внимание
предположим что нам случайно
говорят что
нам допустим говорят что
если она есть то скажите
там самое первое вхождение этой
строки
или самое последнее
или количество
ну это вроде
количество уже не так тривиально
ну там хоть сколько то
думать надо там первое вхождение
ну первое
так ну первое вхождение
первое вхождение конечно каждого полидрома
действительно тривиально потому что первое вхождение
у вершины это когда
вы ее создали правда
очевидно, да, просто сохраните момент времени и возрадуйтесь, а вот значит, так тут понятно, о чем я о чем речь, а
то тут вот у нас, а то у нас тут знающий Денис действительно сразу все рассказывает, да, вот,
но идея на самом деле очень проста, то есть идея, то есть на самом деле, допустим, мы хотим теперь для каждого суффикса
пометить, сколько раз он встречался, как нам это сделать, но идея на самом деле очень простая, то есть давайте, когда мы строим дерево
полиндромов, мы знаем самый большой суффикс, который полиндром, да, то есть давайте для него и для всех из всего его
префиксного пути, то есть этого суффиксного пути, прибавим там в черчах единичку, да, тогда у нас будет в конце в точности
ответная задача, единственная мелкая оговорка заключается в том, что, конечно, если мы так будем берем, это будет квадрат,
понятно, да, но как, но как этот квадрат оптимизировать до линии, да, очень просто, давайте просто сохраним для каждой вершины,
что мы тут прибавляли единичку, а потом после того, как мы построим дерево полиндромов для всего, мы эти единички просто наверх
пропихнем стандартным образом, там либо ДФС, либо просто пробежимся по дереву справа налево и будем там говорить, что
там прибавь мое число к суффиксной ссылке, да, то есть как угол, то есть там лениво, то есть более того, аналогичным образом можно
пропихивать и последние вхождения, то есть для каждой, то есть каждый раз, когда вы пришли суффикс, да, какой-нибудь самый большой,
вы записываете, что я его видел сейчас, а потом в конце пропихиваем, что если я себя видел сейчас, то и суффиксную ссылку я видел сейчас,
то есть выбираем максимум, вот, то есть самая крутая задача, то есть у вас там, то есть это на самом деле в 2014 году,
вот, то есть, знаете, в диссертации Рубинчика, на этом, кстати, очень смешно, знаете, редкий случай, когда олимпиадному программисту,
с точки зрения даже олимпиадной практики, интересно почитать кандидатскую диссертацию, потому что там какие страны в обосновании
того, зачем это надо, там тоже расписываются, знаете, вот, бывают такие соревнования CPC и там вот подсовывают задачи на полиндромы,
в которых там какие-то зубодробительные решения, вот, например, одна из таких задач, например, была в 2014 году данные две строки,
там С и Т, я хочу найти количество таких четверок там И, Ж, К, Л, что под строка С и по Ж совпадает с под строкой Т от К, Л,
и при этом эта подстрока является полиндромом, вот, то есть, нет, у меня самого был прикол, что я тогда не знал дерева полиндромов еще,
дерева полиндромов это тривиально делается, сейчас, ну, сейчас, погоди, ну, там вот действительно просто интересно, давайте,
ну, тривиально нет реально, но техника стандарта, значит, как тогда это делать, ну, идея такая, ну, например, одна из идей на самом деле может быть такая,
то есть, давайте, ну, значит, как это можно сделать, вот, ну, на самом деле можно сделать по-разному, можно, например, пробежаться по строке С,
построить дерево полиндромов, построить дерево полиндромов и заодно там для, ну, да, ну, просто, короче, построить дерево полиндромов,
тогда идея такая, а теперь возьмем строку Т, для нее не будем строить дерево полиндромов, а будем, так сказать, ходить по строкой Т,
по дереву полиндромов в строке С, то есть, что я имею в виду, я буду иметь в виду, что я буду идти Т слева направо,
и в этот момент времени я хочу знать самую длинную подстроку, которая заканчивается в этом символе и которая не просто является полиндромом,
но является полиндромом, который встречается в строке С. А в строке Т как мы будем проверять, что встречается?
Так зачем? Я же говорил, определение еще раз. Я хочу для каждого символа этого символа строки Т найти самую длинную подстроку строки Т,
которая заканчивается в этом символе и является полиндромом, встречающимся в С. Ну, не очень понятно, как это сделать.
Элементарно. То есть, делать я это буду следующим классическим образом, вот это надо обсудить.
Нет, погоди. Ну, я рассказываю другой метод. Так, давайте я это выключу тогда.
Так, давай, погоди, погоди. Слушай, как бы на эту тему я так скажу, на вкус и цвет фломастера разные, а изучить стоит несколько способов,
потому что тут кому как. Потому что я, например, вот первое решение, которое у меня тут приходит в голову вот такое.
Вот это мы убираем, эту красоту, все. Жалко, что убираем, вот придем. Если бы это осталось, конечно, до понедельника, это была бы красота, конечно.
Нет, знаете, потому что забавно, почему... Да? Так тут и прикол. Более того, я каждый раз прихожу, и тут остается то, что осталось у меня после среды.
Вот это красиво. Ну, вот, ладно, вот это я оставлю, да.
А на сколько мы, собственно, говорили, что 45 минут... Все, все, все.
Я говорил 30 через 45. Ну ладно, ну.
Значит, сейчас быстренько, значит, смотрите. То есть первое смысл такой, что, значит, мы... Жала была строка С, мы построили по ней дерево полиндромов.
Теперь идея такая, идем по строке Т. Я хочу для каждой позиции И хранить максимальный суффикс, у которого есть вершинка в этом дереве полиндромов.
Так вот, дальше у меня идея такая. Хочу перейти от И к И плюс один. Как я это сделал?
Во-первых, я проверю, не совпадает ли вот этот символ с этим. Если совпадает, то я проверю, а нельзя ли из этой вершины здесь пойти по символу С.
Если можно, то иду, а если нельзя, значит, этот полиндром нас не устраивает. Ну, дальше, получается, скачем по суффиксным ссылкам до тех пор, пока две звезды не сойдутся.
То есть и тут символ С окажется, и там переход такой будет. То есть, получается, я для каждой позиции И нашел самый длинный суффикс, который тут встречается.
Но тогда, получается, я могу в потенциальном ответе прибавить, сказать, что этот суффикс, вот мы нашли еще вхождение этого суффикса, а также всего его суффиксного пути.
То есть отложенное прибавление единички на пути от вершины до корня. Только в дереве суффиксных ссылок.
Ну, мы же тоже самое делаем, когда количество считаем.
Ну, по сути...
Можно еще раз?
Давай, погоди.
Ну, еще раз. Пусть мы для этого символа его знаем.
Тогда нам что нужно? Нам нужно перебрать все вот эти суффиксы, которые являются встречающимися тут полиндромами. Это мы делаем с помощью суффиксных ссылок.
И для каждого из них проверяем. Ну, начиная прямо сам первого.
Во-первых, верно ли, что тут не только этот суффикс существует, но из него можно пойти по символу С в дереве полиндромов?
А во-вторых, верно ли, что этот символ С еще есть здесь?
То есть, как только мы на него наткнемся, значит, вот ура, этот суффикс на месте.
То есть, получается, очевидно, этот проход тоже делается за линию.
То есть, это просто стандартный такой проход. Мы в Ахакарасике каком-нибудь или вообще где угодно будем с таким проходом сталкиваться.
То есть, это у нас будет одна из таких стандартных идей.
Поэтому я это рассказал ее.
Потому что, в принципе, как правильно было замечено, можно здесь второй метод решения этой задачи.
Давайте построим дерево полиндромов для С, дерево полиндромов для Т и запустим параллельный ДФС.
То есть, давайте для каждого дерево полиндромов С посчитаем, сколько раз он встречается, и посчитаем, сколько он в Т встречается.
Остается только запустить параллельный ДФС и для каждого решим просто добавить к ответу произведение этого на это.
Так тоже можно.
Это более лобовое решение.
Если мы дерево полиндромов строим один раз, давайте построим два.
Согласен. В принципе, согласен.
В принципе, можно сделать так, можно сделать эдак.
В общем, и так, и так.
То есть, честно говоря, в 2013 я вообще рассказал какое-то эпическое решение, которое использовала, как всегда, суффиксный массив ЛЦП.
Сейчас, как ее там, Спарсы.
Ну, вот эту стандартную технологию там всю.
И что-то там еще на них.
Потом выходит Рубинчик и рассказывает.
Ну, вся там, да, на суффиксном дереве.
Ну, не факт.
Так вот, таких примеров у самого Рубинчика в диссертации на самом деле аж несколько.
То есть, там была вот такая задача на какой-то там суперсложной олимпиаде.
Там акцептов, дай бог, чтобы один.
Подразумевалось вот такое решение.
На самом деле, с деревом полиндромов эта задача становится легко приятной.
Потому что, да.
То есть, это очень забавно.
Так что рекомендую.
Кстати, кандидатская диссертация.
Можете так в Гугле вбить.
Кандидатская диссертация.
Там Михаил Рубинчик, кандидатская диссертация.
Ну, как бы.
Ну, скажите так, половина решения, половина диссертации вот это.
То есть, там еще она была чем-то добита.
Тоже в общем-то там достаточно известна в олимпиадной среде чем-то.
Но основа, конечно, дерево полиндромов.
Так что вот такая красота.
Так что актуальный алгоритм придуман получается в 2013 году.
Так что вот.
Ну, как обычно, оказывается, что мы все это знали.
Не-не-не. Дерево полиндромов никто не знал.
2013 год как бы.
То есть, до этого никто от полиндромов так не шел.
Структура данных, конечно, имеет крайне узкую область применения.
Только когда мы говорим, ищем подстройки, являющиеся полиндромами.
Как-то, да.
Вот, конечно.
Но, то есть, мы ее.
То есть, у нас как бы смысл обсуждения ее.
Кроме того, что она просто красивая зараза.
В тем, что она нам прольет свет.
На тем, что вот мы в следующий раз будем обсуждать алгоритмы Аха-Карасик.
И, видимо, Уконен.
Почему бы нет.
И как бы в каждый из них, видимо, вот эти вот идеи.
Как-то в том или ином виде будут прослеживаться.
Ладно, на сегодня все.
