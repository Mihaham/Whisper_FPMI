Так, всем доброго дня, мы с вами продолжаем наш курс занятий. Сегодня у нас дождик, поэтому,
возможно, у нас смена антуража. Вот, мы сегодня с вами наконец-таки пойдем в БК. Мы начнем
разбирать именно такую тему под названием Low Reconstruction. Итак, значит, где мы с вами находимся,
давайте вспомним, сравнить с предыдущими частями. Где мы с вами находимся? Ну, это понятное дело,
что мы в 113 ГК находимся. Да, значит, смотрите, у нас был LWM, и по факту мы с вами уже некоторый
набор Basic блоков объединили в следы для того, чтобы минимизировать количество джампов. Николай
смотрит. Это когда мы несколько блоков объединяем в одну общую конструкцию. Да, трейсы.
То есть, у нас есть Basic блоки, мы их объединяем в трейсы, чтобы, если мы хотим куда-то прыгать,
мы могли бы прыгать именно в другое место. Хорошо, значит, опять у нас экран моргает,
но я думаю, что мы с этим ничего не сделаем. Итак, значит, вот у нас есть такой блок. Видимо,
тут нет нашей замечательной картинки, я ее забыл вставить. Вот, и мы сегодня начинаем как раз
говорить про Backend, и про Backend мы будем говорить с вами в трех контекстах. Первый контекст будет
заключаться в том, что нам нужно будет, во-первых, понять, какие наборы инструкции мы с вами используем,
и вообще здесь как раз начинает играть большую роль зависимость от той архитектуры, под которую мы
компилируем, потому что у нас есть RISC архитектуры, у нас есть CISC архитектуры, и в зависимости от
этого Backends будут сильно различаться. Даже более того, они будут различаться до такой степени,
что одну из стадий, одну из архитектур можно практически пропустить. Ну, поэтому и то же.
Ну да, есть. Есть. Ну да. Вот, то есть смотрите, у нас с вами по факту, можно сказать, что у нас есть
ER дерево для блока, либо у нас с вами есть trace. И на выходе нам нужно на самом деле займить эти
наборы инструкции Assembler, в котором число регистров в данной степени будет бесконечным. То есть мы
пока что не выходим за пределы виртуальности наших регистров. То есть наши регистры становятся
чуть менее виртуальными, чем фактически, потому что в VR мы видели с вами, что виртуальные регистры
могут иметь произвольный тип. А здесь, к сожалению, уже был тип непроизвольный. И, значит, мы с
вами разберем как раз на основе примеров тему под названием паттерны покрытия. То есть как раз,
смотрите, по факту, что у нас с вами есть. У нас, если честно, попробовать все инструкции представить,
у нас с вами будет ER дерево. Да, то есть у нас есть выражение, у нас есть присваивание и так далее. И
вот как раз в данном случае очень удобно будет снова вернуться к представлению ER в виде дерева,
потому что, как ни странно, мы сейчас будем как раз покрывать наше дерево другими маленькими кустами.
Давайте откроем страницу. Здесь есть как раз вот такой вот Assembly Instruction. Это достаточно
давний язык, 2007 год. И давайте как раз познакомимся с набором инструкций, которые здесь нам предлагают
освоить. То есть, смотрите, по факту, здесь есть у нас некоторый язык Assembler, в котором у нас с
вами инструкция состоит из некоторых из Operation Code. И дальше есть набор регистров, которые мы с вами
можем применять. То есть, у нас с вами есть операции классические, есть операции с сайд-эффектами.
Значит, и смотрите, какие у нас инструкции есть. Тут важно сразу, что если мы с вами работаем в
концепции ER, то у нас нет никакой по факту стоимости нашей инструкции. Ну, она на самом деле есть,
если мы хотим сделать какую-то оптимизацию. Здесь мы можем уже на уровне, так сказать, Assembler понять
каждую инструкцию, сколько стоит. То есть, взять, допустим, ту же самую спецификацию микропроцессора,
там, если она есть, и через нее как раз прогнать эти стоимости. Итак, давайте посмотрим на некоторые
инструкции и поймем, что они делают. Значит, здесь первая инструкция – это арифметические операции.
Давайте подумаем, почему здесь у нас стоимости, скорее всего, такие. То есть, на сложение вычитания
два, на умножение деления 5 и 10. Так-то, да, это такты процессорного времени, которые нам нужны.
Пока нет конвейерность на следующих стадиях. То есть, пока что нам ценность инструкции надо сделать.
Хорошо, то есть, вот у нас получается есть регистры, значит, у нас два операнта, мы делаем либо плюс,
либо умножить, либо минус, либо поделить. Следующая инструкция – add increment. Значит,
добавляет константное значение, и видно здесь важная особенность в том, что константу вычислить
намного проще. Да, то есть, прибавить константу сильно проще. Дальше у нас есть, значит, вот такой
язык. Опять же, он не классический ассемблер. У нас есть язык move, инструкция move a, которая позволяет
по факту получить адрес pointer, который указывает на датарегистре, и можем расшифровать наши
инструкции. То есть, у нас тоже есть инструкции по два, они стоят два такта. А дальше есть вот такая
операция, она позволяет сделать следующее. Мы загружаем значение из памяти по указателю agt
плюс c. То есть, мы передвигаем указатель pointed плюс адрес регистр, плюс сдвиг делаем на датарегистр.
Скажите, пожалуйста, в каких случаях эта операция может пригождаться. То есть, сдвиг по значению,
плюс некоторый константный сдвиг. Это инструкция load. Во-первых, для полиэструктур. Еще где?
Ну да, но то же самое в принципе.
Ну да. А, немножко другая инструкция. Ну в целом, да. Ну тут надо смотреть, кстати, под back-end,
какая из инструкций подойдет. А дальше у нас есть операция store. То есть, у нас есть, можем хранить
данные в нашем регистре сдвинутые на определенную операцию. То есть, это оператор присваивания.
И смотрите, самая тяжелая операция, которая здесь есть, это операция move memory. То есть,
сцена перемещает память из одного регистр в другой участок памяти.
Ну да, вот в принципе сверху и видно, что она выражается через две таких.
Не-не-не, она двигает один the word. Она просто одно слово двигает.
Ну да. Ну пока что мы работаем с интами. У нас пока что все, что есть, это инты. Так,
хорошо. А теперь смотрите, важная особенность этого языка. Если у нас здесь conditional jumper.
Видно, что здесь jump не conditional. То есть, мы можем прыгнуть. А? То есть, мы можем...
conditional jumper имеется, который разбегается на два basic блока. То есть, если у нас в VR был
conditional jump в две метки, то есть, либо с веткой true, либо с веткой false, то здесь jump идет только,
если определенное условие выполнено. То есть, как раз для этого мы и делали trace, чтобы мы
отклонялись от основного trace. И соответственно conditional jump будет весить меньше, чем классический
jump. То есть, получается, что мы экономим инструкцию. Так, ну и простой оператор go to, оператор jump,
он позволяет прыгнуть как раз в определенное значение. Следующая инструкция, которая у нас
с вами есть, это инструкция call. То есть, мы по факту перемещаемся в метку m и при этом запоминаем
return location. То есть, грубо говоря, это вызов функции. Вот оно у нас стоит пять поинтов. Да, то есть,
как бы вызвать функцию иногда, конечно, полезно, но иногда полезно ее заинлайнить, чтобы, собственно,
у нас не было вот таких вот операций. Значит, return будет стоить 3. И установка метки будет стоить
нулечков. Ну, на самом деле, да. Ну, почему он... Ну, в смысле два кола. Ну, да. Ну, понятно,
что это... А? Ну, это да. Ну, в целом, вот такой язык. Вот. Ну, и, собственно, здесь указывается,
допустим, для этого языка, типа какой размер слова. То есть, у нас размер слова всегда равен единичке.
То есть, здесь у нас по факту есть чара. Да, ну, понятно, что для интов это тоже можно адаптировать и
посмотреть, сколько у нас стоимость. Значит, у нас есть дейты регистра, у нас есть адресные
регистры. Да, то есть, видите, есть развлечение. И есть программа каунта. Есть указатель нас так.
То есть, в принципе, мы можем обращаться к этим. Так, по вот этой спецификации все понятно? А теперь
давайте перерисуем это все в виде дерева. Значит, в виде дерева это будет выглядеть вот таким вот
образом. То есть, у нас есть операция add, и мы видим, что это как раз у нас add-оператор. То есть,
у него есть вершина плюсик, и снизу он подцепляет два других оператора. А оператор mull это оператор
перемножения. То есть, у нас есть перемножение двух операторов. Оператор add-i, он является вот таким.
То есть, у нас есть Rit равно Rgt плюс c. И, соответственно, у нас получается с вами три возможных варианта действий.
Дальше, операция load, она у нас может редуцироваться. Значит, это либо Rit равно m от mem. То есть, это как
раз вот эти вот операции, помните, mem, move и так далее, которые были в VR. То есть, это то, как эти
инструкции будут у нас транслироваться в VR. Значит, это либо mem от Rit плюс const, либо mem const
плюс Rit, либо mem от const, то есть, в качестве регистра мы игнорируем информацию, либо просто оператор mem.
Соответственно, оператор store, видно, что в VR дереве стоит достаточно дорого. То есть, как бы, нам нужно
собственно сделать mem, потом сделать move. То есть, он стоит 10 очков. И move mem это move от
move mem. То есть, в принципе, наша цель, первая, которая заключается в покрытии инструкций,
это взять все наши конструкции промежуточного представления, взять все наши конструкции
ассемблера, которые у нас есть, и переложить, попытаться построить их в VR дереве. Да, вот чем мы
должны в целом заниматься на этой стадии. А дальше, если у нас есть стоимость инструкций,
то мы можем выполнять разные покрытия. Вот смотрите, здесь есть некоторый пример того, каким
образом мы можем превратить вот этот вот набор инструкций. То есть, у нас, как бы, есть вот такое VR
дерево. Это у нас AssignIndexStatement. То есть, мы говорим, что у нас а и тому нужно присвоить какое-то значение
х. Давайте посмотрим на эти два разбиения. Собственно, в первом разбиении мы берем frame
pointer и получаем значение регистра на константу а. То есть, это наш массив. То есть, первая
операция здесь это load. Вот она, это вторая инструкция. После этого мы должны с вами сделать
следующее. К константу сделать четвертую инструкцию, которая прибавит к R0 значение 4. То есть,
возьмем значение нашего указатель. Дальше, значит, мы должны будем перемножить R1 и R2. Да, то есть,
вот так вот, вот так. Да, R0 это регистр, в котором всегда 0 сидит. Константа 0. Опять же,
взятия константа. Просто вот такой R. Интересно. Дальше мы берем перемножение. Дальше мы берем
сложение. То есть, R1 это R1 плюс R2. То есть, вот он оператор. После этого вот это вот у нас
получается значение нашего элемента массива. Дальше мы загружаем значение нашего значения
нашего x и делаем операцию store. То есть, мы прямо берем и присваиваем значение нашему массиву. То
есть, вот такая инструкция. Мы можем это переписать по-другому и сказать, что давайте вместо того,
чтобы сделать операцию load по хрейнфоитору плюс x, мы сделаем сразу операцию addE. То есть,
прибавим это значение по константе, а потом сделаем moveMe. Попрос. Как вы думаете,
какая из операций стоит дороже? Какое из покрытий? То есть, у нас получается,
для каждого объекта и R у нас может быть, каждого дерева и R у нас может быть несколько покрытий
ассамблярными инструкциями. Значит, у нас есть loadStore и addE moveM.
Сделано. Так, давайте оценивать. Как мы это оценим? Нам нужно посмотреть на инструкции.
Так, давайте поймем. Сколько у нас load стоит?
Store, moveM. А здесь addE неважно сколько стоит, это любое всё больше нуля и мы видим с вами,
что нам выгоднее не использовать moveNem, а использовать addE и констант. Хорошо. То есть,
вот такое вот у нас покрытие получилось. И здесь возникает некоторое понятие. Смотрите,
у нас есть код, у нас есть дерево и у нас может быть несколько покрытий. Соответственно,
мы можем попробовать склассифицировать эти покрытия. Каким образом мы можем склассифицировать?
Значит, смотрите, здесь делается следующая вещь. Мы с вами можем построить наилучшее покрытие. То
есть, что означает наилучшее покрытие? Это покрытие, которое имеет наименьший вес. Дальше,
оптимальное покрытие. Это покрытие, в котором любые два соседних паттерна не могут быть
преобразованы паттерном с меньшей суммой весов. Вот, кстати, если мы воспользуемся вот этой
инструкцией addE и moveMem по сравнению с load и store, то это будет, смотрите, это будет не оптимальным и
не оптимальным покрытием и не наилучшим покрытием. Почему вот эта инструкция не будет наилучшим покрытием?
Ну, вот, moveMem и addE. Ну, потому что есть инструкция, которая весит меньший вес.
Ну, а почему оно не будет оптимальным? А? А оно не будет оптимальным, посмотри, ровно по вот этой причине,
я сейчас помечу экране. Если бы это покрытие было бы не оптимальным, то бы мы не могли взять вот
эти вот две инструкции, которые я обвожу, да, 9 и 8, и преобразовать их в набор инструкций с меньшим
весом. Вот конкретно две соседних. А здесь мы как раз, смотрите, берем две соседних инструкции и
как раз распиливаем их по-другому. То есть если бы такую вот эту инструкцию нельзя было бы склеить
и снова расклеить с меньшим весом, то такая конструкция была бы оптимальной. Вот, и обычно,
когда мы строим компилятор, мы строим все-таки оптимальное покрытие, а не наилучшее. Почему,
как вы думаете? Ну да, ее нельзя решить достаточно быстро, поэтому мы стараемся хоть какое-то покрытие
найти, ну, грубо говоря, чтобы у нас каких-то прямо очевидных оптимизаций не возникало. Вот,
поэтому мы будем искать как раз с вами оптимальное покрытие. Так, хорошо, мы строим оптимальное
покрытие, и здесь как раз возникает алгоритм, который начинает с следующего. Это алгоритм
максимального покрытия. Он строит оптимальное покрытие, и он называется, по факту, является жадным
алгоритмом. То есть что мы делаем? Мы начинаем с корня дерева, добавляем ее в очередь, и дальше
делаем следующее. Мы пытаемся выбрать паттерн с наибольшим количеством вершин, при этом при
равенстве количестве вершин выбираем произволь. Вот, и дальше этот паттерн, узлы этого дочернего
процесса, добавляем в очередь. Вот, в этом очередь можно заменить на рекурсивный выход.
Вот, при этом можно заметить в целом, что такое дерево сойдет. То есть мы как бы идем не от корня
к вершине, а не от вершины к корню, а от корня к вершине. Соответственно, если у нас есть оптимальный
набор инструкций, то так или иначе у нас дерево сойдется в какой-то момент времени. Единственное,
сразу тут нужно сказать, что этот алгоритм в принципе может обладать нерекурсивным свойств,
свойств именно связанных с откатом, потому что мы в принципе можем с вами дойти до определенного
момента и дальше не подниматься для этого выхода. Вот, собственно, это вот алгоритм, который
позволяет найти оптимальное покрытие. Понятен? То есть тут тупой жадный алгоритм. Мы пытаемся
присоединиться сверху вниз. Хорошо, другой вариант это динамическое программирование. И что
позволяет сделать динамическое программирование? Динамическое программирование позволяет найти
наилучшее покрытие. То есть как бы он идет снизу вверх. И идея такая, что мы по факту можем с вами
сказать следующее. Давайте в вершине каждого дерева будем хранить паттерн с его детьми. То
есть сколько занимает сейчас в текущий момент покрытие оптимальный паттерн. И дальше мы что с
вами делаем? Мы говорим, что вес покрытия паттерн, потенциал покрытия паттерна, это значит его значение,
плюс значения, которые висят на груздах его детей. Понятно, что если у нас какой-то паттерн не
покрывается дочерним, то мы считаем, что вес этого паттерна бесконечный. И в итоге мы с вами
выбираем покрытие наименьшего веса. По идее оно является наилучшим, но по факту нужно смотреть
аккуратно с набором инструкций. Потому что, грубо говоря, несмотря на то, что у нас есть линейные
инструкции, то что делать с фи-инструкциями это хороший вопрос. Потому что нам нужно взять
определенные значения. И вот такие инструкции, по которых у нас код не является линейным,
как его покрывать? Хороший вопрос. Поэтому если у вас фи-инструкции нет, то динамическое
программирование подходит. Если у нас нету фи-инструкции, точнее, наоборот, если у нас
есть фи-инструкция, то, к сожалению, этот алгоритм может не работать. А, в принципе, подход,
который берет сверху вниз, он позволяет получить правильное значение. Так, смотрите, здесь как
раз показывается алгоритм, который заключается в том, что у нас с вами есть вот такой оперант.
Это у нас алгоритм, который идет связанный именно с дочерним снизу вверх. Итак, смотрите,
значит, первый способ, которым мы можем двигаться, это мы берем, складываем что-то
со константы, мы получаем вес один. При этом лифт-кост тоже будет один. То есть взятие константа
это тоже один такт. И второй шаг, который мы можем сделать, то есть мы оцениваем значение
операнда плюс. Значение операнда плюс это значение суммы операнда, которое у нас имеется. И вот этот
плюс он как раз нам дает в итоге значение либо три, если мы возьмем add и возьмем отдельно две
константы, либо add и, когда мы говорим, что мы можем прибавить какое-то число заранее. Вот,
в итоге у нас получается вес либо три, либо два, либо два. Соответственно, мем дальше это
инструкция load. И тут все зависит на самом деле от того, какой load мы сделаем. Мы можем сделать
load тупой, который загрузит определенные значения только. Мы можем сделать умнее. Мы можем взять
операцию load, которая берет значение и складывает его с константой. То есть это классический оператор
load. А здесь у нас как раз регистр, который позволяет взять значение с константой. То есть значение
взять регистр с константой это единичка. В итоге у нас получается, так или иначе, total
cost оптимален тогда, когда мы берем мем плюс констант. Да, сразу скажу, что здесь style cost по факту не
один, если мы берем код a10, потому что мы сказали, что load у нас занимает 10 операций. То есть вот
явно таким образом поднимаясь снизу вверх, мы можем увидеть инструкции, которые нам нужны.
Вот так. Понятен ли этот алгоритм? Поднимаемся снизу вверх и строим наше дерево. Вот его недостатки.
Хорошо, давайте поговорим про следующее. Паттерны как правила в грамматике. То есть
иногда правила разбора полезно задавать как определенные правила в грамматике, но тогда нам
нужно интеррироваться по правилам и это кажется не оптимально. Но в целом, если у вас грамматика
плюс-минус однозначная, можно использовать безон. Но я думаю, что вот если внезапно возникнет вот
такое фанатичное правило, давайте воспользуемся парсером правил ассемблера и используем для
instruction-selection безон. Лучше это откинуть нафиг. Тем более первая недозначность,
которую мы поймем, она нам не даст результат. Вот давайте как раз вот с учетом этого попробуем
оценить сложность алгоритма покрытия. Значит, здесь математический факт. Пусть у нас имеется
т шаблонов и всего у нас имеется т шаблонов. Вот в наше правило, если мы говорим про язык,
который мы говорили, там порядка 20 шаблонов. При этом каждый паттерн в среднем содержит
кани листовых узлов, то есть ка точек, к которому мы можем привязаться. При этом давайте оценим.
Пусть у нас понятно, что каждый паттерн нужно сделать в соответствии ему какому-то примеру.
И предположим, что к штрих это количество узлов, которые необходимо для того, чтобы
сопоставить наш шаблон. То есть понять, подходит нам этот шаблон или не подходит.
И будем считать, что у нас в среднем т штрих паттернов подходит каждому узлу. Тогда давайте
оценим сложность, которая у нас возникает в алгоритме максимального покрытия. Смотрите,
всего в дереве N узлов. Каждый из узлов уменьшает, грубо говоря, в среднем оставляет где-то
К. Почему нам надо найти N делительно K узлов? Ну да, не листовые узлы, это именно те узлы,
которые внутри правила содержатся. То есть, образно говоря, если мы возьмем наши правила,
где тряпки? Смотрите.
Он для вот этого примера К равняется 3. То есть, вот он раз не листовый узел, вот он два не
листовый узел, вот он три не листовый узел. Листовый узел, это тот узел,
которым мы можем подцепить правила. Ответственно, смотрите, у нас всего N узлов,
К не листовых, то есть каждый раз у нас отсекается пока узлов. В итоге количество
узлов равняется N делительно K. То есть, количество раз, которым нам нужно будет мачить наш шаблон,
будет N делительно K. При этом, каждый узел у нас будет обрабатываться за K штрих на T
штрих операции. Почему? Потому что у нас с вами количество узлов, которые необходимо проверить
для этого шаблона, это K штрих, который нам для каждого паттерна необходимо проверить. При
этом, у нас в среднем T штрих, узлов подходят каждому узлу. Тут в итоге получается, что нам как бы
нужно найти эти шаблоны. Тут на самом деле, может быть даже на T. Ну, где-то вот такая если точка,
то есть вот эта константа у нас будет зашиваться. В итоге, сложность нашего алгоритма получается
K штрих на T штрих, потому что нам надо среди всех этих паттерн найти максимальные по количеству вершин.
А умножить на N поделить на K. То есть как бы мы с вами экономим получается одну кат операции для этой
штуки. Ну, а если мы делаем классическое динамическое программирование, нам необходимо
просмотреть все вершины. У нас точка будет именно в K раз больше. Вот такой вот у нас получается
результат. Вот такая интересная вещь. Ну, в целом, этот алгоритм как раз можно использовать для
своих задач. Так, понятно ли оценка этой точки? Ну, то есть, ну да, ну то есть, важно посмотреть
именно какое количество решений у нас есть для каждого уравнения. Вот, значит, и теперь мы как
раз с вами, когда осваиваем эту всю вещь, нам нужно поговорить с вами детально про
архитектуры процессоров. Собственно, есть две классические архитектуры. Первая это RISC, это
Reduced Instruction Set Computer. Это инструкция быстрая, приблизительно одинаковой стоимости,
но работа с памятью только через операцию LoadStore. Да, и при этом инструкция обычно трех адресной.
Пример таких архитектур это ARM. Значит, если мы говорим про RISC архитектуры, которая комплекс
Instruction Set Computer, есть инструкция разной сложности, разного типа доступа к регистрам данным.
Инструкция, кстати, обычно двух адресные, и пример этого x86.
Ну да, и вообще этот процессор изначально придумали для калькулятора. Да, таким образом,
что сколько тут? Раз, два, три, четыре, пять компьютеров, да? Нет, у меня не калькулятор. Да,
у меня Mac, у меня Mac на M1. Ну, посмотрим в примере как конструкция. Да, Reduced Instruction Set Computer.
Вот, значит, в чем особенность RISC? Архитектуру? Да, согласен. Кто? А что?
Ну да. Так, извините. Так, извините, куда изобрелась? Там же был забавный эффект,
что классический пример того, для каких целей на самом деле использовался PlayStation 3 в свое время
и PlayStation 4. Фермы большие. Да, да, да, да, да. Да, да, да, да, да. Вот, поэтому тоже особенность
есть. Особенно это Николай знает. Особенность приставок консолей. Вот, значит, в RISC что у нас
есть? У нас есть больше регистров. Дальше у нас есть арифитические инструкции между регистрами,
инструкции трехадресные и low attestor в режиме M от регистр плюс const и результат на одну инструкцию.
Я предлагаю какой-нибудь код скомпилировать. Главное, чтобы петличка не падала. Итак,
значит, какой код скомпилируем? Блин, hello world неинтересно. А? Ага. Давайте это,
какой-нибудь я возьму. Да, я, кстати, наконец-таки запушил код. Ветку 2024. Пока не смерзнул с мастером.
Да, да, да. Так, давайте, что мы именно посмотрим? Я предлагаю
эта неинтересная функция. Давайте if и начнем. А вот он, наш любимый if. Идем мы с вами в Godbolt.
Это сайт Compilers Instructor. Да. О, кстати, у меня есть код. Прекрасно. Так,
какой компилятор будем использовать? Arm gcc я предлагаю использовать.
Так, вот у нас инструкция на арме. Давайте посмотрим. Да, нет, это функция square, вот это вот.
У нас arm v1. Ну а что тут? Есть разные версии. А, вот да, действительно. У меня было включена опция
Вот у нас две функции. Square, 3nta. Что мы здесь видим? Да, здесь, кстати, есть трансляция. Вот он if, да, и вот у нас как раз есть LDR, да.
LDR, что у нас делать? Он загружает регистр. То есть у нас получается, вот это классическая операция load. То есть у нас есть как раз R7 и $12, да, то есть это у нас, кстати,
что такое $12? Скорее всего сдвиг. Давайте поймем. Значит, вот он у нас получился. Вот это у нас, кстати, стекпоинтер. Решетка 0, значит, дальше R0 и решетка 12. Да, вот, смотрите, кстати, обращу внимание,
не зная интересный момент, заключается в том, что кажется, что операция пишется в обратном порядке. Потому что R3 это у нас
сравнивается с константой 10.
Вот, то есть мы...
Ну вот, да. То есть, смотрите, дальше сравнится 10 и дальше есть B на E. Да, то есть мы прыгаем, если у нас значение not equal. А ведь? Да, if not equal. То есть, смотрите, у нас trace,
обращу внимание, как настроен. То есть мы по умолчанию будем заходить внутри цикла, а не вне цикла. Ой, внутри условия, а не вне условия. Да, то есть как бы if and else лучше контролировать вот
таким образом. Значит, дальше у нас идет load. Загружаем мы с вами еще раз значение, решетка 8. Я, правда, не понимаю, почему он грузит несколько... А, тут уже как раз, видите,
используется разный набор регистров. Вопрос, а почему он это не оптимизирует? Нет. Что-то включить?
Да, и что возвращать-то будем?
Да, internal.
Ага. Спасибо.
Да, кстати, the conditional instruction. То есть, видите, тут есть даже if-then оператор.
Да, конечно, он делает следующее. Up to 4 following construction conditionals. А, он включает возможность movelt использовать регистр.
Да.
Смотрите, у нас же фишка в том, что b больше c.
Ну да, да.
Так, минус o3, давайте посмотрим. Ну да, да, да. Нет, тут уже некуда. А вот o1, кстати. Ну, то есть, смотрите, как раз мы сравним значение r0, да, и значение, кстати, передается по регистрам. То есть, r1, r2 это регистры, которые передаются в аргументы функции. Да, кстати.
Ну да, да.
Так, кстати, вопрос. Сколько регистров он может принимать? Давайте проверим.
Так, ну вот, смотрите, я добавил 5 аргументов.
Смотрите, значит, branch for equal l4. То есть, видите, здесь он уже создал новую метку. Значит, дальше он сравнит r1, r2. Если получается less, то мы прыгаем в ветку l3. Где она? А, вот она. То есть, это l3. То есть, здесь все окей.
А что здесь происходит? Да, да, да. И смотрите, что у нас происходит. Мы загружаем регистр, да, r0 и sp это stack pointer.
Да, сверху stack. То есть, видите, переменная e уже нам прилетает со stack. То есть, как бы до четырех аргументов, а дальше уже аргументы берутся со stack. Вот такая особенность. То есть, это как раз у нас ARM, да, и видно, что здесь количество инструкций очень большое.
Так, на o3.
Да, он уже примерно со stack использует. Что, на MIPS посмотрим? Где тут MIPS? MIPS GCC тоже используем, да?
Так, давайте с оптимизацией.
А 4 это что?
Ну, это да, да, да. Сейчас сравнится. Прыгаем, да, в l5, а дальше что это? SLT. Да, метки какие-то. Ну, вообще видно, что инструкции такие. Интересные. То есть, в зависимости от бэкэнта у нас все...
Да, да, да, да, да. Вот это да.
Так, ну что? Осталось CISC посмотреть архитектуру. Давайте как раз про нее поговорим. Что заключается в CISC? В CISC у нас меньше регистров. Регистры при этом поделены на разные классы регистров.
Вот, аэропедические операции могут работать как с памятой, так и с регистрами. Двухадресная форма. То есть, здесь у нас было трехадресная.
Давайте еще раз покажу. То есть, мы идем с вами на... куда? На ARM. Давайте вернемся. Вот, да. То есть, у нас трехадресная инструкция есть. Двухадресная и трехадресная.
Здесь двухадресная инструкция, но здесь есть побочные эффекты. Допустим, к примеру, побочный эффект относится к автоинкарминенту адресов. То есть, специальная переменная, которая нужна.
И, кстати, сразу скажу, что видно, тут вот есть это. Типа, вот здесь вот как раз все было заточено под x86 изначально. То есть, потому что здесь есть программа Counter.
Так, ну что, посмотрим пример этого кода на этом. А как x86, наверное.
Давайте его один. Здесь он на уровне. Так, смотрите, давайте читать. У нас есть регистры EIX, EBX.
То есть, видно, что у нас инструкции есть разного класса. Здесь мы копируем регистр. Дальше, значит, сравниваем значение EDE с десяткой.
И дальше прыгаем. То есть, jump equal в L4. Если нет, то return. Да, мы за этим сэйвили все в EIX. То есть, это аргумент возвращения.
Дальше, что мы делаем? Jump equal. А, стоп, а где тут сравнение B больше C?
А, все, понял. То есть, он сначала вычислил результаты выражений, да, получается?
Сейчас, я что-то не понимаю.
А в ECXD лежит или в R8D?
Я что-то не понял. А, понятно.
Да, вот это вот D+. Так, стоп, сейчас получается.
В общем, видно, что здесь, как говорится, несколько оптимизаций. И здесь как раз по операциям видно, что мы очень сильно экономим на количестве регистров.
У нас есть у регистров разные классы, да, и, собственно, да. То есть, видите, у нас прямо особенности идут под определенные инструкции.
Вот, значит, давайте скажем что. Давайте попробуем решить некоторые проблемы сейчас на текущей стадии.
Значит, как ни странно, на текущей стадии у нас происходит следующее. Первое, мало регистров, они у нас виртуальные, пока что мы не паримся с проблемой малого числа регистров.
Да, и регистры распределяются в разные операнты. Собственно, если мы хотим использовать какой-нибудь оператор T1, T2 на T3, то мы можем сделать следующее.
Собственно, сделать оперант MOV EIX T2, да, потом MOV EIX T3, то есть взять значение операнта, и потом переместить значение T1 в EIX.
Сразу скажу, что здесь T1, T2 и T3 это виртуальные регистры. То есть они пока что самым никаким образом не влияют.
Вот, собственно, двухадресные инструкции, если у нас есть, то, собственно, тоже перемещаем значение регистров дальше складом.
То есть видно, что у нас идет большое количество оперантов MOV, которые нам необходимо обеспечивать.
Вот, ну и репетические операции у нас в ЦИСКи могут обращаться к памяти. То есть наша цель будет попытаться именно отслеживать команды, которые делают лишние операции MOV.
Да, да, тут именно такие вот вещи. Так, побочные эффекты. Собственно, у ЦИСК-арфитектуры бывают сайд-эффекты.
Вот, ну и, собственно, если мы говорим про сайд-эффекты,
то сейчас на современных арфитектурах их практически, господи, вот.
Ну да, от всех этих нужно.
Ну вот.
Ну вот, вот, вот, как бы, ну, на современных арфитектурах их очень мало, вот, поэтому, как бы,
вот, поэтому их можно использовать на сайд-эффекты.
Так, кстати, вот, раз у нас есть такая возможность, давайте посмотрим, собственно, как работает X64-Силанг.
Мы тоже можем посмотреть.
Да, да, да, да, да.
Ну вот, да, да, да, да.
Да, то есть все.
Так, РЦХ плюс Р8.
А?
Господи.
Да, то есть КМП, ЕДХ, ЕДХ, собственно, и если у нас значение не равно, то мы перемещаем указатель А.
То есть здесь видно, в чем особенность, здесь еще порядок конструкции меняется.
Ну вот, в отличие от ARMA, да.
Ух, ё.
Ну, рейск архитектуры.
Да, да, да, значит, добавляет значение V4, V3.
Кстати, он тоже их переставил.
Ну, да, да, да.
Кстати, обращу внимание, что теперь он D плюс E, типа, посчитал.
То есть он, типа, вместил их.
Ну да.
Дальше, значит, мы сравним V1 и V2.
Что такое V1 и V2?
B и C, да.
А дальше мы говорим следующее.
Что если Conditions True, Conditions Selects в райс.
А вот мы и поняли, как эти инструкции можно использовать.
Я сейчас начну.
Что?
Да.
Я пытаюсь быть шокер.
Ясно, наверное, но мы пишем первый пол, а потом destination.
Если пол, то второй пол, значит, destination.
Так, я еще и задал вопрос, что не destination.
Ну, destination первого и Conditions, а, Conditions конце.
А, Conditions 1 и 2.
А, все.
Ага.
So, plane, V4 или там 2.
Да, да, да, да.
То есть, что у нас получается?
В общем, весело.
Ну, что, по традиции, как говорится, уже.
Да, да, да, да, да.
Ну что, попробуем скомпилировать вот эту штуку.
Давайте рубрика эксперимента.
Посмотрим, что скомпилирует мой маг.
Так, Selang, Minus S.
О, Господи, как же он долго компилировал.
А, я забыл опцию оптимизации включить.
Да, да, да.
Ну, не знаю, мне кажется, что он то же самое сделал.
Молодец.
Aram Selang.
Да, да, да, да.
Давайте посмотрим, как структурам обращаться.
Что-то, где у нас?
Массивы, да?
Господи, и как это написать?
Сейчас давайте подумаем.
Так, идём сюда, идём сюда.
Всё, давайте int.
Как передать массив?
А?
Так, вот он код, кстати.
Значит, давайте посмотрим, что у нас тут есть.
Да, да, да.
То есть, что он сделал?
Он сделал jump if not equal.
Да, то есть, смотрите, что тут происходит.
Мы, значит, load-регистр x0x9, да?
А, подождите.
По-моему, он сделал следующую вещь.
Кстати, интересно, что будет, если сделать 100.
То же самое, да?
А почему он x0x9 назвал их?
Ну ладно, видимо, в обратном порядке.
Ну да, да, да.
То есть, у нас всегда, кстати, есть ещё регистры, которые
необходимо именно сохранять.
А?
Чего, long?
Так, сейчас подключу зарядник.
То есть, смотрите, в чём особенность?
Особенность в том, что он прибавляет не один, но
прибавляет по восемь.
Да, прибавляет size-ов для того, чтобы как раз к нему
обратиться.
А?
А потому что это 4-битная архитектура.
Размер long-а совпадает с размером слова.
Тоже, тоже.
Да, кстати, кстати, был забавный момент, что в какой-то
проекте мы что-то делали под Arduino, и мы в качестве
каунтера использовали, счётчика времени использовали
А там им будут ввадьны, да.
Чё?
Чё он сделал, он цикл развернул?
Мочесное.
Какой?
Ну да, да, да, да, да.
Вот они, кстати, принимаемые значения, x0 плюс 64, x0, x0, x0 плюс 64.
Да.
А что такое в один точке?
4 plus 4 plus 2, да?
Ну, мощный.
Так, кентам вернёмся?
Ну, микрокод как-нибудь.
Да, а v1.2 это у нас...
А, развернутые, всё.
То есть на самом деле современные процессоры умеют даже вот такое, то есть
векторные инструкции, да.
Эх, я боюсь, давайте посмотрим.
Что он взял?
XMM, да?
Да.
Да, то есть видно, что все инструкции так или иначе пытаются...
Вот, в общем, вот такие вот интересные вещи, да.
Понятно, что именно здесь важная особенность...
А?
Охё!
А?
Ну, кстати...
Кстати, не только в этом...
Это где?
Ага.
Ну да, кстати, как ни странно, вот если код...
Вернуться к коду на куде...
Там есть вот такая инструкция, причём она делает это векторно внутри одного варпа,
то есть внутри одного сингла инструкции...
А?
Операция называется shuffle down.
Синг.
Во!
Вот так она работает.
Да, да, да, да.
Ну, shuffle down, она двигает регистр на 4 влево.
Ну, она...
Не, ну тут тоже есть shuffle инструкция.
То есть они все, я так или иначе, shuffle инструкцию,
но скорее всего по наиде с x86.
Вот, в общем, вот такие вот интересные вещи.
То есть что у нас есть?
У нас есть вами риск архитектуры, у нас есть вами циск архитектуры.
Собственно, если вдруг кто-то хочет реализовывать бэк-энд,
можно выбирать любую архитектуру по желанию.
Понятно, что...
Кстати, как вы думаете, под какой бэк-энд проще писать код?
По-дармовски или по...
Ой, под циск или под риск?
Под риск.
Да, да, да, да.
Семблерного файла.
Да, конечно, под риск всегда проще.
Но, опять же, особенность в том, что именно с точки зрения железа
риск архитектуры работает сильно капризней.
Для того, чтобы сделать эту риск архитектуры рабочей,
нужно сильно постараться.
Все еще подъезжают в оперативе, а не в реглистпо,
а на единый мультик копировать на одной граффе, а потом
копировать обратно.
Не, я говорю не про то, как этот код писать, а про то, что...
Ага, ну да.
Ну, это тоже есть такое.
Не, просто, если честно говорить, то армовские процессоры, они просто
с точки зрения неосвоенности архитектуры, они могут работать либо
сильно энергоэффективно, вот те же самые маки, либо наоборот.
Жрать энергии как не в себя.
Ну да.
И, как ни странно, тоже можно посмотреть.
Я, кстати, сделаю эту вещь.
У меня есть доступ к FPGA одной.
Я, наверное, смогу сказать, какая там архитектура.
Да, чтобы вы понимали, что такое FPGA.
Это специальная плата, которую можно самостоятельно запрограммировать.
Вот.
И, собственно, выполнять разные операции.
Именно зачастую под этим.
То есть она у меня там используется для...
Ну, не совсем даже.
То есть можно самому запрограммировать чипы, и именно при помощи
него выполнять операции.
Просто там как раз всякие биоинформатические выравнивания
происходят, просто говоря, на геном.
Разработчики, конечно, утверждают, что их тул работает
в разы быстрее.
Но, типа...
Ну, чтобы честно сказать, там, грубо говоря, чипы,
на котором, типа, 20 ядер заявлено,
работают где-то два раза быстрее, чем...
Сейчас дайте мне не соврать.
По-моему, где-то чем 100-ядерный компьютер.
А? 100-ядерный ЦПУ.
Нет, 100-ядер X86.
Ну, это именно кластеры.
То есть это именно СХД.
То есть это вот как берется, все на слу уровне запускается.
Ну и поехали.
Не, ну в целом такие системы есть там.
Просто берут процессоры, объединяют их в несколько...
Да, да, да, да.
В общем, вот такая вот вещь.
Давайте сразу затравку на следующий раз.
Больше мы с вами рассматривали всякие особенности,
связанные с ассемблером.
То есть вы поняли, что нам нужно делать большое количество
виртуальных регистров.
А теперь будет вопрос следующий.
Как эти виртуальные регистры
переправить в обычные регистры?
И здесь как раз мы, так сказать,
эту тему можно было рассматривать на уровне оптимизации.
На теме, связанном с оптимизациями.
Но мы к этой теме как раз приступим на уровне как раз выделения регистров.
Да, то есть это как раз грав потоку управления.
Нам как раз нужно будет его посмотреть.
Да, то есть будем смотреть, кстати,
и вообще, если смотреть на тему,
которая будет этому посвящена,
это алгоритмы раскраски на графах.
То есть нам нужно будет построить граф пересечений
и граф конфликтов,
и его раскрасить в определенные цвета.
Все, наверное, на этом даже все.
Давайте вопрос.
Вопрос.
Окей.
Да, вопросов нет.
Ладно, тогда
восстанавливаем все всем,
кто смотрит в Ютубе.
Всем хорошего дня.
