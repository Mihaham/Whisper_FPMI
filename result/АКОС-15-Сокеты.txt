Так, ладно, мы начинаем тогда.
Ладно, надеюсь, вы все видите и не уснете при этом.
Тема сегодняшнего занятия это продолжение уже не
только межпроцессного взаимодействия, но и еще и сетевой взаимодействия.
То есть сокеты.
Давайте вспомним, какие вообще вы помните способы межпроцессного взаимодействия.
Тупой наивный способ это обычные файлы.
Не буду о них устанавливаться.
Можно делать какие-то разделяемые области памяти с помощью механизма МАП.
Можно использовать каналы как именованные, так и неименованные.
Но у всех этих способов, связанных с каналами, есть существенный недостаток.
Что у Пайпа, что у Фифо.
Что это за недостаток такой? Очень существенный.
Но буфер-то ладно, мы заполнили, прочитали, освободили.
Это нормальная история. Самое-то главное ограничение у каналов.
Да, мы нормально можем организовать взаимодействие только двух процессов, но не больше.
Если вам нужно организовать какой-то процесс, который может работать с большим количеством подключений, то здесь каналы не подойдут.
То есть на самом деле вы можете запустить несколько дочерних процессов, используя один и тот же Фифо или один и тот же Пайп.
Но это сильно вам не поможет, потому что данные у вас будут просто перемешиваться.
И вы не знаете никогда, от кого именно какую часть данных вы получили.
И для взаимодействия нескольких процессов между собой, когда их больше двух, каналы уже не подходят.
И для этого используется еще один способ межпроцессного взаимодействия, который называется сокеты.
Что такое сокет?
Это файл-дискрептор, который в отличие от каналов предназначен одновременно и для чтения, и для записи.
То есть он открыт сразу в обе стороны и предназначен для двустороннего взаимодействия.
При этом при взаимодействии нескольких процессов нужно выбрать один главный процесс, который мы дальше будем называть сервером.
Слово сервер, наверное, знакомо. Это что-то, к чему можно подключиться.
Все остальные процессы, которых может быть от нуля и больше, будут называться клиентами.
Сервер что должен сделать для организации межпроцессного взаимодействия?
Он должен объявить некоторое имя, по которому его смогут найти.
Имена бывают самые разные.
Если проводить аналогию с какими-нибудь именованными каналами FIFO, то есть еще один специальный тип файла под названием UnixSocket.
UnixSocket это некоторый файл, который можно не совсем открыть, который можно подключиться, используя механизм сокетов.
Если вы знаете имя этого файла, если у вас есть права доступа к этому файлу, то есть поскольку файл там можно поставить разные права доступа,
у файла может быть владелец, группа владельцев и так далее, вы можете организовать межпроцессные взаимодействия.
Еще один способ адресации — это использовать пару чисел.
Числа могут быть либо 128-битными, либо 32-битными.
Одно число — это адрес, и второе число 16-битное — номер порта.
Вот адрес компьютера плюс номер порта однозначно определяют какой-то процесс, но уже в данном случае не только на локальном машине, но на каком-то произвольном компьютере.
То есть механизм сокетов очень легко масштабируется с локальной историей на сетевую.
И есть еще третий тип адресации, который присутствует во всех UNIX-подобных системах.
На самом деле их чуть больше, но они уже являются платформа-зависимыми.
Это низкоуровненный способ взаимодействия, где адресом является уникальный дезификатор вашей сетевой платы, куда вы можете, имея права рута, писать что-то напрямую.
Создается socket, как ни странно, систем вызовом, который тоже называется socket.
Что делает socket? Он просто создает файловый дискриптор, которым пока вы ничего не можете делать.
То есть он занимает место в пространстве файловых дискрипторов точно так же, как при открытии файлов и при создании файловых дискрипторов.
Вы можете получить ошибку при создании, что вы исчерпали лимит на количество файловых дискрипторов.
И что необходимо указать при создании сокета?
Во-первых, нужно указать, какой тип адресации вы в дальнейшем будете использовать.
То есть address family, либо UNIX файлы, либо интернет.
Причем интернет бывает двух видов.
Адресация IPv4 классическая, которую вас учили везде, в том числе, наверное, и в школе.
И адресация IPv6, где адреса имеют размер 16 байт.
И сокеты у нас могут использоваться в двух разных режимах.
Один режим – это потоковая передача данных в две стороны.
То есть сокет – это файловый дискрептор, доступный и для чтения, и для записи.
Гарантируется последовательность данных, которые вы записываете и читаете,
и гарантируется целостность этих данных.
То есть если у вас данные закончились, вы об этом обязательно узнаете.
Если возникнет ошибка, тоже об этом узнаете.
Это параметр потоковый.
И второй тип, который мы разберем уже не сегодня, а позже,
это передача коротких сообщений, предназначенной для того, чтобы уменьшить нагрузку на сеть.
Но этот способ не гарантирует абсолютно ничего.
То есть вам нужно указать пространство адресов, тип взаимодействия.
Есть еще третий параметр, который, когда вы начинаете что-то писать на сокетах,
может вас немного смущать. Это номер протокола.
Чуть позже мы сегодня на лекции затронем, что такое номер протокола.
На самом деле с практической точки зрения просто указывайте значение 0,
и в большинстве случаев вам это будет абсолютно не нужно.
0 – это автоматический выбор ядром по паре пространства адресов и тип взаимодействия.
Когда вы создали какой-то сокет, вы израсходовали файловый дескриптор.
Дальше этот файловый дескриптор вы можете куда-нибудь передать, например,
дочерний процесс создать, и, соответственно, дочерний процесс унаследует ваш сокет.
Можете сдать его копию, можете закрывать с помощью клоуз,
для того чтобы этот сокет освободить и ценный ресурс количество файловых дескрипторов немножко возобновить.
Но читать и писать в сокет вы еще не можете, потому что сокет у вас пока еще не настроен,
вы его только создали. И настройка сокета бывает в двух разных видов.
Это либо настройка сокета для серверного взаимодействия, либо настройка для клиентского взаимодействия.
Что требуется для того, чтобы сокет настроить? В зависимости от того, кем вы являетесь.
Если вы являетесь клиентом, то ваш сокет нужно просто подключить к какому-то адресу.
Подключить это значит, если у вас локальная машина, вам нужно знать имя файла,
вам нужно открыть этот файл, и если у вас есть права на доступ к файлу сокета,
все хорошо, все замечательно, соединение установлено.
Если вы подключаетесь к какому-то удаленному компьютеру, либо к себе самому,
но уже используя сетевой протокол имя хоста localhost,
то нужно, чтобы у вас была настроена рабочая сеть
и существовал маршрут до того компьютера, к которому вы хотите подключиться.
Клиенту достаточно сделать просто коннект. Результат работы этой операции нужно всегда проверять,
потому что здесь может происходить все, что угодно.
Даже в таком высокотехнологичном месте как FizTech, как вы могли заметить, иногда с интернетом тоже бывают проблемы.
Ну и если вы являетесь сервером, то тут немножко сложнее.
Необходимо выполнить для взаимодействия.
Клиент после того, как сделал коннект, все, может сокет читать и писать,
используя обычные стенвызовы, риты и врать.
А серверу для этого требуется несколько больше действий.
Во-первых, вам нужно анонсировать какое-то имя, по которому ваш сервис будет доступен.
После этого вам нужно переключить сокет в режим прослушивания.
И после этого вы принимаете по одному соединение от разных клиентов.
И уже с каждым клиентом работаете по отдельности, используя отдельный файловый дескриптор.
Как связать сокет с каким-то именем?
Есть два системных вызова. Один называется коннект, другой байнд.
Разница между ними в том, что коннект предназначен для клиентов.
То есть он устанавливает соединение, и вы уже можете после этого взаимодействовать с сокетом.
Байнд просто связывает сокет с каким-то именем, чтобы к нему кто-то мог подключиться.
Параметры у них одинаковые. Это тот файловый дескриптор, который вы создали раньше.
И плюс имя, которое вы хотите связать с вашим сокетом.
Причем если вы используете высокоуровневый API сокета на питоне, то это ровно один параметр.
В 29-й группе вчера на семинаре это показывал.
В случае си тут немножко сложнее, потому что сокеты у вас бывают совершенно разных типов.
Есть некоторая абстрактная структура SOCADR, которая фактически только содержит заголовок.
Всех остальных структур, которые наследуются этой структурой.
Но си это же не объектно-ориентированный язык программирования.
Здесь имитация псевдоуп реализуется за счет того, что есть структуры, которые реализуют конкретную функциональность определенных адресов,
которые самым первым полем содержат некоторую константу, которая определяет, чем именно эта структура является.
Эти структуры имеют все разный размер.
Например, для IP-адреса IPv4 нам нужно 32-битное число для самого IP-адреса и 16-битное число для номера порта.
А, например, для локального униксойки-то нам нужно уже хранить имя файла.
Тут есть одно отличие от обычных имен файлов.
Это ограничение на длину 108 байт, а не 4096.
Но все равно 108 это заведомо больше, чем 6 байт.
Плюс еще есть дополнительная информация.
То есть у всех структур есть разный размер, который должен быть системным вызовом, скопирован из пользовского пространства в память ядра.
Поэтому на языке C есть еще третий параметр обязательный.
Это размер той структуры, которую вы передаете.
Конкретные поля в разных структурах смотрятся в седьмом разделе мана по соответствующему пространству имен.
Имена, перечисленные на слайд, это уникс, IP это обычный интернет, IPv6 это адресация IPv6 более новая.
После того, как вы связали связывание стенлозом байнд, точно так же, как коннект, всегда нужно проверять на успешность.
Почему у вас может возникнуть какая-то ошибка на стадии связывания какого-то адреса с сокетом?
Можете предположение сделать?
Очень распространенные ошибки, которые не всегда проверяют.
Когда проверяют, получается все очень плохо.
У вас банально адрес может быть занят.
То есть, если у вас, например, есть один компьютер с каким-то IP адресом,
и вы запустили, например, веб-сервер Nginx, который работает на 80 порту,
потом вы запускаете веб-сервер Apache, который настроен тоже на 80 порт по умолчанию, что у вас произойдет.
Тот, кто запущен раньше, тот будет слушать 80 порта и работать как веб-сервер.
Тот, кто запущен позже, не сможет сделать байнд, и ничего хорошего из этого не выйдет.
Более того, когда вы будете решать задачи, писать какие-то серверы,
то понятно, что если вы нормально пишете, а не катаете, вы отлаживаетесь,
у вас иногда что-нибудь случается, программа крэшится,
либо вы ее принудительно останавливаете кнопочкой остановить, послать сигнанс и кил.
Что при этом происходит?
Происходит не освобождение адреса в ведре, то есть при завершении работы процесса
у вас еще остается некоторый фантом вашего сокета.
В Linux он примерно через минуту исчезает, но тем не менее при повторной попытке выполнить байнд
у вас ничего хорошего не выйдет, потому что имя уже занято, нужно либо подождать,
либо использовать некоторую магию, которая у вас в рейтинге прописана.
Итак, вы связали сокет с каким-то именем, дальше вы переключаете сокет в режим прослушивания,
и здесь есть еще некоторый целочисленный параметр, который больше по историческим причинам
является параметром, на самом деле он достаточно жестко,
точнее верхняя граница этого параметра жестко лимитирована в ядре операционной системы.
В Linux 128 максимальное количество подключений, которые могут ждать обработки сервера.
Что значит ждать? Это означает, что вы запустили сервер, еще не успели ничего сделать,
к вам уже ломятся какие-то клиенты. Сколько может быть таких клиентов?
В Linux их может быть не больше, чем 128, и что будет происходить с теми, кто подключился слишком поздно?
Эти клиенты сразу от ядра операционной системы получают отказ, что соединения нельзя установить.
Если вы лимит на backlog не превысили, тогда подключившиеся клиенты успешно смогут подключиться,
Connect им вернет нормальный файловый дискриптор, для них вернет значение 0 успешное подключение,
но пока сервер не начнет что-то писать или что-то читать, для клиента ничего полезного происходить не будет,
он будет просто на стенах закрытой в райд ждать, процесс будет в состоянии sleep.
Вы создали socket, связали его с каким-то именем, переключили в режим прослушивания.
Если на этом этапе у вас все произошло успешно, то следующая часть,
которую вы должны сделать на сервере, это принимать по одному с помощью системного вызова accept,
accept возвращает уже серверу отдельный файловый дискриптор, с которым можно дальше взаимодействовать,
естественно у вас должен быть неизрасходованный лимит на максимальное количество файловых дискрипторов,
кстати по этой причине дефолтное значение количество файловых дискрипторов иногда приходится менять,
потому что значение 1024, которое по умолчанию в большинстве дистрибутилов,
бывает совершенно неприемлемым для серверных применений, когда у вас большое количество одновременных подключений.
Если все успешно, вы на сервере либо приняли соединение, либо клиентом успешно подключились,
то как с сокетом можно взаимодействовать, либо простым способом, который в большинстве случаев более чем достаточен,
используя обычные системные вызовы read&write, поскольку это обычный файловый дискриптор, можно читать, можно писать,
либо используя специальные системные вызовы, которые работают с файлом дискриптор, но специального типа, только с сокетами.
Это send и rec, в которые позволяет еще дополнительно указывать разные параметры.
Например, при чтении вы можете дождаться, когда все данные будут прочитаны, а потом только после этого rec вам возвращает количество байт,
а rec может в этом время прочитать один кусок, потом еще один кусок, то есть объединить количество данных.
Но более принципиально, где используется send и rec, это либо при взаимодействии по UDP, то есть не потоковой передачи данных,
либо при взаимодействии, когда вам требуется передавать какие-то специальные пакеты, например, отдельные участки данных с повышенным приоритетом.
На сокете действуют те же самые ограничения, что и для каналов, то есть нельзя писать в сокет, у которого с противоположной стороны никто не читает.
Если вы попытаетесь что-то записать в сокет, который уже закрыт, то то же самое, как при записи в каналах, вы получаете сигнал sickpipe,
если вы его не обрабатываете, то получаете ошибку brokenpipe.
В систему из-за send вы можете явным образом указать флаг, что не нужно получать sickpipe,
если вы используете систему из-за fright, как эту ситуацию можно обойти, чтобы не падать, если вдруг противоположная сторона закрыла соединение.
Предложите способ обойти эту проблему.
Да, можно просто установить хендлер на сигнал sickpipe, который ничего не будет делать.
Так, ну и сети. Что это такое? То есть с локальными сокетами тут все достаточно просто.
Я вам все рассказал, используйте специальные файлы типа сокет, и будет вам счастье.
Так, теперь немножко про сети. Мы живем в современном мире, поэтому забываем про всякие разные способы адресации,
которые у вас перечислены, например, в мане на сокет.
То есть если вы посмотрите список всех доступных пространств адресов, в втором разделе сокет, какие есть константы,
то их очень много, на одну страницу мана они не помещаются.
И на самом деле большая часть того, что здесь перечислено, это уже какой-то очень старый мусор,
который просто тащится из соображений гарантии совместимости.
Ну не все мусор, тут конечно есть отдельные типы, которые просто редко используем,
но тем не менее много из этого вы в реальной жизни никогда не встретите.
Современные сети это стэк протоколов TCPIP,
и есть еще классическая модель сетевой иерархии, которая называется Open System Interconnection Model.
На каких-нибудь собеседованиях, если вам придется что-то рассказывать про сети,
единственное место, где вам нужно знать, что такое УСИ, какие там есть уровни.
Давайте пройдемся снизу вверх. Какие у нас бывают уровни организации сети?
На самом нижнем уровне у нас есть уровень сетевого интерфейса с точки зрения стэка TCPIP,
который в свою очередь делится на два подуровня, физический уровень и Data Link.
Например, интерфейс Ethernet. Что такое сетевой разъем на ноутбуке, знаете?
Или вы уже привыкли к Wi-Fi?
Ну в общем, бывают сетевые разъемы у десктопов и на некоторых ноутбуках,
и во всяких переходниках с Type-C, куда можно воткнуть проводок.
Это стандарт Ethernet. На самом деле кроме Ethernet раньше существовали еще другие типы сетей,
например, как сиальный кабель.
И в этом стандарте есть два подстандарта.
То есть Ethernet это некоторое обобщенное название.
Один стандарт описывает физический уровень, то есть как у нас данные передаются в виде сигналов по проводам.
И второй стандарт это как данные у нас должны быть организованы, на логическом уровне.
При этом в каких ситуациях у вас могут эти данные отличаться, могут эти стандарты быть разными?
Например, когда вы подключаете через USB кабель компьютеру смартфон,
если у вас Android смартфон, что обычно вы видите?
Вы видите, что вы подключили какую-то новую сетевую плату,
которую используете как обычную сетевую плату,
используя логический интерфейс Ethernet, но при этом на физическом уровне вы используете обычный USB кабель.
И данные здесь передаются по USB, но при этом закодируем предварительно в формате Ethernet frame.
И противоположная ситуация, когда вы используете обычный Ethernet провод,
но на логическом уровне там что-то может быть другое.
Это когда вы установите VPN подключения, у вас создается виртуальная сетевая плата,
которая использует тоже Ethernet пакет, но уже поверх немного другого уровня.
По Ethernet можно передавать данные тоже произвольного типа,
не обязательно Ethernet пакеты, это иногда используется при работе с микроконтроллерами.
Чуть выше уже идет сетевой уровень, который в оси называется сетевым уровнем TCP, IP стеки называется уровнем интернет.
Он определяет способ адресации ваших пакетов.
В нюнаслайде два раза IPv4 потаблировано, это имеет в виду IPv6.
На этом уровне определяется, как можно данные доставить до кого-то другого,
то есть фактически это адрес, по которому как-то дальше можно узнать маршрут.
Из современных протоколов выжили только IPv4 и IPv6, остальное это старинные legacy,
навряд ли вы когда-нибудь видите новое нетвер или старинные Apple компьютеры, которые есть только в Яндекс.Музее.
Следующий уровень – это уровень транспорта, который определяет, а что именно мы передаем.
Либо мы передаем потоковые данные, то есть открываете сокет для двустороннего взаимодействия с помощью Read&Write,
либо вы передаете короткие сообщения.
А дальше уже начинается все, что вы читаете из Read&Write, это уровень процессов, достаточно обобщенный.
Ну и в классической модели AC там есть еще разделение на несколько подуровней,
на самом деле границы между ними очень весьма условные.
Так, ну и что у нас происходит при попытке как-то взаимодействовать.
Шрифт мелковатый, конечно, потом в презентации посмотрите.
Итак, вот представьте себе, что вы открываете какой-то веб-браузер, набираете www.example.com,
не забывая при этом писать http, потому что по умолчанию все браузеры используют протокол https,
который передает данные в разношифрованном виде.
Смотреть на это, конечно, немного сложнее, хотя это безопаснее.
Итак, что у нас происходит.
Наша система открывает какой-то рандомный порт с достаточно большим номером,
и с этим портом связывает какие-то полезные данные, например, заголовок HP запроса.
Что происходит дальше.
С этим потоком данных, дальше этот поток данных заворачивается в некоторый TCP-сегмент.
И здесь уже обязательным параметром TCP-сегмента является номер порта как отправителя,
это большое значение, и плюс номер порта получателя.
Если вы обращаетесь к веб-серверу, то стандартным номером является номер 80.
И здесь еще возникает то самое число.
Нет, пока еще не возникает.
Так, эта штука называется TCP-сегмент, который содержит кусочек данных, связанных с номером порта.
Дальше этот TCP-сегмент заворачивается в IP-пакет,
в который добавляется IP-адрес, куда нужно этот пакет отправить,
и он содержит еще IP-адрес отправителя, чтобы противоположная сторона знала, куда отправлять ответ.
И в этот момент еще добавляется число для TCP-6.
Это тот самый номер протокола, который является третьим параметром при создании сокета.
Тот, который ядро может само выбрать, если указать значение 0.
Дальше IP-пакет заворачивается, если вы используете Wi-Fi либо проводной интернет, уже в Ethernet-кадр.
Адресация по Ethernet немножко другая.
Она предназначена для того, чтобы адресовать любое устройство в пределах какой-то локальной сети,
то есть до первого маршрутизатора или до первого Wi-Fi-руутера.
Это 6-байтное значение называется MAC-адрес.
И вот мы получаем огромное количество заголовок, в дополнение к нашим большим данным.
И этот фрейм дальше как-то идет до маршрутизатора.
И с маршрутизатора дальше извлекается IP-пакет.
Какими-то окольными путями все-таки дело доходит до нашего сервера, куда мы отправили.
Причем доходит он, возможно, в искаженном виде.
То есть у нас может поменяться номер порта отправителя, IP-адрес отправителя,
но, естественно, меняется MAC-адрес отправителя с одним исключением, если вы не находитесь в одной локальной сети.
Дальше сервер обрабатывает эти заголовки.
Если получен соответствие по IP-адресу, то сервер обрабатывает.
Дальше пакет, если не соответствующий по IP-адресу, значит он должен куда-то переадресовать этот пакет,
либо отклонить в зависимости от того, как таблица маршрутизации настроена.
Дальше извлекается TCP-сегмент.
В серверу порта, который прописан в TCP-сегменте, выбирается уже конкретный процесс,
который открыл на прослушивание порт с нужным номером.
Дальше что происходит в обратную сторону.
Зная адрес отправителя, номер порта отправителя, можно сформировать какой-то ответ и отправить обратно.
Давайте пройдемся снизу вверх, начиная с логического, а не физического уровней.
Что мы можем передавать? Интереснее это смотреть на реальной практике.
Для этого есть замечательный тул, который называется Wireshark.
Это кросс-платформенная опенсорсная утилита.
Есть не только в Linux, может даже и в Windows есть, не проверял.
Под Mac оно точно есть, под Linux тем более.
Вот мы запускаем некоторые тулы. Сначала нам нужно выбрать, с каким сетевым интерфейсом будем работать.
В данном случае физиологическая сеть подвела, поэтому я подключусь через мобильный интернет.
Давайте double-кликнем. Что у нас происходит? Происходит какая-то активность.
На самом деле в реальной жизни тут очень большая активность, запутаться легко и просто.
Вверху есть строчка, где можно написать какой-то фильтр.
Например, будем фильтровать все, что связано с IP-адресом.
Я должен продемонстрировать какое-то взаимодействие по протоколу HTTP.
Именно по HTTP, без использования SSL. Не так много сайтов живых осталось.
Пример такого сайта это www.example.com.
Он умеет работать по протоколу HTTP, без буквы S.
И выдают какую-то страничку о том, что это специальный дом, чтобы иллюстрировать, как работать с интернетом на низком уровне.
Итак, вот у нас есть некоторый example.com. Чтобы настроить фильтр, я выясняю его IP-адрес.
Есть разные способы, как выяснить IP-адреса. К сожалению, проектор немножко подрезает, поэтому я подниму.
www.example.com. Команда ns-lookup ищет у основного DNS-сервера IP-адрес, связанный с этим именем.
Есть еще более продвинутая команда, которая называется dig, где можно более тонко тюнить, например, с какого сервера получать.
Итак, вот мы видим, что есть некоторые IP-адресы нашего example.com, и эту штуку мы можем добавить в наш фильтр.
Так, что-то я тут уже получал. Ну ладно.
Так, вот запрос мы уже обработали, он сохранился в истории, который Wireshark отловил.
Итак, что у нас происходит при отправке запроса и получении ответа вот в таком виде?
Происходит очень большой обмен данными по протоколу TCP, который содержит в конце полезную нагрузку в виде текста HTTP.
Вот мы нашли протокол HTTP, и вот этот текст мы можем наблюдать.
Так, но что нас следует до данных, которые мы отправляем в GET-запросе?
Во-первых, у нас есть некоторые заголовок. Вот когда я кликаю по разным частям того, что Wireshark отображает на каком-то пакете, это разные уровни сети интернет.
Frame — это что-то низкоуровневое, поэтому здесь неинтересно это смотреть, оно может по-разному работать даже в разных операционных системах.
А вот начиная с уровня Ethernet-логических, все более-менее стандартно.
Итак, что у нас есть в заголовке Ethernet? Есть всего лишь три поля.
Когда я кликаю на какой-то заголовок, внизу подсвечивается что-то. Это как раз та часть, которая занята заголовками.
Так, что у нас есть в заголовке Ethernet? Есть два числа, длина каждого числа 6 байт, это как раз MAC-адрес отправителя и получателя.
И некоторый тип данных, 2-байтное значение, которое указывает, а что именно внутри этого IP-пакета закодировано.
Поскольку мы можем передавать данные не только по протоколу IP, но и, например, по протоколу IPv6, еще есть всякие разные протоколы, какие типы пакетов мы можем отправлять внутри Ethernet-кадра.
Нужно знать их тип, чтобы принимающая сторона могла разобраться, что дальше с этим делать.
Так, дальше внутри следующий заголовок, уже там, где у нас идет полезная нагрузка. Размер полезной нагрузки является настраиваемым при установке соединения,
установке подключения к интернету. Обычно это параметр 1492 либо 1500. Это максимальный размер одного Ethernet-кадра.
Если у вас что-то не помещается в полезную нагрузку, данные делятся на несколько Ethernet-кадров, они отправляются последовательно.
Здесь какие могут быть ограничения. Например, если вы используете VPN-подключение, то понятно, что у вас будет каждый раз при каждой новом уровне вложенности очередного VPN-подключения размер полезной нагрузки у вас будет уменьшаться.
Дальше у нас в этой полезной нагрузке запихивается AP-пакет, который тоже имеет какой-то заголовок. Естественно, этот заголовок идет сразу после заголовка Ethernet.
Тут куча всяких параметров, на самом деле не все из них нам интересны. В альшарках тоже отображает. Они идут сразу, что у нас есть полезного, интересного в этих заголовках.
Хидр и длина заголовков неинтересно. Суммарный размер в байтах. Заголовка вроде нет.
Полный размер AP-пакета 131 байт. Похоже на правду. Что еще полезного?
Параметр TimeToLeave. Это количество итераций, которые может пройти пакет через разные маршрутизаторы, прежде чем исчезнуть.
Для чего это нужно? Например, если у вас плохо сконфигурированная сеть, есть какие-то петли для того, чтобы пакеты не нагружали сеть, ходя бесконечно, есть некоторые ограничения.
С этим TimeToLeave есть еще один побочный эффект, связанный с тем, что некоторые нехорошие мобильные операторы любят брать дополнительную денежку, когда вы начинаете раздавать интернет с телефона.
Как они это определяют? Телефон является очередным маршрутизатором. При прохождении трафика через него ТТЛ уменьшается на единичку.
По этому признаку можно понять, что вы действительно раздаете интернет, а не пользуетесь телефоном.
На компьютере, с которым вы подключаетесь, увеличивает параметр до 65, и будет вам счастье.
Тут есть некоторые косвенные признаки, чтобы узнать, что вы раздаете интернет.
Если вы пользуетесь как бы телефоном, но при этом телефон внезапно начинает лезть в Windows Update, это уже подозрительно,
и уже по косвенным признакам операторы все-таки могут определить, что вы интернет все-таки раздаете, и с вас может просить денежку.
Номер протокола. Для TCP это значение 6, для EDP это значение 17.
Других поверх IP есть протоколы, но достаточно редко используемые.
Для чего нужен номер протокола? Для того, чтобы при распаковке пакета знать, как дальше обрабатывать следующие заголовки.
Тот самый пресловутый третий параметр.
Контрольные суммы, понятно, не интересно. Да, и два целых числа, без знаковых, 32-битных.
Это source address, Windows 192, 168, чего-то там.
И destination address, это тот самый IP-адрес, который соответствует серверу example.com.
В чем тут есть особенность? В IP у нас не содержится номер порта, это уже TCP-сегмент.
Но что для IP-адреса, что для номера порта, действует соглашение о том, что это числа.
И как можно закодировать числа, если их длина больше 1 байта?
Big Indian, Little Indian, помните такое?
Так вот, у большинства компьютеров родной порядок byte – это Little Indian.
То есть, когда у вас сначала идут младшие разряды, а потом старшие.
В сети не так. Есть такое понятие, как сетевой порядок byte, он же Big Indian,
когда сначала идут старшие разряды, а потом младшие.
Так вот, если вы внимательно посмотрите на бинарный dump, посчитаете на калькуляторе, какое тут должно быть значение,
то увидите, что данные перейдутся всегда в Big Indian, и это нужно учитывать в том числе,
если вы хотите инициализировать какие-то структуры, связанные с адресами либо номерами портов.
В принципе, это все, что есть интересного в IPv4, остальное не особо интересно.
А дальше, поверх, внутри IP-пакетов, в качестве полезной нагрузки мы можем отправлять пакеты одного из двух видов.
Самый простой из них – это UDP.
Я сделал простой запрос к HTTP, огромное количество данных всяких пошло, всяких разных страшных.
Есть еще более простой способ – это использовать UDP-пакеты, у которых в заголовке есть только две полезные информации.
Это 16-битный номер порта получателя, куда нужно отправить, 16-битный номер порта отправителя,
длина сообщения в байтах и контрольная сумма для проверки целостности.
Короткий заголовок, очень простой, и как мы можем отправить UDP-сообщение и проследить.
Один способ – это выяснить IP-адрес по имени, это команда nslookup.
Есть еще команда dig, где можно указать то же самое.
И он выдаст немножко в другом формате, но тот же самый ответ.
Еще есть одна особенность dig, что вы можете указать, кому именно из DNS-серверов,
в которых может быть много, передать данный запрос.
4.8 либо 8.8.4.4 – это гугловские DNS-серверы.
Так, чтобы было что-то нестандартное, я отправляю на сейвер 8.8.4.4 запрос,
получаю правильный ответ, ну давайте исследуем, что у нас при этом произошло.
8.8.8.4.4.
Так, соединение, тут взаимодействие намного короче, чем PotiCP.
Только один запрос и один ответ.
Запрос с нашего IP-шника на 8.8.4.4 и ответ в обратную сторону.
Так, ну давайте посмотрим, что у нас тут могло быть.
С IP с головками примерно все то же самое, он одинаковый для TCP-UDP.
Дальше идет заголовок UDP, это какой-то большой номер 63 372
для открытого порта отправителя и номер 53, стандарт для DNS, адрес порт получателя.
Длина 64 байта.
Так, контрольная сумма, ну и все, заголовок на этом закончился.
Дальше уже идет полезная нагрузка, которая была отправлена в качестве запроса,
ну и ответа на DNS-сервер.
Так, вот с TCP тут все сложнее.
Ну точно так же у нас есть номер порта отправителя сегмента,
номер порта получателя. TCP, в отличие от UDP, это протокол для потоковой передачи данных.
То есть у нас здесь еще важными являются такие параметры,
как порядковый номер какого-то TCP-сегмента в общем потоке,
для того чтобы гарантировать целостность данных в правильном порядке.
Как эта целостность гарантируется?
Вы отправляете какой-то сегмент, в ответ сервер вам отправляет какой-то ответ
в виде TCP-сегмента, который при этом содержит еще одно число в заголовке,
это номер подтверждаемого пакета, что сервер его действительно получил.
Это все обрабатывается на уровне ядра, то есть не нужно при использовании ReadWrite прописывать это вручную.
Дальше ядро проверяет, что действительно все сегменты были отправлены,
если какие-то были не отправлены, повторяет отправку,
либо сообщает о том, что ошибка, что за плохо с интернетом.
Так, есть еще всякие разные неинтересные параметры TCP,
но кроме этого есть еще некоторый набор флагов в количестве 9 штук,
то есть не занимает 1 байт плюс 1 бит,
и среди них выделяются три очень полезных бита.
Один бит, который называется acknowledgement, означает,
что данный пакет содержит значимое число, это номер подтверждаемого пакета.
Кстати, номера пакетов имеют сквозную нумерацию с момента загрузки системы.
То есть если вы запускаете несколько процессов,
то при каждом новом сетевом соединении
начинается эта нумерация не с нуля, а с достаточно большого числа.
Но если вы смотрите в Wireshark, то Wireshark автоматически сам это все пересчитывает.
Так, вот ACK означает, что является значимым число номер подтверждаемого пакета,
и есть два флага для установки соединения, SIN и FIN.
SIN означает, что вы устанавливаете соединение,
а FIN, что вы хотите соединение закрыть.
И есть еще флаг RST, означает, что соединение было сброшено,
в некоторых случаях оно тоже является признаком того,
что в это соединение закрываете, хотя это не самый корректный способ.
Как выглядит взаимодействие по TCP?
Изначально кто-то инициирует соединение,
отправляя при этом флаг SIN.
В ответ вы получаете TCP-сегмент с флагами SIN и Acknowledgement.
После этого уже начинается передача данных,
то есть отправка чего-то с флагом Acknowledgement,
чтобы мы действительно получили флаг подтверждения.
И до тех пор, пока вы не отправите флаг FIN,
ну и в ответ вы тоже получите флаг,
сегмент с флагами Acknowledgement и FIN,
что действительно ваше закрытие соединения принято сервером,
либо, наоборот, клиентом, если вы в другую сторону взаимодействуете.
И тем самым соединение при этом завершается.
И вот как правильно закрывать TCP-соединение,
то есть все-таки отправлять сегменты с флагом FIN.
Когда вы просто закрываете файл в дискриттер с помощью close,
что у вас происходит?
У вас просто освобождается очень ценный ресурс
количество файловых дискриттеров.
И все.
То есть этот файл дискриттер становится недоступен,
но при этом системный вызов close не предназначен
для того, чтобы закрывать сетевые соединения.
Закрыть-то, конечно, можно.
Да, вы освободите у себя файловый дискриттер.
Но что будет происходить с противоположной стороной?
Противоположная сторона об этом не узнает,
что вы закрыли соединение,
и будет пытаться вам что-то записать,
либо будет пытаться что-то от вас прочитать.
В какой-то момент, конечно, получит ошибку
либо broken pipe при попытке записать,
либо incarnation refused при попытке прочитать,
но это произойдет не сразу.
И это будет именно ошибочная ситуация.
Да, при этом вам как клиенту на это, наверное, все равно,
но вы ведете себя невежливо.
Как правильно делать?
Перед закрытием обязательно делать shutdown.
Некоторые системы, например, Linux,
при close посылают как раз пакет RST,
который может быть обработан именно как ошибочная ситуация
для того, чтобы противоположная сторона
не находилась у вас в состоянии ожидания.
Ну и по поводу номеров портов, которые являются 16-битными,
как и адреса, они закодированы в BigEndian,
даже если их номера не очень большие.
Номера до 1000 обычно связаны с какими-то стандартными службами,
то есть есть какие-то стандарты,
которые описывают на каком порту, что должно быть.
Но при этом никто не мешает вам сделать, например,
какой-нибудь эхо-сервер, который будет работать на 22-м или 80-м порту,
или перенастроить SSA, чтобы он работал не на 22-м порту,
а на чем-то рандомном, например,
чтобы усложнить поиск потенциальным злоумышленником.
То есть есть некоторые стандартные порты.
И когда-то давно считали, что у вас есть 1024 стандартных порта,
открывать их может только пользователь root.
Все остальные порты с номерами больше, чем 1024,
начиная с 1024, они могут быть использованы
с бедром произвольным образом в качестве исходящих клиентских номеров.
Куда потом прислать ответ?
В современных системах это немножко не так,
потому что появилась куча разных сценариев использования
помимо стандартных сервисов.
Классический пример — это фласск или robin rails.
Используют порт 8080.
И понятно, что использовать порты с такими номерами в качестве исходящих
как-то не очень правильно.
Поэтому в современных системах в случае с Linux
ядро начинает назначать рандомные порты
начиная с кода номера 32768 в Windows, Mac 49152.
То есть достаточно большие номера.
И вот в этих диапазонах как раз не нужно делать никакие сетевые службы.
И кроме того, порты с номером до 1024 открывать может только root,
либо есть такое понятие как Linux Capabilities,
которые позволяют...
Capabilities, помните такую штуку?
Команды setcap, getcap и так далее.
Всякие флаги там — pay, inherited и так далее.
Так вот, есть отдельный флаг Capabilities,
который позволяет непривлекированному пользователю
все-таки открывать порты с небольшим номером,
если это вдруг нужно.
Но иногда это бывает полезно.
Хотя зачем?
Можно настроить EngineX Server в качестве Proxy.
Ну ладно.
Теперь немножко по поводу исходящих номеров портов,
которые рандомно присваивают из этого большие числа.
На самом деле сервер может неправильно узнать в вашей пиадрис,
когда вы подключаетесь,
номер вашего порта,
потому что где-то по дороге
эти сведения в заголовках могут поменяться.
Из-за чего они могут поменяться?
Давайте рассмотрим классическую ситуацию,
что вы сидите через единую Wi-Fi с вашим соседом,
и вы одновременно подключаетесь к Яндексу
или еще к какому-нибудь веб-сайту.
Что есть у какого-то веб-сайта?
Есть порт номер 80, есть какой-то IP-адрес,
и вы одновременно с соседом подключаетесь.
И так случайно совпало,
что у вас на ноутбуках система одновременно присвоила
один и тот же номер исходящего порта.
А как сервер узнает, а кому именно отправить ответ?
Какой ответ кому предназначен?
Ответ никак.
Поэтому в чем заключается задача маршрутизатора?
Маршрутизатор, он же роутер,
это таблица маршрутизации, которая содержит записи вида
от кого, кому, что было отправлено,
чтобы потом сметчить уже правильную сторону ответа.
И мы получаем запросы с двух разных IP-шников
внутри нашей какой-то локальной сети,
который на выходе во внешнюю сеть превращается в один IP-адрес,
который присвоен вам провайдером,
сервер будет отправлять ответ уже на этот IP-адрес,
который вам провайдером присвоен,
либо он будет отправлять провайдеру,
если у вас динамический IP-адрес,
а провайдер дальше уже разберется,
кому отправлять и так далее.
И роутер меняет номер порта.
Соответственно, получая ответ от сервера,
роутер разбирается,
а кому именно из внутренних клиентов уже предназначается
этот ответ и отправляет его обратно.
Поэтому что будет,
если вы возьмете обычный домашний роутер
и попробуете организовать огромную сеть на 100 человек.
И среди этих 100 человек еще найдутся человек 5,
которые начнут качать торренты или смотреть видосики.
Вообще тела можно не убедить.
Вот однопоточнение у меня поползло.
Можно заметить, что внутри одного,
ну разных частей истек,
и нельзя попрощать другого процесса.
Это на что-то вылетает.
Ну короче, будет плохо.
Опять же, ключевой момент здесь.
Если вы используете обычный бытовой роутер,
на самом деле тут будет уже некоторая перенапряженность нашего эфира.
Но даже если вы в роутер воткнете несколько...
у роутеров еще кроме Wi-Fi бывает выход на обычный Ethernet.
Можно сделать что-то древовидное,
использовать дешевые свитчи.
Так вот, в какой-то момент у вас роутер перегреется
и начнет очень медленно работать.
Просто по той причине,
что у него будет перегружена таблица маршрутизации.
Объем оперативной памяти у роутеров обычно не очень большой.
И вы просто воткнетесь в это ограничение.
Поэтому если вы хотите организовывать полномашнабную какую-то сеть
на большое количество людей,
то здесь уже надо обзавестись какими-нибудь нормальными промышленными роутерами,
которые рассчитаны на большую нагрузку.
Принципиальное отличие в том,
что нормальный промышленный роутер умеет работать с большими таблицами маршрутизации.
Либо взять просто старый десктоп ненужный,
и поставить несколько сетевых плат,
и пусть он будет роутером.
Что еще надо знать про порты?
Лишний открытый порт – это дырка безопасности.
И во многих Linux-дистрибутивах, и не только в Linux,
есть такая штука, которая в Windows называется страшным словом BrandMower.
Что это такое означает?
Какую-то лингвистическую экспертизу надо проводить.
Нарисована в виде стены в иконках.
А что слово BrandMower?
Другой термин – это Firewall, так называется огненная стена.
Что это за штука такая?
Это штука, которая препятствует либо исходящим соединениям
на запрещенные какие-то ресурсы,
либо блокирует попытки входящих подключений через сеть,
на определенные интерфейсы.
Причем Firewall можно достаточно гибко настраивать.
Если у вас есть несколько сетевых плат,
то указывать, какие сетевые платы у вас привязаны к доверенным интерфейсам
или демилитаризованной зоне, то есть без ограничений.
Например, внутренняя сеть между разными сервами.
Какие-то интерфейсы могут смотреть наружу,
там нужны максимально жесткие правила и так далее.
Что является одной записью с точки зрения Firewall?
Это некоторый IP-адрес, номер порта и от кого разрешено принимать запросы,
от кого запрещено и в каких случаях нужно, например, делать перенаправление.
Стандартная таблица маршрутизации в Linux
она унифицирована для роли роутера и так и для Firewall.
И если у вас несколько сетевых плат,
то опять же вам нужно открывать на прослушивание либо конкретный адрес,
либо есть специальное значение IP-адреса 4.0 для IPv4,
либо 16.0 для IPv6.
Это специальный адрес, который означает,
что нужно связаться со всеми сетевыми платами, которые у вас есть.
Так, узнать, какие порты у вас открыты вы можете с помощью команды nmap.
Она обычно не входит в базовую поставку в многих дистрибутеев.
Нужно ставить дополнительно apt-get, циппер и так далее.
В репозиториях обычно есть, но не стоит по умолчанию.
И вот можете проверить свой ноутбук, а что у вас лишнего пана открыто.
Firewall как раз валяет это все прикрыть.
Так, как работает Firewall?
В Linux есть команда, называется epitables,
которая добавляет какие-то правила таблицы маршрутизации.
Правила могут быть видом.
Либо разрешить подключение, либо запретить.
Например, вы знаете, что по какому-то IP-адресу находится злоумышленник,
либо в какой-то подсети с определенной маской.
Ну и вы блокируете явно эти вещи,
чтобы все эти пакеты до вас просто не доходили и никому не мешали.
Причем сервисы, которые у вас запущены,
они даже ничего не узнают, что кто-то пытался подключиться.
Firewall работает на более низком уровне.
Либо перенаправить определенные подключения,
но, например, вы так можете настроить правила,
что если вы выходите в сетку такую-то,
или пытаясь подключиться, например, к какому-то серверу с известным IP,
то это подключение, например, нужно явным образом принудительно перенаправлять
через VPN-тунель, чтобы обойти какие-то блокировки или еще что-то.
Так вот, таблицы амортизатора достаточно огромными становятся.
И напрямую работать с командой iptables
для того, чтобы настраивать правила Firewall, это достаточно утомительное занятие.
Поэтому в разных дистрибутилах есть высокоуровневые инструменты уже поверх iptables.
То есть iptables используют, в частности, в Ubuntu это команда UFW,
которая можно поставить в том числе под Debian, Ubuntu Firewall,
в Fedora есть Firewall CMD, это команда,
которая позволяет тоже легко и просто назначать какие-то правила вашего Firewall.
Да, есть одно важное замечание по поводу Linux-дистрибутилов.
Во многих из них почему-то по дефолту Firewall отключен.
То есть первое, что нужно сделать, поставить Firewall и обязательно его включить,
а уже после этого настраивать.
Если вы настраиваете сервер, то еще не забыть включить сразу по умолчанию 22-й порт.
Так, вообще, что нужно делать, когда вы, например, хотите сделать свой сервер,
неважно, это или на какой-то площадке, где хостинг VDS, VPS,
либо вы дома поднимаете, покупаете статический IP-адрес.
Сначала первым делом при настройке.
Да, учитесь на чужих ошибках.
Первым делом включайте Firewall.
Система без Firewall – это решито.
Причем неважно, есть ли у вас злоумышленники или нет.
Даже если у вас врагов нет, все равно, есть толпа китайцев,
есть куча всяких ботов, которые тупо ломятся на ваш сервер,
начинают брутфорсить все подряд, пытаться ломиться, искать какие-то дырки в приложениях.
Даже если у вас ничего полезного, ценного на сервере нет, кроме SSH,
но все равно это лишнестевая нагрузка. Зачем она вам нужна?
По поводу SSH. Отключите парольный вход.
Пароли – это пережиток XX века, который сильно помогает хакерам.
Даже если не поможет хакерам, все равно хакеры будут пытаться долбиться, подбирая.
Посмотрите, какие логии SSH, если у вас парольный вход разрешен.
Что у вас будет происходить?
Всякие китайские IP-адреса, которые подбирают разные распространенные имена,
распространенные пароли. Опять же, лишняя нагрузка на сеть. Зачем она вам нужна?
Как ни странно, по всему, вот почему хак уже только по SSH разрешает включаться в последнее время?
Распространенная проблема. Тем более, в последнее время есть производитель роутеров MikroTik,
которые допустили серьезный баг распространяющий ботнет, не препятствующий точнее распространению ботнета.
И вот эти роутеры MikroTik становятся сами взломными ботнетами.
В общем, это легко отключается. Один раз настроите ключик и все.
Кроме того, есть такая замечательная тулза, называется Fail-to-Ban,
которая анализирует логи разных серверов не только SSH,
но применимость, в первую очередь, к SSH, потому что туда часть все долгается.
И если обнаруживается попытка несколько раз неправильно зайти,
то происходит добавление с помощью IP-tables в таблицу маршрутизации.
И тот IP-адрес, с которого много раз пытаются до вас достучаться,
например, подбирать имена пользователей и пароли, он добавляется в черный список на уровне Firewall,
и больше вас не будет беспокоить. Тем самым вы можете предотвратить DDoS-атаку, хотя бы на SSH.
На остальные сервисы там не очень тосмысленно, потому что по HTTP это сложно.
Так, ну и закрывайте Firewall-ом все, что вы не хотите показывать наружу.
Понятно, что 22-й порт никуда не деться, подключаться как надо, надо иметь.
80-й порт, если у вас веб-сервер есть, тогда придется открыть.
Всякие внутренние потроха, типа фласка и прочее, естественно, должны быть закрыты.
База данных тоже. Уж тем более удаленный рабочий стол, который RDP либо Windows Remote Desktop,
это решено еще то. Но все-таки, если вам нужно этим пользоваться на локальном компьютере,
и у вас-то что-то прикрыто Firewall-ом, что тут можно поделать?
Опять же, есть команда SSH, это наш все. У SSH есть замечательная штука,
как туннелирование каких-то отдельных портов. То есть помимо терминала
предоставляется функциональность проброса отдельных портов уже по защищенному каналу.
На слайде нарисованы опции командной строки, которые нужно дописать.
Например, если вы хотите, чтобы локально работать... У вас же база данных начались, да?
Подгресс QL или что у вас? Да, на подгрессе.
Так вот, подгресс у вас может быть либо локально поднят, да, DataGrip вы, наверное, вам показывали.
Почему нельзя?
Вот DataGrip, да, вы можете подключиться уже с ознанной, либо на локальном компьютере, либо на удаленном.
С локальным компом все более-менее понятно, все просто, что если у вас база данных находится где-то на удаленном сервере.
Варианта два. Либо открывать на удаленном сервере порт 5.4.3.2 подгресс QL,
и тем самым дать кучу возможностей хакерам, либо просто прокинуть этот порт.
Кстати, в DataGrip это настраивается в параметрах подключения по SSH.
То есть можно накликать, не обязательно ручками запускать отдельный SSH7.
И тем самым пробрасывать трафик уже через вашу SSH-сессию.
Так, ладно, на этом у меня все. Картинка это визуализация огненной стены от бута Рую Дали.
