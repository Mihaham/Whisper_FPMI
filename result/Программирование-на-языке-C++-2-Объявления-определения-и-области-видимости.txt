Мы закончили на обсуждении того, какие есть основные
типы операции над ними.
Это был параграф 1.2, ну и сейчас будет продолжение
параграфа 1.2.
А, значит, нет, параграфы это моя личная нумерация
тем и под тем, чтобы было удобнее.
В конце года у вас будет, ну я вам скину программу
целиком с этими параграфами, возможно, когда-нибудь
будет книжка, но пока ее нет.
Я год от года собираюсь ее написать, но что-то пока
не получается.
Так вот, ну мы с вами обсудили целочистный тип, и тип
с плавающей точкой, и на семинарах вы должны были
на самом деле обсудить такие еще полезные типы, уже
не встроенные в язык, а относящиеся к стандартной библиотеке
как вектор и стринг.
Давайте я вкратце про них напомню, потому что они
важные, полезные, но они полезные с практической
точки зрения, потому что, скорее всего, вы когда будете
прикладные программой писать, вы им будете постоянно
пользоваться, в том числе на алгоритмах, а еще они
очень важные с точки зрения дальнейшего, нам самим они
пригодятся потом, чтобы на их примерах что-то показывать,
но они уже не являются базовыми, то есть не являются фундаментальными
встроенными, они относятся к стандартной библиотеке.
Значит есть и STD-стринг, ну или расскажу, кому не успели
на семинарах рассказать, а кто на семинарах прошел
уже их.
Что-то мало.
Ну да ладно.
Вот.
Ну STD-стринг, что это такое, это тип, которому можно
хранить строки, да, вот, например, так, что можно делать
со строками?
Можно, ну, наверное, самое полезное, что можно со строками
делать, это обращаться по индексу, да, ну, то есть
вы можете спросить, какой там первый элемент этой
строки.
Ну, например, вот я могу там, если у меня есть сиаут,
ну опять STD-сиаут, я могу вывести, эээ, там, СТР, первое.
И вот тут все понимают, что первый элемент это
B, а не A.
Значит, нумерация идет всегда с нуля.
Всегда нумерация во всех массивах, во всех строках
у нас будет идти с нуля.
Вот, никогда не путайтесь.
И вообще рекомендую вам в своих программах тоже
по возможности поддерживать нумерацию с нуля, ну, за редким
исключением, где, там, особенно удобно в некоторых местах
алгоритм делать наоборот, но в подавляющем большинстве
случаев лучше делать нумерацию с нуля, это, в общем, меньше
путаниться будет.
Ну, элементы строки можно менять таким образом, например,
можно сказать, СТР нулевое присвоить там B, тогда строка
станет равна bbc.
Можно у строки спросить ее размер.
str.size.
Это, значит, функция, которая вам вернет количество символов
в строке.
Вот, в данном случае, размер этой строки равен 3.
Не 2.
Размер это количество символов 0,1,2, а всего 3, значит, но
индексы этих символов 0,1,2.
Хорошо, что еще можно делать со строкой?
Ну, вот тут, наверное, надо сказать, что будет, если вы
обратитесь по индексу, который выходит за рамки допустимого.
Например, если я попробую что-нибудь СТР четвертому
присвоить, что произойдет?
Не знаю, СТР четвертая присвоить, не знаю, х.
Вот, строго говоря, в этой ситуации может произойти
все что угодно.
Это так называемое неопределенное поведение или undefined behavior.
В языке C++, если вы обращаетесь по индексу за границу строки
или массива, то не обязательно происходит ошибка.
Возможно, вы просто по СТР четвертому получите случайный
символ и поменяете какой-то символ случайный в какой-то
памяти, лежащий рядом со строкой.
Ну, конечно же, так делать нельзя.
Если вы в своих программах так делаете, то вы очень
рискуете, особенно вы рискуете, если это вы делаете не
в своих программах домашних, а где-то там в промышленном
коде, потому что это может упасть в любой момент.
Но упасть это еще ладно, не самое плохое.
Самое плохое, что это может случайно поменять какую-нибудь
другую ячейку памяти, которая относится к какой-то другой
переменной и будет поведение от этого совершенно
непредсказуемо.
Ну, главное, что надо запомнить, если вы обращаетесь
по индексу за пределы строки, за пределы того, что вы
можете 0.1.2, вы не обязательно падаете.
Вы можете как упасть, то есть программа может крешнуться,
а может и случайный символ там оказаться.
Вот. Мы с вами в какой-то момент начнем подробно
говорить о том, в какой ситуации, что конкретно будет,
ну, от чего это зависит.
Вот. И даже скорее на втором, наверное, курсе вы будете
подробнее говорить о чем это зависит.
Но пока надо просто понимать, что может произойти что
угодно, можно словить рандомное значение.
Вот. И есть такая полезная функция, если вы хотите
обратиться по индексу, но при этом убедиться, что вы
не выходите за границы.
Есть такая функция add.
Add2, например.
Вот. Эта функция, она делает абсолютно то же самое,
что квадратные скобки, с единственной разницей она
проверяет, не вышли ли вы за границу.
Вот. И если вышли, то вы гарантированно получите ошибку.
Времени выполнения вы упадете.
Это иногда полезно для того, чтобы отлавливать,
вдруг вы случайно обратились за границу,
и тем самым у вас что-то странное в программе происходит.
Вот. Когда вы пишете add, вы гарантированно получите
ошибку, и программа упадет, если вы обратитесь за
пределы допустимого.
Да. Можно писать str add, присвоить что-то другое.
И это нормально будет работать.
Вот. И разница между квадратными скобками в том,
что вот метод add, он гарантированно упадет,
если вы обращаетесь за пределы допустимого.
Вот. Ну давайте, наверное, еще несколько функций у
строк мы обсудим.
Значит, какие есть еще полезные вещи?
Ну, во-первых, можно сказать resize.
Вот. Есть size, а есть resize.
Что такое resize?
Это значит изменить размер на такой,
какой сказали.
Вот. str.resize.
Это значит сделать размер строки, ну, например, 5,
и вторым аргументом можно передать символ,
которым нужно заполнить оставшиеся элементы.
Ну, например, не знаю, е.
Вот. Ну, давайте, значит, вот так делать нельзя, да?
Вот после этого действия строка моя будет равна чему?
ABD.
Ну, точнее, вот после этого действия она будет равна BBD.
BBC.
После этого действия она станет равна BBD.
А после str.resize, вот такого, она станет равна...
Она станет равна BBD.
Вот. А после такого действия она станет равна BBDE.
Потому что я сделал размер 5,
и вот лишние элементы заполнено символом е.
Вот.
Я могу сделать resize и на меньше размер, чем у меня было изначально.
Тогда просто, ну, дропнутся те элементы, которые лишние были.
То есть я могу сказать, например, str.resize2,
и строка превратится просто в BB.
Вот. Хорошо.
Что еще можно делать со строкой?
Ну, со строкой можно делать всякие...
Можно, например, делать такую операцию pushback.
Тоже полезная операция.
Это значит дописать в конец какой-то символ.
str.pushback,
например, ну, не знаю, f.
И тогда строка станет равна BBDEF.
Ну, понятно.
Вот. А также можно делать popback.
Так, что-то у меня место закончилось.
Ну, давайте я здесь начну писать.
Можно делать еще popback.
Popback это значит наоборот.
Выкинуть последний символ, тем самым размер уменьшится на единицу.
Вот. Таким образом размер строки можно менять в рентайме,
вот, динамически по ходу программы.
А можно складывать строки, можно дописывать к строкам другие строки.
То есть можно делать str1 plus str2,
str, ну, вот тут у вас есть,
допустим, у меня есть еще одна строка,
тогда я могу сказать str plus str2,
ну, допустим, если у меня была бы еще строка str2,
тогда это была бы конкатинация.
То есть я приписал справа вторую строку к первой.
И я могу также делать plus равно.
То есть я могу к строке...
Вот в чем разница? str plus str2 это просто новая строка,
но при этом исходные строки не поменялись,
а str plus равно str2.
Это значит, что строка str поменяется,
я к str дописал справа строку str2,
и то, что получилось, это теперь строка str.
Могу также символы дописывать к строке,
str plus равно, не знаю, j.
Могу строки дописывать к строке str plus равно,
и в кавычках какая-то строка, все это будет работать.
Minus равно делать нельзя.
И умножить делать нельзя, вот, умножать строки нельзя.
Так.
Ну, есть еще несколько полезных функций,
связанных со строками.
Например, можно делать поиск под строки,
там есть функция subster,
есть функция какой-нибудь там...
Господи, что еще там есть полезного?
Ладно, я даже не хочу вспоминать,
но я не буду про них рассказывать,
вы про них можете почитать на cpp-референс,
открыть и почитать, что еще строки умеют,
но самая базовая операция я перечислил.
Так.
Что-то я еще хотел сказать.
А, вот еще что.
Можно делать приведение строки к числу,
ну, есть функция для преобразования int в строку и обратно.
То есть вы можете, например,
если у вас есть число int,
да, int x равно, не знаю, 55,
то вы можете захотеть сделать из него строку,
для этого есть функция std to string.
Вот, std to string от int,
она берет этот int и превращает его в std string.
Ну, соответственно, как будто это строка 55-5.
Вот.
Обратное преобразование...
Ну, не так тривиально, я бы сказал.
Такой прям функции, чтобы из строки сделать число.
Но она есть, но там в силу некоторых причин
мы лучше попозже про это поговорим.
Но вот из числа сделать строку вот так.
Можно.
Это c++-ный способ так сделать.
Есть еще функции из библиотеки C,
которые это позволяют делать,
но про них мы тоже попозже поговорим,
пока вот только об этом поговорим.
Ну и второй тип, который мы будем постоянно,
всегда везде использовать, это вектор.
Значит, вектор – это динамический массив,
то есть расширяющийся по ходу дела.
Значит, std-вектор...
он в угловых скобочках имеет параметр от какого типа,
ну, например, от int.
Вот я могу написать std-вектор int v.
Это динамический массив,
то есть массив, меняющий свой размер по ходу программы.
Вот.
Ну, что можно делать с вектором?
Да на самом деле с вектором можно делать все то же, что и со строкой.
Сейчас я проверю, что я вас не обманул нигде.
Ну кроме...
Вот на самом деле все операции, которые я перечислил для строки,
я не буду их даже заново перечислять.
Ну вот все кроме этого актуально и для вектора.
Вот все то, что перечислено на этой странице, актуально для вектора.
То есть я могу вектор делать resize
и говорить, заполни вектор каким-то количеством элементов с таким-то значением.
Вот.
Кстати, я могу сказать resize без уточнения каким значением,
и тогда он будет заполниться значениями по умолчанию, в данном случае нулями.
Вот.
Для int-ов это будут нули.
resize 5 это значит вектор станет из 5 нулей.
Вот.
А могу сказать resize, не знаю, 5 запятая 1,
это значит вектор станет из 5 единиц.
Дальше.
Я могу обращаться по индексу к элементам вектора и менять их.
v3 равно 2.
Теперь мой вектор это будет значит...
Что?
Мой вектор сейчас будет 1, 1, 1, 2, 1.
Потому что третий элемент это вот этот.
Индексация с нуля, разумеется.
То же самое у меня есть функция add,
чтобы обратиться по индексу с гарантией проверки, что я не вышел за пределы.
Если я выхожу обращать по индексу за пределы вектора,
опять это неопределенное поведение,
может случиться что угодно,
может я получу случайное значение, может я упаду.
Я могу делать pushback, могу делать popback.
То есть могу докладывать элементы в конец вектора,
могу вынимать элементы с конца вектора.
Кстати, да, что будет, если я сделаю popback от пустого вектора?
Неопределенное поведение.
Ну, скорее всего, тут я упаду,
ну, программа упадет, но может и не упадет.
Непонятно.
Может что угодно произойти.
Хорошо.
Ну, наверное, это все, что я расскажу про вектор сейчас.
Больше пока ничего не буду рассказывать,
но, возможно, вы на семинарах уже больше успели поделать.
Для нашей цели больше ничего не надо будет знать про него пока, в ближайшее время.
Потом мы, конечно,
со временем мы изучим подробно, как он устроен изнутри
и даже почти напишем его сами,
но пока нам достаточно.
Можно вопрос?
Да, конечно.
Вектор – это то же самое, что лист в питоне?
Ну, идеологически да.
Понятно, что там есть много нюансов,
как они устроены чуть-чуть по-разному,
но по смыслу да.
Вектор в плюсах – это, по сути, лист в питоне.
Но не путайте, пожалуйста, лист в плюсах.
То, что в плюсах называется лист,
это совсем не то же самое, что в питоне лист.
То, что в плюсах называется лист,
это на самом деле линк к лист,
и это совсем другая по смыслу структура данных, чем вектор.
Поэтому, соответственно, такой вектор из плюсов – это лист из питона,
а лист из плюсов – я даже не знаю,
в питоне есть аналогичный тип или нет.
Кто знает, может, скажет, линк к листу питоне.
Я не помню.
Ну ладно.
Хорошо.
Так.
Ну, еще я вам должен рассказать про литеральные суффиксы.
Значит, что такое литеральные суффиксы?
Что вообще такое литералы?
Литералами называются последовательности символов,
которые кодируют некоторое фиксированное значение какого-то типа.
Например, я могу написать, не знаю,
один – это литерал,
5.0 – это литерал,
ABC – это литерал.
Вот такие последовательности символов называются литералами.
True – это литерал.
А у литералов предопределен тип.
Вот если вы пишете литерал просто в последовательстве цифр,
то это int.
Вот у такого литерала тип double.
Вот у такого литерала тип...
Ну, тип такого литерала называется const char звездочка,
или даже точнее const char массив,
но забьем...
Ну, это строка.
Потом поговорим о том, что это значит.
Вот у такого литерала тип bool.
У такого литерала тип double, как я уже сказал,
у такого литерала тип int.
Вам иногда бывает, может, хотеться сделать,
чтобы типом литерала считался float, например, а не double.
Вот для этого есть литеральные суффиксы.
Когда вы пишете дробное число вот так, через точку,
оно по умолчанию считается типом double,
но вы можете написать post fix f, ну, суффикс,
и это будет означать float.
То есть вот такой литерал будет тип float, считаться, а не double.
Вот. Еще полезно, например, иногда делать так,
чтобы литерал считался типом unsigned.
Вот вам, возможно, хотелось бы, чтобы литерал считался не тип int,
а тип unsigned.
То есть тогда у вас есть суффикс u.
Что еще скажу я про литералы?
Еще можно в плюсах записывать целые числа
в 16-ричной или в 8-ричной системе.
И даже, по-моему, начиная с какой-то версии, можно в 2-ричной,
но я все время забываю, с какой и можно ли.
Но точно можно в 16-ричной.
Вот если вам почему-то нужно записать целое число в 16-ричной системе,
то вы просто начинаете его с 0x.
Например, вы пишете 0xff, и это означает 255.
Если вам надо записать число в 8-ричной системе,
вы пишете, например, 0123.
Значит, в 8-ричной системе, чтобы записать число,
надо просто его с нуля начать.
Вот если у вас литерал целое число начинается с нуля,
значит он как будто компилятором в 8-ричной системе считается записанным.
0123 это, соответственно, 64 плюс 16 плюс 3.
Да, это 83 будет десятично.
Еще полезное знание, что можно использовать
одинарную кавычку или апостров
для того, чтобы отделять разряды.
Вот, например, если у вас есть длинное число там,
ну, не знаю, миллион сорок восемь тысяч пятьсот семьдесят шесть,
то вы можете, начиная си плюс плюс четырнадцать, правда,
вот так писать,
ну, то есть ставить апостров между как бы цифрами
для удобства чтения.
И это будет компилятором правильно читаться,
как целочисленный литерал просто удобнее читать стать.
Ну, 16-ричная система FF это сколько?
Это получается 16 умножить на 15 плюс еще 15.
240 плюс 15, 255.
Ну, это максимальное значение, которое в один байт влезает, FF.
Это полезно помнить, что это 255.
Ну, и здесь же давайте я вкратце скажу про стандартные приведения типов.
Ну, я, возможно, уже говорил в прошлый раз,
так, очень скользко,
но давайте еще раз проговорим это на всякий случай.
Что происходит, если вы складываете или там вы читаете два числа,
ну, или две переменных чуть-чуть разных типов.
Если они оба целочисленных типов,
то у вас происходит поднятие до того, который больше по охвату.
Вот, это называется integer promotion.
Это стандартное преобразование,
то есть когда вы, например, складываете чар с интом,
то результат получается инт.
Если вы складываете инт с лонг-лонгом,
то результат получается лонг-лонг.
Ну, логично.
Да, кстати, если вы хотите литеральный суффикс для лонг-лонга,
то пишите ll в конце.
Ну, и можно еще написать ull.
Это будет означать unsigned long-long.
Вот, это называется integer promotion.
Или integral promotion.
Значит, поднятие до...
Это преобразование, которое расширяет тип до более широкого.
Дальше есть floating-point promotion.
Это когда вы складываете float с double.
Float поднимается до double.
Ну, если вам нужно сделать float и double,
то float неявно приводится к double,
и происходит так называемый floating-point promotion.
Кроме того, есть стандартная конверсия.
Если вы, допустим, складываете инт с double,
то инт превращается, перекодируется в double на лету.
И это называется стандартная конверсия.
Ну, стандартная конверсия есть между многими типами.
Например, между int и bool есть стандартная конверсия,
как мы вроде уже обсуждали.
То есть, если вы там по default пишете int,
то он неявно приводится к bool.
Да, ну, понятно, что можно из int получить bool,
а из bool int, по неявному правилу, что...
Ну, я говорил уже в прошлый раз, по какому.
Ну, наверное, это все,
что я хочу сказать вам про стандартные типы
и про операции над ними на текущий момент.
Пока что нам этого хватит.
Вопросики.
В каких случаях используются эти суффиксы?
Ну, я вам могу привести такой пример.
Представьте, что у вас...
Ну, я вам даже два примера приведу.
Скажем, представьте, вы складываете double,
вы складываете float,
вот у вас переменная типа float,
и вы хотите ее сложить с пятеркой.
Если вы так напишете, то произойдет floating point promotion,
как я уже сказал, потому что тип double
нужно поднять это double, сделать,
а потом обратно во float.
То есть тип вот этого выражения double.
И если вы его присваиваете float,
то у вас получится преобразование сначала вверх до double,
а потом обратно обрезание до float.
Если вы хотите оставаться внутри float'ов,
не подниматься до double,
то вам нужно писать вот здесь f,
тогда у вас не произойдет конверсии в double при сложении.
Другой пример, если у вас есть две функции,
не знаю там, функция, которая принимает double
и функция, которая принимает float
с одинаковыми именами,
то когда вы вызываетесь от вот такого параметра,
вы попадете в версию, которая double принимает.
А когда вы вызываетесь от такого параметра,
вы попадете в версию, которая float принимает.
Ну и банально, например...
зачем может быть нужен суффикс u?
суффикс u очень полезен
когда вы делаете операции с целыми числами.
Ладно, суффикс у, наверно, мой пример не актуален.
Ну вот если вы складываете знаковое целое число
и беззнаковое целое число,
то у вас происходит
неявное преобразование их беззнаковому.
Вам, возможно, нужны суффиксы для того, чтобы явно сказать, какой вы хотите тип
результатов. То есть, просто когда вы не хотите, чтобы у вас неявно происходило
преобразование между разными видами целых чисел, вы пишете суффикс, чтобы типы
были точно одинаковые, и тогда у вас никаких неявных преобразований не
происходит. Но обычного для этого не нужно.
Почему в одном месте 0x, а потом просто 0?
Еще раз, 0x это если вы хотите в 16-ричной системе записать, а просто 0 это если в 8-ричной.
Спасибо.
Это все ИН.
Да.
А лонг-лог можно?
Не знаю, кстати.
Не знаю, можно ли в 16-ричной системе записать лонг-логи.
То есть, можно ли писать 0xffll?
Не знаю, можете попробовать.
А можно суффиксы для лонг-лога использовать для ИНТ и написать?
Да, по-моему нет суффикса, потому что литерал и так имеет тип ИНТ,
если вы его написали без каких-либо суффиксов.
Но для разных, но для других типов есть свои суффиксы,
можете посмотреть на cp-reference, там их достаточно много.
Но для ИНТа не нужен суффикс, потому что он и так ИНТ в умолчании.
Получается, если мы сложим ИНТ и unsigned, то получится...
Да, если вы складываете ИНТ и unsigned-ИНТ, то происходит приведение consigned-ИНТ.
Это приводит иногда к неприятным последствиям,
потому что если вы складываете, например,
минус один с unsigned-ИНТ, то минус один превращается в 4 миллиарда,
происходит переполнение, прыжок через максимум,
и это приводит к неприятным последствиям.
Будьте аккуратны, когда складываете значения разных типов, не совпадающих.
Компилятор вам, возможно, даже предупреждения выдаст, если вы так делаете.
Так, ладно, давайте пойдем дальше.
Дальше параграф 1.3, и тут я, наверное, перейду к кодированию.
Следующий параграф будет называться объявления, определения и области видимости.
Ну, я буду стандартно начинать свои изыскания с вот таких заготовочек программ.
По-английски это называется declarations, definitions and scopes.
Ну, смотрите, давайте, после того, как мы обсудили,
какие бывают переменные в программе, поговорим о том,
и что вообще состоит программа на плюсах.
Программа на самом деле состоит из объявлений, как ни странно.
Ну, когда вы пишете программу на плюсах, вы на самом деле,
все, что вы делаете, это на глобальном уровне, на верхнем уровне,
вы просто объявляете сущности раз за разом.
Ну, вы можете что-то заинклудить, но если вы что-то инклудите,
то по факту вы же все равно, извините.
Ну, что такое include.io stream?
Это какой-то файл, в котором тоже что-то объявлено, там нет ничего,
в котором тоже что-то объявлено, там namespace какой-то,
и внутри него что-то там объявлено.
По сути, когда вы делаете include,
это значит, что вы просто вставляете в код вашей программы содержимое этого файла.
Но если забить на include, то все, что вы делаете в дальнейшем,
это просто вы объявляете какие-то штуки подряд.
Вы можете объявлять переменные, вы можете объявлять функции,
вы можете объявлять классы, вы можете объявлять namespaces,
ну, еще разные вещи вы можете объявлять,
и по сути на верхнем уровне ваша программа не состоит из этих объявлений.
Но вот то, что у нас сейчас написано, это просто объявление функции main,
но можно кроме функции main еще что-нибудь пообъявлять.
Я могу объявлять переменные.
Я могу, например, сказать int x вот глобально, вот здесь, вот на верхнем уровне.
Я могу объявлять и другие вещи.
Ну, кроме переменных и функций, я еще могу объявлять, как я уже сказал, классы,
чтобы это не значило.
Вот я могу написать классы, c.
Это я объявил class сейчас.
Я могу объявлять структуры, struct s.
Это я объявил некоторую структуру s.
Не важно, что это такое вообще, это нас сейчас даже не интересует.
Важно, что пассивность ссо, что я делаю, это я просто объявляю сущности подряд раз за разом.
Вот.
Ну, какие еще бывают виды сущностей, классы, структуры там и прочее, это мы потом пообсуждаем.
Сейчас суть в том, чтобы понять, что на самом деле программа это пассивность объявлений.
И давайте поподробнее поговорим про объявление переменных и про объявление функций.
Ну, про объявление переменных, в общем-то, особо нечего, наверное, говорить.
Что такое объявление переменной?
Это просто тип, а потом имя переменной и точка запятой.
Возможно, имя переменной делается с инициализацией.
Например, вот так я могу написать.
Тип, имя равно чему-то.
Это не просто объявление, это инициализация еще.
Вот если я в глобальной области, вот эта вот область, которая вне всех функций, вне всяких там фигурных скобочек, называется глобальной.
Вот это называется global scope.
Scope переводится как область видимости.
Вот то, что здесь находится, это глобальная область видимости.
Если я в глобальной области видимости объявляю переменную, то она по умолчанию инициализируется нулем.
Ну, in, я имею в виду.
Если bool, то false.
Ну, в общем, если я какую-то переменную стандартного типа объявляю встроенного, то она инициализируется нулевым значением для себя в глобальной области.
Если я так делаю внутри мейна, то это уже неверно.
Вот здесь уже неверно, что будет ноль обязательно.
Вот здесь может быть рандомное значение.
Но здесь обязательно ноль.
Ну, если я объявляю строку или вектор, то она инициализируется пустой строкой, соответственно, пустым вектором.
Причем это уже не зависит от того, где я объявляю глобально или вот здесь, локально.
Значит, вот эта область, которая внутри функции называется local scope, локальная область видимости.
А это глобальная область видимости.
Хорошо. Ну, про объявление переменных, наверное, все понятно.
Тип и название.
Но я могу еще через запятую несколько объявить за раз.
Я могу сказать там x запятая y.
Это я, значит, объявил сразу две.
Причем я могу вот так сделать, разное значение придать.
Но по кодстайлу не рекомендуется так делать.
Я вас буду отучать объявлять несколько переменных на одной строке, потому что это затрудняет читаемость.
И лучше, ну, в общем, современный кодстайл обычно рекомендует так не писать.
Мы тоже будем стараться так не писать.
За редким исключением.
Вот. Давайте поговорим об объявлении функций.
Ну, что такое функция, думаю, вы все знаете.
Это школьная программа.
Вот. Мы с вами пока знаем только одну функцию main, но я могу объявлять другие функции.
Ну вот, давайте я объявлю какую-нибудь функцию f.
Функция точно так же начинается с возвращаемого типа.
Потом идет имя функции и в скобочках типа аргументов.
Функция может ничего не возвращать.
И тогда типа ее возвращаемого значения void.
Вот void это специальный такой тип, который означает, что функция не возвращает ничего.
Void, собственно, переводится как пустота или вакуум.
С английского, если кто не знал.
Ну вот, я могу написать void f.
Дальше я открываю скобочку и перечитаю аргументы.
Например, void f от int, запятая double.
Ну, я могу этим аргументам имена придать.
Например, могу сказать вот так int a, double b.
Но если я объявляю функцию, я могу имена переменных и не называть.
Я могу просто типа указать, а не обязательно называть имена.
Имена мне нужны только если я пользуюсь этими именами.
Если я определяю функцию.
А если я просто вот так объявил, сказал, что есть какая-то еще функция f, которая принимает int и double,
то имена не обязательно писать.
Я буду часто так делать.
Пропускать имена, если они не нужны.
Имена переменных я имею в виду.
А как тогда обращаться к аргументам внутри функции?
Так, если я не собираюсь...
Вот сейчас я просто объявил функцию и не собираюсь ни к чему обращаться.
А если я в дальнейшем ее буду определять и уже использовать аргументы,
то тогда я начну.
Тогда я дам имена.
И это ничему не мешает.
Вот, здесь как раз мы приходим к разнице между объявлением и определением.
Вот то, что я сейчас сделал, это просто объявление функции.
Я просто сказал, что есть такая функция, но еще не объяснил, что она делает.
Тем не менее, компилятор с этого момента уже значит, что такая функция есть.
Но я могу потом определить эту функцию.
Определить функцию, это значит написать ее тело.
То есть после сигнатуры, вот это называется сигнатурой, набор аргументов принимаемых и имя,
я пишу фигурную скобочку и определяю тело.
То есть, что делает эта функция?
Ну, например, выводит все аут, не знаю, hello, а потом говорит a плюс b.
И еще перевоз шаги.
Тут происходит неявная конверсия типов, как вы понимаете, int double.
И я могу вызвать эту функцию f от 1 запятая 3,5.
Получилось 4,5.
Ну, понятно, сложился int с double, получился double.
Вот. Заметьте, что когда я определяю функцию, я уже аргументы использую.
А пока я ее объявлял, аргументы мне были не нужны.
Я мог, вообще говоря, даже не использовать и здесь какой-то из аргументов,
просто сказать вот так.
То есть я функцию аргументов передал, но в реальности его не использовал.
Ну, бывает.
Просто функция принимает два аргумента, но в реальности использует только один.
Такое тоже вполне себе легально, и так можно делать.
И на самом деле такое даже бывает иногда нужно делать,
когда-нибудь у вас такие ситуации возникнут.
А можно не писать int double во втором?
Нет, нельзя.
Вот типы аргументов обязательно надо перечислить заново,
а имена можно уже... можно другие имена вообще дать.
Например, у меня здесь был int c double d, а тут я сказал int a double b.
И ничего страшного.
При повторных объявлениях я могу имена менять,
но типы должны быть такими же.
Хорошо.
Да, я сказал, типы должны быть такими же.
Но на самом деле я могу объявить функцию и с другими типами, но с таким же именем.
Например, я могу сказать voidev от int float.
Но это будет уже другая функция.
Я могу объявить разные функции, у которых одинаковые имена,
просто типы аргументов разные.
Вот в данном случае вот это f, и вот это f — это разные функции.
И они могут делать разные вещи.
Это называется перегрузка функций.
Это очень важная возможность,
это одна из важнейших возможностей языка C++ и всех C подобных языков,
что можно иметь несколько функций, у которых одинаковые названия,
но разные типы принимаемых аргументов.
И на самом деле это то, чем вы постоянно пользуетесь, даже не думая об этом.
Этим мы будем постоянно пользоваться, и это очень удобно.
А когда вы делаете какую-нибудь операцию над чем-то,
ну я не знаю, там sort, сортировка,
или банально, господи, не знаю, two string, приведение к строке,
вы же не называете операцию по-разному в зависимости от того,
вы же не называете операцию по-разному в зависимости от того,
что вы передали.
Например, представьте, что у вас функция перевода int в строку
называлась бы одним способом, а double в строку другим способом.
Ну нет, они обе называются two strings.
Логично, что вы, наверное, хотите, чтобы функция называлась одинаково,
а работать умела с разными типами.
Совсем дикий пример.
Например, вы умеете складывать объекты, вы умеете сделать плюс.
Вы же не хотите, чтобы плюс для int это был плюс одного вида,
а плюс для doubles это плюс как-то по-другому выглядящий.
Нет, они оба называются одинаково,
просто работают с разными типами.
Это две разных операции, на самом деле.
То же самое и здесь.
Мы всегда будем, и часто это очень удобно,
делать функции, которые называются одинаково, но принимают разные аргументы.
Это нормально, абсолютно.
Это называется function overloading.
Допустим, эта функция у меня будет выводить high.
Та функция выводила hello, а эта функция будет выводить high.
Здесь а непонятно, что такое, потому что я не передал значение.
Пусть здесь тоже будет а.
И вот смотрите, что происходит.
Если я вызвался от int и double, то я попал в первую функцию.
А если я напишу так, 1.3.5f,
вы меня спрашивали, на что могут влиять литеральные суффиксы.
А вот на что.
Теперь я попаду во вторую функцию.
Вам видно, я надеюсь?
В первом случае я вызвался от int и double,
во втором случае я вызвался от int и float.
Это две разных функции, которые делают разные вещи.
Хорошо.
Мы с вами еще поподробнее поговорим о перегрузке функции попозже.
На самом деле, здесь есть много подводных камней.
Я даже...
Сейчас я...
Сейчас задать один вопрос.
Есть много подводных камней.
Например, что если у меня функции, которые...
Ну вот скажем...
Представьте, у меня есть функция, которая от double и от long double.
А я от float вызвался.
Что будет?
Какая выберется?
Вот тут начинаются так называемые...
Вступают в действие правила перегрузки функций.
Правила выбора версии.
Если я вызываюсь от аргументов,
и у меня нет точного соответствия типов аргументов типом того,
от чего я вызвался,
то начинает компилятор делать так называемую...
Overloading Resolution.
Разрешение перегрузки.
То есть он смотрит на имеющиеся версии
и решает, какая из них наиболее подходящая.
Ну вот в данном случае наиболее подходящая будет первая,
потому что конверсия от float в double
это как бы меньше зло, чем конверсия от float в long double.
То есть там есть очень длинный и сложный список правил.
Вы можете открыть на себе переференцию статью
Overloading Resolution Rules
правила, по которым компилятор решает,
что является более легким преобразованием.
От float до double поднять это меньшее преобразование,
чем от float до long double.
Поэтому в данном случае он выберет
от float до double поднять.
Но если я например...
Если у меня есть функция от int и float,
и значит, ну я не знаю...
Ну хорошо, вот представьте, у меня вот такие две функции.
У меня есть функция от int и char
и функция от int и float.
И я решил вызваться от int и double.
То в данном случае у меня будет ошибка компиляции вообще.
Потому что преобразовать double к float
и преобразовать double к char
считается одинакового ранга плохими преобразованиями.
То есть и то и другое это стандартная конверсия,
и у них одинаковый ранг, так называемый.
Они оба находятся в числе стандартных конверсий,
сужающих диапазон.
Поэтому выбор между ними сделать не получится.
А, нет. Ух ты, я вас обманул.
А, нет. Извините.
Сейчас объясню, что произошло.
Мне нужно еще вот эту версию документировать.
Вот, выбор между ними сделать не получится.
И видите, какая ошибка.
Call of overloaded effort and double is ambiguous.
Вызов функции неоднозначен.
Непонятно, какую функцию вызвать.
Вы на самом деле будете сталкиваться с этой ошибкой очень часто.
Вы будете...
Что там, беды какие-то?
Да не то, что все хорошо.
Вы будете часто сталкиваться с ситуацией,
что вы вызываете какую-то функцию,
и у вас ошибка со словами это ambiguous call
и дальше длинный-длинный список кандидатов.
Кандидат такой, кандидат такой.
Значит, это означает, что у вас было много разных версий
от хитипов вызваться.
И то, от чего вы попросили вызваться, неоднозначно
можно тактовать как вызов от того или от всего.
Вот. Запомните эту ошибку,
вы с ней много раз в жизни встретитесь, скорее всего.
Какой был вопрос? Подождите, да.
Вы сказали, что можно объявлять функцию несколько раз,
а какое тогда trio определение будет staggering?
Нет. Я сказал, что можно объявлять функцию несколько раз.
А также можно объявлять функцию с разными типами аргументов.
Но нельзя определять одну и ту же функцию,
несколько раз.
Значит, вот если я попробую определить
функцию с такими же типами аргументов еще раз,
это будет ошибка компиляции.
Я не могу переопределить функцию с такими же типами.
Но с другими типами я ее могу переопределить.
Просто это будет другая функция уже на самом деле.
Ну и что, что она называется так же?
Функция это другая.
Она другая, потому что тип аргументов другие.
Это другая функция.
Объявлять с теми же аргументами?
Вот.
Объявлять с теми же аргументами можно.
А если мы уже определили и после этого объявлять все еще можно?
Все еще можно.
А что за теги?
Что?
А что она делает на теги?
Не на что.
Вот.
Давайте сейчас как раз об этом поговорим.
Это хороший вопрос.
Хороший следующий пункт для обсуждения.
Сейчас мы поговорим о разнице между объявлением и определением.
Вот я вам сказал, что есть понятие declaration и есть понятие definition.
Вот то, что я написал здесь, это declaration, not definition.
Я объявил функцию от Intdouble, но не определил ее.
А вот это определение.
Любое определение является объявлением.
Значит, если я что-то определяю, я тем самым его и объявляю.
Но обратное неверно.
Вот, например, я могу объявить, но не определить.
Вот в данном случае у меня объявлено три разных функции.
f от Intdouble, f от Intfloat и f от Intchar.
Определены только две из них.
Вот в данном случае, вот сейчас я поясню, какая ошибка произошла,
на самом деле, когда я вот так сделал вот эту вот ошибку.
Видите, что произошло?
Я просто забыл, что у меня есть еще вот эта функция.
И я вызвался от Intdouble.
У меня на самом деле есть функция от Intdouble, просто она не определена.
И у меня не случилась ошибка неоднозначности.
У меня все однозначно, потому что компилятор выбирает версию от Intdouble.
Она же есть.
Но у нее нет определения.
И поэтому я сталкиваюсь не с ошибкой того, что вызов неоднозначен,
а с тем, что, ну, так называемая undefinedReference, то есть неопределенная ссылка.
У меня функция эта есть, но определения у нее нет.
И поэтому вызывать нечего.
Вот эта ошибка undefinedReference2 и дальше написано что?
Означает, что вы попробовали вызвать функцию, которая была объявлена, но не определена.
С такой ошибкой вы тоже будете наверняка часто сталкиваться.
И это на самом деле ошибка, которая относится к ошибкам лимковки, а не компиляции.
Но я сейчас не буду пояснять разницу.
Просто запомните, что вот есть еще такая ошибка.
Она означает, что вы функцию объявили, но не определили и пытаетесь использовать.
Я могу сколько угодно раз объявлять одну и ту же функцию, но определить только один раз могу.
Я могу хоть 100 раз подряд написать voidef at endouble и все будет нормально работать.
А если один раз написать от endouble, только объявить ее, а другой от initial?
Пожалуйста, я объявил две разных функции.
От вопроса.
Значит, вот я сейчас сделал и, пожалуйста, все работает.
Ну, то есть ошибка осталась та же самая, что я вызываю функцию, которая не определена.
Я ее сто раз объявил, но ни разу не определил.
Это не страшно.
Объявлять я могу сколько угодно раз одной и той же.
Определить только один раз могу.
Да?
Вопрос?
Обычно после программы функции определяют их.
И допустим там, ну, штук десять функций разными аргументами.
Да.
Но что про это?
Нам сначала надо сказать, что они есть в самом начале.
И как сделать?
Вы же любом на каждый аргумент заново писать и определить.
Что вы имеете в виду?
В смысле, откуда у вас определения возьмутся?
Ну, у вас есть определение где-то внизу или как?
Просто в конце он пишет функции, а в начале вы только заголовки получаете.
Ну, короче, ну нет.
Вы должны все объявления перечислить до использования.
Вот.
Вы должны объявить функцию до ее использования обязательно.
Вот, смотрите.
Если я попытаюсь вызвать какую-то функцию до того, как она была объявлена,
это ошибка компиляции.
Вот.
Давайте я это все удалю.
Ну, вот представьте, я не знаю, вот у меня еще какая-нибудь функция G сейчас будет.
Которая вообще ничего не делает.
Вот я сейчас не могу вызвать отсюда функцию G.
Вызывать функцию я могу только до, только после их объявления.
Смотрите, какая ошибка.
G was not declared in this scope.
Именно declared.
Здесь сказано, G была не объявлена в этом scope.
И scope это область видимости.
В этом scope не была объявлена функции G.
Но вот после того, как она была объявлена, я ее уже могу вызывать.
И если бы я ее объявил вот здесь, я бы ее тоже мог вызывать, несмотря на то, что она определена потом.
То есть вызвать функцию я могу после того, как она объявлена, а определение когда-нибудь потом написать.
Зачем это нужно?
Это нужно для того, чтобы вы могли, например, делать перекрестную рекурсию.
Вот, смотрите, представьте, что у вас есть две функции, и вам нужно из F вызывать G, а из G вызывать F.
Если бы нельзя было объявлять до определения заранее, то это бы никак не получилось сделать.
Вот, поймите этот пример.
Но он будет, если я определил ее после вызовов, все равно искать до определения.
То есть, я бы еще и после, но...
Да, вы можете из функции F вызывать G, а из G вызывать F.
Для этого вам надо одну из этих функций сначала объявить, но не определить, потом определить вторую, а потом определить первую.
Тогда у вас и будет корректно работать, несмотря на то, что определение написано после объявления,
но вызывать вы уже можете тогда, когда было объявление, а определение потом найдется.
Вот так это работает.
Функции в конце определены, ну допустим fint double или fint for, она сначала их объявить получается, да?
Да, перед тем, как вы их будете использовать, они должны быть объявлены, а определены могут быть где-нибудь потом.
А можно допустим fint 2 объявить, а она будет только, только после того, что она будет сразу идти к ним, получается?
Вопрос, что это существует?
Тогда у вас будет считаться, что только она существует, а та не найдется.
То есть, наверное, каждый будет существовать?
Все нужно объявить до использования.
Окей, давайте дальше.
Так, что-то еще хотел сказать, наверное, и забыл.
Да не, ничего больше хотел сказать.
А, вот что хотел сказать.
Нельзя функции определять внутри других функций.
Формально можно объявлять, но это бессмысленно.
Ну, короче, считайте, что, в общем, я не могу внутри функции другую функцию определить.
Вот так нельзя.
C++ и C тоже.
Вот в каком-нибудь Паскале, прости господи, можно было там, вы могли функцию объявить внутри другой функции и там же определить.
Тогда она была бы локальней для этой функции.
В C, в C++ нет.
Функции можно объявлять только снаружи функций, не внутри.
Соответственно, внутри мейна определить новую функцию, которая мне только для мейна нужна, я не могу.
Вот, следующая вещь, это затмение имен.
Вот это я, наверное, сопру.
Все, чтобы мне не мешало дальше примеры рассматривать.
Сейчас еще немного поговорим про переменные.
Вот смотрите, у меня есть переменная X, глобальная.
Я могу локально объявить снова X.
И вот здесь X будет означать тот X, который я объявил последним.
Это не ошибка.
Я могу в разных областях видимости объявлять переменные с одинаковыми именами, и ничего страшного.
Будет один.
Более того, я могу внутри локальной области видимости начать новую область видимости.
И там снова повторить имя.
Я могу просто вот так сделать.
И тут объявить еще один X.
И теперь этот X будет два.
А если я здесь выведу X, это будет один.
И это все не ошибки.
То есть я могу повторять имена переменных в новых областях видимости.
И они будут затмевать предыдущие имена переменных.
Но вот если я здесь выведу X, то выведется один.
То есть до того, как я объявил вот этот X, у меня действует предыдущий X.
Как только я объявил новый X, начинает он действовать.
А здесь снова один.
Вот тут один, вот тут два, вот тут один.
Но это немножко кринж, возможно, но вот как уж есть.
В джаве так нельзя делать, а в плюсах можно.
Да, это все три разных переменных.
Это разные переменные, ну и что они называются одинаково?
Называются они одинаково, но в памяти они разные места занимают.
И у них даже типы разные могут быть.
Я могу запросто здесь сказать, что это вообще double, а не X.
А не им. Double равно два с половиной, тогда это будет вполне два с половиной.
Все нормально.
Бывает так, что я хочу из локальной области видимости обратиться к имени,
которая взята из глобального скопа, а не из локального.
Тогда я могу написать двоеточие двоеточие перед именем переменной.
Вот так.
Это будет ноль.
То есть, где бы я ни находился, я могу достать из глобальной области видимости X, который был глобальным.
Двоеточие двоеточие перед именем переменной означает, что я хочу взять ее из глобального скопа.
Ну так можно не только с переменными делать, так можно и с функциями делать, и с классами,
но с функциями у нас пока нет такого примера.
В общем, так можно делать с переменными.
А промежуточную никак нельзя достать.
Вот глобальную можно достать и самую последнюю, а промежуточную нет способа достать.
Вот, ну и еще одна вещь, про которую я сейчас поговорю, это юзинги и пространство имен.
Ну я вкратце про них поговорю.
Я могу объявлять пространство имен.
Вот зачем это нужно?
Дело в том, что когда у меня большая программа, большой там какой-то проект,
у меня часто бывает так, что пересекаются имена разные.
Ну то есть у меня в проекте может быть много фонариков,
которые называются одинаково, они просто разные вещи делают по смыслу.
Ну у меня там или классы, которые называются одинаково, они разные,
но они называются одинаково просто потому что, ну не знаю,
у меня может быть там какой-нибудь point, структура point,
которая обозначает точку на плоскости.
У меня может быть в проекте, в моей кодовой базе, может быть очень много классов,
называющихся point.
в моей кодовой базе может быть очень много классов,
называющихся point. Или у меня может быть много
переменных, которые называются там, много функций,
которые называются, я не знаю, distance, расстояние.
Не то, что они от разных типов, они могут быть
и от одинаковых типов, и все равно делать разные вещи.
Просто они как бы из разных частей проекта,
и так совпало, что у них одинаковые имена.
Они просто для разных мест, для разных кусков кода нужны.
Извините, а ты одинаковый? Ведь нельзя две разные?
Нельзя, в том-то и дело. Я говорю, мне может хотеться,
поскольку у меня очень большой проект, и он существует 5 лет,
у меня может быть два разных функций distance,
мне может хотеться делать две разных функции с одинаковым названием,
с одинаковыми типами, но делающих разные вещи.
Просто они из разных мест приходят.
Ну, например, у меня может быть, или у меня может быть string,
например, строка, у меня может быть std string,
а не обе, я хочу, чтобы назывались string,
но они были чуть-чуть с разными свойствами, это нормально.
Когда проект большой, когда кодовая база большая,
в ней много может быть разных имен совпадающих.
И как раз для того, чтобы разделять эти имена,
чтобы они не образовывали коллизии, чтобы не было вот этих вот
конфликтов имен, что нельзя повторять имена,
у меня существует пространство имен.
Я могу объявить namespace, ну, допустим, n,
допустим, n большое, и в нем объявлять какие-то имена.
И вот имена, которые внутри этого namespace не будут
конфликтовать с именами, которые в другом namespace.
То есть я могу здесь объявить какую-нибудь функцию,
не знаю, но вот я могу здесь объявить voidf от int,
которая говорит std cout, ну, вот этот int, допустим,
она выводит на экран.
Вот, и у меня может быть другой namespace,
и в нем будет другая f, тоже от int,
которая выводит на экран не от int, а его на 1 увеличено.
Вот это не ошибка, потому что я эти функции как раз
якобы разнес их по пространству имен.
Пространство имен — это вот такой набор имен,
которые живут отдельно вот от других.
Вот эта f, вот с этой f не конфликтует.
Это не является ошибкой повторного определения,
потому что это функции из разных scope'ов.
Вот scope, который здесь, называется namespace scope.
Вот это вот global scope, то, что вообще вне всех
фигурных скобок, вот это namespace scope, а вот это
уже local scope, то, что внутри функции.
И это тоже local scope.
Понятно про пространство имен?
Ну, идея, зачем надо, чтобы имена не конфликтовали,
не пересекались. Таким образом, у меня может быть
очень много сущностей, называющихся одинаково,
но они как бы из разных подмножеств взяты,
из разных множеств имен, и поэтому они не конфликтуют.
А можно ли использовать функцию f, которая задана
в namespace n, например, за пределами…
Да, конечно, разумеется.
Иначе, как бы вы к стандартной библиотеке обращались.
Ну, вы всегда это и делаете, разумеется.
Что такое std? Это и есть пространство имен.
Давайте я вам еще раз покажу iostream, как выглядит.
Файл iostream, он в себе содержит объявление namespace std.
Вот это вот macros, который для компилятора говорит,
что у этого стандартная видимость,
то есть, что имена отсюда должны быть видны.
Ну, в общем, забейте на этот macros,
это просто некоторая подсказка компилятора.
Вот namespace std, фигурная скобка открылась,
и вот все эти штуки здесь объявлены.
То есть, на самом деле, когда вы используете cout,
или когда вы используете string,
или когда вы используете любую штуку,
вы берете ее из namespace std.
И вы говорите всем самым, что пишет std.
Как раз для того, чтобы вот эти имена не пересекали.
Если я захочу в своей программе создать какую-то переменную
и назвать ее cout, это не будет ошибкой,
потому что переменная с названием cout,
объявленная в namespace std, она не будет конфликтовать с моей.
Откуда вы берете список на namespace?
Что значит список на namespace?
Ну, вот std он знает.
Нет, он не знает.
Что значит знает?
У меня вверху написано include eostream.
Include означает буквально следующее.
Возьми файл eostream.
Eostream это прям файл, который на моем компле находится вот по такому адресу.
В такой папке он лежит.
В этом файле написано namespace std, фигурная скобка открылась,
и что-то объявлено.
Когда я пишу include eostream,
он берет файл eostream и копипастит его содержимое мне в программу.
После расшифровки этого include у меня в программе прямо написано
namespace std, фигурная скобка открылась,
и объявлено какие-то вещи.
Никто заранее ничего не знает.
И namespace std тоже заранее не знает.
Просто за счет того, что я написал include eostream,
у меня как бы добавилось объявление namespace std,
и в нем что-то наобявлено.
Поэтому он знает, что cout был объявлен на namespace std.
Точно также я могу написать namespace n,
и в нем что-то объявить, а потом это использовать.
Но заранее никаких namespace он не знает.
Понятно?
Вот.
Хорошо.
Да.
Можно ли просто объявить функцию в namespace,
а потом определить ее в name?
Да, но тебе для этого придется уточнить,
что ты определяешь функцию из того самого namespace.
Смотрите.
Да, смотрите.
Я могу.
Вот если я хочу использовать функцию из другого namespace,
мне надо явно указать из какого.
То есть если я в этом namespace, допустим,
буду говорить g,
и тут буду говорить,
вызови ко мне f,
то будет понятно иметь в виду вот это f.
Но если я хочу взять функцию f
из другого namespace,
мне нужно явно сказать из какого.
Как это сделать?
Ну вот так.
Название namespace и название функции.
Ну или переменной.
Так я разве объявил?
Я вызываю его сейчас.
Я использую ее.
Какое же это объявление?
Да.
А.
Так это я внутри namespace,
а не внутри функции.
У меня функция f,
которая делает вот это.
Я продолжаю оставаться в namespace,
но уже не внутри функции f.
Я сейчас нахожусь в namespace,
но не внутри никакой функции.
Вот.
А здесь я использую функцию f.
Если я просто напишу f,
то это будет браться, конечно,
из того namespace, в котором я сейчас.
Но я могу сказать, возьми из другого.
Для этого мне нужно явно сказать из какого.
Это делается вот так.
Где?
Могу ли я в namespace n
определить функцию
из другого namespace,
не выходя из этого?
Ну это довольно криво так делать.
Честно говоря,
я не уверен точно,
но не знаю, давайте я даже не буду думать.
Не хочу так делать.
Кто не нулевой?
f это аргумент функции, его принять надо.
А!
Это ошибка компиляции, конечно.
Это я ошибся.
Я не могу вызывать f без аргументов,
если я понимаю, что это аргумент, разумеется.
Мне нужно от аргумента вызываться, это просто ошибка.
Да.
Отличный вопрос.
Сейчас про это поговорим.
Ну,
он берет из того, в котором мы сейчас находимся,
а если мы хотим из другого, то значит он берет из другого.
На самом деле, комбинации
namespace правила очень сложные,
и мы их,
они настолько сложные,
что можно
три лекции читать только об этом,
надо просто вовремя остановиться.
Мне нужно вовремя остановиться, иначе мы так до конца лекции
про это будем разговаривать.
Смотрите,
я могу,
да, вы спрашивали сейчас,
вот вы спрашивали, богу ли я
функцию
объявить внутри namespace,
а
определить внутри него. Да, могу.
Для этого я должен
значит
Господи, ты боже мой.
Так, ладно, я не умею удалять до конца строки,
к сожалению.
Ну, для этого я должен написать так, void,
а дальше уточнить,
из какого namespace, и вот тут я могу ее определить уже.
Обратите внимание,
что я,
что имя full, что вот это вот,
вот это n2.2. это часть имени.
То есть, как бы вот, я говорю,
что я определяю f из n.
Я не пишу n2.2,
а потом тип.
Тип всегда идет первым, а дальше я имя называю.
Вот это вот часть имени.
Хорошо.
Последнее,
что я скажу, это юзинги.
Вот, мы можем объявлять,
определять namespace,
и еще есть юзинги.
Да.
Да, я вот сейчас определяю эту функцию.
Объявил я ее вот здесь, а потом решил
определить вот здесь.
Она считается, что все еще
принадлежит namespace,
для нее все те же правила.
Будет вызываться.
Конечно.
Определение может быть после объявления.
Главное, что она объявлена в namespace.
Я уже сказал, не важно, где она определена.
Объявлена в namespace, значит все,
что будет находиться.
Хорошо.
Последнее, что я скажу, это юзинги.
Я могу
делать объявление
юзинг.
Есть три вида юзингов.
Я могу сказать
юзинг какое-то имя,
я могу сказать юзинг какой-то тип,
и могу сказать юзинг namespace.
Давайте сначала поговорю про юзинг имя.
Я, например, могу сказать
юзинг n 2.2.f.
Что это означает?
Это означает, что теперь я
в глобальную область видимости
добавил f из namespace an.
Теперь, если я
вызываю глобально f
без уточнения, откуда она,
или даже локально,
после того, как я это написал,
все, что ниже идет, поскольку глобально
я это написал,
на все, что ниже идет, распространяется вот это слово
юзинг n f.
Это значит, что теперь, если я вызываю f,
то все будет работать.
Вот это давайте я опять сотру.
Это мне уже не нужно.
Вот, сейчас.
Вот, смотрите, ноль.
Я вызвал f от нуля,
хотя вообще-то f
была из namespace.
Если бы я не написал
юзинг n 2.2.f,
это была бы ошибкой,
потому что нет глобальной такой f.
f was not declared in this scope.
Она была объявлена
в scope внутри namespace,
но не глобально, поэтому я не могу
вызывать ее без уточнения, откуда я ее взял.
А если бы мы написали юзинг выше,
чем определение f?
Но если я написал бы вот так,
то это работает.
Юзинг выше, чем f,
не знаю, думаю, что не сработает.
Не хочу проверять, некогда.
Не знаю, если честно.
Ну, это какая-то тонкость.
Юзинг n f, это значит, что в дальнейшем,
если я пишу f без уточнения,
какую я имею в виду,
то берется из n.
Вот, дальше начинается
в общем, стандартная
история, а что если?
А что если бы у меня
при этом еще была f глобальная,
то что бы было?
Ну, тогда бы они...
Вот если бы у меня еще была, допустим,
здесь f, например, от double,
то тогда
у меня как бы теперь глобально есть
if от double, f от int.
И если я вызываю ее без уточнения,
откуда, то они конкурируют,
как будто между ними есть
перегрузка.
Вот.
Что если я теперь
еще напишу using n n
f?
А теперь у меня
как бы я привнес
в глобальную область if от туда,
f отсюда. И теперь, если я буду
пытаться так делать, это будет ошибка.
Потому что теперь я как бы
добавил f и оттуда и отсюда,
это разные f,
но они,
когда я обращаюсь к f,
я не понимаю, какой. Они равноценны,
и теперь вызов
неоднозначен. Я сделал дважды using,
и теперь у меня вызов неоднозначен,
когда я это делаю.
Вот.
Забавно, кстати, что так можно сделать
и с переменными. Представьте, что у меня
есть
глобальная
x,
а еще есть вот здесь
x.
И я написал using
using n.
Так, наверное, кстати, нельзя делать.
nn 2.2x
Так нельзя, наверное, делать, потому что
он скажет, что это повторное
объявление. Да, с переменными
так нельзя делать,
а только с функциями можно.
Redeclaration.
Если я пытаюсь using переменную
сделать, которая уже есть
в этой области видимости с таким же названием,
это ошибка. Вот с функциями так можно,
потому что у меня в функции перегрузка есть,
а с переменными нельзя.
Но
я могу сделать using namespace.
Это второе, что я могу писать using.
Я могу сделать using
namespace, и это означает, что
все, что есть в namespace
таком-то, теперь я делаю видимым
на этом уровне, глобально.
То есть теперь и функция
f, и функция g,
и переменная x глобально
берутся из namespace.
Когда я говорю using namespace,
это значит, что все, что есть в этом namespace
я добавляю в свою область видимости.
И теперь,
если я вот здесь обращусь к x,
это будет ошибка
неоднозначное обращение к переменной,
потому что у меня есть
глобальный x, а еще я привнес
в глобальную область видимости x из namespace
n. И
когда я теперь обращаюсь к x, непонятно
к какому, их два в глобальной области
видимости теперь, один реально глобальный,
а другой добавлен туда из namespace.
И вот у меня ошибка,
когда...
А, Господи,
у меня x уже в глобальной области, вот здесь
объявлен. Да, вот у меня есть
x глобальный и есть
using namespace, да, и
reference to x из ambiguous,
неоднозначное обращение к переменной.
Вот.
Namespace можно объявить, да,
внутри другого namespace.
Внутри функции нельзя,
и внутри класса тоже нельзя.
Namespace, внутри других namespace
можно, и тогда, чтобы
обращаться к местам из этого namespace,
будет писать n...
еще n, n2,
2.2, и так далее.
Можно ли использовать using
внутри чего-либо? Да, using
можно использовать локально, разумеется,
и это даже рекомендуется.
Вот глобально писать using плохо,
потому что когда вы глобально пишете using,
вы как бы сразу глобально делаете
видимым это все, много чего.
Хорошо писать using локально,
тогда вы сделаете, как бы, привнесете
только в локальную область видимости это имя.
Например, можно писать using
std seout,
и теперь мне не надо перед
seout писать std,
потому что теперь я беру seout
из namespace std.
Вот если бы я просто писал seout x,
он бы сказал, я не знаю, что такое seout,
не было его в этом скопе.
Но я сказал using std seout,
и это означает, компиляр теперь понимает, что
seout я собираюсь брать из std.
Я могу также написать using
namespace std,
кто в своей жизни хоть раз так писал?
Теперь вы понимаете, что это значит.
Using namespace std
означает, что все сущности из namespace
std вы привносите в ту область видимости,
в которой это написали. Так не рекомендуется делать
и мы будем вам запрещать это писать
в своих программах, потому что
это на самом деле опасно, когда вы привносите
в свою область видимости все, что есть
на namespace std, вы
рискуете тем, что у вас случатся конфликты
имен с тем, что было кроме
этого объявлено.
Namespace std очень большое, и в нем есть очень много
имен, о которых вы не подозреваете.
Случайно это может в какой-то момент привести вас
к тому, что вот у вас была функция
с каким-то названием, ну например, та же
самая присловутая distance, а в
namespace std есть еще куча функций distance
от разных типов. И вот представьте, вы объявили
свою функцию distance, и еще у вас написано
using namespace std. В итоге
у вас есть функция distance,
и вы ее вызываете, но вызывается
не она, а вызывается та, которую из
namespace std привнесли, потому что она предпочтительнее
по типам, и вы никак
это не одебажите, вы никак не поймете,
что происходит, потому что вы думаете, почему
ваш код делает не то, что вы написали,
а потому что вы привнесли другую функцию, и даже
не подозреваете об этом, и вызывается вообще не она,
а какая-то другая, написанная не вами.
Поэтому писать using namespace std не
рекомендуется особенно глобально.
Локально еще ладно, если
у вас маленькая функция, и вам хочется там
в ней маленькой, чуть-чуть
этим пользоваться, но не глобально, пожалуйста.
Вот.
Про namespace
есть еще такой прикол, что
можно
доопределять namespace, то есть
если я сейчас напишу снова namespace n
и в нем что-то допишу,
то это я, значит, не переопределил
namespace, а доопределил.
Вот для namespace
не распространяется правило, что только один раз
можно определить. Я
сделал namespace n, что-то в нем написал,
закрыл, потом
снова написал namespace n, что-то еще написал,
закрыл. Теперь в namespace n есть E,
F и G. Это нормально, так можно,
и так нужно.
Даже.
Да, ну и
самое последнее, это using
для типов. Я могу
сделать using на
тип. Я могу
сделать using на переменную, на функцию, как я уже
говорил, а могу на тип. Что это значит?
Я, например, могу сказать такое,
что using
v и
равно std vector int.
Ну, мне надо заинклудить вектор.
Да, я забыл сказать, да,
ну, я думаю, вы и так понимаете. Чтобы пользоваться
вектором, надо написать include vector,
чтобы пользоваться string, надо написать include string.
Вот сейчас
я написал
так называемый alias для
типа.
Теперь v и это тот же
самый тип, что и vector int.
В рамках этой области видимости.
Надо понимать,
что я не новый тип сейчас создал,
а просто другое название для уже существующего
типа создал.
Ну, просто если мне почему-то тип
слишком длинно называется, я хочу называть его
короче, я могу вот так делать.
Это иногда удобно.
Да.
От macros это
отличается много. Чем?
Macros очень тупой.
Macros он делает
потекстовую подстановку.
Ну,
macros
это тупая
потекстовая подстановка.
Замени одну подстроку в коде
на другую подстроку в коде.
То есть, если я распишу переменную int v,
то он при любви заменяет на...
Да.
Если ты напишешь переменную там...
Ну, в общем, да.
Macros делаются до компиляции define.
И вам на семинаре
на каком-нибудь про macros расскажут.
А это гораздо более углая подстановка,
она симматическая, то есть она осмысленная.
Компилятор просто понимает, что v,
v, это то же самое, что vector int.
И может выдавать вам осмысленное предупреждение,
что вы там, например,
v,
потом переопределяетесь каким-то другим названием.
Вот, например,
вот вам, кстати, пример. Представьте,
что я так написал, а потом написал так.
Пример, чем это от macros отличается.
Сейчас будет ошибка,
потому что я пытаюсь
переопределить v.i.,
которое уже было объявлено как тип.
v.i. redeclared as different kind of entity.
До этого v.i. было vector,
а теперь я пытаюсь сказать, что это int.
Так нельзя. Если бы я сделал macros define
v.i. vector int, то он бы и вообще
не подавился, он бы посчитал,
что если бы написал int std vector int.
И ошибка была бы другой.
То есть macros это тупая
постановка без задумывания о смысле.
Понятно?
Вот.
Все. Это конец
параграфа 1.3.
Еще раз, а если там int,
что будет в игре?
Если не написали int v.i.,
то что-то это что?
С macros или сейчас?
Ну вообще, если бы не написали int v.i.
Ну я написал, вот, произошло.
Я хотел переобъединить v.i.
Уже v.i. определено как vector int,
а я теперь пытаюсь переменнуть с таким
именем, как нельзя.
Ну, у нас осталось еще немного
времени, давайте начнем следующий
параграф.
Он будет называться
выражение и операторы.
На самом деле,
вот, я вам сказал,
что ваша программа это
из объявлений
и
на верхнем уровне это так.
То есть, на глобальном уровне,
в глобальном скопе, все, что вы делаете,
это объявляете сущности.
Переменные, функции, пространство имен,
классы и так далее.
Но, когда вы заходите в функцию,
то есть, когда вы находитесь в local scope,
вы уже
помимо объявлений
можете писать и другие вещи,
а именно вы можете писать еще
выражения, expression и
control statements,
так называемые.
Значит,
ну, вот то, что вы можете писать
внутри функции,
давайте я, наверное,
снова перейду рисовать на доске,
в отличие от глобальной области
и namespace области,
внутри функции вы можете писать
statements.
Да, значит, параграф 1.4
называется
expressions and operators.
И, видимо, мы его сейчас начнем,
а закончим в следующий раз.
Statements.
Statements бывают
declarations, бывают
expressions, а бывают
control statements.
Declaration уже, вы знаете,
переводится как объявление,
expression означает выражение,
а control statement это,
ну, вы, возможно, догадываетесь,
что такое control statement,
это либо if, либо for, либо while,
в общем, это инструкция, которая
меняет ход выполнения каким-то образом.
Мы с вами в прошлом параграфе
обсудили подробно что такое declaration,
что называют expressions.
Что такое expressions?
Это,
ну, формальное определение
очень сложное, и оно занимает
страницы две, наверное.
Вот у вас на мат-логике
возможно было определение
или будет скоро определение того,
что такое формула синтоксическая,
корректная. Вот expression определяется
также, это длинное синтоксическое
определение, из чего может состоять
expression. Но не формальная expression,
набор переменных и литералов,
соединенных между собой операторами
и скобками по синтоксическим правилам.
Ну, например,
что я имею в виду? Вот, например, там, я не знаю,
x плюс 5 это expression,
x плюс-плюс это expression,
cout x это expression,
вот это все expression,
вызов функция,
это все expression.
А в данном случае
у вас есть
оператор плюс
и два оператора, x и 5.
В данном случае у вас есть оператор плюс-плюс
и один оператор, x.
В данном случае у вас есть
оператор вот этот,
два оператора, cout и x,
это на самом деле тоже expression.
Это вызов оператора влево-влево
от переменных
xout и xout это тоже переменная, просто у нее тип странный.
Вызов функции это тоже expression.
Это особый вид expression, который называется function call expression.
Функция дальше круглые скобочки, которые формально являются оператором.
И дальше перечтение аргументов.
Наша с вами задача это вкратце рассмотреть какие есть виды expression и какие у них особенности.
Давайте мы начнем рассматривать, а продолжим в следующий раз.
Я буду рассматривать не expression как таковые, а операторы.
Выражение состоит из операторов, поэтому я буду рассматривать операторы.
Сначала, наверное, самые простые, всем известные, это арифметические операторы.
Да, это плюс, минус, умножить, разделить, процент, да и все вроде.
Это арифметические операторы.
Побитовые операторы.
Еще к арифметическим, наверное, можно отнести вот эти операторы побитого сдвига.
Но вот, заметьте, что вот эти операторы, они ведут себя по-разному, смотря каких типов они вызываются.
Для целых чисел побитого сдвига означает, ну, означает побитовый сдвиг, вы понимаете, что такое побитовый сдвиг, да?
Например, 1, вот так вот, 3, это будет 8.
Я сдвинул и минус на 3 влево побитого.
Но если этот оператор применяется к истриму, к остриму, то он означает вывод в поток.
А этот оператор, примененный к истриму, означает ввод из потока.
То есть, это тот же самый оператор, просто для других типов он по-другому себя ведет.
Вот так работает перегрузка оператора.
Ну, можно еще, например, упомянуть операторы сравнения.
Давайте я их упомяну и на этом мы закончим.
Операторы сравнения.
Это что за операторы?
Ну, это операторы равно, неравно, меньше или равно, больше или равно, меньше, больше.
Ну, еще есть вот такой оператор, но он появился только в C++20.
Он довольно сложен для понимания, мы его пока не будем обсуждать.
Ну, это операторы, которые позволяют вам сравнивать переменные и другие выражения, проверять на равенство или на меньше.
Они принимают разные типы, а возвращают булевское значение.
Ну, наверное, на этом мы закончим сегодня.
В следующий раз, я напоминаю, мы проведем онлайн.
