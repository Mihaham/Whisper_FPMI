Мы продолжаем прошлую лекцию. У нас остался долг доказать
корректность алгоритма Косараю. Давайте я его напомню
быстренько. Напоминаю, что мы делали. У нас был ориентированный
граф. Мы хотели выделить в нем все компоненты сильной
связности. Давайте я договорюсь, что компоненты сильной
связи я буду называть КСС сегодня, чтобы долго не
говорить. Нужно выделить КСС в ориентированном графе.
Мы делали следующее. Во-первых, мы с помощью обычного ДФСа
сортировали все вершины в порядке убывания ТАУД.
Сортировка вершин в порядке убывания ТАУД. На втором
шаге мы по этой перестановке вершин в этом порядке шли
и для всех непосещенных запускали ДФС по обратным
ребрам. Все, что мы посещаем, непосещенное раньше, это
очередная компонента связности. ДФС по обратным ребрам
из вершин в этом порядке. Все, что на очередном шаге
достигается, это очередная компонента сильной связности.
Есть у меня какая-то перестановка. Я сначала запускаюсь ДФСом
по обратным ребрамам, которые я обзываю ДФСР, ДФС реверс.
Запускаю ДФС из первой вершины в этом порядке. Она что-то
посещает. Все, что она посетила, я помещаю юздами, какими-то
метками, что эти все вершины посещены. Я говорю, что это
очередная компонента сильной связности. Потом продолжаю
идти по вот этому списку, по этой перестановке. Нахожу
первую непосещенную, та, которая еще не помещена,
как юзд, запускаю от нее ДФСом по обратным ребрам.
И опять то, что она посетит, это очередная компонента.
Вот такой алгоритм. Нам нужно догадать корректность.
Для этого нужно следующее утверждение. Утверждение
значит, пусть из У есть путь В, но из В нет пути В, тогда
tout от У больше tout от В. У нас было похожее утверждение,
когда мы говорили про дак, когда мы строили дипологическую
сортировку, у нас было, что если есть ребро из УВ,
в комментарии, если, значит, когда мы говорили про дак
и строили топ-сорт, мы говорили, что если есть ребро из УВ,
и соответственно нет обратного ребра, поскольку у нас
ациклический граф, нет обратного ребра, тогда tout
отсюда обязательно больше, чем tout отсюда. И значит,
когда мы сортим все в порядке убывания tout, эти вершины
гарантированно будут идти раньше, а значит, ребра будут
только слева направо. Это у нас было в прошлый раз.
Такое изменение такое, доказательство.
Ну вот рассмотрим путь из УВ.
Давайте на этом пути рассмотрим вершину с минимальным
t in.
Дубль В, это вершина на пути из УВ
с минимальным t in.
Здесь, видимо, есть два варианта. Первый вариант,
если W совпадает с У, тогда все очевидно, потому что,
значит, если W совпадает с У, значит, среди всех вот
этих вот вершин первая, в которую мой DFS зашел, это
У. Значит, к моменту времени входа сюда все вот эти
вершинки еще не посещены, значит, они еще белые.
Ну, значит, в частности, по леммиям белых путях,
к моменту времени выхода из У мы обязаны будем все
вот это обойти, потому что все это белый путь. Значит,
в частности, вершинку В мы тоже посетим, из нее все
обойдем, пометим ее черной, и только после этого мы
посетим У. Значит, первый случай. Если W равна У, тогда
по леммиям белых путях W посетится до выхода из У. Ну,
значит, есть вот такой неравенственный т-аут, что мы сначала выйдем
из В, только после этого когда-то выйдем из У. Понятно?
Ну, второе, если W не равно У, то как у нас все это выглядит?
Если W, тогда работает следующее. Сейчас, момент.
Неприятно, неприятно. Так, виноват, надо минутку подумать.
Не, ну, смотрите, проблема, вот такая может быть проблема,
на самом деле. Ну, это не очень страшно, главное, что
нет из В в У цикла. Так, сейчас, момент.
Да, окей, получается, что не верно, надо что-то будет
менять, потому что, смотрите, например, вот на такой картинке,
пусть вот есть такая картина, путь из У в В и обратное
ребро из W в У. Тогда, если вот эта вершина первая, из которой
мы запускаемся, и, например, ДФС идет так, он сначала
идет в У, потом пощадь все вот это, потом говорит,
ага, я дошел до вершины, где я уже был, все, дальше
не иду. Получается, разворачивается обратно, выходит из
них из всех, доходит до У, до W, то есть мы, получается,
сначала обошли целиком У, потом вернулись сюда,
и только потом в конце дойдем до В. Тогда, получается,
вот это утверждение неверное, что т-аут больше, чем
т-аут от В. То есть мы сначала выйдем отсюда, потом
выйдем отсюда. Значит, это неверно, извините, там
можно все увидеть. Так, ну тогда надо сделать как-то
по-другому, да, что, ну здесь проблема в том, что они
как бы в разных компонентах, в разных компонентах
сильно связанности, что вот, ну точнее У и В в одной,
У и В в одной компоненте сильно связанности.
Давай тогда попробуем наоборот утверждение сформулировать,
что если есть две вершины в разных компонентах
сильно связанности, причем из одной есть путь в другую.
Давайте как-нибудь вот так вот сделаем, сначала
на картинке. Вот кружочки этой компоненты
сильно связанности. И пусть есть из одной компоненты
сильно связанности путь в другую, по ребрам вот
между компонентами. Тогда я хочу сказать, что
т-аут, максимальный из т-аутов,
который есть здесь, больше максимального из т-аутов,
который есть здесь. То есть, на самом деле мне
мне нужно путь не как бы между двумя вершинами, а путь между компонентами и
брать не просто t-out от вершины, а t-out максимальный из всей компоненты.
Сейчас мы это формально напишем. Пусть c1 и c2 различные компоненты
сильно связанности, различные ксс, причем есть путь из c1 в c2, но сейчас значит,
нет пути обратно, потому что если есть путь отсюда сюда и отсюда сюда, то
получается, что они на самом деле все должны быть в одной компоненте сильно
связанности, если есть путь отсюда сюда и обратно, значит, эти две компоненты
должны склеиться, потому что есть путь в обе стороны. Тогда туждение будет
следующее. Максимум t-out от u по всем u и c1 больше, чем максимум t-out по всем v
для v и c2.
Так, то, что тут было, забыли.
Так, давайте доказывать.
Ну хорошо, давайте посмотрим просто на вот этот путь из первой компоненты в
последнюю, то есть из c1 в c2. Давайте посмотрим на вот эту вершину, из которой, собственно,
когда мы запускаем dfs, мы потом по какому-то пути, то есть возьмем начало ребра в другую
компоненту, который ведет в ту нашу компоненту c2. Ну тогда понятно, что здесь вот как раз не
будет той проблемы, которую мы наблюдали раньше. Значит, смотрите, давайте рассмотрим вот этот
вот путь. Пусть, как бы его назовем, давайте x, первая вершина на пути c1, c2. То есть опять,
я могу нарисовать такую картинку, только здесь же будет верно такое, что у меня не будет как бы
ребер в x. То есть раньше у меня была такая проблема, что если я рассматриваю на вот этом вот пути,
ну вершину с минимальным t1, где-нибудь вот здесь она могла быть, тогда у меня могло быть ребро
в начало. Вот, а сейчас такого же точно не будет, потому что я беру такую вершинку x, да, это первая
вершина на пути отсюда-сюда. Ну то есть такая, что x еще в c1, а следующий уже не в c1. Вот это вот
в c1, в первой компоненте это уже не в c1. Не в c1. Тогда опять то же самое, рассмотрим вершину с
минимальным t1 на этом пути. Так, с минимальным значением t1 от w на этом пути. Вот, первый случай такой
же, что если w совпадает с началом, то все хорошо, потому что если x это вершина первая, в которую мы
попали на всем этом пути, то значит, когда мы в нее зашли, это все белое, раз у нее минимальный t1,
значит, к моменту времени выхода из x мы посетим весь этот путь, в частности эту вершину, то есть мы
выйдем отсюда раньше, чем выйдем отсюда. Первый шаг остается. Полей на белых путях.
Полей на белых путях. tout от w меньше, чем tout от x. Причем здесь можно в качестве w взять,
на самом деле, любую вершину из c2. Где w любая из c2. Потому что если вот это произвольная вершина из
c2, то я ее могу продлить, то есть я вот дошел до какой-то вершинки из c2. Дальше я могу продлить
до произвольной вершинки v, потому что я знаю, что здесь есть пути во все стороны, значит,
я этот путь могу там довести до v, до произвольной вершинки. И опять у меня есть какой-то один сплошной
путь, значит, выйду отсюда я раньше, чем выйду из начала. Нужен второй случай, когда w это не x.
Так, ну тогда можем заметить следующее. Если это первая вершина, которую мы встретили на этом пути,
то к моменту времени выхода из нее, когда этот DFS закончится, я x точно посетить не смогу.
Потому что пока эта вершина обрабатывается, то есть с момента времени t in от w до t out от w,
у меня по сути происходит обработка вершины w, то есть достигнется все, что достижено из нее. Но
x тогда за это время точно не посетится, потому что нет вот такого пути. Ну нет такого пути точно.
Мы предположили, что x это единственная вершина из компоненты сильно связанной с ц1, значит все
остальные точно в ц1 не лежат, в частности из них нет пути в x. Поэтому в x мы никогда не попадем.
Значит, к моменту времени выхода отсюда x еще не будет посещена, но зато будет посещено все,
что находится правее, потому что это белый путь. Вот, и тогда все хорошо. Мы сначала выйдем оттуда,
потом зайдем сюда и выйдем отсюда. Поскольку w не принадлежит ц1, к моменту времени t out от w,
вершина x все еще будет белая. Это с одной стороны. Ну а с другой стороны все вот это посетится,
опять-таки поля на белых путях. Значит, вот то, что мы здесь в конце были в ц2, ц2 вся посетится,
мы не успеем выйти до того, когда же вошли в x. Но ц2 целиком посетится. Значит, можно написать
следующее, что максимальное время выхода во всем v из ц2 будет меньше, чем время выхода из x.
Но этого достаточно для доказательства утверждения. Там у нас было вот здесь,
что нужно взять максимум по всем t out, то есть по всем t out из ц1. Но здесь мы взяли
какое-то конкретное, поэтому это можно оценить еще сверху как максимум по всем вот этим t out.
Значит, этого достаточно. Так, есть ли вопросы? Да, получился сомбурный, извините, но вот вроде
сейчас мы все доказали. По крайней мере, наше утверждение. Так, хорошо, теперь давайте
поймем, зачем это нам нужно. Ну, я утверждаю следующее, что в каждом момент времени вот этого
нашего алгоритма двухчасно, ну, точнее, вот на втором шаге, когда мы запускаем DFS по обратным
ребрам, после каждого запуска DFS мы откусываем целиком какой-то компонент усиленно-связанности.
Это, собственно, то, что нам нужно доказать, что когда мы запускаем DFS по обратным ребрам от
какой-то вершины, мы посещаем целиком какую-то компоненту связанности и больше ничего. То есть
каждый вот этот вот, каждый запуск DFSR по обратным ребрам выделяет нам ровно одну компоненту
цельно-связанности. Если мы докажем, то будет все верно. Ну, смотрите, значит, как эта штука
работает. Пусть, ну, давайте индукции по вот этому вот списку вершин в порядке убывания т-аутов.
Пусть мы несколько компонентов цельно-связанности выделили, их все посетили и пометили все вершины
в них посещенными. Значит, индукция по количеству сделанных шагов. Дальше, вот это вот DFSR
запускается от вершины с максимальным т-аутом, который не лежит ни в одной из обработанных
ксс. Давайте это запишем. Каждый раз DFSR запускается от вершины ранее не посещенной
этим самым DFSR. Ранее не посещенный вот этим самым DFSR по обратным ребрам с максимальным т-аутом,
с максимальным значением т-аут. Ну, то есть есть какая-то вершина В, которая не лежит в этих
компонентах, которые мы уже рассмотрели, и ее т-аут максимально среди всех нерассмотренных. Ну,
тогда мысль первая. Она в какой-то компоненте цельно-связанности точно лежит, причем эта
компонента отлична от вот этих вот уже рассмотренных. Значит, если я запущу DFSR по обратным ребрам из нее,
то как минимум ее компоненту цельно-связанности я точно посещу. Я точно в них вовсе зайду,
потому что это какой-то множество вершин, в частности из которых есть пути В, потому что
есть пути в обе стороны. Если я буду ходить по обратным ребрам из В, то я обязательно посещу
целиком всю компоненту цельно-связанности. Давайте я ее назову как-нибудь В. Запускаемся от вершины
В с максимальным значением т-аута от В. DFSR от В точно посетит всю компоненту цельно-связанности
от В к SSV. Потому что мы предполагаем, что у нас посещенными отмечены только несколько компонент.
В соответственно не посещена, значит вся ее компонента не посещена. Поэтому по обратным
ребрам мы точно достигнем все вот этого. Теперь последнее, что осталось сделать, это показать,
что мы не посетим никакие другие вершины, что мы не посетим вершины из других компонентов.
Ну пусть посетим, пусть есть какая-то ещё другая компонента, с сильной связанности,
отличная от тех посещенных и отличная от настоящих компонентов с сильной связанности вершины V.
Если мы ее посетим, это значит, что есть некий путь по обратным ребрам из V в это компонент
цельно-связанности. Путь по обратным ребрам, не проходящий по посещенным вершинам,
нам ведущий в другую компоненту сильно связанности. Давайте
это тоже запишем. DFSR от V работает некорректно
только если из V есть путь по обратным ребрам
в другую КСС. Ну и все вершины не посещены на этом пути,
потому что в посещенные мы не ходим. Ну тогда это
противоречит с утверждением, потому что если вот эта
вот компонента сильно связанности какая-то другая, причем она
целиком не посещена в этот момент, ну мы считаем, что
до запуска DFSR у меня целиком посещены несколько компонент
сильно связанности целиком. Вот эти вот три. Значит целиком
тогда не посещена. Ну тогда извините, если у меня есть
путь из одной компоненты сильно связанности в другую,
значит по нашему утверждению максимальный т-аут вот
здесь вот больше, чем максимальный т-аут вот здесь. Значит
V это не вершина с максимальным т-аутом, как мы предположили.
Ну тогда мы получаем, что есть путь между двумя компонентами
сильно связанности С1 и С2. Значит вершина с максимальным
т-аутом это не V, а какая-то вершина С1. Ну не обязательно
С1, возможно откуда-то из другого места, но главное,
что точно не V. Значит вершина с максимальным значением
т-аут это не V. Ну вот как-то так. Вопросы? Давайте еще
раз тогда овервью, чтобы не было дырок. Значит смотрите,
мы доказываем по сути такое утверждение, что если есть
путь между двумя компонентами сильно связанности С1 и С2,
то максимальный т-аут здесь больше, чем максимальный
т-аут здесь. Максимальный т-аут в первой, больше
максимальный т-аут во второй. Это вот мы как-то доказали.
Дальше почему корректен наш алгоритм Касараю. Ну мы
доказываем индукции по числу запусков DFSR, что он делает
следующее. После каждого запуска он находит несколько
компонентов сильно связанности, выводит их и посещенными
считает только целиком несколько компонентов. То
есть каждый компонент либо целиком посещена, либо
целиком не посещена. Тогда если я выбираю вершину с
максимальным т-аутом, который еще не посещена, и предполагаю,
что мой алгоритм работает некорректно, и посещает
кроме правильных компонентов еще какой-то мусор, еще
это часть другой компоненты, то это значит, что эта компонента целиком не посещена, а значит из утверждения
из утверждения
t-out здесь должен быть больше, чем t-out здесь, ну по крайней мере максимальный t-out здесь больше, чем максимальный t-out здесь, а
значит v у нас была была была выбрана неправильно, нам нужно было v взять отсюда
окей?
Ну окей
окей
хорошо тогда простое замечание
о том, что такое конденсация графа
конденсация
значит, ну собственно это вот тот граф, когда мы кss объединяем в большие кружочки такие, то есть мы в качестве новых вершин рассматриваем
кss в исходном графе, а ребра оставляем только между кss
конденсация это опять-таки граф, вершины которого это кss
вершины это кss
ну а ребра это ребра между кss
в исходном графе
еще давайте скажем, что кратные ребра удаляем
кратные удаляем
ну какой-нибудь пример давайте сразу
вот
вот есть у меня такие три компонента из сильной связности
первая, вторая, третья и между ними могут быть кинуть ребра например вот такое
вот такое и вот такое
когда после конденсации у меня будет граф из трех вершинок и
двух ребер вот так и вот так
то есть вот эти вот два сжались, потому что в этом графе они были бы, ну по сути кратные ребра, отсюда сюда два ребра
мы не рисуем, мы рисуем только одно
ну и дальше вот это вот
превращается в такое ребро
простое наблюдение, что получившийся граф, получившаяся конденсация это всегда дак, всегда цикличкий граф
всегда так, то есть это циклический граф
ну это несложно, значит если бы у меня был какой-то цикл, то
Если fucker у меня был какой-то цикл, то что значит, что у меня есть цикл между
какими-то компонентами? Что-нибудь вот такое я нарисую то значит, что есть путь отсюда
сюда дальше, здесь можно как-то добраться до вот этого начала ребра. Потом перейти
по ребру, опять добраться до вот этого начала ребра. Короче говоря, у меня есть цикл
между какими-то вершинами разных компонент стильно связанности.
Ну значит в частности, они должны все лежать в одной компанией стильно связанности,
потому что есть путь отсюда сюда и отсюда сюда, через вот Journey Part 2
Поэтому, как минимум, вот эти две вершины должны были быть стянуты.
Ну, противоречие, да, мы предположим, что они в разных ксс.
Значит, давайте это распишем, что пусть у меня есть в этом графе, ну, от противного,
пусть в этом графе есть какой-то цикл на вот этих вот компонентах сильно связанности.
Он тогда порождается используя какие-то ребра в исходном графе из у1 в v1,
из у2 в v2, из у3 в v3 и так далее. То есть в термах исходного графа вот эти вот ребра между компонентами,
которые я здесь рисую, на самом деле были ребрами между вершинами у и ты, в и ты.
Тогда давайте рассмотрим такой путь. Ну, начнем с ребра у1 в и1. Дальше, поскольку у меня v1 и u2
лежат в одной компоненте сильно связанности, то у меня, конечно, есть путь между ними из v1 в u2.
Потом используем ребро у2 v2. Дальше, поскольку v2 и u3 у меня в одной компоненте сильно связанности,
то я могу между ними перейти, как хочу, потому что это одна ксс, ну и так далее.
Собственно, в конце я дохожу до вот этой вот там vn, до последней вершинки. И поскольку они в одной
ксс, то я могу дойти из одной в другую спокойно. Все, значит, есть цикл, поэтому все они должны
лежать в одной компоненте сильно связанности. Раз есть цикл, то можно из одной попасть в другую
и наоборот. Если есть какой-то цикл ориентированный, то можно на нем из любой вершины попасть в любую
другую. Это очевидно. Ну, значит, они все должны лежать в одной ксс. Противоречие. Мы предположили,
что как минимум у 1 v1 в разных. Противоречие. Вопросы? Хорошо. Ну вот, ну а с дагами мы умеем
работать. То есть, если бы у меня была какая-нибудь задача про, скажем, подсчет числа путей в графе,
то вот после конденсации, возможно, что-нибудь там бы получилось делать. То есть, возможно,
нужно было бы просто на конденсации посчитать число путей, а мы это умеем делать с помощью топ-сорта,
и динамики какой-нибудь. Хорошо. Значит, пример, зачем это может быть нужно, это решение задачи
2-сад. Зачем нужно выделять компоненты сильно связанности? Задача 2-сад ставится следующим
образом. У вас есть формула в 2-кНФ. Значит, 2-кНФ это конъюнкция нескольких скобок. В каждой
скобке стоит дизюнкция ровно двух литералов. Конъюнкция нескольких скобок. Каждая скобка
это дизюнкция ровно двух литералов. Ну а литерал это переменная или отрицание переменной.
Литерал это переменная или отрицание переменной. И наша задача это сказать,
является ли данная формула выполнимой, ну или найти у нее выполняющий набор. То есть,
найти такой набор ограничений переменных, чтобы формула на этом наборе была истинна.
Найти выполняющий набор, то есть, ну я так напишу, набор Х1 и так далее ХН, что ФИ на этом
наборе истинна. Ну найти какой-нибудь или сказать, что его не существует, сказать,
что формула не выполнима. Эта задача решается так. Давайте мы для каждой буквы,
для каждой переменной точнее заведем по две вершины. Каждую переменную мы превратим в
две вершины, пометим их соответственно П и не П. Вот, если у меня есть там еще какая-то переменная
Q, то я ее опять раздвою, будет у меня вершина, отличающая Q и вершина, отличающая не Q и так далее.
Для каждой вершины, для каждой переменной две вершины. Дальше каждое ребро, ну например,
точнее каждую скобку, например Х или Y, я превращу в два ребра. А именно, я просто напишу каким
импликациям вот эта дизинкция эквивалентна и проведу ровно такие ребра, как написано в
импликации. Мы знаем, что это то же самое, что не X стрелка Y, это то же самое, что не Y стрелка X.
Интуитивный смысл такой, что чтобы дизинкция была истинна, вам нужно, чтобы если бы не X,
то есть если X 0, то Y обязательно единица. Если не это, то вот это. Или что то же самое,
если не Y, то X. Вам нужно, чтобы хотя бы один из них был единичкой. Значит, если у вас не Y или не X,
то соответственно X или Y. Ну поэтому, давайте на этом примере нарисуем. Есть у меня X, есть у меня Y.
Они тоже превратились в какие-то вершинки. Ну и я рисую просто вот эти вот два ребра,
вот эти две импликации, которые эквивалентны исходной дизинкции. Рисую вот такое ребро и вот
такое ребро. Если у меня, скажем, было что-нибудь, ну давайте еще для примера нарисую. Если у меня
есть что-нибудь типа не P или Q, что у меня здесь стоит не переменная, а отрица не переменная,
например. Ну то же самое, я пишу каким импликациям это эквивалентно. Например, не Q стрелка не P,
или P стрелка Q. Ну и рисую вот эти вот стрелки из не Q в не P и из P в Q. То есть вот какие
импликации эквивалентны данной дизинкции, я такие стрелки рисую просто. Вот и дальше идет такое
утверждение, что выполняющий набор существует, если и только если ни для какой переменной она
и ее отрицание не лежат в одной компанией сильно связанности. Значит, phi выполнимо,
ну выполнимо, то есть у нее вот есть набор, на котором она единица. Если и только если не
существует такой переменной P, что P и не P лежат в одной ксс. Соответственно, алгоритм проверки
выполнимости такой. Мы смотрим на формулу, устроим паниграф вот по тому правилу, как я
описал, и дальше просто разбиваем все на ксс, на компанией сильно связанности, и для каждой
переменной проверяем, а правда ли, что P и не P в одной ксс, да или нет. Если есть хотя бы одна
переменная, что вот эти вот две вершины в одной ксс, то все плохо, формула невыполнима. Иначе
покажем, что выполнима. Ну, мы на самом деле для каждой вершины будем просто хранить номер ксс,
в которой она лежит. И вот когда косараю работает, мы просто вот храним номер итерации, который мы
запускаем DFS по обратным ребрам, и все что посещаем, им говорим, что у них номер ксс,
там ноль, потом это увеличиваем, у них у всех будет один и так далее. Просто для каждой вершины
храним номер ксс. Так, давайте доказывать. Сверху вниз получается, что если выполнима,
то не может быть вот такого. Начну это просто. Предположим противное. Пусть есть какие-то две
вершины, есть какая-то переменная, такая, что она и ее отрисование лежат в одной ксс. Одна ксс.
Раз-то одна ксс, то получается есть путь в обе стороны. Есть путь из П вне П, и есть путь из не П в П.
Теперь давайте вспоминать, какой мы смысл вкладывали вот эту импликацию в эти стрелочки. Смысл был
такой, что если верно начало стрелочки, то должно быть верно конец стрелочки. Если П,
если П, то вот это, если это, то вот это, если это, то вот это и так далее. То есть если верно
какая-то вершина, то есть если она соответствует истинному литераллу, тогда все что из нее достижено,
тоже должно быть истинно. Ну вот просто по тому правилу, что вот здесь, давайте смотреть. Если
не х, то есть если вот это вот верно, то должно быть верно вот это. Если не у, то должно быть верно
вот это. Ну а в тернах нашего графа, если какая-то вершина соответствует истинному литераллу,
то все достижимое из нее должно быть истинно. Ну понятно, что такого быть не может, потому что
понятно, что хотя бы одна из них соответствует единичке, то есть хотя бы один из этих литераллов
истинной, например П. Пусть П равно единице в выполняющем нашем наборе. Тогда единица должна
быть здесь, здесь, здесь, здесь и здесь. Соответственно не П, тоже единица. Противоречие. Если П равно
нелюys, то тогда соответственно, наоборот это единица и тогда здесь должна быть единица,
здесь единица, здесь единица, здесь единица, здесь единица и здесь единица, опять противоречие.
Мы никак не можем выбрать значение П, чтобы у меня все было не было противоречием
вот этих вот двух путях. Давайте я основную идею здесь запишу, что если какая-то вершина
соответствует истинному литералу, то все, что из нее достижимо, тоже должно быть истинной литералы.
Согласны? Ну тогда обратно, снизу вверх, что если вот такой картинки нету, не для какой
переменной, то есть нет явных противоречий, тогда получится найти набор. Давайте его построим.
Давайте скажем следующее, что пусть, ну во-первых, чтобы это сделать, чтобы проверить,
что все вершины, точнее, что для каждой переменной у меня п и не п в разных ксс,
мы запускаем алгоритм Касараю, и он разбивает нам все на компоненты сильной связанности.
Так вот, пусть алгоритм Касараю для каждой вершины сохраняет номер ее ксс.
Для каждой вершины сохраняет номер ее ксс. Я буду обозначать как С от В. То есть для каждой
вершинки В у меня хранится число С от В, равное номеру ее компоненты. Значит, на первом шаге,
когда я запускаю первый раз ДФС по обратным ребрам, я все достижимые по обратным ребрам вершины
говорю, что они в нулевой компоненте, и для них говорю, что С это ноль. Дальше все, что мог посетил,
на следующем шаге беру там вершину с максимальным тавом, непосещенную, посещаю из нее все,
что достижено по обратным ребрам, говорю, что у них С единичка, ну и так далее. То есть храню какой-то
там счетчик и увеличиваю, когда перехожу к новой ксс. Ну тогда мы в частности понимаем,
что для любой вершины П С от П и С от не П это разные числа, не одинаковые. Для любой переменной
С от П не равно С от не П. Ну потому что если было равенство, то они были бы в одной ксс,
а мы предполагаем, что они в разных. Тогда давайте скажем следующее, что П равно единице,
если и только если С от П больше, чем С от не П. Ну то есть чтобы определить значение какой-то
переменной, я смотрю на номер компонента сильной связанности для вершинки П и для вершинки не П.
Если вот выполняется такое неравенство, говорю, что значение П равно единице. Ну и соответственно
наоборот, П я ставлю равно нулю, если выполняется неравенство С от П меньше, чем С от не П.
Вот я так задал значение всех переменных, я утверждаю, что это выполняющий набор. Покажем,
что это выполняющий набор. Ну пусть не так. Что значит, что это неверно? Значит,
что формула не выполнилась, когда конъюнкция может не выполниться. Только если одна из скобок не
выполнилась. Конъюнкция нулевая, если только если хотя бы одна из скобок нулевая, хотя бы
один из конъюнктов нулевой. Ну окей, значит есть какая-то скобка, скажем, х или у, которая на этом
наборе оказалась сложная. Есть хотя бы одна такая скобка, вот пусть это какая-то скобка х или у,
где х и у такие литералы. Хорошо, значит когда такое могло произойти? Только если они оба были нулями,
что дизюнкция нулевая, если оба дизюнкты нулевые. Х равно нулю и у равно нулю. С одной стороны. Это
значит, что раз они нулевые, то выполняются вот такие вот неравенства на номера их компонент
сильно связанности. Давайте тоже напишем, что мы знаем, что c от x меньше, чем c от не x,
потому что я x поставил нулем. То же самое с у, c от y меньше, чем c от не y, потому что я y поставил
нулем. Но при этом, поскольку у меня вот эта вот скобка присутствует в исходной формуле,
то у меня на самом деле в моем графе точно есть ребра вот эти вот, из не x в y и из не y в x. Потому
что если была такая скобка, то точно таки есть два ребра. Давайте я их здесь нарисую. Есть вот
такое ребро и вот такое ребро. Из не x в y и из не y в x. Согласны?
Так, побольше хочу картинку нарисовать, x не x, y не y. Знаю, что есть вот такие ребра перекрестные.
И при этом номер компонента вот здесь меньше, чем здесь, а здесь меньше, чем здесь.
Хорошо. Давайте заметим следующее.
Заметим следующее, что c от не x гарантированно не больше, чем c от y.
Ну вообще, я хочу сказать следующее, что если есть две вершины, соединенные ребром, из одной
есть ребро в другую, то номер и компоненты сильно связанности, которые находит алгоритм Косарая,
у этой вершинки гарантированно не больше, чем у этой. Ну почему это так? Во-первых, если они в одной
ксс, то здесь равенство и все хорошо. Если они в одной ксс, то здесь равенство и все нормально.
Иначе пусть они в разных ксс. Значит, вот y в какой-то ксс и не x в какой-то другой ксс. Ну тогда
работает наше утверждение про корректность Косараю, что если есть путь из одной ксс в другую,
то это обработается раньше. Если есть путь из одной в другую, то обработается раньше та из которой
есть путь. Поэтому, значит, наш алгоритм вот эту ксс найдет раньше, чем вот эту. Поэтому здесь будет
строго неравенство. Ну и аналогично вот с этими двумя вершинками. С вот не y будет не больше,
чем с вот x. Опять, потому что есть ребра отсюда-сюда, значит, они либо в одной ксс,
либо Косараю найдет сначала вот эту ксс, потом вот эту. Ну все, а здесь уже, я утверждаю,
что написано какое-то противоречие. Осталось вот эти вот четыре неравенства совместить и получить,
что там z меньше, чем z. Давайте начну с c от x. Я знаю, что это меньше, чем c от не x. Это знаю,
что меньше равно, чем c от y. Это знаю, что меньше, чем c от не y. И это знаю, что не больше, чем c от x.
Ну все противоречие от c от x меньше, чем c от x. Конец. То есть алгоритм решения 2sat следующий,
мы строим граф, запускаем на нем алгоритм Косараю. Затем для каждой вершины, ну то есть алгоритм,
в частности, для каждой вершины запоминает номер компонента сильной связности, где лежит эта
вершина. Дальше мы проверяем, во-первых, что для каждой переменной вот эти вот два значения
различны, то есть что p и не p всегда в разных ксс. Ну а дальше, в зависимости от номеров этих ксс,
мы либо говорим, что переменная единичка, либо ноль. И просто выводим это в качестве ответа.
Даже ничего не нужно перепроверять, это гарантируемо будет выполняющим набором. Я, конечно,
не утверждаю, что это единственный выполняющий набор, но это один из подходящих. Вообще выполняющих
наборов может быть много, но какой-то один мы нашли. И в принципе их может быть даже экспоненциально
много, поэтому выводить их все это, ну короче, неосмысленно задача, скажем так. Вопросы? Да,
хороший вопрос. Давайте вы на него ответите. Ну конечно, пока что у нас все алгоритмы были
линейные, потому что по сути у нас все сводилось к dfs, а dfs мы знаем, что линейные. Давайте зафиксируем.
Значит, алгоритм Косараю и алгоритм решения Двасат работают за линейное время.
Ну почему Косараю за линию? Там два шага. Первый это запускать обычный dfs и вывести все в порядке
убывания т-аутов, но это легко сделать с помощью просто одного dfs и выводить вершину, собственно,
когда вершина, когда мы выходим из вершины, добавляем ее в вектор посещенных, потом его разворачиваем,
чтобы получить в порядке убывания. А затем я просто прохожусь по вершинам и запускаюсь
dfs по обратным ребраммам. Все, что там достижено, это очередная ксс. Здесь все линейно, никакая вершина
дважды не посетится, поэтому время работы линейная. Двасат тоже получился линейным, потому что если
у меня было, скажем, n переменных и m скобок, то граф, который я строю, имеет два n вершин и два m скобок.
Ну а дальше просто косараю с линейной временной работы от 2n плюс 2m. Окей? Хорошо. Так, ладно.
Значит, тогда с ориентированными графами мы вроде разобрались, базовое все сделали. Теперь давайте
перейдем к неориентированным графам. DFS в Нюор графах.
Главное замечание, главное отличие DFS в неориентированных графах от DFS в ориентированных графах следующее.
Значит, смотрите, в ориентированных графах могла быть такая картинка. Как-нибудь вот так я ее нарисую.
Что это значит? Что я сначала пошел как бы по вот этой вот ветке, все здесь посетил, потом помечаю их черными,
откатываюсь назад и затем запускаюсь по этой ветке. И в частности, нахожу ребро в уже посещенную вершину,
которая уже черная, помеченной черной. То есть я сначала до нее дошел, здесь посетил все, что можно, вышел из нее,
пометил черный, вернулся сюда, а дальше нашел опять ребро в эту же вершину, но она уже черная. То есть в какие-то моменты времени бывали
ребра в черной вершины. То есть в какой-то момент эта серая, эта серая, а эти черные. И есть ребро в черную.
Но понятно, что если бы граф был неориентированный, то такого быть не могло. Потому что если, скажем, вот на этом ребре нет ориентации,
то перед тем как отсюда выйти, я должен был бы ее посетить. Что если я дошел до сюда, здесь все прошел и хочу выйти,
то мне нужно сначала еще вот сюда пройти и эту вершинку тоже пометьте использовать.
Поэтому на самом деле в неориентированных графах не бывает ребер в черной вершины. Не бывает ребер в черной вершины.
Ну это очень просто доказывается, что если мы в какой-то момент находим ребро в черную, вот есть В, а есть какое-то ребро из нее в какую-то вершины,
которое уже покрашено в черный цвет. Ну значит извините, в момент времени, когда мы ее обходили, перед тем как покрасить ее в черный,
нам нужно было начать обрабатывать ее. Значит до того как выйти отсюда, я должен был ее посетить.
А я говорю, что наоборот, я захожу в нее после того как эту посетил. Этого быть не может. Поэтому никогда не бывает ребра в черные вершины.
Это значит в частности, что нам на самом деле не нужны вот эти три цвета, белый, серый, черный, потому что черный у нас никогда не будет ребер в черной вершины.
Поэтому нам будет достаточно двух цветов по сути, поскольку вот здесь черный, его мы никогда не увидим, то есть мы никогда не будем пытаться идти в черную вершину.
Таких ребер мы никогда не увидим. Поэтому нам будет достаточно хранить как бы два значения, которые мы будем просто в виде буллевского флага запоминать.
У нас будет вектор буллевских значений UST. И просто UST от V это были мы в данной вершине или нет. Запускали ли мы от нее DFS.
То есть теперь вместо цвета храним метку посещаемости. Были ли мы в этой вершине. Вместо цвета храним метку посещенности UST.
Ну и давайте я быстренько код перепишу. То есть вот тот код, который был в прошлый раз, он скорее для ориентированных графов, там где мы храним три цвета, белый, серый, черный.
А здесь нам будет достаточно меток UST без цветов. Ну как всегда у нас граф хранится в векторе векторов.
И вот здесь появляется вектор булл UST, который изначально заполнен фолсами, что все вершины изначально не посещены.
Ну а дальше внутри все очень похоже на то, что было. Что мы хотим в какой-то вершине начаться с предыдущей вершины P.
Ну здесь там начало такое же. Можем сохранить родителя parent of V равно P. Можем написать, что ты на V равно timer++, если мы хотим запоминать время входа.
И здесь еще UST от V равно true будет у нас. Вместо того, что было раньше, color от V равно gray. То есть мы отказались от цвета, просто ее пометили посещенной.
Ну а дальше проход по всем вершинам. Вот здесь еще появляется отдельный случай, что у нас вот это вот ребро, которое мы сейчас рассматриваем, это возможно ребро в родителя.
Вот смотрите, я из P пришел в V, теперь находясь в V, я опять это ребро когда-то увижу. Поскольку у меня граф не ориентированный, то наличие такого ребра означает наличие обратного.
И я как бы хочу его игнорировать, потому что я по нему уже прошел, нет смысла по нему вверх возвращаться.
А, так, сейчас. Ну это на самом деле и так у нас обработается, да. Ну ладно, давай тогда просто напишем, что если UST от TUTO continue, да, это здесь пока можно делать.
Если UST от TUTO continue, а иначе просто DFS to V, конец.
Да, то есть если я пытаюсь пойти в вершину, где я уже был, причем вот это в частности включает случай, когда я пытаюсь пойти в родителя по тому ребру, которое только что в меня привело.
Либо ну в какую-то другую вершину я пытаюсь попасть. Тогда я делаю просто continue, а иначе я понимаю, что эта вершина еще не посещена, она свежая, белая в старых терминах, значит я просто от нее запускаюсь и говорю, что в нее я попал из вершинки V.
Вот, ну и здесь тоже работают замечания, например, про то, что на стеке у нас всегда лежат серые вершины, лежащие в одном пути, значит стек рекурсий всегда такой.
Это какая-то вершина старта, от которой мы начали, и затем несколько вот таких вот ребер, все из которых сейчас обрабатываются в каком-то смысле.
То есть вот это вот, скажем, начало, корень старта вершины, затем я запустился от вот этой вершины, вот этой, вот этой, вот этой, и сейчас обрабатывается вот эта.
Потом, когда я ее целиком обработаю, я ее со стека удалю и продолжу обрабатывать вот эту вот.
Ну да, поскольку сейчас у меня уже нет понятия, что эти вершины серые, я просто говорю, что вот на стеке всегда лежит какой-то путь с началом в вершине, из которой мы начали исходный DFS.
Ну и они как бы сейчас в работе. Когда я закончу обрабатывать последнюю, я вернусь к предпоследней на этом пути.
Так, хорошо.
Вот, можно еще вести такие определения, что ли. Можно сказать, что те ребра, которые наш DFS проходит, что это древесные ребра, вот эти вот ребра из V2, по которым я спускаюсь вниз, рекурсивно запускаюсь DFS, это древесные ребра.
Ребра V2, когда запускается DFS2V, это древесные ребра.
То есть вот когда я вижу, что я стою в V, хочу пойти в ту и ту не посещенное, ну unused, used еще равен там false, used от true равно false, значит я в нее спускаюсь и рекурсивно начинаю обход.
Ну поэтому такое ребро называют древесным. Вот, а все остальные ребра будут обратные. Все остальные ребра обратные.
И обратные они как раз в том смысле, что они ведут в какую-то одну из более ранних вершин на стеке рекурсии.
Что все ребра, которые не являются древесными, они на самом деле обратные, то есть ведут куда-то выше именно на стеке рекурсии.
Не в какую-то там другую вершину, не лежащую на стеке, а именно куда-то раньше на стеке. То есть то, что у нас раньше было в ориентированном графе, ребро в серую вершину,
серые у меня лежали на стеке, и все вот как раз ребра, не являющиеся древесными, по которым не пускается DFS, это обязательно такое, которое раньше было как бы ребром в серую вершину.
Что это цикл, ну получаем цикл из вершин на стеке.
Ну вот почему, давайте я картинку нарисую, откуда все вот эти, почему это древесные ребра, а остальные обратные.
Что-нибудь такое нарисуем.
Ну вот как-то так может выглядеть наш граф.
Значит, наш граф исходно неориентированный, есть все ребра, которые я нарисовал, и ребра со стрелочками, и вот эти пунктированные ребра снизу вверх тоже такие есть.
Тогда как работает наш DFS? Он запускается отсюда, помечает использованный, находит это ребро, говорит, что оно древесное, запускается отсюда.
Находит это ребро, говорит, что оно древесное, запускается отсюда.
Ну то же самое здесь, потом сюда, потом сюда.
Вот тут в этот момент находится, что есть ребро, ведущее в уже посещенную вершину.
Тогда он это ребро называет обратным.
Обратное ребро.
Ну и за счет того, что мы как раз вот сказали, что если мы находим ребро в посещенную, мы заметили, что нет ребров в черной вершины, значит, на самом деле это обязательно ребро в серой вершины, которая как бы лежит на стеке.
Поэтому все обратные ребра нам немедленно образуют некоторый цикл, что вот встав в этой вершинке, пройдя по этому обратному ребру, и затем обратно спустившись под древесный, мы получим цикл.
Каждое обратное сдает нам некоторый цикл.
Ну и здесь то же самое. Мы вот здесь все обошли, вернулись в корень, потом эти два назначили древесными.
Затем это обнаруживаем в качестве обратного, продолжаем, продолжаем, продолжаем, находим еще одно обратное. Вот вам еще один цикл.
Каждое обратное на самом деле просто стягивает некоторый цикл на нашем дереве, то есть какое-то дерево с корнем там, где мы начали и, ну вот это дерево сверху вниз,
дерево сверху вниз. И есть некие обратные ребра, которые вот так вот стягивают
какие-то пути на этом дереве. И главная мысль, что не бывает ребер между
разными под деревьями. Вот таких вот ребер не бывает. Ну потому что как раз
такое ребро означало бы, что я должен был... Что значит, что есть такое ребро, например?
Это значит, что я сначала обошел все вот здесь, потом поднялся сюда и дошел
до сюда. Но извините, тогда я вот это ребро пропустил, когда это обрабатывал. Я
должен был бы тогда вот эту вершинку переподвесить сюда,
значит дерево выглядело по-другому. Ну то есть как раз вот это ребро, оно было бы,
скажем, ребром в чёрную вершину, когда я вот эту вершину обрабатывал. А мы поняли,
что ребер в чёрной вершины нет. Так, шикарно.
Вот. Ну давайте я еще словами проговорю, что как, скажем, проверять граф на связанность,
как разбивать его на компоненты связанности и как проверять наличие цикла. Значит,
как проверить, что он связанный? Просто встаём в любую вершинку, запускаем DFS,
после DFS проверяем, что все вершинки у нас used, что все вершины посещены. Это, ну опять,
в терминах ориентированных графов, это лем о белых путях. Что если мы встали в вершину,
запустили DFS, то есть посетили все, что можно, тогда, поскольку раньше все было
достижено по белым путям, то к моменту времени выхода мы посетим все, что было возможно.
Значит, это связанность. Как разбить на компоненты связанности? Ну встаём в любую вершину,
помечаем используемые все, что достижено из неё. То есть запускаем просто DFS,
все, что возможно, и говорим, что это очередная компонента связанности. Встаем, ну как бы,
то есть находим следующую непосещенную, запускаем от нее DFS, все, что из нее достижено,
все, что достижено этим DFS-ом, это очередная компонента связанности. Вот. Ну и так далее.
Это по сути опять лем о белых путях. Что я встал в вершину, достиг из неё всего,
чего возможно. То есть ее компоненту связанности, по идее, выделил. Ну и так
делаю для каждой вершины. И, наконец, третий вопрос про циклы, как проверить,
если в этом графе циклы. Нужно просто узнать, если хотя бы одно обратное ребро, то есть есть ли
ребро в более высокую вершину, есть ли ребро в уже посещенную вершину. Давайте я здесь аккуратнее
это напишу. Проверка на ацикличность. Ну вот, в строчках, когда мы перебираем все исходящие
ребра, надо добавить еще одну. Если ту равно п, тогда continue. То есть если я стою вершине и пытаюсь
пойти по ну в общем ребру, по которому я только что пришел, то есть я спустился вниз, теперь обратно
пытаюсь по нему перепрыгнуть, тогда нужно этот случай проигнорировать. У меня это ребро уже
древесно, я его не должен рассматривать при попытке подняться вверх. А иначе, если я пытаюсь
пойти в посещенную вершину, то есть если you start to, тогда мы нашли цикл. Ну а иначе просто
dfs. Давайте я напишу так, не знаю, cycle, что мы нашли цикл, содержащий ребро из v в tu. И значит,
чтобы его, скажем, целиком вывести, вот есть v, вот есть tu, тогда нужно встать в v, подниматься
по parent до тех пор, пока мы не дойдем в tu, и в конце напишет последнее ребро из tu в v. Если мы ни одного
такого цикла не обнаружили, значит в той комбинации связанности, от которой мы запустились, нет ни
одному циклу. Так, хорошо. Вроде все просто. Так, тогда давайте посмотрим на критические
ребра и вершины в неориентированном графе. Определение. Пусть g связан граф. Так, ну кажется,
понятие связан я еще формально не определял, но связан это тот, у которого всего одна компонента
связанности. То есть такая, что между любыми вершинами есть путь. Всего одна компонента связанности.
Итак, пусть g связан граф, тогда ребро g называется мостом, если после его удаления граф становится
несвязанным. Я напишу так g-e несвязанной. То есть я удалил одно ребро и граф сразу стал
несвязанным. Но альтернативное определение можно не требовать, чтобы g был связанным изначально,
и тогда надо будет говорить, что в этом графе g-e, в графе после выбрасывания ребра, если исходный
граф был несвязан, то и новый тоже будет, конечно, несвязан. Нужно потребовать,
что увеличится число компонент связанности. Альтернативно e это мост, если число компонент
связанности в g-e больше, чем число компонент связанности в g.
То есть тут уже на любителей. Либо вы говорите, что вы мосты определяете только в связанном графе,
и тогда это любое ребро, которое делает граф несвязанным, то есть по сути расшипляет
его хотя бы на две компоненты связанности. Либо вы говорите, что мосты определены в
любом графе, не обязательно связанном, тогда нужно говорить, что число компонент связанности
увеличится после удаления. Обычно я бы все-таки сказал, что вот это берется. Говорить про мосты
адекватно, только если исходный граф связан. То есть вот у вас есть связанный граф, и вы хотите
понять, какие ребра критичны в том смысле, что их удаление делает граф несвязанным. А здесь,
ну не очень понятно. То есть у вас есть какой-то граф странный, не обязательно связанный, и тогда
удаление ребра, ну как бы его оставляет несвязанным. Да, увеличивает число компонент, но непонятно,
почему нам интересно вообще число компонент. А здесь хотя бы какая-то явная характеристика
про связанность, чуть более естественная. Начну нашу цель от найти все мосты.
Поясню еще раз, зачем это может быть нужно. Вот представьте, у вас есть какой-то связанный граф,
ну не знаю, там какая-то сеть, и вам хочется понять, какие каналы взаимодействия, какие связи
между вершинами, какие ребра по сути. Ну критично важно поддерживать. То есть если, скажем, какой-то
канал сломается, если какое-то ребро удалится, то граф станет несвязанным, и скажем, они не смогут
передать друг другу информацию. Если у вас есть там какие-то башенки, которые общаются по радио,
то вот если у вас какая-то связь между башенками нарушится, то вы не сможете передать информацию
из любой вершины в любую, вот будут какие-то уже отдельные куски несвязанные. Так, цель
найти все мосты. Хорошо. Ну давайте сделаем следующее. Ведем такую функцию.
Рет от v, от слова return. Это следующее. То есть минимум из tn от v и минимума tn от u,
где u может выглядеть как-то так. Вот у вас есть вершинка v. Вы можете сначала взять несколько
древесных ребер вниз и попасть в какую хотите вершину w, а дальше взять одно обратное ребро из w в u.
И вот по всем таким возможным путям вам нужно найти минимальный tn от u. То есть вы, смотрите,
вот у вас есть v, соответственно есть под дерево v. Это те вершины, которые достижены используя древесные
ребра вниз. Вот как вы по dfs ушли, вот все, что вы обходите после входа в v и до выхода из v. Короче,
что вы обходите во время обработки v, это под дерево v. Но вот вы можете спуститься в любую вершину
под дерево и затем, используя только одно обратное ребро, прыгнуть куда-то наверх. И среди всех
таких вершин взять минимальное tn. Формально это будет минимум по ребрам w, у. Таким, что это
обратно, давайте я так напишу, минимум по всем обратным ребрам w, у. Таким, что w в под дереве v.
w в под дереве v.
Интуиция здесь тоже очень простая. Вот это вот red означает следующее, что если мы рассмотрим
вот этот вот кусок, да, все по дереву w, рассмотрим, как что-то что-то неделимое,
как компоненту связанности, грубо говоря, то вопрос, насколько высоко мы можем из нее прыгнуть
используя одно ребро. То есть мы можем находиться здесь где угодно и при этом можем взять одно
ребро куда-то вот наверх. То есть какое-то одно обратное ребро. И тогда, когда я беру минимум по
всем вот этим вот tn, я по сути беру самую высокую из тех решений, куда я могу прыгнуть за один шаг.
Тогда я утверждаю следующее. Древесное ребро e является мостом. Давайте я напишу так. Древесное
ребро e равное паре uv. uvtu является мостом. Если только если в термиях вот этой вот функции,
ну, например, rttu равно tntu. Можно так написать. Доказательства. Первое замечание, что
не-древесные ребра мостами быть не могут. Не-древесные ребра мостами быть не могут. Ну потому что
что такое древесные ребра? Это такие ребра, используя которые, идя сверху вниз, начиная
из какого-то корня, я посещаю всю компоненту связанности. То есть вот я где-то встал, ну там,
в какую-то корневую вершину. Дальше использую древесные ребра, посещаю все что возможно. Ребра
такие сверху вниз, как я рисую на картинке. Ну понятно, что все остальные ребра, вот эти обратные
ребра, они нам, если их удалить, то связанности от этого не нарушатся. Я могу удалить все обратные
ребра, от этого древесные ребра останутся все, поэтому будет связанность. Значит, не-древесные
точно на связанность не влияют. Они не могут быть мостами, потому что их удаление оставляет,
ну собственно, вот этот каркас, по которому я могу дойти от корня до всех вершин. Окей, значит,
остается рассматривать только древесные ребра, только они могут быть мостами. Ну что здесь надо
сказать? Ну вот пусть есть какое-то ребро, да, древесное, из VF2. У меня был DFS, он сначала зашел сюда,
затем увидел вот такое ребро в непосченую вершинку Ту, запустился там рекурсивно вот в этом вот
поддереве и посчитал там как-то, что рита Ту равна 3 на Ту. Что это значит? Это значит, что вот отсюда
из всего этого поддерева я не смогу никуда прыгнуть выше, чем в Ту. То есть нет вот таких ребер,
ни такого, ни такого, никуда выше, чем в Ту я прыгнуть не смогу, потому что вот это вот равенство
означает, что, ну вообще, какие значения может принимать рита Ту? Вот куда я могу прыгнуть,
если я рассматриваю риту от какой-то вершинки? Я могу либо остаться вот в самом начале этого
поддерева, либо куда-то, вот если я рассматриваю путь до корня, то я могу прыгнуть куда-то вот на
этот путь от корня до V, да, и соответственно, чем меньше Тин, тем выше я нахожусь к корню,
тем ближе к корню. А если здесь у меня рита Ту равна 3 на Ту, значит, я из всего этого поддерева не
могу прыгнуть никуда, ни сюда, ни выше, ни выше, ну в общем, никуда в корень не смогу. Поэтому единственное,
где я могу быть, это только в этом поддереве. Ну значит, если я просто это ребро удалю, то используя
любые ребра здесь, что древесные, что обратные, я из этой компонента связанности не смогу добраться
в В или выше. Давайте справа налево, да, это мы получается сделали, справа налево. Что если это
верно, если рита Ту равно 3 на Ту, то после удаления ребра ВТУ, после удаления ребра ВТУ,
не будет пути между В и Ту. Ну потому что еще раз, как может выглядеть путь между, давайте так,
путь из Ту в В, при условии, что это ребро удалено. Ну окей, этим пользоваться нельзя. Значит,
все, что я могу сделать, это куда-то там, скажем, спуститься вниз и использовать обратные ребра. Но
все, что у меня здесь есть, из вот этого предположения, обратные ребра меня по-прежнему
оставляют в этом поддереве. Значит, я отсюда никогда не выберусь. Здесь нет никаких других
ребер, я отсюда никак не выберусь, в В точно не попаду. Поэтому, значит, при таком условии у меня
это точно мост. Теперь обратно. Ну пусть не так, пусть перед Ту меньше, чем 3 на Ту. Ну,
понятно, что оно больше быть не может, потому что в определении у меня участвует, в частности,
само значение ТИНа, поэтому мне раньше в другую сторону быть не может. Ну пусть оно меньше. Вот
есть В, вот есть Ту. И я предполагаю, что откуда-то из этого поддерева я могу прыгнуть выше, чем в Ту.
То есть, скажем, в В, например, или еще куда-то выше. Тогда понятно, что после удаления этого
ребра у меня будет путь из Ту в В, например. Тогда, после удаления ребра в ВТУ, по-прежнему будет путь из Ту в В.
Мне нужно сначала спуститься в ту вершину, которая дает вот то самое оптимальное обратное
ребро, затем по нему прыгнуть. Либо я сразу в В попал, либо попал еще куда-то выше,
но тогда нужно просто спуститься по обычным вот этим древесным ребрам до В. Значит, у меня есть путь
из Ту в В даже после удаления этого ребра. Но если есть путь между ними, то я, получается,
смотрите, я удалил ребро из В в Ту, но при этом путь между ними сохранился. Значит,
никакая связанность не нарушилась. Все, что раньше использовало это ребро,
теперь может альтернативно использовать вот этот путь из Ту в В, поэтому связанность никакая не
нарушилась. Значит, граф по-прежнему связан, значит, е не мост. Согласны? Хорошо. Вот,
но мы, получается, построили критерий проверки того, что что-то это мост, осталось его реализовать
в коде. Сейчас-то быстро сделаем. Так, давайте я напишу void-dfs. Ну, начало у нас, как обычно,
мы назначаем parent, parent от В равно P, назначаем ty на V равно timer++. И изначально скажем,
что ret от В это то же самое, что ty на V. Потому что мы знаем, что первое значение, ну, в общем,
чтобы посчитать ret от В, мне нужно взять вот это вот и еще потом его прорелаксировать через
минимум какими-то другими ty-нами. Так, не забываем пометить ее посещенный, just от В равно true.
Ну, теперь обход ребер. Во-первых, если это ребро в родителя, то мы его скипаем. Если true
равно parent, тогда continue. Дальше, что еще бывает? Либо ребро в родителя, либо нормальное обратное
ребро, либо нормально древесное ребро. Значит, обратное ребро это когда just от true. Да, вершина
уже посещенная, значит, ребро обратное. Поэтому, смотрите, мне нужно в частности обновить ret. Мне
нужно сказать, что ret от V, в частности, нужно прорелаксировать ty-нам от true. Картинка такая
здесь. Вот есть V, есть обратное ребро в true. Значит, в частности, из вот этого поддерева я
могу попасть как минимум сюда. Возможно, еще выше, то есть, возможно, я могу спуститься и куда-то еще
прыгнуть. Но в частности, вот это ребро точно есть. Поэтому в этом случае нужно написать следующее.
ret от V равно минимум из того, что там уже и так лежало, и ty на true. Согласны? Ну, просто вот
это ребро используем и обновляем через ty на true. Ну и последнее, когда это все неверно, да, иначе
мы, во-первых, запускаем dfs, tu-V, обычный dfs. Ну, еще при этом нужно ret обновить. ret от V равно
минимум из ret от V и ret от tu. Это картинка такая. Когда мы нашли древесное ребро, вот такое,
вот есть V, вот есть tu, тогда как высоко можно прыгнуть из этого поддерева? Ну, либо используем старую
информацию ret от V, либо можем сначала спуститься в tu, а потом, ну, если здесь ret от tu насчитано
корректно, то я могу, соответственно, куда-то вот сюда прыгнуть. Поэтому это нужно тоже информацию
передать. Знаешь что, я обновляю ret от V через ret от tu. Так, ну и вот здесь мы проверяем, да, вот как
раз применяем то утверждение, что когда мы рассматриваем древесное ребро из V в tu, то на мост,
если только есть, выполняется какое-то равенство. Если ret от tu равно ty на tu,
тогда нужно каким-то образом пометить вот это ребро мостом. Тогда V tu это мост. Ну, тут уже зависит
от постановки задачи. Возможно, вам нужно просто напечатать список всех мостов, либо нужно как-то
там пометить его мостиком, да, то есть, скажем, завести какой-нибудь struct edge, который храни там
откуда-куда это ребро, номер ребра, и булевский флаг является ли это ребро мостом. Тогда нужно
просто у этого ребра поставить метку, что оно мост, ну и потом делать с этим то, что хочет ваш алгоритм.
Все, пометили мостом, завершились. Вот и все. Так, ну тут, наверное, для приличия надо доказать
корректность. Наверное, словами обойдусь. Ну, я хочу доказать следующее, что к моменту времени,
когда V обработано, то есть, к моменту времени, когда у меня, когда я выхожу DFS из вышинки V,
у меня, в частности, корректно подчислены ред от V. К моменту выхода из вершины V
корректно насчитано значение ред от V. Вот, ну если это так, тогда, смотрите, когда я вот здесь
опускаю DFS от 2 с родителем V, тогда я могу предполагать, ну там, по индукции, что когда вот тот
DFS закончился, у меня, в частности, корректно посчитано ред от 2. Значит, зная вот это, я хочу
проверить, что у меня корректно насчитывается ред от V. Ну давайте посмотрим. Вот есть V, вот есть его
под дерево, есть его дети. Все, в общем, древесные ребра из V. Значит, я знаю, что рекурсивно запущусь
от этого сына, от этого сына и от этого сына. Я там правильно насчитал реты по индукции, правильно
насчитал в них реты. То есть, что это значит? Я насчитал ред вот здесь, ред вот здесь и ред вот здесь.
Тогда как выглядит ред от V? Это значит, мне нужно либо сразу взять обратное ребро из V, либо спуститься
хотя бы в одного из сыновей и там взять ред. Ну то есть, спуститься куда-то в под дерево и из него
прыгнуть. Ну это то же самое, что просто в одного из детей спуститься и взять в нем минимально
возможный ред. Все, а как раз ровно так я и обновляю. По всем детям я беру минимум из того,
что там лежало и ред от ребенка. А также я не забываю, что все вот эти вот ребра обратные,
вот это сразу из V обратные ребра, я их тоже учитываю. Что ребра, сразу прыгающие из V куда-то
наверх, я тоже их учитываю. Поэтому вот это утверждение доказывается просто индукцией по нашему
дереву, вот так снизу вверх. То есть, если для этих вышин все правильно посчитано, то для V тоже по
индукции правильно считано. Окей? Ну тогда, наверное, все. За пару минут мы не успеем
следующую мысль сказать. Да, на этом заканчиваем. Спасибо, всем успехов.
