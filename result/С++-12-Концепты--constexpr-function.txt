так у нас пропало в итоге 4 пары получается да ну из них я две попытаюсь нагадать прям
сегодня две в следующий раз короче смотрите что у нас осталось нам с вами осталось закончить тему
шаблонного метапрограммирования по идее мы должны были закончить в прошлый раз и последняя тема
compile time вычисления которая у нас должна быть сегодня и в следующий раз вот я думаю что мы
поступим так я вам сейчас за минут 40 или за час быстренько расскажу ну так не покажу то что
должен был рассказывать три часа вот то есть я не буду там вдаваться в детали я просто чтобы вы
были в курсе чтобы так немного может освежить кто-нибудь посмотрел чтобы не совсем вы сами все
вот или чтобы у вас вопросы можно было задать ну и за одно что вы потом не жаловались что вам это не
рассказывали и спрашивают вот я все-таки вкратце расскажу что там за история тем более это моя
любимая тема одна из любимых поэтому ну как-то совсем не грустно что мы так ее и не прошли вот
а в следующий раз ну тогда уж тайп лист и последняя так сказать финальный аккорд в общем в
следующий раз будет в следующий раз у нас вроде как зачетная неделя но мы я использую нагло этот
раз чтобы восполнить пропавшие выходные у нас не будет алгоритмов это ты конечно сейчас тебя за
это твои коллеги захатят а то есть можно типа в следующий раз а то есть а то есть я могу
типа сейчас рассказать в нормальном темпе то что прошлый раз должно было быть а в следующий
раз рассказать все остальное нет ну короче давайте я в каком-то темпе в ускоренном все-таки
быстренько расскажу то что в прошлый раз собирался и все-таки начну ноутер я не хочу
да я хочу это быстренько так скажем так проспидранить чтобы мы все были в курсе того
что от вас ожидалось и что там имелось в виду вот и дальше я начну рассказывать компайл тайм
вычисления вот проверка наличия методов классе вот она у меня готовая написано с прошлого года
в целом если вы знаете что такое с финаге то вы наверное понимаете как это написать тут
тем не менее есть несколько важных моментов на которые стоит обратить внимание
почему так ладно сейчас мы сейчас мы дойдем до этого а ну вот сразу видно человек смотрел
значит история о чем в чем мы хотим научиться теперь с помощью с финаге с помощью на и был
фа писать ну и нейбл фа про약 полностью в сно сказали проверку что в классе присутствует
данный метод с данными аргументами данный конкретно метод с названием вот за hpeszcze
им название и с данными шаблонными параметрами вот мы написали мета функцию transforming
почему констракт ну мы вот как в аллокатрия как аллокатор троиц проверяет есть ли в
аллокатрии метод констракта данных аргументов ну вот там примерно такая метафункция написано
есть шаблонный тип T, шаблонный ARX, hasMethodConstruct это декл-тайп от вот такой штуковины,
hmchelper, t-arx от нуля. Да, это мы еще в прошлый раз делали. Декл-тайп это полноценный тип,
то есть мы наследуемся от вот такой штуковины, hmchelper с такими-то шаблонными параметрами от нуля.
Ага, раз от нуля, значит декл-тайп пытается выяснить, что это за тип, чтобы от него у наследоваться,
и он должен здесь разрешить перегрузку. hmchelper от int он должен вызвать. Есть на самом деле два
hmchelper, один от int, а другой от всего чего угодно, и конечно же предпочтительнее этот. А этот
возвращает следующий тип. IntegralConstant вот такого типа true. Что такое IntegralConstant мы в
прошлый раз обсуждали. Ему надо вычислить, что это за тип. Ну вот здесь давайте я пока напишу
просто вот так для простоты. Здесь написано декл-тайп от t с круглыми скобочками, точка констракт,
и вместо декл-вал тоже напишу вот так. А что здесь такое? Здесь опять кома-трик. Да,
что такое кома-трик? Мы в прошлый раз обсуждали. Тип этого выражения, это на самом деле буль,
в любом случае. Ну вот под декл-тайпом написано некоторое expression. Вот в этих скобочках написано
некоторое expression. Его тип это в любом случае буль, потому что там оператор запятая стоит. Вот
это оператор запятая. Не просто запятая, а оператор запятая, который вычисляет левый аргумент,
вычисляет правый, возвращает правый. Тип этого выражения буль в любом случае, но это выражение
некорректно, если у типа t нету методоконстракт от таких аргументов. Поэтому, если у типа t нету
методоконстракт от таких аргументов, компилятор, пытаясь понять, какой тип возвращает эта функция,
идет сюда, пытается вычислить этот тип и понимает, что он наталкивается на некомпилируемое выражение.
Значит, эта перегрузка у него отваливается. И остается другая перегрузка, которая менее
предпочтительная, она принимает что угодно, но возвращает false type. Значит, получается, что
hesmet construct наследник false type. А false type это что такое? Это структура, в которой написано static
cons bool value равно false. А если бы он смог вот этот тип вычислить, то есть если бы это было корректным
выражением, то этот hesmet construct был бы наследником true type. А true type это что такое? Это integral
constant bool true. А что это такое? Это такая метафункция, то есть структура, в которой написано using,
точнее не using, static const t value, где t это тип вот этой integral, bool value равно true. Ну вот и все,
вот и получилось, что в зависимости от того есть или нет этот метод у данного типа от таких
аргументов, у нас написано либо static cons bool value равно true, либо false. Здесь есть проблема. Вот я
стер тут decal val, значит, есть некоторый decal val и я вместо него написал вот это. Здесь есть проблема.
Кто смотрел прошлогодние лекции, тот знает какая, да в принципе можно и так догадаться какая. Это
может отвалиться по причине не того, что мет метод construct от таких аргументов, а по причине того,
что у t нет конструктора по умолчанию или у args нет конструктора по умолчанию. Что же делать? Нам
надо как-то по типу t получить объект t. Мы не можем написать t круглой скобочки, точь констракта,
args круглой скобочки, потому что а вдруг нет конструктора по умолчанию, тогда мы отвалимся,
хотя метод констракта может быть был. Нам нужна специальная функция, которая, ну можно было бы и
без нее обойтись, что нам надо сделать? Нам нужно некоторым образом получить здесь выражение типа t,
не обращаясь к конструктору t. А как это сделать? Ну давайте просто запрячем это в еще один вызов
функции. Давайте напишем функцию, которая просто возвращает t. Но я могу опять же, я опять упрощу,
я вот так напишу. Я могу написать так. Это функция, которая просто возвращает t и
значит deckLVal от t круглой скобочки, констракт deckLVal от args круглой скобочки. Это функция,
которая возвращает t, и неважно как она реализована, потому что мы же ее не вызываем. Компилятор же
лишь тип вычисляет, какое выражение получится. Поэтому на самом деле эту функцию можно и не
реализовывать никак. Она никак не реализована. Значит на самом деле в стандартной библиотеке есть
такая функция std deckLVal. Она просто содержит такое объявление для произвольного t, возвращает тип t,
и никак не реализована. Попытка вызвать ее, это ошибка линкера. Но она не предназначена,
чтобы ее вызывали, она предназначена, чтобы только под deckLType быть использована. Ну и последнее
уточнение, это что здесь должно быть t2 амперсанда, а не просто t. Кто понимает почему? Что-что? Ну сегодня
у вас, на самом деле я вам скажу так, вот последние две наших встречи сегодняшней в следующий раз,
это окончательный гвоздь в крышку гроба, попытка убедить вас не писать на c++ окончательно,
и проклянуть этот язык. Вот сегодня еще будет не совсем, но в следующий раз совсем. Так вы говорите,
что это ваша любимая тема. Это моя любимая тема, потому что она как раз... Ну например по этому. Ну мои
вкусы специфичны весьма. Впрочем, если вы прошли на продву, то наверное ваши тоже. Так,
почему здесь t2 амперсанда, а не просто t? Да нет, никто не вызывается. Ничего вообще не вызывается,
у нас только тип оценивается. Т может быть incomplete type. Что такое incomplete type? Это тип,
который вообще не реализован. Или, например, t это может быть некоторый класс, который сам по
себе шаблонный и его инстанцировать надо. Чем отличается t от t2 амперсанда? Тем, что ссылку на
тип можно завести, не инстанцируя сам тип и даже не зная определение этого типа. А если бы мы просто
t возвращали, то компилятору пришлось бы выяснять, что такое t. Как минимум компилятор бы требовал
определение, и он попытался бы подставить в определение конкретные типы, которые у нас тут
имеются. Мы с вами обсуждали, когда говорили про инстанцирование шаблонов в прошлый раз,
что для получения ссылки на t не нужно знать определение t. Ссылка на t это всегда 8 байтов,
всегда поинтер просто. Ну, для чего нужно узнавать t, чтобы понять его размер? Ну,
не единственное, там много для чего нужно узнавать. Но правило такое, что для того,
чтобы компилировать выражение, в которое фигурировать тип t, нужно, чтобы компилятор знал
определение t. Ну, вот так вот. А для ссылки не нужно. Ну, в частности, если у t нет определения,
ну, если я просто написал там класс какой-то c точкой запятой, то вернуть из функции объект
c это будет некорректным выражением, потому что t неопределен. А вернуть ссылку на t будет
корректным выражением, потому что неопределен. Ну и что? Мы не требуем определения, мы требуем
лишь объявления. Нет, это нормально, мы про это говорили, типа указатель или ссылка на t не
требует знания определения типа. Определение типа может быть в какой-то другой там единиц
трансляции, компилятор не будет туда лезть, он не будет искать определение типа, чтобы завести
ссылку на него, это ему не нужно. Ну, например, да. Вот, почему возвращаем r-value ссылку? Потому
что если бы возвращали l-value ссылку, то мы бы тип value нарушили. Ну, потому что мы хотим здесь
получить объект t как r-value. Если бы мы l-value ссылку возвращали, мы бы получили l-value expression.
В чем прикол возвращать r-value ссылку? В том, что мы получаем такой же вид value,
как если бы возвращали просто t, но при этом не требуем определение t быть доступным.
Нет, это r-value ссылка. Мы не принимаем t как аргумент, мы t явно указываем.
Ну, t здесь не принимаемый аргумент, а возвращаемый тип.
Как мы решили проблему с вызовом конструктора?
Какого конструктора?
Мы же все равно пишем d-col-val-a-t от...
Нет, мы не требуем наличия конструктора сейчас. Мы говорим компилятору,
проверь какой тип у этого выражения. Компилятор такой, хорошо, какой тип был бы,
если бы я у результата d-col-val-a-t вызвал констракт. Что такое d-col-val-a-t?
Это ссылка r-value на t, то есть тип этой штуки это t r-value. Тип t и категория выражения r-value.
Дальше мне надо проверить, есть ли у него констракт. Но компилятору не нужно проверять,
что у t есть какой-то конструктор. Он вызвал функцию, которая возвращает...
Он увидел, что функция возвращает t 2A sando, и это означает, что ему не нужно проверять,
что есть там еще какая-то версия, как это t создается. Что d-col-val никак не определена,
это проблема не компилятора, а линковщика. Компилятор же он только типа проверяет,
но d-col-val мы не вызываем.
Непонятно еще раз, если мы заменим 2A sando на 1, что сломается?
В случае, если бы t не имел определения, мы бы не могли использовать d-col-val для таких типов.
Но конкретно в этом случае мы бы все равно не могли использовать вот эту конструкцию,
потому что вызов констракта t требует определения t. Но если мы занимаемся профессиональным
метапрограммированием, так сказать, где типы могут быть вполне себе без определений,
просто какие-нибудь заглушки, то d-col-val можно вызывать даже не инстанцируя определение типа.
Простая ссылка тоже не инстанцирует, но она портит width-value. Мы хотим,
чтобы здесь был t, но не хотим, чтобы было доступно определение t. R-value ссылка,
она сохраняет width-value такой же, как если бы просто t создали.
Ну потому что я хочу здесь написать что-то в духе t, но я не могу написать t,
потому что вдруг t нет конструктора по умолчанию. Что мне написать? Мне нужен
какой-то expression, который мне дает готовый t, но из чего мне его взять? А вот такую функцию
использовать d-col-val от t. Но если бы она начала l-value ссылку, то это было бы не совсем то же самое,
потому что width-value был бы другой. Вдруг этот метод констракт, он определен только у r-value,
а у l-value запрещен. Тогда d-col-val от t мне бы давал не совсем эквивалентную штуку,
как если бы я просто t вызвал. Если я хочу l-value t, то я так и напишу d-col-val от t-ampersand.
Тогда мне вернется, ну по правилам сворачивания ссылок, t-ampersand, 2-ampersand, то есть t-ampersand.
Если я хочу l-value получить с помощью d-col-val, я могу это сделать. А если я d-col-val от t пишу,
то я хочу получить r-value. Но такой r-value, который не требует инстанцирования самого t. То же самое
d-col-val от arcs. Вам говорить, что вы еще в d-col-val забыли? TypeName t равно void? А что еще забыл? Ну
accept? Ну на самом деле человек молодец, потому что посмотрел лекции. Что могу сказать, хвалю.
Че, только с ватей в лекции посмотрел? Вот это кстати может быть, но это я не знаю.
Ты тоже, значит, посмотрел лекции? Да, хорошо. Да, ну наверное add r-value reference, а не t-2-ampersand,
потому что для void тогда это будет некорректно работать, да? Хорошо.
Add r-value reference это просто, ну, обрабатывать отдельную ситуацию, когда void. Да. То есть это просто
костыль для этой ситуации. Удобный язык программированный. Что? А когда мы проверяем, есть его локатор и метод
констракта? Да. Или пытаться вызвать его от l-value выражение? Ведь когда мы в реальности вызываем
констракт от l-value, почему мы проверяем от r-value? Я на самом деле не знаю, может там и от l-value
проверяется. Ну я говорю это так скажем в учебных целях, то есть я объясняю как устроен d-col-val
просто на этом примере. Может быть в случае локатора разумнее проверять так, да? А если мы просто сюда
передадим именно, когда будем всех helper вызывать, просто ему в качестве шаблонного параметра
от l-value дадим? Разве мы не получим как раз проверку для... Да, получим. Ну вот тогда нам в любом случае
выгоднее написать так. Ну да, наверное да. Просто потому что мы снаружи можем, по умолчанию оно проверяет для r-value,
но мы можем просто снаружи передать туда не t, а l-value и проверить конкретно для r-value. Ну да. То есть
это просто более общая реализация, которая... Вот. Пару слов про d-col-val еще. Почему он так называется?
Это может быть... Почему он так называется, понимаешь? Ну вы говорили. Ну я знаю, да, я много раз говорил,
если б ты еще поза прошлого года лекции смотрел, ты бы представил как мне тяжело живется. Так это то же самое, что и t-col-val.
Да, это как бы обратная к d-col-type операция. Смотрите, что такое... Почему d-col-val? Потому что это штука, которая
по типу дает вам значение, а d-col-type по значению дает вам тип. Это как бы взаимно обратная... Ну вот. Я это сам, кстати,
не сразу понял далеко, потому что кажется это такое не очень понятное название, но становится понятно, если вы
немножко позанимаетесь шаблонным метапрограммированием. D-col-type это как бы штука, которая из мира значений
переводит вас в мир типов, а d-col-val это штука, которая переводит вас обратно из мира типов в мир значений.
При этом d-col-type это как бы метафункция, а d-col-val это функция в обычном понимании. Вот. Понятно, что таким же
способом можно написать проверку из constructible, из convertible, из copy constructible, из move constructible,
из... В общем, проверка того, что тип можно создать из чего-то другого, например, из constructible. Как
написать? Таким же способом просто здесь нужно другое выражение. Вот. Теперь дальше. Из no throw move
constructible. У нас была проблема, как написать из no throw move constructible. Напоминаю. У нас есть функция
move of no accept, которая устроена так. Она принимает tm% и возвращается to conditional. Из no throw move
constructible или не из td из copy constructible, тогда tm2m% иначе const tm%. Зачем нам нужна была
функция move of no accept, а в векторе, когда мы перекладывали, чтобы если там move constructor
не no accept, то мы бы копировали, а не move-али. Как написать из no throw move constructible? Наивный
подход. Можно попробовать написать из move constructible и no accept от move constructor. Ну,
от выражения вызова move конструктора. Но это неверно, потому что, если вы так напишете,
у вас move конструктора может не быть, тогда это не скомпилируется. Вы не можете просто через
и оператор no accept выразить из условия, что no throw move constructible. Ну, наивный подход к
реализации из no throw move constructible. Какой? Написать это все равно, что из move constructible и,
обычное и логическое, но accept от t, от std callval, от t круглые сковочки. Почему это неправильно?
Потому что, если нету move конструктора, ну, если он delete, то это будет ce, потому что
конъюнкция работает так, что правая часть пусть и не вычисляется, если первая ложная, но она все
же компилируется. То есть из move constructible false, потому что нет move конструктора. А дальше
написано и, но accept от move конструктора. Но логическая конъюнкция, она short-circuit,
но это не значит, что она не пытается проверить корректность на компилируемость вторую часть.
Она не вычисляет вторую часть, если первая ложная, но она все же пытается скомпилировать
вторую часть, если первая ложная. Что значит вычисляет с точки зрения компиля? Значит ничего. Как будто
пытается скомпилировать и вычислять, то тоже в терминах. Может быть, но тем не менее она пытается
скомпилировать. В общем, а тут как бы вопрос в том, что почему бы нам не использовать
стд конжанкшн, который у нас есть. А что ты напишешь под стд конжанкшн на втором? Стд конжанкшн,
она принимает метафункт. Она должна принять штуку true type, то есть там должно быть что?
Да, в стд конжанкшн нужно передать нечто, что является integral constant в каком-то смысле,
что является full constant. Короче, так не получится. А как тогда? Ну вот так. То же самое. А где у меня
это написано? Так, подождите. А где у меня изнофромов констрактибл? Ну понятно, что здесь написано,
все то же самое я делаю. Просто я делаю изнофромов констрактибл helper от чего угодно,
который false type возвращает, а также изнофромов констрактибл helper, который, ну например,
это один из вариантов, как можно реализовать, который принимает первым аргументом int,
а вторым аргументом по умолчанию принимает вот такую штуковину. Enableift от вот такого,
запитая bool, равно true. Соответственно, если мы вызываем int mnc helper от int, он пытается идти
сюда, пытается понять, что тут за второй аргумент. Если у него это не получается, он отваливается,
идет в эту версию, которая false type. Ну это как вариант, можно и по-другому реализовать, в общем.
Ну и самая вкуснятина это из базов. Кто досмотрел это из базов? Отлично. Значит,
вот это самая вкуснятина. Ох, не надо, пожалуйста, Илья, не пугай. It's T++ time.
Я думаю, как бы это рассказать вкратце. В общем, ну хорошо, вот мы хотим написать проверку,
что тип является наследником один другого. Значит, давайте...
Ну короче, что я хочу сделать? Я вот это сейчас закомментирую. Давайте быстренько,
все-таки я освещу, как работает из базов. То есть, наивная реализация из базов такая. Я
делаю из базов helper от одного шаблонного аргумента. Вот. Сейчас. Нет, кажется, не так.
Здесь не от нуля надо, а вот. А вот. Declval от D звездочки, от null, от круглых скобочек,
по-моему, так, да. Сейчас, я уже забыл, как там это делалось в самом начале. Ну короче, идея в
чем? Я хочу проверить, правда ли один тип наследник другого. Я пишу из базов, но это,
во-первых, conjunction, что первый является классом, второй является классом, и вот дальше самое
интересное. Я пишу из базов helper, которому отдаю указатель на D. А у меня есть две версии
базов helper. Один принимает указатель на B, а другой принимает что угодно. И первый возвращает true
type, а второй возвращает false type. Что я этим добиваюсь? Если D наследник B, то, ну, в любом
случае предпочтительно вот эта версия. Но если D наследник B, то эта версия подходит, а иначе она
просто не подходит. Правильно? Значит, если D наследник B, то выбирается эта версия, потому что
лучше вызваться от B звездочки, если вызвали от D звездочки, чем от чего угодно другого. А она
возвращает true type. Если D не наследник B, то эта версия просто не подходит. Ну, она просто вообще
не является кандидатом на перегрузку, потому что D звездочка не кастится к B звездочки, не подходит
эта версия. Значит, выбирается эта версия и поэтому false type. Так? Вроде нормально, но какая здесь
проблема? В каком случае это будет не работать? Ну, даже не множественное. Приватное наследование.
Если наследование приватное, то такая реализация даст CE. Почему? Потому что проверка доступа
после разрешения перегрузки. Пусть D от B унаследовано приватно, тогда первая версия предпочтительнее,
потому что B звездочка-то это же, ну, да, подходит, но наследование приватное и мы упадем с ошибкой
компиляции, нельзя скастить D звездочка к B звездочки. Эта версия не будет рассмотрена, потому что
приватность проверяется после разрешения перегрузки. Напоминаю, кто забыл. Ну, идея первая, вспомнить,
что мы уже в велосипеде из костылей и перестать с компилятором ругаться на эту комплектную функцию.
Значит, как мы обходим эту проблему? А мы делаем еще один уровень индирекции. Мы делаем вот такую
функцию. Тест из Бейзов, которая от Инта, и смотрите, что происходит. Тест из Бейзов от Инт,
она возвращает декл-тайп от того, что вернула бы, ну, короче, она возвращает то, что вернула бы
вот та функция. Мы в тест из Бейзов отдаем Инт, и версия от Инт возвращает тот тип,
который бы вернула из Бейзов хелпер от D звездочки. Но это может отвалиться. Вот это вот выражение
может быть некорректным по причине приватности. И это выражение может себе содержать ошибку
компиляцию из-за приватности. Что тогда мы делаем? Значит, эта версия по сфинае нам не
подходит. Значит, нам подходит другая версия, которая отчего угодно, а она возвращает true
type. Почему true type? Да потому что D наследник B. Если мы попали сюда, это значит, что здесь было
приватное наследование. Значит, мы отвалились там, потому что была приватная. Значит, мы должны
сказать, да, это наследник. Вот. Я считаю, что это шедеврально. Я не знаю, как вы, но мне кажется,
это просто прекрасно. По-моему, это просто шедевр. Вот. А что, кстати, с множественным
наследованием? Да-да, можно сфоткать еще. А что с множественным наследованием? А то же самое.
Множественность наследования, она тоже проверяется. Так случайно совпало, что множественность
наследования, она тоже проверяется после выбора версии перегрузки. То есть, на самом деле, мы одним
махом били двух зайцев. То есть, на самом деле, если у нас амбигиус приведения типа от D звёздочек
к B звёздочке, если у нас было ромбовидное наследование, мы тоже решим эту же проблему,
потому что мы тоже отвалимся здесь по причине ошиб компиляции вот именно здесь и попадем сюда,
где ответ TrueType. Таким образом, Избейзов проверяет, отвечает да, в том числе в случае множественного
и приватного наследования. Сейчас, почему в случае предпадного наследования мы не попадаем просто
во второй Избейзов Хелпе? Потому что приватность проверяется после выбора версии. Ну,
правила языка такие, мы их обсуждали. Это мы обсуждали в первом семестре, что мы сначала решаем
какую версию вызвать, а потом проверяем доступ. Скорее вопрос, почему она вообще проверяется в Финаге.
Кто проверяется? Нет, Финаге полноценно проверяет корректность вот этого выражения. Он проверяет
полностью компилируемость вот этой штуки. Если это корректная штука, то он...
Ну, то есть, не если. Он просто проверяет, корректно ли с точки зрения компиляции вот это вот выражение.
Оно некорректно. Поэтому отваливаемся, идем сюда. Вот, ну и последнее, это Common Type. Что такое Common Type?
Значит, это метафункция, которая выводит как бы общий, наименьший общий тип для данных N типов.
Вот, что такое Common Type от N типов? Это Common Type от двух данных, от двух первых и от всех остальных.
Да, ну то есть, в случае N типов легко сводится к случаю N-1 типа. Осталось ответить на вопрос,
что такое Common Type от двух данных типов. Как вычисляется Common Type от двух данных типов?
Не используете или используете? Ну, давай, ладно, давай остальные подумают. Значит, так сказать, это
мой тоже любимый вопрос в зал. Как бы вы вычислили наименьший общий тип для двух данных типов?
Ну, не LCH-ку, на самом деле там еще чуть хуже, да, но... А если попытаться там, типа, автопункция,
которая... Да нет. Вот. Осознайте. Значит, осознайте все величие, всю прелесть того,
к чему вы прикоснулись, только что. Значит, как нам понять общий тип для двух данных типов?
Нам нужен некоторый expression, тип которого, и есть общий тип для двух данных типов. Да. Ну,
у нас, к счастью, в языке уже есть некоторая конструкция, которая дает нам общий тип для
двух данных типов. Это оператор знак вопроса двоеточия. Мы просто говорим, пусть тип это будет
такой, как получился бы, если мы сделали decal type от знак вопроса двоеточия для двух данных типов.
Тут написано true, потому что неважно какое-то выражение, нам важен тип того,
что получилось. Значит, мы получаем общий тип для T1 и T2 вот таким способом.
А если наследование приватное будет ничего сломаться?
Сломается, конечно. Вот. Поэтому common type от двух типов, это просто, значит, то,
какой тип возвращал бы оператор знак вопроса двоеточия от двух данных типов, а common type от
T1 типов это просто сводится в common type от T1 типов. Легко. Вопрос можно ли это реализовать
без использования оператора тернального? Это просто забавно, что какие-то нишевые операторы находят
применение в каких-то таких более высоком уровне. Так, ну, в общем, умение писать такие тернавики
никогда. Да, как я могу это прокомментировать? На самом деле это работает хуже, чем вы могли бы подумать,
потому что, например, если у вас есть хуже, чем вы могли бы подумать, это не может работать. Нет,
вы все еще недооцениваете масштабы. А если у вас, допустим, есть мама и есть сын и дочь,
в общем, если у вас есть класс mother, класс son, класс daughter, и вы попробуете найти общий тип для
сына и дочери, то вы не найдете его. Это будет CE. На самом деле STD common type тоже не может найти
общий тип для двух данных. Для сына и дочери, если у них есть общая мама, он не найдет общий тип.
STD common type тоже сделает CE. Ну, потому что это было изначально, что ему придется перебрать все
существующие типы и понять, то есть компилятор, короче, не поддерживает такую структуру у себя,
а он так не умеет, к сожалению. Вот, но вот если у вас общий тип для мамы и сына, то он скажет,
что это мама. Вот. И наша реализация, она плоха еще тем, что корректность ее работы зависит от того,
на каком месте мама стоит. Вот, смотрите, представьте, что я спросил common type от son,
daughter и mother. Тогда это будет CE. А вот если бы я спросил общий тип от mother son и daughter,
то это было бы mother. Почему? Да потому что я сначала вычислил common type от T1 T2,
а потом только к нему добавил T3. Но если я упомянул маму последний, то для T1 T2 это уже будет CE.
Разумеется, разработчики языка почитали, что такое поведение это нормально и выкатили этот продаж.
Нет, разработчики языка, значит, на самом деле STD common type реализован сложнее, и там эта проблема
устранена. То есть там сделано так, что неважно на каком месте вы укажете mother. По-моему, я надеюсь.
По-моему. Вот, но есть и другая причина, по которой decal type реализован не так.
Мне кажется, что там кто-то храпится. Да.
Когда я в 4 часа утра заканчивал делать алгосы, Вася все еще их писал. Может его разбудить все-таки,
но как-то просто нехорошо. Нет, я не против, чтобы он спал, но просто звук отвлекает.
Ну просто ты очень громко храпишь, даже я слышу отсюда. Я не против, чтобы ты спал,
но ты хотя бы вот так ляг, чтобы мы не слышали. Ладно, хорошо. Да, в общем STD common type реализован не так, а вот так.
STD decay это штука, которая убирает амперсанды и разрушает массивы до
поинтров, это мы уже обсуждали неоднократно. В общем, помимо проблемы, о которой я сказал,
что важно на каком месте стоит, собственно, искомый type, есть еще одна проблема. Возможно,
она здесь не упомянута. Илья, такое поведение, что он не умеет интеллектуальные случаи обрабатывать,
это по стандарту или это просто капиллятор не умеет? Не, по стандарту. А то есть по стандарту он проверяет,
только если они прям один, жестко наследник другого? Нет, common type он пригождается, когда вы,
например, у вас есть in, double, char, float, тогда common type будет double. Это типа,
к которому они все могут привестись. Если из данных типов существует тип, которому они все умеют
приводиться, то он его найдет. Это не обязательно наследование, это может быть что угодно. Наследование
частней лучшей, да. А вот у нас же там, ну, можно какие-то алгоритмы написать на типах,
а что, нельзя там написать какой-нибудь там, ну, реальный LCA написать? Ну, к сожалению, нельзя. Ну вот,
я, слушайте, наблюдая за тенденциями развития C++, я, в принципе, допускаю, что когда-нибудь это станет,
что это вскоре станет можно, потому что можешь внести пропузал в комитет, хотя, я думаю, уже кто-нибудь
вносил. Ну, короче, пока нельзя. Ну, так вот, почему-то решил комитет по стандартизации. Ну, так же работает.
Почему, и чего не делается в строительных комплятах? Что нельзя было бы не высокого уровня, не на
высоком уровне это реализовывать? Я не знаю, так исторически сложилось, я ничего не могу сказать
по этому поводу. Ну, вот так вот. Ладно, короче, давайте я не буду, поскольку мы все равно, типа, я обещал не закапываться в
подробности, я не буду сейчас вот это вот все обсуждать, почему тут так и почему реализация вот так устроена.
Короче, по некоторым причинам реализация через тернарный оператор, она плоха, и вот, в общем, тут нужно
некоторые дополнительные надстройки. Ну, ладно, бог с ним. Вот, напоследок, давайте обсудим концепты.
Напоследок.
Класс. Да, уж, конечно, напоследок это такое. По-хорошему, на концепты бы неплохо бы и две пары занять,
так сказать, не грех, но... Так, сейчас. По-моему, есть прикол, что концепты рассказали где-то в базе,
уже. Ну, ничего страшного. Нет, научиться пользоваться концептами не сложно.
Сейчас, ладно, ну, короче, давайте я открою просто файлик концепты. Там много изменений,
так, а давайте я вот так просто сделаю. А, концепт 2, все, отлично, вот уж я не думал. Смотрите,
какая история. C++20 вводит замечательное ключевое слово requires. Почему-то у меня его не подсвечивает
vim, что печально. Это довольно печально, да. Ну ладно. Да, это штука, которая в C++20 пришла на замену
enableif на самом деле. Вот, и на самом деле enableif, ну, в большинстве мест подобных все еще используется
enableif, потому что на C++20, как вы понимаете, все переходят не сразу. Я думаю, еще ближайшие лет 5,
какое там 5, если у нас сейчас много кто пишет, даже на 17-й не перешел. Ну, короче, ну, не знаю,
ну, ближайшие лет 5 точно, я думаю, еще enableif будет в ходу. Но постепенно люди начинают переходить
на более человеческий синтаксис. В C++20 люди поняли, что вообще-то можно придумать наконец нормальную
синтаксическую конструкцию проверки того, что тип допускает какие-то операции. И не писать вот
эту вот хрень, вот эту вот enableif, шаблонный параметр какой-то, совершенно сумасшедшая вещь.
Раз уж мы все равно это умеем писать, давайте просто введем нормальную синтаксическую конструкцию,
чтобы это делать. И такая синтаксичная конструкция появилась, называется requires,
requires-keyword. Мне кажется, будет проще открыть просто на себе переференс ее. Ну, то есть,
по-хорошему я должен был на это целую пару потратить, но раз уж мы все равно, так сказать,
speedrun делаем, то... Не, я хотел speedrun именно. Вот, что такое requires? Это штука,
которая позволяет вам... Блин, тут все только на примере концептов показано, к сожалению.
Ну, не на примере концептов, давайте я вам покажу. Я могу написать requires от какого-то типа,
там, от s, x, и здесь написать какие-то операции над x. Это expression. Ну,
я могу вот так сказать. Сейчас мне не скомпилируется, наверное, по какой-нибудь причине. Так,
извините. Чего? Нет, структура
это не expression, нет. Я так обожаю твои синтоксические вопросы каждый раз,
ближе к концу года обычно. Сейчас, структура... Что? Это не expression, это объявление, declaration.
Что? После объявления структуры ставится точка, после объявления функции не ставится. Ну,
такой синтоксис, что поделаешь? Так, минус std равна c++20. Блин, жалко, что я, конечно, не... Ну,
да, вот. Сейчас, чёрт. Сейчас, я не понял, почему вот это ничего не вывело.
Не, не, requires я хочу. А, concepts2. Всё, я понял.
Нет, нет, нет, это не работает. Я ощущение, что он не научился пока. Так. Ну, короче,
что такое requires? Requires это штука, это expression. Requires expression. У вас есть ключевое слово
requires, после чего вы можете в скобках как бы принять некоторые аргументы как функцию, а дальше
некоторые написать набор экспрешенов, и ваш requires вернёт вам true, если это корректные
экспрешены всё были. И false вернёт, если не корректные. Да, если они не скомпилировались.
Не знаю, почему. Так, давайте я попробую вот здесь-то написать. Вот у меня структура s.
Значит, что? А я не буду. Ну вот, допустим, так я напишу. И точки запятой не хватает. Так,
всё равно не работает. Да что ж такое-то? Что, я не умею пользоваться requires
expression? Да вы чего хоть. Господи. А, ну видимо это только в шаблонах, что ли, можно делать. Ну-ка.
Давайте-ка я сделаю шаблонную функцию. Сейчас. Template type name t. Avoid f. И вот тут я сделаю вот так.
Requires от t. Вот, плюс плюс x. И теперь я, значит, вот допустим верну это из функции. И здесь я выведу
сначала f с шаблонным параметром int, а потом выведу f с шаблонным параметром s.
Ну и у стрим само собой сейчас подключим. Господи. Нет. Вот, ну теперь это скомпилировалось и теперь я
утверждаю, что вот первый вызов вернет true, а второй false. Да, ну, значит, это может только с
шаблонными типами делать. С конкретным типом, видите, он не справился. Ну, ему, видимо, надо,
чтобы это было мета, чтобы t был переменным типом, а если я подставил конкретный, ну так работает.
Значит, да, я опять должен сделать disclaimer, который я делал в прошлом году. Он, в принципе, остался в
силе, что мало кто этим умеет совершенствовать пользу в самом числе я. И на самом деле тут,
возможно, неочевидные баги, которые даже разработчики компиляторов пока не в курсе о них. Поэтому если
вдруг вы увидите странное поведение в этих концептах или Requires, возможно, это не вы, глупые,
возможно, это ошибка компилятора или, возможно, это ошибка разработчиков стандарта, что они не
предусмотрели это. То есть это, как бы, достаточно новая фича, чтобы она была прям идеально всеми
протестирована и проверена, как она работает. А что это? А это какой-то тракедий, что ли? Вот. Что такое
Requires Expression? Это штука, которая проверяет, допустим, для вашего типа вот такие операции. В том
числе здесь можно написать вызов какого-нибудь метода от вашего x, там, констракт, например,
создание чего-нибудь другого. То есть здесь можно написать произвольный набор экспрешенов.
Выражение Requires вернет вам true или false в зависимости от того, корректны ли все эти выражения. Вот. Но это не
все, что она умеет проверять. Она умеет проверять еще более сложные констрейнты. Это называют
констрейнты. Да. Ну, во-первых, есть Simple Requirements. Это вот то, что я сейчас сделал. Значит, это просто
проверка того, что такие экспрешены корректны. Вот. Или, например, Swap, что вот так можно сделать,
что экспрешены корректны. Дальше могут быть Type Requirements. И это проверка того, что данный тип
существует и корректен. Например, я могу написать TypeName вот так. Это не Expression. Тем не менее,
я могу написать просто вот так и точка с запятой. И это будет проверка того, что такой тип существует
и корректен. Я могу написать вот так TypeName какой-то шаблонный класс подставлен T. И он
проинстанцирует и проверит, что подстановка T корректна. Вот. Это Type Requirements. Дальше Compound
Requirements. Я могу написать, что... Пропустим эту часть. Nested Requirements. Ну, вернемся,
когда я расскажу, что такое Concept. Nested Requirements. Я могу написать... Ну, скажем,
внутри Requires еще какой-то Requires. Или я могу написать, скажем, что некоторые операции
является noexcept. Ну, короче, очень много всего я могу написать. Просто я не прошу вас это учить,
я просто показываю вам, сколько всего добавили нового C++20. Это Requires Expression. Понятно,
Requires Expression. Штука, которая позволяет вам проверить, корректны ли данные выражения или данные
типы, или выполняются ли некоторые Compile Time условия относительно них. А теперь Concepts. И вот
это самое главное. Что такое Concepts? К сожалению, меня не подсвечивает Vim, потому что я, видимо,
обновлял, переустанавливал все, и он ключевое слово Concepts Requires не знает пока. Что такое Concept?
Это новая сущность вообще в языке, наряду с типами, с классами, с шаблонами. Это новый
вид сущности. Concept — это некоторый, как бы, множество типов. Что такое Concept? Concept — это такая
сущность, которая отражает идею набора типов. Вот про тип можно ответить, он относится к данному
концепту или нет. Он представляет собой данный концепт или нет. Например, я могу ввести такой
Concept Input Iterator. Вот. Что такое Input Iterator? А я могу сказать, например, Input Iterator — это такая
штука, которая позволяет себя инкейментировать и разыминовывать. И как я это могу написать? Я
могу сказать, template typeNameT Concept Input Iterator равно... Здесь я могу написать либо какое-то
булевское выражение относительно, ну, либо метафункцию относительно T. Ну, вот, как, например,
здесь я написал Concept Polymorphic. Polymorphic — это некоторый концепт, который говорит,
что тип является полиморфным. У меня уже есть метафункция из Polymorphic V, которая приведает
сущность, что тип является полиморфным. И я могу просто эту метафункцию сюда впендюрить. Я могу,
то есть, булевское выражение написать здесь. Concept Input Iterator равно и некоторый булевский
expression от T, как бы, метафункция. У меня получится Concept Polymorphic. А могу написать requires,
ну, что, в общем-то, тоже булевское выражение. Я могу написать requires и здесь сказать разыминовать
x и plus plus x, допустим. Вот, это то, что должен иметь мой Input Iterator. Ну, на самом деле он должен
иметь еще что-то, но, допустим, для простоты, что Input Iterator только это должен иметь. Теперь
мой Input Iterator это некоторый вид типов. Такой, что я могу его передавать функции. Я могу его
использовать как шаблонный параметр. Ну, вот, что я могу сделать? Я могу говорить template и не как
раньше писать type name Input Iterator, потому что это был костыль. Вот, вы согласны с тем, что это был
некоторый ужасный костыль. Мы, когда в алгоритмы передавали итераторы, мы костыляли название типов,
специально название шаблонных параметров, чтобы они отражали суть. У нас в стд, ну, у нас в алгоритме,
в заголовочном файле алгоритм, все алгоритмы принимают type name и этот type name особенным
образом называется, в зависимости от того, какой итератор они ожидают. То есть, там, например,
stdsort ожидает random access итератор, и поэтому там type name random access итератор. Хотя, по факту,
мы можем отдать туда не random access итератор, и название типа не будет отражать суть того,
что туда передали. Это был костыль, с которым мы жили очень долго. Так вот, наконец, концепты,
они эту проблему решают. Теперь мы не названием отражаем суть того, что передаем, а как бы самим
шаблонным параметром мы говорим, что теперь мы в шаблон передаем не просто какой-то type name,
а именно std input итератор. Ну, std input итератор это просто вот стандартный концепт, который
одержит в себе requires то, что input итератор должен уметь. Я могу сказать template и здесь написать
input итератор. Вот мой input итератор. Итер. Господи. Теперь input итератор это концепт,
а итер это название типа. И вот сюда я уже принял итер. И если я в эту функцию в качестве параметра
отдам не input итератор, то есть такой тип, который не удовлетворяет требованиям к input итератору,
я получу ошибку в компиляции. Не что там на 25 строке я пытаюсь выполнить операцию,
которая не разрешена, а что нарушен концепт, нарушен requires. Ты пытаешь создать функцию,
которая принимает input итератор, тип, который не является input итератором. И это очень круто.
То есть мы теперь на типы можем накладывать ограничения, вот эти вот, говорящие о том,
какой именно тип мы ожидаем получить на вход. А вот вопрос. Есть условный input итератор,
можно ли как-то через концепту наложить более сильное примчение, что input итератор на
какой-то тип, чтобы типа разыминование давало нужное? Конечно можно. Сейчас расскажу как так.
Сейчас минутку. Что это шаблонный параметр концепта? Подожди минутку.
Параметризировать концепт? Да, да, да. Ну, в смысле, чтобы концепт сам по себе был шаблонный.
Может быть, это не все, или это очень шаблонная магия, может быть, что-то с вас?
Мы концепт инсуцируем каким-то типом, который по себе содержит точно две точки в бэде.
Я просто спрашиваю, как мы инсуцируем концепт чем? Концепт просто. В смысле, мы его инсуцируем,
или мы типом, который содержит в себе? Нет, это будет выражение. Так, я отвлекся. Какой вопрос был?
Можно ли дополнительно параметризировать концепт, чтобы можно было, понятно, что не так, но типа
что-то наподобие input-интератор в уголовных скобочках сказать вот int и предполагать,
что это будет концепт, который принимает input-интератор на int. Короче, шаблонный концепт.
Сейчас, ты хочешь дополнительно к требованиям на input-интератор еще какое-то навесить требование?
Я могу делать составные концепты, я могу сказать, да как же он меня достал-то. Я могу сказать,
что это input-интератор и что-то еще. Мы хотим input-интератор, у которого звездочка возвращает U,
и requires от t, x. Что? Звездочка возвращает t. Звездочка x. Compound requirement сейчас будет.
Стрелочка is same as что надо. Стоп, стоп, стоп. Ну, я же вам показывал, что requirement-ы бывают вот
такими. Я требую, чтобы звездочка x была convertible to, например, это. Или вот это выражение было
same as такой же, как вот этот тип. А вот этот тип теперь хочется сделать типа не постоянным,
короче, чтобы этот тип можно было как-то снаружи задавать для этого концепта. Ну,
второй шаблонный параметр можно отдать сюда. И то есть мы явно будем указывать шаблонные
аргументы концепта. Мы будем писать constant input-interaтор от одного типа, это подставится
во второй аргумент, и то, что пойдет после этой штуки, подставится на первый. Я не очень понял
сейчас, но возможно это правда. Было сказано, что явные шаблонные аргументы концепта подставляются
во второй и так далее. Да, у тебя то, что идет после названия концепта, вот эта единственная штука,
это подставится в качестве первого. То есть Сеня сказал, что если мы напишем constant input-interaтор
в фигурных скобочках int, то u станет int, а не t. Ну да. Constant input-interaтор в угловых скобочках int?
Да, то int поедет в u, а не в t. А, ну да, возможно. Ну, наверное, да. Это логично, потому что у нас
же после этой штуки один только тип. Я не уверен на 100%, но возможно, что да. У нас же в концепте
может быть там 3-4 параметра. Так, а можно шаблонно принимать концепт? Что? Ну, чтобы шаблонным параметром был какой-то концепт.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Нет, нет, нет. Концепт.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Тимплейт, импут-интератор, итер.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Так вот же написано. Тимплейт, импут-интератор, итер.
Ты когда писал, там, стрейнт, импут-интератор.
Ты когда писал, там, стрейнт, импут-интератор.
Ты когда писал, там, стрейнт, импут-интератор.
Ты когда писал, там, стрейнт, импут-интератор.
Ты когда писал, там, стрейнт, импут-интератор.
Ты когда писал, там, стрейнт, импут-интератор.
Ты когда писал, там, стрейнт, импут-интератор.
Ты когда писал, там, стрейнт, импут-интератор.
Ты когда писал, там, стрейнт, импут-интератор.
Ты когда писал, там, стрейнт, импут-интератор.
Ты когда писал, там, стрейнт, импут-интератор.
Ты когда писал, там, стрейнт, импут-интератор.
Ты когда писал, там, стрейнт, импут-интератор.
Ты когда писал, там, стрейнт, импут-интератор.
Ты когда писал, там, стрейнт, импут-интератор.
Ты когда писал, там, стрейнт, импут-интератор.
Ты когда писал, там, стрейнт, импут-интератор.
Ты когда писал, там, стрейнт, импут-интератор.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Синтаксис такой, типа, синтаксис реквариментов.
Не знаю, можно ли, но может быть и можно.
Сейчас, а какой-нибудь написать enableif?t?
Нет, давай не будем смешивать концепты с enableif'ом, пожалуйста.
Концепты придуманы, чтобы не писать enableif.
Хорошо, а вот второй вопрос.
Requires вычисляет как в compile или в run?
Конечно!
Естественно, в compile-time какой смысл иначе.
А там была функция, которую...
Ну, к самой первой ты показывал, где Require не в концептах.
Да, и она просто отвалилась.
То есть Require, если я делаю не от шаблонного аргумента, то значит он просто падает.
Видимо, он не умеет не от шаблонного параметра вычисляться.
То есть там писать Requires 2 plus 3 равно 5, это типа бог?
Что Requires 2 plus 3?
Requires 2 plus 3 равно равно 5.
Нет, что значит синтаксически?
Requires...
Ааа, это кисатру.
Ладно, да.
После Requires ты должен написать экспрешены, которые будут проверены на корректность с точки зрения компиляции.
А не на истинность, как булевские выражения.
Окей, тогда писать статик ассет.
Их концепт равно 1 plus 2 равно равно 3.
Так можно.
Просто булевский подеказ.
Концепт чего-то там равно 1 plus 2 равно равно 3.
Я не уверен, что так можно, потому что я не уверен, что любой булевский экспрешен A компилируется.
Но дело в том, что после концепт можно писать не любое булевское выражение.
Там есть какие-то ограничения, но я не помню какие.
Ну да, ну компайл там вычиснимый, но кажется там еще какие-то есть дополнительные ограничения.
Ну да, можно написать...
Ну 1 plus 2 равно равно 3, наверное, можно, потому что это тривиально.
Я могу написать концепт trivial равно true, и это будет всегда истинный концепт.
Но соответственно, вот что такое compound requirements, я раньше сказал, что мы пропустим эту часть.
Теперь мы к ней вернемся.
Собственно, вот это и есть оно.
Я могу для данного экспрешена проверить, что это не просто корректный экспрешен или корректный тип.
А что этот экспрешен сам удовлетворяет некоторому концепту.
Вот std convertible2 это концепт тоже, например.
Что такое convertible2?
Это на самом деле std из convertible2, а также еще дополнительное требование, что requires, короче, что from еще static cast допускает.
Это корректность вот такого экспрешена, компилируемость вот такого экспрешена.
Вот.
Значит, на самом деле в библиотеке стандартных концептов есть много чего.
Например, вот есть концепт std same as.
Это как same, как is same, только с дополнительными.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
Это корректный экспрешен.
А это как раз чтобы самсьюминг работал.
Если бы мы просто написали sameS это isSameV от tu, то тогда
если бы кто-то сделал sameS и что-то еще, ну короче
мы хотим чтобы tu были симметричны, потому что с точки зрения
анализатора вот этого вот самсьюминга капцептов
isSameV tu и isSameV ut это абсолютно разные никак не связанные
друг с другом требования.
И чтобы концепт корректно умел обрабатывать более
частные требования по отношению к isSame, он их упоминает
оба isSameV tu и ut, чтобы когда мы сделаем более частный
концепт, он умел правильно понимать, что те требования
накрывают эти, что там больше требований, чем здесь.
Вот как-то так.
Наверное все.
Давайте перерыв сделаем на этом.
Я в общем...
Last but not least, последняя глава нашего замечательного
курса.
Compile time отчисления.
Это близко к тому, о чем мы только что говорили, но
все-таки это несколько другая тема.
Сейчас мы познакомимся с таким замечательным словом,
как constexpr.
Мы с ним уже чуть-чуть знакомы, но сейчас мы познакомимся
полноценно.
16.1, это constexpr, ну давайте скажу constexpr функции.
Давайте так назову, constantExpressions и constexpr функции.
Вот, ну с идеей constantExpressions на самом деле мы уже знакомы,
как понять...
Ну вот, допустим, у нас есть такой класс array, да?
И вот мы хотим завести array из int 5a равно 1, 2, 3, 4, 5.
Вот.
Могу ли я сказать int x равно 5?
Ну, очевидно, нет, потому что x это переменная, я не
могу переменную как шаблонный параметр использовать.
Да, ну ничего, недолго терпеть нам осталось.
Да.
До Мексика все время.
А если я напишу constant, то внезапно уже смогу.
Ну там есть некоторые костыли в стандарте на тему того,
что если у меня константа, которая инициализирована
сразу, то как будто бы я, в общем, могу.
Но понятно, что даже если x это constantint, то не всегда
я могу его использовать.
Кажется, пример мы тоже приводили.
То есть я могу что сделать?
Я могу сказать int x, ну я могу сказать int y, stdcint y, а потом
constant x равно y.
И, конечно же, это не скомпилируется.
Потому что хоть тип x и const, но в compile-time нельзя его
подставить.
Это вообще невозможно.
Водится понятие constant expression, значит constant expression
это такой expression, что его значение известно на этапе
компиляции.
Ну не то, что известно, а должно быть вычислено
на этапе компиляции.
И у нас, начиная с C++H11, есть такое замечательное слово
constexpr, которое говорит, что данная переменная должна
быть в момент компиляции, ее значение должно быть
вычислено.
Вот у меня есть, скажем, я могу сказать const int z равно
5, и это значит, что я объявил константу.
Но здесь вместо 5 я могу написать нечто, что не обязательно
на этапе компиляции будет известно, чему равно, и
тогда эту константу в качестве шаблонного параметра
вот сюда я не смогу подставить.
Но я могу сказать более сильную вещь, я могу сказать
constexpr int z равно 5, и вот constexpr при объявлении переменной
означает, что я обязываю компилятор вычислить вот
это вот, то, чем я проницилизировал в момент компиляции.
А если здесь написано выражение, которое в момент компиляции
компилятор не может вычислить или не должен вычислять
по каким-то причинам, то это будет CE.
Вот, например, здесь, если я напишу constexpr int x равно
y, это уже будет ошибкой компиляции не потому, что я стдр
и от этого завел, а просто потому, что y справа нельзя
в момент компиляции вычислить.
Вот, the value of y is not usable in a constant expression, ну в общем-то
понятно.
Правда ли, что если переменная constexpr, то она обязательно
влечет const.
Правильный ответ – да, значит constexpr обязательно влечет
const.
constexpr – это более строгое условие, чем const, constexpr означает,
что это не просто константная переменная, а еще и константа
времени компиляции.
То есть, вот, надо именно, что… правильно это понимать.
constexpr переменная – это значит, что это не просто константа,
а нечто большее, это константа времени компиляции, константа
вычисленная в момент компиляции и зашита в бинарник, прям
вот, вот, как бы, в секцию константа.
Вот что такое constexpr.
Теперь вопрос, ну, вот это constant expressions, да, теперь
вопрос, а могу ли я… а, ну, пока, вот так, вот я, например,
напишу, int y равно 5, и дальше constexpr int x равно y, так можно,
тоже нельзя, потому что y – это не constexpr.
Значит, y, несмотря на то, что казалось бы известно во
время компиляции, ну, нет, неизвестно.
yr – это локальная переменная, она неконстантная, и это
уж точно не константа времени компиляции.
А если написать constant y?
Вот, если написать constant y, то это будет работать по
причине, что для этого специально костыль какой-то заведен,
но, в общем… ну, в общем, там, кажется, есть в стандарте
костыль, что если вы пишете const int и справа прям конкретное
значение, то он считает, что это можно использовать
в константных выражениях.
Ну да, да, он как бы воспринимает это как constexpr.
Правила точно такие же, вот как понять выражение
constexpr или нет?
Задайте себе вопрос, можно ли мне вот здесь было написать
его?
Вот, правила, на самом деле, именно такие, вот, ну,
вот, в шаблонном параметре, представь, что вы делаете
std array от int запятая и вот это, это бы скомпилировалось?
Вот, можно себя так проверить, если у вас есть интуиция
на тему того, что можно делать шаблонными параметрами,
что нет, то это именно оно.
Можно ли это выражение поставить сюда как шаблонный
параметр?
Вот, в точности это и значит, что оно должно быть констант
и времени компиляции, constant expression.
А, можно ли вызов функции сделать, вот, например, у
меня есть функция, я не знаю, int f от int x, которая что-нибудь
делает, не знаю, return x умножить на x.
Давайте назовем ее sqr от x.
Вот, могу ли я здесь сказать, господи, sqr от пяти.
Вот, господин Барыкин правильно сказал, что надо, чтобы
можно было, надо специальное слово написать, пожалуйста.
То есть компилятор может это сделать, но если его
просто так-то не будет работать, потому что вызов функции
не считается constant expression, так, я не сохранил.
Значит, вызов функции не является constant expression,
потому что он, вообще говоря, может требовать там каких-то
там проходов по сте, ну, там каких-то, значит, прыжков
куда-то.
Но если написать constexpr int, короче, функции тоже можно
объявлять constexpr.
constexpr функцию можно завести.
И вот, если вы саму функцию объявили как constexpr, то тогда
результат ее вызова считается constant expression.
Чего?
Вот, такие дела.
Как это, в смысле, не обманули?
Ну, это правильный вопрос, на самом деле.
Значит, здесь открывается дверь в пропасть, вот примерно
об этом мы будем разговаривать в ближайший час.
Оказывается, что функции можно объявлять constexpr.
Возникает вопрос, а что в таких функциях можно делать,
если они constexpr?
То есть, когда я говорю, что функция constexpr, я тем
самым, как бы говорю компилятору, ты должен уметь это на
этапе компиляции вычислять.
Хорошо.
А могу ли я, скажем, ну вот, я сейчас какой-нибудь
пример напишу, там у меня есть там функция isPrime, пример
типа с прошлого года.
Могу ли я вот, например, проверить число на простоту
на этапе компиляции?
Мне здесь что надо сделать?
Ну давайте там я переберу делители, там for, int, int, ну
я тут не буду, значит, соблюдать хороший код style, там умножить
на i меньше, чем n, меньше равно n, плюс-плюс i, тут, наверное,
от двух надо, да, типа если, значит, если n делится
на i равно нулю, тогда return false, и return, значит, и что
надо return?
Ну как асинхрон?
Неравно 1, да, вот так, что именно вас повседлило,
я правду вообще написал, да, вот видите как, ну нет,
на самом деле нужно, потому что в таком случае, если,
а, ну нет, если n равно 1, то я просто цикл не буду
делать и все, да.
Вопрос, могу ли я вот это сделать constexpr?
Ну тут, смотрите, тут for есть, тут есть if, if constexpr, for constexpr,
да?
Нет, кажется, это можно делать спокойно, потому
что, ну, типа все компетент вычислимое.
А что некомпетентом вычислимое, когда, а где проходит граница
между тем, что компилятор может компетентом вычислить,
и не может?
Размышление, что здесь, да, он обращается только к
локальным переменам, короче, мысль, что здесь он обращается
только к локальным переменам, соответственно, зависеть
может только от, типа, входных параметров.
Вот могу ли я так сделать?
Ну, я здесь должен писать constexpr.
Да, тогда да.
Вы поверьте.
Я бы ставил как минимум на YouTube все компиляторы.
Как бы что ставил?
constexpr на YouTube.
Так, а как бы смысл ставить это в глубину, если ты
бы что-то от меня поставил?
Ну, это...
Вот, на самом деле, if constexpr и просто constexpr надо разделять,
это разные идеи на штуке.
Мы с вами if constexpr изучили раньше, чем просто constexpr,
хотя появился он позже, но это на самом деле совсем
другая история.
If constexpr это какая-то штука, которую вот в compile time надо
проверить, там, на шаблонах, например, что-то, и не компилировать
одну ветку, если это ложно, то есть if constexpr его смысл
в чем?
В том, что вы хотите одну из веток не компилировать,
если условие ложно.
Вот для чего нужен if constexpr.
Здесь if constexpr не уместен, у него задача другая.
Вот, поэтому тут if constexpr, это не об этом, и for, ну for constexpr
это тоже странно, нет, for constexpr такого нет.
На самом деле, правильный ответ, да, это можно вычислить
на этапе компиляции, но, только начиная c++14, значит,
следите за руками.
constexpr появился в c++11, а вот for и if в constexpr функциях
начиная с c++14.
То есть, получается, в 11-х плюсах просто это нельзя
было заставить?
Просто, да, нельзя, потому что слишком сложно, потому
что еще не реализовали, потому что компилятор пока
не умеет.
Значит, я давайте вам продемонстрирую, минус std равно c++, нет, циклы
тоже нельзя.
Смотрите, я вот скомпилировал в версии c++11, и смотрите,
что он мне сказал.
Body of constexpr function not a return statement.
Значит, c++11 было следующее требование, если функция
constexpr, то все из чего она может состоять, это просто
один return и только один expression в нем.
То есть, это должен быть return что-то, а там вы изгоняетесь,
как хотите, тернарники пишите там, вызовы других
constexpr функций, но if и for нельзя.
О, однострочники.
Да, только однострочники можно было делать в constexpr
c++11.
А если точку с запятой написать две строчки в одной, это
считается?
Но это же после второй строчки.
Только return 1, только один return можно написать.
Так, в продолжении будет после return statement, так что
как бы, ну, пиши, не пиши.
Блин.
Нет, я напишу c++, точка с запятой, return 1.
Слушай, меня, честно говоря, пугают твои вопросы, вот
уже меня они все больше пугают, у тебя какие-то вопросы,
вот, мне кажется, тебе надо вот фундамент какой-то
переделать.
Да, просто вот мы вот что-то изучаем, изучаем, а Миша
такой, а вот почему синтаксис ИФА такой?
А что если я два expression напишу в одну строчку, это будет
считаться однострочником?
Нет.
Типа, блин, мне кажется, у тебя проблемы с базовым
синтаксисом какие-то.
Мне кажется, что...
Не, у нас в прошлом году, я помню, где-то в марте или
в апреле в чате возникла дискуссия, а что такое переменная?
Вот это было прям хорошо.
На продве, да, там прям, там просто кто-то задал глубокий
вопрос, что-то про RvL и дальше задался вопросом, что такое
переменная.
Ну вот, а все плюсы 14 уже можно.
Ну ладно.
Нет, то есть можно было делать всякие тернарники?
Да, return и дальше expression.
Тернарники можно было бы это сэмулировать, да.
Можно было бы сделать вызов другой функции.
Вот, хорошо.
Можно ли рекурсию делать?
Ну в 14-х уже можно, в 11-х не помню.
Наверное, тоже можно.
Ну если она код Stexpr, наверное, можно.
Вот, и окей.
Ну хорошо.
Так, а что еще, например, я могу сделать?
Давайте вот что сделаем.
Ой.
Не знаю, вот смотрите, вот я сейчас напишу такое.
Ну, короче, вот.
Я, к сожалению...
Ну, я пока боюсь немножечко йоту вызывать, вдруг нельзя.
Вот, и давайте я скажу, значит, int result, ну или res равно нулю,
и от нуля до 20 res плюс равно isPrime от aitova.
Return res.
Вопрос, могу ли я массив завести?
Ну, он на стеке, наверное, да.
Стеком понятно?
Какой стеке?
Да, это хороший вопрос, на каком стеке?
Пусть это хранятся, пусть он там...
В каком бинарнике?
Бинарника нет, у нас процесс компиляции идет, никакой бинарник еще не создан.
Мы просто хотим посчитать, сколько простых среди первых 20 чисел.
Я такое говорю, constexpr, int.
В принципе, вы правы, да.
Но, но...
Ну да, да, даже C++14 можно.
В принципе, вы правы.
Ладно, тогда усложняем задачу.
Давайте скажем вот так.
Слушай, ну не смешно, ну хватит уже.
Ну все равно, вот могу ли...
Ну вот указатель я хочу завести в compile-time.
Это нормально?
С другой стороны, почему бы и нет?
Мы оставили, что нет.
Уже сделали шаг назад.
Это работа с памятью какая-то, да.
То есть обращаться к массиву можно.
Ну хорошо, ладно.
А указатель?
Следующий шаг это, видимо, введение локаторов.
Ну что, ваши ставки можно так или нельзя?
Кто считает, что нельзя?
Я считаю, что в 14 нельзя.
Чем вот это отличается просто от...
Ну хоть в каких-нибудь.
Нормально.
Даже в 14 можно.
Ну ладно.
Сейчас Илья, а может же нам надо попытаться выйти за конец массива?
Можно попробовать его начать от Nuptera.
Подожди.
Сейчас, не все так быстро.
Давайте...
Кстати, вот конкретно, если указать не 20, а, например, 40,
у меня статический анализатор подсвечивает.
Если в цикле 20 заменить на 40,
так, подожди, подожди.
Сейчас все по порядочку, все по порядочку.
Тихо, тихо, тихо.
Давайте, давайте, давайте, например...
Давайте, например...
Окей, указатели можно.
Ну, на самом деле, действительно, можно указатели.
То есть я, например, могу сказать,
int звездочка ptr равно address res.
Могу сказать.
Эм...
И, значит, вместо того, чтобы res писать,
я буду говорить, вот поэтому ptr я хочу инкриментировать.
Как он это эмулирует?
Как он это делает?
Тоже можно, все нормально.
Даже в C++14.
Сейчас, это какой еще раз сценарий?
Я просто pointer завел,
address переменной взял,
и по pointer теперь,
разыминовывая pointer, кладу туда значение.
Все в compile-time делается.
После предыдущего примера это не удивительно,
потому что на это лечили...
Да, ну, то есть он как-то эмулирует указатели в себе.
Ну, ладно.
Хорошо.
Что еще мы умеем?
ООП давайте мы пока пропустим.
New Delete.
New Delete мы пока тоже пропустим.
Ссылки.
Ну, очевидно, ссылки можно, я не буду...
Да, то есть понятно, что ссылки тоже можно.
Я могу завести int&persand, значит,
там, res2 равно res.
Ну, короче, ссылки тоже можно.
Что еще?
Давайте...
Какие мы еще знаем фичи языка?
Ну, мы, например, знаем такую фичу, как...
Views.
Бросание исключений.
Бросание исключений.
Вот.
Давайте какую-нибудь я придумаю...
Историю...
О, смотрите.
Допустим, меня спросили,
просто или число.
Вот я хочу, если n меньше или равно нуля,
то бросить...
Ну, я пока объекты боюсь создавать,
давайте я брошу ноль.
Ну, стекспор он, наверно, подразумевает
в новых сетах.
Вот, давайте я проверю,
что...
Ну, давайте я для начала проверю, что
3867 простое.
А как вы думаете, нормально вообще это
скомпилируется?
Куда он должен бросить исключения?
Тот же вопрос, что он должен кинуть исключения
в победе.
Так, подождите,
что-то мне не нравится, потому что это
не должно компилироваться вообще-то.
Мы с вами что-то не то делаем.
А может он просто понял, что...
Что статистический анализатор
понял, что это гибросайд,
поэтому просто заигрывали?
Не-не-не, подождите-подождите, у меня такое ощущение,
как будто...
Да, вот сейчас я уже удивлен,
потому что это не должно компилироваться.
Хорошо, давайте я C++11.
Да, в C++11
она отказывается компилировать.
А, но в C++11 даже
фор не компилирует.
Хорошо, а если я G++9
скомпилировать попытаюсь?
Тоже компилирует.
Он нас перегнал и уничтожил?
Как это вообще работает?
Он сначала просто компилирует,
потом делает compile time вычисления,
а потом уже гинает.
Нет, подожди, когда он компилирует, он делает
в том числе compile time вычисления.
Он бьет себя универсально.
Вызвайте от него одного.
Это очень странно,
потому что кажется,
он не должен это компилировать.
Ну, короче...
Может это просто правило
не запрещено так писать,
это типа УБ?
Нет, это не УБ.
Сейчас, короче, я вот так сделаю,
я просто на Godbolt
сейчас это залью
и там проверю с вами это.
Какие они?
Да-да-да-да-да.
Дальше?
Ммм...
Значит...
Так.
Поменьше сделаем.
Вам же видно, да?
Ааа...
Значит, со стд C++14
24 нет,
пока мы не дожили.
Да, все-таки компилируется.
Странно.
Ну ладно, значит компилируется.
Действительно.
Силенг тоже компилирует.
Ааа...
Ну, в общем, да, throw можно писать, короче,
в constexpr функциях.
На самом деле, по-моему, можно начинать
с C++17 было?
Но, видимо,
с C++14 можно.
Теперь вопрос, а если я вызовусь
от нуляс хотя бы?
Что будет?
Вот теперь ваша версия.
Как это не вызовется?
Нет, мы вот здесь вот
n меньше равно нуля
нас сделает throw 0.
Ну, в общем-то...
Это как доказывать,
что корень из двух степени корень из двух
рационален.
Не очень понятно, что будет,
но итог-то ясен.
Ошибка компиляции.
Что еще может случиться
на этапе компиляции, если что-то пошло не так?
Ну, наверное, ошибка компиляции.
Мы не очень понимаем,
умеет ли компилятор бросать исключения
в compile-time или не умеет.
Но в любом случае будет ошибка компиляции.
Потому что в compile-time должна
случиться ошибка.
Значит...
Так и будет.
Так и будет.
Throw expression из нота constant expression.
Ну, просто он
дошел до expression,
он дошел до throw в compile-time.
Короче, правило такое.
Throw в constexpr функциях писать можно,
при условии, что на него дело не доходит.
Если на него дело доходит, то это ошибка компиляции.
Короче, компиляция — это
интерпретация.
Очень похоже туда.
Похоже на Python.
Вот. Очень удобно.
Ну, на самом деле так и в современных
плюсах тоже.
То есть можно писать throw
в constexpr функциях, но просто если
на него дело дойдет, то это будет ошибка компиляции.
А, то есть это идея типа,
что мы можем написать throw
в constexpr функции, чтобы...
Чтобы, если это...
Компиляции ее вызывать, но там до throw не дойдет
и нормально, а потом ее использовать в runtime
в каком, условно, нормальном способу.
Типа, чтобы оттуда...
Да, это правда. Да, вот тут я вам,
кстати, не сказал важную вещь, но давайте скажу
сейчас, я хотел позже сказать.
constexpr не означает, что эту функцию
нельзя использовать в runtime.
То, что функция constexpr
не запрещает вам обычной переменной
с помощью инициализировать в runtime.
Вот.
constexpr — это значит,
что если вы эту функцию
использовали в
constexpr, то это корректно,
и он будет пытаться ее вычислить на этапе компиляции.
Но если вы ее используете
для инициализации обычной переменной в runtime,
он ничего плохого тоже не скажет.
А он будет использоваться в результат вычислений,
которые могли бы сегодня в runtime?
В runtime?
Нет. Думаю, нет.
Ну, нет, он будет, я думаю, заново вычислять.
Типа, сможет ли он
соптимизировать и увидеть
заранее, что это предвычислить можно?
Ну, для каких-то простых функций
для маленьких значений может быть и сможет.
Но в общем случае нет.
Вот, короче, show
вот так работает.
Вот, здесь мы приходим к ответу на вопрос,
а что же будет,
если я, например, вот так
напишу?
Я отложил этот вопрос
неспроста,
потому что на самом деле ответ на него тоже
такой же.
То есть, что если я
во время compile-time вычислений
выйду за границу массива?
Ну, вообще-то это
должно быть, если бы это было
в нормальном вычислении, то это было бы УБ.
Но мы в compile-time
находимся.
А в compile-time
это будет ошибкой компиляции,
потому что он поймет, что
мы вышли за границу массива.
В compile-time умеет включать указатели на массивы от...
Нет, в compile-time
он запомнил, что размер, массив у него
размера 20, и если мы обратились
к элементу за границей,
он это заметил во время компиляции.
И сказал нам
это ошибка компиляции.
Вот.
Если мы, короче, разыминовываем указатель...
Да, вот, например...
О, отличный, отличный, отличный вопрос.
Давайте, подождите, подождите, подождите.
Давайте-ка я вот что сделаю.
Как вам такое?
Я не перехожу за границу массива, я вот так делаю.
Взяли мы
адрес локальной переменной, увеличили его
на один, то есть следующую за ним, как бы, взяли.
И...
Нет, run-timer в компиляторе, конечно,
не будет.
Да нет.
Это...
Подожди, нет, out of bounds это предыдущее было.
Я взял,
в compile-time сделал
как бы уб. То есть я взял,
вот, обратите внимание, на это он не поругался.
Я взял адрес локальной переменной, увеличил на один.
То есть взял как бы следующую по стеку.
Ну, я
я сделал нормальную операцию,
сложил указатель с 4.
Да то же самое, это все уб.
Да, да, да, ну он перейдет к резлу.
Да.
Нет,
это уб, ну в смысле
нет, ну как, если это
уб, то он...
Типа он знает, что это уб, да?
Он знает, что это уб и будет давать ошибку.
Я не могу,
я не могу присваивать этому адресу,
потому что он уже все, он не указывает
ни на какое корректное место...
Он в compile-time умеет,
видите, ловить уб.
В смысле уб не в том, что
его не обрабатывается?
Ну не в compile-time же.
Не, ну кажется, что
типа в compile-time он тогда может им по полной
задачи нам пытаться решать. Почему?
Ну потому что... Нет, подожди,
нет, подожди, во-первых, им по полной задачи
нет никакой проблемы решать, просто они долго
решают. Ну да, ну в compile-time
и убы проверяют, и даже если убы
определить им по полной задачи, он тоже
может проверять. Ну он просто
долго компилироваться будет.
Нет, просто смотри.
Проблемы остановки он в compile-time не решит,
конечно, но это по полной задача
вполне.
Он будет просто 2 часа компилировать,
потому что он хочет все обгонять.
Не, не, в смысле, у нас же очень простая штука.
Почему мы в целом не ловим уб
в compile-time? Потому что это невозможно
типа... Почему мы
не ловим уб в runtime? Потому что это долго.
Ну да. Мы не обвешиваем себя
проверками, потому что
мы не хотим, чтобы был питон.
Мы хотим как бы рисковать.
Мы хотим жить рискованно.
Когда пишем на плюсах.
В compile-time мы не хотим жить рискованно,
а он убы отлавливает.
Другой пример. Еще один пример
сейчас вам покажу. Окей.
Давайте
я в этом цикле добавлю еще одну операцию.
Я вот что сделаю.
Ой.
Вот.
Я заведу некоторые int и буду его
умножать на миллион двадцать раз.
Что произойдет? Ну, конечно же,
переполнение int. И это тоже
ошибка компиляции.
Переполнение int в compile-time, и вот вам и ошибка компиляции.
Хорошо. Вопрос на что. Если мы возьмем
указатель, как бы на конец памяти,
которая будет доступна,
мы берем плюс один?
Вот именно не будем по нему ничего записывать,
но просто указатель.
Так ничего страшного. Я же только что там делал.
Инкремент указатель
это ничего страшного.
Теперь он указывает не куда-то, куда нельзя,
а просто туда, куда вообще не существует.
Подожди. А в чем разница
между существует или
то, куда нельзя? Вот когда я так написал.
Ну, вот когда я так написал,
это тоже как бы конец памяти,
которая нам доступна.
Короче,
просто компилятор отслеживает,
что все обращения к указателям корректны.
Если не корректны, то все, падение.
Вот, ну хорошо.
Ладно, окей.
На самом деле,
эта пара, это просто
Main, я думаю, нельзя.
На самом деле, сегодня
вот эта вот пара, это
такой, краткое
повторение всего того, что мы проходили
с переосмыслением.
Вот мы с вами
поговорили об указателях,
об UB при переполнении указателей, о ссылках,
о константах. Давайте поговорим
про OOP теперь.
Давайте заново
поизвучаем классы.
Вот, например, я могу
завести структуру.
Подожди, подожди, подожди, подожди.
Не торопись.
Вот у меня есть структура
с двумя полями.
Как насчет завести объект этой структуры?
Ну и что-нибудь поприсваивать ему, например.
Ну кажется, что
все еще все хорошо.
Чем это отличается от того, что мы завели int?
Совершенно ничем не отличается, ты прав, да.
Только у меня нет
икса, ну ничего страшного.
Да, да, пожалуйста.
Я могу
запросто...
Иппоинтера нет.
Какая жалость.
А ты звездочку
смотри и все.
Да, я могу
запросто создать объект
структуры в compile-time, но
только начиная с C++.
Смех.
Мне кажется,
C++ что-то вложает,
потому что в C++14, кажется,
нельзя было.
Нет, все равно.
Ну, может и в 14.
Ладно, не будем былое вспоминать.
В общем, можно и в 14.
Хорошо, а если у этой структуры не тривиальный
конструктор?
Конструктор, может ли
констэкспорт пометить?
Это отличный вопрос.
Если не пометчен, то, видимо, нет.
Все, совершенно верно.
Вот сейчас будет нельзя, потому что
вызов конструктора...
Ну, он, очевидно, может вызывать что угодно,
делать там сины, сеалты.
Да, вызов конструктора не констэкспорт.
Но если конструктор констэкспорт,
то почему бы и нет?
Ну, логично.
Шаблоны и так в Compile Timer делаются.
Вот, но у меня теперь нету...
В 14 угасится прикладение?
Нет, нет, нет. У него теперь нету...
Это обычная ошибка, и она была бы
и без констэкспорта.
Все нормально. Конструктор вызвался
в Compile Timer.
Вот.
Ну, потому что я
примеры просто разбираю.
Хорошо.
Ну, понятно, что...
Понятно, что дальше это
распространяется на все методы.
Я могу точно так же сделать конструктор копирования,
конструктор перемещения,
деструктор, оператор присваивания.
Если они все...
Вот до тех пор, пока все это констэкспорт,
оно запросто может отсюда
вызываться.
А в чем отличие от функции?
Вот.
Возможно, вы замечали,
когда...
Значит...
Да.
Заходили на... Заходили на
cpp-reference,
вы, возможно, замечали,
что
слово констэкспор, оно много где.
Это все потому,
что все это, на самом деле,
можно вызывать в констэкспор функциях.
Правда, начиная с C++20?
Вот.
Ну, все эти алгоритмы,
начиная с C++20,
написаны так, что они работают в констэкспоре.
И STD sort можно вызывать в констэкспоре.
Это логично.
Это логично, конечно.
Хорошо, что для вас уже логично.
Чем это нужно?
Если ты хочешь в compile-time
предвычислить что-то,
там, я не знаю,
какой-нибудь решетой ротосфена в compile-time написать,
и вот у тебя предвычисленные простые числа
до какого-то.
Мне бы это лучше сделать
в начале мейна.
Потому что они у тебя будут в бинарник зашиты,
и когда ты запустишь,
они уже готовы у тебя, предвычисленные.
Ты можешь захотеть вычислить
все простые числа до 1.e8
до запуска программы.
Например, пусть тебе надо упихать.
В смысле?
Это вряд ли будет
быстрее.
Это один раз при компиляции произойдет,
а дальше...
Ты вычисляешь это при компиляции,
и в a.out уже зашит ответ.
По-моему, это чуть ли не
эталон олимпиады с ПБГУ.
Насколько это дольше,
чем в runtime в среднем?
Что значит в среднем?
В смысле,
однократно вычислить?
В compile-time
вычисления
делаются дольше,
чем в runtime.
Во сколько раз,
я не знаю.
На олимпиаде с ПБГУ
дольше чем?
Я не знаю.
Я, к сожалению, не могу ответить.
Но runtime запускается многократно,
а compile-time однократно.
Ну-ка.
Вот.
Ну ладно.
А что все-таки насчет...
Еще обращение к конструкции
быстрее, чем обращение
к динамическому памяти.
Ты можешь просто ответить, чтобы это...
Насчет вот такого.
Ну, это же...
Это не может быть...
Это не может быть!
Я не верю!
Это невозможно!
Такого быть не может!
Это будет...
Какая динамическая память?
Он не выделяет динамическую!
Он тебя выделит в той,
на все он просто делает...
Теперь никто не гертирует, что ньюд
не выделит динамическую, блин!
Он знал.
А если я выделю...
Итак, ваши гипотезы.
Что же все-таки будет?
Я же прав, что ньюд не гарантирует, что он
в динамической памяти выделяет.
Я видел много, и это увидел.
То есть вот это вот...
Что делает дилит? Он бинарники чистит или что?
Он просто скажет, что это
освобождено, и по идее...
По идее он не должен просто ее выделить.
А вы можете дилит пока не вызывать?
Он будет часто вызывать
какой-нибудь констэкспер нью
и констэкспер дилит, нет?
Ну вот тут-то все-таки мне наконец-то
C++14 отказывает.
Не могу я
вызвать, извините, пожалуйста,
вось звездочки оператор нью
в квадратной скобочке.
Он не констэкспер.
А как же насчет
двадцатых плюсов, интересно.
Давайте посмотрим,
что представляет из себя
оператор нью в двадцатых плюсах.
Да, почему-то констэкспер здесь
не написано. Ну, ничего.
Можно.
Значит, вот теперь,
вот сейчас,
вот сейчас
вот сейчас начинается
я хочу увидеть настоящее
CompileTime вычисление.
Я сказал настоящее CompileTime вычисление.
Это только начиная C++20
можно. Значит,
начиная C++20
можно делать нью и дилит
в CompileTime
констэкспер.
Дилит, видимо, не делает ничего, кроме вызывать дистанктуру.
Не, ну как?
В смысле память то он не должен вычислять.
Что такое память?
Насколько я понимаю,
здесь ньюин 100 просто
на стеке
выделяет
под стоим то память.
Вот что если я закомментирую дилит в квадратной скобочке?
Как вы думаете?
А будет ошибка компиляции?
А потому что я не освободил?
Ну,
утечка памяти
она тоже в CompileTime
отлавливается.
Но это
УБ.
Смотрите,
как это прекрасно.
В CompileTime вы можете
пользоваться нью и дилитом,
и если вы дилит сделаете
случайно, лишний раз,
или забудете сделать,
или сделаете по неправильному адресу,
то это будет CE.
Компилятор в CompileTime отслеживает
корректность нью и дилит.
Вот если я сделаю дилит без квадратных скобочек,
то это тоже CE,
потому что должна быть диалокация массива,
а я сделал диалокацию просто НТА.
С наследованием все хорошо?
С каким наследованием?
Если мы будем пытаться все эти кулькологи
проворачивать.
Какие?
Виртуальные функции?
Не, подожди.
У меня есть ощущение, что
Компилятор написал космический корабль,
потом отрубил ему крылья,
заменил шасси...
Космический корабль тоже добавили
в C++20, я напоминаю.
Шасси на шины или на лыжи
и выкидывал на вход...
Космический корабль уже есть, вот он.
Мы его уже изучали в первом семесте.
Так что даже шутка про космический корабль
уже не актуальна. Короче,
в C++20 можно выделять
динамическую память,
но я ее облачил в Compile Timer.
А можно сейчас проверить одну штуку?
Если выделить там, типа, 10 в седьмой.
На стеке это очевидно
не выделится.
Она как мне должна выделиться?
Ну, это не 10 в седьмой немножко,
но ладно.
Ой, извините.
Да, давайте я не буду
лучше выделять.
Четыре гигабайта.
Да, четыре гигабайта я немножко
приемно.
Я не хочу еще раз переустанавливать.
Да, ну...
Делить квадратные скобочки.
Он дошел
до этого дилета, значит он скобок.
Можно еще вновь добавить?
Нет, ну,
короче, нет, ему ничего не мешает.
То есть, что...
Давайте подумаем, что
происходит, как это работает.
А представьте, что вы...
Давайте представим, что мы реализуем,
что нам так не повезло в жизни, что мы
реализуем, значит, фантазии Комитета
по стандартизации, и вот мы
реализуем компилятор C++20. Как бы мы
это сделали? Да очень просто.
Мы просто эмулируем в CompileTime.
Что, по сути, делает компилятор?
Он видит этот код, и он просто
эмулирует, пока компилирует, он берет
и делает все то, что он делал бы.
Ну, все те инструкции,
которые бы в Рантайме происходили,
просто компилятор запускает как бы программу.
Никаких проблем.
Но только дополнительно нужно
доделать, чтобы он проверял...
Ну, он обвешивает дополнительно проверками,
что УБ нету.
Но, по сути, ведь ничего нового, кроме...
Ну, что здесь новое принципиально?
То, что компилятор теперь еще умеет
проверять отсутствие УБ.
То есть, это реально динамическая
партия? Ну, это динамическая...
Ну, а что? Я говорю компилятору,
запроси, пожалуйста,
у операционной системы 100
мегабайт, допустим. Что он должен делать?
Он изначально, когда запустился сам компилятор,
у него же, наверно, не было 100 мегабайт,
но он говорит, ну, че, окей,
пока компилирую, мне 100 мегабайт понадобилось.
Он запрашивает, операционная система его выдает.
Ну, то есть, это реально
динамическая память. Если здесь
мало памяти, то может компилятор
как-то своей памятью обходится? Мы не знаем.
Но если это много памяти,
ну, окей, просто компилятор пока компилирует,
сам запрашивает динамическую память у операционной
она ему выдает, потом он ее отдаёт
обратно. Он просто, по сути,
не эмулирует. Он же умеет генерировать
инструкции под этим. Вот он их и выполняет.
На самом деле, очень стрёмный вопрос,
а многопоточка в CompileTime
возможно?
А что именно
ты понимаешь под многопоточкой?
Ну, мы же
из компилятора
в CompileTime считать какие-то очень сложные
задачи? Нет, что
именно ты поднимаешь под многопоточку? Запустить
другой трет в CompileTime?
То есть, бывают они, допустим,
что-нибудь из
header, который execution
вроде называется, и пытаться
какой-то распараллельный алгоритм просто навосить?
Ну да. Что-то вот такое.
Ну, я думаю, что
просто трет нельзя, потому что
у него конструктор не constexpr, вот и
всё.
Если вы про это. Ну, всё,
он не constexpr. Здравствуйте.
А execution, скорее всего, просто есть
constexpr-версия, которая делает
одного worker и всё.
Вот.
Ну, короче, потоки заводить нельзя в CompileTime-е.
Coroutine тоже нельзя,
но давайте не будем об этом.
Так написано,
вот есть страничка
в двадцатых плюсах появилась.
Тихо,
что?
Вопрос. Правда ли, что
механизм проверки на УВ
он такой же, как санитайзеры?
Что санитайзеры и проверка CompileTime?
Вот этого я не знаю.
Может быть, они написали свой,
может быть, они позаимствовали.
По логике, если компилятор
умеет отлавливать всё УВ,
то должны существовать
и аналогичные санитайзеры.
Что им жалко, что ли санитайзер
такой же сделать?
Ну, короче, вопрос хороший, я не знаю.
Можно погуглить, можно
настаковываться.
Вот.
Подождите, давайте дальше.
Это ещё не всё.
Почему-то все плюсы с 14 дают
вызывать NewDelete без проблем.
Ну, так не должно быть.
Все плюсы с 14 не должно быть.
Вот, окей, хорошо.
Мы научились делать NewDelete в CompileTime.
И это нам
открывает замечательные возможности.
Знаете какие? А это нам, например,
открывает такие прекрасные возможности, как
Как насчёт
Как насчёт
Господи.
Как насчёт
вот этого?
Вы никогда не замечали,
например,
вы никогда внимательно не изучали
страничку
конструкторы-векторы?
Вы замечали здесь
вот это, например?
Аааа!
Вы думали о том,
что это значит?
Здесь написано Sync C++20.
Совершенно верно.
NewDelete в C++20 уже можно
в CompileTime, так почему
Vector тогда нельзя?
Значит, String и Vector
можно заводить в CompileTime,
начиная с C++20.
Я могу вместо того,
чтобы писать вот это,
просто сказать
std Vector
от int v
ну там a от 100
и просто обращаться к элементам
Vector.
int i равно 0
i меньше
значит, чего?
100 plus plus i
значит
вот
я
запросто могу завести Vector
в CompileTime и обращаться
к его элементам. Правда,
Vector из ноты мембрового стадина.
Ну, бывает.
Возможно,
мой компилятор
этого не умеет делать,
потому что в прошлом году
еще не умел.
Давайте я
это проверю.
Короче,
поддержка CompileTime
Vector появилась далеко не сразу.
Давайте я это скопипащу
в, к сожалению, не помню,
как скопипастить
одной командой, поэтому я вот так
делаю. Давайте я продемонстрирую вам
в годбалте, что современный
так сказать C++
это позволяет
так сейчас
Мы с 14 плюсами
мы собираемся с 14 плюсами.
Сейчас.
Может, надо
аллокатить?
Так, PrimeScout.
Чего мы не можем сделать?
У нас какие-то, что-то у нас
конкретно неконстантное. Что именно?
Assignment to an object
outside
UnitedLifetime is not allowed
in a constant expression.
Это Trunk.
Ну, в смысле, это
последняя рабочая версия, это мастер-версия.
Сейчас. Я пытаюсь понять,
что именно я сделал не так.
Возможно, я
не должен этот конструктор вызывать.
Ну, работает.
На 12-м мы не должны работать.
Да, Илья сработало просто
аллокатер указатель.
А если не указатель?
Это точно.
Чего?
Ну, мы указали аллокатер.
Нет, это не так работает. 12 и плюсы просто работают.
C++ 2 поддерживает это C++ 11.
Ну, точнее,
видимо, не просто уже нет,
а в принципе нет.
Ну, собственно, полная поддержка 25 плюсов уже появилась только в 12-й весе.
Ну, в принципе,
на C++ 2 работает.
Сейчас, а у меня, а почему на...
А, Силенг, что ли, не работает?
Силенг, видимо, все еще не поддержал.
Хорошо, давайте GCC Trunk попросим.
Да, GCC работает прекрасно.
А с Trunk это кто?
Trunk, не с Trunk, а Trunk.
Trunk это ствол.
Ну, типа это мастер-ветка GCC,
мастер-ветка разработки GCC.
Почему GCC падает на сролл,
потому что мы в него не зашли.
Хороший вопрос.
А, мы в него зашли.
А вопрос...
Мы в него зашли, потому что я не заполнил
вектор значениями.
Вот, я должен заполнить
вектор значениями.
Ну, по идее, SD-Yota здесь тоже будет работать.
Да, только я не помню, к сожалению,
синтаксис SD-Yota.
SD-Yota...
Сейчас мне еще алгоритм надо подключать.
Нафиг.
For int i от 0 до 100.
У меня вот алгоритмами
примерно такие же.
a i t равно i плюс 1.
Нормально?
Все, отлично, компилируется.
Божественно.
Вот, пожалуйста, можно использовать
вектор в Compile Time.
Можно даже использовать
string в Compile Time.
Но если я обращусь здесь
к элементу вектора, который
выходит за границей,
то будет CE.
По причине...
Я вышел за границы...
вышел за границы
выделения динамической памяти.
То есть, смотрите, я в векторе
могу...
То, что раньше у меня было
у b, теперь у меня CE.
Если я обратился квадратными
скобочками за границы вектора.
Причем я могу
эту функцию параметризовать
и здесь вызываться там от какого-нибудь
int, и это будет
или не будет CE в зависимости от того,
от чего я вызвался.
Как из throw.
Вот, отлично.
Ну и давайте напоследок,
так сказать, на десерт,
разговаривая о возможностях
constexpr функций.
Давайте поговорим о такой
замечательной вещи.
Вот мы с вами изучали еще одну прекрасную
возможность языка C++ в первом
семестре. Вот ты о ней говорил.
Да, надо быть смелее.
Что бы мы хотели уметь делать в компайл тайме?
Ну, динамическую память
мы на следование, а конкретнее?
Виртуальные функции.
Виртуальные функции.
Типа RTTI как работает?
Как насчет
попробовать в компайл тайме вызвать какую-нибудь виртуальную
функцию?
А в чем проблема?
И здесь вообще не видно проблемы.
Не видно проблемы, действительно. Какая проблема?
В компайл тайме таблицу виртуальных функций завести.
Совершенно естественное желание.
Динамика сделать в компайл тайме
очень логична.
Виртуальных функций
не в компайл тайме все равно считается.
Когда у нас уже есть компилирование.
Это очень хорошо, что для вас
это не выглядит проблемой, потому что
действительно можно делать в компайл тайме.
Смотрите.
Потому что у нас там указатели на именно те программы,
поэтому
когда у нас собрана игра, у нас все это уже
просчитано.
Смотрите, давайте я заведу
действительно функцию
virtual voidf
и она будет
virtual int
virtual int
и она будет возвращать 1.
А здесь я заведу
int f override
которая будет возвращать 2.
И давайте я заведу такую замечательную
constexpr функцию.
Мы методы не хотим сделать?
Это, кстати, хороший вопрос.
Да, давайте я constexpr напишу.
Ну он по умолчанию же constexpr.
Илья.
Миша подсказал
одно волшебное слово, которое работает
во всех компайл тайм вычислениях.
Дивертуализация.
Там же известный какой класс в какой момент дергается,
поэтому в целом даже таблице виртуальных функций
Подождите, кто вам это сказал?
Сейчас, давайте все-таки
constexpr
constexpr
constexpr
void
test-virtual
Вот, и допустим
я здесь буду делать
от x.
Вот, если x
больше 0
то
ну я что сделаю?
Я сейчас заведу derived
но я заведу объект наследника
да
и объект
родителя, как у меня
вводится для полноценного примера
с виртуальностью. И давайте я скажу
basempercent
ref равно
в зависимости от того, x больше 0
он ссылается либо на
родителя, либо на наследника
в обратном порядке
либо на наследника, либо на родителя
вот, и вот если
ref
точка f
возвращает
один, то
бросьте исключения
Отличная
тема. Давай теперь
попробуем
вот здесь вот затестить виртуальность
test-virtual
от
одного
тест-virtual от одного
да, ну мы уже поняли, что
вектор ты не умеешь
ну, бог с тобой
давай мы тебя закомментируем
простые числа мы считать
больше не хотим, мы хотим
тест-virtual делать
компили, а, ну все
запускать можно не запускать
так, это компилируется, давайте
поймем, что происходит, x больше 0
я передал x больше 0
значит ссылка привязалась
к derived
derived возвращает два
не один, значит ноль не кидается
окей, давайте test-virtual
от минус одного
так, вот это уже интересно
господи, что я делаю
меня сила не удает terminate
code after throwing an instance
of int
ну это и должно произойти, в смысле terminate cold
terminate cold
в compile-time
так в run-time должно быть
а, господи
ну конечно, что я делаю
я же test-virtual вызываю не в
constant-контексте, я же должен
ее использовать для инициализации
какой-то constant-export переменной
ну сейчас я и верну int какой-нибудь
она не из compile-time контекста вызывает
ну да, она не запускается
в compile-time
в compile-time она будет запускаться
только если я ее вынудил запуститься в compile-time
путем того, что подставил ее в compile-time
контекст
да, спасибо
на самом деле ты подсказал, потому что
в run-time она бы упала, а не в compile-time
давайте еще раз потестим
то есть вот, я пытаюсь
инициализировать constant-export int через результат
тест-virtual, тем самым заставляя ее
запуститься в compile-time
и это сейчас не должно упасть, потому что
класс
ладно
уберем это
ну нормально
а теперь я от минус одного вызовусь
и
все
значит, в compile-time
он симулировал таблицу виртуальных функций
и действительно, если мы
попали в версию
наследника, то мы
вернули
два, а если попали в версию родителя, то
вернули один
почему он не может просто всегда
девиртуализацию делать?
может и может
девиртуализация
это такая штука
я думаю механизмы другие
я думаю, что это отдельные немножко
проекты
просто здесь же он буквально
девиртуализация решает другую задачу
девиртуализация пытается оптимизировать
некоторые конкретные ситуации
с конкретными очень строгими
ограничениями, а здесь я
канонический пример чистого
полиморфизма вызвал
я думаю, что просто проще
симулировать заново таблицу виртуальных
функций в compile-time, чем написать
чем приспособить девиртуализацию
под вот этот сценарий
ну я не знаю
в любом случае, я не знаю, мне кажется, что
компилятору просто проще
если бы я был разработчиком компилятора
ну я не знаю, как бы я делался
в зависимости от того, что уже для девиртуализации написано
но
как нормально вызвать void-концепцию в функцию
чтобы
никуда и не присваивать
а что ты хочешь добиться
void-концепции?
ну например, проверить
ты потом родишь всю память, которую
сделаешь
в контексте void-концепции
да, я не очень понимаю
для чего в constexpr вызывать void-функцию
она ничего не возвращает
то есть ты заставляешь компилятор что-то посчитать
и все
и ничего не вернуть
тогда ты для
инициализации этого глобального
а, в смысле, ты хоть
ну чтобы вместо вот этих
кастарей стафферов, ее можно сделать
в блог, засунуть в статик и все
подожди, а вдруг это какая-то
third-party-функция
у тебя нет доступа к ее коду?
ладно, давайте
дальше я все-таки расскажу
я почти
был прав, я сказал, что мы сейчас будем
обсуждать, что можно еще нельзя делать в constexpr функцию
но мы почти
закончили обсуждение, осталось только
вот это
да
а вот src, алгоритмский src
это же функция, которая возвращает void
но она constexpr
а как ее вызвать?
в какую-то функцию делаешь
а, ну если ты в constexpr функции
пишешь sort
то вот тебе и
если ты
ну тогда это не будет в compile-time вызывать
ну я же вот
ну слушай, ну я же вот здесь вот
если я нахожусь
если я нахожусь в вычислении
constexpr функции
и вызываю какую-то другую функцию, хоть void
то она
но это я понимаю
ну как, вот здесь вот я мог бы сделать sort
например, если бы я count-prime
сделал во момент компиляции, то sort тоже
должна быть constexpr
если у меня в мэйне constexpr-вектор
я хочу его отсортировать
в compile-time
если у тебя в мэйне constexpr-вектор
ты не можешь его отсортировать
потому что constexpr
привлекает константность самого объекта
если ты уже создал constexpr
я говорил, что constexpr
привлечет const, ты не можешь сортировать
константный вектор
я могу использовать его внутри
constexpr функции
ты можешь создавать там неконстантный вектор
и его сортировать
а если я лямду какую-нибудь
ссссссссссссссссссссссссссссссссссссссссс
это можно
ну сейчас покажу, подождите
так вот
виртуальная функция в compile-time
ну короче, увидели мы этот пример
у меня теперь вот какой вопрос
что если бы я здесь
c++
gcc не поддерживает
вектор, да?
ну 12 поддерживает
как мы поняли
у меня написано
c++ 2b
2b это 23
нет, gcc
просто не дорелизовал
не знаю, покажи потом свой пример
так, смотрите
я поступил
следующим образом, у меня была constexpr
virtualint
а вот эта версия
не constexpr
видимо разные симнатуры
вопрос
нет, симнатуры одинаковые
constexpr не является частью симнатуры
вопрос
можно ли override-ить constexpr функцию
не constexpr функции ей
или наоборот
ну как минимум не константность отличается
ну нет
не отличается
стоп
то что функция constexpr
не накладывает на функцию ограничение
константности
констэкспр функция
это свойство функции
оно никак не связано с типами
принимаемыми или возвращаемыми
еще раз
констэкспр это почти то же самое что и конст
это же часть симнатуры
нет
констэкспр функция это свойство функции
константный
она может менять объект
и не соревноваться
короче
мы еще глобальные перемены не рассмотрели
сейчас рассмотрим
по идее должно быть можно убирать
значит смотрите как это работает
вот я вызвался
от отрицательного числа
и получилось
throw
вот
он мне ничего не сказал
что вот это не констэкспр
но если
я вызвался от положительного числа
то он уже на этот раз
выдал ошибку компиляции
по причине вызов не констэкспр
функции
что произошло
а он просто сначала
вычислил разрешил
динамический полиморфизм
то есть
что происходит он решает
какую версию функций ему реально надо вызвать
он выбирает
перегрузку но не просто выбирает перегрузку
он еще и проверяет таблицу виртуальных функций
ну как бы псевдо таблицы
я не знаю что он там хранит в compile time
то есть он сначала решает какую версию
ему нужно выбрать
а потом пытается вызвать и тут
обнаружена не констэкспр
вот это как раз супер вонично
ну в плане она там же ведет себя
и с ambitious
и с квалификаторами доступа
ну да
то есть я могу
оверрайдить
констэкспр функции
не констэкспр функциями и наоборот
вот этот вот констэкспр
он влияет только на то
что если реально в compile time ему понадобится
ее вызвать это будет ошибка компиляции или нет
на выбор версии
это никак не влияет
и на runtime поведение это никак не влияет
это влияет только на то что если ему реально
надо будет в compile time ее вызвать он просто упадет
ну и dynamic cast
ну конечно же dynamic cast тоже
можно делать в compile time
в первом семестре за такой ответ
конечно вы получили
что то плохое но
теперь можно значит
dynamic cast тоже можно делать в compile time
вот
ээээ
значит
надо просто
вот я просто скажу dynamic cast
к derived
ampersand
от ref
точка f
ну и давайте верну это
ну да там же int
вернется вот
то есть смотрите
я сейчас передаю в эту функцию
единицу
и у меня
под ref лежит
derived
то есть теперь я должен
ну вот этот dynamic cast должен корректно отработать
правда я упаду потому что не
констэкспр
вот
чего
да
а попробуй кстати
поменять местами констэкспр
и не констэкспр в классах
посмотреть просто что он реально вот сейчас работает даже в такой ситуации
пожалуйста давайте значит
здесь я убираю констэкспр
а тут я
пишу констэкспр
вот работает
сейчас
то есть ему пофиг что бэйза не констэкспр
почему уб это
почему уб нет никого уб
я ему пофиг что
убэйза не констэкспр
а убэйза не констэкспр да
чего
какой
ну давай верну
как было
ну вот у меня есть вот этот ref
под ним может быть либо derived либо
based смотря от чего я вызвался
ну вот я делаю
dynamic cast derived
он либо корректен либо некорректен
в зависимости от того чего я вызвался
ну как бы
в нормальной ситуации
это было бы либо
исключение либо все хорошо
значит если я вызвался
от отрицательного числа то это
должен быть exception bad cast
почему это было бы
исключение
чего потому что
dynamic cast так работает
к ссылке это exception если там
based на самом деле
да от родителя к наследнику
вот если я вызвался от
положительного вот сейчас
если я вызовусь от отрицательного числа
у меня будет
ce
со словами
некорректный dynamic cast
то есть dynamic cast зафейлился
в compile time потому что я попытался
скастить к базу
а там был
то что не являлось
derived в run time это было
исключение но поскольку мы делаем все в
compile time это ce
вот а если я вызвываюсь от
положительного числа
то
ce уже другая
dynamic cast корректно отработал
но мы
попали в версию f которая не
constexpr и мы пытаемся
вызвать неконстекспру версию f поэтому
ce
нормально
хорошо
нравится вам
ну вот
ну давайте
напоследок
я вам покажу
страничку на cp-референс про
constant expression
и вы пронаблюдаете
полный список вместе с его
эволюцией
что считается constant expression
что такое
constant expression
значит constant expression это
gl value
core constant
expression что такое core constant expression
это отдельный пункт
которое ссылается на объект
ну в общем
тут перечислено на
так не получится понять конечно надо
как то по другому
давайте прочитаем что такое core constant expression
есть понятие core constant expression
это такой expression
чье вычисление
не приведет к вычислению
чего угодно из ниже перечисленного
в общем длинный список
а у нас еще одно занятие будет
да да в следующий раз мы продолжим
в следующий раз я вам как раз про
type list расскажу
вот ну в следующий раз
мы компенсируем то что должно было быть
в этот раз
ну в общем это
то что не является
constant expression
вот тут вот перечислено
что не является constant expression
вот кажется
vis нельзя использовать constant expression
значит
нельзя
объявлять статические
или trade local
переменные
нельзя делать
function call или
конструктор который
не constexpr
нельзя вызывать constexpr
функцию которая объявлена на нее
определена
ну вот не поддержали
нельзя
вызывать constexpr virtual
функцию которая
вызывается над
объектом
not usable in constant expressions
и время жизни началось
вне этого выражения
нельзя вычитать выражение
которое превзойдет implementation defined limits
нельзя вычитать выражение
чье вычтение приведет к любому виду
core language and defined behavior
включая
переполнение целочисленного int
деление на ноль
pointer arithmetic and sideware and bounce
короче вот этот пункт вот по нему
вот согласно этому пункту
вычтения всего того было compile time
что?
убейтаце
ну да здесь написано вот то что по сути убейтаце
а лямбда expression
до 7++17
внимание вот это очень важный пункт
начиная с 7++17 лямбды можно
в constexpr делать
просто лямда если сама лямда
по себе ничего вот не нарушает
того что перечислено в этом списке
то лямду тоже можно создавать
и вызывать в constexpr
как перт работает если здесь нельзя вызывать
я думаю что
не не тут написано
видимо вот этот пункт как раз
те ограничения позволяет обойти
неявная конверсия lvl
ukrvl короче список
из 35
пяти пунктов
что нельзя делать в constexpr выражениях
нельзя делать
вот смотрите нельзя делать throw
нельзя делать assembler вставку
нельзя делать
var
это вот помните в C у нас были функции
с переменным количеством аргументов в стиле C
вот их нельзя
нельзя делать go to
нельзя делать dynamic cast или typeid
который бы бросил исключение
и нельзя в лямда expression
ссылаться на vis который
был определен за пределами этой лямды
если эта ссылка будет
odruse
вот смотрите как этот список
поредел в c++20
смотрите typeid
нельзя было
делать do c++20
new expression
delete expression
ну вот new expression
вообще нельзя было
до c++20
а начиная c++20
дописка такая
oracle
std-allocator allocate
если только эта
allocation
это replaceable global allocation
function and allocated storage
короче можно при условии
что это все диалацируется
в той же самой функции внутри вычтения
внутри вычтения того же выражения
а в той же функции
isDialocated
within the evaluation of this expression
не знаю что это значит
ну короче так написано
что это должно проходить
вот
начиная с c++20 нельзя корутины
его ap-yield
вы и так не знаете что это
поэтому не думайте об этом
c++20 добавилось и constexpr
не сделали
до 714 нельзя было делать
присваивания
ну в общем вот
ну а дальше объяснять что такое
constant expression
ну тут есть еще какие-то
технические штуки
converted constant expression, constant subexpression
manifestly constant evaluated expressions
я не хочу выяснять
что это такое
вы поняли что почти все можно
в делать в constexpr начиная с c++20
а вот
с корутиными это типа
просто потому что это решили не поддерживать
потому что это непонятно зачем нужно
я думаю что
корутины дай бог
чтобы и без constexpr
нормально работали пока что
то есть ты как бы ты только добавил
огромную фичу в язык тебе бы ее
сначала саму отдебажить чтобы она нормально
работала там относительно них
я думаю что это куча дискуссий
как там что должно быть
а ты хочешь их еще в constexpr разрешить
потому что их только добавили и пока что
я думаю да
я думаю по той же причине почему
и например нельзя
freeway comparison
почему spaceship
оператор нельзя
потому что она только в языке появилась
не работает пока не трогает
не работает пока не трогает
не работает пока не заработает
когда заработает все равно не трогает
возможно в c++
40 каком нибудь мы увидим все это
тоже в constexpr
судя по тенденции
вполне допускаю что и трэды
и корутины будут в constexpr
в общем следите за
новостями что называется
на сегодня все
