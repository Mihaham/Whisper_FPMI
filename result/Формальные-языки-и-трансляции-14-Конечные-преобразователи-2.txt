Так, всем доброго дня, мы с вами продолжаем проходить наш курс, и сегодня у нас предпоследняя лекция.
Она связана с тем, что мы с вами будем проходить такое понятие, как конечные преобразования Я,
и конечные преобразователи у нас будет вторая часть нашей концепции, связанных с вот этим вот фактом.
На самом деле, уже начали это изучать. Давайте, как обычно, вспомним, а что мы с вами уже прошли на прошлой лекции.
Как говорится, что было в предыдущих сериях.
Да, у нас были копатели.
Французская фамилия.
Значит, у нас были конечные преобразователи.
Раз, мы ввели, что такое конечное преобразование.
Кто может напомнить?
Да, у нас есть автомат, в котором у нас на переходе мы читаем совхода слова А, а пишем на выход букву Б.
И мы с вами, как на лекциях, так и на семинарах, уже понимаем, что вот эта вот конструкция, когда мы читаем какое-то слово совхода
и пишем какое-то слово на выход, по факту задает нам базовую морфологию слов русского языка.
То есть, мы можем склонять, мы можем выделять приставки, корни, суффиксы, услов при помощи таких вот конструкций.
И мы с вами в прошлый раз еще доказали основную теря мнева, которая говорит о том, что у нас всякое конечное преобразование,
то есть, преобразование, которое по некоторому автомату из входного языка строит выходной язык,
мы поняли, что его можно разложить в виде композиции трех преобразований.
Пи в минус 1, композиция айдино-регулярный язык, композиция пси.
Ой, так, это.
И мы с вами в прошлый раз очень детально и потошно пытались понять конструкцию, почему это работает.
Напоминаю, что вот это у нас не удвиняющая гомоморфизма, а это ограничение на регулярный язык.
И мы с вами провели некоторую аналогию с курсом линейного алгебра
и поняли, что это некоторый аналог сигулярного разложения матриц,
где мы с вами видим, что любое линейное преобразование можно разложить в композицию
двух ортогональных плюс сжатия и растяжения.
То есть это, что мы с вами в прошлый раз поняли.
Да, то есть здесь факт этот очень простой.
Но давайте поймем, зачем нам эта теорема будет нужна.
На самом деле, эта теорема нужна будет нам сегодня для того, чтобы доказать,
что образ регулярного это регулярный и образ КС языка, контекст свободного языка,
это тоже контекст свободного языка.
Это одна из наших целей на сегодня.
Вторая цель на сегодня это доказать, что конечное преобразование замкнутое относительно композиции.
Давайте поймем, зачем нам нужно уметь, образно говоря, делать вот такую вещь.
Если у нас есть какое-нибудь преобразование фи, гамма со звездой и фи со звездой,
то композиция получается так.
Фи и фи, которая бьет гамма со звездой, фи со звездой, тоже будет являться конечным преобразованием.
Давайте поймем, почему нам это важно.
Во-первых, это процесс разложения, мы явно им пользовались.
А еще давайте какой-нибудь практический пример.
Это аналог операции Pipe.
То есть когда у нас есть, допустим, печатаем какой-нибудь файл,
а дальше перенаправляем этот поток на какой-нибудь вывод.
Тут о кого-то возникли флешбеки из курса параллельных распределенных вычислений.
Это те, кто на втором курсе поймут, когда придут на третий курс.
То есть мы можем взять какой-то вход и перезаписать его на какой-то вывод.
То есть выход одной программы используется как вход в другой программу.
Мне тут на вечер рассказали, что кому-то обещали сегодня на лекции рассказать,
как делать вот такую вещь при помощи конечных преобразований.
Как число на три умножать?
Да, это 2х плюс х.
Единственное, как ни странно, если мы это делаем все в двоичной записи,
то у нас идет запись вот такая.
То есть у нас получается есть нолики, вход у нас справа налево,
и нам нужно данные считывать в порядке, давайте в таком.
Когда у нас умножение на 3, кажется, нам не дается два числа, а дается одно число.
Да, дается одно число.
Поэтому нам нужно сделать следующее.
Во-первых, сделать конечное преобразование, которое из х делает пару х, 2х в таком порядке,
чтобы можно было их записать.
А потом мы можем использовать конечное преобразование для сложения.
И как раз для этого нам нужна композиция.
Ну, например.
Или когда мы говорили, что мы берем к числу что-то прибавляем,
мы говорили, что нам нужно добавить значащие нули.
И мы сказали, что нам нужно конечное преобразование,
по факту это дело, то дальше мы применяем композицию.
То есть этот факт позволяет закрыть большое количество маленьких-маленьких пунктов, которые есть.
Значит, мы сегодня будем доказывать вот этот факт.
Сначала я сразу скажу, что это технически математически не сложная идея,
но практически это будет как раз внутреннее написание выводов.
Итак, давайте докажем сегодня теорему первую.
Давайте я буду сосылаться на презентацию, чтобы немножко переодозначил.
Слушайте, у нас есть два конечных преобразования.
Значит, конечное преобразование.
Тогда конечное преобразование.
В чем самая главная сложность доказательства этого факта?
Самая главная сложность это как сделать факт, чтобы промежуточный язык,
который мы пишем на выходе, не попал в сумасшедший язык.
Мы с вами понимаем следующий факт, что на ребре,
так давайте я пока идею оформлю, что на ребре, которую у нас есть,
мы можем либо считывать ровно одну букву, либо писать ровно одну букву.
Помните, мы в прошлый раз доказывали этот факт.
И давайте как раз для этого нарисуем простую картинку.
Вот смотрите, вот у нас, допустим, автомат 1, вот кое-что прообразует 2.
Значит, у нас может быть два варианта.
Первым, читаем букву, пишем, не пишем ничего.
Второй вариант, читаем ничего, пишем букву.
Здесь есть такие же варианты.
Получается, читаем букву, не пишем ничего.
И не читаем ничего, пишем букву.
Вот смотрите, какие варианты нам помнят правила.
Левый, верхний, правый, нижний.
Да, левый, верхний, правый, нижний.
А что сделать вот с вот этим вот?
Важный вопрос.
Да?
У нас точно не фидбак у 35?
Ой, да, конечно.
Вот так.
Понятно, композиция так действует.
Так, смотрите, а что мы будем делать с этой конструкцией?
Мы по факту можем прочитать какую-то букву и написать что-то прочитать, написать букву.
Здесь тоже мы можем что-то прочитать, здесь написать букву.
Давайте мы обозначим, вот сейчас главное, чтобы у нас все с определением было, все хорошо.
У вас что-то одинаковое.
Это нормально.
Они нужны для того, чтобы буквы совпадали.
Вот так.
Ага.
Да, все.
Значит, смотрите, пусть это у нас Q1, вот это Q2, вот это по 1, по 2.
Это наше состояние в автомате.
Но тогда давайте сделаем хитрую вещь.
Давайте мы сделаем переход.
Который не читает ничего и не пишет ничего.
Но, конечно же, при определенном условии.
Да, у нас база стала сложнее тогда.
Ну, это да.
Да, это будет у нас работать в условии том, что у нас есть переход Q1,
это будет Q2a,
Q1a,
Q2a.
То есть у нас есть 20 переходов.
Если у нас есть такие переходы, то мы с вами их будем схлопывать в одно.
Вот.
Это как раз возможность из-за того, что у нас на ребре может быть одна буква на входе,
одна буква либо одна буква на выходе.
Так.
Давайте попробуем еще сформулировать переходы, которые нам нужны.
Значит, как описать вот этот случай?
Ну, когда мы букву с аккодов читаем.
Вот этот случай, это когда мы на выход из первого преобразователя что-то пишем.
Мы его должны схлопнуть с аккодами из второго преобразователя.
Посмотрите, здесь мы можем написать следующее.
Пара Q1t,
Q2a,
Q2t,
S.
А также преобразовывая.
Так, наоборот.
То мы читаем букву и пишем S.
Ну и третий переход.
Давайте по аналогии напишем.
Qp1,
Qp2,
Qp2,
и на выхода.
Вот такие у нас переходы будут в нашем автомате.
То есть идея еще раз.
То, что есть со входа, мы читаем.
То, что пишем на выход, мы пишем.
А промежуток схлапываем.
Да.
Ну не только.
Опять же, как мы строили ограничение на регулярный язык?
Нам нужно было одновременное движение по двум автоматам.
Есть нам нужно одновременное движение по двум преобразователю.
То есть и по ходу, и по выходу.
Если мы с первого что-то читаем,
то мы должны прочитать перегиб в этом преобразователе,
в другом остаться на месте.
Ну и на выходе мы должны делать то же самое.
Да, вроде не надо.
А если у нас вытекается гамма?
Да, вообще не сломаемся.
У нас одна из этих все вытопили в обычном образе.
Ну да.
Не, мы никак не сломаемся.
Просто это.
Здесь мы один.
Здесь у нас сигма со звездой.
Здесь гамма со звездой.
Здесь гамма со звездой.
Кажется никаких проблем нет.
Образ говоря, из русского в немецкий, из немецкого в английский.
Наша цель сделать перевод с русского в английский.
Так, вот они переходы здесь.
Да.
В общем, это просто запись перехода.
Теперь смотрите, как обычно.
Значит, мы с вами доказали, точнее подкроли конструкцию.
Нам осталось определить может завершающий состояние,
и может в стартовых состояниях.
Вот, собственно, если мы подкроем наш конечный образователь,
то это пара, понятно, будет.
Это как-то вот QEP.
Вот QEP состояние в нашем автомате.
Дальше у нас получается сигма штрих.
Это первая алкоголь.
Выходной будет QEP.
Дальше множество переходов.
Это QEP.
Значит, старт это будет пара Q0, Q0.
И завершающий это будет множество пар QEP,
где Q принадлежит множеству завершающих.
И P принадлежит множеству завершающих.
Ну, я...
Чего не кажется сигмой?
А?
Чего не кажется сигмой?
Ой, потому что это да, это алкоголь.
Вот, какой нам вариант надо доказать?
Вот здесь.
Опять же.
Ровно то же самое повторяем.
Значит, идея такая, что если мы из нашего общего преобразователя
читаем слово U и пишем на выход слово V,
тогда существуют промежуточные слова,
через которые мы это все сделали.
Вот.
И вот этот вариант мы как раз с вами будем доказывать.
Давайте я его тоже запишу.
Где тряпка?
Оригинально.
Так, пока я стираю с доски,
скажите, пожалуйста, в какую сторону факт
доказывается чисто технически?
Слева направо или справа налево?
Слева направо.
Вот это в обе.
Ну, нет, на самом деле здесь и...
Ну, если слева направо,
если у нас выполнено вот это условие,
что у нас в композиционном преобразователе есть переход,
то существует промежуточное слово.
Наверное, слева направо технически.
Слева направо технически.
Мы просто сделаем индукцию по длине,
по числу шагов вывода в нашем преобразователе.
Вот.
Просто мы это уже так много раз сделали.
Я все это делал вчера.
Вы когда-то спрашивали,
в какую сторону перехваты фигов подвигаются?
Не.
И дальше гадаете,
о том, как в таком порядке пространится.
Ну, как бы...
Так, что у нас получается?
Из Q1,
у
Q2z,
значит, из P1z выводится P2v.
Ой, P2v.
Ну, давайте скажу так.
Значит, вот здесь вот у нас просто индукция по числу шагов.
Давайте вот это обозначим m.
Вот это будет mq,
а вот это mp.
А?
А, точно, да.
Эпсилон,
эпсилон,
эпсилон,
эпсилон.
Вот так.
Индукция по числу шагов.
Так, а что, запись закосновилась?
А?
А, интернет, что ли, падал?
Окей.
А, ну там на два файла это разобьет все.
Ну, бывает.
При конвертации.
Хорошо.
Тут, как бы, смотрим.
Да, еще раз, проговорю идею.
Смотрим, как получился каждый из переходов и восстанавливаем результат.
Вот.
Если время останется, мы это посмотрим.
Просто мы это уже делали очень много раз.
Поэтому давайте мы будем двигаться в другую сторону.
Напишу техника.
В другую сторону это что, если выводилось в...
Одновременно в двух преобразователях, то у нас есть вывод здесь.
В левой части.
Тут надо будет рассмотреть три варианта.
Собственно, как ни странно.
Вариант номер раз, вариант номер два, вариант номер три.
А?
Ну, конечно же.
А?
Как говорится, база.
У меня, кстати, забавный факт.
Вот в формалках все говорится про слово...
Все говорится про индукцию.
Так у меня в дипломе, в Бакалаврском, было одно и то же слово повторено тоже огромное количество раз.
В домикандах же?
Нет.
Правила Лапиталя.
Там, если вбить в поиски, там раз десять или пятнадцать было Лапиталь.
Можно вопрос?
Какая идея, чем фамилия вашей бабы?
Ну, Федотова, допустим, а что?
Взломать пытается.
Федотова.
Отвечайте на вопрос, после этого у вас со всех счетов все снимут.
Ну-ну.
Ну, что там того, что сейчас восстановление по паролю.
Два-факторная антификация везде.
Дима КТЧ.
А?
Дима КТЧ.
Реализую в скором времени.
Ну, пока.
Так.
Ну что, давайте база.
Ну, за ноль шагов.
Тогда смотрите.
Вопрос.
З, тогда к чему будет равен?
Эпсилон.
Ну, потому что за ноль шагов у нас получается уэпсилон выводит.
Из этого будет следует, что уэпсилон.
П2.
П2 получается.
Из этого будет следует, что В равно эпсилон.
Ну, мне осталось следующее написать.
Что Q1P1 получается эпсилон-эпсилон.
Действительно за ноль шагов выводит.
Эпсилон-эпсилон.
То есть он выводит ровно ту же самую конструкцию, которая у нас была на входе.
А тут еще нужно сказать, что Q1 равняется Q2.
Q1 равняется P2.
Потому что за ноль шагов у нас состояния никаким образом не поменялись.
Так.
А, здесь еще была доказательств теоремы.
Да, давайте мы его пропустим.
Сейчас вернемся к нему потом.
Значит, это переход в одну сторону.
Три варианта рассматривается.
Вот.
Вот, собственно, мы проехали базу как раз.
Теперь переход.
Надо посмотреть, собственно, каким образом у нас происходили переходы.
Значит, тут у нас надо рассмотреть, какой был первый шаг.
Значит, мы могли либо читать из-у, либо прочитать что-то, либо записать здесь одновременно и прочесть здесь, либо записать что-то на выход.
Значит, либо пишем в, либо читаем, пишем в Z, читаем в Z.
То есть вот они три варианта.
Давайте рассмотрим первый из них.
Читаем букву А из слова Q.
Переход.
Первый шаг.
Читаем букву А.
Из-у.
Ну тогда давайте смотреть.
Что это означает?
Это означает, что Q равняется А'
И получается следующее, что у нас Q1 А' ексилон за один шаг мы получаем с вами Q1 U' ексилон.
И дальше за какое число шагов мы получаем Q2 ексилон V.
Так, кстати, здесь есть какое-то промежуточное состояние Q3.
И во втором у нас преобразовании есть следующее.
Значит, P1 Z' выходит у нас получается.
И смотрите, до каких пар тогда мы можем сделать предположение индукция?
Ой, только тут Z.
Для каких пар мы можем переписать предположение в другую сторону?
Смотрите, Q3 P1 и Q2 P2.
Значит, по предположению индукции у нас получается, что у нас Q3 P1.
А получается Q3 E' выводит пару Q2 P2 E' V.
Так, а теперь давайте смотреть на переходы наши.
При этом смотрите, как получить слово Q1 P1?
Так, получается A U' E', которое в нашем случае U.
Смотрите, за один шаг давайте обозначим эти переходы.
Это первое, это второе, это третье.
Вот, смотрите, и здесь у нас как раз есть вот такой переход,
который позволяет нам не менять наше состояние в автомате.
Вот оно, по второму свойству мы получаем следующее,
что Q3 P1 выводит Q' E', а вот это уже по предположению индукции.
Точнее, по факту лучше.
Мы получаем пару P2 E' V.
То есть первый переход мы с вами сделали.
Так, скажите, понятно, что произошло?
Мы просто осмотрели первую букву, а дальше применили предположение индукции.
Вот еще вкратце, как это все делается.
Так, хорошо. Как вы думаете, какой случай будет собираться ровно аналогичным способом?
Третий случай, когда мы с вами пишем букву V.
Вот, давайте мы его тоже рассмотрим.
Давайте мы его назовем второй.
Получается, так, мы читаем, пишем.
Я его тоже напишу таким вот образом, то есть смотрите.
Получается, что V это V' C, наоборот C' V'.
Ну и получается следующее, что у нас P1 Z' выводит P2, точнее некоторые P3.
Получается C'.
А, наоборот, мы же пишем C, да?
Z' C и это у нас P2' C' V'.
Хорошо. Ну тогда, смотрите, опять же мы можем с вами применить предположение индукции.
То есть здесь у нас получается, смотрите, Q1 U' выводит Q2' Z'.
И вот теперь, смотрите, здесь у нас соответственно будет такое же, кроме буквы C'.
Получаем, опять же, по предположению индукции, что из пары Q1 P3.
Так, что получается у нас?
У' мы можем перейти в пару Q2 P2' Z'.
Ну осталось первый переход поставить.
Получается, у нас будет свойство по 3.
Что у нас получается с вами?
Значит, пара Q1 P1 получается U'
Дальше у нас получается за один шаг, вот как раз за вот тот шаг, на который вы написали букву C,
мы можем его написать и в нашей тройке.
Ну и дальше уже применить предположение буквы.
Дописав слово V в конец.
То есть, смотрите, получаем, что мы можем здесь со входа ничего не брать,
с выхода ничего не берем, вот как бы записываем букву V.
Получаем пару S' V'.
Это все.
Второй факт мы с вами тоже пока не знаем.
То есть, чисто техник?
Так, понятно?
Давайте еще раз.
Сейчас вот третий предположение мы будем сыграть, что их звучит.
Так, да, согласен.
Это второй переход.
И остался самый тяжелый переход, это третий.
То есть, идея такая, у нас есть 4 варианта.
Есть один вариант, когда мы считаем букву, есть второй вариант, когда мы пишем букву.
А есть третий вариант.
Смотрите, третий вариант интересен.
То есть, мы если пишем что-то в промежуточный язык,
то мы обязаны из него что-то считать в какой-то момент времени.
Почему это не единственное, что мы рассматриваем?
Почему это не единственное, что мы рассматриваем?
В другую сторону доказательства.
Мы в смысле сказали, что оно тупо техничное и мы писать не будем,
но в эту сторону мы сейчас какую-то технику, бедность не пишем.
Не, мы не технику пишем, мы идею.
Надо посмотреть внимательно, что за первый переход у нас.
А в обратную сторону, вот здесь есть три правила, по которым появились переходы.
Вот по нему пишем.
А здесь как бы нам наоборот надо собрать эти переходы.
Так, третий переход.
Если мы пишем какую-то букву на выход, то мы это делаем.
Получается, смотрите, у нас с вами есть у1, значит, уэпсилон
за один шаг.
Мы переходим в состояние q3, у, давайте, b, а во втором автомате,
да, то есть если, опять же, количество переходов больше, чем 1,
то мы с вами делаем следующее, в п1, в п2, в п3, в п4, в п5.
Если, опять же, количество переходов больше, чем 1, то мы с вами делаем следующее,
в п1, получается, b, z штрих, эпсилон.
Переходим в состояние p3, которая, значит, берет, съедает эту букву b.
И дальше у нас получается, в п2, что получается, п2, эпсилон z.
А здесь у нас получается q2, эпсилон b, z-штрих.
Так, давайте посмотрим внимательно, по какому факту мы можем написать индукционный переход.
Смотрите, мне кажется, что если мы посмотрим внимательно на тройку,
u, z-штрих, v, то мы увидим интересную вещь, что оказывается, что вот этот вот переход,
мысленно закрываем букву b и смотрим на вот этот переход,
мы получаем с вами как раз предположение индукции.
Да, конечно же, за один шаг.
Потому что если бы этот переход был каким-то другим, мы бы применяли другие варианты.
Так, ну и получается, что по предположению индукции тогда q3, p3,
значит u, z-штрих выводят эпсилон b.
Так ведь? Хорошо.
А нам нужно, значит, общий факт.
При этом, смотрите внимательно, пожалуйста, я хочу обратить внимание,
что из вот того, что у нас переходы там первые, видите какие, они считывали,
первый переход писал букву b на выход, а второй переход читал букву b с обхода.
То есть мы с вами как бы видим, что здесь писали букву b, а здесь читали букву b.
Поэтому по свойству один, по переходу один мы можем написать q1, u.
Так, давайте это на другой доске напишу, потому что это будет не видно.
Так, давайте тут тоже промотаем.
Во, собственно, утверждение то, которое мы хотим написать.
q1, p1, u-эпсилон, за один шаг будет считать q3, p3, получается, да, тоже u-эпсилон.
Потому что там ничто у нас с вами не пишется.
Ну и дальше получаем с вами, ой, извините, я тут лажу написал.
Тут же епсилон у нас просто.
Все. То есть мы получили с вами идукционный переход.
Опять же, тоже техника, но чуть более умная, поэтому это надо разбирать.
Так, понятно?
Хорошо, теперь как терем доказывать, что языки совпадают?
Значит, патридь.
Предположим, что у нас пара u и v принадлежит вот этой вот композиции, которую вы построили.
Как мы обозначили?
Мы обозначили как-то, по-моему, c и m.
Вы да, смотрите, что это означает?
Это означает, что существует аq, p, принадлежащее f, ну, множество завершающих состояний, а q, p, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q.
Академии.
Которые мы обозначили вот это вот.
Такое, что из, смотрите, у епсион мы выводим пару q, p, епсион v.
Так, теперь, смотрите, лемма.
С учетом инварианта мы получаем, что это эквалентно, потому что у нас с вами существует z такое, что, выполнено такое свойство.
У 0 получается u, q, z.
И получается p0, p0, епсион v.
Ну, дальше смотрите, что получается.
Вот это эквалентно тому, что у нас слово, пара u, v, принадлежит psi1, потому что мы дошли до завершающего состояния, точнее uz.
Вот это эквалентно тому, что пара z, v принадлежит psi2.
Одна вопрос. А чему принадлежит пара u, v?
Композиция.
Да, как раз композиция.
Ну все, мы доказали с вами теорему.
То есть мы доказали с вами, что, конечно, преобразователь, который мы построили для композиции, будет работать вот таким образом.
Техника. Техника плюс одна идея.
Собственно, к чему мы с вами и вернулись.
Так, понятно ли доказательства в общих чертах?
Понятно, что формаль доказательства, ну, оно чисто техническое, и сейчас будет скорее всего не совсем понятно.
Вот, главное, я опять же подчеркиваю, что главное запомнить основную идею.
Основная идея, откуда мы первую букву берем?
Либо читаем, либо пишем, либо одновременно читаем и пишем.
А идея где?
Идея, первую букву рассмотреть.
Это не идея, это техника.
Идея была на прошлой лекции.
Не надо читать, оставить запись в лекции, послушать текло, чтобы доказательства не доказать.
Ну, можно так. Ну, как бы лучше это.
Так, долгожданный пример.
Представим себе, что у нас с вами есть два конечных преобразователя.
Здесь, по-моему, с алфавитом есть проблемы, но да ладно.
Давайте как раз перечислим пары состояний, которые будут между собой схлопываться на этой картинке.
Смотрите, здесь Q0P0, здесь Q0P0 и Q1P0.
Потому что, смотрите, здесь мы читаем букву B, здесь мы пишем букву B, а здесь мы ее считываем одновременно.
Какие еще переходы? Тут еще есть.
Q0P0 и Q2P1. То есть, здесь мы с вами пишем букву C, а здесь мы ее читаем.
Получаем Франкенштейна.
А?
Красавец.
Красавец.
Хороший переход из 0.
Хороший вершина 0.
Да, да, да. То есть, смотрите, первое, то есть, у нас здесь получается по вертикали вот это.
Вот преобразователь у нас с вами, то есть, мы дублируем все копии переходов, которые здесь есть.
А по горизонтали мы строим вот эти автоматы.
И по факту мы делаем с вами просто вот эти вот перемычки, синие перемычки.
Это у нас с вами переходы 2 и 3, которые у нас появляются.
А верхние, а красные перемычки, это он стоп, что фундаментально нам позволяет построить композицию.
Ну что, как вам картинка?
Ну, если почистить, нормально.
Ну, как обычно, да, если почистить, будет нормально.
Тут на самом деле три перехода только.
Три вершины являются, так сказать, там достижимыми и порождающими.
Если мы с вами говорим про термина.
Так, с этим разобраюсь?
Хорошо.
Получается, что куча вершин выкидывается, и понюхать к этому они и сжимают.
Ну да.
С первым конкретно понимаете, как можно рендеровать пайк на автоматах.
Но зачем это делать уже в оборудовании?
Да, зачем это делать, если это уже в косе.
Не, ну, в смысле, мы на косе это писали, когда махку.
Кто-то писал, кто-то еще будет.
Ну, кто-то и все будет, да.
Пайк на автоматах.
Ага, ну да.
Ландедлайн 4.
Понятно.
Так, значит, давайте...
Ну да, давайте это.
Давайте это.
Продолжим все-таки, вспомним теория манева, и наконец-таки воспользуемся ей правильным образом.
То есть, мы будем доказывать, что композиция регулярного...
Точнее, регулярная симконтенсовая свободность у нас сохраняется при взятии конечных преобразований.
Так, давайте посмотрим.
Сейчас мы будем доказывать следующий факт.
Что...
Возможно, кстати, у кого-то это уже было на семинарах.
Что если у нас L регулярный,
Psi это конечное преобразование, тогда Psi от L это регулярный.
Так, вы не поверите, как это доказывается.
Берем следующее.
Берем, значит, раскладываем по теориям манева
наше конечное преобразование.
И дальше смотрите, если мы докажем, что каждое из этих преобразований сохраняет регулярность,
то их композиция сохраняет регулярность.
Нет.
Сейчас мы будем уравнение решать с вами.
Слушайте, уравнение по индукции, мне казалось, что вас научили решать на первом семинаре, и все.
Смотрите, напоминая, что у нас phi и Psi это неудлиняющий гомоморфизм, неудлиняемость здесь будет важна.
Напоминаю, что такое неудлиняющий гомоморфизм, это гомоморфизм, который не увеличивает длину слова.
Поэтому скажите, пожалуйста, следующее.
Чему будет равняться phi от Epsilon?
Epsilon.
Epsilon.
Epsilon.
Так, а phi от буквы A.
Буквы Epsilon.
Да, это у нас либо B, либо Epsilon.
Либо A.
А?
Либо A.
B это символ алфавита какой-то.
Да, просто я говорю, что длина не больше, чем единица.
Хорошо, тогда вопрос.
Как решать уравнение вот такого вида?
То есть там нужно идти phi в минус первое от Epsilon?
Ну, в плане, мы берем все буквы, которые переходят в Epsilon.
Да.
И скрываем таких стуманов.
Да, смотрите, наша цель научиться решать уравнение.
Phi от X это Epsilon.
Да?
Значит, если у нас это X это слово, тогда у нас получается phi от X1 под хвостом амортиза.
Epsilon.
Значит, phi от Xit это Epsilon.
Для каждой буквы.
Угу.
Так, давайте я, чтобы не запутаться, я сейчас буду вводить определение как из презентации.
А, это алфавит у нас с вами.
И получаем, что у нас с вами X.
Это множество такое, что phi от Xit
равняется Epsilon.
Тогда смотрите, у нас получается, что X можно представить и дерегулярным выражением.
Плюс
А это что-то знает?
То есть это, это что-то знает?
Угу.
Смотрите, друзья, если у нас с вами решение уравнения является регулярным выражением.
Ну, можно сочлить дерегулярное выражение.
Это на что-то должно намекать.
Это означает, что если у нас с вами язык исходный регулярный, для него есть регулярное выражение.
Тогда вместо тех буквок, которые у нас были написаны.
Там допустим у нас написано было один плюс а со звездой было регулярное выражение.
Тогда мы, это уже можно заменить на регулярное выражение.
Здесь это плюс что-то со звездой.
Если это создает, будет создавать E.
Деничка это пустое слово, напоминаю.
То это будет создавать то, что переходит в пустое слово.
Наверное, это со звездой плюс.
Да, это со звездой.
Согласен.
Понятно, что звездочка воспитает.
Угу.
Осталось решить еще одно уравнение.
Нужно понять, что такое фиатекс.
Сейчас, я не очень понимаю, что вы хотите вообще сделать.
Мы хотим сделать следующее.
Смотрите, у нас есть регулярный язык.
Нам нужно доказать, что образ регулярного языка при обратном гомоморфизме, не уплиняющем, является регулярным.
Ну, в плане, это то, что мы сможем отвечать.
Ну, да, это да.
А причем это уравнение?
Ну, нам нужно написать явное регулярное выражение.
То есть, вот у нас L.
Вот у нас язык L, он регулярный.
Значит, у него есть все регулярные выражения.
Ну да.
Действуя на него обратным гомоморфизмом, не уплиняющим, хочется получить для образа этого языка тоже какой-то регулярный.
Угу.
Поэтому мы сейчас решаем как раз уравнение, что фиг минус первое от...
Чему равняется фиг минус первое от слова, если слово не запятится?
Если мы сможем выдать регулярное выражение, то мы победили.
Для епсилона мы справились.
Да, есть ли это буква?
Осталось решить одно уравнение еще.
Нам теперь надо научиться решать уравнения такого вида.
Во.
Вот такое вот.
Так, смотрите.
У нас слово должно быть какой-то буквой.
Образ слова – это буква.
Ну, смотрите, давайте посмотрим на картинку.
Значит, у нас с вами каждый из слов – это кондекция.
Значит, часть из них – это кондекция.
Это кондекция.
Значит, часть из них перейдет в епсилон.
Вот здесь вот это.
И какая-то из них перейдет в QB.
А это, это мы просто были обозначения для суда.
Да, да.
То есть остальная перейдет в B.
Нет, стоп, вы хотите решать уравнение не для конкретной группы, а для всех?
Нет, для конкретной.
Так что, смотрите, предположим, что у нас есть P от Y, но в это уравнение…
Очевидно, у нас есть еще, надеюсь, другие символы, которые переходят в другие буквы B.
Нет, конкретно в одну букву.
Только один символ перейдет в B.
Это определенное слово.
То есть вот у нас есть слово Y, которое мы разложили в такое произведение.
А, да.
Да.
А что, каждая из них дает в образе какую-то букву.
Прямо хустое слово.
Это, кстати, по свойству неозданящих галмархитм.
Да, потому что если бы это не было верным, то у нас могли бы всякие быть проблемы.
А, и поэтому, смотрите, давайте мы обозначим за tf, tf.
Нужно таких букв.
Кажется, здесь все еще минуты нет.
Кажется, здесь минуты нет.
Ну, кроме того, что epsilon может перейти во что-то сравнение.
Да, нам нужно, чтобы epsilon не переходил во что-то сравнение.
А иначе у нас, типа, просто длина будет больше чем одна буква.
Есть такое.
Значит, если у нас x сравнится с beta, то phi от x равняется f.
Вот, а тогда, смотрите.
Как тогда задать phi минус 1 от beta?
Какое регулярное выражение будет у этого пары?
Кто понимает?
Да.
Beta, beta, beta, beta, beta.
Ой, наоборот.
То есть, вместо a, здесь нужно поставить вот эту узкую вещь.
Видимо, я подумал, что это одно место на b.
А, да.
То есть, мы вводим вот такие телесиплы, и через них уже пишем регулярные выражения.
Мы доказали самый форсный факт, что право у нас, не изменяющего гамортизму, от регулярного языка, является регулярным.
Кажется, не изменяющего гамортизма в том, чтобы у нас была обратная вещь гамортизмы.
Ну, да.
Тоже есть такое.
Так, понятная идея?
Да.
То есть, решили уравнение?
Можно связь с того, что мы написали, и то, что нам нужно.
Ну вот, смотрите.
Давайте я напишу так.
Применяем для регулярного языка.
Вот этот регулярный, значит, мы хотим сделать так, чтобы вот этот был регулярным.
Вот этот регулярный, значит, вот этот должен быть регулярным.
Нет, это понятно.
А?
А про что говорим?
А почему именно с первой?
А, смотрите, значит, давайте еще раз.
У нас L регулярный, для него есть регулярное выражение.
Сдающее, да.
Да. Напишем регулярное выражение.
И заменим в нем все символы вову к такому правилу.
Все символы вову к такому правилу.
Единички заменяем на и со звездой.
Все символы заменяем на вот эту вот ерунду.
Получаем регулярное выражение.
Которое называется правообразие.
Это из свойственного маркета.
Да, это да.
Ну да, мы решаем это уравнение из свойственного маркета.
Нет, мы еще испускаем вниз.
Ну да.
Ну да.
Так, хорошо.
Давайте тогда следующий факт.
Следующий факт самый простой.
Часть номер два.
L регулярный, R регулярный.
Значит, смотрите, чему равняется ограничение этого регулярного...
Ограничение этого языка на регулярное?
Ну конечно, пересечение.
Вот это регулярное, вот это регулярное.
Что мы знаем про пересечение регулярных языков?
Регулярное.
Вот это регулярное.
Что мы знаем про пересечение регулярных языков?
Регулярное.
Доказали.
То есть вторую часть нашей цепи мы прошли.
Как доказывает третью часть цепи?
Есть идея?
Просто регулярно заменить.
Да, в каждом углу заменяем на образ.
То есть у нас было, допустим, мы заменяем это все.
Получается образ единичка и единичка.
Все, доказали.
Сейчас, а у нас есть свойство голморфизма, что фиата.A плюс.B равна фиата.A плюс.B?
Нет.
Ну, это кажется достаточно...
А что такое фиата.A плюс.B?
Ну, короче, я имею в виду, что мы можем спускать, если свойство голморфизма, мы можем пускать на произведение?
Ну, свойство голморфизма, да. Но на произведение это по определению.
Да, а сложение мы можем спускать?
Ну да, мы используем следующее, что в свойствах фи от А до Б.
Это факт из теории множества. Для отображения оно верно.
То есть у нас для любых отображений на плюс и на звездочку можно запускать?
Да. Ну, за счет звездочки, за счет того, что у нас есть для конкурсинации.
А звездочки для конкурсинации, да?
На плюс любое отображение на конкурсинации было.
Да, да.
Хорошо.
Так, это мы доказали.
Так, это вот факт.
Теперь следующий факт.
Предполагаю, что у нас есть контексты свободный язык.
Тогда нам нужно доказать, что образ его контекста свободный.
Здесь чуть-чуть сложнее, но не сильно.
Давайте проверим интуицию. Как вы думаете, какой самый сложный факт здесь будет доказываться?
Какая из частей цепи?
Ограничение просто.
Ограничение-то как раз просто. КС пересечься регулярно, но это КС.
Если интуиция, то тоже это будет самый сложный.
Ну, правильно, да.
И вы не поверите, чтобы упростить наше страдание нам понадобится нормальная форма хомского.
Мне не нравится.
А?
Мне не нравится, что нам придется упрощать страдание.
Даже если упрощать.
Так, смотрите, пусть у нас есть грамматика в нормальной форме хомского.
Тогда...
Смотрите, что мы делаем.
У нас есть уже решение уравнения.
Помните?
Если мы понимаем, что φ-1 от b,
звездочка получается...
Что у нас?
Это звездочка, это b.
Это же регулярно.
Регулярно. А теперь фишка в чем?
Давайте мы вот это вот решение уравнения представим в виде КС грамматики.
Но можно просто правление на грамматику построить.
То есть мы с вами зададим,
φ-1 от b как грамматика,
у которого будет, значит,
ж бета,
это получается n бета,
сигма,
точнее это будет тетту.
Давайте это с крышкой обозначим.
Ну, это тот прообраз, который есть.
Стартовое состояние будет sb,
и будут правила.
Тогда смотрите, что мы сделаем с вами.
Мы по факту
возьмем и подвесим это правило.
То есть мы заменим
правило
правило
Напоминаю, что у нас есть правило
вида
afbc,
afa
и sv.
И какую замену нам надо сделать?
Значит, вот это никак не меняется.
Вот это заменяется
на стартовый символ нашей грамматики.
Который мы построили для прообраза.
А s во что заменяется?
WCF
Да, WCF
Фанату линукс минта привет!
Ну, кто-то ноутбук открыл с линукс минтом.
Включил.
Я звук услышал.
То есть смотрите,
вот такое у нас получается
преобразование.
То есть как бы мы подвешиваем
вместо терминальных вершин
новый старт.
Са, еще раз.
Смотрите, значит у нас буква.
Мы хотим, чтобы здесь
вместо а
вот эта неверная конструкция
была вот так.
Фи в минус первое от а.
То есть у нас было правило
из а в а
мы хотим, чтобы вместо а
вводилось все, что было в с
в минус первое от а.
Ну для f в минус первое от а
мы хотим, чтобы вместо а
в фи в минус первое от а.
Ну для f в минус первое от а, поскольку это
регулярное выражение, для него можно покрыть грамматику.
Вот, и мы берем стартовое
состояние в этой грамматике.
И подвешиваем.
А еще надо то, что на или
в нормальном стиле?
Что бы можно было
формально написать, не более чем.
Ну просто в каждом
правиле искать терминалы и
заменять их на однообразно, это
ну больше писать буквам так.
Что бы у тебя в листьях были
нормальные терминалы, которые
они из правила
Если это формально
доказывать, просто редукция сильно проще.
Так, Влад.
То есть вот это самая основная
идея доказательства.
Значит второй факт.
ЛКС
Р регулярный.
Пересечение КС.
Пересечение КС, да.
Все.
А помните сколько мы
получили для того,
что бы этот факт доказать?
Мы построили МП-автомат
без эфсилон переходов.
Через нормальную форму грейбах.
Ну не только для этого.
Не удлияющий гомоморфизм.
Значит L это КС язык
и G грамматика формально
в форме хомска.
Ну тогда, давайте я напишу.
Надо заменить правила
на следующее.
А в БЦ.
Собственно, А заменяется
в образ буквы.
Не заменяется куда все.
Все.
Доказали.
То есть мы доказали, что
образ контекса свободного языка
при конечном преобразовании
это контекст свободного языка.
То есть за пределы этого языка
мы выйти не можем.
Кажется это все?
Типа хочется сказать.
Но на самом деле не все.
В том плане,
а можно ли что-то еще сказать
про конечное преобразование?
Помните, есть такой язык
в правильных скобочных последствиях?
Так ложно.
Существует интересный факт.
Если вы вспомните,
как вы доказывали
кондлежность контекса свободного языка
по описанию, кто вспомнит еще?
Заметьте.
Не, ну вы баланс считали.
Мы везде считали баланс.
Вам не кажется, что это странно?
Как-то.
То все задачи решаются
одним и тем же способом.
Ну а мы доказываем
тем же способом не странным?
Не, ну индукция это чисто формальная вещь,
которая необходима для того,
чтобы поверить в это доказательство.
Мне кажется, что все идеи построить
кресть язык по описанию.
Где мы сидим и читаем баланс.
И больше мы ничего не применяем.
Ну бывает.
Оказывается, это не зря так.
Этому есть формальное объяснение.
Оказывается, что контекст свободного языка
это не что иное,
как некоторая модификация
правильных скобочных последностей.
Говорят, случайность и не случайность.
Минго, значит, смотрите,
здесь для любителей лемма-разрастание
еще одна.
Для очень больших любителей.
Для ценителей.
Вы не поверите, доказывается в одну строку.
Заметьте, ну что?
В одну строку, которую мы не прочитаем
в первом разу.
Идея такая.
Еще раз, для тех,
кто внезапно пропустил лемма-разрастание,
лемма-разрастание показывает,
какие пары слов не находятся
в конечном преобразовании.
И идея следующая.
Мы берем автомат,
точнее преобразователь, в котором
либо пишем одну букву со входа,
либо пишем одну букву на выход.
И повторяем ровно то же самое доказательство,
которое у нас было для лемма-разрастания
конечных автоматов.
Импорт, да.
Импорт и экстенд.
Нет, надо
настоследник применить.
То есть получается, что
сумма здесь возникает
из количества букв.
То есть она у нас есть либо на входе,
либо у нас есть на выходе.
Вот.
Я бы сказал, что
в данном случае это уже упражнение
доказать этот факт
в счет того, что мы с вами прошли на курс.
Здесь есть все равно доказательства в презентации.
Можете посмотреть их.
Идея такая, что опять же у нас есть цикл.
Существует вершина,
к которому мы посетили дважды.
И опять же видим цикл.
Я это не буду говорить,
потому что сейчас хочется доказать интересную вещь.
Здесь еще есть примеры в презентации.
Опять же можно посмотреть,
как это делается.
Здесь перевод в троичную систему
числения. На семинаре,
я надеюсь, это разберут с вами.
Идея в том, что...
Давайте тогда скажу,
в чем идея состоит. Идея в том,
что длинные слов при разрастании
меняются рациональным образом.
Рациональным числом.
А перевод из одной системы числения в другую
имеет нерациональное отношение
от длинных слов.
Что?
Да, так сразу это.
Идея, почему нельзя
при помощи конечного преобразования
перевести число из двоичной системы в троичную.
Потому что при разрастании
у нас длина слова меняется
в рациональное количество раз,
а перевод из одной системы числения в другую
меняет это все в нерациональное число раз.
Михаил так задумался.
Возможно для каждого к,
но все-таки рационально.
Ну да, в пределе мы смотрим.
То есть наша цель, чтобы наше
разрастание выбило нас за пределы языка.
Потому что мы можем
рассмотреть слово
X1,
у нас же нет
предельного слова.
Нет, предельного нет слова.
Смотрите, еще раз идея.
Мы раскладываем это все в произведении трех
произвольных слов.
X1 Y1 Z1,
X2 Y2 Z2, фиксированные в данном случае.
Ну да, и к меняется.
Нам нужно отношение
длин для к посмотреть.
Сейчас, я не понимаю, чем проблема,
что на странице к двоичной системе.
У вас
есть число,
у вас есть пар N2 и N3,
которые должны одновременно лежать
на этой хладке.
На доске
оно не стремится как раз
к ладери.
Оно стремится к констанции.
Вот в чем прикол.
Да, оно не стремится к ладери,
оно стремится как раз
к рациональному числу,
а по факту оно стремится к отношению Y.
Да, все, сейчас напишу тогда.
Да, там написано что-то.
Ладно.
Там написано то, что мы хотели бы.
Смотрите, значит
я напишу так,
что в двоичной системе
будет стремиться как рационально.
Вообще, логарифмон
двоичного
по трех,
вот поэтому не ленивый писать
в последний год.
Прием стремящего бесконечности.
Вот это я.
Это почему M?
Почему M?
Почему M?
А M это у нас с вами следующее.
У нас функция M зависит от K.
Да не стремится.
Я должен сказать,
что оно стремится к
отношению Y.
Да, да, да.
Смотрите.
Смотрите,
смотрите, здесь два фактора.
Первое, что это
стремится к отношению
длинных слов Y1 и Y2,
приказ
меняется бесконечно.
Если мы возьмем,
что наша функция M
это M от K,
то мы можем
для произвольного M
написать вот такое.
для f чисел
нам нужно найти противоречие
вот эта штука для изъема разрушания
приходим к противоречию
теперь смотрите
это мы с вами разобрали
тут тоже самое про скобочные последности есть
разобрать почему правильные скобочные последности
нельзя из-за ноунтургии перевести
теперь новая вещь
которую еще ни разу не рассказывал
но как бы случайности не случайны
вводим вот такой факт
у нее есть даже название
теория мохомского счетца нерже
и у нее есть две формы
слабая форма и сильная форма
я буду рассказывать идею доказательства
идея такая
детали там на самом деле не очень сложные
Михаил подтвердит
мы это на семинаре уже доказывали
значит всякий контекст свободный язык
можно получить некоторым
рациональным конечным преобразованием
из языка с ИК
видами правильных скобочных последностей
то есть любой контекст свободного языка
который вы не берете
у него оказывается есть
вид представления ВК
скобочных последностей
что такое рациональное?
это конструктивное доказательство
то есть оно явно получится
тогда картинку будем рисовать
я сокращен
смотрите
получается следующее
давайте сформулируем формально
ЛКС язык
тогда существует конечное преобразование ПСИ
такое что
Л
для некоторого ВК
что такое БК?
БК это ПСПС
в К типом скобок
правильно?
это правильно если это отбенатур
то есть мы берем скобки
можем брать круглые скобки, квадратные скобки
фигурные скобки, угловые скобки и так далее
оно К должно быть
К пар открывающий
соответствующий и закрывающий скобка
догадайтесь что красивое
давайте подумаем
пока я тут
занимаюсь тем, что я
прятал мочу
как можно представить контекст
в свободном языке?
нормально
еще?
по автоматам
и по автоматам
что мы знаем про автомат
то как меняется стэк
можем ли мы сделать так
чтобы мы на стэк
клали не что-то большое
и со стэка тоже снимали не что-то большое
по одной боку
по одной боку да
это мы идем
смотрите
LKS язык
все да
у нас нет стэков
да
собственно
существует mp автомат m
оказывается магазин
памяти со стэком
такой что
для любого перехода
выполнено вот такое соотношение
сумма для стэков
равняется единице
а это означает
смотрите
что у нас есть переходы вида q1,u
давайте я буду обозначать буквы
q2,a,k,t
q1,a,k,t
q1,a,k,t
q1,a,k,t
q1,a,k,t
q1,a,k,t
q1,a,k,t
а
а и ты
принадлежит в
стэковом алфавиту
а второй переход получается
q1,u,a,k,t
q2,x,u
а теперь осталось аккуратно построить конечный преобразователь
значит для
всех таких переходов
я напоминаю что это у нас автомат
то есть у нас как бы фундамент есть
нам нужно
правильно переложить эти все вещи
значит давайте посмотрим
значит для такого перехода
u,u,a,k,t
мы его превращаем
в переход
вида
u
я не знаю как обогначить скобку
а давайте да
банальный вопрос
катый скобкой
вот так вот
вот
а все такие переходы
представляем в виде
закрывающей скобки
тогда образ
так только
что мы сказали?
всякий ks
из множества
наоборот короче говоря
мы вход и выходы местами перепутали
да
у нас есть кс
у нас есть кс
у нас есть кс
да
мы убираем все
просто скобки
вот теперь корректно
то есть на вход мы подаем какую-то скобочную
последность по факту это
история стека нашего
то есть кладем вверх, складываем вниз
баланс не отрицательный
поэтому стек всегда не пустой
не пробивает дно
правильно
поэтому мы посмотрим
и как раз по вот этим переходам
как раз восстановим mp автомат
сейчас, подожди
то что мы первое пишем
в переходе, это мы считываем или пишем?
считываем
а вы по скобочной последности
да, по скобочной последности
наша цель получить что-то из скобочных последностей
вот
то есть буква на стек открываем скобки
буква на стек и закрываем скобки
и значит
это еще не все
то есть смотрите, все что у нас есть
это некоторое конечное преобразование
над правильным скобочным последствием
есть более сильная форма, которую мы доказывать не будем
в этом курсе
она вот такая
то есть оказывается, что
кс языка это на самом деле
не что иное, как
это некоторое преобразование
над языком правильных скобочных последствий
то есть мы как бы
у нас есть язык правильных скобочных последствий
мы его ограничиваем на какое-то
регулярное выражение
а потом переводим каким-то гомоморфизм
то есть получается, что
контексты свободные языки у нас
на самом деле имеют
ну, не так много вариаций
так сказать
все в некотором смысле
правильно, все в некотором смысле
правильно скобочные последствия
вот
то есть вот такой вот у нас факт есть
напоминаю, что презентации у нас есть
поэтому, если что, это можно делать
так, да
ну, в кавычках, несложное преобразование языка PSP
так, значит, смотрите, давайте подъем итоги
мы с вами сегодня доказали, что
конечные преобразователи сохраняют
автоматныеquinese языки
дополнительно, мы с вами посмотрели, что контекст свободный
и AB a discrete
то есть, у нас осталась одна лекция
и одна тема
та самая
и есть шанс не успеть ее за лекцию
нет, мы её успеем за лекцию
возможно, даже успеем минше, чем за лекцию
Мы будем доказывать линейный алгоритм.
Заодно, может быть, я, кстати, приду и покажу, что сейчас в файтон 3.12 творится.
А что такое трансляции?
А это преобразователи.
На английском языке они пишутся transducers.
Вот они, трансляции.
Вот они те самые трансляции.
Да, и мы с вами понимаем, что компилятор это тоже в каком-то смысле преобразователь из одного языка в другой.
Ну да, а если компилятор говорим, то это в Assembler.
Все, давайте вопроса.
Аплодисменты
