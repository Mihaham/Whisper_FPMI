Я напомню, на чем мы остановились. Мы рассмотрели две формальные системы.
Исчисление-высказывание и исчисление-предикатов. Обе они имитируют обычное математическое
рассуждение. Исчисление-высказывание формализует тавтологии. То есть формула является тавтологией
тогда и только тогда, когда она выводима. Исчисление-высказывание аналогично. Исчисление-предикатов
формализует общезначимые формулы. Формула общезначима, если ее можно вывести в исчисление
предикатов. Я уже про это говорил, по крайней мере в прошлый раз точно. Но сейчас я это хочу
подробнее объяснить, что выбор формальной системы, он в общем-то не единственный. В сущности,
вот эти классические системы возникли потому, что основная цель была формализовать математику,
и люди выделяли самые базовые шаги математического рассуждения. Но с другой стороны,
если задача ставится так, что нужно как-то проверить, что формула тавтология или формула
общезначимая, такого ограничения нет. Плюс эти шаги, которые фиксируются в этих исчислениях,
они удобны с человеческой точки зрения. А если, например, проверку делает компьютер,
то можно делать и какие-то другие шаги. Если они достаточно эффективны, то какая, в общем-то,
разница? Они могут более сложно определяться. Но разницы большой нет. И из вот этих всех
наблюдений возникло понятие системы доказательств. Что это такое? Это алгоритм,
который берет пару. Можно считать, что это двоичные строки, тексты или что-нибудь такое.
Ф я условно буду называть формула. Формула, утверждение, неважно. А П доказательства. И у
нас есть какое-то хорошее множество формул. Я тоже кавычки поставлю. Ну, скажем, тавтологии или
общезначимые формулы. Но, в принципе, может быть и что-то другое. И от системы доказательств для
этого множества требуется следующее. Алгоритм читает эту пару и выясняет, верно ли, что вот
это вот П является доказательством в некотором смысле этой формулы Ф. И должно выполняться такие
условия корректности. Алгоритм признает, что это П, это корректное доказательство Ф. Или не признает.
И условия корректности должно быть таким. Если формула принадлежит вот этому множеству
хороших формул, то существует такое доказательство, что алгоритм признает,
что это доказательство формулы. То есть, для каждой хорошей формулы доказательства есть. А если
формула плохая, то для любого доказательства алгоритм его отвергнет для этой формулы,
то есть посмотрев на что-то, что пытаются ему продать в качестве доказательства,
алгоритм говорит нет, для этой формулы это не доказательство. То есть вот такая корректность.
Ну видно, что исчисление-высказывание и исчисление предикатов удовлетворяют этим условиям, что у нас
в данном случае будет f и p. Ну допустим, для исчисления-высказывания я буду говорить,
для исчисления предикатов аналогично. f это запись, двоичная запись бульевой формулы. Что такое p?
p это вывод в исчислении-высказывание, то есть последовательность формул,
которая содержит нашу и каждая формула обоснована. Что делает алгоритм? Алгоритм делает очень простую
вещь. Он смотрит, во-первых проверяет, что это действительно корректный вывод. То есть про каждую
формулу ему нужно понять, является ли она аксиомой. Мы обсуждали, что это легко сделать алгоритмически.
А если аксиомой не является, ему нужно перебрать все пары предыдущих формул и посмотреть, можно ли
эту получить с помощью modus ponensis предыдущим. Но это тоже перебор предыдущего отрезка доказательств,
он не очень длинный, поэтому алгоритм эффективный. Эффективный это работает за полиномиальное время
от длины входа. Длиной входа в данном случае является вся пара. Доказательство само по себе
может быть длинным. Вот это называется система доказательств. И если действительно интересоваться
какими-то компьютерными приложениями, то есть компьютерной проверкой тавтологичности, то нет
никакой нужды останавливаться именно на нашей формальной системе, это исчисление, высказывание.
Можно придумать что-то еще. И таких систем придумано много. Я расскажу об одной самой,
по-видимому важной на самом деле, за исключением вот этих вот классических, которые мы сказали,
они тоже очень важны. И рассказ опять-таки разобьется на две части. Вначале я объясню,
как это работает в случае булевых формул, даже в начале чуть более узком случае, потом булевые
формулы, а потом уже объясню, как это применять к логике первого порядка. Так же, как в сущности у
нас было, исчисление, высказывание такой небольшой кусочек исчисления предикатов, который работает
только с булевыми формулами, и с ним легче разобраться, чем с исчислением предикатов. Я напомню,
что полноту исчисления предикатов я доказывать не стал, сославшись на то, что технически это
довольно трудно. Это действительно труднее, чем то, что мы проделывали, хотя следует тем же самым
идеям. Так вот, окажется, что та система, которую я сейчас введу, она дает возможность доказывать
теоремы корректности полноты для логики первого порядка довольно быстро. То есть самая трудная
часть сегодня будет относиться к булевым формулам. К логике первого порядка надо будет
разные преобразования делать, но по модуле этих преобразований все на самом деле очень несложно.
Там есть только одна идея, быть может шокирующая, но она такая в логике всегда, то есть это, как не
доказывая, она возникает. Но про это в следующий раз. Итак, давайте рассмотрим систему доказательств
основанная на правилах, на правиле резолюции. Что это такое? Это такое правило. Если у нас есть две
формулы A или B и не A или C, мы можем вывести B или C. Ну, как вы уже должны были осознать, вот эти
правила вывода, они основываются на каких-то семантических следствиях. Мы хотим, чтобы вывод
сохранял хорошие свойства формул, и семантическое следствие в данном случае очень простое. Если у
меня есть две вот такие булевые формулы, то из них семантически следует B или C. В частности,
если это тавтология, это тоже будет тавтология. Если эти формулы истины на каком-то наборе
при значении переменных, это тоже будет истина. Почему? Ну, это очень легко увидеть. Смотрите,
A и не A, они могут быть одновременно истинны. То есть на любом наборе при любых значениях
переменных одна из этих формул ложна. Если ложна, скажем, не A, а вот такая дизюнция истина,
значит C истина. Если ложна A, а вся вот такая дизюнция истина, значит B истина. Таким образом,
у нас есть два случая, и в каждом из них или B или C истина, ну и значит B или C обязательно истина в
обоих случаях. То есть очень простой такой вывод. То есть само по себе правило сомнению не подвергает,
но давайте разберемся, как его применять. Оно уже выглядит не похоже на наши обычные рассуждения,
и нужно вначале придумать, для чего такое правило удобно использовать. Ну, первое наблюдение
состоит в том, что удобно использовать для того, что называется дизюнкты. Это дизюнкции литералов.
То есть не произвольные формулы, а дизюнкции литералов, переменных или отрицаний. Ну почему?
Потому что тогда мы видим, что у нас сохраняется это свойство. В принципе, резолюции можно применять
к более сложным формулам, и даже на самом деле такие системы рассматриваются, но я их касаться
не буду. Они более сложные, и нам они не потребуются. Это первое наблюдение. То есть,
исходно резолюции хорошо бы применять к наборам дизюнктов. Я чуть позже скажу, каким именно наборам,
но это просто наблюдение из самого вида формул, которые входят в правила резолюции, как-то так
сразу становится ясным. Второе наблюдение, еще более важное. С помощью правил резолюции удобно
не доказывать, а опровергать. Опровергать что? Выполнимость некоторых наборов дизюнктов. Вот давайте
я рассмотрю пример. Наверное, здесь поместится. Давайте возьмем дизюнкты A или B, не A или B,
A или не B, не A или не B. Я думаю, что всем понятно, что это множество дизюнктов несовместно. Почему?
Потому что каждый из этих дизюнктов обращается в ноль ровно в одной точке. Этот ноль-ноль, этот в один
ноль и так далее. Но все четыре возможных значения переменных этими четырьмя дизюнктами покрыты.
Как бы вы ни присвоили значения A и B, один из этих дизюнктов будет нулем. А теперь смотрите,
как можно с помощью правила резолюции это обосновать. Давайте возьмем вот эти два дизюнкта и применим
правила резолюции. Ну тут формально написано B или C, но мы знаем, что B или B это то же самое,
что B. Давайте применим здесь правила резолюции опять по переменной A. Получим не B, точно таким
же рассуждением. Теперь один маленький трюк. Правила резолюции буквально этого не содержит,
но никто ж нам не запретит написать вот так. Дизюнкция с ложью. Если мы берем какое-то утверждение и
дизюнкция с тождественной ложью, а это то же самое утверждение, потому что если вы ставите в
дизюнкцию тождественную ложную утверждение, ничего не меняется. Но теперь форма позволяет применить
правила резолюции уже по переменной B. И мы выводим ложь. То есть получается так, у нас есть дизюнкты,
мы применяем правила резолюции, выводим новые дизюнкты и заканчиваем тем, что выводим тождеост
наложенный дизюнкт. Я его еще буду называть пустым, сейчас объясню почему. И это означает, что исходное
множество несовместно, потому что вот посмотрите на это семантическое утверждение. Если есть
выполняющий набор для этих дизюнктов, то в силу вот этого семантического следствия он же будет
выполняющим набором для этого дизюнкта, для этого и для этого. Ну а для лжи выполняющего набора нет,
значит его нет и для исходного множества дизюнктов. Таким образом наша формальная система будет устроена
немножко не похоже на то, что было раньше. У нас теперь будет не доказательство, а опровержение. Ну и
давайте теперь ее будем строить. Прежде чем ее строить, давайте договоримся вот о чем.
Есть такие очевидные наблюдения за дизюнкциями. Если я беру дизюнкцию А или А, это то же самое,
а я это уже использовал. Если я беру дизюнкцию А и истины, это истина. Если я беру дизюнкцию А или
не А, это тоже всегда истина. Такие очевидные тавтологии. Поэтому, вообще говоря, в дизюнкте не
имеет смысла повторять литералы в силу вот этой тавтологии. Если какой-то из литералов обратился
в истину, то весь дизюнкт обращается в истину. Если в дизюнкте встретилось два противоположных
литерала, переменная и ее отрицание, то это дизюнкт истины. И если мы получили истинный дизюнк,
то он нам становится бесполезен, потому что никакому противоречию мы используем,
то естественно, истинный дизюнкт не придет. Поэтому дизюнктом теперь я буду называть вот такой
стандартный дизюнкт. Это по определению множества литералов без пар. То есть каждый литерал ходит не
больше одного раза. Порядок литералов тоже не важен. Дизюнкты же, мы помним, что коммутативно,
поэтому в каком порядке записаны дизюнкты не важно. И нету противоположных литералов,
потому что тогда дизюнкт дождется истинной, нам это не интересно. То есть вот такие стандартные
дизюнкты. И правила теперь, резолюции, я сформулирую чуть жестче. Ну, пока я написал
резолюцию по переменной, но я требую, чтобы результат тоже был стандартным дизюнктом.
Ну а что скажете вы делать, если у нас написано что-нибудь такого типа. Формально мы можем
применить резолюции по x и получим не y или y. Это не стандартный дизюнкт. Вот удобно считать,
что в этом случае правило резолюции просто неприменимо. Это же легко определяемый случай,
он бесполезен. Неприменимо не в том смысле, что что-то плохое случится, а просто бесполезно.
Но мы увидим дождец на истинной дизюнкте, он нам никак не поможет дальше. Поэтому формальную
систему, которую я назову исчислением резолюции. Сокращенно буду писать и r. Она устроена так,
формулой в ней это стандартные дизюнкты. И есть ровно одно это вот правило резолюции. Важно,
чтобы их дизюнкция была стандартной. То есть как в моем примере, смотрите, это конечно и это,
и это стандартные дизюнкты, а когда мы применяем резолюцию, у нас получается уже не стандартные.
То есть мы просто говорим, что правило неприменимо к таким дизюнктам и всё. Это же нас не сильно волнует.
Ну хорошо, как устроено исчисление резолюции? Мы говорим, что из множества гамма это множество
дизюнктов. И мы говорим, что из него синтоксически в исчислянии резолюции следует дизюнкт D,
если существует резолютивный вывод. Что это такое? А это последовательность дизюнктов.
Без ограничения общности можно считать, что последний как раз D. И что должно выполняться?
Как обычно, когда мы говорим о выводе, нам нужны какие-то обоснования. Обоснования двух типов.
Первое обоснование DIT, то есть это для любого I должно одно из двух выполняться. DIT принадлежит
вот этому множеству гамма, не формул дизюнктов, из которых мы выводим. А второе обоснование
применимо правилой резолюции, то есть DIT получается с помощью правила резолюции из какого-то
DIT DIT, где jk меньше i. Ну и вот видно, как это должно выглядеть. Значит, у нас должно получаться так,
что DIT должно иметь вид какой-то переменной x или DIT, какой-то еще хвостик. DIT должно иметь
вид не x или какой-то другой хвостик. Тут индексы различают. И наш дизюнк DIT это как раз дизюнция
этих вот остатков. В этом случае мы говорим, что дизюнк DIT и получается применением правил
резолюции к двум предыдущим. Важным частным случаем является опровержение. Я это буду обозначать
вот так. Я вот вел специальное обозначение для лжи. Так удобно. Ну и в этой науке так принято. Что
такое опровержение? Опровержение это вывод пустого дизюнка. Я вот здесь сказал, что дизюнк стандартный,
а что такое пустой? Это просто-напросто пустое множество литералов. Ну вы скажете, с чего вдруг
я его пустое множество литералов отождествляю с тождественной ложью. Ну смотрите, чтобы дизюнция
была истинной, нужно чтобы один из ее членов был истинной. То есть правило такое, существует
член дизюнции, который истинный. Если мы берем квантор существования по пустому множеству,
он всегда ложный. Потому что в пустом множестве вообще элементов нет, поэтому там точно не
существует такого элемента. Ну значит ложное. То есть вот такое немножко иезуитское объяснение,
но оно формально правильное. Ну и содержательно вот на этом же примере видно было, что нам так и надо
рассуждать. Хорошо, значит опровержение это вывод пустого дизюнкта. Просто по определению. А
опровержение чего? Давайте подумаем. Ну вот тут я пример сейчас как раз стираю, и из него в общем-то
опровержение чего? Мы высказываем утверждение, что множество вот этих дизюнктов совместно, и если
нам удалось увести пустой дизюнкт, то этот вывод опровергает это утверждение. То есть это
утверждение заведомо ложным. Потому что мы доказываем, что оно не совместно. То есть это
доказательство не совместности множество дизюнктов или опровержение утверждения совместности.
совместности. Принято называть опровержением, чтобы подчеркнуть разницу между этими типами
формальных систем. Ну и основная теорема. Звучит очень просто. Я ее сейчас формально запишу,
перескажу словами, что это означает. Смотрите, что означает, что из множество Disjunct Mutta
семантически следует пустое? Это означает, что множество несовместно. Пустой Disjunct ложен на
любом наборе значений перименных. Если бы существовал выполняющий набор для гамма,
то тогда бы мы точно могли сказать, что пустой Disjunct не следует из этого множества. А если
следует, значит, что на любом наборе значений переменных
хотя бы один дизъюнкт из гамма ложен. А это вот наш
вывод опровержения. То есть опровержение существует
тогда и только тогда, когда множество дизъюнктов несовместно.
Ну и как обычно, эта равносильность разбивается на два утверждения.
Корректность. Если мы что-то вывели, если мы вывели не что-то, а пустой дизъюнкт,
то тогда это множество несовместно. Ну, можно рассуждать по-всякому.
Проще всего написать контрапозицию. Значит, контрапозиция будет выглядеть как?
Если гамма совместна, то тогда из такого гамма нельзя вывести пустой дизъюнкт резолюциями.
То есть, если семантически не следует пустой дизъюнкт, то и нельзя вывести.
Доказательство в эту сторону получается проще. Давайте подумаем, как это доказательство записать.
Ну, как обычно, индукция, вот у нас есть определение резолютивного вывода,
нам нужно делать индукцию по набору значений переменных. Я не случайно переформулировал это вот так,
потому что нам это альфа понадобится. Я хочу по индукции доказать, что если у нас есть вот это вот,
это резолютивный вывод из гамма, то на наборе значений переменных альфа, значит гамма от альфы,
я считаю, все дизъюнкты истины, то тогда и все дизъюнкты, которые мы выводим, тоже истины.
И этого достаточно, чтобы утверждать, что мы не можем вывести пустой дизъюнкт,
потому что пустой дизъюнкт должен быть ложным. Ну, а доказательство индукции по длине вывода.
База индукции понятна какая. Первый дизъюнкт в нашем выводе, безусловно, должен принадлежать
множеству гамма, потому что правила резолюции применима только если есть хотя бы две формулы
перед этим. Значит, по условию такой дизъюнкт истинный. Ну, то же самое, если мы берем какой-то
шах, теперь шах индукции, без ограничения общности, вот это самое t. Допустим, для всех выводов,
короче, t мы это уже умеем доказывать. Значит, все вот эти вот предыдущие дизъюнкты, все истины,
по предположению индукции. И нам нужно доказать истинность последнего дизъюнкта. Ну, если он
принадлежит гамма, то опять-таки проблем нет. Осталось понять, что будет, если мы применяем
правила резолюции. Ну, давайте смотреть. Вот мы применяем правила резолюции, эти два дизъюнкта
истины на альфа по предположению индукции. И тогда мы знаем, мы же проверили семантическое вот это
следствие. Тогда мы знаем, что то, что мы получаем по правилу резолюции, тоже истинно. Если это истинно,
то и это истинно. Ну, вот, в общем-то, и все. На этом доказательство закончено. То есть, ну,
тут еще раз видна вот эта идея, что обычно доказательство корректности проще. Не всегда,
я знаю примеры формальных систем, мне о них рассказывали, где удивительным образом полнота
доказывается легко, а корректность это трудная задача, которую люди долго решали. Так тоже
бывает. Но это редкость, это скорее экзотика. Обычно у нас мы придумываем формальную систему и
стараемся придумать, ну, вспомните, как я вводил резолюцию, я тут же сразу проверил,
что семантические следствия выполняются. Ну, именно для того, чтобы не иметь проблем с этим
правилом, что если эти формулы истинны, то и это истинно. Мне с самого начала этого хотелось,
я с самого начала проверил, что это так. Но полнота с полнотой, как обычно, сложнее.
Но не так, чтобы уж совсем сложно. Значит, для полноты мне нужно доказать в обратную сторону. Давайте
где-нибудь здесь предварительные логические преобразования напишу. Значит, полнота означает,
что если у нас множество несовместно, то оно выводится в исчислении резолюции. Ну, из него,
оно проявляется в исчислении резолюции, извините, а проявляется, можно вывести пустой дезюмп.
Ну и опять-таки удобно использовать контрапозицию и доказывать, что если не выводится пустой
дезюмп, то тогда гамма совместно. Существует набор значений переменных, которые выполняют все
дезюмпы. Но это привычное нам рассуждение, когда мы доказывали полноту для исчисления
высказываний, было то же самое. Мы предполагали, что нельзя вывести противоречие, тогда можно
построить выполняющий набор. Здесь похожая ситуация, здесь противоречием будет пустой дезюмп,
играть роль противоречия. И вот если его вывести нельзя, говорим мы, ну тогда должен существовать
выполняющий набор. Вот это надо проверить. Это посложнее, потому что теперь мы уже возможности
засунуть в определение, нужное нам утверждение потеряли, у нас уже все определения зафиксированы и
нужно какое-то рассуждение. Но давайте подумаем, как рассуждать в этом случае. Первая идея состоит
вот в чем. Идея пополнения. Я напомню, что когда мы обсуждали исчисление высказываний, то мы тоже,
когда доказывали, что непротиворечиваяся равносили на совместности, мы брали непротиворечивое
множество формул и пополняли его, потому что с пополненным проще рассуждать. Здесь то же самое.
Давайте возьмем множество форм, дизъюнкта в данном случае, таких, что они выводятся из гамма. По
нашему условию пустой дизъюнкт этого множества не принадлежит. То есть просто включаем в это множество
все-все дизъюнкты, которые мы можем вывести. Вот тут самое время сказать, мне дальше это будет важно,
что множество гамма, я про это нигде до сих пор не говорил, но вы можете проверить. Множество гамма
не обязано быть конечным, оно может быть бесконечным. Рассуждения никакие пока не испортились,
ну потому что тут, когда мы доказывали корректность, ну что там, ну все истины, ну да, все истины. Ничего не
портится от того, что этих всех бесконечно много. Сейчас мне важно, что хотя множество может быть
бесконечным, множество переменных счетно. Я его могу пронумеровать. Если не счетно, вот буквально
такое рассуждение, как я привожу, не годится, там его нужно модифицировать, это возможно, но
давайте не будем заморачиваться. Счетного множества переменных уже довольно многом, нам его хватало
все время, непонятно почему, ну на самом деле понятно, но у нас до этого дело не дойдет. До
не счетных множеств переменных мы не доберемся, нам хватит счетных. И теперь я хочу сделать такую
вещь. Я хочу вот это множество гамма штрих разбить в объединение непересекающихся, разбить это
означает представить множество в виде объединения непересекающихся множества. Из чего состоят эти
множества? Это множество таких дезъемков, которые принадлежат нашему гамма штрих и содержат литерал
для хк, то есть либо хк, либо или, словами надо писать, иначе возникнет проблема, то есть содержит
или хк, или отрицание хк и не содержит хк при и больше к. То есть вот такое вот множество. Ну
то есть берем дезъюнкт, смотрим какая переменная, какой самый большой номер переменной в этом
дезюнкте. Вот это и есть то хк, которому принадлежит это множество. То есть каждый дезюнкт попадает ровно
в одно из таких множеств. Вообще не обязательно из гамма штриха, просто любой дезюнкт. Ну потому
что дезюнкт содержит конечное число литералов, все мы их считаем, что у нас переменные перенумерованы,
поэтому мы смотрим, просто находим максимальный индекс и вот его и записываем. Что? Да, может
содержаться, а, не содержит литерала, нет. Спасибо. Нет, нет, не содержит литерал. Значит, спасибо за
объяснение. На словах я сказал удачнее, просто каждым дезюнкту можно поставить максимальный
номер переменной, который в него входит. Вот это и есть то самое. Не хотелось просто эту функцию
как-то еще определять. И мы будем, план такой, мы будем доказывать по шагам индукции пока, будем
доказывать, что все дезюнкты из гамма-катова истины. Но истины где? Заметьте, что я пока не назвал
выполняющий набор. Это нехорошо. Давайте я его назову. Так, только у меня вот как-то все слегка
сбилось. Как вы думаете, можно стереть определение резолютивного вывода? Мне кажется да, потому что,
ну, я его постоянно буду повторять, то есть резолютивный вывод применение правил резолюции. В общем,
тут доска занята, но ничего очень умного тут не написано. Я не хочу далеко от этой части доски
отходить. Про системы доказательств можно было бы и стереть, они у нас появятся, но уже конкретные.
Хорошо, значит, как мы будем строить набор альфа? Значит, альфа строится опять-таки по индукции.
Альфа-ката равняется нулю, если все из того, что D принадлежит гамма-катому,
следует, что D на наборе значений предыдущих и нулю равен единице. Ну, то есть, как это объяснить
словами? Мы хотим подобрать выполняющий набор. Вот мы предполагаем, что мы уже преуспели на
предыдущих шагах. Нам нужно выбрать значение катой переменной. Ну и мы смотрим на дизъюнты,
которые содержат кату и переменную как самую старшую. У нас есть желание поставить ноль.
Если получилось, мы ставим ноль, и заметьте, что тогда мы добились своей цели, потому что если
для гамма-катого равно единице, тут сейчас нужно представлять, что я потом буду все доказывать по
индукции. Я предполагаю, что предыдущие альфа-иты гарантируют нам истинность всех дизъюнтов с
меньшими номерами. Ну и тогда и все, и делать вроде бы ничего не нужно. Но может же, конечно,
быть так, что какой-то из дизъюнтов, тем не менее, обращается на таком наборе в ноль.
Тогда говорим мы нет, ну ноль мы присвоить не можем, у нас не все гамма-каты будут истинны. Ладно,
говорим, мы присвоим тогда единицу. То есть мы присваиваем ноль, если сохраняется вот этот
наш вариант, за который мы следим. Все дизъюнты истины. Если он нарушается, мы присваиваем единицу.
И все, что я хочу доказать по индукции, что все гамма-иты истины. Заметьте, что у меня тут в этом
определении нет базы, но на самом деле вот это вот применимо, и когда предыдущих значений
переменных нет. Как присвоить значение альфа-1? Если у нас есть дизъюнт, сейчас мне база все равно
понадобится, давайте посмотрим из чего может состоять гамма-1. Заметьте, что поскольку не
выводится пустой дизъюнт, хотя бы одна переменная есть в каждом нашем дизъюнте. Вот это то место,
где используется то, что не выводится пустой дизъюнт, больше оно нигде не используется. Как может
быть устроена гамма-1? Ну это или переменная х1, или ее отрицание. Смотрите, какие-то переменные
должны быть, переменная х1 обязательно должна быть. У нас нет другого стандартного дизъюнта,
то есть переменные с большими номерами входить не могут, то есть этот дизъюнт может содержать
только х1. Ну вот что за стандартный дизъюнт, который содержит х1? Ну либо переменная, либо отрицание.
Теперь давайте посмотрим, как мы присваиваем значение альфа-1. В этом случае, если я подставлю
вместо х1 ноль, что у меня получится? У меня получится, что есть дизъюнт, который вращается
в ноль. Значит альфа-1 должен равняться единице. А в этом случае такого дизъюнта нет. Тут самое
время спросить, а почему я не рассматриваю случаи, когда гамма-1 содержит оба таких дизъюнта? Это
бы создало для меня большие трудности, потому что ни одно из двух правил применить было бы нельзя.
Что? Нет, а это смотрите, вот гамма это множество стандартных дизъюнтов. Существенно, что вот это
стандартный, вот это стандартный. Нет, тут надо другое использовать. Смотрите, свойства полноты
нашего множества. Мы добавили все, что можно вывести из исходного множества гамма. Но если мы
можем вывести х1 и вывести не х1, мы можем вывести пустой дизъюнт, применив правила резолюции.
Поэтому вот такой случай он невозможен. Ну смотрите, вот применение правила резолюции,
вот один стандартный дизъюнт, вот другой, вот третий. Это пустое множество дизъюнтов.
Но мы взяли одно множество, куда входит х и еще что-то. Другое множество, куда входит не х и
еще что-то. В данном случае это что-то пустое множество. И взяли объединение этих чего-то. Но
объединение двух пустых множеств это пустое множество. Я не дизъюнт записываю, это я записываю множество
дизъюнтов. Если у нас есть х1 и есть не х1, то из этих двух дизъюнтов мы можем вывести пустой.
Так, ну прозвенел звонок на перерыв. Давайте сейчас прервемся. В общем-то место достаточно
удачно. Я надеюсь, что с базой стало понятно. Вот этот вот тонкий момент, на который нужно
обратить внимание, что оба дизъюнта в гамма-1 входить не могут, потому что иначе бы выводилось пустое.
Ничего. Брать формулы дизъюнта из гамма и применять резолюции.
Чтобы проверять тавтологичность формулы, я буду брать отрицание и проверять,
что отрицание невыполнимо. Но теперь мне нужно как-то по формуле,
это вот булева формула, построить КНФ так, чтобы А выполнимо было равносильно тому,
что это КНФ выполнимо. У вас в курсе алгоритмов уже должны были возникнуть свадимости,
правильно я понимаю? Не? Не было еще свадимости? Ну должны быть. Хорошо,
значит я тогда буду первый, кто вам про эту идею скажет. В общем, это и называется свадимость,
одной задачей к другой. Мы хотим проверять выполнимость булевых формул, а вместо этого
будем проверять выполнимость КНФ, и нам нужно какое-то преобразование. Для текущего курса
алгоритмов, для моего курса логики, на самом деле не очень важно, насколько сложное это преобразование,
лишь бы оно реализовывалось алгоритмом. Но вот эта вот идея системы недоказательства, она возникла в
рамках теоретической информатики, где интересуется все-таки эффективностью процедур. Поэтому мы хотим,
чтобы эта свадимость была полинамеральной, чтобы по формуле за полинамеральное время мы
строили соответствующую КНФ. Почему это существенно? Потому что один простой способ построить КНФ по
формуле. Вы должны знать, вас должны были учить на первом курсе того, что называется, ну вот собственно
КНФ и ДНФ, словам вот этим. И один из основных фактов, что любая булева функция представляется в
виде ДНФ, но и представляется в виде КНФ. Вот то, что я написал, это представление в виде КНФ. Мы
должны взять конъюнцию по нулям функции, таких вот дисъюнктов, куда входят все переменные, либо
позитивно, либо негативно, в зависимости от того, какое значение принимает соответствующая переменная.
И все было бы хорошо, то есть мы просто вот по любой формуле можем написать такое представление,
но есть проблема. Проблема состоит в том, что вот эта КНФ, она называется совершенная КНФ,
она очень длинная может быть, потому что конъюнция берется по всем нулям. Вот представьте, что у вас
переменных много и нулей много, точек, в которых значение формулы ноль. Тогда у вас там будет,
ну вообще говоря, экспоненциально много членов, всего значений 2 в степени N, если на число
переменных возможных значений. И вот у вас там даже до двух степени N может дойти вот эта
совершенная КНФ. Поэтому буквально вот такое вот преобразование нас не устраивает. Нам нужно
что-то более хитрое, и это хитрое существует. Вот эта свадимость, которую я вам сейчас рассказываю,
она в следующем семестре все равно понадобится, потому что через нее в общем-то все равно все
проходит. То есть там, когда вы будете изучать то, что называется НП полнота, там почти всегда в
начале возникают произвольные булевые функции, потом из них надо сделать КНФ, а из КНФ уже
можно там все что угодно делать. Там получается такая сложная ветвящаяся иерархия, в общем,
я про это говорить не буду, но вот эта свадимость в том или ином виде вам понадобится. Может быть
вам в следующем семестре расскажут ее немножко иначе. Как ее собираюсь рассказывать я? Я собираюсь
поступить просто. Я хочу посмотреть на дерево формулы. Напоминаю еще раз, что я все время предполагаю,
мы это несколько раз обсуждали, не сказать что в каких-то деталях реализации, но мы обсуждали,
что существует эффективный алгоритм, который строит дерево разбора формулы. И вот я теперь
хочу для каждой подформулы, я хочу записать, вести дополнительную переменную. Значит у меня будут
переменные, дополнительные ZB, B подформула. То есть вот эта вот КНФ, она не будет равносильно
А, у нее даже будет другое множество переменных, но выполнимость будет равносильна. То есть мы
ослабляем условия, вот тут просто получается КНФ, которая равносильно исходной формуле, а тут у нас
равносильности не получится, но получится зато КНФ, выполнимость которой равносильно выполнимости
исходной. И как я эту КНФ буду строить? Я для каждого узла дерева разбора формулы запишу такие
КНФ. Допустим у меня B это отрицание C, тогда я запишу, оказывается плохое место на доске,
если B это скажем дезъемцы, я должен написать ZB равносильно ZC или ZD, ну и так далее. Значит
если B это, давайте вот я импликацию напишу, как самую важную для нас случай. То есть смотрите,
почему я говорю КНФ? Выписывая какие-то формулы, которые КНФ не являются. Но что мы про эти формулы
видим? Мы видим, что в них ходят всего три переменные. Это такие условия согласования.
Вспомогательная переменная ZB должна быть равна, а ведь когда эквивалентность, этот вот вixo,
это значок эквивалентности, когда эквивалентность истины, когда обе части одинаковы, равны. Поэтому
значение форму вспомогательной переменный ZB, должно быть отрицанием значения вспомогательной
переменной З c, чтобы вот такое выражение было истинным. Это вспомогательные переменные
присвоенные узлам дерева разбора, под формулой, то
есть у нас вот здесь переменные, давайте я как-нибудь сразу
напишу, тут у нас будут переменные x, а тут у нас
будут переменные x и z, то есть я добавлю переменные,
за счет этого мне станет легче строить KNF, она будет
короче.
И смотрите, все KNF, которые я здесь выписал, я не выписал
только для конъюнкции, ну точно так же как для дезюнкции,
в них ходят либо две переменных, либо три переменного.
Поэтому если я буду выписывать совершенную KNF для этих формул,
в ней будет не больше 8 членов, а на самом деле даже не 8,
они больше 4, потому что сколько нулей у таких формул
очень легко посчитать.
Ну пусть даже 8, это нам не важно, у нас есть какая-то
формула, и мы выписали для каждого узла дерево
разбора, мы выписали KNF длины там не больше 8, ну значит
у нас получилась KNF, длина которой тоже не более чем
8 раз больше, чем длина исходной формулы.
Но это еще не все, нам еще нужно добавить, вот ко
всем этим KNF нам еще нужно добавить вот такой вот дезюнк
ZA, вот это вот и будет KNF, которую я хочу построить.
Ну и теперь осталось только доказать, что построение
эффективное, я думаю, вопросов особо не вызывает, потому
что в сущности все что нужно построить дерево разбора
и по дереву разбора выписать вот эти вот KNF, но это очень
легко, то есть для каждого из случаев мы можем заранее
просто написать соответствующий KNF, просто подставлять там
нужные переменные, это ясно, что это не сложно.
Давайте предположим, что у нас исходная формула
на каком-то наборе значений переменных истина, то есть
она выполнима.
Я утверждаю тогда, что вот это KNF, истина на таком
наборе значений переменных, альфа, бета, где бета для
подформулы B, это просто-напросто значение подформулы B на
наборе альфа.
Давайте я это скажу неформально, потому что формально тут
получается какое-то переливание из пустого порожня, ее трудно
понять.
Значит, я предполагаю, что сама формула A выполнима,
я утверждаю, что вот эта вспомогательная KNF тоже
будет выполнима.
На каком наборе значений переменных?
Ну, к сам присвоим те же самые значения, а что присвоит
Z?
Ну, легко догадаться, что нужно просто взять Иксы,
вот тут у нас значения известных, переменных, и просто вычислить
значения всех под формул.
Для каждой подформулы значение будет единице, потому что
A единица.
А что будет для вот этих вспомогательных KNF?
А смотрите, это же просто правило вычисления значения
формулы по значениям под формулу.
Если мы вычисли уже вот эти вот значения в точке
альфа, то вот это значение определяется ровно такой
же формулой.
То есть, раз мы присваиваем по нашему правилу вычисления
значения, все вот эти вот эквивалентности будут
выполняться.
Они, собственно, про это и говорят.
Вот эти вот эквивалентности говорят, что мы корректно
вычислили значения под формулы B по значениям, входящих
под формулы C и D, из которых она составлена.
Ну и все.
Давайте теперь в другую сторону посмотрим.
Допустим, на каком-то наборе у нас KNF истинно.
Ну, я буду утверждать, что тогда наша формула должна
быть истинна на ограничении, то есть забывая про переменные
бета.
Ну, давайте смотреть.
Опять-таки индукции по разбору формулы будем
доказывать, что если все члены, все дизъюнкты нашей
KNF истинны, то тогда значения соответствующих вот этих
вот переменных, они должны быть ровно значениями
соответствующие под формулы на наборе альфа.
Ну, это, очевидно, для базы индукции, то есть для переменных.
Ну, для переменных деваться некуда, они принимают ровно
те значения, которые нужны.
А дальше нужно сделать шах индукции, ну шах индукции
делается очень просто, если у нас вот есть, давайте
я, у нас несколько случаев, но чтобы не мучиться я рассмотрю
один, скажем, с импликацией, а дальше все аналогично.
Допустим, мы уже доказали для меньших формул, что
ЗС равняется С от альфа и ЗД равняется С от альфа,
Д от альфа.
Ну, тогда, смотрите, раз у нас KNF вот эта истина,
у нас есть соответствующая истина, вот такое вот высказывание,
ЗС, О, ЗБ, равносильно ЗС следует ЗД.
Ну и чему равняется значение под формулой B на наборе
альфа?
Просто по определению это С от альфа следует Д от
альфа, по предположению индукции то же самое, что
ЗС следует ЗД, и вот это истина, ну раз это истина,
значит ЗБ должно равняться вот этому вот самому значению,
ну и тем самым ЗБ будет равняться значению под формулой B на
наборе альфа.
То есть опять-таки ничего удивительного нет, поскольку
мы фактически задали, вот это KNF задает правило
вычисления значения под формулу, по предыдущему,
ну и ясно, что если мы все предыдущие вычислили
правильно, то у нас нет никакой возможности уклониться
от того, чтобы правильно вычислить следующее значение,
потому что это функция, а тут стоит эквивалентность,
у нас вот эта переменная, она должна равняться значению
вот этого выражения.
Ну если там не импликация, а любая другая связка, рассуждение
абсолютно такое же, потому что от него ничего не зависит.
Вот таким вот образом мы получаем равносильность,
вот эту свадимость.
И теперь самое время вернуться к самому началу, я обещал
систему доказательств, как теперь устроена система
доказательств.
Вот у нас есть формула, ну булева формула давайте
считать, что будет тогда для нее доказательством.
Будет такой список, во-первых отрицание формулы, во-вторых
которая построена по отрицанию, в-третьих, вот это вот резолютивный
вывод, противоречие из конъюнктов, из дизюнктов, прошу прощения,
вот такой список, можно сказать, формулы, он и будет доказательством
тавтологичности.
Почему?
Потому что, смотрите, если такой список существует,
пусть ему нашелся корректность, ну тогда вот это резолютивный
вывод показывает, что КНФ, из которого делается этот
вывод, невыполнимо, сводимость наша говорит, что тогда отрицание
F невыполнимо, значит F тавтология, и наоборот, предположим,
что F нет тавтологии, тогда отрицание F выполнимо, тогда
выполнимо и соответствующая КНФ, которую мы сейчас построили,
ну тогда какой бы вы резолютивный вывод не написали, где-то
должна быть ошибка, то есть пустого дизюнкта вы не
получите по корректности исчисления резолюции.
Вот, собственно, и все.
Вот такая вот система доказательств.
Она выглядит сложнее, чем исчисление высказываний.
Почему?
Потому что мы отказались от идеи моделировать человеческое
рассуждение.
Люди так не рассуждают.
Люди не строят вот эту КНФ по отрицанию какого-то
утверждения.
Это довольно безумное занятие.
Но если говорить о компьютерах, то есть очевидный плюс
у резолюции перед исчислением высказываний.
Вот в исчислении высказываний, если вам дана формула, вы
хотите построить ее вывод.
Есть такая проблема.
С чего этот вывод начинать?
Ну для конкретных формул я вам говорил разные добрые
идеи, с чего стоит начинать, но это конкретная короткая
формула, а записана длинная формула, про которую ничего
не понятно.
С чего начинать?
Неясно.
А здесь у нас же дизъюнктов вообще конечное количество.
Поэтому здесь, если не заботиться об эффективности, можно
вообще начинать чего угодно.
Вот есть у нас набор дизъюнктов.
Давайте искать пару, к которым можно применить
резолюцию.
Применим резолюцию.
Дальше у нас набор увеличился на единицу.
Опять смотрим, можно ли применить резолюцию.
Если можем, применяем и расширяем набор.
В какой-то момент окажется, что мы уже ничего нового
построить не можем.
Применение резолюции дает только те дизъюнкты, которые
так уже есть.
В этот момент мы говорим, все, множество совместно,
потому что пустого мы уже не выведем.
А если появился пустой, мы говорим, отлично, оно
несовместно, мы доказали, вывели пустой дизъюнкт.
То есть в этом смысле исчисление резолюции, оно и было придумано
в конце 50-х годов, когда люди стали задумываться
об автоматизации доказательств.
Потому что здесь вроде бы, ну тогда они очень заботились
о том, что может получиться очень длинно.
Это странная вещь, но когда компьютеры были очень слабыми,
8 килобайт было пределом мечтаний, люди легко рассуждали,
ну давайте будем перебирать все наборы значения тысячи
переменных.
Это никого не смущало.
А сейчас как-то люди начинают писать в репи, ну да, вот
от тысячи не перебирать, от 500 может быть.
А тогда как-то это никого не волновало.
Потому что это все было так в общих рассуждениях.
Но тем не менее, идея оказалась очень правильной.
И вот за остаток лекции я хочу объяснить, уже практически
ничего не доказывая, просто рассказать, это полезно
понимать, соотношение между исчислением высказываний
и исчислением резолюции.
Вот у нас есть система доказательств, построенная на резолюциях,
есть система доказательств, построенная на исчислении
высказываний.
Ну лучше в каком смысле?
Обычно сравнивают по длине доказательств.
Если есть доказательства в одной системе, насколько
длинным или коротким может быть доказательство
в другой системе.
Так вот, с такой теоретической точки зрения, исчисление
высказываний намного лучше.
По резолютивному выводу мы можем построить доказательство
f в исчислении высказываний, которое будет иметь полинамеральную
длину.
Ну даже, по-моему, линейную.
И, в общем-то, идея более-менее понятная, потому что мы,
конечно, можем вывести то, что у нас используются
правила резолюции, но мы можем вывести соответствующую
тавтологию, что из конъюнции двух таких формул, импликация
значит то, что получается в выводе.
Вот этот переход мы тоже можем обосновать, более-менее,
построив доказательства равносильности и выполнимости.
Это надо подумать, как правильно сделать, но, в принципе,
возможно.
Тогда получится, что мы, если у нас есть вывод пустого
дизъюнкта, мы как бы из отрицания f получаем противоречие.
А вы помните, когда я доказывал теорему о полноте, это наш
основной прием.
Если мы хотим доказать f, давайте из отрицания f выведем
противоречие, тогда, пользуясь средством исчисления высказаний,
в два шага получим доказательство нашей формулы.
Вот примерно такая идея, ее, конечно, нужно оформлять,
там все шаги делаются, по-моему, все-таки квадратичная
будет свадебность, я погорячился, что линейная, но неважно.
Подробности я рассказывать как раз не хочу, желающие
могут подумать, как это сделать, это интересно,
но так технически не совсем просто.
То есть, казалось бы, исчисления в высказывании намного
лучше, но на самом деле исчисления в высказывании
в реальных программах, которые проверяют автологии,
не используются.
Я не знаю таких программ, и непонятно, как их писать.
А исчисления резолюции используются, и используются настолько
эффективно, что в последние годы полно публикаций
такого вида.
Вот есть какая-то комбинаторная задача, сложная, которую
непонятно, как решать.
И человек пишет, ну мы же знаем, что выполнимость
KNF проверяется легко, давайте нашу задачу сведем к выполнимости
KNF и проверим выполнимость KNF.
При том, что все знают, это пишут люди, естественно,
достаточно грамотные, все знают, что в теоретической
точки зрения выполнимость KNF трудная задача.
И на самом деле исчисление резолюции не только в этом
смысле слабее, но еще вот в каком смысле.
Для исчисления в высказывании мы не знаем тавтологии,
которые доказываются только очень длинно.
Мы просто не знаем.
Может их и нет.
Никто не знает.
А для исчисления резолюции такие тавтологии можно
написать.
Вот можно написать тавтологию, у которой любое опровержение
резолюциями будет экспоненциально длинным.
При этом, как экспоненциально, два в степени корень издлина
формулы.
Не длина формулы, а корень издлина формулы, но все
равно экспоненциально.
При этом вывод в исчисление высказываний для этой тавтологии
на самом деле короткий, полиномиальный.
Это тоже можно доказать.
Поэтому в теоретической точке зрения исчисление
высказываний намного сильнее, это все знают, все так и пишут
во всех статьях.
Но в других статьях пишут, что мы знаем, что проверять
легко выполнимость КНФ.
И это не то, что там, это просто в моей практике тоже
был такой случай.
У меня был студент, который решал задачу из теории
игр.
Мне нужно было делать довольно сложный перебор комбинаторный.
Он написал программу.
Но там заведомо перебор был большой, было ясно с
самого начала.
Но оно у него работало совсем медленно, там нужно было
для разных графов делать, ну вот он там буквально с
графами с 5 вершинами, с 6 вершинами, с 6 уже не мог
справиться.
И тут он вспомнил, как ни странно, что ему рассказывали
про исчисление резолюции на втором курсе.
Он обрадовался, посмотрел сети, нашел программу, которая
проверяет выполнимость КНФ, запустил ее и все стало
работать 600 раз быстрее.
То есть то, что у него требовало там нескольких дней, буквально
в минуты у него просто вычисляло.
И далеко он конечно не ушел, там на графах с 7 вершинами
все равно это все перестало работать.
Потому что там действительно очень большие объемы, там
уже ничего не спасает.
Но тем не менее, как такое вообще возможно?
Это животрепещий вопрос.
То есть есть два вопроса, в которых теоретическая
информатика, теория, она полностью проигрывает
практики и пока не очень понятно, как с этим быть.
Это вот во-первых проверка выполнимости КНФ, а второе,
но это вы все знаете, это вот эти нейронные сети,
которые по непонятным причинам что-то хорошее делают, хотя
не должны.
Нет никаких оснований считать, что в многомерном пространстве
так уж градиентные методы могут дать хоть что-то полезное.
Но дают.
Почему?
Неясно.
У нас нет теоретических средств для ответа ни
на один, ни на другой вопрос.
Откуда взялись хорошие программы, откуда взялись нейронные
сети, я думаю вы отчасти представляете, но откуда
взялись хорошие программы для выполнимости КНФ, я вам
сейчас расскажу.
У меня еще пять минут есть.
Эксплуатировалась очень простая идея, что люди любят
соревноваться.
Двадцать лет назад начаты были чемпионаты SAT-солверов,
то есть программ, которые проверяют выполнимость
КНФ.
То есть собираются люди, выдают исходный код на Си,
скажем.
Я не помню, сейчас может быть это изменилось, в начале
это было Си, и по-моему Си плюс плюс разрешалось.
В общем какие-то ограничения, чтобы у организаторов есть
совершенно конкретные трансляторы, они используют один и тот
же транслятор для любого кода, формулы описываются
некоторым стандартным образом, это организаторы тоже объявляют,
что это формат задания формул, и дальше запускается
он на одном и том же компьютере, то есть соревнования именно
алгоритмов, то есть железо абсолютно одно и то же.
Ну и кто быстрее, разные виды, как в лёгкой атлетике
есть разные виды, и тут тоже есть разные виды.
На случайный КНФ, на КНФ, которые получаются вот такой
сводимостью, то есть берём какую-нибудь булевую формулу
замысловатую, сводим и смотрим, что там получается.
На КНФ, которые приходят из индустрии, это уже в более
поздние годы, коммерческие люди этим заинтересовались,
и они стали для соревнований просто выдавать, то есть
у них есть какая-то может быть даже секретная вещь,
которую они хотят проверить, но когда это превращается
в КНФ, восстановить, что там было в начале достаточно
сложно.
Вы же понимаете, перенумеровать какой-нибудь случайной
перестановкой, перенумеровать переменной, кто там разберётся,
о чём вообще речь.
Какая-то длинная там с миллионом переменных формулы.
Ну опять-таки соревнования на тех КНФ, про которые
люди умеют доказывать, что резолюции работают плохо.
Вот в общем много.
Вы можете найти сайты этих чемпионатов и посмотреть.
И поскольку это происходит 20 лет, а люди всегда, когда
хотят выигрывать, эти программы бешено совершенствовались.
Вот мой студент использовал чемпионскую программу 2014
года, это было года три назад, и она уже работала очень
хорошо.
Просто более поздние программы, они уже не открыты, они
представят коммерческий интерес, их просто так
не выдают, то есть можно купить их, но тогда они не
так дёшево стоят.
Ну и в общем неудивительно, потому что сил вложено
в создание этих программ огромное количество, это
как любой вид спорта, чтобы становиться чемпионом,
нужно прикладывать огромное количество усилий, тренироваться,
что-то делать, но что существенно, у меня осталось буквально
две минуты, в основе практически всех этих программ лежат
резолюции, точнее комбинация резолюций и очень примитивная
идея частичного разбора переменных.
Вот смотрите, у нас есть набор переменных, давайте
разбирать по первой переменной, х1 равно нулю и х1 равно
единице, подставим, что-то у КНФ уйдёт, потому что
если х1 равно нулю и входит х1, то просто вычёркиваем
этот литерал, а если не х1, то этот литерал единичный,
мы прям весь дизюнкт вычёркиваем, то есть КНФ так слегка
упрощается, мы так разбираем, разбираем, получается
такое дерево разбора, что существенно, что когда
происходит рекурсивный возврат, как в моём доказательстве
полноты, если мы уже разобрали одну ветку и другую ветку
и пришли, что они невыполнимы, мы можем найти, применить
резолюцию, мы можем вывести новый дизюнкт, то есть получается
так, что такой комбинированный алгоритм, мы делаем разбор
частичный, каждый раз, когда делается рекурсивный
возврат, мы добавляем дизюнкты, соответственно, у нас больше
проблем, то есть у нас ветвление чаще обрывается, чаще происходит
рекурсивный возврат, больше дизюнктов, то есть такой
бутстрепен, и эта идея удивительно хорошо работает, понятно,
что в чемпионских программах есть ещё и много чего, но
вот эта идея есть всегда, с неё всегда начинают, скажем,
на случайных КНФ она сама по себе очень хорошо работает,
как ни странно, но на не случайных надо что-то делать, в последние
годы уже нейронные сети там запускают, то есть вот программа
работает-работает, там же очень много свободы, у нас
выбор переменной, очередной для ветвления, он ничем не
ограничен, и вот сеть изучает, как она ветвилась, насколько
удачно получалась, и на этом сама обучается, прям на
собственной работе, и говорят, что вот чемпионские программы
на этом что-то выигрывают, вот современно уже последних лет,
ну вот примерно так, то есть удивительным образом
в решении задачи выполнимости помогла не наука, а неистребимое
желание людей побеждать соревнований, ну вот на сегодня
всё.
