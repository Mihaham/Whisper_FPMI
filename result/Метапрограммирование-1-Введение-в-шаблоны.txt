Теперь, надеюсь, хорошо. Как и было анонсировано в прошлый раз, мы будем продолжать с шаблонами разбираться.
Вот просто механика шаблонов. Сейчас там какие-то выяснения. Давайте чуть-чуть подождем.
Все, да? Отлично. Вот. Я не могу собраться с мыслями, если хотя бы еще один человек параллельно со мной говорит, поэтому, пожалуйста, не делайте этого. Окей? Спасибо.
Ну, это абсолютно у всех так работает, мне кажется. Давайте идти. Мы будем повторять паттерны в первую очередь, потом пойдем к шаблонам.
Эти паттерны здесь постольку, поскольку они исторически здесь появились, о чем я вроде в прошлый раз сказал. Есть замечательная книжка Александреску.
Сегодня вечером я выложу репозиторий, там все ссылки будут. Где он, соответственно, рассуждает о том, как всякие разные паттерны в шаблонах реализовывать и получать от этого профит.
Ну или, наоборот, можно сказать, он рассуждает о том, как использовать шаблоны, чтобы с этими паттернами было удобнее работать.
Ну, давайте просто сначала повторим подряд все сплошняком паттерны. Вот за полчаса, я надеюсь, мы управимся. Вы же умные и, конечно же, их знаете уже давно.
И, конечно же, вы их не могли забыть. Начнем с видов. Там три категоризации, они мутные, ничего особо не значат, там одно сюда запихнуто, другое туда.
Ну, так сложилось исторически. Порождающие структурно и поведенческие. Ничего нового. Поехали с порождающих.
Фабричный метод. Еще с курса ТП я заметил, а еще с ГОСов, а еще с экзамена по ТП, что у людей нет понимания, что такое фабрика, что такое фабричный метод, почему там вообще два разных паттерна.
Давайте про фабричный метод. Это один метод. Вот то, что здесь какой-то диалог Windows Box, все это не имеет отношения к фабричному методу.
Вот Create Button. Вот это фабричный метод. Все остальное это декорация.
Кто-нибудь может объяснить нам в двух словах, зачем вот этот Create Button и в чем состоит, собственно, паттерн?
Смотря на эту диаграмму. Она для вас не должна быть новой. Правда, Вить?
Дебе черная кнопка, белая кнопка. И там хочется во время исполнения понимать.
Кнопки, кнопки они везде одинаковые, поэтому нам не нужно...
Не хочется явно вызывать конструктор объектов. Хочется иметь метод, который создавал бы его. Возможно, если конструктор какой-то нетривиальный, или нужно создать объект в системе, то нужна вот эта вот фабрика.
Что-то вы такое говорите, оба близко к правде, но вот беда.
Это опять общие слова. Вот вы сейчас описываете просто, что есть такое понятие как Interface.
Если мы не хотим иметь изолированный объект, если мы хотим иметь доступ к объекту тока в системе, то мы не должны уметь создавать объект через конструктор.
Нет, это ты описываешь... Похожий на этот паттерн по названию штуку, но абсолютно отличающийся от него существом.
То же не то. Это все трюки, которые появились позже, чем вот этот паттерн, который не имеет отношения к ОП вообще никакого.
И это трюки скорее как C++-у специфичные, что мы делаем конструктор приватным, делаем глобальную функцию, create что-нибудь.
Ну, такое видели уже, make shared. Вот это вот некоторые люди называют фабричным чем-то там.
Но мы не об этом сейчас. Это просто неловкое совпадение, что это называется одним и тем же словом.
Ну окей, я не услышал ответа, который я хотел услышать, а он очень простой.
У вас с консоли пользователь ввел чиселку 1, 2, 3, 4 или 5. Вы хотите в зависимости от этой чиселки создать разного наследника интерфейса button.
Как это сделать? Сделать switch. Switch по чиселке. И в зависимости от этого делать либо new windows, либо new HTML button и все работает.
Чем этот подход плох?
Больше цифр, больше свичей.
Ну как бы да, но почему это плохо-то?
Блин, захотел новую кнопку добавить, иди дописывай свич-кейс новый. В чем проблема?
Можно перекомпилировать новые функции, придется за них все перекомпилировать?
Это тоже не особо большая проблема. Я предлагаю сейчас думать об OOP-абстрактном, а не конкретике плюсов, где с перекомпиляцией.
Это тоже вообще-то не теряется.
У вас есть место в коде, где написан свич, который ответственен за то, чтобы понять, в зависимости от ввода пользователя,
что делать, какую кнопку создавать.
Мы кнопку новую добавляем, и в десяти местах свич должен изменить.
Ну, хорошо, давай сделаем функцию, в которой этот свич сохраним, и в одном месте придется менять.
Не чувствуете? Беда!
Но я этого ожидал, в принципе, поэтому все это здесь и есть.
Тут просто есть очень простая истина, которая не только к OOP относится, не только к этим паттернам,
и вообще некоторые наблюдения, что хорошее понимание этих паттернов, хоть не позволяет их использовать на практике,
потому что, ну, нафига, но позволяет на практике другие вещи с ними лучше справляться.
Вот о чем я всем говорю сейчас.
Код расширяемый должен быть. У вас есть библиотека одна, в которой интерфейс-батон,
а дальше есть несколько библиотек с HTML-батоном, Windows-батоном и прочим-прочим.
Есть библиотека, которая там, ну, это все какой-то юзер, пользовательский интерфейс, кнопочки.
Вы хотите ваше приложение под плойку адаптировать, но вот этот код под плойку
он вообще никак не должен упоминаться в вашем основном коде.
Почему? А потому что, да, если у вас какой-нибудь open-source-проект,
то вы должны строго разделить его на две половины.
Привет! Open-source-ная база и все, что специально для плойки, ни слова вообще не должно упоминаться
в вашем open-source-ном этом, ну, иначе вас засудят мгновенно.
Поэтому мы не можем просто сделать там PlayStation-батон, его инклюдить в основном коде программы
и в свече создавать новый PlayStation-батон, вот здесь вот.
Нам нужно, чтобы можно было создавать новые вот эти вот виды кнопок,
в зависимости от пользовательского ввода, не меняя старый код вообще,
не упомяная никак конкретных вот этих вот наследников интерфейса в общем коде.
Ну и, в принципе, это правильный дизайн, что вы хотите систему расширить,
только расширить, да, а вам почему-то старый код менять надо.
Вот это признак плохого дизайна, вообще говоря.
Расширяемость должна без изменений каких-то там вообще других мест,
ну, по там разным причинам, это, конечно, само по себе наблюдение бесполезное.
Ну вот, поэтому что мы делаем? Мы делаем другую иерархию,
ну, вернее, тут уже какая-то иерархия была.
Вот и кнопку создавать, оказывается, нужно, ну, не где-то в абстрактном месте в коде,
а вот именно в рамках этой иерархии, в зависимости там от чего-то.
Ну и вам нужно просто добавить метод, который возвращает button.
И вот в базовом классе диалог там, ну, собственно, весь код, да, вся логика,
что вот вы там с каким-то диалогом работаете, кнопку нажимаешь, что-то происходит,
оно зашито здесь, но это как бы абстрактный класс.
Он, когда ему нужно создать кнопку, ну, тут я простой пример привел,
что в зависимости от циферки на консоль введён, на деле же, конечно же, не так,
в зависимости от какой-нибудь конфига или платформы или ещё чего-нибудь такого, не важно.
Но вот в какой-то момент диалогу нужно создать кнопку.
Он не создаёт настоящую кнопку, а просто вызывает виртуальный метод.
И всё. А дальше оказывается, что на самом деле в объект такого типа мы никогда не создаём,
а создаём объекты типов наследников, которые живут уже в ваших библиотеках
для конкретных платформ, для там Windows, для Web.
Перегружаете там этот метод, и в нём создаёте кнопку нужную для нужной платформы.
Понятно ли сейчас стало? Я чувствую, что нет.
Ещё раз, можно оточнить как диалог, вот это диалоговое окно и батон, как они связаны?
Связаны следующим образом. Диалогу хочется в какой-то момент создавать кнопки.
Диалог хранит кнопку? Ему хочется создать кнопку.
Но у него не хранится. Мы создали новый диалог, у него пока кнопок нет.
В какой-то момент по ходу своей работы он захотел создать новую кнопку.
Может в конструкторе даже, это не проблема. Но как ему её создать?
Хранится как бы да, хранится. Как-то. По интерфейсу главное что?
Абстрактную кнопку хранит, по интерфейсу у нас ОП.
А вот по интерфейсу экземпляр создать нельзя, нужна какая-то конкретная кнопка.
Мы говорим, что не он решает, какую кнопку создавать.
Он это делегирует через виртуальный метод своим наследником.
И вот этот виртуальный метод, который создаёт кнопки, он и называется как бы фабричным методом.
ОК. То есть вы можете новую платформу сюда прилепить, просто отнаследовав диалог, отнаследовав кнопку.
Вот внаследовании диалога вы ровно одну функцию кастомизируете, create button.
То есть минимум усилий прикладываете к тому, чтобы можно было, чтобы расширить эту систему.
То есть как? Switch был заменён на виртуальный вызов.
Это в принципе общая схема всего вот этого замечательной бодяги с паттернами и ООП подходом.
Ну кто-то из вас, я посмотрел по чату, оказывается ходил ко мне много лет назад на ООП.
На ТП, извиняюсь, на ТП.
И там я тоже самое примерно загонял, поэтому очень странно, что никто не помнит.
Но с другой стороны, 4 года прошло.
ОК. Есть ли какие-то вопросы про вот это вот? Вы поняли идейно, что происходит?
ОК. Дальше начинается... А, ну это то же самое, да?
Да, это то же самое, но с абстрактными какими-то разметками.
Что у нас есть какая-то иерархия тех, кто хочет создавать объекты.
Есть какая-то иерархия объектов.
Ну и вот мы за счёт добавления виртуального метода createProduct умеем его кастомизировать на следниках.
ОК. А вот это фабрика. То есть до этого была не фабрика.
Был фабричный метод. А теперь фабрика.
Где мы говорим, что мы уже не будем просто в какую-то существующую иерархию типа диалогов вшивать новый метод,
когда нам понадобилось кнопки создавать.
А мы прямо отдельную специальную иерархию сделаем для создания кнопок. Да?
WinFactory, GUI Factory, MacFactory.
И в этой иерархии даже может быть несколько разных функций создания чего-то.
Тут есть для баттона, для чекбокса. Можно то создать, можно другое.
Ну и на чём-то всё.
Теперь вы в коде своём прикладном просто прокидываете разным подсистемам вот эти объекты в факторе.
Ну, прокидываете по интерфейсу, конечно же.
И теперь ваш прикладной код может просто у этого интерфейса позвать метод какой-то создай мне чё-то
и получить некоторую абстрактную кнопку или абстрактный чекбокс, не зная какая там имплементация.
Важный вопрос.
Давай.
Вот все эти объекты, которые создаёт абстракт фабрики.
Может вопрос глупый, но сами в фабрике хранят в себе объекты, которые они создали?
Нет.
Их роль – это быть просто диспетчером вызовов, грубо говоря.
Мы хотим диспетчеризовать вызов конструктора, по сути.
Ну а потом забыть, какой конкретно объект получился после этого вызова, зная ли что получился,
что есть интерфейс-батон, которому этот объект удовлетворяет.
Ну и вот как-то так это и работает.
Вот эта диаграмма в целом вам понятна же, правда?
Я искренне надеюсь, что я сейчас нудные вещи, которые так понятно рассказываю, кроме вот этого вот…
Можно вопрос?
Да.
То есть, предположим, мы сделали какую-то привожуху, которая вот сейчас мы под Windows ее делаем,
и мы хотим всегда создавать одинаковые окна под Windows.
Да.
А потом мы когда переедем на Mac, мы хотим просто заменить вот эту фабрику,
и у нас автоматом начнут создаваться окна под Mac.
В этом идее?
Да, не меняя старый код.
Но тут есть еще одна важная деталь.
Что мы пишем вообще-то на плюсах, а не на джаве.
И нам такой подход, ну нафиг не сдался, если честно.
Кто может догадаться, почему?
Почему мы не будем с помощью ООП, интерфейсов и вот этого всего, вот этой машинерии,
никогда в жизни не будем под разные платформы адаптировать приложения?
Мы можем цппшник подменить?
Ну раз, цппшник можно, два, можно эти FDF, да, там с линковщиком и цппшником подменой.
Три можно там, ну вообще как-нибудь шаблонами и в констекспроме обойтись.
Но почему мы всем этим страдаем?
Потому что это все-таки Compel Time.
Ну подростной системой.
С целью какой?
С целью какой?
Почему мы не можем все это обернуть?
Ну да, вот ключевое Compel Runtime.
В Runtime дорого.
Если у вас все приложение, ну как бы, приложение, как правило, оно часто стучится в операционку, правда?
Вот и часто нужно как-то взаимодействовать с внешним миром.
По крайней мере, на моем опыте я как бы сервера не особо пишу.
Больше клиента.
Ну и если это стучание в операционной системе у вас запрятано за десятью слоями вот таких вот интерфейсов и виртуальных вызовов,
то первого вы хорошего не получите.
У вас будут постоянные промахи по кышам и прочее.
Поэтому в плюсах мы по-другому делаем.
Но это Джава.
Мы представляем, что мы как бы пишем на Джаве.
И получается вот так.
Что такое промах по кышу?
Что такое промах по кышу?
Смотри, у тебя на процессоре от процессора до оперативной памяти это как сходить за пивом в соседний город.
По времени.
Для масштаба, да?
А вот от процессора до кэша маленького кусочка типа оперативной памяти,
но находящийся прямо в чипе процессора, это как в соседний ларек сгонять.
Да.
А вот если ты просто какую-то инструкцию на процессоре выполняешь,
что это там просто холодильник, открыть и достать пиво.
Ну по таймингам, да?
Что вот в оперативную память ходить это там в другой город,
а просто инструкцию на процессоре выполнить.
Это до холодильника дойти.
Очень плохо будет, если тебе там нужно сложить десять чисел,
и ты на каждое из этих сложений сначала там типа сходил два раза в другой город,
потом к холодильнику подошел, все.
Теперь еще там два-три раза в другой город, чтобы достать новые числа,
а потом ну быстро их сложилось дойдя до холодильника.
Поэтому в процессорах есть кэши, они вот прям внутрь процессора зашиты,
работают так же как оперативная память, но прозрачно для вас.
И если вы пишете ООП-код, где куча виртуальных вызовов,
то эти кэши вас будут очень ненавидеть.
Ну давайте потом к этому вернемся, возможно, я не знаю.
А именно промах.
А, промах что такое?
Ну ты попытался получить доступ к памяти, которая сейчас не загружена в кэш.
Почему такое могло произойти?
Ну а тебе реально нужна новая память, с которой ты раньше не работал,
поэтому откуда она в кэше может взяться?
Промах, то есть это попытка обратиться к памяти?
Попытка к доступу, и ты типа, ну как бы вот, интуиция такая,
из доска для дарца это кэш, все остальное вокруг памяти.
Ты такой стреляешь, попал, не попал.
Ну, короче, да, мне казалось, это термин очень широко известный.
Ну да.
Ну если какие-то…
Нет, возможно я…
Окей, ну это не проблема.
Если какие-то слова вас смущают, обязательно задавайте вопрос.
У нас должен быть здесь диалог, а не монолог меня.
Так будет эффективнее, мне кажется.
Можем вернуться к фабричному?
Давай.
Давай.
Ты приводил пример, когда мы принимаем вводы от пользователя…
Да, да, да, да.
Вот я ровно про это хотел сказать.
Задержи вопрос в голове, вот я к этому подводил, но мы отвлеклись.
В целом, вся вот эта машинерия фабрик и фабричных методов,
и фабрик абстрактных, она нужна ровно для того, чтобы в рантайме
диспетчеризироваться по тому, какой конструктор запускать.
Например, если вам в зависимости от ввода пользователя
разные сущности создавать, когда вы в зависимости от платформы
что-то делаете, то это не нужно делать в рантайме.
Вы до рантайма знаете, до какой платформы вы релизите
свое приложение на плюсах.
На джаве у вас один джарник, он должен везде работать, и вот так вот.
Это хороший пример для джавы и плохой пример для плюсов,
потому что на плюсах так никто писать не будет.
Хороший пример для плюсов – это спавнер в Майнкрафте.
Все играли в Майнкрафт.
Там спавнер, можно у него яичком кликнуть, он будет спавнить
либо коровок, либо свинок, либо зомби.
Как думаете, как они определяют, какого моба спавнить?
Потому что моб в Майнкрафте – это просто такая же кнопка, по сути.
Есть интерфейс, там моб, его наследуют, есть зомби-класс,
есть класс свинка, и вот.
Как в зависимости от того, каким яичком кликнул пользователь,
спавнить разных мобов?
Но ровно так, давайте хранить абстрактную фабрику, вот такую.
Прямо внутри спавнера.
При клике яичком каким-то мы у яичка спросим,
а какая фабрика к тебе привязана?
А он говорит, а вот эта фабрика. Ее сохраним в спавнер.
А дальше спавнер будет звать фабрику.
Эй, создай мне нового моба.
И вот теперь мы написали класс спавнера, который ничего не знает
ни про зомби, ни про коровок, ни про кого.
Он просто работает с абстрактными фабриками мобов, и все ок.
Вот. То есть хорошее типа применение вот этого всего,
это когда у вас строго в рантайме все происходит,
ну а это обычно в зависимости от ввода из сети,
или в зависимости от ввода пользователя.
А вот этот пример, ну такой себе.
Давай вопрос, если на него не ответил еще.
Мне кажется, нет.
Вот, например, у тебя был свитч, и в зависимости от цифрки
мы рано нахнулся за дверь.
И ты сказал, что фабричный метод,
это мы от этого свитча избавимся.
Да.
Я пока не чувствую, как мы избавились.
Окей.
Куда мы свитч тянем сейчас?
Свитч мы заменим на вызов виртуальной функции.
Хочет распилить мир на много маленьких библиотек,
которые друг друга зовут, но как бы никуда не вылезают,
не вылезают в свой код. Вот.
В Compile Time можно вспроходить эту виртуальность или что?
В Compile Time пока вообще не говорим.
Мы пытаемся понять про паттерны и вообще вот это вот.
Все сломалось?
Да все нормально, живем.
Назад он включился, назад он с нами пишется.
Это что-то странное было.
Окей.
Давай подзапись еще раз про свитч с цифрками.
Свитч с цифрками.
Я хотел сказать, что пример свитчом с цифрками,
он, конечно, все равно...
Ну, невозможно его решить только инструментами ОП,
но во всяком случае где-то в коде нужно написать,
в зависимости от ввода пользователя,
что должно происходить.
Такая табличка все равно должна быть.
Ну, в этом месте мы тоже можем придумывать, конечно,
что-то очень хитрое, например,
сделать возможность регистрироваться разным модулям нашей программы,
говоря на какую цифру они что возвращают.
Ну, какие-то такие вещи.
Но пойнт всего этого в общем и целом в том,
что после того, как вы вот этот механизм
какого-то диспетчеризации
по вводу пользователя сделали,
какой-то...
Я говорил, что я не могу думать,
когда кто-то еще говорит параллельно.
Вот у меня просто мысли вылетают.
Все? Хорошо.
Пойнт чем? Есть какая-то диспетчеризация
по данным, которые вел пользователь,
а дальше мы летим по виртуальным вызовам всяких интерфейсов,
и все абстрактно.
И в какой-то момент мы вталкиваемся в то,
что нужно что-то создать, какой-то объект.
Ну вот конструкторами виртуальными не бывают,
поэтому мы называем фабричный метод
и получаем разные объекты,
в зависимости от того,
кто там...
Никогда не делайте об общем идеологии, это ошибка.
Да.
Вот проходящий мимо человек тоже согласен,
что все примеры, в принципе, которые здесь будут конкретные,
они фигня, если честно.
Я на практике никому так не посоветую делать.
Ну вот проблема Апатора,
потому что их объясняют,
это вообще непонятно.
Да, а потому что все какие-то, более-менее здравые примеры,
они слишком сложные.
Мне нравится пример со спавнером в Майнкрафте.
Вот это вот просто лучший,
он абсолютно понятный.
Только непонятно, откуда изначально берется вот это вот фактори,
и кто там говорит,
какого предмета, какая фактория, какого моба.
Ну вот да.
Да, какие-то там
с конфигов что-то читается,
как-то оно инициализируется,
все равно где-то там свич в итоге кроется.
Но как бы...
И вся идея это отталкивает свичи как можно дальше.
Возможно, где-то полностью от них избавляться.
Давайте дальше идти,
потому что мне наскучило немножко.
Но если все еще какие-то вопросы есть.
Нет.
Хорошо.
Да, почему про все это говорим?
Вот это вот писать, это шлютая морока, правда?
Ну, лютая просто.
Куча классов надо делать.
Куча какой-то фигни писать.
И все это сводится к тому, чтобы просто
в каждом из вот этих вот конкретных
классов
написать типа
вызов new что-то там.
То есть просто конструктор вызвать.
Да.
Да.
Да.
Окей.
Абстрактная фабрика пишется
с нуля,
когда мы поняли, что нам в будущем
в приложении понадобится как-то
диспетчеризировать
создание разных объектов.
Например, когда мы спавнер в
Майнкрафте делаем, мы заранее продумываем систему
и говорим, ага, мы будем фабрики мобов
делать, и через них будем конкретных мобов
уже выбирать и спавнить.
Фабричный метод
обычно вписывается уже
постфактум. У вас есть какая-то иерархия,
и внезапно оказалось,
что в этой иерархии нужно создать какой-то
новый объект.
Какую-то новую фичу прикручивать, и нужно новый объект
создать. В этот момент вы в иерархию
вписываете один метод
виртуальный, который возвращает
по интерфейсу тот объект,
который вам нужно создать.
А в наследниках
реализуйте уже конкретные
вызовы
конструкторов. Вот так вот.
То есть я правильно понимаю, что
в идеале фабричный метод
должен был бы быть абстрактной фабрикой,
а зачем?
Нет, нет, нет, не надо так на это
смотреть. Иногда вот так удобно.
Иногда вот так удобно.
Но в большинстве случаев и то, и другое
полная фигня, и писать код вы будете по-другому.
Но некоторое абстрактное
понимание вот этого, оно полезно,
и вы постфактум взглянете
на свой код и такие, ой,
а я же изобрел фабричный метод. Какой
молодец. Или ой, я же изобрел
абстрактную фабрику. Класс.
Да, про что я говорил?
Вот это писать Марокко,
и анонс того, что будет в будущем.
Мы сделаем шаблон,
который вам просто по списку типов,
ну просто через запятую перечисляйте,
какие вот там есть.
Есть там интерфейсы button и checkbox.
Перечислили список.
Дальше есть у них конкретные
наследники. Mac button, Mac checkbox.
Тоже перечислили в списке.
И win button, win checkbox.
Тоже перечислили. Три списка есть,
в один шаблон все это запихиваете,
получайте всю эту иерархию.
Вот все, что здесь на картинке нарисовано,
мы сгенерируем шаблонами.
А реализация?
Она одинаковая везде.
В этом и point.
Вот в этих методах, в этих реализациях
вы не делаете ровным счетом ничего,
как сделать new Mac checkbox,
new Mac button, ну и return
new Mac button. Вот все.
В этих классах
ничего нет.
Это все boilerplate, тупейший.
Поэтому Александреску придумал,
как его автоматизировать.
Но лучше бы не придумывал, потому что на практике
такое конечно же не стоит использовать.
Всегда можно придумать что-то более гибридное,
современное, используя не только
ООП подход.
Окей, давайте ехать дальше, пожалуйста.
Мы уже столько времени здесь.
Целый час. Это провал.
Едем дальше.
Строитель. Ну про строитель вы должны мне рассказать,
потому что кто-то уже говорил, что такое строитель, зачем он нужен.
Ну да,
по частям собирает целый объект.
То есть мы хотим
какой-то сложный конструктор
с двадцатью аргументами
или какой-то даже сложный вызов функции
с двадцатью аргументами
взять и разбить на кусочки.
Ну и в этот момент мы что-то такое изобретаем.
У нас у билдера есть
какие-то сеты
или ады, ад что-нибудь,
сет что-нибудь. И каждый из них
в свою очередь возвращает обратно такой же билдер.
Ну вы такое, надеюсь, видели.
И просто вызывается функция
makeBuilder.add что-то,
.add что-то, и вот так подряд пишется
все эти ады. Вот это максимально
прикладной паттерн, но такой ОП отсюда
выкинуть надо, а вот так очень полезная
штука.
Если навернуть шаблонов,
еще более полезно.
Но об этом потом.
Вот, а что здесь нарисовано
с ОП-шной такой точки зрения?
Чем это в ОП вообще было изначально придумано?
Чтобы разные системы
потихоньку инициализировали
какой-то крупный объект.
Поняли, что я сказал?
Вот у вас три библиотеки, каждая из них
должна немножко привнести свой вклад
в построение вот этой вот машины.
Нужно делегировать заполнение
информации аргументов конструктора
разным сущностям.
Ага, вот это делается через
билдер. Все.
Если вы не поняли, что я сказал,
сообщите об этом или молчите вечно.
Мы будем считать, что все поняли.
Вот, но такое не особо
часто нужно, а вот просто
сделать код более понятным и красивым
без конструктора на 20
аргументов, это да.
Иногда же требуется.
Это может быть полезно еще, наверное, когда
мы хотим создать объект, который
будет составной частью у нескольких
других объектов. То есть мы хотим сделать
например, ногу, нога будет
там у Барби, у Кена.
А зачем билдер для этого?
Чтобы мы типа сконфигурировали ее
и потом такие сказали, сделай еще одну, сделай еще одну.
Ну, можно так сделать.
А можно просто скопировать ногу
и все.
Ну да, если есть какой-то изначальный набор
конфигураций, который общий, а потом
нужно чуть-чуть докастомизировать для
конкретных целей, то вот туда
идеально подходит билдер.
Потому что вы в общем коде какие-то куски
сеттаете, а потом каким-то другим
ребятам делегируете, доконфигурируете
для Барби, доконфигурируете для Кена.
И все в принципе,
ну да, нормальное применение.
Дальше. Ну, это в абстрактном
виде, не будем смотреть.
Есть синглтоны, есть прототипы.
Они тривиальные, правда? Вы все знаете, что такое
синглтон и все знаете, что такое прототип.
А я не верю вам.
Чем отличается прототип
от конструктора копирования?
Вот можно конструктор
копирования вызвать в класс. Зачем нам какой-то
прототип, там какой-то метод клоун говорят
писать, зачем это все?
Что значит изменить прототип?
Ну, потом прототип состоит в чем?
У вас есть интерфейс, у вас есть наследники.
Вы добавляете в
интерфейс метод клоун.
Так, в наследниках
его реализуйте, делая объект, который
точно такой же, как текущий.
И возвращаете его по ссылке,
по интерфейсу.
Зачем это?
Почему нельзя?
Вот, это правильное замечание,
абсолютно. В этом все разница.
Да?
Конструктор копирования, он ничего не знает
ни про какую виртуальность, ни про какое наследование,
ни про какое ОП.
Конкретный тип берет и копирует.
Когда у вас иерархия,
есть указательный интерфейс какой-то,
то а как, собственно, понять,
что под этим интерфейсом кроется,
и как вообще у него вызвать конструктор копирования?
Он же не виртуальный.
Поэтому клоун это просто виртуализация
конструктора копирования.
Точно так же, как там вот эта вся фабричная муть,
это виртуализация
просто конструктора.
А? Давайте ехать дальше.
Компоновщик. Это дерево.
Ну, дерево, у которого
есть какой-то интерфейс ноды,
а дальше эти ноды могут быть разные.
Где вы видели компоновщики в жизни?
HTML.
Ну, в принципе, да. Если вы парсите HTML,
да,
то у вас дом дерева получится ровно компоновщик.
А еще? Аиста дерева.
Лисп.
Ну, да. Ну, вот это все компоновщики.
Триально, тривиально. Едем дальше.
Декоратор.
Тут, конечно,
должно быть очередной
монолог про то, чем отличается декоратор
от адаптера, от прокси,
от... Давайте декоратор в абстракте.
А кто-нибудь помнит, что это?
Питонячий декоратор.
Нет, питонячий декоратор это не декоратор.
Ну, в каком-то смысле это декоратор, но не в полном.
Ну, мы
хотим добавить какой-то функционал
к объекту, не
меняя сам объект.
Сам класс его.
И поэтому мы наворачиваем этот декоратор.
Типа как extension
методы. Ну, типа того.
Но держится все на том, что есть интерфейс.
Вот с этого надо начинать. Есть интерфейс.
У нас есть его, какой-то
наследник его реализует, что-то
там делает. Мы хотим делать чуть
больше. Ну, тут
какой-то writeData, readData. Мы хотим
дату шифровать перед записью и чтением.
Да? Поэтому мы берем
ну, как бы,
простое решение это взять, переписать,
скопировать вот этот весь класс.
Добавить вот это вот
шифрование, и вы
справились в принципе. Хорошее
решение это, ну,
вот тут что-то какая-то фигня нарисована.
Можно просто взять и...
Ладно, нет, мне не получится так объяснить
из-за этой диаграммы. Хорошее решение.
Вы делаете новый класс.
Encryption...
EncryptionDecoraтор можно его назвать.
Можно просто EncryptionDataSource.
Неважно. И
храните
внутри него другой DataSource.
Вот как бы
оборачивайте другой класс,
другой интерфейс.
Другой объект того же
интерфейса. Вы его оборачиваете
и при этом сами реализуете этот же интерфейс
тоже.
Посредством методов того, кого вы обернули.
Вот такая идея.
Понятно, что я сказал?
Оборачивающий класс всегда наследник
того, кого он оборачивал?
Нет, он его хранит в том-то и дело.
Мы не наследуем FileDataSource.
Мы храним любой DataSource.
Вообще любой.
Но мы наследуем DataSource, получается.
Да, мы наследуем интерфейс.
Тут отличевой момент
всей этой конструкции в том, что есть какой-то
интерфейс. Если интерфейса нет, то
Decoraтор...
FileDataSource вообще тут это...
Да, это конкретный пример какого-то DataSource.
Но вот был какой-то один DataSource.
Другой, третий, четвертый.
И все их нужно уметь шифровать.
В этом тоже как бы
point. Поэтому мы делаем вот такой
EncryptionDecoraтор, который внутри себя
хранит DataSource,
воврайт-даты
и рид-дата.
Что-то там шифрует, а потом называет
уврапи.
Понятно?
Рукомахательно.
Это хорошо.
Четыре года уже как должны все знать.
Поэтому было бы плохо, если было не понятно.
Ну и вот тут какие-то
общие рассуждения, что можно вот этот общий
класс вынести. Он на прошлом слайде уже был.
Такой BaseDecoraтор.
Потому что в каждом декораторе должно быть
поле в раппи.
Поэтому мы же против копипасты. Мы сделаем
специальный промежуточный класс,
у которого ровно одно поле есть
в раппи. И все.
Чтобы не писать его заново.
Очень полезно.
Прекрасно.
Можно весь boilerplate написать.
Какой?
С повторной реализации интерфейса,
который мы передаем в раппи.
Так нет. В том-то идея, что мы в повторной реализации
интерфейса хотим...
А, нет, ну ты прав.
Да, если у нас 10 разных
методов вот здесь,
ну вот в этом интерфейсе 10 разных методов,
мы может хотим только один из них
как-то кастомизировать.
Добавить какое-нибудь поведение новое
на запуске.
Или просто к в раппи прокинуть, как они и были.
Вот тогда их можно в этот бейс-декоратор
запихнуть.
Но это уже как-то не про дизайн,
а просто какую-то специфику того, как вообще
код на джабы пишется.
И на имплисах в принципе тоже. Окей.
Мост.
Вот я утверждаю, что мост это тривиальный паттерн,
его вообще не нужно учить, не нужно знать, что это паттерн.
Это просто здравый смысл.
Кто-нибудь помнит, что такое мост?
Нет.
Ну и правильно.
Пример?
Вот этот?
Нет.
Это не мост.
Ну почему?
Потому что, возможно, его кто-то
называет мостом,
но имеет в виду совсем другое,
нежели имеют в виду авторы книжки по паттернам
вот этой вот, ну вы поняли о чем.
Я от банды четырех, вроде так называется.
Наверное, ты другой мост имеешь в виду.
А тут
мост очень тупой.
Что у нас значит есть иерархия окон,
ну окно для X,
окно там для, я не знаю, что такое
PM, может вы знаете.
Ну это что-то странное.
Ну ладно.
А потом решили добавить
иконки.
Вот что окон должны быть иконки.
И делайте
icon window, и от него заново наследуете
x icon window, PM icon window.
Ну вот если вы такой код увидите,
вы, наверное, матом покроете
автора, правда ведь?
Это же бред полный.
Ну иконки должны как-то
храниться в окнах, ну или наоборот.
Окна в конце концов
могут храниться в иконках, если очень хочется.
Мост про это.
Тут просто прекрасно
придумано, что вот мол есть
окно,
у него есть там вот
окно с оконкой наследник,
есть икно с
какой-то другой,
трансин, ну пропадающее окно,
виды окон.
Вот иерархия видов окон.
Икно с оконкой, икно с чем-то другим, икно с чем-то еще.
А дальше есть вот
иксы и какой-то PM,
наверное, это виндовое окно.
Вот это отдельная иерархия будет.
Вот и все. Какой-то window impel.
И вот
просто window хранит в себе поле
window impel и прокидывает ему всякие
иерархии, вызову, чтобы там что-то сделать.
То есть делайте много разных иерархий,
храните их друг к другу полями,
а не запихивайте все в одну иерархию.
Вот и весь pattern bridge.
Декомпозируйте код правильно,
иначе говоря.
Достаточно тривиальная вещь,
не нужно о ней думать вообще, вы просто
когда пишете код, у вас у самих должно быть
желание так делать, даже
не вспоминая, что это ведь название какое-то есть.
Вот.
Тут есть еще целый список.
Если вы хотите, могу что-нибудь про них сказать,
но я бы хотел скипнуть.
Помните их?
Ну так в целом.
Кто все эти люди?
Ну адаптер, так когда у вас есть два интерфейса,
вы хотели бы дружить?
Да. Причем важная оговорка,
два интерфейса в принципе одно и то же делают.
Звучит как бред, да, но
это паттерны для того, чтобы работать с legacy в том числе.
Это когда у вас есть
какой-то legacy, у вас полным-полно
будет мест, где 10 функций,
названия почти одинаковые,
аргументы почти одинаковые, делают
почти одинаковые вещи, но все какие-то чуть-чуть
по-разному и типа
это плохо. То же самое с интерфейсами.
Два-три интерфейса, которые по сути одно и то же,
но так сложилось исторически, что они разные.
Вот нужно заткнуть одно в другое,
вот адаптер прекрасно.
Ну.
Апрокси, это по-моему, когда у нас есть два
взаимодействующих с собой интерфейса,
а третий между ними, который делает какую-то
ворикулу.
Знаешь, если честно,
прокси, это та
штука, которую я вообще ни разу на практике
не применил, не видел применения,
не смог понять, зачем оно,
то я предлагаю просто считать, что прокси не существует.
Это какой-то типа
странный гибрид из много чего.
У меня в проекте есть штука,
которая называется прокси,
но она делает много чего.
Ну вот именно.
Тут совсем этим проблема, что каждая из этих вещей,
она там, слово классное,
но эти ребята, они
не запатентовали эти слова,
поэтому эти слова используют еще
куча других ребят для совсем других значений
и все такие, сделай фабрику, да,
сделаю фабрику, делает make shirt
или что-нибудь такое, и как бы, это
вообще про разное. Ну, ладно.
Дальше идем, дальше идем.
Я хочу побыстрее пройти все.
Паттерн команда.
Он вообще вам должен быть знаком
и роден, как я не знаю что,
потому что мы, собственно, в одной из домашних
будем с нуля писать. Паттерн фабрика
на шаблонах, очень интересно.
Ну, что он делает? Кто-нибудь помнит?
Он обращивает какую-то функцию, действие
в класс, в объект.
Ну да.
Ну да, и в принципе все.
То есть тут предлагаются еще
обвесы, которые можно сделать поверх вот этой
основной идеи, что, мол,
если вы представляете действие
в виде объектов,
то вы можете там откатывать
эти действия, делать анду
или какие-то бэкапы сохранять
или серилизовать эти действия, да.
То есть мало ли у вас там какая-нибудь
последовательность действий,
которые должен совершить какой-то
манипулятор рука, и вы хотите вот там
сохранить эту последовательность
или исполнить эту последовательность.
И вот вы их храните объектами,
и это вам классно.
Ну, в целом,
самая такая...
самая
часто встречаемый,
самый часто встречаемый вид этого паттерна
это STD Function,
потому что это чистые воды
команда.
STD Function это объект, который делает какое-то действие.
У него есть стейт, у него есть какие-то ссылки
куда-то вовне. Это тоже бывает
нужно, чтобы
что-то посчитать или сделать.
STD Function будем писать в какой-то момент.
Это абстрактный
вид всего этого.
На него смотреть тяжело, давайте не будем.
Шаблонный метод.
Ну, мне это в дипломе пригодилось.
Полезная штука.
Идея тупейшая.
Кто-нибудь может догадаться
о ней из картинки?
Я сомневаюсь,
что кто-то запомнил с курса ТП
вот это вот.
Нет,
никто не помнит,
что это такое, зачем
тут три какие-то класса.
Все очень тупо.
У вас есть алгоритм какой-то.
В дипломе, скажем,
как у меня.
И этот алгоритм делится на шаги.
И вы...
Каждый из этих шагов
тоже отдельный алгоритм,
и по каждому из них вы 10 статей нашли,
как реализовать.
Вы можете все варианты попробовать,
по-разному их комбинировать.
Ну и что вы делаете?
Вы основной алгоритм пишете в главном классе сверху,
а все шаги делаете
виртуальными методами.
Потом делаете наследников
и какие-то комбинации этих шагов.
И по-разному эти шаги делаете.
Тут вот
какая-то последовательность действий в игре.
Take turn,
collect resources, что там.
И предполагается, что где-то здесь есть...
Наверное, take turn имеется в виду как этот метод,
который все остальные подряд
запускают.
Возможно, с каким-то ифами еще, какой-то логикой,
в цикле чего-нибудь.
Но суть take turn — какой-то код,
который запускает заглушки,
которые ниже.
Дальше эти заглушки чем-то надо заполнить,
мы в наследниках их заполняем. Шаблонный метод.
Все тупо.
А, ну собственно, вот.
Шаблонный метод,
в нем какие-то шаги, шаги виртуальные,
в наследниках переопределяем. Все.
Идем дальше.
Визитор. Визитор — самый классный паттерн,
как по мне. В нем есть что-то волшебное.
— И есть мнение, что это
предусложенный паттерн?
— Ну, в принципе, да.
Но ты должен знать, что такое
визитор, правда ведь? Напомни нам,
что такое визитор. Ты же пишешь компиляторы.
— Сейчас.
— А?
— Да, я такого могу ожидать,
потому что это
пишется один раз и забывается дальше.
Насколько я сужу.
— Не, я просто помню, что это,
как пример, у нас есть паттери типа.
Я хочу привести пример
из компиляторной сферы.
Мы пишем токенайзер, который нам
выплевывает последовательность токенов.
У нас токены совсем разные
могут быть, они могут охранять разные
поля, могут не хранить поля,
могут иметь там какие-то свои методы и так далее.
И мы
хотим иметь подпоряжение
к какой-то последовательности токенов.
В ООП-шнем подходе мы имеем
CD-вектор, а указатель
на базовый класс.
И дальше мы хотим,
чтобы мы какую-то штуку
делали с этими токенами
по-разному, в зависимости от типа этого токена.
То есть
типичный пример
это мы хотим, условно говоря,
вывести в лог нашу последовательность
токенов, и мы хотим,
когда у нас токен, который отвечает
за стримковый литерат, мы выводили строчку,
которую он внутри себя хранит. Если он
отвечает за интовский литерат, он должен
выводить чиселку, которую в себе хранит.
Если это просто скобочка
литерат. Ну окей, есть токены,
иерархия, есть действия.
Где визитер?
Ну визитер
это, соответственно,
визитер, он
отвечает за действия, и у нас есть
метод visit.
У нас каждый из
наследников его парты определяют,
чтобы диспетченизация произошла
и внутри...
Наследников чего?
Наследники токенов.
Наследники токенов, метод visit, окей.
Вот, и потом, соответственно,
визитер, он в зависимости от того,
с каким токеном работает, он по-разному
его партует.
Ну, короче-то, я описал только что
то, что здесь нарисовано, в принципе.
Но это абсолютно не объясняет, зачем
все это нужно. Вот, если честно, я
из твоих объяснений не понял,
зачем мне нужен визитер.
Мы просто хотим на каждой AST ноде
разных пасов делать разную логику.
И мы можем эту логику просто
вписать каждый раз разно,
и у нас визитер будет сам ходить и вызывать
вот эти арбудочки.
Давайте тогда чуть-чуть проскролим.
Не-не-не-не-не-не.
Каждый тип, который реализует метод
accept, внутри знает, какой метод
визитер дергает на себя.
Ну, это все
в правильную сторону мысли,
но я главную суть хочу, нафиг
это все нужно.
Вот у нас есть такая картинка.
Вот два примера там про AST и про токены.
Это все из этой области.
У вас есть данные, и у вас есть поведение.
И вам нужно каждой из каждом их
декартово перемножить
и написать код.
Вопрос. Где этот код писать?
Как вот это все
организовать в фактический код?
То есть это будут
какие-то тела функций, но куда их вписывать?
В какие функции?
Два ответа на этот вопрос есть.
ОПшный ответ.
Давайте сделаем интерфейс,
данные будут наследовать
этот интерфейс,
а код будет методами.
Поведения будут методами этого интерфейса.
Просто и понятно.
Почему я так обвел по горизонтали?
Потому что
один из этих данных организует все поведения.
Ну да, это группировка.
Красное означает,
что эти штуки рядом находятся в коде.
В одном модуле, в одном объекте,
в одном чем-то. Здесь по горизонтали
группировка. И что это значит?
Это значит, что нам очень легко
не меняя старый код добавить новые данные.
Так? Легко.
А вот
добавить новое поведение
нам очень сложно.
Потому что нам нужно пройтись
по всем уже существующим данным
и везде вписать новый метод.
Не забыть. Иначе там ничего
работать не будет.
Такая группировка имеет
смысл. Если вам хочется
часто добавлять данные
и не хочется часто добавлять поведения,
то есть отличная группировка.
В компиляторах получилось по-другому.
АСТ, в него не часто
добавляются новые данные,
зато очень часто пытаются добавить
какие-то новые поведения, которые
проходятся по нему и что-то там
преобразуют, оптимизируют, добавляют,
переставляют. Вот такие вещи.
То есть им было важно, чтобы было легко новые
поведения добавлять.
Поэтому они придумали Visitor.
Теперь можно посмотреть на эту картинку.
Visitor инкапсулирует
стратегию того,
как мы делаем действия над
данными.
То есть
у каждого Visitor
для каждого вида данных
должен быть метод Visit.
Посетить эти данные.
То есть Element A, Element B — это
разные данные. А Visitor — это интерфейс
для действий.
Дальше для каждого конкретного
действия, в той табличке
вертикальные столбцы. Для каждого конкретного
действия вы делаете наследника.
Конкрет Visitor и вписываете туда код.
И вот уже
на эти две штуки смотря, группировка
получается по вертикали.
Мы сказали, что
поведение — это класс.
Назвали этот класс Visitor.
И сделали у него методы Visit,
которые делают действия над
каждым видом данных.
Теперь как это запустить?
То есть мы организовали этот код,
но вопрос, а как нам запустить?
Удобно.
Отличная идея.
Нет, будет
проще. У Element
мы сделаем, ну или у данных.
Они тоже будут террархией,
потому что это OP. Мы сделаем
метод Accept.
Он будет принимать какой-то Visitor.
А дальше мы попросим
всех наследников реализовать
этот метод Accept
и дёргать в этом интерфейсе
нужный метод
от себя.
Element A будет в этом
интерфейсе дёргать в Ascept
из интерфейса Visitor
Visit Element A.
Это просто нужно,
Accept, вот эта вся фигня,
просто чтобы упростить запуск этого кода.
Ну ладно, вы не могли.
Ладно, оно здесь нужно фундаментально,
я фигню какую-то сказал,
прошу прощения.
Итого, вам дали два
абстрактных вещи, Element непонятно какой
и Visitor непонятно какой.
Вы с одной стороны хотите запустить какой-то метод
Visit, один из этих двух.
Но вы же не знаете, какой элемент вам дали?
Не знаете, поэтому не можете
запустить ни один из них.
Поэтому вы пихаете Visitor в Ascept.
Ascept проходит
виртуальную диспетчеризацию и уже знает,
кто я, Element A или Element B.
А дальше он вызывает второй раз виртуальную диспетчеризацию
уже на Visitor,
вызывая конкретный метод Visit
и определяет, какое я поведение.
То есть такая двойная диспетчеризация,
чтобы понять и поведение,
и данные, и запустить нужный код.
И такая группировка получается.
А я не ожидаю,
что вы это когда-то в жизни писать будете,
но мне почему-то это прикалывает,
потому что очень симметрично получается, очень красиво.
ОП классическая по горизонтали
группируют, а Visitor позволяет сгруппировать по вертикали.
По-моему, это прикольно.
Ещё, конечно, можно...
О, так, стоп. Ещё можно
группировать каждую ячейку по отдельности,
вообще ничего не группируя.
Про это у нас...
Диагональ.
Что вы всех расстроите.
Чтобы все были недовольны.
Нет, можно вообще без группировки,
чтобы в любой момент, где угодно,
когда угодно можно было взять
и написать...
Ну и реализовать
какую-то ячейку этой таблицы.
А там нереализованные ячейки по дефолту
ничего не делают, например.
Такое можно сделать при желании.
И мы это будем делать на каком-то из семинаров
потом в будущем.
Вы видите перед собой бинпоиск уже некоторое время.
Запись идёт,
запись идёт.
А к чему это здесь?
Это конкретный алгоритм, он работает с Entami.
Наша общая задача по жизни
будет, среди прочих,
на этом курсе это обобщать алгоритмы.
Да?
Ну, данные обобщать как-то
не особо имеет смысл.
А всё программирование, оно состоит
только из данных и структур...
Фу. Из данных и
алгоритмов.
Ча цитата знаете?
Ну вот я не знаю.
То есть я записал,
но наизусть не помню.
Умного мужика, короче.
Вот, и
Мы хотим обобщать алгоритмы, чтобы они
работали с большим количеством данных
без нужды нам что-то переписывать
и менять.
Понятно общая цель?
Это максимально абстрактная
формулировка.
То есть, неважно.
Просто мы хотим обобщить, чтобы
больше кейсов можно было покрыть
одним и тем же кодом.
Вот этот код покрывает один кейс
и, в принципе, всё.
Ну, я думаю, ничего нового
в самом коде вы не видите.
Ну и нам надо обобщить.
Как мы это будем делать?
Вот на прошлой паре
мы уже...
Да, я думаю, камеру надо
повернуть или меня видно?
Видно. Хорошо.
На прошлой паре мы уже что-то подобное
видели, правда?
Можно взять и запихнуть
всё в macros, где указывается тип
вместо int.
А дальше вот такое сделать.
И хоба! У нас появился...
И macros закомменчено.
Да.
Наверное...
Я не уверен, что хотел со всем этим
комментированием добиться.
Запустили macros, получили функцию,
можно использовать.
Обратите внимание на inline, про которое
я говорил.
Всё в хедре будете писать, поэтому inline.
А ещё маленькое дополнение
к прошлой паре, кстати.
Inline в языке C и C++ работает
абсолютно по-разному.
Поэтому всё, что я рассказывал на прошлой паре,
применимо только к C++.
Если вы будете когда-нибудь писать на
чистом C, почитайте отдельно
о том, как это работает там.
Окей. Едем дальше.
Вернее, нет, не едем.
Давайте попробуем назвать
минусы, какие-то и плюсы у этого подхода.
Вот именно вы.
Если мы вот так будем выписать наш код,
какие проблемы нас ожидают?
И чего хорошего у нас вообще будет?
Проблема первая, что делается, если он
в типе стоит больше, чем у одного слова.
Мы можем только от типов, чтобы
верить и будет что-то поперяться.
Да, вот проблемы с...
Вот это главный минус.
И про сложные типы
это примерно в эту же стезю,
потому что если вы сюда
какую-нибудь пару из intа-инта подставите,
как я в прошлый раз говорил, всё ломается.
Ещё.
Сейчас будет ещё много вещей,
которым будет вопрос, зачем это нужно,
когда можно шаблон.
Ну да.
Ещё что-нибудь.
Ну это всё проблемы с непонятными
ошибками компиляции.
Perit'ом можно, просто надо его в круглые скобки
ещё одни запихать.
И вот не user-friendly, сложные ошибки компиляции.
Может плюсы какие-то есть у этого?
Ну в принципе да.
Ну inline просто,
короче да, все это не будет работать, если честно.
То есть тут надо будет написать static inline все.
Ну давайте я назову минус.
Наш отрывок кода нужно заново скомпилировать для каждого
нового типа, который мы сюда подставим.
Это может быть долго.
Ну да.
Ну же.
Так.
Умеет, но всё равно это проблематично.
Ну ты обычный код пишешь, всё хорошо.
А когда вот такое начинаешь вытворять,
ну как-то всё-таки IDE не любит такое.
Где тогда сломается?
Def it and def it?
Ну не знаю.
Почему?
Мы не пытаемся разные функции для разных типов сделать.
Мы пытаемся алгоритмом общить,
чтобы туда больше всякой фигни можно было запихнуть.
Какой ценой нам не важно.
Ну да.
Сейчас будет не очевидное.
Знаете что такое iCache?
Потому что инструкции, которые вы исполняете на процессоре,
они тоже
загружаются в cache
перед тем, как собственно на процессоре
исполняться.
И если у вас очень много кода,
который делает примерно одно и то же,
но с чуть-чуть разными данными,
одна с нотами, другая
с флотами, третья с слонгами
каким-нибудь, то вот этот iCache
он будет недоволен вами.
Потому что почти одни и те же инструкции загружаются,
но чуть-чуть разные,
и из-за этого разная память и все плохо.
Поняли, о чем я?
В шаблонах тоже самое.
Да, и в Rasty тоже самое.
У нас образовательный курс.
Если вы хотите
затроллить
пользователя Rasta, обязательно поговорите с ним
об instruction cache и влиянии
монумерфизации на него.
То есть Rasty
тоже типа шаблоны, но чуть-чуть другие.
Но там
фактически получается, что на каждый
пук создается новая инстанциация.
Вот что угодно.
Пишите, постоянно что-то там
шаблонизируется, инстанцируется вообще без повода.
И
instruction cache от этого очень больно.
Вот, ну ладно, давайте
закончим на это смотреть.
Какие-то понятные в принципе недостатки, очевидно,
что так плохо делать. Поэтому все так и не
делают толком-то. Все делают по-другому
бинпоиск. Вот так его делают.
А никак.
Нафиг.
Не делаю.
Не делаю. Просто не делаю. Вот он.
Видите, что-то
происходит.
Заменили все на указательную свою память.
Да.
Ну а что как бы?
Так чтобы это был стиль, нужно вместо
cd-span там более звездочки сделать.
Ну понятное дело, но
это очень смешной гибрид
idc и
синтаксис kc++20.
Мне это кажется
забавным.
Ну что?
Про это тоже нужно поговорить.
Какие недостатки, преимущества?
Очень большие сигнатуры
тяжелости, мне кажется.
Ну да, прям все.
Бой по вякуле
статистической проверки.
Потому что если мы можем
указать на байкингу, мы можем
вякулить.
И в этом
знаете, как брендайна?
Уб можно очень легко
сравнить. На сравнении с двух
имтов будет вызывать кол.
Это скорее более частая проблема, что
у меня в принципе ОС специализированных
по типу оптимизации.
Нет, ну как
бы тут про то, что indirect кол
будет, ну компилятор может догадаться
и соптимизировать. Потому что в большинстве случаев
вы сюда впишете просто какой-то конкретный
фикс функции. А вот эта вся фигня
заинлайнится?
А дальше он увидит,
ой, а функция-то мы знаем какая, и indirect кола
не будет.
Если компромат условно убежит от другого файла
или трансляции, то его никак не заинлайнится.
Ну а в такой ситуации шаблонизирование
какое-нибудь вам никак не поможет
для использования макросов.
Потому что все равно будет, инлайнинга не произойдет,
вы куда-то далеко пойдете.
То есть тут вопрос только в том, что вот это может быть
дополнительный indirect кол,
но я утверждаю, что нет.
В современных компиляторах уже не важно.
Нельзя, чтобы
на функцию, которая вылезает, что она наинлайнится?
Что-что?
Шаблон, шаблон функции,
которая вылезает, нет?
Да, в этом вся идея этого подхода
в том, что никаких шаблонов, мы просто с
байтиками работаем. Знаете,
какой плюс у этого?
iQishook хорошо.
Тут один и тот же bytecode будет
заимечен для всех типов.
Кроме этой одной функции,
которая там будет разная.
Ну как бы в данном примере
все рассуждения про iQish
это лукавство полное, здесь
не повлияет.
Программисту будет плохо, мы уже вроде как
и сказали.
Да, рассуждение про iQish относится
на более большие масштабы, более крупные
какие-то отрывки кода
про проекты.
Размер Benign и iQish
тоже.
Это все в одно и то же место
можно вписать.
Потому что
если у вас экзешник игры
весит 20 гигов, пользователь будет
недоволен.
Если 100, то он будет рад.
Я про экзешника,
не про ресурсы к игре.
Ну, не важно.
Разве игры упираются по размеру
самой игры в бинарии?
Чем меньше
ты всякого мусора в свой бинарий
вложишь, тем больше HD текстурок
4К разрешения ты сможешь
напихать, чтобы пользователь не
ворчал. По-моему этот
трейдов понятный.
Ну что,
еще придумаем что-нибудь про это?
Идейно,
мы отложили,
два подхода уже увидели,
в этом подходе мы отложили решение
о том, как конкретно будет алгоритм
себя вести до фактически
времени при процессинге.
А здесь мы отложили момент
решения, как конкретно алгоритм
себя будет вести
до рантайма,
что тут компаратор,
он в рантайме может любой вообще получиться.
Как бы да,
а может и нет.
Да,
но ты же можешь сюда любой компаратор
пихнуть,
пихнуть сюда вызов функции
другой, который из сложной логики
выбирает один из десяти компараторов.
Да,
я об этом и говорю, что здесь
в рантайме выбор, вот тут,
а в верхнем только при процессинге.
Что ты хотел сказать?
Да, да, и все равно iCache
будет плохо. Ну это да, это трейдов,
невозможно
как бы и съесть торт, и остаться
с ним.
Да, но не всегда же оно заинлайнится.
Чтобы понять, что что-то заинлайнилось,
есть ровно один выход, это пойти прочитать
Assembler.
По-другому не догадаться.
Ну и с другой стороны, возможно вы и не хотите,
чтобы оно инлайнилось,
напишите в cpp-шник, и тогда все будет
без онлайна.
Ну короче, какие-то профиты есть
и у этого подхода, какие-то и у того.
Есть наша любимая ООП.
Вы не понимали, почему написать
нельзя просто этот?
Ну все, все сломалось.
Почему нельзя
написать шаблон, потому что можно по-другому
обобщать код?
Вот мы берем,
делаем интерфейс,
iCompareable,
и делаем compare to другой
iCompareable.
Для этого нужно по варианту идти.
Тут будет проблема, что мы не всегда хотим сравнить
любые два iCompareables.
Но iCompareable для каждого типа.
Ну тут сразу есть
бедыш,
который уже написан в коде,
а так в какие-нибудь моменты
пары?
Ну,
ну или от динамикаста может быть
еще не так страшно.
Больше проблема, что если кто-то
где-то написал тип, который
не дубовку, а где-то iCompareable,
то нужно писать датку над этим типом.
Вот именно да.
Я бы сказал,
больше проблема в том, что вы
насиловать компьютера
будете вот такими действиями.
Ну просто нельзя так писать код.
А джависты пишут.
Да? Внезапно.
Для тех, кто не знает,
процессор
загружает память,
память из компьютера блоками
4 байта. Меньше он не умеет.
Если вы пишете
вот такой код, а я надеюсь, вы понимаете, что это значит,
да, у нас есть
контейнер с указателями на
инты, и каждый инт
хранится где-то непонятно где на кучу,
в произвольном месте.
Что это значит? Итерируясь по этому...
Фабрика использована,
они хранятся рядом.
Ну,
если повезло, а если ты еще какие-то действия
подделал, то все сломается.
Так вот, что будет происходить,
когда вы будете что-то искать
в таком массиве, как-то по нему
ходить? Каждая загрузка любого
инта из этого массива — это промах
по кышу и загрузка 64
байт лишних, из которых вам нужно
примерно 4.
То есть вы понимаете, что вы замедлите код
таким образом. Вот 64
делить не 4. Сколько будет? 16.
В 16 раз замедлите код.
Но очевидно, что оно здесь в память
будет упираться, правда?
Процессорных инструкций здесь нету
фактически.
Значит, единственное, что нас интересует, это
насколько мы хорошо
читаем память.
Почему мы на самом деле сильнее
замедлим код, если вспомнить нашу
майнинг?
Ну да, тоже верно.
Просто из того,
как мы работаем с памятью,
каждый доступ к инту из этого
массива — это промах по кышу, загрузка
48,
60 лишних байт,
которые вам не нужны, которые вы
выкидываете. А если бы мы написали вот так?
Разведите только там
маленький...
Да, да, да, да. Тут должен был быть
линейный поиск, чтобы аргумент был более
весомый. Потому что бинпоиск, он так и так
прыгает вот так вот по массиву. Но когда
вы уже сузили свой диапазон поиска
до 64 байт,
да, вот этот подход
нужно делать линейный поиск вообще-то,
потому что это будет быстрее.
Но во всяком случае,
когда вы сузились до 64 байт,
вы хотите просто вот один раз загрузить
их и всё, и прыгайте там как хотите.
А здесь, даже когда мы сузились
до 64 байт в нашем диапазоне,
мы будем постоянно
загружать каждый инд заново из памяти.
Это будет очень медленно.
Надеюсь, я вас как-то убедил, что
у ОП очень плохо получается
на самом деле обобщать какие-то
элементарные алгоритмы.
У ОП хорошо получается
моделировать какие-то сложные системы
высокоуровневые,
но таким вы занимаетесь
как правило в нормальных компаниях
минимум времени.
Вы не сидите и не делаете абстрактные
менеджеры, фабрик,
медиаторов, адаптеров,
чего-то там
над систем.
Вы данные обрабатываете.
Кто не согласен с этим утверждением?
Вдруг я не прав?
Почему ты не согласен?
Я хранил только данные.
А, ты только хранишь.
То есть ты пишешь базы данных
и тебе их нужно только сохранить.
Они же пришли по сети, их нужно приложить в память.
Ты обрабатываешь данные.
Мы все занимаемся обработкой данных
по сути. Написанием алгоритмов
по большей части.
Когда мы там уже доросли, мы начинаем системы
дизайнах делать.
Там паттерны ОП, вот это все.
А когда вы просто пишете код,
нам в первую очередь важно, чтобы
а, простой,
все.
В попытке обобщить бинпоиск
ОП не справилось абсолютно.
Чистое ОП.
Поэтому, конечно же, и
все минусы
вы уже назвали,
я их забыл записать,
но будем считать, что мы помним.
Все очень плохо здесь, короче.
Так вот, три подхода.
Все из них не очень хорошие.
Нужно сделать новый подход,
который все проблемы решит.
Нет.
Ну все, шаблоны.
Это была отсылка, если вы не поняли.
Про 14 стандартов нужно сделать один,
который все объединит и все проблемы решит.
Результат 15 конкурирующих стандартов.
Тут та же самая ситуация.
Несмотря на то, что шаблоны многие вещи
делают хорошо,
в других мечах они такие же проблематичные.
Но вот давайте...
Блин, надо выписать все-таки.
С Макасом я вижу только одну проблему удобства.
Да.
Они сильно удобнее.
Они раньше проверяются, всякий синтаксис чекается,
вызывать удобно.
Фактически все эти минусы, кроме iCache, они ушли.
Давайте...
Они читаемые.
Да-да-да.
Ну...
Плюс-минус не читаемые.
Чуть-чуть плюс-минус
Концерты.
Ну, смотрите, как бы...
Не копируемые.
А что?
Почему...
Ну, это ко всем относится, что выше была.
А почему ты... Где я копирую?
ТВЛ.
Ну, можно ссылку поставить, если хочешь.
Концссылку.
Так, по-моему, такой код ставил.
Ну и все.
Нет, это не проблема.
Вот какие-то общие свойства того,
на какой класс типов мы обобщаем наш алгоритм,
они как бы ну...
Абстрактные.
Я бы сказал, что
Visual Studio
будет плохо.
Потому что это именно она
нифига не умеет нормально
подсвечивать синтаксис, подсказывать
в рамках шаблонов.
Два года назад с Vimeo было плохо.
Я с ClangD
живу просто в S-коде
и в принципе нормально.
Самый правильный код — это выключить
апеллисансы. Да, и писать весь код в ВИМИ.
Ладно.
Любой IDE на самом деле будет немножко плохо,
но гораздо лучше, чем с макросами.
Это тоже, ну, чуть-чуть
хуже, чем у макросов.
Вот, блин,
мы так не записали, что было проблематично.
Да...
Вот так вот.
Наверное, неправильно
написал, да?
Нет, наверное, правильно.
Что вы еще называли про ОП?
Сложно вызывать, да?
Что-то такое говорили.
Ну, да-да-да.
Ну, медленно.
Ну, в принципе у нас
какие-то минимальные классы,
если так на все делать,
разрастаются до огромных.
Что разрастается?
Ну, у нас минимальные какие-то классы,
просто из-за того, что нам все это нужно еще
виртуально включать, разрастаются до каких-то огромных.
Такой класс, который делает минимум,
разрастается до сотен байков.
Сотен байков.
Просто потому, что мы подключили пять таких функционалов.
Не уверен о чем-то.
Где здесь класс?
Если у нас iCompare,
то мы потом еще будет фичу.
И у нас в итоге там на каждый идет по 8-16 байков
и виртуальное наследование.
А не надо делать виртуальное наследование, ты чего?
Не всегда получается виртуальное наследование.
Ну, если не получается, то это все.
Это храм с точки зрения ОП.
Ты уже не ОП занимаешься чем-то более
общим, абстрактным.
То есть в ОП есть один класс
и много интерфейсов.
Тут речь именно о том,
что интерфейсы.
Ну, медленно, да.
Ну, короче, вот это все.
Кажется, что вот это все мы шаблонами
лечим, то есть мы ближе к макросам
в плане...
В плане всего.
Шаблоны больше похожи на макросы,
поэтому проблем, связанных с ОП
и всяким этим, нет.
Но не все проблемы
макросов до конца решены.
Давайте еще вот на это посмотрим.
Есть ли вот о этой штуке
плюсы по сравнению с шаблонами?
Кажется, есть. Если все типы стереть
и работать с байтами, то iCache
будет счастлив.
Ну, вот про выбор компаратора.
Может быть проблема, что
если мы используем стандартный тип,
у него есть
дефолт на определенный
оператор меньше.
А мы можем хотеть
другой оператор меньше?
Ну да, примерно такие вещи.
Можно пофиксить опциональным аргументом?
Пофиксить можно.
Я бы даже обобщил этот вопрос
до того, что... Ну, если вот ровно так
написать, то
вы ровно один конкретный компаратор
можете использовать с конкретным типом.
Но это решается.
Есть еще один важный моментик,
который мы вот как-то проскользнули
по нему... Ой, я не туда открыл.
Проскользнули по нему про
открытость и закрытость.
Вот это,
что называется закрытый алгоритм.
Потому что нам нужно
явно пойти и...
Ладно, я не уверен, что это конкретно
так корректно называть.
Давайте так это все-таки называть.
Чтобы тип наш впихнуть
в этот алгоритм, надо пойти
отнаследовать его от iComparable, либо написать обертку.
То есть нам необходимо менять
чужие типы данных, чтобы они подходили
к нашему алгоритму.
Плохое обобщение, вам не кажется?
То есть ну...
Подключив библиотеку какую-то, где уже
есть какой-то тип данных, вы не сможете
просто его использовать с таким обобщением.
Грустно.
Взяли, написали хитрый аккомпаратор,
все работает.
И в шаблонах тоже сможете.
Написав свой там
оператор меньше или
перегрузив чего-нибудь, ну или
вообще функцию здесь какую-то вызывать.
Вот.
На этом, мне кажется, все про вот это вот
сравнение.
Я хотел, чтобы вы почувствовали, что обобщать...
Ну, нас покидать начинают.
Удачи.
Я хотел, чтобы вы прочувствовали, что
вообще говоря, наша цель
она обобщать алгоритмы.
Делать это можно по-разному.
У этого есть разные плюсы, разные минусы.
Я очень сильно сейчас полил грязью ОП,
но это, конечно, ну так,
лукавство.
Нет, какие-то плюсы ОП есть.
Какие-то вопросы, какие-то проблемы
оно решает хорошо, но надо чувствовать
какие конкретно.
Вот.
И дальше мы будем, в принципе,
пользоваться не только шаблонами
для обобщения алгоритмов.
Чувствуется, что какое-то вот
заключительное слово нужно, но у меня его нет.
Поэтому мы просто возвращаемся к презентации,
потому что
время подходит к...
Это что такое? Это не то.
И это не то.
Вот так.
Да, время подходит к концу.
Нам нужно пройти презентацию.
Так что какие-то...
Какие-какие-какие...
Я хотел спросить у вас, знаете ли,
в эму в семантику.
Да?
Я не хочу.
Что значит знаем?
Ну, давайте...
Мы знаем, что...
Как ее писать? Знаем, как она работает.
Честно, я не особо...
Давай, работай.
Давайте, контрольный вопрос.
Не как работает, это как...
Да, блин, работай. Что такое?
Совсем.
Выбрали, видимо,
скринт.
Надо вернуть туда обратно.
У вас есть?
Давайте...
У вас есть?
Тише, давай, работай.
Контрольный вопрос
на знание.
Мы в семантике.
L-value, R-value.
Это прилагательное, на самом деле, да?
Что они описывают?
Expression. Ура!
Ну, значит, все знают.
Ладно, что такое expression?
Часть AST дерева?
Да, это часть просто кодопрограммы.
Часть AST дерева.
L-value, R-value категоризируют
по сути вершина AST дерева.
Для вас это шок или
примерно понятно?
Хорошо.
Похоже на то, что вы все знаете.
Не будем больше говорить про
семантику.
Будем говорить про неработающий проектор.
Какого черта? Работай.
Теперь надо переключить...
Так.
Что это такое?
Моя беда в том, что этот монитор
вдвое большего разрешения, чем мой.
И когда я переключаюсь в OBS между
записью моего монитора и этого,
у меня разрастается
вот так,
вот за пределы
зоны записи.
Какой-то непродуманчик.
Ну ладно.
Все, пошли дальше.
Надо закончить. Я чувствую,
вы устали.
Закончим мы вот с
тупых вещей.
Обычно с них начинают, а мы ими закончим.
Вот это заголовочек
шаблона.
Можно туда всякие имтики писать,
type-name. А что дальше можно писать?
Еще раз можно писать
template.
Это правильно.
А кто-нибудь
сможет назвать кейс,
в котором нужно после этого еще раз
писать template? Точно такое же.
Да.
Нет,
никогда template-template параметр, когда
класс шаблонный и метод
внутри него шаблонный. Вот тогда два раза
может быть подряд.
Да, и мы все это вне класса определяем.
Ну а более просто.
Какие сущности могут быть шаблонами?
Алиас.
Сигнатура функции.
Класс, функция.
Метод, концепт.
Ну в принципе да.
Я бы сказал, что класс и структура
это все одно и то же.
Сигнатура функции это та же самая
функция, но тут конечно
есть деталь.
Шаблоном может быть как определение,
так и объявление функции.
Ну вот я хотел
это после вот этого отрывка презентации
поговорить насчет этого, но мы не успеем уже.
Поэтому давайте просто презентацию досмотрим
и пойдем по домам спать.
Да,
про шаблоны
переменных. Вас это не шокирует, правда?
Вы видели такие уже?
А вот что будет если без слова
constexpr написать? Что это вообще значит?
Логически?
Получается
biome
и сравнивать
размер кого-то типа
с данным ксом.
Нет, нет, нет. Сейчас.
Во.
Я про это хотел сказать. Вот это закрыть можно.
Вопрос был другой.
Просто что такое шаблонная глобальная
переменная?
Да.
Мы в бинаре будем резервировать место
под каждую инстанциацию. Это такой способ
автоматизировать выделение
памяти в глобальной секции
вашей программы.
Да. В каком-то смысле.
И вы не поверите, это даже
используется на практике. У нас есть
такое. Против крутится.
Я хочу отпилить уже давно, потому что это
жесть. Но есть.
Окей. Все это можно
писать. Ну вот шаблон класса.
Знаете
что? Я встану здесь, пожалуй, потому что мне
нужен презентер вью, чтобы не забыть,
что там дальше идет по плану.
Какой-то он неудобный
здесь. Ну ладно.
Да. Шаблон класса. Внутри него можно
написать метод.
Соответственно, все шаблонные
аргументы можно где угодно использовать в
рамках той сущности, которую вы определили.
Вот вообще где угодно.
Для некоторых это может быть шоком.
Шаблон, я надеюсь, нет. Можно отнаследоваться от С.
Можно завести
поля типа С. Можно
аргументы типа С в функции принимать.
Можно возвращать типа С.
Можно создавать объекты типа С. Что угодно.
Просто в рамках этого
тела у вас как будто бы есть
вот такой тип.
Чтобы использовать
такой тип, у нас есть такой синтаксис.
Окей?
Окей. Ничего нового.
Да, и вот накину
еще раз терминологию.
Давайте так с вами будем говорить в рамках этого курса,
что мол, сущность
это одно из всего, что мы перечислили,
и у нас есть
шаблоны сущностей.
Вот
то, что после темплейта идет.
Темплейт это как бы заголовок шаблона,
а дальше идет шаблон сущности.
И нет шаблонных функций,
есть шаблоны функций.
Про это я уже понудил.
Инстанциация и специализация,
пожалуйста, не говорите
посмотри на эту инстанциацию.
Потому что инстанциация это процесс,
а результат это специализация.
Ну, почему
акцентирую внимание, потому что
в некоторых вопросах нашего курса
придется залазить в стандарт.
Там это строго соблюдается терминология,
и чтобы не запутаться, пожалуйста, тоже
вот соблюдайте.
Окей.
Вопрос к вам.
Ну, если до этого было скучно
и все старое, то возможно сейчас будет
что-то новое. Возможно, вы не
задумывались об этом.
Ну, зависит от типа цена.
Если нет, то есть, то... Нет, а я просто вот такой код
написал в Main.cpp и все.
Это скомпилист.
Скомпилист, да.
Ну да, это правильно.
Ну код на самом деле нет.
Ну да, это все скомпилируется,
потому что у нас по шаблону...
Ну как бы...
То есть, иногда
он требуется по линии типов, например,
при
Я не очень понял, что ты хочешь сказать.
Скорее всего, то же самое, что я сейчас на следующих
слайдах скажу, только другими словами.
Здесь мы не знаем, какой
C.
Мы не знаем, есть ли у C member,
или нету.
Ну и поэтому такой
код чисто сам по себе скомпилируется.
Почему?
Потому что, когда подставим конкретно
C, вот тогда уже можно понять,
есть ли member, нет ли, ошибка, или все нормально.
А просто сам шаблон
с ним все ок. Че?
Тоже верно, да.
А вот так.
А вот так.
Он записывается.
Так. Куда я ушел?
Сюда я ушел.
Дальше.
Вот так.
Скомпилируется.
Почему да, почему нет?
Давайте, кто говорил.
Потому что он уже
доисканственно может проявить, что такой member нет.
Ну так в предыдущем тоже самое
было. Почему там что-то?
Нет, в предыдущем он
не знал C, если
он не инстанцировали.
Я думаю, он проявить может, но не будет,
потому что мы этот сам кучу нигде не используем.
Ну, короче, это все абсолютно
верно. Потому что уже вот этот
код, только объявление шаблона,
она уже не скомпилируется.
Потому что мы знаем, что у нас
завалью, знаем, что у него
тип B, знаем, что вот он B,
и вот у него нет никакого member.
И мы заранее выдадим ошибку,
еще до того, как вы инстанцировали шаблон.
Вы почувствовали разницу?
Если вот сюда
то самое B подставить в качестве шаблона,
то ошибку нам дадут уже
после инстанциации,
а вот здесь ошибку нам дают
до инстанциации,
в момент парсинга самого шаблона.
Вот мы просто
вершины AST
для этого шаблона составляем,
и уже в этот момент выдаем ошибку.
Вот эта вся технология
называется двухфазный lookup имен.
Вот это первая фаза.
В момент парсинга шаблона
мы пытаемся
найти все имена, про которые
все понятно.
Вот про value все понятно,
про member все понятно,
все нашли, вот он B.
Сейчас чуть подробнее будет.
А вот здесь ничего не понятно
про C. C может быть любой,
поэтому на момент парсинга шаблона
мы не можем ничего понять
и откладываем до момента инстанциации.
А почему?
Я уже ответил.
Если чуть более точнее
сказать,
в какие моменты
на второй фазе идет
lookup имен,
а в какие фазы...
Я заговариваюсь.
В каких случаях
на первой фазе идет lookup,
а в каких случаях
на второй фазе идет lookup.
Зависит это от того,
что имя.
Термин имя пока может быть не очень понятен.
Это строгий термин, в стандарте определенный.
Идейно, member – это имя,
value – это имя,
value.member – все вместе имя.
Причем именно вот этот
expression, написанный вот здесь,
как SLVALUE, RVALUE.
Мы не говорим про вот это
конкретное поле у какой-то структуры B.
У нее даже нет такого поля.
Мы говорим именно
об expression, написанном здесь.
Это имя является именем.
И это имя может быть двух видов
в рамках объявления шаблона.
Зависимое и независимое.
Понятно, от чего зависимое.
От шаблонных аргументов.
Если у нас имя зависит
от шаблонных аргументов,
то в момент парсинга шаблона ничего не понятно.
Мы откладываем
resolving имен до инстанциации.
Иначе сразу.
Просто.
Давайте пример рассмотреть.
Где здесь зависимые имена?
T маленькая.
Почему T маленькая зависимая?
У нас есть
шаблонный параметр T большое.
Ну да, потому что тип
у T маленького
T большое.
А T большое это шаблонный параметр.
Поэтому T маленькое зависимое имя.
Так, еще.
Что?
C.
C большое.
Ну и C маленькое тоже зависимое.
Ну тут надо
чуть аккуратнее быть.
Да, C маленькое зависимое,
потому что T2,2.C.
Вот это все вместе зависимое имя.
То есть само C по отдельности
не рассматривается, грубо говоря.
Все вместе зависимое имя.
Вот про FU там что-то сказали.
T.FU или зависимое?
T.FU, вот да.
T.FU зависимое, потому что T зависимое,
соответственно вызов функции на
зависимом объекте
тоже зависимое имя.
А вот это FU.
Вот это независимое.
По-моему,
вы не правы.
Да, может быть перегрузка.
Более того.
FU может быть много разных.
Как у нас в языке C++,
что у нас
такой вызов вызывает в языке C++?
Да, там куча всего может быть вызвана.
Про DL вы что-нибудь
слышали?
А DL потом поговорим.
Короче, правило,
как понять в C++ по
вот такой строке
и по вот такому имени.
Какую функцию конкретно вызывать
на самом деле?
Они просто сногсшибательные, эти правила.
Там просто с ума сойти можно,
и мы о них обязательно поговорим.
И вот ровно потому, что они очень сложные,
все это зависимое имя тоже.
То есть FU не будем выбирать,
пока не инстанцируем с конкретным T
этот шаблон.
Это, думаю, вообще очевидно,
что вот это FU тоже зависимое,
потому что тут явно T указан,
почему вот FU,
который там вызов FU отстояет
в виде, но это же не имя,
вызов FU.
В функциях
работает как-то смешно.
То ли говорят,
что весь вызов функции — это одно большое
имя,
то ли сказано, что
имя функции
оно не может быть просто так нигде употреблено,
после него обязательно есть
какой-то контекст, и вот если в этом контексте
есть зависимые аргументы,
то вот это имя тоже само становится зависимым.
Ну, в этом стандарте
нужно вычислить, если ты хочешь совершенно точно
понять, что там.
Но как
point, который нужно понять,
это то, что когда вы такую FU
от T вызываете, где T — зависимый аргумент,
лукап имени FU
он будет происходить потом.
То есть мы будем искать функцию,
которая это имя называет,
после того, как инстанцируем шаблон.
Ну, то есть, да, правильный ответ,
где здесь зависимые имена — везде.
Вот они все зависимые.
Едем дальше.
Вот это скомпилируется.
Ребусы, да, тут
у нас весь курс из ребусов состоит.
Выскажите мнение.
Почему скомпилируется?
Где?
Что, нет, подождите.
Имена — это когда вы называете
какую-то переменную функцию или другой класс.
Ну, наследование есть.
Вот это
вот это имя
G круглые скобочки.
Вы видите где-то вот
в этом выражении упоминание
чего-то, зависящего от шаблонных аргументов?
Нет, и я не вижу.
Значит, это имя независимое,
оно на первой фазе будет лукапиться.
Ну, да, да, могут.
Да, оно не скомпилируется.
Нет, еще раз,
не скомпилируется этот код.
Почему?
Вот здесь все имена были зависимыми
от чего?
И почему они на вторую фазу попадали?
Почему они стали
зависимыми? Потому что везде
как-то упоминалось T.
Тут T упомянулось, тут T упомянулось,
тут T маленькая,
но T большую тоже зависит.
Да, везде где-то именно
в выражении вызова функции
написано что-то, относящееся к T.
Увидели? Прямо на уровне
буквок.
А вот...
Чего?
Вот здесь написать?
Нет, вот здесь
как метод G отдельно
voidG.
То у вас вызовется этот voidG.
И тогда оно скомпилируется.
Да, но вы же хотели это уже вызвать.
То есть оно сейчас будет искать
какой-то глобальный уже?
Оно будет на первой фазе пытаться найти
функцию, соответствующую этому
выражению, этому имени.
На первой фазе вы не знаете, какой у вас
T. Соответственно, вы не знаете
на самом деле,
что вот это за класс.
А, T.
Почему вы не знаете, что это за класс?
Да, абсолютно верно.
Да, этот класс действительно
лукапится на второй фазе. Почему?
Почему мы не можем на первой фазе,
увидев шаблон A, пойти найти
какой-то шаблон A
и использовать его?
Ну мы же вот видим, вот у нас шаблон A.
Ну какая разница?
Специализация.
Именно в этом point.
Выбор,
какую A от T использовать здесь
в качестве наследника, откладывается
на вторую фазу. Потому что бывают
специализации в зависимости от T
у A. Вы можете специализировать
A от Nта и сделать его другим.
И у него уже же не будет.
Да?
Так что да.
Мы не знаем, какой у нас родитель.
Поэтому на первой фазе
G мы не найдем.
Либо так, либо сяк.
Любым образом вам нужно
в это имя добавить зависимость
от шаблонного аргумента. Почему
зависимость зависимая здесь?
Потому что это указательный объект шаблонный.
Да, это объект типа
порожденного из шаблона C
подставлением T, ну короче
C от T у него тип.
Мы как бы путем того, что G дело зависимое,
мы покидываем его на вторую фазу.
Да, мы его откладываем на вторую фазу.
И на второй фазе, если нам повезет
и нет специализации у A,
мы уже найдем вот эту конкретную G
и все будут довольны.
Сложно, правда?
Ну вот, шаблонный кажется
это просто, а когда начинаешь вот такие вещи
влезать,
начинается жесть. Но гораздо
неприятнее, когда вы на них натыкаетесь
на практике, не зная их существования,
чем когда заранее кто-то предупредил,
что такое будет,
домашко будет, вероятно.
Будьте готовы вписать this куда надо.
Но помимо this можно еще вписать
что-нибудь другое, а A, T тоже
вполне.
Дальше.
По-моему
нет.
По-моему никакой разницы нет.
This, он все равно не явно дописывается,
когда вы делаете вот этот this.
Ну короче, разницы нет,
ни в чем нет разницы.
Есть только,
скорее всего есть эзотерические какие-то
места, где оно по-разному чуть-чуть работает
и что-то никак не сломается. Ну это C++, тут
всегда так.
Подробнее вот здесь
надо читать, потому что я вам
набросал общими мозгами, если у вас
что-то не работает
к этому имеющее отношение,
то есть где-то глубоко в шаблонах,
вам говорят, ой, я не знаю, что это такое.
Возможно вам нужно вот эту статью
перечитать, но уже когда вы будете
на практике сидеть и писать код,
а не вот просто по приколу.
Так что да.
Дальше идем.
Еще один ребус.
Нет.
Не скомпилиться.
Потому что у нас
произойдет лукап, мы посмотрим, что у интернет
мембера.
Вот и все.
Мы же не узнаем,
что тут
кто-то неуверенно сказал
правильный ответ.
Get some member
Get some member
Get some member
Смотрите, когда мы объявляем какую-то
сущность про зависимость или независимость
этого имени, говорить бессмысленно.
Вот зависимость, независимость имен,
она, когда мы используем
какую-то другую сущность,
и хотим понять, где эта сущность на самом деле лежит.
Get member
Get member
Смотрите, на первой и второй фазе
мы находим какие-то
чужие методы.
Вот вы вызвали функцию,
вызвали метод. Нам нужно понять,
какую конкретно код вызвать.
У вас может быть в программе на C++
10 разных функций G
с разными аргументами, и это все равно корректно.
Поэтому есть вот эта процедура
лукапа имен. Мы пытаемся
понять по имени G
и аргументам, какую из G
надо вызывать.
Вот это лукап имен.
Про Get C member говорить
зависимо-независимо бессмысленно,
потому что в этом месте
мы никакого лукапа не делаем.
Мы не вызываем
функцию, поэтому лукап имен не происходит.
Value member – это доступ
на чтение какого-то там поля.
Нужен лукап имен.
А вот объявление какой-то
переменной – здесь никакой
лукап имен не нужен,
кроме как для C. Value
лукап не делается, потому что это
введение нового имени.
Вот здесь тоже введение нового имени.
А для C да, мы делаем лукап
и видим, что это
вот этот C.
Я надеюсь, я непонимание
чуть-чуть подправил.
За это время вы должны были
правильный ответ сформулировать,
как это компилируется или нет.
Так это компилируется.
Можно еще раз про фазу?
Вот здесь вот.
То есть вот B нам
выявляется зависимо,
C Value тоже зависимо.
Нет, смотри, про вот это
вот выражение Value
говорить зависимо и независимо бессмысленно,
потому что эта строчка вводит новое имя.
А про зависимо и независимо
мы говорим, когда используем какое-то другое имя.
Вот здесь мы получаем доступ
к какому-то полю,
хотим получить доступ к другой сущности.
Здесь вот уже надо понимать
зависимо и независимо.
А это введение нового имени.
Когда мы там рассматривали с тэшками,
у нас было как раз где-то T человеком
еще раньше.
Здесь да,
типа T вводили перемену
маленькую T и мы говорили, что это зависимо.
Она дальше будет в коде зависимая.
Я, наверное, плохо сформулировал.
Я буду снять это выделение.
Да, то есть вот здесь
вот тут
в этой строчке только T большое зависимое.
Про T маленькое бессмысленно
говорить зависимое оно или нет,
потому что оно пока только объявляется.
А вот дальше мы вот здесь его использовали
и вот тут оно становится зависимым.
Поняли логику.
В момент объявления нам неважно.
Мы новое имя вводим. Какая разница?
Какое оно будет?
Вот тут был пример.
Я спрашивал,
скомпилируется оно или нет.
И вы в недоумении,
почему оно скомпилируется?
Да,
тут все хором сейчас, кажется,
одно и то же сказали.
Шаблоны классов
инстанцируются кусками.
Не полностью сразу.
Когда мы вот такой код пишем,
единственное, что у нас инстанцируется,
это поля
и конструктор.
Все.
Все остальные методы, которые вы здесь написали,
вы их не использовали, они инстанцированы не будут.
Да.
Лениво каждый
по отдельности.
Почему?
Давай рассмотрим
вектор. Вектор UniquePTR
и вектор NTOF.
Почему вообще,
если вектор NTOF работает,
почему работает вектор UniquePTR?
Задумайтесь.
Конструктор копирования
лениво инстанцируется,
поэтому в векторе NTOF
он инстанцируется, а в векторе UniquePTR
если вы не попытаетесь
скопировать вектор UniquePTR,
он инстанцируется и не будет.
Да?
Поняли, о чем я.
И то есть получается, если мы здесь
следующей строчкой концепции
самим решим вызвать метод
в метод пяти лет семя,
то тогда у нас уже нет проблем?
Да. Мы уже как раз попытаемся инстанцировать этот метод
и уже получим ошибку.
Вот. То есть, общее правило
А.
Ну, невозможно выучить
свои слайды. Я много лет пытаюсь,
но никогда не получается.
Общее правило такое.
Всегда в специализацию
в результате инстанциации
попадают поля и алиасы.
Это, кстати, важно, что
алиасы всегда попадают
в одно из домашек. Вы будете проклинать
то, что оно так работает,
а может и не будете. Зависит тот.
А методы статической переменной,
внимание, вы помните,
что такое статическая переменная в классе?
Да.
Ну, глобальная, по сути.
Можно напомнить, пожалуйста?
Ну, вот. Все сказали
все правильно.
Что можно среди
рядом с полями типом кассер
написать?
Что?
Статик кассер написать, как в диком поле.
Ну, можно, да.
Статик кассер ты где угодно можно написать.
А. Слушай,
это ты прекрасную общую вещь заметил.
Мне это надо вписать сюда.
Я не могу отредактировать,
да.
Мы под статик переменной имеем
именно статик переменной или
статик поля в классе?
Статик поля в классах.
Да.
А это когда ты в одном классе
делаешь другой класс.
Прямо внутри одного класса объявляешь
другую структурку. Вот это тоже
лениво инстанцируется.
Ну ладно.
Это все-таки хорошее замечание.
Я не помню. По-моему они
как концепты работают.
Они сразу по-моему
вместе с полями.
Ладно.
Давайте ехать дальше.
Осталось чуть-чуть совсем.
Я же не вру, правда?
Да, нам осталось совсем
чуть-чуть.
Ехать, ехать, ехать вперед.
Вывод типов.
Не поехали, да?
Теперь поехали.
Очевидно, так
писать можно. Сделали шаблон,
явно указали ему аргументы.
Все встроено логично, понятно.
Но, оказывается,
можно делать и так. Я надеюсь,
для вас это не новость, потому что, когда вы пишете
std min для минимума
из двух чисел, происходит
ровно это.
Иногда приходится писать типы? Иногда.
Но это удобно,
что оно и выводит. Это прекрасно.
А вот если вы для такой штуки
попытаетесь ничего не написать, то
конечно ошибка будет.
Еще раз про предыдущую?
Просто был метод abs.
У него один шаблонный параметр.
Этот шаблонный параметр он принимает как
аргумент. Что происходит?
Компилятор видит,
у вас единственный аргумент,
типа...
А мы нигде не имплементировали abs.
Что не имплементировали?
Там, где-то есть.
Все нормально.
Компилятор видит тип аргумента,
понимает, что, наверное, ты хотел вызвать abs
с конкретным таким типом,
то есть здесь load, здесь double, здесь unsigned.
И все сам генерирует,
инстанцирует, и все хорошо.
Здесь ошибка.
Я думаю, тоже должно быть абсолютно
понятно интуитивно, почему.
Потому что он не знает,
чем от этого.
Даже если авто поменять,
будет...
Что?
Если авто на конкретный тип...
Тоже будет ошибка, да.
Если вы авто на инт замените,
это никак не поможет вам.
Потому что...
Да, потому что у нас не раст.
В расте, насколько я знаю, оно умеет
понимать, что, ой,
результат присвоили инту, значит, хотели
скастить к инту.
Или там флот.
Присвоили к флоту, значит, хотели изначально флот запустить.
Что?
В расте вообще проблемы с неявными кастами?
Нет, я...
Я про вызовы функций,
а не про касты вообще сейчас.
Когда...
В плюсах нельзя так...
Не всегда так уже делал, потому что, собственно,
есть неявная кастка.
А, ну, да.
Нет, проблем там много.
Они в том числе, они, конечно, нам все
ломают, потому что мало ли мы хотели
вызвать с другим аргументом,
потом скастить неявно к чему-то третьему.
Ну, с булими это особо...
Ну, да.
На днях я рефакторил
функцию, которая применяла
на вход int флаги.
Ну, понятное дело, что подразумевалось
из конкретного enum флаги туда
вписывать, да?
Ну, был на дворе 2005
год, поэтому написали int
flags, enum безымянные сделали,
и флаги прообъявили, ну, просто
с префиксом там, my flags,
что-то там.
Вот рефакторю-рефакторю нахожу одно место.
Там вызов этой функции
с этим аргументом.
Bool. True.
Просто. Вот вписали true.
Ну, я думаю,
можно догадаться, как такое исторически сложилось.
Там были вначале на були, потом
префакторили на enum, но история
поучительная. Не принимайте...
Нет, не так. Не рефакторите були
в int, потому что були обратно
в int кастятся неявно. Это очень плохо.
Давайте дальше ехать.
Где?
Нет, потому что смысл
этой функции
в том, что ты выбираешь, к чему кастовать.
Это функция с какого-то C++ 20,
23, 26, не помню.
Ну, короче, такая функция теперь есть.
Она побитого кастует одни int
к другим. Более явная
такая, типа, чтобы...
Ну да, да.
Но...
Тут смысл в том, что есть имплейнтный аргумент,
про который мы ничего не знаем. То, что он возвращается,
вообще нас не волнует. По выводимому
типу определять не умеем.
Вот. Вывод типов работает
и для классов.
Это, кажется, 17-ые плюсы.
Поправьте меня, если не прав.
А это даже 20-ые, по-моему.
Там было для
классов, а с 20-ых у нас и для структуры
работает. То есть
просто структура с двумя какими-то шнягами,
когда вы ее фигурными скобками
создаете экземпляр ее с этими
шнягами, оно само выведет какое-то
у вас должно быть.
Не надо.
Просто
вот так работает.
Даже
более сложно работает.
Ну, то есть
как на самом деле вывод вот этих вот
стаблонных аргументов класса работает,
мы выводим через конструктор.
Мы видим, что конструктор
вызван от
какого-то вектора int,
а тут вызывают от просто любого вектора.
Ну, сопоставляем их
и видим, что t значит int должен быть равен.
Правда?
И этот int сюда впендюриваем.
И все довольны.
Окей?
Окей. То есть, коль скоро
компилятор может доказать, что
такой вызов конструктора
мог быть только если
такой t был, он
с удовольствием вам выведет
и подставит и все будет хорошо.
Но иногда все не так хорошо.
Здесь, конечно же,
будет ошибка.
Очевидно ли это вам?
Да.
Мы ему
не сказали, как из итератора понять
какой t будет на самом деле
внутри.
Вы-то сами знаете, что по итератору
можно понять t, если его разыменовать.
Или если два двуи точки
в value type сделать.
О том, что из этого более правильное,
вы лучше в домашке подумайте.
Но value type, по-моему,
самое правильное.
Поэтому нам надо подсказать компилятору.
Вот про это уже кто-то
сказал вроде, и, скорее всего, вы знаете
в самом низу штучка.
Непонятно, да, что это такое?
Непонятно, да?
Это называется
deduction guide.
Это правило, на самом деле.
И вот эту стрелочку надо считать
как следствие.
Если
конструктор slice
вызвали от
каких-то непонятных двух
шаблонных аргументов,
ну,
вернее так, вызвали от любых двух
одинаковых типов.
Мы какой-то набор
таких свободных
переменных заводим.
В смысле математической логики.
И вот вообще эта надпись
template класса итера, вот в этом контексте
надо как для любых
читать. То есть для любых
итераторов, любых классов итеров,
если вызвали
конструктор slice от
двух таких типов,
то есть, грубо говоря, если
slice инициализировали от одинаковых
аргументов,
то надо в
шаблоне класса подставить
аргумент either value type.
Тут?
Где?
Если у тебя много deduction
гайдов и где-то из них
свинае, ну, нет. Давай так не будешь делать.
Пиши requires.
Нет, это скорее такое вопрос.
Допустим, у меня
именно сложен.
Ладно, свинае тут работает.
Да, это механизм,
который позволяет вам подсказать
компилятору, как
по вот такому вызову конструктора
понять, какой шаблонный аргумент
вы хотите видеть у самого
класса.
Я смог придумать, зачем я это мог бы хотеть.
Можно
вернуться? На самом деле здесь
уже используется свинае.
Потому что
если у итератора не окажется value type,
то, по-моему, это не будет ошибкой.
Да, я как раз про это
и хотел сказать. Где я увижу
ошибку? Я увижу, что
deduction гайд сломался или что
внутри что-то...
Я почти уверен, что оно будет перебирать
deduction гайды, пока не найдет тот, который...
Кто-то просто напишет, типа, стяло текста,
что все попробовал, ничего не получилось.
Да.
Поняли, о чем мы сейчас разговаривали?
Да. Круто.
Можно взять тоже? Да.
В deduction гайды можно
requires вписывать, насколько я помню.
Это поможет.
Стоп, то есть если я здесь напишу
requires, то он мне... Нет,
это не поможет с той проблемой, с которой я сказал.
А какая проблема?
Ну, если
нет value type, то он будет перебирать
все подряд. Да.
Но в этом смысл.
В смысле...
Даст вам лишь возможность
перегрузить deduction гайды.
Короче, так и задумано. Это by design.
Это не бага, не проблема. Так надо.
Это правильно.
Если назад проблема не проблема, то это не проблема?
Да нет, это...
Это с 17-х.
В домашке вам придется это написать.
Так что вот, если пока не понятно,
то просто вот...
Там простая задача будет, вы за один вечер
поймете, что такое deduction гайды,
а за второй вечер и третий
прокачайте свое понимание, когда вторая задача
будет выложена.
Да, и после этого такой код работает.
Потому что мы написали, если вызвали
от двух одинаковых аргументов,
а тут одинаковые begin и end типы
имеют да,
то тип нужно вывести как
тыры-пыры-пыры. Ну, у итераторов, конечно,
есть value type, у вектора.
Но кстати, это неправда.
Знаете, про что я?
Вот такой код, на самом деле,
не соответствует стандарту.
Плохо писать такой код.
На каком стандарте?
На любом.
Итератор trades, да.
Потому что
так сказать, compliant implementation
языка C++
может в качестве итераторов
для вектора использовать указатели.
И мы даже так делаем на работе.
Ну ладно.
Последняя тема
это что можно все-таки вписывать в шаблоны?
Вы думаете, что вы знаете?
Автом можно писать.
Автом можно писать.
Подожди.
Типом можно писать.
Да, ну можно
typeName класс
можно писать int.
А
про разницу между typeName и class знаете?
Нету.
TypeName и class одно и то же
в данном контексте, но есть такое
мнимоническое правило. В некоторых код базах
ему следует typeName, когда
вы имеете в виду любой тип,
а class, когда вы именно хотите
типа ООП, чтобы там именно класс был,
а не int.
Но это так.
Как вам удобнее пишите?
Int понятно.
А вот про такое.
Знаете, что такое?
Это указатель
на member function.
Это указатель на
member function.
Да, можно их
передавать. Указатель на функции.
Как пользоваться, в смысле?
Ну это указатель на функции.
Ну, ну, на F.
Ну, на F.
Ну, на F.
Ну, на F.
Ну, на F.
Ну, на F.
Шаблонные параметры.
Я предлагаю...
Есть сайт, короче, где все это
объясняется, но у него неприличное
название, поэтому под запись я не скажу.
Но на гуглите.
Но на гуглите.
Возможно, я в чат скину, да,
если не забуду.
Как этим пользоваться, лучше
сами разберитесь.
Например, можно написать этот
view, который проходит по всем
полям в структуре.
Много чего можно сделать,
но вот у нас сейчас на это времени нет.
Я с радостью объясню,
но только в следующий раз или после
следующий раз.
Да, можно
написать авто.
Понимаете,
что происходит?
Нет, нельзя. Я тебе запрещаю.
Кланг уронишь.
В кланге будет внутренняя ошибка,
если ты лямду сюда начнешь отправлять.
Я проверял. До сих пор.
Да, в кланге
с этим пока баги.
В компиляторе.
Фродик получше, но тоже не увидит.
Ну, короче...
А что ты захватывать в такую лямду будешь?
Честно?
Ладно.
Ну, это то же самое, что
указатели на функции будут.
Ну, короче, это да.
Так тоже можно.
Много чем,
но в данном контексте
ничем.
Давайте сосредоточимся.
Победный рвок, буквально там 5 слайдов,
по-моему, осталось.
Или 6. Надо добить.
И разойдемся с чистой совестью.
Декл-тайп от авто
можно сюда писать.
И авто можно писать. Разницы никакой.
Но смысл все этого
в том, что вы можете любой
тип сюда закинуть.
Можно инд, можно офлоут.
Можно? К вам вопрос.
Нет?
Снова стандартный пункт.
Можно. Только не нужно.
Потому что флоты не бывают равными.
Вы в курсе?
Да. Если вы там 3 умножите на 2
и 12 поделите на 2,
то вы разный результат получите.
И будут разные шаблоны. Разные специализации.
Да и большими не бывают.
Ну, короче, да.
И то, и другое можно. Работает одинаково.
Разворачивается вот в такой вот отрывок кода.
То есть оно как бы за вас
вот такую штуку пишет,
где вот этот инд первый.
Вводится автоматом.
И да, если для вас это новость, то
когда вы какой-то шаблонный аргумент уже написали,
в последующих шаблонных аргументах
вы его можете использовать.
Такое забавное наблюдение.
Да, не помню.
Я не помню. Там шаблонный-шаблонный параметр или...
Короче, в домашних тоже используйте,
скорее всего, там столько всего намешанного,
что тоже пригодится.
Можно указатели передавать внезапно.
То есть
то, где в бинаре
будет лежать
какая-то переменная,
это оказывается,
статическая переменная, это оказывается
compile-time-информация,
и можно ее и в шаблоны запихать.
И вот для меня это, если честно, было сюрпризом.
Я надеюсь, это не вранье.
Я сейчас задумался, а как это?
Каждый год, видимо, задумываюсь.
Каждый раз удивляюсь.
Там нужно, наверное, чтобы
у указываемой величины
были кратст-экспорт
каким-нибудь методом.
Вот так работает.
Если тут int заменить, то там уже начинаются детали.
Было бы просто странно,
если бы оно работало всегда,
потому что мы можем взять, например,
STD string нельзя шаблонным параметром сделать.
А указатель на STD string?
Может.
Мне кажется, да.
Так это же число просто.
А string это...
Давайте.
Что? Амперсант?
Нет, ссылки сюда пихать нельзя.
Потому что...
Не знаю. Даже с указателями
это странно достаточно, если задуматься.
Куда мы указываем?
Вот эта вот...
Подстановка шаблонов
происходит в момент
интерпретации кода AST
компилятором.
Куда мы указываем-то?
Непонятно.
Видимо, оно семантически
таскает за собой... Помните, мы говорили,
что вообще-то адреса всяких разных штук
это заглушки, а потом на этапе линковки
они подставляются.
Рискну предположить,
что здесь эта самая заглушка
именованная вместо адреса
таскается за собой, и везде,
где она используется, эта заглушка будет потом
подставлена линковщикам.
А, то есть мы теперь еще и
в процессе линковки будем расставлены?
Ну, чем больше мы используем
здесь
этот указатель,
тем, видимо, да, тем больше линковщику
работы будет.
Что?
Адрес на пространстве?
Да нет, просто про то, что
вот это может быть не какая-то статическая переменная,
а какая-то экстерна. И тогда мы не знаем.
Фиксированная может быть
реферия?
А, или компиляция фиксирована?
На этапе компиляции фиксирована
должна быть. Ну, вернее, на этапе линковки
оно уже понятно какое.
А вот на этапе компиляции
подстановка происходит, да, поэтому там вот есть
некоторые детали. Ладно, давайте дальше. Мы опять
надо наращивать темп.
Теперь можно так. Смотрите,
не говорите, что не видели.
Структура
запихнута в
шаблонный
аргумент другой структуры.
Есть ограничение.
Да, это должен быть какой-то супертривиальный
подтип там со всеми ограничениями,
что только можно.
Много чего можно.
Да.
Да, внимание, вот тут
как бы возникает вопрос,
а когда мы считаем
две инстанциации шаблона,
я сказал плохо,
две специализации,
да, когда
мы считаем, что вот
два набора шаблонных аргументов
должны нам в итоге дать
одинаковую специализацию.
Когда специализации равны,
когда нет, да, побитого.
Вот всегда. То есть
если вы, может
такая надежда у вас возникнуть, что если вы оператор
равенства для определить,
то он равный,
вот здесь вот значение v запихнет в одну
как бы специализацию, но нет,
такого не будет.
Наверное, когда это сделают,
если еще не заложишь,
если констакт сколько будет,
нет, не надо.
А еще да,
но ты там
можешь выдернуть какие-то
непонятную, скрытую информацию,
ты можешь достать, потому что бывает
вика, квалит и всякие.
Это следующая или после следующей лекция, короче,
про равенство и что это такое.
Да, ну на это посмотрели,
вроде понятно, да, сюда подставили
а инициализированный ничкой-двойкой.
Следите за руками,
сейчас будет сложно.
Давайте,
скажите, если назад нужно
отмотать
для сравнения.
Было так?
Стало так.
Ну все хорошо.
Ну окей, ну добавили шаблон, да?
Нормально, но тут-то ничего не изменилось.
Вам не кажется это безумием,
что мы выводим шаблонный
аргумент шаблонного аргумента в момент
подстановки шаблонного аргумента?
Мне кажется, это прекрасно.
Да, последнее, что
видимо мы сегодня успеваем, потому что нас сейчас уже выгонять будут.
Что?
Ну короче говоря,
вот у нас в S есть A,
у A шаблонный параметр T.
Вот можем как-то, может быть, с ним
поменять, чтобы внутри S-T использовать,
если у A не нафисно юзинга?
Думаю, нет.
Напиши юзинг.
Как бы, нет, в плюсах
такими вещами не занимаются.
Может дикл-тайп от FST?
Побитого.
Должны T совпасть?
Должны совпасть T,
а потом должны совпасть побитого
представления.
Да, и последнее,
последнее, кажется.
Шаблонные, шаблонные параметры.
Любите шаблонные, шаблонные параметры?
Да.
Ну, давайте,
про то, как это надо понимать в голове.
Вот есть значение,
а есть функции.
Функция это отображение между значениями, так?
На вход даете одно значение,
на выход получаете новое значение.
Есть типы,
а есть отображение между типами.
Это шаблоны.
На вход шаблоны вы даете один тип,
на выход получаете другой тип.
Согласны?
Ну, шаблон
тогда очень похож на функцию.
Шаблон для типов
это то же самое, что и функция
для значений.
Вот абсолютно то же самое.
То есть это нужно понимать
как такой указатель
на метафункцию.
Некоторая метафункция,
которая на вход берет один класс,
а на выход выдает другой класс
и имя этой функции T.
А дальше мы вот здесь
берем и вызываем эту функцию
от int.
На выход получаем какой-то другой тип
и заводим переменную такого типа.
Не уверен, где здесь композиция.
Не уверен, где здесь композиция.
Не уверен, где здесь композиция.
Ну, скорее не композиция,
а отображение из шаблонов
во что-то еще.
Ну, короче, это функция.
Ладно, нет, вру.
Так, по одному,
по одному.
Давайте дальше
вот оставим на потом.
Вот это?
Презентация все будет.
Презентация все будет.
Я сегодня вечером все выложу.
Так.
Какие-то вопросы были.
Проблема в том, что...
Логика такая. У тебя есть типы...
Стоп, нет.
У тебя есть значения.
Значения это некоторые абстрактные шняги.
Их можно отображать друг в друга функциями.
На вход функция
ты дала одно значение,
на выход получил другое значение.
Теперь поднимаемся на уровень выше.
Мета начинается.
Есть типы.
Если...
Да, есть шаблоны.
Шаблон это такая метафункция,
которая на вход получает один тип,
на выход подает другой.
Точно так же, как обычная функция
на вход значения получает,
и на выход другие значения.
Мета функция на вход типы получает,
и на выход типы дает.
Вот это указатель на метафункцию.
Наш шаблон.
Да.
Грубо говоря.
Ну, как указатель на функцию
можно передать в другую функцию.
Так мы в один шаблон.
Сколько конкретно указатель на шаблон?
T.
Вот это вот имя T,
это указатель на шаблон.
Какой шаблон?
Шаблоны разные бывают.
Который берет на вход один класс
и дает на выход другой класс.
То есть это как указатель
на функцию который ты передаешь
в другую функцию,
только указатель на шаблон,
который ты передаешь в другой шаблон.
У нас в качестве шаблона
идет указатель на другой шаблон.
Да, в качестве шаблонного аргумента
идет указатель на другой шаблон.
Да, только его указателем обычно не называют,
но это хорошая интуиция.
Оно как указатель на функцию,
то только на шаблон.
И как разница между функцией
только вот здесь класса и шаблон класса.
Ну, тоже может быть.
Мне не очень нравится такая интуиция.
Ну, все, что поможет вам помочь,
поможет вам понять, все хорошо.
Но мы эту функцию можем использовать.
Мета-функция, да?
Мета-функции вызывают с треугольными скобками.
Вызвав эту мета-функцию от типа,
получаем другой тип.
Да?
Это я напоминаю.
Это может быть алиас.
И этот алиас может все инты отображать в буль.
Или все другие типы отображать в буль.
То есть не надо думать, что это какой-то вот именно
строго шаблон-шаблон.
Это просто отображение куда-то,
непонятно куда.
А можно так писать указания или автозиции?
Ну, то есть, короче, вот после
deplay класса,
какая-нибудь сигнатура?
С шаблонами функции нет.
Пока нельзя?
Нельзя.
Куда мы отображаем?
Только типом.
Вот в этом ограничении этой системы.
Казалось бы.
А что мешает вот здесь вместо класс написать, например,
буль?
И передавать шаблон переменной?
Вот было бы классно.
Нельзя пока.
Не сделали.
А может, чтобы отображение к классу еще
возвращало мета-функцию?
Нет.
Тоже нельзя.
Я понимаю.
Ты, видимо, функционально увлекаешься, да?
Нет?
Ну, есть что-то, какая-то зерно в тебе.
Чего?
У тебя ограничение, кажется, не должно,
потому что мы всегда можем просто делать шаблонный класс,
у которого будет вот эта единственная функция.
Да, да.
Аккумулятор мог бы за нас оборачивать.
Да, хаками можно все ограничения обойти,
поэтому не хотят добавлять новые вот эти вот всякие сущности,
но вот как есть.
Слушайте, я хотел про специализацию успеть еще сегодня,
но нифига мы не успеваем.
Мне очень грустно.
Отвалилась, да?
Про явные специализации.
Не хотим, не успеем.
А ты хочешь камеру забрать, да?
Нет, просто пришел посмотреть.
Мне в целом неважно, если...
Давайте за 4 минуты.
Вот сейчас прогоним.
Вот специализации есть.
Есть явные...
Да, все это называется явные специализации, если что.
То, что вы до сих пор просто специализации говорили,
добавьте слово явное.
Потому что просто специализация, как мы уже выяснили,
это любой тип или функция, получаемая по шаблону.
Можно написать явную специализацию для каких-то конкретных аргументов шаблона.
И есть там полные, соответственно, и частичные.
Ну, я надеюсь, вы это видели уже раньше.
Не новости для вас.
Вот для функций нету частичных специализаций.
Так сделано специально, потому что иначе можно сдохнуть.
Реально.
Правила вызова функций и понятия, какую функцию по какому имени вызывать,
в ней уже космические, мы это увидим.
Если бы к ним еще частичные специализации шаблонов добавились...
Они бы были бы вообще разрешены.
Ну, наверное.
Просто бомба была бы.
Короче, невозможно работать.
Тем более функции перегружать можно.
Вы можете два разных шаблона функций сделать
с одним именем, и они будут друг к другу перегружать
специализации, получающиеся из них.
И все будет ток.
А алиасы и концепты вообще нельзя, да?
Про алиасы, по-моему, это не совсем правда.
По-моему, можно все-таки специализации писать для...
Да.
Можно явные специализации писать, по-моему, полные для юзингов.
С недавних пор.
Надо поправить презентацию.
Для концептов специализации делать нельзя явных.
Кажется, в 2017 году вроде нельзя было, а в 2020 можно.
Ну, вот да.
Кажется, я забыл обновить.
Надо...
А вот еще раз.
Неявная специализация — это что?
Явная специализация.
Неявная.
А это когда вы просто используете этот тип с каким-то шаблонным
аргументом, и компилятор за вас идет, находит главный
шаблон, и из него генерируют путем инстанциации новую
специализацию.
Наверное, просто функция качества аргумента передает
какое-то значение, и он понимает тип этого значения
и подставляет шаблон в бликах.
Когда компилятору надо вывести тип, тогда это не явно.
Да.
Ну, на самом деле нет.
Наверное, проще сказать, что понимается под явной
специализацией.
Да.
Неявные специализации — это те, которые генерируются
по главному шаблону.
Плохо, да?
Короче, вот.
Все, что будет сгенерировано из этого шаблона, например,
вот таким путем, это неявные специализации.
Они сами сгенерированы компилятором.
Код для них просто по шаблону получается.
Ну и, соответственно, вопрос.
Что это за код?
Будет работать?
Не будет?
Что-то происходит.
Ну, работает он будет?
Нет.
Почему?
Да, потому что, чтобы про TypeCheck вот это выражение,
нам нужно понять, какой тип имеет каждый из под выражений.
Так?
Ну, компилятор TypeCheck делает, чтобы убедиться, что у вас
нет ошибок с типами.
Да?
Ну, то есть нужно и n-2, и n-1 инстанцировать, чтобы
понять, какой тип у них.
Ну, то есть понять, какая специализация и какой тип.
Сразу понять нельзя.
Как и раньше, зависимые имена, вот это все, мы не знаем,
какая специализация будет.
Ну, поэтому оно будет до бесконечности брать и в
обе ветки идти, и обе их инстанцировать.
Ну, как бы да, но это не поможет.
Просто сдохнем.
Поэтому, чтобы поправить, как раз вот эти штуки есть.
Вот это явные специализации.
Мы взяли и выбрали конкретный набор аргументов, для которых
тело сущности написали руками.
Оно не по основному шаблону генерируется.
А мы явно выписали, как эта специализация должна выглядеть.
То есть специализация для нуля выглядит вот так.
Специализация для единички выглядит вот так.
Вот, собственно, почему явное и неявное, говорится.
То есть большая часть специализаций, получающихся
в результате инстанциации этого шаблона, они по главному
вот этому вот главной части.
Да, они не явно получаются из главной части.
По-моему, это тоже называют главной специализацией.
Но это плохо так.
Надо уточнить терминологию.
Но, короче, они вот из этого куска получаются.
И только два случая, когда вот нам не подходит общий
алгоритм получения специализации, мы явно прописываем
какой-то каштомный способ получить специализацию.
— А вот там уставить, чтобы у нас не было в бинареи, да?
— Чтобы они в компелтами считались.
Конст-экспорт-переменные инициализируются в компайл-тайме,
а также являются константами.
То есть их варентаймер менять нельзя, а инициализация
их происходит в момент компиляции прямо.
— А если не писать, почему будет?
Там же тоже будет комплей-тайм?
— Ну, вообще да, но как бы...
— И не было в бинареи?
— Да нет, конст-экспорт-переменные в бинареи включиться могут.
Например, если ты адрес возьмешь.
Давайте отложим этот разговор, опять в детали вдаемся.
Разговор про конст-экспорт в следующий раз, возможно, будет.
Но вот то, что на прошлом слайде было, это всё фигня,
потому что теперь так можно делать.
Это просто функция, которая вычисляет рекурсивные числа Фибоначчи.
Я наляпнул сюда конст-экспорт, ну и всё.
Я уже могу её в статических контекстах использовать
в константных выражениях, можно в другой шаблон
подставить в качестве аргумента вызов этой функции.
Просто потому что конст-экспорт.
Про конст-экспорт потом будет ещё, либо сами почитайте.
— Там же ещё главное преимущество, что мы можем эту функцию
юзать, когда мы эти 49 в рантайме-то поузнаем.
— Да. — Шаблоны бы так не получили.
— Да, вот такую функцию можно и в рантайме, и в компайл-тайме
юзать, это здорово. — В конст-вал есть?
— Есть, потом про него поговорим.
Зачем нужны вообще специализации?
Например, вектор булей делать. Узнайте, как вектор булей работает.
Любите вектор булей? Ну вот да, он особенный.
Это вежливо так говорить сейчас.
Да, да, да.
Но можно ещё всякие тайп-трейцы делать.
Например, снимать указатель с типов.
Вот это вот частичная уже специализация.
Там была полная, а это частичная.
Чувствуете, в чём разница?
— Мы сказали, что теперь для любого указателя.
— Да. То есть мы как бы берём и не конкретный один набор аргументов.
Явно прописываем специализацию ему.
А все наборы аргументов, которые выглядят примерно так, вот как указатели.
— Получается, сейчас можно всё упрать в просто алиасы?
— Сейчас не уверен.
— Или полное? — Не уверен. По-моему только полное.
Поиграйте сами.
Понятно, что это делает, да?
Если мы подставили аргументу, у которого есть звёздочка,
то это будет в другое правило.
Если нет, то в другое правило, и будет какая-нибудь ошибка.
Если вы когда-нибудь писали на Хаскеле или чём-нибудь подобном,
это вам, на удивление, кажется знакомым.
В этом есть глубокая истина, но у нас нет времени на неё.
Да, это именно он.
Это последний слайд.
Вы представляете, это последний слайд.
На нём я хотел показать следующую мысль,
вот класс T, его можно дальше использовать,
как угодно, в других шаблонных аргументах.
Давайте его в буль засунем,
вернее, какое-то выражение,
зависящее от вот этого T, засунем в буль.
А потом сделаем две специализации частичные,
одну для true, другую для false.
То есть мы таким образом можем выбрать,
порезать пополам семейство множества специализаций,
которые могут получиться в результате инстанциации нашего шаблона.
Мы его пополам бьём вот этим бульом.
Одну половину здесь реализуем, другую половину тут.
А можно и не пополам, можно и на четыре, на восемь частей,
вообще как хотите.
Да, конечно, тут всё compile-time должно быть.
Вот, на этом у меня всё.
Не кодить мы не идём,
мы слишком долго, слишком долго.
Все, что пришли, все свободны.
