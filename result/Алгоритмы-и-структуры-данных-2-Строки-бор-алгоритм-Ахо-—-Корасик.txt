Так, мы продолжаем говорить про строки, сегодня всякие
вариации Бора рассмотрим, Бора алгоритма Хкараси.
Ну, определение, Бор это корневое подвешенное дерево, на ребрах которого написаны буквы из алфавита.
Причем есть еще одно важное ограничение, что если из вершины исходят несколько ребер,
то на них на всех должны быть попарно различные символы, то есть для любой вершины В из нее не
исходить двух ребер, на которых написаны они те же символы.
Так, например, давайте тут нарисую, ну вот есть какой-то корень дерева, давайте вот так обзову
рут, из него могут быть какие-то стрелочки, какие-то ребра, на них на всех написаны попарно
различные буквы, там не знаю, а, б, д, у, опять вот есть вершины, из них могут исходить какие-то
ребра, но главное, что исходящие из одной вершины ребра все должны быть с попарно различными символами,
а, т, х, здесь там тоже, например, не знаю, а, с, ну и так далее. Главное требование, что из вершины не
может быть такого, не может быть вот такого, что есть вершина, из нее есть два ребра с одной и той же
пометочкой, скажем, с, ни с какой фиксированной пометкой не может быть два одинаковых исходящих
ребра. В остальном это просто дерево, на ребрах которого написаны буквы. Вот, значит, в таком
определении давайте скажем, что такое построить бор по множеству слов. Значит, ну нам нужно построить
такое корневое дерево, чтобы, ну давайте я множество слов пронумерую, s1, s2 и так далее,
я хочу построить такой бор, чтобы из корня этого бора можно было все вот эти вот n слов прочитать,
то есть мы идем сверху вниз, читаем просто по буковке, буква, буква, буква, буква, так доходим
до какой-то вершинки и вот эта вот последовательность букв, которые мы считали, должна совпадать с одной из,
с одним словарных слов и больше никакие другие слова не должны читаться. Ну давайте какой-нибудь
пример нарисуем, я не буду формально здесь расписывать, например, у меня есть строчка там
aba, есть строчка ab, есть строчка там ac, есть строчка, скажем, ct. Тогда бор для нее будет такой,
есть некий общий корень, а затем можно его строить очень просто, значит, давайте сначала построим путь,
по которому читается слово aba. Вот читаем aba и давайте последнюю вершину на этом пути пометим
терминальный. Это знак того, что в этой вершине заканчивается какой-то из вот этих вот словарных
слов, из тех слов, по которым мы строили бор, вот здесь одно из них заканчивается. Давайте такие
вершины помечать жирным кружочком, я буду называть их терминальными. Терминальная вершина, так где
что-то заканчивается. Ну дальше ab, понятно, вот этот путь у нас уже есть ab, мне нужно просто вот
этой вершины пометить терминальный, сказать, что здесь опять заканчивается какое-то слово, да, вот
это вот s2, оно в точности здесь заканчивается. Дальше скажем ac, ну понятно, здесь я буквку a могу
прочитать, а дальше не могу, поэтому мне придется витвиться и создать новое ребро с пометкой c. И
уже вот эту вершину пометить терминальный. Просто каждая вершина соответствующая концу какого-то
слова, мы помечаем ее сразу жирным кружочком, говорим, что она терминальная. Ну и наконец,
если мы хотим прочитать снова ct из корня, то нам придется оба эти ребра добавлять и по c и
по t, не нужно добавить новый ребро и сказать, что это вершина терминальная. Вот, то есть по сути
алгоритм построения бора по данному мнению слов очень простой. Мы идем и пытаемся как можно больше
первых символов сопоставить с тем, что уже находится в боре, да, вот как здесь мы ab, мы шли по тем
ребрам, которые, ну собственно есть, да, сначала есть ребро a, потом есть ребро b, мы вот здесь
заканчиваемся. Когда мы строили ac, мы сначала прошлись по ребру a, которая уже была в боре,
потом рибрации не было, его пришлось построить. Ну также в общем случае мы идем как можно дольше
сопоставляя ребра с теми, которые уже есть, а оставшийся кусочек строим, да, с какого-то момента
мне придется ветвиться в другую сторону и здесь будет такая длинная длинный путь, отвечающий
суффиксу слова, который мы еще не прочитали. Вот, и все концы вот этих путей помечаем терминальные
вершины. Так, это вроде понятно. Ну здесь как раз соблюдается свойство, что из вершины нет разных
букв, да, исходящих, вот такого, вот такого нету, потому что если бы было, да, если нам в какой-то
момент нужно здесь написать c, то мы просто прошлись здесь вниз и ну это, это ребро нет смысла заводить,
потому что можно просто прочитать эту букву здесь, да, нет, нет смысла заводить новое ребро. Так, хорошо.
Значит, ну давайте тогда поговорим еще о методах, как можно хранить этот самый борт.
Способ хранения бора. Ну здесь понятно, что как бы естественно для каждой вершинкой завести некую
структуру данных, да, каждый вот этот узел, это некая там структурка, но при этом есть несколько
возможных вариантов, как именно мы храним множество исходящих ребер, да, там, как мы
сопоставляем для каждой, для каждого символа алфавита ребро, куда, куда ведется, точнее конец
ребра, куда ведет этот символ. Ну здесь есть три классических способа. Первый это, значит,
имеется в виду, как храним переходы, как храним переходы по буквам. Значит, первый способ это
просто массив размера Сигмы. Просто для каждого символа алфавита мы храним либо там какой-нибудь
минус-одинечку, как знак того, что нет такого ребра, либо номер вершины или там указатель,
куда ссылается, куда мы попадем, если прочитаем эту букву. Например, в массиве размера Сигма по
номеру буковки С будет находиться ссылка на вот эту вершину. Отсюда будет вести ссылка сюда. Да,
конечно, сигма алфавит всегда у нас. Да, да, да, в каждой вершине, но я это не прописал, но сказал,
у нас есть своя структура для каждой вершины, структ нод какой-нибудь, да, и так вот в каждой,
в каждой точке, в каждом узле у нас своя нода, своя структурка. И внутри каждой структуры мы
хотим понять, как именно мы храним множество переходов. И вот это вот то, что я обсуждаю,
это то, что находится внутри этой ноды для каждого узла нашего бора. Да, в каждой вершине. Так,
сигма это алфавит. Второе, это, ну, какое-нибудь дерево поиска. Ну, для наших целей будет хватать
стд мап. Просто мап, скажем, из чар в нод-звездочка или в инт, если у нас будут вершины
каждому символу сопоставляет то, куда мы попадем, если прочитаем этот символ, либо если этого символа
нет, да, если нет, скажем, вот здесь вот нет ребра, исходящего по букве А, значит просто, ну,
там нет такого элемента, да, в этой мапе нет такого ключа. И третье, это какая-нибудь хэштаблица.
Про хэштаблицы мы с вами немножко говорили в прошлом семестре, когда нам нужно поддерживать, да,
какое-нибудь, какое-то множество, добавлять туда ключи и удалять, то в принципе хэштаблица тоже
с этой задачей справляется. Особенно, ну, когда у нас вот так не очень много данных. Вот, значит,
в чем преимущество всех методов. Так, так, так, ну, давайте, давайте нарезать такую тупую табличку.
Значит, массив, мап и хэштаблица. Нам важны две операции. Первая, это, ну, грубо говоря, перейти по
ребру. Вторая, это создать переход, ну, то есть создать ребро, да, завести новый переход. Ну,
и последняя, это создать вершину. Сейчас поясню, что имеется в виду. Смотрите, перейти по ребру,
это когда я стою в вершине в какой-то В, и у меня есть некое множество ребер, а мне говорят,
что мне нужно сейчас прочитать там букву С. И, соответственно, перейти по ребру, это значит понять,
есть ли переход по букве С, и если есть, сделать переход, да, то есть найти среди вот этих вот
исходящих ребер то, которое помечено буква в кольце, и понять, куда оно ведет. Вот, что такое перейти по
ребру. Ну, в массиве это, понятно, занимает от единиц времени. В мапе от лог К, где К это количество
исходящих ребер. Вот, ну хэш таблицы, это будет занимать от единицы в среднем, ну, точнее,
амортизированного в среднем. Да, потому что у нас там, во-первых, есть случайность хэш таблицы,
поэтому у нас оценки все только в среднем. Во-вторых, там есть амортизация, потому что пост,
когда насыщается хэш таблица, мне нужно сделать перехэширование, завести таблицу размером
в два раза больше, поэтому там еще появляется амортизационная оценка. То есть, каждое конкретно
может работать долго, но суммарно в среднем можно считать, что каждый работает за единичку. Дальше,
ну, создать ребро это в случае, если перейти по ребру не удалось, а надо, да, мне нужно было
прочитать какую-то букву в куце, такого перехода не было, значит, нужно его создать. Ну, в массиве
это опять-таки работает от единицы, мне нужно просто в массиве длины сигма там, да, взять элемент
с номером c и провести ребро в нужную только что образовавшуюся вершинку. В мапе это вставка
ключа, да, по значению, за логарифом работает, в хэш таблице опять единица в среднем, амортизированная
единица в среднем, потому что это просто, ну, инсерс хэш таблицы. Вот, а создать вершину это
подразумевается, что вот, когда, когда у нас нужно было прочитать букву в куце, а здесь ее не было,
тогда нам нужно завести новое ребро, пометить его буковкой c и завести вот здесь вершину,
соответственно, создать новую структуру здесь, создать новый нод здесь. Вопрос, сколько нам
нужно времени, чтобы создать новый нод. В случае с массивом от сигма, ну, от мощности сигма,
потому что мне нужно завести массив, да, на каждый символ алфавита, это занимает вот столько
времени и столько же памяти. Ну, а с мапой хэш таблицы все проще, здесь просто чисто единицы,
потому что пустой мап, пустая хэш таблица создаются за от единицы. Так, вопросы есть? Вот здесь.
Ну и вывод какой? Вывод зависит, собственно, от того, какие у вас есть ресурсы. Если у вас есть,
так, да, я бы сказал так, если у вас есть много памяти, то предпочтительный вариант это массив,
потому что все операции с проходом по ребру выполняются за единицу, ну, а это просто создание,
выделение куска памяти работает довольно быстро. Поэтому, если у вас есть память на то, чтобы,
если у вас достаточно много оперативки, чтобы для каждой вершины хранить вот прям столько значений
и создавать их каждый раз, когда создаете вершину, то предпочтительный вариант это массив, если
доступно много памяти. Если же с памятью проблемы, то лучше использовать мап, время ухудшится не очень
сильно, потому что, ну, здесь была единица, остался всего лишь логарифм, где k не больше, чем стигма. Да,
мы понимаем, что число исходящих ребер не больше, чем размер алфавита, поэтому эти логарифмы будут,
ну, от довольно небольшого числа, в принципе, тоже поправка будет не очень большой. Значит, это хорошо,
если, ну, мало памяти, мало памяти. Вот, хэштаблица, в принципе, хороша всегда, но нужно помнить вот про вот
эти вот. Во-первых, оно не очень просто пишется, если что-то самописное делаете. Во-вторых,
здесь все оценки, они в среднем и амортизированные, на это надо тоже закладываться. Да, понимаю,
что с какой-то вероятностью у вас алгоритм может работать долго. Давайте так я напишу. Хорошо,
если не требуется гарантировать, что оно всегда работает быстро. Если не требуется эффективность
в 100% случаев. Ну, это вот стандартные наши приколы с вероятностными алгоритмами. Они
работают почти всегда хорошо, быстро, но иногда там, не знаю, раз в год может быть такое, что вы
плохо подобрали хэши, у вас все вырождается там. Ну, здесь не вырождется, но, короче,
здесь будет ООК везде. В худшем случае вам нужно пройти всю хэштаблицу, чтобы понять,
есть ключ или нет. И здесь тоже ООК. Из-за того, что вы там как-то плохо выбрали хэш, у вас может
быть вообще время работы здесь, короче, вырождаться. Не очень сильно, но все-таки
иногда такое бывает. Если вы хотите написать систему, которая всегда работает безупречно,
никогда не зависает, то, наверное, это не для вас. А если там, не знаю, раз в годик можно и полагать
немножко, то, пожалуйста, хэштаблица в остальные 355 дней в году, она будет работать быстрее,
чем все остальное. Ну, конечно, хэштаблица, она же как работает? Она заводит массив размера
примерно в два раза больше, чем число ключей, там максимум 2К. И чтобы проверить, есть ли там
переход, она по сути просто с какого-то момента идет и пытается его здесь найти до первой пустой
клетки. В худшем случае она пройдет всю таблицу, то есть максимум отка. Да, конечно, ну, собственно,
вот вы правы, да-да-да, конечно. Здесь я имел в виду, как бы, если есть много памяти, и можно в
каком-то смысле эффективно ее выделять. Да, если алфавит большой, там, не знаю, тысячи,
десятки тысяч символов, то, наверное, не очень получится ее просто выделять, ну и вам просто
памяти даже не хватит, не говоря про время. Сейчас, секунду. Так, вот оно как, а, это количество
исходящих ребер из вершины. Ну, и с той, в которой мы стоим, вот если мы находимся в вершине В,
и нас спрашивают, есть ли переход по букве С, при этом из нее исходит К ребер, то тогда ответ
на этот запрос работает за единицу в случае массива, ло К в случае мапа и в среднем за
амортизированную единицу в случае х-таблицы. Ну, это вот как мы стоим в вершине, нам поступает
запрос какая-то параметра вершины. Да. Ну, не совсем, мы скорее для каждой буквы говорим,
что нет перехода, да, то есть для каждой из сигма букв мы говорим, нет перехода по А,
нет перехода по B, нет перехода по C и так далее. То есть мы, я сейчас буду писать код для массива,
там будет типа мы создаем массив, заполненный минусы единицами, как знак того, что нет перехода.
Ну, то есть мы не можем создать пустой массив и потом вставить там по букве С, это уже мап,
по сути. Мы скорее для каждой буквы говорим, что нет перехода. Вот, ну и давайте, значит,
алгоритм построения Бора, ну, на массиве, на массивах. Сейчас напишу простой код,
и пойдем дальше. Значит, что мне нужно от вершины? Мне нужен список переходов,
давайте я назову этот массив 2, он будет у меня размера сигма, да, где сигма это, ну,
размер алфавита. И мне нужен флаг терминальности, bull term, я вот так назову. Терминальная или
не терминальная вершина, да, заканчивается в ней кто-то или нет. Значит, ну, конструктор
по умолчанию будет такой, мы создаем вершину без остатейших ребер и по умолчанию не терминальную.
Для этого мне нужно вот здесь вот все значения в массиве 2 заполнить каким-то фиктивным числом,
я привык это делать минус 1, и это можно писать так, memset tu-1 sizeof tu. Еще раз?
Long звездочка? А, нам достаточно интов, у нас будут все вершины пронумерованы сквозной
нумерацией, нам даже не нужны вот эти ноут звездочки, у нас ничего удаляться не будет,
поэтому указатели не нужны. Ну, то есть, да, да, иногда, конечно, бывают задачи, где нужно удалять
вершины, но это редкость скорее, поэтому всегда достаточно интов, ну, зачастую достаточно интов.
И по умолчанию вершина не терминальная.
Так, дальше, я завожу вектор вершин, который назову, ну, скажем, T. По-английски BOR это,
кстати, try, поэтому T. Ну и процедура добавления некого слова в наш BOR.
Add какой-нибудь строчку S, const string S. Значит, приняли строчку, хотим ее добавить в BOR.
Стартуем в корне, считаем, что в дереве всегда есть, ну, в этом BOR всегда есть корень, да, то есть,
где-то мы еще там. Ну, давайте, давайте проверочку здесь сделаем. Момент. Значит,
если BOR пусто, его нужно создать, нужно просто в него корень положить, это просто T pushback нод.
Если, если у нас никого не было, вот это список вершин, да, просто перечтение вершин,
наливая первые, вторые и так далее, описание всех вершинок. Если это пустой BOR, то мне нужно
сначала создать корень, я его просто добавляю pushback вершины, ну, вот, как бы, без начинки, да,
вот, по умолчанию запомнил. Дальше я встаю в корень, говорю, что V это корень, потом мне
нужно идти по строке S и прочитать как можно больше первых его символов, которые, ну,
по которым есть переход в V. То есть, я иду по строке S, так, и меньше S точка size.
Значит, дальше, если есть переход из V по S item, то я его делаю. Если нет,
тогда нужно его будет создавать. Давайте, напишу так, если нет перехода, то есть,
T в это, точка tu от, давайте, я буду считать, что у меня алфавит, это маленькие латинские буквы,
тогда, соответственно, номер буквы в массиве, это просто вычитание из чара символа A. Поэтому
здесь я пишу S и T минус A, минус символ A. Так вот, если нет перехода по такому символу,
то есть, если здесь минус единица, то значение, которое по умолчанию там стояло, тогда нужно
этот переход создать. Ну, это можно сделать так. T точка size и T pushback вершины без значинки.
То есть, перехода не было, я его создал, говорю, что переход ведет в вершину вот с таким номером,
а дальше сразу создаю вершину с таким номером с помощью pushback вершины без значинки. Скажем,
если в боре было всего 5 вершин с номерами от 0 до 4, тогда, соответственно, я создаю вершину,
говорю, что в нее ссылаются под номером 5, и добавляю пятую вершину в 0 индексация, пятую
вершину без значинки. Просто завожу ребро по нужному мне символу S и T. Вот, это в случае,
если перехода не было, я его создал. А дальше я просто спускаюсь по этому переходу.
Если перехода не было, я его создал. Если был, он и так остается. И в любом случае я должен
сделать переход, чтобы пройти вот этот путь, мне нужно эту букву прочитать из текущей вершины.
То есть, вместо V написать TV to вот это вот S и T. Все, и в конце, после этого фора мы прочитали всю
строчку S. Там, где надо было, разветвились и создали новый путь. В конце нужно не
забыть пометить эту вершину терминальной. Все. Вопросы?
Тогда я в асимптотику. Асимптотика добавления строки S, это у нас длина S на мощность алфавита.
В худшем случае, потому что в худшем случае мне придется создать вот столько вершин,
в каждой из которых вот столько элементов массива. То есть, вот столько времени,
столько памяти в худшем случае тратится на создание пути, отвечающего некоторому слову.
Задача.
Нужно научиться поддерживать множество целых чисел S с двумя типами запросов. Первый тип
запроса это вставить X в множество, то есть добавить X в S. Второе, ну это давайте просто find X,
проверить, есть ли X в S. Как решать с помощью Бора? Что? Да, например так, можно просто вот это X
воспринимать как строку над алфавитом 0, 1 и так далее, 9. При инсерте, соответственно,
создать Бор над алфавитом из десяти символов, при инсерте нужно просто добавлять эту строчку в
Бор, чтобы проверить, есть ли это число в Боре в множестве или нет. Нужно пройти опять вот этот
путь, который отвечает слову X. Если мы в конце оказались в терминальной вершинке, значит это слово
есть в нашем множестве. Да. А мы их храним. Еще раз.
В каком-то смысле да, сейчас я про удаление тоже скажу. Давайте запишу. Бор над алфавитом от 0 до 9,
инсерт это добавить X как строку в Бор, find это пройти путь отвечающий X,
ну и проверить стоит там терминальность или нет. Проверить терминальность. Да,
значит прозвучало справедливое замечание, что в этом случае можно и рейс тоже делать,
то есть удалять число из множества тоже можно. Для этого нужно просто опять прочитать X в нашем
Боре и заменить терминальность на нетерминальность. То есть если X было в множестве, а нужно его
удалить, то нужно его опять найти, прочитать вот этот путь от корня до вершины соответствующей
концу X и снять терминальность. То есть если там был терм равен true, то нужно его заменить на false.
Это удаление. То есть в принципе рейс тоже здесь можно сделать. Единственный как бы недостаток в том,
что у вас, ну если например там вы сначала добавили 10 чисел, а потом удалили 10 чисел,
то у вас как бы будет какой-то Бор с десятью путями, но здесь все вершины будут равны,
ну как бы все вершины нетерминальные. В каком-то смысле вы храните просто мусор,
который ничему не соответствует. И у вас тогда как бы размер вашей структуры не пропорционален,
а как бы даже больше, чем количество элементов в S. Ну да, да, да. Тут можно по-всякому это делать,
действительно. Например, если мы, да, в общем вы правильно сказали, можно просто в каждой вершине
хранить сколько есть терминальных в поддереве, вот здесь вот для этой вершины мы скажем храним
сколько здесь терминальных. Если мы в какой-то момент удаляем обе эти терминальные, то мы
понимаем, что тогда у этой вершины в поддереве ноль терминальных, и мы как бы ее можем просто
удалить. Все вот эти пути автоматически удаляются. Ну это одно и то же по сути,
как мы это реализуем? Мы все равно сначала доходим до конца, удаляем здесь терминальность,
если у нас нет детей, то мы удаляем эту вершину и идем вверх, пока не дойдем до вершины. Да,
есть сын, да. Поэтому удаление тоже как-то можно сделать, но обычно это даже не требуется. Так,
что-то еще есть вопросы какие-то? Хорошо, ну тогда вроде сбором разобрались.
Дальше переходим к алгоритму Ахкарасик.
Задача, которую мы будем стремиться решать такая, дано множество стоварных слов, дано множество
слов С1 и так далее, СН, дано текст Т. Ну и скажем в одной вариации нам нужно сложить,
узнать сколько суммарно есть вхождений всех вот этих слов в строчку Т. Найти суммарное
количество вхождений всех строк с первой по н-ую текст Т. То есть, грубо говоря,
для каждой узнать и все сложить и вывести это как одно число. Это одна постановка,
вторая постановка будет такая, задача штриха я назову. Все то же самое, только нужно вывести
все вхождения, вывести все вхождения вот этих наших строчек Т. Будьте здоровы.
Обычно вот эти слова, которые мы будем искать в тексте, мы будем называть словарные слова,
в том смысле, что есть некий словарик вот из этих слов, да, есть какое-то множество слов,
которые мы будем называть словарем, и мы ищем их вхождение в некий длинный текст Т. Не знаю,
зачем, но, например, там мы составляем контрольную по русскому языку, у нас есть список слов,
ну реально словарных, да, которые там надо знать, как пишутся, и мы проверяем, как часто они
встречаются в некотором литературном тексте. Нам нужно вывести все примеры их использования,
увидеть, где они в тексте появляются. Вот, например, так, да, есть множество слов, есть текст,
нужно найти все вхождения в этот текст. Значит, ну, какой-нибудь здесь там, понятно, есть совсем
тривиальное решение, можно для каждой строки решать эту задачу независимо с помощью, например,
алгоритма Кнута Морриса Прата, который мы на прошлой лекции разбирали. Например,
можем построить вот такую строчку, посчитать у него префикс-функцию и тем самым найти все
вхождения с, и, т, в, т. А дальше там префикс или z-функция, кому что приятнее, префикс или z-функция,
и на прошлом деле мы уже учились находить все вхождения вот этого сюда, но это работает за
вот столько для каждого и, и если у нас этих строк много, то у нас, значит, когда я просуммирую
все вот эти симптотики по всем и, у меня получится, ну, понятное дело, сумма длин всех строк s,
но зато перед t еще будет множитель n, плюс n на t, то есть я как бы независимо ищу вхождения
всех с, и, т, в, т, и поэтому здесь возникает вот такой множитель. В случае, если n большой,
это как бы убийственная симптотика, и, собственно, вот от этого множителя мы хотели бы избавиться,
что у нас все-таки не независимо каждая строка пытается попасть в t, а все вместе, и мы их все
вместе пытаемся туда уместить, и понять, где они там лежат.
Так, ну, первое, что мы сделаем для решения обеих задач, это, конечно, построим бор,
помножить условия с 1, так далее, с n. Построим бор по вот этим нашим словам на словам.
Так, давайте я такое даже не столько определение, сколько обозначение скажу. Я буду говорить,
что строка есть в боре, если ее можно прочитать из корня, то есть вот вы встаете в корень,
по буковке эту строку читаете и заканчиваетесь в вершине, не обязательно в терминале,
но в какой-то вершине. То есть ни в какой момент вы не пытаетесь прочитать букву,
которой нет, которого ребра нет. Будем говорить, что слово, какое-то s, есть в боре,
если его можно прочитать из корня. Если его можно прочитать из корня. То есть мы встаем в корень,
переходим по ребрам, отвечающим буквам строки s, и каждый раз этот переход можно сделать. То есть
всегда есть такой переход. В конце мы заканчиваемся в какой-то вершине. Она не обязательно,
повторюсь, не обязательно терминальная, просто какая-то вершина. Например, если есть вот такой
какой-нибудь бор, и вот эти вот вершины помечены терминальными, то какие слова есть в боре? Есть
в боре. Ну, во-первых, конечно пустое слово, эпсион, всегда есть в боре, потому что это просто
стояние в корне, ничего читать не надо, мы уже этот эпсион прочитали. Ну, дальше что? Есть a,
есть ab, есть ad, есть abc, abe, f и fg. Это множество слов, которые есть в боре. Окей? Скажите,
характеристическое свойство слов, которые есть в боре относительно вот этого набора строк,
s1 и так далее. Конечно, да, просто множество префиксов словарных слов. Множество тех префиксов
всех словарных слов. Вот, мне просто будет короче говорить словосочетание есть в боре,
чем префикс какого-то словарного слова. Дальше. Дальше, дальше, дальше. Дальше мне нужно
отождествить вершины и слова. Значит, чтобы немножко формальнее это сделать, смотрите,
у меня вообще говорят, да, все вот эти вот узлы это какие-то ноды, множество вершин,
ну, вершины и множество вершин. Я хочу отождествить вершины с путями, которые до них ведут. То есть,
когда я пишу вершина v, я одновременно имею в виду и точку, да, то есть какой-то структ нод в
нашем боре. И в то же время путь, который ведет от корня до этой самой вершины v. Существует
однозначное сопоставление вершин бора и множество слов, которые есть в боре.
То есть, то, что можно прочитать из корня, то, что можно прочитать из корня,
заканчивается в какой-то вершине. И всюду дальше, когда я пишу v, я могу подразумевать,
как вершину, да, там скажем номер вершины в боре, так и в то же время всю вот эту строчку целиком,
потому что между ними есть тривиальная объекция, да, каждое слово ведет в некую вершину и, наоборот,
по вершине восстановляется слово, которое в нее ведет. Поэтому я сейчас буду перемешивать номер
вершины и строку, отвечающую этой вершине. Так, вот, и, значит, ведя все эти предварительные
обозначения и условности, я могу вести определение. Значит, определение линк от v,
так называемая суффиксная ссылка для вершины v, это самый длинный собственный суффикс v,
который есть в боре. Самый длинный собственный суффикс v, который есть в боре. Вот, и здесь,
пожалуйста, я уже смешиваю строки и вершины, потому что, что такое суффикс v? Ну, конечно,
суффикс не вершины, а строки, отвечающие вершине, да, и в то же время здесь написано,
то есть как бы вот v, она же одновременно отвечает некоторой строке. Я рассматриваю все ее собственные
суффиксы, то есть суффиксы, отличные от всей строки, в порядке убывания длины. Сначала этот,
потом этот, потом этот, да, все такие суффиксы рассматриваю. Мне нужен из них самый длинный,
который можно прочитать из корня, который есть в боре. Скажем, вот эти два было нельзя,
а этот можно. Значит, линк от v будет вести в строку, точнее вершину, отвечающую вот этой
строке. Среди всех суффиксов мы оставляем самый длинный, который можно прочитать в боре.
Ну не столько путь, сколько последовательность букв написана
этом пути. Как слово мы и мы его воспринимаем. Давайте пример какой-нибудь нарисую.
Ну вот так, например. Вот пусть v это эта вершина. Договорившись вот об этом, v это не только вершина,
но и строка a, b, c, a. Да, есть биекция между словами, которые есть в боре, и вершинами,
поэтому v это в частности вот это вот слово. Давайте перебрать все собственные суффиксы этой
строки и найдем какой из них самый длинный есть в боре. Ну a, b, c, a это не собственный суффикс,
это вся строка, ее брать нельзя. b, c, a прочитать из корня нельзя, нет даже первого перехода по
букве b, а вот c, a уже можно. Вот он, переход c, a. Поэтому суффиксная ссылка от v будет вести вот
сюда. Линк от v будет равно этой вершинке. Окей? Ну и тогда второе определение. go vc это,
но никак не называется, это самый длинный, самый длинный суффикс, строки v плюс c,
которые есть в боре. Да. Нет, между всеми вершинами, между всеми вершинами и всеми словами,
которые есть в боре. Ну как вот здесь, например, вот это это epsilon, вот это это a, вот ab, это abc и
так далее. Symbol, v это вершина, вершины, t элемент sigma, т.е. t это один символ. Вот. Что здесь написано?
Есть некий путь до вершины v, соответственно, отвечающий этому пути некая строка, потом я хочу
как бы в конце этой строки, да, вот она строка v, я ее написал сверху вниз, хочу как бы дописать
c и найти самый длинный суффикс такой строки, которую можно просчитать в боре. В идеале,
прям в лучшем случае, вся эта строка и будет читаема из корня. В случае, если из v есть переход
по букве c, вот если здесь есть переход по букве c, тогда go то же самое, что и tu. Переход просто
из вершины v по букве c. Если он есть, тогда самый длинный суффикс такой вот строки, находящейся в
боре, это сама строка v плюс c. Если для такого перехода нет, если, к сожалению, в боре нет
такого ребра, то это что-то более интересно. Нужно сколько-то первых символов отбросить и взять
самый длинный из оставшихся суффиксов, который можно было бы просчитать из корня. Собственно,
определение здесь написано. Самый длинный вот суффикс такой строки, который есть в боре,
который можно просчитать из корня.
Ну и, соответственно, после этого алгоритм AH-карасик, во-первых, насчитывает вот эти вот величины,
все линки, все go для всех вершин, а затем с их помощью решает вот эти две задачи,
наша задача, задачу штрих. Алгоритм AH-карасик. Это, как всегда, два автора. Это мужчина, это женщина,
поэтому здесь не карасик, а имя карасик, женская фамилия. В родительном падеже так и остается.
Он, во-первых, насчитывает все вот эти линки и все тушки, и все go, простите, насчитывает линк и go,
для любой вершины, для любого символа. Стреликом заполняется режим вот этих
массивов линк и go. Значит, ну давайте мы прям его сразу и напишем, по ходу будем
разбираться, как эти линк и go заполнять. Ну, во-первых, надо разбираться сначала с корнем.
Скажите, пожалуйста, чему должен быть равен линк от корня? Вот поэтому определение, если вы это
корень, то куда должна вести суффиксная ссылка? Никуда, да, ее не может быть по определению,
потому что поскольку v отвечает Эпсилону в пустой строке, то у Эпсилона просто нет
собственных суффиксов, поэтому мы как бы берем максимум по пустому множеству, так делать нельзя.
Поэтому формально линк от корня не определен, но я давайте для удобства напишу, что линк от нуля,
скажем, равно нулю. Это неважно, да, но формально он не определен. Формально не определен.
Линк от корня не определен. Значит, дальше, что делает go от корня? Ну, я уже сказал важное
замечание, что если из вершины v есть переход по букве c, то есть если есть в массиве tu переход
по c, значит go просто совпадает с tu. Важное замечание, что если из v есть переход по c,
то go vc равно, ну то, что у нас было tu c для этой вершинки v. То есть у нас для каждого символа
хранится то, куда мы попадем, если просчитаем этот символ. В этом же смысле go просто равен tu,
потому что мы просто считаем этот символ, тем самым v плюс c, оно вот здесь и находится, его можно
просчитать. Это понятно, вот этот случай? Вот. Поэтому для корня мы сделаем следующее. Мы пройдемся по
всем символам, ну давайте я там считаю, что у меня сейчас алфавит это какие-нибудь там числа от нуля до
сигма минус один. Вот. И если t0.tu c не равно минус один, то есть если есть переход по этой
букве по этому числу, тогда go равно просто этому сталому переходу. Go 0t равно t0 tu c. Вот. А что делать,
если нет перехода по букве c из корня? Вот был корень. Я хочу, то есть это строка epsilon,
хочу дописать некий символ c, то есть получить строчку c, взять у нее максимальный суев,
который есть в боре. Чему тогда равно go? Нулю да. Ну просто по определению у нас был корень epsilon,
приписал букву c, получилась строка c. При этом, да, я предположил, что это условие пройдено,
ну то есть это условие не выполнилось, значит по c не было перехода, то есть c нельзя прочитать из
корня. Значит единственный суффикс этой строки, которую можно просчитать, это epsilon. Поэтому go
равен нулю как строка, вершина соответствующей пустой строке. Поэтому иначе я пишу go 0t равно нулю.
То есть если переход был, то go это то же самое, что тот переход. Если перехода не было,
то go это 0. Я попытался прочитать символ c, но не смог и вернулся в корень.
Так, хорошо, с корнем разобрались. А дальше алгоритм можно реализовать, например, так. Мы
будем в каком-то смысле в порядке bfs его обходить, наш бор, и в очередь будем складывать вершины,
для которых мы уже все посчитали. И link и go все насчитали. Тогда, когда мы из бора достаем очередную
вершинку, видим из нее несколько переходов, мы посчитаем link и go для всех вот этих вот вершин
и сложим их опять в очередь. То есть мы как бы, ну вот, как обычно обходит bfs, давайте что-нибудь
нарисую побольше. Какое-нибудь вот такое дерево. Мы сначала обошли корень, потом посчитали ответ
для всех его детей, добавили их в очередь, потом извлекли из очереди эту вершину, посчитали ответ
вЭтовершин, удалили ее, для этой вершины посчитали ответ для них, добавили их, удалили ее,
для этой вершины посчитали ответ для нее, добавили ее в очередь, удалили ее. В итоге�мя сейчас,
в очереди вершины все со второго уровня, потом я опять их обхожу слева направо, добавляют
совершенно трет�ум уровна, и так далее. То есть я вот как бы так, сверху вниз, слева направо
прохожу, вот мы реализуем это в виде прям очереди, очередь номеров вершин, которые мы обработали.
это обработанные вершины, обработанные вершины, ну и изначально мы в эту очередь добавляем корень,
купуш ноль. Дальше пока очередь не пустая,
мы хотим достать вершину и, зная, что у нее уже посчитаны линк и гоу, найти линк и гоу для всех
ее детей. Достали первую вершину из очереди, сразу ее удалили оттуда и сейчас наша цель найти линк и
гоу для детей v. Ну давайте этих детей перебирать. Перебираем все переходы от 0 до сигма. Говорим,
что u это наш сын. Получается при переходе по букве c, то есть t, v, tu, c. Если это минус 1,
то continue. Если это не настоящая вершина, то делать ничего не надо, это не сын, его нет, мы его пропускаем.
Вот, а дальше интересно, смотрите, есть вершина v, для которой мы все знаем, и линк и гоу все знаем.
Есть из нее переход по букве c и вершины u. Для вершины u мы еще ничего не знаем. Вот давайте
попытаемся что-то для нее найти. Во-первых, как найти линк u? Чему он равен? Ну давайте я нарисую так,
вот у нас была строка отвечающей вершинке v, мы дописали к ней t, и это все теперь вместе будет u.
Мы дописали один символ, стало u. Еще раз. Да, гоут линк v по букве c почти всегда. Значит,
давайте подробно здесь обсудим. Почти правильно, только здесь есть небольшая тонкость. Смотрите,
что такое линк? Это максимальный собственный суффикс, который есть в боре. То есть мне нужно
отрезать несколько символов в начале, при этом хотя бы один надо отрезать, нельзя ничего не
отрезать. Нужно отрезать хотя бы один, так чтобы вот эта строка была в боре. Давайте мы сделаем
по-другому. Давайте мы сначала возьмем самый длинный собственный суффикс v, который есть в
боре. Возьмем линк от v. И понятное дело, что если вот это есть в боре, то это тоже есть в боре.
Поэтому когда мы берем линк от v, мы не теряем вот этого вот суффикса v, который остается,
когда мы взяли линк от u. Еще раз. Линк от u, вот эта вот строка, она точно не более длинная,
чем линк от v. Вот здесь вот. Это все не длиннее, чем вот это, потому что это самый длинный собственный
суффикс v, а это самый длинный собственный суффикс v, который еще продлевается на ц. Поэтому это,
конечно, более длинное, чем это, но по крайней мере не короче. И дальше мне нужно как бы среди
всех вот таких вот суффиксов найти тот, который можно продлить буквой c. Значит в общем случае
линк от u будет равно go линк от v по букве c.
Значит давайте еще раз объясню почему. Смотрите, вот это максимальный собственный суффикс строки
v плюс c, потому что u это v плюс c. А максимальный собственный суффикс строки v плюс c. Другими
словами это такой максимальный собственный суффикс строки v, который продлевается еще строкой c. То
есть это некий вот здесь вот суффикс, который можно обращать в боре, от которого вниз еще есть
переход p atraburny по буконе с. Нас самый длинный собственный суффикс v, который еще продлевается
вниз буковкой С. Но это то же самое, что если сначала взять просто самый длинный
собственности суффикс В, а потом среди них всех подписать, ну как бы подписать
к этой строке С и взять максимальный собственности суффикс, просто максимальный
суффикс, который в этой строке есть.
Так, сейчас попробую еще как-нибудь по-другому объяснить.
Ну да, то есть смотрите, вообще что нам нужно вот здесь? Что такое линк от У? Это
точно некий суффикс В, некий собственный суффикс В, после которого написано С. Ну а
здесь мы находим сначала самый длинный, в принципе, собственный суффикс В, а затем к
нему приписываем, то есть вот взяли линк от В, к нему приписали С, и либо это
сразу был переход вниз по ребру С, то есть был переход здесь вниз, тогда гоу
совпадает с ту и просто ведет вниз. Либо мы понимаем, что сразу за вот этим нет
перехода по С. Тогда нам нужно взять как можно более длинный оставшийся суффикс
вот этой строки, который можно продлить буквой С, а это в точности гоу. То есть была строка,
мы к ней приписали С, и нам нужно оставить отсюда как можно больше суффикс, чтобы
можно было написать С. Это в точности по определению просто гоу.
Вот, ну если не понятно, еще порефлексируйте на досуге. По сути мы просто сначала насильно
отрезали хотя бы один символ, да, линк это всегда собственный суффикс, это вот здесь
обеспечивается, что мы насильно отрезали хотя бы один, потому что линк всегда собственный.
А дальше мне нужно просто сохранить как можно больший суффикс с переходом по С в конце,
вот это делается в помощи гоу. Вот, значит, это почти всегда верно, вот эта формула почти
всегда верна, кроме какого случая. Да, кроме случая В это корень, потому что для В у нас формально
линк неопределенный, мы туда написали какой-то мусор, линк отвернул на нулю, что на самом деле как бы
не осмысленно. Вот, значит, это верно, если В не корень, если В не корень. Если же В корень,
то чему равно линк от У? Вот если В это корень, мы прочитали один символ, соответственно,
У отвечает строке из одного символа, чему равно линк от этой вершинки? Да, пустой строке, то есть корню.
Потому что у нас есть строка из одного символа, так как У равно С, вершина отвечает строке из
одного символа С, максимальный собственный суффикс, это строка пустая, Эпсилон, и она
соответствует корню, которая читается в боре, поэтому линк от ребенка корня это всегда корень.
Тем самым мы получили полное описание того, как насчитывать линк от У, либо по такой формуле,
когда В не корень, либо по такой, когда В корень. Так, ну давайте вставим это в код, давайте вот так
выделю, линк от У равно, я это обычно так пишу, тернарным оператором В равно 0, если да, то 0,
иначе вот то самое наше ГО, линк от В по букве С. Вот такая врезка. С линк более-менее
разобрались. Значит дальше мне нужно для вершины У насчитать все ГО, для каждого символа, для каждого
символ нашего алфавита, мне нужно считать ГО по этому символу. Значит мне нужно как минимум все эти
символы перебрать. Давайте я скажу, что это будет переменная D от 0 до Сигма. Я сейчас буду пытаться
найти ГО у Д. Начну первый случай опять простой. Если есть переход, да, если из У есть переход по Д,
тогда ГО просто с ним совпадает. Если ТУ.ТУ от Д не равно минус 1, тогда ГО равно этому
самому переходу. Так, я поленюсь, напишу в одну строчку. ГО у Д равно ТУ ТУ Д. Если из У есть ребро
вниз по букве Д, тогда, как мы неоднократно замечали, ГО по этой букве просто равно тому
самому переходу. Просто переход вниз по букве Д. Вот сюда мы попадаем через ГО. Иначе, что нам
нужно сделать? Иначе, какая произошла ситуация? У нас была строка У, мы попытались к ней приписать
символ Д, поняли, что вот такой строки в Боре уже нет. У плюс Д уже в Боре точно нет. Потому что
если бы была, мы бы могли просто прочитать буковку Д, начавшись с вершинки У. То есть,
тогда здесь был бы переход. Итак, строки У плюс Д в Боре нет, но мы по-прежнему хотим найти самый
длинный суффикс этой строки, которая читается в Боре, которая есть в Боре. Значит, это не просто
максимальный суффикс строки У плюс Д, но максимальный собственный суффикс. Поскольку самой У плюс Д в
Боре точно нет, то тогда давайте напишу так. Максимальный хороший суффикс У плюс Д, хороший,
то есть тот, который есть в Боре. Хороший суффикс У плюс Д. Это то же самое, что максимальный хороший
суффикс. Хороший, сори, собственный суффикс. Да. Нет. Внутри, да, внутри цикла по С. Значит,
что я тут написал? Я сказал, что максимальный хороший суффикс У плюс Д, это то же самое,
что максимальный хороший собственный суффикс У плюс Д. Просто потому, что само У плюс Д это не
хорошее слово, да, его нет в Боре, его нельзя просчитать в Боре. Значит, как минимум один символ
надо откусить, поэтому мы рассматриваем только собственный суффикс. То есть, смотрите, мне нужно
для строки У плюс Д найти максимальный собственный суффикс, который есть в Боре. Но это мы уже вот
только что делали. Да, у нас была строка, мы к ней приписывали символ и искали максимальный собственный
суффикс вот такой вот новой строки В плюс С, который есть в Боре. Это вот оно. Ну, значит, там работает
то же самое. Просто потому, что это та же самая задача. Для строки строка плюс символ найти максимальный
собственный суффикс, который есть в Боре, это вот это. Поэтому просто формула здесь копируется и
будет ГОУ, ну не копируется, а будет аналогичное. ГОУ С, ГОУ Д это ГОУ линк У Д. И это уже будет всегда
корректно, потому что линк от У всегда определено. У это уже не корень, поэтому линк от У можно
корректно брать и, соответственно, можно просто взять ГОУ точно так же, как и там. Вот мораль такая,
смотрите, если мы поняли, почему работает эта формула, тогда, на самом деле, здесь она также
автоматически работает просто потому, что мы решаем одну и ту же задачу. У нас была строка,
вот здесь была строка В, мы к ней приписали символ и ищем максимальный собственный суффикс,
который есть в Боре. Здесь то же самое. Есть строка У, мы приписали символ Д и ищем максимальный
собственный суффикс, который есть в Боре. Но раз это одна и та же задача, то и формула для
почета одна и та же. Просто нужно ВЦ поменять на УД. Вот она. Так, ну и в конце, после вот этого,
сейчас, момент, давайте куда-нибудь вставлю последнюю строчку. Так, ну ладно.
Мы закончили на счет ГОУ УД для всех символов Д. Дальше мы считаем, что мы для вершины У все
посчитали и добавляем ее в очередь. Мы ее обработали, нашли все вот эти величины для нее,
добавили в очередь. Ну и все, на этом надо завершиться. Значит, цикл по С закрывается,
и ВАИЛ наш тоже закрывается. Ну и соответственно, да, все, больше ничего не было.
Да. Потому что мы линк от У считаем, а не линк от В. У нас В это вершина, для которой все
насчитано. Изначально В это корень. Потом мы рассматриваем его ребенка У. И для У уже,
У это уже не корень, а ребенок корня. Пытаемся найти линк.
Сейчас. Не, не сработает. У вас будет линк от уровна У. Потому что, смотрите, вот у вас был
корень В равно нулю. У вас был переход С в вершину У. И линк от В равно нулю. Тогда вы
смотрите на GO корень по букве С. Ну извините, но это У. Да, потому что вот он есть переход.
Так, алгоритм я написал. Единственное здесь, смотрите, здесь два тонких места. Первое,
это понимание вот этой формулы. Я как мог объяснил, но, пожалуйста, еще порефлексируйте
над ней, поймите, почему здесь все нормально. И во-вторых, почему, когда мы вот это вот все делаем,
мы имеем право полагать, что линк от В насчитано, и GO для вот этой штуки уже все насчитаны. А также
здесь, ну линк от У понятно, мы только что насчитали. Но также почему мы имеем право полагать,
что GO для этой вершины и буква D уже насчитана? Да, именно так. Потому что мы идем по нашему
бороду сверху вниз, порядке BFS, то есть порядке увеличения глубины. Значит, все вершины с глубиной
меньше, чем У, уже имеют полностью насчитанные линки и GO. Да, поскольку эта вершина точно имеет
глубину меньше, чем У, потому что это линк, собственный суффикс, значит, имеет меньшую глубину,
тогда для нее точно уже GO насчитано. Ну то же самое здесь. Линк от В имеет глубину меньше,
чем В. Что имеет глубину еще меньше, чем У, значит, для нее все GO уже насчитаны. И именно за
счет того, что мы идем вот так BFS сверху вниз по бору, мы имеем право брать GO для всех вот
это и для линк от В, и для линк от У. Они уже находятся на меньшей глубине, для них уже все посчитано.
Давайте зафиксирую обращение GO линк от В и GO линк от У. Корректно? Поскольку, значит, обе эти
вершины, что линк от В, что линк от У, линк от В и линк от У, имеют меньшую глубину, чем У.
Имеют меньшую глубину, чем У. А потому они уже были обработаны в нашем BFS, значит, для них уже все
насчитано. Были обработаны в BFS раньше, ну просто потому, что BFS идет в порядке увеличения глубины,
в порядке увеличения расстояния от корня. Значит, все такие обращения корректны, и если мы на каждом
шаге делали корректные вычисления, GO и линк, тогда на каждом следующем, поскольку оно следует
из корректных, то каждое конкретно тоже будет корректным. Так, ну а симптотика здесь, конечно,
будет просто В на сигма, где В это, ну что, вершин, ну а сигма, как обычный алфавит. Потому что для каждой
вершины Бора мы заводим массив вот такой вот длины, а все остальное, на самом деле, линейное. Потому
что мы для каждой вершины просто, ну смотрите, линк для вершины у нас определяется за вот
единицы. Потому что линк от В уже насчитано, GO вот эти штуки уже насчитаны, просто обращение
к массиву за вот единицы. Чтобы насчитать GO для вершины по букве, мне тоже никаких вычислений
делать не надо, это просто вычисление за вот единицы. Поэтому каждое конкретное значение
находится за вот единицы, ну а всего значений нужно найти ровно вот столько. Для каждой вершины
и каждого символа нужно найти GO по вершине и символу. Вот столько значений нужно найти,
поэтому вот столько времени нужно потратить. Ну давайте я отмечу, что столько времени и столько
памяти. Ну тут в каком-то смысле лучше и нельзя, потому что мне все равно, мне нужно посчитать вот
столько значений. Мне нужно для каждой вершины и для каждой буквы найти, куда мы попадем,
если к вершине припишем букву. Поэтому лучше чем столько нельзя, вот за такой симптом мы и решили.
Так, ну хорошо, теперь давайте решать задачу и задачу штрих. Давайте вспомним задачу. Обычно
это просто суммарное число вхождений словарных слов в текст. Здесь алгоритм будет следующий.
Мы будем читать наш текст T по одному символу слева направо и в каждый момент времени,
то есть вот где-то там еще продолжение нашего текста, вот мы дочитали до сюда, в каждый момент
времени мы будем от текущего состояния строки T хранить максимальный суффикс, который есть в
боре. Мы идем по T читаем слева направо, вот мы находимся где-то здесь, там дальше еще будут
символы, но вот пока мы дочитали до сюда. И вот в этот момент времени мы храним самый длинный
суффикс текущего положения T, который можно прочитать в боре. Давайте так, для каждого и в момент
времени и храним максимальный суффикс строки T0 и т.д. Т.е. все символы вплоть до Итого. Максимальный
суффикс этой строки, который есть в боре. В чем смысл? Зачем хранить максимальный суффикс,
который есть в боре? Смотрите, мы помним, что что такое слова, которые есть в боре? В боре есть
только те слова, те и только те слова, которые являются префиксами словарных слов. Т.е. если вот
это слово, которое есть в боре, значит его потенциально, если T дальше правильно будет устроено,
его можно потенциально добить до некоторого слова из словаря. То есть это префикс некоторого
словарного слова. И если T дальше будет правильным, мы можем вот здесь получить вхождение какого-то
словарного слова. Из всех таких вот окончаний меня, конечно, интересует только префикс словарных
слов, потому что если вот этот кусок не является
префиксом никакого словарного слова, то его никак нельзя
продолжить.
Если мы взяли какой-то кусок, и это причем не префикс
ни одного словарного слова, то есть его нет в боре, то
что не пиши дальше, эта штука уже не будет началом вхождения
никакого.
Поэтому среди этих окончаний, которые можно продлить
направо, меня интересуют только те, которые есть
в боре, потому что их можно продлить направо некими
окончаниями, чтобы получить словарное слово.
Когда мы обрезали, меня интересуют только такие суффиксы
текущей строки T, которые являются префиксами словарных
слов.
Среди всех таких давайте возьмем максимальный, то
есть их там может быть несколько, вот этот, поменьше, поменьше,
вот все они есть в боре, их потенциально можно как-то
продолжить.
Давайте возьмем среди них самый длинный, тогда мы
точно никакую информацию не потеряем.
Так, а вот этот массив очень легко насчитывается, как
для каждого и взять максимальный суффикс такой строки, которая
есть в боре.
Это очень просто, v0, ну не так, давайте я в 1 индексации
перейду, пусть у меня будет t в 1 индексация от 1 до i.
Значит, тогда v0 это просто корень 0, а дальше vit это
go vi-1 по символу tit, просто потому что вот у меня было
положение строки в момент времени i-1 и было vi-1 это максимальный
вот этот суффикс, давайте я назову, храним vit, вот
у меня был максимальный суффикс в момент времени
i-1, потом добавляется новый символ tit, я хочу пересчитать
максимальный суффикс.
Ну понятно, что это просто go, потому что у меня была
некая строка vi-1, я к ней приписываю новый символ
и теперь у этой штуки хочу взять максимальный суффикс,
ну просто по определению это go, еще раз, у меня было
положение строки в момент времени i-1, вот оно, пусть
vi-1 это максимальный суффикс, который есть в боре, у вот
этой строки до черты, дальше появляется новый символ
ti, я хочу уже найти максимальный суффикс вот этой новой
строки вместе с символом ti, который есть в боре, максимальный
суффикс, который есть в боре, ну как-то вот так будет
выглядеть.
Ну это просто по определению go vi-1 ti, потому что мне нужно
взять вот эту строчку, приписать к ней новый символ и взять
среди всех возможных суффиксов максимальный, ровно это
и делает go, а поэтому вот это vi-1 будет просто переходом
по go в боре, ну и после этого, если я для каждого момента
времени, после каждого символа ti, знаю текущую
вершину в боре, то что мне нужно сделать, сейчас напишу,
каждая i вносит несколько вхождений словарных слов,
несколько вхождений словарных слов.
Значит каких, смотрите, вот пусть vit, это максимальный
суффикс t, который есть в боре, я уже рисовал вот
эту картинку, давайте продублирую, вот он vi, какие слова, вот
мы добавили новый символ, вот этот последний ti, какие
словарные слова только что получили вхождение, то
есть которые раньше не встречались, теперь получили
вхождение, ну это явно какие-то суффиксы, вот какие-то
такие строки, раньше не было, теперь вот появилось
новое вхождение, ну тогда это просто напросто все суффиксы
вот этой строки, которые являются терминальными
вершинами, значит мне, чтобы обновить ответ при добавлении
этого символа, нужно найти количество терминальных
вершин среди суффиксов вот этого, то есть мне нужно
как бы перебрать все суффиксы строки vit и среди них найти
количество терминальных, и это и будет то, насколько
увеличится ответ при добавлении вот этого символа ti, но эта
штука на самом деле может быть переформулирована
так, значит, сколько суффиксов vi являются терминальными
вершинами.
Ну это является, например, так, смотрите, если vi сама
по себе терминальная, то нужно прибавить единичку,
а дальше давайте брать линк от v, линк от текущей
вершины, пока мы не дойдем до корня, потому что линк
это по сути отбрасывание первых нескольких символов,
чтобы вернуться в Бор, сколько символов надо отбросить
минимально, чтобы получилась строка из Бор, то есть вот
у нас, так, давайте не так, вот оно было vi, vi, если она
терминальная, то она уже, как бы собственный суффикс,
нужно добавить единичку, потом нужен следующий по
величине суффикс, который терминальный, значит мне
нужно несколько первых символов отбросить, окей, получил
некий суффикс, который есть в Боре, но при этом не
терминальный, это была просто линк, мы ее игнорируем, потом
опять нужно несколько символов отбросить, чтобы получить
суффикс, который есть в Боре, окей, он, например, был терминальный,
но главное, что это тоже линк, да, то есть мне по сути
нужно, чтобы вообще перебрать все вот эти суффиксы, мне
достаточно прыгать по суффсылкам, по линкам от vd vi, тем самым
я буду перебирать все возможные суффиксы текущей строки,
которые есть в Боре, тогда вот здесь алгоритм очень простой,
давайте мы просто будем прыгать по линк, пока не дойдем
до корня и считать, сколько средних терминальных, тем
самым мы как бы переберем все суффиксы вот этой строки
и найдем, сколько из них являлись словарными словами,
да, это можно предпочитать, конечно, давайте я это напишу,
пока не алгоритмом, да, скорее, идея, да, значит, мы берем
линк от vi, то есть мы берем vi, берем линк от vi, берем
линк от линк от vi и так далее, вплоть до корня, и смотрим,
сколько средних терминальных, сколько среди них терминальных,
сколько средних терминальных есть, ровно столько и появилось
вхождение словарных слов в наш текст, вот, ну, чтобы
победить нам осталось, ну, научиться вот эту штуку
насчитывать быстро, да, сколько среди вот этих
вершин есть терминальных, это, конечно, можно сделать
предпочетом просто, значит, скажем, давайте, пусть будет
knt от v, это количество терминальных на пути по су-всылкам, ну,
собственно, вот по тому пути, да, v, линк от v, линк от
линк от v и так далее, вплоть до корня, считается также
в bfs и в алгоритмах карасик, считается внутри bfs, ну,
считается очень просто, значит, knt от v, это, значит, нужно
проверить, является она терминальной или нет, так,
t от v точка терм, если терминальная, то нужно добавить единицу,
плюс knt от линк от v, а поскольку у меня вот этот вот путь по су-всылкам, он содержит сначала v,
потом линк от v, потом продолжение суфиксного пути для вершины линк от v, да, я просто много
раз навешаю линк на вот эту штуку уже, то мне достаточно знать вот это вот knt и просто к нему
прибавить 1 или 0, в зависимости от того, является ли терминальная вот эта вершинка v или нет.
Если является, то прибавляю единицу, если не, если не является, то прибавляю 0,
и просто остается knt от линк от v. Вот, ну и тем самым, смотрите, мы, во-первых, поняли,
что все возможные, как бы, все возможные интересующие нас суфиксы, это всегда путь по
су-всылкам, да, много раз нужно брать линк, чтобы рассмотреть вообще все возможные суфиксы,
которые читаются в боре, и при этом количество мы также насчитали внутри алгоритмах карасик,
внутри нашего вайла, да, knt от v, то есть количество терминальных на этом пути мы можем насчитать
параллельно с тем, как мы насчитываем все го и все линки, тем самым каждый раз просто в нашем алгоритме,
когда мы спускаем, когда мы как бы переходим в новую вершинку из v и минус 1 в v и v и. Мы просто
добавляем knt для вот этой вершины, это то, сколько новых вхождений появилось в нашем тексте. Так,
давайте закончим, в следующий раз добьем задачу штрих. Спасибо.
