так ну что у нас сегодня вот такая вот тема и в общем это мое отношение к ней более-менее нет
но она это это шутка на самом деле это очень прикольная структура которая умеет делать всякие
штуки и при этом очень просто пишется не просто да ну скажем так если у вас написано
сплэйд дерево то просто теперь если у вас написано сплэйд дерево то там дальше прям прям
совсем почти ничего не надо писать вот основная загвоздка доказать что это быстро работает вот
ну и мы сегодня попробуем все это сделать значит смотрите какую задачу мы хотим решать
мы хотим поддерживать на самом деле лес корневых деревьев
ну и давайте как обычно считать что он числа написано на ребрах
вот ну поступают давайте как обычно давайте по запросов это у меня апдейт на ребре и сумма
на пути что-то я так и напишу апдейт на ребре сейчас давайте пардон пардон мне будет сегодня
удобно видимо числа на вершинах числа вершинах я сделаю вот так да так будет удобнее значит апдейт
числа в вершине второй тип запроса это где-то сам на пути найти сумму на пути но давайте для
простоты я буду искать сумму не на произвольном пути между двумя вершинами а от вершины до корня
то есть сумма на восходящем пути от вершины ве до корня до корня соответствующего дерева
гет сам от в это сумма чисел на пути от ве до корня вот то есть у меня все вершины разбиты на
несколько деревьев вот есть там одно дерево да какое-то второе третье вот если дают в это я
понимаю в каком дереве оно лежит и вот на этом пути до вплоть до корня мне нужна сумма сумма
чисел в вершинах написанных на этом пути вот ну и собственно две новые операции линк это нужно
подвесить одно дерево целиком к другому вот значит представьте что вас было два дерева и вы
хотите как бы вот так вот подвесить вы хотите взять одно дерево целиком приклеить к другому
дереву в какой-то точке ну по факту просто провести ребро провести ребро отсюда сюда такое значит да
между конкретными ну не совсем на самом деле первого аргумента будет всегда корень своего
дерева а вторая произвольная то есть вы целиком вот это вот под дерево взятая за корень подвешивайте
какой-то другой вершине значит подвесить одно дерево целиком к данной вершине
ну и противоположная операция так кат наоборот разрезать ребро если у вас было какое-то
ребро ув вы его разрезаете соответственно по дерево в становится новым деревом кат ув это вам
нужно разрезать ребро ув ну и соответственно то что было по деревам в становится самостоятельным
деревом и ну как бы живет само по себе на то есть если была вот такая картинка что-то такое было
было было ребро ув вы его разрезаете вот это вот становится самостоятельным деревом а вот это вот
все остальное но остается вот этим большим по факту по факту в дополнение к запросам то что
у нас было через хавилла декомпозиции мы делали у нас появляется добавить ребро и удалить ребро
то есть такое динамически меняющееся дерево несколько верев которые там как-то динамически друг
друга подвешиваться и отрезаются и так далее клево согласен вот значит чем а чем будем делать
смотрите мы опять-таки все ребра всех наших деревьев разобьем на два класса активный не
как у нас было в хавилла декомпозиции тяжелые легкие сейчас у нас будут ну я бы называть
выделенные и не выделенные ребра все ребра у нас разбиваются на выделенные и не выделенные
и так же как раньше на непрерывном пути из выделенных ребер и мы будем поддерживать какую-то
структуру данных здесь раньше в хавилла декомпозиции у нас мы как бы рассматривали тяжелые пути и на
тяжелом пути строили скажем дерево отрезков так здесь на выделенном пути мы строим свою структуру
которая на самом деле будет с плой-деревом давайте какой-нибудь пример я нарисую
такое дерево пусть будет вот давайте выделенные ребра я буду заштриховывать
по волнистой линии вот это выделено вот это выделено вот это выделено вот это выделено
ну и все например вот тогда у меня будет всего два сплой-дерева одно отвечает целиком вот этому
пути, другое вот этому пути. Вот. И давайте договоримся, что у меня вершины на пути будут
нумероваться в каждом пути независимо сверху вниз. То есть в этом пути это будет нулевая первая,
вторая, третья вершины, в этом пути опять своя нумерация, поскольку это своя структура,
в ней на объектах своя нумерация независимо от остальных. Здесь тоже это 0, 1, 2. Вот. Ну а получается
вот такие отдельные вершины будут на самом деле своими отдельными сплей деревьями, в которых
просто одна вершина находится, сплей дерева размера 1. То есть вот дерево, вот дерево,
вот дерево. Ну все вот это будут отдельные сплей деревья. Вот. Значит давайте запишем. Я хочу,
чтобы из каждой вершины, из каждой вершины выходило, то есть из каждой вершины выходит
вниз не больше одного выделенного ребра. Так же, как в Хавеладе композиции, у нас тяжелое
ребро ровно одно, но там как бы ровно одно было, здесь не больше, чем одно. То есть да, например,
вот здесь вот ничего страшного, что здесь нет ни одного выделенного ребра. Это нормально. Да,
уточню, что вот выделенные, это вот эти вот штрихованные, а все остальные не выделенные,
не выделенные. Прямые это не выделенные ребра. Вот. Ну и значит строим сплей дерева,
сплей дерева на каждом нисходящем пути по выделенным ребрам.
Значит что у нас хранится в сплей дереве? Смотрите, у нас, ну нам явно надо хранить
сумму в поддереве, да, то есть у нас в вершинах будет храниться числа, вот эти вот. Так же мне
нужно искать сумму на поддереве, внутри сплей дерева, то есть там будет отдельное поле,
которое хранит сумму в поддереве. И это дерево должно быть неявным, потому что, ну мы их будем
явно сильно перестраивать, да, то есть когда там сюда что-то подвешивается. Ну, например, да,
если я захочу в какой-то момент вот это вот ребро назначить не выделенным, а это выделенным,
то мне нужно будет вот этом большом дереве этот кусок отрезать, а этот добавить. И я это часто
буду делать, я буду часто менять типы ребра с выделенных на не выделенный и наоборот,
поэтому мне нужна структура, которая внутри позволяет там быстро склеиваться как-нибудь,
да, между собой, наоборот разделяться, то есть как бы отрезать ребра, ну и так далее.
Привет, Артур Евгеньевич. Вот, значит, давайте это напишем, да, сплей дерева у нас будет по
неявному ключу. По неявному ключу в вершинах этого дерева храним туму чисел из-под дерева.
Так, это сказал, значит, последнее поле, которое я буду хранить, и после этого нарисую пример
еще один. Значит, это мне нужно будет хранить для каждого начала каждого сплей дерева, то есть
по факту для каждого начала всех выделенных путей я буду хранить ссылку на то, куда подвешен,
как бы, ну, вот на родителя по факту. Вот у меня есть целиком какой-то выделенный путь, я буду
для его корня, для начала этого пути хранить ссылочку, ну, давайте даже вот так скажу, вот это
все как бы дерево целиком подвешено вот сюда. У меня будет вот такое поле, что этот путь является
сыном непосредственно вот этой вершины. Например, дальше вот это вот будет целиком подвешено вот
сюда, к единице, это все целиком сплей дерева, оно будет подвешено вот к этой единице, к этой вершине,
ну и так далее. То есть у меня по факту каждое сплей дерево ссылается на то, куда оно подвешено.
Каждое сплей дерево, а напоминаю, сплей дерево это путь из выделенных ребер, так вот каждый путь
это какая-то вот такая вот картинка, да, все выделенные. Я хочу понять, какая вершина как бы
предшествует всему этому пути. Вот ее я буду хранить. Значит, каждый сплей дерево, точнее корень
сплей дерева хранит указатель ptr, ну я напишу на родительскую вершину, вот на предыдущую вершину
относительно этого пути.
Вот. Ну все, структуру более-менее писал. Теперь давайте нарисуем пример с числами,
и вот эти ptr тоже как работают. Надеюсь, не хватит. Сейчас от балды выделю какие-то ребра. Значит,
сразу скажу, что те ребра, которые выделены и не выделены, у них классификация, ну там нет
никакого правила, что вот эти выделенные и не выделенные. Просто вот как алгоритм их в какой-то
момент назначает выделенными или не выделенными, мы их так и считаем. Короче, вот как алгоритм хочет,
он так их выделяет. То есть нет какого-то правила, что там тяжелые ребра выделены или что-то такое.
Вот просто вот как в алгоритме он их назначит, так и так и будет. Вот, например, пусть такая картинка у меня.
Пусть будет вот так. Давайте пронумерую вершины. Как-нибудь от балды. Вот. И построю как-нибудь
сплей-деревья. Значит, смотрите, давайте вот с этого длинного пути начнем. Вот это вот все должно
быть одно большое сплей-дерево. При этом как именно оно внутри устроено, мы не знаем. Но давайте
какой-нибудь пример нарисуем. Вот скажем, пусть корнем этого сплей-дерева, напоминаю, у меня вершины
как бы сверху внизу порядочены, то есть вот это должна быть первая, самая левая вершина сплей-дерева,
это вторая, третья, четвертая. Ну, например, пусть двойка является корнем. Тогда, смотрите,
слева должны идти те, кто левее, то есть выше в пути расположен. Вот эта единица будет сверху,
а справа должно быть вот это поддерево между тройкой и четвертой. Ну, например, пусть будет вот так.
Вот. Вот это корректная сплей-дерева для вот этого первого пути. Потому что, когда мы рассматриваем
вершины слева направо, то есть смотрите на это, как на картинку на плоскости. Если вершины слева
направо записывают, то будет сначала первая, потом вторая, потом третья, потом четвертая. Как раз ровно тот
порядок, к которому вершина идет сверху вниз. Так, это корректное дерево вот это. Дальше давайте
нарисую единичные, скажем. Вот это 10, 11, они будут сами в себе. Вот это вот 12, 15. Здесь корни может
выступать как 12, так и 15. Смотрите, хотя хотелось бы ожидать, что 12 это корень свою сплей-дереву,
потому что она сама верхняя. Это не всегда так. Может быть произвольная вершина. Вот, например,
15. Значит, если 15 корень, то поскольку 12 расположена выше, идет раньше в сплей-дереве,
то значит она должна располагаться левее. Потому что левее это раньше. Так, это нарисовал. Значит,
ну давайте еще вот здесь вот нарисую, чтобы было поинтереснее. 5, 7, 9. Здесь давайте для
разнообразия пятерка будет корнем. Мне нужно, чтобы остальные шли справа. Пусть, например, будет
вот так. Это тоже будет корректный сплей-дерев, потому что самая левая вершина 5, потом 7,
потом 9. Как раз 5, 7, 9 сверху вниз. Шестерка, восьмерка сами в себе. Где-нибудь я вот здесь
их нарисую. Вот этот путь. 14, 20, 16. Пусть будет 16 корнем. Тогда слева 20 может быть и еще левее 14.
Так, я почти закончил. Осталось у меня 13, 17 и 17. Давайте я нарисую вот здесь. Вот, например,
такой набор сплей-дерев может соответствовать вот этому одному дереву. Понятно? Нет противоречи
тут? Да. Нет, совсем не обязательно. Не-не-не, смотрите. Вот, например, давайте вот на этом примере,
если бы четверка, скажем, была корнем, то у меня могло бы быть... Ну нет, подождите. Вот-вот,
окей. Представьте себе, какой-то длинный путь вот здесь был бы. Тогда его корнем может выступать,
например, вот эта вершина. Левое по дереву — это все вот это, правое — это вот это. А какое оно
здесь устройство имеет? Да бог его знает. Может быть, например, вот эта штука — корень, потом вот
сюда он как-то ссылается и сюда. То есть это произвольное сплей-дерево. Давайте пример нарисую тоже.
Если есть вопросы, значит, вот что-нибудь подлиннее нарисую. Вот. Пусть, скажем,
Т — это у меня корень, тогда слева нужно расположить вот это. Например, оно может получиться так.
Корректное сплей-дерево, потому что при проходе слева направо в точности получается путь сверху вниз.
Оно не совсем как бы произвольное, абсолютно. Произвольное сплей-дерево. Главное — бинарное.
Сплей-дерево, понятное дело, бинарное. Так, давайте это сотру.
Ну, смотрите, у меня все вершины исходного дерева,
пронумерованы как-то. Ну, даже я бы сказал так, все вершины, которые вообще когда-либо участвуют в нашей
структуре, пронумерованы 1, 2, и так далее, n. Вот там изначально в задаче сказали, что всего мы
используем, работаем с n-вершинами. Изначально у меня они все 1, 2, и так далее, n. Нет ребер
каждого в своем сплей-дереве. А потом говорят что-нибудь типа, ну там, не знаю, вот это объединить,
тогда нужно вот эти два сплей-дерева склеить. Да. Но они же занумерованы. Мы по номеру можем
получать вершину спокойно. У меня, смотрите, у меня нумерация здесь полностью соответствует
нумерации в исходном дереве. И если мне сказали подвесить там x и y, то я знаю вершину соответствующую x в
одном из сплей-деревев и y в другом. И подвешу, если надо. Ну, можно так сказать, нет, не на сплей-дерево,
а на вершину я бы сказал. То есть по вершине исходного дерева мы имеем указатель на вершину
в сплей-дереве. Да, да, исходное дерево мы в явном виде вроде даже не храним, да, это правда. Вроде
даже не храним, действительно. Вот, ну теперь смотрите, давайте какую-нибудь операцию попробуем
сделать. Давайте попробуем понять, что происходит, если я, например, хочу вот это вот ребро выделить.
Вот это ребро выделить. Что это значит? Это значит, что я должен в частности вот это ребро антивыделить,
да, то есть я должен его убрать, а это добавить. Ну, давайте тогда по шагам сделаем. Давайте сначала
поймем, что происходит, когда я вот это вот ребро делаю невыделенным. То есть ребро между двойкой и
тройкой. Я вот хочу его не выделить. Да, значит, смотрите, мне нужно по факту просто вот это дерево
разрезать, чтобы сверху были один-два, а снизу три-четыре. Ну, давайте я сделал сплей, благо двойка
и так уже корень, и мне на самом деле нужно просто отрезать вот это правое поддерево, потому что вот
как раз вот эти три-четыре, они лежат ниже, их нужно отрезать. Поэтому первым делом, когда я хочу
сделать ребро невыделенным, я поднимаю эту вершину в корень с помощью сплей, ну здесь она и так корень,
и отрезаю правое поддерево, потому что все, что ниже, это гораздо то, что справа. Значит, сделать это
ребро невыделенным, это значит просто убрать вот это ребро. Согласны? Но если я хочу это сделать
выделенным, то мне нужно теперь вот это поддерево 5,9,7, то есть вот этот вот выделенный путь, подвесить
справа к двойке, потому что как раз таки оно идет ниже, значит справа. Поэтому вот это все
безобразие нужно подвесить вот сюда, вот на место того, где раньше было 4,3. Давайте перерисую. Будет
теперь вот так. Вот. Тем самым я вот это ребро выделил. Давайте еще что-нибудь сделаем. Вот это
хорошее, вот это ребро попробуем выделить тоже. Чтобы его выделить, мне нужно это сначала
сначала не выделить, сделать не выделенным, а потом это выделить.
Давайте сначала это сделаем не выделенным.
Для этого я не могу просто отрезать это ребро, потому что это ребро в родителе.
Мне нужно сначала сделать сплей.
Сначала число 12 сделать корнем своего сплей-дерева.
Понятно, что дело после сплея от 12 произойдет вот такое вращение.
12 станет корнем.
Ну понятно, сплей-дерево я могу делать вот эти, извините за выражение, зиги, зиг-зиги и зиг-заги.
И от этого оно останется корректным сплей-деревом, там все суммы я умею находить и так далее.
Вот, поэтому я могу сделать сплей и старое дерево превратить в новое.
Ну а дальше я делаю ребро не выделенным, просто отрезаю это ребро.
Говорю, что правый сын-то нул ПТР, что у меня нет правого сына.
И на место правого сына я подвешиваю вот этот путь 14, 12, 16.
Это 14, 20, 16. Вот он.
Целиком я его подвешиваю в качестве правого сына 12-кир.
Ну то есть делаю вот так.
Согласны?
Вот, вроде очень просто.
Ребра, ребра, ребра.
Какие-то ребра у нас будут выделены, какие-то не выделенные.
Мы храним пути в сплей-деревьях.
И мы более-менее научились переназначать типы ребер.
Невыделенный и наоборот.
Если мы хотим ребро выделить, то мне нужно подвесить нижнее под дерево к верхнему
с помощью, ну просто подвешивания справа,
потому что они идут ниже, значит нужно подвешивать справа.
А если мне ребро нужно не выделить, то есть из выделенного сделать невыделенным,
мне нужно сделать сплей от верхней вершины и правое подерево высечь.
Потому что всё что справа, это снизу.
Да, вот давайте их корни все эти нарисуем.
Давайте в текущей ситуации...
Да, извините, это я забыл нарисовать.
Вот оно теперь выделенное, потому что я переподвесил.
Давайте вот эти ПТР-ки еще нарисуем, кто на что ссылается.
Ну, тут все просто.
Смотрите, у этого дерева большого, 1, 2, 5, 9, 7,
оно ни на что не ссылается, потому что оно и так самое верхнее.
Поэтому у этой штуки 0 ПТР.
Дальше. Вот есть такой выделенный путь 3, 4.
Находим его, вот он.
Для корня этого сплэй-дерева говорим, что он подвешен к вершине 2.
Значит, я провожу вот такой вот ПТР.
Потому что вот это сплэй-дерево целиком подвешено как сын к вершине 2.
То, что ребро ведет в корень, совпадение, оно вполне могло быть подвешено вот сюда.
Так.
Да, например, вот этот путь 13-18, он подвешен куда?
Он подвешен к тройке.
Поэтому здесь отсюда ребро будет в тройку вести.
Не в корень вот этого дерева, а просто в тройку.
Ну, например, еще что будет куда подвешено?
8 будет подвешено к 6, вот такое будет ребро.
Вот этот вот весь большой путь, вот он у меня.
16, 20, 14, 12.
Вот это вот все подвешено к единице.
Поэтому из корня этого поддерева я веду стрелку в единицу.
Но я не буду рисовать, потому что уже перегружена картинка.
Отсюда будет пунктировано ребро ПТР в единицу.
Потому что этот путь целиком подвешено к единице.
Вот.
Ну и так далее.
ПТР из корня текущего сплэй-дерева в произвольную вершину 2.
Ну и так далее.
ПТР из корня текущего сплэй-дерева в произвольную вершину 2.
Туда, куда все это поддерево подвешено.
Вот, ну по структуре вроде все.
Теперь давайте попробуем понять, как мы будем делать запрос GetSum.
Вот, смотрите, пусть у меня все вершины моего дерева разбиты по сплэй-деревям.
Как найти сумму на вот таком вот пути от В до корня текущего дерева?
От В до Р.
Типа того.
Но, смотрите, давайте еще для удобства сделаем все вот эти вот ребра выделенными.
И еще сделаем все вот эти вот ребра выделенными.
И еще сделаем все дочерние ребра из В не выделенными.
На самом деле, чтобы сделать процедуру GetSum, я веду процедуру Expose от В.
Которая делает следующее.
Она делает все ребра на пути от В до корня выделенными, а все дочерние ребра из В не выделенными.
Тогда вообще супер сумма на этом пути.
Ну, то есть на самом деле, этот путь становится просто целиком сплэй-деревом.
Потому что все эти ребра выделенные и он никуда не продолжается.
Поэтому это становится целиком сплэй-деревом.
Полностью это все, все это сплэй-дерево.
Весь путь – это одно сплэй-дерево.
И сумма на пути – это та сумма, которая в корне лежит.
Потому что в корне лежит как раз таки сумма всего по дереву, то есть сумма на этом пути.
Поэтому, если я так сделаю, то у меня сумма на пути вообще за единицу находится.
Если я знаю, что это все –If I know that this is one of the indicates of 3534,
одно большое расплое дерева, то сумма на пути – это просто значение в корне.
Что делает Expose? Делает все ребра на пути от В до корня выделенными,
а все ребра, исходящие из В, делать невыделенными.
Вот такая процедура Expose. Благо, мы уже умеем делать ребра выделенными и невыделенными.
А мы знаем, что там надо что-то переподвесить, что-то отрезать и так далее.
Но давайте напишем процедуру, которая делает Expose.
Попробую уместиться на этой части доски.
Что делает Expose от В?
Давайте картинку нарисую, если есть какой-то путь.
Смотрите, на этом пути какие-то ребра выделенные, какие-то – невыделенные, какие-то – выделенные, какие-то – невыделенные.
И еще, возможно, есть какие-то выделенные нисходящие ребра из В.
От них надо избавиться, сделать их невыделенными.
Давайте я сначала рассмотрю этот путь, который содержит В.
И с помощью сплея В подниму в корень, соответствующий сплее дерева.
Первым делом я делаю сплей от В.
Что происходит? Теперь у меня этот путь, который изначально содержал В, стал соответствовать сплее дерева, в котором В – это корень.
Картинка вот этого пути сейчас вот такая.
Да, вот какое-то сплей дерево. Причем левое под дерево – это все, что вышевое, а правое – все, что ниже.
А мне нужно отрезать вот это как раз ребро, то есть мне нужно сделать его невыделенным.
Давайте просто отрежем.
Отрежем и назначим ПТР вот отсюда, вот туда.
Потому что когда я отрезаю, то есть когда я делаю ребро невыделенным,
у меня, во-первых, разрушается сплей дерева, во-вторых, получается, что вот это маленькое сплей дерево подвешено вот сюда.
Ну, давайте так и сделаем.
Мне нужно сказать, что ПТР от правого сына – это В.
Значит, ПТР от В.райт – это В.
Я назначил ПТР, потому что теперь это отдельное сплей дерево, оно должно отсылаться сюда.
Ну и отрезаю ребро.
Говорю, что В.райт равно ну ПТР.
Вот.
Я за три строчки выполнил вот это вот нижнее условие, что все ребра, исходящие из В, невыделенные.
Согласны?
Чудно.
Все, значит, здесь я преодолел трудности, теперь у меня вот здесь вот происходит конец моего сплей дерева, здесь все хорошо.
Теперь мне нужно пройти снизу вверх и все невыделенные сделать выделенными.
Ой, ну давайте.
Значит, при этом, смотрите, В у меня теперь сейчас корень своего сплей дерева.
Будьте здоровы.
Я напишу следующее.
Пока ПТР от В не налпойнтер.
Потому что, смотрите, сейчас В – это корень своего сплей дерева.
В корне сплей дерева ПТР от В указывает как раз такие.
То есть вот корень вот этого сплей дерева указывает вот сюда вот.
ПТР от него – это вот эта вершина.
Как раз таки родительская вершина на восходящем пути.
Значит, вот сюда мы указываем.
И пока вообще есть родитель, то есть пока я не объединил все в один большой путь до корня,
мне нужно вот это вот ребро между этим деревом и вот этим, и вот этой вершиной сделать выделенным.
Ну давайте будем делать это как-нибудь.
Во-первых, давайте его обзовем.
Пусть это будет У.
Тогда у меня картинка такая.
Вот есть У.
Вот есть сплошной путь, который целиком подвешен к У.
При этом корнем является вершина В, которая имеет ПТР вот сюда.
Так давайте я нарисую по-другому.
Вот есть наш путь.
И здесь где-то В, и она ссылается вот сюда.
То есть по факту это отдельный сплей дерева, У в каком-то другом сплей дереве.
Мне нужно их объединить сейчас.
Мне нужно выделить это ребро и их склеить по факту.
Ну тут как обычно, смотрите, если внезапно у У есть какой-то выделенный сын,
то есть если из У кто-то исходит, вот он У, если здесь есть нисходящее выделенное ребро,
то мне нужно его удалить.
Ну потому что не может быть два выделенных ребра сходящих от одной вершины.
Значит тогда мне нужно сначала У сделать корнем и отрезать правого сына.
Потому что отрезание правого сына это как раз таки обрубание нисходящего выделенного пути.
То есть я первым делом избавляюсь от выделенного ребра, если оно из У торчало.
Как я это делаю? Я делаю сплей от У и отрезаю как обычно.
Вот у меня, представьте, у меня было У, здесь левое правое под дерево.
Мне нужно отрезать это ребро, ну и соответственно нужно не забыть ПТР вот сюда назначить.
Потому что это вот все на самом деле подвешено к У.
То есть на самом деле вот это вот я просто повторяю.
Я говорю, что ПТР от U.right равно U.
И U.right равно 0 ПТР.
Это? Да.
Да.
Еще раз?
Конечно, конечно, конечно, да.
Указатель на область памяти, сама эта область памяти не изменилась.
Ушка лежит там же.
ПТР от В? Сейчас, сейчас изменим.
Смотрите, это мы только подготовку сделали, мы раз выделили это ребро.
Теперь вот это ребро тоже не выделенное.
Что это значит? Это значит, что теперь картинка вот такая.
У У нет правого сына, потому что я его только что отрезал.
И мне нужно подвесить под дерево с корнем В справа к У.
То есть мне нужно вот это вот все подвесить вот сюда.
Потому что вот это вот все должно идти справа, потому что оно ниже.
Вот это вот все ниже чем У.
Поэтому мне нужно просто вот это вот подвесить в качестве правого сына.
Значит, я говорю, что вместо этого я говорю U.right равно В.
Потому что В это корень того сплей-дерева.
Ну и давайте для красоты сделаем ПТР от В равно 0 ПТР.
Потому что В перестало быть корнем своего сплей-дерева.
И ПТР я не храню для некорневых лишин.
ПТР хранится только для корня сплей-дерева.
Если я ничего не забыл, то на этом эксползу закончился.
А ну и В равно У, конечно, да.
Чтобы подняться, мы теперь будем подвешивать.
Когда я сделал вот это вот переподвешивание, вот это вот.
У меня вот это вот все одно большое дерево.
И мне нужно его подвесить вот сюда.
Ну а корнем будет выступать, то есть я вот это переназову за В.
И вот это под дерево целиком буду подвешивать снизу вверх.
Не соответствует, но я вот здесь, когда рисовал,
я многократно говорил, что путь сверху вниз,
то есть сверху вниз в нормальном дереве,
это путь слева направого сплей-дерева.
Смотрите, у меня в моем неявном сплей-дереве
все вершины можно перепорядочить слева направо.
Стали в корень, сначала печатаем левое под дерево,
потом корень, потом правое.
Стандартный обход. Поняли, отлично.
Ну и собственно это порядок мы просто всегда поддерживаем.
Все, вот я утверждаю, что этот код сделал следующее.
Он взял, прошелся по пути от В до корня.
И все эти ребра сделал выделенными.
Понятно, я просто носили, вот эти ребра сделал выделенными.
Склеивал все вот эти сплей-деревья.
Попутно отрезая вот эти вот хвосты, если они были там тоже подвешены.
Все.
Ну и дальше, если мне нужно найти сумму на этом пути,
то поскольку это все одно большое сплей-дерево,
то сумма в нем, это просто сумма в корне.
Ну а в корне там просто за вот эту дницу можно найти значение.
Понятно?
Вот, ну зашибись.
Значит, почему это работает?
Это конкретно не такая реализация.
Каждая конкретная итерация может работать долго.
Потому что в худшем случае, если все эти ребра не выделенные,
то нам придется N раз перевыделять ребра.
Но вот учетно будет за логарифом, оказывается.
Ну потому что сплей-дерево.
Давайте пока я скажу, что будет учетно за логарифом.
Это мы докажем.
А пока давайте разберемся, как все остальные операции работают.
То есть вот с гитсам мы вроде разобрались.
Мы поняли, что гитсам можно просто вызвать экспоуз.
И тогда сумма на пути, это значение в корне.
Давайте попробуем понять, как работает линк и кат.
Значит, давайте попробуем понять, что происходит сначала с кат.
Кат у В.
Значит, у меня было какое-то там дерево,
где было в частности ребро из УВ.
И там что-то вот здесь еще было.
Мне нужно его удалить.
Но это вроде не очень сложно.
Мне нужно сначала это ребро сделать не выделенным.
Если оно было выделенным.
И просто его отрезать.
Сейчас. Продон.
Да даже проще.
Удалить не выделенное ребро вообще ничего не стоит.
Нужно просто ПТР от В занулить.
Потому что единственные связки от того, что у меня ребра не выделены,
как у меня вообще не выделены ребра хранятся в моей структуре?
Только с помощью ПТР-ов.
Потому что в сплэгеревах только выделенные ребра лежат.
А не выделенные получается только за счет ПТР-ов.
Потому что, например, у меня вот это подвешено к тройке,
как раз по не выделенному ребру.
Поэтому из 13-ти идет ПТР в тройку.
У меня как раз не выделен это в точности ПТР-ы.
Значит, если бы это ребро было не выделенным,
выделенным, то мне нужно было просто ПТР от В занулить, сказать, что это нул ПТР. И все, и тогда это
ребро автоматически удалится, потому что мы не знаем, что оно существует. А они никак не подвешены.
Значит, тогда нужно сначала сделать ребро не выделенным, если оно было выделенным, а потом ПТР от В
занулить просто. Сделать УВ не выделенным, ну и ПТР от В равном на ПТР. Давайте скажу, что В равном
с плей от В, чтобы оно корнем стало сразу, потому что ПТР у меня только для корня определен. И вот
давайте ПТР от В занулить. Так, хорошо. Еще раз. Продон, не эксполс, с плей только мы сделали. Да,
так нам ровно это и нужно сделать, потому что теперь это разные деревья, они не связаны. Все, В корень
своего дерева. Нет, не должны, потому что все, здесь это разные деревья, они никак не связаны,
они независимы, мы не должны друг из друга их получать. То есть у вас там было, не знаю,
например, у вас было одно большое дерево. Что такое КАТ? КАТ это по факту разделить ваше дерево
на два. Вот первое, вот второе. Они между собой не связаны никак. Это свой независимый
самостоятельный корень, они никак между собой не коррелируют. Мы просто забываем про их связь.
Так, ну и линк давайте. Линк УВ. Значит это что значит? Значит у меня было под дерево с корнем У,
я хочу подвесить к вершине В. Что можно сделать? Я хочу вот эти два дерева склеить с помощью этого
ребра. Да, да, да. Значит У равно с плей от У. Сейчас зачем пишу? У меня просто, у меня с плей,
наверное, Void просто работает. Да, плей ничего не возвращает. Я делаю У корнем своего дерева и
говорю, что теперь оно подвешено к В. Вы про ПТР говорите? Ну да, вы про то, что происходит с ПТР,
когда мы делаем с плей. Ну да, то есть на самом деле ПТР это какое-то внутреннее поле для корня,
с плей в частности у меня меняется корень после поворота. Надо еще внимательно проследить,
что когда мы поворачиваем, мы меняем ПТР. То есть если скажем, у меня была вот такая вот картинка
для зига, я делаю зиг и меняю местами ПТР от X и ПТР от P, потому что это стало корнем, а это не
корнем. Просто можно посвопать эти поля. Перерыв. Так, давайте дальше поедем. Вы против? Я понял.
Смотрите, на самом деле с точки зрения реализации я все рассказал. Да, вопрос,
типа насколько вы это поняли, ну вот я пытался. Теперь давайте попробуем доказать, что это учет
работает за алгорифм. Для этого нам нужно немножечко вспомнить, как работает с плей деревом,
точнее, какой у него учетная стоимость сплея. Кто-нибудь помнит, какая учетная стоимость сплея?
Точно. Это определение вы говорите более-менее. Это тоже скорее следствие. Значит, на самом деле,
когда мы доказывали что-то про сплей, мы говорили, что учетная стоимость сплея не больше чем один плюс
утройная разность рангов. В конце минус в начале. У нас была такая форма. Это прям было.
Там мамой клянусь. Вот, мы сейчас ее немножечко подправим и будем ей пользоваться. Значит,
смотрите. Давайте я напомню, что у нас такое было R в обычном нормальном сплей дереве. Значит,
вот у меня было какое-то сплей дерево. Я давайте скажу следующее. Вот раньше у меня для каждой
вершины был определен вес равный единице. Для каждой вершины V вес равен единице. Дальше я
определил S от V как сумму весов по дереву. Сумма U под дереве V, W от U. Потому что раньше S это у
меня был просто размер текущего под дерево. Вот есть какая-то вершина V. Я знаю все вершины,
достижимые из нее внутри сплей дерева, и размер это был в точности S от V. То есть по факту сумма
W тоже самое. А рангом я называл просто двоичным логарифм размера. Лог2, S от V. Это то, что было
раньше. И если я вводил вот такие вот всякие штуки, то мы с вами показывали, что учетное время
работы сплей не превосходит один плюс у тройной разности нового ранга X up, то есть после того,
как я сделал сплей от X, и старого, то есть до того, как я сделал сплей от X. Теперь давайте
немножко изменим. Давайте скажем, что у меня у каждой вершины вес не единицы на самом деле,
а суммарный размер всех сплей деревьев, из которых по ПТР можно добраться до V.
Картинка. Вот есть одно сплей дерево. В его вершины с помощью ПТР ведут какие-то стрелки из других
сплей деревьев. Мы помним, у нас много сплей деревьев. Они как-то друг на друга ссылаются. То есть
корень каждого сплей дерева указывает на какую-то вершину в другом. Так вот, давайте посмотрим на все
ребра, торчащие по ПТР вот сюда, вот в эту зашинку V. Ну это какие-то сплей деревья, скажем. Вот это,
вот это. Это все стрелки ПТР. И вот это. Также давайте посмотрим, кто еще к ним подвешен по ПТР.
Есть какое-то другое сплей дерево, которое вот сюда по ПТР подвешено, и еще кто-нибудь вот сюда
подвешен по ПТР. Ну и так далее. Давайте рассмотрим цепочку, точнее рассмотрим все сплей деревья,
из которых по цепочке ПТР можно попасть в V. И вот это я назову весом вершины V. Вес V это,
давайте я напишу так, один из-за учета вершинки V, плюс суммарный размер всех сплей деревьев,
из которых по ПТР можно добраться до V. Всех сплей деревьев, из которых по ПТР можно добраться
до V. Вот такое странное определение. А S и R я оставляю. Значит, давайте я просто вот эту строчку
сотру, все остальное я оставлю. S это сумма дубльвешек из-под дерева, R это additional
grief mass. То есть, например, давайте какую-нибудь картинку нарисую. Если у меня есть вот такое вот
сплей дерево, одно, сюда торчит, скажем, такое сплей дерево, сюда такое и к нему еще подвешено вот
такое, пусть вот будут размеры X, Y, Z. Тогда у этой вершинки W вес равен 1 плюс X. Давайте я сразу S
буду писать. 1 плюс X, потому что вот она сама и еще по дереву размера X сюда подвешена. У этой
вершины S это она сама плюс Y, плюс Z. А у этой вершинки я складываю веса детей и добавляю единицу,
ну потому что сюда больше никто не подвешен. То есть, нет другого сплая дерева, которое указывало
бы сюда по ПТР, поэтому здесь вес у этой вершинки будет просто один, больше никто к нему не подвешен.
Поэтому S, вот эта вот сумма весов из-под дерева, это будет 3 плюс X, плюс Y, плюс Z. Вот это я нарисовал
значение S для вершины этого под дерева, для вершины этого сплай дерева. Еще раз? Да, вот ровно, ровно это так, да.
Значит, оказывается, что при таком изменении потенциальной функции, да, то есть, я, смотрите, я что сказал,
я сказал, что у меня вот есть эти ранги, и давайте я скажу, что потенциал внутри сплая дерева это,
как обычно, сумма рангов по всем вершинам. Да, это потенциал. Ну и тогда можно показать,
что учетное время работы опять подчиняется такому неравенству. Вот это я ставлю без доказательства,
ну потому что надо просто в точности повторить доказательства, которые мы в первом семестре
приводили, потому что все вот эти вот зигзиги, зиги и зигзаги, они на самом деле, ну то есть,
им на самом деле более-менее пофиг на точное значение W. Всем, чем мы пользовались, это что-то типа
там, когда мы что-то поворачиваем, мне нужно доказать, что там 2000 логарифм чего-то меньше, там,
какой-то суммы, и это все сводило к тому, что вот это плюс это не покрывает все дерево. Значит,
там было примерно такое рассуждение, что сумма этих размеров не больше, чем все дерево, не больше,
чем вот это вот все. Вот. Ну и здесь тогда то же самое, если тут просто какие W хранятся,
вы суммите эти W и эти, понятно, что вы там не больше, чем всю сумму W набрали. Вот.
Поэтому вот это вот условие у нас сохраняется. Учет на время сплея вот такое будет. Это без
заказательства. Потому что иначе пришлось бы передоказывать весь сплей. Нет. Значит, вот это
уже не без заказательств. Ну все. Ну все. Значит, тогда теперь наконец давайте я веду общий потенциал всей
нашей системы. Общий потенциал такой. Ну, во-первых, вот эта вот сумма рангов по всем по деревьям,
по всем сплее деревьям точнее. Во-вторых, будет второе сплагаемое, которое будет равно следующему.
Это количество тяжелых не выделенных ребер. Что такое тяжелые ребра? Смотри прошлую лекцию.
Мы определяли heavy-loading-композицию. Мы про каждое ребро говорили. Что такое? Ну,
точнее, для каждой вершины. Я смотрел на размеры поддеревьев. Находил самое большое и говорю,
что это самое тяжелое ребро. То есть, если скажем, вот это поддерево самое большое, то это тяжелое
ребро. Вот оно. Более того, heavy-loading-композиция там как-то однозначно определена. Я говорю,
что если несколько равных, то выбираем самый левый. Там с минимальным номером. Так вот,
давайте помимо потенциальной функции из сплея дерева добавим количество тяжелых не выделенных
ребер. И вот с такой потенциальной функции у меня получится как раз логарифминская учетная
стоимость. Ну, давайте попробуем понять, почему это так. Что мне нужно по факту? Самое сложное,
это у меня Expose. Чтобы найти сумму на отрезке, мне нужно допустить Expose. Я про него сказал. Он
непонятно сколько работает. Потому что там может быть много не выделенных ребер на пути. У них
нужно все выделить, склеить деревья и так далее. Давайте поймем, за сколько работает Expose. Напоминаю,
что учетное время при введении потенциальной функции мы считаем так. Мы считаем реальное время
работы. Плюс изменение потенциала. То есть, вот это вот реальное время работы. Ну,
а это на сколько изменился потенциал? То есть, финовый минус фистарый. New минус field. Вот.
Хорошо. Теперь давайте вот эту сумму разобьем на два куска. На те операции, которые происходят
внутри сплей. Вот этих вот сплей. И все остальное, соответственно. И то же самое с потенциалом.
Потенциальную функцию я разобью отдельно на то, что происходит внутри сплей деревьев и отдельно
количество тяжелых ребер. То есть, по факту у меня время работы складывается из двух компонентов.
Во-первых, сложная операция — это сплей. Потому что сам сплей по себе может долго работать. Потому
что дерево может выражаться в бамбук и так далее, чтобы его переподвесить, может потребоваться много
времени. Но также вот этот вот while может долго работать, потому что он работает. Сколько было
невыделенных ребер на пути, столько мы делаем итерации while. Не нужно все ребра выделить. И вот
давайте тогда разделим эти две составляющие. Во-первых, я напишу так out expose. Это out splay.
Точнее сумма сплейов. Сумма out splay. У меня сплей многократно вызывается от разных вершин.
Давайте я их назову viter. Я вызывал сплей от v, потом сплей от u, потом сплей от его ptr и так далее.
Давайте вот набор вершин, от которых я вызываю сплей, это будет viter. Это будет v0, это v1,
потом еще раз v2, v3 и так далее. Значит, учет и время сплейов плюс учетное время, ну вот всего
остального. Учетное время, давайте напишу, выделение ребер. Потому что время работы складывается из
переподвешивания зигзигов внутри сплей дерева и того, сколько раз мы это делаем. Потому что
каждое выделение ребер еще сопровождается от единицы действий. Я какие-то ptr переназначаю,
делаю детей, переподвешиваю, ptr опять вот здесь поменял и так далее. Вот это вот время, это,
грубо говоря, все, что внутри while прошло, кроме сплейов. Сплей отдельно и все остальное внутри
вот этой штуки. Так, ну хорошо. Значит, вот это вот я знаю, за сколько работает. Это потому нашему
утверждению, сумма по всем i, то есть по всем вершинам откуда мы называем сплей, единица плюс утрой
на разные странгов. r штрих от vi минус r от vi. Ну и плюс еще вот эта вот страшная штука.
Значит, давайте это пока оставим. Давайте, раз мы уже начали с сплей дерева, давайте вот с этим
разберемся. Простой факт. r и плюс один, сори, r и vi плюс один больше равно r штрих от vi.
Давайте поймем, что это значит. Смотри, что такое vi под штрихом и vi плюс один просто.
Но давайте нарисуем. Вот в какой-то момент я говорю, я рассматриваю вот одно целиком сплей
дерева. В нем есть вершина vi, которая является корнем. Это все подвешено вершине vi плюс один,
которая тоже является частью какого-то там выделенного пути. И я утверждаю, что после того,
что такое r штрих от vi. Ну это момент как раз, когда я подвешиваю это по дереву целиком сюда,
а r от vi плюс один это момент, когда я вхожу по факту вот здесь. То есть когда я вот здесь уже
все отрезал и переподвесил, ну короче по факту склеил вот эти два пути. То есть r от vi плюс один
это какой ранг вершины vi плюс один в момент, когда мы вот сюда вот зашли и уравно vi плюс один.
Вот здесь когда уровну vi плюс один, я измеряю ранг. То есть вот здесь будет ранг, а здесь будет ранг
штрих, потому что после сплея. Вот. Ну тогда понятно, потому что что такое ранг vi? Давайте
напишем s штрих от vi, потому что неравенство между логарифмами то же самое, что неравенство между
s-ками. То есть я потенцирую это неравенство, получаю эквивалентное с точки зрения s. Что такое
s от vi и vi плюс один? Для vi это все, что по птр смотри в это поддерево. А для vi плюс один это все,
что смотрит сюда или еще вот сюда. Потому что я вот это поддерево подвесил к vi плюс один,
а значит все, что было достижено по птрам, точнее по птрам до вот этого поддерева,
до вот этого сплея дерева, теперь в частности отсюда можно добраться до vi плюс один. Ну просто
потому что я вот это вот все подвесил как бы целиком сюда. То есть я склеил эти два дерева,
поэтому ранг здесь только увеличился. Все, что раньше было достижено по птрам, то есть все,
что раньше по птрам указывалось сюда, оно осталось. Но теперь также добавилось все,
что раньше указывалось сюда. Теперь оно тоже указывает вот сюда. То есть по птрам можно
подняться сюда, потому что все одно сплошное сплое дерево стало. Получается такое неравенство.
s' да. Ну и все, тогда я вот эту штуку могу оценить. Смотрите, у меня каждое следующее вычитаемое больше
чем предыдущее уменьшаемое. Поэтому я могу написать здесь меньшее равно 1 плюс утроенный
последний ранг минус начальный. R'Vk-R'. Ну а, пардон, да, k. Даже видимо k плюс 1. Да,
спасибо, это я наложал. Здесь будет k плюс 1. Там будет утроенная разность. То есть смотрите,
у меня с помощью вот того неравенства, у меня сократятся там R'V0 и R'V1. R'V1 и R'V2 и так далее,
все сократятся. Останется только R'V0 и R'Vk, где 0 это самое первое слагаемое, k это последнее.
И единица сложится в k плюс 1. Так, вроде хорошо. Вроде хорошо. Ну и при этом, смотрите,
эта штука, понятно дело, от логарифма. Потому что R это у меня логарифм от s, а s это количество
вершин, из которых по ПТР можно добраться до данной. Понятно, что это не больше, чем общий
размер всех деревьев. Значит, это есть логарифм. Вот. А пока непонятно. На самом деле,
повторю, k это количество итераций в цикле while. То есть сколько ребер я делаю выделенными,
сколько ребер было не выделенных, и я их выделяю. Вот это k. Но у нас же они не тяжелые,
не легкие, они пока непонятны какие. Вот тут сейчас будет играть второе слагаемое,
учетное время выделения ребер. Так, ну давайте разбираться. Давайте нарисуем картинку. Что
происходит при выделении ребер? Вот есть наша V, V0, вершина которой мы начинаем. На этом пути
есть какие-то не выделенные ребра. Их всего k. Значит, к невыделенных ребер. Давайте их
классифицируем. Смотрите, у меня же ведь потенциалия, у меня учитывается количество
тяжелых не выделенных ребер. Вот давайте теперь эти не выделенные ребра расклассифицируем на
тяжелые и легкие. Вот пусть k это x плюс y, где x это количество тяжелых, а y количество легких
из вот этих вот не выделенных. Количество тяжелых это количество легких. Тогда смотрите,
в чем прелесть тяжелых ребер? Вот этих вот не выделенных тяжелых в том, что после эксполза они
становятся выделенными тяжелыми. А значит потенциал уменьшится хотя бы на x. Потому что раньше
они учитывались в потенциале, они были тяжелые не выделенные. Дальше я их выделяю, но они остаются
тяжелыми, потому что структура дерева не меняется. То есть я не меняю структуру дерева, я меняю
только понятие выделенности и невыделенности. Я меняю только сплей деревья. Значит, те которые
были тяжелыми останутся тяжелыми. И вот эта вот штука уменьшится хотя бы на x. Потому что x
ребер были тяжелыми, но не выделенными, а станут тяжелыми выделенными. Поэтому потенциал уменьшится
хотя бы на x. Вот, ну а с y непонятно. Так, что непонятно? Сейчас скажу. Момент.
Да, это правда. Это спасибо. Давайте сразу напишем, что y не больше, чем log n. Потому что
легких ребер на любом восходящем пути максимум log n всегда, это правда. Так,
у меня дельта фи не больше, чем у-х. А, так я понял, смотрите. Проблема выделения может быть в том,
что если вот это вот было легким-невыделенным, то, возможно, у меня вот здесь вот торчало тяжелое
выделенное. А я беру, его не выделяю, а это выделяю. То есть, возможно, из-за того, что я вот эти вот
ребра делаю выделенными, у меня, возможно, потенциал ухудшится. То есть увеличится на y,
потому что ребра, которыми я пожертвовал, чтобы сделать y выделенными, возможно, тоже были тяжелыми.
То есть они вполне себе могли быть тяжелыми выделенными. И мне пришлось их сделать невыделенными,
увеличив потенциал на 1 и сделать вот это ребро выделенным. Поэтому количество тяжелых невыделенных,
Давайте напишем, что количество дельта, вот количество тяжелых невыделенных,
количество тяжелых невыделенных будет меньше равно, чем у-х. То есть оно точно на х уменьшится,
хотя бы на х уменьшится за счет вот этих вот тяжелых невыделенных, а не ребер. И, возможно,
увеличится, но не больше, чем на у, потому что каждая легкая невыделенная дает, ну как бы,
ухудшает не больше, чем на один ответ, потому что оно могло быть соседом только одного тяжелого
невыделенного, который станет невыделенным. Поэтому от у у меня в сумме будет не больше,
чем у. То есть оно ухудшит не больше, чем на у. Давайте напишем. Давайте я вот это расшифрую,
так как каждая ранее тяжелая невыделенная ребро станет выделенным. Это отвечает слагамам
минус х. Каждая тяжелая невыделенная станет выделенным. Вот. А каждая легкая невыделенная
после его выделения может испортить максимум одно тяжелое ранее выделенное. А каждая легкая
невыделенная после своего деления портит не больше одного тяжелого выделенного.
Это отвечает слагамам меньше равно, чем у. Ну все. Так. И при этом х и у равно к. Теперь надо
собрать. Да, давайте вот здесь напишу, что вот это вот время. Это по факту что-то типа у минус х.
Потому что, что такое, давайте попробуем понять, что такое учетное время выделения всех ребер.
Это по факту время, учетное время работы всех операций, кроме сплея, внутри вайл. Какие здесь
операции? Тут все операции, на самом деле, работают за единицу. Вот эти все операции работают за единицу.
И я знаю что происходит с потенциалом. Потенциал меняется настолько, не больше, чем настолько.
Ну и давайте я напишу плюс у от k. Потому что у от k это реальное время работы всех этих операций.
А учетное время, это всегда реальное время работы плюс изменение потенциала. Потенциал изменится
настолько. А реальное время работы у от k, потому что время работы этого вайла, кроме сплея,
пропорционально к, потому что внутри какие-то тривиальные операции. Все, теперь если все это
сложу, смотрите, у меня здесь будет... да, я могу вот это вот к разложить как... сейчас,
пардон. Плохо, да? k не должно... извините, секунду, секунду, секунду, секунду. Плохо,
это я не хочу написать здесь. Сейчас. Так, да, там будет k плюс log n примерно.
Момент.
Смотрите, пафос в том, что если я вот это k распишу как x плюс y плюс 1, у меня x взаимно уничтожатся,
останется 2 y, а y я знаю, что есть логарифм. Тогда у меня получился у человека как раз логарифм.
Х сократятся, останется логарифм плюс 2 y, а y это логарифм, потому что легких на пути как раз
максимум логарифм. Будет все хорошо. Вопрос, почему можно здесь написать что-то подобное?
Почему учетное время всего остального это y минус x? Ну, вот он, потому что... я оценю вот
эту часть, вот она, x плюс y плюс 1 плюс логарифма, плюс учетное время выделения, это не больше,
чем y минус x. Вот он, короче, плюс. Сейчас я пофиксирую. Ну, короче, смотрите, потому что с
ватка на самом деле не получалось. Я скажу как надо. Значит, давайте так. Рассказ Гоблина. Здесь
можно сказать, что вот это вот все работает ну типа быстро, поэтому я тут все стер. Если чуть
аккуратнее, надо на самом деле мне подправить потенциал. Я не хочу этого делать, давайте
красным каким-нибудь сделаю. Смотрите, на самом деле давайте скажем следующее. Давайте скажем,
что все вот эти вот операции работают за c действий, c константа. Тогда суммарно,
while работает за ck плюс время работы с плей-офф. Давайте вот этот c вот сюда вот помещу. Тогда у
меня здесь будет c, здесь будет c, здесь будет c на k плюс 1, а здесь будет плюс ck. И у меня как
раз вот то вот ck с этим, вот те cк сократятся вот с этими, ну или там c плюс 1, ну короче,
короче, вот этот x сократится вот с этими и будет все хорошо. Ну давайте, давайте, раз уж взялся,
давайте я это доведу. То есть еще раз, смотрите, я вот здесь вижу раз, два, три, четыре, пять,
шесть действий. Вот давайте c равно шести. Ну какая-то константа, конкретная константа. Сколько
времени мне нужно, чтобы все это сделать? Давайте, давайте эту константу мультипликативно вынесу
перед потенциалом для всех сплей-деревьев. Тогда у меня здесь останется множитель c. Здесь учетное
время выделения всех ребер, это по-прежнему y-x, потому что настолько изменяется потенциал,
плюс ck это реально время работы, потому что k итерации и здесь по c действия на каждой итерации.
Теперь здесь у меня здесь будет c, здесь будет множитель c, здесь множитель c. Тут остается вот
логарифм, потому что константа по-большим съедается, а здесь будет что-то типа t на x плюс y плюс 1.
Ну и, видимо, надо даже не c, а c плюс 1 написать. А, и c минус 1 хватит, сейчас. Давайте я напишу,
что ck это c на x плюс y и мне нужно, короче, чтобы вот этот x сократился вот с этим x.
Значит, здесь надо написать c минус 1, вроде бы. Ну, подгон. Короче, надо подобрать такой коэффициент,
чтобы все сошлось. Ну, c минус 1, если я здесь напишу, то у меня здесь будет c минус 1,
здесь будет x как раз таки на 1 минус c плюс y на 1 плюс c. Этот x сократится с этим и останется
от логарифма плюс y на c минус 1 и плюс еще 1 плюс c. Ну, то есть, короче, y на константу.
Ну, y я знаю, что это логарифм, и все сошлось. Где? Правее? Так, что здесь не так? А, не сходится,
да? Здесь будет тоже c минус 1, потому что здесь будет нож для c минус 1. Ага, момент. А, нет,
здесь не будет. Почему? То есть, тут надо 1 минус c, да? Было написать? Ну, вы поняли, короче,
доводится. Вообще, часто эти рассуждения опускаются. Говорится, ну, там на константу
домножить, и как раз вот этот x сократится с тем. Ну, вот если возиться, то, ну окей,
1 минус c я здесь поставлю. Тогда как раз там, короче, будет нужный коэффициент. А у меня
потенциал изначально нулевой, потому что ранги у всех нулевые, количество тяжелых вообще нет,
Ребер, потому что изначально ноль, а в конце ограничен по логарифмам, поэтому ничего страшного.
Вот даже отрицательность тут ничего не спортит. Ну, вроде все. Ну, давайте обсудим, что здесь
можно вынести о шпаргалку. Все? Полезно. Ну, я подумал, что это будет как-нибудь, не знаю,
типа наутал вопрос, чтобы не всех этим мучить. Наверное, неплохой план, да. Ну, подумаем. Вот.
Значит, давайте последнее скажу, последние пару минут. Как можно было бы решать эту задачу,
если бы у меня, надо было сказать, сумма на пути, на произвольном пути, а не только вот вершина до
корня? Ну, вот не совсем. Мыльца не можем находить, поскольку у нас дерево динамически перешли,
мыльца не можем находить. Как? Ну, они же переподвешены, их глубины меняются.
Изначальное дерево что? Не, у нас изначально, вообще изначальная конфигурация у нас вот такая,
все отдельные вершинки. Между ними проводятся и удаляются ребра. Поэтому с ульца, ну, скажем так,
я пока не понимаю, как это делать. Давайте расскажу, как знаю. Может, можно и по-другому.
Итак, как искать сумму на произвольном пути? Ну, вот есть какие-то вершины В и У. Давайте мы сначала,
как обычно, запустим эксполз от В и найдем сумму на восходящем пути от В до корня. Потом,
что происходит с У? Давайте мы тоже запустим эксполз от У и в какой-то момент его остановим.
Что делает эксполз от У? Он потихонечку расширяет контролируемый этот вершины путь. Он был сначала
такой, потом он приклеил вот такой кусочек, такой кусочек и так далее. Это слишком, не нужна хэшмапа.
Мы просто в какой-то момент, на самом деле, переходим к вот этому большому пути. Тут не нужна
хэшмапа. Просто в момент, когда мы сюда переходим, мы ее делаем корнем и проверяем правду,
что у нее ПТР равно нал ПТР. То есть, когда я дошел до этого пути, это легко проверить,
что если от нее вызвать сплей, то для нее это нал ПТР. Потому что ПТР для этого дерева нал ПТР,
потому что нет никого выше. Значит, в этот момент мне нужно сделать следующее. Это к ответу добавить,
то есть то, что я уже в нашем складереве накопил, добавить к ответу. А вот это вычесть. Но чтобы это
вычесть, надо сделать сплей. Вот эта вышина Х станет корнем. Вот здесь вот находится все,
что правее, в частности В, а здесь вот находится все, что выше, в частности корень. И это нужно
вычесть. Левое по дереву нужно вычесть. То есть, по факту мы находим тот самый LCA, просто мы
его находим с помощью эксполза. То есть, мы сначала сделали эксполз от В, объединили все это в один
путь, эксполз от В. Потом запустили эксполз от У. И ждем момента, когда мы дойдем до вот этого
большого пути. Когда дошли, мы на самом деле нашли LCA. Но если мы нашли LCA, то нам нужно просто
сложить вот это и вот это. Это благо мы умеем делать. Потому что это все, это уже отдельное сплейдерево,
мы знаем какая там сумма. Но это какая-то часть большого сплейдерево. Вот это вот. Но по факту,
мы научились искать LCA через два эксполз. Ну вот, давайте тогда закончим. Спасибо за внимание и всем удачи.
