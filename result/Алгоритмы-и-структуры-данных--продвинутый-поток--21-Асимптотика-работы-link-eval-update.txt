Итак, давайте вспоминать, что у нас было.
Как вы помните, была у нас замечательная структура link eval update.
Было сделано?
Так, помните, что она значит?
Нужно делать eval, нужно делать update, да-да-да.
Вот.
Ну, чистить-то.
Ну, тут даже пока не сильно принципиально действительно, что она вообще значит.
Потому что, ну, на самом деле, как вы помните, суть сводилась к тому, что...
Ну, ладно, давайте вспомним кратко суть.
Мы помним, что у нас есть...
То есть, действительно, структура образует некое подвешенное дерево,
и в каждой вершинке находится какая-то условная чиселка.
Ну, или элемент полугруппы, ну, там, не буду сильно уменьшить.
Вот. И что-то еще надо.
Вот.
Да, дерево, естественно, не обязательно там, какое-то двоичное.
Вот.
И какие у нас операции?
Ну, операции такие, что, ну, на самом деле, у нас не деревья, а лес.
И операция link говорит там, что, ой, а, пожалуйста, возьмите корень одного дерева и подвести его к другому дереву.
eval говорит там, возьмите вершинку, прогуляйтесь по пути, возьмите все чиселки и делайте с ними что-нибудь.
А update говорит, ой, а давайте-ка, там, там, так сказать, домножите вот этого числа на то же что-нибудь.
Вот. Помните приблизительно, да?
Угу.
Вот.
Ну, действительно, в таком виде, действительно, напрашивающееся решение...
Какое у нас напрашивающееся решение?
Это, конечно же, использовать, ну, в первую очередь, и в листику сжатия пути.
Ну, действительно, мы можем заметить, что каждый раз, когда у нас...
То есть, вместо того, чтобы эту вершину подвешивать сюда, мы можем, на самом деле, подвесить сюда и записать в эту вершину вот эту, умножить на эту.
Вот.
То есть, поэтому, на самом деле, вот, то есть, поэтому, по сути, то есть, здесь можно...
То есть, одно из уже эффективных решений, которое, на практике, уже тоже может оказаться достаточно хорошим, это вида, а давайте просто не...
То есть, делаем как делаем, но просто в процессе эвала делаем и в листику сжатия пути.
И, собственно, теперь вот возникает вопрос, насколько хорошо это работает?
Возможно, мы даже уже доказывали, насколько хорошо это работает, но...
Или не доказывали?
Доказывали?
Но давайте докажем еще раз.
Потому что, во-первых, скорее всего, это будет немножко по-другому, потому что в прошлый раз мы доказывали просто то, что тогда учетная стоимость каждого этого сжатия пути будет в эгорифе.
Просто в эгорифе.
Ну, в общем, доказывали просто в эгорифе, мы там взяли простое доказательство.
А, на самом деле, мы попробуем доказать более мощную асимптутику.
То есть, там средняя будет что-то типа максимум из 1.
Значит, в эгорифом двоичной...
Сколько там у нас?
Ой, странно, да.
N квадрат делить на m.
Ну, давайте напишем на m плюс n, хотя на самом деле на m.
И поделить на эгорифом двоичной.
Там 2 m плюс n поделить на m.
Вот.
Такое мы доказывали.
Нет, ну, знакомое, потому что, да, этот результат я формулирую.
Да, мы его активно обсуждали, мы замечали, что он тут устроен так, что чем больше m, тем, оказывается, средняя стоимость оказывается меньше, согласно этой ассоциации.
То есть, в результате это сводится к тому, что, например, если m равно там доходит уже совсем до n квадрат, то тогда получается, что тогда в среднем это все вообще завод единицы работы.
Ну, правда, в общем-то, ничего удивительного в этом нет.
Потому что, ну, в общем-то, действительно, если у нас мы знаем, что у нас операция будет n квадрат, то можно вообще хоть в тупую все сжатие в пути делать сразу, и тогда все получится хорошо.
Вот.
Это вот мы обсуждали, но, по-моему, в таком виде не доказывали.
Вот давайте попробуем.
У нас, например, другая фигурка, что если у нас m сжатий, то их, ну, суммарная вина, это вот это, да, множество m плюс n.
Ну, да, то есть, ну, я и говорю, в среднем, то есть, вот так будет.
А так, да.
То есть, суммарное число m сжатий, да, было m плюс n на вот это, да.
У нас еще n на это возникает.
Ну, да, но это не сильно принципиально.
Это не сильно принципиально.
Вот почему.
Потому что очень логично в принципе считать, что m у нас будет где-то между n и n квадрат.
Ну, смотрите, почему.
Ведь, заметив, что если у нас как-то m было меньше, чем n, то это означает, что есть подозрение, что у нас n элементов просто не объединились в единое дерево.
Потому что просто не было достаточного числа юнионов, правда?
Ну, тогда, если их не было, тогда получается, что элементы можно разбить, собственно, на несвязанные группки и каждую из них анализировать отдельно.
И от этого 8. получат.
Это с одной стороны.
Ну, вот.
Ну, с другой стороны, если у нас m, там это уже порядка n квадрат,
то есть уже подозрение, что тогда уже в этом случае можно вообще не заморачиваться и делать на каждом шаге сжатие путей прям совсем в тупую.
И тогда в среднем получится объединиться, потому что у каждой вершины ее сжатие путей суммарно по-любому.
Будут не больше m, как бы вы их ни делали.
Логично, да?
Вот.
Поэтому там m плюс n, там просто m, это не сильно важно.
Ну, конечно, важно говорить, что m это, конечно, количество именно сжатий путей.
То есть, когда мы там тычем вершину и говорим, ой, осожми ее такое, пожалуйста.
Вот.
Ну, вот внимание и вопрос. Как же мы это будем доказать?
Вот. Ну, мы, видимо, если вы, возможно, мы это уже пытались доказать, но, значит, сейчас мы сделаем примерно следующее.
Значит, мы возьмем.
Так, значит, где мы тут возьмем?
Так, не с той стороны мы возьмем.
Это мы пока не будем.
Значит, идея у нас будет такая.
Смотрите.
Давайте вспомним, что у каждой вершины.
Вот, вот тут внимание, аккуратно.
У каждой вершины есть ранд.
Нет, это еще внимание.
Ну, что такое ранд?
Ну, обычно ранд.
Это тупо расстояние от вершины до самого глубокого ее потомочка.
Ну, то есть, например, вот тут ранд 0, там тут допустим 1, тут 2, тут просто 0.
1, 2, 3, а вот здесь, соответственно, 4.
Это я от ранги нарисовал, да?
То есть, это вот будет называться ранд.
В принципе, его можно в вершинах в явном виде поддерживать, правда, с аккуратно.
Конечно же, мы его будем поддерживать в предположении, что никаких сжатий пути не было, да?
То есть, есть как бы исходное дерево, с которым мы работаем.
А есть то, что получается с сжатия пути.
Понимаете, мы это называли виртуальное дерево.
Было дело, да?
Вот.
То есть, помнишь, это было отличие.
Вот.
То есть, этот ранд можно поддерживать.
Да, если использовать рандовую веристику, да?
То есть, когда там следить, что при объединении там вы подвешиваете только меньшее к большему,
обязательно там, скажем, меньшее к большему,
то тогда там еще какие-то модели, да?
Но пока мы будем просто этот ранд насчитывать.
Вот.
Ранд КТ.
Так вот.
Значит, у каждой вершины есть ранд.
То есть, вот, соответственно, да, у каждой ноты, у каждой у нас вершины есть ранд.
А, причем более того, что самое главное.
Заметим, что этот ранд вообще теоретически может меняться, правда?
Ну, потому что если мы одно дерево подвесим к другому, то ранд, скажем, к локе может поменяться.
Понимаешь?
Ну, мы сделаем еще хитрее.
Мы вообразим себе, ведь мы мысленно, вот для того, чтобы у нас было такое дерево,
мы вообразим себе, вот мы мысленно, вот для, только чисто для анализа, чисто для анализа,
представим себе, что вот мы проделали все вот эти операции, да?
И тогда у нас получается, что у нас просто все элементы пообъединялись в какое-то абсолютно единое дерево.
Единое, единое, единое, единое.
Вот оно.
Ну и так далее.
Вот, красота.
Вот, то есть абсолютно какое-то единое.
И ранд мы будем считать именно с точки зрения вот этого единого дерева.
Вот, понимаете, да?
То есть, как бы, то есть, в каждой вершине, в каждой вершине, в каждой вершине, в каждой вершине,
то есть, как бы, то есть, в каждой вершине, то есть, получается, это приводит к тому, что у нас в каждой вершине рамк раз и навсегда зафиксирован.
Вот именно рамк.
Вот рамк у него раз и навсегда зафиксирован.
Но при этом, конечно, родитель в виртуальном дереве, конечно, не зафиксирован, он меняется.
И нам, по сути, нужно с вами оценить, что нам нужно с вами оценить?
Ну, по сути, сколько, какое суммальное число раз ребра куда-то там переподвешивается, правда?
Ведь держатие пути работает за сколько?
Как бы вы сказали, за сколько оно работает?
Что нам нужно подвешивать? Одну операцию?
Да, одну операцию.
Ну да.
Да, действительно, одно сжатие одного пути работает за О от длины этого пути, то есть, за О от количества стрелочек на этом пути.
И нам, по сути, все, что нужно, это для каждой стрелочки, ну, то есть, нам нужно, получается, посчитать, сколько раз стрелочки перевесились.
А их можно как это посчитать?
А можно теперь попытаться для каждой вершины посчитать, сколько раз переподвесилась ее стрелочка, и потом по всем вершинам это просуммер.
Понятная идея?
Вот.
Или даже надо нот.
Ну, то есть, мы не будем даже по каждой вершине отдельно это считать.
То есть, мы посчитаем по всем вместе.
И поможет нам в этом еще одна интересная маркия, смотрите.
Значит, как мы будем считать?
Мы введем мистические константы.
Это, знаете, внимание, господа, мистические константы.
Вот это вот.
Пи-пи-пи-пи-пи-пи-пи.
Пи-пи-пи-пи-пи-пи-пи.
Пи-пи-пи-пи-пи.
Пи-пи-пи-пи-пи-пи.
Ну, короче, приблизительно вот то же самое.
Ну, суть более-менее одна.
Она.
Значит, спрашиваем, что это такое?
Зачем это?
Да, наверное, два надо написать, вот это вот.
Ну, суть, в общем, одна не важна.
Может, прям вот так вот, наверное.
А, может, так не делать, наверное.
Вот это, вот так вот надо делать.
Вот.
Что это такое, да?
Смотрите.
Идея, значит, такая.
Рассмотрим.
Z плюс 1 в последовательстве.
Смотрите.
Вот.
Так, ну ладно, это я многоватно рисовал, столько нам не понадобится.
Поп-пум.
З.
Значит.
Ну, первое последовательство число 0.
1, 2, 3, 4, 5, 6, 7, 8.
Так, тут число будет 0.
B, 2B, 3B, 4B, 5B, 6B, 7B, 8B.
0.
П квадрат.
Вот.
Ну, короче, и так далее.
Вот, ну.
Ну, принцип, короче, вы поняли, я думаю, да?
То есть, будет такая арифметическая прогрессия с начала в нуле и шагом в B в степени G, в жидкой последовательстве.
Ну, и здесь будет прям уже вот B в степени Z, 2B в степени Z, 3B в степени Z, 4B в степени Z, 5B.
Вот.
Рассмотрим вот такие последовательности.
И теперь будем говорить, что жила-была вершина В.
Вот.
Ну, родители постоянно меняются, естественно, да?
Значит, будем говорить, что ребро, вот это В, П от В.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Ребро, вот это В, П от В.
Это ребро класса G, если G это минимальное такое число.
Ну, давайте так напишем, чтобы не путать.
Минимальное такое I, что существует действительно такое K целое, что K на B в степени I меньше либо равно ранга от V, меньше либо равно ранга от P от V, меньше либо равно K плюс 1 на B в степени.
Вот.
Формальное определение звучит так.
Вот.
Смотрите.
То есть вообразить себе это можно следующим образом.
Смотрите.
То есть на самом деле эти последовательности может быть даже удобнее нарисовать еще немножко по-другому.
Смотрите.
Вот нулевая последовательность, вот если точечки поставить, да?
То есть 0, 1, 2, 3, 4, 5, 6, 7, 8.
Она вот выглядит вот так.
Вот давайте я вот примерно рисую, когда B равно 2.
Да?
Вот соответственно первая последовательность тогда будет выглядеть примерно вот таким вот образом.
Там вторая соответственно тоже прореживается еще два раза, там третья вот такая, ну и так далее.
А нет, вот не настолько.
Не так быстро.
Вот так вот, да?
Тут вот прям вот так вот, ну и так далее.
Понимаете, да?
И мы говорим, что, скажем, репро будет иметь ранг 3, если с одной стороны, во-первых, в третьей последовательности эти два ранга укладываются между какими-то двумя точками.
Но, скажем, вот по все предыдущих последовательностях такое нельзя.
То есть предыдущий последовательственный перескоп через какую-то точку происходит.
То есть в этом случае мы будем называть, что это репро классов.
Вот, понятная идея?
Понятнее.
Так вот, теперь давайте попробуем оценить, сколько у нас, то есть попробуем оценить количество ребер, которые мы рассматриваем в жатиях путей, через, ну, через призму, значит, соответственно, классов ребер.
То есть попробуем оценить количество ребер, которые мы рассматриваем в жатиях путей, через, ну, через призму, значит, соответственно, классов ребер.
И их изменение.
Ну, давайте смотреть.
Значит, если рассмотреть действительно какой-то такой путь.
Вот Jill был путь, и мы его хотим сжать.
Путь, путь, путь, путь, путь, путь.
И тут есть какие-то ранги.
Три, два, там, один.
Ну классов в смысле.
Там один.
Там допустим.
Тоже.
Четыре.
Вот, значит, заметим следующее.
Значит, мы можем рассмотреть следующее.
Значит, у каждого класса есть, давайте рассмотрим на этом пути, последнее ребро.
Последнее скритившееся ребро.
Вот.
И вот давайте все эти ребра по всем.
Вот есть последнее, а есть не последнее.
Вот давайте посмотрим.
Что, вот давайте вообразим.
Вот как изменится, вот что изменится у этой вершины, например, если у нее ребро не последнее в своем классе.
Точно класс изменится?
Ну, на самом деле, я бы сказал, если было B равно 2, то класс изменится.
Но если B не равно 2, то класс, конечно, не обязательно поменяется.
Но расстояние по рангам между этой вершиной и, собственно, будущим родителем на B в степени вот столько вот, конечно же, изменится.
То есть получается, что ранг может не измениться, но он не изменится только ограниченное число раз.
По именам B.
Итак, поэтому давайте теперь суммируем.
Значит, поехали.
Значит, какие у нас ребра бывают?
Значит, в этих же тех путей.
А, да, еще важный момент.
Кстати, еще может так случиться совершенно случайно, да?
Что ни в одну из этих последовательностей у нас ребро не попадет.
Тогда мы будем говорить, что все ребра, у которых нельзя задать класс от 0 до Z будут иметь автоматически класс Z плюс 1 навсегда.
Понимаете, да?
Так вот.
Итак.
Значит, вот давайте рассматривать.
Значит, какие у нас ребра бывают?
Значит, последние ребра.
Их у нас суммарно бывает.
Ну, при каждом сжатии рангов у нас всего сколько?
Z плюс 1?
Ну, в смысле Z плюс 2, да?
Поэтому пишем, что у нас на M сжатии путей будет M на Z плюс 2.
Понимаете, да?
Значит, бывают не последние изменившие ран.
Точнее класс.
А теперь сколько у нас будет раз появляться ребра, которые изменили свой ран?
а теперь сколько у нас будет раз появляться ребра, которые изменили свой ран?
ну точно не больше, чем там n на z
да, да, да, правильно
действительно, заметим, что класс может только увеличиться
смотрите, реберт у нас даже не на n-1
и изменить ранг оно может не более, чем сколько у нас там ранга
если совсем аккуратно писать, то можно писать n-1 на...
сколько получается?
ну, z-1 получается
ну если совсем
понятно, что асинтетически это не по барабану
что у нас еще осталось?
не последнее, не изменившее класс
вот
не последнее, не изменившее класс
что с ними?
сколько их?
ребро может не менять класс и подать не более, чем b раз
ну да
но потому что оно потом может изменить класс и потом еще сколько-то раз не менять
да, ну давайте смотреть
значит, у нас есть n-1 ребро
получается, что это n-1 на b, на z
ну да, да, да
то есть действительно, оно не изменить класс может не более, чем b раз
по крайней мере, по dr
но потом, соответственно, оно этот класс поменяет
так что получается b-z
ну да
так
вот
ну а с другой стороны, что у нас теперь получается?
ну на самом деле, в предположении, что b это у нас
называется m поделить на n
ну 2m поделить на n
то в принципе получается неплохо
то есть если все это просуммировать и поделить на m, то в среднем получится, как видите, o от z
потому что вот эта штука это o от m, правда?
правда, мы кое-что не учли
чего?
ну кое-что, на самом деле, мы не учли
потому что кто-то может прозикнуть ощущения
а если бы написали, что, там, я не знаю
там, действительно, b равно вот столько, а z равно, там, я не знаю, 5
то тогда просто можно было проведать то же самое рассуждение
и сказать, что у нас теперь все операции в среднем золот 5 работают
на самом деле, вот единицы, чего вы там на керману в мозге парите?
мы еще
не сколько раз может быть, когда он уже придет в класс записать единицу
вот, да, то есть на самом деле
да, то есть
то есть в этом случае, то есть надо еще учесть
кое-что еще, то есть, действительно, давайте смотреть
то есть, ребра
класса
z плюс 1
то есть, заметим, что если ребро уже стало класса z плюс 1, то оно будет навсегда
ну вот, теперь давайте думать
что значит, что ребро вообще
а сколько у нас на каждом шаге может вообще тут встретиться ребер класса z плюс 1?
вот так, вот давайте думать
вообще, что значит, что ребро класса z плюс 1?
а, значит, между рангами
да, да, да, да
то есть между рангами вершины ее родителя
единицы, делящиеся на веб-зепи
да, кто-то на веб-зепи
то есть, получается, когда вы скачете по такому ребру, вы абсолютно проскакиваете
b в степени z, умноженное на что?
ну, суммарно, ну, типа
ну, вот, то есть, получается, суммарно
вот так, ранг у нас не превосходит n
логарифен
по основанию b в z
ой, n в степени z просто
да, просто n поделить на b в степени z
то есть, на каждое, каждое же
то есть, получается, что-то типа
так, что-то
сейчас, что-то многовато получается
n умножить на n поделить на b в степени z
так
что-то у меня, по-моему, меньше будет
это нет
ну, ладно
пока вроде n на n
на b в степени z
а теперь
собственно, давайте внимательно посмотрим
давайте так
b в степени z
это сколько?
ну, смотрите, внимание
на самом деле, как бы, фишечка то
то есть, простой, если вот убить эти все округления
забить на них, да
то вообще, заметим, что такое логарифен поделить
по логарифам
да, то есть, это логарифен вот этого
по основанию вот этого
а b это оно и есть
поэтому получается, что
b в степени вот это вот
примерно n квадрат поделить на m
ну вот
то есть получается, это пример
Nn
поделить на
что там получается?
н квадрат
поделить на m
и получается, что-то не то
получается,
н квадрат поделить на m
что-то это нас не очень устраивает, честно говоря
даже в среднем как-то что
вот внимание и вопрос
что ж делать
можно ли их как-то оценить поточнее
что-то
в самом деле достаточно просто
на почте отверну
это идея очень простая
нужно просто дописать сюда слово не последние
потому что, смотрите, последние ребра класса этого мы уже учли, правда?
они уже здесь
а с последними-то то же самое
а с не последними-то происходит то же самое
то есть, а именно, что расстояние по рангам явно увеличивается хотя бы на B в степени Z
после ржатия
поэтому в результате получается, что тут не M, а то есть
то есть, каждое ребро получается может находиться тоже там в ранге Z плюс 1
то есть, вот получается N
то есть, на самом деле не M, а N
и тут получается не M, а N
в результате тут шлеп-шлеп
и получается, короче, M, N
фить-фить, короче, M, N осталось
то есть, это вот, собственно
как выяснили, да, вот так вот B и Z, в общем, так и подогнаем
аккуратней
так что, вот откуда берется вот такая симптомика
ну, можно такая, можно вот там чуть другая, но в общем
как бы принцип, откуда она берется, вот он
на ваших экранах
ну что, есть ли тут какие-то вопросы?
если есть, лучше задайте, потому что Аккерман будет доказываться дальше
будет столько повеселее
да
понятно, Манья?
или еще нет?
ну да
да, нет, наверное
или с какого-то момента повторите, там, до начала
да
не надо ничего повторять, можно идти дальше
ну давайте попробуем
ну что ж, давайте
ну теперь, чего?
все?
ладно
да, ладно
ну что ж, давайте попробуем теперь повысить планочку
ну, как там ее повысить?
потому что мы помним, что у нас на линковал-авдейт ставки были две
первая ставка была 6, и тупо делать сжатие путей, то в среднем тогда все будет работать в завод стойка
вот, но была вторая ставочка
вторая ставочка говорила следующее, что если дерево достаточно хорошее, то тут возникает какая-то там обратная функция Аккермана
вот
ну возникает два вопроса, что такое достаточно хорошее дерево и что такое обратная функция Аккермана
так, вот напомните мне, что такое достаточно хорошее дерево?
может, тут, значит, типа сумма вершин по дереву в два раза уменьшается при спуске на 2 или что такое?
ну, только все-таки мы будем не с айзами, а рангами пользоваться
ну, хорошо
ну вот, там, ну не совсем
там не в два раза, то есть, на самом деле, официальное определение звучит так
значит, давайте вспомним, что определение звучит так
а
значит, дерево у нас называется сбалансировано
внезапно
если
если что
вот
вот
если существует, например, константы, значит, a больше 1, c больше либо равно 1
что для любого теперь k
количество вершин
количество вершин v с ранг от v равно k
не более
чем
cn делить на a в степени k
то есть, на самом деле, это официальное определение звучит так, да
то есть, в СНМе это происходит
потому что, если вы используете рангную ивристику или сайзовую ивристику, а суть одна
то есть, там, по-любому, оказывается, что если вершина имеет ранг x, то это означает, что у нее там в поддереве на ней висит хотя бы 2 степени x вершин, поэтому там получается, то есть, в этом случае, там a равно 2
ну вот
и мистическая теорема теперь звучит так
что если все эти линки устроены таким мистическим образом, что итоговое дерево оказывается сбалансировано для каких-то констант а и c
то тогда оказывается, что вместо m плюс n на максимум, у нас получается m плюс n на мистическую нечто
то ли m и m, то ли m плюс n, ну я не знаю
значит, вот давайте теперь попробуем это определить
но чтобы это определить, давайте вспомним обратную функцию О'Керманна
что это такое?
значит, сейчас я
значит, смотрите
ну то есть, доказывать эту теорию мы будем параллельно с определением
смотрите как
вот сейчас мы, на самом деле сейчас, я тут вот постараюсь часть этого даже не стирать, потому что технология будет абсолютно та же
только вот эти последовательности, а также, конечно же, константы b и z будут, конечно же, другие
да и, а, ну константы b, в общем-то, не будут, на самом деле
то есть z-то будет
то есть, на самом деле, теперь я вот, смотрите, b я вообще убираю, b у меня вообще больше не будет
а z равно
так сказать, альфа от мн
значит, смотрите
значит, последовательность теперь звучит так
ну мы, то есть, на самом деле, сейчас я нарисую просто функцию О'Керманна, даже не обратную, а обычную
ну здесь, ну вы помните, да, что там, тут 0, 2, 4, 6, 8, 10, 12
ну и здесь тоже все просто
0, 2, 4, 8, 16, 32, 64, 128
здесь тоже 0, 2, 4, 16, 2 в 16, 2 в степень, 2 в степень 16
Ну здесь тоже 0, 2, 4, 16, 2 в 16, 2 в степени 2 в степени 16, 2 в степени 2 в степени 2 в степени 16, 2 в степени 2 в степени 16, 2 в степени 2 в степени 16, 2 в степени 2 в степени 16, 2 в степени 2 в степени 16, 2 в степени 2 в степени 16, 2 в степени 2 в степени 2 в степени 16, 2 в степени 2 в степени 2 в степени 16, 2 в степени 2 в степени 2 в степени 16, 2 в степени 2 в степени 2 в степени 16, 2 в степени 2 в степени 2 в степени 16, 2 в степени 2 в степени 2 в степени 16, 2 в степени 2 в степени 2 в степени 2 в
степени 2 в степени 2 в степени 2 в степени 2 в степени 2 в степени 2 в степени 2 в степени 2 liquor
а и g-1 то есть идея такая в каждой крепке я смотрите то есть иду в предыдущий ряд и
нахожу там элемент номер вот тот что слева то есть ряд сверху номер вот это
тогда смотрите вот рассмотрим такую последовательность точнее вот такую
но двумя гнома так но тут действительно кисло бесконечно какие-то длинные так что
вышел вот
ну тут утверждается даже тут всегда тут будет двоечки двоечки двоечки вот так
вот странно сейчас нет у четверчика не совсем так вроде по индукции получается что так у нас
же номерат с нуля видимо получается да в каждой строчке ну вот или не с нуля а ну да с нуля
значит не работала бы так ну тогда скажите как будто это звучит как будто эти двоечки на
самом деле не удовлетворяют условия потому что если у вас тут g равно 1 то вы как бы ищете
нулевой элемент в предыдущем ряду и тут получается 0
можно конечно просто скажу давайте тут всегда будет двоечки
странно
ну да нет понятно что да вот в первом ряду есть единички
сам самым нет ну сейчас на самом деле это мы нет ну можно попробовать
ну когда мы расписывали вот в прошлый раз мы просто говорили что тут всегда двоечки
вакуази ленивjan
не оттакиваешь
Ну, да, возможно, нет, чем вы действительно будете. Ну, то есть 0 поставить, 2 поставить, а дальше не заморачиваться. Ну, окей, хорошо. Будем считать, что тут ржи больше либо ревнут. Странно, конечно, ладно. Тиман?
Тиман?
Ай1 чего?
И больше ли ревнут выйдет за ай1, а ай2? А, ну, ай1, ай2.
Не-не-не, ну и что?
Не написано, что он на любом ревнуту у нас будет тихо тренироваться.
Ну, а тут суть одна, в общем-то. Такая вариация есть, потому что, видите, в оригинале у Тарьяна, собственно, был нулевой ряд, у которого вот так написано.
А потом же, соответственно, в первом ряду степени двойки, вот они. А, или имейте в виду, что тут у вас идентички стояли.
Не-не-не, имейте в виду, что нулева ряда нет. Сразу с первого, по сути.
А, ну, так сказать, суть одна.
Так вот, значит, чем приятна эта последовательность?
Ну, она приятна, они приятны, опять же, тем, что, как и в прошлый раз, каждая следующая последовательность, это под последовательность предыдущей, правда?
Понимаете, да?
То есть, в переводе говоря, тоже можно сказать, что они тут под какие-то точки, тут точки, тут под последовательность точек, ну и так далее, и можно абсолютно с тем же успехом вводить рамки по классовой ревне, правда?
Правда, есть маленькая оговоречка, да?
То есть, здесь мы в итоге пишем не K на B в степени, а, соответственно, пишем, получается, A от I, J.
И здесь пишем A от I, J плюс 1.
То есть, существует вот такое же.
Ладно, давайте вот тут K напишу, чтобы тут звук по кабинету.
Вот, понимаете, да?
Да, нет, наверное.
Вот давайте, прежде чем переходить к тому, что такое альфа.
Ну, то есть, смотрите, что такое альфа, нам, наверное, понадобится, в первую очередь, когда мы дойдем вот, собственно, до этого момента.
Вот не последние ребра класса Z плюс 1, да?
Вот когда мы до них дойдем, вот там, на самом деле, нам и будем думать, чему должна быть равна альфа.
Вот когда мы до них дойдем, вот там, на самом деле, нам и будем думать, чему должна быть равна альфа, чтобы весь этот анализ прокатывал.
А теперь давайте думать.
Ну, давайте анализируем дальше. Последние ребра, ну, сколько?
Ну, собственно, то же самое, правда?
Так, теперь, не последние ребра изменивших класс.
Ну, тоже, в общем-то, пока анализ не поменялся, правильно?
Так, а теперь давайте думать, сколько раз, смотрите, вот здесь начинается самое интересное.
Сколько раз у нас не последнее ребро может не изменить класс?
Показываем, как один лет назад писали, что, оказывается, это все теперь под сомнение ставится, так что надо быть еще более внимательным.
Нет, кстати, на Котфольсе, реально, вот это еще в «Плодии Димакса» пишется, что «Снимаешься, исправление топлива инстититии на Димаксе, с удивлением обнаружил, что, оказывается, хорошо известная нам временная оценка данная Тарья нам в 1975 году, кстати, поставлена под сомнение».
Вот, то есть, причем утверждается, что, причем-то, да, действительно, странная эхипсизона, что, да, причем там было, ну, там, точнее говоря, я до конца не понял, но там, как будто, да, часть народа просто утверждает, что, на самом деле, там, если правильно оценить, то, на самом деле, там, пристально можно написать, вот, единицы.
Подробностей пока не знаю, но...
Нет, это при том, что, а кому-то, возможно, удается доказать, что, на самом деле, вот эта оценка.
Ладно, значит, теперь нам все к делу. Это лирическое отступление.
Значит, итак, значит, как у нас, давайте посмотрим.
И так жило было ребро. И жило оно в классе номер И. Видите, да? Видите?
Что значит, что оно жило в классе И? Это означает, что была какая-то вот величина АИТЖТ.
Значит, и была тут вот какая-то АИЖПП.
Да? И было тут какое-то ребро.
Ну, теперь давайте думать, что означает, что оно именно в этом классе?
Это означает, что где-то вот в классе И-1, да, вот, помимо вот этих чиселок, есть еще вот какие-то.
И хотя бы одно из них обязательно на это ребро падает.
А еще верно, что... А теперь давайте думать, что означает, что это ребро не поменяло класс?
Что это означает?
Вот с точки зрения этой картинки, как было сказано.
Ну, потому что новые родители там жили.
Чего?
Ну, потому что новые родители...
Ну да, лежит где-то там же, но тут можно уточнить как.
Не просто лежит там же, а что в него стало попадать хотя бы на одну чиселку больше.
Ну, раз оно не последнее, правда?
И тогда получается, что оно может изменить, то есть получается, не поменяться рамка может не более чем сколько вот тут вот этих чиселок.
А сколько этих чиселок?
Сколько этих чиселок?
Аи-ти жи-ты минус-аи-ти жи-ты минус первые, кажется?
У нас как берется? У нас аи-ти жи-ты это аи-минус-перве с индексом аи-ти жи-ты минус-перве.
Ну да.
Аи-ти жи-ты минус-перве с индексом аи-ти жи-ты. Ну вот как раз разница между этими индексами.
Да.
И плюс, это совершенно верно, да, спасибо.
Спасибо. Значит, да, а, и, ж, и т, и тут получается, а тут получается равно а, вот я просто определение пишу, и-1, а, и, ж-1, может быть, тут, конечно, надо там вот с крайними случаями еще рассмотреть, но тем не менее.
Ну, давайте, если ж относительно большое, там, хотя бы, там, один плав, ну, хотя нас в первую очередь интересует, наверное, когда ж больше или равно 2, потому что, да, когда тут,
когда очевидно, когда очевидно ж равно 1, то получается, тогда там и рано будет равен нулю, это нам неинтересно, вот, значит, смотрите, ну, тогда, раз это так, то получается, что вот эти элементы имеют действительно индексы в этой последовательности а, и, ж, и т, и здесь, и здесь получается, что этих элементов, на самом деле, что-то типа а, и, ж, минус а, и, ж-1, можно даже еще минус 1 нарисовать,
хотя, на поверхку, можно просто, на самом деле, забить и сказать, что их не больше, чем, не больше, чем а, и, т, ж-1, вот, понимаете, да, тогда получается следующее,
и так, то есть получается, да, если у нас ребро оказалось, вот, действительно, между и, ж, и, и, ж-1, то оно может поменять свой, значит, не поменять свой класс, не более, чем а, и, т, ж, т, раз, то есть получается суммарно,
и тогда давайте просто переберем все и от нуля до, соответственно, z, и переберем все ж от нуля до бесконечности, допустим,
и говорим, что ребро, ребро, соответственно, вот такого а, и, т, ж, значит, оно может поменяться не более, чем а, и, т, ж, т, раз, умножить на, умножить на, а сколько у нас в принципе, вообще, из скальки вершин, вот, давайте подумаем, может, вообще, точать ребро, у которого, которое начинается с ранга не менее, чем а, и, т, ж, т,
может, сбалансированность?
да, теперь мы, да, мы вспоминаем, что у нас есть сбалансированность, и тогда получается, что таких вершин у нас в принципе не более, чем cn поделить на а в степени а, и, т, ж,
видите, да?
но это, а, нет, это ранга ровная, а у нас хотя бы, нет, ну тут, нет, сейчас, погодите, ну тут, да, не хотя бы, а, на самом деле, тут, ж, то, надо, наверное, так, значит, тут,
да, в чем проблема?
у нас же, нет, да, да, проблема в том, что просто она, как видите, насколько это сумма сойдется, так сказать, ну давайте думать, насколько, ну вот, насколько хорошо это сумма сойдется?
больше можно, конечно, ее, каждую, то есть, каждую, конкретную сумму, конечно, сойдется в o от n, ну потому, что это по сути подпоследовательность, последовательности x поделить на а в степени x, правда?
Каждая конкретная сумма, конечно, сойдется в O от N.
Ну потому что это по сути под последовательность последовательности X поделить на A в степени X. Правильно?
Ну, а NZ нормально же.
Ну вот.
А, ну да, ну да.
То есть это равно, ну фактически, меньше либо равно CNZ умножить на какую-то константу D.
D равно сумма X поделить на A в степени X.
X равно от 0 до A. Ну такой ряд у нас сводится.
А, у вас пока еще не на эту часть подадали за экзамен через неделю?
На эту в том числе.
На эту? О, классно, очень умно.
Да, точно.
У нас там не такое было.
А, ну да, не-не-не. Не, я просто вспоминаю, начинают эти все признаки, обилие, диреклия, сходимость, вот эти. Это все сейчас, да?
Это уже было.
А, в первом числе?
Нет.
А, ну да, в третьем числе.
А, потому что в третьем числе будут эти все, эти все эти формулы Ла-Аранжа, вот эти все, да.
Там с этими яндералами по поверхностям, как в четвертой, там будет врезаться фурье эти, да?
Это тоже будут называться ряды фурье и преобразование фурье, но, собственно, вот, возможно, вы узнаете, откуда это берется все на самом деле.
Да, но это все будет в следующем году.
Да.
Итак, ну получается, да, хорошо.
Ладно, то есть получается, короче говоря, можно здесь уверенно писать, что это O от N на Z.
И, наконец, финалочка.
Как нам подогнать теперь? Остается нам подогнать Z так, чтобы получилось O от N.
Логично, да?
Как нам теперь подогнать?
Итак, что же это за мистическая альфа?
Вот давайте внимательно подумаем.
То есть что бы нам хотелось действительно иметь от этой штуки, чтобы это было, значит, соответственно, чтобы это было O от N?
Ну давайте просто как-нибудь попробуем усыгить, да?
То есть не последние ребра класса Z плюс 1.
Итак, сколько раз, ну, то есть, как всегда, ответ у нас, как в прошлый раз, будет N умножить на сколько?
N умножить на сколько раз конкретное ребро класса Z плюс 1 может?
Это первый раз, когда в этом ряду появляется число хотя бы N.
Что-то умножить на N, кажется, что-то такое.
Например, то, что мы и делали.
Так.
Так.
Сейчас.
Так, сейчас еще раз.
Ну, у нас каждый раз, когда мы уже в классе плюс 1, это значит, что мы скидаем по числу, которое в ряду Z.
Ну, а сколько у нас может есть?
Ну, пока у нас жанна-кэпси не больше N, не больше, чем, ну, типа, как бы индекс первого, который хотя бы N.
И вот нам нужно, чтобы...
Желательно, чтобы где-нибудь этот N был константный, да.
Где N или...
Чтобы количество этих, чтобы, ну, первый раз, когда у нас N был, короче, маленький.
Ну, да.
Ну, то есть давайте так.
N умножить на, скажем так, мин такое G, что A от G от Z и G больше либо равна N.
Вот можно так оценить?
Ну, да, возможно.
Ну, да.
Вот.
Ну, можно оценить так и, в принципе, сказать, что после этого заявить, что, допустим, там, а, допустим, от N.
Это сказать, что какое-нибудь там, минимальное такое Z, что, допустим, A от Z и, например, 10 больше либо равно N.
И после этого так честно и сказать, что у нас N какой-нибудь элемент.
То есть мы ждем, когда у нас там десятый элемент станет больше либо равно N.
В принципе, на практических нуждах нас уже этого хватает, потому что, как видим, у нас тут не просто десятый, у нас тут уже раз, два, три, четыре, там, какой-нибудь пятый, шестой элемент, на самом деле, уже.
Уже молодец, видите, да?
То есть уже вот это вот, скорее всего, больше, чем любое N, которое вам на практике когда-нибудь встретится, правда?
Но Тарьян все равно, называется, все докрутил.
И официально и тут предлагается в качестве этой Альфы, на самом деле взять другое.
Значит, Альфа от МН предлагается.
Это минимальное такое.
Что там получается?
Ну давайте тоже Z напишу.
Сейчас давайте разбираться, что-то тоже странное, но почему-то за что купил, зато продаю.
Как говорится, там еще, короче.
Вот, вот теперь давайте думать.
Вот с таким Z-ом, как мы выжимаем.
А тут логи, а логи, в общем, следующие.
Значит, мы говорим, что, ну понятно, что каждое такое ребро, да?
То есть у нас N ребро.
Каждое ребро оно выполнит, значит, после первых M поделить на N увеличений.
Теперь мы гарантируем, что ранг, то есть теперь мы гарантируем, что, соответственно, у нас H будет логарифом.
А что это значит?
Ну что?
Что ранг родителя, хотя бы, да?
Что ранг родителя будет хотя бы логарифом, да.
А теперь замечаем следующее.
Да, то есть возможно тут еще надо подогнать, но нужно узнать, что работает.
Нет, поэтому я не знаю.
А теперь замечаем следующее.
Да, то есть, может быть, тут надо еще подогнать, но...
Суть в том, что...
Теперь, как вы можете заметить,
у нас на самом деле...
У нас на самом деле...
Ранг родителей, в общем-то,
у нас сильно больше что быть не может, правда?
Ну да, по нашему предъявлению, у нас не больше C таких.
Ну да, то есть, на самом деле, тут даже...
То есть, вот...
Ну да, то есть, сколько у нас вершин такого ранга?
Не более чем...
C.
Констант.
Да, то есть, не более чем констант.
То есть, получается, тогда...
После этого у нас все сжатия путей будут работать,
там, например, за O, C.
Слодично, да?
Потому что мы из каждого ранга скачем только в большие ранги,
а у нас получается вот...
Вот.
То есть, вот предлагается вот такая более аккуратная подгоночка,
которая гарантирует нам, что вот суммарно там будет все за O, C.
Вот.
То есть, получается, да, здесь...
То есть, при вот конкретно такой альфе,
действительно, то есть, получается, вот...
Вот этот вот минимум взяли,
и он, на самом деле, получается N умножить на в скобках M поделить на N,
плюс, получается, C.
Ну, вроде и все.
Угу.
Что-то даже не сильно убойно оказалось.
Способ доказать, конечно, специфический.
Ну...
Специфический.
Но красивый.
Нет, отдельная песня, знаете, на самом деле,
совсем мясо, это действительно, если пытаться доказывать,
что это альфа, эта оценка, на самом деле, минимально возможная.
Потому что пока, конечно, это выглядит так, что...
То есть, не очень понятно, почему приложено на альфа вообще оптимально.
То есть, точнее так, то есть, явно есть, наверное, какие-то соображения,
что вот есть технология, как подогнать ряд,
ну вот, а потом, давайте, как эти ряды теперь аккуратно делать,
чтобы тут и по Z сошлось, и...
Ну, эта сумма не поспорадала.
Ну вот, но дальше там начинается черная мания.
А доказали, что это минимальные ряды?
Вот непонятно.
Потому что...
Значит, зачитываем.
Значит, 11 лет назад писали так.
Значит, Емакс пишет так.
Снимаясь исправлением, дополнением статьи на Емаксе,
с удивлением обнаружил, что оказывается,
хорошо известная нам временная оценка данная тарелка,
еще в 1975 году, ставится под сомнение.
Самой адекватной критической статьей мне показал статья
о жанхе 2008 года с напленишкой в конце списка.
Хронология событий.
Значит, древность.
Известны разные реализации в ДСУ с различными юбилистиками,
по большей части, с доказанной временем, вот уже.
1973 год.
Hopcroft-Pullman.
Self-mergent algorithm.
Разработка сложного алгоритма ДСУ со всеми точками О
от иперированного алгоритма.
1975 год.
Тарьян.
Впервые доказал, что давно известные всем юбилистики
жатерпути и объединения по рангу работают за О от обратной функции атервана.
Причем доказал эту оценку как снизу, так и сверху.
1976 год.
Linear expected time of a simple union find.
Предлагаете версию ДСУ только с остащанием путей
и показывается, что она работает за О от единицы в среднем.
Впрочем, как я понял, пишет ЕМАКС,
здесь анализируются звучи, когда входные данные сами случайны.
Значит, 1979 год.
Тарьян.
A class of algorithms which require non-linear time to maintain the enjoyment set
помимо другого содержит альтернативное доказательство того же факта
про обратную функцию атервана.
80 год.
Балаховский.
Указывается, что в доказательстве Тарьян 1975 года содержалась ошибка.
И она исправлена.
И факт ошибки был признан Тарьяном в 1980 году.
Да, но ошибки это не вот в этом вот ошибке видимо,
а в том, что это типа оценка оптимальная.
85 год.
Яо.
Доказательство того, что ДСУ работает за О от единицы в среднем.
89 год.
Pridman Sachs, SSL Pro, Complexive Dynamic Data Structures.
Насколько я понял, описывается новый метод анализа
с этим точкой демократических структур данных.
Метод применяется к доказательству нижней границы
о обратной функции атервана для любого алгоритма ДСУ.
2005 год.
Приводят там два китайца, приводят альтернативную реализацию ДСУ,
которые, как они доказывают, работают за О от единицы.
2008 год.
Вроде как.
Zhang, The Union Finds Problems Is Winner.
Предлагается доказательство того, что ДСУ на самом деле работает за О от единицы.
Вот единица.
В конце статьи приводится список ошибок по мнению автора,
содержащихся в доказательствах Тарьяна 1975-1979 годов,
а также ошибка в доказательстве Pridman Sachs 1989 год.
Дальше почему-то что-то пропущено.
А, видимо, в намеку на то, что, видимо, это не конец.
В общем, весьма запутанная ситуация.
С одной стороны, доказательство Тарьяна за прошедшие 30 лет
должно было прочесано вдоль и поперек,
с другой, если после статьи 1975-го в ней были обнаружены ошибки,
то до сих пор нельзя быть уверенным, что ошибок там больше нет.
Но опять же статьи китайских авторов не слишком урушают доверия.
У меня не было силы углубляться в их доказательства,
но вдруг они доказывают поведение ДСУ на случайных ходных данных
вместо анализа худшего случая, как, например,
в первое время 1976-го, если я стану не ошибать.
Интересно, кто-нибудь что-нибудь еще слышал обо всем?
Ой.
Ой-ой-ой-ой...
Как это? Степан Гатилов там в комментариях пишет.
Я делаю из этого простой вывод.
Можно смело считать, что на практике ДСУ работает, а он от единицы.
Потому что таково время работает в среднем, доказательство раз.
От анти-ДСУ тестов я пока ничего не слышал.
Если ребята до сих пор спорят, то от единицы это все-таки или обратная функция кермана, то антидсу-тесты вряд ли существуют в природе.
Иначе за 100 лет, наверное, точно были бы обнаружены.
Я боюсь, таких тестов просто не может существовать, потому что не возможно отделить на практике константа от обратной функции кермана.
Это, скорее теоретически, вопрос такой.
Забирается ли время работы ДСУ настоящей константой или чрезвычайной мере нарастущей функции?
Как сосредоточится театр яд ДСУ?
Это первый и, возможно, последний элементарный алгоритм, который имеет настолько сложную доказанную синтутику.
Будет символично, если у этого уникума ДСУ синтутика окажется.
Ну вот, подробнее чего я вам говорю.
А, комментарии.
В Википедии пишут, что статья вот этого китайца 2008 года не прошла peer reviewing на конференции СТОЦ в 2008, после чего была удалена с сайта автора.
Все же с вероятностью 99% доказательства в день не вернуло, хотя я его поглядел, но, казалось, там показали, что это тест.
В общем, такое вот шоу.
Так что не знаю.
Так что, возможно, у вас есть шанс еще вклиниться в эту борьбу и что-нибудь сделать.
Так, ну что, есть тут еще какие-то вопросы?
Да нет, наверное, вроде не очень сложно.
Ну да. Эх, жалко, к сожалению, честно скажу.
Жалко, к сожалению, осталась только еще одна, конечно, мелочь.
Ну вот, одна мелочь, на самом деле.
То есть мы так с вами не успели обсудить, как делать link eval update в случае, когда eval равен минимуму или максимуму.
Ну, помните о червейке?
Ну, помните о червейке?
Да, ну почему...
Ну почему дальше-то она как-то отдельно остается?
Ну, в общем, ладно.
Ну ладно, думаю, он знает.
Ладно, давайте на этом такой язык мычим уже.
