Так, алгоритмы. В прошлый раз мы с вами начали рассматривать задачи сортировки
и рассмотрели три квадратичные сортировки, сортировка вставками,
сортировка выборов и сортировка пузырьком.
Каждый из них работал за квадратичное время, все плохо.
Допустим, массив размера 1000 или 10000, таким образом вы, условно,
можете сортировать за довольно быстрое время.
Быстрое я имею в виду примерно меньше, чем за секунду.
Если вам подается на вход массив размера миллион,
то ждать, пока этот массив отсортируется, вы будете довольно долго.
Давайте рассмотрим с вами сегодня первый пример сортировки,
который работает быстрее, чем за квадратичное время
и использует некоторую нетривиальную идею.
Спойлер. Сегодня мы с вами изучим сортировку слияния.
Давайте для начала рассмотрим, для простоты,
давайте рассмотрим такую операцию как слияние.
Что такое слияние? Слияние или мерч?
Соответственно, задача слияния ставится следующим образом.
Дано два отсортированных массива.
Массива A и B.
Требуется получить отсортированный массив C,
который состоит из элементов A и B.
Дано два отсортированных массива.
Необходимо сделать так, чтобы появился третий массив,
который содержит все элементы из A и B
тоже в отсортированном порядке.
Например, 1, 5, 7, 9 и есть массив 2, 3, 4, 10.
Это массив A, это массив B.
В результате слияния я должен получить массив 1, 2, 3, 4, 5, 7, 9, 10.
Давайте разбираться, как мы это будем делать.
Давайте сразу заведу некоторую функцию мерч,
которая принимает исходный массив A,
массив B и массив C, в которые нужно записывать результат.
Смотрите, первая банальная идея заключается в следующем.
Давайте возьмем два массива,
запишем их в третий,
и третий массив просто отсортируем.
Известно нам сортировкой квадратичной.
Как вам план?
Так тебе.
Если у вас суммарное количество элементов N,
сольете два отсортированных массива за квадратичное время.
Но кажется, что если у вас есть уже два отсортированных массива,
то задача получения третьего массива не должна быть такой сложной.
Будут ли какие-то приложения, как это можно сделать быстрее?
Есть идея, два указателя.
Действительно, задача мерч решается с помощью идеи двух указателей.
У нас есть два массива, два отсортированных массива.
Нам нужно получить третий.
Давайте зададимся первым вопросом.
Какой элемент будет идти первым в итоговом массиве?
Понятное дело, что какой-то из этих двух.
Либо этот, либо этот.
Мы берем первые элементы,
и мы точно знаем, что какой-то из них
это наименьший элемент во втором массиве,
это наименьший элемент в первом массиве.
Кто-то из них обязательно должен стоять на первом месте в итоговом массиве.
Согласны?
Допустим, это единица.
Что мы делаем дальше?
Какой элемент должен идти следующим?
Да, меньше из оставшихся.
А какой меньше из оставшихся?
Во-первых, мы этот элемент не рассматривали,
поэтому он остается меньше в этом массиве.
А этот элемент мы рассмотрели,
поэтому этот указатель может сдвинуть на один вправо.
Поэтому сравним теперь элемент два с элементом пять.
И наименьший из этих элементов вставляем вот сюда.
И продолжаем до тех пор,
пока, соответственно, у нас оба массива не опустеют.
Согласны?
После того, как мы перенеси все элементы в итоговый массив,
то мы заканчиваем работу.
Давайте заведем три указателя.
Три указателя я имею в виду три индекса.
Первый индекс iA,
второй индекс iB,
третий индекс iC.
Все они изначально указывают на ноль,
но индекс iA указывает на элемент,
который мы рассматриваем в первом массиве,
в массиве iA,
iB указывает на индекс, который мы указываем во втором массиве,
и C это то место, куда мы вставляем в массиве C.
Понятно?
Ну и давайте, собственно, что скажем?
Скажем, что пока индекс ИА не вышел за границы массива А
и индекс массива Б не вышел за границы массива В,
будем повторять следующее действие.
То есть что мы делаем?
Мы сравниваем эти элементы, которые указывают эти указатели.
Если это зависит от того, какой из них меньше, мы вставляем в массив С.
Так, давайте напишем так.
Если B массива B меньше, чем элемент ИА массива А,
то это означает, что нужно взять элемент массива B и перенести в С.
Мы пишем просто C и C равно B и B.
После этого делаем плюс-плюс и B.
Ну а иначе?
Ну да, плюс-с сделаем, но после L в конце сделаем плюс-плюс и С.
Ну, кстати, хорошее замечание.
В принципе, и С можно получить как сумму ИА и Б.
Ну, пусть так будет.
Не знаю, может сделать замечание, что и С всегда равен сумме ИА плюс ИБ.
Так, что мы делаем иначе?
Ну иначе мы берем не элемент Б, а элемент из А.
Согласны?
То есть берем С и С и вставляем туда значение А и А.
И продвигаем указатель А вперед.
Ну и в конце в любом случае мы продвигаем указатель ИС.
Вот код.
Как вам? Нормально?
Верно ли, что этот код всегда работает?
Да, давайте проведем вот эту процедуру до конца.
Вот с помощью этого алгоритма давайте разберемся с этим массивом.
Значит, мы сравнивали элемент 5 и 2.
Соответственно, продвигаем указатель B на единицу вперед.
Теперь сравним элемент 5 и 3.
Соответственно, 3 меньше, поэтому не удаляем, а в смысле берем 3 и вставляем 3 вот сюда.
Продвигаем указатель A.
Снова сравниваем два числа — 4 и 5, вставляем 4.
Дальше сравниваем 5 и 10, вставляем 5.
Продвигаем указатель.
Сравниваем 7 и 10, вставляем 7, продвигаем указатель.
Дальше, сравниваем 9 и 10, вставляем 9.
Все, на этом у меня массив А закончился и если у меня указатель вышел за границу массива,
то я прекращаю на этом работу.
Все, я прекратил работу.
Но это явно не то, что нам нужно, потому что у меня осталась в итоге еще десятка из второго массива.
Ну и теоретически у меня тут могли остаться еще какие-то элементы 11, 12, 13, ну и так далее.
И ни один из этих элементов я в итоге в этим алгоритме не добавил, согласны?
То есть что я должен еще сделать?
Да, то есть если вдруг у меня либо в этом массиве, либо в этом массиве остались какие-то элементы,
я должен их просто-напросто тупо добавить в конец.
Потому что у меня один массив закончился, это означает, что все оставшиеся элементы отсюда
должны просто-напросто стать конечного массива. Согласны?
Все. То есть давайте тут напишем while и a меньше, чем модуль a.
Я просто-напросто делаю c и c равно a и a.
Ну и продвигаю вперед и a, продвигаю вперед и c.
Ну и то же самое делаю с массивом b. Давайте тут напишу.
While и b меньше, чем модуль b.
Просто-напросто все оставшиеся элементы сгребаю в массив c.
c и c равно b и b, плюс-плюс и b, плюс-плюс и c. Все.
Нормально?
Есть вопросы по этому алгоритму?
Хорошо, давайте поговорим, за сколько он работает, время работы.
Сколько действий делает этот алгоритм?
Посмотрите, что мы по сути делаем на каждом шаге. На каждом шаге алгоритма мы либо
вставляем один элемент из b, либо вставляем один элемент из a.
Тут на одной интерации while мы добавили элементы b, либо из a.
И тут в этом цикле мы добавили элементы из a и з os 분� Role.
При этом по каждому элементу из a из b. Мы проходим все ровно один раз. Согласны?
Соответственно, суммарное количество шагов – это тета от размера массива A плюс размера массива B.
То есть два массива мы можем слить за время, пропорциональное сумме их размеров.
Если у меня есть два массива, суммарная длина которых родна n, то из них можно получить...
И при этом оба они отсортированы уже.
То, соответственно, один большой отсортированный массив мы можем получить за время тета от A плюс B.
Согласны?
Нормально?
Хорошо.
Полдела сделано.
Давайте теперь подумаем, как с помощью этого можно построить какой-нибудь эффективный алгоритм сортировки.
Следующий пункт.
Сортировка с лиянием.
Ну или merge sort.
Так.
Как устроен merge sort?
Смотрите.
По слову, задача сортировки какая?
Мне дан большой массив A, B, C, D, E, F, G, E.
Какие там есть элементы?
То есть дан один большой не отсортированный массив, мне нужно сделать из него один большой отсортированный.
Задача звучит гораздо больше.
Давайте попробуем настроиться на более оптимистичный лак.
Давайте я скажу, что у меня есть не один большой не отсортированный массив.
А я скажу, что у меня есть N отсортированных массивов.
Все, у меня не один большой не отсортированный.
А целых N отсортированных массивов размера 1.
Так.
Ну смотрите.
Ну что, если у меня есть отсортированные массивы, то, что я могу robić?
что я могу с ними сделать? Я могу их слить друг с другом, если у меня есть пара отсортированных массивов,
то я могу их слить друг с другом. Смотрите, кажется, у меня ровно такая ситуация. У меня есть
отсортированные массивы, соответственно, я могу их взять и просто послевать друг с другом.
Как я буду это делать? Давайте рассмотрим на примере. Допустим, дан массив, 7, 3, 5, 4, 1, 2, 6, 8, вот дан такой массив.
Значит, я из этого массива мысленно представляю, что это не один большой массив, а это вот 8 отсортированных
массивов. Что я сделаю? Давайте я буду смотреть элементы попарно, то есть 7, 3, 5, 4, 1, 2, 6, 8, и солью их в массивчике размера 2.
То есть возьму массив 7, возьму массив 3 и солью их в один отсортированный массив 3, 7. Получу массив 3, 7. Нормально?
Просто взял первый элемент, второй элемент, запустил процедуру merge от вот этого массива, а вот этого массива и
сохранил какой-то отдельный массив С. Дальше взял вот эти элементы и слил их в один массив 4, 5.
Взял эти элементы, слил их в массив 1, 2. Взял эти элементы, слил их в массив 6, 8.
После первого шага у меня получилось 4 массива размера 2, каждый из которых отсортирован. Согласны?
Что я делаю дальше? Давайте я продолжу процедуру. Буду продолжать сливать. Возьму эти два массива и солью в один размера 4.
Как я это делаю? Снова смотрю на первые элементы, минимальный из них это 3. Продвигаю этот указатель сюда.
Сравниваю 4 и 7, записываю 4. Сравниваю 5 и 7, вставляю 5. Соответственно, этот массив закончился,
и 7 просто дописываю в массив. Тут получается массив 1, 2, 6, 8. На последнем шаге я получаю два массива размера 4,
которые просто остаются слить друг с другом. Сливаю два массива. Получаю 1, 2, 3, 4, 5, 6, 7, 8.
На последнем шаге получил один отсортированный массив. Победа!
Алгоритм понятен, порядок действий понятен, да. Беру элементы по парам и сливаю друг с другом.
Снова беру элементы по парам и сливаю друг с другом.
Давайте подумаем. И соответственно, вот о каждом этом шаге я делаю мерч. То есть тут делаю мерч, тут делаю мерч, тут делаю мерч, тут, тут, тут и тут.
Так, главный вопрос, за сколько это работает? Давайте подумаем. На первом шаге я беру массивы размера единица, то есть беру n массивов размера 1, и попарно сливаю их друг с другом.
То есть сколько действий суммарно я сделал вот на этом уровне? «n». Почему? Потому что я сливаю два массива размера «1», это занимает… ну «тета от 1 плюс 1», то есть два, ну два действия.
Тут тоже я по сути делаю два действия, тут два действия, тут два действия, тут два действия, то есть суммарно я делаю количество действий, которое равно количеству элементов в массиве, согласны?
То есть это «тета от n». Тета от n действий. Что я делаю на этом уровне. Я беру массивы размера «2» и сливаю друг с другом.
размеры 2 сливаю друг с другом. Сколько времени я суммарно трачу?
Ну тоже тетто от n. Почему? Потому что я сливаю вот эти два массива, время равно там 2 плюс 2,
сливаю эти два массива, время равно 2 плюс 2. То есть суммарно по каждому элементу
массива исходного я пройдусь один раз.
Соответственно снова получают это от n.
Я здесь никого не удивлю, что и на этом шаге тоже у меня время равно тетто от n.
То есть на каждом шаге я буду делать тетто от n действий. Почему? Потому что слияние
по каждому элементу проходит ровно один раз. Согласны?
Есть понимание?
Так, ну теперь давайте рассмотрим в общем случае. Вот если в общем случае у меня количество элементов n.
Чему равно общее количество таких действий? То есть, окей, мы разобрались.
На каждом шаге я делаю n действий. А сколько всего таких шагов у меня будет?
Благодарю. Почему? Потому что давайте пойдем снизу вверх.
Вот здесь снизу у меня получился массив размера n. Выше у меня были массивы размера 4,
выше у меня были массивы размера решет two, выше были массивы размера один.
То есть, если мне есть массив размера n personalized, то разделение, сколько раз я его разделить на 2,
чтобы получить были массивы размера 1? Ну, логарифмическое число раз.
. Поэтому суммарное количество слоев у меня двоичный логарифм от n,
не больше, чем двоичный логарифм от n. Смотрите, на каждом уровне я делаю n действий.
уровень менял агарифом двоичный от n. Но кажется, что из этого следует, что сложность это тета от n-логан.
Согласны? Да? Вот, пожалуйста, сортировка, которая работает быстрее, чем за квадратичное время,
то есть массив размера миллион буквально за несколько миллисекунд отсортируется.
Так, давайте напишем код, что ли.
Merge Sort массива A.
Так, ну, давайте начнем.
4e от единицы до... давайте так напишем.
4e равно единице, e меньше чем n, e умножить равно 2.
Значит, что такое e? Умножить равно 2. А e это размер кусочков.
То есть тут изначально у меня кусочки размера 1, и на каждом шаге у меня размеры кусочков увеличиваются на 2. Согласны?
Ну и тут я итерируюсь по, собственно, числу кусочков.
4g равно 0, пока g у меня меньше чем n, g плюс равно 2.
Значит, g это начало первой последовательности.
Начало первой, сливаемой последовательности.
То есть g всегда указывает на начало первого сливаемого кусочка, окей?
Ну все, и дальше я просто-напросто... ну что я делаю?
Так, блин, я забыл, давайте вначале еще напишем, что я создаю массив c, который я буду складывать в временные значения.
Ну массив c это просто array размера n.
Ну нет, теоретически, если у меня массив не имеет цепи двойки, то у меня там в конце будут оставаться какие-то неспаренные куски.
Ну на самом деле с этим мы разберемся. Сейчас мы код напишем, и потом мы разберемся, что с этим делать.
Ну нет, тут у нас везде меньше чем n, поэтому кажется, что пока мы нигде не выходим за границу.
Умножить равно 2. Создали массив c, в который складываем временные значения.
Ну что, сливаем, пишем merge. Какой массив?
Merge-массив, начиная с j по j плюс i, не включительно, массивом j плюс i до...
И вот так. Максимум, точнее минимум, из n и j плюс 2i. Сливаю все в массив c.
Что-то написано. Написано, что я беру в качестве первого массива массив j-j плюс i.
J это начало левого кусочка. Соответственно этот кусочек имеет размер i.
Поэтому я беру массив, начиная с j этого по j плюс первый элемент, не включительно.
Я его сливаю с каким массивом? Я его сливаю с массивом, который начинается в позиции j.
Если это позиция j, то соответственно эта позиция это j плюс i.
Если это размер i, то соответственно это позиция j плюс i.
До каких пор? До минимума из j плюс 2i.
Потому что эта конец находится в позиции j плюс 2i.
Если это j, это i, это i, то соответственно конец находится j плюс 2i.
Но, как вы сказали, теоретически может случиться ситуация, при которой...
Вот тут у меня не 8 элементов, а 7.
Соответственно, чтобы не выходить за границы, я тут ставлю ограничение минимум n.
Нормально теперь?
Все, сливаю в массив C.
Ну и дальше давайте я напишу...
У меня были элементы, у меня элементы находились в массиве A, а в итоге оказались в массиве C.
Ну а мне-то нужно отсердцевать исходный массив A, согласны?
Давайте я просто возьму все элементы, которые оказались в C, и перенесу их в массив A.
Нормально?
Понятно?
Ну вот у меня был исходный массив A,
а я все элементы сложил в какой-то третий массив C.
В какой-то сторонний массив C.
Поэтому чтобы все элементы оказались в массиве A,
я должен обратно из массива C перенести все элементы в массив A.
Давайте я просто напишу...
Ну просто давайте напишу копии из массива C в массиве J плюс 2i.
Ну просто перенести все элементы, которые оказались в C,
на исходные позиции в массиве A, окей?
Понятно запись?
Все.
Ну кажется все. На этом сортировка заканчивается.
Есть ли вопросы по этому коду?
Да.
Ну да, тут тоже минимум.
От J до минимум из N, J плюс 2i.
Последний, смотри так, для чего нужна последняя строчка.
Вот у меня был массив A.
Вот, допустим.
И я хочу слить вот этот кусочек с вот этим кусочком.
Ага. Как происходит слияние?
Я создаю массив C, вот это массив исходный A,
я создаю массив C и все сливаю вот сюда.
То есть на самом деле отсортированно у меня оказывается массив C.
Но мне-то нужно, чтобы все эти элементы были отсортированы в массиве A.
Поэтому после того, как я все слил в массив C,
я переношу все значения обратно в массив A.
Ну это не средство, это просто условное обозначение в псевдокоде.
Вот, что мне нужно все перенести в массив A от J до...
Ну давайте напишем, если это смущает.
Давайте прям честный цикл напишем.
For k равно 0, пока k меньше, чем...
Нет, давайте так.
k равно J, k меньше, чем минимум из J, плюс 2i и n, плюс плюс k.
Что я делаю? Я переношу все элементы из массива C в массив A.
Я пишу ak равно C от k-J.
Так нормально?
Ну потому что у меня...
Смотрите, когда я сливаю вот эти два кусочка,
у меня в массиве A этот элемент находится на какой-то жидкой позиции.
То есть J это как раз номер элемента,
начиная с которого мне нужно слить вот эти два элемента.
То есть по сути у меня массив A устроен так.
3, 7, 4, 5, 1, 2, 6, 8.
Мне нужно, чтобы в этих позициях оказался массив 1, 2, 6, 8.
Поэтому я все переношу туда. Понятно?
Нормально?
Сдайте вопрос, есть непонятно.
Давайте пример.
Есть массив A.
5, 3, 7, 8, 1, 2, 4, 3.
Как работает алгоритм?
Вначале я возвожу какой-то вспомогатель массив C,
в который буду складывать промежуточные результаты.
1, 2, 3, 4, 5, 6, 7, 8.
Так, что я делаю?
Внешний цикл у меня задает размер блоков, которые я сливаю.
Согласны?
Стартую с блоков размера 1.
Сливаю вот этот блок с вот этим блоком.
То есть позиция первого блока равна J равная нулю.
И я сливаю блоки с нулевого по 0 плюс 1,
с нулевого по первой невключительно,
и с первого по второй невключительно.
То есть я беру вот эти элементы и сливаю их друг с другом.
Куда сливаю?
Сливаю в массив C.
Тут оказывается элемент 3, тут оказывается элемент 5.
Все, после того как я их слил сюда, мне нужно чтобы вот тут,
чтобы вот эти 3,5 оказались не тут, а тут.
Согласны?
Поэтому последний цикл, 4k равно J, k меньше минимум, и так далее,
я просто эти элементы копирую обратно вот сюда.
3, 5.
Перехожу на следующую итерацию цикла по J.
Следующий J у меня 0 плюс равно 2i.
Ну i равно 1, поэтому я сдвигаюсь на двойку,
то есть оказываюсь вот здесь.
То есть сливаю теперь вот эти два массива.
Согласны?
Вот, сливаю два массива, у меня получается, то есть я их записываю сюда.
Тут получается 7, тут 8.
Теперь эти элементы я должен перенести сюда.
Ну, семерку переношу сюда, восьмерку переношу сюда.
Рассматриваю следующие блоки по единице.
1, 4.
Сливаю вот сюда.
Тут у меня получается единица, тут получается четверка.
Все, сливаю сюда, единица, четверка.
Ну, то же самое с этими элементами, 2, 3.
Сюда записываю 2, сюда записываю 3.
Все, это после первой итерации по внешнему циклу, по i.
Перехожу на следующую итерацию.
На следующую итерацию у меня i умножить равно 2.
То есть i становится равно 2.
Чему соответствует i?
i это размер кусочков.
Кусочки размера 2.
Вот этот кусочек, вот этот кусочек, вот этот и вот этот.
Ну как, ну смотрите, давайте рассмотрим конкретный пример.
Пусть у меня j равно 4.
А i равно 2.
j равно 4, это вот этот элемент.
Значит, что мне нужно сделать?
Мне нужно все элементы, мне нужно вставить элементы вот с этой позиции
по минимуму j плюс 2i до n.
То есть j плюс 2i это восьмой элемент, то есть вот этот.
То есть мне нужно вставить элементы сюда,
начиная с этого по этот, не включительно.
Понятно?
В этот момент, то есть когда я сливал вот эти два кусочка,
когда я сливал вот эти два кусочка, у меня в массиве c
записана следующая информация.
1, 2, 3, 4.
Но я хочу, чтобы у меня вот эти 1, 2, 3, 4 были вот тут,
а не в каком-то массиве c.
Поэтому я иду по циклу.
k начинается с j.
Давайте тут буду писать k.
k равняется 4.
Так, значит, в массив a, в k это элемент массива a,
то есть вот в этот, я записываю элемент k минус j.
k равно 4, j равно 4.
То есть я записываю 0,8.
Вот сюда.
Первый элемент c я записываю вот сюда.
Этот элемент c я записываю вот сюда.
То есть по сути я последовательно записываю элементы массива c вот сюда,
но просто-напросто со сдвигом в j.
Ой, да, со сдвигом в j.
Вот это расстояние j.
Уже, если j равной 0, то guarantee meter при 0, то k меньше 0.
А threats...
🎶
Ну то же самое.
Ну j это просто смещение относительно начала.
Если j равно 0, то кажется что k минус 0, это...
Это кажется нет. А в чем проблема может быть?
Как только мы сделаем g плюс 2i и у нас g станет равен n, то мы выйдем из цикла.
Это псевдокод. В C++ срезов нет.
То, что первый блок влезает, в каком плане, куда влезает?
Смотрите, первый блок... Вы про это?
Ну да, это имеет смысл.
На самом деле нам нужно сливать блоки.
Сейчас кажется, у нас первый блок.
А, первый блок не в любом случае влезает, да?
А, ну тогда, все, я понял.
Тут можно взять g меньше, чем n-i. Кажется, это сработает.
Ну понятно, в чем проблема?
Я не знаю, давайте изобразим.
Что у меня массив имеет длину, допустим, 10, я беру блоки размера 4, 4 и тут остается 2.
В итоге эти два блока я солью, а первый блок у меня будет иметь размер 2, который меньше, чем 4.
И, соответственно, вот тут я выйду за границу массива.
Я просто-напросто пожил, буду идти до n-i и все.
Тогда последний блок я не захвачу.
Первое, что мы сказали, это то, что сортировка слиянием работает за n луган.
Вроде как обосновали, все нормально.
Какими дополнительными приятными и неприятными свойствами обладает сортировка слиянием?
Хорошим свойством является то, что сортировка слиянием стабильна.
Что значит стабильная? Это не что-то скрепное, это понятие из теории алгоритмов.
Софтировка является стабильной, если она сохраняет порядок одинаковых элементов.
Сейчас поясню, что это значит.
Представьте себе, что мне дан массив...
Давайте маленький массив нарисую.
Массив 3, 1 штрих, 2, 1, 2 штриха.
То есть, допустим, у меня в массиве есть две единицы,
и они по каким-то причинам отличаются друг от друга.
В смысле, эта единица, эта единица, они разные.
Представим себе следующую ситуацию.
Я взял сортировку и получил вот такой массив.
1, 2 штриха, 1, 1 штрих, 2, 3.
Данное упорядочение, данная сортировка не является стабильной. Почему?
Потому что, несмотря на то, что тут вроде бы как все хорошо,
сначала идет 1, 1, потом 2, 3, относительный порядок вот этих двух единиц, он поменялся.
Изначально у меня шло значение 1 штрих, потом идет значение 1, 2 штриха.
А в конечном массиве это не так.
То есть данная сортировка поменяла порядок, относительный порядок одинаковых элементов.
Поэтому она не является стабильной.
Давайте подумаем над тем, почему, вообще говоря, стабильная сортировка,
почему на самом деле иногда нам могут понадобиться стабильные сортировки.
Можете привести какой-нибудь пример.
Ну, какой-нибудь из жизни.
Открывать счета папин-кодом.
Ну, например.
Или представьте себе, у вас есть таблица.
Там, не знаю, Excel или еще какая-то.
В которой у вас есть, не знаю, условно там FIO.
И там, не знаю, какая-нибудь зарплата.
Вот.
И у вас, допустим, список отсортирован по возрастанию фамилий.
А теперь вам нужно, допустим, отсортировать список по зарплатам.
И correspondingly, там, поймете, какой там наибольший зарплат,
какой он наименее сейчас зарплат, и так далее.
Вот, допустим, вы отсортировали список по зарплатам.
Вот. И отсортировали его каким-то случайным образом.
Так что, понятное дело, у вас зарплаты перемешались.
Поэтому соответственно, и фамилия имена отчество тоже,
эти строчки соответственно поменяли с друг к другом.
Но, если сортировка является стабильной,
то какое свойство у нас еще гарантируется?
Что если вдруг у кого-то есть одинаковая зарплата,
то в рамках вот этого списка они будут отсортированы по фамилии имени отчества, понятно?
То есть если у меня вот тут один штрих и один-два штриха были между собой отсортированы по какому-то другому критерию,
то и в конечном оси они тоже будут отсортированы по тому же самому критерию, понятно?
То есть я на самом деле могу отсортировать не просто отдельные числа,
допустим, я могу отсортировать пары число и какая-то строка.
И допустим, мой список уже отсортирован по строкам, и я хочу его теперь отсортировать по числам.
Если я его отсортировал по числам, то теперь одинаковые числа, то есть внутри вот этих блоков,
у меня числа будут дополнительно отсортированы по их строкам, понятно, да?
То есть часто это довольно-таки приятное свойство, то есть стабильное, давайте формально напишем.
Если ai равно aj и i меньше, чем j в исходном массиве,
то их соответствующий индекс, давайте их обозначим как pe и pj,
то и соотносятся таким образом.
pe – это индекс этого элемента в отсортированном массиве, окей?
Сортировка с лиянием стабильная, и на самом деле еще в плюс можно записать,
что сортировка с лиянием всегда работает за n-логан.
То есть какой бы у вас массив на вход не был передан, всегда в любом случае,
хоть в худшем, хоть в лучшем, у вас сортировка будет работать за n-логан.
Так, кто видит недостаток сортировки с лиянием?
Какая у него есть проблема?
В отличие, например, давайте, смотрите, у нас есть квадратичные сортировки,
ну, не знаю, возьмем какую-нибудь сортировку выбором, или сортировку вставками, неважно.
Все они, понятное дело, работают за n-квадрат.
Но у них есть одно неоспоримое преимущество внезапно,
перед сортировкой с лиянием. Какое?
Они не создают дополнительных массивов.
То есть, грубо говоря, вы квадратичной сортировке передали массив,
и квадратичная сортировка работает только с этим массивом,
не создает никакой дополнительной памяти.
Здесь же нам нужно создавать некоторый дополнительный массив,
который мы будем записывать в промежуточный результат.
Согласны?
И, к сожалению, это, собственно, недостаток сортировки с лиянием.
То есть требует theta от n до памяти.
Вот, это неприятный факт.
Чтобы отсортировать массив, вы можете потратить немного времени,
плюс вам нужно гарантировать, что у вас на системе еще хватает памяти
для, по сути, такого же дополнительного массива.
Понятно?
В принципе, есть еще полчаса.
Давайте поговорим вот о чем.
Давайте поговорим о небольшой модификации сортировки с лиянием.
И попробуем придумать такой алгоритм, который бы не требовал дополнительной памяти.
Давайте попробуем модернизировать сортировку с лиянием так,
чтобы дополнительной памяти он не требовал.
Вопрос следующий.
В какой момент нам нужна дополнительная память?
Дополнительная память нам нужна в процессе слияния.
Чтобы уметь сливать, нам нужно данные элементы записывать в какой-то третий массив.
Давайте попробуем придумать слияние, которое этим недостатком не обладает.
Которое позволяет сливать элементы и не требует дополнительного хранилища данных.
Что я хочу написать?
Это процедура, которая называется in-place merge.
Какое ограничение у меня будет на in-place merge?
In-place merge обязательно будет требовать следующего.
Что сливаемые последовательности расположены строго друг за другом.
То есть сливаемые последовательности лежат в одном массиве
и плюс расположены последовательно друг за другом.
То есть A и B находятся в точности друг за другом.
Давайте начнем с чего. Давайте рассмотрим какие-нибудь простые случаи.
Какие два массива нам легко слить друг с другом?
Понятно дело, что эти два массива априори отсортированы уже.
У вас этот массив имеет размер 10, а этот массив имеет размер 8.
Как их слить друг с другом?
Это простой вариант. Давайте рассмотрим такую ситуацию.
В этом массиве не понятно, что находится, в этом тоже не понятно.
Чему должны удовлетворять размеры массивов, чтобы их можно было легко слить друг с другом?
Например, массивы 1 и 1 слить друг с другом легко.
Допустим, у меня один массив имеет размер 100.
Чему должен быть размер второго массива, чтобы их можно было легко слить друг с другом?
Ноль.
Если размер массива A равен нулю,
то мы сразу можем завершить работу, согласны?
Не массивы, а последовательности идут друг за другом.
Вот у вас есть память, и по сути эти два куска принадлежат одному и тому же массиву.
То есть сначала записанные элементы A, потом сразу же записаны элементы B.
Аналогично, если B равен нулю, равно равно,
то тоже можем завершить работу.
Ну и третий вариант простой.
Если размер первого массива равен единице,
и размер второго массива равен единице,
то что нам нужно сделать?
Ну да, то есть можно записать, что если элемент B0...
Так, давай допишем.
Элемент B0 больше, чем элемент A0,
так наоборот, A0 больше, чем элемент B0,
то мы делаем swap, элемент A0, элемент B0.
Простые случаи рассмотрели? Согласны?
Так, теперь давайте недолго отвечу.
Я сделал утверждение, что сортировка с лиянием стабильная,
но не доказал же, почему она стабильная.
А вы поверили?
Уже на семинаре?
Ну ладно, почему сортировка с лиянием стабильная?
Ну, смотрите.
Что делать с сортировкой с лиянием?
С сортировкой с лиянием на каждом шаге просто-напросто сливают какие-то массивы.
Поэтому, соответственно, если я сливаю два массива стабильным образом,
то соответственно и сортировка с лиянием тоже будет стабильной.
Смотрите, допустим, у меня тут в какой-то момент получилось так, что есть
массив A, массив B, и я указываю на одинаковый элемент.
Тут элемент X, тут элемент X.
Что мне нужно сделать, чтобы гарантировать стабильность?
Да, мне нужно брать элемент X не из B, а из A.
Потому что если возьму элемент из B, то он будет стоять в исход в конечном массиве
гораздо меньше, чем элемент X из A, согласны?
Давайте посмотрим, гарантируется это здесь или нет.
Если у меня элемент из A совпадает с элементом массива из B,
то по какой ветке я иду? По ветке if или по ветке else?
По ветке else, потому что тут в эту ветку я захожу только в случае,
если у меня B и B меньше, чем A и A, а сюда я иду в случае,
если у меня элемент из массива A меньше либо равен, чем элемент из массива B.
Поэтому в случае равенства двух элементов я обязательно возьму элемент из массива A.
Я гарантировал, что у меня сортировка будет стабильной. Понятно?
То есть элементы из левого массива, то есть те элементы, которые идут раньше,
я записываю в конечный массив раньше, чем те элементы, которые идут правее. Согласны?
Нормально? Окей.
Теперь давайте вернемся в in-play-смерт. Напоминаю, в чем задача.
Нам дано две последовательности, про которые сказано,
что они идут друг за другом в ком-то массиве, и плюс они обе отсортированы.
Мне нужно из них сделать один большой отсортированный массив,
при этом не используя никакой дополнительной памяти.
Смотрите, я указываю на элемент X, тут указываю на элемент Y.
Вот два указателя. Какие ситуации возможны?
Возможна ситуация, что X меньше, чем Y, тогда я добавляю X. Нормально.
Возможна ситуация, при которой Y меньше, чем X, тогда я добавляю Y.
Возможна ситуация, когда у меня два элемента равны друг другу.
Что происходит, когда два элемента равны друг другу?
Я беру элементы из массива A.
Вот, встретили.
Так, ну смотрите. Почему мы закинули?
Почему мы закинули X?
Почему мы закинули Y?
Почему мы закинули Y?
Почему мы закинули Y?
Почему мы закинули Y?
Почему мы закинули Y?
Почему мы закинули Y?
Почему мы закинули Y?
Почему мы закинули Y?
Почему мы закинули Y?
Так, ну, смотрите.
Почему мы закинули элемент X?
Почему мы закинули элемент Икс?
Почему мы закинули элемент X?
Почему мы закинули элемент Икс?
Мы закинули элемент Икс, потому что икс меньше, чем Y.
То есть в какой момент мы закидываем элемент Икс из B?
Только в том случае, если он меньше, чем элемент из массива А.
Но если он меньше, чем Y,
то тут Иксы точно идти не могут.
Поэтому такой ситуации просто быть не может.
Есть вопросы?
Тут какие ситуации рассмотрели?
Рассмотрели ситуации, при которой у меня массив A пустой,
массив B пустой, и ситуации, при которой у меня оба массива имеют длину единица.
Давайте сделаем следующее.
Пусть размер массива A меньше, чем размер массива B.
Давайте я возьму элемент X, который стоит в середине массива A.
Как это выглядит на картинке?
Есть массив A, есть массив B.
Я взял элемент X, который стоит по центру.
Давайте наоборот.
Массив A больше, чем массив B.
Я взял элемент X, который стоит по центру.
Отсюда следует, что число элементов больше равно, чем n на 4,
и тут элементов больше равно, чем n на 4.
Согласны?
Если A больше из двух частей, то тут хотя бы n на 4 элементов,
и тут хотя бы n на 4 элементов.
Согласны?
Теперь, что я сделаю?
Давайте я в массиве B найду элемент, который равен lower bound at X.
Что такое lower bound at X?
Давайте лучше g обозначу.
Lower bound в массиве A от X.
Это индекс первого элемента в массиве A,
который больше либо равен, чем X.
То есть я нашел первый элемент, который больше либо равен, чем X.
Тут у меня все элементы, которые больше либо равны X.
Тут у меня все элементы меньше X.
Понятно?
В массиве B давайте lower bound BX.
Окей.
Какая у нас ситуация сейчас получается?
Сейчас у нас получается следующая ситуация.
Вот в этой части массива все элементы больше либо равны, чем X.
В этой части массива все элементы больше либо равны, чем X.
Здесь все элементы меньше X, а тут все элементы больше либо равны X.
Согласны?
Что будем делать дальше?
Тут элементы строго меньше X.
Почему?
Потому что этот элемент это первый элемент в массиве, который больше либо равен, чем X.
Если этот элемент равен X, то это первый такой элемент, который равен X.
Поэтому тут все элементы меньше, чем X.
Сейчас мы очень много задач параллельно разберем.
Смотрите, чего я хочу сейчас сделать.
Следующий план такой.
Вот у меня кусочек больше либо равны X, есть кусочек меньше X.
Согласны ли вы, что именно вот эти кусочки идут не в том порядке?
Но вообще было бы неплохо, если бы вот этот кусочек был здесь, а вот этот кусочек был бы здесь.
Согласны?
Вот.
То есть я хочу взять вот эти куски.
Давайте я обозначу вот этот кусок A', вот этот кусок A'', вот этот кусок B', вот этот кусок B''.
Согласны ли вы, что жизнь была бы лучше,
если бы A', A' и B' поменялись местами?
Так.
То есть стоит перед нами следующая задача.
Сейчас разберем классическую задачу салогермических собеседований.
Значит, смотрите, есть два массива.
Точнее, есть один массив, который как-то разделен на две части.
Ну, условно часть A и часть B.
Что я хочу сделать?
Я хочу применить так называемую операцию rotate.
Просто-напросто поменять кусок B с куском A местами.
То есть я хочу, чтобы вначале шел кусок B, а потом шел кусок A.
Вопрос, как это можно сделать?
У меня возникла задача.
Я хочу, чтобы кусок B' стоял до куска A''.
То есть я хочу эти два куска поменять местами друг другом.
Понятное дело, что вот эти куски теоретически могут быть разных размеров.
Иначе было бы все слишком просто.
В этом случае индекс первого элемента будет просто-напросто не существующим.
То есть первый элемент находится за массивом.
Тогда B' равен массиву B, а B' это пустой массив.
Как будем решать эту задачу?
Да, конечно, без дополнительной памяти.
У меня есть, допустим, массив 1, 2, 3, 4, 5, 6, 7.
Я, допустим, беру кусок вот такой и кусок вот такой.
И хочу сделать так, чтобы у меня был массив 4, 5, 6, 7, 1, 2, 3.
Еще раз, с конца.
Так, подсказка.
Эта задача сложная, я понял.
А как их выровнять?
То есть если у меня число элементов нечетное, то их как не выровню?
Ну, кажется, так не получится, но давайте придем к кому-нибудь более простому решению,
которое не требует условно выворота мозга.
А если куски разных размеров?
Ну нет, нет, нет, если у вас куски разных размеров,
тогда у вас, смотрите, если у вас
куск A сильно меньше, чем куск B,
то у вас тут должно быть наоборот.
Вот это большой кусок, а вот эти элементы должны вот тут стоять.
Вот, развернуть хорошие идеи.
Давайте рассмотрим более простую задачу.
Задачу reverse.
Есть массив A?
Какой это массив A?
Нужно его развернуть в обратном порядке.
Ну какую задачу решать, я думаю, вы понимаете.
Ну просто-напросто идем с первого элемента по пополамтоэлемент
и обмениваем там первый элемент с последним,
второй элемент с предпоследним, ну и так далее.
Нормально, да?
Ну эта задача простая.
Но вот я утверждаю, что первая задача такая же простая, как и reverse.
Что на самом деле rotate
можно сделать с помощью
трех reverse.
Ну как, как это можно сделать?
Во, да.
Смотрите.
Rotate
вот AB.
Давайте я сначала возьму
и сделаю
reverse
всего массива AB.
Это первый шаг.
Что я в итоге получу?
Согласны ли вы, что я сначала получу перевернутый массив B,
а потом перевернутый массив A?
Согласны?
Так.
Следующим шагом.
Давайте я сделаю reverse
от A штрих,
ну дальше от B штрих.
То есть я возьму вот этот кусок
и разверну его.
Что я в итоге получу?
В итоге я получу кусок B
и A штрих.
Ну и наконец третьим пунктом
я сделаю reverse от A штрих.
В итоге получу
B
и A.
Перешел от такой, от такого массива
к вот такому массиву.
Вопросы?
Ну, reverse работает за линейное время,
reverse работает за линейное время, за линейное время.
Кажется, я за линейное время смог обменять два куска местами.
То есть по сути такой свап для массивов,
которые идут последовательно друг за другом.
Правильно?
Так.
Ну, кажется, решили под задачку здесь.
То есть, ну давайте я тут
определю кусочки
следующим образом.
Значит, кусочек A штрих
это будет кусочек A
от нулевого до
позиции
X невключительно.
Ну и X я обозначил позицию X.
Ну позиции, ладно, позицию X
у меня понятна, это N пополам.
Ой, N на 4.
Модуль A делить на 2.
А 2 штриха, вот этот кусочек,
это массив A
начиная с позиции
A пополам
ну и до
A невключительно.
Так.
Кусочек B штрих
это у меня массив B
начиная с нуля
и до
где?
До G невключительно.
G это lower bound от X, да, помните?
Ну и B2 штриха
это у меня
массив B, ну давайте так
напишу G-то и по последней.
Ну все, то есть по сути
просто написал определение кусочков
A2 штрих, A2 штриха, B штрих, B2 штриха.
Окей?
Так, давайте перейду на
вот эту доску.
Так, следующим шагом, как я сказал
просто поменяю местами кусочек B
штрих и кусочек A штрих. То есть применю как раз
вот эту процедуру rotate.
Запишу rotate
A2 штриха
и B штрих.
Так, что я в итоге получу?
Да, в итоге я получу 4 отсортированные
последовательности.
Тут элементы все больше,
так, меньше XA
это кусочек B штрих.
Тут все элементы больше равны XA
это кусочек A2 штриха.
Так.
Подведем промежуточный итог.
Что я сделал?
У меня был исходно
вот такой массив,
который состоял из двух отсортированных.
Теперь я получил 4 отсортированных кусочка,
но зато слева у меня все элементы
меньше либо равны X, а справа все элементы
больше либо равны X. Окей?
То есть по сути я
что-то хорошее да сделал,
то есть я все маленькие элементы
перенес отсюда сюда, все большие элементы
окей.
Давайте еще о чем поговорим.
Верно ли, что на текущий момент
моя процедура является
стабильной, в том смысле, что она
сохраняет относительный порядок равных элементов?
Почему?
Смотрите, это действительно так, почему?
Потому что единственная проблема,
которая может возникнуть,
допустим, у меня есть элементы тут,
ну смотрите,
какие элементы у меня
могут быть равны вот здесь и здесь?
В кусочке h' и h',
какие у меня будут совпадающие элементы?
Только иксы, да?
Ну смотрите, в исходном массиве
у меня вот эти иксы шли
после вот этих иксов, и в полученном массиве
эти иксы тоже идут после этих иксов, согласны?
Все хорошо.
Так, теперь давайте посмотрим
вот здесь, ничего ли я не
нарушил я стабильность вот этого куска
с вот этим куском? Ну нет, тут у меня
все элементы меньше иксов, а тут больше иксов,
а тут вообще априори не может быть равных элементов, согласны?
Ну и тут
если тут были какие-то равные элементы
с вот этими элементами, то этот кусок
как шел позже всех, так и идет позже всех.
Все, кажется, что никакие элементы равные не поменяли
относительный порядок.
Согласны?
Так.
Да.
Ну блин, смотрите, давайте вот эту запись
считать просто как
псевдокод, как просто некоторые математическая
абстракция. То есть просто мысленно считаем,
что h' это вот этот кусок, b' это
вот этот кусок, h' вот этот кусок и так далее.
Да-да-да-да.
Да, это просто мысленная абстракция, тут
никаких выделений массива на самом деле не происходит.
Вот.
Получили вот такую ситуацию.
А теперь сделаем
страшное.
Смотрите.
Вот, смотрите, вот эта часть
и вот эта часть, они вроде как
относительно друг другу уже отсортированы, с ними все хорошо.
Смотрите, согласитесь ли вы,
что если я солью вот эти части друг с другом
и вот эти части друг с другом, то я получу
полностью отсортированный массив.
То есть вот это кусок отсортирован, это кусок отсортирован
Я их солью друг с другом,
получу отсортированный массив. Тут тоже эти
солью друг с другом, получу отсортированный массив, ну, в итоге
два этих отсортированных массива дадут мне один большой отсортированный
массив.
Делаю страшную вещь.
Пишу in place merge
от
h'
Inplace merge. Вот a2, b2, k. Все.
Да-да-да, то есть i и b можно считать, что это указатели на первые элементы части a и части b.
Какую страшную вещь мы сделали? Мы свели исходную задачу к двум задачкам меньше. Согласны?
То, что мы сейчас сделали, называется рекурсия. Формально рекурсию мы с вами будем проходить на следующем занятии, но в целом идея понятна.
Если у нас есть какая-то большая задача, которую сложно решать, мы ее можем разбить на несколько других подзадач, которые тоже сложно решать, но они хотя бы имеют меньший размер. Понятно?
Давайте попробуем это все проанализировать с точки зрения времени работы. Давайте попробуем математически доказать, что на самом деле тут все будет хорошо.
Докажем по индукции. База индукции какая? База индукции, что у меня массив a равен нулю или массив b равен нулю.
Или массив a равен единице и массив b, то есть размер массива b равен единице. Согласны ли вы, что в этом случае все хорошо?
Но эти все случаи тривиальные, поэтому база индукции доказана. Допустим, пусть in-place merge умеет работать на массивах суммарной длины меньше, чем n.
Предположение индукции. Для базы индукции это верно. Если сумма кусочков у меня равна нулю или кусочки маленькие, то я умею все делать.
Теперь давайте предположим, что in-place merge умеет работать для произвольных массивов, суммарной длины которых не происходит n.
Давайте докажу, что тогда у меня все работает и для in-place merge для массивов, суммарной длины которых равна n. Как я это делаю?
Я запускаю in-place merge, перепорядочиваю все вот таким вот образом, и запускаю in-place merge от а3 к а3 и а2 к а2 к а3.
Согласны ли вы, что суммарная длина этих кусочков меньше, чем n и суммарная длина этих кусочков меньше, чем n?
Согласны? Все, окажется, что я победил. То есть все элементы меньше равны x, тут все элементы больше равны x.
По предположению индукции вот это in-place merge сделает красиво все, это in-place merge тоже сделает красиво, в итоге у меня получится один большой отсортированный массив.
Доказательство закончено. Понятно? Нормально?
Да, смотрите, в предположении индукции, допустим in-place merge умеет сливать два массива, суммарные длины которых меньше, чем n.
Допустим, мне на вход подается массив размера n. Что делает in-place merge?
In-place merge, как я описал, вот тут и вот тут, в rotate, перепорядочит массив так, что в начале идут все элементы меньше равны x,
то есть тут меньше равны x, тут меньше x, тут больше равны x, тут больше равны x. Согласны?
И я дальше запускаю in-place merge от вот этих кусков и от вот этих кусков.
Согласны ли вы, что если суммарное количество элементов у меня было n, то после выполнения этих операций вот тут у меня будет число элементов меньше, чем n, и тут точно меньше, чем n. Согласны?
Подождите, я пока не оцениваю время работы. Я доказываю, что это работает.
Я сделал предположение, что in-place merge имеет работать с массивами, суммарные которых меньше, чем n. Тут число элементов меньше, чем n, тут число элементов меньше, чем n,
поэтому я могу воспользоваться предположением индукции и сказать, что тут все будет хорошо, тут все будет хорошо. Согласны?
Все. А раз тут и тут все будет хорошо, то тут у меня будет отсортированный массив, в котором все элементы меньше равны x, а тут будет отсортированный массив, в котором все элементы больше равны x.
Но кажется, что в итоге я получу один большой отсортированный массив. Все, я доказал переход. Соответственно, in-place merge действительно делает то, что нам нужно. Согласны?
Теперь, если успеем, давайте поговорим, точнее запедраним время работы.
Вот сейчас нам это пригодится. Как раз-таки во время работы мы это учтем.
Так, смотрите. Изначально я запускаю in-place merge от a и b. Сумма длин a и b, допустим, равна n.
Давайте я посмотрю, за сколько времени он отработает in-place merge, когда у меня размер входа равен n. К чему сводится у меня in-place merge?
Ну, in-place merge у меня работает, сам по себе работает, за theta от n. Да, ну почему? Потому что время тратится на эти, ну там lower bound, понятное дело, я могу с помощью бинарного поиска найти.
То есть основное время тратится на дет ротейт, дурацкий. Понятно? Согласны, что ротейт займет максимум, давайте o напишем, o большое от n времени.
Вот. И плюс я вызовусь от in-place merge от a-b- и in-place merge от a-2-b-.
Так, теперь давайте поймем, какой размер вот этой задачи и какой размер вот этой задачи. И вот как раз воспользуемся тем, что массив a больше, чем массив b.
Смотрите, у меня вот отсюда следует, что размер h' больше равен, чем n на 4, и размер a2' тоже больше равен, чем n на 4. Согласны?
Ну раз большой, раз кусок a изначально, вот этот кусок a был большим среди этих двух кусков, поэтому тут хотя бы n половым элементов.
А так я его распилил половым, и в том, и в той части, как минимум n на 4 элементов. Согласны?
Так, но если тут хотя бы n на 4 элементов, то это значит, что вот тут суммарно хотя бы n на 4 элементов, и тут суммарно хотя бы n на 4 элементов.
Понятно? Но если тут хотя бы n на 4 элементов, то тут никак не больше 3n на 4 элементов. Согласны?
А растут больше n на 4 элементов, то тут никак не больше 3n на 4 элементов. Все, вот это нафиг. Вот, вот что мне нужно.
То есть я свел исходную задачу к двум задачам, которые меньше по размеру, причем меньше по размеру в 4 третьих раза.
Вот. Так, теперь что я делаю?
Каждый из этих in-place merge. Сколько времени занимает?
Ну, короче говоря, я могу записать рекуррентное соотношение.
Давайте так, что t от n равно t от 3n на 4 умножить на 2.
Рекуррентное соотношение решали?
Упражнение. Ну, это простое рекуррентное соотношение. Упражнение.
Показать, что t от n есть o большое от n lug n.
Ну, это все уходит в ошку, в o большое.
Смотрите, мы на lower bound тратим, действительно, логарифом.
Но на rotate мы тратим линейное время. Кажется, это больше, чем логарифом.
Поэтому на lower bound можем просто на o забить.
Все, то есть время работы in-place merge удовлетворяет вот такому соотношению.
Ну, давайте так, тут межки в равно можно писать, межки в равно, межки в равно.
Это какое-то линейное количество операций.
Это какое-то линейное количество операций.
Плюс дважды t от 3 на 4.
Но кажется, что если мы построим дерево рекурсии,
ну, например, с помощью дерева рекурсии,
или там с помощью метода угадывания.
Кстати, мы проходили метод угадывания, вот это вот все.
То можно прийти к решению n lug.
То есть главная суть заключается, еще раз, давайте повторю главную суть.
Массив A, по предположению, больше, чем массив B.
Поэтому в нем хотя бы n пополам элементов.
Отсюда следует, что в массиве a' и a' хотя бы n на 4 элементов.
Значит, вот тут суммарно хотя бы n на 4 элементов,
и тут хотя бы n на 4 элементов.
Раз тут хотя бы n на 4 элементов, то тут никак не больше 3n на 4 элемента.
Все, то есть я свел задачу по 100% меньше под задачу,
причем в несколько раз, поэтому в 4 третьих раз.
Всё. Это упражнение 1. Упражнение 2. Что делать, если на самом деле массив b больше, чем массив a?
Ну, смотрите, мы предположили, что у нас массив a, то есть эта часть больше, чем массив b.
Но такое же, в принципе, не всегда выполняется. Теоретически у неё массив b может быть больше, чем массив a.
Ну, смотрите, первый вариант окей, согласен. Можно просто сделать ротейт и поменять массивы b, массивы а. Хуже не станет.
А подумайте, как это можно сделать без ротейт. Вот как сделать то же самое, но только вот в обратной ситуации.
То есть на самом деле код будет абсолютно такой же. То есть тоже ищем центральный элемент b, затем ищем какой-то элемент va.
Вот, кстати, вопрос, какой элемент va нужно искать. В общем, небольшое упражнение на подумать.
Ну, в целом идея ротейт зачёт.
Так, на сегодня всё. Всем спасибо.
