и так значит мы в прошлый раз не до разобрались с деревом фенрика давайте сейчас мы обсудим
дерево фенрика деревья фенрика деревьев
значит задача будет у нас такая есть на плоскости много точек n точек
n точек координаты которых ну скажем там целые от 0 до 10 к 9 от 0 до 10 к 9 и по х и по
экрику причем эти точки откуда-то заранее известны они фиксированы и сами точки не
меняются меняется только числа которые в них написан значит в каждой точке написано под
число там 1 2 3 4 и так далее и могут меняться только эти числа соответственно запрос у нас есть
двух типов первый запрос это изменение а этого то есть по какой-то точке по этой точке нужно
поменять то число которое в ней написано и второе это нужно найти сумму аитох в прямоугольнике
прямоугольник значит вам задается вот такой прямоугольник то есть вам фиксируется какой-то
правый верхний угол его координатами там не знаю ну не знаю x и y x и y вот вам нужно смотреть все
что находится левее и ниже то есть вот какой-то прямоугольник и сложить ну вывести сумму всех
ашек по всем точкам которые попадают в это прямоугольник это вот задача из контеста давайте
обсудим как вы решать значит давайте по запросу изменения в точке сумма на прямоугольник мы сразу
скажем что какой-нибудь обычный двумерный фенвик как мы в прошлый раз делали будет работать слишком
долго но как минимум потому что у вас тут там координаты 10 9 10 9 и фенвика строй там ну мы не
можем построить массив 10 9 на 10 9 и даже если там сжать координаты считать что все координаты там
до до n до 10 5 примерно то все равно будет слишком много мы не можем завести массив размера n
это нужно что-то другое начать но первый шаг сделан таким же мы сожмем координат сожмем
координат что это значит это значит что давайте мы сохраним все возможные иксы и все возможные
игреки по исходным точкам вот есть у нас н точек соответственно каждый из них дает какой-то
икс и какой-то игрек значит заводить заведем там массив сортир x заведем массив сортир y и
соответственно здесь будет какие-то n чисел n ординат наших точек и здесь тоже n чисел n
продам здесь значит абсцессы да в смысле координаты по их сумм по их сумм здесь ординаты координата по
ику вот значит мы их все сваливаем в 1 в один вектор потом его сортируем юника я кажется про это
уже рассказывал так же мать координаты когда мы обсуждали различия между онлайн подходом и
оффлайн к решению всяких задач значит паспорт цифровали про юникари то есть удалили дубликаты
теперь у них как бы ну все возможные уникальные иксы игреки которые встречаются в принципе в множестве
точек и тогда каждый исходный x мы можем занять на номер этого x в массиве сортить номер в
сортит но то же самое сыграть игрек номер в этом массиве номер сортит от игрек это значит
сортировки всякие бин поиски дашь бы понять где число находится высортированном массиве на
каком месте вот это все это делается зенлогом вот дальше сделаем следующее дальше мы заведем
дерево фенвиков по дереву фенвика деревья фенвика то есть вот есть у меня моя плоскость мы
понимаем что раз нажали координаты то по сути все координаты у нас не больше чем n не больше
чем и здесь не больше чем и по иксу и по игреку мы нажали да что у нас все различных координат не
больше чем n поэтому и номера в этом массиве все не больше чем n дальше вспоминаем как работает
фенвик он для каждой точки и для каждого икса по сути считает f от и считает f от и такое число
меньше и правное и по сути мы хотим вот создать структуру которая целиком отвечает полоске вот
вот этой вот полоски все что внутри мы создадим для этого отдельную свою структуру то есть для
каждого и для каждого и заведем отдельную структуру которая будет на самом деле еще
одним деревом фенвика но пока что давайте отдельную структуру структуру которая хранит все
точки попадающие вот эту полосу которая хранит все точки в полосе ну когда у нас икс лежит в
отрезке от f от и до и но это вот я просто датчик честно рисовал вот это вот полоса
это вот полоса но точнее здесь как бы будет не икс да а ну давайте я здесь напишу что-то
номер икса номер точки потому что когда мы все посортировали потом перенумеровали
точку давайте их перенумеруем так что они идут порядка застанем иксов и соответственно вот это
вот и это номер точки то есть у меня сейчас координаты по иксу это тоже самое что номер
точки вот хорошо значит мне нужно завести структуру которая хранит все точки вот в
этой вот вот в этой полосе в этой полосе и эта структура будет дерева фенника структура тоже
еще одна внутри дерева фенника деревом фенника и так смотрите получилось что прям garlic for
каждого и у меня есть отрезок дерева фенника вот то есть мне есть дерево фен肥 капу иксам
вот starting поэтому это и progressing да для каждого ей из отрезок обратно compatibility вот вся вот
этого полоса будет храниться еще одном дирline фанды то есть не будет firing 1 дир Amendir
для каждого и свою дереву поэтому назвать дерево фенрика деревья фенрика потому что
каждый элемент внешнего дерева это одно внутреннее дерево фенвика. Ну а дальше, что у нас
будет дерево фенвика вот здесь? Мы понимаем, что это какая-то полоса, что здесь есть какие-то
точки, какие-то точки исходного множества. Ну и давайте теперь эти точки посортируем по у.
Сорт по у. Ну и соответственно, если здесь точек, скажем, мало, здесь всего 6 точек,
тогда понятно дело, что не нужно заводить здесь дерево фенвика на n элементов, потому что как у
нас работал двумерный фенвик, он просто для каждого и заводил по сути дерево фенвика размера n,
когда у меня была такая плотная кабличка, в каждой точке что-то написано. А теперь у меня в этой
полосе может быть очень мало точек, их там может быть далеко-далеко нет, одна-две точки,
ну может быть сколько-то мало. Вот, тогда давайте мы заведем дерево фенвика ровно такого размера,
сколько точек в этой полосе. То есть вот здесь есть 6 точек, давай тогда их перенумеруем, скажем,
что вот эта первая, эта вторая, эта третья, четвертая, пятая, шестая, то есть пронумеровали
снизу вверх в порядке возрастания у. И построим дерево фенвика вот на этих 6 элементах. То есть
дерево фенвика будет размера 6. Ну и в этом дереве мы храним как раз вашу. А ведь вот мы, когда будем
вот новые номера давать, это же будет за отдельное время занимать. То есть мы по факту... Внутри каждой
полосы мы будем сортировку делать, да. Ну да, но просто сейчас... Мы проанализируем еще время работы.
Окей. Вот, значит, мы для каждого и действительно рассматриваем все вот эти вот точки, которые
попадают в полоску, от f от i до i, сортируем их по игре по, строим на них дерево фенвика. А дерево
фенвика обычная update с точки суммы на отрезке. Вот прям самая простая. Даже не на отрезке, а на
префекции. Потому что раз у меня такой прямоугольник... Давайте я вернусь. Значит, у меня вот такой
прямоугольник, который просто... Ну, по сути, вот эта вот правая верхняя граница. Тогда отвечать на
запрос мы будем, как всегда. Мы, значит, разбиваем отрезок по иксу на вот эти вот... Ну, на такие
блоки, да, по, собственно, как мы прыгали в дерево фенвика по иксу. Соответственно, каждый блок
это какая-то вот такая вертикальная полоса. Значит, первая полоса, вторая полоса и вот третья полоса.
Дальше мне нужно в каждой полосе узнать сумму значений в точках, которые находятся не выше, чем у.
Вот мы проводим такую штуку. Соответственно, остаются какие-то точки. Остается какой-то префикс в каждой
полосе, да, потому что мы ограничили, ну, как бы сверху все координаты. То есть остаться префикс в
каждой полосе, но мне нужна сумма на префикс. То есть внутреннее дерево фенвика, оно обычное
дерево, update с точки и сумма на префиксе, как вот у нас было в самом простом варианте в прошлый раз.
Изменения в точке и сумма на префиксе. Вот. Теперь, значит, что, что с синтрофикой? Как построить такую
структуру? Построение, построение вот этого фенвика фенвиков. Ну, мы в самом начале сказали,
что у нас есть сортировка и потом всякие бим поиски, чтобы перенумеровать все наши точки.
Перенумеровать все наши точки. Это NLogin. Это всякие сортировки, перенумерование и так далее.
Дальше. Мне нужно для каждого и посмотреть, сколько есть точек в этом отрезке, да, то есть
пройтись по всем точкам с номерами от f от i до i и их все посортировать. То есть, по сути, у меня,
ну, как минимум, мне нужно в каждой полосе сделать такую сортировку, а потом еще построить дерево
фенвика. Значит, за сколько, вот если здесь ка точек, если здесь ка точек, где k это и минус f от
и плюс один, да, потому что, ну, как раз, да, если мы, если мы ограничиваемся по иксу здесь ишкой,
а здесь f от и, то количество точек в этой полосе ровно вот такое, потому что мы вырезаем какой-то
отрезок. Левый начало этого отрезка имеет номер f от и, правый конец имеет номер i. Тогда, соответственно,
в этом, в этой полосе ровно столько точек, ровно ка точек. Ну и сортировку мы делаем за колобка.
Сортировка за колобка. Значит, уточню, что это сортировка точек внутри полосы по y.
Сейчас-то мы же еще должны будем по массиву всему пройтись и эти точки как бы выделить в
отдельный массив или как? Смотрите, да, да, да, смотрите, еще раз, вот есть у меня, смотрите,
у меня есть по сортированной точке p0, p1, p2 и так далее, pn-1. Они посорчены по иксу, то есть здесь
x минимальный, здесь x следующий, x второй и так далее, xn-1. Дальше, я для каждого i смотрю на
p0 и на p с инексом f0. Выделяю, создаю новый вектор, создаю новый массив, по сути, копирую в него
все вот эти элементы, все вот эти точки и сортирову его по y. То есть, я вычленил какой-то отрезок из
старого моего массива, посортил его по y и теперь на этом массиве буду строить дерево фингрика.
Ну если, соответственно, у меня есть вот эти вот ка точек, они посортированы и на них я в этом
порядке строю дерево фингрика. Дерево фингрика строится там, ну либо закат, мы с вами умеем строить
дерево фингрика за к, либо за колобка. А можно вопрос? Да. А почему не может быть больше точек?
Что значит не может быть больше точек? Здесь ка точек. Внутри отрез к, почему k это i-f, а ты плюс 1?
Потому что мы определяем для себя, что такое полоса соответствующая i-те вершине. Вот у меня есть
i-t точка, есть точка с индексом f, а ты. Тогда давайте мы скажем, что в полосе мы просто возьмем
массив вот с этой точки, вот до этой и будем говорить, что в этой полосе лежит ровно вот эти
вот точки. Мы просто так определяем. Здесь ровно ка точек, потому что мы так себе положили.
Возможно вас смущает то, что на этих сторонах могут быть еще точки, скажем, вот здесь может
быть и плюс первая точка, и ее как бы возможно надо бы учесть. Но так вот нет, давайте ее не будем
учитывать, давайте не будем ее относить к этой полосе. Давайте скажем, что в полосе лежат как бы
ну только точки во внутренности, ну и вот те, которые собственно с нужными номерами, у которых
номер от f и до i. А если точка даже в полосе, но имеет неплохой номер, неподходящий, то мы ее к
нашей полосе относить не будем. Не, наверное, смущает то, что у нас полоса как бы зависит чисто от i,
но при этом в эту полосу можем сложить хоть все элементы. Ничего в этом страшного нет, да, такое
может быть. Для каждого i у нас своя полоса, для каждого i своя полоса. Так вот, вы мне не даете
проанализировать все. Я писал в дарит, сейчас будем мерить 8 точек, сколько у нас всего используется,
сколько времени. Для каждого i у нас своя полоса, свое дерево на каждой полосе. Так вот,
значит, какое время работы? Получается, что время работы такое. Время построения. Время построения.
Это n log n, вот это вот, да, изначальная сортировка. Плюс сумма по всем i k i t log k i t,
ну, где k i t равно i минус f at плюс 1. То есть, да, для каждого i своя полоса. Там какое-то определенное
количество вершин. В i-той полосе k i t вершин. Ну, соответственно, чтобы все посортить и построить
дерево, мне нужно k i t, n log k i t операции. Ольга, по определению. В полосе точек ровно столько
по определению. Потому что в i-той полосе мы рассматриваем все точки, начиная с f i до i.
Ну, сколько чисел в отрезке, сколько целых чисел в отрезке от f i до i? Ну, вот ровно i минус f at
плюс 1. То есть, у нас по одной координате может быть две точки. То есть, дефиксируем их координату,
на этой полосе может быть две точки. Вот я здесь говорил. Возможно, такое будет. Но, еще раз,
мы тогда, мы их просто не относим к нашей полосе. То есть, смотрите, вот есть у меня, допустим, есть
какая-то p и плюс первая точка, которая как бы формально тоже лежит в этой полосе. Но мы ее тогда не
будем сюда относить, потому что у нее слишком большой номер. То есть, в этой полосе у нас будут
просто формально. В этой полосе лежат все точки, у которых номер не больше, чем i и не меньше,
чем f at. Все, вот определение. То, что здесь происходит на границе, какие-то точки, у которых формально,
которые лежат на этих границах, но у которых номер там меньше, чем f at или больше, мы просто
говорим, что они в этой полосе не лежат. Вот просто так по определению положили. Номер от координата x?
Вот не совсем. Не совсем, да. Номер это после сортировки. Да, вот то, как мы их тут посортировали,
какой номер здесь? Такой номер. Иксы могут совпадать, но, типа, у них могут различаться
номера. И вот мы смотрим, по сути, на номера. Иксы нам нужны только для сортировки. Так вот,
значит, как проанализировать вот такую штуку? Сейчас, одну секунду.
Не, ну мы можем это внести, видимо, под один этот самый алгоритм. Давайте я сделаю, значит,
можно сделать следующее. Значит, мне сейчас нужно оценить вот такую сумму. И там от 0 до
1. Каито лог каито. Давайте я каждое каито, вот алгоритм каито, оценив сверх алгоритмом n просто.
Каито на алгоритм m. Ну, потому что понятно, что каито не больше, чем n. В каждой полосе не больше,
чем n вершин. Не больше, чем n точек. А дальше, значит, мне нужно, по сути, оценить сумму всех каитов.
Ну, смотрите, сумма всех каитов. Это можно написать по-другому. Это сумма по всем жи,
сожитых, где сожитое, это количество полос, в которые попала житая точка.
Количество полос, в которые попала житая точка. Это такой как бы двойной подсчет. Здесь у меня
написано, сколько суммарно есть точек во всех полосах. То есть сумма по полоскам,
сколько точек в полоске. А здесь, наоборот, сумма по точкам, в скольких полосках лежит точка.
Сумма по жи, сожитая. В скольких полосках лежит каждая точка. Значит, понятно, что это одно и то же.
Вот, но это уже считается просто. Мы с вами знаем, что c житое не больше, чем лог n. Потому что что
значит, что c житое лежит в какой-то полосе. Значит, житая точка лежит в этой полосе,
если только если f и меньше равно ж, меньше равно и. По определению, мы с вами сказали,
что в этой полосе лежат ровно такие точки, у которых номера больше равны, чем f и меньше равны,
чем i. Значит, получается, что житая точка лежит в этой полосе ровно при выполнении такого условия.
Но мы с вами в прошлый раз доказывали, что все i удовлетворяющие вот этому условию, точнее,
наоборот, все i удовлетворяющие вот такому условию при фиксированном жи. Мы знаем,
как они получаются. И это жи, а потом жио-джи, жио-джио-джи и так далее. Это мы доказывали в прошлый раз,
что если у меня вот это вот фиксировано, а я хочу найти количество i таких, что выполняется вот этого
двойного неравенства, тогда количество таких i — это максимум логарифм. И они все получатся как
навешивание функции ж на жи несколько раз. Вот это вот жи, жио-джи, жио-джио-джи и так далее,
несколько раз, пока мы не упрёмся до конца массива. Поэтому все вот эти вот штуки максимум логарифм,
то есть каждая точка участвует максимум в логарифме полос. Ну, поэтому суммарно размер всех полос
максимум н логан. Поэтому эта сумма оценится всех в н логанах. Значит, вывод. Построение работает
за n лог квадрат времени, n лог квадрат времени и n лог n памяти. Н лог n памяти именно потому,
что каждая точка лежит максимум в логарифме полос. Значит, суммарно, да, суммарно размер всех
полосок, а значит и суммарно размер всех деревьев фенника, он у меня n логан. Каждая точка максимум
логарифме полос, значит суммарный размер всех полос, а значит и вообще суммарно, суммарная
требуемая память, это n логан. Сколько точек умножить на сколько полос в полосах они лежат.
Максимум n логан памяти. Вот. Хорошо, значит это мы построили. Ну, а дальше как отвечать на запрос?
Ответ на запрос. Значит, приходит запрос какой-то x и y. Значит, первое, что мы делаем, это заменяем
x на номер в сорте над x. Ну, точнее на наибольшее число меньше равное, чем x. Да, потому что,
вот смотрите, если есть у меня какой-то запрос, вот такой вот x и y. Вот есть запрос x и y. Мне нужно
как бы посчитать сумму h с точек, которые лежат левее и ниже вот этой вот вершинки, ну, вот этой
точки x и y. Тогда понятно, что x можно уменьшать до тех пор, ну, вот смотрите, я могу его вот так
вот уменьшать, пока здесь не будет лежать первая точка. То есть вот так я его уменьшу, соответственно,
до тех пор, пока на вот этой вот вертикальной прямой не начнется лежать одна точка. То есть я могу
вот этот x так уменьшить, чтобы он был одним из элементов в сорте над x. Ну и так его можно уменьшить,
то есть просто я сужаю область, вырезаю там какую-то полоску, в которой нет ни одной точки. И так дохожу
до первой, просто точки, которые соответствуют наибольшему числу, которая не больше, чем x. Да,
просто ближайшее слева число, вот оно будет здесь. Это тоже делается бинпоиском, тоже делается
бинпоиском. Мне нужно массиве найти наибольшую числу, не больше, чем какой-то x. Ну и то же
самое делаем с y. То же самое делаем с y, как-то его уменьшаем. Эту горизонтальную полоску
превышаем вот в эту. Наша новая x вот здесь. Ну а дальше, что у меня есть? Мне нужно за логарифом,
давайте перерисую картинку. Есть наши точки. Есть какой-то такой запрос, например. Ну конечно,
есть там точки где-то выше и правее, и так далее. Значит, вот эта точка x, да, номер x. Тогда я
просто опять, как всегда, разбиваю мой запрос по x. Как мы это всегда делаем в зере Феллика,
то есть это f от x, это f от x минус 1, да, это соответственно f от f от x минус 1, ну и так далее.
Короче, мы разбиваем по x на такие полоски. Разбиваем по x на вот такие полоски. Ну а дальше
внутри каждой полоски у меня по сути запрос к одномерному Феллику. У меня есть текущие,
значит, внутри каждой полоски. У меня есть список точек, которые в ней лежат. Список точек,
которые в ней лежат. Дальше я могу опять с помощью еще одного вложенного бинпоиска внутри
определить, как бы, какой максимальный номер точки меня интересует. То есть скажем, вот здесь я
вижу y какое-то, да, ограничение сверху. Дальше тогда мне нужно определить первые сколько точек лежат ниже,
чем этот y. Но это опять бинпоиск. Если у меня есть внутри вот здесь вот посортированный список
всех точек, внутри каждой полосы, то мне нужно просто с помощью бинпоиска определить опять-таки
ну самую высокую точку, которая лежит не выше, чем y. То есть вот она будет вот в этой полосе.
Это будет 2y точка. Дальше в какой полосе? Вот в этой следующей. Это будет 2y точка. Да, ну короче,
мы просто в каждой полосе определяем самую высокую точку не больше, чем y, не выше, чем y. Это
еще один бинпоиск в каждой полосе. А потом еще за один логарифм отвечаем на запрос. То есть теперь
мы уже понимаем, что внутри этого дерева Фенрика все точки осортированы по y, и мне нужна сумма на
префиксе. Сумма на префиксе. Причем я понял на каком префиксе с помощью бинпоиска. Значит,
в итоге у меня будет логарифм n полос, log n полос, в каждой полосе у меня бинпоиск плюс запрос к Фенрику.
В каждой полосе бинпоиск, чтобы определить длину префикса, на котором мне нужно найти сумму,
плюс запрос к Фенрику. Запрос к Фенрику. Ну и значит у меня лог раз будет выполняться что-то
за логарифм. В итоге здесь будет лог квадрат. Лог квадрат на запрос.
Лог квадрат на запрос. Если же приходит запрос второго типа, запрос изменения в точке, то мне в
общем-то тоже нужно сделать что-то похожее. Мне нужно понять в каких полосках лежит данная точка.
Вот пришла итая точка, мне нужно в ней поменять значение. Я хочу понять все такие х, что итая
точка лежит в полоске для х, то есть и больше равной чем f от х, и меньше равной чем х. Но
таких полосок тоже логарифм, мы их умеем с помощью Фенрика быстро находить. А потом в каждой полосе
нужно определить, где эта точка итая находится, опять с помощью бинпоиска. У меня есть точка,
мне нужно найти где находится в каждой полосе, какой у нее номер в каждой полосе за бинпоиск.
И потом еще внутри для этого Фенрика сделать за логарифм update в точке. Изменение в точке.
Получается тоже запрос за лог квадрат. У меня каждая вот эта точка, для которой происходит изменение,
она лежит в логарифме полос. В каждой полосе нужно сначала запустить бинпоиск, чтобы понять на
каком месте лежит эта точка итая точка. А затем нужно сделать один запрос изменения к Фенрику,
который также обрабатывается за логарифм. В итоге логарифм полос, в каждой полосе обработка
за логарифм. Получается запрос второго типа тоже за лог квадрат. Как мы выбираем количество полос?
Полос мы не выбираем. Вы про то, что изменение в точке, правильно понимаю?
Когда мы зажимаем прямоугольник справа.
Когда мы зажимаем прямоугольник справа, как мы зажимаем или какие полосы получаются?
Полоски. На полоске, как всегда, в Фенрике. Вот смотрите, есть у меня запрос к Фенрику.
У меня есть точка здесь xy. Ну где xy, это уже теперь номеравку в порядке сортировки.
Вот есть точка с номером x. Вспоминаем, как работает Фенрик. Он у меня берет, считает f от x.
Логически это x и x плюс 1. Это первая полоса. Полоса контролирует все точки с номерами от fx до x.
Это отдельная полоса, в ней хранится свой Фенрик. Мы делаем запрос к тому Фенрику.
Дальше есть все остальные неучтеные точки. Самое правое из них имеет номер f от x минус 1.
Вот эта точка имеет номер f от x минус 1. Самое правое неучтеное. Для нее тоже самое.
Мы можем вычислить значение функции f, то есть f от f от x минус 1. И это будет еще одна очередная полоса.
В ней тоже свой Фенрик. Делаем к нему запрос. В общем, так делаем, ровно так же, как у нас работает обычный Фенрик.
Разбиваем вот этот вот отрезок по x на несколько отрезков, на несколько под отрезков в Фенрике.
Каждый отрезок в этом разбиении – это будет полоса.
Каждый из них свой Фенрик, свой запрос.
А имеет смысл сразу же разгонять программу, то есть писать там всякие префиксные суммы и так далее?
Или можно будет, не разгоняя ее, загнать без тайм-лимита?
Так, префиксная сумма – это где? Где построение Фенрика за n, а не за k, а не за k?
Ну, например.
Это не обязательно нет.
То есть программа зайдет?
Должна, да. Но здесь не особо есть что разгонять, и вообще она должна заходить более-менее без проблем.
Тут много всего надо хранить.
Тут самое главное, что в каждой полосе вы храните две штуки.
Вы, во-первых, храните список точек, ассортированных по Y, в этой полосе.
А также храните дерево Фенрике на этих точках.
Ну а дальше уже можно не особо там подмазывать, оно и так должно спокойно заходить.
А у нас не сломается это дело, если у нас будет много точек с одной координатой X и разбросанных по Y?
Ничего страшного не будет.
Смотрите, наш анализ, ему было пофиг на то, какие X у этих точек.
Главное, что мы их как-то посвященствовали.
И понятие полосы, оно, возможно, довольно глупо будет смотреться, когда они все, грубо говоря, на одной вертикальной прямой лежат.
Ну хорошо, тогда вместо полосы у нас будет просто какой-то отрезок точек от Итой до Фатты.
А дальше весь анализ от этого не портится.
То есть все равно отрезок по Иксан, опять все равно распадается на логарифм отрезков Фенрике.
И в каждом отрезке у меня хранится свое дерево Фенрике, и там тоже логарифм.
Я имею в виду то, что у нас в одном из деревьев Фенрика тогда будет очень много данных.
То есть почему у нас не проходит Фенрик?
Почему нам нужен Фенрик Фенриков, а не проходит двумерный Фенрик еще раз?
Смотрите, мы знаем, сколько точек в каждом дереве Фенрика.
И там дерево Фенрик, и Каи Те, точек, где Каи Те, Фатты минус 1, Фатты минус и плюс 1.
Ну а мы анализ весь уже провели, мы знаем, сколько точек в каждой полосе,
мы знаем, сколько суммарно у нас точек во всех полосах, н логн максимум.
Ну поэтому, поэтому все хорошо.
Ну допустим, Каи Те может быть 10 в пятый.
Ну какое-то одно может.
Ну может, например, если у вас И это там в двоечной записи 1, 1, 1, 1, 1, 2,
тогда Фатты это видимо 0, 0, 0, 0, 0.
И да, какое-то одно конкретное Каи Те может быть большим.
Но суммарно сумма размеров всех полос, она не больше, н логн.
Мы это с вами выше доказали.
Я хотела точить, то есть у нас если мы берем максимальную корзинаку у всех точек, которые имеются,
мы как раз так и делим эти полоски, используя Ф.
Максимальную корзинаку, да, смотрите, мы берем максимальную корзинаку,
которая меньше либо равна, чем параметр запроса.
Вот если мне пришел какой-то х, ну параметр запроса, то я нахожу наибольшее число не больше, чем х.
То есть у Каи Те есть разделение на полоски каждый раз как бы новое, то есть оно зависит от токсая.
Конечно, для каждого запроса свое разбиение, конечно.
Сейчас, а почему у нас все-таки квадрат?
То есть, понятно, логан-полос, на допустим, логан-полос, каждый запрос в нем тоже логан, а бинпоиск куда девается?
Внутри каждой полосы вы делаете бинпоиск один за логарифом и запрос к фенвику один тоже за логарифом.
Но в итоге у вас в каждой полосе два логан.
Полос логарифом, логарифом умножить на два логарифом, это два лог квадрата, это от лог квадрата.
А чем хуже двумерный фенвик, чем вот фенвик фенвиков?
Тем, что он потребляет n квадрат памяти, а эта штука потребляет n логан памяти.
Ага, понял, спасибо.
Окей, давайте двигаться дальше.
Извините, если я не на все вопросы отвечаю, нам все равно нужно ехать дальше, иначе мы мало чего успеем.
Значит, мы переходим к новой большой теме, это деревья поисков.
Деревья поисков.
Все, значит, мы закончили с...
Что у нас было раньше? У нас были всякие кучи, потом дерево отрезков, дерево фенвика и спортстейбл.
Вот это такие простые структуры.
Значит, теперь деревья поисков.
Дерево поиска – это такая структура, которая умеет отвечать, ну, как минимум, на следующие три запроса.
Значит, оно должно хранить множество s в каком-то виде, хранить множество s.
Ну, там чисел или каких-то других элементов. Я скажу, что чисел, например.
И должно уметь отвечать на три запроса.
Первое – это вставить какой-то x, то есть вставить x в s.
Добавить новый элемент в наш s.
Второе – это erase x, наоборот, удалить x из s.
Удалить x из s.
И третье, новое, чего у нас еще не было – это find x.
Find x – сообщить, входит ли x в s.
Вставить, удалить и проверить наличие.
Ну, сразу давайте скажем, что мы храним именно множество, а не мульти множество.
То есть у нас не будет никогда кратностей.
И если, например, мне два раза приходит insert одного и того же, то есть insert x, insert x
то я просто буду игнорировать дубликаты, то есть если мне два раза вставляют одно и то же число
я буду вставлять только одно из них, а второе – буду игнорировать.
Erase удаляет, собственно, единственное вхождение.
То есть я, по сути, просто игнорирую дубликаты, но если мне приходит erase,
то есть я считаю, что каждое число входит максимум один раз, и именно как бы у меня множество хранится.
Если происходит инсерт повторный, то я его игнорирую. То есть повторный инсерт игнорируется,
а erase работает как удаление износства, просто удаление элементов со всеми.
Неважно, сколько у него там копии, мы считаем, что копия ровно одна.
Давайте говорим, что работаем без повторяющихся элементов.
Без повторяющихся элементов с. Вот что значит мы хотим от дерева.
Еще есть опциональные запросы.
Опционально. Можно научиться отвечать на запросы merge.
Это как бы по двум деревьям. Давайте напишу, что есть множество s1, s2.
Вам нужно их как бы объединить.
S1 и S2 в одно новое множество.
В одно новое множество. Есть у вас там одно множество чисел, другое множество чисел.
Вам нужно их научиться объединять. У нас было такое в биномиальной куче.
Когда у нас там есть две кучи, мы хотим их просто склеить, создать одну новую большую кучу,
в которой лежат все элементы из двух предыдущих.
Вот. И еще один опциональный запрос. Это запрос split.
Split s, x.
Это вот такое. Вам нужно множество s разбить на два.
В первом из которых будут все числа не больше, чем x.
А во втором все числа больше, чем x.
Разбить s на s1. Это все y из s.
Не больше, чем x.
И на s2. Это все y.
Sorry, не больше, чем x.
И все y больше, чем x.
Меньше либо равное и больше, чем x.
Split одного множества на два кусочка по какому-то разделителю.
Пришел x. Меньше либо равное влево. Больше ли встал.
Например так.
Вот что мы хотим на дерево поиска.
Да, например, зачем это может быть нужно.
Самый простой ответ какой-нибудь, это такой.
Можно хранить какую-нибудь базу данных пользователей.
Вот вы пишете какой-нибудь свой сайт. Вам нужно хранить там, не знаю.
Когда каждый пользователь, в последний раз посещал ваш сайт.
Соответственно, вам нужно для каждого.
Не знаю. Для каждого ими пользователя хранить в последнее время, когда он посещал ваш сайт.
Соответственно, какие у вас бывают запросы?
то есть добавить кого-то нового пользователя, завести нового пользователя и там сказать, что он только что
был на вашем сайте. Бывает операция RACE, когда, например, пользователь удаляет свой аккаунт и,
соответственно, вы можете стереть всю информацию в нем и освободить память о вашем компьютере.
И бывает операция FIND, значит, вы либо просто спрашиваете, есть ли такой пользователь у вас на сайте,
либо там же, где и FIND, в общем-то, столь же просто вы можете понять, в какой последний момент времени он
заходил. Если вы имя пользователя нашли в вашем дереве, в вашей структуре, то вы можете посмотреть,
какое число с ним ассоциировано, в какое последнее время, в какой последний момент он
заходил на ваш сайт, и вывести это число. Таким образом, вы можете знать, когда этот пользователь был
последний раз на сайте. Почему это деревья поиска? Потому что мы будем в качестве вот этой структуры,
которая умеет отвечать на все эти запросы, мы будем рассматривать двоичное дерево поиска.
Двоичное дерево поиска. Значит, что такое двоичное дерево? Двоичное дерево – это когда у вас есть
какой-то корень, root, корень, и затем у каждой решины есть максимум два сына. Есть левый сын,
правый сын, есть левый сын, правый сын. Здесь, например, есть только левый сын, здесь есть,
например, только правый сын, здесь есть тоже, например, только правый сын. У каждой решины,
у каждой решины не более двух сыновей. Левый и правый. Вот. И это значит, что такое двоичное
дерево? Потому что у каждой решины максимум два сына. Теперь, что такое дерево поиска? Дерево
поиска – это такое дерево, которое удовлетворяет следующему условию, что если в вершине написано
какое-то число х, то во всем левом под дереве все числа обязательно строго меньше, чем х. А во
всем правом под дереве числа обязательно больше, чем х. Вот это дерево поиска. Дерево поиска. Еще раз,
если в вершине написано какое-то число, то есть вершина соответствует какому-то пользу,
именю пользователя, имени пользователя, тогда в левом под дереве, то есть все, что находится в
левом сыне и ниже всего этого левого сына, все, что достижено из левого сына, там все имена пользователя
или все числа меньше, чем х. Но если мы говорим про строки, то должно быть какое-то сравнение на
строчках, например, лексик графическое. В каком-нибудь порядке строчки сравниваются. Вот слева все меньше х,
а справа все больше х обязательно должны быть. Это дерево поиска. Ну, соответственно, если все это
выполняется, то есть если у каждой вершины максимум два сына, а также для каждой вершины,
если находится в ней число х, то слева должны быть только меньше х, справа только больше х.
Если все это выполняется, то это двоичный дерево поиска. Вот, значит, ну, можно написать на основе
такого определения наивное дерево поиска. Наивное дерево поиска. Давайте мы предложим,
как можно реализовать все операции insert, erase и find в нашем деле. Давайте начнем
с простого find. Вот скажите, пожалуйста, если у меня есть двоичное дерево поиска, как в нем
проверить наличие какого-нибудь х, что есть вершина, в которой написано число х? Пускаться по веткам из корня,
либо меньше, либо больше, в зависимости от значения корня. Да, все верно. Значит, давайте встанем в корень,
посмотрим на то число, которое в нем написано, например, z. Ну, если z равно х, то мы сразу его
нашли. Дальше, если z больше, чем x, то есть х меньше, чем z, тогда мне заведомо нужно идти влево,
то есть если z больше, чем x, нужно идти влево и искать его в левом подделе, потому что справа
лежат только еще большие числа, значит, туда идти нет смысла. И наоборот, если z меньше, чем x,
то x, если где-то и находится, то только фраум поддели. Слева его быть не может. Вот, ну, собственно,
поэтому их называют дерево поиска, потому что поиск здесь реализуется очень-очень просто. Нужно
просто идти либо влево, либо вправо, в зависимости от сравнения x с текущей вершинкой z. Это работает
за глубину. Работает за от аж, где аж глубина дерева. То есть просто длина максимального пути
от корня до какой-то из вершин дерева. Максимальный путь сверху вниз. Теперь можно сделать инсерт,
например. Инсерт x. А у нас же глубину можно сделать пополам, вроде бы, нет? Ну, это все равно будет
для нас слишком плохо. У нас будет глубина логарифмическая. Когда мы сделаем хорошее дерево,
у нас будет глубина логарифмическая. Но пока что давайте наивно дерево поиска, не задумываясь о том,
насколько эффективно это работает. Как сделать инсерт в дерево? Ну, например. Нужно просто идти из корня и в пустое
место вставить. Да-да-да, все верно. Значит, мы можем также вставить в корень. И давайте запустим,
как бы, алгоритм, который мне искал бы х в дерево. Вот мы стоим в корне, тут написано число z, и мы
понимаем, как бы, где должен лежать х. Он либо уже присутствует в дереве, ну скажем вот, не знаю,
z больше, чем x. Он либо уже присутствует в дереве слева, либо, если его там нет, то нужно его туда
подвесить. То есть мы переходим все равно в сына, и здесь пытаемся найти место для х. Ну и, в общем,
так идем-идем спускаемся. И когда, например, в какой-то момент я понимаю, что мне нужно идти вправо,
а справа никого нет, то есть нет правого сына, тогда мне нужно правого сына создать и сказать,
что здесь написано число х. Это случается не бинарная куча с дополнительными операциями?
Нет. Это не бинарная куча, потому что, ну, бинарная куча заполняется по слоям. У нее есть корень,
у него, ну, то есть она обязательно имеет вот такую структуру, что там все есть вершинки на предыдущих
уровнях, а последний заполнен может быть не полностью. А у нас такое будет совсем не всегда
выполняться. У нас, ну, например, там может не быть правого сына вообще, то есть может быть
какой-то такой, но это какая-то часть бинарной кучи, но, в общем, здесь аналогия не работает,
и еще как минимум не работает, потому что в куче у нас не было вот такого соотношения,
что слева лежат все меньше числа, справа все больше. Там было просто требование,
что снизу все меньше-лево равны, а здесь другое требование, да, у меня есть как бы разделение
налево и право, поэтому с кучей здесь аналогия, ну, такая, не очень работающая. Итак, значит,
insert работает как будто бы просто find x, и если мы пытаемся пойти в несуществующего сына,
то вот туда подвесим x в качестве листа. Значит, если x, ну, давайте скажем, что если x лежал в
дереве, то мы ничего не делаем, лежал в дереве, то делать нечего, иначе подвешиваем x в качестве
листа, значит, иначе x подвешиваем в качестве, ну, вот такой, да, висячей вершинки, в качестве
листа, в качестве висячей вершинки к той вершине, откуда мы в последний раз пытались его искать,
то есть вот мы стояли здесь, и здесь было там число меньше, чем x или меньше, чем x, то есть мы как бы
должны пойти направо, но у этого игрока нет права сына, ну, тогда просто давайте x создадим новую
вершинку вот здесь, и скажем, что x является новым правым сыном, подвешиваем в качестве листа.
Ну, окей, как это реализовали. Проблема такой реализации, что если у нас будет куча инсертов,
insert 1, insert 2, и так далее, insert n, например, вот в таком порядке, тогда дерево, которое мы построим,
будет вот таким, просто вот такая вот ветка вправо, 1, 2, 3, и так далее, n, потому что есть у
меня корень, 1, потом в качестве права сына я подвешу 2, потом еще 3 нужно подвесить сюда,
4 в качестве права сына, и так далее, и так далее, у меня будет такой выраженный случай. Вот поэтому
собственно это и есть наивное дерево поиска, оно может быть весьма неэффективным, но пока что
мы про это не думаем. Давайте хоть как-нибудь реализуем, чтобы потом нам было проще. Хорошо,
мы сделали insert. Дальше erase, erase x. Здесь тоже мы сначала попробуем его локализовать в дереве,
попробуем найти. Если его нет в дереве, то делать ничего не нужно. Если x нет в дереве,
то делать нечем. Иначе давайте мы предположим, что мы нашли наш x в дереве. Отличный случай
был бы, когда у x нет детей, то есть нету ни левого по дерева ни правого по дереву, у него нет ни
одного сына, ни лева ни правого. Тогда все очень просто, нужно просто забыть про существование x,
и соответственно, если у x был какой-то родитель p, то сюда удалить вот эту стрелку. То есть если
x был раньше левым сыном в какой-то вершинке, то теперь скажешь, что у нее нет левого сына. То
есть идеальный случай, когда у x нет детей, у x нет graphs, x это лист, тогда нужно просто его
и соответственно там отрезать какую-то ветку отрезать какой-то какой-то стрелку из таблиц
вот если x лист
то просто его отрезаем
просто его отрезаем
дальше если у x нет левого сына
то мы можем сделать следующее вот смотрите был наш родитель p какой-то есть x и например у x нет
левого сына у x есть только правое поддерево тогда мы можем просто вот это правое поддерево r
переподвесить на место x то есть забыть про существование x и сказать что теперь картинка
такая просто у старого p левым сыном ну то есть тем же сыном каким был x будет дерево r то есть
все это дерево поднимаем наверх на на единичку про x забываем и переподвешиваем вот эту вот
вершинку в качестве сына p вот это все будет хорошо да потому что здесь никаких конфликтов
не будет здесь вот это дерево было пустой поэтому отсюда ничего торчать не будет ну и соответственно
все все все сохранится все вершинки которые здесь были то есть ну вообще все вершины в этом
поддереве были меньше чем п раз это был левый сын раз их был левым сыном ну тогда их можно
подвесить чуть выше потому что они все равно меньше чем п можно подвести вот если у x нет левого сына
можно просто правое поддерево подвесить на его место если же у x есть левый сын то давайте
сделаем следующее теперь пусть у x есть левый сын пусть у x есть так сейчас есть
я так хочу сейчас одну секунду ну да давайте сделаем то же самое что например если у x нет
права сына пусть у x нет права сына тогда то же самое нужно переподвесить только левый сын есть
только левый сын нет права в общем-то тогда картинка симметричная если у п есть какой-то
родитель и есть у него только левый сына нет правого то здесь нет ничего просто или переподвесить
и про x забыть самый тяжелый случай это когда у п есть оба сына и левый и правый есть оба сына
и левый правый тогда мы не можем вот здесь проблема мы не можем просто удалить x и что-то здесь
переподвесить мы не можем вот этот или сюда поднять да как бы потому что здесь будет правое
поддерево и возможно здесь нарушится какие-то неравенства то есть я просто возьму какое-то
число отсюда, помещу его сюда, то возможно оно будет... Сейчас. А, ну да, возможно у него просто и так было два сына, например,
вот здесь было два сына, и мы как бы попытаемся к этой вершинке подвесить еще третьего сына. Но такого делать нельзя, у нас максимум два сына у каждой вершины.
Поэтому как-то здесь просто переподвесить не получается. Решение будет таким. Давайте мы пойдем в правого сына,
и найдем в нем самый маленький элемент, самое маленькое число. Находим Y, самое маленькое число в R.
Это самое маленькое число находится очень просто. Нужно просто идти влево, пока есть левый сын. То есть вот мы стоим здесь.
Если есть левый сын, пошли влево. Если есть левый сын, пошли влево. И так далее, и так далее, и так далее, пока есть левый сын.
Легко понять, что мы таким образом действительно найдем минимальный элемент в дереве, потому что мы встали в корень этого дерева.
Если меньшее число и существует, то оно точно лежит слева. Потому что слева лежит меньшее число, справа большее.
То есть если число меньшее, чем вот этот корень есть, то оно слева. То же самое тут. Если меньшее число и существует, то оно слева.
Ну и так далее, и так далее. Если мы дойдем до вершины без левого сына, то это значит, что нет ни одного числа меньше, чем вот этот.
То есть это Y, вершина без левого сына, и соответственно меньше этого числа никого нет.
Тогда сделаем следующее. Давайте мы вместо X запишем Y, то есть X забудем, напишем на его место Y, а удалим Y, вот это вот старое число Y, его нижнюю позицию.
И это уже легко сделать, потому что смотрите, у Y нет левого сына. Нет левого сына.
И его удалить уже тогда можно, потому что даже если у него есть какой-то правый сын, мы можем просто...
То есть вот у Y, скажем, есть какой-то правый сын, тогда я могу просто это правое поддерево переподвесить на место Y, просто его сюда переподвесить.
И тогда, соответственно, я удалил Y. Вот так будет работать наш Rx. То есть мы сначала находим X в дереве. Давайте повторю.
Мы сначала нашли X в дереве. Потом, если одного из сыновей нет, то мы просто переподвешиваем одного из существующего детей на место X.
Дальше, если оба сына существуют, и левый и правый, то давайте мы в правом поддереве найдем минимальный элемент.
Находим Y, самое маленькое число R в правом поддереве. Затем Y перезаписываем вместо X.
И, наконец, удаляем старое вхождение Y.
Почему это все работает? Ну вот, например, почему мы можем Y перезаписать вместо X?
Потому что Y это был минимальный элемент в правом поддереве. Поэтому, когда я заменяю X на Y, у меня, смотрите, X увеличился.
У меня был X, а он заменился на какого-то чувака из правого поддерева. Поэтому X увеличился, и все вот эти не раз они сохранились.
То есть вот это число с левым поддеревом, оно, конечно, по-прежнему вот это число больше, чем все, что в левом поддереве.
Что происходит с правым поддеревом? Ну здесь мы взяли самое маленькое число оттуда и поместили его в корень.
И потом, причем этот Y отсюда удалили? Значит, все оставшиеся здесь числа, они будут больше, чем Y.
Все оставшиеся справа числа будут больше, чем Y. Значит, инвариант нашего дерева, что слева все меньше, справа все больше.
Инвариант дерева сохранился, поэтому все сделали корректно. Так можно было сделать.
Ну и здесь последнее осталось нам удалить старое вхождение Y. Я сказал, что Y уже не имеет левого сына.
Ну предположение, что это минимальное число, значит, что у него нет левого сына.
И значит, я либо просто его удаляю, если нету даже правого сына.
А если правый сын есть, то я правый сын переподвешиваю, правый сына переподвешиваю на месте ледника.
Правого сына переподвешиваю на месте ледника. Вот и все. Вот такой рейс.
Как работает этот рейс? Хорошо.
Нам вот этот рейс будет очень нужен.
Ну, собственно, нам важно понимать, как это работает в наивном случае, чтобы как-то это оптимизировать.
Итак, значит, давайте теперь тогда рассмотрим одну из вариаций того, как можно наше дерево балансировать.
Сбалансированное дерево поиска.
Значит, мы хотим, мы понимаем, что время работы всех наших процедур, оно в худшем случае пропорциональнее глубине дерева.
То есть, чем глубже дерево, тем дольше мы можем спускаться от корня в пульках х.
Значит, мы хотим, чтобы глубина была как можно меньше.
Ну, она будет логерифмическая везде.
Чтобы глубина была по отлоге, ну, где n это текущее количество элементов в множестве.
N это мощность S.
Ну, соответственно, если дерево такое, мы будем говорить, что оно сбалансированное.
Ну, это неформальное определение.
Сбалансированное просто значит, что оно достаточно хорошее для нас.
И первое дерево, которое мы рассмотрим, это AVL дерево.
AVL дерево.
Значит, AVL это по фамилиям авторов.
Давайте я для общего развития напишу.
Значит, первого чувака звали Адельсон Вильский.
Второго чувака звали Ландис.
Вот какие цивилизации.
Вот почему он так называется странно.
Значит, AVL это первый, L это второй.
Итак, значит, вот что они сказали.
Давайте мы будем поддерживать следующий вариант.
Что если h от v это глубина под дерево вершины v, то требуем следующего соотношения.
Для каждой вершины v разность глубин левого под дерево и правого под дерево должна быть не больше единицы.
То есть вот если это L, это R для любой вершинки v, то модуль разности h от L минус h от R должен быть не большим единицам.
Ну, соответственно, это это определение.
Если для каждой вершины выполняется вот это вот соотношение, что модуль разности глубин левого сына и правого сына не больше единицы,
то есть они вообще либо глубины равны, либо отличаются на единицы, тогда такое дерево называется AVL дерево.
AVL дерево.
Если у каждой вершины модуль разности глубин двух детей левого и правого не больше единицы, тогда мы говорим, что это v дерево.
Вот в частности, например, если там вообще правого сына нету, вот есть вершинка v, у нее есть, скажем, например, левый сын, а правого сына нету.
Ну, тогда правый сын имеет глубину 0.
Будем говорить, что если дерево пустое, то есть если его вообще там ничего нету, то говорим, что глубина 0.
И тогда HL должно быть не больше единицы.
HL не больше единицы.
Вот что такое AVL дерево.
Теперь наша задача состоит в следующем.
Во-первых, показать, что у такого дерева обязательно неплохая глубина, всегда не большим логарифм.
А во-вторых, как-то научиться переделать наши инсерты и рейсы так, чтобы всегда сохранить вот этот вариант AVL дерева.
Что глубины всегда, ну как бы, что глубина левого сына и правого сына всегда уравновешен.
Примерно там плюс-минус один друг от друга.
Ну, давайте сначала сделаем первое, что поймем, какая глубина может быть у AVL дерева из n вершин.
Какая может быть глубина у AVL дерева из n вершин.
Давайте обозначим, наоборот, давайте обозначим S от H, это минимальное количество вершин в AVL дереве глубины H.
То есть, наоборот, мы фиксируем глубину и ищем минимально возможное число вершин.
Фиксировали глубину H и ищем минимально возможное количество вершин S от H.
Тогда давайте сообразим, что такое S от 0.
Мы поняли, что нулевая глубина означает, что дерево пустое, и там 0 вершин.
Дальше глубина единица означает, что просто одна вершина.
Значит, здесь давайте напишу пусто, пустое дерево.
Глубина единицы значит, как бы, одна вершина, и соответственно, всего S от 1 это единица.
Дальше S от 2. Что такое S от 2?
Это значит, что мы можем нарисовать дерево глубины 2.
Какие у нас есть деревья глубины 2?
Есть вот такое дерево, когда у корня есть один сын, соответственно, глубина будет 2.
Либо у корня есть оба сына, и левый и правый.
Больше ничего быть не может, потому что иначе глубина увеличится.
Ну и тогда понятно, что S от 2 это 2, да, потому что у меня, потому что минимальное число вершин это 2.
Ну, это мы поняли.
А дальше можно заметить следующее, что S от h равно 1 плюс S от h-1 плюс S от h-2.
Вот почему.
Потому что, смотрите, есть у меня дерево глубины h.
Дерево глубины h.
Как оно выглядит?
Это корень, первая вершинка, а дальше два сына, два под деревом.
Причем, какие могут быть глубины у этих под деревьев?
Ну понятно, что раз глубина всего дерева это h, то обязательно есть хотя бы один сын, у которого глубина h-1.
Вот скажем, у левого сына глубина h-1.
Отсюда вот это слагаем.
Да, минимальная возможность число вершин в нем.
Это S от h-1.
Теперь вопрос.
Тогда какое минимальное количество вершин может быть в правом сыне?
Ну, можем сказать, что здесь глубина h-2.
Потому что мы знаем, что модуль разности глубин левого сына и левого сына,
отличается максимум на единицу.
И если мы хотим минимизировать число вершин, то понятно, где нужно минимизировать глубину.
Поэтому минимальное число вершин справа это S от h-2.
Значит, это левый сын, максимальный сын, это правый сын, минимальный.
Но получили такое соотношение, что S от h-1 плюс два предыдущих значения.
Вот, тогда я утверждаю следующее.
Давайте я это соотношение перепишу.
Что S от h равно единица плюс S от h-1 плюс S от h-2.
Тогда S от h это вот такое.
Это h плюс первое число фибоначи минус один.
Где f это число фибоначи.
Задающееся соотношением f0 это единица, f1 это единица и так далее.
Причем fкт это сумма двух предыдущих.
fk минус один плюс fk минус два.
Сумму двух предыдущих.
Здесь простое соотношение.
Соотношение, доказательства просто по индукции у h.
Индукция у h.
Значит, база h равно 0, h равно единицы, очевидно.
Мы же с вами уже все это разобрали.
Мы поняли, чему равно S от 0, S от единицы на прошлом слайде.
Мы знаем, чему равно S от h для h равно 0, 1.
Мы понимаем, чему равно последовательность f.
Можно написать, что f от 2 это 2, например.
Сумму двух предыдущих это 2 получается.
Ну и понятно будет, что это соотношение выполняется.
Далее пусть h больше равно 2.
Тогда с одной стороны мы знаем, что S от h это единица плюс два предыдущих S.
С другой стороны, про каждое из двух предыдущих мы знаем его выражение через словебоначи.
Это будет единица плюс f h минус 1.
Мы взяли следующие словебоначи и вышли единичку.
Здесь будет f h минус первая тоже минус 1.
Следующие словебоначи минус 1.
То есть здесь наверно 1 больше, чем у S.
Здесь раскрываем скобки, остается f h плюс f h минус 1.
Минус 1.
Ну а это мы знаем, что это просто f h плюс 1.
По определению, сумма двух предыдущих словебоначи это следующее число фибоначи.
Получилось то, что нужно.
Что S от h равно f от h плюс 1 минус 1.
Таким образом, минималевозможное количество вершин в AVL-дереве DGH,
это какое-то число фибоначи следующее, минус 1.
Число фибоначи минус 1.
Дальше.
Так, вопросик.
Сейчас, одну секунду.
Объясните отношение для S от h.
Вот это.
Давайте вернемся.
Значит, смотрите, откуда это возникает.
Мы измеряем минималевозможное количество вершин в дереве глубины h.
Ну хорошо, что такое дерево глубины h?
Это какой-то корень и два сына.
Значит, есть один сын, ну обязательно есть хотя бы один сын глубины h минус 1.
Потому что, ну, неужно откуда-то взять путь длины h.
Значит, соответственно, хотя бы один из сыновей имеет глубину h минус 1.
Когда вот этот сын имеет глубину h минус 1.
Тогда в нем вот столько вершин минимум.
В этом сыне как минимум столько вершин по определению.
S от h минус 1.
Это минималевозможное количество вершин в AVL-дереве глубины h минус 1.
Теперь смотрим на второго сына.
Какая у него может быть глубина?
Ну, мы с вами знаем, что если это корректный AVL-дерево,
то глубина правого сына отличается от глубины левого сына максимум на единиц.
Поэтому мы можем взять h минус 1 и сделать плюс минус 1 или оставить как был.
То есть глубина вот этого дерева, давайте напишу все возможные варианты.
Это либо h минус 1, либо h минус 2, либо h.
То есть максимум на единичку отличается от h минус 1.
Но смотрите, h точно быть не может, потому что иначе глубина была бы вот здесь вот h плюс 1.
Потому что есть вершинка и по дереву глубина h.
Поэтому суммарная глубина будет h плюс 1.
Правый сын имеет глубину либо такую, либо такую.
Ну, тогда, соответственно, минималевозможное число вершин это, конечно, S от h минус 2.
Потому что глубина либо h минус 1, либо h минус 2.
Но минимум из них это, конечно, h минус 2.
И тем самым минималевозможное количество вершин в этом дереве это S от h минус 2.
Вроде объясню.
Итак, зачем нам нужно это соотношение про...
Зачем нам нужно это соотношение про части Боначо?
Давайте вот перехожу.
Ну, нам на самом деле важен просто их порядок роста.
Нам важен их порядок роста.
Утверждение, даже упражнение без доказательства.
Утверждение без доказательства.
Пусть...
Так, сейчас, одну секундочку.
Как мы их определили там?
Соединиться, да, их, например, с...
Пусть phi равно 1 при скорой, в принципе, пополам.
Тогда f...
Видимо, k минус 1 равно phi в n-х минус phi в минус n-х делить на корень из 5.
Sorry, здесь будет n.
Это легко доказать просто по индукции.
Там вы доказываете, это для n равно единиц и двойки.
Получили соотношение для f0, f1.
А дальше, если вы знаете, чему равно два предыдущих, то есть f от n и f от n плюс 1,
то вы их складываете, получаете f от n плюс 2.
И проверяете, что вот эта сумма равна в точности тому, чему нужно.
То есть доказательство утверждения очень просто по индукции.
Да, это как-то тяжело, возможно, доказывается, но...
Sorry, придумывается эта формула, но доказывается просто.
Но тем более, вы выводили на окончание.
Нет, смотрите, делений здесь вообще нет никакого.
Можно понять, что здесь деление само по себе будет целым.
То есть здесь будет что-то, деляющее на корень из 5,
когда вы сократите, останется целое число.
Всегда целое.
То есть так удивительно получается, что это соотношение всегда целое число.
Прилагаю вам это доказать самостоятельно.
Сейчас, у меня минус х и стих не минус n.
То есть там как бы одна фита.
Вроде так. В общем, попробуйте доказать.
Если вы это уже доказывали, то вы и так понимаете, о чем я говорю.
В чем здесь смысл?
Здесь написано какое-то число больше единицы.
1 и 6 кажется примерно.
Вы здесь уже возводите степень n,
а здесь вы берете минус 1 и 6, Wirtschaft использовать в степень минус n.
Ну, а в возnutвительности в степени минус n,
что помодли больше единицы – это бесконечно убывающая последовательность.
То есть viktigt стремиться к нулю.
Вы взяли какое число по модулю больше единицы
и возводили в большую обязательно степень.
То есть чем больше n, тем большую отрицательную степень вы ее возводите.
Поэтому это слагаемое, как бы у вас будет стремиться к нулю.
стремится к нулю, и понятно, что основное синтетическое слагаем будет фетен.
Поэтому я напишу так.
n-ное число фибоначи имеет порядок роста в тернах θ, как просто phi в степени n.
n-ное число фибоначи – это θ от phi в степени n.
Потому что, еще раз повторюсь, вот это слагаемое стремится к нулю,
и оно не оказывает никакого вклада в тернах θ большого.
Ну а это просто какой-то константный нождик, который можно игнорировать в этих наших тетобозначениях.
Хорошо, получается, что n-ное число фибоначи растет экспоненциально,
потому что phi – это число больше единицы.
Растет экспоненциально быстро.
f от n растет экспоненциально быстро.
То есть представьте, у вас вместо phi стояло бы там 2.
Например, там 2 в степени n. Понятно, что 2 в степени n растет очень-очень быстро.
Так, ну и тем самым мы понимаем, что s от h значит тоже растет экспоненциально быстро.
Тоже растет экспоненциально быстро.
Ну и можно написать то же самое, что sht – это θ от phi в степени h.
Что ht – это число, это θ от phi в степени h.
Потому что мы выразили вот это число через число фибоначи.
Мы знаем порядок роста для числа фибоначи, значит знаем порядок роста для нашего числа s от h.
Итого, смотрите, если мы фиксировали h, то минимальное количество вершин в дереве, в ВВЛ дереве глубины h, оно экспоненциально по h.
Но, значит, наоборот, если у вас фиксировано количество вершин n, то максимально возможные глубина – это логарифм n по основанию phi.
Значит отсюда следует следующее, что если в дереве, если в ВВЛ дереве n вершин, если в ВВЛ дереве всего n вершин, то его глубина не превосходит, ну я напишу так, o от логарифма по основанию phi от n.
Потому что мы понимаем, что если есть какая-то глубина h, то вершин примерно phi в степени h.
Тогда, наоборот, если у вас есть n вершин, то глубина – это примерно логарифм n по основанию phi.
Логарифм n по основанию phi. Ну и все, а это просто o от логарифм n.
Да, мы с вами знаем, что в o обозначениях можно не писать основание логарифма, потому что они все равно все отличаются в консанту раз.
Все, мы доказали, что в овл дереве на n вершинах максимум o от логн глубина.
Глубина не больше, чем от логарифма, а это то, что мы хотели. Мы получаем дерево, которое всегда не очень глубокое и, собственно, победили.
Нам нужно не глубокое дерево, нам нужно поддерживать этот вариант, тогда ответ на все запросы будет быстрый.
У нас все работает за глубину, поэтому раз глубина небольшая, то время обработки каждого запроса будет логарифмическим.
Каждый запрос будет логарифмическим.
Так, окей.
Ну что, тогда едем дальше.
Едем дальше. Давайте ведем обозначение.
Дельта от v.
Это глубина левого сына минус правого сына.
То есть если есть какая-то вершинка, есть у нее левый сын, есть правый сын,
тогда через delta я буду обозначать такую разность.
Глубина левого сына минус глубина правого сына.
Левый минус правый.
Тогда смотрите, нам хорошо, когда delta от v лежит во множестве минус 1, 0 или 1.
Это как раз означает, что модуль разности глубин двух детей не больше единиц.
И, соответственно, плохо, наоборот, когда delta выходит за эти рамки.
Окей, давайте тогда сделаем следующее.
Рассмотрим случай такой вершинки a, у которой delta от a равно минус 2.
То есть мы что-нибудь сделали с нашим деревом.
То есть представьте, у меня было корректно в льде.
Потом я что-то в нем сделал, например, вставил какую-то вершинку просто из наивного алгоритма.
Я ее вставил там на какое-то место, на которое говорит нам вот этот наивный алгоритм из наивного дерева поиска.
Куда-то вставил новый элемент.
Тогда у меня понятное дело, как-то изменились глубины.
У меня изменились там какие-то глубины, например, если мы подрисовали x в какой-то вершинке y,
тогда у меня у y появилось левое под дерево, значит у него выросла левая глубина.
Вот эта htl для него увеличилась, для y.
То есть как-то перечислялись глубины, соответственно, как-то могли перечисляться delt.
И тогда моя цель такая.
Если какие-то дельты стали невалидными, то есть стали вываливаться из этого множества,
плюс-минус один или ноль, мне нужно эти дельты исправить срочно.
Мне нужно сделать так, чтобы они опять стали плюс-минус один или ноль.
Вот давайте посмотрим случай, когда мы дождитое какую-то вершинку,
вот эта дельта стала минус двойкой.
То есть раньше все было хорошо, теперь я что-то испортил, и теперь стала дельта равно минус двойкой.
Дельта а та равно минус двойки.
Тогда работают следующие идеи.
Давайте поймем, что это значит.
Что такое дельта а та равно минус двойки?
Это значит, что правый сын глубже левого на два.
То есть глубина левого минус глубина правого это минус двойка, значит правый глубже левого на два.
Хорошо, давайте тогда посмотрим на вершинку а.
Есть у нее какое-то левое подделье, возможно пустое, но неважно, давайте его все равно нарисуем.
Есть обязательно у этой вершинки правый сын,
потому что раз правый сын глубже левого на два, то он как минимум существует,
то есть не может быть такого, что у него глубина ноль.
Правый сын обязательно существует, и у него есть какие-то подделья.
В b и c, левый и правый сын.
Давайте рассмотрим случай, когда b равно нулю.
Когда работает следующий поворот.
Давайте мы повернем вот так вот это ребро справа налево.
Можно себе это представлять, как будто у вас есть здесь какие-то гвоздики,
скорее шарникщики, вдоль которых вы можете делать какие-то повороты,
и ваши деревья будут как-то приподвешиваться.
Тогда представьте, что будет, если мы сделаем такой поворот справа налево.
У меня понятно, что b всплывет наверх.
b станет как бы новым корнем текущего дерева.
a станет его левым сыном.
Здесь останется a большое.
Ну и теперь давайте, скажем, b переподвесим вот сюда,
а c оставим вот здесь.
Что произошло?
Мы как-то что-то переподвесили,
и я утверждаю, что там как минимум сохранился вариант дерева поиска.
То есть слева все значения меньше, чем значения в точке.
С правой все значения больше, чем значения в точке.
Значит, это совсем легко понять, потому что смотрите.
Например, раньше у меня было a большое в левом под деревья a.
Теперь a большое тоже в левом под деревья a.
Что было? Было B маленькое, было правым сыном A, теперь A это левый сын B.
Ну тогда здесь отношение было, что A это меньше, чем B, и здесь опять A меньше B должно выполняться, значит все выполняется.
Ну и последнее, мне нужно проверить, что все хорошо между вершинкой B маленькой и правым подделием C.
Здесь тоже, собственно, оно остается справа, поэтому все не раньше сохраняются.
То есть такой поворот мне оставляет корректное дерево поиска.
Теперь давайте посмотрим, что происходит с глубинами? Что происходит с дельтами?
Давайте расставим глубины всех под деревьgroв.
То есть здесь h-1, потому что глубина берется из правого сына, раз в левом сыне глубина на 2 меньше.
То есть здесь какая-то, здесь на 2 меньше, поэтому глубина здесь равна h-1.
В французском языке глубина h-1.
Ну и раз delta2 равно 0, то получается, что вот эти два дерева одинаковые глубины, h-2, h-2.
Хорошо, а теперь что происходит, когда мы так переподвесим?
У меня у a большое, у b большое, у c большое глубины остаются, h-3, h-2, h-2.
Теперь к чему равна глубина вот этого a маленького?
Здесь глубина становится h-1, потому что есть вот такой путь направо, а дальше путь длины h-2.
То есть здесь глубина h-1, а здесь глубина h просто, потому что вот есть ребро влево сына.
Ну и вообще всегда, если у меня есть два сына, один глубины x, другой глубины y,
то глубина родительской вершинки это максимум из x и y плюс 1.
Мы берем максимум из двух глубин и добавляем единицу от, собственно, самого корня.
Зато смотрите, какая здесь прелесть.
У меня вот здесь, вот в этом дереве, все дельты стали хорошими,
потому что у h-ки дельта стала равна минус единице, глубина левого минус глубина правого это минус 1.
h-3 минус h-2 это минус 1.
А у b-шки дельта стала равна единице.
Слева, потому что h-1, справа h-2, лево минус справа это единица.
И получается, смотрите, какая прелесть.
Если у меня была вершина, у которой была плохая дельта, дельта от a равно минус 2,
то я смог за один вот такой вот поворот исправить все дисбалансы.
То есть я смог сделать так, чтобы во всех вершинах дельта встала в нормальном интервале
плюс минус 1 или 0.
И так мы сделаем во всех возможных случаях.
Здесь я предположил, что дельта от a равна минус 2 и дельта от b равна нулю.
Сделал такие предположения.
Ну и теперь давайте рассмотрим все остальные случаи и поймем, что тоже как-то можно так хитро
попереворачивать с сохранением им варианта дерева поиска, чтобы в результате у нас все дельты как бы сбалансировать.
Все дельты стали плюс минус 1 или 0.
Остается нам сейчас пара случаев, давайте я их тоже нарисую.
Мы остаемся в предположении, что дельта от a равна минус 2.
И теперь рассматриваем случай, когда дельта у права сына это минус 1.
Давайте я нарисую опять картинку.
То есть все то же самое, только мы меняем дельта от b, стал равным минус 1.
Решение остается, мы поворачиваем вдоль этого ребра справа налево.
Тогда у меня опять b станет новым корнем, у него есть сын a маленькая,
у него есть сына b большая, и у корня есть также сын c.
Теперь опять то же самое делаем с глубинами.
Здесь была исходная глубина h.
Здесь была глубина h минус 3, здесь h минус 1.
Потому что раз дельта от a минус 2, то соответственно справа должно быть максимальная, а слева на 2 меньше.
Здесь h минус 1.
Теперь раз дельта от b минус 1, то значит у него правый сын больше, чем левый, ровно на 1.
Поэтому здесь h минус2, здесь h минус3.
Мы опять проставили глубину всех подделLOL.
Копируем их сюда.
Значит h минус3, h минус3, h минус 2.
Теперь что такое глубина a?
У него есть два сына, оба имеют глубину h минус 3,
поэтому здесь глубина становится h минус 2.
И у b-шки тоже, у него есть два одинаковых сына, одинаковой глубины.
Поэтому глубина здесь становится h минус 1.
И дельты в итоге обе занурились. Здесь стала дельта равна нулю, потому что левый и правый сын имеют одинаковую глубину.
И здесь тоже дельта равна нулю, потому что левый и правый сын имеют одинаковую глубину.
Такая магия, что просто такие вот повороты в таких-то случаях работают.
Нам осталось разобрать кейс, когда дельта от а равно минус двойке, а дельта от b равно единице.
Давайте сейчас разберемся с этим. И на этом в принципе разбора вея-дерева можно считать будет оконченным.
Потому что алгоритм будет такой. Мы подвесили там, то есть когда обрабатываем инсерт какой-нибудь или рейс,
ну подвешиваем или удаляем вершинку ровно так, как делается в наидном алгоритме.
Потом у нас что могло испортиться? У нас могло на плюс-минус один какие-то глубины испортиться.
Вот как раз на том пути, по которому мы шли.
Тогда давайте просто пройдемся снизу вверх и все вот эти дисбалансы устраним.
Устраним там нужными поворотами, устраним все дисбалансы.
Вот как мы сейчас делаем. То есть есть какие-то повороты, которые возвращают дельту в отрезок плюс-минус один или ноль.
Но если мы так сможем сделать всегда, то мы так пройдем снизу вверх до корня, как-то там попереворачивав дерево,
таким образом, что опять станет корректно вея-дерево. То есть все дельточки станут хорошими.
И у меня не будет никаких конфликтов, это будет правильно в Эльдии.
Вот. Ну хорошо, давайте значим.
Ссылки на родителя.
Ссылки на родителя. На самом деле это не обязательно.
А, сейчас. Ну окей, так удобнее. Да, согласен. То есть можно хранить ссылки на родителя, так будет удобнее, действительно.
Чтобы подняться вот так снизу вверх, можно действительно хранить просто ссылку на родителя. Да, можно так.
А можно, в принципе, просто...
Ну мы же, по сути, если писать код, то мы там, возможно, напишем какую-нибудь рекурсию, в стиле спустись в левый под дерево, там все перестрой.
И, по сути, у меня возвращение, возврат, он будет сам из рекурса делаться.
То есть вместо того, чтобы брать родителя, я буду просто отказываться в рекурсе.
Кажется, здесь даже это не обязательно делать.
Итак, давайте разберем в случае, дельта равно двойке, а дельта равно единице.
Когда здесь решение такое?
Здесь решение такое. Так, минус двойки только.
Ой, ой, ой, ой.
Минус двойка, а здесь единица.
Тогда, значит, я рисую опять левого сына, у него есть правый сын.
Дальше, раз дельта равно единице, то у него получается левый сын глубже, чем правый, на один.
Поэтому левый сын как минимум есть. То есть здесь есть фишенка С.
И у нее опять тоже есть какие-то поддеревья, давайте их назову B, C и D.
Давайте расставим где-нибудь глубины, если здесь была H.
Так, вопрос.
Ой, ой, ой, длинный вопрос.
Да, конечно, мы используем, что инсерт не сделает модуль дельты больше двух.
Но, смотрите еще раз, представьте, что у вас было изначально корректно в L дерево.
И вы сделали один инсерт.
Тогда что поменялось? Ну, понятно, что вы сделали один инсерт.
Но если до этого все дельты были плюс-минус один или ноль, то теперь дельты, самое худшее, что может стать, это дельта стала плюс или минус два.
Потому что у вас все H в худшем случае увеличились на единичку, значит дельты стали максимум плюс или минус два.
Поэтому никакие другие случаи нам не нужны.
Ну, еще раз, вы не забывайте, что у вас исходно было корректно в L дерево.
То есть мы храним корректно в L дерево.
Потом делаем инсерт и быстро, сразу же исправляем сетиз баланс.
Сразу исправляем сетиз баланс.
Оно станет корректным L деревом.
И значит все, что было по дороге, это вот, ну, худший случай, когда дельта была плюс или минус два.
Вот мы сейчас разбежаемся с минус двойкой.
Итак, значит, если здесь было H, то слева H минус три, справа H минус один.
Раз правой, глубже лево на два.
Дальше.
Ну, вот это все.
То слева H минус три, справа H минус один.
Раз правой, глубже лево на два.
Дальше.
У вершинки B левой, глубже права на один.
Поэтому здесь H минус два, здесь H минус три.
Ну, а здесь непонятно.
Здесь есть какие-то два поддерева.
У них глубины H минус три или H минус четыре.
Потому что у этой вершинки C, ну, дельта, это плюс, плюс минус один или ноль.
То есть C мы считаем, что сбалансировано.
У нее дельта равна, дельта хорошая.
Ноль или плюс минус один.
Тогда глубина вот этих вершин B и C, деревьев B и C, это H минус три или H минус четыре.
Тогда здесь работают следующие три подвешения.
Можно сказать так, что мы сначала вращаем в эту сторону относительно этого ребра,
потом в эту сторону относительно этого ребра.
В итоге результат вращения будет такой.
Ну, либо можно просто сказать, что мы делаем такое преобразование из дерева.
Сейчас я все нарисую.
И на этом мы заканчиваем.
B, C, D.
Короче, можно все так преподвесить.
И легко заметить, что опять-таки вариант сохраняется.
Вариант дерева поиска сохраняется.
Значит, это тоже все легко проанализировать.
Ну, либо сказать, что там каждый из этих поворотов, очевидно, сохраняет вариант.
Мы доказали чуть выше.
Ну и так мы, по сути, здесь делали два вот таких поворота.
Либо просто аккуратно все рассмотреть и понять, что здесь никаких конфликтов не возникает.
Ну вот, например, у нас теперь B, это правый сын A.
Ну и раньше B лежало в правом под дереве А.
Поэтому все хорошо.
И так далее все соотношения сохранятся.
Теперь что с глубины?
У больших наших деревьев глубины не меняются.
Здесь h-3, h-4.
Вот здесь у D глубина h-3.
Тогда смотрите, у A глубина в любом случае h-2 вне зависимости от того, какая глубина у B.
То есть там либо h-3, либо h-4.
Но понятно, что максимум все равно равен h-3.
Значит, здесь глубина h-1.
То же самое здесь.
У нас есть глубина h-3.
Есть глубина h-3 или h-4.
Но тогда в любом случае здесь h-2 встает.
И здесь h-1 встанется.
Что с дельтами?
С дельтами все хорошо.
Здесь дельта это либо 0, либо 1.
Потому что левое под дерево всегда больше, чем правое.
Ну, либо равно, либо больше, чем правое.
Здесь дельта это либо 0, либо минус 1.
Потому что левое может быть меньше, чем правое.
Ну, а здесь дельта это просто 0.
Дельта просто 0.
Все. То есть мы получили, что если вот это выполняется, что дельта стала равна минус 2,
то вне зависимости от того, какой дельта у правого сына, плюс-минус 1 или 0,
ну, потому что там все корректно, по предположению.
Какой бы здесь ни было дельта, мы всегда можем сделать 1 или 2 поворота,
так, чтобы во всем этом под дереве уравновесить все дельты.
То есть так его переподвесить, чтобы это было корректно.
Ну и дальше просто поднимаемся снизу вверх.
Каждый раз, когда встречаем плохую дельту, делаем одно из таких преобразований,
чтобы у меня все дельты в этом дереве перебалансировались.
Если дельта это равно 2, то то же самое все, только оно зеркально отраженное.
То есть когда дельта это равно 2, у меня, наоборот, левое под дерево более тяжело, чем правое.
И поэтому мне нужно все вот эти вот картинки как бы зеркально отразить.
То есть, наоборот, нужно поворачивать не правого сына, а левого сына.
Не внука там такого-то и такого, а наоборот.
В общем, это все просто делается в случае, когда у меня...
Сейчас, торможу.
То есть это просто зеркально отражение.
Ну и все, мы с вами все в общем-то сделали.
Мы разобрали все случаи, как нужно вращать, и тогда мы в общем-то любые дисбалансы можем устранить.
И тогда инсерт и рейс, если вот так все поворачивать аккуратно,
то получится, что мы будем сохранять агаритмическую глубину нашего дерева,
а значит на каждый запрос мы отвечаем за логарифт.
Все, я на этом тогда заканчиваю. Если есть вопросы, то пожалуйста, задавайте.
Нужно будет вот эти повороты делать рекурсивно, потому что у нас типа глубина снова изменится,
и вершины более высокой вершины могут измениться.
Да, конечно, нам нужно будет идти вверх, понимать, как изменилась здесь аж, и идти наверх, и там делать поворот.
Да, у нас поворотов может быть много.
А получается, когда дельта от Б равна нулю, там у нас не менялась глубина, и тогда не нужно идти вверх.
Сейчас, одну секунду.
Дельта от Б равна нулю когда? Ну вот там аж и аж.
Нет, нет, посмотрите. Надо всегда идти вверх.
Что значит, что у вас сейчас глубина аж?
Это в частности может означать следующее.
У вас раньше была глубина аж минус один, но вы подвесили какую-то вершинку сюда, и стала глубина аж.
И раз она здесь не изменилась, то она осталась на один больше, чем раньше, и значит вам нужно все равно идти вверх.
Возможно, вот здесь вот это дерево перекособочное, у него один сценарий более глубокий, чем другой.
И вам нужно все равно идти вверх до тех пор, пока все не устранятся.
Из-за одного, отвечая на вопросы из чата, как быстро считать дельту?
Можно просто в каждой вершине хранить аж от В, хранить глубину под дерево.
И вот мы здесь описали, как все эти ажки пересчитываются.
То есть каждый из этих поворотов мы поняли, как меняется аж в каждом под дерево.
Но раз мы знаем аж, то мы знаем, что дельта просто разный сценарий.
И соответственно, мы поднимаемся вверх, знаем аж слева, знаем аж справа.
Тоже знаем, как меняется дельта в каждой вершине.
На семинале будут разобраны случаи, как рассматривать ситуацию с листьями.
Там же будет чуть-чуть посложнее, потому что там глубина листьев с ней посложнее будет.
То есть мы заходим в лист, увеличиваем глубину этого дерева, этого листа, подвешивая к ему новый элемент.
Дальше нам нужно будет от этого листа вызвать первый поворот, если там нарушилось соотношение.
Нет, тут нет никаких особых случаев.
Смотрите, вот была у вас вершинка какая-то, и вы подвесили сюда, например, левого сына.
Был Y, вы подвесили X.
Что стало?
Здесь увеличилась аж отель, увеличилась на единицу.
Тут нет никаких особых случаев.
Рассмотрим вот это текущее под дерево.
Оно как-то изменилось по сравнению с тем, что было до этого.
Аж отель выросло.
Смотрим на дельту здесь.
Если дельта это плюс или минус двойка, то нужно сделать один из двух поворотов.
Тем самым мы убьем дисбалансы все вот здесь.
Потом поднимаемся в родитель этого дерева.
Мы знаем, какая глубина у этого под дерева.
Значит, знаем, какая глубина у этого под дерева.
Знаем, какая там дельта.
Если это плюс или минус двойка, то делаем один из двух поворотов.
И так далее поднимаемся вверх.
Тут нет никаких особых случаев.
И даже для листика подвесили.
Сразу просто запускаем одну и ту же процедуру для вот этой вершинки.
Просто вот этот поворот, если нужно.
Ага, спасибо, понятно.
Доску могу скинуть, да.
Так, вот этот слайд, кто просил?
С другими случаями дельта 1? Нет.
Дельта 1 у меня...
Мы это дерево...
Мы храним типа как указатели просто на детей.
То есть мы как бы структуру заводим.
И у нас там просто есть...
Да, ссылка влево, ссылка влево.
Так, и вот дельта 2 равно единице.
Почему это вращение?
Ну, это такое...
Это не... неформальное объяснение.
Ну, грубо говоря, вот представьте, да, значит...
Что мы делаем?
Есть А, есть левый сын, есть Б, есть Б большой, есть С большой.
Я хочу вот так вот провернуть вокруг этого рябра.
Ну, тут сложно без как бы показывания руками что-то сделать.
Ну, вот представьте, что у вас эта штука, это какой-то шарничек, который можно двигать.
А это там, не знаю, какие-то шарики.
А А маленькая, Б маленькая, это какие-то шарики.
Вот представьте, что у меня есть шарики.
То есть вы его просто повернули, как бы подняли Б.
А А как будто бы оставили на месте.
Тогда шарнир у вас выглядит вот так.
Значит, дальше что происходит?
У вас А большое остается слева, С большое остается справа.
Теперь только вопрос, что происходит с Б.
Ну, вот Б мы как бы отрезаем отсюда, потому что...
Ну, он же не может отсюда дальше расти, потому что начались будет степень 3.
Ну, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то.
То есть, по сути, это просто вращение как бы отрезка, вращение такого шарнирчика.
И еще переподвешение одного из подделев.
Переподвешение Б большого к А маленькому.
