О чем у нас была прошлая лекция, кто помнит? DFS, а до этого BFS. Но сегодня мы будем продолжать
DFS. Я надеюсь, вы его плюс-минус поняли, сможете его применять и с ним работать.
Сегодня мы увидим еще одно применение на самом деле DFS, хотя само по себе все будет
называться как топологическая сортировка. Работа с этой сортировкой. Посмотрим,
что она вообще умеет делать и для чего она нам вообще нужна. Вот какие задачи может
решать вообще топологическая сортировка. Ну представьте примерно следующее. Вам нужно построить
какой-нибудь автомат, грубо говоря, действий для того, чтобы получить какой-то результат.
Вот вы складываете, не знаю, пять чисел. Какие числа вначале будет складывать? Сначала, с конца.
От скобочек. Ну вот скобочек нету. Неважно. Хорошо. Вот. А если с точки зрения плюсов,
типа вот вы как будете это делать? С конца. Вот. Ну грубо говоря, вам нужен какой-то понятный
механизм того результата, как вы будете это все находить. Вот. Может быть, не знаю, вы любите
играть в игрушки, и вам необходимо открывать какие-нибудь новые уровни для того, чтобы у вас что-то
новое открывалось. И там тоже есть какая-то своя зависимость между всеми объектами, которые есть.
То есть, у вас есть какое-то первоначальное условие, к которому вы должны перейти. То есть,
если мы сопоставим вот эту вот зависимость в виде каких-то ребер, то мы получим, что у нас из более
младших таких вот элементов должно переходить что-то в более старший. Это касается там и результата
в каких-нибудь вычислениях, и касается вот, не знаю, в Minecraft давно играли или нет. Вот. Но я давно.
Ну была у нас такая тема, да. А когда во время сессии уже делать нечего, вот. Делали свой сервак.
Ну короче, да, для того, чтобы там чего-то достичь, вам необходимо там создать какие-нибудь
первоначальные предметы, после этого из них что-нибудь еще сделать и так далее. Вот. Это все
некоторые зависимости сами по себе, которые вы можете выстраивать в, представить в виде какого-нибудь
графа. И вот вообще, топологическая сортировка, это первое, с чем мы сталкиваемся, это сортировка
для ациклического графа. Это не совсем сортировка в том понимании, которое вы представляете.
Сортировка, которую мы до этого делали с вами. Топологическая сортировка хочет сделать
перестановку ваших вершин таким образом, чтобы фактически все ребра в вашем графе шли слева
направо. То есть у вас не было никогда ребра справа налево. Поэтому топологическая сортировка
чаще всего делается для ациклических графов. Потому что если вдруг у вас есть цикл, то у вас
обязательно будет ребро назад. Иначе как вы шли по этому циклу. Поэтому здесь важно понимать,
что эта сортировка нам поможет вот изобразить, грубо говоря, какую-то последовательность действий,
от которой будет начинаться. И мы понимаем, что дальше от нее что-то будет зависеть. Естественно,
из определений топологической сортировки мы получаем таких перестановок может быть вообще
сколько угодно. Ну не бесконечное число, у нас все-таки количество вершин ограничено. Но точно больше
одной, к примеру, для большинства графов вы найдете. Для цикличных графов. Поэтому топологическая
сортировка может быть в любом виде. Главное, чтобы у вас те самые ребра шли слева направо.
Вот здесь вот у нас изображен небольшой граф. Видите, как он здесь сделан. Ну и грубо говоря,
из 4 у нас выходит только два ребра в 0 и 1. Из 2 у нас выходит ребро только в 0. Из 0 в 0 входит
4 и 2, поэтому они находятся левее. А вот из него выходит ребро в тройку. Ну аналогично про единицу
и тройку можно сказать. То есть фактически мы взяли, расположили как-то вершины, сказали,
что это есть наша топологическая сортировка. Да. А для какого из графов? Для цикличного? Да.
А в плане ориентированно-неориентированный граф, грубо говоря? А это уже тогда цикл.
То есть если у нас есть вершины, есть вершина, которая одна сюда, одна сюда, то это все-таки цикл.
Вот. Поэтому для ориентированного графа делаются логические сортировки, где у нас нет тех самых циклов.
Окей. Если у вас вдруг есть петля, это тоже цикл. А понятно сама суть, что здесь хочется сделать?
Отлично. Каков план нахождения данной топологической сортировки? Вот здесь вот он написан, что мы
просто берем, запускаем DFS, ну и в принципе все. Давайте с вами разбираться, а что у нас может
происходить на каждом из этапов DFS. Представим следующую картину. Вот мы идем нашим DFS,
только первый раз запустили. Я пришел в какую-то вершину, из которой я никуда не могу прийти.
Ну то есть это вот эта самая последняя вершинка, не знаю, какая-нибудь X, из которой я не могу
никуда пойти дальше на моим DFS. Что означает, что не могу никуда пойти дальше? Почему?
С точки зрения DFS, а что означает, что мы в вершине никуда не можем пойти?
Не совсем. В какие вершины можно смотреть данное? Только в черные, не в серые. Вот это вершинка X.
У меня DFS на ней заканчивается. Ну то есть не заканчивается, он не может продвинуться дальше,
он должен будет откатываться. Что это означает для вершины X? Что мы можем на ней сказать?
Нет белых. Что это по факту означает? По факту означает, первый вариант, что у нас просто нет
ребер. Согласна? То есть она просто конечная сама по себе. Второй вариант какой? У нас есть ребров
в серую вершинку и третий вариант у нас есть ребро в черную вершину. Возможно ли второй-третий
вариант? Почему? Потому что граф ациклический. Отлично, то есть второго варианта в принципе не
существует. Третий вариант здесь возможен? Это первый запуск DFS. В первый запуск DFS ничего не
может такого произойти. Вот это вот первая вершина, где зашел в тупик. У нее нет ребер.
Значит в серую мы прийти не могли, черных еще не существует. То есть я когда шел по моему DFS вот
эти все вершины стали серые, остальные остаются белыми, а вот эта вершина просто у нее нет ребер.
Окей, понятно почему? Встали в тупик. Ну это первая итерация, где мы встали в тупик, да. Вот,
поэтому грубо говоря, если я положу это в конец моего списка, ничего не произойдет. Согласна? Ну
потому что из нее нет вершин, но окей. Теперь я перейду к соседней вершине и скажу, что тут
я дошел до новой вершины Y. Какие вершины она может смотреть? Какие у нее случаи есть из этих всех?
Черное отсутствие ребер. Если у нас отсутствует ребра, я положу ее вот сюда,
ничего не произойдет. Правда? Ну плохого для моей этапологической сортировки. А если у меня
были ребра в черной вершины, что может быть черными вершинами? Только та X, которая у нас есть.
И так далее. То есть вот раскручивая вот такой же механизм, мы с вами получим, что если мы кладем
просто вершинки вот в таком формате, грубо говоря, push front делаем постоянный, но в действительности это
не очень хорошо. Просто будем делать push back, потом reverse. Если мы делаем в таком вот виде, то у нас
ребра будут смотреть только вот в ту сторону. Серых ребер из белого в серое не существует,
существует только черные вершинки. Черные вершинки мы уже все просмотрели, все хорошо. Понятно?
Вопросы? Вот. Благодаря этому мы с вами получим некоторый массив, и он будет топологически
отсортирован. Вот и все. Это план того, как это выглядит. Фактически это называется алгоритмом
тарьяна. Все, что здесь происходит. Вот у вас есть здесь топсорт DFS. Что такое топсорт DFS? Ну,
фактически это тот самый DFS. Единственное, что там добавляется, что если вдруг мы нашли с вами
серую вершину, то в этом случае мы делаем false. Почему? Потому что мы нашли цикл. Мы нашли из белой
вершины в серую. Значит, у нас появился цикл. С циклами мы работать не будем. Вот. И дальше мы с
вами просто push-batch-им наши вот эти топсортed вершинки. В массив топсортed. И в конце мы делаем
просто reverse. Вот и все. В начало закидывать, тогда вам использовать нужно что? Дек. Правильно или
использовать дек? Какой лист? Ну, здесь это написано листом, потому что это написано на
питоне. Фактически для вас вектор. Что лучше, дек или вектор? Задача. Ну, у нас никакой здесь
инвалидации сывок не бывает, инвалидации итераторов не бывает, поэтому можно и запить. Вот. Да,
в действительности как бы здесь можно просто взять, развернуть, все здесь получится. Вот.
Алгоритм Тарьяна достаточно понятный, простой и работающий. За сколько работает? Ну, фактически
это время работы DFS. Да. Он работает за столько, за сколько DFS. DFS работает за O от V плюс E в случае
если мы делаем на чем? На списках смежности. А если на матрице смежности? В в квадрате. Хорошо.
Давайте вспоминаем прошлую лекцию и работаем с этой. Окей. Давайте докажем, что это корректно.
Есть какие-нибудь идеи, как это можно сделать? Очевидно, что люблю такое. Нет,
действительности это не совсем так. Ну, первое утверждение относительно циклов. Мы с вами знаем,
что если мы найдем с вами из белой вершины в серую, то мы находим цикл, все он выводит false,
алгоритм корректен. Согласны? Вот. Пусть циклы нет, тогда, да, действительности по индукции
покажем, что у нас нету ребер, которые идут с права налево. Вот. Изначально он пуст наш
массивтик топ сорта, значит у нас все хорошо. Пусть на каком-то очередном шаге мы с вами
положили какую-то вершину V и вот здесь вот у нас уже есть какие-то там вершинки. Отлично. У нас
для этих всех вершин мы точно знаем, что у них там ребра идут только справа налево. Ну как не так?
Вот. Чудно. Какие все вот эти вершины? А? Черные сами по себе, да? Значит, мы их уже рассмотрели.
А из черной вершины мы не могли прийти никак V, потому что иначе бы мы это сделали, она белая.
Значит, иначе бы у нас был путь к ней и тогда бы DFS не заканчивался сам по себе. Значит,
у нас никакого ребра справа налево нет. Понятно механика рассуждений? Смотрите. Данная вершина
V, когда мы ее кладем, она какого цвета должна быть? Когда мы кладем ее, она уже черная. Вот. Но до
этого момента она была там серой, а мы знаем, что из, что мы в серую вершину прийти просто так
не могли. Правильно? Это первое. Второе. А если бы у нас было ребро в обратную сторону,
что бы это означало? Мы из черной пришли в серую. А у нас вообще такое возможно? Нет. Кроме того,
если бы у нас была обследована сама по себе вершинка, то мы бы ее должны были закинуть в DFS и
не заканчивать с той вершины, которая здесь. Понятно механизм? Вот. Все просто. Правда? Коррекцион
алгоритм. Хорошо работает. Вот это является как раз таки топологической сортировкой. Вопросы
к ней есть? Что такое лучший вариант? За E плюс V. А как еще ты хочешь быстрее найти
топологически? Ты можешь быстрее, чем за V это сделать? Точно нет. У тебя все-таки V вершинок.
Вот. А ты можешь сделать это быстрее, чем за E? Нужно ребра посмотреть хотя бы. Вот. Как-то так.
Окей. Переходим с вами к компонентам сильной связанности. Эта тема непрерывно тоже связана
с топологической сортировкой со всем DFS, что у нас вообще есть. И мы с вами будем это смотреть.
Что такое сильная связанность? На всякий случай напомню с прошлой лекции. Ориентированный граф сам
по себе называется сильным связанным, если из любой вершины существует путь в любую другую вершину.
Вот. То есть мы с вами смотрим, что у нас есть путь из вершины V в U, из U в V, к примеру, и так
далее. И компоненты сильной связанности в графе называются максимальные по включению сильно связанные
под граф. То есть мы взяли оттуда все ребра, взяли все вершины, которые можно. Вот. Выбрали
необходимую нам компоненту и смотрим. Ага. В этой компоненте мы можем от одной вершины добраться
до любой другой. И так далее. И вот это является компонентой сильной связанности. Вот. В данном
графе. А как вы думаете, что будет являться компонентой сильной связанности? Давайте я его
пририсую. Смотрите. Давайте по чуть-чуть. Вот это является компонентой сильной связанности? Да.
Потому что я из любой вершины, вот здесь у меня цикл появляется, все хорошо. Они между собой связаны,
я от одной вершины к другой могу сделать. Могу ли я добавить в эту компоненту еще что-нибудь? Нет.
Из этой компоненты все ребра выходят, в нее войти нельзя. Грубо говоря, добавлю я шесть,
я из шести не могу прийти к нулю. Вот. Добавлю пять из пяти, не могу прийти к единичке. И так далее.
Поэтому это максимальная компонента, которая у меня сейчас есть. Вторая компонент это три-четыре.
Согласна? Они тоже цикличные, друг к дружку ходить умеют. Добавить сюда шесть я тоже не могу,
потому что из шести я туда попасть никак не могу. Нет обратного ребра. Поэтому у меня еще шесть и
пять. Поэтому в этом графе четыре компоненты связанности. 0, 1, 2, 3, 4, 6 и 5. Ага. Понятно,
как выглядит компоненты связанности? Вот. Это и есть то, что нам необходимо. Как мы будем с ними
работать? А мы будем работать с ними через конденсацию графа. Что такое конденсация ориентированного
графа? Вот эта полная компонента сильной связанности, грубо говоря, сжимается до одной такой большой
вершинки, назовем это так. Поэтому здесь мы с вами... Осторожно. У нас есть компоненты А, в которые
лежат вершины 0, 1, 2. У нас есть компоненты В, которые лежат 3, 4. У нас есть С и у нас есть Д. Здесь 5,
здесь 6 вершин. Вот. И дальше мы смотрим лишь на те ребра, которые лежат между этими компонентами.
Мы не смотрим внутри. Почему? Почему нам не интересно внутри? Потому что в этом случае у меня от любой
вершины можно добраться к любой вершине. Вот эта компонента мы просто сжимаем. Такое вот моментико.
И с вами получаем здесь что? Что из А можно в В, можно в С, можно в D, а из В в С. Всё. Вот. Это
называется конденсацией графа. Поэтому просто мы вот объединяем вот необходимые нам компоненты,
формируем их и получаем то, что нам нужно. Вот это есть такая штука. Понятно с конденсацией?
Хорошо. А утверждение? Конденсация графа нет циклов. Почему? Иначе бы они были в одной компоненте
связности. Да. То есть если мы допускаем с вами, что цикл у нас есть, то из одной вершины одной
компоненты можно добраться до любой другой вершины другой компоненты. А значит это всё должно быть одной
большой компоненты сильной связности. А компоненты сильной связности, она максимальная по включению
этих вершинок. Противоречие мы получаем с вами здесь, которое у нас есть. Так что да, у нас нет
никаких циклов. Ага. Вроде это понятно. Правда? Чудно. И вот здесь, и вот здесь, у нас будет
применение той самой топологической сортировки, вот эта вот лемма, которая нам понадобится в
дальнейшем. Звучит она так. Давайте будем партией с вами слова, и вы должны объяснить,
смысл её или нет. У нас A и B компоненты сильной связности в графа G. У нас есть ребро какое-то из
A в B. Если мы запустим алгоритм топологической сортировки на графе G, но без проверки на цикличность,
то найдётся какая-то вершина A, которая будет располагаться любой другой вершины из B.
Смотрите, суть какая. Да, у нас есть A, и здесь есть какая-нибудь маленькая вершинка A. У нас есть
какое-то ребро из A в B. Вот. И в этом B у нас тоже какие-то вершинки есть. В чём суть? Суть в
следующем. При топологической сортировке, забивая на циклы сами по себе. То есть,
если мы не будем делать return, то есть в каком-то виде всё равно топологическая
сортировка сработает и покажет нам какой-то массивчик. Согласны? Ну, может, правильно,
может, нет. Будем смотреть. Вот. А что происходит в этом случае? Происходит следующее, что у нас
вот эта вершина A, которая находится в A, она будет лежать левее, чем вот эти все вершинки. Возможно,
там ещё какие-то добавляются вершинки, не суть важна. Но лежит левее, чем все вершины из B.
Вот это там B1, B2 и так далее. Понятно? Вот что подразумевает эта лемма. Если это лемма,
то, наверное, это правда. А кто представляет, как это можно доказать? Ну, сутьевая часть правда. На
самом деле, вот примерно такой логики я всегда и придерживался здесь. Что важно, если мы берём с
вами вершину A какую-то, у нас DFS для всего графа A и B не обязательно самый первый, где идёт DFS.
Какие два варианта есть? Первый вариант, я захожу DFS в A большое, второй вариант, я захожу DFS в B
большое. В случае первого варианта у меня есть маленькая вершина какая-нибудь, не знаю, вот здесь
вот лежащая, и для неё это первая вершина из A большого, в которую я зашёл в DFS. То есть это прям первая
вершина, для которой это существует. Я в неё захожу. Все остальные вершины из A и B какие цветом?
Белые. А что нам говорит Лемма о белых путях?
Кто говорит Лемма о белых путях?
Почти. Ну, по сути, своя да. То есть если у нас есть какой-то белый путь сам по себе,
то мы обязательно это сделаем в нашем DFS. У нас все вершины белые. Значит, я все вершины
B посещу. Согласны? Они станут чёрными, потому что они внутри вот здесь существуют. Когда мы
зашли в эту вершинку, то она будет левее. Понятно? Потому что из неё мы ещё не вышли. То есть из неё
я точно могу добраться до всех вершинок B. Они там вместе все станут чёрными. Я только потом вернусь
в A. Ясно? Да. Если мы начинаем DFS и зашли в A большое, в какую-то вершину A маленькая. Возможно,
обратная ситуация, когда я захожу в B. Вот смотрите, я зайду в B. Я его весь по Лемме о белых
путях пройду. Правильно? Положу куда-нибудь в топологическую сортировку. Могу ли я попасть
куда-то в A? Нет, у нас нет ребра такого. Значит, потом когда-нибудь я зайду в A. Но если я потом
когда-нибудь зайду в A, то оно будет, естественно, лежать левее. Логика такая. Это и есть доказательство
этой Леммы. Само по себе чуть более формально описанное. С тем, что мы объединяем множество
A и B, смотрим, какую вершину там встретили, вот эту вершину A и так далее. И как бы здесь мы с вами это
все делаем. Так что как-то так. Доказательство понятное? Вопросы есть? Не обязательно есть путь.
Если что-то лежит слева и справа, то нет. И слева никогда не всегда есть путь вправо. Окей?
Вопросов нет. Его понятно. Чудеса. Хорошо. Ладно. А что еще важно знать? Важно знать следующее.
Транспонирование графа. Что это такое? Транспонирование графа, это когда мы просто
перенаправляем с вами ребра. Берем это и переделаем, а вершина остается. Те же самые. Ребра просто идут
в обратном порядке. Скажите, все ли могут доказать эту лему? Внутри, как было из одной вершины в другую,
можно добраться. Так и осталось. Правильно? Вот. А вовне, ну как бы ничего не произойдет. Ну,
да. Так что да. Надеюсь, вы это самостоятельно сможете, если что, доказать на экзамен. Правда?
Какой-то нервный смех. Это не очень хорошо. Ладно. А какой же алгоритм вообще поиска компонент
сильных связанностей? То есть мы хотим найти все компоненты сильной связанности в нашем графе.
Алгоритм примерно следующий. Давайте я возьму, запущу DFS, построю топ-сорт. У меня будут расположены
как-то вершинки. Транспонирую граф и запущу DFS в том порядке, в котором они были в топ-сорт.
Начнем с вершины ровно в том порядке. То есть не с нулевой, грубо говоря, начинаем DFS, а с других.
Смотрите, у нас топ-сорт и не исток, и не исход. Давайте с вами сделаем на примере,
вы поймете, что я имею в виду. Хорошо? Вот этот же пример возьмем. С какой вершины хотите начать?
С третьей. Давайте с вами смотреть. С третьей я могу попасть в четыре, правильно? И с четыре
я могу попасть в шесть. Другого варианта нет. В шесть я остаюсь, у меня ничего не получается.
В шесть я записываю. А возвращаюсь в четыре. И с четыре я куда-нибудь могу попасть? Ну в три я уже был.
Ну а в серый вершины заново не захожу. Вот, поэтому никуда по сути еще попасть не могу,
только в белые. Поэтому четыре, три. Чудесно. Какую следующую вершину возьму? Пять? И с пять
я никуда не могу попасть, поэтому просто ее вношу. Хорошо, давайте дальше. Один из один в два,
из два в ноль, из ноль никуда. Вот эти все уже обработаны, они черные. Отсюда никуда не могу
попасть. Поэтому сюда ставлю ноль, потом два, потом один. Вот у меня топ-сорт. Согласны?
Я специально писал в ту сторону, а не в ту. Я не пушбэчил. Ну давайте на всякий случай. Из один в два,
из один пять. Кто там? Из нуля один есть, но это наш цикл как раз-таки, который нам будет мешать именно
для топ-сорта топ-сорта. Из два у меня есть в нолик, из два у меня есть в шесть, из три в четыре,
из четыре в три, из пяти никуда, из четырех в шесть. То есть у меня вот циклы только появились.
Но я пока забил на эти циклы, только они мне мешают для топ-сорта. Хорошо, разворачиваю все
ребра, которые у меня есть. Как будет выглядеть граф с развернутыми ребрами? Давайте нарисуем ноль,
один, два. Сейчас я нарисую, потом ребр проведу. Пять, четыре, три. Разворачиваю ребра, у меня получается
вот так, вот так, вот так, вот так, из шести вот так, четырех вот так. Ну а здесь остается то же самое.
А и еще вот тут. Развернул. И теперь я буду запускать DFS согласно той последовательности,
которой здесь есть. Я опять все говорю, что они все белые, эти вершины. Давайте запустим DFS единички.
Что сделает единичка в этом случае? Какие вершины? Ноль в два и все. Ноль в два и все. И в этом случае
я что получаю? Вот я запустил свой DFS и получил вот эту компоненту обязанности. То есть у меня
будет один, ноль, два. Первая компонент. Согласны? Что на третьем шаге происходит? Да, вот этот DFS
будет возвращать последовательств вершин. Ну вот один, ноль, два. Больше он никуда прийти не может.
Дальше. Что у нас есть еще? Дальше мы идем вот тут один, два, ноль. Мы уже были, правильно? Пять заходим.
Пять. Мы можем прийти только в черные уже вершины. Мы туда не заходим, поэтому остается
просто компонента пять. Согласны? Три, четыре. Мы идем в три. Смотрим, что из нее можно попасть в
четыре. И в ноль мы пойти не можем, потому что он уже черный. Только вернуться в три. Поэтому у меня
компонент получается три, четыре. Согласны? Ну и последний компонент будет шесть. Почему это работает?
Смотрите. Работает это примерно по следующей схеме. У нас с вами была конденсация графа.
Была вот такая вот конденсация. А мы, когда начали с вами, вот с чего мы там начали,
с какой вершины? С трех мы начали, к примеру. Мы с вами начали отсюда, пришли вот сюда,
смотрели, как эти компоненты связаны между собой. А теперь смотрите, если из компоненты,
я из какой компонент связанности мог прийти в какую-то другую? Только в случае,
если у меня были вот такие ребра. Согласны? Если я сюда так пришел, то вот эти компоненты,
где лежат относительно вообще моего существования, грубо говоря, в топологической сортировке? Слева,
справа, справа от вот этой. Согласны? Почти всегда. Вот именно эта лемма, которую мы с вами
доказали только недавно, говорит о том, что есть вершинка одна, что если у нас есть ребро,
то она в топологической сортировке лежит левее. Согласны? Есть такое. То есть, по сути своей,
если я с вами разверну все ребра, целютно все, то все вот эти связки B1, B4 и так далее,
они не смогут прийти в А. Никак. Я из А не смогу к ним прийти. Почему? Потому что я вот это ребро
разверну. А так как я иду слева направо, то я вначале найду эту вершину А, а только потом
компоненту B. Согласны? Потому что я все развернул здесь. А значит, я обработаю всю свою компоненту,
которая у меня есть. Потому что у меня как была здесь сильно связана, так и осталась. Согласны?
Вот суть примерно такая. Сейчас более формально с вами посмотрим. Но с точки зрения алгоритма,
ну как работает этот алгоритм. Ну это пофактически два DFS. Вы говорите, у нас есть colors,
у нас есть компоненты. Вот, а в этом вашем DFS вы просто смотрите, мы смотрим на белую вершинку,
запишем ее в новые компоненты связанности, все хорошо. Вот именно сам DFS. И чудесно. А с точки
зрения компоненты сильной связанности, вы сначала сделаете топ-сорт. Делаете топ-сорт,
смотрите какой у вас порядок. И в зависимости от этого порядка делаете ваш вот этот DFS. Вот этот
DFS он отличается вот тем, что у нас 4 way in order. То есть мы задаем определенный порядок, в котором
обходим все вершины. Вот и все. Ну как бы все понятно. Кого? DFS как сделать? Ну вот смотри,
у меня g.t написан. Транспонированный. Да. Вы когда будете делать задачки, на самом деле хранить,
хранить будете. Ага, еще вопрос. Сам алгоритм понятно написан? Окей. Время работы, ну как бы
v плюс e, 2 DFS, ничего страшного здесь нет. Корректность. Почему все это корректно? Ну смотрите,
по лемме 1 мы отсортировали компоненты сильной связанности топологически. То есть присутствует
вершина, которая лежит левее, чем правая. Вот возвращаемся ровно к тому, что мы сейчас говорили
с вами. Это первое. Оно отсортировано, все чудесно. После второго шага по лемме 2, напомню лемма 2 это
то, что мы с вами говорили, что в транспонированном графе у нас все компоненты остаются на своем же
месте. Остались у нас компоненты сильной связанности такие же. И вот на третьем шаге, когда мы уже с вами
развернули и делаем DFS, то по лемме 1 в начале ордер лежит вершина, которая принадлежит компоненту,
в которую после транспонирования, возможно, входит большинство ребер, но ничего не выходит. То есть
вот эта компонента, которая лежит в самом начале транспонированной графе, в нее все ребра только
будут ходить. Понятно? Поэтому там у нас ничего не происходит, мы только лишь по этой компоненте и
ходим. И по ленью белых путях мы все это прошли, всю компоненту поняли, как она выглядит. У нас все
вершины стали черными, все чудесно. Переходим к следующей компоненте и так далее. То есть мы
каждый раз это видим таким вот образом, что у нас в самом начале лежит компоненты, из которой все
выходит, но ничего не входит. А в следующий раз у нас будет компонента, в которую, быть может,
заходила предыдущая компонента, но не более. И все остальные вершины входят. Понятно? Ну то есть
из нее ребро входит. Вот так что это можно делать. Все это хорошо. Называется это алгоритм касараю.
Приятный достаточно алгоритм. Ага. Есть вопросы? Какие-то полумертвые. Чего такое? Март, весна, красиво.
Грустная история. Ладно, хорошо. В общем-то, это все, что касается топологической ассортировки и
компонент сильно связан. Надеюсь, теперь вы сможете решить эти задачки. Они достаточно просты,
ничего сложного в них нет. Еще про что хотелось бы сегодня с вами поговорить. Про эйлеровость.
Кто знает, что такое эйлеровграф? А вы все из мат-группы, да, или нет? Понял, принял, осознал. А? Да,
это правда. Каждое ребро необходимо обойти. Существует эйлеровый граф, полуэйлеровый граф.
Смотрите, что такое эйлеровпуть. Эйлеровпуть — это путь, в котором мы проходим по каждому
ребру. Полуэйлеровграф — это где у нас есть эйлеровпуть. Эйлеровцикл — это замкнутый эйлеровпуть,
то есть мы вернули в самое начало и можем это сделать. И тогда такой граф, в котором есть эйлеровцикл,
называется эйлеровым графом. Вот тот граф, который здесь представлен, ну каким является?
Точно не эйлеровым. Полуэйлеровым — да, но здесь это достаточно просто показать,
или не просто? Просто. Какой путь должен быть? Все верно. Да, то есть здесь мы с вами пройти
достаточно просто сможем, и это будет полуэйлеровграф. Какие есть критерии эйлеровости? Ну,
мы с вами говорим, что наш граф эйлеров, если он содержит не более одной компоненты связанности
с ребрами и степени вершины все четные, здесь граф, на всякий случай, неориентированный. Вот.
Я это подсвечу. Что подразумевается здесь под высказыванием, что у нас не более одной
компоненты связанности с ребрами? Возможно, ситуация примерно следующая. У вас есть
некоторая компонента, где у вас действительно лежат там какие-то связанности сами по себе,
там что-то происходит в этом графе. А тут еще вот такие вот обособленные просто вершинки без ребер.
То есть вот это все должно быть связано, а вот это вот может существовать. Окей? Если у
вас присутствует более одной компоненты связанности, то это не работает. Вот. И степень
всех вершин четная. Понятно? Просто знаете такое или не знали еще такое? Было? Где было?
Хорошо. Отлично. Вам от группы было? Мало ли? На всякий случай. А, в программе не было? Хорошо.
Ну в школе было, видимо. А, понял. Хорошо. Окей. Как это доказывается? Смотрите, ну в одну сторону
достаточно просто про эйлеровость. Что у нас есть замкнутый путь, если граф эйлеров, значит,
мы можем зайти в каждую вершину и выйти из нее. Значит, у каждой степени вершины четно. Ну и,
в принципе, все. И как бы все связано, потому что у нас есть вот этот вот обход по всем ребрам.
В обратную сторону мы просто построим алгоритм и скажем, что вот в этом случае все эйлерово.
Поэтому мы будем исходить из другого. Да, не бывает таких вопросов. Бывает в неориентированном.
Граф неориентированный в этом случае. Вот, что касается критерия полуэйлеровости. Она аналогична
эйлеровости, кроме одного, что у нас степень вершины всегда четная, кроме, быть может, двух вершин.
Начально и конечное. Все верно. То есть фактически вам говорят следующее. У вас вот есть какие-то две
вершинки, у которых там есть ребра, все такое. Вот у них нечетное. Как доказать, что в этом случае
вот это все полуэйлерово. То есть из полуэйлеровости там будет что-то следовать. Давайте соединим их.
В этом случае степень у всех вершин будут четные. У нас одна компонента связанности с ребрами.
Ну и в этом случае этот граф эйлеров. Выкинем вершину полуэйлеров. Понятно? То есть грубо
говоря, что значит эйлеровость? Что у вас есть цикл. Если я уберу это ребро, то у нас цикл перестанет быть.
Но мы дойти до этой вершины дойдем? Дойдем. То есть вы разомкнули эту цепь. Поэтому это все работает.
Понятно? Критерий полуэйлеровости понятен. Для ориентированных графов степень полузахода и
полувыхода они одинаковы. Для полуэйлеровости аналогично с тем, что было в эйлеровости. Здесь
вообще нет никакой разницы. Все очень просто. Это понятно? Все достаточно легко. Что здесь важно?
Как искать вот эту эйлеровость? То есть мы захотим построить эйлеров цикл. Но для начала нужно
проверить, что он подходит к необходимой нам со степенями вершины. Потому что без степени вершины
у вас будет проблема. То есть мы должны сначала проверить, что у нас действительно степень вершины
всех четная, если мы хотим проверить эйлеров цикл. Вот это первое. Дальше мы делаем рекурсивный
ДФС. То есть запускаем ДФС, потом еще ДФС, ДФС, ДФС. А что мы будем с вами делать? Мы будем делать
с вами следующее. Что мы будем помечать не вершины, а ребра. Мы раньше с вами ребра помечали,
теперь мы будем, о господи, вершины помечали в серые цвета и так далее. А здесь мы будем помечать
ребра. Если мы прошли по ребру, то его выкидываем. Просто само по себе. И под завершение обработки
всего этого мы добавляем ее в начало массива пути. Как бы все это хорошо, все это нормально, выглядит вот
так. Это не сложно. Это все, что нужно для проверки эйлеровой. Ну кроме того условия, что у вас степень вершины
корректна. И это поможет вам найти необходимые вам вершины. То есть это фактически тот же самый ДФС.
Просто вы не делаете ничего с точки зрения цвета. Вы добавляете здесь то, что вы выкидываете какие-то
ребра и запускаете ДФС заново. Рекурсивно просто идете с этим ДФСом. После этого у вас будет эйлеров
цикл. Да. Радить. Хороший вопрос. Это связано с тем, чтобы мы ребро правильно посчитали. То есть откуда мы
пришли в данную вершину. Иначе мы ребра не сможем считать. То есть у нас эйлеров цикл, он из чего
состоит? Он состоит из ребра. Ребра откуда, куда пришли. Вот. Вот видишь там push front написано и PV
вот это и есть ребро. Понятно? Вопросы есть? Нет. Вот так можно найти эйлеров цикл сам по себе. Почему это
корректно? Ну смотрите. Каждое ребро в массиве эйлеров цикл содержится один раз. Ну почему? Потому
что у нас алгоритм так выглядит, что мы выкидываем из V в U вершину. Из V в U ребро. Отлично. А в момент
выписывания ребра все степени вершин чётные. То есть вот я его когда записываю оно должно быть чётным. Почему?
Ставим следующую картинку. Вот у меня есть вершинка S. Вот я от неё хожу. Что-то там делаю. И вот я
могу здесь остановиться? Почему? Почему мой DFS здесь не может остановиться?
Вдруг? Нет. Есть.
Хорошо. Это мне нравится больше. Да, в действительности это так. Окей, это правда. То есть просто остановиться
здесь не могу. А зайти в другую вершину я мог? Вот так. Да. То есть у нас должно быть продолжение и
останавливаться весь у нас DFS только в случае S. Потому что у нас здесь когда мы вышли у нас степень
вершины была грубо говоря не чётная. Мы должны ещё до туда дойти, чтобы она была тоже чётная.
Значит у нас ничего работать здесь не будет. Поэтому в любой момент времени у нас в серебрах даже
когда мы их выписываем у нас всё должно быть чётным. Здесь вот написано более формально по
поводу того как это должно выглядеть, что здесь происходит, как мы это добавляем. То есть вот эти
вот серебры и так далее. Но суть опять же плюс-минус в том же, что у нас есть чётная степень и мы от них
отталкиваемся. Окей. Мы считаем критерии что да выполнены, поэтому мы ищем путь уже да.
Точнее не путь, а цикл. Вот чудненько мы говорим, что последовательность выписанных вершин образует
наш путь. Почему это правда? Сейчас ещё раз мы идём. Мы делаем от родителей к ребёнку. И чего?
Ну грубо говоря представим следующее. Вот мы выписываем ребра. X, Y, A, B, Z, T. Почему Y это A, Z это B?
Вернуть алгоритм?
Зваем рекурсию. То есть мы фактически идём по вот этому вот всему, вот этой вот всей части.
В какой момент мы вернёмся в вершину S? Хорошо, давайте так. Когда цикл найдёмся и здесь какая-то
вершина будет там. И добавим это всё. Теперь у PATS мы как могли тут ходить? Мы могли ходить вот
как-то вот так ещё. Согласны? Обязательно тоже бы в неё вернулись. И там должны были прийти ещё в PATS.
Мы там тоже ходили. И так далее. То есть если смотреть глобально, ну грубо говоря, мы когда из
любой вершины выходим, мы её прихватываем всегда с собой. Вот. И она формирует именно таким вот
способом путь. Вот. Что здесь подразумевается? То есть смотрите, мы выписали какое-то ребро УВ,
и в этот момент в степени вершины всех чётные. Мы с вами говорили об этом. И алгоритм продолжает
делать обход вершине У. То есть УВ мы с вами выписали. Вот У, он продолжает делать обход вот этой
вершинки PS, грубо говоря. И в следующий момент он должен всё равно вернуться в неё, иначе у него
ничего не получится. Поэтому он её выпишет в следующий. И так далее. И в зависимости от этого,
то есть будет формироваться вот такая вот путь сам по себе, которая обойдёт абсолютно все наши
ребра. Ну и как бы все эти утверждения складываются в одно большое и говорят, что наш алгоритм по
строению левоцикла правильный. Вот. Мы образовали некоторый путь. У нас всё чудесно. У нас каждое
ребро содержится один раз. И фактически мы с вами доказали вот этот вот критерий. То есть мы
отталкивали с того, что степень вершин у нас В, компонент среднесвязанности 1 с ребрами. И мы
показали, что есть путь, фактически есть цикл. Значит у нас всё хорошо. Понятно? Ну и последнее,
опять чуть раньше закончилось. Что ж такое? Это вообще беда. Грустная история. И последнее,
о чём бы я хотел с вами вам сказать. Кроме эйлеровости, что существует? Да, существует
гамильтонов граф, гамильтонов путь. Это всё. Кажется, задача очень похожа сама по себе.
Есть у меня некоторые нюансы. Вот. Кто-нибудь знает, какой? Да, это правда. А ещё? По сути
своей это правда. На самом деле задача о гамильтоновом пути, о гамильтоновом графе является ли
граф гамильтоновым? Это НП полная задача. НП полная задача означает, что она не решается
за полином. Всё правильно. Вот. А у неё нет какого-то эффективного алгоритма, считается само по себе,
поэтому это очень такая хитрая задача. И самое интересное про НП полные задачи, но я думаю,
где-нибудь вам это отдельно расскажут. НП полные задачи, они образуют такое семейство. Если вы
решите хотя бы одну НП полную задачу, то после этого вы решите все остальные. Вот. Вдруг у вас
получится. А вы сделайте сначала, а дальше посмотрим. Вот. Посмотрим, что это будет. В
действительности задача на поиск гамильтонового пути это проблема. Конечно же у вас будут
определённые условия на это всё. Шаг не подходит. Ой, с точностью это вероятностный алгоритм,
да, не существует, но не очень тут подходит тоже. Ты должен просто перебрать абсолютно всё возможное.
Вот. И в этом случае что-то заработает. Или не заработает, там же пойдёт. Поэтому, кажется,
задача похожая, задача одинаковая, а фактически одна решаемая, а другая не очень. Как есть.
А, в принципе, на сегодня всё. Если нет вопросов, вот. Хорошего вам вечера.
