В прошлой неделе мы должны были с вами поговорить про мосты точки сочинения, что это такое, как
вообще с этим работать и что происходит. На семинарах, я подозреваю, что практически вы
пописали что-нибудь, поделали, правда? Было что-то? У всех? А кто не ходит на семинары? Хорошо,
давайте там другой вопрос. В общем-то, что такое точка сочинения, кто из вас помнит?
Если убрать, то будет несколько компонент связанности. Да, то есть точка сочинения в
неориентированном графе g это будет вершина удаления, которая ведет к увеличению компонент
связанности. Это может быть их несколько точек сочинения, но изолированная точка, например,
никогда не приводит к нарушению связанности, поэтому изолированные точки никогда не будут
точками сочинения. Вот здесь на этом графе какая точка? 1, 3 и все, отлично. Да, вот, то есть мы
удаляем эту вершину, все ребра из нее, которые рядом с ней, тоже удаляются, поэтому у нас
получается вот такой вот механизм. Как вообще понять, что нам делать с точками сочинения? Ну,
предположим, что мы запустим какой-нибудь алгоритм DFS, вот, какой-то стартовой вершины,
и мы говорим, что это стартовая вершина, она будет точкой сочинения тогда и только тогда,
когда у нее будет несколько сыновей, один или более, а в дереве обхода, почему?
Ой, два или более, соря, два или более. Нет, смотрите, я запускаю DFS, вот у меня есть граф,
я запускаю в какой-то конкретной точке DFS, вот, и у этой конкретной точки несколько сыновей получается,
вот в дереве обхода мы, да, то есть смотрите, вот у меня раз, тут какой-то график, два, три,
вот так у меня граф, вот это стартовая вершина, с которой я запустил, вот это у меня получившееся
дерево моего обхода DFS, а если я его удаляю, тогда она является точкой сочинения, почему? Ну,
а в одну сторону достаточно все просто, если бы у меня был всего лишь один сын или вообще их не было,
тогда в этом случае как бы у меня компонента бы не нарушилась, она как была одна, так и осталась,
вот, ну сколько их было, столько осталось там внутри, если мы говорим с вами про несколько,
тогда они связаны у нас через, связаны через эту вершину, да, вот, ну как бы здесь все очень логично,
очень легко и очень понятно, то есть нам, если вот говорить чисто формально, то у нас есть лемма о
белых путях, мы DFS заходим только в белые вершины, значит у нас из белой вершины в белую любую другую
есть путь, и этот путь точно проходит через R, потому что иначе бы оно лежало в одном и том же,
ну под одним и тем же сыном, вот, значит этот путь проходит вот так или там вот так к соседнему,
поэтому здесь у нас как бы получается такой вот момент, что у нас это является точкой сочинения,
как бы оно в две стороны будет работать, вот, а предположим, что у нас не стартовая вершина уже,
стартовая вершина была R и мы рассмотрим какую-то другую вершину, в каком случае мы можем сказать,
что это является точкой сочинения, но это является точкой сочинения только тогда,
когда у нас существует какой-то сын УВ, если, ну и из этого У нельзя попасть в какого-то предка В,
что подразумевается здесь, ну смотрите, вот у меня есть какая-то стартовая вершина,
вот там вот как-то идет, у меня есть вершина У, есть вершина В, наоборот, наоборот сделаю,
вот, а что означает из У нельзя попасть в предка В, двигаясь только вот по рюбрам дерева,
то есть у меня нету чего-то такого, правильно, а из-за этого вот если у меня был здесь какой-то
путь, я не могу попасть ни к одному предку, который был выше, то что будет при удалении данной вершины,
ну чисто интуитивно, они разделятся между собой, то есть я не смогу из-за этой вершины подняться
куда-то выше, никаким образом, то есть у меня не будет никакого пути для того, чтобы подняться
вот сильно высоко, из-за этого при удалении данной вершины у меня вот эти останутся обособлены и вот
эти останутся обособлены, то есть у меня увеличится количество компонент связанности,
правильно, вот, но здесь мы говорим с вами, что мы двигаемся только по рёбрам и максимум одному
обратному ребру, вот, но как бы здесь ровно в этом логика и состоит, то есть у нас есть
некоторая вершина, у неё есть некоторый сын, вот, и мы от него смотрим, можно попасть как-нибудь наверх,
через вниз и обратно или нет, то есть вот мы можем куда-нибудь вот отсюда попробовать пойти,
если нет, то у нас беда, мы ничего не можем сделать, значит у нас получается больше компонент связанности,
понятно, что я говорю или есть какие-то вопросы к этому всему,
видимо, всё понятно, но теперь смотрите, у нас есть раз, есть два, у нас есть вот эти две теоремы,
останется их вместе соединить и тогда мы получим с вами алгоритм поиска точек сочленения,
нам нужно будет запускать алгоритм DFS из какой-то любой произвольной вершины,
дальше мы смотрим на саму эту вершину, если у нас в самой этой вершины есть хотя бы две соседние
белые вершины, то тогда R это точка сочленения, правильно, ну, то есть мы смотрим просто на
соседние, вот, а после этого мы смотрим на какую-то вершину U, ну, то есть мы проходимся по всем
вершинам и смотрим, у детей есть вариант подняться как-то наверх или нет, то есть выше
нашей вершины, если есть, то всё хорошо, это не является точкой сочленения, если нет,
то тогда это является точкой сочленения, вот, да, да, по первому пункту DFS запускаем из произвольной
вершины, по второму есть две белые соседние вершины от нашей вершины R, то есть это означает,
что у нас есть вот такое, да, мы должны вот это вот всё закрасить, вернуться и заново посмотреть,
вот, понятно, хорошо, по третьему пункту есть вопросик, его достаточно, то есть смотрите,
подразумевается следующее, вот у нас есть некоторая вершина V, у нас есть некоторая вершина U,
они связаны между собой, U является сыном V, вот они связаны здесь, и дальше вот здесь вот там
что-то находится, какая-то там, какое-то дерево, нам нужно понимать, если есть хотя бы одно ребро,
которое находится сверху, тогда в этом случае мы уже можем идти выше, вот, а почему говорят про
хотя бы одно ребро, потому что проверять будет легче, значит бесконечно может быть, для одного
ребра это достаточно, потому что, ну представьте, у меня раз ребро, два ребро, три ребро, четыре,
и потом отсюда, это очень долго проверять, одно обратное ребро понятно как проверить, быстро, вот,
вопросы? Нет вопросов, хорошо, вот, теперь вопрос, как нам быстро понять, что из ребенка U нельзя
попасть в какого-нибудь предка? Нет, а сколько будет работать этот метод? Приятное, вот, будем
работать бесконечно долго, хорошо, смотрите, в действительности, как бы, мы будем вводить
некоторое время, грубо говоря, время входа, время выхода из вершин, и вот время входа в вершину
оно будет позволять нам как раз-таки понимать, когда мы вошли в данную вершину, и куда мы можем
прийти дальше, то есть у нас будет некоторые такой тайм-ап, тайм-ин, вот, и этого будет достаточно,
вот некоторые меры глубины вниз у нас будет тайм-ин, то есть во сколько мы вошли, а когда мы будем
смотреть насколько мы можем подняться, мы просто смотрим насколько высоко мы можем пойти по этому
времени. Вот и все. То есть у нас будет таймин и таймап. Что такое таймин? А таймин это время,
когда мы заходим в данную вершину и мы можем остаться чисто в ней. А таймин бэк это как раз
таки подняться по обратному ребру в какой-то бэк. Вот и таймап сам по себе это вот спуститься по
дереву куда-то и после этого подняться оттуда. Почему мы можем говорить о том, что мы можем
посчитать таймап вот в этой вершине, например? У нас же DFS какой? Какая функция это? Рекурсивная,
то есть если мы посчитаем у детей, мы узнаем и у этого, правильно? Вот, а потому что мы будем
раскручиваться назад, поэтому здесь, когда мы будем поднимать насколько мы можем подняться,
мы здесь поймем тоже насколько мы можем подняться. Поэтому у нас есть как раз таки три варианта
что максимальное время насколько мы можем подняться, то есть, насколько высоко мы можем зайти,
это время когда мы зашли просто в эту вершину. То есть мы остаемся в ней listening у нас
можем из нее подняться куда-нибудь вверх то есть из вот этой вершины у предположим
что у нас есть некоторое такое вот ребро и вот мы по нему можем подняться и последнее
это вот таймап это как раз таки вот из детей сложить и понять насколько они максимум могут
подниматься здесь написано минимум ну что время это минимум почему потому что время входа у нас
чем ниже тем больше наша глубина понятно что я сказал отлично значит семинар у вас прошел не
зря это чудесно вот поэтому здесь в действительности как бы какие какие критерии для точек
сочинения но первое для корня обхода считаем что это точка сочинения если у него больше одного
ребенка получается то есть вот сколько мы белых вершин вот так вот походили везде ну а для проверки
того что у нас является точка сочинения некоторая вершина в это означает что в этой вершине в из
ее ребенка нельзя подняться выше вот то есть время входа в данную вершину оно будет меньше
либо равно чем таймап от других это означает как раз таки этот момент что мы не можем никуда
подняться то есть таймы на то вот та самая мера глубины есть вершина в вершина у если у меня таймап
из этой вершины то есть насколько я максимум могу подняться он не доходит до вершины в н не
знаю тут 5 тут 6 например вот но он максимум 6 приходит потому что не знаю там какой-нибудь ребенок
усмотрит еще вот если у него максимальное время это 6 то у нас как бы беда в этом случае мы говорим
что вершины в будет у нас делать будет той самой точкой сочинения мы ходим по всем вершинам и смотрим
у них нет почему а если как понять что у нас ребенок есть вот на этом вот чудо графики ну
смотрите в действительности как бы а 4 подходит под первые критерии правда
да мы насмотрим на каждую вершину смотрите вот на данном на данном графе который здесь есть
у шестерки есть один сын правильно и у него таймап какой нулевой правильно а время входа
вершину 6 2 ну то есть вот написано 2 0 2 этого сколько мы вошли 0 это насколько мы можем поднять вот
ну таймап 0 поэтому это время входа в корень время входа в корень 0 ну давайте хорошо давайте
хорошо давай 4 что у нас там 0 5 6 1 3 2 вот так есть и вот так есть
это дерево обхода а как у нас здесь идет таймын давайте сначала начнем с него к примеру таймын
что делает он заходит сначала в наш корень ну этого дерева откуда мы начали всегда будет корень
как раз таки дальше мы заходили в пятерку дальше мы заходили в шестерку потом единичку вот после
этого мы оттуда ушли получили что мы зашли в 0 у нас здесь будет 4 потом здесь было 5 10 6 это
время входа правильно осталось понять время куда мы максимум можем подниматься ну как бы из
нулевой вершины куда я могу максимум подняться но остаться в себе потому что выше не бывает на
самом деле поэтому у нас здесь будет ноль ноль из пятерки могу ли я куда-то выше подняться
нет поэтому я могу остаться только на месте то есть я могу у нас какой есть вариант я могу
либо остаться в этой вершине либо по обратному ребру подняться либо спуститься в детей и
подняться по ним три вот этих варианта да я у меня здесь единственный вариант остаться на месте
подняться наверх я никак не могу потому что это дерево у меня здесь все ориентировано уже
лично теперь смотрите когда я раскручивал вот этот стэк вызову грубо говоря рекурсии то в этом
случае здесь на самом деле идет снизу вверх единицу я могу подняться в ноль же могу поэтому
здесь таймап 0 я его посчитаю раньше чем я зайду в шестерку это возможно так не вот так вот а дальше
я захожу в шестерку то есть возвращаюсь из единицы сюда и смотрю ага первый вариант я остаюсь на
месте в этом случае таймап 2 могу ли я подняться из шестерки куда-нибудь нет могу ли я через детей
подняться куда-нибудь да поэтому я выбираю минимум из двойки и нолика получается 0 сюда смотрим
давайте опять мы смотрим из детей из тройки таймап куда колька я могу остаться на месте это
будет 5 я могу подняться вверх это будет 0 и все из детей у него нет детей правильно поэтому
меня между пятеркой нулем самым минимально ну и с шестерки ой ну из второй вершины который за что
зашел шестой из нее я могу остаться на месте это 6 подняться наверх я не могу у меня нет никакого
обратного ребра в этой вершине детей тоже нет поэтому остается только один вариант остаться на
месте правильно поэтому это будет 6 пересмотрю сюда а первый вариант остается на месте 4 второй
вариант а подняться наверх могу ли я отсюда нет у меня ничего нет поэтому это отметаем и
и третий вариант подняться из детей левой я поднимусь к нулевой управок шестерки вот
я выбираю 4 0 6 что из этого лучше 0 вот так расставляется таймапы ну вот чисто если
нарисовать отлично теперь смотрите а у нас это расставлено и какое условие на точки сочленения
я смотрю сначала на корень и такой у меня есть сколько детей здесь 3 больше чем 1
больше чем 1 а это означает что это является точка сочленения то есть вершины 4 это точка
сочленения вот теперь смотрю на все остальные вершины у пятерки детей нет ну как двои ладно
она не является точкой в шестерке у нее есть ребенок но у этого ребенка таймап выше чем тайм
ин здесь правильно значит она может подниматься к предку значит если таймап в этой вершинке
больше чем тут вот значит я могу поднимать точнее тайм-ин в этой вершинке меньше чем
больше, чем таймап в этой вершинке, то есть я могу из этой вершины подняться
выше, чем вот это. Тут два, а тут я поднимаюсь на ноль. Значит, если я удалю, ничего не
произойдет. Ну, то есть удалю эту вершину, меня связано сохраняется. Правильно?
Хорошо, идем сюда. Ну, тройки, двойки, понятно, ничего не происходит, у них детей нет.
Смотрю на нолик. У меня время вход 4. Смотрю на левого ребенка. Если я удалил бы эту
нулевую вершину, то вот этот левый ребенок бы остался все так же связанным. Правильно?
Потому что тут ноль. А вот в то же время, если я посмотрю на правого ребенка, то у меня здесь
6. Он подняться никуда не может. Ни к чему лучше он подняться не может. Согласны? А это означает,
что если я удалю эту вершину, то у меня связанность нарушится. Поэтому здесь это
является точкой исчленения. То есть я посмотрю на всех детей. Стал понятнее на примере?
Нет, у нас нет ориентированных графов. У нас не ориентированный граф – это дерево обхода.
Это получившееся дерево. Смотрите, как мы можем подниматься. Мы считаем,
что у нас есть некоторая вершина, и у нее есть дети. Что подразумевается под
одному обратному ребру? То есть мы доходим до какой-то здесь вершины, и от нее поднимаемся вверх,
и считаем, что она максимальная. Смотрите, вершины У мы идем куда-нибудь к детям,
приходим к ним в какую-то точку. Тут может быть другой ребенок, который поднимается вот сюда.
Какой из них для меня более выгодный с точки зрения рассмотрения У? Вот этот.
Не тайм-ин, тайм-ап. Я мог сначала вот в эту сторону пойти, здесь все обследовать,
потом сюда. Здесь тайм-ин будет меньше. Для меня выгоднее тот, который пойдет выше.
И под этим подразумевается, что у меня есть хотя бы одно обратное ребро. То есть я поднимаюсь
по одному конкретному ребру. Вот оно. Чтобы найти его ребро? Чтобы найти тайм-ап. Смотрите,
давайте еще раз. Как у нас работает ДФС? Согласны, что я сначала обработаю все эти вершины? Я буду
по слоям обходить по сути. Согласны? То есть я рекурсивно сначала сюда зашел, потом уже поднялся,
опять вниз и так далее. Вот. Я найду здесь тайм-ап, здесь тайм-ап, здесь тайм-ап, здесь тайм-ап.
Вот у детей УУ, вот здесь вот которые будут находиться, вот на этом верхнем уроке, грубо говоря,
у них свой тайм-ап есть, который они могут пройти, либо спустившись до детей подняться вверх,
либо сами пойти вверх. Правильно? Я выбираю из них чиселка, которая мне подходит. Минимальная.
Вы писали код на семинарах? Хорошо. Там был тайм-ин и тайм-ап? Ну, время входа, время выхода, да. Вот.
Что, как выглядит вообще весь псевдокод? Весь псевдокод, который у нас есть. Сначала мы с вами,
ну, все так же, типа, как мы посещаем вершину, некоторую нашу вершину, а дальше мы говорим,
что время входа в данную вершину равно тайм-апу данную вершину плюс-плюс тайм. Что под этим
подразумевается? Ну, смотрите, это именно то самое, когда мы говорим, что мы остаемся в этой вершине.
Мы никуда не поднимаемся, мы просто идем вверх. Окей? Вот. То есть мы говорим, что в начале тайм-ин
и тайм-ап одинаково. Дальше я считаю количество своих детей. Вот. Ну, точнее, сколько детей у меня
там, к примеру, есть. После этого я смотрю и иду по всем вершинам, соседним с моей вершиной У.
Которая является, ну, точнее, вершина У это все соседи, которые у меня есть, соседи вершины В.
У меня есть В и у нее есть несколько вершин. Вот в форум я прохожусь по всем этим У. Окей?
Окей. Какие есть варианты? Есть варианты несколько. А в какие вершины мы можем смотреть? В черную мы
можем смотреть? Не можем. Мы можем смотреть только в белую или в серую. Если мы смотрим в серую вершину,
то что это означает? Ну, что мы вот так вот делаем, вот тут вершина У. Правильно? Обратное ребро у
нас появилось. Согласны? Вот. Это первый вариант, что у нас появилось обратное ребро в данной вершине В.
Значит, я могу попробовать подняться по нему. И я смотрю время входа вот в эту вершину и делаю
минимум из таймапа В из таймина У. То есть, в ту вершину, в которую я поднимаюсь. Согласны?
Ну, то есть, я вот это обратное ребро, вот оно. Вот первый И отвечает за вот это обратное ребро.
Меня пугает. Скажите, что именно непонятно. Давайте так.
Тайм? Ну, типа.
Сейчас, смотрите, нам нужно найти минимум из трех чиселок. Первоначально... Давайте,
хорошо. Я захожу ДФС в вершину В. Да? Захожу, не знаю там, время пять. Я говорю, пусть у меня
таймап сначала равен пяти. Ну, я остаюсь просто на месте. Это первый вариант, который возможен.
Правильно? После этого я смотрю вот с помощью того ИФА, который здесь есть, что мы нашли серую
вершину. Если мы нашли серую вершину, то мы пришли куда-то наверх, по нашему дереву. Значит,
это обратное ребро. Вот оно. К некоторой вершине У. У является предком В? Да. Хорошо. А теперь вопрос.
Значит, таймин ВУ какой? Меньше. Ну, предположим, два. Теперь, смотрите, я могу остаться на месте с пятеркой,
а могу подняться до двойки. Ну, естественно, я выберу двойку. А, в смысле, почему там минимум написан?
В ребенка зайти невозможно. У нас серой вершины такой не будет. Такой не будет. Я понял вопрос. Все,
теперь я понял вопрос. Можно. Вот. А дальше, что мы смотрим? Мы смотрим на все белые наши вершинки.
Ну, то есть, вот этот случай разобрал. Теперь, если я смотрю на белые, то они являются нашими
предками. Ой, потомками. Извиняюсь. Теперь все вершины вот в этом эфе, где их равно там white,
это вот это. Можно написать. У предка всегда таймин меньше. Мы не можем пойти в ребенка. Мы уже
прошли эту вершину. Она серая. Серая вершина не может быть ребенком в нашем графе. Из серой вершины
в белую мы пришли, а потом из этой же вершины вернулись обратно. Знаем. Она не может быть
серая. Смотрите, если бы это было ребенком с точки зрения дерева обхода, тогда в этом случае вот это
было бы белым. А мы пришли в серую. В серую вершину нельзя прийти, когда это ребенок.
Серая вершина в таких графах означает вот это. Потому что мы сначала отсюда пришли, потом сюда,
потом сюда, и вот вернулись в серую. В двух разных предках, конечно. Все правильно. Можно и так. Я бы
просто ждал, когда у вас будет косяк в этом, а в контесте, если бы был. Минимум, да, действительно
необходим будет. Это правильное замечание. Теперь стало понятнее. Чудно. Хорошо. Ну, смотрите,
мы можем уже прийти в вершину У, которая 2, можем прийти в вершину У, в которой будет время входа 3.
Минимум из них нужно взять. Я хочу подниматься выше и выше. Нет, почему? Я ж таймап складываю
минимум. Да, у нас в таймапе всегда складываются таймын, таймын, таймын, таймын. Окей, хорошо.
Поехали дальше. Если мы приходим в белый вершинкин, то что в этом случае происходит? Вот они
детьми стали, правильно? Это куда мы можем прийти, да? Да. А У это откуда мы можем прийти из В?
С минимумом. Хорошо. Поехали дальше. Пришли в белые вершины. Будем считать количество детей. Зачем?
Для корня мы будем считать. Для корня. У нас же с корнем какой вопрос? Сколько у него детей? Вот и все. То есть
если мы пришли в белую вершину, то у нас плюс один ребенок. Если их будет хотя бы два, то в этом
случае будет беда. Но будет точка сочленения. Согласны? Вот. Я только для этого считаю детей.
Дальше я прихожу в белую вершину и что я делаю? Я запускаю DFS дальше. Ага. Запускаю DFS. Что в этом
случае происходит? Происходит следующее, что я все обратные ребра просматриваю опять. Правильно? У
детей. У. Согласны? Все обратные ребра опять будут рассмотрены, потому что он будет рассматривать это
ифы в серых. Окей. Если мы все просмотрели, то в этом случае, когда я вернусь к вершине У, что у меня
будет? Согласны, что в вершине У у меня будет нужный мне почти таймап? Или нет? У является сыном В. Вот. То
есть мы обработали всех детей и сделали там необходимый нам таймап. Согласны? Вот. Хорошо. Мы
посчитали. Для У. То есть мы запустили DFS для У и вот этот DFS все посчитал там. То есть он отошел от
детей, потом зашел от детей-детей и так далее. Потом вернулся обратно. Рекурсивно мы посчитали
этот таймап. Чудненько. И тогда в этом случае, что я могу сказать? Давайте я посмотрю, а может быть из
моих детей я вообще вот пришел здесь в нулевую вершину. Согласны? И вот, к примеру, У. Было там 6,
ноль. То есть он мог еще выше пойти. Тогда в этом случае я сверяю, какой у меня здесь таймап, а
какой здесь. То есть вот в этом случае я как раз разбираю случаи, когда через детей поднялся вверх.
Поэтому тут 2 заменится на ноль. Понятно? По сути свои все. Да. Все. G, U и false. False означает,
что это не корень. Так. Это будет самый первый. Самый первый вызов, который вы сделаете там,
это будет DFS. Visit. От графа G в вершине там, не знаю, ноль. И это корень. У вас только одно будет
вызов корня. Самое первое, которое вы вызовете сами. Что? Потому что каждый ребенок не является
корнем. У вас здесь корнем одна вершина. Да. Подождите еще раз. Когда я запускаюсь от любой вершины,
она становится корнем, а все остальное является деревом DFS. И не является корнем.
Так. Почему это точка слиния? Вот. У корня по определению не может быть обратных
ребер. Поэтому корень рассматривается отдельно. У корня в принципе нет обратных ребер. Ему
некуда выше идти. Он самый первый. Вот. Все остальное может, естественно, выше идти. Поэтому,
как бы, если 3 есть сына, это не означает, что это точка слиния. Нет. Еще вопросы. Понятен ли
код написан здесь? Почему? Правильно.
Ну, смотрите. Еще раз. Вот то, что здесь написано, это является таким полу-псевдокодом раз. Во-вторых,
а то, что здесь написано, вы можете использовать каким образом? Вам с точки зрения ООП не нужно
вот типа DFS Visit прям запускать, потому что название очень странное будет. Вам нужно поиск,
вам нужно вернуть вектор вообще по-хорошему. Правильно. Фактически вам нужно просто вот эту
часть выкинуть отдельно. И все. Вот. Которая внутри сама запустит DFS от нулевой вершины,
все такое. Конечно. Это написана сама сутьевая часть. Как вы сделаете, это другой вопросик.
Еще есть вопросы. Все понятно? Хорошо. Мосты. Что такое мост? Да. Ну, то есть точка слиния – это
просто убрать точку, а вершину какой-то мосты – это убрать ребро. И тогда у вас увеличиваются
компоненты связанности. Критерий моста какой? Критерий моста примерно следующий. Пусть мы
запустили все также DFS. Ребро какое-то является мостом, если у нас вот это вот ребро ВУ и В-родитель
У в дереве обхода, и из У нельзя подняться выше. Ну, то есть подразумевается примерно то же самое,
что здесь ток не с точками, ток не с вершинами. То есть подразумевается следующее, что у нас
ребро оно не будет мостом в случае, если мы можем подняться просто выше. Из нашего
ребенка. То есть есть вот такое какое-нибудь обратное ребро. Вот. Ну, то есть ребро именно двигаясь
по детям еще можно, и можно вот по детям обратно еще двигаться. Если вдруг мы можем подняться выше,
то в этом случае это будет мостом. То есть если так нельзя делать, то это будет мостом. Если так можно,
то это не мост. Ну, как бы аналогично тому же, что у нас было, просто главный вопрос, что мы,
удаляя вот эту связанность, мы можем все так же прийти как-то в вершину В. Ну, как мы можем это
сделать? Ну, ровно так же, типа подняться, да попасть мне. Вот. Это является вот некоторым критерием моста.
Хорошо, к мостам. Ну, как бы здесь чуть более формально написано с точки зрения того, как доказать,
что это критерий моста. Вот. Относительно того, что если мы не можем подниматься по обратным
ребрам, то и в дереве у нас нет обратного вот этого пути. Значит, у нас есть единственный путь
через это ребро. А если это путь единственный, который соединяет В.И.У., то в этом случае у нас
при разъединении этого ребра, то есть при удалении, мы с вами получим две, две компоненты связанности уже,
а не одну. Ну, логика здесь такая же, как бы здесь не очень сложная. Какая разница здесь в
точки зрения оточек сочленения? Ну, смотрите. Первое, это отсутствие корня, что нам не важно здесь корень
или не корень, потому что, ну, нет, тут корня, нам не важно, у нас ребра только. Вот. И второе, что нам
нужно заменить таймин меньше или равно на меньше. Всё. Весь алгоритм готов. Если вы написали хоть
что-то, то это уже работает. Вот. Поэтому это выглядит вот так. Ну, то есть мы не проверяем, мы не считаем
здесь количество детей, мы убираем условия на корень и, в принципе, всё. И меняем вот этот вот
меньше или равно на меньше. Вот. Так что, да, если вдруг у вас есть задача на то или на другое,
то решив одну, вы решите, по сути, вторую. На точки сочленения чуть-чуть побольше кода из-за вещей,
которые вы вызываете. Есть ли тут вопросы? Вот. Ну, я думаю, время работы понятно, что время
работы это всего DFS, поэтому так. А что важно здесь понимать? Какие вопросы здесь могут быть?
Смотрите, неориентированный граф вы всё-таки храните как две ребра. Сюда и сюда. Да? Вот. Важно
понимать, что мы не должны смотреть вот в такой же концепции. Мы не можем вернуться по этому ребро
обратно, когда вы будете запускать DFS. Поэтому здесь очень аккуратно обсчитывайте всё это. Если
вдруг у вас вот это вот есть, а у вас вообще есть мультиграф, то там вообще начинается беда. Нужно
понять, как это делать. Это отдельно. На самом деле там с кратными ребрами нужно просто проверять,
есть ли кратное ребро или нет. Если да, то всё хорошо. Если нет, то мы работаем как обычно. Всё. Вот.
Ну, существует теорема Робинсон. Это последнее, что я должен был бы рассказать вам на прошлой лекции.
Поэтому всё хорошо. Звучит оно так, что неориентированный связанный граф можно сильно
ориентировать, то есть задать какую-то ориентацию ребер таким вот образом, что у нас граф будет
сильно связанным, только лишь в связанном графе, где нет мостов. То есть, если у вас есть какой-то
неориентированный граф, вы можете сделать какую-то ориентацию, определенную такую, что у вас граф
будет ориентирован сильно связан и у вас не должно быть для этого мостов. Если вдруг они есть,
тогда вы не можете сделать такой ориентации. Прикольная теорема. Наверное. Вот. Ну, а как она
доказывается? Ну, в одну сторону. То есть, когда мы можем сильно ориентировать наш граф, мы говорим,
что пусть не так, пусть у нас есть какой-то мост. Ориентируем сильно наш весь граф. Предположим,
что у нас есть это ребро, которое является мостом. Если я его удалю, то в этом случае у нас компонент
сильно связанности увеличится. А что означает сильная связанность? Что мы можем и в одну
сторону идти, и в другую сторону идти. То есть, у нас была вершина, то есть, было ребро какое-нибудь
в У. Вот я его сильно ориентировал сюда. Когда я сильно ориентировал, это означает, что из вершины В
я могу попасть в У, из вершины У я могу попасть в В. Но если это было мостом, то я удалю, и у меня
никакого обратного пути нет. Значит, я не мог сильно ориентировать этот граф. Вот, поэтому здесь у нас
как бы противоречие. Чудесно. Теперь, смотрите, в обратную сторону. Давайте мы, у нас нет мостов,
у нас связанный граф, там нет мостов, все чудесно. Как мы можем предложить эту ориентацию? Ну, давайте
ориентироваем все ребра согласно обходу в ДФС. Из любой вершины можно подняться из нее самой
куда-нибудь выше. Все отлично, я могу ходить по предкам. Вот, это является теоремой Робинсона.
Ну, смотрите, подразумевается, что у вас есть вот такой неориентированный граф, у вас там есть вот
такое неориентированное ребро. Когда вы ориентируете его, вы либо в одну сторону
смотреть, либо в другую. Вот, там другого варианта нет. Да. Смотри, мы поднимаемся из любой вершины
выше нее самой, потом еще раз из нее выше любой какой ты хочешь, потом еще и еще, и мы доходим до
корня, до которого, у которого нет возможности подняться еще выше. Вот. Хорошо, ладно. Хорошо.
Из корня нельзя. Вот. Есть ли еще вопросы? Все понятно? Теперь вы сможете ответить про мосты
если вас ночью разбудит. Расскажите. Грустно. Ну ладно.
Ладно. Хорошо, принято. Смотрите, есть вторая тема, а я какой предлагаю механизм. Предлагаю,
мы сейчас будем говорить про нее. У нас, благо, есть время. Вот. Возможно, мы чуточку задержимся.
Если у нас останется алгоритм один, то я его перенесу на следующую лекцию. Хорошо? Это будет
алгоритм Барувки. Вот. С ним чуть-чуть попозже. Ну, я надеюсь, что зависит от того, как вы будете
слушать. Вот. Ну, посмотрим. Хотя бы один алгоритм мы с вами сегодня разберем. Вот. И с ним мы с
вами поработаем. Кто из вас что-нибудь слышал про минимальные остовные деревья? А? Все у вас уже
было на семинарах? На ЛКТГ? Подождите. У вас было это на ЛКТГ? Было? Что такое остовное дерево?
Ну, хорошо. Окей. А вы на ЛКТГ алгоритмы какие-то проходите еще? Или просто типа приколы, приколы
деревьев, назовем это так? Приколы графов? Все, принято. Ладно, хорошо. Давайте поговорим,
что такое остовные деревья. Тогда кратко скажу. Если у нас есть какой-то неориентированный граф,
и у нас есть... и вот остовным деревом, грубо говоря, называется такой подграф,
который содержит все вершины из нашего изначального графа, и оно вот все связано
будет между собой. Должно быть. Вот. То есть вот этот граф остается все таким же... то есть такая
транспортная сеть, грубо говоря, где вы можете откуда угодно, докуда угодно все также добраться,
учитывая, что у вас граф неориентированный. Но если вдруг нет, то в этом случае вы уже не можете
этого сделать. Вот. Что такое минимальное остовное дерево? Вот смотрите, это остовный подграф,
все еще, который у вас есть, но он должен иметь наименьший вес, суммарный, учитывая,
что у нас каждое ребро имел какой-то вес. То есть вот вы хотите сделать такую минимальную
связанность вот всего, что у вас есть, для того чтобы, ну не знаю, дороги меньше вклась, там еще
что-нибудь. Как хотите можете это делать. Вот. Здесь нарисован граф, и вот зелененьким выделен
минимальный остовный граф. Просто остовный граф не минимальный, а минимальный выглядит чуть-чуть
по-другому. Вот. А что еще нам понадобится? МСТ это как раз-таки минимальное остовное дерево. Вот.
Нам понадобится определение безопасного ребра. Что такое безопасное ребро? Ребро ВУ называется
безопасным, если при его добавлении в наш граф же штрих, который вот мы используем как остовное
дерево, он остается под графом некоторого, возможно другого минимального остовного дерева графа.
То есть безопасное ребро это то, которое мы добавили, вот ничего не произошло. Вот. И оно
все также осталось миностовым. То есть мы вот выбрали вот определенные вершинки. И все. Вот.
А что такое минимальный остов? Ну смотрите, мы просто возьмем, какой план здесь капкан? То есть мы
можем добавлять вот эти вот безопасные ребра и тогда у нас все будет хорошо. У нас все также
минимально сохраняется и так далее. Подразумевается, все поняли, что такое безопасное ребро? Хорошо.
Понял. Тогда смотрите. У нас есть некоторый граф. Мы предположим, что у нас вот пока что у нас есть
только вот это ребро. Что такое? И предположим, что у меня есть еще вот такое, вот такое ребро,
вот такое, вот такое какое-нибудь ребро. Что такое безопасное ребро? Безопасным ребром называется
какое-нибудь ребро, которое будет нас связывать новые какие-нибудь ребра между собой. Ну новые
вершины точнее. И оно будет все также под графом минимального остовного дерева. То есть вот это
является под графом миностового. Я беру, добавляю новое и вот эти уже три вершины тоже являются под
графом миностового. Минимальное остовное дерево. Понятно? Потом это такое. Вот это ребро,
если я добавлю, оно уже не будет под графом миностового. Согласны? Он только увеличит стоимость.
Нет, все разные. Ну я просто предполагаю. Хотите, напишу веса. Три, два, десять.
Какое-то ребро не возьмет. Вот это не войдет, например. Ну смотрите, я предполагаю, что войдет. Вот
когда я его начертил, я предполагал, что он войдет. Я написал вам такие чиселки, что оно войдет.
Сейчас я написал вам такие чиселки, которые войдут. Я потому что, ну как бы с пустого начинать не самое
прикольное. Под граф связанным, вот в смысле вот этот кусок. Хороший вопрос. А как ты думаешь? Нет.
Смотрите, давайте еще раз вернем к безопасным ребрам. Что это такое? Вот у нас есть некоторый
ж-штрих. Он является под графом некоторого ж. Ну то есть вот ж-штрих, а что это само по себе? Ну вот у
нас есть какой-то под граф минимального основного дерева. Вот безопасным ребром будет называться то,
что если мы добавим в этот ж-штрих это ребро, то он все также останется под графом некоторого
минимального основного дерева. Да. Конечно. Ну представь, я возьму и сделаю все одинаковые
веса. Я могу связывать их хоть как. То есть я могу, ну предположим, что все единичка. Я могу связать вот
так. Правильно? Я могу связать вот так. Я могу связать вот так. Вот. Мне же никто не говорит,
что у нас уникальные какие-то значения есть. Принято? Принято. Окей. Добавим еще пару определений.
Добавим еще пару определений. Первое. Что такое разрез графа? Ну разрез графа это просто разрезать
граф на два непересекающихся множество вершин. Там слева одни вершины, справа другие вершины.
Ага. Что такое ребро пересекает некоторый разрез? Ну вот смотрите, вот это разрез,
это разрез S и U. Все правильно. Вот. S и U это кусочки моего разреза. Согласны? Ну то есть они не
пересекаются. Окей? Окей. А что такое ребро пересекает мой разрез? Ну то есть оно связывает одну
вершину из одного множества в вершину другого множества. Окей? Ну вот. Вот это вот является
пересечением моего разреза. Пока просто из определений. Правда? Хорошо. Тогда что такое лемма
о безопасном ребре? Смотрите. Пусть G штрих это подграф некоторого минимального основного дерева T,
графа G. А S и U является разрезом моего графа. Вот это вот подграф как раз таки. А такой,
что же штрих не пересекает этот разрез? Ну вот согласны, что он лежит полностью внутри этого
разреза? Просто там вот внутри как-то есть и есть. Отлично. Тогда ребро минимального веса среди
пересекающих разрез, вот это 6 или 7, является безопасным то, у которого будет вес меньше. То
есть если я из этого разреза возьму и добавлю вот это ребро 6, тогда у меня минус 100 получится.
Если я добавлю 7, минус 100 не получится. Мы сейчас говорим о безопасном ребре. Мы подходим к одному
алгоритму, который это будет использовать. Другой алгоритм использовать не будет. Нет. Мы пока
работаем с первым. Первый будет использовать безопасные ребра, которые будут связывать здесь. И мы
говорим, что безопасное ребро будет то, которое вот в этом есть. Безопасных ребер может быть
несколько. Я утверждаю, что среди вот этих ребер, которые пересекают данный разрез, есть
безопасное ребро. И это безопасное ребро, оно имеет минимальный вес. Может быть тут внутри есть
еще одно ребро. Окей? Окей. Как доказать? Ну, по сути своей почти что да. Если у нас есть несколько
вот этих вот ребер, мы предположим, что есть это минимальное ребро, которое есть. Рассмотрим путь
какой-то вершины, вот из этих минимальных, из В в У, в нашем дереве. Вот. Он пересечет разрез
по некоторому ребру, пусть Е штрих. Ну, то есть пусть не так, пусть это небезопасное ребро. Вот.
Пусть оно пересечет по некоторому Е штрих. Окей. Вот. А если мы заменим Е на Е штрих,
в случае, если у меня вес Е штрих меньше, тогда в этом случае связанность любая сохраняется. Вот.
Ну, как бы все в принципе звучит хорошо. Но само по себе это будет означать что? Это будет
означать следующее, что у нас есть одно ребро, есть другое ребро, которое соединяет две вот этих
вот половинки между собой. Вот. И в то же время путь вот отсюда, грубо говоря, сюда и вот отсюда,
а он переходит по этим ребрам. Поэтому их вес должен быть одинаковый. Если вдруг он окажется выше,
то в этом случае у нас проблемы. А если мы выбрали ребро Е, вот какое-то ребро Е,
мы уже выбрали вот эту шестерку, грубо говоря, то добавлять ребро, которое стоит больше,
бессмысленно. Вот. Потому что оно лежит в миностове. Понятно? Вот. Так что ситуация вот примерно
следующая. То есть, если вдруг у вас несколько одинаковых ребер при разрезе, то выбирайте любое.
Одно или другое будет являться миностовом. Миностов не единственный. Вот. Это является
леммой о безопасном ребре и используется в алгоритме Прима. Как работает алгоритм Прима?
Смотрите, что мы делаем. Мы делаем следующее. Пусть у меня есть некоторый граф. Вот. Пусть у меня
здесь есть какие-нибудь ребра. Скажите какие-нибудь веса. Пять. Шесть. Два. Девять. Три. Хорошо. Вот
такой вот у меня граф есть. Хотите еще вершину добавлю? Хорошо. Какие-нибудь счет-числа? 57?
Ты любишь свою школу или что? Пусть будет так. Окей. Смотрите, что здесь делается? Ну, то есть,
у всех вершин номера там 0, 1, 2, 3, 4. Чудесно. В начале я говорю, пусть у меня в первом,
первое это вот этот разрез S вот здесь, второе это вот здесь. Это U. Вот у меня есть. Я смотрю на
минимальные ребра, пересекающие данный разрез. Ну, то есть, согласны, что вершина 0 является под
графами на 100. Она одна. Пустая. Вот. Значит, что по лемме о безопасном ребре я могу выбрать
минимальное ребро, оно будет лежать в миностове. Согласны? У меня здесь 6, 2, 5. Два. То есть,
я провожу вот это вот ребро. Неудобно сейчас будет. Ну ладно. Теперь получается моим разрезом S
будет вот это. А 2, 1, 4 это разрез U. Теперь я смотрю, какие вот здесь у меня есть ребра.
Так. Смотрю на эти ребры и смотрю, ага, какое здесь у меня минимальное ребро? Здесь 5, здесь 9,
здесь 3, здесь 57. А нет, здесь еще ничего нет. Это входит. А здесь 179, здесь 6. Ну какое
минимальное? 3. Я вот это делаю. Отлично. Хотя бы так. Чудесно. У меня осталось вот теперь S
входит, вот эти верхние ребра, эти верхние вершины, а в U входит вот эти два, две оставшиеся. У меня
остается 57, 179, 6. Ну 6. Ну и после этого остается здесь, здесь минимальное 57 и 179. Ну 57 выбираю.
И вот так у меня получается мой ми на 100. Понятно? Это тебе не нравится явно. Да, да, да.
Всего.
Что еще раз? Ну смотрите, вот Лема о безопасном ребре говорит, что в этом случае выбирай любое.
Вот. Просто. Звучит просто. Почему? Кто тебе такое сказал? Смотрите, как я могу выбирать минимум?
Не самое приятное. Еще. Еще. А? И что мне это даст?
Чего? Почему бин поиск? Ты же из нулевого ребра можешь, из нулевого в первое, во второе,
в третье, из второго там, в пятое, третье, второе, первое там попасть. Ребра-то разные.
Как я минимум могу искать? Какие есть вещи? Могу просто проходить и искать минимум? Могу? Могу.
А какую еще структуру вы помните, которая минимум хранит в себе и быстро находит?
Фибоначe ву кучe принято. Просто, пирамида тоже принято. Если очень хочется,
можно писать фибоначe ву кучe. В действительности, да, чаще всего вы будете использовать,
это просто пирамиду. Но фибоначe ву кучe тоже можно это делать. А если вы будете
использовать просто пирамиду, то в этом случае у вас время работы будет за Елу-Кве.
если будете использовать ферманачевую кучу, то это будет E плюс V лук V, но есть
интересный нюанс, у нее константа бешенная, вам это будет бесполезно, поэтому
вы будете использовать просто пирамиду. Да, да, да, приорити Q называется, но да, да, да,
по сути это да. То есть, когда вы делаете в приме, что вы делаете? Вы храните просто
некоторый дист, это минимальный вес ребра, ведущий в ту или иную вершину, в данном
разрезе, грубо говоря. Вы говорите, что у вас есть дист, и дист что делает? Он просто хранит
число. Прев это предыдущее минимальное ребро, которое было. И хип, он будет хранить все наши
ребра, то есть все вершины, и вот по сути по ним смотреть, что у нас там есть. То есть дист показывает
у нас как раз какое ребро мы закладываем сюда. То есть, в самом начале, когда у меня пустота,
некоторая пустота, то вершину нулевой я могу попасть бесплатно, а для всех остальных пока
дотянуться не могу, потому что я еще не добавил ее в разрез S, то есть с пустой вначале. Понятно? Вот,
и я храню в своей пирамиде, то есть у меня приоритетом выступает тот самый дист. Окей? Вот,
и я кладу вот типа вот все свои вершинки. В начале я инсерчу типа все, что можно, у меня получается
типа 0, 0, и дальше бесконечность 1, бесконечность 2, бесконечность 3 и так далее. Мне прикольно,
неинтересно. Вот. Что дальше я делаю? Пока у меня хиппани будет пустан, я с вами вытаскиваю минимум,
который там находится, и говорю, что это минимальное, расстояние до него минимально, значит,
в этом случае оно является безопасным ребром. Значит, я могу его использовать, согласны? Вот,
отлично. Я его достаю, кладу себе в корзиночку, говорю, что вот это вот то, что мне нужно.
И смотрю, если у меня предыдущее неравно было, ну оно существует вообще предыдущее, куда я пришел,
то есть начало вот этого минимального ребра, тогда в этом случае я его кладу к себе куда-нибудь. Если
нет, то не кладу. Все просто. Потому что это нулевая вершина, у нее начала все-таки нет. Мы туда просто
зашли. Вот с ноги. Все остальные вершины мы все-таки приходим по ребрам. Вот. А дальше что я делаю?
А дальше я смотрю на всех соседей, то есть вот эту нулевую вершину добавил, смотрю на всех соседей,
все которые есть, и обновляю дисты согласно тем ребрам, которые здесь есть. Ага. И как только я
обновляю дисты, я кладу это опять в свою пирамиду. И говорю, что предыдущий для 2 кинолик, предыдущий
для 3 кинолик, предыдущий для единички кинолик. То есть откуда я пришел в эту вершину. Вот. Кладу
это в пирамиду, обновляю этот дист. Ну и вот здесь вот есть хип Decrease K. Decrease K подразумевает,
что мы уменьшаем наш, ну наше число в этой пирамиде. Фактически, то есть либо я буду искать,
либо я могу просто складывать все в пирамиду. Вот. И в этом случае там и буду поднимать. То есть
всего сколько будет элементов мне там. Е. Согласны? Ну сколько, сколько ребер, столько,
я дистов туда и положу. И могу просто смотреть, дошел я до этой вершины или нет. То есть есть
она у меня или нет. Понятно? Как это работает? Сейчас мне бы его распарсить правильно. Я тебя
перерисую. Ноль. Сейчас. Тут у нас пять. Тут у нас шесть и один. Три, два, девять. Три.
Пятьдесят семь. Семь с девять. Все верно я нарисовал. Давайте смотреть на нашу пирамидку.
Вот Decrease K по факту он уменьшает нашу расстояние, ну он уменьшает наш ключ. А это означает,
что пирамида поднимается. Ну то есть этот элемент поднимается. То есть севтап просто
вызывается от этого элемента. Что у нас происходит в самом начале? В самом начале у меня хранится
ноль-ноль и все остальное у меня хранится как бесконечность один, бесконечность два,
ну и так далее. Окей? Это пирамида, которая у меня в самом начале. А? Ноль, один, два. Нет,
это номера вершин. Расстояние до этих вершин в самом начале оно бесконечное. То есть я нахожусь,
вот представьте, что у меня разрез S пустой, а все остальное U. Первое это расстояние,
второе это вершинка. Дальше у меня что там? Два, бесконечность, три, еще есть четыре.
Согласны? Пирамида в начале так выглядит. Что потом происходит с этой пирамидой? Я вытаскиваю
вот этот нулевой элемент. Вытаскиваю отсюда. Его больше нет. Интересно, что у нас происходит
дальше? Я начинаю обновлять все дисты, которые у меня есть. Вот по всем, кто у меня является
соседом нуля. Ага. Кто у меня является соседом нуля? Вот здесь я два не написал. В один это 6,
здесь это 5, здесь это 2. Правильно? Согласны? Как у меня теперь будет выглядеть пирамида? Когда
я делаю дикриски, я делаю сфитапы. Но после этого она будет корректной. Согласны? Пирамиду мы
восстанавливаем по корректности. Поэтому это будет выглядеть как 2-3, то есть вершина 3. Потом у нас
есть что там? Пять? Да. Где? Ошибка. Три, четыре. Вот так. Ну да. Вот вы построили пирамиду,
но вот этом. Вот построили. Вот чего мы делаем дальше. У нас есть 2-3, у нас есть что там? 5-2,
у нас есть 6-1, и у нас есть еще там бесконечность 4. Согласны? Я ноль достал,
я сделал экстракт. Правильно? У меня получилась такая пирамида. Понятно, откуда она появилась?
Сейчас расскажу. Расстояние в пирамиде делают в следующем образе. Я добавил вот это в S,
и теперь я смотрю всех его соседей и обновляю дисты. Ну вот сколько у меня расстояние по вот этим
вот ребрам. То есть смотрите, я при добавлении новой вершины что могу сделать? Если я добавляю новую
вершину в S, и вот у меня разрез вот здесь вот меняется. Согласны, что если у меня были какие-то
ребра до этого, я их так и не трону. Какое там было число? Там так и осталось. Правильно? И у меня
изменятся только те ребра, которые здесь есть. Правильно? Дист, что показывает? Он расстояние
от S до U в различных вариантах показывает. То есть какие ребра вот эти вот пересекаются?
Вопрос задай. Есть 00? Смотри, я достаю этот 00.
Это относится к вершине 0. Правильно? Отлично. Относится к вершине 0. То есть в моем S появилась
0. В разрезе S появился 0. Конечно, потому что безопасно. Я же сортирую почему? По ребрам.
Это самый первый вариант, самый нулевой. Когда вот я только пришел, у меня только одна вершинка.
Понятно? Хорошо. Теперь у меня вот такой вот разрез S и U. Такой дист. Дист показывает мне,
как я из S попадаю в U. Вот. Я добавил одну лишь вершину. Согласен? В S. Отлично. По каким
ребрам я могу попасть в U? По пятерке, по двойке, по шестерке. Правильно? Тогда по ним я попаду
вершину 2, 3 и 1. Правильно? Вот. Поэтому теперь я обновляю у двойки, единички и тройки вот эти
расстояния. Как это сделать в коде? Ну смотри, я могу обратиться к какому-то элементу своей хипы.
Вот. А вообще существует такая вещь, как декризки. В приоритете Q вы можете обратиться к конкретному
элементу и сделать там декриз к ключа. Вот здесь ключ значение. Вот вы можете декризы делать сами
по себе. Но. Но. Здесь важное но. В действительности вы будете делать, почти наверно, просто строить
огромную хипу, которая будет E элементов. И просто ее перебирать. Это на самом деле никак не
влияет симпатически. То есть, грубо говоря, вы получите не вот это, а я буду добавлять новые туда
вершины. Но в хипу же можно добавлять элементы. Согласен? Тогда в этом случае у меня появится
здесь два три пять два шесть один бесконечность ну там скорее всего бесконечность три да бесконечность
четыре бесконечность два. Добавил или нет? Пара просто. Согласен? Ноль-ноль удалили. Да. Это точно.
А? Согласен.
Скорее вот так оно сделает. Ну суть такая же. Правильно? Как будет выглядеть пирамидка? Ну,
около того. Давайте она правильно хотя бы сформирована. Я просто сейчас иначе добавлять
элемент конец поднимать и так далее. Это будет долго. Получил такую корректную пирамию. Дальше я
смотрю опять на топ. Это какой элемент? Три? Правильно? Вот. А тогда в этом случае я провожу
свое ребро. Вот это. Которое мы проводили. И удаляю тройку отсюда. И обновляю все дисты.
Каким образом? Ну как я могу из тройки попасть вот сюда? Согласен? То есть вот эти ребра вот одно
ребро вот это, одно ребро вот это еще. Потому что из нуля, ну смотри, я провел одно ребро.
Согласен ли ты, что вот все остальные ребра и 6 и 5 остались на месте? Ничего не изменилось. Ну вот.
Давай. Десятка. Десятка. Теперь смотри, что у меня будет хипех хранится. Что очень размашисто
пишу сегодня. Давайте прим сегодня. А дальше, значит мне нужно от вас будет время, когда вы
хотите послушать про другие. Смотрите. У меня вот такая пирамида и я добавляю новые. Новые
элементы какие? У меня 10-2 и что там? И 179-4, правильно? Здесь у меня 5-2, 6-1 и там еще будет 10-2. Значит
у меня на топе моей пирамиды будет 5-2. Согласен? У меня какие элементы могут быть? Смотри,
предыдущие вот эти все. Плюс я должен добавить сюда 10-2 и плюс добавить еще 179-4. Согласен? Вот я
смотрю на все эти элементы. Что у меня сверху будет? А? 5-2. 5-2. После этого идут уже другие
элементы. Кто у нас там меньше? Ну тут 6-1, 10-2. Согласен? Вот. И там вот все еще. Ну, короче,
я нарисую опять корректную пирамиду само по себе. Вот. Но, возможно, без некоторых нюансов.
Получается, что у нас там 179-4, бесконечность 1, бесконечность 3, бесконечность 2,
ну и бесконечность 4. Ничего не забыл? На самом деле, ни зачем. Но если вы будете
использовать Decrease Key, то полезно. Чтобы было у чего убирать. То есть как-то менять.
А? Decrease Key умеет изменять ключ. Я просто пошел оттуда, вам не понравилось вот так. Я такой,
ну ладно, я буду добавлять тогда элементы. Тогда в этом случае не нужны бесконечности. Это правда.
Да. Да. Так вот. Что отсюда дальше пойдет? 5-2. Согласен? Поэтому здесь появится вот это ребро.
Ну и аналогично дальше. Что важно здесь только понимать. Когда я начинаю вот таким вот образом
строить пирамиду, то у меня элементы могут повторяться. И надо просто проверять,
что я эти элементы не брал уже. Если я брал, тогда бессмысленно их трогать. Поэтому вот это 10-2
никогда и больше не исполнится. Понятно? Зачем? Вы же можете вот преф, вот у вас преф показывает,
пришли вы туда в эту вершину или нет. Можете просто хранить типа, не знаю, визит. Были там в этой вершине
или нет. Понятно? Потому что тогда вы добавите какое-то лишнее ребро. То есть если я 10-2,
добавлю, у меня получится вот это ребро. Зачем оно мне в миностове? Нет, то что оно будет в пирамиде валяться
ничем. Просто у вас пирамида чуть больше будет. Так у меня пирамида за логарифм от N, за логарифм
от V. Правильно? А там будет за логарифм от E. Ну E всегда пропорционально максимум на V квадрат.
Но это два логарифма E. Ну то есть с точки зрения симптотики это ничего не изменит. Понятно? Вот.
Ну и представьте, что я каждое ребро прохожу и добавляю новые сюда вершинки. Я сколько раз
делаю экстракт? E раз. Сколько у меня пирамид всего? Лог E. Получается E лог E, но можно сократить
до E лог V. Потому что E не бывает больше V квадрат. Понятно? Откуда получилась симптотика такая?
Ну с фибоначевой пирамидой, ну, аналогично происходит. Вот просто аналогично, просто это
фибоначева пирамида. Поэтому там E плюс V лог V. Понятно про приму? Вот. Что важно понимать? Важно
понимать, что можно искать минимум просто, ну как бы наивно. Если мы ищем с вами наивно,
тогда в этом случае мы с вами получаем что? А если мы ищем наивно, тогда мы проходимся просто
по всем дистам и смотрим типа минимальный оттуда элемент. Дистов сколько? V, согласны? И я это
повторяю сколько раз? V раз. Ну я потому что V вершин максимум добавлю своими на 100. Согласны?
Обновлять дисты я суммарно сколько раз буду? E раз, потому что я по всем ребрам пройдусь. Согласны?
Согласны, надеюсь. Нет, не совсем. Не всегда. Ну да, по сути своей, да, хорошо, то есть E
пропорционально либо V, либо V квадрат. Да, так можно, но тут будет E плюс V, так E плюс V квадрат,
так правильнее писать в этом плане. Так вот, очень важно, смотрите, заметьте, здесь когда мы делаем
просто вот прямо за E плюс V квадрат, бывают ли случаи, когда это работает быстрее? Вот придумайте
случаи, когда реализация с массивом лучше. До сколько работает алгоритм с хиппой? E лог V, а здесь
E плюс V квадрат. В каком случае массив лучше? Я про асимптотику.
Когда у нас E пропорционально V квадрату? Когда у нас E, почти полный граф, ну грубо говоря,
пропорциональный там V квадрат, в этом случае сложность, приму, за сколько? Вот с массивом.
За V квадрат, правильно? За V квадрат. А в этом случае за сколько? За V квадрат лог V. Да. Поэтому
запомните, не всегда то, что сложнее, лучше. И если вдруг вы увидите почти полный граф, то в этом
случае искать минимум лучше просто в открытую, просто с помощью дистов, по всему дисту проходится
каждый раз и все. Понятно? Ну и там обновлять дисты гораздо проще и понятнее. Ок? Чему E лог V? Смотрите,
сколько раз будет работать вот этот фор VU и соседи V? Ну нет, оно будет работать, сколько у
нас соседей, правильно? Ну то есть вот этот фор пройдется по всем соседям V. То есть это все
ребра, которые у меня есть из V. Согласен? Согласен. В VU я пройдусь почему? По всем ли
вершинам я пройдусь? А теперь смотри, я прошелся по всем вершинам, а внутри я прохожусь по всем
ребрам из этих вершин. Сколько это всего ребер? Это все ребра моего графа. Правильно? Получается так.
Получается это E. Я это делаю E раз. А минимум нахожу с помощью экстракта. Экстракт сколько раз делается?
Экстракт делается тоже E раз, учитывая, что вы хиппу не меняете, к примеру. Вот. Либо делается
V раз, и тогда лог V, ну либо лог E. Ну лог V и лог E это одно и то же для вас будет асимпатически. То есть,
смотрите, именно поэтому это работает E луквы. Хорошего вам всем вечера.
