Так, ну немного организационных вопросов сначала. Семестер у вас будет с тем же самым правом,
оценки будут по тем же самым правилам, что и в прошлом семестре. То есть у вас будет два
модуля. Это полусемистровый модуль по межпроцессному взаимодействию. Затем еще модуль по различным
дополнительным фичам в современных и уникальных системах. Задачи и контрольные все тоже самое. То
есть за каждый модуль ставится отдельная оценка, а итоговая оценка в семестре это просто среднее
арифметическое. Можно вопрос задать? Да. По поводу контрольных. Я вот написал уже две контрольные,
я так и не понял, как некоторые задачи решать. И на семинарах это не обсуждается, и на лекциях тоже.
Вообще семинаристы должны были разбирать уже после контрольных разбор задач. Контрольные
вообще больше по теоретическому материалу, а не по семинарскому. Если вас семинаристы это не
проводили, ну можем тогда после контрольных на лекциях разбирать. Пожелание принимается.
Тема сегодняшнего занятия это межпроцессное взаимодействие. Тут на самом деле несколько тем.
И начнем мы с самого простого и очевидного способа межпроцессного взаимодействия. Это
использование канала. Сначала о том, зачем нужно межпроцессное взаимодействие. Каждый
процесс в любой UNIX системе это что-то самодостаточное, изолированное. То есть у каждого
процесса есть свое виртуальное адресное пространство. Память процесса между собой не разделяют
по умолчанию. Процессы могут взаимодействовать только с ядром для того, чтобы общаться как-то с
внешним миром. Но достаточно часто возникает ситуация, что процессы все-таки должны между
собой общаться. И это нельзя сделать не имея единого адресного пространства. То есть если вы
хотите, например, сделать взаимодействие двух разных функций в любой программе на любом высоковаренном
языке программирования, то вы можете использовать либо глобальные переменные, либо передачу
документов. Когда у вас запущены несколько процессов, то это уже не получится. И здесь уже
приходится использовать некоторые обходные пути, как процессы могут взаимодействовать друг с
другом. Каждый процесс может взаимодействовать с ядром, а соответственно на ядро еще возлагаются
задачи по организации взаимодействия между разными процессами. Какие есть способы с процессом
взаимодействовать между собой? Самый простой, очевидный способ для тех, кто не знает о том,
как устроены операционные системы, кто не изучал course и не изучал курс по операционным
системам, это простое наивное решение создать какой-то файл, открыть этот файл в разных процессах и
писать туда какие-то данные. Чем такой способ плох? Плох тем, что вы не знаете в какой момент у вас
произошли какие-то изменения в файле. Тут возникает целый ряд проблем, начиная с синхронизации до
уведомления других процессов о том, что данные действительно появились. Поэтому такой способ он
конечно иногда используется, но очень плохой, очень неправильный. Кроме файлов есть еще разные
механизмы, например сигналы. Что такое сигнал? Это некоторое уведомление от одного процесса к
другому, либо уведомление от ядра к какому-то процессу, например, что выполнена какая-то
недопустимая операция. Сигналы в принципе тоже могут быть использованы как способ межпроцессного
взаимодействия, но у них есть очень серьезное ограничение. Во-первых, у большинства UNIX сигналов,
которые поддерживаются всем UNIX-подобными системами, есть ограничение связано с тем,
что отправка сигнала просто проставляет флаг наличия этого сигнала у процесса и, соответственно,
если одновременно несколько других процессов отправили сигнал, то процесс прочитает только факт
о том, что сигнал был, но не их количество. Кроме того, кроме номера сигнала, вы фактически
никакую информацию передать не можете. В некоторых современных системах, например,
Linux и FreeBSD, но есть еще дополнительный API для работы сигналами. Это так называемые сигналы
регального времени, которые позволяют отправлять какие-то дополнительные данные очень небольшого
размера, не превышающего размер машинного слота, 64 бита, и при этом, в отличие от обычных сигналов,
их количество не теряется. Все, что связано с сигналами, это у нас будет на одной из последующих
лекций, какие у нас бывают еще другие способы взаимодействия. Самый простой, с точки зрения
использования и достаточно удобный способ, это последовательная передача данных. Для этого
создаются некоторые файловые дискрипторы, в которые можно писать и из которых можно читать.
Соответственно, если вы хотите передавать данные от одного процесса к другому, то вам нужно создать
этот канал, для того чтобы этот канал, естественно, должен быть доступен обоим процессом. Каналы бывают
двух видов, это неименованные и именованные. Именованные каналы еще называют FIFA. Разница между
ними в том, что неименованные каналы должны быть созданы, например, родительскими процессами,
дальше наследоваться дочерьми, а именованные можно открыть по им. У каналов есть некоторые
ограничения, несмотря на их простоту. Например, взаимодействие может между собой только два
процесса. Если вам нужно организовать взаимодействие между собой нескольких процессов, то требуется уже
использовать более сложный механизм, который называется SOAP. Кроме последовательного доступа,
есть более быстрый способ это использование какой-то общей памяти, которая доступна сразу
нескольким процессам. Как это сделать? Вы уже это изучали в прошлом семестре на примере
стеновызова MAP. Там есть такой флаг MAP-shared, который в противоположность MAP-private позволяет
создать какую-то область памяти, доступную сразу нескольким процессам. Есть еще несколько
механизмов, которые работают поверх MAP для того, чтобы можно было организовать взаимодействие
не родственных процессов. Этот способ взаимодействия между процессами является самым быстрым,
но при этом требует более аккуратной реализации, например, по части синхронизации каких-то общих данных.
Тема сегодняшней лекции – это именно каналы, то есть механизм для последовательного обращения.
Самый простой способ создать канал – это запустить некоторую команду в обычном
интерпетаторе, точнее запустить две команды. Между ними можно поставить вертикальную черту.
Вот что эта вертикальная черта означает? Это означает, что нужно взять вывод первой команды
и вместо того, чтобы выводить его на экран, нужно просто перенаправить его на стандартный поток
ввода следующей команды. На самом деле здесь процессов может быть не два, а какое-то произвольное
количество. Можно выстраивать целый конвейер из нескольких каналов и нескольких команд.
И кто у нас создает этот самый канал? Создает его сам Shell. Когда команда интерпетатора разбирает
такую строку, он находит сначала все вертикальные черты, дальше все, что находится между ними,
запускаются как отдельные процессы, которые работают параллельно друг к другу и используют
канал для передачи данных. Что такое канал и как его создать? Что делает команда интерпетатора
перед тем, как создать некоторые процессы? Он вызывает системный вызов Pipe, который существует
во всех UNIX и подобных операционных системах. Это очень старый механизм, поэтому он есть везде.
В качестве аргумента Pipe принимает массив, то есть указательное начало из двух целых чисел.
Это является выходным параметром, то есть туда записывают в этом массив два числа. 0 и 1,
соответственно 0 и первые аргументы, это два файла дескриптора, поэтому один из них доступен только
для чтения, второй доступен только для записи. Дороже, чтобы не запутаться в том,
какой из элементов массива доступен для чтения, какой для записи, можно просто
представлять собой канал как некоторую трубу, в которой данные протекают справа налево. Тут
просто есть некоторая аналогия, что у нас есть стандартный поток ввода, у которого номер 0,
и стандартный поток вывода, у которого номер 1. Соответственно, нулевой файл для
скриптора доступен не только для чтения, первый доступен только для записи.
Как можно использовать каналы? Если у вас есть некоторая программа,
которая вовсе не обязательно взаимодействует с каким-то другим процессом, то каналы можно
использовать просто как механизм для передачи данных из одной части программы в другую. Если
кто-то из вас знает язык программирования Go, то может знать, что в языке программирования есть
такой тип данных как канал, который позволяет передавать данные из одной горутины в другую
горутину. Здесь, естественно, нужно аккуратно следить за тем, чтобы у вас не было блокировок,
то есть ситуации, когда вы записываете что-то, не записываете канал, но пытаетесь при этом
прочитать, хотя данных нет, программа вас просто блокирует. Где можно использовать каналы без
создания новых процессов? Например, если у вас программа многопоточная, то отдельные потоки
могут точно так же писать канал, как и обычный процесс. Давайте на этом простом примере рассмотрим,
как можно создать канал и его использовать. Для создания канала мы используем системный вызов
pipe, которому нужно передать указатель на два последние лежащих целых числа. Обычно для этого
используют массив, созданный на стэкип, просто по той причине, что 2 мта это очень мало и не имеет
никакого смысла выделять память в куче. После того, как канал создан, вы можете что-то писать в
канал и что-то читать. Используя самые обычные системные вызовы read и write, поскольку каждый
элемент канала у нас является отдельным пайлом дескриптора. Запись возможна в элемент массива
с номером 1, а чтение у нас доступно в элемент массива с номером 0. Запустим эту программу,
убедимся, что она действительно работает. Вот мы прочитали какие-то данные из канала,
как только данные закончились, то система вызов read просто возвращает значение 0,
и по этому признаку можно, например, прервать чтение. И в чем бывает проблема при использовании
каналов в рамках одного процесса. Давайте просто возьмем и поменяем 2 строчки местами,
то есть сначала мы попытаемся прочитать что-то из канала, и только после этого будем канал записывать.
Так, запускаем эту программу и получаем мы абсолютно ничего. Прервать процесс можем мы с помощью
CTRL-C. Почему у нас ничего не происходит? Потому что сначала мы пытаемся что-то из канала прочитать
до того, как что-то записали, но естественно висим на том, что read у нас блокирует текущий процесс,
то есть перевольт его в состояние sleep до тех пор, пока не появятся какие-то данные в каналах,
либо канал не будет закрыт. Поскольку запись у нас последовательно идет уже после попытки
чтения, то данные у нас в каналах никогда не появляются, и мы получаем ситуацию название deadlock
или мертвая блокировка, когда программа не может ничего выполнить. Поэтому каналы в этом плане
более смысленно использовать, когда у вас есть несколько процессов. Как это можно сделать? Вы
создаете канал, то есть создаете пару файлов и дискрипторов с помощью стеной из API, и когда
вы создаете новый процесс, то новый процесс начальник у вас наследует часть атрибутов под
разделительского процесса. Кто помнит, какие атрибуты у нас наследуются при эфорке,
помимо файлов и дискрипторов? Ограничения тоже ведь? Да, это разные ограничения, лимиты,
естественно файловые дискрипторы, которые у вас открыты, причем с теми же самыми номерами,
и еще, если у процесса есть разделяемые страницы памяти, то дочерний процесс их тоже наследует.
Там всякие мелочи, например, user ID, group ID и так далее. То есть используя тот факт, что файловые
дискрипторы у нас всегда наследуются дочерним процессом, канал можно использовать как механизм
межпроцессного взаимодействия. И здесь уже мы можем создать какой-то дочерний процесс,
который либо читает, либо что-то записывает. Поскольку процессы, которые выполняют запись и
чтение, у нас выполняются параллельно, то здесь уже уменьшается вероятность дедлока, но все-таки
она не нулевая. И за этим нужно аккуратно следить. Давайте опять же рассмотрим это на каком-нибудь примере.
Создадим все то же самое. У нас есть чтение из канала, запись из канала. Канал предварительно
создается, но мы функцию для записи в канал запускаем в качестве дочернего процесса. Да,
этот код у меня, сразу предупреждаю, немножко не тот идеал, который я обычно требую на семинарах,
поскольку здесь нет проверки ошибок. Это связано с тем, чтобы большее тексты
укладывалось на то. Итак, запускаем дочерний процесс. В дочернем процессе мы выполняем
запись, в родительском процессе мы выполняем чтение. Что у нас будет происходить?
Компилируем программу. Запускаем. Честно получаем вывод, который мы записали из дочернего
процесса. И где же командная строка? Что-то у нас продолжает висеть. Ну ладно, мы можем прибить
нашу программу с помощью CTRL-C. Давайте внимательно посмотрим, что у нас могло пойти не так. Мы
запускаем дочерний процесс и в дочернем процессе мы честно делаем запись каких-то данных, закрываем
канал, завершаем работу процесса. Казалось бы, все хорошо, все замечательно. Мы можем наблюдать,
что родительский процесс, который вызывает ритм, честно прочитал наши данные, вывел,
что он прочитал столько-то байк из пайпа, все это вывел. И программа у нас не завершается.
Почему это может происходить? Здесь требуется соблюсти некоторые правила. Что у нас делает
системный вызов RIT? Он читает не более чем то количество данных, которые вы просите,
и возвращает количество реальных прочитаний с байка. Что RIT обычно возвращает? Это возможные
значения минус один, если возникла какая-то ошибка, если данные закончились, значение больше нуля,
если RIT что-то прочитал. То есть мы наблюдаем ситуацию, что RIT у нас ничего не возвращает,
просто ждет. За чего это происходит? Потому что он пытается прочитать данные и не знает о том,
что наш дочерний процесс завершился и канал закрыт. Но в программе у нас процесс завершился,
он честно завершил свою работу, вызвал Exit 0, казалось бы, что мешает нашему RIT выполнять
дальше. Мешает RIT продолжить выполнение программы дальше то, что у нас канал на самом деле не
совсем закрыт. Давайте проследим за жизненным циклом нашего канала. Вот мы создали какой-то
канал. Здесь у нас в Channel появились два каких-то числа. Обычно назначаются в качестве номеров
самые минимальные не использованные номера для файлов дескриптора. То есть это значение 3 и 4.
Затем мы вызываем систему Use a fork. Что у нас тут происходит? У нас существует две пары файлов
дескрипторов с номерами 3 и 4 при листском процессе и плюс пара файлов дескрипторов с
тем же самыми номерами с дочерним. Затем запускается дочерний процесс, что-то делает и после того,
как дочерний процесс у нас завершился, он закрывает все файлы дескрипторы и все. Мы про это забываем.
У нас остаются два открытых файлов дескриптора в родительском процессе с номером 3 и 4.
Соответственно, процесс пытается прочесть данные из канала, который пока еще не закрыт,
потому что с ним связан еще один файл дескриптор с номером 4 и тем самым канал не считается закрытым.
Эту ситуацию нужно обязательно проверять, когда вы используете каналы. Мы совместно
сценизуем форк. Не забывайте о том, что у вас могут создаваться лишние файлы дескрипторы,
которые ссылаются на один и тот же канал, и это может прийти к ситуации deadlock. Как это
можно избежать? Просто нужно по необходимости закрывать все, что вам становится не нужно.
Итак, вот у нас есть родительский процесс. В родительском процессе, очевидно, не нужен
файл дескриптор, связанный с записывающей стороной нашего канала, поэтому мы должны эту часть закрыть.
После того, как мы закрываем эту сторону канала, все хорошо, все замечательно. После того,
как додчатный процесс завершился, он закрывает свою часть канала и выполнение у нас, честно,
завершается, поскольку ритм возвращается значением. На самом деле, здесь у нас есть
еще какие-то лишние файлы дескрипторы. Сейчас они нам особо не мешают с точки зрения deadlock,
но они все-таки потребляют ценный ресурс под названием количество используемых файлов
дескрипторов. Этот ресурс тоже нужно экономить, поэтому по-хорошему нужно еще закрывать, например,
в додчатном процессе неиспользованный файл дескриптор, канал для чтения. С точки зрения
поведения нашей программы это ни на что не влияет, но может повлиять, когда у вас количество
файлов дескрипторов является граничным. Так, ну и такие у нас есть правила, связанные с
записью в канал. В канал мы можем записывать в том случае, если существует хотя бы одна читающая
сторона. То есть на самом деле читателей у вас тоже может быть несколько. Это могут быть разные
процессы, например, которые читают из канала. Если у вас читает из канала несколько процессов,
то кто из них что прочитает, считается не поделенным. Но если у вас не существует ни одного процесса,
который может прочитать из канала, то есть вы предварительно закрыли все файлы дескрипторы,
связанные с читающей стороны канала, то эта операция запрещена и тот процесс, который попытается
записать что-то в канал, который закрыт, получаем ошибку в виде сигнала sickpipe. Если у вас процесс
выполняется как хранительский дискоманда и оболочки bash, то обычно bash подает ошибку
по названию broken pipe. Как это можно наблюдать? Давайте опять же проведем небольшой эксперимент.
Программа, которая только записывает в канал, но не читает. Здесь мы в дочернем процессе пытаемся
что-то записать в канал. Аргильский процесс у нас вместо того, чтобы читать, просто берет и
сразу же закрывает противоположную сторону канала. Сам дочерний процесс тоже он закрывает,
но хотя бы по той причине, что ему этот файл дескриптора не нужен. И что у нас происходит при
попытке записать что-то в канал. При попытке записать что-то в канал наша программа сейчас не
грохнется, потому что эту попытку выполняет наш дочерний процесс. Аргильский процесс у нас честно
отработал, а вот его дочерний процесс у нас грохнулся, и мы эту информацию можем получить через
exit status дождавшись код возврата нашего дочернего процесса. И можно наблюдать, что процесс не был
завершен корректным образом, а был прибит сигналом с номером 13, которому соответствует сигнал SIGPY.
Если у вас такая ситуация возникла, например, из родительского процесса, то есть мы после
закрытия канала просто напишем что-нибудь, записать в канал и какое-нибудь слово,
то можем наблюдать диагностику, хотя нет, здесь не bash, а ZSH, он диагностику не отработал.
А до этого случаи чем отличался? Что-то я не понимаю. Здесь дочерний процесс у нас грохнулся,
соответственно у нас никакого вывода в текстовом виде нет, но мы через этот статус узнали о том,
что процесс не дошел до строчки по названию exit 0, если бы он дошел до строчки exit 0,
мы бы получили код возврата вот здесь. Вместо этого мы получаем, что процесс был прибит каким-то
дочерным сигналом, то есть он не был корректно завершен, получил ошибку broken pipe. Здесь мы
завершились с кодом 0, видимо потому что код 0 закрыт, либо он не отработал, здесь видимо просто
у вас ошибка не всплыла в командам интерпретаторов ZSH, то есть это на самом деле ошибка,
которых нужно избегать. Когда вы можете натыкаться на эти ошибки? На самом деле вы
можете когда-нибудь косвенно или не явно все-таки делать запись, если не в канал,
то хотя бы в socket. Например, если вы как-то взаимодействуете с каким-то удаленным сервером,
то для socket действует те же самые правила, что и для каналов и запись в socket, который был закрыт
противоположной стороной. Является ошибкой, которая также приводит к появлению сигнала SIGPipe.
Если вы являетесь производителем рабочего окружения рабочего стола под Linux, то активным
пользователем иногда встречали такие баги в программах, когда у вас что-то грохается с
ошибкой broken pipe. Обычно это ситуация, когда не обрабатывается эта ошибка, вы пытаетесь записать
в какой-то сетевой socket, который был закрыт по причине того, что интервейк отключился, сервер упал,
программа может грохнуться, но на самом деле такие ошибки можно перехватывать,
про это будет в лекции, связанной с сигналом. Что у нас еще нужно знать, когда вы пытаетесь записать
что-то в канал? Нужно знать о том, что размер канала у нас ограничен, то есть каждый канал это
некоторый буфер, куда выполняется запись. По стандарту POSIX у вас гарантируется, что размер
этой трубы не менее чем 512 байт. 512 байт на самом деле достаточно мало и в старых реализациях Linux
этот размер был 4 килобайта, в современных реализациях всех операционных систем его
размер 64 килобайта. Соответственно, если вас никто не читает из канала, либо делает это медленно,
вы можете смело выполнять запись, но до тех пор пока не заполнится буфер,
связанный с каналом. После того, как вы этот буфер заполните, то у вас
будет заблокировано. Вот простой пример. Запускаем некоторую программу, которая не
порождает процессы, не создает новые потоки, просто записывает много данных в какой-то канал.
И в случае успешного записи подает информацию о том, сколько байт удалось записать. Запускаем
эту программу. Вот выполняем запись кусочками по 8 байт. Запись пока еще идет успешно. Обратите
внимание, что я здесь нигде не читаю данных, только выполняю запись. Все, в какой-то момент у нас буфер
заполнился. Мы успешно записали 65 506 байт или 64 килобайта данных. После этого процесс переходит
состояние slip на 16 строчке при попытке записи. Сетевный вызов write просто ждет, пока кто-нибудь
не прочитает из трубы и больше ничего записывать уже не может. Но поскольку у нас программа
однопоточная, нет дочерних процессов, если никто не читает из канала, то единственный способ
поставить программу, это ее прийти. На самом деле, поведение системного вызова read и поведение
системного вызова write не обязательно может быть блокирующим. При открытии файлов, если вы внимательно
смотрели на системный вызов open, там есть такой флаг под названием onOnBlock, который позволяет
открыть какой-то файл в неблокирующем режиме. Что означает неблокирующий режим? Это означает,
что вместо того, чтобы перевести процесс в состояние slip, когда чтение либо запись невозможны,
у вас системные вызовы просто завершаются немедленно и возвращают значение в минус 1,
как будто возникла ошибка. Но на самом деле ошибкой это не является. То есть переменной
прописано специальное значение eAgain, которое означает, что у вас в данных новых нет для
чтения, либо закончилось место в буфере, и поэтому запись невозможна, но при этом вы можете выполнять
какие-то еще действия и, например, попытаться сделать запись в следующий раз. Все это хорошо работает,
то есть вы можете открыть файлы с явным указанием флага onBlock, но когда вы создаете какой-то файловый
дискриптор, например, с использованием системного вызова pipe, либо когда вы создаете файлы дискриптора
по socket, то здесь уже указать флаг явным образом не получится, и необходимо использовать дополнительно
некоторый системный вызов, который называется FileControl, который позволяет манипулировать
атрибутами файловых дискрипторов. На самом деле здесь много всяких штук для модификации,
но в данном случае нам нужно просто поменять какие-то атрибуты, связанные с открытием нашего
файлового дискриптора, то есть сначала получить существующие, добавить флаг onBlock и вызвать
команду setFlags. Давайте посмотрим на каком-то конкретном примере. Вот та же самая программа,
которая создает канал, ничего из него не читает и записывает много раз значение по 8 байлов,
до сих пор пока не будет заполнен буфер. Но предварительно выполним некоторую настройку.
Мы получаем атрибуты нашего файлового дискриптора. Здесь мы можем в oldFlags узнать о том,
что наш файловый дискриптор здесь доступен только для записи, но не для чтения. Добавляем
к этим флагам еще флаг под названием nonBlock и после вызова FileControl с установкой флагов наш
файловый дискриптор уже становится не блокирующим. То есть что у нас произойдет,
когда место в буфере закончится и система вызовWrite не сможет ничего записать. В отличие
от предыдущего случая, система вызовWrite не будет приостанавливать выполнение текущего процесса,
а немедленно завершится вернув значение в минус один. То есть как будто возникла какая-то
ошибка в записи и при этом ошибку пропишет значение Deg. Это означает, что мы можем когда-нибудь
повторно записать что-то в файловый дискриптор, но сейчас он просто еще не готов. Если мы вызовем
чтение из буфера просто для того, чтобы опустошить буфер связанный с каналом, то запись повторно у нас
станет опять возможной. Вот тот же самый пример. Записываем все небольшими кусочками наш канал.
До сих пор пока не будет достигнут лимит. Лимит мы достигли и здесь вместо того, чтобы зависнуть,
мы честно выдаем какое-то диагнозическое сообщение. То есть мы упали в эту витку
F, получили значение минус один и ошибку EG. Ну и после чтения некоторого тайм-аута,
пока я с вами разговариваю, мы можем продолжить запись в канал. Сколько места там уже появилось.
А место появилось потому, что там прочиталось? Да, место появилось потому,
что был вызван вот этот вот стены вызов. Но как я уже говорил, у нас с каналом может быть связано
несколько читателей и несколько писателей. Обычная ситуация возникает, когда вы создаете
какие-то дочерние процессы, которые создаются в очередь копии файлов и дескрипторов, связанных
с одним и тем же каналом. И возникает проблема, что у вас может быть несколько например дочерних
процессов, которые читают из канала или несколько дочерних процессов, которые могут в канал записывать.
Возникает проблема, как узнать, кто записал и что записал и как у нас вообще происходит смешивание
данных в канале. На самом деле ответ никак узнать, кто записал и кто прочитал невозможно. То есть у нас
данные всегда смешиваются. Но смешиваются они не совсем произвольным образом. У нас гарантируется,
что есть некоторые минимальные атомарные куски данных, внутри которых данные не перемешиваются.
По стандарту POSIX размер этого атомарного пуска равен 512 байтам. В современных реализациях
новых операционных систем этот размер совпадает с размером одной страницы, то есть 4 килобайта.
То есть что будет происходить, когда два процесса будут записывать что-то в один и тот же канал,
читать мы будем где-то например из одного родителя. То есть один процесс у нас записывает в канал
строку hello, другой записывает строку world. И что ожидается? Делает это все не параллельно друг к другу.
Что мы ожидаем увидеть в родительском процессе? В родительском процессе мы видим, что мы получили
два раза два независимых вызова read. То есть здесь у нас этот цикл чтения выполнется два раза и
read два раза независимо. Вместо того чтобы прочитать максимальный размер буфера 4096 байт,
он прочитал маленькие кусочки от каждого процесса по отдельности. Данные у нас не
перемешались. То есть мы могли бы конечно наблюдать строчки вида v, e, o, l, r, l, l, o, d,
поскольку процессы у нас выполняются параллельно друг к другу. Но этого мы не наблюдаем как раз за
счет свойства атомарности. Потому что данные размеры в мини 512 байт идут от ним на проверённом
куску. Процесс у меня сейчас висит, потому что я тут где-то не дописал в черных процессах,
я в реалистском процессе не написал в открытии каналы, но это не особо принципиально. Чем важно
это свойство и где на практике вы можете наблюдать смешивание канала. Ну вот обычное окошко терминала.
Что такое обычный терминал? Это некоторая программа, которая запускает командный
предприятие башки или что-то еще. Какие у нас есть пайлы дискрипторы, которые нужно с помощью
канала перенаправлять на терминал. Это стандартный поток ввода, когда вы от клавиатуры к процессу
направляете данные. Стандартный поток вывода, то что нужно прочитать, отрендерить, как-то
красиво нарисовать моношириным шифтом. А еще есть стандартный поток ошибок. Стандартный поток
ошибок обычно в терминалах записывается тот же самый поток, что и стандартный поток вывода.
Но при этом, если вы независимо пишите в стандартный поток ошибок стандарт поток вывода,
вы все-таки данные можете на терминале прочитать и эти данные будут содержать какой-то осмысленный
текст, а вовсе не перемешанный по буквам. Ну и давайте еще раз вернемся к примеру, когда мы хотим
запустить какой-то пару процессов и связать их каналом. Что у нас представляет собой каждый процесс?
Это процессы, которые имеют стандартный поток вывода и стандартный поток вода. Когда мы создаем
пайп, то мы создаем новую пару файлов дискрипторов, и у этой новой пары файлов дискрипторов есть
какие-то в общем случае рандомные номера. Если у вас процесс достаточно свежий, то скорее всего эти
номера будут 3 и 4, как самый первый неиспользуемый, но в общем случае это опять же рандом. Произвольные
команды, например, если вы хотите использовать команду ls или wc или еще что-нибудь, они строго
предполагают, что стандартные потоки, с которыми нужно взаимодействовать, располагаются по строго
определенным файлам дискриптора. И как в этом случае можно поступить? Для этого существует
системный вызов, который предназначен для создания нового файла дискриптора из уже
существующего. Есть очень старый файл дискриптор под названием DAP, который создает просто копию
файла дискриптора. Зачем он нужен? Непонятно, видимо когда-то очень давно, но сейчас он
используется в некоторой левеси. Более важное значение есть системный вызов DAP с циферкой 2,
который принимает два аргумента. Второй аргумент это номер файла дискриптора, то есть конкретное
число, которое системный вызов должен вернуть. Что делает системный вызов DAP 2? Создает еще
один новый валидный файловый дискриптор, при этом со строго указанным номером,
который вы ему передали. Естественно может быть ситуация, что такой файловый дискриптор у нас
уже был открыт, то есть уже существует. В этом случае он просто сначала закрывается, а затем
создается новый файл дискриптора с тем же номером, который указывает на какой-то другой файл объект.
Казалось бы можно было просто взять выполнить системный вызов close предварительно для какого-то
файла дискриптора, который нужно освободить. Будем считать, что этот файл дискриптора у нас
имеет уже минимальный номер. Дальше вызываем обычный DAP с цифрой 2, но это решение плохо тем,
что будут два отдельных системных вызова и мало ли что произойдет, например между ними,
особенно если многопоточенная программа может что-то произойти, открыться новый файл,
и файл дискриптора будет зал. Системный вызов DAP2 гарантирует, что закрытие и создание
новый файл дискриптора у вас всегда будет одной атомарной операцией. Ну и что полезного в этом
полезного то, что мы можем в качестве второго аргумента указать какие-то стандартные номера
файлов дискрипторов. 0 для стандартного потока ввода, 1 для стандартного потока вывода, 2 для стандартного
потока ошибок и тем самым переназначить. Вот вывод любой производник программы, которая про это
вообще ничего не знает по нашей пайпы, но что-то более осмысленное. Давайте рассмотрим
практический пример использования DAP2. Вот у нас есть создание дочернего процесса. Дочерний
процесс мы создали пайп, затем дочерний процесс у нас заменяется на некоторую внешнюю программу,
для простоты это команда ls, и дальше мы должны вывод команда ls перенаправить канал, ну а дальше
релизский процесс читает данные из этого канала и считает какой кабайт мы причитали и уводит что-то
на экран с некоторым префиксом. Так запускаем нашу программу, вот честно мы получаем вывод что ls нам
вернул 312 байп, как можно убедиться что у нас действительно правильный вывод, но опять же команда ls
перенаправляем вывод на wc с опции минус c. Действительно мы ожидаем получить 312 байп.
Так, за счет чего это происходит? За счет того что перед тем как вызвать команду ls, но при
этом строго после форка, зачем нужно делать отдельные стадии создания процессов и замены
текущего процесса на другую программу, для того чтобы можно было что-то настраивать между форками
и дзеком. Например настраивать лимиты, а еще переназначать файлы дескрипта. И вот в момент
вызова стена вызова DAP2 стандартный поток вывода для процесса, который потом превратится в ls,
у нас превращается в некоторый канал. Здесь кстати я немножко не дописал, в хорошем после DAP2 нам
становится не нужен вот этот файловый дескриптор и если мы не хотим чтобы у команды ls был файл
дескриптер 4 надо его закрыть. Что будет если я не напишу DAP2? Если я DAP2 не напишу,
несмотря на то что канал у меня действительно существует. Канал существует, но ls при этом
продолжает писать стандартный поток вывода вовсе не в канал и поэтому получаем обычный вывод
команды ls на терминал. Данные с канала мы не прочитали, просто процесс завершился и ничего не
прочитали и не смогли посчитать количество об этом. Кстати почему мы этот вывод все-таки можем
наблюдать? Потому что мы когда создали новый процесс у нашего родительского процесса уже есть
какой-то стандартный поток вывода, соответственно дочерний процесс стандартного вывода тоже
унаследовал и честно выполняет запись. Ну и зачем вообще нужны каналы, где они реально используются?
Ну про один из примеров я вам уже сказал это окошко терминала, который создает три канала,
причем всего два канала. Один в который пишет события от клавиатуры, и стандартный поток
вывода и стандартного потока ошибок. Из стандартного потока вывода и стандартного
потока ошибок терминал рисует какой-то текст. При этом первый и второй файлы дескрипторы в
терминале обычно ссылаются на один и тот же пайм, поскольку рисовать терминал многим терминалом
можно все одинаково, хотя бывают терминалы, которые например раскрашивают разными цветами
стандартный поток вывода и стандартный поток ошибок. Смогут по-разному обрабатывать. Ну и взять
любую среду разработки, который вы пишете код, запускаете, на самом деле селайн не является
реализацией компилятора, не является реализацией оплатчика, он просто запускает команду GCC,
Selang, GDB как внешний утилит, при этом использует команду из стандартной поставки вашего
дистрибутива и взаимодействует с ними просто отправкой каких-то текстовых данных, опять же
через обычные потоки вода и вывода или это используется канал. Ну и например взять
какой-нибудь видеоплеер на базе Mplayer. Mplayer это консольный видео-проигрыватель, понятно,
что видеоконтент через каналы гонят, это очень тяжело и так никто не делает, а вот управление
самим плеером, то есть перемывка вперед-назад, звук громче-тише и так далее выполняется опять же
через стандартный поток вода, стандартный поток вывода. Ну и на самом деле примеров очень много,
при этом у каналов есть некоторые ограничения, но во-первых это файловый дескриптор,
соответственно между собой взаимодействовать могут только родственные процессы, которые
например унаследовали эти файлы дескриптора от родительского процесса. Если вы запускаете
например разные вкладки в терминалы, разные программы, которые хотят между собой взаимодействовать,
то они друг по другу естественно ничего не знают и как можно есть все-таки заставить процессы
между собой общаться. Для этого есть специальный случай каналов, который называется именованные
каналы, еще их называют файлы FIFO, First In, First Out. Это специальные типы файлов,
создать их можно с помощью команды mkfifo, мы их создаем с помощью mkfifo какой-то канал.
Вот у нас файл, который имеет размер 0 байт, специальный тип под названием FIFO,
в линуксе немножко по-другому этот стат будет выглядеть, но суть в том, что у нас файл тает
под некоторые FIFO. У файлов типа FIFO есть точно также права доступа, владелец,
группа владельца и так далее. Ну, какой порядок работает с этим файлом? Давайте
попытаемся из него что-то прочитать. Попытаемся что-то прочитать из канала,
вот стенозавкат у нас в подвесе и ждет пока когда эти данные появятся. Мы можем
в другой вкладке терминала взять и что-то записать в наш канал. Записали и теперь мы
в другой вкладке получили это значение. Что будет если мы сначала запишем что-то в канал,
а потом пытаемся прочитать. Вот утилита echo у нас зависает, поскольку она не может открыть
от канала. В данном случае просто системный вызов open при открытии файла ждет пока кто-нибудь
не откроет противоположную сторону этого канала. И после того как мы читаем что-то из канала,
echo у нас завершает свою работу. То есть поведение здесь точно такое же как у обычных
каналов. При этом у нас все-таки у fifa есть ограничение, но и у обычных каналов тоже связано
с тем что они позволяют организовать взаимодействие только двух процессов между собой. Если вы будете
использовать обычный неименованный канал для взаимодействия в нескольких процессах, то вы
никогда не узнаете кто вам данные записал и никогда не узнаете кто у вас данные прочитал.
Для именованных каналов fifa тут ситуация та же самая. То есть вы можете попытаться читать
за одной вкладке. Можете попытаться читать еще из какой-то вкладки. И теперь делаю запись какой-то
канал. Вопрос где у нас данные были прочитаны? Во вкладке номер 1 или во вкладке номер 3?
Давайте смотрим. Вкладка номер 3 вывели, вкладка номер 1 ничего не вывели, но работу завершили.
То есть поведение здесь считается неопределенным. Кто случайным образом первый смог прочитать,
тот и прочитал. Поэтому для организации взаимодействия нескольких процессов каналы как
именованные уже не подходят. И здесь надо использовать чуть более сложный механизм,
который называется SOPET. Про SOPET у вас будет отдельно. Ну и последнее ограничение связанное
с каналами. Опять же немного забегая вперед, в современных системах Linux и BSD macOS есть разные
механизмы, которые позволяют работать с большим количеством файлов и скрипторов и сделать
достаточно быстро, поскольку они обрабатывают события готовности файлов и скрипторов к чтению
записи и открытии. Они работают с разными файловыми скрипторами, в том числе с каналами,
но поддерживают неполный набор событий. Например события готовности к чтению, готовность к
записи. Они умеют обрабатывать для каналов, а вот события связанные с закрытием канала
противоположной стороной, они уже отследить не могут. И здесь есть некоторые функциональный аналог
канала, который называется SOPETPR. То есть пара из двух локальных SOPET, но поддерживаются не всеми
функционными системами. То есть Linux и BSD mac хорошо замечательная. Если взять какую-нибудь произвольную
старинную UNIX-систему, то такого системного вызова там может быть. На этом все. Вот Рудалия
от Сбера уже научился рисовать достаточно реалистичные картинки. Вот эту картинку он
нарисовал по запросу Парик. Если у вас вопросы. Здравствуйте, Виктор Вадимович, можно задать вопрос
о записи. Где она будет? Я эту запись кинул в слаг. Тут еще в чате вопрос, а нет никакой очереди?
То есть FIFO? Для FIFO тут действует тот же самый порядок, что и для обычных канала. То есть данные
размером менее, не превышающие размер кусочка 4000 га за 6 байт, они не перемешивают. Ну а дальше,
кто первый случайно успел прочитать, тот прочитал. А следующая лекция также будет записываться,
верно? Так, следующая лекция уже будет полноценная в аудитории. Насчет записи это скорее вопрос к
тому, кто к лекторию фотомоиды. То есть конечно я могу делать запись, но у них это получается
обычно лучше. Но с этого вместо я буду еще снимать акост, как лектория. В общем, стандартная съемка
аудитории, все как обычно. Есть ли у вас еще содержательные вопросы?
Будут ли выкладываться на презентации перстепенно или только перед? Я могу это делать,
но напоминаете мне, что периодически презентации могу выкладывать тоже.
Хорошо, я понял запрос. Сейчас тогда презентацию я могу скинуть прямо сейчас в iCloud, а видео
с некоторым лагом, поскольку Zoom требует некоторую обработку. Если бы нужно было еще выложить на Google
диск. Ну ладно, раз вопросов нет, тогда завершаемся.
