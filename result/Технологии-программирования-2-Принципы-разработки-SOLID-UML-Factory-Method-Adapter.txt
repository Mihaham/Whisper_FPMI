Всем доброго вечера! Мы с вами продолжаем курс лекций по технологиям программирования.
Сегодня у нас будет первая более конструктивная лекция, нежели чем подная.
У меня есть два организационных объявления, которые необходимо запомнить.
Кто еще не зарегистрировался в систему?
Надо зайти в наш замечательный чат, заполнить форму.
Там придут два логина.
Первый логин – это замечательный сайт, который называется Ahcheck.
Будьте здоровы!
Надо будет его переименовать на AppShift.
Или логотипом его сделать, мне нравится.
Второй – это NakedLab, через который будут сдаваться домашние задания.
Сразу скажу.
Ищите, если что, в папке spam.
Если у кого-то права сюда не придут, но вы уверены, что заполняли форму,
можете использовать следующую вещь.
Там есть формочка «Восстановить пароль».
По почте можно восстановить пароль и узнать свой логин.
Придут креды для восстановления всего.
И второе – у нас будет первое техническое задание.
На самом деле оно будет нулевое тестовое.
Мы его подготовим к концу недели.
Там нужна на сайте одна техническая вещь.
Вы должны узнать, кто у вас будет проверять задание.
Это пока что в системе есть, но она на фронт-энде еще не реализована.
Так, есть вопросы по организации?
Какие-нибудь?
Тишина.
Паника, давайте вспоминать, что мы узнали с вами в прошлый раз.
Я что-то ничего не слышал.
Что такое?
На самом деле мы с вами не говорили про то, что такое паттерн и атипаттерн,
потому что мы будем сегодня про это говорить.
Да, хорошо.
Что мы узнали про проектирование?
Что?
Да, мы узнали с вами, что такое закон Диметры.
Мы с вами поняли, что такое каплинг и что такое кахежим,
и какие связи именно есть между ними.
И поняли, какие могут быть наметки на то,
что наша архитектура хорошая или не очень.
Вот эти аспекты мы с вами посмотрели,
но вообще, как некоторые люди выразились, была вода.
Сегодня будет воды меньше,
и мы с вами начнем разговаривать про технические вещи.
Значит, мы с вами узнали про критерии хорошей архитектуры
и с вами заботили за закон Диметры.
Значит, план на сегодняшнее занятие
это разобрать вот эти все аббревиатуры.
Вот. Плюс еще узнать, какие существуют паттерны и атипаттерны.
Начнем мы с вами тоже про них говорить
и посмотрим про хорошие и плохие примеры.
Так, значит, смотрите. Поехали.
Солид. Это, по-хорошему говоря,
такая надстройка над ООП,
которая позволяет, так или иначе,
сохранять хорошую архитектуру.
То есть, если мы будем
использовать эти принципы,
то мы с вами обезопасим себя
от выстрелов в ногу при дальнейшем рефакторинге
либо при дальнейшем расширяемости архитектуры.
Мы же хотим с вами, чтобы у нас архитектура была расширяемой
по количеству кода и всякого такого кода.
Смотрите. Солид это на самом деле
пять букв. Это абревиатура.
Она включает в себя пять принципов.
Давайте перечислять их. Первый принцип
это сингл респонсибилити принцип.
Нет, не получится.
Это последний уровень.
Сингл респонсибилити принцип.
Давайте подумаем.
Есть ли наметки на то, что это такое?
Приблизительно так.
Второй принцип.
Open-closed принцип.
Что-то открыто, что-то закрыто.
Тоже разберем.
Третье это принцип замены Лисков.
Это Барбара Лисков.
Пожалуйста, не склоняйте эту фамилию.
Напоминаю правила русского языка.
Иностранные фамилии женского рода не склоняются.
Это женщина.
Четвертое это интерфейс segregation principle.
Принцип разделения интерфейсов.
Это dependency inversion.
Принцип обращения зависимости.
Сегодня мы эти пять штук разберем.
Я нашел статью на хабре,
на которой это все пояснено в виде картиночек.
Поэтому мы с вами будем смотреть на картиночки.
Мне кажется, это будет более интуитивно.
Некоторые паттерны мы с вами разберем.
У нас будут примеры паттернов,
у которых есть те или иные принципы.
Что, поехали?
Первый принцип, который у нас есть,
это single responsibility principle.
В нем суть состоит в следующем.
Один класс играет всегда одну роль.
Тут есть картинка с роботом,
которая говорит, я повар, садовник, маляр и водитель.
Справа у нас этот замечательный робот,
который представляет собой класс разбин на четыре роли.
Он повар, я садовник, я маляр, я водитель.
Наверное, вы сталкивались с мемом
под названием тыж-программист.
Да, ну вот.
Да, в общем, тыж-программист
нарушает принципы единой ответственности.
Вы сами понимаете, хотя по факту наш курс
предназначен для того, чтобы вы научились
использовать этот принцип в самом себе.
Чтобы мы выполняли разные ответственности.
Смотрите.
У этого принципа всегда есть разные примеры.
Значит, он называет, один класс играет одну роль,
один класс выполняет одну функцию.
Но если мы будем переводить это
с точки зрения классического ВВТ,
то один класс выполняет одну функцию.
У каждого класса должен быть один метод.
Да, но это неправда.
Функцию с точки зрения того,
что он именно должен делать.
Смотрите, давайте подумаем.
Вот у нас был cohesion и coupling,
что позволяет осуществить
single responsibility principle.
Да, это по факту пример high cohesion.
Потому что у нас есть четыре отдельных класса,
по факту четыре отдельных роли,
которые могут быть между собой не связаны.
Да?
Я не знаю, если вы представите это все дело как граф,
то есть у нас есть
граф на четырех вершинах,
у нас с вами есть связи между объектами.
Каждый из этих связей
выполняет какую-то сущность,
тут сущности, тут сущности,
а здесь связи какие-то слабые.
Да, то нелогично, чтобы эти все сущности попадали в один класс.
Вот.
И мы как раз в следующий раз будем с вами говорить
про UML диаграммы,
и при помощи UML диаграмм это можно будет легко отследить.
Так, вопросы по вот этому принципу?
Опять же, можете придумать...
Тут нельзя сказать, что есть хороший пример,
можно придумать антипример.
Помните в прошлый раз пример с университетом?
У нас был большой университет,
который выполнял много всего.
Да, вот это антипример,
Single Responsibility Principle.
Да, да, все, но много и долго.
Буква B бюрократия, как говорится.
Так.
Значит, второй пример,
второй принцип, это Open-Close-принцип.
Значит, в чем он говорит?
Он говорит, что класс должен быть открыт для расширения,
но закрыт для модификации.
По факту, если мы с вами будем переводить на русский язык,
это означает следующее, что если вы написали какой-то класс,
если вы хотите поменять какую-то функциональность,
пожалуйста, не меняйте в нем код.
Старайтесь сделать свою архитектуру так,
чтобы можно было отнаследоваться от этого класса
для того, чтобы реализовать новый функционал.
Все понимают, что такое наследование?
Или есть те, кто не знает, что такое наследование?
Ну...
Ну, хорошо.
Смотрите, робот такой, что...
Ну, пример робота на картинке, что мы с вами видим.
Робот умел резать что-то.
Мы представим себе...
Хлеб он резать умел.
Значит, для того, чтобы он научился красть,
его нужно отправить на техобслуживание,
по факту изменить код, для того, чтобы он научился красть.
А теперь представьте себе, что у нас был робот версии X,
и мы с вами делаем версию X плюс 1,
у которой просто, помимо текущего функционала,
добавляется еще один функционал.
То есть мы с вами расширили функционал,
и этот робот теперь умеет еще и красить.
Примеры опять же мы с вами увидим.
Они достаточно элегантные,
поэтому тоже немножечко забежим вперед.
В будущем посмотрим примером.
Понятен ли этот принцип?
Если вы хотите в классе что-то поменять в коде,
подумайте, а может вам нужно сделать наследника,
который меняет этот функционал.
Не совсем.
Эти принципы сильно похожи,
а функциональность с точки зрения определенного человека.
Допустим, у нас был человек,
который выполнял роль X,
допустим, замерял температуру,
но в принципе он может еще и повысить температуру
какого-то объекта.
У него цель работа с объектом, который
по факту связан с температурой.
Он работает в одной области, это замечательно.
Да, резать и красть это все-таки разные домена.
Это хорошее замечание.
Возможно, что если у нас есть базовые функции,
нам надо наплодить, допустим, пример,
несколько локализаций сделать.
Локализация – это перевод на другие языки.
То мы в принципе с вами можем подготовить некоторые шаблоны,
а потом сделать наследники,
где в каждом из шаблонов реализовать определенный язык.
На русский язык, на французский, на английский, на китайский и так далее.
Нет.
Делать отдельных наследников.
Так.
По этой штуке понятно?
Угу.
Хорошо.
Следующий паттер.
Следующий принцип замены барбаралисков.
Причем он заключается.
Представим себе, что у нас есть класс B,
который наследуется от класса A.
Говорим следующее.
Если мы хотим заменить A на B,
то он не сломает логику функционала.
То есть это принцип замены типов.
Представим себе вот такую картинку.
Представим себе, что у нас есть Бористо,
который называется поколением.
И отец говорит,
сделаем кофе.
Тот говорит, давайте, я делал своих, мне сын сделает.
А сын не понимает, как делать кофе.
То есть он начинает делать какие-то действия,
и оказывается, что эти действия не делают кофе.
Такое может быть.
Что-то перепуталось.
Я вычитал интересный пример.
Интересное следующее.
Знаете утки? Животные такие есть.
А теперь представьте, утка квакает,
утка крякает, утка летает.
Кажется, что это утка.
Но прикол в том,
что утки есть замечательный наследник.
Если...
Дак.
А это наследник класса.
А у нее может быть следующий.
Класс.
Давайте я назову фейк дак.
Знаете, есть такие газетные утки.
Образно.
Это же утка.
Только проблема в том, что она кричит,
квакает фейковыми новостями,
летит там, не знаю, по телеге какой-нибудь,
либо еще по другим мессенджерам.
А плавать я не знаю. Она не умеет.
Да, мы пишем, утка, пожалуйста, прилетит туда-то,
прокрякает вот, а потом отплыви обратно.
Значит, фейк распространяется, да.
То есть, фейк куда-то летит, фейк распространяется,
а уплыть он никуда не может. Просто некуда.
А утка там на батарейках, которые...
То есть, мы ее зарядить забыли, и все, у нее энергия закончилась.
Вот такой принцип.
То есть, и на этом основаны всякие интерфейсные штуки.
То есть, если у нас есть интерфейс...
Я сейчас, кстати, проговорю про то, что такое интерфейс.
Представьте, у нас есть...
Ну, давайте сейчас пока подоверим абстрактный класс.
А потом, если у нас с вами нарушается принцип Барбары Лисков,
то, скорее всего, у нас где-нибудь возникнет следующая вещь.
Ив с костылем, либо у нас пойдет какой-нибудь динамик каст.
Да? Чем плох динамик каст?
Ладно, долгий.
Но вам придется именно писать косты для определенного подкласса.
Да, это не очень хорошо.
Да, это не очень хорошо.
Да, это не очень хорошо.
Вот, это как выявить нарушение принципа Барбары Лисков.
Это значит, что нам надо архитектуру менять нашего приложения.
А если у нас...
Ага.
Да, да, это принцип нарушения Барбары Лисков, это классический пример.
Нарушение принципа, и это надо как-то обрабатывать в отдельном случае.
То есть, опять же говорю, надо стараться предотвратить нарушения принципа Барбары Лисков.
Если у нас есть допустимый каст,
то мы можем shelf-
то есть опять же говорю, что надо стараться придерживать всех этих
концепций, но не стараться при этом им идти как по догмю.
Пример эллипса и пример окружности. У нас есть эллипс, у нас есть окружность, да?
Окружность это частный случай эллипса, но если мы заменим окружность на эллипс,
то у нас скорее всего всякий функционал просто поломается, потому что у эллипса что там есть?
Ну периметр, стяжение, большая и малая полуосикс, энтриситет и ежесними понятия.
Да и более того, я вот в одном проекте нахожусь, в котором вы не поверите,
функциональность там, грубо говоря, космические объекты, есть орбиты,
есть круговые орбиты, есть эллиптические орбиты. И там чуть-чуть поменять круг на эллипс,
чуть-чуть, там, энцентриситет чуть поменять, там вообще траектория объекта сильно меняется,
то есть это там баг критический, то есть нужно работать либо в режиме связанных с эллипсом,
либо в примере связанном с кругом. Вот, это косяк, который надо уметь обрабатывать.
Так, хорошо, понятен принцип Лисков?
Так, хорошо, вопрос. По логике да, но надо делать это грамотно. Возможно, что это нужно делать...
Да, возможно, это нужно через какие-то интерфейсы делать отдельно. Я сейчас как раз буду говорить про то,
что такое интерфейс. Ну, это хороший вопрос, подумать как. Значит, смотрите. Наверное,
вы все сталкивались с ключевым понятием абстрактный класс, да? Насколько я понимаю,
группа 211 должна была столкнуться с понятием интерфейса, поскольку у них была джава.
Да? Вопрос остальные, вы знаете, что такое интерфейс или мне рассказать лучше? Да, это на самом деле
интерфейс. Вот смотрите, абстрактный класс это по факту шаблон, в котором некоторые методы могут
быть не реализованы. Да, по факту. А интерфейс это немножко другая вещь. Это вещь, которая говорит о том,
какие роли должны быть присущи данному объекту. Роли. В них нету реализации этих ролей. То есть по
факту интерфейс это сущность, у которой прописаны методы. Они являются публичными. Никакой из методов
не реализован. И в большей части случаев у нее нету никаких полей. Там будет еще слайд посвящен этому.
Сущностно отличается. То есть по факту абстрактный класс это какой-то тимплейт для того, чтобы от него
дальше наследовался класс. А интерфейс это больше ролевая вещь. То есть вот примеру. Такой абстрактный
класс. Студент это абстрактный класс. А обучающийся это больше про интерфейс. Потому что у обучающегося есть
роль какая? Учиться. При этом он может обучаться где? Он может обучаться в УЗе. Он может обучаться,
я не знаю, на ютубе на курсах. Может обучаться в школе. Может обучаться еще на курсах профессиональной
переподготовки. И вот в джаве особенность в том, что она не шена замечательной вещью. А именно множественного
наследования. В джаве нет множественного наследования. Живите теперь с этим. Вот. А чем он заменяется?
Он заменяется принципом разделения интерфейсов. Значит смотрите. Суть в чем? Суть этого принципа
заключается в следующем. Что не надо ставить клиента в зависимости от методов, которые он не
использует. То есть старайтесь сделать так, чтобы если у вас есть какой-то объект, какой-то экземпляр
класса, какой-то класс, а если у вас нету каких-то ролей, которые он не должен исполнять, выкидывайте
их. То есть по идее, я не знаю, пример там зарядник, зарядка. Там написано на самом деле, если внимательно
посмотреть презентацию, что он там должен делать. Он выполняет три роли. Вот почему бы эти три роли не
разбить на три отдельных интерфейса? И тогда мы сможем сказать, что наш объект будет реализовывать
те или иные интерфейсы. Да, тут еще сущность в том, что эта вещь не говорит, мы не наследуем интерфейс,
мы реализуем интерфейс. То есть функция Implements. И классический пример, который здесь можно привести,
это Java. Собственно про нее мы и говорили. Здесь нет множества наследований, здесь есть наследование
определенного класса и, возможно, имплементация некоторых интерфейсов. Значит, те люди, которые
внезапно, может быть, в какой-то момент времени читали про Hadoop, это система обработки больших
данных. Знают, что есть там замечательный класс под названием IntWritable. И смотрите, какие интерфейсы
он реализует. Он реализует интересный интерфейс для того, чтобы в нем было работа. Инты, какие роли есть у
Инта? Мы должны сравнивать. Логично? Значит, intWritable должен реализовывать тип comparable. У comparable
есть функция compare. Значит, если это у нас writable, это значит, что он должен записывать какие-то данные,
поэтому мы имплементируем интерфейс под названием writable. И третий концепт. Возможно, что нам нужно
сравнивать эти значения как строки. И тогда мы должны реализовать интерфейс под названием
writable comparable. То есть мы с вами наш класс разбили на набор интерфейсов. Вот. И пример такой. Давайте
подумаем. Если нам нужен будет только int comparable, то что мы с вами сделаем? Какие нам интерфейсы
понадобятся? Из этих трех? Ну, наверное, тот просто comparable. Если нам, допустим, нужен будет какой-нибудь
float writable, либо string writable, ну, наверное, там надо подумать, какие интерфейсы нам понадобятся,
но в целом суть должна быть такой, что мы просто берем и раскладываем все на максимальное количество
интерфейс. Как вы думаете, в чем проблема? Ну, у нас может быть каша из интерфейсов. Огромная. Ну,
долго работать это понятно. Ну, классический stack trace на тысячу вызов. Ну, да, в общем,
громоздкость кода. Поэтому, на самом деле, я сразу скажу, что про solid надо думать практически в последний
момент. Так, понятен ли пример интерфейс segregation principle? Вот какое-то оживление. Что, двигаемся к
последнему? Принцип обращения зависимостей. Значит, суть в чем? Тут он сложный. Давайте проговорим
сначала. Модули верхнего уровня не должны зависеть от модулей нижнего уровня. То есть, если у нас x
зависит от y, то они не должны между собой зависеть именно как один использует напрямую второй. Второй
модули должны всегда зависеть от некоторых абстракций. Ну, по факту, от некоторых интерфейсов либо
абстрактных классов. Третье, абстракции не должны зависеть от деталей реализации. И четвертое,
детали должны зависеть от абстракций. Это самый сложный принцип, поэтому я подготовил к нему примеров.
Смотрите, тут замечательный робот, который хочет порезать пиццу. Ровно вот так делать не надо. То
есть, не надо к руке присобачивать резолку для пиццы. Почему? Да, она зачастую не нужна. Возможно,
надо резать чем-то другим. Тогда, смотрите, что мы делаем. Видели, наверное, протезы заменяемые есть.
Мы берем, делаем отверстия для протезы, которые обладают тем или иным интерфейсом. Ну, по факту,
для того, чтобы засунуть этот. Ну, представьте, что у нас робот-киборг, которому надо заменить руку.
Он берет. Мы готовим отверстия по специальному протоколу. Это протокол, по факту, это интерфейс.
И мы подключаемся к определенному интерфейсу. То есть, готовим специально втулки, точнее,
определенные резолки. Возможно, что там теннисный мячик, теннисная ракетка будет,
которая будет играть в теннис, либо еще что-то. И мы заменяем это все дело на вот такой вот интерфейс.
Да, я не знаю, видно тут под мупой этот есть втулка, в которую мы вставляем. То есть, у нас получается
легко заменяемость в данном случае. И давайте еще один пример. Вот представьте себе, что у нас
есть вот такой вот дерево узлов модулей. Опять же картинка сетасхабра. У нас есть А, дальше у нас
идут классы ВС. И, допустим, у нас есть какая-то коровая модель ядра. То есть, у нас есть функция Е,
которую вызывают как В, так и С. И проблема в том, что, представьте себе, что нам надо в С изменить
функционал Е. Тогда что произойдет, если мы в С попробуем изменить функционал Е? Да, у нас В может
сломаться. То есть, у нас В не может работать над Е. Первый вариант, который может быть сделан,
это давайте мы создадим типа абстрактный класс, а дальше Е отнаследуем от абстрактного класса,
чтобы связать В и С. Но тогда с этим может быть проблема, что когда мы в следующий раз начнем
с этим работать, мы не сможем понять, кто главный, С или В. Поэтому делается следующее. Смотрите,
мы по факту берем и разворачиваем зависимости. Видите dependency and virtue. То есть, у нас стрелочки
идут теперь не в одну сторону, сверху вниз, а есть стрелочка снизу вверх. То есть, мы говорим,
для В какой интерфейс нам нужен для того, чтобы работал В, и какой интерфейс нам нужен для того,
чтобы работал С. А потом Е по факту будет имплементировать эти интерфейсы. То есть,
чтобы и тем, и тем угодить. Таким образом, у нас нижний уровень не зависит от верхней детали.
Смотрите, абстракции не зависят от детали, детали не зависят от модулей высшего уровня,
а они все взаимодействуют при помощи некоторых абстракций. Красота? Ну да, по крайней мере,
жить можно. Вот, в общем, пять принципов у нас есть. Кто-нибудь вспомнит какие? Поехали.
Single responsibility. Каждый класс собирает одну роль. Open class. Класс закрыт для модификации,
открыт для расширения. L. Это по факту подмена типов не меняет логики. А И? Interface segregation.
Стараемся развивать максимально все на интерфейсе, если что, выкидываем имплементацию интерфейса.
Independence-inversion. Вопросы по солиду? Да, в данном случае, да.
Какой из них? Да. Ну, то есть, следует ставить за клиент зависимости от методов, которые он не использует.
Лучше это делать через интерфейс, чтобы, если что, выкинуть имплементацию интерфейса.
Да, если что, презентацию уже на Google Drive должно быть. Может смотреть. Что, движемся дальше?
Я гни. Расшифровка этой аббревиатуры. Знаете какая? You ain't wanna need it. Вам этого не надо.
Смотрите, из такой вещи, представьте себе, мы хотим, опять же, мы с вами про фиксики говорили.
Мы с вами говорим про фиксики. Мы с вами компания по созданию фиксиков. Ну, образы по фиксикам.
Ну, и давайте вы сейчас кто-нибудь начнет перечислять функционал. Давайте. Что мы должны сделать в этом?
Ну вот, представим себе, что у нас сегодня очень все активны и предложили 150 идей.
Датчик движения, голосовой ассистент, виртуальная реальность, что-то еще.
Мета-вселенная, про которую мы тоже с вами говорили, фиксика-вселенная.
Это называется брейн-шторм. Ну, образно говоря, когда мы все выкидываем идеи, мы все их записываем на доску.
А дальше нам нужно отсечь лишнее, то, чего нам не надо.
На самом деле, если говорить про составление технической документации или технических требований,
есть такое, я не помню сейчас, как называется, продукт-реквайерменс, специальный документ, требование к продукту.
Этот документ нужен для того, чтобы, если ваш мой дядя-начальник пришел и сказал,
я хочу, чтобы у меня пони радугой, единороги радугой кое-что делали, чтобы сказать,
так, чувак, у нас в требованиях документов прописано, что мы этого не делаем.
Да, то есть мы делаем в защиту от того, что человек хочет нам направить.
Реально, такие кейсы бывают. Не зачастую вам придется их делать позавчера.
Надо было сделать их позавчера.
Типичный кейс. То есть нам не нужно делать лишних вещей, по факту.
Ладно, смотрите, предположим себе, что мы выкинули лишние идеи.
То есть не городите, грубо говоря, о лишних сущностях, называется.
Ладно, мы оставили некоторый функционал.
И дальше мы встречаемся с и понятием под названием кейс.
Это не поцелуй, если что.
Это называется stupid-simple-stupid.
Картинка, которую я нашел, кто-нибудь сможет дать афоризм к этой картинке?
Ну, типа того. Нет, скорее всего, Гарри Поттер вторая часть это антитеза к тому,
потому что они опоздали на поезд.
А здесь товарищи решили побежать впереди провоза.
То есть начали городить лишние сущности, лишние абстракции.
Вот мы с вами тут про солид послушали. Начали городить солид.
Не подумав об этом.
Получается проблема состоит в том, что надо стараться делать какие-то вещи
достаточно простым способом.
Для того, чтобы, допустим, мы смогли зарелизить с вами первую версию.
И ко мне в прошлый раз подходили и говорили про вопрос,
а что же касается тех долга?
Да, ну, проблема в том, что это увеличивает технический долг,
который мы должны с вами сделать.
Но надо не забывать, что после киса идет на самом деле еще следующая абстракция,
следующий концепт.
То есть стараемся первую версию реализовать достаточно просто.
Вот, иначе можно закопаться потом.
Так, поняли вот эту вот вещь?
Вот.
Драй.
Следующим идет драй.
И это расшифровывается следующим образом.
To not repeat yourself.
Ну, по факту это бас, но заметьте, в каком моменте она у нас с вами возникает.
Она возникает после того, как у нас уже прошел simple stupid.
Ну, тут виден бард, который пишет 500 раз одно и то же слово.
Вот, так делает.
Да, есть такое.
Вот, смотрите, значит, вот это замечательный бард, который 500 раз рисует.
И на самом деле тут я почитал некоторые холиваронных обряд, пока готовился к ленте.
И они говорят следующее, что драй это на самом деле не база.
То есть помните, мы рассматривали всякие каплинги в прошлый раз.
Вот драй говорит про то, что не надо делать контент каплинга.
То есть прямо копировать вот именно все.
Что-то в определенном контексте, возможно, да.
Потому что, ну, по факту пока мы будем привязываться к интерфейсам,
да, вот это все мы нарушим принцип keep it simple stupid.
Вот, то есть тут надо искать компромисс.
И в кисе вот проблема в том, что, допустим, у нас была проблема в том,
что мы продолбали один из важных релизов в декабре месяце в компании.
Вот, в связи с тем, что мы решили наградить всяких сложных сущностей,
а потом у нас просто воспроизводимость не появилась и все.
Ну, это было связано с машинным обучением.
Так, теперь что касается картинки.
Мне она очень понравилась.
Она говорит про то, в какой стадии их надо исполнять желательно.
То есть сначала нужно выкинуть лишнее, потом сделать это максимально просто,
а потом только уже сгруппировать и не повторять лишнее.
Вот, мне вот эта понравилась картинка.
Значит, что-то я хотел рассказать еще.
Сейчас дайте-ка я вспомню по этой части.
Да, да, да, сейчас.
Блин, забыл, черт.
Ну ладно, если что, я вспомню, тогда покажу.
Так, ага.
Ну, здесь логически мы можем сделать перерыв, тем более у нас там 38 минут прошло.
Давайте тогда отдохнем минут пять.
Может быть, я вспомню, что я хотел рассказать.
А?
Что?
Нет, не про ВЭД.
ВЭД это, если что, аббревиатура.
Right everything twice.
Все, отдыхаем пять минут.
Так, давайте продолжать.
Значит, смотрите.
У этого принципа появилось достаточно большое количество вопросов.
Значит, вы не поверите.
Ну, давайте я немножко разрекламирую яблочную продукцию.
Хотя этого особо не хочу делать.
Вот как раз в яблочной продукции максимально реализован пример dependency inversion.
Почему?
Потому что если внимательно посмотреть на эту замечательную конструкцию,
то мы с вами здесь видим на самом деле...
Ну, я вижу тут три разъема.
Я не знаю, у кого как.
И причем один из разъемов Type-C USB,
от которого мы можем заряжать ноутбук,
можем выводить информацию на экран, если другой конец шнура хороший.
И третье, что мы с вами можем делать.
Ну, вот я, допустим, проектор подключил через отдельную блокстанцию.
Правда, смотрите, проблема в чем этой штуке.
Что приходится по факту использовать дополнительные классы.
Дополнительные обертки.
Да, да, с этим проблема есть.
То есть мы понимаем с вами недостаток этого подхода.
Вот.
И появлялись вопросы про интерфейсы.
Ну, мы, я думаю, тоже сейчас разберем.
Значит, смотрите.
На самом деле мы с вами уже увидели,
что какие-то штуки у нас с вами уже были видны.
Точнее, этот.
Какими-то мы уже диаграммками пользовались,
поэтому пора ввести понятие UML.
Значит, UML расшифровывается как Unified Modulated Mail Language.
То есть это язык универсального моделирования объектов.
Знаете, как раз, если отматываться в истории,
люди фанатели от того,
а давайте мы придумаем искусственный интеллект.
Не знаю, будем все максимально унифицировать.
То есть придумаем сильный искусственный интеллект.
Придумаем так, чтобы код не мы писали,
а мы рисовали какие-то диаграммки,
а это дальше воплощался в код,
в некоторых местах сейчас стерилизованы.
Хотя это...
Я не знаю, наматлог будут доказывать или нет,
что это сложно сделать.
Вот.
Но, в общем, люди старались делать,
и мы придумали язык UML.
В принципе, для наших целей
он нужен для того, чтобы мы с вами друг друга понимали.
Потому что здесь, допустим,
есть одни люди, которые пишут на Python,
другие на плюсах, третий на JavaScript,
четвертый, я не знаю, еще на каком-нибудь там
еще каком-нибудь ОПшном языке,
и нам надо их всех скастовать.
И дальше, возможно, объяснить бизнесу.
То есть нам же нужно найти с вами инвесторов,
которые проинвестируют нам фиксиков, да?
Как объяснить им, что это важно?
Вот. Ну, надо тоже рисовать диаграммы.
И вот, мы сегодня рассмотрим первый тип диаграмм,
который связан именно с диаграммами классов.
Значит, да, поэтому будем вводить обозначения,
они будут полезны и на семинарах,
когда мы будем с вами рассматривать разные паттерны и антипаттерны.
Значит, знакомьтесь, класс.
Здесь, на самом деле, все в нем подписано.
Значит, вот этот вот квадратик — это класс.
Замечательно, да?
Что мы с вами с ним видим?
Сверху мы что с вами видим у этого класса?
Поля, да.
А снизу?
Методы.
Да, поля и методы.
При этом, смотрите, что означают...
У каждого класса есть некоторые модификаторы доступа.
Как обозначаются у нас приватные поля и методы?
Минусиком.
Публичные поля?
Плюсиком.
То есть, если метод у нас публичный, то это плюсик.
Если у нас метод или поле приватный, это минусик.
Так, что тут еще есть? Интересно.
А протект как изначается? Плюс-минус?
Да, мне Иван пинал за то, что я должен был это нарисовать,
и не нарисовал.
Решетка.
Протект.
Если, значит, те, кто понимают джава,
если здесь будет ничего,
я напишу это как пустое множество,
то это специальный модификатор доступа, который есть в джаве package-private.
На джаве рассказывали, что бывают такие?
Лично.
То есть, это приватные пределы под дерево, так сказать.
Так, и есть еще подчеркивание.
Видите, функция метод, который подчеркивает.
Это статические методы, так обозначается.
Вопрос. Что такое статический метод?
Да, который может быть вызван без создания гиперакласса.
Так.
На этом слайде понятно все?
То есть, у нас есть класс, у нас есть поля, у нас есть методы.
У нас с вами есть, что еще?
Модификаторы доступа.
Да, и, собственно, конструктор класса обозначается просто как обычно.
То есть, название этого класса,
если у нас название метода совпадает с названием этого класса,
то это конструктор.
Это еще бывает, приписывают, типа, у нас есть класса,
и пишут вот такую вот вещь.
Конструктор пишут.
Можно в некоторых версиях этой нотации встретить.
Ну, то есть, угловые скобки двойные и конструктор.
Так, с классом разобрались.
Да?
Так, ой, чуть поехал, блин.
Эй, блин.
Так.
Рубрика фиксов в прямом эфире.
Так, так.
Поправили.
Значит, как могут классы между собой взаимодействовать?
У нас есть два класса.
У нас с вами есть пример.
Колесо и машина.
Смотрите, что у нас написано.
По факту, эту диаграмму можно читать так.
У колеса, ой, наоборот, у машины, сколько колес?
Четыре.
Как мы это с вами поняли?
Не, у диаграммы есть.
То есть, смотрите, в диаграмме всегда есть количество объектов на связи.
То есть, смотрите, машина одна.
На одну машину, здесь, если мне указано, указаться один,
приходят четыре колеса.
Ага.
Вот.
А при этом, смотрите, можно писать разные вещи.
Можно писать звездочка.
Так, товарищи, кто знает, что такое звездочка?
Какой пример у вас был до этого?
Матлог.
Что на матлоге звездочка обозначает?
Итерация к линии, да.
Это значит, что этот объект может повторяться любое число раз.
От нуля до бесконечности.
Вот так вот.
Можно обозначать вот так вот.
Одна звездочка.
Это значит, хотя бы один объект.
Можно обозначать так.
Хотя лучше обозначать вот так вот.
Это пример не очень хороший.
Сколько пальцев на руке может быть?
При некотором сущении обстоятельств.
Так.
Не, я про вот это вот.
Вот.
Причем в меньшую сторону это зачетует производственные травмы.
Вот.
А теперь смотрите.
Значит, два класса могут объединяться просто стрелочкой.
Это значит, что они как-то связаны.
А бывает такая штука, что мы рисуем это все дело либо с вот таким ромбиком.
Либо с таким ромбиком.
Не спрашивайте, почему это придумали.
Вот.
Но это показывается на самом деле следующее.
Если мы с вами рисуем, это означает, что объект A содержит в себе объект B.
То есть B является частью объекта A.
То есть колесо является составной частью машины.
Если у нас нарисован закрашенный ромбик, это означает интересную вещь.
Это означает, что если один из объектов убрать, то второй не поедет.
Как известно, машина без колес не поедет.
Я не знаю.
Ну, без всех-то вряд ли поедет.
Это означает, что это незаменимая часть.
Значит, агрегация.
Это класс состоит из студентов, но при этом студенты могут быть в других классах.
И могут быть вообще без группы.
Вот. Изображается без ромба.
И теперь смотрите еще раз про интерфейс.
Спрашивали все на перерыве, поэтому тут веселая готовка.
Интерфейс.
Он делает следующее.
Он исполняет роли.
У него есть только методы, и они являются публичными.
И у него не может быть никаких полей и реализаций.
Если есть поля или реализация некоторых методов, то это автоматом абстрактный класс.
То есть это уже объект сущностный, а не ролевой.
Как обозначаются интерфейсы?
Интерфейсы обозначаются квадратными скобками.
Интерфейс.
Ой, угловыми.
Интерфейс.
Тут эта фигура.
И видно, что у него есть только роль вычислить площадь.
При этом реализация интерфейсов выполняется следующим образом.
Вот так вот.
И стрелочка.
Вот такая стрелочка.
Пунктирная.
Это называется имплементация интерфейса.
Имплементация интерфейса.
Если у нас есть имплементация интерфейсов, то мы должны предоставить реализацию для всех ролей, которые были описаны в интерфейсе.
Так, стало ли понятней про интерфейс?
Чего?
Не-не-не.
Никогда.
Но если мы наследуем интерфейс, то мы должны реализовать все его роли.
Вот.
Если вы хотите реализовать, допустим, не все его роли, это значит, что надо разбить интерфейс на несколько интерфейс.
Так, вопросы по интерфейсу.
А?
А?
А?
Да, можно.
Но при этом абстрактный класс отнаследоваться от интерфейса в принципе может, а вот наоборот не может.
То есть интерфейс отнаследоваться от абстрактного класса не может.
Вот, тонкая разница, ее придется почувствовать.
Значит, смотрите.
Ой, кажется, шокальная картинка.
Значит, абстрактный класс.
Как обозначается?
Значит, на самом деле здесь тонкая-тонкая разница.
В UML'е предполагается, что если класс абстрактный, то его название написано курсивом.
Да.
Вот такая аннотация.
Да.
Не, ну можно писать в квадратных скопах абстрактный класс.
Вот.
Анаследование рисуется другой стрелочкой.
Вот это наследование.
Вот это реализация интерфейса.
Ага.
А что такое загнутый угол?
А, загнутый угол — это комментарий.
Ну, обычно в них могут писать реализацию функций, которые там, которые есть у данного.
То есть здесь пример такой.
У нас есть животное, которое может перемещаться в точку x, y.
А у млекопитающего — это перебежать ножками.
Вот.
А дальше у млекопитающих есть два наследника.
Это кот и пёс.
Вот.
Один говорит мяу, второй говорит гав.
Если у нас тут произойдёт множество наследований, ну смотрите мультик от компании Nickelodeon.
Вот.
Так, понятно, что, как наследование рисовать?
Кто?
Да, животное здесь абстрактный класс.
Млекопитающие здесь тоже абстрактный класс, потому что у нас нет реализации сей.
А вот уже кот и пёс — это уже не абстрактный класс.
Вот.
Вот.
Плохо, надо было сказать, надо было написать чирик в качестве реализации функции сей.
Да, это косяк.
Так.
Вот, замечательно.
И смотрите, теперь мы с вами сфотографировали, как мы делаем сей.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
И смотрите, теперь мы с вами наконец-таки, наконец-таки готовы познакомиться с паттернами.
Потому что для того, чтобы реализовывать паттерны, надо рисовать диаграммы классов.
Ну а значит, смотрите, сразу скажу, что некоторые достаточно популярные паттерны, которые у нас будут возникать по ходу дела.
Мы будем разбирать на лекциях.
Но и на семинарах, некоторые семинары будут посвящены разбору остальных паттернов.
Их очень много.
Первые паттерны.
Первые паттерны.
Значит, во-первых, надо понимать, что такое паттерн проектирования.
Это какие-то кейсы, которые помогают решать определенную задачу.
Типичные косяки, лайфайки, которые помогают решать ту или иную вещь.
Вот смотрите, у вас есть интеграл наберущийся, пример.
Как его можно попробовать взять?
Можно в тупую посчитать, можно посчитать по частям.
Что там еще есть?
Замена переменных.
Замена переменных.
Переход к какому-нибудь там неопределенному, несобственному интегралу.
Кажется, этого еще не проходили?
Проходили.
Да ладно, уже были несобственные интегралы?
Да.
Понятно.
Хорошо.
Ну, вот видите, есть куча способов.
И здесь тоже такие же способы для проектирования.
Первая книжка, которая их упоминает, это Банда 4.
Возможно, вы слышали.
Именно они ввели концепцию паттернов проектированных.
Нижка 90-х годов, советую почитать.
Значит, у паттернов всегда есть имя.
То есть, вы приходите на собес, вас начинают гонять по паттернам.
Вам говорят, что такого паттерна легковес.
Ну и сразу все понимают, о чем говорят.
У каждого паттерна есть задача, которую он решает.
У этой задачи есть типичные решения, которые предоставляются паттернам.
И в конце концов мы получаем какие-то дополнительные результаты.
Какие-то плюсы, какие-то минусы.
Не поверите, бывают паттерны, которые приводят к большей части минусов, чем плюсов.
И, наверное, вы даже с ними сталкивались.
Нет, это паттерны, которые, если не грамотно перевести, они приведут к образованию анти-паттернов.
Вот так вот.
Значит, паттерны бывают трех типов.
Первые паттерны – это порождающие паттерны, которые отвечают за создание каких-то объектов.
Вторые паттерны – это структурные паттерны, которые обеспечивают грамотную связь между объектами.
И третьи паттерны – это поведенческие паттерны, которые обеспечивают взаимодействие между объектами.
Поскольку здесь физика, эпсилон, наверное, мне не надо приводить абстракции, связанные с физикой.
Или привести.
Давайте попробуем.
Хорошо.
Смотрите, порождающие паттерны по факту это не что иное, как создание разных материальных точек с разными описанными свойствами.
Структурные паттерны, как вы думаете, к какому разделу физики относятся?
Ну, подраздел механики какой?
Статика.
То есть, как связываются объекты?
И поведенческие, как вы думаете?
Движание.
Движание, динамика, конечно же.
Вот.
Вот такие абстракции.
Значит, смотрите.
Первый пример, мы сегодня будем рассматривать примеры паттернов в связи с реализацией принципов Солид.
Первый пример Солида – это, ой, первый пример Open-Close-Principle – это пример Factory-Principle.
Значит, представьте себе, что мы с вами начали это, фиксиков воспроизвели.
Да, то есть написали функцию для создания фиксиков.
Написали, написали фиксиков.
Такие это.
Наш проект начал окупаться.
Мы начали прийти в успех.
Кто к нам придет дальше?
Ну, допустим.
Нам придут…
Правообладательные.
Нет, мы договоримся, да, договоримся, да?
К нам придут эти…
Нет, нам придут, мы ско…
Нас просят, вы родились.
Мы скажем, мы родились.
Ну, говорят, ну, тогда давайте нам лучше поедем, да.
нас просят вы родились мы скажем мы родились ну и говорит ну тогда давайте нам лунтиков запилите
так вопрос как производить лунтиков
control c control v это про другой паттерн
ну во первых неплохо было бы понять что общего между фиксиками и лунтиками
они видимо могут ну да они воверх мультипликационные персонажи да они каким-то образом перемещаются
кажется одинаковым это тоже вот начинаем надо с вами найти что-то общий между фиксиками и
лунтиками какой-то общий функционал и дальше смотрите это первый паттерн который у нас
встречается этот паттерн называется фабричный метод в чем его суть это порождающий паттерн
проектирования который определяет общий интерфейс создания объектов и позволяет изменить его
поведение в некотором подклассе вопрос я не помню сейчас ага понял картинка 25 кадр вы
ничего не заметили вопрос как сделать так чтобы не сломать ничего не смотрите у нас есть open
close принципа расширить что расширить смотрите мы должны создать фиксиков должны создать лунтиков
ну смотрите представим себе что фиксиков и лунтиков на заводах производят но это мультипликаторы
это значит что нам надо с мультипликаторами сделать
производить найти какой-то общий архитектурный стиль между между фиксиками лунтиками да и
засунуть его в отдельную в отдельный фабричный метод смотрите вот такая вот диаграмма получается
у нас с вами сверху это наши мультипликационные ребята которые выполняют некоторые действия
они умеют ходить там говорить замечательные фразы и дальше у нас есть реализация интерфейсов
продукт у нас есть конкретный продукт а есть конкретный подруг б которые наследует реализуют
эти два интерфейса слева у нас допустим фиксики справа у нас лунтики да а снизу у нас мультипликатор
класс под названием мультипликатор который производит фиксиков и лунтиков единственное что
у них есть это метод фабричный метод который является абстрактным методом это значит что мы
берем реализуем мультипликаторов идем такие на сайт хахару пишем хахару значит покансия
требуется мультипликатор обязанности тун тудун тудун тудун да но будет рисовать мультиков потом
мы идем на хахару пишем другую вакансию он будет выполнять тоже самое но только теперь будет
рисовать фиксиков и по факту в фабричной методе происходит следующее мы по факту вызываем
конструктор класса который нам необходим как это выглядит реализация в реализации это выглядит
следующим образом мы с вами по факту берем по мультипликаторам ну представьте себе и при этом
каждый знает какую задачу он делает это идеальный мир идеально мультипликационная фирма мы берем
такие так ребят заказ нам нужно сделать новую новую порцию этого шматя мерча для этих ребят такие
так ладно и каждый поскольку по факту они выглядят все приблизительно одинаково но каждый знает
что он должен делать ну и по факту представить себе мы создали 50 с вами мультипликаторов фиксиков
50 мультипликаторов этих лунтиков да и по факту мы говорим ста сделай это все дело а достаточно
одного фора сделать пожалуйста создайте нам мерч ну и каждый делает свой мерч и у нас
получается 50 мерчей фиксиков 50 мерчей лунтиков и потом мы можем их надеть на лунтиков
ну это недостаток так или иначе всех патронов проектирования да но патроны проектирования
они преимущественно нужны для оп так понятен понятна ли вот эта диаграмма вопрос как сделать
на луне как начать платить на луне да нам нужно добавить наследника для для нашего мультипликационного
персонажа и создать наследник мультипликатора не знаете от класса мультипликатор а то есть на каждую
пару объект на каждый объект мы создаем пару объектов его создателя вот такой вот а вот
такой вот патрон недостатков его заключается в том что у нас появляется много классов плюсы
мы скрываем реализацию о создании определенного объекта так вопросы значит сразу сделайте
на семинаре вы будете рассматривать патрон под названием абстрактная фабрика не путать с
фабричным методом это по факту картинка для 1d можно ее в 2d перевратить вот так движемся
к следующему паттерну а вопрос почему он почему здесь исполняется open close principle да
да не меняем код абстрактного класса мы меняем код интерфейсов да но при этом если нам
нужно создать новый тип персонажа мы просто расширяем текущий класс с одной стороны
импренутируем интерфейс со второй стороны расширяем класс так переходим к следующему
паттерну да значит второй паттерн который вообще практически мастер так ли начало
придется работать с ним это паттер под названием адаптер и по факту он используется в dependency
идея следующая представьте себе что мы хотим сделать что-то несовместимое между собой
пример пример такой это портирование игр представьте себе вот мы пишем с вами игру да
мы с вами играть эти игроделы и мы написали с вами игрушку эксклюзивно для playstation как любят
там все делать да в чем прикол playstation да там есть своя система ачевок есть свой
я смотрите если мы с вами нарушим dependency inversion мы просто берем и берем привязываемся к этим
функциям прям напрямую вызываем если мы с вами попробуем придумать dependency inversion как
реализовать мы с вами получим паттерн адаптер потому что мы с вами по факту сделал смотрите
иногда еще этот паттерн называется классы под названием раппер как раппер переводится английского
обертка то есть мы с вами пытаемся делать обертку вот ну вот пример цель этого паттерна
заключается в том чтобы трансформировать объект одного вида таким образом чтобы он был
понятен некоторому другому интерфейсу картинку вы сейчас увидите что она похожа примеры это
преобразователь из одного формата в другой чтобы читалось все в другом формате грубо говоря
калибр я не знаю но на каком-нибудь сайте госуслуг требуют картинки такого-то определенного формата
а вы берете такие закидывайте в конвертатор он там преобразует любой другой формат и работа с
ним нормально дальше если вы хотите работать базами данных вы должны вообще обеспечить работу
с любой базой данных с любым хранилищем данных не только с и текущим возможно что вам надо
мигрировать данные из одной системы в другую то есть смотрите пример вот уже ли вы я не знаю
кто-нибудь по типам пользовался да отлично вот spotify прикрыли да согласен я с этим согласен
вот и замечательный сервис под названием века придумал сервис трансфера данных то есть они
преобразуют этот формат к своему формату и загружает его себе какой пример реализация на самом
деле достаточно простая да тут немножко другое нотация видите зелененькая штучечка с этой
штука как вы думаете что это такое нотации емл да зелененькая это интерфейс смотрите как это
распознать видите стрелочка которая вниз идет это реализация интерфейса то есть смотрите
клиент общается всегда с интерфейсом а дальше мы с вами пишем специальный адаптер который
помогает работать с нашим сервисом то есть грубо говоря вы представьте себе что это система
ачивок в PlayStation Store мы вызываем хук сделаем отправь пожалуйста ачивку и реализуем интерфейс
в качестве класса под названием отправка ачивки PlayStation Plus если мы с вами захотим
портироваться в Steam что нам надо будет сделать для этой штуки просто написать свой адаптер и
все а адаптер вызовет интерфейс для функцию для выгрузки ачивок в Steam гениально да смотрите
где мы эту картинку с вами уже видели сегодня так напоминаю да смотрите у нас была такая такая
штука такая штука а сделали такая штука такая штука такая штука так что там было да
что похоже
да тут две штуки добавил в нее вот такая полезная вещь значит смотрите достоинство недостатки значит
сокрытие детали преобразования интерфейс то есть для нас выглядит это как единое целое то есть
отправили ачивку ачивка отправляется ну и по факту это часть реализации депенденции
при этом и недостаток в том что на каждый чих нужно писать свой конвертатор но представьте
себе следующее такая задача будет те кто будут реализовывать командные проекты вам придется
реализовать все в нескольких интерфейсах типов внешних интерфейсах графический интерфейс там
текстов и так далее и по факту мы от вас будем требовать так чтобы вы так или иначе использовали
адаптер почему потому что будет сетап допустим если вы что-то неграмотно напишите мы с вами попросим
а сможете ли вы за несколько часов перепилить это все с одного интерфейса на другой если вы
сказали да вы молодцы да проверять буду но сделать архитектуры такой чтобы реально можно было
отцепить одну прицепить второе вот такой пример так понятен ли адаптер
давайте я поскольку мы чуть позже начали я сейчас еще один тезис расскажу
смотрите есть паттерны соответственно должны быть анти паттерны логично
один из анти паттерн мы с вами уже разобрали на прошлой лекции и он нарушает принцип
single responsibility он называется если переводить на русский бог объект готов и у этого анти
паттерна заключается в том что мы все пытаемся делать в одном объекте в итоге у нас есть он
гад называется готов обычно значит если вы начнете писать какой-нибудь проект на
типичном графическом интерфейсе тот же самый кути либо такая интер вы начнете писать это все
в классе под названием мэйн виндал и вот у вас мэйн виндал получается огромным по факту будет
являться готов от этого лучше отклоняться при этом некоторые другие паттерны которые мы с вами
использовать у них есть недостаток того что они очень легко могут превратиться в готовых если
не неправильно чихнуть так сказать вот это анти паттерн а вопрос кто-нибудь так вопрос про
готовчик понятна в чем его суть вопрос на засыпку давайте разберем еще один паттер попытайтесь
угадать его название с учетом того что мы с вами уже сегодня разобрали
да
да у нас есть способ узнать чем мы с вами разобрали сегодня
а что это
не смотрите что такое абстрактная фабричный метод и адаптер это это паттерн да да да вопрос
какой еще из методов мы сегодня разобрали принципов я больше даже больше сказал мы с
вами сегодня разобрали вот эту вот замечательную историю вот это
кипит симпл стипет у нас есть кипит симпл стипет и он стоит перед драй и он стоит перед солидом
вопрос давайте попытаемся это все совместить у нас есть кис у нас есть паттерны какой анти паттерн
бинго анти паттерн использует паттерны везде и везде везде и всюду
паттерны не панацея от всех болезней вот это суть этого анти паттерн и получается что анти паттерн
надеется на паттерны вся и всюду нарушает принцип кис а понятен этот тезис
чрезмерное употребление паттернов да ну я не точное название привел возможно что мы сможем там
если поищу информацию в интернете я скажу как этот паттерн точно называется в итоге что мы
сегодня с вами разобрали по факту мы с вами сегодня разобрали основные принципы это солид это
я гни после него идет кис после него идет драй и рассмотрели первые реализации в виде паттернов и
анти паттернов значит следующих сериях мы с вами начнем про мл я вспомнил картинку сейчас покажу
и про методология разработки по я вспомнил сейчас я попытаюсь ее найти если подождете минутку
по почему кипит simple stupid это работает есть замечательная вот такая картинка не знаю видно
или нет это немножко что методология разработки значит смотрите верхняя модель это так называем
водопадная забегая на будущий а нижняя это радостный человечек везде катается на всем вопрос
где у нас нарушается кипит simple stupid сверху видите у нас нарушение идет киса вам нужна штука
которая людям должна помогать ездить да нам не нужна большая машина вот и получается так что
маленькие проекты вот бегают маленькими интеракциями для того чтобы всегда поставлять
заказ но мы про это как раз будем говорить про мы в теме про методология разработки по так
на этом все давайте вопроса
