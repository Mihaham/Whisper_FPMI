Так, вы знаете, сегодня довольно на расслабоне, будет несколько простых задач, поэтому я надеюсь, что многое из этого вам откуда-нибудь будет знакомо, поэтому удивляйтесь, если будет не очень узнавательное.
Ну, будем на несколько прикрыть.
Я разберу просто несколько задач.
Плотнично-клёво плотнично.
Так, потому что нормального определения, что такое девичка проиграет, можно применять.
А может, где-то есть, но оно точно бесполезно.
Вот, просто на некоторых примерах посмотрим, как этим можно пользоваться и что с этим можно делать.
Первое.
Представьте, что у вас есть массив чисел.
Пусть они где-то не предпочитаются, возможно, официально.
Вот, и есть у вас перед этим массивом стоит кого-нибудь человек, кто-нибудь нечего.
Какая точка проигрывает весь этот массив?
Направится максимальную сумму, но при этом за каждую спальню может быть вернёт на предпочтительность или нет.
Либо в плотную стельницу.
То есть свой понятие величины один или два.
Сложно.
Один или два вперёд.
Закончить.
Ну, давайте мы попросим, чтобы мы начали заканчивать в последнем элементе.
Конечно, выжираем.
Заканчиваем в последнем элементе.
Ну, и мы хотим максимизировать сумму тех элементов, которые мы просмотрели.
Масимизируем сумму посещённых элементов.
Масимизируем сумму посещённых элементов.
Давайте сумму не подключать в дальнейшее время.
Ага.
Ну, не всем.
Хорошо.
Кому-то будет фалет.
Что же я должен сказать?
В крайней мере, какие-то базовые вещи, которые будут во всех остальных задачах, которые можно проинвестировать.
Итак, значит, вопрос.
Давайте я скажу, что пусть мой пузнечик прыгает-прыгает-прыгает.
И в этот момент я его на сильно останавливаю.
Вот, например, такую-то запрыгал.
Сейчас мы пустим её здесь.
Я знаю всю историю его победения.
Вот вопрос.
Чтобы дальше он действовал как-то оптимально.
Чтобы нам дальше было понятно, как оно нужно себя вести.
Вопрос.
Что из этой всей информации нам достаточно проявить?
Вот из всего этого пути, из всех элементов, которые он посетил.
Что нам достаточно проявить?
Ну да, конечно, не очень много информации.
В частности, какой элемент он проявил, нам не очень интересно.
Если мы закручиваем в каком-то аитном элементе, то нам не важно, как именно мы сюда попадем.
Вот так, когда прыгает.
В принципе, не очень важно.
Если мы знаем какую-то сумму, которую набрали, то этого достаточно.
Вот, ну вот, значит, отсюда такая идея.
Давайте, чтобы хранить ответ, я хочу для каждого айти знать максимально возможную сумму, которую можно набрать.
Если я начинаю вот здесь вот и закреплюсь в его айтичеке.
Мы поняли, какой информации нам достаточно проявить.
Давайте я его хранить.
Поэтому я вошу в айтичек.
Собственно, данный метод.
Вот и эта максимальная сумма.
Можем набрать.
Вот старта.
Долг.
Ну, и причем, имеется в виду, что наш путь заканчивается именно здесь.
Вот в этом предыдущем последовательстве.
Ввели такую величину.
Ну, дальше, например, можно сказать, что такой нулевой экономик.
Да, что это обратная база нашей знаменики.
База нашего настига.
Потому что в самом начале, когда у меня нет еще элементов, мы стоим здесь.
Единственный способ остаться в нуле, это никуда не ходить.
Поэтому сумма нулевая.
Ну, и дальше можно, например, написать следующее.
Потому что если я обещаю себе, что я заканчиваюсь в этом элементе, то как я мог туда пропасть?
Ну, либо прыжком плюс один, либо прыжком плюс два.
Да, и соответственно, если я знаю, что мой последний прыг был вот такой вот.
То есть я пришел из элемента с номеров не минус один.
Тогда нам нужно было сначала, от начала, как туда прыгать, до сюда.
Потом сделать один прыжок плюс один, вот сюда.
Ну, тогда ясно делал, что нам нужно было от начала до сюда прыгать, и оптимально возможное.
Что у нас тут, в принципе, в детдажке.
Потому что если я максимизирую сумму, заканчивается на аи, при этом я знаю, что предпоседнее слогами это аи минус один,
то значит мне нужно оптимальным образом пропрыгать от нуля до аи минус один.
что уже хранится в массиве ДП и уничтожение.
Это на второй случай, наоборот, когда я последний шаг сделаю на плюс два,
вот так вот скачу,
тогда мне нужно было от начала выпрыгать до и-минус два,
вот этого вот величина,
и потом сделать прыжок в последние вещи и подавать консету i.
Понятно?
Ну, естественно, это переход в коллекцию,
не только если и, видимо, хотя бы двойка,
мы вспоминаем, как будет обращение к минус первому элементу.
Но вот я не буду подробно прописывать, что это верно.
Давайте один раз сделаю.
То есть форма, наверное, верна только если у тебя будет двойка.
А если единица, то у меня вот эта величина неопределена,
потому что нельзя в единицу прийти с помощью прыжка плюс два.
Ну, тогда просто у меня в массиве вот этой величины не будет.
Я не могу брать ДП с индексом минус один,
поэтому просто из массива эта величина как-то удаляется,
я ее там не раскручиваю.
Ну, а вот в общем случае именно такая же.
Вот.
Ну и все, просто это выглядит очень просто.
Мы делаем просто вот это.
Потом в тыпле вот ам.
Вот эту строчку просто записываем,
аккуратно выбирая случай, когда вот эта вот штука не существует.
Вот. В остальных случаях, собственно, основная форма.
Сюда копируем.
Окей?
Вот. Хорошо.
Ну и тогда понятно, что ответ это просто ДП с индексом bm.
Потому что, потому что мне нужно обязательно закончиться в бельной ячейке.
Вот.
И, собственно, там ровно эта величина или нет.
Конец.
Значит, несколько, несколько замечаний.
Во-первых, ну это более-менее единственное решение этой задачи.
С той точки зрения, что если бы мы пытались реализовать какой-нибудь жарный алдемитом,
в стиле не пытаться для каждого кинфредного пьет находить оптимальные ответы,
потом из двух оптимальных что-то выбирать.
А если как-то жарно.
Там, например, вот есть у меня мой массид,
а есть в зале аинда.
И я как-то хочу, просто смотря на два в одном варианта,
куда я могу перейти, куда я могу прыгнуть,
выбирать на них оптимальный.
Ну, например, если там здесь есть отрицательное число,
то его хочется, хотелось бы скипать.
Если это отрицательное положение, то я буду по всю прыгнуть.
И наоборот.
Если это отрицательное положение, то я буду сюда прыгнуть.
В общем, что-то такое, вот такая локальная оптимизация,
когда мы пытаемся, смотря только на возможные варианты вперед,
сравнить их и как это вперед прыгнуть.
Так вот, на самом деле, никакой такой жарный алдемитом,
как бы вы не придумали,
если он смотрит на два впереди стоящего числа
и выбирает, извините, каким-то образом оптимальное,
то можно всегда подобрать фронтер тест, который,
ну, собственно, на котором найденный вами путь
будет менее оптимальным, чем тот, который нашли с помощью DPI.
Вот в DPI-шке можно очень легко оказать корректность.
Собственно, здесь ничего не получится.
А здесь легко оказать корректность,
ну, потому что там можно конкретно индукцией показать,
что к моменту времени, когда у меня пройдены и перитратные цикла,
у меня будет корректно найдена DPI.
Ну, собственно, очень легко доказаться по индукции,
потому что вначале у меня DPI 0,
на базной индукции.
Дальше.
Если у меня для всех шагов от первого до и минус первого DPI-шка
правильная найдена,
то DPI-то мы вот здесь подробно разбирали.
Чему равно оптимальная DPI-то?
Надо просто перебрать последний шаг,
и в зависимости от того, какой он имеет длину,
взять и будет вылучшить динамики.
И если они пощипнут неправильно,
а это так по предположению индукции,
то, собственно, DPI-то выражается правильно по такой факт.
Да.
А вот как динамика значит?
Ну, вот тут тяжело сформулировать
какого-то конкретного жадника.
Если он не скажет какой-нибудь конкретный алгоритм,
то мы можем попробовать построить конкретный тест.
А в общем случае?
Ну, в общем случае, типа, тяжело,
потому что он не банярский алгоритм.
Хотя этот алгоритм, тем более жадный алгоритм,
не очень приятный.
То есть, скорее наоборот,
вы обгодите какой-то конкретный аппарат,
который действует так-то,
и в зависимости от этого можно придумать конкретный тест.
Так.
Я это сказал.
Да, давайте еще очень точку на всякий случай оценим.
Ну, по времени-то все понятно.
Может, просто один линию тыквы.
Вот, а с памятью можно добиться,
на самом деле, вот, и денницы памяти.
И это очень распространено
это очень распространенный трюк
от вакционно-динамичного программирования.
Если мы аккуратно посмотрим на те значения DPI,
которые нам важны с каждого конкретного момента,
то мы поймем, что их все как бы три штуки.
Потому что, чтобы найти DPI,
мне нужно знать только два предыдущих.
Поэтому если я храню их,
через них высчитываю третья,
да, так в том числе вот этого DPI,
мне уже будет не нужен.
Поэтому вместо хранения всего массива DPI,
я могу бы позволить себе хранить
только три вот этих подпаседливых значения.
Предыдущие, предыдущие и текущие.
Когда я перейду к следующему,
мне, соответственно, вот это значение DPI,
все будет интересно, я его забываю,
или там, на его месте записываю новую информацию.
Поэтому память можно добиться просто
константной, храня несколько
последних значенных элементов массива DPI.
Окей?
Ну, все, хорошо, давайте тогда
быстро еще вторую долгу создать.
Это уже будет задача
на табличке.
Представьте, что у нас есть
табличка NL.
Опять-таки в каждой ячейке
написано число.
Вот, мы с Тайли, ну давайте, например,
вот здесь вот изначально численно 1 на 1,
хотим попасть вот сюда,
и можем мы ходить
только, например, вниз или вправо.
В предоступной ходе
я могу пойти либо
строго вниз на 1,
либо строго вправо.
Ошибать общее правило.
Давайте, допустим,
наш товарищ, который ходит,
допустим,
наш путь,
и в какой-то момент его остановим.
Опять-таки, чтобы продолжить
наше движение, из всего этого пути нам
достаточно знать две вещи. Где мы закончились
и какую набрали сумму.
Потому что как именно мы сюда попали
с точки зрения
дополнения ответа до конца нам не очень интересно.
Мы пошли вот так вот, или вот так вот,
или вот так вот, неважно. Важно только последний ответ
и сумму.
Ну, поэтому давайте, собственно, эти величины
в массиве db.
Пусть db не держится.
Это максимальная сумма
на пути
от
с этим
до иши.
Будет уже
квадратный дизайн,
по нашей табличке, по нашим админансам.
Это, собственно,
начало нашего пути. В этом случае
это будет dp1,1 равно a1,1.
Этот элемент, мы когда еще не делали
одного шага, у нас уже есть одно число.
Оно взято в сумме, поэтому, собственно,
мы его взяли в админанс.
Это будет начало нашего дизайна,
ну и переход
давайте в таком же стиле.
Вот вопрос. Если я зафиксировал
некую ячейку иши,
то как я мог в нее попасть?
Давайте рассмотрим последний шаг,
который нас привел в эту конкретную клетку иши.
Ну, откуда я мог попасть в эту клетку?
Либо слева, либо сверху.
То есть, если здесь были входи вниз
и вправо, то, наоборот,
обратно это
слева
или сверху.
Но мы не знаем, как мы сюда попали.
Давайте переберем последний шаг.
Соответственно,
если я вдруг откуда-то знаю, что
оптимальный шаг был вот такой вот,
вот так надо было сюда прийти,
тогда мне нужно просто из 1,1
оптимальным пунктом добраться сюда
до этой клетки иши-1.
Потом с помощью вот этого
ребра вправо попасть сюда.
Потому что если я откуда-то знаю,
что это ребро оптимальное,
то начало пути
из 1,1 и иши-1.
Ну и, наоборот, если я откуда-то знаю,
что оптимальное ребро это вот такое,
вертикальное, то мне нужно из 1,1
сначала попасть в эту клетку,
как натуральный иши-1, и потом
это ребро последний использовать.
Но поскольку я на самом деле не знаю,
какой из этих вариантов оптимальный,
мне нужно ни в кого посмотреть, понять,
какие они производят ответы,
то есть вот такая сумма чему бы равна,
вот такая сумма чему бы равна,
из них выбрать просто оптимальный.
Ну так и делаем.
Dp, Dn, Dt.
Это что?
Ну здесь опять число i и j у меня гарантированно
будет в сумме, поэтому я его насильно сюда вписываю.
И дальше нужно просто
из двух веществ выбрать максимум.
Максимум из Dp и иши-1,
Dp и иши-1.
Я не знаю, откуда конкретно я пришел,
но из этих двух веществ надо выбрать максимум.
Хорошо.
Еще я скажу про вот это вот
конкретно
i-1, j-1.
Я подразумеваю, что
это переход валиден,
когда вот эти два перехода валидны.
То есть можно было прийти вверх, можно было прийти вверх.
Но это не работает
в частности для лечей
этой первого столбца
или первой строки.
Для этих лечей я не мог прийти
либо слева, либо справа.
Для них я не мог прийти слева,
для них не мог прийти сверху.
А именно если вот это вот есть,
то есть если клетка слева была,
если именно с 1,
наоборот это клетка сверху получается,
то есть если вот эту клетку все струит,
тогда ее надо рассматривать максимум.
Иначе просто надо как бы стереть отсюда
и не рассматривать.
То же самое здесь.
Если клетка слева присутствует,
тогда она присутствует максимум,
иначе надо просто стереть.
И там будет тупая строчка в стиле i-1
плюс максимум из просто одного элемента.
То есть если я вот этого сотру,
и максимум можно опустить,
будет просто вот так.
В общем, ну тут
общая форму отраски такая,
а в частном случае,
если значений динамики у меня просто нету,
надо просто изымповать.
Либо же более такой
универсальный способ,
можно наш МДП
продлить на те самые неопределенные значения.
Можно просто МДП расширить
на клетку влево и вверх.
Или там даже лучше не нули,
а минус бесконечности,
потому что числа сами могут быть отрицательны.
Поэтому давайте лучше здесь поставлю
МДП.
Давайте вот здесь вот вверх
и поставлю минус бесконечности.
В массиве МДП.
И тогда
если я буду пытаться
перейти в контентные ячейки нежи
из несуществующей ячейки,
то я по факту буду брать вот здесь
вместо одного из значений
минус бесконечности.
Но это то же самое, как если бы вообще в случае не рассматривать.
Потому что если это сколько именно бесконечности,
то можно просто перейти в контентные ячейки.
Можно по-разному избавляться
от невалидных шагов.
Наверное, самый удобный в данном примере
это поставить на массиве МДП
здесь минус бесконечности,
когда там нельзя влевать.
Если тогда если я буду припить,
то пагами надо сделать очень-очень-очень маленький.
Большим помогает рецепт.
Рецепт понятно где.
ДП и НМ,
потому что мне сказали, что надо закончить свой рецепт.
НМ времени погиб на деле.
А потому что каждое конкретное значение ДП
перехвили за 1,
за каждое конкретное значение нежи
мне нужно какие-то ригмидические операции сделать.
Ну а с памятью здесь
похожий прикол.
Можно делать вступлую
за такое же количество памяти.
Но можно заметить, например,
что если я буду идти по строкам
то мне достаточно будет
справиться только две последние строки.
Потому что значение ДП
зависит только от значения ДП
вот здесь.
Если я окажусь в этой строке,
то мне достаточно свернуть только с первой.
Мне не нужно там и минус с второй, и с третьей и так далее.
Поэтому если я
науcially делаю у течки,
я могу хранить только две последние строки.
Пересчитывать через предпоследнюю,
потом предпоследнюю забывать
и новую пересчитывать через последнюю, ну и так далее.
Поэтому в каждом моменте мне нужно сегодня
две строки хранить, поэтому память
можно сэкономить до просто ОТ.
Если хранить только две последние строки в ДП, то есть текущие и предыдущие, там
там вверх, тут хватит. Вот, хорошо.
Что здесь можно сделать? Здесь можно реализовать динамику не так, как мы сделали, это я буду
называть динамика назад. Можно делать динамику вперед. Вот здесь, смотрите, когда я говорил про этот последний шаг, если я заканчиваю
сплетки ежи, то я перебираю, какой был последний шаг. Либо он слева, либо он сверху. То есть мне помогло
сфотографировать вот эти вот действия, если они раньше были вниз и вправо, то мне нужно как бы наоборот понять
откуда они были сверху или слева. Вот. Я могу делать наоборот. Я могу не разворачивать вот эти мои стрелки и
ставить пример на следующий. Каждый раз, когда мне посчиталось ДП вот здесь, я могу через это значение
обновить значение ДП вот здесь. Ну и то же самое со стрелками вправо. Если у меня есть значение ДП здесь,
давайте я как бы обновлю, попытаюсь обновить значение ДП здесь через эту стрелку. То есть не буду для каждого
конкретного ежи в момент прихода к нему его выщепить через предыдущие. А наоборот, если я пошел в ежи, я буду обновлять все
следующие. Все, что достижено из него. То есть в случае, если я иду вперед, я наоборот буду делать такой и такой.
Вниз и вправо. Ну вот давайте напишу.
Опять-таки у меня будет любой вариант. Вариантный такой. После просмотрения вверх и вниз.
У меня будут уничтожены все пути предпостыдней интерпретации.
То есть давайте специально здесь носить ДП за полмени с конечностью.
Я знаю, что это равно А1 и А2.
Вот. Опять-таки нашему конкретному элементу я буду делать шаг вправо и вниз.
И обновлять соответствующий значение ДП через эти соответствующие стрелки.
То есть если я находусь в ленте в ежи, я могу обновить ответ ДП для ленты справа.
То есть ежи в высоте. И ленту сниз пусть идут один жир.
То есть у меня в цепи будет примерно вот такой.
Максим жир. Я делал обновление для ДП.
То есть это обновление вправо или вниз, то есть обновление вниз.
Вот такой интерпретация.
Смотрите, почему я не пишу максимум, то есть я это делал.
Я для клетки справа и клетки снизу значение ДП в них обновил через максимум,
то есть через нового появившегося пути через клетку ежи.
То есть вот здесь я могу теперь попасть вот сюда, в клетку ежи 31.
Еще раз. Вот это значение ДП обновил через то, что там уже и так лежало.
Так же значение ДП ежи плюс этот мет.
По сути, я сохранил то, что там уже и так было, добавил сюда какой-то один новый пути.
Потому что как минимально пути вот до сюда?
Он проходит либо так, либо так. Возможно, я уже там с вами правильный ответ,
потому что вот эта стрелка уже была учтена.
Но, возможно, правильный ответ – нешедший пэкс.
Поэтому мне нужно обновить это через то, что там уже лежит.
И, собственно, то, что я сейчас включу, новый пути через вот эту ребровку.
Это что-то удобнее, когда вам не хочется, например, вот такие развороты делать.
То есть вы не хотите пытаться понять, как я могу попасть в клетку ежи,
соответственно, эти все ребра разворачивают.
Когда вы просто в тупую делаете все вот такие вот обновления,
если вы знаете ответ здесь, то вы обновляете ответ в конце, соответственно, ребра.
Если вы знаете ответ здесь, то вы обновляете ответ здесь.
Это может быть очень удобно, если у вас переходов много.
Не как у меня сейчас просто их два, а там, не знаю, много.
Например, из каждой клетки есть свое множество возможных переходов по каким-то стрелкам.
Но тогда вы не хотите их все разворачивать, вы можете просто,
зная ответ здесь, обновить ответ через все возможные концы стрелок,
которые прикалываются в этой конкретной клетке.
Может быть удобнее сделать именно так.
Хорошо.
Так, перейдем дальше.
Следующая задача, кроны и множество подходов.
Смотрите볼.
Эти две строки или там два мотива.
Вы хотите найти их или более общую подпоследующуюся.
Подпоследующаяся, понятно. Что такое?
Например, кто-нибудь какая-то последующаяся,
которая получается вычеркн GetData.
Например, можете какие-то элементы вычеркнуть, получит подпоследствия, и всё, всё осталось склеить, это будет подпоследствия.
Ну, наибольшая общая, значит, вам нужно рассмотреть, каковы подпоследствия, которые общие в обеих строчках, есть и здесь, есть и здесь, и из таких наибольших подленивых.
Давайте вот здесь за номерок как-нибудь уже садимся в зале tn, а здесь в зале tn.
Вот, значит, можно не нужно всё вот такое, значит, смотрите, мы можем обрубить насквозь обе строчки на них первоначальных отрезков, вот здесь, вот здесь, вот здесь.
То есть рассмотреть элементы с первого кубитого в первой строке и с первого кубитого в второй строке.
И для конкретной пары единиц навести значение динамика для поезжей, это будет, собственно, длина ног, длина наибольшей общей подпоследствия, для того, чтобы, ну, соответственно, t с первого кубитого и t с первого элемента кубитого.
Если мы такой динаметр не считаем, то понятное дело, что это просто dpnm.
А это dpnm, потому что, когда я рассматриваю всю строку с целиком, от начала до конца, всю строку с целиком, рассматриваю длину и сно, то ровно то, что мне нужно есть.
Значит, база нашей динамики. Давайте я эту строку вывезу.
Для удобства я стараюсь, чтобы dp ноль жил. Ну, для любого жил. И, наоборот, dp и ноль это тоже ноль для любого жил.
Потому что, когда я рассматриваю, бустую одну из строчек, то есть это в случае с соответствием того, что у меня строка s пустая, я ее врубил даже в первые секунды.
Когда понятно, что ноль пустой строки и чего угодно, это ноль. И то же самое здесь у меня вторая строка пустая, первая кота, это, конечно же, длина наибольшего в процессе.
Вот, теперь переход. Как выглядит dp и ноль жил? Как можно получить dp и ноль жил? Есть у меня префикс длины i в строке s, префикс длины j в строке f.
Как выглядит длина наибольшего процесса в данный момент? Ну, можно стоять, например, так. Давайте посмотрим на эти последние элементы.
Давайте спросим себя, а включены ли они в ноль? Включены ли они в ту самую наибольшую общую процессу, которую мы ищем?
Ну, соответственно, есть там несколько вариантов. Этот включен, этот не включен. И, наоборот, и с этим тоже самое, включен или не включен.
Смотрите, значит, в случае, когда я открыто знаю, что с it не участвует кнопка, я точно могу сказать, что dp равно dp и минус 1 j.
То есть, если этот элемент точно не участвует, то я могу его откусить, забыть про него и написать dp и минус 1 j.
Потому что этот элемент не важен, а для двух поставшихся строк мне нужна кнопка.
Поэтому один из способов получить dp и d it – это найти dp и минус 1 j. Это в случае, если s it не участвует.
А если? s it не участвует.
Второй случай симметричный, когда d j не участвует.
Если мне откуда-то известно, что этот элемент вновь не участвует, я могу отрезать его из второй строки, уменьшить нашу задачу.
И соответственно сказать, что dp в точности вот этого dp равно в точности d it и минус 1 j.
А потому что его можно откусить. И если это в значении dp уже известно, то нужно просто его скопировать.
Если даже это важно.
Значит, что не разводится?
Какой случай не разводится?
Когда оба участвуют.
Мне осталось понять в чём будет равна длина ног, если неизвестно, что они оба участвуют.
Но если они оба участвуют, то они друг другу должны соответствовать, потому что это самый правый элемент обеих строк.
Если мы рассматриваем подпосредственность и эти два элемента участвуют, то они обязательно последние в обеих предпосредственностях.
Значит, они обязательно должны совпадать.
И в этом случае, если они совпадают, я могу сказать, что они друг другу соответствуют.
Добавить в это ничку.
И потом одновременно откусить и взять dp и минус 1 j и минус 1.
То есть я их друг другу сопоставляю.
Говорю, что это последний элемент обеих подпосредственностях.
Да, и дальше нужно, забыв про них, найти длину ног, уже типа трексов с длиной 1 по меньшему в обеих строках.
Так, ну давайте об этом в следующем образов.
Как такой программист, лучше вот так.
То есть в случае, если подпрытия не два отнима совпали, я могу обновить значение dp через на 1 плюс dp и минус 1 j и минус 1.
Потому что я уже объяснил, да, эти два последних элемента откусились, они друг другу соответствуют, я их уже взял подпосредственность.
Поэтому все остальное, все что остается, это взять подпосредственность еще вот этих строк.
s с первым элементом до минус 1, вот t с первым элементом до минус 1.
Вот аноды b и плюс ничка за счет того, что я вот эти два символа друг друга сопоставил.
И это работает только если выполняется вот эта проверка.
А если два символа равны, тогда их можно друг другу сопоставить, иначе нельзя.
Ну и соответственно, если это не работает, то это разрешает false, false на что угодно.
То есть оно оказывается конту здесь.
Конечно так нельзя писать, да, нельзя его умножать более на интеджер, но он не может.
А если здесь это верно, здесь 1 умножается на значение 6, получается просто это значение.
Вот, собственно и все получается тогда вот такой.
Так, ну да, значение, когда у меня один из элементов пары, один из аргументов стоков нулевой, мы уже все разобрали,
поэтому мне можно какую-нибудь любую рассматривать.
Ну и дальше, я думаю, что добытая жизнь – это максимум из генера всего.
Это максимум, если я куда-то подрегу еще.
А поскольку я не знаю, какой именно из трех достигается, я думаю, что это верно, если там есть какое-то условие.
Например, если это сыты не участвуют, если это жито, это все оба участвуют.
Но я не знаю, какой из них, но какой-то из них точно достигается, потому что это как бы все возможности, если здесь я разобрал.
Раз меня интересует длинная мощь, то мне нужно выбрать из них максимально затягчить сил, чтобы заположить воду в какой-то же.
Еще раз, последние силы выпадают, но...
Тогда вот один из этих сыграет.
Еще раз, последние темы впадают, но...
Когда вот один из этих сыграет?
Не, мы явным образом никакие проверки не делаем.
То есть, смотри, еще раз.
Собственно, так же, как и будут задачи про табличку, предыдущие задачи.
Мы же не знаем, какой именно переход правиль сверху или слева.
Мы точно знаем, что один из них правильный.
Поэтому мы с ним выбираем как бы оптимально, тот, который дает мне большую сумму.
Нам в ответ.
То же самое и здесь.
Мы не знаем, какой именно за этот второй случай достигается.
Но один из них точно достигается.
То есть, либо не участвует последний в нашей ноге, в строке S.
Либо в строке T последний не участвует.
Либо они оба участвуют.
То есть, они оба участвуют и друг другу соответствуют.
Значит, вот в этом случае достигается.
А то, что вы говорите, когда последние символы равны,
но один из них не участвует в ноге,
когда, например, в ноге у меня будет вот такая.
И вот этот последний не участвует.
Тогда это то же самое, что последний символ здесь просто откусить.
А это у меня разобрано как раз.
То есть, независимо от того, равны последние символы или нет,
я точно могу любой из них отбросить за бесплатно.
Соответственно, вот это и вот это у меня в ответе в члёте.
Ну как?
Окей.
Ну длины, длины.
Ну я же здесь пятраскопаю элементы спокойно.
Да, конечно.
Да, но я здесь протрудил.
Что такое подпасы?
Я говорю, можно вычислить любой набор элементов.
Остальные склеить или будут подпасы.
Не подотрез, а как бы в подможество скорее.
Окей?
Если задача про подсловы,
это мы в следующем смеси не будем про строку говорить,
мы задачу про подсловы решим.
Там надо что-то типа субмасса построить,
или что-то такое.
Здесь просто...
Так, значит, смотрите.
В этот момент мы с вами найдём длину.
Наибольшую длину.
А теперь вдруг нам нужно найти длину
а, собственно, саму наибольшую длину.
Или предыдущих задачах.
И просто сумму там снимаем.
А саму.
Так, как именно здесь нужно брать символы,
чтобы получить самую наибольшую длину.
Вот.
Ну, давайте сделаем
очень простую вещь.
Давайте вот здесь всегда,
когда мы находимся в значении dp,
будем запоминать, откуда нам получше.
То есть вот здесь я беру максимум из трёх величин.
На максимум из вот этого и вот этого.
А давайте так бы я заведу второй массив,
который я назову par.
Ну, типа привес или какой-нибудь.
Par.
Это каким из трёх способов
мы получили максимальный значение dp.
Ну или...
Ну да, короче, это ноль,
если вот этот максимум равен вот этому,
единица если вот этому,
двойка если вот этому.
Давайте я не буду конкретно писать,
то есть как именно это реализовательный вопрос
именно к воду.
Давайте я напишу просто,
как именно
получен
максимум
dp.
То есть и внутри трёх величин,
какая именно из этих трёх величин
даёт максимальный значение.
Пусть вот p и j указывают на
этот значение.
Вот. Тогда как нам
найти ноль
саму подпасственности для строчек s и t?
Чуть ноль p и s.
Ну вот, мы знаем её длину,
она имеют в dp и nm.
dp и nm это её длина.
Значит, да, мы знаем,
как ему произведена длина была получена.
Мы можем посмотреть на
p и nm.
Собственно,
в этом массиве будет храниться,
как именно она была получена.
Если там указать, что вот так она была получена,
значит я могу смело откусить
последний элемент в строке s
и от этого у меня ног не изменится.
Если p говорит, что вот так оно было получено,
то я могу напротив откусить
последний символ в строке t
и ног не изменится.
И, наконец, если вот эта штука указывает,
что вот это вот, это был максимум
при содержании j,
то оптимальный способ это вот эти два
последних символа заматчивать,
сказать, что это последний символ в ноб
и построить ноб для вот этого концепции.
Ну, поэтому я могу написать
какую-то следующую.
Давайте я приду две переменные j,
это текущие координаты.
Два указательных координат?
Ну, это громкое слово,
громкое слово два указателя,
ну, типа того, совсем типа.
Дальше, пока
dp и drg
положительно
я смотрю
на p и j.
Ой.
Ну, давайте я
немножко напишу, да?
Если p и drg
говорит,
что
dp и drg
получено
давайте вот так, по первому правилу,
вот ему первое правило,
по первому правилу,
то это означает,
что оптимальный ноб
для p и j
вместо первого s и j.
Значит, я могу последний символ c и s откусить
и перейти дальше к цепи.
То есть, я понимаю,
что если это
бесполезный символ,
я его убираю
из рассмотрения, перейду к dp и j,
наносим, соответственно, дальше к трупсу.
Вот это был беглый случай.
Второй случай.
Если что-то самое,
нужно по второму правилу,
то есть, вот это вот.
Да, так наступит, наоборот,
текучая dp получена
над браком int.
Значит, мне нужно уменьшить длину и
выставить континент.
Если оптимально всего не рассматривать
int в ответе, то я просто обновил
dp и j.
Ну, и наконец, в последний случай,
если по третьему правилу.
По третьему правилу.
То есть, собственно, означает,
что если dp не ноль,
потому что здесь был не ноль,
значит, символы равны.
И они как раз являются последними,
совпадают с символами к нашему.
Поэтому можно сделать что-то типа такого.
Напечатать в конце тск.
Напечатать в конец.
Напечатать.
В конец тск.
Ну, потом сделать
минус-минус-ки, минус-минус-ы,
а то есть, если
dp-шка текущая получена
по третьему правилу, значит,
у меня последние два символа
состыковались. Они являются
последним символом нашей небольшой
последней части. Я не могу уже как бы
учесть, а так напечатать туда.
И, соответственно, уменьшить обе координаты
и перенесу.
Потому что я отпустил два символа,
если перенесу.
И дальше dp-шка инвестируется в конце.
Да, единственное, что
вот тут в конце я не очень
нормально писал. Написать в конец, это значит,
что я не отвечаю в таком порядке, чтобы они
образовались красно. Я не буду просто
в строках сохранять. В конце нужно будет
развернуть, потому что, как бы, с конца
это все равно.
Я не буду без конца строки. И первый символ,
который я найду, это последний лучший
символ в нуб.
То есть, если я добавлю пер,
это, в самом деле, последний символ ответа.
Потом найду предпоследний презент и следи, и так далее.
То есть, либо вы в строках с конца
куда-то записываете ее справа-наделом,
либо просто добавляете слева-направо,
и потом любишь в конце. Это уже
детальная инвестиция.
Собственно, универсальный
способ, как можно обсудить ответ.
То есть, если вас интересует не только
длина, а не только сумма,
но и способ, каким образом
получена длина или сумма,
универсальный рецепт такой,
запоминаете, как именно было
получено каждое значение dp в отдельном массивчике,
как именно было получено
каждое конкретное значение.
И с его помощью, начиная
от конца и как бы разворачиваясь
к началу, то есть,
от последнего элемента я крышал,
восстанавливаете как именно вашу дп-паспорт.
Там же вы поймете,
ну, то есть, вы в этом
раздомеете все, кем нужно построить,
и таким образом можно посчитать ноб,
конкретный ноб, пульсус,
что надо, то всегда сможете найти.
Окей?
Так, хорошо.
Хорошо.
Следующая задача.
Пусть нигде больше возрастает
в последующем.
Нигде больше возрастает
в последующем.
Задача.
Есть массив.
Нужно в нем выбрать
подпоследовательность.
Опять подпоследовательность.
Когда надо, мы какие-то элементы вычеркиваем,
остальные склеиваемся в нишки подряд.
То есть, мне не обязательно
подотвердить именно подпоследовательность.
Надо выбрать подпоследовательность,
которая возрастала, то есть,
все элементы в ней идут слева-направо
про это увеличение, и при этом
формально нужны институты.
Так, подпоследовательность
с ней может указать.
Двигаем, чтобы все было в порядке системы.
Это не так.
Подпоследовательность, чтобы все элементы
темнота уничтожили.
Так.
Ну, давайте начнем с
какого решения?
Давайте веду следующее.
Любой любительный академик
это минимальная возможность
решения последних элементов
в возрастающих подпоследовательствах
длины ровно как,
которые используют только
первый элемент.
То есть, минимальное значение
последнего элемента
в возрастающих подпоследовательствах
длины как,
если можно использовать только элементы
в возрастающих подпоследовательствах
длины ровно как,
которые используют только элементы
в возрастающих подпоследовательствах
длины ровно как,
если можно использовать только
один экзолеакадемик.
То есть, смотрите,
если я сначала хочу начать
расследовать моего массива,
там бывают разные
возрастающие подпоследовательства.
Они бывают разной длины.
И мы не знаем, какая именность
них сам нападет.
Например, здесь может быть что-нибудь,
мы возрастающие подпоследовательства
длины, например, 3, вот такая,
1,5, но тогда понятно,
что это, наверное, не очень оптимально,
потому что это в соне нам очень сильно
мешает на 20%
А, например, если мы хотели бы
изменить длину шва,
так, давайте вот так сделаем,
если мы хотели бы делать длину 2,
например, у нас есть вот такая, пассис 1,3,
может быть, такое,
есть, в которой-то сложной праве этой сонни,
то, возможно, 3 это минимальное
подследнее значение, да,
в этом случае пассис длины 2.
В общем, как-то здесь четко понятно.
Мы не знаем, какую кокаиную систему
нужна длина, чтобы оптимально
попросту продавать,
но понятно, что если длина 2 сделана,
то нам выгодно как можно
изменить этот последний элемент,
чтобы дальше было жить как можно проще.
То есть, если я знаю, что длина ровно так,
и я могу закончить
в нескольких элементах
вот этот пассис длины, да,
но что если я кончу в нескольких элементах,
то понятно, что из них нужно выбрать ту,
которая самая маленькая,
потому что дальше я могу наиболее
свободно считать.
Если здесь можно только строить 3,5,
потому что это значит, что вот здесь
я могу только добавить немножко пассис.
А в этом случае длина.
Вот, ну, давайте
идем попромосить.
Так, да.
Ну, во-первых,
я не говорю, конечно,
что ровно.
Если такой пассис не существует,
то там, в принципе, плюс бесконечности.
Так, и здесь.
Ну, вот,
и здесь.
Ну, вот,
и здесь.
Ну, вот,
и здесь.
Ну, вот, и здесь.
И плюс бесконечности.
Это стандартное положение,
что если я пытаюсь
хранить там минимальное значение чего-то,
а этого чего-то вообще не существует,
то я буду хранить там промоложение плюс бесконечности
как знак того, что оно, в принципе,
не достижено.
Так вот, я вот считаю,
что в любом времени, в любом одни,
вот этот массивчик,
деперитая первая, вторая, третья и так далее,
это строго возрастающий массив,
если я буду генерировать плюс бесконечности.
Так, деперитая точка
это возрастающий массив.
Ну, то есть, он имеет какой-то
такой, давайте
с ней будем кушать.
А с какого-то момента
парк симптует бесконечности.
То есть, это деперитая первая,
это деперитая вторая, это деперитая третья, четвертая, пятая
и так далее.
Значит, ну почему?
Это вроде бы трибиально.
Понятно, что если у меня есть массовый дымный кар,
который заканчивается где-то,
есть массовый дымный кар плюс один, который где-то еще заканчивается,
то, конечно, это число может быть
только больше, чем это.
Потому что, иначе, если вот это
вот, например, да, то есть, как можно противнное,
пусть Db и Dk
больше равно Db и Dk
плюс D.
Давайте рассмотрим
Db и Dk плюс D. Что это такое?
Это какая-то посетка
с длины k плюс один,
которая заканчивается вот на таком элементе.
То есть там что-то что-то с длиной k плюс один,
которая заканчивается на Db и Dk плюс D.
Но тогда вот это последний элемент.
Это последний элемент
возрастающего с длины k.
Потому что если это была
посетка с длины k плюс один,
то это будет уже с длины k.
Поэтому вот этот элемент
это, в частности, одну из
возможностей совершения
под последней с длины k.
Поэтому эта штука должна быть точно меньше
набравной, чем вот эта.
Но за счет того, что здесь значок будет
такой строго меньше, потому что это строго
возрастает с посеткой, а это еще меньше
набравной, чем вот эта,
ну, то мы получим противоречие.
То есть, получается, что минимальная
возможность совершения под след с длины k
собственно, возможно совершать. Там противоречие.
Давайте еще раз чуть подробнее.
Вот если это x, то x меньше, чем dp, если я каплюсь первым.
Потому что они были в одной возрастающей процедуре, длиной ка плюс один.
Ну и потом, по предположению, это меньше вравно, чем dp или diakata.
В итоге x строго меньше, чем dp или diakata,
но x это одно из возможных завершений процентов длины ка,
а это минимально возможный х-слок, в котором заканчивается процент длины ка.
Там противоречие. Это 1 из, а это минималь. Не может быть 1 из меньше.
Противоречие.
Значит, нужно всегда идти в такое возрастающее.
Сначала там числа возрастают, потом будет бесконечность.
А, конечно, если в какой-то момент будет бесконечность, то дальше тоже будет бесконечность.
Хорошо.
Значит, что происходит с этим массивом, когда мы переходим от i к плюс 1?
А, да, я пишу с этим массивом.
При переходе от i к плюс 1.
Вот вопрос.
Какие принципы гипнотических значений может принимать вот это вот значение?
То есть, если у меня...
Вот раньше я рассматривал в массиве все роковые элементы.
Теперь добавляю логу i к плюс 1.
И хочу найти dp или плюс первая карта.
Какие значения может принимать это значение dp?
Либо i к плюс первая, либо предыдущая dp. Все правильно.
Я утверждаю, что гарантированно вот эта штука это либо вот это, либо вот это.
Ну, это очень просто.
Как именно? Что это такое?
Это минимально возможное завершение под последствием с длины k.
Что такое возрастающая, конечно.
Что такое возрастающая под последствием с длины k?
Она либо содержит, а я предыдущая, либо не содержит.
Если содержит, то она на него заканчивается, поэтому это оно и есть.
Либо она его не содержит, и мне нужно найти наибольшее, то точнее, наоборот, наименьшее завершение
для возрастающих под последствием с длины k вот в этом массиве.
А это dp у меня уже почти.
Ну а поэтому в новом флоте, то есть для нового i,
каждое значение dp принимать одно из двух значений.
Либо вот это, либо вот это.
Либо значение нового элемента, либо значение наследника из предыдущего массива.
То есть при переходе от i к плюс 1 у меня значение сохранится.
Давайте я напишу даже вот так.
Вот, хорошо.
Но, смотрите, мы же с вами знаем, что этот массив тоже должен быть возрастающим.
Мы с вами доказали, что массив dp i t возрастающий,
то же самое, конечно, работает и для i к плюс 1.
Dp i t плюс 1, как массив, тоже возрастающий.
Значит, в частности, я могу заменить его значение на i к плюс 1 не больше, чем один раз.
Потому что, если я два каких-то различных элемента здесь заменяю на i к плюс 1,
то массив уже возрастающий, строго возрастающий быть не может.
Если есть два одинаковые значения где-то, он точно не возрастающий.
Но он не строго возрастающий.
Если есть два одинаковые, то он не может возрастать.
Поэтому получается, что массив новый от предыдущего отвечает максимум в одной позиции.
То есть я знаю, что каждое новое значение dp, x, y каты, это либо предыдущие dp, y, z каты, либо i, y, y.
Но это не может больше, чем один раз встречаться, то и два раза не встречаться не может,
потому что иначе обнаруживаются свойства возрастания.
Значит у меня максимум один раз от предыдущего встречается.
Вывод.
Dp и п.
Отличается от dp читого
не более, чем в одной позиции.
Надо понять, какой.
Начнем с какой. Давайте посмотрим примере этого массива.
Вот был у меня предыдущий dp.
Dp и п.
И допустим, я на веру, что предполагаю новое значение.
Прошло число 20. Следующий число массива это 20.
Но вопрос, как это меняет этот массив dp при переходе и плюс один.
Смотрите, единственное, что я могу сделать, это какой-то из этих чисел поменять на 20.
Понятно, что вот эти вот числа, которые меньше, чем 20, менять я не могу.
Потому что если я что-то из них поменяю, то вот это за что могу поменять.
Ну короче, если я поменяю что-то из них на 20, то у меня нарушено свойство возрастания.
Поэтому их на 20 поменять нельзя.
Это на 20 поменять можно, но это как-то глупо.
Потому что если у меня раньше была возрастающая последовательная длина 4, которая заканчивается на 17,
а теперь появилась такая же, которая заканчивается на 20,
то понятно, что нужно оставить 17.
А нет смысла увеличивать те числа, которые там уже и так есть.
То есть если была последовательная длина 17, то последовательная длина 20 нам не выйдет.
Мы ее игнорируем.
Но я вот даже в таком случае надо 22 поменять на 20.
Потому что у меня раньше была последовательная длина 4, которая заканчивается на 17,
и теперь я книжу справа и буду писать на это число 20.
У меня будет последовательная длина 5, которая заканчивается на 20.
А раньше была только на 22.
Понятно, что было из этих двух.
Надо выбрать 2.
На этом примере мы делаем вот примерно следующее.
Нужно в текущей массиве Db взять число,
наименьшее число, больше или равное, чем i equals 1,
и заменить его на i equals 1.
Значит алгоритм не такой.
Да.
Давайте, чтобы не было конфликта по значению чужих,
пусть P до минимальных позиций,
пока что Db,
давайте он не Db будет взять, как он по другому массиву делал.
Пусть будет массив B.
Pt больше всего равно a.
Тогда я делаю Pt равно a.
Извините за новое подношение.
Что я сделал?
Чтобы не хранить, я не буду хранить двумерную динамику,
потому что я понимаю, что массив только в одном элементе меняется каждый раз.
Я не буду его много раскопировать.
Я скажу, что у меня вот это текущая Pt.
Когда соответственно в массиве D у меня было одно число,
одно за другим меняется.
B это текущая массив Dp.
Я на этом уровне вынимаю эту пиксу, которая больше равна числа a,
и ее меняю на a.
Где же это?
Новый рассматриваемый уровень.
Все.
Значит почему это будет работать?
Ну смотрите, давайте я нарисую подробнее.
Вот был у меня такой массив.
Там какой-нибудь Pt,
первая и так далее.
И вот это число, это наименьшее число больше равное, чем a же.
Больше равное, чем a же.
Значит, ну тогда соответственно работает все то же самое.
Все числа, стоящие вот здесь вот, левее, чем Bp,
они точно меньше, чем a же.
Но потому что Bp это первое большее равное.
Если Bp это первое большее равное, то все предыдущие меньше.
Значит вот эти меньше, нет смысла увеличивать до a.
Нет смысла маленькие числа поднимать, которые большие.
Потому что если была подпасенность закончена в маленьком числе,
нет смысла ее последний элемент увеличить.
Вот эту штуку мы можем спокойно и беспрепятственно уменьшить до a же.
Потому что у меня было Bp-1 меньше Bp,
у меня есть подпасенность длинной Bp-1,
которая закончена в таком числе,
и эта штука меньше, чем a же.
Я могу продлить с помощью нового, только что прошедшего лимита a же,
до последнего длины B.
Поэтому по этой Bp я смогу смело заменить на a.
Вот.
Но если больше, я уже менять не имею права.
Да, ну понятно, что если здесь произошла замена,
то есть если здесь было скажем больше,
то я не могла заменить, и может тогда нарушилась бы...
А ну нет, что я...
Просто если здесь произошла замена,
то нигде правее замена произносить не могла,
потому что иначе у меня нарушил свой связь с возрастанием.
Поэтому замена матчу 1, и она вот здесь.
Все.
Вот такой алгоритм.
Значит, ну надо еще позабыть свой том, с чем начинаем.
Я, наверное,
мы с ним B вот так вот определю.
Видимо, мы так можем сделать.
То есть я скажу, что B0 это минус бесконечность.
Что означает, что как бы патент длины 0,
она не имеет последнего элемента,
ее можно продолжать чем угодно,
поэтому я скажу, что это как будто бы последний элемент
не имеет бесконечности.
А все остальные элементы, как бы патент длины 1, 2 и так далее,
они еще не существуют, поэтому там будет бесконечность.
Вот это означает массив.
Потом я в N раз делаю вот эту штуку.
Посмотрите, это просто бинарный пояс, да?
Это просто бинарный пояс.
Ну, потому что это пояс какого-то числа,
а вот цифрованного массива.
Мы знаем, что массив B всегда возрастающий.
Мне нужно в нем найти наименьшую позицию пояса,
которая равна данному числу.
А это бинт пояс.
Целый алгоритм просто.
Вот.
И у этого цикла в массиве B подняться оптимально для каждой бинты.
Вот, и тогда ответ.
Это, видимо, максимально такой P,
что ВПТ неравном плюс бесконечность.
Да, потому что...
Что же такое ВПТ?
ВПТ – это либо минимальное соглашение по смыслу ВПТ,
либо плюс бесконечность, и это ее так и не существует.
В соответствии с возможным максимальным ВПТ,
который ему существует,
это будет как раз таки бинарный пояс.
Это бинарный пояс.
Итого, мы в данный момент построили...
алгоритм, находящийся в собственном двинном доме.
Вопросы?
Скоро.
Всю неделю, я надеюсь.
А это именно?
Да.
Ну, я знаю.
Вечи видны.
Еще одно алгоритм алгоритма?
Вот.
Хорошо.
Давайте мы теперь сделаем новое алгоритм.
Короче, чуть более для понимания.
Ну, используем фруктуры данного.
Решение нужно два.
Нас будет зачем другая фруктура?
Значит, пусть такое ИТ,
это длина,
это длина,
наибольшая длина возрастающих от последовательностей,
если мы можем использовать только первые две элементы,
и при этом последние элементы нельзя взять.
Наибольшая длина
возрастающих от последовательностей,
в следствии,
можно использовать
только
1 и так далее аин,
причем аин обязательно вся
в возрастающих последовательностях.
Значит, тогда,
если мне, например, известно значение ДПС на всех
начальник отряда 1 до И,
ну или когда имя не сходится,
то имя сходится в какое-то длинное.
Я хочу построить
какой-то возрастающий пасет,
который заканчивается в аи.
Давайте продолжаем, берем последний элемент.
Тогда предпоследний элемент это какой-то клиник слева,
который меньше, чем аин.
Поэтому мы будем церковно выражать,
максимум пасета х меньше, чем и,
и такие, что а х меньше, чем аин.
То есть они идут в плюс ДПЖ.
Например.
Например, если я заканчиваю все аин.
Давайте я, конечно, рисую.
Я хочу измерить в том, что я имею все аин.
Давайте переберу предпоследний элемент.
Вот, сейчас я смотаю их.
Тогда будут два условия.
В-первых, мы находимся в элемент, который подмен patriot.
Если для всех таких,
если я же, что я как бы предзаканчиваю
заканчивается в мой предпоследний этаж, и мне нужно просто найти максимальную дыну
позаходящей поцелусти напрямую с первого положительного элемента, где h включено.
Ну, это как раз просто DP6. В плюсы гейта за счет того, что я вытолкнул.
Да?
Вот.
Сейчас вот тут мы сразу вновь получили квадратичное решение.
Потому что я могу просто ямой для каждого из них перебирать все предыдущие жиры,
которые имеющие магни, из них убрать максимум и прибавить на крючок.
Это уже будет квадрат.
Вот это можно тоже до венбоквен межировать. Давайте сделаем.
Так.
Значит, двум приемом.
Смотрите.
Я вижу, что DP8 выражается в DP для тех, у кого aj меньше, чем aj.
Поэтому раздумно рассматривать все элементы нашего массива в порядке увеличения.
Сначала минимальный, потом второй, да, вторая порядка, третья, четвертая и так далее.
И тогда, к моменту рассмотрения aj, как раз такие просмотры будут только такие, которые ай меньше, чем aj.
Ну и, соответственно, будут только условия, с которыми нас падает только те, которые любят.
Поэтому давайте делаем вот это следующее.
Давайте мы изначально все к DP заполняем венбоквен.
Убьем все элементы.
И будем их восстанавливать и воскрешать порядке увеличения.
Значит, ну здесь надо аккуратно ввести ай, ай, ай, ай.
Ай, ай, ай.
Ай, ай, ай.
Ай, ай, ай, ай.
Ай, ай, ай, ай, ай.
Ай, ай, ай, ай.
Ай, ай, ай, ай.
Значит, ну здесь надо аккуратно вспоминать, что происходит с элементами равными.
Давайте я буду считать, что у меня нет равных.
У меня равных нет.
Но если они равны, то на самом деле равные, то можно воскрешать порядок справа налево.
Если есть ту равную, то воскрешаем порядок справа налево.
Значит, нужно знать тем, что в момент рассмотрения ай, у меня должны быть слева все элементы, которые имеющие ай.
Я их должен был все раскрыть.
И чтобы как раз элементы равные ай не мешали, я хочу иметь их справа налево.
Воскрешаю элементы равные ай и иду справа налево, чтобы те, которые я вижу, не мешали иметь слева.
Если я иду справа налево, то они будут не мешать.
Если я иду справа налево, то они будут не мешать.
Вот.
Ну и все.
Дальше нужно просто придумать какую-нибудь структуру данных, которая позволяет делать изменения в точке и находить максимум на отрезке.
Потому что вот здесь вот у меня предстоит представление ленты H&K, а здесь максимум на отрезке по всем вымещеним.
Что это за структура такая?
Ну что угодно.
Например, дерево отрезка или дерево феновика.
Феновик тоже годится, потому что здесь в нашей структурке все значения будут только увеличиваться.
И запрос максимум только на префиксе будет происходить.
То есть мы видим, что здесь же меньше мыд префикс.
Поэтому даже хватит феновика.
Ну давайте я это напишу.
На прямой работе I.
На ходе.
Просто максимум по всем вымещеним.
Как раз вот это вот условие.
Я могу это сделать, потому что все элементы, которые больше либо равны, они как бы не рассмотрены.
И для них Db равна 0.
Db равну 0.
Поэтому иногда вот я напишу в максимум.
То есть вот здесь, из-за того, что они здесь появляются, я максимум не изменяю.
Потому что там появляются нулевые элементы, у меня максимум не меняется.
Поэтому я могу просто рассматривать максимум на отрезке.
Значит при обработке I находим вот эту штуку.
Ну и дальше обновляю.
Обновляю.
Dp и t равно 1.
Найду другую тупую цель с длиной x и ее дополняю новым элементом I.
Здесь сгодится...
Каждую структуру сгодится делим отрезков.
Или берем феновика.
Потому что мне нужно уметь делать увеличение элемента и макро на префиксах.
А это уметь делать и фен, и пт.
Понятно?
Хорошо, тогда сгодится у меня будут нлубы.
Потому что я один раз делаю запросы типа getMax и update.
У меня n запросов марш на отрезке, и n запросов обновляю.
Вот.
А, надо сказать еще ответ.
Ответ, скорее всего, где лежит?
Где?
Где?
Где?
Ответ, скорее всего, где лежит?
Где?
Не, он же не прав.
Да, max и max, потому что мы не знаем, где мы, на самом деле, должны заканчиваться.
То есть Dp и t у меня насильно предполагают, что I и t это последний элемент моей последовательства.
Я не знаю, где, на самом деле, мы заканчиваемся, поэтому из всех нужно выбрать максимально.
Max, max, I и t.
Ну и, собственно, все.
Здесь, например, точно так же можно поставить ответ.
Я это делал в предыдущем способе, через BinBoys.
Там, собственно, я чуть похитрее, потому что мне нужно в каком-то смысле куда-то пересекать массив.
Не буду подробнее.
Но вот здесь, на основании ответа, все довольно прозрачно.
Нужно просто, как обычно, в момент присвоения Dp и t уметь определять,
а каким образом я получил этот максимум.
То есть, за счет чего, вот здесь написано 1,2x.
За счет того, что я нашел здесь какой-то произведенной ж, что Dp и t равно x.
Поэтому мне нужно как бы на этой структуре уметь не только максимум, но и позицию максимум.
Если я это у меня делаю, то я вот здесь вот также обновляю, чтобы i и t равно x.
То есть, я запоминаю, как именно был получено в текущей начине Dp в вспомогательной массиве P.
На и опять-то, любого D, узнаем, как именно получен x.
Ну, скорее, где именно?
Где именно получен x?
Мы тогда кладем Piter, но Piter уже держит вот та самая ячейка, где получен x.
Но если я знаю, как именно получит каждая начинка Dp, то Dp и t получатся, по сути, через Dp и t.
Тогда то же самое, просто у меня с восстановлением с конца работает, я знаю, где левоответ, это максимальная Dp.
И дальше по одному откусываю последний элемент, переходя к предыдущему в моей поцелусти.
И я могу целиком восстановить нашу Dp.
Все, спасибо.
