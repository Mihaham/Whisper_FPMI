Окей, седьмая лекция, на прошлой лекции мы с вами закончили о том, что мы ввели с вами что такое сеть,
что такое поток, что такое величина потока и порисовали картинки. Вот, это в принципе наше
великое достижение, однако теперь будем пытаться учиться искать максимальный поток, а для этого
понадобится новый инструмент. Остаточная сеть для сети N, напомню, что это у нас такой интересный
кортеж VECST, где C это какая-то неотрясательная, можно сказать, положительная функция на множестве
ребер. Вообще мы проявили на декартом квадрате, поэтому лучше на декартом квадрате V. S и T это элементы,
S и T мы считали различными. И все. И потока, так, для сети и потока F. Это у нас будет внезапно сеть,
будем означать N с индексом F, определяется оно вот так вот. GF, VEF, CF, ST. То есть смотрите,
у нас меняются ребра, у нас меняются вестимости. S и T остаются, вершинки остаются. Теперь мы будем
определять компоненты, которые поменялись. CF это, собственно, самое интересное. Для любых У,
для любых УВ из В. CF от УВ. УВ. Определяется следующим образом. Здесь будет несколько веток
определения. Первый вариант это С от УВ, минус F от УВ, если УВ лежит в Е. То есть если у нас было
ребро и мы пустили по нему какой-то поток F, то остаточная профессиональная способность вот так
вот. Дальше. Сейчас будет самое интеллектуальное. F от УВ, если ВУ лежит в Е. То есть смотрите,
здесь у нас если УВ лежит в Е, то мы берем само ребро. А если у нас лежит обратное ребро,
то мы берем поток. Я нарисую потом. Ну или иначе. Соответственно, EF. Это множество УВ из В квадрат,
таких, что CF от УВ больше нуля. Как это понимать? Давайте на примере. Так, будет С.
Не так. Давайте нарисуем такую сеть. Классическую. Да, и расставим в местимости какие-нибудь.
Давайте вот так вот расставим их. Вот. Например, мы пустили поток. Это наша исходная сеть. Давайте
пустим поток. Такое, что здесь будет, не знаю, один из трех. Здесь один из одного, здесь один
из одного, здесь один из двух. Да. Тогда как будет выглядеть остаточная сеть? Снова рисуем
наши четыре вершинки. Это S, это T. Так, это AB давайте будем обозначать. Давайте читать,
чему равно CF от AB. Нет, от SA давайте сначала посчитаем. CF от SA чему равно? Смотрим. Ребро
SA у нас было изначально в E, поэтому используем эту ветку. Получается 3-1, то есть 2. Остаточная
вместимость. Аналогично возникает обратное ребро. Вместимости 1. Абсолютно аналогично
здесь ребро вместимости 1, ребро вместимости 1. Давайте с SB посмотрим. Так, из SB ребро было,
значит используем эту верхнюю ветку. При этом у нас capacity 1, поток 1, значит пропускная способность
0. А здесь мы определяем EF как то, у чего больше нуля пропускная способность. Поэтому здесь
ребра из SB не будет. Однако будет вот такое вот ребро. Так, аналогично здесь появятся обе стороны
ребра. Обе стороны. Это вот так вот. Так, из AFB мы не пускали поток, поэтому как было, так и будет.
Вроде бы похоже на правду. Такая вот остаточная сеть. Собственно поэтому мы запрещали антипараллельные
ребра, потому что у нас возникает обратное ребро в остаточной сети. Потому что мы пустили сюда,
у нас было ребро из SB. Смотрим. Ребро из SB есть в E, значит есть ребро из B в S по этой ветке. То есть
вы для каждого ребра рисуете два изначально. То есть здесь как бы формально здесь существует
ребро пропускной способности 0, но оно пропускной способности 0, поэтому мы его игнорируем. Вот и все.
Аналогично здесь у вас тоже появляется ребро пропускной способности 0. То есть вы каждое
ребро делаете двунаправленным и ставите соответствующие емкости. Собственно да,
если бы у нас в изначальной сети мы разрешали себе антипараллельные ребра, которые вот такие вот,
то у вас бы в остаточной сети еще было бы вот так вот. Круто да? И разбираться кто где вообще неприятно.
Поэтому мы избавили себя от такой чести тем, что избавились от антипараллельных ребер путем
введения искусственной вершины. Это мы с вами судили на прошлой лекции как это делать.
Здесь у вас может закраться смутное сомнение, что остаточная сеть, казалось бы, это то сколько
потока еще можно протолкнуть. Вроде бы логично, да? Вот это вот действительно сколько потока еще
можно протолкнуть, но это тоже естественная ветка. А вот это что такое? Вот это то,
что вы позволяете себе отменить единицу потока. Как это понимать? Давайте нарисуем еще один пример
по этой же сети. Давайте ее оставим, только нарисуем еще один пример, когда нам это будет нужно.
И везде поставим врусные способности 1. И, допустим, я взял поток вот такой вот.
Прикольно, да? Давайте нарисуем остаточную сеть. Здесь будет сюда 1, здесь будет сюда 1,
так, здесь будет сюда 1, здесь будет сюда 1, а здесь будет в обратную сторону 1.
Ну и что можно было бы заметить, да? Что, по сути, у меня этот поток не максимальный,
мне выгоднее пускать не здесь единичку, не вот так вот брать поток, а вот так вот взять,
получится 2 единицы потока. Ну и мы потом докажем, что это будет связано с остаточной сетью,
что если у нас есть путь из ТФС в остаточной сети, то поток не максимален и наоборот. Но
пока что это какие-то тайные знания, и это может быть максимум на уровне интуиции. Вот. А так,
еще определение. Дополняющим потоком, потоком f'nf, давайте для nf, дополняющим же для чего-то,
назовем поток f'nf, то есть это вы смогли пустить еще единичку потока, ну или больше, чем единичку
потока. Как, например, вот здесь вот можно пустить в остаточной сети еще раз-два, и допустим,
ой, наоборот, тут путь из f так, конечно, должен быть. Вот, ну это потом поймем почему. Ну смотрите,
у вас был поток f, вы по нему построили остаточную сеть, вы бахнули еще поток f' туда и вы дополнили,
как бы, поток. Мы пустили его именно в остаточной сети, то есть вы как бы пустили в этой сети еще
поток, допустим, раз-два, такой вот, или вот здесь вот, то ли вот этой вот траекторией. То есть давайте
посмотрим, что происходит, если я опускаю здесь дополнящий поток вот такой вот. Я же могу его
пустить, да? Вроде все подходит по определению. Тогда что я получу? То есть это будет, если это
было n, это будет nf, то это будет nf плюс f'. Так, снова две вершинки и еще одна т. Так,
смотрим, кто кого. Получается, здесь у меня единичка, потому что в обратную сторону пускаю,
здесь снова единичка, здесь единичка, здесь единичка, и здесь вот сюда будет единичка. Вот,
и вот здесь вот уже из этого f' я не могу дойти. Вот, это будет критериям того, что поток максимальный,
если что. На этом где-то минут через 50, наверное, до этого дойдем. Вот, а пока что, вот мы называем
это определением потоков. Ну, этот поток понятно. Давайте еще сделаем определение одно.
Сложение потоков f и f' определяется. Для любых u, v из v f плюс f' от u,
у. Сейчас будет самое страшное. Так, f от u, v плюс f' от u, v минус f' от vu. Вот так вот.
То есть, вот это естественная часть, вот это неестественная надбавка, ну, точнее наоборот,
отбавка. Почему она возникает? Потому что у вас возникает и прямое ребро, и обратное
ребро в остаточной сети. Поэтому приходится с этим считаться. Ну, теперь нужно доказать естественное
утверждение. Пусть f' это дополняющий поток vnf. Тогда f плюс f' это поток vn. То есть,
мы-то с вами, конечно, классно определили поточечное сложение потоков, но теперь надо доказать,
что наше поточечное сложение это поток. Незапно это не очевидно. Кому очевидно, поднимите руку и
выйдите, докажите. Это первая часть утверждения, а вторая часть утверждения, что модуль f плюс f',
вот так, что величина потока с дополняющим, это сумма величин потоков. Давайте доказывать первую
часть, что это вообще поток, что вывлечает из него величину. Так, что у нас было в потоке? Поток
это функция, которая, я напишу красненько, мы определяли вот так вот, поток, это первое
свойство, потому что у нас ограниченность. А второй свойство, то, что там было, сколько втекло,
столько и вытекло, закон сохранения потока. f плюс f', вообще, поток. Давайте доказывать первую часть f
плюс f', будем доказывать сначала неотрицательность. Ну окей, для любых УВ из В, f плюс f' от УВ,
по определению пишем f от УВ плюс f' от УВ минус f' от ВУ. Так, теперь, что мы с вами говорим?
Давайте скажем, что это больше либо равно, чем это мы не тронем, это мы не тронем, а это оставим,
вот таким вот образом заменим. Ну поток всегда меньше вместимости. Вместимость, когда вы строите f',
это cf, поток всегда меньше вместимости по определению, поэтому я имею право так заменить. У вас поток не
больше, чем capacity, ну или емкость, соответственно, минус поток больше либо равно, чем минус емкость. Так,
ну что еще хочется теперь сделать? Да, мы, естественно, смотрим, что УВ, давайте из Е,
конечно же, их напишем. Почему? Потому что мы смотрим поток изначальной сети в Н, да? Значит,
нам выгодно, адекватно рассматривать только для тех ребер, которые были в сети изначальной.
Вот, окей. Хорошо, а если у нас сети изначальный, то тогда что можно заметить? Что остаточная
пропускная способность ВУ, она у нас по сути, потому что смотрите, что у нас происходит,
если у нас УВ было в сети, то cf от ВУ определяется как f от УВ просто-напросто. Согласны? Ну,
просто по второй ветке определения. Поэтому я здесь могу написать вот так вот просто, что это f от УВ
плюс f' от УВ минус f от УВ. Просто по второй ветке определения я раскрываю cf от ВУ. Так,
ну это равно этому, то есть это равно f' от УВ, ну что по свойству потока не отрицательно. Так,
окей, доказали не отрицательность. Давайте во вторую сторону доказывать. То есть вот эту
штуку. Пункт Б. Так, ну давайте. Снова пишем для ребра из ДЕ f плюс f' от УВ. Что? В смысле
нет. Мы оцениваем f плюс f' все время. Нам нужно показать, что это больше уровня нуля, чем мы будем
показывать, что это меньше уровня capacity в любом случае. Так, это у нас кто такой? Это f от УВ. Здесь
вроде будет проще. УВ минус f' от ВУ. Так, ну давайте сделаем вот как. А, ну здесь предлагают сделать вот
так вот. Забить на третье слагаемое просто. Но в силу того, что у вас поток не отрицательный,
в вычитании его такое уменьшает выражение. Ставим только два первых слагаемых. Так,
теперь давайте поймем, что такое f' от УВ. f' от УВ будто бы хочется сказать, что это вот так
хочется написать по определению. Согласна, да? Ну потому что поток в остаточной сети не может
быть больше, чем capacity в остаточной сети. Просто по определению потока f'. Ну теперь просто-напросто
заметим, что УВ лежит в Е, поэтому мы пользуемся этой веткой. Вот она. То есть cf от УВ равно c от УВ
минус f от УВ. Откуда cf от УВ плюс f от УВ? Это c от УВ. Ну доказали. Доказали, что f' плюс f' это
пункция, которая лежит вот в таком вот промежутке. Остается доказать, что это сохранение потока.
Как у нас говорилось свойство сохранения потока? Что для любой вершинки В из В без С и Т,
что мы хотели с вами? Мы с вами хотели, чтобы сумма по У из Вf от УВ равна была сумме по У из Вf от Ву.
То есть это то, сколько втекает в В, это то, сколько вытекает из В. Мы хотели, чтобы это было равно.
Ну давайте мы это же и запишем. Давайте любой У будем суммировать, чтобы у вас потом в конспектах не возникало
проблем с тем, что буквы разные. Выписываем просто определение. Так, по В из В f плюс f' от УВ. Вот вы
хотим понять, что эта сумма будет такой же. Ну давайте этим займемся, что мы для этого сделаем.
Для этого запишем определение для начала просто. По В из В f от УВ плюс f' от УВ минус f' от ВУ.
Ну окей. Что тогда можно сделать? Заметим следующее, что для f верно сохранение потока.
Согласны, да? Ну потому что f по определению. Тогда я могу просто здесь переставить ВУ местами.
Ну аналогично для f' верно сохранение потока.
Поэтому здесь для f и f' верно сохранение потока. То есть я могу здесь переставить,
здесь переставить и здесь переставить буквы. То есть здесь как раз-таки все очень просто.
Ну тогда я могу заключить, что это просто по определению сложения потоков f плюс f' от ВУ.
То, что требовалось доказать. Мы доказали, что f плюс f' это поток. Вау, это было интеллектуально.
Да, по В. Это сколько в f текло, это сколько из В вытекло. Так, второй пункт. Хотим,
что модуль f плюс f' это модуль f плюс модуль f'. Причем, напомню, что модуль f это сумма по всем.
Так, сейчас давайте скажем это так. Вроде похоже на правду, что можно это так определить.
А, ну нет, конечно же нельзя, потому что у нас сейчас минус суммы обитекающих.
Во, теперь правда. То есть это сколько из f вытекает, это сколько из f втекает. Вот это
наше определение было. Ну давайте напишем определение модул f плюс f'. Это просто
сумма по всем В из В f плюс f' т.е. до В. Минус сумма по всем В из В f плюс f' из В в С.
Ну будто бы хочется взять да расписать все это в 6 сумм. Никогда не возникало такого желания.
Балдеж. Ну сейчас с этим будем заниматься. Так. А, ну да, окей. Давайте еще обозначу вот такую
вот штуку. Что В1 это у нас будет множество таких В, что СВ лежит в Е. В1 это 1. Аналогично В2
определю где-нибудь здесь. Ну чтобы мне было удобнее писать суммирование. То есть это ребра
входящие в С. То есть ребра исходящие из С это исходящие из С. Наоборот, это исходящие,
все уплыли окончательно. То есть по сути я здесь могу написать вот так вот. Потому что это по сути
те, кто из С входит, это те, кто в С входит. Вот. Ну окей, теперь просто-напросто это все запишем.
Так, это что такое? Сумма по В из В1 ф от С до В по В из В1 ф штрих от С до В минус сумма по В из
В1 ф штрих от С. Минус. Так, выписываем дальше. Минус по В из В2 ф от ВС. Минус по В из В2
ф штрих от С до В. Получается плюс сумма по В из В2 ф штрих от В до С. Да. Сейчас,
так, минутку. Здесь ВС, здесь ВС, а здесь СВ. Во, вот так вот. Почему? Потому что у меня здесь
изначально ВС, здесь не меняю, здесь не меняю, здесь должен поменять. Во, все, теперь сложилось.
Это я группирую с этим, это с этим группирую, это с этим группирую, это с этим группирую. Так,
что это такое? Напишу сразу, что это сумма по В из В1 ф от С до В минус сумма по В из В2 ф от ВС.
Проницательный зритель сразу поймет, что это такое, что это модуль F. Так, поехали дальше.
Плюс сумма по В из В1 с В2 ф штрих от С до В минус сумма по В из В1 с В2 ф штрих от В до С. Так,
ну давайте. Кто не согласен с тем, что это модуль F? Здесь я могу В1 расширить до В,
суммирование просто до В. Почему? Потому что все остальные такие потоки это 0. Поэтому здесь я
могу убрать индекс 1. Аналогично, здесь я могу убрать индекс 2. Поэтому это просто F. Все,
что в скобках, это модуль F. Так, и здесь что я могу сказать? Что, по сути, то, что я здесь написал,
это, конечно, классно, но здесь В1 с В2, я также могу на В заменить просто-напросто, потому что для
всех остальных поток 0 будет. Поэтому здесь я могу написать плюс сумма по В из В ф штрих от С до В
минус сумма по В из В ф штрих из В в С. Но это по определению просто величина ф штрих. Конец.
Второе по сложности утверждение доказали. Скоро будет первое. Пределение в сети N равный
JVE CST. Разрезом ST называется A. Ну, пара ST такая, что S, D, V, ST это V. Ну, и то, что мы с вами в
как раз делали, что у нас пересечение пустое, а их объединение полностью это множество вершин.
И второе это то, что и ST лежит в одной доле, ST лежит в другой. Мы здесь их вот так вот разделять
будем. Дальше определение. Пропускная способность разреза определяется крайне интеллектуально.
Так, С от УВ. То есть рассматривается серебра из ST и берется их суммарная емкость. Еще одно
определение. Поток через разрез. Он уже определяется чуть-чуть интеллектуальнее.
Казалось бы, хотелось бы на этом закончить, но нет. Ужасно. Нам нужно доказать несколько
утверждений. Мы хотим доказать, что вообще поток через любой разрез одинаковый,
если фиксировать поток, то раз. Два, мы хотим доказать, что поток через любой разрез не
превосходит вместимости любого разреза. Три, мы хотим доказать, что они соприкасаются ровно в
одной точке, когда мы находим максимальный поток. И четыре, доказать их вероятность всех этих
утверждений. Собственно, когда мы это все докажем, мы докажем теорема Форта Флкерсона.
Теорема FF. Пусть ST это произвольный разрез. N и фиксирован F. Поток. Тогда
что поток через разрез, это просто лично потока. Мы здесь берем на произвольный разрез,
то есть, в хорошем, здесь надо вешать квантор для любого разреза. F это какой-то фиксированный поток.
Ну сейчас, по-моему, самая дичь. Да, самая дичь. Все дальше просто будет доказывать.
Так, по определению, модуле F это сумма по VSV, F от SV, минус сумма по VSV, F от VS. Да. Окей. Так,
ну что можно сказать? Я хочу сейчас немножко навалить кринжа и добавить сюда слагаемое
одно нулевое. Будет он выглядеть ужасно, но вы не пугайтесь. Переписываем все то же самое.
По U из S без S. Уже страшно, да? А теперь пишем нулевое слагаемое.
Почему это нулевое слагаемое? Потому что это сколько из U в F текло, это сколько из V в U вытекло.
По сохранению потока равно нулю. Поэтому суммируйте кучу раз нулевые слагаемые,
поэтому это 0. Поэтому сумма не меняется. Ну что теперь можно сказать? Я предлагаю раскрыть все это
дело, потому что было две суммы, станет сейчас четыре. Некоторые из них двойные. F от S до V,
F из V в S, сумма по U из S без S, F от V, минус сумма по U из S без S, сумма по V из V, F от V в U.
Так, ну что можно сказать? То есть на самом-то деле, смотрите, я могу здесь переставить порядок
суммирования, согласны? Да, извините, еще сумму надо написать. Здесь сумма по V из V, F от U V,
да, вы правы. Смотрите, что я сейчас буду делать. Я переставлю порядок суммирования здесь. Давайте,
будто бы, напишу, что это сначала сумма по V из V, а здесь сумма по U. И заметьте, что здесь у меня
сумма по V из V дофиксированной S. То есть, по сути, у меня здесь перебираются все V из V, а когда
сгруппирую эту и эту часть, у меня будут перебираться все U из S большого. Согласны?
Аналогично здесь. Поэтому что я делаю? Это просто сумма по V из V, сумма, вот это с этой
группирую, по U из S, F от U V, да, минус, аналогично, сумма по V из V, сумма по U из S, F от V U, да.
Теперь самое ужасное. Что такое суммирование по V большому? Это суммирование по S и суммирование
по T, потому что S и T не пересекаются. Поэтому сейчас я распишу каждую из этих сумм как две. Здесь
я возьму отдельно S, отдельно T, и здесь я возьму отдельно S, отдельно T. Так, получится сумма по V из S,
по U из S, по V из S, F от U V, плюс сумма по U из T, сумма по V из S, F от U V, да. Получаем дальше
6 минус, сумма по U из S, сумма по V из T, ой, V из S, у нас всегда U из S, да, было? У нас U всегда U из S, да?
У всегда U из S, а V мы расписываем по обеим. Понимаете, U из S всегда, это будет S T. Вот так вот.
F от V U, минус сумма по U из S, сумма по V из T, F от V U. Вроде бы на правду похоже. Так,
давайте заметим вот что с вами. Сгруппируем 1 с 3, 2 с 4. Минус сумма по U из S, сумма по V из S,
F от V U. Провинциательный читатель должен сразу сказать, чему равна эта разность.
Давайте, чему равна эта разность. Ну да, потому что по сути вы здесь перебираете ровно одно и то же.
Вы можете понять здесь порядки суммирования здесь буквами местами. То есть вы каждую пару V U
рассматриваете ровно один раз здесь, и точно такую же пару V U рассматриваете здесь один раз.
Ну это примерно как вы будете считать сумму от 1 до N или сумму от N до 1. Суммы получатся одинаковыми,
в конце концов. Поэтому это 0. Это кто такой? А это F от ST. Ну все, доказали. Следствие
для произвольного F, для произвольного ST, F заведомо меньше либо равно, чем модуль F.
F от ST. Я надеюсь, это очевидно. Если нет, то могу расписать. А, давайте распишем.
Ровно F от ST. У нас же F от ST фиксирован, F фиксирован. Значит, я могу расписать,
просто поток через этот разрез. Дальше по определению по U из S сумма по V из ST, F от U в,
минус сумма по U из S сумма по V из ST, F от V U. Смотрим, это по определению поток, значит,
он не отрицательный. Вычитая что-то отрицательное, вычитая что-то положительное, мы выражение уменьшаем.
Поэтому это не превосходит. Просто, ой так, ну поток не превосходит всегда вместимости.
С от U в, что равно С от ST. Ну все, то, что мы хотели. То есть, смотрите, что у нас с вами получается,
картина очень интересная. Вот наша действительно числа какая-то. Здесь какое-то разделяющее
значение. Есть вот какой-то F1, есть какой-то модуль F2, есть там модуль F3. То есть, величины потоков
лежат всегда слева. Здесь будут лежать какие-то там C от S1T1. То есть, какие разрезы вы бы не выбирали,
какой поток вы бы не выбирали, у вас всегда есть меньше либо равно равенство. Поэтому у вас одни строго
справа, другие строго слева. Возникает вопрос, есть ли вот эта вот точка, так сказать, наш вот этот
F со звездой. Вот, оказывается, есть. Есть theorem for the folkerson, огласящая, что если вы нашли поток F в сети
какой-то и он максимален, тогда найдется разрез на емкости равной величине потока. То есть, это
будет максимальный поток или минимальный разрез. Или третье утверждение, что в остаточной сети не
найдется пути из SFT. Так, ну поехали. theorem for the folkerson. Пусть F это поток в сети N.
Тогда следующее утверждение эквивалентное. И давайте выпишем эти утверждения.
Первое, это F максимален, то есть, модуль F максимально. Второе, это NF нет пути из SFT.
Третье, из SFT именно. Если я сказал SFT, то я оговорился, извините. Существует
ST разрез такое, что ZST модуль F. Все теорема. Если мы доказываем, то плюс-минус понятно,
как дальше жить, как искать потоки. Поток будет искать очень просто. Вы будете пускать единичку
потока, строить остаточную сеть, дальше смотреть, правда ли, что там уже нет пути из SFT,
если еще есть, то и делать так до бесконечности, пока поток не останется. Это алгоритм for the
folkerson. Покажем теорему. Так, поехали. Ну, я предложу доказать из 1 в 2 сначала. Самое
простое. Что F максимален, значит нет пути из SFT. Ну, предполагаю противное. Ну, или просто
докажем в обратную сторону. Если NF есть путь P из SFT, это следует, что вдоль P можно пустить
дополняющий F'. Такое, что модуль F' больше нуля, очевидно. Но тогда F не максимальный. Дорога.
Что? Путь P из SFT. То есть, если вы нашли какой-то путь, вы вдоль него пускаете единичку потока,
вы смогли ее все-таки заткнуть, потому что у вас это путь из SFT. Значит, у вас есть F' с величиной
строго больше нуля. Значит, у вас есть поток F' с величиной равной модуле F' с модуле F'. То есть,
что строго больше модуле F'. Значит, F не максимальный. Противоречие, грубо говоря.
Доказали и задим в два. Так, теперь, что простенького, что простенького. Давайте
с 3 в 1 тоже простенько доказывать. Так, нам известно, что модуль F для любого F,
для любого ST, модуль F меньше либо равно, чем TST. Но если существует такой TST,
что модуль F равен TST, то следует, что F максимальный. Но это очевидно, почему на самом деле.
Допустим, что F не максимальный. Значит, существует еще больший поток F, строго больше него. Давайте
предположим, что пусть существует F0, такое, что модуль F0 больше, чем модуль F'. Из этого следует,
что модуль F0 больше, чем TST. Но у нас же есть вот это вот. Противоречие. Поэтому этого быть не
может. Хорошо, доказали из 3 в 1 и задим в два. Остается доказать из 2 в 3, получается, чтобы
зациклить. Давайте доказывать. Доказать здесь будет очень простым, на самом деле. Продолжение
получилось настолько безыдейным, что доказывается по страничке. Так, из 2 в 1 доказываем. В NF нет
пути из S в T. Сейчас доказываем из 2 в 3. Да, из 2 в 3 надо доказывать. В NF нет пути из S в T. Тогда
я сейчас просто построю такой разрез, для которого будет верно, что это равно величине потока.
Определим, что S равно V таких, что V достижимо из S в NF, T равно V без S. Согласны ли вы с тем,
что хотя бы T маленькая лежит в T большой? Просто потому, что у вас T недостижимо из S,
поэтому она лежит в T. Ещё нужно, конечно, проверить, что это разрез по определению,
что у вас действительно нет общей вершинки у них и что они суммарно, понятно, что суммарно они
образуют V. Нужно проверить, что среди них, что в них лежат все вершины, это очевидно,
и что нет вершины, лежащие в и в S, и в T. Это вроде тоже очевидно плюс-минус.
Давайте тогда считать F в T просто-напросто. По определению F от V минус сумма по VST,
F от VU. Теперь поймём, что такое ребро через разрез. Давайте поймём вот что. Я хочу сказать,
что F от UV равно C от UV. Понимаете, почему это так? Изначально сети у меня UV из E,
тогда в остаточной сети, что я хочу, это N. У меня очевидно и появляется ребро обратное из UV,
но смотрите, так как вы лежит в T большом, из этого следует, что у меня нет обратного
ребра, вот такого вот. Согласны? Значит, у меня капаситет этого ребра ноль. А чтобы
капаситет обратного ребра было ноль, у меня должно быть, что F от UV равно C от UV из UV. Я же не
хочу, чтобы у меня здесь из S все достижимо. А V недостижимо из S, значит у меня нет такого
ребра. А чтобы у меня не было такого ребра, нужно, чтобы ребро UV было полностью насыщенным.
Иначе у меня возникает обратное ребро, вот такое вот, и всё, и плохо. То есть у меня как бы остается,
грубо говоря, у меня остается ещё какая-то ёмкость здесь, то есть я могу ещё протопнуть поток.
Такого быть не должно. То есть я с вами доказал следующее, что это C от UV. Чтобы доказать,
что это C от ST, мне нужно доказать, что это ноль. Ну абсолютно по тем же соображениям. Если у меня
есть ребро VU в сети, то я хочу, чтобы поток через ноль был ноль. А если у меня есть F от VU, значит у меня есть
ребро UV в сети. Ладно, сейчас давайте распишем это полностью. Если VU лежит в Е, из этого следует,
что F от VU равно нулю. Вот я хочу это показать. Если VU есть в сети, то F от VU равно нулю. То есть что
в обратную сторону никто не течёт через разрез. Давайте предположим иначе. Иначе,
так, CF от UV равное F от VU больше нуля. Почему это так? Потому что у нас VU в сети, значит
остаточная capacity ребра UV это F от VU просто-напросто по определению. Потому что если у нас VU в сети,
то F от UV это CF от UV. Так, а если это больше нуля, из этого следует, что в NF есть ребро
UV. Но если есть ребро UV, ну всё, это плохо. Значит у нас V достижимо из S. В достижимо
из S маленькой. Противоречие, у нас этого не было. Это не достижимо, потому что VST лежит. Поэтому
это ноль. То есть я построил только что разрез, для которого верно, что он равен модуле F просто-напросто.
А ну, да, здесь надо написать, что модуль F равно F от ST. Это мы уже с вами доказали,
что любого разреза для любого потока модули F это F от ST. Ух, ну всё. Это было сложно, я считаю.
Но тиремма Форда Фолкерсона доказана. А из этого следует алгоритм Форда Фолкерсона непосредственно.
В смысле, чем хороша тиремма Форда Фолкерсона? Тем, что мы впервые получили хоть какой-то механизм,
хоть какой-то, позволяющий нам искать поток. Потому что мы нашли какой-то адекватный критерий
максимальности потока. Потому что, если он дать какой-то поток и сеть, вообще не очевидно,
как проверить, что он максимален. Вот внезапно тиремма Форда Фолкерсона позволила нам как
раз-таки эту проблему решить тем, что мы можем построить остаточную сеть, поискать в ней путь,
и если мы его нашли, то поток не максимален. Собственно, алгоритм Форда Фолкерсона, окей,
шаг первый. Найди путь из С в Т с помощью DFS. Если такого нет, то F максимален. А, ну изначально
инициализация F тождественно равна нулю на всех ребрах. Иначе пункт второй. Протолкни F штрих вдоль
пути. Шаг третий. F равно F плюс F штрих. Перестрой NF. То есть, вы нашли дополняющий поток,
перестроили вдоль ребер, через которые тек у вас поток, остаточные стоимости,
вместимости пересчитали. То есть, у вас изначально остаточная сеть равна искомой сети, исходной сети,
а поток тождественно равный нулю везде. Затем вы нашли путь из С в Т, протолкнули вдоль него
поток какой-то величины, вдоль F штрих. Дальше вдоль этих ребер поменяли остаточные вместимости.
Это и есть перестрой остаточную сеть. Все, алгоритм окончен. Повтори 1-4. Классный алгоритм. То есть,
все сложное было это в теории, чтобы это все доказать. На практике, по сути, вы будете писать,
while есть путь, протолкни через путь, измени остаточную емкость на пути и поток через ребро. Все.
Там 50 строк-кода примерно, если писать, как вы пишете. На ревью будет порядка 400 строк-кода,
сразу предупреждаю. Потому что вам придется писать граф, придется писать строитель сети,
придется писать шаблонные BFS и DFS для всего этого. Ну, вы уже должны были привыкнуть. Так,
окей. Давайте оценим сложность времен у этого всего дела. Ну, казалось бы, давайте считать,
что F действует из В квадрата в Z+. Ну, тогда сложность алгоритма
от E на F. Почему? Потому что у вас ровно F раз, ну, максимум F раз запустится ваш поиск пути,
да? Потому что, если только F раз протолкнули по единичке поток, у вас не получится уже ничего
сделать. Здесь надо не так чуть-чуть написать. У вас суммарно будет модуль F DFS. Чем плох
форт Фалкерсон? Чем он плох тем, что если у вас F действует в R, ну, в R+, почему F? Давайте CF,
CF. Тогда все OK. Если CF у вас вещественные, то можно построить сеть, где алгоритм форта
Фалкерсона будет сходиться бесконечно долго. Он будет постоянно перестраивать вдоль там, то есть
у него там будет геометрической прогрессии убывать ребра, которые он там перестраивает, потоки через
них. Поэтому он будет очень долго сходиться. Более того, есть контрпример, когда он сходится,
во-первых, бесконечно долго, во-вторых, сходится вообще к неверному ответу. Поэтому это не самый
лучший алгоритм, однако он неплох. Вот так. Алгоритм Эдманца Карпа. Эдманца Карпа.
А про что этот алгоритм? Шаг 1. Возьмите алгоритм форта Фалкерсона. Шаг 2. Конец.
То есть вам нужно искать не с помощью ДФС пути, а с помощью ДФС. Тогда есть несколько классных
свойств. Во-первых, мы избавляемся от этих контрпримеров с вещественными числами. Он всегда
сходится и всегда нормально работает. Это первое. Второе. Сложность. Вот такая вот будет.
Без доказательств. Еще 40 минут доказывать эту теорему и не выдержу. Вот. Там выводится,
что у вас порядка ВЕ итерации будет в этом алгоритме. И все хорошо, и все у них было прекрасно.
Примерно так. Я позволю себе это опустить все-таки. Так. Определение. Пара УВ из В квадрат,
реберно, К связано. Если при удалении любых ж меньше К ребер,
все еще есть путь из УВ. То есть когда у нас были мосты, мы с вами искали мосты в графе и находили
компоненты реберной двухсвязанности. Когда удалили мосты, компонент связанности превышает
компонент реберной двухсвязанности. Здесь немножко не так, здесь все чуть сложнее.
А именно здесь так сходу, с насколько для всего графа не получится ответить его о связанности.
Однако для пары вершин в принципе сможем. Давайте подумаем, что делать.
Ну да, вот казалось бы, что значит удалить ребра? Нам нужно разрез искать. Причем мы хотим удалить
минимальное число ребер, поэтому соответственно нам нужно минимальный разрез искать. Значит нужно
построить сеть У и СТОК, ВСТОК. Ребра, заменим ребра на двунаправленные например, то есть в одну
и в другую сторону. Ребра заменим на двунаправленные. Ребра, точнее на пару
направленных. Пару односторонних заменим на пару односторонних. С тождественно равно единичке.
Компасити будет равно единичке тождественно. Вот такая вот идея. Как мы с вами говорили,
мы в сети не допускаем антипараллельных ребер, а мы тут внезапно вообще строим каждый
ребро, делаем его антипараллельным. Поэтому у вас должна быть по идее в коде прекрасная функция,
которая берет граф и избавляется от антипараллельных ребер. Вот так, что дальше нужно сделать.
Ну все, сеть ввели, давайте изобразим ее как-нибудь. Так, первый раз это у нас получится что? Что я
превращу все двунаправленные ребра. Ужасно. Получилось буквотето. Так, теперь давайте рисовать.
Давайте это у, это а, это б. Так, вершина у, мы для нее делаем фиктивную вершинку. Это а,
и для нее вот сюда вот шлеп и последний шлеп. Во. Ну чуть-чуть увеличили сеть, ну слегка раздули
бывает. Число вершин стало число вершин плюс число ребер. Число ребер увеличилось вдвое. Нет,
втрою. Короче, линейное увеличение, поэтому 8 точек вообще не роляет. Ну теперь нужно искать в
этой сети максимальный поток. Точнее, нужно искать в этой сети минимальный разрез. Нужно найти
минимальный разрез. Потому что минимальный разрез как-то
раз-таки делает нам из U недостижимой V. Ну или наоборот, из V недостижимой U.
Нужно найти минимальный разрез. Но казалось бы, нам нужно найти, точнее, мы умеем искать
минимальный разрез, а нам нужно найти минимальное число ребер. Но всего того, что у нас
капасти тождественной равно единичке, это то же самое, что найти минимальное число ребер.
Равносильно исходной задачи. Давайте я сразу напишу, что в сети V' это будет исходное число
вершин, плюс для каждого ребра добавится новое. E' соответственно это будет 3E. Вот это наши новые
параметры. Минимальное капасити. Просто по определению минимального разреза,
минимальный разрез, то тот, кого капасити минимальный. Если это не сказал, то извините,
вроде как я говорил. Это наши новые параметры. Теперь, если мы найдем в этой сети минимальный
разрез, значит, найдем нужное число ребер для удаления. Ну все, победа будет наша.
Тогда ищем минимальный разрез. И все. Так, теперь нужно оценить время работы. Эдман скарп
V'. Давайте фортфалкерсон. Давайте я не буду здесь E. В плюс E я буду E писать. Просто,
что мне уже лень. Теперь поймем, чему равно F максимально. Ну да, в лучшем случае придется
удалить ровно E ребер. Все вообще. Но это когда у вас конструкция вот такая вот.
Придется все ребра удалить. Вообще можно сказать так, что если у вас K, то вам нужно
найти, по сути, модуль F равный K. Проверить, что F хотя бы K. Если F больше K, короче,
модуль F в итоге будет равен просто K, который будет в ответе вам фигурировать. Вот так вот.
Поэтому F не превосходит K, а если у вас есть, ну и на K есть оценка E. Ну что круче. Ну вот,
он уже нечем, поэтому скарп. Вот, ну больше примеров на семинаре будет.
