Мы в прошлый раз наконец-то поняли, как устроены выражения new и delete в языке C++. Давайте вспомним, что происходит, когда мы пишем в программе код наподобие такого.
Ответ, который бы нас устроил еще недели две назад, заключается в том, что операция new просто-напросто выделяет динамическую память и создает нужный объект t.
Сегодня же мы скажем более формально, и данное выражение new приводит к двум вещам.
Первое, действительно выделяется динамическая память. Но динамическая память выделяется особенным образом.
В частности, если выражение new мы передаем в список аргументов, а выражение new можно передать в список аргументов, то память выделяется с помощью специальной функции, которая имеет следующую сигнатуру.
Вызывается функция operator new, которая возвращает указатель на void и принимает тот самый набор параметров, которые передали выражение new.
Это возвращаемое значение как раз-таки интерпретируется тем самым местным в памяти, по которому будет создан объект.
То есть операция new, точнее функция operator new, выделяет память и возвращает указатель на выделенный блок памяти.
Что дальше происходит с этим блоком памяти, на который указывает возвращенный указатель?
Дальше, на втором этапе, вот по этому месту в памяти, появляется объект типа T, переданный конструктор параметрами.
Каждый раз, когда мы вызываем new, происходит две вещи. Первый вызов какой-то версии функции operator new,
и по возвращенной памяти, которую выделяет или не выделяет, но самое главное, что operator new возвращает нам указатель по какому-то месту в памяти, в котором можно создать объект.
В этом месте в памяти мы создаем объект с нужными нам параметрами.
Дальше, что происходит, когда мы вызываем delete от какого-то указателя ptr?
Снова происходит две вещи. Как и раньше, мы с вами говорили, что вызов выражения delete приводит к тому, что, во-первых, вызывается деструктор для объекта, который лежит под этим указателем,
во-вторых, память освобождается и возвращается обратно либо в пул памяти, либо в операционной системе, в зависимости от того, как память была выделена.
Так или иначе, первым делом вызывается деструктор.
Если под указателем лежит какой-то объект, то для этого объекта вызывается деструктор.
Ну и второе. Происходит вызов функции оператор delete от этого указателя.
Эта функция оператора delete просто-напросто освобождает память, в том смысле, что она просто-напросто возвращает ресурсы, которые были выделены ранее операционной системе или пул памяти, который вы используете.
Про что тут еще в этом контексте стоит поговорить?
Тут осталось поговорить еще про то, что существует несколько различных форм.
Функция оператор new. Самая часть, которую мы используем, это функция оператор new, которая просто-напросто принимает...
Кстати, тут не совсем корректно.
То есть функция оператор new всегда принимает size t, то есть первым параметром она принимает количество байт, которые нужно выделить, а дальше все остальные аргументы она берет вот отсюда из того, что мы ей передали в круглые скобки.
Если мы ей в круглые скобки ничего не передаем, то, соответственно, операция new принимает просто size t.
Соответственно, мы с вами сказали, что существует несколько стандартных функций оператор new, которые могут быть использованы.
Например, первая самая стандартная функция оператор new – это та функция, которая используется, когда мы выделяем память с помощью new без каких-либо параметров.
Это самая первая стандартная форма.
Вторая форма вызывается в случае, если мы передаем в new параметр no throw.
Эта форма new является так называемой необрацающей формой.
В том смысле, что обычный new, если ему не хватает памяти для того, чтобы выделить ваш объект, то он просто завершает аварийную работу вашей программы.
В ближайших лекциях мы подробнее поговорим про схему с тем, что на самом деле происходит.
А вот эта форма new, если что-то пошло не так, то есть в случае, если память была выделена некорректно, то эта форма new просто вернет нулевой указатель.
Программа аварии не завершится, просто нам вернется нулевой указатель, и вы сможете проверить верно ли что указатель нулевой, не нулевой, верно ли что память выделилась корректно.
Ну и последняя форма, как называемая размещающая форма, имеет следующий вид.
new, ptr и дальше t с какими-то аргументами.
Ключевая особенность этой формы заключается в том, что вот в этой форме, вот эта самая функция оператора new, которая вторым параметром принимает указатель, она не выделяет память.
Она предполагает, что тут указатель, который вы в нее передали, и есть тот самый указатель на уже заранее выделенную память.
Поэтому можно считать, что вот эта форма, все что она делает, так это пункт 2, то есть просто вызывает конструктор t.
Если у вас есть уже какая-то выделенная память, сырая, в которой нет никакого объекта, то с помощью такого синксиса можете просто вызвать конструктор и создать объект сразу же в нужном месте памяти.
Про что мы с вами еще в этом контексте не поговорили?
Мы с вами не поговорили про то, что на самом деле вот тем предыдущим набором стандартных функций оператора new дело не ограничивается.
На самом деле вы можете вводить язык в свои собственные версии операции new.
То есть вы можете самостоятельно перегружать операции new, то есть вводить новые функции,
и таким образом использовать свои собственные версии выражения new.
Более того, вы можете даже переопределять стандартные формы операции new.
Давайте посмотрим на примеры.
Первый пример показывает, как можно, например, перегрузить стандартную операцию new.
Как это происходит?
Смотрите, мы знаем, что стандартная операция new, точнее стандартная функция оператора new, она принимает количество байт, которое нужно выделить.
Давайте переопределим функцию оператора new, которая также называется, которая возвращает void со звездой и тоже принимает количество байт, которое нужно выделить.
Отличие нашей функции оператора new будет заключаться в том, что она будет сообщать нам о том, сколько памяти она выделила.
Во-первых.
Во-вторых, мы будем выделять память с помощью malloc, а не с помощью стандартной функции new.
Тут мы выделили память с помощью new, проверили, что malloc вернул нам не нулевой указатель.
Если он вернул не нулевой указатель, то возвращаем ответ.
Если malloc вернул нам нулевой указатель, то мы сообщаем об ошибке.
И даже переопределяем стандартную версию операции new с квадратными скобками, которая будет вызывать глобальную версию операции new, то есть нашу операцию new.
И перегружаем функцию оператора delete.
Оператор delete принимает указатель, водится звездой, ничего не возвращает.
Ну и точно так же действует операция delete с квадратными скобками.
Но операция delete с квадратными скобками просто-напросто вызывает обычную операцию delete.
Давайте посмотрим, к чему это приведет.
Тут у меня есть пример, в котором функция main выделяет память для одного объекта типа A и выделяет память для массива объектов A из пяти элементов.
Давайте посмотрим, к чему это приведет.
Соответственно, когда я выделял память для объекта типа A, у меня выделилось 4 байта.
Сама функция оператора new, которую я перегрузил, написала мне о том, что она попыталась выделить 4 байта.
Так как программа не упала, видимо, все прошло успешно.
И когда я выделял память для пяти элементов типа A, у меня выделилось 28 байтов.
Вопрос. Почему, когда я выделял память для пяти элементов типа A, у меня выделилось 28 байтов?
Хотя структура A занимает в памяти 4 байта.
Смотрите, у меня структура A хранит себе просто int.
Int на моей системе занимает 4 байта.
Я выделяю 5 элементов типа A, и кажется, что 5 элементов типа A должны помещаться в 20 байтов.
При этом моя версия операции new выделила 28 байтов.
Давайте с нее посмотрим.
Тут вроде как никаких приколов нет.
Сколько памяти нужно, столько она выделяет.
Смотрите, мы с вами говорили о том, что в чем отличие формы new от формы new с квадратными скобками.
В форме new с квадратными скобками, то есть, смотрите, обычному new и обычному delete всегда понимаешь, что он работает только с одним объектом.
Если обычный new и обычный delete работают ровно с одним объектом, то ему всегда понятно, что ему нужно вызвать ровно один конструктор и ровно один деструктор.
В чем проблема с new с квадратными скобками?
New с квадратными скобками проблема в следующем.
Когда вызываете delete, delete каким-то образом нужно узнать, а сколько элементов под этим самоуказателем лежит.
Ему нужно понять, сколько элементов ему нужно удалять.
Вопрос, как это сделать?
Происходит это следующим образом.
Если нужно выделить память для пяти элементов типа a, то чтобы delete в будущем смог узнать, сколько элементов нужно будет удалить, для каких элементов нужно будет вызвать деструктор,
выражение new с квадратными скобками фиктивно выделяет дополнительные 8 байт, в котором хранится количество элементов, которые выделено.
Но при этом new возвращает непосредственно указатель на начало самого массива.
Поэтому эти лишние 8 байт взялись из-за того, что new заранее выделил дополнительные 8 байт, чтобы тут сохранить информацию о том, сколько элементов было выделено.
Об этом думать не нужно, это деталь реализации, о которой компилятор разберется самостоятельно.
Когда я вызывал delete для object, то у меня вызвалась версия операции delete.
Я написал две версии операции delete.
Когда вы реализуете свои собственные версии операции new и операции delete, вы можете поступить двумя путями.
При реализации delete вы можете реализовать обычный delete, который принимает просто обычный указатель, либо вы можете перегрузить операцию delete, который принимает дополнительный размер выделенной памяти.
Для чего это может быть нужно?
Это может быть нужно, например, если вы пишете свой собственный менеджер памяти.
Когда мы работаем с памятью, которая выделяет операционную систему, она сама знает, сколько памяти она выделила.
По данному месту в памяти сколько элементов было отправлено в вашу программу, и поэтому операционная система сама разбирается, сколько памяти ей нужно забрать, сколько ей нужно отдать.
Если вы пишете свой собственный менеджер памяти, то, вообще говоря, зачастую вам информация о том, куда указывает указатель, недостаточно.
Вам еще дополнительно нужно знать, сколько элементов было выделено.
Поэтому существует дополнительная версия операции delete, которую вы можете по желанию перегрузить, которые дополнительно еще принимают размер выделенной памяти.
Как каким-то образом использовать эту информацию для распределения ваших ресурсов.
Тут компилятор нашел версию операции delete, которая принимает дополнительно еще и количество выделенной памяти, и поэтому у меня получилось напечатать еще и количество памяти, которое было освобождено.
Если этих операций не будет, то будет вызываться только первая версия.
Тут я написал операцию new, которая перекрывается со стандартной существующей версией операции new.
Если вы написали свою версию операции new, то она действительно будет перекрывать уже существующую.
В данной программе вообще нет никакой возможности обратиться к уже существующей версии операции new.
Если вы перегрузили функцию операции new, которая уже существует в C++, то существующая версия просто удаляется и используется только ваша.
И вот в этом заключается проблема. На самом деле перегружать глобальную версию операции new крайне не рекомендуется.
Почему? Потому что если вы перегрузили глобальную версию операции new, то эта глобальная версия операции new будет перегружена во всей программе.
И если кто-то, разработчик, который работает вместе с вами, полагается на стандартное поведение операции new, то его будет ждать приятный сюрприз.
В виде того, что будет вызывать не стандартная версия операции new, а будет вызываться та версия new, которая написана у вас.
Более того, мы с вами знаем, что операцию new вызывают всякие контейнеры типа Vector, DEC и т.д.
И все эти контейнеры тоже будут использовать вашу собственную версию операции new.
Поэтому если вы этого не хотите, то крайне не рекомендуется перегружать глобальные версии операции new.
Точнее, крайне не рекомендуется переписывать старые версии операции new.
При этом такая возможность есть.
Допустим, мы договорились о том, что стандартные версии операции new мы не перегружаем.
Если есть стандартная версия операции new, которая принимает только количество байт, то пусть она существует сама по себе.
Какие есть еще варианты?
На самом деле есть еще вариант написать свою собственную версию операции new.
То есть такую версию операции new, которую в программе пока нет.
Смотрите, на одном из слайдов я показал несколько стандартных форм операции new, которые уже в языке C++ существуют.
В частности, это обычная версия, которая принимает только размер.
Это версия, которая принимает дополнительный параметр null throw.
И это версия, которая принимает дополнительный указатель.
То есть вместо того, чтобы выделять память, эта версия операции new просто вернет указатель, который вы передали.
То есть я хочу написать свою собственную версию операции new, которая тоже ведет себя каким-то особенным образом.
Хорошая ность заключается в том, что это сделать возможно.
И вот как.
Допустим, я хочу написать свою версию операции new, которым дополнительным параметром принимает bool.
Что она может делать?
Она может либо печатать информацию на экране или нет.
Давайте напишем, что если...
Давайте параметры verbose.
Если verbose, то давайте печатать сообщение на экран.
Ну и тут тоже самое.
Давайте пока delete оставим.
Delete, чуть позже поговорим.
Хочу собственную версию операции new, в которую я дополнительно могу передать, допустим, bool.
Которая мне просто-напросто скажет, нужно ли печатать на экран сообщение или не нужно.
Спечатать на экран сообщения.
Вот.
Соответственно, вот у меня есть операция new, которая дополнительно может принимать bool.
Раньше такой версии в языке C++ не существовала, теперь она будет существовать.
То есть теперь я могу ее спокойно вызывать.
У меня есть структура A, и я выделяю просто-напросто память для одного элемента A.
При этом заметьте, что так как у меня в языке C++ появилась дополнительная версия операции new,
которая принимает bool, я могу в new передать значение bool, либо true, либо false.
И в зависимости от этого у меня операция new будет вести себя тем или иным способом.
Давайте еще посмотрим на эту реализацию.
Что тут происходит?
Тут я использую параметр verbose, либо печатаю, либо не печатаю сообщение на экран.
Ну и дальше возвращаю выход из стандартной версии операции new.
Вот эта двойная двойточь означает, что я хочу использовать глобальную функцию оператора new.
И глобальная версия операции new просто-напросто принимает количество выделенных byte count.
То есть вот эта операция new ведет себя так же, как и обычная операция new,
просто-напросто дополнительно печатает сообщение на экран.
Ну, давайте посмотрим, как она сработает.
Так, custom new, out.
И соответственно я вижу, что действительно я вызвал new с параметром true,
и на экране появилось сообщение оператора new bool.
Если я вызову с параметром false, то никакого сообщения на экране видно не будет.
Да.
А зачем нам указать?
Ну смотрите, у меня new сам понимает, сколько памяти нужно выделить.
То есть я тут говорю new, то есть мне нужно выделить память для хранения элемента типа A.
Сколько byte в памяти занимает элемент типа A?
Еще раз, вот тут зачем мы передаем?
Ну потому что, смотрите, мы перегружаем функцию операции new,
и функция операции new сама по себе должна знать, сколько byte ей нужно выделить памяти.
Вот.
Ну смотрите, вот тут, давайте я тут, может быть, не так прописал.
В общем, смотрите, когда я вызываю какую-то произвольную версию операции new,
в аргумент new передаются следующие параметры.
В new передается size of t и arcs.
Вот.
То есть вот этот параметр count содержит size of выделяемого элемента.
Понятно?
Ну так я операцию new могу применять к типу t, к типу A, к типу B и так далее,
то первый аргумент является параметром, он не является константой.
Да?
То есть я могу выделять элемент размером 8 byte, могу выделять элемент размером 16 byte и так далее.
И вот этот count как раз таки хранит информацию о том, сколько byte нужно выделить для данного объекта.
Нет, а какое значение по умолчанию должно быть?
Вот я вам говорю, нужно выделить память для объекта.
Какое значение по умолчанию должно быть?
Size of чего?
А какого объекта?
Я же не знаю, какой объект я буду выделять.
Я могу выделить память для объекта размера 16 byte, могу выделить память для объекта 28 byte и так далее.
То есть еще раз, когда компилятор видит эту строчку, он вместо этой строчки подставляет вот эти две строчки.
Первая строчка это вызов функции оператора new с первым параметром size of t, вторым параметром args.
И наконец вызов конструктора.
Вот этот size of t зависит от конкретного типа t.
То есть это не константа.
То есть в зависимости от того, для какого типа я выделяю память, там будет либо одно, либо второе, либо третье значение.
Поэтому это параметр функции.
Окей?
Ключевой вопрос, который меня тут интересует, состоит в следующем.
Ну смотрите, я написал версию операции new, которая принимает bool.
Ну прекрасно, могу с ней играться, могу передавать true, могу передавать false и так далее.
Все замечательно.
Вопрос, зачем я написал функцию оператора delete, и вопрос, каким образом в операцию delete я могу передать аргумент.
Кажется, что таким образом...
Кстати, сейчас что-то засомневался, но кажется, таким образом я передавать ничего не могу.
Да, смотрите, операция, точнее выражение delete не может принимать никаких аргументов.
То есть в delete я не могу передавать никаких параметров.
Но при этом возможность создавать свои собственные версии оператора delete существует.
Вопрос, зачем?
И ответ заключается в следующем.
Свои версии операции delete нужны для того, чтобы решать довольно специфические проблемы.
Давайте я исправлю этот код и напишу тут что-то наподобие такого.
Подробно про оператора throw мы с вами не говорили, но так или иначе его встречали в заданиях.
Оператор throw просто говорит в том, что в данном месте нужно вызвать ошибку.
Короче, в чем пример?
Пример состоит в том, что если у меня в процессе вызова конструктора произошла какая-то ошибка.
Давайте посмотрим, что произойдет.
Я вызываю new для элемента a.
Вызывается функция оператора new, которая просто-напросто выделяет память.
На этом этапе ничего плохого пока не происходит.
Если у нас памяти достаточно, то на этом этапе ничего плохого не происходит.
Согласны?
Теперь опять функция оператора new выделила память.
И дальше по этому месту в памяти компилятор пытается создать объект.
Создать объект, естественно, с помощью того самого конструктора.
Но в процессе создания объекта возникла проблема.
Что это означает?
Это означает, что вызов поражения new совершился неуспешно.
И какая проблема у нас возникла?
Да, утечка памяти.
Смотрите, у меня объект не создался.
Возникла какая-то ошибка.
Допустим, эту ошибку я как-то смог погасить, а как-то смог ее обработать.
Но вопрос заключается в следующем.
Смотрите, выражение new завершилось неуспешно.
Если выражение new завершилось неуспешно, то значит оно не вернуло никакого значения.
А если оно не вернуло никакого значения, то я не смог получить указатель для этой функции.
Согласны?
Точнее, которая получена из этой функции.
То есть, функция оператора new отработала корректно.
Вот, выделилась память.
На нее есть какой-то указатель.
Я попытался создать элемент t тут, но все прошло неуспешно.
Раз все прошло неуспешно, то выражение new прошло неуспешно.
Значит, выражение new ничего не вернуло.
Но раз выражение new ничего не вернуло, то я не смогу освободить вот эту самую память.
Понятно?
И вот тут, в общем, возникает следующий момент.
Тут возникает единственное место в C++, когда C++ сам самостоятельно вызывает операцию delete.
Правило такое.
Если вызов конструктора завершился неуспешно, то память, выделенная
на первом шаге, освобождается автоматически.
То есть, вызвалась функция операции new.
И если на втором шаге возникла проблема, то компилятор естественно понимает,
что если на втором шаге возникла проблема, то у нас самостоятельно не будет никакой возможности
получить этот указатель и освободить эту память.
И поэтому вот тут и вот только тут компилятор самостоятельно вызовет функцию operator delete.
То есть он вызовет функцию operator delete.
Вопрос, какую функцию operator delete вызовет компилятор?
И ответ заключается в следующем.
Смотрите.
Давайте еще раз я скомпилирую программу.
Так, только...
Ладно, спойлер.
Прошу прощения.
Вот, смотрите.
Когда у меня все проходит отлично, когда у меня все проходит хорошо,
без каких-либо ошибок, у меня тут компилятор вызывает функцию operator news,
которая принимает Bool.
Тут компилятор вызывает функцию operator delete, которая не принимает Bool.
Тут он вызывает стандартную функцию operator delete.
Но если второй шаг пошел не по плану, то компилятор вызовет operator delete,
который принимает PTR и исходный набор аргументов,
которые вы передавали ему new.
Окей?
То есть компилятор будет пытаться искать функцию operator delete,
который принимает ровно такой же набор параметров,
то исходный new.
Для чего это нужно?
Ну, смотрите, если вы написали какую-то нестандартную версию операции new,
то, скорее всего, она каким-то нестандартным образом выделяет память.
А раз она каким-то нестандартным образом выделяет память,
то, соответственно, при очищении памяти компилятор думает,
что ее тоже нужно ощущать нестандартным образом.
Поэтому он будет искать именно вот эту версию функции operator delete.
Ну, давайте посмотрим.
Вот если у меня конструктор завершился неуспешно,
row 1,
то что произошло?
Я бы пытался выделить память с помощью new.
Отработал operator new, который работает с bool.
Дальше при создании объекта a у меня возникла ошибка.
Компилятор понял, что на втором этапе возникла ошибка,
и ему нужно каким-то образом выделять,
которая ранее была выделена под этот объект.
И тут, именно в этот момент, он вызвал функцию operator delete,
которая принимает bool.
Причем функцию, которая принимает true,
потому что в исходный new я передавал true.
Понятно?
Если в исходный new я буду передавать false,
то в исходный delete тоже будет передаваться false.
То есть все пусто.
Поэтому правило.
Если вы реализовали свою собственную версию операции new
со своим собственным набором параметров,
то вы обязаны реализовать свою собственную версию операции delete
с тем же набором параметров.
Почему?
Потому что если вдруг при вызове вашей версии операции new
кто-то в конструкторе пойдет не так,
то компилятор просто не сможет очистить эту самую память,
которая была выделена ранее.
Понятно?
Это для каскадной операции.
То есть если выделяем объект,
кто-то начинает создавать первое bool
по новому конструктору.
И получается...
Если вообще что-то тут пошло не так,
то если второй этап завершился неуспешно,
то все откатывается назад.
То есть мы пытаемся очистить выделенную память.
И весь new считается, что он завершился неуспешно.
То есть он ничего не выделял, ничего не создавал.
То есть даже если получается один new был другой new,
и потом все эти new...
Самое главное, что если во втором шаге пошло что-то не так,
то не важно в самом конструкторе
или функции, которые вызывал конструктор,
которые вызывал там функцию и так далее.
Это все равно считается ошибкой,
что ошибка произошла здесь.
Да.
Так, ну...
Я подозреваю, что просто-напросто
ничего не должно скомпилироваться.
Нет, компилируется.
Ну, скорее всего просто-напросто
не вызовется delete.
И все.
Короче, если компилятор не найдет
следующую версию операции delete,
он просто-напросто его не вызовет.
Да.
Если вы задаете объект на стеке,
что произойдет при вызове исключения в конструкторе?
Про это мы буквально через несколько минут
перейдем к исключениям.
Про это поговорим.
Так, есть ли еще вопросы?
Да.
Нет, он size of t принимает
всегда...
Нет, он всегда принимает size of t.
То есть new всегда принимает как минимум
один аргумент, и это размер
самого элемента. Нет, это размер вы можете
проигнорировать. То есть вы можете написать size of size t
и никак не использовать этот параметр.
Но с size of t он всегда принимает.
Ровно как и оператор delete, всегда принимает указатель
к первому аргументу.
В смысле, вот так?
Если вот это убрать...
Нет, он просто скажет, что такую версию оператора new
существовать не может. Оператор new всегда
принимает в качестве первого параметра.
Ну и последний способ.
Смотрите, вот в первом примере
я показал, что можно перегрузить глобальную версию
операции new, но сказал, что
этого делать не стоит, потому что если вы перегрузите
глобальную версию операции new,
то она изменится во всей программе, и скорее всего
это приведет к нежелательным эффектам.
В общем, в той программе,
которую я демонстрировал, которая просто нам запечатает сообщение
на экран, скорее всего вы при работе с
вектором будете видеть кучу сообщений,
по типу того, что вектор выделил память, там вектор очистил память,
вектор выделил память, и так далее, и так далее.
Первый способ, поэтому первый способ
глобально не подходит. Второй способ
это написать свою версию операции new и вызывать его тогда,
когда вам нужно какое-то особенное поведение
для функции операции new.
И наконец, третий способ, как можно перегрузить
операцию new, это перегрузить операцию
new для конкретного типа.
То есть представьте себе, что
у вас есть собственный класс, и вы хотите,
чтобы объекты этого класса, то есть, когда я выделяю память
с помощью new для обьектов этого класса
я хочу, чтобы они выделялись каким-то особенным образом.
То есть ну не знаю, я хочу сохранять информацию
в каком-то журнале, в компентros.reet, мол, ну что
пылесос на эти элементы,
ну не знаю, либо я хочу, чтобы память
для этих объектов выделялась каким-то особенным образом,
например, хочу, чтобы для этих элементов выделялась
чуть больше памяти, чем нужно.
Либо просто Sue
хочу запретить создавать данных объектов
динамической памяти. Вот как это можно сделать.
Смотрите, чтобы перегрузить операцию new для конкретного
типа, я должен в структуре или классе написать статический
метод operator new или operator delete, в зависимости от того,
что вы хотите перегрузить. В данной структуре A я написал
статический метод operator new, который принимает CisT, возвращает
вводится за звездой, и соответствующий operator new с квадратными скобками,
и написал равно delete. На самом деле, я мог написать
произвольную реализацию, тут я привожу пример, как
запретить выделять динамическую память для своего собственного
класса. Я реализовал операции new и операции delete, просто
операции new и операции new с квадратными скобками,
но определил их как удаленные. К чему это приведет? Это
приведет к тому, что компилятор попытается... Компилятор,
во-первых, увидит, что для своего собственного класса
A перегружена своя версия операции new, он попытается
ее вызвать, но когда он будет ее пытаться вызывать,
он увидит, что эта версия функции удаленной, и поэтому
он скажет, что такую версию функции просто вызывать
нельзя. Думаю, пример более-менее понятен. Я пытаюсь компилировать
эту программу, и программа не компилируется. Почему?
Потому что я запретил выделять объекты типа A в динамической
памяти. Можно привести другой пример, показать, что, если
по-нормальному их реализовать, то все сработает. Давайте
просто тоже выведем информацию о том, что класс A выделил
аккаунт памяти. В качестве выделителя памяти воспользуемся
глобальной версией оператора new.
Тут я сказал, что нужно использовать глобальную версию операции
new. В операции new с квадратным скопом я сказал, что воспользуйся
операцией new, которая определена внутри структуры A. Для объекта
типа A был выделен 1 байт памяти, и для объекта типа A был выделено
10 байт памяти. Кстати, когда я вызывал new с квадратными
скопками, почему компилятор не стал добавлять лишние
8 байт? Ответ заключается в том, что компилятор добавляет
лишние 8 байт только для классов и структур, у которых нетривиальный
конструктор, который что-то делает. У меня тут обычная
структура, у нее ничего в диструктуре нетривиального
делать не нужно, поэтому new с квадратными скопками не
сохраняет эту информацию, просто отчищает память.
Если вы хотите запретить создавать ваши объекты в динамической
памяти.
Например, вы хотите просто гарантировать, что объекты
создают каким-то особенным образом. Например, вы хотите
написать какой-нибудь особенный сингл тон, который должен
обязательно храниться на стэке или в глобальной области,
и вы хотите не дать никакой возможности создавать элементы
в динамической памяти. Почему это может быть нужно?
Вы можете написать как защиту от дурака. Объект можно
создать на стэке в глобальной области и в динамической
памяти, но при этом вы хотите явно подчеркнуть, что в
динамической памяти этот объект создавать просто
не стоит, потому что этот объект обладает высоким
требованием по эффективности, а обращаться к динамической
памяти в этом случае будет довольно-таки долго. Поэтому
вы можете просто явно в коде прописать, что имеет
смысл создавать только на стэке. Вот, например,
таким образом. Нет, смотрите, вот тут мы сохраняли размер
только для того, чтобы дилит понял, сколько деструкторов
ему нужно вызвать. При этом естественная информация
о количестве выделенных байт, она ему доступна.
Это мы показывали в той версии. Сейчас, может, прокрутим.
В одной из версий функций я показывал, что операция
дилит может принимать дополнительный параметр count,
и в этот параметр count будет передаваться количество
байт, которое было заранее выделено. Но так как тут
ничего, кроме того, чтобы просто очищать память, не
нужно делать, поэтому эта информация просто не
сохраняется. Есть ли еще вопросы?
Да.
Ну, тривиальный конструктор... Ну, смотрите, вообще говоря,
если вы написали что-то типа...
то компилятор вполне себе может определить этот деструктор
как тривиальный. Не тривиальным деструктором считается
деструктор, который имеет какое-то тело, пусть даже
пустое. Если у конструктора, если у деструктора есть
тело, даже пустое, то деструктор перестает считаться
тривиальным. То есть тривиальным деструктор может объявить
только компилятор. То есть либо так, либо если вы совсем
не написали деструктор. Ну и то, если деструктор действительно
ничего не делает. Есть один пункт, про который хотелось
поговорить, причем достаточно давно. Давайте поговорим
сейчас. Поговорим про некоторые странности-оптимизации,
которая делает компилятор. Давай посмотрим на следующий
код. Код очень простой. Есть структура А, которая просто
лагирует информацию о том, что она делает. Вызывается
дефолтный конструктор, она печатает дефолт-конструктор.
Если вызывается конструктор копирования, она говорит
конструктор копирования. Если вызывается перемещающий
пресвам cerca aiming, значит и так далее…
Давайте посмотрим на то, как выглядит мэйн. Что происходит?
Тут, в общем, код разделён на несколько блоков, значит, в первом блоке у меня происходит следующее, вроде как должно происходить.
Вызывается дефолтный конструктор, потом вызывается копирующий конструктор, AB равно A, тут создаётся копия.
И когда я пишу A равно B, тоже вызывается копирущее присваивание.
Значит, смотрим, что происходит на экране, действительно, всё так и происходит.
Ну, ничего интересного пока.
Дальше, смотрим на первый блок, в нём вызывается дефолтный конструктор, в нём вызывается конструктор перемещения, в нём вызывается перемещающее присваивание.
Вот, тоже всё отлично, никаких приколов нет.
Теперь идём в пункт номер два.
И вот тут начинаются некоторые странности.
Смотрите, что происходит в 53-й строчке.
Вот, вообще говоря, если действовать строго по букве закона C++, то тут должно происходить следующее.
Сначала... Ну, то есть тут создаётся объект типа A.
Но при этом, перед этим сначала справа создаётся временный объект A с помощью дефолтного конструктора.
Согласны?
То есть, справа создаётся объект с помощью дефолтного конструктора, то есть вызывается дефолтный конструктор.
Затем создаётся объект A, и так как объект A видит, что справа от знака равно стоит временный объект,
то этот временный объект перемещается в создаваемый объект A.
То есть в этой строчке должен вызываться дефолтный конструктор,
конструктор перемещения. Согласны?
Что должно происходить в 54 строчке?
В 54 строчке примерно то же самое с точностью того, что конструктор
заменяется на вызов операции присваивания.
Давайте посмотрим, что на самом деле происходит.
На самом деле мы видим, что вызывается
два дефолтных конструктора
и всего лишь одно перемещающее присваивание.
То есть куда-то делается перемещающий конструктор.
То есть в этой программе всего лишь один раз
был создан дефолтный объект.
Точнее, был создан дефолтный объект вот тут,
был создан дефолтный объект тут, и затем было перемещение.
Давайте пойдем дальше.
Посмотрим на группу №3.
Тут у меня есть функция f, которая просто возвращает объект типа a.
Функция f возвращает объект типа a,
создает его в ретерн-операторе и его возвращает.
Что тут происходит? Я пишу a равно f.
То есть я создаю a, с помощью резидента вызову функции f.
Что должно происходить?
Тут, скорее всего, должно происходить следующее.
Функция f создает временный объект, и дальше этот временный объект
должен переместиться в объект типа a. Согласны?
Как в первой, так и во второй строчке.
В первой строчке №59 вызывается только один дефолтный конструктор,
при этом никакого перемещения не происходит.
Тоже какая-то странность.
То есть куда-то делась дополнительная операция,
которую мы вроде как ожидали.
В строчке №4 странности еще больше.
Давайте посмотрим на определение функции g.
Как устроена функция g?
Функция g устроена следующим образом.
И потом возвращает его наружу.
Как выглядит внешний код?
Внешний код выглядит так. Я вызываю функцию g,
и результат вызова функции g сохраняю в переменную a.
Что тут должно происходить? Сначала вызывается функция g.
Когда вызывается функция g,
внутри нее создается объект a с помощью дефолтного конструктора.
Согласны?
Вот функция g. Согласны?
Значит вызывается функция g, создается а с помощью дефолтного конструктора.
Что происходит дальше?
Этот объект возвращается наружу.
Раз это объект возвращается наружу,
то этот объект возвращается наружу
с помощью перемещения.
Из функции g объект должен переместиться сюда
с помощью перемещения.
А вот этот временный объект, который образовался здесь,
на самом деле происходит. А на самом деле произошло следующее. На самом деле, так, не тот
пример, на самом деле тут снова всего лишь был вызван только один дефолтный
конструктор. То есть при создании объекта типа A был вызван
всего лишь один дефолтный конструктор. Но, погодите, кажется, что тут должно было
быть как минимум три конструктора. Почему? Потому что, смотрите, функция g
создает элемент. Вот этот вызов функции g создает элемент.
Вот, то есть элемент должен быть создаться здесь, элемент должен создаться здесь, и
элемент должен быть создаться здесь либо с помощью копирования, либо с помощью
перемещения. Но, при этом, я вижу, что в примере номер четыре, всего было
вызвано всего лишь два дефолтных конструктора. Вот. Вопрос, как так? Куда
деваются вот эти самые дополнительные перемещения, куда деваются дополнительные
копирования? И вот тут ответом на вопрос, служат словосочетания, копии и
служит в словосочетании копия и лижен. Что такое копия и лижен? Смотрите, копия и
лижен — это особая оптимизация компилятора, которая позволяет в некоторых
ситуациях избежать лишних копирований или перемещений. Вот. В каких случаях, в каких
случаях может применяться копия и лижен? Ну, смотрите.
Вот когда я написал вот так, еще раз повторю, что с точки зрения там буквы
закона C++, тут должно происходить следующее. Сначала создается временный объект,
а потом этот временный объект должен использоваться в качестве аргумента для
конструктора перемещения А. Смотрите. Объект типа A создается на основу
временного объекта. То есть, у меня сначала должен создаться временный объект,
а потом переместиться в А. Но, согласитесь, это довольно странно, что я создаю
временный объект, а потом его перемещаю. Тут бы было гораздо более разумно
сразу создать нужный элемент, вопременный a. И ровно это и происходит, ровно этим
занимается копия elision. То есть копия elision приводит к тому, что вот это вот лишнее
копирование или лишнее перемещение просто не происходит. То есть вот этот вот временный
объект создается сразу в нужном месте программы. Понятно? Что еще подходит под
определение копии elision. Под определение копии elision подходит следующее. Представь себе, что у
меня есть пункция f, которая возвращает временный объект. Ну казалось бы, что тут должно происходить.
Так как у меня вызывается пункция f, так как она создает временный объект, то я должен сначала
создать этот самый временный объект. Этот временный объект должен каким-то образом очутиться
вот тут, ну не важно, с помощью копирования или перемещения. И дальше объект типа a должен
создаться на основе вот этого самого временного объекта. То есть компилятор должен вызвать
дефолтный конструктор, дальше либо копирование, либо перемещение, и дальше тут перемещение. Но при
этом мы с вами понимаем, что гораздо разумнее было бы поступить так. Смотрите, мы с вами понимаем,
что a создается на основе временного объекта из f. Поэтому было бы разумнее пропустить второй шаг и
просто-напросто пункция f сразу же вернуть объект с помощью копирования или перемещения в a. Это
первая оптимизация. А вторая оптимизация заключается в следующем. Смотрите, зачем мне брать
вот этот вот временный объект и, соответственно, создавать его где-то вот во временном месте в
памяти? Если я могу взять вот этот вот объект и сразу же создать в нужном месте в памяти там,
где находится a, согласны? Поэтому тут в этом контексте тоже будет вызван только один дефолтный
конструктор. И все, больше никаких конструкторов вызваний не будет. Это тоже копия и лишен. То есть
компилятор избавляется от лишних копирований и от лишних перемещений. Окей? И теперь, наконец,
третий пример. Самый мозговоносящий. Смотрите, вот у меня есть объект a, точнее у меня есть
функция g, которая внутри себя создает объект типа a. Она создает a, дальше с ним как-то работает,
происходит, и в конце делает return a. Вот. И где-то в мэне я пишу следующий код. Аа равно g. Опять же,
то тут вроде как должно происходить. Смотрите, если я вызываю функцию g, то у меня должна
создаться объект типа a, потом я с ним как-то работаю, работаю, работаю, и потом вот этот
объект типа a, который я создал тут, должен вернуться. Соответственно, тут первый вызывается
дефолтный конструктор, дальше этот объект типа a я должен вернуть вместо вызова функции g каким-то
образом, либо копированием, перемещением. А дальше вот этот объект a должен создаться на основе
временного объекта, который вернулся из g. То есть третий. То есть у меня должно вызваться как минимум
три конструктора. Конструктор, который вызывается внутри g, конструктор, который переместит вот
этот объект a вместо вызова g, и соответственно конструктор, который из этого объекта, который
вернул g, создаст a. Вот. Но что сделает компилятор? Компилятор выполнит следующую оптимизацию,
скорее всего. Скорее всего, компилятор выполнит следующую оптимизацию. Он просто-напросто скажет,
а зачем мне городить вот эти вот лишние создания, ну точнее вот эти вот лишние создания 2 и 3,
если я могу просто-напросто взять вот этот вот объект и в качестве вот этого объекта использовать
вот этот объект. То есть что сделает компилятор? Смотрите, у меня вот эта переменная a находится в
функции main. Вот эта переменная a находится в функции g. Но для оптимизации компилятор может сказать,
а давайте я буду считать, что вот этот объект и вот этот объект это одно и то же. То есть на самом
деле функция g внутри себя будет использовать вот эту вот область памяти в качестве хранения
результата. И вместо этого return a, функция g просто нам завершит работу, и вот в этом месте памяти
уже будет храниться готовый объект. Понятно? Да.
Получается, будет после вот всех выдавал функций, ну на стеке станет компилятор. То есть получается,
там создается этот объект a, потом вызывает функция, ну получается стек отодвигается,
потом происходит что-то там, ну он приоритически заполняется, потом стек выдавается, да, отодвигается,
но все что было в функции почистилось. Или наоборот, он, функция выдавается, начинает создаваться,
и он создает, получается, за тем местом, где будет, по сути, консервировать тековый фрейм.
Нет, ну тут как все происходит? Тут скорее произойдет все так, что, ну смотрите, у меня тут
создается переменная a, то есть у меня как бы есть стек, то есть тут есть переменная x, y, там z, t,
и вот переменная a. Вот. Дальше вызывается функция g, создается тековый фрейм для функции g. Но функция g,
когда будет обращаться к вот этой переменной a, она будет обращаться не к своему стековому
фрейму, а к вот этому. То есть так как функция g знает, что ее, ну как бы, вот ее стек находится
сразу же за стеком функции main, она знает смещение вот для этой переменной a. Ну и поэтому функция g
сразу же напрямую может обращаться к элементу a. То есть смотрите, какая странная ситуация возникает.
Вот мы с вами до этого говорили о том, что... Давайте вот тут обозначу по-другому. Пусть тут x,
а вот эта переменная называется y. Ну смотрите, мы с вами говорили о том, что когда вызывается
функция, вот у меня есть функция f, точнее вот функция main, в ней есть переменная y, и есть функция g,
и функция g, и есть переменная x. Вот раньше мы говорили, что когда вызывается функция,
переменные, которые находятся в функции g, никак не влияют на переменные
которые находятся в других функциях, например функции main.
Но тут вот в данной ситуации компилятор понимает, что единственное назначение вот этой переменной,
в итоге оказаться в качестве значения вот этой переменной. И поэтому компилятор просто
łbyственно делает следующее. Он скажет, что а зачем мне в функции g создавать дополнительную
если я могу воспользоваться, то есть если я могу создать переменную у вот эту и
сразу же работать с ней и когда завершится в функции g, по завершении
функции g у Main уже будет готовая перемена у, которая уже хранит тебе то самое значение,
которое нужно. Понятно? То есть ресурсы на возврат значения из функции никакие не
тратятся. Вот эти все оптимизации, которые избавляются от лишних перемещений
копирований, в общем, вот эта оптимизация называется copy-elision.
Вот. Более того, copy-elision, давайте посмотрим на такой пример,
copy-elision работает даже тогда, когда у вас, у класса отсутствуют напрочь
конструкторы копирования и конструктор перемещения.
Смотрите, давайте приведу такие примеры. Вот у меня есть a, я создам a на
основе вызова функции f. И дальше, допустим, сделаю вызов функции g. Вот a.
Смотрите, у меня у класса напрочь отсутствуют конструкторы копирования и
конструктор и при сваивании.50
Но при этом, давайте, то есть снова, у меня отсутствует конструктор
копирования и конструктор перемещения.
Но при этом у меня получается, у меня есть возможность воспользоваться результатом вызова функции f и сохранить его в переменную a.
Программа компилируется и программа работает.
Даже несмотря на то, что функция f из себя возвращает временный объект, этот временный объект как-то из функции f должен оказаться в переменной a.
Вопрос, как он там может оказаться? Либо копированием, либо перемещением. Копирование у нас запрещено, перемещение у нас запрещено.
Как он там оказывается? Непонятно. Ответ – оптимизация компилятора.
То есть компилятор избавляется от копирования перемещений и делает все возможное, чтобы объект в итоге переместился из одного места в другое место.
И то же самое в функции g. Функция g принимает a по значению u. То есть я каким-то образом должен суметь передать в g аргумент типа a.
Но смотрите, у a у меня отсутствует и конструктор копирования, и конструктор перемещения.
Если у a у меня отсутствует и конструктор копирования и перемещения, кажется, что я не могу передавать параметры a в функцию по значению. Согласны?
Потому что передать какой-то элемент по значению, он должен быть либо скопирован, либо перемещен.
Но в случае, если я работаю со временным объектом, то есть я вызываю функцию g от временного объекта, то что должно происходить?
То есть тут должен создаться временный объект, а потом этот временный объект должен переместиться в качестве параметра аргумента функции g.
Но компилятор умный, и он понимает, что зачем мне делать эти лишние перемещения, если я могу взять вот этот временный объект и сразу же создать его в нужном месте.
Поэтому вот тут компилятор воспринимает эту строчку так, что нужно создать аргумент g с помощью конструктора по умолчанию, и все. Никаких перемещений, никаких копирований делать не нужно.
Понятно? Да.
Я могу сделать a от a от a от a от f, наверное, могу. Да, вот.
То есть, казалось бы, тут должно произойти следующее. Вызывается функция f, на основе вызова функции f создается a, на основе создания a создается другой a, на основе этого создается a, и в итоге воссоздается аргумент a.
Но компилятор умный, он понимает, зачем мне вот это все городить, если в итоге получается так, что результат вызова функции f должен оказаться в аргументе функции g.
И давайте проверим, что все компилируется. Все компилируется, даже несмотря на то, что у меня отсутствует и копирование, и перемещение.
То есть, копия лижен говорит о следующем. Если у вас есть временный объект, и какая-то цепочка перемещений и копирований, которые приводят его в другой объект, то вот эта цепочка происходить не будет.
Создание вот этого объекта сразу же будет происходить в том месте, где он требуется.
Так, вопрос? Да.
Смотрите, если цепочка работает, то она будет работать произвольно длиной. Тут есть вопрос в том, когда это на самом деле работает. Это тонкий момент, про это я проговорю.
Если на о0? Нет, тут не зависит от уровня оптимизации. Я тоже могу поставить минус o g для дебага. В общем, все будет работать.
Чтобы это отключить, нужно использовать другие флаги.
Сейчас возникли вопросы, когда это работает, когда это не работает. Давайте перейдем к обсуждению этого. Смотрите, с этим копия лижен довольно интересная и долгая история.
Дело в том, что этот копия лижен появился в языке C++ не сразу. Точнее, он появился более-менее сразу, но не в стандарте языка C++.
Создатели компиляторов практически сразу поняли, что когда происходит создание временного объекта, потом его перемещение в другой временный объект, что-то происходит не так.
Явно мы тратим лишние ресурсы на создание дополнительных временных объектов. Создатели компиляторов довольно быстро внедрили оптимизацию копии лижен в свои компиляторы.
Проблема в том, что эти оптимизации не очень поматчились со стандартами языка C++.
Потому что стандарт языка C++ предписывает создавать временный объект и потом его перемещать в A. Или создавать временный объект и перемещать его в A.
Или создавать X, потом возвращать его сюда и так далее. То есть происходит несоответствие языка программирования C++, точнее стандарта, и оптимизация компилятора.
Ну, можно проверить следующим образом. Давайте я скомпилирую C++11. А, вот C++11 уже не работает.
Давайте C++14, может. Тоже не работает.
Так, давайте попробуем вот так.
Так, давайте вот так сделаем.
Так, давайте вот так сделаем.
В общем, история следующая. В общем, видно, что когда я переключаюсь на старые стандарты, на старые стандарты C++, все перестает работать.
Вопрос, почему? Дело в том, что до стандарта C++11 вот этот вот копия и режим вообще никак не присутствовал в тексте языка C++.
То есть вообще, строго говоря, C++ ничего об этом не знал.
Но в стандарте C++11 копия и режим был включен в стандарт, но со следующей формулировкой, что компиляторы могут такое делать, но вообще говоря, не факт.
То есть стандарт потихоньку начал признавать, что такое возможно, но может да, может нет.
То есть формировка называется нон-мондатори копия и режим, то есть не обязательно копия и режим.
То есть копия и режим может происходить, но вообще говоря, программы не обязаны его поддерживать.
А начиная со стандарта C++17, начиная со стандарта C++17, копия и режим во многих ситуациях стал обязательным.
В частности, копия и режим стал обязательным вот в этой ситуации, когда вы создаете объект на основе чисто временного объекта.
И вот в этой ситуации, когда вы возвращаете из функции временный объект, то есть когда вы в ретерне пишете тут временный объект,
вот в этом случае гарантируется, что вот этот вот временный объект сразу же окажется в том месте, где он в итоге понадобится.
Вот это теперь строго гарантируется компилятором, то есть это будет происходить всегда.
Не важно, есть у вас конструктор перемещения или нет у вас конструктора перемещения.
Что стандарты C++ вам не гарантируют, так это то, что будет происходить вот эта вещь.
Внутри функции будет создаваться объект ровно такой же, как и здесь.
Эта оптимизация называется return value optimization.
А вот эта оптимизация называется nrvo.
В чем отличие rvo от nrvo? Здесь возвращается временный объект, безымянный.
Тут возвращается именованный объект, который больше не понадобится, поэтому named return value optimization.
И в чем ключевое отличие? rvo гарантируется, начиная со стандарта C++17,
nrvo не гарантируется даже в стандарте C++17, но скорее всего будет происходить.
Еще один пункт. В старых стандартах C++ это можно было отключить с помощью специального флага компиляции FNovaLiteConstructor.
В этом случае CopyEleasion может не происходить.
В современных стандартах C++, начиная с C++17, даже эта опция не спасет вас от CopyEleasion.
Работайте с оптимизированной версией компилятора.
Есть ли вопросы?
Да.
Может легче говорить о ситуации, когда нам нужно наоборот затормозить программу, чтобы на сколько нужно не работать?
Сознательно затормозить программу...
Не знаю, зачем это нужно, но...
Смотрите, бывают ситуации, для чего это может быть нужно.
Для чего это раньше было нужно.
Вот смотрите, я написал вот такой код.
И у меня есть следующее понимание.
У меня есть понимание того, что я хочу, чтобы это работало ровно так, как описано в стандарте C++.
Я хочу, чтобы тут создавался объект, первый пункт.
Я хочу, чтобы этот объект перемещался сюда.
И наконец, я хочу, чтобы вызывался деструктор этого объекта.
Допустим, я полагаюсь на то, что тут обязательно будет вызван деструктор для A.
Но если происходит Copy&Vision, то второй и третий пункт просто канут в небытие.
И тут будет создание одного объекта.
Если я хочу, чтобы все работало ровно так, как предписывает стандарт, то я пишу этот флаг.
Скорее всего, если вы пишете этот флаг, то вам нужно просто следование стандарта.
То есть вам по какой-то причине нужно то, чтобы вот тут вызывался деструктор созданного объекта.
То есть вы тут действительно полагаетесь на то, что тут создается временный объект,
потом он перемещается, потом он вызывает деструктор.
Каких-то причин, зачем замедлить программу, я не вижу.
Особенно посылать в context.
Вот, последний пункт.
Остались ли вопросы?
Окей.
Так, ну хорошо, я закрыл свой дештальт.
Давно хотел про это рассказать, и наконец рассказал.
Давайте, в целом мы погрузиться в новую тему не успеем.
Давайте хотя бы затронем проблематику, поговорим про проблемы,
и начнем их подробно обсуждать уже на следующем занятии.
Мы начнем говорить про исключение, но если говорить более глобально, про обработку ошибок в языке C++.
Я надеюсь, наш курс за эти полтора семестра уже успел вас приучить, что программы не всегда работают.
Даже если программа работает у вас локально, то она может не работать где-то еще.
Или если программа работает у вас, то у кого-то другого она может не работать.
Причем причины могут быть разные, начиная от ошибки при программировании,
заканчивая ошибки в логике программы и так далее.
Понятное дело, что в реальной практике, в реальной разработке тоже встречаются, скажем так, нештатные ситуации.
Что я имею ввиду под нештатной ситуацией.
Например, все время до этого мы с вами программировали в парадигме,
что всякий раз, когда мы выделяем память, памяти всегда хватает.
Если в задаче сказано, что на вход подается массив из миллиона элементов,
если вы сделаете new миллион элементов, то миллион элементов у вас обязательно идет.
При этом, на самом деле, понятное дело, что на практике это не всегда так.
Если у вас программа работает в какой-то высоконагруженной среде,
или программы заранее не знают, сколько памяти нужно выделить,
понятное дело, что в какой-то момент может произойти такая история, что new вам скажет нет.
То есть new, на самом деле, может отказать, как бы это странно ни звучало.
То есть new может сказать, что нет, столько памяти нет, и вопрос в том, как с этим бороться.
То есть вопрос в том, можно ли как-то узнать, что new завершилось неуспешно.
Если new завершилось неуспешно, можно ли как-то эту ситуацию обработать так, чтобы программа не завершалась, не крашилась.
И, наконец, третий вопрос, а что делать, если действительно какая-то нештатная ситуация произошла?
Как правильным образом завершить работу функцию, как правильным образом завершить работу программы?
В целом история про это. Мы с вами понимаем, что в программе есть основная логика программы,
которая работает в том случае, если программа работает в идеальном мире, когда ничего плохого не происходит.
И, возможно, в нештатной ситуации хотелось бы понимать, как об этих нештатных ситуациях сообщать,
как об этих нештатных ситуациях узнавать и, собственно, как с этими нештатными ситуациями справляться.
Про это мы поговорим на ближайших занятиях.
Ну и давайте начнем отвечать на первый вопрос.
Вот представьте себе, что вы пишете какую-то функцию.
Допустим, простая функция, которая просто берет два числа и делит одно на другое.
Самая простая функция, которую тут можно придумать.
Что может плохого произойти при делении одного числа на другое?
Понятное дело, что если у вас второе число представляет из себя ноль,
то деление целого числа на ноль приводит к неожиданным последствиям.
Ну в языке C++ это неопределенное поведение.
Естественно, мы не хотим допускать в нашей программе неопределенного поведения.
Мы хотим каким-то образом уметь сообщать пользователю,
ну пользователю имеет в виду тому, кто пользует наши функции,
что погоди, брат, ты подал в функцию что-то не то.
Тебе нужно как-то исправиться, подумать над своим поведением.
Как вот этому самому пользователю сообщить о том, что он неправ,
не закрывая его программу целиком?
Возможно, несколько вариантов.
Вопрос, какие? Какие варианты вы можете предложить?
Вот представьте себе, что вам нужно написать функцию,
которая делит одно число на другое,
и в случае, если что-то пошло не так,
она должна как-то об этом корректно сообщить.
Вопрос, как функция может сообщить корректно о том, что что-то пошло не так?
Давайте какие-нибудь идеи, как?
Ну Сиаут, смотрите, почему Сиаут плохо?
Потому что, ну вообще говоря,
у пользователя может не быть доступа к консоли.
Это во-первых. Во-вторых, ну хорошо,
допустим, я запустил программу, сижу пью чаю и вдруг вижу,
у себя деление на ноль. Что делать?
Я же хочу, чтобы сама программа как-то с этой ситуацией справлялась.
Я не хочу, допустим, я видел сообщение, что Y равен нулю,
давай-ка я перезапущу программу и как-то ее исправлю.
Я хочу, чтобы одна функция могла сообщать другой функции
о том, что во мне что-то пошло не так,
со мной что-то не так.
Понятно?
Так, ну, все это отлично,
но на самом деле самый простой способ это ничего не делать.
То есть, ну, на самом деле простой и стандартный способ.
Первый способ это просто предполагать,
что ничего плохого не произойдет.
Если мы предполагаем, что ничего плохого не произойдет,
то мы просто перекладываем ответственность на все плохое на пользователя.
То есть мы просто наговорим, что вот если там ты
передал на вход в качестве Y значение равное нулю,
то ты сам виноват.
Мы ничего не гарантируем, мы ничего тебе об этом не скажем.
Но, естественно, это не самый хороший способ.
Почему?
Потому что, ну, все-таки в нестатной ситуации
они всегда могут зависеть от пользователя.
Ну, опять же, представьте себе, что мы пишем свой собственный вектор.
То есть как бы мы говорим пользователю,
что вот мы тебе предоставляем класс Вектор,
и, скажем, если ты выделяешь памяти для n байт,
точнее для n элементов, то мы тебе создадим вектор на n элементов.
Но при этом у вектора в какой-то момент, не знаю,
может просто-напросто не выделиться память и так далее.
Понятное дело, что это все не обязательно зависит от пользователя.
То есть мы пользователю все-таки хотим как-то уметь сообщать о том,
что что-то пошло не так, возможно, не по твоей причине.
То есть мы хотим дать понять пользователю,
что то, что он хочет сделать, выполнить не получится.
Поэтому второй способ, как вы правильно сказали,
можно вернуть в специальное значение.
Давайте поступим так.
Если у нас x разделился на y,
то мы вернем результат деления x на y.
Если x на y не разделился,
то давайте вернем какое-то вот специально заранее выбранное значение.
В чем проблема?
Да, вопрос.
Что должно являться специальным значением в случае деления x на y?
Ну хорошо, допустим, в качестве деления x на y
я выиграл специальное значение минус единица.
Вопрос, как понять, вот эта минус единица получена в результате вычисления,
x зеленая на y, или в результате вот этой самой ошибки?
Непонятно.
То есть любое значение, на самом деле, корректное,
и результат деления x на y. Согласны?
То есть специальное значение хорошо,
то есть если у меня есть какое-то специальное выделенное значение,
то я могу просто взять и проверить,
верно ли, что функция вернула это самое специальное значение.
Если да, то функция завершилась неуспешно.
Если нет, то функция завершилась успешно.
Но проблема в том, что не всегда это специальное значение можно выбрать.
Какие еще варианты возможны?
Что еще можете предложить?
Что?
Для нитов нет бесконечности, к сожалению.
Нет, хорошо.
Если я передаю int и в int делю int на int.
То есть у меня функция шаблонная,
но в качестве параметра шаблона я передаю int.
Что делать?
Непонятно.
То есть понятное дело, что если мы делим float на float
или double на double, то там есть специальное значение,
типа none, int и так далее.
Есть такого значения нет.
Что делать?
Например, делим int на int.
Кого-то отдельного выделенного значения,
который бы говорил нам о том, что результат некорректен, нет.
Ну, смотрите.
А если я возьму
max-1
и разделю на 1?
Ну, мне кажется...
Вы так пишете программы в контест?
Вероятно, с того, что будет в A,
очень маленькая.
Да.
Вот какой-то кодический флаг,
который плачет,
который плачет,
который плачет,
который плачет,
тут будет кодический флаг в телу,
который плачет, мы можем его
каждый раз проверять.
Да, вот.
Идея, которую вы описали,
звучит так. Действительно, давайте воспользуемся
какой-нибудь специальной отдельной переменной.
В языке Ic есть специальная переменная
Erno,
в которую, в общем, если вызываете функцию,
то в эту переменную Erno
записывается результат кода ошибки
последней вызванной функции.
Если Erno равно 0, значит, последняя функция завершилась успешно.
если rn не равно 0, то значит последняя пункция завершилась неуспешно.
Давайте заведем какую-нибудь глобальную переменную rn, в которой будем хранить код ошибки.
Если код ошибки не равен 0, значит функция завершилась неуспешно.
Если код ошибки равен 0, то функция завершилась успешно.
В чем проблема? Проблем куча. И все они связаны с использованием глобальных перемен.
Начиная от того, что глобальную перемену нужно всегда проверять.
Это глобальная переменная должна зацарять нашу область видимости, заканчивая тем, что если вдруг мы
пишем многопоточные программы, то есть программы, которые работают параллельно, то функция может создаваться в одном потоке, во втором потоке, в третьем потоке,
и непонятно, какой из потоков записал в эту самую переменную.
Непонятно, какая из функций на самом деле привел к ошибочному результату.
Окей?
Есть еще один способ, который был и есть основным в языке C.
Это просто-напросто использовать возвращаемое значение функций не по назначению.
Давайте скажем следующее. Давайте скажем, что у меня функция возвращает не результат, а у меня функция возвращает код ошибки.
Окей?
То есть возвращаемое значение функции хранит не результат деления х на у, а возвращаемое значение функции хранит
код ошибки, то есть если 0, то нет ошибки, если единицы, двоик или любой не нулевой значения, значит ошибка есть.
А сам результат вызова этой функции буду сохранять в отдельную переменную, которую я передаю третьим параметрам.
Ну, в данном случае, я передаю третьим параметрам аргумент по указателю, но могу третье параметр передавать по ссылке,
и тогда результат вызывает функцию, могут сохранять вот эту самую переменную по ссылке или по указателю. Согласны?
Вот. Ну в чем проблема?
Ну проблема в том, что если вы хотите вызвать функцию divide и при этом никуда не сохранить результат,
то вам придется создать лишнюю переменную для того, чтобы все-таки этот результат сохранить
и при этом никак не использовать. Это первое.
Второе, ну нарушается, скажем так, привычное понимание, наше с вами понимание работы функции.
Ну, когда мы говорим про функцию, в математическом смысле или в смысле программирования, мы предполагаем, что функция возвращает результат.
Но это было бы странно, если бы вы математиками такие. Так. Давайте изучим tangents.
Вот. Tangents от x возвращает 1 или 0. Если tangents можно вычислить, он вернет 1.
Если tangents равен, если нельзя вычислить, то... это не наоборот. Если tangents можно вычислить, он вернет 0.
Если tangents нельзя вычислить, то он вернет 1.
Адентат вычисления тангенса будем хранить в перемен y, вот. Не очень удобно, вот.
Здесь ровно то же самое. Все-таки мы с вами привыкли, что если пункты что-то возвращают, то этот результат мы хотим использовать, то, собственно, в качестве там
каких-то составных выражениях и так далее.
Вот. В общем, все варианты
одновременно и хороши и плохи.
Ну, собственно, как я уже сказал, в языке C чаще всего используется подход с возвратом кода ошибки, и поэтому код выглядит примерно, любой код на языке C
выглядит примерно так.
Вызываем функцию G, проверяем код ошибки, вызываем функцию H, проверяем код ошибки, и так далее. Вот.
Собственно,
куча недостатков, то есть, во-первых, мы теряем
интуитивность, во-вторых, у нас код состоит из кучи проверок.
То есть, завершилось ли функция успешно, завершился функция успешно и так далее, вот. А все-таки хочется читать код, ну как бы
согласитесь, что хотелось бы просто читать код. То есть, вызов
функции F, B, J и так далее.
а уже всякие ошибочные ситуации мы хотели, чтобы они существовали где-то вот в отдельности, в отдельной стране от кода.
Ну, все-таки, когда мы с вами пишем код, ну, как вот сказал молодой человек, мы все-таки предполагаем, что вероятность ошибки крайне мала.
Вот. А зачем, если у нас вероятность ошибки крайне мала, зачем нам городить код, который состоит из кучи проверок?
Ну, и, собственно, в C++ в качестве стандартного способы используется
бросание и отключение.
Значит, ну, к сожалению, лекция закончилась. В следующий раз, как раз-таки подробно поговорим про то, как устроена обработка ошибок в C++ и так далее.
Значит, кратко скажу, что чтобы в C++ сообщить о наличии ошибки, мы используем специальный оператор,
который называется оператор throw.
Вот. Если кратко, то когда у нас работает функция, чтобы сказать о том, что функция завершилась успешно, мы используем оператор return.
И оператор return возвращает нужное значение, которое вычислился в результате вызова функции.
А оператор throw это такой, можно сказать, специальный оператор, который используется тогда,
который используется в тех ситуациях, когда мне нужно сообщить, что функция завершилась неуспешно.
Таким образом, из функции я могу выйти двумя способами. Первый способ это стандартный, то есть получу return. Второй способ нестандартный, то есть получу throw.
Ну, подробнее поговорим на следующей неделе в следующий раз. На сегодня все, всем спасибо.
