Так, добрый день, начинаем.
Так, начнем мы с продолжения LCA.
В прошлый раз мы научились делать это за какие-то асимптотики.
Напоминаю задачу. Есть корневое подвешенное дерево, то есть есть какая-то выделенная вершинка, назначенная корнем.
Как бы можно считать, что все ребра направлены сверху вниз.
Вот. И для каких-то двух вершин нужно найти самую близкую к корню вершины на пути между ними.
А если опять-таки игнорировать ориентацию. Вот это и LCA будет.
Мы научились это делать за N-логен предподсчета и единицу на запрос.
Это с эллеровым обходом и с парстейблом на нем. Вот давайте теперь еще лучше сделаем.
Давайте сделаем вообще линейный предподсчет и единицу на запрос.
Значит, это будет способ 3 нахождения LCA. Это алгоритм Парахолтона и Бендера.
Значит, сначала такое же. Построим эллеровый обход.
Заметим, что соседние элементы в этом обходе всегда по глубине отличаются ровно на единицу.
Потому что обход это что такое? Вот мы просто ходим по ребрам. Каждый раз, когда зашли в вершину,
напечатали ее. Поэтому соседи в этом обходе, это соседи просто в графе. Значит, у них глубины ровно
один отличаются. Значит, соседние элементы отличаются по глубине ровно на единицу.
И мне нужно в этом массиве уметь искать минимум на отрезке. Раньше мы делали с помощью
с парстейблом, а вот за такую симпатику. Теперь мы хотим как-то побыстрее это сделать.
Использую информацию, что у меня глубины соседей отличаются на один. По высоте, да.
Смотрите, я сейчас скажу следующее. Как искать минимум по высоте? Понятно, нужно просто в этом
обходе на месте каждой вершины написать ее глубину и саму вершину как пару. И тогда нужно просто
искать минимум на отрезке. Причем понятно, что основным параметром, по которому происходит
сравнение, это вот как раз глубина. Давайте я сейчас буду игнорить V. Мне просто будет так удобнее
расширять, потом ее когда надо можно вклинить. Меня сейчас на самом деле самое интересное,
это просто найти минимум на отрезке вот по глубинам. Если я знаю, где это находится,
то надо просто посмотреть, какое число в паре с ней стоит здесь, и это будет ответ. Поэтому
сейчас на второй элемент пары я буду сбивать. Ну вот, у меня есть массив длины N. Массив глубин
N. Давайте сделаем следующее. Давайте введем такую странную величину, половину алгорифма,
и разобьем весь наш массив на блоке такого размера, по K. Ну там, если последний меньше,
чем K, то он будет меньше, чем K, и бог с ним. Или там можно в конце чем-нибудь дополнить
какими-нибудь бесконечностями, чтобы на K делилось. И при этом мы понимаем, что внутри каждого блока
соседи отличаются на единицу. Поэтому на самом деле каждый блок можно представить следующим
образом. Во-первых, это просто первый элемент, а во-вторых, это последовательность плюс-минус
единичек, как каждый следующий, отличается от предыдущего. Если я знаю стартовый элемент,
если я знаю все разности между соседями, скажем, что здесь плюс один, здесь минус один, здесь минус
один, ну и так далее, если я знаю, в каком порядке все они идут, то я знаю целиком этот блок. Поэтому
для описания блока мне достаточно знать х, и по факту маску из плюс-минус единиц длины ровно
K, точнее K-1 даже. Вот, значит, маска размера K-1. Согласны? Вот. Ну более того, если я возьму и
просто этот х за нулю, то это то же самое, что если просто вычесть из всех элементов маски х,
тогда, конечно, минимум не изменится. Поэтому я могу считать, что у меня все задается просто маской,
потому что я могу вычесть х из всех элементов. Нет, ну подождите, вот если у нас есть второй блок,
я знаю здесь первый элемент у и знаю маску размера K-1, то я тоже этот блок целиком восстанавливаю.
Так вот, потому что можно вычесть х. Ну, не то что можем забыть, а скорее никакие
минимумы не изменятся. Точнее, если я из всех элементов вычту х, то у меня минимум на любом
отрезке останется в том же месте, где был раньше, просто на х уменьшится. Значит, мне достаточно
охранить только маску, ну и какое-то х отдельно. Если я знаю просто маску, а х считаю равным нулю,
то потом после нахождения минимума на отрезке мне нужно просто х прибавить. Потому что х это
общее, что я вычил из всех чуваков. Ну вот, хорошо, тогда вопрос, а сколько получается различных
масок? Сколько различных блоков, вот если я сделаю такую нормировку их, если я вычил первый элемент?
Ну два в степеника минус один, потому что масок ровно столько. Всего масок два в степеника минус
один. Значит, его чудо это что-то маленькое. Ка специально так подобрано, там специально
множество и одна вторая, чтобы здесь был корень из Н. То есть, вообще говоря, вот этих блоков после
нормализации, то есть после вычитания первого элемента из них, их мало. Различных блоков,
их всего корень максимум. Нет, различных масок вот столько, потому что ну просто два в степеника
минус один. Каждый блок это маска, различных различных масок вот столько. То есть, мы
получаем, что у меня, ну как бы самих блоков много, блоков вот столько, N делить на K,
но различных из них после нормализации вот столько. Корень из N примерно. Тогда давайте
сделаем следующее. Давайте мы для каждого нормализованного блока, то есть для каждой
маски предпочитаем ответ на всех возможных подотресках на них. Первый шаг. Для всех масок
предпочитаем минимум на всех подотресках
для блока ноль запитая маск. Если у меня блок имеет первое число ноль, дальше вот кодирование
плюс-минус 1 задается маской маск. Я хочу знать, я хочу предпочитать минимум на всех подотресках.
Вот это, на всех возможных вообще. Понятно, что делается за корень из N на K квадрат,
потому что у меня корень из N масок, корень из N вот таких массивов, на каждом из них за
квадрат длины я могу предпочитать все минимумы. Значит, это делается за корень из N на K квадрат,
то есть корень из N на K квадрат N. Вот это все еще что-то сильно меньше, чем N. Я говорю,
что давайте я виртуально сейчас из всех блоков вот эти первые элементы вычел. Но и для них,
для различных всех масок я предпочитал ответ. Теперь второй шаг, смотри, что произошло. У меня
есть большой мой массив, длина N большая, который разбит на блоке. И в каждом блоке, на самом деле,
я на любом его подотреске могу найти ответ за отоденицы. Как это делается? Я сначала понимаю,
какая здесь маска. Как-нибудь заранее для каждого блока сохранил какая там маска. Знаю,
какой здесь X и знаю, какой для этой маски на этом подотреске ответ. Ну и потом просто X
прибавляю, чтобы восстановить его. Чтобы вот этот X вот сюда вот добавить, надо просто к минимуму
добавить X. Поэтому на любом подотреске внутри блока я могу найти ответ за единицу, согласны?
Просто потому что я это все предпочитал. Теперь надо научиться искать ответ между блоками. То
есть, когда отрезок не внутри блоков, а какой-то вот такой. Делается очень просто. Мы найдем
минимум вот здесь вот, минимум вот здесь вот, потому что мы умеем искать минимумы на подотресках
внутри блоков. А вот здесь мы найдем минимум с помощью sparse table на блоках. Потому что это непрерывный
подотрезок блоков. И мы сейчас, если воспринимать блок как нечто неделимое, то мы можем построить у
них sparse table размер N делить на K. Второй шаг. Если блоки считать неделимыми, на них можно построить
sparse table. Ну и поскольку блоков всего у меня N делить на K, то sparse table строится за N делить на K
умножено логарифом N делить на K. Значит, sparse table строится за N делить на K логарифом N делить на K.
Ну давайте подставим, что K это половина логарифма.
Значит, логарифм отношения, это разность логарифмов. Ну здесь двоичный логарифм N,
минус двоичный логарифм K. Вот. Значит, когда раскрываю скобки, эти логарифмы сократятся,
останется N. Минус что-то еще. N минус что-то еще. Ну это все, понятно дело, от N. Вот. То есть
по построму, поскольку я как бы сократил длину моего массива в K раз, я на нем могу sparse table
за линию построить. Ну просто потому что массив стал сильно короче. У меня вместо одного элемента
K элементов теперь. K элементов склеились в один. Все, а в sparse table я могу за единицу находить
минимум на отрезке. Ну а то есть еще раз, когда поступает запрос минимума на каком-то большом вот
таком вот куске массива, я сначала вычисляю, в каких блоках лежит начало и конец. Беру минимум
вот здесь, вот минимум вот здесь, вот из первого шага, потому что для каждого блока я умею на под
отрезке внутри блока находить минимум. А дальше у меня есть некий непрерывный кусок блоков,
мне нужно на этом куске найти минимум на отрезке. Это я делаю с помощью второго шага,
с помощью sparse table опять за единицу. Ну и все, получается, что ответ на запрос за единицу.
Поясните?
Ну, наверное, лучшим линии никак уж не получится.
Ну у нас просто n большой элементов, наверное, предпочитать быстрее, чем за n невозможно.
У нас ассимдотика, смотрите, получилось, первый шаг делается вот до столько,
то есть за o от n, и второй шаг делается за o от n, а запрос за единицу, ну понятно,
что эффективнее нельзя. Вот такая магия. Понятно?
Так, ну хорошо, значит, мы научились находить lca за линейный предпочет и за единицу на запрос.
Теперь мы можем это применить для того, чтобы находить минимум в любом массиве за линейный
предпочет и единицу на запрос. Ну давайте напишу задачу. Задача, которую мы давно решали.
Есть статический массив, а 1 и так далее а n. К нему поступают запросы. На отрезке lr найти
минимум между lr. Найти минимум на отрезке между l и r. Ну это вот модельная задача для sparse table.
Мы умеем это решать за n логин предпочета и единицу на запрос. Теперь научимся за линейный предпочет и единицу на запрос.
Решение. Давайте построим дикартовое дерево
с элементами, задающимися парами и ai. То есть и это ключ, а и это приоритет.
Сейчас скажу за линию. Напоминаю дикартовое дерево. Это такая дерево поиска, точнее не так.
Это бинарное дерево, являющееся деревом поиска по ключам и кучей по y. Куча по y значит минимум y
всегда лежит в корне. Вот здесь я оставлю место для того, чтобы описать, как строить дерево за
линейное время. На самом деле должна была быть эта задача в предыдущем семестре, что если у вас
ключи уже отсорщены по возрастанию, но понятно, что ключи у нас просто 1, 2 и так далее n, то мы можем
это построить дерево за линейное время. Значит вот здесь, давайте я оставлю, потом сюда вернусь, вопрос
как построить это дерево за вот n, зная, что ключи упорядочены. Здесь достаточно знать только того,
что ключи упорядочены. Теперь я отождаю следующее, чтобы найти минимум на отрезке в исходном
массиве. Достаточно всего лишь в этом дереве найти LCA у этих двух вершин LAL и RAR. Отвержение,
если, давайте я пишу так, если M это LCA для вершин L и R, то а M это минимум на отрезке SAEL по AVERT.
И значит, вместо того, чтобы находить минимум на отрезке, мне достаточно будет просто в этом
декартовом дереве найти LCA и вывести то число, которое в нем содержится. Давайте
какой-нибудь примерчик нарисую и докажем.
Так, пример.
Пусть будет что-то такое. Понятно, что корнем будет вот эта вот четверка. Здесь я пишу ключ,
запятая приоритет 4.1. Слева нужно вот эта вот будет корнем.
Вот оно. Вот такое декартовое дерево получается по этому массиву. И, например, смотрите, если я хочу
найти минимум на отрезке между первым и третьим элементом, то есть вот этот вот, вот он минимум,
то мне реально нужно между ними найти LCA и вот он будет здесь же, в той же самой точке 2. Если
нужно найти минимум между тройкой и пятеркой, вот они у меня, то их LCA вот здесь, это как раз
минимум. Это точка номер 4, вот она, это действительно минимум. То есть действительно получается так,
что минимум всегда там же, где LCA находится. Вот, но это на самом деле несложно показать,
несложно показать. Давайте мы поймем вообще, где находится минимум. Вот пусть M это их LCA.
Вот где-то оно находится, где-то эта вершина в нашем дереве располагается, M.
Да. Да, вот это тогда скорее нет. Ну, по крайней мере, в обычной реализации у меня
от TIN это нулевой TIN всегда вот здесь. Не знаю, нет, я не могу провести аналогию. То есть,
ну вхожу-то я вот здесь, вот сначала-то вот здесь, а единица у меня самая левая вершина, она вот там
вот. Поэтому, поэтому кажется, что нет. Ну вот, значит, давайте рассмотрим их LCA. Смотрите,
я утверждаю следующее, что не может быть такого, что L и R больше, чем M. Вот такого быть не может,
потому что если бы они были оба больше, чем M, то они должны бы оба лежать в правом поддереве.
Ну, потому что декартовое дерево так работает, если я знаю, что M это предок L и R, и при этом они
больше, чем M, то оно должно быть в правом поддереве, потому что у меня дерево поиска,
все ключи больше, чем M, лежат в правом под дереве. Ну извините, тогда у меня M не может быть LCA,
потому что эта вершина тоже их общий предок. Вот эта вершина тоже является предком и L и R.
потому что они оба в этом под деревья. Значит такого не бывает. Не бывает. Ну
симметрично не может быть такого, что LR оба в левом под деревья, потому что
будь они оба в левом под деревья, вот эта вершина была бы их
общим предком. Значит не бывает такого, что оба меньше чем m. Ну значит m как раз
между ними. Из этого всего следует, что m действительно где-то на отрезке между
ними. То есть по крайней мере мы попадаем куда-то внутрь отрезка. Теперь почему
там минимум достигается, минимальное значение h? Ну смотрите, если есть вот это
вот вершина m, в ее под дереве лежит целиком, ну точнее в ее под дереве лежит и L и R,
значит целиком подрезок с L по R. То есть если где-то вот здесь вот лежит L, где-то
здесь вот лежит R, то понятно, что весь отрезок между ними тоже целиком тут
лежит. Так, сейчас. Я думаю это очевидно. Вопрос почему это так? Почему если какие-то
две точки лежат, то между ними все тоже тут лежит? Да. Ну да, да, да, да, да, да. Я бы себе
это объяснил так, потому что если взять какой-то ключ X, расположенный между L и R, и
пытаться его искать в дереве поиска, то мы сначала дойдем досюда, потому что
поведение от корня до отсюда такое же, как вот при сравнении с L или с R. Ну а
дальше оно значит где-то внизу лежит. Я бы себе так это объяснил. Вот, значит
действительно весь отрезок здесь целиком лежит. Но раз весь отрезок здесь
целиком лежит, а m их общий предок, значит потому что дикартовое дерево это
куча, вот эта штука меньше обравна, чем все вот эти вот. Потому что приоритет
минимальный в корне, в корне текущего по дереву. Значит этот элемент меньше
обравнен, чем все они, значит он минимум просто. Вот. Значит давайте напишем, что в под
дереве, под дереве вершины m целиком лежит под отрезок с L по R, значит приоритет
у m-ки минимальный. Приоритет у m минимален. Ну все, а это значит как раз что m это
минимум на отрезке. Вот. Итого, мы свели задачу нахождения минимума на отрезке к
задаче поиска LCA, а LCA мы по предыдущему алгоритму Фарахолтон Бендера умеем за
линейный предпочет и за единицу на запрос отвечать. Да, да, да. Да, значит. Итог, свели
к LCA, а LCA мы умеем решать за линейный предпочет и единицу на запрос. Победа. То есть получилось
даже лучше, чем Спарстейбл. Ну и на самом деле просто как бы оптимальный алгоритм. Понятно,
что быстрее нельзя. Вот. Вопросы есть? Да, значит у меня остался долг научиться строить дерево
за линейное время. Ну давайте, давайте я это быстренько нарисую. Значит смотрите, я буду идти
просто по вершинам. Значит у меня вершины все даны. Да, вот они. Я буду идти по ним слева направо и
поддерживать текущую версию декартового дерева, постепенно добавляя в него вершины. Значит вот
давайте я несколько вершин добавил, несколько первых. И мое декартовое дерево выглядит вот так.
И вот здесь вот что-то. То есть я буду хранить правую ветку просто. От корня список всех правых
его детей. Ну точнее как бы его правого сына, правого сына, правого сына и так далее и так далее.
До самого конца пока есть вот эта правая ветка. Значит я построил вот такое декартовое дерево для
начала нашего массива. Теперь приходит новый элемент ИАИ, который лежит правее, чем все это
дерево, потому что И больше, чем все предыдущие ключи. Ну вот он где-то здесь. Ну тогда это уже
значит нужно сделать примерно следующее. Нужно найти, нужно как бы провести такую горизонтальную
понять какую стрелочку он рассекает и перенаправить вот эту стрелку сюда,
а вот эту сюда. Тогда это будет корректно декартово дерево. Ну потому что как бы понятно,
что у этой точки эта находится правее, а для этой это находится левее, и это будет корректно
декартово дерево. Ну чтобы понять, что все хорошо, надо строго поговорить про все вот эти
приоритеты там, короче, что это остается деревом поиска по ключам и кучей по Y,
ну если позалипать, то это очевидно. Вот. И значит, я как бы, храня вот эту вот правую ветку,
я могу просто, ну то есть смотрите, когда я новую вишину сюда вставляю, у меня правая ветка на
самом деле вот так упрощается. Это уже не направо движение, а сначала влево куда-то. Это я удаляю
из моей правой ветки. Значит, я могу правую ветку хранить в стеке, вершина стека будет вот здесь,
дальше я удаляю несколько последних, и новая добавленная вершина будет всегда вершиной стека.
Ну то есть я скажу, несколько последних мне нужно удалить, перенаправить здесь стрелки,
добавить эту последнюю вершину, новую вершину на вершину стека, и перенаправить вот это вот
ребро из последней вершины в последнюю вершину стека. То есть я храню правую ветку в виде стека.
Ну и понятно, что это тоже линейное время, потому что у каждой вершины добавится
удалиться максимум один раз, поэтому суммарно время работы линия. Кажется, все. Вопросы.
Окей, окей. Значит, пафос, еще раз повторюсь, что научившись искать ильца в дереве за линейный
предпочет и единицу на запрос, мы научились решать задачу поиска минимума в массиве опять за
линейный предпочет и единицу на запрос. То есть даже лучше, чем то, что мы имели раньше, через
вот такой переход к деревьям. Да, конечно, на самом деле в алгоритме нам даже, ну да-да-да-да-да-да,
нам не нужны операции на декартном дереве, нам нужно просто дерево само. Ну вот, такой прикол.
Так, хорошо, давайте следующий сюжет. Центральная декомпозиция.
Напоминание. Центроид это такая вершина, что после ее удаления из графа все компоненты будут
иметь размер не больше н пополам. Это такая вершина, что если удалить ее и все ребра из нее исходящие,
то размеры всех компонентов будут не больше н пополам. Где n это число вершин, как обычно.
Давайте представим себе какой-нибудь следующий тип задач. Задача дано дерево,
нужно в нем посчитать количество каких-нибудь объектов. Количество чего-нибудь. Да. Подождите,
это пока это название, тему сейчас вот я к ней подвожу. Я напоминаю, что какой-то центроид.
Отлично. Видите, все помните. Значит, еще раз. Давайте рассмотрим следующий тип задач. Задача,
есть дерево, и в нем нужно посчитать количество каких-нибудь объектов, которые как-нибудь описаны.
Там, не знаю, количество вершин на данном расстоянии. Или количество путей, удовлетворяющих
кому-нибудь свойству. Или количество троих вершин, таких что-то, что-то, что-то. Короче,
количество каких-то объектов комминаторных. Тогда такую задачу можно было бы решать так.
Смотрите, давайте выделим центроид в нашем дереве. Какие объекты пропадают после того,
как я удаляю центроид и, соответственно, все ребра из него. Давайте упростим. Давайте считать
пути. Например, нас просят найти количество каких-то путей. Просят найти количество каких-то
путей. Каких-то, то есть, обладающих каким-то задным свойством. Я сейчас не хочу конкретить
свойства, просто какое-то свойство. Какие пути, эти хорошие, которые мы ищем, пропадают после
удаления центроида и, соответственно, разбиение задач на эти более мелкие. Я бы сказал те,
которые проходят через центроид. Не обязательно длинные, они могут быть и короткие. Если я
удаляю центроид, я какие-то объекты разрушаю. Я убиваю какие-то пути, которые надо было бы
найти. Давайте их сначала все учтем. Посчитаем число объектов, проходящих через С. Потом С
удалим вместе со всеми ребрами и рекурсивно решим задачу на всех поддеревьях. Сложим ответы
вместе. Будет общий ответ. Понятно тогда, что я посчитаю все объекты, потому что каждый объект
либо содержится, либо не содержит. И тогда он, соответственно, целиком лежит в одном из поддеревьев.
Давайте это допишем. Сначала найдем количество объектов, содержащих С. Потом удалим С и
рекурсивно решим задачу на всех поддеревьях.
Вроде нет. Тогда смотрите в чем крутизна. Крутизна в том, что каждый рекурсивный
спуск уменьшает размер текущего поддерева хотя бы вдвое. Потому что если изначально
дерево было размера N, то после рекурсивного спуска у меня размер не больше ни на пополам за
счет того, что я решил его центровить. Ну и дальше в рекурсии тоже самое происходит. В этом меньшем
поддеревья находится какой-то новый центровец С штрих. За него все это поддерево подвешивается.
То есть вот это вот я как бы подвешиваю за С штрих. Там будет опять такая же аналогичная картинка.
Я сначала считаю количество объектов, проходящих через С штрих, потом его удаляю и рекурсивно
запускается от всех поддеревьев. Ну и уж по крайней мере можно точно сказать, что глубина рекурсии
будет логарифмическая. Потому что каждый спуск в рекурсии это уменьшение размеров по дереву хотя
бы вдвое. Вот именно зависит от того, какие объекты мы ищем. Но для конкретных задач это
обычно можно делать быстро. Значит глубина рекурсии будет логарифмическая, глубина рекурсии
даже не просто логарифмическая. Ну в смысле не от логарифма, а просто там логарифм. Не больше,
то есть логарифм округленный вверх скажем. Ну и теперь осталось нам как-нибудь эффективно научиться
решать вот эту штуку. Вот если мы научимся находить количество объектов, проходящих через С,
содержащих С как-нибудь быстро, то мы решим задачу, ну типа там Зейн Логан грубо говоря.
Понятная идея? Хорошо, ну давайте например рассмотрим.
Недолго думая решим такую задачу. Данного дерева и число D. Давайте отметим, что невзвешенное.
Невзвешенное и число D. Надо найти количество пар вершин на расстоянии ровно D друг от друга.
Найти число пар вершин у В таких, что расстояние между ними равно D.
Вот. Начну как раз вот задачу такого типа найти количество объектов. Объект это ну по факту путь
длины D. Потому что путь длины D и пара вершин на расстоянии D это одно и то же. То есть я сейчас
буду искать по факту, давайте я напишу эквалентную формулировку, что это просто число путей длины D.
Число путей длины D. Это вот ровно того типа задач. Значит сразу скажу, я не уверен, что эта задача
нельзя решить как-нибудь попроще. Типа там просто хитрым DFS каким-нибудь достаточно умным предпочетом
или что-то такое. Значит если вдруг вы научитесь решать эту задачу без центроида, то расскажите мне.
Вопрос можно ли это делать без центровой декомпозиции? Ну если у вас вдруг к концу
семестра много свободного времени образовалось, то вот подумайте, пожалуйста.
Ну N log N достаточно.
Композиции за N log N.
Это я не знаю. То есть вроде как на вскидку нельзя, но может быть что-нибудь и может.
Вот. Ну давайте научимся считать с центровой декомпозиции. Значит начало. То есть мы поняли,
что самый сложный шаг это научиться искать число объектов, проходящих через центроид.
Все остальное это общая схема, разбиение задач на подзадачи и рекурсивные решения в них.
Итак, вот есть центроид. Давайте за него подвесим. У меня образуется несколько под деревьев.
Мне сейчас нужно учесть, нужно добавить к ответу. Все пути, проходящие через C длины
вот этой вот фиксированной D. Все пути такой длины. Ну это практически следующая величина.
Давайте я подвешу все за C. Давайте я посчитаю глубину всех вершин. И тогда это практически
следующая величина. Сумму по всем вершинам... А, ну и еще мне нужно будет, видимо, ввести
количество вершин на каждой глубине. Пусть будет x от h. Это число вершин на глубине h.
Вершин на глубине h. Тогда ответ это примерно следующая величина. Сумму по всем вершинам
x от D-Dx от V. Потому что если я зафиксировал, скажем, один из концов нашего пути, то как
он выглядит? Раз этот путь содержит C, то мне нужно сначала дойти до центроида, то есть подняться
вверх. Это занимает у меня вот столько шагов. И потом нужно еще спуститься вниз вот настолько,
чтобы длина была ровно D. То есть я сначала поднимаюсь вверх на depth от V, а потом мне
нужно спуститься вниз вот настолько D-depth от V. И как раз если начало однозначно определено,
то спуститься я могу ровно таким числом способов. Сколько вершин на такой глубине,
столько способов и есть. Единственная проблема какая? Можно не делить, если я пару считаю
порядочными. Другая проблема есть. Нет, это легко считается. Да, вот такие пути мы зачем-то
посчитаем. Подняться D-depth, спуститься в то же под дерево и здесь куда-то вниз пойти. Это плохие
пути. Ну мы считаем, как бы я тут явно написал, но конечно мы считаем простые пути. Число простых
путей такое длинное. А вот эта штука нам такие пути посчитает. Вот нам нужно сейчас будет от них
избавиться и потом мы победим. Пережив. Ну, значит на самом деле добивается это очень просто. Мы
поняли какие пути плохие. Точнее, что мы учтем несколько раз. Мы учтем лишние пары внутри одного
под дерево. Вот если V в этом под дереве и конец этого пути, вот такого стрёмного тоже в этом
под дереве, то нам нужно его вычесть. Поэтому на самом деле можно после нахождения вот этой штуки
вычесть то же самое внутри каждого под дерево в каком-то смысле. То есть мне смотрите, вот если у
меня V вот здесь фиксировано, то что мне нужно выкинуть? Мне нужно выкинуть количество вершин в этом
под дереве таких, что длина вот этого пути это D. Давайте это по дереву нарисую вот здесь. Вот
здесь есть центрой C. Я хочу, чтобы вот этот путь имел длину D. Ничего ломать не будет.
Да, ну мы такие тоже удалим. Мы такие тоже удалим, если будет проблема. Ну, смотрите,
если вот такой вот путь имеет длину D, то вот такой вот путь без центроида имеет длину D-2,
потому что то ребро дважды учитывалось. А значит, мне нужно при фиксированном V вычесть просто из
ответа число вершин в этом дереве на глубине, вот отсюда считаемой, типа D-2-DxV. Ну что-то такое.
Ну типа того, да, типа того. Так, сейчас давайте я немножко по-другому это скажу. Вот пусть эта
вершина PIT, тогда вершина U плохая, если она лежит в том же под дереве, что и V. Значит,
если U и V лежат в поддереве PIT, ну где P-шки, это вот эти вот становья центроида. Вот это вот P1,
P2 и так далее, там ПК. Вот если они лежат в одном поддереве и при этом, значит, сумма их глубин
относительно центроида, это D. Вот. Ну а если я посчитаю их глубины относительно Pi,
ну то есть расстояние до Pi, давайте их вот так вот обозначу, depth,
depth-штрих, допусть будет. Да-да-да, это sin-центроида. Так вот давайте depth-штрих от каждой вершины,
это расстояние до sin-центроида. Вот. Тогда с точки зрения работы внутри этого
поддерева, то есть depth-глубины, это во всем дереве, а вот мне нужно, если на это я по дерево
суживаю, то у меня глубины все на единичку уменьшаются, и мне нужно, чтобы вот эти вот глубины их
в сумме давали бы D-2. Вот тогда такие пары надо вычесть. Ну вот, собственно, все. Тогда, смотрите,
моя задача сваливается к следующей. Во-первых, мне нужно во всем дереве для каждой глубины посчитать
число вершин на такой глубине. Во-вторых, в каждом из меньших поддеревьев, если я пересчитываю
глубины как depth-штрих, ну то есть получается, для depth-штрих просто всегда на 1 меньше, чем depth,
потому что я измеряю глубину не от sin-центроида, а от ребенка sin-центроида. Вот. Но опять наша
самая задача, только уже внутри этого поддерева, число вершин на каждой конкретной глубине в этом
поддереве. Вот. Их потом вычитаю. Значит, осталось, давайте напишу, сделать следующее. Во всем
дереве и во всех поддеревьях P-шек найти число вершин на каждой глубине, не происходящей D.
Ну или просто на самом деле на каждой глубине. Найти число вершин на каждой глубине. Это вот
то, что у меня там X обозначено. X это в общем дереве, ну и в каждом вот этом поддереве тоже
будет как бы свой какой-то X-штрих. Вот. А делать это очень просто. Смотрите, если у меня есть большое
дерево, там подвешенное за что-то, за какой-то корень, как посчитать число вершин на каждой
глубине? Но давайте сделать сначала следующее. Давайте запущу DFS на этом вот дереве, его все обойду
и посчитаю для каждой вершины размер поддерева sub-3 и глубину depth. Сейчас скажу. Тогда, понятное
дело, что глубина всегда не больше, ну скажем глубины всех вершин не больше, чем sub-3 от корня.
Потому что sub-3 от корня это количество вершин вообще везде вот здесь вот. Ну и понятно,
что глубина не может быть больше, чем размер всего этого дерева. Потому что даже в худшем случае,
если идти вниз, глубина получается как раз размер поддерева. Значит, я могу сделать следующее. Я
могу для корня завести массив размер sub-3 и просто для каждой вершины v добавить 1 в этом массиве в
позиции depth от v. Значит, я завожу массив какой-нибудь там x от 0 до sub-3 от корня.
Любой вершины делаю просто плюс-плюс x от depth от v. Как раз по глубине, вот она глубина.
Sub-3 это количество вершин в поддереве. Ну смотрите, вот еще раз моя задача какая. Вот есть поддерево
какое-то, просто дерево какое-то. Мне нужно для всех вершин посчитать глубину относительно вот
этого корня и посчитать количество вершин каждой конкретной глубины. То есть мне нужно создать
массив x, который бы для каждого числа, для каждого h сообщал количество вершин на такой глубине.
Ну я это ровное дело, только как бы я ровно это и делаю, только мне нужно, ну вот короче,
мне удобно ограничить размер x вот таким вот образом. То есть тут можно было бы вместо sub-3
написать max depth, например. Вы мне запрещаете? Ну вот я говорю, мне так будет удобно. Пока что
пока что это, то есть еще раз, пока что очевидно, что все глубины, все depth от v не больше чем sub-3
от r. Ну я это объяснил, глубина всегда не больше чем количество вершин в этом дереве. Значит это
все, это правильный код. Возможно. Но смотрите, я вот это сделал все. То есть получается,
что я за время, пропорциональный размер этого дерева решил задачу. Не-не-не, ну да, ну типа того.
Так вот теперь смотрите, вернемся сюда. Что мне нужно? Мне нужно было во всем этом дереве решить
задачу, и во всех вот этих вот K под деревьях, во всех под деревьях сыновей. Причем время работы
на всем под деревья, это скажем n, а на всех под деревьях это время работы равно размеру под дерева.
Потому что тот массив, который я создаю, он как раз имеет размер такой же, как размер под дерево,
и все ограничено размером под дерево. То есть вот здесь время работы c1, где c1 размер этого дерева,
здесь время работы c2 и так далее, здесь время работы сk. Ну поэтому суммарное время
время работы всех этих штук это сумма эссок, а суммарность
здесь совершенно n-1, все кроме центроида. Поэтому
суммарное время работы это n плюс сумма эссок, ну это
вот l. И ту оценку через размер под дерево я вел
именно для того, чтобы сказать, что время работы, то есть
если бы я здесь написал max depth, то у меня время работы
было бы как бы, ну можно и так. Просто здесь более
наглядно видно, что здесь полностью время работы
ограничено чисто размером под дерево корня. Поэтому
здесь все вот эти времена работы, это размер этого
по дереву, плюс это, плюс это, плюс это. А они в сумме
дают как раз n. Поэтому суммарно, чтобы посчитать число путей
длины d, проходящего через центроид, я потратил линейное
время. Все. Да, да, да, да. То есть я вот эту вот задачу
применяю ко всему дереву и вот к этим капот деревьям.
Да, да, в это же под дерево. Да. Еще раз. Так. Так. Можно-можно-можно-можно-можно-можно.
А потом вернем, типа, да? Можно так, да, вы правы,
можно так. Но мне кажется, чуть-чуть труднее объяснять,
но... Ваш тоже рабочий. Ау? Можно. Вы можете что хотите
вообще? В алгоритме можно и не делать, да? Пожалуйста.
Ну вот, вроде все. А то есть, смотрите, давайте еще раз,
давайте пройдемся по алгоритму. То есть, во-первых, алгоритм
мне дается деревом, мне нужно посчитать количество
путей такой-то длины. Я в дерево сначала выбираю
центроид. Центроид мы уже умеем искать. Подвешиваю
дерево за центроид. У него появляются какие-то дети
Я решаю вот ту задачу для всего дерева и всех вот
этих вот кап от деревьев его детей. Тем самым узнавая
количество вершин каждой конкретной глубины в каждом
из этих деревьев. Дальше, там, суммируя какие-то правильные
штуки, я узнаю количество путей как раз пересекающих
ц, проходящих через ц. Дальше я все это удаляю, ц вместе
с ребрами, и рекурсивно запускаюсь вот на этих
по деревьях. Тогда давайте время работы померяем.
Хорошо. Начнем со времени работы. Смотрите, если текущий
размер по дереву был n, то я за отн нашел число путей
пересекающих ц, проходящих через ц, и рекурсивно запустился
от каких-то кусков. Давайте напишу так, что t от n – это
от n плюс t от всех под деревьев, где я знаю, что все s не больше
чем n пополам. Вот эти s – это как раз размеры под деревьев
всех, под деревьев детей центроида. И причем они
все имеют размер не больше чем n пополам.
Так. И хочется сказать, что это будет n log n. Начнем
давайте немножко по-другому. Представляете, почему это
n log n? Вот есть у меня изначально все дерево, все n-вершин. Их
обрабатываю я за линейное время, за отн. Дальше. Из
исходного дерева, где было n-вершин, я удаляю центроид,
разбиваю под задачу на несколько детей и, соответственно,
запускаюсь рекурсивно для массива длины n1, то есть
для дерева размера s1, для дерева размера s2 и так далее
для дерева размера sk. Причем суммарный размер всех этих
деревьев не больше чем n, точнее ровно n-1. Вот. Значит,
это будет второй слой моей рекурсии. Каждое вот это
вот дерево обрабатывается за линейное время от его
значит, суммарно все вот эти деревья опять за линию
обработаются. То есть суммарно весь второй слой рекурсии
работает за линию, потому что здесь каждое за линию от
размера и суммарный размер линии. Да. Ну и дальше
тоже самое. Каждое из них рекурсивно разбивается
на какие-то поддеревья, но при этом суммарно на третьем
уровне рекурсии опять не больше чем n-вершин, значит
они суммарно обработаны за линейное время отн. Ну и
так далее. А глубина, как мы уже замечали, у нас
ограничена логарифмом. Поэтому суммарный время работает
n-логан. Ну вот. Нет, нет, нет, нет, нет. K это просто
какой-то параметр. Сколько угодно может быть. Давайте
напишу просто S. С какое-то. Наверное, ну вот наверное
можно, но так как-то нагляднее. Давайте подумаем минутку.
Ну тут надо понять, что n-логан, она выпуклая или вогнутая.
То есть как бы у меня есть, у меня по сути есть n-1, представленное
в виде суммы. Да, я, кстати, забыл написать, что n-1 – это
сумма S. Вот. Мне нужно понять, какое максимальное значение
может достигать вот эта величина при вот этих условиях.
Ну это что-то неприятное. Надо понять, как ведется
эта функция. Почему она вдруг максимально, именно когда
они примерно поровну разбиваются. Ну да, вот именно, что они
константа, поэтому не понятно. А так вроде. Ну вроде все.
Так есть вопросы по центровой уровне композиции? Хорошо.
Значит, тогда следующая структура – это хавиллайди-композиция.
Хавиллайди-композиция. Значит, здесь уже задача не про подсчет чего-нибудь,
а задача очень похожая на то, что мы делали в каких-нибудь там задачах на дерево отрезков.
Да, например, что у нас было в дереве отрезков. У нас есть массив, и он как-то обновляется,
и к нему поступают какие-нибудь запросы. Типа там обновить в точке и посчитать сумму на отрезки.
Вот здесь то же самое только на дереве. А именно, есть какое-то дерево. Давайте я для удобства скажу,
что на ребрах написаны числа. На ребрах написаны числа. Поступают запросы. На
ребре число изменить и найти сумму на пути. То есть, если раньше я искал в массиве сумму на отрезки,
то теперь я буду искать сумму на пути. Вот какое-нибудь там дерево. Не обязательно бинарное произвольное
дерево. На ребрах написаны числа. Мне нужно искать сумму на пути и менять числа, записанные на пути.
Вот что-нибудь такое же похоже на ДО хотелось бы сделать. То есть, по факту это просто запросы,
запросы на путях. Так, напишу, запросы на путях. На путях. Ну, соответственно, модельная задача.
Давайте зафиксирую. Такая. У нас есть дерево, давайте напишу так, дерево фиксированной структуры. То есть,
как бы набор ребер одинаковый. Вот ребра не меняются, только числа на них. Дерево фиксированной структуры.
Есть числа на ребрах. Есть два типа запроса. Первый это апдейт на ребре. Апдейт, скажем,
ех. Это нужно число, записанное на ребре х, например, увеличить на, sorry, число, записанное на ребре е,
увеличить на х. Число на ребре е, увеличить на х. Вот. Ну и второй это сумма на пути. Вам дают две
вершины у и в, концы пути. Вот они. Вам нужно на единственном простом пути между ними найти сумму
чисел записанных на всех ребрах. Найти сумму чисел на пути.
Вот. Идея будет такая. Идея будет следующая. Я, вот эти вот пути, которые у меня есть в дереве,
какие-то из них, так, сейчас. Значит, не так. Я мое дерево
представлю в виде нескольких путей не пересекающихся. То есть, например, вот это дерево можно представить так.
Вот такой вот путь. Вот такой вот путь. Единственные ребра бывают. Вот такой вот путь. И вот такой вот путь.
Значит, я разбиваю все мое дерево на какие-то пути, не пересекающиеся по вершинам. Ну еще, возможно,
будут такие отдельные ребра, которые отдельно будут торчать. Тогда у меня теперь каждый путь вот
такой вот. Это, по факту, массив. Я могу вот такой путь воспринимать как массив. Потому что на нем
фиксировано какой-то порядок, например, там снизу вверх. Вот они занумерованы эти ребра на этом пути.
И я могу на каждом таком пути ввести дерево отрезков, например. На каждом пути ввожу структуру
данных, которая, по факту, позволяет защищать на эти запросы. А дальше, смотрите, если на каждом таком
пути у меня введено свое дерево отрезков, то чтобы, например, найти ответ на вот таком вот пути,
то есть вот на этом пути, мне нужно взять ответ из вот этого дерева, из вот этого дерева отрезков и
прибавить еще вот это ребро. Давайте я даже поинтереснее веду. Вот, например, вот такой путь мне
нужно сделать. Если меня интересует ответ вот таком вот пути, то мне нужно взять целиком величину
вот этого дерева, прибавить вес вот этого ребра и взять под отрезок вот этого нового дерева.
И мне хотелось бы сделать так, чтобы вот этих вот суммарно количество деревьев отрезков,
которые я перехожу в моем пути, было не очень много. Тогда если, скажем, мой вот этот путь
между У и В пересекает какое-нибудь маленькое количество деревьев отрезков, ну как бы имеется
с ними не пустое пересечение, то мне нужно будет в несколько, в небольшое количество деревьев
отрезков сделать запрос на отрезке. Ну и плюс еще вот эти вот ребра, которые
переходят между деревьями тоже учесть. Если их будет маленькое количество, у нас их будет
логарифмическое количество, то я смогу отвечать на запрос за лог квадрат. Потому что у меня
логарифм разных деревьев, отрезков, и в каждом дереве я за логарифм отвечаю на запрос.
Тогда у меня получится ответный запрос за лог квадрат. Вот идея такая. Значит, как мы это реализуем?
Как мы это реализуем? Значит, во-первых, давайте мы опять посчитаем размеры всех по деревьев.
Посчитаем с помощью DFS размеры всех по деревьев.
Дальше. Давайте рассмотрим какую-то вершину и все исходящие линии ребра.
Тяжелым или активным я назову ребро, ведущее в самое большое под дерево. Тяжелое ребро — это
ребро, ведущее из В какого-то из сыновей с наибольшим размером под дерево. Тяжелое
ребро из В — это ребро сына с наибольшим сап-3. Если таких несколько, давайте выберем вершину
с меньшим номером. А если таких несколько, ну, я просто для однозначности напишу сына с наименьшим номером.
Вот. Теперь у меня у каждой вершины есть какая-то выделенное ребро вниз. У каждой вершины есть
выделенное ребро вниз. Из всех детей один выбран. Такой, у которого размер вот этот, то есть вот это
вот по дереву самое большое, по сравнению со всеми остальными они будут маленькими. Вот такие вот.
Ребро самого большого сына. Так. Ну и вот теперь, если вот эти вот тяжелые ребра воспринимать,
как вот эти вот самые выделенные, да, вот которые здесь сплошными рисовал, и пути выделять,
как пути тяжелых ребер подряд, то это и будут те пути, которые мы ищем. Значит, разбиваем дерево,
дерево на пути из тяжелых ребер. Пример сразу нарисую, чтобы было понятно,
что имеется в виду. Так. Какое-нибудь мне нужно дерево большое. Ну вот я сейчас как раз проиллюстрирую.
То есть у меня у каждой вершины выделено какое-то исходящее ребро, и вот последовательность подряд
идущих ребер, тяжелых вот этих вот, это будет путь, на котором я буду строить дерево отрезков.
Так. Вот давайте, например, такое дерево, вот он корень. Давайте у каждой вершины найдем тяжелое
исходящее ребро. Значит, снизу вверх, но для листьев тяжелого ребра нет. Вот здесь у меня все три под
дерево одинаковые. Ну давайте для определенности самое левое из них выбирать. Вот оно, тяжелое
ребро. Дальше у этой вершины здесь одна вершина под дерево, здесь четыре. Понятно, что вот это
ребро, это тяжелое ребро. Самое большое ребро тяжелое. Так. Здесь тоже самое. Из трех детей
выбираю самого левого. Здесь один, четыре, один. Опять этот самый тяжелый. Вот. Тут пока непонятно.
Здесь из двух детей выбираем самого левого. Здесь самый тяжелый опять вот он. И теперь мне
нужно определить для корня, кто из вот этих вот трех под деревом самый тяжелый. Давайте размеры
посчитаем. Здесь 6 получился размер, здесь 7, здесь тоже 7. Похоже на правду, да. Ну из них
максимальная семерка, из них выбираем самого левого. Вот оно. Что получилось? Вот у меня
получился один путь по тяжелым ребрам. Второй путь и третий путь. То есть вот эти вот цепочки
подряд идущих вниз путей по тяжелым ребрам, это и будут те пути, на которых мы будем строить
деревоотресков. Вот. Будем называть это тяжелыми путями. Вот эти вот товарищи тяжелые пути.
Тяжелые пути. Значит, на них строим деревьяотресков. На тяжелых путях строим, ну в нашей задаче деревоотресков,
в общей задаче какую-то структуру данных, ту структуру данных, которая позволяет на вот
эти запросы отвечать. Давайте в нашем случае строим деревоотресков. Да. На каждом свое. Да. Вот
здесь, ну то есть как бы мне нужна структура, как бы там класс какой-то деревоотресков, который
по данному набору ребра строит на нем деревоотресков. У меня будет вот здесь одно, вот здесь второе,
здесь третье. Они не пересекаются, это прям отдельные сущности независимые. Давайте напишем свое. Да,
свое. Что? Сейчас скажу. Вот в этом графе у меня будет три деревоотресков. Одно из них имеет
размер два, потому что вот эти два ребра, ну то есть как бы мне нужно построить деревоотресков на
вот этих числах, х и у. То есть у меня будет вот такое деревоотресков, а здесь сумма х плюс у. Ну как
строится ДО на сумму оботрески. Если здесь написано АВЦ, то у меня написано в листах АВЦ, а здесь
там ну как-то считается сумма. Вот так, например. То есть я, ну на самом деле не важно, давайте
считать, что у меня номерация идет снизу. Вот у меня есть набор чисел снизу вверх на этом пути.
Я на нем как на массиве обычном строю деревоотресков. Не все, не все, не все. Конечно,
какие-то ребра, которые не помечены тяжелыми, они не войдут ни в какое ДО. Это пока нормально.
Потому что по определению, это вершина, у нее есть тяжелый сын, вот он, у нее есть тяжелый сын,
это все путь тяжелый, путь из тяжелых ребер. Я на нем тоже строю ДО. Неважно, просто-просто,
вот есть вершина какая-то, у нее есть исходящее тяжелое ребро, у нее есть исходящее тяжелое
ребро и так далее. Вот целиком, пока я вниз могу этот путь продолжить, я все это объединяю и говорю,
что это один тяжелый путь. Сплошной, как бы, сплошная постоянность тяжелых ребер. Да нет,
бывает почему, если у вас вот такое вот дерево, например, у вас вот будет тяжелый путь ДН1. Хорошо.
Вот, а теперь, значит, утверждение. Путь между вершинами У и В пересекает не больше,
чем от Логен тяжелых путей. Если мы это докажем, то мы победили на самом деле,
потому что, ну, как бы, я это уже описывал, что если есть какой-то путь, то он, получается,
складывается из каких-то кусочков тяжелых путей непрерывных. На каждом тяжелом пути нужно сделать
запрос к ДО за логарифом, и есть еще между ними перемычки, например, вот здесь. Если я ищу путь
отсюда до сюда, то мне нужно взять целиком отрезок вот этот вот, потом добавить это легкое ребро,
ну, я знаю, ну, как бы, не тяжелое ребро, я знаю, как это на нем написано, просто храню, добавляю
к ответу. И вот на этом куске, то есть на этом отрезке в массиве, в своем ДО, я тоже добавляю
ответ. Беру оттуда сумму, она у меня там хранится где-то, и за логарифом еще добавляю. Ну все.
Почему это верно? Доказательства. Давайте рассмотрим путь от У до их LCA. Рассмотрим путь от У до LCA-UV.
Вот такой восходящий путь. Значит, что такое, что значит, что нам придется пересекать разные
тяжелые пути? Значит, например, у меня начало это какой-то один тяжелый путь, дальше ребро легкое,
и я перехожу к новому тяжелому пути. Потом опять легкое ребро, опять перехожу к новому тяжелому
пути, и так далее. То есть по факту число тяжелых путей, которые я здесь пересекаю, это количество
с точностью до плюс-минус 1, это количество легких ребер, которые я встречаю, потому что каждое
легкое ребро это переключение на другой тяжелый путь. Каждое легкое ребро это переключение на
другой тяжелый путь. Но вопрос, сколько может быть легких ребер на пути от У до LCA? Вот я даже
что не большим логарифом, потому что если ребро легкое, давайте это ребро рассмотрим, вот было
легкое ребро какое-то, легкое. Значит, вот здесь вот размер поддерева не больше, чем у какого-то
другого сына этой вершины. Значит, при переходе вверх по легкому ребру, текущий размер поддерева
хотя бы удваивается, потому что если здесь был sub3 какой-то s, размер sub3 хотя бы s, то здесь
еще тем более больше равно s, потому что это легкое, а значит в тяжелом хотя бы s. Значит,
суммарно во всем поддереве хотя бы 2s плюс 1. Значит, подъем по легкому ребру хотя бы удваивает
размер текущего поддерева, ну а удваивается можно логарифом раз только. Значит, легких ребер максимум
логарифом их log n. Значит, как раз вот этих вот сплошных кусков тяжелых путей логарифмическое
количество. Это у меня был путь от u до lca, путь от lca до v, но аналогично здесь можно его также снизу
вверх пройти, здесь будет максимум логарифом легких ребер. Значит, суммарно у меня будет от
логарифма тяжелых путей и от логарифма легких ребер. Похоже на правду? Ну и собственно все.
Значит, тогда давайте я напишу как отвечать тогда на запрос. Ну запрос апдейта. С апдейтом все очень
просто. Мне дают какое-то ребро, говорят на нем увеличить число на x. Значит, мне нужно понять это
ребро легкое или тяжелое. Если легкое, то делать ничего не нужно, нужно просто обновить здесь число,
потому что легкие ребра у меня в DO не входят. Легкие ребра это просто вот эти отдельные перемышки,
которые я отдельно храню и бог с ними. Значит, если ребро легкое, я просто за единицу увеличиваю на
нем храняющее число и больше ничего не делаю. Если оно тяжелое, то мне нужно понять в каком оно
preneу дерева отрезков лежит. Если оно тяжелое, значит оно является частью какого-то тяжелого пути.
Мне нужно понять, что это за путь, то есть что за DO ему соответствуют и какой номер у этого
ребра в этом дереве отрезков и на следующей ячейке сделать апдейт. Вот это вот сводится к
Doesn't Useless Update в DO. Ну для этого мне нужно знать, какой номер у этого дерева отрезков,
потому что у меня же много деревьев отрезков, да? У меня для каждого тяжелого пути свое дерево
отрезков так вот давайте тогда буду просто для каждого
ребра хранить что за номер DO в котором он лежит и какой
у него номер в этом DO ну потому что у меня же вот это
путь вот он скажем давайте это ребро номер ноль имеет
в своем DO это один это два главное чтобы у каждого
ребра был свой номер в этом DO вот значит у каждого
ребра у каждого ребра нужен номер DO и позиция внутри
этого DO и позиция внутри DO нет нет нет это предпочитывается
за линию в самом начале это предпочитывается за линию
в самом начале потому что ну вот давайте вот у меня
было дерево мне нужно сейчас для каждого ребра сохранить
какой номер DO у него то есть какой номер тяжелого
пути и какая позиция внутри этого тяжелого пути так
но наверное все таки удобнее сверху вниз нумеровать
давайте снизу вверх раз уж начал значит как нумеровать
снизу вверх вот я иду моим ДФСом для каждой вершины
запоминаю родителя и если я дошел до вершины у которой
нет тяжелого стына то есть до листа то я буду подниматься
по родителям их нумеровать 012 то есть снизу вверх как
бы рекурсию развернуть и здесь пронумеровать у
них все у них все номера причем сказать что они все
в одном DO лежат то есть завести какую-то новую структуру
им всем сказать что эти ребра лежат в новом DO и имеют
такие номера 012 вот ну и соответственно то же самое
я как бы ну да то есть для каждого листа я просто поднимаюсь
рекурсивно ну не рекурсивно просто по родителям поднимаюсь
пока пока вот эти все ребра тяжелые я поднимаюсь и их
нумеру то есть это просто в самом начале делать каким-то
подсчетом тут ничего ничего в среднем не будет вот
значит тогда это будет за логарифом потому что по
факту это просто один запрос к до вот теперь сумму как
находить ну тут как бы тоже нужны какие-то подробности
но идейно уже все объяснили значит сумма во-первых мне
нужна найти lca во-первых я нахожу их кольца и давайте
я сведу задачу к двум под задачам сумму от у до w и
от в до w ну две одинаковые задачи сейчас решаю от
в от вершины до какого-то предка решаю теперь у меня
задача такая вот есть у вот есть какой-то ее предок
я хочу здесь найти сумму мне нужно этот путь уметь
эффективно разбить на вот эти вот куски тяжелых
путей и легкие перемычки между ними ну как это сделать
на самом деле когда у меня происходит перемычка между
одним тяжелым путем и другим это значит что вот здесь
вот этот тяжелый путь как раз таки начинался вот
это вот вершина самой верхней вершины вот этого נижнего
тяжелого пути это его начал на самом деле ну потому
что просто ребров родитель оно уже не тяжелое значит
этотixon здесь начался поэтому мне нужно просто
знать где начинается текущая тяжелый путь я попаду сюда
его родитель соответственно это это лег Lane потом я
пришел сюда знаю что я нахожусь в каком-то новом дереве
отрезков в новом тяжелом пути знаю где он начинается
вот это новое начинаешь серебро нахожу здесь сумму на пути мы так далее значит мне нужно
давайте напишем что не нужно хранить позицию начала для каждого тяжелого пути
но дальше делаю ровно вот это у меня есть вершина у меня есть какой-то тяжелый путь
ее содержащий я знаю где он начинается да вот это вот начало давайте какой-то
beginning beginning от в где от у где начинается тяжелый путь содержащий у вот если этот весь путь
лежит целиком ниже чем в то есть в где-то еще выше если в или от сопредком beginning то мне
нужно взять целиком сумму на этом пути сделать запрос в до причем я знаю на каком отрезке у меня
все здесь нумеровано я знаю что это там это последний это предпоследний так далее короче
я знаю какие у них номера скажем просто исходя из глубин я знаю глубину вот этого я знаю глубину
этого я знаю длину ну короче короче номера их легко восстанавливается вот нахожу сумму на
пути дальше следующий рюбов легкая я к ответу просто прибавляю его вес потому что легкие
ребра у меня отдельно хранятся поднимаюсь сюда ну и делаю так пока не дадут до до дольца и
таких итерации будет как раз логарифмическое количество то есть у меня от логарифма запросов
до получается это лог квадрат
да если правильно сделать то можно ну а вы умеете делать такой такой обход который бы хранил
так давайте мы лекцию закончим и мы с вами это обсудим все да спасибо
