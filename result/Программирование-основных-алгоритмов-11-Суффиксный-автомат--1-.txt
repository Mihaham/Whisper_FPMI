а так собственно это лекция где мы половина следующий будет посвящена суффиксному автомату
однако о нем мы заговорим минут через 40 сначала немного теории а так определение
пусть задан язык и тогда правый контекст
слово в мы будем обозначать как р или тв но это райт права или то язык по которому мы берем
это какое-то слово быть может не из языка вообще это не особо важно то есть это множество таких
у что дописав их справок в мы получим слово из л ну пример очень простой тогда р л от а это
будет б б б потому что если мы продлим а справа буквой б то больше слова обез языка аналогично
со словом б б а б б в языке может быть пустой контекст со слов то есть не может может вообще
таких слов не быть может быть контекст состоящий только из эпсилон это нормально то есть например
р или таба это пустое слово эпсилон и бы вот соответственно обозначение будем говорить что два
языка эквивалентны по два слова эквивалентны по языку л то есть у эквивалентно по л св тогда
только тогда когда их правый контекст равны вот окей что тогда теперь будем говорить с вами
вообще есть тема махиллони роуда такая из формалок что если мы ввели вот такое отношение
эквивалентности то существует и автомат который распознает язык и содержащий в себе ровно
столько состояния сколько классик и лентности и более того автомат с меньшим состоянием построить
просто нельзя ну да имеется то конечно если конечно много нас все-таки конечные языки
бесконечно мы не будем рассматривать вот окей теперь зафиксируем строку с ну ладно не буду
писать просто у вас будет одна строка с фиксирована который будем хотеть построить наш автомат прекрасно
вот тогда мы определим язык и это язык всех суффиксов
т.е. если у нас строка давайте s равно a b a b тогда l это язык всех суффиксов a b a b b a b
b ну добавляйте все он или нет в зависимости от того чем хотим эти пока не будем говорить
вдруг пригодится где-то добавим вот окей так соответственно теперь тогда раз у нас язык
порождается всеми суффиксами с я имею право записывать эквивалентность не по языку а по
строке с ну просто замена переменной тогда у эквивалента по s строке в тогда и только тогда когда
рл от у равно рл от в где где л это язык суффиксов
вот в общем-то наша будет глобальная цель это построить автомат у которого вершина это класс
эквивалентности вот что вот наш великий замысел давайте ему потихонечку приближаться а именно
сначала сформулируем следующее что совсем просто утверждение нет сначала не утверждение замечание
будет замечание такое что здесь и далее далее рассматриваем только
под строке с то есть нас там будут всякие слова у слова в строка гамма например все
будет под строками с если не сказано обратного вот теперь можно утверждение формулировать
что у нас за утверждение утверждение такое пусть у и в под строке с бла бла бла если рл от
у ну давайте напишем даже что неквивалентных новых обозначениях из этого следует что либо
у суффикс в либо в суффикс у ну и здесь может сказать что у и в не равны однако можно считать
что суффикс может быть совпадением полностью строк и стога все окей вот ну доказательства
плюс-минус тревелина почему так давайте что значит что вообще мы рассмотрим под строки
с значит у них правый контекст может пустым в смысле почему хотя бы всегда нет смотрите
еще раз я смотрю произвольную под строку очевидно что не есть способ продолжить
вправо до суффикса даже если я смотрю какой-то из суффиксов у него всегда степси он хотя бы
но у оба будет либо оба либо в правом контексте убрали будет только я в правом контексте но
никогда не пустой то есть он может состоять из одного пустого слова но все равно это один
элемент значит нас так какую в это под строке даже здесь напишем то есть слова w такие что
рл w не пустой так как рл от у равно рл от в не равно пустого множества за этого следует что
существует давайте гамма скажем существует гамма такая что у гамма это суффикс с и вы гамма
это суффикс с ну что тогда можно сказать вот ваша строка с и у нас есть у гамма суффикс
с и вы гамма суффикс с то есть я смотрю здесь гамму рассмотреть здесь у рассмотреть здесь в но
если дна уборщим длина в эту картинка вот такая иначе у его имеются местами то есть у вас вот
всегда вот есть это вот граница на которой у его заканчивается потому что есть гамма в правом
контексте раз так то значит у его заканчивается в одном месте значит одно из них суффикс другого
давайте как запишем тогда у и вы заканчиваются давайте так имеют вхождение с правой границей
длина с минус длины гамма ну то есть это индекс это длина с минус 1 гамма вот откуда следует что
но одно суффикс другого сразу следует другого
так с этим понятно вроде тривиального утверждения чуть-чуть менее тривиальная
да конечно
ну
вот пример таких слов сейчас дать попробуем что-нибудь придумать такое простенькое чтобы
у них были равные вхождения да сейчас так ну окей ну вот это самое простое что можно придумать
я вот уже что этих двух слов равный контекст правой и оба пьесе все больше ничего нет
ну нет я беру баб и а баб два слова они разные два под слова но при этом их контекста права
одинаковый поэтому не квивалентно ну это нормально примерно так-то ну окей чуть
менее тривиально хотите ну вот так вот действительно у баб и а баб права контекста
права контекста все больше нет ничего так еще одно утверждение об устройстве одного класса
пусть у это самая длинная строка
в ц.к. вероятности тогда c состоит из у и нескольких самых длинных суффиксов
доказательство следующее что ну раз у нас есть все лежит в одном классе квивалентности то есть
нас верно вот это вот и при этом у это самая длинная строка в этом классе квивалентности
значит любая в то есть давайте рассмотрим так пусть в лежит в ц.модуль очевидно меньше
чем модуль у потому что ну длинная потому что у это самая длинная ц.тогда так как в у принадлежат
ц. из этого следует что у и в эквивалентно по строке с раз не эквивалентно по строке 100 что
тогда из этого следует что в суффикс у то есть я показал что если что-то лежит в классе квивалентности
это обязательно суффикс у второй шаг нужно показать что это неприютный подотрезок по суффиксам
будет так место мало ладно то есть картинка такая вот у вас есть ваша у и вот можно
откусывать по одному символу
хорошо если у то самодельно то пускай в будет самой короткой
пусть и в самая короткая ц. то есть это вот в и пусть x это суффикс у
такой что длина у больше длины x больше длины в то есть какой-то промежуточный суффикс мы
рассматриваем отсюда я хочу показать что он лежит в том же классе квивалентности что у и в
потому что у и в уже в ц. мне нужно показать что все промежуточные лежат окей рассмотрю
произвольный промежуточный суффикс что тогда а тогда я утверждаю следующее что во-первых у
меня есть такое вложение. почему это так давайте для этой пары рассмотрим что значит что x это
суффикс у это значит что все продолжения справа у до суффикса с они являются и продолжениями x быть
может у x есть другие продолжения но главное что отсюда все продолжения входят в этот
отлично аналогично с x в получается но на самом деле вы на семинаре докажете что у вас
бывает либо два случая когда у и в две подстроки либо один из классов ложим в другой тогда одно
суффикс другого либо же вы докажете что их пересечение пустое вообще вот ну это пока что
нам не нужно здесь но рл от у это что же самое что рл от в потому что они в одном классе лежат
он доказали все то есть нас есть такое вложение и при этом это равно этому начни все три равны
значит мы получаем что это какой-то подотрезок суффиксов непрерывных
пухну самой легкой позади так теперь несколько обозначений определение даже будет
так самая лонгест от класса ц это самая длинная строка в с точнее строка в ц
то есть я мог бы там не писать в доказательстве что у это самая длинная страховца мог сказать
что у равно лонгеста ц тоже самое будет дальше будет понятие лен это длина лонгеста так
кажется стало плохо видно это с миним маркер и что еще нам нужно будет ну вашу
любимую суффикс на ссылке конечно надо определить линка ц ведет в такой ц-штрих
что лонгест от ц-штрих это суффикс самый длинный суффикс
лонгеста ц нележащий в ц
так давайте поймем как это выглядит давайте возьму какую-то произвольную подстроку и
и мы посмотрим на ее суффикса
так я сказал что по сути укладской верности это несколько подрядующих суффиксов допустим
закончится где-то здесь тогда значит что суффиксная ссылка отсюда ведет сюда отсюда
сюда ну и так далее то есть нас получается так называемые суффиксные пути это пути
суффиксных ссылок линка ц ну суффиксная ссылка вершина ц введет в такой ц-штрих
вот ц вот ваш ц-штрих будет что лонгеста ц-штрих это вот это вот это самый длинный
суффикс лонгеста ц вот этой вот такой что вот этот вот этот суффикс не лежит в ц уже так
теорема теорема собственно про то как мы определяем лонгеста как понять что строка
является лонгестом в своем классе и в целом может быть вообще каким-то лонгестом может
называть новый класс вот так скажем критерий лонгест ну как раз звучит что
у равно лонгест от класса эквивалентности слова у то есть нас у лежит в каком-то классе
эквивалентности то через квадратные скобочки у я буду обозначать класс хрена если в котором
у лежит вроде это плюс минус тривиальное обозначение вот тогда у является лонгестом
в своем же классе тогда итог тра когда выполнено одно из двух у это префикс с
ну тогда вроде понятно у вас просто длиннее ничего нет а второе существует альфа неравный
бета то есть это просто буковки это не строки такие что альфа у и бета у под строки с то есть
если я могу влево продолжить по одной букве и получить под строки с по разному продолжить
то эта штука является лонгестом в своем классе дать доказывать давайте докажем наверное в
какую сторону окей ну попробуем давайте слева направо то есть если у это лонгест то либо префикс
либо существует два разных продолжения ну окей докажем от контрпозиции то есть докажем что
если это не верно значит не верно это пусть у не префикс с и не существует вон давайте просто
напишу это все потом напишу отрицание под строки и возьму от этого отрицание вот как
планторах распишите сами распишите вот тогда что тогда тогда у нас получается что у нас это
есть наша с да строка есть какие-то хождения у но раз у меня не существует двух таких раз
значит везде предваряет одна и та же буква ну и у не префикс мы сразу сказали то есть нас
можно всегда слева предварить ее ну что тогда тогда любому вхождению у соответствует вхождение
иксу откуда вас следует что икс у эквивалентно по строке сдавайте откуда следует что у просто
не лонгест потому что у нас есть иксу в этом классике реверсности так в одно сон доказали
дать обратно я хочу доказать что либо лонгест это префикс то есть если либо то либо это значит
это лонгест так ну полный доказатель примерно также строится что возьмем контрпозицию и
прием противоречия с тем что у нас будет один тот же класс эквалентности так пусть у не равно
из этого следует что но при этом у лежит же в своем классе где лежит у поэтому у это суффикс
лонгест от куда следует что существует гамма ну либо ну то же самое существует гамма такая
что длина гамма больше либо равна 1 и эти гамма длина гамма будет равна единичке все-таки такая
что гамма у лежит в классе эквалентности у но откуда вас следует что мы следует противоречие
с этим вот то есть либо у не префикс с потому что мы смогли продолжить прямо вот либо у не
будет всегда с этим условием либо это не либо все-таки я пишу человеческий что
у не префикс с и любое вхождение у сопровождается вхождением гамма у
ну тогда не существует просто различных ну конец на этом в общем-то
ну вот это почему не выполняется потому что есть у вас то есть у вас у не лонгест значит у вас
с любым вхождением у то есть продолжением вправо так абсолютно такое же продолжение есть у гаммы у
значит любое вхождение у как под строки сопровождается в начале буквой гамма ну все
значит не углу и разных просто выбрать ну то есть идея здесь такая же просто это то же самое
как только в другую сторону чуть доказали смотрите у вас есть ум и она не лонгест вот
значит есть когда все время входит с у все время ходит икс у если с у все время входит иксу но
наш выключает гамма у получилось вот из этого следует что все вхождения у сопровождаются гаммой
ну тогда у нас просто нельзя выбрать две различные буквы у нас нет таких вхождений у чтобы они
предварялись по-разному так что теперь нужно понять нужно понять что если я знаю все лонгесты я
легко восстановлю все классы то есть я хочу сказать что мне на самом деле автомате не надо
будет следить за изменением состояния надо будет следить за именем именно лонгестов там будет
типа объекция из классов лонгест очевидно отображение давайте как лонгест класса то есть
как по лонгестам восстановить класс пусть что круто как в плане все подсроки как по распихивать по
классу имеется ввиду это на завтра по сути читать под строки какие-то вот я хочу для каждой под
строки по девко на классик вероятности лежит поэтому пусть известные все лонгест как определить
от кота в где вы под строка с очень просто обращаемся к этой прекрасной картинке видим
что у нас лонгесты ссылаются друг на друга с офисными ссылками поэтому давайте найдем среди
лонгестов ведем отношения пейджа быть суффиксом тогда получится ну не очень интеллектуальная
картина и что у вас получается вас какой-то суффикс огромный да очень огромное слово
лонгест дальше вы рассматриваете все возможные слова которые вам даны в множестве лонгестов
и выбирайте то которое самое длинное и суффикс этого и проводим такое ребро то есть можно сказать
что мы на на всех лонгестах строим граф где ребро у нас проводится когда одно из них
является суффиксом другого и нам останется лишь выделить и покрыть тот граф путями все то здесь
вас вот какие-то суффиксы дальше у вас есть вот это вот один класс дальше у вас есть еще класс
вот и раз если смогли так себе лонгесту порядочить такие цепи там будет дерево на
цепи но это не очень важно по-моему там будет дерево с усылок вот если это будет дерево значит
вы смогли их упорядочить так вот по иерархии все значит вы все подсроки можете теперь понять в
какой какой вот такой класс их распихивать будете здорово давайте построим пример автомата для
так давайте выпишем все подстройки разные и раскидываем их на классы эквивалентности
срок здесь очень много а бы а бы а бы а бы а бы а бы а бы а бы вроде бы больше
них вонят всех назвал давайте распихивать по классам эквивалентности а бы а бы может
лежать только их какие-то суффиксы то есть первый класс вот а бы а бы будет
бы а бы это первый класс вот потому что следующий суффикс а бы он уже будет у него будет другой
кончик с правой у нас будет а бы и что еще видимо бы потому что чтобы я могу продолжить
право либо а бы либо пустое слово что а бы а бы правы пустое слово так это использовали это
использовали это использовали так следующий класс это а бы а будет у нас
хоть либо вместе с ним вроде бы да потому что у а бы а продолжение б и у б продолжение
б только вправо до суффикса но остается один класс а что нет это был потом был подстроен
алгоритм пока что это просто бьет дон пристального взгляда то есть я перебираю все подстройки и
смотрю правда и что у них правый контекст одинаковый будто бы если беру подстройку и
делаю ей мапу из подстройки в множество грубо говоря продолжений вот и так я делаю для каждой
для каждой вершины потом просто группирую по равенству этих мап по равенству продолжения
вот а ну еще есть конечно же легендарная штука это я поселу все-таки у нас есть пустая подстрока
давайте учитывать потому что типа корень нашего автомата будет стартовое состояние ну сюда по
букве а можно только перейти сюда по б сюда по б дальше сюда по а сюда по б вот такой автомат
получился вот сразу скажу что вы можете сказать что он неполный и это правда потому что чтобы
сделать полный я должен завести эффективную вершину провести в нее оставшиеся ребра и
они бы соответствовать ровно тому что я читаю не по строке а я говорил что нас
интересует только подстройки нас не интересует что-то что не по строке
я взял написал букву а к причитанному слову прочитал а то есть смотрите вот у меня был
эпсион если я пройду по пути до вершинки б это я должен обязательно причесть класс
то есть либо б либо а б тем дальше из каждого слова а б и б отсюда я приписываю букву а и
попадаю в этот класс для каждого слова отсюда приписываю букву в этот класс вот про то почему
это так работает чуть позже то есть графа постовка у вас такая вот ваш вход автомата
а б а б вот ну красиво причем я могу прочесть и суффикс а да а бы а бы могу прочесть а
бы а бы могу да да сразу скажу что я здесь не помечаю терминальность но ее можно этот явно
найти просто пропустив все суффиксы по автомату так дальше бы а бы я могу прочесть могу а бы
могу вроде вот такие вот терминальные состояния дальше бы могу прочесть да могу и пойду в
терминал ну всё вот а вот дома от очень то удержаются что минимальный почту что меньше
построить нельзя то есть смотрите что мы с вами наконец-то показали за себя показали что если мы
знаем все вон Чтобы мы знаем все классы квентности в общем-то к rename построить как-то
можем поэтому далее мы будем следить за руками и за онгестом почему session cassette будем нас equals
не есть классный критерии того что строка a longTreasury это вот тут вот написано
Так, что можно сказать про сам алгоритм? Алгоритм
будет очень интеллектуальным. Сначала мы вообще не будем
следить за терминальностью, мы просто в самом конце.
Вот это первое. Второе, что можно сказать, это то,
что... ну сейчас. Можно сказать так, что если у нас есть
строка S, для которой мы уже построили автомат, то
значит, мы будем дописывать одну букву и перестраивать
автомат. То есть нас будет... Давайте, мы будем отвечать
на вопросы. Какие новые лонгесты при переходе от S к SC?
Ваши ставки сколько добавят с лонгестов? Вот не больше
двух. Либо один, либо два, там по-разному бывает.
Стой, так, всё, я понял, что забыл сказать. Смотрите,
у нас было с вами критерий лонгест. И раз у нас инкрементальный
подход, то есть мы увеличиваем на единичку длину строки
и подописываем новую букву, тогда можно сказать что?
Во-первых, всё, что было префиксами, префиксами
останется, это понятно, да? Во-вторых, всё, что продолжал,
всё, для чего существовало два разных предварения в
лево, для него также будут оставаться два предварения
в лево, потому что продолжаем вправо, а не влево. А из
этого следует, что то, что было лонгестом, то лонгестом
останется. Вот, поэтому давайте здесь напишем мулевой
пункт сначала. То есть, как бы, отвечая на вопрос, какие
новые лонгесты, сначала ответим на вопрос, какие
старые лонгесты. Из критерий лонгест, тот, кто был лонгестом,
им и останется. То есть, у нас старые вершины не пропадут.
Вот, теперь, в принципе, какие новые будут. Есть по-хорошему
вопрос, как изменяются лонгесты при переходе, но, короче,
связан вопрос к этому. SC – новый лонгест по критерию. Потому что, во-первых, SC – это
префикс. В общем-то, SC – это префикс строки SC, очень
концептуальное знание. Но, во-вторых, в целом, никого
длиннее SC быть не может вообще в строке. Вот, SC раньше
входить не могла в SC, как под строка, поэтому все OK. Что теперь может быть?
Может реализоваться второй случай критерия. Пусть T – новый лонгест. Неравный SC – новый
лонгест. Давайте поймем, как он устроен. Устроен он не то, чтобы интеллектуально.
Вообще, какие у нас новые подстройки, когда написано букву С в конец? Ну, только суффиксы
добавились. То есть, вы когда написали SC, у вас новые подстройки – это что-то, что просто суффикс SC.
Поэтому пункт A, T – это суффикс SC, потому что должна быть какая-то, видимо, новая подстрока или что-то
такое. Потому что, если это не суффикс SC, значит оно должно было быть лонгестом еще здесь,
потому что мы уже это рассматривали ранее. Так, пункт B.
Давайте поймем, что если T – это суффикс SC, то все остальные… Так, T – суффикс SC. Давайте,
что дальше нужно сказать? Если T – это новый лонгест, отличный от SC, то T должна быть под
такой S изначально. Сейчас я это поясню. То есть, смотрите, T – это суффикс SC, и при этом мы должны,
чтобы он раньше был. Да, смотрите, то есть, здесь все верно. Если T – это суффикс SC и не префикс,
потому что T не равно SC, и T – это новый лонгест, значит у нас верна вот эта вот часть критерия. Значит,
если T раньше не была лонгестом, то есть, она только сейчас стала, это значит, что у нас должно было
получиться найти новое вхождение. То есть, у нас, допустим, все были альфа-Т, теперь добавилась бета-Т.
Вот, поэтому T раньше была подстрокой. Нет, у вас добавилось… Включилось слово, что здесь критерий
лонгест про то, что у вас слева дописывается буква. То есть, вот у вас вхождение Т были какие-то,
раз T – это новый лонгест, да? Раз T – это новый лонгест, значит Т начала заново как-то входить в строку,
поэтому появится первый пункт. И перед ним стоит бета. Но при этом у вас, чтобы реализовался критерий
лонгеста, у вас должно быть второе вхождение Т, причем это не в SC, а именно в S, потому что вот
вхождение Т как суффикс SC. Значит, он входит изначально в S, быть может, много раз. Вот она,
ваша Т. Но при этом здесь везде стояла буква альфа всегда. А тут у вас добавилось снова Т,
которая заканчивается на эту букву С. Но перед этим вхождением бета. Вот он, этот новый лонгест,
который может быть. Значит, следующий шаг наших рассуждений, что, причем смотрите,
это значит, что если у меня добавилось вот такое вхождение, и раньше его не было, значит,
бета Т не под строка S. Раз добавилось новое вхождение,
новое вхождение, это следует, что бета Т не под строка S.
Из этого следует, что раз бета Т не под строка S, все суффиксы SC,
длины большей, модуль T, они не были под строками SC. Потому что если у вас бета Т не была под строкой,
то и подавно все больше суффиксы не были под строками S. То есть, по сути, что нас интересует?
Нас интересует самый длинный суффикс, который уже был под строкой. Такой суффикс T самый длинный,
который уже был под строкой. Вот такое вот нас дело интересует. Понятная идея?
Самый длинный. То есть, если такой T существует, то он установлен вот так вот, как самый длинный суффикс,
который под строка S. Почему? Потому что длиннее быть не может. Мы взяли самый длинный, который под
строка S. Все остальные не являются под строкой, а значит, входят в класс SC. Теперь надо понять,
почему все, кто короче, не являются лонгистами. Раз T под строка S, значит, все суффиксы – это тоже
под строки S. Очень тривиальное замечание. У вас здесь все поменьше, они все являются суффиксами.
Но при этом, если бы у них существовали разные предварения в исходной строке S, значит, она была бы
уже лонгистом. Но в лонгистом она стать не могла. То есть, никто короче T стать не может. И поэтому
у нас ровно два варианта. Либо у нас, точнее, вот этот всегда обязательно, а вот этот вот T – она
реализуется. То есть, если она реализуется, то это самый длинный суффикс SC, который под строка S.
Пока что мы еще не умеем определять нормально, реализуется ли вот этот случай. Но пока что нам
это и не нужно. Мы просто поняли, что у нас не очень много новых лонгистов появляется, значит, у нас
не очень много новых классов появляется. Тем более, раз у вас тут каждый шаг не более двух
состояний добавляется, то у вас будет 2 на длину строки минус 1 число состояния в автомате. Не больше
чем. По индукции доказывается. На самом деле, самое сложное рассуждение мы проделали. Все дальше,
все будет проще. Это было самое сложное – понять, что их всего два. И последнее утверждение,
которое надо доказывать перед тем, как к алгоритму переходить. Устройство переходов в вершину.
Пусть рассмотрят такие вот состояния у 1, 2 и так далее, у к или строки. У порядочные по длине
лонгиста имеется в виду. То есть уитов – это лонгист в своем классе. На самом деле, не важно,
потому что сейчас будет проект, на что я хочу. Из уитова есть переход в.
Есть переход в. Что тогда можно сказать? Тогда можно сказать два факта. Все эти переходы по одной
букве. То есть у вас уитый. Переход по одной букве С в вершину В будет. Но это плюс-минус
тривиально. Второе – чуть-чуть ныне тривиально. Что это такое? То есть я утверждаю, что когда
вы переходите в новую вершину, то есть у вас что будет? То есть у вас есть такая картина.
Давайте так. Это будет у1, в дальше по суффиксной строке у2, в у3, в
в. То есть я утверждаю, что когда вы дописываете новую вершину, у вас как-то вот так все будет
устроено. Сразу скажу замечание. Заметим, что у нас был суффиксный путь, он слопнулся в одну вершину.
Вот. Это нам будет важно при оценке асимптотики. Мы будем следить за длиной суффисного пути.
Но это будет уже, наверное, на следующей лекции оценка асимптотики. Все-таки мы не успеем сегодня,
наверное. Так, давайте доказывать. Ну часть первая, она очевидна. Все слова из В заканчиваются на
букву С. Но ребро по автомату, это значит просто дописать одну букву. То есть смотрите, у нас
здесь какое-то слово было в каком-то из этих состояний. Мы к нему дописали С и получили
слово отсюда. Ну не знаю, ПИТ. П лежит в каком-то УИТ. Тогда ПС лежит в В. Мы уже дописали просто
букву С по определению толка с ребра в строенном автомате. Короче, я даже не знаю, насколько это
нужно написать, потому что это, вроде, совсем очевидная материя. Или нет? Надо чуть-чуть расписать
все-таки. Ладно, вы уже умерли, видимо. Все слова из В заканчиваются на букву С. Из этого следует,
что для получения слова из В надо к П, принадлежащему УИТе, дописать в конец С.
Еще более вместить ту кашу не хочу. По-моему, второй чуть-чуть интеллектуальнее. В этой вершине
это классика вероятности. Все. То есть у нас вершина соответствует классику вероятности. Как мы
строили вон там на доске, у нас классика вероятности это вершина в автомате, по сути. И слова из В
значит, это просто слова, которые можно прочесть, придя, ну, сделав путь в автомате. Да это вершинки
из корни. Что? Согласен, надо окно открыть. Это, конечно, глубокое замечание. Ладно, теперь
давайте доказывать это. Давайте посмотрим на то, как устроен В, вообще сам по себе. До этого
я сотру эту картинку и нарисую другую. Нет, ладно, я лучше сотру с этой доски все и нарисую картинку,
потому что там будет большая. Да, вот вы думаете, что надо понимать глубоко эту теорию, я вам сразу
скажу, что нет. В принципе, для решения задачи вам не нужно это знание вот этого всего. Для решения
задачи вам нужно будет написать код в 40 строк. Да, в качестве автомата 40 строк пишется, я сразу
говорю. Вот такая вот огромная штука, 40 строк занимает всего лишь. И под ревью тоже, он настолько
простой. То есть там типа надо два часа теории и 15 минут написать его. В смысле под ревью у вас
нет требований, вы что, я вам не прислал, я специально сказал, что вы уже взрослые ребята и должны были
научиться правильно кодить. В смысле, нет, надо писать абстрактный код слофовит сначала, вот что.
Причем от него отнаследовать неупорядочно и упорядочно флоид. Можно шаблонным параметром
передать. Вот. Ну тогда и нужно создать картеж, но для этого есть просто спан, который хранит
атеративные объекты. Используйте спан над алфавитом, получите строку. Ну ладно, это так, будни
программистов, мы сегодня математики. Вот, я утверждаю, что класс В выглядит как-то так.
Но здесь надо многоточие поставить, но я утверждаю, ну я хочу вот так вот закончить. Тут может быть еще
что-то. Может быть дальше суффиксом написано. В это же не все суффиксы, в это какие-то суффиксы.
Давайте рассмотрим наши строки без У, без С, точнее, без последней буквы.
Так, по длине нарисовать.
Так, кстати, в формалках есть два метода доказательства. Это формальный вывод написать
со отношением выводимости, а есть метод доказательства картинкой силы убеждения. Вот я сейчас буду пользоваться вторым.
Ну нет, елочки это по картинке как раз, метод убеждения.
Получается так. То есть, смотрите, это лонгестат У1.
Вот рассмотрим класс У1. Заметим уже, по сути, что мы переходим в те же самые, вот так вот отделяем их будто бы.
То есть, у нас вот эти вот строки, это вот так вот классы строим.
Ну это, думаю, понятно, да? То есть, я просто ко всем этим строкам приписал букву С и получил строки из В.
Теперь дальше, смотрите, что. Раз у меня это единый класс эквивалентности, значит, вот эта вот штука, это суффикс вот этой.
То есть, вот эта вот штука, это суффикс вот этой, по свойству класса эквивалентности.
То есть, если я отпилю С отсюда, то эта штука будет суффиксом этой, но при этом она не входит в класс эквивалентности У1.
То есть, вот это получается у нас лонгестату 2 и по определению суффиксной ссылки она указывает вот сюда, вот отсюда.
Ну, абсолютно аналогично, дальше продолжается рассуждение.
Достаточно убедительно рукомахание получилось.
Вот с левой пластой меги начинается другое класс эквивалентности.
Да, а с правой это один тот же.
Это может комодипция на У1?
Да.
Вроде убедительно.
Ну, так можно У2, У3 построить и так далее.
А эти УИТы, все такие УИТы?
Это все УИТы, из которых есть переход в В.
В первом пункте мы доказали, что он в одной букве осуществляется.
И теперь мы с помощью этого пункта доказали, что все эти УИТы объединены тогда в такой суффиксный путь, то есть в пути суффиксных ссылок.
Ну, точнее не все, почему?
Потому что дальше у нас будет вот здесь вот суффиксная ссылка В.
Ладно, давайте я здесь вот закончу класс В, да?
То есть у нас типа У1, У2 будто бы были только.
Вот так вот.
Как у нас схематичный пунктирчик, здесь сплошная отделяет новые классы.
Но если у вас это новый класс, давайте это В1, вот это вот В1,
то вот это вот может быть В2 какой-то.
То есть сюда введет суффиксная ссылка этой вершинки.
Ну тогда у вас в этой штуке будут соответствовать новые классы эквивалентности.
То есть по сути у вас пути в автомате выглядят как?
Как какой-то ряд суффиксных ссылок здесь,
какой-то ряд суффиксных ссылок здесь.
Вот как-то вот это Carson здесь и есть classes,
а в organizing class, то есть суффикс не прит sixteen pounds.
Может быть будетCEO.
Так они здесьٹ goddess shapes Я так вот с вами полюбил.
Вот как-то вот так вот у вас устроены пути в автомате.
То есть у вас это суффиксный путь, и при выписывании буквы C будет новый суффиксный путь.
То есть здесь очень красиво, на самом деле.
Вот.
Кого?
Нет, нет. Ну так по примеру получилось.
Типа можно так написать спокойно. Это валидная конструкция будет.
Здесь вот одна вообще входит.
Так получилось.
Так, ну получается доказание в картинке.
Так и напишем метод картинки.
Кто посмотрит лекцию, тот поймёт.
Кто не пришёл на лекцию, тот не получает баллов в контест.
Вот. Так, окей.
Что теперь нужно?
Ну теперь, по сути говоря, мы готовы.
Что мы готовы с вами?
Кто с вами к линейному алгоритму?
Постояние.
Так, давайте.
У нас будет переменная last.
Она будет соответствовать текущему классовиковой варианте S.
Мы рассматриваем переходы за S в СС.
Состоянием автомата.
Так, это будет last.
А дальше что будет у нас?
Ну вроде будет всё, что нам пока что нужно.
Теперь смотрите, что нужно сделать.
У нас появляется новый лонгест СС.
Тогда как устроены ребра, ведущие в СС?
Это вместо U1 у вас берётся last.
Проводится по С, получается СС.
И дальше рассматриваются под суффиксный путь.
И вдоль него проводятся ребра по буквам С.
Давайте пока что P равно last напишем.
И шаг первый это
while нет перехода по С.
Функция tu, наша любимая,
из П по букве С
равно СС.
То есть вы создаете новый класс СС
и начинаете вот это вот делать.
Это переменная P.
Сильнее сотру,
чтобы было лучше видно.
Переменная P.
P это у нас от слова путешественник.
Она будет скакать по этому суффиксному пути.
То есть мы скачем по суффиксному пути
и ведём в СС.
То есть если у нас вот это вот
С и с ней суффиксные ссылки,
из которых нет переходов по букве С,
то мы должны построить вот эти вот переходы по С.
Просто по утверждению переходов в дешинку.
Да, сейчас минутку.
Да.
Да.
Потому что смотрите,
вам нужно найти всё,
что может вести в СС.
В СС может вести что?
То есть вам нужно рассмотреть,
то есть в СС по сути вы рассматриваете кого.
Это все пути, по которым можно пройти в СС.
Либо в классах вариантов СС.
В классах вариантов СС
это несколько суффиксов СС.
Вопрос по определению.
Что такое суффиксы СС?
Они устроены как суффиксы С с дописанной буквой С.
Ну вот.
Причём в этом классе лежат те штуки,
у которых в классах вариантов СС
у которых в классах вариантов СС
что это значит?
Это значит, что у них такой же правый контекст, как у СС.
Давайте здесь подпишу, что
RL от СС
по языку СС
от СС, правый контекст.
Он равен вот такому интересному множеству.
Из Эпсилона.
И вас интересуют все те,
у кого тоже Эпсилон.
Но это все суффиксы СС просто-напросто.
В этом классе будут лежать.
Все суффиксы СС.
А что такое суффиксы СС?
Это суффиксы из С.
Да?
При этом, раз текст пустой,
значит все вот эти вот,
кто лежат в СС,
они не должны быть под строками
вот по вот этому вот утверждению.
Не должны быть под строками С.
Это значит, что из них...
То есть из таких вот...
Сейчас.
Ну да, их значит их просто нет в С.
Вот.
Что это значит?
Это значит, что я беру все суффиксы СС.
Это устроено как суффиксы С плюс буква С.
И она не должна быть под строкой.
Да?
Ладно, я уже пошел дальше
объяснять алгоритм, случайно.
Я...
Потому что, смотрите, пока что мы рассмотрим,
пока нет перехода
из по С из П.
То есть мы идем вдоль суффиксного пути,
по букве С.
Что значит, что нет перехода по букве С?
Это значит, что
вот лонгест от этого класса
и приписать букву С
в автомате еще не встречалось.
Значит, переход был бы уже по букве С.
А если он еще не встречался,
значит у него правый контекст пустой.
То есть если мы добавим
по букве С, перейдем сюда,
то это будет правый контекст в течение пустой
из пустого слова состоять.
Поэтому рёбра восстанут.
И, собственно, это первый шаг.
И самый благоприятный случай один.
В равно ку-ноль оказалось.
То есть в стартовом состоянии.
Что это значит? Когда это может вообще быть?
Это значит, что
буква С впервые вообще была встреча
на нами.
Лучший случай
всегда был бы так.
Если, к сожалению, оно нет,
у нас была бы встречася буква С.
Это большое упущение языков.
Надо делать языки,
где все слова из разных букв состоят.
Там алфавит большой,
константа большая будет, к сожалению.
Ну, там язык динамический вообще штука.
Она развивается, растет.
И там тоже может алфавит расти.
Я думаю, новые уроглифы там придумываются
иногда.
Ладно.
В равно ку-ноль. Из этого следует,
что ура,
победа.
Ура, победа, потому что больше
ничего делать не надо.
Осталось, давайте поймём, что нам нужно теперь
проставить.
Нам нужно понять,
кто такая суффиксная ссылка СС.
Ну, раз П равно ку-ноль,
то С вообще впервые встречается.
Из этого следует, что
линк от СС
равно ку-ноль просто-напросто.
В этом случае новый
лонгест не будет появляться,
потому что у вас не было такого,
что у вас под строка.
Что у вас суффикс СС стал подстрокой.
Потому что у вас из всех суффиксов С
нет перехода по С.
И это классно.
Это прям вин-вин ситуация.
Ещё мы обещали
сами поддерживать лен.
Это длина лонгеста,
если кто забыл.
Потому что сами лонгеста мы нигде не поддерживаем
по памяти.
Мы только
храним лена.
Длина СС
или же
лен от
ласта плюс один.
Конец новых состоений добавляется.
Всё мы про это состояние узнали.
Переходы узнали. Вообще шик блеск.
Случай второй.
П не равно KU 0.
Это трагедия.
Почему это трагедия?
Потому что это следует, что есть
По букве С в какую-то Q.
То есть какая картинка здесь?
по букве C в какой-то Q. То есть какая картинка здесь?
Это S, это P, вот ваша SC. Вы действительно провели сюда ребра по C, и тут выяснилось,
что у вас есть переход по C в Q. И вот это плохой случай, но не совсем плохой.
Сейчас он будет снова биться на два случая. Это последнее разбиение, больше не будет.
Вот два случая осталось разобрать, которые лежат в случае 2. Это когда будет появляться новый
лонгест, когда не будет появляться новый лонгест. Теперь самое интеллектуальное.
Вот что у нас получается. Тогда T это кто такой? Это суффикс SC подходит? Подходит.
T под строка S. Потому что у нас уже был такой переход. То есть у нас самый длинный суффикс
SC, который под строка S такой существует. То есть T это лонгест от P плюс C. Согласны?
Мы нашли такой самый длинный суффикс SC. Понятная идея? Просто по определению того,
что такое T у нас в этом случае. Это самый длинный суффикс SC, который под строка S так и есть.
То есть это самый длинный суффикс S. Но при этом еще мы добавили к нему C. То есть есть подстрока
такая. А Q существовал раньше, до добавления SC, поэтому это под строка S. Что тогда нужно сказать?
Тогда нужно понять, нужно ли расщеплять здесь. То есть будет ли новый лонгест. Что значит,
что T новый лонгест? Если T равно лонгест от Q, то что это значит?
Это значит, что нового лонгеста не возникло. У вас уже был лонгест от Q. Новый лонгест не
возник. То есть вы нашли вот такую T, и она уже была лонгестом. То есть нового лонгеста не возникло.
Нового лонгест не возникло. Как проверить вот это вот? Проверить очень просто.
То есть если у вас верно вот это равенство, значит у вас верно, что вот эта вот T-шка
оплена вот так вот, это лонгест Q. Все. Значит, нового лонгеста не возникло. Значит, что нужно
сказать тогда? Ну, Лен от СС понятно, он всегда будет вот таким вот. Надо понять, кто такой линк от СС.
Ну, конец. Этого случая вообще все, он обработан. Потому что дальше у вас есть переходы по ценой
в суффиксном пути. То есть смотрите, что у нас здесь происходит. В этом случае мы сжимаем просто
суффиксный путь в один. Точнее, даже не так. Мы здесь никаких новых ребер проводим,
только вот эти новые ребра. Вот. И поэтому если были бы только эти два случая, то линейность алгоритма
следовала бы из того, что у нас линейное число ребер в автомате. Это правда, доказывать мы это
не будем. Это сложная сиарема, что число ребер в автомате не больше, чем 3 на длину строки минус 4.
Ну да, такая хитрая оценка. Я даже нигде нормального доказательства толка не нашел.
Просто есть где-то в оригинальной статье существует. Ну и последний случай, это когда нам
нужно расщеплять, когда у нас появился новый лонгест. Так. Последний случай. На этой доске разберем.
Так. Случай 3. Это p не равно q 0. Из этого следует, что есть из p переход по c в q. И лен от p меньше,
чем лен от q минус 1. Ну понятно, что больше он быть не может. Что тогда происходит? Ну это значит,
надо расщеплять состояние автомата. Сейчас будет большая картинка, и потом будет пояснение. Так.
Это наша s. Суфиксная ссылка, суфиксная ссылка, суфиксная ссылка, суфиксная ссылка. Еще суфиксная
ссылка. Ну и еще одна. И, наверное, последняя. Я думаю, столько хватит для картинки. Так. Это наша c.
Но я предположу только по двум, чтобы у нас было больше места здесь для рисования. Вот есть наш
классный чувак q, которого ведет ребро по c и с p. Но при этом у нас появился новый лонгест. Это
трагичная история. Тогда создается вместо q две вершинки. Создается q, создается клон. Ну так ее будем
называть. А мы при этом q, это будет, давайте линк от q обзовем вершинку. Она нужна будет еще тоже
для анализа. Вот такой у нас красивый пассион сложился. Теперь надо понять, что вообще происходит
здесь. Давайте подумаем с вами о том, чем отличается правый контекст с и правый контекст q. Точнее правый
контекст q от нового лонгеста. То есть нас интересует rsc от q, rsc от pc. Давайте последний случай,
давайте. Хотите расскажу, если вам не сложно держаться на 5-10? Если нет, то тогда в следующий раз
останется. Как хотите. До свидания.
