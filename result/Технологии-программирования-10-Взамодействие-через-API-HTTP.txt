Всем доброго дня, мы с вами продолжаем изучать наш курс, и сегодня у нас вторая часть ипопеи
«Просите вы взаимодействие». Сегодня мы с вами пойдем на уровень чуть выше, да, и наконец-таки
рассмотрим, как работают разные HTTP-серверы и вообще, как устроены большие системы между собой,
как они между собой взаимосвязаны. Я не знаю, честно, у кого-то из вас уже был курс по питону,
у кого-то он сейчас идет. Уговорите. Да, хорошо. Рассматривали ли вы там Flask или нет?
Видимо нет. Flask. Библиотека такая. Окей, ну ладно, если что, тогда я просто сегодня тоже покажу это
все дело, чтобы у вас было некоторое знакомство, потому что сегодня мы будем говорить как раз в том
числе и про Application Programming Interface. Итак, давайте вот мы с вами остановимся, вспомним,
что у нас было в прошлый раз. В прошлый раз мы с вами сказали, что у нас есть сетевой стэк,
у нас есть какие-то примеры взаимодействия по всему стэку. Более того, мы с вами понимаем в
случае того, что если мы находимся в одной сети, то в принципе мы с вами можем подключиться к
одному компьютеру в той же самой сети. То есть это все происходит на уровне IP протокола. Дальше
мы можем настроить протокол на транспортном уровне. Это у нас либо TCP, либо UDP. Мы с вами
смотрели Wireshark. И дальше нам нужно идти в... Мы начали рассматривать прикладной уровень,
и кажется мы с вами в прошлый раз разобрали то, что когда мы с вами должны отправлять запросы по
HTTP, то нам нужно отправлять заголовок под названием host. Я, кажется, показывал пример,
что подменив заголовок host мы с вами можем из одного сервера по одному и тому же IP адресу
достучаться до разных приложений. И теперь давайте поговорим про то, каким образом процессы
могут между собой взаимодействовать. У нас есть два процесса. Мы с вами так или иначе поняли,
что они между собой могут общаться через сокеты. То есть это если у нас есть сетевые взаимодействия,
мы ставим сокет по одной стороны, сокет с другой стороны, и они начинают друг друга связываться.
Только маршрут, который проходит между этими сокетами, он достаточно длинный. То есть он может
проходить в принципе в другую точку земли. Но на самом деле мы можем попробовать взаимодействовать
с процессами немножко по-другому. И давайте как раз попробуем рассмотреть эти способы.
Первый способ взаимодействия через файл. У нас есть какой-то процесс A, у нас с вами есть процесс B,
и каким образом они могут попробовать взаимодействовать между собой через файл. Объект A допустим.
Сейчас буду рисовать. К сожалению у меня немного рука повреждена, поэтому возможно буду стирать
все немедленно. Давайте я буду стирать все-таки левой рукой. Итак смотрите, у нас есть с вами
процесс A и есть процесс B. Нам нужно чтобы процесс A передавал какую-то информацию процессу B через
файл. Значит каким образом это можно организовать? На самом деле можно сделать какую-то папку. Папку,
которая называется взаимосвязь между сервисами. Ну и дальше смотреть на содержимое этой папки.
Каким образом можно смотреть на содержимое папки? Мы просто смотрим, грубо говоря, создаем файлы типа
slash 0, slash 1, slash 2, slash 3 и допустим способ общения между процессами. Откуда-куда этот
процесс взаимодействия идет. То есть, грубо говоря, наш процесс начинает обмениваться сообщениями.
То есть здесь мы говорим, что в нулевое сообщение A отправляет B, потом первое сообщение B отправляет A,
ну и так далее. Собственно как каждый из процессов потом может понять, что ему пришло сообщение?
У кого есть мысли? Да, ну посмотрите на последний ID, который прилетел и сказать, что это за, что это за
процесс. Но правда здесь нет механизма нотификации определенного процесса, но в принципе это можно
позволить средствами операционной системы. То есть Unix-like операционные системы имеют как раз механизм,
который позволит получить процесс от сеть на файл. Как вы думаете, в чем недостатки этого подхода?
У него есть на самом деле один большой недостаток, что, во-первых, у нас только два процесса могут
взаимодействовать между собой и если какой-то процесс A запустился допустим не один раз, а два
раза, то все пойдет по одному месту. Потому что мы не можем обрабатывать это все в параллельном
режиме. Вот, и если мы говорим про распределенные в хранилище, то есть про хранение более чем одного
узла, на самом деле такая концепция поддерживается. Вот, и вот современные экосистемы, которые
обеспечивают как раз координацию между большим количеством узлов, работают приблизительно под
протоколом. Значит, я сейчас грузить этим не буду. Давайте я примеры просто скажу, кто по такому
протоколу работает. По такому протоколу, во-первых, работает ZooKeeper, который осуществляет координацию
между узлами в кластерах, которые обеспечивают хранение больших объемов данных. А вторая экосистема,
а второй инструмент тоже достаточно популярный, это инструмент ETCD. Значит, он необходим для
аркистрации контейнеризированными ресурсами. То есть вы на семинарах уже начали проходить
докер, поэтому, наверное, вы понимаете, что контейнеризированные приложения зачастую те,
которые запускаются в докер-контейнерах или в аналогичных им контейнерах. Вот, то есть они как
раз общаются таким образом, только чуть более умным для того, чтобы обеспечить распределение более
чем одного процесса. Значит, это первый способ. Он такой самый простой, но при этом у него есть
недостатки, но, в принципе, его можно допилить, если мы будем использовать примитивы сихронизации.
Значит, второй способ через API. Что такое API? Это Application Programming Interface. То есть мы с
вами по факту должны придумать какой-то интерфейс, который позволит отправлять запросы по определенному
адресу. И как раз один из примеров использования API это как раз поверх протокола HTTP. Они зачастую
используются, но не только поверх протокола HTTP. Про это мы будем чуть дальше говорить. Значит,
какие плюсы и минусы? Плюсы есть, возможно, взаимодействие по сети. Минусы все-таки нужно
будет разрешать проблемы сихронизации тоже. Третий способ это у нас есть два процесса,
и они общаются между собой через некоторую базу данных. То есть на самом деле база данных тоже
между собой представляет сервер. Этот сервер достаточно большой по вместимости. И при
помощи к нему обращаются при помощи специального языка. Обычно этот язык называется structured query
language, он же SQL. И как раз когда мы обращаемся с вами при помощи SQL, мы можем отправлять некоторые
запросы для того, чтобы получать какие-то результаты. Значит, опять же, тут нужно сказать,
что SQL базы данных могут быть разного уровня. Это может быть файловая база данных. Допустим,
к примеру, файловая база данных относится с SQLite. Потому что мы с вами загружаем информацию из
файла. Есть серверные поставки, такие как MySQL, PostgreSQL, Oracle и так далее. И тогда как раз в чем
есть проблема всех этих баз данных, то что их надо правильно настраивать. Если вы их неправильно
настроите, то могут быть всякие разные проблемы. Если мы говорим про большие приложения, в этом
есть определенная проблема. Возможно вы видели, что Ahcheck в некоторых моментах очень долго грузят.
Не Ahcheck, по крайней мере GitLab. Он может действительно долго грузить. Это связано с тем,
что баз данных не справляются с обработкой запросов. Вообще, по идее, про баз данных должен быть
отдельный курс. Я не знаю, у кого когда он будет. В целом, это тоже важно понимать, что это способ
взаимодействия процессов. Но фишка в том, что все вот эти вот способы взаимодействия пока что
являются синхронными. Про это чуть позже расскажу, что нам нужно дождаться результатов наших запросов.
То есть мы отправили, допустим, запрос на обновление данных. Нам нужно дождаться то, что наши запросы
действительно исполнятся. То есть мы не можем делать дальнейших действий до тех пор, пока мы с
вами не получим результат. И это все будет очень сильно тормозить. Наверное, вы видели,
когда вы загружаете что-то на сайте, у вас бывает такое, что я гружу страницу, я гружу страницу,
я гружу страницу. А на самом деле под капотом у вас происходит какой-то запрос, связанный с базой данных.
Тоже могу пример показать, если он интересен. И последний способ, это на самом деле то,
как устроены все нормальные системы данных, высоконагруженные системы. Все взаимодействия
происходят зачастую через очередь сообщений. Значит, смотрите, тут нужно сразу сказать,
что это не классическая структура данных вида очередь. Она имеет похожую суть, но немножко с
некоторыми разными возможностями. То есть у нас по факту что может сделать? У нас процессор A может
положить какое-то сообщение в очередь. Значит, что такое сообщение? Это какой-то запрос на выполнение
каких-то запросов с какими-то данными. Дальше что у нас происходит? У нас есть какой-то, он
отправляет его куда-то, непонятно куда. А дальше, значит, есть процессы, которые могут обработать
этот запрос. То есть представьте себе, образно говоря, кейс, вы отправляете запрос через
госуслуги какой-нибудь. У вас сразу выполняется? Ну или через какую-то другую систему? Или вы
делаете заказ какой-нибудь в интернет-магазине? Что с ним происходит? Вам просто отправляется письмо,
что ваш заказ был получен в системе. А дальше у вас в фоновом режиме начинают эти заказы
обрабатывать. То есть, грубо говоря, первая обработка идет в фоновом режиме, и вся большая
часть обработки как раз уходит в фоновый режим. Давайте, опять же, далеко не отходя, пример системы
по отправке домашних заданий рассмотрим. Вы когда отправляете посылку, что с ней происходит? У вас
браузер висит или нет? Нет, браузер не висит, все отправляется, все происходит в фоне. После того,
как задача обработалась, вам может прийти либо уведомление на почту, либо еще куда-нибудь.
То есть, либо на сам сайт. То есть, вы не видите того, что происходит под капотом. И тем самым вы
отвязываете как раз ваше приложение от контекста исполнения. То есть, это все находится в отдельно
фоновом режиме. И на самом деле, когда вы заходите в любую большую экосистему, будь-таки Янекс,
Гугл, Лазон и так далее, на самом деле там огромное количество очередей под капотом. То есть,
у нас есть какое-то приложение, какой-то процесс, который на самом деле может слушать какой-то
запрос и перенаправлять его в другое место. То есть, представьте, у нас есть пользователь,
который что-то запросил, допустим, музыку Вконтакте. Соответственно, ему идет запрос,
он отправляет запрос, я хочу послушать музыку. Этот запрос отправляется в отдельную очередь,
дальше пользователи снова обрабатывают, достают этот запрос из очереди на загрузку трека,
допустим. После этого, собственно, в каком-то режиме у вас начинает просушиваться трек,
но сообщение, на самом деле, из одной очереди перекочевывает в другое, для того,
чтобы вам плейлист построили в будущее. То есть, у вас же не сразу плейлист музыки отрисовывается,
типа какие треки будут дальше. Они могут отрисоваться чуть позже и прийти чуть позже.
Вот, тем самым как раз взаимодействие всех процессов через очередь, это на самом деле
самый универсальный способ, каким образом можно отвязать контекст исполнения. Чем еще
удобна очередь? Она хранит все сообщения, и если, допустим, у вас произошла какая-то ошибка,
то, в принципе, все эти сообщения можно будет обработать снова. А не так, что,
ой, извините, ваш запрос выполнил неуспешно, пожалуйста, повторите его позднее. Обычно могут
написать, что, типа, вот, ваша заявка вот такая вот, и вообще, смотрите, в чем это удобство. У вас
было такое, что когда-то сайт не работает, какой-нибудь. Обычно, если сайт правильно
настроен, то у него бывает... Ваншопсайта произошли неполадки, вот ID-шник вашего запроса. Вы можете
обратиться к ним в службу техподдержки, они пойдут, посмотрят в очередь, в брокер,
который обслуживает это все дело, и скажут вам, типа, ну вот, у нас такой запрос, мы его обработали
успешно, либо вот возникла такая ошибка, мы его перезапустили. То есть, этот запрос все равно
сохраняется. Именно с теми параметрами, которые происходят. То есть, вот способы взаимодействия,
первые три способы взаимодействия между процессами, это прямые способы взаимодействия,
а четвертый способ не прямой. Значит, давайте скажу так, что мы с вами посмотрим, наверное,
сегодня наша цель акцентироваться именно второй способ. Вот, если у вас, допустим, будут вопросы по
третьему способу, тоже можем их разобрать, но обычно это делается в курсе по базам данных,
ну а четвертый это уже чуть более далекая история. Но хотя принципы, на которых они работают,
мы тоже посмотрим. Так, хорошо, давайте вопрос по этой части. Понятно?
Ну обычно очереди умеет обрабатывать до миллионов запросов в секунду. Ой, ну до миллионов в минуту,
да. Вы на самом деле, давайте попробуем следующий эксперимент. Мне он нравится. Я сейчас прямо в прямом
режиме. Сколько у нас? 11.01 по часам, да? Где у нас чат? Так, я сейчас запутаюсь. А, нашел.
Так. Все, я сделал эксперимент. Значит, я не знаю, получится он или нет, но скорее
все получится. Значит, я сейчас в чате обсуждения материалов лекции отправил отложенные сообщения
на 10 минут вперед. Посмотрим, во сколько придет оно. Ну вот, вот она и задержка до минуты. То есть,
пока у нас очередь обрабатывает сообщения, у нас появляются задержки, но в целом они не критичны.
Вот. Обычно, кстати, давайте подумаем, в какие моменты времени можно увидеть большую задержку?
Ну с утра, во-первых. Более того, в ровные часы. То есть в 9.00, в 10.00, в 11.00, в 12.00, в 13.00. Понятно, по какой причине?
Все просто хотят отправить сообщение, чтобы в 9.00 утра оно пришло. Вот. То есть, вот такой механизм.
Сейчас посмотрим. Кстати, возможно оно в ту же минуту придет. Вот. Вот так вот работают очереди
сообщений. То есть, они пытаются разослать необходимым пользователям необходимую информацию.
Вот. То есть, отложенная отправка, она тоже реализована через очередь. Так. Так, еще вопросы?
Хорошо. Давайте двигаться дальше. Значит, перейдем мы с вами к Application Programming Interface.
Что такое Application Programming Interface? Это договор, в котором говорится, какие команды принимают
некоторые сервис и в каком формате передаются данные. На самом деле, когда вы делали задание
по тестированию, вы уже познакомились с одним Application Programming Interface. Это был Application
Programming Interface с сайта AccuWeather. Давайте попробую даже зайти в него. Вот оно. Вот оно, API.
Да. Значит, у меня разлагинились, но в целом мы с вами видим, что в нем есть. Значит, это пример
классического API. И вот здесь как раз мы можем с вами увидеть запросы. Значит, здесь сразу скажу,
что API использует протокол REST, Representational State Transfer. Про него чуть позже. И у него есть
определенная спецификация. То есть, у него есть метод. Это как раз HTTP-метод Get. У него есть
название нашего метода. То есть, у нас с вами есть метод URL, по которому мы отправляем. Дальше у
него есть типа под папочка. Дальше внутри нее есть, допустим, версия API. Название того сервиса,
в которое мы с вами идем. А там ничего не видно, да? Черт. Так. Наступает технология настройки
проектора. Все. Магия. Да, я смотрю, что ничего не видно. Значит, смотрите. Вот это адрес,
доменное имя по сервису. Дальше это название большого сервиса. Дальше это версия. Версия API
ее можно переключать, допустим. Если у нас будет новая версия API, это будет V2, V3, V4 и так далее.
Дальше у нас с вами есть информация о том, что это у нас admin.rs. И дальше,
вот видите, country-код. В фигурных скобочках те, кто знаком с Python,
возможно, понимают, что это за аннотация. Это аннотация для F-литералов, либо аннотация для
метода формат. То есть, вы дальше в эту строку можете подставить переменную country-код. Какое-то
значение country-код. Вот. И давайте посмотрим, кстати, запрос на country-лист. Вот. Вот он,
запрос. И нам вот здесь отдают формочку. То есть, сюда мы можем ставить ключ API,
он нужен для авторизации, и указать язык, в котором мы должны вернуть наш запрос. Ну и после этого
мы выполняем какой-то запрос и получаем ответ. Вот. Собственно, то же самое у нас происходит и в
браузере. Значит, как это все можно достучаться? Этого всего можно достучаться при помощи браузера,
который отправляет все сообщения в виде HTTP через протокол HTTP. То есть, это hypertext-transfer
протокол. Значит, и здесь как раз у нас есть информация о запросе слева. А второй, это тот
payload, который мы с вами отправляем. Это называется телозапрос. То есть, некоторые виды запросов,
методы запросов позволяют нам отправлять тело запроса, некоторые методы не позволяют отправлять
тело запроса. Давайте рассмотрим, какие методы бывают. Да, сначала давайте начнем с того, что должно
быть в HTTP запросе. Значит, первое, что в нем должно быть, это метод, адрес и версия протокола. Сейчас
наиболее современная версия протокола это HTTP2. Дальше мы должны отправить заголовки и тело
запроса. И давайте как раз посмотрим, какие методы у нас бывают. На самом деле, есть четыре
основных метода, и есть еще некоторые дополнительные методы, которые можно специфицировать. Есть метод
get, который позволяет нам получить какую-то информацию. Второй вид запроса, это запрос вида пост. То есть,
мы можем с вами отправить пост запрос. Обычный запрос пост, это на отправку новых данных. То есть,
вы хотите взаимодействовать с сайтом, вы должны внести какие-то новые данные. Это
делается обычно через пост запрос. Значит, третий запрос, это пут запрос. Представьте себе,
что у вас было какое-то уже поле, там собака-кошка, и вы, допустим, хотите этой собаке сделать
кличку, задать какую-то кличку. Тогда вы берете вот этот полностью объект вашего пса или вашего
кота и полностью отправляете все результаты. То есть, вы именно отправляете всю информацию и
ее обновляете. Если вам нужно обновлять не всю информацию, то для этого обычно используют метод
patch. То есть, добавить какие-то атрибуты. Как вы думаете, для чего предназначен запрос метод
удалить объект? Да, удалить объект. То есть, это нотация на удаление объекта из баз. То есть,
помимо того, что вы можете задать URL, вы можете задать разные методы на эти URL. И заголовок
вида options является специфичным. В нем можно получить определенный объект. То есть, закаширован
у вас объект в базе или не закаширован. То есть, нужно ли вам возвращать страницу сайта или не
надо. Вот. И саунд обычно идет через HTTP запрос. Значит, если мы сейчас с вами пойдем на то же
самый наш сайт, давайте я сделаю вкладочку инспект. И, кстати, отключу кеширование. Так,
сейчас посмотрю. Да, я включу кеширование. Вот, видите, у нас есть вот запрос вида options. То есть,
вот он запрос вида options. Вот. И говорит это. Собственно, в нем определяются, какие мы с вами
заголовки можем отправлять. То есть, это информация о сервере, который мы с вами запрашиваем. То есть,
ее можно использовать для разных целей. Вот. Значит, в этом запросе, что у нас обычно есть в HTTP
запросе? У нас в HTTP запросе есть следующая вещь. Значит, мы с вами, первое, что делаем,
это отправляем URL. Вот, видите. Вот здесь. Дальше метод у нас называется options. А, это мы даже
специально отправляем запрос. Дальше мы у этого... Дальше что у нас происходит? У нас отправляют
заголовки запросов. То есть, мы их там можем отправлять в следующий момент. Значит, что мы здесь
можем сказать? Мы говорим, что мы можем принимать файлы определенного формата. Это называется
meme-type. То есть, мы говорим, что мы готовы принимать файлы определенного, разного формата. После этого
у нас есть информация о кодировании. То есть, на самом деле, странички в интернете приходят не в
чистом виде, а в пережатом виде. Как вы думаете, зачем это сделано? Да, они весят меньше. То есть,
вы можете сделать гзип про определенную HTML страницу и увидеть, что он эффективно
пережимается. Значит, дальше здесь еще один заголовок, интересный браузером, отправляется.
Accept language. Здесь, допустим, у меня accept language NUS стоит. Это по факту приоритет того,
с каким языком мы с вами работаем. То есть, у меня видно язык системы английский, и поэтому у меня
браузер отправляет английский язык. Да, правда, это нужно обрабатывать сайту. То есть, сайт должен
разобрать этот заголовок и, в принципе, выдать мне англоязычную версию. Но этого не происходит.
Вот, дальше, значит, здесь у нас отправляется еще вкладочка origin и refer. Зачем это нужно? Это
нужно для защиты сайтов. То есть, чтобы у вас запросы, которые идут, шли не только с сайта этот,
грубо говоря, с определенных сайтов. Чтобы запросы других сайтов не проходили. И, по-моему,
вчера на семинаре группы показывал, что будет, что если я в командной строке правильно запущу
этого Ахчека, будет очень весело. То есть, я смогу по факту вот этот вот веб-интерфейс подключиться
к нему и использовать его как реальный сайт. Вот, то есть, здесь указывается Ахчек.ру и на сайте,
тоже, собственно, на самом сервере, на котором мы получаем информацию, там в списке разрешенных
адресов стоит Ахчек.ру. Этот адрес не подменяется через браузер. Точнее, его можно подменить,
но не таким простым способом. Значит, и дальше вот важное, что у нас отправляется, у нас
отправляется вот такое поле под названием user-agent. К чему оно соотносится? Она на самом деле показывает,
первое, что она показывает версию операционной системы. Какая у вас операционная система? Дальше,
у вас показывается движок, который поддерживается. И дальше указывается версия браузера. То есть,
вы не поверите, у всех у нас по-разному эта версия браузера будет отображаться. То есть,
вы тоже можете пойти и посмотреть, поисследовать. Вот, и на самом деле, как вы думаете, каким образом
этот можно user-agent использовать? Запрос. Ну, давайте сделаем очень простую вещь.
Да, видите? Как оно поняло это? Оно разобрало заголовок, которые мы отправили.
Сейчас, давайте посмотрим, кстати. Да-да-да, давайте посмотрим, что он парсит.
Вот тут запрос. Якуки пропалил все свои. Платформа МакОС.
Ну, тут надо посмотреть. Возможно, где-то еще дальше в следующих запросах идет.
Тут надо посмотреть еще по запросам. Возможно, где-то тут еще идет какой-то из запросов,
который умеет опрашивать операционную систему. То есть, браузер на самом деле умеет опрашивать
через JavaScript. У него есть некоторый ограниченный доступ к операционной системе. Вот, и видно,
что у нас как раз запросы идут, а они идут у нас в синхронном режиме. Вот, и хочу подчеркнуть,
что у нас с вами гет-запрос отправляется по умолчанию. Вот, сейчас посмотрим, что в нем еще
находится. Вот, то есть, если мы говорим с вами про отправку запроса при вводе адреса, то мы
всегда отправляем с вами гет-запрос. Неважно, каким образом мы его отправляем. Давайте подумаем,
каким образом мы можем отправить не гет-запрос, а какой-то другой. Допустим, запрос на обновление
данных, на еще какие-то... на обновление данных и так далее. Нет, вот мы работаем как клиент в браузере.
Ну, во-первых, если у нас есть HTTP-клиент на фронтенте, то понятно, что мы можем явно
указать, что нам нужно отправить запрос определенного типа. Да, конечно же, можно
использовать формы для отправки не гет-запроса. Если мы посмотрим внимательно, как отправить
поззапрос, мы можем отправить форму, можем отправить запрос из клиента браузера и запрос
приложения. Давайте как раз я сейчас открою вот эту кнопочку. Вот она у нас кнопка. Так,
где у нас форма? Вот она, форма. Сейчас я вот эту штуку закрою. Да, да, да. Вот она форма, то есть
вот он объект формы. По умолчанию, по-моему, у формы метод пост. Ну, сейчас давайте попробуем
еще что-нибудь найти. Button Submit, то есть понажайте кнопки Enter, мы с вами отправим запрос. Но на
самом деле здесь никакое действие не привязано, потому что это фронтент. Потому что на активацию
этой кнопки нажат... там выполняется некоторый джава скрипт код. По умолчанию, значит вы можете
у этого всего дела... Давайте посмотрим, может быть, вот эту кнопку. Так, это картинка.
Ага, это тоже получается у нас с формы. Ну, видите, в современных браузерах уже кое-что по-другому
работает. Так, сейчас найду форму какую-нибудь. Где можно найти форму? На какой-нибудь стареньком сайте.
Здесь есть? Нет, здесь нету. Может здесь? Давайте. Сейчас. Нет, это просто форма.
В общем, давайте покажу сейчас тогда HTML-форум. Значит, это как раз сайт для разработчиков. Вот.
И вот что мы здесь видим. Видите, форум. Дальше, значит, что такое PolyAction? PolyAction это URL,
по которому мы отправим запрос. Типа здесь, если мы напишем slash-login, то мы будем отправлять
запрос на наш страницу. Наш доменный адрес slash-login. Значит, а вот здесь вот мы можем указать метод.
Видите, метод get или метод post. То есть здесь можно указать любой метод, который поддерживается.
Вот. Ну, естественно, здесь мы, допустим, pavel asobakakml.com. Вот. И, видите, нам говорится,
что на самом деле он пытался отправить пост-запрос, но у него ничего не произошло.
Сейчас давайте я открою прямо средство, средство отладки. Я открою вкладку Network.
Вот. Собственно, у нас тут. Отправилось ли что-то интересное? Нет, у нас тут ничего
неинтересного не отправилось. То есть это просто HTML-формочка. Давайте попробуем еще раз пост-запрос
отправить. Возможно, что он поймет, что нужно его отправлять. Не-не-не, он внутри редактора
отправляет. Ну, то есть он пытается, по крайней мере, отправить какой-то, какой-то запрос,
не именно классический get-запрос. То есть таким образом мы при нажатии формы можем переопределить
название нашего сайта. Ну, название нашего приложения. Вот. Либо у нас есть какие-то
клиентские приложения, которые мы можем, при помощи которых мы можем отправлять наш запрос.
Так. Давайте проверим рубрику эксперимент. Во сколько у нас сообщение пришло? 10 минут.
Ну, видимо, нам повезло. То есть у нас не было никакой задержки. Вот. Хорошо. Значит, давайте
посмотрим какие вообще... Так, давайте сначала остановимся по вопросу. Понятно ли вот про
методы, которые бывают в HTTP? Каким образом их можно отправить? Библиотеки для отправки запросов.
То есть что у нас с вами есть? У нас с вами есть несколько command-line интерфейсов и есть несколько
более крутых клиентских приложений. Значит, давайте начнем с самого такого, кажется, простого,
но при этом не менее важного. Это сайт под названием, инструмент под названием CURL. Он же CURL. Он на самом
деле позволяет отправлять большое количество запросов в информацию по сети. Вот. Значит,
как оно работает? Оно работает следующим образом. Давайте я, наверное, включу вот так. Вот. То есть,
видите, у него есть большое количество именно методов. То есть он позволяет нам отправить...
"-d", это у нас пост-запрос, "-x", позволяет нам определить метод. Тут нету поле "-x"? Нету. Но
можно загрузить какой-нибудь файл. И есть поле "-f", это наше название формочки. Давайте я сейчас тоже
в качестве, наверное, примера сделаю следующую вещь. Так. Значит, что мне нужно будет?
Блин.
Да, блин.
Ладно, давайте с генериумом.
А? Ладно. Так, смотрите, я создал пользователя testuser123. И сейчас
мы попробуем через него авторизоваться. Значит, давайте посмотрим, собственно,
каким образом происходит авторизация на сайте. Значит, testuser123. Так, мне нужна вкладка Network.
Значит, какие мы с вами запросы отправили? Так, нам нужен с вами, во-первых, пост-запрос. То есть,
мы с вами... Во. То есть, на самом деле, запрос, который у нас идет, мы запрашиваем с вами именно
токен. Да, то есть, вот он. Вот я отправил по иллодам пароль. На самом деле, из-за того,
что мы общаемся по протоколу HTTP, мы как раз его и можем получить. То есть, что нам нужно отправиться?
Нам нужно с вами отправить пост-запрос на вот этот вот адрес. Дальше указать... Вот, смотрите,
следующая вещь. Указать, что мы с вами отправляем application.json. То есть, application,
то, что это а-ля приложения, а json, то, что у нас формат данных такой. Так, минус х. Значит,
тут придется нам прямо немножечко прямо переписать запрос, чтобы понял наш браузер. Минус
х реферер. Вот этот запрос. И все, кажется. А, и телозапрос. Сейчас мы давайте отправим,
и я сделаю запрос минус в. Итак, смотрите, у нас произошло поле, и что нам сказали? Нам
нужно поле логин и пароль. Ну, давайте мы его отправим. Логин. Пейлот. А, юзернейн нам нужен, да.
Господи, какой он страшный. А? Нам выдали токен для авторизации. Вот. То есть, сейчас мы с вами
сможем при помощи этой штуки пойти и сделать другой запрос. То есть, вот у нас есть запрос,
юзеринфо. Давайте сначала попробуем его отправить вот так. И видите, у нас нет никаких токенов для
авторизации. Собственно, давайте посмотрим, где у нас передается токен авторизации. Вот,
видите, есть запрос как раз под названием authorization. И здесь используется один из
протоколов JVT, JSON Web Token. Мы его вставляем вот сюда и получаем информацию о сайте. Все. Ну,
то есть, вот таким образом у нас происходит авторизация. То есть, на самом деле, у вас просто,
когда вы заходите на сайт, у вас хранится этот токен. Где он хранится? Он хранится в месте под
названием, где оно? Application. Вот. Local storage. То есть, есть CCS storage и есть local storage,
в которые мы зашиваем токен авторизации. То есть, теперь вы понимаете, каким образом
приблизительно работает сохранение информации, о том, что вы сохраняете авторизацию. То есть,
в local storage можно сохранять определенную информацию. Но это делается как раз на стороне клиента.
Вот. Это если вам command-line-интерфейс, почему я его показал? Потому что зачастую, когда вы
будете отдавать какое-то приложение в какое-то другое место, то есть, передавать его в production,
либо еще такое. Вам нужно будет зачастую отправлять именно curl-запрос. Опять же,
есть более продвинутый интерфейс. Он называется Swagger. Вы можете открывать в любом сайте Swagger.
Единственное, вы его здесь не откроете, здесь нужно про вас супер-пользователя на чек иметь.
Ну, в целом, здесь есть... Ну, я их почищу. Вот. Собственно, вот они поля, которые есть. То есть,
вот они запросы. То есть, здесь у нас видно, что есть get-запрос, есть post-запрос. При этом,
здесь еще есть поле имена отправки. То есть, образно говоря, я хочу получить какой-то список
курсов, я его могу получить. Вот. И при этом мне... Чем тут удобно? Мне, видите, здесь прямо отправляет
curl-запрос для авторизации. Вот. То есть, в принципе, API работает именно таким образом. Значит,
если говорить про другие библиотеки, то есть библиотека, именно пакет Postman,
на что она обычно используется для тестирования API. Сейчас, вот он. Вот он выглядит вот таким
образом. То есть, здесь тоже можно отправлять запросы, указывая заголовки, собственно,
проводить какие-то тесты по API. Вот. И есть некоторые библиотеки, значит, другие. Если вы хотите
именно JavaScript отправлять, то современная версия библиотеки fetch, то сейчас не надо писать... Раньше
был старый метод через XML HTTP request. Вот. Сейчас есть новая библиотека. Значит, и если мы говорим
через библиотеки про Python, C++ и Java, то, наверное, вы уже с ними знакомы по библиотеке, по заданию
тестирования. Потому что там как раз при помощи этих библиотеки отправляли запросы. Знакомые
названия? Ну, это популярно. В библиотеке понятно, что есть не только они. Так, с отравкой запросов
разобрались? Как оно происходит? Давайте вопрос. Да, хорошо. Значит, вот пример курсу запроса. CURL
запрос. Мы с вами уже его тоже посмотрели. Вот. И теперь нам нужно каким-то образом получать
результат. Каким образом получается результат? Это так называемый код и возврат. Значит, они делятся
на... У них есть пять уровней деления. Есть ошибки. Извините, я говорю, что ошибки. Есть коды возврата
сотые, двусотые, трехсотые, четырехсотые и пятисотые. Значит, в чем заключаются все эти статусы
и возвратов? Соты – это служебные статусы. То есть, когда вам нужно держать какой-то заголов,
допустим, вы отправляете файл, вам отвечает сотым кодом. Сотый – это continuous,
то первое еще какое-то. То есть, не помню. Двусотые означают, что у нас с вами все выполнилось
корректно. Значит, двусотый код – это OK. И есть еще код 201, который иногда используют для,
если вы что-то отправляете в пост-запросе. То есть, на обновление информации. Это 201 – это
обычно created. Дальше идут трехсотые коды. И они тоже различаются между собой. Самые популярные коды –
это 301, 302 и 304. За что отвечает код 301? 301 означает, что у вас ресурс постоянно перемещен. То есть,
вам присылают заголовок, которым говорится, куда ваш запрос переезжает. Давайте как раз я сейчас
покажу. Мы, кажется, это в прошлый раз смотрели. То есть, видите, я делал запрос по HTTP, и мне,
видите, возвратился 301, но ему вот permanently. И дальше это соглашение пересылается из заголовок
location, куда именно нам надо переадресоваться. То есть, здесь идет переадресация с HTTP на HTTPS.
Есть код возврата ошибки, у кода возврата 302. Это означает, что ресурс временно перемещен.
Обычно его используют в том случае, когда вы, допустим, залогинились на страницу,
вам нужно перейти на другую страницу. То есть, вы выполнили пост-запрос на получение информации,
вы дальше переходите на другую страницу. Есть еще код 304. И, на самом деле, если ваш сайт
поддерживает код возврат 304, значит, ваш сайт, в принципе, нормально работает. Смотрите. Сейчас.
Вот. Сейчас тыкаю на кнопки. А, давайте авторизуюсь.
Это 301. Тут, видимо, мне нужно прогрузить все страницы.
Ну, видите, он хитрый у меня товарищ. Он именно делает немножко другую вещь. Он
отправляет мне код 304. Да, он мне отправляет код 200 и при этом говорит, что у меня информация
закоширована на диске. Давайте еще раз попробуем. К сожалению, он мне почему-то не хочет 304 возвращать.
Он мне именно дает его сотый. Но, по идее, вот здесь вот можно получить код возврата 304. То есть,
это означает, что у вас ресурс не изменился с дата последнего запроса. Это тоже регламентируется
заголовками. Вот. То есть, у нас есть 301, 302 и 304 кода возврата. То есть, их можно частенько
увидеть. Следующие запросы, это 400-е запросы. Это ошибка на стороне клиента. Какие коды
возвратов здесь есть? Первый код возврата это запрос 400. Что он означает? Он означает то,
что вы неправильно сделали запрос по API. Вам говорят, что скорее всего вам выдают спецификацию
еще, почему ваш запрос по API был выполнен неверно. Кстати, давайте попробуем еще раз. Курл минус.
Как-то мы делали какой запрос? Вот это, да? Видите, нам вернулся запрос 400. Ответ 400. То есть,
мы сделали неверный запрос по API и нам вернулся ответ. Дальше есть запрос вот такой вот. Http 401.
Собственно, мы не авторизовались на сервисе. То есть, у нас доступа нет, потому что мы не
авторизованы. Следующий код возврата это 403. Это значит, что у вас доступ к ресурсу запрещен.
Следующий после этого 404. Это означает что? Not found. После этого идет запрос 405. Код возврата
405. Давайте я его покажу на быстром примере. Сейчас мы быстро напишем приложение.
Мы пишем route и давайте я укажу пост. Мы объявляем с вами заголовки и здесь я делаю следующее.
Делаю обработчик.
Дальше нам нужно
мы пишем вот такую штуку.
Нам допустим 6789.
Сейчас исправим.
Как называлось приложение у нас?
Открываем вкладку.
Ладно, поставлю system-wide.
Не поставлю.
Придется создавать окружение.
Ну да, но я все равно привык это делать окружение.
Итак, у нас запущено приложение на 6789 и сейчас мы сделаем следующее.
Я отправлю http://localhost 6789 и видите какой мне статус возвращается. 405 метод not allowed. Это
означает что у вас есть такой заголовок, у вас есть такой route, но он принимает только пост запроса.
То есть это вам говорится о том что вы нужны отправить пост запрос.
Вот видите здесь у нас остановится OK.
Так, окей, понятно 405 что делает?
Какие еще есть?
Значит я просто интересные рассказываю, если вы не поверите вот такой код.
Можно прочитать что типа я чайник, я не могу обработать запрос.
Зачем он делается? Он делается на самом деле для следующих вещей.
Представьте себе что у вас есть некоторые запросы на которые мы должны отвечать быстро и запрос на
которые мы должны отвечать медленно и в том случае если допустим мы не можем ответить на запрос быстро.
Кстати вот такой код возврата используется внутри систем, допустим в гитлабе он используется, тогда ваш
запрос из быстрого переходит в медленный и уже медленная обработка этого запроса происходит.
Вот оно используется в такой спецификации. И последние коды которые здесь есть это ошибки
500. В чем они заключаются? Они заключаются в том что это ошибки уже на стороне сервера, не на
стороне клиента. Самый страшный сон разработчика это когда идет большое количество 500 ошибок.
Понятно по каким причинам. Это означает что у вас сервер начал падать, причем вы в большом количестве
запросов. Теперь смотрите в чем их отличие. Есть ошибка чисто 500, которая отдает вам любой
сервер. Смотрите значит мы делаем следующее. Что напишу? Так давайте вот так. Ошибка есть у нас?
Вот видите? 500 ошибка. То есть у нас ошибка на стороне сервера, у нас сервер не может обработать
наш запрос. Отлично. Ну тогда что нам нужно сделать? Нам нужно каким-то образом понять,
что ошибки бывают помимо 500. Значит какие ошибки бывают? Бывают ошибки вида 502 и 503. Возможно вы
кстати видели. 502 это означает что bad gateway. Что это означает? Это означает вот мы с вами в
прошлый раз смотрели веб-сервер. Веб-сервер пытается перенаправить запрос на наш сервер,
а там нашего сервера не оказывается. Ну а нам говорят bad gateway типа что никто не может ответить
на запрос. А есть запрос 504 gateway timeout. То есть вы можете на уровне веб-сервера отследить и
поставить timeout на выполнение запроса. То есть если вам другой сервер, который должен отвечать
на запрос не отвечает, он говорит ой извините, я не могу ответить, сервис висит. Так что теперь
вы понимаете, что когда сервер висит, вам страничка высвечивается типа 504. Ну и больше вроде таких
известных кодов нету, я перечислю самую популярную. То есть которая встречается с 95% случаев.
Так, по кодам вы знаете понятно? Хорошо, давайте дальше. Значит на самом деле теперь мы говорим с
вами про API. Самым популярным способом использования API является representation state transfer. На самом деле мы
с вами его уже видели. То есть мы пока рассматривали протокол HTTP, теперь мы переходим более высокому
уровню. Значит в нем нету состояния, значит все работает поверх протокола HTTP. Есть протокол,
способ взаимодействия, которые не работают поверх HTTP, но здесь именно мы закладываемся на
сам HTTP. И пути это структуру каталогов. Значит давайте пример я сразу открою. Значит editor.io,
здесь есть хороший пример. Прямо всего API. Swagger pad store. И вот давайте посмотрим, как у нас организован
грамотный API. Значит все что касается животных, мы видим с вами, оно находится по маршруту slashpad.
Собственно нам нужно создать животное, мы делаем пост запрос на slashpad. Нам нужно обновить текущее
животное. Мы делаем питомца нашего, мы делаем пут запрос на slashpad. Если нам нужно найти допустим
какого-то определенного животного по определенному ID-шнику, мы берем slashpad slashpad ID. То есть вот мы
можем даже отправить запрос, давайте отправим. Вот. То есть вот у нас возвращается на животное.
Понятно, что она возвращается в виде формата JSON, но это нам не мешает. Вот. Дальше, если мы хотим
допустим найти по каким-то тегам, то мы здесь можем передать это все в заголовке запроса. Допустим
мы находим животных по тегу элемент. Собственно оно передается в заголовке нашего запроса. Вот.
Собственно, ну и остальные тут тоже есть у информации. То есть чем глубже объект, тем сильнее мы в него
закапываемся. То есть получается у нас узнать об информации определенным животным slashpad slash ID, но
допустим, если нам для конкретного животного нужно загрузить картинку, у нас получается slashpad
slashpad ID slash upload image. То есть мы сразу делаем иерархическую структуру нашего директории.
Вот. Про store то же самое, про user то же самое. То есть если нам нужно зайти user-login, user-logout. Ну и
собственно здесь мы можем с вами назначить переадресацию страниц. То есть как эти запросы
обозначаются. Да. Собственно у нас есть в любом в любом приложении, веб-приложении у нас с вами
есть раутеры, которые позволяют перенаправить наш запрос. То есть допустим, если мы сейчас делаем
app-route slash users, допустим, то мы можем сделать dev-get-users return, допустим, Петя, Вася,
Коля, Маша. А понятно, что здесь под капотом еще должен лежать запрос базу данных. Так,
так, from flask import jsonify. Нам нужно будет запрос делать. Итак, мы делаем запрос, получаем наш
результат. Так, сейчас мы это делаем вверх. Ну и давайте отправим наш курл. Курл 8.9 slash users. То есть
у нас теперь получается, послышу, отдается ошибка. А если мы не делаем slash, то видите, нам возвращает
этот список. То есть мы по факту с вами навесили обработчик на какое-то событие. И наш веб-сервер,
нет, не веб-сервер, наш сервер отвечает этим результатом. То есть на каждый URL вы можете,
допустим, навесить какое-то ограничение. То есть если мы говорим здесь, то можно сделать вот так.
Так, делаем tning. Опять же, я думаю, это детально будут рассматривать на каком-нибудь курсе по
разработке. Мы можем, допустим, сделать вот так slash user slash ID. И здесь обычно методы языка позволяют как
раз найти. Давайте мы перенесем. Создаем наш животных. Ой, это у нас не животные, это у нас люди.
users ID. Собственно, перезапускаем наш сервер и называем наш метод. Опять же,
редиректы тут тоже работают. Вот у нас users, а дальше, допустим, мы передаем slash user slash ID.
Все, я понял. Разные языки по-разному работают.
Вот так вот. Вот, видите? То есть нам вернулся уже конкретный пользователь. Он подставил поле ID
вот сюда. То есть по факту это у нас декоратор, pattern, то есть он делает какую-то дополнительную
функциональность и в итоге нам в методы нашего запроса доставляет конкретное поле ID. Вот мы
написали с вами простой API. Совсем простенький, но рабочий. Так, хорошо, это понятно? Так, отлично.
Давайте двигаться дальше. Значит, каким образом работает сервер? Собственно, давайте еще раз
поговорим. Мы создаем рабочих на определенный путь. То есть делаем путь в методы, которые мы делаем.
Обрабатываем заголовки и тело запроса и отправляем в статус код тело ответа и заголовки. То есть,
в принципе, заголовки можно тоже возвращать в виде запроса. То есть это можно делать в том,
что в флазке. Значит, пример библиотека, который позволяет писать в приложении. Просто сервер это
oat++, это user ver. Там еще есть драгон. Сейчас появился. Драгон, кстати, самый быстрый по менчмаркам.
В Python можно написать флазк. Это будет синхронный фреймворк. Fast API это. А синхронный фреймворк,
который набирает популярности Django, это такой комбайнер. Такой достаточно большой комбайнер.
И в Java, если мы говорим, то синхронный фреймворк это Spring и ассинхронный это ACO. Он не приходит
ему замену, они решают немного разные задачи. Просто список фреймворков, которые можно смотреть
для обработки веб-серверов. Так, ну, собственно, данные у нас должны храниться в базе данных,
естественно. И мы как раз дошли с вами до трехзвенной архитектуры. То есть мы с вами тоже в прошлый раз
рассмотрели. То есть у нас с вами есть веб-сервер, который разруливает наши запросы со стороны
клиентов. У нас есть с вами application-сервер. То есть это вот как раз то, что я сейчас показывал на
флазке. Это называется application-сервер. И к нему можно привязать базу данных при помощи любых
коннекторов. Вот. Как происходит нагрузка? Значит, это вот такой вот интересный пример,
что на самом деле, если мы говорим про Python, то обычно ставятся отдельные прокси. То есть как это
все работает? У нас клиент отправляет запрос. Дальше у нас веб-сервер перенаправляет запрос
на приложение, которое запущено либо локально, либо еще где-то. И здесь есть еще одна вещь,
вот, которую очень важно не забывать. Это control-demon. То есть зачем он важен? Мы вот сейчас с вами
запустили приложение в командной строке. А теперь представьте, что произойдет, если мы с вами закроем
эту вкладку в консоли? Что у нас с вами произойдет? Процесс завершится, сервер перестанет отвечать.
Поэтому его нужно поставить в каком-то фоновом режиме. Вот. Как раз процесс управления фоновыми
режимами как раз осуществляется такими демонами. Значит, если мы говорим про Ubuntu-like-систему,
там используется system-demon, можно поставить себе supervisor. Вот. И дальше у нас возможный перед
нашим приложением, возможно, еще один сервер стоит. То есть в принципе у нас возможно перенаправление
сервера. После этого нам возвращается уже ответ клиента по обратному пути. То есть здесь может
быть большая цепочка вызовов. Вот. И это высоконагрузка систем. То есть не ставьте, пожалуйста,
обычный сервер s-is. То есть это просто локальное решение. То есть если те же самые приложения
на фласке разворачивают, то нужно будет еще ставить отдельный HTTP-сервер, который позволит
запускать запросы более чем в одном потоке. Так. Хорошо. Теперь вопрос я хочу задать про Питон.
Кто знает, что такое Jill? Да ладно. Никто не знает аббревиатуру Jill?
Jill. Так. Мне, видимо, надо пообщаться с преподавателем по Питону, потому что по идее это нужно знать.
Как это расшифровывается? Это расшифровывается как global interpreter log. То есть несмотря на то,
что если вы хотите запустить приложение в Python, работать в параллельном режиме,
то по факту у вас параллельного режима не получится. Это как раз ограничение Питона.
Вот. Поэтому как раз фласк работает на самом деле в последовательном режиме,
а G-Unicorn как раз позволяет распараллеливать вот эту всю машинерию. Ну, конечно, я удивлен.
Так. Давайте я остановлюсь. Понятно ли вот эта картинка? То есть что у нас есть веб-сервер,
дальше за ним стоит, возможно, какой-то контролирующий демон для того,
чтобы серверы не упали. Если что, он перезапустит эти серверы. То есть его цель, цель этого
супервизора как раз осуществлять контроль за ресурсами. Так. Теперь давайте поговорим
про способы взаимодействия между сервисами. Они бывают синхронными и асинхронными. Значит,
каким образом происходят синхронные взаимодействия? Клиент ожидает сразу ответа от сервиса. Обработка идет
сразу же. То есть у вас представьте себе. Давайте я вам покажу пример асинхронного запроса. Так.
У нас с вами... Где тут network, да? Так. Делаем пресет. Видите, крутится вкладочка. Еще раз.
Видите, то есть мы скачиваем страницу. Мы ждем, пока у нас страница загрузится. То есть у нас в
приложении ждет этого ресурса. Вот. И это как раз называется синхронный взаимодействие. То есть
когда у вас вкладка в браузере крутится, именно сама на загрузку, тогда у вас идет... То есть вам
нужно дождаться ответа от этой страницы. Обработка результатов идет сразу же. И при
этом идет критичное время ожидания. 504. То есть у нас появляется способ получить статус квадрата
504. И обычно, смотрите, все запросы, которые мы открываем страницу в браузере обычно идут
синхронными. Только после этого запросы идут в асинхронном режиме. После этого веб работает
весь в асинхронном режиме. То есть что такое асинхронный режим? Вот, наверное, это вам будет
сейчас вы познакомитесь с этим впервые. То есть, наверное, еще никто не видел ни разу асинхронного
взаимодействия. Только сам, если не копал. Асинхронное. Клиент отправляет запросы и не ждет ответа.
Запрос может обрабатываться позже. При этом у нас появляются большие возможности по балансировке
ресурсов. То есть мы можем отправить одновременно несколько запросов. И один запрос могут получить
разные сервисы. То есть у нас появляется способ распределить нашу нагрузку. Вот. Теперь картинка.
Что это за диаграмма? Кто мне может напомнить? Нет, это низкие из диаграммы. Это одна из диаграмм
взаимодействия. Какая именно? По-английски на S, по-русски на P. Нет. Не-не-не. По следовательности. По
следовательности. То есть у нас сверху вниз идет линия жизни. И у нас с вами идут запросы. Вот так
выглядят синхронные сервисы. То есть у нас товарищ B пошел и отправил запрос на наш веб-сервис. Дальше
этот запрос идет в базу данных. Получает результат. И несмотря на то, что сервис B отвечает
пользой заменить сервису B, человек A сидит и тупит. То есть представьте себе, у нас запрос идет
5 секунд. Человек A только будет ждать не 5 секунд, а 10 секунд. Два раза больше. Проблема. Каким
образом это можно решить? Если у нас сервис позволяет обрабатывать запрос A синхронно, то можно
сделать вот так. То есть видите, у нас получается пользователь A отправляет. Вот этот запрос является
синхронным. Дальше у нас идет запрос на веб-сервис. Мы получаем данные. И дальше нам эти данные вернутся
не сразу, а через какой-то момент времени. То есть видите, у нас запрос баз данных пропадает. Что-то
здесь магическое происходит. Дальше нам возвращаются данные. Дальше нам возвращается ответ. И здесь там
тоже возвращается ответ. Вопрос. Я хочу который вам задать. Скажите мне, пожалуйста, вот у вас,
когда вы вызываете функцию любую в любом языке программирования, какой она является? Синхронной
или асинхронной? Любая функция в любом языке программирования является синхронной. Вопрос.
Каким образом сделать функцию асинхронной? Ага, это если язык программирования поддерживает
такое. А если язык программирования такое не поддерживает? Нам нужна какая-то абстракция,
которая позволит запустить нашу функцию в отдельном окружении и отвязать ее с основного
использования. Как это работает? Для этого есть как раз понятие поток или нить. Лучше сказать
дред. Подробнее будет рассматриваться на курсе операционных систем. Но суть в следующем. У нас
с вами есть код. Это у нас какой-то процесс. Значит у нас есть код, у нас есть данные, есть на файл. И
дальше у нас для каждого потока выделяется набор своих регистров и стэк. То есть у нас все
переменные изначально алоцируются на стэке. Когда мы делаем отдельный поток, то у нас все
сохраняется. При этом у переменных выделяется свой собственный набор регистров и свой собственный
стэк. Регистры это как раз то, что у нас находится на процессоре. Таким образом, как запускать
ассихронную функцию? Мы должны с вами создать новый поток, запустить в нем какую-то функцию и
отвязать этот поток от исполнения. Так, хорошо. Давайте подумаем, а как результат тогда получить?
Вот здесь стрелочка идет в обратную сторону.
Хороший результат. Есть такой объект, он называется фьюч, который позволяет вернуть результат. Но это уже не тривиальный механизм.
То есть объект типа фьюч, что такое объект типа фьюч? Давайте немного расскажу. Вы вызываете функцию,
вам выдается вот типа тикет. Типа проверить готовы результаты или нет. После того, как вы проверите
этот результат, у вас получается ответ, готов или нет. Но на самом деле делают немного по-другому.
Вы по факту аргументы функции, которые вызываете, вы передаете еще одну функцию,
которую нужно будет вызывать в случае того, когда у вас закончился запрос. Эта функция называется
callback. И у меня есть пример к вам. Все на плюсах понимают здесь, ну или на ООПшных языках
программирования. Хорошо. Так, со шхом. У меня есть вот такой код. Его видно, да?
Главное, что функции было видно. Смотрите, каким образом обычно выделяются новые потоки.
В C++ есть абстракция std thread. Ее не было очень долгое время, но сейчас она появилась. Единственное,
что вам нужно будет слинковать с реализацией потоков ваш механизм. Итак, смотрите,
значит объявляется поток, он сразу же запустится. В принципе, можно его не индициализировать. И
первое, что всегда принимает любой поток, поток выполняется в отдельной функции. То есть мы должны
передать сигнатуру нашей функции. Дальше у нас здесь возникает runner thread. Дальше мы передаем
аргументы нашей функции. То есть мы получается будем вызывать функцию runner thread в отдельной
потоке с аргументами 100. И смотрите вот эту сигнатуру. Мы будем принимать на вход функцию,
которая принимает на вход int и возвращает void. И эта функция обычно привязана еще к
отдельному потоку исполнения. То есть у нее должно быть какое-то хранение. И дальше мы
делаем следующее. Мы можем, допустим, сделать вот такое поведение, что если у нас значение
x больше нуля, то мы делаем callback на 200, иначе мы делаем callback на 400. Вызываем функцию callback с
параметром 400. Так, вас не пугает вот такой вот код? Это лямбда функция. То есть это функция,
которая не имеет аргументов, которая не имеет названия. Значит здесь у нас это область захвата,
но нам здесь она не важна. Мы принимаем функцию, которая принимает на вход статус код. Здесь мы
выполняем slip на 100 мс и получаем request complete. Дальше мы делаем следующее. Создаем
второй поток, который принимает в результат запроса минус 200 на вход, а в качестве результата
получает статус код, который засыпает на 50 мс и возвращает определенный результат. Потом наш
основной поток засыпает на 200 мс, то есть у нас в программе будет 3 потока. И дальше мы объединяем
эти потоки, то есть мы возвращаем их в общий контекст исполнения. То есть дожидаемся выполнения
всех поток. Можно не дожидаться, можно их отвязать. Так, вопрос. Как вы думаете, что выведет этот код?
В каком порядке? Вот это очень важно. Да, это все будет запущено сейчас параллельно.
Кто первый закончит? Какая функция? Давайте я строки выделю. Да, сначала поток 2 обработают,
потому что он будет спать 50 мс. Потом обработает поток 1, потому что он спит в 100 мс. А потом
обработают результат все остальные потоки. Так, хорошо. Давайте скомпилируем это все дело.
Нам нужен будет LP thread. Библиотеку по thread нам надо будет прилинковать. Ну давайте проверим.
Что? Похоже? Давайте проверять. Значит сначала у нас выявилось 400. Откуда у нас могло вывести
с 400? Вот здесь он выводит статус код. То есть у нас говорилось, что если у нас аргумент функции
меньше нуля, то у нас вызывается callback с аргументом 400. Да, потом у нас что происходит? Дальше вызывается
вот эта функция request has completed и у нее статус код 200. И только после этого вызывается наш request
completed. Кстати, надо его переместить вот сюда. Да, то же самое. А третьим выполняется наш поток,
он засыпает через 200 мс. Вот. Ну и в таком режиме браузеры работают. То есть вы видите,
вы наверное могли обратить внимание на вот эти вот плашки. Вот эти. Давайте еще раз. Вот видите,
что несколько запросов идут параллельно в этой линии жизни. Раз параллельно, два параллельно и
три параллельно. То есть в принципе запросы как раз идут через функцию callback. Так, понятно ли,
что такое callback? Это функция, которая возвращает результат, которую вызываем после выполнения
определенной функции. Так, и здесь у нас возникает следующая неприятная вещь. Есть один антипатор,
который связан конкретно с callback. Называется callback hell. То есть слева это код, который написан
при помощи callback. То есть получается есть функция findUserByName. Потом нам передается на
аргумент функция callback, которую мы с вами вызываем. А дальше внутри нее функция getUserProfile.
Если у нас ошибка, мы делаем callback с ошибкой. Внутри нее вызываем функцию getUserGetAccount.
Мы вызываем callback. Неприятный код, да? Как его решать? С права видно более приятная
реализация этой функции. Она использует механизм async-await. Но как работает под
капотом механизм async-await? Тоже интересно разобрать. И, значит, если мы сталкиваемся
с вами с такими вещами, это значит, что пора нам рассмотреть? С какой-то проблемой.
Да, правильно. Нам надо рассмотреть паттерн, который умеет решать эту проблему. Это будет
поведенческий паттерн. Он называется цепочка ответственности. И он работает следующим образом.
Вот это все поведенческие паттерны, которые у нас есть. Вы, наверное, на семинарах уже
начали часть из них рассматривать. Мы с вами рассмотрели на семинарах стейт, и в следующий
раз мы рассмотрим с вами обсервер, как реализация очереди сообщения. Остальные потихонечку будут
рассматриваться на семинарах. Итак, что такое цепочка ответственности? Нам нужно запускать
некоторые процессы по цепочке событий. Возможно, это нужно делать каким-то сложным образом. Пример.
Сложный процесс авторизации. Возможно, что для того, чтобы вам авторизоваться в сложной
экосистеме, вам нужно по цепочке авторизоваться во всех сервисах. Раньше, по крайней мере, года два
назад, чтобы вам авторизоваться в Gmail, вы параллельно авторизовывались во всех сервисах
Google. В том числе и в страницах Redirectа был YouTube. Сразу прошиваем всю экосистему. Либо
пайплайн сборки кода. Мы будем с вами говорить про сиай на семинарах, и там тоже это все будет.
Итак, цель паттерна chain of responsibility сделать так, чтобы колбекки нам были не страшны,
чтобы передавать выполнение через делегатов. Примером в данном случае является либо Async
Await. Async Await это более продвинутая реализация. Но есть механизм Promise, который позволяет вам
построить цепочку Command-Prize в разрешении текущей. То есть у вас получается, вы выполняете функцию,
после этого вызываете функцию Xen, выполняете следующую функцию, и получается вот такой паровоз.
Как это реализуется? Это на самом деле очень сильно вам поможет напомнить паттерн-декоратор,
который мы с вами рассматривали. У нас с вами есть обработчик событий, и есть базовый обработчик
событий, у которого есть ссылка на следующий по цепочке. Когда мы с вами обрабатываем
наш запрос, мы говорим, что если у нас следующий обработчик не опустой, то мы передаем его по
цепочке. Значит, если у нас есть конкретный хендлер, то мы можем обработать наш запрос,
тут функция CanHandleRequest, мы его обрабатываем. А дальше мы передаем наш запрос по цепочке.
То есть сначала наш запрос, потом идет запрос на следующий. Ну и в итоге смотрите,
почему это паттерн не декоратор? Потому что декоратор это у нас структурный паттерн,
где мы объекты оборачиваем друг в друга, именно в матрешку. А здесь мы налаживаем цепочку. То есть
у нас здесь получается, после h1 мы ставим следующим h2, а после h2 в следующем ставим h3. Можем
сделать наоборот, то есть h1, h3, h2. То есть это именно поведенческий паттерн. Потом мы обрабатываем
наш запрос через h1, и после этого у нас идет обработка на h2 и на h3. Давайте я остановлюсь на
диаграмме. Скажите, понятна ли диаграмма? Давайте код посмотрим, и в следующий раз мы его запустим.
Итак, вот он код. Да, тут синтаксис такой немножко неприятный, я думаю, будет самым
понятно. То есть мы с вами создаем хендлер, обработчик базовый, и дальше на этот хендлер
обычно ставится функция обработки. И дальше, смотрите, у нас получается паровозик. То есть у нас
на хендлер ставится следующий обработчик, division 0, хендлер делим мы на ноль или нет. После этого мы
ставим хендлер обработки файлов, тут логирование будет идет, и после этого мы еще ставим еще один
хендлер. И в итоге один запустит другой, запустит другой, запустит третий. И здесь как раз идет два
обработка. То есть они пройдут по цепочке. Мы запустим этот пример с вами в будущем и добьем,
наверное, еще один паттерн. Да, тут еще остался один полпаттерн. То есть это что касается такого
базового вводного блока по сетевому заявлению. Вообще есть отдельный курс по сетям. Через раз,
наверное, мы с вами, я еще подумаю, про что мы будем говорить. Мы будем говорить про антипаттерна,
либо мы рассмотрим виды языков программирования. Мне кажется, полезнее будет именно посмотреть,
как работают разные языки программирования. Какие парадигмы существуют. Вот, давайте,
на этом, наверное, все. Если есть вопросы, задавайте.
