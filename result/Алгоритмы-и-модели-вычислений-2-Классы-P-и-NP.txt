Так, ну вот неделю назад мы на онлайн-лекции в общих
чертах обсудили такую проблему PNP, значит, сегодня мы
ее поставим немножко более четко и формально, значит,
сначала хочу немножко поговорить про учитывательные модели,
ну и дальше, соответственно, определить, что такое класс
P, что такое класс NP, ну, некоторые общие значения мы уже обсудили.
Ну, а смотрите, вообще есть несколько подходов к тому,
что такое вообще алгоритм, да, что означает, что там
функция вычислима и так далее, вот, ну, вот один из
классических подходов это машина тюринга и машина
тюринга, кажется, очень хорошо подходит для сложки
вычислений, потому что когда мы говорим о сложке
вычислений, нам нужны какие-то базовые шаги, да, и, ну,
у нас есть базовые элементы памяти, если мы хотим считать
память, и, значит, соответственно, в машине тюринга это очень
все хорошо выделяется, да, и хорошо поддается под
счетом, вот, есть другие модели, которые хороши для
других целей, да, там какой-то лямдовый вычисление, да,
там декурсивные функции, вот, но для сложности хорошая
машина тюринга, вот, ну, давайте немножко поговорим
о том, что такое машина тюринга, да, у вас же это
где-то было, да, на ТФС было, вот, ну, да, это вспомним,
значит, потому что тут нам будет важно, что машина
многоленточная, да, так, было и часто распространено
одна ленточная, а вот в торжке вычислений, да, и других
смежных областях удобно, что она была многоленточная,
ну, например, двухленточная, да, соответственно, есть
вот две бесконечные ленты, вот, может быть, и счетом,
может быть, их больше, вот, есть какой-то управляющий
блок, ну, у которого есть указатель, значит, указатель
на одну ленту на другую, вот, ну, а у самого блока
есть какое-то внутреннее состояние, да, на лентах
записаны какие-то символы из некоторого алфавита,
например, А и Б, ну, и дальше команда имеет вид, наш, например,
Q, A, B, переходит в какое-нибудь другое состояние S, да,
какие-нибудь другие символы C, D и еще два сдвига, да,
значит, сдвиг налево, сдвиг направо, вот, ну, в данном
случае, это что будет означать? Это будет означать, что
вот тут, как бы, следующий шаг, следующий шаг, значит,
здесь вместо Q будет состояние S, дальше здесь вместо A будет
символ C, вместо B будет символ D, и так же это изменится,
то есть здесь это сдвинется вот сюда вот, ну, а тут какой-то
еще был символ, да, там, Z, а здесь, соответственно,
сдвинется вот сюда вот, и здесь какой-то еще там
символ D, например, вот, ну, а после этого нужна будет
новая команда уже не Q, A, B, не S, C, D, а S, Z, E, да, S, Z, E тоже
на что-то перезапишут, в какое-то состояние перейдет,
куда-то сдвинется, ну, и так все это вот будет работать,
значит, это, ну, наверное, довольно похоже, да, у вас,
наверное, с одной лентой было или прямо с одной лентой,
да, ну, в принципе, наверное, если вы сами будете придумать,
то вы что-нибудь такое придумаете, в принципе, можно обсуждать
какие-то более хитрые модели, да, значит, может быть,
например, вообще не одна лента, не много лента,
какая-нибудь там клетчатая плоскость, на которую можно
переходить в разных направлениях, может быть, еще надстройка
такая, что есть какой-нибудь там произвольный доступ,
что можно, это собственно то, что в реальных компьютерах
происходит, да, можно прочесть адрес ячейки памяти и
прямо на эту ячейку перейти, а не то, что по одному шагу
сюда, вот, ну, и так далее, значит, если делать больше,
тогда понятно, что здесь будет просто больше символов
здесь, больше символов здесь и больше направлений
здесь, но важно, что состояние одно, состояние свое на
каждой ленте, оно вообще одно на всю машину, вот,
ну, хорошо, значит, дальше, ну, формально машина тюринга
это какой-нибудь там набор из там алфавита, из которого
все эти буквы, множество состояний, из которого вот
эти буквы, ну, и, самое главное, функции перехода, да,
значит, обычно там, там бывает еще два варианта, может быть,
у нас машина отвечает да или нет, тогда вот этот вот
вот ответ можно записать прямо состояние, да, можно
считать, что есть специальные два состояния, выделенные
QA, это принимающее слово accept, значит, принимающее
состояние, AQR reject, отвергающее состояние, вот, тогда, если
машина приходит в одно из них, то она заканчивает
работу, и, соответственно, в этом случае ответ один,
а в этом случае ответ ноль, да или нет. Вот, а другой
вариант, когда ответ, это какая-то там длинная строка
символов, да, или число, или что-то такое, тогда есть
одно завершающее состояние, но после этого ответ нужно
получить не из состояния, а где-то прочесть ленты.
Вот, ну и тогда нужно все договориться, что есть
какое-нибудь еще начальное состояние, и, соответственно,
в самом начале, машинное начальное состояние, скажем,
на одной из лент написан вход, вторая, например,
пустая, ну и после этого начинается какая-то такая
работа, которая задана конечной программой. Так, ну
ладно, я не хотел бы сейчас вдаваться в полные формальные
детали, я это, наверное, не буду записывать, но
глобально я надеюсь, что это понятно. Вот, хорошо.
Значит, теперь почему важно, что именно две ленты?
Ну, на самом деле в некоторых моделях они могут
иметь разный статус, но, например, есть модели
вычислений, где вход неизменяемый, и тогда вот на одной
ленте будет просто записан вход, его можно читать, но
там нельзя ничего менять, а все вычисления будут
произвести на второй ленте, и, например, если вас
интересует затраченная память, то тогда, естественно,
нужно считать им дополнительную память, не ту, которая
вот здесь вместе со входом, а ту, на которой собственные
вычисления происходят. Вот, бывает так, что у лент
вообще разный статус, например, есть рандомизированные
вычисления, где можно считать, что случайные биты записаны
на отдельной ленте, да, могут быть какие-то интерактивные
алгоритмы, да, тогда может быть, что там две машины
имеют как бы одну общую интерактивную ленту, какие-то
свои рабочие, ну и так далее, да, на самом деле можно
множество разных сюжетов описать на языке машины
тюринга с разными лентами, там, с разным статусом.
Вот, значит, тем еще хороша машина тюринга, тем, что
тут вот есть элементарные единицы и по времени и по
памяти, да, по времени есть элементарный шаг, это
выполнение вот этой вот команды, соответственно,
по памяти есть вот одна ячейка, ну, при желании можно
не умножить там алгоритм по размеру алфавита, но это
если уж прям совсем точно надо мерить, вот, а так
по простому можно просто свой ячейк использовать,
на который машина там хотя бы раз указывала в ходе
работы. Так, хорошо, теперь смотрите, если есть
конкретная машина, если есть машина, значит, или
программа, да, значит, это я буду как синониму использовать
слова машина и программа, да, значит, если есть
программа, да, значит, есть какой-то вход, то дальше,
в принципе, есть два варианта, либо машина остановилась
на этом входе, либо не остановилась. Ну, мы будем
считать, что она всегда останавливается, да, потому
что как раз когда она там не останавливается, это
же вопрос перевычастимости, а не сложность вычислений,
да, то есть здесь нас будет интересовать, сколько
времени она будет работать или там сколько ячейк
займет и так далее. Вот, соответственно, можно
написать, ну, как-нибудь обозначить тайм m от х, значит,
это время работы машины на входе х, и будем считать,
что оно меньше бесконечности, значит, время работы m от
х, да, значит, это может быть измерено, собственно,
в базовых шагах, а может быть измерено, ну, в каких-то
других единицах, да, например, если у вас какие-нибудь
аристетические вычисления, можно смотреть, сколько
у нас адефинных операций, сколько мультипликативных
операций, да, и считать именно вот эти вот переходы,
да, не доходить прям до машины тюринга, это операции
с отдельными символами, а прям считать базовые
операции, что у нас, например, умножение на травер
чисел, это вот базовая операция, и мы считаем, сколько
их происходит, да, там, если у нас на входе матрица.
Вот, хорошо, значит, ну, дальше, когда у нас есть и
машина, и вход, то вот можно просто взять и посчитать,
если мы договорились, что считать, да, то берем и
считаем, а если у нас есть просто машина, то уже есть
разные способы в качестве такой времени работы машины,
да, без точения входа, да, значит, время работы самой
машины может вычисляться, как видим, двумя способами,
значит, один способ это в худшем случае, да, значит,
это может быть худший случай, но же в худшем случае
даже еще и иксы могут быть самые разные, но это означает,
что мы смотрим на иксы одной длины, да, то есть можно
сказать так, что time, значит, time m от числа m, это максимум
по всем иксам, у которых длина равна m, да, значит,
а тут, соответственно, время времени работает time m от
икс. Ну, опять же, да, значит, общий подход, что n это просто
длина как бы в битах, да, или символах икса, в принципе,
можно считать, что, например, если это у нас граф, то n это
там число вершин, если у нас матрица, то n это там число
там строк или столбцов, ну и так далее, да, в общем,
в конкретных приложениях n может быть не длиной икс,
а каким-нибудь другим параметрам, который нас интересует,
вот, в общем случае это вот длина икса. Ну и также может быть
не худший случай, а в среднем. В среднем тогда вместо
максимума берем какое-то усреднение, и это вообще
можно там разными способами делать. Ну можно просто
брать там среднеархитетическое, но так не очень хорошая
теория получается, да, значит, там некоторые ухищрения
нужны. Вот, ну что дальше, хорошо, ну для машины мы это
посчитали, но дальше хочется понять, что такое сложность
вопроса, который машина решает. Ну что означает, что
машина там решает вопрос, ну, например, распознает язык,
м распознает язык, а если для любого икс, да, значит,
если икс лежит в а, то тогда м от икс равно единице,
значит, а если икс не лежит в а, то тогда м от икс равно
нуди. Да, то есть машина должна дать ответ на вопрос
да или нет, и причем всегда правильно, да, то есть мы
здесь не разрешаем никогда там ошибаться, да, значит,
всегда должен быть правильный ответ. Вот, ну хорошо, тогда
как определить сложность, собственно, этой задачи, да,
что такое сложность? Сложность задачи на распознавание
языка. Что это вообще такое? Ну вообще, вообще хотелось бы
дать определение, что это там время работы самой быстрой
машины, которая решает эту задачу. Вот, но, к сожалению,
так ничего не получится. Вот, почему? Ну, во-первых,
прежде чем понимать, что не получится, да, все не получится,
надо понять, что не получится. Как, конечно, можно сравнивать,
да, пусть у нас есть одна машина М, другая М штрих. Ну,
и, например, мы этого считали по лучшему варианту, да,
вот максимум вот такой. И у нас какие-то есть две функции
растущие, да, вот как понять, какая лучше. Ну, опять
стандартный подход, что нужно смотреть на асимптотику,
да, то есть, например, если есть там какая-нибудь одна
функция такая, да, значит, это тайм М от М, а есть еще
другая функция, там какая-нибудь вот такая, значит, тайм
Q от М, да, и что машины М и Q решают одну и ту же задачу,
и у них время, но иметь в виду, что вот эта ось это М,
да, а эта ось это время, вот, и одна растет вот так,
а другая растет вот так вот. Ну, стандартный подход,
что нас интересует в виде бесконечности, то есть машина
Q будет лучше, значит, машина Q будет лучше, но в частности,
например, любой полином считается лучше, чем любая
экспонента. Теорема изматонализа, да, что если мы поделили
там экспонентом на полином, то это будет стремиться
бесконечности, но, может быть, очень не скоро, да,
если мы поделим там 1.001 в N и поделим на N в тысячной,
то это стремится бесконечности, но очень не скоро
даже единицу. Вот, но, тем не менее, по крайней мере,
в теории нас интересует именно проведение бесконечности.
Вот, но хорошо, а можно ли все-таки дать такое определение,
да, что сложность задачи – это сложность машины,
которая асимпатически быстрее всего решает эту задачу.
Но было, конечно, хорошо такое определение дать, но,
к сожалению, такой асимпатически наилучшей машины может
не быть, да, потому что может быть такая ситуация, да,
что может быть одна машина, которая работает вот так вот,
да, а другая быстрее, а третья какого-то момента еще быстрее,
да, четвертая дальше тут будет еще быстрее и так далее,
и каждую машину можно улучшить, но не будет одной машины,
которая будет идти там вот по нижней огибающей.
Да, это значит «Терема Блума», значит «Терема Блума»,
что может не существовать оптимальной машины, «Терема Блума»,
да, по крайней мере для некоторых задач, значит,
для некоторых задач не существует оптимальная машина,
которая их решает.
Да, то есть любая машина может быть улучшена, да, та еще
улучшена, та еще улучшена и так далее, вот, но не будет
одной машины, которая будет прям лучше всех.
Вот, значит, эта теорема довольно общая, довольно ранняя,
она еще в 1965 году была доказана, но мы ее не будем доказывать,
да, там не каких-то таких совсем в боксах, где и там нет,
зато здесь много техники, значит, поэтому мы с ней ознакомимся,
и пойдем дальше. Ну, что получается с «Теремой Блума»?
Получается, что нельзя вот так определять, да, уж не говоря о том,
что непонятно, как понять лучше эта программа или не лучше,
ее может вообще не быть, да, так что даже определить так мы не можем.
Ну и в результате получается, что, собственно, нет такого
прям четкого понятия, что такое сложность задачи, есть только
нижние и нижние оценки, да, то есть если есть какая-то машина,
которая решает задачу, у которой какое-то время работая,
то вот такое время будет верхней оценкой на сложность задачи.
Ну а в принципе могут быть и нижние оценки, что в принципе гораздо сложнее,
да, что мы доказываем, что ни одна машина не может
решать быстрее, чем в какой-то скорости.
Вот, вот нижние оценки, это самое сложное, что есть сложные вычисления,
очень мало теорем, в которых прям доказана нижняя оценка,
гораздо больше открытых вопросов. Собственно задача про УП и НП,
это вот классический пример вопроса о нижней оценке.
Значит, если П строго вложена в НП, то тогда
некоторые задачи из НП не имеют паридомиального алгоритма.
Ну вот, мы почти уже вплотную подобрались к формальному определению,
здесь есть понятие D time, значит D time от T от N,
это класс языков, то есть задач с бинарным ответом,
советом да или нет. Значит, это класс языков,
которые распознаются на многоленточной машине тюринга
за время O большое от T от N.
Так, что значит O большое? Ну, то есть какая-то универсальная константа,
так что время будет меньше, чем вот этот констант умножить на T от N.
А зачем вот я пишу O большое, почему просто T от N не написать?
Ну, потому что это константы, это совсем какие-то низкуровневые детали,
например, если мы будем несколько клеток у машины объединять в одну,
то есть переходить от битов к байтам, то у нас там операция над байтами
станет гораздо меньшей операцией над битами, но только в какую-то константу раз.
И тогда получается, что все переходим от байтов к 2-байтовым,
к 3-байтовым и так далее участкам. В общем, можем искусственно
увеличивать размеры ячеек, и соответственно от этого числа операции
у нас будет меньше. Если для подсчета памяти еще можно умножить на логари
числа состояний, то со временем не очень понятно, на каком основании это делать.
И получается, что в константу раз мы можем уменьшить время
за счет искусственного объединения нескольких ячеек в одну.
Поэтому, хотя на практике константы это очень важно,
если ваш программа стала 2 раз быстрее работать, это может очень сказаться
на результатах, тем более если в 100 раз быстрее.
То в теории считается, что это не важно. Нас интересует симптомика,
скорость роста, а не конкретные константы.
Ну хорошо. И дальше.
Класс П от слова полиномиальное время.
Значит, это объединение по всем С от 1 до бесконечности.
Значит, здесь будет D time от N в степени С.
Значит, поскольку у нас уже константы есть вот здесь, то здесь можно просто
функцию писать. Без дополнительного множителя.
Ну вот, мы обсуждали, что в классе П есть много хороших задач.
Там раскраска в два цвета, там поиск кратчайшего пути,
проверка на Эллера в цикл, там поиск совершенно парасчитания,
проверка простоты числа, где N это будет уже не само число, а его логарифм,
то есть число знаков.
Линейно-программирование, например, тоже в П.
Ну и так далее. В общем, огромное множество хороших задач лежат в П.
Так, а дальше возникает вопрос, почему тут до бесконечности?
Почему бы не провести какую-нибудь границу?
Скажем, что четвертая степень это хорошо, а пятая это плохо.
Но дело как раз в деталях модели.
Что вообще-то, что мы хотим?
Мы хотим, чтобы этот язык включал в себя все эффективно решаемые задачи.
Что мы как бы хотим формально поймать понятие эффективности.
Но если мы смотрим на сути, то понятие эффективности
в сути, то понятие, то вообще-то хорошо бы, чтобы деталь модели не зависела.
Например, не зависела от теплолент.
И даже если мы вместо двух лент сделаем одну ленту,
хорошо бы, чтобы наш класс эффективной задачи не поменялся.
Иначе, если мы даже такой модели не можем разобраться,
то странно было, что мы перешли на новый процессор.
И от этого у нас понятие эффективной задачи изменилось.
Хорошо бы, чтобы все-таки было устойчивое понятие,
не связанное с деталями техническими.
Но оказывается, что если вы переходите от двух лент к одной ленте,
если переходите от двух лент к одной ленте,
то тогда время может возлестись в квадрат.
Время t от n может перейти во время t от n в квадрате.
Но почему?
Потому что как вообще переходить от двух лент к одной ленте?
Есть разные способы.
Например, можно их записать на одну ленту.
Вот здесь будет первая лента.
Значит, а вот здесь будет вторая лента.
Да, и тут вот какие-то места есть указатели.
Там же у нас было два указателя, а здесь у нас один указатель.
Поэтому вместо старых указателей мы там пометки какие-то ставим.
Ну и дальше как нужно моделировать?
Мы тут идем, ищем указатель, не знаю, что здесь написано.
Потом идем дальше, ищем здесь указатель, не знаю, что здесь написано.
Смотрим, какая должна быть программа.
Соответственно, перезаписан здесь символ,
передвигаем указатель, идем сюда.
Тоже здесь перезаписано, тоже передвигаем указатель.
Может все так выйдет, что занято место растет,
что мы там дописываем сюда вот какой-то символ,
дописываем сюда какой-то символ,
и они у нас как бы столкнулись.
Тогда что можно делать?
Ну, можно взять, например, отдельную операцию,
весь этот блок взять и сдвинуть туда,
чтобы дополнительное место образовалось в центре,
и его потом использовать.
В общем, так или иначе, чтобы смоделировать один шаг
на старой машине,
нужно, более-менее, туда обратно пройти
по всем клеткам на новой машине.
Можно, да, можно перемешку записывать,
но это не особо будет от того, что вам нужно
найти место, где здесь отметка стоит,
и найти место, где здесь отметка стоит.
А если вы еще будете хранить, чтобы они были рядом,
то тогда вам нужно будет вместо перемещения отметки
передвигать всю ленту,
а все равно будет порядка длины ленты требоваться.
Не, можно не передвигать ленты,
тогда вот эти указатели могут быть в разных местах,
и тогда нужно ходить туда-сюда, чтобы их найти.
Можно пытаться держать их рядом друг с другом,
но тогда, если вы указатель зафиксируете,
у вас лента будет вдоль него двигаться,
и все равно нужно вместо того, чтобы
бегать искать указатель, нужно будет бегать
и двигать ленту.
Вообще, никуда это на самом деле не деться.
Получится, что у вас один шаг на двух лентах
соответствует примерно такому числу шагов,
сколько у вас занятых ячеек.
Но что-таки занятых ячеек у вас порядка ТАТН,
потому что за один шаг на одной ленте
нельзя занять больше одной новой ячейки.
Поэтому всего занятых ячеек не больше, чем ТАТН,
но получается, что у вас ТАТН шагов
и ТАТН на каждый шаг,
ТАТН опираться на каждый шаг еще нужно.
Вот и получается ТАТН в квадрате.
Ну и на самом деле, вот тут как раз даже можно
нижнюю оценку доказать.
Значит, есть такая одна конкретная задача,
называемая задача о полиндроме.
Значит, полиндром, то есть нож таких х,
что у вас как этот х лево направо
и справа налево считается одинаково.
Значит, хр, это имеется у х
написано на обратном порядке.
Ну вот как проверить, что слово это полиндром?
Ну, смотрите, если у вас есть две ленты,
если у вас есть две ленты,
то можно просто скопировать.
Значит, скопировали.
Дальше на этой ленте остались намечки,
а на этой ленте, значит, двигается другой конец.
И дальше идем по одной слева направо,
по другой справа налево
одному все символы.
Если дошли до конца, все совпало, значит,
полиндром, если где-то разночьение, значит, не полиндром.
И вот эта процедура линейная.
Например, 3n, то есть n шагов скопировать,
n шагов перейти в другой конец на одной ленте
и n шагов идти и сравнивать.
Соответственно, тут две ленты,
значит, две ленты это n шагов.
Но одна лента,
как на одной ленте,
но нужно ходить туда-сюда,
как-то сравнивать,
и нужно будет более-менее,
там, n пополам раз,
там, сходить туда-сюда,
будет типа n в квадрате шагов.
Это одна лента.
Я без константа пишу.
n в квадрате шагов.
Ну да, на основании, смотрите,
вот здесь надо написать о большое,
а вот здесь надо написать,
наоборот, о мега большое.
Что о мега большое означает, что есть
какая-то константа, как оценка снизу.
То, что о большое, значит, может быть, и сильно меньше.
А о мега большое, значит, может быть, больше,
но обязательно больше,
чем какой-то епсилон больше нуля,
он нужно на n в квадрате.
Что-то, опять же, можно экономить,
запомнить сразу три е-символа,
пойти туда, сравнить,
и тут будет n в квадрате,
одна треть от n в квадрате.
Но тут можно как раз доказать,
что меньше никак нельзя.
Но это, может быть, на некоторых семинарах
что-то не было пока не в одной группе,
а даже было, да, ну вот.
Вот, хорошо.
Хороший вопрос.
Это вот еще более сложная теорема.
Значит, смотрите, если k-лент,
если k-лент, переходим в две ленты,
то на самом деле там
куча получается,
значит, тогда время
время t от n
превратится во время
t от n
t от n на логарифм t от n.
Что тоже немножко больше,
но уже не в квадрате,
всего нужно на логарифм.
Но это тоже довольно сложная техническая теорема.
Есть в первой главе Рорбарака,
если интересно, то
можно изучить.
Так что здесь вот такой большой шаг,
именно от 2 к 1.
Так, так стоит нам все говорить
только из зрения П.
Ну а говорит следующее, смотрите,
но мы не хотим,
чтобы наша временная граница
зависела от деталей модели.
Но точно хотим, чтобы линейные
алгоритмы попали в
классы эффективных.
Ну а какой минимальный класс функций,
который вместе с каждой функцией
содержит ее квадрат
и при этом содержит
линейную функцию?
Ну это есть многочлены, да?
Да, с одной стороны квадрат
многочлен, это многочлен,
а с другой стороны, если есть тен, то есть тен
в квадрате, в четвертый, восьмой и так далее.
Вот.
Так, ну что, прерывы будем делать?
Ну давайте, да, вроде
есть трепность 5 минут тогда,
значит потом прорыв.
Попробовать у вас подрегулировать
Давайте.
Зай, надень наушники, пожалуйста.
Сейчас потестируем еще раз.
Подживу хорошую пробку.
Продолжим?
Так, значит, на самом деле, значит,
прежде чем приходить к энплею,
я поговорю еще
про эти вот классы.
Значит, то, что здесь есть некоторая
иерархия
классов,
значит, кроме
p,
ну, есть некоторый ряд
тоже стандартных классов.
Ну, важнейшие, я их так
буду писать подряд,
значит, важнейший из них это класс
x,
значит, класс
x, это
объединение по c
от
единицы бесконечности,
значит, d time
от 2 в степени n в степени c.
То есть, это какая-то такая экспонента,
но при этом экспоненты от полинома.
Да, не просто от n.
Да, не просто что-то в степени n,
а что-то прямо в степени c.
Значит, есть класс e,
который чуть-чуть
поменьше.
Значит, e, то c, то c,
от единицы до бесконечности,
значит, тут
d time
от 2 в степени c.
Да, это все классы языков.
То есть, тут вообще такая
структура получается многоступенчатая,
что есть
как бы, собственно, слова, про которые
спрашивают, да или нет.
Да, есть языки.
Значит, языки это множество слов.
Дальше есть классы.
Классы языков.
А дальше, в принципе, есть еще
и иерархия классов.
Да, то есть, ну, это не просто
множество классов, да, какие-то структурированные.
Вот.
Ну, в данном случае, если
такие вот p,
q, p,
ну, понятно, что
экспонента, полинов меньше
экспонента симпатически,
а линейные экспоненты меньше
полиминальные экспоненты.
Да, дальше тут есть, например,
тут уже не такое стандартное
обозначение q, p,
q от слова квазер.
Значит, тут
объединение
по c, от единицы
до бесконечности.
Да, значит,
вот
два в степени
логарины.
n
в степени
c.
Да, то есть, ну, можно сказать,
что q, p, по отношению к
p, это то же самое, что x, по отношению
к е. Да, что
вот здесь, если здесь
c, то это как раз
полинов, да.
2 в степени целой логарины, это то же самое, что
n в степени c.
Вот, а здесь 2 в степени c на n.
Вот, соответственно, здесь 2 в степени
в степени c, а здесь 2 в степени логарины
в степени c.
Ну, дальше, в принципе, может быть там какой-нибудь
е-е,
например, да, это
тоже объединение, здесь, соответственно,
the time.
Вот,
два в степени 2 в степени tn,
и на экспонента.
Вот, может быть и эксп.
Ну, понятно, я уже не буду
писать.
Вот, ну и может быть какие-то градации
здесь делась.
Например, есть
такой очень нетипичный класс,
который иногда упоминается,
это вот такой класс sub-exp.
И это, на самом деле, вместо
объединения пересечения,
да, это пересечение
по всем эпсилон
больше 0,
так, а то значит the time
от
2 в степени n в степени
epsilon.
Да, то есть тут наоборот,
да, это вот сюда
идет, вместо n
будет онкорень из n, онкорень
из n, и вот если для всех
epsilon это будет верно,
то это вот будет sub-exp.
Вот, но
тут
еще очень интересный класс
в следующем смысле.
Да, по крайней мере
теоретически
не гарантируется, что есть один алгоритм,
у которого время работы
меньше, чем любая такая величина
синтетическая.
Но может быть так, что для каждого эпсилона
есть свой алгоритм, который работает быстрее,
и тогда свой язык попадет
в это пересечение.
Вот.
Так, ну теперь
чуть-чуть поговорю
про то, какие тут
могут быть задачи.
Ну вот E это, наверное,
самый такой
появляющийся язык,
самый сейчас появляющийся
класс.
Да, потому что, например,
да, вообще есть теорема
в булирархии, мы, наверное,
ее не будем доказывать, но опять же, знаете,
очень полезно, что вот в этом ряду
каждый следующий класс строго больше, чем
предыдущий.
Да, то есть, действительно есть
опять же там
я точные условия не буду
давать, но
интуитивный смысл
такой, что чем больше времени дать,
тем больше задач можно решить.
Причем это верно даже внутри P, да, то есть, скажем,
за N в кубе можно решить
строго больше задачи, чем за N в квадрате.
И так далее.
За 3 в степени N
можно решить строго больше, чем за 2 в степени,
и так далее.
Но по крайней мере
на каждом следующем этапе есть задач
которые не решаются на предыдущем.
Но так, чтобы
Яну в виде получить такую
задачу, и
она была осмысленная, и принес, чтобы можно
было доказать это, это вот не так
легко.
Вот. Ну, например,
вот в классе E будут лежать
разные переборные
задачи.
Они, на самом деле, в NP лежат, и мы, на самом деле, про них
не знаем, потому что они EF лежат.
Ну, вот переборные, типа
раскраска в 3 цвета, например.
Ну, а тогда, скажем,
N вершин, 3 цвета,
поэтому простейший переборный алгоритм
это 3 в степени N
умножить на
небольшое время для проверки
каких-то расходов.
Вот. Гамильтонов цикл
или путь.
Но, на самом деле, если
перебирать напрямую,
то нужно перебирать все
перестановки, а перестановка будет, как раз, N
факториал.
То есть, в принципе, гамильтонов путь, если
решать простым
перебором, то будет, как раз, алгоритма
из EXP. Да, тут будет
ну, N факториал, это там
по форме стирлинга, типа N в степени
то есть, типа 2 в степени
N на гриф плос N, что
немножко больше, чем 20% констанции.
Да, вот гамильтонов путь
значит, гамильтонов путь
при простейшем переборе
будет решать вот здесь вот.
Но, на самом деле, есть более хитрый алгоритм,
который его вот сюда отправит.
Вот. И вообще
очень довольно сложно
естественным образом придумать
язык, который будет вот здесь вот.
Но там непонятно будет ли его здесь.
Вот. Но искусственно можно там
что угодно придумать.
Да, значит, например, вот из
квазиполиномов.
А почему, кстати, квазиполином?
Ну, потому что не N в степени константа,
а N в степени алгоритма, да, или N в степени
полинома от алгоритма.
Ну, например,
можно придумать такую задачу,
у которой будет перебор
ровного такого размера.
Например, задача
если в графе
из N вершин клика размером
логорифм N.
Да, клика, то есть
можно найти графизм вершин,
логорифм N вершин, которые все
друг с другом соединены.
Ну, там
будет то в стане из N
по логорифм N, то будет
как раз вот такого примерно порядка.
Да, порядка N в степени логорина.
Вот. То есть вот это будет
полный перебор.
Вот. Может это быть
из какой-то
значит,
из какой-то теорем математически
получаться. Например, есть такая теорема
о доминирующем множестве
турниря. Да, значит такой граф
турнир. Значит, турнир
это такой полный и ориентированный граф.
Да, то есть тут есть
значит, есть там N команд
и они все друг с другом сыграли без
ничьих. Да, и там в какую-то
сторону приведено ребро.
Так вот,
но что называется доминирующим
если
в любую вершину N из него
ведет хотя бы одно ребро
из него.
Да, то есть набор команд доминирующий,
если любая команда оставшись
проиграла хотя бы одно из этих.
Вот. Но там есть теорема,
что в любом турнире есть доминирующий множество
размера логарифма N.
И тогда задача поиска такого множества
будет как раз иметь вот такую сложность.
Да, тоже опять же
C из N пологарифма N.
Вот.
В общем, могут быть осмысленные задачи
на разных уровнях. Но вот есть
даже с
другими базами есть экспонент, тоже есть
вполне осмысленные задачи,
но они обычно
как сложная математика связанная.
Ну, например, если там
спрашивать что-нибудь про выигрышные стратегии,
то это все будет где-то вот
в е и в эк.
Кто выигрывает в шахматах N на N?
Да, или шахматах N на N.
Если в стратегии просто кто выигрывает
в шахматах,
то это на самом деле вообще не задача
этого класса. Просто какой-то один ответ
там нет параметра.
Да, мы просто его не знаем,
но этот ответ там есть.
А вот если обобщить шахмат
на доску N на N,
то это же будет такого рода задача.
Тут уже будет асимптотика,
будет куда-то стремиться.
Ну, и на самом деле там будет
именно экспонента какая-то.
Ну, это на самом деле еще зависит
от того о точных правил,
что мы там
по повторам разрешаем и так далее.
Но, в принципе,
так
наверное можно так формулировать,
что это будет какая-то двойная экспонента.
Но при классических правилах
там будет экспоненционное число позиций,
и мы соответственно
будем каждую из них
размечать, там будет выигрышная она
или проигрышная,
ну, и рано или поздно
поймем про начальную выигрышную
или проигрышную.
Вот.
То есть это будет экспенциальный алгоритм.
Да, сейчас кроме квазиполинома
есть, по-моему, театрополином,
который немножко
другой смысл имеет.
Вот я оговаривался
про простые числа,
то когда мы говорим о полиномиальности
проверки простоты,
то здесь вместо n
мы поставим логарифм n,
потому что полином не от самого числа,
а от длины его записи,
то есть от логарифма.
А вот псевдополиномиальные, они как раз те,
где от самого числа,
где может быть много разных чисел, например,
и, например, полином будет
от количества этих чисел
и от максимального этих чисел,
а не логарифма.
То есть длина записи
это число на логарифм максимального.
А если полином
от количества чисел
и от самого максимального,
то это псевдополином называется.
По умолчанию
полином это всегда полином
от общей длины записи.
И тогда, если у вас есть цепочка чисел,
то длина этой записи
это количество чисел в цепочке
умножить на число знака
в самом большом числе.
А если мы...
Нет, можно сказать, что псевдополином
это если мы все числа
записываем в лунарной записи,
то число записываем через n едини.
И после этого
от такой увеличенной записи
это будет полином.
Вот этот псевдополином
и т.д.
То есть сортировки
за n и n
вычисляют все же полиномы?
Да нет, почему?
Мы же сравнивали...
Нет, смотрите,
когда мы говорим про сортировки,
то мы в качестве базовой операции
учитываем сравнение
двух элементов.
И если эти элементы как-нибудь по нормальному
сравниваются, просто как числа,
то, конечно, мы их умеем
сравнить за полином
от линной записи.
Но может быть, само сравнение
подразумевает какую-то сложную процедуру.
И тогда сортировка
будет использовать полинное число
сравнений, но само сравнение может быть
каким-то сложным.
Ну конечно, да.
Да, может быть так, что
базовой операции
не много,
но они сами большие.
И когда мы определяем
все классы P,
там, X и т.д.,
мы должны быть
уверены, что
сортировка
P, там, X и т.д.,
мы доходим до самых маленьких операций.
Поэтому если базовые операции
сами все полиномиальные,
то это ничего не меняет.
А если базовые операции вдруг
оказались сложными,
тогда нужно еще на время
для базовой операции умножить,
чтобы получить нужную оценку.
Конечно, да.
Да, конечно, да.
Ну ладно,
соответственно, в принципе,
классификация вот в тех классах
тоже может иногда
быть интересной задачей.
Но давайте теперь перейдем
все-таки к НП.
Значит, на НП можно двумя способами
смотреть.
Значит, один вариант,
и это вот то, что мы
говорили про сертификаты,
а второй вариант — это
через специальную модель
недоторминированных машин тьюринга.
И, собственно, второй вариант
и дал буквку N
в название НП,
потому что НП означает
non-deterministic polynomial.
То есть полиномиальное время
на недоторминированной машине.
Ну и, по крайней мере,
немножко я поговорю про
эти самые недоторминированные машины.
И это не то же самое,
что вероятностные машины.
Да, значит, хотя
оказалось бы, что
оказалось бы, что
детерминированные вероятности — это вроде как антонимы,
но недоторминированные и
вероятности — это не синонимы,
это немножко разные вещи.
Хотя что-то общее у них тоже есть.
Ну, хорошо,
недоторминированные
машины Тьюринга.
Что это такое?
Значит, математически
можно сказать, что
у них функция перехода —
это не однозначная функция, а многозначная.
Да, то есть это
аналог
обычных
машин Тьюринга
с многозначной
функцией перехода.
Вот, а как тогда
они работают?
Ну, они, получается, работают
как ветвящиеся процессы.
То есть у нас
место
линейного вычисления
получается дерево.
Место линейного вычисления
получается дерево.
То есть можно себе представлять
тут
как бы
тут как бы
хорошие метафоры такие проявленные вселенные.
Что
вот если
машина встречает, когда
реально есть много разных вариантов перехода,
то она
как бы создает несколько копий
из проявленных вселенных.
И в одной копии запущен
один переход, другой копий, другой переход
и так далее.
А дальше, если еще раз
будет много вариантов, то она еще раз
появится.
То есть получается, что
каждый раз
каждый раз получается
вот такое ответвление.
Где-то может быть
и нет ответвления, где-то одно значение.
Где-то, возможно, даже
пустое множество в тупик пришло
и никакого ответа
нету.
Вот.
Ну и так далее.
Это как-то идет.
А дальше происходит следующее.
Если какая-то из копий
в какой-то из проявленных вселенных
пришла к ответу
да,
то тогда как бы все это слопывается,
получается ответ да.
То есть она как бы во все
проявленные вселенные шлёт сигнал,
что ответ да.
И все это узнают.
А если ответ нет,
то ничего не делает.
И если сигнала туда не пришло,
то значит ответ нет.
Вот. То есть получается
это именно для бинарного
ответа.
Значит, если одна из ветвей
если одна из ветвей
пришла
к ответу
да,
то, соответственно, общий ответ
да.
Вот. А если,
соответственно,
те пришли к ответу нет,
то общий ответ нет.
То есть можно сказать, что ответ это дизьюция
ответов на отдельных ветвях.
Вот. А время работы
это длина максимальной ветви.
Вот.
Иначе
иначе ответ нет.
Вот. А время работы всей машины
это
время максимальное
на всех ветвях.
То есть длина максимальной ветви.
Максимальная, да.
Время работы, длина.
Да.
Мы не хотим такого.
Ну вот, да.
Мы не хотим, чтобы
было бесконечно.
Хотим, чтобы всегда останавливалось.
Ну, может никакого
ответа не дать.
То есть где-то может быть
где-то ответ да, там где-то ответ нет.
А где-то никакого. Ну, может считать, что никакого
значит нет.
Не особо повлияет на что-то.
Ну, да.
Ну, тут это, в общем, тут
вообще в машине-чурнике
можно очень много чего варьировать.
Получает то же самое здесь тоже. Можно, например, считать,
что у вас просто есть две функции
перехода.
Значит, тогда будет
либо ветвление на две, либо
без ветвления, если две функции дают
одно и то же.
Значит, можно считать, что
может быть большое ветвление,
может быть тупика, обязательно там либо да, либо нет.
Вот.
Ну хорошо, значит, вот это вот один подход,
а другой подход чертификатный.
Да, сейчас я тут не недороскал подход.
В общем, после этого,
да, вот, кроме
D time, можно определить
M time, да,
то же самый язык, рассказываемый
на вот такой вот нетремерной машине
за соответствующего времени.
В остальном все то же самое.
Вот.
А вот сейчас обсудим.
Так, дай сначала определим.
Значит, M time
от M.
Значит, это класс.
Класс языков
распознаваемых
на
нетремерной машине
тюринга
за время у большой от M.
За время у большой
от M.
Вот.
И опять же данное время
это глубина дерева,
распознаваемых
на смысле вот такого ответа.
Вот.
Ну и есть соответственно
значит, класс
NP.
Значит, класс NP
это
соответственно, N time
от N степени C.
Может, например, класс NX.
Да, NX,
это соответственно
то же самое.
Да, вот там
два степени C.
Вот.
Ну и конечно там NE может быть.
Ну и даже NQP
на том никто не изучает.
Не изучает такое.
Вот.
Так.
Видите, действительно, как они связаны
друг с другом?
Ну связь очень простая.
Значит, знаете, D time
D time
от A от N
вложено в N time
в N time от A от N.
А это вложено в D time.
D time от
два в степени
но здесь я большое напишу.
Потому что помолчалась
констанция здесь, а нужно чтобы была
констанция здесь.
Вот. То есть, недетерминированные
учисления можно моделировать
детерминированными
но за экспенсально большое время.
Значит, почему?
Ну потому что просто размер этого дерева
будет экспенсален.
Да, каждый раз, смотрите, даже если
насветление больше, чем на два
все равно оно будет
в какую-то константу раз.
Да, просто
потому что у нас всего есть константы вариантов.
Да, потому что есть константы новых символов
констант новых состояний
констант новых направлений.
Все это перемножение будет какая-то константа,
которая от N независима, есть только от машины.
Вот. Поэтому размер
этого дерева будет экспенсален
от его глубины.
Но и соответственно можно
детерминированно обойти все листья
понять есть там ответ
да или нет
и сказать какой будет ответ.
Дальше. Поэтому
соответственно вот.
Вот. Ну, в частности
в частности будет
P вножено в N P
и вножено в N P.
Вот. Именно X пониже
да, потому что если здесь N степени C,
то здесь тоже N степени C.
А вот это мы есть.
Это мой вопрос.
Смотрите, что мы знаем.
Мы знаем, что P вложено
в X строго.
Вот. Но вот про эти два вложения
промежуточных не про одно.
У нас неизвестно, строго или оно.
Да, хотя верят,
что оба строгие,
но не парадонка доказать не могут.
Вот.
Так.
Но у нас очень много времени осталось. Давайте я на это расскажу
как вот это вот определение
через нетренированные машины
связано с сертификатным,
которое мы в прошлый раз
обсудили.
Да, значит, есть вот сертификатное определение.
Сертификатное определение N P.
Да, значит, у нас
X должно лежать в A тогда и только тогда,
когда существует Y.
Такое, что
В от XY
равно единице.
Вот. Ну и, соответственно, В работает за полинальное время,
Y имеет полинальную длину.
Вот. Все это одно и то же.
Ну, смотрите, значит,
из нетренированной
детерминированной машины
можно перейти
в сертификатное.
Ну, в следующем образом.
Мы просто в сам сертификат запишем,
по какой ветке вычисления нужно идти.
Значит, включать 100Y
это
вет
вычислений,
приводящие
к ответу.
Да?
Вот. А В
это, соответственно, моделирование
машины вдоль этой
ветки.
Значит, моделирование
вычисления
вдоль ветки Y.
Ну, находить.
Вот. А получается,
что, во-первых,
вот это вот моделирование.
Ну, тут нужно вообще немножко
сказать про универсальную машину тюринга.
Это, наверное, проходили.
Есть универсальная машина тюринга, которая умеет моделировать
другие машины тюринга.
И если там немножко посмотреть, то она это умеет делать
с полиномерным
замедлением. Ну, это примерно так же,
как вот тут мы обсуждали все.
Она, например,
так же действует и с таким
замедлением работает.
А может быть, даже и с таким.
Вообще, какое-то
замедление должно быть, потому что у нас
универсальная машина тюринга фиксирует
число лент, а у моделируемой
произвольное число лента.
Поэтому какое-то замедление должно быть.
Но если там хотя бы две ленты есть,
тогда оно будет вот таким.
Ну, и в любом случае
в полиномерном.
Нет, моделирует
моделирует
моделирует
вычисления вдоль ветви у.
Вот, а получается, что если действительно
если ответ да,
то тогда получается,
что
есть ветвь приводит к ответу да,
можно ее
можно ее подать на вход
и верификаторы ее проверят
и скажут, что действительно
приводит к ответу да.
Если все ветвь приводит к ответу нет,
то тогда что верификатору не подать,
он сразу скажет нет.
Вот.
Ну, и еще в другую сторону.
Значит, в другую сторону.
И сертификатного определения
в
определении
через нетренированные машины.
Ну, тут история такая,
что как машина должна сначала
угадать сертификат.
Угадать сертификат.
Да, тут машина
машина сначала
угадывает сертификат.
Угадывает сертификат, затем
проверяет,
затем проверяет, подходит ли он.
Затем проверяет,
подходит ли он.
Ну, то есть
картинного чтения будет такая, что
как бы такое двоичное дерево полное, то есть сначала она
выбирает, пусть там первый бит у будет ноль или он будет один,
потом выбирает, какой будет второй бит у и так далее, а потом, когда она все биты у выписала, она уже
детерминированно вычисляет вот это самое в.
Ну и тогда, если подходящий у есть,
да еще и не слишком длинный,
то она этот у выпишет и на нем придет к ответу да.
Поэтому общий ответ машины будет да.
Если ни один игрек не подходит, то на любой ветви в итоге будет ответ нет и общий ответ нет.
Поэтому, действительно, вот такая вот машина
дает тот же ответ, который
дает вот это условие.
Ну вот, поэтому действительно получается, что
определение через n-time
оправдывает обнущение n-p,
да, определение через сертификаты просто удобно использовать,
да, и
более наглядно позволяет представлять, что тут происходит.
Ну ладно, есть какие-то еще вопросы.
Длину у, значит, длина у должна
быть ограничена полиновом от х.
На самом деле, можно считать, что время работы в это полином от х,
и тогда от любого у он сможет прочесть только ограниченную тем же самым полиновом часть.
И поэтому, можно считать, что у имеет ту самую длину каково время работы в.
Пример,
не, ну пример типа того, что х это, скажем, граф, а у раскраска три цвета, а в проверяет, что раскраска правильная.
То есть, соседние вершины в разные цвета покрашены.
Да, или там
клика, например, что х это тоже граф, а у
это набор вершин, а в проверяет, что они все друг другу соединены и что в наборе нужное число разных вершин.
Вот.
Ну хорошо, я думаю, на сегодня это все, в следующий раз начнем чрезвычайную полноту, и вот спасибо.
