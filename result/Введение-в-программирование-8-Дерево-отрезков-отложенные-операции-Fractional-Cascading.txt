Итак, смотрите, в прошлый раз у нас в конце был
спортстейбл.
Давайте ократканно напомним задачу, какую мы решали
с помощью спортстейбла.
Спортстейбл на русский вообще переводит разреженная
таблица.
Но так никто не говорит, все говорят спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
спортстейбл.
У нас был статический, то есть не изменяющийся
Чтобы найти сумму на отрезке, мне нужно как бы сложить
на левом отрезке, на правом отрезке и как бы вычесть
вот это вот пересечение, но вот это вот переченье
мы никак не можем вычесть, потому что оно может вообще
не являться степенью двойки.
Вот оказывается, что можно как-то это пообщить, написать
disjointsportstable, там немножко по-другому все выглядит,
и мы научимся отвечать на все такие запросы, там
сумма на отрезке, предзвение на отрезке, особенно,
например, если у вас есть задача в стиле, есть у
вас много матриц, а0, а1 и так далее, а и-1, много
матриц, и поступают запросы, произведение куска матриц
на отрезке, то есть вам нужно найти произведение
с l-той матрицы по r-той, что-нибудь вот такое, умножить, умножить
на a r-тую, то есть тут понятно, уже никакие префиксные
суммы не подойдут, нельзя посчитать произведение
с нулевой по r-той и с нулевой по l-минус первую и потом
как бы поделить да одно на другое, потому что оно
может вообще не делиться, или обратную может быть
сложно найти.
Вот, и в таком случае, например, тоже подойдет disjointsportstable,
это позволит на отрезке найти вам какую-то величину,
какую-то функцию от элементов.
Вот, хорошо, но это все работает только если массив статический
и никаких изменений не поступает.
Сегодня мы будем изучать дерево отрезков, которое
умеет все то же самое, только еще позволяет вам как-то
менять массив дерево отрезков.
Задача более-менее та же самая, на отрезках найти
что-нибудь, типа там сумму, произведение, максимум,
и при этом еще массив может меняться, то есть могут
поступать запросы в стиле и это элемент поменять
на какой-то x, сделать присвоение, а это равно x.
Модельная задача такая, модельная задача, есть у
вас опять массив, а 0, 1, и так далее, а n-1, и два типа
запросов.
Первый запрос, это изменение в точке, то есть по какой-то
позиции и по значению вал вам нужно выполнить присваивание,
а посты равно вал, то есть просто заменить один элемент
другим.
Ну и второй это опять, скажем, сумма на отрезке, по двум
индексам lr вам нужно найти сумму чисел с l того по rt,
a l плюс a l плюс 1, плюс так далее, плюс a r, ну вот такая самая
простая задача для дерево отрезков.
Так, давайте мы для удобства предположим, что n является
степень двойки.
Будем считать, что n это степень двойки, n равно 2 в каторе
для какого-то целого k.
Тогда построим следующее дерево, я нарисую пример
для n равного 8, листьями будут выступать наши 8 элементов
массива.
Вот эти 8 элементов, соответственно, здесь а0, а1, и так далее
а7.
Затем мы эти вершинки объединяем по парам и подвешиваем
к одному общему предку.
Значит, мы рисуем вершинку, которая является родителем
а0 и а1, то же самое делаем с а2 и а3, объединяем их как
бы в одну высшую вершинку, то же самое с а4 и а5, ну
и с последним двумя, а6 и а7.
И в каждой вершине мы будем хранить сумму как бы в поддереве.
Вот здесь будем хранить а0 плюс а1, то есть здесь
знаем сумму на отрезке длины 2.
Здесь тоже сумма на отрезке длины 2 у нас будет а2 плюс
а3, тут а4 плюс а5, здесь а6 плюс а7.
Продолжаем опять, склеиваем пары вершин в одну высшую,
вот так будет и вот так.
Ну и соответственно, число написано в вершине будет
равно сумме во всем поддереве, то есть сумма вот этих вот
чисел а0 и а1, а2 и а3 или по-другому, сумма просто того, что написано
в детях, потому что с левой стороны это а0 и а1, справа
а2 плюс а3.
И здесь число, которое мы будем хранить равно просто
а0 плюс а1 плюс а2 плюс а3, здесь то же самое, все элементы
с четвертого по седьмой.
Напишу а4 плюс и так далее плюс а7.
Ну и в конце самая верхняя вершина будет корнем нашего
дерева и в ней число будет равно сумме всего, что написано
во всех листьях, а0, а1, а2 и так далее вплоть до
а7.
Или что то же самое, сумма в двух детях, в левом и в
правом.
Здесь будет просто сумма всех чисел, а0 по а7.
Вот построили такую структуру, такое дерево, бинарное
дерево, бинарное значит, что у каждой вершины максимум
два ребенка.
Бинарное дерево, в каждой вершине записываем число,
равное сумме чисел в листьях этого поддерева, вот здесь
какое поддерево.
Вот это вот все.
Из этого листья это четыре вершинки нижние, мы складываем
числа, которые там написаны и пишем это в вершинку, в
корень этого поддерева.
Ну например, вот мы такое как-то сделаем.
Теперь давайте поймем, как отвечать на наши запросы
наших двух типов.
Поцвал и Элер.
Ну, поцвал самый простой.
Представьте, что у меня какое-нибудь опятое меняется,
оно раньше было х, а теперь станет у.
Раньше было 10, стало 7, как-то поменялось это число.
Тогда, чтобы мне корректно пересчитать все вот эти
значения, чтобы в каждой вершине было правильное
по-прежнему число, равное сумме с листьев поддерева,
тогда мне нужно поменять все такие вершины, где
участвовало опять.
То есть, если меняю только одно число, то меняются
суммы только содержащие это число опять.
Ну, а таких вершин всего 4.
Вот это, вот это, вот это и вот это.
Больше ни в каких вершинах опять не участвует.
Ни в каких суммах опять не участвует.
Значит, просто давайте пройдемся по вот этому вот восходящему пути
от этого листика до корня.
И во всех вершинах сделаем такую поправку, что если
там раньше был х, то теперь у.
То есть, по сути, сумма увеличивается на у-х.
Если у меня здесь была какая-то сумма, то она меняется
увеличивается на у-х.
То есть, я делал во всех этих точках.
Плюс равно у-х.
Плюс равно у-х.
Плюс равно у-х.
Ну, здесь не забываем тоже в листике изменить.
Плюс равно у-х.
Если у меня х как бы стерлось, а у добавилось, то это как раз разность.
Так, понятно?
Вот.
Ну и, собственно, так и будет работать наш обработка
первого типа запроса.
Мы просто идем от листика до корня.
Ну или, наоборот, от корня до нужного листика.
И меняем все суммы в соответствии с тем, как поменялось число.
Да, как бы насколько оно изменилось, настолько меняется и сумма,
в которую оно входит.
Это простой кусок.
Чуть посложнее вот эти вот запросы типа lr.
Запросы типа lr.
Так, ну давайте ответим на запрос, когда l равно 2, а r семерки.
l равно 2, а r семерки.
Наша цель это найти в этом дереве как можно меньше вершин,
которые в сумме как раз покрывают все элементы нашего отрезка lr
ровно по одному разу.
И здесь нам подойдет, скажем, вот такие две вершины.
Вот эта вершинка, которая покрывает a2 и a3, да, то есть контролирует под дерево
со второго по третий элемент.
И вот эта вершина, которая контролирует с четвертого по седьмой элемента.
И как раз если мы знаем сумму второго и третьего элемента,
а также сумму элементов с четвертого по седьмой, то если мы их сложим,
мы получим сумму как раз на нужном нам отрезке, со второго по седьмой.
Получилось вот обойтись двумя вершинками.
То есть если я как-то эти две вершинки найду, если я пойму, что отрезок 2,7
вот разбивается на эти две вершины, что он целиком контролирует
со этими двумя вершинами, то мы как бы знаем сумму.
Нужно просто два эти числа сложить.
Ну, разумеется, там можно как-нибудь по-другому покрыть.
Скажем, можно вместо вот этой вершинкой взять две вот эти.
Тогда у меня число вершин увеличится, но сумма останется той же.
Это немножко неэффективно, потому что вместо того, чтобы складывать два числа,
мы можем обратиться к их сумме.
Если мы знаем их сумму, то уже нет смысла спускаться в под дерево.
Нет смысла у вершинки брать какие-то ее детей.
То есть если мы взяли вершину, то детей уже брать не нужно.
Ну и так будет работать в общем случае.
Нам нужно будет как-то отрезок LR, на котором мы ищем сумму,
представить в виде объединения вот этих вот покрывающих вершин.
Что это какое-то под дерево покрывает 2-3, а это под дерево покрывает 4-5-6-7.
И вот нам нужно как-то найти эти вершинки, которые покрывают целиком наш отрезок.
Так, ну хорошо, давайте вот эта идея, как будет работать дерево отрезков,
давайте мы напишем все нужные процедуры.
Поймем, за сколько это работает, поймем всякую корректность.
Давайте опять, как у нас было в бинарной куче когда-то, давайте считать, что у меня вершинки
номируются последовательно целыми числями, начиная с единицы.
1, 2, 3, 4, 5, 6, ну и так далее.
Что у вершинки есть два сына, у вершинки V есть сын 2V и 2V плюс 1.
2V и 2V плюс 1.
Вот, а также давайте у каждой вершинки еще помнить, ну или как-то поддерживать,
какой отрезок она контролирует.
Вот это вот корневая вершина, она контролирует весь отрезок с нулевого по 7-ой элемент.
Дальше, ее левый сын контролирует отрезок с нулевого по 3-ий уже элемент.
То есть мы просто смотрим, все, что находится под деревья И выписываем, какие нам есть номера.
Ну это понятно дело, всегда какой-то подотрезок.
Себя какой-то подотрезок, там левая граница, правая граница.
Поэтому, также вместе с каждой вершиной мы будем как-то еще передавать,
какой именно подотрезок она контролирует.
подотрезок она контролирует. Вот я буду это обозначать TLTR, подотрезок массива,
который контролируется в этой вершиной, вершиной V. Ну и тогда, если я знаю, какой
отрезок контролируется вершиной V, то как понять, какие подотрезки контролируются
двумя сыновьями этой вершинки? Очень просто, нужно посчитать полусумму наших
чисел TLTR. Давайте я напишу прямо сразу, так как это можно писать в коде, TL
плюс TR больше больше один. Вот, ну про битовые сдвиги мы немножко уже делали в
прошлый раз. Значит, битовый сдвиг вправо на единичку, это значит, вот есть у вас
какое-то битовое число, и вы как бы, вот здесь находятся младшие биты, ну левое,
первое и так далее, и вы сдвигаете его вправо на единицу. То есть, как бы вот такое
число записываете, и просто те биты, которые вылезли за пределы вот этой
границы, за нулевой бит как бы, вы их отбрасываете. Поэтому, по сути, вы просто
избавляетесь от младшего битика и все сдвигаете на единичку. Вот эти вот
биты, это просто то, что раньше у вас было все левее, чем младший. И это как раз
деление пополам. Вы просто отбрасываете младший бит и все сдвигаете на ее место.
Это вот как раз деление пополам. Целочисленное деление пополам. То есть, если здесь было 0,
то это просто деление пополам. Если там была единичка, то мы как бы сдвинули единичку и ее
отбросили. То есть, это деление пополам с округлением вниз. Ну хорошо, тогда у левого
сына мы пишем, что отрезок,
Отрезок, который она контролирует, это tLtm, а здесь tm плюс 1tr.
Так, сразу скажу, что если вы уже когда-то видели деревоотрезков и привыкли, скажем,
писать его на полуинтервалах, когда правая граница не включена, ну вот, sorry,
я пишу на отрезках, потому что называется деревоотрезков, по крайней мере, на русском,
поэтому у меня все на отрезках. Так что если вам не привычно, ну извините. Ну понятно,
как мы говорим, что левая половина уходит влево, правая половина уходит вправо. Вот ровно это
здесь и написано, что первая половина элементов контролируется левым сыном, вторая правая. Ну
все, тогда мы готовы написать, скажем, процедуру update. Давайте сначала скажем, что пусть t в
это число, храняющиеся в этой вершине, число, храняющиеся в вершине v, то есть какая там
сумма написана? В вершине v. Тогда процедура update реализуется очень просто. Void update.
Да, давайте так и сделаем. 1, 0, n-1. Так, так, так, sorry, sorry. Нет, давайте я все-таки уйду на
другую доску. Давайте я для лобста буду считать, что я уже понял вот эту разность y-x. То есть я
понимаю, что мне нужно поменять число x на число y, и по сути мне важно только то, насколько он
изменился. Мне не важно старое значение, не важно новое. Мне нужно просто знать вот эту поправку,
поправочку y-x, насколько меняются все элементы. Давайте тогда передавать как раз эту поправку.
То есть я встаю в какой-то вершине, которая контролирует отрезок tr, tr, и мне нужно элемент
в позиции pos изменить на дельту, увеличить на дельту. Вот, значит, сначала я встаю в корня и
понимаю, что я контролирую весь массив с 0 по n-1 элемент. И мне нужно поменять там элемент в
какой-то позиции на сколько-то. Мы поняли, что мне нужно пройти, по сути, от корня до этого элемента,
и все на этом пути увеличить на дельту. Все суммы увеличить на дельту. Поэтому давайте сразу это
сделаем, что tvt плюс равно дельта. Мы увеличиваем значение в текущей точке на v, потому что сейчас
там участвует этот элемент, который изменился, поэтому сумма меняется. Ну а дальше скажем,
если мы уже спустились в лист, то есть если контролируемый под отрезок вырожденный состоит
из одного элемента, то можно сразу сделать ретёрн. Нам уже дошли до листа, мы все обновили,
больше сделать нечего. Иначе нужно спуститься в одного из двух санавей, либо влево, либо вправо.
Для этого мы найдем полусумму границ, которые мы контролируем. И это как раз вот этот tm,
это разделитель, что меньше или равнее tm уходит влево, больше tm уходит вправо. Значит,
нам нужно написать, что если pos, то есть если изменяемый элемент меньше либо равен этой границе,
меньше либо равен tm, тогда мне нужно рекурсивно запуститься от левого сына. Update v2 tail tm pos
delta. Я спустился в левого сына, у него вершинка, его номер это v2, как мы договорились. Контролирует
он подотрезок tail tm, тоже как тут нарисовано. Ну а pos и delta мы не меняем, мне нужно по-прежнему
элемент в позиции pos увеличить на delta. Так, это случай, когда нужно идти в левого сына. Иначе,
когда нужно идти вправого сына, мы запускаемся аналогично рекурсивно от правого сына. Здесь
будет v2 plus 1, потому что это его номер. tm plus 1 tr, это контролируемый подотрезок, pos delta не меняется.
pos и delta не меняются. Все, вот весь апдейт. Еще раз, мы запускаемся от корня. Давайте я
напишу, что из мейна при обработке запроса мы запускаемся от корня. Update 1, 0, n-1, pos delta.
pos delta. Мы стартуем в корне, который контролирует весь массив, то есть весь
подотрезок с нулевого поэнонсферого элемента. И как-то там спускаемся, каждый раз понимая,
нам нужно идти в левого сына или вправого. Вот если pos не больше половинка элементов,
то есть находится как бы в левом сыне, то мы туда идем, иначе нужно идти вправо, туда идем.
Так, есть ли вопросы по этому кусочку? Хорошо, тогда давайте здесь же сразу заметим, что время
работы этой процедуры логарифмично по n, потому что если мы построили вот такое наше бинарное
дерево, на нижнем уровне которого n листьев, а дальше как бы у меня все постоянно делится пополам,
то есть я объединяю пары вершин на предыдущем уровне, и так дальше поднимаюсь. У меня число
вершин каждый раз уменьшается вдвое, на каждом уровне при подъеме вверх. Значит,
уровне логарифмичное количество, уровне всего логарифм, глубина моего дерева логарифм. Ну,
а значит, поскольку я по сути просто спускаюсь как-то от корня до листика, значит время
работы логарифмично, просто не больше, чем глубина дерева. Так, хорошо, теперь давайте напишем сумму.
Теперь давайте напишем int getSum. Значит, опять мы находимся в какой-то вершинке
которая контролирует tail-to-air, отрезок tail-to-air, и нам нужно найти сумму с подотреска LR.
int L, int R. Нужно найти сумму на отрезке LR. Запускаться мы также будем от корня,
мы стоим в корне, нам нужно в каком-то отрезке найти сумму. Самый простой случай, самый идеальный
случай, это когда мы пришли в вершину, целиком совпадающую с нашим отрезком. Если TL равно L и
TR равно R. То есть мы пришли в вершину, в которой хранится точно то число, которое мы ищем,
хранится вершина равная сумме элементов с L-to-Apr. Давайте просто его тогда вернем, раз нам нужна эта
сумма, то давайте просто ее вернем в качестве ответа. На это и будет то, что нужно. Иначе, иначе,
мне опять нужно потенциально разветвиться налево и направо сына, понять, куда нужно идти. Вот это
мы сейчас тоже сделаем. Значит, считаем опять наш разделитель, полусумму координат TL-TR.
Ну и давайте здесь же мы заведем переменную ответ равной нулю. ans равно нулю. И дальше может быть
следующее, может быть такое, что мне придется разветвиться в обоих сыновей. Ну, например,
давайте какую-нибудь такую картинку нарисую. Вот есть вершина, есть отрезок, которые она
контролирует, а мне нужна какая-то вот такая сумма. Тогда я частично задеваю как бы левого сына и
соответственно частично задеваю правого сына. То есть мне может быть нужно спуститься и влево,
и вправо как бы. Мне нужно разветвиться и туда, и туда. Если раньше я спускался только в одну из
двух веточек, то здесь, возможно, придется в обе. Ну ничего страшного, в обе мы тогда и спустимся.
Значит, что значит, что нам нужно идти влево? Это значит, что хотя бы один элемент нашего
массива находится влево под деревом. Ну, это то же самое, что просто самый левый элемент массива
находится в этом по дереву. Поэтому если у меня в принципе хоть кто-то лежит слева, тогда мне
нужно к ответу прибавить getSum от левого ребенка. Так, давайте продолжим. Левый ребенок сдается
такими координатами. А дальше нужно как-то сузить отрезок LR на то, что остается. Если есть такое
частичное затрагивание левого сына и частичное затрагивание правого сына, то у меня отрезок
LR, когда я спускаюсь к левому сыну, немножко меняется. У него левая граница остается,
а правая она становится просто Tm. Потому что вот этот кусок как бы отбрасывается. Поэтому давайте
здесь напишем такие границы. L минимум из R и Tm. Ну, тогда как раз если отрезок лежит
частично слева и частично справа, то из этих двух чисел минимальным будет Tm. И граница как
раз вот будет там же, где заканчивается граница вот этого левого сына. Иначе, давайте другую
картинку в этом же месте. Если мой отрезок, на котором я ищу сумму, далеко лежит в левом сыне,
вот что-то такое, тогда у него нелиньер не надо менять, просто мне нужно найти ответ с левого сына,
а вправо я даже не пойду. Вот, поэтому тогда минимум из R будет равен R, и я просто нахожу
сумму на целиком на этом отрезке. То есть тут два случая. Так, ну и нужно еще понять, нужно ли нам
идти вправого сына. Здесь уже будет не else, а отдельный if. Если имеет смысл идти вправого сына,
то есть правая граница отрезка попадает вправо в правого сына. Если R больше, ну давайте так
и напишем, если R больше равно tm плюс 1. Если хоть кто-то из отрезка LR лежит в правом сыне,
тогда нам придется дойти, и мы запускаемся рекурсивно от этого правого сына. GetSum значит
v2 плюс 1. Отрезок контролируемый это tm плюс 1 tr. Ну и здесь тоже надо как-то сузить наш отрезок,
на который мы ищем сумму. Можно написать так. Максимум из L и tm плюс 1, запятая R.
Ну, то же самое. Да, как бы у нас, если отрезок частично слева, частично справа, то его правую
границу нужно оставить на месте, а вместо левой написать tm плюс 1. Да, потому что tm плюс 1,
то вот левая граница правого сына. Если же отрезок LR целиком лежит справа, то тогда этот
максимум будет просто равен L, и отрезок наш не нужно менять, все хорошо. Так, ну и в конце нужно
написать return ans. Return ans, и скобка закрывается. После того, как вернули ответ. Вот, то есть по
сути алгоритм, ну вот прям максимально тупой, да, он что делает? Он говорит, что если мы ищем то,
что нужно, то есть если мы знаем то, что нужно, то мы это сразу возвращаем. Иначе мы говорим,
ага, ну значит нам нужно куда-то спуститься. Давайте поймем, нам надо идти влево. Если надо,
то спускаемся и находим сумму на соответствующем подотрезке. Если надо вправо, то тоже спускаемся,
там находим сумму и их складываем. То есть как-то учли сумму слева сына, как-то справого,
их сложили и вернули в качестве ответа. То есть просто рекурсивно спустились в детей. Понятно?
Вот. Ну, оказывается, что даже такой наивный алгоритм, который в общем-то довольно простой,
он работает тоже за алгоритм на запрос. Значит, это мы сейчас докажем.
Давайте я напишу так, где-то сам 0 запятая n-1 запятая lr, то есть когда я запускаю под
корня в поисках суммы на каком-то отрезке lr, работает, ну здесь уже от log n, что у нас
оценка логарифа. Возможно, он даже, он иногда отрабатывает за от 1, если не нужна сумма на
всем массиве, скажем, он просто смотрит в корень, понимает, что в корне хранится сумма со всего
отрезка, ее возвращает, никуда не спускается. То есть если, скажем, отрезок очень крутой,
то это может работать даже быстрее, чем логариф, быстрее, чем логариф. Но обычно, конечно,
обычно, конечно достигается вот логарифа. Ну не важно. Значит, почему отработать за логарифом?
Почему вообще-то может не работать за логарифом? Проблема в том, что мы можем offer вершинки пойти
и влево, и вправо. Раньше у нас было хорошо когда мы писали апдейт. Мы спускаемся к каждой вершине
только либо влево, либо вправо и тогда время работы пропорционально просто ну длине пути,
как мы спускаемся, это максимум логарифа, максимум глубина. А здесь мы в какой-то вершине
можем пойти и влево, и вправо. И тогда, ну а кто нам сказал, что мы не будем витвиться как бы
полностью вообще, почему мы не пройдем все дерево, например. Ну, например, по следующей причине.
Давайте посмотрим, как именно наш алгоритм GetSum спускается по дереву. Вот он как-то встал в корень
и идет, идет, идет, идет. Давайте посмотрим первый несколько шагов, пока он не витвится,
пока он из этих двух запусков делает только один, либо левый, либо правый. Вот как-то он так
спускался. Потом дошел до первой вишенки, где пришлось разветвиться и пойти рекурсивно и влево,
и вправо. Что это значит? Это значит, что отрезок, на котором мы ищем сумму, он частично лежит,
давайте я нарисую под дерево вот так, который я контролирую с этой вишенкой В. Тогда, значит,
отрезок, на котором нам нужна сумма, он какой-то такой. Он частично слева, частично справа.
Тогда мне нужно разветвиться. Ну вот я разветвился. А дальше смотрите, какой интересный факт,
что если я нахожусь где-то вот здесь вот, и мне, скажем, приходится опять витвиться,
то я уже от правого сына вниз спускаться рекурсивно не буду. Еще раз, давайте я сейчас
фокусируюсь только на левом поддереве, то, что слева. Если я нахожусь здесь в какой-то
вершинке, и мне опять нужно разветвиться, пойти и влево, и вправо, то тогда из правого сына я
уже обязательно точно не буду витвиться. Потому что, что значит, что я вот здесь, давайте я введу
эту букву У. Что значит, что я в вершинке У разветвился? Это значит, что у меня, так давайте я немножко
перенесу, вот так. Это значило бы, что у меня частично отрезок, на который мы ищем сумму,
попадает в правого сына У, и частично влево. Но тогда это в частности значит, что когда мы
спускаемся в правого сына, мне нужно просто взять в нем сумму, и нам нет смысла спускаться ниже,
чем вот этот правый сын. Потому что мы понимаем, что правая граница у меня сейчас вот здесь,
и если я спустился и сюда, и сюда, то получается, что мне нужно целиком вот этот овальчик, и еще
что-то слева. Ну, значит, мне нет смысла спускаться ниже, чем вот этот правый сын. Я до него дошел,
и дальше вниз никуда не пойду. То есть, если я вот в этом левом поддереве, вот здесь, когда-то и
ветвлюсь, или ветвлюсь, да, наверное, если я когда-то поветвился, тогда правый сын больше не дает потомков.
То есть, я как бы поветвился, а здесь тогда уже у меня будет пустая ветка. Поэтому, на самом деле,
каждое ветвление, оно, по сути, это только движение влево. То есть, я как бы взял сумму
справого сына, а рекурсивно, содержательный рекурсивный запуск у меня только из левого сына.
Опять там может быть какое-то ветвление, или там просто втуск влево. Короче, что-то сложное, но главное,
что каждое ветвление порождает только одну содержательную ветку. Правое сразу заканчивается.
Понятная идея? То же самое у меня находится в правом поддереве. Если я вот от В разведвился,
и в какой-то момент там как-то прошел, и у какой-то вершинки W опять разведвился, пошел и влево,
и вправо. Но это значит тогда, что от левой вершинки я никуда вниз не пойду, да, потому что у меня
целиком этот отрезок меня интересует. Вот, я его добавляю к ответу. Значит, из левого сына W
я вниз никуда не пойду. Я могу пойти вниз рекурсивно только от правого сына. Значит, по сути,
у меня, ну скажем так, спуск куда-то вправо вот здесь, и спуск куда-то влево вот здесь. То есть,
по сути, у меня просто два спуска после того, как я дошел до вершинки W. Поэтому число вершин,
которые я рассматриваю, оно по-прежнему логарифмично от глубины дерева. Никогда не может быть, ну то есть,
вот здесь мы, собственно, показали, что если я разведвился здесь, то я дальше не пойду в одну из
дверь. Ну все, поэтому как бы это не то, что там какое-то очень широкое ветвление, а обычно,
если я и поветвился, то одна из веток мертвая. То есть, я там спустился вниз и дальше никуда не
пойду. Вот, поэтому время работает действительно логарифмично. Число вершин, число посещенных
вершин есть от log n. Ну все, число посещенных — это как раз время работы алгоритма. Все,
поэтому мы работаем за логарифм. Вот, и на этом мы нашу задачу, собственно, решили. Нашу задачу
обновления в точке и сумма на отрезке мы решили. Так, есть ли вопросы по этой части?
Хорошо. Тогда идем дальше. Давайте рассмотрим вторую задачу. Это каты 0 на отрезке.
Каты 0 на отрезке. Задача такая. Есть у вас опять массив чисел а0 и так далее, а n-1. Только давайте
считать, что все числа — это нули и единицы. Нули и единицы. И поступают опять два типа запросов.
Первый — это update в точке, то есть изменение в точке по значению pos и значению val. Мне
нужно pos-элемент поменять на val, сделать такое присваивание. Второй тип запроса — это найти
каты 0 на отрезке. То есть вам сообщают какой-то подотрезок lr, а также число k. И вы вот рассматриваете
ваш отрезок с l to the power element и как бы должны при счете слева направо найти среди нулей каты.
То есть у вас там, не знаю, куча единиц, встретился 0. Это был первый 0. Потом опять куча единиц,
второй 0 и так далее, и так далее. Вам нужно найти каты 0. Ну, позицию катова 0, в смысле позицию.
Найти позицию катова 0 на отрезке lr. Вот. Хорошо, такая задача. Тоже ее мы сейчас решим с помощью
деревоотрезков. Так, давайте теперь в вершине. Если мы раньше в вершине хранили сумму из листьев
под дерево, то давайте теперь хранить количество нулей среди листьев под дерево. Теперь у меня t
от v. Это количество нулей среди вот этих вот чисел a с индексом tl, a с индексом tl плюс 1 и так
далее, а с индексом tr, где tl tr это отрезок, который соответствует вершинке v. Тл tr. Количество
нулей на вот этом отрезке. Тогда, смотрите, нашу задачу можно немножко упростить. Можно, во-первых,
по сути, откинуть правую границу. Можно откинуть правую границу. Потому что, что значит, что мы
ищем каты 0 на отрезке? Ну вот есть у меня какое-то начало l, да? Тогда, по сути, мне нужно просто идти
отсюда слева направо, и каждый нулик, который мы видим там, увеличивает счетчик. Когда счетчик
дошел до k, нужно вывести текущий нуль. Поэтому, по сути, правая граница мне не нужна. Правая
граница нужна только для того, чтобы понять, а есть ли вообще на этом отрезке k нулей. То есть,
если я вдруг иду-иду-иду и в поисках каты 0 вышел за отрезок, вот здесь стоит каты 0, то тогда нужно
сказать, что на нашем отрезке l-r каты 0 просто нет. То есть, по сути, r, она у нас только такая
декоративная, что если мы найдем просто каты 0 в порядке прохода от l-того элемента, то нужно
будет просто его позицию сравнить с r-кой. Если она больше, чем r, то, значит, он вылезает за наш
отрезок. Поэтому r нам, в принципе, не очень важно. Поэтому, по сути, достаточно искать
каты 0 просто от l-того элемента и до конца массива. То есть, нам это r, в принципе, не важно,
мы просто если найдем каты 0 на отрезке от l до конца, то мы просто сравним эту позицию с r-кой,
если она меньше или равна, то мы его нашли. Если больше, то, значит, просто там нету
стольких нулей. На отрезке l-р нету стольких нулей. Это первое замечание. Второе замечание в том,
что на самом деле и l-та мне особо не нужно. Потому что, смотрите, что мы сделали? Что мы
делаем точнее? Вот есть у меня l-тая позиция. Я иду как бы отсюда слева направо в поисках каты 0.
Но тогда, смотрите, если я найду число 0 вот здесь вот на префиксе, не включая l-тый элемент,
если я знаю, что здесь, скажем, m нулей, то поиск k-того нуля, начиная с l-того элемента,
каты 0, это, по сути, просто поиск k плюс m-того нуля с начала массива. Но если мы знаем,
что здесь их m, а здесь мы находим каты, то, по сути, мы просто ищем k плюс m-тый сначала.
Значит, и l-та нам тоже не особо важно. Итак, чтобы найти каты 0, начиная с l-того элемента,
каты 0, начиная с l-того элемента, достаточно найти m плюс l-тый 0, sorry, m плюс k-тый 0,
m плюс k-тый 0 с начала массива. Ну где m, это вот как раз количество нулей от нулевого элемента
до l-1. Вот. Ну отлично. То есть, по сути, нам теперь что достаточно сделать? Мы стоим в позиции l,
считаем количество нулевого отрезка от 0 до l-1. Это мы умеем делать с помощью нашего дерева
отрезков. Если у меня в вершинке хранится число нулевого отрезка, то, по сути, как раз мне
нужно там как-то спуститься точно так же, как мы искали сумму. Также у меня здесь будет в вершинке
хранится число нулей, тогда я на этом отрезке могу найти число нулей. То есть, как я раньше
считал сумму, так теперь считаю число нулей. Так вот, я нашел это количество нулей, нашел m,
а дальше мне нужно уже независимо от отрезка lr, то есть все, я про lr забываю, мне нужно просто во
всем массиве сначала с нулевого элемента найти вот такой вот 0, 0 с таким номером. Вот, хорошо.
То есть, теперь мы как бы забываем про то, что у нас была задача на подотреске, мы решаем задачу
на всем массиве. Просто нам нужен 0 с каким-то номером от начала массива.
Давайте я его назову k-большое, k и 0 от начала массива. И здесь нам тоже понадобится дерево
отрезков. Ну, пригодится скорее. Смотрите, идея следующая. Вот есть у вас корень нашего дерева,
который контролирует весь массив. Есть левый сын, есть правый сын. Тогда понятно, что если в левом
поддереве, то есть вот в поддереве, которое контролируется левым сыном нулей хотя бы k, то есть
если вот это вот число хотя бы k, тогда ответ точно в нем. Понятно, что k и 0 тогда лежит в
левом поддереве. Если здесь хотя бы k, то он точно там. Иначе, если их здесь меньше, чем k, то мне
нужно из k вычесть количество нулей, которые здесь лежат, и перейти вправо. Например, если k равно
тройке, а здесь мы знаем, что слева находится 2 нуля, то мне нужно искать просто первый 0 вот здесь.
Понятно? Просто как бы k и 0. Если здесь их меньше k, то мне нужно вычесть то количество, сколько их
здесь есть из k, и искать теперь уже с новым значением k, k и 0 в правом поддереве. Ну и, собственно,
код будет ровно такой. Мы сначала пытаемся понять, есть ли слева хотя бы k нулей. Если есть,
тогда идем в лево просто. И в левом сыне пытаемся найти k и 0. Иначе спускаемся вправо,
уменьшая k на число нулей из левого поддерева. Давайте я пару строчек напишу. Значит, находясь
в вершине v, мы смотрим, если k больше или равно, чем t от 2v, то есть чем число нулей в левом сыне,
тогда просто return, ну то не знаю, get, я не буду писать целиком название функции, там get, get,
k, 0. Идем в левого сына просто с его координатами t, l, t, m в поисках того же k нуля. Иначе,
значит, нужно пойти в лево, в правого сына, извините, в правого сына v на 2 плюс 1. Отрезок,
который он контролирует, это tm плюс 1 tr. Ну и теперь мы ищем не k и 0, а k минус t от 2v. Вот
такой вот 0 мы ищем, потому что слева ровно столько нулей, мы их все отбрасываем, ищем 0 с таким
именом. Вот такой алгоритм, он работает, понятное дело, за алгорифм, за алгорифмическое время от
глубины дерева, потому что это просто спуск. Мы стоим вот здесь и идем либо вправо, либо влево.
Здесь уже нет никаких дилем, что мы когда-то ветвимся, мы всегда спускаемся в одного из двух
сыновей, либо влево, либо вправо. И заканчиваемся как раз в тот момент, когда мы дошли до искомого
листа, где написан k и 0 в нашем массиве. Так, есть ли вопросы по этому куску?
Да, ну, значит, вопрос такой, что делать, если длина массива не степень двойки? Ну на самом деле
ничего не меняется, вот тот код, который я писал, он работает для любого n, даже если n не степень
двойки. Там меняется только то, что у вас, ну, вот то деление, которое я пишу, да, tl плюс tm пополам,
tl плюс, сори, плюс tr пополам. Оно, то есть у нас, если у меня всегда степень двойки, то это всегда
делится пополам. И там вот прям все идеально, такое красивое дерево, у каждой вершинки ровно
два сына, кроме листьев. Если n не степень двойки, то ничего не поменяется в плане кода, просто эта
штука, ну, то есть эта штука может быть нечетная. Давайте пример нарисуем, значит, что происходит,
если n равно 3, например. Тогда у меня корень контролирует отрезок 0,2, левый сын контролирует,
видимо, отрезок 0,1, а правый 2,2. Здесь, соответственно, 0,0, 1,1. То есть единственное,
что меняется, да, это что у меня не все листья на одной глубине получаются. Короче, ничего не
поменяется, на самом деле, в плане кода, потому что у вас все равно, мы все равно договариваемся,
что в левом поддереве находятся элементы стельтова по тмтой, в правом стм плюс первого по тр. Ну и тогда,
в общем, все то же самое работает, просто даже глубина может, ну, в каких-то моментах вы доходите
не до там, не до log n, а до log n минус 1. Каких-то листьев глубина просто меньше. Поэтому это работает,
на самом деле, для всех n. Вот, но если вам хочется прям красивую структуру, то всегда можно сделать
так. Всегда можно добить ваш исходный массив до ближайшей степени 2, просто увеличивать его длину,
пока она не станет степенью 2. Ну и тогда считаю, что ваше дерево прям очень красивое и в нем
выполняется все, что вы хотите. Так, окей. Дальше я хочу поговорить про отложенные операции.
Задача такая, опять есть массив, а 0, а 1 и так далее, а n минус 1. Поступают опять два типа
запроса, в первых из которых сумма на отрезке, давайте я вам напишу так, сумма lr, нам нужно найти
сумму чисел с l по r элемента. Второй запрос это assign на отрезке, то есть делать присвоение на
отрезке lr числа x. Вам нужно все числа на отрезке с l по r заменить на одно и то же x.
Если раньше мы делали update в точке, если мы раньше делали изменение в точке, то теперь может быть такое,
что изменение происходит на целом отрезке, ну и причем оно одинаковое, все числа обновляются
x. Все старые числа забываются, вместо них везде пишется x. И опять нужно отвечать на сумму на отрезке.
Так, здесь появляются отложенные операции, это значит концепция примерно следующая. Смотрите,
мы понимаем, что если мы вот эти вот assign, вот эти присвоения будем делать в тупую, то есть,
честно, для каждого элемента l, l plus 1, l plus 2 и так далее и так далее, вплоть до r, будем вызывать наш
update, вот как было раньше, тогда это может работать долго, потому что если длина отрезка большая,
то мы вызовем много апдейтов. У нас время обработки запроса будет не логарифмическое,
оно будет пропорционально длине отрезка, еще множество логарифм. В общем, слишком долго.
Значит, вместо этого мы будем делать такое. Мы будем в каких-то вершинках тебе делать такую
пометку. Ну, я напишу, давайте promise. Promise равно x. Это значит, что мы себе пообещали когда-то в
будущем присвоить всему поддереву, ну, точнее, всем листиком этого поддерева число x. То есть,
у нас когда-то поступил запрос, где нам нужно все это поддерево присвоить равным x, все эти
элементы сделать x. И мы как бы этого не делаем сейчас, но пообещаем себе обязательно это сделать
когда-то в будущем. Мы это запомнили, мы это записали, пообещали себе это сделать. Promise равно x.
И дальше, в будущем, если мне понадобится вдруг спуститься вниз из этой вершинки, если я рассматриваю
какой-то вот такой запрос, скажем, тогда мне нужно пойти вправо из этой вершинки. Тогда давайте я
эту отложенную операцию, да, отложенную на будущее, сейчас протолкну. Я передам информацию об этом
промесе и в левого сына, и в правого сына. Ну, благо, передается она очень просто. Если я когда-то
пообещал себе положить все эти элементы равными x, то я могу просто этот же самый promise сюда
переписать. Promise равно x, promise равно x. Ну и сумма тоже себя, понятное дело, как ведет. То, что я
t-шкой обозначал, сумма в поддереве, очевидно, как себя ведет, если все элементы равны x.
Если все элементы в поддереве равны x, то сумма понятна какая-то. Просто x умножить на размер
поддерева, на количество листиков в нем. Значит, протолкнуть эту операцию очень просто. Мы обновляем
promise, который тут написан, обновляем сумму. В общем-то и все. Нам важно, что мы затираем информацию,
которая лежала в этой вершинке. Там могло лежать что угодно, какая угодно сумма, какой угодно
promise, но главное, что они были поставлены до того, как пришел вот этот promise. И когда я
его протолкиваю вниз, когда вот эта операция приходит, и мне нужно ее протолкнуть вниз,
я затираю все, что было раньше и сообщаю новую информацию, что все элементы там равны x.
Давайте напишем несколько строчек, как это все формально работает. Уточню, у меня есть массив
promise. Так, promise, кстати, вроде плохо называть. Давайте я буду написать pro, потому что, кажется,
promise есть ключевое слово такое, ну или там, или вы стоили. В общем, не будем так делать. Pro от v
— это отложенная операция вершины v. T от v — это, как всегда, сумма. T от v — это сумма. Во-первых,
давайте напишем микропроцедуру, которую назовем push. Void push — это операция проталкивания
информации, которая хранится в этой вершине, в ее детей. Мы стоим в какой-то вершинке, она
контролирует отрезок TLTR, и мне нужна информация, вот эта промость, которая там стоит, передать
детей. Информацию передать детей. Так, ну вот здесь небольшой хак давайте сделаем, себе облегчим
жизнь и скажем, что вот эти s-сайны нам, когда приходят, они всегда не отрицательны, все x всегда
не отрицательны. Тогда в промесе давайте будем хранить минус один, если там нет никого промеса,
то есть на самом деле в этой вершинке ничего не меняется, ее нужно оставить вот как она была.
Поэтому если промес равно минус 1, то есть в этой вершине нет никаких изменений, там никакой
сайн не приходил или мы его уже обработали, то мы просто делаем ретерн, нам ничего не нужно
делать, мы всю информацию и так передали, ничего делать не надо. Вот, ну это я так вольно себе допустил,
что все x не отрицательны, если они могут быть отрицательны, то это не работает, потому что
минус 1 может быть знаком того, что нужно минус 1 присвоить во всем падении. Вот, ну тогда нужно
хранить какой-то булевский флаг того, что протолкнули мы уже или нет, протолкнули или нет, то есть нужно не
только хранить число, которое надо протолкнуть, но и булевский флаг того, надо это делать или нет,
потому что если уже протолкнули, то больше не нужно делать. Вот, ну а иначе нужно и влево сына,
и вправо сына передать информацию об этом промесе. Так, давайте для удобства я введу
переменную x равную промесу от v. Ну и вот теперь сделаю с детьми то, что нужно.
Я посчитаю сначала границы, то контролируется каждым сыном, и теперь давайте посмотрим на то,
что такое сумма, скажем, левого сына. Что такое t от v2? Это x умножен на размер под дерево.
x умноженный на tm-tl плюс 1. Если мы все равно знаем, что каждое число там равно x,
то сумма равна просто этому числу умножен на длину. Тоже самое с правым сыном, t2v
плюс 1, это x умноженный на, здесь будет tr-tm, потому что у меня отрезок начинается в tm
плюс 1, заканчивается в tr, значит его длина как раз вот такая разность. Не забываем передать
сам промес. Промес v на 2 равно, давайте я вот так напишу, промес v на 2 плюс 1 равно x. Вот такая
строчка с двумя равенствами работает так, что мы один и тот же x присваиваем и сюда, и сюда.
Один и тот же x присвоили и сюда, и сюда. Ну и в конце говорим, что мы этот x протолкнули,
говорим, что промес от v равно минус 1. Промес от v равно минус 1, то есть мы все сделали больше,
этот x протолкнуть не нужно. Вот это как раз соответствует тому случаю, когда здесь была
какая-то операция, не как бы, которую мы себе пообещали сделать, но еще не сделали. Вот давайте
я ее сейчас сделаю и детям передам эту информацию. Так, ну теперь на сумму надо ответить, на запрос
суммы. GetSum. Давайте сначала Assign сделаю, я что-то забыл. Мне нужны отрезки в вершине v,
на каком-то отрезке lr и числа заменить на x. Вот так Assign сначала сделаем, потом GetSum.
Есть вершина, мне нужно в каком-то подотрезке присвоить x всем элементам. Опять самый простой
случай, это когда мы пришли в вершину, совпадающую целиком с тем, ну в общем, с тем отрезком,
которым мы ищем. Ну тогда что нужно сделать? Нам нужно на всем отрезке присвоить x, то есть в
частности нужно сказать, что pro от v это x, что мы этот x как бы сюда положили и в будущем, если что,
мы эту информацию передадим детям, что на всем этом подделье присвоены x. Ну и также нужно
написать сумму, что t в это это x на длину отрезка. tr-tl плюс 1. Return.
Если мне нужно во всем подделье присвоить x, то я запоминаю эту информацию в промесе,
обновляю сумму и заканчиваюсь. Причем здесь, например, важно, что если там уже был какой-то
промес, если там лежала там операция, что раньше пришел запрос, который все числа в этом подделье
присвоил равными y, то тогда я просто эту операцию затираю и забываю про нее, она мне нафиг не нужна.
Если я раньше все числа присвоил y, а теперь переприсвоил x, то мне этот y уже вообще не нужен,
да, и соответственно старое значение pro от v уже меня не интересует. Так, хорошо, это простой
случай. Сложный случай, когда нужно опять в ветвице идти там влево или вправо. Для этого,
перед тем как в ветвиться, я вызову push. Push v tr. И как раз я себе пообещал, что каждый раз,
когда я прихожу в вершину, в которой есть как бы непереданная в детей отложенная операция,
промес, да, здесь какой-то лежит, мне нужно сначала, перед тем как идти в детей, сначала ее протолкнуть.
Чтобы пойти в детей, мне нужно сначала сделать вот то, что написано в этой вершинке. Поэтому пишем
сначала push. Вот, ну дальше там считаем опять полусумму t и l, t и r пополам. И пишем тот же кусочек кода,
который у нас был в гетсами, что если у нас хоть кто-то лежит слева, то мы запускаемся слева,
в левого сына. Если хоть кто-то справа, то идем вправо. Значит, если l меньше равно tm,
тогда нужно сделать assign в левом сыне. Это параметры левого сына, это координаты отрезка,
да, что левый у меня не меняется, а правый может уменьшиться, если он был слишком большой,
то он уменьшается до tm. x у меня не меняется. И аналогично вправо сына идем, что если хоть
кто-то есть справа, то есть если есть хотя бы один элемент, лежащий в правом по дереве,
тогда мне нужно запустить аналогичную функцию assign от правого ребенка с соответствующими параметрами.
Вот, запустился в лево, запустился вправо. Здесь еще нужна одна строча в конце, скажите,
пожалуйста, какая? Что вот если я запустился от левого ребенка, передал туда информацию,
что что-то нужно там присвоить x, у правому передал, что что-то нужно присвоить x,
что нужно сделать в конце, чтобы у меня можно было завершить этот запуск.
Ой, нет, ну спасибо. Ну а Саня ничего не возвращается, да, это функция,
я не знаю, что возвращать. Что-что? Ну она и так здесь до минус 1. После push она обязательно минус 1.
Что? Да, все верно. Значит, мы что сделали? Мы поменяли что-то слева, поменяли что-то справа,
но мне нужно не забыть, что в вершинке v должен быть правильный результат. Мне нужно написать,
что t от v равно t от v на 2 плюс t от v на 2 плюс 1. Вот, и на этом мы можем закончиться после вот
этой вот строчки. Чтобы доказать корректность, надо сформулировать утверждение в стиле,
во-первых, если мы дошли до вершинки v, то в нем лежит правильное значение t от v. И потом,
если мы запустились вот этим вот assign от вершинки v и целиком обработали левое и правое поддерево,
то опять по выходе из этой вершинки у меня t в это будет правильным как бы обновленным значением,
потому что я обновился слева, обновился справа, там по предположению индукции тоже все корректно
сработало. И теперь, чтобы правильно склеить ответ в родительскую вершинку, мне нужно сложить вот
то, что лежит слева и то, что лежит справа. Вопросы? Хорошо. Ну время работы здесь тоже понятно
логарифмическое, потому что код здесь практически такой же, как был в GetSum. Да,
я здесь делаю какие-то штуки за вот единицы и потом, если что, витвлюсь направо и налево. И опять,
эти витвления, они такие, что суммарно вы пройдете только от log-in вершин. Так,
тогда GetSum писать не будем. Я напишу просто, что там в одном месте нужно сделать push в функции
GetSum. Перед тем, как спускаться в детей, нужно сделать push. Перед спуском в детей нужно вызвать push.
Потому что, еще раз повторю, push работает так, что мы себе когда-то, мы когда-то прошли вершинку
v и пообещали себе, что нужно во всем поддереве написать какой-то x. И если мне нужно вдруг пойти
вниз и работать с поддеревом, то понятно дело, что эту отложенную операцию, которую я себе когда-то
пообещал сделать, нужно сейчас сделать. Потому что я начинаю работать с поддеревом, но уже небольшой
черный ящик, а там как-то подразбивается налево и право сына и так далее. Мне нужно вот эту
информацию передать в детей. То, что я себе когда-то пообещал, вот сейчас сделать. Немножко на
амортизационный анализ. Похоже, что то, что я себе пообещал раньше, я делаю сейчас. Вот эту
информацию передаю сейчас. И всегда за этим нужно следить, что если вы вдруг из-за вершины
спускаетесь вниз, то обязательно перед этим нужно запустить push. Так, ну вот,
такие отложенные операции есть. Ну и здесь, соответственно, тоже можно кучу всяких модификаций
делать, что там можно делать не присвоение на отрезке, а там, скажем, увеличение, что все числа нужно
увеличить на x. Можно там делать, не знаю, всякие max равно. То есть, если все числа, которые были
меньше, чем x, заменить на x, а те, которые были больше собраны на x, а их оставить x. В общем, всякие
такие кучу-кучу разных запросов можно делать. Вот на семинарах посмотрите подробнее, какие они
бывают, в каких задачах это нужно и так далее. Так, следующая, что я хочу рассказать, это тоже
интересная штука. Это количество чисел на отрезке, значения которых лежат в отрезке.
Так, что это значит? Это значит, что у нас, кстати, теперь появляется статический массив. Статический
массив, то есть не изменяющийся, а 0, а 1 и так далее, а-1. И есть всего один тип запросов такой. У вас
приходит 4 числа lr и x-еверик, и вам нужно на отрезке с l этого числа по r это число найти количество
чисел, которые большеclip равно x и меньшеclip равно y. Формально нужно найти количество k, таких что l
меньше clip равно k, меньше clip равно r, и при этом x меньше clip равно akata меньше clip равно y. Вам
нужно вычислить как бы под отрезок, найти количество чисел меньшеclip равных чем что-то, и при этом
больше бранных, чем что-то другое.
Это нам, например, позволит считать количество различных
чисел на отрезке.
Можно находить количество различных чисел на отрезке.
Вот скажем, вам опять вычленяет какой-то отрезок с L2R2-элемент,
вы там видите, ага, вот единица входит сколько-то
раз, там двойка сколько-то раз, тройка сколько-то раз,
четверка, скажем, не входит ни разу, пятерка сколько-то
раз и так далее.
И вот вам нужно узнать, сколько чисел входит хотя бы один
раз.
Да, без учета как бы кратности вхождения.
Понятно, что суммарно они входят все R-L плюс один
раз.
Но вот если не учитывать кратности, то сколько различных
туда входит.
Вот это тоже либо успеем на лекции, либо останется
на семинарах.
Итак, здесь тоже есть одно, видимо, упрощение как минимум,
что давайте мы вот такой запрос, когда у меня есть
ограничение и снизу и сверху, мы его преобразуем только
к запросу, когда есть ограничение снизу.
Давайте так напишем.
Количество чисел, принадлежащих отрезку от х до у, равно количество
чисел, больше или равных чем х, минус количество
чисел, больше или равных чем у плюс один.
Ну, очевидно, числа в отрезке это либо, с одной стороны,
они больше или не чем х, с другой стороны, из них
нужно вычесть те, которые больше или не чем у плюс
один.
Считаем, что все числа целые, то есть плюс и единичку
можно добавить.
Задача про отрезок х и у на самом деле сводится
к количеству чисел на отрезке, которые больше
или равных чем что-то, чем какая-то нижняя граница
х.
Ну или там для удобства можно было бы наоборот ограничиться
верхней границей, что это количество чисел, меньше
или равных чем у минус количество чисел, меньше
или равных чем х минус один.
Вот можно так, можно так, давайте сделаем сначала
вот такую штуку.
Здесь нам понадобится, ну давайте я напишу, что можно
называть там деревом мёрч сорта, мёрч сорт, вот,
или это ещё называется fractional cascading, fractional cascading.
Идея следующая, давайте вспомним, как у нас работал
мёрч сорт, ну вот в плане рекурсии, что есть у меня
там на верхнем уровне весь мой массив длинный, потом
он разбивается на два кусочка, как-то сортится его левая
половинка, правая половинка, потом они склеиваются
в один большой массив на верхнем уровне.
Так вот давайте всю эту рекурсию так распишем,
мы когда-то это уже делали.
И давайте, сейчас я нарисую, окошки все.
Давайте как бы промоделируем поведение этого алгоритма
снизу вверх.
Вот на нижнем уровне у меня, когда рекурсия доходит,
она доходит просто до одноэлементных массивов а0, а1, а2, ну и так далее.
В каждой ячейке будет просто массив из одного элемента,
а6, а7.
Дальше мне, как работает алгоритм, как он работал,
он вот этот массив из двух элементов разбил на два,
а теперь сливает обратно эти два элемента в этот
массив длины 2.
Так давайте мы какой-нибудь пример сразу напишем, чтобы было понятно.
3, 5, 1, 0, 4, 2, не знаю там, что остается.
Вот, значит, тогда мерч-сорт будет работать так.
Мы вот эти два элемента, ну вот запускаем процедуру
мерч, которая склеивает как бы два отсортированных
массива.
Здесь будет 3, 5.
Дальше здесь будет 0, 1, мы склеиваем 1 и 0, получаем
отсортированный 0, 1, здесь будет 2, 4, здесь будет 6, 7.
Чтобы склеить вот эти два массива, мне нужно, ну
вспоминаем, два указателя, один здесь, другой здесь,
выписываем каждый раз минимальное число и избегаем указатель
направо в том массиве, откуда выписали.
Значит будет 0, 1, 3, 5, здесь будет, ну здесь вообще
без заменения, 2, 4, 6, 7.
Теперь вот эти два массива, чтобы склеить, мы сначала
записываем вот этот, потом 1, потом вот это минимальное
число будет 2, потом здесь, потом здесь, 5, 6, 7.
Потом вот просто напомнили, как работает merge sort.
А дальше смотрите, давайте моё дерево отрезков будет
ровно вот так выглядеть.
Оно в каждой вершине будет хранить там ни сумму на
отрезке, ни количества нулей, как вот раньше было, не одно
число, а прям вот все эти числа, которые на этом
уровне рекурсии здесь сортируются, которые будут в таком
порядке располагаем.
То есть в корне будут вообще отсортированный весь
массив, в корне дерева будет храниться весь отсортированный
массив.
В левом сыне будут храниться отсортированные элементы
с нулевого по третьей, в правом сыне с четвертого
по седьмой.
И так далее.
То есть у меня в каждой вершинке будет храниться отсортированный
кусок моего, скажем так, под кусок моего исходного
массива.
Вот здесь будет храниться все, что находится в этом
поддереве.
Здесь отсортированы вот эти вот 2, 4, 6, 7 в правильном
порядке.
То есть в каждой вершинке у меня хранится вектор или
массив, неважно, динамический какой-нибудь.
Ну тогда, как можно на это все отвечать?
Как можно отвечать на запросы?
Поиск, количество чисел больше равных чем х на отрезке.
Количество чисел больше равных х на отрезке селпайр.
Ну самое простое это следующее.
Давайте мы вот в этом нашем дереве отрезков, то есть
теперь вот это будет являться уже деревом отрезков.
Мы в нем опять разобьем наш отрезок LR на какие-то
вершинки.
То есть точно так же мы спустимся рекурсивно сверху вниз,
дойдем до каких-то вершинок, которые целиком покрывают
наш отрезок LR.
Скажем вот в таком примере, опять-таки восстановим
его.
У меня вот эти вот две вершинки, вот это и вот это вдвоем
целиком покрывают мой отрезок.
Вот с А2 по А7 у меня весь отрезок покрывается двумя
вершинками.
Ну точно так же в любом случае у меня будет, то
есть когда я так спускаюсь рекурсивно сверху вниз,
у меня отрезок LR разбивается на какое-то логарифмическое
количество вершинок, которые его целиком покрывают.
Ну давайте тогда в каждом таком массиве, мы же знаем,
что это уже отсортированный массив, он возрастает слева
направо.
Давайте мы в каждом из них с помощью бинарного поиска
найдем количество чисел больше равных чем х.
В каждом таком отсортированном массиве с помощью бинарного
поиска найдем количество чисел больше
равных чем x ну там не знаю скажем x
равно
так вот плохой ну ладно значит x равно не
знать четырем да тогда я вот здесь вот
находить давайте тройки давайте тройки
тогда я в этом массиве нашел минимальное
что больше рано чем x bin поиском вот
эта четверка и в этом массиве тоже bin
поиском я запускаю в поисках числа больше
рано чем 3 но такого числа вообще нет
мы будем там указывать на конец массив
понятно что если есть ассоциированный
массив то найти первое число больше
равное чем x это ну логарифмическая задача
вы делитесь как обычно пополам да
и сдвигаетесь там либо либо в левую
половинку либо вправо в поисках того
самого элемента
ну тогда вам нужно просто в каждый из
этих решинок запустить bin поиск
да если вы и тогда мы знаем ну то есть
вот здесь мы получили три числа больше
равное чем 3 здесь мы получили 0 чисел
тогда если мы сложим эти как раз 3 и 0
мы как раз получим суммарное количество
чисел которые мы искали количество
чисел на отрезке lr который по значению
хотя бы x вот и сложим это все получим
ответ ну и в общем случае так и будет
работать мы разбиваем наш отрезок lr
на какие-то вершинки которые его
контролируют в каждый из них пускай
bin поиск находим количество чисел в
этом под дереве больше равное чем x и
все это складываем так давайте тоже
напишем это чуть-чуть
обработка запроса lrx то есть число
количества чисел на отрезке lr больше
равных чем x мы находим от log n вершин в
дереве отрезков в дереве отрезков
которые как раз в объединении целиком
покрывают отрезок lr ровно по одному разу
которые покрывают отрезок lr ну
собственно ровно это мы и делаем во
всяких гетцамах предыдущих мы так
спускаемся по дереву что мы доходим
до вершины, Которые целиком контрольifies
часть отрезка и так ну и так сделали
несколько раз дошли до каких-то вершин
в объединение не как они как раз дают
весь отрезок на весь отрезок
diver также здесь мы как-то спустились
не знаю там вот так спускалисьmostе
одно вершинку здесь тускались
в другую здесь третью вот они в
объединении то есть вот это вот плюс
вот это вот плюс вот это вот в обнов Go
Дают весь отрезок subtractor
а дальше в каждой из них запускаем bin
поиск
продолжаем да в каждой из них
из них, с помощью бинарного поиска, с помощью бинарного поиска, находим
количество чисел больше и равных, чем х. То есть в каждом вот этом вот отцежетрованном
списке, в котором у меня хранится bin поиск и там плюс к ответу. Тогда-тогда
симпатотика ответ на запрос, это лог квадрат.
Лог квадрат. Потому что у меня логарифм-вершинок и в каждой вершинке у меня bin поиск.
Логарифм-вершинок и в каждой вершине bin поиск, которые работают опять за логарифм.
Поэтому а симпатотика ответа на запрос будет лог квадрат.
Что-что?
Не, ну не обязательно двумя, конечно. Например, вот здесь, если у вас будет
отрезок там с первого по седьмой просто, вот такой, то вы его двумя не покроете,
то есть у вас будет три вершинки, вот это, вот это и вот это. В худшем случае логарифм придется всегда.
Так, давайте подумаем. Мы по сути разбили наш массив lr, который имеет длину в худшем случае n,
на несколько кусочков суммарной длины тоже n. То есть если у меня есть k1 плюс и так далее,
плюс там km равно n, то я работаю за логарифм k1 плюс и так далее, плюс логарифм km, верно?
Да, сумма логарифма всех этих штук.
Ну, я напишу так, я напишу, что это логарифм произведения k1 и так далее на km,
потому что сумма логарифм – это логарифм произведения.
Дальше, ну, сейчас.
На самом деле, возможно, вы правы, да, но это надо чуть более тонко проанализировать.
То есть, ну, в худшем случае, если я здесь скажу, что все каиты – это n делит на m,
если все каиты – это n делит на m, то здесь будет, ну, а m – это примерно логарифм n.
m – это примерно логарифм. Тогда вот здесь будет написано n делит на m в степени m,
и вот я беру логарифм. Ну, короче, m – это что-то, что-то, значит, деление на m – это несущественно.
Главное, что здесь будет логарифм от n в степени m, и у вас будет все равно, ну, вот m вынесется умножением.
Короче, в общем, лучше не получится. То есть, если проанализировать как-то в тупую,
то есть, если пытаться максимизировать вот эту вот штуку при этом условии,
то у вас будет лог квадрат. Вот скажем так. У вас будет лог квадрат.
Но если аккуратно понять, как именно устроены эти отрезки, что там, видимо,
в каждой глубине у вас максимум два отрезка может быть, то есть вот эти вот вершины,
которые вы строите, они такие, что их максимум по 2-3 на каждом уровне.
И тогда, наверное, можно получить оценку логарифм. Да, но это чуть более тонкий анализ.
Можете попробовать самостоятельно. Так, хорошо. Я недосказал, как именно мы строим,
как мы получаем вот это вот дерево Merge Sort. Как мы получаем, сколько это времени занимает,
сколько это памяти занимает. Давайте с этим разберемся.
Ну, со временем все понятно. Это просто алгоритм Merge Sort.
Мы его уже понимаем, как он работает. Он работает за n log n.
Построение вот этого всего, построение, это n log n времени.
Там даже тетто от n log n, потому что в точности n log n времени.
Теперь что с памятью? Можете ли вы мне сказать, сколько памяти занимает вот такое дерево,
если я в каждой вершине храню ассортированный вектор всего, что находится под деревом?
n log n, да. Память здесь тоже n log n. К сожалению, тоже тетто от n log n,
потому что каждое конкретное число, скажем, a i t, оно хранится log n раз.
Вот есть у вас a 4. Оно хранится здесь, здесь и здесь.
Ну и каждая a i t хранится log раз, то есть участвует в алгоритмическом числе массивов.
Поэтому суммарно размер всех этих массивов, он, конечно, n log n.
Поэтому здесь памяти чуть больше, чем, скажем, в обычном дереве отрезков.
Если в обычном у вас память линейное количество, то здесь n log n.
Но построение такое же, как в Merge Sort. У вас просто есть нижний уровень.
Вы берете два какие-то кусочка и склеиваете их с помощью процедуры Merge, вот эти два указателя.
Поэтому построение работает с n log n.
Так, окей, это вот такое решение с помощью бинпоисков.
Теперь на самом деле можно это оптимизировать и вообще сделать только один бинпоиск.
И получить асимптотику честный алгоритм без всяких там анализов того, как именно происходит разбиение на вершинке.
А именно, давайте сделаем следующее.
Давайте мы для каждой вершины, вот что у нас здесь написано.
У нас здесь написано какой-то ассортированный массив, который как-то разбит на левые и правые кусочки.
То есть какие-то элементы пошли влево, какие-то вправо.
Тогда давайте нарисуем как бы не то, что историю каждого элемента, то есть откуда он именно пришелся.
Вот эта четверка пришла из этой четверки, там пятерка отсюда и так далее.
А мы для каждого элемента верхнего массива напишем элемент, минимальный элемент, который его больше равен.
Сейчас я вот это все сотру и нарисую все стрелочки.
Вот тут у меня был массив 2467.
2467.
Так вот, я для каждого числа верхнего массива нарисую две стрелочки влево и вправо.
А именно, на минимальное число больше или равное, чем вот это число.
Например, вот есть у меня нолик.
У него минимальный больше или равный его слева это ноль, а здесь двойка.
Минимальный больше или равный вот это двойка.
Затем, скажем, для двойки.
Двойка будет ссылаться вот сюда и вот сюда.
Минимальный больше или равный двойки, простите, это 3 слева.
Что здесь еще интересно?
Например, шестерка показывает здесь сюда, а здесь вот сюда, после пятерки,
потому что слева нет ни одного числа больше или равного, чем 6.
То же самое для семерки.
Она указывает сама на себя и на этот несуществующий элемент.
Итак, для каждого числа храним два указателя.
Ну, точнее, там два индекса.
Я их назову указателями.
Два указателя.
На минимальные числа, давайте я его назову у.
Для каждого числа у храним два указателя.
На минимальные числа больше или равные, либо равные у в обоих сыновьях.
В обоих сыновьях вершины v.
Есть у меня число, оно понятно, оно лежит либо слева, либо справа.
То есть одна из стрелочек обязательно будет показывать просто на y.
Поскольку y откуда-то пришел, он обязательно хотя бы одна из двух стрелок указывает на тот же самый элемент.
А вот в другой вершине мы будем хранить стрелочку на просто минимальный больше или равный.
На минимальный больше или равный.
Эти все стрелочки очень легко считаются там же, когда вы делаете мерч.
Вот есть у вас два эти массива отсортированные, вам нужно сделать от них мерч и еще все стрелки посчитать.
Ну это очень просто.
Сначала вы написали 0, вы написали минимальное число.
Тогда понятно, что он пришел отсюда, стрелка будет сюда.
А стрелка в противоположном массиве будет просто на тот элемент, который вы еще не добавили.
Потому что тот как раз первый недобавленный, это тот, который больше или равен чем этот 0.
Дальше вы написали единицу, она ссылается сама на себя и на этот же недобавленный элемент на 2.
Потом вы пишете 2, она ссылается на себя и на первый недобавленный слева.
Вот на эту стройку.
Короче говоря, все эти стрелки легко насчитываются там же, когда вы делаете мерч.
Просто у вас есть ссылки на минимальный неиспользованный здесь, минимальный неиспользованный здесь.
Вы пишете один из них и ссылаетесь как раз на это число и на то число.
Ну в общем, туда, где у вас были указатели.
И с помощью этих стрелок уже можно отвечать на запросы.
Да, вот это вот количество чисел, количество чисел больше или равных х.
Просто идя по этим стрелкам.
Потому что вот, например, не знаю, было у меня там х равно.
Так, чтобы интересно такое написать.
Ну тройка давайте, да.
Вот у меня, я эту тройку нашел одним бинпоиском.
Значит в корне сделал бинпоиск, нашел, где эта тройка лежит.
Дальше у меня есть две стрелки.
Стрелка вот сюда и стрелка вот сюда.
Ну и по сути это ровно то, что мне нужно от обоих сыновей.
Мне нужно как бы потом, в этих сыновях, как бы бинпоиском найти минимальное число больше или равное Чем Х.
Но эти стрелки ровно это и делают.
Это тройка ссылается на эту тройку,
а здесь на четверку, то есть на минимальное число справа больше или равное чем 3.
Поэтому мне здесь бинпоиск не нужен, мне не нужно будет פускать бинпоиск в этом ребенке.
Мне нужно просто перейти по этой стрелке.
То есть я теперь хранил вот эту тройку и эту четверку.
Дальше, если мне там нужно спуститься вот здесь скажем,
скажем, у меня стрелка стоит сюда и сюда, поэтому теперь вместо бинпоиска там по тройке или по
четверке я просто спущусь вот сюда и сюда, и это как раз минимальные элементы в обоих кусках,
которые больше равны чем 3, потому что тройки нигде нету, 2 меньше чем 3, 6 это минимально больше
равное чем 3, и так будет всегда, мы просто можем пойти по стрелочкам, и это и будет тот самый
минимальный элемент, который мы ищем, минимальный больше равный чем x. В итоге мы избавились от
бинпоисков, мы оставили только один бинпоиск в корне, и потом просто проходим по этим стрелочкам,
мы получается избавились от бинпоисков, их заменили на проходы по стрелкам. Вместо
логарифмического количества бинпоисков мы делаем один, один бинпоиск в корне,
и потом переходим по стрелкам, а потом переходим по стрелкам. Ну и все, и тогда,
если я дошел до вершинки, где мне нужно найти количество чисел там больше равных чем x,
мне нужно просто понять, куда дошли вот эти вот стрелочки, вот это иду-иду-иду, спустился,
и вот это и есть то самое минимальное число, которое я искал, то есть дальше здесь не нужно
пускать бинпоиск, я уже знаю то самое минимальное число, больше равное чем x. Все? Нет-нет,
у нас стрелочки есть вообще везде. Да, я это, возможно, недосказал, у меня для каждой вершинки
и каждого числа в нем хранятся все вот эти вот стрелочки, потому что каждой вершины получается
из двух более низких операций мерч, и этот мерч, он не только склеивает два массива,
но и все эти стрелочки насчитывает. Все эти стрелки есть на всех уровнях.
Вот, тем самым мы как бы избавились от бинпоиска, и тогда асимптотика уже точно логарифм. Асимптотика
ответа на запрос. Ответа на запрос. Ну, тут уже, ну ладно, не важно. Вот логарифм. Логарифмэн. Вот так
работает fractional cascading, это именно вот эти вот стрелочки, которые нам позволяют обойтись
без бинпоиска. Все, тогда то, что я вот анонсировал про количество различных наотрезков, уйдет на
семинар. На этом мы заканчиваем на сегодня. Спасибо, до следующего раза.
