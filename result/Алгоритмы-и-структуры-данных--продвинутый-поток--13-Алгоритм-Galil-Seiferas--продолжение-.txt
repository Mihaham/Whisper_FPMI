Всем добрый день еще раз. Сегодня мы все-таки попробуем завершить то, что начали в прошлый раз.
Ну вот, а что мы начали в прошлый раз? В прошлый раз мы начали, ну в принципе так и серьезно
продвинулись в изучении алгоритма Галилла Сейферса, который занимался тем, что пытался
найти под строку в строке, а точнее все вхождения под строки в строку, и при этом использовать
единицы дополнительной памяти. Но если быть точнее, мы остановились на том, что мы научились
на самом деле даже это делать, но в предположении, что мы там верим в кое-что. Нам требуется взять
какую-то строку и как-то ее разбить на какие-то две очень хорошие строки, и там в одной из этих двух
строк еще что-то найти. Если мы поверили, что мы это каким-то образом за линию от нее умеем делать,
то искать под строки в строке мы тоже научились. Ну а теперь давайте попробуем вспомнить,
что у нас было. Я сейчас не буду повторять прям весь алгоритм, но давайте попробуем
воспомнить вообще основные определения леммы, которые у нас были, потому что в терминологии
нам все равно придется думать. Итак, у нас обязательно было понятие рича, ну и здесь,
по сути, можно легко это определить через Z-функцию. То есть рича от P это P плюс Z от P, согласны?
А если по, да, плюс один, да, не путайте, у нас один индекс, будьте внимательны,
просыпайтесь, просыпайтесь. Очень хочется так думать. Так, ну вот, еще у нас есть определение,
действительно, что у нас есть базовая строка, давайте в прошлый раз вот так вот писали,
так давайте вот так тоже. Так, что у нас еще есть? Ну вот, ну, просто краеугольным
камнем для нас является определение такое, что, допустим, T, рефиксный период, да,
это прямо для нас прям супер супер ключевое вообще определение, просто ключевое понятие,
период S, хотя определение очень, ну, казалось бы простое, да, то есть что там написано,
если у нас должно быть T базовая, как вы помните, и T в степени K, рефикс S.
Давайте эту буфу K еще выделять. Ну, напомню, что K это такая введенная зафиксированная константа,
то есть мы ее отдельно лучше выносим, хотя вот, то есть обычно авторы все время подчеркивают,
что да, мы пишем для удобства K равно 4, но в принципе, если вы возьмете там K равно 5, 6,
10, 12, в общем-то тоже работает где-то. Ну вот, ну, как получается. Ну, понятно,
что тем меньше K возьмете, тем меньше конкретных предъявлений действий будет где-то. Вот. А что
будет называть K равно 3 и почему не будет половаться? Ну, скорее всего, видимо, просто некоторые
доказательства могут половаться. Вот, например, сегодня у нас в одной из клеев, которую мы будем
доказывать, будет фигурировать степень K минус 2, и там нам, по-видимому, придется пользоваться тем,
что K минус 2 больше либо равно 2. Вот. Значит, давайте, но для этого давайте внимательно смотреть,
что у нас еще есть. Так, ну, ключевое, у нас, конечно, была лемма периодически. Так, вот давайте
что-нибудь красивое, давайте что-нибудь каким-нибудь красивым цветом рисуем. Вот, давайте. Будет у нас такая
малиновая лемма. Ее, конечно, можно хоть переломутривой делать. Так, малиновая лемма.
Итак, вспомним, лемма о периодичности. Вот, да, здесь я, конечно, может... Да, она не имеет отношения к
префиксным периодам, но она говорит, если строка S, P1 периодично и P2 периодично. А длина этой
строки больше либо равна, чем P1 плюс P2, напишу так в скобочках, минус нод от P1, P2. То, то что? То что
про, можно сказать, при строку S? Да, совершенно верно, то S нод P1, P2 периодично. Так. Ну, это должно
быть интуитивно понятно, но я на всякий случай напомню, что строка является там P периодично,
если любые два символа в этой строке на расстоянии A и P между собой совпадают. Да, это будет понятно. Вот.
Да, просто была такая лемма. То есть, в принципе, на самом деле, она очень просто доказывается для
P1 плюс D2, но вот если мы хотим минус нод, то тоже доказывается, но для этого уже придется чуть-чуть
пострадать. Вот. Но мы вроде в прошлый раз справились, не будем к этому возвращаться. Но важно нам
для нас даже не великая лемма периодичности, которая вот где-то в другом месте обитает,
а для нас будет важно следствие. Следствие будет говорить следующее. Следствие, которое вот там
пригодится конкретно в нашем алгоритме, оно нам будет говорить. То есть, оно формулируется так.
Значит так. То есть, оно нам будет говорить. Пусть у нас ОС есть. Значит, у строки С есть префиксный
период. Период. Какой? P1. Вот пусть у нас есть префиксный период P1. И, внимание,
базовый префикс даже, обратите внимание, даже базовый префикс P2 больше P1. Причем, ну, базовый
префикс, понятно, на этот раз все честно. То есть, префикс, который является базовой строкой. Вот.
Ну, надеюсь, никого здесь сейчас исключает. На всякий случай скажу, что мы тут объявили, что префикс,
префиксный период или там базовый префикс, там префикс это строка, а мы тут используем чиселки.
Понятно. То есть, формально тут надо, давайте, ставить слово длинный. А ну, в прошлый раз даже и делали,
но и сейчас. Вот так. Да, причем, что для нас самое важное, reach с индексом С от P2 больше
либо равно 2. То есть, здесь даже тогда, как мы уситрились доказать, что мы уситрились доказать,
оказалось, что P2 строго больше, чем k-1 на P1. Что ж там? Что 2P2? А, да. Ну, вот была, ну,
вот, действительно, была у нас и такая веселая клеммочка. Вот, собственно, в основном и ей. То есть,
в принципе, можно, то есть, исходная формулёка могла быть на тему того, что, действительно, если у строки
S есть два разных префиксных периода, то они отличаются друг от друга как минимум в k-1 раз. Да,
то есть, чтобы это было интересно, желательно, чтобы k было уже как минимум и 3. Да, была у нас,
было у нас и такое утверждение. Что у нас ещё было? Что у нас ещё было? Вот, ну, на самом деле,
теперь нам, то есть, были ещё у нас пару утверждений. А, ну, конечно же, нет, мы ввели такое красивое
понятие, мы просто берём снова чёрную марку, мы ещё вводили понятие shift. Так, что такое shift?
То есть, действительно, мы ещё ввели понятие shift с индексом S. Что такое? То есть, это такое
минимальное такое, допустим, L больше нуля, такое, что S от L плюс 1 до q равно S от 1 у ку ку минус.
То есть, видите, помните такую красивую префикс-функцию наоборот, можно сказать. То есть,
по большому счёту, префикс-функция, префикс-функция, то есть, вот это вот, на самом деле,
равно с индексом S. Ну, очень удобно мыслить именно в терминус shift. Вот. И у нас есть,
и у нас была пара очень красивых лемма, которые нам нужны. Лемма 1 заключалась в том, чтобы, давайте,
лемма 1. В чём она заключалась? Она у нас заключалась в том, что shift с индексом S у нас,
что, ну ладно, она начиналась со слова если. Значит, если оказывалось, что для некого q, вот
это вот, оказывается, что сдвиг q поделить на k, то что будет дальше? Давайте, воспомним. Что?
То это префиксный период? Да. То действительно q, так сказать, ну даже не q, а скорее этот префикс
именно q, я садил q. А, шрифт. Именно шрифт. Да, это префиксный период строки S. Да, совершенно.
Да, очень, да, очень такое интересное, достаточное условие. Ну, была и вторая лемма,
даже такая более сложная, более критичная для нас, которая являлась там просто, ну вот. Ну,
обе эти леммы были зашиты в алгоритме. Нам говорят так. Пусть у нас есть префиксный период,
префиксный период S. Вот. Тогда, оказывалось, верны следующие эквивалентности. То есть,
тогда вот, то есть, для любого q от одного до модули S, верно следующее, что оказывается два
утверждения, что L равно shift от q, SyntaxMS, конечно, и этот shift еще и при этом меньше
либо равен q делить на k. Верен тогда и только тогда, когда k умножить на это вот L, соответственно,
у нас меньше либо равно q, меньше либо равно 3q. Вот. Было такое. Вот. Да, в идеале, конечно,
бы еще вспомнить, как это доказывать. Возможно, возможно даже вспомнить. Вот. Ну, вот. Ну,
собственно говоря, да. То есть, это у нас такая основная техника, действительно, которую мы
доказали и с помощью которого действительно активно каким-то образом работали. Но, собственно,
самое интересное для нас было... Значит, что для нас самое интересное? Ну, во-первых, для нас самое
интересное, это, конечно, теорема о декомпозиции. Это, конечно, самое главное. Каким самым главным
артером мы будем писать? Ну, конечно, режим. Мы же любим режимарки, правда? То есть, самое
ключевое для нас это теорема о декомпозиции. Что она нам говорит? Она нам говорит, что любую строку S
можно разбить. Можно разбить. Значит, в конкатинацию S равно УВ, где, с одной стороны, значит, во-первых,
тут я даже отдельно буду писать. УВ не более одного префиксного периода. Не более одного префиксного периода.
И длина У абсолютно произвольная, но длина У это О от чего? Очень легко перепутать,
но тут именно шеста. То есть, фактически, вот оказывается. Вот. Мы с вами, собственно, в прошлый раз
остановились на чем? Мы, конечно, если мы поверили, что в эту теорему, причем в широком смысле поверили,
поверили не только в то, что она верна, но и в то, что мы за линейное время для любой строки С эти УВ еще и найдем.
И не просто найдем, а у этой В еще и выковырием, что это за префиксный период, если он вообще есть. Если мы в это поверим,
то, собственно, после этого по строку в строке мы без труда найдем, помните, да? Вот. Ну и последнее, ну вот.
Последнее, что нам осталось только вспомнить, это нашу основную схему. Вот последнее. Вот давайте тоже я такую вот.
Вот это вот наша рабочая христианская схема эту нарисую. Ну, фактически, мы будем называть ее, может быть, схемой, но там и соправка.
Да? Давайте вот так. Я ее в кавычках назвал схемой КМП.
Да. Ну, в этом месте авторы тоже в случае, там отчасти, там, может быть, соправка ссылается, хотя я не знаю, как они эту схему придумали,
или там первые применили. Ну, тут, как здесь вопрос, да, со стипа концепция блокирующих потоков точно.
Вот. Итак, если мы ищем, соответственно, ну, то есть если мы ищем, допустим, там S, там под строку S в тексте T, то искать мы ее будем так.
Вот. Сначала у нас PQ будет равно, допустим, 0,0, а дальше мы скажем, что допустим, ну, вот, скажем там, то есть while там, ну, я не знаю, P меньше либо равно,
модуль T. Что мы делаем? Ну, и говорим, соответственно. Ну, то есть суть следующая. То есть PQ мы пытаемся поддерживать таким образом, чтобы под строка от P не включительно до PQ включительно у строки T была равна, соответственно, префиксу 1.
Это вот у нас такой инвариант, который мы пытаемся поддерживать.
Пока у нас это выполняется, то есть мы говорим, пока, значит, PQQ1 меньше либо равно модуль T и, соответственно, еще и там продлить хорошо.
Вот. А также, значит, S от, соответственно, QQ1 равно T, PQQ1, плюс, плюс. Вот. Ну, тут могут быть какие-то комментарии, если там, если Q равно S, то там, бла-бла-бла, какое-нибудь.
И ключевая мистическая строка PQ должна быть присвоена теперь P'Q'. Все. Вроде ничего не забыл.
Ключевое в этой схеме было, то есть мы хотим... Смотрите, у нас 1 индексация всех строк, но обратите внимание, под строка T, видите, она не включит.
Да, я немножко спонтанно ввел такую штуку, но, мне кажется, это удобно. Вот. Да, ну, да, возможно, да. А, мы с вами, видимо, в прошлый раз немножко по-другому, да?
Ну, да, мы там, да. Мы такого не привыкли. Но, с другой стороны, вот, мне кажется, тут это будет максимально удобно.
То есть, иногда, вот, действительно, тут совпрямилось с классицией, иногда очень удобно мыслить, что, то есть, в качестве там первого индекса задавать позицию, сразу после которого строка начинается.
Но, основной местицизм у нас где-то будет заключаться в том, как по P'Q выбрать следующие P'Q'.
Ну, так, основные идеи были в том, что в большинстве случаев оказывается, что по P' вместо P'Q' можно дальше писать какой-то P', там какой-то следует, но даже не какой-то P', а P' оказывается там что-то типа P'Q' поделить на K, просто в половине случаев, а Q' равно 0.
Так, ну и всё. Воспомнили немножко, что было?
Хорошо? Вот, ну да, по вашему скучающему виду действительно так вытекает ощущение, что вы прям это всё хорошо помните и понимаете.
Ну, не знаю, я просто, просто я не могу, знаете, похвастаться, если честно, поэтому лучше давайте перепродоговорим.
Ну, как вы видите, ладно, ослушайте лекции, там потом при подготовке к экзамену обрадуются, что там первые 15 минут можно перемотать.
Вот, значит, соответственно, что же мы теперь хотим? Итак, ну, наша сегодняшняя цель, по большому счёту, решить серию модекомпозиции, то есть фактически вот выполнить вот эту штуку.
Значит, ну я здесь уже выяснил, действительно, что нам вообще надо, но для этого, значит, ну давайте вот теперь приступим к делу.
В этот момент мы, собственно, пытаемся начать. Значит, смотрите, для этого нам потребуется глемма 3.
Вот, смотрите, вот, кстати, возможно, сейчас вот начнётся, мы начнём поднимать, ой, боже мой, ладно, потом сейчас я как-то поменяю на красненький, почему-то кому это надо.
Итак, первое, с чего мы начнём доказать свои теоремы, это лемма 3. Внимание, вот, лему 1, лему 2 мы доказали в прошлый раз, теперь начинаем лему 3.
Говорится следующее, любую строку S, допустим, можно разбить, значит, S равно S1, S2.
Такую что, а вот тут сейчас будет экзотическое условие. Смотрите, внимание, для любой строки S, значит, тут вот так интересно сформулировано, S2, S1 в степени k-1, S', –1, –1.
Имеет не более чем одного, а вообще не имеет, ещё получаю, не имеет префиксного периода.
Периода меньшего модулизма.
Вот такой вот красота.
Пока вы пытаетесь понять действительно, о чём лемма. Ну тут действительно, пока на самом деле, пока мы не увидим алгоритм, может сложно понять, зачем эта лемма нужна, но поверьте, надо потрепиться.
Давайте попробуем хотя бы в качестве упражнения её подоказать.
Вот теперь, как нам сейчас поможет то, что k – это 4, а не, например, 2?
А, никак. Ещё очень важно, что строка басовая.
Давайте обратим на это внимание. Она басовая.
Значит, почему это так важно? Потому что можно заметить, ну начнём с того, что любая такая строка имеет, ну, так, во-первых, начнём с, видимо, очевидного авторутверждения.
Заметим, что если строка базовая, то и любой эсаклический сдвиг базовый, согласны? Логично, да? Вот, логично.
Вот, а это означает, что любая такая строка, какой бы это шрифт ни приписывали, а у этой строки по-любому есть базовый префикс длины модуль w, правда?
Модуль w.
Значит, да.
То есть, давайте, давайте, вот, можно даже это так и писать.
Значит, пункт первый. Для любого s-штрих, вот эта вот мистическая строка, t-1s-штрих, имеет базовый префикс
s2s1 длины, длины модуль s, причём, обратите внимание, rich, это из строки, это весёлые строки от модуль s.
Что по нему можно сказать?
Ну что, как вы думаете? Вот давайте внимательно посмотрите на определение и скажите, чему равен, что можно сказать уже вот из определения строки про rich от модуль s?
Сначала бы сказать, что он маленький.
Маленький?
Мы его не породить, да?
Так, нет, ничего умного я не предлагаю.
Хочется тут написать пока только то, что прям вот очевидно отсюда, исследует отсюда из определения rich.
Нет, если вы пытаетесь сейчас что-то умное вывести, это можно упросить.
Просто вообще непонятно, что можно сказать.
Да ладно.
Так, ну давайте порисуем.
Что это вообще такое?
Как оно вот?
Так, погодите.
А, ничего нельзя сказать, потому что я опять запутался.
Ой, чёх мне так блючит сегодня?
На самом деле вот, а если вот так?
Всё поменялось сразу, да?
А вот если так?
Ну хотя бы, видимо, 3s уж точно будет.
Ну даже 3s плюс модуль s2.
На самом деле да, на самом деле больше либо равно 3 модуль s.
Ну можно точно сказать 3 модуль s плюс модуль s2, но это не интересно.
Ну и даже я вот напишу, что модуль, для нас вообще-то достаточно модуль 2s.
Ну вот, ну теперь догадываетесь, почему я хочу именно про 2 написать?
Чтобы предыдущую лему применять.
Ну и предыдущую лему, а следствие из леммы периодически.
Следовательно, если есть префиксный период,
то то, что мы можем сказать, тогда мы гарантируем, что p тогда вынужден быть меньше, чем s,
поделить на k-1.
Ну просто почему, по следствию из леммы периодически.
Что это само по себе значит?
Само по себе это значит только одно, что если у нас есть префиксный период у этой строки,
для такого то есть шрифта, то этот префиксный период, то...
Так.
Вот.
А.
Вот.
А теперь, ну вот, теперь на самом деле вот возникает такое.
Ну вот, немножко такое еще интересное.
Итак, у нас строка действительно у нас длины, допустим, не более чем.
То есть она должна быть...
Ну а с другой стороны, еще как бы местицизм еще заключается в том, что
модуль s делить на k-1 меньше либо равен, чем k-1 на k модуль s.
Интересная следствия.
Кстати, интересно, для кара внутри оно верно вообще?
А, верно.
Вот.
Пока еще не важно.
А что это вообще значит?
Ну вот.
Тогда это получается означать, что kp меньше либо равно, просто...
Ну вот.
То есть kp должно быть меньше либо равно k-1s.
Префиксный период.
Префиксный период.
Префиксный период просто строки s2 и степени k-1.
Вот так.
Ну, по сути, первая цель этих первых трех пунктов, говоришь такое.
Да, мы начинаем доказательства от противника.
И говори, пусть у нас там, допустим, этот префиксный период p, допустим, есть.
Тогда мы замечаем, что оказывается, что его длина должна быть такой, что на самом деле от s4 ничего не зависит, потому что он со всеми своими k-1 вот этими повторами, он на самом деле сюда прекрасно укладывается.
Вот.
То есть вне зависимости от того, какая длина s2 и так далее.
Поэтому, по большому счету, мы можем доказывать теорему для с любым фиксированным s-штрих.
Вот такая идея.
И мы это сделаем.
Значит, смотрите.
И зачем мы говорим так?
Пусть s-штрих равно, ну, короче, s в бесконечности.
Вот.
И так.
То есть внимание.
То есть по большому счету произошло следующее.
Мы зациклили строку s.
Прямо до бесконечности зациклили.
И будем...
Ну вот.
Ну и каким-то образом будем пытаться найти у нее какой-нибудь не имеющий...
Ну, будем пытаться от нее отгрызать какие-то префиксы, префиксы, префиксы.
Так, чтобы в какой-то момент...
Чтобы в какой-то момент очередной бесконечный суффикс этой строки не имел префиксного периода,
меньше, чем modulus.
Вот. Понятно, что мы сейчас хотим сделать?
Да нет, наверное.
Вот.
Чему же нас это приводит?
Посмотрите, каким же образом мы это будем делать.
Делать мы это будем следующим образом.
Вот.
Ну, я сейчас давайте приблизительно напишу.
Значит, метод будет такой.
Скажи так. s, inf.
Присвоить s.
Ну, короче, s2 и s бесконечность.
Ну, по большому счету, вот эта строка.
А, ладно. У нас же нет s2.
Просто s бесконечность.
И дальше будем говорить.
То есть, пока каким-то вот мистическим образом мы будем узнавать,
У, с, инфа есть даже не префиксный период, а просто префикс.
Допустим, t, с modulus t меньше, чем...
Ну, префикс t в степени k, с modulus t меньше, чем modulus s.
Так, modulus t или...
А, тут еще, да.
То есть, пока такое изобразие есть,
что мы делаем?
Мы просто удаляем, ну вот, отпиливаем.
Сначала...
Зачем я эти слова пишу?
Лучше бы формально написал.
С пробел начала s2, что мы отпиливаем?
Минимальное такое t.
Ну, то есть, короче говоря, s, инф становится равным, допустим...
То есть, s, инф от вот этого modulus t плюс один, плюс бесконечность.
Вот, обратите внимание, видите, то есть, этот как бы метод, то есть, этот как бы метод, он устроен так, что, видите, мы даже не проверяем, является ли строка t базовой.
Я вообще изначально хотел сформулировать.
Давайте, пока у этой строки есть префиксный период длины меньше, чем modulus, то давайте-ка этот минимальный префиксный период отпиливаем.
Вот я хотел так сказать.
Но я сказал, почему-то не требую, чтобы это был именно префиксным периодом.
То есть, я написал, что не требовать, чтобы это t было базовым.
Третий маленький вопрос, а что это меняет?
Как вы думаете, отпиливаемое t может быть базовым?
То есть, может не быть базовым?
Да.
Ну, мы же взяли минимальное t.
Да, и что?
Ну, если оно было не базовым, то у него было бы, может было бы меньше.
Да, мы действительно заметим, что если мы взяли t в степени k, допустим, это префикс этой вот бесконечного snfa, и t не базовая,
то тогда можно взять его, так сказать, этот период и обнаружить, что он тоже в принципе, этот период в степени k тоже префикс.
То есть, он не минимальный.
Тут все просто.
Вот таким вот методом мы это будем делать.
Так вот.
Так, ну ладно.
Первые четыре пункта, наверное, можно уже убирать.
В общем-то, они нам уже больше не нужны.
То есть, мы и так уже начнем.
Значит, это работаем.
Да, мы уже знаем, что тут все.
Так.
Так.
Что дальше?
Вот.
А вот сейчас мы будем заниматься тем, как минимум, начнем как раз доказательство того, что мы не зациклимся.
Ну, во-первых, начнем с того, что...
Ну, во-первых, смотрите.
Начнем с того, что если мы зациклимся, то это означает, что строка s не базовая.
Нет такого ощущения.
Ну, давайте так.
Во-первых...
Ну, давайте я пока для разминок действительно представлю.
Пусть мы вообще зациклились, да?
Что значит зациклились?
Вот.
Ну, вот...
Ну, во-первых...
Ну, во-первых, начнем с того, что никогда строки длины больше, чем s, мы отпиливать не будем.
Правда?
А, ну, собственно, никогда не будем, потому что...
Да.
А теперь предположим, что...
Значит, утверждение такое.
Давайте так.
Пусть мы отпиливаем.
Ну, давайте воображать себе, что мы отпиливаем.
Значит, последовательность t1, t2, t3, t4 и так далее.
Пока непонятно.
Может быть, последовательность не закончится, хотя мы попытаемся доказать, что она закончится.
Тогда...
утверждаю я.
Тогда утверждаю я, что длины этих строк, которые мы отпиливаем, не уменьшают.
Как это будет?
Почему я это утверждаю?
Ага.
Давайте чуть-чуть подумаем.
А, ну, вроде понятно.
Ну, вот мы отрезали первое t, да?
Тогда у нас оставшая строка начинается с t в кубе.
Да.
Ну, t вk-1.
Так, ну давайте начнем.
Вот давайте мы отрезали t и t, даже в общем случае, да?
Мы отрезали t и t.
Вот.
И что это означает?
Это означает, что у нас дальше идет вот...
вот это вот все, t и t, t1 штучные.
Что хотя бы t и t в квадрате.
Ну, да.
Ну, хотя бы два раза.
Да.
Ну, и дальше в последствии длины тоже самое, кажется, можно говорить.
С t и t будет получаться.
Что у нас?
А, сейчас.
Да.
Ну, и что дальше?
Ну, у нас в последствии длины...
В общем, мы можем несложно аналогично получить, что
новый привыкстный период, если меньше t и t,
он полностью вызывает в t и t вk-1.
А тогда он был привыкстным периодом сесть.
Ну, до удаления t и t тоже.
Так, и...
Так, сейчас.
То есть, пусть у нас есть период p...
Ну, не знаю, там, какую-нибудь новую букву, наверное...
А, ладно, можно и p.
Меньше, чем t и t, да?
Да.
То, в последствии t и t не больше, чем k-1 и t,
делить не больше, чем...
Да, да, да, да.
Да, да, да.
Ну, давайте попробуем это четко сформулировать.
Предположим, что у нас обнаружился какой-нибудь вот этот вот
t и плюс первый, который оказался по длине меньше, чем t.
Действительно, следствие нам утверждает,
говорит так, что если у нас есть базовый префикс,
обратите внимание, просто базовый префикс с ричем на две строки,
а такие у нас есть, да?
И при этом есть у нас еще какой-то даже
базовый префикс.
Ну, а мы легко видим, да, что у нас не просто базовый префикс,
а самый минимальный этот t-шка – это префикс наперед.
То тогда отсюда мы делаем вывод, что на самом деле эта строка совсем-совсем маленькая.
То есть она должна быть прямо вот в k-1 раз меньше.
То есть там в худшем случае все, что у нас будет – это вот там
пум-пум-пум и еще вот...
Вот.
Ну, теперь заметим следующее.
То есть получается, она влезает...
Ну вот, в две t-ишки она вполне себе влезает, правда?
Но тогда получается, что вот эта вот строка из этих 4 t и плюс первых,
она и здесь вполне себе была.
Спрашивается, а что мы тогда отпиливали t, если у нас был лучший кандидат?
Спрашивается, а что мы тогда отпиливали t, если у нас был лучший кандидат?
Не понятно.
Пока что, пока что.
Нам пыталось того, чтобы хотя бы 3 вообще доказательства.
Да.
Так что, наверное.
Так что, наверное.
Что-то так.
Вот.
То есть вот таким образом мы доказали, что действительно у нас имеет место,
что они все вот увеличиваются.
По камере не уменьшаются.
Более того, знаете, я еще даже сюда кое-что допишу.
Причем нас, на самом деле, для нас еще, ну вот, то есть нам еще тут может
действительно потребоваться еще один интересный факт.
Причем можно, можно даже так сказать.
Причем.
Ну вот.
Ну вот.
Ну причем более того, естественно, t и t это префикс.
Ну давайте так пока напишем.
t и плюс первого.
А можно еще себе вообразить t и t в степени k минус первое.
Это префикс.
Остатка.
Остатка еще можно написать.
Ну еще полезно это понимать, да.
Что когда вы отпиливаете строку, помните, то в том, что там будет дальше, то есть
то, что будет дальше, начинается с k минус одной копии именно t.
Кстати, автоматически отсюда следует, что будет происходить.
То есть отсюда автоматически следует, что зациклиться этот процесс не может.
Потому что, а предположим, что он зациклился, это означает, что мы начали отпиливать
в какого-то момента и навсегда строку одной и той же длины, правда.
Но если мы отпиливаем строку одной и той же длины, то тогда получается, что мы у
этой бесконечной строки s нашли период меньшей длины.
Отсюда автоматически следует, что строка небазовая.
Строка s небазовая.
Вот это понятно?
Пока нет.
Да, вроде.
Ну, давайте я вот упровенную этот шестой пункт.
Процесс, значит подчеркнем, не может зациклиться.
Ну, поясним.
Почему?
Потому что...
Ну, на самом деле, просто говорим.
Вот я давайте на той же картинке нарисую, да, потому что я ее не стер.
То есть, если выяснилось, что мы тут стираем, то отпиливаем одну и той же длину,
начиная с треитова.
Тогда заметим, что тогда следующая строка точно начинается с треитова.
И тогда получается, что все это до бесконечности начинается с треитова, треитова, треитова.
А на самом деле напоминают у нас строка, как акоидовая.
А на самом деле напоминают у нас строка, как акоидовая.
С, С, С и так далее.
То есть, получается у нас...
Ну, не С, а, конечно, там какой-то.
С, там, циклический, циклический сдвинутый.
В общем, короче говоря, тогда получается, что эта бесконечная строка с этого момента имеет период ТИТ,
длины ТИТ и период С-циклическая.
ТИТ, причем, меньше.
Следовательно, эта строка имеет период их нода, и он строго меньше, чем циклического.
Следовательно, строка С-циклический сдвинутый, С, не является базовым, как и строка С-противоречий.
Понятно, да?
Так, ну-ка давайте, давайте под ББМ, под ББМ.
Эх!
С удалось� ли в говоре?
Ммм...
пока еще нет, нет давайте. Вот он бы хотелось бы понимать.
То есть важно, мы отрубаем не только одинаковую длину, но и одну и ту же строчку мы отрубаем.
Ну просто потому что, как мы только что поняли, если мы отрубили какую-то строчку,
значит как бы оставшаяся строчка начинается с этой же строчки, причем еще и повторена к-1 раз.
Но если мы отрубаем одну и ту же строчку, то получается 3 это просто период этой бесконечной строки.
То есть получается мы нашли период строго меньше, чем длина S. То есть да, для нас не секрет,
что в этой строке есть какой-то глобальный конечный период.
Просто обнаружилось, что он равен не длине исходной строки S, а еще чуть меньше мы еще нашли.
Это дает, ну как бы отсюда очевидно, что раз строка бесконечная, значит ее длина больше,
чем вот эта строка, плюс умножить на 2 даже.
И отсюда автоматически означает, что эта строка тогда нод периодично,
там нод от длины S и длины T1, ну и все.
Смотри, самого начала нет, но каждый раз, когда мы отрубаем, скажем так,
это исходная строка была S периодично, ну модуль S периодично.
Оттого, что мы отпилим мы от нее какие-то префиксы, она модуль S периодично и быть не пристанет.
Так вот, предположим, что начиная с какого-то момента мы начали отпиливать одну и ту же.
Значит, с какого-то момента неожиданно выяснилось, что дальше эта строка состоит из просто
разложенной до бесконечности копии Тритова.
Да, самого начала может она и не была, но в итоге оказалась.
То есть получается, мы получили строку, у которой есть 2 периода,
с которой меньше модуль S, а другой равен модуль S.
Ну что, понятно? Все, понятно?
Все, можно двигаться дальше.
Вот. Ладно, значит, смотрите.
А, ну в общем-то...
Ну хорошо, значит, ну вот...
Ну, хотя, ну вот, на самом деле да, но вот...
Нет, но в общем-то, по большому счету теперь...
Но по большому счету, в общем-то, Сиарема на самом деле уже доказана.
Так, для этого давайте вспомним, о чем мы вообще доказывали.
Да, напоминаю, мы доказываем вот эту леву.
Да, мы хотим... Да, к чему мы это все?
Как-то любую базовую S, то есть можно разбить, мы пытаемся разбить на две строки,
у которой сутик собладает вот таким приятным свойством.
Если кс2 приписать там S, скажем, к-1 раз, то как бы никаких
префиксных периодов меньшего модуля С мы не найдете.
Ну вот. Ну при чем тут это? Так вот.
При чем тут это, оказалось бы? А, вот при чем.
То есть идея в том, что когда вы вот, значит, от этих вот S, S, S, S, S, S,
что-то поотпиливаете, вот вы тут отпиливали, отпиливали, отпиливали.
И вот процесс неожиданно закончился.
То теперь можно заметить, что вот этот вот разрезок S2 это ровно то, что вам нужно.
То есть, потому что оказывается, что теперь вот S2 на S это не имеет
префиксного периода ни на меньше чем модул S, а мы, собственно, подводили к тому,
что это ровно то, что нам надо.
Такой вопрос. Если мы закончили сразу же, как бы, на первом шаге,
то у нас S2 будет равно S. Это OK по условию?
Вполне.
Вполне.
Вполне.
Вот.
Так. А теперь вот. Теперь мы введем...
Значит, ну, на самом деле, ну, с технической точки зрения нам еще потребуется
еще такое уточнение внутри.
Уточнение.
Так сказать, процесс 4 доказательств о лембе 3. Ой, начинается.
У вас Дифориди Диез впервые ведет?
Ну, значит, не Диез. Значит, незнакомая фамилия. Значит, не он.
Ну, OK. Ну, не важно.
Нет, я просто помню первую лекцию против Урам. Значит, у нас был профессор Диезперов.
И там он просто сразу начинал это, вводить утверждение, вводить там цифры,
там теорему формулировать что-то там. И что-то там теоремует, что задача 1.3
это, собственно, там утверждение 1.1 при условии 1.2.
Вот в этом вот стиле. Да, вот тут тоже немножко так звучит, конечно.
Значит, так вот, утверждение.
Значит, нам этот процесс будет важен. Я его, пожалуй, даже стирать, наверное, не буду.
Или там вот сейчас перенесу куда-нибудь правее.
Смотрите, фишка. Процесс 4 доказательства о лембе 3 отпилит.
Сейчас тут отпилит от S бесконечности строки суммарной длины, вы не поверите, строго меньше, чем модул S.
Вот такой вот неожиданный красота.
Прошу меня, с чего я это сделал, да?
Так, ну давайте, сейчас я все уберу.
Так, что нам это надо убрать?
Так, ну ладно, это мы поняли.
Ладно, давайте так, картинки-то, я думаю, мы подобного рода по-любому нарисуем.
Так, давайте это уберем.
Вот этот вот процесс 4 пусть у нас поживет.
Так, что у нас дальше будет?
Ну вот, нет, вон, нет, нет.
Вот такой процесс.
Вот оказывается, что он, то есть на самом деле, мы тут рисовали, что он может отпилить очень много, на самом деле он там дальше S и не пойдет.
Почему? А вот почему. Смотрите.
Что мы хотели сказать этим номером?
Я спрашиваю, что мы хотели сказать этим номером?
Так, смотрите.
Давайте себе вообразим, что мы тут пришли и этим четвертым процессом стали отпиливать.
Так, какой-то нам контрастный цвет взять, вот, головой возьмем.
Отпиливаем.
Значит, смотрите, фишка такая.
Предположим, мы тут отпиливали, отпиливали, отпиливали.
Ну вот.
И неожиданно отпилили в позиции вот этой вот X, допустим, больше либо равной модуле S.
То есть вот эта вот длина, это называется вот X, и она больше либо равна модуле S. Понятно, да?
Отпиливали, отпиливали и отпилили.
Давайте теперь рассмотрим позицию условного.
X минус модуле S.
Значит, утверждение такое.
Значит, смотрите.
Начнем с того, что вот эта позиция вот с этими границами отпила не совпадает.
Давайте так.
X минус модуле S не граница отпила.
Почему?
Как вы думаете?
А X это позиция именно какая? Последняя, которая отпилили?
Нет, пусть X это первая позиция, первая граница отпила, которая больше либо равна модуле S.
А границы мы называем индекс последний удаленный или первый неудаленный?
Последний удаленный.
Ну или что-то то же самое, длину всего отпиленного до этого.
Итак, давайте предположим, что мы тут неожиданно допилились так, что H модуле S достиг.
Да, мы хотим доказать, что мы строго меньше отпилили, поэтому пусть X больше либо равна S.
Тогда пусть у нас X минус модуле S это вот просто такая вот позиция левее, которая была.
Первое, что давайте для разминочки докажем, что это не граница отпила.
Ну смотрите, вот мы тут отпиливали, вот T1, T2, T3 и так далее.
То есть можно себе это вообразить, что мы вот тут отпилили, это будет первая граница, потом отпилили T2, вот вторая граница отпила и так далее.
Так вот, я утверждаю, что X минус позиция, X минус модуле S в эти отпилы не попадает.
Вот я спрашиваю, что.
Даже мы отпилили X больше S.
Чего, чего, чего, чего, чего?
Что такое до S?
Ну вот давайте попробуем. На самом деле факт очень простой, но поэтому хочется, чтобы вы его поняли.
Да, давайте теперь предположим, что это была граница отпила.
Тогда начиная с этого момента мы отпиливали, отпиливали, отпиливали и допилились вот до этой границы.
Но заметим, что начиная с этого момента вот эта вся строка это абсолютно то же самое, что вот эта строка,
поэтому получается, что дальше мы зациклимся, а мы только что доказали, что зациклиться мы не можем.
Поэтому X минус модуль S это не граница отпила.
Ну спрашивается, и что?
Казалось бы и что?
А вот что?
Ну давайте вот что. Раз это так, то давайте я тут вот, ладно тут понятно, что это S, я думаю.
Теперь давайте вот на эти вот две строки внимательно посмотрим.
То есть ну понятно, это у нас, допустим назовем их, я не знаю, Y, Y, Z.
Тогда получается, что мы можем сказать?
Вот. Мы по идее можем сказать, что действительно дальше у нас вот идут, на самом деле, Y, Y, Z.
Где-то Y, Z.
Ну раз мы эту строку Y, Z отпиливали в какой-то момент, значит тут дальше наверное ее там хотя бы три копии идут,
в смысле как минус одна копия.
Понимаете, да?
Ну вот.
Ну вот.
Ну теперь возникает вопрос, момент такой, что, заметим, что начиная с вот этого момента,
заметим, у нас Z точно идет, то есть Y, Y, Z, Y, Z, может он тут поменьше, конечно,
а вот что побольше мы не знаем.
Но что мы точно знаем, так это то, что раз тут же у нас зацикл, значит получается вот тут Z, Y, Z, Y, Z, Y, Z уж точно.
Спрашивается, что мы из этого выводим?
Что мы из этого выводим?
Неужели ничего?
Неужели ничего?
Мы пошли на следующем шаге отпиливать, да?
Ну теперь что?
А почему мы на следующем шаге отпиливаем Z?
На этом шаге мы отпилили Y, Y, Z.
На этом шаге мы, наверное, раз мы не зацикливаем все, то мы отпиливаем, наверное, что-то побольше.
Смотрите, здесь дает такое подозрение.
Ну это называется Y, Y, Z.
Но тут, вот тут, кажется, и начинает действовать то, что K больше либо равно 4 все.
Почему?
Потому что мы знаем, потому что как уже легко отсюда заметь нод.
Ну здесь уже можно действительно сказать что.
То есть как нод?
Ну да, насчет Z, Y, Z, может бы, конечно, и покричились.
Нет, хотя нет, может, пока еще и нет.
Что у нас тогда получается?
То есть смотрите, да, то есть с одной стороны тут у нас действительно такой Z.
Ну вот, сейчас.
А, то есть смотрите, знаете, в чем фишка?
Вот с одной стороны тут Z, Y, Z, Y, Z, Y, Z, да?
Это мужик у меня, да?
Да, после распилы.
Да.
Но с другой стороны, тут еще есть магия.
С другой стороны, я утверждаю, что здесь есть как минимум Y, Z, Y, Z, Y, Z.
Ну точнее так, как минимум Y, Z тут есть.
Почему?
Да просто потому что мы же с вами, помните понаблюдали, что каждая следующая, каждая предыдущая отпиливаемая строка, это префикс следующий.
Помните, да?
Было да.
Сейчас.
У нас же может быть больше, чем один отпил.
И что?
Ну если у тебя последователь T2 префикс T3, T3 префикс T4, T4 префикс T5, то наверно и T2 префикс T5, правильно?
И отсюда следует мистический факт.
Что оказывается, если эти Y, Y, Z поменять местами, то, получается, им еще и поменяется.
А что это означает?
Это означает маленькую приятную вещь.
А теперь нам важно, что тут не просто Y, Y, Z, а тут еще Y, Y, Z, Y, Z.
Означает это маленький приятный факт, что как минимум вот эта вот строка Y, Y, Z, а также Z, Y, Y, Z, эта строка имеет период меньше, чем вот это.
То есть, смотрите, у этой строки есть период строго меньше, чем вот эта длина, правда?
И от того, что мы можем так...
Ну потому что, на самом деле так.
Потому что я утверждаю, что если Y, Y, Z равно Z, Y, это означает, что Y, Y, Z, модуль Z периодично.
Угу.
А не модуль Y?
Ну ладно.
А, пожалуйста, и то, и то.
Можно сказать модуль Y периодично, но это же уже не важно.
Самое главное для нас следующее, что получается строка...
То есть, когда мы тут отпиливали, у нас была... мы отпилили Y, Y, Z, но эта строка имеет меньше период.
А это означает, что Y, Y, Z в катой степени тоже имеет меньше период, и как следствие, если взять этот меньше период, то этот меньше период в катой тоже тут был претиксом.
Следовательно, мы четко и то отпилили.
Как мы-то позволили то, что еще раз как-то по четыре?
Ладно, я тебя пока отвергнусь.
Угу.
Я где-то снимаю что-то дальше.
Ну да.
Использовали мы то, да.
Использовали пока мы только то, что Y, Y, Z как бы префикс каждого следующего.
Да, видимо.
Ну, по сути, да, по большому счету, да, мы здесь использовали только что промышлевый равно трех.
Может, правда как-то внутри хватит.
Так, ну что красота!
Сейчас, а можно еще раз, почему у нас Y, Z, Y, Z, Y, Z тоже будет периодично с периодами?
Смотри, мы заметим следовательно.
Если у нас тут мы пишем Y, Z, мы знаем, что тут Y, Z, и дальше Y, Z, Y, Z, Y, Z, и дальше Y, Z, и дальше Y, Z, и дальше Y, Z, и дальше Y, Z.
Заметим следки. Если у нас мы пишем y, y, z, мы знаем, что тут y, z, и дальше y, z, y, z, y, z.
Да.
Тогда мы можем заметить, что дальше у нас идёт z, y, z, y, z, y, z. Правда?
Но мы знаем, что мы вот с этого...
Это я понял. Почему, если мы знаем, что y, z равно z, y, то y, z в кате имеет период меньше, чем y, z?
А почему вот это верно?
Нет, вот это тоже понятно, почему верно.
А что и понятно?
А почему y, z в кате будет иметь такой же период?
То есть это же период, который как бы не нацело делит вину строки?
Ну, не... сейчас.
Ну, не нацело.
Ну, он не продлевает цитателя, если мы строку ещё раз пишем.
Да.
Наверное, нужно сказать, что раз она z периодично, y периодично, то она... нот z, y и z периодично.
Вот тогда у нас получается, как бы, она не базовая.
Ну, в принципе, да.
Ну, как всегда, да. Видимо, мы подобные вещи просто навсегда проматываем.
Хотя, в принципе, да, формально говоря, она сама по себе куда-нибудь проявляется, но, как всегда, z, c, d выполнить как всегда можно.
Единственное только оговорка, знаете, какой у меня вопрос такой?
Возник этому доказательства.
Мы здесь воспользовались тем, что i, g, z это префикс вот этой строки, потому что мы этим говорили, что у каждой следующей строки все предыдущие префиксы, да?
А теперь у меня этот вопрос, а если это место, это последний отпил, и мы дальше ничего не отпилили?
А какая разница? Это же, в смысле, то, что идет после отпила, это еще одно повторение той строки, которую мы отпилили?
Ну, вообще, да. Да, на самом деле, да.
Такой вопрос, не будет ли проблема, что если x равен x? У нас там, видимо, y, z будет стоять только из z просто, да?
Ну, да.
Нет, смотри, у нас есть такой вопрос.
У нас есть такой вопрос.
У нас есть такой вопрос.
У нас есть такой вопрос.
У нас есть такой вопрос.
У нас есть такой вопрос.
У нас есть такой вопрос.
У нас есть такой вопрос.
У нас есть такой вопрос.
У нас есть такой вопрос.
У нас есть такой вопрос.
У нас есть такой вопрос.
У нас есть такой вопрос.
У нас есть такой вопрос.
У нас есть такой вопрос.
У нас есть такой вопрос.
У нас есть такой вопрос.
Ну, приятное уточнение мы провели.
То есть, получается, что мы действительно отпилили нод.
Получается, отпиливать будем только из стротиез.
И, как всегда, нод.
Да, отпиливать будем только из стротиез.
И, получается, что оставшийся разгрузок, собственно, это нам как раз и устроит.
Ну, еще раз.
В чем конечная категория?
Ну, вот мы сказали, что не конечная.
Нет, конечная такая.
Что у нас обнаружилось.
Вот мы отпилили строку игр Z.
Вот когда-то отпилили, да?
И оказалось, что игр Z равно Z игр.
При этом игр PZ обе не пустые, что важно.
Мы увидели, что от строка модуль Z периодично и модуль игр периодично.
Почему она, например, модуль Z периодично?
Потому что если взять все символы, кроме последних Z,
и сдвинуть их направо на Z, то оказывается, что они совпадают.
Ну, вот.
А на Y периодично, потому что берем все символы, кроме последних игр,
и сдвигаем их на Y влево, они тоже совпадают.
То есть, ну, в принципе, дальше в дописывании звучит так.
То есть это означает, что YZ получается нод от модуль Y, модуль Z периодично.
На это у нас просто была...
Вот знаете, я даже для радости, чтоб не писать по какой еме,
я просто это нарисую правильным марком.
Но тогда из этого следует...
Но тогда по большому счету...
Ну вот.
Но тогда из этого следует, так как стандартное нас рассуждение,
модуль игр Z делится на этот вот нод,
модуль игр, модуль Z и, значит, модуль игр Z строго больше этого нода,
тогда из этого следует, что игр Z не базовая.
А вот это нам дает просто противоречие,
потому что все строки, которые отпиливаем, делятся базовыми.
Это наша была, как говорится, такой коллабор, базовое требование.
Вот такая красота у нас получилась.
Вот.
То есть вот получился вот такой интересный процесс.
Так, сколько там времени?
Так, сколько там времени?
Все? Уже?
Ну, вот.
Нет, ну давайте, ладно, может быть...
Нет, ну не совсем так, потому что начали мы тоже, в общем-то, не в 35 минут, да?
Так что давайте можем попробовать.
Можем риск...
Да вот.
Можно теперь рискнуть попробовать, ну ладно, в конце концов, да.
Ладно, у нас есть такое преимущество, что после нас сюда никто не придет.
Так что если мы...
Мы сейчас можем задержаться чуть подольше, а потом пойти пообедать чуть больше.
Так что поэтому давайте попробуем, исходя из вот этих вот соображений,
теперь довести дело до...
То есть доказать хотя бы теорему о декомпозиции.
Давайте мы ее сейчас красивенько докажем.
Хорошо.
Значит так, процесс есть, он закончился, значит мы знаем, что...
Значит, по крайней мере, такую вот...
Такую вот S2, действительно, найти можно.
Значит, переходим непосредственно к доказательствам.
Значит, дальше я напишу новый, рыжий процесс.
Ну, давайте, я его сформулирую в таком вот виде.
Значит, пост присвоить нулю.
То есть опять же, у меня будет такая строка S, и я буду...
То есть итак, мне дана вот эта вот строка S,
и я буду сейчас от нее отпиливать всякие приффиксы.
Ну, то есть, то, что я буду отпиливать, как я уже скажу,
то, что я буду отпиливать, как я уже скажу,
то, что я буду отпиливать, как я уже скажу,
это будет строка U, а то, что останется, строка B.
Значит, поехали.
Как я это буду делать?
Значит, новый процесс, смотрите.
Дальше я напишу следующее.
While...
Значит, S от пост плюс первое.
Ну, вот для удобства, удобно считать, что пост это сколько я отпилю.
Да?
То есть while S, пост плюс один, пум-пум, модулес.
Значит, пока, значит, вот эта штука,
вообще, у этой штуки есть хотя бы два...
...приффиксных периода.
Пока они есть.
Вот.
Что мы будем делать?
Значит, делать будем неожиданно следующую вещь.
P2 это второй.
Второй минимальный.
Приффиксный период.
Давно пора уже его ПП писать.
И что-то еще.
А дальше найти...
Ну, дальше, соответственно, найти...
Найти такое...
...пост-штрих.
Значит, между постом и постом плюс P2.
Такое, что...
Значит, соответственно,
значит, S от пост-штрих плюс один, пум-пум, модулес.
Плюс один, пум-пум, модулес.
Не имеет...
...приффиксного периода.
Короче.
P2.
Ладно, давайте сначала закончим алгоритм, потом будем думать, почему это вообще хотя бы можно, в принципе, проделывать.
Ну и, конечно, сказать, что пост и свой пост-штрих.
Так, ну, во-первых, давайте...
Во-первых, вот так.
Ну, здесь и ладно. Утащим этот второй минимальный приффиксный период, естественно, вот в этой странице.
Вот такой процесс приходит.
Вот такой процесс приходит.
Первый вопрос. Почему я этот процесс вообще могу проделывать?
Ну, в первую очередь, почему я могу вообще вот такой пост-штрих всегда находить?
Да, как вы догадываетесь, вся информация, так если я, как всегда, тут нигде не очень прятался, сдал стопить, но то что.
Следствие. Какое следствие? Следствие? Во-первых, следствие или уточнение?
Во-первых, следствие или уточнение?
Да, у нас есть следствие, а у нас есть уточнение.
Это вообще разные вещи.
Следствие? И каким же образом мы будем применять это следствие?
Такая, знаете, как всегда, я, конечно, плохо знаю какие-нибудь тренировки по ЧГК, но ощущение такое, что вот у вас возникло вот это словосочетание.
Давайте сразу в ассоциации. Где вы слышали это словосочетание?
Где там на этой доске вот это словосочетание, похоже на F?
Где оно?
О, в леометрии.
Да, даже не в уточнении, а просто в леометрии.
То есть у нас кто-то там не имеет префиксного периода меньше П2, а ведь действительно.
То есть по большому счёту. Что происходит?
В этом месте у нас есть вот этот вот азулюминиевый фрагмент.
В этом месте у нас есть вот этот фрагмент.
меньше f2, а ведь действительно, то есть по большому счёту, что происходит? В этом месте у нас есть вот этот вот
огрызок, вот мы тут пост символов отпилили, да, и мы неожиданно обнаружили, что у нас тут есть, что у нас
есть префиксный период f2, да, это не самый короткий, что приятно, тогда идея такая, оказывается мы тут,
то есть мы можем обнаружить, что вот этот вот префиксный период мы можем распилить на две строки,
так что, вот что нам эта Лемма говорит? Лемма говорит, что вот это вот, оставшийся огрызочек,
плюс вот эти каменусы, один копий значит этой старой строки, плюс абсолютно любая хрень,
имеет префикс, не имеет префиксного периода, короче, чем f2. Он добрый, приятно, очень приятно.
Вот, ну более того, так как этот f2 здесь был не минимальным, то очевидно, что действительно,
пост штриха, кажется, больше, чем пост, то есть теоретически Лемма допускала, что на самом деле этот
префикс здесь и произойдет, но в данном случае это не так, потому что в этой позиции вот эта строка имеет
префиксный период, короче, чем f2, это мы уже знаем, просто это мы знаем вот из этих фильмов, то есть помнишь,
что у нас есть два, хотя бы два префиксных периода, и f2 второй из них. То есть таким образом мы можем
вот эту все проделать. И более того, рано или поздно это даже закончится.
А использовали мы это так, что, смотри, Лемма 3 подразумевала, что может быть этот отпил, он как бы не посередине
этой строки будет, а в самом начале. А в самом начале это быть не может, поэтому получается, что пост будет
строго увеличиваться. Вот, но заметим, что, да, что приятно. Приятность здесь заключается в том, что как бы мы,
у нас строка будет все время, мы двигаемся вправо, но мы никогда до конца s не дойдем, правда?
Но префиксные периоды-то рано или поздно закончатся, правда? То есть таким образом, рано или поздно мы, то есть
действительно, значит этот пост, значит этот цикл закончится. И тогда в итоге я скажу, что у меня присвоить s от 1 к
у пост, естественно, да, а в s от пост плюс 1 до модулес. Отлично. Отлично, как минимум, в том плане, что мы теперь, мы
сумели разбить на строку на две так, что у суффикса не более чем один префиксный период. Да, но я сразу согласен с вашим
исключающим видом достижения неактивных. Вот. Потому что если у нас была просто цель отпилить суффикс, у которого не более
одного префиксного периода, мы могли просто один символ отпилить и возрадоваться. Наша цель была больше. То есть нам,
на самом деле, нам хочется не просто отпилить суффикс, но отпилить суффикс в 100, чтобы у этого суффикса был достаточно
большой шифт такой, что он префикс, оказывается, ок, его длины. Неплохо, да? Хотелось бы так сказать. Значит, как это связано
вообще? Ну, во-первых, давайте внимательно посмотрим. Ну, давайте вот, смотрите, вот что сделаем. Значит, что мы сделаем,
что мы делаем, что мы делаем. Смотрите, давайте себе вот как бы это очень красиво описать. Заметим, что мы от строки S
отпиливали несколько раз какие-то строчки, строчки через строчки. Давайте мы предположим, что мы отпилили, во-первых, мы
отпиливали строки U1, U2, U3. Ну, допустим, вот до сюда дошли UL, вот допустим, L раз мы отпиливали, да? И при этом, когда мы L раз
отпиливали, у нас L раз встречались вот эти вторые префиксные периоды, да? Вот это вот P2,1, P2,2, P2,3 и так далее P2,L, да?
Понимаете, да?
Все мы можем сказать. А, ну это, наверное, можно вылезть, тереть, в общем. Ой, ладно, шалка, что мы этот процесс теряем, конечно.
Там как-то на него отсылка идет, надо было его, видимо, вон туда вниз перерисовать, но ладно. Мы будем уже заморачиваться.
Значит, смотрите, ну ладно, самое дело, его все равно вытесняется вот этим процессом. Вот. Что можно сказать?
Во-первых, заметим, что, ну, можно заметить следующее, что, во-первых, всегда модуль Уитого, во-первых, строго меньше, чем...
Значит, модуль Уитого строго меньше, чем P2 и T, согласны? Видно, да?
Видно, да?
Видно?
Только P и 2, кажется.
Нет.
А, нет, подводи-ка там.
Ну, видите, мы тут P2, поэтому, видите, я тут, поэтому, второй индекс. Ну, давайте, я могу еще запяты присылать, если хотите.
Ой, Господи. Ой, слушайте, а у вас какой-нибудь, это теормег какой-нибудь будет?
Или какой-нибудь там веселый курс будет названием математические методы Михаильки? Нет?
Нет.
Нет? Нет?
Нет, я просто помню, там, собственно, там, не знаю, там начинается какая-то там очень веселая возня с индексами, там, красивая теория.
Ну, ладно, не важно.
Так вот, я, собственно, это к чему? Значит, каждая Уитая меньше, чем P2. С одной стороны, да?
Что я еще могу сказать?
А еще я утверждаю, что каждая P2, оно, я утверждаю, строго меньше, чем P, вот почему-то мне очень хочется утверждать, P2 плюс 1 делить на.
Ха.
Ну, ладно.
Ну-ка, скажите мне, с чего я это взял?
Ну, 100% без следствия.
Ну, практически да, даже усиленной версии, что...
Ну, во-первых, то есть, как бы, вообразив себе, что вот у нас есть P2, то есть вот этот вот P2.
Сейчас это второй префиксный период, да?
Но, как бы, но в следующий раз, на следующей итерации, уже первый префиксный период будет не менее, чем столько, правда?
Ну, тогда получается, ну, мы помним, что второй префиксный период больше первого хотя бы в k-1 раз, даже строго больше, чем в k-1 раз, понимаете, да?
Тогда получается, что если предыдущий второй префиксный период был меньше либо равен следующего первого, то следующий второй будет больше, больше, вон, h в k-1 раз.
Что?
Можно это записать или можно это не писать?
Записывайте, записывайте.
А, в смысле, чтобы я это записал?
Ну, в общем, давайте я так пишу.
Смотрите, второй префиксный период после нитого шага, он, как вы уже выяснили, меньше либо равен первого префиксного периода минимального в i-1.
Почему мы так делаем? Потому что в этом пункте мы прям в явном виде прописали, что у нас нет префиксных периодов на следующем шаге, короче, чем вот этот второй, бывший.
Вот. Это у нас просто.
Но при этом вот эта штука, она строго меньше, чем P2i-1 поделить на k-1.
Это был такой красный мастик, если не так.
Вот красота.
А это нам говорит, даже вот, ой, опять я.
Да, то есть надо здесь, опа.
Вот такое следствие у нас есть.
Ну, отсюда, в общем-то, я вот это и выиграл.
То есть, получается, эти P2i растут как геометрическая пресса.
Тогда получается следующее.
Значит, теперь дальше рассуждение такое.
Вот предположим, что мы тут вот L раз отпиливали.
И у нас вот это вот осталось страхой V.
Понимаете, да?
В общем, на самом деле, из этого всего следует маленькая приятная вещь.
Ну, то есть, в принципе, из этого можно сделать вывод, что, на самом деле, u равно o от P2i.
Ну, я беру свою прогрессию.
Да, потому что, по большому счету, все предыдущие члены оцениваются как геометрическая прогрессия шагом k-1.
И все, что хватает k равно 3.
Ой, я уже интригован.
Может, правда сейчас мы это, лучший алгоритм придумаем, не знаю.
Нет, ну, нет, я...
Вряд ли, конечно.
Ну, вряд ли, да.
Доказались.
Ну, скажем так, ладно, да, вроде как...
Скажем так, есть подозрения, что на самом деле это нам понадобится, знаете, когда?
Когда мы...
Потому что, смотрите, мы, что доказательстве теории, мы сейчас не остановимся, да?
То есть, почему мы сейчас делаем перерыв, потом продолжим?
Почему?
Потому что нам потребуется не просто доказать теорию, а еще придумать, как это все делать эффективно.
То есть, пока мы просто...
Поэтому, да, доказательство теории, может, это и не надо,
а вот для построения алгоритма нам потом бы уже не помешало.
Так вот, поэтому пока ничего страшного.
Так вот.
То есть, действительно, раз у нас идет эта диаметрическая прогрессия,
то там, в общем-то, и константа не сильно большая,
там что-то типа k-1 поделить на k-2.
Так вот.
Ну, теперь давайте посмотрим,
какое отношение это от p2n имеет к v?
У v должно быть...
Ну да.
То есть, точнее, к шифту этому какое отношение?
Ну, если у v есть один фрексный период, да?
Ровно один, два уже не может быть.
Да, два уже не может быть.
То он хотя бы p2n.
Ну да, да.
А шифт не может быть меньше этого фрексного периода.
Да.
То есть, у будет от шифта.
Так.
А если у v нет фрексного периода?
Так, нет, погодите.
Ну, шифтом...
Нет, шифтом давайте вот сейчас аккуратнее.
Значит, рассуждение...
Значит, в случае...
Теперь есть два случая.
Давайте, давайте, в случае.
Там два случая.
Первая.
Значит, v имеет фрексный период.
Ну, крайне логично его назвать p1l+.1.
Правда?
Но тогда...
Значит, тогда и века следующая.
Что?
Ну, во-первых, конечно же, p2a меньше либо равно p1l+.1.
И мы утверждаем, ключевое утверждение, что это меньше либо равно шифт.
Ну, шифт понятно.
Вот v от m2v.
Почему это так?
Ну, иначе у строки...
Да, совершенно верно.
Фрексильный шифт плюс p1l+.1.
Да.
То есть, действительно, заметим, что вот эти вот 4 p1s у нас есть.
Они вот на лицо.
Как?
Ка.
Чего?
Ну, у нас ка.
Ну, да, ка...
Да, говорим формально ка, но рисуем 4, раз уж мы себе 4.
Вот.
И действительно, окажется, что если шифт меньше...
То есть, если вот шифт окажется каким-нибудь там вот, я не знаю, вот таким...
Ну, что значит, что шифт оказывается вот еще меньше?
Что вот это вот равно вот этому, да?
Тогда это означает, что вот эта вот строчка тоже является периодом этой строки.
Вот.
Ну, тогда получится, что вот этот, как минимум, префикс, он является и p1 периодичным, и это вот периодичным.
Значит, он...
Значит, получается, вот эта строка не базовая, как всегда, потому что вот эта строка будет являться gcd от p1 и вот этого периодичным.
В общем, дальше стандартное решение.
Кажется, что мы что-то прям буквально, прям ровно такое же доказывали уже.
Ну, да.
Может быть, тут можно на какую-то верму сласлаться, да.
Но нам уже, по-моему, легче просто этим шамлоном придраться.
Вот.
То есть, противоречие.
Ну, вот тогда, в общем-то, все.
Тогда доказательство на лицо.
В этом случае.
И остается только маленький финальный случай.
А что делать, если префиксного периода нет?
Что делать?
Ну, тогда shift хотя бы длина... больше, чем длина выделить на k.
Вот.
Иначе он повторяет хотя бы k раз.
И он будет...
Так, сейчас-сейчас-сейчас.
Так.
Значит, у v нет префиксного периода.
Так.
Так.
Слушайте.
Может, это тогда надо правильно маркером написать?
А.
Да.
Правильно.
Да.
Мы снова пишем.
Используем.
Ну, вот.
Тогда по лемме 1.
Можно сразу на лему 1 сослаться.
А можно повторить это обсуждение, да.
Ну, лучше сослаться, наверное, то у нас будет много повторений.
Ну, вот тут философский вопрос, смотрите.
С точки зрения, как бы, написания прессивого текста, да.
А как бы, если наша цель, как бы, понять его и научиться воспроизводить,
то может быть лучше, может быть полезнее просто 5 раз применять одну.
Это уже будет.
Вот.
Вот, как бы, знаете.
Хотя тут вот философский вопрос, как писать, знаете, потому что...
Вот, так.
taped, ready to feature.
Ну давайте, у нас вот есть наша подвоя льда, но оно
больше, чем длиновая, кажется.
Да, ну на самом деле, да.
То есть, по большому счёту...
То есть, действительно, заметим, что P2v не превосходит v,
там даже v не происходит, там ещё, по-моему, поделить на k-1, даже, что-то.
Поэтому, по большому счёту, да, тут можно...
Да, давайте, рыженький, значит, раз теперь напишем.
Больше либо равно на P2l делить на k, получается.
Этому ещё не точно оценили, потому что тут, я говорю, на k-1, скорее всего, ещё можно поделить.
Откуда? А вот откуда, смотри.
Значит, когда мы последний раз отпиливали вот этот вот v, да,
у нас был вот этот P2l был вполне себе притиксным периодом.
Мы отпилили чуть меньше,
и получается, что вот 3 копии ещё из хвостов ещё осталось.
Нам должно быть P2l умножить на k-1, не поделить.
Дальше?
Ну ладно, давайте просто.
Всё.
Скажись, на этом ли мы и доказаны?
Вообще даже не Лемма, а H2O и Лемма. Всё.
То есть, неожиданная красота. То есть, видите, мы...
Неожиданная красота с отпиливом теоретической прогрессии.
Вот. Ну вот.
Мне, сначала, нужно доказывать, как здесь диаметрически,
то есть, так, мне кажется, понятнее.
Потому что в реальной статье тут, на самом деле, просто написано
докажем по индукции, что там...
Что-то типа, докажем по индукции, что там...
На каждом шаге суммарно отпиливано не более, чем там
минимум из первого префиксного периода и там,
собственно, какого-то окончательного периода, умноженное
на константу k-1, k-2, прям, честно, по индукции.
Ну вот. Ну, а, честно говоря, мне хотелось этого избежать.
Хотелось просто, чтобы было понятно, как будет берётся.
Так вот, продолжение.
Итак, значит, мы с вами...
Ну вот, итак, ну, фактически, мы уже действительно доказали все необходимые теоремы.
Ну, то есть, да.
То есть, давайте ещё раз, кратко, потому что мы в текущем моменте есть.
В прошлый раз у нас было, как реализовать алгоритм за линию,
если у нас есть вот такое разбиение.
А на прошлой нот, а на прошлой лекции, точнее, на паре,
которая у нас была сегодня, мы с вами убедились.
Мы с вами даже придумали вот некоторый алгоритм,
который позволяет действительно такое разбиение на UEV найти.
Вот он, собственно.
Фактически, всё, что нам осталось, это научиться реализовывать этот алгоритм,
во-первых, за линию,
а, во-вторых, за линию, то самое главное, чтобы использованная память была в лоб единиц.
Ну, можно так, для разминочки сказать, да.
То есть, в чём у нас...
Ну, давайте так, разомнёмся.
Что нам вообще надо в этом алгоритме?
Ну, первое, что нам нужно в идеале,
это научиться понимать, есть ли вообще в текущей строке префиксный период.
А точнее, два префиксных периода.
Понимаете, да?
Ну вот, то есть, есть ли два, и желательно найти второй.
И совсем в идеале, совсем в идеале,
желательно этот второй префиксный период находить за окей его длины.
Вот, давайте подумаем.
Вот, предположим, что нам с небес по факсу присылают, допустим, за от...
за от этого П2, и это самая П2.
Вот, внимание, вопрос.
Хватит ли оно верить, что после этого мы тогда тут автоматически победили?
Вот, что нам нужно, кроме того, чтобы получать вот этот вот
префиксный... этот вот второй префиксный период за окей его длины?
Да, нужно пост-штрих находить.
Да.
Действительно, нам нужно выходить этот пост-штрих еще.
А теперь давайте вспоминать.
А как же мы этот пост-штрих вообще будем искать?
Мы там будем находить на меньший префиксный период С бесконечный?
Да, у нас был тот самый мистический алгоритм.
Да, он тут даже остается.
Я его давайте даже перепишу.
Знаете, как это было?
У меня возникла мусор.
Сейчас, где она?
Так.
Да, сейчас.
А можно попросить в сторону?
Давай.
А как у нас там с контестом?
Ой, пока его нет.
Хотя прям очень хочется.
Ну, просто меня просили спросить.
Ага, понятно.
Вы хотите контест?
Если можно, мы заканчиваем?
Нет.
А тут два момента.
С одной стороны, можно и без контеста, с другой стороны, как бы...
Зройся, на первом курсе еще там, например, кто-то спрашивает, а то как-то страшно.
Вот у нас новых задач как-то нету, а в основном потоке там уже третий контест.
Ну вот, видите, спрашивается, как-то вот страшно.
Разрывается шаблон, почему?
Нет, не волнуйтесь.
Контест будет, потому что на самом деле и по геометрии, в первую очередь, на стручке, на самом деле у меня там какое-то большое домашнее задание есть, так что...
Пожалуй, на самом деле, да, шум не мешает его, в общем-то, для вас выложить.
Как минимум его.
Вот так.
Так что...
Так что спасибо за упоминание.
Этот алгоритм, соответственно, 4 у нас выглядит так.
То есть помните, вот этот четвертый шаг, я его даже как четвертый шаг нарисую, пришло время его перерисовать сюда.
Вот.
И отпиливать вот эту штуку мы будем примерно следующим образом.
То есть мы ее будем отпиливать как, соответственно, что?
То есть здесь предлагает так.
То есть у нас тут механизм нарисуем так.
То есть действительно помните, допустим, равно 0 для какой-то строкии абстрактной.
И был у нас механизм, что, там, пока, соответственно, s от cos плюс 1, пум-пум, модуль s, точнее, у него есть, что у него есть?
Префиксный период, допустим, p1, там, меньше, чем некое мистическое число p2.
Пока у нас это будет, мы будем делать cos плюс равно p1.
Это не совсем тот алгоритм, который был, но трансформируется он следующее.
Значит, у нас есть, представим себе, строка s, и мы еще знаем, что у нее есть мистический префикс p2.
У нее есть мистический префикс p2, который является, чем?
Правильно, тоже, по большому счету, префиксным периодом.
Вот, обратите внимание.
То есть что мы сейчас имеем?
Это действительно какой-то суффикс строки s, у которой есть префиксный период p2.
Исходный алгоритм так и говорил.
Отлично, пока мы будем находить, так сказать, префиксный период меньше, мы этот префиксный период будем открыть.
И мы знаем, что до того даже, обратите внимание, если это рассуждение проводить даже не для строки s, а для первых k копии вот этой длины p2,
то можно вообще убедиться, что это отпиливание закончится раньше, чем мы достигнем p2.
Потому что по большому счету мы этим занимаемся, практически для этого p2 мы и занимаемся.
Потому что строка базовая, мы это знаем, поэтому вот.
То есть вот такая трансформация, можно даже четыре штриха назвать, потому что это не совсем то.
И теперь идея, но этот алгоритм тоже, смотрите какой интерес получается.
Если у нас есть мистический черный ящик, который умеет находить префиксный период и желательно за от его длины,
то тогда вот это вот мероприятие мы легко проведем за от отпиливаемой длины, согласны?
Пока вы это поняли.
То есть таким образом получается, что все, что нам нужно, то есть все передаст просто.
Задача дана строка s, пожалуйста, найдите ее.
Скажите, задача лайна.
Верно ли, что у нее есть хоть один префиксный период? Если да, то найдите минимальный.
И задача, ну даже не хань, хотя скорее медленно будет.
Скажите, пожалуйста, верно ли, что у строки есть хотя бы два префиксных периода? Если да, найдите, пожалуйста, старый.
То есть я упреждаю, что ровно эти черные ящики нам теперь нужны для того, чтобы добить задачу.
Согласны?
Ну да.
Поэтому, ну вот, собственно, предыдущую лекцию я начал с того, что начал все это писать.
Эту лекцию я начну с того, что я это все буду стирать.
Да, правильно, обязательно надо на видео заснять, как я все стираю.
Действительно, да.
Так, значит, все это мы убираем, потому что мы уже поняли, что там где-то победа.
То есть, как всегда, мы все резать, мы свели все к черному ящику, который там по ссылочке получается, там строчку или даже сдвиг ее.
Да, как видите, это алгоритм, видимо, удобно будет резать, вот именно все ставил строчки, чтобы удобно было передавать там указатель какой-нибудь красивый.
И, и, и, и, и, и, и.
И все, что нам теперь нужно сделать, это, то есть, теперь задачка зеленая.
Итак, просто теперь абстралируемся.
Дана строка, говорим мы, s.
Значит, версия easy.
Есть ли у нее префиксный период?
И важно, и если да, то найти минимальный префиксный период прайки.
Причем требуемое время работы, то есть время работы, я так не пишу, o от p1, если p1 есть, и o от модуль s иначе.
Ну, если там, если там проходят такие вообще префиксные периоды нет, то, в общем-то, это нас начинает сразу устраивать, потому что мы там на этом алгоритм заканчиваем.
Это версия easy.
Вот.
И версия, так сказать, видео.
То же самое.
Прям кэппи пастим, кэппи пастим, кэппи пастим, но в конце пишем хотя бы два различных префиксных периода.
Если да, то найти минимальный, найти второй минимальный префиксный период p2.
И то же время, соответственно, работы, o от p2, если p2 есть, и o от p1, о от модуль s, конечно, иначе.
Такова наша финальная цель.
Такова наша финальная цель.
Как же это сделать?
Ну, конечно, да.
Слово первой задачи, в общем-то, навекает, но действительно, сильно сложной сейчас не будет.
Ну, это все и так.
То есть, короче, технологии будут не тривиальные, но, в общем-то, уже, в общем, ничего принципиально нового мы не изобретем.
Смотрите.
Потому что для того, что все это базируется на следующем.
Смотрите.
Вот, допустим, вот я неслучайно не стер вот этот вот механизм, потому что, естественно, мы будем пользоваться им.
Смотрите.
Вот, допустим, что мы этот механизм, допустим, делали бы как-нибудь с нуля, и на каждом шаге переходили бы к rp плюс 1,0.
То есть, переводя говоря, там все кушки честно вычисляли, допустим, да?
Мне жутко интересно вот что.
Я хочу по строке f получить, допустим, вот эти вот шифты.
Шифты с под q, q равно 1, 2, 3 и так далее модулест.
Ну, как минимум, в принципе, я хочу вот получить какие-то шифты.
Как мне эти шифты найти?
Ну, на самом деле, есть мистическое утверждение.
На самом деле, давайте я тут подменю переменную, вместо q я тут не напишу, потому что q у меня будет немножко другой.
Очень просто.
Как это, ну вот.
Ну вот.
Значит, утверждение такое.
Смотрите.
Если в какой-то момент.
В какой-то момент.
Допустим, вот этой схемы.
Схемы kmp.
Возникло p в первые, причем в первые.
P plus q равно i.
То есть у вас P plus q, оно как бы, это понятно, это жраница вот этого совпадения.
А, еще важный момент, смотрите.
Тут, конечно, эта схема применяется, когда мы ищем s в t.
Но тут фишка будет в том, что мы теперь эту s будем искать как бы саму в себе.
Ну, то есть идея будет такая, смотрите.
Вот у нас есть строка s, и мы как бы ее ищем саму в себе.
Только начиная не с первой позиции, а соответственно со второй.
Понятно, да?
Ну, то есть если просто в честную для каждого p с нуля это искать.
Ну, по большому счету мы прям в явном виде z функцию найдем.
Ну, если мы будем прям в тупую это делать, мы прям вот будем от каждой позиции z функцию искать.
Но в чем глупости смысл?
Допустим, мы вот ищем действительно у строки s z функцию.
Можно себе такое представить, да?
Тогда заметим следующее, что когда мы вот, например, в позиции какой-нибудь i,
вот ладно, после позиции i тут мы считали z функцию,
и эта z функция вот этот вот reach reach reach дошел вот аж до сюда, да?
То тогда мы замечаем следующее,
что если этот reach дошел до позиции g,
то мы уже можем сказать, что shift от g будет ну не более чем p, правда?
Ну, если так вот z функция дошла.
И если то же самое, если в какой-то момент оказалось, что p равно i,
и, допустим, q равно g минус i, да?
Это вот в терминах этого алгоритма.
То есть тогда мы гарантируем, что если как бы тут у нас достигла g,
значит shift ну либо i, либо еще меньше.
Но с другой стороны заметим, что, скорее всего,
если бы у нас shift был меньше где-нибудь, вот, из 3,
и там reach тоже бы его достигал,
то тогда мы бы уже до g, до позиции g явно дошли бы и раньше.
То есть поэтому идея будет в том, что если мы тут t подменим на s,
то есть будем искать s само в себе,
то оказывается, когда впервые,
когда для какого-то числа i мы впервые достигли p плюс q равно i,
это означает, что в этот момент мы поняли, чему равно shift от i.
Понятно?
Понятно, о чем я говорю?
Но, разумеется, мы не будем искать, это все честно прям все.
На самом деле, заметим следующее, что, как и в алгоритме z функции,
мы тоже в честную все z функции не ищем, правда?
Ну, что значит в честную?
Это означает, что мы же как бы на каждом шаге q не обнуляем, правда?
То есть на самом деле, по большому счету,
когда мы ищем z функцию, мы там пытаемся, значит,
искать ищем z функцию,
то есть на самом деле, по большому счету,
когда мы ищем z функцию, мы там пытаемся, значит,
то есть когда мы там q какой-то нашли,
мы пытаемся сдвинуть на такой p штрих,
чтобы уже знать, что q точно может быть равно q минус,
вот во сколько вы тут сдвинули,
чтобы потом эту границу двигать дальше, правда?
То есть если с какой-то позиции мы уже точно знаем,
что это не произойдет, то мы там просто за 1 все понимаем и не паримся.
То есть действительно, то есть на самом деле,
на самом деле, если мы хотим найти такие шифты,
то нам все p-шки находить не надо,
а вместо этого нужно следующее.
То есть механизм будет такой.
Давайте вот сейчас затру и вот, значит,
попробую рисовать вот все это воображать себе за 1.
Смотрите.
Значит, мы ищем s саму в себе,
и вот допустим, начиная со второго символа,
то есть начиная со второго символа,
мы тут какой-то обнаружили, что тут какой-то префикс
совпадает.
Видите, да?
Тогда мы для всех вот этих позиций
уже шифты как бы знаем, потому что мы до них дошли.
Что теперь?
А мы хотим какие-то шифты дальше.
Что для этого нужно?
Ну, для этого, как мы говорили,
на языке префикс функций, мы бы сказали,
нам нужно найти максимальный собственный суффикс этого префикса,
который совпадает с префиксом.
И передвинуть вот эту p на него,
то есть p фактически,
ну, в идеале, по крайней мере,
передвигается сюда, q уменьшается,
и мы пытаемся продлевать эти p шприкушки,
вот, начиная с этого лумя.
Как бы, насколько нам удастся продвинуть,
вот мы еще шифты найдем.
Понятно, виртуальная смена?
Скорее всего, не очень.
Ну вот.
А что вас пугает?
Вот, на всякий случай.
Может быть вас пугает то, что непонятно,
как это делают залог единицы памяти?
Ну, в частности.
А вот, давай, я конкретно это и не предлагаю.
Я пока просто описываю,
как, ну, один из вариантов,
как работает алгоритм кнута Мориса Пратта, да?
Ну, вот.
Ну, как теоретически мог работать алгоритм кнута Мориса Пратта?
Мы берем строку s и идем в ней вот по строке t.
То есть, сначала мы там вот,
ну, вот, если бы мы шли по строке t,
мы бы начинали вот с самого начала.
Мы тут вот нашли какой-то префикс строки s,
подающий с префиксом t,
а потом хотим двигаться дальше, да?
Как мы двигаемся дальше?
Мы, собственно, берем максимальный суффикс,
который совпадает с префиксом строки s,
и начинаемся вот насчитывать этот префикс,
префикс, префикс, вот докуда дойдет.
Потом мы тоже скачем по вот этой штуке,
эта штука называется префикс функция,
как вы помните, да?
И двигаемся дальше.
Вот.
Было дело?
Да нет, наверное.
Так вот.
Так мы искали под строки в строке s.
А ведь, по большому счету,
это можно проинтерпретировать следующим образом.
В каждой позиции строки t
мы нашли максимальный суффикс,
то есть максимальную длину
под строки заканчивающейся в этой позиции,
которая совпадает с префиксом строки s.
Согласны?
Что, для вас префикс функция звучит как-то по-другому?
Нет.
Отлично.
Так вот.
А теперь давайте вспомним,
как мы саму префикс функцию искали.
А саму префикс функцию искали
мы абсолютно тем же самым образом.
То есть мы для каждой позиции в строке,
на этот раз уже s,
пытались найти максимальные длины под строку
заканчивающейся в этой позиции,
совпадающие с префиксом.
Только на этот раз мы накладывали на себя ограничение,
что сам вот весь этот префикс мы не рассматриваем.
И как мы это делали?
А можно это делать так?
Допустим, для вот этих всех позиций мы ответ нашли.
Дальше мы говорим так.
Для этого префикса мы берем вот этот вот предыдущий префикс.
То есть максимальный собственный супикс,
совпадающий с префиксом.
И начиная с этой позиции,
то есть начинаем пытаться этот префикс расширять,
расширять, расширять, насколько он совпадается
тоже с префиксом.
И тогда для каждой из этих позиций,
куда мы дойдем, мы ответ уже нашли.
То есть префикс-пункцию прямо можно сказать вычислить,
вычислить, не вычислить.
То есть в классическом алгоритме KMP
это эквивалент от того,
насколько мы будем идти,
так что каждый следующий равен предыдущий плюс один.
В какой-то момент это отрубится,
и тогда что мы сделаем?
Мы опять возьмем этот суффикс,
он же префикс,
и пытаемся продлить его.
Может так случиться, что продлить не удастся,
и мы будем скатать несколько.
Да, то есть еще раз говорю,
не устаю повторять,
все, что я сейчас делаю,
это как бы переформулирую
в более подходящие нам терминологии
алгоритм кто там может собрать.
Ни более того.
Так вот.
Но заметим, что я говорил о том,
что мы так можем префикс-функцию находить,
но заметим, что мы же помним,
что префикс-функция и shift
по большому счету одно и то же.
Что такое shift?
Что такое shift от i?
Это фактически i минус префикс-функция от i.
Поэтому, когда мы вот таким образом находим префикс-функцию,
и вот находим такую префикс-функцию,
то мы и шифты находим.
Так вот.
То есть заметим, что в явном виде
нам эти шифты даже хранить не обязательно.
Обратите внимание.
Нам не нужно хранить эти шифты,
потому что на самом деле наша цель перечислять эти шифты
и по большому счету наша цель,
вот если мы решаем задачу easy,
вообще посмотрите, цель easy.
Найти по большому счету такое минимальное i,
что shift от i равно i поделить на х.
Ну вот, потому что какая наша цель?
Чтобы найти минимальный префиксный период.
Что такое минимальный префиксный период?
Это минимальный период,
то есть минимальный префикс,
у которого после себя еще k минус одно вхождение.
Правда?
Вот.
Поэтому по большому счету наша цель найти,
когда у нас впервые произойдет,
что shift от s, ну ладно, можно сказать,
меньше либо равно и поделить на k,
но на самом деле нас интересует ровно и поделить на k,
потому что если у вас для какого-то i это будет там...
Ну вот.
Ну потому что легко доказать,
что если это будет строго меньше,
то скорее всего это будет означать,
что на предыдущих i это уже было верно.
То есть практически нас интересует первый такой shift.
То есть если мы сейчас научимся аккуратно искать шифты,
прям поочередно,
то мы просто запустим этот процесс
и просто остановимся ровно в тот момент,
когда действительно этот shift,
shift от черного i окажется ровно вк раз меньше.
В чем-то заметим, что если мы это будем делать
за o от количества пройденных позиций,
то в общем-то и получится то, что нам надо,
потому что получается мы тогда найдем этот shift
за o от shift умножить на k.
Согласны?
Да, вспомним k это константа.
Вот.
Ну и теперь возникает вопрос.
Как же нам этот процесс запустить?
Ну, начнем с того, что конечно же,
во-первых,
напоминаю, мы все это делаем для strategy s.
Теперь.
И начинаем мы на этот раз не с нуля,
а с единички, конечно.
Понимаете, да?
Ой, ну и тут, конечно.
Да, тут можно сказать ищем s, тоже в s.
Вот.
Ну и самое интересное,
что же у нас будет для pq?
Вот как вы думаете.
А свой переход мы будем забавать.
Ну да, ну понятно, что мы здесь напишем
что-то в духе if там оказалось
действительно,
p плюс q равно там,
p умножить на k,
да?
Совершенно исключительно.
Да, равно, равно, конечно.
То,
так сказать, понятно.
Понятно, да?
То есть в тот момент, как только мы найдем
действительно какой-то shift, который равен
f умножить на k,
f умножить на k,
то соответственно мы победили.
Можно вот так написать, можно
так и пишем.
Потому что shift от строки p плюс q
равен в точности p, как не знаем.
Так вот.
Итак, а теперь внимание.
На что же нам надо заменить pq?
Вот давайте просто даже
картиночку теперь.
Вот так.
То есть получается жила была
строка s.
Мы тут начали после позиции p
шуровать.
И неожиданно обнаружили, что
q пробежала, но
k копии не произошло.
И мы теперь должны вот
о этой всей штуке,
то есть о этой штуке каким-то образом
взять, так сказать,
вот этого.
То есть перейти к следующему
прештриху.
Ну, совсем идеального вот такого
прештриха мы, конечно, не знаем.
Не можем так, мы откуда мы его знаем.
Мы же претикс функцию не хранили
в явном виде, если бы хранили, то нашли.
Но мы ее не знаем.
Ну, что мы тогда в этом случае знаем?
Я утверждаю, что
можно на доске найти, что мы знаем.
Ну,
давайте так.
Что у уже рассматриванного на
чего у этого рассматриванного
нами префекса строке s точно
нет?
Префекса строке s точно нет.
Совершенно верно.
А что это значит?
Ну,
ну,
ну,
ну,
ну,
а что это значит?
5
6
7
8
Да, совершенно верно.
То есть это означает, что раз у
этой всей строке нет, то вот у
этой строке, которая является префексом
этой строке, да, префексного периода точно
нет.
То есть еще более точно нет.
Ну, раз его нет,
тогда вот LEMO1 нам гарантирует
что шифт от этой строчки,
то есть это называется вот у этого
всего, шифт
больше строго, чем
у поделить на х.
Ну вот, поэтому мы пишем теперь нашу
уже полюбившуюся нам в прошлый раз
строчку
f плюс максимум из
единицы и куба
делить на k
вверх
и ноль.
О!
И в общем-то, как мы уже по прошлому
разу поняли,
мы на самом деле теперь этот
первый префексный период,
то есть это вот,
то есть на самом деле этот минимальный
префексный период найдем с вами
теперь за какое время?
Ну, либо он есть, и мы найдем, либо
он есть, и найдем мы его за время
этого периода умножить на k,
либо
либо
ну либо мы так до конца строки
и дойдем, и его не найдем.
То есть, в общем-то, как заказываем.
Почему это будет работать именно за
то есть это будет
за сколько это будет работать?
Ну, суммально, это будет работать
за от
рассмотренного нами части строки,
ну просто потому, что
каждый раз, когда мы как бы рассмотрели
строку k вот так с нуля,
мы как бы дальше сдвинулись на k
логично, да?
Дальше, действительно, сдвигаемся
на, как бы, k,
k поделить на k.
То есть, ну, мы, кажется, в прошлый раз уже
как минимум в прошлый раз уже обсуждали,
действительно, почему из этого следует,
что это линия, да?
Ну, например, по тому, что, как бы,
вот эта p-шка сколько-то раз
сдвигается на суммарную какую-то длину,
а всех остальных действий не более,
чем суммарную эту длину, умножить так.
Вот.
Ну, таким образом, кажется,
вот задачу изи мы, в общем-то, и решили.
Затребовала нам
асимпотик.
Так, есть ли тут какие-то вопросы?
Да нет, наверно.
Нету?
То есть, мы как будто бы, ну вот, мы
такой же алгоритм применяли,
когда мы искали в строке там t,
строку беспроекционного периода.
А мы сейчас, как бы, в строке s,
ищем строку s, и на данный момент она
беспроекционного периода,
поэтому мы тот же самый.
Ну да, мы идем, пока в ней не нашли
префекционный период, уж как только
нашли, мы остановимся.
Да, абсолютно верно.
Идея абсолютно та же самая.
Ну и, наконец, финал апофеоз.
Хотя, может быть, это уже финал
финала, на самом деле.
Вот я даже предложу подумать.
Как теперь, вот тоже глядя сюда
и глядя туда, как теперь допилить
этот алгоритм так, чтобы найти не
только это, но еще и второй период,
если он есть, конечно.
Ну, судя по всему, момент, когда
мы находим первый период, мы его
сохраняем, и дальше делаем
алгоритм, ну, как во втором случае,
когда у ВВ есть единственный период.
А что значит?
А точнее, есть маленькие детали.
Есть маленькие детали.
Ну да, совершенно верно.
В какой-то момент, вот мы, да,
начинаем мы ровно с этого.
Мы это идем, идем, идем, идем,
и, наконец, натыкаемся на первый
префексный период.
Давайте я их даже нарисую.
Вот, допустим, вот у нас ведь длинная,
длинная, длинная строка С, и вот,
наконец, это произошло, мы этот
первый период нашли.
Поехали?
Ой, даже поменьше, наверное.
Потому что, если мы ищем следующий,
следующий, там, помните, в К1, там,
во сколько там?
В кучу раз больше.
Вот это вот П1.
Вот это вот П2.
Вот это вот П3.
Вот это вот П4.
Вот это вот П5.
Вот, допустим, мы дошли,
и вот прям до этой позиции и дошли.
Спрашивается, что делать дальше?
Дальше, ну, во-первых, дальше мы сделаем вот что.
Этот момент мы закончили,
но Q насчитывать не прекратили,
потому что в этот момент мы вот,
у нас P равно P1, и вот это вот Q.
Да, мы продолжаем это насчитывать,
насчитывать там,
и вот, где-то, наконец, остановились.
Это мы насчитаем bridge от, ну, от P1.
Да, совершенно верно.
Мы насчитали вот это вот,
то есть это вот, да, П плюс Q,
равно, действительно, ridge.
Ridge с индексом модулес от П.
Абсолютно верно.
Так вот.
Ну вот.
Ну вот.
Что хочется теперь делать?
Теперь, как-нибудь, что можно сказать
про второй префиксный период,
если такой существует?
Так, ну, потому что, смотрите,
я вот так скажу.
Идея теперь заключается такая.
А давайте теперь просто продолжим
вот этот алгоритм, условно,
так и будем его читать до тех пор,
пока не наткнемся еще на какую-нибудь E
с чем-нибудь.
Вот, допустим, мы после, после внимания этого,
строго после,
будем идти, идти, идти, идти, идти, идти,
и наткнемся, наконец,
на позицию такую E,
что, как мы неожиданно выясним,
shift с индексом S от этой E
и, допустим, равен
и поделить на K.
Вот я утверждаю, что, как мы бы
во второй раз такое встретим,
в чем строго после иринча,
я утверждаю, что вот этот E
и будет
наша P2.
Я почему-то такое утверждаю.
Да.
Оставим пока, да,
тут возникнет второй вопрос,
а как это делать,
учитывая, что конкретно этот пересвод
уже не будет работать,
потому что в рассмотренном префиксе
уже вполне может быть
и префиксный период P1, да?
Вот, пока давайте просто
предположим, что мы будем
продолжим каким-то мистическим образом
эти шифты насчитывать
и неожиданно выяснится, что
вот в какой-то момент
после иринча что-то нашли.
Ну, может, это что-то не является
префиксным периодом?
Ну, давайте так.
Это кандидат
во второй префиксный период,
правда?
Ну, в том плане, что мы нашли
еще один префикс, который делится
на K одинаковых строчек.
Может так случиться, что это
не префиксный период?
Как такое может случиться?
Ну, например,
строчка не базовая,
или эта строчка не базовая,
вот эта вот, которая длиннее
делить на K, да?
Или на самом деле
она базовая, но просто
второй префиксный период был
где-то раньше.
Ну, начнем вот с чего.
Давайте для начала докажем,
что строчка...
Давайте для начала докажем, что
нигде вот тут раньше мы это
делить на K
встретить не могли.
Ну, точнее так, не может
быть меньше, то есть P2 не может
быть меньше, чем мы поделить
на K.
Еще раз?
В смысле, что...
Ну, мы хотим доказать...
Мы попытаемся доказать,
что это есть второй
префиксный период, да?
Если вот таковое в какой-то
момент произошло,
даже, может быть, даже в
какой-то момент произошло
вот такое.
Ну, да.
Ну, понятно, что для P2
такое произойдет,
потому что...
Ну, потому что, да,
когда мы будем рассматривать P2,
ну, давайте вот попытаемся
рассмотреть P2.
Ну, где оно?
Ну, во-первых, начнем с того,
что P2...
Вот P2, может, тут два способа.
Может быть, это P2,
либо после P2.
Может ли P2
закончится до ричат P1?
Нет.
Почему?
Потому что будет не базово просто.
А сейчас...
Ну, если...
Если там близает в
ричат P1 и P2, то не может
это быть.
Да, а почему не может?
Ну...
Может, P2 просто будет не базово,
но это логично.
Почему?
Ну, рассуждение тогда такое.
Предположим, что P2 вместе с K-периодами
влезла в ричат P1.
Да, случайно.
Ну, по размеру никаких проблем,
потому что ограничений на ричат P1 у нас нет,
он может быть очень большой.
Но тут вот какая проблема.
Дело в том, что если рассмотреть строчку
и получается эта строка
и P1 периодично,
и P2 периодично,
и в нее влезает как
4... ну, в смысле, как копии P2,
так и K, и даже более копии P1.
Отсюда легко вывести
полемия периодичности,
что получается эта строка конкретно,
она еще и GCD от P2
P2 и P1 периодично.
Вот.
И тогда отсюда будет следовать, что
ну, может так оказаться, что этот GCD
равен P1,
поэтому базовость строки P1
пока как бы противоречия не вызывает.
Но базовость P2 нарушается,
потому что у нее оказывается
есть GCD от P2 и P1,
которые меньше, чем P2,
и оказывается, что эта вся строка,
эта GCD периодично, значит P2,
не базовая противоречия.
Понятно?
Понята логика?
Более того, я вам даже сразу скажу,
что по большому счету
я вам сразу себе даже сказать,
то есть из этой логики
автоматически следует, что P2
она отсюда же следует,
что она, что на самом деле
P2 обязана быть
просто даже строго больше,
чем вот этот вот GCD
от P1 пополам.
Потому что если тут умещается
в GCD хотя бы две копии P2,
то применяется абсолютно то же самое
рассуждение.
Или даже GCD от P1
или GCD от P2
Потому что тогда облезает
строка от P1 P2, у которой
два разных периода.
Рич P1 пополам,
ну без пополам просто.
Да, просто Рич от P1
минус P1, да.
Да, совершенно верно.
Тут я думаю, что
какое-то такое словосочетание
тут тоже в статье есть.
Да, на самом деле
можно совсем вот так даже.
Вот.
Ну это что означает?
Это в принципе означает, что
это вот P2, да,
то есть она уже вторая копия
выходит за пределы.
Но если она закончилась
раньше, чем И,
ну если она закончилась тогда
позже, чем вот этот Рич,
но раньше, чем И,
то тогда у нас позже, чем Рич,
но раньше, чем И
возникла бы вот тут ситуация,
когда здесь шифт должен быть
как минимум вот это вот поделить
на K, а то и больше, если что.
Ну мы тут себе
ослабили немножко условия.
Поэтому получается, что
если мы впервые встретили
такой шифт, что шифт
этой больше ли правильной
поделить на K, то раньше
никаких вот этих
вторых префиксных периодов не было.
Вот.
Ну возникает тогда естественный вопрос.
То есть тогда получается, да,
что скажем так, у нас есть
получается вот такое
потенциальное P2,
которое вот почему-то хотим сказать,
что это И поделить на K.
Теперь возникает вопрос.
Хорошо.
То есть P2,
то есть реальный P2
заведомо больше либо равен.
Теперь возникает вопрос.
Да, почему это
не P2 еще может быть?
Может быть не базовый.
Да, действительно.
Но даже шифт меньше.
Ну да.
Ну да.
Действительно.
Ну хорошо, да.
Может ли так случиться,
что эта строка не базовая?
Ну чисто теоретически,
почему бы и нет.
Ну и теперь возникает вопрос.
Почему не может быть так,
что эта строка
не базовая?
Почему не может быть так,
что P2 не базовая?
Потому что тогда этот ее период,
который на которой отделят,
это им есть...
Ну совершенно верно.
Тогда это в принципе означает,
что у нас какая-то строка...
Нет, погодите.
Ну я проявить саму в себе
ничего не...
Да, у нее есть меньшая строка.
И что стало?
Эта меньшая строка
может быть равна,
например, P1.
Тогда у нас P.
Ну P2 – это есть шифт.
Ну P2 – это есть шифт.
А шифт меньше...
Мы пошли, что шифт меньше,
чем P2.
Так.
Ну...
Так.
Ну да.
Так.
Ну сейчас...
Ну вот.
Если P2 – это шифт,
то у строки не может быть
меньшего периода.
А мы получили,
что есть меньше.
Сейчас, а кто сказал,
что P2 – это шифт?
Ну, потому что
у нас так...
Ну, у нас так разговаривают,
что у нас всегда P
будет шифтом по плюску.
А, ну вообще говоря, да.
Да.
Ладно.
Прямо и точно мы знаем,
что это заведомо шифт.
Ну шифт – это что?
А, ну да, действительно.
Если окажется,
что P2 – не базовая,
то есть тут действительно
есть какие-то
мистические подкопии.
Это случайно.
Ну, если если 4,
то это 5,
6.
Да.
То действительно окажется...
Да.
То есть если тут окажется
какая-то подкопия,
то тогда окажется,
что шифт А3 будет не таким,
а это вот не так,
потому что у нас
кое-как есть такой.
Потому что, в общем-то,
заметим, что он тогда
на рассмотрение этого шифта,
уже до этой позиции,
и должен был бы
ранее дотянуться,
а он дотянулся только что.
Да.
Да.
То есть таким образом
получается,
что все, что нам нужно,
это искать те же самые шифты.
Только...
Ну вот.
И найти второй раз,
когда мы второй раз
встретим позицию.
То есть, в общем,
встретим ее после ричи
от P1 строго после ричи.
И когда встретим,
что шифты А3
больше неправильные приискали,
и поделить на K,
тогда это и поделить на K
и будет P2.
И если мы это
успешно сделаем,
то мы, опять же, найдем
эту занужную нам симпточку
от P2 на K.
А точно ли больше
либо равно?
Ну...
Ну...
Если так,
то наверно,
все-таки меньше либо равно.
Не, меньше либо равно
то оно всегда будет.
Хотя...
Нет, как раз
не обязательно.
Оно может быть...
Когда строка
не имеет каких-то циклов,
то шифт будет равен
ну, типа, практически...
Ну, то есть...
А, да.
Пожалуй, да.
Вообще, у нас какая-то
тавтология получилась,
потому что
как бы то, что
при пиксторке S
он вот разбивается
ровно на 4, да?
То есть, что
у него вот...
И вот для делить на 4
это профессиональный период
равносильно тому, что
шифт А3 равно
и делить на K строго.
Ну да.
Ну и мы
какую-то сейчас
тавтологию
два раза доказывали,
как будто.
Не, почему?
Нет, то почему нет?
Нет, ну почему?
Первый раз мы доказывали,
просто когда искали
первый этот период,
просто мы искали,
когда мы
первый раз столкнулись
с тем, что у нас тут
как будто нам
как бы найденный префикс
оказался
четырьмя копиями
чего-то,
это первое что-то.
Мы сейчас как бы
про П2
как-то в две стороны
что-то пытались доказывать,
но мне кажется,
это тавтология все-таки.
Почему тавтология?
Ну, еще раз.
Как бы, просто утверждение,
что то, что
какая-то строка
там, П2
префиксный период
равносильно тому, что
шифт С
там, понятно,
4П2
равно П2
условно.
Ну,
и еще, что этот
префикс не базовый.
Равносильно.
Потому что, если шифт
ровно такой,
значит, префикс не базовый.
Ну, что шифта
меньше.
Ну, вот.
Ну, кажется,
этого достаточно,
чтобы утверждение
не было.
Ну, нет.
Ну, там не равносильно.
Когда второй,
надо было еще упомянуть,
что этот второй
вот этот.
Если вот,
хотя, можно, ладно.
Если насильно,
в этом да и дело.
Да, ладно, если
так,
да, получается равно.
Нет, давайте подумаем.
Тут
как бы...
Так, давайте тут
аккуратно,
в жутчестве живом.
У авторов почему-то
такое утверждение
нет.
Видимо,
потому что он как-то
целился только на первые
два, дальше
плевать.
Но вообще,
действительно,
мистическое утверждение.
Вот, давайте подумаем.
Мистическое
утверждение.
То есть,
то есть,
это
действительно,
то есть,
это называется
И префикс
и
префиксный период.
Давайте подумаем
на эту тему.
Префиксный
период.
Тогда
и только...
Ну вот,
строки С,
тогда и только тогда,
когда
shift от
И
с индексом
С
равен
прямо точности
И
поделить на
Х.
Мы такое
прям
жестко утверждаем.
Причем,
утверждает,
что если мы в это
поверим,
то
псевдо таким
образом...
Только
нет,
shift от
4
shift от
К
И
равно И, кажется.
А.
Ладно.
Или вот тут
и поделить на
К.
Так,
действительно,
почему это так?
Ну.
действительно.
Во-первых,
действительно,
пусть у нас
И делится...
То есть да,
тут надо было написать
пусть
И действительно меньше
либо равно С
и оно делится на К.
Так.
Блаблаблаблаблаблаблабла.
И вот
еще
ynamics и
оценverts.
Да,
тогда мы
к parecerº
мы
Не, ну да, если в это поверить, то получается мы таким образом, ну, по модулю того, как конкретно правильно делать перескоки, мы получается можем находить и второй, и третий, и четвертый, и пятый, и десятый, и двадцатый, и вообще все.
Вот, ну давайте разбираться. Как что-то искать префиксные? Ну давайте разбираться. Так, верно ли это утверждение? Ну вот, если и поделить нока в префиксный период.
Что у нас тогда получается? Так, вот у нас строка с. Вот, допустим, позиция и, и выяснилось, что тут четыре копии есть. Ну, потому что shift и разный и поделить нока, это означает, что четыре копии тут есть.
Понимание? Вопрос. Верно ли, что это префиксный период? То есть верно ли, что это и поделить нока базовое? Ответ. Нет, неверно. Почему? Потому что, если оказалось, что эти подстроки можно тут разбить на копии,
то тогда обнаруживается, что shift от и оказывается сильно меньше, чем и поделить нока. То есть и поделить нока, и еще там на что-то поделить на это количество копий. Это как минимум.
Ну вот, следовательно, здесь строка базовая. То есть таким образом в одну сторону доказали. То есть сейчас вот мы как бы, значит, хорошо, давайте в эту сторону доказали.
А нет. Да, в эту сторону доказали. Теперь давайте попробуем доказать наоборот. Жила была позиция и, и совершенно случайно выяснилось, что ее shift равен и поделить нока. То есть опять.
То есть опять что получается, что shift? То есть какая это вопрос?
Мне кажется, то, что вы сейчас говорили, это было доказать это в обратную сторону.
Нет, мы сказали. Нет, первая передача в эту сторону доказать, что было такое. Предположим, что и поделить нока оказался префиксным периодом.
Тогда это означает, что у нас тут есть вот эти вот на лицо k копий и, как следствие, означает, что shift от i, это либо и поделить нока, либо что-то меньшее.
Да. А, откуда? А, ну да. Меньше, не делите. Да, понял, да. Мы как бы доказали в обратную сторону. Да, в обратную. Согласен.
Ладно, давайте еще раз. Да, мы доказали в обратную сторону. Мы, потому что мы привернули такое. Пусть у нас shift от i равен и поделить на k. То есть тут вот обнаружилось таких вот k копий.
Мы вот считаем, что это префиксный период. Для этого нам нужно доказать, что тут есть k копия, это уже есть, и то, что вот эта строка длины и поделить нока базовая.
Как ее доказать, что она базовая? Это очень просто. Пусть она не базовая, тогда тут есть вот такие копии.
Тогда что? Тогда это означает противоречие с тем, что shift равен и поделить на k, потому что если можно эту префикс длины и подразмить не на k копии, а на большее число копий, то тогда и shift будет меньше, чем и поделить на k.
Он будет не поделить на это большее число копий. Так что да, в одну сторону. Так что доказали именно в эту сторону.
Что?
Ну мы...
Ну не совсем там...
Ну не совсем там такое утверждение, да. Да, возможно мы и одни и те же мысли гоняем по кругу, но формулируем их сразу в то время.
Так что ничего страшного.
Теперь далее.
Теперь давайте наоборот. Пусть у нас и поделить на k это префиксный период s.
Ну начало картинки то же самое. Это означает, что тут k копии длины и поделить на k на лицо.
Это означает, что shift на t это не более, чем и поделить на k.
Предположим, что меньше, что здесь shift меньше.
То есть, ну картинка сейчас будет та же самая, разница будет только в том, что тут не такие точные копии.
А скорее всего это будет вот так, вот так, вот так и вот так же.
Но для нас самое главное, что как минимум две копии и этого и этого в этот префикс попадут.
А дальше стандартная схема.
Хцд между вот этим и вот этим.
И доказательство того, что вот эта строка не базовая.
И тогда это не префиксный период.
То есть на самом деле можно просто себе такое извинить.
Что, как только у нас shift, если у нас shift равен ровно, обратите внимание, и поделить на k.
Обратите внимание, кстати, вот эти вот ричи, кстати, не подходят, потому что тут будет shift строго меньше, чем и поделить на k.
Обратите на это внимание.
Видите, да?
Поэтому по большому счету, можно считать, что мы его тоже все насчитываем, насчитываем, насчитываем.
Но по большому счету, если у нас просто из какой-то черной магии мы идем слева направо и каким-то образом за амортизированную линию получаем shift каждой этой позиции,
то как только мы встретим второй раз ровно и поделим на k, в этом месте мы и остановимся.
Остается только финальный вопрос.
А как мы после этого ричи вообще этим механизмом будем двигаться?
Ведь что я имею в виду?
Я имею в виду, что раньше мы двигались, пользовались, раньше мы жестко пользовались тем, что ни одного префиксного периода мы не нашли, правда?
Ну рассуждение у нас было, что если вот где-то, допустим, ричи остановился, а префиксного периода мы еще не нашли, значит p можно двигать на q, поделить на k, потому что в этой части префиксного периода тем более и нет. Согласны?
Понятно, о чем я говорю?
А вот теперь внимание-вопрос.
А как нам...
Ну теперь уже мы не гарантируем, что в найденной строке q нет префиксного периода.
Вот на этот раз что мы не знаем, то мы не знаем. Теперь внимание-вопрос.
Ну вот, теперь возникает такое внимание-вопрос.
А если мы знаем только, что этот префиксный период, видимо, не более чем один?
Видимо, нужно действовать теперь как в пункте b того алгоритма?
Ну да, ну в пункте b, даже не в пункте b, а в лемме 2.
Ну, фактически, да, сначала мы пользовались тупо леммой 1.
А теперь у нас есть лемма 2.
Ну, с помощью леммы 2 теперь мы будем говорить следующее.
То есть, ладно, мы нашли, что у нас есть префиксный период p1, и до этого момента, пока мы на это и не наткнемся, второго префиксного периода у нас нет, правда?
Тогда получается следующее.
Давайте я все это сотру. Красивое утверждение, но мы его все-таки сотрем.
И получается маленькая приятная вещь.
Маленькая приятная, маленькая приятная, вот так.
Что дальше получится?
Получится следующее.
Что теперь на каждом шаге, пока мы ищем этот потенциальный второй период.
То есть, мы тут наткнулись на очередное p, не путать с p1, да?
Ну ладно, как до p1 работает, понятно?
Вот, допустим, если у нас оказалось, что p больше не было равно, чем p1, и вот, допустим, мы тут шли, шли, шли, шли, дошли, и тут погран застава, вот это q, и надо это q как-то уменьшить.
Каким же образом это можно сделать?
Ну теперь мы знаем, что на этом префексе не более чем один префиксный период. Согласны?
Более того, что... Нет?
Нет.
Это так подозрительно, смотрите.
А ведь, мы знаем, что на любом из рассмотренных префиксов строки у нас не более чем один префиксный период.
Причем, более того, если он есть, то он равен в точности p1. Согласны?
Других нет.
Поэтому у нас теперь два варианта.
Да, я даже сейчас без леммы 2, по-моему, это все напишу теперь.
Вариант номер раз.
Вариант номер раз.
Если оказалось, что q меньше, чем k умножить на p1,
ну понятно, что p1 тут как бы начинается, но предположим, что вот тут p1, но предположим, что вот k копии не дошло.
Да, это та самая. Это та самая.
Это та самая.
То тогда получается, что p'q' просто становится по старой стиле.
p плюс максимум, как всегда, 1, и вот это вот q поделить на k,
и 0.
То есть, p можно спокойно на q поделить на k, двигать,
потому что у нас была, ну, например, потому что была уже лемма 1,
которая нам говорила о том, что если бы там нашелся шиф q поделить на k меньше, то, извините, мы бы там и префиксный период меньше нашли, а мы его уже не нашли.
Отлично, да?
Ну вот.
Ну или можно прям вот здесь это посмотреть, что как бы шифта, то есть получается, что...
То есть, получается, шифт, он как минимум, то есть он там не менее чем p1.
Не более.
Не более p1.
Да, если он строго менее.
Скажем так, ну, утверждается, что ладно, в данном случае, на самом деле, шифт просто равен p1.
А, ладно, так, он либо равен p1, либо q оказался вообще меньше p1, такой тоже может быть.
Но если q, правда, оказался меньше, чем p1, значит, мы просто p на единичку увеличиваем и не паримся, да?
А если тут хотя бы p нашлось, то мы знаем, что эта строка p1 периодична, а меньшего периода не будет, потому что тут две копии есть, и гцд, и круче рец.
Вот.
Поэтому здесь не паримся.
Ну, у тебя кофе у нас с ним, кстати, нашлось, почему?
Ууууу...
Да.
Ууууу...
Две копии не нашлось?
Так, ну хорошо, ладно.
А, тем более, что мы тут накатили, а не гжлину парили.
Ну, неважно.
Ууууу...
Уууууу...
Так, ну ладно, лучше нашлёпся на левму 1.
Нет, хотя вот хочется какой-то образ, давайте вспомним.
Нет, просто честно скажу, хочется прикрутить сюда какой-то образ, чтобы не отсылаться просто как на чёрный ящик какой-то левмы.
Вот давайте вспомним, как мы левму 1 доказывали вообще?
Ну, так и доказывали.
А, ну только что так и доказывали, по сути, что если есть такой шифт...
Ну да, если есть шифт, если его куделить на k, то давайте рассмотрим вот этот шифт умножить на k, и действительно в этой позиции окажется вот то доказательство, которое мы только что проверили.
Да.
Противоречие будет заключаться в том, что этот шифт...
Противоречие будет заключаться в том, что этот шифт, если, то есть противоречие будет том, что если у нас действительно шифты окажутся меньше, чем куделить на k, то у нас, собственно, просто и префиксный период, окаж achieving меньше, чем P1 противоречия.
Потому что?
Потому что, мы знаем, что, как минимум, потому что мы знаем, что на этих префиксах есть только один при, не более чем одного префиксного периода, и этот префиксный период, поgyо 1 ничто другое.
ни что другое. То есть, если окажется шифт здесь меньше, то окажется, что мы просто меньше, чем
P1 префиксный период найдем, а такого не бывает. Мы же следим за тем, что, мы же как бы у нас,
помним, да, что мы говорим, что у нас минимальный префиксный период у этих всех префиксов,
это P1, другого нет. Вот такая вот. Но теперь, если говорить о втором случае. Если совершенно
случайно оказалось, что P1 сюда прекрасно уместился. Так и допустим вот так. Что тогда делать?
Если Q больше либо равно K, то из этого следует, что у нас какие-то странные случаи. У нас же
там должно быть один случай, так что K, P1, не больше Q, не больше reach от P1, и второй случай,
все остальное было так. Ну да. Можно пытаться, да. По идее, тут дальше должна быть отсылка на
Lemma2. Ну как бы, ну вот. Ну говорим, вот пусть у нас есть строка, и у нас вот этот префикс у нас
есть, и у него есть префиксный период. Ну вот, тогда префиксный период. Ну вот. Тогда получается,
действительно, ну вот, что мы про него знаем? Мы уже про него знаем, что, действительно, что вот,
мы уже знаем, что K умножить на этот префиксный период меньше либо равно Q, но теперь возникает
вопрос, а не знаем ли мы, случайно, что это Q меньше-либо равно реча?
Или другими словами, да. То есть, на самом деле, идея простая. Хочется сейчас
показать, на самом деле, что вот этих вот P1, они тут
добегают, на самом деле, не только до сюда, но и дальше.
Верим ли мы в такое?
Я не очень про это... С чем навесить? Можно просто проверить, правда ли это, это
мигает стверны или нет. А это кто? А это эквивалент. Сейчас, что мы хотим сделать?
Нет, или нет. А, или наоборот. Нет, ну мы хотим...
Ну, мы хотим следующее. На самом деле, мы хотим... Вот я пока свой прощикам поставлю.
Хотим заявить, что P-Q- равно, на самом деле,
такой интересной вещи, как, значит, P плюс P1 и Q минус P1.
Но это верно только, если Q не больше, чем реча P1.
Да.
Не очень понятно, что мы делаем.
Так.
Ну, скажем так, в идеале... Ну, давайте думать, а что делать?
В идеале мы бы так хотели здесь делать.
Да, в идеале мы бы так хотели. Но это верно не всегда.
Действительно. Потому что, действительно, если тут возникает вопрос, если мы возьмем
P1, верно ли, что он дойдет до конца? Это легко проверить.
Давайте я вот так нарисую. Вот, допустим, оказалось, что вот это вот...
Да, второе. Допустим, оказалось Q, значит, больше либо равно, чем K умножить на P1.
Теперь возникает вопрос. Рич от P1.
Мы знаем этот рич, мы уже его вычисляли, помните, да?
Возникает вопрос, верно ли, что он больше либо равен Q, да, или нет?
Вот.
То есть, что значит, что он больше либо равен?
Это означает, что это вот периодичность, на самом деле, вот...
Ну, так как вот, то есть мы, конечно, ее мерили где-то отсюда, но это же, как бы, префикс.
Получается, если выяснилось, что она до Q дошла, то получается, вся вот эта строка P1 периодична.
И более того, мы знаем, что меньшего периода здесь нет, помните, да?
Да, то есть, ну, от меньшего периода нет.
Ну, просто потому что, видите, тут K-копии вместилось, значит, получается, если тут еще есть меньший какой-то шиб,
значит, тут тоже K-копии вместятся, и получится меньше периода, это не базовая строка, бла-бла-бла, раз.
Вот.
Поэтому в этом случае мы честно переходим на P плюс P1 и Q плюс P1, то есть P сдвигается, а вот эта вот граница Q влево нет,
поэтому там за линию все в порядке.
И второй случай.
То есть, это если да.
А если это не верно, то получается, что эта строка P1 периодичной не является.
Вот.
Ну, что тогда?
Вот что делать, если выяснилось, что вот тут период не доходит?
Ну, то есть, это означает, что строка нет по этим периодичным.
Ну, тогда, это есть, ну, хвост первый случай, и тогда прибавляем максимум с 1 на Q, Q, Q.
А почему это первый случай?
Первый случай, говорили, ну, вот.
Ну, в смысле, потому что это не выполнен в слове леммы тоже.
Так.
Ну, да.
Действительно.
Что, если reach у нас нет, то есть, если reach оказался, Q оказался больше, чем reach,
то вот это не выполняется.
Так.
Ну, а так как, ну, а тогда дальше что не выполняется?
То есть, в претекстный период, то есть, мы точно знаем, что он равен P1,
и мы знаем, что этот P1 получается у нас, если это меньше, либо равен QK,
то получается, что shift ему не равен.
А может, он меньше?
Нет, поглядите, как нам помогает V1, V2?
Ну, давайте вспомним.
Что вы там думаете?
Ну, если shift от Q не больше, чем Q делит на K, то shift будет в претекстном периоде,
значит, он может быть только равен P1, и получается,
что V2 будет как раз верно, ну, в вторую скотчу.
То, что мы уже проделывали как раз.
Ну, да, хорошо.
Доказательство lemma2 мы проделывали.
То, что мы проделывали, когда мы алгоритм строили на почтной паре.
Хорошо.
Нет, а все-таки давайте попробуем.
А вот без lemma2 это сформулировать можно?
Вот что означает, что, допустим, это P1 есть, там, то есть, видим, P1 есть,
то есть, 4 копии P1 у нас на лицах, и дальше они на сколько-то продолжаются, но не до упора.
Что это значит?
Куда это? В финалочке, скажем.
Мы утверждаем, что на самом деле теперь получается...
Ну, действительно, тогда утверждается, ну, утверждается простая вещь, да,
что П штрихку штрих опять равно вот этому П плюс, там, максимум из 1 и Q делик на K,
и, соответственно, ноль.
То есть shift как мне, то есть, больше, чем Q делик на K.
Почему так?
Ну, причина очень проста.
Почему?
Допустим, на этот раз оказалось, что все-таки здесь...
То есть shift устроен так, что, действительно, у нас тут 4 копии, как оказалось.
Вот.
То есть, может быть, даже, ну ладно, меньше, наверное, не может быть, потому что мы уже упоминали,
но может окажется строго больше.
Но это даже неважно.
То есть, может быть, вот так, так, так, так и вот так.
Ну, что это тогда означает?
Ну, вот.
Ну, в принципе, тогда это, ну, вот.
Это означает, то есть, по-видимому, это означает, что вот это вот, то есть, вот этот вот shift
и окажется потенциально в рефиксном периоде.
Или не окажется.
Так, где вы так все пропадаете?
Уже ли самая сложная вещь у вас?
Что-то уже понятно.
Ну, не знаю.
Вот я пока не понял.
Если вы мне поняли, если вы уже поняли, объясните.
Я просто.
Желаю, чтобы без ссылки на левый 2.
Я, собственно, поэтому.
Если хочется вот формальной ссылки на левый 2, да,
но хочется вот без формальной ссылки, хочется это как-то увидеть прямо здесь.
Ну, это вот случай, когда Q больше, чем reach, да,
и пусть shift не больше, чем Q делить на K, так?
Четыре раза влезает.
Ну, тогда этот shift будет рефиксным периодом по лиме 1.
Значит shift будет обязательно ровно по 1.
Ну да, мы заметим, что.
Ну да, то есть действительно мы помним, да, что shift лизает,
но действительно заметим, что это окажется действительно рефиксным периодом,
потому что, да, если это не простая строка, значит, тут и shift будет меньше, да.
Вот.
Ну тогда получается, что он тогда,
ну он тогда должен быть, получается, по 1, потому что других у нас нет.
Ну вот, чем-то и победа. Да, окей.
Все, да, будет счастье.
Да, то есть получается, действительно, тут опять маленький ивчик опять возникает.
Ну вроде на этот раз кажется, что без лимочек уже и обошлись.
Ну что ж, ладно, на этот раз вроде, так, вроде все.
Ну не совсем обошлись.
Вот мы тогда показали, что в таком случае P1 равен shift от Q и не больше Q9 на K.
И тогда мы хотим показать, что на самом деле это вот тогда,
ну типа к P1 не больше Q, не больше reach от P1.
Это как бы, это у женщин по себе, но с другой стороны, это тоже ссылка на лиму все равно.
Ну тут просто, тут как вам удобнее, понимаете?
Как бы, понятно, формальная статья в этом месте аккуратно ссылалась на лиму 2.
Ну просто она там по своим формалистическим причинам это сделала.
Вот была лима 2, то есть вот это, то есть как бы доказательство легко проявить.
А в данном случае нам бы хочется это просто вот именно понять.
То есть поэтому я тут вот, поэтому можно не ссылаться на лиму 2, а просто вот действительно уже мыслить.
То есть мы говорим, что если у строки есть период вот этот вот, период P1,
префиксный период, то есть 4 копии в начале этого базового периода по 1,
и мы знаем, что других таких нет, то тогда мы отсюда же и выводим,
что сдвига, так чтобы этого сдвига было 4 копии тоже нет,
потому что в этом случае это тоже там оказывается просто другой префиксный период.
Ну ладно, так, ладно, поэтому можно не доказывать лиму 2,
можно прямо вот тут сказать, что если тут нашелся шифт больше или меньше,
главное не равен, то как бы будет противоречить тем, что...
Ну все, есть ли еще тут вопросик?
Это когда уже саму строку S там в тексте 3 сказали, да, правильно.
Ну да, технология везде одна и та же.
Но это неудивительно, когда мы префикс пунга, когда мы KMP запускаем,
мы же тоже делаем одну же технологию сначала чистого внутри S,
а потом мы делаем другую технологию.
Ну да, это неудивительно, когда мы префикс пунга, когда мы KMP запускаем,
мы же тоже делаем одну же технологию сначала чистого внутри S,
а потом относить на строке S.
Все более того, в общем-то, и схема.
Так что да, да, то есть в общем-то технология как-то да.
То есть может быть разновидности, вместо мечей берем топоры,
или именно мечи горят, но технология фокуса одна и та же.
Так, ну что ж, так что думаю, кажется, на этом мы успешно победили этот алгоритм.
