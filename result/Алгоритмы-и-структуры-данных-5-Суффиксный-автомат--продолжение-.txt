Так, ну что, давайте попробуем быстренько бахнуть софикс на автомат до конца. Давайте быстро
напомню, что мы в прошлый раз поняли. Во-первых, мы будем строить автомат инкрементально,
добавляя по одной букве в конец строки одну с другой. И будем следить за тем,
какие новые лонгесты появляются. Мы понимаем, что новые лонгесты однозначно определяют классик
эвалентности. Мы понимаем, что sc это всегда новый лонгест, и потенциально у нас есть еще второй
товарищ, который может стать новым лонгестом. Возможно, если он раньше не был, то теперь
становится. А если он раньше был, то он не становится, но он так лонгестом остается.
Значит, s0 это у меня был максимальный суффикс, суффикс sc, встречавшийся в s как под строка.
Ну, хорошо, давайте разберемся сначала вот с этим вот классом, с классом, который порождается
вот этим новым sc, новым лонгестом. Давайте поймем, как устроены ребра, входящие и сходящие из него,
например. Ну, вроде понятно, что из него ребер быть не должно, потому что sc это самая длинная строка,
нельзя получить никакую строчку длиннее, поэтому из sc точно ребер не выходит. Давайте поймем,
какие ребра в sc входят. Ну, понятно, вот если в старом автомате было состояние, отвечающее строке
s, то мы, наверное, должны провести ребро по букве c в новом состоянии sc. Ну, это вроде понятно,
да, потому что, напоминаю, ребра мы проводим ровно в том случае, если в одном состоянии есть такое
слово, которое после дописывания одной буквы справа становится одним из слов второго класса. Ну,
понятно, если было s, то приписывание c дает sc. Дальше, вообще, вот скажите, а какие слова могут,
ну, точнее, из каких вершин мы можем с помощью буквы c попасть в класс sc? Как устроены все такие
слова? Да, это именно суффикс s, ну, потому что что такое слова, лежащие в этом классе? Это sc и
несколько его самых длинных суффиксов, вот такие вот строчки. Значит, как я могу попасть в этот
класс? Ну, во-первых, понятно, что я могу туда попасть только по букве c, потому что все последние
буквы всех этих слов это c, значит, все ребра ведущие в этот класс, на них написано только
букву c. Вот, и более того, это слова обязательно такого вида, что они либо вот это слово плюс c,
либо вот это слово плюс c, либо вот это, либо вот это, ну и так далее. То есть это в любом случае
суффикс s, к которому после дописывания c я попадаю в класс эквивалентности строки sc. Поэтому мне
нужно в каком-то смысле перебрать все суффиксы s, которые были в старом автомате, и из них провести
ребра в sc. Ну, давайте начнем это делать. Вот, мы начали с того, что из этого состояния провели
ребра в sc. Дальше, меня интересует следующий суффикс s, который лежал бы уже в другом классе,
чем s, и из него я буду хотеть проводить ребра в sc. Но, благо, у нас как раз хранится информация про
вот этот вот максимальный суффикс, лежащий в другом классе. Это link. Да, потому что вот в этом классе
и так лежит s и несколько его самых длинных суффиксов. Если я хочу взять самый длинный суффикс,
лежащий в другом классе, ну потому что для этого класса я уже все все все все определил. Значит,
мне нужен link. Да, link это в точности самый длинный суффикс из другого класса. Ну,
значит, давайте возьмем ссылку этой вершины. Попадем в какую-то вершину p. В общем случае,
если из этой вершины буквы не было перехода по c, то его нужно будет создать. Да, ну потому что
если раньше отсюда не было перехода по c, то теперь, понятное дело, он точно должен появиться,
потому что можно прочитать суффикс s и дописать c, тогда мы попадаем в точности вот сюда. Ну,
давайте поймем, что такие переходы нужно провести именно сюда. Вот давайте я скажу,
что давайте сразу я возьму несколько раз всю ссылку. Мы поняли, что вот все интересующие
у меня классы, из которых ребро идет в s и c, они достигаются прыжками по суффсылкам из s. Вот давайте
я из s несколько раз возьму суффсылку. Дошел до вершины p. Пусть из p не было перехода по c.
Что это значит? Это значит, что здесь лежат такие строчки, давайте я их как-нибудь назову, пусть
будет t. Тут лежат такие строчки, которые, во-первых, являются суффиксами s. Мы понимаем,
что раз она достигнута по суффсылкам, то значит t это суффикс s. Но это такой суффикс, что к нему
нельзя приписать c справа, оставшись под строкой s. Потому что ранее в автомате у меня
было можно было прочитать все подстроки. Это автомат на всех суффиксах s, то есть там все
подстроки точно читаются. И если раньше к t нельзя было приписать c, значит t, c уже не под строка s.
Раз не было перехода, значит такой строки не было в старом автомате, не было в старой строке s.
А теперь появляется, теперь понятное дело, что t, c это уже под строка s, c. Это под строка
s, c. Потому что мы взяли какой-то суффикс s, приписали c, понятное дело, мы получили под строку
s, c. Ну и причем это какой-то суффикс s, c, который ранее нигде не встречался. Более того, это какой-то
суффикс s, c, который ранее не входил в s. Ну а мы знаем, что это за класс эквивалентности. Мы в
прошлый раз описывали в точности множество суффиксов s, c, которые не являются под строками s.
Это в точности само s, c. Здесь лежат в точности строки, которые только что получили первое
единственное вхождение. Вот s, c, например, только что появилось впервые, его раньше нигде не было.
И несколько самых длинных его суффиксов только что получили единственное вхождение. Можно так
сказать, можно сказать, что у этого множества слов правый контекст это просто епсилон. Ну то есть,
у s, c точно правый контекст это только епсилон, только пустую строчку можно дописать, чтобы стоять
суффиксом. Значит, здесь, поскольку вершина это у меня класс эквивалентности, то здесь лежат в
точности все такие строчки, у которых правый контекст это епсилон. Ну что такое строчка с
правым контекстом епсилон? Это в точности те суффиксы s, c, которые раньше в s не встречались.
Потому что если бы он встречался где-то левее, то значит к нему, если бы он был где-то вот здесь,
то значит тогда вот это вот было бы в его правом контексте, можно было бы дописать справа. Но
поскольку ничего дописать нельзя, то получается, что здесь такие строки, у которых ровно одно
вхождение сейчас, и это вот в конце строки s, c. Окей? Ну вот, значит получается, что если я
итерируюсь по вот этим вот вершинам, которые являются суффсылкой s в некотором поколении и
нет перехода по c, то я его вынужден создать в состоянии s, c. Потому что для каждой строки отсюда
приписывание к c возможно, и я точно попадаю в этот класс. Поэтому вот отсюда из всех этих вершин я
провожу вот такие ребра. Да, пока не встретим вершину, из которой переход был. Именно так.
Пока понятно вот это? Хорошо. Значит да, как вы правильно заметили, вот давайте мы будем идти по
вот этим суффсылкам, потому что я понимаю, мне нужно провести все ребра ведущие в s, c. Такие
ребра идут только из суффиксов s. Ну вот я их как раз все перебираю в порядке убывания длины.
Давайте рассмотрим самый простой случай. Когда я так шел-шел-шел, дошел до корня и даже в корне,
точнее даже из корня не было перехода по букве c. Случай первый. Во время вот этого вот
итерирования по суффсылкам, значит во время итерирования по суффсылкам, то есть по линкам,
дошли до корня и даже из корня не было перехода по букве c.
Тогда на самом деле картинка очень простая. Вот здесь мы итерировались, итерировались по суффсылкам
несколько раз и дошли до корня. Корень в смысле стартовая вершина. То, откуда мы начинаем читать
все слова. Корень, он же старт. И ни заодно из этих вершин не было перехода по c. Значит,
как мы только что поняли, мне их нужно все провести в только что добавленное состояние s, c.
Я провожу все такие ребра. Ну и понятно, что в s, c больше других ребер нет, потому что что мне
нужно было, какие вообще в принципе ребра могут сюда вести. Ребра, которые ведут из суффикса s и
после дописывания c, становятся суффиксом s, c. Ну это вот в точности все такие ребра. Мы их только
что провели. Других суффиксов у s нету. Мы их все перебрали. Значит, никаких других ребер добавлять
в s, c не нужно, по крайней мере. Ну а дальше давайте заметим следующее. Вообще давайте
поймем, когда такое может происходить. Я утверждаю, что такое происходит,
если и только если s0 равно epsilon, что эквивалентно тому, что c не входит в s. То есть вот такой частный
случай, что мы во время интервью дошли до самого начала, до самого корня нашего автомата и даже
из него не было перехода по c. Может быть только в этом случае. Значит, ну вот это более-менее понятно,
почему s0 это epsilon. Потому что s0 это самый длинный суффикс s, c, который раньше был в s.
Ну если он какой-то был не тривиальный, не пустой, то есть представьте себе. Вот была s,
c какая-то моя длинная. Пусть в ней был какой-то не пустой s0. Самый длинный суффикс, встречавшийся
ранее. Вот даже какая-то такая строка. Ну тогда, если бы я взял вот этот вот суффикс s, он
соответствует какой-то из этих решений, из него должен был быть переход по c, а его не было. Я все
суффиксы перебрал, ни из одного суффикса не было перехода по c, а из такого, я предполагаю, был бы.
Противоречие. Значит, s0 не может иметь длину больше нуля. Значит, s0 это epsilon. Ну и обратно,
если s0 это epsilon, значит, что вообще значит, что s0 это epsilon? Это значит, что ну буквально,
что c не входит в s, потому что я не могу взять даже c в качестве суффикса, встречавшегося ранее.
Значит, c не входит в s. Даже вот такая вот строка из одного символа не является под строкой s.
Хорошо. Ну то есть, я доказал, что из первых следов второе, из второго и третье. Почему,
если c не входит, то происходит такая картинка. Но если c не входит, значит, у нас в старом автомате
нет вообще ни одного ребра по букве c. Ну понятно, если c не было в старой строке, то у нас таких
ребер в принципе не было. Мы не могли дописывать букву c. Значит, в частности из всех этих вершин не
проходит ребро по букве c. Значит, из третьего следует первое. Вот. Получается, такой простой
случай достигается ровно в ситуации, когда мы встретили новый символ, которого раньше в нашей
строке не было. Вот там были a, b, a, b, a. Потом пришел новый c. Тогда я просто прыгаю по вот этим
сусылкам и перепровожу все эти ребра. Да? Вот. Ну, а это значит, что больше лонгестов не появляется.
Вот эта вот строка, она и так изначально была лонгестом. Эпсилон – это лонгест класса,
который отвечает корню нашего автомата. Ну, потому что, что такое, что такое эпсилон? Ну,
это как можно попасть в корень нашего дерева, начав из корня. Ну, не дерево, точнее автомата. Мы
можем только посчитать пустую строчку. Никак по-другому в корень попасть нельзя. Или иными словами,
что такое класс строк, для которых правый контекст состоит только… Нет, наоборот, извините. Давайте
просто посчитаем, что такое рот эпсилон. Вот. Да, все суффиксы. Верно, верно, верно. Все суффиксы.
Если я возьму здесь не эпсилон, то, понятное дело, все суффиксы я получить не могу. Ну, то есть,
в частности, потому что здесь лежит вся строка. А если я возьму строчку, не равную эпсилон, то всю
строку я к ней приписать точно не смогу. Значит, кроме как эпсилон, никто в его классе лежать не
может. Значит, эпсилон всегда… эпсилон всегда отдельное состояние, с которым больше никого нет. Ну,
значит, ну и так всегда было лонгестом. Значит, это лонгестом не становится. Значит, давайте запишем
это. Эпсилон всегда составляет отдельный класс эквивалентности. С0 равно эпсилон было
лонгестом ранее. Значит, новых лонгестов не появилось, значит, автомат уже построен.
Автомат, ну напишу, перестроен. Потому что мы знаем, что у нас может всего два состояния возникнуть.
С одним мы уже полностью разобрались, вот это СС. Да, мы, ну как бы, мы провели все рёбра,
которые в него должны были вести. А больше состояния не появляется, потому что единственный
кандидат на новое состояние уже и так раньше был отдельным состоянием. Соответственно,
новых лонгестов не появляется, новых состояний не появляется. Да? Ну все, значит, первый случай
разобран. Если мы вот так вот утерировались по су-всылкам и ни разу не нашли перехода по С,
то мы автомат полностью правильно перестроили и победили. Так, ну случай, соответственно, второй.
Пусть мы утерировались по су-всылкам и в какой-то момент уперлись в вершину,
из которой был переход по С. Вот я дохожу до некоторой вершины П, из которой в старом автомате
был переход по букве С в некоторое Q. Это П, по букве С есть переход в Q. Тогда я утверждаю
следующее, что С0 обязательно это лонгест от П плюс С. То есть это строка, которая получается
самым, ну точнее является самой длинной строкой из П, к которой справа еще приписан С. Значит,
почему это верно? Ну вспоминаем, что такое С0. Это самый длинный суффикс С, который ранее встречался.
Смотрите, вот эти вот все суффиксы, ну точнее вот эти вот все суффиксы С к ним раньше нельзя было
приписать С. Самый длинный суффикс старой строки, к которой можно было бы приписать С,
лежит вот здесь. Значит, если я возьму самую длинную строчку отсюда и припишу к ней С,
то я как раз получу самый длинный суффикс, который раньше встречался. Просто потому,
что все более длинные суффиксы к ним нельзя было дописать С, а к этому можно. Это самая длинная
строка, которую дописать можно. Так, хорошо, ну и тогда, смотрите, у нас на самом деле
опять раздваивается возможность. Давайте рассмотрим случай, когда s0 это
лонгестат q. Значит, случай 2, это, соответственно, s0 равно лонгестат q. Это
что значит? Значит, нового лонгеста опять не возникло. То есть, вот пусть
внезапно так стало, пусть внезапно так произошло, значит, s0 остается лонгестом.
Он и раньше был лонгестом, и сейчас лонгест. Поэтому опять новых
состояний не возникло. Значит, опять новых состояний не возникает. Хорошо, ну
давайте сразу уточню, как я проверяю вот это вот равенство в коде. Понятно, я не
могу сравнивать строчки, потому что это долго. На самом деле, вот это вот условие
просто эквивалентно тому, что лен от p плюс один равно лен от q. Ну а лены я
договорился, что я храню. Да, лена это у меня как раз длина самой длинной строки в
классе. s0 имеет длину лен p плюс один. Соответственно, они равны ровным в том
случае, если у них одинаковый длин. Ну, потому что в здесь не бывает строк, ну
короче, здесь не бывает одинаковых строк, разные длины, и если у строка равная длина,
то они равны внутри вот этого состояния. Так, хорошо. Давайте поймем, что тогда
происходит.
Так, ну мы поняли, что вот из этих вершин, которые мы прошли вплоть до p,
понятное дело, был переход в s, ну точнее, мы его создаем, нам и обязаны создать
такой переход в состояние c. Теперь, что происходит здесь?
Ну, смотрите, мы живем сейчас ситуации, когда у меня на самом деле, вот если я
рассмотрю мой старый автомат, все кроме вот этого s, у меня этот автомат не
поменялся, потому что в нем не изменился набор лонгестов, значит, набор вершин и
ребер между ними остается такой же, как был. То есть, единственное, что меняется
во втором случае, по сравнению с предыдущим автоматом, это добавляется новая вершина,
и опять в нее проводятся какие-то ребра. Вот я утверждаю, что других ребер в s,
проводить не нужно.
Так, понятно ли почему?
Ну, да, да, потому что, если вспомнить, какие мы проводим стрелки ведущие в s,
это мы проводим такие стрелки, что раньше строка встречалась, но к ней нельзя было
дописать, а теперь стало можно, да, потому что, напоминаю, в s, лежат те строки,
которые только что получили первое вхождение, которые раньше нигде не встречались,
откуда угодно пытаются проводить сюда ребра, то поскольку из них и так c читалось,
да, ну значит оно было вот здесь, а не здесь, потому что ребра ведущие в s, c соответствуют
словам, которые только что получили вхождение, а вот в частности вот это вот слово, да, s0,
оно раньше имело вхождение, то есть дойти до p можно было, и при том прочитать c можно было,
вот, ну соответственно все более короткие суффиксы тоже, к ним справа можно было дописать c,
поэтому они попадали в q или там в какие-то еще более низкие вершины, а сюда мы проводим
только такие слова, которых раньше не было, но таких больше нет. Ну я имею в виду, что если
вдруг есть вот такая картинка, а нет, да, это верно, кстати, да, вы про то, что почему не
появляется других ребер, ну да, да, ну а вдруг, не знаю, вдруг, например, из q внезапно получается,
появляется переход в s, c, ну это бред, ну короче, да, ну в общем, да, действительно других не
появляется, вот эти мы провели, больше ничего появиться не может. Так, ну и тогда все, автомат мы
тоже перестроили, то есть если мы увидели такое p, из которого есть переход по c в q, удовлетворяющий
такому равенству, то в этом случае автомат тоже очень просто перестроился. Так, давайте я еще вот
здесь скажу, я забыл одну вещь добавить, что вот здесь вот линк s, c должно быть равно q, да,
мы же не только стрелки проводим и вершины, мы еще линки подсчитываем, линки и лену везде подсчитываем,
вот, значит, почему линк от s, c это q, ну мы вроде замечали, что линк от s, c это всегда s0,
линк от s, c это всегда s0, потому что здесь лежат слова суффиксы s, c, которые раньше не встречались,
а s0 это самый длинный, который ранее встречался, ну понятно, это как раз самый долинный суффикс вот
этой строки, у которого другой правый контекст, потому что он ранее встречался, а эти не встречались,
поэтому вот это у нас всегда будет верно, ну а мы знаем, что s0 это в точности лонгист вот этого q,
поэтому суффсылка отсюда ведет вот сюда, да, вот, ну и давайте здесь тоже вернемся, в этом случае я
тоже суффсылку забыл назначить, в этом случае по тем же причинам линк от s, c это корень,
потому что s0 это эпсилон, линк от s, c должно вести в s0, значит в корень, потому что корень это
эпсилон, окей, ну вот, все, второй случай разобрали, остался третий, давайте. Нет, смотрите,
нет, нет, нет, нет, нет, мы здесь как раз ничего не делаем, потому что здесь и так были переходы по
c, смотрите, вот в этом случае вот этот автомат, который старый, в нем ничего вообще не меняется,
то есть новые ребра могут меняться только ведущими vsc, вот эти ребра их не было в старом автомате,
но они вот добавляются в новом, а ребра, заключенные между старыми вершинами не меняются, потому что
вот в этом автомате не поменялся набор лонгистов, значит не поменялись ребра, то есть как бы вот этот
набор вершин, он ровно такой же, как был раньше, вершины в нем такие же, ребра такие же, там вообще
ничего не поменялось, только ребра ведущие vsc появляются больше ничего, да, только dp проводим и
и брейкаемся. Да. Так, ну третий случай. Соответственно, когда вот это равенство неверно.
Я как-то допрыгал до P, здесь с помощью буквы C попал в Q. И внезапно S0 наконец-то становится
лонгестом. Раньше не было, теперь становится. То есть это тот случай, когда S0 раньше не был лонгестом,
а теперь стал. Ну, потому что я знаю, что S0 обязательно становится новым лонгестом. Ну,
точнее он точно будет лонгестом, потому что он лежит в другом классе по сравнению с СС.
Но в этом случае он именно что становится. Он раньше не был лонгестом, а теперь становится.
Потому что он был раньше в классе, внутри которого была более длинная строка. Значит,
здесь на самом деле он не лонгест. Был раньше, а теперь становится лонгестом. Так, давайте нарисуем
картинку, что происходит в Q вообще. В Q, как мы знаем, то есть я сейчас хочу нарисовать набор строк,
которые попадают в Q, которые лежат в этом классе эквивалентности. Как мы знаем, здесь будет
несколько строк, которые получаются друг из друга отбрасыванием первого символа.
Вот пусть вот это вот будет все строчки из Q. Значит, где-то здесь будет строка S0. Причем она
будет не самая длинная. Я знаю, что она лежит в Q, потому что получается дописыванием буквы C к
лонгесту от P. Но при этом, по предположению, это не самая длинная строка. Если бы она была
самая длинная, мы были в втором случае. Значит, вот S0 где-то здесь. Теперь смотрите, мы же помним,
что лонгест у нас никогда не пропадает. Если строка однажды лонгест, то у нас всегда лонгест.
Поэтому вот эта строка, которая есть лонгест от Q, она лонгестом остается. Единственное,
что происходит, это S0 становится новым лонгестом. Значит, что происходит? Значит,
этот большой класс расшепляется на два. Вот это вот то, что раньше было в Q, а вот это то,
что раньше было в Q и под линией не больше, чем S0. Ну, потому что оно стало новым лонгестом,
оно расстекло большой класс на два. Значит, класс устроен ровно так.
Что же делать? Ну, хочешь не хочешь, нам придется завести новую вершину, которая будет отвечать вот
этим вот всем словам. S0 и более коротким, которые раньше лежали в Q. Давайте я заведу новую вершину,
обзову ее клон и буду считать, что в ней как раз лежат все вот эти вот слова, которые более
короткие, чем S0 и более и все более короткие. Клон, потому что она будет очень похожа на Q. Ну,
и вообще раньше это была одна вершина. То есть, вот эти вот слова и вот эти, которые теперь остаются
в Q. То есть, это новая Q. Они раньше были в одном множестве. И, скажем, раньше все ребра ведущие в них
и, скажем, исходящие из них были абсолютно одинаковы. То есть, эти все слова были, на самом деле,
склеены в одну вершину. А теперь я их расщепляю. То есть, представьте, картинка была такая. Вот было
одно большое Q, в него там какие-то ребра входили, какие-то выходили и вот здесь вот лежали все вот
эти вот слова. Теперь я делаю следующее. Я часть этих слов оставляю в Q, а часть отщепляю в другой
класс. Ну, тогда картинка просто будет такой. У меня там Q чуть-чуть уменьшится, будет вот такой.
Появится клон, где все остальные слова лежат. Ну и, соответственно, какие-то стрелки вот здесь
перенаправятся будут вот такими. И какие-то надо понять, что со стрелками исходящими будет.
То есть, по факту, я просто под расщепляю один большой класс на два поменьше. Так, давайте
начнем с, например, исходящих ребер. Я утверждаю, что множество ребер, исходящих из клона, будет
такое же, как множество ребер, исходящих ранее из Q. То есть, вот эти вот стрелки, которые исходили из Q,
они наследуются и сюда, и сюда. Ну, это вроде очевидно, что значит, что у меня была стрелка отсюда по
букве А. Значит, я мог взять какое-то слово из этих, дописать А и попасть в другую вершину. Более того,
я мог взять любое слово из этих, дописать А и попасть в одну и ту же вершину. Мы говорили, что наличие
ребра значит, что какое бы слово я отсюда не взял, после дописывания буквы я попадаю в другую вершину.
Ну, значит, и здесь все вот эти вот переходы по А, ну, точнее, один переход по А в какую-то вершину,
скажем, Х, они остаются из Q, из клона. Ну, то есть, на самом деле, картинка будет вот такой. Потому что,
если раньше ко всем этим словам можно было дописать А и попасть в Х, то, значит, и отсюда, и отсюда
должен быть переход по А в Х. Поэтому, как минимум, все очень просто. Ну, там, как минимум, поэтому это
что-то называется клон, потому что у нее, по крайней мере, множество исходящих ребер будет такой же,
как у Q. Давайте зафиксируем, что множество ребер, исходящих из клон,
такое же, как у Q. Ну, значит, исходящими мы разобрались. Теперь давайте с входящими разберемся.
Но здесь все тоже не очень сложно. Давайте вспомним, как устроены входящие ребра вообще в вершину,
чему они соответствуют. Что такое входящие ребра? В Q есть какие-то входящие ребра. Что это значит?
Значит, можно было начать в корне, дойти до какой-то из этих шин, потом по букве С попасть в Q.
И получить все вот это вот возможное множество слов.
Так, но здесь, видимо, тогда важно будет сказать следующее замечание. Давайте утверждение это скажем.
Множество ребер, ведущих в Q, устроено так, что мне проще картинкой показать, чем словесно это формулировать.
Значит, смотрите, вот я знаю какой-то Q. Рассмотрим все ребра, которые в него вели.
Значит, я утверждаю, что, во-первых, на них на всех написана одна и та же буква. Ну, в нашем случае С.
Во-вторых, вот эти вот вершины являются сувсылками друг друга, ну, если их расположить в правильном
порядке. То есть, если рассматривать самую большую из них, то она будет ссылаться по сувсылке на вторую.
Вторая будет ссылаться на третью. Третья будет ссылаться на четвертую. Ну, почему это так?
Потому что давайте опять я нарисую картинку, какие слова лежат в Q. Во-первых, они все заканчиваются на
одну и ту же букву С. Потому что здесь не может быть пустой строки. Пустая строка у меня только в корне
лежит. Здесь пустой строки нет, поэтому, поскольку они все являются суффиксами одной и той же строки,
они все заканчиваются на С. Значит, на всех этих ребрах может быть только одна и та же буква С.
Во-вторых, ну, вообще, что такое ребра ведущая откуда-то сюда? Значит, я могу, там, возможно,
несколькими способами от корни добраться до сюда, к каждому из этих слов дописать С и попасть в Q.
Ну, если я рассмотрю в качестве этой вершины самую длинную, то есть ту, у которой лен максимально,
то это будут несколько самых длинных слов вот в этом вот наборе для Q. Потому что, ну,
какой самый длинный путь ведет в Q? Мне нужно из них выбрать самую длинную вершину с максимальным
лен, взять в ней лонгест и приписать С. И несколько его самых длинных суффиксов будут, соответственно,
появляться из вот этой вершины. То есть, скажем, вот это вот приходит из какой-то вершины В1. Затем
следующие слова появляются опять-таки из какой-то из этих вершин. Если я смотрю самое длинное из них,
то как оно появилось? Ну, там из какой-то другой вершины В2. Причем понятное дело, что тогда обязательно
В1 ссылается на В2, ну, потому что просто В2 это вот как раз вот следующее слово, являющееся суффиксом
все той же самой длинной строки, которая лежит внезапно в другом классе. Значит, друг на друга
ссылаются. Потом несколько строк будут из В2, несколько из В3, ну и так далее. И поскольку все вот эти
строчки являются суффиксами друг друга и при этом лежат в разных классах вот этих вершин, значит,
они все друг на друга ссылаются по суффиксам. Хорошо.
Ну, что мы тогда можем сказать? Тогда мы знаем, как устроено все множество вершин, в виды из которых есть
переход в Q. Давайте его нарисуем. Вот есть Q, вот где-то было P, но мы точно можем сказать, что P это
не самая высокая вершина, из которой есть переход в Q, потому что самая высокая, она соответствует
вот этой вот строке, а P наоборот соответствует вот этой строке, не являющейся лонгестом. Поэтому
где-то там еще выше точно есть другие вот такие вот вершины, ну по крайней мере одна такая вершина,
которая тоже ведет в Q по переходу. Вот, значит, какие-то там такие есть, да, P точно не самая
длинная, но еще возможно несколько вершин, которые получаются из P взятием суффсылки, вот из них
тоже были переходы по C в Q. Тогда что я должен сделать? Вот эти вершины, из которых раньше
вел переход в Q, они соответствовали вот этим вот более длинным, чем S0 слова. Давайте тоже нарисую.
У меня было S0 и какие-то более короткие. Соответственно, все, что выше, это вот эти вот
вершины, потому что P соответствует с точностью S0. Все, что выше, вот эти вот другие вершины,
более длинные, с большим леном, с большим лонгестом, они отвечают вот этим словам. Значит,
после расщепления класса Q на Q и клон у меня эти ребра сохраняются, потому что они вели в более
длинные слова, чем S0, они остаются в классе Q, поэтому эти ребра сохраняются. А вот эти вот серебра,
поскольку они соответствовали каким-то вот таким вот словам, более коротким, чем S0, они
перенаправляются в клона. То есть картинка будет такой. После расщепления Q на две вот эти вот
ростные вершинки Q и клон верхние стрелки мне остаются в Q, а все, начиная с P, перенаправляются в клона.
Ну, потому что все вот, все, которые, начиная с P, получают по сувсылкам, шли с помощью перехода
по C в Q, это вот эти вот все слова, ну там, без последнего символа. Все они теперь попадают в
клон. То есть я расщепляю Q на Q и клон. Значит, если раньше вот эти вот стрелки соответствовали
вот этим словам, то я их, ну, собственно, просто провожу теперь ребра в клона, а не в Q, потому что
теперь это разные состояния. То есть раньше они были все склеены, вели сюда. Теперь я Q расщепил
на длинные слова и короткие. Все короткие слова теперь лежат в клоне. Да? Вот. Все, автомат перестроен.
Да, да, да, да. Ну, я про ребра пока говорил, про автомат, про линк, сейчас тоже все выставим. Вот,
значит, смотрите. Мы разобрались со всеми ребрами ведущими из клона. Мы這樣子, почему мы разобрались
со всеми вершины ведущими в Q и в клон? Ну, потому что мы расщепили вот это вот множество слов.
Соответственно, мне нужно разобрать только те стрелки, которые раньше вели в Q. Ну
и, соответственно, перенаправить их часть. Останется ввести в Q, часть останется ввести в
клон. Новых ребер, понятно дело, не возникнет. Потому что только вот эти вот ребра, которые раньше были
были в автомате, которые раньше соответствовали одну из этих строк,
они остаются вот в этом новом автомате, то есть здесь только
просто расщепилось Q на два состояния, Q и клон. Все, больше ребер не появляется.
В частности, смотрите, возможно, такая картина, что несколько сувсылок P мы
перенаправляем в клона, то есть создаем ребро по букве C в клон, а из какой-то еще
вершины, возможно, был другой уже переход по букве C в какую-то еще другую вершину.
И вот тогда такой переход я не исправляю, ну, потому что он вел куда-то в другое место,
этого уже не связано никак с Q. Здесь в этой части автомата никакие ломгисты не поменялись,
поэтому все ребра корректны. Так, давайте продолжать. Мне осталась здесь косметика какая-то,
значит, я провел все вершины, создал новые вершины, новые ребра, все провел, остались
линки и лены. Ну, давайте разберемся со всем вот этим вот. Значит, во-первых,
наше любимое утверждение, скажите, пожалуйста, чему равно линк это с C? С0, а в терминах вершин?
Клон. Да, потому что клон, это как раз вот с С0 начинается и все более короткие. Дальше,
что такое линк от Q? Тоже скажите, пожалуйста, мне. Клон. Потому что, ну, что такое линк от Q,
вспоминаем, это если я беру самую длинную строчку в этом классе, отбрасываю по одному символу и
дожидаюсь, когда я перехожу в новое состояние. Ну, как мы знаем, несколько самых длинных строчек
лежат в Q, а следующий уже лежит в склоне, поэтому линк от Q это клон. Ну, и наконец,
надо написать, чему равно линк от клон. Это я, давайте так, как быдло напишу, old link от Q. Ну,
в том смысле, что новая ссылка из клона такая же, как раньше была из Q. Это тоже вроде очевидно,
вот опять же по этой картинке. Раньше в Q лежали все вот эти вот строчки, а link это вот эта вот
строка следующая, да, вот следующая ниже, чем самая короткая в Q. Ну, значит, это будет новая линка
для клона. Потому что опять отбрасываю, отбрасываю по одной букве, пока не попаду вот сюда, что ранее
было линкой от всего этого класса, то есть old link от Q. Вот, значит, с линками разобрались,
давайте с длиной еще все напишем, линк от клона, это линк от P плюс 1, потому что самая длинная
строка в клоне это S0, а мы знаем, что у S0 такая длина. Линк от Q не меняется, да, потому что в Q
остается вот эта самая длинная строка, линк от Q не меняется, ну и там линк от SC, тоже на самом
деле везде это надо было писать, что линк от SC это линк от S плюс 1. То есть в момент, когда мы начинаем
проводить ребра из S в SC, я сразу могу сказать, что линк от SC это линк от S плюс 1, ну потому что
получается дописывание одного символа. Все, алгоритм закончился. Вопросы есть? Хорошо, тогда давайте
анализировать асимптотику. Значит, здесь на самом деле два вопроса. Многое понятно, что работает за
линейное время. Например, мы знаем, что поскольку на каждом шаге вершин добавляется максимум 2,
то вершин точно всегда линейное количество, максимум 2n. Что еще можно сказать? Ну, на самом
деле здесь есть два тонких места, которые надо проанализировать. Во-первых, это вот эти вот вайлы,
пока я спускаюсь от S, многократно беря су-всылку и проводя ребра ведущие в SC. То есть я вот отсюда,
там как в первом случае, у меня есть S, я провожу ребро, беру су-всылку, провожу ребро, беру су-всылку
пока не найду либо вот такого ребра, либо пока не дадут до корня. То есть у меня есть, по крайней мере,
один вайл, который вот проводит ребра в SC. Дальше аналогично, вот здесь вот происходит какой-то вайл.
Пока, то есть я не дойду до вершины, из которой переход по C ведет в другую вершину, вот на этой
картинке, я прыгаю по су-всылкам и перенаправляю все ребра, которые раньше ввели в Q, теперь они
будут вести в клон. То есть это второй вайл. Вот вайл, вот здесь вайл, пока мы находим это
самое P. Ну и третий, на самом деле, тонкий момент, это перекопирование ребер ведущих из Q в клон.
Вот здесь у меня была картинка, что все эти ребра, которые раньше вели из Q, они остаются в Q,
а также теперь ведут из клона. Ну и вообще говоря, непонятно, сколько там ребер. Хорошо,
если их мало, но их может быть много. Так, давайте начнем вот с этого последнего момента. Докажем
следующее. Так, сейчас один момент. Там сойдется. Да, должно сойтись. Значит, вершин в суффиксном
автомате строки S, где длина S равна m, не больше, чем 2n, а ребер не больше, чем 3n.
Поэтому, в частности, давайте проверюемся. Если я это докажу, то вот тот мой третий тонкий момент,
когда я перекопирую ребра из Q так, чтобы они вели из клона, суммарно работает за линию, потому что
когда я провожу ребра из клона, я увеличиваю число ребер в графе, а суммарно их максимум 3n. То есть у
меня были ребра только из Q, я продублировал Q, сделал Q и клон, и все эти ребра перекопировал
в клона. Каждое перекопирование увеличивает число ребер на 1, поэтому суммарно таких перекопирований
максимум линейное время. Если мы это докажем, то мы поймем, что вот это перекопирование ребер из
Q в клона работает суммарно за линию. Доказательства первые мы уже знаем, потому что на каждом шаге
добавляется максимум две вершины. Второе. Так, ну сейчас попробую. Тут у меня обычно проблемы с этим.
Хорошо, давайте сделаем следующее. У нас есть автомат, в котором из корня, то есть из старта вершины,
достижимы все остальные. Ну понятно, у нас вершины только такие, что они достижимы из старта, они соответствуют
подсрочку. Так вот, давайте в этом вот ориентированном графе, в котором из корня все
достижимы. Давайте фиксируем какое-то ориентированное основное дерево.
То есть, у нас есть где-то корень, старт наш. Давайте выберем такой набор ребер, чтобы по нему
можно было из старта добраться до куда угодно. Ну и так далее. Понятно, что поскольку из старта можно
с помощью ребер до куда угодно добраться, то я могу выбрать какое-то дерево. На самом деле это надо
еще доказать, но давайте, давайте считать, что мы это знаем. Вроде естественно, кажется, раз можно
добраться, то вот, ну, можно добраться с помощью ДФС, да, дерево ДФС, действительно. Вот, ну возьмем
дерево ДФС. Сколько в нем ребер? Значит, ребер в этом дереве точно не больше, чем 2n-1, потому что
вершин максимум столько, а ребер в дереве на 1 меньше. Значит, мне теперь хочется доказать,
что ребер вне остого мало, не больше, чем n.
Сейчас докажем, что ребер вне остого мало, не больше, чем n.
Ну окей, давайте рассмотрим какое-то ребро вне остого.
Давайте с этим ребром ассоциируем следующий путь. Во-первых, мы из корня по остовным
ребрам дойдем до начала этого ребра. Ну, поскольку такой путь, как бы, поскольку он недостижимый,
значит, есть путь по остовному. Потом используем это ребро и потом отсюда, как угодно, каким угодно
образом дойдем до произвольной терминальной вершины. Причем, возможно, используя не остовные
ребра. Возможно, остовные, возможно, не остовные. Что хотим, то и используем. Значит, здесь произвольные
ребра. Почему так можно сделать? Ну, потому что эта вершина соответствует некоторой подстроке нашей
строки. Понятно, что из любой подстроки можно дойти до терминала, потому что терминал это суффикс.
Из подстроки можно дойти до суффикса всегда. Поэтому такой путь всегда есть. Итак, я каждое не остовное
ребро ассоциировал с некоторым путем, который, в свою очередь, соответствует суффиксу. Ну, понятно,
если прочитать вот эти вот все буквы, то я получу суффикс, потому что я от корня дошел до терминала.
Значит, этот путь соответствует суффиксу. Причем, что несложно заметить, разные пути будут
соответствовать разным суффиксам. Потому что, как минимум, у них будет отличаться вот это вот первое
не остовное ребро.
Понятно? Ну, это разные пути, потому что, если я на каждом пути посмотрю первое не остовное, то,
поскольку я для всех разных не остовных ребер строю такие пути, то все пути различны. Ну,
и, соответственно, строки, которые у них написаны, тоже различны. Вот. Значит, их не более
n, потому что они все суффиксы, и это все различные суффиксы. Победа. Давайте. Значит, еще раз
овервью количество ребер. Я делаю следующее. Сначала я фиксирую некое остовное дерево,
например, дерево обхода ДФС, которое посещает все из старта. То есть, он начинается в старте,
и с помощью его ребер можно дойти до всех решений автомата. Таких ребер вот столько максимум.
Дальше. Давайте рассмотрим все остальные неостовные ребра. Я утверждаю, что вот таких вот ребер,
которые не в остове лежат, их не больше, чем n. Почему? Давайте с каждым таким неостовным ребром
ассоциируем путь, который ведет из корня до начала этого ребра по остовным ребрам. Такое есть,
потому что из корня все достижено по остову. А из конца ребра я пойду до произвольной терминальной
вершины и использую какие угодно ребра. Не обязательно остовные. Какие угодно ребра. Такое опять-таки
есть, потому что это подстрока, и из подстроки можно всегда дойти до суффиксов. Вот. Получается,
что каждому неостовному ребру я поставил соответственно некоторый суффикс. Потому что
вот это вот все идет из корня в терминал, значит это суффикс. Да, конечно. Суффикс на автомате
терминированный. Вот. Тогда соответственно разные пути отвечают разным суффиксам, потому что они
отличаются как минимум вот в этом первом ребре неостовном. Ну и соответственно как бы равны они
могли бы быть только если бы они шли вот ровно по одинаковому пути. Ну то есть вот эти вот суффиксы,
с케ильницы, да. Суффиксы, отвечающие разным путям, могут быть равны. Что значит, что там два пути
дают одинаковые суффиксы? Этоuras эти пути и сами одинаковые, потому что у них совпадает
первый рябро, то есть первый символ, то есть первое рябро. Второй символ, то есть
второй рябро. Третий символ, то есть третий рябро. Четвертый символ, то есть четвертый spare
rebro. Да, потому что как раз tatsächlichiten, потому что как раз детерминированность.
west да, потому что как раз д disse Мар Mia ну все. Значит мы получили, что каждое такое
ребро отвечает какому-то софиксу, такие ребра отвечают
разным софиксам, значит их всего максимально.
Ну там n плюс один, окей, для формальности n плюс один,
потому что есть пустой сфикс еще у строки, да, профит.
Да, все, значит, как я сказал, момент перекопирования
ребер из Q в клон работает суммарно за линейное время,
потому что на ребер у нас линия.
Вот, сейчас осталось только этой доказать.
Значит, осталось доказать, что, ну, как вы говорите,
спуск по линкам суммарно работает за вот n.
На самом деле очень просто, потому что верно следующее.
Смотрите, вот, не совсем, потому что когда мы из paper
направляем ребра, которые раньше выливку, мы на самом
деле меняем ребра, мы их не проводим.
Поэтому тут лучше другой аргумент использовать.
Значит, смотрите, что мы делали.
Вот мы спускались по су-всылкам, и с первого блока мы провели
ребро в СС, потом из второго блока мы перенаправляли
ребра ведущие в Q, так что мы теперь ввели в клона.
Больше ничего не делаем.
Смотрите тогда, в этом случае у меня очень сильно,
если я провожу много таких ребер, то у меня очень сильно
убывает длина пути по су-всылкам, ну, количество
путей в этом многократном применении су-всылки, потому
что раньше был вот такой длинный путь.
Теперь, при переходе к новому автомату, у меня будет
СС, который ссылается на клона, мы знаем, что клон
Следующая, ну, точнее, клон является у ссылка СС.
Так, а, тут надо аккуратнее сказать.
Сейчас, момент, картинка надо побольше просто.
Вот эти вот все ведут в СС, потом была та самая, давайте
самый стрёмный случай, третий рассматриваю.
Значит, раньше она веловку, теперь перенаправляется
в клона вместе с несколькими вот этими вершинами, и дальше
остаются какие-то вершины, которые я не трогаю, и ребра
из них не меняются.
Давайте вообще посмотрим, давайте точно также разобьём
все вот эти вот вершины, более низкие, как из них
устроено ребро по букве С, ну, понятно опять, да, вот
они разбиваются на некоторые группы, так что внутри группы
у меня ребро по букве С ведёт в одну и ту же вершину.
То есть, по факту, у меня вот этот вот старый путь по
ссылкам разбивается на несколько блоков, первый,
второй, третий, четвёртый, так что внутри блока все
переходы по С либо одновременно отсутствовали, либо одновременно
вели в одну и ту же вершину.
Вот, тогда давайте проследим, как этот путь трансформируется
в новом автомате.
Последней вершиной будет СС, она будет ссылаться
на клон, клон будет ссылаться вот сюда, ну, потому что
что это такое?
Это вот мы отбрасываем самую левую букву, попали сюда,
до писалицы попали сюда, но это вот как раз получается
они отличаются отбрасыванием самой левой буквы.
Это будет ссылаться сюда, ну, и там они, вот это потом
идёт в корень.
Тем самым, смотрите, чем больше я здесь вершин обработал,
тем меньше у меня будет вершин вот на этом пути.
Пока не дошло, давайте какие-нибудь буквы напишем.
Ну, что-то пусть на старом пути по су-всылкам,
было х вершин.
Пусть мы создали или перенаправили
к ребер, то есть суммарно вот этих вот ребер плюс
вот этих вот, которые я либо направил в СС, либо в клона,
пусть их суммарно к.
Вот здесь вот суммарно к ребер.
Тогда в новом пути по су-всылкам, ну, который начинается
из СС, то есть из вот этого вот, не больше, чем х-к
плюс одна вершина.
Какое?
Потому что вот здесь мы ребра не проводим, а перенаправляем.
Не появляется.
Оно было, мы его просто перенаправили.
Оно раньше веловку, я просто поменял, что оно теперь показывает
в клоны.
Ну, тут по-другому, по-другому не получается, да.
Потому что именно, что эти ребра не появляются, они
просто перенаправляются.
Вот.
Ну, верно, вот это вот утверждение, потому что, смотрите, вот
пусть вот здесь вот суммарно х-вершин, тогда это же, что,
ну, во-первых, на этом пути вершин не больше, чем х,
потому что как получается вот этот вот путь?
Он получается группировкой вот этих х-вершин некоторыми
блоками, что внутри блока они все по буквеце указывают
в одну из вершин вот этого второго пути.
Ну, картинка, да, просто мы показали.
Более того, вот эти вот суммарно ребра и вот эти вот ребра,
они не просто переходят в столько же вершин, сколько
было здесь, они сильно уменьшают количество вершин, потому
что вот если здесь там было, скажем, к1 ребер, то вот
эти вот к1 вершины перешли в одну вершину, эти к2 вершины
перешли в одну вершину, получается, суммарно у меня
число этих вершин уменьшилось не просто на, ну, точнее,
оно не просто осталось таким, как было, оно уменьшилось
по крайней мере на к1 плюс к2, потому что вот эти вершины
склеились в одну и вот эти склеились в одну.
Вот здесь х, вот здесь суммарно к ребер направлено из этого
блока сюда, плюс отсюда сюда, да, это, ну, смотрите,
вот это вот, это с и все суфссылки, которые я брал
от него, из них проводил ребро в СС, потом взял очередную
суфссылку и перешел в П, несколько опять суфссылок
перенаправил в клона, ну а дальше опять продолжение
пути по суфссылкам, но он устроен так же, там некоторыми
блоками они объединяются и ведут в одну новую вершину
по вот этому уже новому пути по суфссылкам, то есть
вот это старый путь по суфс ссылкам, с и все его суфиксы.
Это новый, СС и все его суфиксы.
Вот.
Ну и, соответственно, чем больше я здесь вершины
объединяю в один класс, чем больше вершин имеют ребро
в СС, и чем больше вершин имеют ребро в клона, темane
вершину этом пути, да, то есть, каждое такое ребро
уменьшает здесь количество вершин на один.
Ну вот.
Ну как, ну потому что можно сказать, что x это потенциал.
Ну типа интуиция такая, смотрите, вот пусть и давайте
следить за значением перемены x.
Вот раньше у меня было здесь x-вершин.
Если я суммарно сделал, суммарно вайлы мои проработали
к действии, то есть я k-рёбер создал, да, вот здесь вот
и здесь вот, то у меня x уменьшилось на k.
Ну и при этом потом выросло максимум на 1.
Может на 2 из-за того, что вот еще s, c добавилось.
Ну короче вот там 1 или 2 здесь констант.
Вот, значит суммарно уменьшений не больше, чем суммарно увеличений,
а их n.
Значит и уменьшение максимум n.
А уменьшение это ровно столько, сколько вайлы суммарно
работали.
Так, все умерли, да?
Ну подумайте, здесь на самом деле правда несложное
рассуждение, то есть просто сравните вот эти вот два
пути по сувсылкам.
Первый, который s и все его сувсылки, да, многократное
применение.
И s и все его многократное применение.
Я утверждаю, что они разбиваются ровно так.
Старый путь разбивается на блоке вершин, так что
внутри блока они все ведут по букве c в одну из вершин
второго пути, а вот так вот они все разбиваются.
Тогда чем больше ребер здесь проведено, тем меньше
вершин на этом пути.
Х, можно просто сказать, что х это потенциал, да.
Ну от текущего, да, скорее, да, от текущего самого
длинного сувфикса количество ребер, количество вершин
на пути по сувсылкам.
Наверное.
Так.
Может какой-то вопрос конкретный есть, я на него тогда отвечу,
если нет, то будем дальше.
Ладно.
Ладно.
Ну как?
Потому что вот, типа мы знаем, вот тут написано,
сколько вершин вот на этом пути.
Максимум там на плюс один.
Потому что, опять, потому что, еще раз, потому что
вот этот путь по сравнению с этим путем разбивается
на блоке.
Блок вершин ведет в одну.
То есть как бы к1 вершин соответствует одной вершине
здесь, к2 вершин соответствует одной вершине здесь, к3 здесь
и так далее.
Поэтому суммарно здесь вершин мы не больше, чем здесь.
Ну тут, подожди, тут с корнем надо.
Тут, сейчас, сейчас, сейчас.
Давайте, окей, давайте какую-то картинку нарисую.
Корень, который ведет куда-то еще.
Вот, смотрите.
Значит, как, как, вот пусть картинка такая.
Причем это корень.
То есть я, вот, вот этот левый, левый путь у меня,
это путь по суфссылкам, начиная от s.
Да, вот это все суфссылки.
Он заканчивается в корне.
Картинка такая.
Тогда второй путь, это вот, это вот.
И вот это последний суфсыслок как раз плюс один.
То есть, смотрите, вот это вот разбивается на блоке.
Первый блок, второй блок, третий блок.
Соответственно, первый блок соответствует одной вершине.
Второй блок, второй вершине, третий блок, третьей вершине.
И плюс еще корень куда никого не ведет,
куда никого не ведет, но который, тем не менее, на этом пути по ссылкам есть.
Поэтому плюс один.
Жесть, всех убил.
Ну давайте дальше тогда.
Что тут из сети?
Поймете.
Все, получается, что за линию работает.
А это на экзаменах?
Да, ну вот что тут изи же все.
Вот.
Значит давайте последнее.
Это суффиксная массив за линией на время.
По суффитомату.
Значит смотрите.
Мы умеем строить за Н.Лугенцев масс.
И умеем за линию строить суффитомат.
Давайте мы сначала построим суффитомат.
Потом за линией на время построим по нему суффиксный массив.
Ну чтобы было быстрее, чем то, что мы уже умеем.
Чтобы проверить по строке на равенство, например.
По индексам.
Не, суффмасс что-то умеет.
Я не знаю.
Должно.
Так.
Значит смотрите.
Что я сделаю?
Первое, что я сделаю, это я сожму так называемые проходные вершины.
Сожмем.
Проходные вершины.
Это вершины, у которых всего одно исходящее ребро.
И которые при этом не являются терминальными.
Проходные.
Давайте напишу не терминальные вершины.
То есть если была какая-то вершина,
не являющаяся терминальной,
из которой всего одно ребро исходит,
то на самом деле картинка имеет какой-то такой вид.
Ну там, возможно, несколько ребер в нее ведут.
Потом по букве С есть из нее один всего переход.
Тогда я эту картинку могу сжать следующим образом.
То есть вот из этого я строю такую картинку.
Ну понятно.
Если здесь было А и Б,
то здесь будет написано А и Б.
Ну понятно.
Если здесь было А и Б,
то здесь будет написано АС, а здесь БС.
Сжатие этой вершинки.
То есть я вижу, что из нее
продолжение единственным образом определено.
Поэтому давайте я не буду...
Я просто ее удалю, скажу, что нет такой сущности.
У меня просто вот отсюда я могу сразу прыгнуть
сюда за АС,
отсюда сюда за БС.
Еще раз?
Правильное замечание.
Не может. Ну окей, да.
Действительно.
Да.
Это верно, но здесь
не важно.
Так.
Ну вот представьте, что мы это сделали.
Это делается очень просто.
По автомату.
Просто если снизу вверх пройти,
давайте для каждой вершины указывать,
где, грубо говоря,
сожмем длинный путь по
таким проходным вершинам.
Это будет ссылаться вот сюда,
это будет ссылаться вот сюда,
это будет ссылаться вот сюда.
Ну то есть как я сказал,
это будет ссылаться вот сюда,
мы просто для каждой вершины
снизу вверх подсчитываем,
где мы окажемся,
если мы сразу пройдем вот этот длинный путь
по сжатым вершинам.
Вот.
А дальше сделаем следующее.
Мы получили опять
некоторый граф
на ребрах которого уже написаны
строчки,
не буквы как раньше, а строчки.
И давайте сделаем следующее.
Давайте просто запустим
ДФС
без пометок юст.
ДФС без запоминания.
То есть вот мы встали в корень,
у нас есть несколько
стрелок из нее.
Стрелки в этом плане, что они уже сжаты.
Я выбираю из них
ту, которая начинает
на самую маленькую букву,
ну на А скажем,
и иду сюда.
Дальше здесь опять я стою здесь,
иду в самую маленькую букву и так далее.
В момент, когда я дошел до
некоторой терминальной вершины,
я знаю суммарную длину этого пути,
то есть я знаю сколько суммарно букв
было написано на этих ребрах,
значит я знаю, что это был за суффикс.
В момент
посещения
терминальной вершины
выводим ее
как очередной суффикс.
Ну не ее, да, но как бы
соответствующую длину
как очередной суффикс.
И мы при этом
не запоминаем юзды,
то есть мы позволяем себе многократно посещать
одну и ту же вершину.
Вот если, например, у меня как-то вот так вот автомат выглядит,
то я сначала вот так вот пройду,
я сначала пройду вот так вот,
потом вот так вот.
То есть я разрешаю себе вершину заходить
несколько раз, ребра походить несколько раз.
Я просто забываю про юзды,
вообще их не обновляю.
Хочу пройти вершину по ребру, прохожу.
Давай сначала поймем, что это корректно.
Потому что мы
как бы по бору действуем жадно на самом деле.
У нас есть автомат, я хочу найти самый маленький
суффикс, для этого мне нужно взять
самую маленькую букву, идти пока не встречу терминальную вершину.
Это будет лекс-суффикс.
Второй
суффикс, который я выведу,
это второй по лексографической минимальности.
Потому что я всегда действую жадно,
соответственно суффикс выведу в правильном порядке.
То есть, по крайней мере, корректность
тривиальна.
Что со временем работы вопрос?
Потому что к Азазовому делан
какой-то кринж.
Мы многократно посещаем вершины,
мы даже не знаем,
ДФС работает за сколько.
В худшем случае он может работать за экспоненту.
Если граф специального вида,
то ДФС без юздов может работать за экспоненту.
А если каждую вершину многократно можно посещать,
то он может весь граф экспоненциально долго обходить.
Но на этом графе он работает
за линию.
Почему?
Что?
Я скажу следующее.
Время работы очевидно
пропорционально количеству
посещенных вершин.
Количество посещенных вершин
с учетом кратности.
Если я вершину два раза наступил, то я их считаю дважды.
Количество посещенных
вершин
с учетом количества посещений.
Не буду писать, да.
С учетом кратности.
Понятно.
Просто каждое действие – это попасть в вершину.
Давайте тогда поймем вообще,
сколько раз я могу попасть
в какую-то вершину.
Ну, не будем торопиться.
Во-первых, если вершина терминальная,
то попасть я могу в нее ровно столько раз,
каков ее размер класса эквивалентности.
Потому что я терминальные вершины не сжимаю.
И попасть я в нее могу всеми возможными способами,
как я могу прошедшить этот суффикс.
А если я попасть в вершину,
то я могу попасть в вершину,
как я могу попасть в вершину,
всеми возможными способами,
как я могу прошедшить этот суффикс.
Поэтому число раз, что я попаду в терминальную вершину,
в точности равно, сколько в ней суффиксов.
Ну, как бы, сколько суффиксов ей соответствует.
Сколько ей соответствует суффиксов.
Потому что любой путь в нашем автомате
до этой вершины соответствует суффиксу.
Ну, хочешь и не хочешь,
по-другому, как вот
стольким количеством способов сюда я не попаду.
Теперь давайте рассмотрим остальные
не терминальные, но при этом
не сжатые вершины.
Не терминальная,
не сжатая вершина.
Что значит, что они сжатые?
Значит, из них, по крайней мере,
два разных ребра исходят.
Потому что если было бы одно, я бы ее сжал.
Значит, отсюда есть, по крайней мере,
два разных ребра А и Б.
Теперь давайте рассмотрим
все возможные способы попасть сюда
в нашем сжатом суффиксном автомате.
Что такое способ сюда попасть?
Ну, по факту, это просто способ расширить какую-то строчку сюда ведущую.
Давайте оценим число таких строк.
Что мы точно знаем?
Мы знаем, что а и б
это подстроки С.
Не наталкивает ли это вас
на какие-то мысли?
Альфа это
где?
Да.
Смотрите, у нас был критерий
longest, что строка является longest, если она
префикс, или у нее два продолжения влево
разных, а здесь вправо.
Ну, чинится очень просто. Давайте
реверсим строчку и получим продолжение влево.
Значит, это значит,
что а-реверснутая
это longest
для СР.
Ну, критерий longest просто.
Если я разворачиваю строчку,
продолжение вправо, это, наоборот,
предварение слева. Согласны?
Все. Значит, количество
посещений этой вершины
ограничено числом таких альф,
что я сюда попадаю, а таких альф
суммарно столько
longest для СР, а их линия,
потому что вершин в автомате линия.
Все.
Давайте запишем.
Значит, число посещений
В
ограничено
количеством
строк альфа,
по которым можно
из корня попасть в В.
Ну, наверное, в точности равно,
но...
Наверное, в точности равно, да.
Ну, я не хочу задумываться, потому что я, возможно,
я какие-то вершины сжал, я, возможно,
какие-то... Нет, я ничего не потерял.
Ну, равно. Окей, равно.
Ну, не больше, да, потому что каждая строка альфа
соответствует какому-то пути до В.
И попасть в В можно было только прочитав
некий путь из корня до В, то есть какую-то альфу.
Значит...
Но такая альфа,
значит, такие альфы
обязательно
удовлетворяют этому свойству,
что если их развернуть и прощать справа-налево,
то мы получим longest для реверсной строки.
Значит, суммарно,
всех таких альф, по всем В,
у от n, потому что longest для СР
у от n. Мы доказывали
только что, что вершин в суавтомате
не больше чем 2n.
Чего?
А почему
не может быть
одинаковый СР для ратора?
Ой, одинаковый альфа для ратора.
Да пусть даже есть.
Когда цинклон
не ломается.
А, сейчас, одинаковые альфы для разных В, да?
Я неправильно, значит, понял просто.
Одинаковые альфы.
Да, да, справедливо. Ну, понятно, что такого
не бывает, да? Ну, автомат 10-мин, нельзя
прочитать одну и ту же альфу, попасть в В. Да, спасибо, это
важно. Да, это я явно не проговорил.
Вот.
Значит, давайте допишем, да? Да, спасибо,
давайте это запишем, что разным В
соответствуют разные альфы.
Потому что автомат
диссерминированный, и нельзя, прочитав
одну и ту же альфу, попасть в одну и ту же В.
Значит, суммарно таких альф,
значит,
суммарно
посещений
таких В
не больше,
чем таких альф,
а их вот он.
Ну, все.
Построили автомат
за линейное время.
Да, конечно.
Вопросы?
Все, тогда спасибо, давайте
нас сегодня закончим.
