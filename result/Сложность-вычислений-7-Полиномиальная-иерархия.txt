Значит, мы немножко ушли вперед на лекции по сравнению
с семинарами.
Мы уже начали полинамеральное иерархию.
Насколько я понимаю, ни в одной группе еще задачи
при нем не начали разбирать.
Ну, ничего страшного.
Давайте я вкратце напомню, что мы обсуждали.
Значит, мы обсуждали такую структуру.
Знаете, что есть класс П, который же считается и
фигма 0, и Пи 0 пальномиальным.
Значит, дальше он вложен в Np, который есть фигма 1
пальномиальная и он же вложен в Коэнпе, который есть
Пи 1 пальномиальное.
Дальше есть фигма 2 пальномиальная, Пи 2 пальномиальная и они
вложено вот так вот крест-накрест
дальше сигма-3-пальномиальная и
3-пальномиальная
дальше тут все вложено крест-накрест и
так далее и это все вложено в pH
значит pH это слово полиномиолхаэроши, которое объединяет все эти классы
вот
начну определение такое
да обобщает катное определение n-p
значит а именно там
получалось что язык s
лежит в сигма-катом
полиномиальном тогда и только тогда когда для
некоторого полиномиального учислимого
вы верно следующее что x лежит в s
тогда и только тогда когда
существует
y1 для любого y2
существует y3 и так далее и здесь для любого или существует
существует ли для любого в зависимости от четности
числа k соответственно если k нечетные то существует если четные то для любого
дальше будет ykt и в конце еще тут будет v от
x и y1 и y2 и так далее
yt
вот
пикатма аналогично только первый квантор другой на первый квантор для любого
вот ну и мы обсуждали
различные условия при которых
это вся иерархия
коллапсирует да то есть продолжается до какого-то этажа а дальше все получается одинаково
но в частности если п равно n-p это вообще все одно и то же
значит все все эти классы будут совпадать с п
вот но если п не равно n-p но n-p равно q-n-p
начинает с первого уровня все одно и то же
ну и мы обсуждали что
эквивалентно следующие условия да что на каком-то уровне
сигма и п совпадает или на том же уровне сигма со следующим совпадает или вся полинарная иерархия совпадает
соответствующим
уровнем
хорошо
значит но вот есть стандартный инструмент изучения конкретных задач разных классах это
инструмент сводимости до концепции сводимости и полноты
да мы уже изучили полимерную сводимость и n-p полноту
здесь та же самая полимерная сводимость и
соответственно полнота на разных уровнях иерархия
да то есть да значит на
различных
уровнях иерархия
значит на различных уровнях иерархия существует
полная задача
вот ну и определяются они точно так же как и n-p полная задача да то есть например
игма
катая полинамиальная полная
значит это означает что одновременно а
там по себе лежит все
а
там по себе лежит сигмакатом полинамиальном и для любого б
из сигмакатого полинамиального верно чтобы
полинамиально сводится к
вот где сводимость та же самая по карпу
да то есть получается что мы по x вычитаем какой-то f от x и
x лежит в б тогда только тогда когда f от x лежит в а
вот
ну и на самом деле тут
значит бывают какие-то
структурированные задачи но и как на счет как и с n-p
есть стандартная задача
как бы с
связанной с логикой
на то есть вот у нас есть задача у выполнимости
значит есть стат
задача у выполнимости то есть нож таких фи
то
существует x такой что фи от x равно единице
вот это задача n-p полная
значит дальше бывает
задача о тавтологии
значит задача тавтология
то есть нож таких фи наброс что для любого x
я ты к равно единице
вот эта задача коин ф полная
ну а здесь будет вот одновременно аналогичная задача
значит именно сигма к тсад
да значит это означает что тут нож таких фи то
существует x 1 для любого x 2 существует x 3 и
так далее
здесь соответственно зависимости отчетности существует и для любого x ката
ну и дальше соответственно фи от
x 1 x 2 и так далее x ката
равно единице
вот ну если соответственно пик ате аналогично
пик ате
то же самое
поэтому тут для любого ли существует пик ате
ну значит если тут всего два уровня
то можно как-то интерпретировать
например существует
значит существует x для любого y фи от x y
равно единице это как бы задача тавтологии с параметром
значит задача о
тавтологии с параметром
да то есть тут подразумевается что x это параметр y это собственно аргумент и
вопрос можно фиксировать параметр так чтобы по аргументу это остался тавтология
но вот это из сигма 2
вот а если наоборот для любого x существует y
то есть у нас есть тавтология
и
вот а если наоборот для любого x существует y и
я тык сыгрок равно единице да то это можно назвать задачей об универсальной выполнимости
значит задача об
универсальной выполнимости
значит ну соответственно здесь получается на наоборот верно ли что как бы мы не фиксировали параметр x
останется выполнимая формула
но а если больше квантеров то получается
намешивать квантерра если если три будет квантера то будет соответственно
задача об универсальной выполнимости с параметрам
соответственно будет еще кainen hundreds от дай можно ли так фиксировать парамуты чтобы осталось универсiga выполнимость
или задача соответственно об универсальной тавтологии с параметром
что как бы не фиксировать еще третий параметр, все равно получится
тавтология для некоторого параметра. Ну и так далее. И это можно продолжать уже.
Ну вот выше третьего уровня уже получается не очень содержательная задача,
но хотя иногда можно что-нибудь и найти.
Так вот, утверждение такое, что эти задачи полные.
Сигма-катая сад – это полная задача в сигмакатом пальномиальном,
ну а, соответственно, пикатая сад – это полная задача в пикатом пальномиальном.
Вот. Ну, как это доказывается?
Ну, более-менее так же, как терминку Кливена, но с некоторой оговоркой.
Значит, а именно, на самом деле, для параметров одной чётности лучше доказывать одно,
для другой чётности лучше доказывать другое.
И поэтому, прежде всего, мы поймем, почему эти два утверждения между собой эквивалентны.
Значит, доказательства.
Первое. Эти два утверждения эквивалентны друг другу.
Так. Почему?
Ну, на самом деле, это легко понять.
Ну, как связана выполнимость и тавтология?
Формула выполнима тогда и только тогда, когда её отрицание не является тавтологией.
А тут, соответственно, получается, что фи лежит в sigma k сад.
Тогда и только тогда, когда не фи не принадлежит phi k сад.
Но такое своеобразное двойное отрицание.
Хотя в некотором смысле и тройное.
Но не тройное, а два отрицания и одна перемена кванторов.
Причем одно отрицание внутри формулы, а другое отрицание к утверждению.
И ещё, соответственно, меняются все кванторы.
Ну и тогда получается, что получается так.
Что х, например, пусть известно, то, скажем, sigma k сад является sigma k поленомиальное полным.
Вот тогда рассмотрим какое-нибудь множество.
Пусть s из pi капальномиального.
Значит, тогда s чертой будет из sigma k полномиального.
Ну, потому что это вот сюда нужно посмотреть.
Если мы пришли к s чертой, то мы взяли отрицание вот здесь.
Значит, у нас все кванторы обратились.
И отрицание вот сюда пришло.
Но если v поленомиальный вычислимый, то отрицание v тоже поленомиальный вычислимый.
Поэтому, соответственно, для другого v получается формула со всеми кванторами наоборот.
Вот, тогда с чертой лежит sigma k полномиальное.
Значит, и получается, что для вводимости f имеем, что х лежит v с чертой тогда и только тогда, когда f от x лежит sigma k сад.
Вот, но дальше получаем, что с одной стороны х лежит v с чертой, это тогда и только тогда, когда x не принадлежит s.
Вот, а здесь по вот тому вот имеем, что это тогда и только тогда, когда f от x не принадлежит k сад.
Ну и теперь вот эти отрицания принадлежности можно снять.
И, соответственно, получаем, что х лежит v с тогда и только тогда, когда не отрицание f от x принадлежит pi k сад.
Ну, вот и получили, что если f делала формулу, которая работала для s, для s с чертой, то тогда отрицание этой формулы будет работать для самого s.
Вот. Ну чего, понятно? Хорошо.
Ну а теперь дальше можно вспомнить, как мы доказываем теперь кукулевина.
Да, у нас там была какая-то большая, очень большая таблица протокола работы.
И мы говорили, что эту таблицу можно так заполнить, соответственно, так, чтобы его работало.
Вот, но там мы пользовались следующим.
Там мы пользуемся тем, что у нас по у квантор существования, по сертификату квантор существования и по тому, как заполняется таблица тоже квантор существования.
И, соответственно, они должны склеиваться между собой, то есть и там существование, и там существование.
Ну, соответственно, чтобы это работало, чтобы это работало в целом, нужно, чтобы последний квантор, ты почки, да, вот здесь вот нужно, чтобы последний квантор был квантором существования.
Ну а это будет как раз для нечетных k и sigma, или для четных k и pi.
Ну вот, значит, теперь получается, что для нечетных k докажем sigma k в полноту sigma k sad.
Вот, а для четных k докажем pi k в полноту pi k sad.
Вот такой вот план.
Ну а реализуется он очень легко.
Ну, очень легко по модулю понимания теоремку Клейвена, да, то есть если мы же забрались вот с этим заполнением протоколов, да, то тут как бы нужно написать так, что вот здесь вот,
значит, здесь x, здесь y1, y2 и так далее, там yt, и тут какой-то протокол.
Ну и соответственно тогда нужно писать так, что x у нас лежит в s, тогда и только тогда, когда там существует y1, для любого y2 существует y3 и так далее.
Существует yk и существует протокол.
Ну а дальше, значит, дальше, соответственно, нужно написать формулы.
Значит, тут формулы, означающие корректность протокола.
Вот, эти формулы пишутся точно так же, как в теоремку Клейвен написались, да, то есть нужно, чтобы верхняя строчка соответствовала тому, что вот здесь вот выбрано.
Соответственно, в нижней строчке было бы принимающее состояние, а по дороге все переходы соответствовали командам машины тюринга.
Ну да, даже запишем.
То есть верхняя строка соответствует, соответственно, набору xy1, y2 и так далее.
В нижней строке есть принимающее состояние, ну а в середине все вычисляется по правилам машины тюринга.
Да, значит, соответственно, внутри таблица вычисляется по правилам машины тюринга.
Ну вот, и за счет того, что здесь последний квантор одноименный, существует пара из y и протокола.
Но с пикатом точно так же, только тут первый квантор будет другой, а важно, что последний квантор склеивается с квантором по протоколу.
Вот, что такое рассуждение. Есть какие-нибудь вопросы?
Ну ладно, дальше я думаю другие примеры все-таки будут на семинарах.
Значит, в принципе, ну вообще ученые исследовали не только mp-полноту, но и полноту вот в этих классах.
И определенное количество задач полных нашли. В частности, те задачи, которые мы в прошлый раз на лекции изучали, будут полными.
Но это обычно не то чтобы прям просто доказывается.
И там тоже есть такой компендиум называется, то есть сборник полных задач.
И там как раз на втором уровне их довольно много, на третьем совсем немного, а на четвертом там как-то и нет.
Да, не возникает естественных задач. Да, то есть вот это получается, я считаю, искусственной задачей.
А естественной, которая берется там из комминаторики, из теореграфов и так далее.
Вот.
Что еще тут можно сказать про полные задача?
Но можно задаться вопросом, а бывает ли полные задачи прямо во всем pH?
Значит, могут ли быть полные задачи?
Во всем pH.
Ну, как думаете, могут, не могут?
Ну, ответ такой, что никто не знает.
Но условное утверждение такое, что если не существует, тогда происходит коллапсирование.
Значит, ответ такой, только если происходит коллапс.
И на самом деле это довольно легко понять, потому что это что такое вообще pH?
Ну, это обвинение всех уровней.
Всех уровней там, ну, любого.
До бесконечного.
Ну, бесконечного нет.
Всех, со всеми номерами, сколько годно большими.
Ну, а тогда, если у нас есть какой-то элемент,
если у нас есть элемент этой самой лестницы,
этой самой лестницы, этого объединения, то что это значит?
Это означает, что этот элемент лежит на каком-то конкретном уровне.
Да, тут как бы нет бесконечного уровня, да, есть только полокупность конечных.
Ну, а тогда получается, что раз это полная задача, то к ней все сводятся.
В том числе и сводятся есть более высоких уровней.
Ну, и дальше, да, тут на самом деле нужно где-то было сказать,
что если там какой-то язык примерно сводится к языку из сигмакатова,
то он сам лежит сигмакатом.
То есть нужно писать, что если такая простая лемма,
если а сводится к b, а b лежит сигмакатом,
то тогда а лежит сигмакатом.
Вот почему это так?
Ну, просто происходит то же самое, да, но вместо,
вместо x-а подставляется там f от x в определение.
И, соответственно, получается такая же цепочка, да,
вместо v, вместо верификатора для a получается верификатор для b,
а вместо x-а f от x.
И получается точно такое же выражение, как и было.
Ну, вот, соответственно, если, да, получаем, что если b полон ph,
да, всей племянной аерархии, то получаем,
что b лежит в сигмакатом для некоторого k.
Вот, ну и, соответственно, следовательно, все ph.
Да, значит, если a лежит в ph, то a сводится к b,
и, следовательно, a лежит в сигмакатом.
Ну и, следовательно, получается, что ph будет равно сигмакатому.
Ну, потому что отсюда пучился ph вложено и обратно тоже вложено,
потому что ph-то объедение всех сигмакатах.
То есть получили как раз коллапсирование.
Поэтому, если тут в полной языке, никто не знает,
но все-таки типичное верование, что все классы, не только панированную NP,
не только панированную NP, а все этажи разные.
Вот, хотя мы и не знаем приятных нам задач на этажах выше третьего,
но предполагается, конечно, можно что-нибудь придумать такое искусственное,
но вот как-то не возникает ничего такого,
что было бы придумано не для демонстрации того,
что может быть задача на 10-м этаже,
а такой задачи, которая бы нас еще почему-то бы интересовала
и была бы выше третьего этажа.
Вот как, ну, бывает пересечение 2-4 уровней для точных задач и оптимизации,
как мы это обсуждали на лекции,
но выше вот как-то не получается.
Вот, хотя вообще, наверное, можно попробовать что-нибудь поискать,
потому что вот у такого очередования кванторов есть игровая интерпретация.
Да, можно вообще вот этот процесс,
ну, например, вот на эту форму посмотрим.
Значит, этот процесс можно понимать как игру между двумя игроками, там,
четным и нечетным.
Вот, и тогда, соответственно, сначала нечетный выбирает X1,
потом четный выбирает X2,
потом нечетный выбирает X3,
и так далее, значит, происходит вот такая вот игра,
а в результате ФИ говорит, кто выиграл.
Да, ФИ это как правило игры, которые говорят, что если
первый ходил X1, потом второй X2, потом первый X3, и так далее,
то выиграл, если равно 1, то выиграл нечетный, если 0, то выиграл четный.
И тогда вот это вот все выражение с кванторами
говорит, что у первого есть выигрышная стратегия, да, у нечетного.
Да, то есть нечетный может сделать такой хороший ход в начале,
что потом как бы не ответил четный,
нечетный все равно сможет ответить,
да, и так далее, и так далее,
что в итоге нечетный выиграет.
Да, это называется выигрышная стратегия, да, что независимо от действий другого,
первый может сделать так, что выиграет.
Вот, ну а здесь наоборот, да, значит, здесь у второго есть выигрышная стратегия, да,
как бы ни сходило первый,
второй сможет ответить, что как бы потом
снова первый не ходил, и так далее, в итоге выиграет.
Ну, первый проиграет, то есть выиграет второй.
Вот, и получается, да, что это вот такие игры,
которые длятся заранее известное число ходов.
Да, вообще можно ставить вопрос о сложности игр,
это довольно содержательный вопрос для многих игр.
Но, чтобы это был вопрос из теории сложности,
особенно нужно, чтобы была не одна игра,
а семейство игр, ну, грубо говоря, на сколько год на больших досках.
Да, например, шашки очень легко обобщаются,
шашки на любой доске, да, четные на четные,
да, в общем, легко можно определить правила.
Да, или там игра ГО тоже легко определяется на любой доске, нечетные на нечетные.
Да, игра там, конечно, есть кинолики, тоже на любой доске легко определяется.
Вот, шахмы-то уже не так легко определяются, да, и это можно сделать, конечно,
но там нужно аккуратно сказать, сколько будет, каких фигур,
какие там, как рокировка происходит, и так далее.
Вот.
Ну вот, но, соответственно, дальше во всяких таких играх получается,
что чем больше доска, тем больше потенциальных ходов может быть.
Да, ну, например, там крестики нолики.
Да, у нас просто каждый ход на одну клетку меньше становится,
поэтому сколько всего клеток, столько и ходов может быть.
Чем больше доска, тем больше ходов.
Вот, а вот здесь вот такие игры, у которых число ходов заранее фиксировано.
Да, то есть известно, что там доска может быть сколько угодно большая,
а ходов будет, например, 20.
Да, и там и на доске 20 на 20 будет 20 ходов,
и на доске 100 на 100 будет 20 ходов,
и на доске 1000 на 1000 будет 20 ходов, и так далее.
Да, то есть сами ходы могут быть какими-то хитрыми и большими,
но их будет всего 20.
Вот.
Ну, а тут, наверное, можно поискать какие-нибудь хорошие игры,
в которых, естественно, образно это ограничение число ходов возникает,
и анализировать их в полноту.
Но я отчет не встречал таких работ.
Так, значит, я хочу еще про две вещи рассказать.
Значит, одна...
Ну, это обе вещи такие, как бы, с стороны моделей.
Значит, одна вещь вот такая.
Значит, смотрите, у нас вообще с классом NP было два определения.
Одно определение вот примерно такое, через сертификаты,
а второе определение через специальный вид машин.
Да, значит, именно через недetermинированные машины.
Вот.
Вот здесь, на самом деле, тоже можно...
Ну, и тогда, как бы, для этого специального вида машин
определение было очень простое.
NP — это класс языков, которые на этих недetermинированных машинах
распознаются за полимерное время.
Вот.
Вот здесь, на самом деле, точно также есть специальный тип машин,
которые называются альтернирующие.
Альтернирующие машины.
Значит, альтернирующие машины — да, это как бы класс...
Ну, это некоторая модель, при которой...
Пигма КП и пика П, значит, становятся...
Значит, становятся...
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Классами языков.
Классами языков распознаваемых
за полимерное время.
Ну, вот, на машинах.
Специального вида.
Вот.
Ну, значит, вот эти вот машины, они выглядят похоже на недetermинированные,
но еще дополнительное оснащение тут появляется.
Да, то есть тут, во-первых...
Значит, во-первых, получается, что функция перехода...
Функция перехода...
Функция перехода...
Многозначно.
И этим они похожи на недetermинированные машины.
Вот.
Но кроме того, у каждого состояния...
Значит, состояния делятся на два типа.
Значит, состояния...
Делятся на...
Сигма.
Значит, на сигма состояния.
И пи состояния.
И это прямо изначально зашито.
То есть изначально прямо про каждое...
Не даже не про конфигурацию даже, а прямо про состояние.
Множество q разбито на два класса.
Сигма состояние и пи состояние.
И дальше ответ...
Получается таким.
Да, значит, ответ...
Подсчитывается...
По конфигурации...
Следующим образом.
Если это конфигурация уже завершающая.
Значит, если конфигурация уже дала ответ,
значит, конфигурация содержит...
Причём положительный ответ.
Значит, конфигурация содержит qA.
Ну, а то и значит принимающая.
Значит, если содержит qR,
то linea а lowers...
Значит, если содержит QR, то отвергающее.
Но дальше, если состояние, если конфигурация содержит,
дальше рекурсивно, если конфигурация содержит
сигма-состояние, вот, и один из переходов ведет
принимающую конфигурацию, то вот это текущее тоже
принимающее.
Да, значит, один из переходов в принимающее состояние,
но тогда текущая тоже будет принимающая.
Ну, а если сигма-состояние и все переходы вытвергающие,
так только принимающая конфигурация, то есть тут
предполагается, предполагается, что у нас нет бесконечных
вычислений, соответственно, у нас получает некоторое
дерево, да, какое-то вот такое вот, ну и так далее,
да.
То есть на листах там написано принимающая и отвергающая,
и дальше мы поднимаемся сверху вниз, вот, используйте
правила, если у нас стоит сигма, стоит сигма и какая-то
одна ветка переходит в принимающее, то тогда все это принимающее.
Вот, а если P-состояние, если P-состояние и, соответственно,
все переходы, все переходы в принимающее, то тогда получается
принимающая, принимающая конфигурация.
Ну, конечно, да, да, да, иначе отвергающая.
Значит, иначе отвергающая, и там, и там, вот, ну и тогда
если у нас действительно нет бесконечных ветвей,
да, это все ветоучленения заканчиваются за конечное
время.
Ну, как нас учит Лема Кёнига, да, нужно, чтобы не просто
вот каждый заканчивалось, да, была какая-то общая
граница по времени, вот, но тогда получается, что
мы, начиная с листьев, рекурсивно поймем в каждой конфигурации
какой там ответ, а общий ответ, это будет ответ в
начальной конфигурации.
Общий ответ, это ответ в начальной конфигурации.
Да, да, да, да, да, да, да, да, да, да, да, да, да, да, да,
да, да, да, да, да, да, да, да, да, да, да, да, да, да, да,
да, да, да, да, да, да.
В частности, ФТНП получается, и вообще нетätомерные машины
получаются.
Если все соединения, это с Hani вот, тогда у нас
получается только кванторисуществование, да, и любая единица поднимется
наверх и в итоге будет единица так ну а дальше соответственно получается что
можно определить классы значит тигма когда я тебя вот так не пишу в другом
натип как np coin а так сильно капе значит это класс языков
класс языков распознаваемых альтернирующими машинами альтернирующими машинами тюринга у которых
начальное состояние это сигма состояние да то есть начале мы начинаем фигмы у которых
значит начальное состояние это сигма состояние вот ну и кроме того на каждой ветви число
смен типов состояния но число смен получается не больше чем к-1 до число блоков одного
типа не больше чем к-1 на каждой ветре число смен
типов состояния строго меньше чем к у вас соответственно число блоков одинаковых
состояний получается не больше чем к но вот здесь вот на этой картинке вот уже как минимум сигма
3 потому что сигма потом пи потом сигма на это уже как минимум сигма 3 но соответственно
пика тп это аналогично вот но соответственно начальное состояние это пи состояние
но и теория такая что это тоже самое что у нас было
значит некоторые книги просто считают синонимами но я предпочитаю вот такой взгляд что это не просто
синонима это два разных определения одного и того же значит сигма катая пальномиальная тоже
что сигма капы а соответственно пи катая пальномиальная это пика по я вот
но в самом деле это стихи один который проще понять чем формально доказать вот
знаете постараюсь но поверх понятно что это одно и другое совершенно одинаково доказывается
так что можно что-нибудь одно доказать данный пример про сигму вот но идея такая что смотрите
в одну сторону там право налево да пусть как альтернирующую машину записать через там
по линейным предикат в общем в целом это похоже на два два определения нп да идея
точно такая же но в одну сторону да пусть у нас так альтернирующая машина тогда мы прямо такую
там формулу напишем да что существует ветвь вот здесь вот что для любой ветви вот здесь вот
существует ветвь вот здесь вот до 4 и так далее да что
но тут на самом деле дай когда тут разные типы то это не совсем так прям как так легко как прям
как я сказал на то что тут существует вот такая и существует вот такая что для любой там и там
и существует вот такая же любой вот это и вот этой их вообще может быть много но в общем надо
сказать так что существует как бы ветвь но вот вы пусть нас наверху наверху сигма состояние тогда
говорится так что существует хорошая ветвь ну которая будет идти до первого попавшегося пи
да она будет либо вот такая вот ветка длины 1 либо вот такая длинна 2 либо там вот такая
Wähtype- Beta и так далее да существует ветка который можем идти пока awaiting состояние так что
для любой ветви который дальше usb состояние идет она как раз может быть разными게요 да то есть
напрямую идет налево тőтут дальше еще что-то если она идет направо то даже если там что-то есть то
то мы это не будем читать, а дальше уже перейдем дальше.
То есть существует ветка до P-состояния, так что для любой ветки до Сигма-состояния
существует ветка до P-состояния и так далее.
Такая, что в итоге это все приходит к принимающему состоянию.
То есть опять же можно это воспитать как игру.
Есть вот такое дерево, и два игрока двигают фишку.
Первый двигает пока может по Сиг м состояниям, но созвестно как хочет.
Да, может сразу сюда сдвинуть, может сюда, потом сюда,
может сюда, потом сюда, потом там и еще куда нибудь.
Оот потом второй как только получил, он тоже может как угодно подвинуть,
может подвинуть сразу сюда, может сюда там, потом еще куда-то.
Вот так далее, потом снова первый двигает, ну и так далее.
Ну и так далее. Соответственно, вот в этой игре должен выиграть первый.
Да, он в итоге должен привести к принимающему состоянию.
Ну, поэтому получается, что sigma kp вложено в sigma kt пленомиально.
Ну, не знаю, как, примерно понятно?
Ну, вроде да. Ну, формально там какие-то формы надо писать.
Идея именно в таком чередовании.
Ну и дальше, поскольку тут на каждой ветве не больше, там меньше, чем k смен,
то и кванторов получится не больше, чем k.
То есть смен кванторов будет меньше, чем k, а смен кванторов не больше, чем k.
И поэтому тут именно то же самое k получится.
Ну а в другую сторону еще проще.
В другую сторону как раз как бы сначала мы при помощи sigma состояния выберем x1,
потом при помощи пис состояния выберем x2,
потом при помощи sigma состояния выберем x3 и так далее.
Там уже такое равномерное дерево получится.
Ну, будет картинка примерно такая же, как была для NP.
Значит, например, сначала вот так вот.
А потом вот так вот.
Вот так вот.
А потом уже все просто идет вот так вот.
Регулярно.
Да, тут уже какие-то ответы получаются.
Вот это я для sigma2 нарисовал.
Как работает альтернирующая машина.
Сначала мы sigma состояние выбираем y1, потом в пис состояние выбираем y2.
А потом уже со всем выбранным начинаем производить детерминированные вычисления.
Вот.
Так, ну ничего, понятно.
Так, хорошо.
Значит, если это понятно, тогда...
Но вот еще я пока подвешу вопрос.
Что будет, если мы вообще не будем ограничивать число смен кванторов?
Что у нас будет просто дерево полинамеральной глубины,
но смен может быть сколько угодно.
Вот, там тоже некоторый класс получится, но мы его пока не проходили.
Так что этот вопрос я...
А пх точно так же просто будет объедением всех вот этих вот...
То есть можно сказать, что пх это такая же штука,
где число кванторов любое фиксированное,
ну, фиксированное, то есть это такое же самое,
что и в холмах, в холмах, в холмах.
Любое фиксированное,
ну, фиксированное, то есть независящие от размера входа,
но при этом любое.
Вот тогда это пх получится.
А если оно еще и с размером входа может увеличиваться,
тогда будет другой класс.
Ну ладно, я уже анонсирую, это будет класс PSPACE,
то есть где полинамеральная память.
Вот, но почему именно он?
Говорим попозже, когда будем про PSPACE говорить.
PSPACE еще больше разных способов взглянуть.
Этот класс.
Так.
Ну, на сегодня последний тему, который я хочу обсудить,
и это вычисление с аракулами.
Четыре, наверное, мы немножко перекинемся на следующий раз
с вычисления с аракулами.
Значит, ну а ракулы,
ну вообще, что такое аракул?
Ну, это такое мысленное устройство подсоединенное к компьютеру,
так что на ход этому устройству можно подать любой запрос,
и это устройство выдаст какой-то ответ на этот запрос.
При этом мы уверены, что ответы в этом самом аракуле
записаны заранее.
То есть в частности то, что он нам ответит,
не зависит от истории общения с ним.
В частности, если его спросить еще раз то же самое,
то он ответит тоже еще раз то же самое.
Вот.
Так, ну вот, значит, вычисления с аракулами.
Так, ну пусть у нас,
пусть у нас, а это просто какое-то множество,
просто какое-то множество,
просто какое-то множество слов.
Вот, тогда П,
аракулом А,
значит, это класс языков,
значит, класс языков,
значит, распознаваемых
за полимерное время
с обращениями,
с обращениями
к А.
Ну а как эти обращения
к А устроены?
Ну, может быть,
можно моделировать через ленту,
то есть, например, есть специальная аракульная лента,
и машина на ней что-то пишет,
потом приходит специальное состояние запроса,
и дальше, соответственно,
она как бы раздваивается,
и аракул как бы ее сам направляет в следующее состояние,
и она понимает, какой был ответ,
либо да, либо нет.
То есть, скажем, машина
записывает запрос,
значит, машина записывает запрос
на специальной ленте
и получает
ответ
о его
принадлежности
к А
за один шаг.
Ну, соответственно, можно
изменить
ну, соответственно, можно
точно так же с аракулом любой другой класс рассмотреть.
Давай скажем, NP
с аракулом А это аналогично.
Аналогично, да, значит, только
ну, опять, может быть, два определения
через генетерминированную машину
или через верификатор,
ну, например, через верификатор
это как-то более понятно,
потому что тут верификатор
верификатор обращается
к А.
Так, значит,
ну, я напомню, что мы
уже встречали теория Мэмбейкера
Джила Соловея.
Я бы, наверное, даже сейчас доказал
просто.
Значит, теория Мэмбейкера
Джила
Соловея
заключается в том, что
существует один аракул А,
при котором P равняется
NP,
да, существует другой
аракул B,
значит, при котором
P, заведомо, не равняется
NP.
И вопрос только в том,
в каком из этих классов относится пустой аракул,
ну, или там,
вычислимый за
пандемиальное время. Значит, ясно,
что аракулы могут быть совершенно разными
по своей полезности,
но если аракул пустой, да, всё время говорит нет,
тогда он вообще не нужен.
Но если он вычислимый за пандемиальное время,
тогда он тоже не нужен, да,
тогда все его ответы можно вычислить
вместо запросов.
А может быть так, что он вообще
Да, тогда он, конечно, очень полезен, он сильно расширяет.
Например, есть известный оракул ноль-стрих, который
решает проблемы остановки.
Да, если вы решаете проблемы остановки, то, соответственно,
вы много чего другого сможете решить.
Вот.
Ну вот, соответственно, вот получается, что
есть такие оракулы, которые
увеличивают P и NP одинаково, а есть те, которые
заведомо NP увеличивают сильнее.
Вот. На самом деле, вот этот вот результат, он такой
типичный для теории 80-х годов.
Да, даже хотя он сам еще в 70-х был получен.
Да, ну вот, это вот такая типичная структурная теория
сложности, когда мы изучаем какие-то классы
и строим оракулы, которые как-то отделяют друг от друга.
Вот, а с частности, например, есть более
сильный аналог этой теоремы, что, на самом деле, для любого уровня
катова есть такой оракул, что полинарные рархи коллапсируют
ровно катом уровня. Знаешь, что до катом уровня все классы
разные, а начиная с катом, все одинаково, с этим оракулом.
Вот. Ну, это, в общем-то, вот, это
вот. Ну, и там куча других есть
разных результатов. Вот, а еще
есть такая
значит, еще, может, вот как писать,
значит, можно показать или строить не отдельный язык, а
раз. То есть, например,
может быть, скажем, пэа
с оракулом n пэа. Значит,
это означает
то
можно
делать запросы
к разным
n пэа языкам.
Ну, например, у нас n пэа язык же определяется
там своей программой. Да, может считать, что мы написали программу,
написали текст запроса и спрашиваем,
лежит ли такой x в языке
задан такой программой.
Вот. Ну, ясно, что на самом деле вовсе не обязательно так сложно делать, а можно все запросы делать
к одному n пэа полному языку.
Значит, или к одному
значит, к одному n пэа полному.
Значит, если мы запрашиваем один n пэа полный язык, то это получается
в общем то же самое.
Вот. Ну, вот. И есть еще
такая вот теорема о структуре ph.
Теорема о структуре
ph.
Значит, смотрите,
sigma k плюс первая полинамиальная
это будет n пэ
sigma k полинамиальная. Ну, и это самое то же самое, что
n пэ с оракулом pi k полинамиальная, потому что как раз
ответ оракула можно переворачивать.
Да, то есть, если оракул отвечает там про sigma k,
то можно его ответ перевернуть, будет ответ про pi k.
Поэтому тут как раз мне не важно кого запрашивать.
Ну, а соответственно, pi k плюс первая
полинамиальная это будет ko n пэ
с оракулом.
Ну, тут то же самое. Да, можно писать sigma kt.
Можно писать pi kt.
Вот. И на самом деле тут получается, дайте тут есть n p,
есть ko n p. Есть на самом деле еще
одна иерархия, еще одна как бы параллельная иерархия,
которая именно вот здесь вот возникает, ее не так-то просто иначе определить.
Да, они называются дельта. Да, еще бывает
дельта k плюс первая полинамиальная, которая есть
p с оракулом
sigma kt и то же самое, что p с оракулом pi kt. То есть,
вот это вот p с оракулом n p это delta 2.
Вот. Ну, дельты мы почти не будем изучать.
Вот. А вот эти вот теоремки докажем.
Но, правда, видим уже в следующий раз, сейчас я только начну.
Дайте я, наверное, вот это вот самое простое.
Дальше самое простое. Или уж какие-нибудь вопросы есть
по формулировкам.
Ну, на самом деле тут простое. Дальше простое это первое утверждение
из теории Бейкера Джилла-Салавея и одно из направлений
вложений вот этих вот. То есть, на самом деле, здесь
вот то, что левое вложено вправо, это очень легко, потому что у нас такая цепочка
из кванторов. Если мы внешний квантор уберем, то у нас получится цепочка
на единицу меньше. И можно про эту цепочку на единицу меньше спрашивать
у оракула. Вот. А последний квантор, точнее
первый, значит первый квантор, который разводит либо NP, либо CoNP.
Вот. Поэтому левое вправое понятно, почему вложено.
Вот. А правое влевое сложнее, потому что
мы можем про много разных...
Мы можем делать много разных запросов. Там мы как бы один запрос сделали.
Вот. А тут мы много разных запросов сделали. Нужно их как-то объединить, все кванторы,
которые там получаются, в одну вещь. Да. Поэтому в другую сторону нетривиально.
Так. Ну и почему...
Почему есть оракул,
при котором P равно NP?
Ну это будет оракул, значит это будет оракул, при котором
можно делать экспоненциальные вычисления.
Значит, это A
будет называться Exponential Computation.
Так. И это будет следующее.
Значит, тут будет пара из m,
x и какого-то числа
t в унархной записи. Да. Так что
m от x равно единице
за меньше либо ну чем 2 в степени t шагов.
Вот.
Ну или можно даже считать, что здесь просто число шагов
задано в двоичной записи. Да, и вопрос
верный, что m от x вырастает единицу за вот такое число шагов.
Так.
Ну и тогда получается
следующая цепочка.
Значит, смотрите.
Берем класс exp.
Exp, то есть то, что решается за экспоненциальное время.
Ну и очевидно, что он вложен в P вот с этим оракулом.
Да, потому что если нам нужно
вычислить, да, про какой-то x лежит он в языке или нет,
то этот язык расположен на какой-то машине m, и мы ровно про эту машину
на этом xе за такое время, за которое он вычисляется, спрашиваем
будет единица или нет. И это будет ровно то, что нам нужно.
То есть одним запросом правильно построен к оракулу, все решается.
Вот. Значит, дальше P
с этим самым exp.com вложено в n-P
с оракулом exp.com. Это для любого оракула,
так на самом деле, да, потому что всегда детерминированное
это частный случай не терминировано, и с оракулом тоже. Да, это так с любым оракулом
будет. Ну вот, а n-P
с exp.com вложено в exp.
Ну и вот это вот тут единственный нетривиальный переход.
Да, значит, это верно, потому что
экспоненциального времени
экспоненциального времени
хватит.
И для
вычисления ответов
от этого самого exp.com
ну потому что нам достаточно просто запустить
машину на такое экспоненциальное время и посмотреть, будет единица или нет.
Да, поэтому ясно, что оракул, который
делает экспоненциальные вычисления, можно как раз вычислить за экспоненциальное время.
Вот, соответственно, хватит и для вычисления ответов
оракула, и для перебора
и для перебора
сертификатов.
Да, потому что y все тоже будут поленали длины
и можно их все перебрать за экспоненциальное
вариантов. И для каждого конкретного y будет экспоненциальное время
на вычисление ответов, ну а произведение экспонентов
тоже экспонента, поэтому общий время будет экспоненциальным.
Ну вот, а раз тут то, что слева и то, что справа, это одно и то же, значит, здесь все одинаково.
Ну и в том числе средние два тоже.
Что нам и требовалось.
Так, ну ладно, значит, тогда в следующий раз докажем
вторую часть теоремы вот этой, сложное направление вот в этой теореме,
а потом, видимо, будем как раз к PSP сдвигаться.
Поговорим, что будет, если тут число смен кванторов не ограничено.
И вот какие-нибудь вопросы.
Ну ладно, тогда спасибо.
