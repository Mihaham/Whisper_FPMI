Итак, мы сегодня поговорим про просочетания, что это
вообще такое, как их искать в двудольных графах, и
с их помощью докажем терму Кионига, и тем самым найдем
алгоритм, как находить в двудольном графе максимально
независимое множество и минимально вершинное покрытие.
До этого еще дойдем.
То есть, определение пусть уже это неориентированный
граф, тогда под множество, множество его ребер называется
просочетанием.
Если никакие два его ребра, никакие два ребра из m не
имеют общих вершин.
Никакие два ребра множества m не имеют общих вершин.
Ну, пример какой-то такой.
Нарисую такой квадратик, и тогда можно будет вот
эти два ребра выбрать и искать, что это просочетание,
потому что это ребра исходного графа, множество m из этих
двух ребер лежит в множестве ребер исходного графа, и
при этом они не пересекаются по, ну, не имеют общих концов,
не имеют общих вершин.
Тут можно еще говорить, что они не пересекаются
по вершинам, что значит не имеют общих вершин, ну,
не пересекаются по вершинам, мы помним, что ребра это по
сути пары вершинок, может быть, что вот эти пары не
пересекаются, ну, собственно, просто, да, как множество.
Но если вы графически изображаете ребра, то они вполне спокойно
могут пересекаться, главное, что у них нет общих концов,
не пересекаются по концам именно.
Вот, по-другому можно сформулировать вот так, да, иными словами.
Значит, граф v запятая m должен иметь степени всех вершин
не больше чем один, должен иметь степени всех вершин,
не больше единицы.
Степень, напоминаю, это число ребр, которые из вершины
торчат нас, сколько ребр исходит из данной вершинки.
Ну, вот, например, на этой картинке у всех четырех
вершин степень ровно один, если мы оставляем только
ребра про сочетания.
Этот ребро дают плюс и д投ичку сюда и сюда.
Поэтому всех вершин остается один.
И в этом новом графе, когда мы вместо реб três ax, оставляем
Wales rapper сочетания.
Тогда у всех вершин степени ровно единичка.
Ну, понятно, может быть степень М, какая deutsche
вершина, которая не входит в поросочетании и понятно,
что не может быть два, потому что если уhov у вершин
ст Adrianva значит из нее торчит два ребра по сочетания, значит
нет, очевидны, пересекаются ровно по этой вершинке степней
два у нас быть не может.
Вот, ну то есть какой-то такой подграф, где у каждой вершины степень максимум 1.
Хорошо. Ну и наша глобальная цель была бы научиться находить наибольшее по размеру, по рассчитанию в произвольном графе.
То есть это можно делать, но мы ограничимся только случаем двудольного графа.
Значит наша цель по данному, в удольному графу
найти максимальное по рассчитанию.
Ну то есть по рассчитанию максимальной мощности.
То есть нужно максимизировать мощность тем.
Вот, и повторюсь, мы ограничимся только случаем двудольного графа.
Где? Значит напомню, кажется у нас не было двудольного, в семинаре только был.
Значит граф уже называется двудольным.
Ну например так, если все его вершины можно разбить на две доли, на два множества, так что ребра у нас только между долями.
Значит если существует такие множества l и l, то может быть 2down.
Если только есть 2.
два множества, так что ребра у нас только между долями.
Если существует такие множества L и R, то множество вершин
это их дизюмптное объединение, то есть объединить L и R получится
V, при этом L и R не пересекаются, и при этом любое ребро из
E, оно одним концом лежит в L, другим концом лежит в R.
При этом любая пара у V, лежащая в E, удовлетворяет такому
условию, либо U в L, A в V в R, или наоборот, U в R, V в L.
Формальное определение более даже громоздкое, чем
интуитивное понимание.
Есть несколько вершин X слева, есть несколько вершин
X справа, L и R, соответственно, и ребра могут быть только
между долями, но не внутри доли.
M это всегда, пар соч, это всегда под множество ребер.
В паросочетании вершины не выделяются, только ребра.
Ну а вершины, интуитивно можно ощущать, что все вершины
остаются, главное, чтобы у них степень была не больше
чем один.
То есть на вершины мы как бы не смотрим, когда определяем
паросочетание, только на ребра.
Хорошо.
Так, ну и давайте тогда сделаем следующее, наблюдение тоже
еще одно определение, как можно было бы искать паросочетание.
Ну вот пусть M это какое-то паросочетание в графе G,
когда путь в G называется увеличивающим путем или
увеличивающей цепью, что то же самое.
Так, опять поторопился.
Ладно, значит, если первые и последние вершины этого
пути не насыщены паросочетанием, то есть в терминах степени
имеют степень ноль, никакое ребро паросочетания им
не смежно, первые и последние как бы не лежат в паросочетании,
не насыщены ребром паросочетания, а на пути происходит чередование.
Значит, давайте напишем, первая и последняя вершины
пути не насыщены M, не насыщены, значит, что нет ни одного
ребра паросочетания, которое бы торчало из этих вершин.
Вот, и дальше на пути у нас должно быть чередование
типов ребер.
Первое ребро должно быть не из M, второе из M, третье
не из M, четвертое из M и так далее.
Я буду это называть типами ребер, типы ребер на пути
чередуются.
Ну и картинка.
Значит, первая вершина должна быть не насыщена
паросочетанием, дальше должно идти ребро не из паросочетания,
не M.
Дальше должно идти ребро из паросочетания M, потом
опять не из M, потом из M, потом не из M и должно закончиться
опять вершины не насыщены паросочетанием.
Значит, первая и последняя должны быть не насыщены
паросочетанием.
Где, повторюсь, насыщенность означает, что хотя бы одно
ребро из этой вершинки торчит, которое лежало бы в паросочетании.
То есть в терминах вот того графа в M степень должна
быть ровной единицей, чтобы быть насыщенной.
Понятно определение?
Вот, зачем оно нам надо?
Ответ очень простой.
Если относительно M есть какая-то увеличивающая цепь,
то M можно очень легко увеличить, выполнив чередование вдоль
пути.
Значит, что такое чередование?
Доль увеличивающего пути.
Ну, это просто нужно инвертировать типы ребер, которые на
этом пути находятся.
Те ребра, которые были не в M, нужно добавить в M, а
те, которые, наоборот, были в M, надо оттуда удалить.
Давайте на примере двухдольного графа я нарисую.
Вот представьте, что у меня был вот такой увеличивающий
путь.
Пунктиры это не из М, сплошные это из М.
Я инвертирую типы всех ребер.
То есть, я удаляю их в парасосочетании вот эти два ребра,
а добавляю вот эти три.
Тога картинка будет такой.
Значит, это ребро теперь в парасосочетании, это
не в парасосочетании, это в парасосочетании, это
не в парасосочетании, это в парасосочетании.
Вот.
Ну, легко видеть, что число ребер в парасосочетании,
Show pewper в М увеличилась ровно на единичку. Минус 2 г付 3, это ровно плюс 1
Ну и при этом если исходное у нас было по прочитанию, то оно и прощанием останется
потому что чтобы это было по прочитанию мне нужно что бы степени всех вышин
Потому что чтобы это было по прочитанию мне нужно чтобы степень всех вышин
были максимум единичка
Ну понятно для этих вышин ничего не поменялось, у них как была степень один так и осталось степень один
на ровно по одному либо про посчитания их из них исходит
А для этих вышин была степень ноль, а теперь осталось степень один
первые и последние не совпадают, сейчас, секунду, да, да, наверное, это правильное
замечание, в общем случае, да, если у нас граф не обязательно двудольный, то есть
в двудольной все равно такого не будет, вот, но давайте добавим, да, действительно, что
наш путь простой, так, где это было, простой путь, простой, значит, в частности, в нем все
ребра совершенно различны, я вот так сделаю, ну вот, значит, давайте запишу, что все ребра,
не лежавшие в М, добавляем в М, все ребра, лежавшие в М, и, наоборот, оттуда удаляем,
удаляем из М, получим просочетание большего размера, получим просочетание большего размера,
вот, такой простой наблюдение, что если einem есть такой вот увеличивающий путь, то можно сделать
чередование и, собственно, ответ, увеличить размер просочек, работает ли это в обратную
сторону, то есть правда ли, что достаточно искать только такие увеличивающие пути, чтобы всегда
находить максимальное просчитание, оказывается, да, и наш алгоритм, собственно, ровно так и будет
работать, он будет пытаться находить такие увеличивающие пути, пока они есть, если хотя
обоин есть, то он делает чередование вдоль него
и пытается найти опять.
Если в какой-то момент он не смог найти ни одного
такого пути, значит он завершается наше просчитание максимально.
Корректность этого — это теорема Бержа.
Она утверждает следующее, что в графе G просчитание
максимально, если и только если относительно него
нету увеличивающих путей.
В графе G просочетание M максимально, если и только
если относительно него нету увеличивающих путей
в том самом понимании, как в определении.
Скажите, пожалуйста, в каком из двух сторон мы уже
это утверждение доказали.
Да, слева направо, что если оно максимально, то нету
увеличивающих, потому что если бы были, то можно было
бы увеличить.
Это вот мы здесь доказали.
Если M максимально, но есть увеличивающий путь, то
можно выполнить чередование и получить просоч большего
размера противоречия.
То после чередования будет просочетание большего
размера.
Большего размера противоречия, мы предположили, что M максимально
получили еще больше.
Вот, а обратную сторону чуть похитрее, тут нам придется
повозиться.
И начнем из такой леммы.
Пропроизвольный граф, здесь на самом деле мы нигде в
удовольствии не будем пользоваться, я это еще отдельно отмечу.
Лемма такая, пусть у нас есть некоторый ориентированный,
не ориентированный граф, в той степени вершин, в
котором не больше, чем два.
Тогда, как он выглядит, он выглядит как объединение
путей и циклов.
Лемма, пусть H неориентированный граф, в той степени вершин,
в котором не происходят двойки, либо 0, либо 1, либо
2.
Тогда, любая компонента связанности графа H, это
либо путь, либо цикл.
Ну, доказательство очень простое.
Значит, давайте сначала избавимся от вершин к степени
0.
Если в графе H есть вершины степени 0, то это просто
такие изолированные точечки, которые ни с кем не соединены,
но можно считать, что это отдельные компоненты связанности,
скажем, пути длины 0.
Окей.
Удалили все вершины степени 0.
Вершины степени 0, но это изолированные, мы их просто
удаляем.
Это компоненты пути длины 0.
Дальше, пусть есть вершины степени 1.
Ну, давайте какой-нибудь из них посмотрим.
Здесь вершиновые степени 1.
Степени 1.
Значит, из нее исходит ровно одно ребро.
Ну, вот куда-то оно исходит.
Какой-то другой вершин.
Если это вершины степени 1, то это компоненты связанности.
Есть две вершины, они соединены, больше никаких ребер из них
нет.
Если это степени 1, то больше ничего здесь нет.
Это ребро, это отдельный компонент связанности,
больше, оно ни с кем не соединено.
Если степень 2, то соответственно из этой вершинки кто-то еще
исходит.
Есть такое второе ребро.
Отлично.
От этого то есть не ледущие в эту вершину.
Ну вот куда-то сюда оно ведет.
И то же самое.
Если у этой вершинки степень 1, то значит, мы целиком
нарисовали эту компоненту связанности, потому что
больше никаких ребер, исходящих из этих вершин, нету.
Поэтому это отдельная компонента.
Иначе, если степень 2, то из нее исходит опять какое-то ребро, причем не отвержается обязательно в новую вершину, потому что никуда назад, скажем, вот сюда вот,
оно вести не могло, потому что тогда вот в этой вершине степень бы увеличилась. Вот сюда не может вести ребро, потому что здесь была бы тогда степень 2.
На все обязательно новая вершина. Ну и опять, если тут 1, то это конец, да, конец компонент связанности.
Если степень 2, то обязательно новая вершина должна быть.
Вот, и так, понятное дело, бесконечно долго мы идти не можем, обязательно мы рано или поздно дойдем до вершины степени 1.
Вот вам, пожалуйста, компонент связанности и путь.
Значит, тем самым мы избавились от всех вершин степени 1 или 0.
0 отдельно, если начали в 1, то закончили в 1 и отпустили путь, да, компонент, который является путем.
Значит, теперь остались только вершины степени 2, давайте рассмотрим какую-нибудь из них.
Вот здесь вершина степени 2.
Из нее есть хоть два ребра, давайте рассмотрим какую-нибудь одну из них.
Ну, дальше тоже самый аргумент, если это вершина степени 2, то значит есть какое-то ребро из нее, либо, ну, сюда оно вести не может, значит, куда-то в какую-то новую вершину.
Это опять вершина степени 2, 1 ребро уже учтено, значит, либо это куда-то ребро в новую вершину, либо куда-то в одну из старых, но давайте пока что в новую.
Значит, и так мы будем идти, идти, идти в какой-то момент.
Второе ребро из очередной вершины будет вести уже в одну из посещенных, но тогда она обязательно идет именно в начальную вершину, потому что иначе у нас была бы вершина степени 3.
Если бы очередное ребро вело было в одну из посещенных, кроме начальной, то у меня была бы вершина степени 3.
Поэтому единственный момент, когда мой вот этот путь может зациклиться, только когда я возвращаюсь в стартовую вершину.
Тем самым я получил вот такой цикл, с вершиной на нем имеют в степени ровно 2, поэтому это отдельная компонента.
Ну, кажется, все.
То есть, если мы начинаем с вершины степени 1, то мы откушаем путь, если с вершины степени 2 и при этом с вершины степени 1 уже откушены, то это обязательно цикл.
Ну, все.
Согласны?
Так, зачем нам эта лимба?
Ну, продолжим вот это доказательство справа-налево.
Предполагаем противное, то есть, что есть какое-то прощание m, относительно которого нет увеличивающих путей, но при этом оно не максимально.
Пусть m не максимально.
Но относительно него нет увеличивающих путей.
Ну окей, если m не максимально, давайте рассмотрим какое-то максимальное.
Пусть m' максимальное прощание.
Пусть m' максимальное прощание.
Мы знаем, что его мощность точно больше, чем m, по предположению.
Раз m не максимально, а m' максимальное, то есть такое неравенство на размеры этих множеств.
Вот, и я рассмотрю такой граф.
Значит, если у меня g это было ve, то я рассмотрю h, v запятая m, симметрическая разность m'.
Здесь симметрическая разность, если у меня есть два множества, то симметрическая разность, вот этот треугольничек, это все, что попадает ровно в одно из них.
Я оставлю только такие ребра, которые входят ровно в одно из двух по рассчитания, либо только в m, либо только в m', но не в оба одновременно.
Те, которые лежали и там, и там, то есть, например, какое-то ребро могло быть взято и в m, и в m'.
Вот такие я не включаю в h, такие я удаляю, потому что они лежат в этом пересечении, я их не включаю в h.
Так вот, тогда h удовлетворяет условию леммы.
В нем каждая вершина, очевидно, имеет степень не больше, чем 2.
Ну, потому что, скажем, сколько может быть ребер инцидентных в какой-то вершине из графа h?
Вот есть какая-то вершина, какие ребра из нее могут торчать?
Ну, понятное дело, максимум одно ребро из m и максимум одно ребро из m'.
Значит, его степень не больше, чем 2.
Для любой вершины степень с индексом h от v, то есть в графе h, не больше, чем 2.
Ну, потому что, еще раз, у каждой вершины v я оставляю только ребра, лежащие либо в m, либо в m',
поэтому максимум какая может быть у нее степень?
Это одно ребро отсюда, одно ребро отсюда, не может быть два ребра, скажем, из m,
потому что из вершины не может торчать два ребра из одного по расчетанию.
Если это оба из m, то это не по расчетанию.
Значит, максимум одно ребро из m, одно ребро из m', значит, степень максимум 2.
Поэтому h распадается на пути циклы.
Там каждый компонент это путь или цикл.
H распадается на пути цикла.
Хорошо.
Давайте докажем, что среди этих компонентов нет ни одного цикла нищенной длины.
Так, ну как может выглядеть цикл нищетной длины?
Вот есть какая-то вершина в H.
И исходящая степень 2.
Есть какие-то два ребра, которые из нее торчат.
Что вообще значит, что из вершины есть два ребра в графе H?
Это значит, что одно из них пришло из M, а другое из M'.
Мы понимаем, что из каждого прочитания могло прийти максимум одно ребро, потому что иначе было бы не прочитание.
Значит, одно из них скажем из M, другое из M'.
Это вот так однозначно можно определить, какое откуда.
Дальше. Ну вот следующая вершина.
Мы понимаем, что у нее опять степень 2.
Раз это цикл, то у всех вершин степень 2.
Одно ребро обязано из M прийти, другое из M'.
Ну значит, вот как-то так мы должны продолжить наш цикл.
Следующая вершинка.
У нее одно ребро из M', второе должно быть из M.
Для этого одно из M, другое из M', ну и так далее.
Короче, у меня происходит чередование того, откуда пришло очередное ребро.
Из M, из M', M', и так далее, и так далее.
Ну понятно, что если у меня есть чередование, то у меня не может быть нечетная длина.
Например, если у меня вот есть вот это как бы цикл...
Ладно, раз, два, три, четыре, пять.
Вот из цикла длины 5, давайте чередовать.
M, M', M', M'.
Противоречие.
Не может быть два ребра, которые в одной вершинке встречаются.
Итак, вот всегда, если у меня есть нечетная длина цикла,
и я пытаюсь чередовать M' и M', то у меня обязательно в этой первой вершинке будет противоречие.
Вот.
Так, ну даже не знаю, что здесь записать.
Значит, тут главное, что будут чередоваться...
Значит, M', откуда пришли ребра?
А что? Очередное ребро, значит, приходит из нового прочитания.
Сначала M', потом M', и так по циклу.
Хорошо, значит, нечетных циклов нет.
Кстати, игра вот здесь, можно было бы сразу сказать, что почему нету циклов нечетной длины.
Если бы мы жили в двудольном графе, то это было бы сразу очевидно,
потому что одна из характеристик двудольного графа, это что в нем нет циклов нечетной длины.
Поэтому если бы я в условии теоремы сразу говорил, что граф же двудольный,
то это можно бы не доказывать, потому что H очевидно это под граф G,
потому что там остаются только какие-то ребра графа G.
Значит, циклов нечетной длины там ниоткуда взяться не могли.
Вот, поэтому в случае двудольного графа этот случай можно даже не рассматривать.
Хорошо. Мы поняли, что нету циклов нечетной длины.
Значит, что у нас остается? У нас остаются циклы чётной длины,
пути чётной длины
и пути нечётной длины.
Так, идея следующая. Смотрите, понятное дело, что каждый цикл чётной длины
и каждый путь чётной длины, они вносят поровну ребер из M и M штрих.
Потому что, опять, на них та же самая идея работает.
Там чередуется то, откуда приходит каждое ребро.
Если первое ребро из M, то второе обязательно из M штрих, третье из M и так далее.
Значит, каждый цикл и путь вносят поровну ребер из M и M штрих.
Но поскольку мы же поняли, что M штрих больше чем M,
значит, я утверждаю, что обязательно должен быть хотя бы один нечётный путь,
на котором ребер из M штрих больше чем ребер из M.
Ну потому что, ещё раз, вот эти вот товарищи вносят поровну ребер из M и M штриха.
А этот, соответственно, какого-то, ну что больше, либо M штрих, либо M.
Но при условии, что M штрих больше чем M, да, у меня, понятно,
должно быть хотя бы один цикл, хотя бы один путь нечётной длины,
на котором M штрихов больше чем M.
Значит, он как-то вот так вот выглядит.
M штрих, M, M штрих, M, M штрих. Вот что-то такое.
Тогда утверждаю, что вот этот путь, который я нашёл,
компонента связанности в графе H, вот с таким свойством,
она на самом деле является увеличивающим путём относительно M, который мы искали.
Докажем, что этот путь, он на самом деле увеличивающий относительно M.
Если это верно, то вы пришли к противоречию,
потому что мы изначально предположили, что M не максимально,
но путей относительно него увеличивающих нету.
А вот сейчас мы его явно построили.
Так, ну тут всё просто.
Значит, почему это увеличивающий путь?
Ну, вспоминаем определение.
У нас, во-первых, первые и последние вершины должны быть,
ну это понятно, простой путь, потому что это компонент связанности.
Дальше.
Первые и последние вершины должны быть ненасыщены
по расширениям M.
Это надо проверить.
Почему они ненасыщены по расширениям M?
Ещё нужно проверить, что у меня чередуются типы ребер.
Что сначала должно идти ребро не из M, потом ребро из M.
Не из M, из M, не из M.
Ну, это чередование, очевидно, есть,
потому что каждое второе ребро лежит в M,
а все остальные лежат в M штрих и при этом лежат в H.
Значит, точно в M они не лежат.
Потому что если какое-то ребро из M штрих пришло в H,
значит в M оно не лежало.
Мы помним, что в H у нас есть только ребра,
ну, лежащие в одном из двух прочитаний,
и если в M штрих, то не в M.
Поэтому с чередованием всё хорошо.
Значит, давайте отметим, что типы ребер действительно чередуются так, как нам нужно.
Так, как нам нужно.
И надо ещё проверить, что первые и последние вершины,
они не насыщены прочитанием.
Почему первые и последние
не насыщены?
Ну, давайте
схематически нарешим, вот это наш путь.
Если бы эта вершина была насыщена прочитанием M,
что это значит?
Значит, что из неё торчит какое-то ребро M.
Но, извините, значит мы знаем, что вот это было甚麼 ребро из M штрих.
Это ребро из M.
Значит, тогда в частности это ребр О должно было быть войти в H,
потому что это ребро точно не лежит в M штрих,
потому что иначе M штрих было бы не по прочитаниям,
поэтому это ребро, на самом деле, обязанно было бы лежать в H.
Значит, тогда мы неправильно нашли компоненту связности.
Ну, мы компоненту связностью нашли так, что большинских ребер
quantity M interactiveamura
так называют их coldன.
никаких ребер инцидентных в какой-либо вершине отсюда
нету. А если есть какое-то такое ребро, значит, соответственно,
есть ребро, которое инцидентно относится к вершине. Поэтому
таких ребер быть не может, значит, первые и последние
вершины не насыщены в m. Если насыщены, то в h не учли
в какой-то ребро. Ну, то есть, как бы мы там неправильно
построили h, это противоречит тому, что мы делали до этого
момента. Так, вопросы? Ну, значит, мы все доказали.
Мы доказали, что если у нас исходно было m, относительно
которого нету увеличивших путей, то он обязательно
максимально, потому что если было побольше, то мы
бы нашли увеличивший путь. Отлично. И теперь с использованием
этого, этой теоремы мы можем написать основную идею алгоритма,
как мы будем искать максимальное прочитание в графе. Значит,
алгоритм такой. Изначально говорим, что m – это пустое
множество. А дальше, пока относительно m есть увеличивший
путь, находим его и выполняем чередование. Пока в g есть
увеличивший путь относительно m, мы выполняем чередование
вдоль этого пути. И в момент, когда мы не сможем больше
найти увеличивший путь, значит, мы нашли максимальное
прочитание, что и требовалось. Так, ну теперь как это алгоритм
реализовать? Значит, конкретная реализация – это алгоритм
куна. Давайте считать, что у меня теперь g двудольный.
То есть, на самом деле, до этого момента рассуждения
они были применены к любому графу, мы нигде двудольность
не пользовались. А теперь будем ее активно пользоваться.
Значит, смотрите, я буду считать, что у меня вот такой
какой-то граф, левая доля, правая доля. Значит, дальше
для удобства я нумерую все вершинки левой доли независимо
номерами 0, 1 и так далее, и справа у меня будет номера
0, 1 и так далее. То есть, вот здесь скажем, будут номера
от 0 до n-1, а здесь 0 до k-1. И дальше я заведу как обычно
вектор-векторов. Для каждой вершины левой доли храню
список вершин из правой доли, с кем она соединена.
То есть, я по сути буду по графу только слева направо
ходить, поэтому мне нужны только для каждой вершины
левой доли список вершин из соседей справа, а в обратную
сторону не нужно. Значит, g только для вершины левой
доли определено. Ну, дальше вспомогательный массив
меток у меня будет used размера n. И вектор еще match, я его
назову размера k. Ну, used понятно, мы будем делать что-то
наподобие DFS, потому что понятно, что нам надо искать
пути, это мы будем делать чем-то наподобие DFS. Нам
нужны какие-то пометки для вершин. А match – это для
каждой вершины правой доли мы будем сохранять, с кем
она в данный момент в просчитании находится. То есть, для каждой
вершины правой доли мы запоминаем либо номер вершины
слева, с кем она сейчас находится в просчитании, с кем она
соединяя ребром в просчитании, либо минус один, если она
ни с кем не соединяя. Я тут еще раз подаду указ, означает,
что это определено для правой доли, и мы храним, собственно,
с кем она в просчитании, с кем она match-ится. Либо
с вершинкой левой доли, либо с минус 1, если она ни
с кем не соединяя. Окей, тогда вот такая процедурка
у нас будет первая. Процедура поиска увеличивающего пути
и augment, от слова увеличение, расширение. Процедура
такая, принимается на вершину и пытается найти увеличивающий
путь, который бы начался в вершинке В. Давайте мы
скажем, что юст у меня true для тех вершинок, для которых
я уже пытался это сделать, и у меня не получилось,
поэтому надо не пытаться заново. Если юст от В, тогда
return false. Что если я уже из этой вершинки пытался
и пытаюсь еще раз, то у меня ничего не получится.
Иначе мы помечаем ее использованной. Юст от В равно true. А дальше
следующее. Мы проходимся по всем ее соседям, которые
напоминают, лежат в правой доле нашего графа. По всем
вершинам смежным В, которые лежат в правой доле, мы
сделаем следующее. Смотрите, здесь следующая идея. Вот
у меня есть В слева, и есть какая-то true, с ней соединена
ребром справа. Значит, тогда, если match от true это минус
и единица, то есть по сути, Т не насыщенна по рассчитаниям.
Если она ни с кем в паре не стоит, тогда мы по сути
уже нашли увеличивающий путь. То есть, как будет
работать Augment? Он будет ходить по графу. Так мне не хватает.
Сейчас давайте я восстановлю какой-нибудь увеличивающий
путь. Значит, он выглядит вот так всегда. Вот, как
будет работать Augment? Он встал сюда, попытался пойти сюда-сюда-сюда-сюда-сюда,
и вот в момент, когда он может закончиться в ненасыщенной
вершинке, он говорит, ага, я нашел, я закончил увеличивающий
путь вот этим ребром. Поэтому мы сразу говорим, что мы
закончили поиск увеличивающих пути, мы его нашли, соответственно,
надо будет вернуть true. Но еще при этом мы можем сразу
положить, что match от этой вершинки последней равно
вот этому V, потому что я все равно потом выполняю
чередование и, соответственно, могу сразу сказать, что
это ребро лежит в парсочи. То есть, в случае, когда
match от true это минус и единичка, я напишу, что match от true это
V и return true. То есть, я закончил поиск увеличивающих
пути, он удался, и при этом я сразу выполняю чередование.
То есть, augment, он не только разрешает true или false, нашел
или не нашел увеличивший путь, но еще и выполняет
чередование вдоль этого пути, если нашел. Соответственно,
вот на последнем шаге мне нужно будет просто это
ребро назначить в парсочи. Но есть еще второй случай,
когда true была необязательно не посещенной, то есть,
она, возможно, с кем-то была в паре, вот, например,
как здесь. Мы начали отсюда, перешли вершину, которая
в паре стоит, то есть, она насыщена. Тогда мне нужно
просто запустить augment вот отсюда, если он успешен,
то есть, я, по сути, прохожусь по этому ребру, запускаю
augment отсюда, и если он успешен, значит, я смог найти увеличивший
путь. То есть, тогда здесь будет такой код, что если
match от true равно минус 1. Так, давайте все-таки на
другую доску перейду, мне тут не поместится.
Если эта вершина не насыщена или насыщена, но я могу
augment от ее, как бы, смежной вершинки от нее запуститься,
и он будет успешен, то есть, вот этот augment вернет true,
тогда нужно сделать вот это преобразование. Match
от true равно v, и return true. Ну а в конце, если у меня
ничего не получилось, то нужно сделать return false.
Итак, давайте еще раз пройдемся, что мы здесь делаем. Augment
для вершины левой доли. Пытается как бы найти продолжение
увеличившего пути, которое бы начиналось в, и соответственно
вот так вот ходило слева направо справа налево,
вот так чередуясь по ребрам из порсочи и не из порсочи,
и которое бы заканчивалось в вершине не насыщенной
вот здесь справа. Итак, есть два случая. Либо мы сразу
из вершинки v видим ее соседа справа, вершинку true, которая
не насыщена по рассчитаниям. Это случай вот этот последний,
когда вот здесь v, а здесь true. Тогда все очень просто.
Значит, раз мы до v дошли, то мы как-то вот так шли
чередуясь, и теперь можем закончить этот путь переходом
в не насыщенную вершинку true. Тогда мы это просто делаем.
Заодно выполняем чередование, и вот это ребро добавляем
в порсочистание, и возвращаем true. То есть что мы сделали,
собственно, это, ну, нашли увеличивший путь. И дальше,
когда у меня рекурсия эта раскроется, соответственно,
я выполнил вот это чередование и вернул true.
Для этой вершинки, когда я запустился рекурсивно,
пройдя вот такой пудленый 2 от v, у меня вершинка v
вернет true, augment от v вернет true. Значит, я сделаю
чередование еще от этой вершинки, у меня будет вот
это ребро добавлено в порсочи, а это, соответственно,
удалено. То же самое для этого. Я запустился из этой
вершинки, ну, то есть когда был здесь, запустился отсюда,
тогда я выполняю опять чередование для этой вершины,
и вот это ребро добавляю, а это удаляется из порсочи.
То есть тем самым при разворачивании курс у меня как раз
все чередование произойдет.
Вот, значит, это первый случай, когда из v есть просто ребро
вненасущенную true. Ну, а если по-другому, да, если match
at 2 не минус 1, она с кем-то соединена, то я могу просто
рекурсивно запустить с аугументом вот этого самого
конца, то есть вот скажем здесь v, здесь true, тогда вот
это вот match at 2.
Тогда вот это match at 2. Я отсюда запускаюсь рекурсивно.
Если я смог рекурсивно найти продолжение, увеличивший
пути, вот какое-то такое, то я соответственно говорю,
что окей, я нашел весь увеличивший путь, выполняю
чередование вот этой участки, что это ребро переключаю
сюда, ну и вывышаю true.
Вот, если же я ничего такого не нашел, то есть после вот
этого цикла по 2 я должен вернуть false как знак того,
что я не смог найти такой путь.
Так, вопросы?
Ладно, значит вот такая процедура, которая пытается
найти увеличивший путь из вершинки.
Дальше в мейне, ну или там собственно, там короче,
как это запускать?
Во-первых, мы делаем used assign n false.
Во-вторых, мы делаем match assign k-1.
Для каждой вершины правой доли она изначально ни
с кем не соединена.
Ну и наконец, в-третьих, мы проходим по всем вершинам
левой доли, по всем вершинам левой доли и пытаемся запустить
augment.
И если он успешен, если augment от v успешен, то есть мы
попытались найти увеличивший путь и нашли и сделали
чередование, то давайте сбросим меточки used.
Used assign опять n false.
Все, весь код на доске.
Значит, как это работает?
Ну смотрите, у нас вот есть изначально наш граф, изначально
нет никакого прощания, прощание пустое, и все вершины
левой доли у меня отмечены unused, неиспользованные.
Теперь я иду по вершинкам v слева направо, в смысле в порядке
возрастания номеров в левой доле, и пытаюсь сделать
augment.
Значит, вот пусть какой-то augment завершился неуспешно,
то есть я попытался запустить augment, но он равен false, и
тогда, соответственно, условия не срабатывают.
Вот пусть augment равен false.
Значит, я в текущем графе попробовал найти увеличивший
путь, но не смог.
При этом, понятно, делал какие-то вершинки, там я
отметил used.
Везде, где я побывал, они все отмечены used.
Это значит, что я попытался из них найти, но не смог.
Поэтому, понятное дело, что до тех пор, пока парасочетание
не перестроится, нет смысла эти пометки сбрасывать,
нет смысла опять пытаться запускать augment из них,
потому что я уже когда-то запускал, граф до этого
момента не перестроился, значит, эти метки, значит,
что от них можно не запускаться заново.
И только если какой-то там последующий augment вот отсюда
завершился успешно и перестроил парасочетание, то есть
у меня, ну, по сути, изменились мэтчи в том вот алгоритме,
в том augmentе.
Только в этом случае есть смысл все пометки сбросить.
Граф перестроился, мэтчи изменились, значит, у меня
возможно появились какие-то новые увеличившие пути,
использующие какие-то из этих предыдущих фишин, которые
раньше были помещены плохими.
Только в этом случае есть смысл сбросить все эти метки.
Иначе, повторюсь, граф не менялся, мы когда-то не смогли,
значит, мы никогда не сможем, пока граф не изменится,
пока, собственно, парасоч не изменится.
Так, вот.
Получается симптотика такая,
симптотика такая,
величина ответа на n плюс m.
Значит, величина ответа это, собственно, размер парасоча,
который мы ищем, размер максимального парасчитания,
число ребер в нем.
Ну, а n плюс m — это время работы ДФСа,
потому что, собственно, между двумя
соседними успешными агументами
от каждой вершины я, по сути, запущусь максимум один раз.
Ну, точнее, каждый ребро просмотрится максимум один раз
из-за как раз этих меточек, которые я не снимаю.
То есть, соответственно, суммарно вот столько раз
рассмотреться за каждой вершиной и каждое ребро.
Поэтому симптотика такая.
Да.
Да, это хороший вопрос, мы сейчас его докажем.
Если кинчу вопросы.
Хорошо.
Значит, да, действительно, здесь есть одна небольшая тонкость.
Потому что вспомним, как работал наш алгоритм,
здесь на псевдокоде написанный.
Пока есть увеличущий путь найти и сделать чередование.
Вот вопрос.
Почему, когда мы один раз всего лишь проходим по всем вершинам
в порядке разрастания номеров,
почему все увеличущие пути мы найдем?
То есть нет смысла несколько раз в этот цикл, грубо говоря, запустить.
Или, например, если мы нашли augment.v,
то почему мы не сбрасываем v опять до нуля?
То есть мы нашли какой-то путь.
Давайте опять его с нуля попытаемся найти.
То есть почему вот здесь мы там не пишем, скажем,
v равно минус 1, чтобы вот отсюда оно было опять нулю равно.
Вот почему.
Так, пусть
не существует
увеличивающего пути
начинающегося
в некой поверхности x
относительно некоторого прочитания m.
Пусть m'
получено из m
чередование
вдоль какого-то увеличившего пути.
Так вот, тогда
не существует увеличивающего пути начинающегося в x
относительно m'.
То есть это как раз ответ на тот самый вопрос,
что если мы когда-то попытались из x найти путь
относительно m, а потом m перестроили,
то заново из x нет смысла искать этот самый увеличивающий путь.
Только из других вышинок.
Тогда не существует
увеличивающего пути
начинающегося в x
относительно m'.
И если мы это докажем,
то мы целиком докажем корректность нашего алгоритма.
Потому что вот там, да, если у меня, скажем, какой-то,
то есть если вот было v
и у меня augment от v провалился,
то есть равен false,
тогда это значит, что мы попытались из v найти
увеличивающий путь, но не смогли.
Но тогда в дальнейшем нет смысла опять вызывать
augment от этой самой вершинки v,
а как раз вот там v равно x.
Вот, значит, просто достаточно один раз прочесть по всем вершинкам,
то запускать augmente,
и, собственно, это будет, да,
мы все увеличивающие пути найдем, все какие могли быть.
Так, ну доказательства тут следующие.
Пусть m' получается из m,
чередование вдоль какого-то конкретного пути.
Но давайте я его нарисую.
Пусть это будет вершинки a и b.
m' получается из m,
чередование вдоль вот этого пути.
Тогда, значит, как выглядит x?
Вспоминаем, что из x-а нет
увеличивших путей, которые бы...
ну, увеличивших путей относительно m,
но давайте от противного, да,
доказательства от противного,
пусть из x-а нет
увеличивших путей относительно m,
но появились относительно m-şтрих,
то есть раньше не было, теперь есть.
Так вот как они могут выглядеть?
Как может выглядеть увеличивающий путь из x-а
относительно m-штрих?
Ну, понятно, что он должен как-то этот путь
пересекать, потому что я этот путь
никак не взаимодействуют с путем из А в Б, то, ну, собственно, все остальные ребра, как бы, типы ребра не поменялись, те, которые были в М, они остались в М штрих, и наоборот, то есть если бы этот путь был хоть такой, то, собственно, он был бы путем относительно М, потому что на эти ребра никак этот путь не влияет.
Значит, обязательно вот этот путь относительно М штрих, он как-то пересекается с путем А в Б.
Ну, как-то пересекается. Давайте рассмотрим первую вершинку пересечения.
Вот как-то он так идет, например.
Ну, вот я что-нибудь такое нарисую.
Вот пусть П это первая вершина на том самом увеличивающем пути относительно М штрих, которая лежит на пути А в Б.
Первая вершина увеличивающей пути.
Ну, тогда отсюда можно построить на самом деле увеличивающий путь относительно сталого пересечения М.
Потому что, смотрите, в такой картинке я могу рассмотреть путь из Х в А вот такой.
Значит, почему он будет хороший?
Я утверждаю, что это тогда будет увеличивающий путь относительно М.
Тогда мы, собственно, придем к противоречию, потому что мы предположили, что относительно М нет таких путей.
Значит, почему это увеличивающий путь относительно М?
Надо доказать, что эти вершинки ненасыщены относительно М, и что типы ребр чередуются.
И что типы ребр чередуются.
Но что типы ребр чередуются, это очевидно, потому что вот здесь вот на этом как бы префиксе пути, на начале пути,
ребра, лежащие в М, это то же самое, что ребра, лежащие в М штрих, потому что вне пути А Б у меня ничего не поменялось.
Это плохая, кстати, картинка, это не может лежать в М.
Я перерисую, извините.
Вот так.
Пр ate тысяче штрихов.
Раз это был увеличивающий путь относительно м штрих, то первое результат не лежало в м штрих, значит, не лежало в м.
Следующее лежало в м штрих, то есть лежит в М, то опять лежит в М.
А дальше, потому что вне пути А Б, у меня М равно м штрих.
Изменения происходят только вдоль этого пути, значит, здесь происходит чередование.
Я иду в ту сторону, так что бы здесь летать было, чтобы чередование было, потому что тут у меня типы ребра чередовались из m м штрих и из м м штрих и так далее.
здесь происходит опять то самое чередование, что у нас, как раз, каждый второй ровень лежит в m.
Так, ну и наконец, соответственно, первая и последняя вершины не насыщены прочитанием m,
потому что a не насыщена, поскольку ab это увеличивающий путь относительно m, и x тоже не насыщена,
потому что она вообще не насыщена относительно m', то есть даже большего прочитания мы не
насыщены, значит, тем более мы не насыщены относительно меньшего прочитания m. Значит,
все выполняется, мы нашли увеличивающий путь относительно m противоречия. Вот второй случай,
когда вот это вот последнее ребро, ну тут нужна вторая картинка, два ребра из m в p ведут.
Good question, сейчас, момент. Невозможно, да. Да, хорошее замечание, действительно,
то есть на самом деле такого быть не может, давайте перерисуем картинку правильно.
Картинка тогда такая. Вот это вот будет p, а здесь вот тот самый путь ab. Да, действительно,
то есть вот этого быть не может, потому что у меня бы тогда вершинка p сойдет над
двум ребром по расчетанию m, что невозможно, поэтому обязательно картинка какая-то такая,
что вот это последнее ребро не лежит в m. Ну значит, наоборот, мне нужно было бы идти,
ну то есть здесь в зависимости от того, где у p лежит ребро справа или слева, то есть, возможно,
мы там могли бы вот сюда идти, тогда нам нужно было бы идти в a. Если мы сюда, то нам нужно идти в b.
В общем, в любом случае нам нужно идти в одну из двух сторон, чтобы получить чередующийся путь.
Вот, значит, если из x есть увеличащий путь относительно m штрих, то соответственно мы
построили увеличащий путь относительно m противоречия.
Да, да. Ну давайте поразбираем, да. Значит, мог ли x прийти в a или в b? В принципе,
мог, ничего бы не мешало. А почему? Ну вот смотрите, вот если у меня была такая картинка,
что бы в этом плохого? Ну так нам не надо, мы просто до нее доходим и все. Ну то есть,
как бы мы из b идем в b, пустой путь. Так, в случае, если x равно a или x равно b, быть не может,
потому что а и b становятся насыщенными относительно прощания m штрих. Поэтому
не может быть не из a, не из b опять увеличивающий путь относительно m штрих. Потому,
что они уже насыщены относительно m штрих. Почему x не может лежать на пути? То же самое,
потому что после чередования все вершины на этом пути становятся насыщенными относительно m
штрих потому что ну то есть когда сделать чередование у меня будет вот
такой вот m штрих то есть каждой вершины этого пути инцидентно ну ребру из m
штрих поэтому не все насыщено
еще раз
смотрите здесь пунктирные и сплошные это все относительно м значит
пунктирные не лежащие в М есть сплошные это лежащие в m, пунктирные не лежащие в m
чем обличается m и m-штрих только тем что вот на этом пути меняются пунктирные
и сплошные то есть вот эти вот становится в м штрихе
это становится Не в м штрихе а в остальных местах то есть везде кроме
этого пути у меня не меняются ну как бы сплошные и пунктирные относительно м
мшрих то же самое поэтому если х лизжит вм persistentinteractive вне пути то
не на пути АВ, значит М штрих и М это одно и то же вне этого пути.
Ещё?
Сейчас, ещё раз. Почему Х не может лежать на АВ?
Почему Х не может лежать на АВ? Потому что в прочесании М штрих все вершины на
этом пути насыщены. Вы про типа то, когда я следующие
прочесания беру. Смотрите, этого не нужно. Мы доказали, что если Х один раз не
лежит, то нет пути из Х относительно М, то на следующем шаге тоже не лежит.
Значит, на следующем после следующего тоже не лежит. Если вместо М взять М
штрих, вместо М штрих и М2 штриха, то получится то, что это все
корректно. Мы доказали, что если на одном шаге мы запустили агмент от
вершины, и он не успешен, то на следующем шаге его опять нет смысла запускать.
То есть нет увеличения в пути относительно М штрих. Но тогда, если нет
относительно пути относительно М штрих, то нету относительно М2 штриха.
Нет, нет, нет, нет. Мы это не использовали. Мы предположили противное. То есть есть
увеличивший путь. Значит, он обязательно сам по себе не использованный.
Так, дальше идем.
Вот, значит, повторюсь, такой, не знаю, ну с точки зрения контестов, вот эти
доказательства, они по сути не очень полезны, потому что код укладывается, ну там
не знаю, в 30 строчек. Его можно просто переписать и сдавать задачу. То есть вот
это вот, это все, ну чтобы просто понять, почему это работает. Что в общем-то
для решения задач не всегда нужно.
Так, ну теперь последний фрагмент про вот максимально независимое и минимально
покрывающее множество.
Значит, определение пусть, у меня есть какой-то граф, тогда множество его вершин, ну
какой-то поднос, что ве называется независимым, называется независимым, если
никакие две вершины не соединены ребром.
Никакие две вершины этого множества не соединили ребром. То есть у нас было
похоже определение для клики, когда, наоборот, любые две вершины должны быть
соединили ребром графа. Тут, наоборот, каждые два ребра не соединили ребром
графа. Двоесть на определение,
если сколько-то граф, тогда множество его вершин называется вершинным покрытием,
называется вершинным покрытием.
Если каждое ребро графа, то есть любое ребро, хотя бы одним своим концом лежит в
с, если до любого ребра графа, либо у лежит в с, либо вы лежит в с, ну хотя бы одно из них.
То есть это такое множество вершин, что каждое ребро хотя бы одним концом лежит в этом самом множестве с.
Например, какой-нибудь нарисуем,
ну, какой-нибудь такой граф. Какое тут можно выбрать независимое множество? Ну, например,
вот эти три вершинки можно взять. Вот эти три вершины выделены образуют независимое множество,
потому что между ними нет ребер, нет такого ребра, нет такого ребра, нет такого ребра.
Можно взять вот эти две вершины множество, рассмотреть вот эти две вершины, тогда они
образуют вершинное покрытие. Вот если я возьму эти две вершины, то действительно каждое ребро
хотя бы одним из концов лежит в этом квадратике, либо тут, либо тут. Это ребро лежит здесь в квадратике,
и это ребро здесь, это ребро вообще-то двумя концами
покрыто, это здесь, это здесь, это тоже здесь, а вот вершинное
покрытие у меня квадратики, кружочки, это независимое
множество. Ну и отсюда видно, давайте оставим это в
качестве упражнения, простое замечание, что вершинное
покрытие и независимое множество всегда дополняют
друг друга. То есть если у меня есть какое-то множество
I, скажем независимое множество, то тогда его дополнение V-I
это гарантированное вершинное покрытие. Ну и соответственно
наоборот, если есть какое-то множество, являющее вершиной
покрытием, то его дополнение это обязательно независимое
множество. Значит доказывается очень просто, если есть
какое-то независимое, значит внутри него нет ребер, то
есть все ребра либо вне него, либо одним концом только
в нём лежат. Значит как раз всё остальное это вершинное
покрытие. Вот, значит вспомним, я когда-то говорил, что задача
поиска клики максимальной в графе, она непрудная,
и у нас там был алгоритм за что типа два в степени
пополам, который по данному графу находил максимальную
клику. Вот, и ну там сильно быстрее чем какая-то экспонента
нельзя, то есть там можно бороться вот с этим показателем
экспоненты, но всё равно это будет сверхполинальный
время работы, больше чем там N в пятой, N в десятой.
Значит, ну тоже самое понятное дело должно быть для независимого
множества, потому что независимое множество от клики отличается
только тем, что я ребра заменил на антирёбра, на несуществующие
Поэтому понятное дело, что эта задача столь же сложная,
задача поиска максимального независимого множества,
столь же сложная, как задача поиска максимальной клики.
Но оказывается, что в двудольных графах, если мы будем рассматривать
непрозвольные, а только двудольные графы, эта задача
становится сильно проще. Значит, найдём максимальное,
по мощности, независимое множество, и минимальное,
опять-таки, по мощности, вершинное покрытие в двудольном графе.
Ну, вообще, часто такое бывает, что если в общем случае,
если граф произвольный или какой-то объект произвольный,
задача может быть трудной, не решаться за полином,
по крайней мере, в текущем человеческом знании. Но
вот если вы рассматриваете какие-то специфические
графы, какие-то специфические объекты, то в них уже эта
задача может как-то быстро решаться. Так вот, пусть
есть у меня двудольный граф G, я хочу найти в нём максимальное,
независимое множество и минимальное вершинное
покрытие. Вот G граф, двудольный, давайте скажем, что в нём
M это максимальное просчитание. Максимальное просчитание
в G. Дальше мы построим ориентированный граф. Строим ориентированный
граф D следующим образом. Начну множество вершин мы
оставляем, только мы ориентируем все ребра исходного графа.
Вот так. Рёбра из M ориентируем справа налево, ребра не
направо. Тоже давайте какой-нибудь пример нарисую. То есть у меня
есть такой граф, например, я могу взять вот такое просчитание,
максимальное, тогда его ребра я ориентирую справа
налево, подрисовываю стрелочки, а все остальные ориентирую
слева направо. То есть всё, ребра просчитания справа
налево, остальные слева направо. Далее запустим
обход D из всех ненасыщенных вершин левой доли. То есть
вот мы нашли максимальное просчитание, относительно
него какие-то вершинки насыщенные, какие-то ненасыщенные,
и вот мы запускаем обход только из ненасыщенных вершин
левой доли. Тогда у меня будет картинка такая. Давайте
я разобью множество вершин на четыре множества, обзову
их L+, L-, R+, R-. Это те вершинки, которые я посетил в процессе
обхода слева. Это те, которые я не посетил. Ну, плюсик
посетил, минусик не посетил. Дальше, это те, которые
я посетил в правой доле в процессе обхода, это те,
которые я не посетил в процессе обхода. То есть еще
от всех какой-то граф конкретный, вот я задаю его ориентацию
всех ребер, есть граф. Дальше, я выбираю все ненасыщенные
слева, запускаю обход. Ну, вот здесь вот это будет
единственное ненасыщенное, я запускаю обход. Все,
что из нее достижимо, там, вот какой-то такой путь,
все, что из нее достижимо, я помечаю плюсиками. Достижимый.
Соответственно, складываю в L+, R+, тех, которые я достиг.
Все остальные лежат в L-, R+.
Так и вот тогда, алгоритм такой, L+, в объединении с R-,
это максимально независимое множество, а L- в объединении
с R+, это минимальное вершинное покрытие, минимальное вершинное
покрытие.
Ну, и так, если это не доказывать, то алгоритм очень простой.
Нашли максимальное просчитание, ориентировали ребра графа
правильным образом, слева направо и справа налево,
так как нужно. Затем запустили обход, ну, какой-нибудь там,
DFS, BFS, что угодно, главное обойти все, что достижимо.
Разбили все вершины на четыре группки и сказали, что
вот такое объединение это независимое, а вот такое
вершинное покрытие. Вот, осталось это доказать.
И на этом, собственно, еще раз. Ну, мы же в нее встали,
мы ее посетили, пометили посещенно, значит, L+, конечно.
Ну, смотрите еще раз, стартование обязательно одна, их может
быть несколько. От каждой непосещенной слева свой
обход. И все, что я хотя бы от одной посетил, я помечаю
плюсиками и кидаю либо в L+, либо в R+. Вот. Хорошо,
давайте мы вот в этом графе точно отметим ребра, которые
не могут быть в графе D. Ну, смотрите, понятно я, что
вот таких вот ребер и вот таких вот ребер не бывает.
То есть из L+, в R- и из R+, в L-, ребер точно быть не может.
Почему? Ну, конечно, да, если это отмечено плюсиком,
то, ну, поскольку мы запускаем обход типа DFS, мы должны были
бы пройти по такому ребру и ее отметить плюсиком.
Да, ну, вообще, не может быть ребра из посещенной в непосещенной.
Дальше, чтобы, например, доказать, что вот это вот,
это независимое множество, надо еще доказать нет обратных
ребер. Почему нет таких ребер? Но давайте подумаем, вообще
что значит, что ребро ведет справа налево? Это значит,
что это ребро по рассочетанию. Да, вспоминаем, что слева
направо у нас ребра не по рассочетанию, справа налево
ребра по рассочетанию. Значит, если такое ребро и есть,
это обязательно ребро просочетания, а вот это какое-то УВ и, соответственно, УВ это
ребро просочетания. Значит, в частности, У насыщено. У насыщено нашим просчитанием М. Но тогда,
извините, как мы могли попасть в У, если мы все обходы начинаем только из ненасыщенных? Вот
представьте, что мы как-то до У дошли, а начинались мы только в каких-то ненасыщенных,
то есть мы могли стартовать где-то здесь, как-то петляли по графу и дошли до У. Но понятно,
что дойти до У мы могли только через В, потому что единственное ребро, входящее в У, это вот это
самое ребро УВ. Никакое другое ребро в У не торчит, никакое другое ребро в У не смотрит.
Значит, чтобы попасть из ненасыщенной в У, мне нужно было пройти через это ребро. Значит, В
обязан должно было быть в Р+, на противоречие. Попасть в У из ненасыщенной можно только с помощью
л2 в У. Ну все, значит, если это так, и мы попали сюда, значит, мы должны были попасть сюда,
поэтому это должно быть в Р+. Хорошо, то есть мы как минимум уже доказали, что L+, в объединении с R-,
это независимое множество. Давайте посмотрим сюда. Ясно дело, что внутри L+, ребер нету,
потому что все вершины левой доли нет ребер внутри доли. Внутри R-, ребер тоже нету. И более того,
нет ребер ни с левой направо, ни с правой налево между ними. Мы это только что доказали. Значит,
независимое множество. И отсюда сразу следует, что дополнение к нашему множеству, то есть L- в объединении
с R+, это наоборот вершинное покрытие. Потому что дополнение к независимому всегда покрытие.
Значит, остается доказать, что это вот экстремальное множество, то есть то максимально независимое,
а то минимальное вершинное покрытие. Мы докажем, что L- в объединении с R+, это минимальное вершинное
покрытие. Значит, мы сделаем два этапа. Во-первых, мы докажем, что у нашего множества размер не
больше, чем размер просчитания, а во-вторых, мы покажем, что в произвольном графе размер
вершинного покрытия должен быть хотя бы размер максимального просчитания. Нет-нет,
просто количество ребер. Вспоминаем, M- это множество ребер. Размер множества – это просто
количество ребер в нем. В любом графе размер вершинного покрытия больше или
меньше равен размер максимального просчитания. Ну, если мы это докажем, то есть, что мы вообще
всегда покрыли должно быть хотя бы такой же мощности, как просчитания, как человечество в просчитании,
и при этом мы нашли какое-то покрытие размером не больше, чем по рассчитания. Ну, значит,
достигается равенство, и это, собственно, есть минимально возможное покрытие.
Так, первое. Ну, здесь следующее работает. Значит, в L- есть только насыщенные вершины.
В L- только насыщенные. Ну, понятно, потому что из ненасыщенных мы запускаем обход,
значит, мы их посещаем в процессе нашего DFS, и поэтому они все лежат в L+. Все ненасыщенные
здесь, значит, насыщенные могут быть только в L-. Во-вторых, в R+, тоже, только насыщенные.
Почему в R+, только насыщенные могут быть? Если в R- есть какая-то ненасыщенная, то на самом деле
у меня есть увеличивающий путь, потому что смотрите, что значит, что у меня какая-то в R+, есть
ненасыщенные вершины, пусть она ненасыщенная. Тогда это значит, что я мог стартовать в какой-то
ненасыщенной вершине левой доли, и в нашем графе D, как-то вот так вот ходя, закончиться могу
в опять ненасыщенной вершине правой доли. То есть, по сути, я нашел увеличивающий путь,
начинающийся и заканчивающийся в ненасыщенных вершинах. Ну, и поскольку я иду слева-направо,
справа-налево, каждый раз меняясь, ребро не есть по расчитанию, ребро есть по расчитанию,
чередуясь, то я, по сути, нахожу увеличивающий путь. А это противоречит тому, что наше исходное
расчетание максимально. Иначе есть увеличивающий путь, да, но это противоречит тому, что исходное
расчетание максимально, которое мы берем. Вот, ну, и наконец третье. Стоит заметить,
что для любого ребра просочетания не больше одной вершины УВ. Ну, короче, не больше, чем одна из них
лежит в этом самом L-минус в объединении с R+. Потому что если бы обе вершины какого-то
ребра просочетания лежали бы в L-минус в R+, L-минус в объединении с R+, значит у меня есть
какое-то такое ребро в графе, да, и в насыщенные вершины, в насыщенную, то есть оно справа-налево,
и при этом идет из R+, в L-минус, а мы доказываем, что таких не бывает. Значит, давайте напишем,
иначе было бы ребро R+, L-, а мы знаем, что из плюсиков в L-минус никогда ребро вести не может.
Итого, смотрите, что мы доказали. Мы доказали, что вот это множество, вот в этом, есть только
насыщенные вершины, но при этом каждое ребро просочетания привносит максимум одну вершину в
этом множество. Значит, размер этого множества не больше, чем размер просочетания. То есть,
каждое ребро отсюда, каждое ребро у V из просочетания M, привносит в моем множестве максимум одну
вершину. Не может две привносить, потому что мы доказали, что не больше чем одна лежит в множестве.
Значит, каждое ребро дает максимум сюда одну вершину, и при этом никаких других вершин тут нету,
все насыщенные обязательно. Что здесь могли быть только те вершины, которые прошли по рассчитаниям.
Значит, здесь вершины не больше, чем здесь ребер. Согласны? Так, ну первое доказали. Второе проще.
Нужно доказать, что в его графе размер высшинного покрытия хотя бы размер максимального просчитания.
Ну это просто, давайте рассмотрим произвольное максимальное просчитание. Мы знаем, что все эти
ребра не имеют общих концов. Значит, я должен взять хотя бы одну вершину из этого ребра в покрытие.
Чтобы покрыть ребро, мне нужно взять хотя бы один из концов по рассчитанию. Дальше, хотя бы одну из
них взять из этих двух, хотя бы одну из этих двух взять, хотя бы одну из этих двух взять. При
при этом все эти ребра не пересекаются, то есть я должен из каждого дву элемента взять хотя
бы одну вершину, и все ни另 не пересекаются. Значит, из каждого ребра надо взять хотя бы одну вершину.
Надо взять хотя бы одну вершину. Ну все, поэтому размер высшинного покрытия
вынужден быть хотя бы размер максимального
прочитания.
А первое вместе со вторым означает, что мы нашли
минимально возможное гипотетически душиное покрытие.
Минимальное душиное покрытие, и более того, его мощность
в точности равна мощности максимального прочитания.
Мощности М.
То есть, оно не больше и не меньше, мы доказали.
Значит, срочность равно.
Так, последнее, что скажу, это вот этот результат
называется серия Макьонига.
Мы ее доказали, и тем самым научились в вдвульном графе
находить максимально независимое и минимально покрывающее
множество.
Все, спасибо.
