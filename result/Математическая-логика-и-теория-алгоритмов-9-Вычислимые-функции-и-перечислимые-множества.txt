Мы продолжаем разговор о теории вычислимости. В прошлый раз мы поговорили про модели вычислений,
значит сегодня поговорим про вычислимые функции,
вычислимые функции, разрешимые и перечислимые множество.
В конце прошлого занятия я рассказывал про первые два понятия, про перечислимость,
ничего не было, но сегодня поговорим. Давайте вспомним, что такое вычислимая функция.
Вообще у нас все объекты, то что у нас конструктивные, то есть каким-то образом
кодируются битами, то есть они являются строками из нулей единиц, но также можно считать,
что это просто натуральные числа. Соответственно, наша функция отображает, например, битовые строки,
или двоичные слова еще можно говорить. В двоичные слова это частично определенная
функция. Что означает, что если может быть так, что функция определена и равна чему-то конкретному,
а может быть так, что функция не определена. Тогда определение вычислимости такое,
если существует алгоритм, ну или может говорить программа, может говорить машина,
существует алгоритм, который, получив на вход, который на входе х, делает следующее,
значит если f от x определена, то возвращает f от x за конечное время, проработав какое-то время,
может быть очень долгое, но конечное. А если f от x не определена, то алгоритм ничего не возвращает,
то есть не останавливается. Если f от x не определена, то не останавливается.
Тут есть тонкая разница между тем, чтобы ничего не возвратить, и тем, чтобы возвратить ничего.
Возвратить ничего можно понять так, что f от x это какое-то специальное значение ничего,
нул или пустое слово, или еще какое-нибудь специальное значение, которое означает, что нет ответа.
Но это не то же самое, что не остановиться и вообще ничего не возвратить.
Здесь важно именно, что машина не останавливается, и никакого ответа нет.
Вот, значит такие функции называются вычислимыми. Дальше легко понять, утверждение очень простое,
что не все функции вычислимые. Почему это так? Да просто из соображения мощности.
Всех функций континуум. Потому что, в общем, это обсуждали, что даже тех уже континуум,
где значение просто 0 или 1, но вообще тут счетное число аргументов, тут счетное число значений,
то есть получается счетная в степени счетная, это будет континуум. Всех функций континуум,
а вычислимых функций счетное множество. Почему? Ну просто потому что функция сдается алгоритмом,
то есть программой, а программа это конечная строка символов, а конечных строк, в отличие от
бесконечных, будет как раз счетное число. Но одна программа максимум для одной функции годится,
да еще на самом деле одну и ту же функцию, как правило, можно по-разному написать. Как правило,
это зависит немножко от вычислительной модели, но во всех нормальных моделях,
во всех нормальных языках программирования у меня есть такая вещь как комментария. В комментариях
можно писать все что угодно, это на работу программы не повлияет. Но даже и без комментариев,
как правило, можно одно и то же сделать кучу разных способов, но можно искусственным образом
разработать такие языки программирования, что там можно действительно все что угодно написать,
но ровно одним способом. Это довольно сложная теорема, мы ее не будем доказывать.
В общем, так или иначе, программ будет счетное число всех функций Continuum.
Что еще можно сказать про вычислимые функции? Есть такое утверждение, что композиция вычислимых
функций вычислима. То есть если f и g вычислимые, то там f от g от x вычислимо, если f и g вычислимо.
Ну и опять же, более-менее для всех обычных моделей это очевидно, потому что есть такая вещь,
как подпрограмма. То есть мы сначала пишем программу для функции g, а потом ее результат
подставляем в программу для функции f. В результате вычисляем f от g от x, и как раз если там что-то
не определено, если g от x не определено, то мы просто не получим результат, который сможем
подставить. Поэтому все вместе тоже будет неопределено. Если g от x определено, но f на этом
входе не определено, то же результат будет неопределен. Опять же, там для любых нормальных
языков, для машины тюринга можно вот так рассуждать. Для произвольной модели это будет уже не совсем так,
но тем не менее сама теория будет верна, потому что класс вычислимых не меняется от того, что мы
переходим к другой вычислительной модели. Поэтому всегда можно брать ту модель, которая для нас более
удобна. Хорошо, что еще можно тут сказать, но можно сказать, что могут быть еще функции
одних аргументов. Могут быть вычислимые функции от нескольких аргументов, например от двух
аргументов. Тут тоже возможны разные определения, как вообще определять, что такое функция от
нескольких аргументов вычислимая. Тут более-менее два подхода к определению. Первый подход это
закодировать пару аргументов или кортеж аргументов как один, как одну строку. Закодировать
пару или набор аргументов одной строкой.
Ну а если у нас аргумент это одна строка, то мы уже знаем, что такое вычислимые функции от него.
Конечно, кодировать должно быть никакое угодно, а такое, что мы по этому коду можем, опять же,
вычислимо выцепить каждый из аргументов. Но это, опять же, неудивительно, что такое кодирование есть,
и наоборот, скорее сложно описать кодирование, которое таким бы свойством не удовлетворяло.
Ну, в общем, можно делать по-разному, но можно даже сказать, что у нас же есть тандарт значения
со скобочками и запятой. Можно просто кодировать, скажем, ноль-двумя единицами,
с ноль-двумя нулями единицами, с двумя единицами запятую, как 0,1, или можно даже делать так.
Если мы пару кодируем, то можно в х биты удвоить, потом написать 0,1, а потом уже y напрямую написать.
Ну, давайте я напишу, например, если у нас вот так вот, значит, вот такая пара,
значит, можно ее, соответственно, закодировать вот так вот, значит, 1,1, 0,0, 1,1, 1,1, 0,0, потом 0,1 и потом 0,1,1.
Тут получается, что здесь удвоенные биты, дальше тут разделитель, и здесь, соответственно, второе слово.
Но это один из огромного количества разных способов кодирования, значит, тут это будет не объективно,
потому что если тут будут удвоенные, потом 1,0, то это никак не будет.
Но хотя мы считаем, что это тоже будет код того же самого, все равно объективно будет.
Вообще это будет не биекция, но можно что-нибудь другое придумать, чтобы была биекция.
Вот, значит, это один вариант, ну а другой вариант, это такое непосредственное определение,
например, у машины тьюринга аргументы написаны там через бланк.
Например, машина тьюринга, так, нет места, я напишу там q0, x, потом бланк и потом y.
Так, q1 только, да, я договорился, что начальное состояние q1, x.
Машина тьюринга начинает работу вот с такого входа, ну а дальше куда придет, туда придет,
должна бы вычислить f от x, y.
Ну хорошо, значит, ну и так может аргументов и больше быть.
Можно вообще считать, что у нас, например, машина тьюринга с несколькими лентами,
и у нас там на первой ленте написан x, на второй y.
В общем, куча есть разных вариантов, можно любой из них использовать.
Так.
Хорошо, ну и соответственно получается, что и такие функции можно подставлять вот в это утверждение
о вычислимой композиции, ну и будут получаться разные функции.
Ну и будут получаться разные теоремы, типа, что сумма вычислимых, вычислимо,
произведение вычислимых, конъюнкция вычислимых, вычислима, ну и так далее.
В общем, всякие стандартные логические функции будут вычислимыми,
поэтому их можно применять к вычислимым.
Получается, что следствие, значит, следствие,
наш там, сумма вычислимых, сумма вычислимых функций,
вычислима, произведение вычислимых функций, вычислима, ну и так далее.
Так, хорошо, про вычислимые функции пока это более-менее все, что я хочу сказать.
И перейдем к разрешимым множествам, значит, если нет вопросов.
Так, хорошо, значит, у нас есть множество А,
значит, А у нас вложено в, например, то же самое множество слов из нулей единиц.
Так, значит, это разрешимая
множество, значит, если...
Если существует
Разрешимое множество, значит, если, если существует алгоритм,
значит, такой, что на входе х, на входе х, соответственно, он возвращает один,
если х лежит в а, значит, и 0, если х не принадлежит а. Вот, значит,
можно сказать, что это эквивалентно, значит, эквивалентно тому, что вот такая вот функция
характеристическая. Функция ха от х, которая равняется единице, если х принадлежит а,
и 0, если х не принадлежит а, вычислимо. Ну, это фактически то же самое, но другими словами.
То есть мы говорим, что этот алгоритм не просто 1 на 0 возвращает, а он вычисляет функцию,
которые те самые значения. Так, ну и дальше с разрешимым множествами та же самая история про мощность,
что всех множеств в континуум, а разрешимых счетное число, потому что всех алгоритм в счетное число.
Соответственно, получаем теорему, там тоже утверждение, что не все множества разрешимы.
Так, что еще можно сказать? Ну, еще из нашей теоремы о композиции получается такое следствие,
что если а и b разрешимы, то тогда пересечение а и b, объединение а и b, дополнение к а,
ну и так же на самом деле декартовое произведение, они все тоже разрешимы.
Ну и все это делается совершенно одинаковым образом, путем композиции каких-то логических функций,
которые очевидно вычислимы, и характеристических функций. То есть, например, можно писать так,
что характеристическая функция от пересечения на входе х, это будет произведение одной характеристической функции
на другую характеристическую функцию. Значит, это у нас вычислимо по предположению, это вычислимо,
произведение тоже вычислимо. Ну а, например, у декартового произведения на входе х и у,
значит, тут будет характеристическая функция ха от х умножить на хб от у.
Тут мы предполагаем, особенно если мы вот эту парадигму используем,
если два аргумента, то означает, что мы как-то кодируем пару, то тут еще подспудно используется то,
что функция проекции вычислима, то есть мы из пары х и у получаем отдельно х и отдельно у.
Конечно, нужно такое кодирование пар использовать, при котором такая функция будет вычислима.
Ну и еще похожее утверждение, что если а и b разрешимы, то тогда их конкатинация,
а также итерация звездок линия тоже разрешимы. Ну а это из чего следует?
Ну, это следует из того, что у нас есть конечное число, пусть нам нужно понять, какое это слово лежит в конкатинации или нет,
но если в нем n символов, то есть n плюс один способ разбить его на два слова,
и дальше, соответственно, для каждого разбиения нужно проверить, что первое половин лежит ва, а второе лежит в б.
И если хотя бы для одного разбиения это будет верно, значит это в конкатинации лежит.
То есть с иными словами можно писать так, что z принадлежит конкатинации a на b.
Тогда я только тогда... А сейчас слушайте, давайте я лучше других термах напишу.
Так, других термах я через характеристическую функцию.
Характеристическая функция конкатинации от z, это дизъюнкция по всем i получается от 0 до n.
Тут будет хиа от z с индексами от 1 до i, и хиб с индексами z от i плюс 1, и так далее, n.
Соответственно, если i равно 0, то вот эта часть будет пустой, а вот эта всем словом z,
а если, наоборот, i равно n, то вот это будет всем словом z, а вот это будет пустым.
А иначе мы каким-то образом разрезаем z на две части.
Ну и тут видно, что тут тоже такая чуть более сложная, но композиция вычинимых функций.
Так, ладно, киньте вопросы.
Ну, да, значит, на самом деле аналогично можно еще поступить с множеством нейтральных чисел.
Вот еще такое утверждение, что если A и B это разрешимые под множество натуральных чисел,
то тогда вот такое множество A плюс B, это еще сумма Минковского называется,
значит, A плюс B это множество всевозможных попарных сумм,
х плюс у таких, что х лежит в А, а у лежит в Б.
Значит, такая штука тоже разрешима.
Ну и доказывается это примерно таким же способом.
То есть есть его, значит, если у нас число там n, то есть n плюс 1 способ его представить,
как сумма двух натуральных чисел, включая ноль.
И для каждого из этого конечного множества способов нужно проверить, что первый слагаемый лежит в А,
второй лежит в B, и если, соответственно, обе проверки выполнены хоть для какого-то разбиения,
то, значит, итоговый ответ да, а иначе ответ нет.
Так, ничего, понятно?
Вот, но с другой стороны, смотрите, а что если, а что будет для разности?
Значит, для A минус B, который будет из всевозможных разностей х минус у, значит, таких, что х из А, а у из B.
Но вот тут такое рассуждение не пройдет, потому что будет бесконечное число способов представить одно число как разность двух натуральных.
Да, там 2, это будет и 2 минус 0, и 3 минус 1, и 4 минус 2, и так далее, бесконечное число вариантов.
Значит, тут получается, что конечного перебора может не хватить.
Ну, точнее, если мы найдем пример, то тогда ответ будет точно да.
А вот если мы перебрали какое-то число вариантов и пример не нашли, то это еще не значит, что его нет.
Мы просто недостаточно перебрали.
Если подходящий пример есть, то его можно найти.
А если нет, то, по крайней мере, в общем случае, неясно, как это доказать.
Ну и как раз вот это дает пример эффекта перечислимого множества.
Такие множества называются перечислимыми.
Ну, на самом деле, у свойств перечислимости есть несколько разных эквивалентных свойств.
Значит, они все друг другу эквивалентны, и для разных теорем удобно не применять разные из них.
Так что сейчас давайте я одно из них выберу в качестве базового определения,
а все остальные будут оказываться как теоремы, что они базовыми эквивалентны.
Базовое определение, мне кажется, должно быть то, из которого название берется перечислимость.
Базовое определение множества А называется перечислимым, если верно следующее.
Если существует алгоритм... так, я сначала напишу, потом прокомментирую, который печатает все элементы А и только их.
Что здесь имеется в виду?
Имеется в виду такой тип алгоритма, у которого есть нечто, что называется поток вывода, standard out.
В тернах машины тюринга можно представлять себе следующее.
Например, есть отдельная лента, и на эту ленту время от времени машина может напечатать 0,1 или пробел, который, понимается, как конец слова, но не может оттуда читать.
И стирать тоже не может, просто она время от времени на выход выдает биты и иногда говорит, что слово закончилось.
Тогда, когда она говорит, что слово закончилось, то считает, что она напечатала очередное слово.
И так она может работать бесконечно, и результат ее работы это будет не конечный ответ, а вот такая бесконечная последовательность отдельных слов.
И нужно, чтобы в этой бесконечной последовательности каждое слово из языка встречалось, а все остальные слова не из языка, не встречались.
Такое у нас требование.
Давайте я немножко обсужу, как это связано с тем, что было вот здесь.
Например, что можем делать? Мы можем по очереди про каждое число проверять, лежит ли оно в A, лежит ли оно в B.
И как только у нас появилось новое число из A, то для всех уже имеющихся из B мы выводим разность х-у, ну, наверное, те, где х больше либрайна у, чтобы натуральное число было.
Как только у нас опять появилось новое число из B, снова мы там для всех, которые уже есть из A...
Ну, можно сделать так, что мы по очереди про новое число сначала проверяем, что оно лежит в B.
Если оно лежит, то нам не нужно ничего добавлять, потому что все остальные из A были меньше.
А если у нас появилось новое число из A, то мы все разности вот этого нового числа и тех, которые уже есть из B, выводим.
Ну и так рано или поздно мы все эти разности напечатаем.
А все остальные числа не напечатаем.
Ну вот, поэтому это действительно связано с тем, что здесь было.
Сейчас, в общем, будет несколько эквариентных свойств.
Ну, если так дать, я одно успею написать, которое как раз связано с тем, что вот здесь написано, что если ответ да, то мы его можем найти и подтвердить.
Если ответ нет, то не можем.
Так, значит, эквивалентные свойства.
Так, ну вот это будет свойство 1.
Будет заключаться в том, что вычислимо полухарактеристическая функция.
Полухарактеристическая функция.
Кое-нибудь хи А с крышкой от х, которая равняется единице, если х принадлежит А.
И не определено, если х не принадлежит А.
Так, ну ладно, значит, наверное, продолжение после перерыва.
Так, давайте продолжать.
Так, хорошо, значит, какие еще будут эквалентные свойства?
Давайте, слушайте, я сначала для этого докажу.
Там у нас есть некоторая одна идея, которая там всюда фигурирует.
Я сначала ее покажу, а потом будем на нее смотреть в других вариантах.
Так, ну смотрите, как из перечислимости будет следовать вот это свойство 1?
Ну, просто запустим причисляющий алгоритм.
У нас есть на входе х. Запустим причисляющий алгоритм.
Я еще не сказал, у меня в прерыве спросили, что вообще у алгоритма должен быть вход,
но у перечисляющего алгоритма можно считать, что пустой вход.
Или какой угодно вход, он его игнорирует.
Просто он должен нам что-то напечатать.
Ну, тогда можно сделать так.
Как вычислить вот эту самую полухарактеристическую функцию от х?
Ну, просто запускаем перечисление и ждем, пока встретится х.
Если встретилось, выводим 1.
Значит, запускаем перечисление а.
Значит, если встретилось х, значит, печатаем 1.
Ну и тогда получается, что мы печатаем, печатаем.
Если там х есть, то есть если х лежит в а, то он в перечилении есть.
И тогда мы рано или поздно его найдем и напечатаем 1.
Если х нет в а, то тогда его там нет.
И мы будем ждать, ждать, ждать, никогда не дождемся.
И вообще это никогда не закончится.
То есть будет как раз неопределенность.
Ну, может быть, в принципе, еще вариант, что там множество конечное,
и перечисление просто закончилось.
На что? Все напечатало, все, и закончилось.
Но тогда чтобы все-таки остаться в рамках вот этого,
то есть остаться неопределенным,
то нужно просто войти в сетчан цикл, и тогда все будет нормально.
Так, это в одну сторону.
А вот в другую, есть некоторая сложность.
С чем сложность?
В том, что мы просто не можем взять и запустить вычисление вот этой функции
на каком-то входе.
Потому что там может быть неопределена.
Если мы будем ждать от нее ответа, она будет неопределена,
то мы, соответственно, никогда ни к чему другому перейти не сможем.
Типа того, да, конечно.
Что делает операционная система, когда у нее какая-то программа зацикливается?
Если операционная система нормально спроектирована, то она не должна в целом рушиться.
Если один процесс какой-то зацикливался, то все вместе не должно обрушиваться.
А за счет чего?
За счет того, что делает операционная система.
Она как-то организует работу разных процессов, дает одному поработать,
потом его приостанавливает, дает другому поработать,
его тоже приостанавливает, дает третьему поработать,
или потом к тому и вернется.
И, соответственно, тогда какой-то один процесс может и зациклиться,
и никогда не остановиться, но тем не менее система в целом
сохранит работоспособность, и какие-то другие параллельные процессы будут работать.
На этом принципе и нужно действовать.
По этому принципу и нужно действовать.
То есть как из вычислимости полухарактеристической функции сделать перечисление.
В общем, нужно действительно запускать поочередно.
Например, можно сделать такой цикл.
Значит, для k равно 1, 2, 3 и так далее до бесконечности.
Значит, запустить полухарактеристическую функцию там от нуля и так далее.
Полухарактеристическую функцию от k.
Тут k плюс 1 получился аргумент.
Значит, на k плюс 1 аргументе на k шагов.
Ну и напечатать те аргументы, на которых эти процессы успели закончиться.
Те аргументы, на которых вычисление закончилось.
Ну смотрите, у нас любые алгоритмы работают пошагово.
То есть есть какой-то элементарный шаг, их можно по очереди моделировать.
Например, сдвиг машины тюринга.
Эти шаги можно считать и можно предудительно прерывать процесс после того,
как он сделал определенное число шагов.
Тут получается такая картина.
Тут получается аргумент.
Тут получается число шагов.
Ну и тут получается как бы некоторая решетка.
На ноль шагов, давайте считать, что не будем запускать.
Соответственно, вот какая-то решетка.
Ну и получается, что для каждой точки этой решетки мы можем запустить вычисление
в этой точке на какое число шагов.
А дальше получается, что мы все эти вершины обходим.
Сначала мы вот так вот запускаем, потом вот так вот запускаем.
Потом вот так вот запускаем.
Что-то он тут стал плохо рисовать.
Ну и тогда, получается, что каждый раз у нас все на большем и большем числе аргументов, на большее и большее число шагов мы запускаем.
И тогда получается, что если у нас вообще, то есть если ха с крышкой от какого-то х останавливается за t шагов,
то тогда, соответственно, на шаге, так сейчас нехорошо то же самое, то же самое слово использовать.
Давайте на стадии, на стадии максимум из t и х, значит, на стадии максимум из t и х, соответственно, будет выведена, будет выведен х.
Значит, х будет выведен нам, потому что как раз на этой стадии, когда х равно вот этому, то тогда и х попадет в список аргументов,
и за t шагов, соответственно, вычленение закончилось. Ой, я тут как смешно написал.
Х попадется в список аргументов, и t уложится в лимитное число шагов.
И тогда, соответственно, учленение закончится, и поэтому х будет выведено.
Вот так. Ну чего, понятно? Это, в общем, более-менее самое важное рассуждение.
Нет, нет, нет, смотрите, потому что мы на t этом шаге мы запускаем только на аргументах от 0 до t.
А если х больше, чем t, тогда х не пойдет в список этих аргументов.
Но зато, когда до х дойдет, то там он даже быстрее, чем за х завершится.
Вот так, хорошо. Ну теперь другие эквалентные свойства.
Другие эквалентные свойства. Два, а это область определений вычислимой функции.
Три, а это область значений вычислимой функции.
Четыре, а пусто, или а это область значений всюдо определенной вычислимой функции.
Так, и пять. Ну, наверное, достаточно, можно еще несколько написать.
Да, мне кажется, самые важные вот эти вот пять.
Так, значит, что а это проекция разрешимого множества пар.
Б, что значит проекция? Значит, что а это множество таких х, что существует у такое, что пара х и у лежит в Б.
Чта Б разрешима.
Вот. Хорошо, значит, теперь как доказывается, что это все эквивалентно между собой.
Ну, тут, в общем, более-менее все не совсем по циклу доказывается.
Назад.
Так, значит, из первого во второе. Ну, это как раз очень легко.
Просто а это область определения полухарактеристической функции.
Соответственно, если полухарактеристическая функция вычислима, то а это область определения вычислимой функции.
Так, ну дальше из 1, из 1.3 получится, что а это область значений f от x, которые есть x умноженное на ха с крышкой от x.
Да, то есть это будет равняться x, если x принадлежит а, и не определено, значит, если x не принадлежит а.
Подожди, сюда определенно это у нас уже четвертое. Третье это просто вычислимая функция, а четвертое это всегда определённый.
Так. Хорошо, значит, четвертое можно по-разному делать.
Давайте четвертое напрямую из перечислимости. Покажем.
Значит, из перечислимости в четвертое. Значит, и тут разберём два случая.
Значит, когда а конечно и когда а бесконечно.
Значит, если а конечно, то, ну, например, можно по циклу выводить.
Да, значит, например, сейчас. Так, значит, а конечно есть вариант, когда а пустое, это у нас напрямую как вариант.
Значит, а равно пустое, значит, это явный вариант.
Да, то есть явно вот здесь написан вариант, что а пустое.
Значит, если а не пустое, значит, если размер а равен какому-то там s больше 0,
то тогда можно считать, что а это будет набор а1, а2 и так далее, аst.
Значит, набор zs элементов. И можно сделать просто такую функцию f от x.
Это будет а с индексом x по моделю s.
Так, только тогда лучше сдвинуть 0, 1 и так далее с минус 1, чтобы это прям остаток был.
Так, 0, 1 и так далее с минус 1. Вот, это действительно вот сюда определено.
Ну, а если а бесконечная, ну, оно на натуральных числах определено.
Вот, соответственно, если размер а бесконечный, то можно поступить по-другому.
Мы представляем, что f от k это просто kt числов перечисления.
И поскольку а бесконечно, то, соответственно, для любого kt числа встретится, и оно будет как раз в множестве.
Вот. Так, ну ладно.
Теперь что нам осталось? Там 5 осталось каким-то образом, но еще все в другую сторону.
Ну, на самом деле, удобно все эти 2, 3, 4 свести к пятому.
Ну, а кроме того, на самом деле, из четвертого, третьего, очевидно, следует.
Даже, да, потому что пустое множество будет областью значений нигде неопределенной функции, которая вычислима.
Да, а поскольку сюда определенные вычислимые являются, в частном случае, вычислимые, то значит, из четвертого, третьего следует.
Да, значит, давайте я напишу, что это, ну я тут позволю себе написать, что это очевидно.
Но все-таки тут, если вас спросят, то нужно так и рассказать, что в первом варианте это областье значений пустой функции,
а в втором варианте областье значений вот той самой, всю доопределенной.
Так, теперь, значит, я еще хочу показать из второго пятая, из третьего пятая и из пятого первого, и тогда уже все направления замкнутся.
Из второго пятая. Значит, пусть у нас А это область определения Ф.
Вот, но тогда можно все следующее, чтобы это будет, ну что пар Х, Т таких, что Ф от Х останавливается за не более чем Т шагов.
Вот, ну тогда действительно, да, значит, если, да, значит, там что нужно написать, что А это множество таких Х, что существует Т, что пара Х, Т лежит в В.
Ну действительно, если Ф от Х определено, то есть если Х лежит в А, то Ф от Х определено, тогда Ф от Х останавливается за какое-то число шагов.
Именно это число шагов нужно сюда подставить. Если Х не принадлежит А, то Ф от Х не определено.
Но тогда за какое число шагов оно не остановится, и поэтому сюда не попадет, вот.
А вот такое B будет разрешимым, потому что, раз это ограниченное число шагов,
то можно вот это число шагов провести и, соответственно, посмотреть, остановится или нет.
Так, ну и с третьего пятая более-менее аналогично, ну чуть-чуть по-другому.
Значит, если A это область значений f, то тогда можно писать так, что A это нож таких y,
что существует пара x и t, что, соответственно, тут, ну это не то же самое B будет,
и что f от x равно y, и f от x останавливается за не более чем t шагов.
Вот. И, соответственно, то, что написано после квантора, это тоже вычислимый предикат.
Но формально нужно сказать, что нужно сначала из пары x и t быть отдельно x, отдельно t,
потом проверить, что f от x останавливается за t шагов, и если останавливается,
то еще проверить, что f от x равно y. Вот. Если не останавливаться, то не надо ничего проверять.
Вот. Ну и осталось из пятого первое. Значит, из пятого первое получается следующим образом.
Опять же у нас x, то есть A это нож таких x, что существует такой y, что пара x и y лежит в B.
Вот. А вычислять полухарактеристическую функцию от x надо так. Мы просто перебираем всевозможные y
прям по очереди, по возрастанию. Значит, для y равно 0, 1, 2 и так далее.
Значит, проверяем, что пара x и y лежит в B. И если верно, возвращаем 1.
Тогда, если такой y есть, то мы до него дойдем в каком-то шаге. При этом важно, чтобы разрешим,
и поэтому каждая такая проверка завершится с ответом 1 или 0. Вот. Если x лежит в A,
тогда такой y есть, и тогда этот перебор до этого y рано или поздно дойдет, и поэтому вернем 1.
Вот. А если такого y нету, то тогда для каждого y вернется 0, и, соответственно,
никогда мы единицу не вернем, процесс никогда не остановится. Вот.
Так. Ну все. Получается, по крайней мере, для вот этих всех вариантов.
Инклонец не доказано. Может быть, на семинаре будет еще пара свойств. Да.
Нет, из четвертого мы третье вывели. Да. Из четвертого-третьего, да.
Потому что тут более частный случай в четвертом, чем в третьем.
Так. Ну дальше, на самом деле, все эти эквалентные свойства дают некоторый такой арсенал,
и разные теоремы, может быть, удобнее доказывать через разные свойства.
Ну, например, утверждение, что если A и B перечислимые,
то тогда пересечение A и B тоже перечислимо.
Значит, как это можно делать? Ну, например, через полухарактеристические функции,
можно писать, что полухарактеристическая функция пересечения, это будет произведение.
От X. Это произведение полухарактеристической функции A умножить на вот это вот.
И тут как раз все подходит друг к другу. Как раз если одно не определено,
то и произведение не определено, а только если оба равны единице, то произведение равно единице.
Ну, например, с объединением так не получится.
Потому что не получится так скомбинировать неопределенность хоть чем-нибудь, хоть как-то, чтобы получилась единица.
А для объединения это нужно. Ну, для объединения, например, можно делать так.
Например, через третья. Значит, если A и B перечислимы, то тогда объединение A и B перечислимо.
Ну, например, можно сказать так. Пусть A это область значений F, а B это область значений G.
Тогда объединение A и B это область значений H, которая определена таким образом.
Значит, такая, что H от 2n это будет F от n, а H от 2n плюс 1 это будет G от n.
Получается, что на четных входах H определена также как F, а на нечетных она также как G.
Ну и ясно, что значения там будут те, которые есть в F, те, которые есть в G, но никаких других не будет.
Ну, давайте еще один пример с пятым, с декартом произведения.
Значит, если A и B перечислимы, то тогда декарта произведения A на B перечислима.
Вот, значит, тогда тут получается, что, например, A это множество таких X, что существует Y, что пара X, Y лежит в C.
Значит, B это множество таких Z, что существует T, так что пара Z, T принадлежит D.
Так, ну и дальше так дать, я вот тут вот напишу.
Значит, тогда получается декарта произведения A на B это множество таких пар X, Z,
что существует Y, T так, что одновременно X, Y принадлежит C и Z, T принадлежит D.
Ну и, соответственно, вот эта вот строчка после квантора это на самом деле свойство пары X, Z и Y, T,
это уже разрешимо. То есть мы каждую из этих пар разбиваем на составляющие,
комбинируем их вот так вот и запускаем проверку для C, проверку для D.
То есть тоже получилось такого же рода выражения.
Ну вот, значит, это вот три примера, как разные утверждения можно использовать.
Понятно, что все эти утверждения можно и через другие свойства доказывать.
Тут довольно разнообразные могут быть приемы.
Так, ну и напоследок я поговорю про дополнение.
Потому что это вот то, что отличает перечислимый множество от разрешимых.
Значит, тут из перечислимости A не следует перечислимость A с чертой.
Вместо этого есть теорема Поста.
Теорема Поста такая, что A разрешима тогда и только тогда, когда A и A с чертой перечислимы.
Доказательства.
Так, доказательства, как это устроено.
Ну, смотрите, в одну сторону, значит, если A разрешима,
то тогда A с чертой разрешима.
Значит, отсюда следует, что A перечислима.
И отсюда следует, что A с чертой перечислима.
Да, это, кстати, я не обсудил, кажется, что из разрешимости следует перечислимость.
Ну, это, наверное, очевидное из определения с полухарактеристической функцией.
Откуда вот это вот?
Просто если ха вычислимо, то и ха с крышкой тоже вычислимо.
Просто мы заменяем 0 на неопределенность.
Заменяем 0 на неопределенность.
Вот, поэтому в эту сторону действительно все верно.
Ну а в другую сторону, значит, если A я с чертой перечислимая,
если A я с чертой перечислимая,
но интуитивно надо сказать так, что мы запустим параллельно
А и А с чертой и будем ждать, где х встретится раньше.
То есть у нас получается вход х.
Мы, соответственно, запускаем...
Ну, давайте так, значит, можно запускаем пошагово
полухарактеристическую функцию для A на входе х
и полухарактеристическую функцию для A с чертой на входе х.
И, соответственно, делаем шаг одной, шаг другой, шаг одной, шаг другой.
И, соответственно, если первая из них остановилась,
если первая из них остановилась, то тогда возвращаем единицу.
Если вторая остановилась, то тогда возвращаем ноль.
Ну а одна из них точно остановится.
Одна из них точно остановится за конечное время.
Почему? Потому что что-то одно то верно, либо х лежит в A, либо х лежит у вас чертой.
Если х лежит в A, то первая остановится, если у вас чертой, то вторая остановится.
Ну и, соответственно, если эта процедура остановится, выдаст правильный ответ.
Вот такое это рассуждение.
На следующей лекции мы изучим вопрос о том, что на самом деле бывают перечислимые,
но не разрешимые множества, и это то, что невозможно установить из соображений мощности.
Потому что перечислимых тоже счетное число, то есть нельзя сказать, что их больше, чем разрешимых.
Но, тем не менее, бывают перечислимые, но не разрешимые множества.
Это важнейшее достижение, с которого началась эта теория.
Это результат Тьюринга 1936 года, связан с проблемой остановки.
Вот к нему мы подойдем в следующий раз.
Все, спасибо за внимание.
