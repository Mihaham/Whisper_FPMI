Продолжаем про потоки говорить. Вот, и первое, первое оно такая, даже не то, что алгоритм,
скорее техника, ускорение времени работы. Это так называемая техника масштабирования.
Вот, идея такая. Давайте мы будем пытаться пускать поток какими-то большими порциями. Ну,
и эти порции будут у нас степенями двойки, и мы будем идти по ним сверху вниз. То есть,
сначала будем пытаться пустить поток какой-нибудь величины, не знаю, там 128,
потом все такие потоки пустили, какие могли, потом уменьшаем наши требования,
пытаемся искать поток величины 64. Ну и так далее, по всем степням двойки до 1, понятно,
что в конце, когда будем пытаться пускать поток длины 1, то у нас найдется, собственно,
максимальный поток воссташной сети. Ну, формально напишем примерно следующее. Пусть
какой-нибудь с большой, это верхнее ограничение на все capacity, верхнее ограничение на все пропускные
способности. Дальше. Для каждого АК в цикле от 26 логарифма С до 0, так, я думаю, куда округлить,
видимо к низу, потому что вверх это будет нулевая сеть. От 26 логарифма С до 0 мы делаем следующее.
Мы сначала переопределяем наши все capacity так, чтобы они были кратны 2 в степенька. То есть мы
уменьшаем все capacity до наибольшего числа, делящегося на 2 в степенька. Формально напишу так.
С-штрих от ребра Е это следующее. Остаточное capacity этого ребра, деленное на 2 вкатой и умноженное на 2 вкатой.
То есть СФ это сколько, какая остаточная capacity, сколько можно еще по нему протолкнуть. Дальше
деленное на 2 вкатой, берем целую часть вниз и умножаем на 2 вкатой. Это как раз в точности есть
наибольшее число, меньше либо равное вот этому, кратное 2 в степенька. То есть мы там что-то
отрезали и оставили только делящиеся на 2 в степенька. Ну и соответственно в графе с такими
capacity мы пускаем максимальный поток. Соответственно если у меня все ребра сейчас имеют capacity кратные
до 2 вкатой, то и поток будет делиться на 2 в степенька в этой сети. Находим максимальный поток,
потом переходим к следующему капросту. То есть вот в этой сети найти max поток. Найти max поток.
Ну и в конце все это просуммировать. То есть вот мы там много сетей строили, каждый раз меняются как-то
остаточные capacity, потому что я прибру какую-то часть потока пускаю и все эти потоки потом
суммирует и будет ответ. Ответ это сумма потоков по всем к. Вот такая идея. Корректность здесь
очевидна, потому что, ну то есть сначала мы делаем что-то странное. Мы как-то уменьшаем
наше capacity, там по степням 2 идем 2 вкатой, 2 вк-1 и так далее и так далее. Но главное,
что на последней итерации, когда k будет равно нулю, у меня c штрих будет просто совпадать с
c остаточным. Потому что если k равно нулю, то вот эта единичка и мы соответственно делим,
умножаем на единицу, ничего не меняется. Поэтому на последней итерации я ищу поток просто в
остаточной сети. Без всяких ограничений, что он должен делиться на степень 2, потому что степень
2 будет равна единице. Корректность следует просто опять из теоремы Форда Фалкерсона,
что мы в конце все равно рассматриваем остаточную сеть, и пока в ней есть путь из s в t,
мы проталкиваем поток. А время работы оказывается здесь будет такое. Время работы
можно оценить как e2 на лог c. Лог c это мы видим количество итераций, количество разных k,
и вот оказывается, что каждая итерация работает максимум за e2. Причем тут неважно,
какой алгоритм. Вот внутри каждой итерации, вот здесь, когда мы ищем max поток, внутри каждой
итерации пока, тут неважно, какой именно мы используем алгоритм, Форт Фалкерсона или Эдман
Скарпа. Здесь можно как Форт Фалкерсона написать, так и Эдман Скарпа. Это неважно,
симплотика будет все равно e2 лог c. Давайте это поймем. Почему время работы каждой итерации
это от e2. Для этого покажем следующее. Пусть f большое, это поток в исходной сети, настоящий
max поток. Давайте так напишем настоящий максимальный поток. А fкат это то, что мы нашли после ката
итерации. То, что мы нашли после ката итерации, то есть сумма потоков, которые мы упустили на
итерациях с номерами 0, 1 и так далее к. Суммарный поток на итерациях 0, 1 и так далее к. Так вот
тогда f настоящее не больше, чем f уже найденное, плюс 2 вкатой на e, где e это число ребер. То есть
вот мы делаем такое наше масштабирование, идем по степеням дворки от больших к меньшим и пусть
там после первых ка итерации мы нашли поток вылеченной fкат. Так вот тогда настоящий поток
отличается от вот этого вот найденного не больше, чем на 2 вкатой умножить на e. Почему это так? Ну
смотрите, давайте мы нарисуем остаточную сеть после вот этой ката итерации. Остаточная сеть
после ката итерации. Поскольку мы уже нашли максимальный поток на этой ката итерации,
то значит в остаточной сети у меня нет пути из s в t. Значит можно нарисовать как-то вот так
нашу остаточную сеть. Есть s маленькая, t маленькая, вот они. И между ними нет пути в этой
самоостаточной сети. Но что значит нет пути? Это значит, что все вот эти вот ребра имеют
остаточную capacity в терминах эссотного графа меньше, чем 2 вкатой. Потому что если бы здесь
была остаточная capacity хотя бы 2 вкатой, то значит это ребро имело бы, ну собственно, если бы тут
было хотя бы 2 вкатой, то значит и в этом графе у меня было бы это ребро с capacity 2 вкатой, соответственно
я мог бы, ну то есть это не все ребра здесь насыщенные. Мы знаем, что есть разрез, который пересекает
в общем только насыщенные ребра. Чтобы в общем поток был равен разрезу, мне нужно чтобы все эти
ребра были насыщенные. Ну вот, значит по этому ребру, на этом ребре остаточная capacity может быть
только меньше, чем 2 в степеника. Подпишем, что остаточная capacity меньше, чем 2 в степеника,
иначе ребро не насыщено. Вот, ну и все, а суммарно здесь ребер их максимум е, поэтому остаточная capacity у
них у всех максимум 2 вкатый умножить на е, значит, так сейчас, момент. Ну да, а собственно, то есть мы
нашли разрез величины не больше, чем 2 вкатый умножить на е. Значит есть разрез величины не
больше, чем 2 вкатый умножить на е. А мы знаем, что величина любого разреза это оценка сверху на
величину максимального потока. Поэтому то, сколько мне осталось протолкнуть потока для того, чтобы
найти максимальные из СВТ не больше, чем величина вот этого разреза, то есть не больше, чем вот столько.
Значит для того, чтобы найти истинное значение потока, к тому, что я уже нашел, нужно добавить не
больше, чем вот это. Ну все. Значит, остаточный поток меньше, чем 2 вкатый умножить на е. А это ровно то,
что написано в том утверждении. Окей? Так, ну отсюда следует сразу, что на каждой итерации, так,
сейчас скажу. В общем, что каждая итерация находит нам от е-путей. То есть пусть мы вот это, скажем,
знаем для нашего ака, рассмотрим каплю с первой итерации. Каплю с первой итерации. Ну там, что такое
работа внутри итерации? Это вот мы построили остаточную сеть с капастями кратными 2 в степени,
сейчас, 2 в степени log2c-k-1, ну что-то такое. То есть очередной степени двойки мы должны
быть кратны. Так, момент. У меня здесь, понял, я, нет. А вот здесь давайте исправлю. У меня итерации,
они как бы сверху вниз номируются, поэтому здесь итерации скорее от логарифма до к, вот так. И
соответственно, там тогда к-1 итерация, простите, к-1 итерация. Да, ну как бы я уменьшаю, поэтому если
там было k, то теперь к-1. В конце будет нулевая. Итак, я рассматриваю к-1 итерацию, то есть строю
сеть, в которой все капасити кратные 2 в степень k-1. Все капасити кратные 2 в степень k-1. Внутри
этой итерации происходит следующее. Скажем, алгоритм Форда Фалкерсона просто находит несколько
путей из СФТ. Каждый из них тоже, понятное дело, имеет хотя бы вот такую пропускную способность,
поэтому каждый путь, который мы нашли, мы по нему пускаем ну хотя бы столько потока.
Каждый найденный путь увеличивает поток хотя бы на 2 в степень k-1. Потому что раз все капасити
делятся на это, то значит любой путь проходит по ребрам не нулевого веса, поэтому у них все хотя
бы столько, значит и поток тоже хотя бы столько. Ну и тогда смотрите, а вот тут у меня написано,
что если вдруг я нашел на предыдущей итерации, какой был поток, то настоящий поток отличается от
него не больше, чем настолько. Но мы видим, что каждый путь, который мы находим на следующей
итерации, он хотя бы 2 в степень k-1. Значит, суммарно, вот этих штук я могу сделать максимум 2e.
Потому что если осталось мне 2 вкаты на e, и каждый путь это хотя бы 2 в k-1, то значит суммарно,
ну сколько сюда помещается 1-2 в k-1, ну ровно 2e. Значит, путей найдем не больше, чем 2e. Понятно,
откуда взялось? Хорошо, вот, значит каждая итерация находит максимум 2e путей. Ну а что
такое итерация? Это поиск увеличивающего пути, пока он есть. Если мы видим, что путей максимум 2e,
то тогда каждая итерация – это просто максимум 2e раз найти какой-то увеличивший путь из s в t,
что работает за линейное время. Что форт Фалкерсон – это просто dfs, что Эдман Скарп – это просто bfs.
Ну а поэтому вот это вот нужно умножить на время работы dfs или bfs, будет как раз e квадрат,
ну и мы получили время работы одной итерации e квадрат. Все, все доказали. Так, ну давайте
напишем, что время работы итерации есть от e, вот оно, сколько путей мы можем найти,
умножить на время работы dfs или bfs, что есть e квадрат, ну потому что здесь это как бы e
плюс v, суммарный вершин плюс ребер, здесь тоже суммарный вершин плюс ребер у нас была оценка,
но повторюсь, из этих двух слагаемых e зачастую больше, потому что иначе можно было в исходной
сети, представьте, что у нас там e сильно меньше, чем v, тогда давайте просто в исходной сети оставим
только вершины, достижимые из s, тогда у нас e и v сравняются, ну там с точностью 2 плюс минус 1,
и они будут одного порядка, поэтому можно будет всюду вместо v писать e. Ну все,
значит каждый тратится за квадрат, суммарный алгорифм, поэтому время работает такое. Ну и понятно,
что это может быть выгодно нам, например, если log c меньше, чем v, да, потому что у нас была
оценка на Эдман Скарпа вот такая, давайте я здесь восстановлю, Эдман Скарп работал за e квадрат v,
и соответственно, если мы вдруг знаем, что log c сильно меньше, чем v, то вот вам,
пожалуйста, алгоритм, который теоретически чуть быстрее работает, чем Эдман Скарп.
Окей, хорошо.
Так, теперь еще один алгоритм поиска максимального потока, это алгоритм Деница.
Пожалуйста, не говорите, что это алгоритм Деницы или что автора фамилия Деница. Автор вот такой,
чувак, поэтому, пожалуйста, говорите родительный падеж правильно, а то меня немножко бесит,
когда говорят Деницы или что-нибудь такое, вот, не надо так. Ну нам тут будут нужны опять
несколько определений. Определение. Сначала определим слоистую сеть. Слоистая сеть сети g,
это вот что такое. Ну, сеть, напоминаю, это у нас обычный граф с капаситами, где выделен две
вершинки s и t. Вот, давайте мы посчитаем кратчайшее расстояние от s до всех вершин и оставим
только ребра между слоями, то есть ребра между вершинками на расстоянии i и на расстоянии i
плюс 1. Давайте я нарисую картинку сначала. Значит, вот есть s, вершины на расстоянии 0,
затем есть какие-то вершины на расстоянии 1, я оставляю в них во все ребра. Есть вершины на
расстоянии 2, я оставляю ребра только между, ну, точнее, из первого слоя во второй, все обратно
удаляю. Есть вершины на расстоянии 3, опять оставляю только ребра из второго в третий,
ну и так далее. Где-то здесь там будет t, я оставляю ребра из предыдущего слоя в него. Ну,
формально тоже это давайте запишем. Значит, пусть v и это множество вершин на расстоянии ровно i от
s. Да, да, ребра неизвешенные, расстояние меряем, как будто они все имеют v с 1, ну, неизвешенные,
да. Собственно, так же, как у нас в Эдманскарпе, мы ищем короче расстояние по числу ребер просто,
невзвешенные расстояния. Итак, значит, v и это множество таких вершин v, что расстояние от
s до v равно i. Да, расстояние невзвешенное. Ну и, соответственно, ребра оставляем только из
этого v плюс 1 для каждого i. Оставляем ребра из v и v плюс 1 для каждого i. Ну, вот с теми
же капастями, которые были исходно в графе. Второе определение – это блокирующий поток.
Блокирующий поток в сети – это такой поток, который нельзя увеличить без введения обратных
ребер. Сейчас нарисую картинку.
Но мы знаем, что если как бы мы вводим обратные ребра, то любой поток можно расширить до максимального,
потому что появляются вот эти обратные ребра, с помощью которых можно отменять неправильно
потекший поток. И, собственно, любой поток можно увеличить до максимального, просто отменив то,
что мы сделали неправильно. А если мы не вводим вот эти обратные ребра, например,
например, картиночка наша любимая. Представьте, что
мы пустили вот такую неправильную днику потока, как мы это
часто можем делать. Этот поток блокирующий, потому
что чтобы его увеличить, мне необходимо вот эту
днику отменить. Если ее не отменять, то здесь нет
больше никакого пути из СВТ. Не вводя обратное ребро,
я не смогу найти больше никакой пути из СВТ. Ну,
собственно, это пример блокирующего потока. Если
мы не переходим к остаточной сети, а все еще живем в
этом исходном графе без обратного ребра, тогда вот
здесь вот как бы нет пути из СВТ, но только в исходном
графе, не в остаточной сети, а в исходном графе.
Вот, и тогда алгоритм Динец описывается очень просто.
Мы будем строить слоистую сеть по остаточной сети
и в ней находить блокирующий поток. И так столько раз,
пока, собственно, есть хотя бы один путь из СВТ.
Алгоритм Динец. Ну, пока не найден поток. Пока не найден
поток. Мы строим слоистую сеть и находим в ней блокирующий
поток. Находим в ней блокирующий поток. Все. Ну, и суммарно,
сколько потока мы протолкнули, это и есть ответ на задачу.
Вот, асимптотика будет лучше, чем в Эдманскарпе. У нас
будет сейчас В квадрат Е. Это мы сейчас будем доказывать.
Получается асимптотика В квадрат Е. То есть, по
сравнению с Эдманскарпом, мы квадрат скинули с числа
ребер на число вершин, но это, понятное дело, выгодно,
потому что зачастую вершин меньше, чем ребер. Мы перенесли
квадрат на число поменьше, тем самым, асимптотика
лучше. Так, ну хорошо. Чтобы это сделать, давайте, то
есть понятно, что алгоритм состоит из нескольких итераций.
Каждая итерация — это построение слоистой сети плюс поиск
блокирующего потока в этой самой слоистой сети. Давайте
тут я имею в виду, что сеть строится по остаточной
сети, по остаточной сети. То есть да, вот здесь,
когда еще блокируюший поток, я забываю вообще, что бывают
обратные ребра, мне просто дали граф, я не ввожу обратные
ребра, просто пускаю, блокирующий поток пока могу. Но, когда
мы строим слоистую сеть и, соответственно, переходим
между итерациями, мы не забываем, что мы решаем нормальную
задачу — у нас бывают обратные ребра, и они, соответственно,
нам нужны, чтобы сначала построить остаточную сеть,
по ней слоистую, и уже в ней шкальблокирующие. И
раз. Опять несколько итераций, столько раз, сколько встроим
слоистую сеть. Ну и вот давайте теперь разберемся, как
работать внутри одной итерации, как искать блокирующий
поток для данной сети. Поиск блокирующего потока
за VE. Блокируешь поток за VE. Так, сейчас будет алгоритм
во многом похожий на то, что мы делали с эйлеровыми
циклами. Идея такая, смотрите, вот есть какая-то вершина,
и я пытаюсь как бы протолкнуть из нее какой-то поток. Ну
не знаю, пусть в нее сколько-то потока пришло, какой-то
f. И я хочу этот поток максимально протолкнуть до конца, до
t. И соответственно из V есть какие-то ребра. Давайте
попробуем просто по первым поважься пройти и это f протолкнуть.
Какие бывают случаи? Бывают случаи, что это ребро, скажем,
плохое. Плохое в том смысле, что оно не лежит в слоистой
сети. То есть, я как бы мой граф не буду явно перестраивать,
не заводить новый инстанс графа, я буду по-прежнему
хранить всевозможные ребра, но только буду проверять,
а лежит это ребро в слоистой сети или нет. Это легко
проверить, нужно просто проверить, что эта вершина
лежит в слое с номером на 1 меньше чем это. То есть,
я ребра явно удалять не буду, чтобы построить слоистую
сеть. Я не буду явно удалять ребра, я буду просто, чтобы
проверить есть ребро или нет, проверять, что вот
эти вот вершины находятся на соседних уровнях. Итак,
я пытаюсь протокнуть F-потока, смотрю на ребро, если вижу,
что оно, скажем, не в слоистой сети, то я его просто игнорирую
и теперь буду рассматривать вот это. Дальше, пытаюсь
по нему протокнуть, а оно пусть в слоистой сети. Пытаюсь
протокнуть F-потока и как-нибудь рекурсивно пытаюсь найти
путь отсюда до T. И пусть у меня не получилось, пусть,
например, вообще из этой вершины, то и недостижимо.
Тогда понятно, что это ребро можно в каком-то смысле
удалить, то есть, можно игнорировать. Если мы не смогли найти
путь отсюда до T, то дальше никогда не сможем, если мы
ищем блокирующий поток. Поэтому это ребро можно как-бы
удалить и дальше рассматривать только вот это ребро.
Ну и, соответственно, аналогия здесь такая, мы для каждой
вершины просто храним поинтер какой-то, PTR от V, это номер
первого ребра, которое интересно рассматривать.
Соответственно, мы скипаем те ребра, которые не лежат
в слоистой сети или из конца которых недостижимо T, мы
их просто пропускаем, тем самым увеличивая PTR.
Ну и вот, соответственно, если отсюда мы нашли путь
до T, то значит, окей, там сколько потоку мы протолкнули,
PTR оставили здесь.
Ну все, давайте запишем, что PTR от V это номер первого
интересного ребра, я так напишу.
Интересного ребра из V.
Интересного, то есть, потенциально полезного, что из
него может быть, по нему точнее, вот по этому ребру мы
сможем потенциально что-то протолкнуть.
Если не можем, то сразу PTR увеличиваем, игнорируя это
ребро в дальнейшем.
Вот, тогда алгоритм будет следующий.
Так, ну мне лень придумать какое-нибудь оригинальное
название, поэтому я им им зву ДФС.
А еще он принимает вершину, и то вот, то самое F, сколько
потока я до нее смог довести.
Сколько я потока F смог довести от S до текущей вершинки
V.
Первая проверка, если V равно T, то я просто сделаю
return F.
Это значит, что я смог найти с помощью моего вот этого
какого-то обхода, с помощью какого-то ДФС, смог найти
путь из S до T величины F.
Ну вот давайте это значение и будет величиной, который
я возвращаю из рекурсии.
Сколько потока я протолкнул.
В моей сети, то есть тут будет F.
Вот иначе, это какая-то промежуточная вершина, и я
должен это F-поток куда-то передать.
Для этого сделаем следующее.
Пока PTRV меньше, чем GVTSIZE.
Так, ну G от V это как всегда у меня список ребер, торчащих
из V, а G от V всегда список ребер, которые из V исходят.
PTRV это номер ребра в этом списке.
Номер первого интересного ребра в этом списке.
Если у меня вдруг PTR сравнялась с размером, значит я все
ребра просмотрел, мне все ребра не интересны, поэтому
я больше ничего из этой вершинки сделать не могу.
Ну хорошо, тогда пусть E это ребро вот с этим вот
номером, то самое ребро, которое мне интересно.
Так, напишу так, ребро с номером PTR от V.
Писки GV.
Ну это вот то самое ребро, которое мне сейчас интересно.
Если оно не лежит в остаточной сети, ну точнее в слейской
сети, или скажем на нем нулевая капасти, то мы его
можем просто скипнуть и увеличить PTR на единичку.
Я напишу так, если level от V плюс один не равно level
от E.tu, да, E.tu это то, куда ведет мое ребро.
Давайте его нарисую из V.tu.
Ну просто в ту давайте напишем.
Если это ребро не из слейской сети, или оно насыщено, то
есть по нему ничего уже нельзя передать, или E.capacity
равно E.flow.
Вот, тогда можно просто сделать плюс плюс PTR V и
continue.
То есть мы как бы посмотрели на ребро, поняли, что на
самом деле тоже неинтересно, ну и скипаем его, просто
увеличиваем этот указатель на единичку.
Так, теперь содержательный случай, когда это ребро
из слейской сети и на нем не нулевая сетчаная
капасти, значит можно сколько-то протолкнуть, причем сколько?
Ну вот сколько.
Минимум из F и E.capacity минус E.flow.
Вот, то есть смотрите, у меня есть ребро, я понимаю,
что по нему можно протолкнуть максимум вот столько
потока, да, это вот та самая остаточная капасти, с
штрих, но при этом не больше чем F, да, не больше чем
это, не больше чем это, беру из них двух минимум.
Соответственно, пытаюсь протолкнуть вдоль этого
ребра столько потока, и этот поток, давайте сюда вернусь,
этот поток, начиная от 100, пытаюсь докинуть до T.
Я просто рекурсивно вызываю DFS 2, запятая вот, вот та
штука. И X это то, сколько потока я умудрился протолкнуть,
то есть по всему вот этому пути я протолкнул X-поток.
Ну, если X равно нулю, то получается я не смог ничего
сделать, нужно сделать плюс плюс ПТР от V.
И continue.
Иначе я нашел какой-то путь, и мне нужно не забыть,
что вот на этом ребре E, мне нужно проставить плюс X,
да, что я протолкнул X-поток.
Ну, я напишу так, E точка flow плюс равно X, а reverse E, reverse E flow
минус равно X.
То есть я по ребру проталкиваю X, значит по обратному, ну,
просто гарантированно должен протолкнуть минус X, reverse E
это обратное ребро.
Вот, и все, и возвращаю X как знак того, что я смог протолкнуть
ровно X-поток. Дальше, если у меня вайл закончился и мы
из него вышли, то значит мы ничего не нашли, просто делаем
return 0, return 0, конец.
Вопросы?
Хорошо, тогда последнее замечание, вот здесь скажу,
что reverse E можно делать опять так же, как когда мы искали
эйлера в цикл, у нас там прямое ребро и обратное всегда
имели номера противоположной четности и соседние, и они
тогда, если одно имело номер E, то второе имело номер E-41,
да, если мы просто каждый раз, когда какое-то ребро
добавляется в граф, мы сразу же добавляем ему противоположное,
то они всегда имеют, то противоположное всегда имеет
соседние номера, отличающиеся четностью последнего бита.
Добавили бро и сразу ему обратное, значит они в массиве
всех ребер всегда в соседние, и поэтому можно очень
легко извлечь его номер.
Ну вот, это поиск блокирующего потока в слоистой сети.
Теперь давайте покажем, что это работает за от VE.
Вот этот алгоритм, да, ну то есть как получается тогда
ищется блокирующий поток, блокирующий поток.
Ну давайте напишем wild true.
Совсем плохо напишем, но тем не менее, wild true.
Запускаем DFS от S с каким-то там, с бесконечной копастью,
то есть мы в S можем изначально, как бы, сколько год намного
потока передать, а X это то, сколько смогли пропустить.
То есть вот мы пытаемся из S протолкнуть сколько-то
потока, исходно сколько угодно, но получилось только
X.
Вот, ну и если X равно нулю, то нужно сделать break.
А иначе войти в цикл.
То есть просто пока можно, мы из S пытаемся найти какой-то
путь.
Находим, находим, находим, находим, пока у них у всех
поток больше нуля, который мы пустили, мы продолжаем
это делать.
Как только мы нашли, что нет ни одному такого пути,
то есть X равно нулю, то значит мы закончили, больше
пути нет.
И мы нашли блокирующий поток.
Вот, тогда утверждаю, что это работает за ОТВЕ.
Вот этот вайл суммарно работает за ОТВЕ.
Почему?
А потому что давайте скажем следующее.
Пусть в результате одного вот такого DFS-а у меня суммарно
все поинтеры увеличились на K.
Да, то есть напоминаю, у меня вот есть вот эти вот
строчки типа плюс плюс PTR от V.
Вот пусть суммарно в результате одного такого DFS-а все
поинтеры увеличились на K, суммарно на K.
Пусть все PTR в результате одного такого DFS-а увеличились
на K.
Так вот, тогда время работы этой итерации есть у ОТВ
плюс К.
Потому что смотрите, что такое K?
K-это то, сколько fees мы просмотрели и пометили
бесполезными.
То есть мы на них посмотрели, поняли, что дальше идти
нет смысла, и пометили как бы ну, использовоными
что больше их не рассматривают.
О-кей, но как тогда вообще работает этот DFS?
Это вот этот ДФС, я не знаю.
рассматривает.
Окей, но как тогда вообще работает вот этот ДФС?
Он в идеале находит какой-то путь из С в Т, длины не больше
чем В, и еще какие-то ребра рассматривает выше этого
пути, которые помечают бесполезными, которые помечают
пройденными, увеличивает с них ПТР, если ПТР был
тут, то увеличил сюда, потом сюда, то есть все эти ребра
пометил неиспользованными.
Поэтому вот это число, это просто то, насколько ребр
мы посмотрим.
Ка это то, сколько ребр мы посмотрели и пропустили,
а В это сколько ребр мы посмотрели и положили в
тот самый путь из С в Т.
Нет-нет, я имею ввиду суммар, вот смотрите, мы для каждой
вершинки увеличили ПТР и суммарные изменения на
К, поэтому здесь просто плюс К.
Ну вот, значит почему, потому что В плюс К это количество
просмотренных ребр.
Просмотренных ребр.
Вот.
Ну и все, а дальше, значит, как у нас работает алгоритм.
Пока есть путь из С в Т в нашей следствии сети, мы
пускаем ДФС, который работает вот за столько, надо понять
тогда, сколько суммарно будет работать все эти ДФСы.
Итак, ну вот эти К, сумма Кашек, она ограничена, видимо,
O от E, потому что суммарный ребр E, значит суммарно все
указатели могут завинуться максимум на E.
Суммарно вот эта вот сумма Кашек это максимум E, вот.
Ну а В что такое?
Ну собственно значит, а нет, не так.
Да.
И суммарно еще можно сказать, что итерация максимуму
O от E, потому что каждая итерация насекает хотя одно ребро.
Значит суммарно итерация будет максимум E и поэтому
симпатика будет VE плюс E, что максимально будет VE.
И так, вот этих напишем, суммарно таких итераций,
суммарно, ну не хочу писать слово итераций, но суммарное
количество запусков DFS есть от E, так как каждый такой
запуск насыщает хотя бы одно ребро, как работает
DFS.
Он что-то просматривает, находит какой-то путь из
SFT и пропускает по нему максимально возможный поток.
То есть, среди всех вот этих вот остаточных капаситей
он выбирает минимальное и пускает поток такой величины.
Значит, то самое ребро, которое было с минимальной
капаситей, он насыщается.
В общем, как всегда, нашли путь и хотя бы одно ребро
насытилось.
Так как хотя бы одно ребро насыщается.
Значит, DFS запускается от E раз, каждый запуск работает
вот за столько.
Значит, суммарное время работы вот этого всего
алгоритма поиска блокирующего потока есть от VE плюс сумма
кашек.
Точнее, насколько мы вот эти вот все кашки увеличили.
Насколько мы запустили после первого DFS, после второго
и так далее после этого.
Ну а это тоже понятно, есть от E, потому что, ну я проговорил
уже, потому что суммарное изменение указателей только
от E.
У каждой вершины есть там несколько ребер, сначала
ПТР здесь, потом здесь, потом здесь, потом здесь, потом
здесь, потом здесь.
Сумма изменения на максимум просто число ребер в графе.
Значит, это все есть то самое от VE.
Давайте.
Как?
Давайте подумаем.
Ну да, да, да.
Да, я понял.
Я понял, да.
Видимо, да.
Я пока, я пока.
Окей, я не готов сказать, что это.
Сейчас.
Ну похоже, да, я не вижу никаких проблем.
Единственное, что, возможно, там анализ был бы чуть сложнее
делать, потому что, ну это вот эти там суммарные изменения
указателей, не понятно, как считать.
Но вообще, да, действительно похоже, что можно вот эти
вот четыре строчки превратить просто в одну, запустить
такой DFS, который пытается, ну собственно, вот это сразу
и делает, пытается пустить сразу столько потока, сколько
может.
Пришел в вершину.
Сейчас, ну.
Сложно.
Мне не очень нравится, потому что, смотрите, вот не знаю,
как-нибудь вот пусть, пусть можно вот так вот дойти
до какой-то вершинки.
У меня, соответственно, DFS от нее запустится дважды,
пытаясь протокнуть вот этот поток и вот этот поток.
В принципе, мы тоже так делаем, да.
Ну ладно, похоже, но все равно непонятно, как это
анализировать, потому что тут тогда, то есть без вот
этих рассуждений непонятно, сколько раз мы вообще DFS
запустим от каждой вершины, как бы, на первый взгляд,
много.
Ну ладно.
Ну вот, смотрите, значит, мы что сделали?
Мы нашли какой-то алгоритм поиска блокирующего потока
за VE.
Теперь надо еще понять, что сколько суммарно раз нужно
будет найти блокирующий поток в слоистой сети.
Потому что динец, он много раз строит слоистую сеть
и в каждой из них ищет блокирующий поток.
Так вот, я утверждаю, что суммарно слоистых сетей мы построим
от V, тогда будет как раз асимботика V квадрат E.
Потому что, в общем-то, если мы будем строить слоистую
сеть, тогда будет как раз асимботика V квадрат E.
Потому что после выполнения вот этого вот поиска блокирующего
потока у меня увеличивается обязательно дистанс от
S до T.
Такое утверждение.
После проталкивания
блокирующего потока
в слоистой сети
в слоистой сети
имеем
ну, я так напишу, дист новая СТ
больше, чем дист старая
СТ.
То есть, вот если в этой слоистой сети
было такое-то расстояние между СТ, то после того, как я
ввел обратные ребра и перестроил слоистую сеть, то есть, я, по сути,
рассматриваю слоистую сеть между двумя соседними
итерациями. Вот здесь и следующую. Так вот, тогда дист
обязательно увеличится.
Дист в слоистой сети увеличивается между итерациями.
Ну, и поскольку он не может увеличиться больше, чем на V, значит,
итерация суммарна от V.
Доказательств. Ну, давайте опять нарисуем слоистую сеть.
А вот было у меня какое-то там
разбиение такое, скажем, в L.
И, соответственно, был путь от S до T длины L.
L и ребер.
Все пути имели длину L.
Теперь я, по сути, что сделал. Я нашел блокирующий поток в этой сети.
То есть, я в каком-то смысле все вот эти пути длины L
исчерпал. То есть, любой путь
содержит хотя бы одно насыщенное ребро.
Потому что иначе, если бы был путь
без насыщенных ребер, то я, соответственно, по нему я мог бы
протолкнуть хотя бы единичку потока.
То есть, все вот эти пути как бы исчерпаны.
Я больше не могу в этой сети ничего найти, поскольку найден блокирующий поток.
И я после этого перестраиваю слоистую сеть.
Хочу показать, что расстояние увеличится.
Но что вообще происходит, когда я ввожу такие обратные ребра?
Когда я все-таки строю обратные,
сори, остаточную сеть строю?
Ну, понятно, какие-то ребра исчезают, потому что они строятся насыщенными,
и к каким-то ребрам еще появляются обратные.
Потому что, если я пропустил поток по ребру, то обязательно
появляется обратная остаточная сеть.
Ну и, соответственно, что тогда может произойти с расстоянием,
если я удаляю какие-то ребра слева направо и добавляю какие-то ребра справа налево?
Ну, понятно, но никак не могло уменьшиться или остаться таким, как было.
Потому что, ну, как может, не знаю, пусть оно уменьшилось.
Пусть дистанция новая, меньше дистанция старая.
При этом, какие-то ребра слева направо я удалил,
и добавил какие-то ребра справа налево.
Ну, такого быть не может, потому что как может быть устроено,
как может быть устроен путь из СВТ меньше длины?
Значит, он должен как-то переходить по вот этим вот облачкам,
V1, V2 и так далее, VL в каком-то порядке.
При этом обязательно, если дистанция уменьшился,
то ему нужно было хотя бы один вот такое перепрыгивание сделать.
Не посетить хотя бы один из слоев.
То есть нужно было сделать переход между двумя не соседними слоями,
что невозможно в исходном графе.
У меня таких ребер через слой нету,
потому что иначе тогда это было бы...
Ну, если есть вот такое ребро,
то тогда вот эта вершина должна быть не в третьем слое, а во втором.
Значит, дистанция не мог уменьшиться.
Он также не мог остаться,
ну, потому что, собственно, мы сказали,
что все пути от S до T длины ровно L мы исчерпали,
и на каждом таком пути удалилось хотя бы одно ребро.
А вот эти вот обратные ребра справа налево,
они, конечно, не могут оставить путь такой длины.
То есть, возможно, теперь путь какой-то крошайший выглядит вот так.
Сначала сюда, то есть вот это могло удалиться,
потом пришлось идти сюда, и потом как-то вот так.
Только так мог наш новый путь выглядеть.
Мне, чтобы добраться до T, нужно было...
То есть все пути слева направо как бы исчерпаны,
значит, нужно хоть раз пойти назад,
использовать вот одно из обратных ребер.
Ну, значит, мой путь мог только увеличиться.
Вопросы?
Хорошо, ну, давайте я что-нибудь здесь напишу.
Напишу, что... Да.
Сейчас, давайте подумаем.
Внутри слоя, да, еще бывает, да, действительно.
Так вот, значит, все пути длины L исчерпаны.
Ну, я вот так схематично пишу, все пути длины L исчерпаны,
значит, нужно...
Новый путь...
Не проходит...
Ну, вот так вот, идеально он проходить не может.
Из S-V1 в V2 и так далее T.
Вот так проходить он не может,
значит, он использует хотя бы еще одно ребро,
там, либо внутри слоя, да, как правильно было замечено,
либо вообще одно из обратных использует,
ну, и тем самым наша длина увеличилась.
Так, ну и все, тогда следствие.
Число итерации в L у единица есть от V.
Вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Ну, вот так вот.
Это так называемые теоремы Корзанова. Мы рассмотрим пока что только одну из них.
Теорема Корзанова, первая. Их всего две. Вторая, ну, в семинаре будет.
Значит, теорема такая. Число итераций алгоритма 1.
Алгоритма 1. Есть от корни СП, где П мы сейчас определим.
П сейчас определим и докажем теорему, и все будет хорошо.
Определение. Давайте мы для каждой вершины, отличной от С и Т, мы определим входящую
capacity и исходящую capacity. Вот, собственно, очень естественные штуки.
Это ограничение на то, сколько потока может втечь в В и сколько может вытечь из В.
То есть это сумма capacity по всем входящим ребрам, это сумма capacity по всем исходящим ребрам.
Значит, сумма по УСУВ, здесь сумма по ВСВВ.
Значит, это как бы то, ну, оценка сверху, сколько может потока протечь как бы через вершинку В.
Вот если здесь может втечь максимум СИН, может вытечь максимум САУТ, значит точно есть оценка
сверху, не больше чем это, не больше чем это.
Мы можем определить потенциал вершинки В, это вот тот самый минимум из САУТ.
Оценка сверху на велесину потока, протекающего через вершинку.
Вот, ну и наконец вот это вот П. Это есть сумма потенциалов по всем вершинкам.
Неравным СТ, потенциал вершины В.
И если мы вот так определим этот самый наш потенциал, то оказывается, что число итераций, в частности,
можно оценить как от корни СП. То есть можно оценить как от В, это все верно,
но еще можно оценить как от корни СП. Соответственно, можно выбрать любой из двух оценок,
та из них, которая точнее и будет, ну, наиболее точно оценивать ваш время работы алгоритма.
Значит, чтобы это доказать, нам нужны пару лемм.
Лемма первая. Пусть L это длина кратчайшей пути.
Дист просто СТ.
Дальше F это величина МАКС потока.
Ну а П вот тот самый потенциал.
Тогда есть неравенство их связывающее.
L не больше, чем потенциал, деленный на поток, плюс один.
Доказательства.
Ну как выглядит наш граф?
Давайте нарешим слоистую сеть, нашу любимую.
Вот здесь где-то Т.
Смотрите, эта лемма работает для произвольного сети.
Вот есть у вас сеть, вы в ней определяете кратчайшее состояние.
Максимальный поток в принципе, ну как у нас был Fortfalk's максимальный поток,
и потенциал.
Так вот тогда вот это верно.
Это работает для любого графа.
Без значительно перехода к какой-то сети и так далее.
Вот.
Рассмотрим вот эту слоистую сеть.
Тогда можно написать следующее.
Смотрите, давайте рассмотрим какой-нибудь там итый слой.
Если я напишу, что ПИТ,
то я напишу ПИТ,
если я напишу, что ПИТ
равно сумме потенциалов вершин из этого слоя,
то я могу заведомо сказать, что эта штука больше равна, чем поток.
Потому что что такое сумма потенциалов потока через этот слой?
Вот есть наш слой.
Я здесь рассматриваю все вершинки.
Я рассматриваю здесь все вершинки.
И вот эта сумма П,
это какая-то оценка сверху на то, сколько потока может протекать сквозь наш слой.
Ну и тогда понятно, что поток не может быть больше, чем этот самый потенциал, чем ПИТ.
Потому что вообще как устроена любая единичка потока в этой сети?
Ну да, она может там как-то находиться.
Мы вспоминаем, что есть еще ребра не из ИТВ слоя, вы плюс первый.
Но тогда какие еще бывают ребра?
Бывают ребра как бы назад,
и бывают ребра где-то внутри слоя.
Но они все в этой сумме как бы учтутся,
потому что когда мы проводим какой-то поток,
у меня точно вот к этой вершине добавится,
вышлится какой-то F из осащенной капасти,
и вот отсюда вышлится F из осащенной капасти.
Поэтому у меня все равно этот поток,
он как бы должен, я вот так неформально объясняю,
должен пересечь наш слой.
То есть как бы втечь и вытечь.
Вот это F должно как бы в него попасть и уйти оттуда.
Поэтому суммарно, если у меня по сути вот эта сумма,
это есть ограничение на то, сколько может втечь и сколько может вытечь из этого слоя.
Но оно все равно должно втечь и потом вытечь.
Значит, это все не больше, чем F.
И так, и это верно для каждого i.
Верно для любого i, ну скажем, от 1 до l-1.
Тогда если я сложу это все по всем i,
то у меня что получится?
У меня получится, что, давайте напишем,
сумму по i, сумму по v из vi.
И у меня будет от 1 до l-1.
Сумма всех потенциалов больше, если про нас,
соответственно, чем l-1F.
Ну а это все, это не больше, чем просто весь потенциал светит.
Потому что у меня здесь сумма каких-то там вершин,
слоев с 1 по l-1.
Есть еще и другие вершины, скажем.
Вот здесь все они учтены.
Возможно, есть вершины еще правее.
Вот они не учтены, поэтому здесь будет эта оценка снизу на потенциал.
Ну и того получили, что потенциал больше, в общем, l-1 умножить на F.
А это в точность тоже написано здесь.
Да, еще раз, значит, вот это для каждого слоя верно.
Суммируем по всем i от 1 до l-1.
Видим, что это больше, ну, соответственно, просто вот l-1 раз такое неравенство складываем.
Остается справа l-1 умножить на F.
И все это оценим еще сверху через P, потому что потенциал не, ну, как бы...
Здесь учитывается потенциал всех вершин, кроме, возможно, там, каких-то, которые не учтены.
Значит, это оценка снизу на потенциал.
Все доказали.
Вот, и вторая лемма говорит нам, что потенциал сети — это константа после проталкивания потоков.
То есть вот есть у меня какая-то сеть, я там пустил какой-то поток, соответственно, добавил обратные ребра,
построил статочную сеть и так далее.
Но потенциал всегда, всегда постоянный.
Значит, потенциал сети не изменяется.
А потенциал сети не изменяется.
Но потенциал всегда, всегда постоянный.
Значит, потенциал сети не изменяется.
При проталкивании потока...
Ну, с учетом обратных ребер.
С учетом обратных ребер.
Ну, доказательство совсем простое.
Давайте вот пусть мы вдоль какого-то пути протолкнули поток.
И рассмотрим для конкретной вершины на этом пути, что поменялось.
То есть я в нее, как бы, ну, через нее протолкнул F-потока.
Значит, соответственно, на вот этих вот ребрах появился поток плюс F,
а на обратных к ним поток, наоборот, уменьшился на F.
Ну, тогда давайте попытаемся понять, как поменялось C-in и C-out для вот этой конкретной вершины.
Мы сейчас покажем, что для каждой конкретной вершины
ни C-in не поменялся, ни C-out не поменялся.
А значит, для всех вершин ничего не поменялось, потенциалы всех вершин сохранились.
Значит, потенциал всей сети тоже остался таким, как был.
Так вот.
Ну, тут, собственно, видно, как поменялось C-in для этой вершинки.
Ну, вот это все.
Ну, тут, собственно, видно, как поменялось C-in для этой вершинки.
У меня уменьшилась остаточная капаситет этого ребра на F,
но зато увеличилась остаточная капаситет этого ребра на F.
Да, потому что здесь плюс F-потоку, то есть минус F-capacity,
а здесь минус F-потоку, то есть плюс F-capacity.
Поэтому давайте я как-нибудь напишу, да.
Давайте напишу так, что остаточная капаситет ребра у В, она уменьшилась на F,
остаточная капаситет ребра В у увеличилась на F,
остаточная капаситет ребра Вw уменьшилась на F,
а Ww увеличилась на F.
Ну, и значит, C-in от В
с одной стороны уменьшилось на F, потому что вот это ребро стало меньше на F,
с другой стороны увеличилось на F, потому что это ребро стало больше на F.
Значит, это, давайте я напишу так, плюс равно F-F,
минус F, то есть не изменилось.
И то же самое с C-out от В.
Да, с C-out, смотрим на исходящие ребра.
Здесь capacity упало на F, а здесь выросло на F.
Значит, сумма capacity осталась такой, какая была.
Тоже, плюс равно F-F.
Все, значит, у каждой вершины, какие были вот эти оценки C-in от В и C-out от В,
они такие же и остались.
Поэтому все потенциалы сохранились.
Значит, P от V сохранилось.
Сохранилось.
Значит, P сохранилось.
P не меняется после протолкания потока.
Вот, и теперь мы наконец готовы доказать теорему Корзанова.
Доказать теоремы.
Нам надо доказать, что число уитарации есть от корни ИСП.
А давайте сделаем следующее.
Давайте мы насильно в нашем алгоритме доказать теорему Корзанова.
То есть, от корни ИСП.
А давайте сделаем следующее.
Давайте мы насильно в нашем алгоритме сделаем просто первые корень ИСП-итерации.
Сделаем первые корень ИСП-итерации алгоритма Деница.
То есть, просто столько раз найдем слоистую сеть, пустим блокирующий поток.
слоистую сеть, пустим блокирующий поток. Итак, корень ИСП раз.
Если алгоритм успел завершиться, то мы победили. Нам достаточно такого числа
итерации, чтобы алгоритм завершился. Это простой случай, я его даже не буду записывать.
Если алгоритм завершился, то мы уже победили. Иначе нам надо еще что-то делать.
Но смотрите, если мы сделали столько итераций, значит вот в оставшейся сети,
в остаточной сети, которая осталась после этих итераций, мы точно знаем,
что ДИСТ хотя бы корень ИСП. Потому что каждый раз увеличивает ДИСТ хотя бы на единичку,
а мы сделали столько итераций, поэтому в результате ДИСТ хотя бы такой.
Так как каждая итерация увеличивает этот самый ДИСТ.
Увеличивает ДИСТ.
И это вот то, что мы обзовем за L.
Ну а дальше мы знаем, что наш P не изменился.
И давайте скажем, что пусть F это сколько потока осталось протолкнуть до конца.
Сколько осталось пустить потока.
Когда по вот этой первой лемме мы знаем, что L не больше, чем P на F плюс...
Сейчас, плюс один. Да, плюс один.
Это просто первая лемма. То есть смотрите, я запустил столько итераций, у меня остался какой-то граф.
Вот для этого графа, который остается после такой итерации, я применяю вот эту лемму.
В ней L – это тот самый ДИСТ, который хотя бы корень ИСП.
P – это тот же самый потенциал, который был с самого начала, потому что P не меняется.
А F – это то, сколько потока осталось пропустить. Остаточный поток в остаточной сети.
Вот я его написал. И это все хотя бы корень ИСП.
Ну тогда, что мы получили? Мы получили, что P делит на F плюс один больше равно, чем корень ИСП.
Но отсюда видно, что F по величине не больше, чем корень ИСП.
Давайте немножко перепишу. Что написано? Написано, что P делит на F больше равно, чем корень ИСП минус один.
То есть F меньше либо равно P делит на корень ИСП минус один.
Что есть от корня ИСП.
Итого, что получилось. С помощью наших лем мы поняли, что остаточный поток после вот этих вот корня ИСП итераций
по величине сам по себе равен от корня ИСП.
Ну значит, если я просто буду пускать наш алгоритм Динница дальше и дальше, то поскольку на каждой итерации мы находим хотя бы один путь,
у нас на каждой итерации есть путь в остаточной сети, значит мы по нему хотя бы что-то протолкнем.
Значит, каждая итерация хотя бы единичку потока нам добавляет.
Ну а если всего осталось столько единиц потока, значит осталось после вот этих итераций еще максимум от корня ИСП.
Поэтому суммарно от корня ИСП итераций. Согласны?
Ну вот. И соответственно эта оценка может быть нам выгодна, если корень ИСП меньше, чем В, тогда мы получили более точную оценку на целую итерацию алгоритма Динница.
Вот, и сейчас применим это в каком-то частном случае. Давайте посмотрим на единичные сети.
Значит, определение. Сеть единична, если в ней вся капаситет 0 или единица.
Если вся капаситет равна 0 или единице.
Первое замечание.
Потенциал такой сети не больше, чем О от Е.
Ну это совсем просто, потому что вот есть какая-то вершина. Мы можем легко сказать, что ее, значит, Син, это просто сколько ребер в нее входит.
Ну давайте оставим только ребра с единичной капасти. Син это сколько ребер входит, Цао это сколько выходит.
Поэтому можем гарантированно написать, ну давайте я совсем в тупую напишу, что потенциал любой вершины не больше, чем О от Е.
Не больше, чем входящая степень от вершины В.
Плюс исходящая степень от вершины В.
То есть, на самом деле, тут можно было писать минимум из этих двух. Но я давайте для удобства напишу Сумму.
Потенциал вершины не больше, чем сколько ребер в нее вошло, плюс сколько ребер вышло.
Еще раз, на самом деле, минимум из этих двух. Но я загрублю неравенство и напишу не больше, чем Сумма.
Поэтому сумма по всем вершинам неравным s и t, p от v, просто не больше чем 2e, потому что
каждое ребро, оно учтется в этой большей сумме ровно два раза, ну не больше чем два раза,
от начала и от конца. Сумма потенциалов не больше, чем сумма как бы всех степеней,
что ограничено сверху двумя e. Вот поэтому потенциал есть от e, а значит по теориям
Картанова число итерации есть ну максимум от корни из e. Это первая мысль.
Вторая мысль такая, что на таких сетях алгоритм поиска блокирующего потока
плейстой сети работает за от e. Поиск блок потока плейстой сети, на самом деле неважно в какой,
пусть будет слоистой сети, работает за от e. Повторюсь, это только если у нас сеть единичная.
Если единичная сеть, мы по ней построили слоистую в какой-то момент времени, то тогда вот тот
самый алгоритм поиска блокирующего потока, который мы писали, работает за от e. Почему?
Потому что каждый ребро рассмотрится максимум один раз. Давайте вспомним, как у нас работал
ДФС внутри поиска блокирующего потока. Он в итоге находил какой-то путь из СВТ в нашей
слоистой сети и при этом еще какие-то ребра скипал, увеличивал ПТР для вершинок, помечая, что эти
ребра больше никогда не нужно рассматривать. Но тогда понятно, что я не только эти ребра никогда
не буду рассматривать, но и вот эти, по которым я только что пустил единичку потока. Потому что
если у меня все капасти это нули или единицы, и я пустил здесь поток, значит все эти ребра
скопом сразу стали насыщенными. Раньше у меня насыщенное могло стать всего одно ребро,
если сеть произвольное, но если единичное, то сразу все вот эти ребра стали насыщенными. Все эти
ребра становятся насыщенными. Значит, каждое ребро в нашем ДФСе, во всех наших ДФСах,
поучаствует максимум один раз. Мы либо переключим для него ПТР, либо сразу насытим,
и соответственно опять тоже сразу увеличим ПТР. То есть если я его насытил, то я могу сразу
увеличить наш ПТР и как бы его больше не рассматривать. Поэтому суммарно каждый
ребро рассмотрится максимум один раз. Значит, и время работы всех вот этих ДФСов есть у ЛАТЕ.
Значит, следствие. Алгоритм диница на единичной сети работает за Е корниз Е.
Потому что суммарно итерацией корни из Е по терями Карданова, и каждый поиск глубок縮 потока за ООД Е.
Поэтому замечаем, что каждый ребро максимум один раз поучаствует в нашем ДФСе.
за от Е, вот поэтому замечание, что каждое левро максимум один раз поучаствует в нашем ДФСе.
Вот, это уже, ну скажем так, сильно круче, чем все, что было до этого, чем всякие там
Эдманс Карп, ну по крайней мере теоретические оценки
Эдманса Карпа или даже Найденица в общем случае.
Четверть стр안 галward Syntax
Так, ну и последнее тогда.
карпа. Это решение задачи о максимальном просочетании
в дудольном графе с помощью потоков. Поиск максимального
просочетания в дудольном графе. Мы должны помнить,
что у нас есть алгоритм Куна, который делает это
за VE. По крайней мере, теоретическая оценка у нас там получалась
VE, число вершин на число ребер. Давайте теперь решим
эту же задачу с помощью потока и с помощью техники
параллельничной сети мы поймем, что алгоритм Динница
на соответствующей сети будет работать еще круче,
чем вот это. Сеть будет такая. Есть у меня исходный дудольный
граф, вот такой какой-то. Тут есть какие-то ребра
между вершинками разных долей. Я ввожу две эффективные
вершины S и T. Что-то слева, что-то справа. И провожу
ребра единичной capacity из S во все вершины левой доли.
Здесь у всех capacity единичка. И capacity единичка из вершин
правой доли в T. Здесь опять все capacity единички. Но вот
эти ребра я тоже ориентирую слева направо и на них на
всех рисую capacity единичка. Все ориентируюсь слева
направо, они все имеют capacity единичка. Так вот, я тогда
утверждаю, что максимальный поток в этой сети соответствует
максимальному просочетанию. Ну и вообще, любой поток,
какой бы мы тут не пустили из S в T, он обязательно соответствует
какому-то просочетанию в исходном моем дудольном
графе. Поток соответствует просочетанию. Ну почему?
Надо всего лишь понять, как просто выглядит любой
поток. Давайте попробуем что-нибудь порисовать. Вот
есть S, есть T. Как может выглядеть любой поток? Ну давайте
проследим просто историю какой-нибудь единички потока.
Вот она сначала вышла из S, попала куда-то в какую-то
из вершин левой доли. Потом какие есть из нее ребра?
Понятно, только в правую долю. Куда-то вот сюда
она могла переместиться. Это самая единичка. И потом
ей опять же не остается выбора, кроме как просто
стечь в сток T. Вот это история поведения каждой единичке
потока. Ну и поскольку у нас поток складывается
из всех таких путей, то все пути, они вот ровно так
и устроены. Сначала мы попадаем в левую долю, потом куда-то
в вершину правой доли, и потом стекаем в T. При этом,
смотрите, все вершины левой доли, которые я посетил,
они должны быть попарно различны. Потому что, скажем, не может
быть такого, что я два раза попал в одну и ту же вершину
левой доли. Потому что здесь у меня ограничение
копасти единичка вот на этом ребре. Значит, я не могу
сразу две единицы передать в одну и ту же вершину. Поэтому
все вершины вот этих вот левых, ну точнее вершины
всех этих путей, которые находятся в левой доле,
они все разные. То же самое справа. Вот здесь, не знаю,
там я еще что-нибудь нарисую. Все эти вершины должны
быть различными. Потому что опять из них и из всех,
если я пустил вершину, то единственный способ дойти
до конца, это сразу провести ребро в T. Ну и опять же,
не может быть такого, что, скажем, какие-нибудь, давайте
тут нарисую. Два разных пути пришли в одну вершину
правой доли, и потом оба стекли в T. Такого быть не
может, потому что здесь не может течь две единички
потока, здесь копасти единицы. Поэтому эти все вершины
тоже различны. Значит, что мы получили? Мы получили,
что у меня слева выбрано несколько вершин левой доли,
справа выбрано столько же вершин правой доли, и они
как-то друг с другом вот такое парасочетание образуют.
То есть каждый слева соответствует кто-то справа, причем
это соответственно описывается ребрами исходного графа.
Вот это вот, это ребра исходного графа. Значит, по потоку
мы сразу можем построить парасочетание. Просто те
ребра, которые вот здесь вот насыщены, между долями,
это и есть парасочетание. Тем самым мы показали, что
из любого потока можно построить парасочетание
той же величины. Ну теперь обратно. Если есть
какое-то парасочетание, то как построить поток?
Ну вот, собственно, ровно так. Если есть какое-то
парасочетание, то давайте просто пустим по единичке
потока в каждую насыщенную вершину левой доли, затем
пропустим эти единички вдоль ребер парасочетания,
и потом из всех этих опять сольем воду в Т. Каждую
единичку потока мы просто сольем в Т. То есть наоборот,
по каждому парасочетанию можно построить поток той
же величины. А значит, максимальный поток равен
максимальному парасочетанию.
Значит, максимальный поток равен максимальному
парасочетанию. Ровно максимальный.
Окей. Значит, тогда давайте мы запустим алгоритм
Деницы на нашей сети и поймем, за сколько он работает.
Ну, для этого надо понять две вещи. Во-первых, что
наша сеть единичная, значит, каждый раз работает
за от Е. Этому вот уже писали. Ну, видно, что здесь все
капасти единичные. Те, которые есть, они все единичные.
Значит, каждый итерация алгоритма Деницы работает
за от Е. Сеть единичная. Следовательно, итерация
за от Е. Но при этом давайте еще посчитаем потенциал
и оценим число итераций по теореме Корзанова.
Как тут можно найти потенциал вот в этой сети?
Ну, я утверждаю, что он просто равен от В. Потому что,
смотрите, напоминаю, как работает потенциал. Мне
нужно для каждой вершины отлично от С и Т взять минимум
из входящей суммарной капасти и изходящей. Но понятно,
что для этих вершин входящая капасти это единица. Ребра
вне входящая только ребра из С в эту сама левой долю.
А для этих чуваков, наоборот, и изходящая
капасти единица. Потому что из них изходящаяauft,
для каждой вершины сумма изходящих
капастей – это единица. Соответственно, для каждой
вершины, я беру минимум из C и С, я получаю для каждой
вершина единицу на все потенциалы единицы, потому что для нее 3 на едице, а целое какое-то,
поэтому минимум равен единице. Ну, не больше единицы, скажем так, потому что может быть вершина
без вообще сходящих ревер, значит у нее потенциал будет нулевой, то есть не больше чем 1.
Итого, для каждой вершины у меня потенциал не больше чем 1, тогда общий потенциал это максимум от v,
не больше чем от v. Значит, итерацией, сюда перемещаюсь, число итераций
по тереме Корзанова
есть от корни из v,
от корни из v. Да, итоговая символика получилась е корни из v.
Е корни из v.
Что даже еще лучше, чем было в Куне, потому что в Куне было, напомню, е умножить на v.
А здесь е на корень из v.
Вопросы?
Да, это хороший вопрос. Что?
Ну, в каком-то смысле да, еще, сейчас скажу.
Вообще, вот это как бы оценка, ну и понятно, что это только теоретически оценка в Куне все равно,
то есть там в каких-то графах, наверное, можно все равно оценить получше, чем тупое е умножить на v.
Скажу так, когда-то в жизни я видел задачу, где кун заходил, а денец нет.
Я не смог себе объяснить, к сожалению, почему это так.
То есть, ну, с теоретической точки зрения, вот это должно заходить точно.
Если кун заходит, то и денец должен.
Но вот почему-то было не так. Возможно, я, конечно, где-то набогал.
Но бывает, ну то есть повторюсь, что, во-первых, конечно, здесь константа меньше.
Константа меньше.
Во-вторых, на каких-то специфических графах вполне может быть вот этот чувак аффективнее, чем вот этот.
Ну, собственно, все.
Вот, тогда давайте на этом закончим. Новую тему уже нет смысла начинать.
Всем спасибо за внимание.
