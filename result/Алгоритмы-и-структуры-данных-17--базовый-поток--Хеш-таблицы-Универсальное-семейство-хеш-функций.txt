сегодня будет очень очень много математики которая возможно вам еще не сильно была вы не
сильно встречали вот а попрошу внимательно относиться к тому что здесь будет потому что
это достаточно сложная тема для восприятия будет именно с точки зрения математики не с точки
зрения того как это запрогася что-то с этим сделать а именно с точки зрения математики вот
поэтому с этим всем нужно считаться вам нужно будет уметь это доказывать вам нужно понимать
почему это работает быстро почему тот или иной метод работает в принципе и так далее а прошу
прощения но да сегодня мы задержимся но мы зато пройдем сразу две лекции по всему что нам
необходимо я надеюсь что мы это сделаем вот все зависит от того как мы будем идти по необходимому
нам материалам я знаю что у вас уже на семинарах должны были быть хэш таблицы еще у кого-то не
было ага кого-то значит они будет тогда мы сегодня говорим про в принципе хэш таблицы все что с
ними связано это еще не конец типа будут еще несколько будет еще пару тем на эту тему вот
а какая какую проблему вообще решает любая хэш таблица она решает проблему следующую что если
у меня есть какой-то массив в котором у нас есть какие-то элементы я хочу быстро уметь
понимать есть ли какой-то конкретный элемент в данном массиве конечно мы можем просто взять
обычные массивы и тогда это будет работать за за уатен просто обычный поиск в массиве можно
придумать что-нибудь другое можно делать какие-нибудь не только массивы за уатен но
к примеру можно ассортировать массивы тогда давайте результат за логен в помощи бинарного
поиска все верно но в этом случае мы будем очень долго вставлять элементы в наш массив вот это
тоже нам не очень подходит а если какие-нибудь структуру данных давайте вспомните пожалуйста
а где у вас будет поиск за логарифм а вставка быстрее чем за уатен бинарное дерево поиска
действительности это так но бинарном дереве поиска проблема в том что мы все время сохраняем
структуру вот этого сравнения все что у нас там происходит и так далее занимает много места
плюс логарифм тоже не очень круто хочется сделать так чтобы у нас вставка удаления и
нахождения элемента было за о от единички это и решает проблема это и решает хэш таблицы
смотрите какая идея с хэш таблицами допустим что мы хотим хранить какие-то числа от нуля до
там м-1 где в принципе м-1 ну в принципе м давайте так потому что там чисел м оно в контексте
памяти достаточно мало как можно быстро хранить такие числа вот чтобы мы понимали есть такое число
нет такого числа да по сути массив из true false где мы будем хранить по каждому индексу есть
такой элемент в нашей в нашей копилочке или нету если мы будем вставлять элемент то это означает
что у нас массив мы вставляем элемент x значит b от x оно будет равно true если мы удаляем
элемент мы говорим что он будет в полс ну и поиск элемента то есть есть элемент или нет
элемента в нашей какой вот табличке мы будем делать просто с помощью ретерна это тоже за от
единицы вот самое первое приближение к хэш таблице вообще все ячейки вот этого массива которые у
нас есть они будут называться корзинами но весь мир к сожалению не построен на числах от нуля до
м-1 и еще чтобы м было маленькое к сожалению она не та вот стоит много разных чисел и тогда это
становится не круто но как обобщенно должна выглядеть хэш таблица смотрите пусть некоторые
к это произвольное множество ключей а для которого хочется сделать аналогичное действие чтобы
были до этого то есть к это то с чем нам могут приходить это могут быть функции это был может
быть массив чисел это могут просто числа какие-то которые просто по одному приходит и так далее вот
а и я хочу построить как раз таки функцию отображения в эти корзинки то есть когда у меня
приходит какой-то элемент x он из как раз таки который у меня есть то я просто беру делаю
функцию h от x и кладу его куда-то от нуля до м-1 потому что с от нуля до м-1 мы понимаем как
работать то есть я хочу вот это сопоставление сделать м называется размером нашей хэш таблице вот
ну а весь тут массивчик который у нас здесь будет напомню что вот здесь вот у нас будут эти самые
корзинки вот куда хэш функция h от x это хэш функция она будет просто складывать наше значение вот и
показывать есть какой-то элемент или нет чем здесь может быть проблема да если количество
элементов к начинает быть больше чем м потому что у нас будут так называемые коллизии то есть
в случае когда у нас будут различные элементы из к x какой-нибудь y но хэш функция для них
будет одинаково в особенности проблема когда у нас к сильно больше м у нас коллизии становится
очень много и тогда какая-либо эффективность этой хэш таблицы вообще становится под вопросом вот
то есть никакого такого инъективного отображения вы сделать не можете что грустно для разрешения
коллизии существует так называемый метод цепочек что такое метод цепочек метод цепочек достаточно
просто смотрите вас есть вот ваш массив b будьте здоровы вас есть массив б у него там и минус один
элемент как только вы встречаете коллизию и в принципе все элементы вы храните следующим
образом вот вам пришел элемент x вы его положили сюда после этого если у вас появится какой-нибудь
y который не равен x во первых а во вторых находится хэш функция отображает в то же место то в этом
случае вы просто таким листом кладете y благодаря этому мы понимаем что у нас вот в этой части именно
с этим хэшом находится x и y и дальше чтобы определить есть ли x или нет y я должен взять и
просто пройтись по всему по всей этой цепочке и сказать встретил я такой элемент или нет это пока
понятно не сложно это отлично вот это и будет называться методом цепочек для разрешения коллизий
что такое время время работы с методом цепочек но нужно понимать что insert и erase всегда будут
совпадать с find то есть вы если находите элемент то ничего не делаете вставки в
разе вы просто убираете один элемент если вы не находите какой-то элемент то есть вы все равно
до начала делаете find то insert должен вставить этот элемент а erase должен как раз таки ничего
не сделать потому что этого элемента у нас нет вот поэтому будем оценивать время find всегда
и для нас это самое важное что есть какое время find время find и следующее мы в начале
находим h от x это находится за о от единички согласны а дальше мы должны пройтись по всей
цепочке который у нас есть поэтому а вот это вот длина цепочки lx которая здесь есть это и
будет наше время работы то есть время работы поиска будет о от единицы плюс lx в худшем случае
когда у вас все элементы складываются в одну и ту же корзинку то есть у вас настолько маленькая
х-табличка что у вас просто одна большая цепочка у вас будет время работы о отн что не круто
а и все упирается как раз таки здесь либо вас не очень хорошая хэш функция и все упирается здесь
в хэш функцию нужно ее выбрать очень правильно очень корректно для того чтобы у вас все работало
что должна делать такая хэш функция равномерно распределять то есть да для того чтобы у нас как
можно больше элементы расходились между собой она должна как-то равномерно раскидывать
элементы между корзинами которые у нас есть но предположим что у нас есть x это unsigned int
вопрос к вам такой нам подойдет функция h от x которая берет просто остаток отделения
равномерно или она распределяет данные в зависимости от задач в плане
ага да вся проблема действительности в том что какие у нас есть конкретно входные данные мы
можем подавать просто на вход м 2 м 3 м 4 м и так далее они будут все классы в одну корзину то есть
все зависит также от этих данных но мы хотим сделать h от x максимально независящий от данных
величин и попробовать это сделать как-то по-другому и для этого вводится так называемое простое
равномерное хеширование это первое самое важное что вам нужно знать у него существует два
определения не эквивалентно между собой первое определение говорится следующим что у нас аж просто
выбирается рандомно из всех хэш функций которые есть в наше множество всевозможных всем понятно
запись вот это вот в степени к множество степени к это есть вот эти отображения между собой окей то
есть мы расслабить абсолютно все хэш функции которые у нас есть вот и аж выбираться будет
случайно из этого множество мы выбираем это случайно вроде бы что-то должно получиться то
есть благодаря вот этой случайности которая есть она может нам помочь вспомните с quicksort например
как было если мы всегда фиксировали какой элемент мы берем там первый там последний середину и так
далее мы всегда могли придумать такую расстановку чисел для quicksort что она будет работать в лучшем
случае за m квадрат и мы pivot выбирали рандомно был такое то есть в лучшем случае во лучше
выбирать рандомно какое-нибудь число вот в этом случае аналогично когда мы хэш функцию будем
выбирать из какого-то множества всевозможных функций в этом случае нам может повезти и все
будет хорошо и ну как бы от рандома никто не защищен но может повезти может нет но чаще повезет
скорее потому что таких функций сколько много согласны вот второе определение следующее ну что
у вас есть какой-нибудь ашат икс вам нужно еще важно что понимать что у вас ашат икс должно
быть одно и то же для любого для одного и того же икса оно не должно меняться между собой поэтому
мы должны всегда фиксировать вот это ашат икс который у нас есть поэтому грубо говоря если у нас
икс приходит какой-то новый ключ то есть у нас вот find мы сделали у нас не получается такого икса
найти грубо говоря то ашат икс будет рандомно выкидывать какое число из м рандом всегда
помогает в равномерности иначе не работает вот а иначе если у нас икс уже есть который к нам
приходил то в этом случае мы будем использовать ровно тот же хэш который был ранее просто выглядит
ашат икс рандомно но это другой вопрос как это делать вот но в действительности здесь нет
пока никакой проблемы то есть мы просто выкидываем рандомно числа но да это это вопрос правильный
который мы подойдем в конце хорошо окей для того чтобы продолжать дальше нам необходимо
окунуться в теорвер который у вас будет чуть-чуть попозже здесь будут введены краткие какие-то
сводки с теорвера назову это так которые вам должны помочь понять все что у нас происходит оно
может немного отличаться с точки зрения теорвера потому что ну совсем вас убить не хочется вот и
иначе будут некоторые проблемы ну смотрите первое что вводится вводится что такое омега омега это
просто а некоторые там множество равновероятных экспериментов которые у нас есть но не знаю вы
кубик подкидываете вот у вас число от одного до шести может выпасть правильно вот у вас омега
мы рассматриваем сейчас именно равновероятные исходы ну потому что мы находимся в таком мире
где у нас рандом рандом равновероять событием какого-то множества это является под множеством
омега ну не знаю типа просто четные числа должны выпасть на кубики это 246 вот это
является событием мы кидаем оно случилось не случилось вот вероятность какого-то события это
мощность множество этого события разделить на множество всевозможных событий я думаю тут
понятно да мощность множество знакомое слово хорошо вот сегодня вот типа я говорю самая
проблема хэш функции и хэш табличек это всегда такой математический аппарат вот здесь нужно
очень аккуратно поэтому останавливает если что-то не понимать дальше пусть у нас x будет
результатом некоторого измерения вот здесь вот написано я от x кто знает какой называется
это правда воспринимаете это как среднее пока что воспринимать будем такие таким способом
потому что это некоторые дискретные случаи поэтому здесь можно сделать так это действительно просто
среднее число которое выпадет вот то есть вы ожидаете что выпадет что-то грубо говоря это
само число на вероятность того того что выпало какой-то там исход ну например у вас есть кубик и
тогда мат ожидания от случайной величины x ну то есть вот вы подкинули кубик вы хотите понять
сколько в среднем будет выпадать чиселка что за чиселка будет выпадать оно будет равно там а
один плюс умножено на одну шестую плюс два на одну шестую плюс так далее 6 умножить на одну
шестую это откуда это получилось вот ну дальше получится какое число это будет это и будет
мат ожидания мат ожидания того числа который у вас выпадет кубики вот здесь либо вы вам не
нравится либо я не понимаю ваши лица вот вы озадачены во всяком случае но хорошо воспринимайте
это так что важно понимать про мат ожидания про мат ожидания важно понимать следующее ну давайте
так среднее буду говорить среднее чтобы не пугать другими словами вот средняя от двух случайных
величин от суммы двух случайных величин это средняя каждый из них и просуммировать необходимо
но если мы говорим про дискретный случай ну как бы просто сложим x 1 плюс y 1 плюс там x
n плюс y и так далее разделим на н ну мы получим то же самое вот разделим просто на две дроби тогда
у нас получается необходимая нам средняя вот а это то что нам тоже нужно и последнее что важно
если у нас x и y это независимые равно вероятные события и они принимают значение а вот здесь
а нет все правильно они принимают значение грубо говоря от нуля там до m минус 1 то вероятность
того что x равен y равно 1 на m правда это просто хотя бы отлично но как бы доказывается это из
первого пункта но нам нужно взять одинаковые пары одинаковых пар всего m различных пар m квадрат
m делить на m квадрат получаем 1 на m ok ok отлично хорошо теперь очень интересная вещь а когда мы
используем простое равномерное хэширование то в этом случае среднее время поиска файнда по
факту составляет о от 1 плюс альфа где альфа это n делить на m n это количество элементов в
хэштаблице ну то есть грубо говоря сколько элементов мы приняли м размер хэштаблицы альфа
само по себе называется loadFactor когда вы будете проходить не знаю на плюсах а нордерцеты еще
же не прошли нет вот когда вы будете проходить вот там вот тоже будут свои методы там тоже будет
loadFactor loadFactor это вот это вот как раз таки n делить на m только у нас есть элементов и сколько у нас
есть корзинок вот то есть мы пытаемся оценить вот эту равномерность не знаю сколько элементов
цепочки будет в среднем нам 3 4 2 1 и так далее вот мы хотим это доказать как такое доказывается
но пусть у нас есть множество x это x1 xn которая является элементами хэштаблицы то есть теми
элементами которые у нас передаются в хэш функцию которые у нас принимаются давайте выразим длину
цепочки как можно выразить длину цепочки вот смотрите вот как вы думаете что у меня за сумма
там написано вам знакома буковка и индикатор слышали такое слово хорошо да это просто индикаторная
функция практически что такое и там h от x равно h от x и t она принимает значение 0 если h от x
не равно h от x и t и единицу если h от x равно h от x и t ну такой да переведены в нты вот
но в общем-то смотрите индикатор это достаточно просто согласны ли вы с тем что длина цепочки
равна сумме всех индикатору суммы индикаторов для конкретного x ну потому что мы просто вот
смотрим все возможные вот эти вот вещи это чудесно давайте теперь выразим маты средняя
среднюю длину цепочки чему равна средняя длина цепочки видите я просто беру и подставляю это
вот ел x видите да вот средняя дальше я подставляю вот этот индикатор а средняя сумме равно сумме
средних да значит я могу внести это под сумму вот по третьему свойству которое у нас было
до этого окей окей это первое и теперь следующее я говорю так что а что такое средняя величина
того что у меня h от x равен h от y это вероятность этого события все может случиться может нет и
вероятность этого события и есть то самое среднее которое возможно нужно принимают 0 1 ну вот мы
понимаем что вероятность это событие есть будет где-то там понятно почему это происходит
что именно непонятно куда делать е ну смотрите мне нужно найти среднюю величину индикатора
да отлично ну вот вот так грубо говоря я должен понять но он может получиться 0 может 1 вот
вероятностью 0 оно получается ну не знаю там п1 да с этого это п2 а теперь смотрите чему равно
этом от ожидания она равно 0 умножить на п1 плюс 1 умножить на п2 получается вероятность когда
они одинаковые теперь понятнее отлично вот благодаря вот этому вот свойству мы получаем
что у нас просто есть сумма вероятности ну и чему равна эта сумма вероятности смотрите h от
x и h от x y это разные события или нет независимые события или нет ну да они разные они разные кроме
одного случая когда они одинаковые все правильно нет смотрите когда когда они одинаковые ну как бы
аж от пяти аж от пяти логично что это одинаковый х х значение правильно согласны то есть в этом
случае у нас будет единичка когда x равно x и t а в других случаях это 1 делить на m все просто мы
смотрим эту сумму получается в одном случае у нас там будет один плюс там n минус один делить на
м если у нас x вообще лежит в множестве x-ов большое а иначе у нас будет n делить на m но все это меньше
чем 1 плюс n делить на м понятно или непонятно это самое начало вопросы есть на экзамене вам это
доказывать не мне предпоследний это из когда сумма получилось вот это из одной
системы в другую но смотрите а если у меня x лежит в этом множестве то у меня что будет то у
меня будет когда x равно x и t это единичка правильно а сколько вероятно сколько случаев что x не
равно x и t сколько таких случаев я кроме одного сколько всего их там было n да получается таких
n минус 1 вот получается что сумма этого всего это 1 плюс n минус 1 делить на m потому что у меня
вероятность одного такого события 1 на m когда ашат икс равно ашат икс это ага это первое но
а второе когда x не лежит в множестве x у нас все события между собой 1 на m значит n делить на
м понятно да где
так 1 делить на m минус 1 не n m n минус 1 смотрите давайте еще раз ашат икс принимает какие значения
нет нет вероятность исхода когда они равны между собой еще раз очень важна это вероятность какое
назначение принимает ашат икс и какой ашат икс икс это это все оно принимает значение там от нуля
до m минус 1 согласны они не зависит между собой как хотят так и принимают это рандомные числа
они не зависящие между собой получается сколько у нас одинаковых парта м а разных пар ну точнее
всевозможных пар м квадрат поэтому здесь получится 1 на м как раз ага еще есть вопросы
доказательств понятно вот а ну важный момент типа все что связано с хэш таблицами это все
математика вот тут нужно ее очень хорошо представлять какое следствие из этого всего
мы получаем следствие такое что у нас результат работы всех операций это 1 плюс n делить на m
значит что мы хотим сделать с этими операциями хороший вариант есть вопросик что с ним в этом
случае делать но да а правильно что мы хотим вообще сделать с м как мы можем ее выбирать
чтобы load фактор был меньше единицы окей и тогда временная сложность у от единички как это
гарантировать м чему равно сделать n множить на 2 хорошо в действительности да как бы а так
как у нас множество x может все время пополняться нам необходимо будет перехышировать нашу таблицу
всегда поэтому здесь будет очень похоже на динамически расширяющийся массив у вас
еще не было векторов правильно ага но какая суть динамически расширяющийся массивом давайте
я сейчас буду почувствовать и мы с вами еще его потом об отдельно обсудим
смотрите суть примерно следующее как только у вас грубо говоря количество элементов количество
бакетов станет равная n то в этом случае вы делаете новый массив которым m будет равно уже 2
и перехашируйте все элементы которые у вас есть и переносите их каким-то образом а динамически
расширяющимся массивы переносите прям вниз а здесь вы выбираете новую хэш функции и перекидываете
их между собой понятно выбирайте с ними что-то делать вот это нужно для того ну то есть это
мультипликативная схема которая увеличивает все время на 2 чаще всего убирают коэффициент 2 но там
можно выбрать 1 и 7 ничего не такое вот самое эффективное где-то 1 и 7 если не ошибаюсь это
нужно делать потому что в этом случае у вас амортизационно будет тратиться всего лишь у
от единички ресурсов почему поговорим об этом в динамически расширяемся динамически
расширяющимся массиве хорошо вот здесь поверьте просто увеличивайте на два да
наша хэш функция рандомно выбирает число для любого икса мы должны брать новые мы должны
перехашировать абсолютно все мы не должны заново перекидывать иначе вы будете заново все
перекидывать то у вас будет неравномерно понятно то мы берем новые хэш функции да ну когда как
ну типа но я говорю мы ответим на этот вопрос в конце вот в общем-то как-то так идея следующая
но то есть фактически алгоритм будет выглядеть так ну find erase понятно типа найти элемент понятно
erase понятно если вы убираете вы не увеличиваете размер m поэтому все легко вот сенсор там нужно
здесь чуть-чуть повозиться повозиться в каком случае если у вас x уже лежит в хэш табличке
тогда вы просто возвращаете ничего не происходит если у вас n плюс один делить на m то есть при
добавление этого элемента оно меньше либо равно единиц то вставляем просто в нашу корзину типа
все как обычно методом цепочек а иначе если вот как раз таки у меня вот это равенство достигается
я увеличиваю наше количество корзин на два и у меня становится два n вот а мы перегенерируем все
хэш функции которые есть перевставляем старые элементы в новую хэш таблицу рандомно раскидывая
элементы и вставляем потом x тоже в нашу хэш таблицу понятно вот время работы будет это за о от единички
в амортизационном случае если вы легко вытаскиваете хэш функции откуда-нибудь окей понятно вам
необходимы просто хэш функция представим что у нас есть вот это банк хэш функции я просто вытаскивать
на данный момент вопросы есть мы кстати очень бодро идем я скажу да
мы специально хотим сделать так чтобы мы находили вставляли удаляли элементы за вот единицы да
мы не хотим искать это долго мы не хотим это делать основная функция хэш табличек это
всегда find race insert для того чтобы быстро общаться между собой типа что там происходит понятно есть
еще вопросы смотрите давайте еще раз а вот у меня есть некоторая таблица b в самом начале
вы добавляете сюда элементы и решаете коллизии между собой метам цепочку да
что одно и то же клетку но когда у вас одинаковая ну хэш функция аш от x равна аш от y когда x не
равен y вот это коллизия у вас количество бакетов не обязательно одинаковая ну возьмем
функцию не знаю тот же процент у тебя для ну от процент м например у тебя для единицы для
м плюс один один и тот же бакет хэш функция еще раз это функция из множества иксо там ключей было
множество к в вот это хэш функция у нас 6 и у кай это все количество ключей которые приходят к
нам а здесь нуля да и минус 1 это просто некоторая функция за шесть чиселка вот еще а да да
рассказать что здесь происходит вот у вас есть типа методы цепочек типа оно там как-то разрешает
эти коллизии то есть вот тут вот x y вот здесь какой-нибудь их стрих y штрих z штрих там да вот
вас есть вот эти вот коллизии и так далее в какой-то момент вы достигаете и амортизационно вы
знаете что у вас работает за у от 1 плюс м делить на м значит вам нужно увеличить м в какой-то
момент когда у вас станет перебор элементов для того чтобы была какая-то равномерность у меня
здесь не равномерно но такое тоже случается потому что рандомно мы что-то выбирали может такое
получиться но в случае когда у вас вот тут вот появится еще какой-нибудь элемент всего 5
бакетов не на т вот но элемент стало больше вы создаете новую хэш таблицу который уже будет там
ну тут 10 элементов должно быть вот вы создаете 10 элементов и перекидываете все элементы и
x y и так далее уже в новую хэш таблицу да потому что у вас изменилась м то есть у вас до этого был
а теперь у вас должна быть а штрих какая-то функция из к в 0 2 м минус 2 ой вот то есть вы должны
уже брать хэш функцию отсюда для того чтобы вас опять же вот эта штука заполнялась равномерно
хэш таблица иначе у вас будут проблемы еще раз хэш функция просто рандом выкидывает числа это
все еще простое равномерное хэширование когда мы просто с помощью рандома берем числа рандомные
числа они всегда равномерно не равномерно распределяются между собой вот еще есть
вопросы здесь понятно хорошо какие есть технические здесь тонкости назовем это
смотрите вот у меня есть хэш табличка за сколько будет работать вы вот всех элементов у от n
плюс m это правда а хорошо ли это почему что еще раз м может быть большим так какие есть решения
раз у кого-то был семинар давайте поговорим о том как это решать то можно указатели хранительные
элементы да смотрите решением все эти вещи является примерно следующим давайте в хэш таблице
который у нас есть а мы будем хранить указатели на элементы а сами все элементы которые приходят
к нам в хэш таблицу мы будем хранить списки ну и так далее вот у нас есть список а согласны ли
вы что у нас есть метод цепочек как бы все ок нужно просто его как-то здесь применить как
мы это делаем вот у меня есть массив вот этот вот б а у меня нету здесь мелков классных поэтому
буду чиселки проставлять вот у меня есть первая хэш функция я знаю что у нее у коллизии там не две
я говорю что пусть она показывает мне на начало и вот это и вот это относится к первой хэш функции
к первому моему бакету второй бакет ну не знаю там пусто пусть будет у них к нему ничего не
пришло еще третьему бакету всего там не знаю одна то есть здесь в чем суть у меня все элементы
с одним и тем же хэшом идут подряд а 4 но пусть тоже не было пятый два вот этих вот которые у
меня здесь есть ну там что и седьмой может есть может нет не знаю вот у меня есть вот такие вот
вещи что мне позволяет делать список проход делать за отэм то есть мы можем вывести все
элементы за о отэм еще вставка и удаление на самом деле тоже за единичку и поиск ну как бы как
здесь искать элементы мы просто будем сравнивать еще хэши как мы поймем что мы вышли в другую
цепочку а другой хэш будет то есть у меня хэш здесь мы знаем там он конкретно и здесь
хэш вообще другой становится согласны вот поэтому здесь все достаточно понятно как это делать но
для того чтобы удалять и вставлять элементы скажите мне пожалуйста давайте так продолжу что да мы
просто будем проверять хэши а какой список нам здесь необходимо хранить как вы думаете
а сейчас давайте еще раз можно одна связанная буду спрашивать как на двух связанных а почему
а предыдущему хешу чтобы вот так вот перевязать правильно хорошо а это правда но есть проблемы с
двух связанного списка смотрите помимо самого элемента вы будете хранить следующий предыдущий
а еще возможно хэш функции очень много не кажется давайте сокращать память мы пытаемся
работать с памятью тоже эффективно можно действительность на односвязанном списке как
как сделать на односвязанном списке удалять элемент но вот смотрите вот у меня тройка указывает
сюда как мне вот вот типа удалить вот этот элемент и перевязать вот этот вот элементик
а как здесь еще раз у меня хэш функции лежит вот тут это долго и как ты будешь находить предыдущую
цепочку то еще назад то потом еще назад это становится у отем так не подходит от
логарифмонт не подходит хочу вот единица
а почти но нет давайте еще предложение
какую вот тут а нет потому что в этом случае у вас будет вывод не за у отем не за у от
элемента всех мне нужно чтобы все элементы выводились типа за отн да нет
сейчас неприятно а
тогда вставку как не делать ну типа это такая проблема курица яйца поменяем
направление мне нужно вставить будет элемент еще поменяем направление куда
какому да да а если мне нужно удалить хорошо элемент типа какой-то другой
например там а какой методом цепочек еще раз у нас есть три сейчас момент нас есть три вот
у меня хэша треху вот оно относится вот сюда к примеру но три условно это звездочка это
какой-то элемент третьей так бакет третьей вот то есть нет так хэша тыкс равно три вот так
должно быть в этом случае здесь у меня лежит указатель на лист конечно если у вас бакет зафиксировано
туда если вы перехожи ручь то нет ну конечно иначе будет не работала как искать элементы еще раз
у меня было определение вот тут если x новый ключ то мы считаем хэш функцию если старый то старый
хэш хэш используем больше указатель и богу указатель неприкольно
неприкольно неприкольно все равно нужно где-то хранить еще ладно смотрите действительность
идея следующая давайте хранить указатель просто предыдущий предлагала хранить не тут а тут тогда
прости тогда прости я думал ты вот тут имела в виду что хочешь здесь вот и тогда это в
действительности так работает у вас forward листах будет типа insert авто erase авто и так далее вот
существуют такие вот у него методы в действительности когда вы дойдете до стли вам булат это все расскажет
вот тогда в этом случае удалять гораздо проще если вам нужно удалить первый элемент то все хорошо
в этот первый элемент удаляйте и перекидывайте вот этот указатель через него все окей вот если
вам нужно вставить ну ставьте здесь нет никакой проблемы вставьте просто вот сюда же скиньте
на него указатель это сюда это все будет работать за у от единичку поэтому это делается вообще на
односвязных списках вот это да чтобы экономить память да да
память небезгранична время тоже константы важны а еще раз типа а симпатически не всегда означает
хорошо по константе мы с вами познакомимся с фибоначевой пирамидой в этом семестре она
будет давать хорошие результаты для не знаю алгоритма д экстре а симпатически но это работает
только симпатически в реальном мире оно не работает но на бумажке работает симпатически
константа очень важна константу тоже нужно беречь грубо говоря вы будете использовать не знаю 3 гигабайт
или 4 гигабайта оперативной памяти все одно и то же но вот тут вот 4 чиселка или 3 вот все играет на
масштабах конечно но это судьба я часть да именно такая вот оно это все что
касается простого равномерного хеширования мы даже с вами уложились в 40 с чем-то нет 50 чем-то
минута вот но почти все глобальная проблема в следующем а существует ли простое равномерное
хеширование как вы думаете все в даран дом все дела такое себе чудо а почему нет
не пойму здесь причем оно но ладно и что там написано почему главный результат помню все
правильно нет здесь не в этом проблема ну рандомы к сортам тоже рандомно получится а примеры
потом вы перезапустите он заработает в этом сути рандома вот когда-то работа когда-то нет
в действительности следующее ну как бы по-хорошему для того чтобы выбирать рандомную хеш функцию вам
нужно их как хранять правильно вот предположим что не знаю у вас вот есть какой-нибудь к а не
знаю там интовая к примеру а вот какая-то ну типа над каким ножем мы работаем множество ключей
ну вас 6 int просто там у него 10 в 9 если мы возьмем мощность множество хэш функций у тебя сколько
всего существует то это будет а м в степени а то это в степени м степеньем модуль к для того
чтобы какое-то множество размером n с помощью бит нам необходим логарифм бит согласны у вас
есть любое число какое-то вы хотите записать его в битах логарифм нужно во степени двоечки
там появляются согласны или не согласны беда скорее согласны хорошо ладно подумайте над этим
фактом сегодня вечером в общем-то если мы возьмем логарифм от этого всего то у нас получится
мощность к на логарифм м но мощность к это все значения это 4 на 10 девятый примерно бит это
очень много бит это очень проблемно понятно ну то есть это там что 2 в 30 то есть чем-то даже
так 233 наверное где-то а бит ну вот и посчитайте вас будет там что байт ну где-то килогигабайт
что не очень хорошо длинта да это есть сами функции мы должны как-то вот типа ну хранить
внутри но это вот первое объяснение теоретической такой теоретической информатике то есть просто
сколько у нас есть место для того чтобы сохранить все функции которые есть я же
рандомно выкидываю функцию тоже беру это любая рандомная функция поэтому на рандомное выкидывать
число вот поэтому это не подходит это не прикольно ну а последнее как понять что встречался ли икс
для того чтобы старый хэш посчитать ну для этого по-хорошему тоже нужна хэш функция вот
а для этой функции хэш таблицы нужно еще одна хэш таблица ну и так далее мы рекурсивно идем в
хэш таблице чтобы тоже не очень круто поэтому ну как бы с двумя этими определениями мы выжить
нормально не можем это то что касается простого равномерного хэширования есть ли у вас тут
вопроса очень кратко пытаюсь вам изложить всю информацию потому что была презентация надеюсь
вы видели задавайте вопрос хорошо тогда мы переходим ко второй теме это вторая лекция
должна быть я бы с вами побольше говорил но тут получается чуть поменьше мы с вами поняли что у
нас нету простого равномерного хэширования это плохо для нас потому что для нее мы такую
восхитительную теорию доказали что она все работает может быстро просто надо взять m равно n
грубо говоря и тогда все будет работать отлично но здесь у нас так не работает и мы переходим к
так называемому универсальному хэшированию а которая у нас есть старый не работает возьмем
новое но будем строить его на основе старого смотрите мы хотим найти какое-то небольшое
семейство являюсь под множеством вот всех вот этих хэш функций которая обладала бы все теми
же свойствами что и простое равномерное хэширование то есть нам необходимо так взять и придумать что-то вот
мы хотим вот из этого всего кусочка кусочка их нить хэш функции мы хотим выбрать маленький
который обладает теми же свойствами ага вот и нам нужно придумать что это такое ну смотрите
а в каком случае вот универсальным семейством как раз таки это и называется мы пытаемся найти
это универсальное семейство семейство называется универсальным если при выборе какой-то хэш
функции из этого семейства выполнялось бы свойство что для любого x и y из нашего множества ключей
а вероятность того что случилась коллизия меньше либо равна чем один делить на м м количество
бакетов понятно вот мы хотим сделать так чтобы у нас вот универсальное семейство существовало
именно в этой концепции мира и попробовать с ней что-то сделать напомню про простой равномерное
хэширование вот у нас была с вами теорема что там работает за у от 1 плюс альфа мы говорим что
если мы заменим простой равномерное хэширование в этой теореме на универсальные семейства хэш
функций то в этом случае все будет хорошо и все будет работать ровно так же то есть для универсального
семейства работает ровно та же теорема мы можем сказать что это все работает за о от 1 плюс альфа
ага как это сделать но это сделать достаточно просто смотрите не меняются почти никакие пункты
кроме быть может а вот этот вот где 4 написано почему как бы да из-за того у нас было равенство
стало неравенством просто из-за того что у нас универсальное семейство здесь имеет неравенство
меньше либо равно 1 делить на м окей вот из-за этого получилось неравенство во всем остальном это
одинаковое это пока понятно ясно что это работает взяли кусочек заработал хорошо давайте тогда
разбираться с примерами которые есть вам их нужно будет реализовывать так что подумайте о том что
это вам полезно смотрите я хочу взять множество у меня здесь слайды почти без интриг у вас сразу
идет доказательства с ним учу и так далее вот поэтому думайте о том почему там так написано
вот а я хочу взять множество ключей как zp то есть множество вычитов пп где п это
простое число именно простое число я хочу взять в качестве а аж то есть моего множество
х функции это будет функция вида а икс плюс б процент п процент м п из предыдущего по какому
вычету нас было м это количество бакетов где а это тоже входит множество вычитов по п без нуля
только то есть у меня должно быть все-таки не просто б процент по процентам вот а икс
какой-нибудь вот и бы я тоже лежит в этом множестве zp и тогда я утверждаю что это множество аж оно
универсальное а и б мы берем разные п это множество ключей откуда принимает икс оно
не может увеличиваться у вас м может увеличиваться по нет ага да да для конкретной
подзадачи если брать конкретнее то поверьте мне вы с такой сталкнетесь вот мы говорим о том что
вот такое множество х функции оно является у нас универсальным то есть какую функцию оттуда не
восьми у них вероятность того что будут коллизия 1 делить на м для конкретного множества ключей как
мы это делаем мы делаем следующим образом мы возьмем рандомный x и грек что они неравны между
собой и скажем что икс трих это вот как раз без процента м х функция и грек штрих это без процента
м тоже ну то есть это а икс плюс б процент п и а и грек плюс б процент п выясним друг из друга
икс штрих и грек штрих что я получу я получу ну как бы я могу все внести под одну скобочку получу
а от икс минус игрек процент п а не ноль икс не равен игрек поэтому икс минус игрек не ноль п
простое все хорошо у нас не будет ничего оно не выйдет за границу мою zp получается это не нулевая
часть правильно то есть икс трих минус игрек штрих не нулевые а значит икс штрих не равны игрек
штрих понятно да отлично вот следующее мое утверждение я говорю что существует биекция
между всем возможными икс трих игрек штрих и а бы но то есть грубо говоря когда у меня есть какие-нибудь
икс игрек я могу подобрать любые обе получив любые икс штрих игрек штрих эти множества одинаковые
между собой то есть я с помощью одного могу перейти в другое и определить что там было понятно что
я делаю а да отлично хорошо ну как это сделать ну давайте просто решим стим линейных уравнений
можно ее решить подставить вот как здесь написано я просто не знал бы на линале прошли систему
линейных уравнений или нет еще да да хорошо ну в общем-то можно сказать что здесь матрица матрица
не вырожденная просто если очень хочется но одно из двух короче вот ну как бы вы можете все
подставить получить и здесь будет действительно какое-то число оно все не нулевое это хорошо и
мы получаем единственное решение для а и б через икс игрек икс штрих игрек штрих икс игрек у
меня фактически зафиксировано я взял произвольные вот я с ними ввожусь их штрих игрек штрих я
говорю что через них я получаю а и б единственным способом что логично оно не может быть не
единственным в этом случае окей принято хорошо ну и а для того чтобы сказать что действительно
нам нужно еще что нам нужно еще все-таки сказать что у нас размер множества одинаковые то есть
меня в одну сторону должно быть правда и в другую сторону должно быть правда но как нам сказать это
ну давайте посчитаем мощность множество мощность множество а и б какое почему
всевозможные ну то есть а может принимать п-1 вариант б может принимать п согласны а икс
штрих игрек штрих вот та пара которая там находится она может принимать аналогичное значение почему
потому что они не равны все правильно если я икс штрих фиксирую то там становится у игрек
штрих п-1 вариант круто какого порядка а ты имеешь в виду с точки зрения реализации или что
точки зрения м здесь все зависит от того что ты хочешь получить напомню мы доказываем для
какой серии для вот этой правильно n делить на м n это что количество элементов сколько у нас
количество элементов zp я ответил на твой вопрос вот видишь как хорошо отлично в общем-то перейдем
к икс штрих игрек штрих нам нужно понять какая вероятность того что икс штрих процент м равен
икс штрих процент м потому что мне нужно понять коллизию хэш функции согласны ну икс штрих игрек
штрих они вот этот первый кусок хэш функции который в квадратных скобочках правильно это
понятно пока вот я просто беру вот этот процент м мне нужно понять вероятность того сколько у них
может быть коллизий но здесь все достаточно просто икс штрих мы можем выбрать п различными
способами ну логично у меня п вариантов мы переходим просто от икс игрека к икс штрих игрек
штрих они взаимосвязаны между собой там нет никаких проблем вот икс штрих можно выбрать
по различным способам потому что у нас вычет по п правильно правильно вот какими способами
мы можем выбрать игрек чтобы у нас было равенство
ну типа того да но вот к вот здесь вот у меня просто написано для примера это правда но
действительности п делить на м почему потому что вот эти кусочки я выбираю единственное
чему не может быть равен игрек штрих от чему это икс штрих правильно поэтому я должен буду
вычитать еще минус единицу я округляю это вверх окей ну типа все здесь понятно надеюсь вот максимальное
количество раз это такое но мощность множество у меня какая п на п минус 1 мы только что с вами
про это говорили да да отлично продолжаем это веселье я я я обещал математику я ее приношу вот
продолжаем это же веселье смотрите мы говорим что п делить на м округленное ну во первых
п я могу сократить между собой я думаю вы это понимаете это отлично п делить на м минус 1 ну как
я могу п делить на м представить верхнюю оценку это п плюс м минус 1 делить на м согласны
это максимальная оценка вот делаю минус единицу делю на п минус 1 эту минус единицу я подставляю
туда дальше я получаю что п плюс м минус 1 минус м и все это делить на м п минус 1 окей ну а теперь
вычитаем получаем п минус 1 делить на м п минус 1 получая 1 на м то есть у меня вот это универсальное
семейство хэш функций вероятность их коллизий если я возьму вот зафиксировать эту хэш функцию
какой-нибудь вероятность коллизий там будет всего лишь один делить на м меньше либо равно все
правильно а значит это семейство универсальное а если оно универсальное то у меня за сколько
работает поиск 1 плюс альфа альфа не забывайте n делить на им ну здесь п делить на им в этом
случае принято это принято чудно тогда давайте чуть-чуть дальше существует пример естественно
не универсального хэш семейства давайте просто бы уберем вот уберем бы и все оставим тоже множество
ключей все будет также все то же самое что а без нуля но мы убираем бы что в этом случае происходит
как доказать что семейство не является универсальным нужно найти такие иксы иксы и игреки что у нас
вероятность будет больше чем один делить на м согласны м я могу фиксировать как хочу п могу
фиксировать как хочу а могу выбирать какой хочу x и y аналогично вот но вот это а оно и будет вот
этой вероятностью которую мы вытаскиваем ну смотрите давайте зафиксирую п 7 м 2 x 1 y 3 ну вот
такие вот числа мне пришли в голову догадаться до них но это пример как не знаю ну типа как вы
любите догадываться до по в эмоциональном анализе когда вы выбираете потенциал вот плюс
минус также вот типа взято с потолка покажем что вот поэтому это ближе туда в общем-то мы смотрим
при всех значениях а так у нас выглядит х функции аш от x и аш от y у меня всего две корзины поэтому
это 0 и 0 единички вероятность должна быть меньше чем 1 вторая если бы это было универсальное
семейство х функции в этом же случае если я подставляю а аш от x и аш от y я получаю что
вероятность здесь будет 2 третьих ага а если вероятность 2 третьих это больше чем 1 вторая
получается семейство не универсальное принято вот вот такой вот тут маленький пример а естественно
вы можете по упражняться доказать обратное что давайте мы бы оставим а уберем если вам будет
очень интересно дома по упражняйтесь кто знает может быть вас ждет такой на контрольный вот так
сказать тонко намекаем а подумайте об этом нет а если а равно единички да да я понял под множество
но кто сказал что под множество универсального множества это универсальное множество
по-моему я нигде не утверждал то
да но ты должна понимать что у меня а выбирается единицей но ты ее фиксируешь тогда эту единицу
а я не фиксирую здесь ничего да принято так что подумайте над этим на досуге
окей ну и последнее смотрите мы с вами поговорили про простой равномерное хэширование мы с
вами поговорили про универсальное хэширование теперь перейдем к идеальному хэшированию куда
уж может быть лучше смотрите как работает идеальное хэширование я поверьте я даже
до 2000 закончу хотя посмотрим вот давайте так посмотрим на идеальное хэширование статического
множество идеальное хэширование может работать только вот для статического множества не работает
когда у нас оставляются какие-то элементы потому что они все-таки увеличиваются или что-то с ним
происходит поэтому я фиксирую какое-то множество то есть оно у меня зафиксировано множество вот
этих вот иксов которые принимается я хочу на этом множестве построить хэш таблицу без коллизий вот
это будет универсально идеально потому что тогда я смогу находить элементы за это от единички согласны
понятно то есть никакой операции insert и erase нет у вас есть только поиск понятно вот вы смотрите
вот по этим элементам есть они нет нужно что-то для них тоже доказывать для этих элементов смотрите
пусть это число коллизий в хэш таблице вот когда-нибудь я это поправлю число коллизий в хэш
таблице тогда согласны ли вы с тем что количество коллизий это вот эта сумма с индикатором
аха перебор всех пар но типа в одну сторону что у нас первое всегда меньше число без повторов
все верно согласны с индикатором понятно давайте посчитаем среднее число коллизий в хэш таблицы
размеры м при выборе какого-то аж из универсального семейства то есть я универсальные
семейства все еще держу себя но вот я хочу понять количество коллизий которые у нас есть я выбираю
средняя ну то есть я считаю среднее число коллизий это средняя по сумме индикаторов значит я
могу так как средняя суммы это сумма средних я вношу это среднее внутрь средняя индикатора это
вероятность правильно вернемся к этому же вероятность того что они равны между собой а вероятность
того что равны между собой хэши в универсальном семействе множеств у универсальной семействе
хэшей и горе господи прости оно меньше либо равно одной делить на м правильно поэтому у меня
получается сумма 1 делить на м да ну и получается всего это n на n минус 1 пополам 1 делить на м
согласна принято вот столько у нас может быть коллизий в универсальном семействе хэш функции
окей хотите небольшой перерывчик можете можем устроить типа или вам нужно добить и все
нет у вас сегодня две лекции если что это вторая уже идет ну то есть это вот те два кусочка
которые я должен был вам рассказать побольше а тогда не но все принято хорошо
если знаем туда
а проблема в том что ты должен сначала считать все вот эти вот элементы которые к тебе придут
ты не можешь работать без вся нет вставки в идеальном хэширование еще раз ага вот есть
проблема в общем-то что нам нужно еще нам нужно кое-что еще есть и р вера называется это леммой
маркова слышал кто-нибудь такое слышал познакомитесь более обобщенном виде в действительности
что такое леммаркова леммаркова говорит следующее что пусть у меня x это какая-то случайная
величина там вот мы будем рассматривать на натуральных числах с ноликом вот тогда для
любого эпсилон больше нуля вероятность того что x больше чем эпсилон вот эта случайная величина
больше чем эпсилон она меньше либо равна чем средний x делить на эпсилон понятно
вот суть такая как это доказывается доказать через среднее икса средний икса это просто
сумма всех вероятностей к сов на x да это больше либо равно чем я икс ограничусь снизу икс больше
согласно ну я просто типа убрал кусочек нижний отлично а если я брал кусочек нижний то это больше
либо равно чем я бы взял x равный эпсилон ага эпсилон я могу вынести у меня остается просто
сумма всех вероятностей x равно x на сумму всех вероятностей это вероятность того что x больше
бравен а тут эпсилон ссоре не x маленькая и эпсилон окей как бы это логично да
понятно почему сумма вероятности что x больше эпсилон это то же самое что вероятность что x
больше эпсилон не страшно не отвечаете да в действительности это так хорошо давайте я
утвержду этот момент вот да там x маленькая это некорректно вот этот кусочек там неправильно
да конечно но это маленький кусок ну типа здесь очень просто вам она понадобится это
лемма понимаете типа я не даю просто так вот в чем проблема
вас ну смотрите это не мотана тярвера другое понимая но что поделать пока что вот так поверьте
концу семестры мы будем рассказывать и показывать на руках но вот когда-то кто-то ко мне подходил
говорил очень нематематично непонятно почему вот математика нужно с ней жить в общем-то про
идеальное хэширование что важно помнить давайте спокойнее спокойнее друзья ага в общем-то а
какая здесь теорема с идеальным хэшированием это вот теорема 2 я назвал смотрите пусть h из
универсального семейства и m это n квадрат то есть количество бакетов это n квадрат тогда
вероятность коллизии что количество коллизии больше единички меньше чем 1 вторая интересный
факт как-то мы можем доказать мы можем доказать просто следующим образом посмотрите вероятность
того что це больше либо равно 1 1 то есть количество коллизии больше либо равно 1 оно
полиеми маркова меньше либо равно чем средняя ци делить на единицу согласны согласны отлично
а что такое средняя по ц ну средняя ц мы уже тоже посчитали это n на n минус 1 пополам на 1
дельтаем согласны а ну травну а не больше да сори лага вот не больше дальше просто
вместо m подставляю n квадрат но я надеюсь что вы справите что n минус 1 делить на n делить
на 2 n это меньше 1 и 2 правильно нет на 2 n n минус 1 делить на 2 но n шутки 1 я сократить
могу да ладно извините но я надеюсь этот факт вам понятен получается это меньше 1
отлично то есть у нас в случае m равны n квадрат вероятность того что количество коллизии будет
больше единиц и больше либо равно это 1 2 меньше 1 2 это очень мало у вас грубо говоря за две
итерации вот если вы один раз сделали у вас не получилось и у вас появились коллизии сделайте
второй раз и у вас скорее всего получится построить нужную хэштаблицу без коллизий согласны
то есть я все также беру универсальное семейство хэш функции просто размер бакет в делу n квадрат
вот но в чем проблема здесь ну не памяти много действительность у нас проблема в том что m
равно n квадрат вы представьте что у вас количество ключей возможных типа которые приходят вам это
там 10 9 это кошмар это очень очень много поэтому здесь есть проблема память проблема действительно
с памятью какая идея решений проблема с этой памятью а давайте мы сделаем следующее что мы
заведем хэштаблицу каждый ячейки который будем хранить другую хэштаблицу вот и для того чтобы то
есть грубо говоря мы не будем вот так вот делать методом цепочек которые у нас там есть а если у
нас будут какие-нибудь коллизии то мы внутри еще раз захешируем элементики то есть у нас был
один хэш есть коллизия мы переходим к маленьким хэшам типа вот и мы перехешируем их и тогда
у меня внутри там n квадрат согласны ли вы с тем что если я возьму там новую хэш функцию грубо
говоря и постараюсь переделать что-то то там будет вероятность коллизии 1 2 меньше 1 2 по
той теореме которая была согласна то есть давайте еще раз в чем суть его часть вот этого всего
вот представьте что у меня есть вот этот кусок у меня здесь ашат икс какой-то он может быть равен
там не на ашат игрек для того чтобы разрешить эту коллизию я хочу здесь вести новую хэштаблицу
где у меня будет x и y аш штрих от аш от икс и аш штрих от аш от игрек а нет нет не ашат игрек
ашат аш трих от игрек и аш трих от икс сори вот так а если у меня размер вот этого кусочка
м квадрат ой н квадрат н и т в квадрате н и т это количество коллизий по факту вот в тот
или иной момент времени вот если у меня н и т в квадрате то вот это количество коллизий здесь
вероятность коллизий меньше чем 1 2 согласны понятно как я пришел к этому выводу задайте вопрос
да потому что через цепочки оно все-таки занимает время я хочу для идеально сделать
за это от единички я хочу сделать прям вот это от единицы честная вот что мы в этом случае
вообще будем делать и как вообще жить вот смотрите я для каждой вот такой вот ячейки
которые у меня есть буду делать свои хэштаблички вот и буду делать эти хэштаблички на там м1 равно
н1 в квадрате ну и так далее там м и т равно н и т квадрате я вот создаю такие вот хэштаблички
внутри когда у меня появляются коллизии в этом случае у меня все отлично все хорошо потому что
у меня вероятность коллизии маленькая и если вдруг будет какая-то коллизия внутри вот этих
маленьких хэштабличек тогда в случае я просто перехаширую мою таблицу и где-то на второй
террации вас точно должно все заработать ну в хорошем случае если вы не заработает
да но это достаточно не много вот окей последняя теорема 3 а кто нам вообще сказал что вот это вот
эффективно по памяти ну по сути своей частично тогда вот но нам нужно по-хорошему просто показать
что вероятно ну что если у меня m равно n вот это вот м глобально то есть количество бакетов аж
это универсальное семейство хэш функции и в корзину и ты попала и ты элементиков тогда средняя сумма
н и т в квадрате оно меньше чем 2 н почему это мне важно потому что для меня n квадрат это много
но все-таки 2 н это не н квадрат это удобно правильно все должны показать что сумма вот этих квадратов
которые у меня здесь будет она будет не более чем 2 н а мне нужно это посчитать ну как я это
посчитаю смотрите я беру среднее от н и т в квадрате давайте я перепишу что мы раскладываем
просто квадрат в начале смотрите у меня 2 на н и т н и т минус 1 пополам плюс н и т ну как бы если
вы все это сложите получите н и т в квадрат согласны заметим что все правильно очевидно что все верно
вот а дальше мы смотрим на все это чудо и смотрите что такое н и т на н и т минус 1 пополам это количество
коллизий внутри одного кусочка согласны да вот я делаю сумму по всем этим кусочкам это есть
количество коллизий согласны вот ваше количество коллизий которое возможно получается это у меня
два средних количество коллизий но а н и т ну мы просуммируем н и т и все это сколько у нас
элементов есть нашим x правильно это n согласны вот отлично получается два средних c плюс n что
такое средняя ц это n на n минус 1 пополам 1 на m двоечки сокращаются я говорю что m равно n поэтому
у меня получается здесь что здесь получается n минус 1 плюс n это 2 n минус 1 это меньше чем 2 n
согласны все верно именно так понимаю что может быть трудно но это последнее все больше
никакой мы никакой математики на сегодня вот вроде когда если я не ошибаюсь какое здесь
важное следствие важное следствие здесь следующее что вероятность того что н и
т сумма н и т в квадрате больше либо равно чем 4 н меньше чем 1 вторая благодаря тому среднему
который мы посчитали то есть мы посчитали среднее количество объектов н и т в квадрате теперь
я говорю что у меня вероятность тоже она меньше одной второй почему ну потому что я просто применю
лен маркова окей просто применил лен маркова у меня был 4 н я делаю 2 н делить на 4 н получаю
одну вторую понятно запомните этот факт для этого вам здесь помогают а этот факт этот факт нам
нужен для следующего что у нас не будет количество вот этих вот бакетов то смотреть
средний это мы посчитаем нас интересует вероятность того что вот это не огромная какая-то
штука по памяти потому что ну чисто случайно у вас может быть что все-таки н квадрат будет
вот а мне не нужно мне нужно сказать что у меня должно быть 4 н вот но в действительности короче
появляется так что вот это называется алгоритм фкс честно не помню фамилия но когда-то на
экзамене мне сказали что это алгоритм ки и все от этого меня прям порвало в тот момент поэтому
не делайте так пожалуйста вот запомните последовательность буквок в общем-то смотрите
какой алгоритм вот этого двойного хэширования по сути алгоритм следующий мы строим внешнюю
хэш таблицу m равно n выбирая случайно какое-то универсальное семейство хэш функций существуют
универсальные семейства хэш функций для строк для всего остального мы смотрим рассмотреть только
для чисел например вот выбираем хэшируем все необходимые нам данные которые даны вот самого
начала то есть от x1 до xn смотрим на количество коллизий мы понимаем сколько здесь элементов
каждым бакете лежит согласны я их смотрю и такой ага если их больше чем 4 н то мне не нравится эта
хэш функция я и перед перебираю новую и беру новую эту хэш функцию то есть повторяем первый
пункт заново для чего мы это делаем для того чтобы вот здесь было линейно благодаря тому что мы
сказали что вероятность того что больше чем 4 н меньше чем 1 вторая это означает что за
пару итераций мы точно эту найдем хэш функцию мы не будем бесконечно долго ходить это пару итераций
окей понятно зачем мы доказывали вот это меньше 1 вторая вот то есть нас не будет какой-то большой
большой здесь хэш табличек отлично что мы делаем дальше дальше мы просто для каждой ячейки и ты
строим свою хэш табличку а размера м это равно н это в квадрате и выбираем ошитое то с тем
фиксируем конкретно ошитое выбираем из универсального семейства хэш функции но если
на числах то это просто а и б мы просто рандомно выбираем и дальше если у нас есть коллизии в
хэш таблице то в этом случае мы перехашируем ее благо вероятность коллизии меньше чем 1 2 помните
этот факт помните вот поэтому это займет тоже пару итераций таким образом вот вы может быть
и террироваться будете типа какое-то время но в то же время для вот этого статического множества
вы построите хэш таблицу который вы за у от единицы сможете найти необходимые вам вещи вот поэтому
find в этом алгоритме будет работать достаточно просто это нужно проверить что x равно б ошитое от x
то есть тот элементик который там хранится мы же по индексам ходим все вот как-то так вот
здесь возможно скобочек только не хватает но это ладно а что важно про этот алгоритм знать
знаю важно знать что время работает в алгоритм от это отн почему ну потому что построить хэш
это вот это это даже отн то есть мы не сверху просто ограничим и снизу ограничен нам нужно
пересчитать все хэши которые есть этот отн дальше перестроить хэш таблички вот здесь вот
который у меня есть ну для каждого это тоже займет там n 1 в квадрате но когда мы просуммируем
это не больше чем n это отн не больше чем 4 н мы будем делать отлично там мы тоже перехашируем ну
получим через какое-то количество итерации получаем это отн памяти это занимает это отн
но отн точнее вот и последнее но поиск в лучшем случае этот этот единички потому что у нас есть
нет коллизий мы не смотрим элементы дальше мы всегда просто заходим мы берем элемент понятно
вот это алгоритма в кс это все будет будет на экзамене все доказательства тоже будут вот да
до вы его будете делать как раз вот я вам просто последнее время специально не пишу код чтобы вы
посидели почитали и сами написали вот на этом в принципе все я вас даже не сильно задержал
