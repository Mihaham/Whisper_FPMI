Начнем лекцию. Сегодня мы так условно заканчиваем первый модуль нашего курса, который был посвящен
ведению объектно-ориентированного программирования. В целом, мы заканчиваем с темами первого задания.
Заканчиваем, на самом деле, чуть ли не наиболее важной темой в нашем курсе. Это конструкторы и деструкторы.
Если задать какой-нибудь вопрос, что самое главное, что отличает язык C++ от языка C, или, в принципе,
объектно-ориентированные языки не объектно-ориентированные, то, наверное, это конструкторы и деструкторы.
Потому что это, наверное, наиболее важная вещь, наиболее существенная часть, которая из языка C++
делает, собственно, язык C++. В принципе, все остальное, это какой-то сахар, какой-то гарнирка
и ко всему остальному. Ну а конструкторы и деструкторы, в принципе, очень важная тема.
И очень хотелось бы, чтобы все в ней разобрались. Достаточно понагнетал? Все напряжены?
Окей, давайте начнем. А начнем мы с того, что скроем некоторые проблемы, которые у нас появились
после прошлой лекции. Вообще у нас с любой занятией будет стоять из следующих вещей.
Мы будем ставить какую-то проблему, с ней бороться, то есть в итоге поборем, но на следующей лекции
выясним, что появились дополнительные проблемы, которые нам нужно решать и так далее.
То есть постоянно мы будем решать какие-то проблемы, у нас будут появляться новые.
Ну кроме последней лекции. Я надеюсь, что после последней лекции мы более-менее все проблемы решим.
Итак, давайте вспомним класс стека, который мы писали в прошлый раз.
Напомню, у нас был класс стека. Мы в приватную область занесли все детали реализации,
а в частности указатель на буфер, то есть мы реализуем стек на массиве.
Дальше в приватной части у нас также сам размер стека хранится, в смысле значение размера.
Ну и мы говорим, что у нас вместимость стека фиксированная, равна сотне,
ну просто для простоты реализации, чтобы не загромождать слайды,
ну и чтобы вам было что решать в домашних задачах.
И мы вынесли в публичную часть весь интерфейс стека, то есть как с ним можно взаимодействовать.
То есть есть метода init finalize, которую мы вызываем в начале работы со стеком и в конце работы со стеком.
И ввели методы push, pop и top, стандартные методы для взаимодействия со стеком.
Добавить элемент, удалить элемент и получить верхний элемент.
Ну и константный метод top size и empty, который позволяет получить размер,
узнать пусть ли стек или получить верхний элемент стека, даже если он константен.
Ну и метод capacity, который говорит пользователю,
какое максимальное количество элементов может наш стек вместить.
И написали вроде как классный стек. В прошлый раз все были очень счастливы,
звонили родственникам, вот какой стек мы написали, все очень круто.
Но вот я утверждаю, что этот стек очень-очень плох.
Ну пока еще.
Давайте подумаем, что вам не нравится вот в такой реализации класса stack?
Что в ней не так?
От чего бы хотелось, может быть, избавиться? Что бы хотелось добавить?
Замечательно, у вас очень разное чувство прекрасного, действительно.
Мы вроде как в прошлый раз договорились, что не очень хорошо, наверное,
самостоятельно как-то выделять память, самостоятельно устанавливать размер,
самостоятельно очищать, то есть вызывать new, delete и так далее.
И мы сказали, ну хорошо, давайте это все скроем внутрь специальных методов.
init finalize, то есть когда нам нужно создать стек, мы вызываем метод init,
когда нам нужно завершить работу со стеком, мы вызываем мету finalize.
А теперь давайте задумываемся над таким вопросом.
А чем это, вообще говоря, отличается вот вызова new и delete?
Ну хорошо, нам не нужно знать о деталях реализации стека,
то есть нам не нужно знать о том, что стек на самом деле реализован в виде
какой-то динамического массива. Но все равно вот сама процедура,
что-то сделать в начале и что-то обязательно сделать в конце, она сохранилась.
То есть если мы не вызовем init, у нас стек не заработает.
Если мы не вызовем finalize, у нас будет утечка ресурсов и так далее.
То есть об этом все еще нужно думать.
Более того, ну вот хорошо, мы написали класс stack.
Кто-то другой написал класс массива, кто-то другой написал класс очереди и так далее.
И каждый из них назвал по-своему. Кто-то назвал init, кто-то назвал метод start,
кто-то назвал констракт и так далее.
Вам нужно для каждого класса помнить, а что нужно на самом деле вызвать,
чтобы он заработал, или что нужно на самом деле вызвать, чтобы он закончил работу.
Согласитесь, это не очень удобно.
Ну вот ровно то, про что я говорил.
Нам необходимо все еще вручную инициализировать объект.
После того, как мы создали объект стека, нам нужно обязательно вызвать метод init.
Если мы его не вызовем, то стек у нас не заработает.
Еще одна проблема, которая не сразу приходит в голову, но тем не менее она существует.
А что, если я захочу завести константный стек?
Давайте пока не думать о том, зачем это нам нужно.
Наверное, константный стек не совсем имеет смысл.
Вы пишете класс массива, и вам нужно завести константный массив,
который хранит определенное количество значений, причем фиксированное.
Я хочу завести константный стек, который никак не меняется.
Вопрос, как мне его пронициализировать?
Только оказывается, что никак.
Потому что метод init, естественно, я вызвать не могу.
Потому что init у меня изменяет стек, согласны?
Как я могу преодолеть эту проблему?
Могу ли я у константного стека вызвать init как-то?
Да, я могу сделать метод init константным.
Но если я сделаю метод init константным, то это сразу же повлечет за собой то,
что я должен все поля сделать mutable.
Но это как-то странно.
То есть я все поля разрешаю менять в константных методах.
Это странно.
Вот возникает такая проблема.
Константный объект я инициализировать не могу.
Проблема с копированием.
Давайте подумаем над тем, что должно происходить при копировании объектов.
Вот у меня есть стек.
Я, кстати, тут забыл вызвать метод init.
И это вот как раз эта проблема, про которую мы говорили.
Хорошо, я создал стек, сделал init и запушил туда один элемент.
А дальше решил создать копию объекта стек.
Вот когда вы создаете копию какого-то объекта, что вы ожидаете, какого поведения?
Наверное, вы ожидаете, что у вас будут две независимые копии.
То есть можно работать с одним стеком, можно работать с другим стеком.
Но при этом в одном стеке один стек создастся с теми же элементами, который был в исходном стеке.
Но что происходит при копировании структур?
Или при копировании классов сейчас?
Когда вы одну структуру копируете в другую, что происходит?
Да, просто побитовое копирование.
То есть каждое поле копируется в другое.
То есть что у нас было?
У нас был объект стек, у которого был буфер, который указывал куда-то в динамическую область памяти и хранил там массив.
Ну и также есть у него свой size, который равен единице.
И вы завели стек other, у которого тоже есть поле буфер, у которого есть поле size.
Хорошо, size вы скопировали, он стал равен единице.
А что стало с буфером у other?
Он теперь указывает на ту же область памяти, что и исходный стек.
То есть теперь и первый стек, и второй стек указывают в одну и ту же область памяти.
Что это в свою очередь означает?
Это означает, что если я буду вставлять элементы в первый стек или буду вставлять элементы в второй стек, у меня оба стека увидят эти изменения.
Да?
Беда.
Хотелось бы наверное иметь две независимые копии.
Более того, смотрите еще какая проблема.
Ну смотрите, у меня есть в моей программе два объекта типа стек.
Ну это собственно стек и other.
Вопрос, кто из них должен называть met finalize?
Что произойдет, если я у них обоих буду вызывать finalize?
Будет это проблема или нет?
Да, будет double free.
Ну то есть формально это undefined behavior, то есть непонятно, что произойдет, но скорее всего вы получите ошибку double free.
То есть вы два раза очищаете одну и ту же память.
Чего делать нельзя.
Снова беда.
Окей.
Ну и наконец с finalize.
Ну та же самая проблема, что и с init.
То есть его нужно постоянно вызывать вручную.
Более того, если у вас есть стек, который содержит внутри себя какие-то другие стеки,
то вам нужно делать просто те же самые действия, что вы делали при создании динамического доумерного массива.
То есть мы в цикле добавляем элемент в стек,
для каждого из них вызываем met init,
а потом в цикле, чтобы очистить стек, нам нужно для каждого элемента вызвать finalize,
и только потом вызвать finalize для внешнего стека.
Совсем беда, совсем плохо.
Согласны?
И вот я утверждаю, что на сегодняшней лекции мы все эти проблемы поборем,
и все у нас будет замечательно.
Ну и первым, с чем мы начнем,
это с конструкторов.
Да.
Ну, определение.
Конструктор – это особый метод класса,
который вызывается всякий раз при создании объекта.
То есть конструктор – это метод, который вызывается неявно при создании объекта.
В чем особенности этого метода?
Особенность этого метода заключается в том,
что он не имеет возвращаемого значения,
то есть возвращаемое значение у него писать не нужно.
Не void ничего, то есть единственное значение конструктора – это создать объект.
Дальше.
Имя этого метода обязаны совпадать с именем класса.
То есть если вы пишете метод, у которого имя совпадает с именем класса,
это конструктор.
Ну и конструктор вызывается неявно при создании объекта.
То есть вручную конструктор вам вызывать не нужно.
Он вызывается всякий раз, когда вы создаете объект.
Когда вы создаете объект,
когда вы создаете объект, конструктор вызывается автоматом.
Ну давайте попробуем написать какой-нибудь пример конструктора для класса stack.
Ну вот пример. Что тут происходит?
У меня имя метода совпадает с именем класса stack.
Этот конструктор в данной ситуации ничего не принимает.
Видно, что он ничего не возвращает.
Ну и дальше я просто фигурно-скопко пишу те действия, которые мне необходимо сделать.
Но в частности, при создании stack мне нужно проинитилизировать буфер,
то есть выделить память. Ну и сказать, что size равен нулю.
Ну и написав такой конструктор, теперь при создании объекта stack
у меня все вот эти действия будут выполняться автоматически.
То есть теперь вот в этой строке происходит,
ну во-первых, создается переменная типа stack,
а во-вторых, сам stack инициализируется вот таким способом, как я описал.
То есть таким образом мы вроде как избавились от метода init.
Круто? Вот.
Ну и теперь давайте, ну собственно это такой небольшой пример,
значит все понятно, то есть по синтаксису.
Сейчас мы будем подробно обсуждать все виды стеков,
все виды конструкторов, какие они бывают и так далее.
В смысле, типа void.
Ну типа как-то вот так.
Скорее всего он скажет, что вы неправильно пишете конструктор.
Не обязательно.
Естественно, если вы пишете конструкторы,
то как и любые другие методы могут быть написаны
как в публичной области, так и в приватной области.
Если вы пишете конструктор в приватной области,
то это означает, что внешний код не имеет права пользоваться этим конструктором.
Ну вот в частности давайте,
что произойдет, если я тут public заменю на private.
У меня вот эта строка, последняя,
она просто наоборот не скомпилируется.
Потому что в этом месте компилятор попытается вызвать конструктор,
но зафейлится, потому что он приватный.
И на самом деле существует целая классификация видов конструкторов.
И каждый их из них обладает своими свойствами.
Классическая классификация выглядит следующим образом.
Есть параметрический конструктор,
есть конструктор преобразования,
есть конструктор по умолчанию,
есть конструктор копирования, есть конструктор перемещения.
Ну про конструктор перемещение будет отдельная история,
будем говорить через несколько лекций.
это отдельная история, будем говорить через несколько лекций.
Давайте поподробнее мы говорим про каждый из этих видов.
Первый вид erstуктора самый простой – параметрический конструктор.
Давайте будем называть параметрическим конструктором
любой конструктор, который может принимать более одного аргумента Л丈夫.
Если конструктор принимает более одного аргумента,
то будем говорить, что это просто обычный параметрический конструктор.
Большой пример.
Допустим, я хочу уметь создавать стэки таким образом.
Я хочу стэку передавать размер и те элементы, которые он должен хранить изначально.
Допустим, я хочу создать стэк, который изначально заполнен 10 единицами.
Я хочу уметь так делать, потому что мне так удобнее, допустим.
Я не хочу в цикле вызывать push, я хочу, чтобы у меня сразу стэк был определенного размера с определенными значениями.
Чтобы так сделать, я могу написать конструктор.
Я пишу стэк, снова без возвращаемого значения, снова метод называется так же, как и обычный класс.
Ну и дальше я передаю ему аргументы.
Соответственно, первый метод это size, то есть каким размером мне нужно проинитиализировать стэк.
Ну и второй параметр, это какими значениями мне нужно стэк заполнить.
Ну и дальше в фигурных скобках я делаю необходимые действия.
Завожу новый буфер, завожу, соответственно, инициализирую size,
в значении не инициализирую, а присваиваю size нужное значение.
И в цикле, собственно, заполняю мой стэк.
И теперь как я могу вызвать этот конструктор?
Теперь, когда у меня есть такой конструктор, который вынимает два аргумента,
я могу создавать стэк с помощью аргумента вот таким образом.
То есть я пишу имя типа или переменный, и дальше в круглых скобках я указываю,
с какими параметрами мне нужно проинитиализировать этот стэк.
И вот эта запись означает, что при создании стэка у меня будет вызван вот этот конструктор, который описан выше.
Ну альтернативные способы создания здесь также указаны.
Можно через присваивающую инициализацию это все делать абсолютно эквивалентно.
Ну все, после того как у меня отработал этот конструктор, я могу спокойно обращаться к size, к top,
и, собственно, все работает так, как нужно.
Теперь давайте поговорим о важной детали конструкторов, про списки инициализации.
Значит, давайте рассмотрим такой пример.
Вот представьте себе, что у меня есть класс B, у которого есть константное поле типа int,
и у которого есть ссылочное поле, которое ссылается на double.
Вот x и y. x это константа, y это ссылка.
И вот я хочу написать конструктор, который в конструкторе, который в качестве параметров принимает
значение, которое должен быть проинитиализирован x, и значение, которым должен быть проинитиализирован y.
Ну точнее значение, с которым должен связаться y.
Ну и в конструкторе я, собственно, что делаю. Я говорю, что x у меня должен быть равен x,
у которого мне передали, и y должен ссылаться на y, который мне передали.
Ну казалось бы, все нормально. Ну и дальше я создаю объект типа B,
передаю ему 0 и z. То есть понятно, что в качестве второго аргумента я могу передать только
так называемое lvalue, то есть, грубо говоря, переменную или то, что имеет какое-то место в памяти,
потому что на это можно было ссылаться.
Вот как вы думаете, все ли будет нормально?
Почему?
А нет, в чем проблема?
Методы же могут обращаться к приватным полям.
Ну то есть если бы мы не могли в принципе обращаться к приватным полям,
тогда бы конструкторы были нафиг не нужны, потому что если конструкторы не могут
обращаться к приватным полям, то как они тогда что-то инициализируют?
То есть, естественно, конструкторы к приватным вариантам тоже имеют доступ.
На самом деле будет довольно неожиданная проблема.
Компилятор нам скажет, что, во-первых, у меня не проинициализировано
константное поле x в первой строке.
Во-вторых, он скажет, что у меня не проинициализирована ссылка
во второй строке.
И в-третьих, он скажет, что по какой-то причине я пытаюсь сделать присваивание
члену, который доступен только на чтение.
Что-то не то происходит, да?
То есть, казалось бы, я сделал x равно x, y равно y,
то есть вроде как я их проинициализировал.
А компилятор жалуется, что я их не проинициализировал это раз,
а во-вторых, он жалуется, что я пытаюсь как-то изменить
поле, которое доступно только для чтения.
Но в частности, это x.
Ну и проблема на самом деле заключается в следующем.
На самом деле то, что вы пишете внутри фигурных скобок в конструкторе,
это не инициализация.
Ну, точнее так.
Это инициализация, но это инициализация стека.
Вот.
Вот то, что Вы пишете здесь,
это...
это присваивание, анициализация.
Давайте так скажем.
Смотрите, чтобы вам к чему-то оборотиться внутри фигурных скобок,
Вам нужно что-бы это что-то было уже создано.
Согласны?
Допустим, что-бы я мог обратиться к x чертой,
это x чертой должно быть уже где-то создано,
должно уже быть как-то проинициализировано.
y с чертой то же самое.
Что-бы я мог обратиться к y с чертой,
оно тоже должно быть как-то уже проинициализировано.
То есть, грубо говоря, внутри у меня все поля
и дальше внутри фигуринскобок я с ними только работаю.
Но в частности, вот тут я пытаюсь заново присвоить какое-то другое значение х
и заново присвоить какое-то другое значение в у.
Понятно? Понятно разница между присваиванием и инициализацией?
То есть, грубо говоря, когда я пишу вот так, это что?
Инициализация или присваивание?
Инициализация. Да, я задаю начальное значение при создании.
А вот это? Это присваивание.
Да, то есть х у меня уже проинциализирован, то есть х у меня уже есть в памяти,
он уже создан, и дальше я просто заменяю его значение.
Вот в конструкторе происходит то же самое.
Когда вы заходите в тело конструктора,
предполагается, что все элементы, все поля уже проинциализированы.
Понятно?
Ну и возникает парадокс C++ очередной.
Мне нужно как-то проинциализировать поля,
и мне их нужно проинциализировать в конструкторе.
Но как только я захожу в конструктор, они уже проинциализированы.
Что делать?
Внутри фигурных скобок, то есть внутри тела конструктора,
я их проинциализировать не могу.
где мне их нужно проинциализировать?
На самом деле, мне их нужно проинциализировать до входа тела конструктора.
То есть до фигurdных скобок внезапно.
И вот такой синтаксис называется...
Как называется?
ès Shelley
Как проинициализировать поля класса правильно? Делайте следующим образом.
До входа в тело конструктора, то есть между прототипом конструктора и между телом конструктора,
то есть открывающейся фигурной скопкой, вы пишете следующую вещь.
Двоеточие. Ну и даже через запятую инициализируйте поля.
Вот то, что пишется вот здесь, вот здесь происходит инициализация.
То есть вы задаете начальные значения ваших полей.
Вот если я напишу так, то теперь все будет работать как надо.
То есть если я попытаюсь создать объект B с помощью нуля и Z,
у меня X чертой проинициализируется нулем, Y чертой проинициализируется ссылкой на Z,
и дальше, когда я вошел в тело конструктора, у меня уже вот эти значения будут проинициализированы нужными значениями,
и я могу с ними как-то дальше продолжать работать. Понятно?
Да, об этом будет отдельный слайд. Важно.
Точнее так, не важно, но мы поговорим об этом.
Все понятно, что здесь происходит.
Вот то, что вы пишете здесь, то, что помечено здесь, это инициализация.
Вы сдаете начальное значение. Поэтому важное правило.
Если вы хотите что-то проинициализировать, то есть вы хотите задать какие-то начальные значения в конструкторе,
старайтесь это как можно больше делать в списках инициализации,
потому что это правильнее.
Если вы так не делаете, то давайте вернемся к стеку.
Что здесь происходит? Здесь происходит следующая вещь.
Сначала компилятор вам создает ваши переменные по умолчанию,
а затем вы как будто бы присваиваете,
если вы не написали список инициализации, то компилятор это все проинициализирует как-то по умолчанию.
То есть он сначала их создает, и сохранит какое-то мусорное значение, которое лежало в памяти до этого.
А уже потом, после этого, вы пытаетесь что-то менять.
В частности, пишете size равно чему-то, и буфер равно чему-то.
Вместо того, чтобы сразу вы не выкопали, а вы не выкопали,
то есть вы не выкопали, а вы не выкопали.
И буфер равно чему-то.
Вместо того, чтобы сразу написать то, что вы хотите.
Согласитесь, что второй способ гораздо более эффективный, чем первый.
В данном случае не более эффективный, но представьте, что с качества полей возникают какие-то другие тяжелые объекты.
Когда вы сначала создаете тяжелый объект, а потом внутри конструктора сразу его как-то изменяете.
Согласитесь, гораздо логично сразу создать его таким, каким он должен быть.
А если мы, например, как-то инициируем объект, который намного сложнее чем переменная,
например, это список, то участием можно создать функцию, которая будет возвращать, например, носик,
и указать в спокус при децентрализации функцию от нашего агумента и стат.
Что вы имеете в виду?
Если у вас само поле является каким-то другим объектом,
во-первых, в списке инициализации мы об этом поговорим позже, но можно вызывать другие конструкторы.
То есть объект можно проинциализировать его конструктором.
Если у вас поле поддерживает конструктор, то вы можете...
Пусть у B есть поле stack.
И вот я могу списки инициализации через двоеточие указать до фигурной скобки.
Указать S и в скобках указать параметры конструктора, и тогда он создается.
Если вам нужна какая-то более сложная инициализация,
можно написать какую-то функцию, которая возвращает нужный вам объект.
И вы ее можете передать в круглой скобке, но тогда это будет работать как то,
что вы внутри функции F создали объект, а потом его скопировали в нужный вам.
Копирования, скорее всего, не будет, но грубо говоря, так.
Ну и здесь то, про что я говорил минут назад.
Если вы не пишете список инициализации, то компилятор все равно его вам напишет,
но только он все поля проинциализирует так, как он хочет.
Грубо говоря, если это просто какие-то инты в латын, то-есть примитивный тип,
он там просто ничего не инфтилизирует не будет, просто там сохранится мусор.
А если поля являются этими классами или структурами,
то они будут проинциализированы по умолчанию.
Про то, что такое по умолчанию, что такое конструктор по умолчанию, поговорим позже.
В общем, самое главное, который надо помнить, что даже если вы не пишете списка инициализации,
компилятор все равно его напишет за вас, но вам может не понравится, что он там напишет.
Потому что компилятор не может проинцелизировать константы.
Он пытается проинцелизировать, но если у него что-то не получается, то он паникует.
Вот константы сами по себе не инцелизируются. Ну вы помните.
Ну и ссылки сами по себе никак не инцелизируются.
Вот поэтому тут проблема.
Если бы тут был просто int или просто double, то все было бы нормально.
Обычные значения инцелизируются мусором.
Да, ну и тут вот как раз второй пункт.
Если какое-то поле не проинцелизировано, то компилятор попытается проинцелизировать его самостоятельно.
Вот важное слово «попытается», но у него может не получиться.
Если не получится, то вы получите ошибку компиляции, естественно.
И тот вопрос, который вы задавали про порядок в списке инцелизации.
Значит, порядок создания полей определяется порядком следования их внутри класса, а не внутри списка инцелизации.
Короче, компилятор будет инцелизировать ваши поля ровно в том порядке, в котором вы указали их в структуре,
в котором они перечислены вот здесь.
Вот порядок здесь компилятор будет игнорировать полностью.
Ну вот пример такой, классическая ошибка.
У меня есть структура A, у которой есть три поля интовых X, Y и Z.
И я хочу, чтобы все три поля были сразу проинцелизированы одним и тем же значением,
которое я передаю в конструктор, то есть в value.
Ну и как бы я делаю следующий вещь.
Я говорю, ну давайте я сначала проинцелизирую Z, передам ему значение в value.
Дальше я проинцелизирую X тем же значением, который лежит в Z.
Ну как бы я предполагаю, что в Z у меня сейчас лежит в value.
Казалось бы, все нормально.
Ну а потом X я проинцелизирую тем же, что лежит в Y.
В этом случае лежит тоже в value.
То есть я предполагаю, что все поля у меня проинцелизируются значением в данном случае 11.
Но при этом, когда я попытаюсь вывести на экран, то я увижу,
что 11 у меня проинцелизировался только Z,
а все остальные содержат какие-то странные значения.
Почему так получилось?
А потому что компилятору плевать, что вы написали списки интеллизации.
Точнее плевать в каком порядке вы что-то написали.
Компилятор сначала посмотрит и увидит.
Сначала идет поле X, поэтому он интеллизирует X, Y.
А в Y хранится мусор, поэтому X тоже проинцелизируется мусором.
Дальше он смотрит, дальше идет Y, поэтому он интеллизирует Y.
В Z лежит мусор, поэтому в Y лежит теперь какой-то другой мусор.
То есть старый мусор убрали, новый положили.
И только в конце самом проинцелизируется Z.
Ну вот Z как раз повезло, и он будет проинцелизирован нормально.
А вот вы когда описывали списки интеллизации,
я как-то поняла, что у нас при создании перемены
сразу где-то описывается то, что с кодом.
Чего же здесь уйдет, например, о моей зафотографии с мусором,
кто дал вам?
Ну смотрите, что такое перемена?
Перемена – это ссылка на область памяти.
Грубо говоря, когда вы звели какое-то имя,
вот этому имени уже поставлена в соответствие какая-то область памяти,
но еще не проинцелизированная.
И здесь как раз про то же самое.
За Y может закопиться, грубо говоря, вот у вас есть адрес дома,
вы купили строящийся дом.
Место вроде как у вас есть, а дом сам не построен.
Адрес вы можете там прочитать.
То есть Y связан с каким-то местом в памяти, но оно еще не проинцелизировано.
Ну и правильный вариант выглядит следующим образом.
Что про инцелизацию?
Минцелизация в ровном том порядке, в котором она указана в полях структуры.
Вот если вы сделаете так, сначала проинцелизируете X,
потом Y проинцелизируете тем же, чем проинцелизирован X,
а дальше Z проинцелизируете Y,
то все будет работать нормально.
Потому что сначала инцелизируется X, туда записывается value,
дальше Y проинцелизируется X,
там уже нормальное значение,
Вот так работают. Понятно?
То есть порядок создания полей определяется порядком объявления в классе,
но не порядком списка инициализации, это важно.
Ну и нормальный компилятор на самом деле вам скажет, что вы делаете что-то не так,
если вы написали в списке инициализации в другом порядке.
То есть если вы с достаточным уровнем предупреждения его поставили,
то компилятор такие ситуации отслеживает и вам выдает предупреждение.
Так, идем дальше...
Следующий вид конструктора.
Я напомню, мы разбираем виды конструктора.
Вот если ровно один аргумент, то это конструктор преобразования.
Вообще говоря, конструктор преобразования — это более широкое понятие,
но, как правило, удовольствуются таким, и это нормально.
Почему конструктор преобразования называется конструктором преобразования?
Ну, потому что он используется для выполнения всевозможных преобразований типов.
Например, вы знаете, что существуют стандартные преобразования типов.
Типы float в double, int в long — типы могут преобразовываться друг в друга.
Конструктор преобразования тоже может быть использован для преобразования одного типа в тип вашего класса, например.
Вот пример. Я хочу написать конструктор стека, который принимает только один аргумент — это размер стека.
То есть какое количество элементов у меня должно изначально лежать в стеке.
Ну и все эти элементы я, допустим, хочу инициализировать нулем.
То есть вот такой конструктор у меня создает size элементов, равных нулю.
То есть я в списке инициализации создаю буфер, инициализирую массив нулями, фигурные скобки.
Ну и дальше задаю size.
Ну и теперь что у меня происходит?
Теперь я могу, как обычно, вызывать конструктор.
Ну, с помощью круглых скобок я пишу стек, ими перемены, и даже в круглых скобках с какими параметрами я вызываю конструктор.
Дальше. Я могу сделать вот такую вещь.
Казалось бы, довольно странно.
Я могу стеку присвоить какое-то другое значение, которое равно какому-то целому значению.
Окей? То есть стек равно 3.
Более того, если у меня есть какая-то функция, которая принимает стек,
я могу в эту функцию передать, ну, как переменную стек,
а могу передать какое-то числовое значение, например, f от 10.
И когда я вызываю f от 10, у меня 10 неявно преобразуется в стек и вызывается f от стека.
Круто?
Нет, это ж нифига не круто. Вы чего?
Ну вот, смотрите, вот если вы смотрите на код и видите f от 10,
вот с какой вероятностью вы думаете, что, ага, здесь вызывается функция от стека?
Есть такие люди?
Вот f от 10. Это f от стека, да?
Нет, это бред. И тем более, когда вы идентифицируете стек числом,
вот таким образом, ну это тоже что-то странное.
Ну как вы стеку присваиваете какое-то число?
Наверное, хотелось бы, чтобы такие вещи не работали.
Ну, точнее так.
Если вы пишете класс комплексного числа или класс рационального числа,
то, наверное, это норм.
То есть это норм, что у вас там десятка преобразуется в комплексное число
или десятка преобразуется в рациональное число.
Это нормально.
Но если там десятка преобразуется в какой-нибудь стек,
или десятка преобразуется в какого-то персонажа игры,
которого вы пишете, ну странно.
Хотелось бы такие вещи запрещать иногда.
Чтобы такие вещи запретить,
здесь специально ключевое слово explicit.
Ну, от английского explicit это явный,
вот implicit не явный.
То есть explicit говорит, что этот конструктор
нужно обязательно вызывать только явно.
Неявно его вызывать запрещено.
Ну, как это выглядит?
Вы пишете ключевое слово explicit,
ну и дальше пишете сам конструктор.
Конструктор одного аргумента.
Ну, на самом деле можно от нескольких,
но, как правило, explicit пишут только для конструкторов с одним аргументом.
Это явное указание конструктора,
ой, явное указание компилятору,
что данный конструктор можно использовать
только для явных преобразований.
Только для преобразований,
которые вы попросили сами.
То есть без вашего ведома,
это совершать запрещено.
То есть без вашего разрешения запрещено
преобразовывать size t в stack.
Вот.
То есть теперь, когда вы написали конструктор с ключевым словом explicit,
у вас вот такая штука.
Не работает.
То есть это считается
неявным преобразованием тройки в stack.
Такое вы запретили.
Ну и вот такая строка тоже не работает.
Неявно преобразовывать десятку в stack
без вашего разрешения
запрещено.
Если вы все-таки хотите вызвать f от десятки
по какой-то причине,
вы должны явно попросить компилятора
об этом.
Написать stack от 10.
То есть вы тут явно попросили,
что нужно десятку преобразовать в stack
и только потом вызвать функцию f.
Вот назначение
в слово explicit.
Дальше.
На этом с конструктором
преобразование все.
Теперь очередной вид конструктора
это конструктор по умолчанию.
Конструктор по умолчанию
это конструктор, который
может быть вызван без аргументов.
Ну мы идем по уменьшению
количества аргументов.
Короче говоря.
Если вы пишите конструктор,
который не принимает аргументов,
то этот конструктор будет выubbyн
когда вы создаете объект
и не передаете ему ничего в круглых скопках.
Если вы задаете объект и ничего в круглоскопах не передаете, то в этом случае работает конструктор по умолчанию.
То есть так или как-то вот так, с помощью присваивающегося синтаксиса.
И вот тут есть важный момент, очередной странный момент C++.
Вот смотрите, до этого мы могли спокойно вызвать вот такие конструкторы таким образом.
То есть писать стек и даже в круглоскопах указывать, что нужно передать.
Казалось бы, чтобы вызвать конструктор по умолчанию, наверное, хотелось бы, чтобы можно было делать точно так же.
Вот так. Ну просто передать круглые скопки.
Но вот оказывается, что так делать нельзя по довольно странной причине.
Вот если посмотреть на вот эту запись, то она должна вам очень сильно напоминать объявление функции.
Объявление функции other, которая ничего не принимает и возвращает стек.
И компилятор воспринимает это точно так же.
То есть он думает, что когда вы написали вот так, это значит вы объявили функцию other, которая возвращает стек и ничего не принимает.
И вот по такой причине вот так писать нельзя. Можно писать только вот так или вот так.
Ну и, собственно, такой вопрос.
Вот смотрите, до этого мы вроде как про конструкторы вообще ничего не знали.
Например, на прошлой лекции мы вообще ничего не говорили про конструкторы.
Но при этом мы спокойно создавали стек без аргументов, дальше вызывали какие-то методы, и это все даже работало.
Вот вопрос. Ну, смотрите, мы не написали ни одного конструктора.
Более того, в прошлом семестре вы не писали ни одного конструктора.
Вы писали структуру, но при этом конструкторы не писали.
Но при этом вы могли спокойно создавать объекты без аргументов. Как так?
Вы писали значение по умолчанию?
Нет. В стеке мы не писали значение по умолчанию.
Нет, мы так не делали, на самом деле. То есть когда мы писали стек, то есть в принципе вы можете не писать ничего.
То есть когда мы писали стек, у нас был просто указатель на буфер и сайс.
То есть мы ничего тут не указывали.
Мы просто всю инициализацию указывали в методе init.
Вот на прошлой лекции.
Именно в методе init мы присваивали мультр или что-то еще.
То есть даже если вы по умолчанию ничего не укажете, то это все равно будет работать.
И все это по следующей причине.
Это потому, что если вы не написали ни одного конструктора, то есть если вы компилятору дали понять,
что вы находитесь в первом семестре и вы вообще ничего не знаете про конструкторы, то компилятор любезно за вас напишет свой конструктор.
То есть правило такое, если вы в классе не объявляете ни одного конструктора, то компилятор напишет конструктора по умолчанию за вас.
Важный момент, он напишет за вас только конструктор по умолчанию.
Хорошо, не только.
Давайте так.
Все, остановимся на этом.
Если вы не пишете ни одного конструктора, не объявляете ни одного конструктора, то компилятор за вас пишет конструктор по умолчанию.
Что будет делать этот конструктор по умолчанию?
Каким он будет?
Тут есть три возможностей ответа.
Самый слабый ответ заключается в том, что он просто-напросто ничего не сделает.
Просто-напросто проренетилизирует все поля мусором.
Это не совсем правда.
Если у вас класс или структура состоит только из полей примитивных типов.
Если у вас все поля примитивные типы, то действительно там будет просто храниться мусор, ничего другого.
Более правильный ответ заключается в том, что если вы не пишете свой конструктор, то компилятор пишет за вас конструктор по умолчанию, который все поля инициализирует по умолчанию.
Точнее, вызывает у всех конструктор по умолчанию.
Но это тоже не совсем правда, потому что у примитивных типов конструктор по умолчанию, естественно, нет.
Это не констанция конструктора по умолчанию, потому что это не класс и не структура.
Наиболее полный ответ заключается следующим образом.
Когда компилятор создает вам конструктор по умолчанию, все примитивные типы он инициализирует мусором, то есть никак их не инициализирует.
А если у вас в качестве полей выступают другие классы или другие структуры, то для них он вызовет конструктор по умолчанию.
А если у вас константные поля?
Мы возвращаемся к физическому инициализации. Константные поля компилятор не умеет создавать.
Там будет ошибка, да.
Ну вот такой пример. У меня есть какой-то класс A, то есть как-то он написан, неважно, ну и допустим у него есть свой конструктор по умолчанию.
Вот я написал класс B, у которого есть поле X и у которого есть поле A.
Ну и допустим в этом классе B я не написал своего конструктора по умолчанию.
Точнее так, я вообще никакого конструктора не написал.
И вот в этом случае я по-прежнему могу вызывать, точнее могу создавать объекты типа B без аргументов.
В этом случае у меня поле X будет ничем не проинциализирован, точнее будет проинциализировано мусором.
А для B точка A, точнее для этого поля A, у меня будет вызван конструктор по умолчанию.
Естественно. То есть если в классе A, давайте так, если в классе A есть конструктор по умолчанию, то будет вызван именно он.
Если в классе A, давайте так, если в классе A нет конструктора по умолчанию, то будет ошибка эмпиляции, но об этом сейчас поговорим.
Давайте так, да.
Естественно, вы для класса можете писать сколько угодно конструктора.
То есть конструктора можно перегружать. Естественно, нельзя написать два конструктора, которые принимают один и тот же набор аргументов.
Разные можно.
Абсолютно, да.
Но если вы в своем классе написали хотя бы один конструктор, то есть вы дали понять компилятору, что я знаю, что такое конструктор, и вот я пишу их,
то компилятор вам не будет ничего создавать.
Такое правило.
В общем, если вы не написали ни одного конструктора, то компилятор вам создаст. Если написали хотя бы один, то все, забудьте.
Ну и да, соответственно, тот конструктор, который представляет вам конструктор, то есть конструктор от государства, он выглядит вот таким образом.
То есть он, грубо говоря, конструктор с пустым телом.
Но при этом мы помним, что если написали список инициализации, то список инициализации все равно выполняется.
Именно поэтому все поля, если у них есть конструктор по умолчанию, для них будет вызван конструктор по умолчанию, обязательно.
Comp palavr может отказаться вам генерировать конструктор по умолчанию не только в случае, если вы сами написали какой-то конструктор.
Этим небольшим Seoul
в общем, совсем расстроится, потому что,
во первых, нельзя создать поле а,
потому что конструктор приватный.
Во вторых, нельзя создать поле b,
потому что непонятно чем проник préางельизировать
константу.
Ну а в третих не может проникра sermon,
чем проникра Californ thanked.
В этом случае, даже несмотря на то,
что вы не написали ни одного конструктора,
комплятор вам тоже отказался генерировать
конструктор по умолчанию, потому что
непонятно, как должен он выглядеть.
Ну и последний пункт здесь. Конструкция равно default.
Допустим, вы в своем классе написали какие-то конструкторы.
Какой-то конструктор преобразования, какой-то параметрический конструктор и так далее.
Ну и при этом вы хотите, чтобы у вас в классе также был еще конструктор по умолчанию.
Но при этом вы не хотите писать его самостоятельно, вы хотите отдать это все на откуп компилятору.
Тогда вы можете воспользоваться конструкцией равно default.
Ну смотрите, вы написали свой конструктор какой-то.
В этом случае компилятор вам, естественно, не будет генерировать конструктор по умолчанию.
Но вы можете вежливо попросить компилятора сделать это и делать это следующим образом.
Вы пишете b круглой скобки равно default.
В этом случае компилятор за вас напишет конструктор по умолчанию.
Вот ровно в таком виде, в котором мы обсуждали до этого.
Если бы я эту строку не написал, то у меня бы конструктор по умолчанию в классе не было.
Но я хочу, чтобы он был. Но при этом мне самому писать его в лом.
Ну тогда я просто пишу равно default и это явная просьба компилятора создать за меня этот конструктор.
Вот и все.
В данном случае они оправдываются.
Но это лучше тем, что это более явно показывает ваше намерение.
То есть когда кто-то читает ваш код, ему более понятно, что вот этот конструктор предоставлен компиляторам.
Они вы писали.
Ну и когда мы будем говорить про следующий конструктор, там default будет отличаться от пустых фигурных скобок.
Так, вопросы?
Ну перерыв тогда.
Следующий конструктор, по которому мы поговорим, это конструктор копирования.
Конструктор копирования это конструктор, который создает объект с помощью другого объекта того же типа.
То есть если в качестве параметра ваш конструктор может принимать другой объект того же типа,
то этот конструктор называется конструктором копирования.
Вот.
Вот, к сожалению, вот просто так написать конструктор копирования правильно.
В общем, это просто так.
В общем, если не знать про то, как ведет себя конструктор копирования,
очень сложно написать его правильно с первого раза.
Вот, смотрите, допустим, я пишу вот такой конструктор копирования.
Ну, я следую ту по определению.
Значит, по определению у меня конструктор должен принимать другой объект того же типа.
Ну, соответственно, если я хочу написать конструктор копирования для стека,
то я в качестве аргумента ему передаю просто stack s.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Ну и дальше я задаю вопрос.
Вам задана вопрос.
Бесконечные рекурсии отвечать нельзя.
Ну а в чем проблема?
Ну не по ссылке и что?
Ну да, смотрите, в чем проблема.
Проблема в следующем.
В этом случае я вызываю конструктор копирования.
В этом случае я вызываю конструктор копирования.
Что делает конструктор копирования?
Конструктор копирования принимает,
у него есть в качестве аргумента
он принимает s.
Как я принимаю s?
s я принимаю по значению.
А что происходит с аргументом,
когда я передаю его по значению?
Аргумент копируется.
Фактически аргумент копируется
в тот аргумент, который у меня в функции.
То есть у меня сначала a должен скопироваться в s.
Ну смотрите, я хочу a скопировать в b,
но перед тем как скопировать a в b,
у меня a должен скопироваться в аргумент s,
чтобы я мог с s внутри
вот этого конструктора работать.
Понятно?
а как мне скопировать a в s?
с помощью конструктора копирования.
Хорошо, вот тут тогда вызывается
Конструктор копирования
из a в s.
А как работает конструктор копирования?
Сначала он должен скопировать аргумент.
То есть а у меня теперь копируется в какой-то s'.
в какой-то s-трих. То есть я пытаюсь вызвать конструкцию
закопирования, которая копирует a в s-трих. Но чтобы скопировать
a в s-трих, мне должен создаться какой-то аргумент, и поэтому,
и так далее. Это очень понятно. Чтобы запустить конструкцию
закопирования, мне нужен конструкцию закопирования, а у меня его нет.
А про это мы поговорим. Если вы не пишете конструкцию
закопирования, то действительно вся поля копируется побитого.
Но когда вы написали свой конструкцию закопирования, то работает
то, что я сказал. Проблема понятна? То есть чтобы скопировать
a в b, мне нужно сначала a скопировать в s. А чтобы скопировать
a в s, мне нужно вызвать конструкцию закопирования, получать
такая рекурсия. То есть я не могу вызвать конструкцию
закопирования, потому что мне нужен конструктор
закопирования. Как решается эта проблема? Решается очень
просто. Нужно принимать аргумент не по значению, а по ссылке.
Точнее, по константной ссылке. Почему именно по ссылке,
понятно, потому что ссылка не создает копий. Ссылкой
ссылается на ровно тот же объект, который вы передали.
А почему по константной ссылке? Ну, во-первых, из соображения
безопасности, чтобы вы точно не поменяли тот объект,
который вы передали. То есть странно, что вы копируете
один объект, и при этом этот объект меняется. Но, во-вторых,
константные ссылки позволяют вам передавать так называемое
r-value, то есть временное значение. Если я захочу скопироваться
от временного значения, то по ссылке мне не получится
его передать. Потому что нельзя создавать ссылку
на временный объект. А константную ссылку на временный объект
создавать можно. Конструктор копирования это конструктор,
который принимает элемент того же типа, но по ссылке.
Желательно по константной ссылке. Ну и теперь вот про
вопрос из зала. Смотрите, до этого мы вроде как конструктор
то есть вы к конструктору копирования писали?
Но при этом копировать объекты могли,
ну вот вы же наверное могли одну структуру скопировать другую struct,
и так далее.
В этом случае тоже действуешь особые правила.
Точнее в этом случае комп administration создат вам concerts Standing 부�파,
и правило здесь такое.
Если вы не написали своего конструктора копирования
и конструктора перемещения,
что такое? Поговорим позже.
Если вы не написали копирование и перемещение,
то компилятор за вас напишет вам конструктор копирования.
Parechite. discernible.
ıma,
Raz Yea.
Shla低,
شætegeryt,
stest,
все равно будет вам создаваться. Ну и соответственно, что делает
конструктор копирования, который предоставляет вам компилятор?
Самый простой ответ – это то, что он просто берет по битву
и копирует все поля, но ровно то, что мы наблюдали до этого.
То есть у вас все поля стекок просто-напросто взяли и скопировались
в поля другого стека. Но это не вся правда. А вся правда заключается в том,
что копирование происходит следующим образом. Примитивные поля копируются,
то есть всякие инты, флоты, були и так далее, они копируются по битву.
Просто берется битвое представление и дословно копируется в новый объект.
А если поле представляет из себя не примитивный тип, а объект-класс,
то это поле будет копироваться с помощью конструктора копирования.
Понятно? То есть если у кого-то поле есть свой конструктор копирования,
то при копировании будет вызван именно он.
Ну вот здесь пример. Соответственно, если вы написали свой конструктор копирования,
то компилятор предоставляет вам конструктор копирования, который эквивалентен следующему.
Он для класса A, точнее для поля A вызывает конструктор копирования,
ну а для объекта X он просто копирует его по битву.
Можно сказать, что он просто берет и вызывает копирование для каждого поля в отдельности.
А что произойдет, если у меня в классе A нет конструктора копирования?
Ну то есть в принципе нет вообще никакого. Что произойдет?
Ну представьте, в классе A вообще нет никакого копирования.
То есть даже компилятор там не создал. Что произойдет?
Ну вот это сможет? Компилятор сможет создать? Нет.
То есть если у вас какие-то поля некопируемые, то, естественно,
конструктор копирования создаваться за вас не будет.
Я думаю, это вполне естественное правило.
Ну вот ровно то, что я говорил.
Компилятор откажется генерировать за вас конструктор копирования,
если у вас в классе есть поля, которые нельзя копировать.
Ну вот как это может получиться?
Ну вот представьте, что у вас есть структура A,
и снова структура A написала какую-то вреднючку,
которая запретила нам вызывать конструктор копирования.
То есть он сделал этот конструктор копирования приватным.
И у меня есть структура B, у которой в качестве поля выступает поле А.
И вот тогда, если я попытаюсь скопировать объект B,
то это у меня не получится, почему!?
Потому что у меня в структуре B нет конструктора копирования.
А почему у меня в структуре B нет конструктора копирования?
Потому что компилятор отказался генерировать конструктор копирования,
потому что ему непонятно, как копировать объект A.
У объекта A нельзя вызывать конструктор копирования, он приватный.
Ну и аналогично, если вы хотите, чтобы компилятор за вас
сгенерировал конструктор копирования, вы можете его явно об этом попросить.
С помощью конструкции равно default. То есть если вы хотите явно сказать
компилятору, что вот конструктор копирования нужно сгенерировать за меня,
то есть не знаю, я сам не умею, или вот меня устраивает то, как делаешь ты,
то можно сделать равно default. В данном случае я пишу b
и дальше принимаю объект типа b по константной ссылке и пишу равно default.
В этом случае компилятор генерирует его за меня.
При этом писать для конструктора копирования равно default не обязательно,
потому что если вы не опишете свой конструктор копирования,
то в принципе компиляторы за вас это и сделают.
Ну и вопрос. Как вы думаете, есть ли ситуации, при которых нужно
писать свой конструктор копирования? То есть мы вроде как обсудили,
что компилятор со созданием копирования справляется сам.
То есть компилятор в принципе сам может все поля взять и скопировать.
В каких ситуациях нужно писать конструктор копирования тогда самостоятельно,
если компилятор всегда за нас задает это копирование?
Указатель.
Ну да, то есть если говорить в общем, то если вы управляете
какими-то ресурсами, например, у вас внутри объекта хранится указатель
на выделенную память, то в этом случае, естественно, вам хочется глубокое копирование.
То есть вам хочется этот буфер скопировать целиком, а не просто скопировать указатель.
Но чтобы не возникала такой ситуация, как со стеком.
То есть у вас есть буфер от первого стека, у вас есть буфер от второго стека.
Если вы просто бездумно с помощью компилятора скопируете s2 в s1 или наоборот,
то у вас оба этих буфера будут указывать на одну и ту же область памяти.
Ничего, наверное, не хотелось бы, да?
То есть хочется, чтобы два стека имели разные области памяти,
точнее разные массивы, на которые они указывают.
И вот в этом случае вам нужно писать свой конструктор копирования, действительно.
Эта ремарка понятна?
Если вы сами как-то управляете памятью или в принципе ресурсами,
то чтобы корректно их передавать, чтобы корректно их копировать,
нужно написать свой конструктор копирования.
Если у вас в принципе класс состоит только из примитивных типов,
ну например, у вас вы пишете свой класс комплексного числа.
Ну комплексное число это что?
Это просто два типа флотовых числа, которые отвечают за действительно умнимую часть.
В этом случае, естественно, конструктор копирования свой писать не имеет смысла,
потому что компилятор и так справится за вас, побит вас копировать все поля.
Это нормально.
Мораль ясна?
Окей.
Ну и замечание про конструктор копирования.
Вот смотрите, когда мы обсуждали конструктор по умолчанию,
мы говорили, что вот эти две записи, они абсолютно эквивалентны.
Ну потому что если вы пишете пустые фигурные скобки,
то компилятор все равно за вас напишет список инициализации,
которые все поля создаст по умолчанию.
То есть что написать равно default, что написать пустые фигурные скобки,
это абсолютно то же самое.
Вот для конструктора копирования это неверно,
потому что если в конструкторе копирования вы напишите пустые фигурные
скобки, то для компилятора это означает, что
конструктор копирования должен вести себя так,
он должен ничего не делать.
В этом случае компилятор так, как вы написали пустые
фигурные скобки без списка инициализации,
в этом случае компилятор все поля создаст по умолчанию,
но не скопирует.
Понятно?
Поэтому в этом случае есть разница между равно-дефолт и просто пустыми фигурными скобками.
То есть для конструктора копирования написать просто пустые фигурные скобки недостаточно.
Пустые фигурные скобки без списка инициализации для компилятора означают создать все по умолчанию.
Но копирование это не создать по умолчанию, естественно.
Все понятно? Отлично.
Ну и делегирование конструкторов.
Значит, все, с видами конструктора мы закончили.
Какие конструкторы мы успели разобрать?
Параметрический конструктор, конструктор преобразования, конструктор по умолчанию,
конструктор копирования.
Есть еще один специальный вид конструктора, конструктор перемещения,
но мы договорились, что о нем попозже поговорим, когда-нибудь.
Теперь про делегирование конструкторов.
Проблема следующего рода.
Допустим, я хочу написать для своего класса stack следующий конструктор.
Конструктор, который принимает массив динамический и его размер.
И я хочу, чтобы в этом конструкторе у меня в stack загрузили все эти значения
из вот этого массива.
То есть я хочу проинтересировать stack элементами из переднего массива values.
Нормальное желание?
Ну что я делаю?
Я создаю буфер с помощью new, то есть выделяю память для своего буфера,
в котором будут храниться элементы.
Задаю значение size, ну и дальше в цикле копирую все элементы
из массива values в свой буфер.
Все нормально, да?
Хорошо.
Теперь мне приходит еще одна идея.
Так у меня stack управляет как-то нетривиально памятью,
мне нужно писать свой конструктор копирования,
чтобы не было поверхностей своего копирования,
чтобы копирование было глубоким.
Ну хорошо, что я делаю?
Я создаю снова буфер с помощью new,
я создаю начальный размер size, который равен такой же размер,
как переданный stack other.
Ну и дальше в цикле я копирую все элементы
из другого буфера в свой буфер.
В чем проблема?
Здесь написано, окей.
Ну понятно, да, что есть дублирование кода.
То есть что первый конструктор, что второй конструктор
в принципе выполняют одни и те же действия.
Мы просто копируем элементы из одного массива
в свой массив, и все.
Ну наверное хотелось бы как-то,
ну естественное желание избежать дублирования кода.
То есть наверное хотелось бы чего-то такого.
То есть я понимаю, что конструктор копирует,
то есть я понимаю, что конструктор копирования
в принципе у меня работает точно так же,
как и вот конструктор, который написан выше.
То есть в частности, если я вот в конструктор,
который у меня выше находится,
передам значение other size и other buffer,
то все будет происходить так, как я хочу.
Да, у меня скопируется size
и скопируются элементы из буфера.
Согласны?
То есть хотелось бы, чтобы у меня был какой-то вот такой синтаксис.
Я внутри одного stack вызываю другой stack.
Но при этом есть проблема. Какая?
Мы помним, что все, что написано в фигурных скобках
может быть использовано против вас.
Все, что написано в фигурных скобках,
это не инициализация, а что?
Ну это просто изменение текущих значений,
изменение уже проинциализированных значений.
Поэтому естественно, что внутри
фигурных скобок другой конструктор
вызывать нельзя.
Более того, когда вы пишете
вот таким образом,
когда вы написали такую строку,
на самом деле у вас тут происходит не вызов конструктора,
то есть не вызов другого конструктора,
а создание временного объекта.
То есть это то же самое, как если бы вы написали
int в скобках 5
и вот так.
Ну что эта строка означает?
Это выражение, которое, грубо говоря, означает 5.
Вот в этой строке 5.
Ну что 5?
Не понятно.
Вот здесь то же самое. Вы просто создаете stack временный,
то есть вы в этой строке создали stack,
и он сразу же уничтожился.
Хорошо.
А как правильно?
Как правильно вызвать конструктор
в другом конструкторе?
Делается тоже через синтаксис
списков инициализации.
Вы должны вот здесь,
через двоеточие указать
конструктор, которому вы делегируете
полномочия.
То есть, грубо говоря, вот тут дословно говорить следующее.
У меня конструктор копирования
выполняет те же самые действия,
что и вот такой конструктор с вот такими параметрами.
Понятно?
То есть я говорю, что конструктор копирования
у меня должен выполнить вот такие действия.
Я должен ему передать other size и other buffer,
ну и дальше, собственно, выполняется код
конструктора, который был написан ранее.
Ну и начиная с этого момента
управление полностью переходит
в конструктор, который вы указали.
Какое важное правило здесь нужно поговорить?
Во-первых, нельзя сделать следующим образом.
Нельзя сказать, что
одни поля ты проинфилизируешь с помощью...
Одни поля ты проинфилизируешь так же, как и
инициализирует другой конструктор,
остальные поля я проинфилизирую сам.
То есть, грубо говоря, нельзя вот тут написать
через запятую size 0.
То есть вот так нельзя.
То есть если вы уже делегировали
полномочия другому конструктору,
то этот конструктор полностью будет отвечать
за создание вашего объекта.
То есть ничего больше
написать после двоеточия,
если вы делегировали полномочию
другому конструктору, нельзя.
Но при этом, если вы хотите как-то...
Вот вас полностью устраивает,
что делает другой конструктор.
Вас полностью устраивает, что происходит здесь.
Но при этом вы хотите как-то
изменить size, например.
Вы хотите сделать все то же самое,
но при этом size был на один побольше.
Это вы можете сделать,
просто написать внутри фигуры скобок
size...
Можно и так.
Все ясно?
Окей.
Это про делегирование конструкторов.
То есть конструктор можно взять
в других конструкторах,
если вас устраивают эти действия,
которые он должен совершать.
Так, ну и...
Значит, с конструкторами все.
Есть вопросы?
В принципе, по конструкторам.
Ну тогда давайте поговорим про деструкторы.
Ну, я думаю, по названию понятно.
Если конструкторы создают объект,
то деструкторы его уничтожают.
Соответственно,
деструкторов существует
всего один тип.
То есть у конструкторов у нас была целая семейство,
а деструктор только один.
Деструктор это особый метод класса.
Но деструктор,
деструктор это особый метод класса,
который вызывается при завершении времени
жизни объекта.
Как только время жизни объекта завершается,
вызывается деструктор.
Каков синтаксис?
Как написать свой деструктор?
Во-первых, деструктор не имеет возвращаемого значения.
То есть когда объект уничтожается,
у него нет возможности сказать последнее слово.
Он уничтожается и все.
Без последнего слова он ничего не возвращает.
Его имя совпадает с именем класса,
но перед началом вы должны написать тильду.
То есть тильда имя класса означает,
что вы пишете деструктор.
Ну и плюс деструктор
ничего не принимает.
У объекта нет шанса
на последнее слово,
на последнее желание, то есть ничего передать деструктор вы не можете.
То есть деструктор всегда выглядит следующим образом.
Тильда, название класса
и пустые круглые скобки.
Это деструктор.
Ну какие действия можно выполнить деструктуре?
Например, что нужно сделать для стека?
Что мы знаем для стека?
Что нужно сделать, чтобы он завершил корректную работу?
Очистить память, вернуть ресурсы
в операционной системе.
Ну что мы делаем?
Просто в деструкторе пишем delete-буфер.
И вот теперь,
когда мы так написали,
мы знаем, что деструктор вызывается всякий раз
автоматически, когда время
жизни объекта подходит к концу.
И вот теперь нам не нужно вручную управлять памятью стека.
Теперь стек автоматически выделяет память
в конструкторе и автоматически
очищает память в деструкторе.
То есть теперь, когда вы напишете просто
вот такой код, без всяких
файналайзов, у вас стек будет корректно
работать. То есть вот тут при создании
выделилась память, вот тут,
когда вы вышли из области действия
стека, у вас стек вернул все ресурсы,
то есть вызывался деструктор. Понятно?
UndefinedBehaviour.
То есть если вы
написали как-то стек
в какой-то области,
вот как только фигурная
скобка закрылась,
вот в этот момент вызываются все деструкторы.
То есть все объекты, которые были
созданы внутри этого скоба,
для всех этих объектов будет вызов деструктор.
И все ресурсы вернутся системе.
И вот деструктор
это, наверное, самая важная концепция,
самая важная часть языка C++,
которая позволяет, вообще говоря,
не следить за всякими
утечками памяти и так далее. То есть если вы
корректно написали для всех классов деструкторы и так далее,
то все ресурсы автоматически выделяются,
все ресурсы автоматически возвращаются системе.
И никакого ручного управления памятью.
Да, ну и про последний пункт.
Тут написано, что деструктор
вызывается неявно при уничтожении любого объекта.
При этом деструктор при большом желании
можно вызвать и, грубо говоря, явно.
То есть, грубо говоря, вы можете
сделать его так.
То есть вы можете в конце сказать
stack,
точка и через тильду
вот так. То есть вы, грубо говоря,
явно вызвали деструктор. Но так делать не стоит,
точнее так делать нельзя.
Почему? Потому что компилятор
все равно за вас. То есть даже если вы написали
так, компилятор все равно за вас.
Когда вы выйдете из этой области действия,
из этой области видимости, у вас stack
все равно, для stack все равно вызовется деструктор.
И тогда у вас будет как раз-таки вот это вот самое
double-free. То есть вы два раза очистите одну и ту же память.
Чего делать нельзя?
Понятно?
В данном случае ничего. То есть, как правило,
деструкторы нужны для того, чтобы вернуть какие-то ресурсы
в системе. Ну, допустим, у вас там класс открывает
какие-то файлы, какие-то соединения по сети,
что-то еще.
Чтобы это все корректно обработать, чтобы это корректно закрыть,
делается деструктор.
Если у вас просто класс комплексного числа, то, естественно,
деструктора ему не нужен.
Да, про это, видимо,
на следующем слайде...
Ну, про это мы поговорим.
Деструктор должен быть публичным.
Иначе будут всякие неприятные штуки.
Да, кстати, давайте еще такой момент сделаем.
Его на слайдах нет, но
это тоже важно проговорить.
В каких ситуациях
еще вызываются конструкторы и деструкторы?
Ну, вот, смотрите, вот, допустим, я
хочу, чтобы у меня stack
хранился в куче.
Ну, то есть, не в смысле данные stack хранились в куче,
они и так в куче хранятся.
Я хочу, чтобы сама переменная stack,
ну, не переменная, а вот
само то место, где хранится stack,
это была куча.
То есть, грубо говоря, я хочу сделать вот так.
auto ptr равно
new stack.
Понимаешь, что здесь происходит?
Ну, я создаю stack,
но в куче.
Ну, и через вот этот ptr я могу
вызывать всякие методы push,
один,
всякие топы,
ну и так далее.
Как вы думаете, вот в этом случае вызывается
конструктор для stack или нет?
Почему?
Почему бы ему не вызваться?
Потому что
сам stack же как объект,
он в куче находится.
Ну, а сам объект
надо создать,
конструктор-то для него, наверное, должен быть вызван.
Короче, ответ такой,
конструктор вызывается
не только, когда вы на stack
создаете переменные,
но и когда вы создаете объекты
с помощью new.
Вот new,
операция new,
тоже
порождает вызов конструктора.
То есть, в этом случае какой конструктор
для stack будет вызван?
Конструктор по умолчанию.
Вы можете здесь указать
внутри круглых скобок
какие-то параметры, например, 10 и 1.
И в этом случае у вас в куче
создаться объект stack
с параметрами 10 и 1.
То есть, new
тоже вызывает конструктор.
То есть, объект
без конструктора создаться не может.
Для любого объекта все равно
вызывается конструктор.
Но, как вы правильно сказали,
деструктора
вызвана не будет.
Действительно.
Если вы создали объект в куче,
это не локальный объект,
если бы нет области видимости.
Если вы выходите из области видимости,
то у вас уничтожается сам указатель,
сама переменная, в которой хранится адрес.
Но сам stack продолжает жить в куче.
Это обычное поведение.
Хорошо.
Чтобы эту память очистить,
естественно, мы вызываем delete.
Delete.ptr.
Как вы думаете, при вызове delete
вызывается деструктор или нет?
Видимо, да.
Когда вы вызываете delete,
то нью порождает вызов деструктора.
То есть нью порождает вызов конструктора,
а delete сначала вызывает деструктор
у того объекта, у которого вы вызываете delete,
а потом очищает память,
у которой оставился бы объект.
Поэтому нью и delete тоже порождают вызовы
конструкторов и деструкторов.
Вот такое замечание.
Ну, ptr на что указывает?
На stack.
Поэтому будет вызван деструктор stack.
Почему?
Потому что
когда вы вызываете...
Потому что компилятор не понимает,
в каком случае нужно освободить память в куче.
Вы создали
объект в куче.
Сохрани на него указатель.
И объект продолжает жить в куче.
Когда вы выходите из области видимости, у вас уничтожается указатель.
У нас в языке C++ нет сборки мусора.
Если у нас была, как в джаве
или в питоне, сборка мусора,
то компилятор бы понял, а на этот объект никто больше не ссылается,
то есть на него нет указателей, значит его нужно удалить.
А в данном случае нет.
То есть вы создали объект в куче, и вы теперь сами ответственно
за то, чтобы его как-то самостоятельно уничтожить
или самостоятельно создать.
Но это то же самое, как если вы
с помощью нью выделяете массив,
и массив у вас тоже автоматически оттуда не удаляется.
Вы должны явно сами очистить этот массив.
Поэтому, грубо говоря, когда вы используете нью и delete,
вы сами вручную управляете временем жизни объекта.
То есть вы сами
начинаете жизнь объекта с помощью нью,
вы его породили, и сами должны
уничтожить с помощью delete.
А если вы создаете объекты в локальной области видимости,
то есть на стеке, то тут проблем нет.
Стек создался, а вот конструктор.
Мы вышли из области действия, из области видимости,
стек должен быть уничтожен, все понятно.
Что значит, как-то не так.
А зачем?
Мы будем
говорить про умные указатели,
в частности про SharedPtr.
Вот там пример такое поведение.
Когда объект удаляется,
точнее, когда вы выходите
за область видимости, когда вызывается
конструктор для умного указателя,
то объект, на который он указывает, он удаляется не сразу,
ну а позже, когда на него уже никто больше не ссылается.
Вот так можно.
А вот прям, чтобы сказать явно,
что удали не сейчас, а через 5 секунд, то нет.
Ну, точнее, можно
с помощью параллельности, с помощью потоков,
но это вам не нужно.
Дальше?
Да, ну и, соответственно,
ну снова вспоминаем, что
для Stacking мы на самом деле не писали свой деструктор,
и вообще для структура вы не писали свой деструктор.
То есть вы его не писали, а он есть.
На самом делеيل конструктор за вас пишет деструкторы.
Что он делает?
Ну, простой ответ, но неправильно.
Это ничего не делает
И это примерно правильный ответ,
то есть если у вас действительно
в классе поля только примитивных типов,
тогда boring.
Если вы пишете свою структуру для комплексных чисел,
чисел, то деструктор просто-напросто забьет. Ну хорошо, была переменная комплексная числость,
теперь ее нет. Ну все, короче, я просто указатель стека сдвигаю, там теперь хранится то, что хранилось
раньше, я перезаписывать ничего не буду. Ну это нормальное поведение. Если объекты это примитивный
тип, то ничего делать не надо. Но при этом, если в качестве полей у вас выступают объекты других
классов, то для них вызываются деструкторы. Ну то есть, если у вас есть, уйди, если у вас есть класс A,
и он как-то написан, и у вас есть класс B, у которого внутри есть int x и аа, ну и при этом для B вы
не написали своего деструктора, то для B все равно деструктор будет создан за вас, ну потому что
для любого объекта обязательно должен быть вызван деструктор. И вот в этом случае деструктор
для B, который создался для вас компилятор, он x просто проигнорирует, потому что примитивный
тип, с ним ничего делать не надо, а вот для A он самостоятельно вызовет деструктор. Понятно? То есть
деструкторы для полей всегда вызывают автоматические, то есть вам самостоятельно этого делать не
нужно, окей? То есть компилятор достаточно умный, чтобы самостоятельно уничтожить поля класса.
Ну естественно, дефолтный деструктор вам не доступен, если у какого-то поля класса нет
деструктора. Ну например, снова есть класс A, у которого приватный деструктор, и вы создаете
объект типа A. Вот объект типа A на стеке в данном случае создать нельзя, ну это другой пример на
самом деле, это пример того, что произойдет, если у вас будет приватный деструктор. Вот если
у вас приватный деструктор, то вы получите довольно интересный артефакт, ваши объекты теперь
нельзя создавать на стеке. Впрочем, если у вас есть, если вы написали приватный деструктор, то есть
деструктор, который никому не доступен, то просто так создавать объекты вам нельзя. Как вы думаете,
почему нельзя? Что? Ну нет, тут другая проблема. Ну как бы у меня класс A пустой, у него и так
ничего не утекает. В принципе его вызвать нельзя. Тут проблема в том, смотрите, когда вы
создаете объект A, и когда вы выходите из области его действия, вот тут компилятор за вас подставляет
вызов деструктора. Когда вы выходите из области действия, вызывается деструктор. Но компилятор
не может вызвать деструктор, потому что вы скажете, что он приватный. Вот проблема. Поэтому вы
получите, если вы напишете так, то вы получите ошибку, что короче, деструктор приватный, и создавать
объекты на стеке вам нельзя. Поэтому не делайте приватный деструктор, вам этого не нужно.
С чем? С приватным конструктором у нас было такое же, но была другая проблема. Вам создать
объект нельзя, а тут проблема другая. Вам создать объект можно, но уничтожить его нельзя. Но компилятор
в любом случае попытается его уничтожить, поэтому в любом случае у вас будет ошибка
компиляции. Если у вас приватный конструктор, там особо нет проблем. То есть если вы делаете
приватный конструктор, то вы говорите, что этот конструктор вызвать нельзя. Ну окей, тогда вы
можете воспользоваться другим конструктором. А здесь в принципе проблема в том, что если вы
когда вы создаете объект на стеке, то вам придется его в какой-то момент уничтожить.
Точнее, компилятору придется его уничтожить.
Но он не может его уничтожить, потому что он плеватый.
Ну и вопрос, что нужно делать в деструкторе, нужно ли писать свой деструктор и так далее.
Мы это на самом деле уже проговорили.
Если для уничтожения объекта никакой нетривиальной логики не требуется,
то деструктора писать не нужно.
Если вы пишете свой класс комплексного числа,
свой класс, не знаю, рационального числа и так далее,
то свой деструктор писать не нужно,
потому что компилятор справится за вас.
Если у вас есть какая-то нетривиальная логика,
например при уничтожении объекта вы знаете,
что вам нужно очистить память.
То есть вы знаете, что в процессе своей работы ваш класс выделяет память.
ваш класс открывает какие-то файлы,
ваш класс открывает сетиовые соединения.
Вот при уничтожении объекта вы знаете, что вам нужно это все закрыть.
все эти ресурсы вернуть в операционной системе.
Все эти действия нужно прописывать в деструкторе.
Общее правило такое, если вы как-то работаете с ресурсами ограниченными,
то нужно их корректно возвращать в деструкторе.
Если у вас такого нет, то не пишите деструктор, вам он не нужен.
Последнее правило тоже я проговорил, что у каждого поля в вашем классе все равно будет вызван деструктор.
Поэтому вручную вызывать деструктор не нужно.
Нужно просто сделать те действия, с до которых компилятор не додумается.
Например, освободить память с помощью delete, закрыть файл и так далее.
Если вы не писали свой деструктор, то компилятор за вас напишет деструктор.
Если вам не нужен деструктор, то вообще его не пишите.
Если у вас деструктор тривиальный, то его писать вообще не нужно.
Продолжение предыдущего слайда.
Для стека нужно очистить память.
Вот это действие нужно прописать.
Многие еще пишут вот такую строку, но зачем?
У вас стек все равно уничтожается.
Этим стеком все равно никто не воспользуется.
Зачем вы делаете size равно 0?
Не нужно это делать.
Сайд самостоятельно уничтожится, сам вернется в систему.
Так можно сделать, но не обязательно.
Так делать тоже не нужно.
Если у вас есть структура B, и в ней есть поле stack,
то в деструкторе B не нужно вызывать самостоятельный деструктор для стека.
Компилятор сам за вас справится, он это все сделает.
Вы главное, память очистите, если вы что-то выделяли, и все.
Поэтому для структуры B деструктор в принципе не нужен.
Почему вы выделили деструктор вручную?
Потому что тут вы вызвали деструктор вручную.
То есть вы самостоятельно уничтожили S.
Но компилятор всегда, после того, как заканчивается деструктор,
он самостоятельно уничтожает все поля класса, точнее он высчитает эти поля.
Поэтому компилятор снова вызывает деструктор для S.
Но это разговор о том, что компилятор всегда вызывает деструктор у всех полей.
Если вы самостоятельно вызовите деструктор, то вы вызовете его второй раз.
А этого делать не нужно.
Мы закончили обсуждать конструкторы, деструкторы, и сейчас я утверждаю, что мы на самом деле можем
в полной мере реализовать одну из важнейших идиом языка C++, а именно RAI,
или Resource Acquisition is Initialization, то есть захват ресурса, есть инициализация.
В чем это идиом состоит? А идиом заключается в следующем, что всякий раз,
когда вам нужен, говорим про RAI, захват ресурса, есть инициализация.
Идиом говорит следующее, что всякий раз, когда вам нужен какой-то ресурс,
например, память, соединение по сети, мютекс, что угодно, этот объект необходимо оборачивать
в некоторые классы в деструктуру, чтобы захват этого ресурса происходил автоматически в конструкторе,
а освобождение происходило автоматически в деструкторе. Понятно, почему это важно, почему это нужно?
Потому что если вы ресурс захватываете внутри какого-то класса, то этот же ресурс будет автоматически освобождаться в деструкторе.
То есть теперь вам не нужно думать о том, чтобы вовремя освободить ресурс, чтобы вовремя вызвать delete,
вовремя сделать Unlock для мютекса и тому подобное и так далее. Понятно?
То есть исследование данной идиоми и оборачивание ресурсов в некоторые так называемые классы обертки,
например, мы будем говорить про класс Vector. Vector в языке C++ это некоторая обертка над динамическим массивом.
Будем говорить про умные указатели. Это, собственно, обертка над обычными указателями, которые ведут в кучу и так далее.
Если мы для каждой такой ситуации заведем свою обертку ООП-шную, то все будет замечательно.
Не нужно вызывать никаких вручную delete и так далее, все будет происходить автоматически, тем самым повышая безопасность ваших программ.
Ну и здесь пример. Пример абсолютно не связан с реальностью.
Мы спустя какое-то время напишем свой стильный, модный, молодежный, классный, умный указатель.
Но пока пример такой. Смотрите, я могу создавать объекты в куче с помощью new.
Например, автоптр равно new int и 10. Создается десятка в динамической области памяти.
Теперь мне нужно следить за тем, чтобы для этого ptr я вовремя вызвал delete.
Как бы выглядело все то же самое, но если мы следуем идиоме раи. Выглядит это следующим образом.
У нас есть класс int ptr, который из себя представляет указатель на int.
В поле он, собственно, этот самый указатель на int сохраняет.
В конструкторе мы выделяем память и инициализируем это значение тем аргументом, который нам передали.
А в диструкторе этот самый указатель освобождаем.
Если мы пользуемся этим классом int ptr, то при создании объекта у нас автоматически происходит выделение ресурса.
А при уничтожении этого объекта, когда он выходит из области действия, автоматически происходит вызов диструктора.
Теперь нам не нужно вручную вызывать не new, не delete. Все происходит автоматически из-за нас.
Понятно? В этом стоит смысл идиома раи.
Один из последних пунктов. Поговорим про порядок вызова конструкторов и диструкторов.
Важно помнить, что конструкторы вызываются в точности в порядке объявлений.
Это мы уже говорили, когда говорили про списке инициализации.
Мы говорили, что поля создаются в том порядке, в котором вы объявили.
Тоже самое верно для любых переменных.
Если вы создаете объект A, а потом B, то сначала создается объект A, а потом B.
А уничтожаются они в обратном порядке. Сначала уничтожится объект B, а потом уничтожится объект A.
Для полей или структуры всё тоже самое.
Если у вас есть какой-то класс c, у которого в качестве полей содержится f1, f2, f3.
Когда будет вызвана диструктор c, для этих полей в следующем
Как вы думаете, для чего это может быть нужно?
Или почему так сделано?
Ну а какая разница? От перестановки это вызовет деструкторов. Что может поменяться?
Что еще раз?
Ну что вы имеете в виду? В каком смысле?
Да, да, да. Ну правильно.
Смотрите, действительно, так как у меня сначала создается f1, потом f2, потом f3,
то есть я вполне себе могу закладываться в такое поведение.
То есть у меня f2, например, внутри себя может как-то не явно содержать информацию об f1.
Так как f2 объявлен позже, чем f1, то f2 вполне себе, например, внутри себя может хранить ссылку на f1, указатель на f1 и что угодно.
Поэтому, если я уничтожу f1 раньше, чем f2, то будет печально.
То есть f2 будет пользоваться уже уничтоженным объектом.
Но это может испортить поведение моей программы.
Поэтому я сначала уничтожаю f3, от которого точно уже другие аргументы не зависят, уничтожаю f2, от которого f1 не зависят, но уже потом уничтожаю f1.
Ну и плюс еще одно объяснение, что на самом деле переменные так тупо располагаются на стеке.
То есть когда вы заводите переменную a, у вас кладется a.
Потом когда вы создаете переменную b, у вас переменная b остается на стеке.
Но естественно, чтобы уничтожить переменную, то переменная уничтожается в обратном порядке.
Сначала из стека извлекается b, а потом из стека извлекается a.
Поэтому уничтожается в обратном порядке.
Понятно, да?
Ну и еще одно важное правило, которому нужно следовать после того, как мы рассмотрели сегодня конструкторы-деструкторы.
Есть так называемое правило 3, которое в процессе нашего курса эволюционирует до правила 5,
а потом к концу курса мы узнаем про правило 0.
Но это уже другая история.
Пока давайте поговорим про правило 3.
Правило 3 звучит следующим образом.
Правило 3 – это не правило языка.
То есть если вы не будете ему следовать, то компилятор в принципе не расстроится.
Расстроится ваш семинарист и так далее, но вот с компилятором все будет нормально, он переживет.
Правило 3 – это скорее правило приличия.
И звучит оно следующим образом.
Если в вашем классе необходимо написать конструктор копирования или деструктор или присваивание –
про присваивание мы поговорим сегодня, спустя какое-то время.
Если вам нужно реализовать одно из трех, либо деструктор, либо конструктор-копирование, либо копирующее присваивание,
если у вас появилась необходимость в чем-то одном, то нужно реализовать сразу все три.
Опять же, это не правил языка. Если вы напишите деструктор, но при этом не напишите копирование или присваивание, то конструктор от этого
не пострадает. Пострадает, скорее всего, ваша программа. Почему? Потому что смотрите, давайте подумаем, в каком случае нам нужно писать свой деструктор или конструктор копирования?
Мы уже говорили, что деструктор и конструктор копирования мы пишем, если мы как-то нитривиально управляем памятью для стека.
Для стека мы, естественным образом, пришли к мысли, что нужно написать деструктор, потому что нам нужно делать delete.
То же самое для стека мы пришли к мысли, что нужно написать конструктор копирования,
потому что дефолтное копирование нас не устраивает.
Ну скорее всего, если вы пишете свое деструкторе-конструктор-копирование,
то это значит, что у вас есть какое-то управление ресурсами,
а если у вас есть управление ресурсами, вам нужно не забыть и написать корректный деструктор,
корректное копирование и корректное присваивание.
Вот такое правило.
Окей?
Поэтому оно так называется, правило трех,
потому что он фигурирует три сущности.
Вот.
Да, ну и позже мы поговорим про правило пяти
и правило нуля. То есть это все будет.
Вопросы?
Да.
То есть нужно будет реализовать
прям их полностью,
или достаточно будет
получить компилятор?
Если вас устраивает то,
как компилятор себя поведет в этом случае,
то можно написать default.
Не, просто как правило,
опять же, если у вас возникла
супер потребность написать destructor,
то скорее всего, в 99% случаев
вам просто необходимо
написать и копирование, и присваивание.
То есть скорее всего у вас
дефолтное поведение не устраивает.
Вот как в случае со stack.
Опять же, да, это просто такое правило
программистов среди C++.
Вот.
Да, ну и собственно демонстрация
этого правила, например, для случая
псевдоумного указателя,
который мы написали для int.
То есть мы написали свой конструктор
копирования, написали свое присваивание
и написали свой destructor.
Да, ну и тут
вопрос на подумать, что произойдет,
если не реализовать хотя бы один из методов.
Ну, я думаю, понятно. Если не реализуете destructor,
то у вас утечка памяти.
Если не реализуете конструктор копирования,
то что происходит?
У вас получается
два объекта,
которые указывают
на одну и ту же область памяти.
Да?
А к чему это в итоге может привести?
Да, к двойному удалению.
То есть естественно у вас для х будет вызван destructor
и для y будет вызван destructor,
но так как они указывают на ту же область памяти,
то у вас одна и ту же область памяти будет очищена
два раза, что делать запрещено.
Понятно?
Ну и все остальные приколы там связаны с тем,
что если вы тут измените значение 10
на значение 11,
то это же значение изменится и для y,
и для всех остальных,
кто указывает на эту область памяти.
Чего, наверное, вы бы не хотели.
Что?
Ну, про пресваивание мы еще не говорили,
но в целом история такая же.
Вот смотрите, допустим,
пресваивание на самом деле еще более печальная ситуация.
Тут, кстати, пресваивание неправильно реализовано.
Кто понимает, что тут неправильно?
Ну ладно, сейчас объясню.
В общем, смотрите, у вас есть x
и тут есть y,
и они живут своей жизнью.
А дальше вы в какой-то момент решили,
что x должен быть равен y.
Допустим, вы решили,
что x должен указывать
туда же,
точнее так.
Вы хотите скопировать значение,
на которое указывает x,
хотя нет, тут все правильно, я вру.
Нет, тут все нормально, в общем.
Тут никакой ошибки нет, тут просто поведение другое.
Допустим, у x была десятка,
у y была двенадцать.
И когда я присваиваю x равно y,
на самом деле довольно странное поведение,
но мы хотим, чтобы эта десятка заменилась на двенадцать.
И все.
Но мы не напишем присваивания.
Допустим, мы забыли написать присваивания.
Тогда что произойдет?
Тогда спойлер, сейчас мы об этом поговорим,
но тогда просто произойдет то,
что x будет указывать туда же, куда y.
То есть если мы написали свои присваивания,
то стандартное присваивание работает таким образом,
что оно просто присваивает все поля.
И снова возникает та же самая проблема,
что и с конструктором копирования.
Два объекта указывают на одну и ту же область.
Поэтому что?
Что еще раз?
Почему x становится ссылкой y?
Внутри x хранится указатель,
и вот этот указатель указывает туда же,
куда указывает y.
Это логично, но у нас неправильное поведение у деструктора тогда.
Потому что деструктор
он удаляет в любом случае.
А если мы два раза удаляем одну и ту же память,
это плохо.
В общем, это просто пример.
Данный класс им пользоваться не нужно.
Мы разберем,
как правильно написать умный указатель
с правильной семантикой копирования и так далее.
Просто пример, что все три сущности,
в которые фигирует правило 3,
они на самом деле нужны.
И ни от какой из них избавиться нельзя.
Дальше.
Конструкция равно delete,
которая появилась в C++11.
Равно delete
это такая конструкция,
которая позволяет
помечать функции,
которые вызывать нельзя ни в коем случае.
Как это работает?
Допустим, у вас есть функция f от int.
Если вы написали просто функцию f от int,
то ее можно вызывать и для int,
и для doub, и так далее.
Просто у вас аргумент будет преобразовываться в тип int.
А что, если вы
жутко не хотите, чтобы у вас
функцию f может было вызываться от doub?
То есть вы не хотите, чтобы вашу функцию f
можно было вызывать от 0.0?
То есть вы не хотите, чтобы у вас происходило преобразование
из double в int?
Тогда вы просто пишете f от double равно delete.
И тогда, если кто-то попытается вызвать
функцию f от double,
у него ничего не получится. Он получит ошибку в компиляции,
которая написана здесь.
То есть у вас есть функция f от deleted function f.
Ну и аналогично, например,
для шаблонов.
То есть вы хотите, чтобы у вас была
шаблонная функция, которая работает со всеми типами,
но с каким-то конкретным типом она не работает.
Ну, допустим, шаблонная
функция g, которая
в общем случае принимает один аргумент,
но в случае, если она принимает int,
вы хотите, чтобы не работало,
такое не компилировалось.
Тогда вы просто пишете специализацию,
и для нее пишете равно delete.
И вот в этом случае
у вас функцию f от 1.0 нельзя вызывать,
и нельзя вызывать g от единицы,
потому что единица это int.
Ну, для чего это может быть нужно?
Это может быть нужно для того,
чтобы, например, запретить вызывать какие-то
конкретные методы у вашего класса.
Ну, например, смотрите,
мы знаем, что если вы не написали своего собственного
конструктора копирования,
то компилятор с конструктором копирования
создается за вас.
А что, если вы не хотите, чтобы компилятор
вообще создавал за вас конструктор копирования?
Ну представьте, вы не написали конструктор
копирования, и вы не написали его намеренно.
Вы просто не хотите, чтобы ваши объекты могли копироваться.
Как это сделать? Как запретить копирование?
Ну, смотрите, можно поместить
конструктор копирования
во приватную область.
Если мы поместим конструктор копирования в приватную область,
то это значит, что конструктор
копирования вызывать никому нельзя.
Но на самом деле правильней сделать следующим образом.
Правильнее просто пом roller
как удаленный, то есть написать равно delete. И вот в этом случае уже точно никто
конструктор копирования вызвать не сможет. Вот кто понимает, в чем отличие первого
способа от второго способа? Да, вот в этом случае вы не совсем полностью запретили
копирование. Вот если вы тут внутри напишете какой-то метод, то внутри него вы вполне
спокойно можете копировать элементы, потому что приватные конструктор
копирования означает, что конструктор копирования могут вызывать только методы
вашего класса. В приватной области имеет доступ метод вашего класса. Понятна
история. А если вы помечаете конструктор копирования как равно delete, то это
означает, что вообще никто не имеет права вызывать конструктор копирования, хоть
наши, хоть не наши. Поэтому равно delete это более радикальная вещь, чем
просто приватный конструктор или деструктор. Вопросы? В общем, мораль такая, если вы
хотите полностью запретить использовать какой-то конструктор копирования или в
принципе какой-то метод, то вы просто помечаете его как равно delete. Потому что
если вы тут, например, не напишете равно delete, то компилятор попытается создать
конструктор копирования за вас. Вот если вас это не устраивает, то вы пишете равно
delete. На этом эти слайды закончились, и подводим итог. Мы познакомились с
конструкторами, то есть со специальными методами класса, которые вызываются при
создании объекта. Мы познакомились с деструкторами, которые вызываются всякий
раз, когда объект уничтожается. Мы понимаем, что для конструкторов, для более
эффективной реализации конструкторов нужно использовать списки инициализации.
Мы познакомились с конструкторами равно default и равно delete, которые позволяют либо
попросить компилятор создать что-то за вас, либо равно delete, который говорит, что
вот эту штуку в принципе использовать нельзя и реализовывать ее не надо.
Ну и правила трех тоже следует соблюдать.
Все правильно. Вопросы?
Давайте перейдем к следующей теме. Очередная тема называется перегрузка операций.
Это более интересная часть, более интересная, чем нудные конструкторы-деструкторы.
Давайте поговорим о следующем. Мы когда-то на первой лекции работали со структурой
комплексных чисел. Мы написали структуру комплекс, у которой есть два поля.
Действительно имнимая часть. Действительно комплексное число представляется в виде
двух чисел. Действительно имнимая часть. Ну естественно, как и любые другие числа,
наверное, нам хочется, чтобы их можно было складывать.
Чтобы мы могли взять два комплексных числа и их сложить.
Взять два комплексных числа, посчитать разность, посчитать произведение и так далее.
И собственно, чтобы это сделать, мы можем просто взять и написать функцию сам,
которая принимает два комплексных числа и возвращает некоторое новое комплексное число,
которое является суммой двух переданных.
И при этом возникает следующая проблема. С одно стороны, для того чтобы сложить встроенные
в язык числа нам нужно воспользоваться операцией Плюс.
То есть одним плюс три нам складывают числа. А чтобы сложить два комплексных числа нам нужно
вызывать какую-то дополнительную внешнюю функцию сам, которая и складывает.
То есть возникает некоторая асимметричность, то есть с одной стороны для одних чисел
вам нужно вызывать Плюс, для других чисел вам нужно вызывать специальную функцию.
Наверное, хотелось бы, чтобы можно было брать два комплексных числа и просто складывать их между собой с помощью плюса.
Естественное желание, да?
Просто чтобы был более удобный интерфейн, чтобы можно было более чисто и явно читать ваш код.
И вот хорошая новость заключается в том, что все плюс-плюс это сделать можно.
То есть можно настроить операцию плюс так, чтобы она работала с вашими собственными типами.
И вот мы поговорим об этом.
Возможно, этот механизм, который позволяет вам писать свои реализации операции, называется перегрузкой операций.
Перегрузка операции является примером статического полиморфизма.
То есть помните, когда мы говорили про ООП, мы говорили, что одним из признаков объектно-ориентированного языка является такое свойство как полиморфизм.
Полиморфизм – это один интерфейс с много реализацией.
Перегрузка операции является примером полиморфизма. Почему?
Потому что вы используете общий интерфейс, например, операцию плюс.
И эта операция плюс работает как с интами, как с слотами, так и с вашими собственными типами, например, комплексными числами.
То есть одна операция, но при этом работает со всеми типами по-своему.
Ну, как выглядит синтаксис перегрузки операций?
Очень просто.
Чтобы перегрузить операцию плюс так, чтобы она работала для ваших собственных типов, достаточно написать функцию, которая называется оператор плюс.
Оператор плюс – это специальное имя, которое говорит о том, что мы сейчас определяем свою собственную операцию плюс.
Дальше пишем ее как бы мы писали обычную функцию.
Мы знаем, что операция плюс принимает 2 аргумента, мы говорим, что она принимает 2 комплексных числа,
и возвращает новое комплексное число.
Дальше в фигурных скобках мы описываем, что должна делать функция.
То есть мы складываем действительные части, именимые части и возвращаем новое комплексное число.
Все, и теперь, как только вы перегрузили свою операцию, вы можете спокойно пользоваться операцией плюс и складывать ваши собственные типы, в данном случае комплексные числа.
Мы про унарные, про бинарные, про все операции мы подробно говорим, пока просто про синтаксис, что можно делать так.
Важное замечание. Естественно, когда вы перегружаете свою собственную операцию, компилятор не будет следить за тем, что вы следуете правилам математики.
Если вы перегрузили операцию плюс, которая на самом деле неправильно складывает комплексные числа, компилятор не скажет, что идите, сходите на комплексный анализ и потом возвращайтесь к себе плюс-плюс.
Нет, такого не будет. Компилятору в принципе плевать, что вы напишете внутри операции плюс.
То есть вы можете написать даже вот таким образом. Вы можете написать операцию плюс, которая ничего не возвращает и которая внутри себя просто выводит hello world.
И тогда при складывании двух комплексных чисел у вас будет просто на экране всегда появляется hello world.
Так можно делать, но зачем? Естественно, когда вы перегружаете свою собственную операцию, нужно как-то стараться делать так, чтобы она следовала общепринятой семантике.
Чтобы никто ни у кого не возникало никаких сомнений в ваших умственных способностях.
Ну и вот сейчас мы как раз поговорим, во-первых, мы чуть-чуть поговорим про правила перегрузки, про то, как можно перегружать бинарную операцию, внарную операцию.
Ну и попутно поговорим про принятую семантику известных вам уже операций.
То есть как правильно их перегружать так, чтобы никто не подумал, что вы не свистех, а... ладно, не будем.
Сами подставьте что угодно.
Так, значит, синтаксис перегрузки и операции. Да, в общем, основной синтаксис мы проговорили.
На самом деле существует альтернативный синтаксис, который позволяет вам перегружать операцию как метод класса.
То есть альтернативно вы можете перегрузить оператор плюс непосредственно внутри комплексного числа.
То есть, грубо говоря, вот у вас есть структура комплекс,
и внутри нее вы пишете, собственно, комплекс, оператор плюс, ну и так далее.
Вот в чем отличие перегрузки операций как обычной функции и как метод класса?
Значит, если вы перегружаете операцию как метод класса, вам нужно передавать на один аргумент меньше.
Потому что левый аргумент автоматически считается тем аргументом, относительно которого вы вызываетесь.
Понятно сказал, нет?
Никак. Всегда автоматически левый.
Ну то есть, грубо говоря, если вот эта штука, вот эта штука, у вас раскрывался такой вызов,
то есть когда компилятор встречает вот такую штуку, он, грубо говоря, вместо этого подставляет за вас вызов такой странной функции.
Оператор плюс и дальше в круглых скобках комплекс 1 и комплекс 2.
Если вы реализуете это как метод класса, вот так, то вот эта конструкция у вас раскрывается в другую часть,
точнее в другом виде. В этом случае она раскрывается вот в такую запись.
То есть у вас от левого операнда через точку вызывается операция плюс.
И дальше передается то, что вы передали в скобке. Понятно?
Просто разница такая. Вы можете перегружать операции как внешнюю функцию,
и тогда вам нужно передавать строго то количество аргументов, которые нужно.
Либо вы перегружаете как метод класса, тогда вам нужно передавать на один аргумент меньше.
Но при этом левый операт автоматически считается вот тот, который стоит слева, точнее.
Есть, об этом мы поговорим позже. Различия есть.
И на ваш вопрос можно также перегружать унарные операции.
Унарные операции перегружаются также как бинарные, просто на один аргумент меньше.
В частности вы можете перегрузить унарную операцию минус.
Унарная операция минус принимает один аргумент. Вот вы его передаете.
В этом случае операция минус для комплексного частот находится в зависимости от минуса в действительной части и минус м eightю части.
Названия у них одинаковые, но просто отличаются по количеству аргументов.
Ну и унарные операции, так же как и бинарные, можно перегружать в виде методов класса.
В этом случае действует общее правило. Если вы перегружаете как метод класса, нужно делать на один аргумент поменьше.
Если вы реализуете унарную операцию как метод класса, то не нужно ничего передавать в качестве аргумента.
Уже приори понятно, для какого объекта вам нужно вызывать операцию минус.
Если вы вызываете минус c, то это то же самое, что c.оператор минус.
Если вы перегружаете как внешнюю функцию, то минус c это то же самое, что оператор минус от c.
Просто в зависимости от того, что вы реализуете, у вас раскрывается либо в таком виде, либо в таком виде и это всё больше.
Просто в зависимости от того, что вы реализуете, у вас раскрывается либо в таком виде, либо в таком виде.
Теперь давайте поговорим про общие правила перегрузки операций.
Ну и про конкретные особенности для конкретных операций.
Значит, правил всего 6, общих правил 6.
Первое правило – нельзя переоперировать операции для уже встроенных типов, давайте так скажем.
То есть, вы не можете переоперировать операцию плюс для inta и inta так, чтобы она работала как минус.
Или вы не можете переоперировать операцию плюс для inti candles.
Вот для встроенных типов перегружать нельзя.
Вот то, что есть для встроенных типов – это уже будет навсегда, вы этого никак не измените.
То есть в частности, если вы посчитали, что хорошей идеей было бы перегрузить операцию умножения для
cons char звёздочки и inta, то не получится никак.
Просто запрещено для встроенных типов перегружать операции, понятно?
То есть хотя бы один из аргументов у вас должен быть пользовательского типа.
Например, вы можете перегрузить операцию плюс для комплексного числа int. Вот так можно.
Потому что первый аргумент у вас комплексное число. Это первое правило.
Второе правило состоит в том, что нельзя вводить в язык новой операции.
Например, если вы хотите, так же как и в Python, чтобы умножить-умножить работало как в здении степень,
то воспользуйтесь Python. C++ вам этого не позволяет делать.
То есть вы не можете просто взять и вести новую операцию. Все, нельзя.
Если такой операции в языке нет, то и создать вы ее не можете.
То есть перегружать можно только существующей операции.
Третий пункт. Нельзя менять арности приоритет операций.
Что такое? Арность это количество аргументов, которые принимает операция.
То есть если у вас есть... какая есть чисто Бинарная операция?
Деление. Есть операция деления, которая принимает два аргумента.
Вот вы не можете перегрузить деление так, чтобы оно принимало только один аргумент.
Или вы не можете перегрузить операцию плюс так, чтобы оно принимало три аргумента.
Нельзя. Ну и приоритет операции тоже нельзя.
то есть если в языке с плюс-плюс есть приоритет операций,
собственно, приоритет операций тоже не меняется от этого.
То есть если вы приопределяете операцию плюс, как умножить, а умножить как плюс,
то приоритет этого никак не поменяется.
Существует четыре операции, которые перегружать нельзя.
Это операция разрешения области видимости,
операция точка, тернарная операция
и операция точка звездочек, что бы это не значило.
Короче, общий правил такой.
Если в операции присутствует точка, то перегружать ее нельзя.
Еще есть четыре особенная операции,
которые можно перегружать только как методы класса.
Мы говорили, что операцию можно перегружать как внешнюю функцию,
а может как метод класса.
Но вот есть четыре операции, конкретно вот эти.
Это операция пресваивания, операция круглой скобки,
операция квадратной скобки, операция стрелочка.
Вот их можно перегружать только как метод класса.
Как внешнюю функцию, их перегрузить не получится.
Ну и шестое правило. На самом деле его нужно переименовать таким образом, что не перегружайте операции и, и, или.
Но если вы все-таки их переопределяете, то важно помнить, что они теряют свойства короткого вычисления.
Что такое свойство короткого вычисления для этих операций?
Ну да, да, да. То есть для И означает, что если первый аргумент ложь, то второй аргумент уже в принципе не вычисляется.
Ну а для И, или если первый аргумент это правда, то остальные аргументы тоже не вычисляются.
Вот если вы перегрузили операцию для своих собственных типов, то это уже не работает.
Всегда будут вычисляться и первый, и второй аргумент.
Ну и плюс в старых плюсах до 17 стандарта, то есть еще вот эти операции, они обладают тем свойством,
обладают тем свойством, что у них все аргументы вычисляются строго слева-на вправо.
Для плюса это неверно, для плюсов вполне может вычислиться сначала второй операKNOWN, а потом первый операணт.
Вот для операции и, и, или строго слева-направо.
И в старых плюсах это тоже терялось свойство, но теперь как бы все нормально.
То есть если вы используете 17 стандарт, то у вас в аргумент тоже будут вычисляться сначала первый аргумент,
потом второй аргумент, все нормально.
Ну в общем, шестой правил на самом деле звучит так, что старайтесь не перегружать операции и, или.
Потому что все привыкли, что и или это логические операции, которые работают с булями.
В общем, по-другому не надо делать.
Так, по правилам есть вопросы?
Нет, она потеряет короткую логику только для вашей перегрузки.
Для булей, естественно, короткое учтение все еще работает.
Что еще раз?
Как можно перегрузить операцию в виде метода?
Вот был пример.
Унарная операция минус, и мы ее перегрузили в виде метода класса.
Вот эта фраза, комплекс, выточий, дветочий, оператор, означает, что мы перегружаем метод класса комплекс.
Аналогично, можно операцию минус перегрузить прямо, внести прямо внутрь класса комплекс и перегрузить, то есть и написать как обычный метод.
Единственное отличие, что надо на один аргумент меньше писать.
Об этом мы поговорим, все будет нормально.
Почти про все операции сейчас поговорим.
Общие правила есть вопросы?
Окей.
Ну тогда давайте поговорим про конкретные особенности конкретных операций.
Отвечаю на ваш вопрос.
Есть ли разница, перегружать ли бинарную операцию как метод класса или перегружать ее как внешнюю функцию?
Разница есть.
Общее правило в том, что лучше перегружать как внешнюю функцию.
Вот почему.
Если я написал перегрузку в виде внешней функции, то если я попытаюсь вызвать...
Давайте начнем с верхней строчки.
Предположим, что комплексное число у меня поддерживает конструктор от 0, 2 и 1 аргумента.
При этом заметьте, что это конструктор не explicit.
Конструктор может использоваться для неявных преобразований.
Все числа у меня могут не явно преобразовываться в комплексное число, но это нормальное поведение.
Тут я explicit нарочно не пишу, чтобы разрешить подобные неявные преобразования.
И вот теперь допустим я пишу перегрузку операции плюс как внешнюю функцию.
То есть я принимаю комплексное число y и складываю их внутри.
И таким образом у меня работает и вот такой код.
Ну почему он работает?
То есть вот эта штука раскрывается в вызов функции оператор плюс.
Первое аргументом комплексное число.
Второе аргумент это не комплексное число, но при этом число может спокойно преобразовываться в комплексное число,
потому что у меня есть вот это конструктор.
Понятно, да?
И аналогично я могу вызывать 1 плюс комплекса 2,2.
Потому что один из аргументов комплексное число, а второй аргумент может быть преобразован в комплексное число.
Но, если я перегружаю операцию плюс как внешнюю функцию, то внезапно у меня перестает работать вот такая вот запись.
То есть внезапно мне теперь становится важно, в каком порядке у меня следуют аргументы.
Почему работает верхняя запись?
Потому что у комплексного числа есть метод оператор плюс, который я спокойно вызываю.
А вторая строка в принципе не может быть вызвана. Почему?
Потому что компилятор в принципе не будет рассматривать то, что у единицы можно вызвать через точку какую-то операцию.
Потому что единица это не класс, у нее нет никаких методов.
Поэтому компилятор в принципе не может догадаться, то есть он не видит никакой возможности вызвать операцию плюс.
И поэтому это вызывает ошибку компиляции. Понятно?
Поэтому общий правил заключается в том, что если у вас есть бинарная операция, плюс умножить, минус разделить и так далее, то реализуйте ее как внешнюю функцию.
Чтобы у вас работали неявные преобразования.
Пример понятен?
Перегрузка префиксного инкремента и декремента.
Вы знаете, что существует префиксная операция плюс-плюс и префиксная операция минус.
Как она работает?
Вот как она работает?
Понятно, что она увеличивает что-то на единицу или уменьшает что-то на единицу.
А что она возвращает?
Да, возвращает результат, то есть возвращает новое значение.
При этом не просто новое значение, но вот возвращает просто-напросто исходный х.
То есть она возвращает сам объект х.
И в итоге на самом деле результат операции плюс-плюс можно что-то присвоить.
И в итоге после этой операции у вас будет х равен 5.
Понятно?
Потому что плюс-плюс возвращает, ну грубо говоря, сам х.
Ну или говоря умным языком, который мы узнаем через несколько лекций.
Он возвращает lvalue.
Он возвращает категорию значения lvalue, то есть возвращает сам х.
И об этом стоит помнить, когда вы перегружаете свою префиксную операцию.
Ну префиксную операцию плюс-плюс или минус-минус.
Значит как ее правильно перегрузить?
Ну вот тут пример показан.
Тут показаны два примера, как ее перегрузить в виде внешней функции и как в виде метода.
Но давайте как в виде внешней функции.
Операция плюс-плюс принимает объект комплексного числа по ссылке.
Понятно почему по ссылке?
Потому что мы этот объект хотим изменить.
То есть мы не хотим изменить копию, мы хотим изменить именно тот объект, который нам передается.
Поэтому мы принимаем его по ссылке, увеличиваем в данном случае только действительную часть на единицу.
И возвращаем сам объект.
При этом возвращаем его тоже по ссылке.
Потому что любой разработчик на C++ привык к тому, что операция плюс-плюс возвращает исходный объект.
То есть именно сам объект, а не копию его.
Ну и ровно то же самое можно писать в виде метода класса.
То есть метода класса комплекс.
Но в этом случае вам нужно достаточно просто сделать плюс-плюс re и все.
И тут кстати мы приходим к первому осознанному применению ключевого слова this.
Помните такое слово this в прошлый раз изучали?
This это указатель на текущий объект.
И вот собственно основное применение this это в случае, если мы хотим вернуть ссылку на самого себя.
Ну смотрите, если бы у нас не было this, допустим у нас нет this такого ключевого слова.
Как бы вернули ссылку на самого себя, на самый этот объект?
Ну непонятно как.
Может как-то можно?
Короче я не знаю, хотя наверное можно как-то.
Ладно, не будем об этом говорить.
This нужно для того, чтобы вернуть ссылку на себя.
Чтобы вернуть ссылку на себя, вы разыменовываете this.
Понятно?
This это адрес, по которому лежит вот мой объект.
И чтобы его получить, точнее получить ссылку на него, вы его разыменовываете.
Потому что когда вы разыменовываете указатель, вы же можете разыменованному указателю присвоить какое-то значение.
И вот тому значение, на которое он указывает, он изменится.
Из этого следует.
То есть это просто доказательство того, что возвращается на самом деле ссылка.
Ну или возвращается lvalue.
Вот.
Ну и аналогично префиксному инкременту и префиксному декременту есть посфиксные инкременты и декременты.
Чему они отличаются от префиксного?
Да, они возвращают копию начального значения.
То есть они возвращают не измененное значение, а они сохраняют то, что мы говорили.
Они возвращают не измененное значение, а они сохраняют исходный объект и потом его возвращают.
Окей?
И тут возникает довольно интересная, снова парадоксальная ситуация, снова приколы C++.
Смотрите, есть префиксный инкремент, он принимает один аргумент.
Есть постфиксный инкремент, и он принимает тоже один аргумент.
Как отличить один от другого?
И вот было принято гениальное решение, нужно второму принимать фиктивный аргумент int.
То есть это абсолютно фиктивный аргумент, который просто служит для того, чтобы сообщить, что вот сейчас я перегружаю постфиксную операцию.
И все.
Его на самом деле нельзя передать.
На самом деле его можно как-то обозвать, то есть можно сказать int x.
Этим x-ом даже можно внутри пользоваться, но при этом передать x непосредственно в эту функцию никак нельзя.
Но это просто вот такой костыль, чтобы отличать префиксную операцию от постфиксной операции.
Ну и как работает постфиксная операция?
Значит, мы сначала сохраняем старое значение, потом увеличиваем то значение, которое нам передали, и возвращаем старое значение.
Ну при этом, естественно, возвращаем не ссылку, потому что ссылку на локальный объект возвращать не стоит, но возвращаем копию старого объекта.
И тут на самом деле такая демонстрация того, что лучше всегда использовать префиксный инкремент, чем постфиксный инкремент.
Потому что префиксному инкременту нужно сделать некоторые дополнительные действия, сохранить старый элемент, а потом его снова вернуть.
Вот префиксному ничего не нужно, он просто увеличивает и возвращает себя же. Вот и все.
Поэтому в общем случае префиксный он, во-первых, он чуть более эффективен, особенно если мы говорим про какие-то тяжелые объекты.
Смотрите, если я попробую вернуть ссылку, то у меня будет проблема. Я возвращаю ссылку на локальный объект.
То есть я возвращаю ссылку на объект, который уже по выходу из функции будет уничтожен.
Это называется провисшая ссылка, висячая ссылка.
Но ровно как и указатель на локальные элементы тоже возвращать не стоит.
Следующая операция, про которую мы поговорим, это операция взять элементы по индексу.
Или квадратные скобки. Напомню, что в рамках общих правил операцию квадратной скобки можно перегружать только как метод класса.
Как внешнюю функцию перегрузить нельзя. Это первая особенность.
А вторая ее особенность заключается в том, что она может принимать только один аргумент.
То есть в квадратных скобках можно написать только один аргумент.
То есть нельзя написать ноль, нельзя написать два, три и так далее.
Ну, для чего это может быть нужно?
Например, если вы пишете какой-то класс, который представляет из себя массив или строку.
Что? Еще раз.
Если вы пишете двумерный массив, то в квадратных скобках нельзя указать два аргумента.
В общем, в квадратных скобках нельзя указать два аргумента.
Ну, в задании у вас есть матрица, и там в качестве решения этой проблемы мы пишем круглые скобки.
В круглых скобках, ну, забегай вперед, в круглых скобках можно сколько угодно аргументов написать.
А в квадратных скобках только один.
Ну, например, если вы пишете свой класс массива, то вы можете перегрузить операцию квадратной скобки,
которая просто возвращает, ну, собственно, по указателю возвращает...
Ну, короче, от указателя берет квадратные скобки и возвращает результат.
Ну, а для матрицы, вот как я сейчас только что ответил, нельзя.
То есть если вы пишете свой класс для матрицы, то круглые скобки не могут принимать два аргумента.
Квадратные скобки всегда принимают только один аргумент.
Окей? Окей.
Ну и сразу же про круглые скобки. Снова круглые скобки, ровно как и квадратные скобки,
могут быть перегружены только как метод класса.
То есть непосредственно внутри класса вы можете реализовать круглые скобки.
Как внешнюю функцию круглые скобки вы перегрузить не можете.
И в отличие от квадратных скобок круглые скобки могут принимать абсолютно произвольное количество аргументов.
Хоть ноль, хоть один, хоть два, хоть десять.
Ну, вот такой пример.
Допустим, мы написали структуру Printer, которая перегружает операцию круглые скобки.
Эта операция круглые скобки принимает int, принимает C-шную строку и принимает
чар. И что теперь можно делать с этой структурой?
Ну, можно создать объекты этой структуры.
И теперь объекты этой структуры можно вызывать как обычные функции с помощью круглые скобок.
Ну, вот такие объекты еще называются функторами.
Функтор.
То есть функтор – это объекты, у которых можно вызвать круглые скобки.
Ну, потому что они ведут себя примерно таким же образом, как и обычные функции.
Окей?
Вот.
Пример понятен?
Ну, или для класса матрицы, например, вы можете определить тоже оператор круглые скобки,
передавать туда sizeTi, sizeTj.
Ну, и дальше уже возвращать элемент по индексу ij.
Ну, и дальше уже возвращать элемент по индексу ij.
Так.
Ну, и наконец, перегрузка операции присваивания.
Значит, это тоже особенная операция, и, вот, если вы помните,
операция присваивания фигурирует в правил cel3.
Вот. В правил cel3 говорится, что если вы перегружаете,
точнее если вы пишите свой деструктур конструкции копирования или операцию присваивания копирующую,
то вам нужно лизать все три.
Вот. Значит, как работает классическая операция присваивания?
Классическая операция присваивания работает следующим образом.
Понятное дело, что она должна взять элемент, который стоит справа, и записать его в объект,
который стоит слева. А что возвращает операция присваивания?
Она возвращает объект, который стоит слева, но, если быть точнее, она возвращает ссылку на объект, который стоит слева.
То есть, если я напишу так, вiele OctaveX, что будет записано?
1, да, потому что операция пресваивания работает следующим образом. Сначала вычисляется x равно 0, то есть x' присваивается 0
и операция пресваивания возвращает сам x, то есть тут вместо пресваивания возвращается x. И теперь этому x' присваивается единица.
То есть в итоге x' будет присвоена единица.
Я думаю, это мы разобрали то, как действует обычная операция пресваивания.
Для обычных типов.
Естественно, моя мысль заключается в том, что свои операции нужно реализовывать с учетом вот этого.
То есть операции нужно реализовывать так, чтобы они были похожи на поведение классических встроенных операций.
Но вот в частности, если мы знаем, что операция пресваивания, которая работает со встроенным типом, возвращает ссылку на элемент,
точнее вот на тот элемент, к которому учет пресваиваем, то и наша операция тоже должна возвращать ссылку на этот элемент.
Ну и операция пресваивания, копирующая, должна принимать ссылку на элемент того же типа.
Понятно почему ссылку, и понятно, почему константную ссылку. Ровно те же самые правила, что и для конструктора копирования.
Ну и как выглядит операция пресваивания для комплексного числа.
Мы просто копируем действительную часть, копируем немую часть и возвращаем this. Вот и все.
В смысле, чтобы она возвращала ссылку?
Опять же, давайте вернемся вот прям вот сюда.
Любая ваша операция может делать что угодно. Никто вам не указал, в общем, может делать что хотите.
Но желательно, чтобы вы делали так, как делают нормальные люди.
То есть, в принципе, вы можете написать операцию пресваивания, которая не пресваивает, а делает что-то еще.
Вы можете написать операцию пресваивания, которая возвращает не ссылку, а возвращает что-то другое.
Но лучше, если она будет вести себя так, как все от нее ожидают.
Стандартное ожидаемое поведение от операции пресваивания.
Ну и правила для операции присваивания. Операция присваивания особенно еще тем, что если вы не
реализ·ите свою соб·ствуную операцию при сваивании, то апп сериал об步 работит
Ровно как и для конструктора-по-умолчанию деструктора-и конструктора копирования. Если вы не написали
свою собственную операцию при сваивании, то она будет написана за вас. То есть компилятор за вас
напишет операцию при сваивании. Эта операция при сваивении-по-умолчанию, она просто JUST возьмет
возьмет и присвоит все поля. Условно, если у вас есть класс A, у которого есть
поля x, y и z, если задаете A, задаете B, потом a-шки присвоите B, то у вас
произойдет следующее. a.x равно b.x, a.y равно b.y и a.z равно b.z.
Вот ровно это сделает за вас компилятор.
Зачем нужна операция скобочки, если можно писать просто метод?
Давайте подумаем. Смотрите, как вам удобнее, если у вас есть какой-то массив,
что вам удобнее? Вызвать array 0.get, а круглые скобки нужны как в случае матриц,
чтобы можно было индексироваться. Это первый случай. Второй случай, более подробно про то,
зачем перегружать операцию круглые скобки, мы, наверное, поговорим ближе к концу курса,
когда будем говорить про всякие лямбдовыражения, стандартные алгоритмы и так далее.
В общем, иногда хочется написать объект, который ведет себя как функция, чтобы его можно было
передавать в другие функции, например. Если нам нужен объект, который ведет себя как функции,
то это можно создать с помощью структуры и перегрузки операции круглые скобки.
С операцией присваивания понятно. Операция присваивания фигурой правилы 3,
то есть ее тоже нужно реализовывать, если у вас есть какая-то нитриальная работа с ресурсами.
Если вы не пишете свою операцию присваивания, то она просто берет и присваивает все поля по
отдельности. Операция присваивания, я это не говорил, но это в общих правилах есть.
А операция присваивания – это операция, которую можно перегружать только как метод
класса. Как внешнюю функцию операцию присваивания нельзя перегружать.
Важный момент. Присваивание нельзя перегружать как внешнюю функцию, а вот всякие плюс равно,
минус равно, умножить равно и так далее, вот их можно. То есть плюс равно минус равно
пресваиванием не считаются. Их можно реализовывать как обычные внешние функции и так далее.
Исключение касается только самого пресваивания.
Это, наверное, даже где-то должно быть прописано.
Это мы уже обсуждали, что если у нас есть в классе какое-то нетривиальное управление ресурсами,
то стоит операцию пресваивания писать самостоятельно, а не доверяться компилятору.
Но снова понятно почему. Потому что нас не устраивает, что если у вас есть какой-то stack x,
который указывает на какую-то область памяти, есть stack y, который указывает на какую-то область памяти.
Да, вот тут, кстати, будет проблема. Смотрите, если я stack x, присвою y, то что у меня произойдет?
У меня x теперь будет указывать туда же, куда указывает y.
И тут возникают сразу две проблемы.
Во-первых, x и y указывают на одну и ту же область памяти, а во-вторых, вот эту память мы уже безвозвратно потеряли.
То есть мы потеряли на нее указатель, и все, у нас утечка, без возможности восстановления.
Поэтому если вы работаете с ресурсами, то операцию пресваивания тоже нужно перегружать обязательно.
Пример, как это можно сделать, показан здесь.
Что нужно сделать для stack? Во-первых, нужно удалить старую память, выделить новую память,
скопировать размер другого stack, ну и даже в цикле скопировать все содержимое другого stack в наш stack.
Ну и не забыть вернуть this, точнее разыминованный this.
Потому что операция пресваивания обычно возвращает ссылку на себя.
И вот это тоже не совсем хорошая реализация операции пресваивания, вот по какой причине.
Вот что если я вдруг захочу сделать довольно странную, но все равно, вот такую вещь.
А равно а.
А почему?
Да, смотрите, если я попытаюсь сделать, это называется проблема самопресваивания,
то есть если я попытаюсь объект присвоить самому себе, то у меня в общем случае возникнет ошибка,
ну проблема точнее, почему? Потому что в этом случае у меня a.
То же самое, что и this, точнее разыминованный this, согласны?
И когда я у себя удаляю буфер, я на самом деле буфер удаляю и у a.
Потому что a. это то же самое, что и я, понятно?
И по сути вот в этой строке что происходит? Я из уже удаленной памяти копирую снова в себя же.
То есть я уже из какого-то мусора копирую вот свой буфер.
Ну то есть проблема явная.
Ну если, соответственно, чтобы избежать этой проблемы, обычно пишут так называемую защиту от самопресваивания,
просто в начале операции пресваивания вы пишете проверку.
Ну вот, вот она здесь написана.
Это вы пишете в самом начале.
То есть если я, то есть this, не совпадает с other, то есть точнее address other, то место, где расположен other,
не совпадает со мной, то есть то, где располагаюсь я и то, где располагается other, это разные места,
тогда я могу выполнять пресваивание.
Если нет, то в общем не выполняю ничего.
Ну то есть это выглядит так.
Если this не равно address other, то я что-то делаю.
Вот все вот это проделываю.
А иначе просто ничего не делаю и возвращаю сразу.
Понятно?
Это защита от самопресваивания. То есть это еще один пункт, про который нужно помнить, когда вы реализуете свою операцию пресваивания.
То есть нужно помнить про защиту от самопресваивания.
А это по кодстайлу. Все глобальные константы, все статические константы по кодстайлу у нас должны начинаться с префикса k
и писаться в camel-кейсе.
Но чтобы подчеркнуть, что это глобальные константы.
Честно говоря, я сам не знаю, но такой синтаксируется.
А, ну вот как раз слайд про составные операции пресваивания.
На них подробно останутся не будем.
Но я не знаю, как работают остальные операции пресваивания.
То есть плюс равно, умножить равно, делить равно.
Они изменяют объект, который находится слева за счет объекта, который расположен справа.
При этом они ровно как и обычные операции пресваивания.
Ну, во-первых, изменяют сам объект, а во-вторых, возвращают ссылку на измененный объект.
Вот и все.
Но при этом, в отличие от обычной операции пресваивания, они могут быть реализованы как внешняя функция.
Вот, например, как здесь показано.
То есть в качестве левой операнта вы принимаете ссылку на комплексное число,
а в качестве правой операнта принимаете просто константную ссылку на число.
Потому что то, что стоит справа, не изменяется.
Ну вот, вы выполняете необходимые действия, и дальше возвращаете левое число, то есть левый оперант.
То же самое можно сделать с помощью реализации в виде метода класса.
То есть в этом случае вы принимаете просто правый оперант по константной ссылке
и возвращаете разыминованный this.
Все стандартно.
Ну и теперь в качестве последовательного пункта подробно поговорим про перегрузку побитого сдвига.
Смотрите.
Казалось бы, кому может прийти в голову перегружать побитый сдвиг?
Это как-то странно. У вас есть комплексное число, что значит сдвинуть его побитого влево?
Как-то странно все поля сдвигать побитого влево.
Или у вас есть класс массива, как-то странно его тоже побитого как-то сдвигать и так далее.
Тем не менее, побитого сдвиг перегружают регулярно.
Почти всегда.
Но просто его, как правило, перегружают для того, чтобы перегрузить вывод и ввод из потока и в поток.
Вы вряд ли в прошлом семестре обсуждали, почему C in и C out работают именно таким образом.
Почему побитого сдвиг для C in и C out работает как вывод или ввод?
И вот сейчас мы подробно об этом поговорим.
Как это работает? Почему это работает?
И как заставить C in и C out, точнее как подружить C in и C out со своими собственными классами.
Тут история такая. Начнем с далека.
Давайте сначала разберемся с тем, что такое STD C in и что такое STD C out.
Где-то в стандартной библиотеке, определён класс, стандартная библиотека состоит из большого количества классов.
В частности, в стандартной библиотеке обрели классы E stream и O stream.
От слова input stream, то есть поток ввода, и output stream, поток вывода.
STD E stream и STD O stream – это классы.
А STD C in и STD C out – это объекты этих самых классов.
То есть где-то в стандартной библиотеке обрел класс.
Не STD, а просто обрел класс E stream или O stream.
И тоже в стандартной библиотеке обрела переменная O stream, C out.
C in и C out – это просто некоторые переменные, которые имеют тип E stream или O stream.
Так как C in и C out – это пользовательский тип, класс, не встроенный тип,
для них можно перегрузить некоторые операции.
В частности, для них перегружены операции по bit.ly влево и по bit.ly вправо.
Так что они что-то внутри себя пишут, то есть передное значение они внутри себя пишут,
или передное значение куда-то что-то выводят.
Важно понимать, что C in и C out, ровно как E stream и O stream –
это не единственные потоки, которые существуют в стандартной библиотеке.
В стандартной библиотеке есть куча других потоков.
Например, есть поток E stream, есть поток O stream, есть O stream stream и E stream stream.
Первые два осуществляют вот или вывод файл.
Можно писать конкретный файл, у вас на компьютере создается файл с нужным вам содержимым.
Или если у вас в файле записано какие-то данные, их можно считать с помощью потока ввода из файла.
Также можно данные записать в строку или считать данные из строки.
Здесь пример приведен для строк.
Например, я могу создать поток ввода из строки, то есть я создал строку 123 и создал поток S in.
Из этой строки я могу считать данные x, y и z, то есть могу считать 3 целых числа.
Ровно с помощью такого же синтакса, как я это делаю с помощью stdc и stdcout.
Или я могу попытаться вывести в строку, то есть я могу записать данные не в консоль или файл, а в какую-то строку.
Но делаю в следующем образом. Я создаю объект sout, типа O stream stream,
ну и дальше вот в этот самый sout вывожу данные x через запятую y, через запятую z.
И теперь я эту строку могу получить с помощью метода str.
И вот этот метод мне вернет строку 1,2,3.
По-моему, у sin нет str, это надо уточнить, я точно не в курсе. Может есть, может нет.
В общем-то, общая концепция понятна. Есть потоки, и sin и sout это просто объекты потоков.
Объекты потоков вы можете создавать самостоятельно.
Например, с помощью sin, sout, ну или можете создать свои файловые потоки,
они будут работать так же, как и обычные потоковые консольные вводы и выводы.
Ну точно можно указать нужную вам строку в конструкторе.
Можно ли как-то ее впоследствии дописать, я, честно говоря, не в курсе.
Нужно в документацию посмотреть, можно ли там что-то делать или нет.
В общем, общая идея понятна.
Так вот, почему же все-таки операция по битву издвига работает с объектами класса estream и ostream?
На самом деле, да, я уже рассказывал, в общем, идея стоит в том, что в стандартной библиотеке
перегружена операция по битву издвига влево или по битву издвига вправо.
Так, что вместо того, чтобы осуществлять по битву издвиг, она осуществляет ввод или вывод.
Понятно? То есть вот эта вот операция, то есть вот эта вот запись sdsin вправо-вправо x,
это не что иное, как просто вызов бинарной операции по битву издвига,
но просто перегруженный для типа estream.
Тут никакой магии нет, просто перегрузка операции, про которую мы уже час говорим.
Да, ну и тут есть вопрос. Как вы думаете, любая операция, она что делает?
Она выполняет какие-то действия, в данном случае она записывает что-то в поток,
точнее записывает из консоли что-то и, естественно, что-то возвращает.
Как вы думаете, что возвращает операцию по битву издвига, применённую к потоку?
Есть ещё идея, есть вариант bool. Что ещё?
Скан возвращает количество изчитанного.
Скан возвращает количество изчитанного, да, но а sin что возвращает?
Возвращает поток.
Возвращает поток, а если точнее?
Ссылку на поток.
Ну ссылку на поток, да, действительно.
Давайте задумаемся, смотрите, как мы можем использовать поток-вывод и вывод.
Ну в частности наверняка вы использовали вот такой вот, как называется, трамвайный поток.
Как конвейерный поток. Вот или вывод.
То есть std sin x, а потом то же самое, но y, да?
И как это работает? Ну смотрите, чтобы это работало, чтобы это работало,
ну смотрите, давайте рассмотрим, давайте посмотрим вот на эту операцию.
Вот чтобы она работала, чтобы она работала, ей нужно в качестве левого операнда тоже передать поток.
Поэтому, то есть это раскрывается следующую вещь.
Тут как будто бы вот тут стоят скобки, и даже от того результата, который получается в скобках,
мы вызываем побитву из двиг вправо.
И вот чтобы это работало точно так же, как и вывод, точнее, ввод из потока,
необходимо, что вот то, что стоит в скобках, возвращало нам исходный поток.
И вот ровно так побитву из двиг, перегруженной для операторов ввода или вывода в поток, ровно так он и работает.
То есть прототип их выглядит следующим образом.
То есть оператор побитого из двига вправо принимает поток ввода по ссылке
и принимает ссылку на элемент, в который нужно что-то ввести.
Понятно почему по ссылке, потому что мы изменяем тот элемент.
И возвращаем мы ссылку на оперенный поток, чтобы могли работать вот такие вот конвейерные вводы или выводы.
Ну и то же самое касается оператора вывода из потока,
потому что если вы пишете что-то в поток, то естественно вы тоже можете делать вот так.
Тут все понятно?
То есть важно понимать, что вывод из потока и в поток работает так, что, во-первых, это просто перегруженная операция побитого из двига,
а во-вторых, чтобы работала конвейерная вывод или конвейерный ввод, они просто возвращают ссылку на передный поток.
Ну и теперь, если вы хотите переопределить операцию ввода или вывода в поток или из потока для своих классов,
понятно, что теперь нужно сделать.
Нужно просто перегрузить операцию побитого из двига влево или побитого из двига вправо, вот и все.
То есть если вы это не перегрузите, то естественно комплексное число просто так выводить на экран у вас не получится.
Потому что STDCOUT не знает, как выводить в поток ваши данные.
То есть как перегрузить, например, операцию вывода в поток для вашего комплексного числа?
Ну очень просто. Вы пишете оператор с двига влево, дальше вы принимаете по ссылке поток и принимаете по константной ссылке ваше комплексное число.
Ну а дальше, собственно, вы пишете, в каком виде это все нужно вывести.
Ну вот вы пишете, что в поток, нужно записать сначала действительную часть, потом плюс, ну и потом минимум часть.
А если вы хотите вывести комплексное число 5, 3, то выводите 5, потом плюс, потом 3, потом пишете И.
И вот ровно в таком виде у вас будут вводиться данные.
Когда вы будете, например, делать STDCOUT от С.
Вот, аналогично для операции ввода из потока.
В качестве первого аргумента вы принимаете ссылку на поток вода.
Надо помнить, что вам нужно вернуть ссылку на поток вода, чтобы сработала эта конвертная штука.
И в качестве правого аргумента вы передаете комплексное число по ссылке, ну потому что вы его изменяете, естественно.
Ну и дальше вы пишете, что из потока нужно ввести сначала действительную часть, а потом из потока нужно ввести минимум часть.
То есть теперь, когда вы пишете STDCIN C и в консоль пишете 5, 3, то у вас в C записывается комплексное число 5, плюс 3, и.
Окей? Вот. Вопросы? Да.
Ну нужно отдельно обработать вот этот центральный плюс.
То есть отдельно считать 5, потом отдельно пропустить нужное вам количество символов, и 3.
Что?
Что такое поток? Поток это просто можно считать, что объект класса STDOStream или STDEStream.
Я думаю, на этом понимания достаточно. То есть объект класса EStream или OStream мы называем потоком.
Ну и тут стоит вопрос, смотрите.
Вот часто возникает такая ситуация, что мы для нашего класса делаем приватные поля.
Ну например, для комплексного числа мы можем сделать так, что у нас поля, действительная часть и минимум часть, они приватные.
А доступ к ним мы получаем с помощью специальных методов. Ну можем так сделать? Можем.
При этом понятно, что операции ввода или вывода в поток мы можем реализовывать только как внешнюю функцию.
Ну понятно почему. Потому что мы не можем реализовать их как метод. Мы не можем написать метод внутрь потока.
Потому что он где-то определен в стандартной библиотеке. То есть мы не можем залезть в кишки стандартной библиотеки и написать, что вот для моего класса делай вот так.
То есть операцию ввода или вывода поток мы можем реализовать только внешнюю функцию.
А внешние функции не имеют доступа к приватным данным.
И вот тут может возникнуть проблема. А как считать данные в мой объект, если данные приватные?
Ну например, представьте себе, что у меня вот это вот поле Re и поле Im, это приватные поля. Вот как в них что-то считать?
Ну можно, да, можно через специальные методы, сеттеры. Типа set Re, set Im и так далее. Но это не всегда удобно.
И вот тут очень подходящий или неподходящий момент, но тут можно поговорить про дружбу C++.
Значит, в C++ классы умеют дружить с некоторыми функциями. Но более того, классы умеют дружить между собой.
Что это означает? Если ваш класс объедил какую-то функцию своим другом, то это значит, что этой функцией разрешено лезть в приватные поля.
Вы вряд ли помните, но на предыдущей лекции, когда мы говорили про приватные поля, там была отдельная сноска,
что приватные поля запрещают доступ всем остальным, кроме друзей. То есть приватные поля запрещены, доступ к приватным полям запрещается всем, кроме друзей.
Как объявить функцию другом? Очень просто. Если вы пишете свой класс, вы внутри своего класса пишете friend,
ну и дальше пишете про те функции, которые вы хотите объявить другом. То есть вы говорите friend и дальше пишете, кто ваш друг.
Здесь вы говорите, что функция print является вашим другом. Что это означает? Это означает, что теперь функция print,
которая написана где-то вне, которая написана где-то снаружи класса, теперь эта функция имеет полный доступ приватным полям вашего класса.
Но в частности она может воспользоваться полем size, которое приватное, она может воспользоваться полем buffer, которое приватное и так далее.
То есть полный доступ к внутренностям вашего стека эта функция имеет.
Что еще раз? То же самое. Вы можете объявить другом метод кого-то из другого класса. То есть вы можете написать friend,
а дальше например void a.f. Вот это означает, что вы объявили метод класса a своим другом.
Более того, другом, давайте его есть, скорее всего есть, но давайте на всякий случай скажу, что другом можно объявить и другой класс.
То есть если вы хотите, чтобы класс a, ну какой-то другой класс, friend, класс a. То есть если вы хотите, чтобы какой-то другой класс, например класс a,
имел полный доступ к приватным полям стека, вы можете написать вот такую строку.
То есть другом можно объявить функцию, можно объявить метод другого класса, или можно объявить другой класс целиком.
В этом случае вот то, кого вы объявили другом, будет иметь полный доступ к вашим полям.
Дружба нетранзитивна, к сожалению, как и в жизни. Если я говорю, что вы мой друг, то я вам как бы разрешаю всем пользу.
Но это не значит, что я для вас стал другом, понимаете?
Поэтому, если я сказал, что класс a это мой друг, то это не значит, что стек стал другом для класса a.
Внутри класса стек. Ну где-то внутри класса стек.
Без разницы абсолютно. Да, вот тут приватность публическая не работает.
Внутри мэйна? А, функцию мэйн сделать своим другом.
Тогда из мэйна вы можете вызывать приватные поля, но так не делают обычно.
Нет, объявление friend является объявлением.
Отдельное объявление делать не нужно.
Если вы сделали объявление friend, то считайте, что вы написали про тип функции.
Есть такое из области шизофрении, вы можете объявить друга и сразу его создать.
Сделать друга или воображаемого друга.
Если вы хотите написать функцию, которая является вашим другом,
то вы можете объявить функцию print другом и сразу ее реализовать.
Вот это мой друг и вот он такой.
То есть так тоже можно.
На этом слайде показано, что другом может быть метод другого класса
или другой класс целиком.
Ну вот тут пример.
Соответственно, класс a объявляет класс b целиком другом,
а класс b объявляет только метод f своим другом.
Поэтому методу f класса a можно обращаться к приватной части класса b,
а методу h нельзя, но при этом классу b
класс b имеет полный доступ к приватным частям класса a.
Потому что сам класс a сказал, что b это мой друг.
Ну и теперь, собственно, вот пример реализации,
например, потокового ввода для класса комплексного числа.
Если вдруг так получилось, что поля у моего класса комплекс, они приватные.
То есть что я делаю?
Я говорю, что операция побитого с двига вправо,
ну вот такая, является моим другом.
Вот, и теперь я могу вот внутри этой операции
свободно использовать точка re, точка im.
Ну и все нормально.
Ну это способ обойти приватность, то есть объявить кого-то другом.
То есть если вам нужна какая-то функция,
и вы хотите, чтобы эта функция имела полный доступ к вашим приватным полям
или к приватным методам, вы просто объявляете ее другом.
Вот и все.
Ну это был последний слайд, но при этом я хочу сделать небольшое замечание
про то, что не стоит плодить очень много друзей.
Ну вообще слово friend нужно использовать с осторожностью.
Что в жизни, что вот здесь.
Почему?
Потому что я могу объяснить с архитектурной точки зрения.
Ну вот, представьте себе, что у вас есть класс.
У него есть какое-то, давайте назвать, приватное ядро.
Что мы обычно помещаем в приватную область?
Ну какие-то детали реализации, то есть как реализован мой класс.
Например, для стека в приватную область мы поместили буфер,
то есть массив, в котором хранятся элементы, и размер.
То есть в данном случае мы в качестве реализации используем стэк на массиве.
Ну из этой реализации обычно торчат какие-то публичные,
давайте вот, закрашенная часть это приватная часть,
а не закрашенная это публичная часть.
То есть у вас есть какая-то приватная часть,
которая отвечает за детали реализации, то есть как реализован ваш класс.
И дальше из нее у вас торчат публичные геттеры,
то есть публичные методы, которые позволяют вам
получать доступ к этим самым приватным полям,
или пользоваться вашей реализацией.
В частности это, не знаю, какой-нибудь push, top, size, ну и так далее.
И у вас может возникнуть мысль, ну смотрите,
а зачем не использовать вот эти вот самые push, top и size,
если я пишу свою собственную функцию,
допустим, я пишу функцию f ну и бла, бла.
Ну, допустим вы думаете, что, ну смотрите, я сам реализовал класс стэк,
то есть я пишу свою библиотеку и я написал класс стэк,
ну я пишу какую-то функцию f, которая работает со стэком.
Ну мне как-то хочется, например, напрямую работать с данными,
с приватными данными стэка.
Ну почему, потому что я же реализовал стэка, да,
то есть я реализовал стэк, я понимаю, как он внутри устроен,
поэтому я, наверное, смогу использовать вот эти самые внутренние представления
внутреннее представление в своих функциях, поэтому я объявляю функцию f своим другом.
Почему так делать не стоит? Представьте, что у вас куча друзей, которые лезут в вашу
приватную область, функция f, функция h и так далее. Почему это плохо? Представьте себе, что
ваша программа эволюционирует, ваша библиотека эволюционирует, и в какой момент вы
поняли, что, наверное, лучше stack реализовывать все-таки на связанном списке.
Потому что вы так вот потестировали, собрали эти отзывы от пользователей и поняли, что гораздо
эффективнее у вас будет реализация, если это будете реализовать на связанном списке.
И решили взять и всё изменить. Полностью переписали ядро вашего класса реализацию.
Что из этого следует? Что вам теперь нужно изменить реализацию f? Потому что f у вас
было завязано на том, что у вас stack реализовано массиве. Вам нужно изменить реализацию h.
То же самое для функции g. Чем больше вы лезете в вашу приватную область,
больше вы зависимости распространяете на другие функции. Понятно? Поэтому правильный
способ является следующим, то есть не плодить друзей, а стараться все остальные
функции h и g реализовывать через публичный интерфейс, через методы top, size и так далее.
И вот если вы реализовываете так, то даже если вы измените внутреннюю
реализацию, то вам достаточно будет изменить методы push, top, size и так далее,
то есть какой-то ограниченный набор действий. Вот. И все остальные функции, которые
используют ваш публичный интерфейс, автоматически будут работать корректно,
потому что они уже не зависят от деталей реализации. Понятно? Короче, друзей
должно быть как можно меньше. И вот на этой ноте давайте закончим лекцию.
Окей? Все, спасибо.
