Всем добрый день! В прошлый раз мы остановились на том, что обсудили теорему о поиске точек
сочинения в неориентированных графах. Напомню, что мы доказали. Мы доказали следующий результат,
что если нам дан мы не ориентированный граф, то что можно сказать.
Вот если дан мы не ориентированный граф и мы запустили DFS на таком графе,
со старта вершины R, то вершина R будет являться точкой сочинения тогда и
только тогда. То есть, вершина, которая является корнем будет точкой сочинения тогда и только
тогда, когда у нее в дереве обхода в глубину более одного сына. Вот, это первое. А второе,
второе, второе, у нас было следующее. Что если вершина U не совпадает со стартовой точкой DFS,
то есть не является корнем дерева обхода, то она точка сочинения тогда и только тогда,
когда у нее есть сын, из которого нельзя попасть в предку вершины U. Следующая вещь. Вот у
вас есть вершина U, у нее есть сын V, тут какие-то предки. И вот если отсюда нельзя попасть в
предков, то вершина U является точкой сочинения. Что еще мы сделали? Мы рассмотрели две
характеристики графа, первая это, точнее, характеристики вершины. Это time in, то есть время
обнаружения, собственно так, как мы обсуждали на лекции по DFS, и вереновую характеристику time up,
то есть та высота, на которую можно подняться, двигать только по ребрам дерева и одному обратному
ребру. Ну двигаться можно только по направлению, которое задано естественным обходом графа. В том
смысле, что если вы располагаете вершины сверху вниз, то есть предки расположены выше, а потомки
ниже, то ребра дерева вы направляете сверху вниз, а обратные ребра снизу вверх. Так вот, если вам
разрешено двигаться только по ребрам дерева и по одному обратному ребру, то вот time up это то,
та высота, на которую можно подняться, используя только одно обратное ребро. Ну и мы сказали,
что условие 2 теоремы, оно на самом деле в точности совпадает с вот таким условием,
что существует C&V, у которого time up больше либравен, чем time in A2. Ну и в конце мы коротко
обсудили, как вот эту самую характеристику time up можно считать. Ну time up это, собственно,
минимум из time in для текущей вершины, минимум из всех time in для вершин, в которые идут обратные
ребра, и time up для всех вершин, в которые ведут ребра дерева. Ну и соответственно,
что мы понимаем? Мы понимаем следующее, что time in можно высчитывать прямо в процессе обхода
в глубину, time up тоже можно высчитывать прямо при обходе в глубину. Давайте коротко опишем,
у нас есть цикл. DFS visit, вот граф G, родитель P и вершины V. Ну опустим там все части,
связанные с цветами, с посещением. Давайте просто рассмотрим основной цикл. For VU in.
Среди соседей вершины V. Смотрим, значит, если VU это обратное ребро, вот как определить обратное
ребро или нет, мы разбирали. Понятно, что если у нас ребро ведет в серую вершину, то мы встретили
обратное ребро. Вот, значит, если это обратное ребро, то что мы делаем? Вот смотрим на эту
формулу. Если мы видим, что у нас есть ребро, который ведет, точнее, есть обратное ребро,
которое ведет в какую-то вершину back, то мы можем time up обновить до time in not back. Точнее,
написать следующее. Time up от V равно minimum из time up от V и time in not U. Ну а далее,
если VU это ребро дерева, то что мы делаем? Если мы видим нового сына, то есть видим
белую вершину, точнее, видим ребро дерева, то мы увеличиваем число детей для вершины V. Это первое.
Второе. Мы можем репурсивно запустить DFS visit от вершины U. Ну и дальше, в этот момент, после того,
как у нас закончился вызов DFS visit для вершины U, что мы знаем? Ну для нее был корректно посчитана
характеристика time up. Time up от U. То есть мы прошли в эту вершину, DFS там как-то завершился,
соответственно, time up для вершины U уже был посчитан. Ну и все, в этот момент мы уже можем выполнить
проверку. Если вершина V не является корнем, и time up от U больше либо равен, чем time in not V,
то просто пишем, что V это точка сочленения. Ну и в конце проверяем, если вершина V все-таки была
корнем. Ну в конце, в смысле, после того, как весь цикл завершился, проверяем, если вершина V была
корнем и число ее детей больше, чем один, то V это точка сочленения, articulation point. Ну,
идейно понятно, да? То есть вот, то есть мы буквально воспользовались двумя формулами. То есть вот этой
формулой. Здесь U и V у нас поменены местами, не важно, да? Вот, то есть мы воспользовались вот этой
формулой внутри этого U и V. То есть если это условие выполняется, то значит V это точка сочленения.
Ну и плюс в процессе нашего обхода в глубину мы подсчитывали еще и time up. То есть time up обновили
здесь. А, и time up на самом деле нужно было обновить здесь. Давайте, тут мы забыли. V это та вершина,
из которой мы вызываем, а U это та вершина, которую мы сейчас будем обрабатывать. Да,
вот тут еще надо, конечно, писать обновление time up. Вот, если мы встретили ребро дерева,
то time up от V это минимум из time up от V и time up от U. Теперь все нормально. То есть time up
обновляем здесь, когда видим обратное ребро, и time up обновляем здесь, да, когда видим ребро
дерева. Все, ну а дальше пользуемся критерием. То есть либо этим, либо если это корень,
то спрашиваем про числа детей уже в самом конце. Articulation point, точка сочленения.
Ну вот. Так, на этом с точками сочленения все. Теперь перейдем к реберному аналогу.
Точек сочленения – это мосты. Ну что такое мосты? То есть мосты – это то же самое,
что точка сочленения, но только для ребер. То есть мост – это ребро в неориентированном графе,
такое что, давайте так не такое что, а удаление которого приводит к увеличению компонент связности.
Например, вот такой граф. Вот это ребро – это мост. Понятно, что если мы удалим это ребро, то у нас
граф развалится на две компоненты. При этом вот это, вот это и вот это ребро не являются мостами.
Удаление любого из этих трех ребер не приводит к развалу графа. Отдельно стоящее ребро тоже
является мостом и так далее. Ну и хорошая новость состоит в том, что для мостов критерии абсолютно такое же.
В общем, поиск мостов аналогичен поиску точек сочленения за исключением двух вещей.
Значит, первый. Нет особого случая корня. Ну понятно, мост по себе не может являться корнем,
поэтому про корень тут в принципе можно не говорить, то есть отдельно рассматривать
случай корня не нужно. Ну и второй момент. Нестрогое неравенство нужно заменить на строгое.
То есть вот здесь. Вот это неравенство просто заменяем не строгое на строгое. И все начинает
работать. Ну то есть УВ мост, У предок, В сын. Если таймин от У строго меньше,
чем таймап от В. Доказательство проводить не буду, потому что оно абсолютно аналогично
предыдущему. Единственное отличие, почему здесь возникает строгое неравенство. Ну смотрите,
вот идейно. Вот у меня была вершина У, у нее был сын В. Вот раньше, смотрите, раньше, когда у меня,
да, и тут какое-то дерево растет. Вот раньше, когда у меня были ребра, которые вели В, меня это устраивало.
То есть если из под дерева В, то есть точнее из вершины В, я не мог добраться в предков,
но при этом мог добраться на вершину У, вот на эту высоту. Меня это устраивало. Почему? Потому что
если я удалю вершину У, то у меня вместе с ней удалятся все вот эти ребра. Соответственно,
компонента отвалится. Поэтому у меня был неравенство не строгое. Мне можно было подниматься в У,
нельзя было в предков. А в случае мостов не работает. Я хочу проверить, является ли УВ мостом.
Но вот если помимо этого ребра у меня есть еще какие-то ребра, которые ведут в У, вот это ребро
перестает быть мостом. Потому что я его удалю, и при этом вот эта вершина остается связанной
со всем остальным под графом. Поэтому я заменяю неравенство на строгое. То есть вот такие вот
ребра мне запрещены. То есть если у меня все ребра ведут из этой компоненты в эту же компоненту,
то все плохо. Потому что существует только одно ребро УВ, которое связывает граф повыше с под
деревом В. Тут все абсолютно то же самое, только вот эта штука не нужна, потому что проверяется
случай корня. Ну и вот тут. Тут У. Тут мы, к сожалению, поменяли. Давайте тут поменяем. Тут будет У. Тут У, тут В.
Ну и так далее. Вот.
Ну теперь У. Еще раз вопрос можно? Нет, это все же стоит под ИФОМ.
Нет, таймап мы обновляем после DFS-визит. Ну то есть идея какая? Мы запустили DFS-визит от вершины В.
Ну теперь уже от вершины В. Вот. И таймап для В уже посчитан. Соответственно вот тут мы спокойно
можем его использовать. Вот. Так, ну с мостами то же самое, только теперь вместо У из точки сочинения
мы пишем. Ребро ВУ является мостом. Вот и все. Вот этот случай убираем. И вот тут проверку на корень
тоже убираем. В остальном все то же самое. Да, ну и знак меняем с нестрогого на строгое.
Ну и последнее, что хотелось бы сказать про мосты, это доказать одну интересную теорему,
а именно теорему Робинса. Звучит она следующим образом. Связанный граф G сильно ориентируем,
тогда и только тогда, связанном графе G нет мостов. Что значит граф сильно ориентируем? Ну смотрите,
вот у меня есть неориентированный граф. Граф буду называть сильно ориентированным, если я могу ввести
ориентацию на ребрах так, что у меня сохранится свойство сильной связности. Да, ну то есть если
у меня дан неориентированный граф, и он связан, что это означает? Это означает, что из любой вершины
я могу добраться до любой другой. Вот. А сильная ориентированность говорит следующее, что ну давайте
я просто нарисую как-нибудь стрелочки на ребрах. И вот если у меня получится нарисовать стрелочки так,
что у меня сохранится свойство сильной связности, то есть из любой вершины я по-прежнему смогу
добраться до любой другой, то я буду говорить, что у меня граф сильно ориентируем. Окей? Да, что если
можно так сделать, то граф сильно ориентируем. Так вот оказывается, что так можно сделать в том и
только в том случае, если у меня в графе нет мостов. Если хотя бы один мост есть, то все. Беда.
Давайте докажем. Ну, в одну сторону. Значит пусть у меня граф сильно ориентирован,
при этом есть мост. В изначальном графе был мост. Ну, давайте его рассмотрим. Значит, как выглядит
любой мост? Значит, есть ребро, которое связывает какие-то две компоненты связности. Так, ну по
условию, точнее вот по предположению, у меня граф сильно ориентирован. То есть я могу вести ориентацию
на ребрах. Соответственно, на этом мосте я тоже как-то веду ориентацию. То есть, ну допустим, без ограничения
общности. Без ограничений общности будем считать, что сильная ориентация заносится так, что у меня
ребро идет от вершины У к вершине В. Так, и что тогда получается? Да. Но из этого следует, что из В нельзя
попасть в У. Пришли противоречию. То есть, грубо говоря, мост это как раз те ребра, которые ориентировать
нельзя. Если вы их ориентируете, то все, обратный путь вам будет закрыт. Так, ну и обратно. Обратно
докажем конструктивно. То есть прямо предъявим сейчас ориентацию графа, если в графе нет мостов.
Смотрите, давайте просто возьмем и запустим DFS на этом графе. И будем ориентировать ребра следующим
образом. Да, и ориентируем ребра по направлениям ребер дерева. То есть, от предков потомкам.
И направлением ребер обратных ребр. Ровно то, что мы делали раньше. Раньше мы делали вот здесь.
Помните, мы запускали обход DFS и говорили, что ребра дерева будут ориентированы так, что ребра
дерева ведут от предков потомкам. Если у меня есть обратное ребро, то ориентируем его по направлению
потомка к предку. Ну, собственно, как раз по направлению обхода. По направлению обнаружения этих самых
ребер. То есть, естественная ориентация довольно. Вот. Ну и, собственно, утверждается, что вот эта
ориентация, как раз таки, будет сильной ориентацией графа. Почему? Потому что следующая вещь. Чтобы
показать сильную связность, достаточно доказать, что корень дерева DFS достижим из
любой вершины. Почему это так? Ну, смотрите, я как-то ориентировал граф и хочу доказать, что он сильно
связан. Так вот, я утверждаю, что он будет сильно связан тогда и только тогда, когда корень достижим
из любой вершины. Ну, почему это так? Потому что, если я из любой вершины могу добраться до корня,
то это значит, что из любой вершины я могу добраться до корня, а от корня могу добраться до любой другой
вершины. Потому что это дерево. Ну вот, здесь есть мосты, но давайте представим себе, что вы из любой
вершины можете добраться до корня. Ну, что это тогда означает? Вот, допустим, вам хочется построить путь
из тройки в ноль. Как это сделать? Ну, вы сначала идете в корень, а потом из корни спускаетесь,
куда вам надо. Понятно? Точно? Всем понятно? Поэтому самая главная проблема — это из любой вершины
добраться до корня. Если вы поднялись в корень, то все, до любой другой вершины вы спокойно дойдете.
Потому что ребра так. Потому что ребра идут от предков к потомкам, а корень — это предок вообще всех
вершин. Так, ну а почему это так? Вот, отлично, да. Это так, потому что в графе нет мостов. А из этого что
следует? Что для любой пары УВ, где У — это предок, В — это сын, time up от В больше либо равен,
чем time in от У. То есть вот у вас есть ребро УВ. Почему строго? Нет, все нормально. Нет? Сейчас,
или наоборот должно быть? Не, наоборот же должно быть. Вот так. То есть из вершины В я могу подняться в У или выше.
Ну, то есть вот. Из вершины В я могу подняться в У или выше. Ну, это отрицание вот этого условия.
То есть там time in больше либо равно, чем time up от В. Вот. То есть что это значит? Вот в какой бы
вы в вершине не находились, вы всегда по обратным ребрам сможете попасть хотя бы сюда. А если
смогли попасть сюда, то что это значит? Мы применяем ту же самую операцию. Раз вы оказались здесь, то
отсюда вы можете подняться куда-нибудь повыше. Ну и так далее. Понятно? То есть из любой вершины вы
можете подняться чуть выше. Ну а бесконечно выше-выше вы подниматься не можете. Рано или поздно вы
пойдете в корень? Ну, все. То есть двигаясь по ребрам дерева можно... ребрам дерева и обратным
ребрам и обратным можно попасть в предка. Ну а из этого следует можно добраться до корня.
Ну все. Давайте еще раз проговорю, что мы сделали, как мы доказали. Нам нужно доказать, что если у нас
в графе нет мостов, то мы можем из любой вершины добраться... видя некоторую ориентацию на графе,
мы можем добраться из любой вершины до любой другой. Я предлагаю ориентировать граф согласно
ребрам дерева и обратным ребрам. Соответственно, у меня
сохранится свойство сильной связности в том или только в том случае, если из любой вершины
я могу добраться до корня. Из любой вершины я добираюсь до корня. А потом из корня я добираюсь
до любой другой вершины. Почему это верно? Почему из любой вершины я могу добраться до
корня? Ну, ровно потому, что у меня нет мостов в графе. Нет просто мостов. А если у меня в графе
нет мостов, то это значит, что для любой пары предок-сын выполнено вот это неравенство.
А что говорит это неравенство? Это неравенство говорит, что из сына я могу подняться своего
предка или даже еще выше. Но если из любой вершины я могу подняться в предка или еще выше, то двигаясь
вот так вот по предкам, я могу добраться до корня. Ну все, окей? Все, разбрались? Ну вот,
такой интересный факт. Так, давайте перейдем. Так, на этом надо сделать такую паузу и сказать,
что мы закончили просмотров материал второго модуля. Первый модуль был посвящен деревьям,
второй обходом на графах. Сейчас мы перейдем к третьему модуле, который будет посвящен,
ну так условно назовем, полезной информации на ребрах. То есть раньше мы на ребрах ничего такого
не писали, а сейчас у нас на ребрах будет какая-то информация, какие-то числа и так далее. И будем
пытаться как-то обрабатывать все это. Но, видимо, после перерыва. Так, я привел в порядок тот алгоритм,
который мы писали. Теперь кажется, что все консистентно и с теоремой, которую мы доказывали,
и с другими обозначениями. В общем, полный псевдокод выглядит так. Давайте еще раз. Изначально
таймин и таймап, они равны для вершины У. Мы просто там присваиваем не текущий, а увеличиваем счетчик
и присваиваем это значение. Дальше проверяем, является ли наша вершина корнем. То есть она корень,
если у нее не было предка. Так, можно потише, пожалуйста. То есть она корень, если у нее не было
предка. Ну и число детей в данный момент у нее ноль. Дальше, собственно, в цикле проходимся по всем
соседям. Вот если встретили обратное ребро, то мы обновляем таймап. Ну, мин равно таймин от В. Ну,
мин равно, в смысле, равно минимум из текущего значения вот этого значения. Вот. Если это ребро
дерева, то увеличиваем число детей, запускаем default visit, обновляем таймап. И с помощью критерия
теоремы проверяем, является ли вершина У точка сочинения. Вот. При этом этот критерий, да,
вот это вот условие, оно годится только, если вершина У не является корнем. Вот. Соответственно,
как только этот цикл заканчивается, мы проверяем второй критерий. Если вершина У изначально была
корнем, да, вот из root, и у нее больше одного ребенка мы обнаружили в процессе обхода в глубину,
то значит У тоже корень, ой, тоже точка сочинения из АП. Окей. Вот. Так. А тема,
которую мы переходим, называется потоки. Потоки в графах. Это вообще о чем? Вот. Представьте себе,
что у вас есть какая-то сеть труб. То есть вам дан некоторый ориентированный граф,
вот задан некоторый ориентированный граф, и задано две выделенные вершины. Source,
то есть источник, и sync, stock. Исток, исток. Значит, что вам известно? Известно, что источник
продуцирует, ну что может течь по трубам? Ну, в общем, что-то он продуцирует, в общем,
какую-то жидкость, ну или какое-то количество единиц товара. Вот. При этом там потенциально
бесконечно много. И есть, собственно, stock или target, который может этот товар в себя принять,
тоже сколь угодно большое количество. Но при этом есть ограничение. И ограничение заключается в том,
что пропускная способность труб или дорог, она ограничена. Ну скажем, здесь вы можете максимум
пустить пять единиц, здесь три единицы, здесь две, здесь четыре, здесь три, два, шесть, один,
три, десять. То есть по каждому ребру можешь протекать ограниченное что? Одно ребро осталось,
вот это пусть тоже три будет. Вот. То есть пропускная способность каждой трубы ограничена.
Ну и соответственно задача в чем заключается? Ну задача заключается в том, чтобы каким-то образом,
ну то есть решить задачу логистики, каким-то образом направить товары по дорогам или жидкость
по трубам так, чтобы протекало максимальное количество того, что вы там пускаете из источника в
синг, т.е. в таргет. Ну то есть давайте формально попробуем описать. Формально что у нас есть?
Формально у нас есть граф, который будем называть транспортной сетью. Вот такая что у нее на парах
вершин задана некоторая весовая функция, точнее capacity. В смысле пропускная способность. То есть capacity
это функция на парах вершин в, ну не варь, давайте от нуля до плюс бесконечности. Вот. То есть сув
максимальное число единиц товара из ув. При этом если ув принадлежит е, тогда это только тогда,
когда сув больше нуля. Вот. То есть между какими-то парами, парами этих, не знаю, городов, узлов,
у нас ничего протекать не может. Например, между вот этим, вот этой парой ничего протекать не
может. Условно можно считать, что между ними пропускная способность равна нулю. Вот. А между
этими вершинами ребро есть. Соответственно на нем задана некоторая положительная пропускная способность.
Вот. Ну и сдача заключается в чем? Значит, пусть f из тоже пар v в r поток,
такое что для любой пары uv, uv меньше и равен чем cuv. Ну, давайте скажем заодно, что больше и
равен чем 0. Вот. То есть нам необходимо пустить какой-то единиц товара f по каждому ребру так,
чтобы вот эти все условия удовлетворялись. Ну, давайте здесь какой-нибудь попробуем пустить.
Допустим, здесь пустим. Сколько можно тут пустить? Давайте пустим 4. Здесь пустим 2. Тогда здесь
пройдет тоже 2. Соответственно отсюда можем пустить. Давайте пустим 3 отсюда и 1 отсюда. Да? То есть видно,
что все пока. Где? Сюда? Почему? Все нормально? Да, входит 6. Да, давайте тут 4, тут 2. Вот. Нормально?
Дальше. Нет. Да, если мы сюда пустили 4, давайте отсюда пойдет 2. А отсюда пойдет оставшееся 2.
Значит, здесь пошло 2. Соответственно давайте 1 пустим сюда, 1 пустим сюда. Да, и тогда сюда
дополнительно еще 1. 3. Ну, тогда отсюда пойдет 2, отсюда пойдет 1. Ну, кажется, все нормально, да? Вот.
То есть по этому ребру пустили 4 единицы, хотя пропускная способность 5. Здесь пустили 2 единицы,
хотя пропускная способность 3. Так, здесь две единицы. Так, тут 6, 6. Так, тут 5, 5. Ну, кажется,
все остальное нормально. То есть черным я обозначил поток, красным пропускные способности. Так,
ну и какой суммарный поток у меня течет из источника из стока в сток? 6. Вот эту штуку
будем назвать величной потока. Можно пустить больше? Да, ну как минимум можно увеличить на 1.
Да? Ну, как минимум. Ну вот, если отсюда пущу 5 единиц, здесь тогда я могу увеличить на 1, здесь
тоже могу увеличить на 1, здесь могу увеличить на 1. Соответственно, поток, который был найден, не
не максимально. Соответственно, мы сейчас займемся вопросом, а как искать
максимальный поток вот в таких сетях. Да, нужно еще, наверное, написать дополнительные
условия. Вот как вы правильно отметили, у меня ни в одном вот во внутренних вершинах
вот эта вот самая жидкость или этот самый товар накапливаться не может. То есть
складов вот в этих вершинах у меня нет. То есть вот сколько в вершину пришло единиц,
столько же из нее должно выйти. За исключением стартовые и конечные вершины, естественно.
То есть во внутренних вершинах у меня ничего не накапливается. Ну такое первое
правило Киргофа. То есть сумма для любой вершины v не равный s и t. У меня сумма
исходящего потока vpx должна совпадать с суммой входящего потока.
Ну давайте попробуем решить как-нибудь эту задачу.
Значит задача решается следующим образом. Ну точнее план такой. Давайте сразу построить
поток сложно. То есть довольно сложно сразу там взять и найти максимальный поток. Как
-то назначить веса в ребрах и так далее. Давайте будем строить потихонечку. То есть по ручейку.
То есть пустим какой-нибудь ручеек из источника в сток. Зафиксируем. Потом во
старшейся графе тоже пустим какой-нибудь ручеек. Ну и так далее. Например. Пусть у меня тут s, тут t.
Пусть у меня там какой-то вот такой граф. Пропускные способности следующие. Везде по единице.
Что я собираюсь делать? Давайте я просто попробую найти какой-нибудь путь из s в t. Ну
например вот такой. Допустим который идет вот по верхней дуге. То есть сколько я тут могу пустить
единицы вдоль этого пути? Ну по единице. То есть тут могу пустить единицу, тут могу пустить единицу и тут
могу пустить единицу. Отлично. То есть пустил и соответственно насытил какие-то ребра. Это был первый
шаг. На следующем шаге снова. Давайте попробуем найти какой-нибудь путь из s в t, который проходит
по еще не насыщенным ребрам. То есть по ребрам, которые я еще могу что-то пустить. Ну что, давайте
пустим по нижней дуге. 1, 1, 1. Ну и казалось бы все. Я таким образом, то есть постепенно увеличивая
мой поток, я найду максимальный. То есть план такой пока. То есть пускать там маленькие ручейки,
до тех пор, пока я могу насытить мою сеть. Как только я не смогу найти путь из s в t,
но в данном случае я не могу найти путь из s в t, потому что у меня вот эти все ребра, они
сблокированы. Все, как только я не могу найти путь, я на этом останавливаюсь. Все ли понимают,
что этот путь ведет в никуда? Пока. Смотрите, да, то есть это я так хорошо просто подобрал пути,
что они меня так хорошо себя ведут. Но на самом деле может возникнуть немного другая ситуация.
Что если я взял... Ну снова, тут пропускные способности везде по единице. То есть тут единица,
тут единица. Единица, единица. Что если я мой первый поток пустил как-то не очень? Ну скажем,
нашел путь вот такой. Здесь пустил единицу, здесь пустил единицу, здесь пустил единицу. То есть пошел
вот так, пустил единицу здесь, пустил единицу здесь. Вот. То есть это ручеек, да, я его пустил,
нашел путь из s в t, все нормально. Так, что я делаю на втором шаге? Плачу, да, ну то есть все. То есть я
прохожу сюда, а отсюда уже пути никуда не могу, то есть никакой путь другой найти не могу. Это
ребро заблокировано, поэтому я могу пройти, но уже из этой вершины я никуда пройти не могу,
потому что это ребро заблокировано. Все, беда. То есть если я ищу жадным способом мой поток,
вот в такой постановке, то все плохо. В чем здесь проблема? На самом деле проблема не в методе,
метод нормальный. То есть с помощью такого метода мы сейчас построим оптимальные алгоритмы.
Проблема заключается в том, что если мы в какой-то момент построили неправильный ручеек,
неправильный поток, то у нас нет возможности его исправить. То есть нам бы хотелось сделать
следующую вещь, что если мы видим, что вот это вот ребро мы выбрали как-то неоптимально, нам бы
хотелось в процессе добавления новых ручейков его как-то исправлять. Ну в частном, например,
сказать, что пустили ручеек здесь, пустили ручеек здесь в обратном направлении, то есть
компенсировали вот этот поток, а потом пустили ручеек сюда. Тогда мы пришли ровно к вот этой
картине. То есть если мы другой путь пустили вот так, то мы бы сказали, что путь идет сюда,
потом путь идет сюда, который компенсирует старый поток здесь, и путь идет сюда. И тогда вдоль
каждого ребра мы бы построили нормальный поток. Понятно, да? То есть хотелось бы как-то в процессе
исправлять наши неправильные пути, которые мы нашли до этого. Так вот, чтобы этого достичь,
мне придется немного поменять определение, которое я вел до этого, ну точнее, как поменять,
наконец-то ввести эти определения, потому что это все была болтовня. Сейчас давайте попробуем как-то
исправить это все. На самом деле, тут есть еще одна проблема. Мне очень не нравится, что у меня
определение потока, точнее, определение величины потока, оно какое-то, точнее, вот это вот условие,
что у меня ни в каком узле не накапливается никакая жижа, оно у меня, грубо говоря, не симметрично.
То есть я должен отдельно рассматривать, отдельно рассматривать ребра, которые исходят из вершины,
и отдельно рассматривать ребра, которые входят в вершину. Давайте попробуем это исправить с
помощью симметризации потока. Давайте наконец введем определение. Каким определением потока
буду пользоваться я? Значит, определение будет следующее. f поток в транспортной сети g,
если f это функция топорок вершин в r, такая что она удовлетворяет следующим условиям. Первое условие
антисимметричность f от uv равно минус f в у для любой пары в у. То есть сколько единиц у меня потока
течет в направлении от u к v, то есть что можно сказать, что если у меня из uv течет поток равный
единице, то я могу сказать, что из vv у меня течет поток равный минус единицы. Грубо говоря, как ток,
положительные частицы текут в одну сторону, отрицательные в другую. Второе. Естественно,
я хочу, чтобы мне удовлетворялось вот это соотношение. То есть я не хочу, чтобы у меня
поток тек больше, чем у меня реально вмещает ребро. Что? Нет, вот так. Мне так устраивает.
Так, ну и третье. Для любой вершины v неравный s и t, сумма fvx по всем x принижающим v равно 0. Вот.
Теперь у меня формула вот эта стала симметричной. Почему? Вот смотрите, раньше у меня что было? Раньше
у меня была вершина, у нее входило, скажем, один-два и выходило два-один. Да, вот раньше что отвечало
условию, что у меня ни в одной вершине поток не накапливается. Ну, я отдельно считал исходящие
ребра и отдельно считал входящие ребра. А теперь что у меня происходит? У меня помимо входящих
ребер теперь есть симметричное ему ребро, которое течет в обратную сторону. Ну вот, антисимметричность.
То есть это значит, что в обратном направлении течет минус одна единица потока и здесь минус две единицы
потока. Ну и теперь, если я просуммирую по всем исходящим ребрам, то у меня как раз таки будет
сохраняться баланс. То есть 2 плюс 1 равно минус 1, минус 2. Понятно? То есть теперь я входящие
ребра учитываю как исходящие. Все нормально. Вот, ну еще одно определение величиной исходящего
потока. Назовем модуль f+, который равен сумме всех потоков, которые исходят из вершины s.
Все, что производит поток вершины s, это величина исходящего потока. Соответственно,
величиной входящего потока назовем f с минусом, который будет равен сумме по всем потокам,
которые входят в t. Так, так, так, так, так. Что еще раз? Нет, нет, конечно. Вы что?
Нет, какой модуль? Вы что? Ну зачем модуль? Что вы придумываете? Ладно, давайте вот тут.
Давайте с определением разберемся. Хорошо. Давайте вот тут. Что нам нужно? Значит, помимо прямых
ребер мы теперь заводим и обратные ребра. Вот так, вот так, вот так. Какие у них пропускные
способности? А, пока не понятно. У них на самом деле нет. У них пропускные способности равно нулю.
Потому что вам разрешено опускать поток только в направлении от s к вот этой вершине. То есть
от s к направлении от s положительного потока течь не может. Смотрите, мне разрешено
опускать поток от этой вершины? Вот этой вершины. В обратном направлении. Мне опускать положительный
поток запрещено. Вот. И соответственно, так как я поток симметризовал, у меня в обратном направлении
тут течет минус один, тут течет минус один, тут течет минус один, ну и так далее. Везде, где ноль,
у меня течет поток минус один. Минус один меньше равен, чем ноль. Поэтому все ок. То есть если у меня
ребро идет в правильном направлении, то там у меня пропускная способность равна единице.ュ Но
при этом есть еще куча остальных ребер, у которых пропускная способность равна нулю. Да, то есть
ребра graph считается только те, у которых пропускная способность равна единице. При этом между всеми
остальными парами вершин тоже есть пропускная способность, но при этом она равна нулю. Ну и при этом,
как я сказал, у меня поток антисимметричен. То есть если у меня в этом направлении поток течет равный
то в обратном направлении счет поток равный минус единице.
Но при этом в обратном направлении, так как поток равен минус единице,
а пропускная способность ноль, то второе условие тоже выполняется.
Минус один меньше, равно нуля. Все нормально.
Ну или вот это еще можно переписать как
минус сумма по всем y, клянусь за чем v, в силу антисимметричности, свойства 1.
Ну и утверждение стоит в том, что на самом деле не важно,
какой поток, какую величину потока вы считаете, они будут равны.
Более-менее очевидно, давайте докажем.
Давайте просто возьмем сумму по всем x при назначении v, сумму по всем y при назначении v, f от x и y.
Так, только на самом деле это надо убрать.
Вот это верно сейчас для любой вершины.
Или нет?
Нет, это для любой вершины не равный s и t, конечно.
Значит, рассмотрим такую сумму. Что мы про нее можем сказать?
Во-первых, давайте выделим отдельно часть, которая относится к s.
Здесь будет сумма по y при нежащем v, f от sy.
И отдельно выделим часть, которая относится к t.
Сумма по всем y при нежащем v, f от ty.
Но и останется на что?
Сумма по всем x неравным s и t, сумма по всем y при нежащем v, f от x и y.
Что можно сказать про эту сумму?
Что можно сказать про эту сумму?
Почему?
Да, по пункту 3 вот эта сумма, мы ее можем слопнуть в ноль.
Точнее, вот эта штука равна нулю.
Ну потому что для любого x неравного s и t вот эта сумма ноль.
Соответственно, эта штука будет равна модуле f плюс,
минус модуль f минус.
Минус модуль f минус.
Чем у нас там только x неравного s?
Где?
Ну, последняя сумма.
Так, вот эта?
Разве нам еще вот эту штуку x не равен t?
Ну вот, не равен s, не равен t.
То есть я извлек часть, которая относится к s, и часть, которая относится к t.
Так, а что у нас стоит здесь, смотрите?
Что у нас стоит здесь?
Почему вот эта сумма на самом деле равна нулю?
А да?
Смотрите, эта сумма по всевозможным парам x и y.
Но при этом для любого uv у меня есть f и t.
А у меня есть f и t.
А у меня есть f и t.
А у меня есть f и t.
А у меня есть f и t.
А у меня есть f и t.
Но при этом для любого uv у меня есть f от vu, который с обратным знаком.
Ну короче, у меня вся эта сумма по всем парам раскладывается на пары x, y, y, x.
Vu и uv, которые взаимно уничтожают друг друга.
То есть на самом деле вся эта сумма изначально была равна нулю.
В силу антисимметричности 1.
Согласны?
То есть в этой сумме расположены всевозможные пары.
А всевозможные пары раскладываются на сумму f от x, y.
У меня в этой сумме есть пары f от x, y плюс f от y, x.
Но так как f от y, x равен минус f от x, y, это равно нулю.
Поэтому и вся сумма целиком равна нулю.
Ну и что я в итоге получил? Что у меня исходящий поток минус входящий поток равен нулю.
Ну, следовательно, они равны.
Понятно?
Это просто как бы некоторое утверждение о корректности,
что неважно, как вы считаете, что величина потока, которая исходит из тока, равна величине потока, который входит в поток.
То есть неважно, как вы определяете величину потока.
Это два эквалентных определения.
Вот. Окей.
Давайте теперь вернемся к нашему примеру.
Давайте как-нибудь его покрупнее нарисуем, чтобы прям все было видно, все было понятно.
И попробуем понять, чем симметризация потока нам помогла.
Так, нарисуем пропускные способности.
Здесь 1, здесь 0, здесь 1, здесь 0, здесь 1, 0, 1, 0, 1, 0, 1, 0, 1, 0.
Так, ну и допустим, мы пустили плохой поток, который шел и прошел по диагонали.
Что у нас получилось?
Что здесь величина потока равна 1, здесь 1, здесь 1.
И что еще?
Ну и в обратном направлении у меня протекли минус 1.
Тут минус 1, минус 1, минус 1, минус 1, минус 1.
Ну, нулевые потоки я не буду писать.
Во всех остальных местах у меня поток 0.
Понятно, что все три условия для потока выполняются.
Да, вот вон те.
Так, ну тут понятно, S.
Теперь давайте попробуем нод.
Собственно, план снова прежний.
Пускаем маленькие потоки до тех пор, пока мы можем найти путь.
Как только пути не будет положительного, мы прекращаем работу.
Так, давайте попробуем в таком графе теперь пустить какой-нибудь положительный путь.
Ну, смотрите.
Значит тут, каким есть исходящее ребро? Есть исходящее ребро вот это.
Но по нему я ничего пустить не могу.
Если я пущу какой-то положительный поток вдоль него, то у меня будет тут больше единицы,
ну соответственно больше пропускной способности этого ребра.
Все плохо.
Давайте я попробую здесь пустить поток равный единице.
Пускай здесь поток равный единице, здесь минус единица.
Дальше. В этом, в эту вершину я снова попасть не могу.
Один-один.
А смотрите теперь вот здесь. Какая история?
У меня есть ребро, которое ведет из этой вершины в эту вершину.
В изначальном графе вот этого ребра не было.
То есть изначально у него была пропускная способность ноль.
Но теперь смотрите, если я вдоль этого ребра теперь пущу поток равный единице,
у меня все будет нормально.
Минус один плюс один ноль.
1 – ноль. Ноль меньше равна нуля и так далее.
То есть, симметризовав поток, я получил возможность
исправлять плохие потоки. Понятно?
То есть, по этому ребру я теперь могу пустить поток
равный единице. Понятно? Вот.
Давайте тут напишу плюс один.
Плюс один минус один – ноль. Все нормально.
Так, а здесь, соответственно, если я сюда добавил поток
равный единице, то отсюда я должен его вычесть.
Соответственно, тут еще, давайте, зачеркнули, напишу ноль.
Все, я пустил поток дополнительно в этом направлении, соответственно,
увеличил поток в этом направлении на единицу, а в обратном направлении
уменьшил на единицу. Окей?
Ну, теперь я попал сюда. Ну и что я вижу?
Есть свободное ребро. Ну, естественно, я его использую.
Один.
А нас подождет только ребра, которые посещены в вершине?
Нет, конечно. Мы рассматриваем только ребра,
по которым можно пустить поток.
Нет, посещенные вершины тут вообще ни при чем.
Так, давайте теперь снова попробуем.
Попробуем пустить поток из s в t.
Это ребро занято, это ребро занято.
Ну все, приехали.
При этом какой у меня суммарный поток течет из s?
Два. И кажется, это максимальный поток.
Все, всего лишь симметризовав поток, мы научились исправлять
плохие потоки и не попали вот в ту неприятную ситуацию.
Понятно?
Но осталось непонятно, почему это работает всегда.
Вроде как выглядит разумно, но кажется, что я где-то обманываю вас.
Давайте попробуем доказать
корректность всего этого метода.
А доказываем мы с помощью
одной интересной леммы,
которая называется арифметика потоков.
Арифметика потоков.
Значит, история такая.
Так, прежде чем арифметику потоков,
давайте в качестве одного из пунктов леммы это сделаем.
Оказывается, потоки можно складывать и вычитать.
Вот что мы сделали здесь.
Мы как раз-таки брали и складывали потоки.
Вот здесь мы взяли и сложили поток, взяли и сложили поток.
И так далее.
Потоки можно складывать и вычитать.
Давайте здесь ведем определение.
Прямо в условии леммы.
g от f это остаточная...
Пусть f,
поток в g.
g, f,
остаточная сеть.
Сеть,
если
cf от x, y
равно c от x, y
минус f
от x, y
любой пары x, y
принадлежащие v.
График g, f.
График g, f.
То есть g, f это тот же самый граф, что и g,
но только у него остаточные пропускные способности вычисляются вот таким образом.
Точнее, это как раз есть остаточная пропускная способность.
Остаточная
пропускная
способность.
Что?
Интересно.
Понятно?
То есть я по графу уже опустил какой-то поток,
а потом пересчитал пропускные способности.
Какая остаточная сеть? Давайте построим остаточную сеть
для этого графа.
Давайте я буду
зеленым цветом рисовать.
Какая остаточная пропускная способность здесь?
0-1, 1.
То есть в этом направлении я могу пустить 0 единицы потока,
в этом направлении я могу пустить 1 единицу потока.
Здесь 0-1, 1, 1-1, 0,
0-1, 1, 1-1, 0,
здесь 1-0, 1,
0-0, 0,
1, 0, 0, 1, 0, 1.
1.
Зеленым цветом я показал остаточные пропускные способности.
То есть это пропускные способности в новом графе.
GF.
Ну вот, по определению, вот здесь.
Бравие пропускные способности в исходном графе,
и вычитали, сколько потока в данный момент там течет.
То есть красное число минус черное число.
Так, арифметика потоков.
Первое утверждение заключается в следующем.
Пусть H
поток в GF.
Пусть я нашел поток в остаточной сети GF.
Тогда H плюс F.
Это поток в исходном графе G.
Понятно?
То есть жил-был у меня граф G.
Я пустил по нему поток F.
Получил граф, точнее, остаточную сеть GF.
И вот если я в этой остаточной сети пущу дополнительный поток,
то суммарный поток у меня будет и потоком в исходном графе G.
Понятно?
Грубо говоря, я легитимизировал все, что я делал до этого.
Складывал потоки.
Давайте сразу докажем.
Что мне нужно проверить?
Чтобы показать, что это поток, нужно проверить, что это действительно будет потоком.
Согласны?
Первое свойство. Антисимметричность.
H от XY плюс F от XY
равно минус H от YX
минус F от YX.
Согласны?
Так как H и F это потоки, то они сами по себе антисимметричны.
Соответственно, сумма тоже антисимметрична.
Второй момент.
Ну смотрите.
Так как H
поток в GF,
то что из этого следует?
Согласны?
Ну H от XY – поток в графе G.
А в графе GF у меня пропускная способность вот такая.
Так, ну а что из этого следует?
Из этого следует, что F плюс H меньше или меньше, чем C.
Ну просто перенес F в левую часть.
Все. Соответственно, F плюс H
удовлетворяет условиям пропускных способностей
в исходном графе.
Третий пункт.
Сумма... там бла-бла, да?
То есть, если V не равен S и T,
то сумма по всем х F в X
равно нулю.
Ну и с другой стороны, сумма по всем х H
в X равна нулю.
Так как и F, и H – это потоки.
Ну и с другой стороны, сумма по всем х H
в X равна нулю.
Так как и F, и H – это потоки.
Ну из этого следует, что
сумма по всем х F
от VX плюс H от VX
равно нулю. Все.
H плюс F удовлетворяет всем трем свойствам.
Следует, H плюс F – это поток.
Все, нигде не обманул.
Ну смотрите.
Ну и второе – разность потоков.
Пусть F1
поток в графе G,
в исходном графе G.
И F2 – тоже поток в исходном графе G.
Поток в G.
Тогда F2
минус F1
это будет поток.
Как вы думаете, в каком графе?
Нет.
Ну я спрашиваю, что мне написать.
В G, F1?
Ну смотрите, если я возьму граф G, F1,
прибавлю к нему поток F2 минус F1,
то я получу поток F2.
Соответственно, получу поток в G.
Понятно. Ну доказывается аналогично.
Аналогично.
Мы просто по определению
проверяем, что F2 минус F1 – это поток.
Тоже по трем пунктам.
Мы успели не все, давайте хотя бы
без алгоритма вас не оставлю.
В следующий раз рассмотрим другие алгоритмы.
На самом деле мы алгоритм рассмотрели.
Я так руками помахал. Давайте я формально опишу.
Алгоритм будет называться
алгоритм Форда Фалкерсона.
Очень простой.
Что мы делаем?
Шаг 0. Стартуем с потока нулевого.
Сначала у нас ничего в графе не течет.
Дальше.
Строим граф GF.
GF с пропускными способностями равными
C минус F.
Второй.
С помощью
обхода в глубину
ищем путь
положительный.
Положительный, который течет
по ребрам с положительной пропускной способностью.
Ищем путь
из S в T.
И пускаем по нему поток
Дельт Ф
равный минимуму
ЦФ
от ЕИ,
где ЕИ это путь
от S до T.
Ну короче, просто запускаем DFS
и ищем путь из S в T.
Среди всех ребр, которые мы посетили,
мы нашли реброс наименьшей пропускной способностью.
Ну раз мы нашли реброс наименьшей пропускной способностью,
значит, по всем ребрам мы можем пустить как раз таки вот этот Дельт Ф.
Проталкиваем этот поток.
Все. Ну и третий пункт, последний.
Повторяем.
Повторяем. Один, два.
Ну, до тех пор,
пока в GF
есть путь
из S в T.
Ну, ровно то, что мы делали до этого.
Пускали по маленькому потоку, по маленькому ручейку из S в T.
И в тот момент, когда мы поняли, что у нас теперь нет пути из S в T
по положительным ребрам, мы остановились.
Алгоритм очень простой. То есть, по сути, мы несколько раз применяем DFS
и все.
К сожалению, да, за сколько он работает.
Ну, DFS за сколько работает?
Ну, за E, условно.
Ну, будем считать, что изолированных вершин у нас нет, поэтому все ок.
Потому что они бесполезны в потоке.
То есть, DFS работает за E. А сколько раз все мы вызываем DFS?
Сколько?
Почему E?
F. Модуль F.
Ну, почему? Потому что если у нас все потоки, все простые способности целые,
то мы каждый раз пускаем минимум одну единицу потока.
То есть, представьте себе, что у нас суммарный поток максимальный,
который мы хотим найти, равен сотне.
И мы каждый раз ищем там по потоку, который равен единице.
То есть, пустили одну единицу потока, а потом еще одну.
И всего таких будет с той итерацией.
Поэтому E умножить на модуль F.
И в этом недостаток этого алгоритма, потому что этот факт
не дает сказать, что он полинамиальный.
И этот факт мы заранее не знаем.
Но тем не менее, если вам по каким-то причинам известно,
что поток не может быть очень большим, то алгоритм вот такой эффективный.
В следующий раз мы рассмотрим более разумные алгоритмы.
