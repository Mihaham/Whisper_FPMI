Давайте начнем, лекция 13. Мы сегодня закончим ДП, наконец-то. Не то, что мы много проходили, но закончим.
Ну, 13, потому что я писал семинар 12. А может и 12?
13.
И важно.
Двенадцатая?
Двенадцатая.
Двенадцатая плюс или минус один?
Типа, прошло 11-ое было.
Так, лекция 1х. Короче, какая-то лекция.
Нет, нет, мы живем в арабской системе ощущения, не в Римске.
Вот, собственно, сегодня у нас будут два сюжета, динамика подотреска и динамика по множеству.
И с динамиком мы заканчиваем, дальше геометрия будет до конца курса.
Окей, соответственно, поехали тогда первый сюжет.
Динамика подотреска.
И первое. Там, по сути, динамика подотреска сводится к тому, что там всего два типа есть.
И есть общий динамик. То есть DP от LR.
Ну, то есть, по слову, какая у вас есть какой-то массив или последовательность, вы там должны что-то на них посчитать.
Собственно, DP от LR это обычно ответ для ALT, AL plus 1, AVERT.
И следует кло подотреска.
Ну и, собственно, дальше вы будете как-то это вычислять.
И обычно это сводится к чему? К тому, что
в какой-то такой формуле пересчета, что DP от LR это какая-то функция от подотресков меньше.
Ну, чаще всего это что-то такое. То есть у вас был ваш массивчик так называемый.
Поставили L, поставили R.
Тогда динамика на LR вычисляется как будто вы берете на вот таком вот и на вот таком вот.
И что-то там считаете.
Ну, самое простое это какая-то формула включения и исключения.
И вы прибавляете это и это, и вы читаете еще меньше отрезочек.
Там, не знаю, например, посчитать число под последовательностью палендров.
Собственно, вот.
Это считается за счет того, что у вас для LR вы считаете сколько здесь, плюс сколько здесь, минус сколько здесь.
Примерно так.
Ну там обычно база задается что-нибудь типа
DP от EE, то есть отрезки длины 1, ну и иногда отрезки длины 2.
Ну и чаще всего универсальное равно 0, если L больше R.
Ну потому что все-таки отрезков справа налево у нас нет.
Ну что-нибудь такое.
Такая общая схема.
Базу задали, формулу пересчета задали, смысл задали.
Осталось узнать где ответ лежит.
У нас зависимость тоже как вы.
Если у вас ответ это вот это вот, то ответ на всю массиву лежит DP0 и M, например.
И порядок пересчета обычно здесь такой, что берут.
Серый порядок пересчета следующий, FOR.
L равный 2, L меньше N, плюс-плюс L, здесь дальше FOR, L равный 0, L меньше чем N минус L, плюс-плюс L.
Ну и здесь говорят, что R равно L плюс L.
Что-нибудь такое.
То есть у вас сначала перебор идет по длине под отрезки, а затем по левой границе.
То есть у вас сначала уничтожается для всех отрезков длины 3, потом длины 4, ну и так далее.
Ну можно по-другому считать, главное, чтобы у вас отрезки перебирались в нужном порядке.
То есть когда вы учитываете уже больший отрезок, у вас должны быть эти поменьше посчитаны.
В этом очень удобно всегда длину сначала увеличивать, потом уже там длинуть.
Вот, это первый тип задач.
И второй тип задач, он отличается лишь тем, что здесь вот будет другая формула пересчета.
R, ну обычно что-нибудь типа такого.
Давайте даже и так наверху напишем.
Ну давайте дам скорость.
Напишем нормально.
Db от L, M.
Db от M, Db от R.
Вот, то есть у вас здесь возникает необходимость разрезать ваш проотрезок на два, и вы считаете их на двух меньших.
Собственно, функция jet это какая-то функция, которая знает части и собирает вам ответы.
То есть функция слияния такая.
Ну да, минимум, максимум или сумма, в зависимости от того, чего вам надо найти.
Здесь вот как-то вот так вот.
Здесь можно было написать, конечно, f.
У нас все-таки m перебирается, поэтому с минимум симпатичнее выглядит.
Сейчас будут примеры, если что, по задачам.
Ну и, собственно, пример первый это
найти максимальную по длине
подпоследовательность полиндрома.
Ну, вот, про число полиндромов у вас просто в контесте есть.
Поэтому я не буду разбирать.
Я разберу кое-что очень похожее.
Ну, например,
что-то такое.
Ну, что-то типа, ну, префиг здесь понятный является к полиндрому.
Давайте чуть-чуть заменим.
Вот.
Тогда один, два, три, три, не получится собрать.
Вот два, три, три, два получается, например.
Я чуть не вижу, что больше было бы.
А, ну два, три, четыре, четыре, окей.
Если больше, то получится собрать.
Вот, это значит, есть два решения.
Первое решение вам на семинаре расскажут.
Второе сейчас я расскажу.
Вот.
Давайте введем DP от LR.
Это длина максимального подполиндрома
на AL, AR.
Это запятые.
Неудачно, правда, но.
Вот.
Окей.
То есть мы хотим посчитать ту штуку.
Ну, какая у нас база есть?
Давайте для отрезков длины 1 зададим базу.
Что такое DP?
Длина 1.
Длина 1.
Длина 1.
Длина 1.
Длина 1.
Что такое DP?
От IN, IN.
Единица.
Ну да.
Всем понятно, почему здесь нужна ясная единица?
Окей, все эти вы разбрались.
Тогда дальше...
Дальше надо разобраться с пересчетом,
как его тут считать.
То есть DP от LR
Ну давайте разберем просто в два случая.
То есть вот ваш массив.
Вот ваш LR.
Вот так вот.
LR.
Вот.
И допустим у вас эти чуваки равны.
То что тогда будет по ответу?
DP от IN.
DP от LR.
DP от IN.
Ну плюс два.
Плюс два символа добавляем.
А L3
с ПСР.
А иначе, если это неправда.
То есть если эти символы не равны.
Максим и
ассоциация.
То есть максимум из вот таких углов под креслом.
Ну почему это так?
Потому что этот элемент у вас значит не вносит
никаких новых подпоследовательностей
полиндромов, потому что у вас нет
крайнего заканчивающегося.
Ну и все.
Поэтому это максимум.
Из
F-1
R
Ну и все.
Да здесь у нас пересчет
золоть единицы делается.
Переход от гранины по отрезку к отрезку
на единицы длины больше.
Вот.
Да, не может нижняя штука быть больше верхней?
Да вроде не должна быть.
Потому что у вас здесь это оптимально.
То есть у вас ответ на этой штуке не больше,
чем ответ на этой штуке плюс один.
То есть как бы по идее не может
максимум что совпасть.
И то не факт.
Потому что у вас
от этих отрезков
добавляется вот этого.
Добавляется одна буква, чтобы получить
один из этих.
И одна буква, чтобы получить этот.
Поэтому здесь как бы плюс один будет максимум.
И как бы плюс два.
Ну так бы нет.
Но если не верится, то по страховке может быть
максимум еще из того, что будет.
Вот.
Окей.
1B
А, ну я думаю тогда понятно, что здесь
время работы с такой динамикой.
Это от N квадрат
гент с длина массива на F.
На время вращения функции F.
А здесь от N куб на G.
1B это такая задача.
Данные
N матриц.
А1
АН
АИТ
размеров
АИТ
имеет размеры А
и минус 1 на АИТ.
Ну там не знаю, матрица 3 на 5, 5 на 2,
3 на 4.
Ну чтобы их можно было перемножить, поэтому у них интересные размеры.
Ну сколько надо делать умножений?
Такие вот элементарные два чиселка перемножить.
Чтобы перемножить две матрицы.
Ну да.
Перемножение
матриц
M на N
и M на K
и будет
M на K
Ну это вроде логично, да?
Что у вас, например,
ровно столько умножений потребуется.
Если вам нужно столько умножений.
Чтобы умножить так много умножений.
То это, наверное, много.
В чем, как видите,
здесь у вас размеры повторяются.
Поэтому каждый
размер будет фигурировать не один раз.
в этих перемножениях, как хочется, узнать вам, как оптимально перемножить
матрицу в каком порядке, в силу того, что у вас умножение матрицы ассоциативно.
Например, у вас a размера 5 на 10, b размера, здесь не знаю, на 7,
c размера 7 на 3, b размера 3 на 5, что-нибудь такое.
И вы хотите посчитать a, b, c, d.
Ну, давайте просто в тупу пойдем на a на b, перемножим результат на c и результат на d.
Посмотрим, сколько действует.
a на b, это будет 5 на 10 на 7, 350.
a, b имеет размер 5 на 7.
Дальше b, c, a, b, c.
Это будет 5 на 7 на 3.
Сколько? Это сложно. 110.
Как получилось? Четко.
Что?
Так явно.
Сейчас.
А, 21 на 5, 105.
И a, b, c имеет размер 5 на 3.
Последний это a, b, c, d.
Сколько будет у нас? 5 на 3, на 5, 75.
А, b, c имеет размер 5 на 5.
Ну, давай считаем сумму.
Что-то типа 530 вроде бы.
Ну, на правду похоже.
Вопрос можно ли оптимальнее?
Будут мысли.
В матрице у меня алгоритмы размеры.
Поэтому можно опять середине матриц маленьких размеров.
Ну, такие дебристики.
Это не какой-то общий алгоритм.
Это жарный алгоритм, в котором мне сложно доказать,
что оптимальность, если вы говорите сейчас максимально маленькую матрицу,
то она приведет к лучшему варианту.
Наверное, динамичнее.
Ну, именно, да.
Я же веду себя под сюжет, который у нас есть.
Причем, заметьте, что вот этот сюжет мы уже сами разобрали.
Остался один сюжет, вот этот, которым я и веду.
Давайте dp-attl это минимальное число действия, чтобы перемножить alt и ar-t-матрица.
dp-attl это минимальное число умножений,
зря на r-ты.
Ну, тогда, наверное, нужна база какая-то, да?
Ну, в смысле, что значит умножить ум на себя?
Здесь нет такого принятия умножить ум на себя.
Если у вас массив длина 1, то вы просто ничего не делаете вообще.
Да, поэтому dp-attl и это ноль.
Почему равно dp и и-и?
Почему и здесь?
Сколько действий нужно, чтобы перемножить две матрицы?
У нас вон размер написан.
Как у вас база интересная?
Немножко нетривиальная.
Ну как, просто требует понимания задач.
Давайте разберемся с формулой пересчета.
Что такое dp-attl?
Ну, так как мы, наверное, ищем минимальное перемножение минимум
по м-атлер, я такое выражение нацелую.
Смотрите теперь.
Ну, сумма двух кусков, да?
То есть, сколько вы бы взяли бы?
То есть, смотрите, здесь нарисую.
l, r, m.
То есть, будто бы вы взяли ответ на куске с l по m,
перемножали, да?
Дальше с m по r.
Ну, с m плюс один уже только по r по перемножали.
И здесь вот склеивать результат вам еще нужно.
То есть, будто бы это что-то типа dp от l-того m-того плюс dp от m плюс один r-тый.
А теперь надо понять, какие размеры будет у итоговой матрицы.
Ну, когда вот мы их перемножаем,
у вас же здесь какой-то результат получился,
и здесь какой-то результат получился,
и у него размеры будут.
Ну, вот будто бы l минус 1, потому что у нас l-тый будет здесь.
Дальше крайние справа-то будут r-тый, да, действительно.
А кто по серединке будет?
Ну, будто бы ам минус 1.
Не знаю, вроде, на правду похожи.
Может, и аминус 1.
Ну, скайм-то будет.
Ну, суть важна.
То есть, вот, как у вас формула получилась,
вон та от краски прекрасная функция g,
которая у вас берет две штуки, там еще что-то считает.
Так вот, вот эта вот функция сливания ответа
от результата был подотресканным.
Вы понимаете, что надо закупы-то все будет посчитаться.
Позвольте не заполнять ту матрицу для этого случая.
Тут 4 объекта много.
Это надо 4 на 4 по полным значениям посчитать.
8 целых.
Перемножать надо неприятно.
Пожалуй, откажу себе по удовольствию.
Можете сами попробовать.
Ну, понятно, что ответ лежит в дп от всего массива.
Порядок перечет тоже понятен.
Он здесь вот такой же,
как и вот здесь написан.
Только у вас еще здесь 4м отель-дайвер перебирается.
Ну и все.
Здесь как бы ничего интеллектуального нет.
Ну все.
Молодцы.
Ну, что ж.
Ну все.
Молодцы.
То есть, как бы,
почти все дп подотрескам сводятся
потому, что вы берете подотрески,
на них считаете ответы.
То есть, как бы,
почти все задачи, которые вам могут встретиться
с дп подотреском, они
сводятся к одной из двух моделей.
Просто возможно функция f чуть сложнее,
или там функция g сложнее,
чем просто так вот взять и посчитать.
Например, не знаю,
еще есть задача,
вам там набор чиселок,
вам можно ставить скобки
плюс-множить и минус.
Нужно найти максимальное и минимальное значение выражения,
которое вы можете получить.
Абсолютно так же,
как в этом случае делаете.
Вы считаете,
будто бы скобками обрабляете этого куска,
ну и дальше ставите между ними операцию,
одну из трех,
и перебираете ответ.
То есть, у вас будет dplr
и там, не знаю, еще что-нибудь типа,
последняя операция еще, если это измерение.
Вот так вот.
Такие еще можно,
ну, короче, можно много задач придумать.
Нагадаем под отрезком.
Например, найти, вам дана там
скобочная последовательность из круглых,
закрывающих круглых квадратных
и фигурных скобок,
найти максимальную подпоследовательность psp.
Тоже сводится к этой штуке.
Потому что у вас psp это еще такое,
что-то типа
скобка и скобка t
и std psp.
Ну, и там квадратный скобок,
вот.
То есть, вы перебираете, что у вас есть
такая вот,
то есть, когда вы переходите сюда,
вы перебираете, что где-то есть посредний парный
и проверите, что это все psp.
Если да, то победа.
У вас там конкретно есть, по-моему,
по одной задаче на этот и на тот тип.
Окей, ладно, второй сюжет на сегодня
это дпп-подможество.
Вообще, надо придумать сначала,
как подможество кодировать.
Сколько, вот есть у вас множество
из одного элемента,
сколько у него подможеств?
Браво, это меня.
Молодцы.
Ну, вот.
Вот так.
Ну, вот.
Вот.
Сколько у нас чисел в двуичной системе счисления длины m?
Полной мм.
Мы еще нашли.
Пусть есть массит a0, a1, an-1.
Да?
Тогда маской его подможества назовем число длины n в двоичной запище.
В запище запитаю, где i-ты бит равен единице, тогда и только тогда, когда i-ты в подможестве.
Ну, например, давайте возьмем подможество.
Этик массив будет на самом деле.
Будем брать его подможество.
Подможество здесь подразумевается не в плане, что только уникальные элементы, а в плане, что индексы уникальные.
Что-нибудь такое.
Тогда число вида в двоичной системе это равносильно тому, что мы берем весь массив.
Например, вот такая вот штука.
Это равносильно, что мы берем какие числа.
Последняя, троечку.
Эту мы не берем, потому что здесь ноль.
Эту берем, потому что здесь единица, двоечка.
Эту не берем, потому что здесь ноль.
Ну, и таким образом можно перебирать просто все подможества.
Окей.
То есть мы с вами приравняем подможество и их маски.
Ну, в плане избиекция, за счет такого отображения, которое мы назвали маской.
Поэтому далее в контексте, когда я буду говорить, число, подможество, маска, это все будет едино.
Вот здесь надо понимать, что все это отображается одно в другое, вот так.
Потому что мы считаем, что это нулевой бит.
Это первое.
Да, здесь немножко не с наступовкой произошло, а просто поделать.
Вы можете считать наоборот, но я все-таки привык, что нулевой бит это младший бит.
Как считать, так нужно, так и делаем.
Окей, тогда вспомним, что у нас есть с вами битовые операции над числами.
По битовой И или по битовой И.
Ну, на сценариях должны были обсуждать, что это такое, когда вы там все контейнеры изучали для работы сотресканно.
Ну, структур данных.
Тогда допустим, что у нас есть А и Б.
Они вложены в кое-то С. То есть это по одной, что кое-то С. Великого, классного.
Тогда кто такой А пересечь с Б? Как его выразить битвами и операциями?
Ну да, по битвой И просто-напросто.
Это Маск А, с Маск Б.
Ну, Маск, это здесь просто-напросто этот двоичный чисел называется.
Ну как объединение выразить?
Ну да.
Кто-нибудь догадается, как симметрическую разность выразить?
Молодцы.
Как лица не выразить? Дополнение там можно.
Как А с чертой написать?
Нет, именно тильда. Вам нужно по битвой инвертирование.
То есть нет что-то?
Он будет считать там, не знаю. Если это не ноль, он обвернет один.
Значит обвернут он ноль. А тильда у вас все биты перевернется.
Там вот те, у кого же АКОС был, там наверное, если у вас же были там всякие Маски сигналов, то там вот как раз где-то используется идея,
что он может так кодировать под множеством.
Собственно, зачем это надо?
Чем нам понадобится эта вот идея гениальная о том, что кодировать можно есть тут вообще числа до 2 степен, и как-то страшно видеть в 8 точке 2 степен.
Вот не надо, мы сейчас будем видеть в 8 точке 2 степен, поэтому не пугайтесь.
Это было создано, ну не то чтобы это прям для этого было создано.
Кодировать под множество всегда полезно.
Особенно эффективно там удалять элементы, добавлять элементы тоже классная идея.
Другой вопрос в том, что выяснилось, что некоторые задачи комменторной оптимизации тоже удобно решать с помощью всяких под множеств.
Например, та же задача в рюкзаке. Вы же можете ее просто решить,
типа сказавшись, допустим возьму этот элемент и рекурсивно запустит это оставшееся под множество.
Могли, ну могли. В чем вы могли разным путем перейти к одному и тому же под множеству.
То есть у нас было бы такое полное решение без мемоизации рекурсии.
А если бы вы писали динамику от под множества, оптимальный ответ для под множества в рюкзаке,
тогда у вас было бы будто ВДП от этого под множества равно оптимуму.
И вы получили бы решение единичным программированием для рюкзака.
Но мы не будем в рюкзаке сегодня. У нас с этим связан лишь один сюжет.
Это задача камевая жора.
Английский. Это ТСП.
Что? Двен, да?
И… Меважора.
Ревлинг Советского программа, по-английски, ТСП еще называют.
Если вам надо будет погулять какие-то статьи по точкам меважора,
вот погуляйте вот по ТСП и вы найдете все статьи нужные вам.
У нее есть наверное тысячи разных постановок.
И такая самая-самая, что ли, известная,
И такая самая-самая что ли известная, это когда у вас есть граф, взвешенный, вам нужно найти гамильтон-офф-путь наименьшего веса.
Сумагного. Гамильтон-офф-путь напомнит путь, который проходит во всем вершинам ровно один раз по ним.
Там причем графы бывают разные, бывают полные, бывают неполные, бывают там что функция веса симметрична, то есть у вас граф неориентирован, бывают что-нибудь антисимметричный, там ничего не такое.
Бывает что там функция весовая удовлетворяет, аксиомом метрики бывает не удовлетворяет, не нравится треугольник.
Это вообще разные алгоритмы для разных случаев, и уж тем более там с разным временем, с разным временем мы ее решаем.
Мы решим следующую постановку, что у нас есть полный граф.
Там полный взвешенный граф.
Что там нужно?
Надо найти...
Ну, по этому ровному пути искать.
Гамильтон-путь минимального веса.
Вот такая вот задача.
Очевидно, что в полном графе гамильтон-путь есть. С этим вы согласны, я надеюсь?
А сколько таких путей?
Ну, будто бы n!
Потому что в любую переставку может быть полный граф.
Ну и как бы перебирать n! путей, ну от n! не сорит на как-то.
Ну, можно сказать, что это от n! плюс 1! путей.
Вот кому понравится вот такое, скажите мне.
Обалденно, да?
Ну, это полный перебор был бы.
Если бы мы не запоминали бы ничего сейчас в рекурсии, так сказать.
Ну, мы бы не рекурсии одна не перешли, там все равно.
Там была бы такая же если бы точка.
Мы хотим немножко улучшить этот результат.
Вот такого вот.
Кто круче?
Очевидно.
Вот кому не очевидно, то пускай докажут, что правый круче.
Наверное, достаточно сказать, что для 10-ти это явно меньше, чем это.
Ну и дальше по индукции у вас все растет быстрее, чем я.
Вот, вот такие вот.
Заказайте, что на пальце.
В чем идея сейчас будет?
А динамика будет следующей.
У нас будет такая динамика двумерная.
В одной из них будет поодно, что в другой что-то еще.
Минимальный вес
гаметного пути
на вершинах из маски.
При этом
позакончить
в вершине В.
Если вы как-то походили, походили.
Граф был большой.
Это же дорогой граф.
Или Райгородского будет рисовать.
Андрей Михайлович.
Граф тут кружок.
Вот он.
Это тарелка была просто.
Это сарделька уже, да.
Вот у вас ваша маска, которую вы посетили.
Вот у вас есть ваша вершинка В.
Которую вы закончили.
И вы здесь как-то побродили, побродили, побродили.
Приперли сюда.
В верчице.
Чуть-чуть почти хот-дог.
Теперь нам нужно понять, как дальше обойти граф наш.
То есть у нас есть три оборота.
Сюда, сюда, сюда, сюда, сюда, сюда.
Сюда ребер нет.
В начальни есть, но мы по ним идти не можем,
потому что эти вершины уже посещены.
Тогда найдем базу сначала.
Какая база будет?
Ну это классно.
Хорошо.
Наверное, это до вершины тоже понятно.
Какой будет ответ?
Ну если у вас одна вершина графа.
Ну да.
А как это записать правильно?
Почему 0 не бесконечность?
Потому что если вы стоите в одной вершине,
то вы уже граф обошли, будто бы.
Сделав ноль шагов.
Не задумывайся об этом.
Да, под 100 ноль все либо хорошо, либо никак.
Ноль это хорошо.
Бесконечность это плохо.
Но мы в него все равно никогда не спустимся.
Я тебе сразу скажу.
Это просто так вкинули с аудитории.
Угадайте следующее,
что ДП вот такого вот вида.
Кому непонятно.
Вот такого вот.
Это В, это В.
Вот так вот.
Какой первый символ там?
Единичка.
Это один побитый из бигфлева В.
То есть чтобы получить два в бетой,
как вы уже помните,
вы должны взять просто побитый из бигфлева В.
И как вы победите.
Поэтому очень удобно
кодировать на самом деле масками.
Потому что когда нужно добавить В в множество,
вы берете ваше множество побитого
или с вот этой вот штукой.
Как кстати получить и этой битой числа?
Правилом 0 или единиц?
Да, взять побитый из вот этой штукой
и вы получите 0 или 1,
в зависимости от того, что у вас было.
Теперь давайте пересчетом разберемся.
То есть это такая ДП.
Только здесь мы будем брать следующее.
ДП от...
Здесь будет динамика вперед.
Динамика вперед.
Динамика вперед.
То есть будто бы мы закончили в вершине У.
То есть мы прошли сначала маск,
потом...
И закончили в какой-то вершине В из маски.
Дальше мы пошли в вершину У.
Вот.
То есть вот маск плюс У
в множество.
И закончили будто и в вершине.
Вот чтобы были в маске, пошли в У.
Что это такое?
Это минимум из...
В из маски.
А, да, здесь надо кстати заметить,
что
У не лежит в маске.
Потому что иначе вы доходить не можете.
Это минимум по В из маски,
что
ДП
маска
ВТ
плюс
ДВ от ВУ.
Ну ДВ это
вес ребра просто.
У вас есть функция ДВ,
которая выдаёт по двум вершинам
вес ребра между ними.
Хорошо.
А, ну остальные динамики
остальные равны
бесконечности.
Ещё здесь надо сказать сразу,
что это неправда конечно же,
что здесь равно так называемое
мин равно.
Что такое мин равно?
Это вы берёте равно
минимум из себя же
и правого аргумента.
Давайте я здесь напишу.
А
мин равно
В,
равно тем, что А равно
минимуму из А и В.
Так же описывается
МАКС равно.
Видите, как
что-то плюс равно В, а здесь мин равно.
Почему это нужно?
Потому что вдруг на самом деле
вам вот эту вот МАСКу могли пустить
из какого-то другого подможества
оптимальным образом.
То есть не эту фиксированную МАСКу надо было брать,
а какую-то другую там и закончить вершины У.
Вот.
Ну и выяснится тогда, что надо было как-то по-другому
действовать и тогда нужно
чтобы этот ответ был лучше, чем то, что мы насчитали.
Вот тогда мы всё время
будем выполнять.
И причём это верно, так когда мы
ставим все остальные динамики равны бесконечности
только, значит неправда.
То есть это понятно примерно?
Как проверить, что вершинка
не входит в МАСКу?
Ну да, вам нужно чтобы
и ты бит был ноль просто.
Ну вот и бит здесь.
Проверить, что В лежит в МАСКе.
Вы просто форум берёте по всем вершинам
и если оно не лежит в МАСКе, то скипаете.
Нам это позволяет
вот этого штука.
То есть смотрите, как устроен вот такой пересчёт.
Вы перебираете МАСКи.
Внутри МАСКи перебираете вершину У.
И если она не в МАСКе,
то типа закончили.
Ничего не делаете.
Если она в МАСКе, то вы ничего не делаете.
А если на ней из МАСКи, то запускайте
ещё один внутренний фор по вершинам В из МАСКи.
То есть МАСК сама
это 2 степен,
перебор У это Н,
перебор В это квадрат.
А как перебирать МАСКи правильно?
Вот, да, это очень важный вопрос.
Потому что казалось бы, МАСКи надо перебирать
в порядке увеличения вложенности
друг в друга.
Когда нашли поднос, то вы должны будто бы
его взять и увеличить.
Иначе, ну, типа,
как вы будете считать больше и множество,
не знаю, меньше, непонятно.
И здесь нужно заметить следующее,
что если вы рассматриваете МАСКи в порядке
отрастания, то к моменту,
когда вы смотрите какую-то МАСКу, все её подносы
уже были рассмотрены.
Поэтому достаточно перебирать фор
И от 0 до 2 степени на минус 1, на самом деле.
То есть это, да, очень важное замечание, что
перебор МАСКи хоть и должен идти
в порядке включения,
но, на самом деле, порядок
по возрастанию удовлетворяет этому свойству.
Чтобы к моменту рассмотрения какой-то МАСКи
все меньше, то есть вне вложды уже
посмотрели.
Вот так вот.
Нет, я понимаю, в смысле
в смысле,
ну, в том, что мы могли
просто прийти в эту штуку другим путем.
Как-то по-другому
собирают подножество.
Ну, смотрите, вот вы хотите
собрать, потому что 1, 2, 3, 4, да?
Вы могли бы собирать как?
1, 2, 3 и прибавить 4, да?
Закончить 4.
Потом, не знаю, 3, 2, потом добавить
1, потом 4. И у вас порядок другой,
из этого веса другие субарды.
Хотя подножество одно и то же.
Но вдруг другой вариант оказался лучше.
Поэтому вам нужно минравло делать.
По не просто равенству.
Да, да, да, да, да.
То есть здесь имеется в виду,
ну, если
убрать математическую абстракцию,
то все одно и одна чиселка, по сути.
Ну, ячейка в памяти какая-то.
Вот это вот.
Фиксируйте массы, фиксируйте ут,
это просто одна ячейка в памяти.
И вы с ней
оперируйте.
Вот, то есть хорошо, окей, ладно.
Вы можете просто сетоксички расстрелить,
это как вот этого.
Что вот эта вот штука равна минимуму из себя же
и вот этой вот штуке.
А она по умолчанию?
По умолчанию бесконечности.
Мы сказали, старая бесконечность.
Ну, давайте для
непонятных блюд бесконечность будем.
Вот.
То есть вот такая вот идея,
что можно подмостов перебирать.
У вас на семинаре будет задача
о максимальной клике рассмотрена.
Вот.
Короче, как-то так.
Ну, и дальше подмостов тоже очень много
можно чего придумать.
Главное, что у вас есть
одинаковая на подмостов, наверное, Н маленькая,
потому что у вас два степени Н есть.
Вот у вас, по-моему, краски задача в контесте
это вот эту динамику написать.
И там M до 13, что ли.
Граф маленький, короче.
Так, ладненько.
Давайте продолжим.
Ну, если никак.
Мы с динамикой закончили.
В принципе, основной категорию мы разобрали.
Есть еще там, кому будет очень
интересно DP по профилю.
Можете почитать.
Мы оставим это
за рамками курса в этот раз.
Потому что такой сюжет, который еще реже
возникает, чем все это.
Раз мы с динамикой закончили, то у нас
на этот семестр и до его конца
остается только одно.
Это геометрия.
Ну и план на сегодняшний остаток
лекции очень простой.
Мы с вами вспомним,
мы поймем с вами,
как кодировать геометрические примитивы
удобным образом.
И там может что-нибудь пообсуждаем про них.
Потому что большая часть у вас на семинару идет
все-таки.
И начнется следующая лекция,
будут уже сразу с многоугольников
пойдем всякие, как пересекать две
прямые уже не будет в следующий раз.
Окей.
Во-первых, все это прямая, собственно.
Потому что я думаю, что точка
не является самостоятельным сюжетом.
А, да.
Еще мы живем в мире
в силу того, что мы все плоскоземельчики,
мы живем на плоскости.
Поэтому вся геометрия будет на плоскости.
В 3D мы выходить не будем в этом семестре,
да и вообще в курсе.
Вот.
Поэтому прямая задается вас очень простым образом.
Это тройка ABC.
Которая у вас
отождествляет
вот такое вот уравнение.
Ах плюс Bх плюс С равно 0.
Вы спросите, почему не у
равно к х плюс B?
Я отвечу, потому что что такое вертикальная прямая
в терминах у равно к х плюс B?
Ну, непонятно.
Ну, типа, Канда в бесконечности стремится.
Все-таки приятнее жить
с вот таким вот осознанием факта.
И как вы можете догадаться
уже по этому замечанию, что у вас предстоит
очень веселый контест по геометрии.
Потому что нам придется эйфать кучу случаев.
Вертикальные прямые, не вертикальные и так далее.
Вот. Прямая.
А как понять, пересекаются ли две прямые?
В смысле непропорциональные координаты?
Вот у вас две прямые.
Да это решить надо.
Ты что?
Мы не решаем ничего.
Какой определитель?
Ребят, мы мыслим в терминах
школьника, шестиклассника сегодня.
У нас есть направляющий вектор A
и направляющий вектор B.
Как понять, что они пересекаются?
Ну, то есть у вас A-вектор и B-вектор
не коллинярные.
То есть если у вас A-вектор
не параллелен B,
это равносильно тому, что прямые пересекутся.
Да.
А как понять,
как выделить из уравнений
прямых направляющий вектора?
Или AB?
Так кто нормаль? Давайте.
Голосование кто из них нормаль?
Просто A1 и A2 равно
B1 и B2, тогда
они параллельны.
Что такое A1 и A2?
Я не знаю, о чем вы написали.
Давайте A1 и B1 и B2.
А для второй
A2, A1 и B2 и B2.
Тогда можно просто проверить отношение.
Но это понятно, что можно.
Но нам потребует
будем, почему нет. Мы не будем
решать систему уравнений.
В том, что вы перейдете в
вещественные числа.
Смотрите, у нас все геометрия будут
построены на том, что вещественные числа
это очень плохо. И мы все считаем
в интах. Вообще все.
Только если вам нужно найти точную точку пересечения,
тогда можно переходить добы.
Все остальное будем жить, что у нас все в интах.
Поэтому будем считать всякие
определители, типа
A1, A2, B1, B2.
Равно 0 равносильно
тому, что A параллельно
B. Потому что один из них является
сильнее на комбинации другого.
Окей.
Найти точку пересечения, но придется решить систему.
Причем, я надеюсь, вы не будете
писать метод крамера.
Нормально просто. Возьмите и вычтите
одно из другого, например.
Выразите х из одного и подставите
в другой. Можно метод крамера
в целом? Почему нет?
Окей. Хорошо.
Прямые.
Как понять, что точка лежит на прямой?
Кто скажет подставить в уравнение,
тот будет очень неправ.
Интересно.
Ну да.
Можно подставить в уравнение прямой,
потому что у вас все коэффициенты в интах.
Можно подставить в уравнение прямой.
Прямая совсем просто.
Окей, отрезок давайте.
Как сдать отрезок?
Хорош.
Ну да.
х1 и у1?
х2 и у2.
Человечество не придумает ничего лучше,
как метод.
Как понять, что
точка лежит на отрезке?
Давайте так сначала.
Можно подставить в уравнение прямой
этого отрезка
и поставить прямой.
Подставить в него
по правильной точке и посмотреть,
что поступало.
Проверить, что площадь
этого треугольника 0?
То есть векторное произведение написать?
Ну точнее, как векторное.
У вас в 2D не существует вектора 0?
Нет.
То есть векторное произведение написать?
Да.
Ну точнее, как векторное. У вас в 2D не существует
векторного произведения?
А оно называется псевдовекторным
произведением в 2D.
То есть мы будем
отождествлять надпись
фидо A на B
векторно. Это у нас будет
в двумерном случае число.
Ну давайте из другого определителя.
Неважно на самом деле с какого.
То есть такой определитель.
Да, в любом случае так и будет.
То есть мы будем отождествлять,
что здесь не вектор получится, а число.
И это будет называться псевдовекторным
произведением.
Чтобы вы потом не пришли
на экзамен по аналиту, не заявили,
что вы в 2D умеете векторное произведение брать.
Потому что это возможно в R3, в R7,
в R4 вроде нельзя.
Вот, это A на B.
Тогда мы в силу того,
что все-таки свойства остаются,
выясняется, что это площадь,
удвоенная площадь этого
треугольника будет, если вы рассмотрите
A-C на A-B.
То есть вам нужно проверить, что
A-C,
A-B
равно 0.
Вот.
В каком прямоугольнике?
Вам нужно проверить, что
проекция точки C падает на A-B.
Как считать проекцию, помните?
Типа нет?
Какие два условия?
Вам нужно...
Ну окей, хорошо, можно
сделать по-другому.
Можно проверить, что A-C и A-B
направлены.
После этого условия A-C
самонаправлен с A-B.
И что
B-C
самонаправлен с B-A.
Вот, если у вас
выполнены вот эти вот три условия,
то я утверждаю, что точка
C лежит на отрезке.
Почему это так?
Ну, если я проверяю вот это вот условие
в нем верно, это значит, у меня точка C
находится от точки A
в нужной полуплоскости.
То есть, если я построю здесь перпендикуляры,
значит, что у меня где-то здесь
вот он находится, на прямой,
на продолжении в эту сторону.
Аналогично я с точкой B делаю
и строю продолжение, и беру
перещение от краски отрезок.
Все.
Это вот эти две
отрезки, это самонаправлены?
Да, да.
Потому что если у вас только это
проверено, значит, у вас точка C может
где-то быть.
Почему?
Вы проверили сначала, что у вас вообще
вот это вот.
Почему? Нет.
Вот пример,
что у тебя A-C и A-B
самонаправлены.
Ну, точнее, A-C и A-B.
У тебя A-B и A-C самонаправлены будут.
Вверх мне даже не нужно тогда
на самом деле вам.
Даже не нужно
на самом деле.
А зачем?
Да, да, да, да.
Вот к линяру все-таки ничего
в параллельности, а самонаправленность в одной
сторону вообще.
У тебя достаточно
самонаправленности?
Точка A фиксирована.
Что значит, что
A-C самонаправлены с A-B?
Это значит, что они лежат, если они вкладываются
в одну точку, значит, они на одну прямую лежат.
Причем в одну сторону смотрят.
Окей.
Разобрались с отрезком
и точкой.
Так, дальше.
Как понять, что отрезок пересекается с прямой?
Это хороший вариант, действительно.
Давайте отрезок прямая.
И прямая.
Вот ваша прямая P,
которая будет задаваться точками A-B.
И вот ваш отрезок CD.
Как проверить, что они пересекаются?
Наверное,
они пересекаются с прямой A-B.
Как проверить, что они пересекаются?
Наверное,
тут говорят, да,
проверить, что пересекаются прямые,
образованные CD и A-B.
Проверить, что точка пересечения лежит внутри отрезка.
Прямо то, что у вас точка пересечения
становится священными координатами и все.
Из-за точности вы проигрываете.
Да.
То есть, вам нужно посмотреть, что CD лежат в разных полуплоскостях.
На самом-то деле.
Как это можно сделать?
Например, можете видеть вектор A-B.
Смотрим вектор A-C-A-D.
Тогда напомню, что такое
вот эта вот наша штука.
Но она очень близка будто бы на то,
что это модуль A на модуль B на синус угла между ними.
На самом деле, так и будет.
Я не знаю, какие формулы.
Я мышлю в парадигме шестиклассника.
У меня есть векторная произведение,
SkyArt произведение, все, я больше ничего не знаю.
А, причем, как проверить, что есть соноправленность?
Это же не очевидно.
Не, подожди, давайте научимся сначала соноправленности.
Я забыл вам сказать, как делать.
Это вам нужно, во-первых, проверить, что векторное произведение
равно нулю.
Ну, псевдовекторное. Что это значит?
Где он равноully?
Как проверить именно соноправленность?
Вам нужно, чтобы косmos был положительным.
Как проверить, что косmos положительным?
Да, что SkyArt произведение положительным.
Все.
То есть, смотрите, мы увидим, 305et não oper AIDSitisimi possible.
переходить к синусам и космисам только когда
одну совсем не в маготу.
Пока что все в маготу.
Окей, как проверить, что C и D лежат по разной стороне от A-B?
Вы берете вектор, и вам нужно проверить, правда ли что,
вот этот угол меньше 90 градусов будет,
ну или там больше, не очень важно,
он меньше 180 будет, окей, а другой угол больше 180,
причем какой из них не очень понятно,
поэтому, а что такое угол меньше 180 и больше 180? Это синусы их, согласны?
То есть у вас синус от 0 до 180 положительно, 180 и 60 отрицательно,
поэтому берете и просто делаете вот так вот,
A-B на A-C умножить на A-B на A-D будет больше,
наоборот, вам нужны разные знаки, меньше либо равен нулю,
потому что если разница 0 у вас есть, то у вас есть то, что у вас просто лежит одна из точек напрямую,
ну все вот, отлично, вы проверили, что 0 лежит на A-B в разной полуплоскости, браво,
вот уравления, не переходящие в W, не равен, точнее, окей,
точку отрезок посмотрели, отрезок пилом посмотрели,
давайте самое сложное, отрезок и отрезок,
у нас времени, а еще 10 минут целых,
как проверить, что два отрезка пересекаются?
Да, все, надо проверить, что, то есть вы берете и проверяете вот это вот неравенство,
это у вас то, что у вас CD пересекает A-B,
давайте аналогично две точки С запишем, CD на CA, CD на CB меньше 0, все,
это первый способ, есть второй способ, он очень страшный,
там вы строите какие-то bounding boxes,
то есть вы строите вот такие вот прямоугольники,
для каждого из отрезков вот такой вот будет,
смотрите пересекаются эти прямоугольники,
с помощью проекции по X и Y на соответствующей оси координации,
мне кажется это очень страшно, но у нас есть хороший вариант,
окей, так, с отрезком на отрезком разбрались?
Потому что это первое, это только то, что у вас CD пересекает прямую A-B,
он уже по причине на отрезков,
это наоборот то, что A-B пересекает прямую CD,
вот, да, это единственный случай,
это если A-B не параллелен CD,
если A-B параллелен CD,
значит вам нужно проверить, лежат ли все точки на одной прямой,
если они все лежат на одной прямой, это один случай,
если C не лежит на прямой A-B,
то все, у вас нет пересечений,
давайте рассмотрим случай A-B, проверим CD,
тогда из этого следует первый вариант,
что C не лежит на прямой A-B,
из этого следует, что A-B пересечит CD, пустое множество,
значит, если C лежит на прямой A-B,
тогда у вас получается какой контент?
вот здесь A, здесь B, здесь C, здесь D,
давайте я буду считать, что заведомо,
я могу параметризовать прямую,
то есть ввести просто радиус-вектор точки A,
радиус-вектор точки B, допустим,
и параметризовать через параметр T,
то есть, что у вас AB,
это просто RA плюс T на RB минус RA,
ну, радиус-вектора,
вот, ну и для T любого приезжающего R,
это точка на прямой,
давайте считать, что да,
если у кого-то из отрезков совпадают концы,
то вы переходите к точке-отрезку,
это мы уже умеем решать,
вот, вот так вот, AB-CD,
давайте я буду считать,
что A-B, C-D,
просто так жить проще будет,
левее с точностью до вот этого параметра,
вот, ну тогда, что я могу сделать,
чтобы проверить прищелье,
нужно проверить, что C лежит внутри AB
или B лежит внутри CD,
это прямой AB, вам нужно отрезок AB теперь,
второе,
ну, C принадлежит прямой AB,
ну, что тогда можно сделать,
ну, если у вас C,
проблема в том, что у вас C может
не принадлежать отрезку AB,
при этом пересечение может быть, знаете когда,
C не лежит в отрезке AB,
но при этом пересечение
в целом отрезок AB,
поэтому вам нужно проверять, лежит ли A,
в CD лежит ли B,
в CD лежит ли C, в AB лежит ли C,
лежит ли D в AB,
если хоть что-то из этого верно,
то вы даете правду,
что есть пересечение,
иначе говорить, что пересечения нет,
надо просто перебрать,
C лежит в AB,
D лежит в AB,
A лежит в CD,
и B лежит в CD,
если хоть что-то из этого правда,
то у вас есть пересечение, иначе его нет,
круто, да?
5 минут,
надо еще 5 минут рассказать,
прикольно.
Сложно понять,
что такое слева,
сложно понять.
Если вы параметризуете туда,
тогда можно,
я говорю, что если без параметриза,
то придется вот это делать.
Окей, тогда
наверное еще
небольшой сюжетик,
раз мы пересекали все,
с чем можно было только.
Давайте, наверное,
разберемся с расстояниями
и закончим на этом сегодня.
Первое расстояние между точками.
Ну да.
Что?
Можно квадрат расстояния,
неважно.
Ну я считаю, что с ними
с точками любой сможет вас посчитать.
Расстояние
от точки до прямой.
Это что там на умном?
Я такого не знаю.
Я знаю формулу.
Я мыслю в парадигме шестиклассника
всю эту лекцию.
Ну вы помните,
векторное произведение,
это площадь параллограмма,
построена в нем.
То есть площадь ABC,
ну псевдовекторного в нашем случае,
это 1,2ABC.
Это с одной стороны,
с другой стороны.
Это же
равно 1,2.
А, ну площадь треугольника.
Чему равна площадь треугольника у вас?
А, да, полупроизведение
длины основания
на высоту,
которая вас интересует.
То есть у вас получается,
что H это будет
сложно.
Сейчас.
ABAC
перейти на AB.
Будто бы вот так вот.
Здесь уже, к сожалению,
придется вам к веществам переходить.
Даже так у вас,
даже если вы перейдете в квадрат,
у вас все равно будет не обязательно целый.
Давайте от точки до отрезка.
Здесь есть два случая.
Первый случай,
проекция C попадает
на проекцию C напрямую
с держащей AB.
C штрих.
То есть C штрих это
проекция на AB.C,
что она попадает
внутрь отрезка AB.
Если C штрих
принадлежит
отрезку AB,
то это будет
принадлежит
отрезку AB,
то ответ, будто бы,
расстояние от точки до прямой,
то это род
расстояния от C до
прямой AB.
Второй вариант C не принадлежит
отрезку AB.
Как тогда есть?
Это что-то такое.
Тогда очевидно,
если вы опустите проекцию,
то в силу того, что
чем больше основания
вот эта вот,
тем больше наклонная,
ответом будет минимум
SCA, SCB.
Ну, длин.
Вот.
Стал научиться находить проекцию.
Как проверить, что проекция попадет
отрезка AB?
И что?
И что?
Почему?
Тогда оно должно быть
AC и BC.
И вектор на еще ноль,
то есть,
у вас C должна на прямую
попасть сначала.
Ну, я понимаю, да.
Ну, то есть, если у вас,
чтобы вы получили проекцию,
чтобы понять, что, да, вам нужно еще векторное,
то есть, вам все равно придется проекцию искать.
Ну, как искать проекцию?
Давайте, ребят, вы сможете, я в вас верю.
Ну, тогда найдите проекцию
и проведите, что оно внутри отрезка, и все.
Какой?
И что?
Почему, если C, AB больше 12 градусов, все хорошо?
Какой вы? C, AB смотрите, да?
А, я понял.
Либо вот это вот
ФИ1 смотреть.
Либо вот это вот ФИ2 смотреть.
Если один из них тупой, другой острый,
то, действительно, да, проекция будет
снаружи. Если оба острые,
то проекция будет внутри.
Факто.
C штрих принадлежит AB,
равносильно тому,
что ФИ1 меньше
ПИ на 2.
ФИ2 меньше ПИ на 2.
Потому что, если один из них прямой,
то попадете в вырожденный случай крайний,
в котором вас оба варианта
устроят.
Если хотя бы один из них больше,
чем ПИ на 2, то вы выйдете
за прямую.
Да, можно проекцию не сказать справедливо.
Ну, расстояние между отрезками сможете найти?
Вам нужно объединить квинтасенсию
всего, что было сказано, и получить
огромную такую вот штуку
отрезков.
Сейчас вам нужно проверить,
отрезки пересекаются или нет. Если пересекаются,
то ответ ноль. Если они не пересекаются,
то они могут быть параллельными.
Если они параллельны, то там по одному способу решается.
Если они лежат на пересекающейся
прямых, но не пересекаются,
то это будет другой разговор.
Да,
но здесь не нужно будет искать, на самом деле.
Если у вас С штрих попадает
на отрезок АБ,
тогда только тогда, когда у вас ФИ1 и ФИ2 острые.
Так расстояние это у вас будет от минимума СА и СБ.
А, так вот, это расстояние
от точки до прямой будет случай.
Короче, расстояние между отрезками, оно считается следующим образом.
Вот у вас
два отрезка,
А, Б, С, Д,
и берется минимум
из четырех величин.
Расстояние от А до С, от Б до С,
от С до А, от Д до А.
Получается, что минимум
из этих четырех величин даст вам ответ.
При условии, что они не пересекаются.
Если они пересекаются,
это другой разговор.
Все, вот так вот.
Так, а если здесь точка С лежит
на прямой АБ, что будет?
А, ну да, мы перейдем,
все равно у нас будет один из углов больше,
и все будет хорошо, окей.
А о пересечении отрезков мы разобрали,
если он лежит на прямой.
Получается все, мы с вами разобрали все расстояния
и пересечения,
на семинарах соблюдут окружности,
и с следующего раза
мы начинаем многоугольники сразу.
Ну и все тогда.
Вроде бы по времени тоже все.
