сегодня мы поговорим про локаторы да значит моя цель сегодня успеть вам
рассказать все что нужно и выдать вам первую задачу да я понимаю ваши опасения
полгосом то да у основы у основы тоже первая задача этой недели должна появиться
но она будет другая вот эта задача которая у вас будет первая она будет
второй у них да еще дек вас мы уж так и быть решили избавить от дека и но зато
добавить кое-что другое конец вот так сказать поп-фронт pushback сделали да
с фейковой вершиной с одной не ну получилось бы но это было бы криво
неприятно так окей смотрите значит начнем по пунктам что сначала что такое
локатор даже идея локаторов ну давайте вспомним что мы знаем уже к
текущему моменту про память и про управление памятью ну мы наверное
знаем из первого семестра возможно и со школы даже что вот бывает стек ну что
вот есть я напоминаю вот это статическая память да тут которая дата потом есть
код текст и стек вот это то что выделяется вашей программе изначально
фиксированного размера а есть еще динамическая память называется хип и у
нас есть оператор нею который которым мы иногда можем обращаться если мы
понимаем что по какой-то причине вот стэк мы не хотим класть но то что мы
значит по умолчанию локальные перемены заводим они кладутся в стэк статические
перемены кладутся сюда и глобальные а если мы понимаем что в стэк мы не
помещаемся ну или просто если мы заводим какой-нибудь вектор стринг мы
же не обязательно в стэк не помещаемся когда заводим стринг просто стринга и
вектор так устроена что они внутри себя выделяют память на кучу и вот
происходит фактические обращение к оператору нею который в свою очередь а
вот что делает оператор нею кто понимает что он делает примерно ну да это
понятно а как да на самом деле там есть еще один уровень вот оператор нею он сам
по себе ну понятно что он как-то реализован компилятором да оператор
нею ее правда можно переопределить и этим мы вскоре займемся это правильное
замечание обычно действительно не стоит так делать но стоит хотя бы
посмотреть как это делается так вот оператор нею он вызывает функцию malloc
скорее всего ну то есть если мы будем писать свой оператор нею то скорее
всего мы будем обращаться к сишной функции выделения памяти оператор нею это
по сути такая чуть более высокоуровневая отстройка но malloc но что делает оператор
нею он на самом деле выделяет памяти вызывает еще конструктор ну еще всякие
разные вещи делать например бросает исключение если памяти не хватило вот
еще разные вещи там делает например поддерживает кастомную функцию обработки
ситуации когда памяти не хватило new handler так называемый ну это примерно как
вот terminate по сравнению с abort вот мы уже с вами обсуждали что есть плюсовая
функция terminate которая чуть более умная обертка над сишной функцией abort когда
программу надо завершить экстренно но вот это вот как бы вот это вот уровень вот
это вот мир c++ вот это вот c ну функция malloc в свою очередь она тоже не просто
так устроена она на самом деле там скрыта довольно сложная логика в ней и она
пытается как-то вот по умному что-то делать как-то вот распоряжаться с
памятью но сама по себе функция malloc это еще не уровень операционной системы то
есть функции malloc можно еще написать самому вот можно самому написать аналог
malloc правда это очень сложно будет вы поймете наверное скоро почему но сама
по себе функция malloc еще можно на c реализовать а вот дальше начинает есть
еще один уровень это уровень os kernel но это тоже c правда но я даже не буду
стирать но вот дальше есть такая функция mmap называется это так называемый системный
вызов что такое системный вызов это функция которая передает управление ядру
операционной системы функция malloc это еще не системный вызов это еще функция из
библиотеки сишной а вот ммэп это функция которой malloc обращается в конечном счете
когда он понимает что сам не справляется то есть malloc там поддержит какой-то пул
свой он что-то делает неважно ну в конечном счете все опирается в функцию ммэп ну или там ее аналог
неважно там какой и вот ммэп это уже непонятно как устроено ну то есть может быть и понятно
может вам там на втором курсе расскажут про это но я вот уже не знаю как это устроено да но это вот
ядро операционной системы делает там как-то вот уже непосредственно вот прям вот с оперативной
памяти что делает но окей это вот все оно так выглядит вниз но мы с вами знаем что вызов
оператора new это вещь которую вообще мы обычно хотим избегать не правда ли но то есть мы с
вами понимаешь что вызов оператора new вот в нашем мире в мире c++ это достаточно такое дорогое
действие которое приводит аж вот к такому и там передается управление ядро операционной системы
наша программа замирает планировщик переключает выполнение там на ядро и начинается что вот мы
хотим мы подумаем а вот нельзя ли нам как-нибудь взять управление памятью в свои руки почему бы
нам не написать какой-нибудь класс который бы сам решал как памятью распоряжаться ну как бы он
это делал ну понятно что разочек все-таки оператор new вызвать бы пришлось ну разочек в самом
начале допустим вызовем оператора new на гигабайт сразу а потом мы будем просто класс поддерживать
который сам будет ну вот по какой-то причине мы можем лучше знать как нам памятью распорядиться
чем системный вот этот вот молок или кто-то там есть и просто теми кто память распоряжается
да это это это это первое во первых нет
а ладно я просто хорошо ладно нет я я если что сегодня на одну только пришел да я я если что
был даже морально готов к тому что и на вторую не приедешь но ну просто вдруг ну хорошо что
были готовы обе стороны хорошо ладно так вот да есть две причины во первых мы хотим
минимизировать обращение вот сюда это долго очень а во вторых мы можем просто сами лучше знать как
нам распоряжаться ну потому что например мы можем знать что все наши выделение памяти будут одного
размера и маленькими но скажем мы знаем что мы вот нам предстоит порядка миллион раз вызвать
оператор нею на 4 байта планировщик ну менеджер памяти операционной системы не может делать
таких предположений он старается угодить всем вы можете выбирать разные алгоритмы memory
менеджмента смотря по тому какие скорее всего как вы предполагаете у вас выделение памяти
будут какого размера и сколько и в каком порядке в ком количестве там понятно что вот вот этим
вот пулом можно распорядить вот этим вот пулом можно распоряжаться по-разному смотря что вам
предстоит выделять и насколько много вот поэтому зачастую бывает так ну не зачастую но иногда
бывает так что вы лучше сможете вы лучше знаете как распорядиться пулом памяти чем операционная
система просто потому что операционная система не может сделать предположение о том сколько вы
впредь и каких запросов ей дадите вот поэтому мы приходим к идее того чтобы неплохо иметь
свой класс еще вот над ним уровнем выше который называется allocator на уровне плюсов то есть
вот allocator это еще одна абстракция над оператором new которая позволяет вам самому один раз допустим
обратившись к new а может быть и вообще не обращаясь к new сейчас мы обсудим варианты
написать свой менеджер памяти вот ну и на самом деле если теперь еще раз глянуть на контейнеры вот
например на вектор можно наконец открыть глаза на реальность и заметить что там у них у всех
был еще один шаблонный параметр мы обходили стороной старались про него не упоминать но
теперь самое время на самом деле у всех контейнеров вектор листа есть еще один шаблонный
параметр allocator то есть на самом деле вектор но он выглядит так значит там есть template type
name t вот конечно из-за доски у меня есть искушение начать писать класс t вместо type name t type name
alloc вот но он это шаблонный параметр по умолчанию поэтому его вы никогда скорее
всего не упоминаете и не думаете о нем потому что он по умолчанию подставляется равным чему
std allocator от t у него шаблонный параметр тоже есть да на самом деле спойлер вот вот это это
была огромная ошибка комитета по стандартизации когда они добавили а локатору шаблонный параметр
но осознали они это слишком поздно и все плюс плюс в общем дальше был долгий путь страданий как
они пытались от стандарта к стандарту сделать а локаторы более удобоваримой концепции языка
но в конце концов c++17 они ввели std polymorphic allocator который избавил от необходимости писать
шаблонный параметр t но это длинный спойлер это далекий спойлер вот на там пару занятий вперед
наверное ну нет ладно на одно следующий раз мы уже мы до этого дойдем вот но пока идея в том
что мы пишем шаблон параметр t но оно так вот и используется ну вот и теперь давайте посмотрим
как на самом деле должен выглядеть ну скажем резерв вот когда у нас был резерв там мы на
самом деле но эти вообще подумаем что нам надо это локатор какие методы мы хотим чтобы обращение
к нью заменять ну и дилит что логично заменялись вызовами каких-то методов локатора а локатор
должен себя инкапсулировать логику либо обратиться к нью либо сделать что-то более умное что
возможно мы сами напишем если подставим сюда вместо стд локатор свой локатор по сути нам
нужно от локатора два метода а локейт идея локейт да и вместо чего мы будем писать а локейт
вот там где мы пишем нью нью от там п ты вот чего-то там вместо этого мы будем писать
а локатор точка локейт ну у нас на самом деле здесь будет поле еще у нас будет поле
который просто а лог это некоторый объект он живет как поле в векторе то есть на самом
деле у вектора еще на одно поле больше я не сказал что он большой он очень маленький на самом
деле это правда но это же не означает что он сам должен быть большим маленький но даленький
но сейчас увидишь но он нет сам по себе объекта лог маленький он там указатель хранит и пармчисел
обычно сам ну сейчас сейчас увидим вот ну короче это некоторый объект и он должен храниться где-то
в полях поэтому на самом деле у вектора не три поля а 4 то есть помимо указателя на массив самого
сайза и кп 100 еще есть а локатор вот но стандартный а локатор он вообще очень маленький у него
ща полей нет ну сейчас увидите в общем чего на себя представляет что такое вот это будет
вместо этого мы будем теперь писатьanner.alocate
а log с точка аллокить так нет
минуточку минуточку минуточка минуточках мы как раз так то не хотим дело это будет как раз
неправильный написал вот мне вместо этого будем а лока локейт писать это же как раз не прил액ает
операции а Лакита мы должны писать в те моменты когда мы алоцируем а и Conスト рейн уже алоцируем
как раз все наоборот вот как раз то что я хотел а правильно мы там писали жуть
в виде что-то типа newr ну там мы писали там t звездочка newr равно ну там где-то
мы там делали резерв когда мы там реалацировали мы что писали новый
массив это это там reinterpret cast t звездочки от на самом деле new char в
квадратных скобочках там сколько-то n умножено size of t вот это жесть вот как
раз вместо этого мы нет это как раз нетипичный код на c++ в современном c++
так не пишут так не принято принято писать вот даже на самом деле не так
принято еще чуть по-другому но сейчас вот пока будем так писать а лог точка
локеть и локеть один параметр сколько да кто ху вот сколько n да вот поэтому
он и от т потому что он знает да вот то что на т как раз говорит о том что ему
мы передаем только сколько штук а он выделит байт столько сколько надо
под столько штук на кучу он их выделит но зависит от него это локатора конечно он
возвращает указатель то есть вот мы вместо там вместо вот этого мы пишем теперь вот вот
вот короче пишем вот это вот теперь а дело а еще есть делокейт а как работает делокейт
да мы должны вот вместо того чтобы писать там ночем не буду мы там писали до дилит
квадратной скобочки опять три интерпрет каст к чар звездочки вот это всего вы писать
локейт вот что нужно передавать передавать нужно указатель и число зачем передавать число
ну ответ математика абсолютно точно абсолютно бесполезно drastically требует стандарт почему
на самом деле нужно передавать число но на самом деле стандартному а локатору как раз не нужно
число, но вот вашему аллокатору может быть нужно. И в общем приняли соглашение, что надо
передавать число то самое, которое вы передавали, когда просили allocate это. Из-за какого? Полимортный
появился только в C++17, а это еще в C++03 было, тогда еще никто не подозревал о том, что.
Нет, полиморфный аллокатор это вообще не аллокатор в старом понимании, это вообще
другая вещь. Ну, точнее, нет, это аллокатор, но, короче, он с этим аллокатором никак не связан.
Да, ну, короче, вот просто так вот надо передавать. Потом, возможно, поймем почему, а, возможно,
нет. Ну, возможно, вам это понадобится когда-нибудь, а, возможно, не понадобится. Вот, но есть еще два
метода аллокатора. Почти, ну, то есть, на самом деле в C++20 они признаны устаревшими и их убрали,
но я про них все-таки расскажу. А именно, у них еще есть метод construct и destroy. Сейчас я объясню,
почему они стали deprecated и что вместо них, но сначала я все-таки расскажу, как было до этого.
Еще есть метод construct. Вот construct — это как раз замена вызову placement new. Как вы пишете construct?
Вы пишете construct ptr, а дальше args, и он вам ничего не возвращает. Значит, construct — это то,
что как раз надо писать вместо new от ptr, t от args. Так, вот вы по указателю хотите создать объект типа t
от таких аргументов. Аргументов тут может быть много. Обычно это параметр шаблоны с переменным
количеством аргументов, и тут многоточие, просто распаковка пакета. Вот, еще есть destroy.
Construct и destroy. destroy — вы ему просто передаете ptr, ну и он по факту вызывает destructor t
по этому адресу. Нет, он пишет ptr, стрелочка, тильда t. Да, конечно, только одиночного объекта.
Вот. Ну по сути нам вот эти четыре вещи-то и надо будут. То есть вот все то, что мы там свистоплязка
вот с этим вот new и непонятными какими-то заклинаниями писали, теперь у нас есть просто
четыре метода, которые за нас там что-то делают. Возможно, делают это, возможно, делают что более умное.
Теперь давайте поймем, а как они реализованы на самом деле в std-аллокаторе.
Отличный вопрос. Очень правильный, но он преждевременно задан. То есть действительно,
почти никогда не нужно делать что-то иное, чем placement new просто. Как и в случае destroy,
почти никогда не нужно делать нечто отличное от вызова destructor явного. Но бывают случаи.
И сегодня не будет их. Но вот в следующий раз, завтра, я думаю, тоже не будет,
а вот через неделю я думаю, что расскажу. Вам так не хочется? Слушайте, ну вы как-то рано
сдаете, семестер только начался, нам еще гораздо более интересные вещи предстоит. Слушайте,
с вами как-то невозможно работать. То вам скучно, потому что слишком банальные вещи рассказываются,
то когда начинаются не банальные вещи, а можно, не надо, мы не хотим это знать. И как вообще,
как отгадать вообще, что вам надо рассказывать тогда, я не очень понимаю. Как-то очень сложно
балансировать, слишком капризные какие-то люди пошли. Так, короче, вот четыре метода.
Construct и destroy действительно почти всегда делают одно и то же, но иногда все-таки нет, и поэтому
у некоторых аллокаторов, у них там хитрая реализация, ну про это мы потом поговорим,
пока еще не понятно совершенно, что это могло быть такое. Аргументы, которые в constructor.t
надо передать, new от ptr, t от args нужно же написать. Так, хорошо, ну теперь, что из себя представляет
вот этот std-аллокатор на самом деле? Вот как он реализован? Ну вот тут бы, конечно, мне не
помешал проектор и просто код на экран вывести, но раз уж у меня нет проектора, давайте я потрачу
лишние пять минут и напишу реализацию на доске. Но я причем не буду даже, наверное, писать там
что такое вообще, как выглядит? Хорошо, template. Ну ладно, нормально, успеем. TypeNameT. Я напишу,
что это структура, а не класс, потому что там все публичное будет. Вопреки ожиданиям, возможно,
которые у кого-то были. Аллокатор это максимально простая и очень тупая структура. Написать
реализацию std-аллокатор это упражнение там, не знаю, для семиклассника, да. Я хотел сказать на
троечку, ну типа, ну очень просто. Стандартный аллокатор, он очень примитивный. Во-первых,
там нет полей ни одного. А что делают методы стандартного аллокатора? Так просто они должны
делать то, что раньше было написано вместо этого. То есть, как, например, работает allocate? Он
возвращает t звездочка, allocate. Да, принимает он что? Size tn. Да. Так, ну и что он делает? Ну тут
возможно написать const. Я не знаю, ну я даже не знаю, правильно ли писать тут const. Ну вообще
можно написать, потому что аллокатору пофигу, конечно, на этот allocate. В случае стандарт,
вообще говоря, аллокатору не пофиг, когда allocate происходит, потому что аллокатор может
от этого поменяться. Ну потому что если это какой-то умный аллокатор, у него может хранить
состояние, он может как-то вот менять что-то в себе в зависимости от того, какой allocate сделали.
Но стандартный аллокатор, ему без разницы, ему вообще менять нечего. Просто стандартные у него
полей нету. Ну константный аллокатор довольно странная сущность. Я вообще не знаю, где такое
бывает или нет. Не буду писать const на всякий случай, потому что как-то это неправильно. Вообще,
наверное, это не идеоматично allocate, чтобы было константным. Ну и что тут? Тут надо написать
return. Ну вот надо примерно вот это и написать, вот это вот, return, вот это вот, return, бла-бла-бла-бла-бла-бла,
интерпет, касты. Вот. Ну на самом деле не совсем это опять-таки, но тут можно бесконечно улучшать,
понимаете. Есть очень много уровней, глубины, до которых можно это все оптимизировать. Ну
идеи, например, на это надо написать. На самом деле там обращение к new чуть по-другому выглядит,
там не написано new char, а там чуть-чуть другая форма new используется, но по смыслу все вот
примерно это там написано. Просто вот вернуть это надо. Понятно, что дело deal locate. Нужно просто
вызвать, ну опять же, нужно вызвать delete к чару опять приведенный и там надо на самом деле ничего
не возвращать даже. Там вот что делать construct? construct вызывает оператор new, как раз placement
new, construct. Что делает construct? t звездочка ptr и еще аргументы, переменное число. Да,
у него должно быть переменное число шаблонных аргументов. Type name многоточие args. Вот. Ну и тут
надо написать что-то типа const args ampersand многоточие args. Опять же, на самом деле не совсем это,
но к этому вопросу вернемся еще позже. Что если ут нет конструктора этих ваших пакетов? В смысле от
пакетов. Не бывает конструктора от пакетов. Бывает конструктор от некоторого количества
аргументов. Пакет это сущность, которая существует только в сознании компилятора. В момент генерации
шаблонного кода она превращается в нормальный список параметров. Без вот этого уже. Ну и тут
просто происходит new от ptr, t от args. Вот. Ну и destroy я не буду писать, что происходит. Очевидно,
что происходит. Просто делается ptr стрелочка tilde t. Вот. Так выглядит аллокатор. То есть на
самом деле вот этот объект он один байт всего занимает. Все один байт. Вот. Почему один, а не
ноль? Ну потому что не бывает объектов размера ноль байт. Но вот один байт больше не надо. Как
выглядят конструкторы копирования, оператор присваивания этого аллокатора? Move конструк...
Ой, извините, вы не знаете. Ладно, destructor. Ну в общем, они тривиальные. Они, ну можно писать
равно default, но это вообще без разницы, потому что они ничего не делают. Можно написать,
что они пустые просто. Можно их не писать, не будут по умолчанию. Ну они просто ничего не
делают, потому что копировать нечего. Этот аллокатор он stateless, у него нет состояния,
он ничего не хранит. Это просто обертка над вызовами new и delete. Вот. Зачем нам, почему,
что еще раз? Вот сейчас как раз вот сейчас понятно, что если бы все аллокаторы были
такими, то не нужно было бы объектов создавать. Но давайте подумаем, какие могут быть другие
аллокаторы. Вот например, ну то, о чем я говорил, вот что если я хочу завести большой пул в самом
начале и им распоряжаться самостоятельно? Ну такое, потому что, а что делать,
если он исчерпается? Нет, перекладывать ничего нельзя. Аллокатор, нет, аллокатор не может
перекладывать, он должен, это уже не то. Ну на самом деле придется поддерживать что-то типа там
связанный список этих пулов, ну этих блоков, да. Но можно работать в предположении, что пул
никогда не исчерпывается. Потому что, смотрите, ну можно, например, кидать исключение, если пул
исчерпался. Нет, ну смотрите, вы обычно же чего, вы для чего используете свой аллокатор? Вы используете
свой аллокатор как раз потому, что вы это знаете лучше, чем вот операционная система, как будет
и сколько памяти у вас выделено. Вы допустим понимаете, что вы ни за что, ни когда в жизни
выделите больше гигабайта. Поэтому ваш аллокатор, он в самом начале выделяет гигабайт и дальше
работает в предположении, что он никогда не исчерпается. Нет, можно, конечно, там считать,
что возможна ситуация, что оно исчерпается, ну и поддерживает там действительно какое-то вот несколько
этих блоков. Вот, ну то есть как теоретически мог бы быть устроен нестандартный аллокатор? Вот
типичный пример такого аллокатора это пул-аллокатор. Пул, не тот маркер, пул-аллокатор. Нет, это вам написать
надо будет. Ну нет, на самом деле не совсем это вам написать надо будет. Сейчас я вам расскажу. Да.
Нет, не хотим, потому что аллокатор должен копироваться уметь. Что должно происходить,
когда ты вектор конструируешь от другого вектора? Представь, что у тебя аллокатор синглтон и ты
решил написать вектор равно другой вектор. У вектора есть поле аллокатор, он должен быть как-то
создан из аллокатора, который был там. Как это должно произойти? Если аллокатор... Нет, вот как раз
нет. Мы храним в поле сам аллокатор, а не указательный аллокатор. Идея в том, что сам по себе аллокатор
это легковесный объект. Это правильный вопрос. Да, у вас может быть несколько аллокаторов,
аллокатор это средство управления некоторым блоком памяти. Сам по себе аллокатор должен быть
маленьким и легковесным. Аллокатор в себе не должен хранить какую-то огромную вещь. Он содержит
себе обычно правильный и диаматически использованный аллокатор. Аллокатор себе содержит пару указателей,
и у вас может быть несколько аллокаторов на один и тот же блок памяти ссылающихся, на один и тот
же пул. И когда вы копируете вектор, вы можете получить копию того аллокатора,
которая будет вам позволять использовать тот же блок памяти, что и тот вектор использовал.
У них может быть как раз класс Singleton, который хранит в себе состояние глобальное для данного
блока памяти. У вас должен быть класс пул, в котором и выделен этот пул, и он хранит вектор из каких-то
чисел, которые говорят о том, как этот пул хранится в этом классе. Аллокатор – это лишь средство
обращения к этому пулу. То есть пулы-аллокаторы, их может быть несколько, ссылающихся на один и тот
же пул. И возникает правильный вопрос, когда я создаю пул-аллокатор, что я должен делать,
когда я создаю новый пул-аллокатор? Я должен, наверное, создать новый пул. У меня несколько
пул-аллокаторов может заведовать одним пулом, но я же могу иметь несколько пулов в одной программе.
То есть у меня есть большой пул, и сколько-то пул-аллокаторов им распоряжается. Есть другой
большой пул для других нужд, и сколько-то пул-аллокаторов им распоряжается. То есть,
если я создаю новый аллокатор с какими-то определенными параметрами, допустим, я хочу
сказать, пул-аллокатор нам вот 100 тысяч. Это означает, что я должен новый пул создать,
то есть я создаю новый инстанс класса пул и запоминаю указатель на него, допустим. А дальше,
когда я создаю пул-аллокатор от другого пул-аллокатора, я лишь копирую этот указатель,
и у меня получается, что несколько пул-аллокаторов на один тот же пул указывают, да?
Да, ну да. Нет, сейчас, при чем тут вектор? Почему нам не хватит одного большого пула?
Потому что у тебя может быть, ну как, смотри, например, в одном пуле ты хочешь выделять только
по одному байту всегда, а в другом по 5 байт всегда. Ну, например, тебе нужно поддерживать там
большие хранилища объектов разного типа. Вот в одном пуле ты точно знаешь, что у тебя будет
постоянно выделение памяти по, не знаю, по 10 байт, а в другом всегда по 25 байт. Так вот,
вот у тебя и два пула получилось. А, ты хочешь сказать пул-аллокатор от шаблонного параметра N?
В смысле, ты хочешь сделать пул-аллокатор от размера? Так тоже можно. Нет, ты сказал,
сейчас давай сделаем, шаблонизируем пул. Параметром T и все. Что такое T? Какая разница тебе,
какой тип тебе, размер лишь важен. Вот N шаблонного параметра тогда, а не от T. Размер не в смысле
количество байтов, а в смысле размер блока, который мы собираемся выделять. Да, 10 или 25, да. Вот N, он, да.
Ну, слушай, я не очень понимаю, что тебя смущает. Ну, типа даже если у меня есть, хорошо, ну даже
если ты хочешь шаблонизировать пул и сказать, что у меня есть пул для 10 пул для 25 байтных кусков,
почему я не могу захотеть два разных пула для 25 байтных кусков? Ну, то есть у меня там есть, не знаю.
Как вы поймете, что это что нужно? Все что угодно можно написать. Можно написать с 2000 кубов.
Как я отличу ситуацию, когда мне нужен второй пул от ситуации, когда…
Ну, это какой-то очень общий вопрос, я не знаю, как на него ответить. Ну, кажется, что это должно
быть понятно из контекста, когда тебе нужно новый, лучше новый пул завести, когда лучше старый
доиспользовать. Это зависит от того, какой у тебя алгоритм управления памяти в этом пуле, например.
Например, у тебя пул может быть таким, что ты вообще не освобождаешь, когда ты просто на Нью
ты сдвигаешь право указатель, а на дилит ты ничего не делаешь. И ты просто пул заполняешь,
зная, что он не привыкнет 100 тысяч никогда, а потом грохаешь, когда закончил он пользоваться.
Когда тебе нужно, ты создаешь новый пул. Да, не удаляющий дилит. Именно такое вам надо написать,
кстати. Вот, тебе такой пример устроит. То есть ты хочешь экономить время на вызовах New
дилит. Ты делаешь этот пул таким, что ты просто как стэк его используешь. Ты выделил пул на миллион
или миллиард и просто не освобождаешь никогда. Когда тебе говорят New, ты такой хоп, сдвинул на
один. Когда дилит, ничего не делаешь. И когда у тебя все заканчивается, используешь, просто грохаешь
весь пул. Очень быстро, очень эффективно. Потом ты в какой-то момент заводишь новый пул и еще раз его
переиспользуешь. Пожалуйста. Два пула тебе нужного, одного и того же типа. Так, давайте я закончу то,
что хотел рассказать здесь, потому что сейчас мы начинаем здесь дебри, который вообще уже немножечко
не по порядку. Ну вот, пул и локатор. Вот, а вот еще пример локатора очень интересный. Ну, что такое
пул? Ну, это такой большой-большой массив, ну или указательно большой массив, динамический. И, ну скажем,
еще дополнительно к нему какой-нибудь там вектор, ну или какая угодно структура, которая описывает
состояние пула. Может быть, это просто одно число, если ваш пул просто описывается местом последней
локации. Ну, например, да, хорошо. Ну, я не хочу думать. Да, вот стеклокатор еще. Знаете, что такое
стеклокатор? Вот смотрите, вот вы, я вам тут в самом начале говорил, что вот вы когда стринг
заводите или вектор, у вас может даже и не быть такой ситуации, что вам не хватает стека, но все
равно будет обращение к динамической памяти. А что если я точно знаю, что мой вектор, он не
превзойдет, скажем, 100 тысяч элементов? И мне надо очень быстро, чтобы этот вектор работал. Я не хочу
вызывать нью. Я не хочу делать реаллокации, я не хочу делать вот это все. Я хочу просто сделать
вектор на стеке. Резерв мне сделает обращение к нью, а я хочу вектор на стеке, чтобы не обращаться
к нью. Да, я хочу, чтобы это все было, вот как мне сделать, чтобы контейнер хранился на стеке. Ну ладно,
вектор. Вектор не очень хороший пример. Вектор действительно один раз к нью можно сделать резерв
и все. А давайте лист возьмем. Вот если я использую лист, стд-лист, на каждый пушбек там создается
новый, там происходит новый вызов нью. И я никак не могу листу сказать резерв на 100 тысяч, правда же?
Потому что так написано в стандарте. Ну нет, ну в смысле лист не приспособлен для этого. Для этого
тебе нужно вообще пересмотреть свое отношение, свое понимание листа. Да, как раз аллокатор
позволит это сделать. Как раз мы за счет того, что мы добавляем новый уровень абстракции, это аллокатор,
мы теперь и лист можем сделать на стеке. Потому что с вектором это не так актуально, там действительно
всего один вызов нью можно сделать, и один вызов дилит, если резерв написать. А вот с листом это очень
даже актуально. Потому что стандартный лист, он работает медленно, там константа большая. Почему?
Как раз потому что на каждый пушбек, у вас хоть оно и зовут единицы, но это каждый пушбек, это вызов
нью новый. А это, в свою очередь, обращение к операционке, что-то там какое-то дело нет. Так почему вам,
например, если вы знаете, что у вас лист будет всего на 100 тысяч интов, скажем, вы понимаете,
что это точно уместится в 8 мегабайт стека вашего. Так давайте сделаем лист на стеке, и никакого
нью, и вся память у вас просто вот тут прям вот в шаговой доступности. Тогда вам можно написать
стек-аллокатор. Как добиться этого? Давайте напишем такой аллокатор, который будет, вот как сделать
стек-аллокатор? Как мне сделать, чтобы лист на стеке выделялся? Да, я просто заведу локальный
массив, то есть я в полях буду хранить массив, не динамический, а статистический, ну обычный массив.
В полях кого? Хороший вопрос. Ну, очевидно, не самого аллокатора, потому что тогда у меня опять будет
проблема, как его копировать. Если я напишу лист 1 равно лист 2, мне нужно просто завести класс,
который я назову storage, и он будет некопируемым, но он не будет синглтоном, потому что я могу
создать несколько стек-стораджей разных, но скопировать будет нельзя. Можно будет создать новый,
это будет происходить тогда, когда я хочу создать новое семейство, скажем так, стек-аллокаторов.
Вот копирование присваивания будет запрещено, в нем будет один массив в полях хранится огромный,
там на миллион чаров, а эти, ну он допустим будет шаблонизирован параметром n, вот сколько там
байт, скажем. А эти аллокаторы, когда я создаю новый стек-аллокатор, они такие, окей, если это новый
аллокатор, то я заведу новый стек-сторадж, а если я копируюсь от старого аллокатора, то я, скажем,
буду разделять с ним тот же самый стек-сторадж. Пожалуйста, и все. Ну а дальше allocate,
ну как-то сделайте здесь. Например, простейший, тупейший пример, как я сказал, вы просто на allocate
сдвигаете pointer здесь, а на allocate ничего не делаете. Таким образом вы максимально эффективно
управляете памятью в предположении, что вы никогда не превзойдете суммарный качество памяти,
используя вот такой констант. Вот. Ну и вот. Отличный вопрос, можно и новый создавать.
Так тоже можно. Это зависит от твоих намерений. Можно делать указательно тот же, можно новый
создавать. В STL есть средства, позволяющие правильно… Неважно, сейчас увидите, что там есть. Окей. Все
по идее. Я рассказал про аллокатор, про то, какие в принципе могут быть нестандартные аллокаторы.
Теперь давайте поговорим про аллокатор trades. Наверное, это будет короткий пункт. Вот смотрите.
Слушайте, нет, я передумал. Давайте не так сделаем. Давайте сначала поговорим про
аллокатор aware containers. Мне кажется, это более важно обсудить. Аллокатор aware containers. Так,
что такое… Вот есть аллокаторы. Теперь надо подумать, как правильно использовать аллокаторы
в разных контейнерах. Какие тут есть проблемы? Вот сейчас как раз давайте обсудим, во-первых,
как правильно копировать аллокаторы. Первый вопрос. Когда копируется вектор, скажем, нужно ли
копировать аллокатор? Или нужно просто создать новый инстанс, аллокатор такого же типа? Да,
вопрос на понимание. Вы же понимаете, что вектор от T, STD-аллокатор и вектор от T,
pull-аллокатор. Вопрос не стоит о том, как одному другое прислоить. Потому что это не CE, это разные
типы. Ну а что вы хотели? Ну вот как раз для этого и придумали polymorphic allocator tag,
если что, чтобы векторы от разных аллокаторов не были несовместимыми типами. BDS-STL. Но пока это
разные типы для нас. То есть, если у вас контейнер типа аллокатора, это разные типы контейнера,
вы не можете один другому присвоить. Поэтому мы не задаемся вопросом, что делать, если у нас
вопрос CE будет. А вот если у нас есть вектор от T и какой-то аллокатор, и мы хотим пронициализировать
его вектором от такого же T, но другого, такого же аллокатора, то есть тип такой же, но объект
аллокатора там уже какой-то есть другой. Есть два варианта. Вот кто, ты да, говорил или кто-то из
вас говорил, что можно пронициализировать аллокатор копией того аллокатора, наш аллокатор,
а можно проинitiциализировать аллокатор новым аллокатором такого типа как там.
Да, но есть еще более, короче, в STL все еще несколько хитрее.
Можно в аллокаторе, в реализации самого аллокатора указать, что должен делать
контейнер, когда копируется аллокатор. Вот, и для этого в аллокаторе можно определить метод,
который называется SELECT ON CONTAINER COPY CONSTRUCTION.
SELECT ON CONTAINER COPY CONSTRUCTION.
Ну, в зависимости от того, какой у вас аллокатор, вы можете хотеть, чтобы вектор при копировании
себя либо копировал аллокатор, либо создавал новый. Нет, почему? Новый аллокатор – это считайте,
вы новый пул завели и все отдельно работает. Нет, аллокатор об этом не забудь. Новый аллокатор – это
с чистого листа все пул начался строить. А вот дальше уже, когда сам вектор будет
непосредственно копировать, поле аллокатор, чем-то надо проинциализировать. Мы проинциализировали
не копии того аллокатора, а новым таким же аллокатором. А дальше началось, собственно,
поэлементное копирование вектора. А оно из себя представляет поэлементный allocate и construct.
Но вот этот аллокатор новый уже будет делать allocate-construct на новом пуле тех элементов
вектора, который он себя начнет копировать. В общем, честно говоря, выглядит как-то стрёмно.
Я даже не могу сходу сказать, чем это плохо, но просто, не знаю, какое-то вот житейское чутье
подсказывает, что так лучше не делать. То есть ты хочешь оператору присваивания дать какую-то
нестандартную семантику. Хорошо, давайте я вам задам такой вопрос. Ничего она не принимает,
возвращает аллокатор. Ну, она либо возвращает этот аллокатор, то есть тут варианты какие,
вы можете написать либо return this, либо return, пустой просто аллок, без параметров,
ну или с какими-то там параметрами. Внутри аллокатора, да, это метод аллокатора,
который может у него быть, а может и не быть. Как и construct и destroy, они могут как присутствовать,
так и отсутствовать в аллокаторе. Вот в ваших аллокаторах вам не надо будет, скорее всего,
определять construct и destroy. Ну да ладно, следующий вопрос. Вот смотрите,
аллокаторы иногда можно сравнивать на равенство.
А вот зачем. Потому что контейнер, когда копируется, он как раз проверяет, равны ли
аллокаторы. Дело в том, что если аллокаторы уже равны, то не надо копировать и новый создать
тоже не надо. Нет, ну хорошо, если там selected-container, copy-construction возвращает новый аллокатор,
то нужно все равно создать новый аллокатор. Но если selected-container, copy-construction возвращает
тот же самый аллокатор, возвращает аллокатор, равный тому, а наш аллокатор уже равен тому,
то кажется, что наш аллокатор можно не копировать. Ну тебе не обязательно копировать аллокатор,
если твой аллокатор уже равен тому. Ты копируешь контейнер. Если твой аллокатор уже равен тому
аллокатору, ты присваиваешь. Надо ли тебе подменить аллокатор, вот вопрос. Да, виноват.
Когда вы конструируете новый вектор из другого вектора, этот вопрос не стоит. У вас есть функция
container-copy-construction, которая говорит вам новый аллокатор создать или тот, который вы используете.
Допустим, вы присваиваете один вектор другому, и вам нужно решить, вам нужно подменять ваш
аллокатор на тот или не нужно. Как вам это понять? А вам можно проверить, а равны ли эти аллокаторы
уже или нет? То есть у аллокаторов вообще должен быть оператор равно-равной еще, чтобы контейнер,
контейнеру иногда нужно понимать, равны ли аллокаторы. А что вообще, ну например, когда они равны как раз,
а что значит, что они равны? Это вот что такое для аллокаторов? Все стандартные аллокаторы равны,
но некоторые более равны, чем другие. Да, правильно. Вот это как раз важная мысль. Давайте назовем наши
аллокаторы равными, если как раз они общий пул разделяют. То есть если у нас, что значит, что наш
аллокатор равен какому-то другому аллокатору? Это значит, что можно, вообще говоря, ну, наверное,
можно даже не в терминах контейнеров. Вы же можете, не обязательно внутри контейнера это делать. Вы
просто можете, ну е-мое, вы можете какую-нибудь функцию написать свою, которая с аллокатором работает
без контейнера, без всякого. Вот вы передали аллокатор функцию, и там, я не знаю, что-то поделали,
создали новый локальный аллокатор из того, ну и так далее. Вы иногда хотите понять, вот этот аллокатор
это то же самое, что другой аллокатор или нет? А что означает то же самое? А это означает, что то,
что было выделено первым аллокатором, можно освободить вторым аллокатором. Вот что это означает на
самом деле. Вот эта важная мысль. Надо понять это, два аллокатора считаются равными, если то, что
выделено одним из них, можно освободить другим. Это как раз в наших терминах означает, что они общий
пул, например, разделяют. Два аллокатора равными считаются, если то, что выделено одним из них,
можно освободить с помощью другого из них нет если как раз они могут быть вот
астд локаторы всегда равны друг другу что кто не делает пределите они делают
что-то они не вызывают дилет честный они не освобождают править с мыслью что ее нельзя
будет еще раз занять как это называется локатор который ничего не делает
пределить вот всего ничего прямого ничего может например счетчик плюс один сделать
ну нет пул локатор это не тот который ничего делать при удалении это тот
который большой пул заводит им распоряжается стека локатор это ну наверное
можно сказать что частный случай пул локатора когда у вас пул на стеке вот
пул локатор не название пул локатор ничего не говорит о том какой у вас
алгоритм менеджмента памяти тул просто говорит о том что вы большим
полом распоряжаетесь вы можете как ничего не делать пределите и тогда
возможно и правда у вас все локаторы можно считать равными я не уверен может
есть кое-что случая который меня забыло может лучше все-таки так не делать но
логично их все-таки не считать равными если там пулы разные ну просто по логике
вещей вот но возможно если у вас что-то делается там какая-то машинеть и
происходит, когда вы освобождаете, то, конечно, нужно считать их неравными, если на разные полы указывают.
Любому другому аллокатору такого же типа. Нет, нельзя сравнивать аллокаторы разных типов.
Неопределенная операция.
Конечно. Нет, ты можешь сравнить аллокатор, ты можешь сравнить std аллокатор от t и std аллокатор от u,
вот так, скорее всего, можно сделать.
Нет, я думаю, вы получите true, но это это неважно.
Вы можете, наверное, если у вас аллокаторы одинаковые, но разных шаблон-типов, тут еще можно как-то, если у вас std аллокатор и std аллокатор,
то их нельзя сравнивать просто потому, что это разные типы.
Нет, ну, может быть, можно определить оператор сравнений так, что они будут...
Может быть, можно определить оператор сравнений для них так, чтобы они были разными, но я не знаю, кто в здравом уме должен
захотеть сравнивать аллокаторы разных типов. Это, кажется, просто должна быть неопределенная операция.
Но если вы сравните два аллокатора одного типа, например, два стека аллокатора, то как раз вот их сравнение, должны говорить, это у вас
один и тот же пул или нет.
Это должно быть, просто логично.
Ну, это логично, да.
Зачем сравните аллокаторы?
Когда мы копируем вектор, мы хотим избежать как-то от любого копирования, если они уже равны.
Если аллокаторы равны.
Если два аллокатора пользуются одним и тем же аллокатором, то нет смысла копировать.
Это лучше идея, когда у нас лист все-таки...
Но все равно, если мы скажем, вектор A равен вектор B,
аллокатор будет составиться таким же, то есть надо его посмотреть.
Но все равно элементы копируются.
Да.
Сейчас, а нам же лучше предоставить контейнер, как контракт называть, или не придется?
Нет, при присваивании не придется.
А если он говорит, что мы всегда...
В смысле, не придется?
Это только констракшн.
Да, точно.
Это когда мы создаем контейнер копированием другого контейнера.
Когда мы говорим, новый вектор равно старый вектор, создаем новый вектор.
Нам нужно решить, для нового вектора позаимствовать аллокатор из того вектора или создать новый.
Вот эта функция у аллокатора помогает понять, что из этого делать.
Если она есть, то он вызовет ее.
А если ее нет, то он стандартным способом себя поведет и скопирует аллокатор.
А вот когда мы присваиваем вектор другому, и пусть мы поняли, что это неравный, мы все равно туда поделимся, как контейнер.
Кто? Аллокаторы неравны?
Нет, если аллокаторы неравны, то мы такого не вызовем.
Нет, мы скопируем аллокаторы, я думаю.
При присваивании.
При присваивании.
Это не совсем правда, потому что есть еще одна функция.
Правда, она уже не у аллокатора.
Есть такая функция, пропагейтон контейнер копи ассайнмент.
Сейчас я расскажу.
Но не в этом пункте.
Пока давайте считать, что при присваивании контейнеров мы всегда копируем аллокаторы, если только у них аллокаторы неравны уже.
У меня есть еще один важный вопрос.
Смотрите, мы с вами пишем лист на аллокаторе.
А, да, я забыл сказать, что такое аллокаторы веер контейнерства.
Аллокаторы веер контейнер – это такой контейнер, который правильно использует все эти методы аллокатора.
Это контейнер, заботящийся об аллокаторе, уважающий аллокатор.
Если контейнер считается аллокатором веер, все стандартные контейнеры, разумеется, такие.
Если они не просто тупо копируют аллокатор, а смотрят на соответствующие методы аллокатора,
на соответствующие свойства аллокатора, и либо копируют его, либо не копируют, в зависимости от того, что там написано.
Вы можете открыть на CVP Reference статью, если бы у меня был проектор, я бы вам сейчас открыл ее и мы бы на нее посмотрели.
Вы можете открыть статью C++NamedRequirements Allocator-Aware-Container.
И там написано, какие требования накладываются на контейнер, чтобы он считался Allocator-Aware-Container.
Разумеется, как раз главная суть вашей задачи и будет заключаться в том, чтобы написать Allocator-Aware-Container, да еще и который бы правильно работал с вашим аллокатором.
Ровность до аллокатора готова.
Нет, в смысле равн...
Значит, в чем будет заключаться ваша задача первая?
У вас будет задача написать лист и стек аллокатор.
При этом как лист должен быть совместим с любым аллокатором правильно написанным, то есть лист должен быть Allocator-Aware.
Я могу подсунуть туда любой корректный аллокатор, и все должно правильно работать.
Так и аллокатор должен быть STL совместим, то есть удовлетворять требованиям Allocator.
Кстати, Allocator это тоже понятие из C++NamedRequirements.
Там перечислено, что должен уметь аллокатор, чтобы считаться полноправным аллокатором.
То есть в тестах я буду делать следующие вещи.
Я буду брать стандартный контейнер с вашим аллокатором, разные стандартные контейнеры с вашим аллокатором, проверять, что все правильно,
А ещё я буду брать ваш контейнер с разными аллокаторами, с вашим.
Ну, с вашим и с стандартным, и возможно еще с каким нибудь.
И тоже проверять, что все правильно.
С South event-илист Harrison Ex inspect?
С давших прошлые годы, например.
Так вот, у меня к вам вопрос такой очень важный, о котором вы возможно сейчас не задумались, но вы неизбежно столкнетесь с этой проблемой, когда будете писать лист.
Смотрите, лист, он же тоже имеет такую… Ну, что такое лист? У него есть шаблонные параметры.
TypeName t, TypeName alloc, я не полюнюсь даже еще раз написать, равно std allocator, пока я пишу, вы возможно уже сейчас заподозрите подвох, проблему.
std allocator от t. Класс, лист. Вас ничего не смущает здесь? Вот в этом вот месте вас ничего не смущает.
А как вы будете в листе пользоваться allocator? Нет, минуточку. А как лист устроен, напомните? Там нужно node, да. А как вы будете node выделять?
У вас же allocator от t, а не от node. А про node пользователи ничего не знают, он вам передает allocator от t.
Значит, на самом деле лист хранит в себе allocator тоже как поле, но не такого типа. Да, он должен создать allocator, но не такой. А он должен создать allocator как этот, но не от t, а от того, чему надо.
И вот это, скажем так, еще одна из причин, по которым комитет понял, что что-то пошло не так, когда вот это случилось.
А можно написать aloc равно st allocator, а потом aloc и фигурка с кубочек от чего-то создать? Что, где написать что? А, в смысле сделать aloc шаблонным-шаблонным параметром?
В смысле aloc равно st allocator около st или как? Ну, то есть ты хочешь делать aloc шаблонным параметром, который сам шаблон. То есть ты хочешь написать typename t, запитать template с кубочках typename aloc равно st allocator.
Да, это очень классный вопрос на самом деле. Это вообще очень классный вопрос. Очень умный вопрос, и ответ на него нельзя, и вот нужно понять почему.
То есть это классная очень мысль, это гениальная мысль вообще. Ты молодец. Но нельзя, к сожалению. Это могло бы быть выходом из положения, но нет, это не работает.
Ты знаешь почему? Потому что тогда не получалось бы создавать aloc от большего чем один числа шаблонных параметров.
Ну, например, st allocator у него, наверное, должно быть два шаблонных параметра t, а еще n, который вот это вот n обозначает здесь.
Если у меня aloc принимает два шаблонных параметра, этот вопрос на stackoverflow я читал все время, потому что пару лет назад тоже я сам задумался, а почему бы так не сделать?
Ну вот нельзя, потому что тогда вы бы тем самым сразу запретили, у вас просто синтоксически бы получился template typename, фигурная угловая скобка закрылась, и вот это вот.
Оно бы позволяло вам передавать в качестве alocator в этот контейнер только alocators с одним шаблонным параметром, а если у вас был alocator с двумя шаблонным параметром, его бы сюда не отдали.
Впрочем, конечно, бывают же шаблоны с переменным количеством шаблонных аргументов, но тогда их еще не было.
А теперь уже все, это не переделали, и в общем оно так и осталось.
Казалось бы, действительно, это самое место применить, а лучше делать шаблонный параметр, но нет.
Так вот, так что я должен сделать здесь? Я должен здесь, давайте я сотру и здесь напишу, что я должен сделать полем моего листа.
Я должен какой-то магией своим полем сделать не вот этот вот aloc, а alocator такого же типа как этот, но с другим подставленным типом t, node вместо.
То есть у меня есть внутренняя структура node, тут вот что-то в ней есть.
Как мне сказать, как мне объявить alocator? Ну, тут ничего лучше нельзя предложить, просто у alocator еще есть метод, должен быть, метод, точнее meta-метод rebind.
Значит alocator предоставляет такую метафункцию rebind.
Значит внутри alocator, внутри alocator вот тут, вот тут вот еще есть template type name struct rebind,
в которой написано using other равно, ну да, std alocator от u.
И на самом деле в листе написано примерно следующее, тут написано using, а node aloc равно type name, потому что у нас dependent name сейчас будет,
aloc rebind от u, rebind от node other и заводим мы здесь node aloc, node aloc мы храним.
Разумеется. Вот, а теперь, отвечая на все эти вопросы, я как раз последний, видимо, пункт, который мы сегодня успеем следить, это 9.3, как раз вот теперь я расскажу, что такое alocator traits.
Как вы могли заметить, мы уже много всего напридумывали методов alocator, в том числе meta-методов, которые, к чему это, как будто что-то плохое, это норма, привыкай к этому.
Ну, не хочешь, заставим. Значит, ладно, alocator traits. Что такое alocator traits? Вы, наверное, можете догадаться по аналогии с итератор traits.
Это такая структура, которая доопределяет за alocator все то, что он забыл или не захотел определять сам.
В частности, construct, destroy, rebind, select-on-container, copy-construction, еще много чего. Это работает также как итератор traits.
То есть на самом деле методы construct, destroy, вот эту вот структуру rebind можно не реализовывать в своем alocator, потому что alocator traits за вас доопределит.
Вот так. Что? construct, да, определит вот именно так. rebind определит именно так, только здесь вместо std alocator будет ваш alocator написан.
Что именно сделает? Так он же с шаблонным параметром alocator, как и итератор traits, с шаблонным параметром итератор.
Значит, есть такая структура std alocator traits, объект этой структуры никогда не создается, и все, что в ней есть, это много разных юзингов.
Ну нет, хорошо, неправда, в ней есть много юзингов, а еще много методов, но это все статические методы.
Например, в ней есть метод construct. Он выглядит так, template, type name, многоточие args, void construct, static void, уже он статический, потому что объекты alocator traits не создаются никогда.
Статик void construct. И он принимает, а что он принимает? Он принимает alocator, а еще аргументы, ну ptr и аргументы.
Ну вот здесь мы принимаем только ptr и аргументы, а в traits мы должны принимать alocator, ptr и аргументы. Причем alocator мы принимаем как? По ссылке, по константной или нет? Нет, не по константной, потому что alocator вообще говоря мог бы поменяться от того, что вызвали construct.
Вот aloc, t, звездочка, ptr. Правильный вопрос. Сейчас скажу, что такое t звездочка. t звездочка на самом деле это type name aloc, . . . value type. А вот value type уже обязан быть определен.
Значит в alocator еще должен быть, я вижу вот выражение лица. Звездочка, ptr.
Ну, Андрей Михайлович ждет вас на кафедре DM в таком случае. Вы думали, а вы думали, зачем я тут работаю? Я сам кафедру DM заканчиваю между прочим. Тайная агента на самом деле. Я же говорил, я же вам в самом начале совместно сказал, в чем цель этого курса. Вы еще не до конца поняли, сейчас поймете до конца.
Вот так. Что делает этот метод? А что он делать должен? Что делает эта функция?
Она должна понять, есть ли у alocator то, что она знает. Точно. Значит здесь нужно написать следующее. Надо написать, если у alocator есть метод construct с такими вот параметрами, то вызвать его, а иначе сделать вот это.
Как мы пишем их? Авто-авто-авто компилятор сам догадается. Вот. Ну как это реализовать мы пока не понимаем и поймем мы это ближе к концу семестра, когда изучим шаблонный метод программирования чуть поглубже.
Да-да-да. Ну там проверка по сочетанию метода. Ну то есть вот здесь фактически написано именно это. Тут на шаблонах написано проверка существует ли метод у такого-то класса с такими-то аргументами.
Точно так же как и в Iterator Trades. Iterator Trades определяет за вас категории итератора в зависимости от того, какие методы у вас определены, от каких типов. То же самое здесь.
Но Iterator Trades гораздо сложнее, чем здесь. Здесь просто один if условно, говоря, надо написать. Как его написать мы пока не понимаем. Сейчас я вам этого не расскажу, но потом мы скоро мы поймем когда-то.
Вот пока вот тут вот написана какая-то магия, которая вызывает construct у allocator, если он есть, от нужных аргументов. Если нет, делает сама вот это.
Аналогично destroy. Она либо вызывает у allocator метод destroy, если он был, либо сама вызывает destructor t. Дальше, что делает destructor t еще не всегда надо вызывать, потому что value type может быть не классом, а int.
И вызвать destructor int будет ce. Поэтому нужно еще сделать дополнительно проверку, а классовый или тип, тот t, который у нас.
Вот. Дальше. SelectionContainerCopyConstruction. То же самое. Она проверяет, есть ли у allocator метод SelectionContainerCopyConstruction. Если есть, то возвращает то, что он возвращает, а иначе просто возвращает allocator, который сюда дали в параметры без изменений.
А когда мы пишем какой-то контейнер, мы должны не вызывать метод construct?
Совершенно верно. Совершенно верно. И именно поэтому я вам говорил, когда писал здесь, что не совсем это там написано. Помните, когда я написал, что там было alloc.allocate, я сказал, ну там не совсем это, скоро поймем почему. Вот сейчас мы поняли почему.
Все методы, все методы вызываются через allocator trades.
Нет, нет, нет, нет. allocator trades, метод allocate у allocator trades просто вызывает метод allocate у allocator. Но в целях унификации считается правильным все методы вызывать через allocator trades.
Но в случае allocator trades без разницы, действительно. В случае allocate без разницы. Allocator обязан иметь метод allocate.
Allocator trades ничего не добавляет allocate, он просто, так сказать, прослойкой служит для его вызова. Но вот construct и destroy так явно не вызывают allocator.
Если вы их вызовете, вообще это будет CE, начиная с C++20. Потому что на самом деле этих методов уже нет в стандартном allocator, начиная с C++20. Вот этого всего нет в std allocator, начиная с C++20.
Они теперь allocator trades, потому что никто напрямую к allocator эти методы не вызывает.
Все так, все так.
Все правильно, да. Нет, ну скорее всего вы пишете using alloc trades равно std allocator trades от node alloc.
Вот, и да. Теперь, что вместо rebind? В allocator trades есть внутренняя структура, которая называется rebind alloc.
rebind alloc. Значит структура rebind alloc.
Почему это звали rebind?
Ну не знаю, почему-то вот...
Analyzer allocator trades.
Потому что Analyzer allocator trades, да. rebind alloc от U. Да, ну, template type name понятно тут.
И тут написано using...
Нет, на самом деле это не структура даже, извините. Вот как раз почему это не структура.
Потому что это using.
Это using rebind alloc.
Там U.
Это просто вот та самая вещь.
Ну как?
Так же.
Если в allocator есть rebind, то...
Ну тут шаблонная магия.
Типа в allocator есть rebind.
Ну тут типа std conditional, грубо говоря.
Если в allocator есть rebind и в нем есть other, то это он.
А иначе это вот этот allocator от U.
Ну просто вот этот allocator, от которого мы сейчас, allocator trades.
От U.
Вот.
Сейчас, почему один параметр?
Так, один параметр, другой тип.
Сейчас, не-не-не.
Ребайн alloc он где определяет?
А...
Возможно...
Он понимает alloc, значит он после alloc должен быть.
Он понимает...
Ты прав. Здесь должно быть U и еще arcs.
Что?
Но allocator может быть от многих параметров.
Потому что...
Первый из них это тип, а еще могут быть сколько угодно дополнительных параметров.
Уже с типом или шаблонный тип?
Или шаблонный allocator?
В смысле?
Я согласен с allocator.
Чего?
То есть allocator это alloc, alloc это что?
Alloc это, конечно, определенный allocator.
А как мы тогда...
Условно, я не знаю, развиваются тип и другой тип?
Шаблонные магии, друг!
Я не очень понял.
Что именно мы делаем?
Что мы там можем написать? Мы можем написать alloc?
А, я понял, да, я понял. Проблему.
Шаблонные магии, два этих принимают.
Два типа.
А он не может дать без подставы?
Но он может дать через arcs.
Ладно, передать ему типу allocator, который ты даешь, и тип, который ты создалешь allocator?
Нет.
Не можешь передать ему шаблонный allocator без шаблонных параметров?
Без подставных шаблонных параметров?
Да, слушайте, я не знаю.
Я не знаю, я забыл.
Я не помню.
Ну, короче, не знаю.
Ну, я не помню какие там параметры.
Да-да-да-да, allocator trades вот этого allocator.
Это да, это точно так.
А вот что в rebind-алог написано, я забыл, да.
Но, к сожалению, сейчас бы открылся.
Переференции мы бы посмотрели, но вот без проектора я так не могу сказать.
Ну, слушайте, вы посмотрите, откроете и используйте правильно.
Вот.
Еще там есть такие вещи.
Propagate on container, copy assignment.
Propagate on container, swap.
Propagate on container, move assignment.
Значит, это как раз...
Это usings.
Точнее, это не usings, это булевские константы просто.
Значит, есть булевская такая константа.
Propagate on container, copy assignment.
Propagate on container, copy assignment.
В allocator trades.
Вот allocator. Что она говорит?
Если она true, то это значит, что при присваивании одного контейнера другому с этим allocator нужно подменить allocator.
Если false, значит, не нужно.
Да?
Ну, присвоить один allocator к другому.
Надо присваивать allocator к allocator, когда ты контейнер присваиваешь или не нужно.
Или оставить то, что было, да.
Нет.
А allocator trades, да?
Да, allocator trades.
Что?
И по умолчанию...
Я вижу, я не понимаю.
Ну, по умолчанию, по-моему, true.
То есть, по умолчанию...
По умолчанию, я просто не знаю...
Ну, я не помню там...
Скажите, что там себе переференс написан, по умолчанию.
Я не понимаю.
Что это такое?
Просто открыла и ничего не понимаю.
Вот.
Так, что-то я еще забыл.
Важное, мне кажется, напоследок сказать.
Сейчас я подумаю.
Так, сейчас давайте я быстренько
открою список того,
что я должен был вам сегодня рассказать.
Да, точно.
Вот последнее, что я должен был вам рассказать.
Смотрите.
Да.
Значит, финалочка.
Смотрите. Возвращаясь к теме allocator
aware-container.
А...
Давайте еще раз вспомним.
Вот опять.
Мне нужен был бы проектор, нужно было открыть код pushback,
скажем, вектор.
Или... А.
Какого pushback?
Давайте вспомним, что такое
присваивание одного вектора другому.
Вот.
Как работает... Вот.
Нужно вообразить сейчас то, что у меня нет проектора.
Но вот давайте представим, что мы
сейчас исследуем тело метода
присваивания одного вектора другому.
И допустим, мы поняли,
что propagate-on-container-copy-assign
это true, то есть нужно присвоить один allocator
другому.
А что это значит? Это значит, что нам надо...
Ну, нам надо сначала на старом allocator
уничтожить все старые элементы.
Необязательно. Нет, необязательно.
Сказать пулу, что мы уничтожаем
один элемент.
Что значит сказать пулу?
Какому пулу?
Да, об этом сейчас и разговор.
У нас есть
что...
У нас есть какой-то allocator.
Да.
Произвольный allocator, разумеется, да.
У него есть методы construct,
destroy, allocate, allocate.
Ну, да.
Ну, то есть
я хочу сказать, что
мне неизбежно придется
сделать присваивание одного allocator
другому
уже после того,
как были уничтожены объекты
с старым allocator.
Даже если я создам локально
новый allocator
из старого allocator, потом я с старым
allocator уничтожу объекты, мне же нужно
в итоге мое-то поле сделать
нужному allocator как-то.
Что если оператор
присваивания allocator кидает исключение?
Выкинуть его дальше
и забыть про это, как страшная игра.
Я уже удалил объекты.
Векторист. Мне нравится, как люди
на лицо берутся.
Так, еще раз, смотрите.
Проблема. Я присваиваю
один vector другому vector'у.
И у меня разные allocator'ы.
И мне нужно propagating container copy assignment
сделать для allocator. То есть заменить allocator.
Но старые-то объекты
мне нужно удалить старым allocator. У меня в векторе лежали
какие-то объекты. Мне нужно их удалить
старым allocator'ом. Сделать
deallocate.
Потом заменить allocator, сделать
снова allocate и положить новые объекты.
Откуда вы возьмете новые объекты и удалили?
Новые объекты возьму из vector'а,
из которого я копируюсь.
Я присваиваю одному vector'у другой vector.
У меня в моем vector'е лежат какие-то объекты.
В моем vector'е лежат, там a1, так далее,
an. В другом b1, так далее, bn.
Вы поделяете память, потом перекладываете объекты.
Что значит перекладываю объекты?
Мне нужно создать объекты новым allocator'ом,
удалив их старым allocator.
Где я возьму новый allocator?
Как я его
создам?
Я создаю новый allocator.
Так, еще раз.
У меня есть... Ну вот проблема в том, что у меня
нету... У вас есть смартфон, который можно нарисовать,
стереть что-то уже.
Хорошо, давайте,
хорошо.
У меня есть мой allocator.
Вот я пишу...
Можно назвать только два vector'а и bn, чтобы было понятно,
а как он здесь?
Оператор равно...
Оператор равно...
От const
vector
t alloc
&other
Что я делаю здесь?
Понятно, там авто будет.
Нет, не будет так делать.
Короче, понятно, какой возвращаемый тип.
У меня в полях лежит allocator
и там t звездочка
array
cz, kp, st, все понятно.
Что я должен сделать, в первую очередь?
Ну, я должен проверить.
If allocator trades allocator
propagator, container, copy, assignment,
то вот это, допустим, я написал,
что это выполнено.
Что дальше я должен сделать?
Я могу идти обедать?
Нет, все, я сейчас уйду.
У меня просто вопросы задают, я не могу никак остановиться.
Что я должен сделать?
Люди жалуются, говорят, что хотят на DM
к райгору, они не могут больше
это терпеть.
Мне нужно сделать
destroy того, что у меня лежало в vector'е
старым allocator'ом
а потом
я никак не могу
старый allocator вот этот allocator
вот этим allocator
мне нужно сделать destroy всего того, что лежало
в vector'е и deallocate
а потом
ну или до этого
мне нужно создать
новый allocator
мне нужно вот это
поле подменить на тот allocator,
который тут был.
Да, я не могу
я никак не могу избежать присваивания
allocator'а после того, как я
освободил старый объект, потому что
даже если я скопирую
этот allocator, присвою
или могу, сейчас давайте подумаем, может
могу, если я
сначала создам новый allocator
из того allocator'а
а мы все равно потом присвоим
или сейчас теперь
с опытом копирования
хорошо, я могу, наверное, сначала
создать копию этого allocator'а
вот так. Я создаю копию
этого allocator'а
этому allocator'у присваиваю
тот allocator
на копии уничтожаю
весь pool и все объекты
как раз
потом
пока уничтожаю объекты
исключения не может быть. Это
новый accept штука. Потом
уничтожаю allocator
локальный копию
destroy всегда no accept
destroy уничтожение всегда no accept
а вот копирование не no accept. Уничтожаю
этот копию локального allocator'а
теперь у меня этот allocator
уже новый allocator
а теперь я выделяю новую память
и создаю новый объект
а что если тут будет исключение
если тут будет исключение, то мне надо
все вернуть обратно
и новый allocator вернуть обратно
то есть вернуть allocator как было
короче, в любом случае
как бы я не изгалялся с копированием allocator
у меня неизбежно возникнет ситуация
что мне нужно вернуть allocator как был
скопировать allocator обратно
или туда или обратно
а у меня уже исключение кидать нельзя
как же мне поддержать exception safety
с allocator'ами
если мне нужно в какой-то момент присвоить
одному allocator'у другой
и вот никак я не могу
на самом деле
в требованиях allocator
написано, что присваивание allocator
должно быть noexcept и все
ну то есть если вы
никак не получается
избежать, чтобы allocator
копировался с сохранением
безопасности исключения
просто по требованию allocator должен
копироваться без исключения и все
присваивание allocator
ну да, присваивание allocator и noexcept
ну возможно не все там
копии или мув присваивания, какой-то из них
все на этом
