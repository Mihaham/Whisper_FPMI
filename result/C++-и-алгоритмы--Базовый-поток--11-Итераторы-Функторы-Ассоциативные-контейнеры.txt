Всем добрый день, давайте начнем. Сегодня последний раз, когда мы встречаемся для разговора о C++,
дальше будут только алгоритмы, но тем осталось, мягко скажем, немало, поэтому давайте постараемся
успеть разобрать все то, что было запланировано. Мы в прошлый раз остановились на том, что начали
обсуждать итераторы, и кое-что, отсюда мы уже даже успели обсудить. Кажется, остановились
здесь. Вкратце напомним, что у нас есть итератор, и итератор представляет собой
некоторый общ ada интерфейс указателя. Мы с контейнерами можем работать через так
называемые итераторы, и итераторы представляют интерфейс, который похож на интерфейс указателя,
то есть их можно инкрементировать, некоторые можно декрементировать,
можно разуменовывать, получать значения и так далее.
В частности, итератор – это единственный способ получения элементов связанного списка.
Понятное дело, что мы не имеем доступа к внутренней реализации списка,
то есть мы не можем взять ноду, сказать ей next, next, next или prev, проходиться в право-лево.
Мы можем взять итератор внутрь списка и с помощью него бегать туда-обратно.
Ну и собственно все алгоритмы стандартной биб pureтеche
так или иначе работают с итераторами, то есть с абстракцией итератора.
Алгоритмы стандартной биб pureteche, они не подразумевают того,
что вы туда будете передавать контейнер, они подразумевают,
что вы туда будете передавать итератор, ну скажем, в данном примере,
если вы хотите отсортировать иектор, то вы передаете итератор
на началоبة, и speculate, и итератор наконец, vend,
вот и соответственно этот диапазон будет сортироваться.
Более того, итераторы помогают нам с тем, что таким образом
ну и скажем его часть. Мы можем взять какую-то середину вектора, передать
итератор на какой-то центральный элемент, передать итератор на другой элемент
и отсортировать небольшой диапазон внутри целого контейнера.
И как правило, итераторы реализуются непосредственно для каждого контейнера,
потому что каждый итератор должен понимать, как устроен внутри контейнера.
Условно итератор вектора понимает, что он бегает по непрерывному участку памяти.
Итератор в списку понимает, что он указывает на конкретный узел, и в своей операции плюс-плюс
он должен перейти к следующему узлу, а не увеличиться на ячейку памяти.
Поэтому каждый контейнер реализует свой итератор, и этот тип можно получить
с помощью разрешения области видимости, например, стадивектор Invo и точку.
