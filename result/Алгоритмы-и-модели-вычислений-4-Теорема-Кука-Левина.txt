Ладно, дать начнем, обсудим, наверное, полные задачи.
Ну, поскольку лекция была две недели назад, то я вкратце напомню, что мы там изучали.
Значит, надо было понять параллельно сводимость.
Значит, А параллельно сводится к Б, если существует параллельно вычислимая f, такая,
что x принадлежит А тогда только f от x принадлежит B. Вот, начинал понятие NP-трудность.
Значит, NP-трудность означает, что для любого А из NP А сводится к B. Значит, тогда B будет NP-трудная.
Вот, и был понятие NP-полноты. NP-полнота это будет NP-трудность плюс равнесть к NP.
Значит, мы дальше изучали свойства, что полинарная сводимость транзитивна.
Если мы что-то сводим к языку из P, то у нас получается язык из P. Если что-то к языку из NP, то получается язык из NP.
Ну и, соответственно, если мы NP-полную задачу куда-нибудь сводим и то, куда мы свили тоже в NP, то будет тоже NP-полная задача.
То есть, основной инструмент, это такое утверждение, что если А NP-полная, и А полинарная сводится к B, и B из NP, то тогда B получается NP-полная.
Вот, хорошо. Дальше мы обсуждали конкретные задачи.
Ну, значит, была задача SAT. Сат от слова it's viable, it's stability problem.
Значит, это множество таких phi, где-то были его формулы, и существует x такое, что phi от x равно 1.
Значит, вот это вот SAT. И дальше был... есть еще, в частном случае, 3 SAT. 3 SAT это, в общем, аналогично.
Да, только phi это формулы формат 3 KNN. Значит, phi 3 KNN такое, что существует x, что phi от x равно 1.
Дальше, там еще была пара примеров, как мы сводили 3 раз краску и задачу о клике SAT.
Ну, еще есть общая конструкция, как можно свести SAT к 3 SAT. Этого вроде же не обсуждали, да?
Хорошо. Ну, идея такая. Смотрите, как вообще устроена формула. Есть какие-то базовые переменные, и дальше они как-то друг с другом комбинируются.
Дальше комбинации как-то еще комбинируются, и каждый раз есть какая-то базовая операция, которая комбинирует какие-то уже созданные формулы.
Ну, идея стоит в том, что для каждой такой подформулы нужно ввести свою переменную и записать условие, что там все правильно подсчитывается.
Кстати, я на примере покажу. Пусть у нас формула phi. Ну, он примерно имеет такой вид. Пусть будет вот f или q, и, скажем неверно, то r влечет s.
Значит, ну, вот это такая. Тут, конечно, задача выполнима стрибиально, но я хочу на этом примере показать, как мы, собственно, к 3 KNF переходим.
Значит, ну, идея следующая. Значит, что мы для каждой подформулы заводим свою переменную.
Значит, например, вот так вот. Знаете, что x это дизюмца по a или q, v это импликация, w отрицание, а x уже вся форма вместе.
И тогда получается, что и выполнима, и выполнима тогда и только тогда, когда совместно вот такая система.
Значит, u равно p или q, v равно r влечет s, w равно не v, и x равно u и w. Еще x отдельно.
Значит, когда вот у такой системы есть решение, когда такая система тоже выполнима.
Сейчас пока еще не 3 KNF, давайте обсудим, почему вот эта часть верна.
Ну, смотрите, что значит, что phi выполнима. Значит, есть выполняющий набор, то есть такие были вы значения, что вся форма истина.
Тогда, соответственно, для каждой вот этой вот новой буквы можно посчитать, чему она будет равна.
И при этом вот этот x итоговый будет равен единицам.
Ну, тогда если мы эти значения вот сюда подставим, то соответственно они все будут верны.
И в итоге, поскольку их все равно единицам, то это тоже будет верно.
Вот. Ну, от другой стороны, если форма не выполнима, то есть там какие значения поставить всегда будет 0, то и сюда тоже.
Значит, либо какой-то из этих равенц неправильно посчитано, либо они все посчитаны правильно, тогда тут будет 0.
И тогда они все сразу выполнены быть не могут.
Ну, а дальше, дальше, на самом деле, вот эта вот система, система это и означает конъюнцы вот этих всех условий.
Вот. А 3kNF получается, потому что можно просто каждую вот эту вот форму привести к формату 3kNF.
Например, значит, u равно p или q.
Ну, можно, в принципе, абстрактно сказать, что, ну, это же тоже, ну, здесь вот эта вот равенство понимается как эквиваленция.
У нас, соответственно, можно сказать, что вот это вот все вместе, как выражение, истинное или ложное, это функция трех болевых переменных.
Ну, а любую болевую форму, любую болевую функцию можно привести к 3kNF.
Ну, в смысле, просто кkNF. Вот. Ну, поскольку здесь всего 3 переменных, то это получается 3kNF.
Вот. Можно так абстрактно сказать, а может прям конкретно написать.
Тут, наверное, вот так вот будет, значит, u или...
Наверное, вот так вот, u или не p.
Это значит, что если p, ну, такая вот конструкция, это же импликация, что из p следует u.
То есть, если p верно, тогда здесь у нас тоже верно.
Второй вариант это u или не q.
И третий вариант это не u или p или q.
Ну, он, собственно, означает, что, на самом деле, вот это означает, что из u следует p или q.
А вот эти вот две штуки означают, что из p следует u и из q следует u.
Вот.
Ну, вот.
Обязательно, вот это вот 3kNF получается.
Ну и со всеми остальными функции точно так же, да, можно поупражняться, какие именно формы будут получаться.
Так.
Какие-нибудь вопросы?
Хороший вопрос. Да, вот и правильный вопрос. Почему это переномеально?
Ну, это, на самом деле, вопрос про то, почему существуют синтезические разборы, почему он быстро делается.
Ну, я не буду вдаваться в детали, но в целом, это содержание каких-то курсов по синтезическому разбору математических выражений или программ.
Да, в общем, там это делается. Ну, можно прямо попробовать программу написать, да, что, ну, тут какая-то баланс с кубок.
Да, мы идем, вот эта кубка открылась, дальше мы рекурсивно этот разбор применяем, пока эта кубка не закроется, и это у нас будет там первая часть.
То есть, на самом деле, нужно что сделать? Нужно вот из формулы сделать дерево, а потом из дерева написать эти все равенства, ну, а потом из равенства сделать уже КНН.
Ну, третья часть вполне совсем понятна, да, потому что мы просто, ну, мы просто как бы говорим, что тут вот небольшое число функций, мы их переделываем вот так вот.
Третья часть совсем понятна, по дереву более-менее тоже понятна, что мы дерево обходим вверх-вниз, слева-направо, и в каждой нетерминальной вершине пишем такое равенство.
И плюс добавляем еще отдельного для, ну, для корня.
Ну, а как строить дерево, ну, это по идее учит там в каких-то курсах по структурам данных там или чего-нибудь.
Ну, и главное, там это по идее, это даже можно делать в один проход по формуле, что мы как бы идем, идем слева-направо по формуле и постепенно также слева-направо строим дерево.
Ну, а в один проход это уж точно быстро.
И нет, а потом, ну, можно вот эту систему заменить на конъюнцию всех вот таких вот подформул, и получится одна большая форма.
Ну, может просто проверить.
Вот во нет, логика тут такая, что вот в этой скобке логический смысл, что из u следует p или q.
Да, вот эту вот равенство означает, если в одну сторону и в другую.
То есть, вот это значит что из u следует p или q, это значит, что из p следует u и это значит, что из q следует u.
Но, соответственно, из p или q тоже следует u.
Ну, если нужно, чтобы в каждой скобке было ровно три, то это можно сделать за счет каких-то дополнительных переменных.
Тут можно дописать или Q, или не Q, а здесь или P, а или не P уже получилось.
Так будет больше скобок, но и из трех.
Смотрите, если два KNF, два SAT уже будут лежать в P.
А если больше трех, то, конечно, тоже будет NP полное.
В некоторых приложениях будет важно, что именно три в каждой скобке, а не то, что не больше трех.
Давайте обсудим, почему два SAT лежат в P. Это нам все равно потом пригодится, и довольно красиво по себе.
Смотрите, если у нас есть какая-то кобка с двумя литералами, то она, на самом деле, равносильна двум импликациям.
Это равносильно тому, что из не P следует Q, и также это равносильно тому, что из не Q следует P.
Ну и с другими точно так же.
Если будет не R или S, значит это равносильно тому, что из R следует S, и с другой стороны это равносильно тому, что из не S следует не R.
Ну и так далее. Собственно, остается вариант с двумя отрицаниями, он тоже аналогично делается.
И тогда получается, что если есть такая три KNF, то можно по ней построить некий граф.
В этом графе для каждой переменной будут две вершины с этой переменной отрицанием.
Ну и, например, можно вот такую рассмотреть.
Значит, не P или Q.
И, например, не Q или не R.
И, соответственно, не P или R.
Так, и тогда смотрите, что получается. Не P или Q. Это вот тут получается из P, из P следует Q. Значит, из не Q следует P.
А каждую из импликаций буду рисовать как стрелочку. Вот в этом графе.
Значит, из P следует Q, из не Q следует не P.
Значит, это получается из Q, из Q следует не R. Значит, из R, соответственно, следует не Q.
Такая симметричная штука.
Дальше получается из P следует R. Значит, из не R следует не P.
Вот, и получается, смотрите, что если мы пройдем, пройдем вот так вот.
Да, значит, можно применять правильность логизма.
Из P следует R, из R следует не Q, а из не Q следует не P.
И в итоге получить, что из P следует не P.
Значит, из P следует не P.
Вот, и тогда это будет означать, что может быть только весь 0, а весь 1.
Потому что только из нуля может следовать единица, а из единицы 0 не может следовать.
Вот.
Но если получишь, что есть два пути, из P в не P и из не P в P.
Или какой-то переменный.
Значит, если есть два пути,
из, соответственно, P,
или какой-то переменный, для P, да, из P в не P и из не P в P,
то, соответственно, формула просто будет не выполнена.
Ну что, формула.
Формула не выполнена.
Вот. Ну, на самом деле, это критерий.
Значит, то есть вот в эту сторону это довольно понятно.
Да, потому что тогда сразу должно быть и вот так вот, и наоборот.
Да, так не может быть.
Вот.
Ну, на самом деле, верная и в обратную сторону.
То есть, если таких путей нет, то она выполнена.
Верная и обратная.
Вот, значит, наверное, дать я полностью доказать не буду рассказывать.
Да, значит, может подумать сами.
Там есть несколько разных подходов.
Ну, например, можно подходить так.
То, рассмотрим все переменные по очереди.
Вот, если нет вообще ни одного пути, да, не такого пути, не такого пути,
то тогда каким-нибудь произвольным образом,
каким-нибудь произвольным образом определяем назначение переменной.
Вот, но после этого, значит, например,
ну, например, вот это говорит, что P должно быть равном нулю.
Ну, например, чему это равно R и Q?
Да, это ничего не понятно.
Например, мы можем сказать, что будет Q равно единице.
Да, Q равно единице, тогда R должно быть равно нулю.
Да, то есть, получается, что если мы поставим перемен какое-то заточение,
то из двух литералов будет один истинный.
И из него какими-то путями,
на какими-то путями можно прийти.
Соответственно, тоже куда-то и то, куда придем, будет равно единице.
Вот.
Ну вот, а если, соответственно, для очередной переменной,
для очередной переменной есть какой-нибудь такой вот путь,
то и значение тоже автоматически получается.
Дальше нужно аккуратно доказать, что это все сойдется друг к другу.
То есть, например, и тут как раз нужно использовать,
что все эти ребра, они такие парами идут.
Например, это же верно не только для просто ребр, но и для путей.
То есть, есть путь из R вне P.
Вот так, раз-два.
То есть, вы двойственно ему из P в R.
Вот.
Так.
Хорошо.
Дальше, давайте я это оставлю как-то в упражнении для семинара.
Дальше есть ключевая теорема Кукулевина.
Теорема Кукулевина, которая стоит в том,
что задача SAT.
Ну и как следствие задача 3 SAT.
NP полное.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
НП полное.
НП полна.
На самом деле, прям к САТ-у так не...
Ну, должна быть некоторая довольно сложная конструкция.
Да, и для начала
можно поговорить не про САТ, а про то, что называется
генерическая НП полная задача.
Генерическая НП полная задача.
Значит, она обычно означает ТМСАТ.
ТМСАТ равняется
множеству
и строек.
Значит, и строек
машина,
вход
и число в унарной записи.
Значит, машина,
вход Х и число в унарной записи.
Такие, что
существует Y
то М от XY
равно единице
и М от XY
останавливается
на не более чем Т шагу.
Вот.
Значит, соответственно,
про нее нужно доказать
во-первых,
что она из-за НП
и во-вторых,
значит, во-вторых,
что она НП трудная.
Любая к ней сводится.
Ну, и на самом деле
тут может возникнуть вопрос
зачем нужно Т
еще и в унарной записи.
Вот.
Ну, вообще Т нужно
чтобы это была хотя бы разрешимая задача.
А вот
в унарной записи нужна как раз
чтобы это лежало в НП.
Значит, принадлежность
принадлежность к НП
берется
вот из чего.
То
ну, просто вот это все
можно проверить
как раз за полинома длины входа.
Это все
мы можем проверить
как раз за полинома длины входа.
Ну, потому что моделирование
ну, моделирование на Т шагов
занимает как раз порядка времени Т.
Ну, как именно порядка
зависит от деталей моделя.
Вот.
Ну, в общем, в любом случае получается,
что моделирование
моделирование на Т шагов
моделирование на Т шагов
занимает
время порядка Т.
Ну, да.
А вот как раз чтобы
потому что время
именно порядка Т.
А, 1 степень T
означает 1 из подряд.
Ну, нет,
а среди кадров скорее будет Y.
А это как раз часть входа.
Да, значит
вот это я как раз объясняю, что нужно
смотрите, если мы
просто T напишем,
то это даст потребовать
логарифма T обитов.
И тогда будет общая длина
будет как раз там
N плюс логарифм T.
И тогда получается,
что T может быть экспоненциальным,
чтобы, тем не менее,
битов на запись T
тратилось бы по полиномиальное число.
Но тогда будет не то, что мы хотим.
Тогда мы не сможем проверить,
что за такое экспоненциальное время оно действительно становится.
И чтобы, соответственно,
время, которое нам нужно
было полиномом
от суммарной длины записи,
нужна такая унарная запись
из одних единиц.
Вот.
Да, конечно.
Да, это вот про все.
Да, да, да, да.
Да, может быть такое.
Вот.
Ну, а вторая часть НП-трудность
она почти очевидная.
Значит, пусть у нас
А лежит в НП.
А лежит в НП.
И как раз
Х лежит в А.
Тогда и только тогда,
когда существует Y,
что
M
от XY
равно единице.
И, соответственно,
это работает
за меньше либо равно,
чем какой-то полином.
Иначе МП
от N шагов.
Вот.
Вот.
Ну, это получается, что просто нужно
Х
отобразить в тройку
как раз из М
Х
единиц,
которая NП от длины Х раз.
Вот.
Значит, соответственно,
вот эта тройка
и эту тройку, конечно,
по Иксу можно довольно быстро
написать.
Ну, вот. Ну, а весь получается
ровно то, что написано.
Ладно, давайте сделаем
перерыв на 5 минут.
Значит, вот теория
МП Клевина.
Значит, ну, чтобы
ее доказывать,
нужно так или иначе
залезть в какие-то
детали
модели.
Да, значит, нужно что-то говорить про машину тюринга.
Значит, ну, и мы будем считать.
Будем вот так вот записывать.
Вот.
Вот, значит, есть Х.
Потом,
например, вот так, такой
пробельный символ,
бланк, будет отделять
Х от
Y.
Ну, и потом еще
все остальное
будет заполнено
тоже бланками.
Тут я для простоты предполагаю, что у нас
одна лента у машины.
Соответственно, у этой одной ленты
написан Х,
потом пробел, потом Y,
потом сплошные пробелы.
Соответственно, после этого
еще нужно
состояние написать.
На Q1.
Значит, Q1 состояние.
Вот, значит, соответственно, после этого
мы просто запускаем
запускаем машину и так далее.
И будем считать, что у нас
в каждой строчке
написана конфигурация.
Любая конфигурация имеет
вид
вот такой вот.
Значит, A, Q.
Маленькая B.
Здесь A
и B большое.
Это слова
какие-то. Значит, Q
какое-то состояние.
Вот.
Значит, Q какое-то состояние, A какое-то символ.
Вот. Соответственно,
подразумевается, что вот такая
запись означает, что вот есть лента.
Значит, вот есть
символ A. Значит, есть соответственно
символ B.
Вот. И соответственно, машина
находится в состоянии Q
и указывает
вот на этот символ A.
Слева от него написано A большое,
справа от него B большое.
Вот. И вот эти конфигурации, они
друг за другом так
записываются.
Вот.
Ну, а здесь, соответственно, где-то
в конце есть
принимаешь состояние
Q accent.
Ну, решетки
это просто пустые клетки, можно считать.
Решетка, она и похожа
на пустую клетку.
Ну да.
Вот.
Значит, дальше, какая тут основная
идея.
На самом деле,
символ, который
написан в клетке,
зависит
только от
четырех
символов.
Значит, только от четырех символов
над ним.
Значит, почему
от четырех, почему так несимметрично?
Ну, несимметрично это потому,
что мы именно вот так записываем.
То есть, тот символ
под символы,
который указывает головка,
он записывается после,
соответственно, символа состояния.
Вот.
Ну и там получается, что если вот среди этих
четырех вообще нету символа
состояния,
то тогда тут просто копируется сверху.
Вот. И даже если здесь символ состояния,
то тоже просто копируется
сверху.
Ну, это вот,
это на ленте все написано.
Но, опять же, вот как здесь,
мы записываем именно вот так.
То есть, тут все, что на ленте, плюс состояние.
Да, да, да, да.
Я сказал, одноленочная машина.
Так это разные этапы.
То есть, тут...
Ну, типа того, да, да, да.
Да, после конфигурации.
Ну, ветка в том смысле, что Y в начале выбрано.
Y в начале выбрано,
а остальное уже
идет как идет.
Погодите.
Значит, я хочу сказать следующее,
что тут вот, в каждой строчке
написано.
Я хочу сказать, что вот,
что будет написано в этой клетке,
зависит только от четырех клеток
на дней, которые вот так расположены.
Вот. Если есть тут состояние
вообще нет, или если оно вот здесь,
вот тогда тут просто копируется сверху.
Вот. А дальше, ну, соответственно,
есть команды.
Например, если состояние вот здесь вот,
если состояние вот здесь вот,
и, соответственно,
тут какой-то символ.
Вот дальше, что будет здесь,
соответственно, того что машина делает,
когда она вот в таком состоянии
смотрит на такой символ.
Значит, что она может делать?
Она может этот символ
куда-то заменить
и сдвинуться налево, например.
Тогда здесь будут то,
на что она заменит.
Она может на что-то заменить
и сдвинуться направо.
Если она сдвинется направо, тогда то,
на что мы заменили, будет вот здесь вот,
а здесь будут на вот состоянии.
Ну вот, в любом случае, это вот этим двумя определяются.
Ну и также нам нужна вот эта клетка, потому что может
быть так, что на самом деле вот здесь вот символ состояния,
здесь символ алфавита, и это такой символ, при котором
куст двигается налево, а если будет другой символ,
то он не будет двигаться налево.
Значит, если двигаться налево, то тут будет новое
состояние, а если не двигаться налево, то будет тот же символ,
который вот здесь вот.
Ну вот, поэтому то, что вот здесь вот тоже влияет на
то, что будет вот здесь вот.
Слава какие-то, да.
Да, мы доказали куклу Левина.
Сейчас-то еще нет никакой формулы, значит, я объясняю, что происходит, но дальше уже очень близко к формуле.
А и Б – это то, что дофинство происходит в родине, да?
Ну да.
Да.
Нет, нет. Нет, А и Б – это не могут быть состояния, это именно слова из алкогита.
Ну, потому что есть только одно место, куда машины указывают, там только одно состояние может быть.
Бывают, конечно, такие экзотические модели, где машина тюрингит с несколькими головками.
Да.
Вот. Хорошо, значит, теперь, как будет выглядеть наша формула, значит, которая выполнима тогда-это тогда-когда?
Когда есть такой Y, при котором вот это все вычисление заканчивается снимающим состоянием.
Так, сейчас я еще вернусь вот сюда.
Вот про количество строчек надо сказать.
Значит, количество строчек – это, собственно, время работы машины.
Там какое-то T от M.
Вот. Ну, дальше смотрите, за каждый шаг, значит, за каждый шаг машина может сдвинуться правее, не более чем на одну клетку.
Поэтому по горизонтали, значит, по горизонтали тоже можно считать то, что тут T от M.
Вот. Ну, поэтому, соответственно, размер всей таблицы T от M в квадрате.
То есть, полиномиальная, если это, значит, если это N, P, то тогда вот это T от M должен быть полиномиальная.
И тогда размер всей таблицы тоже полиномиальный.
Так, все, теперь пишу формулу.
Значит, всю эту таблицу можно закодировать.
То есть, можно сказать, что там P ежитое.
P ежитое – это набор, значит, набор переменных.
То есть, набор переменных, кодирующих содержимое в ячейке.
Соответственно, ежи.
Вот. Ну, это какой-то конечный набор переменных.
Потому что у нас всего конечное число символов, конечное число состояний.
Соответственно, можно какое-то конечное число битов, даже логарифмическое от общего числа символов состояний,
каким-то логарифмическим числом символов закодировать.
Соответственно, все, логарифмическим числом битов закодировать все возможные символы.
Вот.
Во, значит, это вот P ежитое.
Так, теперь, что нам нужно?
Наш Ворлофи.
Значит, будем представлять, как конъюнцию трех составляющих.
Значит, phi start и phi accept и phi step.
Значит, phi start будет означать, что начальная, значит, начальная конфигурация, какая нужна.
И phi accept означает, что в конце конфигурация принимающая.
И phi step означает, что всюду по дороге и переход сделан направленно.
Так, значит, phi start будет такой вещью.
Будет примерно так, что, значит, P0,0 равно Q1.
То есть сначала там будет начальное состояние.
Значит, дальше будет P01 равно X1.
И так далее.
И P0,0 равно X0.
То есть, значит, там сначала принимающие состояние, потом все символы X.
Вот.
Потом будет P0,0 и N плюс 1.
Это будет пробел.
Значит, бланк.
Вот.
А дальше смотрите, Y мы как раз не знаем.
Но мы знаем, что он стоит из битов.
То есть, что в Y либо 0, либо 1.
Поэтому можно так написать.
И P0,0,N плюс 2 равно 0.
Или P0,0,N плюс 2 равно 1.
И, соответственно, P0,0,N плюс 3 равно 0.
Или P0,0,N плюс 3 равно 1.
И так далее.
и тогда, и так, дö того, сколько у нас символов у И.
Сколько символов у И тоже зависит от нашей машины.
Значит, это какой то полином,
который может быть меньше, чем T от m.
Ну, можно считать, что так.
Да, Поежит – это не одна переменная, а несколько.
Потому что, да, символ ты можешь считать, что три, а вот стейн все равно будет много.
Так, и так далее. Да, значит, и, соответственно, p 0, а тут n плюс какое-то...
Ну, дайте я так пишу, плюс длина y и плюс один, наверное, да.
Вот это равно нулю или, соответственно, эта же штука равна единице.
Вот, а все остальные, да, например, n плюс длина y плюс 2, это будет бланк.
Ну, и так далее, вплоть до последнего, да, значит, p 0, ну, t от n я просто напишу, да, значит, равно бланк.
Вот, вот это фистарт.
Фистарт означает, что в начале написано ровно то, что там написано.
И на самом деле вот это вот единственное место, где мы бит икса используем.
То есть, опять же, к вопросу о том, почему садимся в полинамиальное, мы можем просто взять бита икса и сюда подставить.
Так, хорошо, ну, соответственно, дальше fe accept.
Ну, вот сначала идет там q1, все бита икса, потом бланк, а потом либо 0, либо 1, потом тоже либо 0, либо 1.
А на кроссе нужно, чтобы существовал такой y из нули единиц, да, и это x дан, а y не дан.
И y должен существовать.
Ну, t от n какой-то многочлен.
Да, его можно, ну, его можно записать как-то в сводящую функцию, да, то есть, ну, t от n оттуда же, откуда и длину y берем, да, из природы машины, которая это все делает.
Да, потому что у этой машины есть какая-то длина y и какое-то время работы.
Да нет, это же неправильно, там есть решетка еще между x и y.
Ну, нет, ну, вот здесь я просто, я на самом прямую, что дальше все остальные решетки, то есть, что здесь я предустановил длину y.
Ну, может, да, может быть.
Ну, да, можно сделать так.
Нет, там он может, конечно, и не устанавливать длину y, но это всегда вопрос кодирования, потому что можно сначала y за y закодировать.
Ну, да, можно сделать так, вот. Нет, там можно, конечно, и не устанавливать длину у.
Но это всегда вопрос кодирования, потому что можно сначала у закодировать беспрефиксным кодом.
Например, вот какой может быть беспрефиксный код?
Ну, самый простой, когда мы каждый бит удваиваем, а в конце пишем 0,1.
Тогда код одного у не может быть префиксом кода другого у.
Но тогда, после этого 0,1, можно еще дописывать все, что угодно.
И все равно мы можем будет прочесть, какой именно у.
И тогда, значит, если мы так сделаем, то можно считать, что для у предустановлено.
А можно, конечно, считать, что и не предустановлено, а действительно писать, как вы говорите,
как бы для всех индексов, начиная вот с этого, написать, что они равны 0,1 или бланку.
И если какой-то район бланку, то следующий тоже район бланку.
Типа того.
Нет, сертификат у нас возникли вот здесь вот, да.
То есть тут вот у нас есть два варианта для вот этого m plus второго бита,
потом два варианта для m plus третьего бита и так далее.
Соответственно, мы все эти двойки перемножаем.
Ну, типа того, да.
Ну, fiacet означает, что просто...
Так нет, здесь вообще нет.
Просто вот у нас получится форма полинамидной длины,
где мы просто вот в эти конкретные места поставим конкретные биты.
Но мы вставляем форму полинамидной длины,
но мы вставляем формулу, мы вставляем формулу.
Значит, устроить, что важно.
Значит, важно, что таблица полинамидного размера,
и важно, что тут используется только четыре предыдущих клетки.
Что это позволит здесь сделать функцию константного размера,
который от этого зависит.
Да, если был тут какой-то растущий, то тут как раз экспонентом возникло.
Ну, можно так сказать, да.
Можешь сказать, что мы TMSAT сводим.
Можешь сказать, что мы произвольную машину сводим.
Так, так вот, fiacet.
Ну, fiacet означает, что просто в конце,
да, значит, TAT0, значит, это qacet,
или и так далее,
или TATMTATM.
Значит, равно qacet.
Вот.
Так, ну и FISTEP.
FISTEP будет как раз кодировать вот эту фигурку.
Вот.
Ну, а что fiacet? Fiacet означает, что либо здесь принимающий стояние qacet,
либо здесь, либо здесь, либо здесь, и так далее.
Так.
Хорошо.
Ну, дальше FISTEP.
Нет, почему?
Так, давайте я тут...
А, в смысле...
Нет, да, можно считать, что слева есть граница, да,
то есть что лента односторонняя.
То есть мы можем двигаться и налево, и направо,
но только справа от ограничителя.
Ну, мы обсуждаем, что это не обременительные условия.
Вот, FISTEP.
Так, ну тут я, давайте, уже без многоточий, да,
напишу вот так.
Вот это, значит, будет конъюнкция
по всем i.
Вот единицы, то есть,
по всем i,
по всем i,
по всем i,
от единицы до t от n.
Конъюнкция по всем g,
от нуля до t от m.
Здесь нужно писать, что p и gt
будет какой-то конкретной функцией.
Значит, как p и минус 1g минус 1.
Ответственно, p и минус 1g,
p и минус 1g плюс 1,
и p и минус 1g плюс 2.
Вот, ну приятно смотреть,
тут вот это g минус 1,
или g плюс 1g плюс 2
могут, в принципе, вылезти вообще
за пределы этой таблички,
да, то есть если g у нас вот здесь,
и минус 1 вылезет вот сюда.
Но можно считать, что есть
специальный символ нахождения
за пределами таблички,
и вот эта вот функция,
функция, которая говорит,
что будет в зависимости от вот этих вот,
она соответственно тоже
умеет обрабатывать.
То есть, если оказалось, что вот эта клетка уже за пределами таблички,
то будет специальное значение
для этой функции.
То есть, вот эта вот f,
и f, вообще говоря, довольно сложная функция,
потому что f
внутри себя
содержит всю программу машины тюринга.
И даже по несколько раз.
Вот, но тем не менее,
у нее размер хоть и большой, но константный.
Вот,
значит размер у нее хоть и большой, но константный,
поэтому
вот у этой части будет размер константа,
ну а дальше мы это умножаем
еще на t от n и еще на t от n,
получаем размер пленомиандии.
Вот, добавляем вот этого,
добавляем вот этого, получаем, соответственно,
ну всю формулу получаем, да,
то есть это остается пленом,
значит, получаем всю формулу.
Так, ну теперь давайте аккуратно проговорим,
почему это правильная сводимость.
Вот, смотрите, пусть у нас есть
такой y,
пусть у нас x зафиксирован,
и для него есть такой y,
что машина выдает единицу.
Тогда, соответственно,
есть
соответствующий вот таблица работы
этой машины на этом y.
И можно значение всех переменных
взять такими,
чтобы
ну чтобы они совпадали с тем,
что в столице написано.
Вот.
Ну и тогда просто получается,
что все это будет верно.
Так.
А, сейчас, да,
вот так вот.
Да, получается,
что все это будет верно.
Да, мы возьмем
для игр как раз такие биты,
соответственно, вот это все тоже будет верно.
В конце, поскольку
ответ дату будет, соответственно,
понимающий состояние,
вот, и поскольку это правильный протокол,
то все переходы тоже будут верны.
Да, то есть получается, что если
существует y,
значит такое, что
m от x и y
равно единице,
то тогда для
для протокола
для протокола работы
m от x и y
m от x и y
и формулы
будут верны.
То есть формулы выполнимы.
Ну, то есть, значит, для протокола работы,
значит, для значений по ежи
взятых из протокола работы,
то есть из той таблички.
Вот.
Ну, на самом деле и наоборот тоже.
Значит, если
есть выполняющий набор у формул,
есть выполняющий набор у формул,
тогда получается, что
по, соответственно,
по
p
0 n plus 2,
значит, p 0 n plus 3
и так далее.
Значит, p, соответственно,
0
n плюс размер
y плюс 1
можно поставить
можно построить
может построить y.
Вот. Ну и, соответственно,
значит, значения
по ежи t
значит, зададут протокол работы
на этом y.
Протокол работы
для этого y.
Вот.
Ну и, соответственно, этот протокол
закончится
принимающим состоянием.
Значит, который
закончится принимающим состоянием.
Вот. Значит, почему
почему это все будет правильно?
Ну, потому что, смотрите,
что у нас говорит FISTART?
FISTART говорит, что у нас возникает
начальная конфигурация
для вот этого x
и какого-то y
нужно длины.
Дальше, что говорит FISTEP?
Ну, FISTEP говорит, что каждая следующая
строчка получается из предыдущей
по правилам перехода машины тюринга.
Вот. Но это, конечно, в принципе,
нужно еще немножко подробнее доказывать,
но ладно, это я тоже пропущу
на что
ну, что действительно
однозначно определяется.
То есть тут
и оно вообще вроде довольно понятно
должно быть.
Ну, тут нужно
на самом деле две вещи доказывать, что
во-первых, это определяется,
во-вторых, однозначно.
Вот. Ну, так, в общем, то и другое
можно доказать путем аккуратного
анализа
правил перехода машины тюринга.
Вот.
Так. Ну, и на этом все.
Так. Ну, и, значит, и
последнее,
что раз выполнена Fiat Accept, значит,
там где-то в конце есть принимающий состояние.
Вот. Ну, значит,
соответственно, оно там
должно быть.
Вот.
Какие-нибудь вопросы.
Не, ну, на самом деле
можно и не через нее делать.
То есть, ну, можно сказать, что вот это вот
и это как раз вот это вот.
Это то же самое, что вот это.
А так, в принципе,
то есть тут ценность
генерической
не обязательно в том, что мы ее
сводим там куда-то.
Вот. А
то есть, ну,
то есть, ну,
то есть, ну,
да.
Вот. А может быть в том, что
просто
часто вот по полной задачи выглядит
именно так.
Да. То есть, полная задача в
одной классе часто получается
так, что мы получаем какое-то описание
вообще задачи из этого класса.
И если такая задача сама будет в том
же классе, то она будет полной.
Вот.
Так. Ну, ладно.
В следующий раз получается, что мы
будем разные полные задачи
изучать.
Все. Спасибо за внимание.
