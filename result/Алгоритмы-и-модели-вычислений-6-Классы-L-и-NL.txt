Так, ну хорошо, значит, на сегодняшней лекции, да, ну и еще на одной или двух следующих, мы будем говорить про логарифмическую память.
Значит, сначала я расскажу немножко неформально, про что здесь идет речь и почему это важно.
Ну, вообще память – это важный ресурс. Почему? Ну, значит, есть причина полувековой давности, что память просто очень дорогая.
И в 70-х годах прошлого века, в общем, более-менее память была самой дорогой частью компьютера.
И более-менее, если вы изготавливаете или покупаете компьютер, в котором в два раза больше памяти, то и стоить он будет не в два раза больше, но там на 90% больше.
Поэтому это прям было важно с маленькой ограниченной памятью пытаться решать побольше задач.
Но даже если память и не очень дорогая, то, тем не менее, как реальный компьютер устроен, там есть на самом деле несколько уровней памяти.
Есть регистры процессора, к которым доступ более-менее мгновенный. Есть кэш, к которому доступ не мгновенный, но очень быстрый.
Может быть несколько разных уровней кэш-памяти. Дальше бывает оперативная память, которая еще побольше, но к ней доступ еще медленнее.
Дальше бывает жесткий диск, к которому доступ еще сильно медленнее. По старой технологии HDD, SSD побыстрее, но все равно не так быстро, как оперативная память.
Ну и теоретически можно еще говорить про какое-нибудь хранилище на облаке, которому нужно через интернет подсоединяться, это еще дольше, чем внутри компьютера.
И бывает даже такой крайняя степень, это какой-то архив вообще никуда не подключенный, например, на магнитном носителе.
Хотя кажется, что всякие магнитные носители типа аудиокассеты, видеокассеты, это все осталось в XX веке.
И восстаревшие технологии на самом деле это не совсем так. И технология на магнитном носителе тоже развивалась все эти годы, но просто она ушла из потребительского сектора в сектор хранилища, долговременного хранилища каких-то статичных данных.
И реально магнитные носители с такими лентами используются, и, более того, там научились довольно плотно записывать информацию.
Но проблема в том, что чтобы ее прочесть, нужно физически перематывать эту катушку, поэтому этот процесс не быстрый.
Многие интернет-компании реально время от времени делают архив своей информации вот на таком магнитном носителе с целью, что если вдруг все сервера сразу сломаются, то потом с этого магнитного носителя можно будет восстановить.
Все такие большие дата-центры устроены так, что там вся информация хранится в нескольких экземплярах, как минимум в двух, но даже скорее в трех.
И там есть какая-то управляющая система, которая следит, чтобы это все никуда не потерялось.
Если там какой-то блок поломался, то его там не чинят, а просто убирают, ставят новый, старый отдают в переработку, а дальше эта система следит, чтобы все было записано не один раз, а несколько.
Но тем не менее, несмотря на это, время от времени делают слепки базы данных и записывают их на магнитный носитель.
К чему это все? Каждый следующий уровень хранилища памяти больше по объему, но медленнее по доступу.
Соответственно, если ваша программа использует слишком много памяти, то ей приходится обращаться к более медленному носителю, и получается, что память переносится прямо и на время тоже.
Что если ваша программа эффективна по памяти, то есть ей не нужно, например, она целиком помещается в оперативной памяти, ей не нужно ничего записывать на жесткий диск, то она и работать будет быстрее.
Если у вас та же самая задача решается с меньшим объемом памяти, то она может существенно быстрее работать.
Даже хотя, допустим, число базовых операций может быть там будет такое же, но если эти базовые операции не связаны с доступом к медленной памяти, то все это будет быстрее.
Ну а время это все-таки самое важное, чтобы задачи решались к сроку.
Хорошо, почему нас интересует логарифмическая память, и что это вообще означает.
Ну вообще здесь предполагается вот такая картина, что есть один блок памяти, это неизменяемый вход.
Ну и хотя понятно, что для любой содержательной задачи нужно все-таки весь вход прочесть, тем не менее рабочая память, на которой реально какие-то вычисления совершаются, может гораздо меньше, чем вот этот неизменяемый вход.
Ну и хотя понятно, что для любой содержательной задачи нужно все-таки весь вход прочесть, тем не менее рабочая память, на которой реально какие-то вычисления совершаются, может гораздо меньше, чем вот этот неизменяемый вход.
И это тоже вполне себе практическая история, потому что, ну например, представьте такую задачу, у вас есть какой-то жесткий диск, и он заполнен информацией почти целиком.
Или телефон там завит фотографиями, и свободного места совсем мало.
Но, тем не менее, вам нужно совершить какую-то операцию, например, поиск по всему диску чего-нибудь.
И, соответственно, конечно, если вы ищете информацию где-то, то вы не можете это изменять то, где вы ищете.
Соответственно, вам нужно, чтобы ваша рабочая память, которую вы используете, была гораздо меньше, чем сам вход.
У вас нет второго такого же диска, на который вы можете скопировать и там изменять все что угодно.
Нужно каким-то образом хранить только небольшую часть.
Но вот это вот вполне себе классическая история.
Поэтому, когда говорят о количестве использованной памяти, то память, которая использована на вход, не учитывают.
Учитывая только вот эту рабочую память, только она используется при подсчете занятой памяти.
Вообще, в любой выщитной модели есть какие-то базовые ячейки.
Например, в машине тюринга это может быть отдельная клетка, в которой может быть записано какой-то символ.
Ну и, соответственно, число вот этих клеток является использованной памятью.
Ну а что значит число клеток?
Например, в случае машины тюринга можно считать, что это клетки, на которые в процессе вычисления хотя бы раз машина указывала.
Вот на этой рабочей памяти.
Ну и тогда вполне может быть и логарифмическая такая память.
Но она совсем маленькая, она не может быть.
Например, если она будет константной, то это фактически будет то, что называется конечный автомат.
Не знаю, у вас не было такого понятия? Было, да?
Ну вот конечный автомат это фактически компьютер с константной памятью.
И даже там есть такая теорема, что если даже память не константна, но она что-то типа там у маленькой от повторного логарифма,
тогда это все равно будет конечный автомат.
Значит, это можно смоделировать.
Но вот если это не повторный логарифм, а просто логарифм,
тогда уже какие-то содержательные вещи, не решаемые конечной автоматами, можно вполне себе делать.
Ну а вообще в целом тут есть классы dspace, dspace от s от n.
Значит, это опять же языки, то есть задача с бинарным ответом.
Значит, языки распознаваемые на памяти у большой от s от m.
Букска d означает детерминированная машина чьюринга.
Соответственно, есть nspace от s от n.
Значит, это вот то же самое, только на недетерминированной машине.
Дальше она работает в принципе так же, как мы обсуждали про недетерминированную машину по времени.
То есть у нее такой ветвящийся процесс.
И, соответственно, на каждой ветве должно быть у большой от s от n памяти дополнительный.
И если на одной ветве ответ один, то общий ответ один, если на всех ветвях ответ ноль, то общий ответ ноль.
Ну а дальше про какие бывают конкретные классы.
Бывает класс l, который есть dspace от logarithm m.
Есть nl, соответственно nspace от logarithm m.
Есть pspace, значит dspace от полинома от n.
Вот еще бывает nspace от полинома, но на самом деле то же самое, что pspace.
Когда там бывают всякие другие, там expspace, например, экспоненциальная память.
Бывает poly l, poly l, давайте я даже напишу.
Значит, poly l, это dspace, соответственно, от, ну, от полилогарифма, то есть полином от логарифма.
Некоторые задачи у вас здесь лежат.
Ну и вот есть теория Мисцевича, я думаю, я не буду ее доказывать, но, по крайней мере, сейчас.
Потом посмотрим, может быть, и докажу.
Теория Мисцевича заключается в следующем, что nspace от s от n вложена в dspace от s от n в квадрате.
То есть квадратично, значит, квадратично увеличивается память при детерминизации.
Значит, если для детерминированного и недетерминированного времени у нас было экспоненциальное возрастание,
то есть то, что недетерминированное делается за время t от n, делается детерминированно за время 2 в степени t от n,
ну, по крайней мере, при тривиальном способе это сделать.
Вот здесь у нас получается квадратичное.
Ну, там формально-техническое условие, значит, это верно при s от n больше, чем в логарифме.
Если совсем маленькая память, может быть, не совсем так.
Ну, из стереомисцевича два следствия.
Значит, следствие 1, что pspace равняется n pspace, то есть про полиномиальную память нет вопроса,
о том, дает ли недетерминир что-нибудь дополнительное ответ, что не дает.
Ну, а следствие 2, что nl вложено в поле l.
То, что распознается недетерминированно на памяти логарифм, распознается недетерминированно на памяти логарифм в квадрате,
то есть как раз в частном случае полинома.
А вот вопрос, о том, равны ли l и nl, открыт.
Открытый вопрос.
Открытый вопрос, равны ли l и nl.
Ну и он играет роль вопроса op и np применительно к вычислениям на ограниченной памяти.
Соответственно, план такой. Немножко поговорим про класс l, на какие там задачи лежат.
Поговорим про класс nl. Там есть своя теория nl-полноты.
Ну и вот теория nl-полноты с одной стороны похожа на теорию np-полноты, с другой стороны немножко другая.
Ну и вот она является важным инструментом для решения этого вопроса.
То есть там всякие похожие теоремы, что если там nl-полная задача лежит в l, тогда l равно nl и так далее.
Вот. Хорошо.
Такая общая картина. А, дайте я еще общую картину.
Про то, как связаны классы по времени и по памяти.
Так. Ну, давайте так.
Значит, D-space от S от n у нас вложено в N-space от S от n.
Это вложено в D-time от 2 в степени S от n. Ну, от 2. Ну, тут у большое нужно, да.
Вот. Это вложено в N-time от 2 в степени его большое от S от n.
И это у нас вложено в D-space.
Вот. Ну, того же самое.
Вот. Значит, соответственно, как это принятно к конкретным классам работает.
Ну, в частности, получается вот такой ряд.
Значит, в частности, значит, у нас l вложено в nl.
Значит, это вложено в P. Это вложено в N-P. Вот. А это вложено в P-space.
Ну, а это у нас получается равно.
Значит, равно N-P-space. А это вложено в EXP.
Ну, а дальше это вложено в N-EXP. Ну, и так далее.
Ну, давайте я еще EXP-space напишу.
Вот. Тут получается три уровня.
Первый уровень логарифмический, второй уровень полиномиальный, третий уровень экспоненциальный.
Вот. Конечно, могут быть какие-то промежуточные.
Там какой-нибудь вот полилогарифмический, квазиполиномиальный и так далее.
Вот так. Ну, давайте на примерах.
Значит, на примерах поймем, почему это так.
Значит, самое простое, почему l вложено в P.
Так. Доказательства.
Ну, давайте я сначала на примерах вот из этого ряда,
а потом скажу, почему это обобщается на произвольные границы.
Так. l вложено в P.
Это верно по очень простой причине.
Потому что, смотрите, если у нас логарифмическая...
Да, у нас есть вход длины N и есть рабочая память длины логарифма.
Смотрите, вход длины N и рабочая память длины.
Ну, давайте я тут целый гривен напишу.
Вот. Тогда просто сколько у нас всего конфигурации может быть?
Значит, число...
Ну, да, значит, я имею в виду машину тюринга в уме.
Значит, число конфигурации.
Чему равно?
Это будет Q, но это вместо число состояний.
Значит, число состояний...
Ну, это какая-то константа.
Размер множеств состояний.
Это какая-то константа.
Значит, умножить.
Значит, умножить на что?
Умножить на...
Ну, давайте пусть даже там не бинарный алфавит какой-то.
Так, это у нас гамма, ленточный алфавит.
Обычно гамма в степени C логарифм N.
Значит, вот эта вот гамма, это ленточный алфавит.
То есть какие вообще символы бывают.
Вот. А вот всё вместе в степени C логарифм N
это число возможных слов, записанных на рабочей лене.
Значит, это число возможных слов на рабочей ленте.
Вот. Но ещё у нас есть один параметр.
Это расположение указателей.
Вот. Соответственно, на входной ленте это будет N.
А на рабочей это ещё целый грифм F.
Вот это будет число способов разместить указателя.
Вот. Но вообще, если через всё это продраться,
то у нас получается какой-то многочлен.
Ну, смотрите, это какая-то константа в степени логарифм умножить на C.
Но это то же самое, что N в степени C на логарифм вот этого.
То есть какой-то многочлен.
Может быть, с большим показателем, но многочлен.
Ну, умножили ещё на N, там ещё на единицу увеличилась степень.
Это константа, значит, это мелочь какая-то, да.
То есть это точно меньше, чем ещё N.
Вот. В общем, всё это вместе получается многочлен.
Ну, то есть всего, значит, вот это вот всего по лином от N-конфигурации.
И при этом повторяться они не могут.
Потому что, если конфигурация повторилась,
значит, если конфигурация повторилась,
то тогда машина зацикливается и уже никогда не остановится.
Значит, конфигурация не может...
конфигурация не может повториться.
Вот.
Ну, а тогда что получается?
Получается, что число шагов не больше, чем число конфигурации.
То есть полиномиально.
Значит, число шагов меньше либо равно, чем число конфигурации.
И, следовательно, полиномиально.
Ну, раз число шагов полиномиально...
раз число шагов полиномиально, значит, это лизит в P, по определению.
Так. Хорошо.
Ну, на самом деле, точно так же работает вложение как бы через один.
То есть D-space от S от N вложено вот сюда.
Два в степенью большой от S от N.
И это как раз тоже верно, если S хотя бы логарифм.
Почему это так? Потому что у нас есть вот этот множитель,
который не зависит от памяти, это N.
Вот. Но вот если S от N хотя бы логарифм,
то это будет порядка два в степени S от N.
Вот. Если S будет сильно меньше, то вот это будет определять ассинтотику.
Да, как бы всё равно полином получится.
Вот.
Не, наоборот ничего не портит. Мы его оценим N.
Нет, не логарифм будет портить, а вот это N будет портить.
Да.
Ну, это не логарифм, это то же самое S от N.
S от N не будет портить, а вот это вот N
будет больше, чем два в степени S от N.
Если это совсем маленькое.
Так.
Ну, теперь давайте поговорим про то, почему NL.
Значит, NL вложено в P.
Тут довольно интересный подход.
Значит, всё равно нужно смотреть на конфигурация.
Вот. Но дело в том, что вот когда у нас
детерминированные вычисления, то у нас конфигурация как-то вот одна за другой идут.
И получается как бы такая линия.
А когда у нас, значит, когда у нас
недетерминированные вычисления, то вместо линии у нас получается дерево.
И дерево, вообще говоря, может быть экспедиционным.
И тогда вопрос, как мы его будем обходить.
Но ответ такой же, что на самом деле оно не может быть экспедиционным,
потому что всего конфигурация полинамеральное число.
И соответственно, у этого дерева, если он слишком сильно ветвится,
то у него разные ветви будут склеиваться и приводить к одному и тому же результату.
Вот. Поэтому рассматривается такая вещь, как конфигурационный граф.
Конфигурационный граф.
Значит, здесь вершины – это конфигурация.
Вершины конфигурация.
Вот. А ребра ориентированная...
Да, или дуги, как еще раз говорили,
з However,
или дуги, как еще говорят,
значит, ориентированные ребра соответствуют допустимым переходам.
Раз у нас не детерминизм, то у нас, может быть,
для одной и той же исходной конфигурации
несколько допустимых переходов.
рёбер выходить из одной и той же вершины. Ориентированные рёбра, допустимые переходы.
Ну и вопрос такой, есть ли в этом графе ориентированный путь изначальной конфигурации
в принимающую. Соответственно, вопрос, который нас интересует, значит, это есть ли в этом
графе, есть ли в этом графе ориентированный путь изначальной конфигурации в принимающую.
Вот. Можно для простоты считать, что у нас есть только одна принимающая
конфигурация. Например, мы искать конфигурацию принимающей если это там принимающие состояния,
но можно считать, что мы добавили ещё одну фиктивную конфигурацию и из любой
конфигурации с принимающим состоянием добавили ребро вот в эту фиктивную конечную.
тогда и просто вопрос о пути в графе, вот, но вопрос о пути в графе это очень
известный алгоритмический вопрос, и я думаю все должны прекрасно знать, что он
решается за полинамidное время, в том числе и в ориентированном графе, то есть
получается, что вопрос о пути в графе решается за полинамидное время.
Ну вот, соответственно, получается, что граф полинамидного размера, мы его строим
явным образом, можно просто выписать все возможные конфигурации, проверить для
каждой конфигурации, откуда там идут ребра, и потом, соответственно, для
полученного графа решать задачу о достижимости. Ну вот, ну вот, поэтому NLFP
вложено. Да. Нет, память-то обычная, это машина недетерминированная, недетерминированная
машина означает, нет, значит, для детерминированного тоже можно построить
такой граф, но там просто из каждой конфигурации будет выходить ровно одна
стрелка. Вот. И соответственно, если мы пойдем изначально, то мы можем просто
по этим стрелкам идти и смотреть, куда придем. Вот. А если он недетерминированный,
то может из каждой точки выходить несколько стрелок, и тогда просто так мы
идти не можем куда попало, да, а надо именно смотреть на достижимость
принимающей конфигурации, да, вот изначальной.
Да, да, да, да, да, да, на всех ветвях, на всех ветвях память ограничена. Вот.
Так, хорошо. Ну и давайте, наверное, еще обсудим вот это вот, да, но почему НП
вложено в PSPACE. Значит, НП вложено в PSPACE. Значит, это вот почему, да,
ну я напомню, что такое НП. В смысле сертификатов у нас было, что х лежит ва,
тогда и только тогда, когда существует у такое, что ва от x и у равняется единице.
Вот. Ну и тогда можно просто перебирать все у, да, значит, можно как бы делать так.
Значит, можно запустить перебор DownGrid, но он потребует полинавиальной памяти.
Значит, перебор, перебор у требует полинавиальной памяти. Значит, почему? Ну как так получается,
что вот мы выделили какой-то блок, да, вот здесь вот у, да, значит, а вот здесь получается вычисление,
вычисление ва от х и у. Вот, и да, получается, что мы сначала взяли у из одних нулей и с ним
вычислили. Потом мы тут как бы, если вдруг единица случилась, то все, да, значит, ответ один. Иначе
мы как бы вот эту память освобождаем, а тут переходим к следующему у, да, все нули в конце
единицы. И с ним вычисляем. Вот. Ну и так далее, да, то есть каждый раз после очередного вычисления
ва от х и у, если получился единица, то мы заканчиваем вычисление с ответом один, если
получился ноль, то мы у инкрементируем и на той же самой памяти, значит, на той же самой памяти
продолжаем. То есть вот это вот ключевое отличие памяти как вычислительного ресурса от времени
стоит в том, что память можно переиспользовать. На тот же участок памяти, где мы уже проводили
вычисления, можно использовать для каких-то следующих вычислений. Вот. И вот за счет этого
получается, что хотя время будет экспоненциальное, память будет полиномиальная. Вот. Ну, соответственно,
для произвольных, дальше для произвольных границ это все будет аналогично. Так, ну что,
какие-нибудь вопросы? Да, перерыв. После перерыва поговорим про конкретные задачи,
ну, сегодня из Эль. А про Эль следующий раз.
Примеры задач из Эль. Так, ну начнем мы с арифметики двоечных чисел. То есть, в общем,
будет три группы задач в этом разборе. Значит, первая группа – это арифметика двоечных чисел,
вторая группа – это синтактический разбор выражений, например, скобочных последовательностей.
И третья группа – это некоторые операции на графах. Значит, первая – это арифметика
двоечных чисел. Вот. Ну и первый пример. Один а – это сравнение. Значит, сравнение,
то есть, есть два числа и х и у в двоечной записи. Нужно понять, кто из них больше. Ну,
скажем, верно ли, что х больше у? Вот. Значит, тут в принципе немножко важно, как именно,
как именно числа записанная. Можно считать, что они просто на разных лентах написаны,
что у нас не одна входная лента, а две входных ленты. Значит, есть х, есть у. Вот. Ну и тут,
соответственно. Ну, значит, в самом простом случае можно считать, что они еще и одной
длины битвы, и если нужно там ведущие нули поставленные, тогда это вообще получается
автоматная задача. Значит, нам даже не нужно вообще никакой памяти. Да, мы просто идем,
значит, если заранее известно, что они не одной длины, то мы идем слева-направо. Значит,
слева-направо смотрим, совпадают символы или нет. Соответственно, если совпадает,
то идем дальше. Если не совпадает, то как бы там, где стоит единица, то и больше. Да, ну,
совершенно естественно. Вот. А теперь давайте обсудим технические моменты. Значит,
во-первых, они могут быть разной длины. Да, например, вот так вот. Тогда, соответственно,
если мы будем идти как раньше, то у нас будет неправильный ответ. Потому что на самом деле вот
это вот больше, там просто больше значих цифр. А если мы будем сравнивать так же, то у нас будет
вот это больше. Вот. Поэтому, ну, тут надо наоборот получается идти. Значит, можно сказать,
что мы наоборот идем с мальших битов. Да, идем с мальших битов, там справа-налево. И дальше,
соответственно, если у нас, да, тут храним как бы результат сравнения текущих хвостов.
Вот. Соответственно, получается, что если у нас очередной бит получается больше, да, то есть,
например, сразу последние биты, да, значит, он больше здесь. Сравним предпоследний, да, больше
здесь. Да, и сравним еще. Ну, и так далее. Значит, если они такие же, то мы оставляем результат
сравнения хвостов. Если какой-то больше, да, то тот, который больше как-бы перебивает все,
что до этого было. Ну, а дальше, если там кто-то один кончился раньше, чем другой, то тогда нужно
проверить, нет ли единицы в том префиксе, который еще остался. Ну, а если там есть единица, то
получается, что это число больше в любом случае. Если там остальные нули, то нужно оставить тоже
результат, который был. Ну вот, в общем, вроде тоже получается, да, что если, значит, если они разные
длины, но на разных лентах, то тоже можно вот так вот сравнить. Вот. Если же они будут на одной ленте,
да, то есть тут как-то написано х, значит, потом какой-то разделитель, потом у, то вот тогда уже
нужна лентграхмическая память, не константная. Вот. Но тогда мы фактически делаем то же самое,
но мы не можем сразу смотреть и на один бит, и на другой, а должны его запомнить и перейти там
куда-то. При этом, смотрите, мы не можем ставить меток, никаких меток не можем ставить, что мы,
скажем, запомним вот этот бит, поставим тут точку, а потом идем туда, возвращаемся слева от того,
где мы ставим точку. Значит, вот так нельзя делать, потому что это будет изменение входа, и это запрещено.
Значит, вместо этого мы будем считать шаги, да, то есть мы как бы, ну, сначала мы там, скажем, идем сюда,
до разделителя, да, на шаг назад, это будет последний бит х. Вот. И у нас есть будет, тут будет
какой-то счетчик. На счетчик, соответственно, мы идем, да, значит, идем по одной клетке направо,
и, соответственно, вот этот вот счетчик увеличиваем на единицу, да, доходим до конца, да, идем назад,
еще там минус один, это будет как раз чему, чему равен этот счетчик. Ну, то есть, это фактически
будет длина у и там плюс один. Вот это вот. И это вот будет как последний бит, теперь мы его сравниваем,
а счетчик запоминаем, копируем, да, то есть тут будет на самом деле счетчик один и счетчик два.
Да, и счетчик один у нас будет сфиксировано после первого прохода, это будет вот, сколько клеток
нужно пройти от какой-то бита икса до соответствующего бита икрика. Вот. А счетчик два мы будем все
время использовать, чтобы понять, где мы находимся. Да, то есть, получается, что мы копируем счетчик один,
счетчик два, идем обратно, каждый раз уменьшая счетчик два на единицу. Когда счетчик два стал нулем,
означает, что мы пришли там вот сюда вот. Ну или там вот сюда уже, в общем, куда-то сюда пришли,
надо точно понять, куда именно. Вот. Но если мы пришли сюда, то мы делаем еще один шаг сюда,
не изменяя счетчики. А потом начинаем снова идти вот сюда вот. Теперь нам будет увеличивать счетчик
два, пока он не станет равным счетчику один. И тогда мы пришли в предпоследний бит икс. Ну и так
получается, что мы ходим туда-сюда, делаем все то же самое, что мы делали вот здесь вот. Но теперь
нам нужна пара счетчиков, чтобы, ну как бы, технически обслуживать весь этот процесс.
Надо уметь сравнить два счетчика, конечно, но тут это уже будет не очень важно.
Не, в принципе, конечно, вы правы. Вы правы, что нужна такая вещь. Но можно сказать, что мы сделаем
рекурсивные, там сегов рекурсий будет совсем немного, потому что счетчики будут логерифмически
длинные. Вот. Можно как-нибудь иначе организовать хранение. Например, у нас будут чередоваться бит
счетчика 1, бит счетчика 2, и мы будем сравнивать просто проходя по ним и сравнивая по литовым.
Да, в общем, ну главное, что поскольку эти счетчики логерифмического размера, то с ними уже гораздо
проще. Да, с ними почти все что угодно можно делать, и это как раз тот самый логерифмический размер
займет. Вот. Хорошо, так. Ну, формально, конечно, нужна какая-то общая теорема. Да, общая теорема
заключается в том, что класс L не зависит от числа лент рабочих, ну и рабочих тоже, но и входных,
что нам здесь самое главное. Вот. Ну а доказывается, теорем примерно так же, как здесь, да, то есть
вместо, так, заводятся счетчики, которые отвечают за то, куда показывают головку на каждой ленте,
и, соответственно, там как-то все обрабатывается. Так.
Так, хорошо, значит, дальше следующий пункт, там 1b, 1b, сложение. Ну, смотрите, вообще, сложение,
да, это же не вопрос, ответом да или нет, это функция, но, соответственно, как всегда с функцией можно
использовать два подхода. Во-первых, можно считать, что у нас прямо функция вычисляется, но побитого,
то есть, например, у нас есть еще выходная лента, на которую ответ пишется шаг за шагом, да, или,
ну да, да, да, да, да, да, в общем, что есть выходная лента, которая не используется при подсчете памяти,
и на которую просто время на время поддаются биты ответа, да, значит, слева направо. Вот. А или можно
считать, что это вопрос о проверке правильности, да, что у нас есть там три числа, a, b и c, и нужно
понять, верно ли, что a плюс b равно c. Значит, тогда это будет ответ да или нет.
Ну, например, вот. Ну, тут, опять же, если у нас все-таки нету ответа, то желательно его вычислить.
Вот. Но, в общем, можно и вот про такое спрашивать. Так. Ну, как это делается? Ну, опять же, зависит
от того, как у нас записана информация. Если вообще все a, b и c записаны на разных лентах,
значит, будет a, b и c. Тогда, опять же, достаточно даже константной памяти работает стандартный
алгоритм в столбик, да, что он просто, ну, конечно, мы просто каждый раз смотрим на три бита,
и еще есть как бы бит переноса, да, есть бит переноса, да, и мы, соответственно, сфенируем два
очередных бита и бит переноса, и, соответственно, проверяем, что сумма, да, то есть, ссоры этих битов,
это то же самое, что написано вот здесь вот. Ну, а бит перенос, получается, что если там хотя бы две
единицы из этих трех битов, да, то бит перенос и на следующий раз тоже переходит.
Нет, подождите, вот это я нарисовал вот для такого, что у нас уже есть a, b и c, но чтобы проверить
справедливость. Вот. А, соответственно, если нам нужно писать ответ, да, то это означает,
что просто по одному бит и надо выписывать. Ничего нельзя, может только на нее очередной бит напечатать,
а читать с него нельзя уже. Да, нет, это вы спрашиваете, в каком порядке можно записывать ответ. Да,
соответственно, действительно, если мы записываем вот так вот, да, то получается, что мы записываем его с младших бит,
начиная. Вот. Но, на самом деле, конечно, если немножко повозиться, да, то можно и со старших
начинать, да, то есть можно просто, как бы, все эти младшие биты не печатать, да, а просто, да,
значит, дойти до сюда и вот этот бит напечатать. Вот. А потом и нужен еще счетчик, да, вот тут
будет счетчик, да, сколько бит уже напечатали. Да, пойдем, как бы, пойти обратно, вычислять это все еще раз,
и теперь второй бит напечатать. Да, это, конечно, очень неэффективно, да, значит, это очень неэффективно,
но, в принципе, допустимо. Вот. То есть память рологрифическая будет, да, как раз, как раз счетчик будет
заведен. Вот. Ну, реально, в реальных процессорах сложение даже не так делается, это мы попозже
обсудим, как именно там есть специальные, специальные способы ускорить этот процесс. Так, хорошо,
значит, ну, это вот сложение, ну, и дальше третья вещь, это умножение. Значит, умножение, соответственно,
тут будет a умножить на b равно c. Вот. Ну, тогда получается так, что, смотрите, если у нас a будет
равно, например, a n минус 1, a n минус 2 и так далее, a 1 на ноль, да, побитого, значит, b это будет b n
минус 1, b n минус 2 и так далее, b 1, b 0, то дальше будет получаться следующее, да, что c, да, c может быть длинным,
да, тут будет 2 n минус 1 и так далее, c 1, c 0, и дальше будет получаться так, да, что c 0, и это будет a 0, b 0,
значит, это можно точно написать. Значит, c 1 будет a 0 b 1 плюс b 1 a 0, в смысле b 0, так, давайте так, a 0 b 1 плюс a 1 b 0,
вот, но это уже может быть равно двум, да, соответственно, это только последний вид, это будет, да, по моделю два. Вот, а вот c 2 уже будет,
да, это будет a 0 b 2 плюс a 1 b 1 плюс a 2 b 0, и еще плюс перенос, да, значит, именно если вот это было равно единице, то, соответственно, если это было равно двум, то еще единица пошла как перенос, вот, но, в принципе, и так далее.
Да, значит, тут будет и так далее, но только в чем отличие от сложения в том, что переносы могут быть не только на один бит, а сразу на несколько бит вперед, да, потому что дальше тут будет много слагаемых,
и эти слагаемые могут быть в сумме дать, могут в сумме дать не два и не три, а какое-то большое число, вот, и это большое число даст переносы сразу на несколько предыдущих разрядов, но, в принципе, можно считать, что вот этот перенос, это то, что было вот здесь вот пополам, ну, или там, без последнего бита, вот, и так дальше это будет, но, в общем, важно, что вот этот перенос, значит, перенос будет
уж не больше, чем n, да, сам перенос будет не больше, чем n, а, значит, занимает не больше логарифма, да, значит, занимает меньше или в равно логарифма n битов, ну, и, соответственно, мы его будем хранить, ну, и для хранения переноса достаточно как раз логарифмического числа b.
Ну, тут тоже получается, что мы ответ с конца опечатаем, если вдруг нам нужно сначала без использования дополнительной памяти, то, ну, можно только, опять же, вычислять соответствующий бит, да, и его опечатать.
Так, ну, чего, понятно про умножение? Значит, вот тут ключевой момент, да, ключевой момент, что перенос может быть не одним битом, да, а логарифмом битов, и получается, что тут, значит, в отличие от предыдущего и от сравнения и от сложения, мы не можем, значит, мы не можем организации памяти сделать так, что нам нужно вообще константами дополнительной памяти, значит, нам все равно нужно хранить перенос, и он все равно будет логарифмический.
Да, то есть даже если мы делаем так, что нам не нужны эти технические счетчики, все равно получается, что нам нужен логарифм для хранения переноса.
Так, ну, чего, понятно? Так, ну, ладно. Хорошо, значит, тогда поговорим про скобочные последовательности.
Вот, так, значит, второе.
Значит, второе это вот синтактический разбор, значит, синтактический разбор.
Ну, соответственно, тут пункт два А это правильная, правильная скобочная последовательность.
Вот, ну, что такое вообще правильная скобочная последовательность?
Ну, там есть несколько разных определений, минимум три.
Значит, есть определение как бы просто через разбивание скобок на пары, что можно разбить скобки, что там четное число открывающих и закрывающих скобок, их можно разбить на пары так, что в каждой паре открывающий идет раньше закрывающий.
Вот, можно также потребовать, чтобы это было, ну, в некотором смысле правильно, что, например, смотрите, если мы просто требуем разбивания на пары, то, может быть, например, вот эту, что вот эта скобка вот с этой в паре, а эта скобка вот с этой в паре.
И тогда, вроде как, они разбиты, но это не совсем то, как мы ожидаем, мы ожидаем, что вот внутренние будут в паре и внешние будут в паре.
Ну, на самом деле это неважно, если хоть как-то разбиты, можно их перегруппировать так, чтобы они были вложены как надо.
Соответственно, есть такое рекурсивное определение, есть рекурсивное определение, что, соответственно, пустое слово, пустая последовательность, это правильная скобочка, если там нет ни одной скобки.
Это как бы база рекурсии, что пустая последовательность, это правильная скобочная последовательность, дальше, если есть какая-то правильная скобочная последовательность, то можно ее взять в скобки вот так вот.
Вот, ну и наконец, если есть две, f1 и f2, правильная скобочная последовательность, то можно их приписать одну к другой, и это тоже будет правильная скобочная последовательность.
Соответственно, если мы берем как бы в паре вот эти вот две скобки, тогда уже никакого перекрытия не будет получаться, то есть вот это будет получаться, что мы сначала взяли пустую, дальше ее взяли в скобки, получилась просто скобка открывается, скобка закрывается, и вот это вот еще раз взяли в скобки.
Вот, ну а также есть еще третье, третье эквалентное свойство, значит критерий, значит критерий через баланс скобок, значит критерий такой, что
значит во всей цепочке баланс нулевой, то есть открывающих столько, сколько закрывающих, значит во всей последовательности баланс равен нулю, а в любом префексе
в любом префексе больше ли в район нулю, то есть получается, что значит в любом префексе открывающих не меньше, чем закрывающих, но вообще можно сказать, что все эти три свойства эквивалентны между собой, но проверять удобно как раз последние
свойства, потому что можно просто идти слева-направо, идти слева-направо подсчитывать баланс, если вдруг он опустился в минус, то говорить, что ответ нет, если дошли до конца, то проверить, что он равен нулю, если равен, то сказать да, при этом нам нужен один счетчик, значит нам нужен один счетчик для баланса, и как раз баланс уже не больше, чем
число символов, то есть баланс не больше, чем n, но и соответственно требуют алгоритмы n-битов, да, это еще тоже тут все очень важно, что мы используем двоечную систему, так что числа порядка n требует как раз алгоритмы n-битов, вот, ну вот соответственно вот этот вот критерий через баланс получается, проверяется, проверяется на, не наполиняем, не наполиняем, не наполиняем, не наполиняем, не наполиняем, не наполиняем, не наполиняем, не наполиняем, не наполиняем, не
наполиняем на алгоритмической, значит на алгоритмической памяти. Вот, хорошо,
так ну чего понятно вот мой дать последний на сегодня
значит граф оставим на следующий раз вот а сейчас
поговорим про последовать последовательности из
двух или нескольких типов скобок последовательности
нескольких
типа вскобок
например есть круглый есть квадратная а вот если у
на кисти круглый квадратная то как раз вот такая штука
может стать проблемой
Ferantwort
примерественно у нас круглый открывается потом квадратный
закрывается потом круглые закрываются 저는 закрывается
на то здесь все хорошо со всеми балансами
но это, тем не менее, неправильное. Тут, действительно, мы можем разбить на пары, чтобы открывающая была раньше закрывающей.
Да, все балансы, какие надо, но, тем не менее, это неправильно.
Значит, вот это вот неправильное.
Вот. Какая тут проблема?
Ну, проблема в том, что, если мы найдем парную к этой скобке, то внутри будет неправильная последовательность.
А вот весь вот участок, участок между парными скобками неправильный.
Ну и, соответственно, алгоритм будет нацелен на то, чтобы проверять, чтобы для каждой скобки искать парную ей,
и проверять условенно баланс между этими скобками.
Соответственно, алгоритм для каждой скобки, для каждой скобки искать парную,
и, соответственно, проверять условия на баланс, условия на баланс по каждому типу скобок, по каждому типу скобок, соответственно, между ними.
Вот. Ну, тут, понятное дело, значит, нужно некоторое доказательство, что это будет правильно.
Вот. Ну, более-менее, ну, а для этого нужно, на самом деле, сначала определение,
а определение, на самом деле, будет такое же рекурсивное, только вот здесь, вот когда мы добавляем скобки, они могут быть разных типов, но парные друг к другу.
Да, то есть в данном случае будет вариант, вот такой будет вариант с квадратными.
Вот. Если больше типов, то больше вариантов.
Вот. Ну и тогда, понятное дело, что баланс по каждому типу скобок тут всегда будет выполнен,
ну и как раз парное к этой будет вот это, и внутри тоже будет все выполнено.
Вот. Ну, надо еще обратно доказывать, да, что если баланс выполнен, тогда можно так разобрать.
Вот. Это я уж не успею формально доказать.
И давайте я чуть-чуть расскажу, как именно этот алгоритм будет работать и почему ему нужна алгоритмическая память.
Посмотрите, как искать парную.
Ну, мы идем слева-направо, считаем баланс по этому типу скобок.
Да, то есть тут, давайте какой-нибудь там пример.
Ну, что-нибудь вот такое вот, да, или тут там что-нибудь еще.
Да, вот мы идем вот здесь вот, да, у нас тут будет, значит, один, два, три, потом два, три, два.
Дальше это мы пропускаем, да, то есть тут как бы оставляем баланс два,
тут получается один, один, два, один, один, ноль.
Да, то есть квадратная скобка любая не меняет числа, да, открывающая круглая увеличивает, закрывающая уменьшает.
И вот то место, где мы впервые обратились в ноль, это и будет парная.
Да, то есть вот это вот будет как раз парной вот к этой.
Вот, ну, ясно, что этот баланс, он, опять же, будет не больше n, поэтому требуют алгоритма битов.
Вот, но кроме того, да, значит, мы же не можем метку поставить.
Нужен еще счетчик, который будет подсчитывать, сколько мы всего тут скобок символов прошли.
Вот, а потом можно сказать, что мы идем просто обратно,
и уже считаем, ну, может считать, что по этому типу мы уже проверили, что все есть,
что все верно, да, идем по другому соответственно.
Да, по другому типу скобок проверяем, что по нему тоже все нормально.
Почему что?
по этому типу, но потому что тут автоматически, если мы взяли первое место, когда он обращается в ноль,
то тогда между ними все это будет положительное, да, и в ноль не обращаться.
Вот, поэтому нужно по квадратным проверить, но в данном случае все будет верно.
Но, соответственно, нужно еще счетчик, да, чтобы мы знали, докуда проверять.
А что мы проверяем с квадратом?
Тоже баланс.
Ну, мы только его справа-навево проверяем, но справа-навево тоже самое должно быть.
Вот, а если, например, тут было там не вот так вот, а вот так вот,
то получилось бы, да, что мы идем, и тут по квадратам не скользится баланс.
Да, будет ответ «нет».
А может быть, например,
может быть, например,
вот так вот,
да, значит, тогда, если мы вот это вот проверяем, то тут по квадратам тоже все будет хорошо.
Да, поэтому это нужно для всех, да, значит, для всех открывающих найти парную закрывающую, это проверить.
Да, в данном случае, значит, в данном случае, если мы возьмем вот такую вот пару,
да, это будет как раз открывающая закрывающая, и вот в ней по квадратам будет неправильно.
Вот. Ну, в общем, получается, что мы, что у нас нужен счетчик, чтобы подсчитывать, куда нужно прийти.
Да, нужен счетчик, чтобы подсчитывать баланс.
Нужен счетчик, чтобы подсчитывать другой баланс по другому типу скобок.
Но их будет какое-то небольшое число, три счетчика, каждый занимает логарифминитов.
Значит, всего памятного логарифмическая.
Вот. Ну, и вот это вот, давайте,
итоговая фраза, итоговый принцип, что
суть того, что нам нужна логарифмическая память,
заключается в том, что мы используем константу счетчиков,
каждая из которых принимает пальномиальные значения.
Тогда каждый из них требует логарифма битов,
и все вместе, раз их константы, тоже требует логарифма битов.
Вот. Вот это вот суть того, что такое класс C.
Все, спасибо за внимание.
