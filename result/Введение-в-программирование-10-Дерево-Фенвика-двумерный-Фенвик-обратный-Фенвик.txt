Вот, значит, смотрите, мы поговорили с вами про дерево
отрезков, про онлайн против оффлайта в прошлый раз.
Сегодня мы рассмотрим еще одну структуру данных,
которая называется дерево фенвика.
Дерево фенвика.
Вот.
И в контесте, который, ну, вот сейчас третий идет
на кодфорсис, там две задачи есть на дерево фенвика.
Точно.
Вот.
И прелесть его в том, что он очень легко обобщается
на большей размерности.
Как, например, есть у нас дерево отрезков на массиве
работает, там всякие суммы на отрезках, изменений
в точке делает.
Вот.
А если рассмотреть ту же задачу, ну, примерно такую
же, да, там сумма на отрезке и апдейты точки, но, скажем,
когда вы живете не в массиве, а в табличке, и тогда, соответственно,
у вас с там под прямоугольника какого-то изменения в точке
или даже не в табличке, а в трехмерном кубике таком,
то же самое.
Апдейты точки и сумма на под кубе.
Тогда дерево отрезков там работает, ну, с большим
трудом, это сложнее обобщать, ну, просто потому что больше
кода будет.
Вот на дерево фенвика обобщается очень-очень просто.
Одно удовольствие – писать фенвика в больших размерностях.
Вот мы сегодня поймем, как это все делать.
Значит, ну, сначала давайте вспомним нашу модельную
задачу.
Самая простая задача, которая решается с помощью, в частности,
дерево фенвика.
Значит, есть массив, а0, и так далее, а n-1, и два типа
запросов.
Первый – это апдейт в позиции поз значением вал, нужно
увеличить число на позиции поз на вал, сделать плюс
равно в точке, и второй – это гетсум на отрезке.
Гетсум, соответственно, по индексам LR, нужно найти,
то есть там вывести AL плюс L плюс 1, плюс так далее,
плюс AR.
Вот такая классическая задача у нас была, мы ее умеем решать
с помощью дерево отрезков, а сегодня мы просто познакомимся
с еще одним способом, как ее решать, и этот способ
нам тоже будет чем-то полезен, вот, в частности, он позволит
нам выйти в большей размерности.
Так, ну смотрите, давайте, я повторю наш массив, какой-то
вот такой он будет, давайте введем следующие две очень
странные функции.
Давайте скажем, что f от i – это i and i plus 1, это вот
логическая i, логическая побитывая i, и нам еще нужна
будет функция g, и это i или i plus 1, или это логическая
побитывая.
Вот эти андерсант и палочка – это то, как они реализуются
в C++.
Первая уже была, кстати.
Было что-то похожее, когда на семинарах было про
спортстейбл.
А, ну и здесь, кстати, у нас такое было, когда мы пытались
определять, является ли число степенью двойки.
Да, вот это точно было.
Ну еще что-то похожее было в доме задачи про спортстейбл,
там когда неидомотетные операции были, ну в общем,
кто смотрел тоже что-то знакомое, возможно сейчас
тоже увидит.
Вот, но тут не нужна никакая, никакие предварительные
сведения.
Я все расскажу.
Итак, мы все-таки определили такие две функции, и тогда
давайте скажем, что s и t для каждого i – это сумма
на отрезке с fi до i чисел ajt от fi до i.
То есть, смотрите, понятное дело, что когда мы берем i
в конъюнкции, то есть побитывая i, тяжело, да, есть i переменная,
есть i как операция, короче, когда мы берем конъюнкцию
побитывая двух чисел i и i плюс один, то понятное
дело, что результат будет не больше, чем i.
Да, понятно, что fi не больше, чем i, потому что там i берется
в конъюнкции с чем-то, конъюнкция может только уменьшать каждый
бит.
Ну, значит, это какой-то отрезок, обязательно не вырожденный,
когда у нас левая граница – это fi, а правая граница
– это i.
Это обязательно какой-то отрезок, ну вот, собственно,
с него мы посчитаем какую-то сумму.
То есть, если у меня был какой-то массив наш исходный,
то для каждой позиции i я считаю fi – это какое-то
число, находящееся левее, ну или совпадающееся с самим
i.
И вот на этом отрезке я нахожу сумму.
Вот с этого отрезка я считаю сумму.
Это, соответственно, для всех i от 0 до n-1.
Для всех i от 0 до n-1.
Вот, то есть мы посчитаем такие суммы на отрезках.
И если в дереве отрезков было что-то похожее, там
тоже были суммы с под отрезков каких-то, но только там были
они по степням двойки как-то устроены.
Здесь вот с помощью этой функции определяются все
отрезки, то есть в качестве правого конца выступает
любая точка нашего массива, в качестве левого конца
выступает f от этой правой границы.
Вот у нас будет n таких сумм.
N сумма, n точек.
Для каждой точки своя сумма.
Ну и тогда можно написать сразу следующее.
То есть предположим, что у меня этот массив s как-то
насчитан.
Тогда можно сразу решить задачу суммы на префиксе.
Значит, как можно написать getSum?
Ну давайте я напишу getPrefixSum.
GetPrefixSum.
То есть нам нужна на отрезке, скажем, нам нужна сумма
на отрезке от 0 до pos.
Решение будет очень простое.
Ну смотрите, у меня есть сумма на любом отрезке
с, точнее для любого правого конца, у меня есть сумма
на каком-то отрезке, где правая граница именно такая.
Тогда давайте посмотрим на этот pos.
Давайте возьмем от него f от pos.
И соответственно мы знаем сумму на вот этом отрезке.
От f pos до pos.
Вот здесь мы знаем сумму.
Соответственно тогда дальше pos уменьшим до этой точки.
То есть скажем, что pos равно f от pos-1.
Встанем в эту первую нерассмотренную ячейку.
И то же самое, возьмем от нее f.
Посчитаем здесь сумму.
Мы благо знаем, чему равна сумма на каждом таком отрезке.
Она лежит в массиве s.
Оттуда сумму знаем, добавляем ее к ответу.
Потом опять изменяем pos на вот эту точку,
которая лежит самая правая нерассмотренная.
Ну и так прыгаем, прыгаем, пока весь массив не пропрыгнет.
В итоге код будет такой.
Значит сначала мы говорим, что ans равно 0.
Потом, ну скажем, заводим какую-то переменную i,
которая изначально равна 0.
Всегда не отрицательная.
И функция перехода здесь такая.
i равно f от i-1.
Потому что f от i-2 это левая граница, которая включена.
И мне нужно еще на 1 сдвинуться, чтобы получить первую невключенную точку.
И в итоге нужно просто к ответу прибавить ks и t.
ans плюс равно s и t, return ans.
Вот такой несложный код позволяет нам найти сумму на претексе
от нулевого индекса, от нулевой позиции до посты.
От нулевой до пост.
Ну мы просто так прыгаем.
Мы знаем сумму на каких-то кусочках.
Давайте вот их все просто сложим
по тем стрелочкам, которые у меня получаются.
От этого f я их складываю, складываю.
В результате получается как раз сумма на отрезке 0 до pos.
Оказывается, что это будет работать эффективно,
потому что функция f такая крутая,
что эта цикла будет работать максимум от логарифма ходов.
То есть не больше, чем 20 логарифм от i,
ну или точнее от n будет итерация в этом вот форике.
Давайте тогда сначала с этим разберемся.
Сначала мы поймем, как делать вот этот getSum.
То есть как узнавать сумму на префиксе.
Ну, сразу скажу, что если мы знаем, как находить сумму на префиксе,
то сумма на любом отрезке сводится к 2-ым запросам на префиксах.
Потому что, если нам нужна сумма на том-то отрезке,
мы можем взять сумму на таком префиксе,
вычесть сумму на таком префиксе,
и как раз получиться сумму на нужном отрезке.
Поэтому если мы решаем заслуживание про суммы,
то можно считать, что запросы поступать только на префиксах.
Потому что отрезок от префиксов почти ничем не отличается.
Нужно просто вычесть там два числа.
Теперь, если мы докажем, что вот эта вот штука работает за логарифом, то есть что максимальная длина этого цикла, сколько раз он повторяется, это от логарифа, тогда мы можем отвечать на запрос нахождения суммы отрезка за логарифом, за от логарифа.
Потом нужно будет еще научиться делать апдейт, но это давайте пока что чуть позже сделаем, пока что разберемся с GetSum.
Давайте я восстановлю эту строчку.
И вот pos до большего равна нуля и равно f at – 1.
Вот это как раз перебирает все незадействованные i, вычисляя f at, находит сумму на отрезке, начинающуюся в fe, знакомящуюся в i, на нем берет сумму, добавляет к ответу.
И все такие отрезки мы проходим.
Значит, работает за отлогарифом. Почему?
Для этого надо понять, что делает функция f с битовой записью числа i.
Вот давайте мы представим, как написано i, то есть чему равно i, чему равно, соответственно, i плюс 1, который участвует там в конъюнце, и чему, соответственно, будет равно f at.
Вот давайте напишем. Пусть есть какое-то число i.
Оно устроено так.
Ну, точнее, мне нужно понять, в чем отличие между i и i плюс 1.
Отличие вот в следующем, что в i, чтобы из i получить i плюс 1, мне нужно посмотреть на максимальный блок единиц в конце, в числе i, ну и, соответственно, перед этим блоком будет 0.
И тогда, когда я прибавляю единицу, у меня все вот эти вот младшие единицы зановятся, и единица перейдет в старший разряд, и вместо одного из нулей будет единиц.
Вот так в любом случае, ну, точнее, для каждого i работает у меня прибавление единицы.
Мы вычленяем последний блок, последний наибольший блок из единиц, то есть просто смотрим, сколько в двоечной записи единиц в конце, их, возможно, будет 0,
тогда просто вот этот вот как бы отрезок пустой, этого ничего нету, и просто младший 0 меняется на младшую единицу.
Но если их там несколько, то просто после прибавления у меня эта единица будет проталкиваться, проталкиваться вот так вот по разрядам.
В итоге она осядет вот здесь вот, в итоге младшая единица заменится нулями, а самый правый 0 заменится на единицу.
Ну и тогда f от t, это нам нужно просто взять конъюнцию побитую этих двух строк, соответственно, здесь все неизменное,
этот блок какой был здесь, такой останется здесь, такой перенесется сюда, потому что конъюнция двух одинаковых блоков, это он сам.
Ну а здесь все зановится, потому что 0 ант-1 это 0, 1 ант-0 это 0, здесь 0, здесь 0, здесь 0, здесь 0.
В итоге вот как можно выразить, что делает f от i. f от i зановляет, зановляет, как бы это сказать?
Зановляет блок младших единиц, младших единиц.
То есть если у меня на конце было несколько единичек, то чем отличается i и f от i?
Отличается только тем, что вот этот как раз блок из единиц целиком превратился в 0, больше ничего не поменялось.
То есть f от i просто берет, рассматривает все младшие единицы справа налево, пока не дойдет до 0, и все эти единицы превращается в 0.
Как раз преобразование f от i ровно так и работает, превращает младшие единицы в 0.
Тогда что такое f от i минус 1?
Ну здесь тогда нужно из вот этого числа, которое написано выше, из f от i вычесть единицы.
Понятно, что эти нули превратятся в единицы, эти нули превратятся в единицы, ну а здесь еще что-то произойдет.
Давайте напишу, здесь что-то странное происходит, потому что, например, если здесь было еще несколько нулей, то они тоже все превращаются в единицы,
а соответственно младшие единицы превратятся в 0. Это будет вычетание единицы.
Но мы не особо будем заботиться над тем, что происходит вот здесь, то есть тут какое-то преобразование.
Самое главное, что когда мы переходим от i к f от i минус 1, мы самый младший нулик заединичили.
То есть раньше он был нулем, теперь он стал единицей, а все более младшие единицы остались на месте.
Поэтому, когда мы делаем переход от i к f от i минус 1, у меня происходит следующее.
Младший 0, младший 0, зануляется,
наоборот, становится единицей, становится единицей,
становится единицей,
и еще что-то возможно происходит слева, что-то еще может происходить
в более старших разрядах.
Но это несущественно. Для нас самое главное, что просто младший 0 превратился в единицу.
И это в частности означает, что число раз, когда мы входим в цикл,
то есть сколько раз мы можем к i применить преобразование вот этого,
и получить f от i минус 1. Но явно не больше, чем исходно в нем было нулей.
Ну, точнее, не сколько исходно в нем было нулей, а сколько вообще может быть нулей в числе.
Потому что мы взяли 0, превратили его в единицу.
Дальше, если еще раз применяем преобразование, мы берем вот эту вот 0, превращаем его в единицу.
И так далее. То есть все более младшие единицы у нас сохраняются,
мы просто должны взять какой-то 0 и заединичить его.
Но тогда понятно, что количество шагов, в которых мы можем это сделать,
это количество шагов не превышает общего возможного числа бит.
Значит, число шагов не превышает общего числа бит в i.
То есть не больше, чем двойственного грифа.
Ну, тут у меня написано log m, неважно там log i, в кочем-то случае может быть log m,
поэтому сверху сделаю цинку просто log m.
Все, значит, количество итераций фора не больше логарифа.
Что мы и хотели?
Получается, что запрос суммы на префиксе у меня реализован уже за логарифом.
Так, едем дальше. Дальше нам нужно научиться обрабатывать апдейт.
Дальше нужно научиться обрабатывать апдейт.
Update pos val.
Давайте я нарисую, напишу код, который обрабатывает апдейт,
и мы с вами докажем, что он все делает корректно и за нужную симпатику.
Код очень простой.
Для всех i от pos до n, i равно g от i, s и t плюс равно val.
Конец.
Тоже очень простой код.
Ладно, тут слишком много отличий, я не буду говорить, что это...
То есть это во многом похоже на то, что у нас было раньше, в предыдущем кусочке,
когда мы по f от i прыгали.
Только здесь, во-первых, другой переход, i равно g от i.
Здесь другие начальные и конечные условия,
но, соответственно, мы не сумму, не к ans, не к ans прибавляем s и t,
а, наоборот, s и t увеличиваем на какую-то константуал.
Значит, почему это то, что нам нужно?
Смотрите.
Вообще давайте напишем условия, какие s и t нужно поменять.
Представляем себе, что a pos t увеличивается на val.
Ну, собственно, происходит то, что в запросе.
Тогда вопрос, какие s и t должны поменяться?
Какие s и t меняются?
Ну, явно те и только те, в отрезке которых есть pos.
Значит, мне нужно увеличить s и t на val, если и только если
выполняется такое условие, s и не больше, чем pos и не больше, чем i.
Потому что для каждого i число s и – это сумма на отрезке с fi до i.
Соответственно, эта сумма может поменяться,
только если в нём, внутрь, в него попало число a pos t.
У gt здесь он находится.
Но это в точности условие, что fi t меньше равно pos меньше равно i.
То есть мне нужно, чтобы обновить мой массив s,
вот этот массив сумм на странных наших отрезках,
мне нужно просто пройтись по всем i с вот этим условием
и в них увеличить s и t на val.
В них во всех s и t увеличить на val.
Это вот, что мне нужно сделать.
И я утверждаю, что этот код делает ровно то, что мне нужно.
Делает ровно то, что мне нужно.
Ну, давайте поймём, почему это верно.
Давайте поймём, как устроены вот эти i с условием, которые тут написаны.
Давайте я напишу где-нибудь i.
Выделю в нём блок единиц в конце максимальный.
Напишем f at.
Сейчас, пардон, хочу немножко по-другому нарисовать.
Я нарисую сначала f at.
Здесь будет место для pos, здесь будет i.
И это что? Это какой-то блок старший вид,
на который мне фиолетово.
Потом будет 0, потом будет куча единиц.
f at, напоминаю, у нас за нуляет последний блок единиц.
То есть, старшие разряды остаются неизменными,
нолик остается неизменным,
а вот эти все младшие единицы превращаются в нули.
Тогда вопрос.
Когда может быть такое, что pos меньше равно i и pos больше равно, чем f at?
То есть pos находится между этими значениями числа.
Всё очень просто.
У pos должны быть вот эти биты такие же, как у i и у f at.
То есть, тоже написано вот здесь.
Оно такое же, как здесь и вот здесь.
Ну и вот здесь тоже написан нолик.
То есть, этот ноль должен быть...
Ну, понятно, да?
То есть, если у меня число pos заключено между f at и...
И у них вот такой есть общий префикс у всех,
то и этот общий префикс есть в частности в числе pos.
А вот здесь, соответственно, ну, здесь как бы что угодно.
То есть, тут что угодно.
В итоге какое у меня условие получилось на i?
Как выглядит i?
И выглядит так.
Мне нужно оставить какой-то префикс в pos, который заканчивается нулём,
а правее этого префикса записать единицы.
То есть, я беру произвольный начальный отрезок pos.
Вот представьте, что у меня есть число pos,
который заканчивается нулём, и там справа ещё что угодно.
Так вот, давайте я просто то, что было правее,
я буду просто игнорировать и заменю единицами.
И вот это будет одно из корректных значений i.
И, соответственно, мы поняли из вот этой вот картинки,
что любой i таким образом получается,
что нужно просто взять какой-то префикс из pos,
потому что, смотрите, вот эти вот...
Давайте нарисую.
Вот эти вот красные кусочки совпадают.
Вот эти красные кусочки совпадают.
Значит, i таково, что это какой-то префикс pos оканчивается нулём,
а потом всё, что написано правее этого нуля, мы заединичили.
То есть, не важно, что там было изначально, мы просто их сделали единицами.
Вот это какое, как бы какие i у меня подходят.
Такие и ровно такие.
Мы как бы их описали целиком.
Вот, ну, хорошо.
Хорошо.
Сейчас мы берём все нули просто.
Так, так, так.
Важно ли, что здесь ноль?
Сейчас, секунду.
Можно вопрос, да?
Так.
Пардон?
Можно вопрос, да.
Да, ну, смотрите, хорошо.
Значит, единственное, когда это, видимо, может не работать,
когда у меня вот здесь вот нет ни одной единицы,
и тогда, соответственно, мне нечего вот здесь вот заменять.
Так, извините, момент.
Не так сказал.
Значит, наоборот, да?
Мне ещё, у меня вот есть такой случай, когда i равно pos.
Ну, понятно, что i равно pos всегда нам подходит,
даже если, скажем, pos нечётное.
То есть, когда вот, не знаю, pos вот такое.
Сейчас я его где-нибудь нарисую.
То есть, когда pos вот такой заканчивается единицей,
то мне такое i тоже подходит.
Ну, потому что если я возьму pos равно i,
то понятно, что i удовлетворяет этому условию,
что f at и меньше равно pos меньше и меньше равно i.
Так вот, такое точно мне подходит.
А дальше, смотрите, какие я перебираю значения i.
Я навешиваю многократное число g.
Точнее, функцию g.
Я навешу многократное g.
И теперь мне нужно понять, как действует g.
То есть, мы поняли, какие i нужно перебрать.
Вот эти вот, да?
Оставить какой-то префикс и заединить всё, что правее.
Теперь давайте тогда поймём, как действует функция g.
Переключаемся дальше.
И задаем себе вопрос, как действует g.
Сейчас вопрос.
Секунду.
Как действует g?
Условия задачи, это, видимо, вот это, да?
Я правильно вас понимаю?
Или условия задачи, которые мы решаем исходно?
Исходно мы решаем вот такую задачу.
Update с точки, сумма на отрезке.
Да, всё.
Вот такая. Update с точки.
То есть, pos равно в точке.
И сумма на отрезке.
Для произвольных индексов найти сумму на отрезке.
Ещё вопрос насчёт того, как мы и выбираем.
Ну хорошо, значит, мы теперь хотим понять, как действует функция g.
Не слышно?
Нет, я вас не слышу.
Хотя у меня звук включён.
А скажите сейчас что-нибудь.
Раз-раз-раз.
Это хорошее.
Кто-нибудь?
Приём.
Так, я ничего не слышал.
А, а теперь?
А теперь слышу.
Я короче давно уже пытался задать вопрос.
Извините.
Сейчас мы и берём просто любой ноль.
И всё, что правее него, заединичиваем.
И для любого ноля заединичиваем всё, что справа.
Всё, окей, спасибо.
Да, извините, пожалуйста.
Я не в тот поток поставил звук.
Да, теперь я вас слышу.
Так, ну что же, разбираемся со функцией g.
Значит g, напоминаю, g от i.
Это i or i plus 1.
Хорошо.
То же самое сделаем.
Давайте мы выделим в i последний блок из единиц.
То есть нолик и куча единичек.
Нарисуем i plus 1.
Раз нам нужно посчитать or, то мне нужно i plus 1.
Это тот же самый префикс.
Потом один и потом куча нулей.
И наконец считаем g от i.
Префикс не изменится,
потому что or двух одинаковых блоков.
Это тот же самый блок.
То есть это всё одно и то же.
Ну а здесь вместо нулей будут все единицы.
Здесь вместо нулей будут все единицы.
Ну потому что как раз or единицы нуляет единицы.
В итоге g от i действует так.
g от i заединичивает,
то есть превращает в единицу.
Младший 0.
Младший 0.
Берёт самый младший нулик,
то есть самый правый нуль в личной записи
и превращает его в единицу.
Вот это вот преобразование такое,
что мы поменяли всего один бит,
младший 0 поменяли на единицу.
Ну и ровно это на самом деле мы и хотели
от всех тех i, которые мы перебираем.
Смотрите, как у нас работало перебор всех i.
Мы рассматриваем все...
Давайте примерно рисуем, наверное.
Давайте разберём какой-нибудь пост конкретное.
0, 1, 1, 1, 0.
1, 1, 0.
1, 1, 1, 0.
Напоминаем, как работают все i,
которые мне нужно перебрать.
Это значит, я обрезаю на каком-то нуле,
и всё, что правее заединичиваю.
Это ровно те i, которые мне нужно перебрать.
Ну, во-первых, у меня есть вот такой и равный пост,
когда я просто обрываюсь на нуле.
Но это просто мы всегда и так отдельно обрываем.
И равно пост.
Это мы переберём.
Дальше я хочу обрубиться вот так.
Ну да.
Дальше я хочу обрубиться как бы вот здесь,
то есть фиксировать, оставить такой префикс
неизменным, а всё, что правее него,
заединичить.
Но смотрите, эти единицы у меня и так единицами стоят.
Поэтому единственное, что меняется
при переходе от вот этого числа вот к этому,
это что вот этот младший 0
заединичивается.
То есть вместо этого нуля должна встать единица.
А это как раз преобразование geote,
geot-посточное.
Если мы начали в пост, то это geot-пост.
Я просто взял младший 0, заединичивал
и получил новое путь,
как бы новое интересующее у меня число.
Дальше мне нужно будет обрубиться вот здесь
и всё, что правее, заединичить.
Но там и так уже одни единицы, кроме вот этого одного нуля,
который самый младший.
Это теперь будет младший 0,
мы его заединичиваем,
получили опять блок из единиц сплошной
и получили опять новое значение.
В итоге мы сделали
ровно то, что хотели.
Мы перебрали все такие начальные куски,
пооставляли их, и всё, что находилось правее, мы заединичили.
Там поставили одни единицы.
И это просто будет число pos,
geot-pos,
geot-pos,
ну и так далее.
Мы просто берём младший 0 и его превращаем в единицу.
И так до тех чисел,
пока они вообще меньше чем n,
они попадают в наш массив.
Кажется, что всё.
Мы вывели критерии того,
какие нам нужны и,
и показали, что функция g делает ровно это,
что она перебирает все такие, которые нам подходят,
и больше никакие.
Заканчиваем степень блоки минус один.
Нет, у Фенрика ещё такая прелесть,
что здесь вообще не обязательно думать про...
А, сейчас.
Степень блоки минус один.
Ну...
Ну, кажется, не обязательно.
Ну, например, смотрите,
вот если у вас плен какой-нибудь вот такой,
я сейчас какой-нибудь нарисую, да,
а pos какой-нибудь вот такое.
Сейчас, степень блоки минус один, да.
Нет, нет, нет, секунду.
Короче, не обязательно, не обязательно.
Вот такой пример.
n такое, pos такое.
Вот.
Значит, тогда вы закончите вот в этом числе,
потому что, когда вы
попытаетесь заединить этот
младший нобик, то у вас получше число больше,
чем n, и, соответственно, оно вылезает за границу массива,
и...
Это плохо, да, мы туда не идём.
То есть, не обязательно в
степень блоки минус один, то есть,
не обязательно у вас там будут соединиться.
Там, возможно, какие-то нули сохранятся.
Но дело ограничено себя, что нельзя
вылезать за длину массива.
Потому что там нет числа, мы там
сумму не определяем.
Но это такое замечание, оно нам
неважно.
Так.
Ну что, мы написали апдейт,
и мы попутно поняли,
что он работает за логарифм, за от логарифма,
потому что сколько итерации работает наш
форм, ну столько, сколько было нулей
в исходном числе, потому что каждая
итерация – это замена одного нуля
в единицу, и значит, ну поскольку у меня
всего в дуэчной записи логан бит,
то, соответственно, каждый нуль может
проявиться в единицу, и так всего максимум блок раз.
Поэтому, суммарно, апдейт работает за от
логарифма. Он перебирает все нужные
и, работает за от логарифма,
и всё хорошо. Мы целиком решили
нашу задачу за логарифм на запас.
Итог.
Get some
и апдейт
работают за от логарифма.
За от логарифма.
И быстро пишутся.
Что тоже немаловажно.
Быстро пишутся.
Можно ещё раз резюмировать, пожалуйста,
почему эти замечательные функции
решают нашу задачу?
Так, почему они решают нашу задачу? Ну, потому что
как бы это объяснить?
Во-первых, потому что с ними всё сошлось.
С ними так получилось, что
они как бы друг
через друга выражаются.
Если суммы, которые мы определили,
они на отрезке от f от и до и,
то апдейт нужно делать по желуд
и прыгать.
С ними всё сходится, и с ними
сложность будет логарифмическая.
Видимо, вам
хочется понять, почему мы их взяли,
какой в них смысл.
Ну, смысл как раз в
двоичной записи. Давайте повторим.
Что делает желуд и?
Желуд и оно
значит
превращает
младше ноль
в единицу,
а f от и
за нуляет.
Ну, вот как раз и хорошо понятно, что делает
jet и f от и, но
очень плохо понятно, что делает
get prefix и update.
А, хорошо. Ну, смотрите.
f от и это какая-то функция меньше
равная, чем i.
Тогда что мы сделали на самом деле?
Мы просто для каждой позиции
знаем вот этого числа f от и,
то есть для каждой i знаем f от и.
А ещё мы знаем, мы храним же массив s.
То есть мы на самом деле знаем сумму
на другом отрезке.
Для каждого i мы знаем сумму на отрезке
с f от и до и.
Вспоминаем дерево отрезков.
Забыли про это. У нас было дерево отрезков,
то есть мы знаем сумму с каких-то подотресков.
Здесь то же самое, здесь суммы с каких-то подотресков
они уже
совсем не такие, как дерево отрезков,
они управляют вот этой функцией f.
То есть для каждой правой границы
мы вычисляем левую границу f от и
и на этом отрезке находим сумму.
Соответственно, тогда get sum работает
очень просто. Если мы знаем сумму на каких-то там
отрезочках, то давайте посмотрим
на отрезок, который заканчивается в i.
Он начинается в f от и заканчивается в i.
Мы знаем здесь сумму.
Тогда давайте встанем вот в эту точку.
Эта новая точка будет
давайте я назову j. Она равна f от и
минус 1.
Тогда опять, если мы от точки j
уже возьмем функцию f,
то это будет опять какой-то отрезок, на котором мы знаем
сумму. Левая граница будет
f от j, правая граница будет j.
Мы знаем на нем сумму. Давайте добавим
ее к ответу. То есть мы знаем сумму
здесь, взаим сумму здесь.
Это там какие-то кусочки нашего ответа.
Добавим их к ответу. Соответственно, будем
отпрыгать, пока не пройдем
весь префикс.
Ну и все это сложим
в ответ. Получится как раз
таки сумма на префиксе.
А ровно это мы хотим.
Может быть лучше остановиться, когда мы достигнем левой
границы и после этого посчитать
f от этой границы.
Точнее
s.
Ну мы можем
залететь ее.
Да-да-да. Значит, здесь мы
смотрите, мы рассматриваем
сумму на префиксе,
потому что, да, если мы будем
пытаться находить сумму на отрезке,
то мы, к сожалению, с помощью этих стрелок можем
перепрыгнуть за наш
за левую границу. Вот если у меня были
LER, мы, соответственно, в LER взяли какую-то
такую сумму на отрезке, потом такую сумму на
отрезке, потом взяли и попробовали такую,
и здесь слишком много. То есть мы берем то, что
не нужно. Значит, мне нужно вот эти вот точки
отдельно добавить. Но их там может быть, к сожалению, слишком
много, поэтому мы лучше
вычтем сумму на префиксе
до r, вот такую вот сумму,
вычтем сумму на префиксе
долю минус один, и получится
рискомая сумма. А так прыгать мы уже умеем. То есть мы
когда допрыгаем до нуля,
мы явно за начало массива не перепрыгнем.
Такой проблем уже не будет.
Мне просто показалось, что мы
дважды вычисляем одно и то же.
Да вроде нет, мы вычисляем
по одному разу сумму на двух разных префиксах,
а потом их вычитаем.
Функция G
Функция G, что еще раз?
Функция G
Зачем тут?
Функция G для апдейта. Значит F мы используем
в GetSum.
Функцию G мы используем
в Update.
Потому что, смотрите, повторяемся,
если у меня... Как работает
Update? Update предполагает, что у вас пришло
какое-то изменение в точке. Вот есть какая-то
позиция pos, и в ней число изменилось
на вал. То есть там было какое-то число x,
стало x плюс вал.
Хорошо. Но мы тогда
хотим обновить некоторые значения в массиве
s. То есть у меня есть массив s,
где хранится сумма на каких-то подотресочках.
И теперь мне нужно, соответственно, какие-то
из них пересчитать. Какие из них
изменились? Ну вот ровно те, которые
вот такие, что i лежит где-то справа,
а f лежит где-то слева.
Вот такие отрезки.
Раньше мы
описали все такие i,
которые лежат правее, чем pos,
и для которых эта стрелочка как бы перепрыгивает
через pos. И с помощью
функции g мы их все перебрали. То есть
мы доказали, что если перебрать
в качестве i значения pos,
g вот pos,
g вот g вот pos и так далее, то есть
все много раз навешивают g, пока мы не
перевалимся, как бы не перейдем за границу
массива справа. Во всех таких
отрезках и только в них присутствует
точка pos. И, соответственно, в них
во всех нужно s и t увеличить на вал.
Потому что туда входит число
pos, оно увеличивается, его
нужно учесть. Но раз оно изменилось, то и
сумма на отрезки тоже изменилась.
Массив из нориков и единиц — это массив чего?
Это битовое представление.
То, что я тут рисовал, всегда было битовое
представление. Это битовое представление
числа. Какого-то числа конкретного?
Вот здесь, например. И я
рисую вот такой прямоугольничек
и 0.1.1. Это значит, что
там какие-то есть старшие биты,
потом есть бит 0, потом 1.
Я имею в виду то, что мы же изначально
имели массив, а как мы пришли к битовому
представлению? Битовому представлению чего?
У каждого натурального числа есть его
битовое представление. В смысле, двоечная запись.
И чтобы понимать,
как работает функция f,
как работает функция g. Ну вот, например,
вот здесь я поставил перед собой вопрос, как
работает функция g, как действует функция g.
Значит, для этого я
рассматриваю аргумент, беру какое-то произвольное i.
Представляю i в двоечной записи. Вот тогда
могу его как-то так нарисовать.
Ну и понимаю, что g
берет вот это вот. То есть чем отличается
i от g o t? В чем отличие?
В том, что мы взяли вот этот младший ноль
и его превратили в единицу.
Это такое описание того, как действует функция g.
Это не преобразование
чисел в массиве, это просто
ну просто действие функции
на каждом конкретном индексе. Если было
и то, останется g o t, который отличается
изменением одного бита.
И получается, что
массивы сытых — это массив каких-то
частичных сумм.
На подресках, да. Да.
И они могут пересекаться.
Да, могут пересекаться спокойно.
Никаких требований на них нет.
Если вопрос в чате
про то, как мы изначально заполняем
массив s, изначально
его заполнить можно, например, следующим образом.
Ну, я называю это построение.
Построение
s. Ну, смотрите, давайте изначально
скажем, что массив из нулей состоит.
Да, что наш a, что наш s
целиком из нулей состоит.
И потом просто сделаем
n-n апдейтов.
Для всех i от 0 до n
мы сделаем апдейт
и a i t.
Тогда, соответственно,
в каждой ячейке у меня
из нуля мы получим
нужно на мне число a i t, то есть то,
которое есть там
во входном массиве.
И заодно мы обновим все нужные
значения в массиве s.
Заодно мы обновим все нужные
суммы в массиве s.
Ну, например, так. Это работает за n log n,
потому что у меня n апдейтов всего, и каждый апдейт
будет за логарифом.
Быстрее нельзя?
Можно, но
не обязательно, потому что у нас все равно
будет куча запросов. Каждый запрос у нас все равно
будет за логарифом.
И, то есть,
если мы все равно на запрос встречаем за логарифом
и запросов там обычно больше, чем n,
поэтому это не очень принципиально.
Но, в принципе, можно. Можно построить массив
префиксных сумм на a.
Массив префиксных сумм.
И тогда s i t это
префиксная сумма i t
минус префиксная сумма
f i t − 1.
Потому что если я знаю, скажем, сумму от
нулевого элемента до i t
я знаю сумму от нулевого элемента
до ф i − 1,
то сумма
с f i t до i t элемента — это как раз такая
разность.
Ну, массив префиксных сумм мы уже знаем, что такое.
Это сумма нескольких первых элементов от нулевого
до какого-то, соответственно, здесь
от нулевого до i t, здесь
от нулевого до вот этого f i t − 1,
как раз лежат ровно те числа, которые нужно положить в сумму. Ну вот так взяли и за open получается.
Чем больше еще раз почему это работает?
Ну смотрите, переход от А к массиву перегрузки на сумму работает так, что мы говорим, что при f it
эта сумма чисел от 0 до it, а 0 после так далее плюс a it.
Это считается за o at n. Суммарно массив перегрузки на сумму можно считать за o at n. Мы на первой лекции это делали.
Массив перегрузки на сумму считаем, и теперь мы за o at 1 можно найти сумму на любом отрезке.
Ну в исходном массиве, без изменений. Если нет изменений, то за o at 1 любая сумма мне доступна.
Потому что пусть есть какой-то отрезок с l power.
И я знаю, ну то есть с перегрузкой на сумму мы как-то рассуждали, что есть вот такая сумма от 0 индекса до r.
Есть вот такая сумма от 0 до l-1.
Тогда их разность, это как раз сумма на отрезке l.
Теперь вместо r возьмите i, и вместо l возьмите f at. Да, просто f at.
В итоге, значит, сумма на отрезке, которая нам нужен, это в точности pref it minus pref f i-1.
Здесь надо не забыть, что s it это что такое? Это сумма по всем g от f i до i ожитого.
Просто какая сумма на отрезке? Сумма на отрезке мы умеем рассчитать за 1 с помощью pref sum.
Так, ну что, когда едем дальше, значит нам нужно точно, собственно, то, что я обещал, это обобщение на большей размерности.
Обобщение на большие размерности.
Ну, например, если у нас есть какая-нибудь прямоугольная табличка, давайте квадратно, я буду рисовать.
Есть табличка n на n. Соответственно, в каждой клетке стоит какое-то число.
Так, еще вопросик. Постояние минимум за n log n, когда… Нет, я вот только что объяснил алгоритм за n.
Мы почитали pref с суммой, потом разностями на отрезках, знаем всех сетей.
Это заот n было. Только n log n – это обычный апдейт.
Да, это дерево Фенвика было.
Ну, почему оно так называется, я тут не могу ничего сказать, но Фенвик – это, видимо, автор или один из разработчиков, по крайней мере.
Вот, где здесь дерево? Дерево тут, конечно, довольно тяжело уловить, но, в общем, там можно также с большей натяжкой, но можно представить это все в виде дерева.
И также, как у нас было в ДО, сказать, что сумма в вершине – это сумма в поддереве, но это там не очень красивая конструкция получается.
Мне проще так рассказывать, просто давайте вот это называть деревом Фенвика и боксом, да, то есть почему именно так называется – это, я считаю, не принципиально для решения задач, для понимания, что происходит.
Аналогия с деревом здесь, я считаю, не помогает. Ну так вот, значит… Нет, видимо, нет. Вот, отлично.
Значит, есть у меня табличка. На вершине ИТ строки ежитого славца стоит число АИТ-ежитое. И опять есть два типа запросов.
Есть update в точке, то есть по позиции ИИЖ и числу ВАЛ нужно сделать АИТ-ежитое плюс равно ВАЛ.
И второе – это getSum, но getSum уже не на отрезке, а на подправке.
То есть если мне дали какие-нибудь четыре числа L1, R1, L2, R2, давайте я вот так вот веду координаты, да, то есть здесь возрастание И, здесь возрастание G, тогда мне могут дать какой-то вот такой прямоугольник, дать его координаты левого верхнего угла L1, R1 и правого нижнего, L2, R2.
Соответственно, теперь сумма уже не на отрезке, а на подпрямоугольнике, который задается своими двумя координатами двух концов – левый, нижний, правый, верхний.
Ну, сразу давайте заметим, что сумма на подпрямоугольнике произвольном, она сводится к сумме на таком префиксном прямоугольнике.
Потому что, смотрите, вот давайте я нарисую прямоугольник, на котором мы ищем сумму, вот что-нибудь такое. Давайте тогда мы возьмем сумму вот на таком прямоугольнике с левым верхним углом вот здесь, ну, то есть возьмем вот такой прямоугольник.
Тут, понятное дело, много лишнего, в частности, можно вот этот прямоугольник вычесть и вот этот прямоугольник вычесть.
Но тогда левый верхний угол мы вычтем дважды, давайте его обратно прибавим.
И тогда как раз, смотрите, значит, это мы учли один раз, давайте поставлю сюда плюсик, мы учли один раз от вот этого вот красного прямоугольника самого внешнего.
И все эти числа будут в сумме. Дальше, это мы вычли один раз, потому что один раз мы учили, по сути, мы учили только этот, ну этот прямоугольник, который мы учили.
раз от этого вот красного шitungенского бетонда с самого внешнего и �оторATTë в сумме, дальше
этого уже 추ли 1 раз потому что 1 раз прибавили что ли это мы прибавили 1 раз от самого внешнего
прямогольника и вычистит 1 раз, estudу вот это синие кавинника соответственно все cyclist
используются 0 д resistance то самое вот здесь 1 раз прибавили 1 раз вышли ну в левом верхнем
будет два раза прибавили, два раза вычли. Поэтому в итоге, когда мы так сложим все,
ну то есть с правильными коэффициентами плюс-минус, мы сложим все вот эти вот 4
рефиксные суммы, у нас будет ответ на нужно мне прямоугольник. То есть все вот это
как бы сократится, все слагаемые там попарно сократятся и останется только
нужная мне сумма на нужном прямоугольнике. Вот, в итоге поняли, что вот это вот
сводится к, я напишу get pref сам, или это просто соответственно найти сумму на
прямоугольнике с левым верхним концом 0,0, а правым нижним lr. Все прямоугольники
можно решать такие рефиксные, что у них левый верхний угол f0,0. Похоже на то, что мы делали раньше,
когда говорили префикс в массиве, это какой-то начальный отрезок, то есть отрезок
с левой границы 0, правой границы где угодно. Здесь тоже самое, правая граница где угодно,
а левая граница в 0,0. Ну вот, соответственно свели запрос к префиксным суммам. Ну хорошо,
тогда давайте обобщим, собственно, наше предыдущее решение на двумерный случай.
Пусть s и t же t, это такая сумма. Сумма по u от f от i до i, сумма по v от f от g до g,
а у t в t. То есть я просто отдельно независимо перебираю все u от f от i до i, и v отдельно
перебираю независимо от f от g до g. И все числа, которые попали и по первой границе,
и по второй в нужные отрезки, я складываю. И у меня получается вот такой вот s, s, s и g.
То есть можно, давайте опять нарисуем наш табличку. Если у меня есть произвольная строка i и
произвольный столб s и g, здесь есть какая-то ячейка, то сумма s и g, это вот такое. Мы можем
посчитать f gt, мы можем посчитать f it, провести вот такие вот две полосочки отсекающие. И
соответственно, то, что лежит в пересечении наших двух полосок, это как раз s и t gt. Это в точности
тех числах, у которых первая координата лежит в отрезке по i, то есть по первой координате,
вторая координата тоже лежит в отрезке от f житого до g. Вот, мы так это определяем.
Да, вопрос.
Лев, после подсчета s мы удаляем. Ну, если хотите, удаляем, да.
Ну, больше нам он не понадобится. Ну, вообще, еще раз повторюсь, достаточно за n log n все
всегда строить, то есть ничего страшного не будет, если вы за n log n построите вместо того,
чтобы строить за o at n, потому что у нас все равно на каждый вопрос будет ответ за логарифом. И
из-за того, что вы вначале делаете n log n предпочет какой-то, ничего страшного не будет.
Ну, так вот, значит, тогда как отвечать на get prev sum? Get prev sum для индексов там LR. Ну,
очень просто. Давайте, значит, вот есть у меня там какая точка LR. Давайте я отдельно,
независимо, по одной координате применю вот этот, ну, много раз f, применить f-1, применить f-1,
применить f-1. И то же самое по второй. То есть разобью вот такие вот стрелочки по каждой из
координат, по каждой из осей. Ну, и дальше, соответственно, мне нужны будут суммы во всех
таких вот прямоугольниках. Я получаю такую сеточку, и мне нужны будут сумма во всех
прямоугольниках. И все это нужно будет сложить. Соответственно, тогда код будет следующим.
Ans равно 0. Для всех i от L и не отрицательно i равно f от i-1. То есть такая же строчка,
как у нас была раньше. Потом для всех j от R, j больше на 0, j равно f от j-1. То же самое только
для другой переменной. Мы к ответу прибавляем s и t jt. В итоге отличие минимальное. У нас просто
появилось два вложенных цикла вместо одного. Цикл по одной координате, цикл по другой координате,
и причем они вот так вот, именно независимые, что отдельно первая координата пробегает все
возможные вот эти вот, все вот эти вот отрезочки по i, и отдельно вторая, все отрезочки по j. В итоге
мы как раз складываем сумму из всех таких прямоугольников, на которые разбилась, ну,
то есть вот эта вот сетка разбивается на такие прямоугольники, и из каждого из них мы там считаем
сумму, и все это складываем в ответ. В каждом прямоугольнике своя сумма, мы все их сложили,
и прибавили к ответу. Получается работает за лог квадрат, потому что по каждой координате у нас
логарифм отрезков, в итоге в пресечении у меня получается лог квадрат прямоугольников. Ну вот,
а апдейт точно также работает, значит, мне нужно понять в каких, то есть если у меня происходит
изменение в какой-то точке там x, y, допустим, то мне нужно понять, каковы такие i, что точка x,
y лежит в полоске по i, и каковы такие g, что x, y лежит в полоске по g, то есть, да, по
стройкоординате. Это те же самые условия, причем они независимые, отдельные условия на i,
отдельные условия на g, и мы все такие должны перебрать. Почему нужно прямоугольник вытворить
срок по границам сетки? Я имею в виду, нужный нам ответ, что будет проходить по границам, то,
что он не будет меньше или больше, чем нужны границы. То есть как мы получаем ответ? Вот так.
Вот алгоритм. Ответ – это сумма на прямоугольнике, у которого левая верхняя точка – это 0,0. Вот,
собственно, это важно, что у него левая верхняя точка – это 0,0, а правая нижняя – это какая-то
точка LR. Нет, но мы свели эту задачу из условия того, что мы можем проводить любой многоугольник,
мы же не говорили, что мы можем проводить многоугольник только по границе, а здесь мы
можем посчитать только для многоугольника, который мы можем провести по границе. Границы – это что такое?
То, что штриховано. То, что штриховано. Значит, смотрите, нет, мы можем, если у меня LR – произвольная
точка, то я могу с помощью вот этого кода найти сумму на этом прямоугольнике. Вот почему. Давайте
вспоминаем, как работают у меня вот эти стрелочки и как проводятся пунктирные эти рёбра. Значит, вот
есть у меня число L – это нижняя координата по И, по Х. Я считаю f от L – это какое-то число такое,
которое меньше обравно, чем оно, и я провожу такую пунктирную линию выше, чем f от L. Дальше
вот здесь будет число f от L – 1. Я беру опять от него f и провожу какую-то линию. То есть у меня,
по сути, ровно вот это происходит. У меня И так. Я перегираю И, которое изначально равно L,
не отрицательно, и я к И применяю при образовании f от L – 1. Тогда понятно, что я вот так отсекаю
линии и вверху ровно добью до 0. То есть последняя стрелка будет вот такая, поскольку я всегда не
отрицательный, f от L тоже всегда будет не отрицательным. Соответственно, все эти отрезки – это как раз
разбиение какое-то. Вот такое разбиение. Потом то же самое происходит с g. Вот такое разбиение какое-то
другое. В каждом прямоугольнике я знаю сумму, поэтому никаких проблем тут нет. Тут нам пришла
историческая справка, я так понимаю. Да, это двумерный фенрик. Сейчас апдейк я напишу,
давайте апдейк напишем. Я просто не успеваю начать отвечать. Фенрик, нет, фенрик отдельно будет,
это именно двумерный фенрик. Значит, апдейк как работает? апдейк с точки x, на число вал. Работает
так. Давайте я сначала напишу то, что я хочу делать. Представляем, что axy увеличилось на вал.
Тогда вопрос, какие с и g поменялись? Какие с и g изменяются? Ну, ровно следующее. Что, во-первых,
x должно лежать в отрезке от fe до i, а y должно лежать в отрезке от fg до j. Ну, просто потому,
что с и tg это как раз отрезок, ну, точнее сумма в прямоугольнике, где первая координата от fe
до i, а вторая координата от fg до j. Ну, поэтому вот ровно такие условия. Если только, если выполняются
такие условия, то мне нужно с и tg увеличить на вал. Значит, соответственно, мне нужно отдельно
перебрать i независимо, отдельно независимо перебрать g из этого условия, и в каждой такой
ячейке увеличить сумму на вал. Пишем так же, как у нас было в одномерном случае. Чтобы перебрать
все i, удовлетворяющие вот этому условию, я пишу for i от x до n. i равно g от i. Это будет все i,
подходящие под первое условие. Дальше внутри я перебираю все g, подходящие под второе условие.
Это вот такой цикл. g равно g от g. А n это что? Ну, размер нашей квадратной таблички. Мы считаем,
что она n. А квадратная? Ну, если она прямоугольная, то здесь будет просто другая сторона.
Почему объединяем в систему, а не в совокупность? Ну, потому что вспоминаем, что такое s и tg. Это
сумма по u, сумма по v, а у v, где u от f от i до i. И здесь вот f от g до g. Тогда вопрос, какие такие
i и g могут быть, что вот здесь вот одно из слагаемых, это axy. Ну, ровно вот такие. Какие такие
i и g, что в этой сумме есть слагаемая axy? Ну, это в точности означает, что вот в этом промежутке,
то есть от f от i до i есть x. И еще в отрезке от f от g до g есть y. Вот получается система.
Все, получили тоже залог квадрата обновления. Залог квадрата.
Ну и, соответственно, если вдруг нужно еще больше размеров, там трехмерная, четырехмерная. Вот в
контесте как раз кстати есть задача на трехмерного фенлика. Там вот просто три вложных цикла пишете,
и все отлично работает. Не нужно никакой трехмерно деревоотресков. Здесь так же все очень-очень
эффективно по памяти, потому что, по сути, мы не заводим дополнительную память. У нас, как бы,
все на том месте, где исходный был массив, можно на нем все хранить. То есть не нужна до памяти
эффективно с точки зрения константа, потому что здесь очень много битовых операций. Вот этот
всякий g и f от i. Они все очень простые, потому что они битовые. И соответственно,
ну в общем, сплошное удовольствие. Так, ладно. Это был фенлик обычный и двумерный. Я не знаю,
название для fg, не знаю. Ну, кстати, когда мы будем для двумерного фенлика строить исходно
и осытые житы, здесь уже, наверное, существенное, что мы должны выбирать оптимальный вариант.
Что такое оптимальный вариант? Ну, за сколько мы будем строить массив двумерные сытые житы?
Ну, можно также с помощью n квадрата апдейтов за n квадрат лог квадрат. Это же плохо. Ну, может
быть, да, здесь я больше с вами соглашусь, потому что может быть такое, что... Ну, хотя... Ну,
да, да, да. Наверное, грубо говоря, если у вас табличка там, не знаю, тысяча на тысячу и всего
потом десять пятый запросов, то, наверное, n квадрата лог квадрата лучше не умножать,
а просто q лог квадрата умножать. Да, то есть число запросов значит лог квадрата. Да,
наверное. Ну, тогда вот можно эти префиксные суммы ввести. То же самое. То есть префиксная сумма
на табличке — это сумма в прямоугольнике, где левый верхний угол — это 0,0, а правый нижний — это
вот произвольная точка ижи. Там пересчитывается очень похожим образом, и соответственно,
зная все префиксные суммы, мы сумму на любом под прямоугольнике тоже можем заводить не
судно. Тогда построение будет за квадрат. Ну, а скорее я про то, что в задачах на ногомерном
фенрике обычно у вас исходный массив заполнен нулями. И кажется, задача в контесте ровно так,
что у вас изначально все ашки в нули, соответственно, все ски можно считать нулями,
и потом уже поступает запрос тип апдейтов. Ну да, это важно, это хороший вопрос, но почему-то это
никогда не нужно. То есть что обычно хватает либо просто написать за лог квадрат кучу апдейтов,
либо вообще изначально все нули, поэтому делать нечего. Ну вот, хорошо, давайте тогда пойдем дальше,
и наверное мы обсудим другие операции, другие функции, ну скорее другие операции, кроме суммы.
Что вот, например, пусть нам не нужно, нам нужно искать не всему на отрезке, а что-нибудь другое.
Ну, например, произведение. Например, нам нужно искать не get сам, а get product,
и соответственно отрезка lr. Это просто найти произведение чисел al, al plus 1 и так далее.
Скажите, пожалуйста, можно ли эту задачу решать похожим образом на то, что мы делали до этого?
Раньше у нас была сумма, которая решалась суммой слишком большого количества, потом вычитанием
ненужных. Сейчас у нас произведение, где мы умножаем слишком много, а потом делим на ненужные.
Все правильно, мы просто считаем префикс. Есть же логарифм еще, просто тогда все линейно.
Но с нулем тоже проблема, если у вас есть, если одно из чисел 0, то логарифм от него...
Давайте скажем, что у нас нет нулей. В общем, вопрос здесь скорее на просуждать,
чем на написать. Давайте я все-таки скажу что-нибудь, что можно посчитать префиксы и все произведения.
Точно так же мы будем считать произведение на префиксе, а не на отрезке. И тогда, соответственно,
если я знаю произведение на отрезке от 0 до r и произведение на отрезке от 0 до l minus 1,
тогда нужно одно поделить на другое и вернуть ответ. Здесь, конечно, куча проблем, что, во-первых,
с нулями, что если тут есть 0, то нельзя делить на 0. Во-вторых, что числа могут быть слишком большие
и не помещаться ни в лунг-лунг, ни куда. В-третьих, что... Хочется верить, что влезет.
Да, ну и, собственно, с делением. Если мы переходим к каким-то логарифмам или к доблам,
то, возможно, мы посчитаем ответ не точно. Какая-то погрешность, густошка большая.
Короче, тут все не очень хорошо. Лунг-лунг хватает для того, чтобы просто перейти в логарифм.
Ну, зависит от задачи, конечно. Скажем так, можно сделать так, чтобы не хватало.
Можно сделать так, чтобы не хватало. Вот. Ну, хорошо. Ну, то есть с произведением там худа,
можно разобраться. А что делать с максимумом? GetMaximum на отрезке. Если мне нужно найти на
отрезке lr, найти максимум. l, и так далее, ar. То здесь сюжет все хуже, потому что даже зная
максимум на таком префексе и на таком префексе, я максимум на этом отрезке никак не выясню.
Скажем, если здесь есть какое-нибудь суперогромное число, там 10, 9, то оно будет участвовать в обоих
префиксах, и это нам не даст никакой информации о том, какой именно здесь максимум. Поэтому,
ну, по крайней мере такая же идея не работает, что нельзя знать максимум на двух префиксах и
оттуда как-то извлечь ответ. Вот. Ну, на помощь приходит так называемое обратное дерево фенвика.
Обратное дерево фенвика. Оно определяется следующим образом. Напомню, это старое у нас было
s.i.t. Это сумма по j от fi до i ожитого. Сорри, сумма, да. Давайте сразу на максимум построим.
Максимум по всем j от fa3 до i ожитого. Значит, это обычное прямое как бы дерево,
прямое дерево фенвика. И вводим обратное s.i.t. Это максимум на отрезке, сейчас внимательно,
очень странное условие, от i плюс 1 до j от i ожитого. Вот i плюс 1 до j от i. Смотрите,
вот это прямое обычное дерево фенвика, оно для каждой правой границы считает какой-то
максимум направо, на каком-то вот таком отрезке. Правая граница фиксирована, левая какая там fa3.
Обратное дерево, оно действует наоборот. Оно стартует в позиции i плюс 1. Важно здесь именно i
плюс 1. Не i, а i плюс 1. И идет в противоположную сторону, куда-то направо, в сторону увеличения.
Потому что j от i всегда больше равно, чем i плюс 1, потому что оно его содержит в качестве
дизюнкта. И или i плюс 1. И соответственно мы будем считать максимум вот на этом отрезке.
То есть как бы идет в обратную сторону. Если мы раньше прыгали налево, в сторону
уменьшения координат, то теперь будем прыгать в сторону увеличения. И тогда решение будет
следующим. Если у меня есть наш массив, и мне нужно найти максимум на каком-то таком отрезке.
Давайте тогда сначала встанем в правую границу и будем прыгать влево, пока это осмысленно. То
есть взяли f от r, видим, что это нас оставляет внутри нашего отрезка. Перепрыгиваем,
знаем здесь максимум. То есть на этом отрезке нам максимум извести. Дальше поднимемся налево,
опять прыгаем куда-нибудь сюда, знаем здесь максимум. Тут все хорошо, мы находимся внутри
отрезка. Но допустим в следующей точке f от правой границы уже куда-то выскакивает. Тогда понятно,
что нам нет смысла, нам нельзя брать максимум на этом отрезке, потому что здесь есть какие-то
недопустимые нам числа. Все, тогда мы останавливаем наши прыжки влево и больше этого не делаем. И
начинаем движение навстречу. Встаем в левую границу, давайте я буду считать, что у меня задно все на пол
интервале, задно все на пол интервале, и левая граница у меня не включена, вот так, не включена.
Тогда, значит, я хочу прыгать как бы навстречу из левой границы. Ну как раз у меня, если я возьму
слт штрих, это как раз максимум на каком-то таком вот отрезке, который начинается в l плюс 1,
заканчивается там g от l, это какой-то такой максимум. То есть я возьму так, так прыгну. В общем так
несколько раз попрыгаю, знаете, все максимумы. И в идеале хотелось бы, чтобы я закончил как
раз в той точке, из которой не получился тот большой прыжок. В идеале я дойду до сюда,
и у меня как раз все числа ровно по одному разу задействуются. Все числа ровно по одному разу.
Вот. Если это так, то получится, что все хорошо. И здесь тоже понятно, что это работать будет за
логарифм на запрос, потому что я сначала в правой границе прыгаю максимум логарифм раз,
потом левой навстречу максимум логарифм раз. Они как раз склеились, и получилось у нас,
что весь наш исходный отрезок разбивается на несколько, в каждом из которых я знаю максимум.
Давайте покажем, что так это и будет работать. Покажем, покажем, что если из текущей правой
границы, правой границы, так сейчас давайте допишу, потом вопрос почитаю, нельзя прыгнуть влево,
то встречное движение слева направо. Сейчас, а если мы, скажем, самым первым прыжком из R мы
перепрыгиваем L. Тогда мы ни одного прыжка из R не делаем. То есть мы прыгаем только столько раз,
пока мы не вываляемся из отрезка. Окей, ладно, хорошо. Еще раз, как мы прыгаем. Смотрите,
мы встали в правую точку, в R, и прыгаем влево по вот этим вот стрелочкам F, то есть применяем F,
пока мы не вываливаемся из отрезка LR. Просто прыгнули, посмотрели, мы еще в отрезке LR,
целиком в отрезке LR, если целиком, то обновляем наш максимум и продолжаем прыгать. Так прыгаем,
прыгаем, то есть как обычно, вот это будет F от R, следующая точка это будет F от R-1, потом применяем
опять F, смотрим, если эта точка лежит в отрезке, то берем максимум и продолжаем прыгать. Прыгаем,
прыгаем справа налево. Потом допрыгались для такого, что мы не можем переблюднуть влево,
оставаясь в отрезке, то есть мы куда-то туда перепрыгиваем, что вообще я вываливаюсь из отрезка LR.
Тогда я начинаю встречное движение, встаю в точку L и беру вот эти вот максимумы, как бы встречные,
буду двигаться слева направо по таким отрезкам, то есть из L я перехожу как бы в G от L,
потом в G от G от L и так далее, и соответственно у меня вот встречные вот такие вот отрезочки,
и я утверждаю, что они в конце обязательно схлопнутся. То есть когда, если я не смог
прыгнуть влево, то потом встречное движение как раз закончится в той точке, из которой я не смог
сделать прыжок налево. Так, и вот это мы сейчас докажем. Сейчас покажем, что если из текущей
правой границы L, то есть когда я вот так вот L раздвигаю и она стала вот сюда, если нельзя
прыгнуть влево, то встречное движение слева направо закончится L. Ну, давайте напишем условия того,
что мы не можем из текущей правой границы сделать прыжок. Ну, во-первых, должно быть L больше
чем L, потому что иначе напоминаю, что мы сейчас как бы на пол интервале ждем, что левая граница
не включена, а правая включена. Смотрите, здесь не явно, я имею в виду, что когда я вот так вот
прыгаю, я двигаю правую границу запроса, потому что если L вот здесь, то я могу посчитать максимум
на вот этом отрезке, на красном отрезке, и правую границу сдвинуть сюда. Опять, здесь знаю максимум,
обновляю ответ и правую границу сдвигу сюда. То есть L вот динамически, оно изменяющееся.
Так вот, значит, когда вообще вот получилось так, что я не могу прыгнуть влево. Во-первых,
L больше чем L, потому что должны быть хоть какие-то здесь числа, иначе мы уже все
просмотрели и делать ничего не надо. Во-вторых, f от R меньше либо равно L. То есть вот этот прыжок отсюда-сюда,
он ведет либо в L, либо левее, потому что L как бы не включено у нас. Если f от R меньше
либо равно, чем L, то как раз получается мы вывалились из нашего отрезка, из вот этого отрезка мы вывалились.
Ну и тогда я утверждаю, что в этом случае обязательно g от L меньше либо равно R. То есть,
если мне как бы еще есть что делать, если R больше чем L, то есть пока остались какие-то
непокрытые точки, я обязательно смогу вот здесь выделить какой-то отрезок на нем,
и соответственно перейти дальше. И так у меня будет работать, пока у меня R больше чем L. То есть,
пока есть хотя бы один непокрытый элемент. Это как раз то самое условие нашей корректности. То есть,
мы сначала прыгали направо, и потом пока есть живые точки, мы прыгаем, так извините,
неправильно сказал, мы сначала прыгаем справа налево, уменьшаем R, уменьшаем R, уменьшаем R,
потом в момент, когда не можем этого сделать, делаем следующее. Пока есть непокрытые точки,
вот эти вот непокрытые точки, мы сдвигаем левую границу. Сдвигаем, сдвигаем, сдвигаем вот по этому
правилу, что L переходит в g от L. И утверждается, что пока есть непокрытые, обязательно будет ход,
то есть будет такой ход, который не перекрывает наш отрезок, то есть не вылезает за нашу правую
границу. Вот, ну давайте докажем. Значит, опять мы пишем битовое представление, то есть записываем
L и R в личной системе. Давайте напишем L и R в личной системе, то есть сначала будет где-нибудь L.
То есть мы таким образом, получается, можем пропрыгать несколько раз, как бы, вот в основном
мы прыгали влево, потом вправо, потом опять влево. Нет, нет, нет. Сначала много прыжков влево,
потом много прыжков вправо, и всё, они сошлись. Итак, значит, мы пишем опять двоичную запись.
Сначала напишем L, давайте какую-нибудь такую, потом R. У них есть какой-то общий префикс,
общий префикс в личной записи. Ну, соответственно, раз R больше, чем L, то у меня здесь где-то стоит
единица, здесь ноль, ну а справа уже что угодно. Потому что если одно число больше, чем другое,
то в двоичной записи у них сколько первых битов совпадают. Я имею в виду, что я их
дополняю до одного числа разрядов. Всегда я считаю, что у меня там все числа пишутся
с одинаковым числом бит. Если меньше, то дополняется нуля. Вот, значит, у них какие-то префиксы
совпадают. Потом, поскольку R больше, чем L, здесь стоит единица в первом бите, где они
отличаются, а здесь стоит ноль. Ну а справа уже неважно, что у меня уже выполняется, что R больше, чем L.
Окей, значит, тогда что такое f'R? Вспоминаем, вспоминаем. Это, кажется, зануление последнего
блока из единиц. То есть мы смотрим на младшие биты, смотрим, кто из них единицы до первого нуля,
и все вот эти вот младшие единицы зануляем. Но тогда, смотрите, если вот здесь вот есть справа,
есть где-то какой-то ноль, то эта единица сохранится. Потому что если здесь был ноль,
соответственно, там какие-то единицы, то только они могли занулиться, а эта единица останется,
как бы, неизменной. Она всегда сохранится. И тогда вот этого уже не может быть. Потому что f'R не
может быть меньше, чем L, потому что здесь уже будет единица, которая обеспечивает то, что f'R
больше, чем L. Значит, единственная возможность выполнения вот этого неравенства, вот этого
неравенства, это следующее. Когда все единицы, все позиции правее, чем вот эта единица, тоже
единицы, что здесь все единицы, тогда f'R это, соответственно, зануление всех вот этих вот единичек.
И даже вот эта вот единица, где происходит различие между L и R. Ну и слева здесь еще что-то. То есть
здесь там, возможно, еще какие-то были единицы, они тоже занулились здесь. Ну, соответственно,
здесь тоже самое. Тут как бы что-то происходит. Но главное, что из вот этого условия, что f'R меньше
равно, чем L, следует, что R заканчивается вот таким длинным блоком из единиц. Так, и теперь нам
хочется понять, что gOtL меньше равномерно, чем R. Давайте вспомним, что такое gOtL. gOtL это взять
младший нолик и его сделать единицей. Взять младший нолик и его сделать единицей. Ну, тогда вот
это, собственно, почти очевидно, потому что как здесь тогда gOtL? Если, скажем, здесь есть какой-то
нолик, тогда мы просто его меняем на единицу, и получается число, как бы здесь такое же, здесь будет
один, ну и там тоже куча единиц. Понятно, что gOtL будет меньше равно, чем R, потому что эти общие
препиксы у них сохранились. Здесь остался ноль, здесь остался единица, поэтому gOtL даже будет
меньше, чем R. Ну, а если мы представим, что у меня правее этого нуля стоят все единицы, и,
соответственно, я меняю вот этот вот нолик у меня будет младшим, тогда я поменяю его на единицу,
и будет, ну, одно и то же число, что у меня будет gOtL равно будет просто R, потому что у них есть
общий префикс, потом просто куча единиц. Ну и всё. В итоге мы получили действительно, что за счет
того, что, повторюсь, вот здесь стоит куча единичек, неважно, что мы будем менять вот здесь
в любой ноле, какой мы там не поменяем, всё равно получится число не больше, чем R, поэтому выполнять
это такое не нравится. Вот. Ну и отсюда следует наш алгоритм. Давайте я его сейчас напишу,
только если у меня получится перенести как-то. Сейчас, одну секунду. Так.
Всё, это мы доказали. Теперь как выглядит код. Значит, нам нужно находить, напомню,
максимум на отрезке. Давайте изначально скажем, что, давайте напишем функцию getMax,
на отрезке LR, да. Значит, как это работает? Сначала мы говорим, что ans это какая-нибудь там
минус бесконечность, то есть нейтральный элемент относительно вот этого максимума,
то есть такое число, которое явно заменится, как только мы возьмём первый максимум. Значит,
следующее пишем, да, что, во-первых, видимо, я хочу сделать, нет, давайте буду считать,
что мы находим как бы на полуинтервале, на полуинтервале, ответ на полуинтервале. Тогда,
while, R больше чем L, то есть пока, в принципе, есть хоть одно неиспользованное число,
и можно прыгнуть влево, то есть F от R больше чем L, пока из правой границы можно прыгнуть налево.
Значит ans равно максимум из ans и S от R и, соответственно, R равно F от R минус 1.
Это вот наше обычное преобразование R, что мы прыгаем по F, уменьшаем на 1, и на этих отрезках
взяли максимум. Это были прыжки справа налево. Теперь прыжки слева направо. Пока, опять-таки,
R больше чем L, то есть пока есть хотя бы одно неиспользованное число в отрезке, ну и здесь даже
никакое второе условие дополнительное не нужно, потому что у меня уже вот это вот выполняется,
то есть поскольку я вышел из первого цикла, то у меня обязательно рушилось вот это вот неравенство,
значит оно выполняется, и здесь никого дополнительное условие не нужно. Я просто говорю,
что ans равно максимум из ans и S от R, L равно G от R. Все. Вот так, фигурная скопочка.
Вот, ну вроде все. И мы, собственно, доказали, что вот этот вайл, он как раз-таки будет работать
ровно столько, то есть ровно столько итераций до тех пор, пока у меня весь отрезок не исчерпается,
пока я его целиком не накрою маленькими вот этими отрезочками, которые все покрывают,
которые целиком покрывают все элементы моего отрезка LR по одному разу. Ну вот, понятно,
что это работает тоже в завод логарифма, потому что здесь у меня наше преобразование R переходит
в FTR минус один, это мы уже доказываем, что работает максимум лог раз, здесь другое
преобразование встречное L переходит в G от L, это тоже максимум лог раз, ну и, соответственно,
а симпатику будет лог N. Как это помогает нам не учитывать какие-нибудь большие элементы правее
LR? Правее LR. Ну вот, смотрите, это условие мы же вывели, это означает, что когда я прыгаю
из L куда-то, я не вылезаю за гринд с нашего отрезка LR. Значит, все, что находится правее,
просто никак не поучаствуй, потому что G от L гранищена R и все. Мы для этого доказывали,
что мы сначала слева направо не перепрыгаем, а потом справа налево, пока есть неутеченные
элементы, мои прыжки не будут вылезать за правую границу, они всегда будут внутри,
пока целиком не покроют весь отрезок. То есть, получается, нам нужно две разные S для того,
чтобы мы могли работать с двумя разными видами перемещения в массивы. Да, именно так, S и С.
Так, зачем первое условие в первом цикле? Не нужно, да, вы хотите сказать, потому что оно
автоматически из первых и из второго следует, что если ftr больше, чем L, ну тогда, например,
здесь нужно написать, хотя бы пока R больше либо равно нуля. Хотя бы это нужно написать,
потому что если у вас R становится нулем, тогда f от нуля это ноль, и вы зациклитесь,
скорее всего. То есть, без этого условия плохо, да, мы не хотим брать f от отреза от
Ну, можно писать так, можно писать R больше, тут не важно. Давайте напишем R больше нуля.
Так, ну, время у нас почти вышло, давайте я оставлю в качестве упражнения update. То есть,
мы сделали get max за логарифм. Ой. Так, я подумал, там мне прислали какое-то сообщение. Значит,
давайте, конечно, упражнение update на s штрих. Значит, мы умеем делать update на s, потому что,
собственно, ну, также как обычно, да, мы там делали update с точки увеличения числа какого-то на вал,
и тогда, как бы, s я обновляю точно так же. Я знаю множество отрезков, в которых лежало изменяемое
число. Соответственно, там нужно пересчитать s. Похоже будет тоже с с штрихом, там нужно будет
тоже применять функцию f, чтобы прыгать по нужным мне отрезочкам. И там все тоже делится с логарифм.
Нет, l, к сожалению, как минимум, оно может минус 1, потому что мы на полу интервалах все делаем.
Разница такая, значит, s вот и это максимум. Вот такой. Максимум на отрезке влево. То есть,
в каждой правой, в каждом, до каждой правой границы есть какой-то прыжок влево. А s штрих,
это прыжок вправо из и плюс 1. У вас в чем разница? Мы используем оба. Нам нужны прыжки из права
налево и слева направо. То есть, мы сначала несколько прыжков. Чтобы сделать get max на отрезке,
мы сначала делаем несколько прыжков справа налево, потом несколько встречных слева направо.
Нам нужно и то, и то. Так, хорошо. Но здесь есть такое одно неприятное обстоятельство,
что чтобы уметь делать апдейт, замечание, апдейт у меня несколько будет обрезанных,
апдейт не полный. Почему? Потому что апдейт может быть только такой, который увеличивает числа.
То есть, как у меня было раньше, у меня был аппост плюс равно балл, теперь у меня, соответственно,
может поменяться как-то число. Но такие апдейты могут работать только, если я как бы число
могу только увеличиваться. То есть, либо остается на месте, либо увеличивается. То есть, как бы,
ну, max равно с чем-то. Могу только увеличить. Только увеличение. Потому что иначе, если, скажем,
у меня запросы были бы, то есть апдейты были бы просто изменения в точке, не увеличение,
а произволеннее изменение. То есть, возможного уменьшения. Тогда, к сожалению, все может
сломаться. Потому что, если у меня есть какой-то максимум на на отрезке, то есть вот, ну, я знал
какой-то максимум на отрезке от f от i до i. То есть, я знал s и t. Потом пришел здесь какой-то
пост, изменившийся. И да, там не знаю, он был семеркой, стал тройкой. Но тогда я, в общем случае,
не знаю, какой стал новый максимум. Потому что, если он раньше был максимум, и был какой-то
второй максимум пятерка и это семерку упало до тройки, то у меня как бы максимум он изменился,
и при этом изменился непредсказуемым образом. Мне нужно взять как бы исключить это число pos из
отрезка и взять как бы второй максимум, то есть без него. Но мы не хотим хранить второй максимум,
потому что там где второй максимум, там и третий, там и четвертый и так далее, и вообще все числа
на отрезке. Поэтому тут не получится сделать иначе, кроме как поставить ограничение на запросы,
что числа только растут. Числа не могут убывать, иначе к сожалению наш фенлик, он не может находить,
ну он не знает как меняется максимум на отрезке, когда изменяется только одно число. Если вы знали
максимум в предыдущем момент времени, потом изменилось одно число, максимум тогда непонятно,
как поменяется. Возможно в какое другое число вообще сместиться, и его непонятно как искать.
Вот поэтому мы считаем, что числа только увеличиваются. Тогда как раз все корректно,
тогда неважно, то есть нам не нужно никакой второго максимум, просто у нас был старый
максимум, если увеличилось какое-то число, там не значит семерки до десятки, тогда мы просто старый
максимум пытаемся обновить десяткой, и тогда он либо такой как был раньше, либо стал десяткой.
Вот в случае, когда все числа увеличиваются, то максимум можем легко обновлять. Так, вроде все.
Я понимаю, что мы на вал в этот раз не увеличиваем на, а именно делаем такое значение.
Да, да, ну или типа можно сказать увеличиваем на, но тогда увеличиваем на не отрицательное число,
можно так. Либо вот как я написал, максимум равно, то есть либо увеличиваем до вал,
либо оставляем на месте. Это как год, но мне так удобно представлять, что не прибавление чего-то
не отрицательного, а увеличение, ну то есть максимум равно, то есть либо оставим, либо сделали больше до
какого-то значения. Так. У нас, то есть мы, еще раз, мы не можем уменьшать, собственно,
элементы массива, да? Да, только увеличение. Вот, значит, резюме. Фенвик чуть менее мощный,
чем деревоотресков, потому что, если мы вспомним обычные деревоотресков и вспомним наши запросы в стиле
там плюс равно в точке и максимум на отрезке, то деревоотреска решает эту задачу на раз-два,
не задумываясь там, мы просто храним в каждой вершине максимум по дереве, а по дереве с точки
пересчитывается тривиально. То есть, по сути, никакого выигрыша мы не получили, кроме, ну,
значит, быстродействия, потому что здесь больше битов операции, здесь нет никакой рекурсии спусков
по деревоотресков, то есть это быстрее, но и проще пишется, потому что здесь меньше всяких вот там,
ну, спуск деревеотресков, там нужно считать координаты детей, как разбивается отрезок и так далее,
то есть просто меньше кода. Да, он более тяжелый с точки зрения понимания, с точки зрения как бы
вспоминаний, там вот эти функции f, g, их много-много, они много раз используются, тяжело это запомнить или
понять, но кода меньше, кода меньше, эффективнее, быстрее, все такое, но, к сожалению, сильно менее,
как бы это сказать, короче, горизонт решаемых задач сильно меньше, чем в деревеотресках. Вот такая
моя мораль. Ой, Финнеке, Финнеке мы не успели, да? Ну, получается, туда, в следующий раз. Сейчас, с умножением можно делать так же, как с Макшеном. Да, можно также встречно Финнеке написать, да.
Есть какие-то операции, которые можно делать на деревеотресках, но нельзя делать в срочных объектах?
Ну, то есть, обдаить, понятно, накладывает некоторое учение, но вот, если мне не хватит, именно...
Сейчас, ну, например, на время раз ГЦД непонятно, как работать, наибольший высшеделитель на отрезке, например, наибольший
высшеделитель в деревеотресках считается просто, а вот Финнеке тоже непонятно. То есть, Финнек работает только с такими операциями, которые после изменения одного числа
предсказуемо себя ведут. То есть, если мы знаем, скажем, результат до, и знаем, как бы, одно число, то мы знаем результат после.
Вот, например, с наибольшим общеделителем так не получится, потому что там нужно как бы знать разложение всех чисел и понимать, то есть, если, например, у меня число раньше делилось на B4 перестало,
то надо понять, делится ли хотя бы какое-нибудь другое число на отрезке на P. Это непонятно, как делать, то есть, в общем, ну, тут все-таки, я бы сказал, что все-таки Финнек умеет сильно меньше, там, типа, минимум, максимум, сумму произведения, что-нибудь такое, совсем простое базово.
При провалении на отрезке там, на самом деле, есть техника, но мы ее уже не будем рассматривать, возможно, я в семинаре включен.
layer]. Если у нас обратной дерево Финнек и glaSpace, то в нем нулевое число меня lifity не Нулевое.
А у нас нет проблем с нулевыми числами, а, сейчас, нулевое число меня ace не Нулевое.
А можно просто считать количество нулей на отрезке, можно считать количество нулей на отрезке, тогда, а, считать количество нулей и произведения всех нуoths хранить.
количество нырей и произведение всех ненулевых, тогда изменение нуля на ниноль, это просто уменьшить
количество нырей и умножить произведение на что-то, и там любые такие изменения, они тоже пересчитываются.
Так ладно, я вас сильно задержал, извиняюсь, давайте заканчивать.
