Сейчас мы покурим про верравнивание и битовые поля заодно, я расскажу вкратце. Вот, смотрите,
какая история. Вот когда вы, когда вы сами, когда вы просто пользуетесь стандартными new
delete, стандартным локатором, когда вы создаете переменные на стеке, вы об этом не задумываетесь,
обычно. Но как только вы начинаете писать свой локатор, в частности, вот если вы начинаете
писать стековый локатор, то у вас возникает следующая проблема. Ну как вы в стековом локаторе,
скорее всего, будете выделять память. Ну вы там создадите какой-нибудь массив чар, там из,
я не знаю, из дофига. Вот, да, ну или там не чар, а uint 8t или std byte, ну не знаю, что-нибудь в таком
стиле. И допустим, вот это ваш пул, вот это ваш пул, тот самый, который называется, кстати,
не пишите слово пул, вот все понимают, что слово пул пишется так, просто я в прошлые годы видел
некоторых, кто писал пул-алокатор, называл его пул, в смысле п-у-л-л-алокатор, потене-алокатор. Вот,
вот, короче, пул пишется вот так, а не так. Так вот, когда вы такое сделаете и, допустим,
начнете выделять на этом локаторе int, ну давайте вот представим, что вы вот этим пулом пользуетесь
разделяемо, и у вас есть два локатора, один выделяет на нем int, а другой, не знаю,
даблы. Вот представьте, вы можете же, в принципе, теоретически завести большой пул и выделять на
нем вещи разных типов. Тогда у вас возникает следующий вопрос, вот int, вот вы кладете int,
int, int, int, положили, допустим, 3 int по 4 байта. Давайте уже буду по-английски писать,
4 байта, 4 байта, да, как-то это нехорошо, выглядит как будто это шестнадцатеричное число. Хорошо,
4 байта, 4 байта, 4 байта, а потом решили положить double, 8 байт, или еще того хуже решили положить
long dumbbell, 16 байт. Ну вот этот адрес, он не кратен восьми же, правда? Нет, если, ну вот если я
выделил вот эту штуку, как бы он не был выровнен, даже если он очень хорошо выровнен, если я положил
3 int, а то есть если он был даже так выровнен, что он был остаток 4, по-моему, для 8, ну я предполагаю,
что я предполагаю, что изначально он выровнен нормально, но вот вы если положили в него 3 int,
а потом положили double, то у вас получается double лежит по адресу не кратному восьми, но вообще да,
это правильный совершенно вопрос. Чар, он же не обязан быть выровнен никак, ну то есть чар может
начинаться с любого байта, там вообще нет никаких требований, он кратен в четыреом или восьми, и на
самом деле, если вы на стеке заводите массив чаров, а вы его на стеке собираетесь заводить, то он может
начинаться с адреса там, что-то там, ну один, то есть остаток один, по-моему, для 8 у вас будет,
тогда все эти вещи будут не выровненными, но что значит не выровненными, это значит, что они
начинаются с адреса не кратного, ну давайте скажем, что перемена не выровнена, если ее адрес не кратен ее
размеру, это для примитивных типов такое определение работает. Вот правильно выровненный aligned int,
это такой, который лежит с адреса кратного 4, aligned double это который лежит с адреса кратного 8,
вопрос, а что плохого, если так, вот допустим я положил int по адресу не кратному 4,
да, ну на самом деле это все, я вот не знаю точно, к сожалению, я пытался там гуглить ответы на этот
вопрос, вот и там, короче, на разных сайтах пишут очень много разных вещей, я в итоге так и не
понял это undefined или unspecified, ну это что-то скорее всего implementation defined, то есть зависит от
процессора, вот смотря какой у вас процессор, именно процессор, он по-разному будет реагировать
на misaligned переменные, какой-то процессор может просто от этого, ну скорее всего это
действительно будет просто замедление работы, потому что процессор он же читает, ну как,
он выполняет инструкции, там, чтения и он делает это там кусками по 4 или по 8 байт, по 8 скорее
всего, не по 4, и если у вас int, так вот у вас кусок 4 из 4 байт, еще кусок из 4 байт, там вот это
кусок из 8 байт и вот это вот предыдущий кусок из 8 байт, если у вас int лежит таким образом,
что он вот задевает 1 байт отсюда и 3 байта отсюда, то процессору, чтобы такой int прочитать и
записать, нужно будет в два раза больше инструкции выполнить, грубо говоря, чем чтобы нормально
лежащий int записать, вот, но тут мы приходим к разговору о том, как устроен процессор там,
какие в нем бывают инструкции, как это все может быть оптимизировано, но этот разговор я не хочу
начинать, вот, и я не уверен, что я смогу все правильно рассказать про это, но если вкратце,
то скорее всего, просто это придет к тому, что он будет дольше работать, ну вы можете, наверное,
создать вручную такую ситуацию и замерить, и проверить, что будет, вот, ну вот, тут, там,
если у вас какой-нибудь intel x86 64, то, скорее всего, так и будет, как я сказал, если у вас какой-нибудь
другой процессор, какой-нибудь AMD, то может быть, будет какой-нибудь другой эффект, в каком-то
процессоре может вообще не будет заметен эффект, он как-то умудряется справиться так же, вот,
а в каком-то процессоре может быть вообще секфолд будет, вот, но, скорее всего, ничего плохого не
будет, будет просто замедление, так вот, чтобы нам это побороть, нам хотелось бы уметь переменные
класть по адресам правильно выровненным, и вот, когда вы такой массив чаров на стеке заводите,
вам нужно позаботиться о том, чтобы он, ну, чтобы он начинал, чтобы его, чтобы он начинал лежать
с адреса кратного, ну, 16, скажем, да, правильно, ну, то есть, вам нужно заботиться о том, чтобы
этот массив начинался с правильного адреса, и о том, чтобы, когда вы что-то выделяете, вот этот,
вот, стек, вот, как сказать, push делаете у него, чтобы вы тоже, если вам, вас сейчас адрес не кратит
какому-то числу, чтобы вы тоже не, ну, в общем, соблюли выравнивание, вот, как этого добиться?
Прежде чем я расскажу, как этого добиться, давайте я расскажу про то, а как вообще в стандартной
ситуации это происходит, вот, если вы, допустим, используете оператор new, но вот если вы кладете
что-то на обычном стеке, вот, если вы просто заводите переменные на стеке, там, int, double,
на стек кладете, то они выровнены, как полагается, вот, ну, это просто там, забота компилятора,
так их класть на стек, а если вы оператором new пользуетесь, как он выравнивает? Ну, или давайте по
другому, если мы функцией malloc пользуемся, то как она выравнивает? Вот, если вы сишный malloc
вызываете, а потом, то есть вы хотите выделить объект типа T, и вы решили вместо new воспользоваться
malloc'ом, malloc принимает просто число byte и возвращает вове звездочку, вот, отличная мысль, вот,
в этом есть некоторое, некоторое отличие malloc перед new, но на самом деле malloc все-таки выравнивает,
а просто, чтобы вы об этом не думали, все там реализовано так, что malloc дает вам выровненный
по, ну, скорее всего по 16 байт адреса, вы можете затестить, попробуйте malloc вызвать много раз,
заметите, что все время они выровнены. Ну, если ты сделаешь много раз malloc на 1 байт, да, то ты,
скорее всего, ты получишь выровненный по 16, как и через new, вот, это сделано потому, что, кстати,
может быть, нет, вот, на счет, если ты выйдешь 1 байт, может быть, он умный, и он поймет,
что выровнять по 16 бессмысленно, то есть ты 1 байт, я не знаю, я не знаю, вот, может быть,
Леша Пономарев знает, он вам завтра расскажет. Завтра мы вам собираемся рассказать про то,
как malloc работает, сам уже, сам непосредственно malloc, вот, это интересная тема, я думаю, что.
Наибольшие 9 двойки относительно чего?
Нет, если я попрошу 100 байт, он выровняет на 16, потому что вдруг у меня структура,
которая, ну, не знаю, ну, короче, скорее всего, он выравнивает, вот, насколько мне известно,
он выравнивает на 16 все-таки, ну, то есть он выравнивает на, он выравнивает на некоторое
число, которое, опять-таки, implementation defined. Вот у вас на, у вас, да, от разных, от того,
на какой вы платформе живете, зависит, насколько он будет выравнивать. Вот, чтобы узнать, насколько
выравнивает new ваши переменные по умолчанию, значит, new, он тоже, на самом деле, возвращает
адрес всегда выровненный по какому-то количеству байт по умолчанию, вот, как и malloc, в общем,
потому что new, он, скорее всего, вызывает malloc, в конце концов, на низком уровне, вот, и есть такая
константа, ну, это даже не константа, это вот что, значит, есть такой тип в стандартной библиотеке,
называется std max align t. Что это за тип, как вы думаете? Это такой тип, который, выравнивание
которого такое же, как максимально возможное выравнивание для примитивного типа на вашей
платформе. Ну, вот, скорее всего, самый жесткий тип, самый жесткий по выравниванию у вас,
это long double. Вот, может быть, он просит выравнивание 16, нет, да, но double он 8, а long double 16,
ну, скорее всего, это все опять, я напомню, что все эти числа, которые говорю, они тоже зависят
от платформы, long double, вот, да, да, может быть, у вас еще есть int 128t, вот, ну, по-моему,
он появился официально. Ну, Майк Мирзаянов, спасибо ему за платформу codeforces-полигон,
писал пост об этом, значит, на своей когда-то, по-моему, он появился там официально, но,
может, я что-то путаю. Кто, int 128t? Ну, наверняка, должность чего бы нет. А, ну, не знаю таких
подробностей. Вот, но он тоже 16, байт занимается 128 поделить на 8, это будет 16. То есть вот они
должны выравниваться по 16. Ну, вот, max align t, это такой тип, выравнивание которого оно такое же,
как у максимально жесткого по выравниванию стандартного типа. А как узнать выравнивание,
собственно, типа? Вот вы можете, наряду с sizeof, спросить еще align of у типа. Начиная с c++11,
кстати, я не знаю, куда надо было делать до c++11, если честно, но вот начиная с c++11, появился
оператор align of, это прям оператор, и он позволяет вам для данного типа узнать, какое у него
выравнивание. Ну, вот как sizeof. Вы просто пишете, например, align of в одно слово, там от чего-нибудь,
там от int, и получите 4. Ну, вот для примитивных типов align of будет как sizeof, скорее всего. Но
если у вас структура какая-нибудь с полями разными, например, у вас может, ну, вот если у вас структура,
в которой есть double там и int, то понятно, что ее выравнивание будет 8. Ну, это все опять
implementation defined, то есть я живу в предположении, что double это 8, а int это 4. Да, а если в структуре
2 int, то выравнивание будет 4. Что если возьмем? Нет, а plus-plus прибавляет sizeof, а не align of. Да,
структура выравнивается по размеру наибольшего поля, наибольшего по... Ну, если у вас полем тоже
является структура, то значит, по ее выравниванию, да. Вот. Ну, хорошо. Ну, на самом деле, когда вы new
вызываете или когда malloc вызываете, то у вас, в общем-то, вот это выравнивание, оно так и соблюдается. То
есть все, что вы делаете через new, вы не паритесь про выравнивание, потому что он, ну, может быть,
для меньших, для типов меньшего размера он выравнивает там хуже, если понимаешь, что не нужно. Хотя,
я не знаю. Мне кажется, что он... Ну, в общем, не знаю. Но уж точно он не сделает вам выравнивание хуже,
чем max.line.t, если ваша структура требует выравнивания max.line.t. Он сделает правильное
выравнивание, потому что он просто, скорее всего, всегда его делает. Да. Да. Да. Да. Да.
Да. Да, именно поэтому. У этой структуры размер 16, потому что padding, потому что размер устроен так.
Ну, вот если бы у вас... Если бы у вас... Вот если у вас структура с даблом и двумя
интами, то ее размер зависит от того, в каком порядке вы перечистите поля, я напоминаю. Вот,
кажется, я про это уже говорил, но может... Понятно, что вот у такой структуры, как написано, размер будет
16, а если я поменяю местами intdouble, то размер станет 24. Вот. Так вот. А как мне, допустим,
сделать выравнивание больше, чем стандартное? И тут возникает вопрос, зачем мне может быть
нужно выравнивание больше, чем стандартное, в принципе? Ну, во-первых, мне, может быть,
оно вот здесь нужно, да. То есть, если у меня есть вот эта ваша структура, которая называется stack
storage, да... Да, ну вот, например, у этой структуры я, наверное, хотел бы... Это массив чаров на стеке.
Наверное, я хотел бы, чтобы у этой структуры выравнивание было 16. Несмотря на то, что мне
лежит массив чаров, я хочу, чтобы выровнен он был по 16. Да. Ну, например, размер от этого меняется.
Потому что поля при создании объекта инициализируются в порядке, в котором они перечислены. Почему это важно?
Почему это существует? Что существует? Почему компилятор не может за пользователя переставить
оптимальным образом объекты внутри его структуры, а инициализировать в порядке, в котором пользователь перечислен.
Потому что раньше не было обращения к указателю плюс длина, или что? Я думаю, что это мы унаследовали
от Си в каком-то смысле, потому что вы иногда хотите, чтобы у вас... Ну, вы иногда хотите... Да нет, хотите.
Ну, если вам нужно низкоуровнево сконструировать поля по отдельности, ну, вы можете заполнять структуры,
вызывая конструкторы полей по отдельности. Ну, там конструкторов, конечно, не было. Но если у вас какая-нибудь штука,
например, вы на низком уровне что-то по сети передаете, там какие-нибудь пакеты с данными, то у вас вы можете
хотеть, чтобы эта структура... Ну, да, вы, не знаю, какие-нибудь TCP connection делаете, и там нужно, чтобы у вас
сначала был бит того, потом бит всего, потом вот то число, то число. Если вы их в структуру оформите,
то вы знаете, что они именно в таком порядке будут лежать. Тогда вы можете просто эту структуру закодировать,
там, custom, сказать ее size of и передать как биты просто сырые. Ну, напишите. Давайте выберем порядок.
Пусть для этого нужно будет написать какую-нибудь прагму не переупорядочивать. Слушайте, а я не вижу большой
проблемы. Ты что у вас так... Вы как-то так... Так тебе не приходится думать. Ты пишешь, и оно работает.
Нет, тебе об этом приходится думать, только если ты прям очень хочешь сэкономить память. Ну, если ты так,
если напишешь, ну, оно будет работать нормально. Ну, короче, не знаю. Ну, мне не кажется это прям
большой проблемой. Ну, типа, ну, если тебе прям важно, чтобы было 16, а не 24 байт, ну, переупорядочить,
да. Но зато по умолчанию ты знаешь, что поля лежат именно в том порядке. То есть, если ты начнешь
структуру как биты представлять, то ты понимаешь, что именно там лежит это поле. Ну, вот с переменными
на стеке не так. С переменными на стеке, когда вы заводите переменные на стеке, кладете int, потом double,
потом int. Компилятор имеет право переупорядочивать. Скорее всего, это делает. Если вы на стеке, на стеке
заведете int, потом double, потом int. А вот если вы их в структуру оформите, то уже и компилятор
не имеет права так делать. Вот. Ну, не знаю, хорошо это или плохо. Ну, вот так. Так вот, а как мне
сделать выравнивание не такое, как стандартное? Например, вот в этом случае. Вот здесь мы уже выяснили,
зачем. Вот здесь я хочу, чтобы этот массив чаров... Да, потому что массив чаров, он лежит, он без
выравнивания. Вот. А для этого в C++11 есть такое ключевое слово aligns. Я вот сотру заголовок,
потому что мне нужно его вписать. Значит, оно пишется после слова struct перед названием структуры.
Значит, вы можете попросить структуру выровнять как. Это ключевое слово. Оно пишется прямо без
пробела. Оно подсвечивается в IDE как ключевое слово. aligns, а дальше tip. Вы можете написать либо
жесткую константу там 16, либо вы можете написать какой-то тип и скорее всего вы хотите написать
std max align t. Да. Вот. Тогда эта структура будет выровнена как max align t. Ну, либо какой даббл.
А, в смысле max align... Что? Max align t это как long double, но может быть long double не самый на вашей
платформе жирный тип. Я не знаю, какие бывают жирнее, но... Да, вы узнаете какой... Я ставлю на то,
что там почти у всех вас 16 будет. Это тип. Ну, я могу в aligns написать число, ну как из size of,
как из... Нет, ну да. Могу написать тип, а могу написать число просто. Причем, если я напишу не
степень двой... Выравнивание это всегда степень двойки. Если вы передадите не степень двойки,
то... Не знаю, но я не пробовал никогда... Не знаю. Возможно он просто округлит до ближайшей сверх
степени двойки. А может быть... Не знаю, что он сделает. Может... Это, кстати, может быть и CE
даже, потому что... Ну, я не уверен, что это CE, потому что это же все compile time вычисляемая штука
должна быть. Правда, align? Ну, как и size of. Поэтому, в принципе, он может CE выдать. Ну, я не
думаю, что... Ну, я не пробовал. Ну, я не знаю, просто не пишите так и все. Чего там на маке? А как long
double тогда у тебя работает? Или... Что? Каких обращений? А, у тебя просто 16-байтные типы не
поддерживаются. Может быть, у тебя какой-нибудь старый мак? Ну, я не разбираюсь в маках, честно говоря.
Я не знаю. Ну, ничего не могу сказать, не знаю. Ну, странно, интересно. Может, у тебя
CLN старый тогда или Compilot? Непонятно. Ну, у меня 16. А процессор у тебя какой? Ну, на интелах,
на современных. Вот у меня интел там i7, он спокойно 16. Ну, у него там... Ну, в общем, не знаю,
от чего это зависит. Это может зависеть от процессора, может и от операционки, от, не знаю, много от чего.
Фиг знает. Можно погуглить, почитать. Вот, ну ладно, CLNs понятно, CLN of понятно. Теперь дальше. А как...
Могу ли я сделать выравнивание больше, чем MaxLineT? И надо ли мне это? Может ли мне быть это надо?
Наверное, может, но не надо. Значит, есть такая штука, как SSE. Знаешь, что такое SSE? Да, значит,
расшифровывается-то как? Что-то типа Stream, SIMD, E, не помню, как расшифровывается, E, Execution может быть. Ну вот
это само по себе аббревиатура, она расшифруется как SIMD. Классно. Вот первое... И левая эссет тоже SIMD, да?
Extensions. А, Extensions, да, отлично. Stream, SIMD, Extensions. А SIMD расшифровывается как Single Instruction Multiple Data.
Значит, что это за штука? Это такой... Кратным чему должен быть адрес твой? Да. Ну вот я тебе как раз и привел пример такой структуры, представь, что этого интернета нет.
Вот у тебя такая структура есть. Вот у тебя такая структура, нет третьего int. У такой структуры выравнивание будет 8.
Чтобы этот double лежал по адресу 8, этот лежал... Ну все, вот у этой размер 16, а выравнивание 8. Ну 4 байта Padding. Вот у этой тоже размер 16.
А вопрос в чем? Да. Ну в стринге лежит чар-звездочка с ICT, с ICT, ну и еще локатор, как мы теперь знаем. Ну все.
Нет, которые выровнены более, чем настолько байта. Вот как раз маска с ICT это такая штука. В конце концов все сводится к числам тем или иным, если ты все раскусишь, все расшифруешь.
И у тебя получается, что самое жирное, что бывает, это long double, ну и lin 128t, у него 16. А, да, бывает еще указатель. Указатель на метод, кстати, еще бывает жирным.
Вот указатели, кстати, мы про это, по-моему, не говорили. Указатели на методы, они занимают больше памяти, чем обычные указатели и чем указатели на функции. Какой сдвиг?
Указатель на метод это… Указатель на метод это… Указатель на метод класс. Да. Ну вот ему нужно хранить указатели, видимо, на что, не знаю. Да, значит указатели на методы, они занимают обычно в два раза больше памяти, чем обычные указатели, потому что указателю на метод нужно хранить не просто адрес метода, а еще и адрес, с которого начинается this относительно.
Ну, то есть, если у вас наследование, то вы можете вызывать метод родителя, нет, вы должны знать, где this лежит. Вот если вы вызываете адрес, если вы вызываете у какого-нибудь объекта наследника метод родителя, а этот родитель, скажем там, какой-нибудь виртуальный,
или он просто второй, то вот этому родителю в своем методе нужно знать, что на самом деле относительно начала объекта родитель начинается вот сдвинутый на столько-то.
То есть, если вы вызываете метод отца, у вас есть мама, папа и сын, и вы вызываете метод папы от сына, то этому методу папы при его вызове нужно знать, что this начинается позже, чем объект начинается.
Вот там в таком-то стиле, и вот в указательный метод нужно хранить эту информацию. Поэтому указательный метод жирнее, чем 8 обычно.
Указательный метод отца нельзя применять в применение у сына.
Нет, почему? Как раз можно, благодаря тому, что я сказал.
То есть, я создам указатель у отца, у структуры А указательный метод х, а потом применю этот указатель у структуры Б.
Как раз благодаря тому, что я сказал, так и можно делать.
Ну хорошо, допустим, у меня структура С от 2х А и Б наследуется.
Я использую указатель структуры B для объекта С.
То есть, как он вообще может понимать? Непонятно.
То есть, он же предназначался исходно для B, как он вообще может значиться?
Что такое указатель на функцию? Это просто адрес, где хранится исполняемый код этой функции.
Но указательный метод отличается от обычного указательного функции тем, что он как раз хранит еще сдвиг относительно начала объекта.
Где объект начинается? Ты в метод неявно перейдешь первым аргументом this.
И он думает, что this это и есть начало моего объекта.
Но если ты передал туда не настоящий этот тип, а его наследника, то ему нужно как-то узнать, что на самом деле this начинается не там, где ему дали, а правее, например.
Ну так вот, ладно, давайте вернемся к SSE. Смотрите, на современных процессорах некоторых есть такой крутой режим,
что вы можете, ну, например, 128-битное число перемножать за одну инструкцию или еще299 битное число перемножать за одну инструкцию.
Битные числа там перемножать за одну инструкцию или еще лам лучше 256 битные числа перемножать
Вы не можете перемножать 256 битные за одну инструкцию, вы можете 256 битное число интерпретировать как четыре маленьких числа и все их параллельно перемножить
А, да
Симд мультипол дута
Туда его
Да, значит я неправильно сказал, да, окей
Мультипол дута, она именно потому что мультипол
Да, наверное это более правильно, что вы можете взять четыре маленьких числа и перемножить их как бы параллельно одновременно
Честно скажу, не знаю куда это работает подробно, потому что ну просто не знаю
Вот, я не пользовался на самом деле этим на практике, только
Вот, но
Если вы, ну если вы хотите этим пользоваться
То вам может понадобиться
А
Ну вот для такого как раз вам может быть нужно, чтобы ваше выравнивание было
Ну вот, например, если у вас там SSE вот эти вот 200-256 битные
То вам может быть нужно, чтобы как раз вот эти вот, сколько там у вас получается, 8 винтов, да, лежали по адресу кратному 256
По адресу кратному 32, а не 256
Короче, если вы хотите пользоваться векторными инструкциями
Вот этими вот built-in functions, которые перемножают сразу много винтов за раз
Вам как раз может понадобиться выравнивание больше чем 16
Вот, и если вы там пишете какую-нибудь высоко оптимизированную, какую-нибудь матричную
Какое-нибудь там перемножение матриц каких-нибудь, которые вот там сделаны, знаете, там всякие библиотеки
Для нейросеточек какие-нибудь там, какой-нибудь TensorFlow наверняка этим пользуется
Вот там, скорее всего, умножение чисел, оно делается
Ну, в общем, чтобы перемножить там 4 числа, найти скалярное произведение векторов
И перемножаете там сразу большими кусками по несколько винтов, и складываете их
Вот, тогда вам может понадобиться выравнивание больше чем 16
Например, вот такой пример
То есть Lines больше чем размер максимального типа, который у вас существует
Он, ну, бывает
Если вы такую штуку делаете
Вот
Мы так и не дошли до момента, как выравнивать
Что?
Вот мы и научились выравнивать массив чаров
Да
А теперь я хочу на массив чаров положить очередной double
Так
Не раньше, чем позиция pos
Да
Как?
Ну, ты хранишь сколько у тебя байт задит
Следишь просто за адресом
Смотришь, если он не красен восьми
Первый файл
Ну, да
Я же думал, да
Эм
Нет, какой-нибудь std...
Если ты наста...
Так я не подходишь
Скоро std будет где-нибудь в адресу
И мы заживем
Do everything for me
std
std do whatever I want
Я не знаю
А что, а что
Пока, насколько я знаю, стандарт не планирует такое добавлять
Можешь в весне внести пропозал
На университет
Антон Палухин его рассмотрит
От России предложение
Стандарт внести решение
Вся издача представлены в первый класс
В первый класс
Так
Короче, с выравниванием
Понятно, ну если вы
Вручную типа стэк пишете по сути
То да, наверное, вам вручную выравнивать надо сделать
Ну, насколько я знаю, нет оператора
Может я просто что-то...
Вот у меня сейчас число, я храню, скажем, позицию
Мне приходит
Запрос на выделение памяти
Который выглядит как
Какой размер
Мне же не приходит align of
Мне еще нужно передавать в allocator align of
Или, Аня, я вызываю, типа, сейчас
Стэк сторожем ты пользуешь
Стэк сторож это твой класс, ты в стэк сторож
Можешь передавать align, да
Круто
В качестве параметра, из allocator
То есть, когда ты allocator'ом пользуешься, ты не думаешь об этом
А когда allocator вызывает методы stack storage
Он уже думает об этом
Окей, ему передали align of
Я такой
Вот у меня есть поз
Кратен вот этому вот
Я могу его сдвинуть два раза
Что-то такое сделать
Ну, типа
Ну, короче, все, давайте
Закончим
С выравниванием понятно, да
Ну, в метод stack storage
Соответствующий
У тебя есть метод stack storage?
Ну, типа push, не знаю
Alloc, не знаю
Так, теперь
Есть еще в стандартной библиотеке
Вот такая функция aligned alloc
Который можно передать
Число alignment
А есть еще оператор new
С параметром alignment
Вы можете
Есть такая форма оператора new
В которую параметром можно
Передать alignment
Alignment причем
Ну, там
Есть, я не помню, как он называется
Специальный целочисленный тип
Это, скорее всего, просто size t
Нет, это наследник size t
Ой, господи
Нет, виноват, не наследник size t
Это наследник
Какого-то типа, который является
Структурой, которая содержит только size t
Короче
Не помню этих подробностей
В общем, у вас есть
Вы можете в new передать число
Там 8
Но правильно его интерпретировав
То есть у вас там есть тип
STD, alignment
Я забыл, как он называется
Ну, короче, в оператор new вы можете
Передать параметром, когда вы выделяете
New t от 5
И вы можете попросить
Или new int от 5
New вот сюда
Вы можете alignment передать
Этот int, допустим, по 32 выровнять
Хотите как раз с s и e делать
Так, а что еще есть?
Значит, вот в
Бусте есть такой
Буст
Да, ну есть такая самая популярная
Библиотека расширения STD
Я бы так сказал
Да, да, песочница комитета
По стандартизации
Все, что есть в бусте, рано или поздно
Переходит в стандарт, просто буст
Такая библиотека, в которой есть много чего
В частности, там, кстати, есть, по-моему, и stack allocator тоже
А может и нет, я не помню
Но там точно есть много разных allocator
В том числе, там есть aligned allocator
Вот есть STD allocator
И, в принципе, в STL-то больше
Особо нет никаких интересных allocator
А вот в бусте, например, есть aligned allocator
И он как раз позволяет вам
Ну, то есть у вас же нет allocator
А представьте, что вы хотите
В контейнер передать allocator
Который бы там выравнивал
По 32, например
Вот вы не можете завести вектор
От int так, чтобы int
Были выровнены по 32
Ну, чтобы вектор был, у вас нет просто
В STL нету
Такого классного
Но вот в бусте есть STD aligned allocator
Который вы в конструктор
Передаете параметры alignment
И он просто делает то же самое, что и обычный allocator
Но просто еще выравнивание делает другое
Но, соответственно, вот этому new
Он, по сути, вызывает
Просто new с соответствующим выравниванием
Вот этому new парно
Соответствует delete
С соответствующим параметром
Но сейчас мы про это поговорим
Вот, и еще о чем я хотел сказать в этом пункте
Это bit fields
Битовые поля
Мне кажется, это тема, которую здесь стоит упомянуть
Но это такая
Не то чтобы часто используемая штука
Вот, но я в свое время как раз
Познакомился с битовыми полями, когда вот
Как раз делал то, что я говорил
Там
Бывает нужно
По сети низкоуровнево передать
Пакеты, сформировать
Структуру, которая в себе содержит
В правильном порядке заполненные
Поля
Запроса, грубо говоря
Если вы делаете TCP запрос куда-то
То вам нужно заполнить
Структуру
В правильном порядке, положив поля в нее
И вот тут вам могут помочь
Битовые поля
Что такое битовые поля
Вы можете
В структуре
Сейчас, возможно, кого-то шокирую вообще
Кто вообще знал про битовые поля?
Ну, короче
Я могу в структуре сделать вот так
Допустим int i 2.3
int j 2.5
5
Я ловлю взгляды
Ну и сотру дабл
Тогда размер такой структуры будет
1 байт
Вот это количество бит, которое вы хотите
Чтобы занимало вот это вот
Да
Это тоже пришло к нам из C
Значит вы можете написать поле
Если у него целочисленный тип
int unsigned int
short
Вы можете
Только для целочисленных типов
для вот integral types
Вот
Выравнивание структуры все равно
Если ты сделаешь int i 2.1
То у тебя будет
У тебя будет по сути 1-битовое поле
Если тебе нужно много 1-битовых полей
То ты можешь сделать
Если тебе нужно 8 1-битовых полей
Ты можешь сделать 8 вот этих вот по одному биту
Если тебе нужно 1-битовое поле
2-битное поле, потом 3-битное
То их все можешь в 1 байт упаковать за счет вот этого
А что будет, если он написал бы
Ну, короче, чтобы не кратно 8
Что не кратно 8?
int i 3 int j 4
будет кратно 8 все равно
Ну, размер структуры
он умеется будет округлен
Он все равно будет выровнен по размеру наибольшего поля
Ну, либо до одного байта
Если тут все вот так вот
Важно в том смысле
Например, ты не можешь запросить short int i
2.20
Потому что short int 16
А, только меньше
Ну да, ты можешь запросить меньше
В чем вообще шутка? Почему?
Это не шутка
Это правда
А присваивать им числа
Ааа
Не, это неожиданно
В смысле
Секунду
Ну, я могу написать s.i
равно, не знаю, 6
А можно написать равно 9
Можешь, но тогда implementation define
что произойдет
Ну да, но implementation define
что произойдет
Но он точно присвоит ему какое-то значение от 0 до 7
На самом деле нет
Вот если я напишу unsigned int
Вот сейчас я не могу присвоить 6
3-байтная битва polyint означает
от минус 4 до 3
Вообще это очень полезно
Да, если вам нужно упихать
У тебя присваивание
все еще работает как минимум
как присваивание int
Вот, что вы не можете делать
с битовыми полями
вы не можете адрес взять
Вы нельзя написать вот так
это ce
насколько я знаю
Ну а в остальном
пользуйтесь, пожалуйста
Соответственно, битовые поля позволяют вам
упаковать
Ну, теперь понятно, что
если я сюда допишу еще double
то у меня все равно будет
off этой штуки 8
несмотря на то, что это все 1 байт занимает
Но если у меня нет больших жирных
чисел, то я могу
8?
Ну если здесь я бы еще double вернул
то 8 байт занимал бы double
и 1 байт вот это
Ну все равно 16 байт был бы размер
что double надо выровнять
по 8
Слушайте, ну вы так
этому всему как-то вот
удивляетесь
что вот
Че вы
что вы
что вы гоните на плюсы вообще
вы знаете какой-то язык
который более эффективно
позволяет вот это все использовать
А в расте можно вот так делать
Я не знаю
Надо кстати посмотреть курс
по расту тоже
Но я начал было
смотреть первую лекцию
и там он что-то начал хейтить плюсы
мне не понравилось
Уважаемо
Нет, если серьезно
ну вот было интервью
этого
Яндекс.Такси Голога
который разрабатывал
трекер
и там по-моему он говорил что
ну короче
там есть такое
мнение что
на расте больше
о языке раз больше говорят чем на нем реально пишут
то есть это уже не первый
и даже не второй не пятый
язык который весь такой крутой
что он заменит плюсы говорит видали мы 10 таких
языков вот проходит пара лет
там не знаю проходит 5 лет все забывают
про него и придумают новый язык который еще круче
еще вообще шикарнее
продолжать писать на плюсах основная
ну был язык Ди
знаешь такой
ну вот
есть ГО я не знаю
иногда да
все равно не превзошел же он плюсы
пока по популярности ну ладно
ну вот ГО
про ГО говорили много что он такой
весь о себя крутой а потом там
поглубже копнул там встал
потом появились слухи что все там тоже довольно коряво
ну короче не знаю ну все это
очень холиварные вопросы так я
рассказал про элайменты про обитывай поля
и в принципе наверное это все про что хотел здесь
рассказать в этом пункте давайте я сейчас поговорю
следующим пунктом про то
что это конец этого разговора
теперь вы знаете как писать локатор
целиком
будут
да
почему
нет
нет
это же
от минус 3 до 4
не 1 байта
я думаю что 1 байта она будет занимать
вряд ли она будет выровнена по 4 байта
я думаю что нет
ну я слушайте
я не на 100% уверен
я думаю что это все на самом деле имплементейшн
дефайн
да да да
да да да
на самом деле даже то что они внутри 1 байта будут лежать
это тоже имплементейшн дефайн насколько я знаю
но на практике это так скорее всего
вы можете проверить
вот
так
ну просто стандарт он не
стандарт вообще если вы его почитаете
то там вообще нет никогда каких-либо
требований компилятору
за редким исключением что он делает там
на низком уровне как он что хранит
например если говорить про наследование там
стандарт не описывает
как компилятор обязан это все имплементировать
это уже следующий уровень
это более низкий уровень
как компилятор все реализует
в стандарте написано как это должно выглядеть внешне
а как компилятор это реализует
ну это следующий
шаг вглубь
вот сейчас я хочу поговорить
про то наконец-то
как перегружать new и delete
вот смотрите
у вас есть
как на самом деле теперь
выглядит наше обращение
к памяти
у нас есть локатор trades
через который мы обращаемся к локатору
через который мы обращаемся к new
через который мы обращаемся к молоку
который делает
много всего умного
но в конечном счете обращается
к
ммэп
еще там
некоторым функциям операционки
ну вот я напомню
теперь вот эта иерархия так выглядит
и вот
до сих пор мы находимся на уровне
языка C++
вот здесь мы находимся
на уровне OOP
вот это уровень языка C
а это уровень значит ядра
OS
kernel
так вот сейчас я вам
хочу рассказать про этот уровень
подробнее
про эти два уровня мы уже поговорили
с ними все понятно
а завтра
вам Леша расскажет про
что на этом уровне происходит
ну а тамühren
письмо
может расскажете
я не помню как там сейчас обстоят дела
с этим
вот
Хорошо, давайте поговорим про new и delete overloading. Сейчас я возможно
кого-то опять к окну, но на самом деле нет, это не очень сложная тема, она
просто немножечко неинтуитивная, но я в общем предвкушаю, что сейчас будет опять
много очень удивленных возгласов из зала. Первое и главное, что надо запомнить
про перегрузку операторов new и delete, это что есть оператор new, а есть функция с
названием оператор new, это разные вещи. Значит вот если вы хотите, если вы что-то
одно должны вынести из этого параграфа, вот я вам сказал, что это, если вы забудете
все кроме этого, то вы уже что-то узнали. Есть функция с названием оператор new,
ну то есть вы можете определить свою функцию void звездочка, оператор new от
там size t, n. Ну на самом деле, на самом деле не так, первым параметром надо
pointer принять, сейчас, так нет-нет, подождите в new мне не надо принимать pointer, да не
надо принимать pointer, да, pointer надо принимать, если я placement new, в общем я
могу определить вот такую функцию, оператор new size t, n, это как раз, я
глобально могу такую функцию определить, это будет определено, но если вы такое
определите, то ваша реализация заместит стандартную. Значит, как
переопределить оператор new? Нужно просто написать свою функцию оператор new и тогда
она заместит то, что по стандарту делается в момент вызова оператора new, но
надо понимать, что это, это не весь, скажем так, оператор new, функция оператор
new, это не то же самое, что оператор new, потому что оператор new, он состоит из
двух, его действие состоит из двух частей, выделение памяти, а потом вызов
конструктора, функция оператор new, это лишь выделение памяти, и когда говорят
про перегрузку операторов new и delete, имеют в виду именно перегрузку той части,
которая выделением памяти занимаются, перегрузить вторую часть нельзя, и когда вы
определяете глобальную функцию оператора new, имеется в виду, что вы
определяете способ для нее выделить память, и вот эта void звездочка, которую
вы возвращаете, она передается как бы в следующую часть вызова оператора new,
который вызывает конструктор на этом месте.
Когда я пишу int звездочка new, а у моего new, который я написал, вызываю оператор new.
Да, значит, конструктор в случае нтов как раз не вызывается, но если у тебя какой-нибудь тип,
ну то есть я написал t звездочка там x равно new t от там args, что происходит в этот момент?
В этот момент ищется функция с названием оператора new, если ты ее определил, если
такое void находится, то вызывается она, а иначе делается стандартное действие, после чего,
неважно, это было стандартное действие или твоя собственная функция оператора new,
на тот адрес, который вернула функцию оператора new, либо в стандартной имплементации, либо твоя,
натравляется вот этот конструктор. А теперь, что такое placement new? Вы же помните,
что у new бывает еще форма new от ptr, t от args, такое тоже бывает. Нет, это все еще оператор,
это все еще, давайте я скажу, что это new expression, вот это вот называется new expression, выражение new.
Это тоже new expression, просто с дополнительным параметром ptr. Ему соответствует функция
оператора new с дополнительным параметром как раз вот ptr, void звездочка ptr. В смысле дальше?
Прямо. Каким параметром? Вторым, да. Можно переопределить и такую функцию,
можно переопределить функцию void звездочка оператора new, значит тоже size tn всегда первым
параметром, а вторым параметром void звездочка ptr. Таким образом вы можете переопределить
placement new. Ну, например. Size tn это сколько байт выделить. Placement new не выделяет байты,
поэтому стандартная реализация этого выглядит так. Return ptr. Когда вызывает placement new? Он
вычисляет это исходя из того, как вы конструируете. Например, вот здесь вызовется функция оператора new
с параметром size of t. Это компилятор превращает вот такие выражения в вызовы функции оператора
new с правильным n. Не знаю ни одного практического случая, когда нужно было бы это переопределить. Нет.
Нет, нет, нет, сейчас. Вот именно эту функцию, я не знаю практического случая, когда можно
переопределить, но эту функцию вполне себе. И я вам рассказываю это не для того, чтобы вы
переопределяли потом вот это. Я рассказываю вам это для того, чтобы сказать, что на самом деле,
я вам вот эту функцию привел, например, их еще там штук 10 версий. Есть вот такая версия оператора new,
есть версия оператора new с параметром no throw t. Помните, я вам говорил про нее? То есть третья
версия функции оператора new. Это функция, которая принимает точно также первым параметром size t,
а вторым параметром no throw t. Помните, что делает эта функция? Она делает то же самое, что и обычный
new, столь разницей, что не кидает исключения в случае неудачного выделения памяти, просто на lptr возвращает.
Вы можете ее вызвать вот так, new от std no throw. Когда мы с вами проходили исключения,
я вам, кажется, про это говорил.
Ну в std вряд ли. В std вообще никто new не пользуется. Там только Allocator пользуется new, а все остальные через Allocator все делают.
Ну почти все стараются. Allocator стандартный не пользуется no throw, да. Если ты переопределишь оператор new,
то если ты такой оператор new переопределишь, то этого уже кажется достаточно, чтобы все контейнеры твои, все выделения памяти в контейнерах проходили через него.
Но есть очень много версий. Вот если бы у меня сейчас был проектор, я бы открыл вам страницу, но я предлагаю вам самостоятельно сейчас.
Сидите, у вас клавиноуты есть, откройте на себе периференцию страницу с оператор new function, где перечислены все существующие версии. Их там 20 с чем-то.
А можно вопрос? А вот допустим я захотел сначала выделить на куче большой массив, а потом переопределять оператор new, чтобы уже выделять от этого массива что-то. То есть чем мне пользоваться при выделении массива?
Чего? Если ты хочешь так делать, то тебе скорее всего класс Allocator надо написать свой. Как раз для этого это кажется какой-то неправильный подход.
Да, вот как раз если ты такой хочешь сделать, то тебе как раз дорога в написание своего Allocator. Как раз стандартный use case для чего нужен свой собственный Allocator.
Как там сделать, чтобы все пользовались Allocator, вообще все?
По умолчанию.
Ээээ.
Для этого не нужно, чтобы убежать?
Нет, ну скорее так. Как сделать, чтобы никто не пользовался Allocator? Просто поговорить с ними?
Ну вообще пользоваться Allocator напрямую это плохой код-стайл. Вот я вам возможно этого еще недостаточно четко произнес, вот сейчас я это произношу прямым текстом и можете считать это официальным заявлением.
Значит вот не нужно в своем коде никогда, если только вы не пишете что-то низкоуровневое, использовать оператор new. Вловну напрямую.
А Allocator тоже напрямую пользоваться нельзя.
Вот. А если, нет Allocator можно пользоваться, если вы пишете свой контейнер, то правильно пользоваться Allocator?
Нет.
В смысле нет?
А Allocator trades.
Это ерунда.
Ну Allocator имеется ввиду. Через Allocator trades, ну да.
А оператором new надо пользоваться напрямую, только если вы пишете какую-то memory-management штуку, какая-то класса, которая называется memory-management.
Если вы пишете пользовательский код, контейнер какой-нибудь там, или что-нибудь в таком духе, то не надо вызывать new напрямую.
Поэтому если вы переопределяете new, прям вот этот, то это очень низкоуровневая вещь.
Это вы, значит, переопределяете, ну реально все, ну как, вот все по сути, все Allocators, вот у вас есть много Allocators, возможно, разных, но все они так или иначе вызывают new в конечном счете.
Ну скорее всего, если только у вас нет mall locator, который вызывает mall lock напрямую, в обход new.
Кстати, это еще один вариант, какой может быть не стандартный Allocator, может быть mall locator.
Он отличается от стандарта тем, что mall lock вызывает вместо new, обходит new.
Вот, так вот, ну да, вот если вы переопределяете этот new, то, значит, не знаю, я, наверное, не ответил на этот вопрос, который задали, но за то, что другой рассказал.
Так вот, их там, да, 22 штуки, и у них у всех разные параметры.
Ну, например, есть вот этот new, есть new со вторым параметром, будет звездочка ptr, это placement new, есть с параметром no-fruit t, есть параметры с align, да, есть, как, кстати, тип называется, align val t, да, то есть есть вот тот самый, про который я говорил полчаса назад, std align val t.
Ну, я понимаю, да, с вторым параметром. Это тот самый new, который вы можете вызвать, если хотите, чтобы new был с нестандартным выравниванием.
Всем этим expression соответствует какая-то функция оператора new, и все их можно перегрузить.
Можно переопределить любую из версий оператора new, и это будет означать, что new expression вот с такими параметрами будут приходить в нее.
Вы можете переопределить placement new, например, если вы хотите, ну, по какой-то причине хотите, чтобы любой вызов placement new в вашей программе приводил к выводу все-аута, чего-нибудь там, кто-нибудь вызвал placement new.
Зачем нужно было, зачем нужно переопределять placement new, уважаемый вот коллега на первом, ну, а, не ты спрашиваешь, ну ладно, неважно.
Например, если вам нужно написать тесты к allocator, к чему-нибудь, и проверить, что правда ли они вызывают оператор new в нужное количество раз с нужными параметрами.
Ну и примерно так. На самом деле, слушайте, я вас обманул, что мне никогда не пригождалось переопределять оператор new.
Конечно, пригождалось, я как раз в тестах этим и занимаюсь, когда вы будете allocator писать.
То есть там перегружен оператор new, и проверяю, ну, я просто перегружу оператор new вот этот вот, и проверю, что вы с правильными параметрами его вызываете, с какими надо.
Вот это и это количество. Так вот, вы можете переопределить любую версию оператора new.
Ну, в принципе, все, про это сказал. И еще, что я хочу про это сказать, вы можете написать оператор new с произвольными аргументами.
То есть вы можете сделать кастомную версию оператора new. Вот у вас есть new там от разных…
Он очень часто вызывается, а арк это пакет, значит у него не низший приоритет.
Ну, если ты сделал шаблонный оператор new, да, ну обычно…
Сейчас.
Нет, оператор new, они все не шаблонные, насколько я знаю. У них здесь конкретный набор аргументов, но ты можешь сделать какой-нибудь свой собственный new, new от типа…
Да. Ну, это значит, что ты можешь написать new и что угодно. Ну, не в смысле тамплейтно, а в смысле ты можешь написать new от какого-то своего специального типа,
от какого-то тега, который будет означать, что это твой личный new, вот твой new, собственно.
И таким образом ты можешь, допустим, ну, например, ты хочешь потребовать, чтобы все выделения памяти в твоей программе проходили через твой собственный new.
Вот это, кстати, возможно, вот то, о чем ты говорил в каком-то смысле.
Ты можешь сказать, что там, не знаю…
Ну, если кто-то вызвал оператор new там вот такой или такой, то ты там бросаешь exception и говоришь неправильный new вызвали.
Или вместо него просто напрямую вызываешь свой new. А свой собственный new он что-то делает хитрое.
А, то есть, типа, сказать, вот вы вызвали обычный new, ну я вам свой подкину.
Ну да. Вот, соответственно, окей, мы поняли про оператор new, теперь про оператор delete поговорим.
А, еще, есть же оператор new квадратной скобочки, это другая вещь.
О, да.
Когда вы переопределяете вот такой оператор new, вы не переопределяете тем самым new квадратной скобочки.
Если вы хотите переопределить new квадратной скобочки, то вам нужно еще вот эту перегрузку тоже написать.
А у нее параметры уже другие, у нее уже параметры…
А, нет, у нее тоже, по-моему, один параметр size tn, тоже сколько байт.
Но формально это разные функции, их нужно отдельно переопределять.
Молок можно переопределить?
Ну да, но можно свой молок написать.
Ну просто надо, чтобы, ну надо подложить вместо C-ш на стандартной библиотеке свою имплементацию, будет себе свой молок.
А что все-таки он не будет делать с… Как он будет eline-ить? Он же не знает имя.
Он вызывает молок, а молок умеет eline-ить.
Eline val t подразумевается, что оно больше, чем 16, больше, чем max eline t может быть.
Я не знаю, может он делает что-то более умное, но вероятно он вызывает молок, смотрит, выровнен ли он как надо.
Если не выровнен, то да выравнивай.
Вот, значит, вот все есть еще версия оператора new квадратной скобочки.
Кстати, а как мне вызвать кастомную версию оператора new квадратной скобочки, если я перегрузил оператор new квадратной скобочки с произволенными параметрами, со своими?
Как мне его вызвать?
У меня же нет… Я же не могу написать new… А, нет, могу, да.
Ну так и вызвать. New от параметров t квадратной скобочки там.
Ну да, может тактично.
Да. Ну t, что-то тут. Вот, так тоже можно.
А посмотри, ну, по как выглядит выражение new-expression с ней в честь того, как это как фенон, а потом…
Ну…
Я не знаю, почему так, но вероятно так.
Так решил комитет паснартизации. Я не знаю, но у меня один ответ.
Ну, вероятно, так просто удобно.
Чтобы когда ты не… Если ты не хочешь знать про это, ты пишешь интуитивным, понятным синтаксисом.
Когда ты впервые узнаешь про new, ты не задумываешься о том, что в самом деле есть функция оператора new, которая примет два аргумента.
Ты просто вот так пишешь.
Если ты уж хочешь копнуть и перегрузить вот эти вот вызовы, то ты, значит, ну вот, такие параметры им перейдешь.
Теперь, есть ещё оператор delete. Опять, есть функция оператор delete.
И это не тот же самый, что оператор delete, ну, то есть delete-expression в нашем понимании, оператор delete, в старом понимании.
Что делает оператор delete? Он освобождает память.
А что делает… Что делает функция, точнее оператор delete? Она освобождает память, toasting that new было выделено.
Ну выражение delete, оно делает две вещи. Сначала вызывает destructor, потом вызывает функцию оператор delete, вот.
И вот вторую часть можно переопределить, первую нельзя.
То есть, если вы пишете delete, там, ptr, то это приводит к тому, что у ptr был тип-то звёздочка, тогда вызывается деструктор t по адресу этого ptr, а потом выдаётся функция оператор delete от ptr.
И вы можете её переопределить. То есть вы можете сказать void оператор delete. Какая у неё сигнатура? У неё сигнатура void звёздочка ptr. Ну и вот она там что-то делает.
По-моему да. Ну она вызывает free, а во free не надо передавать размер, насколько я помню. Вот. Дальше. Но бывает же delete с кастомными параметрами.
А как вызвать delete с кастомными параметрами? Ну вы можете перегрузить любой delete с кастомными параметрами и можете даже написать delete со своими собственными параметрами.
Но как вызвать delete с кастомными параметрами? Ведь вы как? Delete? Нет, к сожалению, такого синтаксиса не существует.
Вам придётся явно вызывать оператор delete, если вы хотите вызвать delete с кастомными параметрами.
Значит если у вас есть, если вы хотите сделать delete нестандартный, а какой-то с кастомными параметрами, то вам придётся вручную сначала делать диструктора, потом писать 2.2. оператор delete от параметров нужных.
Нет, нужно писать. Потому что delete это и название оператора, а не название функции. Delete это ключевое слово, если бы ты написал без слова оператор, то он бы не понял.
Потому что, ну обычно так пишут, можно написать и без 2.2. просто для надёжности обычно пишут 2.2. вдруг, если хочешь глобальный оператор delete вызвать.
Type name не всегда обязательно писать, но всегда пишут.
Потому что ошибка с type name вызывает, получается только если у вас шаблонное что-то, ещё шаблонное, у него ещё есть шаблонная специализация, ещё что-то шаблонное, функция какая-то.
И вот тогда у вас компилятор не сможет определить, что это. Но мы всё равно всегда пишем type name.
Ну кстати в C++20 ослабили условия, когда надо писать type name. Если компилятор может обозначать, что вывести, то не надо уже писать type name в некоторых ситуациях.
Так, вопрос slash задача. Представьте, что у вас, кстати я про это узнал несколько лет назад, мне задали прикольный вопрос, там один знакомый на собеседовании спросили.
Вот как сделать, чтобы запретить все выделения памяти на куче наоборот?
Нет, так, подождите, сейчас. Вот представьте, что у вас есть, ну да, вот представьте, что вы, вот у вас есть какой-то тип, вы хотите, чтобы этот тип, скажем, нельзя было выделять на куче.
Можно только на стэке, да, вот конкретно этот тип. А такое можно сделать, вот я вам забыл сказать, извините, можно определить оператор new для специально, для типа своего.
Вот это то, что я вам рассказал, это глобальный оператор new и delete. Но есть, бывает еще оператор new для своего типа, как это пишется? Вы можете, значит, вот вопрос, как, например, запретить типу создаваться на куче?
Для этого нужно определить оператор new для своего типа. Как вы это делаете? Вот, допустим, у меня есть какой-то тип, там struct, не знаю, my struct, я сейчас отру вот это вот, то есть у меня есть свой собственный тип, которым я хочу запретиться создаваться на куче.
Я могу сказать, там не знаю, как запретить создание на куче. Я для структуры s определяю свой оператор new, его можно сделать членом класса.
Его можно сделать членом класса. Можно сделать оператор new членом класса. Для этого я пишу оператор new в телекласса. Я пишу void звездочка оператор new, ну, короче, то же самое, пишу просто.
Все 20?
Не-не, одного, ну, если я хочу стандартный u запретить, то вот...
Конечно.
Не-не, я вот предполагаю, что люди вот...
Стандартным локатором, если все пользуются и ничего такого не вытворяют, вот как запретить создание s на куче?
Объявили, но определили.
Не-не, определили. Я сейчас определю и напишу throw, exception, тесты не пройдены, у вас стекло локатор должен был не выделять ничего на куче, а вы выделили.
Короче, пацаны, сдаемся кастомным new каким-нибудь.
Нет, ну в смысле, я прочекаю, что у вас new не переопределен ни разу, а потом переопределяю его сам.
Никакой new не переопределен. Я могу вот тот new переопределить.
Слушайте, я код review буду делать в конце концов. Не я, а кто-то другой.
Ну, короче, можно для своей структуры, можно, короче, все вызовы оператора new и оператора delete для своей структуры делать иначе, чем для остальных.
Вот так можно сделать еще.
Вот здесь n, кстати, по-моему, будет означать количество объектов, а не количество byte, но я не помню, не уверен.
Наверное, все-таки количество, короче, не помню.
Ну, не помню, надо прочитать.
Ну вот, а оператор delete аналогично можно определить в теле структуры, ну объявить и определить.
Соответственно, когда вы пишете new...
Ну delete, функция оператора delete для своего типа тоже можно в теле определить.
Сначала мы уничтожим наш класс, а потом вызовем его метод.
Так это статический метод.
А здесь почему не написано статический?
Вот, это отличный вопрос, который я хотел обсудить в следующем.
На самом деле, давайте сначала закончим про оператор delete.
Так вот, я могу переопределить new и оператор delete для своего типа.
Тогда, если на самом деле я немножко пропустил, вот если у меня написано new t от чего-то, то как работает это выражение?
На самом деле, я пропустил один шаг.
Я сказал, он ищет, определён ли ваш собственный оператор...
Но он сначала ищет неопределённый оператор new для этого типа.
Понятно, что частное предпочтительное общее, он сначала посмотрит, нет ли оператора new члена этой структуры.
Потом только посмотрит, нет ли глобального переопределённого оператора new.
Потом только вызовет стандартный, если нет его.
Так вот, а почему не написано static?
Да потому что static, вот прям, ну это костыль такой, если вы переопределяете оператор new или delete,
а не static всё равно, если даже вы не напишете static.
Ну, они автоматически считают, что static, просто компилятор как бы за вас допишет static.
Поэтому можно не писать static, но по смыслу, конечно, static.
По-хорошему тут надо написать static.
Это как запретить создание на кучу, переопределить свой оператор new.
Вопрос, а как на стеке запретить?
Вот представьте, у меня есть такой класс, который я хочу, чтобы можно было создать только лишь на куче, а на стеке нельзя.
Ой, сейчас, подождите.
Если я...
Да, вот как мне запретить создание объектов моего класса на стеке?
Ну какой?
Чего проверять?
А, типа мы перегрузим new, и в нём будем...
Перегрузим свой new, и в нём будем делать counter++, и в вызове конструктора будем проверять, что counter...
Ну, тогда, точнее, наверное, это скорее не counter, нужно обуливский флажок.
Типа, когда ты этот самый...
Сбрашешь его на false, только что был вызван new, тогда да, иначе exception.
Ну, такое можно, не знаю, ну, наверное, можно.
А есть кастели.
Но вообще до C++20 у этой задачи не было нормального решения.
В C++20 для этой цели добавили так называемый destroying-оператор-delete.
Сейчас я расскажу, что это такое.
Что такое destroying-delete?
Это такой оператор-delete, который не вызывает деструктор.
Вот как есть placement-new, который не выделяет память, а лишь вызывает конструктор, ну, по сути,
есть ещё специальная версия оператора-delete, который не вызывает деструктор, а лишь память освобождает.
Вот.
Тогда что вы можете сделать?
Вы можете, пользуясь destroying-оператор-delete, вы можете фактически сделать,
вы можете своему классу сделать приватный деструктор и вызывать его руками в операторе delete.
Ну, зачем нужен destroying-оператор-delete?
Чтобы вы деструктор сами вызывали, скажем, из этого оператора.
Вот.
Тогда, если вы сделаете приватный деструктор, то никто на стеке создать ваш объект не сможет.
Потому что, ну, если приватный деструктор...
Destroying-delete, да.
Ну вот, почему он так называется, я не знаю.
Значит, есть такая форма оператора-delete, которая принимает PTR, а ещё std destroying-delete-t.
Destroying-delete.
Это версия оператора-delete, которая не вызывает деструктор.
Как это работает?
Значит, если вы в своей программе вызывает...
Ну, вы просто делаете приватный деструктор, скажем, к своему классу,
тогда никто не может создать его на стеке, по очевидным причинам.
Приватный деструктор.
Но переопределяйте для него вот это.
Тогда никто не сможет вызвать...
Ну, никто никак не сможет создать ваш класс, кроме как,
используя вот этот destroying-оператор-delete.
Ну, тогда вам придётся...
Всякому, кому нужно создавать ваш класс, ему придётся пользоваться операторами new-delete явно напрямую.
Он не сможет создать его на стеке, это значит, что ему придётся создавать его на куче.
То есть ему придётся использовать вот этот destroying-оператор-delete, чтобы его удалить.
Все остальные операторы не смогут его уничтожить, потому что деструктор приватный.
А этот оператор, будучи членом класса, сможет.
Ура, нормальное решение, наконец-то!
Да, начинай с C++20.
Ну, этот оператор, вы в нём просто сами реализуете вызов деструктора.
Тогда никто не сможет воспользоваться стандартным оператором delete,
и на стеке создать тоже не сможет.
Но зато единственный способ уничтожить ваш объект...
Ну и конструктор тоже private можно сделать, и сделать оператор new членом, который будет его вызывать.
Вы делаете оператор new для своего класса.
Не-не-не, ну вы можете сделать...
Сейчас, вы можете...
А, да, всё, правильно, ты прав, действительно.
Вот, поэтому как раз через оператор new это не решается.
Если бы приватный конструктор сделал, это не поможет.
Потому что оператор new-то сам по себе конструктора не должен вызывать,
а конструктор потом вызовется сам.
А он приватный, поэтому он не сможет вызваться.
И поэтому решение вот через деструктор такое.
Через запрет деструктора и destroying оператор delete.
Вот такая история.
Слушайте, ну последняя вещь, которую я хочу сказать, такая.
Смотрите...
Нет.
Этого я больше не буду говорить.
Вы как-то слишком начали серьёзно к этому относиться.
Короче, последняя вещь, которую я хочу сказать, такая.
Смотрите.
Представьте, что я написал new t от каких-то аргументов.
Ну и там t звелочка ptr равно new t от каких-то аргументов.
О чём нам надо поговорить ещё?
Какая проблема?
С нами на всю жизнь.
Начиная с декабря прошлого года.
Да.
Смотрите, что будет, если конструктор t кинет исключение?
Ну new я напомню ещё раз.
Он сначала выделяет память, потом вызывает конструктор t на выделенной памяти.
Вот.
А что если конструктор t кинет исключение?
Память-то уже выделена.
А кто delete вызовет?
Он вызовет.
Кто?
Вызовет delete.
Минуточку.
Оператор new сам не вызывает никакого конструкции.
Мы же, кажется, это обсуждали.
Сам вызов, просто вызов конструктора, заход функции.
Он же на new кинет исключение.
Почему?
Да, конструктор не может.
Нет, не конкретно именно выполнение чего, каких конструкций.
Мы поставим конструктор.
А сам заход функции.
Мы же делали как бы тракеечно, мы даже навешивали на конструктор.
Нет.
Ты все забыл уже.
Все равно может быть так, что мы вызовем конструктора,
и он вернется с исключением.
И нам нужно как-то обработать.
Не от памяти выделять.
Не от памяти обработать.
Значит, ну...
Нам это нужно в тракеечи оборачивать, что ли, конструктор.
Мы не можем здесь набирать тракеечи.
Как мы память сводим тогда?
Память сейчас вызовет delete?
От не вернувшегося ptr?
Ну, мы можем сейчас.
Или ptr сегодня вернет?
Ну, вот как раз проблема в том, что вы ничего не можете с этим сделать.
Поэтому еще в стандарт добавлен костыль.
На самом деле это сделано за вас.
Вот это такой вопрос с подвохом.
Вас могут где-нибудь спросить, а как же тогда?
Но на самом деле ответ заключается в том, что
действительно компилятор сам...
Все, отлично, мне пора уходить.
Все, отлично, мне пора уходить.
Компилятор сам вызывает оператор delete.
Компилятор сам вызывает оператор delete.
Функцию именно оператор delete.
С соответствующими параметрами.
Если здесь было бы исключение.
То есть на самом деле вызов этого...
Это выражение работает еще чуть сложнее, чем я рассказал раньше.
Бла-бла-бла.
Все, он там выбирает правильную версию new.
Вот этот конструктор и она сама...
Это забота компилятора все это реализовать.
Если new...
Если конструктор кинул исключение, то компилятор
ищет оператор delete с соответствующей сигнатурой.
Если он был кастомный, вызывает его.
Если не было кастомного, вызывает стандартный.
Если не было кастомного, вызывает стандартный.
Итог потом возвращается и про какие-то исключения.
В смысле, реализация языка.
Вот компилятор.
Вот эти вот вызовы...
Вот эти выражения превращаются в такой код.
Вот на самом деле.
