Ну что, поехали? Напомню, что в прошлый раз мы с вами перешли в новую модель сбоев,
византийских сбоев, где сбоенные узлы могли не просто рестартовать, не просто перезагружаться,
они могли еще и произвольным образом нарушать протокол. И в этой модели мы делили узлы не на
корректные и сбоенные, а скорее на честные и нечестные, на честные узлы и злоумышленников,
которые пытаются систему привести в какое-то некорректное состояние, возможно, кооперируя
свои действия. И в этой модели мы по-прежнему хотим уметь решать задачу консенсуса, то есть задачу
репликации через задачу консенсуса. И в прошлый раз мы с вами показали, во-первых, что решать задачу
консенсуса в модели с византийскими сбоями, где узлы произвольным образом нарушают протокол,
можно, если число узлов в три раза больше, число честных, число реплик в три раза больше, чем число
сбоев, которые мы закладываем. Мы доказали вот эту нижнюю оценку двумя способами. Во-первых,
для разных условий. Во-первых, мы доказали, что даже в случае, когда у нас сеть синхронная,
но когда честный узел может в голове, сбойный узел может в голове моделировать честные узлы,
то вот в таких условиях нижнюю оценка справедлива. И во-вторых, мы показали, что если сеть частично
синхронная, то даже имея механизм цифровых подписей, даже имея инфраструктуру открытых ключей,
мы не можем переживать вот больше, чем f сбоев, если у нас 3f плюс 1. Помимо этой оценки, мы с вами
построили алгоритм Ben Oro, который решал такую довольно искусственную задачу бинарного консенсуса,
причем решал ее не очень эффективно, а именно ему требовалось 5f плюс одна реплика. Этот результат
сам по себе для нас не очень ценен, все-таки мы заботимся о том, чтобы строить что-то прикладное,
что-то эффективное. Но все же мы, разбираясь с этим алгоритмом и с такой наивной задачей консенсус
изолированной, мы с вами изучили две полезные техники, которые мы с вами сможем добавить в свой
арсенал и с помощью них строить что-то более практичное, тема сегодняшнего занятия. Во-первых,
мы с вами обратили внимание, что для того, чтобы вообще строить какие-либо алгоритмы в
бизантийской модели, нам нужно решать задачу аутентификации. Если узел A получает сообщение от
узла B, то узел A должен действительно убедиться, что это сообщение отправлено именно узлом B,
а не каким-то другим узлом-злоумышленником, который только представляется как B. И для этого нам
был нужен механизм цифровых подписей. Это не единственный механизм, с помощью которого можно
решать задачу аутентификации, и мы сегодня рассмотрим другой. Но в первую очередь мы сегодня
будем работать именно с цифровыми подписами. Это будет наш основной механизм аутентификации.
Вторая техника, которую мы увидели, обобщала ранее известную. Раньше мы работали с простыми
системы кворумов, где кворумы пересекаются, по крайней мере, по одному узлу. Сейчас нам этого мало,
потому что в пересечении кворумов может быть нечестный византийский узел, и он нам может
соврать. Поэтому мы перешли к технике византийских кворумов, где кворумы пересекаются либо по 2f
плюс в одном узлу, такая система кворумов называется маскирующей, или по f плюс
в одном узлу. В первом случае, когда в пересечении f плюс в один узел, мы знаем, что в пересечении
большинству честных, и вот большинство честных могут подавить нечестные просто количества. Если же
кворумы пересекаются по крайней мере по f плюс в одном узлу, то мы уверены, что в пересечении есть
по крайней мере один честный узел, и, если через кворумы, через пересещение кворумов, передаются
аутентифицированные данные, то есть данные, снабженные подписями, то этого
будет достаточно. Вот сегодня мы будем использовать именно такие системы
кворумов, они называются dissemination, системы кворумов, рассеивающие это так.
Но все же, у нас есть нижняя оценка n больше 3f, у нас есть цифровые
подписи, у нас есть византийские кворумы.
Но мы пока не знаем, достижима ли эта оценка снизу.
Можем ли мы построить алгоритм консенсуса, который будет переживать
f византийских сбоев и обходиться 3f плюс 1 репликой, а не 5f плюс 1?
Вот сегодня мы изучим такой алгоритм, и он будет называться practical BFT.
BFT.
Это результат 1999 года, авторы Мегель Кастро и Барбара Лисков.
И этот алгоритм будет решать незадачу консенсуса в изоляции, как когда-то
мы называли single degree praxis, а этот алгоритм будет решать задачу
репликации лога, как multipaxis или как raft.
И этот алгоритм снова будет работать как multipaxis или raft в некоторые
жесткой фиксированные конфигурации, но уже в конфигурации оптимального размера,
а именно в конфигурации из 3f плюс 1 узла.
Вообще говоря, в византийской модели различают два подхода.
Когда мы фиксируем количество реплик и когда мы не фиксируем.
Вот когда мы фиксируем количество реплик, такой подход называется permissioned.
В следующий раз у нас будет bitcoin, и там число реплик не фиксировано,
реплики могут свободно присоединяться к сети и уходить.
Такой подход называется permissionless.
Ну что, давайте поговорим про то, как этот алгоритм работает.
Точнее, не так. Прежде чем говорить про то, как он работает,
нужно вообще представить, зачем он нам.
Вот он реплицирует некоторый лог, а этот лог нужен для чего?
Каково состояние, которое мы будем реплицировать?
Раньше мы говорили, что это не очень важно.
Пусть мы реплицируем некоторый автомат.
В него поступают команды, нам эти команды нужно упорядочить на разных репликах,
и эти реплики будут применять в одном и том же порядке
и двигаться по полной той же истории.
Сегодня мы все еще будем абстрагироваться от конкретного реплицированного состояния,
но на будущее скажем, что все-таки оно не совсем произвольное,
потому что с этим состоянием работают клиенты,
среди которых тоже могут быть византийские узлы,
которые тоже могут быть злоумышленниками.
Поэтому, вообще говоря, само реплицируемое состояние
должно быть устойчиво к нечестным клиентам.
Как именно это состояние будет устроено?
Мы поговорим в следующий раз на примере Биткоина.
Ну а пока лишь скажем, что мы будем использовать немного альтернативную лексику,
мы будем говорить не про команды, мы будем говорить про транзакции.
И вот пусть у нас есть 3F плюс 1 реплика.
Мы зафиксируем, пусть мы готовы пережить один отказ,
и поэтому мы используем 4 реплики.
На картинках у нас всегда будет сегодня 4 узла.
И вот они как-то решают задачу репликации лога.
Они реализуют некоторый ordering service.
Пока даже не важно каким образом.
И с этой системой работает клиент.
Клиент отправляет сюда свою транзакцию.
Он хочет, чтобы транзакция зафиксировалась
в порядковой номеротности на других транзакций,
и рано или поздно применилась к некоторому репликированному состоянию.
После чего клиент получит некоторый ответ.
Мы сейчас говорим про то, как устроен протокол клиента.
Во-первых, заметим, что с византийской системой
вот так вот прям взаимодействовать нельзя.
Мы могли так взаимодействовать с мультипакс и с мультирафтом,
потому что каждый узел вел себя честно.
Но сейчас, если мы отправляем свою транзакцию к какому-то конкретному узлу,
а он окажется с византийским, то он может нам просто выдумать ответ.
Базовое правило любой византийской системы,
мы никогда не можем доверять ответу какого-то конкретного узла.
Мы всегда должны доверять только группе узлов.
Поэтому на месте клиента нам мало дождаться одного ответа.
Видимо, нам нужно дождаться некоторого количества ответов от разных реплик.
У нас всего 3f плюс 1 реплика.
Из них f могут быть византийскими или просто отказать.
Поэтому мы можем рассчитывать на то, что мы дождемся 2f плюс 1 ответа.
Эти ответы могут быть разными, потому что среди реплик, которые ответили клиенту,
есть честные, есть византийские.
Но мы предполагаем, что все честные реплики ответили одинаково.
И мы знаем, что среди... раз всего мы получили 2f плюс 1 ответ,
то среди них есть, по крайней мере, среди этих ответов есть не более чем f ответов от византийских реплик,
а значит, по крайней мере, f плюс 1 ответ от честной реплики.
И вот эти честные ответы смогут перекрыть византийские.
Что мы делаем? Мы на месте клиента дожидаемся, ждем такого количества ответов
и выбираем ответ, который повторяется, по крайней мере, f плюс 1 раз.
Разумеется, мы должны учитывать, что византийские узлы могут пробовать представляться другими узлами,
поэтому все респонсы должны быть снабжены цифровыми подписами.
То есть, когда какая-то реплика отвечает, то она подписывает свой ответ.
Так что на месте клиента мы дожидаемся такого количества ответов,
выбираем f плюс 1 одинаковый, и мы теперь уверены, что среди этих f плюс 1 одинакового
есть ответ, по крайней мере, от одного честного узла.
Ну а значит, если честные узлы корректно решают задачу консенсуса,
то значит и все честные узлы дали бы такой же ответ, так что мы выбираем его.
Правда, в таком протоколе есть неудобство, а именно клиент отправляет запрос одному узлу,
получит ответ от многих. Нам все же было бы удобно работать в модели клиент-сервер,
где мы общаемся только с одним узлом через некоторое соединение.
В принципе, такое техническое ограничение, желание сделать именно так,
никак не мешает нам воспользоваться тем же самым протоколом.
Просто пусть вот этот набор сообщений, которые служат доказательствам того,
что честные узлы выбрали некоторый ответ, может накапливать не сам клиент,
а может накапливать узел, с которым клиент общается.
То есть мы вот эти стрелки сотрем,
и пусть другие реплики ответят не напрямую клиенту,
а вот тому узлу, который с клиентом общался.
И вот уже этот узел отправит клиенту не один респонс,
а вот такой набор респонсов, каждый из которых снабжен цифровой подписью.
И вот этот набор подписанных ответов мы будем называть сегодня
коронным тертификатом.
Вот именно с помощью коронных тертификатов
в византийской системе, конкретно в Practical BFT,
узлы смогут доказывать другим что-то про третьи узлы.
То есть здесь один узел может сказать нам, что ответная система именно такой,
и приложить вот этот коронный сертификат,
тем самым клиент сможет действительно проверить, что его не обманули.
Правда тут можно быть еще аккуратнее и подумать над тем,
что вдруг византийский узел отправит коронный сертификат,
но просто для другой транзакции.
Поэтому мы можем сделать еще более аккуратно
и сказать, что у нас респонс привязан к некоторому дайджесту,
где дайджест это криптографический хэш транзакции.
Вот если транзакции уникальные, то есть у них хэши будут разными,
ну по модулю того, что конечно в хэш функции может возникнуть какая-нибудь коллизия.
Ну вот, если все же транзакции можно различать по хэшам,
а мы в следующий раз увидим в Биткоине, что действительно это можно делать,
то пусть реплики, которые отвечают клиенту,
привязывают свои ответы к хэшу транзакции, подписывают свой ответ,
и тогда здесь мы на месте клиента будем уверены,
что нам дали сертификат именно для нашей транзакции.
Ну и это конечно еще не все, потому что что же делать клиенту,
который просто не получил ответ от реплики?
Он конечно же завел тайм-аут, завел таймер, отправил свою транзакцию,
и если этот таймер протух, если тайм-аут истек,
то клиент вообще говоря не понимает, что происходит.
Может быть, конечно, этот узел умер, а может быть, этот узел злоумышленника
он намеренно умолчал об этой транзакции и просто игнорировал ее.
Вот нужно какие-то дополнительные действия придумывать,
но мы к ним вернемся позже, а пока заметим еще одну важную деталь.
Вот здесь клиент, работая с системой, должен проверять цифровые подписи ответов от реплик.
Ну и для того, чтобы их проверять, он собственно должен понимать,
какие открытые ключи у этих самых реплик.
Для этого нам нужна некоторая вспомогательная инфраструктура.
Ну вот для того, чтобы вообще пользоваться цифровыми подписями,
нам нужна цифровая инфраструктура, которая называется удостоверяющим центром.
Вот представим себе, что вы браузер,
и вы идете общаться с некоторым сервером по безопасному соединению.
Вы должны узнать открытый ключ у этого сервера, чтобы дальше там работала криптография,
чтобы работало безопасное соединение.
Но если вам сервер отправит просто пару, я, сервер, и вот мой открытый ключ,
то, конечно же, у вас нет оснований ему верить.
А что если это с вами разговаривает на самом деле злоумышленник?
Поэтому этот документ, который связывает identity и открытый ключ,
нужно чем-то подкрепить.
Но вот браузер серверу не доверяет.
У серверов много разных на свете, мы не можем доверять каждому по умолчанию.
Но, может быть, есть некоторый участник удостоверяющий центр.
И мы считаем, что вот этому участнику доверяют все.
Доверяют в том смысле, что для него открытый ключ этого Си всем известен.
И тогда, чтобы сервер мог представиться нам, чтобы он мог сообщить нам открытый ключ,
он идет в удостоверяющий центр, и удостоверяющий центр выпускает вот такой документ,
который называется цифровым сертификатом, который связывает С и открытый ключ,
и этот сертификат подписан секретным ключом удостоверяющего центра.
После чего сервер может отправить нам этот сертификат,
и если мы доверяем С, то значит, мы теперь можем доверять и серверу.
Вот эта конструкция называется инфраструктура открытых ключей.
И наш протокол, раз он пользует этими цифровыми подписями,
раз клиент все это проверяет, эти кормные сертификаты, ему нуждается инфраструктура.
Вопрос, почему мы доверяем в конце концов какому-то одному удостоверяющему центру?
Ведь весь смысл нашей конструкции состоит в том, что мы можем взять много реплик
и разместить, доверить их эксплуатацию разным организациям.
Но говорят в этом контексте про консорциям, есть разные организации,
каждый из них отвечает за какую-то группу реплик,
и мы каждой конкретной организации на месте клиента не доверяем,
но мы все же считаем, что две трети этих организаций, две трети реплик будут честными.
Нам этого достаточно. А тут мы почему-то доверяем одному удостоверяющему центру.
Но это на самом деле не страшно.
Можно доверять и нескольким удостоверяющим центрам,
и тогда можно отсеять каких-то подозрительных.
То есть не то чтобы у нас есть одна единственная точка доверия, их можно дублировать.
И если говорить про реальную жизнь, то тут не то чтобы прям один удостоверяющий центр,
потому что он бы, конечно, не выдержал такой нагрузки.
На самом деле в жизни у нас есть целая иерархия удостоверяющих центров.
И когда вы приходите к серверу, он дает вам сертификат, который подписан
с некоторым удостоверяющим центром.
Откуда вы знаете его сертификат?
Откуда вы знаете его открытый ключ?
Для этого ключа есть свой собственный сертификат,
который подписан удостоверяющим центром более высокого уровня.
Ну а у этого удостоверяющего центра более высокого уровня снова есть некоторые родители,
которые выпускают для него сертификат.
Ну, и в конце концов мы приходим в некоторые корневые удостоверяющие центр.
и если вы браузер, то просто вы в себе несете сертификат
этого самого корневого удостоверяющего центра.
После этого вы можете спуститься по цепочке и проверить
сертификат какого-то конкретного узла.
В общем, такая инфраструктура нам требуется.
Мы ей сегодня не явно пользуемся,
просто потому что мы пользуемся цифровыми подписами.
Итак, мы обсудили протокол клиента,
как ему получить ответ от системы,
как среди разных ответов выбрать ответ честных узлов,
в предположении, что византийских узлов все-таки не больше,
чем заложенный параметр f.
Ну а если больше, то рассчитывать тут не на что, конечно.
Мы об этом в прошлый раз говорили.
А теперь нужно разобраться, что все-таки внутри этого контуры происходит.
Как именно будет устроен сегодняшний алгоритм?
Вот пока вся эта конструкция, этот алгоритм мало зависела.
Зависела, но не правда, она зависела,
но только в том смысле, что этот алгоритм, он permission,
то есть он фиксирует число реплика.
Теперь перейдем внутрь этого контуры
и поговорим, как устроен PBFT.
Этот алгоритм возник не на пустом месте,
он развивает идеи другого алгоритма,
который называется just-time replication.
Это алгоритм, который реплицирует лог
на не византийской модели, а в обычной,
где есть рестарты и отказы узлов.
То есть это некоторый аналог мультипаксиса и RAFTA.
Но любопытно, что этот алгоритм был придуман раньше и RAFTA,
который был придуман в 2012-13 году,
и мультипаксиса, который придуман в начале 90-х.
Just-time replication придуман в 1988 году.
Но так случилось, что он не получил популярности,
не получил распространения,
и мы знаем про мультипаксис, мы знаем про RAFTA,
а про just-time replication мы говорим в контексте
такого алгоритма, который опирается на VR.
И вообще говоря, это удивительно,
потому что just-time replication — это алгоритм,
который очень разумно, очень понятно устроен.
В нём, как и в мультипаксисе, как и в RAFTA,
есть понятие эпохи.
Только название у этих эпох, опять, особенное.
В паксисе это были ballot numbers, в RAFTA это были термы.
В just-time replication эпохи называются view.
Отсюда и название протокола.
И к этим эпохам, к этим view, как и в RAFTA,
привязано понятие лидера, привязан лидер.
Узел, который занимается упорядочиванием
всех команд, транзакций, которые поступают от клиентов.
Этот лидер называется primary.
Primary всегда находится в некотором терме.
Опять же, just-time replication использует эти view
ровно таким же способом, как их использует RAFTA,
просто для того, чтобы блокировать устаревших лидеров.
Если система перешла в новую эпоху,
если большинство узлов следует уже за новым primary,
то старый primary не может закомитить новую транзакцию,
потому что в пересечении будут реплики,
в пересечение его кворума и кворума, которые уже проголосовали
и в праймари будет реплика, которая отвергнет,
глядя на эту view, сообщение от праймари из прошлой эпохи.
На этом сходство не заканчивается, их довольно много.
Я бы сказал, что этот алгоритм довольно сильно напоминает RAFTA,
потому что, так же, как и в RAFTA, этот алгоритм декомпозирован
по двум фазам. Фаза, где есть primary
и он занимается репликацией,
и есть фаза, где выбирается новый primary,
она называется viewchange.
Вообще, когда авторы RAFTA писали свою статью,
они там отдельно говорят, они сравнивают свой алгоритм
с мультипаксосом и говорят, что он проще,
потому что в мультипаксосе выбрана неверная декомпозиция,
что задача репликации лого поделена по слотам,
и в каждом слоте решаются свои независимые задачи консенсуса,
и ее решение не имеет какого-то осязаемого физического смысла.
Сложно увидеть физический смысл в sync-decrep-аксосе,
пока мы его не промасштабируем на весь лог.
Только тогда у нас появится понятие эпохи,
лидера, блокировки старых лидеров и так далее.
Так вот, эта идея декомпозиции по фазам,
по фазе выбора лидера и по фазе репликации,
она была придумана еще в 1988 году.
Причем мне кажется, что даже в этом подходе
была выбрана более удачная лексика,
потому что в RAFTA смена эпохи называется выбором лидера,
а в view-stamped replication она называется view-change.
И мне кажется, что этот термин лучше подходит,
потому что он лучше отражает суть сложность задачи.
Сложность задачи не в том, чтобы выбрать нового лидера,
а в том, чтобы аккуратно сменить эпоху
и не забыть все ранее закоммиченные команды.
Напомню, что в RAFTA доказывали,
что транзакция команды закоммичена,
если она переживает смену эпохи,
и она будет непременно находиться в логе лидера любого будущего терма.
Вот сложность в том, чтобы аккуратно эпоху сменить.
И лексика view-stamped replication эта сложность подчеркивает.
Почему же алгоритм, если он такой разумный, был надолго забыт?
Дело в том, что оригинальная статья вышла довольно, кажется, запутанной,
и там алгоритм view-stamped replication, сам алгоритм репликации,
в том, что эпоха декомпозирован от каких-то ненужных инженерных подробностей,
но, кажется, уже в 2000-х годах авторы этого алгоритма
переписали статью заново,
написали статью, которая называется view-stamped replication revisited,
и вот она уже очень хорошая, очень понятная,
и я всем рекомендую ее прочитать.
Ну хорошо, мы собираемся сегодня для репликации использовать
примерно такие же идеи.
У нас четыре реплики.
Давайте мы нарисуем процедуру репликации.
У нас будут четыре реплики.
И среди них одна из реплик назначена primary.
Давайте немного передвинем нашу картинку.
По-другому организуем пространство.
Нарисуем ее вот здесь, чтобы места было побольше.
Вторая реплика является primary.
Ее функция упорядочивать транзакции,
которые поступают от пользователей.
Мы пока не говорим, откуда этот primary взялся,
как именно он выбран.
Пусть он уже есть, но и мы будем пользоваться этим фактом.
Он получает транзакцию от пользователя,
и его задача выбрать для этой транзакции порядковый номер,
выбрать ее позицию в логе.
После чего primary раздаст эту транзакцию с присвоенным порядковым номером другим репликом.
Это первая фаза.
Здесь мы отправляем сообщение, которое называется prepare.
Primary говорит остальным репликам, что в текущей эпохе В
я присвоил порядковый номер S транзакции с дайджестом,
здесь криптографическим хэшом D.
И разумеется, он свое сообщение подписывает.
Своим секретным ключом.
И отдельно предлагает к этому prepare собственно отправленную транзакцию.
То есть в этом сообщении только хэш, а здесь отдельно сама транзакция.
Обратите внимание, что сегодня мы говорим именно про сообщение.
Вот скажем, в протоколе RAFT в статье используется термин RPC, то есть удаленный вызов.
Вот нам сегодня важно, что это не RPC, это именно сообщение,
потому что мы эти сообщения дальше будем пересылать другим узлам.
Но чуть позже увидим, как это будет работать.
Итак, у нас есть реплики, они получили от primary команду,
потому что нужно положить в слот S транзакцию с дайджестом D вот в текущей эпохе.
Но, конечно же, да, и вот в USTMP replication дальше эти реплики добавляли себе в лог эту транзакцию,
отправляли подтверждение primary, primary собирал quorum,
и в общем команда после этого коммитилась.
Разумеется, в нашей византийской модели такого наивного протокола будет уже недостаточно.
Потому что просто-напросто primary может быть византийским,
и он может не исполнить функции, которые у него возложены.
Вот давайте подумаем, что может делать primary, как он может нарушать протокол.
Ну скажем, он может получить транзакцию и продублировать ее,
то есть назначить ей сразу несколько порядковых номеров.
Или он может транзакции игнорировать, может игнорировать все транзакции,
может игнорировать транзакции какого-то пользователя, которого primary не любит.
Не знаю почему. То есть он может выкидывать какие-то конкретные транзакции.
Ну и наконец, primary может назначать транзакции в разном порядке для разных реплик.
Или это можно сказать по-другому, что для какого-то порядкового номера S
primary может назначить разные транзакции разным репликам.
Можно придумывать еще некоторые случаи византийского поведения, но основные эти.
И наша задача сейчас придумать, а как же мы можем с таким поведением византийского primary справиться.
Хотя стойте, нужно подумать над другим вопросом.
А зачем мы вообще выбрали византийского primary?
Может быть наша беда в этом, может быть нам не нужно справляться со всеми этими действиями нечестного primary,
может быть нам просто нужно изменить протокол выбора этого primary.
Конечно же так не выйдет, потому что primary может начать вести себя по-византийски уже после того,
как он выбран primary. А до этого он может вести себя честно, вводя другие заблуждения.
То есть он злоумышленник, но он ведет себя честно, соблюдает протокол до тех пор,
пока он не станет primary, а после этого он уже начинает действовать вот так вот вредно.
Дублировать транзакции, выкидывать транзакции, назначить разные транзакции в один слот.
Так что мы от этого обязаны защититься на уровне протокола.
Давайте с каждой проблемой разберемся.
Начнем с дублирования транзакций. Вот как раз эту проблему на уровне протокола репликации, наверное, решать не стоит.
Мне кажется, что эту проблему нужно делегировать вот тому состоянию выше, которое мы реплицируем.
Вот если вы вспомните рафты, если вы писали в домашней работе в рафте exactly once,
то и думали про снапшоты, чтобы обрезать лог, то вы должны понимать,
что exactly once реализуется скорее на уровне автомата, а не на уровне самого рафта.
От рафта требуется семантика at least once, чтобы каждая команда была реплицирована по крайней мере один раз.
А вот exactly once или, может быть, at most once после некоторого TTL
вы должны гарантировать уже на уровне самого реплицируемого состояния, которое потом снапшотится.
Короче говоря, мы эту задачу обсудим, но обсудим в следующий раз и на уровне,
например, биткоина, на уровне криптовалюты, которую мы будем строить.
Вот там дублирование транзакций никак не помешает.
Так что сегодня это не проблема, если primary задублирует транзакцию.
Подозрительно, но не смертельно.
Но вот если primary выкинет транзакцию, то это уже печально, потому что мы теряем свойство liveness.
Для клиента выглядит так. Мы отправляем систему транзакцию и ожидаем, что eventually она упорядочится относительно других транзакций
и применится к нашему реплицированному состоянию.
Тут наш транзакцию может выкинуть.
Ну хорошо, давайте вернемся на эту картинку и подумаем, как справиться с таким поведением primary.
Что делать, если он выкидывает нашу транзакцию?
Видимо, мы не получаем ответа, то есть мы не получаем этого кворомного сертификата.
У нас истекает некоторый таймер.
Что после этого мы делаем? Мы, конечно, подозреваем primary.
И мы этим своим соображением, что primary, возможно, византийский,
но может быть он просто отказал, может быть он византийский, мы это пока не понимаем,
и мы этим делимся с остальными репликами.
Мы отправляем им транзакцию.
И что делает каждая реплика? Она просто сама теперь становится клиентом.
То есть смотрите, вот здесь клиент, не дождавшись ответа от системы,
говорит остальным репликам, что я отправлял транзакцию,
отправлял транзакцию, видимо, primary, да, я не проговорил это,
конечно же клиент общается с primary.
Так вот, клиент не получил от primary ответа,
пожаловался на этого primary другим узлам,
но сама по себе такая жалоба не должна приводить к тому, что узлы, скажем,
перевыберут новую primary, потому что эта жалоба, ну потому что клиент мог
просто оклеветать primary, он мог ничего ему не отправлять.
Так что что делает честный узел, который получил транзакцию от клиента в обход primary?
Он сам перепроверяет верно ли, что primary честный, он сам становится клиентом
и отправляет primary эту транзакцию.
Но я вот воспользуюсь этой стрелочкой, она имела другой смысл,
ну вот я, ладно, нарисую новую.
Реплика отправляет эту транзакцию на primary.
И теперь эта реплика знает, что если от primary транзакции не приходят
по истечении некоторого тайм-аута,
то primary, видимо, ее выкидывает, видимо, primary нарушает свой протокол.
И тогда уже, видимо, эта реплика захочет primary поменять.
Пока реплика не знает ничего про эту транзакцию, то она, конечно же,
может доверять текущему primary.
В конце концов, византийский primary может не отправлять транзакции
остальным репликам, но может отправлять какие-нибудь, скажем,
хардбиты о том, что он все еще жив.
И честная реплика, пока она не поговорила с клиентом напрямую,
она не различает две ситуации.
Когда у primary просто не было транзакции,
или когда клиент ее отправил, а primary ее проигнорировал.
Вот для того, чтобы эти два сценария отличить,
клиент сам отправляет транзакцию репликам,
реплики пересылают ее, заводят у себя таймер.
И если этот таймер истекает, а primary так и не прислал нам
сообщения при API.PR, то реплика справедливо считает,
что primary византийский и, наверное, его меняет.
Про смену эпохи мы поговорим чуть позже.
Вернемся пока на эту картинку и вспомним, что мы разбирали три проблемы.
Дублирование транзакций, выкидывание транзакций.
Вот с выкидыванием транзакций мы разобрались.
По модулю того, что мы пока не описали, как именно поменять эпоху,
как именно поменять primary.
Но если мы это умеем делать, то, значит, и с таким поведением тоже справимся.
И остается третья проблема, а именно, что primary по разному порядочевой транзакции
выбирает разных реплик или для некоторого порядкового номера S,
для некоторого слота primary выбирает разные транзакции для разных реплик.
Давайте я здесь поясню.
V – это view, в котором лежит primary.S – это слот, порядковый номер.
Итак, реплики ждут prepare, получают его, но, правда, они не понимают,
может быть, primary раздал разные транзакции этим самым репликам.
Доверять primary, вообще говоря, оснований нет.
Точнее, мы надеемся, что он честный, но на всякий случай мы должны проверить,
что он все же не обманывает нас.
Для этого мы заводим дополнительную фазу, где каждая реплика посылает другим репликам,
здесь происходит такая квадратичная коммуникация, все общаются со всеми,
каждая реплика посылает другим сообщение, которое мы назовем,
ну не мы назовем, в фибиофейне так называются, сообщение prepare.
Сообщение означает, что я и эта реплика получила от primary в эпохе V,
в слоте S, транзакцию с дайджестом D.
И, разумеется, я свое сообщение и эта реплика подписываю.
И теперь, если я какая-то реплика, вот здесь вот,
по истечении фазы prepare, собрала 2F плюс один одинаковый prepare,
то я и эта реплика, говорю, что я подготовила транзакцию с этим дайджестом в эпохе V,
в слоте S, predicate prepared.
По-человечески это значит вот что, если какая-то реплика собрала вот такое количество prepare,
то она уверена, что на большинстве честных реплик в эпохе V, в слоте S, лежит одна и та же транзакция.
Ну и дальше можно заметить, что поскольку мы собираем вот такое количество одинаковых preparов,
то в пределах одной эпохи не бывает двух разных подготовленных транзакций.
Почему? Потому что если две реплики подготовили разные транзакции, то каждая из них собрала вот такой кворум.
Вот это prepare для транзакции Tx, это Tx'.
И вот пересечение этих кворумов prepare есть, по крайней мере, здесь 2F плюс одно сообщение, prepare здесь 2F плюс одно.
В пересечении этих кворумов, по крайней мере, F плюс одно сообщение, пересечение этих кворумов, по крайней мере, F плюс один реплик,
а значит, по крайней мере, одна честная.
Ну и эта реплика честная, получается, проголосовала, отправила разные prepare в одной и той же эпохе за разные транзакции,
чего и делать запрещается. Так что не бывает двух разных подготовленных транзакций для одного и того же слота в одной и той же эпохе.
Ну и теперь возникает естественный вопрос. Вот мы какая-то реплика, мы получили транзакцию от primary,
положили ее в какой-то слот лога и после этого убедились, что эта транзакция лежит на большинстве частных узлов.
Другой такой транзакции не будет. Можем ли мы считать, что эта транзакция закомичена?
Можем ли мы зафиксировать ее в некотором порядке, зафиксировать ее с порядковым номером S и дальше применять к автомату, если переднее тоже зафиксировалось?
Вот этот вопрос сложный, и мы сейчас его разберем. Я вернусь немного в прошлое, вставлю маленькое замечание, что вот эту картинку мы рисуем в разрезе
некоторого фиксированного слота S. Вот вся эта картинка. Для разных слотов эта картинка будет дублироваться.
Пока у нас есть в этой картинке две фазы. Первая prepar, для упорядочивания, вторая prepar, для того, чтобы реплика поняла,
что на большинстве частных реплик лежит та же самая транзакция. Ну и вот реплика это поняла, она набрала вот такой набор сообщений.
И нас интересует вопрос, можно ли считать такую транзакцию закомиченной?
Вот если мы вспомним понятие комита в рафте, то для него мы доказывали, что из определения комита следует, что транзакция переживет смену эпохи.
Что эта команда, которая удовлетворяет определению комита, непременно будет находиться в логах лидеров всех последующих эпох.
Здесь нам нужно сделать то же самое. Показать, что если команда закомичена, то она переживает смену эпохи,
а для этого нужно описать процедуру смены эпохи, смены праймари, потому что пока мы этого с вами не сделали.
Ну вот давайте пока остановимся здесь, остановимся на реплике, которая собрала вот такое множество сообщений, такой сертификат.
Позже мы назовем его сертификатом. Она знает, что на большинстве частных лежит эта же транзакция.
А теперь случается смена эпохи. Немножко освободим место.
Поговорим про смену эпохи, которая называется, напомню, view change.
Смена эпохи означает, ну смена эпохи это смена праймари. Нужно выбрать нового праймари.
Почему? Потому что, видимо, старый праймари ведет себя подозрительно.
Ну вот какая-то реплика получила транзакцию от клиента, сказала, что праймари почему-то не комитит эту транзакцию.
Мы на месте клиента не получаем кворн сертификат с ответом.
Реплика говорит, ну хорошо, давайте проверим.
Посылает транзакцию, преодолесует транзакцию праймари, ждет у него при ЭППР, заводит таймер, таймер протухает.
И, видимо, мы подозреваем в чем-то праймари. Видимо, теперь праймари становится подозрительным.
Нужно выбрать нового.
Как это сделать? Как должна быть устроена процедура выбора этого нового праймари?
В RAFT для того, чтобы обеспечить лайв нас, а нам в конце концов праймари нужен для того, чтобы обеспечить лайв нас, как всегда, выбор лидера.
В RAFT для этого достаточно было выбрать любого лидера. Все узлы были честными.
В раме достаточно было, чтобы кто-то из них стал лидером и назначал команды и реплицировал их на логи фолливеров.
Здесь у нас требования более сложные, потому что мы хотим не просто выбрать какого-то лидера,
ну, например, потому что этот праймари просто отказал,
а мы хотим, чтобы эвентуал был выбран честный лидер, честный праймари, который гарантированно закомитит транзакции пользователей.
Но как же отличить честный узел от нечестного?
Потому что мы сказали, что мы же не можем гарантированно выбрать честного праймари,
потому что византийский узел может вести себя нечестным, до тех пор, пока он не будет выбран праймари.
Но можно было бы сказать следующее, что мы выбираем праймари каким-то образом,
и если он себя скомпрометирует, например, в таком протоколе,
то мы запишем, что он, видимо, подозрительный византийский, и после этого его будем на следующих выборах игнорировать.
Вот так делать опасно, потому что в конце концов в этом протоколе мы не то чтобы понимаем, что праймари византийский,
мы скорее понимаем, что праймари чего-то долго не делает.
И может быть он действительно злоумышленник, и он действительно игнорирует намеренно команды конкретного пользователя, транзакции конкретного пользователя.
А может быть он честный, ну просто я не знаю, он залип в какой-то паузе, он затормозил почему-то.
Может быть он работал на какой-то виртуалке, которую засаспендили и переносили на другую машину.
В общем, можно себе разные сценарии представить, и мы не то чтобы понимаем, что праймари византийский,
мы скорее понимаем, что праймари подозрительный.
Но если мы ошиблись, если все-таки он был честным, просто он залип,
то если мы его исключим из последующих выборов, то мы, значит, рано или поздно можем так потерять все честные узлы.
Так что мы должны каждому давать второй шанс.
И при этом гарантировать каким-то образом, что eventually некоторые честные узел станет праймари.
Для этого нам нужна новая идея. Ну как новая?
Она в Объяснительном репликейшене была с самого основания с 1988 года.
Но для нас она будет новая, и она будет нам полезна именно в контексте византийских систем.
Мы будем использовать такую идею. Мы не будем лидера выбирать, мы будем лидера праймари назначать.
Давайте я, чтобы опять поместиться, немного перенесу картинку.
У нас будет идея rotating primary,
где primary в эпохе v назначается узел v по модулю n,
где n это общее число узлов.
То есть мы перебираем праймари просто по кругу.
Если один нам не нравится, мы берем следующий.
Он нам тоже кажется подозрительным, мы продолжаем выбираем следующего и вот так вот просто двигаемся по кругу.
Отлично. Если мы в такой схеме умеем подозревать праймари в византийском поведении,
то мы просто меняем эпоху, передаем право быть праймари следующему узлу,
и так рано или поздно мы дойдем до некоторого честного узла.
Мы здесь при этом никого не исключаем, у каждого есть второй, третий и так далее шанс.
Хорошо. Допустим, вот какой-то узел в чем-то подозревает праймари.
Допустим, он даже честный.
Вот достаточно ли этого, чтобы сменилась эпоха и сменился лидер?
В RAF-те, если кто-то какой-то узел не получал heartbeat и append entries от лидера в течение реакшн тайм-аута рандомизированного,
то он становился кандидатом и призвал всех перейти в новую эпоху.
То есть достаточно было одного такого участника.
Здесь у нас система византийская, поэтому снова мы не можем доверять конкретному участнику, мы не можем доверять конкретному узлу.
Желания одного узла перевести систему в новую эпоху недостаточно,
потому что этот желающий узел может быть византийским, и он просто хочет сбросить строна от текущего честного праймари.
Поэтому, чтобы праймари поменять, нам нужно получить голоса нескольких узлов.
Собрать голоса нескольких узлов.
Итак, у нас есть снова четыре узла.
У нас есть праймари в эпохе view 5 и есть узел, который станет следующим праймари в эпохе 6.
Вот пока праймари вот этот.
Если он каким-то образом себя скомпрометировал, то участники уведомляют об этом узел, который должен стать праймари следующим.
Они отправляют ему сообщение в view change.
В том числе сам P6, он может проголосовать за то, чтобы сменить праймари из прошлой эпохи.
view change, эпохи В.
Нам нужно получить какое-то количество голосов.
Но вопрос, сколько голосов достаточно, чтобы P6 честный?
Чтобы вот этот узел, третья реплика, стала праймари в шестой эпохе.
Какого количества сообщений в view change достаточно, чтобы P6 действительно посчитало, что нужно поменять эпоху?
Потому что, может быть, P6 честная, а P5 тоже честный.
Просто византийские узлы хотят эпоху продвинуть вперед и мешать вот этому честному праймари.
Казалось бы, достаточно получить на месте вот этого узла F plus 1 view change.
Потому что среди этих F plus 1 view change будет, по крайней мере, одна честная реплика, которая пожелала сменить праймари.
И вроде бы этого достаточно. Если хотя бы одна честная реплика подозревает праймари, значит у нее есть основание, значит мы должны сменить эпоху.
Но, тем не менее, в протоколе view change, в PBFT мы дожидаемся 2 F плюс 1 сообщение view change.
Ну, разумеется, эти сообщения подписаны, потому что иначе как мы собираемся эти кормы.
То есть мы почему-то требуем больше view change, и пока, наверное, мы не понимаем зачем, но в будущем это прояснится.
Хорошо. Ну, а дальше, если узел получил много view change, который переводит систему в следующую эпоху, в которой он должен быть праймари,
то этот узел отправляет всем репликам сообщение new view. Можно переходить в новую эпоху.
В таком протоколе пока очень много каких-то непонятных, странных мест. Тут очень большой простор для византийских узлов повлияет на все это.
Ну вот смотрите, даже в византийских, что делать, если нам в текущей праймари не нравится, мы проголосовали за следующего праймари,
а он почему-то на new view не посылает. Ну почему? Потому что просто этот узел отказал. У нас в конфигурации заложена возможность F отказов.
Этот F включает в себя и злоумышленников, и просто взорвавшиеся узлы. Так вот, что если этот третий узел взорвался и никогда на new view не отправит?
А он в следующей очереди. В этом случае, когда мы отправляем view change, мы заводим еще и таймер.
И если он истекает, мы переходим вот еще в следующую эпоху, в следующую промежуточную эпоху.
Но тут есть некоторые тонкости, а именно, что таймеру нужно экспоненциально увеличивать, чтобы потом реплики, которые пытаются пережить отказавших праймари, синхронизировались по эпохам.
В общем, в этом месте лучше к статье обратиться, потому что мы сейчас запутаемся, если будем в это погружаться сильно. Это нас скорее отвлечет сейчас.
В общем, эта проблема решается. Но есть другая проблема, которая нас больше, наверное, сейчас интересует.
А именно, это случай, когда следующий праймари византийский.
Или даже так. Что мешает в таком наивном протоколе третьему узлу, который должен стать праймари в эпохе 6,
что ему мешает просто, не получая вьючейнжа, отправить сообщение new view остальным репликам и перевести всех в новую эпоху.
То есть ему текущий праймари честно не нравится, он нечестно и хочет управлять всем сам.
Как обычно, мы возвращаемся к идее, которая была найдена нами еще в клиентском протоколе.
А именно, мы никогда не доверяем ответу конкретного узла. Мы всегда доверяем сертификату.
Если узел стал праймари и хочет перевести все реплики за собой в новую эпоху,
он должен доказать, что достаточно много реплик проголосовали за смену эпохи.
Для этого он может приложить вот этот вот кворомный сертификат, обозначив его V, к своему сообщению вьючейнж.
И тогда, если мы реплика получаем сообщение new view, то мы проверяем этот сертификат, проверяем подпись.
И действительно, мы теперь уверены, что эпоха сменилась, потому что набрался квором из большинства честных.
Хорошо. Следующая проблема, которая в этом протоколе пока неясна, не разрешилась.
А именно, что если у третьего узла, который станет праймари в эпохе 6, просто-напросто не полный лог?
В RAFT мы выбирали лидера всегда с полным логом. Мы там аккуратно тюнили правила голосования.
Мы голосовали за кандидата на месте фолловера, только если у кандидата старшая эпоха в логе больше,
либо равна нашей, но сам лог содержит больше записей. Здесь праймари назначается детерминированно,
и мы просто не уверены, что у него будут все данные. Поэтому, когда мы отправляем вьючейнж,
да, вот здесь я не написал, конечно, вьючейнж тоже подписывается, чтобы потом эти подписи можно было проверять здесь.
Мы в этом вьючейнже отправляем еще и лог. То есть на месте реплики, которая голосует о смене эпохи,
мы прикладываем к этому сообщению вьючейнж еще и свои собственные транзакции, которые у нас уже в логе есть.
Но все же этого мало. Понятно, что да, праймари, если он честно и получает эти логи, он их...
Давайте так. По задумке праймари должен получить эти логи, каким-то образом скомбинировать их в лог для светлого будущего
и отправить этот лог для светлого будущего вместе с new view.
Ну, тут могут быть разные варианты. А что, если новый праймари, скажем, византийский, и он просто отправил всем пустой лог?
Ну, у него это сделать не получится, потому что вместе с этим логом он отправляет сертификат для смены эпохи, сертификат В,
и каждый реплик, который его получает, может проверить действительно, что праймари пересобрал новый лог правильно.
В PBFT все-таки немного не так все работает. Я сейчас не совсем корректно все это рассказываю, но...
Пока нас дополнительные детали здесь запутают.
Хорошо. Значит, если праймари византийский, то, скорее всего, его можно будет перепроверить.
Но вот как поступать честному праймари, который получает view change как и от честных узлов, так и от византийских?
Дело в том, что честные узлы, видимо, отправляют какие-то похожие логи, а вот византийские узлы могут эти логи
просто придумывать, менять транзакции. Как мы гарантируем, что транзакции, которые мы считаем закоммиченными,
а я напомню, что закоммиченной мы хотели бы считать транзакцию, которая лежит на большинстве честных логов,
как гарантировать, что такая транзакция переживет смену эпохи? Почему, собственно, если у нас есть
праймари следующий, и вот он собрал вот такой вот quorum view change,
почему непременно он узнает про закоммиченную транзакцию?
Ну вот тут можно и заметить, зачем мы использовали, зачем мы дожидались именно 2f плюс 1 view change.
Именно для того, чтобы пересечься, вот в этом quorum есть большинство честных узлов,
ну и, видимо, большинство честных узлов есть в quorum для подготовленной транзакции.
Так что посмотрим, как эти quorums пересекаются. Здесь quorum узлов, которые отправили в view change для смены эпохи,
здесь quorum узлов, которые отправили в prepare для какого-то view change v,
и здесь prepare v, s, d. В каждом из этих quorum'ов 2f плюс 1 узел.
Смотрим на пересечение опять. Тут по крайней мере f плюс 1 узел, то есть, по крайней мере,
давайте нарисуем его, по крайней мере, один честный.
Опять те же самые рассуждения, та же самая dissemination система quorum'ов.
И, казалось бы, если транзакция подготовлена какой-то репликой, если транзакция подготовлена,
и эта реплика знает об этом, если эта реплика подготовила транзакцию d в слоте s в эпохе v,
то известно, что глобально на большинстве честных узлов лежит транзакция,
а значит, в пересечении этих quorum'ов будет честный узел, который, с одной стороны,
эту транзакцию у себя имеет, а с другой стороны, он проголосовал за смену эпохи
и отправил новому primary свой лог. Так что новый primary мог бы из лога вот этой реплики
забрать эту транзакцию, и тогда она переживет смену эпохи.
Напомню, что мы об этом и волновались. Мы говорили, можно ли считать вот этот preparat
свой предикат preparat сигналом к комиту.
Ну, пока рассуждения разумные, правда, не совсем понятно, вот что.
Ну да, мы теперь на месте p6 уверены, что хотя бы один viewchange
хотя бы от одного узла содержит препарат транзакцию.
Но не очень понятно, как на месте нового primary из всего этого quorum'а,
из всех ответов выбрать именно ответ этого узла.
Потому что он же получает и другие ответы. Ответы от византийских узлов, ответы от узлов,
которые не попали в этот quorum.
Было бы здорово, если бы вот эта честная реплика, которая попала в пересечение этих quorum'ов,
смогла бы каким-то образом primary честному доказать, что именно ее транзакцию
из слота S нужно взять. Как же это сделать?
Как же этой честной реплике доказать, что именно ее нужно слушать?
Ну вот мы это делали уже несколько раз. Если мы один узел хотели кого-то в чем-то убедить,
скажем, мы primary отвечали клиенту, или мы новый primary отправляли всем сообщения
о смене эпохи, мы всегда к нему прикладывали quorum'ный сертификат.
То есть набор сообщений, подписанных большинством честных узлов,
и этот сертификат удостоверял ответ, удостоверял право смены эпохи.
И вот мы на месте этого честного узла, было бы здорово, если бы мы этот честный узел
смогли предоставить вот такой аналогичный quorum'ный сертификат для подготовленной транзакции.
То есть мы бы хотели новому primary передать вот такой вот, назовем его, prepare сертификат.
Если бы у нас у зеленой реплики он был, то, разумеется, новый primary, третий узел,
непременно бы эту реплику послушал, потому что ему бы нечего было выбирать,
потому что мы сказали, что в пределах одной эпохи для одного слота не бывает
двух разных подготовленных транзакций, не бывает двух транзакций с сертификатами.
Просто primary вот здесь, получив эти view changes, выбрал бы ту транзакцию,
у которой есть prepare сертификат. А теперь возвращаемся к исходному вопросу.
Почему? Потому что эта реплика с помощью этого сертификата умеет доказать,
что вот какое-то большинство честных реплик проголосовали за эту транзакцию.
Ну, картинка не самая аккуратная, но в принципе должна быть понять.
Так вот, теперь можно вернуться к исходному вопросу и разобраться,
можно ли считать подготовленную транзакцию закомеченной?
Может ли узел IT, который собрал prepare сертификат для транзакции,
считать, что эта транзакция переживет смену эпохи?
Транзакция переживет смену эпохи, если в пересечение кворумов,
репликации и view change попадет реплика, у которой будет prepare сертификат.
Давайте мы здесь его нарисуем.
Но пока вот это условие означает лишь, что эта реплика знает, что у нее есть prepare сертификат.
И если она попадет в пересечение кворумов, то она, конечно,
новому праймари про транзакцию сообщит и сертификат предоставит.
Но вообще-то в пересечение кворумов можно попасть в любая из реплик.
Так вот, мы транзакцию назовем закомеченной,
когда она подготовлена на 2F плюс 1 реплик.
Когда она подготовлена на большинстве честных реплик.
Вот такое определение не совсем корректно, если аккуратно подумать.
Но вот команда закомечена, когда большинство честных реплик подготовили ее,
то есть сформировали prepare сертификат.
И тогда кто бы из этого большинства не попал в пересечение кворумов с view change,
чтобы этот кто-то, эта честная реплика сможет предоставить prepare сертификат
и новой праймари им непременно воспользуется.
Но вот такое определение коммита, оно глобальное.
То есть на большинстве честных транзакция подготовлена.
Но пока у нас эта реплика этого не понимает.
Она знает, что на большинстве честных транзакция просто находится в логе.
Но она не уверена, что большинство честных набрали prepare сертификат
и могут с помощью него доказать факт подготовленности на большинстве лидеров следующей эпохи.
Поэтому мы в наш протокол добавляем еще одну фазу.
Вот можно вспомнить здесь даже single degree of access, в котором есть определение коммита,
определение chosen proposal.
Значение выбрано, если нашелся proposal nv, за который проголосовала большинство аксепторов.
Опять, это определение, это глобальное свойство для набора узлов, для набора аксепторов.
Но при этом каждый аксептор не наблюдает выполнение этого условия,
каждый аксептор всего лишь голосует локально.
И нужно, чтобы какой-то пропозер набрал этот quorum
и сказал остальным аксепторам, что значение выбрано.
Сами аксепторы этого не понимают.
Вот здесь та же самая история.
Эта реплика знает, что на большинстве честных лежит одна и та же транзакция,
но она не уверена, что другие честные тоже знают об этом.
Поэтому для того, чтобы конкретно реплике понять, что транзакция закоммичена,
она еще раз отправляет всем сообщение,
ну и все реплики снова отправляют всем сообщение,
семантика которого такая.
Я и та реплика подготовила транзакцию, я собрала препарат-сертификат,
и я говорю это вам.
Сообщение commit vsd.
И вот если реплика здесь набрала 2f плюс 1 одинаковый commit,
то вот тогда уже она может заключить, что действительно транзакция закоммичена,
что выполняется такое глобальное свойство, что транзакция подготовлена
на большинстве честных узлов.
После этого можно транзакцию применить к своему состоянию,
ну и в конце концов отправить ответ primary.
И primary, собрав эти ответы в сертификат, отправит его клиент.
Давайте здесь тоже сертификат нарисуем.
На самом деле и это еще не все,
потому что если внимательно подумать над протоколом,
промоделировать различные исполнения,
то окажется, что я, строго говоря, ничего пока не доказал.
Я скорее сформулировал некоторую интуицию и не рассказал вот про что.
Вот как будто бы новый primary, когда он собирает view changer,
если ему присылают лог и в этом логе есть транзакция,
а у него есть сертификат, то казалось бы primary избавлен от выбора.
Он знает, что не будет другой транзакции с сертификатом.
Просто потому что пересекают скворы,
в пересечении есть один честный узел, ноги и так далее.
На самом деле все хитрее, потому что оказывается,
что при смене эпохи узел, который должен стать в следующем primary,
может получить разные логи с разными транзакциями,
и эти транзакции будут сертифицированы.
Но, разумеется, они не могут быть сертифицированы в одной эпохе,
поэтому они будут сертифицированы в разных view.
И тогда новый primary должен выбрать при смене эпохи сертификат с наибольшим номером.
И вот это уже будет настоящий PBFT.
Ну и строг говоря, тут нужно все это доказывать,
но примерно рассуждение там похоже на то, что было раньше.
Честно говоря, не хочется все это сейчас повторять.
Если вам интересно, можно обратиться к статье,
но вот я сам протокол и всю интуицию, кажется, здесь для него изложил.
Что этому протоколу не хватает?
Не хватает, наверное, разговора про смену эпохи,
потому что вот эта процедура, она вроде бы описана,
мы вроде бы поговорили, каким образом эта процедура противостоит сбоям старого primary,
нового primary, отдельных реплик.
Но все же она остается очень громоздкой,
потому что, ну, в самом деле, представьте, вы здесь отправляете целый лог,
и к каждой записи этого лога вы прикладываете сертификат, в котором много сообщений.
Ну вот, да, я забыл об этом сказать.
Мы говорим именно про сообщения, а не RPC,
потому что мы постоянно эти кормные сертификаты перепосылаем.
Ну, в смысле, набираем и посылаем другим.
Нам нужно иметь именно вот такие подписанные сообщения.
Ну вот, здесь очень много сообщений, мы отправляем их потом еще раздаем,
и лог у нас растет, копится, копится, копится,
и вот мы повторяем всю эту процедуру при каждой смене эпохи.
Хотелось бы как-то иметь здесь лог какой-то ограниченной длины.
Ну и мы такую задачу уже решали с вами.
Мы хотим сейчас научиться делать snapshot.
То есть мы хотим просто префикс лога, закомиченный, обрезать
и представлять его как-то более компактно.
То есть мы хотим поддерживать, вместо префикса лога,
схлопнуть его в какое-то итоговое состояние,
которое получается применением всех транзакций этого,
всех закомиченных транзакций этого префикса.
Мы когда говорили про RAFT, в лекции по Access Made Life,
мы говорили про то, как делать снапшоты.
Мы говорили об этом на семинаре про crash consistency.
Но вот прям такая процедура нам не подойдет,
потому что когда мы там делали снапшоты,
и каждая реплика делала их независимо для своих собственных индексов,
в этом протоколе так сделать не получится.
Вот представим, что мы научимся делать снапшоты,
и когда мы будем менять эпоху, мы вместо полного длинного лога
будем отправлять s-snapshot
для некоторого префикса и вот некоторый суффикс.
И непонятно, почему мы на месте праймари нового
должны доверять вот полученному снапшоту здесь.
Почему мы доверяли логу, мы поговорили,
потому что с транзакцией в этом логе был связан сертификат.
А почему мы доверяем вот этому снапшоту, непонятно.
Опять, мы не можем доверять на месте праймари одному узлу.
Нам нужно, чтобы к этому снапшоту было приложено
некоторое криптографическое доказательство того,
что вот этот снапшот разделяется между разными репликами.
Поэтому правило построения снапшотов будет чуть сложнее
относительно того же RAF.
Во-первых, мы будем делать снапшоты синхронно.
Но синхронно, разумеется, не во времени, а синхронно по индексам.
Ну вот скажем, каждую сотую позицию в логе.
Мы здесь построили снапшот.
А теперь нужно каким-то образом научиться доказывать новому праймари,
что этот снапшот действительно похож на снапшот других узлов.
Поэтому мы снова отправляем этот снапшот...
Ладно, мы отправляем не целый снапшот, это было бы тяжело.
Мы отправляем другим узлам, другим репликам сообщение снапшот,
который сделан в кат и позиции.
И этот снапшот имеет hashD.
И, разумеется, свое сообщение подписываем.
И так делает каждая реплика.
И теперь, если какая-то ИТ реплика построила снапшот
и получила еще 2F голосов, 2F подтверждений того,
что на других репликах есть снапшот с таким же hash,
то она может к своему снапшоту прикрепить снова quorum-сертификат.
И этот quorum-сертификат приложить к своему снапшоту в viewChange.
То есть метод, в принципе, такой же.
Таким образом мы сможем все же не повторять сложную процедуру
после каждой смены эпохи, потому что закомиченный префикс
будет компактиться и заменяться с помощью такой процедуры
на более компактные представления.
Ну и последняя идея, которая, последняя техника на сегодня,
касается аутентификации.
В этом протоколе мы использовали для аутентификации цифровые подписи.
Использовали их очень часто.
Вот мы каждое сообщение подписывали.
Но цифровые подписи это не единственный механизм аутентификации.
Вот скажем, если мы говорим про безопасные соединения,
если мы браузер и мы общаемся с сервером,
то в пределах этого соединения мы не то чтобы каждое сообщение,
каждый пакетик подписываем с помощью асимметричной криптографии.
Мы не то чтобы постоянно используем все эти операции над рептическими кривыми,
это было бы очень неэффективно.
Когда мы открываем сессию защищенную, то вместо этого мы делаем следующее.
Давайте я смотрю цифровые подписи
и поговорю про альтернативный способ аутентификации,
который называется коды аутентификации сообщений.
Итак, мы браузер и сервер.
Вот между нами есть сессия.
И мы с помощью цифровых подписей, мы узнали сертификат, мы можем его провалидировать.
Мы с помощью механизма цифровых подписей и с помощью протокола Диффи Хелмана
договариваемся о некотором разделяемом секрете между двумя этими узлами.
Мы договариваемся о сессионном ключе S.
Давайте я переименую сервер и B в Алису и Боба и буду про них уже говорить.
У нас есть Алиса, у нас есть Боб.
Они договариваются между собой о разделяемом секрете AB с сессионным ключем.
И если Алиса отправляет сообщение Бобу,
то она к этому сообщению прикладывает хэш криптографический
от конкатинации сообщения плюс этого самого секрета.
И вот этот хэш мы назовем аутентификатором.
Не подписью уже, другое название аутентификатор.
Альфа AB от M.
И теперь Боб, получая сообщение и получает аутентификатор,
действительно может удостовериться, что сообщение отправило именно Алиса.
Он конкатинирует полученное сообщение с секретом, который узнает только они вдвоем,
считает хэш, что гораздо проще, чем проверка подписи.
И сравнивается с аутентификатором, который получил сообщение.
Вопрос, в котором задаются авторы.
А можем ли мы заменить в нашем протоколе,
где постоянно используются цифровые подписи, механизм аутентификации
с цифровых подписей на эти самые маки?
Потому что получится эффективнее, потому что они гораздо быстрее.
И они тоже решают задачу аутентификации.
Но все же так сделать нельзя.
Потому что способы разные, и этот способ эффективнее,
но он в некотором смысле слабее.
Он не имеет очень важного свойства, которые нам предоставляют цифровые подписи.
И это свойство называется non-repudiation.
Невозможность отказаться от собственных слов.
Ну вот представьте себе ситуацию.
У нас есть Алиса, у нас есть Боб и у нас есть некоторый Виктор.
И Алиса отправляет Бобу сообщение, допустим, подписанное Алисой.
Алиса отправит сообщение, подписанное Алисой. Это разумно.
И Боб посылает... Что может сделать Боб?
Боб всегда может доказать Виктору, что он получил это сообщение от Алисы.
Он может отправить это сообщение Виктору с цифровой подписью,
и Виктор может проверить эту подпись.
Коль скоро у них есть удостоверяющий центр, есть сертификаты,
можно узнать открытый ключ узла А Алисы.
Можно ли на месте Боба доказать, что Боб получил сообщение от Алисы,
если Алиса вместо цифровой подписи приложила к сообщению mAuthenticator?
Это проблема, потому что Боб... Но что он может сделать?
Он может проверить этот аутентификатор, то есть он может убедиться,
что сообщение отправило именно Алиса.
Но если он отправит этот аутентификатор Виктору,
то Виктор уже этим аутентификатором воспользоваться не сможет,
потому что он не знает сессионного ключа между A и B,
к которому этот аутентификатор был привязан.
Ну ладно, не беда. Может быть, Алиса сможет написать два аутентификатора?
AB и AV. Один из них предназначается Бобу, а другой предназначается Виктору,
которому сообщение будет пересылаться.
И тогда Боб проверяет этот аутентификатор, а Виктор проверяет этот аутентификатор.
Почему нам вообще это важно? Почему нам важно...
Почему нам важно на месте Виктора понимать, кто отправил сообщение?
Ну потому что мы постоянно пользуемся здесь кормными сертификатами.
Это наш такой основной рабочий инструмент сегодня.
Мы их использовали в протоколе клиента, мы их использовали в протоколе смены эпохи,
и мы их использовали для того, чтобы подтвердить, что транзакция реплицирована.
Мы всегда перепосылаем сообщение.
Вот во viewChange отправляем препэры, которые мы получили от других узлов.
То есть, например, здесь одна реплика посылает другое сообщение препэр,
а здесь эта реплика голосует за смену эпохи
и прикладывает в этот viewChange этот самый препэр.
То есть перепосылает это сообщение.
Ну а теперь почувствуем разницу между двумя вот этими механизмами.
Пусть у нас есть этот самый V, который в данном случае новый primary,
который набирает viewChange.
Он получает этот V от чужих сообщений,
и он хочет проверить их подпись или аутентификатор.
Вот, допустим, V получил сообщение через Боба от Алисы,
и он видит, что это сообщение было снабжено, допустим, цифровой подписью,
и Виктор видит, что цифровая подпись не сходится.
О чем это говорит? Какой вывод может сделать Виктор?
Может ли Боб быть византийским?
Конечно, может, потому что он прислал сообщение с неправильной цифровой подписью.
А может ли Боб быть честным, а Алиса быть византийской?
Ну, это было бы странно, это странная конфигурация,
потому что если Алиса была византийской и отправила сообщение с неправильной цифровой подписью,
а Боб был честный, то Боб был бы в первую очередь обязан проверить это сообщение,
проверить эту подпись. Зачем же он нам посылает ее тогда?
То есть здесь не бывает такого, что Алиса нечестная и сломала подпись,
отправила неправильную подпись, а Боб честный,
потому что он бы проверил это раньше и нам бы сообщение посылать не стал.
А что если мы пользуемся вместо одной подписи такой вот парой аутентификаторов?
Что видит Виктор? Виктор видит, что, допустим, вот этот компонент аутентификатора,
αав, скомпрометирован, то есть он просто испорчен.
Мы считаем хэш от сообщения с нашим секретом, от а до в,
и видим, что не сходится этот аутентификатор с этим хэшом.
Что мы можем думать про а и б?
Может ли а быть, может ли б быть нечестным?
Ну, разумеется, Алиса была честная, отправила аав, аав не были обыкорректны,
а Боб аав сломал.
А может ли а быть нечестным, а б быть честным?
Тоже может, потому что Алиса отправила Бобу корректный аав, и Боб его проверил.
Но отправила ему сломанный ав, но Боб этого проверить не может,
потому что он не знает сессионного ключа между а и в.
Так что он просто проверяет свою компоненту и перепосылает весь аутентификатор Виктору.
В итоге Виктор плохо понимает, что случилось.
Валидин ли...
Он не различает два случая, а почему для нас PBFT это важно?
Вот представим, что мы primary, и мы получили quorum-сертификат здесь.
То есть нам какая-то реплика говорит, что в слоте S
транзакция T подготовлена, и вот набор сообщений, которые это доказывают.
И если транзакция закоммичена, то вообще говоря,
в пересечение с view-change может попасться только один честный узел,
который сможет этот сертификат предоставить.
А теперь представим, что мы на месте византийского узла что можем сделать?
Мы можем сертификат вот этого узла, который попадет в пересечение,
взять и отравить с помощью неправильного аутентификатора у prepare.
То есть мы вот какая-то реплика...
Мы допустим вот эта реплика, отправили первые реплики prepare
и подписали, добавили к этому prepare
корректный аутентификатор для вот такой пары
и некорректный аутентификатор для пары четвертая реплика, третья реплика.
И в итоге первая реплика собрала quorum-сертификат,
она надеется с помощью него доказать новому primary,
что транзакция должна попасть в следующую эпоху.
Но так получилось, что в этом quorum-сертификате одно сообщение отравлено,
потому что отравлен аутентификатор, который адресуется третьему узлу, следующему primary.
И реплика, которая собирает здесь вот этот quorum-сертификат,
она не может это проверить, потому что для нее этот prepare правильный,
для нее компоненты аутентификатора правильные.
Итак, подводим итог.
У нас один византийский узел может серьезно испортить весь протокол,
если мы используем коды аутентификации сообщений вместо цифровых подписей.
Казалось бы, у нас одна цифровая подпись заменяет целым векторам аутентификаторов
для каждого потенциального адресата.
Но утверждается авторами, что даже так получится эффективнее.
Но правда, из коробки просто взять и поменять не работает.
Но в PhD одного из авторов есть целая глава про то,
как можно PBFT переложить на аутентификаторы все-таки вместо цифровых подписей,
немного усложнив процедуру смены эпохи, но тем не менее это можно сделать.
Мой пояс сейчас скорее в том, что цифровые подписи – это не единственный механизм аутентификации.
Есть коды аутентификации сообщений, но они по своим возможностям не эквивалентные.
Коды аутентификации сообщений эффективнее, но они теряют свойство non-repudiation,
то есть нам сложно перепосылать сообщения, которые мы получили от других узлов.
Так что принципиально важно, что весь этот протокол изложен именно в терминах цифровых подписей.
Ну что ж, нужно подвести итог.
Мы с вами построили протокол, который пока не слишком эффективный.
Тут много таких фаз происходит, тут довольно громоздкая процедура выбора лидера.
Но все же мы добились оптимального числа реплик, ну и построили протокол,
который в принципе похож на то, что было раньше, на multipax, на wrap.
Есть все-таки в нем довольно много сходств,
а есть зато и много отличий, которые позволяют нам решать задачу именно византийской модели.
Ну и давайте как-то соберем вместе все техники, которые мы здесь использовали.
Во-первых, мы унаследовали техники, которые были придуманы еще в прошлый раз.
Мы используем цифровые подписи повсеместно и существенно пользуемся свойством non-repudiation.
И мы используем византийские кворумы, которые пересекаются,
по крайней мере, по f плюс 1 узлу или по 1 честному узлу.
А из новых техник у нас есть две очень мощные идеи.
Во-первых, как мы обеспечивали лайвнес?
Мы обеспечивали лайвнес с помощью протейтинг праймари.
Мы не пытались выбрать честного праймари, это невозможно, кажется.
Мы научились подозревать подозрительных праймари
и менять эпохи так, чтобы просто в эпохах ротировались лидеры.
И таким образом мы гарантировали, что рано или поздно,
не зная какие узлы честные и какие нечестные, не умея их отличать друг от друга,
мы гарантировали, что eventually право упорядочивать транзакции,
перейдет формировать лог предыдущей транзакции, перейдет к некоторому честному узлу.
Вот эту идею мы дальше будем развивать.
Мы увидим, как эта идея совершенно альтернативным образом
представлена в протоколе репликации в блокчейне биткоина.
И через еще одну лекцию мы увидим, как эту идею можно,
вдохновляясь в биткоин, оптимизировать, сделать еще эффективнее.
То есть сократить накладные расходы на вот эту громоздкую процедуру смены эпохи.
И вторая техника, которой мы сегодня пользовались,
которой раньше не было, это кворумные сертификаты.
Вот кворумные сертификаты мы использовали в протоколе клиента,
и мы использовали вот с такими системами кворумов.
В пересечении был по крайней мере один узел,
и вот здесь через это пересечение с помощью кворумного сертификата
мы могли убедить нового праймари, что большинство честных узлов согласны с нами.
Опять же, эту идею мы еще воспользуемся через два занятия,
когда мы будем говорить про протокол репликации уже правда блокчейна Hot Stuff.
И еще одна занятная вещь, на которую я хотел бы обратить на последок внимание,
это то, как устроен вот этот протокол именно репликации в разрезе одного слота.
Тут происходят некоторые забавные вещи в смысле знания отдельных узлов.
Когда мы после первой фазы проходим через вторую,
то у нас накапливается знание, что на большинстве честных лежит некоторая транзакция.
Мы собираем такой вот кворумный сертификат, вот этот вот.
Мы честный узел знаем, что на большинстве честных одна и та же транзакция.
После следующей фазы commit наше знание усложняется.
Теперь мы знаем, что большинство честных знает, что на большинстве честных лежит одна и та же транзакция.
И теперь большинство честных узлов, некоторое большинство честных узлов,
этот факт, знания того, что транзакция лежит на большинстве честных,
могут доказать потому, что у них есть кворумный сертификат.
То есть вот здесь мы собираем кворумный сертификат,
а здесь мы собираем можно сказать кворумный сертификат кворумного сертификата.
Не то чтобы прямо сейчас я этим наблюдением собираюсь воспользоваться, но через неделю я продемонстрирую некоторую аналогию, как именно похожее накопление знаний, голосов возникает в Биткоине,
а еще позже, когда мы будем говорить про Hot Stuff, я покажу, как можно идеи Биткоина и идеи PBFT совместить в более эффективный протокол, который будет эффективно пайплайнить вот сборку этих кворумов, кворумов, кворумов и так далее.
Ну что ж, тогда на сегодня все. Спасибо.
