9 задача для этого вообще вспомним машины тюринга
что это такое машина тюринга это один из способов формализовать понятие
вычисления мы определяли его следующим образом входной алфавит сигма гамма
ленточный алфавит дальше у нас было множество состояний букв кс от слова
states с нулевое стартовое состояние мы говорили есть с accepted есть с rejected
допускающие и отвергающие состояние есть функции дельта функции переходов и
вроде бы все у нас будет ограничение следующее что гамма принадлежит к гамма без специально
выделенного символа что с нулевое с а и с rejected это все некоторое состояние множество гамма меньше
оно конечно аналогично множество с
каких-то группу даже были кардиналы в этом году помним поэтому сохраним значки функцию дельту мы
определяли следующим образом что сейчас давайте я взгляну что было раньше потому что сейчас я
порядок изменил 100 процентов с гамма все я понял хорошо функция переходов она брала в себя
некоторые состояния брала в себя некоторые символ и говорила что вот мы сейчас находимся
в некотором состоянии с некоторым символом тогда мы переходим в новое состояние меняем
этот символ на новый и выбираем одно из движений лево на месте права вот это наша классическая
модель вычисления это все конечно хорошо прекрасно но это вообще неудобно ну то есть
это совсем например у нас уже просто на уровне там процесса мы процесс-то какой-то приложение
ой какая-то программа работающая у нас уже на уровне программы есть что у нас есть некоторая
программа процесс у него есть input стд in есть стд out есть стд r и логично нам было бы их
действительно как-то сепарировать чтобы были отдельные места где у нас хранится информация
которая к нам пришла в качестве хода где-то мы отдельно пишем информацию качестве вывода
ну вот например да еще где-то отдельно информацию напишем о том чтобы делать вывод более того это
вот просто процесс у нас есть еще один момент у нас есть процессор у нас есть машиночка в нашей
тачке там лежит цепу в этом цепу есть регистр и что как можно насмотреть вот на какой-нибудь
ядро этого цепу что у нас есть входные данные они прям приходят такой пачкой пачка там столько
сколько принимает этот регистр вот на регистр пиши данные у нас например 64 битная тачка обычный
регистр не xmm ymm zmm а вот просто обычный там какой-нибудь ну давайте в что там x86 там
какой-нибудь регистр rci вот 64 битика ему к нему прилетела вот такие вот ленты 64
дальше он как-то там производит вычисление у себя соответственно для вычислений условно мы скажем
что давайте вот здесь меня что-то будет как-то там с ним вычисляться и он выдаёт информацию
но ведь на цепу там не один регистр а куча регистров и можем по идее как бы сказать
что ну ок нам могут данные прийти которые больше чем и мы их равномерно разнесем по регистрам
которые вычислят и соберут вместе тогда что же получается нас по сути своего рода многоленточная
машина тюринга у которой есть венда входа input дальше у нее есть несколько лент для вычислений
калк один от английского calculations
калкен и у нас есть аутпут что такое не могу нормально рисовать
здесь у нас мы можем только читать нам сюда только информацию подвезли
здесь мы можем оперировать как угодно а здесь мы должны будем записать то есть
начально здесь мы пустая лента а в конце она должна стать не пустой и пользователь будет
ожидать что вывод машины тюринга на этой ленте как нам формализовать подобный агрегат ну если
одна лента это вот оно
то много лент это что это по сути одна большая лента вот такая вот считайте одна большая лента
но в которой мы просто сделали или вот так вот полосочки и работаем как бы ячейка у нас
теперь это одновременно склеенные раз два три сколько у нас здесь n плюс две ячейки в данном
примере вот такими вот векторами нас ходит ну примерно как смотанализом сначала в первом
семестре мы там с одновременными функциями потом во втором семестре hello world у нас
пространство rn вот теперь мы начинаем работать в пространстве rn только в пространстве лента
что же начнем погружаться в этот мордр итак у нас снова будет некоторые фавит сигма гамма
точно также состояние ну то есть мы снова работаем как бы с одной лентой поэтому состояние не
поменяется здесь accepted is rejected и дельта ну дельта это просто обозначение поэтому пока дельта
не поменялась афавит и ну как раньше писали так и сейчас можно да на самом деле сказать давайте
здесь будет алфавит для каждой ленты свой но давайте возьмем объединение всех этих фавитов
положим его за сигмой будем жить в такой более простой модели не будем ему сына себе жизнь
и у нас коленточная машина
коленточная
машина тюринга
ну вот эти вот все условия про сигму гамму конечностей сохраняется
а меняется главным образом именно тот элемент в котором зашифрована та интерпретация с
бесконечными лентами это функции переходов на самом деле дельта она и есть своего рода
формализация нашего нашей попытки интерпретировать вычисление как движение по бесконечной ленте и
изменение символов что теперь какие у нас движение у нас движение мы все также можем двигаться либо
влево либо вправо но теперь уже мы будем это делать по каждой ячейки то есть где-то мы здесь
где-то мы сюда пройдем получается по каждой ячейке нам нужно будет совершать эти действия
окей если по каждой ячейке мы говорим что это вектор вектор как у нас делается вот так вот
хорошо состояние состояние мы помним что мы живем в том мире когда состояние как были раньше так
и сейчас сейчас просто у нас лента теперь состоит не из ячейки а из вектора ячейки тогда
гамма это символ станет вектором здесь гамма тоже станет вектор на этом все то есть мы буквально
просто теперь работаем с многомерной ленты здесь
пока сложно я думаю понять что происходит очень абстрактно далеко от жизни но
рассмотрим сейчас пример и надеюсь все станет на свои места
сейчас загляну где у меня сам пример
вот
сейчас
ух
я найду весна
но она
потерялся так здесь же те условия которые нужны
на 29 я помню
как
у
для
можно
О, хорошо. Поехали. Вот задача, будет следующая. Нам нужно будет построить машину тюринга,
которая... Нет, я не то решал. Это не интересная задача,
вот. Которая проверяет, что на вход пришло число вида 0 в степени n, 1 в степени m,
0 в степени минимум из n и m. Что происходит? У нас получается, нам нужно быть сначала
определить n, потом определить m, потом подсчитать функцию минимума и вывести...
А, нам даже не выводить. Не нужно выводить. Если проверяет, то s-accepted, s-rejected. Мы просто
проверим, что это так. Нам s-addout не понадобится. Поэтому поехали. Первое, что мы делаем,
определяем какие у нас ленты в машине тюринга. Первое, стандартный вход. Второе. Итак, на
первой ленте вычислений мы будем вычислять n. На второй ленте входа мы будем вычислять m. В чем
плюс того, что я под каждое число выделяю свою ленту? Как только я его подсчитаю, у меня оно будет
уже сохранено на этой ленте. Все. Я теперь смогу просто использовать соответствующую ленту движением
головки. Дальше. Мне нужно будет вычислять минимум. Тогда завожу под него ленту. s-addout мне
не нужно, поэтому все. Вот 4 ленты. Ну, определились. 4 ленты есть. Алфавит гамма. Задаем 0, 1,
символ пустой. Дальше sigma 0, 1 и все. Еще, конечно, множество состояния мне нужно будет задавать,
но я его задам в конце, когда я пойму, сколько всего состояния мне понадобится. Начнем. Начинается
все с того, что нужно определить, как мы будем подсчитывать nm. Что мне выбрать в качестве базиса.
Там, например, числа можно раскладывать в различные системы счастливее. В зависимости
того, в какой системе счастливее мы раскладываем, по-разному будут вестись там вычисления. Я
предлагаю, так как нам нужно вычитывать минимум, использовать унарную систему счастливее. То есть,
мы просто поставим n палочек, m палочек, а минимум это наименьший из них. В таком случае минимум
будет высчитываться каким образом. Вот у меня есть просто числа палочек. Мы начнем с края и вправо до
тех пор, пока на одной из лент мы не встретим решетку. Как только мы встретили решетку,
мы остановимся. Перед этим мы будем просто брать и записывать подряд единички.
Встретили эту, остановились. У нас есть минимум.
Аналогичным способом, но если мы будем хранить в бинарной системе счастливее, то есть там 0 единицы,
как двоичный код, то аналогичным способом можно вычислять функцию побитого сложения.
Побитое сложение вычисляется следующим образом, пока в обеих лентах не встретим вланг.
Сумму уже сложнее. Сумму нам нужно будет, например, суммой. Сумма на самом деле проще в унарной.
Что такое сумма в унарной? Это мы переписали все палочки сюда, потом стали переписывать все палочки
Закончили. Начнем и начинаем мы с прочтения. Итак, у нас что? Должна принять состояние и какие-то данные.
Говорим, что вот функция Delta, мы ее сдаем. Мы принимаем состояние с 0, на трех лентах у нас ничего нет.
Давайте дополнительно укажем какое вообще начальное состояние у нашей машины.
На лентах 2-4 произвольное место.
На ленте 1 пишущая головка указывает на начало.
Все, пояснили какое начальное состояние у машины тюринга.
На самом деле состояние с 0, оно может сначала принимать вот такие два вариации.
Когда у нас на входе 0, то есть мы сейчас считываем 0, в таком случае нам нужно будет перейти к 0.
Ленту входа мы не изменяем, мы по ней только читаем. Мы сдвинулись вправо, прочитали, перешли к следующему.
Здесь, тогда что? Если мы прочитали 0, нам нужно увеличить на 1 количество единиц.
Количество единиц у нас в второй ленте. Тогда мы записали сюда единичку, сдвинулись вправо.
В унарной системе увеличение на 1, это просто до запись еще одной единицы.
Остальное все не изменно.
И мы переходим в какое состояние? В состояние с 0.
С 0 у нас чтение.
Хорошо. С 0 могло на самом деле встретить единицу.
Что в таком случае?
Если единица, мы оставим единицу, но будем в некотором смысле соответствовать принципу единственности ответственности.
У нас есть одно состояние, плюс это одно состояние отвечает какой-то одной задачи.
Не будем в одно состояние пихать много заданий.
Легко запутаемся и не сможем написать нормальную машину тюринга.
Тогда что? Давайте сушать ответственность.
С теперь будет не просто чтением, а чтением нулей.
В начале. У нас же есть нули в начале, нули в конце.
Сейчас я все отмечу, чтобы не забыть пункт.
Так вот, мы уже закончили.
Если мы вдруг дошли до единицы, нам нужно перейти в новое состояние.
Как мы перейдем в новое состояние? Мы ничего не изменим на ленте.
По сути, применили функцию identity и сменили на новое состояние S1.
Как будет работать S1?
С1. Его задача следующая.
Посчитать теперь единицы.
С1. Чтение единиц.
Буха.
S1 должен принимать один.
Здесь пустоту.
Тогда он не изменяет ленту входа, но сдвигается вправо.
Мучили эту единицу.
Он должен...
Он должен не изменить количество нулей и увеличить на один число единиц.
Лент, конечно же, ответственную за минимум не меняем.
Хорошо. Дальше S1 может встретить у нас ноль.
В таком случае мы должны будем остановиться, потому что все.
На этом чтение единиц закончено.
Применяем функцию identity и меняем состояние на S2.
На S2 пока мы остановим.
Потому что дальше S2, что она должна будет сделать?
Она должна будет переключиться на вычисление минимума.
То есть здесь это мы прочли.
Теперь нам нужно будет прочесть это.
Но для того, чтобы прочесть оставшуюся единицу,
нам нужно подсчитать минимум.
Значит, мы будем переходить в состояние, которое начнем считать минимумом.
Начнем.
Я думаю, просто сейчас сделать или нет.
Давайте сейчас я попробую сразу сказать.
У нас здесь рассмотрено в случае нулей и единиц.
Здесь тоже 1 и 0.
Но ведь у нас могут быть плохие строки.
Например, у нас может прийти строка из только нулей.
В таком случае, если нам пришла строка из n, вот такая,
нам нужно проверить, что n делится на 2.
Для этого мы просто перейдем в новое состояние.
Я пока его не запишу.
Запишем после того, как пройдем нужное число.
В таком случае, если нам пришла строка из n, вот такая,
нам нужно проверить, что n делится на 2.
Мы просто перейдем в новое состояние.
Я пока его не запишу.
Запишем после того, как пройдем нужное число.
Пока оставим.
В случае единиц, в случае с 1, мы также можем встретить пустое.
То есть это означает, что мы прошли 0, дальше встретили n.
А дальше мы пришли в состояние пусто.
То есть здесь нет нулей.
Как мы понимаем, что, например, n в таком случае будет уже хотя бы единица.
Ну, потому что мы в 1 попадаем, когда мы точно встретили единицу.
Тогда справа должно быть уже больше 1 нуля, а его нет.
Значит, это число уже не подходит.
А значит, мы можем уже один выход из вычисления написать.
S1.
Если оно встретит внезапно решетку.
Решетка, решетка, решетка.
То мы ничего делать не будем.
Но перейдем в состояние Sr.
Все.
Вышли из подсчета.
Начнем подсчитывать минимум.
Минимум я уже сказал, что мы начнем просто двигаться по лентам, пока не есть.
Но чтобы двигаться по лентам, скажу.
У нас на лентах имеется следующее состояние.
Денички.
Это лента n, это лента m.
Это лента n, это лента m.
И у нас сейчас мы лежим в этой ячейке, а здесь в этой ячейке.
Мы начнем постепенно сдвигаться по двум ячейкам сразу вправо.
До тех пор, пока одна из них не встретит
символ решетки.
Причем каждый раз, когда мы сдвигаемся, мы будем записывать единицу в ленту минимума.
Давайте это как-то формулизуем.
У нас вот состояние S2.
S2.
Я скажу так, чтобы не было сверху прочерк.
Здесь один, здесь один.
Прошу прощения.
Нам нужно будет как раз здесь сделать не n, а l.
Для чего мы это делаем?
У нас каждый раз, когда мы записывали в эту ленту, мы записали единицу в ячейку и сдвинулись в следующее соседнее вправо.
Теперь мы должны будем идти, пока у нас встречается единица.
Поэтому для того, чтобы начать следующую терацию, нам нужно будет вернуться обратно на единицу.
Вот ровно это мы сделаем на S и L.
Если внезапно там оказалось, что их нету,
ну то есть ну, нулей не было, единиц не было, ну мы просто попадем в пустоту, значит, ничего не прочитали.
Тогда и у нас терация не пойдет в следующее для вычисления минимума, ну и мы получим, по сути, ноль.
Так что все хорошо.
Итак, S2.
Она принимает что-либо на первой ленте.
Дальше, на второй ленте она принимает единицу, единицу.
Единицу.
Единицу.
Здесь будет символ решетка и сдвигается следующим образом.
Мы сохраняем то, что было на первой ленте, записываем 1, 1 здесь.
И также записываем 1 в вправо к ленте минимума.
Здесь мы сдвинемся в R, здесь в L, здесь на месте.
Нам важно сохранить позицию в ленте вода, поэтому мы пишем ZN.
Два других случая, когда...
Если здесь у нас что-либо, у нас решетка, снизу что-либо, здесь решетка.
Мы переходим следующим образом.
Здесь остались на месте, остались на месте, остались на месте.
И перешли, здесь нужно не звать, здесь S2 будет, а здесь мы перейдем в новостное состояние, в S3.
И аналогично в симметричном случае.
Если у нас встретилась решетка снизу,
если у нас встретилась решетка снизу,
то мы также завершаемся.
На момент перехода в состоянии S3 мы теперь имеем подсчитанный минимум на 4 ленте.
На момент перехода в состояние S3 мы теперь имеем подсчитанный минимум на 4 ленте.
что мы теперь делаем теперь если мы имеем подсчетный минимум мы знаем что
сверху у нас нули нули единицы то нужно будет просто проверить что у нулей
оставшихся ровно нужное число как мы это будем делать на ленте минимума мы стоим здесь а дальше
ровно столько единичек сколько должно быть нулей то есть мы можем делать следующим образом давайте
аналогично вернемся в единичку и дальше начнем шагать следующим образом 1 0 двигаемся вот сюда и
мы должны будем дойти до состояния когда одновременно упремся в решетке в таком случае победа
если мы пришли в состояние 0 решетка или решетка 1 значит у нас количество нулей и
количества минимумов не совпало берем здесь исправляем что нам нужно будет в случае завершения
с подсчета числа сдвинуться вправо бжух ой прошу прощения это мы сдвигались сюда нам
нужно будет сдвигаться влево сдвигаться влево здесь у нас да нужно будет на врат найти здесь
влево здесь влево има состояние с 3 поехали с 3 как она работает с 3 должно работать следующим
образом если мы встретили 0 не пойми что здесь не пойми что что угодно здесь что угодно здесь и
один здесь то мы можем спокойно сдвигаться а здесь влево у нас к сожалению здесь придется идти в
обратном порядке а по ленте входа вправо и двигаться с 3 если с 3 встретит внезапно 0 здесь решет
вот беда у нас не совпало минимум и тот значит мы ну по традиции сохраняем все как есть и завершаем
работу если с 3 решетка что угодно 0 аналогично прошлому завершаем выполнение
0 там этого появиться не может здесь ну для
здесь один же только да здесь все и опять же остался только один интересный случай мы встретили
единицу где-то если мы встретили внезапно единицу и что угодно здесь то беда мы не должны были
встречать единицу дальше только нули идут то сохраняем позиции конечно нет числа плохое
останется один интересный случай когда мы одновременно пришли в и там и там одновременно
свершились то это победа это с accept осталось одно важное но которое мы как раз тогда были
как быть в случае если у нас только нули тогда нам нужно будет отвезти сейчас скажу
особое состояние здесь 0 0 0 0 0 это с 0 давайте мы сделаем следующие с 2
если она встретила решетку то значит все слово которое нам подали это нули что угодно что угодно
что угодно мы перейдем в куда оставим все как есть и нам нужно будет теперь понять как нам
проверить начетность что значит проверить начетность проверить начетность можно следующим
образом как я предлагаю делать что мы будем идти в обратном направлении то есть по нулям
и поочередно записывать один в кудам я буду постепенно записывать один
сначала а потом я буду то один стирать и в конце мне останется проверить вообще у меня есть ли
один или нет то есть что буду происходить когда я делаю один шаг я записываю один когда я делаю
второй шаг я этот единичку стираю я делаю снова новый нечетный шаг я заново записываю
единицу делаю четный шаг стираю если у меня будет в итоге четное число шагов то единицы не
будет если нечетная то у меня будет один мне нужно будет на какой-то это ленте писать причем
мне нужна гарантия что изначально вообще там ничего не было для этого мне идеально подойдет
лента которая точно еще нигде не используется и пустая это лента минимум поэтому теперь она не
только лентам минимум но и лет лента четности я могу вообще вынести в отдельную ленту например
подсчет четности но сейчас я не хочу усложнять модель и писать еще пятый пятую строку абсолютно
бесполезно везде просьба там будет сохранение и на месте поэтому я просто переиспользую уже
имеющиеся ресурсы так у меня есть но не новое некоторое состояние здесь я сгинусь влево снова
все тот же трюк когда мы прошлись стоим сразу после окончания последовательности и движением
назад мы на него возвращаемся и нужно новое состояние последнее состояние которое мы
использовали это было эстей значит я теперь леша есть 4 и так есть 4 есть 4 может принимать только
0 0 что угодно как что угодно здесь будет пусто на ленте четности мы идем 0 влево все сохраняем
на месте а здесь записываем один и вправо то есть на ленте минимума случилось следующее была
решетка я на нее указывал теперь стала единица я остаюсь здесь дальше я перехожу уже в новое
состояние потому что ну здесь будет пусто поэтому конфигурация храницы мне запустится
стани с 4 мне нужно новое с 5 если с 5 получит 0 ой на месте давайте сохранюсь там не нужно
сохраняться на месте и тогда мне не нужна с 5 я буду использовать с 4 здесь на решетке а
здесь с 4 на единицы мы поменяем четность будет 0 влево на месте на месте опустошу
4 теперь выход и состояние с 4 с 4 может выходить только в состоянии решетки на первой ленте
здесь нам без разницы что а снизу у нас два варианта либо это решетка тогда победа это
четное число значит такое возможно скажу сейчас погодите что это плюм
0 в степени n 1 0 это 0 в нулевой это просто 0 вн ты все нам даже не нужно
на четности это я начал тупить это 0 вн тей поэтому любая последность из просто нулей она подходит
тогда нам нужно будет сделать следующие с 0 сучьей решетки ну просто где где где где где где где
у меня какой с 2 0 сучьей решетки это просто победа
я с 1 0 сюда мы прошли прошли прошли прошли прошли прошли прошли мне кажется я просто
сейчас с 3 а где за использовать штуку давайте думать я где-то это определил где я не помню
где вот не оно ли это с 1 с 1 перешло вот 2 с 2 дальше оно работает так
с 2 подсчет минимум да вот это с 0 это не с 1 это вот с 0 и в данном случае просто ничего не
делаю я перехожу с accepted потому что это в таком случае у меня просто строка из нулей а строка
из нулей удовлетворяет этому соотношению именно поэтому даже случай 0 1 0 0 равняется
и все но все ок вот это вот ненужное
в итоге вот наше писание машины тюринга отсюда до сюда дальше ну если предположим там придется
где-то понадобится счетность здесь вот мы так в бите просчитали счетность и зависимости от того
что мы увидели нужно будет просто все сохраняем это было решетка ты четность поэтому это было
accepted а с4 решетка ничего ничего один решетка ничего ничего один все сохранили как есть но выше
уже срежать если вы пытались это записать на там одноляточной машине тюринга я более чем
уверен что вы мне обошлись таким часом состояние а каким именно самое время записать здесь нужно
будет оказать что множество s этом с с а ср это дефолтные плюс нам понадобились от 1 до 3
3 дополнительных состояние это очень мало все достаточно компактно мы понимаем что
вот каждое состояние это какое-то действие у нас есть особые случаи
здесь все дальше s3 у нас за что отвечал у нас с 3 за
равенство 0 или в конце часа нулей минимум из n я вот настоятельно
рекомендую в этой задаче попробовать подумать про многоленточную машину тюринга она должна
упростить более того вообще почему она упрощает у нас есть теория мы про то как можно модифицировать
машины тюринга у нас есть произвольная машина тюринга одноленточная мы можем первым делом ее
перевести в ограниченную давайте слева
как нам это сделать нам рассказать что они эквалентны нам просто нужно в этой машине тюринга
выделить некоторые некоторую ячейку и дальше сейчас скажу
да здесь мы разобьем их почетности соответственно здесь аналогично относительно этого нуля мы пойдем
в одну сторону например четно другую нечетно и сейчас да и подсчитывая что движение сюда мы
можем почитать сколько мы двинулись здесь соответственно на нужное число раз отодвинуться
в соответственности отчетности и посчитать многоленточные машины тюринга удобно делать
следующим образом одну ленту превращаем в бесконечную одну сторону дальше бесконечно
одну сторону дробим по какому-нибудь модулю то есть выделяем отсюда там числа сравнимый с
один по некоторым модуле модуле это число лент там 1 будет 2 3 так далее и 1 2 3 так далее
им дальше их все мы начинаем превращать в ленты м штук и потом каждую из них раскрываем в
полноценную ленту и вот таким вот транзитивным способом мы имеем эквивалентность многоленточных
машин тюринга одноленточных если честно вот сейчас насчет этого я возможно где-то ошибся
не совсем помню как эквалентность прям четко доказывается это точно так это прям факт здесь
мог немножко наложать поэтому если будете готовиться почему-то проверьте что в теории так
у кого-то может быть есть вопросы по
щас скажу по многоленточную машину тюринга
а я вообще жив
супер вопросов нету получается да
все понятно
супер хорошо в общем тогда надеюсь 29 номер хорошо пройдет поехали в этот раз мы разбираемся
с щас скажу чем мы разбираемся можно глянуть мы будем разбираться с универсальностью
главное универсальное мне почему-то триггеры что я в прошлый раз это уже рассказывал про
универсальность числи мы странно я думал уже рассказывать текст идем дальше тогда начнем
говорить про универсальность так у нас есть понятие универсальность универсальность это
свойства машин тюринга свойства мы помним что такое свойства
свойства из окотача первого семестра это у нас предикат унарный
с одной стороны мы помним что предикат и мы можем интерпретировать как функции из некоторого
носителя в это в 0 1 где 0 1 были его константы либо как некоторые под множество n ты степень
данном случае мы будем интерпретировать именно вторым способом свойства это
некоторое под множество давайте я скажу что у нас есть
countable
вроде сейчас я проверю
это их сейчас путаю
вычислимые функции это
компьютер был все я плыву
компьют это был множество всех вычислимых функций ну множество опять же такое страшные
слова скажем что это все вычислимые функции не будем говорить точно множество это или нет
это некий некий такой класс функций причем мы скажем что не все вычислимые функции там на
самом деле можно говорить что там все вычислимые функции такого-то количество аргументов вот мы
сейчас будем рассматривать для количества аргументов где n равняется 1 универсально
функции для функций одного аргумента этого у нас были обычные f из n в какие требования
к универсальной вычислимой функции у в почти как увы но только у в в в давайте дадим более
абстрактное определение поэтому скажем для класса c у нас не есть некоторый класс функций
так вот универсальные функции для некоторой класса ц должна была дать для нас свойственные первое
что она вычислима причем давайте класс c из унарных вот n вен это вот какой-то функции да давайте вот
даже не так некоторые под множество давайте просто из она она вычислима как функции двух
аргументов не будем просто писать то есть у нас универсальная функция она будет иметь на
один аргумент больше она будет бинарной и поэтому теперь вычислимость нам нужна не просто что она
будет вычислима а что она вычислима как функции двух аргументов что теперь по сеточке мы можем
это его вычислять нормально все также теперь главное почему она универсальная это что для
любой функции с класса c будет существовать ее номер такой что f это есть вот давайте
у в ф будут называть как у у н нулевого
то есть функция она будет по второму аргументу 1 мы зафиксируем второй сохраним также мы
договоримся использовать следующую нотацию что у n t от x это есть не что иное как у n x
я реально определённо это рассказывал хорошо и дальше у нас появляется более сильное условие
которое заключается в том что мы хотим главность
главную универсально участимая функция и так снова для класса c
ну если это главная универсально участимая функция то теперь мы требуем что не в санкции
функции как здесь у нас была участимая функция участима универсально участимая
универсально участима все и теперь нам нужна главность что было такого в uvf в чем она могла
быть нехорошей у нас для каждой функции c мы ее можем поместить проекцию в сечение то есть у нас
у это табличка функции все появлялись как коризонтальные сечения если здесь у нас
здесь здесь здесь n здесь x то вот они были сечениями но могло оказаться что у нас вдруг
затаилось где-то лишние сечения которые выходят из этого класса и сама функция содержит что-то
лишнее поэтому теперь мы говорим что давайте теперь любое сечение для любого n выполняется
что у n вот функции по второму аргументу она лежит в классе заданном
еще
нет я это все я не что-то плыву что-то я плыву и сильно это третье условие в
это было третье условие для класса то есть первые условия численности второе это условия
универсальности а третье что она для класса то есть мы не выходим за класс
универсально учителя функции универсально учителя для класса а второе это что для любого вычислителя
это же что такое то компьютобл
бинарных найдется такое t из класса тотальных функций что для любого n
для любого x будет выполняться следующее что универсальные числи мы главные универсальные
числа моя функция мы пытаемся творить некоторый беспорядок на не беспорядок
короче некоторую такую перемешанину на ее строчках это будет какая-то вот такая функция
то есть идея в чем что какой бы мы другую теперь не взяли бинар какой бы другой бинарный
учителя мы не взяли мы сможем его получить из универсально учителя функции поэтому она
главная то есть любой другой к ней сведется есть на касательно этой функции интересная теорема
называется теорема к линии неподвижной точки
звучит на следующем образом что пусть у
nx главная универсально учтимая функция у нас есть некоторые тотальные функции
тогда для любого nx
сейчас тогда найдется такое n дайте назовем его n с чертой что у n с чертой x будет равняться
у от t от nx идея следующая что что какой бы мы тотальные функции не пытались в ней двигать
столбцы какой-то из этих столбцов обязательно сохранить свою позицию в этом ее тотальность
давайте такой вопрос сейчас касательно универсально учтимых функций главный
все понятно потому что все хорошо мы вот их сейчас задание проишаем и про них забудем вообще
прям нас совсем
мы видим раз никто ничего не говорит вопросов нет
сегодня сумбурника получилось
первое задание это попытка вас запутать теоремой к линии задание на внимательность задание
неприятное ставлю желтый короче 2929 задание это определенно не сложная задача на то чтобы
запрограммировать машину тюринга если делать с многоленточной если пытаться одноленточную
там есть определенный вариант в которых вы сделаете 40 за 40 состояний просто решите забить на
это нужно быть умнее там и так вот у нас тоже самое значение как мы делали раньше есть гув и
нам нужно сказать что не зависит от выбора у существует такое и он что для всех x выполнено
но это вот так вот даже не так дайте чуть стину чтобы было корректно утверждение
это просто ремок линии существует такое x что для всех n выполнено ну конечно же это неверно
но эти первые пункта чуть больше я там объясню что у нас есть f от n равное 2 n плюс 1 она принадлежит
тотальным но не f это она принадлежит тотальным поэтому все хорошо она отрабатывает это вот
буквально применение в пункте b мы уже видим что n и x они не совпадают поэтому скорее всего
это все лажа но здесь немножко хитрее что у нас будет фиксировано но некоторые x должно остаться но
у нас есть какая-то номерация там функции например инкримент а там принадлежит
компьютер был тогда для него найдется некоторые и ну и понятно что таких x вообще существовать
не может за счет того что это инкримент в пункт д стабильный то мы его не отмечаем в пункте
в у нас он и и и и поменялась и я поменялась только там по сути разными стами давайте делать
я вот черчу буквально мою универсальную чесим и функцию у меня есть у меня есть пусть там и она
1 и n 3 у меня есть какой-то x
и есть
до х плюс 1 что от меня хотят что в первом случае существует такое x что для всех
и он будет это выполнено ну давайте что сделаем сделаем вот вот эти должны совпадать у нас
f n x и так скажу и он 9 плюс 1 и вот они должны совпадать
ну в таком случае мне достаточно привести сказать что для любого x найдется n которые
будут неравно ну что не что для любого x будет существовать такое n что f
н от x и не равняется f n 2 n плюс 1 2 x плюс 1
сейчас ну пусть так существует что для всех и он выполнено
какой бы я не выбрал
но однозначно у меня все функции на одном аргументе не могут равняться у меня есть
две какие-то функции которые неравны ну давайте я возьму и скажу что здесь будет эта функция
тождественного нуля здесь функции тождественной единицы тогда я могу взять такую главную
функцию что вот на единицы это будет на тройке у меня будут записаны 0 1 это вот я фиксировал
в такой фиксации у меня получится что что должно существовать такой x что они должны где-то
совпасть но естественно нигде не совпадут поэтому вы неверный в случае пункта g что для любого
n существует такой x что они совпадут но опять же если я зафиксировал такую вот функцию универсально
главную универсальную числему что у меня здесь есть функции тотального нуля и функции тотальной
единицы они расположены соответствующим образом и поэтому они должны совпадать но
бред они такого не совпадут идея здесь следующая что либо это теория маклини либо пытаемся вот
например как здесь фиксировать какие-то две позиции у тривиальных функций то есть у функции
везде равные нулю функции везде равные единицы как чтобы они были неравны там функцию которые
например как здесь когда последовательны придумаем функцию чтобы сейчас скажем чтобы не совпадали
вот эти вот значения там какую-то строго растущую очень быстро растущую там экспонент то есть
возьмите вот как здесь инкримент чтобы не было возможности такого совпадения на больше строго
монотонно вот что нужно 41 все на этом все на самом деле или не все не все сейчас будет
самая приятная задача в курсе просто
чтобы научиться решать нужно просто запомнить следующую мантру так оформляем ее в виде теория
пусть у икс главная специальность на мою функцию в икс
учтем и функции двух аргументов тогда существует такое п что для
любого икс выполняется что у по икс равняется в по икс доказательств
ну если мы видим у есть вы в самое время используете рему к линии
для начала воспользуемся определение гув что у главно универсально учтемая функции
следовательно по определению будет существовать некоторая тотальная функция
что для любого икса будет выполняться следующим что у тн икс для любого икса для любого и
равняется в икс по теориями к линии будет существовать такое п но нас же вот теперь
есть тотально есть главный универсально учтем и есть компьютер был от двух аргументов то будет
считать такой п что у а т от п икс равняется в п икс обобщение не в п а уп и теперь осталось
записать транзитивную цепочку уп икс равняется у т от п от икс равняется в от п от икс
причем до говорится что здесь существует такое п что для любого икс чета д
вот это вот просто запомнили здесь расписали по определению применили теория муклине получили
вывод запомнили это доказательство тогда задача наша просто применить теперь эту теорию так
формуировка существует некоторые машины тюринга с номером n который вычисляет функцию f от n
и так если с номером n то этот номер пришел с некоторой главной универсально учтем и функции
хорошо у нас есть ун икс тогда что нам нужно нам нужно
делать следующее рассматриваем правую часть как следующее f от x равняется в от tx справа
может быть написано абсолютно произвольная функция она будет от двух аргументов нам нужно
сказать что она комбинарная функция вычислим и и тогда мы можем воспользоваться с этим утверждением
существует такое n что ун икс равняется в пх то есть будет существовать некоторое ун икс равное
в икс а это есть f с номером n именно то что нам сказали то есть задача буквально просто выучить
теорему ее написать а дальше сослаться на нее явно показав что вот это вот вы это вот ун и это
все задача максимально простая дальше начинается более сложный блок арифметика и арифметической
иерархии начнем с арифметической иерархии у нас есть арифметической иерархии
иерархия
она она на слово у нас на следующих двух моментах есть сигмака есть пика это не
п это п большая буквы заговна сигма мы помним это сумма от сумма сложения сложение у нас
логики дизъюнция это квантор всеобщенности это умножение это дизъюнция ой-ой-ой-ой существование
ту всеобщенности как мы определяем что какой-то класс сигмака или пика определяем и следующим
образом пусть у нас есть некоторый разрешимый предикат x1 xn и перед ним идет следующая
последовательность существует ой-ой-ой дайте y x1 так далее xn то есть это все равно в некотором
смысле функции от одной одной от одной переменной остальные все будут поедены кванторами здесь
существует дальше для любого существует и так далее в таком случае мы говорим что первый знак
существует следовательно это класс сигма здесь n следовательно это сигма если у нас здесь будет
для любого x1 так далее то это класс p и отметил сразу несколько важных моментов что есть у нас
идут подряд несколько кванторов то вот это вот все равносильно одному квантору по паре аргументов
поэтому в реальности мы делаем следующим образом что у нас идет некоторый блок существования
дальше идет некоторый блок любых
потом снова блок с квантор существования так далее вот доходит до предиката разрешимого
и такое мы называем вот
сигма n где n количество таких блоков
сейчас нм были здесь давайте по депо количестве блоков интересный вопрос возникает о том как это
вообще связано например с решимостью и там перечислимость ко перечислимость понятно что
сигма 0 равняется пиноль кванторов нету и у нас ты только разрешимый предикат но если разрешимый
предикат то очевидно это есть разрешимый deducible по-моему короче назовем просто разрешимый
сигма 1 пересечь сигма с п1 это дайте не так скажу сначала сигма 1 скажу что это перечислимая
п1 это ко перечислимая в принципе понятно же что вот эти штуки они дополняют себя там если
один то ко это вот мы смену квантор тогда сигма 1 пересечь с п1 это одновременно перечислимый
ко перечислимый по теореме поста это класс разрешимых вот а теперь начинается самое интересное
начинается кукуруза у нас уже были елочки самое время познакомиться с новым овощем
самое время научиться рисовать початок кукурузу вот у нас словно початок кукурузы и он как идет
вот у него есть листья
нормально это сделано
вот тут у него жухта
вот у нас класс сигма 1 вот класс сигма п1 здесь у нас лежит конечно же вот класс разрешимых
которые перечислим дальше у нас идет расширение сигма 2 которая включит нас все есть
п2 которая себя включит тоже там все так далее потом начнется там еще
сигма 3 какая-нибудь там интересненькая
п3 и так далее до бесконечности вот как кукуруза у нас все больше больше чаще чаще чаще это все
образуют как раз вот такой вот вложенность цепочки что мы знаем про вложенность этих
цепочек что сигма 0 равняется п0 равняется сигма 1 пересечь с п1 вложено строго в сигма 1 п1
вложено строго в сигма 2 пересечь в п2 вложено строго в объединения в их вложено строго в
пересечения следующих и так далее вот такая вот цепочка
самое время заняться классификацией арифметической иерархии
у
все что касается этого задания там скажем так неприятно
начнем множество программ с конечной области определения то есть нужно как-то сказать что
конечную область определения конечная область определения значит мы можем ее ограничить сверху
нашу сен значит это какой-то вот префикс больше существует некоторые границы b что для любого
и он выполняется что что если n меньше чем b
сейчас для любого n для любого m что если n меньше b нет наоборот больше то есть для
всех чисел больше у нас не должно останавливаться функция если n больше m то
дайте любого x что x больше n то у nt от x
у nt от x не останавливается за м шагов
обращаю внимание на этот момент эту штуку мы можем реально проверить здесь m шагов
это конечное число мы можем это проверить если мы только говорим что не останавливается это
проверить нельзя это неразрешимое свойство здесь существует дальше это очевидно sigma 2
множество параград которые на входе 5 равны пяти ну что это это множество таких n
которые находе равны то есть не должно стыд существует некоторое время остановки что
то у n на входе 10 равняется пяти останавливается за м шагов
это один контрсуществование sigma 1 потому что программ который на ходе равны 5 или не
останавливаются это очевидно sigma 1 не останавливается множество таких программ что для любого
m не останавливаешься для любого x что у n но опять же тут вообще на самом деле вопрос не останавливается
не останавливается на каком-то конкретном числе мы тогда считаем не останавливается или что не
должны на всех у n от x вот давайте я скажу так что я считаю не останавливается если не останавливается
на всех все что на больших ничего не знаю что на лучше всех не останавливается за м шагов
это п 1 ну смотрите или это у нас магическое объединение поэтому здесь мы имеем к раз
sigma 1 объединить п 1
дальше множество программ область которых спадается множеством простых чисел
проверка на простоту это вычислимо поэтому говорим что множество таких n что для любого
x для любого m что есть и у n t от x остановилась за m шагов то x принадлежит п и последнее но это
что это нас п 1 может программа из которых является экзотической прогрессии ух тут я просто
выпишу формулу это множество таких n что существует а нулевое существует дельта то есть мы задали
археологическую прогрессию что для любого x для любого m то есть задали вход задали число шагов
найдется к ну задали соответственно вот шаг в археологической прогрессии такое что если у n t от
x остановилась за m шагов то у n t от x равняется а нуль плюс дельта к
вот что здесь произошло здесь есть существование любого существования это sigma t
а теперь задача 38 дача 38 заключается в том что нужно просто четко по заданию выписать все
в пантерах оно не сложное но можно наплести лишнего
арифметическое рахимонус можно тюрьма определенных всех точек не бесконечной
фактической прогрессии с не нулевой разностью для которых при этом множество значений этой прогрессии
является не некоторых часа бесконечной фактической прогрессии с не нулевыми разниц ух
первое что мы говорим в этой задаче зафиксируем у n x главную честная функция
а теперь во всех точках некоторые бесконечные фактической прогрессии ну существует а нуль дельта
я впишу сюда но скажу так оно потом внесет должно вноситься внутрь но я просто не буду
делать потому что мне не несколько это неудобно что для любого к существует м
смотрите здесь сказано определенное во всех точках некоторые фактической прогрессии но
ничего не сказано про метод поэтому ну на остальном множестве мы не специфицируем
предвидение это зафиксировали сказали вот теперь что сейчас мы будем пробегаться по
и и магической прогрессии количество шагов зафиксирует за которые должна останавливаться что
мы делаем мы говорим что я перейду к записи в яму формате потому что иначе мы вообще не поймем
что происходит у n а 0 плюс дельта ка останавливается за м шагов дальше и
теперь нам нужно говорить что объединение вот этих вот арифенической рейс существует некоторые
а нулевое дайте так а существует некоторая дельта так неравную нулю существует некоторая ка
что
у от n а 0 плюс дельта ка равняется а 0 плюс дельта ка то есть мы сказали что это равняется
некото значение не на некоторых и последовательности но теперь нам понадобится сказать что что если мы
один раз приняли мы должны все остальные тоже взять потому что это же объединение
и для любого ка теперь нужно новая ка ну давайте
ка я не люблю такое вот сопряжение поставим ка существует м число шагов и
будет существовать ка ее сейчас сопряжение полюсик хорошо
давай точе что у n т от а 0 плюс дельта
каплюсик ну то есть для какого-то ка то есть для всех остальных должно
найти найти какой-то пара вопрос но говорим вот существует пара вопрос останавливается
за и он с удовельствием шагов и у н а 0 плюс дельта ка плюс равняется а 0 черта плюс дельта черта
ка сопряжение ну и наконец-то теперь это мы просто берем все выносим наверх
прошлое что там у нас было у нас было то что называлось этим скажу ее
приведение предваренно нормальной форме но здесь нам нужно переводить не просто
предваренно нормальной форме ак предваренно нормальной форме где кванторы будут стоять
максимально оптимально то есть нам нужно будет во первых поддерживать внутри вот этих вот всех
соответствующий порядок а остальное мы должны просто правильно выставить вот здесь например все
существует здесь заканчивается существует поэтому идеально слепляется для любого сюда ну
к сожалению не получится слепить нужно будет писать квантор у нас там каким существует а 0
существует дельта существует к и тут нет любого ка существует им существует
существует и он существует к что для любого к звезда существует м звезда существует к плюс
время разбираться в кванторах плюсики существует 5 штук первые первая сигма ответ
sigma 5 иногда могут получаться вот такие вот ответы в таком случае как это может
получиться когда у нас здесь есть еще один момент мне кажется я сдаю все это на пуду да здесь же
пересечение все это я топлю в общем идея в чем что здесь у нас будет квантор существования здесь
будет квантор для любого или это дизьюн ц и мы приводим пнф как мы приводим мы выкидываем
квантор существования выкидываю квантор с общности мы можем выкинуть их формате существует для
любого а может для любого существует и так и так валидно но в этом случае это sigma 2 в этом
случае это п 2 поэтому ответ здесь правильный не то что я написал изначально sigma 2 пересечь с
п 2 вот за счет того что можно кванторы переносить в разном порядке
здесь у нас не получится переносить кванторы в разном порядке именно потому что они лежат
на разных уровня вот как можно заметить у нас не получится их нормально вынести можно выносить
квантор в произвольном порядке когда вот они на одном уровне тогда их можно нормально их переносить
если нас например вот здесь вот было бы какой тут любого мы могли вынести с одной стороны существует
потом до любого а могли бы вынести сначала для любого а потом существует и было бы у нас там
объединение какой-нибудь окей
сейчас глянуть что происходит это есть это есть это есть это есть жух
38 42 задание это на
тему которая называется арифметика у нас была рифметическая иерархия теперь просто рифметика
формальная рифметика она лежит на основе аксиоматики она то есть у нас есть следующая
сигнатура саксессор сложение унижение равенство константа 0 1 и есть соответственно правила
там вывода аксиом есть аксиомы 1 13 из оп исчисления предикатов дальше есть аксиомы равенство это у нас
рефлексивность транзитивность рефлексивность транзитивность симметричность
ну как отношение к валентности дальше связь с аксессором
и связь со сложением и унижением
икс плюс игрек равняется z мне не нравится в плюс дубль у плюс дубль в
следовательно саксессор от икс плюс игрек равняется равняется саксессор от у плюс
дубль в аналогично у нас доваряется еще аксиом когда здесь умножение но я писать не буду и
у нас есть 3 аксиом пиано первая аксиом пиано она нам ограничивает натуральный чисто снизу
не натуральный чисто в общем да мы говорим что 0 он ограничивается снизу дальше что мы говорим
саксессор увеличивает что неверно что икс нравится игреку ой что саксессор сейчас
не хочу разбираться пофиг это по моему из как раз из равенства саксессоров чета туда
нафиг общего и самое главное это аксиома индукции я научить так что есть у нас некоторый
предикат если он верен нуле им для любого икс из верности предиката для него следует
истинность предиката для следующего в таком случае утверждается что для всех икс этот
предикат верен ну снова воспоминания транзитивный ой конус сейчас мозг уже
все пристает работать сейчас не транзитивная какая трансфинитная индукция вот да вот у нас
есть следующие индукции теперь от нас хотят чтобы мы вот формальные аэфметики
задали интерпретацию данной сигнатуры и проверили какие аксиомы вообще в этой
интерпретации выполняются какие нет вот что здесь произошло давайте в таком случае советую
рисовать бамбуки вот например у нас аксессор это он к некоторым сроде задает порядок с отн n плюс
1 0 1 2 жутко вот то поменьше а для меньше нуля у нас минус один жутко у нас получились такие
два графа эти графы показывают что у нас происходит вообще с данной интерпретации
проверяем что любого икс но не равняется следующим она выполняется действительно перед
предыдущих нет одна спросит вот очень важно нарушается внимательно надо быть дальше что для
любого игрека из это вот та самая эксилон пиано по-другому записан и там при помощи применения того
как он называется законов доморгана любого экса любого игрека я подозреваю что игрек
должен быть здесь очень странно стоит ну я буду интерпретировать так тут странно все это лежит
верно так что если следующие совпадают то эти совпадают но действительно нас нету такого
чтобы у нас мы переходили во что-то дно поэтому нарушений нету для любого икса вообще это говорит
о том что инъективность функции с с на самом деле на некотором смысле функции
для любого ирека для любого у экса не существует такой игрека что икс равняется с от игрек следовательно
вот это неверно у нас же есть минус один поэтому нарушили не существует такой и что их сравняется
с нет такого нету у нас нету нигде колечко принцип индукции ну смотрите это же это n это n это в
некотором смысле и он дизью нас n это фундировано это фундировано вместе все фундировано поэтому
принцип индукции выполнено он не будет нарушаться и последнее что если не расскажу снова новая тема
я уже немножко стал короче дешки рассказывать не буду как делаются простите
если будут вопросы можете написать я не расскажу
это просто абсолютно новая иная тема задача зеленая ее прям надо делать она легко лутает
баллы и эта задача на тем кто называется бета кодирование геодоля в чем идее бета кодирования
геодоля у нас есть некоторая последовательность это 0 тогда ли это
мы хотим закодировать у нас есть последовательность есть функции перехода
которая от это й и переходит к это й с 1 тогда мы можем закодировать все последовательность
следующим образом существует n существует а существует б такое что
бета функция геодоля от а б 0 равняется это 0 и бета функция от а б n равняется от это n и
для любого й меньше н выполняется что бета а б й плюс один равняется правила перехода
вот бета а б й вот
то есть что на самом деле бета функции геодоля там под капотом вроде китайской
в остатках попытка кодировать технические прогрессии вроде да намогу шеваться у нас вот
а и б это некотором смысле вот из там прогрессии прошло это у нас итератор то есть вот й это
нулевая поэтому у нас здесь 0 это nt поэтому здесь n здесь это й а здесь это й плюс первая вот как раз
поэтому в нашем случае если мы хотим закодировать там какое-то множество нам нужно задать его
качество последовательности и назвать продукцию мы хотим
кодировать мы хотим кодировать n степени n степени с одной стороны кажется что давайте
мы й будем превращать эту й давайте превращать там в какую-нибудь
й плюс 1 на n й так мы получим вообще факториал это не то что нам нужно поэтому мы будем
переходить следующим образом что у нас это й это будет n степень й и переход у нас будет
следующий n й на n это й поэтому если мы так записали мы можем явно задать вот это вот добро
поехали существует n существует существует а b существует что там
существует n существует b и а да уже пофиг на самом деле есть бета дальше а б 0 оно должно
равняться чему в n в нулевой степени значит один дальше и б б n n в степени n у нас n и и правило
перехода что для любого й от меньше и он выполняется что бета а б и от плюс один равняется
n бета а б ажух все на этом все это вот такое формулировка на самом деле не бывает посложнее
там нужно подумать как именно правильно закодировать годы как именно представить это
в виде последовательности и найти правила перехода все на этом у меня все если есть
вопросы welcome если нет вопросов то все
что тогда всем спасибо всем пока
