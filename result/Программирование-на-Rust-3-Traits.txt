К сожалению, у нас сегодня нет на лекции никаких девочек, поэтому некого поздравить с Международным женским днём.
Поздравляем тех, кто в записи, если такие будут смотреть девочки.
На этой лекции мы посмотрим на трейты и посмотрим на такую штуку, как называется интервью ментабилити.
Мы это успеем сделать, потому что слайдов у нас на этот раз достаточно много.
Собственно, план такой. Сначала посмотрим на трейты, потом посмотрим на такую штуку, как Exotically Sized Types.
В Rust'е дело в том, что некоторые объекты могут быть unsized, то есть мы на этапе компиляции не знаем их размера.
Поэтому у нас для этого есть специальный трейт, и мы с ним разберёмся.
У нас есть некоторый набор трейтов стандартной библиотеки, о которой мы рассмотрим также.
Они необходимы для того, чтобы, например, перегружать операторы или какие-то фундаментальные вещи в языке менять.
Сравнимся с тем, что у нас есть в плюсах, ну и потом поговорим про интервью ментабилити.
Такс.
Трейты это что-то вроде интерфейса в других языках.
Это не совсем правда, но давайте пока что в первом приближении, пока мы не узнали всё о трейтах, будем считать, что это вроде интерфейса.
Смотрите, я объявляю такой трейт. Я назвал его Animal.
Обратите внимание, что я не написал ключевого слова перед функциями Pub.
Потому что по умолчанию публичность функций, которые трейт им даёт, она зависит от того, публичен ли сам трейт.
То есть, если у вас трейт публичен, то у вас все его функции публичны.
Вот.
Ну вот, я сделал такие два метода, Name и Noise, которые принимают на вход Self и возвращают стринг.
Какого типа Self, скажите?
Ну да, типа, который наследуется в кавычках.
Который на самом деле, правильно сказать, имплементирует трейт. Сейчас мы это увидим.
Вот.
Также мы можем всякие дефолтные имплементации писать.
Это очень часто используется в стандартной библиотеке, потому что у нас есть какой-то набор базовых функций.
На основе этих базовых функций мы уже имплементируем какие-то дополнительные.
Например, в случае итератора мы можем по умолчанию имплементировать такие штуки как Map.
Мы же знаем, что итератор возвращает нас Next.
Мы вызываем Next и возвращает Option Item.
То есть, Option на следующий объект.
На основе этого мы можем, например, какой-нибудь Map устроить уже.
Ну, вы, наверное, видели в домашке, да?
Каждому объекту что-то применить, какую-то функцию. Изменить типа.
Вот. Давайте попробуем какую-нибудь структурку создать и имплементировать для нее такой трейт.
Вот. Я создал такую структурку. Назвал ее Ship.
И, смотрите, написал Impl.AnimalForShip.
Ключевого слова, заметьте, опять же, Pub нет.
Потому что это зависит от публичности трейта.
Я имплементировал Name так, что я просто клонирую Name, который внутри,
и возвращаю его, и Noize как какую-то строчку.
Бах. То, что говорит у нас овца.
Вот. Тут, кажется, все просто.
Давайте пойдем дальше.
У нас есть такой UsageExample.
Вот давайте создадим овцу, назовем ее Dolly.
Мы можем проверить, что, например, у нее появились новые функции,
которые мы не имплементировали у самой овцы.
Они зависели от трейта.
ShipName это Dolly.
Если мы вызовем ShipTalk, то тогда она станет...
Ага. DollySaysBug.
Да, это...
Ну да, все правильно.
Вот, видите, у нас Talk вызывает Name и Noize.
То есть NameSaysNoize.
И у нас, когда мы вызовем Talk, то у нас получится DollySaysBug.
Понятно?
У нас дефолтная имплементация у Talk есть.
Теперь давайте попробуем так.
У нас есть структурка Doc.
Мы ей тоже какой-то Name имплементировали.
Добавили какой-то Noize.
И даже мы можем дефолтные методы тоже как-то переимплементировать, как нам захочется.
Вот, например, на этот раз мы не будем там...
NameSaysNoize делать.
А вызовем PrintLens какой-то вот такой заранее заданной строчкой.
Вот.
Вот так вот это работает с дефолтными имплементациями.
Тут понятно, да?
Смотрите, а теперь я сделаю так.
Я создам такую структуру Human.
Человек.
Так, напишу Name.
Ну, Talk у нас какой-то тоже есть.
У нас тоже есть MyName, SelfName.
Самое интересное для нас Noize.
Смотрите, у нас Human имеет тип...
Ну, мы имплементировали TradeClone.
ThriveClone сделать.
Из домашнего, наверное, вы уже помните, что такое clone.
Мы обсуждали его две лекции.
Поэтому примерно помните, что если я вызову SelfClone, то тогда я склонирую человек.
Получается, да? Получается тип Human.
Ну, это вызывает...
Результат таких вот действий будет, по сути, то же самое, что просто написать SelfName.
Но, как видите, я могу внутри имплементации Human использовать его какие-то Trade.
Особенно для него.
Потом имплементирует clone.
Я могу внутри имплементации Trade Animal использовать clone.
Так как у Human есть clone.
Понятия на тот момент.
Ну, просто там какая-то дополнительная имплементация,
которая просто клонирует каждый объект.
Thrive так работает.
А если мы сделаем так,
ну, возьмем тот же Same Trade Animal
и попробуем в ток воспользоваться clone.
Во-первых, если вы попробуете написать clone,
то равняется SelfClone,
то эта строчка скомпилируется,
она будет внезапно иметь тип не Self,
то есть не объекта.
С строчкой скомпилируется,
она будет внезапно иметь тип не Self,
то есть не объекта, который имплементирует Trade,
а ссылочки на Self.
Референс, точнее, на Self.
Это не очень очевидно с первого взгляда.
На этой лекции еще разберемся.
То есть мы типа можем отдельно клонить ссылку
и отдельно клонить сам объект?
Вообще да.
Ну, если что, обычные которые Redone или ссылочки,
они копии являются.
Потому что у нас heardmm.
Потому что у нас может быть сколько угодно читателей, ну естественно, если мы создадим еще одного, никакой проблемы не будет.
А вот mutable reference уже не клонируем, потому что мы не можем иметь несколько писателей.
Это не очень очевидно, почему у нас клонируется ссылочка на self здесь.
Мы здесь чуть-чуть дальше по лекции это обсудим, поговорим.
Там работает такой trait, называется дерев.
И он нам чуть-чуть непредсказуемо работает.
Увидим, какие у него правила.
Но если вы попробуете сделать все так, то есть смотрите, я разыменовал self,
то есть тем самым я гарантированно получил тип self здесь.
Не ссылочку на self, а именно self.
И сделаю clone, то раз, надо пожаловать.
Слушайте, вот у вас типа self, нет clone.
Действительно, мы же типа, который self ничего не затребовали при имплементации трейта.
У вас появляются в голове какие-нибудь ассоциации с плюсовыми концептами прямо сейчас?
Ну вот здесь вот просто у нас раз по умолчанию ничего для типа не имплементирует.
Ну ничего не требует от типа.
Это нам нужно затребовать самостоятельно.
То есть давайте мы так и сделаем.
В плюсах, если что, подобный код, но там, конечно, не clone было бы, прекрасно бы скомпилировался.
Ну и так бы работало до тех пор, пока бы мы не засунули объект, который нельзя копировать.
В плюсах, например, конструктор копированный.
Смотри, если этот метод есть у типа, то в плюсах бы все прекрасно скомпилировалось.
Ты бы ни о чем не узнал.
А если такого типа нет, ну ты случайно засунул, не знаю, написал код, засунул какой-то типа,
которого нет конструктора копирования, допустим, и ты получишь такую ошибку при инстециализации шаблона.
В общем-то у нас нет такого метода.
Давайте попробуем и self затребовать clone, чтобы мы смогли склонировать объект.
Вот смотрите, у меня есть pop-trade-animal, я написал такое замечательное ключевое слово where.
Я сказал, теперь self у нас должно имплеметировать clone.
И это будет прекрасно компилироваться.
Обратите внимание, что теперь я пишу self clone, и у меня клонируется именно объект self, а не reference to self.
То есть уже наоборот по сравнению с этим вот поведением.
У нас тут было именно клонирование ссылки.
Мы это обсудим чуть позже, там просто есть такой замечательный мем.
Обсудим, в общем, как работает reference чуть позже.
Это отлично скомпилируется, потому что раз понимает, self имплеметирует clone.
Ну, where означает, что pop-trade-animal, где мы ожидаем, что self clone.
Да, но на самом деле чуть другое, потому что require строго что-то запрещает либо что-то разрешает.
Например, а вот какие-то вещи, которые ты не указал, он будет по умолчанию разрешать.
Мы тоже сравним это чуть позже.
Вот, а если мы попробуем, помните, у нас ship и dock были типы.
Вот мы возьмем вот такую вот имплементацию трейта и попробуем ship и dock, которые у нас были до этого, у которых не было clone.
Мы не писали derived clone на них.
Скомпилировать.
Вот тут примерно такие ошибки, что ship это не clone тип.
Если у нас пишут, что trade bound ship clone, значит свайп.
И мы будем получать такие вот от раз-то очевидные ошибки.
Еще на этапе, когда вы засовываете тип.
Он нам не даст сделать не очевидную ошибку, какую-то глубокую, которую нам потом очень долго читать от компилятора.
А еще мы можем попробовать какие-то написать банды в generic.
Вот смотрите, например, у меня есть такая вот функция.
Я у нее затребовал вот обратить внимание, что ti двоеточие, я тоже пишу какие-то требования.
Это работает точно так же, как where.
Я бы мог, по сути, написать вот здесь вот ниже, where, ti это clone, plus hash, plus iterator.
Запитает ti это clone.
Так, вы не потеряли сейчас.
Что такое ti?
Что еще раз?
Что такое ti?
Ti, смотри, у нас просто я затребовал, что это итератор.
Как жалко, что он не показал сам trait итератор, но в общем-то он внутри содержит тип item.
Он требует, чтобы для каждого во время имплементации этого trait это еще указало, какой тип у item.
Ну, то есть это какой-то тип, как using в плюсах.
Что еще раз?
Нет, он бы сказал, что у ti нет item.
Ну, вообще лучше делать это trait, наверное.
Потому что, насколько я помню, ассоциированных типов со структурами нет, поэтому нужно это именно в trait писать.
Обратите внимание, что сверху я бы никак не написал, что ti это clone.
Я бы просто не мог здесь что-то написать.
То есть в баундовых женериках они более ограничены, чем var.
Var это такой строго более сильный синтаксис.
Просто иногда будет быстрее написать в этих угловатых скобочках что-то, если там пара баундов и все.
Что еще раз?
Блин, на эту лекцию не успеем.
Да, да, прям посмотрим.
Там внутри будет trait и traitor, и внутри там будет написано type item.
Это будет означать, что когда ты будешь имплементировать traitor, то тебе нужно будет написать какой-то тип для item.
Ассоциированный тип.
Вот. У нас есть внутри там какой-то new, который возвращает self.
Ну и вот я ровно сказал то, что можно перенести это сюда.
Вот оно как раз тут перенесено в качестве примера.
Это понятно?
У нас нет как такового наследования в расте.
У нас такой не объектно-ориентированный язык раст.
Но тем не менее мы можем делать такую штуку, назвать support trait.
Ну смотрите, у меня есть такой trait person, trait programmer.
И как вы видите, я могу их наследовать.
То есть, например, я создал trait student, который затребовал то, чтобы у объекта также был имплементирован person.
В принципе, это то же самое, что и написать where self person.
На самом деле даже не то же самое.
Нет, это когда вы требуете.
Я вам соврал, это не то же самое.
Но это именно как бы приплюсовать между собой trait.
То есть, если вы имплементируете student, то у вас обязательно должен быть имплементирован person.
И Rast будет об этом знать.
То есть, вы сделали балл такой.
А как это отличается?
А как это отличается?
Да.
От where отличается тем, ну там будут сейчас у нас еще trait объекты.
И Rast в общем-то в таком случае не поймет, что у вас, если вы будете писать dean student,
то Rast не поймет, что person тоже имплементирован.
Поэтому желательно super trait именно делать.
Чтобы он делал vtable на это все дело.
Ну, мы сейчас поймем.
А как это все отличается от плюсовых классов?
Как вы сказали, что это наследование, а это...
Ну, наследование плюсовых классов, оно именно плюсует, грубо говоря, классы между собой.
Там же появляются...
Ну, если, например, публичное наследование,
тогда у тебя будут все приватные методы переедут, функции и все такое.
И даже, которые внутри находятся, как их назвать, переменные, ну, поля, да.
Вот, поля тоже будут как бы смержены.
А здесь именно trait, он как интерфейс, он то, что умеет делать структуру, показывает.
Да, естественно, плюсах в памяти размещения это может быть, ну, не как два класса,
то в Rast это будет просто два класса, да, нет?
В плане, два класса, да.
В плане, то, что, ну, вот как раз то, что нет.
В проблеме в том, что trait в поле нет,
и поэтому интересно, как просто двигаешь концепты, учили его, решили другие концепты.
Ну, что-то типа того, да, концепт концептом усиливаешь.
Вот.
А в депоте имплементации в трейдер чем нагоняется EOTP?
Так, вот с этим вот понятно, да?
Примером, здесь вот у нас programmer plus student это computer science student,
ну, то есть я могу много трейдеров завтребовать.
Более того, я могу, например, не написать функцию, я ставлю только фигурные скобочки.
Когда бы это означало, что computer science student это кто-то,
кто имплементирует programmer plus student, например.
А еще я могу, соответственно, добавлять какие-то дополнительные функции.
А в чем мотивированное отсутствие наследования?
Наследование в плане наследования структур, в меньшую очередь.
Ну, это на самом деле такой способ очень легко делать ошибки.
Ну, даже, например, в Java запрещено множественное наследование.
А если ты захочешь сделать имплементацию для нескольких интерфейсов в плюсах,
ну, читай для нескольких структур с какими-то функциями,
то в таком случае у тебя будет множественное наследование,
это как-то не очень хорошо.
Я, опять же, хочу, наверное, это снести ближе, ну, этот разговор к концу трейдов,
чтобы мы все выяснили о трейдах, а после этого мы как бы это все просуммировали.
Если вы не против.
Ну, то есть, чтобы я не забегал наперед, пока я вам рассказываю про разницу с плюсами.
Вот. Давайте дальше пойдем.
А давайте вот так вот сделаем. У нас есть какая-то структурка форм,
которая есть username-age, есть два трейда, username-widget и age-widget.
Обратите внимание, что у меня есть два гета.
Так, да.
Ну, вот я имплементирую username-widget и age-widget.
Вот возвращает username, возвращает age.
А потом я делаю вот такую вот штуку.
Я создаю форму, а потом вызываю get. Что произойдет?
Кажется, у get разные return-types.
Что, return-types?
Кажется, у get разные return-types.
Да, там разные return-types, но там даже если одинаковые,
если одинаковые, то тем более было бы все плохо.
Здесь, конечно же, точно так же, как и вы не знаете, что произойдет,
так же и компилятор rasta не знает, что вы от него хотите.
В общем, он на вас пожалуется.
Он скажет, что знает несколько get-ов.
От username-widget и от age-widget.
Соответственно, нам нужно ему сказать, про какой мы get-говорим все-таки.
Есть для этого два таких способа.
Во-первых, мы можем сделать...
У меня комментарий остался, неужели?
А, ну это просто комментировал то, что было старое.
Во-первых, я могу это вызвать от трейта.
Смотрите, username-widget-get.
То есть я написал трейт username-widget, запросил у него get,
в качестве self передал ссылку на форму.
Rasta поймет, о каком трейте идет речь.
Какой именно get вы вызываете.
Что еще раз было раньше?
Ну да, вот он в комментариях.
Form-get.
Он не знал, какой get вызвать.
То есть теперь мы ему сказали, вот здесь вот я хочу username-widget-get.
Теперь понял, что мы имеем в виду именно это.
И оно скомпилируется прекрасно.
И выведет rasta с ним.
Потом у нас есть еще age.
И мы можем сделать это.
Выведет rasta с ним.
Потом у нас есть еще age.
Ну вот смотрите, я здесь вот использовал такой особенный синтаксис,
который называется fully qualified.
Давайте мы его собственно обсудим.
Я взял нашу форму.
Смотрите, я уточнил, что формы я рассматриваю как age-widget.
То есть я рассматриваю как объект, который имплементирует
trait-age-widget.
Ну форм действительно имплементирует эту штуку.
То есть я что-то типа приведения сделал примитивного.
И потом я вызываю get на форме.
То есть я знаю, что я на форме вызываю age-widget теперь.
Это такой fully qualified синтакс называется.
Сейчас мы его еще обсудим.
Вот конкретно на этом слайде примерно понятно, что происходит в этой строчке.
Сейчас еще будет.
Если написать вместо age-widget-form, то он не заработает?
Вместо age-widget-form, то есть форма с форм?
Нет, не сработает.
Ну во-первых, там должен быть trait.
А у нас там структура, то есть форма как структура.
Структура как структура, это было бы странно.
Сейчас еще раз, у меня здесь не чарик, а вот это вот форм приводится к age-widget,
и потом get называется.
Не, ну вот это вот, это только для компилятора.
Для компилятора мы говорим, что мы сейчас будем от форм вызывать age-widget.
Этот синтакс заключается от первого тем, что мы сначала проверяем тип аргумента, что это форм.
Во-первых, проверяем форму, а во-вторых, мы проверяем age-widget, то есть то, что get действительно есть.
И вызываем именно get от age-widget в этой форме.
Вот так вот.
Ну это все, естественно, на этапе компиляции происходит, а не в runtime.
Смотрите, это очень похоже на turbofish.
В первой лекции у нас было упоминание о нем.
Даже не упоминание, мы чуть-чуть его посмотрели, когда были в женерике.
На самом деле...
Даже не знаю как...
Какой вы способ, так сказать, инстанцировать?
Ну давай пока что это проедем, побежим дальше, потому что у нас много слайдов.
Все равно это не совсем turbofish.
На самом деле это называется polyqualified syntax, то есть в данном случае.
Оно хоть и похоже на turbofish, но turbofish'ем не является.
Еще если будете читать где-то в интернете, то раньше это называлось universal function syntax.
И это самый общий способ вызывать функции в расте.
То есть более общего способа нет.
Большую часть времени раз за вас понимает, какую вы вызываете функцию.
Иногда, когда он не понимает, вам приходится указывать.
В первом случае вызвали это от трейта, во второй раз тоже от трейта, но это еще более общий способ.
Как-то так.
Сейчас.
Я подзабыл, что я хотел сказать.
Да, ну мы требуем AT, что он имплементирует трейт.
Мы это все вроде бы уже сказали, да?
Ну да, если это просто идентификатор, то это может быть пропущено.
Ну тут понятно, да, примерно.
Ну вы не говорите, просто понятно. Если что-то непонятно, лучше спросите.
В плане edgeVisitGet мы можем, конечно, так сделать.
Оно сработает.
Я просто показал, что еще можно вот так вот еще более общий способ для вызыва функций есть.
То есть вот этот и этот синтаксис, они работают абсолютно одинаково в данном случае.
Так.
А что если мы хотим зацепить какой-то тип, который имплементирует какой-то трейт?
Ну, собственно, помните, я писал, что в дженериках можно вот такие вот ограничения вводить.
Ну здесь вот я какой-то myTrade требую и clone.
Тоже вы, наверное, видели это в домашке.
Только здесь вот обратите внимание, мы это уже делаем не в структуре, а в функции.
То есть мы в функции тоже можем делать дженерик и требовать какие-то там сложные на трейты ограничения.
В том числе мы можем тут написать where.
У меня примера с where, наверное, нет, но мы можем написать в общем t и после этого написать where t, это myTrade прес clone.
myTrade прес clone.
Структуру вместо трейта?
Как понять?
Ну, в общем, что у нас у тебя в структуре? То есть там поля нельзя просто...
Ну, трейт это какая-то абстракция на уровне компилятора, по сути.
То есть нет никакой поля в структуре?
Ну, в трейте, да. В трейте он только ассоциирует типы, константы и функции.
Функции мы посмотрели, типы еще посмотрим, константы попозже посмотрим.
А вот если мы в структуре используем все, не потребуем clone и при этом в теле функции будем планировать с t, то это будет...
То расскажешь, что не имплементирует clone.
Причем... Да, да.
Ну, то есть это в каком-то смысле преимущество перед плюсами, потому что мы получаем ошибку сразу же.
В том месте, в котором мы еще используем тип.
Ну да, а не в том месте, в котором мы еще используем тип.
Да, кстати вот...
Вот mytrade плюс clone еще можно писать так.
Impl.
То есть такое ключевое слово.
Impl делает ровно то же самое, это просто синтактический сад.
То есть оно точно так же создаст какой-то там тип t после функции, который mytrade плюс clone и импл.
То есть импл делает ровно то же самое, это просто синтактический сад.
То есть оно точно так же создаст какой-то там тип t после функции, который mytrade плюс clone.
И этот t подставит на место импл. mytrade плюс clone.
То есть вот эта вот запись и вот эта вот запись, это одно и то же.
Просто второй вариант это синтактический сахар.
Что такое синтактический сахар? Мне сразу видно, что это женерис.
Сейчас, можно еще раз?
Так.
Тут видно, что это женерис, а там нет.
Получается, это неудобно, если у нас несколько элементов.
В плане.
Да, такой вопрос. Мы можем несколько имплов?
Да, можем.
Ну t, он естественно раз называет это не t.
Там какой-то у него интернал.
Мы вот здесь пишем, вот на этом слайде.
Вот мы пишем импл. t.
И вот, допустим, мы хотим еще output. t.
Вот на следующем слайде мы тогда что, должны дважды написать?
А ты имеешь в виду, чтобы мы и там и там требовали один и тот же тип t?
Да.
Нет, тогда нужен generic. Импл, он просто такой синтактический сахар в одно место, что-то вставить.
Что еще раз?
Потом обращаться к типу переменной.
К типу переменной? Ну это generic.
Да, ну как он называется?
Не, подожди.
Подожди, тип t ты не можешь выяснить, если ты в генерике.
Все, что ты знаешь о типе t, это то, что он имплимитирует mytrade плюс clone.
Ну если я хочу создать другую переменную типа t.
Ну другую просто создавай ее.
Нет, ты ее я хочу написать.
Я хочу написать tnew.
tnew?
Ну, предположим t имеет...
Ну, допустим tclone хочешь написать, clone имплементирован, да?
Ну...
Ну ты просто напишешь input letig, сравняйте input clone, и оно прекрасно будет работать.
Нет, какой-то статический метод.
Статический метод, в плане.
Ну, мне не нужен экземпляровать. Мне не нужен input, я хочу t.
Короче, вопрос, как в засахаренном коде достать тип аргумента, который был засахарен.
Ух, примерно так.
Ох.
То есть вот в предыдущем таблице...
Не, я понял, что вы хотите, то есть достать тип t.
Вот я сходу вообще не знаю, как это сделать, я никогда так не делал.
Да.
Нет, скорее всего, там есть что-то такое, чтобы достать, но я так ни разу не делал.
По-моему, звучит очень проще написать генерик.
Ну, так это вот реально, ну это как когда в плюсы втащили возможность аргумента и пункции.
Ну, вот это полезно в основном, когда он, например, возвращает итератор.
Вы пишете там стрелочка, импл итератор. У нас такое было в чате как раз.
Тогда мы будем возвращать итератор, в общем-то.
Что-то, что возвращает итератор.
Вот.
А что если мы хотим какие-то дополнительные методы в зависимости от того, что t что-то имплементирует?
В компиляторе это выглядит...
Не в компиляторе, точнее в стандартной библиотеке.
Это выглядит, конечно, не совсем так, но в принципе достаточно.
Похоже.
У нас есть и нам option.
Так.
Я сделал какую-то имплементацию, какие-то функции option.
А теперь я хочу при условии, что t что-то имплементирует, ну имплементирует default,
а у нас есть какие-то еще функции.
Вот я могу написать импл t, option t, vrt, default.
Если t имплементирует default, тогда у типа option t появится дополнительная метода из этого блока.
То есть они объединяются все такие...
Да. Все, что имплементирует t, они там, сам компилятор выяснит, что это имплементировано.
Вот.
Сейчас еще какая разница между там, где vr есть и нет vr?
Повтори.
А.
Есть ли разница между, где есть vr и нет vr? То есть мы можем...
Ну смотри, вот здесь у нас произвольный тип t, мы от него ничего вообще не требуем.
А вот здесь мы требуем default.
И, ну типа, мы можем либо тот, либо тот использовать.
Нет, мы можем, если t не имплементирует default, то нам будет доступна только функция из этого блока.
А если имплементирует?
А если имплементирует, то и то.
Ну получается, мы можем так, ну, сколько угодно наканустроить, и компилятор все правильно подмешает.
Ну он будет добавлять.
Ну если у вас так получится...
Ясно, просто какой-то произвольно-сложный технический граф по специализации, и компилятор подмешает правильно под граф, да?
Я вот подзабыл, конечно, какой хороший пример здесь можно произвести.
Да не важно, как хороший или нет.
Не, не про это.
Там может быть такое, что у вас компилятор не понимает что-то про имплей.
Я подзабыл, я подзабыл, что именно, поэтому, наверное, не буду на всякий случай вас путать, потому что в чате добавлю.
Вот.
Но это, в общем, знаете, что вот эта вся фигня, она аддитивна.
То есть если у вас там будет default плюс clone, допустим, ниже, то в таком случае это нормально приплюсуется.
А если у вас будут как-то пересекаться имплы, то тогда компилятор будет отжаловаться.
Он-то разрешит, причем еще на этапе, до того, как вы хоть какой-то тэп ставите.
Какая была комплиментация, которая вам пользуется?
Обе, либо обе, либо только тэ.
Объединение всех имплов, которые подходят.
Да, объединение всех имплов, которые подходят под тип тэ.
Можно делать отдельную реализацию для тех, у которых чего-то нет.
Дело, когда нет default.
Да, там есть not default.
Ну, там есть такой значок, например, вопросик будет означать, что не обязательно имплементируют.
Это используют для сайст почти всегда.
Нет, есть вопросик, есть восклицательный знак.
Восклицательный знак означает не имплементируйте.
Это уже, конечно, вопросик к началу.
Онрос прищелся как сахар конкретно для уксана.
Ну да, наверное.
Ну, вопросик именно тут имеют. Вопросик к default здесь будет, если не обязательно имплементировать default.
Восклицательный знак не имплементирует default.
А вот это уже больше похоже на то, что в стандартной библиотеке.
Библиотеки. Ну, не больше, в принципе.
Тоже самое, что в стандартной библиотеке.
Если T
имплементирует default, то в таком случае
будет включена вот такая вот функция.
До этого у нас были импл блоки, а теперь у нас
есть два импл блока. Теперь у нас один импл блок
и есть вот функция Android power
default. Она действительно есть в
опшене. Она действительно принимает self
и возвращает либо T, если
у нас опшен, то сам.
Либо default-ное значение
T, если у нас там now.
То есть мы можем
делать еще более точечные?
Да, мы можем функции
включать-выключать,
в зависимости от этого.
А зачем нам здесь у каждого
это и у импл, и у опшен?
А, вот это про это?
Помню, на первой лекции говорил,
что мол, это выглядит нелогично,
что мы дважды повторяем один и тот же список
аргументов. Но сейчас
чуть подальше мы увидим, что у
трейтов тоже есть дженерики.
И что это нужно будет расфасовывать.
То есть импл — это все почему мы
дженерик, а дальше просто расставляется
тип. Мы увидим это,
когда будем говорить, например, про
сравнение.
Свиная врасти нет.
Так, понятно ли
вот такие вот базы трейтов?
Окей, я просто
посмотрю, где в ВЭР можно
писать?
В ВЭР можно в функциях писать,
в трейтах писать.
Можно в структуру включать
или отключать структуру для каких-то
типов.
А, как в ВЭР?
В плане структуры написать
в дженерике, например, стракт-тест
и внутри написать тиклон.
И в таком случае, если засунуть
при инстанциализации структуру
какой-то тип, который не клон, компилятор скажет,
что для этой структуры нужен обязательно
клон тип.
Давайте поговорим
про exotically sized types.
Большую часть времени
у нас размеры типов врасти
положительные, строго положительные
какие-то натуральные числа.
Это, на самом деле, не всегда правда.
В-первых, у нас есть типы нулевого размера,
во-вторых, у нас есть типы размера, которых
мы не знаем на этапе компиляции.
Всего у нас есть такие вот,
по крайней мере, в стабильном расти,
есть такие вот четыре типа.
Там вроде бы есть еще пропозалы дополнительные
для того, чтобы работать с FFI,
но я тут уже слабо разбираюсь,
не буду вам
рассказывать про это.
В-вторых, если мы используем FFI,
то мы, в общем, почему-то не можем сказать,
кто он такой.
А это что FFI?
Это foreign-function interface,
когда взаимодействует с другими языками.
А что у нас в последние две категории?
Zero-sized types и empty types.
Empty type это, ну, сейчас увидим,
пустой енам, который нельзя инцелизировать вообще.
Например, есть структура, которая просто
не в смысле в пакете.
Нет вариантов у енама.
То есть ты его не машинит.
В бюджетах типа тип пустой,
если у тебя все объекты с этого типа пустые,
а тут просто значение пустое.
Получается как, как бы сказать, ненак.
Да-да, это как раз то, что с первой лекции.
Вот.
Нас из этого особенно интересует Dynamic
и size types.
Бразируя size types, там, в принципе, достаточно
все понятно.
Мы даже на первой лекции поговорили.
Нас интересует 10.
В первую очередь. Сегодня.
Это такие типы, у которых
неизвестны размерные этапы компиляции.
Есть два главных типа 10.
Даже более того, это
два единственных типа 10 вообще на весь раз.
Это slice и trait-объекты.
Вот когда мы проходили slice
и проходили строковая slice,
мы же, наверное, когда на это смотрели,
думали, а почему это у нас
это ссылочка постоянно пишется
перед tr и перед u8.
Ну, может быть, да.
Но казалось, что это просто обычные
скриньки юхи, там есть, ну, и span,
и spilso. Нет, это не совсем так.
Потому что для того, чтобы было
все корректно, с точки зрения
теории типов, у нас же строковая slice
не понятного размера
во время компиляции. Мы не знаем в зависимости
от user input и все.
А вот ссылка на строковая slice,
она уже понятна, что из себя представляет.
Она представляет из себя указатель
и размер, допустим, slice.
А, что бы это,
ссылка на slice имеет указатель
и размер. Да, ссылка на slice-то
умеет, а сам slice- это какой-то
участок памяти с точки зрения теории
типов raster. Он не знает, какого размера slice.
Он not sized.
Ну, еще есть такая штука, называется
trait-объекты, на которую мы еще посмотрим.
Это, в общем-то, у нас
кемическая диспетчеризация.
Эти типы не имплементируют такой trait,
называется sized.
Это так называемый маркерный trait.
Припоминайте копию.
Я вот говорил, что у нас
копия- это маркерный trait,
с точки зрения компилятора.
Да, он имеет
с точки зрения компилятора
особенную семантику.
Если вы имплементируете копию,
то это что-то говорит компилятору,
что можно копировать просто по байтовой типы,
что у него другая семантика внутри языка.
Sized тоже самое говорит.
Это маркерный trait, который что-то
влияет внутри компилятора самого.
И на самом деле, когда он говорил raster,
ничего не требует помолчания типов, я
капельку соврал. Все-таки raster
помолчания типов требует то, что они sized.
Это он делает,
потому что у вас примерно все, что вы будете
создавать, будет sized.
То есть будут действительно редкие ситуации,
когда вам нужно будет писать, что тип
не обязательно sized.
Да, может быть, мы посмотрим сейчас.
Вопросительный знак
у B
для частности
не обязательно
по умолчанию.
Вопросительный знак, как раз вопрос
Sized, это самый частый паттерн.
Мы его будем очень часто
видеть сегодня, когда мы будем в стандартной
блядевку смотреть.
Как я говорил, запомните,
в raster очень строгая система типов.
Следите за типами.
У нас slice,
как я говорю, это
вещь, которую непонятная размера.
И для того, чтобы с точки зрения
теории типов все было правильно, мы не пытаемся
как в плюсах, допустим, сделать string view,
у которого там пара указателей,
допустим, внутри.
Мы именно создаем отдельный тип,
который unsized размера, и
делаем ссылку на его, который уже sized размера.
То есть чтобы все было корректно с точки зрения
теории типов, ничего не ломалось, soundness
работает, все прекрасно.
Safe raster получился.
В том числе у нас
как я сказал,
t и ссылка на t это разная вещь.
И то, что у нас ссылка
на str и str это разная вещь.
Вообще,
внутри raster я вам, конечно, говорил, что это
два указателя на какое-то время, кажется.
Я вам чуть-чуть собрал, это все-таки
указатели и размер.
То есть указатель на начало
слайса и число батиков,
которые у вас дальше идут.
Ссылка на t
Нет, это правда только для unsized
типов.
Это будет, как минимум,
по очереди будем идти,
это правда для слайсов.
Для слайсов это правда.
Еще там будет чуть-чуть другое
ссылок на
trait объект.
Ну и естественно...
Да, это все для того, чтобы у нас
получился в итоге safe raster.
Мы делаем тип t, который unsized
и потом делаем ссылочку, которая уже
sized.
Чтобы у нас все в сумме получилось
корректно.
Давайте посмотрим на вот такой примерчик.
Я создал trait hello.
Теперь хочу в функциях
принять слайс
объектов, которые имплементируют hello.
Все объекты, которые...
Ну, просто чтобы везде
вывести строчку hello.
Как вы думаете, это скомпилируется?
Ну, скорее всего, да. Не скомпилируется.
Это не скомпилируется, потому что
раз должен именно типа получать
внутри слайсов.
Он не знает размера типа hello.
Он не знает...
Дело в том, что много объектов может
имплементировать trait hello.
У них у всех могут быть разные размеры.
В слайсах, естественно, не засунешь.
Компилятор не понимает, что значит слайс
объектов hello.
И соответственно, ему нужно
какая-то... Нужна какая-то другая информация.
Давайте для начала пробуем
сделать так.
Засунем generic, скажем, что у нас
какой-то tag, который имплементирует hello.
Какой-то конкретный tag.
И у нас будет слайс таких объектов.
Скомпилируется ли такой вариант?
Да. Да, это скомпилируется,
потому что раз знает о том...
На самом деле, мы здесь, напоминаю,
не явно требуем, что t это size.
Здесь на самом деле плюс size
еще есть.
Потому что у нас почти все объекты size
на практике.
Вот.
Он будет для каждого отдельного типа t,
так как это generic, имплементировать свою
вот эту вот функцию.
И, соответственно,
вызывать нужную вариацию.
Ну, все еще
это же не то, что мы хотели.
Это не то...
Просто слайс
объектов, которые выполняют
trade.
Это
какой-то конкретный
отдельный тип. А как получить так,
чтобы у нас были
разные типы?
Кстати, еще
подсмотрю, что у меня там в следующем.
Да, это как раз тот вопрос, который задал.
Вот.
Да.
Вот, давайте посмотрим сразу же на ответ.
Так что мы его не угадаем.
В Rasty есть такое ключевое слово,
называется din.
Оно означает, что этот объект
динамический, то есть
он будет в run-timer.
В частности, у нас din hello
это unsized
тип, потому что мы не знаем, какой
размер у типа,
который имплементирует hello.
А вот ссылка на din hello
это уже понятная штука.
Еще раз, у нас какой был вопрос,
с чем проблема была?
Смотри, а как нам сделать
такой слайс, чтобы в нем были
разные объекты и все имплементировали hello?
Здесь же у нас конкретный тип,
который имплементирует hello, они все одинаковые.
Что если я хочу разные?
Если в одном слайсе
предъявляют разные объекты?
Да.
Алеотипы?
Нет.
Смотрите, у нас ссылка на din hello.
Din hello, как я говорил, unsized тип.
Это непонятная какая-то структура,
которая имплементирует trade hello.
А вот ссылочка на din hello
это уже понятная штука, которая
представляет 2 указателя.
Это указатель на сам объект
и указатель на vtable.
Ponte virtual table.
Что такое?
Вот как раз
будет виртуальная табличка
методов hello.
И мы будем вызывать их.
То есть подставлять указатель на наш объект,
находить нужную нам функцию,
которую мы хотим вызвать,
подставлять и вызывать
правильную функцию.
Попросим, какой массив
это динамический массив?
Мой?
Нет, не может.
Это точно такой же слайс, как если бы я
написал, что вот здесь у tuple из U64
и U64, по сути.
По размерам будет тоже самое.
Din hello это просто какой-то
тип, который означает, что у нас
указатель на trade объект.
Это называется вообще trade объект.
Din trade.
Соответственно, какой-то trade.
Дин создает
trade объект,
который имплементирует hello.
Как я говорил, что
din hello это какой-то
unsized тип, потому что мы не знаем
размер объекта, который его имплементирует.
А вот ссылочка на din hello,
это уже понятная вещь.
Это virtual table и сам объект.
Эта штука называется
fat pointer.
Если что, толстый указатель.
В этом смысле
мы можем раз встречаться, если будете
читать про раз.
В этом смысле.
Ну да, можно сделать
вектор ссылок на din hello.
Смотри, на первой лекции мы говорили,
что в расте ссылка это
first class object.
Потому что rast проверяет
валидность этих ссылок.
А в плюсах это reference for wrapper.
Если только
хочется так сделать.
Более того, мы
отсмотрели на ссылочку, но можем сделать даже так.
Вот смотрите, я имплементировал hello для str.
Обратите внимание, что str
это unsized тип.
Имплементировал для строкового slice
hello.
Ну и вывожу просто hello str.
Ссылочка тут лишняя,
я хотел просто str оставить.
Потом я создаю slice
и вызываю там
создаю reference 1, reference 2
и reference 3. R1 понятно,
что такое. Мы с этим уже разобрались.
Более того, мы можем
создавать умные указатели
на трейд объекта.
То есть что-то,
что имплементирует hello,
у нас это
box.new.xclone.
Это на самом деле
просто особенный синтаксис.
Box во время
инстанциализации своей
он знает, сколько ему нужно выделить памяти
под объект.
Но после того, как мы ему сказали,
что он теперь din.hello, он содержит
указатель на vetable.
То есть, когда мы говорим ему,
что он создает
какой-то din.hello объект,
он выделяет память под t,
но мы же знаем в данный момент,
что у нас является
строковым slice.
Я выделяю память под этот тип t,
а потом я еще добавляю
vetable.
И то же самое с rc.
Reference counting.
Box это уникальное владение rc,
это много может быть.
Chef.ptr, но
однопоточный.
Строго однопоточный.
Еще, конечно,
плохо, что на слайде не показало.
Если вы где-нибудь сверху изvtx.hello,
то, естественно, раз уж я имплементировал dester.hello,
то оно успешно будет работать.
Так, никто ли не потерялся?
Точно никаких вопросов нет?
Это мне кажется,
что, наверное,
все потерялись уже.
Там почти везде
в стандартной библиотеке
подданца есть типы,
так или иначе что-то.
Ну, в общем, специальная есть
и проблема.
Если я возьму din.hello,
то это объект непонятного размера.
Это какая-то структура, которая имплементирует hello.
Это может быть str,
это может быть какой-то мой объект,
который непонятного размера.
din.hello непонятного размера.
А если я беру ссылку на din.hello,
то это trait.object,
то есть это указатель на сам объект,
ну, указатель понятного размера,
и указатель на vtable.
Vtable тоже, ну, указатель на vtable тоже понятного размера.
Поэтому, соответственно, din.hello понятного размера
мы можем его инициализировать на стеке,
раз все понимает и все получается.
А вот неизвестного размера,
то есть trait может быть разных размеров,
мы мылим, что
в немногих переменах,
а размер будет увеличиваться, есть функции будут создаваться,
то есть почему может быть у трейта разный размер?
В плане у трейта.
Это у объектов,
у объектов, которые имплементируют трейта,
могут быть разные размеры.
Так.
Мы можем ключевым слове din.
Извините.
Прямо вопрос появился.
В предыдущем слаге вот
вот это din.hello,
он вообще где будет хранить?
Это на стеке.
Ну, то есть это все разворачивается
на этапе компиляции, он понимает,
что на самом деле...
Он на этапе компиляции создает vtable.hello
где-то, кладет его.
И когда он будет
это компилировать, он, соответственно, положит
в din.hello, то есть в r1,
ссылочку на x где-то
и рядышком он положит ссылочку на vtable.
Он же знает, где
hello vtable и знает,
какой объект мы берем.
Соответственно, получается
два osize по размеру.
Два указателя.
Ну, и все будет на стеке.
Так.
Мы можем еще у din.trait
требовать какие-то дополнительные...
Ну, попробовать
затребовать дополнительные
трейты.
Давайте попробуем это сделать.
Создаем так x
и пусть... Ну, hello
и какой-то я там trait world создал так,
чтобы вы не видели, да.
Неважно, что он там имплементирует.
Если я напишу din.hello plus world
расскажет, что
мы не можем затребовать
больше, чем один trait здесь, не auto-trait.
Что такое auto-trait?
Ну, это такие штуки как send, sync.
Мы с ними попозже познакомимся
и включим словом auto.
В общем,
просто знайте, что пока что на данный момент
все, что вы можете сделать, затребует только один trait.
Включим слов 1.
Если вы хотите больше трейтов,
то вам нужно создать супертрейт и имплементировать.
И тогда Rust корректно
сделает vtable для этого дела.
Кажется, как что-то, что очень легко
добавить как фичу.
Но, типа, это же...
Почему не может сгенерировать
hello world самостоятельно,
если мы пишем hello plus world?
Раз, за явность, поэтому
тебе нужно будет явно создать такой trait.
Все, что
имплементирует hello world.
Скажем так.
Просто такой синтез,
синтез-синтез-синтез-синтез.
Ну, мне что-то кажется,
что в связи с этим будут какие-то проблемы,
если мы не будем прям явно
создавать это дело.
Так.
Мы можем затребовать какие-то auto-trait.
Вот, как я сказал, например, send и sync есть.
Это такие для многопоточности трейта.
Сильно опускаться пока не будем.
Ну, маркерные трейты, они тоже для компилятора
существуют.
Ну, и мы тут пишем plus send,
и оно все отлично скомпилируется и будет работать.
Вот.
Окей, давайте попробуем такой от код
скомпилировать.
Как вы думаете, скомпилируется?
Я предыдущий момент.
А вот вы же говорили, что
только один можно
трейд показать.
Ну, я сказал, что можно только один,
не auto-trait. Send это auto-trait.
Его можно указывать.
Ну, я просто так вот говорю, что вот есть такие трейты,
типа send и sync, которые можно дописывать.
То есть мы чуть попозже
ознакомимся.
Нам, по сути, на данный момент можно считать,
что мы можем только один трейд дописывать,
потому что мы не ознакомлены
больше ни с чем.
Интересно, вот это скомпилируется или нет?
В принципе, наверное, плохо то, что я дописал тут send.
Можете считать, что его тут нет.
Все равно не скомпилируется.
Скомпилируется.
Чем это отличается от того,
там был пт, какой-то.
Тут просто клоун.
Да, тут вот есть
нюансик. Попробуйте догадаться,
что тут не так.
Сейчас отберешь то, что send на ответ
не влияет.
Да, send не влияет на ответ, поэтому
я говорю, что его можно убрать.
Убираем, думаю.
Может быть, функционированные боксы,
что-то еще.
Логично, что для клоуна
не будет работать. Как же он будет клонировать то,
что не знает?
Вот, нам дали точный ответ.
Как мы можем узнать то, что мы клонируем вообще?
Мы же не знаем тип, который мы будем возвращать.
Мы когда делаем один клоун,
то мы стираем тип.
То есть, соответственно, а клоун что делает?
Он берет self и возвращает клоун.
Ну, возвращает self.
То есть, это касается любых трейдов,
у которого функции возвращают
этот тип
за трейдчину?
Да. То есть, там есть
некоторый набор правил, которые мы сейчас посмотрим.
Это называется все правило object-safety.
Давайте мы посмотрим
на ошибку компиляции.
Нам Rust явно говорит,
что клоун не может
стать объектом, скажем так.
Cannot be made into object,
потому что мы не знаем
как сказать.
Здесь, видите, есть второй ноут.
Чтобы трейд был
object-safe, ему необходимо
чтобы мы могли
зарезолвить типу динамически.
Мы не можем зарезолвить тип динамически,
потому что его стерли.
Вот.
Мы бы могли бы зарезолвить,
если бы у нас был какой-нибудь, не знаю,
один hello, и hello бы мы могли
просто обратиться в vtable,
у нас бы все работало.
А здесь мы не можем, потому что у нас
клоун возвращает self. Мы не знаем, какой
self он возвращает.
Давайте уточним конкретно,
что происходит.
Чтобы быть object-safe,
никакие методы
трейд не должны
использовать тип self.
Потому что если мы будем его
использовать, то в таком случае мы не будем знать
какой тип нам приходит
на вход. Ну, например,
не на вход, а вообще какой тип
возвращать. Например, если мы будем
возвращать self, как
клоун, или, например, принимать
на вход какой-нибудь второй аргумент, который
тоже self. Откуда мы знаем, какой self?
Более того, это трейд
не может
иметь никаких статических методов.
Опять же, потому что мы не знаем
никаких...
не знаем типа self.
Ну, у трейда можно тоже статик методов
добавлять. Это получается
я уже наперед забежал этими словами.
И, например, у нас есть такой трейд,
fromIterator. Если мы будем
вызывать fromIterator, то мы не будем
в таком примере, мы не будем знать
какой код нам запустить.
Потому что мы не знаем
типа self.
В общем, раз
за вас будет за этим следить,
за object safety, если вы будете
динамически пытаться там какие-нибудь вещи
типа клоун засунуть,
то в таком случае он
вас ударит по рукам.
Вы знаете, что типа self
нельзя использовать там, где у вас динамический
хересолвик.
Ну, по понятным причинам
мы не знаем типа.
В общем, это все как-то напоминает
сложности в использовании стандарений плюсов.
Кстати говоря, есть
any врасти даже. И он даже
умеет его типа выводить.
Ну, там будет одна даже задача домашняя.
Просто инханит.
Намечение каска как-то
можно полно объяснить вот этим приколом, что
мы
знаем.
Так. С object safety
вам все понятно? Ну, примерно
понятно, да?
Примерно, да.
Примерно только, да.
Ну, с этим надо положить.
Это как SDMove.
Ну, SDMove
очень просто, наверное.
Ну, нет, ну потом просто.
Ну, да.
А потом приходит кооперижинг такой, нет,
все, закрываем.
Так.
Так еще раз. Есть ли вопросы про
public safety?
Окей. Дальше.
Мы можем даже добавлять
исключительно для
trait-объектов какие-то дополнительные функции.
И раз, то их запишет vtable.
Например, я сделал
какой-то trait-example.
Я его
не вместил на слайд, видимо, да.
Вот у меня есть какой-то trait-example.
Потом я добавил impaldine-example.
И у меня есть там
функция
isDin, которая говорит, что у меня
объект динамический. Ну, естественно,
это будет труп, потому что у нас будет доступно
только для динамических объектов.
Создал какую-то структуру
test, имплементировал для нее
example. Создал
x и y. x это
вполне конкретная штука. Это тест.
А y это boxDinExample.
Внутри
тоже тест содержит.
Но мы об этом не знаем.
Конечно, если мы напишем x из
din, то, так как у нас
это не динамический объект, расскажешь,
что такой функции нет.
А вот y из din уже скомпилируется,
потому что dinExample у нас
имплементирует dinExample.
Вот так вот.
В плане размер.
Это просто штука, которая
говорит, что вот
в эту штуку нужно засунуть
variable.
Смотрите, у тест
какие функции?
Я не вместил.
Это просто какой-то пустой трейд.
У него нет никаких функций.
А я еще добавил имплDinExample.
Там есть из din. Соответственно, у x
нет вообще никаких методов.
А у y будет из din.
Потому что я добавил
vtable метод из din.
ИмплDin означает,
что мы имплементируем для трейд-объектов
эту функцию.
Только для трейд-объектов.
То есть для того, что dinExample.
Для них будет доступна эта функция.
ИмплDinExample
это какой-то
тип, который
реализует example.
ИмплDinExample
это какой-то
трейд-объект.
Это какой-то
dinExample.
Ну, а вот как
в box он поймет
размер
dinExample?
Там же нужно при создании box
знать размер типа...
Он же создает, когда box new
он знает, что тест имеет нулевой размер
и что, по факту, раз даже не будет
ничего лоцировать, потому что там нулевой размер.
Такая оптимизация будет.
И в итоге там будет
только ссылочка на vtable.
А если у нас
example2 реализовывал example?
Этот метод был у dinExample2?
Еще раз.
Если у нас example2 реализовывал
example?
example2 это какая-то структура?
Трейд.
Он требует это супертрейд, он
example требует.
У dinExample2 был вот этот метод?
В плане...
Подожди, я создаю супертрейд.
Наследует ли супертрейд
содержимое имплемента отсвете номеров?
Ну да, будет.
Так.
Вот есть такой еще интересный вопрос.
Когда нам предпочитать трейд-объекты
генериком и наоборот?
Да,
это именно этот вопрос.
Ну раз уж мы уже знаем
про какой вопрос речь, давайте попробуем
ответить.
Чем же генерики лучше?
Ой, ну ничего.
Капиллятор
помогает с ними.
С динобъектами, как видишь, у нас тоже
помогает.
Так. Ладно, тогда давайте
я буду за вас отвечать.
Я немного не понимаю вопрос.
Там создавать условно функции
принимающих генериков?
Да, ты можешь создавать функции, которые
принимают dinTrade.
Можешь сказать, например, функция,
которая принимает tMyTrade,
а можешь сказать, функция,
которая принимает dinMyTrade.
Например.
Мы используем, что негр получит,
пожалуй, по фигуре пользователь
и код за счет конкретных
типов. Да, это может
помочь.
За счет того, что мы знаем конкретный
tpt, мы можем делать для него специальные
оптимизации и, соответственно, ускорять код.
Какие минусы у генериков?
Нет вот этой гиторогенности, типа,
что нельзя делать массив
имплементов одного генерика, не использовать
ритм. Давай предположим,
что мы рассматриваем только ситуации, где и то
и то возможно использовать.
Интересно.
Так, давайте попробуем.
Сейчас.
Ну, что-то типа вот это.
Ну, вот как-то...
Ну, смотрите. Во-первых, трейд объекта
это только одна функция.
То есть мы создадим только один
экземпляр функции.
Ну, если там, конечно, нет каких-то дополнительных генериков
или что-то в этом, то будет один экземплярчик
функции, который будет
сравнительно небольшой.
Если у нас в случае генерика
может функцию
100 типов, допустим, разных
передаваться, то у нас будет 100 разных
инстанцев. А в случае
динамической диспетчеризации
у нас будет только одна функция.
И это, на самом деле,
хорошо в том смысле,
что это трейд объекта,
они мешают код bloat.
Ну, знаете, когда у нас
очень-очень много разных типов,
то в таком случае у нас на каждого
есть своя функция и, соответственно, очень-очень
много кода. У нас становится
огромный бинарник, мы перестаем
влезать в кэшпроцессор,
и это плохо.
А вот одна функция
динамической диспетчеризации уже будет
прекрасно влезать, и даже, возможно,
какие-то специальные
оптимизации никакой
речи не играют,
когда у нас все влезает в кэшпроцессор.
С другой стороны, нам
наверное не очень нравится постоянно ходить
по указателю в объект.
Ладно, по указателю в объект нам не нужно
ходить, но вот vtable нам нужно ходить.
vtable ходить
достаточно плохо.
Вот, мы не хотим
диреференситься.
Вот, как я сказал, у нас
стоит объекты дают меньше кода,
соответственно,
но они требуют того, чтобы
мы читали vtable.
С другой стороны, дженерики
они обычно быстрее,
потому что они
type-specific оптимизации
включают для компилятора.
Вот.
Но
есть проблема, что
когда есть много типов, которые
имплементируют дженерик-функции, в таком случае у нас
становится много функций,
и они не влезают просто в память процессора,
в кэш.
И в этом кейсе уже
trait-объекты будут быстрее, конечно же.
Но, как вы понимаете,
общий ответ, это, в общем-то,
всегда профилируете код.
Вы заранее,
ну, возможно, если глаз наметом
ответите, конечно, на этот вопрос.
Но, in general,
лучше попрофилируйте код, чтобы
понять.
Никто не потерялся?
Так. Понятно ли
примерно с типами
необычного размера?
Что они примерно в себе представляют?
Ужас какой.
Может, закроем дверь?
Так, давайте поговорим про
типы
traits, то есть стандартной библиотеки.
Поговорим примерно минут 10,
после этого пойдем на перерыв.
Вот. В первой лекции я вам говорил
про средства кода генерации, например,
про bring.tlm.
В том числе вы и в домашней
это видели, и в примерах лекции есть
такой macros derived, который позволяет
автоматически выводить какие-то стандартные
библиотечные traits.
Ну, и не только библиотечные.
Вы можете написать свои macros.
Такие macros называются процедурными,
то есть они генерируют за нас код.
Вот. В то время как macros вроде
bring.tlm это декларативное,
подробнее мы поговорим про это попозже.
Но просто чтобы вы не пугались,
derived macros это вещь, которая
автоматически как-то имплементирует
trait, ну, для нас.
Обычно там какой-то очень
линейный простой характер имплементации,
то есть, например, в случае клон
склонировать каждый тип отдельно.
Нет, свою версию macros не можем,
но можно написать macros под свои traits.
Будем это делать.
То есть, чтобы пользователю было удобно
писать derived и какой-нибудь наш macros.
Вот.
Давайте начнем с default, самый простой.
У него есть drive default macro.
Если у нас все типы внутри структуры
имплементировать default, то в таком случае
default имплементирован.
Все, что делает default, это
просто возвращает
какую-то default имплементацию объекта.
Для чисел там будут нули,
для options будут
noun, да.
Мы можем
trait default имплементировать
самостоятельными руками.
Например, если у нас default имплементация
по нашему мнению
должна содержать какие-то единички
там внутри, не знаю,
как нам хочется,
то мы можем это написать ручками.
Вот.
Да.
Ну, это удобно в том смысле,
что, например, как мы
видели с options, там есть unwrap for default
и вообще
очень много всяких структур
в библиотеке,
смотрят на наличие trait default.
Вот. Ну, просто чтобы
нам было удобно. Это такое...
Знаете, мы не можем
абстрагироваться по всем типам,
которые имеет конструктор new,
но мы можем абстрагироваться по всем,
в которых есть default какой-то конструктор.
Это, грубо говоря, наличие
default-ного конструктора.
Еще давайте, чтобы закрепить
obj-safe-ли это trait.
Да, это не obj-safe-trait,
потому что он защищает self.
А если у тебя будет din-default,
то это не скомпилируется по той причине,
что когда ты будешь пытаться вызвать у объекта
default, то не будешь знать, какой тип
возвращать. Тип stirred.
То есть только указатель на объект и указатель
на vetable.
Default имплементировали.
Да, он скажет, один из объектов
не имплементировал default.
Ну, это eror. Просто скажет, ну вот
я не знаю, имплементируют default
либо руками, либо имплементируют для этого типа
для начала.
Ну, конечно, удобнее
default имплементировать для того единственного
типа, но если
default категорически для того типа
нельзя, то, к сожалению, придется руками.
Default предназначен для такого линейного,
максимально простого имплементации.
Вот.
Это как раз то, что я сказал.
Мы не можем абстрагироваться по всему,
что имеет new, но мы можем абстрагироваться по всему,
что имеет default.
Вот. А почему этот trait по умолчанию
не выводится в расти?
Вот, если все имплементирует default,
почему бы там не вывести default?
Ну, стандартный билотичный
библиотип вроде бы все имплементируют.
Vector имплементирует, option имплементирует,
всякие числа имплементирует.
Вот. Ну, очень-очень много
объектов имплементирует.
То есть, можно считать, что практически
вся стандартная библиотека этим traitом
пользуется.
Вот.
Так, что у меня там дальше будет?
Там будет call.
Вот.
Ну, на самом деле, просто потому, что Rast
не хочет ничего автоматически за вас
имплементировать. Он хочет, чтобы
все указали руками.
Это на самом деле несложно дописать
derive default, если вам это нужно.
Либо, если у вас какой-то custom-naked
behavior, то вы напишите
самостоятельно.
Ну, то есть, это нужно для того,
чтобы продолжать
то, что Rast ничего умолчания
от типов не требует.
И в том числе
еще есть проблема, что если у вас
default все-таки другой, он у вас
имплементировался автоматически.
В таком случае, а вдруг у вас
не устраивает default имплементация,
а вы об этом забыли просто.
Забыли ее изменить.
Или удалить. И в таком случае у вас
будет ошибка в коде.
Ну, то есть, здесь Rast
явно от вас требует.
Чтобы вывели
default.
Вот.
Есть еще clone.
У него тоже есть macros.
У него есть
clone, как мы уже видели.
А еще есть такой вот clone from,
у которого есть default имплементация.
Это достаточно такое
общее правило для стандартной библиотеки.
Бывают дополнительные
удобные методы, которые
default-но как-то имплементированы.
На основе того, что
уже вот есть.
Например, на основе clone, который есть в этом трейде,
мы создаем clone from.
Ну и почему же этот трейд по default-у
не имплементировается?
Да, по той же причине, абсолютно.
Причем с clone
на самом деле ситуация даже
хуже, чем с default-ом, потому что
clone еще
в общем такая вещь, которая может вас
вызвать даже unsafety
в Rast.
Если вы будете очень...
Напоминаю, в save Rast невозможно
вызвать undefinedBehaviour и memory
unsafety, но если вы будете как-то
очень некорректно использовать clone и unsave,
даже не очень некорректно,
если у вас где-то будет unsave и clone,
то в таком случае очень легко сделать ошибку.
Мы там чуть-чуть попозже
посмотрим, как можно просто банально
когда вы проектируете стандартную
библиотеку, затребовать чуть-чуть
больше, чем нужно, и за счет этого
получить
случайный memory unsafety в Rast.
Ну, такого нет, конечно,
в Rast. В Rast нет memory unsafety,
но просто будет пример такой
inocelec, который мы посмотрим.
Вот.
Есть такой тип копия.
Вот.
У него есть derived-копия macro.
Ну, этот macro, по сути, просто пишет там,
что impo copy for type
и все. То есть там же нет никаких
типов. Это маркерный
trait. Он для компилятора существует.
И он означает то, что мы просто
копируем бита.
То, что вы говорили,
ну вот, вас спутало.
Есть такая штука в Rast как move
semantics, а есть такая штука,
которая называется copy semantics.
Copy semantics,
то помните, мы там делали let x
равняется 42, потом let y
равняется x, и
если с вектором, допустим, там происходил move
и x был больше недоступен,
то в данном случае у нас
x остается доступен, а y копируется
просто. Ну, то есть это уже
copy semantics.
Как видите, это такой маркерный trait, который
меняет то, как компилятор работает с вашим
типом.
Нет, если
copy это еще более сильно, чем
clone.
Ну, смотри,
если у тебя
клонирование в случае
какого-то примитивного типа, это просто копировать
битики, а trait copy
это просто маркерный trait,
который говорит, ну вот, я только что просто
скопировал битики и больше ничего не сделал.
То есть, если
типы имплементируют копию, то можно, соответственно,
его клонировать, но это логично, да?
А что значит
маркерный trait?
Означает, что он для компилятора.
Меняет что-то в компиляторе.
Это такая языковая фишка.
Ну, я, помнишь,
вот сказал пару минут назад про
пример с x и y, как у нас
вектор moveался,
а 42 копировалось.
Помнишь? Ну, вот
она меняет даже семантику внутри языка.
Имплементация такого trait.
Вот.
Ну, то, что copy clone, это потому, что
clone в данном случае будет просто копировать
битики, а copy говорит, что я только что
скопировал битики. Верь мне, компилятор.
Грубо говоря.
Ну, числа копируемые типы, да, просто
битики скопировать, числа скопировалась.
А вот вектор скопировать просто не получится, потому что
у нас получится внутри два указателя на одну и ту же память.
Но нужно клонировать, то есть
с буфером внутри.
То есть, copy это более сильное
условие.
Ну да, он проверяет, что
каждый тип внутри копии, и, соответственно,
делает копию для
всего типа.
Вот. Есть еще
partial и co.
Это такая штука,
которая предназначена для сравнения объектов.
Обратите внимание, до этого у нас не было
генериков третий. У нас появились
генерики. То есть, мы можем
затребовать какой-то RFS, который
полночайное self правую часть сравнения.
Обратите внимание,
что стандартная библиотека продумана,
поэтому у нас RFS не обязательно сайсит.
Мы можем сравнить между собой два слайса.
А никто не мешает.
Вот.
От partial и co
мы требуем equal и not equal.
Ну, not equal, соответственно, имплементируется
как not equal на внутри
дополнительную имплементацию.
И этот trait одновременно
он перегружает оператора
равно и неравно. То есть,
если вы его имплементируете, вам не нужно писать там
x equal y, хотя вы можете
через точку.
Вы можете написать x равенство y.
Вот. То есть, это способ перегрузки
оператора в RASP. Более того,
по-моему, дальше имплементация есть.
Да.
Ну, правильно. Как работает?
Сейчас.
Как macros работает?
Он для self просто лексиграфически сравнивает
вот поля, как ты их
объявил. Он также просто поля,
при условии, что они partial equal
имплементируют, будет имплементировать.
Вот.
Давайте, ну, понятно,
если в partial equal нам
не нужно, чтобы
правая часть была другим типом.
Что если мы хотим,
чтобы справа был какой-нибудь другой тип?
Давайте попробуем что-нибудь имплементировать.
Ну, для начала давайте попробуем,
когда у нас правый тип совпадает.
Вот у нас есть какая-то структура a,
у нее есть x, который
i32.
Вот. И я имплементирую ручками
partial equal для a.
Это, кстати говоря, ровно то, что сделает
derived partial equal.
Вот. Внутри там вот я имплементирую
equal.
И, соответственно,
я говорю, что self x equal
other x.
Можно, если что, написать просто равенство.
Здесь. То есть, self x равняется
other x. Я просто
написал полностью, чтобы вам
было понятно, что это и эта запись.
По сути, равенство — это просто
синтоксический сахар.
Вот.
Так.
Ну, а теперь давайте сделаем
так.
Это одно и то ли?
А, да, это просто
более подробное чуть-чуть. Я скопировал.
Вот этот слайд
лучше удалить и вот этот вот оставить.
Да, я просто
Вот.
Вот. И теперь давайте сделаем
back.
У него, смотрите, я сделал
derived partial equal. То есть,
то, что произойдет, у меня появится
какая-то имплементация partial equal,
которая сравнивает x.
А теперь давайте сделаем так,
чтобы у меня partial equal
имплементировался для
b при условии,
что правая часть — это a.
Вот. Я сделал так.
Я сделал partial equal a fo b.
У нас fn equal есть какой-то.
Потом мы сравниваем
на равенство.
А, мы видим, что у нас получается
не generic имплементация, а generic
trade.
Да, да. Ну, когда будет смотреть
на правую часть, то он вызовет
определенную имплементацию
partial equal, у которой правая
часть определенная.
Вот.
А до этого у нас не было generic?
Ну, в плане не было.
Да, у нас здесь не было generic,
потому что, смотри, у нас есть
требование, что RHS
это self. Ну, просто мы сказали default
на RHS это self.
Да, и соответственно мы его здесь не
написали.
Вот. А вот здесь мы уже хотим, чтобы
мы могли сравнить
b равняется a.
Так?
Ну, теперь давайте
задефиниваем структуру и
trade.
Всякие, да.
Ну, структуру эти
стационизируем.
Вот.
Я создал a1 и a2. Это какие-то
x42 и x43.
Мне пройдет сравнение на неравенство,
потому что я имплементировал partial equal.
А теперь я создаю b.
b, где x равняется
42. И, смотрите, я b
сравнил с a1.
И все коллектно прошло и скажет, что это
будет true.
Вот если я пробую a1 сравнить с b, то уже не
получится, потому что у a1
не имплементирован partial equal
для b справа.
То есть это уже нужно для a
имплементировать.
А, ну, в плане переставка,
да?
Не, вообще там есть
требования некоторые, чтобы оно
равнялось.
То есть вы формально можете так сделать,
но не формально, раз-то он
тоже формально, раз-то он говорит
документации, что если вы будете использовать
стандартную библиотеку, то у вас есть некоторые требования
на имплитацию partial equal.
У нас как в списках, что концепты можно
подсыпать интокрически, а можно
наделировать магически. Если ты наделиваешь концепты,
то это и помедляем.
Давайте досмотрим partial equal,
наверное, и пойдем на перерывчик.
Что, вот это?
Ну, говоришь,
импл partial equal
b for a,
и у тебя все получилось.
Нет, раз-то
он только в одну часть.
Так, это
последний стандарт?
Ну, не всегда,
иногда ты хочешь по-разному сравнить.
Ну, в общем, как есть,
раз-ли будет явно.
Если реализовать
некорректно, то точно
так же, как мы говорили со структурами
на прошлой реакции.
В общем, у нас не будет
на варианте fc undefined behavior, но у нас может быть
некорректное поведение
нашего кода. Ну, в плане,
что он может некорректно отработать,
просто логическая ошибка будет какая-то.
Оборты, паники и так далее.
Но undefined behavior в варианте fc не будет,
то есть у нас код не взорвется,
не разломает на них.
То, что мы требуем от partial equal,
это a не равно b, например,
тогда и только тогда, когда
не a равняется b.
Ну, это если вы хотите, что у вас
корректно работала имплементация,
то это нужно требовать.
Потом симметричность. Если у вас есть
в обе стороны сравнение, то в таком случае
a равняется b, если b равняется a.
Ну, b равняется a,
если a равняется b.
То есть из одного следует другого.
Одного следует другое, да.
Ну, если мы умеем
сравнить a с b, b с c там,
ну, то есть подряд,
то в таком случае, если a равняется b
и b равняется c, тогда мы должны
иметь a равняется c.
Теперь очень важный вопрос.
У нас все это время
мы смотрели название partial equal.
Partial equal.
Как бы частичное равенство, да.
Как оно там математически называется,
я уже подзабыл.
А почему нам в это вообще нужно вразиться?
Не, это нужно с точки зрения
математики ответить на этот вопрос.
А почему у нас не просто equal?
Просто вот trade equal
равно и не равно.
У нас есть trade equal.
Что?
Эти дополнительные требования
потом появляются,
когда уже дальше идем по иерархии.
Ну, вот мы сейчас как раз на этот вопрос
идем. Да, вот отношение календ
сейчас мы с ними разберемся.
Почему нам нужен partial equal?
В том случае,
вот я говорю вам, сейчас мы будем смотреть еще
на equal, почему если у нас есть equal,
то есть еще и partial equal.
На каком моменте мы свернули на туда?
Ну, короче,
вспомните про float, например.
А помните, у них есть специальное значение,
наны там всякие.
Ну, как сравнивать наны с обычными float?
Нет, почему?
Ну, интервалы тебе нужно, чтобы
один приезжал в интервале другого.
А в сравнении уже вроде
работает не интервально,
а прям по дикталу.
Ну, в общем, мы требуем вот equal, partial equal.
Да, у нас есть проблема в том,
что нан не равен никому, в частности,
он не равен сам себе.
Поэтому у нас
выполнено частичное равенство, но не equal.
И это в каком-то плане
удобно, потому что если вы попробуете
посортить float,
то не на всех данных
у вас будет корректная сортировка,
например.
Ну, потому что у вас наны не сравниваются.
Вот будет там нам,
и он сломает сортировку.
Поэтому раз требует
в сортировках для типов,
что они должны быть кмп.
Мы чуть позже посмотрим. То есть это прям уже
полный порядок на типах,
чтобы можно было их сортировать.
А вот на нанах
имплементирована только partial кмп.
Мы их можем только частично сравнить,
не все. И если вы хотите
сравнить их,
ну, то есть посортить float,
то вам нужно явно сделать
компаратор, в котором будет написано,
что вы делаете partial equal и делаете
unwrap.
То есть обратите внимание, что вот здесь мы
возвращаем, а не здесь
bool возвращаем точно, и потом
это кмп будет.
Там нужно будет делать unwrap и
чтобы явно показать, что
мы запаникуем, если у нас там будут
какие-нибудь наны и несравнимые типы.
Примерно понятно?
А, если
на названии стекла было будет,
будет ли это
booger?
Нет, если ты сравнишь
два float на нан, то они будут
нан с наном float,
тогда ты получишь false.
То есть
не true, несмотря на то, что это два нана.
Потому что некорректно сравнивать между собой
на на number.
Вот это то, что я сказал,
это хорошо
для абстракции на алгоритмах
всяких.
То есть алгоритмы
порой им не хватает всяких
partial equal, например, и им нужно
более сильные условия.
Если вы любите математику алгоритма,
то, наверное, вы порадуетесь этому свойству,
потому что вам
не нужно предусматривать что-то
от пользователя или требовать что-то неявное
от пользователя, как в плюсах.
Вот так вот.
Кажется, дальше Нику.
Ну что, пойдем на перерыв?
Вот, смотрите, у нас есть такой вот
trait, который я назвал важно
в кавычках маркерным, потому что
он, с точки зрения компилятора, не является.
Копи что-то менял в компиляторе.
Есть еще send и sync, которые что-то
меняют в том, как типа можно
пользоваться
именно на уровне компиляции.
Equal я называю маркерным
только в кавычках, потому что он
ну, формально
он что-то маркирует, но при этом
для компилятора ничего не говорит.
Вот, специально.
У него есть derived equal macro,
который просто имплементирует
Нику автоматически.
Самое главное, что он дает,
это то, что у нас a теперь обязательно
равняется a.
Вот и все.
В каком смысле тут равняется?
Ну, например, что
none не равно none на случай флотов.
А здесь у нас обязательно равенство,
соответственно, флот сюда не подходит, а какое-нибудь число
уже подходит.
То есть у нас есть полноценное равенство,
можем сравнить.
Сейчас, почему еще раз флот сюда подходит?
None не равно none.
А, то есть это
именно во всех
значениях?
Ну, none никому не равен
вообще. Даже себя.
И, соответственно, получается,
что мы не подходим под
частичное равенство,
определение математическое.
Поэтому у нас есть equal для этого отдельно,
который требует отдельной рефлексивности.
Ну, это означает,
вот обратите внимание,
вот у меня есть теперь возможность
отделять. У нас вот есть
partial equal.
Мы требуем имплементации
partial equal. Сами в equal
ничего абсолютно не добавляем.
Единственное, что
это говорит,
то, что наша имплементация partial equal
еще и рефлексивна.
И все получается.
В каком-то смысле, опять же, в кавычках
он маркерный.
Только в кавычках.
Вот.
Давайте теперь поговорим про такую стуку
перед тем, как перейти к сравнению
про ordering. Это такой специальный
enum. В плюсах у нас
для этого используется минус 1, 0 и 1.
Ну, точно так же, как FC. Просто числа.
В Rust у нас есть
enum, у которого есть
less, equal и greater значения.
У него есть немножко
функций. Это is equal, is not equal,
is less than equal,
lt это, по-моему,
строго меньше.
Зачем такие маленькие названия?
Ну,
equal и not equal понятно,
lt мне тоже не нравится,
но is less или less or equal
это, наверное,
less еще нормально, а less or equal уже как-то
длинно.
На сме писали, прибудьте,
я покажу.
Ну, в общем, как есть.
Наверное, название здесь
нравится не так
сильно, как хотелось бы.
Но это, на самом деле,
в общих чертах Rust очень хорошее
название.
Zen это, смотри, у тебя есть
ordering. Это такая
штука, которая, если у тебя
твой текущий ordering
equal, то тогда он возвращает второй.
Понял?
Так, смотри, у тебя есть 2 ordering
a и b. Если ты пишешь
a, then b,
то в таком случае, если у тебя a
это equal, то тогда вернется b, иначе
вернется a. То есть точно так же,
как ты в графическом порядке сравнишь.
Если у тебя раньше, то ты идешь дальше.
Нет.
Я считаю, что красота нужна
очень, ну, как
в принципе, как один шаг
в графическом сравнении.
Что такое ordering?
Это мощная функция?
ZenVif это просто то же самое, но с функцией.
Функция только что?
Да.
Но она берет, ну, не то же самое
но с функцией, она берет наш текущий ordering,
что-то с ним делает, возвращает ordering.
Ну, там есть...
Что еще?
Да.
Наверное, вам по названию тоже понятно,
greater превратит в less, и наоборот equal
сам себя перейдет.
ZenVif?
Да.
Берет текущий ordering,
применяет к нему функцию f.
Функция f возвращает ordering.
А просто Zen?
А просто Zen это
лексиграфическое сравнение.
Если self это equal,
то это equal возвращает other,
иначе возвращает self.
Ну, там есть еще
какие-то функции, кроме equal,
not equal, там есть greater, less,
ну, в общем, штук 6 примерно
еще какие-то есть.
А и b?
Так, a и b это просто абстрактные
какие-то вещи,
когда я говорил, ну, то есть a, d и b.
a и b это какие-то ordering.
Здесь вот den не a, это self, а b это other.
Я просто назвал a и b,
для того, чтобы попроще было.
В плане...
Просто параметры Zen, а и b,
как сколько?
Нет, den это функция yinamo.
Соответственно, если ты от yinamo вызовешь
then, тогда получится...
Then, тогда ты внутри пишешь
какой-то ordering, и возвращается ordering.
В общем, подразберись, ты, наверное, запутался
в том, как функции возвращаются,
как работает функция
в имплахах.
Ну, это просто импл-ордеринг.
Это то, что находится в импл-ордеринг.
Соответственно, если у вас есть a,
какой-то ordering, тогда вы можете вызвать
a из equal.
Вы можете вызвать a, den.
Так, давайте поговорим
про partial-ord теперь.
Обратите внимание, что partial-ord
в partial-kmp-свм возвращает
option-ordering.
Почему? Потому что у нас какие-то числа
могут быть несравнимые.
У него есть derived-macro, соответственно.
Точно так же
вот здесь у нас возникает
vers-not...
Ну, не обязательно size-типа.
RHS. То есть, опять же, можем
сравнить всякие слайсы.
Вот. И, в общем-то,
наверное, это все,
что нужно знать на этом слайде.
Примерно понятно, как объявлен этот trait.
Сортировки требуют partial-ord?
Нет, сортировки требуют ord.
Прямо линейный порядок.
Это мы сейчас посмотрим еще.
Ну, partial-ord, смотрите,
еще от partial-equal уходит.
То есть, наследуется
от partial-equal, грубо говоря, супертрейд.
И, соответственно,
у нас еще равенство есть
у объекта, который имплементирует
partial-ord.
То есть, если вы можете сравнить объект,
то в таком случае вы можете его сравнить
чисто-логически на равенство.
Так?
Ну, это то, что мы требуем, да?
Это уже такая формальная, более-менее, математика.
Если a равно b
только тогда, когда у нас
partial-qmp возвращается
some-equal. То есть, тогда и только тогда.
То же самое с a меньше b
и a больше b.
Заметьте, в скобчиках написал
ensured by default implementation.
Это из документации.
Это означает то, что derive
вам обещает, что это условие
обязательно будет выполнено, если вы
сделаете derive.
Оно не может быть неимплементировано.
Да, что?
partial-cmb
это что? Это аналог меньше?
Это сравнение.
Он возвращает ordering.
Он возвращает less, equal, or greater.
Причем общий.
А почему?
У нас ordering,
напоминаю, вот такая вот штука.
Ордеринг less, equal, greater.
Мы возвращаем общий ordering.
Так.
Ну и, соответственно,
а меньше либо равно,
ну и так далее.
С равенством, default implementation
не может вам гарантировать,
потому что вам нужно для начала имплементировать partial.
Логично, да?
Вы можете его имплементировать руками неправильно.
Но, тем не менее, если даже
неправильно имплементировать руками,
все остальное default implementation вам правильно выведет.
Ну, конечно, при условии, что
у вас равенство корректно.
В общем, следите за тем, чтобы у вас правильно
все, правильно работали такие вещи.
Иначе
у вас может, раз код работает,
просто логически некорректно.
Ну, логическая ошибка, это логическая ошибка,
вы никак не избавитесь.
Сейфти, тем не менее, остается у вас всегда,
даже если вы неправильное сравнение делаете.
Так.
Теперь ORD.
Заметьте, ORD требует equal
плюс partial ORD.
Так.
То есть у нас partial ORD
требовал partial equal
плюс какие-то дополнительные функции.
А теперь, если мы еще говорим, что у нас
equality корректная,
то в таком случае у нас есть полноценный KMP.
У нас, с точки зрения математики,
мы можем прям возвращать ordering,
потому что мы уверены в том, что у нас все объекты сравнимы.
Плюс ко всему, раз что они все сравнимы,
то в таком случае у нас есть, ну, у нас же loom,
получается, да? Мы от логику вспоминаем.
Вот. У нас есть minimum,
maximum и clamp.
Еще как дополнительная функция.
Они имплементируются дефолтно?
Ну, то есть если ты не входишь, уберешь minimum,
уберешь maximum. Если ты не входишь в этот диапазон,
тогда он, соответственно, к нему подвинет.
Либо ставит том, как он есть.
Ну, и вот, соответственно,
некоторые условия.
Наверное, первая нам не особо
интересна.
Точно так же у нас дефолтная имплементация
все гарантирует.
При условии, конечно, чтобы
equal и partial.lord корректно
имплементировали.
Ну, дефолтная имплементация, еще раз напоминаю,
это macros.
Который мы пишем dirifort.
Max.buy
помнишь, мы говорили
на второй лекции,
что у нас, например, есть
sort,
есть sort.buy метод.
Что мы можем ordering какой-то
добавить. Здесь kmpeg
это какая-то функция сравнения.
То есть наш max
работает точно так же, как kmpeg.
То есть это в точности
означает то, что у нас
ort и partial.ort относительно
друг друга консистентно работают.
Здесь это написано.
То есть они согласованы.
Я думаю, что если что,
вы дома разберетесь с этим.
Просто это математика, если что,
можете вспомнить на википедии
определение.
В принципе, там понятно
частичный порядок и полный порядок
как работают.
Еще есть такая специальная структурка
называется reverse.
Смотрите, как я объявляю
забавную структурку. Я пишу reverseT
и после этого не фигурные скобочки, а внутри
какой-то публичный тип T.
То есть я объявляю
по сути, наша структура
reverse
является
тюплом,
которого первое
поле
это наш T.
Чем нам
reverse полезен, это тем, что
например, мы хотим вектор отсортировать
в обратном порядке. Причем не только
в обратном порядке, но еще и
при условии, что у нас
с самого начала все элементы, которые меньше
трех, а потом все элементы, которые больше трех.
Смотрите, какой у меня такой
хитрый компаратор.
Подождите, можете пояснить
синтаксиз структуры?
Я надеюсь, сейчас не отрубится.
Вроде бы
запись работает.
Так, какой синтаксиз?
Смотри, это называется new type,
чтобы не соврать, мы следующий слайд
буквально. Пока что просто поверьте,
что это структурка, которой мы один.
Это не то, что вы должны знать.
Это не то, что вы должны знать.
Этот синтаксиз
мы сейчас обсудим.
Давайте посмотрим лучше на примеры
использования.
Реверс
делает реверс ордеринг. У него
имплементирован орд,
причем имплементирован так, что
он делает внутри реверс.
То есть вместо less он будет возвращать greater,
вместо greater less.
Это удобно такой в раппер,
когда сортирую,
сначала сортирую больше трех,
чтобы было видно.
Здесь все элементы меньше, тройки
получаются, здесь все больше тройки.
Это тюпл.
Второе это reverse нам.
Соответственно, у меня внутри
отрезка будет реверсный порядок.
Если бы вместо этого тюпла
просто написал reverse нам, то у меня
получилось от 6 до 1 массивчик.
Это бывает удобно.
Просто вернуть что-то в реверс
и все хорошо, красиво работает.
Это зерокост abstraction.
Так что вы можете в любую позицию.
Без вреда
производительности.
Примерным понятием пример.
Какое замыкание?
Sort by key возвращает ключ
сортировки.
В данном случае он возвращает
пару из була и
реверс.
Где-то это и 32.
Реверс и 32.
Теперь делаем new type.
Посмотрели?
Это не совсем понятное объявление.
Это на самом деле бывает удобно.
Это какая-то функциональщина.
Смотрите, у нас есть структурка
years, которая
I64 себя представляет.
На самом деле тип.
И структурка days, которая I64
представляет.
По сути я структурку объявляю как
какой-то новый тип.
Я просто приименовываю тип I64,
но при этом стираю все, что я знаю
об I64.
Смотрите, я сделал импл для years.
И теперь я, когда
делаю todays, то в таком случае
я создаю структурку days,
которые... Вот видите, опять же, как tuple
обращаюсь. Здесь можно через запятую
объявить несколько типов.
То есть точно так же, как помните, мы в
янамчике на первой лекции, там тоже в скобочках
что-то могли написать через запятую.
А с теплами
.0.1 только работает?
С теплами только .0.1
работает. Ты не можешь
писать в квадратных скобочках.
Ну, знаешь, в плюсах
еще хуже с гетом.
Да, да.
Ты такие вещи
просто в гет не говори.
Все там хорошо.
Так.
Значит, у нас здесь
видите
умножение на 365.
Получается, что years
перевели в days.
И потом мы можем days, например,
tu years сделать и поделить на 365,
поделить на 365, получить
целое число дней. Смотрите,
здесь зависит такая структура к example, в которой я
даже generic объявил.
У нас и 32, и 64, и какой-то
t, и это все будет такой
tuple на самом деле.
А модификатор public
в этом списке что делал?
public давай мы это обсудим на следующей лекции.
Ну, по сути, давай
опять же я очень упрощенную
модель мира сделаю, скажу, что
pub говорит о том, что это доступно
не только внутри этого файла, но и внутри других.
Это не до конца, правда?
Там модули.
Обсудим это на следующей лекции.
Ну, в плюсах там
просто, если заимпортировал, там
private-public элементарно работает.
И, кстати говоря, еще в
расте, вот почему-то во многих чатах
видел,
что люди для себя открывали,
что доступность имени типа это разные вещи
в плюсах.
В том числе в чате
concurrency это было.
Это было еще в чате второго
курса плюсов.
Текущего, кажется, второго типа.
Там есть чат по плюсам,
просто уже плюсы прошли. Я видел, что там
люди тоже для себя открывали такую новую вещь.
В расте у вас так не получится.
Он обратит внимание на то, что вы приватную
структурку, которая
недоступна этому коду.
Выкидывайте и скажете,
что сделайте ее публично, если вы хотите
ее вернуть. Причем он это сделает
до того, как вы попробуете вообще
этой функции воспользоваться. Скажет, что вы возвращаете
что-то с
более узкой области
видимости.
Поэтому и у пап удобен.
Потом мы об этом поговорим.
Про Newtype еще что-нибудь поговорить?
С ним все понятно?
Это удобно.
Обстрагировал years, days,
потом, например, в стандартной библиотеке
для time есть duration.
Такая штука.
Там все просто удобно.
Такие имплы есть.
Всякие перегруженные плюсы для
правой и левой части.
Это такой функциональный стиль
достаточно.
И позволяет, например,
если в случае плюсов,
если бы вы записали
например, int64t,
то у вас бы все работало,
то в Rust за счет Newtype у вас все
будет прекрасно.
У вас там будет прям отдельная
структурка, которая будет прям называться
так, как вам хочется.
Вот. Смотрите.
Еще в Rust можно хэшировать объекты.
TradeHasher выглядит вот так.
Ну, хэшировать объекты
мы сначала начнем, конечно,
с
того, что
само по себе хэшируют.
То есть вы же понимаете,
что у нас бывают разные
типы хэшей. Разные алгоритмы
хэширования.
Да.
На Hasher и Hashable по сути разбивают.
Давайте сначала посмотрим на Hasher.
Hasher это такая штука, которая
умеет, во-первых,
писать какие-то произвольные байты.
Это самая главная функция.
Она берет какой-то слайс байтов и
пишет их.
И есть структурка Finish,
которая, собственно, возвращает
U64 результат хэширования.
Возможно, если вы
помните о COS, у вас был
OpenSSL. Вы тоже, когда хэшировали,
вы записывали частями
по байтову, да?
Все это кусочками, там, какими-то слайсами
байтов. Здесь то же самое. Здесь также
абстрагировано. Вы можете хэшировать
произвольные наборы байтов. За счет этого
Hasher потенциально может работать
с любым типом.
Закисывать куда-нибудь?
Или куда записывать?
Ты
отрабатывал когда-нибудь с OpenSSL
например?
У кого-то
у кого-то у вас закончился второй
субъект РАКОСА?
У всех.
У всех.
Возможно, там
должна была быть
подача на OpenSSL, если первым один еще не убрал.
Там же как-то она была.
Было прикольно.
Просто смотри, нам плохо, если у нас
Hasher будет специализироваться для каждого
отдельного типа. Например, там
для E-size, для U-size
отдельно. Мы хотим просто, чтобы наш Hasher
имел какой-то абстрактный
алгоритм, который хэширует произвольные
байты.
И после этого мы можем и U8
тип
захэшировать просто слайс из одного байта
отправив. И U64,
и слайс строковый, и что хочешь.
Просто произвольные наборы байтов.
То есть Hasher это такая штука, которая
хэширует, по сути, произвольные наборы байтов.
И она тогда действует?
Ну, у нее
есть какой-то стрейт? Ну, у этого трейта, да,
есть какой-то, ну, у самого трейта
нет, но у той структуры, которая имплеметирует Hasher
должен быть какой-то стейт, который
она будет содержать внутри себя.
Точно так, то, что должно быть, следует
изновищим функциям финиш, который, если не хочет
разрешить константов,
например.
Что еще раз?
И это просто какой-то
набор байтов, которые ты хочешь
захэшировать.
Например, если ты делаешь write U32,
все, что, по сути, внутри происходит, это вызов
write со слайсом
из четырех байтов.
Да.
Ну, просто для удобства
вашего, чтобы могли просто запихнуть
там то, что вам удобнее.
Ну, там есть еще какие-то имплементации,
я там все не выписывал, просто показал
какие-то из них.
А нельзя оставить просто,
типа, вот write и разные
типы, оно не будет, как вот,
переопределять функции нельзя
в write, правильно?
Да, переопределять нельзя.
И типа, чтобы оно само определило.
Да, перегрузок функций не отразится.
Смотрите, вот давайте
попробуем использовать хэшер из
hashMap'а. Он чуть-чуть
запрятан, поэтому нам придется его достать
таким образом. U-System Decollections hashMap
default-hash.
Вот, это тот самый медленный хэшер,
который нам замедляет хэштабличку.
Тем не менее, который
дает мало коллизий.
Создаем
дефолтный хэшер, и смотрите, я и U32
записал, и U8,
и еще один U8, да, хэшер
с несколькими записями.
Потом еще, смотрите,
я об этом не рассказывал, можно литералы
делать, строковые, байтовые.
Если вы дописываете B перед
строковым литералом, то это означает, что
компилятор будет
на это смотреть, как на слайс U8,
а не на слайс строки.
То есть, по сути, приведет просто время
компиляции.
Ну что-то.
Я не понимаю, что делать в Write,
в Write от строки
он что делает?
Как он?
В Write от строки он берет байты,
ну, получается, что там 4 байта
внутри строчки,
и он вызовет в Write
от 4-х байтового слайса.
Ну, а сам Write уже как-то прожевывает
эти байты.
Сам Write там зависит
от алгоритма хэширования, там, например,
может боксорить все байты, ну, чисто для примера.
А статистически он
должен получить хэш по этой игре,
или что?
Он должен дописать
байты. Ну, представь, что у тебя в итоге
это то же самое,
что если бы я, например, в самом начале
дал 4 байта, потом еще один байт,
потом еще один байт, потом еще 4 байта,
то этот вот кусок, если бы я сразу в Write записал,
было бы то же самое.
То есть, по сути, в случае, когда мы хэшируем данные,
они не помещаются в память разом
или по недоступным разом, поэтому мы их вот так
давайте я проговорю, чтобы
это, наверное, Андрея не слышно.
Просто потому, что эта память
не всегда вмещается, поэтому
нам удобно
иметь именно такой дизайн
трейд хэш.
Вот. Ну, если вы
выведете, получится вот какой-то
вот такой вот хэш.
Ну, вроде да.
Я вроде раз background запускал,
получался такой хэш.
Ну, я не гарантирую, что он потом
не изменится, конечно.
На момент создания лекции
было так.
Для Write есть какие-то требования
на гарантии?
Требования гарантии, что
неважно,
какими кусками ты подавал отсутствие байтов.
Ну да, если
в самом начале, ну, если
у 32 подавать по 1 байту,
то все равно все получится.
Еще, кстати говоря, хэшер в Rust
гарантирует, что от запуска к запуску будет
один и тот же хэш.
Но он гарантирует то, что внутри одного запуска
одни и те же типы будут
гарантировать, ну,
давать один и тот же хэш. Ну, это сделано просто
с точки зрения безопасности.
Вам такое
требование зачастую не надо просто,
чтобы у вас хэш постоянно давал свою
знаку.
Ну, это как обзор,
в котором, наверное, хэш там
объедется, там хэш сидится
так.
Так.
Теперь у нас есть трейд-хэш.
Это, собственно,
объекты, которые мы можем хэшировать.
Ну, то, что хэш был.
Только называется оно хэш.
Вот.
Для начала у нас есть вот такая вот штука.
Это функция хэш,
которая принимает какой-то стейт.
Стейт это, собственно, и есть сам
хэшер.
Если вы хотите что-то захэшировать,
тогда вы передаете
стейт, ну, то есть сам хэшер,
и записываете у него и делаете
final,
чтобы получить результат.
Вот.
Ну, точнее, final вы не делаете,
просто
запись происходит.
Кстати, а вот тут по синтезу мы не могли
не писать,
где h это хэшер,
а написать в...
Ну, вот.
Мы могли hash,
двоеточие хэша написать.
Вот.
Ну, есть еще hash slice,
который позволяет slice таких объектов
хэшировать.
Ну,
он имплементируется через hash просто тем,
что мы имплементируемся по slice.
Смотрите, по всему кому-то было очень удобно,
он добавил эту функцию до форта.
Давайте попробуем имплементировать
hash
ручками.
Смотрите.
Берем person,
в person быть стадийшник,
имя и какой-то номер мобильного.
Смотрите, что я делаю.
Как раз h-hash у меня, кстати, написано.
Как раз ответ на вопрос,
можно так делать?
Ну, и что я делаю?
Я просто хэширую сначала ID, а потом фолл.
Обратите внимание, на имя я не хэширую.
Я могу так сделать,
никто не запрещает, это у меня
хэш игнорирует просто имя.
А как возвращать?
А, возвращать как раз.
Чтобы вернуть сам результат хэширования,
нужно в стейд постучаться уже.
Попросить стейд, пожалуйста, верни мне.
Сделаю финиш.
Вот.
Когда вы имплементируете
одновременно и hash, и equal,
очень-очень важный момент вам
нужно предусмотреть, что если у вас 2 ключа равны,
то у вас hash и равный.
Значит, это бред, конечно.
Что? Звучит как бред?
Ну да, это будет...
Соответственно получается hash не hash,
если у нас будет не равенство,
но вам обязательно нужно это...
Обязательно это нужно учесть,
в том числе hash map и hash set,
они на это полагаются.
Так.
Потом у нас есть дроп.
Дроп мы уже видели.
Обратите внимание.
Очень важно, у вас дроп
не принимает здесь self.
У вас принимает drop mute self.
Потому что дроп
это просто такая фигня,
которая вызывается компилятором.
То есть вы не видите
явно этих вызовов,
но когда у вас переменная drop,
у вас вызывается функция drop перед этим.
Ну и она там что-то делает,
а потом же компилятор
только делалакцирует поля.
Еще, кстати говоря,
был, кажется, на второй лекции
вопрос про то, когда же переменная
дропается, как это все работает.
Кажется, наверное,
мне не получилось адекватно этот вопрос ответить.
Тут есть ссылочка
на REST Reference, как оно прямо подробно
работает. Там вообще никакой
магии нет, там все просто.
Но правила есть.
Много правил, в общем, есть.
Вкратце, просто
если у вас овнер выходит из
скопа, то есть его нужно
дропнуть владельцем.
Если у вас переменная вышла из скопа,
тогда то, чем владеет переменная,
нужно дропнуть. Собственно, ровно это и происходит.
Ну и там специфицируется, когда
drop вызывается, все такое.
Я думаю, вы ничего неожиданного не найдете,
но если вам интересно подробно,
можете почитать.
Да.
Так, давайте мы
drop by hand
имплементируем.
Сначала просто какую-то структуру
hasDrop, которая будет нам принять, что
ее дропают.
Ну и давайте hasToDrops.
Сделали какую-то
структуру hasToDrops, у которой есть
drop,
который принять, что
мы hasToDrops дропаем.
Ну и соответственно, если мы это
запустим,
вот так вот, тогда сначала у нас создастся
hasToDrops.
Потом у нас будет running.
Ну и если, соответственно, у нас
запустится running, вызывается running, потом
мы выйдем из копы и мы начнем drop
hasToDrops. Сначала вызовется hasToDrops,
потом вызовется
hasDrop, вызовется hasDrop
от 1, а потом от 2.
Вот так вот это работает.
Ну тут все очень просто,
1, 2, это hasDrop, hasDrop.
Какие-то поля.
Ну да.
Да.
Еще есть
бывает такое, что вам хочется, чтобы
drop не вызывался компилятором
автоматически.
Вот. Для этого есть такая
структурка, называется manualDrop.
Она такая для компилятора
особенная. Компилятор знает, что
то, что обернуто в эту
структурку, в общем, от этой структурки
не нужно вызывать drop.
От нее нужно вызывать только руками.
Можно только руками.
Вот.
Ну, вы можете создать с произвольным значением
tag на тремене или drop,
потом intoInner,
там всякие.
Еще обратите внимание, тут есть unsaved
функции take и drop.
Вот.
Ну,
это сделана структурка,
во-первых, для того, чтобы это было очевидно
для пользователя, то, что в этой структурке
не вызывается drop.
Во-вторых, так как
вы руками
управляете manualDrop,
вам никто не мешает вызвать drop,
а потом сделать take.
И тогда бы было memory unsaved.
Поэтому эти две функции
unsaved.
Вот у нас есть поле
в структуре, который manualDrop.
Когда структуру
уничтожается, она не уничтожает, ведь
это поле.
Well, manualDrop у нас
особенный просто. Раз знать, что
не нужно вызывать на нем drop.
У него особенного поведения.
Ну, просто мы таким образом не получим
утечку памяти?
Ну, у нас есть структура,
у нее есть поле, которое manualDrop.
Ну, поле имеет такое, да.
Нет, ну, утечку памяти ты можешь получить.
Утечка памяти — это save,
как я говорил на прошлый лет.
Да, раст — это
считает save. Ну, это правда,
потому что утечка памяти — это просто
плохо, но это не ломает
код.
А что в целом будет происходить в такой ситуации?
Дропнутся все поля, кроме manualDrop.
manualDrop не будет
вызываться.
Да, нужно реализовать самому, писать
ручками, это все.
Если manualDrop
мне нужно там написать,
что я unsaved.
Что еще раз? Если я использую manualDrop?
manualDrop использует unsaved
функцию.
Как этим воспользоваться, Миша?
Ну, тебе, чтобы воспользоваться unsaved функцией,
нужен блок unsaved. Ты пишешь unsaved,
и там фигуристые скобочки.
Я вам просто для примера показываю, что здесь вот
так как это небезопасно,
это отмечено unsaved.
Если вы unsaved сильно не знакомы,
вам manualDrop нигде не понадобится.
Пока что.
Поэтому не пугайтесь.
Вам это
просто для справочки, что в расте
можно и руками вызывать дроп
без компилятора.
Есть еще trade at.
Это способ имплементировать
плюс.
Ну и смотрите, здесь
вот у нас уже есть ассоциированный тип.
В итераторе у нас, помните, был
тоже item, и здесь у нас есть typeOutput.
И мы возвращаем в ад какой-то
selfOutput.
А, это та самая
штука, там где next
был?
Да-да, там next возвращал
общем на item, на selfItem.
Сейчас, а оно о чем говорит?
О том, что структура,
которая использует это, обязательно должна иметь
поле. Нет, она должна не иметь
поле, она должна сказать, что
typeOutput равняется чему-то.
То есть она должна специфицировать
какой типу output.
Сейчас, наверное, пример будет.
Да, будет как раз пример. В данном случае
я вот явно прописал, что output
равняется self.
Тип self.
Вот у нас есть структурка point, у которой
x и y это какие-то типы t.
И я
имплементирую для add
ну для point
trade add. Я указал, что output
это self, потом функция add
написал
достаточно банальным образом.
Кстати, обратите еще внимание,
что мне пришлось для того,
чтобы вот это вот работало. Раз же по умолчанию
ничего не требует от
типа, поэтому нам
нужно явно сказать, что t
это на самом деле add с output
равным t. То есть
именно то, что я здесь вот сделал.
Почему не тебе было просто
импл т сделать?
Импл т, потому что он бы тогда
сказал, почему это ты суммируешь,
при том, что у нас t не умеет
суммироваться.
Соответственно, еще есть такая add assign.
Это уже плюс равно.
Соответственно, берет
правую часть и записывает
какой-то результат лево.
Потом usage exam.
Ну тоже вот какой-то я пишу
результат. Я в self записываю
результат суммирования точно
такой же, как и до этого.
Вот.
Здесь оператор присваивает
к self присваивает значение
к self присваивает значение
point, где x это self x
присадр x и y это self y
присадр y.
Что еще раз?
Эту штуку тоже можно перегрузить, да?
Оператор равно нельзя.
Ровно не перегружается.
Так.
Конечно, в расе ее можно перегрузить
примерно любой такой рефинитический оператор.
А отца в мул, то есть там
сложение.
Он просто делает мулы.
Он просто делает мулы и копирует битики.
Муф нет.
Это ремайндер остаток
в делении.
Да, это shift left и shift right.
Вот, это всякие рефинитические
операторы. Соответственно, у них есть
assign варианты, типа bit or assign.
Такие вот варианты.
Еще есть
перегрузка операторов not и
negative. Ну, not понятно,
это
отрицание
логическое, а negative это просто минус.
То есть, не минус один, не минус два.
У них, конечно,
уже нет assign вариации, потому что это
все-таки унарные операторы.
Поэтому у них не может быть assign варианта.
Вот.
Ну, если что, почитайте.
Они там абсолютно точно так же устроены,
как и add. Просто там
перегружают другие операторы.
Тут понятно?
Так.
У нас есть индекс.
Индекс – это то, что перегружает
квадратные скобочки.
Причем в immutable
контекстах.
Сейчас посмотрим, что такое immutable
контекст. Вот, смотрите.
У нас стоит, который
индексируется каким-то типом
индекс. Ну, idx.
В случае всяких там
векторов idx – это
usize.
Плюс ко всему у нас, видите, idx
не обязательно что сайсит,
и output тоже не обязательно сайсит.
Интересно.
Потом у нас есть функция
индекс.
Собственно, когда вы пишете
контейнер индекс, как я сверху написал,
то если вы напишете
контейнер.индекс в скобочках индекс,
то в таком случае это будет то же самое,
что вызвать квадратные скобочки.
На самом деле в расти сети плюс равно
умножить и так далее – это все
просто синтактический сахар для трейтов,
в которых через точку вот это
вызывается.
Вот.
Индексу разрешено
паниковать, когда он выходит
за границы.
Ну, то есть если вы вышли за какие-то
условные границы, которые вы сами себе придумали,
то РАСТ вам разрешает паникуйте.
Это адекватное
поведение. В принципе, вы можете паниковать
где хотите, но просто в документации
местами в РАСТе написано, как лучше имплементировать,
чтобы
поведение было предсказуемым
для пользователей одинаково.
То есть в панике вот если
запаниковало все, это упало?
Ну, на самом деле нет.
Мы потом посмотрим на то,
как ловить панику. Там можно такие вещи
делать. Но это вообще нормальная практика
ловить панику? Не.
Паника – это unrecoverable
error. То есть, конечно,
так можно делать, но не надо.
Я вот не понимаю,
вообще он не знает вопроса size
вообще, но он сплоткует информацию
новую. Да, если бы ты не
написал, то тогда бы у тебя было требование,
что IDX – это size тип.
А так ты можешь в качестве IDX, например,
слайз засунуть.
Ну, и индекс возвращает
ссылку на опыт.
Давайте попробуем воспользоваться.
У нас есть какой-то янам нуклеотид,
то есть структурка нуклеотид count.
Ну, соответственно,
ACGT, я там не помню из биологии,
примерно так называются нуклеотиды.
Ну, и то же самое там
какие-то count.
Ну, давайте импенсируем
индекс для нуклеотид count.
Обратите внимание, что у меня
индекс принимает на обход нуклеотид.
То есть, я отдаю ему
в качестве типа, по которому
индексируюсь нуклеотид.
И после этого,
когда меня индексирует нуклеотидом,
принимаю наход
матчем.
Понимаю наход нуклеотид, матчусь по нему
и возвращаю соответствующий тип.
Ну, соответствующее число.
Понятно?
Ну, надеюсь, что понятно.
Так.
Теперь есть еще индекс mute.
Сейчас разберемся, в чем у меня отличается
mutable and mutable context.
У меня есть
примерчик.
Здесь, как вы можете заметить, разница в том,
что, во-первых, индекс mute требует реализации
индекс, потому что если вы не умеете
индексироваться, то к чему вам индекс mute?
Потом отличие в том, что у нас не просто индекс,
а индекс mute называется функция внутри.
И возвращаем ему табельную ссылочку.
А не просто ссылку на cellpal.
Давайте попробуем
разобраться с индекс индекс mute.
Сделаем какую-то структурку тест,
в которой внутри x.
Это усайс.
Потом сделаем имплементацию
для теста.
Вот.
Ну, принимаем наход усайс, и потом
просто возвращаем self x.
То есть, по сути, я ничего не делаю с индексом,
который мне выдали, а просто возвращаю текущий
x у теста.
И принчу, что я об индексе.
Понятно, как
имплементировано?
Мы возвращаем
с индекса.
Ну, просто на x у той некоторые
тесты. Я даже индекс,
по которому индексируюсь, просто игнорирую
в качестве примера.
Ну, и примерно то же самое
с индекс mute, только отличие в том, что
я возвращаю табельную ссылочку и вывожу
то, что в индекс mute.
Сейчас потресим, что же у нас будет
в каком случае выводиться, индекс или индекс mute.
Да, вот он.
Так.
Вот, у нас тест 1, это какой-то
x 42, и потом есть mute
тест 2, это x 42.
Ну, давайте вызовем тест 1.0.
И это, конечно же,
будет иммутабельный контекст,
потому что у нас переменная не мутабельная.
Соответственно, у нас вызовется
индекс.
Потом, если я вызову тест 2.0,
при своем значении нулю,
в таком случае это будет индекс mute.
Потому что мы мутируем.
Нам нужна мутабельная ссылка.
Раст это вывел. Если вы напишете
сверху просто тест 2.0,
то в таком случае, точка из битой,
то у вас вызовется просто индекс.
Потому что Раст понимает, что вы ничего не мутируете,
и вернуть
нужно просто индекс.
Иммутабельную ссылку.
Давайте возьму
ссылочку на
тест 2.x. И попробую
тест 2.0 при своем значении
единичку.
Еще раз, что?
У нас нарушение правил
владения.
У нас получается, что мы пытаемся
взять мутабельную ссылку, когда у нас есть
не мутабельную.
Потом вызовем тест 2.0
и
Раст выяснил, что нам нужен индекс.
Во-первых, потому что у нас есть
ссылка в R.
Во-вторых, потому что мы ничего не мутируем.
Вот.
Ну и, соответственно, если мы выведем R,
то мы получим ноль, потому что мы тест 2.0
при своем значении ноль.
Вот так вот.
Раст просто понимает из контекста, что вы хотите.
Иммутабельную ссылку или не мутабельную?
Смотри, у тебя есть
не мутабельная ссылка на тест 2.x.
А теперь ты пытаешься
на x внутри,
мутировать. Смотри, у тебя мутабельная
ссылка на x возвращается здесь.
Соответственно, ты по мутабельной ссылке x
пытаешься сейчас мутировать.
То есть, имеешь прямо сейчас не мутабельную
ссылку, ты пытаешься
мутировать переменно. Это нарушение правил
владения, потому что есть либо одна мутабельная ссылка, либо
сколько года много
не мутабельных.
Так.
Ну, с этим понятно.
Теперь давайте Read&Write.
Мы можем страгироваться, потому что
умеет писать либо читать.
Давайте посмотрим для начала на
TradeRead. У него есть
одна очень важная функция,
называется Read. Принимает
на вход какой-то slice
байтов, которые нужно записать.
Ну, которые нужно
прочитать и записать
бухер. Ну, и соответственно
возвращает сколько прочитали,
либо ошибку.
И всякие на основе этого Read
есть дефолтные имплементации.
Это какие-то примеры.
Читать мы можем для REST-файла,
или с TCP Stream,
с CDN, и даже
можем читать из всяких строковых слайсов,
векторов и так далее.
Ну, то есть,
рас в этом плане
хорошо абстрагирован, что мы можем
читать, даже в тестах написать
просто набор байтиков,
из которых мы хотим читать, и
REST будет...
читать из них.
Сейчас ReadBuff.
Ух, ну, это кажется
буфер просто какой-то.
Ну, я просто какие-то взял
функции, например, с документацией. Я, честно говоря,
не помню.
Ты имеешь в виду вот это вот...
Да, там
lifetime,
кажется, должен зависеть от Read.
Для этого нужно просто
вспомнить, почитать, что делает ReadBuff
в документации. Я его совсем не помню.
Вот, если ReadExide,
то ты либо прочитал, либо не прочитал
что-то из двух. Вот.
Так.
Теперь внёмся...
Ну, пойдём к TradeToWrite.
Write — это, соответственно,
то, что мы умеем читать,
соответственно, мы не можем читать
из всех этих строковых слайсов,
но мы можем читать из всех этих строковых
слайсов, соответственно, то, что мы умеем читать,
соответственно, тоже умеем из
File, TCP и так далее читать.
Здесь есть целых две функции важных.
Это Write, который
записывает из
какого-то буфера.
И Flush.
То есть мы ещё, возможно,
можем написать какие-то
буферизованные
записи.
Flush означает то, что мы
буфер прямо сейчас
делаем пустым.
То есть мы пустошаем.
Вот.
Понятно ли, почему
так Trade устроен?
Так.
WriteAll будет Write по кругу
вызывать, пока он всё не запишет
или пока на ошибку.
Ну, Flush вызывается...
Это зависит от структуры.
Просто мы можем сразу же писать те байты, которые нам дали,
а мы можем в структуре хранить
какой-то буфер.
Ну, Flush внутри
Write в WriteAll не вызывается.
Он существует только для структуры,
которая имплементирует Write.
Для пользователей.
Ты на ОКОСе помнишь, как
ты в TCP писал по кругу?
Так. Нужно вернуть
студентов.
Теперь давайте
BuffRead перейдём.
BuffRead это
буферизованное чтение.
Соответственно, мы можем
либо заполнить буфер
внутренний какой-то.
Во-первых, мы умеем читать точно так же, как мы до этого
читали. Во-вторых, у нас появляется дополнительная
функция для работы с буфером.
Заполнить буфер и
так, я не помню, что конкретно
делать консюм, если честно.
Я помню, что я читал, подзабыл.
Давайте, чтобы не соврать
и не буду вам точно говорить, что
делать консюм, но самое главное
FillBuff.
Он
заполняет наш внутренний буфер
в той структурке,
которая у нас буферизованное чтение
имплементирует.
У нас более того есть
BuffReader.
Она предназначена для того, чтобы
по умолчанию как-то буферизовывать
чтение. Она внутри
себя содержит буфер
какого-то размера. Я боюсь
соврать, возможно, 4-килобайтный.
Возможно, я вам конкретно
вру, так что лучше проверить
это в стандартной библиотеке. Ну, какого-то размера
буфер. Она принимает
в качестве типа T.
Эта структурка является
дженериком.
Какой-то тип, который мы
можем читать. И, соответственно,
когда мы пытаемся что-то прочитать
из него, тогда BuffReader
записывает это все
в свой буфер.
Вот как-то так.
Ну, если вам...
То есть, по сути, достаточно
имплементировать Read. Чтобы имплементировать
BuffRead, вы можете просто обернуть
в BuffRead то, что у вас Read.
Вот так вот.
Так.
BuffRead using BuffWrite.
Насколько я помню, здесь нет...
Вот это вот лишнее.
Это вот строчки.
Забудьте про нее. Не должно быть.
На самом деле, трейта BuffWrite нет, конечно же.
Но вопрос...
Почему там файл Open
или знак вопроса?
Ну, это треки.
Ну, местная навыка.
Open вообще отрезал.
Смотрел на...
Ну, ты либо успешно откроешь файл,
либо, например, его может не быть,
или не быть прав на чтение на него.
Если не будет, то что?
Это вернет какую-то ошибку.
В котором проект?
Их не ошибка.
Ну, в вопросе,
кто это делает, он просто
мачит либо OK файл,
либо error какая-то ошибка
и пропихивает ее дальше.
То есть этот код конкретно
не запаникует?
Нет, он не запаникует,
если у вас Logtxt есть.
А, и не надо проверять как раз
их...
Вопросик, это способ
error handling со второй лекции.
Вот.
Да, я подумал,
что это BuffWrite.
Просто думаю, BuffReader есть.
И по идее, должен называться BuffWriter,
а потом вспомнил, что есть BuffWrite.
Собственно, структурка.
А, не, BuffWriter.
Так как у нас
манипулировать буфером в случае
BuffWrite нет никакого смысла,
поэтому у нас нет трейта BuffWrite.
Просто нет в нем смысла,
и его, соответственно, добавили.
Если у вас бухфилизованное чтение существует,
вы можете и воспользоваться
в коме, например, в домашней издачке.
Вот, есть такие еще прекрасные трейты,
DisplayDebug.
Это, собственно, то, что перегружает
характер того, как мы форматируем строчки
в MacroCFormat
и в Println.
Вот.
Смотрите, у нас есть текст
HelloWorld, вот такой вот.
В случае Display мы выведем вот так вот.
Просто Hello, у нас n есть
World, соответственно.
А если мы имплементируем
Debug, то в таком случае,
если мы выведем Debug,
тогда у нас выведется строчка так, как она была бы в коде.
HelloWorld, так вот в кавычках
с
slash n.
То есть Display
это просто что-то вывести на экран,
а Debug — это Debug-вывод более подробный.
С каким-то, возможно, форматируем.
Вот.
Давайте посмотрим
сначала на Display.
Это
стока форматирования
для пустых
фигуристых скобочек.
Вот как вот здесь у нас есть.
Если вы пишете пустые скобочки,
то у вас вызывается Display.
Собственно, он принимает на вход
какой-то форматор, на который мы сейчас посмотрим.
Что-то с ним делает, и после этого
возвращает либо OK, то есть я все записал,
либо какую-то ошибку.
Для форматора есть еще
подробная документация.
Если захотите,
можете ее почитать.
Мы сейчас будем, кажется...
А, кажется, я подумал, наверное,
что... А, у меня форматор все-таки есть
в лекциях.
Так.
Давайте теперь посмотрим
на Debug Trade.
Это то, что появляется, когда вы пишете
двоеточие вопросиков.
У него есть даже Derive Debug
Macro. То есть Display вам нужно писать
самостоятельно, потому что Vras
не знает, как выводить типы.
Он абсолютно не понимает,
что значит за Display какой-то произвольный тип.
Но Debug он может
задисплеить. Он будет писать
например, в случае структуры,
название поля и какое значение у поля.
Вот.
Это достаточно удобно.
Это у вас лучший друг в случае Debug,
если вам нужно подробно вывести
какую-то структурку на экран.
Так, давайте попробуем,
как эти Trade с дизайном
посмотреть.
Обратите, во-первых, внимание, что мы можем вообще-то
выводить любой объект.
Мы сможем выводить в том числе всякие слайсы
результатов форматирования.
Но при этом у нас
нет никаких дженериков.
Давайте попробуем заранее ответить на вопрос.
Как же так получилось, что дженериков нет,
а выводим любой тип, который врать?
Мы уже знаем ответ на этот вопрос.
Вот.
Когда Formatr создается,
он там принимает на вход
произвольный тип, который врает.
Он не дженерик.
Он дженерик по какому-то lifetime,
но не дженерик по типу, который врает.
Да, да, да, давай, давай.
У нас есть точная ответственность для этого вопроса.
Как вы считаете,
Давай-давай, у нас есть точный ответ на этот вопрос, это лекция.
Да, там динрайт. Там динамическая диспетчеризация.
Значит, давайте подумаем о том, почему дебак так задизайнен так, как он задизайнен.
Во-первых, нам плохо возвращать просто строчку, то есть result-строчка,
потому что мы пишем какую-то, делаем какую-то лишнюю аллокацию.
А что если мы хотим, например, записать файл.
Зачем нам эта лишняя аллокация, если мы можем писать напрямую файл?
А если я хотим какой-то буфер на стеке написать, ну как в Esprint?
Если мы будем возвращать какую-то строку, то в таком случае мы будем промежуточно написать строку,
а потом писать буфер. А что, если мы хотим напрямую написать буфер?
если наш debug рекурсивно вызывается на подобъектах, то есть у нас не просто там какие-то и 32 и 64, а
прямо там какие-то структуры внутри структур, тогда это будет на подобъектах вызываться, и тогда у
нас было бы вообще n allocation под каждый такой вывод, им бы еще строки конкатинировали. Это плохо,
поэтому мы хотим как-то писать напрямую туда, куда нас просят. Собственно у нас поэтому есть
такая структура, называемая форматор. Подробно объяснять, что делают поля внутри, я не буду,
нам это наверное не так интересно. У нас интереснее всего баф. Интереснее всего нам для бафа.
Интереснее всего баф. Как вы можете заметить, у нас тут есть din-write. Как думаете, почему мы тут
din написали? Почему мы не сделали форматор генериком по какому-то т, где t имплементирует write,
и не запихнули его в этом din-t? Да, там неприемлемый кодблок. Там очень много типов имплементирует
дебаг, и соответственно у нас гораздо быстрее работает код, если у нас будет тут din сидеть.
Кстати, когда вам сказал про din-t, t если что это тип, соответственно din-tip написать не получится,
нужно писать din-trate. Такой код не скомпилируется, я просто неправильно вам сказал. Вот.
Да, форматор привязан к какому-то lifetime. Ну, например, форматор как минимум должен жить не меньше,
чем объект, который в write. Потому что если форматор будет жить больше, чем открытый файл,
то у нас получится unsafety опять. Поэтому у нас тут есть lifetime. Про lifetime чуть попозже поговорим.
Еще у нас есть такой trait, называется toString. Он превращает объект в строчку. Соответственно
он принимает объект, возвращаясь в строчку. Он автоматически имплементируется, если объект
имплементирует дисплей. Соответственно toString не нужно имплементировать напрямую. Имплементируете
дисплей, а потом вы бесплатно получите toString. Вопрос, а как же так получилось, что у нас
автоматически что-то имплементируется? Как это сделать в коде?
Не, я имею ввиду это автоматически имплементировано. Автоматически у нас появляется trait.toString.
Если у нас имплементирован debug, как это работает? У нас какой-то автоматический extent получается.
Погоди, ты будешь добавлять тогда имплементацию toString? Смотри, она здесь автоматически добавляется.
То есть так тебе нужно написать импл.toString for type, а здесь он автоматически имплементировать.
Правильный ответ. В общем, для всех те, которые имплементируют дисплей и не обязательно
size, имплементируется toString. Внутри он выглядит примерно вот так. Это прямо из компилятора,
из компилятора стандартной библиотеки скопировано. Можете не вдумываться, как это работает,
если вам непонятно в принципе. Главное понять вот эту строчку. Это то, как автоматически
extend что-то. Тут, кажется, все понятно должно быть. Так, потом есть drf и drf.mute. Вот мы дошли до
самого сладкого. Это лекция. У нас, кстати, осталось 10 минут. И сколько слайдов? 48?
Мне кажется, до интервью мы сегодня не дойдем. Так, давайте продолжим пока что. Пока есть время.
Мы можем даже указывать, какое поведение будет от оператора dereference, то есть у звездочки. Это
используется только для умных указателей. То есть для всяких RC, для бокс имплементировать.
Что еще раз? Для клоун. Ну мы сейчас разберемся. Это уже поведение dereference. Особенно как там
работает. Он специализирует оператор звездочки dereference. Получается, да.
Так, у нас есть trait deref. У него есть какой-то target, к которому мы deref-аемся. Ну естественно,
сама функция deref. Опять же, звездочка это просто синтактический сахар для объекта .deref. Тоже
самое с deref.mute. Он требует реализации deref. Внутри deref.mute. Ну и тут кажется понятно.
Вот. Этот trait никогда не должен заканчиваться ошибкой, потому что вся стандартная библиотека
Rasta, во-первых, на это полагается. Во-вторых, это будет очень очевидно для пользователя,
если он увидит ошибку в deref. То есть он не хочет получать ошибку, когда он просто deref-ает какой-то
тип. Ну в том числе потому, что deref работает не явно, в принципе, в Rasta. И вы получите
прям ошибку совсем в непонятном месте. А вот тот мент, который мне хотелось показать. Самое
время объяснять вам, как работает точечка.
Где-то я находил шутку, там типа наживение 20 метров на стандартной библиотеке. Оператор двигает влево и так ясно.
Так. Значит, давайте так. Если ты имплементируешь deref к какому-то таргету, x это какое-то значение
типа t, то в таком случае звездочка t. Так, мне самому придется сейчас на слайде смотреть, потому что я наизусть не помню, как это работает.
Если ты имплементируешь deref к таргету, x это какое-то значение t.
Это, если что, то как работает просто deref.
Смотрите, deref работает в таргет равный u. То есть мы tap приравниваем к u. В немутабельных контекстах, если вы делаете deref x, то это то, что я говорил, это синтоксический сахар звездочка x.
Он превращается в deref deref x. То есть абсолютно то же самое.
Так, потом. Значение типа ссылки на t приводится к значению типа ссылки на u.
А еще t неявно имплементирует все то, что умеет u. Ну, конечно, немутабельное в случае deref.
Deref – это немутабельный deref у нас.
То есть формально, если у вас есть deref к таргету равному u, то в таком случае вы неявно имплементируете все методы типа u.
Потому что deref работает, ты можешь написать точечку и метод типа u.
И deref все выйдет.
А давай дальше пойдем. Там будут прям правила. Прямо на примерах.
Так, ну deref mute тут написано абсолютно то же самое, только с изменением того, что появилось mute.
То есть все мутабельные методы еще имплементируются для типа t, если мы deref-аемся к u.
И значение типа mute t приводится к mute u.
Вот и через 2 deref.
То есть если у меня есть deref к 1 типу, вот этого типа deref следует.
А мы сейчас опять это увидим.
Вот примеры там с rc и str.
Ну там вот там вот джедочка написанная, а поскольку тот тип тоже deref, то что сработает?
Теперь давайте оператор точечка.
Оператор точечка создает много магии в производстве для того, чтобы сконвертировать типы.
Он делает очень много autoreferencing, dereferencing и приведения типов, пока сами типы не совпадут.
Так, это собственно правило.
Начинаем.
Для начала компилятор проверяет, может ли он напрямую вызвать метод какой-то.
То есть если вы пишете x это типа t, пишете x.fu, допустим, то он в первую очередь пытается найти у самого типа t метод.
Это называется buyValue call.
То есть с самого начала он пытается найти у самого типа.
Если у него не получилось...
Тогда компилятор пытается автоматически zdерефаться.
Он пытается вызвать fu у ссылки на t и у mute ссылки на t.
Это называется autoref call.
Ну и если мы не можем вызвать эту функцию, вот кстати говоря, еще в случае,
если мы неправильные типы имплементируем,
если у нас неправильные типы, либо если функция вообще не имплементирована до self,
то в таком случае он пытается дальше идти.
Автоматику он просто за тебя.
Ты этого не видишь, он за тебя делает, а не он.
Все, автоматика.
Ну да.
Если никто из этого не сработал, то он пытается задеревать t.
То есть если у ссылки на t нет...
С самого начала мы пытаемся у самого значения,
потом если не получилось значение, у ссылки на значение вызвать.
И у mute ссылки на значение в таком порядке.
Если не получилось ничего вызвать или типы не совпали,
то в таком случае он пытается задеревать.
Дерев либо дерев mute, соответственно,
в зависимости от контекста.
Да, иначе fail, конечно, с дерева нет.
Он пытается задеревать.
Это все, у меня, кстати, тут текста t нету,
поэтому здесь дерев и вот это вот не monospace.
Ну ладно.
Собственно, если мы не можем задереференсить t,
то тогда мы пытаемся за unsize t.
Ну смотри, если у тебя есть ссылка на str,
то ты превратишься в str.
Потому что на самом деле индекс имплементирован
не для ссылки на str, а у str.
Так, давайте попробуем посмотреть на такой вот пример.
У нас есть array rc внутри rc-box,
внутри box slice.
А потом я делаю такой first entry array 0.
Это скомпилируется, это будет работать.
Не, ну какой тип?
Тип t.
Получится.
Понятно.
Ну непонятно, но даешь.
Ну хорошо, давай разберем.
Хорошо, для начала.
Array 0 – это просто синтактический сахар
для trade.index.
На самом деле мы, конечно,
вызываем array.index 0.
То есть, как я говорил,
все trade, ну плюсики там,
все такое – это синтактический сахар.
Это вот то, что мы на самом деле ищем.
Мы хотим найти точка index 0 у кого-то.
Для начала компилятор проверяет,
имплементирует ли этот тип index.
Вот так как не имплементирует,
ссылка на rc или mute ссылка на rc
это не имплементирует,
то в таком случае мы пойдем дирефать.
У нас же правило,
сначала мы пытаемся по значению,
потом по ссылке,
потом мы tabbing ссылки.
Ни то, ни другое, ни третье
не имплементируем,
а дирефаем.
Дирефа у rc – это бокс.
То есть rc – дирефается к боксу.
Мы же, когда делаем диреф у rc,
мы получаем, собственно,
объект, который внутри.
Пытаемся снова.
У бокс такого метода нет.
У сылки на бокс метода нет.
У mutable ссылки на бокс метода нет.
Окей.
Задирефаемся дальше, да?
Дирефаемся, получаем тип t3.
Да.
Не, мы не можем задирефать t3,
соответственно,
мы пытаемся за unsize-ить это.
То есть ссылка t3 – это какой-то slice.
И здесь нам нужно за unsize-ить
и получить квадратные скобочки на t.
Обратите внимание,
что вот это вот на самом деле
индекс не имплементирует.
Не имплементирует t.0.3
trade index.
Имплементирует именно slice st.
Превратить unsize тип.
Вот это вот мы превращаем вот это.
То есть мы просто t.0.3
превращаем в slice st.
Просто, опять же,
с точки зрения теории типов
в расти правильно,
если у вас индекс
имплементирован именно у unsize типа.
Все для корректности
такого, правильности
логической, математической.
Вот.
Мы за unsize-или
и получили slice на t.
И, соответственно,
ух, t имплементирует индекс.
Соответственно,
мы нашли эту пункцию,
которую мы хотим вызвать.
И компилятор, соответственно,
пытаясь сделать r0,
он вызовет, конечно же,
ну, slice,
который внутри rc-box
возьмет 0-ой элемент.
А как же правило, там,
явное, очень явного?
Ну,
боюсь, что это как раз тот пример,
когда ты в большинстве случаев
будешь ловить,
наоборот,
положительные эмоции
от этого,
потому что тебе вряд ли
придется вот, вот,
такие вот
замечательные структуры.
Не надо будет
две звездочки фигать.
Да, не нужно будет
десять звездочек
как в плюсах писать типа.
Да блин.
Смотри, как там.
Да.
Диды писали.
А такой вопрос, так,
мы берем,
вот, еще раз,
t.t3 у нас
в сайзе slice?
Да.
Он имеет размер
size of t на t.
Так.
А если у нас
index out of bounds,
что,
кто кидается?
Паника.
Ее кидают,
собственно,
элементации индекса
у unsized slice.
Нет.
Компилятор,
такое вещь
во время компиляции
не проверяет.
Ну, конечно,
не проверяет,
потому что тогда
вопрос,
кто именно из
этой цепочки
первым бросит панику?
Ну, когда
это скомпилируется,
а потом,
когда ты в рантайме
будешь,
у тебя,
собственно,
имплементация индекса
вот у этого slice
выдаст панику.
То есть,
ну,
компилятор,
это все просто,
как я говорю,
превратит,
получается,
в одну,
внутри.
Ну, ладно.
Ну, в плюсах
ты бы сделал
то же самое
только руками.
Вот.
Ну, я просто
показаюсь.
Я сижу,
иногда я пытаюсь
понять,
кто именно кидает.
Просто,
часто,
то есть,
у нас в данном случае
конкретно
этот объект,
типа квадратные
скобки T,
он знает свой размер,
поэтому,
вполне себе,
кинет панику.
Да.
При этом,
на уровне типов
этот размер
то,
что мы
копировали,
то ссылку,
то тип.
То есть,
это у нас
clone,
мы делаем
clone,
это value clone.
Так.
Для начала,
опять же,
так,
это,
надеюсь,
это не,
это повторение,
да?
Черт.
Как же так вышло?
Ладно.
Правильные примеры.
Ладно.
Так, ладно,
давайте подумаем.
Да,
давайте подумаем
и делаем
value clone.
Мы с самого начала
пытаемся
по значению.
По значению,
у нас
вообще
clone не имплементирован.
Так?
Вроде бы не имплементирован
по значению
ссылки на T
clone.
Ну, хорошо.
Вот.
Соответственно,
мы пытаемся это,
у ссылки на
ссылку на T
тоже не имплементирован,
мы табельные
ссылки на
ссылку на
T тоже не имплементирован,
пытаемся
дирефать.
Дирефаем T,
получаем.
Если не имплементирован
clone,
кстати,
сейчас вот
путаюсь,
а почему
там
скопируется?
Ну,
именно
заклонится
ссылка.
Да,
там
заклонится
ссылка,
если
T не
clone.
Cloned будет
иметь
типа
ссылки
на T.
Вот.
Мы же
требуем от
T.
Какой
момент
нам
придет,
когда
она
заклонится
ссылку?
Давайте
тоже
подзабыл
этот момент.
В чате
напишу
сразу.
Ну,
мне
что-то
подсказывает,
просто,
что
по каким-то
причинам,
расту не
нравится
ссылка
на T,
как один
из
других.
Так,
теперь
мы можем
сравнить
с плюсами,
наконец-то.
Наверное,
сравнить
с плюсами
и закончим,
потому что
у нас
формально
лекция
уже все.
Так.
У нас
трейты
хороши
тем,
что они
позволяют
отдельно
держать
имплементацию
от
данных.
В
таком
случае
интерфейса
очень
тяжело
расширять.
То есть,
если
вы
захотите
доимплементировать
какой-то
свой
интерфейс
для
типа,
то в
таком
случае
нужно залезть
в этот
тип.
Это не
удобно.
А в
случае
расту,
вы
можете
использовать
новые
типы,
но сложно их
расширять.
Вот.
Потом,
в
расте
все
трейты
явно
имплементированы.
Пока
плюсовых концептов
позволяет
либо
что-то
только
запретить,
либо разрешить.
А то,
что не
написано,
то
получение
разрешено.
Вот у
меня есть
код
stringify,
какая-то
функция stringify,
которая
возвращает
из
std
string.
Есть
код
cat,
который умеет
в
stringify,
собственно,
и
pet.
Вот.
Потом у нас есть
функция
f,
которая
требует
отти
stringable,
и при
этом я внутри
вызываю
код
stringify.
И
я
не смотрю
ее
с
какого
получится.
Ну,
теперь
представьте,
что у вас все это время
огромная
кодовая
база у вас,
красивые
типы все время
засовывались
в эту
функцию,
что-то
типа такого.
А потом
вы засунули
те,
которые внезапно
pet не
имплементируют.
Какого-то
типа.
Ну,
все равно
было бы
гораздо приятнее,
если бы у вас
был
trait stringable,
и если бы вы
потребовали
stringable в
Rast,
ну,
то
string,
по сути,
то в
таком
случае у вас бы
такой код не
скомпилировался,
потому что Rast
сказал бы,
что он не
нашел
у типа
tpet.
Мы же
в этом
плане,
если вы
попробуете
загуглить,
например,
Rast
trait C++,
ну,
то есть,
как
Rast
trait C++
имплементируют,
там очень
много статей про
то,
как
люди
завидуют
trait в
Rast,
прямо в
смысле слова.
Ну,
то есть,
они
ищут какие-то
способы,
прича,
я думаю,
понравится,
когда
вы будете
работать с Rast,
потому что
она
хорошо
позволяет
абстрагировать
код.
Ну,
и собственно,
концепты
в плюсах
проверяются
только тогда,
когда
инстанциализируются.
Это то,
что приводит
каким-то
запоздалым
ошибкам,
что несколько
неудобно.
Кажется,
мы
Давайте тогда всем пока!
