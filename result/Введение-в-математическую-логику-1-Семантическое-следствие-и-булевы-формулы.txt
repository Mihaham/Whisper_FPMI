Так, ну что, звонок прозвенел, пора начинать, рассаживайтесь.
Ну а вы меня должны по идее знать, на всякий случай
напомню, что меня зовут Михаил Николаевич Вялый,
я буду у вас лектором по новому курсу введения
математическую логику.
Раньше у нас был единый курс логики и теории алгоритмов,
но мы программу перетасовали, и у вас вместо теории формальных
систем алгоритмов и триапа будет логика и теория алгоритмов.
Часть материала из триапа войдет в теорию алгоритмов,
ну а в этом курсе будет то, что было про логику раньше,
плюс еще, поскольку освободилось немножко места, будет еще
разные вещи.
Значит, ну как устроена отчетность по курсу, как устроена так
же, как в прошлом году на алгебре, то есть будет
экзамен, будет бально-рейтинговая система, на сайте кафедры
вы можете посмотреть более подробно и посмотреть программу
курса с официальным заданием.
В общем, я думаю, что особо тратить на это время сейчас
не нужно, вы должны все представлять, потому что все очень похоже
на курс алгебры, там те же самые очки, в общем, все
точно так же, никаких изменений пока не планируется, ну
я надеюсь, их и не будет.
Так что я сразу перейду к делу и начну рассказывать
уже содержательным.
Что такое математическая логика?
Это очень амбициозный проект.
Как научиться формализовывать математические рассуждения,
так чтобы можно было доказывать, как часто говорят, метатеоремы.
То есть теоремы такого типа, какое-то утверждение
нельзя доказать в таких-то обстоятельствах, в такой-то
формальной системе.
Или, наоборот, какой-то класс утверждений доказываем.
Или там две формальные системы равносильны.
Это очень амбициозный проект, потому что на первый взгляд
не очень понятно, как к этому подойти, математика
науко-содержательная, когда мы рассуждаем, у нас
и образы, и какие-то наглядные вещи, но давным-давно люди
поняли, что математика очень хрупкая, достаточно
одного противоречия, чтобы все рухнуло.
И поэтому нужно обеспечить корректность всех доказательств.
И этим занимались довольно долго, и кончилось вот тем,
что в какой-то момент люди совершенно уже упорно
стали работать и достигли некоторого успеха.
Успех частичный, и объяснить, в чем успех и что неудача
это одна из частей курса, так быстро в двух словах
я говорить не хочу.
С чего мы начнем?
Давайте вообще начнем с того, что оговорим некоторые
важные общие вещи, относящиеся ко всем рассуждениям такого
типа.
Смотрите, у нас идея формализовать математические рассуждения,
хотя бы утверждения, так, чтобы можно было математическими
средствами что-то про них доказывать.
Возникает такая трудность, я думаю, совершенно понятная.
У нас в результате, в одном рассуждении будут и сами
математические утверждения, и математические утверждения
в математических утверждениях.
Как не запутаться.
Это действительно некоторая проблема, и поэтому я сразу
введу некоторые два важных понятия, которые буду постоянно
использовать, именно чтобы различать вот эти два уровня,
которые у нас всегда будут.
Первый уровень называется семантик, это те объекты,
о которых мы рассуждаем.
Ну вот, допустим, мы берем тюрьму группы, изучаем.
Вот группы, это наша семантика в этом случае.
Все, конечно, не так просто, потому что здесь скрываются
философские глубины, потому что если мы уж озабочены
строгостью рассуждения, то нам скажут, ну а почему
вы вообще знаете, что группы существуют, что это вообще
такое, что за объект, мы же не можем показать, пкнуть
пальцем вот эта вот группа, их в физическом мире нет.
Поэтому нужно как-то эту проблему решать.
Значит, математики ее решают очень просто.
Математики стихийные платонисты.
Они считают, что математические объекты существуют в некотором
идеальном мире, мире идей, и мы какие-то свойства этих
объектов способны узнать.
Что там еще есть за свойства, мы не знаем, но какие-то
способны узнать.
То есть нам доступен этот мир с помощью наших умственных
усилий.
Это одна из возможных философских трактовок того, как живут
математические объекты не единственно возможная.
Философию я вдаваться не хочу, хочу только сразу
сказать, что большинство работающих математиков
стихийно этой точки зрения придерживается, никто не
сомневается, что группа есть, что множество есть,
не знаю, что действительно числа есть.
При этом возникают разные трудности.
Частично я потом про них скажу.
И люди, озабоченные строгим обоснованием в математике,
такой подход, конечно, не ценят.
Считают его слишком наивным и непригодным для серьезного
дела.
Мы его, тем не менее, придерживаться будем, потому что иначе очень
трудно.
Есть способ подложить некоторые формальные основания под
семантику, но он трудный.
Я чуть позже во второй части курса немножко расскажу
про саму идею, как это делается, но учить этому не буду, потому
что это сложно и особо не нужно.
Сейчас люди не так сильно озабочены корректностью
рассуждений.
А вы вообще учитесь на факультете прикладной математики,
многие из вас программируют, а программисты вообще не
озабочены корректностью программ.
Все работают неправильно, никого это не смущает,
наоборот, все этим очень довольны, потому что можно
выпустить через два месяца следующий релиз, заработать
еще денег, и в общем так оно все и идет.
Но, тем не менее, такая проблема есть, ее стоит иметь
в виду, но я буду придерживаться почти все время такого наивного
подхода.
Когда я от него отступлю, я это отдельно оговорю.
А вторая вещь, которую нам что-то нужно с ней сделать,
это называется синтаксис.
Давайте я напишу, я все эти подробные слова писать
конечно не буду, но по крайней мере, чтобы можно было.
Что такое синтаксис?
Это как раз способ формально представлять математические
утверждения.
И математические рассуждения, которые, как вы, я думаю,
хорошо понимаете, это просто цепочки утверждений, связанные
с законом милуэки.
То есть, некоторые цепочки утверждений корректными,
мы их называем доказательствами, некоторые – нет.
Но что при этом, мы же все-таки хотим, чтобы это были математические
объекты, нам надо как-то внятно сказать, что мы имеем
в виду.
Подход тут такой, он не сразу именно так установился,
я уж пропущу всякие исторические истории по этому поводу,
а сразу скажу, как более-менее сейчас на это смотрят.
В любом случае, что математическое утверждение, что математическое
доказательство – это текст.
А что такое текст в современном мире?
Это файл.
Если упрощать жизнь, а в этой науке мы предпочитаем
упрощать, отбрасывать разные ненужные сложности,
файл – это просто последность нулей единиц.
Текст – это слово из нулей единиц.
И что нам нужно?
Нам нужно уметь различать тексты или слова, которые
являются описаниями каких-то математических утверждений
или математические доказательства, которые не являются.
А что значит различать?
Ну, это не должно быть, как с пьесами Шекспира один
критик говорит, да, вот это гениальное проникновение
в историю средневеков в Англии, другой говорит,
нет, это злобная клевета и поклёп на несчастного
Ричарда Третьего, скажем.
Математики так не хотят, поэтому они считают, что
должно быть твёрдое правило, которое объясняет, вот эта
цепочка является формулой, я потом эти слова буду использовать,
более-менее формулами называть, ну или последовательностью
формул, которая называется доказательством, а это
не является.
Ну, и сейчас вы все понимаете, как это нужно формализовать.
Нужно сказать, что есть алгоритмы, допустим, компьютерная программа,
вы даёте ей на вход текст, и она говорит, да, это математическое
утверждение, даёте другое текст, она говорит, нет,
это не математическое утверждение, и это должен быть вот такой
вот алгоритм, который работает, совершенно механически
преобразовывает эту цепочку.
Ну как устроена теория алгоритмов, вам будут рассказывать в
параллельном курсе, я позже, в самом конце курса, мне
оно понадобится, настоящая теория алгоритмов, но вас
ещё этому должны научить, я надеюсь, что когда мне
понадобится, вас уже этому обучат, а пока я буду к алгоритмам
относиться, ну апеллируя к вашей интуиции, вы все
какие-то программы писали, у вас там был курс вообще
весной, тоже что-то там, основы алгоритмов, поэтому
какое представление о том, что такое алгоритм у вас
есть, вот у нас будут конкретные алгоритмы появляться, пока
речь идёт о конкретных алгоритмах, в общем-то, большего не
нужно, проблемы начинаются, когда мы хотим доказывать
утверждение, что какого-то алгоритма не существует,
потому что это не очень понятно, как сделать, ну мало
ли, вот сейчас не существует, а завтра кто-нибудь напишет.
Вот, и обычно эти алгоритмы, которые различают формальные
утверждения и формальные доказательства от мусора,
ещё предполагается, что они эффективны, это не обязательно,
то есть для такой настоящей теории это требование не
обязательно, но в жизни, понятно, оно полезно, потому
что если мы придумаем какую-то очень замысловатую формализацию,
где чтобы понять про строчку из 20 символов является
или она описание математического утверждения нужно 10 миллионов
лет, ну как-то это не очень понятно, зачем такая формализация
нужна, ну и честно говоря, никаких интересных примеров
такого рода я не знаю, то есть не исключено, что они
есть, я не буду утверждать, что нет, но я не знаю, вот,
и из этого уже ясно, что логика и теория алгоритмов
тесно связаны, не случайно были вообще долгое время
у нас в одном курсе, и в университете, вот на Мехмате, там у них
курс алгоритма и математическая логика, он годовой просто,
но он единый, потому что это действительно связанные
вещи, и более того, теория алгоритмов возникла исторически
позже, то есть люди вначале думали, как бы убедить себя
и других, что наши математические доказательства правильные,
а в процессе этой работы возникли разные структуры,
не сразу, там история очень длинная, но в какой-то момент
возникло то, что называется формальной моделью вычислений,
то есть появилась возможность математически строго сказать,
что такое алгоритм. Ну и побочным следствием этой
деятельности пары дюжин, наверное, человек за 50 лет
стала современная компьютерная цивилизация, то есть если
бы вот этой работы по обоснованию математики не было, скорее
всего, технологическое развитие шло бы по-другому, потому
что в начале вычислительные устройства были другими,
это была такая стойка с дырочками и провода, и написание
программы состояло в том, что надо было правильным
образом воткнуть провода, то есть сделать какие-то
дополнительные соединения, получалась уже электрическая
схема, которая конкретную задачу решала, а нужно
решать другую задачу, нужно было провода перевтыкать.
И так довольно долго развивалось, лет 15, по крайней мере, и
довольно сложные вещи такие устройства могли делать,
а потом захотелось делать еще более сложные, и инженеры
уже совсем замучились, потому что, ну вы понимаете, как
это мучительно, допустим, вам нужно 100 килобайт программы,
сколько нужно дырочек, ну так, вообще, если делать
все по уму, то не так уж и много, но они же тогда делали
по-простому, ну и нашлись математики, которые им
объяснили, что вы зря различаете программы и данные, что это
на самом деле одно и то же, а нужно написать вместо
этих дырочек, нужно один раз все закоммутировать,
чтобы реализовался универсальный алгоритм, который будет
часть данных воспринимать как код и работать на остальных
данных уже как на данных.
И это была революция.
Не только в математике, не только в технике, а, как
мы сейчас видим, вообще во всем обществе.
Ну, на этом я рекламную часть курса маневатической
логики закончил, надеюсь, вы прониклись, что это важная
вещь, что вот рассуждая в таких крайне отвлеченных
понятиях, можно не на роком цивилизацию новую создать.
То есть, в общем, это серьезные и глубокие вопросы.
Мы, конечно, всего охватить не сможем.
Моя цель более-менее дать вам представление об основных
технических идеях, как вообще можно такие рассуждения
проводить.
Ну и до каких-то теорем я хочу, конечно, добраться
не без этого, но не сильно далеко.
И поскольку это дело достаточно трудное, и одна из трудностей
этого курса состоит в том, что, как бы мы ни старались,
формализации получаются очень громоздкими.
Мы привыкли содержательно рассуждать про математику,
и это очень гибко, очень удобно и позволяет нам легко
подстраивать свое восприятие к каким-то конкретным
обстоятельствам.
А логика устроена иначе.
Нам нужно фиксировать определение довольно сложных вещей,
поэтому и определения получаются сложными.
Ну это некоторая неизбежная трудность, все-таки мы очень
амбициозную цель ставим, поэтому ее не так легко
достичь.
Значит, что вообще происходит, когда мы, допустим, зафиксировали
какую-то формализацию?
У нас их будет несколько, но зафиксировали какую-то.
Самый первый вопрос, естественный, который возникает, это даже
не про доказательства, а про то, какие утверждения
у нас, зафиксировано синтакс, зафиксирована семантика,
какие утверждения вообще мы можем выразить вот этими
средствами формальными, которые у нас есть?
Какие утверждения вы можете выразить обычными алгебравическими
формулами о группах?
На самом деле, не очень многими, я не уверен, что этот пример
разовью подробно, но ясно, что нам нужно что-то еще,
это мы в следующий раз обсудим, что нам нужно и что мы постоянно
использовали, когда говорили о группах, ну и других математических
дисциплинах тоже самое.
Но вопрос этот, он все равно важен и он не очевиден,
потому что, во-первых, заранее ясно, что если мы хотим
рассуждать о каком-то бесконечном множестве, то шансов построить
универсальную выразительную формализацию нет.
Формализация, я напомню, это текст, то есть любое
утверждение это текст, значит утверждение в любой формализации
счетное множество, последности 0 единиц, счетное множество.
Хороший вопрос, поднимите руки, кто знает, что такое
счетное множество.
Ага, ну почти все знают, хорошо, а теперь более сложный
вопрос, поднимите руки те, кто может ответить на вопрос,
где вас, в каком физтеховском курсе вас этому учили.
Это гораздо меньше, вот у меня было такое подозрение,
что эта тематика как-то проваливается, она нужна
более-менее в разных областях математики, но всем в содержательных
курсах жалко тратить на нее время и проваливается.
Ну, в общем, более-менее в терминах, которые вы уж
точно должны знать хотя бы из моего курса алгебры
можно сказать так, что счетное множество те, которые можно
поставить в взаимно однозначное соответствие с множеством
натуральных чисел.
Ну там целые числа тоже счетные, в общем их много,
там есть некоторая несложная наука про эту часть и вот
судя по опросу большинство что-то про это знает, мне
подробности не нужны, вот сейчас мне, например, нужно
просто чтобы вы понимали, что множество слов из 0 единиц
счетно.
Ну как поставить в соответствие слова из 0 единиц натуральные
числа, есть много способов, я давайте сейчас не буду
на это отвлекаться, но это несложное упражнение,
я думаю, каждый из вас легко с этим справится.
Да, а свойства это просто подмножество, то есть мы
про одни элементы говорим, что они обладают свойством,
другие не обладают, то есть это подмножество и подмножество
даже счетного множества уже не счетное количество,
это такое известное открытие кантера, поэтому шансов
описать вообще, построить такую мощную выразительную
систему, которая будет описывать все, если множество бесконечно
нереально.
Поэтому этот вопрос содержательный и вот первая часть курса
мы будем, я постепенно введу самый мощный формализм,
который нам будет нужен, не в один прием, а так несколько,
и потом мы будем изучать, что же в рамках этого формализма
можно выразить, а уже во второй части курса мы обсудим,
что можно в рамках такого формализма доказывать.
Понятно, выразить это одно, а доказать все-таки там
еще какие-то логические связи, это сложнее, но так постепенно
и в самом начале мы к этому будем готовиться, какие-то
вещи с самого начала будем разбирать.
Вот примерно такой план, но прежде даже чем его реализовывать,
я хочу начать с того, чтобы вот эти слова про синтаксис
и семантику придать им какой-то более конкретный
смысл.
Мне это все равно нужно, мы начнем с очень простого
примера, я в этот раз даже не надеюсь его закончить,
но начать все равно нужно с него, потому что он нам
понадобится дальше для вот этой вот уже мощной
формализации.
Давайте вот что обсудим.
Такой будет связь с тем, что вы заведомо знаете,
и тем, что мы будем хотеть делать.
Я хочу сейчас объяснить, какого рода утверждение
мы будем формализовывать.
И вот давайте начнем с чего-нибудь очень простого.
Вот система линейных неравенств, x больше единицы, x больше
двух.
И вас, я думаю, учили еще в школе тому, что неравенство
x больше нуля не является следствием этой системы.
А неравенство x, ой, наоборот, x больше нуля является, прошу
прощения, не в том порядке начал писать, а x больше трех
не является.
Что мы при этом понимаем ввиду, когда мы говорим
о следствии системы уравнений или системы неравенств?
Давайте скажем это общими словами.
У нас есть некоторое множество утверждений.
Ну, в данном случае это два неравенства.
Значит, неравенство – это утверждение.
Оно либо истинно, либо ложно.
Как распознать утверждение?
Необходимым условием является то, что оно должно принимать
логическое значение.
Утверждение должно быть истинно или ложно.
Если что-то не может принять логическое значение, это
не утверждение.
А во обратную сторону надо как-то еще что-то оговаривать.
Итак, у нас есть набор утверждений и еще одно утверждение.
Давайте вот это вот я f обозначу, вот это вот a.
И что мы подразумеваем, когда говорим, что a является
следствием f?
Мы подразумеваем следующее, что если все, ну такое обычно
и бывает, утверждение не просто утверждение, а в них
есть еще какие-то параметры, которые могут переменные,
понимать какие значения.
И вот существенно что, что если мы уже зафиксировали
значение всех переменных, то есть истинная или ложь
для всех утверждений в f уже определена и они все оказались
истинными, то тогда мы точно знаем, что утверждение
a тоже истинно.
Ну и посмотрите, действительно, если х больше единицы и
х больше двух, то, конечно, для любого х, который удовлетворяет
этим неравенством, он будет положительным.
Это очевидно.
А х больше трех такому свойству не удовлетворяет,
потому что может быть число, скажем, два с половиной.
Оно больше единицы, больше двух, но меньше трех.
То есть все из f утверждения истинны, а а ложны.
Вот если выполняется, мы это будем обозначать вот
таким вот знаком формальным и говорить, что это следствие.
Но я напоминаю, что в логике приходится держать два
уровня рассуждения, это следствие содержательное,
на уровне семантики.
А у нас еще будут доказательства.
И в доказательствах тоже будут появляться свои
следствия.
Мы зафиксировали, так условно я сейчас не буду конкретизировать.
Аксиомы, я думаю, на таком уровне..
Представляете как устроено формальное рассуждение?
Зафиксировали аксиомы.
Зафиксировали правила рассуждения и что-то выводим.
И вот то что выводим, является следством того, что мы приняли
в качестве аксиома.
Но это другое следствие, не такого вида.
Нужно их как-то различать, поэтому вот это вот следствие мы будем называть
семантическим следствием. Другого долгое время у меня и не будет, но я буду
стараться все время проговаривать это лишнее слово, чтобы вы понимали, что в
конечном счете нам нужно два вида следствий. И цель в каком-то смысле в том
логике и состоит, чтобы придумать такую формализацию, чтобы семантические
следствия совпадали с синтоксическими. То есть, что мы можем доказать все, что на
самом деле следует. Семантическое следствие, если у нас есть набор утверждений и
еще одно утверждение, то А считается семантическим следствием СЗФ, если как
только все утверждения СЗФ истинны, А тоже истинны. Почему, потому что у нас будут
синтоксические следствия. Например, ну пример синтаксиса, я не хочу сильно это
развивать, с системами линейных неравенств можно выполнять синтоксические
операции. Брать сумму неравенств положительными коэффициентами, там
добавлять, вычитать одинаковые члены слева и справа, умножать на положительное
число, в общем, представляете, да, вот есть некоторые такие преобразования.
Можно считать, что наша запись в виде неравенств это вот и есть синтаксис, а
вот эти вот преобразования это правила формального изменения. То есть у нас есть
равносильное преобразование, и все, что можно получить такими преобразованиями,
скажем, если мы складываем, это неравносильное преобразование. Если я
сложил два неравенства, получил, скажем, неравенство 2х больше 3, ну это,
конечно, следствие и вот мы объявляем, что у нас вот синтаксис вот такой, всё что
мы можем так построить это следствие. Ну, вот, если вы немножко подумайте, вы
поймете, что такими естественными линейными преобразованиями вы не получите неравенство
х больше нуля из этих двух неравенств. Потому что непонятно, почему вам разрешить вычитать.
Правильный синтаксис в этом случае включает еще себя одно действие. Но давайте я все-таки теорию
линейных неравенств не буду рассказывать. Я не знаю, кто вас и когда этому будет учить. По
видимо, когда уже будут учить линейному программированию, вряд ли раньше, и там не очевидно,
что прям про линейные неравенства будут говорить. Но именно с такой, с логической точки зрения. Но в
принципе есть такой подход, который позволяет все это. На самом деле у нас будет пример очень
похожий на этот. Но давайте пока не забегать вперед. Итак, вот это у нас появилось семантическое
следствие. И теперь, наконец, я хочу перейти к конкретному примеру, где будут частности
и семантическое следствие тоже. Это булливые функции. Ну, что такое булливая функция? Я думаю,
вы знаете, с прошлого года у вас был курс, вводный курс комбинаторики. У него длинное название,
поэтому я не берусь его воспроизвести. Но там аллоги, брологики, комбинаторики, теориографов.
И булливые функции там почти заведомо появлялись. Ну, я напомню, это мы берем функцию, которая
тотальную, то есть сюда определенную, которая словам длины n булливым сопоставляет 1 бит. То есть
другими словами аргументы ее булливы и значения тоже булливые. Почему это интересно с точки
зрения логики? 0 и 1 традиционно кодируют ложь и истина. То есть на это можно смотреть так. У
нас есть некоторые высказывания, которые могут быть истинными или ложными. Их еще называют
элементарные высказывания. Ну, вот переменные функции. А функция это составное высказывание.
Ну, например, составным высказыванием может быть такое. Все высказывания иксы это истины. Что
это за функция будет? Ну, я думаю, всем понятно, что это будет конъюнция. Такая функция у вас заведомо
появлялась. И более-менее любое составное высказывание можно так изобразить. Почему? Потому
что составное высказывание, его истинность зависит только от входящих и истинности или
ложности входящих в него частей. Ну, тогда это и получается функция. Вот такая связь булливых
функций и логики. И это в частности объясняет следующее определение. Что если у меня теперь уже
есть множество? Ну, смотрите, у нас есть высказывание x1, xn, а f это какое-то составное высказывание,
которое зависит от x1, xn. Вот, как пример, конъюнция. То есть, все иксы это истины. Это составное
высказывание. Оно зависит от значений иксы, но от ничего больше не зависит. То есть, если
все иксы это истинные, значит, и наше составное высказывание истинное, а иначе ложное. Но
такому составному высказыванию соответствует булливая функция. Вы подставьте истинностное
значение 0 и 1. Посмотрите, что ваше составное высказывание говорит, истинное оно или ложное.
Если оно истинное, то значение функции равно 1, если оно ложное равно 0. То есть,
два языка говорить об одном и том же. Просто, технически удобно говорить о булливых функциях,
Ну а содержательно, в логике это нужно понимать, что это действительно составные высказывания.
А, ну может быть даже прежде, чем я напишу определение семантического следствия,
давайте сразу разберемся, вот у меня синтаксис и семантика еще с доски не ушли,
давайте разберемся, что в этом примере синтаксис, а что семантика.
О чем мы вообще рассуждаем? Мы рассуждаем о
о составных высказываниях, которые зависят от каких-то элементарных.
Ну и чтобы не ограничивать себя в количестве этих элементарных высказываний,
мы будем считать, что их бесконечно много. У нас есть какой-то набор,
можно сказать, булевых переменных или вот элементарных высказываний.
И в сущности сейчас мы находимся в такой очень ограниченной
семантике, вот мы о свойствах последностей 0 и 1, по сути дела, что-то хотим говорить.
А что мы говорим? Если у нас есть функция,
которая зависит там от каких-то переменных,
что она нам говорит? Она нам говорит,
какие значения стоят на третьем, седьмом и восьмом месте.
То есть если мы говорим, что функция...
Тут еще некоторое соглашение,
что нас же интересует истинно или ложно, это высказывание.
Оно истинно, если равна единице.
Вот если функция от x3 к 7 и x8 равна единице,
это значит, что на третьем, седьмом и восьмом месте
стоят такие наборы истинных значений,
которые гарантируют истинность этой функции.
Там понятно из 8 возможных вариантов,
какие-то будут давать 0, какие-то будут давать единицу.
То есть мы выражаем такое свойство,
что на конкретных местах конечном количестве
стоят какие-то значения, а другие стоять не могут.
То есть вот это выразительное средство.
Согласитесь, вроде бы не очень многом,
но тем не менее,
в таком странном и, казалось бы, очень убогом виде
можно представлять вполне себе содержательные теоремы.
Вот давайте...
Давайте поймем, как с помощью булевой функции выразить
какое-нибудь свойство графов.
Вот, например, что граф Гамильтонов.
Гамильтонов, вы помните, должен быть Гамильтонов цикл.
Такой цикл, который проходит через каждую вершину ровно по разу.
Ну и граф, давайте считать, неориентированный для определенности.
Тогда...
Что нам нужно? У нас...
Как это встроить в нашу схему
с последовательностями 0 единиц?
Но надо вспомнить, что пар натуральных чисел
тоже счетное количество.
И использовать переменные не вот как я написал
x1, xn, а переменные x и t, x и gt.
Которые говорят следующее,
что если у графа есть вершина и и g,
есть ли ребро между этими двумя вершинами?
Тогда если я выберу
какие-то переменные вот в таком диапазоне,
это часть всего бесконечного множества переменных,
придам им значение 0 и 1, я закодирую граф.
У меня будет известно, какой у меня граф.
На самом деле тут даже не просто не равно,
поскольку я сейчас про неориентированные графы говорю,
нужно сказать, что и меньше g,
потому что x и gt должно совпадать с x и gt,
можно это избежать, чтобы лишних условий не писать,
просто написать, что мы только такие переменные рассматриваем.
У нас появляется граф.
И дальше, например, свойства графа Гамильтона.
Это некоторая функция.
И я не хочу слишком углубляться в это дело,
но я думаю, всем понятно, что таким способом
в нашу вроде бы убогую семантику
можно загнать утверждение любых конечных объектов.
Ну, вот я о графе загнал,
а представьте, что у вас не граф,
а какое-нибудь там либо отношение,
наконец-то у вас есть вершина,
то есть у вас есть вершина,
то есть у вас есть вершина,
но представьте, что у вас не граф,
а какое-нибудь там либо отношение на конечных множествах,
либо какая-то функция, либо еще что-то такое.
Ну, понятно, что нужно сделать примерно то же самое.
Нужно просто завести переменные,
отвечающие возможным элементам.
То есть все можно определить через множество,
ну и вот будет булевая переменная,
что вот такой элемент входит или не входит в множество.
То есть любой конечный объект можно так представить
после некоторых усилий в виде конечного множества.
Ну, вот как я сейчас, скажем, это сделал.
Что граф, это множество ребер,
и вот так вот я представил его.
Таким образом,
вроде бы семантика достаточно бедная,
но при этом
ну что-то интересное в ней сказать, наверное, можно.
И
говорить можно разные вещи.
Я сразу, поскольку я ввел
семантическое следствие,
это вот для нас будет основное,
что мы хотим выражать,
я сразу специфицирую это определение
для булевых функций. Пусть f множество булевых функций.
Булевые функции я сокращенно напишу.
И какая-нибудь f мало, это просто булева функция.
Тогда мы говорим, что
f мало следует из f большое.
Ну, f такое курсивное, а там а было.
Ну, сейчас мне удобно.
Значит, смотрите, у меня,
я сейчас совершаю некоторые актуальные мысли,
потому что когда я говорю о функциях,
я на самом деле имею в виду утверждение.
f от x
равно единице.
Понятно, да? То есть я говорю о множестве функций,
или об одной функции,
но я имею в виду утверждение,
что соответствующая функция равна единице.
То есть можно считать в духе предыдущего примера,
что я рассматриваю систему уравнений булевых.
Вот функция из множества f красивая равна единице.
Вот у меня есть такая система уравнения.
Она при каких-то значениях переменных выполняется,
при каких-то одно из переменных не выполняется.
Значит, это недопустимое значение.
Ну, и есть еще одна функция.
И определение следования точно такое же,
как для систем линейных уравнений.
То есть это вот по определению
Рассказ здесь не идеальная.
По определению это означает,
что если g от x равно единице
для всех функций из вот этого множества,
то тогда f от x тоже равно единице.
То есть сейчас, когда я говорю о булевых функциях,
еще раз подчеркну.
Вот здесь на доске это написано.
Я имею в виду под функцией высказывание.
То есть нас интересует, когда оно истинно.
Ну, это некоторые такой
общегоупотребительные в этом месте двоемыслия.
Обычно говорят о функциях,
хотя речь идет об высказываниях.
Тут, в общем, пока еще запутаться не так уж сложно.
Можно не запутаться.
Ну вот, это определение совершенно такое же,
как было в общем виде,
просто для этой конкретной ситуации специфицировано.
Мы зафиксировали вид утверждений.
Давайте какой-нибудь пример разберем.
Я его напишу формально,
чтобы место на доске экономить,
а смысл значков на словах скажу.
У нас есть две булевые функции.
Она равна единице,
если количество единиц среди аргументов этой функции нечетно.
То есть сумма по модулю два аргумента.
А вторая функция называется дизъюнкция.
Я ее написал словами,
имею в виду некоторый умысел.
И она равна единице,
если хотя бы один из аргументов равен единице.
Такое определение дизъюнкции,
как оно у вас и было,
когда вам вводили дизъюнкцию.
И я утверждаю,
что из ксора семантически следует дизъюнкция.
Ну почему? Давайте подумаем.
Что значит, что ксор равен единице?
Это значит, что количество единиц среди аргументов нечетно.
Ну а нечетно это значит положительно.
Нольчетное число.
Здесь хотя бы один аргумент равный единице.
Ну а дизъюнкции одного достаточно,
поэтому дизъюнкция обязательно равна единице.
Вот в обратную сторону неверно,
потому что, скажем, дизъюнкция от набора 1,1,0 равна единице,
а ксор от этого набора равен нулю.
Поэтому в обратную сторону следствия нет.
То есть эти высказывания, как говорят, неравносильны.
Множество. А здесь написана одна функция.
Формально я должен был бы написать вот так.
Значит, это вы правы.
Но это тоже будет наше.
Значит, у меня будет так.
Я буду давать определение.
Тут поскольку формализм очень громоздкий,
люди придумали, как с этим справляться,
допуская некоторые вольности.
Вот сейчас я такую вольность продемонстрировал.
Одно элементное множество я просто записал как сам элемент.
Еще я буду писать через запятую.
То есть будет что-нибудь в таком духе f.
Сейчас появится.
Буквально через минуту.
Ну и дальше тоже я буду вводить какую-то формальную конструкцию,
а потом говорить, ну а вот вообще-то на письме мы будем что-то упрощать.
Уже сегодня такое появится.
Формально, да, надо записать вот так.
Я полностью с вами согласен.
Значит, давайте рассмотрим.
Осталось три минуты до перерыва.
И за это время, я думаю, мы успеем рассмотреть два крайних случая.
Может так случиться, что посылки,
вот это множество f еще называется посылками.
Что оно вообще пустое.
Какие функции следуют из пустого множества?
Нет, если бы.
Это равносильно тому, что f от x всегда равно единице.
Дело в том, что какой набор значений переменных вы не возьмете,
все функции из пустого множества равны единице на нем.
Все функции из пустого множества равны единице на нем.
Это утверждение истины.
Значит, наша функция тоже должна быть равна единице.
Кого-то может шокировать такое рассуждение.
Давайте, когда я введу более подробный формализм,
нам все равно нужно будет какие-то примеры разбирать,
мы к этому вернемся.
Это на самом деле следствие того, как определена в логике импликация.
Это мы прям сегодня введем.
У вас была импликация, думаю, год назад.
Вы знаете, что это такое.
Такая булева функция, которая обладает определенными свойствами.
Но и в частности, из лжи следует в том числе истина.
Из лжи следует истина. Это истинное утверждение.
По этой причине нужно вот так рассуждать.
Почему это?
Сказать лучше позже.
Наконец, давайте посмотрим на такую функцию.
Давайте я ее прям вот так вот сразу обозначу.
Вот такой значок, как перпендикуляр в геометрии,
логики обозначают ложь.
Ну и родственные понятия так обозначают.
В частности, я буду так обозначать функцию,
которая тождественно равна нулю.
И давайте посмотрим, когда...
Ага, ну, не успел.
Значит, в перерыве вы можете подумать,
когда такая функция, тождественная ложь
является следствием какой-то системы функций.
Давайте все-таки не будем комкать, после перерыва продолжим.
И я начну с важного замечания.
Мне тут напомнили,
что у вас по этому курсу будет не экзамен,
не экзамен, а зачет.
Не экзамен, а зачет.
Я точно не знаю, потому что на самом деле
этот курс только появился.
И я сам толком не знаю.
История такая, долгое время, много лет был экзамен.
Потом, в прошлом году, внезапно,
экзамен исчез просто посреди семестра.
То есть где-то в начале ноября мне студенты сказали,
у нас в расписании сессии нет такого экзамена,
а вы обещали экзамен.
И я с удивлением обнаружил,
что да, уже оставили только зачет.
Поэтому правила будут немножко не такие,
как на алгебре, где есть экзамен.
А правила будут такие,
что раз зачет с оценкой его будет выставлять
преподаватель семинаров,
и он уже объяснит правила.
Я буду как раз тоже выставлять
100-балльную оценку,
и потом корректировать 10-балльную.
Потому что я уже так привык много лет делать,
и мне не хочется это менять,
а потом в следующий раз снова менять,
потому что вернут экзамен.
Да, это важно,
но единственное, давайте это держать в голове.
Я уточню, я забыл посмотреть,
честно говоря, это важная вещь,
тем более что курс новый, это моя недоработка.
Но
время еще есть,
выяснить зачет или экзамен
мы успеем.
Давайте вернемся к этому вопросу.
Итак, есть множество функций,
из которого следует тождественная ложь.
Что это за множество?
Это множество должно
обладать таким свойством.
Если у нас есть значение переменных,
хотя бы одна из функций равна нулю.
Представьте, что на каком-то наборе значения переменных
все функции обращаются в единицу.
Тогда, по нашему определению,
вот эта функция тоже должна равняться единице,
а она всегда ноль.
Чтобы удовлетворить этому
определению, нам нужно, чтобы
хотя бы одна из функций этого множества
обращалась бы в ноль.
Такие множества
называются несовместными.
И это понятно, откуда восходит.
Напомню, что мы же
говорим про множество функций,
но подразумеваем систему уравнений.
f от x равно единице
для какого-то множества функций.
И это
обычное понятие,
несовместная система уравнения, означает,
что у нее нет решений. Это ровно то, что нам нужно.
И это
будет для нас очень важное понятие.
Поэтому я сразу
несложную лему
логическую докажу про него.
На самом деле можно было
ограничиться только понятием
несовместной системы,
потому что
семантическое следствие
из f следует g,
оно равносильно
тому, что
из f
и отрицание g
следует уже тождественноложно.
Отрицание g определяется очень просто.
Но равно единице,
если
сама g равна 0
и равно 0
иначе.
То есть инвертируем значение функции.
И вот такое
несложное утверждение
о том, что это
равносильно. Сказать, что g является
семантическим следствием f,
или что f и отрицание g
несовместно.
Давайте разберемся, почему тут очень
много случаев. Смотрите, предположим, что
вот это выполняется.
Тогда, если
f от
x равно единице
для всех
функций
нашего семейства,
то g
обязательно
должно
равняться единице. То есть
отрицание g равняется 0.
Ну и тогда
на таком наборе значений переменных
вот это множество уже
не обращается все в единицу,
потому что все в единицу,
а вот это вот ноль.
Ну а если какая-то из этих ноль,
то
и ладно,
уже ноль появился.
То есть
в эту сторону мы доказали. Теперь давайте посмотрим.
Предположим, вот такая система несовместна.
Что это означает?
Это означает, что если
все функции f
на каком-то наборе значений переменных
обратились в единицу,
система несовместна. Значит, на этом наборе значений переменных
отрицание g должно быть нулем.
Иначе бы она была совместна.
Мы нашли бы набор, на котором все функции
равны единице. Ну а раз отрицание g
равно нулю, то g равно единице.
Вот это ровно то, что у нас написано
в определении семантического следства.
Таким образом видно, что
это равносильное понятие.
И к несовместному
про несовместное множество функций
можно доказать теорему, не сложную,
но важную, которая вообще
для логики играет очень большую
роль.
Давайте я, наверное, вот здесь
сотру.
То есть у нас сегодня никаких
сложных
утверждений не будет,
и даже сложных определений не будет.
Сейчас под конец лекции пойдут
чуть более сложные определения.
В обратную сторону.
Смотрите, множество
функций f и отрицание g
несовместно.
Что это означает? Что если
на каком-то наборе значений переменных
все из f обратились в единицу,
то раз оно не совместно, значит
отрицание g должно обратиться в ноль.
Ну иначе было бы совместно.
А раз отрицание g
обращается в ноль, значит само же обращается в единицу.
Это и есть
определение семантического следства.
Значит, это называется
теорема компактности.
Давайте я даже прежде, чем
саму теорему выписывать,
напишу, чем она все-таки
отличается от чего-то другого.
Давайте рассмотрим бесконечную
систему неравенства.
Давайте рассмотрим бесконечную систему неравенства.
İş больше один, больше двух, больше н больше
любого положительного числа.
Ну, думаю всем понятно, что эта система
не совместна.
У нас нет наибольшего числа, то есть
всегда, какой бы мы
число не взяли, найдется натуральное число,
которое больше, чем это.
Значит, система не совместна.
Другой стороны, если я возьму какую-нибудь конечную подсистему, то есть оставлю только конечное количество неравенства,
то такая система будет уже совместна обязательно.
То есть если у вас написано конечное число вот таких вот неравенств,
ну понятно, какое-то число там в правой части самое большое,
ну и ясно, что решение есть все иксы, которые больше этого самого большого будут решать.
То есть если мы говорим про линейное неравенство,
несовместность бесконечной системы, она вот так может оказаться сложной.
Что все конечные подсистемы совместны, а несовместность она в таком, в пределе.
Так вот, для булевых функций это не так.
Собственно, это и есть теорема, которую я хочу доказать.
Она называется теорема компактности.
Значит, если у нас есть несовместная система,
то существует конечная подсистема, то есть под множество,
которая тоже несовместна.
То есть в случае булевых уравнений,
если у нас даже есть бесконечное количество уравнений,
и мы знаем, что система получилась несовместной,
мы знаем, что препятствие будет описываться
конечным количеством уравнений системы.
Каким именно мы не знаем, если система достаточно сложная,
может быть это и не так легко определить,
но существенно, что такая конечная система есть.
Это очень важный факт.
В каком-то смысле на нем построены основные доказательства
самых важных принципиальных теорем и логики.
Сейчас пока совершенно неясно, какое это имеет отношение к логике,
к доказательствам и так далее,
поверьте, что это и есть тот мотор,
на котором работают все доказательства.
Давайте ее докажем.
Теорема не сложная, но все-таки надо бы ее доказать.
Тут мне сразу понадобится некоторое понятие,
которое, я думаю, вам до какой-то степени известно,
но я напомню.
Есть такое понятие, как корневое дерево.
Наверное, вам в курсе алгебры, логики, комбинаторики
такое понятие как-то возникало.
Ну или, по крайней мере, в алгоритмах возникало.
В общем, представляете, что такое корневое дерево.
Так, судя по реакции, лучше про это хоть пару слов сказать.
А что такое дерево?
Это уж точно было.
Раз были графы, то без деревьев не обошлось.
Очень хорошо.
Корневое дерево – это дерево, в котором отмечена вершина,
которая называется корнем.
Но мне нужно, чуть более сложное понятие,
которого у вас, наверное, не было,
а мне нужно, чтобы, значит, тут есть корень,
у каждого корня есть сыновья.
Вершина, которая непосредственно под ним.
Ну и так далее.
И вот мне нужны деревья, которые, вообще говоря,
у нас будут возникать такие деревья, бесконечные.
Причем бесконечными они могут быть в ширину и в глубину.
В ширину это значит, что у какого-то узла дерева
бесконечное количество потомков.
Такое, в принципе, тоже можно себе представить.
Вообще корень, и у него бесконечное количество потомков.
Ну, дерево.
Но это не интересный случай.
Интересный случай, когда количество потомков конечном.
Что?
Что?
Конечный.
Вот как я сказал, конечный.
Значит, ляма о дереве.
Если степень всех вершин конечный...
Вопрос правильный, хотя буквально такой пример нам не нужен,
но, вообще говоря, такая ситуация тоже.
Возможно, что они конечны, но не ограничены.
Если в степени всех вершин конечны
и нет бесконечной ветви...
Бесконечная ветвь, это понятно, что такое.
Это такой путь бесконечный, который начинается в корне,
спускается в один из сыновей корни и так далее.
И продолжается вот такое бесконечное количество раз.
Дерево может быть бесконечным в глубину.
У него может быть бесконечная ветвь.
Так вот, если в степени вершин конечны и нет бесконечной ветви,
то есть дерево не бесконечно в ширину и не бесконечно в глубину,
то оно конечно.
Ну, эта ляма кажется уж совсем очевидной.
Я скажу ее стандартное доказательство.
Доказательство такое.
Давайте строить.
Предположим, что дерево бесконечно у степени всех вершин конечных.
Давайте построим бесконечную ветвь.
Просто предъявим процедуру, которая это строит.
Начинаем с корня.
У него конечное количество сыновей.
Поскольку все дерево бесконечно,
под одним из сыновей должно быть бесконечно много вершин.
Выберем там, где бесконечно.
Опять находимся в такой же ситуации.
Конечное количество сыновей, поскольку всего бесконечно,
то хотя бы на одной ветве бесконечно.
И вот так, выбирая бесконечно каждый раз того сына,
под которым у нас бесконечно много вершин дерева,
мы получаем бесконечную ветвь.
Так что ничего сложного, это можно по-разному оформлять.
Такое рассуждение в таком стиле логикам как-то больше нравится.
А в принципе, можно было бы как-то иначе сказать.
С другой стороны, может быть, это и самое простое доказательство.
Я, честно говоря, не хочу сейчас задумываться.
Теперь доказательства теремы компактности.
Причем тут дерево?
Давайте построим то, что называется полное бинарное дерево бесконечное.
В нем бесконечно много уровней,
отвечающих переменным как раз x1, x2, x3 и так далее.
И когда мы находимся в какой-то вершине,
это означает, что мы уже присвоили значение переменных.
Вот если мы идем по ребру из корня 1,
это значит, что x1 равно 1.
Если идем по 0, то мы падаем вершину, где x1 равно 0 и так далее.
То есть если мы пришли в эту вершину,
про три переменные мы уже знаем.
Первая равна 1, две другие равны 0.
Ну а остальные пока не определены.
Чтобы определить остальные, нужно спускаться по дереву дальше.
То есть это действительно дерево,
и в нем, естественно, есть бесконечная ветвь.
Более того, любая бесконечная ветвь в точности соответствует
одной из последовательств бесконечных последовательств 0 и 1.
Если у вас есть последовательств 0 и 1,
у вас задан путь по этому дереву из корня.
Ну это очевидно, по построению дерева.
Вот это вот такой объект,
на котором мы часто будем что-то рассуждать полезно,
чтобы он появился пораньше.
Теперь давайте теорему компактности попробуем доказать.
Для этого давайте сделаем вот что.
Условия теоремы?
Условия теоремы такое, что если множество булевых функций
не совместно, то в нем есть конечное подножство,
которое тоже не совместно.
Ограничение на ясность?
Да, вот ограничение такое, что если оно не совместно,
то есть конечное несовместное подножие.
То есть это очень общая теорема.
Она на самом деле опирается на дискретность наших функций.
Вот пример с неравенствами числами,
но не совсем на дискретность, даже на конечность,
потому что там у нас тоже дискретная,
много натуральных чисел, но оно бесконечно.
Поэтому мы можем убежать куда-то в предел.
А тут не можем.
Сейчас мы увидим почему.
Давайте я обозначу те функции f, d,
я обозначу те функции z,
которые зависят только от первых d переменных.
Не обязательно от всех.
И теперь я возьму какую-нибудь вершину дерева.
Ей отвечает набор значений первых, скажем, d переменных.
Какие-то значения выбраны.
И я отмечаю эту вершину,
если все функции из вот этого множества равны единицам.
То есть смотрите, в этой вершине нам трудно говорить о значении функции,
если она зависит больше, чем от d переменных.
Если у нее аргументов больше, то как мы не знаем значения вообще говоря.
Поэтому находясь в этой вершине,
нам имеет смысл смотреть только на значения функций из такого множества.
И вот если значения равны единице, мы отмечаем.
У нас получается такое поддерево.
Поддерево, потому что, обратите внимание,
я специально сказал, зависит только от,
но не обязательно от,
но не обязательно от.
Поддерево, потому что, обратите внимание,
я специально сказал, зависит только от,
но не обязательно от всех.
Это я сказал на словами, но только от.
Не зависит от всех остальных.
А от этих тоже может не зависеть.
Поэтому если мы попали, включили эту вершину в поддерево,
то все вершины на пути к корню тоже будут включены.
Потому что вот здесь будут функции, которые сюда тоже входят.
Потому что они зависят только от тех переменных, это разрешается.
Потому что функция зависит не от всех переменных,
а только от части.
Ну вот, получаем поддерево.
Что мы можем про это поддерево сказать?
В нем нет бесконечной ветви.
Потому что бесконечная ветва
означала бы присваивание значений всем переменным.
И посмотрите на построение этого поддерева.
Тогда бы все функции из нашего множества
обращались бы в единицу.
Ну понятно почему.
Потому что каждая функция зависит от конечного числа переменных.
Значит, если у нас есть бесконечная ветва,
мы спустимся на такую глубину, чтобы все эти переменные уже входили.
Ну и тогда наша функция должна равняться единице.
Про любую функцию так можно сказать.
В результате получается, что
существование бесконечной ветви означает,
что все множество f совместно.
А у нас по условию оно не совместно.
Значит, бесконечной ветви нет.
Ветвление 2 вообще.
Не просто конечное, а 2 в данном случае.
Поэтому лемма о дереве применима.
Значит, само дерево конечном.
А что значит, что оно конечное?
Ну в частности означает, что у него какая-то конечная глубина.
В нем конечное число вершин.
И поэтому есть какое-то число n такое,
что путь от корня до любой вершины не длиннее, чем n.
Ну потому что вершин всего конечное число.
Поэтому путь по дереву простой однозначно определен.
Вершины не повторяются.
Значит, их будет не больше, чем количество вершин дерева.
Но это означает что?
Смотрите, если я теперь возьму множество fn плюс 1,
оно конечное.
Потому что сюда входят только те функции,
которые зависят от первой n плюс одной переменной.
Таких функций конечное количество.
Вы их, наверное, подсчитывали на комбинаторике.
Ну это понятно, как возьмем таблицу значения,
поставим произвольным образом 0 единицы и все.
То есть их конечное количество.
Но это множество уже не совместно.
Почему?
Потому что если бы оно было совместно,
то у нас бы здесь была бы какая-то вершина
и был бы какой-то путь в корень.
А можно сказать, что такое вершина?
N?
Да.
Ну, допустим, количество вершин в этом дереве,
которое я выделил.
Отмеченных.
Да, отмеченных.
Таким образом, достаточно взять такое множество.
Оно конечное и оно уже не совместно.
Вот такое несложное рассуждение
позволяет нам использовать вот это соображение компактности.
Ну, последнее, что я по этому поводу хочу сказать,
это про терминологию.
Почему компактность?
У вас, возможно, в анализе это слово возникало.
Я не знаю, это зависит от курса анализа.
Но некоторые преподаватели анализа его тоже любят.
Вообще это понятие из топологии.
Есть такая математическая наука.
Ей вас, насколько я понимаю, систематически никто не учит.
Поэтому я и не буду пытаться вам объяснять,
как это связано.
Это та самая компактность, которая в топологии,
для тех, кто что-то про это слышал.
Но для какого топологического пространства это нужно подумать.
И те, кто немножко знают топологию,
поймут, что надо посмотреть на вот это полное,
бесконечно бинарное дерево.
И какая там топология.
А чтобы не морочить голову остальным,
я больше никаких комментариев говорить не буду.
Но это действительно та самая компактность.
Нам это топологические соображения будут не нужны.
Это другой способ построения курса логики,
где больший упор делается на топологические соображения.
Но поскольку учить топологию еще у нас времени не будет,
то я буду более классическим подходом пользоваться.
Почему Fn плюс 1 не совместно?
Смотрите.
Н это количество отмеченных вершин.
Что?
А вот я же отмечал.
А отмеченная вершина на уровне D отмечается,
если все функции, которые зависят не больше,
чем от первых D переменных,
обращаются в единицу при соответствующем присваивании.
У нас в вершине дерева отвечает частичное присваивание.
Первым переменным мы присвоили какие-то значения.
Соответственно те функции, которые зависят только от этих переменных,
уже приобретают какие-то значения.
Требование, чтобы вершина была отмечена,
что они все равны единице.
Почему Fn плюс 1 не совместно?
Давайте сейчас обсудим.
Предположим, что оно совместно.
Тогда у нас есть такой набор значений,
на котором все эти функции равны единице.
Чтобы не перерисовывать, я продолжу.
Но это означает, что эта вершина отмечена.
А мы уже обсудили, что у нас всего N отмеченных вершин,
и длина пути из дерева в корень не больше, чем N.
То есть мы не могли отметить вершины, которые лежат на глубине N плюс 1.
Тогда бы у нас в дереве была бы N плюс 1 вершина.
Ну даже N плюс 2, на самом деле.
Я сейчас на единичку немного сбился,
но я думаю, что это не должно вас сильно запутать.
Мы просто единицу добавляем к этому числу N,
и видно, что уже сюда мы попасть не можем.
Потому что нам тогда нужен путь, который длиннее,
чем у нас есть в общее количество отмеченных вершин.
Тут очень важна монотонность.
То есть если мы отметили вершину всех предков этой вершины,
мы тоже отмечаем.
Потому что в определении вот этого частичного множества Fn,
я говорю, что это все функции, которые зависят от X1, Xd,
но не обязательно от всех.
Они зависят только от этих,
но может зависеть только от X1 или только от X10.
Поэтому приходим к противоречию.
Именно поэтому оно не совместно.
Хорошо, давайте...
Еще есть 15 минут.
Сделаем следующий шаг.
Далеко мы уйти не успеем, но какой-то следующий шаг сделаем.
Смотрите, я говорил в основном про семантику,
а какой там синтаксис в этой ситуации с булевыми функциями?
Синтаксис – это булева функция.
Нам нужно как-то булевую функцию представить как математический объект.
Но вообще булева функция, поскольку это функция из конечного множества,
это конструктивный объект.
Ее всегда можно задать таблицей значений.
Поэтому к моему самому слабому требованию к функциям это относится.
Но, конечно, задавать булевую функцию таблицей значений очень неэкономно.
Потому что если переменных много, скажем, миллион,
то какая будет таблица значений?
Всего возможных наборов значений 2 в миллионной степени.
Это вы знаете, сколько у нас двоичных слов.
2 в степени N. Количество слов длины N.
Нам нужна таблица значений 2 в миллионный размер.
Не то что денег не хватит на диск, чтобы содержать таблицу значений,
но вообще-то места во вселенной не хватит, чтобы записать столько значений.
Но это к физикам почему не хватит.
Я беру за правду то, что физики говорят, какого размера вселенная,
сколько там элементарных частиц.
Но 2 в миллионный всем понятно, что много.
А тем не менее бывают функции, которые очень легко задать.
Вот я уже задал конъюнцию. Представляете, я задаю конъюнцию миллиона переменных.
Я это сделал очень быстро.
Я говорю, если все переменные равны единице, функция равна единице.
Если хотя бы одна равна нулю, функция равна нулю.
Мне не нужно жесткий диск размером отсюда и до туманности андромеды.
Я вот все, я уже задал функцию.
То есть можно задавать булевые функции гораздо компактнее.
И таких способов много.
Сжатого описания булевых функций.
Я сейчас введу важный для дальнейшего формализм.
Он так и называется, булевые формулы.
Почему я введу его? Там еще есть схемы.
Я не знаю, может вам что-то успели на первом курсе рассказать про это.
Если нет, то вы могли откуда-то еще знать.
Есть схемы, есть разрешающие деревья.
В общем, есть много способов сжатого описания, формального сжатого описания булевых функций.
Но логики по традиции используют вполне определенные.
И я его и введу.
О, не функция, а формулы.
Там были функции, теперь формулы.
Но это, по сути дела, продолжение того же примера.
Просто я теперь изменяю синтаксис.
Я вместо того, чтобы считать, что функция задана в лице и значении,
я ее буду задавать некоторым другим способом.
И делать я это буду следующим образом.
Вы заведомо знаете, вас в прошлом году этому учили,
что есть такие пропозициональные связки или логические связки,
которые объединяют булевые переменные.
Ну вот, конъюнцию мы уже упоминали, дизюнцию, импликацию, равносильность.
Давайте я для определенности просто напишу таблицы.
Поскольку это функция от максимум двух переменных,
то это все легко записать таблицы.
Я сейчас просто напомню.
В общем, вы это, конечно, должны знать.
Но я, несомненно, как страдаю профессиональной деформацией,
как все преподаватели, я считаю, что если что-то студентам сказано, они это знают.
Но при этом я понимаю, что это ложные утверждения.
И не стесняюсь повторять то, что, мне кажется, все знают,
потому что кто-то мог забыть или вообще как-то пропустить.
Ну, самая простая связка – это отрицание, это просто инвертирование бита.
Тут связки, конъюнцию я уже определил, она равна единице только если оба.
Обе переменных равны единице, дизюнция, наоборот, равна единице,
если хотя бы одно равно единице.
Импликация – это очень важная для логики связка.
И она попала на неудачное место на доске.
Ну ладно, слушайте, как я на слова говорю.
Тут место, на котором не хочет писать, не признает.
Ну вот, я постарался.
Значит, она равна нулю в единственном случае,
когда первый аргумент – единица, а второй – ноль.
Первый аргумент импликации называется посылка, а второй называется заключение.
Тома правила определения импликации очень простой.
И это очень важно, потому что именно импликация отвечает за логическое следование,
которое лежит в основе всех рассуждений перехода от одних утверждений к другим.
Ну и еще есть эквивалентность мне понадобится.
Это просто равенство аргументов.
То есть связка, конъюнция – это просто равенство.
Это просто равенство аргументов.
То есть связка эквивалентность равна единице, то есть истинно, если левая и правая части одинаковы.
Это тоже часто используется, потому что понятно,
нас интересует не только истинность или ложность утверждения,
скажем, равносильность.
В математике полно утверждений, что одно свойство равносильно другому.
Естественно, такое нужно.
Ну в общем, есть вот такие связки.
Есть больше, конечно, булевых функций больше,
но логики обычно ограничиваются этим, можно даже и меньше использовать.
А про теориям упоста вам рассказывали.
Что? Да, да, да.
Что, скажем, если мы оставим только импликацию отрицания,
то мы можем выразить любую булевую функцию.
Ну вот, это важно.
И на самом деле я сейчас вам пересказываю примерно то же самое,
потому что, когда вам говорили, можно выразить,
вам как раз говорили, что существует формула,
которая представляет соответствующую функцию.
Но я не уверен, что это сделали.
Очень часто в курсах дискретной математики делается немножко в вольном стиле.
Мне, поскольку дальше придется это использовать именно формально,
я хотел бы проговорить детально, как мы определяем формулы.
То есть, по сути дела, это те самые формулы, с которыми вы имели дело,
содержательно нужно понимать, что это то же самое.
А формально вот, что нам нужно.
У нас есть связки, но мы можем...
Они задают какие-то простые такие блоки,
которые объединяют элементарные высказывания.
Дальше эти связки можно комбинировать друг с другом.
Можно в связку подставить результаты применения других связок.
И получаем формулу.
То есть, формула ее, естественно, поэтому определяет рекурсивно.
Формула – это или переменная, или результат применения связки к двум другим формулам.
И на таком пути у нас сразу возникает представление формулы в виде дерева.
Это не просто корневое дерево, а еще размеченное.
Я нарисую какой-нибудь несложный пример.
Размеченное чем? Внутренние вершины дерева помечены связками.
А листья, то есть вершины степени 1, отличающиеся от корня, они помечены переменными.
Это ровно соответствует моему рекурсивному определению.
Рекурсия вообще всегда тесно связана с деревом.
Потому что вы находитесь возле рекурсии,
вы когда делаете рекурсивный шаг, у вас есть сколько-то вариантов.
Вот вы спускаетесь по дереву вниз.
Когда вы достигаете листа, у вас идет рекурсивный возврат, вы поднимаетесь вверх.
И чем удобно представление в виде дерева,
что сразу понятно, как вычислять значение формулы.
Формуля отвечает булевого функции.
Вот представьте, что я рассматриваю значение формулы вот при таких значениях переменных.
Тогда я просто-напросто подставляю в листья эти значения.
А что я делаю дальше?
Чтобы означать каждую вершину дерева, я просто применяю,
тут написана связка импликации, я ее применяю к тем значениям, которые уже вижу ниже.
Значит здесь будет единица, а здесь, что будет тут единица, тут ноль, значит будет ноль.
То есть вот на таком наборе эта формула ложна.
И у нас сразу видно, что формула, которая задана таким образом, представляет булевую функцию.
Какой недостаток у этого определения?
Ну, недостаток такой. Почему логики его не любят?
Потому что оно апеллирует к понятию дерева.
На самом деле, я слегка вас обманул, не просто дерево, а полное название будет таким.
Плоское корневое помеченное дерево.
И уже судя по тому, сколько там эпитетов, ясно, что если это определять математически аккуратно,
придется говорить много слов.
И логикам это не нравится, потому что возникает какая-то сущность, которая кажется сложной.
Ну, по крайней мере, когда логика возникала, понятие дерева считалось сложным.
Там и теория графов-то была в зачаточном состоянии.
И подозреваю, что сказалось сложным, потому что никто еще не написал учебников в теории графов.
Если бы 150 лет назад кто-то бы удосужился написать такую странную книжку
и заставил бы всех университетов ее учить, то, возможно, логика была бы сейчас по-другому бы излагалась.
Просто когда возникала логика, понять теории графов как таковой не было.
Были отдельные теоремы, которые приходилось очень сложно формулировать,
потому что удобной системы терминологии не было.
Я не уверен, что...
Вообще деревья изучали, с другой стороны.
Теорема Киргофова была доказана еще раньше, и она про Остовные деревья.
Так что не знаю, как-то Киргоф ее сформулировал.
Что-то все-таки было в качестве дерева.
Хорошо.
Как же выходят из этого положения логики?
Они дают другое определение.
Вообще логики любят, чтобы все задавалось максимально простыми математическими объектами.
И самый простой математический объект – это слова в алфавите,
последовательности символов, принадлежащих некоторому алфавиту.
Ну, идеально, как я уже говорил, когда этот алфавит двоичный.
Ну, если он конечный, тоже не страшно.
Но логики согласны и на бесконечный алфавит.
Почему, я надеюсь еще успеть объяснить, но если что, в следующий раз объясню.
Значит, как теперь формула...
Теперь я дам определение, которое будет для данного курса базовым,
потому что так его определяют логики.
Во-первых, я ввожу алфавит.
Алфавит – он бесконечный.
Он состоит из символов переменных, их счетное количество.
А также еще из некоторого количества значков.
Открывающая, закрывающая скобка, и вот значки для связок.
Сколько там связок нам нужно?
На самом деле можно было бы две связки, но пусть будут все, которые я написал.
А переменных бесконечно много.
А переменных бесконечно много, да.
То есть это бесконечный алфавит.
И вот формула – это слово в этом алфавите.
Слова в алфавите – это конечная последовательность элементов данного множества.
Они обозначаются а со звездочкой.
Думаю, что эту звездочку вам скоро разъяснят в параллельном курсе алгоритмов.
Уже было, ну прекрасно.
Так значит, формула – это слово такое, что...
Выполняются следующие условия.
Одно из трех.
Или формула – это просто-напросто переменная.
То есть слово длины 1, которое является символом переменной.
Или даже одно из двух.
Или формула...
А, ну из трех, потому что у меня есть отрицание.
Или формула имеет вид...
Дизъюнция, конъюнция, импликация, равносильность двух формул.
Или формула имеет вид отрицания формул.
То есть B и C формулы.
То есть это определение, как вы видите, рекурсивное.
То есть это определение, как вы видите, рекурсивное.
То есть это определение, как вы видите, рекурсивное.
Чтобы его использовать, его нужно вот так вот раскрывать.
Например...
Вот такое слово, в котором 1, 2, 3, 4, 5 символов является формулой.
Почему?
Потому что оно составлено вот по вот этому второму правилу
из двух формул X1 и X2.
А вот такое слово не является формулой.
Потому что любая формула длины больше единицы,
по нашему правилу, должна начинаться с открывающей скобки.
А это слово не начинается с открывающей скобки.
Вы скажете, как же так?
Что ж, нельзя вот так вот писать, обязательно надо расставлять скобки.
Успокой, можно.
Значит, конечно, на письме ставить много скобок очень трудно.
Загромождает.
И мы будем использовать сокращенную запись, опускать скобки,
если понятно, как их восстановить.
Есть общее соглашение о том, какие связки сильнее.
Мы это оговорим.
Но нужно понимать, что вот такая запись, тем не менее, формулой не является.
То есть такое слово длины 3, это не формула.
Но это можно назвать именем формулы или описанием формулы.
Вот ясно, какая формула имеется в виду, если мы такое напишем.
В данном случае просто скобки расставить.
Если написано, кстати, о несколько импликаций, то уже не так ясно.
Вот какая формула имеется в виду?
Слева направо, говорят мне.
Да, на самом деле, если пользоваться стандартными соглашениями расстановки скобок,
скобки надо поставить вот так.
То есть когда применяется одинаковая операция без скобок,
мы считаем, что первой применяется та, что слева.
Ну а дальше у нас есть соглашение о старшинстве.
Но скажем, с импликацией лучше надежнее расставлять скобки,
потому что мало ли кто-то может не знать об этом соглашении.
Ну в общем-то есть способ скобки почти что не использовать.
Иногда они все равно бывают нужны.
Что мы в сущности теперь можем сказать?
У нас появилось строгое определение формулы.
Вот оно формально корректное.
На самом деле я на этом примере объяснил, как его применять к какому-то слову.
Ну нужно просто вот так вот разложить и все.
И более-менее ясно, что дерево и получится.
Вот это дерево называется дерево разбора формулы.
Что неясно, это почему по данной формуле будет всегда получаться одно и то же дерево.
Вот это мы в следующий раз обсудим.
Это не сложная вещь, однозначность разбора.
Это соответствие между деревьями, которые я даже не определил,
и формулами, которые я определил строго, оно взаимно однозначно.
Но это требует некоторого рассуждения, которое давайте в следующий раз я проведу аккуратно, поскольку время сейчас вышло.
