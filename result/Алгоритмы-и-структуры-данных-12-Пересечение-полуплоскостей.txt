У нас сегодня две вещи в плане. Во-первых, это проверка принадлежности точки многоугольнику и, во-вторых, это перещание полуплоскостей.
Ну, сначала принадлежность точки многоугольнику.
Вообще говоря, если формально что-то пытаться доказывать, то нужна такая лемма.
Лемма Жардана.
Которая, грубо говоря, говорит примерно следующее, что если у вас есть многоугольник какой-то, то он разбивает плоскость на два куска, то что внутри и то что вне.
Ну, соответственно, лемма какая-то такая, что если у вас есть простая, замкнутая, ломаная, ну, наверное, даже кривой достаточно, но в нашем случае будет ломаная конечно, без сам пересечений.
Вот, то тогда она разбивает плоскость на две части, как бы то, что, ну, конечная часть, то, что мы социруем с тем, что находится внутри гаммы, и внешняя.
Вот.
Ну, и мы как бы в каком-то смысле не явно будем ей пользоваться, что вот типа есть многоугольник, что такое вообще внутри.
Ну, вот типа у вас плоскость как-то разбивалась на два куска, если вы какой-то многоугольник построили, то что внутри, это как бы, точнее, одна часть, а то что внутри и все остальное снаружи.
Вот, ну и надо соответственно понять, попадает ли какая-то заданная точка внутрь этого многоугольника, внутрь или на границу.
Вот.
Значит, первое, что мы сделаем, это проверим, не лежит ли точка на границе.
Ну, это делать просто, надо просто пробежаться по всем сторонам и проверить, лежит ли точка на отрезке.
Это там вроде какая-то простая задача.
Значит, первое, что мы всегда делаем, это проверка того, что точка лежит на границе.
Вот, после этого мы можем предполагать, что точка либо строго внутри, либо строго снаружи.
И так будет нам рассуждать удобнее, что мы отбрасываем случай, когда точка где-то на границе, значит либо внутри, либо снаружи строго.
Вот, ну тут есть несколько способов, давайте их все быстренько обсудим.
Значит, способ первый через ориентированные углы.
Вот.
Значит, давайте мы как-нибудь ориентироваем наш многоугольник.
То есть, чтобы его вершины были в каком-то порядке.
На самом деле, не важно в каком, просто у нас есть какая-то последовательность вершин на вот это ломанное, в порядке их обхода.
Ну и давайте просто из этой точки будем проводить векторы во все соседние вершины.
И мерить ориентированный угол, под которым мы видим вот эту сторону v и v плюс один.
Значит, померим такой угол, померим такой угол, померим такой угол и так далее.
И вот одождается, что если сумма этих углов отлична от нуля, значит мы внутри иначе снаружи.
Значит, считаем сумму ориентированных углов на все стороны v и v плюс один.
Если сумма равна нулю, то точка вне, иначе внутри.
А? Да нет, вроде правильно. Если ноль, то снаружи. Вне, то есть снаружи.
Не, это как раз соответствует тому слушаю, что у вас есть точка, давайте для простыты вычислим.
И вы представьте, вы стоите здесь, и вы смотрите под какими углами вам видны вот эти вот векторы.
Отсюда видно вот под таким углом. Потом еще вот под таким.
Потом вы начинаете в другую сторону крутиться. Следующая сторона видна вот под таким углом.
Потом вот под таким еще минус, и вот по таким еще минус.
И вы видите, что у вас есть точка.
Потом еще вот под таким. Потом вы начинаете в другую сторону крутиться.
Следующая сторона видна вот под таким углом.
Потом вот под таким еще минус, и вот по таким еще минус.
В итоге сумма как раз в ноль превратилась.
А если вы были внутри, то, ну как бы вот представьте, я стою внутри какого-то там, представь, что это какая-то комната или лабиринт.
Я смотрю на все его стороны вот с такого порядка, типа вращаюсь и смотрю на стороны.
Если там вижу какой-то изгиб, то я немножко назад, потом в обратную сторону кручусь.
Ну и так, чтобы мне все просмотреть, мне нужен как раз угол 2p, скорее всего.
Ну либо плюс 2p, либо минус 2p, чтобы все стороны посмотреть.
Ну вот.
Ну да, но на самом деле не очень большая, потому что вам надо сравнивать, как бы у вас значение, либо ноль, либо оно хотя бы 2p по модулю.
И это все-таки, ну там, очень сильно отличающаяся величина.
Скорее всего, вы не сможете накопить такую огромную погрешность, что 0 и 2p не сможете отличить.
Так что, скорее всего, это не проблема.
Но в целом, да, как бы тут нужна тригонометрия, нужно извлекать углы.
Кстати, напомню, что если у вас есть какой-то угол, вы хотите понять его величину, то лучше всего, точнее всего, через атан-2 это делать.
Если у вас есть вектор u, вектор v, то можно найти этот угол, как атан-2 векторное произведение, запятая скалярное произведение.
Вот это вектор иноцикулярный.
Типа это наиболее точный способ извлечения угла по двум вот этим вот векторам направляющим.
Вот. Ну можно еще здесь дописать букву l, если вы все в лонг и дабл делаете, тогда будет еще точнее.
Но обычно это не особенно важно.
Вот, понятная идея?
Доказывать не умею.
И вам не сводить.
Не, что это корректно.
Ну типа, почему если мы вне, то внедапно сумма углов ноль, а иначе не ноль?
Определение чего?
Ну я бы не сказал.
Да бог узнает.
Ну тогда все остальные надо будет передоказывать в этих терминах. Не хотелось бы.
Правда ли, что мы сейчас на доске показали там атан-2, а просто угол не ориентированный?
Нет, ориентированный именно, ориентированный.
А, ну да, потому что да.
Ориентированный.
Все очевидно.
Вот, хорошо. Ну понятно, проблема, проблема, что здесь тригонометрия.
Может это работает чуть-чуть дольше, чем хотелось бы, потому что тригонометрические функции довольно тяжеловесные.
Вот.
А давайте другой способ.
Значит, давайте дальше считать, что у меня все в целых числах.
Значит, здесь и далее.
Координаты это целые числа.
Координаты всех точек целые.
Вот. Ну и давайте скажем, что у меня все лежит в каком-нибудь большом квадрате.
Например, все внутри какого-нибудь большого квадрата 0а.
То есть при необходимости мы можем наш многоугольник и точку сдвинуть параллельно, так чтобы они все попали в первый квадрант.
Ну и если у нас есть какое-то ограничение на координаты, то мы можем взять достаточно большой а, чтобы все лежало вот в таком вот квадратике большом.
Значит, здесь у вас и многоугольник, и точка.
Вот.
Но идея такая, что давайте мы из этой точки выпустим какой-нибудь луч.
И посчитаем количество пересечений его с границей многоугольника.
С нашей ломаной гамма.
Вот.
Тогда понятно, что, ну в хорошем случае, нечетность количества пересечений.
Значит, что мы были изначально внутри, чётность значит, что мы были изначально снаружи.
А скажем, здесь у меня одна точка пересечения, где-нибудь здесь было бы, видимо три.
Вот они 1, 2, 3.
Где-нибудь здесь было бы 4.
1, 2, 3, 4.
Значит, внутри нечетная,
внутри нечетная
вне
чертная. Это как раз более-менее следует из леммы, что
если вы были внутри, то чтобы вы выйдите за границу вам надо нечетное количество раз
Каждое прещение это либо выход, либо вход
чтобы выйти, вам надо, нечетное количество раз, изменить текущую область, в которой вы находитесь
А если вы были изначально вне, чтобы идти на бесконечности, оказываться опять вне
то нужно четное количество раз смениться. Вошли-вышли, вошли-вышли, какое-то количество раз
Вот, ну, значит, давайте просто пустим какой-то луч, посчитаем
число пересечений с границы ногогольника, со стороны
ногогольника и посчитаем его отчетность.
Вот, в случае, когда у меня координаты вот такие,
можно пустить луч.
Значит, давайте скажем, что пустим луч с направляющим
вектором, ну, например, а, а плюс один.
То есть, из всех таких лучей, которые можно было бы пустить,
я опускаю, ну, примерно, вот, какой-то вот такой вот.
Ну, то есть, это была точка п, это будет точка п плюс
а, а плюс один.
Вот, этот луч хорош тем, что, во-первых, его конец
гарантированно лежит за пределами квадрата, во-вторых,
на этом отрезке никаких других целых точек нету.
На отрезке вот, ну, в общем, на вот этом вот отрезке,
если в нуле его нарисовать, то от нуля до а плюс один
никаких других целых точек нету.
Ну, потому что нам надо, чтобы выполнялось вот такое
соотношение на x, y, а плюс один делить на а, никакой
другой целой точки с такими кронатами там нет.
Вот, значит, в частности тогда на этом луче нет никаких
других целых точек, в частности, нет вершин. На таком луче нет вершин на
долгольниках. Вот, а значит нам достаточно просто попересекаться сторонами и будет
все хорошо. То есть как раз не будет вот таких проблем, как например было бы, если
бы мы через вершины проходили. Давайте нарисую. С вершинами сходу непонятно, как их
учитывать, потому что, например, если бы у меня картинка какая-нибудь была вот такая, ну и луч
проходит через вершину, то ну непонятно это учитывать, как пересечение с границы или нет. В этом
случае надо учесть, как пересечение. А скажем, вот в таком случае мне эту вершину не надо было бы
учитывать, как пересечение. То есть казалось бы и то и то вершина, и там и там формально я с границы,
ну как бы с отрезками пересекаюсь дважды, что здесь две стороны, то что здесь две стороны. Но
здесь ее надо учитывать и здесь не надо, потому что как бы здесь я не меняю свою внутренность
относительно многоугольника. Вот, поэтому с вершинами проблемы, но если мы пустим хороший луч,
то таких проблем не будет и у меня пересечение, если и будут со сторонами, то только по внутренности
сторон, то есть я вершины затрагивать не буду. Поэтому дальше надо будет просто пересечь там вот
этот луч или вообще говорю просто отрезок вот этот вот со всеми сторонами. Вот, и там не будет
проблем с тем, что мы попадаем на вершину, надо просто проверить пересекаются ли два отрезка,
если пересекаются сделать плюс один к счетчику. Вот, ну вроде все. Цио-численность ну для того,
чтобы мы через вершины не проходили, да. Да, значит в итоге мы просто проверяем,
считаем количество пересечений отрезка ну вот это вот от п до конца п плюс а плюс один со всеми
сторонами. Вот, ну а проверка пересекаемости двух целоческих отрезков это какая-то стандартная
задача, которую должны уметь делать. Еще раз. Вот сейчас мы как раз будем разбираться вот
эти случаи сейчас будем все разбираться, как тут правильно все это учитывать. Вот,
значит последний способ, который не боится разобраться с тем, что происходит в случае,
когда мы пересекаемся по вершине, и просто аккуратно все эти случаи разбирается. Значит он
получается на самом деле даже короче чем все остальное с точки зрения кода, но более такой
умный скажем. Значит способ третий давайте вместо вот такого луча пускать просто горизонтальный,
просто горизонтальный направо. Так вот такая рыбка у меня получилась. Ну и вот какой-то такой
вектор я пускаю. Опять хотелось бы посчитать сло точек пересечения и понять лежим мы внутри
или вне. Вот, но здесь мы уже спокойно можем проходить через вершины и давайте поймем что с
этим делать. Ну давайте ведем какой-нибудь счетчик. Сколько раз мы пересекаем границу и давайте
скажем, что пусть AB это очередная сторона, пусть AB очередная сторона. Значит давайте мы переставим
концы так, чтобы A точка Y было меньше равном B точка Y. То есть A лежало ниже чем B. Ну то есть
если у нас есть такой вектор, мы можем переставить концы, от этого отрезок останется, но мы можем без
ограничений общности считать, что первый конец у нас лежит ниже второго. Значит сделаем следующее,
что если мы лежим, значит если наш весь отрезок лежит строго выше чем точка P, значит вот это P,
вот это какой-то отрезок AB. Если A точка Y больше P точка Y или B точка Y меньше равно P точка Y,
то я сделаю континью. Я такие отрезки буду игнорировать, то есть я считаю, что они не вносят вкладов
пересечения. Почему? Ну первый случай это вот такой, что вот у меня была точка P, раз A точка Y больше
P точка Y, AB точка Y еще больше, значит у меня весь отрезок строго выше лежит. Понятно, что он не дает
пересечения. Это первый случай, когда A точка Y больше чем P точка Y, а она выше. Второй случай здесь неравенство не
строгое, мы считаем, что если у меня картина какая-то вот такая, то будем считать, что эта штука не дает
пересечения. То есть в каком-то смысле, да, здесь пересечения есть, но если она, если другая
сторона вот такая, то я тогда это пересечение буду считывать вот для этой стороны, а не вот для этой.
ну просто так договоримся что как бы понятно здесь возникает пересечение но
тогда эта точка лежит на границе в смысле на луче и мы ее учтем в другом
отрезке если нужно поэтому в этом случае мы просто скипнем вот а иначе
если мы не скипнули то давайте просто проверим пересекается ли луч и отрезок
если пересекается увеличим счетчик на 1 как проверить пересекаются они или нет
ну в нормальном случае пересечение это что-то вот такое да как-то можно легко
проверить ну можно например нарисовать вектор из а в п и из а в б и тогда утверждаю что
наличие пересечения равносильно тому что вот такой вот поворот идет по часовой стрелке
ну то есть что чтобы нам чтобы отрезок пересекался с лучом мне нужно как раз да
чтобы чтобы из точки а п виднелось левее чем б только в этом случае будет пересечение вот
ну соответственно давайте так и напишем что если векторное произведение а минус п и
и б минус п б минуса продон на если вот такой вот вектор угол точнее по часовой то есть меньше
равно нуля тогда я делаю плюс плюс кн т ну и в конце если кн т нечетно то значит внутри иначе снаружи
да извините по минусам по минусам по минусам
все весь код
весь код значит же что он работает давайте попробуем понять почему
ну смотрите все те стороны которые находятся для которых а и б по разные стороны вот нашей
прямой от нашего луча мы их правильно учтем то есть пересечение нормальный пересечения со
сторонами которые не через вершины проходит там все нормально нам вот это вот условия в точности
проверяет что луч пересекает отрезок нам осталось только с вершинами надо понять
что если мы как-то внезапно прошли через вершины если луч прошел через вершину то мы ее правильно
учтем давайте порисуем картинки всякие значит как например может наша вершина находиться на
луче ну может могут быть какие-то такие вот ситуации и наугольник где-то вот здесь может
быть такая ситуация наугольник где-то там может быть вот такая ситуация наугольник здесь такая
ситуация наугольник здесь и еще отрезки напрямой тоже может быть да значит отрезок напрямой и
и наугольник где-то вы ну и как бы где-то вот так вот он либо то же самое ниже
да ну короче тут много случаев на самом деле конечно то есть наугольник чем может быть вот такой
так ну эти два симметрично давайте это сотру осталось еще когда у меня вот эти вот
стороны да они не симметричны но да я понял давайте пока скрипнем ладно
вот ну короче какие-то вот в общем давайте такие посмотрим я отрешусь на всех все будет
хорошо да ну смотрите значит короче вот утверждается что если вы все возможные способы
лежание точки на ну вершины на на луче нарисуйте то вы короче все правильно обработать но давайте
что-то посмотрим значит вот например вот такой случай тогда что произойдет тогда мы кажется
обе учтем потому что у меня обе вот эти стороны не скипнутся вот это не выполняется это не
выполняется и обе пересекают луч поэтому здесь будет плюс один здесь будет плюс один и в итоге
да ну как бы считаем что это вошли и вышли по факту мы остались внутри все хорошо здесь тут
все тоже самое да у меня такие же две стороны мы считаем что плюс один каждый из них дает только
бы тоже вошли вышли и по факту ничего не изменилось как и надо там и как бы по касательно
заделен наугольник и вышли из него хорошо тут тут не изменилось как бы количестве пересечений
здесь верхняя сторона даст плюс 1 а вторую мы проигнорием потому что она как раз вот такого
типа на что она не строго ниже луча поэтому мы ее скипнем и как раз у меня будет плюс один как
и надо я вышел из многоугольник ну как раз у меня добавил добавил с одной перчатки тут все хорошо
здесь то же самое здесь будет плюс один здесь будет 0 нижнюю сторону я скипаю это как раз как и
надо я схожу в многоугольник делаю плюс один вот здесь что происходит со стороной лежащей на
луче я ее скипаю сама сторона сторона сама по себе ничего не дает потому что это отрезок вот
такого типа да когда б.у меньше но п.у значит сами стороны вот здесь вот лежащие на луче
ничего никакого вклада не внесут вот а в остальном вот эти вот соседние стороны исходящие из этих
машинок они ведутся также как на той доске то есть в этом случае вы дадите плюс один плюс один и
как раз по касательно задеваете многоугольник здесь у вас будет это проигнорится потому
что вот этот случай здесь будет плюс один и как раз как надо до у вас при проходе вдоль
стороны вы выходите из многоугольника как раз нечетности ну чет Lift на один поменялось здесь
оба плюс один как и надо вы были внутри остались внутри здесь это плюс один это 0 надо плюс 1 ну как
потому что вы были вне, а зашли внутрь. Ну вот, все остальные случаи там, если надо,
также разбираюсь. То есть, если мы нарисуем вот так вот, и что еще? И вот так вот, да?
Ну, короче, что бы ни рисовали, все будет нормально, обещаю. Вот.
Не знаю. Думаю, что нет. Вот. То есть, смотрите, кода-то совсем мало. У нас есть просто цикл
по сторонам. Мы смотрим на сторону АВ, если надо, переставляем концы так, чтобы выполнилось
неравенство. Потом IF и IF, и все. И в конце, в конце меряем просто четность количества. Четность
контейнта. Еще раз? Нигде не пользуемся. Ну, в каком-то смысле, да, но тогда вот эти вот все
неравенства надо было бы делать с погрешностью. Ну, в целом, да.
Еще раз, в общем случае, ничего не страхует?
Ну, да. Ну, окей, я согласен с тем, что этот способ годится, получается, даже для не целых,
для не целочисленных. Но, ну, типа, тут надо тогда править вот эти все, все неравенства с
погрешностью. Ну, в целом, да. Да, потому что вот здесь вот эта проверка сработает.
Так. Можно рандомный пускать. Ну, типа, если пустите рандомный, то с вероятностью 1,
вы не попадете в вершину. Если он по-настоящему рандомный. Поэтому можно даже не думать об этом.
Вот. Ну, вот тут на любителя, ну, как бы вот, не знаю, вот этот самый, самый короткий, скажем так.
Все, можно дальше. Хорошо. Значит, ну, тогда давайте переходить к перечечению полуплоскостей.
Задача очень простая. Вам даны на плоскости N полуплоскостей, задаваемых прямыми и какой-то
из двух вот тех полуплоскостей, на которые она разбивает плоскость. Скажем, вот эта прямая и
все, что лежит ниже нее, вот эта прямая и все, что вот здесь вот лежит, вот эта прямая и все,
что там, ну и так далее. Какие-то вот такие вот у вас есть полуплоскости, вам надо их все пересечь.
То есть найти фигуры пересечения. Буквально. Вам даны полуплоскости, найдите, найдите их
пересечения. Опишите их пересечения. Как за эту полуплоскость? Давайте подумаем. Значит,
я буду задавать их в таком виде. То есть у меня также будет три коэффициента, задающие уравнение
прямой, а X плюс B, Y плюс C. И знак? И знак, больше или равно? Всегда больше или равно? Всегда
больше или равно. Ну, потому что, как бы, если меньше или равно, то я могу все коэффициенты
умножить на минус один и сделать больше или равно. Поэтому любую полуплоскость я могу задать таким
образом. Это представление удобно, например, тем, что у вас как бы в полуплоскости лежит
нормальный вектор прямой, AB. Вот если вы нависуете именно, что AB нормальный вектор, то он будет
лежать ровно по ту же сторону, где точки имеют значение относительно прямой и не отрицательное.
Вот такая задача. Есть набор полуплоскостей, вот так вот задаваемых, надо их пересечь,
надо найти фигуру пересечения. Давайте подумаем, как она вообще может выглядеть. Что такое фигура
пересечения, если у нас есть такая картинка? Ну, в хорошем случае, как вот в этом, например,
это какой-то выпуклый многоугольник. Нет. У нас точно получится выпуклая фигура,
потому что мы пересекаем выпуклое множество как минимум. Потому что каждая полуплоскость
это выпуклая штука. И мы уже доказывали, что если у нас есть набор выпуклых,
мы их пересекаем, получится выпуклое. Пересечения любого количества выпуклах – это
выпуклое множество. Поэтому точно получится что-то выпуклое, причем с конечным количеством ст oath.
Вот в таком нормальном случае будет многоугольник. Но бывают, конечно, всякие другие неприятности,
например, у вас может получиться просто что-то не ОГРАНИЧЕННОЕ
например если такие 3 полуплоскости пересечь
то получишь вот такая вот чашка
бесконечно растущая наверх
либо может напротив получиться
выраженный случай типа просто прямая
если вы пересечете вот такую плоскость
и вот такую полуплоскость, то пересечение будет прямое
но аналогично, можно её ограничить на отрезок
если вы вот так вот до пересечёте ещё
даже на точку, если вы пересечете вот так вот, то есть всякие такие выраженные
фигуры, прямая точка отрезок бывает, и еще бывает случай вот такой вот полосы, это
единственный случай, когда граница не связана. Вот, но мы на самом деле не будем
это и фать. Слава богу. Мы обойдемся следующим приемом. Давайте мы погрузим,
точнее ограничиваем всю нашу плоскость каким-то большим квадратом, ну там, минус
cc, грубо говоря. Давайте мы введем bounding box, ограничивающий какой-то квадрат,
минус cc. Да, конечно. Всего можно задать в виде четырех ограничивающих полуплоскостей,
что x больше либо равно, чем минус c, x меньше либо равно, чем c, и то же самое с y. Не очень квадрат,
но неважно. Вот, тогда по крайней мере у меня причина точно будет конечным, потому что я
ограничивался на конечную фигуру, еще дальше я как-то пересекаю, как-то от нее что-то отсекаю,
понятно, что будет что-то конечное. Вот, ну и на самом деле, если c взять достаточно большим,
то я смогу понять, я вот эти случаи тоже в каком-то смысле смогу отследить, что у меня когда фигура
неограниченная. Что значит фигура неограниченная? Значит, при погружении ее в такой квадратик мы точно
что-то из границы пересечем. Ну, например, вот если была такая чашка, то у меня вот там какая-то
область границы bounding box попадет как границу многоугольника пересечения. Вот, ну и тогда,
как бы, если надо, мы можем это отслеживать. То есть, если нам надо сказать, скажем, конечное
пересечение или нет, мы можем понять, попала ли хотя бы какая-то из граничных точек на границу
нашего многоугольника в пересечении. Если да, то значит у меня пересечение бесконечно.
Да, ограниченное имеется в виду. Да, спасибо. Так лучше, конечно. Ограниченное, конечно, да.
Еще раз? Когда пересечение за точка? Ну, c давайте дам побольше, чтобы была не точка, а отрезок.
Вот, если я правильно понял. Ну да, ну тогда давайте c типа сделаем поменьше, чтобы пересечение было
подальше. Вот, то есть, на самом деле, какое надо взять c? C надо взять таким, для которого заведомо
все точки пересечения изначальных полуплоскостей, точнее прямых и задающих, лежат строго внутри
вот этого квадрата. Тогда таких случаев как раз не будет. То есть, в идеале, c такое, что внутри
bounding box лежат пересечения всех пар прямых задающих нашу полуплоскость. Вот, значит,
ну, вообще говоря, если у вас изначальные координаты, значит, если известно, что,
ну, например, в целочисленном случае, если у вас все координаты целые и, скажем, не происходит
какой-то константы a по модулю, т.е. a это ограничение на все коэффициенты, на все координаты точек,
да, то есть, если, скажем, у вас полуплоскости создаются точками, скажем, вот какими-то двумя
точками и, что вот, полуплоскость проходящая через две точки и там по такую-то сторону от них. Вот
если координаты точек задающих эту полуплоскость ограничены по модулю целым числом a, то c достаточно
брать порядка в кубе. Вот, тогда можно показать, что пересечения как раз все попадут внутри,
внутри нашего квадрата. Вот, но, на самом деле, многовато обычно, и на практике там обычно хватает
c гораздо меньше. Вот, но, как бы, формально, строгая теоретическая оценка именно кубическая.
Вот, ну хорошо. Теперь давайте считать, что мы живем в ограниченной вот такой коробочке,
минус c по обеим координатам и нам надо ее пересечь по факту с какими-то другими
полуплоскостями. Не, не будем, это на семинаре. Ну, типа, не будем доказывать и требовать тоже не будем.
Так, ну вот, значит, тогда первый алгоритм за квадрат можно сразу написать.
Значит, давайте изначально скажем, что наше текущее пересечение это наш bounding box,
наш большой квадратик и просто давайте по одной полуплоскости вводить в рассмотрение и отсекать
от текущего многоугольника то, что задает наша полуплоскость. Ну, скорее, скорее просто вернуть
многоугольник или сказать, что фигура пересечения пустая, потому что если многоугольник, ну, а дальше
пользователь сам уже поймет, если он, если многоугольник содержит границу bounding box,
тогда он бесконечный и дальше делай сам что хочешь. Вот. Значит, еще раз, да, мы изначально
храним bounding box и давайте по одной рассматривать полуплоскости и отсекать от нашего многоугольника
то, что отсекается. Скажем, вот пришла такая полуплоскость, окей, мы отрезали вот это вот,
теперь говорим, что вот это наш многоугольник. Пришла вот такая полуплоскость, что-то там отрезали,
ограничили. Пришла вот такая, что-то отрезали, ограничили. Ну и так далее. Вот. Это делается за,
ну, понятно, что у нас вершин будет линейное количество всегда у отн, вершин в нашем многоугольнике
будет у отн и тогда как это сделать? Ну, когда приходит новая полуплоскость, давайте пересечем
просто ее со всеми сторонами текущего многоугольника, поймем вот те самые точки пересечения, где новая
полуплоскость пересекается со старым многоугольником. Вот. Соответственно, она разбивает многоугольник,
в общем случае, на две части. По одну полуплоскость, по другую. Ну и надо оставить ту из них,
которая лежит по нужную сторону. Пересекли, отрезали и сбросили все, что лежало вне полуплоскости.
Вот. Это будет квадрат, потому что для каждой из n полуплоскостей мы пересекаем с предыдущими n,
по факту находим точки пересечения и отбрасываем какую-то половину.
Значит, давайте что-то напишем. Начинаем с bounding box. По одной рассматриваем полуплоскости,
пересекаем с текущим многоугольником. Оставляем ту из частей, которая лежит внутри полуплоскости.
Так. Согласны?
Вот. Ну, естественно, там бывают всякие крайние случаи, когда, например, когда полуплоскость
вообще не пересекается и, скажем, все и так лежит в полуплоскости, тогда мы ее просто игнорируем.
Либо же наоборот пришла полуплоскость, в которой же это условие не пересекаешься со старым
многоугольником. Тогда мы сразу говорим, что пересечение пусто и завершаемся. Больше
нам рассматривать нечего. Иначе она как-то там содержательно пересекается и надо оставить одну
из двух частей. Вот. Ну и поскольку такой алгоритм бывает иногда полезен, что как бы вот этот
квадротичный вполне себе по времени будет удовлетворителен, давайте мы немножко подробнее
посмотрим, как вот это пересекать. Точнее, что происходит, когда ввожу новую прямую,
какую из двух частей оставить. Ну что, давайте быстро, значит, вот про этот алгоритм я скажу,
как его хорошо реализовать можно. Значит, смотрите, мы будем хранить текущий многоугольник,
как пассент с вершин. В1, В2, В3 и так далее, как обычно, вплоть до кунтика. Приходит новая
полуплоскость, скажем, ошитое. Вот пришла новая полуплоскость, ошитое. А, что слово half plane,
полуплоскость. Значит, делаем триральной проверкой, что если все вершины лежат внутри
полуплоскости, то мы ее просто игнорируем, потому что они дают новых ограничений. Это вот этот случай.
Вторая проверка, если, наоборот, все точки лежат вне полуплоскости, то ответ пустое множество.
Иначе давайте мы заведем кунти вектор ответа, куда будем скидывать вершины нового многоугольника.
Вектор вершин нового многоугольника. Вот, и давайте в цикле по всем старым сторонам многоугольника,
вот давайте, пусть у меня есть сторона v и v плюс один. Давайте поймем, какие новые вершины надо добавить в ans,
когда мы рассматриваем очередную сторону. Значит, ну, тут будет четыре случая. Если обе точки лежат в
полуплоскости, тогда давайте мы в ans pushback-нем только вторую точку, вторую вершину. Так,
если я буду писать pb вместо pushback, вы меня убьете? Черт. Ладно, так, второй случай. Что? Я на
доске пишу, а не в контесте. Неважно, значит, если первая не лежала, вторая лежит, то смотрите,
значит у меня сторона пересекает прямую задающую полуплоскость, потому что одна вершина по
одну сторону, другая по другую. Значит, мы переходим между полуплоскостями, мы точно пересекаем
полуплоскость. Вот есть какая-то точка пересечения v и v плюс один и прямой задающий нашу полуплоскость.
То есть, картинка какая-то такая. Но давайте скажем, что q – это точка пересечения h и t, а,
perdон, ну, h маленькая, давайте, h маленькая – это наша полуплоскость. Полуплоскость,
которую мы сейчас рассматриваем. Значит, в этом случае я и q и v плюс один добавлю в ответ.
Какой я сейчас злой. Третья ситуация, когда у меня, наоборот, предыдущий конец лежал,
а новый не лежит, тогда опять есть точка пересечения. И давайте в этом случае мы добавим только ее.
Так, ну и последний, когда обе не лежат. Правильно, когда обе не лежат, то делать ничего не надо.
Ничего. Вот. Если мы так сделаем, то в конце будет лежать последовательность
вершин на многоугольнике, в правильном порядке. Ну, вот здесь, например, почему я игнорирую,
когда я рассматриваю две вершины и обе лежат по правильную сторону, я игнорирую первую из них,
я игнорирую первую. В it и игнорирую добавляю только v и плюс первую. Ну, потому что я как раз считаю,
что в ans у меня, если надо, v и it уже лежит. То есть, я перебираю стороны, it и плюс первую,
плюс вторая и так далее. И если надо, у меня предыдущая вершина, последняя вершина прошлого
отрезка уже лежит в ans. То есть, как вот здесь v и plus первая уже лежит. И если на следующем шаге
я рассматриваю v и plus 1, v и plus 2, они обе опять лежат, мне нет смысла опять добавлять v и plus 1.
Она и так там лежит, я добавлю только v и plus 2. Поэтому в этом случае я не добавляю старую,
добавляю только новую вершину. Ну и вот во всех случаях, как бы, я считаю, что у меня построено
какое-то начало, я ищу следующую новую точку на границе нашего многоугольника. В этом случае я
попадаю внутрь, ну как бы, внутрь полуплоскости, пишу, что очередная вершина это q и v и plus 1. В этом
случае я и так лежал и начинаю выходить, но до выхода у меня появляется точка пресечения. В
этом случае точек пресечения нет. Вот, то есть, в конце после этого фора в ans как раз лежит список
вершин в правильном порядке. q это точка пресечения стороны v, вот этой стороны с прямой,
создающей нашу полуплоскость. Нормас? Хорошо. Так, тогда давайте переходить к алгоритмам побыстрее.
Нет, потому что опять, это в каком смысле сортировка и не быстрее, чем NLGN, в общем случае нельзя.
Ну нет, короче, NLGN будет только. Вот, значит смотрите, давайте я разобью наши полуплоскости
на две группы по направлению вектора нормали. Мы понимаем, что вектор нормали у нас смотрит
куда-то внутрь нашей полуплоскости. Давайте разобьем их на две категории. В первой категории
вектор нормали будет каким-то таким, он либо смотрит строго вправо, либо находится где-то
в верхней полуплоскости, исключая вот этот вектор строго влево. То есть, вот этот не лежит, все остальные
там лежат. Это соответствует диапазону углов от 0 до π не включительно. Вторая категория это те
полуплоскости, для которых вектор нормали, ну все остальные, то есть, либо строго влево, либо вниз,
исключая вот эту горизонтальную сторону вправо. Это диапазон углов от π до 2π не включительно.
Разбили полуплоскость на два класса. Дальше, внутри каждого класса давайте отсортируем
полуплоскости вот в этом порядке. Что сначала будет идти полуплоскость вот с таким нормальным
вектором, потом вот с таким, вот с таким, вот с таким и так далее. То есть, я сортирую в порядке
против часовой стрелки вектора нормали всех полуплоскостей внутри каждой категории. Тут
сортировка, тут сортировка. Уже N лог N получилось. Вот. Дальше, я утверждаю, что давайте сейчас
рассматривать будем только первую категорию полуплоскости из первой категории. Будем добавлять
их в таком порядке. И опять будем хранить текущую, как бы текущее пересечение. Вот несколько первых
мы добавили. Ну, например, первая всегда у меня это строго вот такая штука, потому что у меня есть
вот такой вот такая полуплоскость из bounding box. У меня точно есть такая прямая. Дальше, я начну
добавлять какие-то вот такие вот полуплоскости, и они будут все дальше и дальше закручиваться вот
так против часовой стрелки. И в частности, это означает, что при рассмотрении каждой новой
полуплоскости она задает новое содержательное ограничение. Потому что если у меня, вот если я
хоть чуть-чуть прокручу эту прямую в сторону против часовой стрелки, она задаст более мощное
ограничение при пристремлении х к бесконечности. Потому что я увеличил ее уголой
коэффициент, значит она задает самое мощное ограничение на бесконечно больших х. Поэтому точно
каждая новая полуплоскость, каждая прямая будет частью границы вот этого пересечения.
Ну вот, давайте тогда хранить просто, давайте будем хранить вектор, ну или там стэк, неважно,
я буду хранить вектор прямых вектор таких полуплоскостей. Вот в каждый момент времени у меня
текущий ногогольник, точнее текущая фигура пересечения, это что-то вот такое, например.
Приходит новая полуплоскость, какая-то более наклонная против часовой стрелки,
чем последняя рассмотренная. Тогда, в простом случае, надо просто pushback-нуть наш вектор,
то есть она может быть просто конечной стороной, конечной стороной нашего вот такого обвощенного
многоугольника. Либо же, возможно, она проходит где-то вот здесь вот, да. И, соответственно,
тогда последнюю из стэка надо будет удалить, потому что, ну как бы, она задает условия,
которая и так перебивается вот этим вот. Может быть даже такое, что новая рассмотренная
полуплоскость где-то вот здесь вот располагается, мне нужно удалить и вот эту, и вот эту. Но, в общем
случае, мне нужно удалить несколько последних полуплоскостей, потому что у меня была какая-то
вот такая вот картинка, и пришла еще более крутая полуплоскость. Тогда понятно, что она отсекает
несколько последних из нашего стэка, и ее нужно будет добавить последней. Да, ну это, на самом деле,
очень похоже на выпуклооболочку, что несколько последних, пока несколько последних полуплоскостей
нарушают выпуклость в каком-то смысле, мы их удаляем. Но вот здесь условия нарушаем, ну как бы,
нарушается выпуклость, если, скажем, вот если точка переченья двух последних из стэка лежит вне
новой полуплоскости, то можно последнюю смело удалить, если последние две пересекаются где-то,
грубо говоря, правее чем новая наша полуплоскость, то последнее из стэка никакое
содержательное ограничение не задает, её можно удалить из стэка. То здесь вот это и вот это
пересекаются здесь, эта точка не лежит в нашей новой полуплоскости, я, соответственно, вот это вот
тоже удаляю, я удалил изначально вот этот, теперь вот эту, потом у меня последняя становится вот эта,
предпоследняя вот эта, их пересечение уже внутри полуплоскости и, как раз, вот эта
штука это корректная граница нашего многоугольника. То есть мы просто делаем
следующее, мы храним в стеке все наши полуплоскости слева направо вот в таком
порядке. Пока пересечение последних двух лежит вне новой аж, я последнюю удаляю.
Сейчас все разберем. Давайте сначала напишем, что мы внутри категории, внутри первой или
второй категории, мы делаем следующее. Храним стек полуплоскостей, в цикле по всем
новым. Пока пересечение двух последних из стека не лежит вошитое, я удаляю последнюю из стека.
Вот, после этого просто в стек добавляю аж это.
Ну все, тогда после этого у меня посчитаны нижние огибающие по факту и верхние огибающие наших
полуплоскостей. То есть есть у меня какая-то вот такая вот штучка, какая-то вот такая.
Надо теперь их совместить. Потом будем, но это чуть-чуть менее приятно. Значит,
как это сделать? Вот смотрите, давайте я отдельно их нарисую. Вот есть верхняя какая-то, да? Есть,
нижняя и есть верхняя. Давайте сделаем следующее. Давайте мы просто пойдем сканлайном слева направо.
Давайте выпорядочим нашу полуплоскость и слева направо в обоих стэках, в обоих векторах. Вот здесь
такой порядок, здесь такой порядок. Слева направо. Давайте просто пойдем вот так слева направо
и будем отслеживать текущий пересечение. То есть я прикладываю здесь вертикальную прямую,
двигаю ее инатонной направо. И рассматриваю, как верхняя огибающая и нижняя огибающая пересекают
нашу прямую. Сначала печенье пусто, потом в какой-то момент оно начинает расширяться
слева и справа, ну и вот и в какой-то момент оно замыкается, становится пустым. Надо дальше.
Значит, что нужно для этого делать? По факту, у меня и так все прямые упорядочены слева направо.
Мне нужно просто, ну там давайте считать, что у меня все заодно отрезками, да, что вот это отрезки все.
Вот это отрезки, вот это отрезки. Вот я иду слева направо, пересекаю текущие два отрезка в верхнем,
как бы в верхней огибающей, в нижней огибающей. Понимаю, где они там пересекаются, получаю левую
точку пересечения. Затем вот так вот иду, смотрю, какой из отрезков закончился, да, то есть если вот
здесь закончился, то я в нижней огибающей перехожу теперь вот на этот отрезок. Я соответственно
скльжу здесь вот так, здесь вот так, опять смотрю he не пересекался, поэтому двигаюсь дальше.
Здесь пересечения вот здесь, ну точнее переключение вот здесь, двигаюсь теперь монотонно вот так.
Они все еще не пересекаются. Пришел сюда, начинаю двигаться так, ну и так далее. По
факту просто так, монотон двигаюсь, жду когда они в следующий раз пересекутся. То есть у меня есть
указатель сверху, указатель снизу, они монотонно двигаются. Я жду момента, когда у меня пересекутся
стороны. Это будет конец пересечения. Вот, что такое.
Давайте тоже напишем. Это правда. После того, как нашли
нижнюю и верхнюю огибающие, проходим по ним слева-направо.
Типа двумя указателями. Следим за первым и последним пересечением.
Находим первые и последние пересечения.
Ну, как-то вот так. Понятная идея? Вот, это в принципе
можно лизовать. Я не пробовал много раз, что можно. Что?
Ну, как скажете. Вот, хорошо. Можно делать так. Давайте посмотрим
опять-таки второй способ, как можно без вот этого слияния нижней и верхней
огибающей обойтись. Давайте мы объединим вместе первую-вторую категорию.
То есть, вот раньше я делал это отдельно. Сначала в первой, потом во второй.
И потом как-то их склеивал. Теперь давайте на это забьем. Давайте просто все это в один
вектор добавим. Ну, опять-таки в том же самом порядке, что сначала у меня как бы
нижняя огибается, потом верхняя. Ну, просто подряд без разделения на первых три
категории. Ну, как минимум сломается следующее, что когда вы добавляете новую
полуплоскость, у вас, возможно, нужно будет удалять не только из конца, но и
из начала стека. Потому что представьте себе такую картинку. Вот у вас была вот
такая вот фигурка и пришла вот такая вот полуплоскость. Тогда вам нужно
удалить вот эту, а она лежит в начале стека. Это не бог весть какая проблема,
как можно удалять из конца и из начала. Да, волшебная структура дек у нас есть.
Давайте дек будем считать. Я два стека уже не помню, как делается. Вот, ну идея
собственно такая же. Да, у меня есть, вот я в деке храню последовательность
полуплоскостей в порядке их обхода против всего стрелки. Когда добавляется новая,
у меня, возможно, удаляются какие-то последние полуплоскости. Ну, также как
было в первой категории, когда у меня несколько последних пропадают. Либо несколько
первых, как вот здесь. У меня первая, ну как бы самая первая вершина полуплоскости
в деке, она более слабая, чем вот эта новая полуплоскость. Давайте тогда опять из
начала удалять так же, как мы из конца удали, так же из начала. Вот, то есть теперь
уже мы будем хранить полуплоскости в деке. И, скажем, пусть ошитая новая
полуплоскость. Новая полуплоскость. Ну, тут давайте пропишем. Значит, пока две
последние полуплоскости. Не так, да? То есть, ну... А? Ну, в частности, да. Ну,
давайте, давайте написем чего-нибудь более в формате кода. Значит, давайте мы дек
Давайте пропишем, значит, пока две последние полуплоскости...
Не так, да?
То есть, ну и...
А?
Ну, в частности, да.
Ну, давайте, давайте написем что-нибудь более в формате кода.
Значит, давайте мы дек наш назовем, пусть будет это D,
ну и с, пусть будет размер, размер нашего дека.
Размер.
То есть, количество полуплоскостей в нем.
Количество полуплоскостей.
Вот, значит, пока...
S хотя бы два, то есть, пока у нас внутри есть хотя бы две полуплоскости,
и пересечение двух последних не лежит в новой ошитой.
И...
Ну, давайте я напишу, интерсект.
Не хочу, пересечение.
Двух последних, то есть D, S минус первое,
и D, S минус второе,
лежит вне ошитого,
тогда я D делаю pop back.
Вот, аналогично с началом, что пока
S хотя бы два,
и пересечение D0 и D1 дают вне ошитая,
то я делаю pop front получается.
Вот, ну теперь надо понять, когда наша новая полуплоскость добавляется в дек,
потому что, если раньше, когда мы жили, скажем, только в первой категории,
мы понимали, что она всегда добавляется,
потому что у нас дает обязательно какое-то более мощное ограничение.
Тут непонятно, тут она не всегда добавляется.
А именно, я утверждаю, что надо написать примерно следующее.
Смотрите, ну, во-первых, надо отсоединить два момента времени,
если мы еще в первой категории находимся,
то есть, если мы еще вот нижнюю огибающую устроим,
то ее точно добавить в любом случае.
Иначе, если мы уже зашли за вот этот угол 180 градусов,
если мы начали верхнюю устроить,
то мне нужно будет проверять вот эту точку,
пересечение первой и последней полуплоскостей
на принадлежность ошита.
Потому что, например, вот если бы у меня ошита была,
не здесь, а где-то вот здесь вот,
то есть у меня уже и так был корректный многоугольник,
пришла где-то ошита, летящая в воздухе,
она не дает новых ограничений,
поэтому ее нет смысла добавлять, ее не нужно добавлять.
Ее нужно добавлять только если она вот эту вот точку,
пересечение первой и последней полуплоскостей,
если она ее внутри содержит.
Точнее, наоборот, не содержит.
Поэтому условие какое-то такое,
что если ошита еще в первой полуплоскости,
еще в первой категории,
ну как бы мы помним, что у нас есть еще потенциальный,
мы можем разбивать полуплоскость на две категории,
первая, которая нижняя,
вторая, которая верхняя.
Ага.
Или же пересечение
d0 и ds-1.
Так, ну, кстати, как бы s, понятно,
здесь надо еще сделать s--,
потому что я уменьшаю размер здесь и здесь.
Вот, чтобы s всегда был корректным размером.
Ну, или там d0 тушка size везде писать.
Неважно.
Значит, если пересечение первой и последней
лежит вне ашиты,
тогда d pushback ашиты
и плюс-плюс s.
Вот, что-то примерно такое надо сделать.
Так.
Один момент.
В общем, здесь бывают проблемы с тем, что надо
следить, как именно у меня, в общем, не должно быть
у меня пустое пересечение.
Потому что если я просто вот так буду добавлять в
наши полуплоскости, то в какой-то момент может
быть такое, что, ну вот смотрите, у меня, например, было что-то
такое, и я пытаюсь добавить вот это вот.
Тогда у меня что произойдет?
У меня сначала несколько последних удалится, и это
добавится в пересечение, будет у меня вот это и вот
это.
Ну это какой-то бред.
Вот.
Да, это так себе полуплоскость, но вот надо еще отдельно
разобраться с тем, когда у меня на самом деле опустевает
пересечение, потому что вот когда я это делаю, вот
эти все картинки работают только если у меня пересечение
реально не пустое.
Потому что если оно внезапно опустело, то, ну как бы, мне
надо вообще все это стереть, а я этого не делаю, я какой-то
последний удаляю.
То есть я считаю, что у меня все равно вот.
То есть если мы докажем, что пересечение не пустое,
то это алгоритм корректный?
Если мы научимся понимать быстро, что оно пустое, да?
Ну типа того, да.
Ну то есть или другими словами, давайте отдельно еще раз
поймем, не будет ли пустое пересечение, но вообще да,
вообще да.
То есть как бы если все всегда не пусто, то это работает.
Вообще не думаю, не думаю.
Ну то есть как бы, как вы тогда отличите вот этот
случай вот от этого?
Да, это хорошая мысль, что на самом деле в нормальном
случае, в хорошем случае, когда у меня реально получается
какой-то многоугольник содержательный, у меня внутри
дека направление всех нормалей, полуплоскостей, оно заворачивается
как раз против всего стрелки, спокойно вот так, ну как
бы, короче, все кратчайшие повороты между нормальными,
они против всего стрелки.
Да, если мы внезапно начнем вот так вот кучу всего удалять
и затем у нас будет пересечение, значит и эту мы например
добавим, и у меня будет неправильный поворот от последней
к последней, тогда нужно завершиться и сказать,
что все пусто.
Теперь вы уже не поняли, ну давайте напишу, что давайте
я вот это все оставлю, в конце сделаю такую проверку,
значит что, ну еще раз смотрите, в хорошей ситуации, если
у меня перчение не пусто, то у меня последовательность
нормалей, которая лежит в деке, то есть у меня в деке
лежат вот эти вот полуплоскости в порядке обхода вот таком,
а у меня нормалья заворачиваются строго против всего стрелки.
То есть, переход от этого к этому против часовой кратчайший,
от этого к этому против часовой и с便.
Вот я утверждаю что, в случае, когда у меня впервые происходит
опустение, когда пересечение становится пустым, что
происходит, когда у меня пересечение пустое?
Ты знаешь, Jenna Dash какая-то такая, у меня работает скажем
первые вайл, я удаляю все эти вот у меня, это не лежит,
該 не лежит, это не лежит, это не лежит, я всё удалил
кроме последний, потому что последний не с кем пересекать
ну тогда у меня есть вот это и вот, и я утверждаю, что
нужно добавить такое, что если добавить такое слово
что всё сработает, что напр empezarу вот этой штуки
и вот этой, они должны по идее заворачиваться против
часовой, но как видно на картинке они заворачиваются
по часовой, вот отсюда-досюда и по часовой ближайшей
в этом случае надо сказать, что ответы остоль
Вот после того, как мы дописали тот if, если поворот от нормали
ДС-2 к нормали, ДС-1 по часовой, ну да, по часовой, то есть кросс меньше либо равен нуля.
Тогда можно сразу сказать, что ответ это пустое множество. Вот. Ну и так вроде будет все хорошо.
Так сейчас один момент.
Смущает момент, что на самом деле кросс не зависит от того, опять-таки он не различает от этой картинки, где вы двигаете на какой-то...
Не, различает, смотрите, потому что, сейчас, момент, различает, потому что еще раз, я вот эти штуки я по-прежнему делаю.
В случае, когда перещение пусто, у меня удалятся все полуплоскости, кроме Д0. То есть у меня вот этот цикл пробежится, у меня все точки перещения лежат вне аш-итоя, я их все удалю.
Я удалю все полуплоскости, кроме самой первой. Как раз вот в этом плохом случае, когда перещение пусто, у меня в деке будет лежать только Д0 и аш-итоя, я вот здесь ее добавлю.
Вот. Ну и если я сделаю эту проверку, у меня как раз поворот плохой. А в случае, если перещение было не пустым, то у меня перед вот этим аш-итоем будет какой-то предыдущий, какая-то нормальная,
многоугольника и заворот между ними будет как раз против всего и как и надо.
Так. Да. Ну тут, конечно, чтобы в контесты отзагнать.
Сейчас, одну секунду, я пойму, что еще надо сказать. Почти все.
Да, вроде все. Значит, единственное, что я не сказал. Смотрите, значит, все нормально. Тут надо еще сказать аккуратно про параллельные прямые, то есть полуплоскости, у которых задающих прямые параллельно.
Чтобы мы, на всякий случай, чтобы нам не пришлось пересекать параллельные прямые, потому что, да, я здесь многократно вызываю процедуру пересечения, значит, чтобы у меня не было никогда параллельных прямых, давайте разберемся с параллельными прямыми.
Вот. Значит, ну тут все просто. Если у меня есть несколько прямых, если у меня есть несколько полуплоскостей со направленными нормальными, то есть у которых там АВ одинаковые, да, мы берем самую сильную из них, которая задает самые сильные условия.
Ну, это какая из них? Вот если у них АВ одинаковые, то самые сильные условия задает та полуплоскость, в которой С минимальный, я утверждаю.
Ну, да, потому что при больших С это, наверное, все только будет как бы более слабым. Если оно верно для меньшего С, то для большего С это тоже будет верно.
Поэтому если у меня есть вот такие прямые с одинаковыми направляющими векторами, то из них давайте мы выкинем все кроме одной, оставим только ту, где С минимально.
Вот. При этом нам надо различать прямую вот такую и вот такую. Ну, то есть параллельную ей, но противонаправленную.
Ну, очень правильно.
Нет, там везде надо брать минимальное С, потому что они все задаются неравенством большего равного нуля, там просто будет все домножены на минус один, как раз максимум придет минимум.
То есть у меня все полуплоскости заданы вот таким вот неравенством большего равного нуля, поэтому всегда, независимо от того, куда она смотрит, надо всегда выбирать минимальное С.
Правда ли, что мы берем нормальное? Ну, вот как это сделать быстро?
Вот, как это сделать быстро. Можно, смотрите, можно просто все наши векторы нормалии сделать единичной длины, сказать, что А квадрат, то есть Б квадрат равно единице.
Ну, то есть поделить на корень из суммы квадратов. Все коэффициенты можно поделить на корень из суммы квадратов.
Тогда у вас вот эти вот прямые, у этих прямых будут одинаковые просто вектора нормалия АВ, здесь будет АВ, а здесь же будет другой, тут будет минус А минус В.
Поэтому, чтобы проверить, что вот как раз у вас есть пачка прямых, они как бы задают одинаковые условия, если у них одинаковые нормальные векторы.
То есть вы их посортили вот в этом нашем порядке, сначала первая, потом вторая категория, в порядке заворачивания вектора нормалия.
Потом идете подряд, если видите несколько полуплоскостей с одинаковым вектором нормалия, выбираете из них то, у которого С минимально.
Те, которые больше, просто выкидываете.
Вот.
Нет. А нам не надо.
Быстро вот эти игнорировать.
Ну можно просто смотреть на, можно сделать так, можно посортить по направляющим векторам АВ, дальше если АВ одинаково, то в порядке возрастания С.
И сначала вы рассмотрите вот эту, а если рассматриваете новую, которая совпадает с предыдущей, но с другим С, вы это игнорите просто.
То есть у вас сортировка сначала по АВ, потом в порядке возрастания С, тогда вы сначала рассмотрите это, а все остальные, если они совпадают с предыдущей по А и Б, вы их просто игнорируете.
И не добавляете в дек.
Вот.
А так вроде все.
Так, вопросики может?
Простая задача, смотрите.
Ну можно, можно, ладно.
Значит есть набор точек на плоскости.
Нужно найти для каждой из них множество точек наиболее близких к данной, чем ко всем остальным.
То есть вот у вас есть вся плоскость, вам надо понять, какие точки с плоскости лежат ближе всего к этой, чем ко всем остальным.
То есть скажем вот, от этой точки расстояния до этой меньше, чем до всех остальных.
Вот надо понять фигуру, которая ближе всего к этой точке, чем ко всем остальным.
Это называется диаграмм Варанова.
Смотрите, вот у вас по факту есть набор точек на плоскости.
Давайте определим просто ячейку диаграммы Воронова для точки P i,
как все такие точки D, что... давайте Q,
такие, что расстояние от Q до P i в меньшем равном расстояние
от Q до P g для любого g.
Как раз такие точки, которые были же всего к P i,
чем ко всем остальным.
Зовется ячейка диаграммы Воронова.
Ну да, расстояние до P i это минимальное среди всех расстоений до n точек.
Вот, что... а?
Среди всех точек плоскости.
Нет, среди всех точек плоскости, да.
Да.
Значит, что это тогда за фигура должна быть?
Выпукло многоугольник, который задается какими условиями?
Границы как задаются?
Да, серперы на самом деле, потому что вот если у вас есть две точки,
то что такое точка ближе к P i, чем к P 2?
Но вам надо провести между ними СП.
И то что содержит, вот короче это полуплоскость и ближе к П1,
чем к П 2, это полуплоскость ближе к P 2, чем к P 1.
Соответственно, чтобы построить ячейку диаграммы Воронова для точки P i,
вам нужно построить СП между P i и все остальными точками
и пересечь вот те полуплоскости, которые ближе всего к P i.
То есть, вы вот здесь построили серпер,
для этих двух точек построили серпер, для этих двух точек построили серпер
Пересечение вот этих полплоскостей, это будет как раз ячейка диаграмма Воронова.
Ну, смотрите, вам по факту, я вот это вот условие расписываю так.
Давайте я для каждой пары ИЖи...
Ну, надо описать все точки плоскости, попадающие в ячейку диаграмма.
Точки плоскости. Там писано Jr2.
Вот. Наш пересечение, наш фигур, это пересечение полуплоскостей.
Вот. Причем понятно каких, да? Для каждых двух проводим середину перпендикуляр,
и одна из двух, это вот как бы одна из составляющих пересечения.
Тогда, если мне нужно найти ячейку для конкретной точки, мне достаточно построить n середины перпендикуляров,
понять, по какую сторону надо взять полуплоскость, по одну или по другую,
и n-1 такую полуплоскость пересечь.
Тем самым получится как раз одна из ячей к диаграммам Воронова, то, что ближе всего к точке Pi.
Получается, что за n log n можно описать такую ячейку одну для точки.
Если вам нужно всю плоскость разбить, если вам нужно для каждой из n точек описать такую штуку,
то будет что-то типа квадрат-лог.
Потому что для каждой точки примерно n полуплоскости, и вы их все пересекаете.
Вот.
Диаграмма Воронова.
Вот. Ну, на этом тогда все. Спасибо.
