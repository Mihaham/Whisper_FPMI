Значит, вот эта вот тема последняя, она немножко
особняком стоит.
Значит, что я вкратце расскажу так, а у присутствующих
здесь, у кого-то это было уже на семинарах лямбда
исчисления или никого не было, у кого-то было.
Хорошо, ну ладно, значит, я постараюсь так аккуратно
изложить основные вещи.
Значит, ну, во-первых, про что это вообще?
Лямбда исчисления.
Значит, ну, это некоторый другой способ посмотреть
на то, что такое вычислимость, ну, и сформулируешь, что
такое вычислимость.
Соответственно, тут парадигма такая, что все есть функция.
Значит, все есть функция.
Значит, и здесь основная форма записи, вот так вот
выглядит, лямбда х точка какой-то п.
И толкуется это так, что объект p интерпретируется,
понимается как функция от х.
Значит, вот это вот p, давайте я напишу рассмотренное.
Значит, как функция от х.
То есть, например, ну, может быть, написано что-то вроде
лямбда х точка х плюс у, но это означает, что выражение
х плюс у понимается как функция от х, то есть х это
аргумент, а у это параметр.
Так, ну вот, значит, ну и тут вводится некоторая
функция, которая при правильном понимании дает некоторую
модель вычислений.
Так, хорошо, значит, давайте будем в этом разбираться.
Начнем мы, как всегда, с синтаксиса, синтаксис
лямбда исчисления.
Это правило обстроения тернов.
Правило обстроения тернов.
Ой, так.
Так, значит, правило обстроения термов, но их называют там
лямбда термы.
Значит, первое правило базовое, базовое это, что отдельная
переменная это терм, значит, эксперименная, следовательно,
х это терм, но иногда пишет лямбда терм.
Вот, значит, второе правило называется конкатинация.
Конкатинация, то если p и q термы, то тогда, соответственно,
p и q это тоже термы.
Значит, они все лямбда термы, я просто, чтобы быстрее
пропускаю букву, значит, интерпретация здесь такая.
Значит, интерпретация, что вот это вот p, q, но это как
бы функция p, в которую поставлена q, функция p, примененная q.
Вот, значит, и третья это лямбда абстракция, это
как раз вот такой уражение с лямбды получается.
Значит, лямбда абстракция, то если эксперименная, а
p это терм, ну и таким образом, как у нас уже было сформано
в разного вида, получается построение объекта, которое
называется лямбда термами.
Значит, теперь тут, как всегда, много скобок получается,
и чтобы все скобки не писать, вводят соглашение.
Сокращение.
Так, значит, во-первых, если скобок вообще не поставлено,
то они ставят слева направо.
То есть, вот эта штука, это вот, так, сначала p, q, потом r,
значит, потом s.
Так, значит, дальше, если написано лямбда х.пq, то это
будет полностью вот такая штука, лямбда х.пq, в скобках,
и это не то же самое, что лямбда х.п, а потом q.
Тут понятно, что очень много способов протолкать скобок
есть, и чем длиннее, тем больше.
Используется вот такой вот вариант всегда.
Вот, ну и здесь, соответственно, ну тоже, если здесь будет
больше там pq и rs, то тоже это все будет сначала в скобке
заключено и еще разобрано как-то так.
Вот, а лямбда, соответственно, как бы, ну, на все распространяется
после точки.
Да, вот в этом включается соглашение.
Вот, и еще есть такое сокращение, вот такое вот, то после лямбды
может быть много переменных.
Значит, лямбда х.з.п, значит, это понимается так, лямбда
х.лямбда у.лямбда з.п.
То есть, если после лямбды сразу много переменных,
значит, то это вот так вот.
Вот, хорошо, значит, дальше, как обычно бывает, значит,
вхождение переменных бывает свободное и связанное.
Вхождение переменных, значит, свободное и связанное.
Вот, ну, например, если написано, скажем, лямбда х.xy, то тогда
получается, что вхождение х.а связанное, значит, вхождение
у свободное.
Ну, правила, как обычно, то есть, каждый лямбда квантор
связывает все переменные, которые там после точки возникают.
Так, хорошо, значит, теперь есть типичное преобразование
тоже все еще синтоксическое, синтоксическое преобразование.
Значит, первое называется альфаконверсия.
Это можно в кавычках, в принципе, можно и без кавычек
понимать как замена связанной переменной.
Значит, общие правила такое, значит, лямбда х.п преобразуется,
скажем, лямбда у.п, значит, а здесь у вместо х.
То есть, вот эта вот штука, это установка у вместо х.п.
Вот, значит, при этом это может быть во всей формуле
или в какой-то подформуле.
То есть, вот это во всей формуле или подформуле.
Так, хорошо, значит, есть некоторые ограничения.
Нужно, чтобы не возникало проблем с именованием переменных.
Значит, тут может быть две проблемы.
Одна проблема, что старая свободная применная могла
подпасть под действие нового квантора.
Вторая проблема, что под действие старого квантора
подпала новая переименованная переменная.
Значит, некорректная замена.
Значит, первый вариант, ну, например, сам простой, вот так.
Вот лямбда х.ху переименовали в лямбда у.у.
Значит, так делать нельзя.
Вот почему?
Потому что вот эта старая переменная у подпала под действие нового квантора.
А как правильно?
Ну, любую другую переменную можно взять.
То есть, можно, например, написать лямбда т.у.
Так будет корректно.
Так, значит, это первый вариант некорректной замены.
И еще второй вариант, где, наоборот.
В первом варианте у нас что получилось?
Старая переменная подпала под действие нового квантора,
лямбда квантора.
Другой вариант, что, наоборот, новая переменная подпала
под действие старого квантора.
Ну, раз есть переменованный квантор и еще старый,
значит, их минимум два должно быть.
вот ну например давайте только так особо не путаться я вот такой вот так
значит лямбда икс точка икс а тут например лямбда игрек точка икс игрек
вот и я тут тоже значит икс переменную в игрек
значит лямбда игрек точка игрек тут лямбда игрек точка игрек игрек
значит так тоже нельзя
потому что значит что произошло произошло что вот это вот старая
сейчас нет новая переменная да значит смотрите тут как было было что вот этот
вот икс вязан вот этим вот квантором а так в принципе может сказать что
проблем в том что здесь лямбда икс здесь лямбда игрек но нет такой
проблемы нет это мы не запрещаем может быть по одной и той же переменной мы и
в логике это не запрещали и в лямбде тоже не запрещаем вот но проблема в том что
теперь переменная этом месте вязывается вот этим квантором и поэтому смысл
поменялся вот значит так нельзя делать ну опять же на любую другую переменную
можно заменять да то есть можно написать скажем лямбда т точка т лямбда игрек
точка т игрек ну вот хорошо зачем нужна альфа конверсия но затем что если есть
какой-то другой конфликт имен то можно его разрешить ну при помощи
переименование переменной да мы ее где-нибудь переименовали за счет этого может
быть может получиться что какой-то другой другой преобразование возможно
вот так так у меня номерасы одинаково дать это в кружочке будет
вот второе прообразование что это бета редукция
это вообще есть как бы основная вещь в лямбда исчисления это раз есть
применение функции к аргументу значит прообразование следующее тут
лямбда их с точка п я вот здесь именно так стоят скобки на сначала лямбда их с
точка п а потом какой-то кум вот соответственно тут будет преобразование
в п а тут вместо икс
вот ну тоже бывают проблемы значит про значит тут второй проблемы не возникнет
потому что те кванторы которые внутри ку они только внутри ку и будут действовать да и
ни на что в некую не повлияют но первая проблема может возникнуть да свободной
переменной иску может попасть под действие квантора и спа значит здесь
значит некорректный переход да и опять же это может быть тоже такая замена может
быть во всей формуле лифт под формуле на те тоже напишу
по всей формуле или под или под формуле
так но некорректный переход
ну например прям с этим можно с этим же термом можно куда-то некорректный переход
у лямбда и икс лямбда икс точка икс значит а здесь лямбда и дик точка и к с игрек
значит и потом еще и грек значит если на шарики лямбда здесь снимается то есть
лямбда икс исчезает но если механически заменить то получится и гре к
здесь лямбда y точка yy вот ну и опять же получается так нельзя потому что ну вот этот x он связывал
с этим значит был вообще свободный кроме внешнего квантора этот x ничем не связан а когда мы его
заменили на y то получилось что он связан вот этим квантором вот так как же правильно так
давайте я вот здесь вот запишу чтобы не разрывать значит так нельзя как можно
так это экран опять начал гудеть значит надо сначала применить альф конверсию причем здесь
вот внутри да значит именно под формуле да значит например значит лямбда x точка x а тут лямбда z
точка x z и потом y это переход по альфы конверсия и после этого можно уже x заменять на y
и получится y тут лямбда z точка y вот и получается что тот квантор который нам мешал
я переименовал из y z теперь он нам не мешает вот то есть тут сначала альфа потом бета
так
гудит а не за это на микрофоне слышно это другого нет ну ладно тогда сейчас давайте
храню на всякий случай
так хорошо
значит то теперь с этим можно делать ну а есть такая общая теория про равенство лямбда термов
значит определение а ну кстати сейчас давайте сначала прежде чем определение тверждение
тверждение такое что если из п можно по альфы конверсии перейти в ку то иску можно
по альфы конверсии перейти в п то есть альф конверсии обратимо да что если мы
переносим обратно переносим в одну сторону тогда можно перенести обратно rock
iga
в
былоexpensive не будет доказывать а потому что формально нужно определить что
такое корректный переход как ты там по индукция иcentrically как будто корректно
то другую тоже корректно да то есть если в одну сторону взять имен нет
другую тоже нет482 это довольно понятноن и duckt VIPs
очень простое, ну, как бы не очень сложное, но не очень короткое. Вот так что давайте мы его
пропустим. Вот теперь дальше, значит, определение. Значит, равенство лямбда термов,
значит, это симметричное,
значит, симметричное и транзитивное замыкание, да, значит, отношений
P переходит по Альф конверсии в Q e P переходит по B reduction в Q. Вот, то есть что это значит?
На начале, что если мы перешли по Альф конверсии, то термы равны, если мы перешли по B reduct, то термы
равны, причем или если мы в обратную сторону перешли по B reduct, то термы тоже равны,
если у вас есть такие цепочки то они тоже равны значит иначе говоря что это означает
значит иначе говоря
p равно q если верно следующее значит если существует p 0 равная p дальше p 1 p 2 и
так далее p k t равная q так а вот тут я давайте графическое равенство буду
использовать чтобы отличать от этого значит равны этому разной записи но
значит одно и то же а графическое значит рампасимально равны вот значит
что так дать я вот так нарисую значит из п 0 а тут будет такая двойная стрелочка значит
п 1 п 2 значит п 3 и 4 и так далее да значит и здесь значит пк пк минус 2 пк минус 1
значит где двойная стрелочка означает цепочку альфа или бета альф конвейс или бета редукции
поитая двойная стрелка пожитая да это означает что цепочка в одну сторону
значит поитая альфа пожитая и поитая бета пожитая вот
так хорошо значит наверное понятно да определение
хорошо значит дальше есть такое еще очень важное определение определение что терм
значит терм п находится в нормальной форме значит если к нему нельзя применить бета
редукцию даже после какого-то числа альф конверсии если к нему нельзя применить
это редукцию даже после даже после нескольких альфы конверсии
вот тут пример как раз был на предыдущем слайде да то есть вот здесь вот смотрите вот
к этому терму нельзя принять бета редукцию потому что будет конфликт имен но если сначала сделать
альф конверсию тогда можно поэтому этот терм еще не в нормальной форме вот это уже в нормальной
форме вот значит нормальная форма не всегда существует значит есть простейший пример
пример терма без нормальной формы значит это значит амега значит который выглядит вот так вот
лямбда x точка xx тут лямбда x точка xx значит смотрите как это вообще работает ну значит
смотрите тут как бы вот это вот часть это там лямбда x точка п а вот эта часть это есть соответственно
вот это вот ку подставляется вместо вот этих х то есть это вот сюда вот и вот сюда вот отображает
а лямбда исчезает да то есть получается что значит по бета редукции он приходит в ку ку вот но и
значит он сам себя переходит то есть вот это лямбда убирается ку вместо x получается ку ку но это
и есть он сам вот ну соответственно это будет бесконечно происходить начнем нормальной формы
нету так значит дальше возникает вопрос о единственной о единственности нормальной
формы и тут есть такая теорема чорча россера значит о рамбическом свойствия
значит из нее
в некотором смысле следует единственно нормально форм так о чем так этот шум тоже не слышно
ничего себе значит теорем чорча россера без доказательства у нас то что она тоже
не очень сложная но довольно такая муторная так значит теорем чорча россера вот такая
значит смотрите пусть из термопэя можно прийти рядом преобразований в термку
ну только альфа и бета да без без обратных и также из п можно прийти в терм эр значит
тогда существует т значит такое что иску можно перейти в т и из эр можно перейти в
т то есть это как бы такое замыкание ромба да значит из п мы пришли в ку из п мы пришли в
эр значит и это означает что здесь можно достроить этот ромб ну что собственно ромб и получился
так хорошо значит какие следствия из этой теоремы
значит следствие 1
значит следствие 1 это упрощенное определение равенства
упрощенное определение равенства значит п равно ку если существует
эр значит такое что п преобразуется в эр и ку преобразуется в эр
вот но это следует из того что вот вот в этой картинке да у нас как бы много таких уголков и
мы сначала вот этот вот ромбик достроили потом вот этот дробник достроили и так далее и у нас
там на единицу меньше вершин внизу и дальше еще достраиваем и в итоге такой большой трюгончик
получается давайте я так условно нарисую да у нас была такая картина дальше получается вот
такая картина на единицу меньше там дальше еще на единицу меньше вот и в итоге получается
одна тут вершинка но и если мы по сторонам этой воронки пройдем то как раз придем в эту одну
вершину то есть тут получается вот так вот да и вот так вот вот
так хорошо следствие 1 а следствие 2 это единственная нормальная форма
но можно это по-разному формулировать он пер так что если п равно и оба
п ку в нормальной форме то тогда они отличаются только альфа конверсии да то есть п можно
по альфа конверсия прийти в ку можно формулировать так что значит нормальная
форма единственная с точностью с точностью до альфы конверсия вот так но наказательство
следующее доказательства значит мы применяем да значит применять сначала следствие 1
значит последствию 1 мы получаем что из п и с ку есть преобразование какой-то
р вот при этом поскольку п это нормальная форма то здесь только альфа
только альфа так как п это нормальная форма и здесь тоже только альфа только альфа так как
у это нормальная форма вот ну а дальше получается что альфа обратимо значит в
обратную сторону тоже можно что альфа обратимо и тогда получается что и из r тоже можно попасть
только по альфе ну а тогда и с п в ку тоже
так ну что насколько
понятно это рассуждение
ну ладно значит это вот это в общем основной результат про именно синтаксис да без без
какой-то без какой-либо семантики значит оставшуюся лекцию говорим про различную
семантику то могут означать эти самые лямбда записи но в принципе что угодно на то есть
ими можно кодировать любую информацию ну который вообще кодируется натуральными числами или словами
вот значит тут есть такое важное понятие комбинатор значит комбинатор это замкнутый
замкнутый лямбда терм но то есть там нет свободных переменных да по каждой переменной стоит лямбда
вот значит и при помощи комбинаторов можно как бы моделировать вычисления в разных областях
дискретной математики при помощи комбинаторов
значит можно моделировать вычисления ну или вообще по-другому скажу можно моделировать
математические структуры
значит но например например булева логика значит а что значит моделируем что вообще хотим
значит пример это булева логика
значит мы здесь хотим построить значит хотим построить комбинаторы для истины
лжи и логических операций значит здесь нужно построить значит комбинаторы
ну смотрите лямбда здесь как квантор соответственно квантор может связывать
а замкнутый означает что нет свободных переменных да то есть все связаны все связаны
дайте здесь и пишу значит без свободных переменных
значит нужно построить комбинаторы true false там or and и так далее значит так чтобы они
работали также как соответствующие функции значит так что например or true false равняется true
да или and false true равняется false ну и так далее на чтобы таблица истинности повторялась через вот это
равенство которое понимается как равенство лямбда термов который мы вот только что определили
вот значит это можно делать разными способами но один из классических способов такой так
значит смотрите false
так значит false будет значит лямбда xy точка y true это лямбда xy точка x
значит но дальше для логической операции уже возможно разные варианты да например or
можно вот так вот значит лямбда x значит точка x
ой так два аргумента должно быть лямбда xy лямбда xy точка x дальше true и дальше y
значит как это понимается то если x истина то дизюнкция истина если x сложно то дизюнкция
такая же как y вот а почему это так работает ну давайте посмотрим вот прямо аккуратно
посчитаем значит или or true false or true false значит это будет так и давайте я еще раскрою
сокращение значит лямбда x вынесу отдельно дальше плывет лямбда лямбда y точка x true y
так значит дальше и дальше false так и давайте еще вот эти скобки тоже поставлю чтобы было
понятно как это работает до один раз значит после этого смотрите что получается получается
что я сначала внутри вот этой скобки делаю бета редукцию и вот это тру подставляю вместо x
значит получается что здесь будет лямбда y true true y и потом еще false дальше это будет теперь
false вместо y будет true true false true true false теперь я беру определение true это лямбда xy
точка x лямбда xy точка x true false вот ну и здесь давайте я тоже в два шага напишу сначала
вместо x подставляю получается лямбда y точка true false ну и потом как бы это false можно просто
стереть да и формального поставить вместо y но игрек и там нету поэтому он просто пропадает
а получается равно тру ну вот вот такое пробзание на самом деле можно за два шага не делать да
можно как бы сразу такую двойную бета редукцию да что тру вместо x а false вместо y вот и здесь
тоже да тоже тру вместо x вот это да вот этот тру вместо x вот это точнее вот этот тру вместо
x false вместо y ну вот значит есть еще другой вариант
значит
другой вариант or не используя вообще константы
другой вариант or равняется лямбда x y точка x x y на что если x истинно то дизюнкса равна
x истине если x ложен то дизюнкса равна соответственно y вот значит соответственно
ent получается значит лямбда x y точка x y false на то есть если x истинно то конъюнкса равна y
если сложить конъюнкса ложна значит ну или второй вариант лямбда x y точка x y так если
x ложна то конъюнкса равна x вот ну например нот тоже есть разные варианты но сам простой
будет такой значит лямбда x точка x пол стру а то есть если x истинно то нот x ложна ну и наоборот
так ну вот значит это логические операции ну чего понятно так хорошо начну и дальше
следующий пример предметной области это натуральные числа
натуральные числа нумерал и черча
так значит я давайте буду обозначать числами подчеркнутыми значит 0 подчеркнутая значит это
будет ну на самом то же самое что false значит только чуть-чуть традиционно по-другому
обозначается лямбда fx точка x значит один подчеркнутая и это лямбда fx точка fx дальше
два подчеркнутая тоже не то же самое что true значит один это уже свой номерал 2 это
лямбда fx f от fx и вот здесь очень важно скобки поставить да потому что по умолчанию скобки
другие значит 3 номерал 3 это лямбда fx точка f от f от fx вот ну и так далее и так далее и так
далее с номерал n значит это лямбда fx точка f от f и так далее вот f от fx где соответственно
вот это вот получается n штук значит как значит номерал смотреть ну может на них смотреть так
что вообще тут же как бы два аргумента f и x но вот f это как бы первый аргумент и можно
сказать что как бы функция f переходит вот с такую вот функцию ну а что это такое это как бы такая
n n и итерация вот но вот так это и надо понимать да что n и номерал черча переводят любую функцию
n извините любую функция f в n и итерацию f в том числе нулевой нулевой как бы x это такая
нулевая итерация да что тождественная функция да это как бы нулевая итерация любое да значит
тут все на месте да тут f переходит в f вот ну а дальше получается вот эти итерации вот хорошо
соответственно значит возникает вопрос как значит как тут арифметику выражать
вот так значит какие какие будут вопросы
значит как выражать арифметические действия
значит а именно какие арифметические действия нас будут интересовать значит во-первых
прибавление единицы до инкримент значит инкримент это прибавление единицы дальше
положение умножение значит дальше так я с вами словами напишу сравнение на то
что сравнений бывает много разных там равны неравны и больше меньше там равно нулю не равно нулю и так далее
вот значит сравнение дальше декремент вычитание единицы но тут он понимается как значит декремент
это будет максимум из n минус 1 и 0 на то есть такой целочисленный вычитание если уже 0 то
вычитание ничего не дает если не 0 то это вычитание 1 значит декремент значит дальше вычитание вот и
деление вот то есть четыре базы характеристики арифметических действиях ну и всякие вокруг так
но что-то из этого мы сейчас изучим так хорошо значит вверх инкримент так значит
инкримент будет вот так вот выглядеть но опять же есть самые разные способы собственно и
думералы не только черча бывают но вот самое простое значит инкримент вот так вот смотрите
внимание лямбда nfx значит а тот будет f вот nfx вот значит почему это так работает ну
давайте прям на примере какого-нибудь скажем инкриментируем двойку значит инкримент двойки
это что такое что мы вместо n сюда поставим двойку лямбда fx точка f от 2 fx так теперь двойку
расписываем по определению но давайте другими буквами да не fx а же y значит здесь будет лямда
fx точка f значит здесь будет лямда же y точка же от же игрек значит еще тут скобки нужные и тут
вот значит дальше получается что вот это вот f подставляется вот сюда вот и вот сюда вот
значит ax подставляется вот сюда соответственно получается что это равняется значит еф вот
это вот остается, ну а дальше получается, а сейчас и лямбда fx остается, лямбда fx никуда не
девается, за этим мы его здесь написали, чтобы он никогда не делась, лямбда fx остается, f
остается, и потом вот эти лямбда исчезают, а вот эти заменяются, как раз f от fx получается,
вот то есть это 3, ну и так со всеми остальными тоже получится,
да, собственно, неважно сколько раз здесь повторяется g, вот это f будет увеличивать на
единицу, вот, значит вот так работает инкримент, так, значит, теперь положение,
так, ну, сложение можно двумя способами делать,
во-первых, сложение это итерированный инкримент, ну, а то есть можно сказать,
что прибавить m к n это m раз прибавить единицу к n, сложение, значит, вариант один,
значит, вариант один, написать следующее, лямбда mn точка m inc n, то есть m раз инкриментировали n,
ну, а вариант два, это использовать похожую конструкцию, значит, вариант два, вот так,
вот, лямбда mn fx точка mf от nfx, вот, ну и тут в целом такая же выкалка получается,
так что я повторять не буду, но здесь как бы кроме вот этого, здесь еще тоже вот это m
появляется, и тут получится, что сначала f подставляется вместо вот той функции, а вместо
x, который там, вот эта вот штука подставляется тоже с замененными f, ну и получается, что сначала
снаружи m раз f, потом внутри n раз f и всего m плюс m раз, понятно, так, хорошо, но, в общем,
похожим образом, значит, похожим образом умножение, значит, умножение, вот так,
вот смотрите, лямбда mn fx точка m, а потом nfx, вот, но я сейчас не буду расписывать подробно,
почему это работает, но идея в следующем, да, что вот в m там повторяется много раз функции,
каждый раз эту функцию мы заменяем на nf, вот, то есть каждую из m мы заменили на nf, и всего,
значит, у нас mn раз будет f применяться, так, ну примерно понятно, да, вот, значит, еще есть возведение
степень, проще всего выглядит, значит, но сложнее всего доказывается, лямбда mn fx, а тут будет вообще
без скобок, но в другую сторону nmfx, вот, то есть, значит, это будет степень, именно m в степени n,
вот, но это я сейчас не буду говорить подробно, почему так, проще всего взять маленький mn,
скажем, 2 и 3, и в одном порядке, в другом порядке посмотреть, что будет происходить, ну и там станет
понятно, почему это экспонент, так, хорошо, значит, дальше следующая вещь, это сравнение с нулем,
да, то есть там не совсем такое, как я написал, сначала сравнение с нулем, потом вычитание,
а потом сравнение любое, вот, ну, собственно, понятно, как это вычитание, да, кстати,
вычитание, давайте я вернусь сюда и допишу, что вычитание же тоже такое со срезкой, да, значит,
то есть sub mn, это будет максимум из m-n и 0, да, то есть, если мы вычитаем слишком много,
то результат 0, вот, ну и тогда понятно, как сравнение делать из вычитания, да, что m меньше
либо равно, чем n, тогда, только тогда, когда такое вычитание равно нулю, а то есть главное
научиться с нулем сравнивать, так, ну, хорошо, значит, как выглядит сравнение с нулем,
сравнение с нулем,
значит, из 0
будет идти так, значит,
лямда n, а тут будет, ой, сейчас, нет,
лямда n точка n, значит, лямда x точка false и дальше true,
вот такая штука, значит, почему она работает,
значит, ну, смотрите, значит, из 0 с нулем, но это получается 0,
последняясь вместо n, значит, будет 0, потом лямда x точка false,
так, из точки, потом true, ну и у нуля тоже как бы два аргумента, соответственно,
стоит только второй из них, а второй как раз здесь true, поэтому будет будет true,
вот, хорошо, значит, дальше, если мы сюда берем какое-то что-то инкрементированное,
значит, 0, n плюс 1, значит, n плюс 1 будет выглядеть так,
значит, будет лямда f, ой, лямда fx, лямда fx точка f, ну и дальше что-то, на самом деле неважно,
что, те остальные n раз там будет, f и потом x, так, значит, такая штука, потом лямда x точка false,
значит, потом true, дальше, смотрите, вот это вот все, значит, лямда x точка false,
оно подставится вот сюда, вот вместо этого f, значит, поэтому здесь получится
лямда x точка false, ну и тут что-то, это что-то уже другое будет, но неважно, что, потому что тут
просто x нету, и поэтому неважно, что он поставит вместо x, результатом будет false,
в общем, действительно получается, что поставили 0, получили true, поставили не 0, получили false,
так, хорошо, значит, теперь декремент, вычитание единицы,
значит, это так называемый трюк к линии, значит, трюк к линии заключается в следующем,
значит, смотрите, рассмотрим такое преобразование, значит, пара x и y,
значит, переходят в f от x и x, что будет, если мы будем интерировать такое преобразование,
значит, но если мы начнем x, x, значит, то тогда будет f от x, x, потом f от f от x, f от x,
значит, и так далее, и после одного шага получится f в n и от x, fn-1 от x,
вот, и идея декремента такая, значит, идея самого трюка, что нужно сделать 1 раз такое
преобразование, взять второй элемент пары, значит, идея, что сделать преобразование n раз,
взять второй элемент пары, вот, но чтобы это работало, нужно вообще уметь, иметь какие-то
комбинаторы для работы с парами, значит, нужны комбинаторы для работы парами упорядочными,
да, то есть должно быть что-то вроде того, что left от pair x и y, это должно быть x, да,
right от pair x и y, значит, это y, вот, ну и на самом деле такие комбинаторы строятся на базе
логических функций, значит, комбинаторы пары,
значит, pair это лямбда xyp.pxy, значит, дальше left это лямбда p,
п.птру и right это лямбда п.пф, значит, почему это работает, ну, смотрите, что такое будет пары xy,
да, значит, pair xy, это будет, ну, без лямбда, да, это будет просто без xay в лямбдах, лямбда p.pxy,
а, например, left от pair xy, значит, смотрите, в left у меня вот здесь вот p, то есть вместо p
нужно вот это подставить, лямбда p.pxy и дальше true, теперь еще одна бета-редукция, что мы вот
это true вместо p подставляем, то есть получается true xy, ну а true xy это x, это мы уже изучали,
вот, ну и справа часть точно так же получается,
да, хорошо, значит, как теперь это все реализовать, если у нас уже есть функция для работы с парами,
так, значит, смотрите, еще сюда иду, тут на самом деле под спудной есть преобразование функции f,
вот такую вот функцию, и нужно сначала это преобразование как-то записать, а потом его
использовать, так, сейчас уже будет немножко сложнее, чем все предыдущее, сейчас, а на семинарах
это кто-нибудь доходил, а в одной группе доходили, да, ну да, ну хорошо, ну, значит, там все понятно,
там в основной программе дальше мы и не идем, ну ладно, сейчас я 2 минуты запишу и немножко
про неподвижную точку поговорим, так, значит, смотрите, возится такая вспомогательная функция,
значит, decrement function,
значит, которая будет вот так вот выглядеть, значит, лямбда fp, точка pair,
значит, здесь будет f от left p, значит, и дальше left p,
вот, то здесь понимается, значит, п понимается как пара, а f, то есть это, собственно говоря,
следующее, это функция берет f и берет исходную пару xy и делает из этого пару f от xx,
значит, поэтому здесь f от left p, значит, здесь left p, вот, хорошо, значит, как теперь ее использовать,
так, значит, теперь deck, значит, deck будет выглядеть так, значит, лямбда nfx, значит, точка
right, значит, дальше будет n раз мы применили deck fn, f, так, и вот так вот, наверное,
что это deck fn, f это же функция от пары, то есть мы n раз итерируем вот это преобразование,
значит, да, еще с чем начинаем, пара из xx, значит, пара xx, так, и теперь вот эту скобку закрываем,
так, ну и вроде, да, вроде скобки никакие не забытые, вроде, должно быть правильно,
смотрите, как это понимать, вот, мы взяли такое преобразование, так, давайте тут какие-то
комментарии напишу, значит, вот это вот сейчас, нет, сначала вот эта вот штука, это что, значит,
xy преобразуется в f от xx, значит, соответственно, вот эта вот штука, когда бы n раз итерируем,
то это получается, то xy преобразуется в fn от x, да, и fn-1 от x,
соответственно, вот эта штука, это просто пара xx, значит, так получается, когда мы вот эту, вот это
преобразование применили вот к этому аргументу, то мы, собственно, получили тоже здесь право написано,
значит, здесь будет f в n и от x, f в n-1 от x, вот, ну а потом мы взяли правую часть,
значит, правая часть, значит, получается fn-1 от x, а потом еще и лямбда fx добавили,
и это как раз получается fn-1 нумерал, да, если я это тоже допишу, да, значит, вот с этим вместе
получается n-1 нумерал, вот, ну вот, значит, так вычитается единица, ну а дальше что-нибудь
еще вычитается просто итерированием, да, то есть дальше можно написать, что, значит, sub это будет
лямбда mn точка здесь, значит, n раз применили декремент m, вот, ну и дальше, например, можно
сравнение greater equal, да, больше либо равно, значит, тут будет лямбда mn точка из 0, значит,
а тут будет sub, только не перепутать какой порядок, если m больше либо равно n, то нужно
из m вычитать, да, то есть тут будет sub nm, вот, ну хорошо, значит, остается рекурсивное
программирование, да, и неподвижная точка, да, есть какие-нибудь вопросы, вот, по обсуждениям,
хорошо, значит, рекурсивное программирование, значит, конечно, отделить рекурсии это
немножко странно, да, и так вообще не делают, вот, но, в принципе, не запрещено, да, то есть, ну,
значит, я буду иметь тут целочисленное деление, да, значит, целая часть m делить на n, значит,
это будет следующее, значит, это будет 0, если m меньше n, да, кстати, а как строго неравенство
получить, ну, просто отрицание противоположного нестрогого, да, отрицание у нас есть,
соответственно, нестрого есть, значит, строгое тоже есть, значит, целая часть m делить на n,
это 0, если m меньше n, либо, значит, инкремент от целой части m-m делить на n, значит, если m
больше либо равно m, так, значит, еще, кстати, заметьте, что нам отдельного оператора if даже
не нужно, да, потому что наши логические значения не сами работают как тернарный оператор, да,
то есть, вот, если истина, то берется второе значение, если ложь, то берется третье значение,
вот, так, ну и получается, например, можно так написать, значит, можно вот то же самое,
значит, записать, тогда я тебе через номерал напишу, div mn, значит, это так,
давайте я прям помею местами, чтобы je использовать, значит, je mn, дальше будет ink,
значит, increment от div от sub mn и n, так, и increment закрыть, ну а иначе просто 0,
вот так вот, вот, и что здесь получается, получается что-то вроде уравнения, да, что у нас
слева и справа есть как бы неизвестный комбинатор div, да, значит, вот он есть здесь, и вот он есть
здесь, значит, и получается, что это уравнение на div, и соответственно нужно найти его корень,
вот, ну, можно говорить тернах корня, а можно говорить тернах неподвижной точки,
значит, тернах неподвижной точки, получается, что у нас есть преобразование, которое берет
произвольную функцию и ее как бы сюда подставляет и получает новую функцию, вот, и div это ее неподвижная
точка, его неподвижная точка, значит, или это div, это неподвижная точка
преобразования, так, ну я не буду там переписывать, так, значит, как это дальше делается, но в духе
преобразования, значит, можно div там fn, смогательная функция для div, значит, это будет
выглядеть так, значит, лямбда gmn, значит, я от нумералов перехожу к переменным, значит, дальше
как там, как там, да, значит, gmn, значит, дальше инкремент от div, ой да, правильно, да,
значит, инкремент aj от submn, значит, дальше n, так, и ноль, вот, не, ну да, собственно,
можно сказать, что вот как раз у этого преобразования div должен быть неподвижной точкой, вот, то есть мы
хотим, чтобы было следующее, значит, хотим, чтобы div равнялся, значит, div fn div, вот, ну и есть
общий метод, значит, и y-комбинатор, значит, существует общий метод поиска неподвижных точек,
значит, это специальный y-комбинатор, значит, y-комбинатор такой, что для любого f выполнено,
что yf равняется f от yf, но есть разные y-комбинаторы, вот, ну, например, вот такой вот подходит,
значит, пример y-комбинатора, так, ну, например, вот так вот, значит,
лямбда xy точка y от xxy, и еще раз повторяем то же самое, да, то есть y равняется вот
это сам на себя, лямбда xy точка y xxy, вот, значит, тогда смотрите, чему это работает, так, yf, значит,
это лямбда xy точка y от xxy, значит, лямбда xy точка y от xxy, и f, значит, здесь получается, что вот это
вот должно быть подставлено вместо x, да, вот сюда вот, и вот сюда вот, а вот это должно быть
поставлено вместо y, а вот сюда вот, и вот сюда вот, ну, и как раз то же самое получится, значит,
лямбда xy точка y от xxy, значит, лямбда xy точка y от xxy, так, и еще f,
ну, а здесь как раз y получился, то есть это f от yf, вот, ну и, соответственно, вот этот метод
позволяет любую рекурсивную функцию вычислять, то есть сначала записать рекурсивную формулу,
что функция вычисляется через саму себя, каким-то базовым случаем, вот, потом составить вот такое
преобразование, да, значит, такое рекуррентное преобразование, и потом применить y комбинатор,
и как раз будет неподвижная точка. Это мы так определяем, значит, смотрите, откуда оно взялось,
вот здесь вот я вот это div заменил на j, как бы на аргумент, и дальше смотрите, вот если, если я вот
сюда вот еще как бы применю kmn, да, то слева будет как раз divmn, а справа будет как раз вот это
выражение, да, потому что вот эта вот функция g заменится на div, ну а mn заменится как бы на
номерал mn, вот, поэтому, но вот из этого соотношения следует то, что нам нужно, да, если мы левую правую
часть вычислим на паре mn, то будет ровно то, что нам нужно, значит, если мы добьемся, что выполнено
вот это, то выполнено не то, что нам нужно, и значит, это будет нужный, нужный этот самый комбинатор,
ну вот, так, ну вот, значит, это такие самые-самые основные вещи про лямбда исчисления, значит,
там можно, например, какие-то более сложные вещи делать, есть свой аналог проблемы остановки,
значит, а именно нельзя написать лямбда комбинатор, который будет по другим лямбда комбинатором
определять, есть ли у них нормальная форма, да, вместо проблем остановки будет сочетание нормальной
формы, вот, но и в целом получается теория эквивалентной теории вычислимости классической, вот, но не настолько
широко распространенной, но тем не менее многие идеи отсюда используются в функциональном
программировании и соответствующих языках типа хаскела, собственно, хаскел карри это один из
главных создателей этой теории, вот, в честь него даже два языка программирования есть язык хаскела,
а есть язык карри. Всё, я думаю, на этом всё, спасибо за внимание, значит, некоторое количество задач
уже выдано, значит, будет еще последний зачетный листочек в ближайшее время, его можно будет сдавать
до, ну, практически до экзамена, минус время на проверку, то есть экзамен минус два дня,
вот, спасибо, что ходили и слушали, надеюсь, было интересно, ну и до встречи на других курсах,
до свидания.
