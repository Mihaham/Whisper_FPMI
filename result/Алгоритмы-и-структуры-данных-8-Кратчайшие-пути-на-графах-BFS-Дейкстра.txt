Здравствуйте, так мы переходим к небольшому разделу про кратчайшие пути в графах,
значит все что было связано с DFS, ну что я хотел разобрать мы разобрали. Сегодня в
следующий раз у нас будут про кратчайшие пути. Сюжет. Это алгоритмы BFS, Dijkstra,
Floyd, Fort Belman, я звездочка. Такой у нас план на ближайшие две лекции.
Значит начнем с определений. Пусть G, ну это граф, там ориентированный или не ориентированный,
тогда собственно кратчайшим путем или просто расстоянием, да, минимальным расстоянием
между двумя вершинами называется минимально возможное число ребер на пути от U до V.
Тогда кратчайший путь от U до V это путь из U в V с минимальным числом ребер.
Ну естественно кратчайших путей может быть несколько, если у вас есть несколько способов
одинаковой длины попасть из УВ, они все тогда будут кратчайшими. Ну и расстояние, собственно
distance от U до V это просто число ребер в этом пути. Dist УВ это число ребер в этом кратчайшем пути.
Так это расстояние. Значит ну сразу понятно, что из определения вот эта вот штука может
быть плюс бесконечность, если у нас нет никакого пути из УВ, если нет ни одного пути, то максимум берется
по посту множеству, ссори, минимум берется по посту множеству, считаем, что минимум по посту
множеству это плюс бесконечность. То есть эта штука может быть бесконечной. Так это было определение
для невзвешенного графа, когда как бы все ребра имеют одинаковый вес единичка, когда каждое
ребро дает сумму единицы. Дальше, что такое взвешенный граф? Значит это опять множество вершин, множество
ребер, а также некая весовая функция ВВ, которая каждому ребрусу поставляет какое-то число. Значит ВЕ это
граф, ну тоже любой ориентированный или не ориентированный. А ВВ, как функция из Е в Р, это весовая
функция. Ну мы ее будем называть и своей функцией. По смыслу это просто отображение множества ребер
в множество вещественных чисел. Значит тогда, ну дальше все определения наследуются. Крочайший путь
это путь из УВ, на котором сумма весов всех ребер минимально возможна, соответственно расстояние это
та самая минимально возможная сумма. Давайте я напишу так, что весом пути во взвешенном графе
называется сумма весов его ребер. Напишу так, сумма ВВ от Е по всем Е из этого пути П. Если П это наш
путь, мы проходим по всем ребрам на этом пути и складываем вот ВВ от них, то есть тот вес, который
написан на этом ребре. Ну и дальше все то же самое, я давайте не буду это прописывать. Крочайший путь
от УВ это такой путь от УВ, на котором вот это вот, вес которого минимально возможен, соответственно
расстояние это тот самый минимально возможный вес на пути от УВ. И опять он может быть плюс
бесконечность, если нет пути от УВ. То есть такое простое обобщение, представьте, что мы там на
всех ребрах написали какие-то веса и соответственно теперь считаем не число ребер на пути, а сумму тех
чисел, которые написаны. То есть за прохождение дороги у нас есть там какой-то штраф, какая-то
стоимость, вот и мы хотим минимизировать суммарную стоимость, которую мы проходим по пути от УВ.
Так, ну и собственно первый наш алгоритм, это алгоритм поиска крочайших путей в неориентированном
графе. Поиска крочайших путей от одной вершины до всех в неориентированном графе. Это будет БФС.
Расшифровывается это вот так, а значит поиск в ширину. Ну собственно вот эта вот ширина,
как бы в первую очередь мы делаем поиск в ширину. Сейчас я объясню, что это значит.
Идейно он работает следующим образом. Вот есть какая-то стартовершенка С, и мы хотим найти крочайшее
расстояние от нее до всех остальных в нашем графе. Тогда давайте сделаем следующее. Ну понятно,
что крочайшее расстояние от С до С это ноль, да, минимальная, ну минимальная, возможно, длина пути
от С до само себя это ноль. Дальше, вот есть какие-то из С исходящие ребра. Понятно, что до них,
до всех крочайшее расстояние это единица. Ну потому что расстояние ноль быть не может,
потому что ни одна из них с С не совпадает, и есть путь длины 1. До них расстояние единичка.
Дальше, давайте посмотрим все исходящие ребра из них, которые ведут в новую вершинке, то есть не
ведут в С, не ведут в этот же самый слой. Да, это будет там опять какое-то еще другое множество
вершинок. Понятно, что до них расстояние это двойка, потому что есть путь длины 2, нет пути длины 1,
нет пути длины 0. Ну и так далее. Вот в этом будет такой очень простой. Мы просто так по
слоям будем рассматривать все исходящие ребра. Если соответственно мы попадаем в какую-то новую
вершинку, то мы однозначно определяем, что ее вес, расстояние до нее на единичку больше, чем расстояние
вот до предыдущей. И поскольку эта вершина как бы новая, она раньше не была найдена, значит до нее
найдено корректное расстояние. Что есть путь такой длины, и нет пути меньше длины, потому что все
вершины на меньшем расстоянии мы уже нашли. Вот собственно так работает этот алгоритм BFS. Ну и в
ширину значит, что как бы мы встали в вершинку, все ребра, которые из нее исходили, записали,
потом значит для них, для всех тоже прошли все ребра, записали как бы во втором множестве и так
далее. А DFS он наоборот, он как бы шел сначала вот по этой вот веточке, потом поднимался, шел по этой
и так далее. То есть он как бы старался сначала в глубину, а этот сначала в ширину, он максимально
раскрывает текущую вершину. Давайте. Так, я имею ввиду невзвешенным. Да, спасибо, это хорошее
замечание. Тут глупость, конечно, написана. Спасибо. Невзвешенным. То есть когда все ребра имеют вес 1.
Так, напишем код. Как всегда у нас граф будет храниться вектор и векторов. Для каждой вершины
храним список ее соседей, то есть куда можно попасть за один шаг. Дальше будем хранить вектор
расстояний. Для каждой вершины будем хранить насчитанное до нее кратчайшее расстояние. Давайте
я его изначально заполню вот так вот. Что там будет n чисел, все равны плюс бесконечности. Давайте
так и напишу, плюс бесконечность. То есть изначально считаем, что все кратчайшие пути не существуют,
равны плюс бесконечности по весу. Дальше говорим, что dist от s это 0. Говорим, что встаем в стартовую
вершинку, до нее кратчайшее расстояние точно 0. Значит кладем сюда нолик, заводим очередь вершин,
которую хотим рассмотреть, и кидаем в нее s. И наш элдрейтам будет доставать просто по очереди
вершинки из этого q. Достал вершинку, рассмотрел все исходящие ребра, и если они еще были не
рассмотрены, то до них distance это плюс бесконечность. Тогда мы до них нашли кратчайшее расстояние,
выставляем для них dist и кладем вот эти новые вершинки в очередь. Собственно код будет такой.
Пока q не пусто, достаем оттуда первую вершинку, удаляем, рассматриваем все исходящие ребра,
пытаемся обновить расстояние. Я напишу так. По всем tu пробегающим массив g от v. Значит,
если distance от tu это плюс бесконечность, и это новая вершинка, до которой еще не найдено расстояние,
тогда нужно туда положить правильный distance и положить tu в очередь. Наверное, я все-таки здесь
не вмещусь, перейду на вторую доску. Если distance от tu это плюс бесконечность, тогда мы выставляем туда
правильное значение, равное distance от v плюс 1. Потому что у нас есть путь до v вот такой длины,
мы еще добавляем одно новое ребро, из-за этого длина увеличится ровно на единичку.
Distance становится distance плюс 1. И добавляем q в очередь, q push tu. Так, раз-два. Кажется, все.
Вот, ну и на этой картинке давайте посмотрим, что будет происходить. Мы изначально добавили s,
первая вершина, которая обработается из очереди, будет вот эта самая s. Окей, ее достали,
обработали. Рассмотрели все исходящие ребра. Для них, для всех вот этих вот вершинок изначально
distance был плюс бесконечность, поэтому я теперь сюда ставлю единички и добавляю их в очередь.
То есть, соответственно, s я из очереди удалил, а вот эти вершинки в очередь добавил. Дальше
обрабатываем вот эту вот вершинку как первую в очереди. Рассматриваем все исходящие из нее
ребра, для них выставляем distance равные двойке и кладем их тоже в очередь. Поэтому сейчас в очереди
будет вот этот вот кусочек вершин и вот эти вот вершинки. Дальше это рассмотрится, добавится
это, это рассмотрится, добавится вот эти, это рассмотрится, добавится вот эти. Мы перейдем по
сути вот на этот второй уровень, потом от него перейдем на третий и так далее и так далее. Вот
такая реализация, собственно, BFS. Значит, ну здесь все хорошо, а симптотика линейная будет опять.
N это число вершины, N, M это число ребер. Потому что
каждая вершина добавится в очередь, максимум один раз. Значит, каждое ребро рассмотрится
опять-таки, максимум один раз. Потому что, ну, для каждого начала, вот если есть ребро,
мы знаем, что начальный, начальный вершин этого ребра рассмотрится один раз. Значит, это ребро
тоже рассмотрится максимум в один раз, ну и поэтому, да. Т.е. суммально. Вот этот вот фор по всем вершинкам
он отработает за O от m, да, просто за число ребер. Каждый ребер рассмотрится один раз.
Поэтому символитотика, конечно, линейная, как и, собственно, у всего, что у нас было до этого времени.
Так, давайте попробуем доказать корректность. Возможно, она здесь как бы кажется очевидной,
но давайте мы попробуем это плюс-минус формализовать. Сначала следующее. Пусть в какой-то момент времени
dist от q.top равно какому-то числу k. Пусть в какой-то момент времени найдено расстояние до первой
вишенки в очереди, это в точной стеке. Тогда мы покажем следующее, что на самом деле очередь
выглядит следующим образом. Так, давайте я пронумеру. Значит, во-первых, во-первых,
очередь выглядит следующим образом. Сначала идет несколько вершинок с distance равным k,
потом идет несколько вершинок с distance равным k плюс 1. То есть в очереди всегда,
как бы, состояние очереди всегда такое. Несколько вершинок с distance равным k,
и потом несколько вершинок, возможно 0, на расстоянии ровно k плюс 1. Во-вторых,
вот в этот момент времени, если distance для первой вишенки это k, то тогда все вершины
на расстоянии меньше либо равно k уже обработаны, ну точнее, до них найдено правильное расстояние.
Давайте я пишу так. Для всех вершин на расстоянии больше чем k найдено правильное расстояние дист.
То есть если я вижу вершинку в начале очереди с distance равным k, то это значит,
что все вершинки с distance не больше чем k уже как бы обработаны, и в них хранится
в правильном значении дист. Так, ну и третье, если алгоритм когда-то выставляет какой-то дист,
то он его сразу вставляет правильным. То есть если мы для какой-то вершинки v, вот в этой, скажем,
для какой-то вершинки 2 кладем distance от v от 2 равно чему-то, то это присваивание правильное,
и это вот distance, который мы находим, в точности равно расстоянию от v от s до 2. То есть если
алгоритм присваивает distance от 2, то это верное значение, то он присваивает верное значение.
Наш алгоритм никогда ничего не придумывает. Единственное, что вот отсюда следует,
это что он для каких-то вершин может не найти правильный дист. То есть если он distance чему-то
выставил, то это точно правильное значение. Единственное, что он может для каких-то вершин
не найти правильный distance и оставить их плюс бесконечность. Но давайте посмотрим,
что такого тоже быть не может. Так, давайте сначала вот это утверждение докажем собственной
индукцией по нашему алгоритму. Вот давайте делать шаг алгоритма за шагом, шаг за шагом делаем,
проверяем, что всегда выполняются вот эти три утверждения. Что если это было верно вначале,
то это будет верно после каждого шага. Ну сначала нам нужна база, что это утверждение вообще верно.
База, когда, собственно, очередь состоит только из вершинки s. Ну тогда все ясно,
тогда k это 0, k это 0, да, distance от первого элемента очереди это 0. Дальше, как выглядит
очередь? Ну там есть только одно число, одна вершина с distance равным 0. Это в частности очередь
вот того вида, что сначала несколько нулей, потом несколько, возможно, 0 единиц. Это правильный
вид очереди. Это у нас есть. Дальше. Все вершины на расстоянии меньше чем 0 обработаны, для них
найден правильный distance. Но все вершины на расстоянии не больше чем 0 это только s, и для нее
правильный distance мы знаем. Мы его в самом начале до вайла проставляем. Поэтому все вершины на
расстоянии меньше равно 0 обработаны. Это тоже верно, потому что она только одна s, и мы ее изначально
для нее выставляем правильный distance. Ну и третье. Я имею в виду, что вот к тому моменту,
если в очереди distance от q.tоп равно k, тогда все, что мы делали до этого момента, мы все присваивания
делали правильными. Мы сейчас сделали только одно присвоение, что distance от s равно 0. Собственно,
это понятное дело верное присвоение, что все выполненные присваивания пока что корректны.
Корректно.
Ну теперь переход.
Вот пусть в какой-то момент времени очередь имеет такой вид.
Мы хотим показать, что когда мы обработаем эту вершинку первую, у нас будут по-прежнему
сохраняться все три свойства. Так, ну давайте обработаем и поймем. Значит, первое свойство. Как
поменяется наша очередь после обработки первой вершинки, после того как мы ее достанем из очереди,
рассмотрим все исходящие ребра, и какие-то distance обновим, добавим их в очередь. Ну,
понятное дело, что произойдет. Вот это удалится, и возможно в конец еще добавится несколько k плюс
1, потому что у меня добавятся новые вершинки на расстоянии ровно k плюс 1, и я их добавлю в конец
очереди. Значит, вид нашей очереди останется таким же, либо там будет несколько k, и потом
несколько k плюс 1, либо сразу будут просто k плюс 1. Если, скажем, вот это была последняя k, то есть
если, собственно, здесь была ровно одна вершина на таком расстоянии в очереди, мы ее обработали,
удалили, осталось много вершин на одинаковом расстоянии. Поэтому структура в очереди осталась
такой же, как, собственно, в соответствии со утверждением индукции, что сначала несколько одинаковых
чисел, потом несколько чисел больше на один, чем вот это самое число. Первое условие верно. Второе.
Второе. Значит, что все вершины на расстоянии больше чем k, для них корректно найдено расстояние.
Так, ну смотрите, если у меня изначально в очереди было хотя бы две k-шки, тогда утверждение у меня
ну, собственно, ничего нового не появляется. Если я знаю, что к этому моменту у всех вершин
на расстоянии больше чем k все найдено, то после удаления мне нужно, чтобы выполнялось то же самое,
но понять, что это будет верно. Ничего не поменялось, условие не сломалось. Единственный интересный
случай, это когда у меня была кашка единственная, а потом шло несколько сразу k плюс одинов. Я хочу
показать следующее, что к этому моменту, когда я удалю k, когда я целиком работаю, и, соответственно,
в начале очереди будет вот эта вот вершина на расстоянии k плюс один, у меня будут корректно
найдены все дисты до вершины на расстоянии не больше чем k плюс один. А то здесь у меня были только
корректные на расстоянии не больше чем k, а здесь я утверждаю, что на расстоянии не больше чем k плюс один.
Но это не сложно. Смотрите, что значит, что у меня были empirительно найдены все вершины на расстоянии
больше к значит вот у меня когда-то в очереди были все вершины на расстоянии
ровно к все вершины на расстоянии не больше к а сори ровно к а поскольку я
для них нашел правильное расстояние по предложении индукции значит они
когда-то были в очереди вот так подряд я их обработал к моменту куда обрабатываю
последнюю кашку у меня все они побывали в очереди я их как бы все
раскрыл то есть рассмотрел всех их соседей обновил дисты и я тогда утверждаю
что у меня теперь в очереди лежат все вершины на расстояниях ровно к
плюс 1 что после того как я рассмотрел все верхиниlands они ровно к у меня в
очереди держат ровно все вершины расстояние капли с один все вершины на
расстоянии ровно кап tous один так ну значит это почти очевидно
Вот почему. Значит рассмотрим отсюда какую-то вершинку на расстоянии k плюс 1.
Если она находится на расстоянии k плюс 1, то значит есть какой-то путь из s в
с k плюс 1 ребром. Тогда, если я рассмотрю на нём предпоследнюю вершинку,
какую-то u, тогда эта вершина находится на расстоянии ровно k. Да, понятно, что вот есть
путь длины k и нет пути меньше длины, потому что иначе до v был бы путь
меньше длины. Можно было бы приклеить последнее ребро и, соответственно, уменьшить
значит у была где-то здесь значит у раскрыто поэтому такое
ребро ув рассмотрено и для вершинки вы я нашел правильное расстояние вот мы
сейчас доказали что любая вершина расстояние ровно ка плюс 1 лежит сейчас
в очереди ну и наоборот любая здесь лежащая конечно же имеет дистанс равный
ка плюс 1 потому что когда я ну как собственно как когда я какой-то
дист выставляю это собственно можно вот отсюда вот взять что если я какой-то
дист выставляет он правильно насчитывается значит действительно все вот эти вот
вершинки это правильные вершины все множество шин расстояние ровно ка плюс
1 так это это был второй шаг ну и последнее
что все дисты которые я вставляю правильные да давайте это тоже поясним когда я
обрабатываю первую вершинку из очереди вот эту вершинку с расстоянием ка я по
сути перебираю все ребра из нее исходящие которые ведут в еще не
посещенные вершины то есть вершины до которых я еще не знаю дистанции тогда я
значит ставлю что у них у всех дистанции така плюс один вопрос почему это верно
ну смотрите здесь не может быть дистанции меньше ровно ка потому что растут ка то
все вершины на расстоянии меньше ну ка я уже обработал и в них лежит корректный
дистанц по вот этому вот второму тому что я стер на что не может быть у них
меньше ровно ка настоящие расстояния потому что по второму пункту я все такие
уже обработал у них уже найдено корректное расстояние дистанции поэтому здесь хотя
бы ка плюс один но с другой стороны здесь не больше чем ка плюс один потому что есть
путь длины ка вот здесь вот который можно одним ребром дополнить до пути длины ка
плюс один значит после обработки вершины ну во время обработки вот этой вершины первой
в очереди действительно все дисты которые я проставляю они проставятся правильными
значениями ка плюс один то что надо я туда и поставлю вроде все вот мы доказали что эти
три свойства выполняются ну и отсюда собственно вследствие что все дисты мы правильно найдем
все дисты найдутся верно наверное это можно там наверное можно сказать что это очевидно и
можно было не доказывать но мы заодно поняли вообще как выглядит очередь в каждую минуту времени
пока доказывали вопросы
хорошо
думаю нет ну типа непонятно как потому что вот представьте у вас такая картинка какая-то
вы беремность выходить на расстоянии вот дайте вершинки кратчайшие
короче на самом деле если вы так будет сделать то вы у вас экспоненциальное время работы будет
вы по сути перебираете все пути на самом деле в дефессе ну если вы то есть вы дошли вот так вот
нашли какое-то расстояние потом нашли другое и вам нужно от этой вышины опять перезапуститься да что
там сначала было двойка потом единица вам нужно заново обойти все ее по дереву вот и это может
выразиться в экспоненту так тогда значит следующий алгоритм это 0 ка бфс это случай когда все
ребра в графе имеют вес целый от нуля до к давайте напишу так что весовая функция ребра отображает
множество 0 1 и так далее к значит тогда работает следующая идея смотрите мы опять будем использовать
очереди только в этот раз не одну а ну типа n к значит первое замечание такое что если все веса
uri все ребра имеют вес максимум ка тогда максимальный вес который нам который может
получиться он не больше мы n-1 множество к все дисты не больше чем н-1 мозг на кeed
потому что если есть какой-то путь от удове то можно считать что в нем максимум и минус одно
ребро ну давайте это поясни в да что вот если есть какой-то путь можно считать что в нем
максимум n-1 ребро. Ну, действительно, мы знаем, что если есть путь, то есть простой путь по вершинам.
Значит, все вот эти вершины попарно различны. То есть каждое ребро, когда мы проходим по
ребру, дает нам новую вершинку, значит, суммарно ребер я прошел не больше, чем n-1. Потому что изначально
была u, каждое ребро увеличивает число пройденных вершин на 1, значит их суммарно максимум n-1. Значит,
есть путь длины максимум n-1, значит его вес максимум n-1 умножить на k. Если вот здесь все веса
максимум k, то значит его вес максимум вот такой. Поэтому мы точно знаем, что ответ всегда не больше,
чем вот столько. Соответственно, в обычном BFS все дисты максимум n-1. Тогда давайте сделаем
следующее. Мы заведем вот столько очередей. Давайте я для удобства напишу здесь nk, меньше nk. Давайте
для удобства заведем nk очередей. Пронумеруем их там, значит это будет q0, q1, q с индексом nk-1. И будем
делать следующее. Изначально в нулевую очередь положим s, стартовую вершину, из которой мы хотим
найти все дисты. А дальше будем обрабатывать ну собственно так же, как раньше. Вот есть некая вершинка
s, есть из нее исходящие ребра. Они могут быть разных весов. Ну скажем, вот здесь есть какое-нибудь
ребро веса 3. Ну тогда понятно, что если у меня было до s какое-то расстояние x, то до этой вершинки
у меня есть расстояние x-3. Да, возможно, давайте я здесь напишу, вот тут было какое-то x, тогда
здесь x плюс 3. Возможно это не кратчайшее, но нам нужно по крайней мере такие пути учесть, что если,
скажем, кратчайший путь до вот этой вершинки проходит через s, то это расстояние равно x плюс 3.
Значит давайте просто тогда в очередь с номером x плюс 3 добавим эту вершинку u. Что если мы нашли
какое-то расстояние, более короткое, чем раньше было известно до этой вершинки, то я просто добавляю
в очередь с этим, ну с номером равным этому самому расстоянию. И потом я до нее опять дойду,
ее обработаю, рассмотрю все ребра, исходящие из нее, положу опять их в соответствующую очередь и так далее.
То есть теперь у меня как бы именно что по слоям все будет. Сначала рассмотрим все вершины на расстоянии 0,
потом на расстоянии 1, 2 и так далее, и они все, когда я рассматриваю очередную вершинку, они
добавляют какие-то новые вершины в более низкие очереди с большими номерами. Так, давайте тоже
какой-нибудь код напишем. Есть у меня столько очередей. Далее q0 push s dist s равно 0. Ну а все остальные
опять плюс бесконечности. Все остальные равны плюс бесконечности. Дальше запускаем, скажем, цикл x по
номеру очереди. Так, меньше чем nk. Пока x-я очередь не пустая. Неверно, что qx.empty.
Начнем делаем похожую штуку. Достаем первую вершину. qx front и qx.pop делаем сразу.
Рассматриваем все ребра. Вот, ну теперь ребра уже характеризуется не только как бы конечной
вершины ребра, но еще и весом. Поэтому давайте я буду считать, что у меня ребро задается какой-то
структуркой, которая хранит все параметры, там откуда, куда и какой вес. И я вот сейчас в цикле
пройдусь просто все, ну пройдусь по всем ребрам. g от v вот так сделаю. Я считаю, что есть какая-то
структурка edge, да, и собственно мы там итератором пробегаемся по вектору всех ребер, исходящих из v.
Да, да, да, вот как раз это я сейчас хотел сделать. Так, давайте, значит, заведем изначально какой-то
вектор used and false. Значит, он для каждой вершины говорит, правда ли, что мы ее раскрыли, то есть правда ли,
что мы ее когда-то достали из очереди и прошлись по всем ребрам. Так, давайте я вот это вот сотру.
Напишу здесь, если used от v, тогда continue, а иначе used от v равно true, вот так. Значит, смысл такой,
смотрите, у нас в принципе на самом деле каждая вершина может быть во многих очередях, да,
потому что, смотрите, вот, например, мы до нее нашли сначала расстояние x плюс 3, а потом там через
какую-то другую вершину нашли более короткое расстояние, и она тогда будет жать в двух очередях,
например, в x плюс 3 и в какой-то с еще более маленьким номером. И понятно, что нам нужно рассматривать
только когда мы ее впервые нашли, когда до нее, собственно, расстояние найдено кратчайше. Вот,
поэтому, собственно, если мы ее достали из какой-то очереди с большим номером, то я тогда, ну,
это проверяю, да, если мы ее уже видели, то пропускаем, вот, и иначе помещаем использованное,
что вот мы ее сейчас впервые достали. Так, и дальше вот этот вот проход по всем исходящим ребрам.
Ну, да, значит, если distance от e.tu, то есть куда ведет это ребро, больше, чем distance от v,
плюс стоимость этого ребра, e.kost я напишу, тогда нужно обновить и положить в новую очередь.
Distance от e.tu равно distance от v плюс e.kost. И надо добавить вершину e.tu в очередь вот с этим номером,
потому что мы как бы до нее нашли более короткое расстояние, поэтому мы сейчас хотим ее
добавить в эту самую очередь вот, ну, с номером равным этому расстоянию. То есть q с индексом
Distance от e.tu, push e.tu. Вот, кажется, все.
Так, значит, я утверждаю, что, я утверждаю следующее, что когда мы начинаем рассматривать
х-ую очередь, да, то есть когда х становится равным к какому-то значению, у меня в х-ой очереди лежит
следующее. Все вершины на расстоянии ровно х, кроме, возможно, тех, которые достижены из них по
ребрам нулевого веса. Значит, еще раз, когда х, когда я вхожу вот в этом цикле, когда х
приобретает какое-то новое значение, очередь qx имеет следующий вид. Здесь находятся все вершины
на расстоянии ровно х, кроме, возможно, нескольких тех, которые достижены из них по ребрам нулевого веса.
У нас же есть, да, возможно, ребра веса ноль. То есть, возможно, вот здесь вот есть какие-то
ребра веса ноль, которые тоже, по сути, надо сюда добавить. Ну, ничего страшного, мы их, когда вот
эти вершинки будем рассматривать, мы все равно все вот эти вот ребра, исходящие веса ноль, будем
видеть и добавлять их в эту же самую очередь. То есть, вот здесь, если если e.coast это ноль,
тогда мы добавим e.coast в ту же самую очередь, в которой находится v. То есть, в текущую очередь
добавим. Значит, здесь все, кроме тех, которые достижены по ребрам веса ноль, и мы их тоже добавим,
когда будем вот таким образом рассматривать, раскрывать все наши вершинки. Так, ну а дальше,
соответственно, почему это всегда верно? Ну, там понятно, что это верно вначале, что есть изначально
есть вершинка s в нулевой очереди, и понятно, что все вершины на расстоянии ноль это либо s, либо
достижимые из s по ребрам нулевого веса. И мы их тогда все найдем, когда будем раскрывать вершинку s
и там исходящие из нее. Как-то так. Ну и, соответственно, дальше, если я, скажем, правильно нашел все
выше, то есть все вершинки на расстоянии меньше ну x я правильно обработал, тогда в частности, ну понятно,
что вот есть там какая-то следующая очередь x плюс один. Ну, вообще, для всех более низких вершин
distance строго больше, чем x, потому что все меньше равные x я уже обработал. Ну и, соответственно,
что значит, что у вершинки расстояние там x плюс один? Значит, из какой-то из этих вершин есть
ребро такое, что, ну в общем, сумма вот этой расстоянии плюс вес этого ребра это ровно x плюс один.
Ну, значит, собственно, я ее в эту очередь добавил. Все, ну тут давайте там особо без доказательства,
можно считать, что это без доказательства. Ну, какое-то такое интуитивное понимание вроде есть,
что вот когда мы обработали первые x очередей, у нас правильно найдены все вершины на расстоянии
больше, чем x. Вот они тут лежат, они обработаны. Значит, все остальные, ну что такое вершина
расстояния там x плюс сколько-то? Это значит, нужно откусить последнее ребро, посмотрите,
его вес, попасть в вершину расстояния меньше, чем x, ее обработали, значит, это ребро раскрыто,
значит, в эту очередь добавлено на правильную вершину. Вот и все.
Вопросы? Так, ну давайте тогда напишем симптотику. Здесь симптотика такая, м плюс nk. Значит,
nk, потому что у меня, ну как минимум, я изначально завожу nk очередей, ну или там по-другому, можно
сказать, что каждая вершина в худшем случае добавится в k очередей, потому что вот если есть
какая-то вершинка v, и я, ну допустим, представьте, что я изначально нашел до нее там какое-то расстояние
x плюс k по там ребру веса k, потом я нашел до нее расстояние x плюс k минус 1 по какому-то другому
ребру, ну видимо там величный k минус 1 и так далее. То есть в худшем случае вот эту вершинку я для нее
могу обновлять расстояние k раз, когда я рассматриваю ребра все меньше и меньше веса, я получаю все меньше
и меньше расстояние до v, поэтому она может побывать в нескольких очередях, но максимум в k, точнее видимо
в k плюс 1. Отсюда возникает вот это вот слагаемое nk. Ну а m опять из-за того, что каждая вершина на
самом деле раскроется, то есть вот за счет вот этих меток, за счет вот этих меток, у меня каждая вершина
будет для каждой вершины вот этой цикла обработана с максимумом один раз. То есть ходящие
ребра обработаны только один раз, когда она впервые отмечена, впервые обработана в какой-то
очереди. Поэтому каждое ребро рассмотрится один раз, значит по ребрам у меня вот ну просто плюс m слагаемое.
То есть этот алгоритм в принципе хорош, если у вас k там небольшое, ну там. Часто вообще k равно
единице и так называемый 0.1 bfs, когда у вас в графе ребра только вес 0 или 1. Вот, ну для произвольного k
тоже работает, если n на k не очень велико. Окей. Так, да, симпотика, корректность, ну корректность
без доказательств на уровне идеи. Вроде все. Значит дальше двусторонний bfs. Двусторонний bfs.
Ну здесь название говорит само за себя. Только здесь немножко другую задачу мы решаем. Мы находим
расстояние не от s до всех, а от s до t. Раньше мы по сути находили кратчайшее состояние от s до всех
остальных. Теперь хотим от s такое-то фиксированное t найти. Ну тогда давайте просто с двух сторон наш
bfs пускать. Да, вот давайте сначала рассмотрим все вершины на расстоянии 1 от s, потом, ну давайте я
ребра буду рисовать. Стрелочки, то есть. Затем найдем все вершины, из которых есть подлинный 1 в t.
Потом отсюда рассмотрим все вершины на расстоянии 2. Здесь наоборот все ребра ведущие в это множество
получится. Множество вершин на расстоянии 2 от t и так далее, пока они не пересекутся. И вот когда-то
впервые найдется вершина, до которой мы нашли путь из s и из которой нашли путь в t. То есть мы
будем пускать наш bfs как бы вот так с двух сторон, пока какая-то вершина не обработается из обеих
половинок. И с левой, и справа. Тогда я утверждаю, что минимальный ответ это, ну собственно минимум по
всем обработанным вершинкам, distance от s плюс distance до t. Ну давайте это опишем. Запускаем.
Я напишу параллельно. На самом деле имеется ввиду по итерациям последовательно, что сначала
нашли все вершины на расстоянии 1 здесь, потом на расстоянии 1 здесь, на расстоянии 2 здесь, на расстоянии 2
здесь и так далее. Ну не то что параллельно мы запускаем там два потока, если у вас были какие-то
параллелки. Нет, просто ну значит, грубо говоря, один шаг алгоритма здесь, один шаг алгоритма здесь,
один здесь, один здесь. Пока не найдется вершина, обработанная с обеих концов, с обеих сторон,
с обеих сторон. Тогда ответ, истинное расстояние от s до t, это следующая величина, минимум по всем
вершинам v. Давайте напишу так, dist s до v плюс dist t от v, вот так. Что это такое? Это два массива, которые
я, соответственно, dist s это те расстояния, которые я нахожу идя от s, dist t это те расстояния, которые
я нахожу идя от t по обратным ребрам. То есть два bfs, один работает с массивом dist s расстояния,
другой работает с массивом dist t расстояния. И тогда, чтобы найти правильное расстояние, нужно
просто перебирать все вершины, которые вы здесь видели, и взять минимально возможную сумму. То есть
что вы взяли любую вершинку v, вы знаете вот это расстояние, знаете вот это расстояние, складываете
их и по всем возможным вершинам перебираете, это будет ваш минимум. Нет, нет-нет-нет, невзвешенный,
невзвешенный. То есть это можно обобщить на там 0k bfs, но давайте считать, что он невзвешенный.
Так, ну почему это, почему это верно? Почему то, что мы найдем, это действительно расстояние от s
до t. Ну смотрите, давайте считать, что мы сделали как бы по d шагов слева и справа. То есть мы
сделали дейтерации bfs из s и дейтерации вот по этому обратному графу из t. Это значит, что вот
если наш bfs обрубить после дейтерации, это значит, что мы правильно нашли все вершины на расстоянии
не больше чем d из s и правильно нашли все вершины на расстоянии не больше чем d от t. Согласны? Мы
правильно нашли все вершины на расстоянии не больше чем d из s и из t. Значит дальше мы рассматриваем
все вершины, складываем вот эти две суммы, то есть по сути те вершины, которые попали сюда и сюда,
мы вот здесь рассматриваем, потому что для остальных там будет плюс бесконечность какой-то из
чисел. Складываем два числа, берем из них минимум. Так, почему найдется правильный ответ?
Ну давайте скажем следующее, пусть с обеих сторон выполнено по дейтерации bfs. Пусть с обеих сторон
выполнено по дейтерации bfs. То есть найдены все вершины на расстоянии не больше чем d из s и
найдены все вершины на расстоянии не больше чем d до t. Все вершины с dist sv меньше равно d и все
вершины или dist vt меньше равно d. Все такие вершины найдены, у них насчитано правильное расстояние
в этом случае от s до v, в том случае от v до t. Почему мы тогда нашли правильный путь, когда взяли
такой минимум? Так, ну во-первых, понятно следующее, что когда мы берем вот такой минимум,
этот минимум будет точно не больше чем 2d. Потому что раз у меня вот эти вот, ну по сути,
я вот так расширял наши облачка слева и справа, они когда-то пересеклись. Они пересеклись на какой-то
вершинке, на расстоянии не больше чем d отсюда, не больше чем d отсюда. Значит ответ точно не
больше чем d плюс d. Есть вот этот путь, есть вот этот путь. Каждый из них не больше чем d, значит
ответ точно не больше чем 2d. Тогда давайте покажем, что любой путь длины меньше чем 2d мы точно
увидим. Докажем, что любой путь длины меньше чем 2d мы точно увидим. Ну увидим, значит, что на
нем есть какая-то вершинка v, для которой вот эта штука равна вот этой самой длине пути. Почему это
так? Вот есть путь какой-то из s в t, длины меньше чем 2d. Почему тогда я его обнаружу? Очень просто.
Давайте просто возьмем d эту на нем вершину, то есть вершину такую, что вот здесь d ребер. Соответственно,
эта вершина на расстоянии d находится от s. Ну извините, если она находится на расстоянии d от s,
тогда она обработана и до нее насчитана правильный дист, вот этот вот дист s правильно до нее насчитан.
Вот эта вершинка v на расстоянии d. Для нее правильно насчитан дист s с одной стороны. С другой стороны,
раз длина пути меньше чем 2d, значит вот здесь вот длина пути меньше чем d. Раз суммы этих двух чисел
меньше чем 2d, поэтому тогда здесь меньше чем d. Ну значит опять, она обработана, если мы рассматриваем
вот этот обратный bfs из t. Поэтому до нее правильно насчитан дист t. Профит. То есть еще раз, если мы
предполагаем, что есть какой-то более короткий путь, чем вот тот, он точно имеет вот такую маленькую длину,
но с другой стороны, если мы рассмотрим d эту на нем вершину, то до нее правильно насчитана и вот это
расстояние, и вот это. Значит в частности в том минимуме этот путь участвует. Поэтому все пути,
как бы кандидаты на ответ, у меня будут учтены. Значит минимум я точно найду, расстояние точно найду.
Согласны? Тут надо еще там, если совсем строго хотим, то нам надо рассмотреть случай, когда на
этом пути нету d этой вершины, то есть длина этого пути меньше чем d, но тогда расстояние от s до t
вообще меньше чем d, и на самом деле наш алгоритм должен был закончиться на предыдущей итерации,
потому что, то есть я, получается, за d-1 итерацию дохожу от s до t, значит тогда вершинка t будет
обработана на d-1 итерации, но с другой стороны обработана на нулевой привод, когда мы шли
здесь, поэтому алгоритм должен был бы раньше завершиться. Вот вроде так. Теперь вопрос зачем,
если у нас есть обычный BFS. Например, затем, если у нас граф, грубо говоря, экспоненциально растет,
или другими словами, каждая вершина, вот если вы стоите в какой-то вершинке, то из нее есть,
скажем, константа, какое-то одинаковое число новых рёбер, новых вершин она порождает по а штук.
Каждая вершина, когда вы идёте BFS с лево направо, каждая вершина вам раскрывается в а новых вершин,
то есть, скажем, у s степень какая-то а, затем каждый из них дает еще а исходящих рёбер, ну и так далее.
Вот, ну пусть такой граф у вас есть. Тогда, если бы вы запустили обычный BFS и пытались бы найти
путь из s в t, и между ними пусть какое-то расстояние d, тогда вам пришлось бы рассмотреть примерно вот
столько вершин, а в степени d. Ну, там, видимо, даже еще больше. В общем, тут будет какая-то сумма
геометрической прогрессии, да, 1, а, а в квадрате и так далее, до а в степени d. Ну, короче, вот главное
слагами а в степени d. Это обычный BFS, если мы просто идем вот так с лево направо. Вот, а двусторонний BFS,
как он будет работать на таком графе? Ну, смотрите, то есть мы считаем, что вот есть s, такие
три ребра из нее, вот так вот, ну не три, а там а-рёбер. И то же самое с t. В t входят три ребра, в
каждой из них входят по три ребра и так далее. То есть тут как бы он и с лево направо экспоненциально
растет, и справа налево экспоненциально растет. Тогда до того момента, чтобы они пересеклись,
нам достаточно пройти d пополам шагов примерно. Ну, там d плюс 1 пополам, возможно. И поэтому тогда
здесь человечем, который я рассмотрю, будет всего лишь 2 на а в степени d пополам. Ну, это сильно лучше,
да, то есть если там у вас а и d какие-то достаточно большие, то это, ну, по сути, улучшение в корень.
По сравнению вот с этим, это это корень. Корень из вот этого как раз а в степени d пополам. Вот,
поэтому двухсторонний BFS, он вот так хорошо работает, если вы быстро экспоненциально растете при
проходе из любой вершинки или, наоборот, в любую вершинку вот по этим обратным рёбам.
Так, да, ну и при этом тут надо еще сказать, что там в идеале, чтобы действительно было вот такое
значительное различие, нам нужно весь граф хранить в какой-то хедж таблице, потому что, то есть если
скажем, у нас граф экспоненциальный, и мы все равно храним там дист s и дист t как какие-то массивы,
то мы, конечно, никакого выигрыша не получим, нам все равно нужно там вот столько памяти хранить. Но
чтобы этого не делать, и чтобы как бы обрабатывать только те вершины, до которых мы дошли, нам нужна
какая-то хедж таблица вот здесь. Чтобы, соответственно, не хранить дисты до всех, а только до тех, которые
мы видим. Нам нужна хедж таблица. Ну, то есть как один из возможных вариантов. Вот, и, значит,
такое в принципе бывает, вот в контесте будет задачка на это, это, грубо говоря, когда у вас есть,
ну там, не знаю, грубо говоря, какая-то игра, и вы можете из каждой позиции делать, ну какой там,
не знаю, из каждой позиции у вас есть ровно четыре хода. То есть, соответственно, у вас тогда каждая
вершинка, это какая-то позиция в игре, вы можете из нее сделать четыре хода. Ну, соответственно,
наоборот, если у вас есть какая-то позиция, то она достигается из каких-то других четырех возможных
вершин. Поэтому как раз у вас вот такой экспоненциальный рост есть, ну там, слева направо и справа налево,
поэтому, ну, в каком-то смысле лучше было бы использовать двусторонний BFS. Ну, а в худшем случае,
конечно, это тоже просто n плюс m, линейная по размеру графа алгоритм. Ну, потому что, там, в худшем
случае, если граф какой-то обычный, то вы просто пройдете половину вершин слева, половину вершин
справа. Понятно, что у вас ничего от этого в терминах азимтотики не изменится, но только если
у вас какая-то такой специфичка структура, это может быть полезно. Так, хорошо, значит,
тогда мы переходим к алгоритму Dijkstra. Это случай взвешенного графа с произвольными не отрицательными
весами ребер. Значит, функция W, она из ребер в, ну, давайте я так напишу, ноль плюс бесконечность. То есть,
все веса ребер не отрицательные какие-то числа. Давайте это прям пропишу. Веса ребер не отрицательные
числа. С отрицателями Dijkstra работать не умеют. Они все должны быть строго не отрицательные,
больше нуля. Так, алгоритм довольно простой. Значит, смотрите, в каждом инфремене все вершины будут
разбиты на два кластера, использованные и неиспользованные. Для использованных вершин я
считаю, что я знаю корректный дистанц. То есть, задачу опять я решаю от s до всех. От s до всех
находим кратчащее расстояние. Найти dist. Значит, вот есть какое-то множество использованных, я до них
знаю корректное кратчащее расстояние. А здесь я знаю только какую-то оценку на кратчащее расстояние.
Тогда алгоритм работает так. Из всех вот этих вот неиспользованных найти вершину с минимальным
дистанцем, который я нашел, какой-то v, до которой дистанц насчитанный минимально возможный. Дальше я
считаю ее использованной. Считаю, что до нее насчитанное расстояние правильно. То есть,
по сути расширяю мое множество использованных нововершенкой v. А дальше рассматриваю все
исходящие ребра из v и обновляю dist для всех этих концов. Очень похоже на то, что было у нас в 0kbfs,
что я нахожу вершину первую, как бы не обработанную, с минимально возможным дистанцем до нее
насчитанным. Раскрываю ее, то есть рассматриваю все исходящие ребра и обновляю dist для концов этих
ребер. Ну и, соответственно, перехожу в цикле. Потом дальше у меня будет из вот этих вот, из вот
этих вершин находиться вершина с минимальным дистом. Она будет объявляться как использованная,
то есть до нее правильная насчитанная расстояние. Ее раскрываем, то есть рассматриваем все исходящие
ребра, ну и так далее. Итак, алгоритм. Значит, изначально все дисты
это плюс бесконечности, дистатес это 0, все вершины неиспользованные. Все вершины неиспользованные.
Дальше. Пока есть хотя бы одна неиспользованная, пока есть неиспользованные вершины, мы говорим,
что пусть v это неиспользованная вершина с минимальным значением dist, неиспользованная
вершина с минимальным значением dist от v. Помечаем ее использованной. Помечаем v использованной. Ну а
дальше вот то, что называю раскрытие вершины в цикле по всем ребрам исходящим из v, обновляем
dist для конца этого ребра. Обновить dist от e.tu. Точно так же, как у нас было в 0kbfs. Я
прохожу по всем ребрам исходящим из v. Если distance от v плюс вес ребра меньше, чем distance от
e.tu, тогда я этот самый distance e.tu обновляю. Уменьшаю собственно с учетом вот этого последнего
ребра из v в tu. Вот это будет называться раскрытие вершины для краткости. Раскрытие v. Ну все. Я взял
вершину с минимальным dist. Говорю, что это теперь правильное расстояние. Она помеченная,
использованная. И рассматриваю все исходящие ребра, обновляю dist. И дальше возвращаюсь в цикл,
нахожу первую неиспользованную с минимальным dist. И так далее, и так далее.
Так, значит, со сколько это можно реализовать? Асимптотика. Тут есть две принципальные
реализации. Первая это просто за n квадрат. Очень просто. Давайте мы для каждой вершины явно хранить
вот эту пометку использования использованная. Там какой-то просто булливский флаг used. Чтобы
найти вершину v с минимальным значением distance, которая не использована, я просто прохожусь по
всем вершинам неиспользованным. То есть по всем прохожу. Если она неиспользованная, то тогда пытаюсь
обновить вот эту, то есть нахожу минимальную вот эту вот dist от v за линейное время. То есть эта штука
будет работать за линию, просто проход по всем вершинам. Вот. Ну а дальше, суммарно время работы
раскрытия всех вершин, это от m. Суммарно от m. Потому что каждой вершины будет помечено использованной
максимум один раз. Значит, каждое ребро рассмотрено максимум один раз. Поэтому суммарно все раскрытия
работают за линейное по числу ребер время. Ну и последнее, это что итерации в цикле while у меня
максимум n. Не больше, чем n. Ну точнее там ровно n, видимо, будет. Ну не важно. Не больше, чем n
итерации. Потому что на каждой итерации я помечаю какую-то неиспользованную использованную. И while
работает ровно столько, пока есть неиспользованные вершины. Значит, суммарно итерации максимум n.
Поэтому есть слагаемое от m. Все раскрытия работают за от m. Плюс слагаемое n квадрат, потому что я n раз
нахожу минимум. Из этих двух понятно дело, что n квадрат максимальная, потому что мы считаем,
что в графе нет красных ребер. Значит, m всегда меньше, чем n квадрат. Ребер не может быть больше, чем
квадрат от числа вершин, если нет красных ребер. Это первое, да, просто линейный поиск минимума на
каждой итерации. На каждой итерации. Другой подход работает за m лог n. И здесь нам нужно более
хитро искать минимум. А именно искать мы его будем с помощью кучи. Тех куч, которые мы рассматриваем в
первом семестре. Смотрите, что у нас есть. Давайте у меня в какой-то куче, в бинарной куче, лежат все
неиспользованные вершины, которые сортируются в порядке убывания дистатвы. То есть в корне лежит
неиспользованный вершина с минимальным дистанцием. Дальше, что мне нужно? Мне нужно находить минимум в
куче. Это корень. В случае бинарной кучи это корень getMin. Дальше, мне нужно делать extractMin,
потому что вершину нужно пометить использованный, соответственно удалить из кучи. Удалить
минимальное значение из кучи. А еще мне нужно делать decrease key, потому что вот здесь вот, когда я
обновляю distance, когда я раскрываю вершину, обновляю дисты, я могу их только уменьшать. Дисты, они
могут только уменьшаться, то есть если у меня был какой-то путь до e.to и я нашел более короткий,
тогда я его уменьшаю. Значит мне в куче нужно, точнее в моей структуре, мне нужны три операции getMin,
extractMin и decrease key. Там еще в каком-то начале надо было сделать build, создать кучу на n элементах
вот по тем значениям дистов. Но это куча, это куча. Там бинарная, биномиальная, какая хотите.
Вот, соответственно, ну там давайте build я буду игнорирует, build работает за линейное время у нас.
Вот, getMin работает за единицу в бинарной куче по крайней мере, extractMin за логарифом от размера
кучи, а в куче у нас максимум n элементов всегда, потому что каждая вершина один раз.
Decrease key работает за логарифом. Причем сколько раз нам нужно будет делать эти операции? Вот эти по n раз,
getMin и extractMin нужно делать n раз столько, сколько итерации Вайля, а это суммарно m раз.
Decrease key работает, ну как бы, decrease key связан с обработкой ребра, поэтому суммарно декризов будет
максимум m. Ну поэтому видим, что у нас здесь будет n раз log n плюс m log n. Понятно, что обычно m
больше чем n, поэтому здесь обычно остается только вот это вот главное слагаемое. Здесь пишется m log n.
Ну можно для там, для честности написать что-то типа m плюс n log n, что если у вас граф очень маленький,
в смысле, в смысле ребер в нем мало, тогда у вас там вот это слагаемое может быть больше, n log n
может быть больше чем m log n. Ну можно тогда писать вот такое, но давайте я все-таки вот это буду писать
как основное, потому что я считаю, что m оно у нас больше чем n. Потому что, значит, у нас вообще
граф не связан и можно тогда взять какую-то его отдельную компоненту связанности и в ней отдельно
работать. Так, понятно откуда такая симптотика получилась? Вот, ну и последнее, что на самом деле
здесь можно использовать не бинарную кучу, то есть мы использовали бинарную кучу, можно использовать
какую-нибудь другую, типа куча фибоначи. Мы ее не рассматривали, ну давайте напишем, как у меня будет
симптотика. Значит, еще раз, да, главные операции такие, экстракт бинарный нужно сделать m раз,
декриз ки, так декриз ки, нужно сделать m раз. Так вот, в фибоначевой куче экстракт работает
амортизировано за алгорифм, а декриз амортизировано за единицу от фибоначевой кучи. Значит,
тогда суммарное время работы будет m плюс n лог n. Вот, ну у фибоначевой кучи хорошо тем,
что у него как раз декриз ки амортизировано за единицу, и в том случае, когда m сильно больше
чем n, то есть декризов больше, чем экстрактов, тогда у меня, соответственно, декриз работает
суммарно за m, а экстракты за n лог n. И по сравнению с m лог n, это, ну, довольно значимое улучшение,
потому что если я скажу m сильно больше, чем n, то я тогда теперь не больше множителя умножать на
лог n, а меньше, да, только n умножая на лог n, а m на лог n я не умножаю. Вот. Она большая, да,
но амортизация во-первых, во-вторых, о, большое, поэтому. Но в любом случае мы это писать не будем,
но с точки зрения теории, если мы рассматриваем поведение на реально больших нм, там миллионы,
миллиарды вершин, тогда, да, вот эта симптомика будет лучше, чем бинарная куча, но как бы у нас,
в наших таких учебных задачках, конечно, нам такое не нужно, нам будет всегда хватать бинарной кучи,
или биномиальной, какая вам больше нравится, за m лог n. Так, корректность. Почему этот алгоритм
всегда находит правильные ответы для всех вершин? Корректность. Сейчас скажу.
Я хочу доказать следующее утверждение, что вот, ну, у меня, понятное дело, в каждом инфремене,
после каждой трассы моего алгоритма, у меня есть использованные вершины, которые, как бы говорю,
что я до них уже нашел правильное расстояние. Есть неиспользованные, до которых есть только какая-то
оценка на расстоянии, да, для них dist от v это не точный ответ, а какая-то пока что оценка на
ответ, оценка сверху на ответ, что я нашел до них какой-то путь, возможно, есть более короткие,
которые я пока не учел. Так вот, я утверждаю следующее, что пусть в какой-то момент времени,
давайте не v, а u, в какой-то момент времени, u это неиспользованные вершины. Такая что?
Один из кратчайших путей от s до u не содержит других неиспользованных вершин. Один, ну, в смысле,
какой-то, один из кратчайших путей от s до u не содержит других неиспользованных.
Тогда distance от u правильно посчитан. Тогда distance от u, который мы насчитываем нашим алгоритме,
равно правильному значению dist s u. То есть, напоминаю, dist s u это определение просто расстояния
от s до u, а distance от u в квадратных скобках, то, что мы в алгоритме находим, это то, что наш алгоритм
пытается выдать в качестве ответа для вершинки u. Так, вот, я это формулировал. Ну, это плюс-минус
очевидно, потому что смотрите, что значит, что есть кратчайший путь от s до u, который не содержит других
неиспользованных. Значит, он сначала как-то петляет по множеству использованных, потом берет и за одно
ребро сразу попадает в u, да, и больше никаких других не посещает. Согласны? Дальше, если я по индукции
буду доказывать, что в множестве использованных лежат всегда правильные ответы, что для них,
для всех distance, которые я нашел, всегда правильный, тогда, ну, понятное дело, я как бы знаю, получается,
вот это кратчайшее расстояние. Я знаю кратчайшее расстояние от s до u, например. Знаю кратчайшее
расстояние distance от s до y. Ну и тогда понятно, что нужно просто одно ребро приклеить, но оно как бы
обработается, когда я буду раскрывать y. Значит, в момент, когда я раскрываю y, у меня в u положится
правильный ответ. Вот, значит, я использую такое утверждение, что если v использованное, то, ну опять, да,
distance от v равно distance от s до v. То есть это, собственно, мы хотим показать, что все вершины, когда они
переносится в разряд использованных, до них правильно щепочет на distance. Так вот, если это верно какой-то
итерации, вот сейчас для них для всех начнется правильное расстояние. Тогда все вот такие вершины
справа лежащие, неиспользованные, до которых кратчайший путь не содержит других неиспользованных,
тогда для них вот это тоже верно. Потому что я знаю кратчайший путь от s до y, до предпоследней
вершины этого пути. y когда-то был раскрыт, когда он помечался использованным, значит это ребро
рассмотрелось и, соответственно, до u я нашел кратчайшее расстояние. То есть этот путь учтен. Вот.
Значит, теперь осталось показать, что когда я достаю v из неиспользованных с минимальным
distance, я до нее нашел правильный ответ. Ну пусть это не так. Пусть в какой-то момент
алгоритм помечает использованной вершину v, для которой distance насчитан неправильно. То есть
distance найденный в алгоритме строго больше, чем distance sv. Ну понятно, он не может быть меньше,
потому что все, что мы делаем в алгоритме, это, понятно, делать только оценка сверху на правильное
расстояние. Я никогда, я не придумаю несуществующих путей, я только рассматриваю какие-то пути,
пытаюсь их продлить существующими ребрами. Потому что поэтому в другую сторону неравенства быть
точно не может. Так вот пусть я использованный помечаю какую-то такую вершину distance v больше,
чем distance v. Окей, рассмотрим настоящий кратчайший путь от s до v. Поскольку вот это вот верно,
то в этом пути обязательно есть какая-то другая неиспользованная, потому что если бы в ней не
было неиспользованных, то у меня было бы точно вот это вот равенство. Здесь квантор всеобщности,
что если у вот такова, что есть какой-то путь такой, тогда вот это верно. То есть любой вершины у,
для которой существует путь неиспользующий других неиспользованных, тогда для нее distance
правильно посчитан. Так вот, значит вернемся. Вот пусть мы v выбираем в соответствии с тем,
как наш алгоритм, ее выбирает минимальный distance по неиспользованному, и пусть у нее
неверно посчитан distance. Тогда рассматриваем кратчайший путь настоящий. Он обязательно содержит
какую-то другую неиспользованную, потому что если бы не содержал, то вот по этому
утверждению у нас был бы distance равный. Значит он выглядит как-то так. Вот есть s, вот есть v,
и этот кратчайший путь ходит как-то так. Сначала он как-то здесь что-то делает, потом перемещается
в неиспользованные, там как-то ходит здесь, возможно возвращается, как-то так петляет,
и доходит до v. Причем есть какая-то другая вот здесь вершина. Давайте рассмотрим первую
неиспользованную на этом пути. Пусть у первая неиспользованная на этом пути. Тогда, поскольку
вот этот начальный отрезок моего пути является кратчайшим путем от s до u, если бы он не являлся,
можно было бы этот путь опять сократить, и тогда был бы еще более кроткий путь от s до v. Так вот,
это получается кратчайший путь до u, который не использует других неиспользованных вершин,
кроме u. Значит, я для u нашел правильное расстояние. Путь от s до u не содержит других неиспользованных,
других неиспользованных. Значит, мой алгоритм нашел правильное расстояние dist at u. Dist at u
равно dist s u. Согласны? То есть, был какой-то путь, я взял первую неиспользованную,
тогда для нее правильный пощитный ответ. Ну а дальше уже все просто. Мы понимаем,
что вот это не больше, чем dist s v, потому что кратчайший путь от s до v отличается от кратчайших
путей от s до u, дописыванием каких-то ребер вот здесь. Ну и поскольку они все не отрицательные,
distance мог только вырасти. Такого неравенства следует из-за того, что все ребра не отрицательны.
Так, ну и вот это меньше, по предположению, чем dist s v. Получается противоречие. Мы показали,
что distance от u меньше, чем distance от v, а v была такая, что она не использована с минимальным
dist. А мы показали, что из другая не использована с меньшим dist, противоречие. Сейчас мы доказали
корректность dx. Смотрите, два шага здесь. Первое замечание такое, что вот просто рассмотрим
какой-то момент в выполнении нашего алгоритма. Вот есть использованные, есть неиспользованные.
Если u это какая-то неиспользованная, вот просто пусть ус가지вольно неиспользованная такая,
что до нее есть крайней Idi.♪ потт неиспользующей других неиспользованных. Тогда я утверждаю,
что это GWG найдено к радости. Это мы, вроде, как доказали, потому, что, если здесь у меня все
найдено по индукции, по предположению индукции, здесь все найдено, правильную расстояния найдены,
тогда от S до Y известно крершу расстояния, Y раскрывается, соответственно это ребро
это ребро учитывается, я до У нахожу кратчайшее расстояние.
Почему не может быть что-то более короткое,
используя еще раз, не используя кратчайшие?
Потому что я... сейчас.
Вот еще раз, да, до У есть несколько кратчайших путей.
Я говорю, что пусть один из них, один из кратчайших,
не использует других неиспользованных.
Нет путей меньшего веса.
Есть этот кусок, который мы просто заметили.
Дальше предполагаем, что наш алгоритм некорректен,
до их стране корректная.
Это значит, что в какой-то момент мы достаем вершину В
неиспользованную, такую, что вот эта выполняется.
Для нее найдено расстояние неверное,
не совпадает с истинным.
Тогда рассматриваем настоящий кратчайший путь от С до В,
вот этот вот, вот он, такой петляющий.
Дальше, поскольку выполняется такое неравенство,
то на нем обязательно есть какая-то другая неиспользованная,
потому что если бы не было, то было бы равенство.
Окей, рассмотрим на этом пути первую неиспользованную У.
Пусть У это первая неиспользованная.
Ну а дальше, значит, мы понимаем, что до нее distance правильно посчитано,
что distance У равно distance У по тому замечанию.
Это не больше, чем distance В, потому что отличается
дописанием каких-то ребер в конце,
и это по предположению меньше, чем distance В.
Значит, distance У имеет меньше, меньше distance В.
Противоречие с тем, что В это минимальная вершина,
минимальная неиспользованная по дисту.
Хорошо.
И, наконец, последний алгоритм на сегодня,
это двусторонний алгоритм Dijkstra.
Двусторонний алгоритм Dijkstra.
Работает очень похоже на то,
как мы, собственно, делали двусторонний BFS.
Задача опять.
Есть две вершины, S и T.
Нужно найти кратчайший путь из S в T.
Не из S до всех, как мы делали в обычном алгоритме Dijkstra.
А именно от S до T есть начальная вершина, есть конечная,
а между ними нужно найти кратчайшее состояние.
Работает очень похоже на обычный BFS.
Ну, по сути, мы просто параллельно, в кавычках,
запускаем Dijkstra по обычным ребрам из S
и по обратным ребрам из T.
То есть те ребра, которые ведут в T.
Вот так вот, справа-налево как бы.
Что значит параллельно?
Значит, у нас есть, по сути, две кучи.
Куча для вот этих вершин, которые из S обрабатываются,
и куча вершин, которые обрабатываются из T.
Есть у меня две кучи,
две бинарные кучи, например.
Я смотрю на их корни,
то есть на минимальные из дистов.
То есть это минимально неиспользованный из S,
это минимально неиспользованный из T.
Выбираю из них минимум и раскрываю.
То есть если скажем вот это меньше,
чем вот это,
то я рассматриваю эту вершинку,
достаю ее, экстрактиваю из кучи,
раскрываю ее.
Иначе, если мне нравится в другую сторону,
я, наоборот, экстрактиваю вот это,
удаляю вершинку из правой доли
и раскрываю ее по обратным ребрам.
И так делаю до тех пор,
пока какая-то вершина не будет обработана
и исключена из обеих куч.
Значит, параллельный запуск с двух сторон.
Обрабатываем вершину с минимальным дистанцием.
То есть из этих двух выбираем минимальную
и ее раскрываем.
То есть либо раскрываем по прямым ребрам,
либо раскрываем, наоборот, по обратным ребрам.
То есть я изначально завожу список всех ребер,
ведущих в каждую вершину,
и теперь ее в обратную сторону раскрываю.
И завершаемся,
когда какая-то вершина будет удалена,
обработана из обеих куч.
Когда какая-то вершина
удалится
из обеих куч.
impotent.com
Ну и соответственно ответ
Это опять то же самое, минимум по всем вершинам, dist s до v плюс dist t от v.
То есть я иду слева направо, храню dist s по ребрам слева направо от s, иду справа налево от t, храню все dist t, расстояние от текущей до t.
И соответственно ответ это минимум вот таких сумм, что я сначала от s добираюсь до v, а потом от v до t.
Так, ну опять нужна корректность.
То есть со симптотикой здесь то же самое, что если ваш граф вот такой, что он как бы экспенциально растет,
из каждой вершины есть там, грубо говоря, константа, ребер влево и константа, ребер, наоборот, вправо.
Тогда, ну то же самое, что если мы так параллельно запускаем, то как бы мы встречимся где-то на серединке,
соответственно рассмотрим там корневое число вершин.
И тоже опять нам нужны какие-то х-таблицы, чтобы получить выигрыш по времени.
Но в худшем случае, конечно, вы просто рассмотрите n пополам вершин слева, n пополам вершин справа,
и никакого выигрыша не получится. Это в общем случае.
Но в каких-то там частных, если граф в специфичке устроен, то вот у вас может быть сильно лучше от такого алгоритма.
Корректность.
Значит, пусть алгоритм завершается после обработки какой-то вершины мид.
То есть вершина мид – это вот тот момент, когда у вас вот эти две кучи пересеклись,
вершина мид обработался и из левой кучи, и из правой.
Вершина мид удалена из обеих куч.
Ну и дальше похожий аргумент.
Значит, мы знаем, что ответ точно…
Значит, если мы нашли расстояние от s до мид какой-то там d1,
вес этого пути d1, и от мид до t вес какой-то d2,
то мы точно знаем, что ответ не больше d1 плюс d2.
Потому что есть вот такой хорошейший путь.
Дальше опять так же, как мы делали в двустороннем BFS,
покажем, что любой путь меньше длины мы увидим.
То есть если путь имеет длину меньше, чем d1 плюс d2,
то на нём обязательно найдётся вершина такая, что для неё сумма вот этих штук равна длине пути.
Ну действительно, пусть есть какой-то путь меньше длины.
Пусть есть путь из s в t длины меньше, чем d1 плюс d2.
Вот какой-то путь.
Тогда опять давайте рассмотрим вершину, первую вершину в этом пути,
на расстоянии хотя бы d1 от s.
На расстоянии хотя бы d1 от s.
Первую вершину на этом пути на расстоянии хотя бы d1 от s.
То есть вот здесь везде сумма весов ребер меньше, чем d1,
и вот это вот, когда ребро добавляется, сумма хотя бы d1.
Вот это первая вершина расстояния хотя бы d1.
Тогда до неё я утверждаю, обязательно правильно найден dist s.
Давайте я её назову как-нибудь x.
Dist s от x правильно найден.
Потому что все вот эти вот вершины обработаны.
То есть до них до всех dist от s меньше, чем d1.
Значит, поскольку у меня mid удалена из кучи,
значит все вершины с меньшим расстоянием уже удалены из неё.
Потому что Dexter рассматривает вершины в порядке увеличения этого самого dist.
Значит все вот эти вершины удалены раньше из кучи и обработаны.
Значит до x в частности найдено правильное расстояние.
То есть у меня найдено до них до всех кратчащие расстояния.
И когда вот это обрабатывалось, я это ребро рассмотрю, то есть до x найду правильное кратчащее расстояние.
Это есть.
Ну и дальше уже очевидно, что эта штука меньше, чем d2.
Потому что если это хотя бы d1, а в сумме меньше, чем d1, то это меньше, чем d2.
Значит dist t от x тоже правильно найден.
Потому что эта штука меньше, чем d2, а у меня mid удалена, и до неё было d2.
Поэтому все меньше тоже найдены.
Значит dist t тоже правильно найдено.
Ну все, сумма этих вершин равна длине этого пути, значит я его учту в ответе.
Еще раз, я рассматриваю первую вершину x, первую вершину в этом пути, слева направо, до которой расстояние хотя бы d1.
То есть вот здесь хотя бы d1, а на всех префиксах меньше, чем d1.
Ну значит мы d учтем, она участвует в этом минимуме, поэтому все пути меньше длины мы учтем, значит минимали из них тоже учтем.
Кажется все, спасибо за внимание.
