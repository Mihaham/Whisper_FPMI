Начнем сегодня с такой веселой задачки.
Вот, значит, смотрите, сегодня в некоторое время мы поищем разрезы в неориентированном графе.
Неориентированном, но от этого не менее взвешено.
Беса не отрицают.
Но важно, что граф именно не отрицает.
Вот.
Вот такой домик.
Да, граф не обязательно планарный, конечно.
А то мы помним там все за ЛОГМ, да, да, да.
Вот.
Ввешенный.
Ну, ему тут везде веса дорисованы, но самое главное, что все веса не отрицательны, как всегда.
Как всегда, в общем-то, в этой науке.
И все, что нам хочется, это...
Ну, по-разному.
Для разбиночки нам хочется найти минимальный разрез.
Да, вы спросите, между чем и чем?
Кто С и Т?
А я скажу, на этот раз не кто.
Наша цель разбить, собственно, множество вершин на С и Т.
Вот.
Так, чтобы от С и Т было минимально возможно.
Легче еще.
Берем пустое множество и все остальное.
Да, в такой постановке, конечно, да.
Самое тупое, берем С пустое, Т все остальное, вес ноль, ура.
Согласен, неинтересная задача.
Вот.
Но...
Поехали дальше.
Да, но, к сожалению, мы на этом не успокаиваемся.
Тут выясняется, что надо, чтобы оба этих множества были не пусты.
И вот тут уже задача...
Ну, если, конечно, нам не оказалось, что граф не связан,
в общем-то, оказывается, нетривиально.
Да, если граф не связан, то, собственно, понятно.
Вот.
Вот.
Но, собственно, хочется, тем не менее, найти, разбить таким образом,
то есть, чтобы было как можно лучше.
Внимание, вопрос.
За какую асимптотику мы, с высоты наших всех теорий, умеем это делать?
Перебираем С и Т.
Да, самое тупое, что можно сделать, перебираем С и Т.
И для каждой пары С и Т находим минимальный поток.
Так, ну, за какие асимптотики мы это умеем делать?
Н квадрат на н е лог н.
Ну, просто, так, ну, н на е лог н, на самом деле.
Н, сейчас, н квадрат на перебор всех С и Т.
А, ну, нет, я спрашиваю, если сколько мы поток.
А, н лог н на е.
Ага, ну да, в е лог в, собственно, там, с линкатом, ну, либо...
Ну, либо закуп чем-нибудь там, чем углу.
У нас две возначения произошло, значит, С был...
Это была профессиональная способность.
У нас все, потоки закончились, скоро вернуться.
Нет, потоки не закончились, смотрите, нет.
Ну, здесь это может символизировать то, что у нас есть неориентированный граф у веса,
и мы ищем минимальный разрез.
И никаких пропускной способностей нет.
А, так попробуем.
У нас нет потока?
Нет.
Нет, понятие, смотрите, понятие разрез вообще никак.
Есть какими потоками светлых.
И у нас только фантастическая случайность, что разрез вообще как-то связан с потоками.
Просто вот так.
Ну, и фантастическая, конечно.
Ну, решение, короче, предложено, это именно перебрать вершины,
теперь интерпретировать веса как способности и на типо поток.
Вот.
То есть это будет у нас работать за, там, получается, n квадрат, точнее v квадрат,
на, там, так сказать, max flow.
Это слишком тупо, потому что у нас одна вершина точно будет в одной из далеких.
Ну да.
И ее можно зафиксировать и забить.
Совершенно верно, да.
То есть, на самом деле, можно перебрать и все паралики,
то есть фиксировать одну и перебрать всех ее напарников.
Ну, кто будет точно в другой доле.
Поэтому, на самом деле, да.
n на max flow.
Ну, за это асимптотика у нас будет еще сегодня фигурировать.
Да.
Вот за нее можно даже более мощную задачу решить.
Вот.
Но мы же попытаем, вот.
Но так как у нас n max flow, это у нас,
ну, в нашем случае это получается либо,
как бы это max flow интерпретировать,
то есть, либо n квадрат на n лог n,
либо n четвертый получается.
Можно так сделать.
Вот.
Но, оказывается, оказывается, что можно и,
ну, что, на самом деле, если просто найти разрез,
то, оказывается, можно и чуть-чуть побыстрее.
Вонично.
Вот.
То есть, ну да, то есть, то есть, то есть,
то есть, заметим, что на этот раз мы же не ограничиваем в себя,
какие конкретно две вершины должны быть.
Главное, чтобы разрез был минимальный.
Вот.
Значит, что же нам для этого хочется сделать?
Вот.
Ну, оказывается, ну, вот, то есть, идея может оказаться достаточно,
вообще, неожиданно простой.
Значит, первая идея, которая возникает.
Рассмотрим какие-нибудь две вершины.
Вот еще одна схема.
Рассмотрим какие-нибудь две вершины
и минимальный разрез между ними.
Ну вот, балды.
Тогда у нас два варианта.
Либо этот разрез минимальный.
Либо...
Либо t в другой доле.
Либо не минимальный.
И тогда это означает...
Но тогда в минимальном разрезе s и t будут железообитонно в одной доле.
И тогда, возникает ключи идеи.
Чтобы попытаться найти более оптимальный,
мы можем просто s и t сжать в одну вершину.
Ну и, соответственно, понятно, все ребра,
связанные с s и t, направят в эту новую вершину.
И в полученном графе можно дать след.
То есть, в принципе, это еще одна схема,
как найти решение за n на max flow, правда?
То есть, мы будем n раз искать максимальный потом.
То есть, отчего можно оптимизировать этот алгоритм?
Ну, естественно, за счет того, что жил был s и t.
Что s и t мы в этом алгоритме выбираем абсолютно произвольные, первые попавшиеся.
А идея может быть в том, что нам же не нужны s и t произвольные.
То есть, нужны они нам абсолютно произвольные,
то есть, там конкретные какие-то не нужны.
И получается такая идея.
То есть, нам нужно найти какие-то s и t
и какой-то минимальный разрез между ними.
А вдруг так можно?
То есть, может быть, нам удастся найти
какие-нибудь вершины s и t и минимальный разрез
быстрее, чем за максимальный поток,
в предположении, что нам как бы нужно,
и s и t мы тоже сами подгоняем.
Вдруг можем найти s и t, для которых разрез ищется легче.
Вот, собственно, основная, то есть,
первая идея алгоритма именно в этом.
Сейчас мы попробуем, то есть, вот будет у нас ставка,
что эти две вершины и разрез между ними мы найдем за n квадрат.
Да, что приведет нас просто к алгоритму за...
Значит, за счет чего мы это сделаем.
Итак.
Значит, еще раз.
Значит, наша задача, давайте этот временный разрез уберем.
Значит, наша задача найти дан граф.
И нам надо найти какие-то вершины s и t
и минимальный разрез между ними.
То есть, по сути, задача дан граф
надо предъявить тройку.
s, t, разрез между ними.
Условие должно быть такое, что s не равно t,
а разрез между ними минимален как разрез между ними.
Так, вот это понятно?
Хорошо.
Значит, это вот то, что мы делаем.
Значит, как же мы это делаем?
А делаем мы это весьма неожиданно.
Вот жайник.
Ну, тут действительно неожиданный,
потому что, честно скажу,
тут я вот это редкий стук,
когда я не очень понимаю, действительно,
как это вообще придумали.
Но жайник предлагается следующим.
Давайте, смотрите.
Мы заводим множество а.
Изначально в нем лежит
одна абсолютно произвольная вершина.
А дальше мы в нее,
значит, мы в нее, соответственно, добавляем
все остальные вершины по очереди.
Но не просто так.
А в определенном порядке.
То есть, по i равно от 1 до
модуль v-1, соответственно.
Мы добавляем в а такую вершину u,
что понятно, что на этот момент времени
u не лежит в а.
И при этом,
нет, давайте,
тут будет v0, а тут будет v.
И хочется, чтобы,
соответственно, вес,
сумагный вес ребр,
соединяющий вершину v
с множеством а,
был максимально возможен.
Надеюсь, подобного рода обозначения
не контрируйте.
Вообще, не контрируйте, что мы так
поплако обозначали уже.
Да, будет.
Хотя...
Ну, нет, подождите.
Нет, у нас w там не было.
У нас были c в качестве.
Они потом снимаются разрез.
А, нет, на самом деле...
Думаю, что это разрез.
Ну, это не разрез, это...
Ну, смотрите, это сумма ребр,
соединяющих вершину v с множеством а.
На самом деле, это то же самое, потому что
это сумма ребр, соединяющих вершины
из доли s, вершину в доле t.
Да, лучше в мое, в фигуре.
Ну, да.
Ну, здесь вот так вот, короче, хотя
формально говоря, конечно, тут вот можно и так.
Это же правда, нет?
Что правда?
Почему у нас не может быть...
Почему это минимальный разрез?
Актуз из множества v множества а.
А это не разрез?
Минимальный разрез это минимум
по w сетей.
W сетей это просто
сумма весов.
Само по себе, да?
Давайте вот скажем, что
если у меня есть два множества каких-то,
пусть у меня есть, допустим, множество
я не знаю, x и y,
то я вот введу определение,
что w от x и y
это просто
сумма w от e
таких, что
e.start
лежит в x
и e.finish
лежит в y.
Ну, я так.
Я так пишу.
Or vice versa.
Ну, тупо меньше букв.
Чем или наоборот.
Нет, лучше бы или наоборот.
А, или наоборот столько же букв.
Ну ладно, и меньше предел.
Ну, окей. Не важно.
Ну вот, то есть это вот просто
обозначение, то есть пока я...
То есть я пока вершину
в множество а
запихиваю, скажем, добавляю
вершину, которая связана с этим множеством
больше всего.
Вот.
За какую асимптотику
кстати, я могу это провернуть
этот алгоритм?
Ну вот, ну
да. Ну, например, v2
плюс e.
Ну, понятно.
Аналог алгоритма prima, по сути, правда.
В чем самого базового.
То есть можно v2
плюс e.
Можно, в принципе,
использовать тут что-нибудь типа
prima с ключей.
Ну, или prima с этом, да.
И сколько будет? e логовая?
Ну и, как всегда, конечно,
можно устроить prima с ключей fibonacci.
Получится e плюс v логовая.
То есть идеальная асимпточка будет
даже не v3 тогда у общего алгоритма,
а
как всегда, ve плюс v2
логовая.
Знакомая асимптотика, правда.
Ну, правда,
возникает вопрос.
Пока, конечно, следующий вопрос, который возникает даже
не на уровне, почему это работает.
А что общественно делать?
А зачем мы
проделали эту абстрактную
операцию в вакууме?
А проделали мы
ее вот зачем.
Значит,
дело в том, что
вот есть черномагический факт.
Пусть s и t
это
последняя
фона, наоборот,
предпоследняя и последняя, соответственно,
предпоследняя
и
последняя
вершины
добавленные
в а.
Тогда
значит, смотрите,
оказывается, внимательно, есть
минимальный разрез
между s и t.
Это
это вы не поверите.
Ну, короче, разрез, в котором
в одной доле лежит только вершина t,
а в другой все остальное.
Ну да, то есть если мы
поверим в это мистическое утверждение,
то, собственно, дальнейший алгоритм
уже реализовать трудами составляет.
Будем доказывать?
А как?
Будем, будем.
Интуитивно понятно?
Интуитивно понятно?
А, сарказм.
Табличка вот иногда не хватает.
Тем более, что она иногда как-то
добавляет своего веса.
Ну, значит, давайте,
как же мы
это будем доказывать?
Вот отдельно, пусть как-то придумали вообще.
Но доказывать будем так.
Ну, начало-то, в общем-то, система
в общем-то тоже логичная.
То есть жил-был,
как это?
Жил-был сеть.
И рассмотрим
произвольный разрез
c.
Между вершинами s и t.
S и t, которые последние, которые последние.
Да, те самые, да.
То есть c это у нас
произвольный разрез.
Разрез.
Ну, наша цель
доказать, что...
Ну, в чем наша цель?
Надо доказать, что
действительно этот разрез
он не лучше,
чем, собственно, сумма
весов из вершины c.
То есть по сути этого,
что нам надо доказать?
Вот.
Вот.
А теперь смотрите.
Значит, что
у нас тут будет происходить?
Ну, происходить будет примерно следующее.
То есть если рассматривать этот разрез,
то давайте посмотрим, какие вершины будут
появляться в множестве a.
Ну, сначала
будет появляться какая-то вершина.
Ну, без...
Ну, не то чтобы совсем без, там,
конечно, ограничения общности, да.
Вот у нас вот есть вершины s и t,
они будут в разных талях разреза, да.
Значит, ну там самая первая
вершина будет лежать...
Ну, давайте пока предположим,
что в доле вместе с s. На самом деле
не сильного значения это иметь не будет.
Да и не сильного тоже.
Некоторое время
вершины будут находиться
с ней в одной доле.
Потом впервые появится
вершина, возможно это уже даже t будет,
но в какой-то момент обязательно появится
вершина, в нод, который лежит
уже относительно разреза c в доле t,
правда?
Пим-пим-пим-пим-пим-пим.
Ну, потом они опять перескочат.
Вот. Потом еще.
Ну так, сколько-то раз будет.
И вот наконец, в какой-то
момент, то есть они дойдут до
вершины s и произойдет
последний перескочок.
Вот такая вот
интересная идея.
Вот.
Так, теперь
теперь смотрите.
Значит, нас будут интересовать
так называемые
активные вершины.
Давайте
на всех. То есть давайте так.
Вершина v
вершина v
активная.
Активная, если
непосредственно
перед ней.
В a
была добавлена
вершина
вершина
из
другой доли.
Относительно c, конечно.
Относительно
сильно
сильно
c. То есть сначала всех
влечих отпусков. Да. То есть нас
будет интересовать вот эта вершина,
вот эта вот вершина.
Оп. Значит, оп.
Оп. И конечно же
неожиданно оп.
Вот.
Значит, еще мы введем определение,
что, ну, во-первых, давайте введем
av. Это
будет у нас
состояние, ну, вот это состояние
множества a.
Состояние
множества a.
Непосредственно
верну
перед добавлением
v.
Вот такая разница.
Так вот.
Значит,
ну, вот.
Значит, утверждение. Значит, что теперь?
Так. Давайте вот уточним.
Значит, еще
важное обозначение для нас будет
это. А, ну, еще
очень просто сказать, что давайте пусть это
cv
разрез. Вот тут внимание.
Сейчас будет внимание. Разрез
множества
каково оно что?
Множество av
внимание объединенного с v
это важно.
Ну, понятно, индуцированного
разрезом
c. Ну, думаете, понятное
я имею ввиду, да?
То есть, как бы мы рассматриваем
тот же самый разрез c, только
не на всех решимах, а только на этих.
Так вот.
Листическое утверждение.
Которое мы сейчас будем активно
доказывать по индукции.
Значит, утверждение такое
для любой
активной
вершины
v
верно,
что вес вот этого
вот разреза
он
больше либо равен
чем w
между v и av.
Это все, что нам нужно
на самом деле.
Так что, наверное,
истинно так.
Если мы это докажем,
то мы по сути докажем, что это
для активной t, а это ровно то, что надо,
потому что cv, то есть ctt
есть просто полный разрез.
Что такое w для cv?
Вес этого разреза.
То есть, мы рассматриваем только вот эти вершины.
Разрез между ними индуцированный
c, но вот, допустим, для активной вершины
это будет вот примерно вот посюда, да?
И рассматриваем вес всех ребер,
которые вот тут находятся вот выше и пересекают
разрез.
Вот.
Так что, соответственно, если мы докажем,
то есть поверим в это, то
в общем-то мы уже поверили во все.
Значит, как же
это теперь доказывать?
Ну, заметим, что
база индукции
верна просто автоматически,
правда?
Ну, потому что когда у нас
мы находим самую первую активную вершину,
то есть самую первую смену, то мы обнаруживаем,
что это верно просто потому, что это одно и то же.
Вот.
Ну да.
Да, хорошо.
Обратите внимание, то есть
в точности то, что
надо.
А теперь давайте
попробуем проделать
переход.
Значит, вот давайте
попробуем с этим внимательно
поиграть.
Вот пусть у меня есть две последовательные
вершины.
Соответственно,
В и У.
Это две последовательные активные вершины.
И предположим,
что для У мы все доказали,
то есть для У утверждение верно.
А теперь попробуем доказать
то же самое для...
У нас разрез
во всем графе СВТ
это разрез под множество графов.
Да.
Да, но и здесь
В, обратите внимание, показывает не все графы,
торчащие из В, а только те, которые торчат
в более ранние вершины.
Хорошо, а почему нам не достаточно этого утверждения?
Почему нам было хватает?
Потому что, когда мы приходим
на Т, то как бы СТ
это разрез всего множества,
потому что это все вершины.
Почему это все вершины?
Потому что Т последнее добавленное.
Последнее добавленное, ну и что?
А мы добавляли все вершины по очереди.
Это значит, что АТ
это все вершины без Т.
Сейчас, то есть мы
таким алгоритмом найдем одну пару СТ.
Да.
Мы найдем, да.
Мы найдем одну, да.
Это алгоритм, как за квадрат
найти одну пару СТ.
Да, и мы это будем потом сжимать СТ
и проделывать это на раз, конечно.
Именно поэтому у нас
НКПНН квадрат.
Отлично.
Так.
Жило было У.
И так для У мы вот
что-то доказали.
Вот. Ну теперь
давайте попробуем вот что сделать.
Ну давайте вот просто попробуем
для разминочки пописать.
Вот давайте В от В и АВ.
Это что такое?
Вот.
Ну вот.
Ну, соответственно, смотрите.
Плюс того, что В от
В от В и АВ.
Это просто равно
В и АУ
плюс В от В
и АВ
без АУ.
Ну, пока вроде ничего неожиданно.
Значит, какой же здесь
вот здесь уже
можно сделать кое-какое неравенство.
Я утверждаю, что теперь я могу
написать. Значит, вот пишу меньше
либо равно. Значит, я тут
напишу плюс В от В
и АВ без АУ.
Вот это я пока приписываю.
А здесь я пишу
В от У
и АУ.
Да.
То есть обратите внимание, почему мы это сделали?
Да, ровно потому, что
по построению алгоритма.
То есть помните, жило было множество АУ
и мы выбирали вершину,
которая к этому множеству
связана ребрами максимального
суммарного веса.
Это оказалась вершина АУ.
А не вершина В.
Совершенно верно.
Вот.
Значит, что же у нас теперь?
Это по построению алгоритм.
Вот. Но с другой стороны,
смотрите теперь, что у нас есть.
Но на самом деле,
теперь мы можем применить
к этому В
предположение индукции. Правда?
Почему?
Ну вот.
По предположению индукции.
Получается
В от СУ
плюс
то же самое. Пока я вот это тоже переписываю.
В без А.
Ну и внезапно все.
Казалось бы, почему все?
Ну, потому что с момента,
когда у нас был СУ,
мы добавили еще вот хотя бы
ребра между В и У
и всеми в последующем.
Ну, добавили что?
Ну они добавили суммарный вес
к подвесу.
Ну, точнее сказать, правильнее вот так.
То есть важно то, что действительно
мы можем обнаружить, что ребра,
которые по определению используются здесь,
это просто подгоножество
ребр этого разреза.
Причем каждое ребро мы учли
не более чем по одному разу.
То есть действительно, что это такое?
Что такое W от СУ?
Это, по сути,
все ребра
вот до этого момента.
Да?
Ну, короче,
ни одного ребра нет.
Ну хорошо, хорошо. Давай нарисую.
Вот.
Все ребра, которые тут
соединяют.
Разве?
Ну, W от СУ
это вот
вот это.
Что такое
вот это?
Это
на самом деле вот это все ребра.
Да, это правда.
То есть на самом деле
да, но на самом деле
чего нам не хватает? И здесь мы пользуемся
еще одной важной предположением.
Вот, обратите внимание.
То есть теперь остается только увидеть,
что это просто почти все ребра.
То есть не хватает нам на самом деле
только ребра, которые соединяют
вот эти вершины с вот этими.
И здесь мы пользуемся еще одним важным
предположением в нашей условии.
Да, что все леса не отрицательные.
Обратите внимание, на самом деле мы здесь этим
не явно воспользовались.
Потому что если бы они были отрицательными,
то бы оказаться, что вот тут какие-то ребра
отрицательные, поэтому там это
неравенство не имеет.
О, мы все.
Доказали.
Что-то как-то даже...
Можно перевыходить все?
Ой...
А о чем мы сейчас планируем?
Ой...
Ну, оказал...
Да, оказал, да. Можно, конечно, остановиться
как маленькие красивые задачки.
Но нет.
Оказывается, то есть
на самом деле мы можем...
То есть, на самом деле, можно и красивее.
Ну, то есть это, конечно, тоже.
Причем самое смешное, что мы идем не по хронологии.
Потому что, по-моему,
вот эта штука, это вообще, вроде, января 1980-е.
А структура данных, которые мы сейчас будем
ускутять до 1961.
Причем она, на самом деле,
может быть, честно даже более всеобъемлюща.
И она, на самом деле, будет позволить нам
делать более сложные задачи.
Вот сейчас мы тут едва-едва
нашли тут какие-то две вершины СТ
и минимальный разрез между ними.
Сделав это энеранс, там что-то сжимаем,
мы нашли вообще,
резерили вершины на две нитривиальные доли
так, чтобы вообще разрез был глобально минимальный.
А структура данных, которые мы сейчас перейдем.
А, нет, прежде чем, да.
Важно, конечно, ответить,
что этот алгоритм,
это алгоритм Штормардера.
Секундочку,
можно про это сделать?
Да.
Мы получили,
что разрез
у нас всегда одна вершина
и все остальное.
Да.
Мы уже специфическое разрешение сказали.
Нет, нет, нет.
Да.
Утверждение.
Нет, не обязательно.
Где мы находили что-нибудь кроме такого разреза?
На следующих итерациях.
Дело в том, что, смотрите,
вот это утверждение говорит...
Да, там будет жил.
А так пока, действительно, это тоже не самое
тривиальное утверждение,
но утверждение говорит о том, что
существует вершина,
существует две вершины,
такие что,
разве минимальный разрез между ними,
это разрез, который выделяет
от той вершины.
Это тоже, на самом деле, не самое
интуитивное утверждение.
А можно подытожить?
Мы доказали то утверждение,
что на любой активной вершины В
много веса...
Отлично, сворачиваем пружинку обратно.
Почему это?
Это означает, что, так как вершина Т активная,
то это означает, что это утверждение
вернует для вершины Т.
Следовательно, но для вершины Т,
то есть, для вершины Т
что это получится?
То есть, это получится W A C,
ну, потому что C и C T это одно и то же.
А W A C T получается
больше либо равно, чем
W A T и A T.
Вот я вот переписал.
Что это такое?
Я переписываю просто то же самое.
C T это C.
А A T это множество вершин...
Все кроме T.
Ну да, то есть, множество модуль В
без C T.
Это еще нет.
Где вы тут видите?
Я донесу гениальную новость.
Эта штука есть в Boost.
В смысле, в расширении стандарта
STD.
Boost это не расширение стандарта STD.
Это просто библиотека.
Да, но которая
опредендует на расширение
стандарта STD.
Моя любимая задача в контесте теперь.
А что?
В какой-то гнушке это уже
не явно реализовали?
А Boost можно использовать?
Блин!
Не, ну как сказать?
Там смешнее было, что кто-то
где-то в гнушке едва ли
нашел просто кучу фибонаки, на самом деле.
Несколько лет мы обо мне.
Ну, на самом деле, да.
Ну, давно пора. Хотя, по этой логике
это называется, давайте добавляйте уже в STD весь Boost,
давайте, пусть там тогда уже и дейкстру там
не надо будет писать.
Там все есть, на самом деле, там давно уже все реализовали.
Но там, правда, отдельно
с графами надо учить, там какие-то концепции,
какие-то эпические, я не помню.
То есть, надо знать.
Но, видимо, если вы имя владеете, то...
Хотя не знаю.
Вот!
А можно дальше, в смысле?
Мне не о чем говорить.
Мы хотим доказать, что...
Мы начинали вот в чем.
То есть, мы заметили, что сам мы взяли абсолютно
произвольный разрез между STD.
То есть, что это вообще?
О чем это было вообще?
Это было вот о чем.
Мы запустили вот этот алгоритм.
Обнаружили, что
STD это предпоследние
и последние вершины, которые были добавлены в АСА.
Мы...
И вот...
И что мы дальше сделали?
Мы взяли произвольный разрез.
Абсолютно произвольный разрез
между STD.
И начали думать, просто думать, ничего не делать.
И доказали, что
вес этого разреза
больше либо равен, чем вес разреза,
который просто соединяет STD со всем остальным.
Ну вот, следовательно, доказали, что
лучший разрез между STD это реально разрез,
который STD и все остальное.
Все.
Я вот свернул спружинку.
Ну вот.
Ну дальше можно сворачиваться,
сделаем это все, и раз, и получим весь алгоритм.
Вот, такая красота.
Это называется алгоритм Штор Вардера.
Не Штора Вардера, а Штор Вардера
в общем.
Почему? Потому что Штор — это мотить, да.
Так, я не помню,
столкнулись вообще с этим эффектом, или нет?
Нет.
Ну, пока не столкнулись, да.
В следующем году,
вопрос для знающих, угадайте,
в связи с каким алгоритмом мы столкнемся
в следующем семестре с этим эффектом?
Не знаете, Долон?
Нет, этот алгоритм вы точно знаете.
Не знаем, что у него какие шторы.
Нет.
Ну эффект, почему фамилия не склоняется?
Нет, потому что в следующем семестре
у нас будет алгоритм Ахакарасик.
Ахакарасик — это марка.
Так что, если кто-то говорит,
это напишем Карасика,
то вы это, проявляйте, проявляйте
большое неуважение, да.
Вот.
А Карася?
Это в моем чистое респект.
Ну да, не говоря уже о той мелочи,
что там еще и Карасик черезу пишется.
Кстати...
Аптичерта.
Вот.
Хоть это и не птичка, но все-таки, да.
Ладно.
Но это будет в следующем семестре.
Я думаю, в этом семестре мы все-таки
на строку жевать не будем.
У меня в раньшее.
Нет, зачем? Ну, что-нибудь еще...
Ой, нет.
Может быть, это алгоритм.
В конце концов, это алгоритм.
Надо же это минус стол за крутую асимптотику найти.
Вот, ладно.
Сначала мы по ТОТИ закончим, конечно.
Хотя мне от раздражения, что мы
в Рискуевле сегодня закончим.
Все еще вопросы? Отлично.
Ладно. Так вот.
Ладно.
Еще вопросы по этому алгоритму есть?
Нет.
Нету?
Ладно, тогда смотрите.
Теперь смотрите.
Теперь мы попробуем сделать кое-что еще.
Пока это мы просто нашли
какой-то минимальный разрез.
Какой-то минимальный разрез.
Но на самом деле хочется
поставить себе большую цель.
Хочется найти
минимальные разрезы
внимание, между всеми парами вершин.
То есть я хочу
как-то описать
ну, возможно, там
то есть как-то описать, то есть
найти какую-то структуру, которая позволит мне
между любыми двумя вершинами
находить минимальный разрез.
Как-то это описать.
Но спрашивается, как это может выглядеть?
Ну, самое легкое, что
может тут действительно возникнуть
это, конечно, тупо матрица.
Ну, для начала,
хотя бы на уровне чисел, если да,
возникает тупо матрица.
Матрица, в которой хранятся
все минимальные разрезы?
Ну да, такие веса
минимальных разрезов.
Между всеми парами вершин.
Ну да.
А зачем?
Чего зачем?
Как первую прикидку.
Ну, самый тупой.
Самый тупой ты и я могу.
Ну, как всегда, надо начинать
с чего-то тупого, потом
что-то оптимизировать, оптимизировать.
Знаете, как это бывает?
У вас ситуация,
вы находитесь в какой-то олимпиадной школе,
вам нужно для детей придумать какую-нибудь прикольную задачу на ксор.
Простенькую-простенькую.
Ну, вы придумаете какую-то очень простенькую задачу,
а еще можно ее допилить вот так.
Вообще еще вот так.
А, так вот какая-то стойная задача придумывается.
Все сразу отстойно.
Может ты сидишь, автор сидел, накручивал.
Нет, ну там даже не накручивал,
еще идеи, еще идеи.
Вот, идеи результатов.
Ну, вот.
В результате получается задача, не сложная по коду,
но, видимо, приличная сложность
по математике, которую там в Петрозаводске
почему-то только две команды знают.
Нет, просто у меня вот реально такое
случилось как-то.
Читают, видят,
о, матеша, все.
Не, неправда.
Это неправда, извините, в команде обязательно часто есть математик,
которые как раз готовы взять задачу.
Нет, ну почему матеша?
Ну там не совсем матеш, а там,
как бы, нормальная,
но тем более все.
Все нормально.
Так что, скажи,
нормально, на самом деле.
Так вот, значит, давайте теперь подумаем.
Итак, пусть у нас есть вот эта вот мистическая
матрица.
F.
И у нас вот есть такое, то есть F от ИЖ
это вот вес,
можно сказать,
мин разреза
между ИЖ.
Ну первое, вообще, что
возникает, вот просто,
на этом уровне,
это, а насколько произвольные числа
могут быть в этой матрице?
Ну, то есть, условно говоря,
ну, то есть, понятно, что все эти числа, конечно,
должны быть не отрицательны, тут без вопросов.
Но интересно, вот,
тут насекает вопрос.
Если я просто накидаю
в эту матрицу рандомные числа?
Ну, естественно, симметричные.
Все еще будет нековано.
Да.
Почему?
А потому что, если у вас есть такие три числа,
что что-то там, больше чего-то там,
то, может быть, у вас есть три числа,
что что-то там, больше чего-то там,
то можно разрез по-другому построить.
Да.
Ну, а тут уже речь будет не о разрезе,
тут уже речь о том, что, может быть, вы
графки правильно построили?
Ну, потому что, что значит
вершина адекватная? Что значит матрица адекватная?
Значит, существует граф, который...
Да, у которого разрезы минимальных разрезей,
именно такие.
Вот. Ну, вот возникает вопрос.
Смотрим три вершинки,
S, T и F.
Посмотрим, какие вообще
бывают тройки разрезов между ними.
Тройки разрезов?
Ну, в смысле, разрез S, T, разрез S, V
и разрез V, T.
И что? Что-нибудь получим.
О чем?
Действительно, что-то мы действительно
получим, а это будет сейчас очень интересно.
Хоть не райстриугольник, скорее всего. Да.
Два из них вроде совпадать должны.
Да. Сейчас.
Не совсем. Ну, точно.
Ну, не обязан, потому что...
Ладно, не вспомним. Просто разрез
между S и T, а то V будет лежать
в одной из долей. Да, совершенно верно.
Но это вовсе не означает,
что это минимальный разрез
между V и T тоже, потому что, может, минимальный разрез
между V и S и
между V и T, на самом деле, отправляется...
Ну, не понятно. Но тогда он хотя бы разрез.
Да.
И это тогда... Здесь мы можем записать
тогда следующее интересное утверждение.
То есть, это про матрицы, да?
Ну, понятно, что условно там
будем говорить, что
F и E равно 0,
F и G равно
F и G и...
И еще можно записать, что
F... Вот я так
напишу. F...
Ну, давайте, ладно.
Спокойно. Будь здоров.
Значит, F от S и T
на самом деле
больше либо равен минимума.
Вот мы это так сформулируем.
Между S и V
и V и T.
Нет, не равен.
Не обязательно.
А, и равен минимуму
из этого и всему S?
Ну, там...
Ну, просто учтем, что...
Есть вариант, когда S единственная
вершина в своем множестве.
Сто.
Ну, разные варианты есть.
Ну, давай.
Ну, давайте так.
Давайте начнем с того... Давайте так, аккуратненько.
Почему вот это утверждение...
Почему это вообще верно?
Ну, это понятно, почему это верно?
Сейчас, минимум
из...
По всем B.
Нет, минимум из конкретно
вот этих вот двух F.
Для любого V это верно?
Для любых S,
T и V.
То есть, вот так.
Для любых V, S, T.
То есть, для любой тройки это верно.
То есть, как вы и сказали,
рассмотрим поизбольные три вершины,
тогда вот верно для F от S и T.
Ну, доказательств очень простой.
То есть, надо доказать, что F от S и T
больше либо равно, чем что-то из этого.
Ну, действительно,
рассмотрим этот разрез
между S и T.
В попадет в какую-то долю.
Ну, допустим, в долю T.
Ну, если она попадет в долю T,
тогда мы замечаем, что этот разрез
он является еще и разрезом
между S и V.
Вес этого разреза F от S и T,
и он больше либо равен
минимального разреза
между S и T.
Да, потому что
это мистический принцип математики.
Как бы
вес произвольного объекта
больше либо равен, чем
вес минимального объекта.
Поразительный факт.
Поэтому получается, что в данном случае
F от S и T больше либо равно,
чем F от S и T.
Ну, а если бы вы оказались здесь,
то было бы F от V и T.
Да, ну, давайте подумаем.
Очень хочется заявить,
что там равенство.
Но
тут вот возникает вопрос.
Хорошо, это мы сейчас видим,
что вот в данном случае F от S и T
больше либо равен, чем F от S и V.
Но обязательно ли он ему
именно равен?
Вот почему
может быть нет?
Вот действительно, давайте думать.
Почему может быть нет?
Возможно, если S и V в одной доле.
Да, какое может быть.
И вроде все.
Да, но это и принципиально.
То есть на самом деле.
Ну да, пример на самом деле привести очень просто.
Ну вот.
Ну хотя бы что-нибудь подобное.
А вот.
То есть действительно, чтобы найти
минимальный разрез между V и T чем-нибудь,
то конечно выгодно S и T отправить
в одну долю.
Вот.
Да, то есть кажется, что по модулю
конечно чуть-чуть уточнить и будет
полное утверждение.
Но на самом деле вот это
уже полное утверждение.
Да.
В каком смысле? В том плане, что я утверждаю,
теперь более нейтралийальное утверждение,
что если матрица
удовлетворяет
вот этим свойствам,
то можно подогнать подходящий
граф.
Если F
удовлетворяет
утверждению,
то
можно
построить
подходящий
граф.
Что увлечаешь?
В смысле, легче?
Наверное, дерево можно построить.
Вот. На самом деле, да.
И более того, этот граф
будет деревом, что интересно.
Значит, как это сделать?
Да очень просто.
Вот смотрите.
Вот.
Вот.
Вот.
Вот.
Очень просто.
Вот. Смотрите.
Заметим, что я из этого утверждения
могу вывести еще кое-что.
То есть, я могу вывести, на самом деле тут
написать так, что на самом деле
F от ST больше либо равно, чем
минимум из
F от SW1,
FW1W2,
f, v2, v3 и т.д. f от v-1, т.д.
Красиво, да?
Why?
Because.
Ну потому что цепочкам будет такая примерно.
То есть f от st больше либо равно, чем минимум f от sv1, fv1, т.д.
Это что? Теперь эту штуку.
Если...
А, уже, да.
f от sv1...
Давайте я распишу, чтобы было понятно.
Вот f от minimum f, v1, v2 и, соответственно, f, v2, t.
Ну и т.д.
Ну этот минимум можно убрать, то есть просто подоставить, да?
То есть минимум из трех.
Ну и т.д.
Заметим, это нам кое-что должно напоминать.
Это знач предыдущего?
Нет.
Это нам должно напоминать, потому что...
Смотрите.
Если мы вообразим себе теперь f не как разрезы, а как матрицу смежности какого-то другого графа.
Получится следующее, что...
Каждое f...
Оно как бы да...
Ну вот.
Что нам должно тогда напоминаться?
То есть f от st больше либо равно, чем...
То есть в этом графе тогда любое f от st больше либо равно, чем минимальное ребро на абсолютно любом пути от st.d.
Ну вот.
На самом деле теперь да.
То есть если это немножко инвертировать, то это будет похоже на что-то, что встречалось в миностолах.
Потому что у миностола, помните, есть мистическое свойство, что дерево является миностолом.
Тогда и только тогда, когда у него любое ребро...
Ну правда, оно больше либо равно, может быть не минимума, а скорее максимума, да?
Нет, точнее так.
Ну, точнее так.
Нет, точнее так.
Любое ребро не из-за стола, оно больше либо равно, чем максимум на пути.
Вот.
Вот.
Ну здесь, соответственно, вот.
Ну здесь возникает, значит, альтернатива.
Давайте построим максимальный асток.
Возвращаемся.
Мы хотим построить граф, у которого разрезы будут ровно вот такие.
Ну вот.
Значит, смотрите.
Тогда вот идея такая.
Давайте построим максимальный асток.
Там будет меньше, правда, минимума, а не больше.
Так.
Ну, с одной стороны, да.
Да.
То есть вот построим действительно вот такой граф.
То есть просто вот максимальный асток.
И тогда давайте смотреть.
Какой тут минимальный разрез?
Между вершинами.
С одной стороны.
Ну да, минимум на пути.
Так.
Ну да, действительно.
Если мы говорим о дереве, то в дереве между любыми двумя вершинами разрез равен, действительно, минимуму на пути, правда?
Ну, формально говоря, разрез.
Ну, как сказать?
То есть действительно выгодно просто распилить одно ребро.
Почему?
Ну, потому что если мы рассмотрим абсолютно две произвольные вершины, то как бы там понятно разрез может пересечь несколько ребер, но хоть одно пересечет, правда?
А у нас все не отрицательные.
Вот.
А на самом деле выгодно было просто взять разрез между всех вот этих ребер, на самом деле взять только одно любое из них, которое вот на пути лежит.
И это будет нехуже.
То есть получается.
Значит, смотрите.
Вот.
Ну вот.
То есть вот получается действительно такое вот маленькое интересное утверждение.
Вот.
Что в данном случае, то есть мы действительно.
То есть.
То есть действительно.
Если так посмотреть.
То в данном случае тогда в этом графе минимальный разрез.
Он.
Ну, с одной стороны, вот это вот f от st.
Допустим.
Да.
Он всегда.
Вот.
То есть он соответственно будет.
Больше либора.
Чем.
Ну.
Ну вот.
Сформулировать нормально.
Так.
Так.
Ну вот.
Значит, смотрите.
То есть ну с одной стороны действительно автоматически верно, что оно.
Ну кажется понятно уже.
У нас разрез будет в таком графе равен минимум на пути.
Но при этом f от st.
Оно не больше.
Оно.
Оно не может быть больше минимума.
Потому что тогда мы могли бы добавить вместо другого.
Значит оно будет равно минимум.
И равно разрезу.
Да.
Что-то такое.
Ну да.
То есть действительно.
Да.
Как бы да.
F от st больше либора.
Но действительно.
Да.
Почему этот минимальный разрез равен именно f от st.
Вот.
Ну действительно.
Ну вот.
То есть действительно.
Если бы оказалось, что f от st.
То есть действительно.
Если вот это вот f от st.
То есть в этом графе там разрез был бы.
Ну то есть вот f от st от разреза.
Он был бы строго больше.
Чем какой-то из этих районов.
То тогда этот астов не был бы максимально.
Потому что мы бы это минимально выкинули.
Добавили бы.
Это было бы строго больше.
То есть отсюда.
Получается весьма мистический факт.
Что в этом дереве.
Минимальный разрез между st.
Это не больше либор равно f st.
А ровно f от st.
То есть получается.
Просто.
Существует дерево.
То есть уже так.
То есть первое.
Видите.
Не самых сложных соображений.
Но оказывается, что.
Просто существует дерево.
То есть для любого графа.
Существует дерево.
На котором по крайней мере.
Веса разрезов.
Одни и те же.
То есть такие же, как и в основном графе.
То есть на самом деле.
У него тоже такое дерево построено.
Но на самом деле.
Утверждение, которое мы докажем.
Еще более сильное.
Потому что это дерево.
На самом деле позволяет.
Естественным образом находить.
Не просто без минимального разреза.
Но сам минимальный разрез.
То есть мы его пока.
Конечно же не доказали.
Но.
Мы построим такое дерево.
Чтобы в нем.
По минимальному разрезу.
Можно было восстановить минимальный разрез.
В исходном графе.
В чем?
Пупым образом.
То есть сказать, что.
Допустим.
Минимальный разрез.
Это вес у нас какого-то ребра.
Какого-нибудь вот этого.
Тогда если его отпилить.
То у нас получается вот такой разрез.
Такие два под дерево.
Так вот.
Утверждается, что тогда и в исходном графе.
Это тоже будет именно это минимальный разрез.
Такое вот более сильное утверждение.
И это и будет называться.
Дерево гуморивки.
Это две фамилии.
Распиливаются они дефисом.
Вот в этом месте.
Вот.
Дефис вроде не минимальная.
И что?
Дефис вроде не минимальная.
Это не меньше, чем риски гумора.
А это почему?
Почему растеревается дефисом?
Не, вот здесь еще.
Что?
Распиливается в этом месте.
Я имел в виду, что когда мы говорим гумориху.
Мы произносим две фамилии.
Дефисом я показал, где заканчивается одна фамилия.
И начинается другая.
То есть к самому алгоритму.
Этого отношения само по себе не имеет.
Вот.
Это абсолютно реальные две фамилии.
Собственно есть статья 61 года.
Собственно милая статья, кстати, вполне.
Мы уже доказали, что по данному F
можно построить граф.
Ну да.
Так что построили.
Мы его прям в явном виде построили, доказали.
И это та самая идея.
Мы взяли граф,
по которому каждое ребро
между F и V2
нашли максимальный астов.
И этот максимальный астов взяли как граф.
Мы построили для нас
аст.
Это равно минимум.
Это равно минимум.
Нет, мы просто...
Нет, на самом деле, смотри.
Что мы сделали? Еще раз.
Рассмотрим матрицу с вот такими условиями.
Мы строим...
Граф строим так.
Сначала мы строим граф,
который вот с такой матрицы смешности.
А потом у него
оставляем максимальный астов.
И после этого
мы доказываем,
что между любыми вершинами СТ
минимальный разрез в этом дереве
он реально равен
этого теста.
Вот что мы сделали.
Отдельный вопрос как.
Это не очень сложно, но мы это сделали.
Вот.
Теперь, смотрите,
давайте подумаем.
На самом деле, да.
Вот такое дерево.
По умолчанию, конечно, это дерево.
Это какое-то относительно абстрактное дерево.
Но с другой стороны, насколько оно абстрактно?
Ведь, на самом деле, если так вдуматься,
то давайте
рассмотрим снова глобальный разрез.
Стоят, стоят, стоят...
И вот мы нашли
великий
минимальный разрез.
Великий минимальный разрез.
Это был призвольный граф.
Да, это был призвольный граф, в котором мы нашли
минимальный разрез. Глобальный минимальный разрез.
Но тогда, заметив следующее,
что минимальный разрез между любыми двумя вершинами
из разных долей этого разреза
это вот этот разрез.
И тогда, как-то весьма логично
на самом деле сказать
действительно, что разбить эти вершины
кажется интуитивным на два множества.
И как-то сказать,
что давайте теперь найдем
минимальные разрезы между всеми парами вершин.
Вот тут внутри, здесь
и внутри здесь.
И будем искать, потом
их там эти два дерева подцепим друг к другу.
Потому что тут тоже окажется
вот этот минимальный разрез, вот этот
или этот. Они тут соединятся
между собой, ну и так далее.
И потом их как-нибудь подцепим.
Но правда возникает маленькая проблема,
что на втором переходе
уже возникает проблема, что
вот эту штуку, во-первых, надо куда-то цеплять.
А во-вторых, что самое интересное,
это кто сказал, что в минимальном разрезе
между любыми двумя вершинами
на самом деле вот это вот оно
обязательно в одной доле лежит, что ли?
Да, конечно.
А если они в одной доле,
то это минимальный разрез?
Смотри, ребышко.
Почему?
Снял кусок, и это
в множество вершин.
Так, возьмем.
Получим
множество вершин.
Какое?
Да.
Ну давайте сразу нарисуем.
Потому что да.
Потому что тут действительно возникает утверждение,
которое мы захотим доказать.
Значит, смотрите.
Сформулируем мы его так.
Мистическое утверждение.
Пусть.
Значит, допустим А и
допустим не А.
Это
минимальный разрез
между
С и Т.
Вот так.
А теперь говорим так.
Пусть.
Вот допустим И и Ж
лежат в одной доле А.
Тогда утверждение
заключается в следующее.
Если
сжать
если сжать вот эту вот
другую долю в одну вершину
то
минимальный разрез
между
И и Ж
не поменяется.
Вот.
Понимаете?
Да, почему?
Как говорится
Ну почему?
А смотрите почему.
Значит, смотрите. Итак.
Вот у нас есть
значит, А и А с тильды.
Это разрез между вот
вот
ну допустим
ну допустим С и Т.
Вот. И вот, предположим, что у нас
тут возникли вершины И и Ж.
Ну здесь допустим
вот сейчас скажу.
И между ними есть минимальный разрез.
То есть тут вот есть
четыре таких зоны.
Чего?
Я не понял, что это.
Притикальный разрез между С и Т.
А С и Т это кто?
Ну С вот там. Т лежит
где-то здесь.
Ну она лежит просто либо здесь, либо здесь.
На каком верхнем?
Вот сверху
крыльчат.
Ну Т где-то здесь лежит.
Здесь вот С лежит там
допустим.
Секундочку.
Мы уже сказали, что сейчас
а на левом рисуночке это что?
Мы уже сделали утверждение, что
и что мы доказываем теперь.
А доказываем
мы следующее, что когда мы будем искать минимальный
разрез между И и Ж
вот это вот минимальный разрез
между И и Ж.
Б допустим
Ну без ограничений общности мы можем считать
что С лежит в одной доле с И.
Вот с Т
вот почему я Т не нарисовал.
Ну с Т конечно не совсем.
Тут как повезет.
Тут либо Т может быть и в одной доле
СС в этом разрезе, а может быть и в другой.
Что это за СС?
Это произвольное СС? Да.
То есть мы взяли произвольное СС
абсолютно, нашли минимальный разрез.
Потом просмотрели две вершины, которые
лежат в одной доле этого минимального разреза СС.
И тогда мы утверждаем, что мы можем
сжать другую долю этого разреза
и минимальный разрез между ежей
от этого не поменять.
Это уже не глобальный
миноразрез.
Это уже просто разрез на еды.
Мож risesound это не обязательно
какие-тоiller88888889OO
Что?
Что что?
Нас заск장или, Максим.
Нам сказали что мы возьмём минимальный разрез
глобальные. Это минимальный разрез, но между ССП. Изначально нам это говорили, потому что возникала идея, из каких примерных
идеей возникает, что да. Существование такого красивого дерева это логично. Хотелось себе такое
вообразить. То есть на самом деле, если бы у нас была задача просто построить дерево, то можно было бы
уже и сейчас ставить. То есть строим минимальный разрез. Дальше потом ищем, как находим тут внутри в этой
доле какие-нибудь две вершины с минимальными соединениями. Ну а дальше тут появляется
какие-то рекурсивы на два дерева и мы эти деревья соединяем. Но это бы построилось просто. Дерево такое,
что веса минимальных разрезов нашлись бы. То есть берем любые две вершины, находим минимум на пути.
Но это бы не обязательно соответствовало самому разрезу. То есть чтобы показать, что это будет
соответствовать самому разрезу, нужны более аккуратные вершины. И вот собственно это первые из них.
Вот давайте допустим пока, допустим, что Т у нас лежит в этой доле. Вот. Так. Ну давайте,
как бы нам обозначить эти четыре множества? Ну давайте вот эти четыре множества вершин
обозначим х, х с тильдой, игог с тильдой. Как тильды связаны с тильдами А и Б? Нет,
х относится к доле А, игог к доле А с тильдой. х, игог относится к доле B, х, игог с тильдой относится к доле B с тильдой.
Ну я не знаю, я могу дописать тут это х1, х2, х3, х4. Ну так что, что нам вообще надо? Там надо доказать,
да, что если бы, то есть мы хотим доказать следующее, что ну, например, ну один из вариантов,
что если мы сейчас игрок с тильдой перенесем вот сюда, то хуже не станет. В каком смысле? В том
плане, что вот разрез между И и Ж, от этого мы только выиграем. Ну для этого по сути надо доказать,
что, ну я вот буду, раз уж мы используем С, я так и буду использовать. То есть, если, ну вот, то есть
для этого нам надо показать, что, то есть вот если текущий разрез между И и Ж его вес, он равен f от
x, x стильдой, плюс f, x, y стильдой, плюс f, y, x стильдой, плюс f, y, y стильдой. Видите, да?
Это текущий разрез f стильдой. Да, это текущий разрез f стильдой. И это, мы хотим сказать, что это больше либо равно, чем будет
то же самое, если мы перетащим y стильдой сюда. То есть, это будет, то есть, верно ли, что это больше
либо равно, чем f от x, x стильдой, плюс f, y, x стильдой, плюс f, y, x стильдой, x стильдой.
Мы можем сократить. Совершенно верно. Да, по идее мы можем сделать шлёп-шлёп и шлёп-шлёп.
Ну, то есть, по сути, это можно было и сразу написать, что когда мы игроками стильдой
переходим, то как бы вот эти вот две f-ки исчезают, но появляется вот это. То есть, по сути, мы хотим
доказать, что, то есть, это вот эквивалентно тому, что условно f, x стильдой, y стильдой,
я вот в таком виде запишу, минус f, x, y стильдой, минус f, y, x стильдой, меньше либо равно нуля.
Пока будет всё понятно. Вот. Ну вот, ну теперь вот возникает вопрос. Откуда же мы эту мистику возьмем?
Ну, каким-то образом нам, наверное, надо воспользоваться тем, что вот этот вот разрез
между СТ, он минимальный, правда? Чтобы этим воспользоваться, мы сделаем вот что. Мы попытаемся,
наоборот, перенести y вот сюда. Оттого, что мы перенесем y стильдой вот сюда, эту долю S,
то от этого разрез только увеличится, правда? Разрез между СТ. Давайте это запишем. То есть,
это будет означать, что текущий наш разрез это f от x, y, плюс f значит x, y, x стильдой,
плюс f x стильдой, y, плюс f x стильдой, y, x стильдой. И это меньше либо равно, чем то,
что у нас сейчас получится. А то, что у нас сейчас получается, это что? Да. То есть, это f от, ну в данном
случае давайте x, y, плюс чего? f, y, x стильдой, y. Ну, там понятно, буквки можно местами менять,
да? Так, вот это мы точно знаем. Разда, как и то, что здесь тоже можно делать шлёп-шлёп, ну и, конечно,
шлёп-шлёп. Видите, да? На самом деле, смотрите, так как у нас все f не отрицательны, опять мы
этим пользуемся, да? То из этого следует маленькая приятная вещь, что f от x, вот это вот y, она заведомо
меньше либо равна f, y, x, стильдой. А уже из этого, обратите внимание, следует ли это всё?
В общем-то, всё, доказательства обычно. Могли бы даже что-то проще сказать. Там типа y с волной
передвигаем, у нас добавляются y и y с волной, а убираются x с волной и y с волной, поэтому не
Сейчас я не понял, что мы доказали в последний момент, как мы перешли? Ну, смотри. Кого мы на что
заменили? Значит, мы никого не на что не заменили. Вы доказали, вот это нужно вот то. Значит,
смотри, это вес разреза между a и a стильдой. Это вес разреза между, соответственно, y стильдой,
между y и всем остальным. Там x объединённое с x стильдой. А, у нас там опять f от x и x стильдой больше 0.
Ну да, здесь можно было так и записывать, то есть мы бы просто замечаем, что так как, видите,
тут f от x и y и f с стильдами, он меньше либо равен этому, то есть вы уже вот это вычли,
уже меньше либо ровно 0. А вычтем ещё, будет только хуже. Всё. Ну, в этом месте догадается тварь очень.
Почему красный не равен тваря верно ещё? А потому что это не просто f, это веса двух разрезов между вершинами
и c и t. То есть оба вот эти разреза, это разрезы между s и t. Обратите внимание.
Почему это так? Самое первое красное. Что? Вот это вот? Нет, длинное красное. Вот это? Я говорю, это вес
разреза между s и t вот этого. Вот это? Это вес разреза вот этого. А мы все еще есть в предположении,
что t игрок принадлежит. Да, это было предположено. А если нет, то там что-то похожее, да? Да. То есть да,
то есть конечно здесь нельзя говорить, что всё именно общее, но утверждается, что если вы t
перенесёте сюда, то здесь тоже будет идея о том, что значит мы докажем, что y можно перенести сюда
путём того, что давайте перенесём сюда и тут получится ещё какие-то неразницы. Вот, но я думаю,
вы это можете в качестве упражнений с нами пробить. Так что вот такая вот идея. То есть это вот два разреза,
этот минимальный это просто, ну это минимальный предположение, это просто разрез, поэтому я тут
ну а дальше шлёп-шлёп-раз. Вот такая вот маленькая приятная вещь. Вот, значит к чему это нас приводит.
Вот, мы заметим, что это утверждение теперь тогда позволяет вот на вот этот вот механизм
взглянуть немножко по новому, правда? Вот давайте посмотрим внимательно. То есть можно как-то более
аккуратное дерево строить. То есть а именно, то есть теперь, то есть теперь уже по крайней мере на уровне
первого шара к этому дереву можно так, можно найти, ну допустим отбалдывай сейчас, найти минимальный
допустим разрез. Допустим, да? Ну вот и дальше теперь говорить, что вот, то есть сказать, что вот если
мы эту вершину сожмём и будем в этом предположении искать тут какие-то деревья здесь. Вот, ну мы их
соответственно найдём. Вот, ну вот мы их там как-то соответственно найдём и всё, что нам останется,
это только вершину с зацепить за вот эту вот штуку. Ну, казалось бы, по крайней мере. То есть это тоже уже ближе
к истине, но всё-таки не совсем то. Нам же в идеале хочется, чтобы минимальный разрез, чтобы прям дерево
отвечало прям совсем минимальным разрезом, правда? Да, то есть в принципе, да, то есть если наша задача
теперь найти тут минимальные разрезы здесь, ну да, мы теперь можем условно там сжать эту вершину,
ну вот, а потом её разжать и сжать, вот это вот всё. Но пока это всё равно немножко мутнало.
Вот, поэтому, ну вот, ну и дерево откровенно в этом направлении. Так вот, смотрите, как мы теперь будем
строить дерево. Значит, дерево мы теперь будем строить там. Значит, дерево мы будем строить там. Мы сейчас не будем вообще цепляться.
Вот, да, это опять был минимальный разрез. Так вот, мы продолжим не цепляться за минимальный разрез.
Что делать? Мы будем брать первое, ну вот, то есть ну здесь нам будет предлагаться просто взять две вершины
и найти минимальный разрез между ними на каждом шаге. А шаги будут выглядеть так. Смотрите. Значит, дерево будет
строиться постепенно и в каждый момент времени у нас будет дерево метаверши.
Значит, смотрите внимание. То есть в каждый момент времени сейчас в нашем алгоритме будет шаг такой.
У нас будут некоторые метаверши. Ну всякое бывает. То есть вот будет построен анод. То есть будет такой вот типа метадерем.
Причем будет верно следующее. Значит, для каждой вершины, то есть для каждого ребра в соединяемых и метавершинах
существует две вершины ИЖ, так что вот этот вот разрез, ну то есть вот вес этого ребра F от ИЖ и более того
минимальный разрез между ними это действительно вес этого ребра. И вот в чем этот разрез выглядит именно так. То есть вершины надо
разбивать именно вот на вот этом ножте и вот этом ножте.
Я не помню, как мы это сделали. В смысле, так. Откуда это взялось?
Откуда это взялось? В смысле, у нас есть дерево? Ну нет, берется так. С чего мы вообще начинаем хотя бы?
А начинаем? Нет, изначально у нас метавершина вообще одна. Ох, то есть мы их разбивали сразу?
Да, вот сейчас мы будем подразбивать. Т.е. мы будем находить две вершины, разрез между ними и разбивать.
Потом еще находить две вершины, минимальный разрез между ними и разбивать.
И в качестве варианта будем поддерживать, что у нас в каждом experience есть дерево. Вот есть метавершины,
метавершины соединены ребрами и более того у каждого ребра есть две вершины. И вот из двух
это вершины так что минимальный разрез между ними реально вот такой вот это
именно вот такой не только вес такой ну и вот сам разрез в условном графе
просто есть не то что для каждой папы ну просто есть ну то есть существует две
вершины не между любыми прям двумя вершинами не разрез между ними именно
такой вот может быть то есть будет такой вот мы будем так аккуратненько
подразумевать и тогда в конце у нас каждый метр вершины будет одна вершина а тогда
если мы поверим в этот вариант у нас по сути это и будет дерево добыть
а сейчас это сейчас это нечетко
формально
ну давайте
не совсем
мы говорим что у нас для любых двух метров вершин соединено ребром найдется в каждой
каждой вершине по вершинке для которой минимальный разрез будет по весу равной весу этого ребра
еще сам разрез это бы разделить по ребру
ну более того конечно вот эта вершина G она не обязана быть одна тут на всей этой вершине
то есть например для этого ребра на самом деле может быть это как и F от KL и вот эта вершина K
вот эта вершина L
существуют такие вершины?
да, то есть можно выбрать
давайте нам по чем себя разбивать
давайте нам по чем себя разбивать
То есть будем вот пытаться поддерживать вот такой вариант.
Как мы это будем делать?
Дерево, мы говорим, это дерево метовершины, да?
Это дерево метовершины, да.
Да, метовершины образуют дерево.
Да.
Вот.
То есть они будут соответственно обгазовывать эти.
Вот.
Ну теперь да, давайте теперь к победе.
Почему действительно это победа?
Ну потому что действительно в самом-самом конце у нас появится дерево метовершины.
Дерево, дерево там вот.
И мы будем знать теперь следующее.
Что между вот теперь вот этими двумя вершинами минимальный разрез это именно вот это.
Видите, да?
Ну а теперь давайте думать.
Вот, допустим, рассмотрим опять вот вершины ССТ.
Между ними есть соответственно путь.
И на этом пути есть, ну понятно, и на этом пути соответственно есть минимальное ребро.
Внимание, вопрос.
Вот, допустим, вот это минимальное ребро.
Вот почему этот вот соответствующий разрез, он является минимальным и между ССТ?
Ну причина очень проста.
Ну начнем с того, что реальный минимальный разрез ФОТСТ, он больше либо равен, чем минимум из весов этих ребр, правда?
Почему?
Потому что эти ребра отвечают за разрез между этим и этим, этим и этим, этим и этим, этим и этим,
а у нас такое там ФОТСТ большего минимума было, видите, да?
Это с одной стороны он больше либо равен.
Но с другой стороны минимальный разрез меньше либо равен, вот, например, вот этого разреза.
Он больше, то есть он больше либо равен этому минимуму и меньше либо равен, потому что такой разрез вот реально существует.
Следовательно, он ему равен.
То есть это действительно минимальный разрез.
И если нам вот так, ну вот, если нам удастся построить дерево с таким, дерево метавершин с таким вариантом,
так чтобы в каждой метавершине была только одна вершина, то это будет действительно наша мечта дерева Гомолеку.
Так сказать наш край.
А внутри метавершин там не обязательно тоже дерево будет?
Изначально внутри метавершин просто множество.
Изначально каждая метавершина тупо множество вершин.
Но когда мы его разбиваем, мы гуляем в бедро.
То есть, конечно, да, на всякий случай, конечно, да,
уточним, что вот эти ребра не имеют ни самого сами по себе отношения к ребрам исходного графа.
Можно вас?
Да.
Когда мы будем разбивать вершины?
Как мы ребра пересоединяем?
Вот, а этого мы еще не описали.
Хорошо.
Вот.
А теперь смотрите, какая будет идея.
Идея будет следующая.
Значит, делать мы будем так.
На каждом шаге мы будем брать, то есть, на самом деле алгоритм еще страдает некоторой произвольностью.
А именно, смотрите, что жила была какая-нибудь вершина,
что мы возьмем первую попавшуюся компоненту, внутри которой что-то есть.
В которой есть хотя бы две вершины.
Возьмем произвольные две из них.
Вот, например, S и вот, например, T.
Да, значит, идея будет в том, что давайте просто найдем минимальный разрез между S и T.
Но...
В каком множестве вершин?
В глобальном.
В изначальном графе.
Да, в изначальном графе.
Но с маленькой оголочкой.
Смотрите.
Вот мы доказали вон то мистическое утверждение, правда?
Тогда оно утверждает, на самом деле, следующее.
Что, так как S и T лежат в одной доле относительно, например, вот этого разреза, да,
то когда мы сейчас будем искать вот между S и T...
Вот давайте я вот выдерну S и T.
То мы...
Вот все, что висит вот на этом подди...
На этом дереве
можем
самостоятельно
то мы...
Вот все, что висит вот на этом подди...
На этом дереве
можем
сжать
в одну.
Мысленно.
Ну даже не мысленно, а объявно.
Мы будем это делать.
Да, и мы будем это делать.
В смысле, но дерево-то не будет меняться.
Потом.
Ну потом-то не будет.
Потом вернем вот это.
Потом мы, конечно, это восстановим обратно, да.
Но когда мы будем, пока мы будем искать разрез, мы это будем вот...
Будем следить за тем, чтобы все эти вершины отправлялись в одну долю.
А зачем следить-то?
Они же так отправятся.
Не отправятся.
Почему?
По умолчанию не обязаны.
Потому что минимальных разрезов может быть несколько.
А-а-а.
Помните об этом?
Нет, что существует не разрез.
Да, самый тупой пример это когда все ребра между всеми вершинами равны нулю.
Тогда у нас минимальным является вообще любой разрез.
Так что поэтому аккуратнее.
Ну а есть еще такая фишка.
Мало того, что вот мы эту вершину можем жать.
И минимальные разрезы от этого не поменялись, да.
То есть вообще нигде вот между этими вот вершинами.
То есть теперь заметим, что мы ровно по этой же причине, не разжимая вот эти, можем теперь жать...
Это под деревом.
Можем ждать и жать и это.
Да.
То есть мы вот все это сожмем.
То есть у нас теперь получится вот что-то подобного рода.
Вот тут S и D.
А у нас же не бинарное дерево?
Не-е-е-е.
Не-е-е-е.
Не-е-е-е.
Тут все что угодно может быть.
Тут абсолютно там вот.
Пожалуйста.
Пум-пум-пум.
Там не-е-е.
Все нормально.
Так, вот это да.
Тут бывает одна мета вершины.
Ничего страшного.
И тоже.
Вот.
То есть получается вот такие вот.
Вот такая вот примерно ситуация.
Да, то есть тут соответственно ребра понятно какие.
Ну тут не ребра, тут просто между...
Понятно.
Вот.
Значит идея тут будет такая.
Значит мы найдем этот минимальный разрез.
Заметим, что этот минимальный разрез отправит какие-то из этих вот сжатых под деревья в одну долю, а какие-то в другую.
И тогда у нас будет идея просто в следующем.
То есть тогда будет идея такая, что мы просто скажем, что вот эта вот доля с s это одна мета вершина, доля t вот эта другая.
Мы их соединяем соответственно ребром веса fst.
А вот эти...
А этих товарищей мы подцепляем в соответствии с найденным разрезом.
Ну и потом соответственно понятно, разжимаем это все и получается.
Я подумал, что это проще делать, ну ладно.
Почему так реально?
Почему вот это ребро сдалось?
Нет, ну как...
Ну на самом деле так, это конечно сейчас не тревожа для других.
Ну почти реально.
А как это по-твоему делать?
Я думал, что нам нужно было вечно все сжимать, сжимать обратно, потом еще считать, что куда-куда пошел.
Не помню.
Я не знаю.
Я не знаю.
А мы s это брали произвольно?
S это да.
Ну вот, мы брали произвольно.
Более того, что самое для нас обидное...
Ну вот, по-видимому Шторвардера мы здесь забабахать кстати не можем.
Почему не можем?
Потому что Шторвардер найдет первые попавшиеся какие-то две вершины в графе, а это будут в том числе и сжатые вершины.
Поэтому то, что можно сказать, что минимальный разрез это вот типа вот это и все остальное.
Примыслово даетесь.
Поэтому к сожалению, здесь вот Шторвардер просто так не работает.
И этот алгоритм, точнее симпточка этого алгоритма, это o от n на max lobe.
Вот такая вот красота.
Но остается только действительно доказать, почему это вообще так.
Почему же это вообще так?
А вот почему, смотрите.
Ну, значит, что нам по сути надо доказать?
Ну, на самом деле доказать надо...
То есть у нас было что было нетривиального в инварианте?
У нас было нетривиального в инварианте то, что у нас есть...
У каждой пары соединенных с ребром метовершин были две вершины, разрез между которыми соответствовал вот это.
То есть что у нас может произойти?
Теоретически у нас может так произойти, что вот жила была метовершина.
Вот у нас SCT, и она была соединена, вот допустим, тут какие-нибудь вершины.
Ну, я от балды напишу, что-нибудь типа UUV, да?
Вот они были тут соединены ребром UUV.
И тут вот это вот было это UUV, да?
Понимаете, да?
Да.
Вот.
Ну, и тут понятно, что тут, понятно.
Тут там висели какие-то там подцепленные вот эти все веревки, еще вот это все, да?
Тут еще что-то висело там.
В общем всякое это виселье было.
Вот.
И могло произойти...
Нет, по идее вроде все инварианты сохраняются, только мог нарушиться какой вариант?
Мог нарушиться инвариант, что когда вы распилили вот это вот FATST, могло оказаться, что вот эта метовершина подцепилась не к той вершине, в которой находится UUV, а к другой.
Ну, могло же такое произойти, правда?
Ну вот, на самом деле нам хочется доказать, нам очень хочется доказать, что, допустим, что такого быть не могло.
Ну, точнее, теортически, точнее, аккуратненько так.
Может быть, на самом деле и могло, но тогда можно было бы сказать, что и здесь такая какая-нибудь вершина найдется в идеале.
Ну, а что это за вершина могла тут найти?
А чем вот тут найти?
Ну, если вот вершина ноты оказалась тут, то на самом деле все, что нам остается доказать, то так как тут вообще могло остаться только вершина T,
поэтому все, что мы можем доказать, это то, что попытаться доказать, что минразрез между T и V, он на самом деле соответствует FATUV.
Понимаете, да?
То есть мы теперь говорим следующее.
То есть жили-были вот эти вот вершины U и V.
И был между ними разрез FATUV.
И взяли мы мета-вершины, обратите внимание, то есть взяли мы эту вершину в U, нашли в ней вершины S и T.
Кстати, какие-то из этих вершин могли даже совпадать, кстати, обратите внимание.
И нашли минимальный разрез.
И оказалось, что все вот это под дерево, которое мы заблаговременно сжали, оно оказалось не в той доле, в которой находится U.
Ну, будем считать, что U оказалось в доле с S.
Понимаете, да?
Так вот.
Значит, нам очень, значит, по сути мы хотим теперь показать, что на самом деле FATUV больше Vib равно, чем FATUV.
Ну, на самом деле получится равенство.
Нет, хотя пока равенство не обязано.
Если мы покажем, что вначале поможет.
Тем, что это серебра на самом деле корректно?
Нет.
Ну, кроме того, по модулю того, что, ну, точнее так, с оговорочкой.
Может так оказаться только что, пока если мы это докажем, то, то есть это тогда, тогда мы заявим следующее, что FATUV можно заменить на FATTV, и дерево будет корректно.
Правда, правда, с мелкой оговоркой, откуда мы возьмем FATTV, да?
Еще глупый вопрос.
А если FATUV меньше, чем FATTV, то почему мы не можем сделать то же самое, поменять вес этого ребра?
FATUV меньше, чем FATTV?
Ну, независимо от того, какой там знак.
Нет, нам, суть-то в том, помните, у нас в варианте было прописано то, что найдутся две, если мы соединяем ребро, мы должны выбрать две вершины, что вот меморальный разрез между ними реально такой, и он как раз тушеный.
Ну, просто если говорить, что мы можем менять вес ребра, то мы можем выпустить его на меня.
Ну, теоретически так.
Но, видимо, нам не очень нужно это делать.
Ну, да.
Вот, так.
Ну, у нас как, ну вот.
Так, ну да, когда, ну вот.
Ну вот, ну у нас, да.
Чего?
Чем нам помогает нижнее отражение?
Там будет равенство сейчас просто.
Ну, на самом деле, да, там будет равенство, то есть идея будет в том, что у нас будет просто ребро перетянуть, на самом деле разрезы не поменялись.
Хорошо.
То есть вот очень хочется вот это.
Ну, давайте так вот, давайте так вот, все, хотим, по сути, да, вызов, равенство.
Да, вот все, что мы хотим.
Так.
Ну, во-первых, заметим, что, ну, наверное, в одну сторону это утверждение очевидно.
А именно, я утверждаю, что на самом деле вот f от uv больше либо равно, чем f от tv, это заведомо правда.
А кем?
А кем?
А кем?
Увидел.
Да, да, да.
Это уже как тогда было, да.
Сейчас буду домашние задания спрашивать, очень спрога спрашивать.
Давай, выучил?
Да.
Точно выучил?
Да, вам я клянусь, садись пять.
Ну ладно, мы не в Казахстане, поэтому да.
Вот.
Значит, смотрите, а это очевидно последующая причина.
То есть дело в том, что f вот этот вот разрез uv между uv.
Он разрезал в том числе и вершины tv.
Поэтому получается, что f от uv это вес какого-то разреза между tv.
И, конечно же, он тогда больше либо равен, чем вес минимального разреза.
Между tv.
Поэтому вот это утверждение, действительно.
Очевидно.
Значит, еще раз.
f от tv это вес минимального разреза между tv.
Утверждение, f от uv это вес какого-то разреза между tv.
Какого?
А именно, рассмотрим вот тот самый разрез f от uv, который разделял uv минимальным образом.
У нас, то есть уже было, что вот этот вот разрез, он уже есть, да?
И он разрезал вот uv.
И он отправлял tv в разные доли.
Да, ясно.
Вот.
Так что на самом деле теперь нам надо показать, что f от tv больше либо равен, чем f от uv.
Это все, что нам теперь осталось показать.
Что?
Поехали.
Значит, как же мы это будем делать?
Вот тут сейчас красиво будет.
Так.
Так, ладно, давайте вообще ликвидируем.
Сейчас.
А можно четернуть?
Давайте забудем про это ребро, в принципе, в общем.
Оставим его как есть.
Пусть живет.
Достроим дерево геморриху.
Получим n горшин, соединенных какими-то ребрами, веса которых мы не знаем.
Запустим еще n разреза.
Просто, может, до вершины, вероятных оставшихся.
Так у нас у дерева сейчас...
А, я, возможно, вряд ли, сохранился. Вот тут стоит.
Да, не все так просто в датском королевстве, да.
А тут тем более.
Ой, хотя да.
Что мы слышали от датских программистов.
Так вот.
Значит, поехали.
Значит, мистическое утверждение, которое заведомо верну.
F от TV больше либо равно, чем минимум из следующей цепочки.
F от TS, F от SU, F от U.
Ну, есть такое ощущение, правда?
Не знаю.
Но, как мы уже выяснили, F от UV, оно больше либо равно, чем...
Так, ну, значит...
Так, сейчас, давайте уточнем. В этом порядке их надо писать или...
Чтобы это сейчас порядок садов не перекутать.
Да, все правильно.
Вот.
Ну, а теперь давайте посмотрим внимательно.
Вот. То есть, кажется, что что-то из этого можно достаточно легко выкинуть.
Мы знаем, что F от TV хотя бы... F от TV.
Ну, вот.
Ну, в смысле, нам нужно показать, что каждый из трех хотя бы F от UV.
Точнее так.
Ну, по сути, да.
Но одно из них точно хотя бы F от UV.
Так, ну, давайте посмотрим. Давайте попробуем... Надо чем-то воспользоваться.
Ну, по сути, да.
Ну, по сути, да.
Ну, по сути, да.
Ну, по сути, да.
Ну, по сути, да.
Надо чем-то воспользоваться.
Надо... Ну, вот.
Надо чем-то воспользоваться.
Но надо, по идее, воспользоваться тем, что...
Наверное...
Ну, вот.
Ну, в сути, да. Можно заметить, что F от TS это, наверное, минимальный разрез между ними.
Чем же WTS?
Да.
Да.
Да. Заметим.
Да. Заметим все это. Маленькую приятную вещь.
Раз вершина W, по нашему предположению, отправилась в долю к T,
то тогда получается, что TS...
Она F...
Ну, то есть, что TS... То есть, F от TS это минимальный разрез, и это какой-то разрез между F, V и U.
То есть, тогда отсюда получается, что F от TS больше либо равен, чем F от...
Собственно, UV.
А так как так, то есть, тогда отсюда получается, что...
Ну, соответственно, то есть, просто F от TS можно радостно выкинуть.
Угу.
Значит, F от TV больше либо равен, чем что?
Чем минимум из...
Ну, F от SU тем же самым.
F от SU... Да!
Ой.
Так.
Так.
F от SU в одной доле любого разреза.
А это неважно, да?
Теперь надо каким-то образом мистическим показать, что F от SU больше либо равен, чем...
Ну, почему-нибудь разрез SU.
У нас там вопросик, но это не нравится.
Да, пока вопросик.
Нет, точнее так. Нет, смотрите, это точно верно.
Да, и в этом не нравится мне этот вопросик.
Да, в этом мы...
Но у нас есть вот это, а нужно вот то.
Да, то есть нам, на самом деле, надо показать...
Ну, как сказать, надо, возможно, попытаться показать, что F от SU больше либо равно...
F от UV.
Что, почему не нравится?
Какое?
Право с минимумом?
Смотри.
Право не нравится с минимумом, это наше свойство разрезов.
Еще забавно факт. Мы знаем, что F от UV, хотя бы F от TV, да?
То есть здесь должно быть разница выполнять, потому что не может быть больше.
Да, но это другое. Из этого и будет равенство следов.
В смысле, мы можем сказать, что F от TV равен минимуму из F от SU.
Не, на самом деле не должен.
Я вам так... На самом деле тут весьма неожиданная идея.
Мы не сможем доказать, что F от SU больше, чем F от UV.
Это может быть и не так.
Да.
Сейчас.
А неравенство можно с минимумом еще раз?
Нет, смотри, вот это неравенство верно, потому что...
Ну, боже, у нас было свойство разрезов, да?
Помнишь, для вот ST и V, да?
Что F от ST больше либо равен чем минимум F от SV и F от VT.
Да.
Это просто оно.
Да.
Потом одно из них выкидывает, что F от T заведомо больше либо равен F от UV.
А теперь тут все сейчас будет весьма неожиданно.
Все отрядущий будет.
Смотрите.
Дело в том, что доселе во всех-всех-всех-всех разрезах, которые мы искали,
S и U оказывались в одной доле, правда?
Правда.
Правда.
А тогда, смотрите, вот вообще...
А теперь, что будет, если я добавлю в этот граф между S и U ребро с весом 57?
Минимальный разрез?
Не изменится.
Тогда, смотрите, все вот эти F-ки, они не изменятся.
Ну, потому что минимальный разрез не изменится, то есть изменятся только разрезы какие-то не минимальные.
И они увеличатся на 57.
Более точно, теперь заметим, что вот эти F-ки тоже никак не поменяются, кроме одной.
Поменяется вот это F плюс 57.
Понимаете, да?
Ну и, как следствие, вот так вот F плюс 50.
Да, какая-то...
Что это такое?
Да, просто чит сезона, на самом деле, конечно.
А что мы еще раз делали, мы провели ребро?
Я провел между S и U ребро веса 57 дополнительно.
И заметил следующее, что все вот эти F-ки от этого не поменялись.
Я бы сказал даже так, важно, вообще никакие F-ки вот из тех, которые мы тут находили, вот именно вот, то есть которые вот ребра метровершина, они не поменялись от этого.
Вот, потому что, да, минимальные разрезы, потому что абсолютно те же.
Да.
Вот, эти вот между, ну вот, то есть поменялось только F от S-U плюс 57.
То есть получается, тогда мы показали, что F от TV больше либо равно, чем минимум F от S-U плюс 57 и F от U-V.
Но 57 это Дед Мороз.
Так и запишу.
Да, в каком плане Дед Мороз?
Ну, в том плане, что без 157 я тут могу написать просто абсолютно произвольное число.
Вот.
Ну, там отсылка, это просто доказательство того, что Дед Мороз существует.
Вам не рассказывали?
Конечно, нет.
А кто это должен был сказать?
Вообще нам это Ромашенька рассказывал.
Жалобственно где-то.
Ну да.
Нет, там просто это крестота была, там что-то в духе, там, там, там по идее Дед Мороз существует.
Доказательством.
Да, ну, согласно ему с тем, что там, если у нас есть объект, который одновременно там обладает двумя свойствами, там существует объект, который обладает двумя свойствами одновременно, то существует и объект, который обладает только вея хотя бы одни разрезы вплоть.
Угу.
Ну вот.
Дет Мороз существует.
То есть как бы все.
У нас существует, да.
Ну вот, вывод Дет Мороз существует.
Почему я на него отсылаюсь?
Потому что заметим, что доказать существование можно всего чего угодно, включая у каждого из вас третьего глаза.
Вот, на самом деле.
Вот здесь тоже.
57 это Дет Мороз.
Потому что я вместо 57 могу поставить 57 в степени 57.
В степени 57.
Лучше.
Где существующий Дет Мороз существует два свойства?
Ну это другое.
Нет.
Ну то, что он существующий.
Ну то, что он существующий и то, что он Дет Мороз.
А это корректно говорить, что существование это свойство?
Ну вот там.
Где-то там, на самом деле, притерилось бы.
Это ошибка там.
Ну вот как-то еще более красиво это формулировал Дешу.
Ну вот, ну это шедевр, да.
Вот.
Там вот такая там.
Тонкая такая.
Вот.
Так вот.
То есть получается, сколько не прибавляй, а FHTV будет больше либо равна, чем минимум между ними.
Ну отсюда автоматически следует, что...
То есть как бы...
Ну вот.
То есть вполне вероятно, что FHTV больше либо равно, чем FHSU.
Вполне вероятно.
Но, тем не менее, FHTV больше либо равно, чем FH.
Вот.
Так что вот такой вот очень красивый чип получился.
А в начальном алгоритме мы...
Мы сначала взяли одна вершина.
Ага.
И мы каждый раз брали рандомную вершину.
И в ней рандомные две вершины.
Или или.
Да.
То есть отдельные песни, на самом деле, нельзя ли их брать чуть-чуть менее рандомно.
Какими-нибудь там методами Шторм Варнера.
Там шо...
Методами Шторм Варнера.
Да, Варнера вспоминать можно.
Варнер это он.
Вот.
Но слета, честно говоря, что-то непонятно.
Секунду.
Это прям то, что можно откинуться на...
На этот.
Да.
Да, к сожалению, мета вершины это важная часть.
Очень хочется делать Шторм Варнера, но...
Ой.
Вот.
Но, тем не менее, вот за N наhi-motsu.
То есть, получается, что можно не зимать.
То есть в данном случае, да.
Ну, то есть сжать их, конечно, надо.
Но, тем не менее, вот за N наhi-motsu.
То есть, получается, что можно не зимать.
Ну, то есть, сжать их, конечно, надо, а то мало ли, но если уже за что зацепилось, за то зацепилось, само по себе заморачиваться не надо.
То есть, заметьте, мы даже не обязаны поддерживать для каждого ребра, а между какими двумя вершинами этими разрезами.
То есть, обратите внимание, даже не обязаны это поддерживать, мы просто знаем, что они существуют, и этого для нас достаточно.
Так что, вот такая вот красота.
Вот.
Так, ну что, есть ли тут какие-то вопросы?
Почему из того, что мы можем дать любого ребра, внимание, разрезы не поменяться, это то, что у нас, так вот, работает больше.
Ты можешь подогнать такое, что оно обгонит это.
Добавь FATV.
Нет, в смысле, добавь это FATV.
Да.
Тогда у тебя, ну...
Да, у тебя будет не нравится FATV, хотя бы минимум от FATV плюс что-то, FATV, значит, FATV, хотя бы F2V.
Так что, вот.
Значит, кто-то тебя где-то обманули, а?
По сути, как бы мы говорим, что...
Почему это что?
А если мы так будем делать?
Что?
Если мы не докажем тюрему, она станет сверна, в плане.
Ну да. То есть, так, от того, что мы ее докажем, она не перестанет быть вверх.
Ну да, тут, конечно, да.
Нет, ну действительно.
Да, есть, конечно, там бывает пара тонких моментов.
Не знаю, то лично меня, на самом деле, тоже возникает ощущение, что здесь где-то обман.
То есть обман возникает, как бы, да, что мы всю тюрему доказываем, что мы что-то одно, а вот работает ли она одновременно для всех.
Вот-вот-вот.
На самом деле, подглядки такие.
Ну вроде как все нормально.
Сейчас мы тюрему доказывали, мы вообще не смотрели на то, куда попали все остальные вершины.
То есть мы только вот сюда внимательно смотрели.
А перед этим мы действительно аккуратно...
То есть аккуратно действительно видно было, что мы можем сначала сжать вот это, потом сжать вот это, потом сжать вот это и так далее,
потому что везде мы аккуратно знаем, что минимальный разрез от этого сжатия не меняется.
Причем никакие из этих разрезов не меняются, поэтому можно сжать.
Поэтому вроде вот...
Поэтому вроде там, да.
Как бы уже в 1961 году никто никому не нагнал.
