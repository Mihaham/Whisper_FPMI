Мы продолжаем говорить про кучи. Сейчас поговорим про биномиальную кучу, которая
умеет чуть больше, чем бинарная. Но сначала одна интересная задачка, которую можно решать и даже
в бинарной куче. Значит, задача такая. По факту, в дополнение ко всем четырем стандартным запросам
кучи insert, get-min, extract-min и что-то еще дикрестки, можно добавить запрос erase. Erase x. Запрос
очень простой. Удалить x из кучи. Но давайте мы наложим обязательства, что этот x обязательно
в куче присутствует. x был в куче. То есть мы не будем просить от структуры удалить те элементы,
которые в нем, которые в ней отсутствуют. Давайте такую договоренность сделаем. Ну, вроде логично.
Значит, тут есть два случая. По указателю, по значению. Первый довольно простой.
Значит, представьте себе, что x задается не значением, как число там 120, а указателем на какую-то
вершину кучи. То есть вот есть у вас куча, которая на самом деле в виде массива представлена,
и вам говорят не x, а какое-то аи. Вам говорят, что вот в этой вершине аи лежит то самое число,
которое мне нужно удалить. Пожалуйста, удали его. Скажите, пожалуйста, как используя все те операции,
которые мы уже знаем, как можно число удалить? Вот так будет супер. Спасибо. Мы скажем,
что аи равно минус бесконечность, где минус бесконечность это такое число,
которое заведомо меньше всех элементов кучи. Затем мы поднимем ее с помощью сфтапа.
тогда оно обязательно всплывет в корень кучи. Если я положил сюда минус бесконечность и поднимаю
ее с помощью сфтапа, то, поскольку минус бесконечность самое маленькое число в куче,
оно обязательно поднимется в корень. Ну, а корень, я удалять умею, это экстракт мин.
экстракт-мин удаляет корень дерева, то есть элемент является минимальным, в нашем случае это
всегда корень, поэтому он эту минус бесконечность как раз и удалит. Вот, добились того, чего хотели.
Но это, повторю, все в случае только если у меня дается указатель. Мне дается не только число x,
но и кто-то мне тыкает в кучу и говорит, вот этот x вот тут вот лежит, вот его удали, пожалуйста.
Не просто какое-то там число 120, которое где-то в куче лежит, а вот оно, вот я прям показываю,
вот его индекс и вот его удали. Другое дело, когда меня просят именно по значению удалить.
Когда мне не сообщают индекс, где в куче это число лежит, а просто говорят, вот есть где-то у тебя x в
куче, удали его, пожалуйста. Где он конкретно лежит, мне не говорят. Здесь мы опять встречаемся с
проблемой, что мне нужно в каком-то смысле найти элемент по значению в нашей структуре данных. Мы
это видели, когда писали односвязанные списки. По значению искать в списке как-то не очень понятно.
Нужно пройти все элементы, в худшем случае проверить на равенстве x. То же самое в куче.
Если я вам говорю x, то проверить его наличие или найти, как-то его локализовать внутри кучи не очень
понятно как. Потому что все, что вы знаете, это что при спуске вниз у вас что увеличивается. Ну понятно,
можно до каких-то пор спускаться вниз, но непонятно даже, куда раздваиваться, идти влево или вправо,
потому что из слева больше элементов, из права больше элементов, где x непонятно. В худшем случае
опять-таки вам пришлось бы всю кучу обходить. Это бред, мы не хотим делать операции, которые работают
за линейное время, это слишком долго. Вместо этого давайте заведем дополнительную кучу удаленных
элементов. У меня будет две кучи. В одной куче a я буду хранить те элементы, которые туда добавляются,
добавленные элементы, а в куче d просто удаленные. И тогда для обработки запроса erase x я всего лишь
добавлю x в кучу d. Просто сделаю d insert x. Я вставлю число x в множество удаленных, в кучу удаленных.
Такое странное действие. Я в каком-то смысле пометил x удаленным, поместил его в кучу удаленных.
Что делать дальше? Ну смотрите, вообще говоря, мы можем в каком-то смысле продолжать спокойно
работать с кучей a. Если меня просят найти минимум в куче или что-нибудь в нее добавить или удалить
минимум, то обычно куча d на нее не влияет. Например, если x было не самым маленьким числом в куче,
то, например, get min и extract min в a будут работать точно так же, как если бы x не удалялся. А я
там какое-то число удалил, далеко не минимальное, тогда минимум остается в a таким же, как был.
То есть, вообще говоря, куча a не сильно от этого изменяется. Но, конечно, если, скажем, x это
минимальное число, то нужно что-то сделать. Нужно его из кучи, наверное, извлечь. Поэтому давайте
сделаем следующее. Каждый раз, когда приходит какой-то запрос изменения кучи a, get min или
extract min, давайте напишу при обработке запроса get min или extract min, мы запустим следующую процедуру.
А именно, мы будем удалять минимальные элементы из a и из d, пока они одинаковы. Пока a.get min
равно d.get min, я пишу на псевдокоде, на самом деле здесь равно-равно в большинстве языков,
но мне лень, я пишу просто равно. Пока у них равны минимумы, я их оба извлекаю. a.extract min
и d.extract min.
Смотрите, по крайней мере, если у них совпадают минимальные элементы, значит, я в какой-то момент
этот x добавил в a, потом говорю удали его из кучи, но я его добавляю в d, но на самом деле его
нужно удалить и оттуда и оттуда, потому что это тот элемент, который я добавил, но его нужно удалить.
И вот я вижу, ага, минимальный элемент в a и в d одинаковый, значит, я его когда-то добавил,
потом удалил. Ну, значит, давайте его отовсюду удалим, то есть мы увидели, что они совпадают,
удалили их из обеих куч. Тем самым, учли его удаление. В момент, когда у них минимумы не равны,
я понимаю, что в a лежит правильный минимум. То есть, в момент, когда они не равны, значит,
здесь минимум меньше, чем здесь, в куче a меньше, чем в куче d, значит, в a лежит минимум, который мы
еще не удаляли. Значит, его и надо вывести. Иллюстрируется следующей простой картинкой.
Давайте я нарисую числовую ось. Давайте засечками я поставлю элементы а, а крестиками обозначу те из
их, которые удалялись. Вот это удалил, вот это удалил, вот это удалил, этот не стал удалять,
этот не стал удалять, удалил вот этот. То есть в куче d лежат крестики, в куче а лежат засечки.
Ну тогда понятно, как извлечь минимум из кучи а. Мне нужно пока минимум в обеих кучах совпадают,
удалить, удалить, удалить. Вот это впервые минимум в а, отличный от минимума в d. Они уже не
совпадают, это значит, что этот минимум когда-то добавлен, но еще не удален. Значит, он на самом
деле настоящий минимум. Здесь в принципе не обязательно, главное, что если вы какой-то x несколько
раз добавляете, то он в куче несколько раз учтен. Например, если вы x дважды добавили в а и всего один
раз в d, то у вас будет две засечки и один крестик. Одна засечка уничтожится с одним крестиком,
останется одна засечка. Ничего страшного с тем, что дублируете. Именно севтап, я его в корень
поднимаю, потом удаляю. А как мы два раза удалим элемент, я не понял.
Так, извините, два вопроса, давайте вы сначала. Еще раз, я считаю, что мои запросы правильные,
что не бывает такого, что я удаляю несуществующие элементы. Иначе это все не работает. Справедливое
замечание, смотрите, если меня попросили удалить, например, даже вот так вот, если меня попросили
удалить вот этот элемент, которого в куче нет, тогда его в d добавлю и никогда его из d не удалю.
Буду всегда считать, что это минимум и вообще у меня все сломается. Так вот, я хочу, чтобы такого
не было. Я считаю, что все мои запросы корректные. И более формально, d всегда под множество a. Множество
удаленных всегда под множество добавленных. Теперь ваш вопрос. Нет, хорошо. Почему что?
Не будет ломать чего? Смотрите, сифтап я запускаю только в декрестки, правильно? Ну что меняется
от декрестки? Смотрите, в куче декрестки я не запускаю. Может быть такое, что меня просят запустить
декрестки от удаленного элемента. Но это опять бред. Это некорректный запрос. То есть я считаю,
что все мои запросы, я явно не формулирую, но я считаю, что запросы корректные. У меня не удаляются
недобавленные элементы. У меня не уменьшаются удаленные элементы. То есть я не делаю чего-то
незаконного. Тогда что значит декрестки? Декрестки может прийти либо сюда, к элементу, который не
удален, и на самом деле лежит в «а, ну окей, я вам переместить куда-то сюда». Ничего страшного. А декрестки
к элементу, который уже удален, я запрещаю просто. Но это неправильный запрос. Не может быть такого,
что вы сначала удалили, потом уменьшили. Это бред. Я такое запрещаю. Да.
Просто две кучи есть. В первую я добавляю все элементы, которые приходят на insert,
во вторую добавляю все, которые приходят на erase. То есть когда меня просят сделать erase x,
я делаю insert x в кучу d. У меня есть две кучи. В одну добавляю, во вторую тоже добавляю. Потом,
пока в них минимумы одинаковые, я оба минимума извлекаю. Ну как? Это две кучи. У них есть
процедура getmin. Пока они одинаковые, я их оба извлекаю. Вот картинка. Засечка это элементы
д. Это удаленные элементы. Первые несколько элементов a на самом деле удалены. Это как раз вот
пока засечка совпадает с крестиком, пока минимальный добавлент совпадает с минимальным
удаленным, я их стираю. Вот этот я вижу добавлен и удален. ОК, забыли про него,
потому что он удален. Этот добавлен и удалён, забыл. Этот забыл. А дальше
я вижу элемент, который добавлен, но не удалён. То есть не верно, что минимум в а, равен
д, значит был добавлен какой-то элемент, который сейчас минимален, но при этом не удален. Значит,
он и есть минимум. Справедливо, ну как есть. Ну что значит у отн? У меня все равно, если как бы в два
раза больше памяти. Ну типа, ну ладно. Ну не очень хорошо, но по-другому не получается, по крайней мере.
Когда еще придется ставить дополнительную проверку во всех функциях кучи a, что этого элемента нет в куче d, это же еще дополнительные действия.
Нет, нет, нет, я нигде не проверяю отсутствие элементов в куче d, я делаю ровно вот это. У меня в коде больше ничего нет.
Ну тогда вы же по-настоящему не удаляете. Конечно, я не говорю, что я удаляю, я делаю так, что я отвечаю на все запросы правильно.
Так, хорошо, смотрите, вот такую задачку мы поняли, как решать. Просто поддерживаем кучу удаленных.
Окей, теперь давайте перейдем к еще одной реализации кучи, называется биномиальная куча,
которая умеет делать все то же, что бинарная, но еще чуть больше. А именно, она умеет делать,
конечно, insert, get min, extract min, decrease key и новая процедура merge, процедура слияния двух куч.
Слияние двух куч. Что это значит? Представьте себе, что у вас были независимые какие-то две кучи,
одна-вторая. Вы хотите создать новую структуру данных, которая равна их объединению в каком-то смысле.
Вот все элементы, которые валялись здесь или здесь, вы хотите все слить в одну кучу, построить одну
новую большую кучу. Вот это merge. Есть элементы в одной, в другой вы хотите их все объединить в одну
большую. Это merge, склеивание двух куч. Давайте подумаем, например, про бинарную кучу. Почему тут
непонятно как делать? Потому что непонятно. Лучшее, что приходит на ум, это взять все элементы одной
кучи и итеративно по одному заинсертировать в другую. Берем первый элемент, добавляем, второй
добавляем через insert, третий, четвертый и так далее. Как-то долговато. Лучше вроде ничего не
придумывается. Если у вас есть две бинарные кучи как массивы, можно их состыковать, запустить
hipify, построить кучу, но это опять линия, опять не очень быстро. На бинарной куче это вроде не
получается. Давайте разберемся с биномиальной, в ней это быстренько получится сделать. Итак,
значит, определение. Давайте начнем с биномиального дерева ранга K. Биномиальное дерево ранга K.
Я буду обозначать его через tk. Значит, t0 это просто вершина. Одна вершина без детей. t1 это вершина
с одним сыном. t2 это следующая картинка. И так далее. В общем виде верно следующее,
что дерево следующего ранга K плюс 1 получается подвешиванием одного дерева ранга tk в качестве
сына к корню другого дерева ранга tk. Чтобы получить дерево K плюс 1 ранга, я беру два
дерева одинакового предыдущего ранга tk и подвешиваю одно из них к другому в качестве сына,
получаю тем самым дерево ранга K плюс 1. Ровно так у меня построены вот эти вот два первых дерева.
Как получить t1? Я беру t0 и t0 соединяю их ребром. Как получить t2? Я беру t1 и t1 соединяю их ребром,
получается t2. В общем случае конструкция такая. Беру два дерева предыдущего ранга, склеиваю
ребром. Значит также в вершинах дерева расположены числа, давайте напишу расположены элементы,
и они должны удовлетворять требованию кучи. То есть как обычно, что значение в вершине меньше
либо равно, чем все, что находится его по дереву. Они должны удовлетворять требованию кучи.
Давайте нарисую какой-нибудь пример t3. Так, ну я должен справиться. Так, вот оно. Нет сейчас,
бред. Кажется это корректное t3, потому что вот t2 и вот еще t2 соединил ребром. В вершинах
расположены какие-то числа. Такие, что числа ниже больше, чем число в вершине. Тогда как
обычно у меня минимум будет в корне. Например, давайте скажем, что здесь какое-нибудь число 3.
Здесь будут какие-нибудь 4, 8 и 20. Здесь пусть будет 10, здесь там 25 и 23. Например так. Это будет
корректное биномальное дерево ранга 3. Структура у него жестко фиксирована, то есть какие вершины
являются новьями кого, строго софиксировано по вот этому определению, что я подвешиваю дерево
предыдущего ранга к себе же. Ну а числа какие-то, главное чтобы опять вершина, число в вершине
меньше, чем все, что в поддерега. Тройка меньше, чем все вот эти вот. 8 меньше, чем 10. 20 меньше, чем 25-23.
Дурак, потому что наверное. А, да, извините. Давайте вот так вот сделаю быстренько. Да,
спасибо. Склеились у меня. Там две вершины, там разные числа какие-то. Спасибо.
Вот это биномиальное дерево. Одно дерево. А куча. Куча. Это набор биномиальных деревьев по парам
различных рангов. Биномиальная куча. Это набор биномиальных деревьев по парам различных рангов.
То есть я запрещаю иметь себе два дерева одинакового ранга. Нельзя иметь Т2 и Т2 одновременно. Они
обязательно все различные. Например, можно иметь Т0, Т3, Т4. Это хорошо. А иметь Т1, Т2. Т2 нехорошо,
потому что есть два дерева одного ранга. Я запрещаю себе иметь деревья одинакового ранга.
Вот. И это будет биномиальная куча. Дальше. Как я буду хранить у себя в памяти? Ну,
смотрите. Поскольку куча это набор деревьев, я давайте как-нибудь буду эти деревья хранить
сами по себе. А их корни сложу, ну, например, в список, если нужно двухсвязанных. Так что корень
первого дерева ссылается на корень второго, корень второго на корень третьего, корень третьего
на корень четвертого, а корень четвертого уже никуда не ссылается, потому что куча кончилась. Итак,
я свяжу корни всех моих деревьев в список. Они будут ссылаться друг на друга. Если нужно,
список двунаправленный. Вроде бы это не нужно, но как бы мы понимаем, что одно от другого не
сильно отличается. Если надо, мы добавим обратные ребра. Так. Замечание. Смотрите.
Сколько вершин в дереве ранга k? Два степени k. В дереве tk ровно два вкаты вершин. Тривиальный
факт доказывает по индукции, если в t0 одна вершина, а tk плюс 1, то есть это из двух копий одинаковых по
структуре деревьев tk и tk, то значит число вершин с каждым шагом удваивается и становится в два раза
больше. В дереве k легко понять, что вершин ровно два степени k. Теперь, если у меня все деревья
попарно различных рангов, то сколько всего может быть деревьев, не больше, чем логарифм? Если всего
в куче n элементов, то деревьев не больше, чем логарифм. Почему деревьев не больше, чем логарифм?
Давайте рассмотрим самые маленькие деревья. Представьте, у нас есть t0, t1, t2, t3 и так далее. У них
размеры это степени двойки 1, 2, 4, 8 и так далее. Какое наибольшее количество различных степеней
двойки вы можете набрать, чтобы не превысить n? Ну, ясно? Логарифм. Как раз минимальная степень
двойки 1, 2, 4 и так далее вплоть до 2 в степени логарифм. Значит, деревьев мало. Вот этих вот корней,
вот этих деревьев, которые я связываю с собой, их мало, их всего логарифм. Это здорово. Более того,
можно заметить, что глубина всех этих деревьев тоже логарифмическая. Точнее, глубина катого
дерева это в точности k. Глубина tk равна k. Ну, также по индукции здесь глубина 0, здесь глубина,
то есть самый длинный путь вниз. Какое наибольшее время у нас занимало бы, скажем, сивдаун? Какая
самая длинная длина пути сверху вниз? Здесь одно ребро, тут два ребра. Ну, тут понятно,
1 плюс сколько ребер в k? То есть какой ранг, такая глубина? Окей, ну вот такая структура. Теперь
давайте поймем, как здесь все работает, как наши операции можно быстренько проводить.
Давайте начнем сразу с мерч. Представьте, что у меня есть две биномиальные кучи, представленные
вот в таком виде, что у меня есть список корней, которые друг на друга ссылаются. Каждый корень
— это корень своего биномиального дерева. Как их быстренько склеить? Ну, смотрите, идеальный
случай, если в этих двух кучах, в этих двух списках корней, все ранги попарно различны.
Скажем, в левом есть только t0, t3, t4, в правом есть только t1, t2. Тогда делать ничего не нужно,
это у вас будет корректная биномиальная куча. Вы просто все деревья сваливаете в один большой
список. Если дубликатов нет, если нет деревьев одинакового ранга в двух разных кучах, то даже
ничего делать не нужно. Теперь что делать, если дубликаты есть? Представьте, что в обеих кучах
было дерево ранга k. Тогда, понятно, вы не можете их оставить, вам нужно что-то сделать. Ну,
понятно, их можно слить в одно дерево большего ранга. Вы можете, имея два вот таких дерева, за
единицу построить вот такое. Вот просто этой картинкой. Есть одно корректное биномиальное
дерево, есть другое. Вам нужно подвесить одно к другому, чтобы получить дерево ранга k плюс 1.
Единственное, здесь важно, что к чему подвешивать. Вам нужно сравнить числа, расположенные в корнях
этих деревьев, ну и к тому, которое меньше подвесит другое, потому что иначе требования кучи
нарушатся. Ну, это простая проверка. Что к чему подвешивать, это просто. Надо просто сравнить два
числа. Но мораль такая, что если есть дубликаты, если есть деревья одинаковых рангов, то их можно
склеить и получить ранг k1 побольше. На этом основывается алгоритм. Давайте я скажу, что вот
эти вот деревья в списке, которые у меня лежат, они идут в порядке возрастания рангов. Например,
t0, t3, t4, t10. Здесь тоже самое t1, t2, t5, t17. Идут в порядке возрастания рангов. Тогда давайте
одновременно двумя указателями идти по этим двум кучам. Вот есть одна куча, вот есть другая.
И как-нибудь их сливать. Например, если мы видим, что здесь есть t0, а там нет t0, то я могу t0
спокойно перекопировать в ответ, потому что t0 точно ни с кем не склеится, у него нет дубликатов,
я t0 просто оставляю. Затем здесь вижу t3, а здесь t1. Значит, у t1 пары нет, я могу t1 спокойно оставить.
Давайте напишем какой-то пример. 1, 3. Значит, видим, у 0 и 1 пар нет, поэтому я их спокойно
оставляю в результате. У меня будет отдельно дерево t0, отдельно дерево t1. Потом я вижу,
ага, у меня есть две кучи одинакового размера, t3 и t3. Давайте их склеим. Получим дерево t4. Затем
видим опять, ага, у меня есть еще дерево t4. Давайте опять их склеим. Получим t5. Ну и так далее.
По факту все, что мы сделали, это сложили два числа в двоичной системе в столбик, начиная от
младших битов к старшим. То есть представьте, что вот это номера включенных битов в двоичной
системе числения. Я иду по двум числам слева направо, начиная от младших битов, идя к старшим.
Если я вижу два включенных бита в этой позиции, то я их складываю и переношу в следующий разряд,
из itv v1. Если я вижу, что v1 опять что-то стоит, то я, если надо, опять склеиваю. Это ровно
сложение двух чисел в столбик в зависимости от младших числений. Согласны? Если есть одинаковые,
то есть в катом разряде включены оба бита, я их склеиваю и получаю бит в следующем k1.
Ну и все. Получается, что таким линейным проходом по обоим спискам я могу их склеить,
могу слить деревья, если нужно. И все это работает опять-таки за логарифмическое время,
потому что длина обоих списков у меня логарифм. Значит, я прохожусь по одному
за логарифмическое время, по другому за логарифмическое время и, если надо,
что-то склеиваю. Получается, суммарный список размера логарифм, я его получил за логарифмическое время.
Если у них одинаковые ранги, то сливаем, да. То не сливаем, их не нужно сливать,
если у вас есть t0 и t1, то мы их просто так же перекопируем в ответ. Их не нужно сливать,
они и так уникальные, мы их просто оставляем в ответе как корни новой кучи.
Ну у нас у меня один указатель в первой куче, один во второй. Они оба двигаются монотонно
слева направо. Если видят одинаковые кучи, кучи одинакового ранга, то сливают и получают кучу
следующего ранга. Если они различные, то меньше из них копируют в ответ, и указатель сдвигается
вправо в той куче, откуда скопировался. Если здесь, смотрите, мы начинаем отсюда. У меня 0 и 1 не равны.
Значит, 0 ни с кем не парится, я его спокойно копирую в ответ, переношу указатель сюда. Затем смотрю,
кто из них меньше? Один меньше. У него нет пары, я его копирую в ответ, сдвигаю указатель. У двое
пары нет, я его копирую в ответ, сдвигаю указатель. Опа, три-три. И теперь мы их склеиваем,
получаем т4. И оба указателя двигаем сюда. То есть у меня в памяти хранится т4, и вот еще
четверка, если надо, опять их склеиваю. Получаем уже пятерку, она опять в свою очередь склеивается
И в итоге у нас будет 0, 1, 2, 6. Да, верно, верно, верно.
Спасибо. То есть у меня правильно понимать, если у меня были две кучи, в одной все возможные двери
от одного руками судим, а в другой все возможные от одного руками, то в конце получится куча с одним
деревом как 1. Да, вы сейчас сказали, как складываются числа в двоичной системе
счастливения 1, 1, 1, 1, и 1, 1, еще одна единичка. Ну вот ровно так они складываются, что там будет 0.
Ну конечно, да, потому что здесь ровно это и происходит. Если вот это вот считать номером бита в
двоичной системе счастливения, то мы ровно это и делаем. Если видим два включенных бита в двух
числах, то они складываются и переносятся в следующий разряд. Ровно это мы и делаем. tk t
plus tk равно tk плюс 1. В следующий разряд переходим.
Да, ну смотрите, на самом деле можно хранить просто это все в ответе, то есть вот у меня есть две кучи.
Я храню еще кучу ответа, список ответов. Я туда свалил 0, 1, потом увидел 3, 3, склеил, получил t4,
положил в ответ. Дальше вижу, ага, там есть четверка. Если в ответе есть четверка, то я склеиваю и
переношу ответ в t5. На последний бит, на старший бит. Еще раз? Ну да, не понял вопрос. Мы идем слева
направо от меньших ранок к большим, это правда. Потому что мы проводим одно ребро.
Массивы? Я понял, я это не сказал, но на самом деле, конечно, такую штуку в массиве мы хранить не
можем. У меня представление в виде массива есть только для бинарной кучи. Когда вот там есть хорошая
картинка, что элементы a1, a2 и так далее, а n, очень легко представить в виде бинарной кучи. Когда у вас
дерево вот такое, вы же это не в массиве храните, вы храните явно какую-то структуру вершина, какой-то
черный ящик вершина, которая в свою очередь ссылается на каких-то детей, которые у нее есть. То
есть это уже не массив, а именно вот отдельная сущность, вершина, которая имеет несколько детей.
Это имеет несколько детей, это несколько детей и так далее. Но добавить очередного сына справа
можно очень легко, можно просто к этому списку добавить еще одного сына справа. Но это уже не
массив будет. Нет, не придется, если мы правильно будем делать подвешивание, то у меня требования
кучи нигде не нарушатся. Если у меня есть две кучи с числом x и y в корне и x меньше y, то требования
нигде не нарушатся. Я по другому подвешу, значит x к y подвешу. Так, можно дальше? Прекрасно. Дальше,
значит, это я про мерчу все сказал. Теперь давайте все остальные операции быстренько обсудим,
как реализовывать. Значит, что делать с инсертом? Очень просто. Давайте мы создадим отдельную кучу,
добавим в ней дерево t0 и скажем, что единственная вершина в ней это x. И запустим мерч вот этого
дерева с нашей исходной кучей. Тогда мы победим. Мы завели тривиальную кучу, она, конечно, корректная,
это биномиальная куча, потому что состоит из одного дерева ранга t0. И после мерча я как раз
этот x добавлю в нашу исходную кучу. Работает за логарифом. Да? Декрестки. Ну, здесь вообще думать
не нужно. Если мне по указателю говорят уменьшаемый элемент, то есть меня тыкают в какую-то вершину
моего дерева и говорят уменьшу на 3. Я такой, хорошо, уменьшаю на 3, а дальше севтап. Благо севтап
у меня работает. У меня сохраняется моя процедура севтап, которая просто берет и исправляет все
ошибки с родителем, пока они есть. Пока это число меньше родителя, я их свопаю и поднимаюсь наверх
рекурсивно, пока все эти ошибки не исправлю. Работает опять-таки за логарифом, потому что
глубина дерева логарифмическая. Куда бы мне изначально не тыкнули в моем дереве, глубина дерева
ранга k максимум k, поскольку k всегда не больше чем логарифм, потому что нельзя иметь дерево ранга
больше чем логарифм. Значит глубина логарифмическая, поэтому севтап работает за логарифм. Так, что дальше?
Ну get mean. Ничего не надо понимать. Смотрите, мы просто запускаем мерч. Мы уже доказали,
что мерч работает за логарифм. Не надо это еще раз передоказывать. Как-то он там работает
за логарифм. Вот мы это используем, получаем сразу логарифмическое время. Так, get mean. Ну смотрите,
тривиальная оценка от логарифма, потому что можно пройти по всем деревьям и найти минимальное
значение из корней. Деревья в логарифм, в них в каждом дереве достаточно проверить только корень,
потому что корень это минимум в своем дереве. Ну и поскольку все логарифм, то можно за логарифм
это все сделать, просто пройдя по всем корням. Вот, это за логарифм. На самом деле, если постараться,
эту штуку можно было бы написать и за единицу, но тут пришлось бы несколько повозиться. Чтобы
написать get mean за единицу, я могу всегда поддерживать указатель на минимальный корень. Я понимаю,
что минимум всегда это один из корней. Вот у меня есть много деревьев. Минимум точно в одном из
корней, потому что корень это минимум в своем дереве. Давайте просто поддерживать указатель на
минимум и аккуратно его поддерживать, когда происходят всякие разные запросы изменения.
Вот когда происходит мерч, как пересчитать указатель на минимум? У вас была одна куча,
вы знали где минимум, другая вы знали где минимум, вы ее полностью перестраиваете,
проходите по всем корням, как-то их сливаете и получаете новый список корней. Понятно, где-то
минимум. Вы все эти корни так прошли, вы знаете, какой из них минимальный. Мы знаем указатель на
минимум. Что происходит в дикриске, как поддерживать указатель на минимум? У вас число поднимается,
если оно дошло до корня, то надо посмотреть, а не стал ли этот корень новым минимумом. Если стал,
то нужно указатель на него переправить. В общем, это все несложно. Давайте попишу,
если хранить указатель на минимальный корень. Вот сейчас к этому перейдем. Да,
спасибо. Мне остался только экстракт-мин. Надо сначала понять, как он работает, а потом,
как мы этот указатель поддерживаем. Как работает экстракт-мин? Смотрите, есть у меня моя куча из
нескольких разных деревьев. Я знаю, кто из них минимальный. У меня поддерживается указатель на
минимум из всех этих корней. Вот скажем вот это. Что я хочу в идеале сделать, что я на самом деле
буду делать? Я говорю, окей, это какая-то вершина. У нее есть несколько сыновей. Давайте мы эту вершину
удалим, а все вот эти вот деревья сложим в отдельную биномиальную кучу. Скажем, что это новая
биномиальная куча h, штрих какой-нибудь, и смержем ее со всем оставшимся. Еще раз, как работает
экстракт-мин? Мы знаем, какой корень был минимальным, что вот это число минимальное. Я его удаляю,
но мне же нужно сохранить всех его детей, мне нужно сохранить всех потомков. Я говорю, хорошо,
давайте все вот эти деревья вырежем, сложим в новую кучу h, штрих и склеим все, что осталось,
то есть вот это, вот это и вот это, с кучей h, штрих. Благо процедура мерч у меня есть, мы умеем
объединять две биномиальные кучи. Но здесь нужно сказать немножко аккуратнее, почему я имею право
всех вот этих вот детей минимума выносить в отдельную кучу h, штрих. Мне нужно сказать, что это
вот будет корректной биномиальной кучей, потому что я имею право сложить в h, штрих только биномиальную
кучу. h, штрих это биномиальная куча должна быть. Значит, в частности, все вот эти вот деревья,
которые являются сыновьями минимума, они должны быть все биномиальными деревьями, причем попарно
различных рангов. Давайте проверим, что это выполняется. Я утверждаю, что картинка всегда
имеет такой вид. Если я рассматриваю дерево k-того ранга, то оно всегда имеет следующую структуру,
это корень, а дальше к нему подвешено дерево ранга 0, дерево ранга 1, дерево ранга 2 и так далее
вплоть до ранга k-1. То есть, дети, вершины, pardon, дети, корня tk, это все меньшее деревье, t0 и так
далее, tk-1. Если я это докажу, то такой подход будет корректным, потому что все эти поддеревья,
это корректные биномиальные деревья, попарно различных рангов, значит, я их могу свалить в h,
штрих, а потом все замерзнуть. Не будет проблем с тем, что у меня h, штрих это не куча, потому что это
куча. Но почему это верно? Давайте опять по индукции докажем. k равно 0 тривиально, потому что у
k равно 0 нет детей, собственно, ровно это и нужно показать, потому что k-1 это будет минус 1. Переход.
Пусть для tk это верно. Как доказать для tk плюс 1? Я знаю, как получается tk плюс 1. Что такое tk плюс
1? Это tk, к которому еще справа подвешено tk. Вроде понятно тогда, если вот это вот, это вот,
это вот, то как раз у меня получилось, что к корню подвешено сначала t0, t1, t2 и так далее tk-1,
а еще справа добавлен tk. Переход индукции завершен. Итак, значит, еще раз. Как реализую
экстракт мин? Нахожу минимум, смотрю на всех детей, понимаю, что это попарно различных рангов
биномиальные деревья, выношу их в отдельную кучу и потом сливаю все с помощью мерч. Значит,
это тоже работает за логарифмическое время от Луган. Ну и, как вы правильно заметили,
поддерживать указатель на минимум, на минимальный корень после вот этого всего несложно. Но если
я в мерч что-то делаю, то раз я его вызываю, то минимальный корень тоже автоматически посчитается
правильно. Да, в отдельную новую кучу аш-стрих, а потом склеиваю то, что осталось, и аш-стрих.
С помощью мерч. Ну конечно, да, вот эти вот все, кроме вот этого вот, я вот эти вот все
склеиваю с аш-стрих. По факту я ровно минимум только и высек, только его и удалил.
А экстракт-мин для биномиальной кучи, мы берем какой-то минимальный корень среди всех корней?
Конечно, это минимум, минимум. Минимальное значение среди всех. Экстракт-мин, он что такое? Это
найти минимальный элемент в куче и удалить его. Только минимальный. Но, если я договариваюсь,
что у меня есть указатель на минимум, вот то, что я тут говорил, что я за единицу знаю указатель
на минимум. Если его всегда поддерживаю, то это не проблема, я знаю, где он. Вот этот минимум,
я у него вырезаю детей. Давайте. Я это упоминал, в дереве, сейчас, вот, глубина от дерева ТК равна
К. Но осталось сказать, что К не больше, чем логарифм, потому что в дереве ТК два вкаты вершин. У вас не
может быть ранг больше, чем логарифм, потому что в нем вершин слишком много, больше, чем Н.
Еще раз, почему что? Ребят, можно потише просто? Я не слышу вопросов даже. Да. Почему сфтап за
логарифм работает? Ну, смотрите, вот у вас есть какое-то длинное дерево. Ну, как длинное, вы знаете,
что углу на логарифм. Вас ткнули вот сюда. Что вам нужно сделать? Вам нужно, пока вы не поднялись в
корень, сравнивать вот этого чувака и родителя, если надо свопать их значение. Окей, потом вот
этого чувака и его родителя, если надо свопнуть значение. Но это в точности путь от вершины до корня.
Раз глубина логарифмическая, значит этот путь тоже максимум логарифмический. Потому что глубина
это просто самый длинный путь от корня вниз, а вы идете снизу вверх. Так, хорошо. Все, значит,
тогда я считаю, что мы с биномиальной кучей разобрались. Мы скорее всего вернемся к ней
где-нибудь на следующей лекции, когда будем говорить про кучу фибоначи. Это тоже куча,
основанная во многом на биномиальной, но с некоторыми еще модификациями. Пока чтобы к
этому перейти, мне нужен некоторый матаппарат, который я сейчас буду вводить. Это то, что я
называю амортизационный анализ. Амортизационный анализ. И то, что я когда-то уже упоминал.
Итак, представьте себе такую конструкцию. Вы хотите хранить некоторую структуру данных,
которая будет означать некоторые запросы. Но на разные запросы, или даже, точнее, на запросы одного
и того же типа, она может отвечать за разное время. Какие-то запросы одного и того же типа
обработают быстро, какие-то долго. Так вот, можно тогда в некотором смысле их усреднить. Можно
сказать, что есть некоторая функция, которая сверху оценивает суммарное время выполнения всех
запросов. Даже когда внутри типа запроса возникает вот такой дисбаланс, что какие-то быстро,
какие-то долго, вы можете их в каком-то смысле усреднить и сказать, что в среднем они работают
быстро. Вот ровно это я сейчас буду определять. Итак, пусть S это какая-то структура данных,
которая умеет обрабатывать ка типов запросов. Давайте я их занумеру, типы запросов это один,
два и так далее. Это вот, например, то, что у меня было в куче, это insert, extract mean, get mean,
decrease key. Четыре типа запросов, они какие-то, они что-то делают с нашей структурой.
Значит, тогда будем говорить, что функции a1, давайте я с круглыми скобочками их напишу,
a1, a2 и так далее, ak являются амортизационными или иначе учетными стоимостьями выполнения
всех запросов. Если, идейно смотрите следующее, если вы вот эти вот функции a1, a2, a3, ak воспринимаете
как настоящее время работы, то это дает вам оценку сверху на реальное время работы. То есть,
даже если какой-то итый запрос может выполняться не за время, а итое, а за какое-то другое, но вот
суммарно, если вы все эти ашки просуммируете, то получится хотя бы столько, сколько реально было
времени работы. Формально, если для любого n, для любой последовательности запросов
типов i1 и так далее, i n, то есть я говорю, что к структуре поступает n запросов, их типы это i1 и так
далее, i n, например, insert, decrease, extract и так далее, вот это типы, я не говорю какие у них
характеристики, там x, дельта и так далее, только типы, первый тип, второй, третий,
вот если такие типы поступают, то реальное время работы есть o от суммы всех этих ишек,
ну точнее от суммы a с этими индексами. Сумма пожи от 1 до n, а итое житое от n.
Наитый тип запроса, да. Ну и смысл ровно такой, который я придался этому дать. Смотрите,
вот есть какие-то функции, взятые из потолка, они на самом деле не имеют ничего общего с тем,
как на самом деле работают эти запросы, как они обрабатываются. Они обрабатываются,
бог пойми, за какое время, за какое-то. Я говорю, вот эти функции я тебе даю, из космоса взял,
вот они хорошие, они учетные время работы, если когда вы их складываете с аргументом n,
то есть вот в скобке подставляете n как число запросов, а индексы берете такие, какие были
типы запросов. Пришел insert, вы в сумму добавили a insert от n. Пришел decrease key, вы добавили a
decrease key от n. То есть каждый индекс это свой тип запроса. Вот если вы просуммировали эти ашки по
всем запросам, то у вас должно быть хотя бы реальное время работы. То есть на самом деле время
работы настоящее, это o от суммы этих ашек. То есть эти функции какие-то из космоса прилетели,
волшебные. Но если они внезапно удовлетворяют вот такому условию, что они сверху ограничивают
время работы настоящее, то это учетные стоимости. А с индексом i, с индексом g.
Давайте какой-то пример из рубрики уже пройденного. Давайте вспомним, как мы реализовали очередь на
двух стэках. Я говорю, что я завожу два стэка. Первый и второй. Insert я обрабатываю просто
добавлением элемента сюда. A pop или top я обрабатываю тем, что в случае пустого второго стэка я сначала
перекладываю все элементы из первого во второй. А дальше со вторым работаю просто доставая из
начала. Давайте скажем следующее. Понятное дело, что insert всегда работает за от единицы, потому что
insert это просто добавить элемент в первый стэк. Ничего никуда не перекладываю, просто insert это push
в первый стэк. А top или pop, каждый конкретный такой запрос, он может быть очень долгий,
время работы может быть долгим. Потому что, еще раз, если внезапно второй стэк пустой, а в первом
что-то лежит там x, y, z, t, то я сначала все эти элементы по одному вот так вот тихонечко скрупулезно
по одному перекладываю сюда. T, потом z, потом y, потом x. Но понимаешь, что это не от единицы. А время
работы пропорционально число элементов в первом стэке. Оно может быть большим. Но я утверждаю,
что если A здесь положить, то есть A с индексом top и A с индексом pop, назначить единицей, то это
будут учетные стоимости. То есть реальное время не единиц, видно, что здесь сколько элементов,
столько это и работает. Но учетно будет за единицу. Учетное время работы операции top и операции pop
будет единицей. Ну почему? Давайте докажем. Я на самом деле это уже доказывал. Потому что давайте
рассмотрим какую-то последовательность из N операций. Фиксируем N. Фиксируем последовательность
из N запросов. Инсерты, топы и попы. Пуши, да, извиняюсь, пуши вместо инсертов. Рассматриваю. Но я
доказываю, что все это суммарно работает за O от N. Потому что каждый конкретный элемент x, он может
максимум один раз пушнуться в первый стэк, потом перенестись во второй и потом из него извлечься.
Но с ним происходит там три или четыре действия, в зависимости от того, как вы считаете. Добавился сюда,
удалился, добавился, удалился. Значит, суммарно, если всего было N операций, давайте так напишу,
если было всего N операций, то всего добавлено не больше, чем N элементов. А дальше я говорю,
что каждый элемент участвует максимум в четырех действиях. Добавился сюда, удалился,
добавился сюда, удалился. Значит, суммарно произведено не больше, чем 4N действий.
4N – это реальное время работы. Понятное дело, что 4N – это O от суммы единичек по всем запросам,
где A равно единице. Ну всё. Попросы? Ну супер.
Вот я буду обозначать амортизационное время работы за o звёздочка. Вот это вот всё я буду обозначать
как o звёздочка от единицы. То есть реальное время работы, может быть, бог знает каким,
мне это не важно. Я говорю только, что учётно это работает как будто бы за единицу. В том смысле,
что, если я считаю, что работа за единицу, то суммарно, это даст правильную оценку на время
работы. А каждая конкретная, может быть, долга, но суммарно, как будто бы каждая за единицу.
Так, хорошо. Давайте рассмотрим метод, как можно выводить вот эти вот ашки, как можно получать
какое-то учетное время работы на разные операции. Это называется метод монеток,
ну или иначе метод бухгалтерского учета. Сливать можно. Во-первых, можно сливать,
чего не умеет бинарная куча. Во-вторых, на ее основе мы реализуем фибоначевую кучу,
которая быстрее работает, но во многом наследуется от биномиальной. То есть у нее дикриски работает
за единицу амортизировано. Но это мы в следующий раз еще посмотрим. Так, хорошо. Бухгалтерский
учет работает следующим образом. Представьте себе, что вы клиент банка, и кроме выполнения
операции над вашей структурой, вы можете делать какие-то операции в банке. Вы можете класть туда
деньги, класть туда монетки или забирать туда монетки. Смысл монет такой, если вы когда-то
понимаете, что операция слишком простая и у вас есть еще много времени перед тем, как придет
следующий запрос, вы можете в банк несколько монеток положить. Вы говорите, ага, мне пришла
простая операция, ну тогда я подсекономлю себе денег на будущее, положу в банк немножечко денег,
и дальше, если что, буду расплачиваться вот этими монетками, которые я положил себе на будущее. То
есть если простая операция, то вы кладете несколько монеток в банк. Если приходит сложная операция,
как вот здесь, вам нужно переложить кучу элементов во второй стэк. Вы говорите такое, окей, я может
быть сейчас поработаю долго, но у меня в банке есть много денег, давайте я буду из него занимать
деньги, и в каком-то смысле за эти деньги буду выполнять операции. То есть у меня в банке много
денег, я себе накопил какую-то сумму, я потихонечку оттуда достаю монеты, и как бы за эту стоимость
выполняю операции. Вот такая аналогия. Формально давайте скажем следующее. Пусть ТИ, это реальное
время выполнения этого запроса, время выполнения этого запроса, позволим себе кроме выполнения,
то есть кроме ответа на запросы, позволим также класть деньги в банк и снимать деньги из банка.
Значит пусть ДИ, это число монет, которые мы кладем в банк во время этого запроса,
а ВИ, это наоборот снимаем число монет,
которые мы снимаем из банка, снимаем со счета, снимаем со счета. Тогда А равное Т плюс Д минус
В является учетной стоимостью. То есть если А задать по такому правилу, то они удовлетворяют
определению амортизационной стоимости на самой левой доске. Значит что тут написано, смотрите,
учетное время складывается из реального времени работы, плюс то сколько монеток я себе даю на
будущее, в случае, если операция простая, я вот окей, мне пришла простая операция, Т маленькая,
я такой, хорошо, давай я несколько монеток себе отложу на будущее, тем самым здесь немножко
увеличу время работы А, вот это учетное время работы я себе увеличу, но ненамножко, так что,
не знаю, если здесь 5, то здесь тоже 5, например, пожелал себе еще 5 монеток на будущее. А дальше,
если приходит трудная операция, то я расплачиваюсь, я уменьшаю А за счет снятия денег со счета,
я вычитаю W, чем больше W, тем сильнее я уменьшаю свое учетное время работы. Ну и вот утверждение
простое, что если баланс в банке всегда не отрицательный, если баланс на счете всегда
не отрицательен, то действительно эти Ашки можно рассматривать как учетное время работы,
а И, да, это амортизационные стоимости. Это все в течение ИТ операции, индекс И, значит все
происходит в течение ИТ операции. Мне пришла операция, я сначала на нее ответил за время ТИ,
потом делаю что-то с банком, возможно снимаю, возможно кладу деньги. Достаточно, достаточно.
Но давайте так, мы все равно никогда не будем делать отрицательный баланс в банке, это странно,
нам это и не нужно. Доказательство очень простое, смотрите, давайте, у меня баланс всегда не
отрицателен и Ашки определены таким образом. Тогда давайте просуммируем все Ашки. Просуммируем
все учетное время работы вот ровно так, как здесь у меня написано. У меня там написано, что реальное
время работы это о от суммы Ашек. Давайте все Ашки просуммируем. Что здесь получится? Это сумма
реальных времен работы, плюс сколько я денег положил в банк суммарно, минус сколько я суммарно
снял из банка. Дальше это не отрицательно, потому что мой баланс не отрицательен. Я положил хотя бы
столько, сколько снял, а мой баланс не отрицательен, то есть сумма Дшек больше, чем сумма Двшек. Значит,
сумма Таитых не больше суммы Аитых. Что ей требовалось? Сумма реальных времен работы не
превосходит сумму учетных стоимости. Что ей требовалось по определению? Как правильно заметили,
мне на самом деле не нужно обязательно, чтобы всегда была не отрицательная сумма. Мне важно только,
чтобы в конце, чтобы суммарно за всю программу, за все время работы программы я положил больше
ровно, чем я снял. От того, что я потребовал, что всегда не отрицательно, ничего не сломается,
и я всегда на самом деле так и буду делать. Я никогда не буду занимать из банка. Там у меня
всегда будет не отрицательная сумма на счету. Давайте, например, вот здесь вот поймем,
как можно было бы монетками получить то же самое. Как с помощью метода бухучета понять,
что А равна единице является амортизованной стоимостью? Надо придерживаться ровно той
самой логики. Если поступает простая операция, то мы несколько монет кладем себе в банк. А если
сложная, то я выполняю все операции именно за счет того, что у меня есть много денег в банке. Я
снимаю деньги со счета, тем самым виртуально уменьшая время работы на запрос. Давайте сделаем
следующее. Когда нам поступает х, это простая операция. Пуш работает за чистую единицу.
Когда поступает запрос, я добавлю элемент х в стек, а также положу на него две монетки,
кажется. Давайте вместе с х я положу на него две монетки. Дальше, когда приходит топ или поп к
не пустому второму стеку, если тут есть какой-то элемент, тогда его удаляю просто за единицу. Если
эта операция проста, я просто удаляю и ничего не делаю. А если операция сложная, и мне нужно сначала
все элементы по одному из первого стека перешить во второй, то я это делаю за счет тех монет,
которые на этих элементах лежат. Здесь у меня на каждом элементе по две монетки. Я элемент достаю,
за счет той монеты, которая на нем лежит, я выполняю перенос, и тем самым у меня остается на нем
монета, и как будто бы я эту операцию сделал бесплатно. То есть я сделал одно действие и расплатился
за это одной монеткой. То есть у меня t равно единицы и w равно единицы. Они сократились, поэтому я как
будто бы это сделал за ноль. То есть я за одну монетку перенес х во второй стек. То же самое
с остальными. У меня на элементе лежат две монетки, я перекладываю в другой стек, расплачиваясь за
этой той монеткой, которая на нем лежит. Даже получается одной монетки хватало, то есть я просто
достаю элемент, снимаю с него монетку, которую как бы из банка. То есть я из банка снимаю монетку,
вывожу из банка монетку, перекладываю сюда, как будто бы за ноль. Ну и получается как раз,
что у меня время работы примерно равно числу снятых монеток на t равно w, число перекладывания
равно числу монеток, которые я снимаю, значит a равно нулю просто будет в этом случае. Вот, то есть
просто по формуле t плюс d это ноль, t равно w, поэтому a равно нулю в случае тяжелой операции. Ну да-да-да-да-да-да.
Ну окей, ну тогда нужно там две монетки как раз достали и добавили. Ну это все детали, конечно.
Так, понятно? Хорошо, давайте переходим тогда к следующему примеру получается. Это динамический
массив. Динамический массив, он же вектор. Задача, вам нужно поддерживать массив переменной длины,
который умеет добавлять элементы в конец и удалять элементы из конца. В формале вам нужно
поддерживать множество элементов, которые как-то проиндексированы и уметь быстро отвечать на
следующие типы запросов. Первый запрос это квадратные скобки, то есть по индексу и сообщить аит,
сообщить аит, по индексу вывести элемент. Второе это pushback x, добавить x в конец массива,
добавить x в конец массива. Ну и последний запрос, наоборот popback удалить последний
элемент из массива, удалить последний элемент из массива. Вот такая задача. Ну мы будем на
самом деле это делать на базе массива, но массива, который будет частично заполнен. У нас не будет
такого, что все элементы лежат в массиве и все, то есть вот здесь вот край массива, здесь последний
элемент и вправо от него ничего нет. У нас, наоборот, у нас будет выделено для нас некоторая удобная
память, подряд идущий набор ячеек. Первые несколько ячеек будут содержать элементы массива,
а дальше будет свободная доступная для меня память. Вот давайте скажем, что элементов занятых у меня
будет s, от слова size, размер массива будет s, а всего я себе выделил c ячеек памяти, всего c.
Тогда, ну понятно, что если это все дело на базе массива, то квадратные скобки тривиально работают,
нужно просто вывести a и t. Раз это в массиве, то это работает за единицу. Можно сразу указать,
что это работает за чистая от единицы, не амортизированная, не учетная, а именно чистая
от единицы. Потому что, ну мы работаем в такой в рам модели, то есть random access, мы по индексу
и можем сказать, что там лежит. Вот, что делать с push и pop back? Ну в простом случае, например,
когда у меня приходит push и s меньше, чем c, я могу просто вот в эту свободную ячейку добавить x,
ну и соответственно сдвинуть s на единичку, сказать, что s переходит в s плюс 1. В случае простого pop,
я могу наоборот, вот был у меня последний элемент, я знаю, где он лежит, давайте я скажу,
что я наоборот s на единичку уменьшу, а про этот элемент забуду, скажу, что как будто там ничего нет,
и наоборот s поменяю на s минус 1. Это будет pop. Я по факту просто сдвигаю указатель с последнего
элемента на предпоследний, уменьшая размер массива на 1. То есть я его оставляю лежать здесь,
считаю, что здесь доступная для меня память, но говорю, типа там ничего нет, туда не ходи,
массив заканчивается вот здесь. Это простые случаи. Теперь, что происходит в случае сложного push
back и сложного pop back? Значит, что такое сложный push back? В идеале надо, но мы до этого подойдем,
да. Ну сейчас, если массив не перестраивается, то есть если у меня c остается таким же,
то в принципе эту память пока я ее, скажем так, пока я работаю с этим массивом, здесь можно ничего
не чистить, потому что я ее забрал у системы, я сказал, это моя память, я делаю здесь все,
что хочу. Если мы хотим этот массив удалить, куда-то перекопировать или что-то с ним сделать,
тогда, да, всю эту память надо будет очистить. До этого мы еще дойдем. Итак, что такое тяжелый push
back? Что такое тяжелый push back? Ну, это просто случай s равно c, когда у меня заполнена вся выделенная
память. Я не могу добавить вправо в конец еще один элемент, но нет такой возможности. Ну,
решение нехитрое. Давайте мы попросим у системы массив вдвое больше длины, 2c. Перекопируем туда
все мои с-элементы, которые были изначально, и добавим с плюс первый в конец. Значит, решение
очень простое. Значит, запросим у системы, ну или иными словами, выделим массив длины 2c,
массив длины 2c. То есть у меня был массив длины c полностью заполненный. Я выделяю массив вдвое
больше длины. Сначала копирую все свои старые данные. Значит, копируем старые данные. Копируем
старые данные. Ну и в конец сюда после всего, что добавил, добавляю x. Можно.
Нет, нет, нет, конечно, никак не 2 в степени, потому что, смотрите, если, например, приходит n раз pushback,
представьте, у вас было изначально массив длины 1, вы потом сделали 2. Хорошо, нет, конечно, не 2 в
степени, линейно, да. Ну, не очень хорошо, но по-другому как не особо получается. Но, раз мы про
память заговорили, вот эту память давайте очистим и вернем в системе. Да, то есть мы не будем ее за
собой сохранять, мы ее больше не будем использовать, и чтобы у нас не текла память, чтобы у нас не
оставались выделенные участки памяти, которые мы не используем, давайте его удалим и вернем в
системе. Ну там зависит от языка, c++ это типа delete. Вот эту память вернем в системе. В том смысле,
что мы просто скажем, с этой памятью я больше не работаю, ее, пожалуйста, не учитывая в мой memory
limit. Вот, я сейчас ограничен вот здесь. Этим я не пользуюсь, и, пожалуйста, забери его, я больше
вообще туда смотреть не буду. Ну, понятно, что это работает за что-то типа ООЦ. На самом деле,
реальное время работы это ООЦ. Ну, потому что я тут копирую, создаю массивы и так далее, это ООЦ.
Но, если бы у нас, например, были только pushback, это происходит очень редко. Давайте вернемся к
примеру. Пусть изначально массив длины 1 и поступают только pushback, pushback 1, 2, 3, 4 и так далее.
Тогда сначала я массив длины 1 превращу в массив длины 2. Потом, когда он полностью заполнится,
в массив длины 4, потом длины 8, ну и так далее. По степеням 2 я пойду. Ну и тогда это происходит
все реже и реже. Если у меня массив длины 8, то мне нужно сначала 4 новых pushback получить,
целиком его заполнить, и только после этого я выделяю новый массив. Это происходит все реже и реже,
экспоненциально редко становится. Если у меня только pushback, тогда мне нужно по степеням 2 идти,
и это происходит все реже и реже. Поэтому, кажется, что это не очень страшно. На самом деле так и есть,
учетно будет все за единицу. Смотрите, мы говорим следующее. У меня был массив длины 8,
я создал массив длины 16, а этот очистил, вернул в системе. Тогда у меня здесь задействовано 9 из
16, но это все еще моя память, я ее контролирую. Если мне приходят еще pushback, то я 10, 11, 12,
все сюда буду класть. Она не то, что утекла. Утекла, это когда вы потеряли на нее указатель,
а вы знаете указатель, у вас все элементы вот здесь лежат, вы знаете, сколько их, где они
начинаются, где заканчиваются, вы все это контролируете, все в вашей власти. Если их не приходит,
ну не очень хорошо, но ничего страшного, вы всего лишь в два раза больше памяти используете, чем
можно было бы, 16 вместо 9. Но потом, когда ваш алгоритм закончится, вы эту память очистите,
тем самым у вас все указатели вывернули в системе, у вас ничего не утекло, просто не максимально
эффективно. Ну что поделаешь, константа 2 не очень страшна. Так, хорошо, на самом деле на это можно
было бы и закончить, потому что, если я не ошибаюсь, в C++, по крайней мере, процедура pop back
реализована просто уменьшением s на единичку, то есть буквально pop back это s минус равно 1.
Ну ровно это мы и хотим, мы хотим, чтобы последний элемент забылся, мы сдвигаем указатель с последнего
на предпоследний, уменьшаем размер на единицу. Это в принципе не очень плохо, это может быть
неоптимально только в случае, когда, например, представьте, у вас пришло много push backs, вы сделали
большой массив, потом много pop backs, вы удаляете, удаляете, удаляете, получаете маленький массив. То есть,
если у вас много pop backs, тогда у вас массив может быть такой, у вас заполнена очень маленькая память,
s маленькая, а c большое. Ну как-то странно, не очень хорошо. Вы у системы забрали вот столько ячеек,
чтобы хранить вот столько. Ну что-то вы странное делаете. Да, я вот, написано же буквально, запросим новый
массив, то есть создадим новый массив, перекопируем и сотрем старый. Ну потому что я не могу вот эту
