И вот сегодня я начну с того, что определю формулы
первого порядка, которые описывают этот формализм.
Ну, более торжественно сказать формулы логики первого порядка.
Значит, определение, похоже на определение булевых формул,
нам формулы будут словами, некоторыми специальными словами в алфавите.
Ну, какой алфавит? Давайте, я его как-нибудь вот так обозначу,
это от слов первого порядка. Пусть будет а, ладно.
Значит, алфавит устроен сложно. Я даже не буду писать обычное обозначение множества,
а просто буду перечислять, что есть. Есть, во-первых, символы переменных.
Я вот тут прямо напишу символы, чтобы их не повторять. Есть предикатные символы.
K называется арностью предикатного символа. Есть функциональные символы.
Это все символы, одиночные символы алфавита. То же самое. Есть, наконец,
константы. И есть специальные знаки. Какие? Ну, во-первых, нам нужны знаки булевых связок.
Давайте я перечислю те, которые, по-моему, были для булевых форм. Не очень принципиально.
Ну, пусть будет стандартный набор. Символы кланторов, открывающие закрывающие скобки и
запятая. Вот из-за того, что запятая, записывать все это дело обычным образом, когда мы перечисляем
элементы множества, не очень удобно. То есть, видите, алфавит довольно сложно. Есть некоторое
конечное количество специальных знаков и есть, ну так, сколько нужно. Счетное количество символов.
Причем про символы мы приписали, какого они сорта. Константа, функциональный символ, предикатный,
переменная и про функциональные и предикатные символы еще сказано, какого они арности. И символов
каждой арности и функциональных и предикатных сколько угодно. Ну, счетное количество, чтобы
не испытывать каких-то проблем. Вот это алфавит. Теперь, исходя из этого алфавита, нужно определить
формулы. Но определение, опять-таки, более сложное, чем в случае булевых формул, потому что вначале
нужно определить то, что называется термой. Значит, определение рекурсивное. Все определения будут
похожи на определение булевых формул. Я вот так подробно про булевые формулы рассказывал,
потому что они попроще. А определения все устроены точно так же. Значит, термом является переменная
или константа. Это терм длины 1. А также термом является выражение вот такого вида,
где f это функциональный символ, а t и t термы. Многоточие здесь, как обычно, я ставлю, чтобы
показать, что там просто через запятую перечисляются термы. Тут их должно быть к штук. То есть,
типичный терм выглядит так. Вначале имя функционального символа, затем открывающая скобка и
внутри пары открывающей и закрывающей скобка просто перечислены через запятую еще какие-то
термы. Могут быть перечислены переменные, а могут быть и более сложные термы. И для чего это нужно?
Ну, я напомню, в прошлый раз про это заходила речь. В математике постоянно используются какие-нибудь
вот такие выражения. Не просто переменные, а какие-то выражения, составленные из функции
переменных. Вот чтобы это задать, мы заводим термы. Если функциональных символов, скажем,
убрать функциональные символы, то термы останутся только переменные и константы. Но мы их обычно не
убираем. Теперь, когда определены термы, можно определить атомарную формулу. Это уже формулы. И
термы и формулы — это слова. Но они устроены по-разному. Атомарная формула имеет вид,
предикатный символ. И дальше в скобках перечисляются через запятую К термов.
Давайте здесь, чтобы не было путаницы с переменными, ножи заменю.
Элементарные формулы. Из элементарных. Ну, атомарные или элементарные. Я буду
постоянно оговариваться, потому что это синонимы. Атомарными они называются, потому что это атомы,
формулы из которых собираются более сложные. Внутри атомарной формулы формул уже нет.
Сейчас мы это обсудим чуть подробнее. Давайте я закончу определение. Ну и, наконец, формула.
Определение рекурсивное, как и в случае термы, это устроено так. Атомарная формула.
Или связка, примененная, ну, одна из связок, примененная к формулам.
У нас там связки еще есть. Ну, отрицание есть. Есть эквивалентность, пусть будет. Да, правильно.
То есть мы можем булевые связки применять к формулам так же, как к булевым формулам. То есть
вот тут должны стоять формулы, но теперь уже не булевые, а вот формулы первого порядка,
в частности, атомарные могут стоять. И, наконец, есть формулы, которые, как говорят,
получаются навешиванием квантора. То есть слова, которые устроены так, что...
Давайте я возьму скобки. По-моему, это совсем не обязательно, но не хочется возиться с лишними
техническими доказательствами. Скобки, я напомню, они задают порядок действия. Сейчас мы это обсудим.
Подробнее. Ну, вот это вот уже определение. То есть когда мы смотрим на слово в алфавите
символов первого порядка, мы должны понять, формула оно или нет, применяя это определение
рекурсивно. То есть у нас одно из этих условий должно выполняться. Мы проверяем возможность
каждого из них. Чтобы проверить, мы должны проверить части, которые у нас получились
под формулы, что они корректные под формулы и так далее, пока не доходим до атомарной формулы,
где нам уже нужно проверить, что перечислены именно термы. Для этого мы используем определение терм.
Ну и опять-таки, как и в случае булевых формул, с формулой можно сопоставить дерево. Плоское дерево,
размеченное, но оно имеет уже более сложную структуру. Это предикатный символ. Не предыдущий,
а предикатный. Я прошу прощения, что сокращение написал. Хотелось не занимать все доски. Дерево
разбора. Как оно устроено? В вершине дерева написано что-то. Смотрите, что у нас может быть
в вершине дерева. Либо связка, либо квантор, либо предикатный символ. И тогда тут будут уже термы.
Тут уже дерево может этвиться больше, чем на два. И вот термы, они заканчиваются переменными или
константами. Получается так, у нас дерево разбора. Построить это дерево разбора по формуле можно точно
тем же алгоритмом, который мы использовали в булевом случае. Смотрим на скобки и восстанавливаем
по скобкам структуру дерева. А какие ставить, приписывать символы вершинам дерева? Ну вот те,
которые у нас возникают при разборе формулы. То есть в сущности все то же самое, только более
сложные правила. И у нас возникает большее ветвление, но тут никакой сложности нет, потому что
запятая достаточно однозначно синтоксически выделяет вот те блоки, которые должны быть термами,
которым мы должны применить уже построение дерева терма, начинающиеся с какого-то имени,
ну и заканчиваешься переменными. В результате у дерева разбора получается сложная структура.
Вот смотрите, есть часть в дереве разбора, в которой являются формулы, а есть часть вершины,
которые являются термами. Это не обязательно равномерные части. Вот тут у меня сразу очень
простая формула. Давайте я, чтобы можно было продемонстрировать какое-то разнообразие,
я наоборот напишу там импликацию. А здесь что-то такое, вот еще где-то глубже у нас стоит формула,
и вот потом только где-то вот здесь уже встречаются атомарные формулы. То есть если посмотреть только
на ту часть, которая отвечает формулам, это тоже будет дерево с тем же самым корнем, но листьями у
него будут атомарные формулы, то есть предикатные символы. Когда мы смотрим на это дерево, мы видим,
на это под деревом мы видим в листьях предикатные символы, а дальше под предикатными символами мы
должны поставить термы, какие нужны. Ну допустим t1 имеет r2. Да, значит я скорее имел в виду,
что здесь какое-то дерево, но два ребра может выходить, а может выходить три, если арность
этого терма 3, если у вас функциональный символ. Да, здесь можно даже написать не термы, я прошу
прощения, это я хотел говорить о термах. Тут конечно функциональные символы стоят, посмотрите
на определение терма. Что будет стоять вверху? Ну какой-то функциональный символ,
а в листьях будут стоять переменные или константы, это отвечает определению терм. Вот это
разбиение существенно при определении, давайте прямо здесь напишу значение, ведь формулы нам
нужны не просто так, написать формулу можно и их много можно написать, но наша цель зафиксировать
с помощью формулы какой-то предикат в какой-то модели, и поэтому нам нужны правила оценки
формулы. Как формулу, также как с булевой формулой, мы оцениваем булевую формулу каким-то
способом, получаем истину или ложь. Здесь оценкой формулы тоже будет истина или ложь, но не оценкой
термы. Термы будут оцениваться иначе, а формулы будут оцениваться истиной и ложь, но это будет
зависеть от многих вещей. Вот давайте сейчас я здесь напишу на этой доске, надеюсь помещусь,
значит для того чтобы оценивать формулу мы должны задать модель, иначе вообще невозможно
говорить об оценке формулы. Ну и в этой модели что должно быть? Какая у нее должна быть сигнатура?
Мы должны, если у нас есть формула, в ней встречаются какие-то предикатные функциональные
символы, константы. Модель должна быть такой, чтобы она содержала соответствующие предикаты,
функции и константы. То есть мы должны каждому вот этому синтоксическому элементу, символу,
который у нас есть, сопоставить. Ну предикат, я напомню, это отношение и правильная арность.
Если я хочу первый, допустим, у меня R1, он имеет арность 3, ну значит мне тут нужен тернарный
предикат, R2 имеет арность 2, ну значит нужен бинарный предикат. То же самое с функциональными
символами. Ну и константы это какие-то выделенные имена в модели. Модель, я напомню, сразу не пустой,
считается множество, это там для того, чтобы не возникали всякие паразитные проблемы. Но этого
еще недостаточно, чтобы сказать истинно формула или ложно. Почему? Потому что у нас есть переменные.
От значений переменных значение формулы тоже может зависеть. Поэтому нам еще нужна оценка
переменных. Ну это просто-напросто функция из переменных в модель. То есть функция из множества
переменных. Обычно мы как записываем функцию P и в круглых скобочках аргумент? Здесь это не
очень удобно, потому что круглые скобочки у нас носят синтоксический характер. Поэтому я то же
самое, это на самом деле то же самое, буду писать вот как. Х, допустим, значение переменной х в
квадратных скобочках, а имя оценки я буду писать как индекс. Вот здесь вот я тоже использую
квадратные скобочки, это у меня будет общее соглашение. У нас есть проблема, мы сейчас рассуждаем о
синтаксисе, в котором уже есть запятые круглые скобки и очень легко запутаться, если использовать
привычные математические приемы. Поэтому я буду использовать квадратные скобки, которых у меня
нет во фавите первого порядка, чтобы подчеркивать, что это значение какого-то синтаксического элемента
в модели. Значение переменной, ну вот оно задается какой-то оценкой, оно может быть разное. В модели
значение предикатных функциональных символовых констант фиксировано, поэтому там никакой оценки
не приписано, оно просто моделью задается. Давайте попробуем, что бы мне стереть. Наверное,
алфавит проще всего стереть, вряд ли вы запутаетесь хоть их и много, но вряд ли вы запутаетесь с алфавитом.
Ну вот я написал некоторую формулу, значит вот значок меньше это символ бинарного отношения,
а интерпретировать я ее буду так на действительных числах. Меньше это просто отношение строгого
сравнения. Ну здесь у меня нет констант и нет функциональных символов, ну давайте тогда,
чтобы константы будут похожим образом, давайте пусть будет функциональный символ. И есть еще
бинарный функциональный символ сложения. Вот такая формула. Она формула, естественно, потому
что смотрите, в корне стоит квантор всеобщенности, дальше предикатный символ, вот как я рисовал,
он бинарный и это уже атомарная формула, поэтому здесь есть терм переменная, а здесь терм более
сложный применение функций двум переменным. И вот мы хотим оценить, значит что нам нужно,
я уже написал оценку этих символов, она обычная, и мне теперь нужно написать, как я оцениваю значение
переменных. Ну вот скажем один и два. Вот если это зафиксировано, у этой формулы возникнет
логическое значение. Но я еще не описал, как оно возникнет. Что? Значит еще раз, тут некоторая
проблема состоит в том, что можно эти формальные определения давать по-разному и ни один из
вариантов не будет полностью удобен, то есть у нас будут возникать проблемы. Стандартно считается,
что мы определяем, смотрите, у меня на самом деле формальная оценка переменных, это оценка вообще
всех переменных в алфавите. Конечно для формулы это не нужно, потому что если в формулу входят,
мы сейчас увидим из правил оценки, входят какие-то переменные, то от остальных уж точно ничего не
зависит. Но формально мы вообще должны всем переменным приписать значение. Я этого не стал
делать, потому что это как-то уж совсем доска маленькая, переменных бесконечно много. Но правила
оценки они формулируются именно так. Я хочу сейчас просто продемонстрировать, как работают
правила оценки, раз уж попросили пример. Значит с чего начинается оценка? Оценка начинается с
оценки терма. Значит смотрите, оценки константа уже заданы, оценки переменных вот они тоже заданы,
поэтому если терм имеет длину один, ну уже знаем его оценку. Давайте теперь оценим терм,
который имеет вид функция от каких-то термов. Как вы думаете, как мы его оценим? Ну можно
догадаться, мы должны взять ту функцию, которая отвечает этому функциональному символу и применить,
рекурсивно вычислить значение от термов и применить эту функцию к этим значениям. Получим
значение функции. Ну в общем, самым естественным образом. Например, здесь. Как будет оцениваться терм
вот этот? Плюс, у, х, пи. Какая будет оценка? Ну мы видим один и два, значит функция у нас
сложения. Значит этот терм будет оцениваться в три. Теперь как оценивать атомарные формулы?
Следующий шаг. Оценка переменных она определяна на переменных, а на термы она продолжается. То есть
смотрите, у меня написано правило оценки. Вот я здесь написал, здесь термы. Формула состоит из
разных частей вершины. Формулы бывают термами, бывают формулами. Так вот, термы оцениваются как
элементы модели, а формулы оцениваются как обычно, как истина и ложь. И ну 0, 1. Я буду писать для
краткости 1, 0. Давайте смотреть, как я буду оценивать атомарную формулу на заданной оценке
переменных. Ну тоже легко догадаться. У меня есть предикат, отвечающий этому предикатному
символу. Я должен вычислить значение термов, которые входят в атомарную формулу. Ну и применить
предикат. Давайте на примере, как попросили. Пример, к сожалению, в другом месте, но я не
предусмотрел. Ну и вы видите, что трудно все поместить. Пределение довольно громоздкое. Как
будет оцениваться вот на такой оценке переменных вот такой предикат? Извиняюсь.
Ну надо оценить термы. Этот терм оценивается в двойку, а этот терм оценивается в тройку. Истина
значения 2 меньше 3. Истина. Вот мы оценили атомарную формулу. Ну теперь надо оценить дальше.
Значит оценки формул, которые являются булевыми связками, по обычным правилам. Я даже их не буду
расписывать, потому что это точно так же, как в случае булевых формул. То есть если у меня есть
импликация, я хочу ее оценить, я должен оценить посылку, должен оценить заключение, ну и применить
к полученным логическим значениям импликацию и так далее. А вот с кванторами получается хитрее.
Как оценить формулу с квантором? Она равна единице тогда и только тогда.
Сейчас я напишу, потому что трудно говорить. То есть смотрите, оценка получается очень хитрой.
Формула с навешенным квантором всеобщности равна единице тогда и только тогда, когда формула A,
ее называют область действия квантора, истина, но не просто на оценке pi, а на всех оценках,
которые совпадают с pi за исключением переменной х. А вот переменная х может в новой оценке,
пишу штрих, может принимать произвольное значение. Содержательно это очень понятно,
когда мы говорим, для любого х что-то выполняется. Это значит, что какой бы мы х не подставили,
х переменно оценим как-то, должно получиться истинным. Вот это формальное определение. Ну и
аналогичное определение для квантора существования. Тут только разница в том,
что достаточно одной такой оценки. Для всех пиш-штрих, а тут существует пиш-штрих.
И давайте вернемся к примеру. Теперь я хочу оценить всю формулу. Она как раз имеет вид квантора
всеобщности. Значит, я теперь должен сделать вот что. Я должен оценивать вот эту вот формулу не
только при тех значениях х и у, которые у меня написаны. Х у меня по-прежнему всегда будет 1,
а вот у я должен приписать мысленно все возможные значения и посмотреть,
всегда ли получается истина. Ну как вы думаете, при всех ли у выполняется неравенство х строго
меньше у плюс х. Если переписать нашу формулу в привычных обозначениях, она будет выглядеть
вот так. И теперь х у меня единица, а у я должен присваивать все возможные значения. Всегда ли
единица строго меньше, чем у плюс единица? Не всегда, потому что это зависит на самом деле от
носителя модели. Вот эта множество называется носителем модели. У нас действительные числа,
среди них есть отрицательные. Давайте возьмем там у минус 1. Ну вообще любое отрицательное число,
это нарушится. Если бы это были, скажем, целые положительные числа, это было бы правда. А даже
если целые не отрицательные, тоже неправда, потому что было бы ноль и строгого неравенства бы не
было. То есть вообще говоря, это свойство может быть чувствительным к модели, но в любом случае
так или иначе мы можем это определить. Можем в таком пиквикском смысле. То есть у нас есть определение.
Ну вот, то есть вот так устроены правила оценки, вот так устроены формулы, и вот с этим придется
дальше работать. Прощее определение я вам предложить не могу. Есть разные варианты, повторяю,
но во всех возникают какие-то неприятные синтакфические ограничения, что-то нужно говорить. В общем,
ну цель довольно мощная. Мы хотим вообще всю математику вложить в наш формализм, поэтому
приходится мириться с тем, что формализм получается не очень простым и содержит какие-то
такие неприятные вещи. Может быть кто-то когда-нибудь придумает лучший формализм. Пока вот
все, что известно, оно не сильно лучше вот этого стандартного. Что-что? Про кванторы? Значит,
смотрите, как оценивается квантор всеобщенности? Мы должны взять все оценки переменных, которые
совпадают с нашей, за исключением переменной X, и на каждой такой оценке вычислить значение формулы,
которая стоит под квантором, области действия квантора. Если всегда получается единица,
формула с навешанным квантором единица. Если хотя бы при одном значении ноль, формула ноль. Вот
как в примере. А с квантором существования похожая ситуация. Мы тоже берем те же самые оценки,
которые только в X отличаются, но теперь нас устроит, если хотя бы на одной такой оценке область
действия квантора оценивается в единицу. Содержательно это понятно. Тут ничего по сравнению
нового, по сравнению с тем, что я рассказывал в прошлый раз, нет. Но теперь мы зафиксировали
формализм и нужно зафиксировать определение, как мы вычисляем значение вот по этой формуле,
которая является словом или деревом, неважно. То есть вот так вот вычисляем. Ну и давайте сразу
первое наблюдение из правил оценки. Во-первых, из правил оценки ясно, что значение формулы уж
точно не зависит от переменных, которые в нее не входят. Я думаю, это просто вот понятно из
самих правил. Но оказывается больше. Переменная может входить в формулу, но от нее ничего не зависит.
Это тот вопрос, который вот мне задавали. Бывают такие переменные, от которых тоже ничего не
зависит. Давайте посмотрим. Тут надо ввести терминологию. Еще раз это я перепишу. Если у
нас формула имеет такой вид, вот это называется область действия. Квантер. Я пишу, в общем,
для квантера существование то же самое. Теперь пусть у нас есть какая-то формула. Я ее специально
напишу вот так. Это слово какое-то из символов. И пусть у нас есть вхождение переменной. Вот это
вхождение связанное. Называется связанное. Если существует квантер по х такой, что вот это
вхождение входит в область действия квантера. Вот как в примере у меня было. У у меня входил
связанно. А х свободно. Иначе свободно. Я еще раз напишу уже просто произвольными буквами. Вот
формула. Вот смотрите, у входит связанно. Он входит один раз, и он входит связанно. А х входит
свободно. Оба вхождения. Если формула какая-нибудь более сложная. Это тоже формула. Я скобку забыл
поставить. То смотрите, х входит три раза. Вот эти вхождения свободные. То есть свободные или
связанные вхождения переменной. Не имя переменной, а вхождение переменной. Вот эти вот вхождения
свободные. А вот это связанное, потому что он входит в область действия квантера. Такое возможно,
что одна и та же переменная входит и свободно, и связанно. Что мне сейчас важно, это что такое
параметр формулы. Переменная, это переменная, у которой есть свободное вхождение.
То есть в этом примере, скажем, у х есть свободное вхождение. Хотя бы одно. Вот нашли
свободное вхождение, всё, достаточно. А у у конец свободных вхождений. Вхождение под квантером,
оно тоже считается связанным для определённости. То есть свободное это то, которое не попадает в
область действия квантера. На самом деле это легко показать на вот этой схеме с деревом. Вот что
значит, что переменная входит свободно. Смотрите, у нас есть корень. Давайте я там не связку напишу,
а корень обозначу формулу. И как всегда в дереве, я думаю вы это знаете, от листа к корню существует
единственный путь. И что значит, что переменная входит, вот это вот вхождение, в разных листьях
может быть написано одно и то же имя переменной. Каждый лист это вхождение переменной. И вот что
значит, что это вхождение свободное. Значит, что когда я двигаюсь к корню, мне квантер по иксу не
встретится. А если он встретился именно по иксу, то это вхождение уже связано. То есть очень просто.
То есть вы просто смотрите на путь от листа к корню, там появился квантер по той же переменной,
ну значит она связана. Если не появился, значит это вхождение свободно. И вот первая лемма,
которую не сложная, но которую полезно доказать, чтобы убедиться, что мы нигде не наврались с
определениями формализма. Она такая, значение формулы зависит только от оценок параметров.
Ну вспомните пример, который мы разбирали. Там у был, не было параметров, у него только связанное
вхождение. И было видно, что хотя мы у какое-то значение вначале присвоили, но оно ни на что не
повлияло, потому что когда мы начали оценивать квантер, мы вместо у должны были подставлять все
возможные значения. Поэтому по этой лемме вы правы, чтобы сказать, какое значение формулы,
нам достаточно указать значение икса. Просто посмотрели на формулу, там есть параметры, вот
надо указать оценки параметров, этого будет достаточно. Но при таких определениях это становится
утверждением. Тут мы уже зафиксировали, как оценивается формула, теперь это надо доказать.
Ну доказательство очень простое, доказательство разбором по длине формулы. Базой будет случай
атомарных формул. Атомарные формулы, в них все вхождения свободны, поэтому ясно, что лемма
выполняется. Если мы применяем булевые связки, то что получается? Вот допустим импликацию я для
определенности буду говорить. Здесь есть какие-то параметры, здесь есть какие-то параметры,
какие параметры у формулы, которая является импликацией A в B. Ну объединение параметров
по двум подформулам. И если мы знаем значение всех этих параметров, у нас есть оценка всех этих
параметров, то по индуктивному предположению, мы можем оценить A, можем оценить B, ну и значит
можем оценить импликацию. Но и осталось понять что происходит, когда мы делаем шах индукции
на формуле с навешанным квантором. Здесь тоже очень просто, потому что, смотрите,
вот если у меня есть формула вида для любого xA, в этой формуле x точно не параметр, потому что
самого верху висит квантор, значит, все вхождения xA в эту формулу будут связаны. Значит, нам нужно
доказать, что оценка зависит только от параметров A за исключением возможной x. x может быть параметром
формуля. Ну так это понятно из определения, потому что мы x придаем все возможные значения и смотрим,
получится у нас всегда единица или нет, если квантор в всеобщенности, или получится хотя бы
один раз единица, если квантор существует. И ясно, что этот результат не зависит от того,
как я оцениваю переменную x. Ну, как в примере, я приписал формально какое-то значение, но оно
никакой роли в оценке уже формулы с квантором не сыграло. Поэтому эта лемма выполняется. И
фактически получается... О! Базы атомарные формулы, вот такого вида. Утверждение у нас такое,
что значение формулы зависит только от значения параметров. Какие параметры у атомарной формулы?
Все вхождения переменных, потому что квантора вообще нет, поэтому все вхождения свободны.
Связанное вхождение может возникнуть только, если есть квантор, а в атомарной формуле его нет.
Ну и в сущности теперь понятно, что формула задает нам, когда зафиксирована модель. Если
модель не зафиксирована, формула вообще непонятно, что задает, это мы обсудим. Формула,
которая для всех моделей что-то говорят, это отдельная история. Но обычно значение формулы
зависит от модели. Вот мы берем, и в примере я это показал, это тоже возможно. Мы берем модель,
и что задает формула? Чтобы получить истину или ложь, мы должны задать оценку переменных. Теперь
мы уже знаем, что достаточно задать оценку параметров. То есть фактически формула задает
предикат. R-ности равны количеству параметров. В частности, если формула, как говорят,
замкнутая, в ней нет параметров. Такие формулы тоже бывают. Я сейчас напишу какую-нибудь. Для
любого x, а от x. Эта формула называется замкнутая, потому что ни одного параметра нет. По этой
лемме ее значение не зависит ни от одной переменной. То есть она истинная или ложь данной модели. Такой
нулярный предикат. То есть замкнутые формулы задают фактически в каком-то смысле аналог
булевых формул в том смысле, что если задана модель, а модель заменяет нам присваивание
переменных. Вот тогда у таких формул есть значение. А у остальных это получается некоторый
предикат. Ну и последнее, что я хочу сказать перед перерывом, до него осталась минута,
что в отличие от булевых формул, там всегда есть надежда иногда иллюзорная, что если мы
посмотрим на все мыслимые значения, там на самом деле всегда значение вычисляется. Я неправильно
сказал, не надо посмотрим. Если у нас есть формула и значение переменных, то чего бы не вычислить.
А с формулами первого порядка это не так. Если задана модель, давайте я напишу какую-нибудь
формулу сложную. Для любого х существует у такой что... Я позволю себе тут немножко
математические жаргоны в обычном виде написать, чтобы было понятнее. Ну, значит, эта формула я
хочу ее интерпретировать на натуральных числах. Ну давайте даже на положительных натуральных
числах. Прайм это предикат унарной простоты. Ранее единицы, если число простое. Сложение это
сложение, это прибавление просто. Двойка это константа. Ну а это сравнение чисел. И что здесь
написано вот в такой формуле? Она замкнутая, как нетрудно видеть. У нас есть два квантора по х и по
у и другие переменные не входят. Что эта формула утверждает? Она утверждает, что есть сколько угодно
большое простое у такое что у плюс два тоже простое. То есть, чтобы оценить эту формулу,
нужно решить знаменитую проблему простых чисел близнецов. Она истина, если простых чисел
близнецов бесконечное количество и ложна в противном случае. И тут ясно, что уже никакое
построение табличек нам не поможет. Это вот математика. Ну либо истина, либо ложна. Никто не
знает. Уже много веков люди пытаются на этот вопрос ответить и ничего не получается. Несмотря
на то, что теория чисел развита там до безумной степени, но не выходит. То есть оценки формул
первого порядка это уже очень непростое дело. И ой, я извиняюсь, сейчас нужно делать перерыв.
После перерыва я начну объяснять почему так. Ну, собственно, короткое объяснение уже было,
что мы всю математику можем выразить не только простые числа близнецов, а вообще все что есть.
Значит, такое небольшое введение в синтаксис у нас появилось, но и появилась некоторая
семантика. И теперь я хочу про семантику поговорить, потому что синтаксис сам по себе,
он не очень интересен. Ну, зачем он нужен? Тут опять-таки придется ввести какие-то слова. Сейчас
я их сделаю ввиду. Значит, логики используют такую терминологию. Теория
т-аккурсивная. Это множество замкнутых формул. Ну, почему это называется теорией? Это на совести
логиков. Обычные математики это называют аксиомами. Вот простой пример. Допустим,
мы изучаем группы и написали множество замкнутых формул. Я их выписывать не буду для скорости,
но, я думаю, в голове легко представить, что это формулы первого порядка. Значит, какие у нас
свойства у группы? Ассоциативность. То есть, для любого х, для любого их, для любого z,
должно выполняться равенство ассоциативности. Ну, в сигнатуре группы это записывается.
Существует такой элемент группы E, что, ну или если E у нас константа, то тогда это будет
выглядеть так, что для любого х, E умножить на х равно х умножить на E равно х. Тоже формула первого
порядка. Равенство у нас есть в этой сигнатуре. Ну и обратный тоже можем написать. Это с точки
зрения специалиста по теории группы, аксиомы группы. Но логики, когда мы напишем соответствующие
формулы, скажут, что нет, это вы написали теорию. Ну вот такая терминология. Мы ей будем
пользоваться, потому что так в логике говорят. Значит, и поскольку формулы замкнутые, то для
каждой модели теории, модели теории это понятное дело, что такое. Ну не очень понятно, сейчас скажу,
модель теории. Во-первых, в сигнатуру входят, входят интерпретации всех символов из Т. То есть
для каждой формулы мы должны уметь по правилам оценки вычислять значение. И все формулы,
из Т истины. Ну вот модель, давайте как-нибудь ее М обозначу. М, ну и здесь что-то там сигнатура. То
есть моделью теории я называю такую модель, в которой все формулы из нашего множества,
они замкнутые, поэтому они истинные или ложные в каждой модели. Вот они должны быть все истинные.
Ну, например, моделью для аксиом группы будет любая группа. Модель у данной теории,
их может быть много, они могут быть устроены по-разному, да. Модель теории, это такая модель,
в которую входят интерпретации всех символов формул теории. Ну у нас формулы теории содержат
какие-то переменные, не переменные, предикаты, функциональные символы. Все они должны быть в
этой модели определены. Ну вот как здесь в правилах оценки. И причем должно еще также выполняться такое
свойство, что все формулы теории должны быть истинны в этой модели. Значит, конечно, не у любой
теории есть модель. Я сейчас легко напишу теорию, у которой нет модели. А вот можно здесь простой
пример. Вот, значит, вот одна формула и вот вторая формула. Они обе замкнуты, но я думаю всем понятно,
что модели у такой теории быть не может. Как бы я не проинтерпретировал символ А, у меня фактически
написано формула и ее отрицание. Но по правилам оценки, либо формула ложная будет в ложь оцениваться,
либо отрицание будет в ложь оцениваться. Значит, у такой теории просто нет модели. Значит,
Т говорят совместно, если есть хотя бы одна модель. Ну и не совместно в противном случае. Вот
эта модель не совместна. Ну то есть несовместная модель, это мы погорячились, мы наложили такие
условия, которые выполнить в принципе нельзя. А если совместно, значит, о чем-то идет речь,
не всегда о чем-то однозначно определенном. Вот как в случае аксиом группы. Группы у нас очень
много свойств, они очень сильно различаются. И так, ну, какие-то теоремы вернут для всех групп,
но таких теорем мало, но какие-то вернут. Теперь я напомню, что у меня возникало понятие
семантического следствия, оно определено и здесь. Синтактическое у нас появится позже.
Значит, формула А является семантическим следствием из теории Т, если А истина в любой модели Т.
В сущности, я повторяю то же самое определение, что было для более формул только в более
общей абстрактной ситуации. Значит, модель – это такая интерпретация всех символов,
которые входят в наши формулы, при которых они все становятся истинными. И вот если такая
интерпретация сделана, может так получиться, что формула А тоже истина. Ну, в качестве примера,
если у нас есть теория группы, то вот та формула, которую я уже выписывал, что для любого x,
для любого y, x, y в минус 1 равняется y в минус 1 на x в минус 1. Это формула, и она
является семантическим следствием теории групп, то есть тех вот аксем трех, которые у
нас задают свойства группы. Формула. Это теория, это формула. Любая. Ну, вот как пример,
вот я написал пример формулы А. Только тогда здесь нехорошо писать равенство внутри формулы,
как-то вот так что ли напишу. То есть у нас получается так, что эта формула будет следствием
теории групп. Семантическим следствием. Потому что, если выполнены аксиомы группы, это мы
проверяли, это несложно доказать, что из них будет, как только выполнены аксиомы группы,
значит вот это тоже свойство выполнено. Мы проверяли, это все достаточно, просто рассуждения
там какие-то нужны. Но тем не менее, мы знаем, что это семантическое следствие. И это частный
случай общего понятия. Можно вообще сказать, что вся математика примерно этим и занимается.
Какие есть следствия, у каких теорий? Ну, под теориями, я напомню, с точки зрения содержательной
математики мы имеем в виду аксиомы. То есть мы задали аксиомы, аксиомы геометрии. Какие мы
можем доказать теоремы в геометрии? Но доказать это будет дальше, это будет синтаксическое следствие.
Это вот основной вопрос логики, с которого логика стартовала, это как бы вот это неформальное
понятие семантического следствия превратить в синтаксическое понятие. Формулы ведь синтаксическое
понятие. И мы можем какие-то манипуляции с формулами делать. Например, менять под формулу еще какую-то или
еще что-то. И цель состояла в том, чтобы придумать такие правила манипуляций, при которых мы получаем
в результате в точности семантические следствия из данного множества формул. И эта цель достижима.
Я объясню, правда, очень не сразу, но это вот одна из основных вещей, которые вы должны вынести из
курса, что не просто достижима, а даже как она достижима. Но это будет позже. Пока давайте посмотрим
на примеры. Ну, теория групп тоже пример, но давайте какой-нибудь. Я хочу сейчас проиллюстрировать
одну тонкость, с которой приходится тут мириться из-за наших определений. Давайте рассмотрим такую
теорию. Давайте я даже следуя логике, логиком напишу по-уродски. Вот логики очень любят вместо
того, чтобы писать обычное математическое обозначение множества через запятую элемент и писать
как-то вот так. То есть это на самом деле множество из двух элементов. Логики просто пишут плюс,
обозначают и то и то. Ну, так принято. Давайте я сейчас напишу нормально. Я не буду этим злоупотреблять,
но в каких-то ситуациях я это буду делать, потому что это настолько стандартно, что очень трудно
избежать. Очень трудно отказаться. А формулы сами по себе выглядят вот так. Да, значит,
я опять-таки в формулах не пишу скобки, предполагаю, что скобки мы расставляем в соответствии с
представлениями о старшинстве. Представление о старшинстве такое, ну кванторы равноправны
по старшинству. Они сильнее, чем импликация и эквивалентность, но слабее, чем конъюнкция
и дизюнкция. И тем более отрицание. Я не буду этим злоупотреблять, потому что вот если у меня
написана формула для любого х, а и б, я буду стараться всегда писать вот так. Вообще иногда
буду забывать, потому что я привык к такому порядку, что конъюнкция сильнее, поэтому мы должны
вычислить конъюнкцию а и б, и потом уже навесить квантор на то, что получилось. Но я постараюсь
скобки ставить в этом случае. А когда скобки не поставлены, это подразумевается, что их можно
восстановить. Сейчас я напишу формула. Кто-то уже может быть даже сообразил, почему она называется
транс. Не сообразили? Ну тут поскольку импликация, тут я все-таки обязан поставить скобки.
Импликация слабее, чем квантор. А это ареф. И тоже кто-то мог бы сообразить. Почему,
как вы думаете, первая формула называется транс? Транзитивность. На самом деле,
когда мы будем задавать модель для этой теории, нам нужно, у нас вообще только
предикатный символ, бинарный, нужно предикатный символ как-то интерпретировать, как бинарные
отношения. Ну а что означает тогда вот верхняя форма? Она означает транзитивность этого отношения.
Если х и у в отношении, у и з в отношении, то х и з в отношении. Свойство называется транзитивность.
А нижнее свойство называется антирефлексивность. Почему? Потому что если х и у в отношении,
эта формула говорит нам, что тогда точно неверно, что у и х в отношении. Антисимметричность хорошо,
значит. Извините, не хорошо, а вы правы. Антирефлексивность – другое свойство. Спасибо.
Значит, антисимметричность, прошу прощения, это я заговорился. Все правильно, это именно как
антисимметричность нужно понимать. Антирефлексивность – это что для любого х неверно, что ах. Я извиняюсь,
это я действительно перепутал. Ну и какие отношения удовлетворяют свойству транзитивности,
антисимметричности. В этих отношениях в математике есть специальное название. Я не знаю,
учили ли вас на первом курсе бинарным отношениям. Учили, нет? В общем, это называется строгий частичный
порядок. Если у вас есть отношения, которые удовлетворяют этим свойствам, то то есть
tau – это теория строгого частичного порядка. А линейный я не случайно обмолвился, потому что
теория эта не очень удобная, в ней мало теорем можно доказать и ничего интересного, хотя про
частичные порядки можно много чего интересного сказать. Но вот в таком виде, в виде семантических
следствий таких формул не так много можем сказать. Почему? Давайте поймем, чем трудность. Важный
класс порядка в линейные порядки, когда любая пара элементов сравнима. Как записать условия
линейности порядка? Хочется написать что-то такого типа для любого х, для любого у, аух или аху,
что элементы сравнимы. Но я думаю, что многие из вас, глядя на эту формулу, уже сообразили,
что это так делать не стоит. Какие будут модели у теории T плюс вот эта формула? То есть такие
отношения, для которых выполнена и транзитивность, и антисимметричность, и вот это вот свойство
линейности. Нет. Какие модели? Назовите хотя бы одну для примера. Нет. Моделей у такой теории
просто нет. Такая теория не совместна. Смотрите почему. Потому что, в частности,
я когда оцениваю эту формулу, я ее должен оценивать, придавая х и у одинаковые значения. Там же стоит
для любого х и для любого у. Значит у нас в оценке этой формулы возникнет такая оценка
переменных, когда х и у оцениваются одинаково. Но тогда смотрите, что здесь написано. Здесь написано
AXX следует не AXX. А здесь написано AXX или AXX. Ну, AXX или AXX это понятное дело просто AXX. А что
написано здесь? AXX следует не AXX. Это на самом деле логически, как ни трудно видеть, просто не
AXX. То есть получается так, что вот эти две формулы при такой оценке приобретают обязательно разные
логические значения. Поэтому модели просто нет. Ну и после этого уже ничего интересного сказать
нельзя. Значит нам нужно выкрутиться. Вот свойство линейности, оно в математике записывается немножко
иначе, более хитро. Для любого х, для любого у. Из того, что х не равно у, следует, ну вот что. То есть
любая пара разных элементов сравнима. Вот тогда все в порядке. Тогда проблем не будет у нас. Любое
отношение линейного порядка, скажем, действительные числа со строгим неравенством, как вот мне
предлагали, оно уже будет удовлетворять этому. Оно является отношением строгого порядка и будет
удовлетворять этому свойству, потому что любые два разных действительных числа вы можете сравнить.
Или одно больше, или другое больше. Возникает другая трудность. У нас в формуле появилось что? Еще
один предикат. И теперь другая проблема. Я могу этот предикат интерпретировать как угодно. Например,
как пустое множество. И тогда моделями теории t плюс вот эта формула lin будут вообще все строгие
частичные порядки. Потому что если это пустое множество, предикат всегда истинный, мы просто...
Сейчас, секунду. Наоборот, нужно, чтобы он был всегда ложный. А он будет всегда ложный, потому что,
ну да, естественно, как бы вы... А нет, то есть нам нужно, чтобы предикат неравенства был пустым,
значит все элементы равны. Тогда вот это вот всегда ложно, и эта формула всегда будет оцениваться
истинной. Это некоторая проблема, которая мешает, вообще говоря, в нашем формализме. У нее есть
некоторое стандартное решение. Я, наверное, сегодня расскажу только кусочек, а подробнее расскажу,
когда потребуются детали. Кусочек состоит в следующем. Часто рассматриваются не просто модели,
я даже это не буду писать, для нас это будет немножко вспомогательным понятием. Не просто
модели теории рассматриваются, а то, что называется нормальные модели. Нормальная модель это вот что
такое. У нас в сигнатуре теории выделяется бинарный предикатный символ, который мы считаем
равенством. Он обычно и обозначается знаком равенства. И нормальная модель, когда символ
равенства предикатный, интерпретируется как именно равенство в модели, то есть как бинарный
предикат равенства. И тогда у нас вот проблем не возникает. Если я говорю про нормальную модель
теории t плюс лин, это в точности линейные порядки. То есть нормальные модели все такие. Но
вторая сторона этого вопроса, что на уровне модели я всегда могу сказать, что этот выделенный символ
я интерпретирую как равенство. Но мне может захотеться сами формулы подкрутить, чтобы, раз уж я
ввел равенство, чтобы у меня не было сомнений, что этот символ нужно интерпретировать как
равенство. Для этого есть некоторый специальный набор формул, которые добавляются в теорию с
равенством. И это понятно, что это свойство равенства. Отношение эквивалентности, рефлексивность,
что x равно x. Симметричность x равно y следует y равно x. Ну и транзитивность та же самая.
Кроме того, нам нужно еще убедиться, что все остальные функции предиката уважают это равенство.
Что если вы в предикат подставляете равные значения, скажем, a от x1 и y1 и a от x2 и y2. Если x1
равен x2 и y1 равен y2, у вас должно получаться одинаковое значение. Вот нужно для каждого
символа и сигнатуры добавить еще вот такие формулы согласования. Тогда получается то,
что называется теория с равенством. И в сущности, за исключением несущественной подробности,
это практически у теории с равенством и будут модели нормальными, только нужно взять отношение
эквивалентности. Вот у нас формально определено отношение эквивалентности, нужно взять классы
эквивалентности. Мне это будет нужно в очень специальном случае, я поэтому подробно на этом
останавливаться не буду. Можно было бы сразу перейти к нормальным моделям, считая, что у нас
всегда есть сигнатуры равенства, всегда мы его интерпретируем как равенство, но это создает
другие неудобства. Неудобства, связанные с рассуждениями по индукции и так далее,
вот этот более свободный синтаксис, он позволяет легче простраивать доказательства, а с равенством
рассуждения могут оказаться более сложными. Поэтому я по умолчанию буду считать, что у нас
модели общие, а если я буду говорить о нормальных моделях, я буду прям так это специально оговаривать,
имейте в виду. Ну и тем более о теориях с равенством, там я буду просто аккуратно прям выписывать
все эти свойства. Вот это такая особенность с моделями и вот мы более-менее сейчас показали,
что всю математику можно в принципе себе мыслить как игру, как изучение семантических
следствий с теорией, осталось только понять, почему у нас все-таки формализм первого порядка
очень ограничен. В прошлый раз мы обсуждали, что у нас в математике бывают такие индуктивные
определения, как я давал определение целого числа, используя сигнатуру алгебритарского,
там было индуктивное определение. Ну и формулы мы определяем индуктивно, не стесняясь. Бывает
много чего и возникает вопрос, почему собственно мы считаем, что формализм первого порядка такой
уж удобный. Еще один пример, когда он неудобен, когда вы изучаете анализ, там проблема в том,
что наш формализм первого порядка, он бестиповый, то есть все переменные, они одного уровня, они
принадлежат просто носителю модели. А в анализе страшно неудобно, потому что вы говорите о числах и
о функциях. И получается так, что нужно либо переходить к формулам второго порядка, разрешать
кванторы по функциям. Для любой функции счет выполняется. Либо, чтобы сохранить первый порядок,
нужно ввести в качестве носителя модели такое противоестественное явление, как действительные
числа и функции на действительных числах, и ввести еще такой вот предикат тип, предикат число,
который примененный к их говорит, что он истинный, если это число, а если это функция, то он ложный.
И тогда все можно записать, не вводя предикатов по функциям, но это очень громоздко. Почему же я так
уверен, что всю математику, тем не менее, можно выразить логикой первого порядка. Дело в том,
что это некоторая общая догма, в которую все верят, что всю математику можно выразить в
теории множества. Множество, я напомню так, если неформально, это просто совокупность элементов
какой-то природы. Множество равны, если в них ходят одни и те же элементы, ничего больше нет. И
оказывается, это люди долго к этому шли, но смогли всю математику простроить из множества. Значит,
тут я всегда делаю оговорку, связанную вот с чем, что сто с лишним лет назад математики были очень
озабочены корректностью формализма, и действительно пересказывали на формальном уровне практически все
новые результаты. И это все получалось. А потом оторопь от того, что в основаниях математики
обнаружились проблемы, прошла, выросло новое поколение математиков, и оно стало больше
интересоваться интересными приложениями физики и так далее, а основания как-то отошли на второй
план. И с тех пор прошло уже лет 70, по меньшей мере, то есть уже не одно поколение несколько
сменилось, и доказано, что сто тысяч теорем, я думаю, это довольно точная отсылка. И конечно,
в доказательствах этих теорем математики не стесняются, они используют средства,
какие только могут. И верно ли, что любую доказательство любой теоремы можем пересказать
в теории множества, сейчас это отчасти вопрос веры, потому что для каждой теоремы, которую
доказало человечество, это не проделано. Это могло бы быть проделано, если бы научились боты,
которые выдают себя за искусственный интеллект, научились бы не писать политические заметки,
а читать математические статьи и писать формальные доказательства по ним. В общем-то,
дело-то нехитрое, на самом деле, математические статьи и без того довольно формально написаны.
Казалось бы, это не должно быть такой неподъемной работой, но вот эта цель,
которую, в принципе, по моим оценкам, мощности компьютера хватало бы для достижения этой цели
где-то в начале 21 века, то есть в тысячу раз меньше, чем есть сейчас. Но эта цель сейчас
не достигнута, я подозреваю, еще в течение 20 лет не будет достигнута. А статьи из-за политиков
писать будут это, конечно, но это просто задача немножко разной, трудность. Вот,
так давайте все-таки я объясню, на чем зиждется наша уверенность. Нам нужен всего один предикатный
бинарный символ. Чтобы говорить о множествах, как ни странно, у нас сигнатура будет примитивнейшая,
просто один предикатный символ. Без предикатных символов нельзя, я вот уже стер, вот остались
правила оценки. Видно, что чтобы была формула, нужно, чтобы хотя бы один предикатный символ был,
иначе у нас нет атомарной формулы, ничего не построено. Так вот, теория множества мы будем
объяснять, используя всего-навсего один предикатный символ. Понимаем мы его так,
x принадлежит y, то есть x является элементом y. Ну, с помощью этого предикатного символа можно
определять много других предикатов, используя правила первого порядка. Например, что значит,
что x под множество y. Ну, мы знаем, что это такое, что для любого z из того, что z входит в x,
следует, что z входит в y. Согласно, да, вот как мы определяем под множество, вот так и определяем,
что каждый элемент, который входит в x, входит в y. Ну, а что такое равенство? У нас были проблемы
с равенством, тут проблема решается очень просто. Это по определению означает, так мы множество не
формально определяли, что x содержится в y и y содержится в x. Ну, формулы первого порядка.
Ну, пока мы недалеко ушли, давайте определим еще какую-нибудь вещь. Скажем, я хочу определить,
что множество x всего один элемент. Обычно такие множества называются синглитоны. Как это сделать?
Ну, давайте попробуем. Для этого надо написать какую-нибудь формулу, где параметром является x,
но с какими-то переменными. Значит, что для любого y. Не так. Существует такой y, что, во-первых,
y входит в x. И для любого z, из того, что z входит в x, следует, что z равняется y. Согласно. Как
определить, что множество ровно один элемент? Вот мы говорим, что такой элемент есть в этом
множестве элемента, оно не пустое. Пустое множество тоже определить легко. Что значит,
что пустое множество? Это по определению означает, что для любого x неверно, что x принадлежит пусто.
Это и все. А тут оно не пустое, хотя бы один элемент есть. Дальше мы добавляем условия,
что других нет, что если я взял какой-то другой элемент, то он принадлежит множеству,
то он с x совпадает. Следующий факт, не факт, а предикат, который хорошо бы выразить, это что в
множестве два элемента. Ну, я думаю, я даже не буду сейчас писать. Я думаю, что всем понятно,
как такую формулу написать. Ну, вот здесь надо заменить. Существует y и существует,
не знаю, v такие, что y принадлежит x, v принадлежит x, y не равно v. И для любого z, если z принадлежит x,
ну, дизьюнция или z равен y или z равен v. В общем, такую формулу написать можно. Ну,
и там что три элемента, в общем, любое конечное число элементов мы написать можем. Но этого пока
мало. Значит, решающий шаг, решающий шаг состоит в том, что нам нужно определить, что такое упорядоченная
пара. Множество, они не упорядоченные, там вот они определяются в точности своими элементами. А
нам в определениях очень часто бывает, можно говорить о последовательностях и вот как минимум
в упорядоченных парах. Ну, если вы вспомните, вам почти заведомо вводили понятие Декартова
произведения множества. Оно определяется как множество упорядоченных пар. А что такое упорядоченная
пара? Как ее выразить? Если мы все хотим построить из множества, мы должны как-то уметь выражать
упорядоченную пару из множества. Ну, и я сейчас напишу содержательное определение. Оно не единственно
возможное, но вот одно из стандартных упорядоченных пар по Куратовскому называется. Упорядоченная пара
называется множество, в которое входит в качестве элементов только множество, содержащее ровно один
элемент х и множество, которое содержит х и у. На самом деле, сколько элементов в таком множестве,
это еще вопрос. И обязательно, может быть один, если у равняется х. Потому что если у равняется х,
вот это множество, это множество, это одно и то же. В перечислении сколько мы не перечислим. Ясно,
что это определение в первом порядке переписывается. То есть мы пишем, во-первых, что это множество
содержит два элемента, а дальше мы пишем, что это вот синг и содержит именно х, а это вот мы
пишем без условия, что х не равен у, пишем формулу для пары. То есть это все записывается и
получается длинная формула, но которая задает упорядоченную пару. Почему я так сражаюсь столько
времени с упорядоченной парой? Потому что я не случайно упоминал про Декартово произведение.
Теперь, имея упорядоченную пару, мы можем определить, что такое Декартово произведение множество.
Х Декартово на у, нам нужно определить, что значит, что z какой-то принадлежит Декартово
произведению. З принадлежит х умножить на у, если существует у принадлежащая х,
в принадлежащий у такое, что х является упорядоченной парой у в. Определили. А в
частности Декартово произведение множество позволяет нам определить понятие функции. Я не знаю,
рассказывали ли вам про это в прошлом году, но должны были по идее, что функция такой,
это фактический график функции, но с точки зрения теории множества, это и есть функция. Функция
это множество таких упорядоченных пар и х и у, что каждым х отвечает не более одного у. Ну,
а имея функции, мы уже можем много чего сделать. Можем, например, определить, что такое инъекция,
что такое сюръекция, что такое биекция. Наконец, мы можем определить бесконечное множество. Потому что
бесконечестный множие является обеим. И это самова, равномощная данным. Равномощная
существует биекция. Что такое биекция, мы мы определить можем. Значит, у нас появляется
понятие бесконечного множства, появляется понятие конечного множца. Но, чтоб развивать
математику содержательную, нам вообще-то надо не столько бесконечный множ puff, а сколько прямо
честно натуральные числа. Потому что это в 19 веке еще стало
известно, что, если у нас есть понятие натурального
числа, дальше математики умеют выстраивать всю свою
науку. Определить целые числа, как в школе это
делается, потом определить рациональные числа, это
тоже делается в школе уже не настолько чисто, потом
определить действительные числа, в школе это делается
совсем не часто, ну может быть вас на анализе на первом
курсе научили это делать часто, ну если не научили,
Не то чтобы безумно сложно.
Есть понятие додакиндово сечение,
есть понятие бесконечная двоичная дробь,
то есть есть много способов выстроить теорию
действительного числа, если у вас есть
рациональные числа.
Ну и более сложные объекты из этого
можно строить, ну и произвольное множество
можно строить.
Для алгебры скорее нужны произвольные множества.
Ну там операции, ну опять-таки если
возьмем алгебру, что там нужно?
Нужны операции, нужно уметь объяснять
свойства операции, то есть видно,
что формулы первого порядка, если уж мы можем определить функции, должно хватить, чтобы те же
аксемумы груб задать. А натуральные числа, их можно по-разному определять. Когда появляется
конечное множество, уже можно пытаться определить количество элементов в нем. Удобнее всего это
сделать, задав прям натуральный ряд. Натуральный ряд в теории множества обычно задают вот так.
Вот смотрите, это число 0, это число 1, это число 2. Как, если у нас есть множество,
задающее число n, построить множество, задающее число n плюс 1? Нужно взять множество,
отвечающее числу n и добавить в него в качестве элемента само это множество. Ну 3 я сейчас так
напишу. У нас есть 2. Чтобы задать 3, я беру множество, задающее 2 и добавляю в качестве
элемента само это множество. Ну и понятно, что так можно продолжать неограниченно долго. Получаются
натуральные числа. Дальше можно считать, что элемент этого множества, это можно определить с
некоторым трудом, но можно. Элемент этого множества кодирует натуральное число. И чтобы говорить о
конечном множестве какого-то размера, мы говорим, что есть биекция вот с этим фиксированным множеством,
которое мы определили. То, что вы там написали 1, 2, 3, это мощности множества. Ну это и мощности
множества. Это на самом деле просто множество, которое отвечает натуральным числам. Формальная
теория множества, не при всех подходах, но при некоторых. Под натуральным числом понимается
множество вот такого вида. У нас же есть только предикатный символ, как откуда взять натуральное
число. Ну вот пустое множество я определил. А дальше каждый вот этот переход, он определяется
формулой первого порядка. Потому что, что я сказал, естественно определяется. Там еще нужны некоторые
свойства, чтобы этот процесс был именно однозначный, чтобы у нас продолжение было однозначно. Но это все
делается, это можно аккуратно сделать. Никаких сложностей с этим нет, если у нас есть понятие
функции. Ну вот, у меня осталось буквально три минуты, я хочу немножко вас разочаровать. Так
получается все красиво, мы всю математику теорию множества вложили. А давайте зададимся вопросом.
Да, значит, про что я не сказал и не буду говорить. Свойства множества можно описать тоже как теорию
первого порядка. То есть написать множество, определить множество формул первого порядка,
которые задают вот аксиомы теории множества. Ну там есть разные аксиомы, в частности вот то,
что я использовал, что экстенсиональности, что множество равны тогда и только тогда, когда у
них одинаковые элементы. Есть более сложные аксиомы. В общем, это называется, их несколько
вариантов, но самый стандартный называется ZFC. И там, ну вы можете в википедии посмотреть или в
каких-нибудь книжках под названием теория множества. Есть списки этих аксиом. Там некоторые аксиомы такие,
что не сразу поймешь, почему они нужны, но они действительно нужны. Без них не удается ничего
доказывать. А эти аксиомы, они существенны тем, что все свойства, которые мы знаем про множество,
там вообще говорят доказать можно. То есть поэтому получается так, что все, что мы можем доказать
математике, можем доказать ZFC. Значит ZFC – неоднородное обозначение. Z и F – это фамилии,
это Цермелла и Френкель. Два математика. А C – это не фамилия. Дело в том, что среди аксиом,
это примерно как в геометрии, среди аксиома есть очень аксиома, которая у всех вызывала раздражение,
аксиома выбора. Значит, часть аксиом, теория множества говорит о том, как можно строить множество из
уже имеющихся. Например, если у вас есть множество и есть какая-то формула первого порядка,
но в сигнатуре множества, то она может выделить те элементы из данного множества, которые
удовлетворяют этой формуле. Ну, формула с одним параметром. То есть такое определение через
свойства. Но есть еще одно определение, которое такое, что если у вас есть семейство множеств,
это тоже можно аккуратно определить, что такое, вы можете построить множество,
выбрав по одному элементу из каждого семейства. Ну, как наглядно это представляет так. Представьте,
что у вас стоят подносы с кучей печеньек. И вот вы можете выбрать из каждого подноса по одной
печеньке, образовать новое множество. Но очень невинные аксиомы, печеньки-то точно с подноса
собрать можно, это все понимают. Но из этой аксиомы следуют очень странные выводы. В ZFC можно
доказывать очень неприятные с точки зрения нашей интуиции вещи. Сейчас уже закончилось,
я последнее что скажу. Можно, например, доказать, что шар трехмерный, можно разбить на несколько
частей пять, что ли. Так чтобы, по-моему, пять. У вас восемь получилось? Посмотрите книжку Яченко,
по-моему, он объясняет, как пять сделать. Значит, так их повернуть, чтобы сложить шар вдвое
большего диаметра. То есть решим продовольственную проблему человечеству. Взяли клубень картофельный,
разрезали на пять частей и сложили два таких же. Ну потом можно это повторять сколько нужно. Вот,
то есть это, конечно, выглядит неправдоподобно и противоречит нашей интуиции, но тем не менее,
если вы признаете аксиомы ZFC, там это доказуемо. Вот, поэтому C всегда выделяют. Иногда рассматривают
ZF, это без аксиома выбора. Там можно много тоже доказать чего, но не все. Иногда аксиомы выбора
заменяют на не менее странные аксиомы, которые с аксиомой выбора не согласуются, и у них тоже есть
какие-то приятные следствия и неприятные следствия. В общем, но про формальную теорию множества я буду
говорить сильно позже и не очень подробно. Это все-таки для начального курса слишком сложный предмет,
то есть я даже список аксиомов не буду выписывать, уж тем более не буду пытаться объяснять, как из них
все доказывается. Ну, вы можете взять какую-нибудь старую книжку, например, Куротовского теории
множества или какие-то более новые. В принципе, сейчас перевели какие-то книжки хорошие. Я так даже
не посоветую, но я читал в свое время Куротовского. Ну, занудное чтение в какой-то момент просто
становится скучно, потому что начинаешь понимать... Кстати, в Мендельсоне, насколько я помню,
который у нас в списке литературы, там формальная теория множества до какого-то предела развита.
Обычно скучно становится раньше, чем заканчивается этот начальный уровень, потому что становится понятно,
ну да, так вот все можно доказать, но вот мучиться с формальными доказательствами становится уже не
интересно. Когда становится ясно, что да, все наши неформальные рассуждения вот такими трюками можно
воспроизвести. Ну хорошо, на сегодня все тогда.
