Напомним, мы в прошлый раз обсудили, как писать
быструю сортировку, но давайте очень быстро напомним, как
это делается.
Есть массив, мы выбираем случайно его элемент в
качестве пилота.
Напоминаю, выбирается он именно случайно, равновероятно
среди всех возможных элементов массива.
Дальше в идеале, ну и точнее на самом деле, как мы и будем
делать, мы разбиваем наш массив с помощью процедуры
partition на три куска, сначала идут элементы меньше x, затем
элементы равны x, затем элементы больше x.
Я на прошлой лекции показал, как разбить на два куска,
что сначала меньше, потом больше либо равное, ну можно
там еще раз, еще одним циклом пройтись и сначала записать
вот из этого блока, выделить все x, написать их сюда, потом
оставить все больше.
То есть, грубо говоря, это мы все-таки предполагаем,
что ровно так мы массив разбиваем.
Ну и дальше рекурсивно сортируем вот эти вот два кусочка, да,
те кто меньше x, а те кто больше x, а просто рекурсивно
сортируем и в результате получается сортированный
массив.
Вот это была быстрая сортировка.
Quick sort.
Теперь давайте посмотрим алгоритм quick select.
Сначала определение ввиду.
Значит пусть a1, a2 и так далее, an массив, давайте массив
чисел пусть будет, пусть b1, b2 и так далее bn его отсортированная
версия.
А то есть, какой массив будет после сортировки.
То есть, мульти множество чисел здесь такое же как
здесь, только они расположены в прядке возрастания.
Значит тогда через a с нижним индексом в скобочках i я буду
обозначать bt, то есть тот элемент, который после
сортировки стал бы item, а с нижним индексом круглые
скобочки i.
Это, собственно, то самое bi, которое было бы на этом
месте после сортировки, и я называю это it-порядковой
статистикой.
Называем it-порядковой статистикой.
Вот, очень простое определение, а с нижним индексом i в скобочках
это то число, которое после сортировки было бы на этом
месте, если бы мы посортировали.
Очень простое определение.
Ну и задача, по массиву, исходному вот этих ашек,
найти катую порядковую статистику, желательно без сортировки.
Значит, по массиву и числу k найти а с нижним индексом
k в скобочках, то есть катую порядковую статистику.
Ну понятно, можно было бы просто сортировать массив
и вывести катый элемент, но это как-то слишком скучно.
Вот, давайте мы бахнем алгоритм Quick Select, который сделает
нашу задачу за линейное время в среднем.
Алгоритм, собственно, Quick Select, реализуется очень похоже
на Quick Sort.
Начало идентичное.
Давайте мы выберем случайный пивот, вот у меня есть массив,
я выбираю в нем случайный элемент x, случайный пивот,
произвожу процедуру partition, ну и после нее мой массив
опять-таки разбивается на три куска.
Элементы меньше x, элементы равны x, элементы больше
x.
Давайте я обозначу количество элементов меньше, чем x через
a.
Так, ну а плохо, а все-таки занято у меня массивом,
ну давайте какой-нибудь пусть будет b, ладно.
Значит, здесь будет b элементов меньше, чем x, c элементов
равных x и d элементов больше, чем x.
Тогда, ну смотрите, замечание первое.
Если k меньше либо равно, чем b, то нам достаточно
рекурсивно запуститься вот от этого кусочка и искать
катую порядковую статистику.
Ну потому что понятно, что после сортировки вот этого
массива у меня здесь как-то переставятся элементы,
все эти x останутся на месте, и здесь внутри этого блока
тоже как-то переставятся элементы, поэтому если
k не больше чем b, то катая порядковая статистика останется
внутри вот этого блока, ну и она сохранится у номера
k.
Значит, мне достаточно запустить Quick Select на вот этом вот первом
блоке с параметром k.
Так, давайте я это назову как-нибудь a1, a2, a3, три куска
моего массива.
Значит, тогда пишу, запускаю Quick Select на первом куске
нашего массива, то есть на a1, с тем же самым параметром
k.
Вот, то есть у меня, ну как бы я сузился на этот массив
и еще опять катую статистику.
Вроде верно.
Дальше, иначе, если внезапно k попало вот сюда, то есть
k больше чем b, но не больше чем b плюс c, если выполняется
вот такое вот неравенство, тогда скажите, пожалуйста,
чему равен ответ?
Конечно.
А потому что, если k вот здесь, то после сортировки
k-та статистика будет вот здесь, внутри этого блока,
поэтому ответ равен x.
Ну и последний случай, если k больше чем b плюс c внезапно,
то ясное дело, нужно искать статистику вот здесь, потому
что даже несмотря на перестановки, которые получаются здесь
после сортировки, здесь будет b элементов, здесь будет
c элементов, а элемент с таким номером останется
внутри вот этого блока.
Поэтому его достаточно искать здесь.
Значит, я могу рекурсивно запустить процедуру quickselect
на вот этом третьем блоке, но здесь нужно немножко
аккуратнее написать, потому что мне уже внутри этого
блока нужна не k-та статистика, а какая?
k-b-c-t, спасибо.
Потому что, какая у меня номерация, раз, два, три,
и так далее, b, b плюс 1, и так далее, b плюс c, но поскольку
я эти два блока сразу отбросил, я понимаю, что мой ответ
не там, он где-то вот здесь вот.
Ну, значит, его номер я уменьшу на b плюс c, потому
что я вот этот кусок отбросил, вот эти два куска отбросил.
Значит, мне достаточно искать ответ вот здесь вот, только
у него номер теперь будет k-b-c.
Здесь алгоритм.
Ну, я могу только повторить.
Партишн понятно, что сделал?
Да, ну, обычный партишн, разделили массив на три
куска.
Дальше, пусть b, c, d, это размер этих кусков.
Если k не больше, чем b, то ответ вот здесь, в первом
блоке.
Значит, мне достаточно запуститься рекурсивной процедурой
и искать катую порядковую статистику вот в этом блоке.
Ну, потому что после сортировки катое число останется вот
здесь вот.
У меня вот эти как-то переставятся после сортировки.
Эти останутся на месте, эти как-то переставятся
внутри своего блока.
Значит, катое останется здесь.
Поэтому мне нужно искать ответ не во всем массиве,
а только здесь, с номером k.
Вот.
Если k внезапно попало вот сюда, от b плюс 1 до b плюс
c, то ответ это x.
Потому что у меня будет первая, вторая и так далее
бета-статистика здесь, с b плюс 1 по b плюс c здесь.
Поэтому надо вернуть x.
Если же k больше, чем b плюс c, то есть попадает в третий
блок, то мне нужно искать ответ в третьем блоке,
вот с таким индексом, ну, потому что мне нужна статистика
с номером k во всем массиве.
Но после удаления первых двух блоков, его номер уменьшается
на b плюс c.
Получается, что мне нужно в этом массиве, вот в этом
третьем блоке найти статистику с таким номером.
Мы же ищем номер, правильно?
Мы ищем значение.
Вот как я здесь x возвращаю число, вот найти a с индексом
k, то есть найти значение, которое было бы на k-том месте
после сортировки.
Вот.
Вопросы есть по алгоритму?
Почему мы не обладаем достаточным арсеналом?
Что?
Почему мы не обладаем достаточным арсеналом?
Ну, вот это утверждение, которое я пока не обладаю,
для которого мы пока не обладаем достаточным арсеналом
доказательств, потому что здесь какой-то тярвер.
У меня там происходит какой-то случайный выбор пивота.
Мне хотелось бы как-нибудь доказать, сколько в среднем
операций я сделаю.
Ну, идея на самом деле следующая, если вам интересно,
как это доказывается.
Идея в следующем.
Нужно просто сравнить, сколько раз между собой сравняются
вот такие два числа.
Потому что, когда вообще два числа сравниваются
вот в процессе нашего алгоритма, сравнение чисел внутри
массива происходит только во время партишна.
Когда я выбираю случайный пивот, случайный х, и делаю
партишн только в это время, у меня все элементы сравнятся
с х.
Ну и понятно более-менее, что время работы алгоритма
пропорционально к количеству сравнений, которые делает
ваш алгоритм.
Потому что здесь сложность только в партишне.
Я сделал партишн за линию от массива, потом развивал
три случая и перехожу рекурсивно в одну из двух частей.
Поэтому время работы практически в точности равно числу сравнений,
которые делает ваш алгоритм.
Ну и затем нужно просто оценить, с какой вероятностью
два числа, которые стояли бы на итом и нажитом месте
в массиве после сортировки, с какой вероятностью они
сравняются.
Вот с какой вероятностью эти числа сравняются?
Ну видимо, для этого вам нужно, чтобы вот эти вот
числа между ними никогда пивотами не были.
Как минимум.
Потому что если кто-то из них, вот какой-то х отсюда
побывал бы пивотом, то значит аи и ажи уже между собой
сравниться не могли бы, потому что я бы их сначала
посплитил с х, ну то есть я бы сравнил сначала их
с х, они бы пошли в разные стороны, один скажем сюда,
другой сюда, но я бы их уже между собой не сравнивал.
Ну и отсюда можно заключить, что вероятность того, что
два конкретных числа сравняться, это что-то в стиле, ну вот
такое видимо.
Потому что первый пивот, который выбирается на этом
отрезке должен быть этот или этот, но не один из них.
Ну и дальше если сложить, то как раз получится что
надо.
Идея примерно такая, но разворачивать не буду,
потому что как бы у нас нет тервера пока еще.
Такие дела.
Значит, утверждение без заказательства, этот алгоритм
работает за УАТН в среднем, то есть мат ожидания времени
на массиве длины n есть УАТН.
Другая задача, сортировка, а у нас все-таки не сортировка,
а поиск одного значения.
В идеале, представьте себе, я каждый раз выбираю внезапно
средний элемент, то есть тот элемент, который после
сортировки был бы центральным, тогда у меня будет вот где-то
х в середине, массив разбился примерно на два равных
куска, я запускаю скажем от одного из них, причем
здесь я потратил примерно n операции, согласны?
Чтобы сделать этот partition, я трачу примерно n действий,
примерно n сравнений.
Дальше я запускаюсь рекурсивно от вот этой половинки.
Сколько здесь элементов?
Ну примерно n пополам, то есть я оставляю только
этот массив, длины n пополам, в нем опять как-то волшебным
образом выбрал элемент примерно срединный, сделал
по нему partition, и это заняло у меня время примерно n пополам.
И потом опять перехожу в какой-то из двух блоков,
ну и так далее, размер каждый раз уменьшается в два раза,
это вот прям идеальный случай, если каждый раз внезапно
получается ткнуть ровно вот в этот центральный элемент.
Ну и эта сумма, да, вот эта вот сумма таких дробей сходится
к двум n, это линия как раз от m, да, нет-нет-нет, звездочка
еще это амортизация, по крайней мере, в моих обозначениях.
Я так и буду писать oatn в среднем, звездочку пока
не использую.
Не знаю, возможно в каких-то других источниках так, но
мне кажется, что обычно подписывают, то есть в среднем
или там амортизировано, обычно это всегда пишут
словами, поэтому я пока этих сокращений не использую.
Ну хорошо, какая-то магия утверждает, что она работает
А давайте сделаем алгоритм на базе вот этого всего,
который работает гарантированно за oatn, ищет катую порядковую
статистику, и мы докажем, почему он работает за линейное
время.
Ну и, соответственно, это нам тогда можно было бы
и не доказывать.
Ну вот, справедливо, если у нас действительно массив
чисел, да, а если числа очень большие, ну что-нибудь
такое.
Вот, давайте мы сделаем то, что называется детерминированный
quick-select, детерминированный quick-select, сейчас попрошу
быть очень внимательными, сейчас будет очень много
индексов, в которых надо не запутаться.
Как работает алгоритм?
Опять, задача та же, есть массив длины n, надо найти
катую статистику, катую порядковую статистику.
Я сделаю следующую магию, я разобью весь мой массив
длины n на блоке из пяти элементов, первые пять
элементов, еще пять элементов, еще пять элементов и так
далее.
Ну, если он не делится на пять, то последний блок
будет не целый, неважно, хочу, могу дополнить m какими-то
элементами бесконечностями вот здесь, вот тогда все
будет делиться на пять, если надо, можно считать, что
он делится на пять, если не надо, то последний блок
просто не полный.
Дальше сделаю следующее, я в каждом блоке найду медиану,
на всякий случай дам, медианой массива из n элементов называется
а с нижним индексом, ой, сейчас скажу, n пополам пойдет
не пойдет вверх, если округлить, то пойдет, вот так вот хочу,
n пополам округлить вверх, вот, это просто вот как раз
та самая центральная статистика, если я церстирую, что будет
на центральном месте, какой элемент будет в самом центре,
и, например, если у меня массив из пяти элементов,
а у меня сейчас все вот эти маленькие блоки будут
как раз из пяти элементов, представьте себе, у меня
массив а1, а2, а3, а4, а5, что такое вот эта его порядка
статистика, ну это видимо третья в точности, да, а3,
вот эта вот медиана, это а с нижним индексом 3 в скобочках,
то есть третья порядка статистики, вот какой элемент после
сортировки этого массива был бы третьим, это его медиана,
так вот, давайте я в каждом из этих маленьких блоков
возьму его медиану и обзову их б-шками, пусть это b1, это
b2, это b3, это соответственно b с индексом n делить на 5,
поскольку у меня n делить на 5 блоков, в каждом блоке
своя медиана, у меня получается n делить на 5 чисел, повторю,
давайте я это зафиксирую, что b и и это медиана этого
блока длины 5, я разбил на кусочке длины 5, в каждом
нашел медиану, обозначил за b и и, так, давайте я введу
здесь немножко обозначений, да, quick select что принимает,
он принимает массив а и число ка, пытается найти катую
статистику в массиве а, дальше сделаем внезапный рекурсивный
вызов, давайте скажем что x это quick select от массива
b с индексом n делить на 10, да, а вам больно, но мне все
равно, но я раз уж начал, я не хочу переделывать, да,
я его все еще описываю, подожди, он еще не завершился,
пока начало такое, что я разбил его на блоке из 5 элементов,
в каждом взял медиану, это я еще описываю, это еще не
завершится алгоритм, что, можно я сначала закончу
алгоритм, потом мы поймем зачем это так, почему это
так далее, так вот, возвращаемся, я рекурсивно запускаюсь
на массиве вот этом b, на массиве медиан пятерок
с индексом n на 10, ну понятно, я на самом деле в этом массиве
тогда просто найду опять медиану, потому что их там
n делить на 5, я выбираю статистику с номером n делить на 10,
это как раз медиан на массивы медиан по факту, согласны,
да, у меня много медиан, я из них выбираю медиану,
то есть опять центральную статистику с индексом n
делить на 10, а дальше делаю стандартную вещь, я запускаю
partition по x, ну и дальше добавляю вот те вот три строчки,
то есть по факту детерминированный quick select, все что делает,
это более умный выбор x, вот если раньше у меня x выбирался
случайно, равновероятно среди всех элементов,
то теперь я его считаю такой магией, я выбираю медианы
во всех пятерках, выбираю медиану в этом массиве медиан
и по нему делаю partition, ну а дальше все стандартное,
у меня массив разбился на три куска, меньше x равный
x и больше x, и дальше в зависимости от того, как соотносится
k с размерами этих блоков, этих корзиночек, я запускаюсь
либо сюда, либо сюда, либо возвращаю x, ну давайте я продублирую,
пусть это опять будет a1, a2, a3, пусть здесь размер,
опять b занято, пусть будет c, d, e, извините, дальше все
как обычно, если k не больше, чем c, тогда return, ну вот
это наш детерминистик quick select, пусть будет я его
так назову, от a1 с индексом k, то есть я в этом блоке ищу
катую статистику, если c меньше k, меньше либо равно
c плюс d, return x, ну и наконец, если c больше, чем c плюс d,
тогда return, детерминистик quick select, от третьего блока,
ну и опять-таки с исправленным индексом k-c-d, потому что
опять, поскольку я отбросил вот эти элементы, то катая
статистика стала k-c-d. Теперь описание алгоритма закончено.
Есть вопросы по тому, как устроен алгоритм? Давайте.
Выбираем медиану в каждом блоке, да, да, да. Так, ну давайте
я здесь тоже напишу, детерминистик quick select, я запускаю сам этот
же алгоритм, не тот рандомизированный, а вот этот новый, который
я сейчас строю. Да, извините. Ну, этот массив длины n-delete
на 5, я в нем выбираю статистику с номером n-delete на 10, то есть
я выбираю по факту медиану в этом массиве b. Да. И используем
теперь этот x в качестве пивота, а дальше все как
всегда. То есть у меня единственное, что поменялось, это вместо
использования случайного пивота, вот как раньше у
меня было, x случайный пивот. Я теперь говорю x это медиан
на массиве медиан пятерок, а вся остальная логика
также как в рандомизированном случае. Нет, ну вот это,
это медиан на массиве медиан, но это не медиана всего массива,
я такого пока не утверждал. Если мы докажем какую-то
оценку на то, сколько вообще работает детерминистик
quick select, тогда мы и поймем, вот сейчас мы займемся оценкой
8 точек. Вот так сработает. Давайте проверим, почему
работает, потом посудим, можно ли выбирать какое-то
другое количество. На самом деле это будет задача
в домашней, поэтому я вряд ли буду много про это
говорить. В каком плане бесполезен? Ну его также
можно написать, я про это тоже скажу чуть позже. Нет,
ну конечно нет. Тут хорошо только то, что мы избавляемся
от случайных битов. Если нам внезапно это сложно
делать, если мы не хотим использовать рандом, то вот
можно сделать так. Так, еще вопрос где-то был. Да.
Не скажу, секрет. Утверждение. Предъявленный алгоритм,
заметьте, он уже детерминированный, у меня нет никаких случайностей.
Так вот, я утверждаю, что такой алгоритм работает
за отэн. Доказательства. Сперва я хочу оценить,
насколько эффективный pivot x. Вот та медиана, массива
медиан пятерок, которую я выбираю, насколько это
хороший pivot. Вот я утверждаю, что x является статистикой,
ну порядковой статистикой, с номером от трех десятых
n до семидесятых n. Давайте сначала это поймем, почему
так. То есть, вот тот x, который я выбираю, он в каком-то смысле
достаточно хороший, потому что, что такое вообще плохие
пивоты с точки зрения partition? Плохие пивоты — это
те, которые очень близки к минимальному элементу
или очень близки к максимальному. Тогда partition мне почти ничего
не дал. Я разбил на что-то очень маленькое и что-то
очень большое. Ну и, скорее всего, запускаюсь от этого
большого куска. Поэтому x-ы, близкие к первой статистике
или к n-ой, они довольно невыгодны. Я почти ничего не сделал.
Так вот, я утверждаю, что тот x, который я выбираю в моем
алгоритме, как медиану массива медиан пятерок, такой x
будет весьма выгодный. Он не будет близок к единице,
хотя бы на 3 десятых n, и не будет близок к n, ну в смысле
к n-ной статистике, хотя бы опять-таки на 3 десятых n.
Почему? Картинка очень простая. Смотрите, давайте я
все вот эти блоки длины 5 нарисую 5 точечек в каждом
из них. То есть, вот эти 5 элементов. Здесь 5 элементов,
здесь 5 элементов, здесь 5 элементов, ну и так далее.
Дальше давайте представим виртуально, что я все эти
блоки длины 5 посортировал. Вот так вот я нарисую неравенство.
Значит, это один блок длины 5, второй блок длины 5 и так
далее. И каждый я посортировал. Заметьте, сейчас я доказываю
асимптотику алгоритма. Я могу в доказательстве асимптотики
делать что угодно. Сортировки в настоящем алгоритме не
происходят. Это не то, что делает наш алгоритм, это
то, что я делаю для доказательства утверждения. Этого не происходит
в настоящем алгоритме. Прошу заметить. Итак, вот
пусть я посортировал все вот эти мои пятерки. Ну понятно,
там 5 элементов, я их могу переставить так, чтобы они
возрастали сверху вниз. Дальше, я могу вот эти столбики
из 5 элементов теперь еще так переупорядочить между
собой, чтобы выполнялись вот такие вот неравенства.
А именно, чтобы у меня медианы возрастали слева направо.
Ну понятно, можно так сделать. Вот у меня есть n делить на 5 столбиков,
медиана в каждом, это вот как раз третий кружочек. Давайте я выполню
сортировку этих столбиков по третьему кружочку. В порядке
возрастания. То есть я могу их так переставить, чтобы у меня
третьи кружочки возрастали слева направо. Я их просто так
переставил, чтобы они возрастали. Тогда скажите, пожалуйста, где находится
x? В этой вот нашей, ну в центре, да. x это в точности центральный элемент
на такой картинке. Потому что, смотрите, вот повторюсь,
третьи кружочки в каждом столбце, это медианы соответствующих блоков,
медианы блоков длины 5. Теперь я их посортировал. И если я посмотрю на
центральную медиану, то есть, вот смотрите, у меня здесь n делить на 5 медиан,
если я смотрю n делить на десятую из них, да, медиану вот с таким
номером, то это будет в точности x. Ну, потому что x это медиан на массивы медиан.
Вот он, массив медиан, отсортированный. Понятно, что x там будет в центре.
Чудесно. Теперь мы на самом деле почти все сделали. Мы нашли x на этой картинке.
Теперь давайте оценим количество элементов меньше x и количество элементов
больше x. Ну, вот я утверждаю, что все, что здесь меньше x, все, что здесь больше x.
Ну, вроде понятно по цепочкам. Да, смотрите, вот у меня есть этот столбик.
Здесь при движении вверх у меня значения уменьшаются, здесь при движении влево у меня
тоже значения уменьшаются. То есть, я могу уменьшать медиану, потом в столбике дойти
до соответствующих элементов опять с помощью уменьшения. Поэтому все элементы в этом
прямоугольнике точно меньше x. Ну, не меньше либо равно x. Вот. То же самое здесь. При движении
направо я увеличиваю элемент, и при движении вниз, то есть я могу дойти до какого-то кружочка,
потом при движении вниз опять элемент только увеличивать. Поэтому здесь будет опять-таки хотя
бы вот этот прямоугольник элементов, который больше, чем x. Больше равный, чем x. Вот. Ну,
теперь осталось понять сколько их. Ну, их везде хотя бы 3 на 10. Потому что это
прямоугольник со стороной 3 и n делить на 10. Это прямоугольник со стороной 3 и n делить на 10.
Значит, я считаю, что я доказал вот это утверждение. Вопросы есть по вот этому утверждению? Пока не
иду вот сюда, пока просто вот это доказал. Понятно. Да, ну картинка просто. Супер. Ну,
более-менее все. Дальше анализ симптотики, сейчас мы его проделаем аккуратненько. Да, значит,
я доказал вот это утверждение. Теперь надо доказать все про время работы. Смотрите,
давайте я, как обычно, обозначу через t от n время работы на массиве длины n. Максимальное время
работы на массиве длины n. На массиве длины n. Тогда я утверждаю, что выполняется следующее
соотношение. t от n не больше, чем t от n делить на 5, плюс t от 7n делить на 10, плюс o от n.
Откуда это все взялось? Давайте проанализируем, как работает алгоритм на массиве длины n. Вспоминаем,
что он делает первое. Он разбивает массив на блоке по 5 элементов и в каждом находит медиану.
Я утверждаю, что это делается за линейное время. Потому что у меня линейное количество блоков,
каждый блок константного размера. Чтобы найти в блоке константного размера третью порядку
статистику, понятно, можно обойтись от 1 действий. Просто у вас есть массив из 5 элементов,
как-нибудь уж вы, наверное, в нем третью статистику найдете за от 1, хоть там за 100 действий,
но главное, что за от 1. Тем самым вы нашли массив b, а массив медиан всех пятерок. Это от n пока что.
Что делаем дальше? Запускаем тот же алгоритм, рекурсивно запускаем себя на массиве длины n
делить на 5. Вот вам первое слагаемое. Давайте напишем, что это рекурсивный запуск нашего
детерманистики quick select на массиве b. На массиве медиан пятерок. Напомню, время меряется от
размера массива. Это номер порядковой статистики. А я именно от размера массива считаю. Дальше. Дальше
partition. Но мы знаем, что partition работает еще за линию, поэтому здесь вот в o от n еще константа
как-то увеличится. Но она там съедена, она там ущетена. Ну и наконец проверка трех случаев и
рекурсивный запуск, в худшем случае рекурсивный запуск, в одну из частей. Но при этом эта часть,
я утверждаю, обязательно имеет размер не больше чем 7 на 10. Потому что наш pivot вот такой хороший.
Слева от него и справа от него хотя бы 3n на 10 элементов. Значит, ну давайте картинка. Вот у меня
был массив, я выбрал некий pivot, который после сортировки имеет индекс от такого до такого.
Значит, ну после того, как я запускаю рекурсивные, то есть вот эти два запуска, я запускаюсь либо для
всех элементов меньше x, либо для элементов больше x. Но я знаю, что их везде не больше чем 7n на 10.
Потому что x это статистика, которая от минимум отстает хотя бы на 3n на 10. Значит, больше него
элементов не больше чем 7n на 10. И от максимум отстает тоже не больше, в смысле хотя бы на 3n
делить на 10. Значит, меньше него тоже элементов не больше чем 7n делить на 10. То есть в этих частях
массива элементов не больше чем 7n делить на 10, потому что x вот такой. Отсюда получается такая
рекуррента. Согласны? Вот, ну все, теперь надо просто аккуратно проанализировать и доказать,
что O от n является решением такой рекурренты. Значит, общий совет. Значит, как такое делать?
Что делать в таком случае? Ну, во-первых, нам надо раскрыть определение O от n и сказать,
что это не просто n на какую-то константу, которая где-то там есть. А вот давайте конкретную какую-то
С возьмем. Смотрите, вот это вы поняли откуда? Нет-нет-нет, вот это определение T от n. А вот это
следует из того, как устроен наш алгоритм. Я вот объясняю, что мы сначала берем медиану массива
пятерок, это вот столько времени занимает. Потом делаем partition, это вот столько времени
занимает. Потом запускаемся рекурсивно от одного из кусков длины не больше чем 7n на 10. Отсюда вот
это слагаемое. Получается, что на T от n верно вот такое, для T от n верно вот такое рекуррентное
соотношение. Это доказано. Сейчас мы будем понимать, почему отсюда следует, что T от n это линия. Так вот,
давайте раскроем вот это O от n. Раз здесь O от n, значит существует конкретная C, некоторая, что T от n
не больше чем T от n делить на 5, плюс T от 7n делить на 10, плюс Cn. Ну потому что O от n на O от n это не
больше чем Cn всегда для кого-то C. Вот, дальше давайте я, чтобы никого не запутывать, докажу,
что T от n не больше чем 10Cn для любого n. Ну, база как-нибудь антривиальна. База n равна единице,
уж как-нибудь там разберемся. Если массив из одного элемента, то вообще даже делать ничего не надо,
можно просто вернуть катовую статистику, в этом случае k равна единице. Понятно, что T от 1 не
больше чем 10C на 1. Ну, можно считать, что C достаточно большое, если надо. Короче,
база вот в таких реквинентах всегда как бы почти автоматически выполняется. Ну, переход. Значит,
пусть вот это соотношение верно для всех меньших n. Тогда давайте докажем для n. Пока что все,
что я знаю про T от n, это вот это. Давайте напишем. Пока переписал. Дальше применим
предположение индукции к вот этим двум слагаемым. Поскольку здесь аргумент меньше чем n, значит для
них справедливое предположение индукции, я могу написать, что вот это вот не больше чем 10C умножить
на аргумент, это не больше чем 10C умножить на аргумент. Давайте так и напишем. Это не больше
чем 10C на n делить на 5 по предположению индукции, это не больше чем 10C умножить на 7n делить на 10.
Вновь по предположению индукции. И что бы вы думали будет, если мы все это сложим, верно 10Cn.
Вроде не обманываем, да, потому что здесь будет 2Cn, здесь будет 7Cn, здесь еще 1Cn. Доказали.
Доказываем по индукции. Доказываем по индукции. Считаем, что для всех меньших n это верно, то есть
если n-штрих меньше чем n, то для n-штрих верно это соотношение. Теперь, чтобы доказать это для T от n,
я переписываю то, что мне известно про T от n, оцениваю оба вот этих слагаемых через
предположение индукции и получаю то, что мне нужно в точности 10Cn. Вот эти-то? Ну как,
предположение индукции просто. Я считаю, что вот это вот верно для всех меньших n. Ну то есть
формально, да, если k меньше чем n, то T от k не больше чем 10Ck. Это предположение индукции,
но я вот тут написал, тут написал. То есть T для меньших аргументов не больше чем 10C на аргумент.
Вот здесь не больше 10C на аргумент, не больше 10C на аргумент, просто предположение индукции.
а дальше складываю, получаю внезапно 10 цен. Да, конечно, но константа 10 так подобрана, чтобы
здесь было не больше 10 цен. Если бы я взял, например, 11 цен, у меня бы здесь было чуть
меньше, чем 11 цен, я бы мог его сверху оценить 11 ценами. Вот я и сказал, я здесь специально написал
константу 10, чтобы не вводить очередное там какое-то, а, большое, да, какую-то константу,
потом ее подбирать, я сразу вам засполилировал ответ, с ним доказал. Да, 10 специально подобран.
Ну, например, да. Что там, кто что-то заметил? Ну, да, да, да, да. Я услышал вопрос. Это,
оказалось, все понятно? Можно дальше идти? Давайте. Сейчас я отвечу на вопрос, я помню его, да. Да,
на нем рекурсивно запускаем тот же алгоритм. Ну, давайте так, то есть формально, если там,
не думая отвечать на ваш вопрос, я могу сделать так. Если n не больше, чем 10, то, наверное,
на массиве длины 10 я могу найти любую статистику, которую меня попросили. Значит, давайте,
я мой алгоритм исправлю так, ну, прям вот, как работает DQS, он принимает массив длины n,
если n не больше, чем 10, сделай что-нибудь тупое и найди катую статистику, а иначе делай вот это.
Ответил? Опять, мне не важно поведение на маленьких n, я рассматриваю только на бесконечности, да, в этом
весь пафос вообще всех алгоритмов, что нам не важно работа на маленьких n, не важно только на
бесконечности. Так же и здесь, да, для маленьких я могу что-то отдельно развивать, и вот здесь,
как бы, я считаю, что все корректно индексам. Итак, отвечаю на вопрос, который мы задали минимум
четыре раза, почему пять, а не другое число? Правильно это, потому что работает. Вопрос,
с какими другими числами сработает. Ну вот, в домашней будет задача описать все вот эти вот
числа, которые можно поставить вместо пятерки, так, чтобы это работало. Интуиция. Ну, наверное,
естественно, выбирать нечетное вот это число, да, нам не интересно брать 4, 6 и так далее,
потому что ну там сложно медиану просто определить. Да, я выбираю пятерку нечетной, чтобы можно было
взять медиану в этом блоке. Это тривиальный аргумент. Дальше вопрос, почему нельзя бить на блоке длины
1 или 3? Но бить на блоке длины 1, это как-то совсем глупо, вы вообще ничего не сделали, да? Вот, бить на блоке
длины 3, вот, типа, оказывается, что если вы будете бить на блоке длины 3, то там будет плохая симптотика.
То есть, грубо говоря, если вы вот это все распишете, то там будет, ну, короче, оно не будет сворачиваться в
вот-эн. Вот тройки мало. Если вы с тройкой это сделаете, то здесь будут как бы вот, то есть, эти штуки,
они так внезапно работают для пятерки, что это все сворачивается в вот-эн. Вот для тройки не сработает.
Получается, пятерка как бы, ну, минимальный кандидат, для которого все подходит. Вот вам и ответ.
Можно больше, да. Можно больше, но как бы это уже вряд ли осмыслено, потому что чем больше вы
выбираете размер блока, тем сложнее вам искать медиану в массиве вот этого блока. Окей? Вопросы?
Ответы. Хорошо. Еще раз? Ну, конечно, ну, как бы с точки зрения практики, наверное, если вы возьмете
вместо пятерки там 21 и будете искать медиану в, ну, короче, у вас константа просто вырастет,
скорее всего, но это не точно. Так, ура! Все, мы нашли, значит, катую статистику за линейное время.
Тривиальное следствие. Можно написать детерминистик. Quick sort.
Основанная той же идее, но уже без использования случайных бит. Как это делать? Как?
Можно просто медиану выбрать. Да, значит, работа следующим образом. Вместо того, чтобы выбирать пивот
случайно, давайте выберем его детерминированно медианой. Благо мы уже написали линейный по времени
алгоритм, который находит нам катую статистику для любого k. Ну, то есть, какую k мне сказали,
такую я найду. Я взял и нашел в моем массиве медиану. Дальше все, как обычно. Partition по x.
У вас массив разбивается на три куска. Ну, давайте вот так напишу. Сколько-то x, меньше x и больше x.
За счет того, что у вас x это медиана, у вас вот здесь элементов не больше чем половина и здесь
элементов не больше чем половина. И это прям самый идеальный случай, лучшей на что можно надеяться.
Когда вы выбираете в качестве пивота медиану, у вас массив разбивается на вот такие два куска размера
не больше чем n пополам. Ну, а значит здесь работает такая рекуррента. А мы знаем, что ее решением
является n log n. Эту картинку я точно когда-то рисовал. Если у меня получается делать partition
с медианой всегда, то есть с элементом, который центральный после сортировки, то у меня время
работы такого алгоритма точно будет n log n. Потому что я каждый раз по факту бью массив на два куска
и рекурсив на их сортирую за время t от n пополам. То есть у меня есть такая рекуррента и мы вроде
уже доказывали, что это вот n log n, верно же? Ну вот, все. Значит, если просто вместо случайного пивота
выбирать медиану с помощью вот того алгоритма, то вот, пожалуйста, детерминированная сортировка
n log n. Еще одна. Вот. Так, ну хорошо. Это сделали.
Так, выдыхаем. Идем дальше. Переходим к сортировке чисел непосредственно. Сортировка чисел.
Значит, до этого момента все сортировки, которые мы рассматривали, основывались исключительно на
сравнениях. Мы не пользовались информацией о том, что на самом деле за элементы лежат в массиве.
Все, что мы делали над элементами, это только их сравнивали и переставляли между собой. Так вот,
давайте теперь вспомним, ну или, по крайней мере, рассмотрим случай, когда мы сортируем именно числа.
Ну и желательно, числа не очень большие. Значит, самая простая постановка такая. Давайте в ноль
индексации теперь. Надо оно мне. Вот есть массив чисел. Представьте, что все элементы — это целые
числа из множества от нуля до k. Ну где k тоже не очень большой. Представьте, что там n и k порядка
миллиона что-нибудь. Надо сделать сортировку. В такой постановке это вроде совсем просто. Давайте
самый простой алгоритм сортировки. Называется сортировка подсчетом. Делается очень просто.
Давайте мы сначала пройдемся по массиву и посчитаем, сколько раз каждое число встретилось. Давайте
заведем какие-нибудь контейнеры, точнее, какие-то счетчики. Knt от x — это сколько раз встречается
число x в нашем массиве. Сколько раз x встречается в A, в исходном нашем массиве. Но это очень легко
сделать. Давайте заведем просто массив с индексами от нуля до k, заполним его нулями, пройдемся по
массиву. Каждый раз, когда видим число, увеличиваем количество его вхождений. Это тривиально. А дальше
просто, если у меня для каждого числа написано число вхождений, давайте я выведу каждое число
столько раз, сколько оно в массиве встречается. То есть для всех x от нуля до k, там скажем для i от
одного до knt от x, принт x — такой интеллектуальный алгоритм сортировки. Вроде работает.
Мы идем по всем возможным числам, которые могут быть в массиве в порядке возрастания,
и печатаем каждый из них столько раз, сколько оно в массиве присутствует. От одного до knt от x идем
в цикле, и каждый раз печатаем x. Понятно все? Массив. У меня же все числа от нуля до k.
Еще раз, к knt я могу просто так объявить. Knt — это массив размера k плюс 1, который заполнен
изначально нулями. Я сразу сказал, что k небольшое. Если k небольшое, то я могу завести такой массив,
занулить его и дальше вот так пройти и все сделать. Очевидно, что такой алгоритм работает за n плюс k.
На что тратится это время? На считывание массива от n, на создание массива knt от k, на опять-таки
прохождение по всему массиву и увеличение количества вхождения каждого x. Еще от n,
потому что я по этому массиву прошел. Ну и вот здесь еще от n плюс k, потому что я для всех чисел
массива печатаю сколько раз оно входит. Поэтому n плюс k. Повторю, это адекватно,
если это что-то адекватное, то есть если k там миллионы, возможно десятки миллионов,
тогда это хорошо. Так, что-то еще хотел сказать? Забыл. Да, могут быть. Сейчас, момент,
что-то еще хотел сказать. Ну ладно, бог с ним. Так, хорошо. Теперь давайте модифицируем эту
сортировку так, чтобы она стала стабильной. Это определение, что такое стабильная сортировка.
Ну вообще говоря, формально мы знаем, что такое сортировка. Это поиск перестановки входных
элементов так, чтобы они стали в порядке возрастания. То есть формально обычная
сортировка это поиск перестановки из 1, 2 и так далее n в 1, 2 и так далее n такой,
что ассо сигма 1 не больше ассо сигма 2 и так далее. Вот где а изначальный массив. Так вот,
стабильность, это когда равные элементы сохраняют свой относительный порядок. Давайте я сначала
на примере, потом формальное определение как не допишем. Вот представьте себе такой массив.
Ну понятно, его сортировка это 1, 1, 1, 2, 2, 3. Так вот, я хочу, чтобы сортировка была стабильная,
чтобы равные элементы сохраняли свой относительный порядок. То есть, что вот те 3 единицы,
которые идут в начале, вот эта соответственно вот этой, вот эта вот этой, а эта вот этой. Дальше
идут двойки, и они тоже сохраняют свой относительный порядок. Сначала вот эта двойка,
самая левая, потом вот эта левая, потом вот эта двойка, следующая за ней. Ну и тройка вот такая.
Формально. Мне нужна такая перестановка, что, ой, не разу написал это формально,
мне кажется, я умру сейчас. Сейчас, сейчас, потому что sigma это то, куда встает, нет, момент.
Сейчас, нет, недостаточно. Сейчас, sigma 1, кто-то встал на первое место.
Вот нет, мне так не нравится.
Нет, нет, вы не так говорите, потому что sigma и это не то, на какое место встал этот элемент. А то,
кто стоит на этом месте теперь? Видимо, надо sigma в минус первый. То есть, формально, конечно,
надо писать так. Потому что это не то, на какое место встал этот элемент, а скорее кто встал на
такое-то место. Поэтому мне нужно, чтобы место, на которое встало и, было меньше местное,
которое встало ажи. Так правильно, как думаете? Да, да, не похоже. Сейчас, дайте я еще 30 секунд подумаю
и пойдем дальше в любом случае. Сейчас, подождите, пожалуйста. Сигма 1, кто встал на первое место.
Сигма в минус первый от 1. Да, да, все правильно, потому что, смотрите, потому что на самом деле
sigma в минус первый от какой-то позиции p это место, куда встало число ap. Куда встало ap.
Тогда вроде все правильно писал. Что значит тот индекс, который был? Это тот, кто перешел на…
При условии, что ai равно ажи. Ладно, в общем, что-то, извините, формально вроде так, можно,
наверное, по-другому. Еще раз, главное, чтобы все поняли качественно, что происходит. Я хочу,
чтобы равные элементы, если один был левее другого, то после сортировки первый будет опять-таки левее
второго. Сигма – это перестановка, в каком порядке я представляю элементы. Сигма 1 – это то число,
которое встало на первое место. Сигма 2 – это то, которое встало на второе место. Сигма n – это то,
число, которое встало на n-ое место. Да, это изначально номер элемента, который встал на такое-то место.
Вот, значит, минус 1 – обратная перестановка. Ну, это вот обратная перестановка. Это тот,
кто встал на… Точнее, если сигма от двух – это тот, кто встал на второе место, то сигма в минус
1 и это то… Ну вот, сигма в минус 1 от P – это место, куда встало АП. Ладно, еще раз. Нет,
сигма от P – это кто встал на это место. А здесь я спрашиваю, куда пошло АП. Ладно, все, еще раз,
давайте, я не хочу здесь задерживаться. Если вы не поняли, давайте на качественном уровне поймете.
Стабильная сортировка такая, что если два числа равны, то после сортировки они
сохраняют относительный порядок. Вот как здесь вот были две единицы, после сортировки это пришло
сюда, это сюда. Вот мне именно что нужно, если это было левее этой единицы, то они сохранили свой
порядок, что это осталось левее, чем это. Все. Если формально не понятно или если не согласны,
записывайте так, как правильно. Вот, теперь давайте напишем стабильную сортировку под счетом.
То есть, я хочу не просто оба как переставить мои элементы,
да, ну потому что в том алгоритме я вообще не слежу за тем, в каком порядке шли, вот если там
несколько равных было, я вообще не слежу за тем, в каком порядке они шли. Я просто их куда-то
сваливаю вот в одну кучу и просто их печатаю. Я даже не знаю, на каком месте все они были изначально.
Вот, давайте это исправим. Начало будет такое же. Давайте я здесь, наверное, напишу все-таки немножко
кода. Давайте я заведу массив knt из нулей, пройдусь по всем элементам массива и увеличу количество
вхождений числа ai. На плюс плюс число это увеличение числа на единичку. Вот, сейчас в массиве knt лежит
количество вхождений каждого числа, ну также как вот здесь. knt от x это сколько раз x встречается
в массиве a. Дальше я сделаю следующую магию. Для всех i от 1 до k я к knt i прибавлю knt i-1.
Вот. Все элементы до k. После этого, смотрите, давайте поймем, что теперь хранится в массиве knt
после этого цикла. Ну к knt 0 у меня осталось количество нулей, потому что к knt 0 здесь не
меняется. Дальше к knt 1 я прибавил к knt 0. То есть теперь в knt 1 лежит количество нулей плюс
количество единиц. Дальше, что такое в knt 2? к knt 2 я прибавил новое значение к knt 1. К knt 2
увеличил на knt 1. В knt 1 лежит количество нулей плюс единиц. Значит в knt 2 теперь лежит количество
2 к нулей единиц. То есть всех не больше чем 2. Ну легко понять, что после выполнения этого цикла,
давайте здесь подпишу, что knt от x это количество числа не больше чем x. Ну потому что как бы я
вот посчитал сколько их всего и протолкнул вперед. То есть каждое x я протолкаю во все
больше. Тем самым я его учту во всех больших аргументах, во всех больших индексах. Вот.
Прелесть в том, вот зря я перешел все-таки в ноль индексации, вот здесь не больше всего удобно
один индексация. Ну ладно. Смотрите, если бы я использовал один индексацию, то у меня элемент,
скажем с номером knt от x в один индексации должен был быть самым правым x. Потому что смотрите,
вот у меня есть knt от x. Что такое knt от x? Это количество элементов не больше чем x. Значит,
элемент с номером, вот если я возьму один индексацию на время, элемент с номером knt от x,
вот здесь вот расположены все элементы не больше чем x, значит здесь расположен самый правый x.
Самый правый x. Ну если x вообще конечно существует. Потому что вот здесь вот на этих позициях должны
располагаться все числа не больше чем x, потому что их вот ровно столько. Самое правое из них
должно быть самым большим, самым правым числом, то есть самый правый x. Поэтому теперь я буду идти по
моему массиву исходному справа налево и x класть вот в эту ячейку. Да, ну вот я уточнил,
если x вообще существует. Если не существует, то конечно там другое число. Сейчас учтем, не переживайте.
Вот. Мораль такая, что я хочу класть, вот если я теперь пойду по исходному массиву справа налево
и вижу x, то я его хочу поставить на позицию knt от x. Давайте ровно это и сделаем. Значит,
идем по массиву справа налево, в порядке убывания индекса. Вот пусть x, давайте обозначим x это
текущее число, я хочу поставить его на место knt от x. Да, вот это вот самый правый из увиденных
x, я хочу поставить его на место knt от x. Ну, то было в 1 индексации, в 0 индексации, это будет что-то
типа, давайте напишу ans knt x минус 1, да, потому что если мы хотим в 0 индексации жить, то мне
нужно единичку вычесть. Сюда поставить вот это самое x. Вот. И нужно уменьшить knt от x на единичку,
а минус минус knt от x, то есть уменьшаем knt от x, чтобы следующий встреченный x встал не на то
же самое место, а на место на единичку левее. Потому что если у меня в массиве есть несколько x,
я иду по массиву справа налево, это поставил на место knt от x, это на место knt от x минус 1,
это на место knt от x минус 2, потому что каждый раз, когда я поставил x, я уменьшаю позицию,
на которую надо поставить x. То есть теперь в каком-то смысле можно понимать, что knt от x это
не количество, а позиция, куда надо ставить очередной x. Ну вот я просто иду справа налево,
ставлю. Вот. В конце, давайте вот после этого, теперь ans 0 и так далее ans n-1 содержат стабильно
отсортированную версию A. Вот такие дела. Сейчас все будет, вы опять сбегаете вперед. Вот пока,
сейчас будем применять. Еще вопросы есть? Давайте. X это текущее значение, мы знаем,
куда его надо поставить, ставим туда. Да ans это ответ.
Нет-нет-нет. Смотрите, вот если у меня есть несколько x, я сначала увижу этот,
поставлю его на место knt от x минус 1, потом уменьшу это число на 1, потом буду идти справа налево,
увижу этот x, опять тот же самый x. И в значении knt хранится правильное место для него, потому что я
его уменьшил. Опять ставлю, куда надо, уменьшаю. Дохожу до него, опять ставлю, куда надо, уменьшаю.
То есть у меня как бы вот эти x поставятся подряд справа налево, начиная с позиции knt от x.
Ну конечно, да. Вот. Зачем это надо? Действительно, пока непонятно зачем, у нас все так как бы были
числа, мы их переставили и получили опять отсортированную версию. Зачем это надо один?
Да. А что такое просто стабильная сортировка? В смысле просто сортировка подсчетом? Ну тем,
что она стабильна. Вот это была просто або какая сортировка, теперь я сделаю ее стабильной. Сейчас
я покажу зачем может быть нужна стабильная сортировка. Пример. Сортировка пар чисел.
Представьте себе, что элементы вашего массива это не числа, а пары чисел. Давайте я напишу
формально. У вас есть массив пар а0, b0, а1, b1 и т.д. аn-1, bn-1. Ну и опять все значения это какие-нибудь
маленькие целые числа. Все аi и bi целые числа от 0 до k. Опять хочу отсортировать как-нибудь
за быстро. Давайте я сделаю следующее. Так, вроде справа налево надо сделать. Шаг 1. Стабильная
сортировка по b. Шаг 2. Стабильная сортировка по a. Конец. И здесь важно, что она стабильная.
Давайте пример какой-нибудь нарисуем. Такая пара, такая пара. Сейчас, одну секунду. Такая
пара. Такая пара. Ну еще что-нибудь. 2, 3 нарисую. Да, вопрос? Пара сравнивается классически как,
да, это я не сказал, но давайте напишу формально. Значит пара x, y меньше пары x' и y'. Если только
если верно одно из двух. Либо x меньше, чем x', либо они равны, но y меньше, чем y'. Ну так всегда так.
Векторы так сравниваются в плюсах. Классическое сравнение пар. Слева направо, лексиграфически
сравнение это называется. Компоненты сравним слева направо. Впервые когда находим неравенство,
знак неравенства между первым несовпадением совпадает со знаком сравнения пар. Вот.
Ну вот давайте такой пример посмотрим, что происходит. Я сначала сортирую по b. Давайте как-то
они переставятся. Сначала будет видимо вот это. То есть первый шаг. Сортировка по b. Вот это
минимальная. Дальше 1,3,2,3 и вот это 2,4,1,4. Шаг второй. Сортировка по a. Так, эти остаются, причем
стабильная сортировка по a. Эти два остались на месте. Это переместилось сюда, потому что единичка
первая. Здесь осталось 2,3,2,4, потому что стабильно. Относительный порядок равных
элементов. Сейчас равенство подразумевается по a. Относительный порядок элементов не изменился.
Ну как видим, вроде реально посортировалась. Неважно, можно просто сортировку, это правда.
Ну я уже для красоты написал. Почему это работает? Смотрите, после завершения первого этапа у меня все
пары отсортированы слева направо в порядке возрастания b. Что я делаю потом? Я сортирую по
a. Понятно тогда, что если у двух пар были разные значения a, вот пусть скажем было x и x' и одно
меньше другого, тогда понятно, что после второго шага они будут правильно расположены между собой.
Поскольку у меня сейчас происходит сортировка по первому аргументу, по a, по первой компоненте.
Значит после этого шага, понятное дело, элементы с разными ашками у меня будут правильно
отсортированы между собой. А раньше тот, кто меньше. Единственное вопрос, что происходит с теми ашками,
которые равны. Так вот, поскольку сортировка стабильна, то те пары, у которых ашки совпадают,
сохранят свой порядок по сравнению с тем, что было после первой итерации. То есть они будут
сравнены как раз по b. Потому что после первой итерации у меня все пары отсортированы в порядке
возрастания по b. И получается при равных a я оставляю этот порядок, то есть при равных a я их буду
как бы сравнивать по b, потому что они отсортированы после первого шага по b как раз. Вот, поэтому это
корректная сортировка. Еще раз? Да, можно и нестабильно, это правда. Вопросы? Да, ну это простые вещи.
Сортировать по счетам даже стабильно мы умеем, вот как бы алгоритм только что предъявлен.
Ну смотрите, у вас есть n элементов, у вас массив из n элементов. При стабильной сортировке вы
смотрите только на конкретный компонент пары. Здесь на b, здесь на a. Вы игнорируете второй
компонент. Ну и дальше вот так вот сортируете. Ну да, поэтому вы делаете две разные сортировки,
все правильно. Здесь вы игнорируете первый компонент пары, здесь вы игнорируете второй
компонент пары и сортируете так, как будто бы этого второго компонента просто нет. Ну и тогда
работает вот обычная сортировка по счетам стабильная. Я проговаривал, что в случае
совпадения a-шек вторая сортировка не поменяет их порядок, потому что она стабильная, стабильная
по a. Значит, в случае равенства они сохранят свой относительный порядок после первого шага,
то есть если две a-шки равны, то после второго шага их порядок такой же относительной,
такой же, как был после первого шага, потому что она стабильна. Но они же посортированы
после первого шага по b-шке, после первого шага они отсортированы в порядка разр peaks по b-шке,
Значит, если две ашки равны, то они вот здесь вот были в том же порядке, в котором надо, в порядке
возрастания по b, потому что мы сначала сделали сортировку по b, а поскольку вторая стабильна,
то их порядок не изменится. Как вот здесь, смотрите, вот у меня было 1,2, 1,3. Они между собой по бшке
правильно упорядочены, ну потому что первый шаг такой, что у меня возрастание по b идет,
потом я их стабильно сортирую по а, но если их значения равны, то я сохраняю их позиции просто.
Тут, наверное, интереснее было бы увидеть вот это, например. Вот это переходит сюда, а это сюда.
Их относительный порядок сохраняется, потому что сортировка стабильная, ну и это правильно,
потому что сначала должно быть 1,2, потом 1,4. И именно из-за стабильности у меня получается
корректность. Если у нас есть вообще quicksort, то можно вообще этого не делать? Нет, все-таки
лучше сортировку почетом делать. Если k маленькая, смотрите, если k маленькая, то мы на все про все
потратили вот столько времени. Наверное, это лучше там, ну зависит, конечно, от n и k, но обычно это
лучше, чем n log n. Как это можно еще использовать кроме сортировки пар? Можно это использовать в так
называемой паразрядной цифровой сортировке. Паразрядная цифровая сортировка. Вот, мы сейчас
осмотрим то, что называется LSD, Lift Significant Digit. Значит, как работает? В чем была проблема
сортировки под счетом просто чисел? В том, что числа могут быть большие. Если k там 10 в 9,
то нам не хочется заводить массив размера 10 в 9. Представьте, если k 10 в 18 или даже еще больше.
Так вот, давайте мы представим все наши числа как строки в десятичной системе
числения. Ну или там можно было бы и в двоичную, давайте в десятичную. Значит, каждое число,
не знаю там, в 128, например, это число вот такого вида, например, в десятичной системе
числения. Если числа разные длины, то я могу их добить нужным числом нулей слева, чтобы они все
были одинаковые длины. Я сейчас буду считать, что все числа будут у меня одинаковые длины в
десятичной системе числения. Если что, я могу нулями слева добить. Тогда ее очень простая. Давайте
мы, то есть вот у меня есть много таких чисел, описываемых как строки. Давайте я сначала их
отсортирую по последней цифре, потом стабильно по предпоследней, потом стабильно по предпоследней
и так далее, вплоть до самых старших битов, точнее вплоть до самых старших разрядов. Я утверждаю,
что у меня получится правильная сортировка. Логика ровно такая же. Смотрите, что происходит
после последнего шага. После последнего шага, когда я сортирую самые старшие разряды, у меня
разные разряды, то есть, если у двух чисел различные первые разряды, они точно встанут
как надо. Ну, например, если здесь было два, а здесь три, то после самой последней сортировки это
будет раньше, чем вот это. Потому что так работает сортировка под счетом. Вот это будет раньше,
лучшеerness чем это. Но, если же было какое-то
число с одинаковом, ну, точнее, старшим разрядом,
то поскольку последняя сортировка стабильна, то
они сохранят свой порядок после вот этой предпоследней
сортировки. То есть, они, наследуют свой порядок
от вот этих кусочков. От всего, кроме старшего
разряда. Ну ровно так числа и сравниваются. Если старшие
разряды различные, то больше
то, у кого больший разряд, вот этот вот старший. Если
они одинаковые, то я как будто бы игнорирую старший
разряд и сравниваю опять-таки все, начиная со второго разряда.
То есть так можно сравнить большие числа за логами?
Да, типа того.
Так, понятно все здесь?
Просто справа налево сортирую по разрядам.
Стабильно каждый раз.
Ну и соответственно, давайте напишем, что если все числа
а0, а1 и так далее были опять-таки целыми от 0 до k,
то этот алгоритм работает за...
Ну, я напишу, видимо, n до лог k,
но вот я здесь уточню, что по основанию 10.
Пока вот я по вреднейшему уточню, основание 10.
Но потому что у меня n-чисел, я запускаю вот столько сортировок,
потому что у меня разрядов ровно столько,
здесь число гриф мотка, столько разрядов,
сколько разрядов, столько у меня будет
стабильных сортировок подсчетом.
Ну и каждая сортировка подсчетом работает за n.
Точнее за n плюс 10, давайте я еще более повыпендриваюсь,
напишу, здесь n плюс 10.
Потому что сортировка подсчетом работает за количество чисел
Ну, вот это вот k, да, плюс наибольшее значение числа.
Да.
Когда мы ставим, что 0,5 в целом число для объектов,
для объектов, которые в штрафнении проявляют себя одинаковыми,
мы же обязаны эти объекты сохранять,
потому что мы можем просто в каунт сохранять,
а потом вот так же.
Но смотрите, в каунт я на самом деле не сохраняю объекты,
я сохраняю количество объектов только.
И вот здесь я когда делаю, смотрите, я иду справа-налево по массиву,
то есть у меня массив исходный сохранен.
Я считаю, на какое место надо его поставить,
и ставлю его туда.
То есть формально здесь надо было написать...
Да, здесь все правильно написано, более-менее.
То есть именно я смотрю на элемент,
я смотрю на нужную его цифру, на очередную его цифру,
знаю, где его надо поставить, ставлю его туда.
Вроде все нормально.
Что?
Ну, потому что сортировка под счетом, напоминаю,
если бы у меня были все числа от 0 до k,
я бы просто одну сортировку под счетом сделал,
то это было бы n плюс k.
Ну, потому что мне нужно завести массив размера k,
ну и так далее.
Но здесь k это 10, потому что у меня значение в каждом разряде от 0 до 9.
Поэтому n плюс 10.
Ну, это вот, собственно, непосредственно
именно паразрядная сортировка.
Понятное дело, что можно это немножко улучшить,
и, например, сортировать не по циферно,
а, например, блоками из нескольких цифр.
Там по 4, по 5, по 6 цифр вполне спокойно можно сортировать.
Ну, потому что вот здесь вот эта вот плюс 10,
понятно, это несодержательная добавка,
а если бы я сортировал не по циферно,
а, ну скажем, по миллионно,
то есть я выбираю 6 разрядов и по ним сортирую,
тогда здесь бы у меня было плюс 10 в шестой,
это не очень страшно,
но зато здесь логарифм значительно уменьшается,
будет логарифм по основанию 10 в шестой.
Потому что теперь у меня количество сортировок,
которые я делаю,
это логарифм k по основанию того,
какое здесь максимальное значение числа берется.
Ну, дальше уже как бы ваша фантазия.
Сколько вам, если вам хочется это сделать,
то вы можете сами подобрать там,
ну да, можно менять систему числения, пожалуйста.
Можно выбирать правильный размер блока,
то есть по сколько разрядов одновременно вы сортируете.
Ну и как-нибудь там подобрать,
чтобы константа была прям супермаленькая,
если надо.
Это еще раз,
это если сортировать не по циферно,
то есть не по разрядно,
а сразу по 6 разрядов за раз.
То есть я считаю, что у меня число определяется
не остатком по моделю 10,
а остатком по моделю 10 в шестой.
И тогда вот здесь у меня все числа будут
не от 0 до 9,
от 0 до миллиона минус 1,
ну а сортировать числа от 0 до миллиона минус 1 я умею,
сортировка под счетом.
Так я сортировал по младшим 6 разрядам,
потом по следующим 6,
потом по следующим 6, опять стабильно каждый раз.
То есть как бы я здесь
не пользовался нигде
тем, что я именно
по циферно сортировал,
я могу сортировать по 2, по 3 цифры одновременно.
Да, да, так и было,
там было просто плюс 10.
Так, ну все, спасибо за внимание,
до следующего раза.
Аплодисменты.
