Давайте поговорим, поговорим про ругательственное слово
на три буквы A, D, L.
Слышали про такой?
Класс!
Вот это вот мы видели, по-моему, уже слайд.
В три этапа идем.
Набираем множество имен, делаем постановки шаблонов
и резолвим,
кто лучше все подходит из полученных имен.
Ну, пришло время узнать, как первый этап работает
в деталях.
Работает он следующим смешным образом.
Видели вызов и пошли вверх по namespace.
В текущем namespace ищем, в родительском namespace ищем,
в глобальном namespace ищем.
Можно секундочку?
Да.
Вот до этого мы говорим про spaceship.
Где-то тут будет сакральный момент того, что нужно было знать про spaceship?
Или это просто две разные темы?
Нет, вот здесь spaceship не нужен.
Просто я сказал так, вкинул, типа,
давайте всегда писать spaceship как friend внутри класса.
Вот почему я попытаюсь через это объяснить.
Эхе-хех.
Но вы не сильно опоздали.
Мы собрались говорить про то, где происходит name lookup.
Где мы набираем это самое корзину имен,
с которой потом идем выбирать самое лучшее.
Здесь.
Идем вверх по всем namespace,
набираем все бары, что увидим.
Ну, тут вызов бара.
Надо, соответственно, отсюда бар забрать,
отсюда бар забрать, оттуда бар забрать.
Все подходят.
А потом выбрать из них наилучшее.
Ну, это если так в целом.
А тут, кажется, ответ очевиден.
Найдется ли вот это вот имя бар при вот этом вызове?
Нет.
Нет, ну вообще другой namespace какой-то,
не имеет отношения.
Туда мы смотреть не будем.
А вот в такой ситуации что будет?
Тут можно догадаться, если быть очень смекалистым.
Но вряд ли.
Ну как бы да.
Но как и что это значит?
Просто поглядите внимательно.
Ну вот да.
Вот здесь же мы не пошли в namespace n.
А тут почему-то пошли.
Ну вот ответ, конечно же, что есть.
А здесь же мы не пошли в namespace n.
А тут почему-то пошли.
А тут, конечно же, что здесь бар найдется и нормально вызовется.
Вопрос почему?
Может так же, например, поиск было с зависимыми именами.
Здесь поиск зависимый на namespace, и тут крещение.
Ну нет, тут термин...
Просто потому что мы уже один раз залезли.
В смысле, что на этой строчке?
Нет, вот это точно никакого отношения не имеет.
То, что на предыдущих строчках мы как-то залезали куда-то,
никак, никогда не влияет на следующие строчки.
Типа аргумента.
Зависимые имена, это тут как бы правильная идея,
но термин зависимые имена, вот кто-то про него сказал сейчас,
он именно про шаблоны.
Здесь шаблонов нет, ни одного.
Поэтому здесь чуть другие термины будут.
Перед этим поговорим про имена.
Тут я регулярку написал, наверное, правильно.
А, ну да, там еще что-то подчеркивание ниже.
А, ну да, там еще что-то подчеркивание нижнее,
какие-то теперь... Нет, да?
Нет, это что-то как уни-код.
А, ну это так.
Сейчас, там теперь любой уни-код символы
можно использовать, да, в именах?
Отлично.
Отлично.
Да, а к чему эта регулярка-то?
Имена бывают двух видов.
Qualified and unqualified.
Понимаете, что эти слова значат?
Квалифицированные и неквалифицированные.
Не помогает, да?
Квалифицированные – это те, в которых namespace явно прописано.
То есть мы полностью пишем, что мы собрались вызвать.
То есть совсем полная квалификация –
это два двуюточия.
Первый namespace – два двуюточия. Второй namespace – два двуюточия.
Третий – два двуюточия. Класс – два двуюточия.
Мы полностью всю цепочку вложенности прописать.
Это вот qualified name.
Unqualified – когда мы просто пишем какое-то имя.
Фу – это unqualified.
Здесь bar – это unqualified имя.
Ага.
Operator – это тоже unqualified имена.
То есть когда вы пишете цин две стрелки hello world,
вот эти две стрелки – это тоже unqualified имя.
Какие-то мелкие детали есть, нам они несущественны.
А qualified – это все, что можно записать в виде z.
Qualified – а дальше пошли два двуюточия namespace,
два двуюточия namespace.
Еще тут нужно упомянуть, что в самом начале тоже можно поставить
два двуюточия, но ничего перед ними не написав.
А если z for global namespace,
тогда это unqualified?
Два двуюточия z.
Неважно, что где находится. Мы сейчас говорим об именах.
То есть в выражениях, которые написаны.
Мы пытаемся вызвать функцию или пытаемся переменную достать.
Мы смотрим на выражение имени.
Если выражение выглядит как просто z,
которое unqualified,
то оно unqualified.
А если мы перед ним хотя бы одно-два двуюточия имеем,
то это qualified. Критерий такой для строк.
Если есть внутри два двуюточия, то qualified.
Окей?
Скажите мне, что значит два двуюточия?
Вот без namespace просто два двуюточия и какое-то имя.
Да, мы форсируем именно global namespace,
а не какой-нибудь другой вложенный.
Тут еще и трюк, что может быть,
здесь компилятор за нас каких-то namespace потом допишет,
но нам это несущественно сейчас.
А как форсировать локальный namespace?
Никак.
Форсирую глобально и полностью выпишу путь до локального.
Но вообще про то,
как форсировать, какая функция будет вызвана,
в C++, казалось бы, базовая вещь, которую мы делаем,
это вызываем к функции.
Но вот убедиться, что будет вызвана именно та функция,
которая вы хотите, это оказывается настолько нетривиальное занятие,
но об этом мы узнаем в следующих сериях.
У меня сегодня и сил не хватит на это.
Про первый этап,
где мы ищем список корзину имен,
с которыми дальше будем работать.
Процедура поиска их называется namelookup,
и для qualify и unqualify имен она отличается.
Что сначала идет?
Смотри, ты видишь в коде имя.
Ты в коде смотришь вот сюда, это вызов,
имя здесь bar, надо понять, что вызывает.
Нет, сейчас смотри.
Речь идет не об имене.
Короче, когда ты видишь объявление функции,
тут нет уже понятия qualify, это имя или unqualify.
Оно есть, но оно не про другое совсем.
Нас интересует qualify для имя в месте вызова.
В точке вызова мы явно прописали n2.bar,
тогда это qualify, если просто bar, unqualify.
То оба добавятся в корзину.
А кто вызовется?
Это решит overload resolution,
если они будут одинаковые, то будет ambiguous,
call ошибка.
Сейчас будут два кейса, qualify и unqualify.
Это про точку вызова функции.
Где вы вызов функции написали,
вы там полностью прописали имя функции
со всеми квалификациями, или только само имя собственное.
Вот от этого зависит.
То есть со всеми namespace и 7777.
Ну, ладно, не всеми.
Хотя бы с одним namespace, если написали.
То есть хотя бы одно-два-двую точью, если есть.
То процедура такая.
Мы сначала ищем в X...
Что, потом qual внутри?
Но сначала ищем X, очевидно.
Фу, да, все, я туплю.
Здесь сказано, что идет рекурсия.
Потому что namespace это тоже нужно находить.
Поэтому, когда у вас написана какая-то qual,
эта функция какая-то, qual и перед ней два-двую точи X,
надо сначала запустить рекурсивность себя,
чтобы найти, где у нас Y, два-двую точи X.
То есть вот от префекса себя запустили,
нашли, где namespace.
В нем уже запускаем поиск qual.
Если вот такой идет,
то X строго в глобальном namespace.
И когда сделано вот такое,
то есть перед первым namespace нету два-двую точи,
то идет поиск qual.
Если вам покажется, что это
хреново сформулированная индукция, так и есть.
Но я это переписывал со стандарта, по-моему.
И там как-то вот эта индукция очень плохо...
Я правильно понимаю, что qualify,
чтобы на всех шагах
рекурсии был qualify,
нужно везде поставить две-двую точи.
Да, чтобы совершенно точно
выбрать, какую функцию ты вызываешь,
нужно начать с глобального namespace
и полностью прописать, куда ты хочешь прийти.
Иначе у тебя для самого первого namespace
qualified lookup,
который будет на следующем слайде,
мы находим какой-то namespace,
и дальше в нем ищем следующий namespace,
следующий, следующий, следующий,
и в последнем из них ищем уже функцию,
просто по списку функций в этом namespace.
Как это словами даже понятнее,
чем перевод формулировки из стандарта,
я думаю, вы поняли.
Интереснее, что происходит,
когда мы inQualify lookup делаем,
когда у нас не указаны namespaces.
Начинаем идти наверх,
в поисках того, что подойдет.
Соответственно,
это про namespaces,
есть класс, внутри него функция,
внутри функции вызов.
На уровне namespaces посмотрим,
нет ли совпадающих имен и выше, выше, выше,
как пример самый первый был.
В родительские классы мы тоже пойдем.
Вы уже умны, да?
Тут звездочка должна быть.
Что за звездочка про поиск в родительских классах имен?
Нет, там вот да, называл человек.
Чего?
Я не расслышал.
Если имя зависимое
и родитель зависимый,
то мы туда не пойдем.
Если имя inQualify
и родитель зависимый,
то мы туда не пойдем,
потому что мы не знаем родителя.
На первой фазе в смысле.
Это вставит в текущую область видимости,
где ты этот using написал.
И если там и там одинаковые абсолютно функции,
имя и родитель зависимы.
Суть этого одна функция.
Одной функцией может быть много деклараций.
Как это понять?
Если есть глобальная функция,
есть ровно такая же,
мы искали using, space, вот это.
Тогда ты, кажется...
Нет, оно приоритет возьмет.
Потому что на этом шаге
изнутри, наружу идет.
Нет, все равно волшебно, непонятно.
Если мы пишем using declaration,
мы создаем новый, маленький скоп,
который начинается с using и идет дальше.
Он же не остановится набирать имена,
когда найдет хотя бы одно подходящее.
Он пойдет дальше, насколько я помню.
Если остановится на этом шаге, то я уже путаю.
Наверное, должен остановиться.
Если это unqualifying имя, то он остановится
и посмотрит, на кого он давно шел.
Наверное, все-таки я сейчас соображаю.
Да, оно остановится.
Оно остановится и дальше не пойдет.
Ладно, нам это не интересно.
Тут есть вот оговорочка маленькая.
Я про friend definition вам сказал.
Есть friend definition.
Прямо внутри класса делаем friend функция
и объявляем ее.
Где область видимости, в которой живет эта функция?
Просто снаружи класса.
Какая вот friend definition?
Он туда и кладется.
Для зависимых имен там еще какие-то приколы.
И последним самым шагом
начинается некоторый загадочный ADL.
Что такое ADL?
Мы начинаем искать функцию foo,
увидев unqualified вызов foo от bar
в различных местах,
которые как-то связаны с аргументом,
да, при этом из всего предыдущего
мораль какая?
До ADL мы дойдем, только если все остальное не сработало,
тут вот такие правила.
Если нашлась какая-нибудь внешняя функция,
то она подавит ADL.
ADL ищет в следующих местах
связанных с bar функцию foo,
класс, в котором внутри самого класса bar,
снаружи от этого класса,
то есть в namespace его содержащим,
во всех родительских классах
или курсивно во всех namespace родительских классов.
Вот этой переменной bar.
Если bar – это какой-то шаблон,
и в этот шаблон подставлены какие-то аргументы,
то есть тип bar – это специализация шаблона,
и в namespace, где лежат аргументы,
вот этого шаблона для bar,
кто-то там крестится уже на задних рядах,
нет, показалось.
Если у нас какие-нибудь указатели на функции
или указатели на методы,
вы знаете, что такое указатели на методы?
В них тоже все типы,
которые упоминаются, мы их всех тоже возьмем
и в них идем, и в их namespace идем.
И вот все эти места называются
ассоциированные с bar скопы.
То есть примерно все, что хоть как-то известно
про bar в compile-time,
все сущности, которые вообще хоть малейшеньким образом
как-то относятся к bar,
в них мы пойдем искать имя функции,
в них мы пойдем искать имя функции,
в них мы пойдем искать имя Foo.
Ну не буду про них, слишком сложно.
Почему этот код компилируется?
Почему он компилируется, я не понимаю.
Вот cout, он namespace std,
я пишу std cout, мне говорят, да, есть такое.
Если я просто cout напишу, работа не будет.
А оператор меньше-меньше, он тоже на namespace std определен.
Почему мы можем вызвать оператора меньше-меньше,
не указав, что он на namespace std?
Да, вы можете написать hello world на C++
исключительно за счет того, что существует ADL.
Ой, началось, нет.
То есть вот этот оператор меньше-меньше,
он определен на namespace std,
но это анквалифает имя.
Операторы, мы где-то упомянули, что это анквалифает имя.
Значит, мы посмотрим на аргументы.
Второй аргумент неинтересный,
по концу char звездочка,
там нет никаких ассоциированных классов и namespaces,
но очень интересный аргумент.
У него есть ассоциированный класс,
cout stream какой-нибудь.
Самое главное, что в std там написано, что он в std.
Да, в каком порядке оно все находится.
Мы берем класс этой переменной,
тип этой переменной, смотрим в нем,
а потом идем наружу в namespace,
который для этого класса относится.
Это класс определенного std.
Но и не только это.
Эта переменная сама в namespace каком-то живет.
Этот namespace тоже считается ассоциированным.
Как аргумент, оператора меньше-меньше.
А меньше-меньше это имеет?
Нет, не факт.
Да, по-моему, квалификация...
Нет, может...
Ну ладно, тогда не будем.
Из того, что точно здесь было за факт чекано,
по всяким...
Я правильно понимаю, что мы пойдем в std,
даже потому, что меньше-меньше он квалифает,
потому что один из его аргументов
имеет в себе тип, который лежит в std.
То есть если ты напишешь auto ampersand x
равно std cout, а потом вот сюда x подставишь
и std cout.
Все равно сработает.
Оператор меньше-меньше найдется через ADL.
Вот, поздравляю.
Мне кажется, на данном этапе
те из вас, кто понял, что такое ADL,
наконец-то до конца понимают,
как на C++ написать hello world.
Да, там везде есть маленькие детальки,
которые, чтобы до конца понять,
нужно стать самым бюрократом дурацким,
который пишет стандарт.
Но понимание, что ADL есть
и что он идет в тип переменной аргумента
достаточно, на самом деле.
Кстати, мы будем еще и упражняться
очень интересным образом в следующий раз.
Упражняться, в смысле, я оговорился.
Да, если ты...
Да, если ты передаешь в...
Не факт, потому что тип вектор begin,
вектор end, он implementation defined.
Может быть, имплементация стандартной библиотеки,
где вектор.begin возвращает t звездочку.
Но в целом, да, если у тебя
в функцию передается какой-то тип,
который точно в std лежит,
а не писать, в вызове функции std 222.
Вопрос, нужно ли это делать?
Я бы сказал, что нет.
Да, тут всякие обозначения, без ADL,
жизнь вообще не кайф.
А как же using std операции?
Ну, можно так было, да.
Давайте пробежечкой.
Вот такая штука замечательная.
В какой книжке?
Ну, вот, видимо.
Зачем это нужно?
И второй первый, да.
Для стандартных вещей из std.
Да, в using...
А если без using,
то второй сработал бы только из объекта.
Да, нам не интересны
объекты из std и примитивные типы.
Нам интересно, что будет для наших типов.
Вот мы свой namespace сделали,
и в нем сделали свой тип.
И то и другое будет работать одинаково, да?
Но теперь мы можем взять
и в нашем же namespace объявить свою функцию swap.
И вот этот код снизу
вызовет нашу функцию swap вместо std.
Абигиус не будет.
Не будет, да.
Ну, почему?
Такие приоритеты.
Абигиус не будет,
потому что у нас найдется
std swap, который шаблонный,
и найдется наш swap, который не шаблонный,
который для конкретного типа.
То есть в множество имен и то и другое попадет.
А потом уже на этапе overload resolution
мы посмотрим.
То есть в множестве имен std swap будет
и любые наши штуки swap, которые мы определим.
Это и есть то, что называется точка кастомизации,
за исключением некоторых деталей.
На самом деле std swap это тоже точка кастомизации.
Вы слышали про std begin и std end функции?
Они тоже точки кастомизации.
Вы можете определить std begin и std end
для каких-то своих структур,
которые не имеют метода begin и end.
И за счет чего это работает?
За счет вот такой технологии,
что стандартные алгоритмы вызывают begin и end
вторым способом.
Не знаю, делают ли на самом деле.
И вы, когда пишете шаблонный код на самом деле,
если вы хотите, чтобы пользователь мог чуть-чуть
подкастомизировать и подкрутить, как именно что там происходит,
например, подменить swap на какой-то свой кастомный,
который работает на один такт процессора быстрее,
а это важно, когда у вас сортировка пузыряком,
то вам нужно код вот так писать.
Поэтому swap вот только такой должен быть, не такой.
Интересно язык C++, да?
А шаблон-то так легко и интересно.
В общем...
Почему такой, а не такой?
Потому что здесь ты найдешь пользовательские кастомизации.
Если obj1 и obj2 это какие-то чужие типы,
лежащие в namespace n,
то автор этого namespace n может захотеть
всю кастомную реализацию функции swap сделать
в этом же namespace,
который работает быстрее, чем стандартный swap.
Все, я понял, я понял.
Более узкий специализация может быть эффективной.
Да, потому что мы знаем там структуру всего нашего внутри,
мы сделаем быстрее, круче.
Вот я чувствую катарсису одного человека, это...
А вот это DL вообще не изданное?
Сколько лет ты можешь написать hello world, столько о DL существует.
Вам может...
Я не знаю.
Да, я, к сожалению, не знаю немецкого,
поэтому шутка не зашла.
Что я хотел сказать?
Я хотел подытожить,
что DL это на самом деле лютый костыль,
какая-то ну типа кастомизация
частых функций, типа чтобы их как-то вот
подменить на лету, что-то сделать.
И как бы жизнь он облегчает, но...
код становится писать как минимум неприятно,
и своп нормально в шаблонном коде вызвать не можете,
не написав какое-то заклинание.
Ну, в общем, DL достался нам по наследству.
Сейчас очень много обсуждений о том,
что это хрень, и надо это выкинуть из C++,
но пока ничего такого не предвидится на горизонте даже близко,
и поэтому живем с ним.
Нет, в родительских классах
своп у тебя вряд ли будет объявлен.
Нет, если у тебя obj1 и obj2
это зависимые имена,
то своп автоматом зависимый.
Нет, если у тебя obj1 и obj2
это зависимые имена, то своп
автоматом зависимый.
Как бы вызов функций, в нем
в имя включены еще аргументы, но не совсем,
но как бы да, потому что эти аргументы
влияют и на то dependent или нет,
и на lookup влияют, как мы узнали из ADL,
потому что lookup зависит от аргументов,
поэтому эти аргументы и часть
имени, и как бы нет, и тут сложно сказать,
что конкретно правильно, какая терминология официальная.
Ну да, вот как факт,
аргументы влияют на lookup,
и аргументы влияют на то, зависимое
имя функции будет или нет. Если аргументы зависимые,
то вот имя функции, вот здесь этот вызов считается зависимым.
Да, это некоторое подобие extension
методов в каком-то смысле.
Extension методы есть не только в Kotlin,
еще в C-sharp и Java теперь вроде.
Это возможность написать метод внутри класса,
то есть пишете методы вне класса,
но появляется он как будто бы внутри.
Ну да, и так даже можно,
C-sharp убойный язык.
Просто кажется, что extension
и то, что в предыдущем свадьбе было,
оно может решать одни и те же проблемы.
Да, как бы проблемы здесь примерно
те же пытаются решить, это некоторая расширяемость
и подписывание старых
абстракций на новые контракты какие-то,
на новые интерфейсы.
Потому что он плохо работает, когда ты его начинаешь
пытаться использовать для чего-то, кроме Hello World.
Если ты не веришь, то ты убедишься в этом
через пару семинаров или лекций,
если я все-таки не решу это выпилить.
То есть это неожиданно еще не работает,
когда у тебя есть какая-нибудь функция 2,
которая лежит у тебя где-то локально.
Короче, это какая-то проклятая фича C++,
на первом курсе из-за нее
невозможно объяснить человеку, как работает Hello World.
Но это уже как бы показатель, мне кажется, надо что-то делать, но...
Я потерял всякую надежду сегодня успеть пописать код,
поэтому код будем писать в следующий раз,
сегодня добьем вот эти вот мелкие темы,
потому что вот эта конкретная тема вам поможет с домашками.
Да нет, с третью рана.
Третья, видимо, будет не на этой неделе, а на следующей.
Во второй можно по-разному написать код.
Один из способов его написать, это вот через вот эту штуку.
Некоторые ее видели, возможно, уже, некоторые нет.
Давайте познакомимся.
Вот эта штука называется curiously recurring template pattern.
Почему так?
Потому что весьма любопытно, что подобный код
постоянно появляется и появляется заново в разных код-базах,
абсолютно независимо, заново открываемое разными людьми.
Поэтому его так и назвали, любопытный и заново
постоянно возникающий паттерн использования шаблонов.
Вот, молодцы.
Нет, это прекрасный паттерн.
Нет, он нормальный.
Ну, вы видите, что происходит?
Вот если кто-то в первый раз видит такое вот,
мы делаем базу шаблонную и наследуем ребенка
от шаблонной базы с аргументом самого себя.
Класс, наследуем от базы с аргументом самого себя.
Проклятое что-то в этом есть, да.
Но это работает.
В этом вся проклятость.
Каким-то образом, да, мы как бы
наследуемся от base and derived и как бы в момент
работы с базой мы тоже увидим,
что derived уже определен вообще-то.
Хочется сказать,
ой, ну тут derived, вот тут это,
когда будет какой-то incomplete и ничего работать не будет.
Ну проклятость-то в этом и заключается, что оно работает, блин.
Что?
Вот как поле здесь завести drive, ты, конечно же, не можешь.
Да, а вот так сделать можешь.
Ну, поле мы сказали, вот поле типа T,
в base завести не получится.
А вот использовать в методах можно. Почему?
Вспоминаем.
Нет.
Не угадай.
Ленивая инстанциация методов.
Да, у вас инстанцируется вот в этом месте
только сам class, но не инстанцируются
его методы.
Да?
Вообще ничего не инстанцируется, просто.
А вот когда вы где-то в коде
уже напишете interface или static func
у derived, например, вот в этот момент
уже будет инстанцироваться вот это вот или вот это вот.
Но к тому-то моменту у нас derived уже определен
полностью, работает.
Что, после base?
Вызов static sub?
Да нет, все равно будет работать, наверное,
нет, не будет, потому что derived вообще не определен.
Да, кстати, кассир на свойство t, кажется, не работает.
Не должен, потому что вот на самом деле
в момент инстанциации base derived он incomplete.
Мы пока не знаем какие там поля и не знаем
какие там методы. Мы только знаем, что такая
структура есть, ничего больше о ней не знаем.
Нет, в смысле?
И same?
Нет, не должно, и same это уб будет.
Same от d и d.
Может быть alias?
То есть это тоже нужно, чтобы у тебя класс был?
Нет, incomplete-тип не может быть alias.
Короче...
Кажется, там никакие вообще нельзя.
Нет, вроде можно, потому что все места, где нам не требуется полнота t,
почему быть? Давайте, ну таких мест крайне мало.
Давайте прервем вот эту дискуссию.
Почему это работает?
Потому что на момент наследования,
мы инстанцируем шаблон base, но не его методы.
Методы инстанцируются лениво,
по мере нужды. А в самом шаблоне base,
кроме этих методов, ничего нет.
Ну и в этот момент инстанциации base, вот это вот t,
которое derived будет, это incomplete-type.
То есть тип, про который мы знаем, что он тип,
знаем, что это структура или класс,
но не знаем, какие там поля или какие методы.
То есть если ты попытаешься здесь в качестве поля t сохранить,
то это работать перестанет, потому что чтобы сохранить тип,
как у себя поле, нужно и его поля тоже знать.
Размер нужно знать этого типа.
А мы не знаем на момент вот инстанциации base.
Но когда...
Я только что говорил, а ты в это время болтал.
Если бы ты послушал, ты бы, наверное, уже понял.
Повторяю третий раз.
Идет двухфазная инстанциация.
Ленивая.
Сначала инстанцируется сам класс в момент наследования.
Класс без всяких методов инстанцируется.
Это вот на первом занятии было, что
когда вот так пишете, у вас инстанцируется класс,
его поля, его алиасы внутренние, но не методы.
В этот момент, как бы, тут t есть,
но он incomplete.
Как будто forward declaration только был.
И использовать его как-то по-нормальному не получится.
Не получится с какой-то стати кассир на свойство t написать.
Не получится t как поле здесь сохранить.
Requires тоже не будут работать, если вы их
вне методов напишете.
В методах requires можно написать, опять же, из-за ленивости.
Если какой-нибудь using напишете,
и в нем requires на t, то не будет.
В общем, ленивая инстанциация,
методы отложены, инстанцируется сам класс.
В этот момент t это incomplete type,
но мы с ним ничего не делаем тут, мы делаем все в методах.
А вот в момент, когда мы уже будем звать эти функции,
interface и static func,
ну, наверное, мы создадим экземпляр класса derived,
и будем звать вот эти методы у него,
в этот момент-то и derived тоже полностью определен,
и шаблон полностью определен, и мы просто берем
и инстанцируем только один метод, который нам нужен.
Все.
Тоже все работает абсолютно так же,
потому что это абсолютно артагональные вещи.
Вот все OP, вирчол,
pure virtual, оверайды,
это все настолько артагонально тому, что мы обсуждаем,
что, да, здесь можно пихнуть еще и всякой виртуальности
и будет тогда вообще убой.
Теплэйтные методы они тоже типа не инстанцируются?
Да.
Не темплэйтные методы в шаблоне типа
они инстанцируются только по нужде.
Их инстанциация откладывается. Это было на первой лекции.
Там есть запись, можешь ее посмотреть,
наверное, достаточно для таких вопросов.
Немтя, какой-нибудь оператор копирования в векторе.
Вот если бы методы не лениво инстанцировались,
а сразу, то вектор UniquePTR бы не скомпилировался,
потому что у вектора есть оператор копирования,
оператор присваивания с копированием,
и там ты пытаешься копировать UniquePTR.
Нельзя, ой, не должно компилироваться, но за счет этой ленивой инстанциации оно работает.
И здесь тоже за счет этого работает.
Это все круто, но зачем это нужно?
Вот это абсолютно верно.
Да, enableSharedFromThis ровно так работает.
В целом, на самом деле понятно, что мы можем делать.
Мы можем здесь написать кучу кода и здесь написать кучу кода.
И использовать какие-то методы из ребенка прямо посреди этого кода.
А потом в ребенке их как бы переопределить
и что-то как бы такие, заглушки заткнуть.
А если вам это похоже на виртуальные функции?
Вот очень похоже.
Внимание.
Это как бы другой вид полиморфизма.
Один из трех китов ООП это полиморфизм,
но если быть точнее, это динамический run-time закрытый полиморфизм.
Там много конкретных слов нужно поставить,
чтобы описать, какой конкретного ООП подразумевается полиморфизм.
А это другой вид полиморфизма.
Внезапно паттерны ООП, которые были у нас в самом начале,
они работают не только с динамическим полиморфизмом
на виртуальных вызовах.
К чему весь разговор?
Вот на таком полиморфизме можно попробовать написать каких-нибудь паттернов.
Итератор.
Нет, это не нужно.
Каких-то более содержательных паттернов, таких структурных, что ли.
А, например, шаблонный метод абсолютно понятно,
как на этом сделать. Правда?
Вот здесь пишете какой-то алгоритм, и в нем используете какие-то там шажочки.
А дальше в наследниках эти шажочки дергаете.
Пожалуйста, паттерн шаблонный метод без оверхеда
на виртуальную диспетчеризацию.
Те методы, которые используются в базе, чтобы дефолтные были?
Как наследуется от класса, где определен метод size,
чтобы в базе можно было использовать метод size?
Да, вот эти вот имплементации
можно выдвинуть в другой тип,
и от него наследоваться тоже. Независимо.
Это тоже, кажется, будет работать.
Да, это работает.
Очень много чего можно натворить с этим. Давайте пойдем по слайдам все-таки.
Можно на этот base class смотреть
как на некий интерфейс.
Вы как бы наследуетесь от интерфейса,
но статического, а не динамического.
И можно через такой забавный концепт статически проверять,
удовлетворяет ли там класс вашему интерфейсу.
Но это скорее упражнение по приколу.
Можно вот так сделать.
Вот этот самый простой вариант развития идеи
можно сделать имплементацию по умолчанию.
Соответственно, если в дочернем классе
есть implementation,
то он будет использоваться.
А если нету, то будет использоваться из родительского.
Вот тут может сломаться
в некоторых ситуациях, по-моему.
Еще раз, если у нас
в дочернем классе
определенный implementation, то он вызовется.
Да. А если нет, то вызовется вот этот из родительского.
Мы же родительский, вот этот вот. Родительский.
Нет, не виртуальный.
Это статическое происходит.
Что void.interface?
Я имею ввиду, чтобы функции интерфейса static func
не сломаются при вызове.
Потому что в этот момент уже все определено.
Давайте дальше.
На самом деле, ну да, это как бы aboost two-phase lookup
по большей части. В частности того,
что для корректного two-phase lookup необходимо
откладывать инстанциацию методов.
Почему это важно осознавать?
Потому что на MSWC некорректно реализован
two-phase lookup и некоторые,
по-моему, да.
И некоторые шаблонные трюки, которые у нас
на гцц и кланге прекрасно работают на MSWC,
работать не будут. Или работать по-другому.
Врут.
Ну, возможно, это какая-то совсем bleeding-gauge версия,
потому что я на работе наткнулся недавно.
Не помню.
Свежая. Мы часто обновляем компиляторы.
Да, по-моему, да. Ладно.
Не факт.
В общем, да, долгое время в MSWC точно
был сломан two-phase lookup, поэтому трюки с CRTP
на MSWC могут работать либо как-то иначе,
либо совсем не работать. Будьте внимательны
в кроссплатформенных проектах.
В принципе, такой техникой
можно просто подмешивать какой-то контент
новый в дочерний класс.
При этом этот контент еще и может пользоваться
какими-то свойствами дочернего класса.
То есть работать как статический интерфейс.
И главное, что это замена такая виртуальным вызовом.
Вот в некоторых местах вам на самом деле не нужно
в runtime ничего определять. У вас все в compile-time
известно. Поэтому можно взять и заменить
от OP, просто выдрав интерфейс, заменив на CRTP,
и в принципе продолжит работать,
но будет быстрее, бесплатно.
Ну, зависит от того, как вы это написали, конечно.
Это все нормально будет.
Вопрос.
Вот если мы в этой базе CRTP-шной
напишем обращение к фаузу методу,
а в базе этот метод не определим,
насколько накрученную ошибку
Ну, такую неприятненькую, что типа
я не нашел метод.
Да.
Нет, концептом нельзя проверить,
что в derived есть нужное.
Хотя нет, можно.
Что?
Но если хочется
подсказки
то, кажется,
короткий ответ нельзя,
а длинный можно сделать отдельный класс,
который реализует контракт,
задаваемый концептом,
и тот объект, который мы используем,
он будет наследоваться CRTP базы
с шаблонным параметром
этого объекта.
То и на это нормально,
потому что вот это вот надо самому написать,
и тогда станешь понимать, о чем речь идет.
А пока ты сам не написал, абсолютно неясно.
Да, что ты говорил.
Я хотел сказать, что можно же
сделать интерфейс в олд-вишном понимании
с пьюр-виртюровыми методами,
а просто в наследнике, по-моему, файл.
Да, есть такое...
Если я что-то не определю,
будет читаемая ошибка, и при этом вроде бы
ректуализация в рандеме не будет.
Нет, она все равно будет, потому что
ключевое слово «файнал» — это подсказка,
ну и гарантия, что других наследников дальше не будет.
Но...
Вот где можно.
А периодически пишется код, в котором нельзя понять
в Compile Time, что на самом деле за объект
придет по интерфейсу.
Ну, такой код очень легко написать, правда,
и несмотря на то, что фактически там может быть
всегда только один единственный вариант
по логике вашего кода компилятора,
до этого догадаться не может,
из-за того, что там информация по нескольким
кодам раскидана, и в итоге вы получаете
виртуальные вызовы, хотя они вам не нужны.
Да.
Просто если не написать «файнал»,
и мы будем обращаться по указателю на дирайта,
там все равно будет виртуализация, потому что, возможно, дирайта есть какой-то наследник,
и там мы скастили, короче, базу.
Вот дирайт тоже может быть больше, чем кого-то.
А если мы написали «файнал», то это уже невозможно,
Опять же, это все работает,
если только у тебя простой код, и компилятор видит,
что ты вот в этот указательный интерфейс
сохранил объект, который на самом деле вот такой,
и на самом деле у него там все final,
и компилятору сложно догадываться в ОП коде,
что на самом деле будет вызвано. Я бы даже сказал, невозможно.
Нет, если ты просто создал экземпляр derived,
и у него что-то помечено final, и ты его вызвал,
то, да, конечно, там виртуального вызова не будет,
но это не сильно поможет. Обычно там интерфейсы начинают накручивать,
и вот из-за них всякие беды,
что там что-то приходит по интерфейсу, и все перестает работать.
Да, я не сказал самого главного,
вы все еще с CRTP как бы можете
передавать штуки по ссылке на база T.
Только T это вам будет известен уже,
но это все равно в некоторой степени прикольно,
что вы как бы прячете сам T и говорите,
только из этого набора методов что-то вызывай,
но самого derived ничего не смей вызывать.
Ну и, конечно, это требует шаблонизации всего,
если вы хотите с любым T работать.
По-моему, еще условие, что это должны быть полей наследника.
Иначе это...
Что?
Наследника поля могут быть наследник любой.
Давайте про полезное применение этого.
Это паттерн-прототип.
Помните его.
Когда вы его реализуете, вам нужно вот этот pure virtual
метод взять и завернуть
и вернуть отсюда new square,
отсюда вернуть new circle,
ну и запустив там конструктор копирования.
Давайте не будем копипастить,
сделаем вот так.
Это
CRTP промежуточный класс
на следующий abstract shape.
Он все еще pure virtual, но он шаблонный.
И подмешивает в свой
дочерний класс функцию clone,
которая возвращает по интерфейсу
abstract shape
копию себя, но скачанного derived.
Понятно, да?
Нет? Внимательно смотрите.
Да, потому что задумано,
что ты из square и circle наследуешь от shape
с собой CRTP.
И автоматом получишь в них метод clone правильный.
Это очень мощный подход
к дедупликации всякой копипасты,
которая у вас одинаковая примерно,
но в этой копипасте необходимо знать
статический тип.
Да, я и сомневаюсь, что много кто
открыл, кроме тебя.
О, два человека.
Потому что люди не открывают ссылки в чате,
если это кому-то другому ответ.
Но с этим можно еще и визитер очень круто написать.
Либо посмотрите в чате, либо сами попробуйте.
В визитере ассепт был, который надо копипастить.
Точно такая же техника.
Так, нужно еще про это что-то сказать? Нет?
Все. Ура.
Стало чуть получше.
Она применяется практически повсюду,
но когда пытаешься найти, найти очень сложно.
Потому что никто не называет этот CRTP в коде,
все просто пишут коды такие.
Написал, сделал, классно.
Из того, что удалось за пять публей найти,
это в стандартной библиотеке есть shared from this,
уже сказали про него, и view interface.
Сейчас в 26-ые предлагают добавить итератор interface.
Там итераторы вообще все на CRTP работают.
Вот непроверенная информация,
но ссылка кликабельна, поэтому можете пойти посмотреть.
Я уже не помню, что там было.
Там разбития для ксемы.
Пока.
Маленький трюк, маленький прикол,
который соединяет вместе все, что было до этого,
чтобы лекция была такой состоятельной.
Можно добавить CRTP, ADL и друзья вместе,
и получить прикол.
И операторы сравнения тоже.
Это не очень актуальный прикол,
немножко протухший, баянистый, но все равно прикольно.
Мы сделаем CRTP-класс
с френдами,
с френд-дефинишенами, обратите внимание,
которые сравнивают
два экземпляра t,
где t – это draft,
через некоторый метод equal to.
Поняли, что вот это такая бодяга?
Теперь как его использовать?
Приватно наследуем
нашу шнягу от equal comparable
с собой,
и один метод реализуем.
equal to.
Да, френды.
Тут еще раз важно оговориться,
что когда где-то кто-то в коде
будет писать,
ваш value type равно равно
еще один какой-то объект value type,
то у вас появляются эти операторы,
вот эти вот френды.
Это важная деталь про вот этих френдов,
которые я не сказал.
Их невозможно вызвать квалифицированно.
Когда вот пишете friend и объявляете метод
прямо в классе,
квалифицированного имени у них нет.
И вызвать их можно только через ADL.
Через ADL по value type
мы находим ассоциированный
родительский класс,
а идем сюда,
а вот эти френды попадают во внешний
namespace, поэтому они найдутся.
Понятно, что произошло, да?
Ничего не понятно.
Говорите со мной, понятно, почему нашлись эти френды
и пробросились уже к equal to,
который мы один реализовали.
Итого, мы научились вместо того, чтобы писать два оператора
ручками, когда хотим наш класс сделать сравнимым,
писать одну такую строчку простую
и один оператор сравнения.
Угадайте, что дальше? Можно то же самое сделать и для…
Да, вот, кстати, почему вот эти френды здорово?
А потому что вообще не стоит засорять
Зачем вам лишние имена добавлять, которые можно найти?
Более того, в определенный момент,
когда вы увлекаетесь слишком сильной метапрогой,
вы начинаетесь по производительности программы
упираться в ее время компиляции.
Сбор множества имен
и overload resolution на нем
периодически оказывается ботлнеком в этом вопросе,
потому что слишком много имен в каждом namespace, их слишком много
находится, то есть пишете какой-нибудь оператор равно-равно,
и там вываливается у вас из всех хедеров
тысячи разных операторов равно-равно.
Вот этот вот сет на тысячи имен мы идем там что-то инстанцируем
еще шаблонное, еще overload resolution запускаем.
Долго. Поэтому можно делать вот так.
Вот эти френды, их невозможно найти, вот эти функции,
невозможно найти ни по какому имени, кроме как
ассоциированному с equal comparable
или его namespace'ом.
По-моему токсика comparable.
И это здорово.
Меньше засорения namespace, но какой ценой.
Да, но ты, по-моему, не сможешь их найти
через ассоциацию с другим классом, я не уверен.
Это опять лютая деталь.
Да, квалифицировано
обратиться к ним вообще нельзя.
Они волшебные.
Тихо, Андрей, подожди.
Да, они волшебные, это просто магия,
их нельзя достать квалифицированно.
По-настоящему магия, в стандарте написано,
когда у вас friend definition, qualify lookup невозможен,
но считается, что функция лежит
во внешнем namespace'е.
Просто так.
В основном namespace'е объявления этой функции нет.
Ты на namespace смотришь, а в нем ничего нет.
В контексте класса объявление есть,
в контексте namespace объявления нет.
Именно объявление не сущности, а ее объявление.
Ну как бы да, но мне такое не добавляет понимание.
Я смирился с этим как просто, с реальностью.
Оно работает вот так.
Friend'ы находятся только через EDL, но это нам не помеха,
меньше засорения namespace'ов.
Да, следующий шаг, это просто взять
и через такую же технику операторы меньше, больше,
все остальное все определить через нее.
Итого вместо шести операторов можно написать сколько?
Примерно, можно один,
если это будет ваш ручной аналог 3-way compare.
Да, то есть
как бы до оператора spaceship'а
люди, которые очень любили сравнивать разные типы,
они тоже как-то выкручивались, ну вот примерно так.
Что?
В том, что мы не пишем не равно или что?
Да, в том, что мы не пишем не равно.
Да, а сейчас ты просто spaceship'ы используй
и не парься. Но в целом это вот
как бы хорошее применение, все, что мы только что видели.
Тут EDL и вот эти вот front definitions
и сравнения участвуют
и с RTP и вообще так классно.
И все это называется Barton-Nachman-Trick.
Ну как бы вот
мораль, я не знаю, как еще прокомментировать.
Да, наверное, все-таки суть этого трюка в первую очередь
в том, что не как бы не в операторах сравнения,
а в том, что мы генерируем внешние функции
по отношению к классу. Можно генерирует не только операторы.
Если у вас есть какое-нибудь соглашение
о том, что через EDL должна находиться функция
bar, ну вот как в стандарте swap есть
begin и end, вы свою такую функцию сделали bar
и решили ее там как-то выражать через что-то.
Ну вот тут точно так же ее можно
френдами нагенерить для произвольного класса.
Мне кажется, здесь лучше все
сформулировано, вот это вот не в усталом виде писалось,
и сейчас я устал.
Да, вот генерирование внешних функций,
это, наверное, самая правильная фраза.
Финалочка, которую я добавил вчера ночью,
перед тем, как понял, что надо
заполнять вот этот вот
интплан замечательный.
Ну это 23 плюсы.
У нас они пока не включены.
Я не уверен, что стоит пытаться,
потому что очень все сыро.
Но знать про это надо, потому что
это как бы захайпит вас как-то продавливать
обновления на новые стандарты на работе
и в разных проектах ваших.
Значит, есть такая структурка старая,
есть метод, сколько у него аргументов?
Один? Это правильно.
Есть неявный аргумент this, первый.
А теперь можно его сделать явным.
Вот это вся фича.
Вы просто пишите this, тип должен быть
такой же, как у структурки,
и какое-нибудь название свое придумаете.
Можно self, можно me, I, как хотите.
Что-что?
Ну, тут сейчас понятно будет,
почему это мощно.
Что так-то это...
Что?
Ну, нет.
Ну ссылки и покупатели в этом плане
одинаково работают. Не в этом суть.
Кажется, что это так, типа какая-то мелочь,
зачем ее добавили.
Как бы обращаться внутри такого метода
нужно чуть-чуть по-другому к полям и к другим функциям.
У вас пропадает вот эта фишка,
что вы можете имя упомянуть
и обратиться к методам, если я не ошибаюсь.
Теперь нужно явно писать self.x строго.
Ключевое слово this тоже перестает работать
в рамках вот этого вот, по-моему.
То есть это даже целый новый вид объявлений методов,
которые по-другому принципу работают
и механика у них другая.
Интересно, что происходит с заплатой ляма в этом случае.
Лям-дизис дает некоторые возможности быть фундомом.
А что здесь происходит?
Можно рекурсированный лям делать.
Сейчас все будет.
Ну, вот такая функция.
Теперь настал вот такой.
Да.
Или даже такой.
Это как-то да, это вот как-то сильно удобнее,
чем то, что было раньше с вот этим вот приписыванием,
где-то справа непонятным.
Тут теперь простой синтаксис, как во всем другом языке.
Пока шаблон мы сюда не делили,
всё сильно куча не стало.
Теперь мы только что реализовали 4 разных метода
в одном.
Потому что раньше вам нужно было руками где-то там костылять
вот этот вот имперсандик, словоконст там дописывать.
Да тоже почему нет?
Можешь оператор квадратной скобки сделать
как бы...
Всё, то есть это и константное lvalue,
и просто lvalue, и rvalue,
и даже если вы извращенец,
то это константное rvalue, ссылка.
Волотайл покрыли.
Вот там у вас t,
мы говорим this, t,
у нас есть self,
у нас теперь self
в качестве this, но при этом
типа t2%
Когда ты сделаешь,
смотри, пусть у нас есть объект x
типа new and shiny,
вот ты делаешь x.doSomething,
ну x это lvalue, да?
будет lvalue, ссылка.
Теперь делаешь std move x.doSomething,
теперь x будет rvalue.
Если вызвать эту функцию шаблоном параметром других,
не new and shiny,
а хороший вопрос.
Я понятия не имею, что произойдёт.
Что будет, если подставить в этот метод
шаблонный аргумент не new and shiny,
а какой-то совсем левый,
и попытаться вызвать?
Он мне кажется даст...
даст синтезировать новый список аргументов
из двух элементов,
который может помочь.
Если new and shiny указалось...
кажется да.
Просто тебе скажут, что ты неправ,
потому что твой тип не костуется к тому,
что ты указал.
t не костуется к new and shiny.
t по умолчанию выводится из того,
на чём ты .doSomething сделал.
Не совпадает.
Из expression,
который стоит слева от точки.
Тут дело в том,
что у меня есть new and shiny,
у меня есть derived 1,
есть derived 2.
Про наследников пока не говори ничего,
всё будет.
Я говорю, что если просто какой-то
рандомную мусорную фигню указать,
интересно, а другая сторона нет.
Как стереть?
Нет.
Тут нет ластика.
Хорошо.
Bright only память, наша любимая.
Если мы здесь укажем какой-то рандомный мусор
типа int,
то нам, конечно, скажут, что это неправ.
Вот это не является int.
Но если мы тогда ничего в треугольной скобке не написали,
то мы будем вводить из вот этого выражения,
какой тип нам нужен.
Здесь это какой-то x типа new and shiny.
Что-то вообще кроме new and shiny
может быть в t-подставе?
Да, сейчас будет.
Да, может.
Нет, мы не настолько крутые.
В этом весь убойный эффект.
Внимание, то, чего я вас лишил на прошлой паре,
то, как можно делать на пазо прошлой.
Из 20 плюсов можно, оказывается,
писать авто в аргументах.
Раньше это у лямп можно было только,
а теперь вообще у любых функций.
Это тот же самый код.
И это для всех шаблонов верно.
Вот любые шаблонные функции вы можете вместо того, чтобы руками
не смазывать, можно написать авто.
Только тогда придется в форвардах делать декл-тайп от селфи,
это не очень удобно.
Досточек костюм.
Сделать макрос, который будет вот это вот форвард
от декл-тайп.
Вы смеетесь, есть библиотеков, которые так весь код написан,
и люди себя прекрасно чувствуют.
Юнифекс.
Там весь код измазан макросом ФВД,
который делает ровно вот эту операцию.
Ладно, нас ждет парочка катарсисов
на ночь перед сном.
Собственно, вот они.
Это CRTP.
Нет, ну, это есть.
Тимплейт, вот тимплейт.
А я-то спрятал тимплейт.
Бейс-нетиплейт.
Да, это более мощная поддержка
CRTP.
Ты сможешь здесь взять
и написать?
Да, можно.
Наверное, да, но...
Должен смочь.
Тогда это вроде лучше сердечки.
Возможно.
Нет, ничего ты не можешь,
потому что мы здесь наследуемся от бейс-нешаблонного.
Значит, в момент тайп-чека вот этого вот всего,
когда мы собственно концепту будем проверять...
А, нет, это шаблон. Все будет работать.
То есть сюда вместо авто
подставится derived?
Когда ты на derived вызовешь вот этот метод,
подставится derived.
А если ты его вызовешь не на derived, а на базе,
то подставится base.
Ты можешь создать экземпляр base
и вызвать этот метод.
А как оно вызовется, если...
Ну, не скомпилируешь, не бывает.
Ну, дефолтную ты имплементацию сюда какой-то напиши.
А, если она написана, то скомпилируется.
А здесь будет derived.
Но при этом если derived.interface делаю,
то в авто подставится derived.
Да.
Но кажется, это не то, что появилось в появлении
в проекте.
Ты считаешь, шаблоны интерфейс,
в котором используется имплементация,
скормить его.
Нет, еще раз, ты теперь не указываешь
шаблонный...
Это могло быть методом без лист стати.
Да.
Да, это могло быть методом статическим,
поэтому надо просто явно self прокидывать,
но теперь это можно через точку делать.
Это удобнее.
Внезапно пришел на ему кап,
его статические функции,
таких он немного конфликтует.
Короче, вот так можно, это прикольно.
Это альтернативный CRTP новый, модный.
Но в задачах пока так вы не сможете сделать.
Можно это пообьюзить.
Вот это последняя череда слайдов,
три-четыре штуки.
Есть... Да нет, не с визитером.
Визитера пока не будет.
С тд-визит будет. Дерево.
Есть лифы, есть ноды.
Само дерево это вариант,
либо лист, либо нода,
и нода сама из себя представляет
два дерева, право и лево.
Я думаю, вы не видели еще такой способ
создать дерево.
Ну, по крайней мере, когда олимпиадки,
решаешь точно не так.
Это просто стиль написания кода такой пока что.
Ну, это никак...
Ну да, да.
Да, украдено
с блогика Microsoft, если кому интересно.
Перед тем, как перейти
к смаку, вот такое наблюдение.
В стандарте есть функция визит.
Знаете, что она делает? Она пытается на объекте
вызвать оператора круглые скобки
от настоящего типа, который лежит в варианте.
То есть, визиту нужно первым аргументом
создать функциональный объект, у которого есть оператор круглые скобки
для всех различных тэшечек,
которые в варианте перечислены.
Ну да, для всех альтернатив.
Слово альтернатива правильное.
Можно руками написать класс
с этими операторами круглые скобки,
а можно сделать такую забавную фигню под названием overloaded,
это класс. В конструктор мы ему
передаем две лямды.
Нет, с двадцатых плюсов нет.
Две лямды передаем, одна для листа,
другая для ноды. Варианты перебрали.
Лист нода.
Этот overloaded волшебным образом делает объект,
а круглые скобки для той и другой лямды.
Как? Просто наследуется от них всех.
В блоге написали overload,
у нас preference overloaded используется,
но не стыковочка.
Тут должно быть overloaded
и фигурные скобки.
Либо функция,
или костыль.
Вы поняли суть, да? Мы наследуемся от пака лямд,
сколько угодно их может быть.
Используем вот такую конструкцию,
которая с нашей высокой башней понимания того,
как name.lookup работает. Должно быть понятно,
что это такое.
Мы собираем все...
Да, это зависимые родительские классы,
и в дефолту, когда мы делаем name.lookup внутри overloaded,
мы не найдем на первой фазе ничего.
Поэтому нам нужно собрать
все эти родительские операторы круглые скобки
из всех родителей и все их перетащить
в скоб видимости overloaded.
И тогда они все будут считаться
валидным overload сетом.
Они все друг друга перегружают.
Пойдем
выбирать одну из них.
А вот они.
Стд принт никого не напряг? Нет.
Нет? Хорошо. В 23-х плюсах есть стд принт.
Ура, наконец.
Тридцать лет развития.
Съели петалиста, да?
Мы букву f убрали.
Стд принт f-то и раньше был, букву f убрали.
К чему это все было?
А вот к чему это было.
Это функция,
считающее количество листьев.
Мы визитируем
одно из двух
и захватываем
шаблонные ссылки self.
Понимаете, какой тип выведется вот здесь?
Нет. Внутренний. Какой?
Почему?
Выведется overloaded.
Понимаете, что происходит?
Это прикольно. Что?
Потому что у нас overloaded
наследуется от лямбды.
Поэтому мы берем самый последний наследник.
Overloaded наследуется от вот этих двух лямбд.
И к себе перетаскивает их операторы круглые скобки.
Поэтому, когда визит вызовет один из этих операторов круглые скобки,
но вот этот второй,
объект, на котором он его будет вызывать, это overloaded.
И, соответственно, здесь внутри
мы спокойно можем взять и рекурсивно запуститься.
Потому что self это overloaded,
и в нем все еще есть две функции.
Одна для листа, другая для ноды.
Убойно.
То есть это прекрасно, кажется.
А как выведется self?
Как self выведется?
Вот внутри std-vizit есть код,
который на объекте вот этом overloaded,
который мы передали ему, на этом объекте
вызовет оператор круглые скобки.
Ну там какая-то переменная есть, где хранится вот этот overloaded.
Давай O ее назовем.
И делается O круглые скобки от чего-то.
Это какой-то альтернатива.
O в этот момент какой тип имеет?
Это лямбда передается
аргументом overloaded.
А overloaded наследуется от типов этих лямбд,
и мы конструируем такой объект overloaded,
в котором подряд лежат эти лямбды.
И все операторы круглые скобки этих лямбд,
они втащены в этот дочерний класс.
Вот, наследуется от всех лямбд.
Вот этот синтаксис смешной
инициализирует первого родителя первой лямбдой
и второго родителя второй лямбдой.
А вот этот смешной синтаксис
собирает операторы круглые скобки в класс overloaded.
То есть у него теперь есть два оператора круглые скобки,
пришедшие из родителей.
Причем второй оператор круглые скобки это не функция.
На вот этой картинке
первый оператор круглые скобки это функция,
а второй не функция,
это шаблон функции.
Тут авто.
То есть вот в этой области видимости overloaded есть две сущности.
Одна функция, один шаблон функции.
Дальше вот этот вот вызов происходит о круглой скобке.
Где-то внутри visit глубоко есть вызов на вот этом объекте
оператора круглой скобки.
Врубается overload resolution,
сразу видит.
Так вот у нас в этой области видимости есть одна функция
оператора круглой скобки, один шаблон оператора круглой скобки.
Их и возьмем.
Дальше происходит инстанциация второй сущности.
Шаблон надо инстанцировать, чтобы все было функциями.
Вот этот шаблонный аргумент надо вывести.
Мы смотрим, как вызов выглядел о круглой скобке.
Какой тип о?
Overloaded.
У него тип должен быть вот ровно такой overloaded.
Теперь имеем две функции уже.
Одна из которых принимает вот это вот.
Другая из которых вот это, но вместо авто здесь
подставлен overloaded от все еще этих же двух лямп.
И ссылка указывает
на сам этот объект overloaded,
с которого все началось.
Используем себя дальше
в следующих двух визитах, чтобы процедура повторилась.
Да, это шаблон.
Это лямпда, которая порождает некоторый класс,
а оператор круглой скобки шаблонный,
а сам класс не шаблонный.
Да.
Лямда это объект.
С типом, который там рандомный.
На каждую лямду генерируется свой новый тип.
Тип этот обычный, просто класс.
Зато в нем есть метод шаблонный.
Шаблонный оператор круглой скобки.
На этом у меня наконец-то все.
Мы с вами очень много сегодня говорили.
Опять начали на 15 минут позже
и закончили на 15 минут позже.
Наверное, это стоит политикой партии официально сделать,
чтобы мы просто в 5-15 собирались.
Да?
Блин, ну ладно.
В общем, всем спасибо, все свободны.
До свидания.
