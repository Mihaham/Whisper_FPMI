Ура, мы начинаем. Сегодня у нас последнее занятие, мы завершаем тему блокчейнов и мы сегодня изучаем
самый современный, самый оптимальный permission protocol, который называется Hot Stuff. Это результат
2019 года и можно было бы подумать, что сегодня будет что-то сложное, но совсем наоборот,
сегодня будет что-то очень простое, слишком даже простое и даже удивительно, что настолько простое
можно придумать в 2019 году. Но конечно, чтобы придумать что-то простое в 2019 году, нужно сначала
изучить что-то сложное, что было до этого и каким-то образом подумать и вот все это совместить.
Так что начнем. Можно было бы этот протокол рассказать просто с чистого листа. Вы ничего
не знаете про блокчейн, вообще ничего не знаете и можно было бы в принципе разобраться. Но я
потрачу некоторое время и сначала напомню вам, как был устроен PBFT, как был устроен протокол
консенсусов в биткоине. Проведу еще раз параллель, напомню о них и мы подумаем,
как их можно склеить, чтобы получить что-то более оптимальное. Ну вот, мы с вами на последних
двух занятиях говорили, во-первых, про practical Byzantine fault tolerance. Это первый протокол и про
биткоин, он будет где-то здесь. Две идеи уже немолодые, то есть это 99 год, это 2008.
И вспомним, как там решалась задача консенсуса, как в этих алгоритмах, в этих системах упорядочивались
транзакции. В PBFT у нас был permission подход. Мы фиксировали число реплик 3f+, если мы собираемся
пережить сбоев любых отказов византийских узлов. И один из этих узлов назначается primary. И этот
primary отвечает за то, чтобы упорядочивать транзакции. Давайте быстро вспомним, как это происходило.
У нас, напомню, на рисунках 4 узла, потому что 3f+, и вот этот узел является primary. Он
получает транзакции от пользователей, но мы их называем здесь транзакциями. Получает транзакцию
primary. Primary, конечно же, принадлежит некоторой эпохе. Она называлась в этом протоколе view.
Primary в этом view получает транзакцию, выбирает для него порядковый номер и раздает эту транзакцию
другим репликам. Это первое сообщение, первая фаза. Она называлась prepare. Мы отправляли сообщение
в эпохе V с порядкомом номером S и хэшом транзакции D. Заметьте, свое сообщение подписывали. К нему
предлагали саму транзакцию, чтобы каждый раз с собой не таскать, потому что эти сообщения,
вообще говоря, мы собираемся пересвовать другим узлам, и чтобы не таскать с собой данные,
мы сюда добавляем только хэш. Первая фаза. На второй фазе реплики, получая вот эту транзакцию в
этом слоте, должны были понять, верно ли, что вообще лидер primary их не обманывает. Может быть,
он отправил разные транзакции с разными дайджестрами, разными хэшами, но с одним и тем же порядковым
номером. Чтобы разобраться, что лидер частный, они обменивались сообщениями. Вот такая квадратичная
коммуникация. Все общались со всеми. Тут можно кое-что оптимальное сделать, но чуть-чуть со всем,
так что это не очень важно сейчас. Эти сообщения назывались prepare, и смысл у них был такой. Я
и Т-реплика говорил... Простите, здесь, конечно, не И, а здесь подпись primary. Я и Т-реплика здесь
говорил другим, что я в эпохе В, в слоте С, получил транзакцию с дайджестом D, и свое сообщение
также подписывал. И если какая-то реплика, ну вот скажем это, набирала достаточно одинаковых
препареров, а именно 2F плюс 1, то мы говорили, что она подготовила вот эту транзакцию в этом
слоте. Если она собирала такой набор подписанных сообщений, такой хворомный сертификат, который мы
называли P-сертификатом, то реплика знала, что на большинстве честных реплик лежит одна и та же
транзакция, про которую мы знаем. Дальше мы задавались вопросом, достаточно ли этого, чтобы
считать, что транзакция надежно зафиксировалась в нашем логе. Обычно это было так, ну по крайней
мере в рафте это было так, но здесь у нас ситуация сложнее, потому что у нас сложнее устроена
смена эпохи. Вспомним, как происходила смена эпохи. Вот понятие комита, понятие фиксации транзакции
команды в логе, оно связано с тем, понятие это означает, что при смене ридера, смене эпохи, транзакция
всё ещё останется в логе. Вот поэтому мы сейчас поговорим, как эта смена эпохи происходила.
Да, обращаю внимание, что вот в ПВФТ, кстати, лекстика мне кажется удачнее, чем в рафте,
потому что в рафте мы говорим про процедуру, про фазу выбора лидера, а сложность она не в выборе
лидера, как известно, а именно в том, чтобы лидер ничего не забыл, ничего не потерял, ничего не
сломал. Так что смена эпохи больше подходит по смыслу. Давайте возьмём маркер поярче. Во-первых,
в смене эпохи мы не то чтобы выбирали нового праймари, мы его назначали. У нас была цель, чтобы
честный узел стал праймари. Мы не знаем, кто честный, но мы умеем подозревать не честный,
если они там ничего не посылают нам, если они посылают что-то разное. И тогда мы меняем праймари,
перебираем праймари просто по кругу. Мы говорим, что в эпохе В праймари назначается узел с индексом
В по модулю N, где число реплик. И если какой-то узел, точнее какая-то группа узлов достаточно
большая, решала, что праймари нужно поменять, то каждый из них отправлял новому праймари,
следующему в очереди. Вот это был праймари в эпохе 5, это праймари будет в эпохе 6. Вот мы узел,
который подозревает праймари в эпохе 5 в визнатистском поведении, отправляем праймари следующему
узлу, который должен стать праймари в эпохе 6, сообщение, которое так называлось view change.
И если новый праймари набирает достаточно много таких голосов,
но в том числе он может сам за себя проголосовать, то эпоха меняется и этот праймари говорит всем,
что давайте перейдем теперь в эпоху V plus 1. Это сообщение, которое называлось new view.
Разумеется, у нас было много тонкостей, но во-первых, у нас нет повода верить одному узлу,
который посылает new view, поэтому он должен убедить остальных, что действительно эпоха имела
право смениться, поэтому мы в сообщении new view прикладываем quorum на сертификат.
И вот добавляем его сюда. Кроме того, мы должны позаботиться о том, чтобы новый праймари знал
про все транзакции, которые мы собираемся считать закромичными. У нового праймари мог быть пустой лог,
но не то чтобы пустой, этот узел мог отставать от остальных, поэтому каждая реплика,
которая посылает view change, вместе с этим сообщением присылает и свои транзакции.
Разумеется, все сообщения подписаны, и они образуют quorum на сертификат.
Но нужно быть аккуратным на месте нового праймари, потому что разные реплики могут
посылать разные логи, и какие-то изнатильские реплики могут просто транзакции выдумывать.
Мы повторяем PBFT, пока ничего не пропустил. Поэтому если реплика посылает view change новому
праймари и посылает туда свои транзакции, то она должна как-то доказать этому новому
праймари, что эти транзакции должны перейти через эпоху. Как это можно сделать?
Хорошо, если у реплики, которая посылает view change, есть prepare-сертификат для транзакции,
потому что понятно, что двух разных prepare-сертификатов в пределах одной эпохи для одного и того же
упореткого номера S быть не может. Просто потому что пересечение двух вот этих вот quorumов будет,
по крайней мере, один частный узел, который, получается, проголосовал дважды. Так что мы будем
уверены, что транзакция переживёт смену эпохи, падёт в следующее, если в пересечении quoruma узлов,
которые отправили в view change, и в пересечении quoruma узлов, у которых есть транзакция,
какое-то очень маленькое пересечение получилось, оно побольше эти. Вот в этом пересечении есть,
по крайней мере, один частный узел, который может доказать, что транзакция должна переехать в
будущее. То есть у него должен быть prepare-сертификат у этого узла. Но как гарантировать, что он будет?
То, что какой-то узел знает, что у него есть prepare-сертификат, если у какого-то узла есть
prepare-сертификат, он знает, что на большинстве честных лежит одна этажа транзакции, но не факт,
что именно вот этот узел с prepare-сертификатом попадёт в пересечение quorumов и сможет доказать
новому primary. Так что такого определения, что транзакция лежит на большинстве честных узлов,
недостаточно, чтобы гарантировать, что она в сменной эпохе переживёт. Чтобы доказать,
что гарантировать, что транзакция переживёт сменной эпохи, то есть что она закоммищена,
мы должны знать, что у большинства честных есть prepare-сертификат. Тогда кто бы из вот этих 2
f плюс 1 узлов не попал, точнее, кто бы из этого большинства честных узлов не попал в пересечение
множеством честных узлов quorum and viewchange, он сможет сертификат предоставить и таким
образом докажет новому primary, что большинство честных узлов действительно получили данную
транзакцию и записали её в лог вот в этом слоте. Но это определение глобальное, то есть если
большинство честных узлов подготовили транзакцию, то кто-то из них пойдёт в пересечение quorumов и
докажет следующему primary, что транзакция переживает светлое будущее. Но отдельные узлы этого пока не
понимают. То есть действительно может быть большинство честных с подготовленной транзакцией,
но они же не знают ничего про остальных. Вот для того, чтобы отдельная реплика поняла,
что такое условие выполнено, мы устраиваем ещё одну дополнительную фазу, вторая, третья,
которая называется фаза commit. Смысл этой фазы commit, чтобы отдельная реплика поняла,
что большинство честных реплик знают, что на большинстве честных реплик транзакции. Для этого
они обмениваются сообщениями ещё раз. Вот эти сообщения даже выглядят похожи. Сообщения называются
commit, и у них те же аргументы. В эпохе V, в слоте S, транзакция с дайджестом D. Вот смысл
committer в том, что реплика, которая его отправила, обладает преперсертификатом и, попав в пересечение
quorumов, отправив Uchange, может доказать что-то новому primary. И если какая-то реплика собрала
2F плюс один одинаковый commit, то она уверена, что большинство честных знают, что на большинстве
честных транзакций могут доказать. После этого можно уже отправить в primary подписанный ответ,
и он сообщит его клиенту. Такой протокол местами не очень эффективный, местами очень неэффективный.
Во-первых, в чем он неэффективный? В том, что процедура смены эпохи очень сложная.
В процедуре смены эпохи мы должны в Vuechange отправить лог с сертификатами, в каждом из которых
много сообщений. Дальше отправится new Vue, и в этом new Vue будет quorumный сертификат с этими
сообщениями в Vuechange, у которых короче. Тут появляется очень много сообщений, и сам этап
довольно сложный, сама фаза довольно сложно устроена. Это первое место, которое мы сегодня
оптимизируем. Второе место, которое пока не оптимизировано, это вот эта картинка с репликацией,
с упорядочиванием репликации транзакций. Эта картинка в разрезе конкретного слота S,
и у нас вот для каждого слота параллельно выстраиваются такие картинки. Но вот если вы
вспомните multipaxos, то он тоже сначала состоял из отдельных паксосов, в каждом из которых было
две фазы, а потом мы заметили, что можно из них построить некоторый конвейер. Вот здесь на самом
деле тоже такая идея прямо просится, потому что, смотрите, давайте транзакцию перерисую здесь.
Вот видите, сообщения prepare и commit, они написаны рядом, и смысл у них, конечно,
разный, но при этом они структурно очень похожи. И что происходит после первой фазы? После первой
фазы мы собираем коронный сертификат. Вот мы реплика, мы накопили коронный сертификат из
prepare, который означает, что на большинстве честных транзакций. А потом мы совершаем еще один раунд
коммуникации и накапливаем уже два f плюс один коммитов, и фактически мы собираем коронный
сертификат, где каждое сообщение говорит, что у отправителя этого сообщения есть коронный
сертификат. То есть мы собрали такой коронный сертификат, коронного сертификата. Так вот,
если абстрагироваться от смысла этих фаз, о том, что здесь мы что-то понимаем, здесь мы
там... Здесь мы понимаем, что на большинстве, здесь мы понимаем, что большинство понимает,
вот если от этого абстрагироваться и просто посмотреть на формальную структуру, то вот так и
хочется сказать, что мы возьмем для слота S такую картинку и ниже приложим картинку для слота S
плюс один, а выше для S минус один. И когда мы проходим через вторую, через первую фазу для
слота S и собираем коронный сертификат первый, то мы могли бы вместе с этим собрать коронный
сертификат, кормовый сертификат для слота S-1. Ну и вот так дальше.
Если смотреть на PBFT, можно увидеть, что здесь хочется сделать конвейер.
А теперь вспомним про биткоин. И вот тут нам знание биткоина потребуется.
В биткоине у нас вообще лога не было. И не было слотов. У нас вместо этого был блокчейн.
Он начинался с некоторого джинезис блока B0. Дальше ROS, ROS, ROS. И теперь...
Давайте нарисуем сеть сначала. Вот сеть. Реплик этого самого блокчейна.
В эту сеть можно было свободно приходить, свободно уходить.
Алгоритм работал в модели permission-less. Собственно, от этого все различия и появлялись.
Каждый узел был репликой этого самого блокчейна, и каждый узел получал транзакции от пользователей.
А дальше они распространялись гостепротоколом.
Ну и вот какой-то блок посередине, который получал зеленую транзакцию красную, он строил из них блок
и хотел в этот блокчейн свой новый блок с двумя транзакциями добавить.
Вот у этого узла появлялся блок с красной и зеленой транзакцией.
Ну а дальше, как мы решали, кто именно из вот этих вот узлов в сети добавит свой блок,
потому что у каждого узла он мог быть свой. Для этого мы разыгрывали это право в лотерею с помощью
proof-of-work. Мы решали пазл, который выглядел следующим образом. Мы брали хэш, криптографический
SHA-256 от SHA-256, от заголовка блока, в который входил хэш-поинтер, то есть хэш предшествующего
блока, которым мы цеплялись. Входил хэш корень дерева меркла всех транзакций в блоке и нонс.
Вот лотерейный беретик, который мы ищем. И мы хотим, чтобы хэш от этой конкатинации был маленьким,
то есть он начинался с некоторого количества нулей. Сложность этого самого пазла. И если какой-то узел,
который заинтересован, и каждый узел, который был заинтересован в том, чтобы добавить очередной блок
блокчейн, решал этот пазл. То есть он перебирал нонс, потому что, кроме перебора, никакой разной
стратегии не было. И если он находил этот нонс, то он сразу распространял его по сети.
Вот этот узел он назывался майнером, ну и сам процесс майнинга. У нас была проблема с тем,
что два узла, два майнера могли найти разные продолжения блокчейн.
И давайте вспомним, каким образом мы вот эту ситуацию разрешали. У нас возник форк. Два блока
здесь абсолютно равноправны, оба из них имеют право. Оба из них принадлежат этому дереву блоков
уже. Это перестала быть цепочка, конструкция стала деревом. Мы должны разрешить этот форк выбрать
одну из продолжений. Для этого мы что делали? Мы продолжали майнить. Вот каждый узел, каждый
майнер, который хотел добавить свой блок, он в текущем дереве выбирал, во-первых, самую длинную
цепочку. Ну а если у нас несколько продолжений, одинаковые длины есть, то мы просто выбирали ту,
про которую мы узнали раньше. И мы майнили за ней. Потому что, когда мы решаем этот пазл,
мы цепляемся к какому-то конкретному блоку. И, с одной стороны, мы по-прежнему играем в лутерею,
то есть мы пытаемся стать лидером в этом раунде, добавить свой блок. А, с другой стороны, продолжая
этот майнинг, мы своим процессорным временем голосуем, своим хешрейтом голосуем либо за одну,
либо за другую цепочку. И вот тут и нужно увидеть пайплайнинг. То есть, с одной стороны, мы играем
в лутерею, а, с другой стороны, мы придавливаем своим перебором предшествующую историю. Если мы
найдем нонс, то он же... Какой смысл имеет? Он доказывает, что наш новый блок следует за каким-то
другим конкретным блоком. Вот новый блок B следует за блоком конкретным B'. А в этом конкретном блоке
B' уже есть... У него тоже есть хешпойнт-разголовки. То есть наш нонс доказывает, что мы, на самом деле,
прицепились вот к такой цепочке. Ну и так можно продолжить до самого основания, то есть до блока B'.
Тот же нотис-блок. Ну вот это же форма конвейера, на самом деле. И теперь можно подумать, что если мы
вдруг заменим в PBFT наш лог с независимыми слотами и вот протокол независимый для каждого слота
на блокчейн с хешпойнтерами, то мы сможем эти кормные сертификаты накапливать более эффективно.
Другая идея, которая в биткоине может быть полезна нам здесь, это процедура выбора лидера. Вот здесь у
нас лидер есть... Слишком много маркеров накопилось. У нас здесь есть лидер, мы иногда его сбрасываем
и меняем на нового. Но вот эта процедура смены лидера, она очень тяжелая, очень громоздкая. В биткоине,
наоборот, эта процедура просто встроена в протокол в быстрый путь. Но этот путь не очень быстрый,
потому что раз 10 минут. Но тем не менее, мы просто в каждом раунде выбираем нового лидера с помощью
proof-of-work. Это еще одно место, где мы сегодня сможем PBFT ускорить. План дальше такой. Мы алгоритм
вспомнили, теперь нужно все эти детали совместить. Смотрите, у нас есть здесь artiting primary,
здесь у нас есть просто случайный лидер для каждого раунда. Идея отсюда можно перенести сюда. Здесь у
нас есть накопление кормных сертификатов, здесь у нас есть для этого хэшпоинта, которые могут
делать это более эффективно. Здесь нет вообще кормных сертификатов, но здесь есть nonce. И он сам
по себе доказывает, что над веткой работает много узлов. Так же, как и здесь, кормный сертификат
доказывает, что много честных узлов проголосовало за одну или другую транзакцию. Только здесь
кормные сертификаты в пределах раунда могут быть только одним в PBFT. Потому что кормы пересекутся
по одному честному узлу. В биткоине в пределах одного раунда, так условно, за одним блоком может
быть два разных блока, то есть два разных nonce. И вот ровно поэтому биткоин теряет finality. То есть
теряет возможность закометить блок. Всегда можно переманить альтернативную цепь. Мы хотим
воспользоваться хэшпоинтами для пайплайнинга, но, конечно, мы не хотим использовать nonce в таком
виде, потому что они нам помешали. Ну и вообще, какой из двух подходов мы выберем? Потому что
нужно от этого вообще исходить. Мы выберем в нашем протоколе hotstuff permission подход. То есть
мы будем фиксировать число реплик. Почему мы этого хотим? Мы хотим этого, потому что мы хотим
иметь понятие коммита. Мы хотим, чтобы какие-то блоки фиксировались в истории. У нас будет
блокчейн, ну точнее дерево блоков, но при этом блоки там будут фиксированы в какой-то момент.
И перемайнить уже смысла слова это не имеет. Ну, в общем, сделать альтернативный форк уже
будет нельзя. Казалось бы, мы получаем что-то потенциально менее децентрализованное, но с другой
стороны, если мы сможем избавиться от этого тяжелого view changer, то мы сможем масштабировать
наш протокол на большее количество реплик, ну там на сотни. А с другой стороны, если мы говорим про
децентрализованный permissionless подход, где число реплик может быть вообще произвольным, то кажется
все равно такие подходы, они скатываются в какую-то децентрализацию. Ну почему? Если вы фиксируете
хэш-функцию, фиксируете пазл, то можно построить железку, которая будет просто на схеме его
реализовывать. И тот, кто построит больше таких железок, купит их, получает преимущество большое.
У него концентрируется этот хэш-рейд. Если вы замените этот пазл на какой-то более хитрый,
но там на рендомизированный, то все равно кажется, это не сильно поможет, потому что если участников
станет слишком много, то они станут редко выигрывать, у которых у них уменьшится, поэтому они снова
будут организовываться в пулы, возникнет централизация в той или иной степени. Ну, тут можно разные
юристики выдумывать, но в общем, это все довольно уязвимая конструкция. Если мы говорим про, если мы
говорим здесь не про proof of work вообще, а скажем, proof of stake, ну это тоже форма централизации, у кого
больше денег, тот и решает, какая история продолжится. С одной стороны, да, как бы система ведет себя
честно, она следует за честными узлами, но при этом все равно число реплик, фактически, которые принимают решение,
довольно невелико. Так что если мы оптимизируем эту конструкцию, то в принципе нам такого подхода
должно хватить. Так что на то, что сейчас произойдет, можно смотреть так. Можно считать, что это PBFT,
в который принесли дерево блоков, принесли хэш-поинтеры для пайплайнинга, и поэтому вместо лога
получилось дерево. И принесли ротацию лидера на каждый раунд, чтобы упростить этот протокол. А можно
смотреть иначе. Можно смотреть на протокол hotstaff, который сейчас будет как на консенсус на комото,
то есть на консенсусе биткоина, где зафиксировали число реплик, и вот эти нонсы заменили на
кормные сертификаты. То есть то, что мы сейчас построим и так, и так, с разных сторон выглядит по
разному, но по сути является просто некоторой композицией идей параллельных из двух разных
подходов. Как я обещал, чтобы рассказать про этот протокол, в принципе ничего знать не нужно,
поэтому давайте мы сотрем что-нибудь. Почти все сотрем. Да, вьюченч нам не нравится, мы хотим от него
избавиться, мы его точно сотрем. А определение комит у нас, конечно, тоже будет другое. Да,
почему hotstaff, кстати, я не рассказал, кажется. Вот есть эфир, и в нем используется сейчас proof
of work. В proof of work нет определения finality. Блоки не фиксируются навсегда. И вот есть желание у
разработчиков этого эфира сделать эфириума сделать так, чтобы надо блокчейном построить
протокол, который все-таки будет финализировать блоки. Идея этого протокола была предложена в
2017 году. Кажется, что скоро собираются это внедрять, и идея называется Casper. Доброе
привидение. Доброе, потому что оно привидение, поэтому оно отпугивает плохих людей, и оно доброе,
а добрые люди с ним дружат. Поэтому Casper хорошим поможет, а злоумышленником помешает. Вот hotstaff
это такой маленький чертенок из истории про Casper. То есть это некоторая альтернатива этому
протоколу. Ну вот, мы собираемся в hotstaff строить дерево-блок. То есть у каждой реплики... Да,
мы фиксируем число-реплик снова. У нас permission protocol. Число-реплик оптимальное. Каждый из реплик
хранит дерево-блок. Каждый блок привязан к некоторому раунду. В каждом раунде появляется
некоторый блок. И в каждом раунде этот блок формируется лидером этого раунда. А лидеры в каждом
раунде свои. Вот опять мы считаем... Давайте считать, что в раунде K у нас лидер K по модулю N. И как у нас
будет выглядеть протокол, по крайней мере общая схема его работы, пока без деталей. Какие там
сообщения, как они вообще летают по сети. Итак, у нас жизнь этого блокчейна делится на раунды.
В раунде K, например, лидером является вот эта реплика. Она смотрит на свой блокчейн,
на это дерево. Каким-то образом строит там новый блок, который к чему-то цепляется. И этот блок
рассылает другим репликам. Реплики, получая этот блок, либо голосуют за него, либо отвергают. Каковы
именно правила голосования, поговорим позже. Пока будем считать, что реплики довольны. И они в этом
случае голосуют за блок, отправляют сообщение vote. Но отправляют его не лидеру раунда K, а лидеру
следующего раунда. Вот это мы отправляем сам блок в раунде K, а лидеру следующего раунда,
когда реплика, проголосовавшаяся за этот блок, отправляет сообщение vote, где говорит, что в раунде
K она проголосовала за блок с хэшом H. Это некоторый аналог хэшпоинтера. Итого, у нас в раунде K
появился вот такой блок в блокчейне. И в начале следующего раунда у лидера этого раунда,
вот второй реплик на данном рисунке, по возможности собирается кормный сертификат 2F плюс 1, одинаковый
vote. То есть большинство честных узлов проголосовало за вот такое продолжение блокчейна. 2F плюс 1, vote
Kh. Ну, разумеется, все голоса подписаны, как обычно. Кормный сертификат. И вот этот кормный
сертификат будет служить тем самым нонсом. Вот в биткоине, когда мы публиковали новый блок,
мы должны были к хэшпоинтеру приложить нонс, который доказывает, что действительно мы проделали
работу, и вот блок пристраивается за тем блоком, на который мы ссылаемся. Вот здесь, чтобы лидер
раунда K плюс 1 прицепился вот к этому блоку, продолжил эту ветку истории, он должен к своему
блоку приложить вот такой вот сертификат. То есть его хэшпоинтер блока — это и есть кормный
сертификат. Тут буквально одно и то же. Хэшпоинтер — это кормный сертификат, потому что в кормном
сертификате есть хэш предшествующего блока в каждом vote. Рисовать это я буду так. Я буду
рисовать черный ромик. Это кормный сертификат. И когда мы публикуем новый блок на месте лидера
раунда K плюс 1, когда мы строим новый блок, то мы в него добавляем этот самый кормный сертификат.
Прошу прощения. Окей, копаюсь, есть ли вопросы? Или все понятно? А он не выбирается, он вращается
так же, как и раньше. Но он просто вращается на каждом раунде. То есть в PBFT мы выбирали лидера,
и он там долгое время работал, если он честный. Сейчас мы это хотим немного упростить, сделать
чуть менее эффективно в этом месте. В принципе, это можно потюнить, в конце концов. Но сейчас мы
для простоты скажем, что у нас лидер вращается каждый раз, как в биткоине. Правда, в биткоине он
выбирался случайным, потому что число реплик неизвестно. Здесь мы зафиксировали число реплик,
поэтому просто назначаем следующим. Вот этот следующий лидер в раунде К плюс один накапливает
этот сертификат и его прикладывает к своему блоку. После чего снова рассылают его всем.
Сейчас, секунду, я картинку дорисую. Ну и тут снова происходит то же самое. Реплики голосуют за
этот блок и отправляют свои голоса следующему лидеру. Лидеру следующего раунда.
И у лидера следующего раунда появляется новый хэшпоинтер. Следующий сертификат, который
подтверждает, что большинство честных узлов проголосовало за эту ветку. Ну и вот блокчейн,
он так дальше вглубь растет. В чем проблема? Лидер раунда К плюс два, он просто византийский,
у него накопился сертификат кормный, а ему просто не хочется эту ветку продолжать,
и он выбрасывает этот кормный сертификат. Что делать честным узлам? Ну, если честные узлы
не дождутся за некоторое время в текущем раунде нового блока от лидера текущего, то, видимо,
они могут перейти в следующий раунд. Это не проблема. Ну, точнее, тут нужно делать немного
аккуратнее, то есть нужно, чтобы все это делали более-менее синхронно. Поэтому нужно снова
собрать кормный сертификат перехода в следующую эпоху, в следующий раунд. Но это уже сейчас,
прямо сейчас не очень важно. Важно то, что как же они продолжат вот эту ветку. Ну вот, допустим,
мы эту эпоху скипнули, этот раунд скипнули, потому что плохой лидер, и вот мы переместились в раунд К
плюс 3. И как же мы собираемся прицепиться к этому блоку теперь? Чтобы к нему прицепиться,
нужно иметь вот такой хэшпоинтер. Ты спрашивал про нонсы, где здесь нонсы, да? Здесь нет нонсов,
потому что, еще раз, у нас была аналогия, что нонс в биткоине подтверждал хэшпоинтер. Нонс,
он доказывал, что большинство сети работает над этой веткой. Здесь у нас вместо этого нонса
и пруфуфворка просто кворумные сертификаты, которые доказывают, что большинство сети голосует за
вот эту ветку. То есть у нас от биткоина остались хэшпоинтеры, но мы эти хэшпоинтеры подтверждаем
теперь не процессором, не перебором кэшей, а просто голосами, потому что у нас число
реплик фиксированное. В биткоине это почему мы так делали? Потому что у нас были не фиксированные
кворумы, у нас были кворумы в процессорах. Теперь у нас кворумы обычные в голосах, и поэтому
сертификатов достаточно. Так вот, что делать в раунде K plus 3?
Ну нет, в K plus 3 в раунде у праймари нет. У праймари вот такой блокчейн, и пресс-сертификат
не знает ничего. Волты ушли сюда. Можно придумывать другой протокол, но в этом протоколе узлы
просто делают форк. Какая-то ветка заглохла, потому что очередной участник оказался
злоумышленником. Но не беда, что мы можем сделать? Мы можем просто из опубликованного блокчейна
изъять кворумный сертификат, уже известный, и переиспользовать его. Да, вот, кстати, в этом
блоке теперь тоже есть кворумный сертификат, но понятно, что все это продолжалось. Так вот,
что сделает участник лидер раунда K plus 3? Он построит новый блок и переиспользует вот этот
кворумный сертификат. Мы попали в раунд K plus 3. Почему мы стали лидером в раунде K plus 3?
Потому что нам большинство узлов сказало, что тайм-аут. Потому что нужно пропускать такие раунды,
где ничего не происходит. И мы делаем форк. Но теперь форк это неплохо, форк это наша цель,
потому что она позволяет нам обходить заглохшие ветки. Окей, значит, получилось, да? Я бы сказал,
что это практически весь алгоритм. Осталось только разобраться, какие блоки мы считаем
закоммитченными и каковы правила голосования. То есть когда мы отправляем голос. Вот прелесть
протокола, что это более-менее единственное сообщение, которое у нас есть. Ну и считаем
вот. Потому что мы не можем продолжить эту ветку, потому что мы не знаем сертификата,
а без сертификата нельзя сослаться на этот блок. У нас ссылка это сертификат.
Вот блок публикуется вот здесь вот. Вот он опубликован. Все за него проголосовали.
Вот этот узел накопил к органу сертификат и теперь можно использовать его как ссылку.
Вот да, но он его потратил, поэтому мы просто переиспользовали старый сертификат и сделали форк.
Что теперь нужно уточнить? Как именно мы голосуем и какие именно блоки мы считаем
закоммитченными? Ну давайте с коммитом начнем. Мы скажем, что блок закоммитчен,
если он трижды сертифицирован в подряд идущих раундах. Вот был опубликован блок B0. Для него
был собран сертификат, который использовался как ссылка, как хэшпоинтер в блоке B1, за который
снова проголосовало большинство честных узлов. Был собран сертификат, который был переиспользован
в блоке B2, для которого снова был собран сертификат. Вот трижды сертифицированный блок
объявляется закоммитченным. Заметим, что это свойство глобальное. Вот этот сертификат может быть
собран у византийского узла и, тем не менее, все равно это приводит к закоммитчиванию блока. То,
что этот сертификат может не наблюдаться никем, это отдельная история. Ну как в ПАКСОСе,
отдельные аксепторы тоже мало что понимают, но при этом определение коммита такое, что на
большинстве аксепторов проголосовало один и тот же проползл. Тоже глобальное определение.
Правила голосования. Правило 2. Вот мы реплика. Мы получаем в каком-то раунде K очередной блок.
Во-первых, мы голосуем за блоки строго монотонно по раундам. То есть мы помним последний раунд,
в котором мы голосовали за блок и голосуем только если у нового блока раунд больше.
Ну, похоже на обычный ПАКСОС. Правда, смысл немного сложнее, но не суть. Может быть,
на зачете поговорим с кем-нибудь. Если кому-то повезет, то сможем разобраться,
откуда такое правило берется, какова его интуиция. Вот 2 правило, оно более сложное в определении,
зато интуицию пояснить проще, мне кажется. Введем понятие locked round. Locked round для дерева блоков.
Вот у каждой реплики есть дерево. И что мы сделаем? У каждого блока в этом дереве есть
какой-то раунд, в котором блок был построен. Ну, я вот откуда-то нарисую. 7, 8, 10, 9, 11.
Что мы сделаем? Мы возьмем все листья и отступим от каждого листа два шага вверх. Посмотрим на всех дедушек.
Вот это не высота, это раунд, в котором блок появлялся. Они могут быть на одинаковой
высоте с разными раундами. Вот здесь нарисована не высота блока, а раунд, в котором он появился
в этом дереве. Так вот, мы возьмем все листы, отступим два шага вверх и выберем из этих дедушек,
из этих блоков, блок с максимальным раундом. Вот этот раунд объявим Locked round. И мы скажем,
что блок, мы, реплика, голосуем за блок B, если раунд блока, к которому цепляется блок B,
не меньше, чем Locked round. Повторюсь, это раунд, в котором объявился блок.
Вот такой сценарий был уже нарисован. Ты хочешь, чтобы я написал 11 или 12? Здесь что-нибудь будет
написано, давай я не буду угадываться. Что? Не очень понимаю твой вопрос. Числа имеют значение,
потому что с помощью этих чисел определяется понятие Locked round. Ты хочешь, чтобы я числа здесь
аккуратнее подобрал? Вот здесь 8, 9, 10 пропущен, 11 какой-нибудь. Чем это продолжается? Ну хорошо,
это справедливое замечание, не очень нужное сейчас, но справедливое. Да, я согласен с тобой.
Мы берем дерево блоков, в этом дереве есть ссылки, хэшпоинтеры, такие сертификаты, и каждый блок
был построен в некотором раунде. Мы взяли листья, все отступили от каждого листа два шага назад,
получили набор блоков. Отступили отсюда два шага, получили вот узел, отступили отсюда два шага,
получили вот узел. И говорим, что Locked round это максимальный по раунду дедушка в этом дереве.
То есть мы из этих блоков выбрали максимальный по номеру раунда. Нет, комит пока не нужен. Это
просто правило голосования для дерева. У нас есть дерево, и мы отступаем дважды вверх.
Да, про закомитченность давайте я еще раз уточню, что мы говорим, что блок закомитчен,
если он на него, он трижды сертифицирован в подряд идущих раундов. Это важно. Ну вот,
каков физический смысл этого правила? Ясно ли это? Это round pair. Даже не знаю, как сказать. Это
round блок, на который ссылается B. Но вот блок, он же к чему-то цепляется, у него есть какой-то
хэшпоинтер. Вот мы смотрим на round блока родителя, к которому мы цепляемся. И вот этот round должен
быть не меньше, чем Locked round для дерева нашего. Что? Постри, пожалуйста, я не разобрал. Вот есть
реплика, у нее есть дерево, она получает от лидера текущего раунда очередной блок. Смотрит,
если она не голосовала за блоки из больших раундов, больше либо равных. Сейчас. Если она
голосовала за раунды, больше либо равные текущему раунду текущего блока полученного, то не голосует.
Если не голосовала, то запоминает новый максимум и голосует. Но только если Locked round дерева этой
реплики не больше, чем round родителя, к которому цепляется вот в дереве. Это блок B. В чем смысл,
в чем интуиция второго правила? Она очень простая. Но она немного произвольная. Тут есть какая-то
магическая константа странная. Вот мы отступаем здесь на два шага, то есть мы берем дедушку и
требуем трех сертификатов. Похоже на какой-то произвол. Какая-то магическая константа 3 здесь.
Но если вот об этом не думать пока, мы к этому вернемся еще, то смысл должен быть понятен. Вот
здесь, по крайней мере. Мы запрещаем глубокие форки. Мы не можем форкнуться далеко от листьев. Мы
какие-то ветки можем альтернативные продолжать, но не можем делать это на четыре шага вверх.
А правило commit здесь очень естественное, потому что у нас здесь собрался коронный
сертификат. Здесь коронный сертификат коронного сертификата. Ну и здесь тройной такой коронный
сертификат. В общем, это вот pipeline, который был вот здесь. Ну что дальше? Мы уже здесь избавились
от выбора лидеров, уже приятно. Осталось доказать, что определение committ вот такое разумно. Что
значит разумно? Вообще понятие разумности в каждом алгоритме свое. Если мы говорим про
multipax, то понятие committ означало... Мы доказывали, что если слот закоммитчен, то новый лидер
перезаписать его не может. В RAFT мы доказывали, что если мы команду закоммитили, то она переживет
смену эпохи. Вот здесь мы покажем, что если... Точнее, не так. Что у нас вообще нет смены
эпохи, логов нет, перезаписи нет. Мы покажем, что два любых закоммитченных блока просто лежат
в дереве блоков на одной цепи. Ну и сотрем VFT.
Теорема. Мы докажем немного более сильное утверждение. Будет звучать так. Пусть у нас
есть блок B0. Он закоммитченный. То есть для него собран сертификат C0, который был
использован в блоке B1, который тоже был сертифицирован. И этот сертификат в качестве
хэшпоинтера был использован в блоке B2, который тоже был сертифицирован. И у нас есть
некоторый волнистый блок B, который просто сертифицирован. И блок, и раунд блока B с волной
не меньше, чем раунд закоммитченного блока B0. Вот тогда мы покажем, что блок B с волной
является потомком блока B0. Ну давайте какие-то простые случаи сначала разберем. Вот пусть раунд
сертифицированного блока B с волной просто совпадает с раундом блока B0. Что это означает? Это один
и тот же блок, потому что два блока сертифицированы, а сертифицированное значит, у них собрал скорбный
сертификат размера 2F плюс один. Значит, в пересечении есть по крайней мере нечестный узел. А значит, он должен
голосовать одинаково. Значит, это был один и тот же блок. Хорошо, второй частный случай. Раунд B с волной
равен раунду B0 плюс один. Что мы здесь можем заметить? Ну у нас понятие закоммитченности требовало,
чтобы раунды шли подряд. Поэтому если раунд блока B0 плюс один, это просто по определению
commit раунд B1. Ну и снова в одном раунде, если блок B1 и блок B с волной сертифицированы оба,
поэтому снова в этом случае мы получаем, что B с волной совпадает с B1, а B1 потомок блока B0.
Случай r волнистого блока равен rB0 плюс 2 понятно то же самое. Поэтому давайте перейдем к
содержательному случаю. Блок, раунд блока B с волной просто больше, чем раунд блока B2.
Смотрите, вот эти два блока B с волной и B2 были сертифицированы. То есть за
каждой из них проголосовало большинство частных участников. Вот нарисуем два
quorum. Это quorum для волнистого блока, это quorum для третьего блока в цепочке комитов.
В пересечении у нас, по крайней мере, F плюс один узел, по крайней мере один честный узел.
И этот честный узел проголосовал и за B с волной, и за B2. Вот нарисуем его таймлайн.
В каком порядке он мог голосовать за B с волной и за B2? По этому правилу голосования он голосует
строго монотонно по раунду. А раунд B2 меньше, чем B с волной, поэтому он сначала должен был
проголосовать за B2 и только потом за B с волной. Но чтобы проголосовать за B с волной, он должен
был убедиться, что parent B с волной не меньше, чем locked round. А locked round в этот момент уж точно
это максимум из всех дедушек, а мы знаем, что вот есть, по крайней мере, такой блок B2 и перед ним
еще есть B1 и B0. То есть мы знаем, что locked round в этот момент уж точно не меньше, чем раунд блока B0.
Да, получилось? Ну вот тогда из этих рассуждений мы и получаем, что round parent волнистого блока не
меньше, чем round B0. Ну вот, собственно, и все. Теперь мы берем в нашем утверждении B с волной,
пользуемся этими рассуждениями и переходим вот к такому же случаю, просто с раундом меньше.
Мы уменьшаем round. Ну и в какой-то момент мы свалимся вот в эти частные случаи и получим то, что нам нужно.
Да, прости, я не сказал этого. Конечно, да. Когда мы голосуем за блок, если он нас устраивает,
если он вписывает свои ограничения, то мы добавляем его в наше дерево. Ну что, значит, мы можем
подниматься от B с волной и мы не сможем перескочить блок B0. Мы находимся в его под дерево.
Ну вот и все. То есть мы действительно показали сейчас, что закоммиченные блоки лежат на одной цепочке.
Здорово, да? Но есть... вот алгоритм, кажется, гораздо проще, чем PBFT, но уж точно проще, чем PBFT.
Похож на биткоин по этой структуре. Мы строим дерево из блоков, там есть хэшпоинтеры, но поскольку у нас
теперь не proof of work и нонсе, а quorum-сертификаты, потому что есть фиксированный набор реплик и quorum
можно собирать, взаимоисключающие, то у нас появляется определение коммита. Это прекрасно,
но внимательный слушатель заметил бы давно уже, а где мы в этих рассуждениях использовали
магическую константу 3? Ну вот давай я вот эти правила и определение коммита немного скорректирую.
Я скажу, что locked round – это просто старший родитель, то есть я от листов отступаю только один шаг вверх,
и скажем, в определении коммита тоже хвостик обрежу. Скажу, что у меня достаточно двух сертификатов,
а не трех. Что же мне помешает провести те же самые рассуждения? Просто я вот длиной цепочки
пользовался где? Ну вот я сказал, что раз мы проголосовали за B-сволной, значит locked round был не меньше,
а locked round – это два шага назад, вот я сделал два шага назад, получил бы ноль. Если я locked round
в определении уменьшу константу на один, то мне нужно будет сделать один шаг, поэтому я и цепочку
коммита сокращу тоже на один. Поэтому кажется, совсем это утверждение про safety этого протокола
от этой магической константы 3 не зависит. Можно было сделать бы и 2, и 1. Или 4, ты верно меня понял,
или 4. Вот, давайте теперь подумаем, почему нельзя 1, 2, и 4. Это плохая идея будет. По-разному плохая,
ну давайте с четырех начнем, начнем это самый простой вариант. Ну сейчас, это вопрос какой-то
вкуса, но далеко и далеко. Вот 4 мы просто не можем себе позволить в таком протоколе.
Можно. Так мы же про это и говорим сейчас. Еще раз, я же сказал, что вот safety мы доказали,
и вот в этих рассуждениях мы нигде существенным образом 3 не использовали. Точнее, мы использовали
то, что здесь два шага вверх, и вот эта тройка согласована. Определение коммита согласовано
с правилом голосования. Ну подстроим и там, и там. Можно сделать 4 сертифицированный,
единошно сертифицированный, дважды сертифицированный. Вот, смотрите, мы не можем взять 4, потому что чтобы
блок закомитивался, нужно чтобы в четырех подряд идущих раундах за нас за цепочку проголосовала
большинство. Вот если у нас число реплик 3, f плюс 1, то гарантированно будет 3 подряд идущих
честных где-то. Что? Ну когда-нибудь. Вот, а 4 уже никогда не может не быть. Окей, что?
Да, ну мы же по кругу ходим. Это, например, можно предустрелить, например, от четырех узлов и одного византийского.
Ну вот, мы здесь забили, точнее, на продолжение блокчейна. Вот, если 4 не стоит, ну 4 может быть не
стоило, потому что как бы и сменчивая цепочка работала, зачем как бы медленнее делать? Почему нельзя 1? Вот мы
говорим, что блок закомитчен, если для него собрался сертификат. И мы говорим, что locked round для дерева это просто
старший лист. Почему так нельзя делать? Кто он? Какой лидер? Тут много лидеров, они на каждом раунде свои. Вот,
смотрите, если мы скажем, что commit block это просто сертификат, то что значит commit? Что можно новые
блоки добавлять только в под дерево. Ну а теперь представим, вот у нас блок в раунде K плюс 1, он вроде как закомитчен,
потому что для него сертификат собрался. Но этот сертификат, византийский узел, лидер раунда K плюс 2,
никому не сказал. Нам нужно форкнуться, переиспользовать этот сертификат. Но мы не можем форкнуться,
потому что здесь parent от этого раунда будет в раунде K, а locked round будет K плюс 1. Мы просто запрещаем
себе форки. Вот мы хотим форкаться, ну хотя бы на шаг вверх. Ну и тогда давайте сделаем здесь
вот два сертификата и locked round определим как старший родитель для всех листов.
Ну раз три, а не два, то видимо не очень здорово. Есть какие-то проблемы.
Но этот случай, он не простой уже, точнее он сложнее, чем два вот этих 4 и 1, они были тривиальными.
Нарисуем такую картинку. У нас есть вот блок в раунде K, он оказался сертифицирован,
был построен блок в раунде K плюс 1, он оказался сертифицирован, за него проголосовал большинство
честных. Но в раунде K плюс 2 так случилось, что в раунде K плюс 2 все было тоже в общем-то хорошо,
в смысле лидер был честного, не византийским. Он построил блок, добавил его в свой блокчейн,
а потом, я не знаю, он перезагрузился, например, залип надолго. И он не успел до тайм-аута в этом
раунде этот блок никому раздать. Но у него он есть. Вот нарисуем всю сеть. Вот здесь есть какое-то
количество, не знаю, византийских или мертвых, ну пусть даже византийских, чтобы они мешали,
вот тормозили честный узел. Вот здесь вот F византийских и есть вот этот зеленый,
который построил этот блок. Наступает раунд K плюс 3. Что делают честные участники? Вот честные
участники видят вот такой блокчейн. Они не могут продолжить его лист, потому что у них нет
сертификата. Лидер раунда K плюс 3 какой-то, он не может продолжить эту ветку, поэтому он
форкается. Он хочет форкуется от блока K. Мы в раунде K плюс 3 хотим переиспользовать вот этот
сертификат и сослаться на вот этот блок. Отправляем его всем и у лидера раунда K плюс 4 голоса
скапливаются. Вот для того, чтобы получился кормный сертификат, нужно, чтобы мы собрали на лидере K
плюс 4 два F плюс 1 голос за вот этот блок. У нас F византийских, они не будут голосовать за этот
блок. Поэтому все остальные должны проголосовать. Вот почти все проголосуют, кроме Зеленого,
потому что если у нас локт раунд это старший parent, то у всех старший parent это K и от него
можно форкаться. А у Зеленого старший parent это K плюс 1. И он говорит, я не буду голосовать этот
блок, потому что что-то глубоко слишком. То есть у нас где-то застрял такой невидимый блок,
который не продолжился и не опубликован как следует. И он мешает форкаться. На каких-то
узлах есть такая скрытая веточка, скрытый листик, который никем не наблюдается. И вот эта магическая
константа 3, она нужна для того, чтобы ровно форкаться на два шага вверх. Да, может и отправляют,
но просто остальные уже проголосовали в раунде K плюс 3 и кого это волнует? Мы же голосуем монотонно
по раундам. А зачем монотонно? Это сложный вопрос на зачете. То есть он не сможет уже сертифицировать
этот блок, потому что уже многие проголосовали, но почти все проголосовали за K плюс 3. То есть он
единственный, кто будет за него голосовать вообще-то. То есть вот это 3 нужно, чтобы эту скрытую ветку
невидимую обойти и форкнуться относительно нее на два шага вверх. А больше не нужно, но и больше мы не
можем. Вот я не знаю, довольно затеяльево устроен мир, что ровно так нужно делать. Вот ровно 3. Ну как
бы 3 — это константа такая важная для византийских отказов, поэтому не удивительно, но все равно
удивительно, что только так и работает. Ну что, вот такой протокол. Вращаем лидера на каждом,
такой максимально простой симметричный протокол с одним типом сообщений, с одним типом коронного
сертификата с блокчейном. С одной стороны, это PBFT, в котором сделали пайплайнинг через
коронные сертификаты и в котором сделали ротацию лидера на каждом раунде. Ну или это биткоин,
в котором заменили хэшпоинтеры, в котором вместо нонсов и майнинга сделали голосование обычное и
коронные сертификаты, потому что зафиксировали число узлов. Но с какой стороны не смотри,
вот получается что-то. То есть можно с разных сторон смотреть, но вот исход примерно один,
и результат этот получен аж в 2019 году. Не знаю, почему так получилось, но кажется,
что без понимания PBFT и биткоина выдумывать с нуля это было сложнее. Хотя, может быть и нет.
Но по крайней мере видно, как можно было это придумать, глядя на PBFT и на биткоин вместе.
Ну а клиент здесь довольно перпендикулярно. Это все конструкции, потому что мы здесь не про
блокчейн, не про компьютер, говорим о транзакции, все это криптография, мы говорим просто про то,
транзакции упорядочивать. Ну это то же самое, что и в биткоине, та же самая идея. Мы выбираем
каждый раз какого-то случайного лидера, здесь просто перебираем их по кругу, поэтому мы
периодически проходим через честных. Если у нас отказов византийских не больше чем F,
то мы вот две трети раундов проводим в честных узлах, а они добавляют транзакции в блокчейн.
Так что тут вся интуиция наследуется, тут ничего принципиально нового
как раз и нет, здесь просто комбинация известных идей. Ну что ж, на этом наш курс заканчивается,
мы дожили до конца, спасибо вам большое, что были с нами, и мы через 10 минут поговорим про то,
что вообще было в течение семестра, я попытаюсь какую-то интуицию вместе собрать, но вы тоже
можете вспомнить что-нибудь, что вам запомнилось, и завтра мы вот в 11 утра проведем зачет.
