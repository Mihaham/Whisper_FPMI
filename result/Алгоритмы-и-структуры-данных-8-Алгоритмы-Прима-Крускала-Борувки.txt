Так можно начинать? Напомните номер лекции, пожалуйста, я не помню. Восемь, наверное. Спасибо.
Так, я хочу сделать небольшое дополнение к лекции про кратчайшие пути. Важная идея,
я сейчас ее быстренько освещу. Двусторонний BFS расскажу. Ну раз BFS, то, значит, граф невзвешенный.
Вот. И задача найти кратчайший путь из S в T. Ну то есть и начало, и конец фиксировано. То есть
это как во звездочке, да только невзвешенный граф. Вот. Смотрите какая идея. Простая очень. Давайте
мы запустим параллельный такой BFS с обеих сторон. И из S, и из T. То есть вот мы знаем какой-то
начало и конец S и T. Давайте мы потихонечку запустим вот эти вот две очереди наши. Одна
будет находиться в расстоянии из S, другая из T. И вот когда они, то есть они как-то вот так
будут по слоям обрабатывать наш граф. Да, вершины расстояния 1, 2, 3 и так далее. И вот когда они
впервые пересекутся, тогда мы завершимся и скажем, что ну грубо говоря, вот это вот, то есть отсюда
до сюда, плюс отсюда до сюда, это кратчайшее расстояние. Вот такая простая идея. Давайте я
сейчас формализую. Ну, до какой-то степени. Значит запускаем BFS из S по прямым ребрам,
и из T по обратным. Ну, потому что из S мы как бы идем вперед, используя обычную ориентацию ребер,
а в T мы, наоборот, хотим прийти. То есть мы используем, то есть как бы у нас стрелочки такие.
Значит, чтобы нам идти из T, мне нужно сначала инвертировать направление всех ребер, ну как
обычно, обратные ребра построить, то есть не вот такое, а такое его сделать, и соответственно идти
справа налево. Вот по итерациям. Идем по итерациям. Ну, итерация это вот как раз вот эти облачка. Сначала
нашел совершенно расстояние 1 отсюда, потом нашел совершенно расстояние 1 отсюда, на расстоянии 2,
на расстоянии 3, извините, 2 опять, да, 3, 3, 4, 4 и так далее. Значит, пусть после D этой итерации
облачка пересеклись. То есть мы нашли какую-то вершину, которая находится на расстоянии не
больше, чем D от S и не больше, чем D от T. Ну я напишу, слои пересеклись, пересеклись. Вот. Тогда ответ,
это минимум по всем вершинам. DIST SV плюс DIST VT. Вот это мы для многих вершин знаем, это мы для
многих вершин знаем. Ну и соответственно вот для тех вершин, где мы знаем и то и то, мы складываем
вот эти две суммы и получаем, ну как бы ответ. То есть мы можем дойти вот S до куда-то, потом отсюда
до T. Вот. Значит, почему это верно? Почему это верно? Ну смотрите, очевидно, что вот эта штука не
больше, чем 2D. Эта штука не больше, чем 2D, потому что у меня D-T слои пересеклись. Значит, есть вершина,
находящаяся на расстоянии не больше, чем D от S и на расстоянии не больше, чем D от T. Ну значит,
просто сумма вот этих двух величин будет не больше, чем 2D. Значит, давайте тогда покажем,
что если есть какой-то более короткий путь длины меньше, чем 2D, то мы его тоже увидим на самом
деле. Пусть есть какой-то путь длины меньше, чем 2D. Вот есть S, вот есть T, вот какой-то такой путь.
Давайте рассмотрим на нем D-ту вершину. То есть давайте отступим от S, D-рёбер, а в конце останется,
что получается, меньше, чем D-рёбер, рассуммарная длина меньше, чем 2D. Ну и все, смотрите, раз эта
вершина находится на расстоянии D от S-ки, значит она лежит, ну то есть она лежит где-то вот здесь. То
есть мы до нее посчитали правильное расстояние из S. И раз здесь меньше, чем D, то мы, наоборот,
от T до нее тоже нашли правильное расстояние, ну потому что BFS правильно все находит. Значит,
в ответе мы учтем вот этот путь, потому что мы от S до XA умеем добираться и от XA до T. Значит,
все такие пути мы разберем, ну и поэтому этот минимум будет равен тому, чему нужно. Вот,
профит. Понятно? Хорошо. Ну и соответственно, на самом деле, эту же штуку можно обобщить на алгоритм
D-экстры и на звездочку тоже. Значит, ну в D-экстре более-менее что-то похожее происходит. Если у
вас есть выделенные начальные и конечные вершины, давайте мы запустим опять параллельно D-экстру здесь,
ну как бы из S и в T, то есть на графе по обратным ребрам, там у нас будут две кучи храниться,
ну и давайте извлекать короче элементы, извлекать вершины из куч параллельно в каком-то смысле. И
когда какая-то вершина удалится из обеих куч, мы считаем, что мы нашли кратчайший путь. То есть там,
ну как-то примерно так же граф обходится, у меня расширяется множество вершин, до которых известны
ответы. Когда они пересеклись, мы считаем, что вот как раз, в общем, когда что-то пересеклось,
мы перебираем все такие пути, выбираем из них минимальный. То же самое в азвездочке. Ну,
азвездочка это какая-то надстройка на D-экстре, то же самое, можно пустить азвездочку из S в T и из
T в S, они там в каком-то порядке все обрабатывают, и когда они состыкуются, когда они пересекутся в
какое-то вершине, можно сказать, что ответ найден. Вот. Значит, это все полезно в случае, когда у вас граф
очень связный, да, вот я хочу сказать слово expander, наверное это будет громко здесь сказано, давайте на
примере каком-нибудь, когда вы решаете какую-нибудь головоломку типа там кубик рубика, ну, может быть,
не 3 на 3 на 3, но хотя бы 2 на 2 на 2, и у вас, если вершины вы кодируете в состояние, то есть
конфигурацию вашей головоломки, то понятно, что у вас из каждого состояния довольно много переходов,
ну там в кубике можно двенадцатью способами повернуть какую-то грань, то есть выбираете какую
грань и в двух сторон вращаете, почасовой или противчасовой. Поэтому у вас каждая вершина как бы
имеет двенадцать исходящих ребер, и так для каждой работы, да, у вас граф регулярный, у каждой вершины
одинаковой степени, поэтому понятно, что если вы пускаете какой-то обычный BFS, как он работает, вот
сначала у вас есть, ну то есть у вас есть там стартовая конфигурация, есть конечная, например,
собранный кубик, то есть желаемая вами конфигурация головоломки, вот. Вы берете и каждый раз от каждой
вершины добавляете в очередь по двенадцать вершин, то есть на первом условии у вас будет
двенадцать вершин, давайте я А это назову, на втором будет А квадрат, потому что каждый из них даст еще
по двенадцать, ну там по одиннадцать, ну неважно, вот, и так далее. У вас, короче, так экспоненциально
растет размер того, что вы перебираете, вот. И если вы так делаете, то чтобы найти вершину T,
которая находится там на каком-то X там слое, у вас вот здесь вот переберется а в степени X вершин,
вот. А если бы вышли с двух сторон параллельно, да, вот здесь нашли облачка размера А, здесь А,
а тут А квадрат, тут А квадрат, вот, то пересеклись вы бы примерно на X пополам-то слоя, и здесь,
соответственно, было бы только А в степени X пополам вершин, что, ну, все-таки сильно лучше, да. Все-таки
А в степени X сильно больше, а в степени X пополам, вот. Поэтому, как бы довольно годная идея, именно
когда у вас вот так экспоненциально взрывается граф, то есть когда у каждой вершины большая степень,
и она поражает много новых вершин, тогда вот лучше с двух сторон идти, вы просто меньше вершин
обойдете. Такая идея. Ау, ой, там прекрасная задача в контесте есть, удачи вам. Так, хорошо, значит,
теперь непосредственно к сегодняшней теме про минимальные остовы. Давайте пару определений,
сегодня давайте только неориентированные графы. Давайте напишу, что сегодня неориентированные
графы. Мне будет лень писать слово неориентированный постоянно, у меня сегодня всегда все неориентировано.
Значит, если G это граф, и H это тоже граф, то H называется под графом G, если V штрих
это подносит V, а E штрих подносит E. То есть вы оставили какие-то вершинки, какие-то ребра,
произвольное подношество. Значит, дальше, если при этом, если при этом V штрих равно V, то H
называется остовным под графом, то H остовный под граф G. То есть если вы вершины не удаляете,
то это остовный под граф называется. Вот, и если еще при этом H это дерево, то есть связанный граф
без циклов, тогда это остовное дерево. Дерево, то есть связанный граф без циклов, то H это остовное дерево.
Ну, например, давайте какой-нибудь нарисую. Вот есть такой большой граф, что-нибудь вот такое. Я
могу здесь выбрать следующий остов, точнее, остовное дерево. Вот, ну, это ребро я обязан взять,
потому что без него, потому что это мост на самом деле, мосты нельзя не брать. Вот, ну, а здесь
могу взять, например, что-нибудь вот такое. Вот, выделенные ребра образуют как раз остовное дерево.
Потому что я взял все вершины, взял какие-то ребра, и если рассматривать только красные
ребра, то граф очевидно связан и не имеет циклов. Получается дерево. Вот, ну, наша цель будет на
сегодня такая. Вот, если у вас еще граф не просто такой, а еще и взвешенный, то есть на каждом
ребре написан какой-то вес, тогда мне нужно найти минимальный остов по весу. То есть вот среди всех
деревьев выбрать то, у которого минимальный суммарный вес, минимальный вес ребер, который в него
входит. Значит, остов минимального веса, ну, это просто остовное дерево с минимальной суммой весов ребер.
Ну, это очень естественная задача, потому что если у вас есть какой-нибудь граф, ну, не знаю, опять,
какая-нибудь компьютерная сеть, и для того, чтобы провести канал взаимодействия между двумя
компьютерами, вам нужно потратить столько-то денег. То есть у вас каждое ребро имеет какую-то
стоимость. Вот, и вам нужно выбрать какие-то каналы так, чтобы сеть была связанная, то есть компьютеры
могли обмениваться, ну, там можно по цепочке любой информации, ну, и при этом потратить как можно
меньше денег. Пожалуйста, задача минимального остова. То есть нужно выбрать связанный под граф,
потратив при этом минимальную сумму. Вот. Значит, леммо, которое будет, кажется, единственное содержательное
сегодня, окей, единственное важное, называется леммо о безопасном ребре. Ну, давайте в общем случае
я напишу. Пусть g это взвешенный неориентированный граф, а s это остовный под граф, являющийся под
множеством, то есть под графом, какого-то минимального остова. Это остованный под граф, то есть он
содержит все вершины, но, возможно, не все ребра, являющийся под графом какого-то минимального остова.
Вот. Ну, то есть у нас алгоритм будет интеративный, он будет постепенно расширять наш миностов, то есть
изначально мы возьмем, скажем, пустое множество, то есть все вершины и ноль ребер, без ребер вообще.
Понятно, что это под граф миностов, потому что любой миностов содержит пустое множество. Вот. И дальше мы
будем потихонечку расширять, добавлять туда ребра. Вот сейчас опишем, как их будем добавлять.
Значит, пусть s это что-то, что можно расширить до миностова. Пусть e это самое дешевое ребро графа g.
Соединяющие разные компоненты связанности графа s.
Значит, картинка будет чуть позже. Тогда s плюс e тоже под граф минимального остова.
Тоже под граф минимального остова. Вот. Ну, то есть картинка, давайте нарисуем. Что такое s?
s содержит все вершины и, возможно, он еще не связан. То есть, на самом деле, s это какое-то
разбиение всех вершин нашего графа на какие-то компоненты связанности. Внутри каждой компонент
у меня на самом деле будет дерево. Ну, это неважно. То есть, как-то внутри компонент уже... Да. Да,
это не имеет значения, вроде бы. Думаете, имеет? Ну, давайте поживем, увидим. На самом деле это
точно неважно, потому что мы знаем, что в любом остове ровно n-1 ребро. Ну, потому что чтобы
обеспечить связанность, нужно провести n-1 ребро. А значит, если мы прибавим одну большую константу
ко всем весам, то у нас в предсказуемом изменится стоимость. Значит, алгоритм ему на самом деле
неважно. Даже если все отрицательно, я могу прибавить большую константу, и точно все будет
нормально. Вроде доказательством этим неважно на отрицательность. Так вот, какой-то такой граф
у нас есть, и мне нужно его добить до связанного, проводя какие-то ребра, соответственно, между
компонентами. Я знаю, что его можно как-то дополнить. То есть, эта множество ребер не противоречит
выбору минимального остову. И вот я беру какое-то E из графа, например, вот это вот E, утверждаю,
что его можно добавить, то есть объединить эти две компоненты, и сказать, что это по-прежнему
под множество миностово. Ну, во-первых, если E само по себе, то есть, если вот это S плюс E это
под множество миностово, то и так уже все очевидно. Давайте напишем. Пусть S вложено в T,
если S плюс E тоже вложено в T, то доказывать нечего. Иначе E в T не лежит, иначе E не лежит в T.
Хорошо, давайте посмотрим на конце этого ребра. Пусть E соединяет какие-то вершины U и V,
но T же ведь это связанный граф, T это минимальный остов, поэтому он в частности связанный. Значит,
есть какой-то путь в графе T между этими вершинками, между U и V, при этом ребро E
использовать нельзя. Ну, как-то этот путь выглядит. Понятно, что в какой-то момент он,
ну вот если я рассмотрю этот путь, соединяющий U и V в графе T, то понятно, что он в какой-то
момент выходит из этой компоненты связанности и попадает сюда. Возможно, по пути заходит сюда,
возможно там. Ну, короче, он может быть какой-то сложный, вот какой-то такой стремный вообще,
но понятно дело, что он хотя бы один раз перейдет из одной компоненты в другую. То есть,
он может быть вот такой еще, например, вот так может быть. То есть, на этом пути гарантировано
будет хотя бы одно ребро, соединяющие вершины разных компонент связанности. Давайте это напишем.
Тогда в пути между U и V в графе T есть хотя бы одно ребро,
соединяющий вершины разных компонент графа S. Ну, то есть, вот такой переход из одной компоненты
в другую. Так, есть ребро, соединяющие вершины разных компонент графа S.
Значит, его вес хотя бы такой же, как у E. Давайте я назову E'. Тогда стоимость E' точно больше
равна стоимости E. Ну, потому что E это минимальная из ребер, соединяющие разные компоненты,
а E' какое-то. Вот E' это минимальная, а E' вот оно, это какое-то. Вот это или вот это, ну какое-то
ребро другое. Его стоимость больше равна, чем стоимость E. Ну, тогда смотрите, в графе T у меня
что происходит? У меня есть некоторый путь между U и V, вот такой вот длинный путь, содержащий где-то
по дороге ребро E'. При этом во всем графе G есть еще вот такое ребро между ними E. Ну, значит,
я могу просто смело удалить E' и добавить E в наш граф T. Связанность у меня не изменится,
связанность не сломается, потому что на этом цикле у меня связанность сохранилась, а значит все
остальное тоже достижимо. А стоимость могла только уменьшиться, но не строго уменьшиться. Значит,
тогда T-E' плюс E, а стовное дерево не большего веса. Да, ну и значит S
плюс E это по однорству вот такого минимального стова. Вот это вот минус стов.
Нормально? Хорошо. Все, ну член мы доказали. Отсюда автоматически следует алгоритм Прима.
Который я уже на самом деле заспойлерил. Алгоритм Прима. Сначала в качестве S берем пустой под
граф, то есть граф, содержащий все вершины, но не содержащий ребра. Дальше, так нет, так не хочу,
хочу по-другому сказать на самом деле. Давайте вот такую картинку нарисую. Значит, изначально
у меня есть какая-то первая вершина и весь остальной граф. Я нахожу самое дешевое ребро,
ведущее из единички в весь остальной граф. Пусть это будет реброк какой-то. В вершинку номер два,
например. Тогда я это ребро добавляю в минус стов и могу это сделать, потому что изначально у меня
один и все остальное, это разные компоненты связанности, но теперь на самом деле у меня все вершины
в попарно-разных компонентах и нет ребер. Это ребро можно добавить по лемме. Я его добавляю и
теперь говорю, что у меня один-два это компоненты связанности и вот есть все остальное. Опять нахожу
самое дешевое ребро отсюда-сюда, какое-нибудь вот такое, но опять там какое-то ребро. Его добавляю,
говорю, что вот это теперь моё подножие минус 100. Потом нахожу новое ребро из этого подножия
в остаток графа и так делаю, пока весь остов не построю. Давайте я напишу так. Давайте с первой
будет только одна вершина. Дальше n-1 раз, потому что чтобы построить остов, мне нужно добавить
ребро. Находим самое дешевое ребро между s,e и остатком графа. Между s,e и, ну, видимо,
g без s,e. Пусть это будет ребро e. Ну и говорим, что если плюс первое, это s,e и t плюс e. Мы просто
итеративно применяем лему безопасным ребром. Добавляем каждый раз самое дешевое ребро в
подножие, ну не в подножие, а, сейчас скажу, в текущую, ну да, в подножие минус 100. И так
итеративно добавляем. В конце у нас получается минус 100, потому что раз каждый раз было подножие
минус 100, то в конце тоже будет подножие минус 100, которое уже является остовом на самом деле.
Вот, значит, вопрос, за сколько это работает. За сколько? Да, ну, можно и м-логерство. На самом
деле тут симдотики такие же, как в DX3. Значит, во-первых, можно за n квадрат, что тоже иногда
бывает полезно, если у вас в графе слишком много ребер, и m-лог n больше, чем n квадрат.
То есть тогда можно за квадрат следующим образом. Давайте поддерживать массив d от v. Это так,
вес минимального ребра ведущего из s,e, ну как бы, из текущего s в v. То есть вот у меня есть, как бы,
s, текущая подножие минус 100, есть все остальные вершинки. Давайте я для каждой вершины буду
хранить самое минимальное, которое в нее входит. Вот из всех этих ребер выбираю самый маленький,
храню его вес d от v. Значит, тогда, чтобы найти самое дешевое ребро, мне достаточно пройтись
по всем еще не включенным вершинам и взять из них минимальное d от v. Вот этот шаг. Это просто выбор
минимального d от v. Давайте еще раз картиночку. Вот есть s, вот есть g без s, есть все остальное,
как бы. Для каждой вершины здесь я знаю самое дешевое ребро, ведущее в нее из s. А мне нужно из
всех таких самое дешевое. То есть из всех ребер между двумя вот этими долями мне нужно
самое дешевое ребро взять. Ну тогда я просто по ним по всем прохожусь, выбираю минимальное
значение d от v, то есть минимум по всем минимумам. Ну вот пусть он какое-то такое ребро, вершинку,
скажем, x. Я ее хочу добавить в s, вот так вот расширить мое s. Ну и соответственно,
тогда мне нужно будет пересчитать все дешки, потому что у меня теперь появились новые ребра, вот такие
вот, ведущие из x. Мне нужно теперь дешки для всех концов этих ребер тоже обновить.
Значит, по всем, ну не буду, короче, писать. Напишу так, по всем ребрам, исходящим из x,
обновляем d от v. Итого, 8 точек у меня будет n квадрат, потому что мне нужно n раз выбрать
минимум в массиве длины n. Каждый раз выбор делается за линию, всего minus 1 раз, поэтому будет квадрат.
Вот. А эта штука суммарно работает за m, вот это вот все суммарно работает за m,
потому что каждое ребро посмотрится два раза. Каждая вершина добавится один раз,
значит, каждое исходящее ребро по одному разу, ну и потому что у ребра есть два конца, то каждое
ребро дважды просмотрится. Поэтому эта штука дает от m. Ну, как обычно, я считаю, что m меньше
чем n квадрат, поэтому основной слоган будет вот такой. Вот. Ну и можно сделать то же самое за m лог n.
Просто надо хранить бинарную кучу. Бинарная куча на вот этих вот дешках, на массиве d. Ну,
потому что так же, как в dx-ре на самом деле, мне нужно уметь делать экстракт мин и уметь делать
декрески, потому что здесь происходит только декрески. А я, когда обновляю, только уменьшаю,
потому что у меня добавляются какие-то ребра, я к имеющемуся минимуму могу что-то, ну короче,
могу его обновить чем-то еще более маленьким. Поэтому у меня бывает только экстракт мин и декрески.
Вот. Ну и поэтому будет такая симпатика. И если мы опять-таки внезапно откуда-то знаем про кучу
фибоначи, то будет опять такая симпатика m плюс n лог n, потому что декрески фибоначи
работают за быстро, за учетную единицу, за амортизированную единицу. Поэтому будет m без
множителя лог n, ну а экстракт мин за логарифом работает амортизировано. Поэтому второй слоган
и логан. Вот эта симпкуча. Так, вопросики есть? Хорошо.
Так, следующий алгоритм. Алгоритм Крускала.
Значит тоже, тоже, тоже очень естественный. Смотрите, давайте мы посортируем все ребра в
порядке возрастания веса. Ну как бы понятно, да? Вот наша лемма как бы говорит, что у нас довольно
хорошо работают жадно алгоритмы. То есть если я на каждом шаге в каком-то смысле выбираю минимальное
ребро, ну подходящее, да, чтобы циклов не образовывалось и так далее, то, наверное, его можно
добавлять. Ну давайте на первом шаге мы посортируем все ребра. Сортировка ребер всех, всех ребер по
возрастанию веса. Вот, а дальше мы просто в этом порядке по ним проходим и добавляем все, что можно.
Главное, чтобы не было циклов. Нам, мы понимаем, что циклы нам не нужны. Циклы в, ну как бы они, они
связанности нам, связанности не помогают. Нам нужны только циклический граф, да? Дерево это граф
без циклов. Вот, поэтому мы просто в этом порядке идем и все, что цикла в подграфе не образует, добавляем
в подграф. Собственно и все. Вот, и в этом порядке просматриваем ребра. Добавляем те из них,
которые не образуют цикла. Ну то есть, например, если у меня какой-нибудь такой граф, вот этот,
например, самое дешевое ребро, я его сразу беру. Вот это второе по дешевизне ребро, я его тоже беру.
Если, например, третий было бы вот это, то я его игнорирую. Его брать контрпродуктивно, да, у меня
и так уже есть путь между ними, нет смысла брать еще вот это ребро. Поэтому я его игнорирую, третье
пропускаю. Ну и, например, если четвертое вот такое, то я беру вот это четвертое ребро. И вот вам,
пожалуйста, прекрасный миностов получился. Вот, значит, корректность опять-таки тривиально следует
из леммы, ну потому что на каждом шаге я выбираю вообще потенциально самое дешевое существующее
ребро. Из всех доступных я выбираю самое дешевое. Если его можно взять, добавляю по лемме безопасным
ребре, это всегда можно сделать. Если раньше было подносит миностово, то сохранится подносит миностово.
Вот, значит, поэтому единственный вопрос это, как делать вот это вот? То есть, как проверять,
появляется ли цикл после добавления ребра или нет? Значит, как это проверять? Мы это будем
делать с помощью новой структуры данных, которая называется СНМ. Значит, это система не пересекающих
ребров. Что это такое? Смотрите, СНМ как следует из названия? Поддерживает разбиение какого-то
множества элементов, какой-то совокупности элементов на непересекающееся множество. Одно множество,
второе, третье, четвертое, пятое. Ну, вот как-то, что-то такое. И умеет отвечать на два типа запросов.
Значит, во-первых, собственно, что нам нужно? На самом деле разбиение на множество, это будет разбиение
на компонент связанности. Каждое множество, это своя компонент связанности в этом вот графе по
мере построения к рускала. По мере выполнения к рускала. Первый запрос, который нам надо умеет
отвечать. Давайте объединить две компоненты. Unite. Слить два множества в одно. Два множества в одно.
Это нужно делать, когда проводится ребро между компонентами. То есть, если у меня были две
разные компоненты, я добавляю ребро в текущую версию миностово. Значит, у меня вот эти две
компоненты сливаются в одно большое. Мне нужно слить эти два множества в одно. То есть, теперь у меня не два
множества раздельных, а одно большое вот такое. И второе, соответственно, это надо уметь проверять,
добавляет ли цикл добавления ребра. То есть, по факту, мне нужно научиться, лежат ли две вершины
в разных в разных долях, в разных множествах. Ну, пока не буду называть. Мне нужно учиться проверять,
лежат ли два элемента в одном множестве. Если они лежат в одном множестве, значит,
добавление ребра в эту компонентную связанность образует цикл. Ну, потому что, если у меня есть
какой-то здесь связанный подграф, я добавляю туда ещё ребра, и понятно, что образуется цикл. Нет
смысла добавлять ребра в уже и так связанный подграф. А вот если бы эти вершины были в разных долях,
в разных компонентах, то добавление ребра как раз таки нам полезно. Нам не нужно с Лидвигом.
Ну и теперь вот такую задачу мы научимся быстренько решать, и её вот сюда вставим,
как под задачу, и так у нас кросскава будет хорошо работать. Так, как я буду хранить вот это всё
безобразие. Значит, я скажу следующее. Для множества в СНМ мы будем хранить как корневое дерево.
Будем хранить корневое дерево. То есть вот если множество, ну, точнее, если набор элементов
лежит в одном множестве...
Ну и вот так вот, как мы будем хранить корневое дерево. Ну и вот так вот, как мы будем хранить корневое дерево.
Ну и вот так вот, как мы будем хранить корневое дерево. Ну и вот так вот, как мы будем хранить корневое дерево.
У каждого элемента В храним В от В. Это родитель В в соответствующей деле.
Ну или минус один, если родителя нет, то есть вершина сама уже является корнем.
Или минус один, если В хранит.
Причём вот тут важное замечание, которое надо сделать, чтобы не запутаться.
Вот эта структура в множествах, которую я только что вёл, эта древесная структура, никак не связана с исходным графом.
То есть вот смотрите, раньше у меня там было что? У меня был какой-то граф, я добавляю ребра, соединяю компонент связанности и так далее.
То есть на самом деле там каждое множество тоже было деревом. Но вот то дерево и вот эти, это разные деревья.
И вообще давайте про ту задачу поповременно забудем. Забудем, что там что-то, какой-то граф был, какие-то деревья были, не было ничего.
Вот просто вот эта задача. Я здесь сам самостоятельно свяжу новую структуру на множество. В каждом множестве своя структура дерева.
Никак не связана я с тем, что было там. Эта структура берется только из того, как я обрабатываю запрос.
То есть давайте мы забудем про кроп скала, только на этом мы сомплюсируемся. И структура вот здесь.
Мы сами вали выбирать как хотим. Не то как задача исходная была дано, там какие-то ребра проводились, так и расставляем деревья.
Нет. Как хотим, так и делаем. Вот сейчас мы полностью властны на тем, как строить эти деревья.
Давайте на вот этот вопрос быстро ответим. Как понять, что два элемента в одном множестве?
Давайте дойдем до корня обоих деревьев. Вот есть U, вот есть V.
Давайте дойдем по стрелочкам до вершины с P, вот V равно минус 1. То есть вот до сюда и до сюда.
Если пришли в один тот же корень, то значит они в одном дереве. Если в разном, то в разном.
То есть если бы V был вот здесь, то они бы пришли в разные вершины, и значит они лежат в разных множествах.
Поэтому вот эту штуку мы уже умеем обрабатывать просто пройдя по дереву до корня.
Этого неплохо.
Так, ну что, давайте продолжать.
У нас про SNM осталось чуть-чуть на самом деле довести.
Давайте я напишу простой код, который здесь делает то, что я начал говорить,
что по вершине мне нужно до корня дойти, и соответственно критерии того, что вершины в одном дереве или в разных,
это то, совпадают ли у них корни или не совпадают.
Давайте я напишу следующую очень простую процедуру int get,
которая берет вершину, если она корень, разрешает ее же саму.
То есть если у нее нет родителя, то значит она сама по себе уже корень.
А иначе нужно вернуть get от родителя.
Такая функция делает то, что я сказал.
По дереву поднимается просто вверх.
Никаких хитростей не делает.
Просто поднимается, поднимается, пока до корня не дойдет.
Охранистим как ноты?
До интов хватит, но у нас же изначально числа от 0 до 0,1.
Мне так и хватит.
Массив чисел?
Да, тут никаких структур даже не надо.
Хорошо, значит с get разобрались.
Соответственно на второй запрос более-менее научились отвечать.
Теперь что делать со слиянием, с юнайтом?
Вот есть два дерева каких-то.
Я хочу их следить в одном множестве.
То есть как это происходило?
Мне сказали, что вот есть у, вот есть в.
Я каким-то образом хочу множество, содержащее у и множество, содержащее в, следить в одно.
Для этого, понятно, разумно наверное подняться до корня.
Получить корень одного дерева и второго.
А дальше давайте подвесим одно из деревьев к другому.
У нас же это все корневые деревья.
Давайте меньше из них подвесим к большему.
Просто посчитаем количество вишен здесь, количество вишен здесь.
И то из них, которое меньше, назначим сыном большего.
Давайте картинку симпатичнее нарисую.
Чуть-чуть докажем.
Было такое маленькое дерево.
И вот было какое-нибудь большое.
Такое вот кустистое, если есть такое слово, дерево.
Вот такое что-нибудь.
Совсем не обязательно бинарное.
Я нигде про бинарность ничего не говорил.
Вот тут я когда рисовал, оно не бинарное.
Я по В нашел корень.
С помощью процедуры GET по U нашел корень.
Посчитал размеры.
И подвесил меньше к большему.
То есть по факту провел просто вот такое одно ребро.
Для этого, чтобы сравнивать, какой из деревьев меньше, какой больше,
давайте я в каждой вершине еще буду хранить размер.
Давайте я буду писать size.
Это размер по дереву.
То есть в каждой вершине я храню, сколько вершин лежит в ее по дереве.
Тогда процедура UNITE у меня работает следующим образом.
UNITE от U и V работает следующим образом.
Ну, сначала давайте U заменим на GET от U, V заменим на GET от V.
То есть считаем, что у меня деревья корнями заданы.
Не какими-то там рандомными вершинками, а корнями своими.
Вот это и вот это.
Я считаю, что U не равно V.
Потому что если U равно V, то меня попросили множество само собой.
Видите, это бред. Мы так не делаем.
Дальше я сделаю следующее.
Если size от U меньше size от V, то я их свопну.
И подвешу V к U после этого.
Что такое подвесить V к U?
Это значит назначить родителем V вершину U и пересчитать size от U,
потому что у него появился новое под дерево.
Появилось новый сын и вместе с ним все под деревом.
Поэтому size от U я просто прибавляю size от V.
Конец.
Я взял два корня.
К большему из них подвесил меньше.
У меня сейчас U больше, V меньше.
Соответственно родитель V это U.
И размер U поменялся, потому что там появился новый под деревом.
Причем тут давайте еще раз повторим.
У меня сейчас U больше, V меньше.
У меня у меня U больше, V меньше.
тут давайте еще раз, я повторю. вот это
ребро, которое я провожу, вот это вот
древесное ребро, оноuchenасно не
связано с исходной задачей, потому что
в исходной задачи меня просили вот
такое ребро провести, вот они. а
я вместо этого взял, поднялся в корне и
провел вот такое ребро. этого ребра
возможно даже в исходном графе нету.
но еще раз, те ребра, которые я провожу
внутри своей струху не обязаны
соотноситься с исходным графом.
я внутри множества могу
провести ребра как угодно. да, эти
ребраtoo notebookEL�, это и sedukir, что
только то, что это все в одной компоненте. То есть если бы провел такое ребро,
у меня бы тоже все это осталось одной компонентой, но я для удобства, для того,
чтобы асимптотика была такая, как надо, я прожу вот такое ребро. Еще раз, это ребро
не из исходного графа, а вот я его сам хочу и ввожу.
Вот, собственно, все. Вот того, что я написал на той доске, хватит, чтобы
отвечать на запросы за логарифм.
Значит, теперь все запросы работают за отлогарифма. Теперь ответ на каждый
запрос. У меня будет отлогарифма N. Ну почему? Давайте покажем, что глубина всех
деревьев будет максимум всегда логарифм. Глубина всех деревьев не превосходит
высшего логарифма N. Почему? Смотрите, потому что каждый раз, когда я прохожу по
ребру снизу вверх, я уменьшаю размер текущего по дереву хотя бы в два раза.
Да, потому что вот был у меня, вот, что такой проход по ребру снизу вверх? Это
значит, в какой-то момент это под дерево приклеилось к этому, причем это было
меньшим, а это большим. Я всегда меньше к большему подвешиваю. Значит, при проходе снизу
вверх у меня размер текущего по дереву увеличивается хотя бы вдвое, потому что
раньше было вот это, а стало вот это при переходе в родителя. Причем, если тут был
х, тут был у больше равной х, то значит, суммарно будет хотя бы 2х. Вот, ну значит,
каждый подъем это увеличение размера по дереву хотя бы вдвое. Но увеличиваться
вдвое мы можем не больше, чем лог раз, потому что всего N элементов. Ну, значит,
глубина алгорифма. Значит, подъем в родителя
увеличивает
размер под дерево
хотя бы вдвое.
Ну, значит, глубина максимум алгорифма.
В п, в п, в п. Не обязательно в корень, то есть все вот эти стрелки, они всегда
увеличивают хотя бы вдвое. Не обязательно в корню, просто, ну, в непосредственно
родителя. Ну вот, а значит, у меня гет работает за алгорифм всегда, потому что
гет просто прыгает в родителя, ну, многократно поднимается в родителя, а каждый
подъем в родителя это увеличение хотя бы в два раза размера под дерево, значит,
таких прыжков будет максимум алгорифма. Ну, юнайт автоматически работает за алгорифм,
потому что юнайт — это просто два гета, а дальше вот и днице. Что-таки свопы, какие-то
прибавления и так далее. Вот, поэтому сразу у меня все работает за алгорифм, все запросы
алгорифм. Окей? Так, хорошо. Значит, это, ну, такая самая простая реализация СНМ. Есть
чуть более изочеренная, есть следующая эвристика. Значит, давайте я здесь напишу. Вот то, что я
делаю вот здесь вот — это эвристика по рангу, эвристика по рангу называется. Вот, а сейчас мы сделаем
эвристику сжатия путей. Значит, тут помогает следующее важное замечание. Смотрите, мне на самом деле,
повторно скажу, от структуры дерева не так уж много и нужно. Мне на самом деле нужно только
уметь находить корня дерева. И вот то, что здесь был какой-то там длинный путь вот такой из трех
ребер отсюда до сюда, мне на самом деле это не очень важно. И я сделаю следующее. Каждый раз,
когда я для какой-то вершины В, многократно поднимаясь по стрелочке, дохожу до корня своего
дерева, я могу попутно для всех вершин на этом пути перенаправить эту стрелку сразу в корень.
То есть я все вот эти стрелки удаляю и перенаправляю их сразу в корень непосредственно, без вот этих
промежуточных вершин. Повторюсь, у меня структура дерева как-то меняется, но сами множество, сами
в себе не меняются. У меня остаются на месте корни, у меня остаются достижимости все, то есть то,
что было в одном множестве, в одном множестве останется лежать. А то, что было в разных, по-прежнему
будет в разных лежать. Поэтому такое преобразование точно мне ничего не портит. Короче, структура
остается корректной. То есть это будет другое дерево, но по-прежнему корректное. Разбеяние на множество
будет корректным. Но зато понятно делать в каком-то смысле оптимизация, потому что потом, если в
будущем меня кто-то попросит сделать гет от В, я не буду проходить все вот эти ребра, а сразу прыгну
вот сюда. То есть какую-то часть работы на будущее я себе уже сэкономил. Давайте я напишу обновленный гет.
Значит, как обычно, если мы уже пришли в корень, то надо его вернуть. Вот, а иначе, ну давайте
какой-нибудь х я заведу. Пусть это будет корень, полученный из родителя. Ну я сразу ПЛТВ переназначу
родителя, в корень точнее, и верну его в качестве ответа. И эта эвристика вкупе с предыдущей,
с эвристикой по рангу, работает супер быстро. Сейчас напишем засколько вам не понравится.
Теорема, конечно. Значит, давайте введем следующую функцию, называется функция кирмана.
Я тупой, мне можно. Значит, n плюс 1, если m равно нулю, а m минус 1, 1, если m больше нуля, а n ноль,
и а m минус 1, а m n минус 1, если оба положительные. Вот, какая-то такая функция. Значит, важное
здесь вот это, что при уменьшении первого аргумента на единичку, вы в качестве второго
подставляете что-то уже насчитанное. И за счет этого у вас получается на самом деле взрывной рост
этой функции, потому что когда вы здесь уменьшили на единичку, а в качестве второго аргумента
поставили что-то, ну короче, почти amn, чуть-чуть поменьше, amn минус 1. На самом деле за счет этого
у вас она будет очень быстро расти. Мы там напишем примерчик, она там уже для а4,4 какая-то
астрономически огромная просто. Вот, начинается называть функцией керман. Дальше пусть а это
обратная функция кермана, то есть минимальное такое n, что amn больше или равно k, что обратная
функция кермана. Вот, и тогда оказывается, что две эверистики вместе работают за амортизированную
обратную функ
Вот, почему это хороший результат? Потому что а4,4 это 2 в степени 65536-3, это тоже там 2 в какой-то,
не помню в какой, 16 наверное. Ну и поэтому, типа а это уже что-то гигантское, представь
себе 2 в степени 65536, это уже что-то гигантское, это больше, мол, кунг, уже заведомо. И вы еще и двойку в
этой степени возводите, это прям, не знаю, это что-то супер огромное. Вот, поэтому а для всего адекватного
не больше чем 4. То есть если вы тут поставляете какое-то нормальное число, там не, ну я даже не знаю,
таких слов, наверное, нет. Наверное, больше чем 10 в сотой, ну уж точно больше, короче, от любого
нормального числа от не больше чем 4. Вот, поэтому здесь у вас написано 4. Ну вот, поэтому в каких-то
местах вы даже можете увидеть на трассу что-то работать типа за единицу, ну потому что как бы,
ну на всех, на всех как бы, не просто реальных там вычислителях, а ну на всех как бы мыслямых
задачах даже, это всегда не больше чем 4, поэтому можно считать, что это единица. Ну все-таки как бы не
хочется так говорить, потому что там мало ли когда-нибудь, не знаю, ну помимо, что число атомов
во вселенной больше, чем вот это и тогда, ну типа, ну короче, короче, вот теоретически оценка
правильная вот такая, но в практических как бы вычислениях можно, ну ею часто пренебрегают,
давайте так, я не буду пренебрегать, но часто можете увидеть, что ею пренебрегают и пишут,
что это просто единичка. Вот, ну здесь еще замечание, что здесь как бы важно, что ну,
существенно, что это именно учетная оценка, ну потому что, например, если у вас вполне спокойно мог
вот такой вот бамбук когда-то появиться, то есть вы вот так вот, если подвешивали там вот это к этому,
это к этому и так далее, такое, такое могло быть, тогда у вас может быть вполне, что у вас такой
длинный бамбук есть. Тогда чтобы вам выполнить гет для этой вершинки, вам нужно весь его пройти,
но зато вы сразу все вот эти стрелки сюда перенаправляете и больше поэтому бамбуку не ходите.
То есть каждая конкретная операция может работать задолго, но учетно вот там, как обычно в среднем,
все работает быстро, примерно за единицу. Вот, ну и поэтому давайте вернемся к Рускалу,
давайте 8 дочек напишем. Значит, сколько работает сортировка? За m log m, а дальше за m на альфа от m,
потому что у меня будет m запросов каждый, ну к СНМ, каждый работает за учетную альфу,
значит, суммарно работает за m на альфа.
Хороший вопрос. Это правда. Ну по крайней мере асимпатички точно правда. Это справедливое
замечание, да, что как бы вот это всегда меньше, чем это асимпатически. Вот, но опять-таки тут-то у
меня написана сортировка, а мы про сортировку знаем много чего. Например, если бы мы могли
сделать сортировку под счетом, то это было бы за отм. То есть если бы мы внезапно откуда знаем,
что веса, ребра маленькие целые числа, тогда можем сортировку побыстрее сделать. Вот. Ну
поэтому как бы вот давайте я все-таки оставлю и то и то, потому что и эту штуку можно оптимизировать,
да, ну здесь там не оптимизируешь, но по крайней мере альфа это всегда маленькая штука, поэтому тут
как бы тоже можно понять, что это в каком-то смысле отм. Вот, но вообще говоря вот такая сумма остается,
и это асимптотика Kruskal. Так, все, SNM плюс Kruskal закончили, вопросы есть по этому блоку?
Окей. Так, ну тогда последний алгоритм, алгоритм Барувки, который делает то же самое. Ну в плане
решает ту же самую задачу. Алгоритм тоже описывается довольно просто. Во-первых,
давайте для каждой вершины выделим самое дешевое ребро из нее исходящее. Ну как бы понятно,
что если мы ищем минимальный астов, то наверное в каждую вершину что-то должно входить,
грав должен быть связан, и у каждой вершины должно быть какое-то исходящее ребро, если грав
больше, чем из одной вершины состоит. Поэтому понятно, что в вершину должно ввести хотя бы
минимальное ребро. Возможно больше, но минимальное точно по стоимости должно входить. Ну, в ответ
точно войдет ребро веса хотя бы такой как минимальный. Вот давайте его возьмем. Для каждой вершины
возьмем в астов
самое дешевое исходящее ребро.
Второе. Сожмем компоненты связанности и запустимся рекурсивно.
Ну, пока в графе хотя бы две вершины остается.
Да, ну, то есть примерчик давайте нарисую опять. Вот есть какой-то такой граф. Давайте я для каждой
вершины найду самое дешевое исходящее ребро. Например, для этой вершины будет вот это ребро,
для этой пусть будет оно же, а для этой вот это. Для этой вершины будет вот это ребро, для этой
вершины вот это. Я утверждаю, что это подножие на 100. Я могу превратить эти вершины в одну большую
вершину, сжать их. То есть сказать, что вот эта теперь одна вершина и вот эта одна вершина. Ребра,
которые остаются, это ребра между компонентами. То есть ребра между вершинами, ну вот одна здесь,
другая здесь. То есть все вот эти ребра теперь у меня превращаются в ребро
между компонентой вот этой и вот этой. То есть я их там всех склеиваю, но на самом
деле могу сказать, что выбираю минимальное. Понятно, что если есть несколько таких
ребер, то мне нужно из них только минимальное. Вот, сжимаю компоненты,
остается вот такой граф. Ну и в нем уже рекурсивно нахожу минимальный астов, это
просто это ребро будет всегда.
Вот такой алгоритм. Значит, тут есть два вопроса. Во-первых, почему у нас не
образуются циклов, во-вторых, почему у нас получится минимальный астов в конце.
Вот давайте сначала с циклов начнем. Значит, как сделать так, чтобы не образовывалось
циклов, чтобы не образовывалось циклов. Потому что на самом деле в той
реализации, в которой я написал, циклы могут появляться. Потому что если бы у
меня, например, были три вершины, соединенные ребрами веса 1, ну одного и
того же минимального веса, то я мог бы для этой вершины выбрать это ребро, для этой
вершины выбрать это ребро, для этой вершины выбрать это ребро.
Тогда у меня бы был цикл, а так точно нельзя. Мы не можем цикл добавлять в
минастов, это бред. Поэтому на самом деле мне здесь нужно немножко уточнить и
сказать примерно следующее. Если есть несколько ребер минимального веса, то я
из них выбираю то, которое ведет вершину с минимальным номером, ну, чтобы не было
такого, что я для этой вершинки выбрал это, а для этой вот это. Ну, короче, чтобы
чтобы у нее не было циклов как раз. вот давайте здесь это формализую. если есть
несколько исходящих ребер одинакового веса, одинаково минимального веса,
выбираем ребро ведущее вершину с минимальным номером.
вот тогда уже циклов я не получится.
почему?
ну чтобы доказать, что циклов не получится, я сделаю следующее.
давайте я вот эти ребра, когда их выбираю, давайте их буду ориентировать. то есть я их
ориентирую только для доказательства, на самом деле не в алгоритме, не в
реализации. короче, я их ориентировать не буду, сейчас только для доказательства буду ориентировать.
так вот, давайте в случае, когда я довершины В, выбираю некоторое ребро Е, из нее торчащее,
я ориентирую это ребро в сторону от В. то есть я его вот так вот ориентирую. это значит, что из В
я выбрал ребро Е. давайте нарисуем в нем стрелку. тогда, как выглядит граф после вот этих выборов,
после выборов ребра для каждой вершины? ну это так называемый функциональный граф,
когда из каждой вершины выходит ровно одно ребро. ну понятно, я для каждой вершины нашел
минимальную по весу, из минимальных по весу взял то, которое ведет в вершину с минимальным
номером, и ориентировал его в сторону от В. теперь у меня исходящая степень каждой вершины ровно
один. так вот, этот граф всегда выглядит как-то так. в каждой компоненте связанности у меня есть
некий цикл, к которому подвешены деревья. вот так, и в общем виде нарисую, что-то вот такое будет.
здесь дерево, здесь какое-то дерево, ну и так далее. и таких циклов может быть несколько.
возможно цикл из двух вершин, вот такой может быть. ну смотрите, вот давайте посмотрим
функциональный граф. что это такое? это значит, мы встали в какую-то вершинку, и у нас всегда
есть одно исходящее ребро, одно направленное исходящее ребро. вот оно куда-то ведет. давайте
просто пойдем по этим по этим ребрам, куда-то пришли. дальше, здесь опять есть исходящее
ребро, куда-то пришли. здесь есть исходящее ребро, куда-то пришли. и так далее, и так далее. мы не
можем продолжить цикл до бесконечности, потому что граф конечный. рано или поздно мы попадем туда,
куда уже были. туда, где уже были. и вот вам, пожалуйста, цикл. то есть тут, как ни крути цикл,
обязательно будет. в функциональном графе обязательно есть циклы. ну возможно вот такие длины 2,
когда из У пошли в В и из В в У. это вот случай, как вот тут на картинке было. одно и то же ребро
назначено сразу двум вершинам. это будет цикл длины 2. почему граф так выглядит? понятно,
я начал в В, обязательно вошел в цикл. то есть из каждой вершины достижем какой-то цикл. вот этот,
вот этот или вот этот. а дальше к этому циклу, что в этот цикл может входить? только какие-то пути.
то есть только деревья. вот такие вот подвешенные деревья. у меня вершинами, корнями деревьев
выступают эти вершины на цикле. и к ним может быть подвешено что угодно, но только уже без циклов.
потому что если там где-то есть цикл, то это будут отдельные компоненты несвязанные с этим циклом.
если достижим какой-то цикл вот здесь, то я уже до этого цикла точно никак не доберусь,
потому что я все достижим и исчерпал. поэтому именно что каждый компонент
по связности...�� тут не очень хорошо говорить про компонент связанности, потому что граф ориентирую,
но тем не менее каждая компонента этого графа — это цикл с подвеш standardized и к нему деревьями.
Ну и в общем случае бывают у меня, конечно, петли в качестве циклов, но тут такого не бывает,
потому что у меня все-таки в графе нет петель, я не выбираю петли, поэтому тут такого не бывает.
Но в общем случае в функциональной графе бывают вот такие петельки.
Так, и вот я утверждаю, что в случае построения функциональной графа так, как я писал,
у меня не будет вот таких вот больших компонент связанности, где цикл имеет длину больше, чем два.
Потому что цикл длины больше, чем два, это как раз есть, ну, обычный цикл в исходном графе,
а цикл длины просто два, это нормальный цикл, это вот такая штука, просто одно ребро,
я его могу добавлять. Так вот я утверждаю, что не будет цикла в длине хотя бы три.
Не будет циклов длины хотя бы три. Почему? Первое замечание, если есть два ребра подряд,
из В какое-то исходящее, в У и из У какое-то исходящее, то их стоимости при проходе по
ребру только уменьшаются. Это очевидно следует из того, что вот для этой вершинки, давайте я их
назову В, У, ВВ, что значит, что для У я выбрал Е штриха, а не Е. Но это уж точно значит,
что вес Е штриха точно не больше, чем Е, потому что если бы он был больше, то я мог бы вместо
этого ребра выбрать Е, и мне стало бы только лучше. А поскольку я выбираю минимально исходящее
ребро, то я Е штрих никак взять бы не мог. Поэтому если есть два ребра подряд, то их веса уменьшаются
при проходе по направлению. Отсюда до сюда вес только уменьшается, не строго уменьшается. Поэтому
если у меня есть некий цикл, то при проходе по нему постоянно уменьшается стоимость. Но давайте я
начну с какого-то там кост от Е. Пришел сюда, стоимость уменьшилась, еще уменьшилась, еще уменьшилась,
еще уменьшилась и осталась такой же, какой была. Ну значит, понятно дело, что они все одинаковые,
что веса всех этих ребер одинаковые, кост у них одинаковый. Значит, стоимость одинаковая, и тогда
играет как раз вот то, что я здесь говорил, что мне нужно выбирать вершину с минимальным номером.
Давайте примерно рисуем. Вот у меня есть цикл из пяти вершин. Давайте я их зонумирую V1, V2, V3, V4, V5.
Давайте напишем, что значит, что для v1 я выбрал v2, а не v5. Они же одинаковые,
то есть вот эти стоимости одинаковые, но я выбрал тем не менее вот это ребро в v2, а не в v5. Это
значит, что его номер меньше, чем v5. Раз я для v1 выбрал ребро v2, а не v5, то v2 меньше,
чем v5 численно. Это вершина с меньшим номером. Дальше давайте посмотрим на v4. v4 выбрала v5,
а не v3, хотя это ребра одинакового веса, значит v5 меньше, чем v3. Могу продолжить
это неравенство вот до сюда. Теперь смотрим на v2. Для v2 опять есть два одинаковых ребра
минимального веса, но я выбираю v3, а не v1, значит v3 меньше, чем v1. Ну и наконец для v5
тоже самое пишу. v1 предпочтительнее v4, хотя они имеют одинаковый вес, значит v1 меньше,
чем v4. Ну и теперь наконец для v3 v4 предпочтительнее, чем v2, значит v4 меньше,
чем v2. Противоречиво, v2 меньше, чем v2. Это было для цикла нечетной длины. Для цикла
нечетной длины будет на самом деле еще проще. Давайте для v1 напишу. Значит раз v1 выбирают v2,
а не v6, то v2 меньше, чем v6. v5 выбирает v6, а не v4, поэтому v6 меньше, чем v4. v3 выбирает v4,
а не v2, поэтому v4 меньше, чем v2. И мы уже схлопнулись, v2 меньше, чем v2. Ну и собственно и все.
То есть там на самом деле можно аккуратнее расписать, что если длина цикла нечетная,
тогда будет вот такая цепочка, ведущая к противоречию. Если длина цикла четная,
то будет вот такая цепочка в два раза меньше длины, но тоже ведущая к противоречию. И не
будет противоречия, только если цикл у нас вот такой. Потому что здесь я уже ни одного
такого неравенства написать не могу, потому что если из v1 есть только одно исходящее в v2
минимального веса, то там уже нет никаких вот таких условий, что v2 предпочитнее, чем кто-то.
Поэтому здесь просто никакого противоречия нет, такое бывает, и только так на самом деле будет.
Мы показали, что больших циклов не бывает. Могут быть только такие, а это не то, что цикл,
это просто одно и то же ребро. То есть это цикл только из-за того, что я его ориентировал,
одно и то же ребро в две стороны. Но на самом деле это просто одно ребро графа,
которое не образует циклов при добавлении в наш миностов.
Поэтому мы теперь доказали, что с учетом вот этой оговорки у нас граф всегда будет оставаться
дерево. Точнее, ацикличность будет оставаться, циклов там не будет. И если я вот так постепенно
все склею, то это будет дерево в конце концов, потому что циклов никогда в нем не появятся.
Так, чудно.
Значит, ацикличность мы доказали.
Теперь вопрос про минимальность. Почему, добавляя все эти ребра, мы остаемся под
множеством миностова? Ну давайте опять порисуем. Смотрите, ребра, которые я добавляю на очередном
шаге, это несколько вот таких вот компонент связанности, опять-таки в кавычках, вот такого
вида. То есть у меня есть цикл длины 2 и к нему подвешены деревья. То есть все, что я добавляю в
наш миностов, это какое-то ребро, которое по факту я ориентировал в обе стороны. То есть я для этого
вершины выбрал это ребро и для этого выбрал тоже самое ребро, поэтому получился цикл длины 2. И к нему
что-то еще подвешено. Вот какие-то там такие штуки. Давай что-нибудь длинное нарисую. Вот я утверждаю,
что это все можно скопом добавить в миностов, и у меня останется все это под множеством миностова.
Почему? Смотрите, ну давайте посмотрим на вот эту вершину. Это какая-то компонента связанности в
миностове, то есть тут, на самом деле, опять лэма в безопасном ребре. Вот это, это какая-то компон�menы
связанности в исходом миностове. Потому что у меня сейчас после сжатия компонент и у меня
дома, на самом деле, каждый вышина это своя отдельный компонент связанности. Вот отдельные компоненты.
Что такое это? Это минимальное ребро, ведущее из этой компоненты во все остальное. Поэтому
это ребро точно безопасное, по лэме. Вот это одна компонента, это все остальное, я могу взять это
ребро добавить в ответ. поэтому так точно можно сделать. теперь что такое вот это
ребро? это ребро на самом деле это минимальное ребро, соединяющее вот эту
компоненту связанности со всем остальным. потому что какие ребра вообще из
этой компонентной связанности торчат? они либо отсюда выходят, либо отсюда. но я знаю,
что вес этого ребра не больше, чем вес этого ребра. я делал уже это замечание, что
здесь при проходе по ребру у меня вес только уменьшается. поэтому вес этого
ребра точно меньше, чем веса всех ребр исходящих отсюда. joue просто
минимальной выходящей schooling то есть тут еще возможно какие-то есть
ребра, но они все хуже чем вот это, а это хуже, чем вот это значит это опять так
и безопасная я могу его добавить в наш ответ. ну и здесь то самая для этой
вершины, эта ребра оптимальная, для этой компоненты эта ребра оптимальная, ну потому что
есть только еще вот такие, но они хуже чем то, она хуже, чем это. поэтому все это
можно склеить в одну компоненту. И так далее. Теперь у меня есть одна большая
компонента. Это ребро лучше, чем все входившие в него, а значит, чем все остальные
вообще, поэтому можно вот это склеить. Это ребро опять-таки оптимальное среди
всех входящих. Это можно склеить ну и так далее. То есть мы как бы вот здесь
вот можем все это добавить, получить вот эту компоненту связанности. Здесь все
объединить. Ну опять это ребро в конце будет ребро, минимальное ребро
соединяющие две компоненты связанности. То есть по факту я просто многократно
Многократно применяю лему о безопасном ребре и понимаю, что каждое добавление ребра корректно.
Ну, как бы победа.
Давайте я так это лениво напишу.
Многократно применяем лему о безопасном ребре.
Снизу вверх давайте напишу.
То есть я прохожу по стрелкам снизу вверх.
Так, с минимальностью тоже разобрались, следует из лему безопасном ребре.
Ну и последней осталась эту точку оценить.
Здесь вроде получается m log n.
Потому что рекурсивных запусков у меня будет логарифмическое количество.
Здесь запусков будет log n.
Почему? Потому что на самом деле после вот этого мероприятия,
после взятия всех минимальных ребер и после сжатия компонент,
я утверждаю, что число компоненту уменьшается хотя бы вдвое.
Если оно уменьшается хотя бы вдвое, то значит количество рекурсивных запусков будет максимум логарифмическим.
Ну и понятно, что внутри каждого запуска мне по факту надо просто все ребра перебрать,
чтобы минимально для каждой шины идти.
Поэтому будет вот такая симпотика.
Почему, давайте это напишу.
Число компонент связности уменьшается хотя бы вдвое на каждом шаге.
Просто потому, что размер каждой компоненты связанности будет хотя бы два.
Потому что если была какая-то вершина, я из нее выбираю хотя бы одно исходящее ребро,
по построению я выбираю хотя бы одно ребро.
А значит компонента, содержащая эту вершину, хотя бы две вот эти вершины уже содержат.
Возможно там что-то еще, возможно там какая-то более сложная компонента.
Но хотя бы две вершины там точно есть.
И потом там что-то еще, есть какая-то вершина, из нее есть хотя бы одно исходящее ребро.
Опять-таки, возможно, что-то еще есть, но здесь хотя бы две вершины в этой новой компоненте будут содержаться.
И раз в каждой компоненте хотя бы две вершины исходного графа, то всего компонент не больше чем n.
А если изначально было n вершин, а стало не больше чем n пополам,
то получается, что на каждом шаге вершин хотя бы в два раза меньше чем на предыдущем.
Норм? Ну вот, все. Значит, log n итерации, log n – глубина рекурсии. Наверное, слово
«рекурсия» не очень хорошо, потому что это можно просто в цикле обернуть. Мне от
рекурсии здесь надо просто многократность скорее. Поэтому можно
говорить, что не рекурсивный запуск, а просто вот пока n хотя бы двойка, делаем
вот это. Вот. И на каждом уровне, на каждой итерации, за линейное время, но я тоже
сказал, нужно для каждой вышины найти минимальное ребро. Для этого просто
перебираю все ребра и релаксирую минимум для обоих концов этого ребра.
То есть еще пережить компоненты? Да-да, тоже справедливо. Надо сжать компоненты, но это DFS.
Тоже за m. Ну, m плюс n. Да, m больше, чем n, как обычно.
Вот. Ну, все тогда. Спасибо. До следующего раза.
