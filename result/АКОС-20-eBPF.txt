Так, ну и тема сегодняшнего занятия, последнее в этом модуле, это Extended Berkeley Packet Filter.
Достаточно короткая тема, потому что тут в основном будут всякие экзамплы, ковыряться по
чужим экзамплам, все детально разберется, смысла никакого нет, можно посмотреть только самое
основное, типовое. Что это за технология такая? Это линукс-специфичная технология,
которая была отобавлена, начала разрабатываться в 2013 году и распространялся в 2016 году,
когда попала в основную ветку Linux и в основные мейнстритные дистрибутивы. Разработана она в
экстремистской организации, деятельность которой запрещена на территории Российской Федерации,
поэтому никаких ссылок не будет, никакого цитирования тоже не будет, это все запрещено
теперь законом. Ну и небольшая отсылка о том, что такое классический Berkeley Packet Filter. Все-таки
название Extended подразумевает, что это расширение чего-то уже существующего. В прошлый раз я вам
уже показывал, как делать простые фильтры для того, чтобы фильтровать некоторый контент,
как работает классический Berkeley Packet Filter. Он принимает некоторый сетевой пакет,
соответственно лезет в различные составляющие сетевого пакета и в зависимости от того,
подходит нам пакет либо не подходит, он его либо принимает, либо не принимает. В чем особенность
реализации Berkeley Packet Filter? Особенность реализации в том, что вам не приходится гонять
данные между пространством ядра и пространством пользователя. Весь код у вас, вот эта маленькая
программка, написанная на псевдо языке какого-то ассемблера, она выполняется на самом деле в ядре.
И что это за код ассемблер такой? Это ассемблер специально для виртуальной машины, которая
существует внутри ядра. Понятно, что если вы можете загрузить какую-то произвольную программу в ядро,
это очень опасно, поскольку ядро очень чувствительная штуковина, и если у вас
грохается какой-то обычный пользовательский процесс, то ничего страшного не происходит.
Но грохнулся процесс, и грохнулся, взяли, перезапустили. Если у вас что-то произошло не так в ядре,
то у вас как минимум нарушена целостность всей системы, система скомпрометирована. Это очень
нехорошо, поэтому не любой код можно загрузить и выполнить. Есть такая программа под названием
верификатор. То есть, прежде чем выполнить произвольную программу в ядре, нужно удостовериться,
что эта программа действительно не приведет никаким печальным последствиям, поэтому на
исходный код программы накладываются дополнительные ограничения. И только в том случае,
если программа считается безопасной с точки зрения верификатора, тогда ее можно выполнять.
У любой программы, хоть на классическом BPF, хоть на экстене BPF, поэтому есть ограничение на
количество инструкций, чтобы программа выполнялась не очень долго. Во-вторых,
для того чтобы предотвратить долгое выполнение программы и зависание в принципе, у нас запрещены
джампы, условные либо безусловные, на инструкции, которые были до этого. То есть, мы в принципе
никак не можем реализовать никакие циклы. Теперь расширенный BPF. Это все было про классику,
есть некоторый байт код, который выполняется. Что такое экстенит BPF? Вроде как общая идея точно
такая же, как у классического BPF, но при этом это совершенно другая подсистема,
которая в том числе позволяет делать just-in-time компиляцию в нативный код. Инструкции точно
также аж 4-убитные, но это совершенно другой ортоканальный набор инструкций. То есть, вы
можете скомпилировать программу сначала в байт код для eBPF, дальше загрузить ядро. Если у вас
ядро выполняется на архитектуре x8664, то этот код будет транслирован в нативный машинный код.
Насчет ARM я так и не нашел информации, будет ли он транслироваться или нет. Возможно, уже сделали
поддержку в свежих версиях ядра. Ну и этот код уже дальше выполняется. В чем ключевая фича
extended BPF по сравнению с классическим BPF? Если мы можем выполнять любой код где-то на уровне ядра,
то это совершенно не обязательно может быть предназначено для того, чтобы фильтровать сетевые
пакеты. Ведь в ядре есть много других событий, операции ввода-вывода, системные вызовы,
ну и просто выполнение каких-то программ, которые можно трассировать. Таким образом,
кроме как сетевая фильтрация, у нас инструмент по названию пакетный фильтр может быть пригоден
для большего количества разных интересных применений. Какие могут быть применения?
Ну понятно, что есть фильтрация сетевых пакетов. Кроме того, вы можете выполнять анализ
производительности. Вы можете навешивать разные дополнительные функции на уже выполняющийся
код в программе. Причем не обязательно программу запускать, может быть что-то запущенное, просто
сайди чего вы знаете. Можете навешивать разные обработчики, связанные с определенными системными
вызовами. И не только с системой вызовами, вообще на самом деле на любые функции внутри ядра.
Ну и для чего это может быть использовано? В том числе, например, для мониторинга различных
системных вызовов. Но тут есть некоторые ограничения на тему того, как вы можете их
фильтровать. Тем не менее, есть хороший пример применения разных технологий по изоляции, в том
числе Extended BPF, где пакет-фильтр используется для мониторинга стенных вызовов, но не для
их модификации. Фреймворк от Гугла под названием NSGL. Да, Google пока еще не запрещенная организация
на текущий день, поэтому это название употреблять можно. Так, ну вот в классическом Berkeley
пакет-фильтре вы могли написать какую-то последовательность инструкций, дальше ее загрузить,
верифицировать и запустить. Либо вы могли написать текст на ассемблере, скомпилировать
соответственно в последовательности инструкций, которые дальше вкомпилировать внутри вашей
программы и запустить. А с Extended BPF, поскольку программы сложнее могут быть, на ассемблере
особо много не напишешь. И хочется все-таки иметь возможность писать их на чем-то высокоуровневом,
например на языке C, на языке C++, на языке Rust, если вы знаете язык Rust. В общем, на любом языке,
который поддерживается фреймворком LLVM. В прошлом году вы были первокурсниками,
у вас был курс весной под названием технологии программирования, помните такой? Вам про LLVM
что-нибудь рассказывали? Так, хорошо, LLVM я вам тоже покажу. Итак, давайте рассмотрим пример,
совершенно бесполезный программ. Бесполезный, потому что наша цель это скомпилировать и загрузить,
поэтому программа выглядит очень тривиальным образом, она просто существует. Наша задача вот
это вот программа, кстати, видно что-нибудь на проекторе. Теронный фон, говорите, будет лучше,
давайте попробуем. Так, лучше.
Отключить подсветку цветов, да? Так. Ладно, тогда отказываемся от текстовых редакторов. Итак,
вот самая дурацкая тривиальная программа, которая не делает ничего. Методически эта программа
полезна тем, что нам нужно иметь возможность ее хотя бы как-то загрузить, верифицировать,
то есть прежде чем загрузить, нам нужно ее скомпилировать, потом загрузить, прогнать
через верификатор, убедить, что программа действительно работает, и если все хорошо,
значит мы молодцы. Так, делается это, ладно, вместо EMX можно попробовать VI, может цвета будут такие.
Ужасные. Так, теперь программа, которая все это делает. Основана она на системном вызове,
который называется BPF. Есть системные вызовы, которые в качестве перерыва аргумента принимают
какую-то целочисленную команду и какие-то аргументы, которые могут быть совершенно разнообразны в
зависимости от команды. Примеры таких системных вызовов это File Control, IO Control, ну и вот один из них еще это
системный вызов BPF, который один системный вызов имеет огромное количество всякой разной
функциональности в зависимости от того, что вы передадите в качестве первого аргумента.
Соответственно у него могут быть аргументы это присоединить какую-то программу загруженную к
какому-то событию, загрузить программу, ну и так далее. Итак, вот у нас есть системный вызов BPF,
прокручиваем ман страницу до того, что связано со словом luat. Эта команда означает загрузить какую-то
программу и программа представляется в виде последовательности команд, которые представляются
тоже некоторые структуры. Каждая команда имеет у нас, так это у нас, это шестичерубитное значение,
которое в свою очередь тоже может делиться на разные кусочки под названием обход команды,
аргумент команды и так далее. Это все закодировано некоторым образом и нам нужно сначала превратить
какую-то произвольную программку, написанную на высокого уровня языке программирования,
в последовательстве шестичерубитных инструкций, которые имеют тип данных, структ BPF.
Так, это VI, как его терпеть не могу. ВИМ это не VI. Ладно,
видно что-нибудь. Ладно, будем тогда пользоваться самым дурацким текстовым редактором,
потому что он совершенно не функциональный. Итак, есть структура BPF INST, на самом деле каждый
элемент структуры это просто какое-то 8-байтное число 64 бита. Наша задача прочитать набор инструкций,
затем используя команду системы вызов BPF. Обратите внимание, что BPF вызывается не в виде BPF,
как это написано в мане. В мане у нас есть какая-то настоящая сигнализация. Для его использования
нужно использовать функцию Cisco. Где вы еще такое встречали раньше? Слова FUTEX, помните?
Так вот, да. Есть некоторые системные вызовы, которые честно реализованы в виде системных вызовов.
Они имеют ман страницы, которые написаны C-шными сигнатурами, но на самом деле в стандартной C
библиотеке нет поддержки некоторых системных вызовов. То есть нужно их запускать ручкой.
Про BPF возможно тоже. FUTEX написано в самом начале. Может быть когда-нибудь в глипси библиотеке после
окончательной стабилизации функционала BPF все-таки добавит честную поддержку. Но на самом деле почему
этой поддержки нет? Точно так же, как нет поддержки для FUTEX. Потому что FUTEX на самом деле
вручную никто не использует. Обычно есть MUTEX, который в свою очередь использует FUTEX. MUTEX уже реализован
в стандартной библиотеке. Пожалуйста, пользуйтесь MUTEX. Зачем вам FUTEX? То же самое с BPF. То, что я вам
сейчас показываю, это просто некоторый ресерч, чтобы вам показать, как устроено все изнутри,
какая на самом деле за этим кроется боль, чтобы вы это прочувствовали и больше никогда этим не
пользовались. Итак, нам нужно подготовить некоторую программу в виде последовательности
64-битных инструкций. Затем с помощью системного вызова CIS BPF и команды BPF LoadProc загрузить эту
программу. Самое ключевое здесь это подготовить тот набор данных, ту последовательность 4-битных
инструкций, которые нужно загрузить. Итак, у нас есть некоторая программа. Что мы сделаем в первую
очередь? Итак, давайте посмотрим на этот слайд. У нас есть исходник. Нам нужно его сконвертировать
в bytecode LLVM, который вы знаете с первого курса. Дальше bytecode LLVM может быть загружен уже в ядро
с помощью механизма E-BPF, а затем ядро имеет право скомпилировать этот код в машинный код и
выполнять уже машинный код. Достаточно сложная конструкция, но есть одно маленькое преимущество,
что этот код E-BPF является портируемым и независимым от конкретной платформы. В отличие,
кстати, от LLVM, LLVM штука не очень портируемая на самом деле. Итак, как нам превратить программу
на выскоренном языке программирования bytecode LLVM? Если у вас программа на C или на C++,
есть замечательный компилятор по названию C-Lang с опцией minus hemit LLVM.
Опция minus C означает, что нужно сгенерировать какой-то файл, не доводя его до готовой программы,
которую можно запустить. Дальше наша исходная программа. На выходе мы получаем файл
BPF.BC. Это обычный бинарный файл, который содержит bytecode LLVM. Что мы можем с этим
bytecode сделать? Мы можем превратить его в текстовое представление и посмотреть на нашу программу.
LLVM.dis нам породил файл BPFProgram.ll, который уже является текстовым, а не бинарным.
И между текстом файлом LLVM и bytecode LLVM существует строгое соответствие. Это
некоторый ассемблерный код. Вот наша функция, сам BPFProgram, которая выделяет на стеке
какой-то указатель, сохраняет там что-то, отбрасывает и возвращает 300 бит на значение 0.
Вот это называется функция LLVM. Синтаксически немножко похожа на код на языке Ic. На самом
деле, это не структурированный язык программирования. Здесь нет никаких ветвлений,
здесь нет никаких циклов. Есть только наборы инструкции, записанные в чуть более человеческом
виде, чем программа на языке Ic. Тоже самое можете проделать с абсолютно любой программой,
получить некоторый текст, дальше его скомпилировать обратно в bytecode либо сразу в машинный код.
Почему я говорю, что вот это представление не совсем партируемое? С одной стороны, у нас тут
нет никаких регистров, поэтому мы можем компилировать эту программу под разные
архитектуры процессоров. Здесь вы можете использовать какие-то виртуальные регистры,
вот процент 2, процент 0 и так далее. Если у вас количество регистров на реальной машине больше
либо равно, чем количество виртуальных регистров, то при компиляции в машинный код будет отображение
на реальные регистры. Если у вас регистров меньше, например, 300-убитная архитектура x86,
значит память у вас будет периодически использоваться на стеке. Тут у нас полная абстракция. Код,
тем не менее, не партируемый, поскольку он скомпилирован в данном случае селанг 11 версии,
компилятор 10 версии не скомпилирует. Компилятор селанг какой-нибудь 12-13 или что там самое
последнее, не факт, что скомпилирует. Может 14-я. В чем проблема внутреннего представления LLV?
Оно не стандартизовано и меняется от версии к версии. Сейчас уже, конечно, в меньшей степени,
чем по сравнению с тем, что было лет пять назад, но все равно никто вам не гарантирует,
что вот это представление хоть в текстовом, хоть в бинарном виде можно будет скомпилировать где-то
еще. Поэтому мы про него забываем. Оно нам не подходит. Нам нужно превратить эту программу во что-то
другое. Как потом из бинарной программы превратить что-то? Вот у вас есть bytecode LLV,
неважно текстовое представление, либо бинарное. Но опять же, если вы селангу
скормите какой-то файл, который заканчивается на .ll или .bc, то на выходе получите
уже обычный объектный файл, скомпилированный для текущей архитектуры. Либо можно сразу указать,
не генерируя промежуточные стадии, селанг вместо имитл.lvm, target и какая-нибудь другая
архитектура отличная от текущей. Например, target BPF. Можно оставить имитл.lvm, получим то же
самое. Либо сразу все скомпилировать, в том числе можем пропустить промежуточные стадии генерации
.llvm bytecode, скомпилировать все из исходной программы и получаем некоторый бинарный файл,
который скомпилирован для другой архитектуры, не текущей. У вас, наверное, это x86, у меня на этом
конкретном компьютере это ARM 64. Получаем на выходе какой-то бинарный файл по названию BPF program.o.
Что мы можем посмотреть? Поскольку это объектный файл, то мы можем посмотреть об gdump'ом что-нибудь.
Так, обычного gdump'а нам тут не поможет. Can't disassemble for architecture unknown. Это gdump' идет из
поставки GCC. Ну ладно, lvm gdump' в этом плане чуть более умный. И у нас есть какая-то программа,
где-то есть секция текста, которая содержит метку сам BPF program, которая транслируется в какие-то
8-байтные инструкции. В данном случае их всего три штуки. Это что-то там записать в регистр r1,
дальше непонятно. А, ну это, видимо, неоптимизированный код, поэтому он аргумент записал в r1. Дальше в регистр
r0 записываем значение 0, ну код возврата, и exit из функции. Это нереальный assembler,
не assembler x86, не assembler arm, а assembler bytecode виртуальной машины BPF, который этот код
может загрузить прямо в ядро. Так, ладно, нам нужно загрузить вот эту вот последовательность
команд. Что мы можем сделать? Мы можем взять вот эти значения, считать их 4-битными константами,
захардкодить массив из трех элементов и получить нормальный BPF программу. Слишком сложно, да? Зачем
такое извращение? Давайте все-таки немножко автоматизируем наш процесс по извлечению вот
этих вот байтиков. Хотя бы если мы получим какой-то бинарный файл, мы можем этот файл бинарный
прочитать и дальше сделать что-то человеческое с ним, например, считать у BPF программой и загрузить.
Так, как мы можем выделить какую-то часть из объектного файла? Ну, во-первых, у нас тут есть
разные секции. Давайте сделаем некоторые фильтры. Опция "-j", и название секции отобразит нам только
секции с определенным названием. То есть мы уже уменьшили количество данных, и если мы команду
llvm-obj-dump поменяем на команду llvm-obj-copy, то мы можем скопировать что-то из одного объектного файла
в другой. Все то же самое без префикса llvm будет работать с обычными объектными файлами для вашей
родной архитектуры. Так, ну и при копировании мы можем указать формат данных, в котором нам нужно
сохранить определенный участок нашего бинарного файла. Если мы напишем binary, то формат файла
подразумевается обычный plain binary без всяких заголовков. Так, binary, ну и выходной файл какой-нибудь,
pf-program, пусть будет просто bin. Получаем на выходе файл размером 24 байта. Вроде правильно,
три инструкции по 8 байт в каждой. И что в себе содержит этот файл, мы можем посмотреть,
например, хэкс дампом. Видим что-то похожее с точностью до того, что хэкс дамп разворачивает
все слова те же самые байтики, что и в дезасимблированном выводе нашей программы.
Так, ладно, получили такую программу, теперь мы можем этот файл бинарный открыть обычным
системам вызовом read, прочитать, определить количество инструкции, три штуки, дальше заполнить
аргумент для системного вызова bpf и выполнить системный вызов bpf для того, чтобы загрузить
какую-то программу. Этим мы сейчас и займемся. Тут нам уже неважно си ланг, gcc, разницы абсолютно
никакой. Компилируем, запускаем программу, которая загружает за хардкоженное название файла,
которое мы сейчас сгенерируем, ppfprogram.bin. Так, и получаем ошибку. Бабах, оперейшин от
пермитит. Потому что надо внимательно читать ман страницу на bpf, и тут где-то прописано,
что нам нужно иметь некоторые capability с под названием cap sysadmin. Точнее, тут есть уточнение
в notes, что начиная с версии 4.4 ядра, непривилегированные пользователи могут некоторые
программы загружать без повышенных привилегий. То есть я могу просто написать судо. Хорошая идея.
Ввести пароль, стать рутом. Все, программа честно загрузилась, программа пустая,
поэтому не делать ничего. Но хотя бы никакой ошибки у нас не появилось.
Чем плох подход через судо, или просто сразу стать рутом и запускать весь подрута. Но это небезопасно.
Ваша программа может выполнить все что угодно. Нам нужно локально поднять привилегии. Как это сделать?
Вспоминаем Linux Capabilities. Нам нужно иметь capability cap sysadmin для того, чтобы использовать
стены вызов BPF. Для этого мы можем вызвать один раз с правами рута такую программу как setcap,
прописать требуемые права и проставляем флаги для capability sysadmin. Какие нужно
проставить флаги? Давайте вспоминаем. Это вы уже должны знать, чтобы выполнить
стены вызов BPF один раз. Во-первых, он должен быть permissive. Логично. А еще он должен быть эффективным.
И имя файла, на котором мы поставили право. Все, теперь без судо запускаем. Все хорошо, все замечательно.
Что означают флаги P и E? В контроле нужно повторить вопрос. Не все на него правильно отвечают,
может хоть выучите. P понятно, это permissive разрешить. А эффективность нам зачем нужна?
И зачем нам не нужна inheritance? Так, ладно. Это вопрос на самостоятельное изучение. Надо
добавить в контрольную. Продублировать еще раз. В каком ситуации у нас может пойти что-то не так,
несмотря на наличие прав? Все, эту программу я скомпилировал, не трогаю. Я не трогаю даже файл для
того, чтобы у него сохранились расширенные атрибуты. Вот эта все, теперь строчка, хранится в расширенных
атрибутах файла BPF loader. Если я файл перекомпедирую или что-то с ним сделаю, расширенные атрибуты у меня
пропадут. Мне надо будет делать операцию ситкеп еще раз. Я немножко поиздеваюсь над исходной
программой, написанной на языке C, и добавлю way, к Z я не люблю nano. В айлтру ничего не делать,
хорошая программа. Программа плохая, но с формальной точки зрения это корректная программа. Почему она
корректная? Потому что баланс кобочек соблюден, никаких новых неизвестных имен у нас нет, никакой
симатической ошибки тут с точки зрения компилятора тоже не видно. Хорошая программа. Так, хорошо,
что же такое, файл, x, теперь C lang, target, BPF, скомпилировать, файл BPF program.c, скомпилировали,
после этого делаем копию BPF program и пытаемся этот файл теперь запустить еще раз. Запускаем,
получаем бабах. Бабах, почему бабах? Еще раз, вот программа, которую мы скомпилировали,
и теперь на стадии загрузки BPF мы ее загрузить не можем. У нас есть cycle while,
который превращается в инструкцию jump на строчку назад. Go to, program, counter,
minus 1. Поэтому здесь потенциально возможна ситуация, когда программа никогда не остановится,
и верификатор тупо формально эту программу не разрешает нам загрузить. Иногда все-таки в BPF
программах бывает полезно иметь какие-то циклы. Если циклы вы никак не можете сделать,
ну это грустно. Как с этим бороться? На стадии компиляции есть такая опция an-f unroll-loops,
но помогает не всегда. Что делает опция unroll-loops? Она старается развернуть все циклы,
если это возможно. Что значит развернуть циклы? Если у вас встречается какой-то цикл,
то компилятор, при условии, что цикл, количество итераций цикла известно на стадии компиляции,
делает большой код, повторяя каждый раз, каждую итерацию цикла. Вот такие программы верификатор
пропустит, но в данном случае нам это не помогло, потому что цикл while true бесконечный,
количество итераций на стадии компиляции нам в общем случае не известно, и компилятор
оптимизацию применить не сможет. Естественно, если мы повторим еще раз копирование,
повторим запуск, ничего не помогает. Просто так взять, запустить произвольный код в ядре,
вы все равно не сможете. Давайте сделаем эту программку чуть более полезной,
например, чтобы она умела что-то делать. Вот чтобы сделать эту программу чуть более полезной,
вот пример программы, которая запускается перед запуском какой-то функции, и что так говорит. Что
можно на самом деле использовать внутри программ, которая выполняется внутри ядра? Внутри ядра вы
не можете использовать стандартную seed библиотеку, вы не можете использовать произвольные системные
вызовы. Вы можете использовать только какое-то ограниченное количество функций, которые доступны из
контекста BPF. Полный перечень всех этих функций перечислен в седьмом разделе мана BPF Helpers.
Так, закрываем man на BPF, надеюсь, он нам больше не пригодится, а вот BPF Helpers. Это список всех
функций для текущей версии ядра, которые можно использовать. Функций на самом деле достаточно много,
и вы можете делать разные полезные программы. Например, вы можете что-то выводить на экран того
логика, который у вас выполняет трассировку перерез программы. Примерно, вы можете выяснить
процесс ID и какая-то программа, которая у вас выполняет некоторый код. Давайте
скомпилируем теперь и загрузим некоторую программу. Эта программа находится так, выглядит следующим
образом. Вот простенькая программа, написана на языке C. Давайте попробуем сделать такой же трюк.
Target BPF, только скомпилировать, получить объектный файл, и вот эта вот функция. И тут получаем
сколько ошибок. В самом деле, здесь нам что не хватает с точки зрения компилятора языка C,
чтобы программа была корректной. Нам не хватают какие-то заголовочные файлы, где их искать.
Если подключим какие-то заголовочные файлы, в которых объявлены типа данных U64, функции BPF,
из принт K, что еще не хватает структ PT-REX, тогда, казалось бы, все хорошо, все замечательно.
Слинковать мы это не сможем, хотя бы сможем скомпилировать. Где искать заголовочный файл,
на самом деле ответ не очевиден. Можно взять исходники ядра и надергать заголовочный файл из
исходников ядра. Затем все это скомпилировать, ну и получить какую-то программу, хорошо,
станет немножко лучше. Вручную это можно сделать, но жутко неудобно, трудозатратно. И одна из причин,
почему все-таки система вызов BPF не имеет сишной оболочки. Потому что это не очень осмысленно,
никто вручную для BPF не пишет. Есть высокоуровневые фреймворки, есть библиотека ЛИП-BPF для
использования высокоуровневого образа этого системного вызова. Есть еще боевоскоронний способ.
Так, apothecary search. Есть пакет под названием BPF compiler collection,
реализованный для языка питон, как ни странно. Поэтому мы можем взять питон,
что-нибудь наклепать даже в терминале и загрузить нашу BPF программу. Итак, давайте сделаем следующую
функциональность. У нас есть какая-то произвольная программа, в которой выполняется какая-то
произвольная функция. Может выполняться в произвольном моменте времени. И наша задача
отловить все ситуации, когда мы вызываем какую-то произвольную функцию, используя механизм extended
BPF. Сначала нам нужна какая-то программа, которая что-то делает. Программа, программа, программа тоже
тупая, тривиальная. Выглядит следующим образом. Функция main, которая сообщает свой пит,
чтобы мы могли к чему-то подключиться. Дальше на каждое нажатие клавиши ввод просто вызывает
некоторую функцию, и эту ситуацию нам нужно уметь отловить. Программа совершенно дурацкая,
учебная. В реальной жизни, на самом деле, вам может понадобится поставить трассировку на уже
работающий код для совершенно произвольной программы. И то, что вам сейчас показывал в
качестве модельной ситуации, на самом деле можно применять на практике. Какая-то программа у нас
скомпилирована, исполняемый файл сам программ. Соответственно, в этом сам программ, в таблице
символов, можно найти какую-то функцию, которая называется some function, находится в секции текста.
Ладно, запустим нашу программу, сам программ. Вот она работает, вот на каждое нажатие клавиши
ввод говорит I'm some function, которая вызывает функцию some function. Программа уже работает,
я ее не запускаю. Ну и задача использовать инструменты BPF. Для этого понадобится Python.
Итак, from bcc, вот ссылочка, iuether.org, не знаю, что за организация, но она не запрещена,
поскольку не является экстремисткой. Итак, from bcc, import, что-нибудь, достаточно только BPF.
Так, дальше у меня есть некоторый файл, который находится в файле trace some function. Вот
некоторые программы написаны на языке C, которые нужно скомпилировать в код BPF и загрузить.
И желательно сделать это с минимальными телодвижениями. Окей, мы просто берем этот текст программы.
Как нам прочитать текст программы? Очень просто. Мы вызываем функцию... Да, сейчас я показываю
некоторый код, который на самом деле не является чистым кодом с точки зрения языка Python,
просто по той причине, что я это набираю в терминале и хочу минимизировать количество нажатия на кнопочки.
Итак, open, естественно, писать inline это очень плохо. Лучше, конечно, писать в конструкции viz,
open, sf, дальше какие-то блоки. Так, trace some function. По цветам, кстати, видно что-нибудь?
По идее должно быть. Так, trace some function. Читаем, тут же открыли файл, прочитали,
и скормили. Все, в некотором BPF. Вот мы создали некоторую программу BPF, которая успешно скомпилировалась.
Давайте смоделируем ситуацию, когда программа у нас не скомпилируется, потому что всякое в жизни
бывает. Например, вот у вас программа, которая, во-первых, она компилируется. Давайте сделаем что-нибудь
противное, например, она не может компилироваться. В этом случае получаем ошибку компиляции именно
при попытке создать объект BPF из некоторого нелегального текста. Так, что мы еще можем сделать?
Мы можем программу сделать корректной с точки зрения синдекса EGSI, но содержащую некорректный код,
поскольку эта программа содержит бесконечный цикл. Она хотя бы скомпилировалась, но где-то на дальнейшем
шаге. Ладно, мы скомпилировали программу, которая содержит цикл while true. Сейчас мы
запихаем в ядро. Давайте попробуем что-то с этим сделать. У нас есть некоторая программа,
которой мы хотим прикрутить трассировку вызова функций. Более того, эта программа у нас уже работает,
мы знаем ее процесс ID. Прикрепляем теперь код, который мы загрузили в ядро, точнее тут отложенная
загрузка в ядро в этом фреймворке. И нам нужно подключиться к некоторой функции, а чтобы знать
некоторые функции, нам нужно загрузить эту функцию из... нам нужно знать адрес этой функции,
чтобы знать адрес функции, нам нужно посмотреть на объектный файл. Поэтому нам нужно все-таки
скормить этот файл. Так, мы находимся где... рановато я начал что-то писать. Надо еще написать
import OS, gcvd. Так, имя программы. Соответственно, это... берем текущий каталог, slash, sum,
программ. Так, что нам нужно знать еще? Нам нужно знать название функции,
которые мы хотим подключиться. Я забыл название, поэтому... подсмотрю в исходном файле. Название
функции было sum func. Точнее, тут не важно, что за программа, это может быть произвольный символ.
Так, ну и теперь прикрепляем нашу загруженную программу, используя функции. Так, name. Это
название программы, чтобы выяснить адрес. Так, символ. Это название функции. Так, что еще нам
нужно знать? Нам нужно знать процесс ID. И у нас есть некоторая программа, которая может содержать
несколько функций в одном исходном тексте. Соответственно, нужно еще указать, какую именно функцию мы
используем. Так, вроде ничего не забыл. Вот здесь вот происходит как раз ошибка, что на уровне ядра мы не
можем загрузить программу BPF. Здесь на питоне мы получаем ошибку, инвалид-аргумент. Прям в точности,
что нам выдал системный вызов P-error. Если более детально разбираться, а что у нас произошло,
а произошло у нас вот что. Go to PC-1. Так делать нехорошо. Ну ладно, давайте мы берем все-таки вот эту
каку. Оставим честную программу, которая гарантированно завершается за фиксированное время.
Чем нравится консольный питон, вы можете стрелочками вверх-вниз. Только это IPython,
повторить все итерации заново. Все, мы теперь честно загрузили программу, скомпилировали ее
в нативный код уже внутри ядра и подключили к событию под названием вызов какой-то функции по
определенному адресу для процесса с указанным процессом ID. Ну окей, давайте теперь смотреть,
что у нас происходит. Ага, происходит у нас permission denied. Почему? Ну потому что у нас есть
куча разных процессов. Как-то очень странно разрешать произвольному процессу. Вот так взять
просто и подключиться к другому процессу. Посмотреть, что он там вытворяет. Так делать
нехорошо. Что для этого нужно, чтобы иметь такую возможность? Нам нужны права бога. В принципе,
можно навешать на питон кучу разных capabilities, но зачем произвольному интерпретатору питон?
Давайте один раз безопаснее как раз запустить что-то из подрута. Так, ладно, повторяем всю
эту итерацию. From VCC import BPF. Загружаем программу. Trace some func. BPF attach
view probe к файлу. Так. Приходится, к сожалению, повторять некоторые действия. Some program,
symbol some func и fname trace some func. И process ID, самое последнее, вот этот вот. Так, подключили.
Ну и смотрим, что у нас происходит. Так, ладно. Понял, что в нашей программе вызов
функции происходит каждый раз, когда нажимаем кнопочку вот. Нажимаем. И, честно, для произвольного
процесса получаем вывод о том, что у нас есть вызов какой-то функции. В принципе,
вот это можно сделать и отладчиком ГДБ, но чем плохо отладчик ГДБ? Он каждый раз должен
остановить программу, должен посылать сигналы разрешения на продолжить выполнение. Это работает
медленно. BPF, в отличие от отладчика, работает прямо в ядре и генерирует какие-то новые события,
за которыми мы теперь можем наблюдать. Так, что мы можем делать? Вот я сейчас набирал
загадочные слова по названиям uProp после слова attach. У нас есть разные виды функций. Это функции,
которые реализованы в пространстве пользователя, то есть выполняются в юзерленде процесса. Здесь
можем наблюдать за событиями входа в функцию, за событиями завершения работы функции. Кстати,
для чего это может быть полезно? Например, измерить время выполнения функций. То же самое
можно сделать на уровне функции ядра. В чем принципиальная разница? Функции ядра все-таки это
более чувствительная штуковина. И здесь мы для юзерленд знаем текущий процесс ID,
для функций ядра нам придется разбираться самостоятельно. Еще один use case, для чего нам
может понадобиться трассировка входа в функцию и выхода из функции. Это, например, запомнить время,
когда мы начали выполнять какую-то функцию и посмотреть на время, когда мы закончили выполнять
функцию. Для чего? Чтобы вычесть из одного другое и тем самым узнать время выполнения функции. Для этого
нам нужно где-то хранить промежуточные значения. Поскольку у нас события возникают в произвольный
момент времени, они должны быть самодостаточными, то просто взять и завести какую-то глобальную
переменную, у вас уже не получится. У вас все-таки код должен быть самодостаточным. Если я попытаюсь,
или вы попытаетесь скомпилировать код, который содержит обращение к статическим переменным,
то у вас этот код будет отвергнут на стадии загрузки, он не будет валидным. Единственный
способ использовать что-то для перистензийного хранения, это использовать механизм по названиям
BPF maps. Название на самом деле не очень удачное, это обобщение для всех любых произвольных контейнеров.
Это могут быть не только словари, так слово map соответствует в английском языке, но также произвольные
массивы, произвольные таблицы. Просто исторически называется слово maps. Как сделать
замер времени работы какой-то функции. Следующий пример, это уже две функции. Одна функция выполняется
в начале выполнения, другая в конце. В начале выполнения мы берем текущее время выполнения и
сохраняем в некоторую хэш таблицу, в некоторый словарь, используя в качестве ключа процесс ID.
При завершении работы функции мы берем текущее время, вытаскиваем из словаря значение по ключу
процесс ID, вычисляем значение и тем самым мы знаем, как долго выполнялась наша функция. Для этого нам
требуется некоторая структура данных под названием BPF hash, которая хранит промежуточный результат.
Давайте сделаем теперь то же самое. Загрузим теперь код из этого файла.
Делаем теперь два пробочка событий. AtachuProp. Нам нужна функция,
которая выполняется в самом начале. Функция называется startTracing.
Просоединили и еще нам нужна функция на конец трассировки.
Теперь наблюдаем. Несколько нажатик клавиш. Время работы каждой функции варьируется,
поскольку это астрономическое время. Оно всегда может быть разным и зависит от кучи разных условий.
Что еще можно полезного извлечь с помощью Berkeley Packet Filter.
Код хороший, потому что проверяет все возможные ошибки. В начале момента времени, когда мы заходим в
функцию, мы в некоторую hash таблицу добавляем значение с ключом protos ID. В общем случае,
мы могли этого и не делать. Что произойдет, если я не буду делать проверку, если у нас значение в словаре
или нет. Казалось бы, это должна быть ошибка выполнения, в том случае, если мы действительно не
вызвали startTracing. Если вызвали, хорошо, если не вызвали, ну какое-то ОБ. Так вот, на самом деле,
с точки зрения верификатора BPF, программа, для которой не будет существовать вот такого кода,
она будет некорректной. То есть верификатор, штука достаточно умная, он видит, что мы делаем
обращение какому-то глобальному словарю, возможно, мы не получим корректный результат. Если вы не
обрабатываете ошибки, и верификатор это видит, что вы не обработали случаи отсутствия элемента,
то он скажет ай-ай-ай, так нельзя, и откажется загружать некорректную программу в ядро операционной
системы. Еще из полезных штук, мы можем отлавливать разные системные вызовы. Вот это уже огонь штука.
Системные вызовы, для чего нам может понадобиться отлавливать. Пример, что на низком уровне ловить
все то, что реализовано даже не на уровне стандартной символиотеки, в том числе с использованием
каких-нибудь изколов, программ, написанных на ассемблере и так далее. Настанавливаю программу,
которая мне уже не нужна. Останавливаю трассировщик, который уже тоже не нужен.
Пример программы не нужен, потому что у меня есть интерпретатор Bash, который просто работает,
и можно навесить трассировку на какую-нибудь функцию, которую Bash заведомо может выполнить,
например, системный вызов exec. Итак, программа, которая это делает. Система вызов exec
просто проверяет, что если мы выполняемся из программы под званием Bash, тогда говорим,
что Bash пытается сделать exec. Если нет, сразу сделаем return null. Никого не смущает такая
конструкция для проверки совпадения строк. Сравниваем нулевой символ, первый символ, второй,
третий. Как бы вы в реальной жизни не поступили, вы бы, наверное, написали сравнение двух строк.
Оператор 2 равно на C++, хорошо, функция str на Cmp на языке C. Почему я не могу это использовать?
Потому что у нас нет стандартной библиотеки. Извините, приплыли. Поэтому приходится немножко
извращаться. Здесь программу перезагрузить. Файл назывался trace his call. Загружаем и
подключаем к событиям ядра. Что подключиться к событиям ядра? Тут есть одна хитрость,
а именно события. Это вызов какой-то функции ядра. Какая функция ядра отвечает за то,
чтобы вызвать систему вызов exec ve? Если вы скажете, что функция называется sys exec ve,
возможно, вы будете правы на архитектуре x86, но не на архитектуре ARM. Поэтому здесь
придется применить некоторую дополнительную магию. Get syscallfname exec ve. Прицепляем функцию,
которая называется в этом файле trace exec ve, которая просто проверяет, запущена она из баша. Если из
баша, то говоришь, что баш попытался сделать exec. Если нет, ничего не делает. Анк known
программ trace exec. Удачно подцепились. Давайте понаблюдаем за тем, что происходит. Откуда я
могу запустить новый процесс с помощью exec? Например, я могу запустить minet commander.
Ой, по глазам бьет. Синий цвет ужасный, дефолтный. Тем не менее, запуск minet commander это уже системный
вызов exec. Как я могу выяснить, а что за параметры системы вызова exec? Давайте уберу это синий.
У меня есть некоторый набор регистров. Соответственно, есть указатель. Я могу вытащить
вовсе не строку. По указателю я не могу вытащить строку, не используя никаких специальных функций.
Что такое системный вызов? Системный вызов – это переключение процессора в режим ядра. Соответственно,
данные у вас где-то там остались в пространстве пользователя. Их нужно предварительно скопировать
куда-нибудь к себе на стэк поближе. В принципе, можно сделать все что угодно и достучаться до
любых параметров вашего системного вызова. В некоторых ситуациях вы можете захотеть не выполнять
какой-то системный вызов при выполнении определенных условий. Например, команда ls – хорошая команда,
хорошая безопасная. Команда rm – если вам не нравится, почему вам может не нравиться команда rm?
Или rm с некоторыми опциями? Наверное, потому что rm-rf-slash писать нехорошо. Вы хотите сделать
свою систему более безопасной и запретить запуске таких команд, в принципе, неважно,
как вы их запускаете. Из Basha, из программы на C, или написанная программа на Assembler,
вы хотите просто жестко запретить все подряд. На этот случай открываем наш bpf-helpers. Там есть
такая замечательная функция под названием bpf-override-return.
f-override-return, которая немедленно завершает системный вызов с некоторым
переопределенным кодом возврата. Классная фича. Как мы можем эту факт теперь использовать?
Мы можем взять теперь и запретить выполнять системный вызов, сразу вернуть код возврата 1 вместо 0.
Есть система вызова exec. Хорошая идея. Почему опасно? Естественно, по-хорошему надо сделать
проверки, что у вас команда такая. Это будет много кодов из-за таких особенностей. В принципе,
это возможно, наверное. Давайте скомпилируем. Что случилось? Наверное, где-то...
Так, почему перемешать Deny? Потому что backup как-то болтается.
Так, trace искал подчеркнение 1, который в случае, если стема вызова выполняется программой
под названием bash, выводит, что bash попытался выполнить стемный вызов exec и выполняется
кодом возврата 1 вместо того, чтобы реально выполнить какой-то стемный вызов. Просто мы фильтруем и все.
Так, ладно. Давайте загрузим эту нашу программку. Trace is called 1. Загрузилось. Подключаем. Получаем
какую-то ошибку. Ошибка-то, ладно. Мы можем посмотреть лог. И вот в логе тут интересная фича
написана. Программа у нас скомпилировалась, честно. Получили bytecode BPF. Если мы программу
смогли скомпилировать, это означает, что все-таки мы не опечатались названием функции и с ее сигнатурой.
Но на стадии верификации получаем вот такую интересную ошибку. unknown func BPF overwrite return.
Это означает, что функция может либо присутствовать вашей системе, либо не присутствовать. От чего это
зависит? Это зависит на самом деле от вашего ядра операционной системы. И даже нет версии. От того,
как ваш ядро скомпилировано. Понятно, что если мы будем разрешать любому процессу произвольно
вмешиваться, вытворять все что угодно. Наверное, есть какие-то use-кейсы, когда это полезно,
но по умолчанию это, наверное, все-таки не очень безопасно. Поэтому по умолчанию возможность
модификации результатов системных вызовов у нас запрещена. И вообще, механизм BPF по умолчанию
работает со всеми данными только в режиме read only. Он не может подменить данные системных вызовов,
то есть значение регистров, еще что-нибудь. Он не может подменять код возврата из системных вызовов.
Как это поправить? На самом деле поправить это можно, если внимательно почитать MAN на эту функцию.
Вот есть такой конфиг в ядре. Давайте его проверим. Конфигурация, с которой собрано текущее ядро,
находится обычно в файле slash-boot, slash-config и название версии через defis, текущая версия ядра.
Если вы давно пользуетесь системой, у вас там может быть несколько ядер, но uname-r позволит вам вернуть
нужное ядро. Вот куча конфигов. Грепаем нужную нам строчку. Получаем, что в нашем ядре действительно
BPF отключена возможность подменять результаты системных вызовов. Ладно, заходим в исходники ядра,
make, menu, config. Экран слишком маленький для меню конфига. Ничего вам от него не напоминает.
Собирали когда-нибудь ядро ручками? Ладно, самое время научиться. Make, menu, config. Дальше вы
долго упорно лазите по конфигу ядра. На самом деле очень залипательная штука. Нам нужен кернел-хакинг,
наверное. Кернел-хакинг, а может не кернел-хакинг, где-то в другом, кернел-дебаггин-энструментс.
Нет, не кернел-дебаггин-эн инструментс. Короче, можно порыться по менюшке. Еще можно
найти нужный вам файл под названием kconfig. После того, как он был со... Нет, не kconfig.
Тежа конфигурация хранит. Точка конфиг. И прописать нужные вам параметры прямо сюда.
Прописать. Кто любит редактор NaNo? Как там поиск реализован? В подсказке есть только replace.
Так, ищем вот эту вот bpf-kprobe. Not found. Ладно, тупо вставим куда-нибудь.
config bpf-kprobe override. Так, вроде не опечатывался. В всякий случай сделал копипасту.
Так, сохраняем, выходим. Ну и дальше собираем ядро. Ладно, на этом пару можно закончить. Ядро будет
собираться очень долго. Но у меня не с нуля, но я уже начинал это делать, но все равно это будет
долго. В общем, давайте резюмируем, что такое bpf, для чего он нужен. Bpf прикольная штука,
если вы можете подсматривать в произвольной функции, в произвольной процессе. Если вы
можете подсматривать в произвольной функции на уровне ядра, вы можете фильтровать какие-то
пакеты. Что вы можете из этого сделать, используя такой базовый инструментарий? Вы можете сказать
все что угодно про любую программу. Дальше возможно использовать какие-то сторонние инструменты,
обычный системный вызыв Kill, Petrace, заниматься чем-то остальным. Вот я уже давал ссылку на
гугловский репозиторий по названию NSJL. Если вы увлекаетесь безопасностью или прочими с
анбоксингами, посмотрите, прикольная штука. Вот он как раз использует в том числе eBPF,
чтобы мониторить, что в системе происходит. Но фильтрация, естественно, уже другим способом.
Так, ну и если вы видите какую-то картинку на экране, то значит лекция закончилась,
я не буду писать подпись, что это нарисовано и что нейросетка взяла за основу. Ну да,
у нас законы такие, что не все теперь можно писать. Ладно, на этом все.
