так короче у нас тема умные указатели прошлый раз мы нет лямбда функции пока нет
сейчас мы закончим разговор про умные указатели сначала а лямбда функции это будет отдельно тема
не связанная ну получается те так а маркер то нормально пишет ну так не очень да значит smart
pointers как я уже говорил я в прошлый раз заспойлерил кучу всего но как я уже говорил мы не сразу
решим все проблемы в реализации smart pointers мы сейчас как-то их решим а потом еще вернемся к
этой теме и дорешаем вот а вам-то надо будет все имплементировать но мы уже обсудили как устроен
shared ptr минималистичный вот давайте я напомню что-нибудь быстренько но мы сначала обсудили
unique ptr да потом судили минималистичный shared ptr а что там было там был давайте даже напишу это
там был значит shared ptr там у нас в полях как мы поняли должен храниться собственно указатель
на вот этого t а еще прям на t она что ну пока что на t если ты если ты о том о чем я думаю то
пока еще мы эту проблему не решили но вероятно ты не о ней да ну хорошо ну вот еще count
ну да ладно ну size t так почему да ну нет я эту часть мы я не буду повторять извините ну мы
выяснили в прошлый раз что нужен указатель на счетчик они просто счетчик иначе нам непонятно
как его вот ну и понятно как работает конструктор диструктор оператор присваивания не очень
интересно что статик не подойдет да вот ну все такой минималистичный shared ptr но тут еще
якобы написано конструктор диструктор ассенвент оператор который мы тоже реализовали и в принципе
все понятно вот смотрите какая какую проблему решим следующий хотелось бы следующий решить
проблему что у меня нету нормально пишущего маркера может быть из какой-нибудь аудитории
позаимствовать ну вот я не знаю я забыл вот я просто как-то мне не нравится они все пишут
так себе вроде что-то пишут но не очень хорошо ну да ладно следующий пункт значит это будет
параграф не 11 уже 12 точка 3 будет называться функции make shared и make unique make shared появилась
тогда же когда и собственно shared ptr c++11 make unique появилась только c++14 значит что мы что нас
не устраивает в shared ptr сейчас но вот нас не устраивает примерно та проблема что если не
аккуратно сделать нею а потом 2 shared ptr на этот сишный pointer то получится что будет двойное
удаление мы это обсуждали да получится что у вас две так сказать линейки shared ptr указывающих
на одно и то же каждый будет думать что он ответственный удаление получается двойное удаление
вот это раз ну хотелось бы написать какую-то функцию которая бы избавил нас от необходимости
писать нею вообще ну вот функция make shared она на самом деле как раз так устроена она позволяет
вам не ну я вот этот промежуточную стадию голова стика такого сразу получить или как это
лягушку ну то есть не надо делать отдельно сишный ptr потом из него конструировать shared ptr это все
обернуто функцию make shared вы ее вызываете вот функции make shared вы как раз вызываете
от аргументов конструктора ну если у вас есть сишный ptr в какой-то момент то это уже опасно
нет нет ты если завел сишный ptr если ты в программе завел вручную сишный ptr
а потом завел у него shared ptr то это чревато ошибкой что ты либо заведешь еще один shared
ptr на то же самое либо потом напишешь delete хотя не должен был потому что у тебя уже есть shared
ptr и короче кажется что хотелось бы миновать наличие вообще сишных ptr в коде если у тебя
есть shared ptr то есть наша цель перестать писать нею вообще использует только shared ptr но это
пока не единственная проблема а вторую проблему сейчас озвучу но сначала я напишу как выглядит
сигнатура мы их shared какая у нее будет сигнатура она принимает аргументы конструктора виноват
сначала t потом arcs то есть вот у нее есть шаблонный параметр t еще arcs и возвращает
на shared ptr на t называется make shared и принимает что да arc с двойной амперсант конечно потому
что это универсальная ссылка теперь мы уже понимаем что это такое почему двойной амперсант
понимаем же да все понимают думаю что нет но ну ладно вот ну привыкайте да привыкайте так
вот ну мы ее сейчас реализуем но перед этим я вот еще о чем хочу предложить вам подумать смотрите
в shared ptr если вы вспомните его реализацию который мы написали тут вот ее не написано
ну подразумевается что вы были на прошлой лекции так что да так вот вот кто-то спрашивал там чате
а можно ли стека локаторе использовать shared ptr я сказал нельзя но он там и не нужен но нельзя
вот почему потому что shared ptr он внезапно использует сам вызов new в себе дополнительный как можно
понять из того что мы написали это ты слишком далеко вперед забежал но вообще этого мы то это
мы тоже хотим да нет подождите подождите подождите не так быстро не так быстро раньше
рано еще паниковать я начал говорить про стека локатор потому что shared ptr неподходящий
класс для реализации стека локатора потому что shared ptr стека локатор подразумевается что я
не хочу использовать динамическую память вообще а shared ptr даже если осоздал shared ptr вот
какой-то вещи освобождение которой представляет из себя не освобождение динамической памяти как
другое действие сам shared ptr обращается к оператору new для внутренних нужд то есть shared ptr он
внутри себя замаскированно содержит вызов оператора new о котором вы можете не подозревать вот
если вы пользуетесь shared ptr как как юзер и не знаете о внутренней реализации то вы можете даже не
подозревать что на самом деле создание shared ptr это лишний вызов new на на in на на каунт да
именно нужно же вот эту фигню положить динамическую память то есть shared ptr вызывает new под
капотом для того чтобы каунт положить и получается следующая ситуация вот вы написали там не знаю
int звездочка p равно new int ну вот если вспоминать использование shared ptr ну старая да в старом
варианте а потом написали shared ptr от int там sp от p получилось что у вас вот тут вызвалось new и
вот тут вызвалось new то есть у вас два вызова new то есть у вас получится что вот этот вот ptr и
вот этот вот каунтер ну они оба динамически выделенные вещи но они отдельно разными операторами
new выделены и лежать еще будут в разном не рядом так вот предлагается сделать следующую вещь почему
бы мы если не создаем shared ptr сразу из документов конструктора без промежуточного вот этого почему
бы нам не сделать сразу new на t и счетчик вместе ну то есть чтобы вызов new был 1 а не 2 и чтобы
они рядом лежали то есть я здесь сделаю вот как я напишу что я хочу выделить значит
так ну мне нужно byte как size of t плюс size of size t
вот и после этого я могу shared ptr свой сразу а что кстати сделать то сразу надо нет ну во
первых надо конструктор надо вызвать еще вот это то есть надо сказать вот этот вот ptr
ну вот я сделал такое а потом мне надо сделать такое это правильный вопрос но пока я не думаю
об этом значит значит потом я делаю вот так ну я создал я выделил короче кусок памяти где
лежит т звездочка и счетчик этот и и что и конструктор надо вызвать на то место куда я положил
это все нет не будет потому что new он он выравнивает по max align t а не будет ли без
alignment int да хорошо просто хорошо просто если меня ты этот чар например да то получится что
я положил int ну да это правда но окей тут еще нужно предусмотреть правильный alignment to do
нет если мы выделим 9 байт то первый из них он выравнивает по размеру там по 16 а это тогда
да и тут останется не выровненный да стандартный new выравнивает по max align t что не странно
потому что если бы он так не делал то каждый при каждом использовании new вам нужно было бы
а не забыл я выровнять это сайну этой line of long double условно говоря
что-то с каждой парой у нас возникает у нас темп все замедляется потому что количество вопросов
напомните что это такое каждый растет мы так мы так скоро совсем вперед перестанем двигаться
да в конце конец семестра будет о том что мы снова вспомним как работает стандартная
пера то есть это такая на самом деле курс вперед туда и обратно c плюс плюс туда и обратно
ну так вот ну да здесь надо еще про alignment подумать ну давайте я не буду сейчас думать
понятно что это тоже надо правильно написать так вот я пишу new ptr t вот чего от std forward
std forward с шаблонным параметром arcs от arcs многоточие. вот это я положил
значит объект типа t по этому адресу вот а теперь я хочу создать собственно
shared ptr из этого всего дела а как это сделать положить один наверное потому что shared ptr
а shared ptr как создать из этого да нужно другой конструктор shared ptr от какой-то специальной
вещи на самом-то деле вот эта функция это будет friend ну вот короче friend shared ptr
make shared ну тут понятно там надо шаблон написать еще что это там
ну понятно тут вот и должен быть конструктор приватный приватный конструктор от какого-то
тега специального говорящего что мы через make shared вызываем сейчас ну или не от тега просто
от поинтера ну там может будет несколько приватных конструкторов и один из них ну
чтобы между ними различать ну короче да нам нужен приватный конструктор от чего ну от
ну наверное от да просто я могу действительно сделать какой-нибудь там тег make shared тег
и вот звездочка ну все я попаду сюда и в этом конструкторе я проинциализирую правильно уже
и это и это просто фейк да просто фейковый тип такой который пустой но за счет него
попадаем в эту версию конструктора так ну понятно что тут надо написать да и понятно что там еще
надо написать ну то есть тут надо ну надо сказать что вот этот вот каунтер
давайте наверное здесь ну здесь просто наверное скажу shared ptr return shared ptr
от make shared тег и еще ну make shared тег по умолчанию и что там и вот этот ptr ну и все а тут
тогда я каунтер проинциализирую у нас много проблем будет да а где второе он началось да
хорошо ну ладно еще раз повторим что было раньше это копии лижен я напомню это значит пункт 10
точка забыл какой пункт но в общем да это это ultimate копии лижен c++ 17 гарантированная которая
которая точно не приведет к копированию такой ситуации этот shared ptr он сразу же будет
этим shared ptr этот случай мы обсуждали вот так ну хорошо но тут ну я не буду писать что тут
понятно каунтер проинциализировали вот ну теперь какие у нас у нас проблемы какие у нас проблемы да
как delete делать если мы так это все написали то теперь нам нужно да нам нужно помнить создались
мы через make shared или не через make shared потому что ну да нет это на самом деле не только во первых
нет смотри во первых для того чтобы не работать с ишными пойтерами вообще пользовательском коде
во вторых чтобы у тебя был всего один вызов new в третьих чтобы счетчик и объект лежали рядом
они в отдельных где-то в разных местах ну чтобы грубо говоря у тебя обращение к счетчику
обращение к объекту было почти одной операции одной загрузкой в память а вот
но это будет достаточно достаточно неудобно проверять каждый то есть тебе на самом деле
довольно много раз надо будет и фать это на самом деле устроено дело так давайте я
заведу такую еще структуру которая называется control блок не не не значит есть такая структура
внутренняя для shared птр она называется control блок ну она считайте тут объявлена и она содержит в себе
counter и объект и хранить нам надо лишь поинтер на эту структуру но
я буду хранить сейчас у меня есть действительно проблемка проблемка проблемка ну наверное можно
сделать бейс контрол блок и просто контрол блок как обычно да ну то есть у меня будет
бейс контрол блок которая хранит просто сайс т и контрол блок который хранит сайс т и т и тогда
вот этот указатель будет указателем на ну да этот указатель будет указателем на бейс контрол блок
у меня будет указатель вот на такую вещь бейс контрол блок блин мне нельзя пользоваться
тряпкой больше она очень портит маркер потом после нее маркер не пишет я буду хранить указатель
на бейс контрол блок и еще на т да смотри какая фишка я вот что сделаю я чтобы ефать меньше
в деструкторе но я не хочу в дополнительной буль заводить я не хочу чтобы было дополнительной
буль в полях и разумеется я не хочу заниматься вот этим вот чем вы предложили с ненужным битом
что как зачем но буль нужен тебе в деструкторе ну ты на прошлой паре не был ты естественно не
понимаешь а ну ну жаль ну тебе нужен деструктор шерп тр как-то реализовать как ты его реализуешь
деструкторе шерп тр тебе нужно делать delete counter и delete t delete вот этот птр который был так кто
понимает буль зачем нужен дополнительных в полях сейчас классно а не нормально давай уточни так
ну типа да если высадить если мы следом через функцию мэйк шеред то у нас нужно один раз
оператор delete вызвать они два нормально в минималистичном варианте шерп тр у нас
было в диструкторе написано delete птр delete count а теперь нам нужно сделать не это а просто delete
один лишь птр причем даже не delete а оператор delete ну то есть нужно вручную вызвать диструктор
там а оператор delete вызвать вот таким способом как какой-то звездочки это если мы через мэйк
шеред создались а не через мэйк шеред создались то нужно по-прежнему сделать да ну вообще хотим
да но никто не ну мы не не запрещаем в принципе пользователю создаваться через не через мэйк
шеред нет они появились 11 оба вот мэйк юник появился позже чем
короче что предлагается сделать это это хак на самом деле такой некоторый на самом деле я
наверное пере в общем идея в том что вместо того чтобы проверять буль ли у меня ну там true или
false какой-то буль я буду проверять вот эти указатели они на одно и то же или нет есть
указатель на t и есть указатель на base control блок я буду проверять а указатель на t он
но надо поменять местами да только тогда с base control блоком будет проблема
ну сейчас возможно
ну просто ну идея в следующем если эти указатели указывают на одну и ту же штуку то значит мы
через мэйк шерд создавались а иначе они отдельно лежат если у нас не через мэйк шерд то это
указатель на какую-то одну вещь это указатель какую-то другую вещь а ты чего предлагаешь
а можно кстати да можно просто сказать что я и что у нас будет каунтер это ну да нет а как
ты тогда будешь хранить блок в котором нету а я понял типа ты хочешь сделать контрол блок
в котором обязательно есть t и возможно еще каунт нет у тебя каунт либо в полях либо в блоке
если у тебя ты создался через мэйк шерд то у тебя каунт будет в блоке а по сути это кажется то
же самое как если бы проверять это указатель на одно и то же или нет короче если у тебя о о о
вот что если у нас вот у меня будет base control блок состоять просто из t тогда а
контрол блок будет состоять из из него и еще дополнительно каунта и я буду хранить указатель
на base control блок которую кстати я могу просто при интерпрет кастом получить из из t если
мне дали готовый t это это легально если у меня есть такая структура просто то я могу
интерпрет кастнуть сказать что вот а каунтер либо у меня есть структура контрол блок которая
наследница этой которой добавлено еще поля каунтер и если я создался не через шерд птр то я не
создаю просто контрол блок я создаю только base control блок а каунтер отдельно а если я создался
через мэйк шерд не у меня понятно что у меня два указателя в полях они один нет два указателя все
указатель на контрол блок и указатель на каунтер отдельно со ст звездочка каунтер
вот и получается либо у меня каунтер на лп тр и тогда значит каунтер надо искать здесь
контрол блоке рядом с этим t либо каунтер не на лп тр и тогда на него надо смотреть
вот ну и по этому же признаку я понимаю осознался через мэйк шерд или не через
мэйк шерд соответственно в деструкторе я либо делаю delete каунтер delete delete то
delete все отдельно либо вот так ну и на самом-то деле вот здесь я могу писать не двоеточие
оператор new я могу написать new контрол блок вот бла бла бла бла бла потому что ведь по факту
мне создать нужно конкретно уже объект контрол блок вот здесь я могу написать и проблемы
сравниваем заодно решилась потому что поля уже сами по себе будут нормально выровнены вот здесь
мне не нужно вот это все делать вручную а могу просто создать контрол блок ну короче все понятно
у кого контрол блока нет зачем это же структура plane но она просто aggregate initialization сделается то
есть я просто вот вот здесь я да я просто сделаю сейчас контрол блок звездочка птр new
контрол блок бла бла бла ну давайте сейчас подумаем вот не контрол блок от чего
ну да непонятно
это будет какой-то move что ли нет мне это не нравится
ну я наверное могу сказать вот так ты от std forward ну и один
так std forward arcs вот arcs многоточие 1
t вот такой 1 и закрылась фигурная скобка а это pair value и поэтому copy elision у
меня не будет создан временный t а сразу создастся там нужный t из-за copy elision опять же
ну хорошо но у меня как видите проектора нет компилятора нет проверить негде поэтому
вам придется верить согласен но ноута нет тут никак не решишь проблему нет если хотите
можете кто-нибудь подключить ноут проекту но я пока буду дальше рассказывать ну все короче
понятно так с моих шеродом понятно контрол блок это структура внутри шерд птр приватная потому
что она ну то есть надо написать да вот вот типа шерд птр от т на самом деле контрол блок ну для
разных шерд птр разный контрол блок 1 вот я проинцелизировал здесь ну это мы в этом
конструкторе уже сделаем если пришли сюда то мы поймем что каунтон аутэром проинцелизирует
ну да да да то есть а то есть на самом деле будет то есть можно на самом деле убрать тег и
сказать что мы просто от контрол блока от указателя на контрол блок создаемся если мы
создаемся от указатель на контрол блок то мы сразу понимаем все что произошло ну вот
ну например так окей дальше так давайте дальше кто понял проблему ее решение про моих шерд
ага да да вот текущая все к моменту что нет и структура мы разобрали ну в смысле мы
мы не написали но понятно как его написать если нал птр то одно да ну тогда и этот будет нал
птр если оба нал птр если этот нал птр то ничего делать не надо а если этот нал птр этот не нал
птр значит это было через мэйк шерд и тогда шерд тэр по умолчанию то мог создать и вообще ничего не
будет лежать тогда хорошо так теперь мэйк юник мэйк юник она отличается от мэйк шерд тем
что она просто создает уник птр без всякого контрол блока и в общем легкое упражнение
реализовать мэйк юник самостоятельно что написать надо просто сказать ретерн и уник птр от стд
форвард аркс аркс она появилась и плюс 14 а это все плюс 11 почему мэйк уник появилась позже потому
потому что потому что мэйк юник она не союз мэйк шерд и ребят в комитете подумали что мэйк
шерд это полезная функция мэйк юник в принципе зачем ну мэйк шерд позволяет оптимизировать
шерд птр не создавать лишний раз там и не вызывать лишний раз не а prolongtgunner ну что она позволяет
в принципе зачем непонятно но потом они поняли спустя три года что облажались на самом деле есть
еще одна проблема вот помимо всех упомянутых есть еще одна проблема из-за которой функция
makeShert и makeUnique необходимы и поэтому все плюсы 14 они добавили функции makeUnique смотрите допустим
я решаю в какой-то момент использовать Unique PTR так вот у меня есть функция которая да вот
у меня есть какая-нибудь функция которая принимает Unique PTR и я решаю это передать Unique PTR вручную
созданные я говорю Unique PTR там от int от new int да ну это все вызов функции я передаю но это не все
а еще эта функция принимает какой-то другой параметр ну например другое число вот c++ 11
догадайтесь что может пойти не так нет тут не особо что-то может пойти не так я число
получаю как вызов другой функции вот догадайтесь что может пойти не так что может пойти не так
ну нет а что не так-то будет даже выбросить исключения но и казалось бы и что ну выбросила
и выбросила но вот в чем проблема c++ 11 вычисления порядка аргумент вычисления аргументов функции
не не упорядочено это unspecified behavior но хуже того не гарантируется даже что каждый
аргумент должен быть полностью вычислены вычислены только насчет вычисляться другой
поэтому теоретически возможно следующая ситуация что вы сделаете new int потом сделать
ложе а потом Unique PTR от того и если же выбросить исключения то у нас будет течка памяти потому
что Unique PTR еще не успел взять владение а new уже отработал нет компилятор имеет право вычислять
аргументы функции в любом удобном умопорядке в том числе что-то параллель он может вычислить
часть потом вычислить это потом вычислить это ну что-то параллельно нет ну например компилятор
решит что тут и тут есть какое-то одинаковое выражение которое он может соптимизировать
посчитали какое длинное рефметическое выражение написано а тут такое же но он просто его посчитает
не знаю и сюда же подставит его а потом вычислить до вычислить это до вычислить это ну к примеру так
вот функция make Unique избавляет от этой проблемы потому что если вы напишете make Unique вот если
не так напишем а make Unique с шаблонным параметром int то мы обезопасились и такого уже не произойдет
ну потому что если уж вычислиться make Unique от int то будет InU и UniquePtr конструктор сделаны
гарантированно а не может вычисление g прервать вычисление другой функции
ну до этого у меня был expression он состоял из вычисления вот этого потом вычисления вот этого
от этого а тут у меня один вызов функции его нельзя прервать вот ну и еще одна такая уж совсем
минорная проблема когда упорядочен оно не стало никогда а c++ 17 запретили то что вот я сказал то
есть вот эта проблема добавили make Unique чтобы решить эту проблему в том числе c++14 но
c++17 просто запретили компилятору прервать вычисление одного аргумента чтобы вычислить
другой вот начиная c++17 гарантируется что здесь это exception safe потому что вот этот
аргумент должен быть вычислен полностью причем это начнется поэтому эта проблема уже не актуальна
ну вот но еще одна совсем маленькая проблема это что когда вы пользуетесь Unique Ptr явно
конструктором вам тип нужно дважды повторять если у вас тип очень длинный и сложный то вы опять
понятно можете чуть-чуть ошибиться в названии типа то есть я сейчас делаю new что-то там вот очень
длинное std unordered map от std blah blah blah my hash my allocator от std вот это вот все а потом
таки а теперь пожалуйста Unique Ptr с шаблонным параметром вот это вот все то же самое от
моего п вот чтобы вам два раза не повторять этот длинный тип вам Unique Ptr может make Unique вам
только один раз но она работает начиная с 17 но нет она не работает еще потому мы же кстати на
прошлый паре как раз выясняли что она не работает как раз у меня не сработала же я пытался компилирует
потому что shard ptr можно конструировать не только от т от указатель на т а еще это указатель на
родителя т ой на наследника т и поэтому он не знает что подставить и поэтому вам придется
вручную повторять тип несмотря на то что ct ad появилось ну вот make shard make Unique короче
мораль новый пункт код стайла всегда пользуетесь во первых всегда пользуетесь умными указателями
когда это возможно а не сишенами во вторых не вызывайте их конструктор напрямую а вызывайте
через make shard make Unique на самом деле а кто кто у вас ведет паше охтямов но на самом деле когда на
самом деле мы с паше охтямовым как раз обсуждали эту проблему потому что он хейтил курс по плюсам и
говорил что почему люди приходят во второй семестр и пишут на си пишут сишные указатели
они умеют политься умею ну блин у нас вот такая программа мы только в марте успеваем указатель
протянутку а ну ладно ладно я понял ну тогда давайте вы побыстрее хотим ну короче все вы
теперь уже прошли теперь нет оправдания вот ну короче да да все теперь мы прошли умные указатели
теперь теперь у вас нет оправданий перед паше охтямовым я перед собой да не ну а что нормально
удобные умные указатели очень очень хорошие так вот не ну пользоваться ты им уже можешь
реализовать еще пока не можешь но сейчас сейчас сможешь скоро так идем дальше следующий пункт это
вик птр я это сотру сейчас именно следующий пункт о них вик птр называется сейчас мы будем
решать проблему возможных циклических зависимости shared птр вик птр это еще один умный указатель
который как раз решает эту проблему нет нет все хитрее сейчас узнаете значит ну смотрите
ну проблему я уже озвучивал представьте что у вас есть объект и в нем есть поле указатель
который указывает на другой такой объект в котором есть поле указатель а но указывает на
первый такой объект если оба эти указатели shared птр и то такая конструкция никогда не
будет удалена ну если вы вот ну если вы строите дерево например на shared птр и
родитель помнит ребенка ребенок помнит родителя вот такую штуку сконструировали а потом если вы
вот эту вот вершину отцепили ну то есть вы казалось бы вы сказали типа ну все я вы же на вы
же на умных указателях пишете вы не хотите delete ручную делаете вы типа отцепляете вот это и
такие все вот вот этот родитель теперь на лп тр и казалось бы это должен уничтожиться сам но нет мы
не хотите вручную делать вы хотите отцепили под дерево оно будет что-то но так не получится вот
вам придется ну вам придется вручную получается вот это что ну вот в случае
дерево ну короче сейчас я думаю
ну вот представим что это не дерево а просто какая-нибудь структура в которой
одно из полей указатель на другую такую же структуру ну или даже на
несколько ну то есть не несколько указатель на другие такие структуры
да вот и вы вот у вас у тебя есть такая структура в которой там несколько вещей
слазит друг на друга и ты типа а что я тебе рассказываю твоя структура вышла из
области видимости вот что должно произойти вот у тебя есть вот это вот
штука типа ноут вот она вышла из области видимости а в ней есть shared
птр на другую ноут а что должно случиться когда она из области видимости вышла
казалось бы но допустим у тебя ноут содержит всего лишь ин и shared птр тебе
казалось бы никакой не тривиальный деструктор не нужен если у тебя такая вот
структура ноут с интом и shared ptr на другое вышла из области видимости такой ну классно все удалится а
нет потому что у тебя две ноуты ссылались одна на другую и shared ptr казалось бы должен освободить
но нет потому что он еще думает что кто-то на ту же ссылает вот и все короче так не сработает и
поэтому мы сейчас изобретем еще одну еще одного монстра weak ptr это все проблема которая родственна
проблеме сборки мусора в языках поддержащих сборку мусора в джаве я уже говорил что ну там
джаве и питоне в шарпе там где еще и сборка мусора она страдает такой же правил почему
сборка мусора это не тривиальная алгоритмический вещь потому что потому что у вас могут быть
циклические ссылки вот ровно по этой причине и там каждый каждый язык программирования там решает
это по-своему там есть целые какие-то целые теории о том целые какие-то алгоритмы как это делается
там вот питоне например есть такие то поколение там 1 1 2 поколение объектов что-то такое вот ну то
есть вам нужно понимать на какие объекты уже нет ссылок на какие есть а если циклические ссылки
нужно чтобы уничтожить их ну вот а я shared ptr сам по себе не будет решать стд shared ptr не
будет решать и ваш shared ptr не будет решать эту проблему и чтобы эту проблему решать то есть
если у вас если у вас такие циклические зависимости возможны то вам надо использовать
weak ptr что такое weak ptr это слабый указатель что такое слабый указатель почему он слабый кто
развалится ну он слабый потому что он ничего не контролирует вот я бы так сказал он слабый
потому что он не может за себя постоять что ли я не знаю вот как-то так он не может а не вот он
слабый потому что он не может защитить то что под ним лежит от удаления кем-то другим вот так вот
короче weak ptr это такой ptr который базово поддерживает две операции создать shared ptr из себя на то
же самое а еще посмотреть не уничтожилось ли уже то что подо мной лежит базовая операция две посмотреть
не удалил ли уже кто-то то на что я смотрю а второе это если не удалил то создать shared ptr на него новый
как предполагается это использовать когда вы берете когда у вас есть циклические зависимости
вам достаточно просто один из ptr сделать weak вот если у вас есть ну например ссылка туда обратно
вот если у вас есть указатель на ребенка и на родителя то достаточно решить для себя в какую
сторону ссылка будет слабой вот в одну сторону ссылка будет сильной то есть она будет как бы
владеть а в обратную сторону ссылка будет таким наблюдателем вот допустим ну стандартный подход
это что указатель вверх он слабый ну я пунктирчиком нарисую то есть вы заводите shared ptr на сына но
weak ptr на родителя и прикол weak ptr в том что его мнение не учитывается при удалении то что
weak ptr указывает на что-то это неважно оно все равно удалится да понятно то есть вот если у вас
одна из один из указателей в цикле weak ptr то цикл правильно разрушится вам нужно просто решить в
какую сторону указатель weak ptr будет shared ptr должны образовывать такое ориентированное дерево
направленное а если у вас циклы возникают то вот стрелки в обратную сторону нужно weak ptr делать
тогда такая конструкция будет корректно разрушена потому что лишь shared ptr она будет как бы снизу
вверх разрушена так потому что сначала умру там нет нет сверху вниз сначала умрет вот этот он
умер умрут его дети потом умрут их дети ну и так далее ну если у себя если у тебя вся эта
вот конструкция вышла из области видимости допустим ты потерял указатель на нее уничтожается на
эту штуку уже нет ни одного shared ptr она уничтожается но у тебя был по всей видимости shared ptr на нее
когда его не стало shared ptr такой ага я был последним на эту указатель значит ее сейчас уничтожу
она уничтожается ее уничтожение величез собой уничтожение shared ptr на вот эти вещи потому
что они были в ее полябе эти shared ptr эти shared ptr что ну похоже что да
слушай это какой-то интересный вопрос ну блин не должно же так быть
ну возможно
так ну в общем вот это уничтожится потом уничтожится эти ну и так далее вся эта
конструкция уничтожится а то что вик птр и были снизу вверх это неважно потому что вик птр
что их самое главное свойство они их наличие не влияет на тот счетчик соответственно у вик птр
какие есть методы как пользоваться вик птр но вот у него есть метод expired bool expired
это метод который позволяет проверить умер уже тот кто под нами лежит или нет
ты молодец и правильные вопросы задаешь это непонятно пока это нужно кое-что изобрести
еще будешь чтобы это работала не будет еще один инт но сейчас сейчас узнаете так а еще
у меня есть вот такая функция shared ptr от t которая называется о господи а как она называется
вот это прикол я забыл как называется метод вик птр откройте кто-нибудь и переференз вик птр как
называется штука которая shared ptr лог что ли она называется да значит это лог да да да да это
она это shared ptr лог вот и она тоже конст по моему она же конст ну казалось бы да точно
вот это две главные функции два главных метода shared ptr ой вик птр то есть expired и лог
посмотреть не умерли объект ну прежде чем обратиться лог сделать ну ты у тебя нет
разыменования вик птр как операции если что а потому что если у тебя объект умер ты уб получишь
при такой операции как в чем проблема так так для сишном указатель ты можешь проверить
пустой ли он а для вик птр как проверить тебе нужна функция expired почему почему ты не почему
у тебя нету просто оператор звездочка да кстати мы не сказали самое главное про shared ptr
у них же оператор звездочка стрелочка еще перегружена но это я думаю понятно да про
стрелочку по моему говорили ну если не говорили прочитать стрелочка чуть сложнее звездочки там
нетривиально есть там костыль такой тоже языковое что стрелочка должна возвращать
сишный поинтер к которому автоматически описывается стрелочка еще одна в общем
у shared ptr и вик птр понятно есть оператор звездочка и стрелочка оператор звездочка у
нарная возвращает ссылку на вот эту вещь а оператор стрелочка возвращает указатель который там
потом да вот а если бы у оператора вик птр был бы оператор звездочка то чтобы она возвращала
ну в норме должен возвращаться темперсант а тут что будет возвращаться а если нет ну темперсант
звездочка возвращает темперсант конечно что ну конечно вот как бы реализовать как бы мы
реализовали звездочку у вик птр объекта может не быть ну то есть грубо говоря в контрол блоке
лежит нал птр там нет уже объекта ну и что мы будем делать а что будет делать звездочка бросать
исключение тогда значит умирать ну надо ссылку на те вернуть где ты возьмешь ссылку на те хоть
на какой-нибудь будет ce ну как ты вернешь ссылку на те от нал под ссылку они указатель на те это
должно вернуть что такое звездочка п на контрол блок то есть ты хочешь то есть ты хочешь вернуть
то есть ты хочешь забить на то что это может быть нал птр сказать блок стрелочка объект и вот его и вернуть
ну короче ладно ну давайте в общем этот вопрос оставим почему у вик птр нет звездочки но
ну наверное можно было бы реализовать куда который был делала убе если бы там был
expired но типа подразумевается что вик птр вы не так должны пользоваться вы вик птр
пользуетесь только для того чтобы посмотреть жив ли он еще пациент там и если жив то
шерп птр можно создать ты говоришь лог а дальше стрелочка что-то там нет подожди это не курс по
многопоточности да теперь у меня есть шерп птр на родители в смысле обратно так вик птр никуда не
делся просто кроме шерп птр кроме вид птр ты создал шерп птр шерп птр да так давайте обсудим как
expired работок это дискуссионный вопрос почему нет звездочка есть только лог но у нас в любом
случае понятно что функция expired должна быть в каком-то виде как она реализована как мне
вик птр понять у меня объект умер уничтожен уже или нет шерп птр ну начнем с того что шерп начнем
с того что вик птр может существовать только тогда когда есть уже хоть один шерп птр на то
же самое нельзя создать вик птр на что-то не имея шерп птр на это потому что вик птр не
уничтожает объект когда умирает сам вик птр не владеет объектом если ты создаешь вик птр
подразумевается что ты наблюдаешь за тем кем уже кто-то кем уже кто-то владеет вот шерп птр
может владеть объектом а вик птр такой создался такой ну я посмотрю но пока нету
шерп птр который владеет объектом нельзя сказать вик птр да вик птр создается от шерп
птр ну и от другого вик птр ну примерно конструктор вик птр он от шерп птр там
еще какие-то наверное есть но но не от сишного поинтера тот же звездочка это какое у нас
вот этот каунт а если там через мэйк шерп было
значит ну вик птр
хорошо значит у нас будет хранится base control блок звездочка блок да
ну да да да да да ты понял главную проблему а ты понял главную проблему главная проблема
не в этом главная проблема вот в чем у нас шерп птр когда умирает последний он уничтожает за
собой весь контролл блок включая счетчик а допустим еще вик птр и существовали на это если
после этого я у того вик птр спрашиваю умерли объект он должен сказать умер но уже удален
счетчик как он поймет что он то есть казалось бы вик птр должен здесь просмотреть на каунтер
сказать ну или нет но проблема в том что он никогда не может быть 0 просто что был бы
0 он бы был удален вместе с объектом нам нужно не удалять счетчик когда мы удаляем объект если
еще есть живые вик птр и потому что вик птр и могут еще смотреть объекта они уже к объекту но они
не запрещают объекта удаления но счетчиком они еще могут пользоваться поэтому когда шерп
тр удаляет объект свой видишь то каунт 0 он должен еще проверить а если вик птр и если есть
вик птр и то счетчик он не удаляет удаляет только объект правильно нам нужен еще один счетчик
который называется вик каунт нет все эти из вик птр уже ну это уже не смысл значит на самом
деле у меня в контролл блоке будет лежать два счетчика шерп каунт и вик каунт вот
мне опять не нравится то что мы сделали с этими контролл блоками потому что я не хочу хранить
дополнительно указать я хочу один хранить всего лишь да хочу хранить нам нужен все-таки
значит смотрите предлагаю вот что сделать давайте я все-таки сделаю контролл блок в котором
лежат сначала два числа потом т и буду хранить два указателя один из которых ну я буду хранить
два указателя которые в случае если создавался через мэйк шерет просто будут указывать на этот
самый контролл блок один и тот же просто на одно и то же место в памяти на начало этого контролл
блока а если если я создавался не через мэйк шерет то у меня будет указатель на т указать в
другое место и так я пойму что у меня в контролл блоке нет т есть только счетчики у меня все-таки
указатель на т будет отдельно они указатель на счетчик я хочу у меня в контролл блоке либо
или нет я создаю контролл блок в котором либо есть только счетчики если ты уже создан был либо
есть счетчики те и как я буду понимать контролл блок у меня с т или без него а я
буду просто либо этот указатель который указатель на те будет он будет указать и
другое место либо вот указать на тоже самое место если он на то же самое место
Если указать, буду просто плюс делать, плюс два счетчика, это не страшно.
Вот, короче, такая идея.
А иначе контрол блок у нас на месте, то что будет?
Бейс контрол блок будет хранить два счетчика.
Значит, тут будет shared count и weak count.
shared count.
То есть на самом деле надо два счетчика.
And weak count.
Вот.
Control блок, это будет наследник base control блок,
который еще дополнительно хранит T.
И у меня будет указатель на...
А...
Может, можете наследование замутить здесь?
Ну, я имею в виду, что здесь должен быть указатель, видимо, на T.
На base control блок и на T, да?
Блин, не нравится мне это.
Нет, я не хочу на base control блок и на T, потому что...
Ну, потому что вдруг так случайно получилось, что они просто рядом оказались,
но не потому что я их создал одновременно, а просто потому что рядом оказались.
Да, я хочу, чтобы у меня именно равны были вот эти указатели как числа,
если я их создавал одновременно.
То есть у меня будет указатель на base control блок
и указатель еще на какую-нибудь штуку, которая является...
Которая может быть либо T, либо...
Либо указателем просто на T, либо...
Либо указателем на то же самое.
Да, сейчас, что-то я не понимаю.
Нет, ну я понимаю, но я думаю, как это сделать, чтобы...
Чего? На CPU сейчас не написано, как это реализовано, конечно. Ты чего?
Ну да, в ST.
Ну давайте, я не знаю, сделаем...
Ну давайте сделаем T звездочку, действительно.
PTR все-таки.
Которая будет либо... Мы просто будем проверять,
либо действительно здесь, либо действительно она с этим control блоком рядом,
либо... либо нет.
То есть у меня будет T звездочка, которая...
Сейчас, а почему я вообще сделал... Почему я их поменял местами?
Я что-то уже перестал... Я что-то уже запутался.
Почему я поменял местами T и control блок?
А, потому что T может быть не всегда там. У меня обязательно должны быть два счетчика,
но не обязательно T, да. Ну то есть у меня, короче, есть указатель на control блок,
который начинается с двух чисел в любом случае.
А дальше там либо лежит T, либо не лежит T.
Вот этот указатель на T, он будет либо вот вести на область памяти
сразу после этого control блок, либо куда-то в другое место.
И так я буду понимать, я через make-shared или не через make-shared создался.
Звучит как убыть.
В материале поместили их подряд просто в памяти с помощью...
У нас есть памяти локатеров, по которым мы знаем об убедении.
Например, наш стеклокатер, который честно кладет друг за другом.
Вызвали два подряд, получили проблему.
Сначала T, а потом T.
У нас есть стеклокатер, который зачем стоит по обратном порядке.
Стеклокатеры в этом порядке?
В смысле, который с конца...
У нас есть подряд, как будто это одна общая control блок,
и мы дальше сможем сделать...
Сейчас, подождите.
Да-да-да, конечно, конечно.
Нет, понятно, что можно bool добавить, но я не хочу bool добавлять.
Понятно, что если бы мы добавили bool, то все решилось бы.
Я хочу красиво сделать.
Можно сделать вот так.
Как?
CD, ray, variant.
Ну да, тип, который равен либо тому, либо другому,
его можно пронициализировать как этим, так и другим.
А там будет храниться типа?
Да, но это не очень правильно, потому что мы все равно ничего не соптимизировали.
Там будет храниться, скорее всего, дополнительная штука.
А...
Ну как обойтись двумя полями, чтобы не хранить bool дополнительный?
Понятно, ты сконструировался через makeshared или не через makeshared?
А потом появился weak count еще.
Понятно, что мне надо либо еще один int хранить тут, либо...
либо указательно еще один int хранить, либо...
Да.
Base control block.
У меня base control block начинался с T.
А давайте еще один base control block делаем.
Давайте добавим стандартный...
Сейчас.
Почему не работает то решение, которое было, когда мы weak count добавили?
У меня был base control block, который хранил только T,
а их control block хранил его еще счетчик.
И у меня было, получается...
У меня был этот либо налпы...
Ну это еще счетчик, а структуру счетчик.
И теперь мы будем хранить счетчик звездочка.
Да, структуру счетчик.
Да, структура counter.
Структура counter.
Да, да, да, да.
Кажется, вот так.
И кажется, что-то я наворотил совершенно зря.
Можно просто сказать, что...
Давайте скажем, что структура называется counter.
Смотрите, структура counter.
И мы храним указатель на counter.
Base control block выглядит как...
Просто T.
А control block выглядит как T и еще counter.
Да, мы храним указатель на...
Да, все, все, все, извините.
Все получилось, все хорошо, да.
Все сработало.
Да, все, давайте дальше.
Ну давайте еще раз.
Я уже понимаю, что, наверное, никто ничего не понимает.
Ну просто 3 раза...
Ну, я просто...
Я просто зачем-то начал менять местами поля этой штуки.
И это была плохой идеей.
Надо вернуть как раньше.
Давайте я просто напишу полностью.
Давайте я просто напишу полностью, что у меня есть.
В чем шутка?
Нам не жалко для одного объекта,
на который мы собираемся создавать 10 тысяч SHFQR,
создать несколько лишних инток.
Один объект один раз.
А в каждом SHFQR хочется хранить как можно меньше.
Понятное дело.
Структура base control block
будет хранить просто T.
Вот.
А структура control block
будет наследницей
base control block.
И будет хранить
еще дополнительно
counter.
Тогда как это работает?
Если мы создались
через make shared,
то у нас хранится структура
control block, в которой хранится
object и counter. Все нормально.
И вот этот counter
он на LPTR, да?
Он на LPTR, потому что
мы так договаривались раньше.
Мы понимаем, что если он на LPTR,
значит мы через make shared создались.
А если мы создались не через make shared,
то у нас есть лишь
base control block,
он настоящий base control block,
в котором лежит...
Мы пронициализируем
тем объектом, который
указатель на который нам дали...
Ну да, reinterpret cast,
наверное, просто.
Reinterpret cast, да.
Я просто скажу, что тот указатель, который
мне дали, это и есть указатель на base control block.
И это будет корректно, потому что
base control block это plain структура,
которая просто поле типа T и все.
Это нормально, это не UB даже.
Даже не UB.
Ты чему радуешься?
Проблема в том, что вы этому радуете.
Так, все работает, нормально.
Отлично.
А тут не T, а значит object?
Нет, именно T, object.
Потому что когда мы сделали
make shared, мы реально на ней
создали объект.
Короче, по второму смысле,
это указатель.
Так, кто понял
проблему и ее решение?
Хорошо.
Что непонятно?
Как работает expired?
Ну как?
В wik.ptr хранит то же самое,
что и shared.ptr.
На самом деле в wik.ptr хранит...
Да, вопрос такой,
когда мы удаляем счетчики наконец?
А, в деструктуре wik.ptr, конечно.
Ну то есть в деструктуре
shared.ptr теперь мы не удаляем счетчик,
если еще был wik.ptr.
В деструктуре shared.ptr теперь мы делаем
еще дополнительную проверку.
Если ты последний wik.ptr,
ты удаляешь control block.
А если это было все через make shared
создано, то ты удаляешь всю эту штуку.
Когда уничтожается shared.ptr?
Он должен проверить.
Есть ли еще wik.ptr?
Если есть wik.ptr, то он просто вызывает
в деструктуре t,
а память не освобождает.
Вообще не освобождает?
Конечно. А как?
Если он был выделен через make shared,
то он выделен одним куском.
И это, кстати, недостаток функции make shared.
Это та причина, по которой
некоторые считают, что функции make shared
все-таки не стоит пользоваться иногда.
Потому что функция make shared
обладает следующим недостатком.
Если у тебя есть wik.ptr
и ты уничтожил последний shared.ptr,
то все равно будет выделен лежать.
Но если t большой
и у тебя wik.ptr переживают
shared.ptr постоянно, то у тебя будет лишняя память
использоваться.
Но деструктур t будет вызван shared.ptr.
А вот память будет не освобождена
и счетчики будут еще храниться.
Если же у тебя wik.ptr
нет, то ты полностью удаляешь все.
А вот wik.ptr
это важно.
Очень часто люди ошибаются в этом.
Как устроен
деструктур wik.ptr?
Деструктур wik.ptr
никогда не удаляет
t.
Он поэтому и wik.
Он удаляет разве что в счетчике.
То есть wik.ptr смотрит
на деструктур wik.ptr
смотрит, есть ли еще
есть ли еще хоть что-то
shared count или wik count.
Если это есть, то он ничего не делает.
И если
только деструктур wik.ptr
обнаруживает, что нет ни shared
count и wik.count
то wik.ptr
диалоцирует память под
это все, но деструктур t
не вызывает уже, потому что деструктур t
вызван shared.ptr. Только shared.ptr
ответственно за то, чтобы уничтожать t.
Wik.ptr отделал удалить счетчики.
Все, так работает wik.ptr.
Соответственно, как работает expired, мы просто
смотрим на shared count.
Как работает log, мы просто
смотрим, если shared count, опять же
не ноль, если это ноль, то мы кажется
бросаем исключение, наверное, bad wik.ptr
какой-нибудь.
А если не ноль,
то создаем
shared.ptr на него. И это дешевая
операция, потому что создание нового
shared.ptr не привлечет к созданию
ну, это очень дешевая операция.
Да, мы просто создаем shared.ptr,
который хранит те же
два счетчика, те же структуру.
Никого нового выделения памяти не происходит, потому что
log может отработать только
когда shared.ptr уже был. Не то же самое.
Да.
То же самое, что и shared.ptr, да.
Делает не то же самое, что и shared.ptr.
У него
дофига различия, у него нет почти ничего,
что есть в shared.ptr.
У него нет звездочки, нет
стрелочки, у него нет useCount.
UseCount, кстати, может и есть.
UseCount — это сколько еще shared.ptr
на то же самое указывают.
Главное различие — его нельзя разоменовать.
Вот это две главные его операции — expire и log.
