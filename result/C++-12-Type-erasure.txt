Наша цель на сегодня не очень большая, но такая есть. Нужно научиться реализовывать
некое подобие контейнеров, которое содержит сущности переменного типа.
В частности, шерты с кастомным локатором. Но это не контейнеры, это я неправильно сказал.
Мы сегодня не поговорим о том, как Сипрос Плюс устроит динамическую типизацию.
Ну так. Некое подобие динамической типизации. И это будет тема 14, которая будет называться,
ну можно было бы ее назвать, наверное, я пока сюда шел, вот я придумал, что ее, наверное,
можно было бы назвать одним словом динамической типизация, но давайте я более подробно напишу.
TypeRanger и Union. На самом деле есть примерно два разных подхода к тому, как можно устроить
в плюсах динамическую типизацию. TypeRanger и Union. Ну и опять-таки, честно говоря, поскольку плюсы
это основа мироздания, значит, я подозреваю, что в большинстве языков, в которых есть динамическая
типизация, в том же питоне, скорее всего, ну под капотом примерно так что-то и работает.
То есть у нас просто, мы сейчас просто реализуем это, и вы поймете, что, ну в общем-то, это,
пожалуй, естественный способ, и другого-то, собственно, принципиально какого-то особо не придумаешь,
мне кажется. Вот, мы начнем с TypeRanger. Это такая идеологическая стирание типов,
ну по-русски уже довольно прижившийся термин, и разберем мы это на примере такого замечательного
класса, который называется STD Any. Значит, STD Any, ну и его реализация. Что такое STD Any,
как вы, наверное, можете догадаться из названия. Да, это объект, который может хранить любой тип.
Ну, он на самом деле, этот тип появился, начиная с C++17 только. Ну, сама идеома TypeRanger
появилась гораздо раньше, но вот этот тип появился с C++17, и вот мы начнем с него,
потому что он самый такой, ну самый простой, что ли. Вот, ну давайте для начала как им пользоваться.
Смотрите, я могу написать STD Any, да, ну, во-первых, надо подключить загадочный файл Any,
могу написать STD Any a там равно 5, и теперь Any будет хранить int. А потом я могу сказать a равно,
но вот если так сделать, я, честно говоря, не уверен, что он будет хранить. Ну, давайте я вот так
напишу. Вот так сделаю. Ну, это значит, для строк есть типа, пусть не было бы начинать с такой версии,
литеральный суффикс s, это значит, что this is the Sting, а не Charles S. Вот, теперь a будет строкой,
потом можно a положить вектор, ну, короче, что угодно можно сделать с a. Вот, нет, чтобы обратиться к
тому, что в a лежит, вот это хороший вопрос. А как обратиться, собственно, к отцу? Или можно ли написать,
сейчас, по крайней мере, можно написать auto b равно a? Да, b будет Any. Ого. С таким же
содержимым. Логично. И String b равно a нельзя написать сейчас. А там a минус abc? А равно? Нет, это присваивание,
не минус конечно. Таких операций мы не поддерживаем. Вот, как обратиться к тому, что в Any лежит? Нужно знать,
что там лежит. Это некое неудобство, это вам все-таки не питом. Придется явно говорить,
какой вы хотите тип, когда к Any обращаетесь. То есть, вот вы можете обратиться к Any и сказать,
ну, давай-ка достань мне строку, которая там сейчас лежит. Но если там будет не строка в этот
момент, то exception. Сейчас. Он не знает, что там лежит. Нет, кто? Any. Сам по себе. Что значит
знает? В смысле? И вот если вы просите его вернуть строку, он вернет. Если просите вернуть int,
сейчас он не справится. Да. Но при этом сам он не может понять, что мы от него... Нет, может,
может, спросить type. Значит, есть два основных метода. Type и, ну, вот, скастовать к данному
te. Если там действительно te, то все будет хорошо. То есть, можно скастовать к type и все. Да. Ну,
и спросить, какой type. Он вернет type id. Ну, то есть, можно сказать a.type. Сейчас, я, на всякий
случай... Да, Any. Значит, type это такой метод, который просто возвращает вам type id. Ну,
можно написать name. Это вам выведет... Ну, вот это будет type id. Тот самый type id, который вернул
у нас, когда мы виртуальное добро всякое обсуждали. У type id есть поле name? Ладно. Не поле, а метод.
Собственно, это и, по сути, главный метод. Один из двух главных методов, который у него есть.
Оператор равно и name. Все. Вот, можно спросить вот так. Какой тип сейчас? Ну, соответственно,
можно вот это не писать, а можно, например, проверить, правда ли, что в any лежит string. Ну,
можно написать. Правда ли, что a.type равно равно type id вот... Ну, что? Сд string. Ну, что-нибудь в
таком стиле. То есть, вы можете проверить, правда ли, что там лежит тот тип, который вы хотите. Вот. И
дальше вы можете скастовать к нему. Сейчас. Как скастовать к нему? Как взять тип type id какого-то
объекта? В смысле, вот не any, а string. Да. Оператор type id. Это оператор такой встроенный. Мы о нем
говорили, когда было виртуальное расследование. Мы о нем говорили в первое семестре, когда были
виртуальные функции. Да. Ладно, видимо, в моей голове просто отразилось, что с невиртуальными
классами это не работает. Это работает со всеми классами, но имеет смысл только для полиморфных.
Ну, потому что для неполиморфных вы в compile time знаете тип. Ну да, понятно. Чем type id
спрашивать. Вот. Но работает это со всеми. Но вот теперь еще у нас есть any, с которым это
тоже работает. Ну и, спойлер, я по-прежнему... Ну, это все еще работает только для полиморфных.
Просто там внутри полиморфизм просто спрятан. Виртуальные функции, на самом деле, внутри. Но
сейчас увидите. Вот. Ну так вот. И еще есть сейчас функция. Это не оператор. И это даже не метод. AnyCast.
AnyCast к типу T. Я могу сказать AnyCast std AnyCast. Все, вот у меня без std. AnyCast к std String.
Вот a. Ну, сказать auto s. Ну вот так. Это будет значит строка. Ну, это будет копия строки. Вот. А можно
ли? Не копировать. Нет. Скастовать его к его type. Нет. Блин. В смысле? Он знает свой type,
но скастовать к нему нельзя. А, это логично. Конечно, это очень логично. Это попытка сделать
питон, но в меру сил, так сказать. В меру сил. Ну вот. Можно не копировать. И тогда у вас есть метод...
Ой, не метод, извините. Это все не методы. Это внешняя функция. AnyCast, которая возвращает вам...
А, да, кстати. Есть еще. У AnyCast есть перегрузка, которая принимает AnyAmpersand. А можно вот так.
Ну, тогда вы заберете просто из Any и его содержимое. Ну, все нормально. Вот, чтобы не копировать.
Видимо, будет пустой объект. А, который там был. Вот. Да, там будет лежать... Что угодно. Не типизировано.
Нет. Там будет лежать, я думаю, все еще тот же тип, просто пустой. Ну, вы мугнетесь как-нибудь.
Да. Оттуда. Вот. Ну, можно не копировать, а можно сделать так. Можно сказать, что я хочу...
Не знаю, почему. Почему-то нету AnyCast на ссылку. А, ну понятно. Потому что как исключение? Там как?
А, нет. Не понятно, почему нет AnyCast на ссылку, честно говоря. Но есть AnyCast-показатель.
Можно вот так сделать. И тут тогда, наверное... Ну, тогда тут лук присутствует. А зато можно написать
AnyCast. Ну, то есть, я вот так вот делаю и получаю указатель на стринг. Вместо того, чтобы получить
новую стринг. На ту стринг, да, которая там лежит.
Зачем все равно передавать указатель на AnyCast? Ну, чтобы он отличал... Я вызываюсь.
Так, может быть, в Any лежал ST-стринг звездочка. Когда я вызываюсь от указателя на Any, он понимает,
что я хочу указатель на Т получить, а не сам Т. Так. Сейчас. Откуда он возьмет указатель на Т?
Ну, у него же там Т хранится. А, ну да. Ну, указатель вернет. Еще. Так, все. Это короткий, значит, гайд,
как пользоваться STD Any. А, ну да, эта штука бросает исключение Bad AnyCast, если там лежал не этот тип.
Если что-то наследники, родители... Нет-нет. Не работает. С наследованием, сколько знаю, не поможет.
Вот. Ну, все. Вот это все, как можно использовать STD Any. Ну, можно вектор из Any создать. Да.
Понятно, что Any можно копировать, мувать. Вот. Как обычно, оператор присваивания у него есть.
И будет вызываться просто оно у его типа, и все. Ну, да-да, он просто мувит.
Не, а пункты... Вот AnyCast, STD, Stringer, Tempest, Sat. Вот звездочка вернул ноль. Хотя и не пустой, интересный.
Чего?
А ты не последний, кто это сделал? Нет.
Ну, все. Должно быть, как я сказал, по идее. О, стоп. Он звездочка не бросает исключение, скажи. Или я прослушал.
А, да, это правда. Звездочка не бросает исключение. Как стройный макад. Ну, понятно, да.
Да, да, логично. То есть он просто либо нолпойнтер, если вы типа не отгадали, либо вернет просто.
Может, тебе там лежит нейтрей?
Я, честно говоря, что-то вот смотрю на это и не понимаю, почему-то все-таки нету ссылки. Не знаю.
То есть мне почему-то казалось естественным, что должны быть ссылки. Понятно. Ну, фиксим.
Ну, указать ему можно, по крайней мере. Так вот. Как это реализовано теперь? Нам надо понять.
Что там внутри? Ну, вы уже... Я уже засполнил, что там. Там виртуальные функции.
А давайте, может, вы придумаете сейчас, как это сделать.
Идея красивая и такая прям... Ну, короче, прям вот красивая штука.
Я, кстати, читал этот курс в первый раз лекции еще, когда это была весна 2019 года.
Ну, когда впервые я постал лекциями. Вот я тоже рассказывал про ЭНИ.
Но тогда я сам еще не знал, как оно реализовано. Ну, потому что это был C++17, и что-то я там затупил.
Вот. И сходу не придумал. Ну, вот сейчас я предлагаю еще раз вместе подумать.
То есть штука довольно красивая, если...
Ну, так. Просто знаний имеющихся уже достаточно, чтобы это придумать.
Надо придумать. Что нужно написать? Что должно быть внутри?
Но самая проблема, главное, какая? Надо, когда мы меняем, вот когда мы так делаем,
надо корректно уничтожить то, что лежало раньше.
Нарушить что-то вроде указатели, ну, на функции деструктора.
Вот да, да. И вот это вот как раз... Ну да, это проблема. А что именно там? Как это должно?
Ну, мы уже чуть-чуть говорили про то, что там есть какой-то подкапот дополнительный, более тяжелый вес,
который хрень кучит указателей, а на хрень мы контролируем его.
Ну, сейчас Уэйни там, ну есть где-то еще...
Представим себе, у нас есть вот какой-нибудь стринг, да?
У него, конечно, нет таблицы виртуальных функций, но можно ее сделать.
Просто таблицу функций стринга.
Вот. И хранить указатели на этой таблице функций, и все.
Как-то там к ней обращаться. Как ноль людей.
Нельзя же унаследоваться от всех типов сразу.
Да, вот проблема в том, что действительно нужно хранить какие-то внутри указатели на...
Ну, на что? На типа... На деструктор, на...
Если мы копируем 1A, то тоже нужно что-то вызвать правильное.
Наверное, мы по меньшей мере храним какую-нибудь звездочку на сам объект.
Ну...
Плохо, конечно.
Ну, например...
Ну, не будет звездочку на самом деле, а кое-что другое.
Вот, короче, да, смотрите, гениальная идея.
Нам нужно где-то сохранить указатели на разные методы.
И они динамически подменяться должны.
Но если подумать, если так вот переосмыслить то, что мы знаем,
вообще-то у нас уже есть языковой механизм, который это...
Виртуальный функции?
Конечно.
В смысле, я сказал, у нас нету у стринга таблицы виртуальных функций.
Если она была, мы могли просто на нее сослаться.
Нам нужно что-то такое сделать, чтобы как-то...
То есть не хочется это руками прям реализовывать, да и непонятно как, если честно.
Ну да.
Хочется как-то выразить через виртуальные функции вот эту идею,
что нам нужно просто на произвольный тип навесить табли...
Ну, добавить к нему таблицу типа виртуальных функций,
которые будут говорить, что делать, если деструктор позвали,
что делать, если то позвали, все позвали.
Вот.
В общем, идея гениальная, красивая и простая.
Мы сейчас объявим...
Шифронного наследника для каждого типа.
Да!
Серьезно?
Мы сейчас, здесь внутри,
во-первых, напишем такое.
Ну, это все в приватной части я пишу.
Ну, давайте я не буду думать над названием особо.
Я назову просто StructBase.
И эта структура, она будет особо-то ничего не...
Она будет просто полиморфная.
Все, что мне от нее надо пока, что это...
Виртуальный деструктор, чтобы она полиморфной была.
А теперь я скажу, что для каждого Т
будет наследник этой штуки...
Изя.
Просто парень в чаши.
Слышишь?
Значит, у меня будет наследник этой штуки
для каждого Т.
И что будет в этом наследнике?
Сейчас нас... Ага.
Убираю деструктора.
Т...
Т и...
Ну, типа на конструктор.
На деструктор, на какие-нибудь еще функции.
Ну, давайте подумаем, что нужно в наследнике.
Давайте для начала просто вот без копирования,
просто вот, чтобы мы могли...
Ну, вот, чтобы тот код, который это это написал, работал.
Чтобы мы могли один А и Н создать,
присловить ему потом другой тип и так далее.
Сейчас.
У нас что-то среднее между лекцией семинаров,
ближе к семинару, кажется, вот, но...
Ну, тут реально вот прикольно.
Это, скорее, такая задача.
Нам точно нужно виррайт деструктора, давайте так.
Ну, да.
Ну, деструкторы, там не пишется overwrite,
они просто...
Нужно сохранить объект типа Т.
Мы же не его наследник.
Начнем с того, что где-то хранить само Т надо.
Вот здесь.
Вот здесь самое место, да.
Вот прямо тут мы и сохраним его.
Мы же от него не наследовались.
Так.
А что мы будем, собственно, в полях хранить?
Amy.
Давайте поймем.
Вот я не знаю, здесь где-нибудь...
Блин, плохо я, конечно, доскуюсь больше.
Ну, давайте вот здесь...
Указатель на base.
Да, вот тут, короче, будет продолжение кода класса Amy.
Вот в полях у меня будет...
Ну, вот, продолжаем.
Класс Amy.
Тут будет указатель на base.
Ну, не знаю.
Не буду думать именно названиями.
Ptr.
Это в derived или нет?
Это в Amy.
Вот это класс Amy.
Да, но вот в нем сначала есть две такие структуры.
Я пока что-то не знаю.
Там продолжение derived, а там продолжение Amy.
Да, что в derived мы дописать должны?
Сейчас мы подумаем.
Давайте для этого сначала подумать, что в Amy, собственно, будет происходить.
У нас есть указатель на base.
Ну, как будет выглядеть, например, указатель на...
Не указатель, как будет выглядеть конструктор.
Amy.
Вот мне говорят...
Шаблонный конструктор, чего угодно.
Да, template type name T.
Amy.
От...
Ну, давайте скажем const temperson.
Value.
Что нужно сделать?
Ну, зря рано я скобку открыл.
Нужно две точки.
Создать объект типа derivedT.
Чем проинициализировать поле мое?
Ну, да, объект типа derivedT.
Проинициализировать чем?
New.
New?
О, господи, нет, только не new.
Нет, аллокаторов не будет.
Спасибо большое.
В этот раз аллокаторов не будет.
А в Amy нет аллокаторов.
В Amy нет аллокаторов.
Да, на самом деле
комитет
к 2017 году
начал подозревать, что
пихать аллокаторов в всюду
кажется, было не очень хорошей идеей.
И в Amy они уже не стали.
Долго ожидали.
Не подходило, это правда.
Но, потому что
все равно
ну, короче, они поняли, что
использовать аллокаторы не всегда удобно.
Они даже придумали полиморфику аллокаторов.
Как вы помните.
Вот, new derived
от
t?
Нет, не от.
Или он сам подставит?
Derived t.
А, new derived, ну
да, можно во-первых
я забыл шаблонный параметр.
New derived с шаблонным параметром t,
но я думаю, что
в сети AD
здесь есть.
Вот.
Да и, в общем-то
все.
Конструктор мы написали.
Объект готов.
Вот.
Ну и давайте, как будет выглядеть,
вот в чем мы пользовались.
Расписываемся, оно страшное, потому что
нужно деструктор вызывать.
Ну деструктор там, ну да.
У нас его еще нет.
Значит, тем не менее,
темплей
опять type name
type name
t
any
апператор равно
от конст
t
Она хорошая,
типа от t
2 амперсанта.
5 2 амперсанта.
И ты не можешь сделать здесь так.
Говорите, пожалуйста.
Это не будет универсальная ссылка.
Вот, у слова амперсант последняя буква d.
Давайте будем говорить амперсант да,
а не амперсант так.
Меня бесило.
Короче, говорите правильно.
Я не знаю, кстати,
почему все говорят амперсант.
Я не знаю.
Я не понимаю, почему.
Надо сделать паузу перед d, чтобы
сделать 2 амперсанта.
Ладно.
Все хорошо.
Короче, нет.
Чего вы говорили
про 2 амперсанта?
Мы же должны уметь делать
конструктор от std move
потом.
Понятно, что нужно еще
версию для 2 амперсанта.
Это все ясно.
Кстати,
вы же понимаете, да,
что проблема. Если мы сделаем конструктор
n от t2d на амперсанта,
это будет универсальная ссылка.
Будет ли?
Конечно.
Но он же не ARKS.
Он же не ARKS.
А мы тогда сможем
передавать этот форум
на твоей лифте?
Ну, сможем.
Ну, короче, слушайте, это детали.
Это уже упражнение.
Реализовать оставшиеся методы
это, в общем...
Ну, понятно, да, что нужно еще
от move, от RBL
правильно сконструироваться уметь.
Нет, это будет универсальная ссылка, если ты...
Ладно.
Ты думал, универсальная ссылка будет только то,
как это многоточие бывает? Нет, конечно.
Нет, такого я не говорю.
Так вот, а что здесь сделать надо?
А может, сначала деструктор напишем?
Ты сам сказал сначала
оператор присваивания. Давай уж оператор присваивания тогда.
Вызываем деструктор.
Нет, деструктор чего?
Ну, не себя, а деструктор T.
Как это нужно вызвать сейчас?
Ну, мы не можем пока что.
Нужно дописать бейс.
Да, что же делать?
Давайте приопределим
деструктор derived. Это же тривиальная штука.
Tilde derived,
overwrite, что там.
Вызываем деструктор, его T,
и все.
Что?
Ну, давайте
у derived переопределим деструктор.
Или оно уже нормально?
Если ты у derived в деструкторе
напишешь вызвать деструктор этого,
то
что будет происходить?
А, у него уже есть
по умолчанию. Все хорошо.
Можно просто вызвать его.
Какого вызвать?
Ну, точка.
Явно.
И диалатировать потом еще надо.
Господи, зачем?
Delete просто давайте сделаем.
Тупой я просто.
Я путаю деструктор и delete. Простите меня, пожалуйста.
Я не делал первую задачу для основы,
которая была на это, и все.
С тех пор. Прочек.
Что за первая задача для основы?
Самая первая задача. У нас была string,
а у них была еще что-то.
Я понял, да.
New, delete. Я их пропустил, все.
Для основы.
Когда не было, это просто
так сказать, чтобы люди
получше освоились, а то обычно люди
не освоятся, но
я не освоил.
Delete, ptr. А почему это корректно будет?
А потому что он вызовет что?
Что он сделает?
У нас же был уже delete
с абстрактными,
господи, с виртуальными классами.
Поскольку это полиморфный тип,
благодаря тому, что
виртуальный деструктор, когда мы сделаем
delete этой штуки,
он правильно уничтожит объект.
Он правильно вызовет
деструктор, он вызовет деструктор именно
той штуки, которую надо.
Но вопрос, от этого в какой момент уничтожится?
Когда вызывается деструктор derived, у него уже
поле есть t, значит,
угадаются все поля объектов.
Но на самом деле сначала отрабатывает код
деструктора derived, который нет.
А потом
уничтожаются поля derived,
ну то есть это все
у нас компилятор делает.
А потом вызывает деструктор based,
уничтожается поля based,
и диалацируется память тоже в
правильном количестве.
Просто вала.
Классно.
А теперь, в общем-то,
PTR, можно сказать, PTR равно
Сейчас бы явно деструктор
отвел ее.
Все.
Кайф.
Ну, деструктор это просто delete PTR, кажется.
А че
в derived нам вообще больше ничего не надо, что ли?
Или как?
Пока выглядит как будто да.
Ну конструктора нет пока.
Да, нету конструктора.
Ой.
Ну давайте скажем, что конструктор
ну конструктор триреальный.
Биз не будем возвращать?
Где?
А.
Ну конструктор тут понятно.
Кстати,
с какого
с каких плюсов у нас вообще есть виртуальная функция
вообще такая?
Прямо с рождения. С третьих.
Нет, третьи это не первая, это начальная версия.
99-й, 98-й.
Ну,
в 98-м они уже были,
но даже 98-й это не начальная
версия. Круто.
Там была еще какая-то суп супер древняя, 80-я какая-то.
Круто. А когда плюсов было?
Тоже очень давно.
Ну, короче,
скорее всего раньше, чем мы все родились,
поэтому, я не знаю, когда.
До исторической эпохи.
Отчета, отчитывая время
от моего дня рождения.
Да.
Сеологично абсолютно.
Да, это до исторической эпохи считается.
Так, хорошо.
Чего не хватает еще?
А в деструкторе нам ничего не надо написать?
Мы не написали.
В 103 дирает зачем?
Да.
Они ж все обвертки вроде просто.
Никчемные.
Сейчас, если мы ничего не напишем
в деструкторе.
Но он будет дефолтный.
Ну да, скорее всего будет нормально.
Можно написать просто, что он
дефолтный, наверное.
Подстраховаться
точно не будет.
Ну, давайте теперь поймем, как копирование
устроено.
Вот тут, на самом деле, чуть похитрее
надо сделать. Вот здесь,
если ты совпал с тем, который у нас,
то не надо заново создавать.
Надо просто копировать старый.
Ну, надо присваивать, присвоить.
Я не играю тутом.
Вообще, по идее.
Это ладно.
Это чуть более хитрая история.
Как копировать Эни?
Вот как будет выглядеть конструктор
копирования Эни?
Эни
от конст Эни Амперсан.
Что тут должно произойти?
ПТР проницилизировать надо чем?
Это отличный вопрос.
Когда-то это было вопросом
на отел 10 на экзамен,
а теперь это будет вопросом, скорее всего,
на какой-нибудь хор.
Времена меняются, да.
Инфляция, ценок.
Во-первых, да, во-вторых,
то, что 5 лет назад еще никто
в мире не знал, сейчас
постепенно становятся общей практикой,
как надо писать, поэтому неудивительно.
Теперь в 20
уже изобретали такого, что 5 лет назад
никто не подозревал, что такое.
Кто-то может придумать.
Опять, нам нужно менять
утирайф оттэ, не знаем, какой у нас тэ.
Да.
Давайте Вене, что ли,
утирайф хранить
оттэ или юзинг.
Ну хотя бы что-нибудь.
Юзинг оттэ.
И что?
Мы же не можем менять юзинги.
Нет, подожди, а как ты
ПТР сконструируешь, от чего?
От чего?
Погнали, короче, в точку копии
сделаем функцию.
Нас учили на этой
давайте втирайф
и объявим функцию.
Где вас учили? На ТПшке.
Паттерн такой.
Что-то там, кто-то там,
что-то там.
То, что втирайф, это функция,
которая будет сообщать указанного утирайфа.
Уважаемо, уважаемо.
Ура! Хор! Сколько?
Пять? Но учили, да.
Блин, это же сильно.
Надо было не говорить, что нас к тому учили.
Он бы таким умным меня считал.
Да, вот, короче,
здесь нужно функцию кофе сделать.
Которая возвращает,
типа, бейз, звездочка и нормально.
Или может со... Щас.
Может ли у виртуальных методов
быть разный возвращаемый тип?
Вроде нет, поэтому бейз, звездочка
и нормально.
Нам надо, чтобы она была виртуальной.
Ну да, понятно.
И здесь она будет равна нулю.
Ну или что-нибудь бросать будет,
ну неважно. А тут
значит, бейз, звездочка
копия.
Override?
Наверное, конст. Везде.
Ну да.
Еще no accept, наверное.
Почему? Нет.
Ну no accept здесь нет, потому что new везде вызывается.
Кстати, что насчет exception safety?
Ничего.
Ну в общем, да.
Исключаем исключения.
Ничего.
Ну и что здесь надо сделать?
Return.
Да просто я скажу, return new.
Derive от T.
От...
Ну, можно сказать, от object вот нашего,
а можно сказать от vis.
Короче, просто...
А vis можно?
Ну конструктор кофирования derived,
ну почему бы нам не написать?
Ну и тут мы про... да, и все.
А тут мы просто, значит,
говорим, что PTR мы имитализируем.
Значит, PTR, стрелочка, копия.
Ой.
ADAC PTR, стрелочка, копия, да.
Ну там, понятно, надо проверить,
что ничего не...
что это не NALPTR,
там, ну короче, понятно.
Тут не other.ptr.
Other.ptr, правда.
Да, ну вот и все.
По сути, реализовали.
Ну, понятно, что во-первых,
нужно проверки на NALPTR делать,
во-вторых, нужно там
что-то про exception подумать,
в-третьих, нужно для MOV
сделать правильные версии, то есть
правильную перегрузку
сделать в случае, когда RwL
передали, и тут для RwL что-нибудь сделать,
типа MOV. Ну, это все
упражнение. Для...
не знаю. Ну, вы можете считать, что
упражнение NALPTR какое-то будет.
Ну, как одна из задач на экзамене,
вполне можно быть...
напишите там
any... реализацию
как бы вы сделали там
не знаю.
Вот.
Ладно, это any.
Теперь классно,
вот этот вот, вот этот вот вот
вот это идиом называется type erasure.
Значит, в чем конкретно
заключается? Что мы делаем вот такую вот
штуку,
У нас есть база
И шаблонный наследник для любого tr
И на этом же, в принципе, основанная реализация будет еще как минимум двух классов, которые мы с вами разберем
Это, во-первых, широту tr, которую вам, собственно, и надо написать будет
Илья, а почему мы не хотели сделать оператор tr вот здесь вот?
Зачем?
Ну, у нас чтобы можно было неярно конструктировать tr
А где это надо?
Ну вот, у нас там были проблемы с тем, что мы всегда должны были знать, к чему костовать
Почему бы не знать, к чему костовать?
Так, еще раз
Ты хочешь удираем, да, определить t, оператор t
И где тебе это поможет?
О, Гостон не будет виртуальным, может отстой
Да, все логично, нормально, все отлично, все
Так вот, возвращаемся
Так вот, у нас есть еще как минимум два класса, где нам это пригодится
Один из них широта tr, а другой из них это что?
В прошлый раз мы это обсуждали
Function
Function точно в таком же принципе реализован
Ну, на самом деле Function реализован чуть хитрее
Там сделаны хитрые странные оптимизации, чтобы с виртуальными функциями не работать
Так можно меньше работать?
Или вообще не работать?
Вообще не работать
Господи
Ну, наверное, как реализована Function мы с вами разберем завтра
А сейчас мы поговорим о том, как все-таки реализовать shared ptr, вот тот самый многострадальный
Чтобы в нем и делитер был кастомный, и аллокатор был кастомный
Для этого нам потребуется вертальная функция
Вот в shared ptr, в реальном, востоянном shared ptr
Ну, если вы просто откроете код реализации shared ptr, то вы там, с удивлением, найдете слово virtual в нескольких местах
Потому что он использует вот эту вот штуку
Но там черт ногу сломает, невозможно понять, что написано
Потому что там...
А вы еще нас за код ставите
Ну, в общем, там весьма интересная есть оптимизация
Вот, но если внимательно вчитаться, то за огромным слоем дополнительных каких-то оптимизаций и всяких проверок
Скрыта вот эта идея, что у нас есть база, а есть верет
Так вот, у нас shared ptr хотелось бы, чтобы умел конструироваться
Да, нам хотелось бы, чтобы наш shared ptr, значит, это будет параграф 14.2 у нас
shared ptr с кастомным дилитером и аллокатором
Ну, что такое кастомный дилитер? Ну, я вроде уже рассказывал
Давайте для начала с кастомным дилитером разберемся
У нас есть контролл блок
Ну, так, давайте опять же еще упростим сначала и скажем, что у нас пока нет вот этой возниз моей шефов
Давайте считать, что у нас пока вот shared ptr создается только одним способом, просто через конструктор
Ну, то есть ему дают указатель и, возможно, еще дилитер
Будем считать, что пока нет у них у меня шерты и нет никакого аллокатора
Что тогда мы бы хранили в полях shared ptr?
Ну, один звездочка
В ptr думаем или нет?
Да, давайте думаем
Вроде ничего не меняется
Ну, меняется то, что у нас там была возня с контролл блоком, который мы хотим хранить
А, ну да, если у нас нету
Если у нас нету мейк шерд, это все проще, но нам все равно нужно хранить
Нам же нужно контролл блок еще хранить с двумя счетчиками в любом случае
И еще указатель на t отдельно
То есть у нас, я напоминаю, у нас была
У нас была, я напоминаю
У нас уже без того был бейс контролл блок, в котором хранилось shared counter v counter
И у него был наследник там, контролл блок, просто контролл блок, в котором хранилось t
Да? Правда?
У нас был другой контролл блок, который shared counter v counter
Бейс контролл блок у меня был, в общем, у нас был бейс контролл блок
Да? Правда?
У нас был другой контролл блок, который shared counter v counter
Бейс контролл блок у него был t
И контролл блок у нас селся с бейс контролл блок, и в нем еще контролл блок
Да, мне кажется, что нужно, чтобы бейс был t, потому что нам никогда не нужно dest
Фактически, а удобнее было так хранить, чтобы меньше info писать
Ну, в общем, сейчас мы переделаем все, кажется, снова
Так, стоп
У нас был бейс контролл блок, а в нем t, а контролл блок чем от ним отличался?
Еще counter
А когда тоже еще одна структура?
Правда, кстати?
Ну, в смысле, сам по себе counter
А, все, я понял, у нас бейс контролл блок хранился t
Да, да, да
Короче, по сути, бейс контролл блок у нас был t, а контролл блок от него отличался тем, что к нему еще одна счетчика добавилась
Да, да, да
Да, вот так, ну окей
Да, наверное, все-таки надо было бы сделать наоборот
Наоборот? Ну, ладно
Мы пытались в прошлый раз
Много чего пытались
Да
Ну вот, у нас добавился кастомный дилитер, что теперь делать?
Как добавился? А как вообще передали?
В конструкторе передали
Какого типа объекта?
Дилитер – это такой объект шамплит
Функциональный шамплит
Type name – дилитер
Дилитер – это штука, которая, ну, это функциональный объект, да
Может быть, там одна функция
Которая вызывается, которая имеет оператор круглой скобочки, от t звездочки
И вот ее надо вместо деструктора вызывать
Sheriff PTR, нам сказали, t звездочка PTR
И дилитер
D
Ну, дилитер тут, наверное, конечно, нужно по ссылке принимать
Сейчас, я не уверен
Наверное, что по ссылке
Ну, в общем, да
А если мы можем передать просто обычную функцию?
Указатель носичной функции
Это должна быть сама функция или указатель на нее?
Ну, указатель на нее, да, по идее, можно
Ложим по ссылке принять указатель
А в чем проблема?
Указатель по ссылке как раз можно
Указатель на ссылке нельзя
Нет, дилитер принимается по значению
Потому что, типа, подозревается, что он слабительный
Слабительный
Да, что там просто пора указатель, в худшем случае, в нем
Но если это тяжелый объект, то, ну, мугнем его
Изо всех сил
В смысле, стоп, мугнем туда
Ну, мы сейчас положим, мы еще не будем копировать, просто мы туда сохраним себе мугнуть эту штуку
Мы же не приняли его по делу
Мы же приняли по значению
Вот, что делать-то?
Как, значит, нам, что нам делать?
Туда нам что положить?
Ну, нам надо вот этот дилитер тоже в контроллер-блоке сохранить
В каком-то из контроллер-блока
То есть нам нужен бейс-бейс-контролл-блок
С виртуальным
На самом деле нам все-таки
Мне все-таки что-то вот очень нравится, что мы в прошлый раз написали
Потому что какой-то у меня вот прям
Какой-то у меня диссонанс
Потому что обычно бейс-контролл-блок содержит как раз счетчики
А ты, он либо есть, либо нет
Вроде у нас получалось и так
Мы просто хотели как можно меньше указателей хранить в основном шерптере
И так получилось меньше ифов, можно и наоборот хранить
Давайте я все-таки сделаю бейс-контролл-блок
Вот я просто почему хочу
Вот эта идея с тем, что у нас есть бейс и дирайв, то она как раз сейчас очень полезной будет
Потому что мы заодно просто делаем еще его полиморфным
А, сам контролл-блок с каунтерами
Конечно, сам контролл-блок с каунтерами и он и будет полиморфным
И там будет вся эта виртуальная штука
А вот дирайв в контролл-блоке будет...
Он будет шаблонным в зависимости от типа дилитера
А потом еще локатор туда допилим
У нас будет шаблонный контролл-блок в котором будет лежать дилитер и локатор
Вот, но это только на случай если мы создали через Мейкшерет
Ну, точнее, наоборот, если мы создали черед Мэйдшерра, то у нас как раз дилитер не будет.
У нас будет два разных контроллблока. У нас будет один базовый контроллблок, в котором будут лежать счетчики и виртуальный деструктор.
Ну, и виртуал, там, копия, что еще там надо. И будет два разных наследника от него.
В одном будет лежать аллокатор, но не будет дилитера. А в другом будет лежать и дилитер и аллокатор, но не будет Т.
Что за прикол? А Т ку надели?
А потому что, смотрите, если мы через Мэйдшеррад создаемся, то Т уже создан.
Ага, и Т его хранит?
Виноват. Сейчас, ну, я все перепутал, неправильно сказал.
Ну, короче, в одном, один будет на случай, если мы через Мэйдшеррад создаем, другой на случай, если мы через обычный конструктор создаем.
Вот. Если мы созданы через, не через, что?
Может напишем?
Ну, давайте попробуем. Ну, давайте я попробую, сейчас, наверное...
Пусть в бейс будет каунтер, это нормально.
Короче, давайте я...
На полтрайфа больше будет. Это вообще не страшно.
Значит, да, давайте у меня будет бейс-контрол-блок.
И все, что мне надо в бейс-контрол-блоке, это...
У нас запись идет, да?
Блин, я вам сливаю просто решение задачи, что-то как-то неправильно.
Если бы записи не шло, то просто остальные бы страдали.
А мы нет? В смысле, типа...
Это как в истории за посещение зачет просто в другой форме.
Ну, типа да.
Да, ну, короче...
Ну да, мне нужно, чтобы у меня был, значит, сайс...
Ну, тут будет сайс-т.
Share account, week account.
Ну и для того, чтобы все понимали, с чем они связались, будет вот такая вещь.
А почему уже здесь?
Так...
И от него как раз и будет шагунный последний.
Это тот самый бейс, который для TypeRage'а.
Я просто хотел сделать следующее. Очень бы.
Если я не из вот этих вот кастомных дилитеров, я не хочу связываться с виртуальной функцией.
Не выйдет.
В смысле, без кастомного дилитера же почему не выйдет?
А, ты хочешь сказать, что...
Ну, кстати, может быть что-то подобное...
Задачка на около 11.
Я не знаю. Но я думаю, что нет.
Я думаю, действительно, это можно так сделать.
Ну, не только кастомный дилитер, еще и кастомный аллокатор бывает.
Ну, я хочу, чтобы если я ничего кастомного не делал...
Если ни кастомного дилитера, ни кастомного аллокатора...
Я бы очень хотел бы не связываться с виртуальной функцией.
Знаешь, почему не получится?
Потому что твоему shared ptr'у могут присвоить другой shared ptr, у которого они будут.
Что за люди это делают?
Зачем они присваивают мне этот дельмо?
В том-то и дело, что...
Да, хорошо, понятно.
Что мы...
Если бы у нас дилитеры и аллокаторы были шаблонными параметрами самого shared ptr,
то не было бы вообще никаких проблем.
Но мы хотим, чтобы они были динамически подменяемыми.
И именно поэтому мы должны сделать с виртуальными функциями в любом случае.
Так вот, у нас будет наследник...
Вот давайте сделаем наследник этой штуке на случай, если мы...
Созданы не через make-shared.
Если мы созданы не через make-shared,
значит это будет структура...
Control-блок...
Не знаю, regular давайте, обычный Control-блок.
Она будет наследоваться от Base Control-блок.
А они шаблонные?
Да, конечно, наша будет шаблонная.
Adup, Angev.
Разве?
Да, с шаблонным параметром дилитеры, с шаблонным параметром аллокатор.
Да, даже если мы не через make-shared созданы,
все равно мы можем кастомный аллокатор передать.
То есть, мы могли создать объект на кастомном аллокаторе
и в конструктор shared-ptr отдать этот аллокатор,
чтобы он удалил его правильным аллокатором.
Но эти штуки, они имеют...
По умолчанию значение...
Вот аллок по умолчанию стд-аллокатор...
Ну, там...
А дилитер по умолчанию равен чему должен быть?
Дилитер по умолчанию равен...
А же был какой-то 2.2.0, оператор, что-то там...
Не то?
Значит, есть такой класс в стандартной библиотеке,
на котором мы можем кастомный аллокатор,
а, значит, есть такой класс в стандартной библиотеке,
называется std-default-delete.
Кто бы мог подумать...
Вот t, вот шамлонный,
и он просто...
Его вызов...
Ну, он...
Это эквивалент того, что делается обычно.
Мы вызываем оператора круглые скобочки у этого объекта
от t звелочка ptr.
Вот у него есть оператор круглые скобочки
от t звелочка ptr.
И что делает этот оператор?
Удаляет.
ptr стрелочка tilde t.
Да, вот это default-delete.
Заметьте, это только деструктор, это не освобождение.
Да, да, да.
А, я забыл самое главное.
Здесь же должен быть, собственно, type-name t.
Кто?
Точнее, type-name u, потому что t у нас...
Те уже заняты.
Да, type-name u.
Вот это u, это будет тот самый, который для type erasure нужен.
Вот.
И что мы в этом control-block regular будем хранить?
Сейчас, какой type мы удалить-то хотим?
Что?
При чем тут type erasure?
Зачем нам что удалять?
А, нет, стоп, стоп, стоп.
Ой, господи, чушь написал, извините.
Это delete-relocator, это type erasure.
Да, все, все, все.
Все, я какую-то ерунду написал.
Слава богу.
Страшно стало очень.
Вот, и что здесь будет храниться?
Сейчас подумаем.
Ну, то же самое.
Что такое?
Объект delete-relocator.
Здесь уходится delete-relocator.
Логично, да?
И еще что-то, связанное с T.
Угу.
Да, а знаете?
Виртуальная функция, которая удаляет его, что-то такое.
Не, все, delete-relocator хватит, объект T.
Значит, T object.
Вот сейчас, кажется, не получится.
Ну, подумаем.
Delete-er.
Не знаю, просто D.
Облокатор.
A.
D-O.
Все.
Аллок.
Не знаю, давайте D-O хотя бы.
Да, спасибо.
Так.
Хорошо.
Ну, хорошо.
Так, и что?
Ну, как мы это создавать-то будем?
Вот если нас конструируют от кастомного delete-а, кастомного локатора и дают нам T звездочку,
чем мы будем делать?
Понимаете, в чем проблема?
А мы же раньше T звездочку хранили.
Мы же вообще раньше не хранили объект T, да?
Мы в итоге пришли к тому, что мы храним T,
но мы просто делали интерпрет-каст,
потому что у нас была плей-инструктура с одним полем T.
И мы сказали, что если нам дали T звездочку,
ну давайте мы просто скажем, что это и есть.
Это на самом деле не указатель на T,
это на самом деле не указатель на T,
это указатель на наш BaseControlBlog.
Вот почему мы BaseControlBlog сделали T.
Вот.
А теперь у нас так не получится,
потому что мы не сможем сказать,
что та T звездочка, которая нам дали,
это и есть pointer на нашу штуку.
Кстати, почему?
А потому что у нас есть еще BaseControlBlog.
И мы не можем делать плюс.
Потому что нам еще куда-то надо будет присобачить
shared count, visual.
Да, да, да.
Нет, может быть как-то можно извернуться?
Ну, короче, не знаю.
Подумайте.
Я утверждаю, что вот так сработает.
Мы просто здесь будем честно хранить ту T звездочку,
которую нам дали.
Это будут два перехода.
Нет, ну мы будем в полях shared PTR хранить
T звездочку отдельно.
И если нам shared PTR спрашивают,
то мы будем хранить указатель на правильную T звездочку.
Два перехода будут когда?
Нам дали T звездочку,
но в ControlBlog мы будем хранить T звездочку.
Но shared PTR мы продублируем.
Мы будем в поле еще shared PTR хранить эту же T звездочку.
Ну, указатель на то же самое.
Ну, зачем мы вообще это делаем?
Чтобы не прыгать сначала указатель на ControlBlog,
потом указатель на...
Зачем здесь ее хранить тогда?
Ага.
А как мы будем из ControlBlog удалять объект?
Справедливо.
Передавать ему.
Мы же им пользуемся в shared PTR.
Ты должен будешь говорить delete...
Ну, там тебе нужно будет в какой-то момент говорить,
типа delete ControlBlog.
И что ты будешь делать?
Или ты хочешь сказать,
ты будешь...
У тебя будет типа виртуальная функция delete ControlBlog вот...
И ты будешь передавать...
Не, не понятно.
Как ты будешь делать?
Как ты ему...
А, ну да, один хрен...
Да, все нормально.
В любом случае, короче,
два перехода по указателю.
В общем, не знаю,
может, когда ты начнешь писать,
ты придумаешь что-нибудь более умное,
но вот пока я знаю такую реализацию.
Ладно.
И если кто-то придумает что-то более умное,
более оптимальное, или если кто-то...
А сам темы где хранили, кстати?
Все это время?
Ты этот ControlBlog на случай,
если ты уже создан.
А, у нас же еще будет сейчас ControlBlog и Regular.
Конечно, ControlBlog и Regular еще будет.
И вот в нем уже будет настоящий Те лежать.
Кайф.
Так вот.
У нас не только будет разный регулятор для MakeShared,
для LocateShared.
Нет, для MakeShared это частный случай LocateShared
просто со стандартным локатором.
Так, мне кажется сейчас важный момент,
потому что я, на самом деле, почти все сказал,
и самое время спросить, кто понял,
как реализовывать SharedPTR.
Ну, в основном, как бы, идейно.
Ты, кстати, тоже слушай,
потому что тебе тоже реализовывать просто
это будет следующей задачей у вас.
В смысле следующей?
У основы просто.
После кого?
После NordicMap.
Ну, они на одну задачу стоят,
но это у вас тоже будет.
У основы такие же задачи будут.
У основы такие же задачи,
просто у них есть первая задача,
которая нет у вас,
а у вас последняя,
которая нет у них, будет вот так.
Я подумал, что основа
должна не сильно отставать в прадвы в этом году,
потому что...
А про два быть круче, чем в прошлое,
про два раза в два и нормально.
Так каждый год...
Ну, во-первых, ни раза в два нет.
Мы с вами пройдем чуть больше,
чем в прошлом году успели,
но не сильно больше.
Да, хорошо.
Но так каждый год происходит.
Это нормально.
Конечно.
В следующем году будет лучше,
чем у вас, да.
И вообще каждое следующее поколение студентов...
Они уже будут писать
на плюсах двадцатых просто каждый день.
Конечно.
Слушайте, еще...
Еще я не знаю,
еще пять лет назад,
в первом семестре,
мы вообще не затрагивали C++11.
Мы говорили,
что равно дефолт, равно дилит,
этого нет,
потому что типа C++11,
это еще вот...
Это слишком сложно?
Ну, там...
Мы были на C++3.
Ну, да.
Ну, да.
Ну, да.
Ну, да.
Ну, да.
Ну, да.
Ну, да.
Вы же там...
Мы были на C++3.
Да.
Ну, сейчас мы уже
C++17 с вами изучаем вот в полной мере вот этот вот
E, и все прочее.
Через год, я думаю, уже
вполне C++20 фичи какие-нибудь будем изучать
на первом семестре.
Ну, короче...
Вот.
Так, так что?
Ни кто не понял,
как шеф пытается реализовать, да?
Ты понял.
Ну,
у меня будет очень много проблем,
когда я собираюсь писать.
Но идея наверняка понятна.
Вот.
Главное – идею понять, да.
Ну вот
я выпождаю, что вот с такими...
с такой иерархией классов, всё получится, ну потому что у меня есть рабочая реализация, в которой именно такие поля, короче, я знаю, что можно по-другому, но вот можно так, как минимум так получится, да, что
мы сюда допилили дилитер и аллокатор, по сравнению с тем, что проходили несколько знаний назад
да, ну и чуть-чуть по-другому организовали эту штуку, потому что тут рачку хранили Т, а теперь-то звёздочку
аллокатор мы будем называть СРПТ, а мы будем ВИКПТ, а тоже ВИКПТ
понятное дело, да, но образ простенький относится, сравнительно, он ничего не делает, сравнительно
он же не отвечает за создание объектов
а вот тут дилитер и аллок, это кто, это типы?
смотрите, что?
дилитер и аллок, это какие-то типы на функцию или на объекты?
дилитер это функциональный объект, что от него требуется, чтобы у него был оператор круглой скобочки от Т звёздочки
дилитер это тип функционального объекта
дилитер это тип функционального объекта, ДЕЛЬ это сам функциональный объект, то есть его использование будет таким
ДЕЛЬ от ПТР
в какой-то момент
вместо того, чтобы вызывать ПТР в стрелочку тильда Т, вы будете говорить ДЕЛЬ от ПТР
в дефолтом случае это будет то же самое, что ПТР с точки тильда Т, но может быть и что-то другое
ДЕЛЬ это по сути просто настройка над деструктором
что?
ДЕЛЬ настройка над деструктором или что?
это замена деструктора
так, смотри ещё раз, шеред ПТР, вообще говоря, может вместо деструктора с объектом делать что-то другое при уничтожении
пример я приводил в прошлый раз, хотя он может быть вам не очень понятен, но
топ-1
какие бывают сценарии использования РАИ?
первый пример это освобождение памяти
топ-2 пример
или даже может быть наоборот
топ-1 это
смотря что вы пишете
если у вас многопоточная программа
у вас может быть разделяемая память
и на неё нужна блокировка
это значит, что вы
у вас есть несколько
платоков, которые работают с одним и тем же
и при входе
в критическую секцию
вы должны сделать некоторую операцию
типа я захватил блокировку
грубо говоря, я пометил, что я сейчас здесь, это моё
и остальные
прежде чем туда начать заходить
они смотрят занято или нет
да, и если нет, то ждут
пока не освободиться
когда кто-то занимает, он
так вот, если вы
делаете, и у вас опять
вы какую-то функцию пишете
и у вас вместо muteX
написано muteX.log
это значит взять вот эту штуку
которая заведует блокировкой
и занять
и в конце при выходе вам надо сделать muteX.log
по сути это просто переставить вложок обратно
что свободно
но может быть
вы объект не уничтожайте никакой, просто он существует
между потоками, вы им пользуетесь по очереди
но может быть у вас исключение
или вы вышли из функции по другой причине какой-то
и вы хотите в любом случае
не забыть Unlock, сделать иначе все зависимы навечно
они никогда не смогут зайти
потому что будут вечно заняты
вы забыли освободить и вышли
вот это второй случай, когда нужно R.I.E
это пример, что может делать Deleter
кроме того, чтобы делать Deleter
он может делать, например, Unlock
он может говорить
пометь там, что свободно
перед выходом
соответственно у вас возникает
второй паттерн из поля
через год
пройдете
на многопоточность
когда будете многопоточность делать
ну вот это просто пример того, где это может быть нужно
кроме как освобождения
можно вопрос?
Make Share, я просто не помню, что он еще принимал
он делает
с оригинальным
локатором и делитером
Make Share
значит, Make Share нельзя отдать кастомный делитер
если вы делаете Make Share
то вы просите
его создать объект за вас
ну тогда делитер
Make Share это неуместно
не совместимо с кастомным делитером
хорошо, Allocate Share
тоже самое
Allocate?
он должен его сохранить
Значит, Allocate Share
это по сути вы говорите
создай объект за меня
потом сам разберись как его удалять
вопрос в том
что хранит второй наследник
да, что будет хранить второй наследник
давайте это
кажется, что между Allocate Share и Make Share
он в одном случае должен хранить локатор, в другом не обязан
почему же он хранит локатор
не надо делать
различия
Make Share это просто частный случай Allocate Share
со стандартным локатором
не надо для него отдельно заводить
давайте я напишу теперь еще один темплей
TypeNameT
почему я пишу TypeNameT
TypeNameAlloc
ну равно
sdelocatorT
структура
какая структура
структура
ControlBlock
пух
не знаю как это назвать
ControlBlock какой
ну не регуляр
ControlBlock Make Share
ну не знаю
тоже наследник Base ControlBlock
а почему у нас первый регуляр
ну типа
стандартным способом создали
стандартным способом это типа
с кастомным дилитером, с кастомным локатором
нет, стандартным это без Make Share
да, окей, ладно
и тогда может быть дилитер и локатор
что здесь нам хранить надо
ну нам по прежнему надо хранить локатор
очевидно, а еще что
а тут как раз надо будет хранить T
не T звелочку, а уже именно T
потому что T мы сами должны создать
а дилитер уже не надо будет хранить
есть еще проблема
а мы
к сожалению
нам же друг между другом
нужно уметь присваивать
чего
ну вот
у нас
хранился обычный
ControlBlock
а нам дали вот этот ControlBlock, нам нужно переприсваивать
но вроде не страшно, мы все указательно храним
какого-то удаления надо будет
потом подумаем
а
хотелось бы
ну хотя нет, можно переприсваивать
дилитер
у нас может быть ситуация
значит
у нас может быть
какая ситуация
что
мы
в этом ControlBlock
объект мертв может быть
проблема
в чем
ну у нас
не получится type erasure
в чистом бьюе
как мы его реализовывали
потому что смотрите у нас
в том type erasure
подразумевалось, что вот этот T
он
ну короче, нет
не так, когда будет уничтожаться
ControlBlock make shared
он же будет уничтожаться
он будет вызывать destructor T
но бывает так, что
объект T мертв на самом деле
когда ControlBlock еще жив
потому что может быть shared PTR умер раньше
чем wig PTR
а wig PTR же не хранит
wig PTR хранит тот же ControlBlock
как же, у нас общий с ними ControlBlock
у нас ControlBlock
в нем лежит объект
но объект может быть убит shared PTR
а еще на это все дело
продолжать смотреть wig PTR
и когда будет wig PTR умирать
сейчас wig PTR убивает base ControlBlock
wig PTR если он последним остался
должен удалить всю вот эту байду
с ControlBlock
но ты уже удален
ты уже уничтожен destructor
destructor объекта T
а wig PTR потом шикетит
да, ну то есть все это еще продолжает существовать
но объект уже мертв
храним буль что-то там
нет, ты когда будешь делать
delete вот это все
ControlBlock
объект это поле
если оно будет полем типа T
то у тебя автоматически будет вызываться destructor T
когда ты будешь уничтожать всю эту конструкцию
о госпит, я не могу этого избежать
поэтому нам придется здесь
и конечно немножечко
поступить
некрасиво
массив чара
ну
не антилизированный память
здесь нужно просто количество
ну то есть массив
из стольких байд сколько нужно
ну еще
align of T
align st
здесь нужно писать предчат
да
вот вам new
вот вам эстедуение
так, поняли зачем
так, ну короче когда будете писать
поймете
сколько людей здесь сдали лист
ясно
пока никто, потому что еще мы ни у кого не принес
но только КТ сдало
нет, вы что-то слушайте
вы слабые какие-то
в прошлом году вроде люди быстрее
лист сдавали
он просто такой
ну сейчас будете писать, поймете
а кто это вообще писать-то будет
кстати, хорошо просто
ну нет, Семен точно будет писать
это я знаю
я надеюсь, что эту задачу еще
я надеюсь еще
10
я рассчитываю, что ее зовут больше, чем сейчас
здесь людей
зачем мы храним массив чаров
мы его прикастуем к Т
еще раз
у нас возможна ситуация, что
тут
мертвый объект
но контроллок еще не удален
есть проблема
деструктор объекта
мы не можем избежать того, чтобы он вызывал деструкторы своих
я понимаю
поэтому если мы храним объект Т
мы обосрались
теперь мы храним массив чаров
и реинтерпреткастим его каждый раз
и все
хорошо, а нельзя хранить Звездочку тут
плохо
Т же где-то нужно хранить
вот тут, на куче
через Нью, через Аллок
на самом деле
на самом деле
что
тоже будет хорошо
это вместе с
это просто унифицированное
для того, чтобы унифицированно
все работало, удобно здесь тоже хранить
Звездочку ПТР, как и здесь
чтобы
это будет указатель
на эту же штуку
в полях мы храним указатель
на бейс контроллок, а еще Звездочку
чтобы быстрее обращаться
и
какая еще проблема есть
вот какая
дело в том, что
у нас же может в Шеред ПТР
лежать не Т на самом деле
а У, где У наследник Т
нет, нет, нет
и что делать
поэтому здесь все-таки нужен там
nameT, там nameU еще
и там тоже?
потому что здесь реально object может быть не типа Т
а что разница?
здесь, кстати, может и не нужен
тут точно нужен, потому что тут
реально мы можем хранить объект не типа Т
вот здесь точно нужен еще один шаблонный параметр
У, потому что это может быть
реально не Т, а что-то большее, чем Т
прям реально
большее
но указатель можно хранить
на
не уверен
надо подумать
ну вот здесь
мы можем хранить указатель на Т, а тут
может быть и на У хранить
ну если я что-то забыл сказать
то, наверное, я завтра это скажу еще
или там, когда вошли
у нас как работает?
у нас не осталось для НУ Шеред ПТР на объект
а остались в ВИК, а когда все удалится?
память освободится
только когда умрет последний ВИК ПТР
а дилитер вызовется, когда
да, когда Шеред ПТР
последний умирает, он вызывает дилитер
на вот эту штуку, и тем самым действуют
просто массив чаров
а когда умирает последний ВИК ПТР, он
делает дилокей
и там кто-то жаловался
где-то там у нас такой орфлоу, что память
не освобождается
да, это я вам рассказывал в прошлый раз
ну тут еще проблема есть в том, что вам нужен
аллокатор, это будет аллокатор на Т
а вам нужно будет из него сделать аллокатор
на вот эту все
