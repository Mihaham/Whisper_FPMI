Всем добрый день! Сегодня мы продолжаем разговор про вычисления на ограниченной памяти,
но теперь дополнительная память будет совсем маленькой, а именно логарифмической.
Сначала поговорим про деталинированные вычисления на логарифмической памяти,
и потом начнём разговор про недетерминированные вычисления, которые продолжим в следующий раз.
Возможно, в следующий раз будет точно, но ещё посмотрим.
Давайте начну демонстрацию.
Поговорим про вычисления на логарифмической памяти.
Давайте я напомню, как мы считаем память.
Подсчитывается число занятых ячеек на рабочих лентах.
Не учитываются ячейки входа, которые, соответственно, получаются неизменяемыми.
Ну и выхода, если он не просто да или нет, то есть если он является словом или числом.
Если он является битом, то тогда не важно, считать его или нет, он всё равно константа.
Вот, соответственно, вот есть класс L.
Получается L – это dspace.
Вот, сейчас, нет, здесь больше не нужно.
Здесь мы просто пишем логарифм.
Это класс языков, для которых достаточно памяти порядка Ln на детерминированной машине тюрлинга.
Ещё есть Tnl.
Tnl – это будет nspace от Ln.
Соответственно, это класс языков, для которых достаточно памяти порядка Ln,
соответственно, на недерминированной машине тюрлинга.
Ну и, значит, поговорим.
Сначала, первая половина лекции будет стоять от различных примеров.
Примеры языков из L.
Первый класс примеров будет различными задачами из просто арифметики двоичных чисел.
Задача из арифметики двоичных чисел.
Ну и первое из них – это просто сравнение чисел.
Значит, здесь у нас будет язык LE, который состоит из пар XY, таких, что x меньше либо равно y.
Ну, на самом деле, будет там меньше либо равно, да, или там больше либо равно, строго меньше.
Будут они в двоичной записи записаны или какой-нибудь другой.
И это всё, на самом деле, не очень важно.
Главное, что не унарные.
Если запись унарная, то там и так все фактически полинамиальные алгоритмы будут решаться на лог памяти.
Потому что если у вас унарное кодирование, то вы можете сначала перейти в двоичное
и дальше уже работать с тем, что получится.
И, конечно, двоичное кодирование занимает логарифмическую память от самого числа.
Поэтому там все обычные полинамиальные алгоритмы будут логарифмическими.
Что унарной записи – это не интересно.
Будем считать, что запись двоичная.
Тут, на самом деле, важный вопрос состоит в том, как именно представлены числа.
Самый простой вариант, когда достаточно константной памяти,
это если у X и Y одинаковое число значащих битов, то есть возможные ведущие нули.
При этом X и Y записаны на разных лентах.
Получается, что тогда достаточно идти слева направо,
значит, читать параллельно X и Y от старших битов к младшим,
соответственно, сравнивать прочтенные биты,
ну и искать первое несовпадение.
Как только оно найдется, можно выдать ответ, что число, в котором стоит единица, больше.
Если все совпали, то числа равны.
Это можно сделать конечным автоматом.
То есть мы идем слева направо от старших битов к младшим.
Я думаю, что должно быть так.
1b, что у них, возможно, разное число значащих битов, но тогда будем считать, что ведущих нулей нет.
Можно считать, что они есть, там еще немножко сложнее.
Соответственно, в записях нет ведущих единиц.
Но, соответственно, возможно, различная длина X и Y.
Ну тогда получается, что сначала нужно сравнить...
А, ну и они по-прежнему на разных лентах.
Нужно сначала сравнить длины.
Если у одного числа длина больше, то и оно больше.
Тоже вполне все естественно.
Ну и, в принципе, можно просто...
По-прежнему не нужна дополнительная память.
Но, соответственно, нужно сделать минимум два прохода.
Да, скорее три.
Я пишу несколько проходов.
Тут все зависит от того, что мы сначала стоим на старшем разряде или на младшем.
Потому что, чтобы сравнивать длину, не важно.
Для того, чтобы сравнивать длину, безразлично с какой стороны начинать.
Мы просто идем параллельно по битам и смотрим, какое число быстрее закончилось.
Если одинаково, то тогда уже нужно сравнивать по битам.
Если мы стоим на младших разрядах, то можно сначала пройти к старшим, сравнить длину.
Если длина одна, тогда уже начинается о старших сравнивать.
Если мы сначала на старших разрядах, то можно сначала сравнить.
Но тогда мы окажемся при равенстве в конце слова.
И тогда, соответственно, нужно возвращаться обратно.
А потом уже снова сравнивать.
В общем, я думаю, это тоже должно быть понятно.
И еще один В.
Соответственно, записи на одной ленте.
Тогда уже обязательно нужен некоторый алгорифм.
Для сравнения соответствующих битов нужно перемещаться от записи одного слова к записи другого.
При этом нельзя делать пометки до какого бита прочитано число.
Если можно было делать пометки, тогда дополнительной памяти не нужно было.
Мы тоже сделали пометку.
Возвратились, взяли там бит, тоже сделали пометку.
Пошли туда, сравнили, сдвинулись, сделали пометку и так далее.
Ходили бы туда-сюда.
Но, к сожалению, так нельзя.
Соответственно, вместо пометок нужно подсчитывать шаги.
Например, идем вдоль слова Х, подсчитываем шаги на второй линии.
Мы записываем двоичные записи, поэтому там получится длина записи и порядка алгорифма.
Длина записи будет в верхней целой части алгорифма Х.
Ну, там плюс один, может быть, в общем, неважно.
После этого дошли до конца слова, дальше идем вдоль слова Y.
Соответственно, подсчитываем.
Снова шаги.
Ну, и снова записываем.
Дальше идем вдоль слова Y, подсчитываем шаги, тоже записываем результат отдельно.
Равниваем результаты.
И это уже можно делать обычным способом, потому что на рабочей ленте с алгоритмической длиной мы можем делать пометки.
Тут уже обычным способом делаем пометки.
Так как там только алгоритмическая память.
Ну и вообще рабочая память.
Вот, соответственно, если какой-то больше, то выдаем соответствующий ответ.
Так, если равны, то начинаем сравнивать результаты.
Так, длина Y нам, в принципе, уже не нужна.
Дальше, получается, идем на начало X.
Значит, у нас запасы уже не нужны.
Ну, и дальше идем на начало X.
Значит, у нас запомнена длина X.
Идем на начало X.
Запоминаем бит на X1.
Дальше делаем шаги.
Бит на X1.
Дальше делаем длину X плюс один шаг вправо.
Сравниваем.
Ну, значит, мы таким образом дойдем до Y1 и сравниваем его с X1.
Ну, на самом деле тут, смотрите, надо все-таки это аккуратно делать.
Потому что если вдруг оказалось, что там еще ведущие нули есть,
то нужно будет и от длину сравнивать с учетом этих самых ведущих нулей.
Так что можно либо требовать, чтобы у нас автоматически,
если где-то начальная единица, мы сразу отвергаем, говорим, что не в том формате вход.
Да, это мы, конечно, сможем сделать.
Либо как-то еще отдельно говорить, как именно мы будем сравнивать.
Тогда сначала нам...
Тут как бы тогда будет две разные вещи.
Отдельная вещь – это число битов от первой единицы до конца,
а другая вещь – длина всей записи.
И тогда, соответственно, будут немножко...
В общем, одну вещь мы используем здесь, другую – здесь.
Так, хорошо.
Дальше, получается, идем теперь на длину х шагов влево.
Значит, запоминаем бит х2.
Соответственно, делаем теперь длину х плюс один шагов вправо.
Значит, и сравниваем х2, запоминанное с у2.
Ну и так далее.
То есть каждый раз делаем х шагов влево, потом х плюс один шаг вправо.
И делаем сравнение.
Соответственно, если где-то какие-то сравнения различные, то понятно будет ответ.
Если все одинаковые, то будет тоже ответ.
Вот, хорошо.
Соответственно, получается, есть некоторый общий вывод.
Есть некоторый общий вывод, что если для реализации алгоритма
достаточно иметь полиномиальное число.
Даже нет, не полиномиальное.
Константное число счетчиков,
каждый из которых варьируется в пределах от 1 до полинома от n,
то для реализации алгоритма достаточно логарифмической памяти.
Здесь нам нужен фактически один счетчик, чтобы запомнить длину х,
и один, чтобы считать эти шаги.
Его же можно использовать здесь для сравнения.
Получается, что память логарифмическая.
Я надеюсь, что это довольно понятно.
Это не очень сложная вещь, но я просто хочу подробно рассказать,
чтобы было понятно, на какие технические вещи тут нужно обращать внимание.
Несли каких-нибудь вопросов.
Если нет, то движемся дальше.
Дальше пункт два.
Пункт два – это сложение чисел.
Тут я уже не буду так подробно рассказывать.
Тут со сложением.
Это функция.
Для функции по логарифмической вычислимости можно понимать две вещи эквивалентные.
Либо у нас есть машина, у которой есть выходной поток,
и в нем печатается сумма.
Либо у нас уже дана сумма, и мы просто проверяем, что сумма именно такая.
Сложение чисел.
Тут тоже первый вариант, когда у нас на x и y слагаемые написаны на разных лентах.
Соответственно, тогда годится обычный школьный алгоритм.
Столбик.
И, опять же, дополнительной памяти вообще не нужно.
Это получается, можно сделать конечным автоматом.
Взять и сложить.
Понятно, вы все знаете, когда мы идем справа налево,
запоминаем бита переноса, то есть складываем бита x и y,
добавляем бит перенос, если он был, если получилось 0 или 1, то так и оставляем бит переноса 0,
если 2 или 3, то 0 или 1 пишем, и еще один бит переноса, и так все вычисляется.
Обычный алгоритм.
Соответственно, 2b, 2b это слагаемые записаны на одной ленте.
Тогда получается аналогично, но нужен счетчик, обозначающий текущую позицию.
Точно так же, как здесь.
Хорошо, я думаю, это понятно, складывать столбик все умеют.
Теперь поговорим про умножение.
Три умножения чисел.
Здесь уже прямо школьный алгоритм не совсем подходит.
Школьный алгоритм в чистом виде не вполне подходит,
поскольку обычно подразумевает квадратную таблицу,
соответствующими результатами умножений и потом сложения.
Но на самом деле, если у нас x будет равно x1, и так далее, и xn.
А давайте наоборот.
Давайте так, от n до 0, xn, xn-1, и так далее x0.
То есть мы нумеруем, начиная с мальших видов, начиная с 0.
Соответственно, у равняется yn, и так далее y0.
Ну, тогда получается, что x умноженный на y будет равен z,
которое будет равно, значит, будет бит в два раза больше z2n, и так далее z0.
И биты в принципе считаются так.
Значит z0, но это равно x0 на y0.
Это понятно.
Значит z1 будет равно x0y1 плюс x1y0.
З2 будет равно x0y2 плюс x1y1 плюс x2y0.
Ну и еще, возможно, плюс перенос предыдущего этапа.
Потому что здесь с 0 на 1 никак не могло быть переноса,
потому что тут либо 0, либо 1, а вот здесь, в принципе, могло быть 2.
Могло быть 2, 1 плюс 1.
Тогда тут мы пишем 0, а единицу отправляем на перенос предыдущего этапа.
И так, в принципе, и дальше будет.
Понятное дело.
Зкт будет равно x0yk, значит, плюс x1y-1, плюс и так далее.
Плюс в конце там xкт y0.
Ну и еще опять же плюс перенос.
Но главное, что надо понимать про перенос,
значит, чем перенос для умножения отличается от переноса для сложения.
Для сложения этот перенос был всегда либо 0, либо 1.
А здесь, поскольку мы складываем много слагаемых,
при этом система у нас по-прежнему двоичная,
то этот перенос может быть длинным.
То есть тут даже если x1 и x2, даже если x и y хранятся на разных лентах,
и нам не нужна логографическая память для того, чтобы запоминать,
куда мы там смотрим на x и куда на y,
то все равно нам нужна логографическая память для хранения переноса.
То есть тут получается и так далее.
И для хранения переноса может быть нужна логографическая память.
Получается, что мы делаем.
Понятное дело, что если у нас с двух лент на одну нужно,
то нам нужны счетчики, чтобы запоминать, куда идти в одном условии и в другом условии.
Пусть у нас даже x и y на разных лентах.
Тогда что мы делаем?
Один указатель выводим вот сюда, другой сюда,
и потом один по взрослению, другой по убыванию.
Если у нас и там, и там единицы, то мы увеличиваем этот счетчик на единицу.
Потом еще добавляем перенос с предыдущего шага.
Получается какое-то число логографическое.
Последний бит мы записываем в ответ ZKT,
а все кроме последнего бита, то есть целую часть от половины,
мы отправляем как перенос на следующий шаг.
Ну ладно, я думаю, это тоже должно быть довольно понятно.
В результате, кроме этого текущего переноса и, возможно, указателей для одной ленты,
нам ничего не нужно хранить, получается логографическая память.
Так, хорошо.
Теперь проверим четвертую часть.
Четвертая часть, проверим проверка правильности скобочной последовательности.
Значит, проверка правильности скобочной последовательности.
Я думаю, что вы все помните, что это такое.
У нас имеется баланс.
Одно из определений такое,
что в каждом префиксе открывающих скобок не меньше, чем закрывающих,
а во всей последовательности поровну.
Вот тогда мы можем просто завести счетчик для подсчета баланса.
Соответственно, при открывающей скобке увеличивать его на 1, значит при закрывающей уменьшать.
Если оказалось, что он равен 0 и должен быть уменьшен, то, соответственно, отвергнуть вход.
Если слово закончилось, то проверить, что он равен 0.
Если равен, то принять, если не правен, то отвергнуть.
Понятно, что никакой момент баланс не может быть больше, чем длина.
Поскольку баланс всегда не больше длины, то, соответственно, получаем, что достаточно логарифма битов.
Так, хорошо. Надеюсь, это тоже более-менее понятно.
Другой вариант. Я оставлю номер 4, 4 штрих.
Это проверка правильности последовательности из нескольких типов скобок.
Тут недостаточно проверять баланс по каждому типу скобок.
Например, может быть, вот такая вот скобка, потом скобка круглая закрывается и скобка квадратная закрывается.
Тут, соответственно, все балансы верны.
Последовательность неправильная.
Ну, соответственно, тут получается критерий, который нужно проверять.
Такой критерий, что условие на баланс соблюдается внутри каждой пары
соответствующих скобок.
Да, здесь, например, круглая закрывается, круглая закрывается, вот между ними баланс не соблюден.
Ну и тогда алгоритм будет такой, что мы стартуем от открывающей скобки,
заводим счетчик символов и счетчик баланса по скобкам данного типа.
И, соответственно, доходим до момента, когда счетчик баланса обнулился.
Вот, соответственно, если слово кончилось раньше, то отвергаем.
Ну и дальше, соответственно, анализируем участок между этими двумя скобками.
С точки зрения баланса. Ну и тут вроде бы даже можно не разделять, а просто подсчитать баланс.
Достаточно подсчитать баланс по всем типам скобок.
В смысле не различать их?
Ну, мне кажется, да, должно быть достаточно.
Ну, в принципе, надо подумать, это будет верный критерий или нет, но, по-моему, верный.
Если даже вдруг не верный, то можно и по каждой отдельности.
Но, по-моему, даже если внутри по всем типам все будет нормально, но при этом это не разбирается,
то по предположению индукции там для какой-то другой пары скобок внутри них будет не все верно.
Так что вроде бы это должно быть правильно.
Вот такая дополнительная оптимизация. Можно, конечно, перебирать разные.
Да, в принципе, тут еще можно поговорить о входе записан.
Потому что если у нас константное число видов скобок, то, конечно, можно просто как слово написать.
Но если еще и число скобок может быть растущие, зависящие от длины,
то тогда нужно описывать типа скобка открывающая, и у нее там индекс какой-нибудь.
Индекс в мире какого она типа.
Но неважно. Эти индексы как раз тоже логографической длины,
так что можно их там сравнивать друг с другом как угодно и так далее. Записывать, приписывать и так далее.
Ну, соответственно, как мы анализируем, можно считать, что мы идем обратно справа налево.
Каждый раз баланс туда-сюда изменяем.
И, соответственно, вот этот счетчик символов наоборот уменьшаем на единицу на каждом ходе.
Соответственно, когда этот счетчик символов обнулился при проходе обратно, то счетчик баланс новый тоже должен обнулиться.
Так, ну ладно.
Так, ну ладно. Я думаю, что онлайн-лекции перерыв не обязательно делать.
У меня еще есть одна историка, которую хочу рассказать.
Про логографическую память детерминирована, дальше про нл уже начнем разговор.
Она немножко более сложная, чем все предыдущие.
Пятое это проверка того, является ли граф деревом.
Тут, конечно, могут быть какие-то разговоры про то, как именно граф кодируется.
Да, ну по граммеру он неориентированный, является неориентированный граф деревом.
Он может кодироваться как список ребер, как матрица смежности.
Так или иначе, мы считаем, что у нас есть процедура, как от вершины перейти к соседней.
Может быть, к соседней с таким-то номером и так далее.
Вот, проверка того, является ли неориентированный граф деревом.
Смотрите, какое определение. Дерево.
Дерево – это связный граф без циклов.
Вот, но можем ли мы проверять связность?
Значит, можем ли мы проверять связность и отсутствие циклов по отдельности?
На самом деле можем, но это довольно сложная теорема.
Такая теорема Рейнгольда 2005 года.
Основная вещь, которую мы изучаем в этом курсе, относится к 70-м годам, к 80-м.
А это уже существенно более свежий результат.
Хотя для вас, может быть, уже не такой свежий.
Теорема Рейнгольда 2005 года использует технику экспандеров.
И там довольно много технических разных подробностей.
На моем спецкурсе про псевдослучайности и дарандомизации пару недель назад мы как раз доказали эту теорему.
Но тоже без всех технических подробностей.
И до этого мы три занятия необходимой вещи из теории экспандеров изучали.
Такой серьезный результат, на пальцах не объяснить.
И то, и другое вместе можно проверить относительно, по крайней мере, элементарные методы.
Тут я вам покажу пример.
Вот здесь будет один граф с циклом.
Такой цикл.
И у него какие-то есть ответвления.
Вот так.
Это граф с циклом.
Еще есть дерево.
Какое-то такое дерево.
Ну, неважно. Я не очень большое рисую.
Вот этот цикл, то, что я написал, у нас унициклический граф.
И один граф дерева.
Теперь мы возьмем и начнем эти графы обходить.
И обходить по правилам левой руки.
То есть каждый раз будем поворачивать налево.
Я пока неформально говорю, что левой руки на картинке видно.
Это в общем виде не очень понятно.
Давайте я тут какую-нибудь стрелочку поставлю.
В начале направление обхода.
Вот так мы начинаем обходить.
Обходим так потихоньку.
Обходим.
Вот так вот обходим потихоньку.
Так он в конце.
Давайте аккуратно сделаем.
Так вот обходим.
Все, обошли.
А тут тоже обходим.
Тоже каждый раз поворачиваем налево.
Вот, ну уже видно.
Можете представить, чем закончится.
Можно увидеть одно кардинальное отличие.
Слева то, что у нас справа.
Справа мы каждое ребро прошли два раза.
Один раз в одну сторону.
Вот так вот.
Один раз в другую сторону.
Слева некоторые ребра, ребра которые в цикле, мы прошли только один раз.
Отсюда что получается?
Отсюда получается, что справа у нас число шагов в два раза больше, чем число ребер.
Потому что мы каждое ребро прошли один раз в одну сторону, два раза в другую сторону.
Слева у нас число шагов меньше, чем удвоенное число ребер.
Ну вот это как раз ключевая идея.
Есть вообще эквалентное определение дерева.
Эквалентное определение дерева, что это граф, связанный граф на N-вершинах, у которого N-1 ребро.
И как раз подсчитать число ребер, нужно завести счётчик и с ним работать.
Но связанность остаётся.
Вместо связанности будем проверять, что обход определённого вида
делает 2n-2 шага, прежде чем вернуться на исходное ребро.
Вернуться, то есть пройти вторично.
Эти картинки существенно опираются на планарность.
В примерах обход проводился по правилу левой руки, но без планарности непонятно, откуда его взять.
Поэтому вместо этого мы будем считать так.
Значит, заменим такое правило, что если после ребра Ij идём по ребру jk
где k – это вершина с минимальным номером, которая больше i, в которой есть ребро.
При этом тут имеется в виду порядок по циклу.
То есть k минимальное в ряду i плюс 1, i плюс 2 и так далее, n потом 1, 1 и так далее.
В честь самой i тоже может быть, если там никаких других вершин нет.
В частности, если j – висячая вершина, то после ij будет jj.
То есть мы пройдём туда и обратно. То же самое, что мы и здесь, и здесь много раз видели.
Проблема с этим определением такая, что оно не всегда даст такой обход, как мы хотим.
Особенно если нет планарности.
Давайте я покажу пример. Тут уже пример будет с номерами.
Тут будет так.
1, 2, 3, 4, 5 и 6.
Вот в этом графике есть вершин, и будет сейчас 5 ребер.
Но дерева он не будет за счёт того, что есть изолированная вершина.
5 и 6 изолированной вершины.
Тут будет вот такой вот ромбик.
Теперь смотрите, что будет получаться.
Например, мы начали с единицы и пошли в двойку.
Дальше из двойки. Мы в двойку пришли из единицы.
Дальше будем идти в тройку.
Тройка минимальная, которая соединена.
Дальше пришли в тройку из двойки, идём в четвёрку.
Четвёрку пришли из тройки, но должны уйти в двойку.
Дальше в двойку пришли из четвёрки, следующий по циклу единицы.
Уходим в единицу.
Теперь пришли из двойки, уходим в тройку.
Теперь в тройку пришли из единицы, следующая двойка.
Пришли из тройки, следующая четвёрка, уходим сюда.
Пришли из двойки, следующая тройка, уходим сюда.
Наконец, пришли из четвёрки, следующий по циклу единицы.
Соответственно из тройки уходим вот сюда.
После этого продолжается цикл.
Видно, что здесь мы вдоль каждого ребра прошли два раза.
Одни раз в одну, другой раз в другую сторону.
Хорошо.
В чём тут отличие?
Дело в том, что в любом случае в таком обходе
каждое ребро не может встретиться больше двух раз до зацикливания.
То есть оно может встретиться один раз в одну сторону,
другой раз в другую сторону.
Меньше не может.
Вот, поэтому...
Ещё третья вещь.
В примере слева граф не является деревом.
Однако обход делает два и минус два шага,
прежде чем зациклиться.
Вот.
Но есть ещё особенность, которая...
Тут есть эта изолированная вершина.
Однако в нём есть изолированная вершина.
Соответственно, итоговый критерий такой.
Граф является деревом, если...
Так, первое.
Первое, в нём n вершин и n-1 ребро.
Второе.
Обход по указанному правилу...
Обход по указанному правилу возвращается на исходное ребро
после 2n минус двух шагов.
И третье.
В нём нет изолированных вершин.
Соответственно, все эти условия проверяются на логарифмической памяти.
Так, почему?
Ну понятно.
Рёбра, так или иначе, должно быть, возможно легко посчитать.
Соответственно, обход тоже понятно как делать.
Во-первых, мы запоминаем исходное ребро.
Вот 1-2, например.
Мы запоминаем исходное ребро.
До этого нам нужно два логарифма.
Потом каждый раз мы помним предыдущую вершину, текущую вершину.
И, соответственно, ещё перебираем все остальные, начиная со следующей.
Ну, со следующей после вот этой.
В общем, в таком порядке перебираем остальные и проверяем, какое из них есть ребро.
Ну, там типа ещё нужно три логарифма.
То есть мы помним i, помним g, и ещё нужно для перебора, соответственно, вот этих вот.
Как только мы видим ребро, сразу переключаем.
И так вот, там какая-то константа на логарифм нужна.
Ну, изолированные вершины тоже легко проверить.
Изолированные вершины тоже легко проверить.
Просто перебираем все вершины.
Это нужен логарифм.
Перебираем все возможные соседи.
Ещё логарифм.
И, соответственно, если все проверили, а ребра нет, значит она изолированная.
И тогда нужно отвернуть.
Ну, и что нужно ещё сказать?
Нужно ещё сказать, почему критерия выполняется.
И, соответственно, если граф не является деревом, но имеет n-1 ребро.
Значит, но имеет n-1 ребро.
То он не связан.
Если граф не является деревом, но имеет n-1 ребро, то он не связан.
Вот.
Значит, если при этом в нём нет изолированных вершин,
то в каждой связанной компоненте строго меньше n-1 ребра.
Ну, а обход до зацикливания проходит по каждому ребру не более двух раз.
Как в связанной компоненте может быть строго меньше n-1 ребра?
Ну, если вообще во всём графе n-1, а в компоненте...
Ну, как бы вот здесь связанная компонентя столько же ребр, сколько во всём графе.
Из-за изолированных вершин.
Если в компоненте меньше n-1 ребра, то это несвязанная компонента.
Нет, n-1 – это от всего графа.
N – это число числов во всём графе, а связанный компонент – это отдельный кусок.
Вот.
Обход до зацикливания проходит по каждому ребру не более двух раз.
Соответственно, общее число шагов будет меньше, чем 2n-2.
То есть получается, что если первое и третье выполнено, то тогда второе не выполнено.
То есть если граф не дерево и выполнено условие 1 и 3, то не выполнено условие 2.
То есть все сразу выполнены быть не могут.
Вот.
Ну и дальше нужно ещё доказать, что если граф является деревом, то все три условия выполняются.
Ну да, кстати, тут ещё нужно сказать, что n больше одного.
Если n больше одного, если n равно единице, то это всё тривиально.
Если граф реализируется, то все три условия выполняются.
Так, ну соответственно, первое мы знаем из дискретного анализа, третье тоже очевидно.
Первое и третье.
Ну, давайте я пишу так.
Первое известно, третье очевидно.
Вот.
А второе нужно доказать.
Да, значит, условие 2.
2 доказывается по индукции.
Ну, можно примерно сделать так.
Можно, например, начать с висячей вершины.
Начнём с висячей вершины.
Это тоже хорошо известный факт, что в любом дереве есть висячая вершина.
Ну а дальше из другого конца, из соединённой с ней вершины, может выходить некоторое количество поддерев.
Да, значит, тут есть какое-то, так, нет.
Значит, тут есть какое-то, так сказать, дерево.
Первое, да, значит, какое-то.
Дерево второе.
И какое-то дерево третье, например.
Ну и в принципе, конечно, более может быть больше.
Вот, а смотрите, да, как бы вот, например, они нумируются.
Да, тут есть какой-то циклический порядок.
Давайте я таким цветом обозначу циклический порядок.
Ну, в смысле, это порядок номеров вот этих вот вершин, которые вот с этой связаны.
Значит, вот эта вот висячая.
Значит, дальше там вот эта вот, вот эта вот, вот эта вот, так далее.
Так, но дальше смотрите, получается, что вот к этой вершине смежной, да, значит,
к смежной с ней, с ней свисячей, к смежной с ней присоединено несколько деревьев.
Значит, в каждом из них.
Ну, соответственно, да, значит, в которых, значит, в которых эта смежная является висячей.
Значит, в каждом из них, по предположению индукции, по предположению индукции,
обход пройдет по каждому ребру дважды, прежде чем вернется в исходную.
Ну, а соответственно, вернувшись, вернувшись, да, значит, по нашему правилу, перейдет в следующее дерево.
И, соответственно, только обойдя все деревья, путь вернется в самую первую вершину.
Ну вот, то есть мы идем сюда, следующий панель, наверное, вот это, поэтому он идет сюда и начинает обход вот этого дерева,
возвращается сюда, потом, по правилу, приходит вот в эту вершину, соответственно, дальше обходит вот это вот под дерево,
возвращается сюда, идет сюда, обходит вот это вот под дерево, возвращается, только потом идет обратно сюда.
Ну вот, с какого ребра начинать, это, в принципе, не важно, но, в принципе, можно на логарифмической памяти и висячей вершины тоже искать.
Вот. Ну что, понятны конструкции, есть какие-нибудь вопросы?
Да, отлично. Так, ну ладно, значит, у меня остается 5 минут, так что я только кратко анонсирую, что будет в следующий раз.
Значит, по всей видимости, в следующий раз будет очным, но еще сейчас дождемся официального объявления именно от Fistech.
Вот. Значит, NL. NL означает недetermинированная логарифмическая память.
Да, то есть получается, что есть разные возможные варианты следующего хода.
И если какой-то путь будет в принимающую вершину, то у нас лежит наш вход в языке.
Значит, если нет ни одного, то, соответственно, машина в целом отвергает вход.
Так, значит, ну и там есть классическая задача. Это путь уже в ориентированном графе.
Значит, путь в ориентированном графе. Ну и идея такая, что вот у нас есть... почему это лежит в NL?
Потому что, смотрите, если есть вообще какой-то путь, то есть путь, с которым длина не больше, чем число вершины в графе.
А тогда мы можем запустить цикл следующего вида. Значит, у нас есть текущая вершина и предыдущая.
Или даже есть просто текущая вершина. Текущая вершина, мы перебираем все возможные варианты следующей вершины.
Ну, можно даже сказать так. Мы перебираем вообще все вершины.
То есть из текущей мы перебираем все вершины. Если в вершину, которую мы сейчас рассматриваем, есть ребро из текущей,
что значит перебираем? Недетерминированно. То есть берем недетерминированную какую-то еще вершину.
Если в какую-то еще вершину есть ребро из текущей, то мы, соответственно, по этому ребру переходим, и у нас новое рассмотренное будет текущей.
Если у нас вершины нету вообще, то мы, например, сразу говорим нет.
Тогда если какой-то путь есть, то будет вариант, что мы каждый раз берем вершину доли этого пути и в итоге приходим, куда нам нужно.
Вот это базовая задача из NL. Дальше у нас будет две больших теоремы.
Мне бы хотелось очень успеть их обе в следующий раз пройти. Может быть, какие-то вещи я буду пропускать, оставлять на семинара.
Одна теорема о том, что NL равняется ко NL. То есть доказывать отсутствие пути можно тоже. На логографической памяти недетерминированно.
Вторая теорема, что эта задача о пути будет полной в этом классе NL.
Это почти очевидно, если вспомнить все наши разговоры про конфигурационный граф.
Потому что в конфигурационном графе как раз и был разговор о том, есть путь от начальной вершины до принимающей или нет такого пути.
Вот такой анонс. Тогда получается до следующего раза. Если больше нет вопросов, то спасибо за внимание.
