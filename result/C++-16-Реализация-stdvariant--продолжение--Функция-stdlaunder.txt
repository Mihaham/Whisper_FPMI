Вот, собственно, класс-вариант, в нем мы поняли, что храним variateq.union, еще индекс,
который говорит о том, как азельтратика сейчас активная, и мы написали, ну, там,
с оговорочками разных тонкостей, написали функции GET, консультёр на тихом поняли,
что легко и неинтересно, не будем писать, вот, и мы начали разговаривать о том, как
реализовать конструкторы. А, да, мы тут написали метафункцию getNetsByType, и, возможно, нам понадобится
getType, боимится еще, сейчас подумаем. Вот, и мы начали разговаривать о том, как писать конструкторы.
Вот, написание конструкторов варианта — это самая веселая, пожалуй, штука есть. Возможно, только ради
этого стоило об этом поговорить. Ну, вообще, можно было бы честно в variate, ну, то есть,
сделать ему конструктор от шаблонного типа T и произвольного, то есть, от U, template type U,
конструктора 22%, и просто перебирать в этом union, ну, то есть, делать вот этот вот шаблонный цикл,
так скажем, пока мы не дойдем, пока мы не увидим, что тип head совпадает с типом, который у нас сейчас,
и сконструировать, когда дойдем до нужного. Но это, во-первых, поработало за линейное время в runtime,
а во-вторых, это бы не позволяло выбрать лучшую версию, как при перегрузке это происходит, если у нас там
int double и string, а нам дали float, то мы должны сконструировать double. Вот, поэтому вот предлагать
следующее решение. До этого догадаться самому, я не знаю, кто до этого догадался, кажется, Андрей
Александрович, по-моему, писал какую-то статью там о том, как, в общем, какие-то ребята очень такие мощные
из комитета, там, очень такие старички, изобрели вот такой способ, значит, мы наследуемся от переменного
количества предков, который называется вариант alternative, приватный на следовательстве, вот как это выглядит,
вариант alternative с типом te и еще все остальные варианты. Ну, вы вроде все поняли, да, что это, повторяю, все понимают,
все понимают, что написано здесь. Тут многоточие, и после этого еще. Единственный вопрос, мы когда, мы как бы проходили
отдельно приватное и публичное наследование, отдельно множественное наследование, правила ставятся где, вы понимаете?
От всех, если я хочу просто от двух челеков наследоваться приватно, что я должен сделать?
Это отличный вопрос, честно говоря, я не знаю, как они сделали parser этого, то есть наследование от переменного количества шаблонных
аргументов там появилось в C++, даже не в 11, по-моему разрешили, по-моему, наследование от переменного количества типов
появилось позже, чем просто переменного количества шаблонных аргументов, но я не уверен, типа parser дублируется
Вы слышали слово «правила» перед каждым вариантом вернутьев, я не знаю, но в данном случае это неважно, потому что у нас
все равно класс, а у класса все вот наследование по волчанию приватное.
О, да!
Нет, ну я думаю, что дублик, да, то есть мы написали правильное.
У нас наследуемся от структуры, но наследуется класс.
Да-да-да, наслед... ну...
Кто наследует, тот определяет.
Да, это же он, ну как сын...
Не знает ничего про тебя.
Нет-нет-нет, сын, что такое приватное наследование? Что сын не показывает нам, от кого он наследовался.
А сам он знает об этом?
Конечно, сам он знает.
Ну, приватное наследование — это сын запрещает внешним человеку видеть, от кого он наследовался.
Ну, поэтому private — оно относится к классу, то есть вот это вот private — это область ответственности самого варианта.
Каким образом был правильный наслед? Я не понял.
Приватно запрещает нам вообще обращаться к базовому классу.
В смысле обращаться... private запрещает внешнему человеку использовать этот факт, что ты наследник.
Окей, а внутри типа...
Конечно, нет, иначе какой смысл наследования вообще?
Private — это еще раз напоминаю, что это private наследование.
Это такое наследование, что никто, кроме вас самих, не может использовать этот факт, что вы наследник того.
Ладно.
Но вы, конечно, можете, потому что иначе в чем смысл?
Это как приватные поля. У вас есть приватные поля и приватный предок.
Но предок — это же ваша часть, по сути.
Это же как бы то, что в вас внутри есть.
Так вот, вариант Артернацев говорит, что он...
Вообще-то у него есть дирайв, потому что вариант Артернацев знает, что он на фене всегда.
И он умеет конструироваться вот этого t, от которого он создался.
И что он делает? Он просто говорит такой хоп, я туда положу вот это value.
С шамлонным параметром t.
Вот.
А как я его положу? Ну тут нужна функция put.
Пишите, напишем функцию put тоже.
Да, ну собственно, а что? У нас дальше в варианте написано using, вот это вот все, вариант Артернацев многоточит.
Вот все, вариант Артернацев многоточит.
Здесь есть такой же вопрос.
Можно ли вообще писать using, что нас запитает, что бы?
Нельзя, но можно писать...
Так.
Сейчас, у меня тут вот что-то не то.
Опа, опа, опа.
Извините, пожалуйста.
Позадрешал, да, понимаю, понимаю.
Так, давайте...
Позадрешали, да.
Да.
Матам или олимпиадной неравенства.
А, значит...
А, это вы типа пишете учебник, да?
Сколько я знаю?
Не совсем, но не важно.
Ну пока не написали ни одной новой строчки по, да?
Да, я хочу открыть...
Я говорю, уже ты из вас.
И ничего страшного.
Да, да.
Ладно, в варианте.
Ну, у тебя, да, у нас нет.
Все, вы продолжите сидеть, я уйду.
Давайте я...
Я сейчас попробую variable.
Variable arguments.
Ой, Господи.
На что он так же октябрь обговорил всю пару.
О, Господи.
Параметр back.
Значит...
Ну давайте посмотрим.
Вот здесь должно быть написано
про шаблонные using в том числе.
Вот контексты, в которых
можно использовать распаковку
пакета.
Вот, там, base, edify.
Вот.
Во-первых, можно делать...
То, что мы искали, оно внизу.
Не на столько, не на столько.
There is a declaration.
Вот это стимулятор 17 появился.
А, SDBR...
Мы, кстати, обсужали, почему
SDBR, кстати, раньше...
Да, кстати.
Возможно, поэтому.
Нет, почему? Они могли добавить что-то в язык.
Раньше это был какой-нибудь
compile-reinfinity, а теперь
это стал часть языка, и они спокойно добавляют сюда
к биотеку. Да, в общем,
использование переменного количества
шаблонных аргументов
в появлении юзинга
появилось и в 17.
Вообще, этот юзинг-конструктор появился только с 11,
а с переменным количеством
появился с 17.
Вот, а base-specifiers
появилось уже по 11.
Прикол.
Ну ладно.
Почему вначале добавляют фичи, а потом думают,
где их менять?
Нет, почему? Вполне возможно, что они добавляют фичи
как раз... Вот, например, рэп играет,
они добавили как раз потому, что здесь это надо.
Ну, они могли продумать,
но...
Нет, скорее они добавили...
Нет, они именно понимают,
что неплохо было бы иметь такую конструкцию,
для чего они добавляют, я думаю. Короче,
ну все, в принципе, все работает.
Осталось только путь написать.
Конструкторы работают.
Как путь написать?
В смысле, конструктор работает, а мы ничего уже не забывали.
Все, что нужно,
у нас уже написано.
А можно варианты?
Все, что есть варианты,
конструктора T,
ну и вот это.
Значит,
давайте путь напишем.
Что надо здесь написать?
Войт?
Там был T, да,
type name T.
А что?
Войт, наверное, тут.
Что?
5%?
Value?
Еще там 4 варианта?
Ну, это понятно.
Что здесь?
Положи, чему 4 варианта?
Да, мне нужно...
Нужно знать,
куда конструктор.
Просто можно там...
Да, так что надо сделать?
В каком контексте она используется?
Только в конструкторе?
Ну пока, да, но пока только для этого пишем.
Удалять пока ничего не надо?
Потом удалять мы будем,
но это потом.
Да, сейчас мы еще дистрибку напишем.
Если конструктор, а что?
А неважно, какая разница?
Как это неважно?
Theta hat?
Нет, нам надо...
Нам надо...
Вот, кстати,
нам надо как-то еще...
Вот здесь я не совсем правильно сказал,
у нас еще индекс нужно положить правильный.
Нам же нужно индекс запомнить.
Зачем?
Потому что у него индекс...
Вариант должен записан быть...
Какой индекс сейчас активный?
Да, но где это индекс?
Он сейчас запишет, нет?
Кто запишет? Я сказал...
А, в пут мы запишем.
А куда запишем мы это?
В пут внутри Юния имеет.
В пут внутри Юния?
О, Господи!
Да.
Ну, значит, надо бы в конструкторе добавить строчку.
Да.
Это все правильно, кстати?
Типа, наши нижние.
Да, да, да, это все...
Ну, сам Variant Union, он в...
Вообще, вовне варианта.
Мы сделали.
Мы сделали.
То есть, я могу чисто Variant Union?
А-а-а...
Возможно, правильнее было бы сделать структуру,
которая содержит в себе
Union, вот этот, и индекс.
И в этом...
Эта пут определять уже в этой структуре.
И тут...
Индекс, соответственно,
расставить.
Мне вообще так кажется.
Вот, ну то есть нам в любом случае надо индекс поставить,
но для этого надо, чтобы Variant Alternative знал какой-нибудь индекс еще.
Вот, а как нам это сделать?
Ну,
нам на самом деле вот как можно это сделать.
Вот здесь Variant Alternative
я просто напишу
и я не буду поле ему заводить,
я ему скажу static course
sizeT
И индекс, он же...
Ну, этот индекс, он же...
Определен заранее.
Определен заранее в compile-time
мне не нужно в объекте Variant Alternative его хранить.
Просто для каждого экземпляра,
для каждого инстанцированного Variant Alternative
индекс будет известен.
А что это будет такое?
Ну, это и будет getIndexByType
тот самый.
Какой?
Вот t-Types
2.2.vl
getIndexByType.vl
Ну да, вот уже есть getIndexByType.vl
То есть, на самом деле
нам даже здесь не надо
ничего мудрить, а просто
я вот здесь запишу
Ааа...
Мы еще, кстати, не решили в предыдущий раз
проблему, потому что у нас сверху объявлен Variant
но у Variant есть Storage
и поэтому мы будем при этом провести.
Давайте я скажу this.ptr
это вот это вот static course derived
this
и
this.ptr
сначала я скажу storage
положим туда эту штуку
а дальше
я скажу
this.ptr
да, this.ptr
а дальше я скажу
this.ptr
индекс
равно
индекс
вот
я могу
ну давайте скажу index большой буквы
чтобы было красиво
вот
да
и вот
но это
константа же
статичная константа
ка вначале
ну да
ка значит констант
с индексом
ка и на кей
да
константа
кей
а вот
на самом деле
это все-таки не очень не нравится, потому что
мы же
я уже не понимаю
я еще не понимаю
у нас же типа
а у нас там все types
ну короче
их все не нравится
мы же конструировали Ιд mı
а потом должны быть
когда мы конструировали quiz
он принципизирует
эти поля
что назвать
что значит
что значит
короче
то есть на самом деле
Выполняем. Скорее всего, он сначала принесет все по умолчанию,
поэтому пойдет в тело конструктора. Да, наверное так, потому что иначе было бы
странно, иначе как мы из...
Чего я буду... Он же всегда у нас тоже собирается, скорее тогда, а потом уже потом приходит.
Так мы из твоего конструктора, конструктор нас.
Да, короче, что-то я вот задумался, не знаю, возможно это...
Секундочку. Возможно, он будет в другом порядке делать, и тогда такая реализация не очень хорошая.
И проблема не в индексе.
Мы делаем у человека, который еще не создан.
Это да, не очень хорошо.
Ну, эту проблему потом решим. Что?
Решили проблему, что у нас вариант отремонта не знает сториджа.
В смысле, не знает сториджа?
В смысле, объявляешь вариант сверху, потом пишешь везде вместо функции про это.
А, ну может даже скомпилируется.
Давайте попробуем это скомпилировать. Не хотел я, правда, их начинать делать.
А оно вроде скомпилируется. Я каждый раз скомпилировал.
Кстати, не так уж много и ошибок. 161, что у меня 161.
Кто нерв где-то?
Кость.
Что?
Это закоэминичный мейн, понятное дело.
У меня скобочный баланс засоблюден, видимо, где-то.
Закрываешь столки в мейне.
Есть.
Вот она.
Так, это грустно.
Так, может CLM?
Нет, получше скажешь.
А то скобочный баланс засоблюден.
Ааа...
Трэшка чхэшка?
Да, во-первых, я забыл многоточие здесь.
Вот здесь.
Так, что дальше?
Declaration of tapes, types, shadows, template, parameters.
Отличное отмечание.
А, я...
Все это оттуда же идет.
Сейчас, declaration of tapes.
Почему так?
Это не здесь.
А, в 78-й строке.
А, вот оно что.
Ну да, здесь нужно другое.
Да, вот так.
Да, вот здесь.
Конфликт имен.
51 expected expression.
Это где у меня expected expression?
А, понятно.
Давайте все-таки допишем.
Так, если что...
Не, ну в принципе, можно было бы просто сказать,
что я беру адрес.
Тут можно даже, наверное, visitconstexport
просто сказать, что...
Ну, это же union. Какая разница?
Я просто...
Что мы в head вообще хотели?
Ну, если T это head,
то на месте heads конструировать head.
А иначе пойти и сделать put
в тот union, который второй.
Давайте подумаем,
могу ли я написать просто вот
сейчас без всякого их констатиста
просто сказать new от
от вот этого
T от value.
Ну, конечно, так бы не сказать,
потому что 3D-предкаст придется делать какой-то.
А...
Наверное, это даже будет работать.
Почему?
Ну, в смысле, если я
интерпреткастом сейчас здесь забывал.
Почему работает не тот тип?
И что?
Так, я просто беру адрес, я интерпреткащу
его, указать именно то, что мне надо, и все.
Корейцы, у них адреса, так все равно же.
Ага, у всех одинаковые адреса.
А может такой вопрос? Да.
У нас, у нас, вроде, в union есть конструктор по умолчанию?
У кого?
Нет, у него нет.
А почему он не создается?
Кто по умолчанию создается?
Он не создается.
Он пока...
Ну, он не создастся, нет.
Ну, если тип уникальвиальный, он не создастся.
И его нужно написать будет.
И слова default там тоже нету, да?
Ну, в данном случае default
ничего не сможет сделать, скорее всего,
потому что он не поймет, что именно надо сконструировать.
Кажется, у нас default уникал.
Вот.
В общем.
Просто именно в этом ошибке, когда я пытаюсь
сказать. Так, давайте
я все-таки, не нравится мне так делать,
давайте я все-таки честно напишу.
If constexpr std is same where
от t,
запятая head,
я создам new
по адресу head
t в value
а иначе
я сделаю put
с шаблонным параметром t
от
ну, иначе
я в tail просто сделаю put
с шаблонным параметром t, там же самое value.
Вот так, по крайней мере,
не будет убе формально, когда я буду обращаться
к полям unit. Ну, то есть, я
хотя бы правильно члены проинциализировал,
то есть, я new вызвал по, ну, по адресу
нужной штуки, а не по адресу
не той штуки.
То есть, я как бы,
по крайней мере, формально правильно
нужно писать tail.templateput
Да, это правда.
Сейчас бы мне Силенка об этом сказал.
Да.
Чего?
А мы put вызываем
с конкретным типом всегда.
Вот именно здесь мы решаем эту проблему.
Выберется версия
перегрузки, наиболее подходящая,
а это tail уже будет конкретно в одним из тех
tail, иначе мы
в варианте turnative tail всегда в одной из тех
types.
Так, ну давайте попробуем теперь это
скомпилировать.
А...
Хорошо.
Ну, давай.
А концепт по умолчанию у него есть, я надеюсь?
Кажется, тоже нет.
Интересно.
Missing template keyword так,
строчка 100,
вот здесь template
нужна,
давайте
дальше.
Не скомпилируйтесь, потому что...
У меня когда
где?
Где-где?
О,
index-1 надо, конечно.
Да-да-да.
Мы не за что здесь не скомпилируем, потому что там
нужен конструктор и деструктор в варианте q, не рано.
Сейчас, подождите, тут я хочу пока понять,
что компилятору не нравится.
NoNumberNamed вариант alternative,
InMight вариант alternative.
А...
В чем проблема?
Привет.
Я смог это стимулировать.
Ой, молодец.
Так, давайте поймем, что
не так.
Alternative.
А, я просто опечатался, господи.
Да, вот это неприятно.
Alternative.
Я тоже собирался себе
стимулировать быстрее.
Может, правильнее?
Мне кажется, это будет регулярно.
Мне кажется, это нам сразу поцелует.
Ну, да,
я
согласен. Наверное, я это сделаю
в следующем ученом году.
Нет, ладно,
наверное, я поставлю. Да, я поставлю.
В следующем ученом году уже нельзя быть.
Ну, может быть, валить
и раскладывать все эти старошилки,
как всегда.
И раскладываю.
И я еще
новое придумаю в программу,
и надо просто старошилки раскладывать снова.
Это...
Почему?
Потому что
because BasePlus
default-конструктор.
Нам нужен почему-то default-конструктор
variant-alternative. Когда мы его напишем,
будет проблема, что нет
default-конструктора у ValidQNN.
Когда мы это исправим, напишем, что нет
default-деструктора у ValidQNN.
Только когда мы его тоже допишем, даже пускай
пустым, вот тогда он скопилируется.
Давайте допишем.
Мы тут ничего не делаем.
Тут мы тоже ничего не делаем.
Variadic
Junion
Мы ничего не делаем.
И здесь мы ничего не делаем.
Почему он не может им default-ом написать?
Потому что нет понятия default-а.
Потому что он не понимает, что такое
default, это значит, что он должен
проницилизировать, какой тип из имеющихся.
Так,
а теперь у нас нету get
int.
Ну отлично, можно сказать
my get, вместо std-get.
Что теперь?
Index as a private member
это стражка 101.
Мы в фраге добавили, кажется.
Да, у меня get не друг.
Давайте сделаем.
Да, я сделал
get от
Это на все натуры не совпадает.
Так,
нужно авто
43
43
Я ничего не возвращаю.
Точнее, я возвращаю ссылку на бой.
Во всяком случае, я возвращаю ссылку на бой.
Когда у нас, мы же переписали
get для пустого, и так надо что-то выкинуть.
Вагон байд, вагон байд get.
Да, император.
Возвращайте буль.
В самом деле, буль.
Блин, я не знаю.
Поверьте.
Так,
что будет это делать?
А, не типа просто возвращать, я не знаю,
какой-нибудь empty struct.
Здесь гранвение, шумы,
что-то зацепили.
Не было такого.
Когда такого не было,
и вот опять.
Ну, короче, здесь я просто
верну empty struct.
А, черт,
это будет...
Ну, что, что?
Это будет
бита ссылка.
Да,
это будет вообще бита ссылка.
Давайте куда-то не бежим.
Какой-то такой...
Извините, я заделывал дырю как могу.
Так же, мы, когда с моим годом
в последствии создавели там
такой же прикол, чистый из комментариев.
I'm so sorry.
Интересные ошибки.
Классно.
Так, а почему
не верну инфы?
Так, на самом деле я хочу...
Возможно, я вводка поступлю сейчас,
я не буду все это исправлять на ходу,
я просто открою вам вариант, который у меня
написан был заранее, который кипелируется.
Там все то же самое, примерно.
Просто заранее исправим наши ошибки на компиляции.
Давайте я так поступил,
иначе мы будем еще 20 минут исправлять CE,
мне это не нравится.
Короче, мы разобрались с тем,
как конструкторы работают.
Кажется. Кажется понятно, да,
что конструкторы делают.
Давайте напишем деструкторы,
на этом, в принципе, разговор про вариант пока закончим.
Что должен делать деструктор?
Ну, сейчас мы напишем деструктор,
но я не буду исправить ошибки компиляции,
я просто открою заранее написанный код,
который кипелируется.
Там то же самое все.
Нам надо в варианте...
Вот что должен делать деструктор в варианте?
Давайте деструктор в варианте.
Отчищать активный...
Как мы это сделаем? У вас есть индекс?
Ухраните его все.
Сохраним тайп-лист, так сказать.
Ну, то есть, что я должен сейчас делать?
Что написать в деструкторе?
У вас есть в варианте...
У вас есть метод обращения, да?
Ну, кажется, да, есть.
Нам на пост деструкта вызовут в варианте, кажется.
А, кстати, мы должны писать этот
using в варианте деструктов
в паблике или неважно?
Ну...
Уличные конструкторы должны быть...
Если напишешь в приватном,
если напишешь в приватном,
то они просто останутся приватными.
У меня прям работают.
Чего? У тебя не MSWC-компилятор, случайно?
Что?
У меня TANK++ и EG++
я упробовал, у меня компилировался.
Сейчас, ты хочешь сказать, что ты using
конструктор написал в private-секции варианта
и это из Main вызывается?
Да.
Это какая-то ерунда.
Ты его вызвал?
Да, я вызвал.
Возможно, он просто сгенерируется
Возможно, он просто сгенерирует
дефолтный конструктор
и как-то придумал,
как сконструировать родителей
самому умолчанию.
У всех типов дефолтный конструктор,
он такой типо, а, нормально.
Возможно, он всех родителей сконструировал
по умолчанию и...
Возможно, у тебя поэтому нужен конструктор
по умолчанию для варианта альтернатив?
Так тут тоже надо было, он тоже показался.
Так вот, деструкты варианта.
Чего он должен делать?
Удалить активный тип.
И всё.
Ну, это не всё, что нельзя сделать.
Обратиться в юниор
вызовет деструктур явно.
Деструктур чего? Юниор?
Какого типа?
Ты умеешь обращаться
к сторожу? Ты же умеешь кучать гет?
Нет.
Гет только с шаблонным параметром
ты умеешь вызывать или с шаблонным параметром
индекс? А у тебя не шаблонный параметр,
а роттайм примерно.
Индекс.
Ну, нам нужна какая-нибудь функция
дестроид и пилот.
Нам нужна что-то виртуальная, потому что мы никогда
не... Нет, нет, нет.
Функция дестрои...
Функция дестрои...
Вот этот вариант мне больше нравится.
Нам нужно просто в юниор добавить ещё функцию
дестрои.
Вот.
Но сейчас.
А что дестрои-то?
Что? По индексу?
Да.
Дестрои?
Я почти придумал.
Короче, дестрои от
индекса. Просто индекса.
Так.
Нет, от.
А от числа?
Да. Если ноль,
то удалим х.
В чём проблема?
А дальше будем
параметрально проходить?
Вы считаете?
Нет. Мы не миллионеры.
Если про это.
Я всё-таки хочу, чтобы это было шаблонной
штукой.
А как?
Пусть это будет так-найм-индекс.
Или так-найм-тэ, на самом деле.
Так-найм-тэ, ладно.
Так-найм-тэ. Ну, то же самое,
просто дестрои без параметров
и в конст-экспорт.
А теперь, наверное, у нас сейчас понадобится функция, чтобы
если STD
isSame
в
опять т, запятая head.
Ну, может, сейчас и для
индекса сделаем.
То мы говорим head.
вызвать
destructor head.
Ну, а иначе делаем
дестрои
с шаблонным параметром
t от
tail.
tail.
tail.template-destroy
tail.template-destroy
tail.template-destroy
tail.template-destroy-t
tail.template-destroy-t
tail.template-destroy-t
На самом деле, мне
не очень нравится такая реализация.
Сейчас я её ещё упрощу.
Вот что
на самом деле.
По сути, сейчас я могу сказать
с каким шаблонным параметром
вызвать дестрои.
Понятно.
Да, пока что.
Это в варантайме представляется они.
Да.
Тейфлист пишемся.
Тейфлист вектор пишется.
Лёгкий
виртуальный акул.
Я виртуальный акул.
А я виртуальный класс.
Смотрите, я
просто сделаю деструктор вариант
альтернатив.
Ну или я сделаю даже не деструктор
альтернатив, в самом варианты
альтернативе сделаю функцию destory.
Я сейчас
буду так смотреть, правда ли
индекс мой, я опять сейчас
статик кастом сделаю
к наспитникам, правда ли мой
индекс там, который записан,
это тот индекс, который мой сейчас.
И если да, то я просто вызову
с шаблонным параметром, как надо, без всякой фаз здесь уже.
То есть это будет за линию происходить?
Это, конечно, будет за линию происходить, потому что это надо делать, ну, потому что это врантаймерный упсус.
То есть всегда улизывается destroy всех предков?
Да, просто он будет тривиальным во всех случаях, кроме одного.
Да, но в каком-то смысле он будет не тривиальным, но это врантаймерная операция.
А у тебя вариантов нет?
Да.
У тебя вариантов нет? У меня вариантов, сколько угодно.
Если у тебя мало идея, прошу исправнение, как говорится.
Так, можно мы вернемся в destroy?
Можно мы вернемся в destroy?
Сейчас, destroy я просто уничтожаю голову.
А, не просто уничтожаю голову, я уничтожаю голову при условии, что она какая надо.
А else не пишу.
А, просто else нет.
Да, вот так давайте.
Jostam загонит голову.
Почему?
А здесь я напишу так, я скажу...
Секунды, я присоединяюсь, они без пояснения резко вернутся и вернутся обратно.
Почему можно так сделать?
Потому что я хочу написать, он мне не дает.
Сейчас, я вариант alternative делаю функцию destroy.
Которая делает следующее.
Если...
Ну, во-первых, опять весь PTR она делает.
Это static cast derived.
Звездочки.
Почему destroy?
Почему не destructor?
Потому что мы можем destroy не только...
Дестрой нужен чаще, когда мы направляем в свое место.
Да.
Хорошо, ладно, мы destructor вызывали destructor.
Если Vist PTR...
Уже не cost export.
Vist PTR.
Стрелочка index равно равно наш index,
то просто я вызываю destroy,
ну, Vist PTR.
Стрелочка storage.
Точка destroy.
Точка tempo destroy.
Ты хорош.
Шаблоны поравентом T.
И все.
То есть, этот destroy, он просто во всех случаях тривиально сработает.
Ну, как тривиально?
Он сделает, конечно, один проход по указателю,
но в остальном он ни к чему не приведет,
потому что destroy вызовется в реальность только один раз
и уничтожит правильную голову.
А как вызовет destroy все?
Да.
Вот.
А вот тут...
А можно еще вернемся туда, потому что я ничего...
Хорошо, давай вернемся.
Почти все понятно.
Почти все понятно.
Ну вот, просто я вот так написал.
Это тот destroy, а новый destroy где?
А новый destroy вот где?
Я просто destroy понял, все хорошо.
Новый destroy просто проверяет, как называется, storage точку,
потому что storage это есть именно еще.
Так, теперь, как вызвать здесь, в деструкторе,
destroy для всех наследников сразу?
А, ну, кажется, уже понятно, что что-то надо сделать.
Нам нужно вызвать как бы функцию destroy в вариант alternative.
Ну, как бы, да?
Так.
Ну, мы пишем вариант alternative, type, запятаем type три точки,
ну, двоеточь-двоеточеча, destroy, и потом в конце еще три точки.
Что-то такое.
Ну, как с юдингом.
А есть ли, я думаю, что пакетный вызов функции?
Конечно, ну, за Китай это просто...
Есть?
Нет.
Так прям нет.
Но есть.
И вот сейчас как раз мы изучим еще одну.
Killer feature.
Killer feature 17?
Да.
Значит, сейчас мы впервые...
Cyclepotipum.
Cyclepotipum.
Fold expression сейчас будет.
Если кто знает.
Cool.
Сейчас мы впервые...
Там в первом смеси, когда я рассказывал про пакеты типов,
кто-то заикался, что вот есть еще fold expression.
Внутри скобочек что-то.
Да.
Возможно, это был ты, кстати.
Нет, это был такой человек.
Ладно, хорошо.
Сейчас мы впервые в нашем курсе используем новую синтаксическую
конструкцию, которая называется fold expression.
А...
Вот мы сейчас отлучировали сюда.
Смотрите.
Да-да-да.
В C++17 появилась такая синтаксическая конструкция.
Это новая синтаксическая конструкция.
Мы такого раньше еще не делали никогда.
Она позволяет вам применить, вычислить одно и то же выражение
параметризованное пакетом типов.
Ну, например, у вас есть вот шаблонный парак, вот
у вас есть, допустим, шаблонные аргументы.
Давайте что-нибудь простое.
Вот, например, так.
Вот у меня есть шаблонные аргументы, которые допускают
оператор двойной имперсант над собой.
Я тогда могу написать такую функцию.
Вот у меня переменное количество шаблонных аргументов
принято, а я возвращаю вот такое выражение.
Многоточие двойной имперсант и этот пакет.
И это в compile time развернется в двойной имперсант по всей
элементам пакета.
О, типа я видел там, кстати, есть булевые функции,
вот это N, записок принимаются, ну, за себя.
То есть это вообще что-то сделано, да?
Возможно.
Возможно есть, да.
Вероятно.
Вероятно.
Ну, я не очень понял, про какие ты говоришь.
Секундочку, почему, но написано как функция,
оно же примерно константное.
Ну, функция константная.
Сейчас.
О, нет, все отлично, я понял, хорошо.
Пожалуйста.
Так, посмотрите, пожалуйста, на эту синтаксическую
конструкцию.
Вот тут формальное определение, как это работает.
Значит, у вас есть выражение, которое должно быть пакетом.
Ну, оно может содержать, оно может быть не тремяльным
выражением, то есть не просто имя, не тремярное,
но в нем должен фигурировать имя пакета.
Бинарная операция, многоточие, скобка закрылась.
Все это обязательно должно быть в скобках, что важно.
И без скобок это не будет компилироваться.
Это должно быть в скобках, потому что синтаксис иначе
просто компилятами может распарсить.
Ну, не повезло.
Всегда это должно быть именно в скобках.
Важный вопрос.
Да.
Уже было секунды назад.
Да.
Зачем мы в Destroy проверяем, что head и test совпадают?
Мы же всегда вызываем, только если head и test совпадают.
Нет.
В Destroy...
Чтобы мы это проверили на этапе рых, раньше еще.
Ты про Destroy в Union.
В Destroy в Union.
Так у тебя в Union всегда head фиксированный,
а тебе нужно будет делать любой.
Union и head первый.
И что?
А тебе нужно делать любой.
И что?
Я же не ударил остальные.
В смысле?
Тебе нужно ударить нужные.
Ты хочешь сказать, ты готов вызвать destructor head,
хотя там не head лежало?
Нет, нет, нет.
В смысле?
Я его просто не буду вызывать.
Я же Destroy вызываю в одном из случаев.
Ты говоришь про то, что это все равно...
Мы два разных знаем, одно и то же.
Ну, поскольку это их констэкспорт,
то это ничего не портит,
а если вдруг я вызову Destroy из какого-то другого контекста,
то ничего не будет.
Если я вызову Destroy с неправильным типом,
то ничего не произойдет.
Ну, там их констэкспорты.
Зачем я вызвал Destroy?
Если вы вызвали Destroy,
значит вы уже точно ошиблись в смысле.
И лучше вам скажут, что...
Лучше сделать какую-то штуку, которая скажет,
что вы ошиблись,
чем штука, которая такая...
И ничего не сделает.
Ну, возможно.
Эй, короче, это личная проверка.
Она Compile Time,
Compile Planet Exp, не жалко.
Возможно...
В одном контексте вызвать Destroy,
это бы нам пригодилось.
Так, давайте придемся к Fold Expression.
Fold Expression.
Посмотрите на определение.
Все понятно.
Есть
вот такие два варианта.
Fold Expression,
когда я хочу сделать
не просто
бинарным оператором связать
все элементы пакета,
а еще с каким-то аргументом
с левой или с правой.
Например, вот здесь.
Например, я хочу вот это добавить,
просуммировать весь пакет
и еще в конце добавить к этому вот это.
Секунду можно нагниться.
Там сказано, вот так неправильно,
а вот так правильно. Я не увидел отличия.
Тут говорится про то, что
сколько нужно вот это выражение записывать,
которое я тут в конце написал.
Вот.
Ну, давайте вот еще
парочку примеров.
Например, можно вот так
вывести все элементы пакета.
Как раз такая
конструкция
позволяет вывести все в СИАУ,
потому что она разворачивается в СТД СИАУ
влево-влево. Первый аргумент пакета,
все это в скобочках влево-влево,
второй аргумент пакета и так далее.
Через пробел это может быть?
Через пробел вывести?
Ну, СТД СИАУ
сейчас, давайте подумаем.
Можно?
Ну, если я сделаю СТС СИАУ
Давайте, типа,
как сюда пишем пробел,
штуку обернем в скобки,
а она скобки раньше распасет,
да?
Да, через пробел,
не знаю, как.
Ну, можно заказать
такой потоп и потом, типа,
слушай,
не, примерно,
типа, создать копирующий потоп, который
каждый раз можно полностью вывести куда-то,
он сам-то не сдаляется.
Ну да, понятно, что можно там создать какой-то
какой-то обер, куда лезть, наверное,
через обер.
Почему ты так пишешь?
Потому что у меня нет идеи.
Ну, я не знаю, можно или нет,
но я не могу сказать.
Данилу Максимов не умеет решать задачи, сдача не решается.
Ну, давай, у тебя есть идеи?
Да, обращаемся к тебе.
Мы можем просто взять
аргумент в скобочки? Все сломается или нет?
Мы можем, почему нет?
Хорошо, ну можно после аргумента
в скобочках в этих написать
влево-влево пробеги?
Да!
Первым распорзаться оно,
получится, что у тебя карта будет влево-влево
при объеме операторов пробела.
А почему я не могу взять
вот это в скобочки
написать?
Сейчас.
Если все возьму в скобочки,
то ничего не будет.
Проблема в том, что он в любом случае
пишет все аргументы подряд,
и только операторы между ними.
Я могу оставить пустоту
слева твоей точки сейчас?
Пустоту слева, то есть написать
бизнес-дресси-аут?
Ну, тогда он попробует.
В смысле, пустой экспрешен?
Точка за пятой?
Ну, нет, просто пустой, вообще пустой,
ничего не делается.
Ну, ладно.
Короче, я так понял,
просто убрать...
Многоточие, влево-влево, аркс
и все это в скобочки.
Без эс-дресси-аут, короче.
Многоточие, влево-влево, аркс
и все это в скобочки.
Вот в плане эс-дресси-аут
обратите к галочке.
Все, что слева, три точки.
Скобка открывается,
многоточие,
влево-влево, аркс,
Так, выбирать все, что находится с левой отрицательной, до левой из полки.
И куда оно выведется?
Ну, сейчас никуда, но, типа, если так можно, то...
Ну, это будет работать как... Ну, я же спросил, понятно?
Это будет работать вот так. Оно свяжет просто все аргументы вот этим оператором.
И, типа, идея в том, что я хочу распаксить одно выражение в кучу вот таких же сигналов.
А, он не поймет?
Он свяжет этим оператором все твои аргументы, что за день.
Какой аргумент?
Что можно?
Я не понял ничего.
Какая операция может быть над Void?
Просто мы же не хотим, чтобы все срочно это возвращало.
Так, короче, мы очень долго сидим на этом. Ну, в общем, понятно синтез этой конструкции.
Синтез плюс 17.
Вот, кстати, обратите внимание, что в зависимости от того, с какой стороны вы напишете многоточие, зависит ассоциативность.
Она... Ну, он либо право ассоциативный, либо лево ассоциативный сделает какую-то штуку.
То есть, как... Чем нижние два отличаются?
Ну, он... Ну, как бы ты можешь его вот так... Ну, вот написано, чем они отличаются.
Все.
Так вот, теперь я вспоминаю, что у меня есть оператор запятая.
Точно, да.
И говорю следующий вариант альтернатив.
От types, запятая types, многоточие.
B.B.destroy.
Запятая, многоточие.
И все это в скобочках.
И все это в скобочках.
И все это в скобочках.
А что это у нас там...
Это, знаете, по всем наследникам пробежавшись, вызвал дестрои.
Не доказавай, ну как, но что если, например, у нас... Как вы понимаете, какой пакет мы разбиваем?
Ну...
Читчички, может быть, их больше одного же, вроде?
Ну нет, если у тебя... Ну, как? В первую очередь, вот этот пакет, понятно?
Нет, ну это понятно, а я именно самому фокусируюсь.
Если их больше одного, то C и E будут, я думаю.
Вот, на самом деле я вам сейчас веселую историю расскажу.
Вот и если это скомпилировать, ну сейчас я попробую это скомпилировать.
Ладно, давайте я уже не буду пробовать.
Это компилировать, я...
У меня это компилируйте.
Я в принципе написал все, что хотел.
Сейчас я просто открою.
Так, все.
Про реализацию контурка, пакетов, вариантов, я рассказал все, что хотел.
Если кто-то что-то хочет спросить сейчас, то самое время.
Потому что мы еще будем дальше к следующему вопросу.
— Да. Почему, почему нет возможности, не добавили возможности, instead of «запитой» здесь написается точка «запитой»?
— Потому что «запитая» — это оператор, а точка «зап monastery» — не оператор.
— Ну и формально, если бы мы распарсили как множество… типа...
— Почему не поменяли син元тикцизм языка? — Почему maminax?
Зачем вообще требование, чтобы запитая была оператором?
Зачем вообще требование, чтобы промежуточная штука была оператором?
— Потому что иначе тебе пришлось бы поменять син 20111 на уровне совсем глобальном,
что у тебя бывают не только expression и declarations, а еще и expression в скобочках.
Клуб.
Ну потому что то, что заканчивается точкой за битой, это инструкция.
Она может быть чем-то...
Она может быть в скобочках, хорошо.
Да, у тебя может быть...
Мол, она работает, я придумал это увидеть.
Что? Ты придумал с пробелами это сделать?
Какая херня.
Это забавно, это что-то прикол.
По-моему, страшно ты это придумал.
Ну типа...
Это прикол.
Интересный код.
Что там?
Да, я знаю.
А что-то доп-функция или какая-то?
Нет, сейчас я напишу.
Ой.
Интересно.
Да блин.
Bim.
Как себя?
Витар.
STDC out.
Робел.
ARX.
Все это в скобочках.
А, забитае.
Нет, забитае, то есть три точки без этого.
А, забитае.
А, точно, через забитуе все, да.
Это жесть.
Я считаю, это вообще жесть.
Ух, ну понятно.
Ух.
Аппарата забитае, да.
И даже может присвоиться очень куда-то впихнуть, не просто чак какой-нибудь.
Ооо.
Не, ну это конечно очень мощно.
Да, круто, круто.
Это прям очень мощно.
Нет, у тебя первым пробел выведется.
Может, у меня есть старый.
Тогда последним пробел выведется.
Ну, можно вводить стрим-стрим.
Пусть за один пробел вводить все.
Я победил.
Так, все.
Теперь я...
А, или вначале ARX, а потом ARX.
Я это закрою.
Открою вот другой файл.
Конечно.
Ааа.
Ладно, давайте я перейду в обратную папку.
Которую я выводил раньше.
Я выводил на мой MyVariant2.
Себе отзывал.
Так, ну, короче, на самом деле тут у меня...
Съемка идет?
Что, съемка идет?
Но тут не...
Если ты к тому, что вы просто это все скобипастите и напишите, то...
Так он уже...
Так.
Вы думаете здесь...
Здесь написан просто вариант, который я написал, но он далеко не полный.
В смысле, здесь написано не сильно больше, чем я написал до этого.
А нам надо больше?
Конечно.
Углай.
Ну, вот...
Хочу щипсить.
Это будет смешно.
Отрати ровно.
Что за ломбер?
Вот.
Вот, значит...
Вот здесь ты лондер нужен.
Вот.
Сейчас мы...
Пуча.
Сейчас мы про это и поговорим.
Но сначала я из него стру.
Так, значит...
Так, сейчас...
Вот.
Ну, давайте еще раз посмотрим, что мы добились.
У меня есть getIndexByType, getTypeByIndex.
Не помню, зачем оно было надо, но вот оно написано.
Значит, вариант Alternative.
То же самое, что и у нас было Derived.
Index.
Конструктор по умолчанию.
Вариант Alternative.
Тут у меня был где-то важный вывод какой-то.
Конструктор Outtie.
Конструктор Outtie 2.0.
Destroy.
Почему-то Destroy...
Ничего не делает.
Ничего не делает, да.
Что же Destroy?
Не дописано Destroy.
Ну, то компилируется.
Не дописано Destroy.
Ну, то компилируется, да.
Ну, variatic union.
В общем...
А сколько Busqy будет работать в дальнейшем?
В общем, все, по сути, ничего нового.
Вот этот вариант Alternative с Destroy.
Все, все.
Ну, короче, вот.
Все, что мы написали, по сути, здесь.
Просто оно написано так, что компилируется.
Давайте это скомпилируем.
Проверим, что компилируется.
C++ experience.
Да.
My...
Значит...
My варианту 2.
Не спрашивайте, почему 2.
Первый провалился, понимаю.
Вот.
Нет, просто первый был как раз тот, в котором все реализовано.
А вам не надо до него показывать.
Значит...
Так.
Смотрите, это компилируется.
Потому что G++ на самом деле не смог распарсить эту конструкцию.
А Clang сможет?
А Clang сможет.
Знаешь, как пилируют Clang?
Сейчас, секунду.
А локально нам Clang установлен?
Нет, в контесте G++, но G++ 11 уже может.
То есть...
А изначально G++ какой был?
10.
Все, слава богу.
Вот, начиная с 11, G++ умеет распарсить.
А 10 не умел.
И здесь...
Сейчас.
О, господи.
Так, где-то...
Возможно, я закрыл это.
Ну, в общем...
Так, нет.
Ну ладно, не буду искать.
В общем, там был баг в G++ 10, про который был в багзилле G++.
Баг репорт.
В общем, там написано, что G++ умеет парсить такие конструкции.
И вот, начиная с 11 версии, умеет.
Это к тому, если вы будете компилировать G++ в версии ниже 11,
то у вас может это не работать.
Но это не ваша ошибка.
Это ошибка, как компилятор.
То есть, мы впервые столкнулись с реальной ошибкой компилятора.
Да не впервые.
Мы, по-моему, раньше сталкивались.
Какой?
В этом году?
Ну, нет.
В прошлом году точно сталкивались.
Ладно.
Может, в этом вы и не застали еще.
Так, окей.
Переходим к следующему пункту нашей замечательной программы.
У нас осталось 12 минут, но мы успеем, я думаю.
А пункт называется эстаделлонда.
Я даже напишу...
Что там?
Аптейд?
Да.
Вот, короче, не знаю.
Я торжественно сделаю заголовок.
Каптер 47.
Вот здесь вот написано.
Эстаделлонда.
Вон был стягивать доску.
Да не.
Я вот здесь вот напишу, и мне места хватит.
Короче, смотрите.
Вот такая пункция.
Пока это спойлер, сейчас я попробую вот это скомпилировать и запустить.
Вот смотрите, у меня есть вариант от int-double-std-string, который создает пятерки.
Молодец.
И вывожу, что, ну, это должен получиться int, понятное дело, и смотрю, что в нём лежит по int.
И хочу быть уверен, что там пятёрка действительно лежит.
Ну, на самом деле, я мог и не выводить, я просто напишу assert, но вот сейчас мы выведем, что там лежит.
Значит, я компилирую, я плюс плюс одиннадцатым, запускаю, и там лежит пять, как ни странно.
И даже assert не упал.
И даже assert не упал, да.
Ну, давайте я попробую скомпилировать это силендом.
No.
И там лежит пять, как ни странно.
А давайте я попробую.
Мы очень лозь.
Опа.
Что он сделал?
Мы должны в руки играть все оптимизации по ручкам, и посмотреть, где там сломалась какая оптимизация.
Значит, у кого есть идеи, что здесь пошло не так.
Здесь нет никого обма, то есть всё то, что мы реализовали, тут написано.
Давайте проследим внимательно, как работает конструктор.
Что такое конструктор V от 5?
У нас в варианте есть у наследованные конструкторы.
Вариант alternative.
Больше нет конструкторов.
Смотрим конструктор варианта alternative.
Вариант alternative умеет конструироваться от...
Ну, вот здесь есть те ауты, которые, в общем-то, я не просто так написал,
потому что, собственно, мы по ним поедем.
Ну, вот здесь есть те ауты, которые, в общем-то, я не просто так написал,
потому что, собственно, мы по ним и можем дебажить, что происходит.
Они все сэндл в конце.
Сейчас мы с ними запустим.
Вот, смотрите, значит, мы...
Что произошло?
Так, минуточку.
Бойзик стринг. Так обычно.
Да.
Обычная строка.
Да, смотрите, что здесь происходит.
Он выводит нам порядок, в котором он посещает конструкторы.
Сначала он оказывается в варианте alternative в конструкторе,
и typeid это int.
Ну, я вывожу, какой тип у него.
И value 5. То есть он сначала проницилизировал
поле 100 с пятеркой.
И только затем он зашел в дефолтный конструктор для дабла,
и только затем он зашел в дефолтный конструктор для строки.
А можно дефолтный конструктор?
Кстати, заметьте, пятерка появилась.
Вместо... ну, я не убрал ладуа, но все стало работать из-за сиаутов.
Ну, потому что сиауты, они зачастую...
Из-за сиаутов исчезают оптимизации некоторые.
То есть он сказал...
Оттого, что я закомпетирую сиауты, он станет работать по-другому.
Не удивляйтесь. Что, что, что?
Мы с твоей механикой, мы не можем вас не держать,
потому что мы мы не жарим.
Все так.
Что он нас с этим делает?
Ну, собственно, ошибка там, где нужно Slender будет поставить.
Вау!
Ты знаешь наперед, да.
Нет, он видел, как мы стирали Slender.
Нет, он неделю назад подходил и спрашивал.
Так, ну, смотрите, на самом деле все-таки происходит неприятность.
А именно сначала...
Почему мы входим в дефолтный конструктор?
Так мне же надо наследников проницилизировать.
Наследников, а родителей?
Родителей.
Да, можно посмотреть, какой у нас дефолтный конструктор у родителей, пожалуйста.
Пустой.
Вот и конструктор у родителей ничего не делает.
У него уже полей нет.
Нет, нет, нет.
Он всегда вызывает всегда.
Ну, всегда.
Да, хорошо.
Ну, то есть вызывается конструктор вот этого вот...
А мы получаем этот наш вопрос.
Ну, в смысле, нет, еще не сконструирован storage в момент, когда мы заходим в конструктор,
потому что он вызывается.
Ну да.
Он не сконструирован, ну и ладно.
Нет.
В смысле, мы вызываем его, мы к нему обращаемся, к несинферимому объекту.
Вообще УБ должен быть.
И УБ происходит.
Все логично.
Нет.
Что?
Где мы к storage обращаемся?
В конструкторе...
Смотри, у нас есть наследник.
Чтобы смулировать наследник, мы сначала конструируем родителя,
а родители берут поля наследника и инициализируют их.
Что-то с ними делают.
Да.
Ну, типа все, УБ сворачивает.
На самом деле вроде это нормально, потому что мы не поли...
А мне важно, чем сейчас конструктор вообще?
Потому что функция put, она что-то делает адекватное.
У нас в storage сейчас не лежит ни один объект в сырой памяти.
Ага.
И мы вот в этот момент просто к сырой памяти storage...
Время жизни storage еще не начало.
Мы к обращаемся к сырой памяти storage и кладем туда int.
Да.
А потом все это отрабатывает.
А потом только инициализируются поля, видимо, варианта.
Видимо в том, что конструктор ничего не делает по умолчанию,
поэтому ничего не меняется.
Конструктор по умолчанию storage...
Чего?
Конструктор storage ничего не делает.
Конструктор storage ничего не делает.
Память не обнуляется, ничего не происходит.
Так вот, компилятор просто видит, что в конце вызван дефолтный конструктор,
и такой раз дефолтный конструктор вызван, значит, там можно обнулить.
Значит, можно до этого ничего не делать с этой памятью,
что бы там ни происходило.
Ну...
Ну...
Сомнительно.
Это О2, все нормально.
Ну...
Я не понимаю, почему это не УБМ.
Так это УБМ, конечно.
Почему оно так себя ведет?
Конечно, это УБМ.
Это УБМ, правильно.
Главное понять настоящую причину, почему это УБМ.
Вот.
Так, а что у меня в storage написано?
Да, в ряде гивнем.
Собственно, здесь у меня куд.
Ммм...
Вот то, что создано, здесь мы вызовем...
Это уже...
Это не проблема, с одной памятью.
Да, с одной памятью, это не проблема.
Но то, что мы обращаемся к объекту до начала времени его жизни,
и у него потом вызовется конструктор еще.
Да...
Сейчас меня начало это смущать, потому что...
Потому что...
Если это действительно так работает, то...
Ваше понимание сломалось.
Мое понимание, да, сломалось.
Потому что я-то думал, что он все-таки называется Pochette после того, как мы...
Что он инцелизирует storage...
Короче, надо посмотреть в Assembler на подвидении.
Я думал, что он инцелизирует...
Вот, короче, что вот этот мерок называется после того...
Можно просто проверить, в какой раз он инцелизирует.
Да.
Ну, скорее всего, он просто ничего не делает с ним.
Ну, то есть, когда вызывается дефолтный конструктор storage...
Когда вызывается дефолтный конструктор storage, ничего не происходит.
Просто ничего не происходит.
Вот. У него формально начинается время жизни, но ничего туда не плывется.
При этом вот этот чел...
Он ничего не делает, потому что он такой...
Ну, все равно потом дефолтный конструктор storage вызывается.
И, видимо, поэтому я тоже ничего не делаю.
Он реально может пригодаться.
Ну, по инструкции в порядке.
По инструкции в порядке.
Сейчас, когда у нас создается объект...
Ну, он не причина, чтобы объявляться, да?
У него уже сразу будет минопатия, да?
Ну, это происходит все равно.
Ну, да.
То есть, она прямо...
Конечно.
Окей.
Тогда дальше мы переходим к товарищу, который наш предыдущий конструктор, да?
Пробегаемся, и потом мы с ним поставим обязательно уже пример.
А дальше он пытается...
Ну, сконструировать storage, ну, типа...
Вступать, которую мы затронули, и при этом мы ее...
Это ты говоришь, чтобы он делал без оптимизации.
То есть, он буквально исполнял строшку за строчкой.
Поэтому так и сработало.
Типа, все нормально сработало.
Нет, он, наоборот, должен был нормально сработать.
Нет.
Потому что он сейчас с оптимизацией, он не обязан делать то, что ему написал детство.
Он может стимизировать это.
Если ты попытаешься изменить память...
Которая?
Которая у тебя уже был выполнен констракт и не была выполнена...
Там не был констракт, там было allocate.
Понимаешь?
Ты эту память алоцировал, но не инструировал еще.
В этом ты прикол.
А где мы конструируем память?
После родителей.
Сначала родители, потом сын.
Конструируем непосредственно объект, который...
Еще раз.
И как происходит конструирование, если ты наследник кого-то?
Выделяется память под всех вас.
Да, да, да.
Вызывается конструктор всех твоих родителей в каком-то порядке.
Вызывается конструктор тебя.
Вот смотри.
Вырезается память, которая относится именно к тебе, не к твоим родителям.
Нашего конструктора мы уже узнали, конструктор родителя.
Формаева наш конструктор есть, представляете, using.
Устой.
Что это значит?
Что мы как бы...
Еще в какой-то момент вызывается конструктор наших полей.
Вот это очень интересно.
Они вызываются после конструктора наших родителей.
Вот проблема вот эта.
Потому что у тебя конструктор, твоя волда...
Что такое using конструктор?
Конструктор storage, это то, что вызывается, его он вызывает, а там в ту же паре он вызывается
Его уже используют на объекты, скорее всего, он нравится
Ну, нет, он не совсем
Да, все так
Сначала вызывается конструкторы всех родителей
Это логично
Потом только конструктор variadic и union
Ммм
И конструктор variadic и union ничего не делает
Но из-за того, что он ничего не делает, имплядер может позволить себе отменить все, что сделано до этого
На этой памяти
Да, это правда
И я не понимаю, как мы вообще можем сделать так, чтобы это не было упадет
Мы можем сделать так, чтобы это работало, например, с аутом
Ну, надо просто как-то заставить его явно сразу кинцелизировать storage
За мнением делающих
А, ну, кстати, возможно, да, он может, типа, зачищать storage
Мы в разе не можем менять порядок инсталлирования, в смысле
Мы умеем отметить активизацию, как сказал
Это все равно UBS, в смысле, формально, даже если это работает, это...
Ну
Добро пожаловать
Да, ну, короче
То, что я хотел сказать, вот в чем заключается
Есть такая волшебная функция?
Да
Нет
Я сейчас закомментирую все, если да, си аут
Что здесь написано?
Закомментирую, если да, си аут
А, только, кажется, не весь, потому что си ауты две строчки кое-где
И вот эта часть не закомментируется
Я хотел сложить этот винт, да
Вот, да, сейчас мы увидим, что все падает снова
А под силенгом, кстати, не падает
Силенг просто без активизации
Чего?
Да даже O3 все равно, он просто не оптимизирует
Он предваряется
Вот, есть такая функция
Ну, короче, просто сейчас расскажу
Какая-то проблема решается, как это работает
И придется до следующего раза обложить
Есть такая замечательная функция
This is delonder, вот она тут должна быть использована
Что она говорит компилятору?
По сути, эта функция говорит компилятору, что вот это обращение нельзя оптимизировать
Где?
Значит, почему компилятор иногда решает пропустить вот эту часть?
Почему он решает ее пропустить?
Потому что он из некоторых соображений решает, что
Ну, у нас под этим указателем лежит значение, которое и так заведомо известно какое
Я не буду тратить время на его перезапись, потому что оно
Из некоторых соображений, связанных с УБ, связанных с нарушением вами контракта
Что вы не кладете подряд два раза одно и то же на один и тот же адрес
Компилятор решает, что второй раз пласть он не будет
Ну, по сути, здесь именно это происходит
Только компилятор первый раз решает, что он ничего пласть не будет
Да и второй тоже
Второй раз он ничего не кладет, потому что вы ничего не инициализируете
Первый раз он не кладет, потому что вы все равно положите
Второй раз, какая ему разница?
Ну, это УБ
Вот, std-londer это функция, которая
Очень трудно объяснить, что делает на самом деле
Можем посмотреть, если хоббель отличен
Нет, она и принцип, она built-in londer и там assembler
Там даже не assembler, там intermediate representation
Ее нельзя написать самостоятельно
Она чисто
Она на ходе внутренней имплементации компилятора
Она не на плюсах реализована
Она, короче говоря, предотвращает оптимизацию компилятора, которая разрешает не делать это обращение
По сути, она говорит, забудь, что ты раньше знал об этом сказателе
И сделай все равно то, что я тебя прошу
Не оптимизируй это обращение
Yes, do what I say
Я тебя очень прошу
Что-то вроде забудь, что вообще лежал раньше
Поэтому адресу памяти и читай, что это
Да, почему londer?
Ну, londer значит постирать
Бельмё постирать, еще деньги отмывать
Money это значит отмывание денег
Снимаком, комитет
Ааа
Значит, londer это функция, которая говорит
Не забудь, что ты знал раньше об этом указателе
Возможно, у тебя есть какие-то о нем предположения
Так вот, не делай их
Тем самым предотвращает оптимизацию, что можно не перезаписывать
И это актуально в случае варианта
Например, когда вы кладете
Когда у вас что-то лежало по этому адресу памяти
А потом вы туда кладете что-то другое
Компилятор в этот момент, он может
Если вы там
Даже если вы вызвали деструктор
Компилятор такой может
Вообще, при некоторых условиях
Компилятор может предполагать
Что там лежит то же самое
Что и раньше и не будет заново считывать указатель
Ну, например, если у вас был тип
В котором константное поле
А потом бы в плейсмент нею туда
Положили другое константное поле
Но компилятор может предположить, что
Константа не изменилась, поскольку она была константой
А второй раз класть на ту же память
Вы, по идее, не должны
Если вы не сделали это
Совсем правильно, что компилятор не заметил
Что время жизни объекта закончился
Потом снова началось время жизни другого объекта
Компилятор может иметь предположение
Относительно указать, что там что-то лежит уже
Вот Sdlonder предотвращает это предположение
И заставляет компилятор
Не использовать, тихо положу туда, все равно
Короче, с Sdlonder это будет
Работать правильно
Только 5 почему-то не вывелось
Потому что я весь Сяутик
А, потому что я весь Сяутик
Да, но ассерт не упал
Вот, короче, мораль
Для отечественного кода Sdlonder
Когда будет реализовывать вариант
Когда вы обращаетесь к
Именно в путе, да
Ну вот когда вы делаете пут
Может быть нужно это использовать
Потому что иначе
При оптимизации он проигнорирует
Для отечественного кода
Sdlonder
Есть что-то такое
Для отечественного кода используется ли Sdlonder
Нет, но там чуть другая реализация
Вот, я не понимаю, почему это
Явно сочетается УБ
Границы разумеют
Просто
Все, давайте
До следующего раза
Я хотя бы быстренько
Поперек, что делает Sdlonder
Компания, типа
Она же какой-то
Ассендертом инжинирует
Ну или меняет ассендерации
Она как раз
Ну вот, вот у меня есть
Собственно вот
Вот как выглядит этот код
В ассемблере без
Без Sdlonder
А вот как с Sdlonder
Ну
Сама с Sdlonder ничего понятного
Генерирует, она наоборот
Запрещает компилятору оптимизировать некоторые
Ассембльные инструкции
То есть с Sdlonder, я в том, что я добавлю Sdlonder
Ассемблера станет больше
Потому что действие компилятора
Буду нужно сделать больше
Ассемблерная инструкция во что-то транслируется
Раньше она ни во что не транслировалась
Сейчас
Где это у нас
Вот она
Ну по сути вот
Кладет 5 туда
Если я закомментирую
То она вообще ни в какой ассемблер не транслируется
Эта инструкция
То есть от того, что добавил Sdlonder
Появились новые ассемблерные инструкции
Просто компилятор не оптимизировал эту часть
