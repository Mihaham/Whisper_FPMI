Следующее, что мы хотим научиться реализовывать, это no throw move constructible и move no accept.
Is no throw move constructible и move if no accept.
Почему мы нампистим no throw и move no accept?
Без комментариев, не знаю.
Интересно, интересно.
Ну, понятно, что мы сейчас научимся реализовывать не только из no throw move constructible, но просто из no throw что угодно, а move no accept просто для него как раз no throw move constructible понадобится.
Ну, смотрите, у нас в принципе уже есть из move constructible, ну, почти есть, но давайте я вам скажу, что у меня есть вот, вот по сути, что такое из move constructible?
Это из constructible от T и T, V, M, A.
Так?
А из move constructible V это из move constructible от V, V, L, все, все, move constructible готово.
Вот это же R-value ссылка, а не универсальная ссылка, понятно.
Как это отличать? Я уже видимо, я без того понимаю.
Универсальная ссылка это то, что в функции, а здесь конкретная штука, ты просто с the mempersand'ами, ты янжер, указываешь, когда этот шамлон используешь, типа свой, the mempersand.
Универсальная ссылка появляется в функции.
Ну еще, а у универсанта.
Не всегда появляется когда-нибудь ссылка, потому что, если у тебя перейдут 1-2 конструктора и 1-2 нет, то одна из них универсальная.
В общем, давайте начнем опять с застряния надолго на этом сговорю, хочется побыстрее уже.
Значит, как реализовать из move constructible? Ну, наивный способ сказать, что это же просто, что такое из move constructible?
No, throw move constructible. Ну, это, казалось бы, просто из constructible и что?
No, except, what?
No, except, what?
T, what?
Чего?
Decal valve.
Ну, можно сказать decal valve.
Ну, можно сказать так, да, нормально.
Она и так правила T, но, в принципе, можно и так сказать.
Почему это неправильное? Это наивная реализация, но неверная. Принципиально неверная.
Она не будет работать.
Вообще, в любом случае.
Нет, ну, в каких-то случаях она будет работать.
Не по-всюду.
Что?
Decal valve.
Приватный, например.
Ну, она не будет работать, в случае, когда...
Можно говорить, пожалуйста, что такое noexcept, what?
А ну, говорит, правда ли, что это выражение не может пьянуть исключение?
Это оператор noexcept.
Он, по-настоящему, впечатлимый.
Возвращает true...
Возвращает false, если там внутри есть mu, dynamic cast или throw, или какая-нибудь не noexcept функция и false во всех остальных случаях.
Конечно, non-evil-weighting.
Он не вычисляет, разумеется, это выражение.
Он только проверяет noexcept ли там.
Почему это не будет работать?
Потому что, если нет move-конструктора,
если эта штука не move-constructible,
то из constructible будет false,
ну, я могу написать здесь, наверное, из move-constructible от t,
это будет false,
и вот эта вот выдаст ошибку, купиляция.
Если нет move-конструктора, то вы скажете, ну, правая часть логического i не вычисляется.
Так никто ее не вычисляет.
Она же компилируется.
Ну, это конъюнция обычная.
Если первый аргумент false, то конъюнция обычная.
Это конъюнция в каверси.
Это конъюнция в каверси.
Это конъюнция в каверси.
Это конъюнция в каверси.
Если первый аргумент false, то, казалось бы, правый аргумент не должен вычисляться.
Нет, значит, надо поприкнуть типа шаблон conjunction.
Вот даже, типа, мы сделаем проект первого и все.
Сенсибы точно не будет.
Все равно нужно сделать какой-то тип.
Шаблон conjunction.
Шаблон, нужно сделать какой-то тип.
Не, не, используется deconjunction.
А что во второй подставить?
Тоже самое.
Это не твой тип, а что?
Это же буллевский констант, а просто нужен тип другой.
Так мы же говорили, что conjunction просто...
Что, типа, conjunction просто реализован для типов,
но про факт, что она не будет работать.
Не, не, не, булл констант вот этот.
Да, если нужен булл вот этот.
Нужно булл... Вы предлагаете писать булл констант?
Да.
Которая... Че будет здесь?
Не, мы предлагаем...
Мы запихиваем в STD булл константа все этот месяц.
Что запихиваем в STD булл констант?
Пишем там создать конст булл value равно вот этому?
Да.
Так это опять CE будет?
И это запихнуть в SP conjunction?
И какая разница-то? Опять CE будет?
Почему оно подставится?
Он не должен подставить сюда.
Но он еще скорее потом должен уже был следом.
Посмотри второе.
В смысле, ты хочешь сказать, что он его не инстанцирует?
Да, почему его должен инстанцировать?
Мы же обсуждали то, что у нас...
В чем разница между full expression и conjunction?
Ну, я думаю, что...
Давай проверим.
Значит, че я хочу сказать?
Ты предлагаешь мне написать из no throw...
Что?
Ровно из твоей conjunction.
Мне нужно булл констант, значит.
А, ты хочешь...
Ты хочешь булл констант вот здесь?
Окей. Я понял.
Да.
Сейчас.
И там тоже.
Это мы на плеотипе закомментируем?
Сейчас, почему у нас из move constructable...
А, из move constructable это будет false type.
Ты хочешь сказать...
Стоп, что у нас сейчас вообще написано сейчас?
Секунду. Можно вернуть назад?
Я не понимаю.
Что у нас было написано?
Из move constructable V надо, конечно, здесь.
Да.
И using V?
Ой, да, constextable...
Да, это тоже правда.
Да, но constextable можно...
Все, хорошо, все нормально.
Только тогда из no throw move constructable V.
Да. Ну, можно...
Ну, хорошо. Давайте скажем, что...
Struct из no throw move constructable...
Это...
Это равно или наследование?
Наследование.
Это наследование, stconjunction V,
с шаглонными параметрами какими?
Из move constructable от T.
А еще, что вы предлагаете в constant?
От...
Э...
Вот этого.
И...
Углова скобочка закрылась.
И пустое тело.
Сейчас должно быть выгонять.
Вот. Ну...
Попробуем.
Возьму-ка я какую-нибудь структуру,
которая...
Которую нельзя мутить.
И попробую проверить, правда ли, что она
из no throw move constructable.
