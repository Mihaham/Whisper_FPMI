раз мы поговорили про, в принципе, что такое машина тюринга, в этот раз мы будем обобщать
машины тюринга, ну точнее не обобщать, а увеличивать размерность. У нас была там некоторая машина
тюринга от одного аргумента, сегодня мы переходим от машины тюринга с двумя аргументами nk, например.
Так вот, мы будем рассматривать не все такие бинарные машины тюринга, а особые. Которые
называются универсальные вычислимые функции. У нас есть, мы знаем, что у нас есть некое такое
соответствие между вычислимыми функциями машинами тюринга, поэтому я буду больше говорить про
функции, но то же самое вот справедливо там для машин тюринга, ну с точностью до определенных изменений.
Ну что такое универсальные вычислимые функции? Первое, это такая у нас будет функция у от слова
universal от двух аргументов nx, которая обладает двумя свойствами. Первое, у вычислима как функции
двух аргументов. Второе, это что для любого, скажем, что для любой f принадлежащей классу
вычислимых функций. Давайте я назову их как там вычислимые. Ну давайте вычислимые функции.
Найдется такой номер, что для любого x принадлежащего натуральным числам.
Ладно, давайте просто напишу для любого x. Понятно. Будет упоняться следующее, что у от
n0x равняется f от x. Причем мы будем допускать себе следующее обозначение. Вот такое вот,
что у с индексом n от x это есть не что иное, как у nx. В чем смысл вот такой вот штуки? В том,
что у нас есть все возможные вычислимые функции, а теперь мы их можем засунуть в
некоторую такую табличку. Вот у меня были. У меня табличка. Вот здесь пусть будут x. У меня
была функция, но просто принимал какие-то значения. А теперь у меня их можно замена
и получается вот здесь у меня лежит одна функция, здесь другая. Вот так вот они все сложены вверх.
На это можно смотреть, как на своего рода, как бы так сказать, трансляцию из одного языка в другую.
То есть у нас есть некоторый, например язык программирования, есть переводчик этого языка
программирования в программы на другом языке программирования. Так как у нас здесь и здесь n,
то есть на самом деле у нас есть двойственность, что у нас одновременно функции занумерованы,
аргументы занумерованы, и вот с этим как раз связан следующий прикол, что и аргументы это
натуральное число и функции тоже в некотором смысле натуральное число. Называется такой
прикол, проблема остановки. Пусть у нас есть некоторая универсальная честная функция,
буду обозначать везде ее как УВФ. Тогда множество, множество с, множество таких
аргументов n, что у n, n определено. Оно является неразрешимым.
Это называется проблема остановки.
Но несмотря на то, что это неразрешимо, мы можем точно сказать, что это перечислимо.
Давайте придумаем алгоритм, как это все перечислить. Ну, у нас есть, есть,
у n, t это у нас некоторые машины тюринга, то есть у нас у n, t это будет некоторая функция,
аргумент, который будет подаваться вот во второй знак. Ну давайте, я не знаю, были ли у вас,
но языке бы программирование, это бы назвали в языках программирования, если бы мы писали,
мы бы написали что-то такое, что f от x это у нас равняется, а здесь даже нужна лямбда, ладно,
окей, хорошо, у n, x, для какого-то n. Тогда, если эта машина, это какая-то вычисленная функция,
соответственно, есть некоторые машины тюринга, которые вычисляют, тогда что мы делаем? Мы берем,
перебираем все пары, пары вида n, t и запускаем у n в аргументе n,
на t шагов. Если завершится, то соответственно, мы выведем, не завершится, но не выведем. Все,
таким образом, мы сможем перечислить все такие n, на которых эта универсальная функция будет
завершаться. В следующем, ну, сначала свойств следующим теоремой, мы обозначим теорему
поста. Вроде в прошлый раз мы о ней говорили, что множество m является разрешимым,
раносимо тому, что m перечислим и ко перечислим. Что мы можем здесь сказать, что если у нас есть
теорема поста, мы имеем неразрешимость, но перечислимость, тогда отсюда мы можем сделать
следующее заключение, что не ко перечислимо по теореме поста. Хорошо, следующей характеристикой
интересной будет тотальность. Тотальность функции. Что такое тотальность функции? Это всю доопределенность.
Ну, то есть, не существует такого x, что не существует f от x. Ну, или по-другому будет у нас,
как это звучать, что для любого x будет существовать некоторое a такое, что a равняется f от x.
Ну, функции там действуют из какого-то одного множества в другое, не конкретизируем.
Хорошо, вот у нас есть универсальность функции, а что насчет, скажу, насчет универсальной
функции, которая при этом является тотальной. Так вот, подтверждается, что не существует
такой функции. Не существует универсальной тотально участвуемой функции. Почему не существует?
Опять же, используется техника диагонального метода кантера. Это же кантер? Вроде кантер. То есть,
у нас снова есть вот эта табличка. Здесь x, здесь n. Если диагональный, рассматриваем диагональ.
И берем, рассматриваем аргументы. То есть, здесь 0, 1, 2, 3, 4, 5, полетели. 1, 2, 3, 4. Рассматриваем
функцию d на 1 диагонали. d от x равняется, давайте вот, пусть это у нас какая-то функция tnx,
тотально универсально участвуемая. Пусть она существует. Тогда мы рассматриваем d от x, это txx.
Что в таком случае? В таком случае рассмотрим функцию d штрих, от x полученные d от x плюс 1.
Это натуральное, плюс 1 тоже будет натуральным. Хорошо, если это везде определено, то и это тоже
везде определено. Ну а это означает, что d штрих от x принадлежит классу тотальных функций.
Но, очевидно, не существует такого n, что tnt от x будет равняться d штрих от x. Поэтому
универсальные тотально участвуемые функции не существуют. Хорошо, мы говорили про кооперечислимость
как то, что дополнение принадлежит. Также на кооперечислимость можно смотреть немножко другим
способом, на самом деле тем же самым. А именно следующим, что мы должны перечислить элементы,
которые не лежат. А, ну это в целом и есть, да, по сути тоже самое. Хорошо.
Смотрим следующий. Терема райса Успенского. Очень важная терема. Терема райса Успенского.
И говорит она нам о следующем, что любое нетривиальное свойство машин тюринга неразрешимо.
Начнем. Что это означает? Первое, что нужно отметить, что значит нетривиальное.
Нетривиальное тире это не пустое множество и не все натуральные числа. Ну то, мы же про машин
тюринга. Не все машины тюринга. Вот так вот. Мы сейчас работаем не в некоторой номинальности.
Хорошо. У нас есть машины тюринга. Свойства это у нас что? Это у нас некоторые подможества.
Время вспомнить. Интересным следствием этой теоремы будет то, что у нас неразрешимым будет в принципе
произвольный предикат. Нетривиальный. Свойства это предикат унарный. Для большей
мощности мы просто можем сводить их. Но о сведении вроде попозже или давайте сейчас расскажем про сводимость.
У нас есть операция M с водимостью. В чем ее смысл? У нас есть некоторые два множества. Множество A и множество B.
Мы про эти множества можем говорить разрешимые они, неразрешимые, перечислимые не перечислимые,
копии перечислимые, не копии перечислимые. Там много еще интересных свойств. У нас есть функции.
Функции могут действовать с одного множества в другое. И вопрос. На каких множествах возможны
вычислимые функции? Как будут связаны между собой множества, если на них действует вычислимая
функция? Начнем с первого момента. Давайте рассматривать не просто такую, а функцию,
некоторую такую функцию из аморфизма этих двух множеств. То есть что у нас было из аморфизмом,
что x принадлежит A, равносильно f от x принадлежит B. Мы накладываем на это из аморфизм требования,
что это вычислимо. И в таком случае мы называем, мы говорим, что ам сводится к B.
И оказывается, что из этого вытечет несколько интересных свойств.
Первое свойство. Оказывается, что B накладывает уже в себе очень... B накладывает уже сильные
требования на то, как ему должно быть A. Но в целом это действительно понятно. Если мы можем как-то
определять... Сейчас. Можем как-то определять элементы B, то используя функцию f,
которая вычислима, мы также можем определять элементы A. Поэтому из B перечислимости,
разрешимости ко перечислимости будет следовать, что A тоже перечислима, разрешима ко перечислима.
Понятно, что если у нас есть импликация в одну сторону, у нас есть контрпозиция.
То есть если A не что-то из этого, то B тоже не. Дальше есть следующие два свойства. Это
свойства, которые позволяют нам охарактеризовать M-сводимость как отношение. И это рефлексивность.
Очевидно, функция Identity вычислима, поэтому селок. И транзитивность.
Транзитивность. Композиция двух вычислимых функций тоже вычислима. Это нам дает свойство предпорядка.
Антисимметричности нет, в том смысле, что у нас, например, все разрешимые между собой M-сводятся.
Так что все M-сводятся. Более того, на самом деле есть более сильные свойства про все разрешимые,
что любое разрешимое множество сводится к любому нетривиальную множеству.
Когда я сказал, что любые два разрешимые сводятся друг к другу, исключая вот случай тривиальных множеств.
Не все плохо. Почему пятая возможна? Потому что если A нетривиальная, в нем есть элемент,
который принадлежит, и есть, который не принадлежит. В этом его нетривиальность.
Там не может быть только один случай, там обязательно два. И если оно разрешимое, то у нас есть
характеристическая функция. Ну тогда мы просто давайте там, где она единица, сведем к элементу,
который лежит, там где ноль, сведем к элементу, который не лежит. На этом все по теории. Если есть
вопросы, я могу ответить. Если нет, то будем разбирать. Хорошо.
Первый номер. Смысл его определить перечислимость, не перечислимость,
коперечислимость, не коперечислимость. Задание желтое, непростое. Здесь много подводных камней.
Ну в целом здесь можно ошибиться. Начнем. Множество простых чисел. Какие предположения?
Мы можем определить число простое или нет? Ладно, видимо все спят.
Простые числа мы умеем проверять на простоту, просто проходить по всем числам меньше его и
проверять делимость. Поэтому это разрешимо. У нас буквально есть алгоритм. По теориям
что разрешимность это перечислимость плюс коперечислимость. Дальше. Множество всех программ,
вычисляющих все функции. Ну смотрите. Множество всех программ, вычисляющих функцию. Оно тривиальное
нет. Потому что есть которые не вычисляют и есть которые вычисляют. Соответственно это у нас
неразрешимы по теориям Ирайса Успенского. Множество программ, вычисляющих функции совпадающие. Ну так же,
так же, так же. Тривиальных здесь нет. Все что про программы. Пар программ. Это уже предикат.
Бинарный. Он тоже работает. Поэтому здесь уже все. Вот в этом блоке ничего кроме обыть не может.
Скорее всего да. Здесь будет какой-нибудь простой алгоритм. Все остальное здесь не лежит. То есть
здесь у нас максимум один элемент в этом блоке. Поехали. Множество программ, вычисляющих функции.
Что мы можем делать? Давайте думать алгоритм который мы попробуем. Ну мы можем просто
перечислять подряд программы и проверять что хорошо не хорошо. Если один раз хорошо это не
значит что всегда хорошо. Но если один раз плохо это значит что всегда плохо. То есть если один раз
встретили беду мы можем остановить цикл и выйти из него. Поэтому мы можем определять программы
которые не вычисляют ее в этом перечислении. То есть нам буквально не нужно проходить все аргументы
и все и чтобы узнать функция не вычисляет ли функцию квадрата. Соответственно это есть
код. Оно не разрешило значит у нас есть код перечислимость и не перечислимость. Сейчас жу.
Стоп у меня печено как здесь. Сейчас подумаю.
Давайте подумаем а я пока пойдем дальше. Почему у меня так ступило с b? Странно странно странно.
Ну все просто с b я понял что происходит. Здесь работает следующая логика. Что у нас есть тотальные
функции множество тотальных функций. У меня есть некоторая функция t. Я эту могу функцию t свести
к программе которая вычисляет вот эту функцию квадрат. Каким образом? Я по t построю функцию t от x.
По t от x я строю функцию t от x делить на t от x умножить на x квадрат. Мы видим что это сводимость
она вычислима. Соответственно тотально у нас не перечислимый и не ко перечислимый.
Не перечислимый и не ко перечислимый. Соответственно это лежит здесь.
Я все понял в чем проблема с не ко перечислимостью. В том что когда говорю что есть один раз у нас
случилась проблема и на этом можем закончиться. На самом деле у нас же есть там класс функций
которые вообще никогда не останавливаются. Поэтому проверка того что функция определенна
она уже не особо вычислим. Как раз на тотальных здесь мое прорабатывает. На нетотальных не отрабатывает.
Множество программ вычисляющих функцию f совпадающие с x квадрат на своей области
определения. Ну вот тут как раз отрабатывает то о чем я говорил. На своей области определения
значит мы можем там она область определения значит она за конечные шагов конечные числа
шагов отработает мы можем просто проверить результат верный он неверный если он где-то
неверный значит ну все беда мы сразу ее выведем здесь в буква gm множество пар программ с
не пересекающимися областями определения что тут делать
пупу пупу пупу пупу пу пу ой тут пересекающиеся. С пересекающимися ну все просто мы можем
перечислять пары программ и проверять, просто запускать их на определенное число шагов. Если у
меня отработали, я могу проверять, что отрабатывает ли вторая программа на том же аргументе. То есть мы
просто берем пара программ, запускаем на каком-то аргументе на определенный число шагов. Если они обе
остановились, то значит все это победа. У них пересеклась область определения. Если нет,
ну не повезло. Получили перечислимость. Пункт D. Множество программ, вычисляющих функции,
строго возрастающих на своей области определения. Но опять же замечаем вот этот вот паттерн.
Чуть-чуть слабее его сделаем. Вот на своей области определения, на своей области определения. Этот
паттерн как раз подсказывает нам, что здесь есть ко перечислимость. То есть на своей области
определения, значит программы тут завершились. Поэтому вопрос лишь в том, что мы можем на этом
сделать. Если мы можем какое-то свойство на область определения, если оно один раз не выполнилось,
на каком-то элементе, то оно не выполнится на всем. А свойство для области определения в общем случае,
то есть что для всех оно выполняется, это не вычислимо. Потому что сама по себе область
определения может быть бесконечной. А мы не можем бесконечное количество элементов обработать.
Поэтому здесь точно также ко перечислимость.
Вот. Да пусть у нас есть некоторые свойства. Даже отмечу это, что у нас есть свойства.
Дайте я просто напишу. На области определения это дом,
сразу подозрение на ко перечислимость. Почему может быть не только ко перечислимость? Потому
что, во-первых, проверьте, может быть, во-первых, это тривиальное множество или там еще есть какие-то
подводные камни. Идейно почему-то так, что не выполнено на х, то
и на дом, на всем. Ну то есть на всей области определения.
Дом бесконечный. Вот да. Вот такой вот есть интересный момент, который можно сразу в этом
задании улавливать. Дальше. Ну это уже очень простое задание. Тут нужно брать все баллы за него.
Задание на эмсводимость. Задание простое. Поехали. Если A сводится B и A сводится C,
то B сводится к C. Ну вообще не факт. Как это опровергнуть? Ну очень просто. Разрешимость,
неразрешимость, разрешимость, разрешимость, неразрешимость, разрешимость. Такого быть не
может. Если неразрешимая, то она сводится к неразрешимому. Если A сводится к B и B
разрешимая, то A разрешимая. Ну да, верно, это свойство. Если A сводится к B и A перечислимо,
то B перечислимо. Ну не факт. Если было бы B перечислимым, то как раз могло бы не так.
В каком случае? Ну почему не так? Возьмем в качестве A разрешимое множество B множество
тотальных функций. Множество тотальных функций не перечислимо и не ко перечислимо. Прекрасное
множество, которое прям отрицает все. То есть если мы только свели тотальное множество к чему-то,
мы сразу показали и неразрешимость, и не ко перечислимость. Ну и неразрешимость тоже.
Если A и B разрешимые, и B и не B пустые, то да, все верно. Вот это вот условие, оно и означает,
что B не тривиальное множество. Ну и это мы никогда не убираем.
Ух, а теперь уже более сложные.
Поехали. Множество самоприменимых программ M сводится, множество самоприменимых программ
это 0100S. М сводится множество программ, останавливающихся в нуле. Давайте, которые
останавливаются в нуле, будем называть H0. H от слова holds останавливается. Останавливается
0, H0, M сводится, множество программ останавливается на любом входе. Останавливается на любом входе,
это значит тотальные. 100T. Множество программ останавливается на любом входе,
к множеству программ, не останавливающихся ни на каком ходе. Давайте их... Сейчас подумаю.
Давайте, скажем... Давайте U.S. назовем их Unstoppable. Множество программ не останавливается
ни на каком входе, и снова U.S. M сводится к множеству самоприменимых программ S. Ну и поехали.
Нам нужно просто разобраться про каждое множество, что я ищу. Начнем. Про множество U.
Ой, про множество S мы сразу знаем два свойства. Перечислимость,
кооперечислимость. Разрешимость я писать здесь не буду, потому что да, это комбинация тех.
Поехали. Множество S. Перечислимо, некоперечислимо. Дальше.
Дальше. Множество тотальных функций. Неперечислимо, некоперечислимо. Рассмотрим множество HX.
То есть множество программ, которые останавливаются на входе N. Что мы можем сделать? Понятно,
что оно неразрешимо. То есть у нас не может быть одновременно два плюса. Но я могу сказать,
что оно перечислимо. Почему? Давайте я буду подряд запускать все программы на определенное число
шагов. И на вот аргументе N. Если программа остановилась, я выведу. Так я перечислю все
алгоритмы, которые останавливаются на каком-то шаге. Сам применим. Применимы. Тотальные. Останавливаются
на всех ходах. Определены на N. Останавливаются. Дальше.
Давайте. Множество программ, которые не останавливаются на каком-то входе. Это тоже
не тривиальное множество, поэтому два плюса не может быть. Соответственно, у нас осталось два
варианта. Либо это перечислимо, либо коперечислимо. Работаем по той же схеме, что и с HN. Запускаем все
программы на входе N и проверяем. Если программа остановилась, ну все. Значит, она не принадлежит
ему точно. Поэтому можем вывести. Откуда имеем не коперечислим. Имеем коперечислим и не
перечислим. Unstoppable. Дальше. Это не на каком входе она останавливается. Они аналогичны
коперечислим. Теперь мы берем еще перебираем все входы. Еще какие-то интересные множества
вроде бы не было. Вроде бы это все, что нам нужно. Можно было подумать, что как бы HN, если мы N
начнем постепенно разворачивать во все чиса, оно перейдет в T, а это переходит сюда, то,
по аналогии, что мы начнем в общей тени на все, то множество тотальных функций US должны стать тоже
не коперечислим и не коперечислим. Почему же тут все по-другому? Как раз проблема в том, что нам
очень сложно понять. Уже еще работала, и нам нужно еще подождать, и она закончит. И рефункция,
в принципе, никогда не может работать. Поэтому неопределенность ломает тотальность. А в случае
с неостановкой, у нас нет проблем с тем, что программа может работать бесконечно. У нас здесь
какой критерий того, что не лежит. Так, о чем это я был? О том, что функции, которые... вот US множество,
оно будет... сейчас... останавливаться, это holds. Зачем я начал S использовать? Ну ладно, раз начал,
то уже начал. В общем, проблема в том, что здесь как раз мы будем проверять остановку. Остановка
это конечное число шагов. Поэтому если функция остановилась, то она остановилась. Все, у нас нету
вариантов того, что нужно подождать пару шагов или бесконечности. Вот, здесь нужно быть внимательным.
Откуда что мы можем сказать? Что, например, к тотальным... сейчас... тотальным и ни к чему другому из
этого сести не можем. Поэтому V точно не отрабатывает. Дальше... сейчас... US к S. OK, по табличке
возможно. То есть смотрим, чтобы не было такого, что минус перешел к плюсу. Вот этого точно нельзя.
H0 к T OK, S0 к H0 OK. Теперь начинаем думать, можно ли это осуществить.
А, ну еще G невозможно, потому что да, тут плюс-минус, а здесь минус-плюс. Такие программы друг другу не
сводятся. Ужух. У нас осталось вот первые два пункта, которые, казалось бы, по табличке в целом
вообще возможны. Но если табличка говорит, что возможно, значит, пытаемся придумать сводимость.
В целом, если время меняем в обрез, ну, все то, что осталось... все то, что возможно по табличке,
то и отмечаем. Это, кстати, я бы назвал достаточно сложным заданием. Начнем. Множество самоприменимых
сводится к нуду с программ, останавливающихся в нуде. Просто построим по программе самоприменимых
программ. Ух. То есть программ с номером. То есть у нас есть программа. Вот такая вот у nt от x. Мы по этой
функции построим функцию следующую. Функцию f от x равняется у от nn. Мы взяли вот наши функции,
просто разбили вот ее самоприменимость на все аргументы. Сделали такую а-ля константу,
которая... ну, либо константа, либо функция нигде вообще не завершается. И что теперь происходит?
Если m самоприменима, то она останавливается. Соответственно у нас, что функция f от x останавливается
в нуде. Если функция у nt не останавливается, то и функция f от x тоже не останавливается в нуде.
Ну какая здесь аналогия? Ну если у нас была функция самоприменимая, там f от x, мы по ней
строим функцию g от x равную f0. Но если она останавливается в 0, то та будет самоприменима.
Не останавливается, то та тоже сама неприменима.
А теперь время следующего номера.
Что происходит в данном случае?
Тридцать шестая задача. Здесь есть два варианта того, как может быть. Множество
программ может быть и некоперечислимым, и неперечислимым. В таком случае вам
нужно будет сводить множество тотальных функций к функциям из условия. Либо оно будет только
коперечислимо, либо оно будет только коперечислимо, или только перечислимо. В таком случае вам
нужно показать одну и дальше доиспользовать теоремы Райя Суспенского. В общем, здесь понятно,
теорема Райя Суспенского даст неразрешимость, и я утверждаю, что это множество коперечислимо.
Почему? Так.
Будем перебирать тройки вида МХ.
И будем делать что? Запускаем
МТЮ машину тюринга, ну программу, то есть машину тюринга, на входе Х, на время Т,
на Т шагов. Если завершилось, и выход нечетный,
следовательно, не принадлежит. Следовательно, вывод.
Это алгоритм коперечисления. Для программ, которые где-то определены, хоть где-то определены,
это точно работает. Возникает вопрос, а что если у меня, в принципе, программа, которая никогда,
нигде не завершается, ни на каком входе. В таком случае, я, в принципе, никогда ее не смогу здесь
вывести. Это будет означать, что она должна принадлежать этому множеству. Но и действительно,
если программа нигде не определена, то у нее множество значений, это пустое множество. А для
пустого множества все свойства выполнено. Все значения, все элементы пустого множества,
вычетные, да, все верно. Поэтому также здесь еще нужно добавить комментарии про
случаи, нигде не останавливающихся программ. Ну, откуда имеем коперечислимость?
Плюс теорема райса Успенского равняется неперечислимости. Но опять же, про теорема райса Успенского нужно будет
сказать пару слов, что это множество нетривиально. Показать, что действительно это нетривиально,
привести пример, когда лежит, когда не лежит. Пример того, что это множество не пусто, вот такая
функция. То, что дополнение множества не пусто, вот такая функция. Все, показали, что действительно
условия теоремы райса Успенского верны, соответственно, можем ее использовать. Вот это вот не забываем.
Но опять же, на самом деле, это тоже не до конца. Теоремы райса Успенского даст неразрешимость,
и надо будет сказать, что еще плюс теорема поста. Вот про это не забывайте. Сама по себе,
только теоремы райса Успенского это не даст. Нужен еще критерий поста. Что у нас осталось? У нас осталось...
У нас осталось 37 номер. Он про свадимость.
Я поставлю здесь красное, здесь желтое. Что с машинами тюринга? У нас не перечислимо,
не ко перечислимо. Есть такая комбинация, то используем Т. Если не перечислимо, а не ко перечислимо,
используем множество тотальных функций. Если перечислимо, не ко перечислимо, используем
множество самоприменимых. Не перечислимо, ко перечислимо, используем дополнение множества
самоприменимых. Все. Сразу понимаем, что будем использовать, после этого проводим
саму М-свадимость. Покажем, что множество тотальных функций сводится к множеству М. Я вот этот
положу за М. Хорошо. Итак, пусть у меня есть некоторые функции f от x принадлежит М. Мне
нужно по ней построить, сейчас скажу, некоторые тотальные функции. Хорошо. Как я буду ее строить?
Нет, у меня есть некоторые t от x, тотальная функция. У меня есть теорема о том, что М и П,
они равномочны, то есть существуют некоторые объекции. Назовут их f. Она вычислима, вычислимая
объекция, там все хорошо, поэтому я могу сделать следующее. Давайте я возьму и скажу, что я по t от x
построю М от x. М от x принадлежит М. И буду я это делать все функционалом psi. Как работает
функционал psi? Функционал psi берет себя функцию t и возвращает функцию M. Давайте я так запишу.
Функционал psi на функции t в точке x, то есть это равняется M от x, равняется следующим образом.
Функция t, тотальная, от psi минус 1 от x, если x принадлежит простым числам. Не определено,
если x не принадлежит простым. Что теперь мы имеем? Сейчас скажу. Если t, можно сказать,
что psi из комы M с водимостью. В чем тут идея? Почему сделано так? Если t, тотальное, то у любого
x из п будет какой-то некоторый прообраз в N, соответственно, применив к нему t, мы получим какое-то значение.
Действительно, множество областей определения будет совпадать множеством простых чисел. Получается,
M будет лежать в M. Если же t не тотальная, то будет какой-то аргумент, на котором она не определено.
Это означает, что для некоторого, ну понятно, что для некоторого, сейчас скажу, для некоторого
натурального числа будет некоторый прообраз, будет образ в простых числах, и вот на нем окажется,
что функция будет неопределена. Поэтому область определения у M не совпадет с простыми числами,
и в результате это будет действительно M с водимостью. Зачем мы делали вот это вот phi? Потому
что, казалось бы, зачем вообще оно нам нужно? Мы могли бы просто сразу делать t от x. А что,
если t это не тотальная функция, которая определена на всех x, кроме x равного 6? 6 не является простым.
Поэтому, в таком случае, функция t построит нам вполне себе функцию M, у которой область
определения будет совпадать с областью простых чисел. Именно для этого мы перевели все простые в
некоторые натуральные числа, чтобы гарантировать, что если t где-то не останавливается,
то вот это натуральное число мы его получим в качестве аргумента. Хорошо, и вроде последний
номер. Да, последний номер. 38. Скажу честно, я уже не помню какие варианты к нему,
поэтому, возможно, я его оценивать не буду. Тот, который здесь есть, но он не особо сложный.
Логика выполнения здесь следующая, что нам нужно неразрешимое множество, любое бесконечное
множество, которое также неразрешимое. Для этого нам нужно воспользоваться следующим свойством.
Первое. Разрешимых множеств счетно. Соответственно, мы можем их нумеровать.
Поехали. Давайте считать, что это номерация. Буду, наверное,
играть в их омега 1, омега 2, омега 3, омега 4 и так далее. Также я скажу,
что не просто это разрешимое множество, а разрешимое множество, мощность которых бесконечна.
Ну и поехали. Имеем вот такую табличку. 0, 1, 2, 3, 4, 5, 6 и так далее. Это номерация элементов.
Здесь по строкам будет номерация самих множеств. Омега 0, омега 1, омега 2,
омега 3, 4, 5, 6 и так далее. Ну и поехали. У меня здесь вот так вот элементы и добро.
Чем идея в том, что давайте мы просто для любого такого множества выкинем один элемент. В
таком случае у нас получится нужное. Осталось просто правильно это сделать.
Как мы будем это делать? Сейчас скажу.
У 0 множества 8 0 его элементы. И скажем, что вот этот элемент мы берем,
вот этот вот обязательно мы не берем. Хорошо. В следующем множестве,
сейчас неразрешимое множество, любое бесконечное множество тоже неразрешимое. Хорошо. Мы берем,
идем и проверяем, что первый элемент, который можно взять. Вот предыдущий элемент, его взяли.
Берем и идем дальше, не берем после него. Первый элемент, который нельзя, который новый будет.
Дальше. Следующий множество. Первый элемент новый, если есть мы берем, который не встретился,
не берем и так далее. Отметим, что на каждом шаге у нас берется лишь конечное число элементов и
аналогично лишь конечное число элементов было выкинуто. Поэтому рано или поздно найдется для
любого омега некоторый элемент, который мы еще ранее не использовали, поэтому его можно будет взять
и найдется элемент, который можно выкинуть. Таким образом, мы пройдемся по всем разрешимым множествам
и все взятые элементы дадут нам именно то множество, которое мы хотим. Почему это сработает? Потому
что если вдруг у нас есть некоторые бесконечные под множество, которое разрешимо, то значит выбранное
нами множество пересекает, ой, выбранное наше множество содержит некоторую строчку. А этого не
может быть, потому что мы с каждой строчки вычеркнули один элемент хотя бы. Все. Задача решена.
Ну, на этом у меня все. Если есть вопросы, можете задавать. Если нет, то в целом все. Контрольная не
сложная, местами чуть неприятная. Вот этот вот момент, наверное, это самый сложный, но он сложный
за счет того, что здесь он нужно работать с функционалами, хотя до этого нигде с функционалами
не работали. То есть, по сути, вам нужна функция, которая берет на вход функцию и строит другую
функцию. Вот это вот вещь не особо интуитивно понятная и здесь действительно может быть непонятно.
Там и сложно придумать сразу, не нужно там больше времени. Все остальное легко, достаточно. Ну,
35-я тут. Ну, тут, опять же, просто поставить вот эту табличку для всех множеств. В целом,
наверное, процентов 50 всех множеств мы рассмотрели здесь. На самом деле, n здесь можно заменять не
только на n, а на какой-то тут картридж из n1, nk и все также работает. Ну, только конечный картридж,
конечно же. У меня все. Ну, видим, вопросов нет, тогда всем спасибо.
Все, пока-пока.
