И задачи общие. Есть специальная задача для группы 328 и 18.
О построении схемы функциональных элементов.
И специальная задача для 20-й группы.
Давайте мы их на семинаре разбирать не будем, но я дополнительно приложу файлы как бы я их решал.
Ну еще раз, мы в прошлый раз начали говорить про буду функции, что это такое, давайте еще раз вспомним.
У нас есть функции. Как они работают? У нас есть FK.
Мы добавляли дополнительные условия, что на Энарность.
Потому что в общем случае говорить про буду функции не совсем корректно.
Так что определяем что такое Энарная буду функция. Это 0,1.
Функция из 0,1 степени 0,1. Соответственно произвольная буду функция это какая-то Энарная буду функция.
Давайте определим классы Энарных буду функций.
И потом просто буду функция на связи с объединением всех классов по N.
Так же в прошлый раз мы говорили что есть буду функции.
И мы можем каждую буду функцию сопоставить Dnf, Knf.
Причем тот алгоритм, который мы делаем по таблице истинности, он дает нам не просто Dnf, Knf, а Sdnf, Sknf.
Оказывается, помимо Dnf, Knf, буду функцию можно представлять другими способами.
Сегодня мы будем больше говорить про то, как нам представлять буду функции не однообразным, а при помощи каких-то выбранных базовых элементарных операций.
Буду функции Dnf, Knf, они были про конъюнцию, дезюнцию, инверсию.
Второй способ это пареном Жигалкина.
Как выглядит пареном Жигалкина? Это 1, 40, конъюнция.
То есть мы теперь представляем другими операциями.
Давайте определим что в принципе такое пареном Жигалкина.
Дальше я буду здесь писать пыжи пареном Жигалкина.
Пареном Жигалкина, по определению, это есть ссор от i равно 1 по n каких-то пареномов Жигалкина.
Это не n, это i.
Где пареном Жигалкина.
Это либо конъюнция нескольких переменных.
Либо 1.
Как мы можем смотреть теперь на единицу? На единицу мы можем смотреть как на конъюнцию нуля переменных.
То есть у нас, например, когда было логибреическое, что у нас было в алгебре?
У нас были многочлены вида a, plus ab, plus что-нибудь там.
Плюс какие-нибудь цифры, которые 3, 5, 6, 8 и так далее.
Вот мы определяли количество вхождений переменных.
Это степень одночлены, ну или другим словом, монома.
И говорили, что степень вхождения переменных в моном вида какое-то число это ноль.
То есть ничего не вошло.
Ровно так и здесь. У нас в единицу просто не вошла никакая переменная.
Давайте поговорим, почему в алгебрических пареномах мы могли там писать еще что-то вида.
3mn, а здесь мы говорим, что это просто конъюнция нескольких переменных.
Потому что на самом деле в алгебре мы работали с исчастными коэффициентами.
В полиномаше Галкина мы берем коэффициент из какого множества, давайте подумаем.
Что-то я ничего не слышу.
0.1
О, супер, хорошо.
Берем коэффициент из 0.1.
Если я возьму коэффициент из нуля, то что такое, у меня будет ноль конъюнции на что-либо.
Это будет ноль.
Поэтому писать ноль коэффициент перед чем-то не имеет смысла.
А значит единственный коэффициент, который мы можем писать единица.
Но при этом, если мы сделаем единицы конъюнции что-то.
У нас есть свойство, что один конъюнции что-то, это есть само это что-то.
Давайте запишем свойство, что ноль конъюнции а, это а.
Для любого а.
И для любого а также упомяну, что один конъюнции а, прошу прощения, это само а.
Поэтому в реальности мы можем единственный раз, когда написать явно эти коэффициенты.
Это когда не вошла ни одна переменная в оно.
Причем ноль мы не пишем, потому что.
Что?
Потому что есть свойство, что для любого а.
Ноль к сор а, это а.
Поэтому ноль мы тоже не записываем.
Единственное, что действительно у нас может поменять значение.
Это один к сор а.
Вспомним, один к сор а, это...
Один к сор а, это что такое?
Не а.
Да.
Это отрицание а.
То есть один, он действительно меняет наше значение.
Хорошо.
Так, так, так, так, так.
Это что такое маном Жигалкина.
Дальше еще запишем интересное свойство про а.
Что для любого а, а конъюнции самим собой, это а.
Тогда, на самом деле, если мы будем увеличивать степень хождения переменной в маном.
Мы ничего не изменяем.
Там, например, в алгебре а и а квадрат.
Это абсолютно разные вещи.
В болевой алгебре у нас а равняется а квадрат.
В каком смысле, что это а на а?
Причем а на а.
Мы договорились писать средних полиномах Жигалкина,
подразумевая, что тут стоит знак конъюнции.
Хорошо.
Так, это, это, это, это есть.
Дальше.
Ну, давайте просто несколько свойств, почему полином Жигалкина это хорошо, красиво, круто.
Первое свойство.
Ну, наверное, это то, что называется коммутативностью.
У вас уже было, у вас уже были что-то типа группы кольца поля где-нибудь на алгебре?
Нет.
Нет?
Нет, не было.
Главное, грустно.
Тогда чуть позже вы поймете, что, в общем, вот эта система.
Сор и конъюнция и единица.
И единица.
Запись в помощи манома Жигалкина это очень крутая тема.
Запомните ее до, когда?
До того момента, когда у вас появятся там кольца поля.
Также аналогом это все будет на теории множеств.
Это что?
Теоксора это симметрическая разность для конъюнции пересечения.
И один это все множество.
Вот.
Эта система очень крутая.
Будете с ней работать.
Даже, по-моему, не только на алгебре.
Прямо с теорией множества будете потом работать на теорию меры.
Вот с этой системой.
Хорошо.
У меня есть коммутативность.
Сора и конъюнции.
Почему это важно и нужно?
Потому что теперь я могу произвольным образом записывать у себя конъюнции.
Могу произвольным образом записывать переменные внутри манома.
Ровно так же могу сталкаемые менять местами.
И ничего от этого не меняется.
Например, когда становится боль, беда, что этого нет.
Например, матрицы.
Если это матрицы, что делаете?
Матрицы перемножаете.
Перемножить матрицы мы не можем.
Мы не можем менять порядок перемножения матрицы.
И с этим на самом деле очень большой боль.
Второе, что у меня есть хорошее.
Ассоциативность.
Ассоциативность сора и конъюнции.
То есть я могу произвольным образом ставить скобки.
В частности, это позволяет мне просто скобки убрать.
Когда я пишу А, Б, С, какая разница?
Я сначала возьму конъюнцию от переменных А и Б.
И потом С к ним добавлю.
Или наоборот, начну с Б, С, потом добавлю А.
Но на личный XOR я могу произвольным образом поменять сагаи между собой.
И вычислить их другим образом.
При этом ответ я не поменяю.
Извините, а можно на примере?
На примере?
Давай, смотри.
А, Б, XOR, С, Д.
И давай еще что-то.
XOR, В, К, Н.
Понятно, что, во-первых, я могу поменять местами А и Б.
Вот внутри этого все добра.
И значение, когда я вычислю теперь, у меня не поменялось.
Это то, что называется коммутативность конъюнции.
Я поменял местами два аргумента.
Да, я про ассоциативность хотел понять.
Ассоциативность, смотри.
Ассоциативность говорит о том, что если я вот так расставлю скобки, то есть...
Сначала вычислю первую, первый XOR, потом второй XOR.
Или, наоборот, я поставлю скобки таким образом.
А, Б, С, Д, XOR, В, К, Н.
Значения будут одинаковые.
Например, как это называется?
Я не помню, как в школе это называется русскими словами.
Простите.
Это точно должно было быть.
Возможно, это распределительный закон или сочетательный.
Ну, это полезно, когда...
Нет, дистрибутивность, она есть, и это другое.
Дистрибутивность, она про две операции.
Вот мы сейчас после этого прямо расскажем.
Вот я могу сделать что?
Я могу...
Ну, например, пока не знаю, насколько тут хороший.
Давайте...
Сейчас.
Дистрибутивность...
Как коммутативность поможет при дистрибутивности?
Это точно.
Я могу сейчас показать.
А, ну, смотрите.
Например, у меня будет выражение какое?
А, Б, XORCD, XORCM.
Вот мы помним, что есть у нас дистрибутивность еще.
Давайте сразу запишу.
Дистрибутивность.
Что относительно чего?
Это вот опять то, как любят, то так и называют.
Какого-то единого соглашения о том, что значит дистрибутивность одной операции на другой, нет.
Поэтому я скажу, что это дистрибутивность конъюнции.
Ой.
Да, конъюнции надо...
XOR.
Если кто-то подозревает это другим образом,
ну, ничего страшного.
Главное в том, что...
Какой именно смысл вы под этим вкладываете?
А тут, ну, дело вкуса.
Что значит дистрибутивность конъюнции над XOR?
Это значит, что если у меня были A, XOR...
Что было у меня?
A, B, XOR...
А, C?
То есть, если у меня были 2 конъюнции,
A, B, XOR, A, C,
то это то же самое, что A, B, XOR, C.
Это называется левая дистрибутивность.
То есть, я взял с лева, вынес буковки в лево.
В общем случае у нас дистрибутивность...
Она...
Не всегда бывает просто дистрибутивность.
Иногда бывает только левая дистрибутивность.
То есть, если аналогично сделаю все справа,
буквы A вынесу,
то это правая дистрибутивность.
Если есть и то, и то,
мы просто говорим, что есть дистрибутивность.
Как правило, когда мы говорим просто дистрибутивность,
мы понимаем, что у нас есть коммутативность
операции вножения.
То есть, мы можем взять и поменять местами переменные.
Вот здесь, например,
в классическом расставлении скобок
у нас скобка стоит слева.
И вот применить дистрибутивность,
если у меня не было ассоциативности,
здесь я не могу, вот тут.
А я хочу применить дистрибутивность,
и для этого я пользуюсь ассоциативностью.
То есть, я теперь могу поменять порядок скобок.
Давайте теперь у меня скобки будут стоять не так,
а вот так, вот так.
Все.
Теперь у меня во второй скобке внутри есть
то, что я могу просить по дистрибутивности.
Я смогу вынести С.
Давайте, даже не так сделаю.
Я сделаю вот здесь, чтобы было написано МС.
Теперь мне надо будет воспользоваться коммутативностью,
чтобы поменять местами переменные М и С.
Я их сделаю, жух, СМ.
И после этого я все это добро превращу в С умножить на D плюс М.
И я на самом деле простил нашу запись.
Почему я простил?
Потому что, ну, просто посчитайте,
сколько переменных в первом случае использовалось
и сколько переменных здесь.
Это то, зачем нам нужны
свойства коммутативности, ассоциативности, дистрибутивности.
Есть такое, есть такое, есть такое.
Слушай, нам бы важно понять...
Хорошо.
Мы можем...
Четвертое.
Четвертое это хорошее очень свойство.
По сути, знаете, что оно говорит?
Что раньше мы под XOR мы пишем плюсик, обводим в кружочек.
Вот, если убрать кружочек,
то, ну, в целом плюс идет в точности как плюс
и умножение стандартное в алгебре.
Но мы обводим его в кружочек не случайно.
Что? Давайте его назову так.
Сортеры это и сложение,
и вычитание.
В чем кроется свойство...
Сейчас. Где кроется как раз это свойство?
Если мы нарисуем таблицу истинности 0011 01 01.
Вот AB.
А тут XOR.
То...
Заметьте, что происходит.
На нулях мы...
что сложим нули, что вычтем нули, мы получаем действительно 0.
0 и 1.
Если мы сложим 0 и 1, то это получится 1.
Если мы вычтем из единицы 0, это 1.
Если из нуля вычтем 1, мы получим минус 1.
Но так как минусов у нас нет, то...
На самом деле, что такое минус?
Минус это...
Я скажу.
Под минусом мы понимаем...
В общем случае, что такое минус A.
Минус A это...
такой элемент...
что A плюс минус A равняется 0.
Вот что такое минус A.
Это некое такое число, что мы добавим к A и получим 0.
Вот.
Что такое минус 1 в рамках булевой алтуры?
Это 1.
У нас в качестве сожжения теперь XOR.
1 XOR.
Что-то такое, что...
минус 1, что будет равняться 0.
А мы знаем, что 1 XOR 1 это есть 0.
Просто из таблицей истинности.
Значит, минус 1 вот это вот.
Это есть не что иное, как само по себе 1.
Поэтому 0 минус 1 это минус 1, который является 1.
Ну, аналогично для второго случая просто поменяли местами.
А...
1 плюс 1 это 2.
2 это перебрали.
Ну...
По-хорошему, еще один способ смотреть на это все как.
Вот вам рассказывали уже про...
модульную арифметику?
Нет.
Ну, мне кажется, что нет. Возможно, я ошибаюсь.
Почти уверен, что нет.
Ну, арифметика остатков по модулю.
Вот.
Ну, вы наверняка уже с этим как-то в школе должны быть сталкиваться, что...
мы можем вычислять значение по модулю какого-то числа.
Например, что значит вычислить по модулю 3?
Вот.
У меня есть. Я огрублю. У меня есть только цифры 0, 1 и 2.
Если я сложу два числа...
То есть, а...
Сделаю остаток по модулю м плюс b.
По модулю м.
Это будет...
На самом деле, я все возьму еще раз по модуле.
Потому что внезапно я могу вынести.
Выть из-за границы модуля.
Это все то же самое, что возьму а плюс b.
По модулю м.
Ну, свойства остатков давайте.
Просто сложили два числа.
Мы взяли остаток деления на m.
Дальше взяли остатки деления этих чисел, сложили.
Потом еще раз взяли от этого всего остаток.
Но это тоже самое будет.
Просто арифметика проверить.
Вот.
На самом деле, 0, 1 это...
Остатки какого числа могут быть?
Это только остатки 2.
Потому что у тройки уже может появиться остаток 2.
То есть, мы живем в остатках по модулю 2.
А тогда что такое 2 в рамках остатков по модулю 2?
Ну, давайте просто 2 поделим с остатком на 2.
Это в точности 0.
Поэтому 1...
Поэтому 2 в рамках пулевой алгебры это 0.
То есть, что сложили, что вычли то же самое.
Это важное свойство.
Что XOR это изображение вычитания.
Чтобы смотреть на полидом Жигалкина.
И как-то понимать, как с ним работать.
В плане, просто методом пристального взгляда.
Да, мы говорили, что XOR это, по сути, в сравнении по модулю 2.
А, супер топ.
Хорошо.
Так, теперь вот.
Полидом Жигалкина, супер дупер.
Да.
Мы его даже в ядно КТЧ там были рассказывали.
Теперь давайте смотреть.
Методы нахождения полидома Жигалкина.
В прошлый раз я рассказал про треугольник Паскаля.
Было.
Сейчас повторим.
Но на самом деле его недостаточно.
Они нам понадобятся не совсем для того, чтобы просто строить эти полидомы Жигалкина.
Насколько, чтобы понимать, какие у них есть хорошие свойства.
Построение полидома Жигалкина.
Первый способ это...
Как он там?
Треугольник Паскаля.
Хорошо.
Как работает треугольник Паскаля?
Давайте я расскажу на примере.
Функции из трех.
Агументов.
Нужно строить будет на нее.
Еще это ПЭКУЕР.
Дальше строим таблицу истинности.
Дальше строим таблицу истинности.
4 0 4 единицы 2 0 2 единицы...
2 единицы 0 1 0 1 0 1 0 1
И сама наша функция.
Давайте насыпием рандомных аргументов.
0 1 2 3 4...
Ой-ой-ой.
Какая красивая полетела.
0 0 1 1 1 0
1 1 1 0 красиво красиво что мы делаем у нас появилась появился вектор значений
функции прям видим вектор вот у нас 8 координат что мы делаем мы вектор
превращаем строку для этого применяем операцию транспонирование взяли прям
транспонируем 0 1 0 0 1 1 1 0 супер теперь начинаем строить
треугольник для этого по серединке между цирчистами ниже записываем 40 0 41 это 1
1 40 1 0 0 0 40 это 0 0 41 1 1 41 0 1 41 0 1 40 1 ну поехали дальше 1 1 0 1 0 1 0 1 1 1 1 0 1
0 0 0 0 1 1 1 0 0 1 1 1 0 1 0 1 1 1 0 0 но опа получили прям треугольничек на самом
деле этот треугольничек не не прям не поймет куда берется а здесь есть
биерция между ним и треугольником паскаля который был для биноминальных
коэффициентов и интуитивно откуда вообще взялись биноминальные коэффициенты но
помните мы начинаем сумма сумма сумма сумма это свойство это то что называется
паскаля для биноминальных коэффициентов когда значение вот этой штучки есть сумма
значений сверху слева справа только теперь сумма это если в какой-то бумажке
ваша задача просто я показать объект хорошо теперь на левый ряд
и видим какие-то коэффициенты а это есть коэффициенты при соответствующих
маномах в таблице истинности для этого нам надо каждому набору переменных сопоставить
какой-то маном какой маном сопоставим мы сопоставим маном который состоит из всех
переменных которых данном наборе перенесла значение 1 поехали для пейку для трех нулей у
нас какая-то переменная в него войдет но нет все нули значит никакая переменная вошла это
маном единица дальше вошла только переменная это маноме аналогично вон он ку здесь рожки
куэр это маном куэр п пр п ку п куэр ну так как мы помним что коэффициент 0 этому просто не
используем маном значит просто выбираем маном у которых которым соответствует единицы это будет
ссор через один куэр ссор п ссор пр вот построили полином же галтыны для данной функции
дальше у нас есть метод суммирования угольник паскаля он же не гарантирую что она самая короткая
что значит самая короткая нет лишних маномов или это ну у нас вот первых у нас нету прям
такого понятия как самая короткая ну по крайней мере мы мы этим не запаривались никогда но вроде
если мы посмотреть первым такой канонический вид полинома жигалки нигде я сокращу например
вот здесь вот я не сокращу там до r что как я могу сократить я могу сократить и р айдинг сор ку
ссор п айдинг сор р вот если мы не будем пытаться сократить таким образом не запретим запретим
скажем что это не полином же галкина на самом деле это не есть полином же галкин
как этого модификации то мы получаем минимальную просто сам по себе полином же галкина мы можем
явно расписать его вот не просто не такой формулой что это там уравняется а можем сказать что это
ссор я скажу по всем подможествам
ну дайте x1 тогда xn дальше соответственно теперь у нас какой-то подможество значит я беру
коэффициент альфа амега на конъюнцию по 7 x1 x на конъюнцию по 7 x и там лежащим в
амеге x итых и говорим что альфа амеговая лежит в 0 1 вот мы заняли более чуть конструктивную формулу
что такое полином же галкин ну и как видишь здесь мы просто либо используем аном либо
не используем оно поэтому самое короткое это когда мы убрали все неиспользуемые мономы здесь
так что задачи минимизации кнф днф здесь нету если уже все очень хорошо то есть много
член жигалкин когда мы записали это уже самое короткое это самый короткий полином жигалкин а
ну за исключением тех моментов когда мы можем например вот здесь я сделаю здесь ку здесь
делаю оставлю куяр то что я смогу сделать я смогу ку вынести один к соре а дальше меня это это я
могу снова это упростить превратить в п к сорку вот один соря заметим что новая запись в
разы компактнее но в том определении который мы дали это не является классическим полином
жигалкина то есть мы действительно можем упрощать но уже это будет не полином жигалкина просто по
определению метод суммирование скажите пожалуйста запись будет у нас записи грется будет
я не понял как там получилось то что мы эти две скопки перемножили ща по эксорку это типа
мэр вынесли да вот это вынес дальше вынес кушку а дальше вынесу уже нет и унес вот это вот это
обязательно вообще выносить или можно и так оставить эксорку и и так далее то что я сейчас
вынес это я просто показал что можно на самом деле запись упрощать но то что я упростил я
получил не полином жигалкина будем внимательны вот ответом будет ровно вот такая вот запись
ничего прощать не надо прям просто взяли получили какие маномы их записали через
сорк всю задачу решили даже не пытаться ничего упрощать оптимизировать этого не надо всех
устраивать
жух и поехали значение функции пусть будут у меня 1 1 1 0 0 1 1 не хочу хочу
красивый вот такой хорошо метод суммирования в чем заключается метод суммирования у нас
опять опять же те же самые маномы соответствует каждой строке таблице есть нести один
но вычисляем их уже несколько другим способом поехали как мы вычисляем на каждой строке мы
вычисляем дефицент последующий последующие формуле давайте скажу что альфа на наборе
икса 1 т.д. икса переменных причем уже здесь нули единицы это есть естественно сумма по модуле 2
по всем наборам и и у 1 т.д. и век н что будут меньше икс айдин т.д. икс н в смысле
декарта произведение f от y 1 т.д. икс н декарта произведение
уже проходили произведение частичных порядочных морс подида что были
да тогда порядок на 0 1 мы знаем на 0 1 у нас на 0 1 у нас порядок
вот у меня частично порядочные множество какое что 0 не больше чем 1
тогда декарта произведение декарта произведение у нас что было что мы берем декарта произвести
перемножаем вот эти все 0 1 и так далее n раз и получаем какой порядок что каждое
координата должна быть меньше вот такой у нас порядок давайте смотреть для строки из нулей это
только она сама значит это значение функции просто на этом наборе вот даже давайте просто
храню прошлую функцию показать что она одинаковая сейчас покажем что мы получили тот же все это
значение как можно удобно писать что давайте просто дальше записывать это значение везде вниз где
этот набор меньше ну где меньше набора всех нулей он всех наборов меньше поэтому
можно взять везде единички 0 эти прописать 0 взялся это значение функции теперь значение функции на
наборе 0 0 1 вот сюда записываем через ксори единичку где этот набор меньше там на самом
деле он будет меньше там где присутствует переменная r у маномах ну значит он пройдет
пройдет пройдет уже можно заметить интересную закономерность что каждый раз когда мы
увеличиваем количество переменных соответствующим маноме то есть количество единиц наборе мы
прыгаем на 2 в степени это количество единиц и через этот прыжок записываем везде значение
функции там у нас было 0 мы поэтому прыгали на сколько 2 степень 0 1 шаг здесь у нас одна
переменная это два степени 1 2 через два прыгаем наборы записывать значение и так далее это равняется
единице дак у нас 0 прыгаем через 2 пум-пум-пум-пум-пум ладно я наврал не через два прыгаем
все да я наврал такое бывает простите через два прыгать вот это все забили или сказал
здесь у меня ку вот ку куяр где у меня у меня здесь куяр еще здесь куяр здесь не только п здесь не
столько п здесь мне тоже п здесь у меня тоже п теперь пр у меня здесь единичка еще сюда единичку
дальше пыку ничка спор ничка все отчетное число единичек это 0 поэтому получили какой маном поехали
вот здесь единичка здесь здесь здесь и здесь р сор куэр сор да то есть получается и там смотрим
на пакуэр видим просто там ноль везде ставим нули потом смотрим на пакуэр видим что там
р равно единицы везде где р равна 1 и ставим типа сор значение в этой точке далее смотрим
пакуэр где ку равна единицы смотрим все где ку тоже равна единицы то есть получается
до куда мы дойдем таким образом да ну смотри мы так запол... сейчас вот мы максимальный набор
у нас 1 1 1 вот до сюда мы доходим все ну тогда вот мы просто берем шагаем вверх пока не
достигнем того то есть мы для каждого набора в общем мы берем все те которые больше равны чем
он да и в них дописываем вот сорем это значение вот это ровно то что раз написано справа все мета
суммирования очень хорош тем что мы поняли что первое что значение что коэффициент
свободный член пареного Жигалкина я сделаю вот таким каким-нибудь нужно выделить прям свойство
сразу первое свободный член свободный член свободный член пареного Жигалкина будет
равняться чему дайте посмотрите метод суммирования что он сказал
это в точности равняется f от всех нулей дальше второе
маном коэффициент при маном x1 тогда xn он будет чему равняться
ну смотрите он соответствует набору всех единиц какие наборы меньше набора всех единиц да все
какие угодно значит значи значи коэффициент маном x1 тогда xn будет равняться просто к сору
всех значений на всех наборах и считай и считай сам этот набор да и конечно да каждый каждый
короче у нас порядок порядок рефлексивный поэтому каждый набор не больше самого себя то есть мы
каждый набор к сориум со значениями которые в этом наборе ну да вот смотри я записываю
вот они они всегда присутствует нас перцент приманоме и ксинта вернется и
но доль ссор так далее ссор f от один тогда вяде все просто проксорили про всех важно отсюда
сделаем какой выбор к ссор у нас было что сложение по модуль 2 что если f принимает единицу
нечетное число раз то он есть то есть ходит в поляном жигалкина четная не входит зачем
это нужно это нам дает хорошие хорошие достаточные условия того что поляном жигалкина функции
будь нелинейным напомним что такое линейность линейность в обычной алгебре была когда у нас
степень хождение каждой переменной равнялась единицам тогда у нас линейная на член
я тебе скажу
пареном же галкина линейн тире
степень хождение сейчас дайте скажу его степень не превосходит единицей причем как мы
определяем степень паренома дек паренома жигалкина равняется максимально 8 и и степеней
манома жигалкина где маном жигалкина степень количество переменных ну на самом деле да мы
вот там переменные как мы говорили в какой-то степени мы такие случаи сразу отбросили потому
что бред какой-то и не имеется тогда поляном жигалкина линейн есть его степень меньше
единиц и сразу записываем до достаточно условия линейности паренома жигалкина
ду это достаточно условия уже наверное достаточно условия необходимые условия
из мотонализа должны были как-то запомнить до линейности паренома жигалкина ф принимает
единицу сколько раз он должен не войти пареном из xн так далее x1 так далее xn принимает
единицу четное число раз причем f тире не менее чем бинарная функция то есть для
унарные функции которые имеют аргумент только один ну от того что войдет маном x1 она линейность
не потеряет мы в целом да для унарных функций говорить о нелинейности вообще как-то странно
не все линиями хорошо это важно помните мы это будем использовать дальше так в целом на это
блок пар полянома жигалкина все по нему есть вопросы если прос про достаточно условия я не
понимаю почему я понимаю почему типа при четном числе единиц у нас последний не войдет
недостаточные условия это необходимые условия да необходимо спасибо да потому что достаточно
у нас говорит что достаточно говорить что если она выполнена то это точно так а необходимое
слове говорит что если это не выполнено то это точно не так так что это у нас необходимо
слово то есть если она принять нечетный раз то она точно не линейна все так что да мы определяем
не линейность мы определяем не линейность в общем еще по полянома жигалкина есть какие-то
вопросы может там замечание еще где-то наложил но видимо нету теперь мы переходим к
а можете пожалуйста все-таки еще раз показать на примере вот тот том который мы посчитали вот
как мы по условиям понимаем что он не линейный смотри метод суммирования заключается в чем что
у нас есть формула коэффициента при соответствующем наборе из переменных и она говорит о том что это
ссор значений функции на всех наборов которые меньше заданного причем меньше в смысле порядка
заданного декартом произведением то есть каждая координата должна быть меньше тогда
мы смотрим на набор на набор который соответствует моному x1 тогда xn это набор из всех единиц тогда
если этот набор состоит из всех единиц какие наборы меньше его его все наборы меньше его
потому что один это максимальное значение а значит коэффициент при нем это есть точности
ссор всех значений функций а смысл коэффициентов заключается в чем что мы берем этот набор или
не берем мы берем этот моном или не берем если единица то берем 0 не берем значит когда мы
возьмем когда ссор всех значений функции равняется единице а ссор сам по себе это было
свойство что ссор это сложение по модулю 2 когда сложение по модулю 2 из нулей единиц
равняется единице когда количество единиц нечетно вот отсюда это взялось да а почему
линейно получается если у нас кер не входит а смотри мы мы не говорим что она будет линейно
необходимые условия как работает она говорит что если то условие не выполнено то функции точно
не обладает этим свойством все да я поняла спасибо это недостаточные условия достаточно это
тоже периодически полт необходимой достаточной ссоре это необходимо здесь начинаем говорить про
про классы функций поехали начинаем с того что такое композиция функций
f и g
как мы обозначаем композицию это f кружочек или f композиция g от x1 тогда
это есть скажем так давайте я вектор уже никого не пугают
если пугать значит будем бороться со страхом же у нас будет функция из 0 1 0 1 м то есть что
такое функция же она берет n аргументов и выплевывает м аргументов по-хорошему это
записывается как тогда же это есть вот такой вот вектор g 1 так далее g m
где все же и ты живу прошу не сейчас но основной зарядку
же это живет у нас она принимает 0 1 и возвращает 0 1 то есть же само по себе это просто обычная
и нарная же это обычная же и нарная более функции можно просто да тут написано из
0 1 степени в 0 1 с какой степени я а откуда буква им взялась но это я вот определяю так
сейчас функцию не говорю что вот пожалуйста рассмотрим что такое же же это функция которая
из степени n степень им действует то есть она каждому набору
короче каждой последовательности 0 единиц длины n сопоставляет какую-то последовательность 0 единиц
длины n м да вот это то же самое что же это вот есть такой вектор с функцией g 1 так далее
же на самом деле даже не так не оно так так как такие называются функции
они называются сейчас по-хорошему такие функции называются матрицами
извините там а там вот же это там не вместо нет смотри она примет что каждая функция себя примет
она вернет 0 1 но их всего m штук и тогда что делает же же просто вернет ровно то что вернула
то есть мы как бы подаем вот какой-то последовательности z 0 единиц дальше я прошу
g 1 так далее же верни мне просто 0 единицу и она мне вернет нужную координату просто просто
для уточнения получается f это м арная функция же это м арная же сама по себе ну она немножко
не является буря функций в том смысле которым определяли она такая а же это что ли проектора
нет нет же это просто и нарные буря функции окей а я вы действует из м в что 0 1 м это обычная
м арная буря функция же к сожалению давайте на нее смотреть просто как на набор из м бинарных
функций понял почему я говорил про матрица смотрите как работала и в м сейчас же как
действовала она брало n выплевывала и я вперед м выплевывает 1 поэтому композиция работает следующим
образом вот эти должны совпадать и тогда мы из n из последовательств длины n выплениваем
последовательств длины 1 и тогда вот эта штучка на аргументах x 1 x и он означает что что мы взяли
f от g x 1 тогда xn то есть по сути мы посчитали же потом это то что мот анализ называл сложной функцией
вот как правило мы будем просто жить на чем нет мы все равно все равно мы будем просто мы будем
использовать несколько функций подавать их на вход другой функции например мы можем сказать что такое
функция x 1 или x 2 конъюнция x 1 играете x 42 вот такая вот штучка по сути это композиция функции
конъюнции и дизъюнции xr вот это была f это f жух вот это же вот это же первое вот это же второе
да немножко не совсем приятные ну и вообще когда мы говорили про матрицы почему матрицы
почему откуда они взялись у нас была штучка g 1 тогда gm что такое мы подали значение x 1 тогда xn вот
мы записываем к обысковых по сути это просто напоминает строку нам давайте осмотрим это как
строку 1 тогда xr тогда когда мы применим мы что как работает умножение строки на столбец
столбца на строку да мы просто берем и сейчас это 1 на n это
ладно я не буду это рассказывать тоже гинейная алгебра которая пока мы не рассказывали я сейчас
не подберу просто долго буду тратить время на этом ну умножаем матрицы грубо говоря что у нас вот
есть раз матрица g 1 тогда gm у нас есть поддали ей аргумент x 1 мы перемножили матрицы получим
матрицу которая будет m столбцов дальше эту матрицу z m столбцов поддали f и f умеет эту
матрицу z m столбцов превращать в 1 столбец и всегда у нас все я понял как мы будем делать наверное
все-таки g 1 тогда gm дальше у нас есть x 1 тогда xm мы перемножили здесь получилось высчитали
значение это будет g 1 тогда g от x 1 тогда xm теперь вот этот вот вектор мы поддали f кире это превратилось
в f от g 1 тогда gm на самом деле когда мы говорим про функцию мы сейчас про вот такие вот функции
мы их можем как-то представить в виде виде матрицы с какими-то коэффициентами из того
пространства в котором она живет у нас например пространство это пространство 0 единиц будет
матрица из 0 единиц мы умножили на столбец из 0 единиц получили новый столбец из 0 единиц и
потом их тоже такая матрица мы перевножили только матрица размера ст 1 получается строка
строка из 0 единиц переножили их получили число это все работает так но можете этим не задуматься
чуть позже поймете как это связано с просто сильнее на алгебре можно точить да можете много
вверх пытать сейчас вот на том месте где x 1 или x 2 умножить на вот эту штуку равняется 1 вот
это если честно не очень понял x 1 еще раз x 1 или x 2 и в скобках x 1 42 ну смотри это вот как
раз пример того что есть композиции функции вот наверху меня функция f все да да все исполнил да
можете так и вниз немного до это я понял вот с этим объяснением том где мы берем g 1
до gм ты и умножаем на x 1 декса до x н ты мы ждать до x н ты должны умножать а вы им написали
кажется молодец да получается типа мы и вниз тогда даже м ты да нет просто перепутал
координаты все вот сейчас тогда я понимаю то есть мы для каждой же 1 берем все эти и
потом берем все эти и для f уже берем вот эти все значения да ну окей понятно только
стрелочку типа нарисовали ну да да на самом деле просто же такая каждая функция
какая-то строка например как можно превратить функцию строку помните мы вы мы делали по
линомы же галкина вот мы можем взять по линомы же галкина и просто сопоставить строке коэффициенты
вот прям при этих наборах и превратить даже не так все мы просто вычислили значение функции
наборах 0 1 2 3 и сопоставили строке ее значение вот у нас получилось своего рода кодирование
строки а потом дальше когда вы вычисляете звучит как то что просто надо нет там чуть
более сложно кодирование но глобально она вы того при смену стал что мы просто строке
сопоставили функции сопоставили строку из 0 единиц такую что вот мы просто умножаем на это
добро можем вычислить я даже умножение так у нас есть умножение умножение так они
у нас сложение таксор не на смысл когда мы же один умножаем на вот эту на стол 5 из
мы же умножаем не в прямом смысле ну да конечно ладно давайте пока забудем про это добро
у меня одного изображения пропало нет у меня тоже пропало
и с экран просто гаса гугл перестает
все-таки хотел спросить но-то насчет формулы икс один из юнце икс два и икс один икс сор икс два
вот это конъюнция это вот функции которые вы подадим что-то нам нужно подать два
аргумента конъюнция значит же будет состоять из каких-то двух функций 1 2 1 пойдет на первый
аргумент вторая пойдет на второй аргумент первая функция же первая это что же первая это у нас
точности дизюнция же второе это ксор поняла в таком случае мы получим что-то вроде матрицы
потом уже применяя к ней функцию f получим значение либо 0 либо 1 да вот это как раз то что
хотел объяснить что каждая в общем каждую функцию если мы выберем базис мы можем эту функцию
в базисе задать какой-то строкой соответственно икс 1 тогда икс н у нас будут в этом базисе
0 или 1 поэтому это будет столбец строка это ой функции это строка строка умножить на столбец
это число поэтому что мы можем мы здесь когда перемножаем столбец из функций мы получим
сейчас мы переносим когда мы перемножим столбец из функций который на самом деле строки то есть
какую-то матрицу размера n нет размера m на n умножим на столбец из m то есть матрицу размерности
n умножить на 1 мы получим новый столбец но только он будет размерности n m на 1 тогда функция f это
строка раз строка размера m то есть матрица размера 1 на m на выходе при перемножении строки на
столбец получим просто число вот глобально это работает так вообще на этом будет построен вот
дальше весь инал что каждую функцию мы превращаем строку аргументы функции становится столбцом и
вычисления значения функции это просто перемножение строки на столбец да а функции которые выдают
несколько значений это вот такой столбец из функции то есть матрица размерности m на n где
n размерность каждой функции m количество всего таких функций вот в общем надеюсь композиции плюс
минус понятно отчасти по ботовый инал поэтому давайте говорить про композицию n уровня
давайте сначала сразу скажем класс более функции классом более функции будем называть
какое-то множество тогда теперь композиция
n уровня
для класса пушевых функций назовем луку что это такое
определяем мы как принято в матологе по индукциям когда мы определяем по индукции нам нужно указать
какую-то базу базу какую это натуральное число самое маленькое натуральное число это 0 соответственно
нулевой уровень это множество всех проекторов
проектор через е или через и пишется кто помнит е вроде бы е
в случае если это ошибка будет не моя твоя все мы тебя запомнили вот это множество всех
проекторов тогда если мы знаем проекцию n-1 уровня то это уровень мы получим каким образом мы
просто возьмем множество всех возможных композиций
пункции из q и n-1 уровня
ну например просто давайте поймем что такое первый уровень первый уровень это мы берем
всевозможные композиции функции ску и проекторов проектор сам по себе это функция вида взяли x1
тогда xn просто вернули координату тогда что мы можем положить в какую-то функции ску если
на себе просто проекторов мы получим в точности все элементы ску плюс извините
кажется в определении должно быть и всех уровней которые меньше и равны чем n-1
ну да да спасибо из не больше чем с первого уровня вот так напишем ну хотя
ну смотри я могу сказать почему достаточно писать n-1 уровня потому что давай возьмем
проектор в него подадим на нужной координате функцию из n-2 уровня и получается эта функция
просто войдет в уровень дальше если мы какую-то функцию положили каждый следующий класс она вот так
вот войдет сейчас если честно не очень понял еще типа мы берем функции иску и ну давай посмотрим
что такое просто первый уровень как мы будем писать проектор проектор можно писать там можно
писать проектор и ты и x1 тогда xn давайте я буду писать не так я буду обозначать следующим
образом я буду говорить что это x и t и буду ставить там давайте что нет можно подумать
давайте буду ставить буду ставить крышку над эксцитом вот эта штучка это проектор по сути на самом
деле это просто эксцитой мы просто мы взяли его из xn поэтому если мы взяли функцию скул там
какая-то ку принадлежит ку пусть это ку это инарная функция тогда как мне получить функцию ку я просто
возьму x1 проектор тогда или xn вот это есть она и совпадет с ним ну да да поэтому например в
композицию первого уровня для класса более функции ку в него войдет все ку правда ли что-то будет
равно этом классу то есть будет ли в обратную сторону вложения но я скажу сразу нет то есть
ку вложена в первый уровень в обратную сторону не обязательно рассмотрим такой
класс класс из импликации первый уровень это все возможные проекторы тогда второй
ой тогда первый это нулевой уровень все возможные проекторы первый уровень это что это от x1 может
она у нас быть от x2 а также я могу что сделать я могу подать наоборот x2 x1 поменять местами
проекторами а если я меняю местами проекторам ты получаешь на самом деле уже другую функцию потому
что у них разный вектор значений то есть например первый уровень у нее будет это что это будет
импликация в одну сторону импликация в другую сторону ну и что еще туда обязательно войдет у меня
был x1 он принимает там сколько аргументов два аргумента вот я возьму потом сюда x1 x2 это в
точности будет x1 так что еще сюда у меня безусловно войдет x1 x2 и в принципе любой произвольный
уровень будет вложен следующий потому что мы возьмем x1 дальше у него подсунем нужную функцию а дальше
все просто захламим каким-то каким-то чудом ну пусть будет x2 тогда x1 просто захламили даже можно просто
до проекторов натыкать потому что проектора там дальше есть все и эта штука даст вот эти скажу
что таку это есть точностеку и мы таким образом просто пододвинули функцию с более нижнего уровня
композиции в более верхней сохранить не очень понимаю как бы я не понимаю что здесь как бы
происходит потому что ну я просто помню на примере допустим если у нас есть функции и или да или еще
какое-то множество функций то на первом уровне мы просто берем допустим у нас есть функция двух
аргументов давайте рассмотрим аргумент тип такие функции дизюнция конъюнция вот и отрицание вот и
допустим у нас есть скольптам твой пример конъюнция дизюнция отрицание очень плохой
почему потому что потому что короче тот пример который ты привел он может представить
абсолютно любую функцию ну ладно давайте конъюнция дизюнция конъюнция дизюнция сейчас скажу конъюнция
ну пересечение классов варям да да ну вот и на первом уровне тогда и допустим у нас есть три
аргумента тогда на первом уровне это будет типа x1 конъюнция x2 ну и так далее и к 2 конъюнция x3
x3 конъюнция x1 или x1 дизюнция x2 x2 дизюнция x3 или x1 дизюнция x3 всего 6 таких штук вот но на
3 на самом деле нет еще помимо этого всего там обязательно будут проекторы потому что возьму
в проектор подам другие проекторы я получу проектор каждый уровень будет содержать предыдущий
поэтому проектор лежат в абсолютно любом уровне вложенности так что там уже не получится просто
только конъюнция дизюнция просто помню нам это по-другому объясняли нам объясняли то что как бы
это не подвигается на один уровень они все распределены по уровням то есть как нам на лекции
объясняли что на первом уровне ну ладно окей хорошо то есть мы говорим что у нас проектор это
такая в общем вспомогательная функция которая с прошлого берет какую-то функцию и двигает ее
на следующий уровень то есть типа но в общем я понимаю но это да да все я кажется понимаю супер то
есть глобально вот про это продвижение это продвижение части нам нужно чтобы смотреть как друг
другом класс вот потом будем говорить про то что есть замкнутые классы как между собой
замкнутые классы будут вложены поэтому например класс проекторов он очевидно вложен в произвольный
другой класс замкнутый замкнутый мы сейчас попозже покажем что это не но это судя из того что вы
говорите проектор они включены в любой класс функции нет все три класс функции это просто
произвольное множество да если произвольная функции произвольное множество функций то я могу
туда не положить прайпер да но тогда как мы будем передвигать на следующий уровень а мы сейчас
говорим про композицию одного уровня то есть когда мы берем функции и пытаемся друг с другом
их на комбинировать в плане в том чтобы смотри если у нас были функции какие-то вот изначально ну
пусть тоже конюнция дизюнция еще что-то у нас еще на самом деле есть где-то проекторы лежат
хорошие они правильность x1 xn на самом деле проекторов столько же сколько переменных
переменных как мы поняли мы просили счетное число проекторов счетная и мы берем пытаемся это как-то
накомбинировать то есть просто получить новую функцию просто подав функцию какие-то другие всем
возможными способами в этом смысл перехода на новый уровень просто пытаемся но вот вы говорите
проектор используется значит везде это везде где класс функции является супер позиции какого-то
уровня а у нас не любой класс является супер позиции какого-то может это пример где у нас
проекторы не будут использоваться ну вот я возьму просто множество из инкликации это является
классом були функции потому что это какое-то множество но не является супер позиции почему ну
потому что как минимум здесь нет проекторов как максимум даже если мы попросим первый уровень
сказав что давайте проектор и мы оставим ну ревом уровень будем тянуть дальше там какой-нибудь там
возьмем определение что давайте эти штуки будут лежать сейчас скажу это штуки будут лежать в
минимальном уровне в котором они встретились только новые добавим уберем дубляж тогда не будем
протаскивать вверх не будет хватать аппарат инкликации а в чем разница между композицией
уровней супер позиции на уровне ничем просто это новичное название композиции супер позиции
сложная функция это все просто разные названия одного и того же но смотри помнишь мы даже что
сказали что это такое это просто мы и взяли а джи текс один тогда риэсэн это вот чисто как
анализе была сложная функция ничего нового
дайте смотреть и замыкание класса будет
ну опять же смотри вот на глобально нам на композиции на уровне мы можем встретить
как нам может всех возможных композиций функции на самом деле посмотрели что в таком
определении нам не обязательным предыдущий уровень и потому что эти функции перейдут в
более высокий уровень а можно сказать что давайте мы минимальный минимальный уровень в котором не
встретились вот они там останутся дальше не будут перетекать вверх ну окей тогда просто
потребуем что композицию с не больше чем анализ первого нет нормально ничего не изменилось
на данной лекции нам и не так сказали ну тогда тогда есть претензии тому как
формально определено то потому что если формально говорим что всех возможных суперпозиции то не
прорезать если не всех возможных то вот тогда уже другое определение возможно кстати по
душу в чате про это по этому поводу сделать это давайте поговорим за прозамыканием
просто бурю функции обозначается на следующим образом
с квадратных скобках к у вас бурю функцию к
это объединили всех
объединения композиции цельку всех уровней
то есть туда положили нулевой 1 2 и так далее вот теперь замкнутые классы
говорим что к замкнут
если его замыкание совпадает с ним
то есть в чем смысл за до классов бурю функции
в том что мы попытались взяли какой то в чем смысл в принципе замыкание класса в том что мы
взяли сейчас скажу взяли сейчас один момент взяли какой то стартовый набор более функции а дальше
попытались при помощи этих более функции выразить все возможные другие функции вот все что мы можем
только выразить это есть замыкание класса дальше может например какой-нибудь замкнутого класса множество
всех проекторов как-то комбинатор не будешь комбинировать ты получишь все равно какой-то
проектор поэтому вот или например еще проще какой класс замкнут например пустой класс когда
ни одна функция не вошла очень глупые примеры когда на пустой множество да никаких функций нету
поэтому ничего накомбинировать не можешь хотя сейчас композиции там все равно проекторы будут
поэтому композиция нулевого уровня это множество всех проекторов
поэтому помним что из этого следует что наш класс может быть зам необходимые условия зам
необходимые условия замкнуть типа мы для пустого класса берем все равно проекторы от каких-то
иксов да поэтому у нас не получается в него входит все проекторы если у него не вошли то нулевой
уровень композиции будет уже содержать какой-то проекта которого нет соответственно замыкание
не будет содержать этого дальше что хороший пример на завтра это множество всех функций если
назначально появилась множество всех функций то как их не комбинирует и получишь какую-то
функцию с этого всего множество потому что это уже множество всех функций это не множество всех
множество поэтому такое можно давайте некоторые свойства замыкания
можно какой-нибудь более сложный пример там где типа мы используем хотя бы одну
нормальную функцию он является замкнутым сложный функции где мы используем хотя бы там не знаю и
дизюнкты или конъюнкты или хотя бы что-нибудь такое просто непонятно может быть я просто не
хочу понять как это применяется функции сохраняющие 0 то есть те функции которые на наборе из нулей дают
ноль ну смотри есть у нас например но понятно что все проекторы будут подходить сюда потому что
но проектор на всех нулях это значит какого-то переменной какой-то компоненты она будет
обязательно ноль все проекторы сюда вошли так что уже необходимо свой выполнено дальше давай
посмотрим что есть во всем композицию несколько функций если у нас изначально были же и ты они
сохраняли что они сохранили они сохраняли но сохраняли 0 то тогда если мы подадим им
7 0 то они вернут 0 а значит если еще f сохраняла 0 она получит на вход только нули то она тоже
вернет 0 значит композиции тоже будет 0 для произвольных f и жеитых значит композиция
тоже будет сохраняющий но дальше я хочу уточнить еще f и g это все жеитые это получается функции
которые мы берем иску и все f это тоже которые мы берем иску да все возможные типа да так что
там тоже все супер ну и так далее аналогично с сохранением нуля работает сохранение единицы
вот вам примеры функции которые которые это уже не все функции но уже какие-то такие не
тривиальный пример дальше будут у нас мы отдельно посмотрим еще замкнутость самодольственных
линейных или афинных и монотонных это тоже вопрос еще да а вот у нас же получается что все функции
иску одинаковое количество аргументов не обязательно я могу в куб засунуть там функции
различного количества аргументов ну например конъюнция дезюнция и отрицание отрицание у нас
унарная конъюнция дезюнция бинарная мы говорим что всех возможных композиций то есть вот постараемся
засунуть столько аргументов сколько возможно а если невозможно то ну невозможно ну просто
только возможные способы окей так дайте про свойства замыкания но первый очевидный
свойства по которым прогрели что обязательно множество всех проекторов войдет множество всех
проекторов хорошо дальше второе очевидное свойство что если что просто куба идет сюда
третий это уже не очевидный свойство что если куба множество и это какие-то
классы более функции то из замыкания будут сохранять вложенность
извините можно вопрос сейчас куб это уже это же у нас множество функций типа там не
подразумевается то что мы берем какие-то аргументы то есть это типа функции просто
как функции типа если у нас есть функции к сор и дизюнкция то просто говорим 40 дизюнкция а
когда мы говорим про супер позиция мы указываем какие переменные мы туда кладем типа x1 x2
но мы говорим что них вот смотри здесь я явно еще нигде не писал специально вот никакие аргументы
вот только здесь где проектор оказался такой проектор я кладу проектор этой координаты то есть
это функция которая возьмет n аргументов и вернет не первый
окей ну ладно хорошо то есть на самом деле да это функции я везде вот специально писал что я
подаю функцию функцию я нигде не писал что это какие-то x1 pvxn у меня только проекторы я вот
подал сказал что пожалуйста давайте мы если я хочу сохранить саму по себе функцию я в нее
насыплю проекторов окей понятно тогда вот дальше у меня есть вложенность и четвертые свойства это
то что называется идомпатентность что если мы один раз все накомбинировали то пытаясь комбинировать
уже всевозможные комбинации между собой мы ничего нового не накомбинировали интуитивно
понятные правила дальше по аналогии запустью мы скажем полный класс
был функций это такое что его замыкание совпадает с множеством всех функций
я пишу класс класса всех булю функций
ну и тогда у нас есть такая штука как критерий
полноты поста что он гласит
куполный тогда я только тогда когда эти тогда и только тогда когда первая
ку не вложен в 0 2 ку не вложен в 1 3 ку не вложен в совдол ку не вложен в афин и 5 ку не вложен
все поехали теперь еще раз можем что еще раз а это линейные функции у вас вот я
сейчас все скажу что такое по ноль пойдем так далее поехали по ноль сохраняющий 0
полный класс б это имеется в виду типа полный класс для булевых функций то есть
ку это уже булевые функции ну полный класс булевых функций это класс булевых функций
которые дается полно то есть мы говорим по полноту булевых для булевых функций
да да к этой полноты булевых он кутейли полноты поста для булевых функций сохраняет 0 значит на
значение всех нулей это 0 п 1 сохраняет единицу это f от всех единиц равняется 1 дальше д по
английский совдол само двойственные что значит самодвойственные что дайте скажу так f от x 1
т.д. x н равняется не f от не x 1 т.д. не x как понять что функция сохраняющая 0 сохраняющий единицу
очевидно просто смотрим в таблице истинности на первую и последнюю строку самодвойственные
смотрим таблицу истинности от нас там делим ее пополам прям она всегда делится пополам потому
что у нас количество строка то есть какая-то степень двойки и смотрим что что наборы
симметрично относительно серединки должны принимать различные значения не совпадают
почему это так потому что наборы симметрично относительно середины это есть наборы которые
мы по компонентно инвертировали значение это в точности просто свойство в рамках таблицы
истинности такой вот радугой дальше а а можно пример какой-нибудь пожалуйста извините наоборот
если они не совпадают то получается что сейчас если они совпадают то она как раз
ки получается не является самодвойственной да а мы говорим что не совпадает значит на самодвойственное
давай я сделаю только можем пример да да вот побольше спасибо вот я возьму дайте что функцию
там 0 1 1 0 1 1 1 1 жух беру делу телю пополам таблицейственности а теперь смотрю на вот
такие вот наборы симметрично относительно серединки 0 1 у меня не совпали а вот один один
совпали поэтому эта функция не самодвойственная например если я возьму испорчу это и скажу что
пожалуйста будь нулём то функции станет вполне себе самодвойственной например один искусство
самодвойственных функций что нам на самом деле не нужно сохранять весь ее массив значений нам
нужно сохранить лишь первую половину его в этом так вот оптимизация то есть поле 1 и 1 0 это одно
и тоже если совпадает то нечетная самодвойственная да если совпало то это не самое я имею
в виду 0 1 и 1 0 это рабочая тема 0 1 1 0 да это самодвойственная они все не совпали
симметричные поэтому всего а это класс афинных или не или линейных афинные ли не
если бы там было 0 1 1 0 то они бы совпали значит это не самодвойственная не не самодвойственная
это не самодвойственная линейные могут еще обозначать их как и
аналогично самодвойственные д это долл но по-английски это все в дуле могут еще обозначать
как я буду значать здесь д возможно иногда кстати мне будет переклинивать на с афинные это
а также можно означать л от слова линейные ну откуда что то что сейчас на какие мысли
налевать на понятие линейность это как раз линейность по дому жигалкина поэтому это все у кого
по дому жигалкина линейный дальше стать я сейчас вспомнил про по дому жигалкина когда спрашивали
про минимальность даже на экзамене будет один из билетов заключается в том что каждый функции
соответствует единственной по дому жигалкина поэтому там без вариантов просто только один
по дому жигалкин задает одну функцию и наоборот там минимизировать нечего и это монотонные
что это значит что f от x1 т.д.xн должно не превосходить от f y1 т.д.yн если x1 т.д.xn
y1 т.д.yн порядок мы помним порядок декартов монотонность прям в точности как обычная
монотонность функции только тогда у нас были чисто мы говорили что чисто больше теперь у нас
такие вектора из 0 единиц и если у нас появилась класс более функций на такой множество причем
хорошие то мы можем сказать про базис класса
базис класса класса более функций
это класс как назовем базис давайте назовем базис буквы b такое что первое замыкание
дает нам кум то есть мы можем при помощи функции с класса b выразить произвольную функцию с класса
кум и второе что для любого b штрих под множество такого что не равно b выполнено что замыкание
b штрих не равняется кум только такая что теперь если мы выкинем какую-то функцию из класса из
выкинем какую-то функцию из базиса то мы потеряем выразимость некоторых функций с кум
все табарны на этом теория вся давайте вопрос о теории это когда ты ее скребу
один вопрос их нет поэтому будем прямо сейчас решать
все хорошо итак у нас есть многочлен же галкина для функции от хотя бы двух
переменных то есть почему мы смотрим на двух переменных хотя бы потому что у нас может
появиться нелинейность для одной переменной все слишком скучно и выберите утверждение
мы содержит слагаем один тогда и только тогда когда на всех нулях это один правда это или нет
кто помнит мне кажется да да мы прям если посмотрим сейчас когда мы говорили про пареном
же галкина бум бум бум бум бум это было давно же галкина первые вот свободный член это в
точности значение на всех нулях то есть если значение на всех нулях один у нас будет свободно
член один если на всех нулях будет но то получим 0 1 не получим все слагаем мы короче маном из
всех переменных тогда и только тогда когда значение на всех единицах это один правда ли это
нет нет нет правильно это неверно потому что давайте мы скажем что на всех единицах будет
один а где-нибудь оставшееся нечетное число этих штук мы доберем нет нам ведь достаточно
подождите нам достаточно условий чтобы существовал вот эта штука то чтобы у нас было просто нечетное
число единиц в итоге чтобы существовало да это даже не просто для существования вот этого манома
это необходимые достаточное оно для для для для линейности такая штука получается нам если мы
говорим что если здесь единицы мы хотим попросить чтобы пожалуйста можно тогда я в п1 пн сейчас
п1 пн не существовало но функции принимал на всех единицах один тогда мне нужно просто добить
дочетного числа единиц и ее значениях и это могу спокойно раскидать по другим наборам все возьму
какой-нибудь еще один набор туда поставлю единица все остальное 0 вот у меня будет функции на всех
единицах один но при этом содержать такого слагаемого не будет в смысле тут уже очень
просто рассуждение просто говорим у нас может быть такой пример то что нас нечетное количество
единиц при этом f от всех единиц равно ну или так ну просто с разных сторон смотрим в кидах
п содержит слагаемое один тогда только тогда когда f на всех нулях ну и ну очевидно это противоречит
пункту а который мы сказали что верно поэтому скип п содержит слагаемое п1 тогда или пн тогда только
тогда когда на всех единицах 0 но тут работает то что я сказал что давайте возьмем на всех единицах
один какой-то еще набор на нем будет один а нет нет мы просто возьмем функцию которая только на
единицах равняется единицей остальные 0 этой мерной конъюнции не будет содержаться вот это добро
но при этом на единицах она не 0 поэтому неверно вот как раз прекрасный пример когда написано
выберите верное утверждение оно одно поэтому внимательно а можете пожалуйста пояснить еще
раз почему бы это неверное почему бы это неверно смотри я возьму функцию здесь сейчас мы говорили
когда у нас существует такой маном критерии его и он существует тогда и только тогда когда
функция f принимает нечетное число раз единицы вот я возьму здесь единицу на этом наборе я возьму
функцию на наборе давайте как он на всех нулях тоже будет единица она всех остальных наборах у меня
будет 0 тогда она всего содержит четное число единиц а значит слагаемые п1 тогда для пн не
войдет в пыльном жигалке поняла то есть пыльном жигалки наслежит но вот п1 п2 пн только в
том случае если количество один нечетно да поняла спасибо теперь номер 15
какие свойства могут одновременно выполнить не сохраняет 0 но на то на нелинейно как это как с
этим жить как правило смотрим на таблицу истинности и понимаем может ли быть такое не сохраняет 0 это
как выглядит это вот нас из таблицы всех здесь набор всех нулей не сохраняет он значит здесь
единицы монотонно наборы все короче все наборы из нулей единиц они будут не меньше чем набор
из нулей и поэтому если на монотонно то значение должно быть не меньше чем единица значит будет
единицей значит на самом деле наша функция вот такая вот всех единиц вопрос будет ли она
линейной эта функция которую всегда принимает единица поэтому что функция единица а единица
в одном же балке начали на единицах поэтому она всегда линейно соответственно такого быть не
может смотрим на следующий номер из так у нас сохранение единиц сохранить сохранение нуля вот
нас набор из нулей из единиц сохраняет один значит на 1 1 не сохраняет 0 значит нулях она единица
самодвойственно дайте посмотрим вот у нас набор может быть такое не может быть она не
самодвойственно пункт вы а если бы сохраняла 0 то тогда была бы самодвойственно да тогда у
нас могут быть одновременно выполнено такое свойство там просто доберем оставшиеся набора
как нибудь по самодвойственности красивенько вот сейчас как раз у нас будет этот пример 1 1 на
нулях она сохраняет 0 на единицах сохраняет единицу она самодвойственно и линейно давайте я рассмотрю
функцию от двух переменных 0 1 1 0 1 1 я смотрю что пока я вот смотрите пока я смотрел у меня
ничего не нарушилось то есть самодвойственность мне пока есть линейность но я могу добрать до
четного числа единиц и поэтому меня не спортится вот я вот к необходимым условиям поэтому я пытаюсь
построить просто функцию которая хорошая как правило функции двух переменных достаточно
чтобы если он есть пример то вы найдете очень надеюсь что не по не получится так что специально
сейчас посмотрят это скажут что вот сказали про это давайте придумаем такой пример что он только
работает на трех перемен дальше все на совести составитель задачи раньше всегда все от двумя
функция для двух аргументов всегда работала в общем если в этом году не работает то это не
я виноват тогда пробуйте из трех здесь 0 здесь 1 нам нужно дать самодвойственности линейность
линейность значит мне нужно будет поставить что мне нужно сделать хотя бы четное число ну
четное какими сделаю значит нужно расставить только одну единицу сюда ну давайте сделаю здесь
один тогда по самодвойственности это должно быть нырём что это за функции это функции проекта
первых координат и ее проектор его полиновом же галкин это в точности просто название этой
переменной то есть поэтому длиннее все супер такое может быть как вы еще раз так быстро пределили
поляном же галкину почему-то ну смотри 0 единицы это на что за функции она ведь совпадает просто
со со значениями поэтому это проектор а проектор просто это название с этой переменной и у нее
поляном же галкина вот как правило если надо там что-нибудь делать пробуйте выходить на какие-то
простые функции их проводить пример вот например на поляном же ой на проектор и уходит все супер
более того смотрите здесь не сказано что качество переменных должно быть больше одной поэтому
можно было попробовать просто одной переменной здесь на нулях единицах поиграться что за функция
здесь тоже выйдет проектор давайте смотреть линейная а тен больше одной переменной равна нулю на
нечетном числе наборов но мы помним что критерии ой необходимые условия линейности это то что
должна быть равна но сейчас равна единицы на четном числе наборы вопрос и как садить как
соотносятся четность количестве единиц и количества нулей в векторе функции колокольки
но они равны да потому что всего всего значение функции принимает два степени то есть четные
поэтому если одно четное то и другое четное если одно нечетное то и другое нечетное поэтому
если она равна нулю на четном наборе то и единицы на нечетном а дальше в максимальной степени
да значит нелинейно все по инну она нелинейна
вот здесь мы даже ничего не строили никакие из предыдущих но опять все мимо и опять у нас
чудные задания в котором какие а правильный только один поэтому
а можете пожалуйста еще раз объяснить как мы в первом пункте так быстро поняли что она линей
навсегда глянем смотри не сохраняет 0 значит на наборе всех нулей она единица монотонно смотри
один из таких свойств из аналогов того что можно говорить такой монотонность это если она на
каком-то наборе единица то и на всех наборах его больше она тоже единица да то есть везде
единица это понятно да а если функции везде принимает значение единица то это функция единица
в равно один а это значит что линейно да понятно спасибо да нет извините а можете
поесть еще раз необходимые условия просто почему она работает окей сейчас вернемся
сейчас я сделаю красивенькое бом бом бом бом бом смотри у нас то что коэффициент при
маноме x1 тогда xn принимал он есть если функция принимает один нечетный раз и отсутствует если
четные это понятно да супер тогда если у нас степень f и f более чем бинарно не менее чем
бинарно и она принимает один нечетный число раз то значит тогда в нее войдет полином ой в нее
войдет маном x1 тогда xn причем n у нас будет хотя бы двойкой значит у нас будет маном степени
больше чем не меньше чем два а значит она будет не линейна супер хорошо через замыкание какие из
этих свойств гарантирует что пересечение что замыкание пересечения равно пересечение замыкания
такие штук нам гарантируют
ну давайте для произволь для любых множеств уже интуитивно должно быть понятно что это не
должно работать просто перейдем пример ну например что я возьму например я возьму сюда что у меня
вот например есть классе функций я могу сказать что он является замыканием конъюнции дезюнции
инверсии потому что кнф днф и также он равняется замыканию ксор единица и что там конъюнция в этот
раз я буду выучать и ниц и ниц и они вот как в прошлый раз потому что чтобы не путать ст все у меня
вот такое получилось давайте просто просмотрим их их пересечение их замыкание это в точности
т а их собственное пересечение это просто функция конъюнции понятно что одной конъюнции мы не выразим
всевозможные функции почему ну например потому что функция ку сохраняет 0 а 0 это замкнутый
класс значит как бы мы ку не комбинировали она всегда будет сохранять вот как бы конъюнции мы
комбинировали она будет всегда сохранять 0 а функции не сохраняющие 0 она не выразить это кстати
одна из идей которая потом будет все не работает ку вложена можно очень быстро при чем здесь сохранение
нуля мы же поняли просто что их пересечение это просто дезюнции поэтому не работает но нам
нужно сказать почему одной конъюнции мы не выразимся функции вот как ты докажешь хорошее
доказательство этого то что мы скажем что вот там ку лежит в каком-то замкнутом классе а этот
замкнутый класс не является всем множеством множеством всех функций вот я говорю что например
например это что конъюнция сохраняет 0 а класс сохранения нуля он замкнутый поэтому чтобы мы
не выражали при помощи конъюнции будет сохранять но а значит мы не выразим все функции а справа
у нас будет как раз множество всех функций поэтому неверно сейчас если честно не очень понял на
же и без всех без сохранения нули все работает в общем это просто просто формально доказали
почему-то так не более чем на естественно на контроль на это все просто смотрится и
такой вижу пишу не доказывать вот ку вложено в эр у нас какие-то свойства но если ку вложено
в эр то пересечение куэр это что это ку супер соответственно слева мы имеем вот такую штуку
справа что у нас вот меняется куэр я знаю что тогда если ку вложено в эр то замыкание ку вложено
замыкание эр значит замыкание ку замыкание эр так как первое вложено во второе то это равняется в
точности своему первому ну и понятно что я вижу равенство ой да это гарантирует дальше я предлагаю
рассмотреть следующую штуку ты ну потом покажем почему так у нас есть прекрасные две штуки про
которые мы говорили это стрелка пирса и штрих шефера и их плюс в том что при помощи их мы
можем выразить абсолютно любую булил функцию и они являются базисом класса всех возможных функций
очевидно что что он получим в пересечении этих это пустое множество замыкание пусто множество
это множество всех проекторов а справа мы видим просто пересечение т и т но очевидно что это неверно
и ну мы видим что правда куэр сами не пересекаются поэтому вот все и у нас снова чудесный номер в
котором только спрашивают про какие а правильно ответ один погодите а как мы поняли что г это
неверно стрелка пирса штрих шефера являются базисом класса всех функций а поняла спасибо
большое сейчас и получается они не подходят потому что у нас их пересечение это пустое множество
получается и слева пустое множество и справа тоже пустой множество смотри во первых
замыкание пусто множество это может и вообще до справа все потому что каждое по отдельности
замыкание да вот можется функции пон weaving все3004 под investigatorvar composition
это все, а с левым получается пустое будет.
Ну не пустое, а множество всех крейкеров.
Да, множество всех крейкеров.
А вот еще хотел точнить
насчет там, где
насчет пункта В.
Пункта В.
Тут работает вот тот же
пример. Тот же пример, да?
Да, мы просто не примеры,
мы шили два одного мира. Понятно.
Про вот это вот
обязательно напомним. Короче, все
держится просто на том, что
мы помним, как
выразить класс всех функций.
Вот так вот можно,
вот так вот можно, можно вот так вот
дальше. На самом деле
можно будет выразить вот
так вот нам
и можно выразить
вот так вот.
Вот. Это нам
для кнф и днф,
но на самом деле там одна из этих
штук, она лишняя.
Это не
то есть она будет не базисом. Базисом
будет вот. Базисом у нас
раз, два, три, четыре, пять.
Давайте сразу их выпишем.
Базис и т.
Первое это у нас
конъюнция отрицания.
Второе
дизюнция отрицания.
Третье
конъюнция экссор
единица.
Четвертое
стрелка пирса.
Трешкой вы называете любую
бф?
Это множество всех возможных более функций.
Понял.
Хорошо.
Есть такая штука, есть такая штука.
Можете, пожалуйста, наполнить быстро,
как с помощью
этих мы выражаем
те.
Как при помощи этих выражаем?
Ну, с помощью третьего,
это просто мы вычислим отжигалки.
А с помощью там
первого, второго, четвертого. Я помню,
с помощью первого мы
хотим нам наполнить.
И второго, и четвертого, и пятого.
Третий полинов жигалки. Федос,
подумай сначала.
Ну, смотри, первый, второй
очень легко делается.
Для этого нам нужно просто при помощи
конъюнции и отрицания выразить
дизюнцию и наоборот.
Ну, что такое?
А или B?
Ну, смотри, это то же самое, что не A
или не B.
А дальше мы применяем закон домоордана.
Не, не A,
и не B.
Все.
Вот так вот я могу выразить
при помощи...
четвертого и пятого.
При помощи четвертого и пятого, смотри,
я не помню в точности что и что.
В общем,
вот эта штука,
это отрицание.
Дальше.
Ну, да.
А, B.
А, B.
А, A.
А, B.
Б. Аналогично для
стрелки...
для штриха шейфера.
Аналогично.
Короче, одно из них является дизюнции,
другое является конъюнции.
И что и что, в каждом случае я точно не помню.
Окей, все.
Извините, а
нет еще...
что выражать, мы научились даже.
Там привели в КНФ
ДНФ и даже
Тваринтич.
Давайте смотреть.
В паренном жигалке насчитаем в третий раз
или уже достаточно?
Ну, хуже не будет.
Ну, давай.
Не знаю, я бы уже пропустил.
Ну, если просят, то давайте в третий раз
посчитаем паренном жигалкина.
Никогда еще столько раз паренном жигалкина
не считали.
Что?
Писуем треугольник Паскалем.
Только ответа недостаточно,
нужно объяснить, как он получим.
Применяем
метод
треугольника Паскаля.
1 0 1
0 0
1 1 0
Поехали.
Соответственно, теперь выписываем,
какие здесь у нас соответствуют
мономы.
Смотрим на левую штучку.
Поехали. У меня есть раз, два, три, четыре.
То есть это вот этот вот.
И выписали его.
Спидран по решению
17 задачи готов.
Так, 18 скипаем.
В общем, дайте я проще скажу.
Что-то в вашем году решили
хардонуть.
Извините, можно очень быстро
учинить? Получается 16 ответ, только
B.
Да.
Пугаться то, что спрашивают,
какие у вас получилось один,
и вы точно в этом верите, не надо.
Просто люди не совсем
умеют корректно составить число.
Вот, короче.
Номер про 19.
Спрашивают какую-то функцию
от какого-то количества аргументов.
И просят
сказать, при каких N
она является какой.
Как решается этот номер? Смотрите,
как правило, там
0, 1, 2, 3.
Мы просто строим
таблицу истины для этой
булливой функции и прям явно выписываем.
А при больших значениях,
как правило, это просто какой-то там
будет.
А при больших значениях там всегда
выполняется одно и то же, просто
нужно заметить закономерность.
Почему так?
Потому что, ну, иначе
как вы еще решите?
Опять же, судя по тому, что
ребята сейчас с тренировочными вариантами
могут сделать так, что в этом году придется
строить таблицу истины для четырех.
И в целом, когда-то там был один номер,
в котором пришлось строить таблицу истины для
четырех аргументов, и смотреть, что там творится.
А для всех больших там уже
выполняется закономерность.
Поэтому ничего гарантировать не могу.
Поехали, смотрим.
Начинаем прям.
Почему только с трех начинаем?
Почему для, типа, двух не строим,
например?
Прямо от нуля до трех всегда.
Смотрим, вот n равняется 0.
Что такое функция, когда n равняется 0?
Если иди аргументов,
ровно два нуля.
Ну, понятно, что если у нас n равняется
0.1, у нас, в принципе,
не может быть два нуля, потому что
не наберется по числу.
Тогда эта функция – тождественный 0.
Точности дайте так.
Упор есть 0.
Тогда, что мы знаем про 0?
Дайте две нуля, начать им табличку.
Даже не будем чутить.
Две нуля.
0 очевидно сохраняет единицу.
Очевидно сохраняет 0,
но очевидно не сохраняет единицу.
Дальше.
Дальше.
0 монотонен,
но он всегда константа,
поэтому константа монотонна.
Он линейен,
да.
Он самодвоственен,
конечно же.
А вот самодвоственен, сейчас скажу.
Сейчас.
Так.
Когда один аргумент.
Смотрите, когда 0 аргументов,
у него
он просто дает одно значение.
Поэтому отрицания тех
штук, их просто нет,
поэтому он будет самодвоственен.
При n равном единице
у нас будет тоже 0.
Он точно так же будет
по 0, отсутствие по 1,
монотонен, афинин.
И он самодвоственен, конечно же, нет,
потому что 0 и 1
он всегда примет маль.
Смотрим, n равняется 2.
Чартим таблицу истинности.
Когда 2, 0?
2, 0.
Для уже знающих эта штука
называется стрелка пирса.
Стрелка пирса
она является
булил функцией.
Класс булил функции,
состоящий из одной стрелки пирса,
он у нас полный, а значит,
она не лежит ни в одном.
Извините, можно очень быстро учить?
А для n равного 1,
почему мы сказали, что там
равно 2, 0?
Это, типа, чтобы exec2n
было верно?
Смотри, n равна 1,
когда среди аргументов ровно 2, 0.
Когда n равняется 1, у нас, в принципе,
не может быть 2, 0, значит, у нас всегда 0.
Поэтому торжественный 0.
Торжественный 0 он всегда
не сохраняет 0, не сохраняет 1,
монотонен, афинин, а самодвоственен
он будет при 0 аргументов,
а при всех остальных он не самодвоственен.
Не понимаю определение,
она верна, если среди аргументов
ровно 2, 0, но
почему мы строим, типа,
именно для тех случаев, когда она верна?
Не понял.
Ну, я имею в виду,
почему не может быть другая таблица истинности?
Ну, потому что мы просто вычислили,
ну, вот мы взяли количество аргументов 1,
вычислили на каждом наборе аргументов
значение этой функции, все.
А, все, блин, понял.
Ну, просто вычислили
самую эту функцию.
Если вы не помните свойства
про...
О, что-то мы лагаем вообще.
Если вы не помните свойства про стрелку перса,
то прям можно подобреться истинности.
0 не сохранились, 1 не сохранились,
монотонность очевидно не
сохранилась, афининность
почему? Потому что у нас всего нечетное число.
Единиц в наборе,
сама двойственность тоже не сохранилась.
Все.
Дальше живем.
N равняется 3.
N равняется 3, у нас...
0, 0, 0, 1, 1, 1, 1,
0, 0, 1, 1, 1, 0, 0, 1, 1, 1,
0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1
Этот номер самый неприятный,
оставляйте его в конец, потому что
у него больше всего делать, и прикол в том,
что если вы не докажете
хоть одну...
Короче, если вы докажете про 0,
про один, про монотонность,
самодольность и провиневность нет,
у вас 0 задачу.
Очень неблагодарно, оставляем венец.
Нам нужен 2 нуля.
Вот, естественныйitations.
она сохраняет ноль, не сохраняет единицу, она не монотонна, будет ли она аффинна,
ну смотрите, всего у нас 3 таких штук, значит войдет MonomTot, поэтому она не аффинна,
самодовольственная ли она?
в порядке
не самодовольственная, смотри, в момент больше равняется ли 4
f на всех нулях будет равна чему? нулю, потому что количество нулей больше 2
поэтому она по 0
f на всех единицах равняется нулю, потому что здесь нулей равняется нулю
хорошо, так как мы видим здесь и здесь ноль, то следовательно она не самодовольственная
можно еще раз сказать, как мы довольно быстро понимаем, что функция не аффинна?
считаем количество единиц, которое принимает функция, если не четно, то она будет содержать Monom
из всех вот этих вот штук, из всех аргументов, он будет в степени больше, чем один, значит она не линейна
ну это же недостаточное условие, то есть если бы у нас совпало, что она единичка, то нам пришлось бы
для каждого проверять Monom, ну для каждого набора нуль единичек
ну смотри
ну в общем случае, да?
ну как правило, в общем, по вариантам прошлых ряд, я очень надеюсь, что сохраняю традицию, что
как правило, всегда не линейна
и все это можно легко доказать, просто показав, что функция принимает нечетное число единиц
а зачем мы отдельно 5 трех аргументов рассматривали, а потом для всего больше трех, мы не могли просто для всего больше еще 3?
могли
просто потому что начертили еще раз 3, еще раз поняли, что творится
мы поняли, что больше трех, вот например нули у нас будет сверху снизу, поэтому у нас сразу по ноль не по 1 и не D
а остальное, ну сейчас будем смотреть, ну понимаем, что вот где-то здесь мы заметили закономерность
как нам получать набор, который сломает нам монотонность
и аффинность нужно будет смотреть
на счет аффинности в обратную сторону работает, если четное число единиц, то она обязательно аффинна?
нет
ну вот
мы говорили, что это необходимо, но недостаточное
ну да, хорошо, я это так просто в всякий случай
поэтому если так получилось, что у вас не работает эта штука, как может сработать?
может сработать метод суммирования
метод суммирования говорит нам о чем, о том, что если вот здесь вот было в начале
обычной такой строчки, если у нас здесь было нечетное число единиц, вот среди первых четырех
то вот на этом мономе она будет принимать значение единицы
будет это на моном войдет, вот например 0.1.1
сейчас скажу
в таком случае вот как раз работает, когда
когда у нас 0, там 0, дальше 1
0, дальше 1, 0, 1, 0
здесь возможно где-то нулевое число нулей
вот такой набор берем
дальше смотрим какие функции примет значение на таких наборах
и тогда для вот этой вот штуки
коэффициент при соответствующем мономе будет просто к сору всех этих значений
по методу суммирования
то есть если здесь где-то встретилось только нечетное число единиц
соответственно мы получили плохой моном
она не линейная, это вот второй вариант как может использоваться
а можете еще раз объяснить как мы вот по линейности поняли когда у нас просто больше четырех
как мы выявили значение
здесь мы очень быстро поняли
просто сколько всего единиц в наборе значений f
их три штуки
да, но а вот когда мы говорим больше или равно четырем
мы же пока еще ничего не сказали
пока вообще ничего не сказали
мы знаем пока про p0, p1 и про d
вот теперь про монотонность мы поняли вот из этого набора
извините, можно уточнить?
да
сейчас вот последнее что вы сказали как понять что функция является
короче является она линейной или нет
если у нас просто по четности количества единиц нельзя сказать
то есть я вот этот шок не помню где мы сказали что
ну вот то что вы красным нарисовали
ну давай еще раз расскажу
в общем если тогда не так
то ну во-первых первое замечание
я пока не видел в принципе вариантов которые
в больших случаях она была линейной
всегда была нелинейность потому что нелинейность мы можем доказать
а доказать линейность это что-то очень сложное
и вряд ли вас будут просить на контрольный
нет, я понимаю, но я имею в виду доказать нелинейность
если у нас мы его не можем доказать
просто исходя из того что у нас нечетный единичек
тогда мы пытаемся найти вот такую комбинашку
выбираем две координаты когда они равняются единице
дальше смотрим значение функ
на ней на наборе в котором только одна единица есть вторая ноль
на котором другая единица и другая ноль
и на наборе всех нулей
тогда коэффициент при соответствующем маноме
то есть если это it это yt
то есть x it и x yt
коэффициент при ней есть сор четырех этих значений
если у нас получилось так что
среди этих значений ровно нечетный число единиц
то значит у нас войдет такой маном
значит у нас все испортилось
а почему это должно работать?
потому что по методу суммирования
прям просто пишете по методу суммирования
достаточно обоснований
потому что в методе суммирования
как мы работали?
мы брали просто все меньшие наборы
помните свойства
теперь я понял в чем суть
по методу суммирования
то есть на самом деле нам метод суммирования нужен
больше не для того чтобы находить пыльную обжигалки
надо оказывать нелинейность функций
в этом вопрос
ему нужно делать поэтому достаточно внимания
почему эта функция при n больше 4 не равняет 7?
смотрите какая штука я заметил
что если я по краям поставлю 0
то у меня функция будет равнять единице
а если я возьму потом
самую последнюю сделаю единицей
то у меня останется 0
и это нарушит монотонность
обобщил на большей размерности
получил не монотонность
просто беру по краям 0 все остальные единицы
тогда у меня ровно два нуля
поэтому функция принимает значение 1
если я сделаю только первый 0
этот набор больше его
но функция принимает значение меньше
следовательно не монотонно
подождите
а если мы возьмем просто первый и последний
там же у нас оба нуля
разве из этого не следует
то что не монотонно?
нет, не следует
не понял
монотонно это если у тебя есть
два набора
один больше другого
но функция приняла значение меньше
везде струйки
я понял
не строгая
хорошо
остался вопрос
про линейность
во-первых
давайте заметим
сколько у нас
значений единиц
количество единиц у нас ровно столько
сколько
из способов расставить два нуля
по компоненте z
поэтому
давайте делать как
сейчас
подумаю
сейчас подумаю
один момент
в общем первый вариант
мы можем посчитать сколько таких
наборов
это будет c из
n по
сколько
по два
количество
это
это у нас что?
это n факториал
на 2 факториал
на n минус 2 факториал
равняется n
на n минус 1 на 2
ну в общем как мы понимаем что
здесь например будет что?
равняется 4
если 1 кратно 4
то у нас все плохо и может
получиться четное число
значений единиц
поэтому не сработало
давайте такой способ не работает
значит мы действуем
по этому методу
подбираем такой набор
чтобы было количество единиц
нечетно на нем
под набор
я предлагаю поступить следующим образом
давайте рассмотрим набор
0011
функция на нем
принимает значение 1
все наборы меньше него содержат
нулей больше
0
значит функция
равняется 0
тогда здесь будут
нули
не здесь
тогда все оставшиеся
ксоры по методу суммирования
это будут 0
единиц здесь сколько?
ровно 1
следовательно
монум какой?
x3 и т.д.
xn войдет
смотрим
сколько всего переменных
среди x3 и xn
так как n больше равно 4
то
степень больше либо равна 2
следовательно
не афиген
вот именно поэтому рассматриваем
с 3
этот метод нам бы дал
капель
а можете еще раз повторить
осуждение?
первое что мы попробовали сделать
давайте посчитаем сколько
таких штук
я понял
что это просто способ
расставить 2 нуля по n координатам
это c с n по 2
c с n по 2 это n факториал
делить на 2 факториал делить на n-2 факториал
то есть n-1 на 2
вот если я возьму n кратную 4
то очевидно у меня здесь получится четно
значит
идея с необходимым условием
про количество
про четность количества единиц
принимаем у f не работает
следовательно единственный способ показать нелинейность
это искать такой набор
первый случай
когда мы искали набор
там было 2 мы брали единицы
чтобы было нечетно
здесь нам придется взять больше
я хочу взять
первый такой набор
на котором я получу 1
чтобы меньше его все возможные наборы были 0
тогда у меня всего единица 1
значит
я возьму такой
моном
состав пыльного жигалкина
давайте я взял такой набор
это 0,0 а все остальные единицы
все наборы меньше
его будут содержать
хотя бы
3 нуля
потому что мне придется какой-то из единиц превратить в 0
чтобы сделать меньше
тогда у меня нулей будет хотя бы 3
значит функция
примет значение 0
значит на всех наборах меньше него функция принимает значение 0
тогда по методу суммирования
коэффициент при
мономе x3
и так далее xn
будет 1, 40
и так далее 0 то есть 1
значит
этот моном
войдет в пыльном жигалкина
смотрим какая степень этого монова
так как n больше 4
то переменных там хотя бы 2
значит степень больше равна 2
тогда мы
получили нелинейный моном
в пыльном жигалкина
откуда получили отсутствие афинности
понятно не очень
давайте пока другой скопируем
давайте еще раз это рассуждение
которое было для
случая n больше 4
окей
следующая задача будет куда проще
это кое-что самое интересное
можно начнить
мы получается
а
это
это
это
а
да да да все
я просто сначала подумал что мы
в общем да
давайте еще раз идея
она такая что берем
и ищем набор
первый набор на котором
функция примет значение 1
тогда мы точно знаем что если это
первый набор то набора всех предыдущих
значений 0
значит
тогда
коэффициент
при соответствующем мономе
это все я понял да да но это все понятно
все вот я отыскал его
0 0 и 1 дальше все
и супер я смотрю что
действительно такой моном хорош
потому что он содержит хотя бы две переменные
поэтому мы потеряли линейность
и у меня больше равных 4
ну давайте пока вот вы над этим
может подумать сейчас пока в голове переварится
мы решим более простую задачу такую
релакс для мозга максимально
короче задача заключается в том
чтобы построить две таблицы
еще табличку критерия пост
на этом достаточно
строим для
мажорити
0 0 0
1 1 1 1
0 0 1 1
0 0 1 1
0 1
0 1 0 1 0 1
поехали у нас есть
мажорити
есть одада
одада это же не четкость
именно это четкость
мажорити
просто 0 0
0 1 0 1
1 1 1
0 1 1
0 1 0 0
1
0 1
ну блин
понятно как они
себя ведут
п 0
п 1
соудол
монотенософем
чертим вот такую табличку
0 1
мажорити
одада
поехали давайте заполнять про
мажорити
сохраняет 0
сохраняет 1
короче
самодвоственная
ряна
все наборы симметричные
имеют предположение
монотонная
ли она
да
афинная
ряна
нет почему не афинная
вот такую штучку берем
опять же идея с тем что берем
первый набор
на котором функция приняла один
работает
это набор с двумя переменными
поэтому
соответствующим оно войдет
и она будет нелинейной
потеряли афинность
грусть тоска
содом
у нас
п 0 есть, п 1 есть
да есть
монотонность
очень быстро
монотонность для
мажорити как мы быстро проверили
просто
посмотрели на значение
метода пристального взгляда
понятно
вот для
для
ода мы видим что не монотонно
то есть набор 0.1.0
стал 0.1.1 и поменялись на 0
потерялись
ну
так как нас хотят
чтобы это было базисом то
я могу сразу сказать что можно
скипать вот этот вот
проверку на афинность она будет афинной
но
так как от вас просит развернуть
ответ то придется построить
пыльную обжигалку
то есть
здесь как мы ответили почему
не афинно
не афинно потому что вот
рассмотрели первые три у нас
вот такой моном
либо можно
явно построить пыльную обжигалку
но показа еще нет не афинно
поехали строим
ну
короче
заметили что это
это у нас
теперь 0.1
0 сохраняет 0
1 не сохраняет
можно очень быстро вот как мы монотонно
проверили для
от
для от
смотри вот наборчик
все все
то есть монотонно всегда проверяется
методом пристального взгляда
вот про монотонно сейчас
скажу это метод пристального взгляда
всегда
если кто-то знает как
можно делать не метод пристального взгляда
будет круто
х
нет никто не знает если кто-то знает
то вы решаете одну из вот этих проблем математики
там короче
есть
есть функция
не помню как называется
конечно она
равняется количеству монотонных
функций от
n аргументов
булевых и там вот она
очень быстро растет
и ее можно решать только полным перебора
да там что-то кажется
до шести штуков определили
до девяти по-моему
до девяти
уже по-моему до девяти
быстро
в общем 0 1 не самодвоственные
монотонные
да монотонные
потому что константы афинные тоже
потому что константы
заполнили какую-то обличку
теперь что делаем
первое что проверяем то что это базис
проверяется двумя
почему они не самодвоственные
самодвоственные это же получается двойное отрицание
для 0 1
но я возьму набор
допустим
она всегда примет 0
поэтому как бы ты не инвертировал
аргументы она
значение свое не поменяет
логично
поэтому они не самодвоственные
в смысле
самодвоственные это
если мы инвертируем
все аргументы то
значение функции инвертируется
константы не могут
инвертировать свое значение
поэтому если мы инвертируем их
аргументы они не поменяют
соответственно они не самодвоственные
ок понятно
а 0 же не
афинный там же четное
число
единиц
0
длином же галкина 0
насколько я помню считается
просто 0
но там же не выполняется
необходимые условия получается
а не все я понял
да там везде 0
просто у тебя ни один не войдет поэтому
считай просто 0
у тебя коэффициент там либо 0 либо 1
поэтому 0 как бы зашел
супер
да даже и мы можем
как сказать что эти 0 это
1-41 тут все
линейны
так что все супер
в общем первое что мы проверяем
полноту первая полнота
для этого метода пристального
взгляда смотрим что в каждой
колонке у нас есть минус
извините можно для монотонности
спросить если мы возьмем какой-нибудь
набор аргументов где типа
первый набор аргументов будет больше
чем второй и
получится что при первом
наборе аргументов функция будет
все равно меньше или иначе
при втором
это ничего не даст
ты скажешь
просто на этих наборах у тебя функции
монотонно
монотонно ли она на всех
не факт
при линии монотонности
оно же значит что если у нас набор
аргументов меньше чем
второй то при первом она должна быть
меньше или иначе при втором
для любых наборов
ты говоришь что здесь мы можем
взять что первый набор у нас больше
чем второй
значения в первом
все равно меньше
чем значение в втором
это противоречит
пределение допустим мы возьмем
набор первого
один нуль а второй набор
ноль ноль
при том при другом она 배умит
одинаковое значение это
это противоречит потому что первый doesn't have a lot
монотонов ん
видишь мы требуем не строгую монотонность то есть мы говорим то что типа эти условия
равносильно да какие ну то что типа f от первого набора меньше чем f и второго это равносильно
тому что первый набор меньше или равен второго нет мы говорим что если у нас набор один меньше
другого то функция не должна уменьшить свое значение ну обычная монотонность как в школе
окей просто теперь у нас более сложный порядок на аргументах
в общем первая проверяем планту панта проверяется как смотрим что в каждой колонке у нас есть минус
тоже есть все у нас каждой колонке есть минус соответственно у нас вот этот набор не вложен
ни в один из классов следовательно по критерию поста полу все у нас есть полнота теперь нам
нужно сказать что если мы хоть какую-то функцию выкинем то тогда мы потеряем полноту но смотрим
дальше просто прям берете выписываете что если выкидываем 0 то у нас получится вложенность
1 соответственно неполной выкидываем 1 получаем вложенность п10 соответственно
неполной выкидываем мажорите получаем вложенности вов Ridge не полный выкидываем
от получаем вложенности монотонный неполный все проверили полноту проверили что выкинув
какой-то из функций мы потеряем полноту, значит показали, что это базис.
У нас осталась последняя задача. В общем 22 выразите одно через другое.
В общем как работаем мы с этим добром.
Ну отрицание сейчас скажу. Отрицание у нас это мы помним 1 xor p. Поэтому наша задача выразить как
как нам выразить единицу. Ну например по помощи инвекции я могу сказать, что p следует p это единица.
Идея на что я хочу. Я хочу получить этот полином Жигалкина. Для полинома Жигалкина мне вот справа
у меня есть xor, мне не хватает единицы, не хватает конъюнций. Почему я хочу получить полином Жигалкина?
Потому что дальше я могу работать вот чисто с полиномами равенство и как-то упрощать все.
Я выразил единицу, поэтому теперь я могу выразить отрицание. Не p это у нас p следует p xor p.
Как не выразить импликацию? Давайте построим что? Построим полином Жигалкина для или. Это p xor q xor p q.
Почему так? p xor q даст нам равенство на средних наборах, плюс нам нужны равенства на нижнем
наборе. Это пq. То есть мне даже не чувствует. Импликация. Да импликацию уже придется построить.
То есть естественности 1101. Это импликация. Извините, я сейчас. Как вы сразу без типа по
строению поняли какой должен быть многочлен? Ну потому что xor даст нам равенство, даст нам
единички на средних наборах. Нам что было или не хватает единички на нижнем наборе. Для этого это
пq. Ну и плюс я просто помнил разложение этих функций. Все просто. Рисуем это чудо. Поехали.
0 1 1 1 0 1. То есть это у меня 1 xor q xor p q. Теперь что я делаю? Теперь я решаю уравнение.
Справа у меня p xor p q xor p q. Равняется что-то там. Давайте назову x. Например xor и инверсии.
Это импликация. Что я могу? Так как это полиномы, я могу брать и вычеркивать
одинаковые слагарины. Поехали. Теперь что у меня? p равняется x xor 1. Что тогда я делаю? Я хочу справа
вычесть единицу. Что такое вычитание в полиномы Шигалкина? Это xor. То есть я беру сюда xor 1 xor 1.
То есть x неизвестный. Это у меня 1 xor p. Что такое 1 xor p? 1 xor p это отрисание p. А мы уже знаем как это выразить.
То есть 1 xor p мы знаем как выразить при помощи этого. Значит я знаю что такое x. Вот это у меня
p следует q. Значит я могу выразить дизъюнцию. p или q равняется. Что такое x? Это p следует p xor p.
Дальше на это все навешиваю xor и p следует q. Пожалуйста решили. Именно поэтому полином
Шигалкина хорош. То есть мы справа получили полином Шигалкина. Слева получили полином Шигалкина.
Дальше приравняли. Сказали что давайте мы добавим еще что-то. Чего не хватает до того. Назовем
это x. И будем решать уравнение относительно x. Чему равняется x? Я могу вычитать справа с
лево одинаковые. Дальше вот у меня остался 1. Я взял добавил еще 41 41 и получил в точности чему
равняется x. Все решили уравнение но только уравнение теперь на немножко других полиномах. Извините можно
уточнить если честно. Я для отрицания понял что мы сделали. Насчет дизъюнции не очень понял. Мы
сначала составили многочисленные Шигалкина. И потом говорим что нам нужно еще чтобы была
импликация. И сейчас чтобы была импликация. Что мы делаем получается. Ну смотри понятно что только
через XOR я не смогу как-то получить. Нет тут же сказано через XOR импликацию по условию. То есть не
может быть только XOR. На самом деле там если там подберут такие условия можно что одна через
одну выразиться. Нет тут же мы выразили только через XOR. Но по условию нам нужно чтобы формуле
было еще импликация. Нет по условия нам нужно чтобы эти были выразлены через это и то. Чтобы
вот используя XOR используем импликацию и получаем эти штуки. Если ты можешь использовать только
XOR получить какую-то из этих одних. Супер вполне себе подойдет. Проблема в том что это не сможешь.
Я имею ввиду у нас по условию сказано что нужно выразить отрицание и импликацию через
через XOR и импликацию. Это значит что мы должны отдельно сказать что такое отрицание P через
чтобы записать такую формулу для отрицания P чтобы там было и XOR и импликация. Не обязательно.
Нет ты просто должен использовать только эти два функции записать. Не обязательно чтобы
участвовали обе. А ну так тогда зачем для ВМ еще что-то делаем если мы через XOR уже все записали.
ПКУ. А я понял. Поэтому мне не хватает одного XOR и что я делаю. Я хочу записать импликацию
через пыленом Жигалкина. Даша я скажу что к этому пыленому Жигалкина добавлю какой-то еще
пыленом Жигалкина. То есть там будут содержаться либо вычитание лишних либо добавление не хватающих
маномов Жигалкина. То есть глобально у нас с левой справа маномы Жигалкина так фиксированы. Теперь у меня
справа функции с левой функции. Вот здесь вот у меня уже есть какие-то а здесь есть другие. Тогда вот я X
я что хочу. Я хочу добавить недостающие. Я сейчас не очень понял. Переход. То есть вот мы говорим что нужно
ПКУ. Короче мы говорим что у нас есть конъюнция которую мы не можем выразить. Вот как мы потом
рассуждаем я не понял. Мы слева записали пыленом Жигалкина вот такой. А как мы записываем то что
справа я не понял. Можно еще раз. Слева у меня пыленом Жигалкина для вот этой штуки.
Да. Здесь вот это вот это пыленом Жигалкина для ампликации. Все. Пыленом Жигалкина это кабинет
из каких-то маномов. Маномы все фиксированы. У меня есть такая штука как соль. Я вот что я скажу что
пусть X это какой-то еще пыленом Жигалкина который я ссорю с пыленомом Жигалкина для ампликации
чтобы получить пыленом Жигалкина для изюмцы. Почему-то. Сейчас извините вопрос. Разве P типа
из P следует Q у нас должна быть такой пыленом Жигалкина? Да. Мы же записывали что это вы записали
единичку и на ее месте должна P стоить. Ну ок. Спасибо. Да блин я не понял что это такое. Ну да это уже
Мекса. Ладно давайте. Все. Теперь я понял. А там же Q должно стоять. КУК СОРПЕК СОРПЕКУК. Тут стоит. Тут единичка стоит.
Сейчас подойди пожалуйста. В общем давай еще раз. Вот я записал пыленом Жигалкина для ампликации,
записал для изюмции. Теперь я говорю что вот я возьму X это что? Это какой-то пыленом Жигалкина
состоящий из манов Жигалкина который не достают справа до лево и который вычитает какие-то лишние
пыленомы Жигалкин которые есть право. Все. Я решаю теперь уравнение относительно X. Что я делаю? Я
могу вычесть Q. Дальше я могу вычесть P и P справа. Теперь я получаю следующее уравнение что Q равняется
X 41. Тогда что мне нужно? Мне теперь нужно убрать единицу справа. Давайте я добавлю единицы там
и там. Потому что единицы есть в учитании. Тогда X у меня будет равняться 1 к 40. 1 к 40 какая-то
переменная я уже умею выражать. Поэтому я просто заменяю на эту запись. Это Q следует Q к 40. Все.
Справа я знаю как эту запись переводить. Поэтому я вместо X подставляю новое, а дальше все умею.
Q к 40, Q к 40, что это последует Q. И это равняется P или Q. Поэтому если у вас есть
X, переводим все в пыленомы Жигалкин и решаем уравнение. А по условию типа 0 и 1 нельзя использовать
формулю. Ну да, конечно. Так, ну вот это я понял как мы получили. Но сейчас вот эта верхняя запись,
можно очень быстро уточнить просто чтобы понять правильно я понял или нет. Вот мы говорим что у нас
слева пыленом Жигалкина для или, а справа получается говорим что какой-то короче пыленом Жигалкина
для импликации и то что мы его умножим на другой пыленом, который у нас убьет вот
эти самые. Но почему мы точно знаем что он убьет их? Это будет какой-то какой-то пыленом Жигалкина,
который добавит недостающие и убьет лишние. X, то есть X добавит недостающие и убьет лишние.
Ну вот смотри, например, что сделал этот X? X убил один, который был лишним и добавил Q,
которое не доставало. Сейчас убил X и добавил Q, которого не доставало. Ну потому что вот 1 1,
вот этот вот уберет, а Q он добавит. Сейчас работает как у нас XOR. Работает так, что если у нас чего-то
не было, то он этого добавляет, а если что-то было мы это за XOR, он это уберет. Ну окей, хорошо мы
говорим пусть у нас будет X, который недостающую короче добавит и уберет лишние, но как мы понимаем
что у нас здесь? Мы говорим что Q это лишнее, да? Нет, я все, я сказал что вот и записал вот это урожение,
все, после этого я начинаю решать уравнение, находить что такое X. А еще вопрос, вот почему мы
сразу пришли к мысли, что типа мы должны X умножить именно там на импликацию? Мы X ничего не умножали,
мы XORим. Почему мы именно XORим с импликацией? Потому что мы хотим вырослить. Потому что у нас из
возможностей есть только импликация еще. Все, я понял, то есть мы говорим какой-то многочлен,
XORим его с этим и говорим что он добавит недостающую, убьет лишнюю. Когда как мы понимаем,
что у нас недостающая, что у нас лишняя? Я так понимаю, что у нас лишняя... Мы решаем уравнение.
Мы решаем уравнение. У тебя записано слева, справа. Стандартное уравнение для многочленов,
как в школе, только теперь другие значки. Теперь вместо сложения мы пишем сложение в кружочке. Все,
дальше что умеем мы можем делать с многочленами? Если справа и слева есть одинаковые компоненты,
мы их можем убрать. Вот я убираю одинаковые справа. Я убрал ПК с права-слева, П с права-слева.
Игры чуть-чуть, я понял, да. Понятно. Мне осталось К уравняется в той штуке, поэтому теперь я хочу
вычесть справа один, а вычесть этот XOR один, поэтому XOR один справа, XOR один слева. Получилось что такое X?
Все. Если будет XOR с чем-то, решаем пыльном сжигалке. Решаем этим пыльном сжигалке. А если не будет?
А если не будет грусти, мы пытаемся придумать какие-то, ну короче, методом рандома.
Полюном сжигалки это круто, но есть подозрения, что вам его специально не дадут, потому что им
очень приятно решать такие вот уравнения. Все. На этом вроде все задачи решили. Извините, а 20 можно
разобрать? Давайте 20, вот 20 и 18 я отдельно напишу решение, я пишу файлы. А они какие-то сложные, да?
Они просто там только пару групп, которые доступны, например 18. Короче 18, того что я помню,
заключается в том, что вот это есть у нас по сути ESCNF. Соответственно, мы можем просто построить
сразу по этому быстрый таблицу истинности. Делаем карту Karno по карте Karno, минимизируем.
Дальше используем законы Деморгана. Еще как-то покрутили по дистрибутивности, по сокращали,
получили красоту и записали это все при помощи схемы с функциональных элементов. Там будет что-то
вида, как я помню. Там будет что-то вида, когда мы... Что там было? Там здесь вот дизюмсы,
даже некого как-то там придут так, это как-то так, и там как-то так, и здесь вот как-то так.
Нет, ну здесь вот такая, здесь такая. В общем, она как-то так будет выглядеть, я уже не помню точно.
Я что-то такое решал, я напишу решение, которое я сделал. А по двадцатой какая основная идея?
По двадцатой... Ну, по двадцатой, во-первых, во-первых, вам нужно для двадцатой есть 10
ПТК-классы. Вам могут сюда найти произвольные классы, вам могут быть там классы лямбда, класс В,
класс что... Ну, короче, кранитивные, дизюктивные вам могут дать классы... Пересечением вам могут
быть дать каких-то классов. Короче, есть такая штука, как решетка поста.
Вот такая красота. По идее, вам могут дать на контрольный, абсолютно произвольный класс
отсюда. И там вот что-нибудь такое спросите. Вам нужно помнить всё.
Ну, а как-то, нет, нам её показывали верхнюю часть, и вот Т ну там вот Т нулевое, ну как бы Т,
который сохраняет нулевое, так далее, и это вот Т первое. Ну как бы, как этим пользоваться?
Как этим? Я попытаюсь подумать, придумать какой-то общий способ, но я просто... Эта задача
вообще впервые, таких никогда не было, что дадут на реальный, я даже представить себе не могу.
Понятно. То есть вполне себе можно сделать что-то. Ну дай бог, и сохранят там классы ТК. А теперь,
ну давайте дадим вам класс какой-нибудь там, вот этот вот МП, МТ, когда монотонные и ещё Т-шки.
Вообще никто не помешает вам. Могу спокойно дать классы там, какие-нибудь дизинктивные, конъюнктивные.
Ну, то есть это просто фиг пойми какая задача. Глобально, ну типа 18-й дадут что дадут, ну понятно,
просто другую функцию там, как решать, какого-то общего алгоритма нету. Просто строим таблицу
естественности, при помощи карт-карно пытаемся уже сразу как-то минимизировать. Дальшим методом
приставного взгляда. Применяем законы деморгана, что мы делаем. Здесь, 20-й, ну, я не правда,
я не знаю. Во-первых, я не знаю, что дадут. Правда ли дадут потом в конце просто Т0. Может
быть сверху сделают, может быть верхний индекс будет фиксирован, нижний будет каперименный. Как именно
эта штука будет выглядеть, непонятно. Понял. Типа, если был бы раньше, я бы мог еще как-то посмотреть.
Задача вообще абсолютно новая. Раньше даже, ну типа, ТК не всегда на семинарах разбирали. Ну,
324 это мат-группа, по-моему, а 326 и 328 это эти, про два. Ну, 312 это рэш. Я не знаю, зачем рэш дают.
Ладно, я попытаюсь вывести какие идеи здесь, я почитаю, подумаю. Думаю, завтра сделаю.
Спасибо, до свидания. Мне за что решение. Прошлые лет скоро будут. До свидания. Спасибо за
ДОП-семинар. Всем добру, до свидания. Спасибо.
