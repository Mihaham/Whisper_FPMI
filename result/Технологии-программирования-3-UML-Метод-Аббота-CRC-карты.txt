Всем доброго вечера! Сегодня у нас будет следующая лекция, посвященная таким интересным вещам, как
UML. Мы немного затронем, что же такое методология разработки ПО и посмотрим, из каких частей
состоит разработка ПО, как люди на самом деле разрабатывают ПО. Смотрите,
сегодня такая лекция технически будет сложная, но важная, потому что в первых
итерациях проекта вас попросят нарисовать разные UML диаграммы. А для того, чтобы нарисовать UML
диаграммы, надо понять, что же такое UML. Давайте вспомним, что мы с вами в прошлый раз узнали.
Напоминание, что у нас было в предыдущей серии. Да, Solid, Kiss, Dry, Diagny. Да, мы с вами еще поговорили
про первые паттерны и антипаттерны, и на самом деле мы начали с вами разбирать UML. Что же мы с
вами разобрали? Класса. Мы с вами поговорили про диаграмму классов. Не только все классами
обеспечивается. Мы с вами вспомнили шутку Solid, шутку Dry, Kiss, Diagny, первые паттерны и антипаттерны,
и поговорили про диаграммы классов. На самом деле, UML состоит не только из диаграммы классов. Это,
на самом деле, я бы так сказал, первая декомпозиция, которую можно сделать с UML. Давайте познакомимся с
что же такое UML. Давайте отмотаемся. Небольшое прошлое, а приблизительно лет на 30 назад.
Да? Давайте историческая аналогия. Значит, 90-е годы. Что происходит в мире IT? Появляется
интернет в публичном масштабе. Раз. Что это за закон? Я, может, забыл. Закон Мура, может быть?
Про ускорение. Да, это закон, который говорит, что за каждые 18-24 месяца количество транзисторов
всеми увеличивается в два раза в вычислительной схеме. Но тогда этот закон был выполнен еще и
для центральных процессоров. Ну да, в общем, много что сопоставляется, но с вычислительными
мощностями сейчас это работа только для видеокарм, чтобы было понимание. Так, еще.
Это было такое, я бы сказал, второе дыхание мира сети. Скорее бы сейчас, где-то сейчас происходит,
я бы так сказал, если не третье. Вот, давайте еще. Мы же все-таки с вами тут пришли говорить
за разработку. Давайте поймем, какие языки появились в 90-х годах. Python это хорошо, но это не
наш кейс. Появились замечательные два языка. Первый язык это Java. А потом, что еще было? Какой еще
язык был? C Sharp. И в чем их особенность этих языков? По сравнению с C++ тем же самым. Они чисто
объектно-ориентированные. Да, то есть, если мы с вами поговорим про тот же Java, то мы с вами
понимаем, что в ней все объекты, мы, кажется, с вами в прошлый раз про это говорили, отнаследуются от
замечательного класса под названием Object. Вот, и так забегаю наперед. Значит, в этой неделе у
некоторой группы уже начнутся разборы паттернов. Значит, один из паттернов взят по факту из Java.
Ну, реализации там можно найти в Java. В C++ там другая реализация будет, но в целом это тоже
порождающий паттерн. То есть, у нас есть чистое ООП. Теперь давайте поймем, что происходит с
технологией, если она внедряется в каждый утюг. Ну, вот смотрите, у нас появились чисто
объектно-ориентированные языки. Мы с вами понимаем, что в ООПшных языках у нас есть методы,
у нас с вами есть поля, у нас с вами есть наследования и все такое. И у нас появляется диаграмма класса,
которую мы с вами в прошлый раз видели. Какой из этого можно сделать гипотетический вывод,
особенно если мы с вами привередливаем математики? А? Превратить код в набор диаграмм. И из набора
диаграмм генерировать код. Вот. И этот цель как раз преследует язык QML. Значит QML расшифровывается
как Unified Modeling Language. Унифицированный язык моделирования. И здесь все подчиняется такой
инструкции, что если у нас с вами есть способ каким-то образом построить диаграммки, провалидировать
их, проверифицировать их, разницу между валидацией и верификацией мы будем с вами говорить чуть
позже, то давайте не будем писать код, а будем строить диаграммки. Отличный план. Как вы думаете,
он был реализован в реаленсе? Да, кстати, про блок схемы мы сегодня поговорим.
На самом деле ответ нет. Эта идея не очень хорошо прижилась. Почему? Потому что язык очень-очень
сложный. Крайне сложный. Чтобы владеть совершенствием надо пройти семестровый курс и дай боже,
если он пройдет хорошо. Раньше был такой курс, на него сейчас тоже можно будет походить в
седьмом семестре по выбору и узнать, что же такое UML в полных прекрасах. Но нотация в нем
крайне сложная. Помните, мы даже когда смотрели с вами в диаграмму классов, то мы с вами начали
сильно путаться. Было такое связи какие? Там четыре типа связи есть между классами. И что, если мы
с вами путаемся между этими четырьмя типами классов, то с другими диаграммами будет намного
сложнее. Но на самом деле эти диаграммы в первом приближении можно использовать для того, чтобы
объяснить другому человеку, что мы имеем в виду. И всякие архитектурные сложности, в принципе,
можно тоже отобразить на этих диаграммах. И вот чтобы мы с вами начали понимать друг друга,
будем считать, что мы с вами сегодня будем строить павилонскую башню в программировании,
в некоторой абстракции. Мы с вами поговорим про UML. Так, вопросы по этому слайду? Нет. Значит,
как рисовать диаграммки эти? Значит, есть разные способы. Кто-то, кстати, сказал, что Visual Studio Code
есть некоторые плагины, которые это поддерживают. Это да. Но главное проверять, что в этих моделях
есть валидация. Сразу скажу, что в заданиях по паттерну нельзя будет взять, написать сначала
код, а потом нарисовать, сгенерировать диаграммки из этого. Вот. Нужно сделать аккуратно. То есть,
продумать архитектуру, а потом уже перекладывать на диаграммки. Значит, есть два тула. Это бесплатные
тулы. Первый тул — это модель. А второй тул называется Papyrus. Есть еще очень крутые тулы типа Magic
Draw, но они, собственно, стоят некоторых денег и оплатить, к сожалению, мы сейчас их не можем.
Значит, смотрите, чтобы вы понимали, как этот тул выглядит. Значит, это вот такая вот по факту
IDN, среда интегрированной разработки, но только на уровне диаграммок. То есть, вместо того,
чтобы писать код в правом окне, у нас рисуются диаграммки. Причем связи между этими диаграммками
валидируются, и ничего лишнего нельзя тут нарисовать. На самом деле проблема, знаете, в чем оказалась?
Более того, в UML. Как только люди начали реализовывать эти диаграммы и писать инструменты,
для всей этой проверки они зачастую очень быстро крашатся. Просто из-за того, что мы начинаем
рисовать набор диаграмм, у нас одна диаграмма не состыковала со второй, вторая с третьей,
и мы не можем просто выйти из ошибочного состояния. Такое реально бывает на практике. Но в первом
приближении можно задавать эти все штуки. Более того, эти штуки умеют генерировать код.
Второй тул это Papyrus. В принципе, та же самая история. Это наследник от Eclipse. Я не знаю,
слышали про такую IDE как Eclipse? В общем, для нее дофиги еще плагинов написано,
и каждый плагин это отдельный тул. Здесь видно диаграмма класса какого-то проекта.
Собственно, можно скачать эти тулы и посмотреть, научиться им пользоваться.
Есть про тулы и вопросы. Еще я же сказал, что есть Visual Studio Code с плагином для DRAW-YO,
который умеет валидировать модели. Сам DRAW-YO лучше не использовать, потому что он нифига
не валидирует результат. Но это так, если мы с вами говорим про прототипирование. Точнее,
если мы говорим про реальные кейсы про прототипирование, в принципе,
можно использовать визуальные редакторы. Главное, чтобы схемы быстренько кидались.
Картинка. Вам надо пояснить картинку. Представьте себе, что вы едете в лифте. К сожалению,
у нас лифтов не очень много. Давайте представим кейс. Вы поехали к другу, к старшекурснику.
Где сейчас ФМИ-старшекурсники живут? Не, в Тринажке. В Тринажке сколько этажей?
Ну, 12 этажей. И у вас есть гениальная идея. Мы же тут фиксиков двигаем. Представьте себе,
что вы едете к другу старшекурснику на 12 этаж. Предлагаете ему идею. Давай запилим это. У
вас опыта не очень большой. А у вашего коллеги опыта достаточно большой. Ну и говорит, ну что,
давай. И у вас есть время, пока вы едете на лифт с первого до 12 этажа, это приблизительно
полминуты, объяснить, что же происходит. Вы можете показать картинку. Вот, смотри. Это будет
выглядеть так. Нам для техники нужна эта. Какие-то основные особенности разложительной диаграммы.
Да, вместо того, чтобы объяснять, мы на таком языке будем писать. Не понять,
что будет. А вот так вот диаграмма есть и все сразу видно. Вот. Как бы друг к другу мы с вами
можем понять. Да и можно, кстати, и по диаграмме тоже скажу наперед, можно будет понять,
хорошо ли у вас устроена архитектура. Наверное, если вы нарисуете диаграмму класса и поймете,
что у вас в диаграмме классов от одного класса идет огромное количество связей к другому классу,
наверное у вас нарушен принцип high cohesion low coupling, который мы с вами говорили. Вот.
Либо если у нас с вами появится треугольник какой-нибудь, типа у нас есть класс A,
который использует некоторые класс B, а класс B использует класс C, а потом оказывается,
что класс A использует класс C. Вопрос. Такая диаграмма что у нас с вами нарушает? Да,
такая диаграмма у нас нарушает закон Диметра. Вот. То есть на диаграмме можно следить.
Знаете, что касается диаграмм UML? Диаграмма UML делится на два больших типа. Значит,
первый тип это структурные диаграммы, которые показывают связь между объектами. Вторые типы
это поведенческие диаграммы. Это диаграммы, которые показывают поведение между сущностями,
которые у нас с вами есть в системе. Значит, и структурных диаграмм нас сегодня будет
интересовать. Диаграмма классов и диаграмма компонентов и диаграмма пакетов. В правой части
мы с вами будем рассматривать сегодня тоже некоторый набор диаграмм. Мы рассмотрим с
вами диаграмму activity, use case и диаграмму state machine, по факту диаграмма состояний. Плюс
еще выделяет отдельный набор под диаграмм. Это диаграммы, связанные с взаимодействием двух
объектов с течением времени. К таким относится, допустим, диаграмма последовательности,
которую мы с вами тоже сегодня рассмотрим. В общем, вот такая вот большая картинка. В конце
презентации есть ссылка на эту картинку и есть ссылки на все описания всех видов диаграмм.
Так что картинку это можно не запоминать. В общем, вот эти типы диаграмм мы сегодня с
вами посмотрим. Значит, что касается диаграмм классов. Мы с вами ее уже посмотрели в прошлый
раз, поэтому сегодня я решил вместо этого сделать некоторое упражнение. Я покажу,
как можно из текста описания выделить класса. То есть, как понять, что может быть класс. Вот.
Значит, так. Есть ли вопросы по введению в UML? Или пока вообще ничего не понятно? Да,
мы сейчас как раз по ним пойдем. Ну, опять же, не так подробно, чтобы вот прямо стать
экспертами по UML и сдать экзамен сразу по UML. Но в первом приближении. Значит, смотрите,
давайте начнем с первой диаграммы. Это диаграмма вариантов использования. Вот давайте попробуем
понять, что, по вашему мнению, такой вариант использования. Еще это расшифровывается как
use case. Не понял. Так, ладно. А что она так? По-другому это еще называется use case.
Как вы понимаете, я бы сказал, это с точки зрения бизнеса. Описание процесса. Что же у вас
происходит? Представьте себе case. Вариант использования. Обучение в университете. Давайте
поймем, как, из чего он состоит. Ну, это понятно. Смотрите, на самом деле, тут очень важно понять,
кто будет играть роль. Смотрите, у нас с вами есть вот этот вот челдобончик. А что, настолько она
богает? Смотрите, у нас есть челдобончик. Это этот студент. Не поверите, есть еще другой
челдобончик. С другой стороны. Нет, я, конечно, давайте это, некрасиво. Так,
давайте челдобончик с этой же стороны будет. Препод. И есть такое понимание, что у нас есть
система. В нашем случае это университет. Вот давайте подумаем, как эти люди могут
взаимодействовать. Ну, давайте, посещение занятий, да. Я теперь понял, почему доска.
Степендию. Сдача зачетов. Да. Что еще? ЗП. Вот. Значит, есть еще стипендия. Смотрите,
что, что объединяет стипендию зарплату? Так, смотрите, смотрите песню, бухгалтер, милый мой бухгалтер.
Есть еще получение? Что там называется? Нет, какой задавальник? Бухгалтер же у нас тут.
Отправка денег, вот. Выплата, да. Спасибо. Смотрите, и оказывается, что получение стипендии и
получение зарплаты, они у нас общие относительно того, какие выплаты у нас производятся. Так ведь?
Ну, что это через всю одну и ту же бухгалтерию проходит. Да, поэтому, когда сценарий получения
стипендии, это на самом деле включает в себя вариант использования. То, что я рисую крокляшками,
это вариант использования. Если у нас здесь есть зарплата, то мы тоже на самом деле ее включаем
в получение выплат. Да, и дальше мы объединяем это все дело. То есть, смотрите, из чего состоит
вариант использования, сценарий использования. Это некоторые сценарии взаимодействия по оцени,
некоторыми акторами. Значит, акторы, вот эти вот люди, которые у нас нарисованы, они называются
акторами. Вот, а круги, это вариант использования. Вот пример диаграммы вариантов использования,
на самом деле, мы с вами ее тоже тут нарисовали. На самом деле, они вот так вот изображены,
наверное. Вот так вот, я бы даже сказал. Ну, здесь такая же картинка. Значит, смотрите,
единственное, что мы с вами видим, что здесь, не поверите, тоже есть наследование. Видите,
на экране есть кругляшочки с видом extents. Есть include, а есть extents. Значит, чем отличается?
Это все дело. Include означает, что при выполнении одного варианта использования нам нужно обязательно
выполнить другой вариант использования. Да, ну, нотация не точная, поэтому можно либо extents,
либо extents использовать. Вот, include, а extents, это значит, смотрите, мы выполняем какой-то
вариант использования, да, и потом, допустим, при выполнении некоторого условия мы переходим
в другой вариант использования. Пример. Вы когда-нибудь видели ошибки на экране? Вот представьте
себе, у вас идет какой-то сценарий, выполняется, а потом внезапно что-то происходит не так. Мы с
вами сворачиваем в некоторый альтернативный сценарий, в котором нам выдается ошибка. И вот как раз
выдача ошибки, это является альтернативным вариантом использования к варианту использования,
который у нас есть. Ага. Ну, пример. Вот опять же пример с получения выплат. Вы такие,
стучитесь с системой, тук-тук-тук, дайте мне денег. Видите, такие приходите, маскируетесь под
препода и захотите зарплату препода получить, а потом так и идете. Так, стипидиальный отдел
смотрит, там на самом деле два отдела, зарплатный отдел и стипидиальный отдел. Зарплатный отдел
смотрит и говорит, вы мне зарплату не заплатили. Таки смотрит, вас нету. Говорит, а вы кто? Вы студент?
Так, идите отсюда, вам другого аудитория. Вот, то есть у нас был основной сценарий, то есть если бы
пришел преподаватель, у нас бы этот сценарий прошел успешно, а если у нас нет, то нам надо
свернуться в другой вариант использования. Да, это extents. Вот, то есть смотрите, вот на примере у нас
есть заказ еды и он расширяет вариант использования заказ вина. Почему? Ну, мы заказываем еду, да,
допустим, а потом заказываем в вино. Что нам надо сделать для того, чтобы заказать в вино? Паспорт
показать, да. То есть у нас добавляется два действия. Покажите паспорт, точнее, да, да, одно действие,
покажите паспорт после этого. И тогда мы переходим уже в вариант использования заказать в вино. Вот,
значит, вот такая вот интересная вещь. Причем на каждом из этих вещей можно написать стрелочков,
что же происходит. Так, ну и смотрите, мы сразу понимаем, на этой диаграмме мы сразу понимаем,
кто будет клиентом нашей системы, кто этой системой будет пользоваться. В нашем системе
по университет пользуются ей студенты, преподаватели и бухгалтеры. Ну, может быть, еще кто-то,
следующий кафедр, деканату, вот это вот всего. Вот, а что касается системы, связанной с рестораном,
то мы с вами видим, что здесь у нас шеф отвечает за то, что он готовит пищу и по факту подтверждает
заказы на пищу. Клиенты заказывают еду, есть еще официанты, есть еще кто? Кассир. То есть сразу
видны все действия, которые у нас есть. Да. Ну да, нам все равно, то есть студент приходит получать
стипендию. Да, да, да, конечно же. Ну то есть все равно это проходит через бухгалтерию, получается,
что стипендию включает в себя выплату каких-то средств. Просто по какому физлицевому счету это
проводить, ну, отдельный вопрос. То есть как бы смотрите, ну, отличие там стипенди не облагается
налогом, зарплата облагается налогом. Так, смотрите, так, по этой диаграмме вопросы. Вот именно по этой
диаграмме. То есть вы приходите, общаетесь с заказчиками и начинаете выяснять, что же вам
надо делать. И вот такими большими мазками вы выделяете те сценарии, которые вам нужны. Значит,
смотрите, когда мы пишем сценарий, в каждом юскейсе нам необходимо прописать следующее. Название этого
варианта использования, оно написано в кругляшочках. Действующие лица. Как понять действующие лица из
этой картинки. Да, человек, кто-то соединен с человечками. Дальше у нас идет основной сценарий. Здесь
эта штука, которая не прописывается прямо в сценарии. Это прописывается обычно в отдельном документе,
в котором по шагам расписывается, что делает каждый из акторов, что делает система. Пример.
Пример. Посещение занятий. С чего начинается этот. Этот сценарий. Давайте продумаем. Шаг
первый. Преподаватель приходит на занятие. Не, образно говоря. Отлично. Давайте представим,
что аудитория уже открыта. Второй шаг. Студент приходит на занятие. Это основной сценарий.
Если на шаге два студент не находит свободных студий в аудитории, он приступает к альтернативному
шагу поиск стульев в других аудиториях. Шаг три. Студент начинает слушать преподавателя.
При этом преподаватель начинает вести какой-то материал. То есть у нас тут два актора принимают
в участие. Шаг четыре. Преподаватель спрашивает, есть ли вопросы. Это студент. Мы можем перейти
либо в альтернативный сценарий ответ на вопрос, если студент задает вопрос, либо перейти дальше.
Можно написать, повторяем шаги три и четыре до тех пор, пока пара не закончилась. Либо пара не
закончилась, либо материал не закончился. Прямо по шагам прописываем все действия. Не поверите,
это сильно упрощает разработку. Я так расскажу из примеров. Система пишет, по факту главный
разработчик, я и мой друг, мы ее вместе пишем. Оказалось так, что я вовлечен в процесс преподавания,
а мой друг в него влечен в процесс преподавания. Вы не поверите, когда мы расписали для некоторых
сценариев, когда мы только начали писать сайт, что надо делать по шагам, по сценарию. Вы не
поверите, разработка этой фичи ускорилась раз в пять. Просто в лед. Поэтому такие сценарии полезно
прописывать. Это что касается use case. Возможно, что я после лекции как раз вам пришлю пример того,
как это выглядит. Прямо сделаю скрин из этого документа, чтобы вы поняли, как пишут варианты
использования. Более того, при помощи вариантов использования вы не поверите, можно начать писать
тесты, которые будут проверять этот вариант использования. Так, понятно ли, что такой вариант
использования и зачем он нужен? Важная фишка. Так, давайте дальше. Поговорим немножко про
выделение классов. Значит, смотрите, представьте себе, вам присылают техническое задание. Это
такой документ, в котором описано, как система должна выглядеть, из каких составных частей она
должна состоять и так далее. И как понять, а где же классы в этой системе? То есть что за
сущности будут стоять между собой классы? Значит, бывают несколько способов, а один из них это так
называемые CRC карточки. Это значит вот такого рода карточки, в которой мы пишем верхней части
названия нашего класса. Дальше мы прописываем, какие ответственности у этого класса, то есть по факту
контракт, который он должен исполнять, а справа это с какими другими объектами он должен
коммуницировать. Примеры. У нас есть с вами продажа sales. Значит, какие у него ответственности? У
него, значит, должна быть промоакция, обеспечить промоакции, делать проводки, обеспечивать некоторые
поведения и так далее. А есть коллаборанта, то есть продажи кого вовлекают? Это партнеры, которые
нам продают товар, либо определенные клиенты, которые этот товар покупают. То же самое с
транзакцией. У транзакции какие обязанности? Это обеспечить перевод денег, трансфер, и аудит. То
есть что такое аудит? Это, в общем, проверка того, что у нас транзакции проходят нормально,
нет никаких макинаций и так далее. Да, то есть это финансовая вещь. То есть любой отчет к вам
приходит, вас начинают проверять, у вас есть вся история транзакций. Замечательно. Вот. И коллаборанты
у нас кто транзакции вставляет? Это считыватель с карты, когда мы оплачиваем это все, и клиенты. Вот.
И таким образом мы с вами явно можем выделить, то есть если у нас для какого-то объекта мы точно
можем описать некоторые ответственности, и некоторый набор коллаборантов, скорее всего,
это будет класс. При этом давайте подумаем, что означает контракт? Вот в левом столбце,
в responsabilites, в контракте, для чего мы можем это использовать? А? Ну в левой картинке, то есть
это вот здесь. Раз, два, три, четыре. Для чего можно использовать в первом приближении вот те
ответственности, которые мы с вами вынесли? А? Ну это раз. Да, можно их разделить. Но давайте
в первом приближении. Мы с вами пытаемся выделить классы. У класса что должны быть? Методы и поля. Где
здесь в первом приближении будут методы, а где поля? Да, responsibility, это скорее всего будут методы,
а коллаборатор, это скорее всего поля, с которыми мы можем взаимодействовать. Плюс? Более того,
мы с вами можем понять из этого, что в принципе справа коллабораторы в каком количестве они будут
в каком отношении. То есть мы понимаем скорее всего, что транзакция это одна карта, один клиент. Если мы
говорим про продажу, там может быть один клиент, один партнер и так далее. То есть мы с вами можем
понять в каком отношении, в какой сущности это можно хранить. Это первый способ, который можно выделять
класс. Понятно ли, что такое CRC-карточка? Вот тоже можно попробовать. И есть второй пример. Ой, так это уже
пример. Метод Abotton. Он тоже применим. Значит, в чем сущность? Мы берем текст, берем карандашик,
ну либо выделитель, и начинаем выделять это все. Значит, первое, что мы делаем, выделяем
существительные. Потом все существительные в тексте объединяем в группы синонимов. Кто такие
синонимы? Ну, по факту, да. Если вы знаете Matlock, то ой, квалентность. Слова похожи по смыслу. Значит,
третье, мы исключаем числительные. Я вот, честно, русский язык не помню. Мне кажется, числительные это
отдельная часть речи. Да, так что это, можно вычеркнуть, исключаем числительные. Значит, дальше исключаем
эфемерные слова, типа система, данные, информация, служба. Ну, в зависимости от контекста. То есть,
понимаете, такие слова, которые встречаются везде в информационной технологии. Такие слова еще
называют стоп-словами. Возможно, кто знает этот термин в машинном обучении, слышал про него.
Вот. Ну да, видите. И последнее, исключаем слова, которые вот совсем к предметной области не подходят.
После этого мы можем все эти существительные проверить на метод CRC и оставить только те
необходимые, которые являются названиями класса. Давайте пример. Я взял тоже как раз из одного текста
описание как раз по курсу, который будет в дальнейшем. Вот представьте себе у нас текст.
Служба выполняет заказы по доставке заказов клиентов. Доставка заказов шляется по маршруту,
составляющим из несколько путей и так далее. Давайте попробуем выделить здесь те существительные.
Давайте я даже их буду выписывать. Так, поехали. Служба. Заказ. Доставка. Ну, давайте не повторять.
Клиент. Клиент, маршрут. Ага. Тип, да? Тип, транспорт. Ну да, мы уже с вами понимаем,
что скорее всего эта спецификация будет. Местонахождение. Ну, вот давайте пример.
Номер. Номер. Ну, давайте сразу поймем. Первое, что из этого хочется выкинуть.
Смотрите, начинаем с и чего. Объединим синонима. Если у нас тут синонимы, ну в принципе нету.
Единственное, можно сказать, что транспорт бьется на некоторые подтипы. То есть у нас появляются
уже некоторые подтипы. Значит, смотрите, второе, что здесь есть, что я не перечислил, это, я не знаю,
есть такие отглагольные существительные или нет. Да, вот смотрите. Отслеживание,
передача, получение, это на самом деле глаголы. Передача. Передача, получение,
отслеживание, это по факту глаголы. Ну да, ну поэтому скорее всего это будут какие-то методы классов.
Да, то есть это как раз то, что мы можем с вами назвать responsibilities. Убираем их.
Доставка. Да, доставка и заказ на самом деле в данном случае это, я бы сказал, больше синонима. То есть
если, смотрите, если бы это был бы какой-нибудь магазин другой, там магазин имеется в виду товара
спортивных, то мы можем оформить заказ, но в качестве заказа может быть написано, что это либо
отправка домой, да доставка, либо это у нас мы ножками приходим и оформляем заказ. Поэтому в данном
случае это синонимы и лучше писать, что это заказ. Да, контекст учитываем. Что? Здесь тонкий
момент, как бы у нас должна быть хотя бы одна сущность, в которой что-то будет храниться.
Да, да, да. То есть, смотрите, дальше что мы можем сделать? Давайте эфемерные слова выкинем отсюда.
Какие слова являются эфемерными? Служба, тип, история, потому что скорее всего история это какой-то
список. Номер, нет, это смотрите, это уже другая вещь. Ну и вот у нас уже остался какой-то из списков.
Это заказ, клиент, маршрут, плечо, транспорт, местонахождение, номер. Что мы исключили? А потому
что это глаголы. А глаголы это методы. А теперь смотрите, применяю метод CRC. Да, на ходу. Давайте
подумаем, у каких из этих сущностей есть какие-то ответственности. Клиент оформляет заказы. Да,
значит это класс. Ну да, можно сказать так, транспорт прокладывает маршрут, местонахождение. Давайте
подумаем, местонахождение является ли чем, что-то он хранит, какие-то обязанности он использует,
или наоборот его используют. Его используют, то есть у него никакого ответственности нет,
поэтому скорее всего это не будет классом. Да, это явно будет поле класса, в котором он относится.
Да, номер тоже поле. Маршрут. Ну маршрут скорее всего хранит стартовое местонахождение,
конечное местонахождение, текущее местонахождение, и хранит набор, и набор хранит всех плеч. Да, а плечо,
у плечо хранит стартовое местонахождение этого пути переправы и конечные пути переправы.
И как, по какому типу транспорта там можно доставлять? Ну смотрите, если бы мы с вами говорили
про чистый C++, скорее всего плечо было бы структурой, а не классом. Да, но пока что класса от структуры мы с вами не отделяем.
Ну окей, да. Да, но опять же тут есть споры, и это еще можно уточнять. То есть это просто первый набросок того,
что с заказом делать. Ну она хранит как с ними себе номер заказа и клиент, который, да, и что в нем содержится.
На самом деле это первая часть описания, там в описании в три раза больше. И там как раз будет про
заказ, что он хранит там, что и так далее есть. Да, я просто это опустил. То есть заказ,
если читать дальше по контексту, то это будет классом. То есть таким образом у нас появляется
сколько классов? Пять классов всего. Заказ, клиент, маршрут, плечо и транспорт.
Ну да, но по факту эта структура будет хранить точку X, точку Y, возможно еще высоту и более ничего.
То есть скорее всего будут его использовать, нежели чем он будет использовать кого-то.
Ну да, ну если он тупо-тупо совсем...
Ну да, тут тонкий момент. Да, то есть мы можем ошибиться в первом приближении на плюс-минус два
класса, давайте скажем так. Окей? Так, понятно ли, что такое, вот как можно выделять классы в первом приближении?
Да, вот смотрите, вот как раз замечательная задачка для контрольной, допустим. Мне кажется.
Так, перерыв делаем? Да, давайте тогда отдохнем. Вот. Это вот то, что у меня осталось, но у нас что-то другое осталось.
Ну не суть важная. Давайте перерыв тогда. Вот пример варианта использования, который можно использовать.
Извините за тавтологию.
Пример получить список заданий на проверку. Из чего он состоит? Он состоит из действующих лид, из основного сценария.
Основной сценарий. Преподаватель нажимает на кнопку проверка заданий. Система отправляет запрос баз в данных.
Получить все объекты типа посылка, статус которых он ревью. Поскольку субмиссион находится в студент, то необходимо реализовать запрос.
Нужно получить субмиссион среди студентов, то есть это уже наметка, что надо реализовать в виде задачи.
Преподаватель должен иметь доступ к проверке заданий студента. В третьем случае, третьем шаге нам система должна вернуть список субмиссионов.
Вот такой пример варианта использования. Достаточно простой. Иногда бывает очень много шагов, которые надо разбить на составные подчестия.
Так, а мы с вами продолжаем. Следующий тип диаграмм. Это диаграмма последовательности.
В общем, из чего она состоит? Она состоит опять же из акторов в системе. Но только это уже более внутренняя система.
Дальше здесь на самом деле диаграмма не совсем точная. Здесь уже рисуются на самом деле не классы. То есть это не классы.
Это на самом деле экземпляры этого класса. Сразу что было понимание.
И дальше мы с вами говорим следующее, что у нас есть с вами некоторые вызовы методов.
И вот по вертикали у нас с вами находится линия жизни. То есть представим себе, что это у нас шкала по времени.
А дальше мы с вами делаем некоторые шаги. Первым шагом мы делаем ставку карт в ATM. ATM это если что банкомат.
То есть у банкомата должен быть метод вставить карту. Как он обычно реализован?
Не, ну в реальных сценариях. То есть у нас есть отверстие, в которое мы вставляем карту. То есть мы должны прочитать карту и понять, что же происходит.
После этого мы делаем verify карт. То есть мы обращаемся к инструменту под названием bank server и вызываем метод у него verify карт.
Дальше у нас наступает здесь альтернатива. Видите alt? То есть возникает один из двух случаев.
Либо у нас все с карты окей, тогда мы запрашиваем PIN код ввести у клиента. То есть вызываем у клиента метод ввести PIN код.
А если карта невалидная, то мы говорим, что карта невалидная, выплевываем карту, возвращаем.
На самом деле смотрите, я сразу скажу, что картинка неверная, потому что по факту, если точно рисовать диаграмму, здесь нужно нарисовать штрихи.
Штрихи – это возвращение результата функции. А дальше этот клиент должен вызвать функцию у отм ввести PIN.
Да, а здесь у нас должна карта извлечься. То есть скорее всего здесь происходит следующее. Если точно говорить, то у отм вызывается метод exit карт у себя же.
И возвращается результат, что карта невалидная. А дальше мы уже двигаемся к следующим шагам, мы вводим с вами пароль.
Ну да. Да, да, да.
Карта валидная, засасываем ее. Запрашиваем PIN, засасываем, не возвращаем.
Да. А вот смотрите, здесь сразу видно следующая интересная вещь, что если у нас с вами есть стрелочка обратная у функции, то это так называемые синхронные функции.
То есть мы вызываем функцию и получаем у нее результат прямо сразу же. То есть в этой функции мы делаем ретёр.
Бывает такое, что функции не сразу возвращают результат, а в течение какого-то другого момента времени.
Такие функции называются ассихронными. И нам не понятно, когда действительно вернется результат.
И не поверите, в web такое достаточно часто. Вот. И для того, чтобы получить результат ассихронной функции, зачастую это все зашивать в другую функцию, которая называется callback.
То есть я тебе отправляю запрос, но после того, как ты выполнишь этот запрос, выполни функцию, которую я тебе прислал.
Вот. И с этим связано, во-первых, один анти-паттерн, а с другой стороны, при помощи этой штуки реализовывается один паттерн.
Вот. Если интересно, давайте я напишу сразу эти два паттерна, чтобы они у нас сохранились в качестве доп-материала.
Значит, паттерн называется, первый, это цепочка ответственности, chain of responsibility, а анти-паттерны, которые с этими связаны, их два, если не правильно реализовать.
Первый называется callback hell, а? Типа того. А второй называется Hadouken code style.
Если говорить про код, то зачастую готовьтесь к тому, что первые итерации review вам будут писать вот такое.
И вы должны понимать, что это такое. Хотите увидеть, что это такое?
Это высокий уровень вложенности.
И вы не поверите, такой же аналог Hadouken code style был найден в исходной базе Яндекса. Да, это было забавно.
Вот. Высокий уровень вложенности. Стараемся сокращать. Это высокий уровень вложенности. Вот.
Ну, это такие отступления, но сразу, чтобы понимали, к чему это может произойти. Вот другой пример.
Он менее детальный. В общем, здесь просто все подписано.
Типа, откуда нам все приходит. Там в квадратных скобочках написан gate.
Дальше мы вызываем сообщение, а дальше мы показываем, в какой момент времени наш процесс живет по факту, активная деятельность.
То есть мы вызывали функцию, дальше что-то происходит, мы возвращаем это все.
Более того, если мы можем с вами создавать экземпляры какого-то класса, вызывая его конструктор,
и тогда показывается метод create, что мы действительно создаем объект этого класса.
Вот. И есть еще, вот тут, кстати, как раз картинка с thick callback, если вы можете ее увидеть.
Да, то есть если на презентации посмотреть, вот тут есть функция типа ajax, потом вызывается функция,
а после нее вызывается функция под названием callback у другого объекта.
То есть мы можем результат функции возвращать не на наш объект, а в какой-то другой объект.
Вот.
И еще бывает optional, то есть что у нас в каком-то варианте может случиться.
Вот. И на самом деле при помощи этой диаграммы можно видеть, каким образом по времени взаимодействуют одни объекты с другими объектами.
Какие вызовы являются синхронными, а какие вызовы являются асинхронными.
Это позволяет навести порядок именно в отображении линий жизни.
Так.
Плюс еще тут можно типа показать, какие действия нас требуют дополнительного ввода информации.
Вот тут есть вкладочки с названием ref.
Так. Понятна ли цель, для чего нужна диаграмма последовательств.
Еще раз. Диаграмма последовательств нужна для того, чтобы провалидировать взаимодействие между объектами
и понять, кто кого-то выдает и в какой момент времени.
И это, допустим, реализация одного из вариантов использования.
По времени.
Вторая диаграмма.
Так, двигаемся дальше.
Вторая штука – это диаграмма состояния.
Значит, к чему это относится?
Представьте себе, что у нас есть какой-нибудь замечательный класс,
который на самом деле может работать в нескольких режимах.
Представьте себе кулер с водой.
В каких режимах он у нас с вами может работать?
Внутренних.
Он либо не работает, либо…
Он либо может нагревать холодную воду, либо ослужать теплую воду до холодной.
То есть у него есть несколько режимов работы.
При этом эти режимы работы он переключает внутри себя.
То есть он сам управляет своим состоянием.
И вот класс, который умеет управлять своим состоянием, обычно называется активным классом или активным объектом.
И диаграмма состояния обычно рисуется для активных объектов.
В чем особенности активного объекта?
Этот объект может управлять другими объектами.
Второй пример.
У него обычно есть свой поток управления.
И три объекта этот автономен.
Давайте попробуем привести пример активного объекта, с которым вы сталкиваетесь каждый день.
А?
Кто?
Кулер.
Кулер, да.
Вот точно каждый день.
А?
Кто?
Да, правильно, светофор.
Я хотел сказать, если вы попали сюда, скорее всего вы с ним взаимодействовали.
Сегодня, да?
То есть этот объект автономен.
Можно ли на него какие-то… Да.
Это следующее, что мы в принципе можем заставить эту штуку работать в независимом потоке относительно нашего программы.
То есть вот наша программа исполняется, да?
А мы можем сказать, давай-ка параллельно создадим сущность, которая обычно называется поток, которая будет принять знак светофора.
То есть у нас получается, мы живем своей жизнью, а светофор живет своей отдельной жизнью.
Да.
Ну, в смысле, это происходит независимо от нас.
Это значит, что у него есть свой поток, в котором он исполняет свои инструкции.
То есть есть поток трапика, да?
Который в машины едет, едет, едет.
А есть отдельный поток, который берет, и вне зависимости от того, едет машина или нет, переключает ему цвета светофора.
Берет и переключает желтого на красный, с красного на желтый, с желтого на зеленый.
Причем, по-моему, фистеховские светофоры более умные.
Они еще в зависимости от времени суток переключают это все по-разному.
Да-да-да.
Там у светофоров бывает такая опция, что с времени суток время на красный, на желтый, на зеленый разное.
Не, на желтый на зеленый разное.
Вот пример, как это рисуется.
То есть у нас у активного объекта есть наборы состояний, есть триггеры, которые переключают эти состояния с одного момента на второй.
Триггер, допустим, term of.
Вот у нас есть банкомат.
Мы включаем триггер, нажми на кнопочку отключить.
И эффект, у нас действительно это цвета светофора.
И переходят в режим out of service.
Но более того, у этого режима могут быть другие подрежимы.
Допустим, а вот если мы с вами захотим обработать режим поступления покупателей.
И то, чтобы вы понимали, это настояние, связанное в том, что автомат не работает.
То есть он не работает.
Он находится в режиме ожиданий.
И дальше, когда мы вставляем в него карту, то у нас появляется следующее состояние.
Мы прочитываем карту, и дальше у нас идет состояние внутри обслуживания пользователя.
То есть состояние внутри состояния.
Вот.
Знаете, как это можно представить?
Все в машину тюринга проходили?
А, ну на матлоге будет скорее всего еще.
Ну, наверное, скоро будет.
Вот.
В общем, когда вы вернетесь к машине тюринга,
теограмма состояния – это та же самая машина тюринга,
ну, немножко другая, но только с ограниченным количеством состояний.
То есть все переходы ясны, видны, куда они ведутся.
Я не знаю, может кто-то из вас более умный,
слушал такое понятие, как конечный автомат?
Вот.
Вот это по факту есть конечный автомат.
Переключение состоянии.
Значит, более того, опять же, дополню,
что эта штука может быть реализована при помощи паттерна под названием состояние.
То есть, если я скажу «состояние»,
то эта штука может быть реализована при помощи паттерна под названием состояние.
То есть, есть отдельный паттерн, который умеет реализовывать такие системы.
Так.
Понятно ли, что мы тут с вами говорим про диаграмму состояний?
То есть, она позволяет отследить внутреннее состояние сложного объекта,
который сам по себе может быть автономен.
А автомат – это автономная история?
Да.
Вот.
Мы можем посмотреть, в каком состоянии она может быть автономной.
Вопрос.
И с примера про систему доставки.
Что у нас в том случае может быть активным классом?
На самом деле, у кого есть состояние?
У заказа.
То есть, когда вы отправляете систему заказа,
у вас заказ начинает, на самом деле, ну, по факту, почти автономно ехать куда-то,
менять свои состояния.
Вот.
Либо кто-то меняет сверху от него состояние.
Вот.
Так, с этим понятно?
Вот.
Такое тоже может полезно.
Так.
А теперь вспоминаем уроки информантики в школе.
Диаграмма деятельности.
С этим вы точно знакомы.
Давайте посмотрим, например.
Узнаете?
Это блок схемы.
Которая обычно...
Ну, либо в рабочих тетрадках.
Вот сейчас смотрите.
Это диаграмма, которая показывает, как организован рабочий процесс.
В общем.
То есть, здесь нет именно линии жизни,
но показано, какое действие, за каким происходит,
и при каком условии мы переходим из одного действия к другою.
То есть, это не активный объект, который меняет какие-то внутренние состояния.
Да, это именно причине за объект.
Причем некоторые... Смотрите, видите вот тут этот?
Жирная полоска есть.
Это так называемые барьеры.
То есть, это штуки, которые должны быть выполнены одновременно
для того, чтобы перейти в следующее действие.
Вот.
Либо параллель...
Либо...
Нет, я вру.
На самом деле, это параллельное исполнение.
Да, это параллельное исполнение.
То есть, смотрите, как только мы переходим в эту ситуацию,
то параллельно можем презентовать свои идеи и записать свои идеи.
Но после того, как у нас с вами эта штука одновременно исполнится,
то мы вставляем вот эту штуку под названием барьер.
То есть, сверху мы распределяем наши потоки на разные подзадачи,
а снизу мы их объединяем.
И дальше мы не можем двигаться до тех пор,
пока мы не выполним два действия, которые были сверху.
Ага.
То есть, смотрите, здесь явно видно, что некоторые вещи можно распараллелить.
И это явно удобно.
Вот.
А чем больше параллельность, тем лучше.
Вот.
В общем, это процесс того, как выводятся идеи.
Это, можете это...
Знаете, что такое brainstorm?
Ну вот, по факту, диаграмма деятельности во время brainstorm.
Можете посмотреть.
Так. Иногда в диаграмме деятельности еще выделяют линии жизни.
То есть, какие действующие лица в ней есть.
Это обычно используется из вариантов использования.
То есть, кто что делает в каждом этапе.
Так.
Понятно ли, что это такое?
И зачем оно нужно?
Ну да, у нас есть сложная процедура.
Допустим, у нас есть вариант использования.
Нам надо показать, каким образом, по каким шагам мы переходим из одного сценария в другой.
Да, если то, то мы переходим туда.
Если не работает, то переходим сюда.
Так.
Ну вот, второй пример.
Это с линиями жизни.
То есть, мы можем сказать, кто за что ответственен в данном варианте использования.
И не поверите, вот как раз вариант использования проще всего переложить на диаграмму деятельности.
После этого.
Вот.
Так, движемся дальше.
Следующая вещь.
Значит, возможно, вы с ними еще не сталкивались.
Кто знает, что такое пакет в языке программирования?
В языке программирования.
Ну, приблизительно, да.
Так.
Товарищи.
Да.
Ну, либо что такое модуль?
Охотновная подсосновенная часть проекта, которая состоит из общих сущностей.
А?
Ну да.
Вот.
И на самом деле в джаве есть как раз такое понятие, как пакет.
То есть, как раз папочка, в которой внутри можно засовывать некоторые по набору файлы.
Вот.
И такая вещь позволяет структурировать наши классы в определенные наборы.
По факту, пакет это набор классов, который объединен по некоторой логической сущности.
То есть, допустим, у нас есть классы, и у него есть наследники.
Почему бы их не вынести в отдельный пакет?
Логично, логично.
Вот пример.
Вот, допустим, смотрите.
Здесь, кстати, мы сразу видим, что у нас есть с вами проблема в архитектуре.
Почему?
Потому что у нас есть с вами пакет.
Банк.
Дальше у нас есть пакет под названием бизнес, и есть пакет под названием управление данных.
И смотрите, в чем проблема.
У нас с вами между бизнесом и управлением данных есть стрелочки в обе стороны.
Да, у нас появляется циклическая зависимость.
Это не есть хорошо.
То есть, надо стараться как можно чаще избавляться от таких циклических зависимостей.
То есть, у нас получается, что классы из шипинга используют класс из шипинга в датаменеджмент, и наоборот.
Ну, я думаю, что в этом ане разбираться потом будет сложно.
Особенно, когда мы пойдем во внутренний пакет и будем смотреть, что в нем происходит.
То есть, по факту, на самом деле, не поверите, диаграммы пакетов строят любое текстовое, любая IDE.
Каким образом?
Догадаетесь?
Ну да, по инклудам, на самом деле, можно разобраться раз.
А во-вторых, просто папки у вас есть.
Скорее всего, в большей части случаев одна папка это отдельный пакет.
Я же надеюсь, вы не пишете код в одном файле.
Ладно, будем отучать.
Вот такой вот пример есть.
Следующая вещь очень важна с точки зрения архитектуры.
Это так называемые диаграммы компонентов.
А в чем она состоит?
Мы можем представить себе, у нас с вами большая-большая система.
Мы что, мы там фиксиков писали, да?
Давайте подумаем, из каких больших составных частей могут состоять фиксики, образно говоря.
Да, у нас есть клиент.
Клиент на чем, скорее всего?
Это какое-то мобильное приложение будет.
Да, то есть у нас появляется фронтендная составляющая в виде мобильного приложения и фронтенда.
Есть бэкэнд составляющая.
В бэкэнд составляющие у нас могут быть всякие компоненты, связанные с оплатой тарифов.
Мы же хотим, чтобы нам деньги приносили.
А? Реклама.
Показывать.
Показ? Я не знаю.
Система, связанная с продажей мерча.
Система, связанная с показом мультиков.
Да, система с хранением данных и так далее.
И это все, на самом деле, уже такие большие компоненты.
И нам надо понять, как связывать эти компоненты между собой.
И вот как раз архитектура начинается в том месте, когда мы смотрим, как выглядят наши компоненты и как они между собой связаны.
Значит, опять же, это диаграмма с сайта.
И здесь сразу мы с вами видим интересную вещь.
Что веб-магазине, мы можем это использовать для первых самых частей, у нас есть три компонента.
Значит, веб-магазин, хранилище данных и система, связанная с аккаунтами.
И в каждой из этой системы есть подсоставная система.
То есть, есть корзина, есть система авторизации.
Здесь у нас с вами есть система клиентов.
Здесь у нас хранятся заказы и так далее.
И видите, вот здесь вот есть вот такие вот перемычки.
Значит, эта перемычка означает, что нам нужен интерфейс для того, чтобы общаться с другим компонентом.
Помните, мы с вами говорили про паттерн-адаптер в прошлый раз.
Да, и вот как раз на каждой перемычке между компонентами нам нужно написать адаптеры.
Вот, и между ними можно установить зависимость.
То есть, нам нужен протокол, который позволяет общаться между частями на разных компьютерах.
Ну, либо на одном компьютере, но как-то разделенным между собой.
Значит, с точки зрения, давайте сразу подчеркну несколько вещей, каким образом можно общаться.
Мы все эти вещи будем говорить про эти вещи будем говорить на семинарах.
Первая вещь, которая есть внутри, зачастую реализована в качестве вызова библиотечных файлов.
Я не знаю, делали обзор по файловой системе Linux на семинарах?
Да, ну, кому-то делать, кому-то нет.
И, наверное, увидели файлики с разрешением либо .dll, либо .so.
Это одно и то же.
Ну, либо .dll, если мы говорим Mac.
На самом деле, это так называемые библиотечные файлы, и на семинаре по семейку вы с вами поймем, как их собирать.
И их особенность, главное, в том, что они подключаются на стадии исполнения программы, стадии runtime.
И по факту мы можем учренить зависимость, разделить зависимость между составными частями при помощи вызова этих библиотек, функций из библиотек.
Другой способ, если у нас есть несколько разных отдельных сервисов, то мы с вами можем сделать следующее.
Мы с вами можем открыть интернет connection на определенном порту.
Например, HTTP протокол работает на порту под номером 80.
Да, то есть есть нумерованные порты.
И получается вот такая вот интересная сущность.
И мы с вами можем описывать протокол взаимодействия между отдельными составными частями.
Вот, когда мы будем говорить про сетевое взаимодействие, вы с этим детально не столкнетесь.
Так, вопросы?
Вот, то есть, смотрите, первая часть, давайте поймем, из каких составных частей это все стоит.
Потому что мне кажется, что у нас потихонечку уже будет все работать чуть-чуть сложнее.
Значит, мы не успели, часть связана с методологиями, ну и хорошо, в следующий раз ее рассмотрим.
Значит, смотрите, первое, что нам необходимо сделать всегда, что мы будем делать, что мы будем делать всегда,
первое, что нам необходимо сделать всегда, давайте я напишу некоторые составные частя,
первое, это определить use-кейса.
Второе, это попытаться в первой итерации сделать диаграмму классов.
После этого, третье, нам необходимо это все попытаться разбить на компоненты.
Четвертое, мы пытаемся с вами use-кейсы перевести в activity-диаграмм,
для того, чтобы понять, какие последности действий.
Пятым шагом, правильно будет объединить классы в некоторые пакеты.
Порядок действий может быть другим.
А шестое, это наложить это все в таймлайн, то есть сделать sequence-диаграмм.
Вот, после этого, после того, как мы это все сделаем, мы можем переформатировать это все в дальнейшем.
То есть, брать после этой штуки и углублять то, что у нас происходит на шаге два и повторять по новой.
И на самом деле, мы с вами понимаем, что если у нас с вами что-то пошло на шестом шаге не так,
то нам, скорее всего, придется это переделывать.
И в зависимости от сложности проекта, нам надо будет понять,
до куда нам надо спускаться и сколько раз этот цикл повторять.
Более того, вот это вот может постоянно меняться.
И зачастую будет меняться в реале.
А вот как эти уже части связаны с разными методологиями разработки,
и что происходит на каждой из стадий, и из каких стадий состоит разработка по,
мы, наверное, с вами уже будем говорить в следующий раз.
Вот, мы поймем с вами, что же за такие умные слова Agile,
что скрывается за словами Scrum, водопад, что такое внедрение, что такое тестирование и так далее.
А после этого мы уже пройдем с вами по интересной технической вещи, связанной с тестированием.
То есть, посмотрим несколько пар, связанных с тестированием.
К этому моменту вы, наверное, уже по теминарской части будете готовы воспринимать материал,
связанный по тестированию.
Вот на этом, я думаю, мы сегодня с вами закончим.
Давайте задавайте вопросы.
Вот.
А если нет вопросов, то тогда я могу сказать всем спасибо, что пришли,
послушали, подписывались.
А если нет вопросов, то тогда я могу сказать всем спасибо, что пришли, послушали.
