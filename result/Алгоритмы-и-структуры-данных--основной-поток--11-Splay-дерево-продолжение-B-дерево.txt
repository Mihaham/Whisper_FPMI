Ну вот, давайте тогда анализировать, чему равно учетное время
вот этой процедуры, что такое аут-зик-зик.
Ну, как обычно, учетное время – это реальное время
плюс разность потенциалов.
Реальное время давайте считать, что это двойка,
потому что здесь всего два поворота, давайте считать,
что поворот у нас работает как бы за одно действие,
грубо говоря.
Мы все равно нигде конкретно не говорим, что такое одно
элементарная процедура, но вот давайте считать, что
все равно константа.
Вот давайте один – это один поворот.
Ну и дальше с рангами, давайте я штрихованными рангами
буду обозначать ранги в этом новом дереве, а обычными
рангами, р-ками, просто ранги в старом.
Тогда у меня разных потенциалов будет вот такой, r' от x плюс
r' от p плюс r' от g минус, ну, r от x минус r от p, давайте
по-другому, здесь у меня будет минус r от g, тут минус
r от p, тут минус r от x.
Ну, потому что ранги меняются только у этих трех вершин,
только у x'a, p и g, потому что в поддеревях a, b, c, d ничего
не произошло, там никаких поворотов не было, там все
ранги у всех сохранились такие же, такие, какие были
раньше.
Ну и в над дереве тоже ничего не произошло, потому
что это поддерево не поменяло свой размер, s от всего этого
поддерева остался таким же, каким был, поэтому для
всех предков все ранги тоже сохранились, изменения
только вот эти локальные в этих трех вершинах.
Ну, хорошо, давайте анализировать, я утверждаю, во-первых, что
вот эти два слагаемых можно сократить.
Ну, вроде понятно, потому что такой r' от x, это двоичный
гриф вот этого всего размера.
Что такое r от g, это двоичный гриф вот этого всего размера.
Ну, понятно, что одно и то же.
Это все мои поддеревья a, b, c, d и три вершинки p, g, x.
То есть вот это вот все и вот это вот все по размеру
то одно и то же.
Значит, ранги у них одинаковые.
Поэтому я могу смело сократить r' от x и r от g, просто потому
что g раньше было корнем вот этого поддерева, а теперь
стал x.
У них одинаковые ранги, их можно сократить.
А, нормально?
Окей.
Ну, а дальше давайте я сделаю такие оценочки, давайте
я замечу, что r от p больше собравно r от x и наоборот
r' от x, нет, нет, нет, да, да, r' от x больше собравно
r' от p.
Значит, что такое r от p, r от x?
Вот они два, да?
Вот они раньше без штриха, значит, в старой картинке.
r от x это логарифм вот этого дерева, r от p логарифм
вот этого дерева.
Ясен пень, что r от p больше, чем r от x, но это первое
неравенство.
И наоборот, в этой картинке r' от x это все вот это, r'
от p это все вот это, опять же ясен пень, что более верхняя
вершина больше, чем нижняя, имеет больше ранг.
Вот, поэтому я здесь могу что-то немножко переписать.
Давайте я напишу, что это меньше обравно все, двойку
оставлю, r' от g оставлю, дальше r' от p оцениваю сверху
как r' от x, минус r от p оцениваю сверху как минус r от x и еще
минус r от x остался, получилось минус 2r от x.
Вот, проверяйте арифметику, то есть просто эти два неравенства
использовал вот здесь, оцениваю сверху таким образом.
Ну вот, а дальше я утверждаю, что эту вещь можно оценить
сверху тремя вот такими разностями, r' от x минус r от x, сейчас
это будем доказывать.
Вот, ну давайте поймем, что вот эта вот неравенция,
которая здесь написана, она эквивалентна следующему,
его можно немножко упростить, что-то подсократить, можно
написать так.
Значит, оно эквивалентно 2 плюс r' от g, смотрите здесь
было плюс r' от x, здесь было 3, поэтому справа остается
2r' от x.
Ну давайте я на лево все принесу, минус 2r' от x,
значит это вот это с этим сократилось и тут остается
минус 2r, а справа минус 3r, если все принести на лево
будет плюс r.
Я утверждаю, что вот это обведенное неравенство
эквивалентно вот этому, просто все перенес справа
на лево.
Да?
Хорошо.
Вот, ну давайте теперь тогда, давайте я тогда сделаю следующее.
Так, видимо я зря перенес лево, давайте направо все
уберем обратно и перепишем немножко по-другому.
r' от g плюс r' от x минус r' от x.
Это то, что мне нужно, сейчас посмотрим, или надо наоборот
оставить минус r'.
Да, sorry, sorry, sorry, последнее забудьте.
Мы так далеко не уедем, наоборот, я все правильно перенес,
давайте я просто 2 туда перекину, здесь оставлю r' от g
минус r' от x плюс r' от x минус r' от x, а 2 просто пошла
направо, минус 2, вот, мне достаточно доказать такое
неравенство.
Вот, ну давайте смотри, что такое минус r' от x, вот
вот я его здесь специально вынес, так чтобы оно было
одинаковое в обоих слагаемых, вычитаемые, в обеих скобках,
тут минус r', тут минус r', что такое r', это двуечный
грифом всего этого безобразия, что такое r' от g, это вот
это, что такое r' от x, это вот это.
Давайте как это обозначим.
Ну окей, давайте перепишем, смотрите, r' это у меня логарифмы
размеров по деревьев, разность логарифмов это логарифмы
отношения размеров, поэтому первая скобка можно писать
так, двуечный логарифм нового размера s' от g поделённым
на старый размер s' от x, вторая скобка переписывается
как двуечный логарифм s' от x делённым на s' от x, да,
потому что rank это логарифм размера, ну и разность логарифмов
это логарифм отношения.
Вот, мне надо показать, что это минус два.
Вот, тут должно быть понятно уже почему это верно.
Давайте обозначим вот это вот за a, например, за b.
Скажите, пожалуйста, какое-нибудь неравенство на a и b, вот глядя
на эту картинку.
То есть мы знаем, смотрите, a это что такое, a это отношение
вот этого всего g, c и d ко всему дереву, b это вот это, отношение
вот этого вот дерева x, a и b ко всему дереву.
Что, например, можно сказать про a плюс b?
Ну так нельзя сказать, потому что a это всё-таки отношение
положительных чисел, но вряд ли будет отрицательным.
Давайте про a плюс b сразу.
A плюс b не больше, чем 1, потому что, смотрите, ещё раз,
a это отношение вот этого поддерева ко всему, то есть g, c и d ко всему
вот этому поддереву, вот оно a, а вот оно b, это отношение
вот этого размера ко всему.
Ну и как видим, они в объединении даже меньше, чем всё дерево,
то есть здесь было x, a и b, здесь g, c и d, они в сумме даже
всё не покрывают, потому что отсылается непокрытое
p, поэтому там даже не меньше левровно, а строго меньше,
потому что p не входит.
Вот, ну и теперь осталось показать, что если у меня
есть два положительных числа, понятно я, что они положительные,
потому что это отношение положительных чисел, мне
достаточно доказать, что если их сумма не больше
единицы, то сумма их логарифмов меньше левровно минус двойки.
Вот, ой, b потерялась.
Ну давайте перепишем, значит, это не равен свеколентно
следующему.
Сумму логарифмов я напишу как логарифм произведения.
Вот, ну а, например, отсюда я могу сделать вывод о том,
что a, b не больше, чем, кажется, одна четверть.
Если у меня есть два положительных числа, суммы не больше, чем
один, то их произведения максимальны в случае, когда
они равны, значит их произведения не больше, чем одна четверть.
Значит, вот отсюда мы знаем, что a, b не больше, чем одна
четверть, значит это автоматически следует.
Вот, кажется так.
Да, значит, кто не хочет следить за арифметикой,
мы доказали, что учетная стоимость зиг-зига не больше
чем вот это, оценивается сверху таким выражением.
Кто хочет последить за арифметикой, спросите вопрос.
Потому что, смотрите, а это что такое, это s'g делить
на s'x.
Давайте на картинке посмотрим.
s'g это размер вот этого всего, g, c и d, s'x это все вот это.
Что такое отношение?
А отношение это количество вершин вот здесь поделить
на количество вершин вот здесь.
Что такое b?
Это s от x делить на s' от x.
То же самое, b это вот это вот, ну не b в смысле, а s от x
это вот это, s' от x это все вот это, значит b это отношение
вот этого человеческого ко всему, но они в объединении
даже все не покрывают, поэтому сумма маленькая.
Норм?
Вот это?
Ну потому что это одно и то же буквально, s' от x от
двоичного грифма вот этого всего, а rg от двоичного грифма
вот этого всего, но тут одинаковый число вершин.
Сойдет?
Ну балдеж.
Вот, значит, нам осталось разобраться с зиг-зигом.
Давайте картинка, ой, пардон, зиг-загом.
Зиг-загом, да, значит, мне нужна тоже картинка, зиг-заг
мы применяем в случае, когда x не корень и не сын
корня, и при этом x и его родитель находятся по
разных сторонах своих родителей, то есть, например, картинка
вот такая.
Вот, в этом случае я, наоборот, сначала вращаю нижнее
ребро, потом верхнее, ну и после этого, значит, у
меня x вылезает в корень, p остается слева, уже справа.
Тут переподвешивается abcd.
Опять же, кто записывал в прошлый раз, проверьте,
что картинка такая же, пожалуйста.
Похоже?
Отлично.
Ау?
Зиг-заг написано, над вершиной же еще какой-то путь до корня.
Это зиг-заг, название операции.
Вот, ну давайте анализировать аналогично.
Что такое зиг-заг?
Точнее, учетная стоимость зиг-зага.
Это, как обычно, два, плюс разных потенциалов, потому
что я считаю, что у меня всего два поворота, поворот
это элементарное действие, двойку пишу, вот, ну и плюс
разных потенциалов.
Тут то же самое, значит, плюс r' от x, плюс r' от p, плюс
r' от g, минус r' от x, минус r' от p, минус r' от g.
Смотрите, учетная стоимость, это всегда реальное время
работы, плюс разных потенциалов.
Давайте вот так вот напишу, а, это всегда t, плюс дельта
фи.
Ну не всегда в смысле, а если мы рассматриваем метод
потенциалов, то мы говорим, что учетное время работы
каждой операции, это реальное время работы, плюс разных
потенциалов.
Ну как бы после операции, минус перед операцией.
Вот.
Двойка как раз соответствует реальному времени работы.
Ну что такое реальное время работы?
Что мы реально делаем, когда выполняем зигзаг?
Мы делаем два поворота, сначала вот такой, потом
вот такой.
Ну вот я говорю, что пусть поворот работает за одно
действие.
На самом деле там типа за пять, но неважно, мы можем
так масштабировать, как бы, ну, я нигде не говорю, что
такое элементарная операция.
Вот, давайте считаем, что элементарная операция
это поворот.
Это всё равно константа, да, это не влияет на симпточку
нигде.
Вот.
Так, ну здесь первый шаг такой же, что у меня вот
это вот и вот это вот сокращается.
По тем же причинам.
И давайте опять же оценим r от p снизу через r от x.
Вот.
Тогда эта вся сумма будет не больше чем два плюс,
эти сократились, r штрих от p плюс r штрих от g, минус
r от p оцениваю сверху, как минус r от x, остается минус
два r от x.
Вот.
И это я утверждаю не больше чем удвоенная разность
рангов r штрих и r.
Вот, опять же, это неравенство я утверждаю, сейчас буду
доказывать.
Вот.
Ну, заметим, что если мы это докажем, то отсюда
немедленно будет следовать, что эта штука не больше
чем утроенная разность этих рангов, r штрих от x минус
r от x.
Ну, потому что ранг x только возрастает при подъеме,
значит эта штука не отрицательна и можно сказать, что две
не отрицательные штуки не больше чем три не отрицательные
штуки.
Так, ну давайте переписывать, я утверждаю, что верно вот
это.
Почему?
Опять, тут много чего сокращается.
Давайте проследим, что именно, видимо r штрих от p, r штрих
от g сохраняются.
Минус два r от x было здесь, минус два r от x было здесь,
они полностью умерли.
Осталось минус два r штрих от x.
Надо показать, что эта штука не больше нуля.
Вот, ну делаем то же самое, значит двойку туда перебрасываем,
r штрих от x группируем по отдельности с этим и с этим,
получаем следующее эквивалентное неравенство.
r штрих от p минус r штрих от x плюс r штрих от g минус r штрих
от x.
Вот это вот надо показать, что не превосходят минус
двойки.
Ну а дальше такое же рассуждение, просто давайте посмотрим
на этой картинке, что такое r штрих от p, ну так же давайте
перепишем, что это такое.
Это двоичный алгорифум s штрих от p делённый на
r штрих от x, а это двоичный алгорифум s штрих от g делённый
на r штрих от x.
Надо показать, что это не больше, чем минус два.
Это доказывается точно так же, потому что вот это
отношение, что такое, смотрите, это вот это вот поделить
на весь размер дерева, а правая штука, это вот это
вот поделить на весь размер дерева.
Опять сумма их не превосходит единицы, значит сумма двоичных
алгорифумов не превосходит минус двойки.
Точно такой же аргумент, просто другая картинка.
вот оно первое слагаемое, вот оно первое слагаемое, вот оно второе слагаемое, будьте здоровы, вот можно
поверить? Вопросы? Чудно. Хорошо, значит смотрите, что мы показали? Мы показали, что зиг-зиг не больше чем
вот это учетно, зиг-заг не больше чем то же самое. И давайте вспомним, что у нас было просто для процедуры
зиг, там было единица плюс утроенная разность рангов. Напоминаю, что было в конце прошлой лекции, мы
доказали, что эта штука не превосходит единице плюс утроенная разность рангов. Вот. Ну тогда я
утверждаю, что отсюда немедленно следует, что суммарно учетное время работы сплея не превосходит
единицы плюс утроенный, давайте так напишу, rank final, где-нибудь вот здесь final, да, типа конечный
rank x-а, минус rank initial, минус изначальный rank x-а. То есть то же самое, я не хочу просто перемешивать
здесь штрихи, потому что штрих это у меня как бы одна операция, там, зиг-зиг-зиг или зиг-заг, здесь
это как бы вот после всех этих операций конечный rank минус начальный. Вот. Ну почему? Потому что,
вспоминаем, сплей это сначала последовательность зиг-зигов или зиг-загов, ну так как надо, да, то
есть мы смотрим на x-а и его родителя, по одной стороны или по разной от родителя, если по
одну то зиг-зиг, если по разной то зиг-заг, и так делаем, пока либо x не попал в корень, либо x не
стал сыном корня. Значит у меня всегда сплей это последовательность зиг-зигов и зиг-загов и
возможно плюс один зиг в конце. Вот. Ну отсюда как раз все получается. Вот, значит, давайте
предположим, что у меня есть сначала какая-то цепочка зиг-зигов и зиг-загов. Вот. Ну и rank x-а как
-нибудь менялся. Давайте скажем, что у меня изначально был rank нулевой от x, потом после первого,
скажем, зиг-зига у меня стал rank первое от x, потом rank второе и так далее, вплоть до какого-нибудь там
rank k-та от x. То есть вот. Сначала в течение k шагов мы делали зиг-зиги или зиг-заги, вот так изменялся
rank. И потом в конце еще в худшем случае произошел один зиг и у меня rank стал какой-то финальный rank x-а.
Ну, значит, ну тогда смотрите, я знаю за сколько учет работает каждый из вот этих переходов. Все
зиг-зиги и зиг-заги. Вот эта штука работает не больше, чем учетно утройная разность рангов r1 от x
минус r0 от x. Потому что мы знаем, что зиг-зиг и зиг-заг работают не больше, чем утройенная разность рангов
конечные после операции минус начальный. Поэтому здесь учетное время работает не больше, чем тройка на
разность рангов. То же самое здесь. Вот эта вот штука, вот этой действия работает не больше чем 3 на r2 от
x минус r1 от x. Потому что до операций был такой rank, после операции такой rank. Ну и так далее.
Вот. Но на последнем шаге мы получаем, что учетное время работы вот этого последнего шага не больше чем 1 плюс утройная разность рангов.
Ранг финальный минус ранг катый. Ранг финальный минус ранг катый.
Ну вот, если все просуммировать, понятно, здесь все сократится, вот эти товарищи сократятся, вот этот сократится, вот этот сократится,
останется как раз в точности 1 плюс утройная разность, ну короче вот ровно вот это получится.
1 плюс утройная разность, конец минус начала.
Так, нормально?
Ну вот.
Ну я вот решу свою штуку этого вот логарифма.
И это совсем просто. Потому что что здесь написано? Тут написано 1 плюс утройная разность рангов, а ранг этот двоичный логарифм какого-то размера под дерево.
Ну всего в дереве понятно не больше чем n вершин, значит любой ранг всегда не больше чем логарифм, ну и всегда не отрицательным.
Значит здесь стоит не больше чем логарифм, тут из него даже что-то вычитается, ну значит понятно, что суммарно это не больше чем 1 плюс 3 логарифма, это все от логарифма.
Да?
Ну отлично, мы доказали, что учет на время работы сплоя это от логарифма.
Вот, собственно, то что мы хотели.
Отсюда в общем-то следует все что нужно.
То есть смотрите, мы что сделали? Мы свели, точнее мы сказали, что после каждого запроса там find, insert или erase я запускаю сплей.
И вот он работает учет на логарифм.
Ну и тогда как бы понятно, что, давайте неформально скажу, смотрите, у меня find, за сколько работает find?
Грубо говоря, он сначала дошел от корня до икса, ну там нашел или не нашел, прошел какое-то расстояние.
И потом после этого вызывается сплей, который поднимает вот эту последнюю вершину в корень.
То есть что-то там поднимает, какие-то повороты делают, зигзаги и так далее, поднимает икс в корень.
Ну понятно тогда, что время работы реальное find и сплея примерно одно и то же.
Потому что find спускался там, вот представьте, что он спустился на глубину h.
Потом сплей его поднял вверх на ту же самую глубину h, значит он поворотов сделал как раз h.
Поэтому у них время работы примерно одинаковое.
Но если мы понимаем, что учетное время работы сплея алгорифм, то всего на стрете тоже учетное время работы алгорифм.
Но здесь надо немножко аккуратнее на самом деле сказать, давайте я немножко про это скажу.
Вот смотрите, мы оценили, например, учетное время работы сплей.
Давайте оценим учетное время работы find.
А тут совсем все просто.
Вот такое учетное время работы find.
Это реальное время работы плюс разных потенциалов.
Ну find потенциал и не меняет, find сам по себе потенциал и не меняет,
оно они просто спускаются, он дерево никак не меняет, потенциал в нем не меняется.
Структура дерева не меняется.
Поэтому остается только реальное время работы.
Мы знаем, что реальное время работы такое же, как в сплее.
И мы его в каком-то смысле реальное время работы
файнда учли в сплое.
Давайте я так напишу, что здесь find не изменяет потенциалов,
и при этом реальное время работы файнда такое же,
как у сплоя.
Потому что если мы спустились на глубину h, то мы потом
его подняли с помощью сплоя как раз за h действий.
Ну вот, о, пардон, извините, опечатка, здесь т, конечно.
Реальное время работы файнда такое же, как у сплоя.
Почему, смотрите, что такое find?
Это мы встали в корень и как-то шли в поиск х, нашли
или не нашли, дошли до какой-то вершины.
Вот пусть мы здесь делали h действий.
Реальное время работы файнда на самом деле равно просто
глубине от корня до той вершины, которой мы дошли.
Вот это вот это вот.
Что дальше происходит?
Дальше вызывается сплей автоматически.
Мы всегда после выполнения каждого запроса делаем
сплей от последней посещенной вершины.
Ну, за сколько работает сплей для этой вершины?
За h.
Потому что сплей все, что делает, он просто текущую
вершину поднимает в корень и делает это, ну, как бы
поворачивает тут какие-то ребра.
Суммарно поворотов ровно столько, какой h.
Поворот за единичку работает?
Да, мы считаем, что за единичку.
Ну вот, тогда утверждается отсюда следует, что out
find есть от логарифма тоже.
Да, потому что время работает там такое же, как в сплее,
потенциалы вообще не меняются.
Вот, поэтому...
Ну, давайте так напишу.
Нет, да, все нормально, все нормально.
Вот.
Поэтому, грубо говоря, учетное время такое же, как у сплея.
Да.
Как такой переход делается, что мы сравнили out find только
с t от сплей, а не с a от сплей?
То есть мы в учетное время сплея обошли логарифм,
а настоящий время работает только с t от сплей?
Тако мне не надо настоящий, мне только учетное важно.
Ну, мы сравнили t от find с t от сплей.
Да.
Ну, смотрите еще раз.
Окей, значит, смотри, что такое out find?
Вообще, на самом деле...
Так, давайте попробуем их объяснить.
Смотрите, давайте полностью напишу, что происходит во
время ответа на запрос find.
Сначала я спускаюсь в дереве на глубину h.
Реально время просто h в поисках x.
За это у меня разных потенциалов не изменилось, потому что
дерево не поменялось.
После этого вызывается сплей.
Время его работы тоже h.
И на сколько-то поменялся потенциал.
На какой-то delta phi.
Из-за вот этих поворотов как раз меняется структура дерева.
Давайте я вот так сделаю.
Нет, плохо.
Как бы сделать, чтобы было не очень плохо?
Значит, тогда, что такое out find?
Out find – это удвоенная h плюс delta phi.
Потому что я сначала вниз спускаюсь на h, потом
вверх поднимаюсь на h, и при этом
разных потенциалов поменялось на delta phi из-за сплея.
Учетное время – это реальное время плюс
разных потенциалов.
h плюс h – 0 плюс delta phi.
А мы с вами знаем, что эта штука –
это от логарифма.
Сумма h и delta phi – это от логарифма.
Но от того, что здесь напишу 2, а не 1.
У меня на самом деле анализ сохранится такой же,
как был.
Я знаю, что h плюс delta phi –
это от логарифма.
От того, что у меня добавилась h,
от этого у меня было бы
вместо 2 – 4.
И у меня анализ был
сохранился полностью.
Опять же, вот эту штуку
Для полного лоска
мне нужно было бы здесь
потенциал заменить на
удвоенный потенциал от исходного.
Я знаю, что h плюс delta phi –
это от логарифма.
Но если бы у меня было
2h плюс 2 delta phi,
было бы тоже от логарифма.
И если бы у меня изначальный phi
удвоился,
тогда у меня было бы
удвоенный логарифм.
Но опять же,
проблема возникает только из-за того,
что я проанализировал h плюс delta phi,
а здесь 2h плюс delta phi возникает из-за того,
что я спускаюсь вверх и вниз.
Это все чинится тем,
что надо подправить определение элементарной операции.
У меня раньше был поворот. Давайте теперь скажем,
что поворот делается за одну-вторую элементарную операцию.
Это констант, она на анализ не влияет.
Поэтому вот здесь
двойка тут написана
или просто h, с точки зрения суммы
и метапотенциалов,
это все можно считать просто h плюс delta phi.
Остается логарифм.
Аналогично со всякими инсертами и рейзами.
Давайте инсерт нарисуем.
Давайте инсерт нарисуем.
Как работает инсерт?
Он сначала
куда-то в дереве спускается,
находит подходящее место для x.
Он как-то спускается
и куда-то подвешивает x.
Потом от него запускает сплей.
Мне нужно показать,
что когда я подвешиваю x,
у меня не очень сильно портится потенциал.
Потому что я знаю, что сплей
после этого учетно работает за логарифм,
но надо еще понять,
какая разница потенциалов при подвешивании x.
Равна delta phi при подвешивании просто.
Насколько меняется потенциал при подвешивании новой вершины.
Я подвешиваю, чтобы будет
тоже не больше логарифма.
Интуитивно смотрите,
почему в худшем случае
вообще насколько
поменялся потенциал.
У всех этих вершин
увеличился размер по дереву на 1.
Значит у них ранг тоже чуть-чуть увеличился.
Скажем, если вот здесь было
10 вершин в размере
в этом по дереве,
то логарифм был лог 10 и стал лог 11.
Ну и так далее.
То есть у всех этих вершин немножко поменялся ранг.
Если здесь был какой-то размер
SOV,
то он станет SOV плюс 1.
Ну и то же самое с рангом происходит.
Было лого t, стал лого t с плюс 1.
Но я утверждаю, что сумма изменений
всех этих логарифм будет маленькая.
Потому что насколько в худшем случае
у меня изменился потенциал.
Не больше, чем на логарифм
ну скажем там
1 минус логарифм 0,
плюс логарифм 2 минус логарифм 1,
плюс и так далее,
плюс логарифм n,
минус логарифм n минус 1.
Да, это правильное замечание.
Но его не было раньше, да.
Его не было, а теперь появился,
у меня просто появилось новое слагаемое
в потенциале.
Вот это соответствует иксу,
вот это родителю икса и так далее.
Но опять же здесь все сократилось,
осталось только лог n.
Поэтому суммарное изменение потенциала
тоже максимально лого.
А значит у меня все хорошо.
То есть у меня инсерт работает
за учетное время инсерта.
Вот эта вот глубина плюс разным потенциалов,
а мы знаем,
и перед этим разным потенциалов небосьчим логарифм.
И мы знаем, что вот эта вот глубина плюс
разным потенциалов оценится сверху еще логарифмом.
Поэтому суммарно
аут инсерта
работает за логарифм.
Ну и то же самое с эрейзом.
Уже не буду то же самое проделывать.
Вот.
Ну это детали.
На самом деле можно
понимать так,
что я все равно, я свожу
любой find, insert или erase,
я после этого вызываю сплей.
Поэтому в каком-то смысле время работы
инсерта find и erase
оценится сверху
время работы сплея.
Но если я про сплей доказал,
что оно учетано логарифмично,
то и все эти тоже учетано логарифмично.
Надо только аккуратно еще сказать,
что разным потенциалов тут небольшая будет
после инсерта или эрейза.
Но это делается.
Ну что?
Вопросы?
Хорошо.
Хорошо.
Ладно.
Давайте тогда покажем,
что сплей еще умеет отвечать на
те самые опциональные запросы,
merge и split.
Merge.
Вот представьте, у вас было два корректных сплея дерева,
вы хотите их склеить, хотите их объединить.
Так.
Ну это не всегда работает, да, видимо.
Работает только, если
все ключи одного меньше ключей другого.
Да.
Это работает только в предположении,
что все ключи,
ну все элементы в смысле, все элементы
левого дерева
меньше всех ключей правого.
Тогда, как можно, например, сделать merge?
Ну, смотрите, давайте я найду
самое большое число в левом дереве.
Максимальное число в левом дереве.
Это делается просто.
Я встаю в корень, иду направо, пока можно.
Вот я встал в корень, иду направо,
направо, направо в правый сын,
и пока есть правый сын.
Таким образом дойду до какой-то вершинки x,
который, я утверждаю, будет максимально
в этом дереве.
Ну, потому что все, что левее, оно меньше,
а правее никого нет.
А мы такое уже делали, когда искали
минимум в дереве и шли налево.
Тут, наоборот, давайте найдем максимальное число
здесь. Давайте вызовем
сплей.
Будьте здоровы. Сплей от x.
Тогда левое дерево у меня
перестроится так, что x станет корнем.
Причем, поскольку он был максимальным, у него не будет
правого сына. И все левое под дерево
целиком уйдет влево.
То есть все, что было здесь, вот это t, оно
станет теперь вот здесь.
У него не будет правого сына, потому что
оно было максимально, значит
никаких правых потомков у него быть не может.
Ну, а после этого я просто могу взять подвес
вот это сюда, и у меня будет корректный мерч.
Вот если это какой-нибудь
t-штрих, я просто беру и
объявляю правым сыном x,
то самое дерево t-штрих.
Все.
Ключи правого.
Что значит ключи правого?
Пардон, элементы, элементы. Извините.
Тут элементы, тут элементы тоже.
Ключи, элементы я буду смешивать.
Это одно и то же.
То, что лежит в вершине.
Ну опять же, здесь можно аккуратно проанализировать,
показать, что учетное время работы тоже будет
логарифмическим. Потому что по факту
все, что я сделал, запустил сплей, подвесил вот
это сюда, но надо еще аккуратно посмотреть,
что происходит с потенциалом, когда я
делаю такое подвешивание.
Но потенциал меняется на
логарифм этого дерева,
был какой-то логарифм x раньше,
точнее все, что было здесь,
он поменялся на
еще что-то, потому что к нему что-то подвесилось.
Но логарифм один стал другим,
разность все равно логарифмическая примерно.
Поэтому время работы мержа
тоже амортизировано логарифм.
Ну и сплит давайте.
Сплит по значению k.
Напоминаю, это процедура,
которая требует от меня разбить
одно большое дерево на два,
таких, что в левом все ключи не больше k,
а в правом все больше, чем k.
То есть у меня было одно большое,
я хочу его разбить так,
что в левом все элементы не больше k,
а в правом все больше k.
Вот.
Ну здесь какая-то похожая идея.
Давайте мы сначала найдем
наибольший элемент не больше, чем k.
Найдем наибольший элемент
не больше, чем k.
Это можно сделать простым спуском по дереву.
Встали в корень,
если он больше, чем k, то нужно пойти влево,
иначе и направо.
Тем самым мы найдем максимальный элемент
не больше, чем k.
Вот нашли.
Давайте от него вызовем сплей.
Давайте скажу, что пусть это x,
вызовем сплей от x.
Тогда он у меня поднимется в корень,
слева будут все еще меньше,
чем x числа,
а справа будут все больше, чем x.
Тут меньше, чем x, тут больше, чем x.
Ну и поскольку x у меня был
наибольшим, меньше, либо больше,
то здесь все числа будут в частности
больше, чем k,
потому что они больше, чем x,
значит они больше, чем k.
А раз x наибольший, меньше,
то все, которые больше, больше, чем k.
Ну и мы получили то, что нужно.
Можно объявить вот это вот левым деревом,
а вот это правым,
потому что здесь все ключи меньше, либо равные,
а здесь больше.
Мы еще меньше, либо равные,
поэтому идем влево.
Вот.
Хорошо.
Ну и тут тогда,
значит, если мы научились
делать merges-play,
то мы будем делать
если мы научились делать merges-play,
можно решить задачу.
Как это? Сейчас скажу.
Ну да.
Давайте поговорим тогда про неявное дерево поиска.
Чуть-чуть.
Вот.
Значит, это, например,
то, чем можно решать задачи следующего типа.
Представьте, у вас есть какой-то массив,
и вы хотите над ним проделывать
какие-то операции,
ну там, не знаю, вырезание, удаление,
что-нибудь такое, то есть у вас как бы надо поддерживать порядок элементов,
слева-направо, 0, 1, 2 и так далее.
И, например, надо, ну не знаю,
вырезать какой-то кусок массива и переставлять
в другое место. Или там просто взять и удалить элемент.
Да, это вот то, что мы
когда-то хотели научиться делать erase
по позиции.
Ну давайте я скажу, что какой-нибудь erase,
а, например,
аитова.
То есть я хочу удалить этот элемент
и как бы склеить две оставшиеся части массива.
То, что было левее, то, что было правее.
Я один элемент выбрасываю, а все, что осталось левее-правее, склеиваю.
Ну и, наоборот, например, insert.
Аитоя в данную позицию
между двумя числами вставить какое-то новое число.
Вот.
Ну и там, не знаю, еще что-нибудь.
То есть такие запросы, которые
меняют структуру вашего массива.
Меняют порядок элементов, вставляют элементы, удаляют.
С порядком элементов
что-то делают.
Ну тогда можно
хранить это все. Давайте хранить массив
в дереве поиска.
Храним массив
в дереве поиска.
Да.
Ну, не важно.
Как определено, так и будет.
Главное, что однозначно определено.
Так.
Что-то я хочу сделать, нет?
Давайте пример какой-нибудь нарисую, наверное.
Вот.
Значит, давайте построим
дерево поиска,
воспринимая, что у меня
как бы они отсортированы.
То есть у меня же ведь
дерево поиска настроится на каких-то элементах.
И там элементы между собой сравнятся.
Давайте считать, что элементы
это индексы в моем массиве.
Ну, я не знаю,
как это сделать.
Я не знаю, как это сделать.
Я не знаю, как это сделать.
Это индексы в моем массиве.
Ну, например, не знаю,
пусть корнем там будет, скажем,
вот это вот число
минус три.
Слева у него там будет
что-то типа там вот так вот, например,
один, два, семь.
И здесь, например, четыре, минус один.
Вот, например, так я могу хранить этот массив.
Знаешь, что в корне минус три
это вот это.
Левее него в порядке
один, два, семь. Вот они, один, два, семь.
Справа минус один, четыре.
То есть, дерево можно представлять таким образом.
Точнее, массив можно представлять таким деревом.
Вот.
Ну, то есть, смотрите, оно не явное,
потому что если я воспринимаю вот эти
числа как ключи, как элементы,
которые сравниваются, это не дерево поиска.
Потому что у меня
ну, много почему.
Блин, а как оно получилось деревом поиска у меня?
А, не, все-все. Вот, например, да, потому что
слева от минус тройки лежит двойка.
Это не дерево поиска, потому что вот здесь, например,
нарушается неравенство. Вот.
Но это именно будет деревом поиска,
если я в качестве ключа
буду воспринимать номер элемента.
То есть, на самом деле, вот это вот,
это тройка, типа вот номер,
номер в исходном массиве, это тройка,
здесь это единица,
это, соответственно, ноль, это два,
это четыре, это пять.
И тогда это как раз будет дерево поиска.
В вершинке три, то есть вот этот элемент,
слева 0.1.2, справа 4.5.
Вот. То есть, если бы я как бы мог у каждой
вершины в качестве ее ключа,
по которому они сравнятся, хранить индекс,
тогда было бы дерево поиска, корректно.
Вот. Но если я храню у всех индекс
в явном виде, то мне проблемно
делать всякие инферсы. Например, если я хочу вот сюда
что-то ставить, какой-то новый х,
тогда мне нужно
у всех вот этих товарищей изменить индекс.
Но это та же самая проблема, что у массива.
Если я вставляю между двумя элементами,
то у меня изменяется нумерация.
И мне как бы нужно было бы тогда вот здесь сделать
ко всем товарищам плюс один в ключ,
в индекс. Я не хочу такого
делать.
Поэтому дерево на той и неявное,
что я явным образом эти индексы хранить не буду.
Но я их всегда могу восстановить по картинке.
Смотрите, вот я индексы стер,
но их можно однозначно
восстановить. Их очень легко понять.
Потому что что такое, например, самый левый
элемент массива?
Это самый левый элемент дерева.
То есть, да, у него минимальный индекс,
он должен быть минимальным элементом в плане ключей в дереве.
Мы знаем, что минимальный всегда самый левый.
Поэтому здесь ноль.
Где лежит вот этот товарищ?
Ну понятно, что вот здесь.
Потому что это второй по минимальности
элемент во всем дереве. Тут один.
Ну и так далее.
Поэтому на самом деле, даже если
индексы я сотру, я могу это восстанавливать всегда
легко потому, что я знаю, что, скажем, вот эта
вершина, это какой-то элемент дерева,
какой-то элемент массива
Все что левее находится левее в массиве
Вот минус тройка, вот она.
Все что левее находится левее, все что правее находится правее.
Поэтому, на самом деле, я утверждаю, что
чтобы хранить... Чтобы уметь
восстановить индексы, достаточно
хранить размеры под деревьев.
Например, если я знаю, что здесь размер Davis под дерево
3, то
Индекс этого элемента в точности будет 3, потому что перед ним идет 3 элемента 0,1,2, и он будет третьим.
Вот здесь, например, у этого чувака левое поддерево имеет размер 1, поэтому размер этого поддерева 1.
У этого чувака индекс будет 4, потому что до него идет целиком вот это поддерево, корень, а дальше он сам, то есть 0,1,2,3,4.
Вот, поэтому на самом деле из размеров поддерева, из размеров всех поддерева все будет пересчитываться.
То есть индексы я всегда могу восстановить через размеры поддерего.
Ну и дальше, уже тогда я могу хранить, я могу просто сказать следующее, я не буду хранить ключи, я не буду хранить индексы, вершин, в массиве,
просто скажи, что они восстанов martyrs размеры поддерев, а вот размеры поддерев я буду хранить.
хранить. Ну и тогда, например, как сделать инсерт x на позицию между нулевым и первым элементом.
Ну, смотрите, если я до вершины до этого дошел как-то, как я дохожу до вершины, я только
из корни до нее дохожу. Поэтому все, что я здесь обхожу, я всю нужную информацию могу передать. То есть,
не то, что я стоя в вершине, могу понять, какой у нее индекс, но, по крайней мере, я,
идя из корни, я могу понять, какой у нее индекс. А, так вот, все, что-то я торможу. Смотрите,
теперь, получается, у меня есть дерево, у меня есть дерево поиска, например, с Play. Давайте тогда,
чтобы сделать инсерт аито, вот не знаю, был у меня такой массив, который был представлен
как дерево. Я хочу между какими-то двумя элементами что-то вклинить. Давайте я сделаю сплит.
Давайте я поспличу, то есть, я передам в качестве k как раз столько элементов, сколько мне нужно
отрезать слева. Он мне рассплитит все моё дерево на два куска, вот на это вот и на вот это вот. То
есть, у меня теперь как бы индексами выступают, pardon, ключами, да, элементы, которые я сравниваю в
дереве. Являются индексы в массиве, мне нужно как раз первые k отрезать. Ну вот, я отрезаю с
помощью сплита. У меня получается два с Play дерева, вот такое и вот такое. Теперь я между ними хочу
вставить новое число x и склеить все в одно большое дерево, но это мерч же. Мерч вот этого, вот этого и
вот этого. Получится новое с Play дерево, в нем индексы не хранятся, но хранятся размеры под
деревьев. У меня теперь будет корректное дерево в том смысле, что сначала идут все вот эти
элементы, потом x, потом все вот эти элементы в том же порядке, в котором они были раньше. То есть,
после мерча у меня будет как раз тот самый массив, который был изначально со вставленным x. Ну все.
Вот. То же самое с Erase. Чтобы что-то удалить из массива, мне нужно расплитить, ну давайте вот,
у меня был такой массив, мне нужно удалить, скажем, вот этот элемент y, его надо удалить. Ну тогда
давайте, если мы знаем, то есть у меня Erase по номеру, какой-нибудь там, индекс i, тогда мне нужно
вот эти вот первые и минус один элемент отрезать слева, и справа отрезать все остальные там n минусы,
и дальше вот эти два смержить. А про y забыть. Опять у меня останется дерево, построенное сначала
по этим элементам, потом по этим, как раз в том же порядке, в котором были раньше, только уже без
y то, что нам и нужно. Вот. Поэтому теперь мы все такая операция научились делать за логарифм в
cosplay дерева, например. Нет, нет, нет, нет. Мы храним только размер под дерево целиком. И утверждаем,
что если мы знаем размеры всех под деревьев, то мы любой вершины при необходимости знаем ее индекс.
Вот. Хранить сами индексы, это плохо, потому что нам тогда их надо пересчитывать обильно. А
размеры под деревьев пересчитывать почти не надо. То есть во всяких там поворотах, во всяких при
подвешениях индексы считаются сложно, потому что там, грубо говоря, много индексов заменяется.
А размер под дерева меняется только там один или два. При повороте у вас меняется всего два
размера под деревьев. Если вы их все считаете, то у вас, если вы все обновляете, то у вас размеры
под деревьев будет корректно всегда посчитано. Так, ну че? Окей.
Хорошо. Хорошо. Так, тогда давайте пойдем дальше. Посмотрим еще одно дерево поиска,
называется бедерево. Вот. Значит, ну мы понимаем, чем нам полезно сплэй-дерево. Во-первых,
тем, что оно хранит недавние элементы близко к корню. Если какие-то запросы часто повторяются,
то мы на них быстро отвечаем. Быстрее, чем глубина. Вот. Бедерево нужно будет, ну точнее,
полезно в случае, когда у вас очень-очень-очень большая какая-то база, которую вы храните в
дереве поиска, и вы не можете ее даже в оперативку поместить. Она находится где-то у вас там,
на жестком диске или где-то на большом облачном хранилище, есть огромная база данных, представленная
в виде как раз бедерево. Вы не можете ее целиком себе подгрузить в оперативку, у вас просто не
столько ресурсов. Вы можете ее подгружать только небольшими блоками, небольшими страничками,
там не знаю, сколькими-то мегабайтами. Вот. И теперь у меня как бы вершина, это будет как раз то,
что я подгружаю из своей большой базы. Значит, смотрите, вершина у меня теперь представляется
не одним числом, а набором чисел. Давайте скажем k1, k2 и так далее, какой-нибудь kst. Это набор
ключей. Если раньше у меня вершина хранилась одно число, то теперь может быть много ключей.
Причем эти ключи внутри одной вершины строго и порядочно, в порядке возрастания.
Более того, если раньше у вершины был всего один сын, то теперь сын будет в каждом промежутке
между ключами. То есть левее первого, между первым и вторым, между вторым и третьим и так далее,
между последним и двумя и после последнего. Вот в каждом промежутке между ключами порождает
какого-то сына. Здесь будет соответственно такая же вершина, здесь будет такая же вершина и так далее.
Все вот эти штуки это отдельные вершины, которые еще вниз куда-то ведут. И при этом ключи,
находящиеся в поддереве, ведут себя естественным образом. То есть вот те, которые слева от k1,
здесь все ключи в этом поддереве будут меньше, чем k1. Ну потому что налево от k1, значит оно
меньше, чем k1. Все это было вот в этом поддереве. Все, что находится в этом поддереве между
ключами k1, k2, по значению будет лежать в диапазоне от k1 до k2. Ну и так далее. Между k2 и k3 будет
диапазон между ними. После ks будет множество, ну точнее все, что находится здесь, имеют ключи больше,
чем ks. Вот. То есть в каком-то смысле это просто обобщение бинарного деревопоиска двоичного,
только теперь мы в вершине храним несколько чисел, и если у меня раньше было налево меньше,
направо больше, то теперь каждая засечка между ключами порождает какое-то поддерево с диапазоном
ключей. То есть то же самое, только я как бы размножил одну вершину, сказал, что в ней много
ключей, она подразбивает вещественную прямую. Можно так нарисовать. Вот скажем, есть у меня вся
вещественная прямая, на ней поставлены засечки k1, k2, и так далее, ks. Все, что здесь, это соответственно
левый сын, вот эта вот штука, это вот эта вот. Дальше, между k1, k2 стрелка показывает на поддерево
целиком вложенной вот сюда. Между k2 и k3 будет вот это, ну и так далее. Справа от ks это все,
что справа от ks. Вот. Хорошо. Значит вот так у нас будет оно устроено. И теперь представьте,
что вот ровно так дерево где-то хранится в большой базе данных. Так да, ну например,
как делать в этом дереве find? Ну вроде несложно, надо встать в корень, find x. Встали в корень,
дальше поняли между какими двумя ключами находится x. Скажем, если он больше чем k1,
но меньше чем k2, то нужно пойти в это поддерево и там искать. Если оно между k2 и k3, надо пойти в
это поддерево и там искать. То есть find более-менее такой же, как всегда. Только теперь надо понять из
множества сыновей, в какого нужно идти. Хорошо.
Так вот, как мы получаем информацию из базы данных? Как мы подгружаем данные из какого-то вот
внешнего источника, внешнего хранилища? Ну обычно она подгружается какими-то блоками байтов,
там какими-то страничками из небольшого количества мегабайт, например. И вот обычно считается,
что как раз одна подгружаемая страничка, небольшой блок, который вы можете быстро получить из базы
данных, это как раз вершина набора вот этих чисел k1 и так далее ks. Тогда вы подгрузили
информацию про эту вершинку, поняли, где находится х, и вы сказали, окей, тогда мне нужна вот эта
вот вершина. То есть там эта штука куда-то ведет, указывает на какую-то вершину, вы говорите,
окей, я перехожу туда-то. Дальше подгружаете из базы содержимое этой вершины, идете туда,
куда показывает, понимаете, где х, идете туда, куда надо. То есть у вас как бы элементарная
операция обращения к базе это запрос содержимого вершины. То есть как бы самое сложное теперь это
спуск по ребру, потому что чем больше у вас спусков, тем больше у вас обращений к базе,
соответственно, тем больше выгрузок из нее. Поэтому мы хотим сделать так, мы хотим, чтобы вершина была
потолще, чтобы в ней было много ключей, но при этом дерево было как можно менее глубокое, потому что
чем оно глубже, тем больше запросов надо делать к базе, тем больше из нее надо делать выгрузок.
Поэтому мы хотим, чтобы дерево было не глубокое, но широкое. То есть чтобы в вершине было много
ключей. Ну а так оно обычно реализовано. Если вы хотите подгрузить хоть немножко информации,
то у вас обычно подгрузится сразу блок вот этот целиком. Содержимое всей вершины вам полностью
доступно. Вот так мы и сделаем. Мы сделаем дерево, у которого в вершине много ключей, но оно не глубоко.
Определение B дерево с параметром t. Это какое-то целое число больше или равное двойке.
Ну давайте я пишу. Дерево вот того вот вида с тремя свойствами. Во-первых, в корне ключей
от 1 до 2t-1. Во-вторых, во всех остальных вершинах ключей от t-1 до 2t-1. И третье,
оно нужно для анализа симптотики, все листья на одной глубине. То есть B дерево какая-то такая
штука. У вас есть корень, возможно какой-то узенький, у него есть какие-то дети потолще уже,
у них есть дети. Ну и все листины скажем на одной глубине, вот на этой.
Целое больше равное двух. Ключей это вот этих кашек в каждой вершине. Вот тут S ключей. Чисел,
который разделяет вещественную прямую. Утверждение очень простое. Глубина дерева
с N ключами, то есть если в дереве хранится суммарно N элементов, N ключей, то глубина
будет примерно алгорифм по основанию t от N. Глубина B дерева на N вершинах, на N ключах,
с N ключами. Есть? O от логарифм N по основанию t. Доказательства. Как обычно сделаем наоборот.
Давайте для фиксированной глубины посчитаем минимально возможное количество ключей. Пусть
глубина равна h, каково минимальное количество ключей? Каково минимальное количество ключей
при данной фиксированной глубине дерева? Если у меня фиксирована глубина и для каждой вершины
у меня есть некий диапазон того, сколько ключей может быть в этой вершине, то понятно,
мне нужно минимизировать в каждой вершине количество ключей. Потому что чем меньше ключей в вершине,
тем у нее меньше детей, и значит мне нужно меньше ключей, чтобы покрыть все это дерево.
Значит, минимум достигается в следующей конфигурации, когда в корне всего один ключ,
в его детях по t-1 ключу, потому что минимально возможное t-1, дальше здесь у каждого из них
тоже по t-1, ну и так далее, вплоть до глубины h. Ну и тогда понятно, что она ростет экспенциально
по глубине, причем с основанием экспонента типа t. Да, ну давайте нарисуем. Здесь вершин,
здесь скажем глубина, давайте так напишем, чему равна глубина, сколько здесь вершин. Значит,
на глубине 1 у меня одна вершина, это просто вот этот ключ, на глубине 2 у меня 2t-1, не вершин,
а ключей. Глубина 2, ключей 2t-1, потому что две вершины в каждой по t-1 ключу. На глубине 3,
сколько здесь? 2t-1t-1. На t мне кажется просто, потому что у каждой вершины t детей. Да,
потому что вот смотрите, у этих вершин здесь t-1 ключ, а значит детей t, потому что количество
диапазонов, на которые данный t-1 ключ бьет вещественную прямую, это t, левее первого,
между каждым двумя и после последнего, их когда здесь ровно t. И таких два, вот это и вот это,
будет 2t на t-1. Ну и дальше на уровне 4 у меня будет 2t квадрат на t-1 и так далее. На глубине h будет
что-то типа 2t h-2 на t-1. Ну если сложить, только раз получишь примерно t в степени h. Да, давайте
просуммируем. Вот 1 плюс 2 на t-1, тут будет сумма t-шек в степени в нулевой, в первый,
второй и так далее в степени t, t в степени h-2. Что это такое? Это что-то типа t в степени
h-1-1 делить на t-1. Это сумма степеней t-шек. Вот t-1 сократилось, осталось 1 плюс удвоенное t в
степени h-1-1. Вот. Это минимальное количество вершин в вот дереве глубины h. Ну и раз оно
минимальное, то оно должно быть меньше и равное чем n, где n это настоящее число вершин. Пардон,
ключей, ключей, ключей, ключей. Вот. То есть чего? У меня получилось 2 на t в степени h-1 меньше
либо равно n плюс 1. Давайте еще пополам сразу поделю. Ну и теперь, если я возьму логарифм по
основанию t, у меня как раз получится, что h-1 меньше либо равно 2-ичного логарифма по основанию t,
вот n плюс 1 пополам. А, ну все. То, что нужно. Значит, глубина не больше, чем вот такой логарифм.
То есть тут логарифм от n плюс 1 пополам, но понятно, что эта штука там не больше, чем n начинает,
для всех n, начиная с какого-то. Поэтому это не больше, чем просто логарифм по основанию t. Так,
хорошо? Потому что, смотрите, это мы посчитали минимально возможное количество ключей в дереве
глубины h. Минимально возможен достигаться в такой конфигурации. Но если мы знаем,
что в глубине h n ключей, это минимальное количество, а это настоящее количество ключей n. Здесь
не нравится такое. То есть мы предполагаем, что есть дерево на n ключах с глубиной h,
тогда n больше, чем минимум. Значит h не больше, чем логарифм. Так, ну хорошо, мы доказали,
что глубина небольшая. Но раз глубина небольшая, то мы можем делать find быстро. Вот, например,
find мы можем делать за сколько? Ну, кажется, за что-то типа t логарифм n по основанию t. Потому
что в каждой вершине у меня примерно n ключей, но от t ключей. Если мне нужно найти x, то я сначала
нахожу, где там x, между какими ключами находится x. Делаю это за t, потому что здесь примерно t ключей,
от t ключей. Ну дальше перехожу в одного из сыновей. Еще раз? Вы про то, что можно бинпоиск сделать?
Можно, но на самом деле, то есть можно здесь написать лог t, но да, конкретно найти x можно
за лог t. Но у вас все равно это t уходит на подгрузку информации. Если вы живете в той модели,
что именно для доступа к вершине мне нужно обратиться в вас, чтобы всю эту информацию перекопировать
к себе куда-то, в оперативку, то как раз t берется как минимум от того, что мне нужно информацию
перекопировать. Поэтому пишете вы здесь бинпоиск или линейный поиск, у вас t здесь остается,
потому что у вас информацию надо откуда-то взять. Она у вас не лежит в памяти, к сожалению. Поэтому
t множество остается. Понятно с файндом? Хорошо, теперь давайте попробуем сделать инсерт.
Инсерт. Ну давайте считать, что x в дереве не было, потому что если он есть, то мы его находим и больше
ничего не делаем. Он и так есть, делать ничего не нужно. Значит, иначе мы хотим добавить x в какой-то
из листьев. Ну вот было у меня там какое-то такое дерево. В идеале было бы, то есть я спускаюсь в
поисках x, дохожу до какого-то листика. И в идеале мне было бы просто вставить x сюда в нужное место
между какими-то двумя соседними ключами. То есть я дошел до листа, в котором x должен был бы быть,
если бы он был. Ну и дальше нахожу два соседних ключа, диапазон между которыми как раз должен
содержать x. В идеале я бы просто его туда вставил и победил. Но, к сожалению, может нарушиться вот это
вот условие, что у меня немного ключей в вершине. Да, ну потому что если бы, например, этого не было,
то у меня бы деревом был бы, например, просто массив чисел отсортированный, туда вставлять и удалять
долго. Вот, поэтому нужно как-то пофиксить случай вот этого переполненного вершины, переполненного
узла. Когда там слишком много ключей, я не могу туда просто так что-то бесплатно вставить. Ну давайте
напишем начало. Ну давайте интуицию напишу, что хотелось бы вставить x в подходящий лист,
но он может быть заполнен. Заполнен, то есть в нем будет вот это максимально возможное количество
ключей. Вот, надо с этим что-то делать. Давайте сделаем следующее. Давайте мы попробуем в то же
время, пока мы ищем x, то есть пока мы спускаемся от корня до листа в поисках x, давайте поддерживать
следующий вариант, что если я зашел в вершину, то в ней строго меньше, чем 2t-1 ключ. То есть в этом
случае как раз я всегда могу вставить x в данную вершину. Давайте поддерживать инвариант. То есть
наше неизменяемое свойство. Что мы хотим? Я хочу чтобы в вершине, в которой я нахожусь, было меньше
чем 2t-1 ключ. Текущая вершина не заполнена, то есть в ней меньше, чем 2t-1 ключ. То есть вот я хочу
идти, я встаю в корень, иду как-то сверху вниз в поисках x, и хочу чтобы те вершины, которые я
проходил, были всегда не до конца заполнены, чтобы в них было место, куда вставить одно число,
если нужно. Давайте думать, как это делать. Ну, например, там давайте я как-то начал, вот эти все
вершины были не заполнены, хорошо, я просто по ним спускаюсь. Пусть я внезапно дошел до вершины,
в которой 2t-1 ключ. Мне хочется что-то сделать, чтобы здесь уменьшить количество ключей.
Давайте сделаем следующее. Давайте я нарисую картинку поприличнее. Давайте родителей еще
рассмотрим. Вот был у меня родитель. Из него я, найдя диапазон между какими-то двумя средними
ключами, перехожу в какую-то вершину, и вот в ней, например, пусть ровно 2t-1 ключ. Но при этом в
родителе, поскольку я спускаюсь рекурсивно сверху вниз, давайте считать, что в родителе меньше,
чем 2t-1 ключ. То есть, грубо говоря, это первое противоречие, где впервые у меня произошло
заполнение вершин. Тогда можно сделать следующее. Давайте просто я найду здесь центральный элемент y,
давайте m назову его. Центральный элемент m, то есть тот, до кого номер, видимо, ровно t.
Да, t это элемент, ну центральный. И подниму его, вот просто возьму и подниму его вот сюда вот на
позицию между теми двумя ключами, между которыми расположено все вот это вот под дерево. То есть,
если здесь у меня было, скажем, a-b, то я просто беру и это m поднимаю и вставляю вот сюда между
a-шкой и b-шкой. И я могу это сделать, потому что эта вершина при этом, она раньше была не заполнена,
поэтому, если что, одно число и всегда могу смело поднять. Вот. И тогда у меня вот эта
одна большая вершина на самом деле расплитится на две. У меня будет вот эта вот часть и вот эта
вот часть. Будет корректное бы дерево. Сейчас нарисую еще раз. Да. Нет, 2t-2 это не проблема,
2t-2 я туда могу поднять. Еще раз, 2t-2 не проблема, если 2t-2, то я могу сделать 2t-1. Где 2t-1?
Вот здесь? Нет, все, я вас понял. Мне нужно, чтобы только в текущее, вот я спустился из родителя в
новую и вот здесь 2t-1 меньше, чем 2t-1. То, что выше, мне уже не важно. Мне важно, что в текущей только.
Сейчас. Дайте вот эту картинку дорисую. Еще раз, вот у меня был родитель, в диапазоне между двумя
ключами была заполнена вот такая вершина. Я здесь беру центральный элемент m, его удаляю,
поднимаю, вот сюда вот вставляю между h и b и теперь говорю следующее. Давайте перерисуем. Что станет?
У меня будет a, m, b. Ну и там то, что было между ними. Теперь диапазон между a и m будет вести вот то,
что было здесь раньше слева, левый кусок, левые половины массива. А между m и b будет то, что справа.
Как раз все неравенства у меня будут сохранены, потому что l это что такое? Это с одной стороны то,
что между a и b, но левее, чем m. Как раз, да, правее a, левее, чем m. r это то, что между a и b,
но больше, чем m. Больше, чем m и между a и b. Все сохранилось. Поэтому такое расщепление вершины
на две с подъемом центрального элемента вверх останется корректным b-деревом. Ну и тогда,
если я уже отсюда, я все еще иду в поисках х, я понимаю, куда надо пойти сюда или сюда, например,
сюда, ищу здесь x, find x, insert x, точнее, insert x. Ну а это уже будет вершина, которая не заполнена,
в которой меньше 2t-1 ключ. Я ее специально расплитил и если нужно опять с этой вершиной я буду делать то
же самое. Я спускаюсь в ребенка, если ребенок заполнен, то я могу центральный элемент поднять
из него вверх. Ну и так далее. То есть, я когда спускаюсь вниз, я поддерживаю, что в текущей
вершине ключей мало. Ну, меньше, чем максимум. Но у нас есть какая-то еще проблема, когда мы делим после вершин, которые мы делали изначально, у нас получается две части, l и r, каждой размером t-2, а должно быть... Не-не-не, t-1 ровно.
t-1, плюс 1, плюс t-1, как раз 2t-1. Тут все четко как раз. Вот, да, значит, осталось, ну на самом деле,
на самом деле все и так нормально, значит, надо понять только какая у нас база. Что происходит в корне,
вот даже если корень, например, заполнен, что происходит в корне, если корень заполнен?
Представьте, что в корне максимальное число ключей. Делаем ровно то же самое. Мы выбираем здесь,
пусть это корень, в нем 2t-1 ключ. Я выбираю здесь центральный элемент, поднимаю его наверх, но сверху
ничего не было, поэтому то, что становится сверху, становится новым корнем. И теперь у этого корня,
этот корень слева ссылается вот на это под дерево, справа вот на это. То есть я по смыслу сделал то же
самое. Я взял центральный элемент, поднял его в вершину выше и сказал, что теперь границы этой вершины
слева-справа, указатели от нее, ведут на то, что было слева от нее и справа. Только теперь,
поскольку у меня выше вершины не было, то я говорю, что, окей, тогда это новый корень. Вот у меня новая m,
это новый корень. Нет, в корне от 1 до 2t-1 написано. У меня во всех вершинах максимум 2t-1,
в корне минимум 1, а во всех остальных минимум t-1. То есть у меня в корне бывает такое.
Еще раз давайте восстановим, что в корне у меня количество ключей от 1 до 2t-1, а в остальных от t-1
до 2t-1. Вот такое определение. Если у вас по-другому, то исправьте. Вот в корне может быть 2t-1. И если
2t-1, то я центрально также поднимаю наверх и говорю, что это новый корень. Вот. Все. И тогда,
если у меня этот вариант сохраняется, если всегда, когда я спустился до вершины, в ней ключей меньше
чем 2t-1, то я могу всегда вставить x, если нужно. И когда я дошел до листа, этот лист не заполненный,
я могу вставить x, куда нужно, и победить, потому что лист не заполненный. Все. Согласны? Понятно?
Вы имеете в виду содержимое? Как массив. Ну как вектор, да. Как вектор, я думаю. Так, ну что,
пять минут, а сас на рейс, ну это, конечно, невозможно. Давайте идею, ладно. Давайте просто
быстренько идею, как реализовать рейс. Наверное, полностью разбирать не будем. Ну, хотелось бы
делать то же самое. Мне хотелось бы, чтобы в той вершине, откуда я хочу удалить x, было не минимально
возможное количество ключей, то есть не t-1. Если в вершине не t-1 ключ, то, наверное, мы сможем
победить. Вот давайте этого попытаемся добиться. В текущей вершине ключей хотя бы t, ну или она
корень. Или она корень. Потому что все-таки в корне мы такого добиться не можем. Или она корень.
Окей. Ну давайте опять-таки спускаемся в поисках х. Куда-то идем-идем-идем. Дошли, например, до вершины,
в которой это условие не выполняется. То есть в ней минимально возможное плохое количество ключей t-1.
Тогда, если раньше я вершину расщеплял, то теперь мне нужно делать наоборот. Мне нужно, ну как бы,
мне нужно посмотреть на собратьев и, возможно, с кем-то из них склеить. Вот смотрите, вот у меня
была вершина с t-1 ключом. Давайте посмотрим на соседнюю вершину слева, среднюю вершину справа.
Ну то есть у меня же все вершины упорядоченные как бы по уровню. Есть непосредственный брат слева,
непосредственный брат справа. То есть у меня как бы есть вершина такая, что диапазон между
двумя числами указывает сюда, между вот этим двумя сюда, между вот этим двумя сюда. А вот в этом
смысле брат слева справа. Ну тогда, например, смотрите, если у меня вот здесь вот ключи хотя бы t,
то я могу просто взять, давайте какие-нибудь буквы введу, а, б. Так, как я это сделаю? Да, тогда
я могу просто взять и поднять a сюда, а b спустить вот сюда, и тем самым увеличить здесь количество
ключей на один. То есть после преобразования у меня будет вот такая штука, у меня будет
вместо b находиться a, а из левого по дереву просто уйдет, здесь останется t-1 ключ, а b спустится вот
сюда, вот в эту вершину, ну поскольку она была левее, чем разделить, она перейдет самый левым
ключом, станет здесь. Здесь будет b и после него t-1 ключ. То есть по факту я просто a поднял сюда,
а b спустил сюда. Опять, можно легко доказать, что это останется корректным b-деревом,
ну потому что, например, все вот эти элементы должны быть, ну они больше, чем b, потому что они
лежат правее этого указателя, значит, ну как раз здесь все хорошо, они справа от b. A было меньше,
чем b, потому что оно было левее здесь, и здесь все нормально, b находится правее, чем a. Короче,
все нормально, это остается корректным b-деревом. Но при этом, смотрите, мы позаимствовали один
ключ у брата и увеличили количество ключей в самом себе. Значит, у нас стало как раз хотя бы
t ключей, все хорошо. То же самое можно с правым, если с правой хотя бы t ключей. Если у обоих
братьев t-1 всего лишь ключ, то мы можем с одним из братьев склеиться. Значит, вот у меня был,
ну давайте левого нарисую просто, вот у меня был левый брат, вот я. Вот, здесь t-1, здесь t-1,
между ними разделитель какой-нибудь x. Тогда я могу просто сказать следующее, давайте я вот
это вот все безобразие вместе с x объеденю, сделаю новой вершиной. То есть я x спущу в промежуток
между братьями, сюда его вставлю, и склею все это, скажу, что это одна новая большая вершина,
но уже как раз ровно с 2t-1 ключом. Так имею право сделать, потому что x как раз он находится в
диапазоне между всеми этими и всеми этими, поэтому будет корректное b-дерево. И как раз я имею право
позаимствовать x сверху, потому что я иду сверху, у меня выполняется всегда это условие, если здесь
было хотя бы t ключей, то я имею право x спустить вниз. Вот, поэтому всегда, когда я нахожусь в вершинке,
в ней будет хотя бы t ключей. Вот, ну все, ну и типа и там, и там доделывается, короче,
давайте на этом остановимся, Eraser на этом достаточно. Все, спасибо.
