Так, ну мы завершаем наш увлекательный, судя по количеству слушателей,
разговор про диаграмм Вороновой, дрангуляции Дилане.
Значит, мне остался небольшой долг с прошлого раза.
Мы, к сожалению, не успели, собственно, самое важное свойство диаграммы
дрангуляции Дилана доказать, что в ней максимизируется минимальный угол.
Давайте напомним, что у нас уже есть. Значит, давайте очень быстро.
Что такое флип-ребра? Это если у нас есть два треугольника, разделяющие общую сторону,
тогда флип – это, по сути, изменение диагонали в этом выпуком четырехугольнике.
Было два треугольника, осталось два треугольника. Мы говорим, что такой флип
бывает полезный. То есть, такой флип легализует вот это вот ребро, Pj,
если минимум среди вот этих шести углов вырос. Мы меряем три угла в этом треугольникеETM
и, соответственно, эти же шесть углов в этих треугольниках. Если минимум из них вырос строго,
то флип легализует это ребро. То есть, ребро было плохим, минимум вырос,
как раз минимальный угол увеличился. Значит, мы говорим,
что флип хороший, флип легализует ребро. Дальше, это получается легализация, давайте напишу
легализация ребра. Минимальный угол увеличивается. Дальше, значит, легализация триангуляции это
легализация всех ребер. Мы доказали критерий того, что триангуляция является триангуляцией деланой,
если только если она легальная. То есть, триангуляция является триангуляцией деланой,
если в ней больше нечего легализовывать. То есть, нет вот таких флипов, которые бы увеличивали
минимум. Это теорема, второй критерий с прошлой лекции, что деланы, если только если легальная
триангуляция. Ну и это, собственно, критерий легальности. Мы сформулировали в термах окружностей,
что триангуляция является легальной, если только если окружность, описанная вокруг любого
треугольника, не содержит вот эту как раз четвертую вершину. То есть, если вы описываете вот
здесь вот окружность какую-нибудь. Ох, ну давайте я вот так вот нарисую. Будем считать, что это
окружность. Вот в ней не должно быть четвертой вершины этого четырехугольника. То есть, вершины
напротив этой стороны общей, в другом треугольнике. В термах окружности давайте я так кратко напишу.
У нас было, что ребро легальное, если только если в окружности, описанной вокруг одного треугольника,
нет вершины другого треугольника. Вот, ну и наконец, самое главное, зачем нам все это было нужно,
я утверждаю, что триангуляция отделана максимизирует минимальный угол.
То есть, среди всех возможных триангуляций, если мы рассмотрим самый маленький угол,
то максимальное его значение достигается ровно на этой треангуляции отделаны и только на них.
Значит, ну доказательства пусть не так. Давайте рассмотрим какие-нибудь две треангуляции.
Значит, пусть Т1, Т2 это какая-то треангуляция, которая максимизирует минимальный угол.
Треангуляция, максимизирующая минимальный угол.
Тогда давайте мы на треангуляции Т2 проведем процедуру легализации. То есть давайте просто
делать edge flip пока можно. Ну пока эти операции легальны. Давайте просто легализовывать все
ребра одно с другим в произвольном порядке. Я утверждаю, что мы в конце дойдем, во-первых,
до легальной треангуляции. Ну потому что в конце нельзя будет сделать ни одного legalize,
ни одного flip-а легализующего ребро. Значит, ну в конце получится легальная треангуляция.
То есть, после какого-то количества действий я получу легальную треангуляцию, а легальная
является треангуляция деланэ по теореме. Ну и значит, нам надо еще доказать, чтобы в любой
треангуляции деланэ минимальный угол один и тот же. Ну это мы замечали, потому что все многоугольники
вписаны, и значит, после треангуляции минимальный угол это минимальная дуга просто в этой описанной
окружности. Ну давайте легализуем T2. Значит, просто будем делать edge flip для каждого нелегального
ребра в любом порядке. Для каждого нелегального ребра в любом порядке. Я утверждаю, что такой алгоритм,
то есть алгоритм просто while существует нелегальное ребро, сделает вот такой flip. На этом мы делаем
треангуляцию T2. Я утверждаю, что этот алгоритм конечен. Что рано или поздно мы придем из T2 к
легальной треангуляции, где больше ничего флипать нельзя. Скажите, пожалуйста, почему. Делаем,
делаем флипы. Почему рано или поздно точно остановимся? Я бы сказал, что возможно,
потому что когда мы здесь что-то делаем, у нас меняется структура треугольников. Возможно,
мы как-то так поменяли, что у нас поменялись вот эти два треугольника,
прилежащие к данному конкретному ребру. Нужен какой-то чуть другой аргумент. В
каком-то смысле да. Что будет потенциалом? Да, да, да. Действительно, можно просто сказать,
что давайте я следующее сделаю. Минимальный угол может не увеличиваться формально,
поэтому не совсем хорошо. Давайте я скажу следующее. Давайте я для каждой треангуляции
построю набор углов всех треугольников. Вот есть у меня какая-то треангуляция. Я померю все углы,
вообще все, во всех треугольниках, и отсортирую их в порядке возрастания. То есть напишу такой
последователь, ну как бы кортеж углов, отсортированный в порядке возрастания. Вот,
значит, я у каждой треангуляции могу рассмотреть набор углов. Дальше понимаю, что каждая легализация,
каждый флип, легализующий ребро, он этот вектор, очевидно, увеличивает строго. Если вектор просто
лексик графически будет сравнен с собой, то каждый флип, конечно, вектор увеличивает, потому что минимальный
элемент увеличивается. Значит, здесь, если я рассмотрю первое различие между двумя последовательными
векторами, то в них как раз отличие будет в том самом минимальном, который я увеличу. Значит,
флип лексикографически увеличивает вектор углов. Лексикографически увеличивает вектор углов.
Вот, ну и остается доказать, что потенциальных векторов углов конечное количество. Ну это просто
сделать у вас просто straight langexcaseziękuję конечное количество данного mesure точек.
Если явно это должна была быть задача, какая-то верхняя оценка на начала triangulation. Значит,
с таких векторов тоже конечное количество, значит, мы не можем бесконечно долго увеличиваться.
По какой-то цепочке мы двигаемся, увеличиваем потенциал. То есть увеличиваем текущий вектор.
Бесконечно увеличиваться не можем, потому что в возможное количество векторов конечно —
значит процедура конечна, процедура конечна, вот, и того в конце мы получили
какое-то t2 со звездочкой, это новая треангуляция, полученная из t2
несколькими edge flips, значит с одной стороны угол я точно не уменьшил
минимальный, потому что минимальный у меня точно мог только
расти, каждый edge flip увеличивает минимальный угол, значит угол не
изменился минимальный, ну, точнее не уменьшился, минимальный угол не уменьшился, вот, и
при этом t2 со звездочкой стало легальной, легальная треангуляция, а значит треангуляция деланная,
треангуляция деланная, вот, ну и все, и дальше вот тот аргумент, который я проговаривал, что во
всех треангуляциях деланой минимальный угол один и тот же, потому что как он
получается, у нас есть, ну, вообще откуда возникает неоднозначность треангуляции деланая,
только из-за того, что у нас могут быть вот такие вот вписанные в окружность
грани в графе деланая, дальше я их как угодно треангулирую, говорю, что результаты
произвольного треангуляции деланая, ну и понятно, что вот как бы я не треангулировал, найдется угол,
опирающийся на самую маленькую дугу, давайте скажем вот это вот самая маленькая дуга, вот этот угол,
соответственно, он самый маленький, поэтому минимальный угол в любой треангуляции деланой
это просто длина, ну, как бы радианная мера самой маленькой дуги среди всех окружностей,
описанных вокруг всех многогольников, во всех треангуляциях деланой минимальный угол одинаковый.
Ну вот вроде все, то есть мы показали, что если у нас была исходная треангуляция деланая t1 и какая-то
другая t2, которая на самом деле максимизировала минимальный угол, то я могу еще в этой t2
минимальный угол еще не уменьшить, ну если исходно был максимальный, то он такой останется,
больше быть не может, и при этом мы получим треангуляции деланая, в которой минимальный угол такой же
как здесь, значит у них просто минимальные углы одинаковые, в t1 и t2 звездочка, поэтому лучше,
чем в треангуляции деланой мы такого получить не можем. Вот, ну собственно все, что надо было
доказать. Да, вот в обратную сторону, видимо, я погречился, действительно, тут не означает,
что если мы нашли какую-то треангуляцию, в которой максимальный минимальный угол такой-то, то это
деланая, наверное, я погречился, давайте не будем доказывать, я думаю, что это не так в общем случае.
То есть именно, что, как бы если я, ну то есть утверждение такое, что если мы построим треангуляцию
деланой, вот тем нашим алгоритмом из Воронова, просто по определению построим, то это треангуляция,
в которой минимальный угол максимально возможен среди всех треангуляций. Возможно какие-то еще есть,
но это точно максимизирует. Окей? Обратно я неосторожно сказал, что ровно такие, значит
максимизация минимального угла достигается ровно в треангуляции деланой. Или все-таки верно?
Вроде верно. Не, не, не, минимальный максимизировать.
Сумма чего? Не, сумма глав у нас константа, я...
Мне кажется вы что-то путаете нас про сумму, я, конечно, ничего не говорил. Я рисовал,
собственно, откуда у нас мотивировка вот того, что нам нужно максимизировать минимальный угол.
Я рисовал такую картиночку, говорю, что здесь уровень 0, здесь уровень 0, здесь уровень 100. И
тогда плохие треугольники, это вот такие, добивающиеся того, что на вот этом вот у нас
горном рифе у нас здесь 0, а хочется, чтобы было сотни или около того. Вот, поэтому мне нужно
просто избавиться от таких маленьких углов, значит, я его пытаюсь максимизировать. Про сумму углов,
я, конечно, ничего не говорил. Да, да, да, да, да, то есть я как бы по всем треугольникам измеряю
минимальный угол, и вот он должен быть как можно больше. Собственно, про это и есть максимизация
минимального угла. Среди всех треугольников берем минимальный угол и его максимизируем.
Так, окей. Да, да. Обратно можно то же самое сделать. Возьмем произвольный максимизирующий
минимальный угол, легализуем, она будет деланной и угол не изменится. Да, это правда. Нет, я бы
сказал, ее можно легализация ребер преобразовать сделанной. Ну, потому что, например, смотрите,
у нас может быть такое, что вот, то есть в обратную сторону, короче, это неверно, но можно
преобразовать, как она является деланной, потому что, скажем, у нас может быть какая-нибудь такая
картинка, где вот такая, что вот это вот минимальный угол, а дальше есть какие-то два треугольника такие,
что их выгодно флипнуть, но они не влияют на минимальный угол. Поэтому как бы минимальный угол
все равно достигается здесь, здесь ничего флипать нельзя, но можно флипнуть где-то во внешности этого
треугольника. Поэтому как бы это не деланной, потому что нелегальная, но при этом минимальный угол
все равно один и тот же максимально возможен, поэтому в обратную сторону все-таки неверно. Вот,
ну хорошо, все, собственно, вот мораль такая, что если мы построили деланной, то у нас есть
максимирующий минимальный угол. Круто. Значит, давайте еще раз повторим, как можно строить
эту треугольницу деланной алгоритм. Ну, во-первых, если у нас есть диаграмма Воронова, мы можем
просто по определению диаграммы Воронова построить граф, граф деланной, граф деланной.
Надо просто смотреть на то, какие ячейки имеют общий кусок границы, и тогда, соответственно,
мы проводим ребро в триангуляции между соответствующими сайтами. Вот, просто по
определению строим граф деланной, а потом его уже до конца дотреангулируем, треангуляция деланной.
Вот, но на самом деле можно избавиться от вот этого первого шага, можно диаграмму Воронова явно не
строить, а вспомнить, как работает алгоритм Форчуна и, собственно, в нем сразу строить граф деланной.
Давайте кратко напомним, что делает алгоритм Форчуна. У нас есть некая сканирующая прямая,
есть некая береговая линия, состоящая из каких-то ветвей парабол. Давайте я что-нибудь здесь довольно
произвольно нарисую. Вот, события двух типов. Первый тип – это какие-то три парабола подряд
предыдущие схлопываются в вершину диаграмма Воронова, либо события приходит новый сайт и,
соответственно, он вставляет новый парабол в нашу береговую линию. Вот, а что нам нужно? Смотрите,
давайте вспомним граф деланной, мы проводим ребро между сайтами, если они разделяют общий
кусок границы положительной длины. То есть это как раз случай, когда две параболы пересеклись в
какой-то точке, и потом в течение какого-то небольшого времени, то есть когда я чуть-чуть
подвиную эту прямую, у меня, соответственно, параболы немножечко сдвинутся вниз, и вершина
пересечения двух средних парабол вычертит какой-то кусочек как раз границ между двумя ячейками
диаграмма Воронова. Значит, тогда на самом деле, чтобы построить граф деланной, мне нужно просто
запоминать, какие пары парабол когда-либо пересекались, потому что пара пересекающихся парабол
значит, что они соседние вот в этой береговой линии при проходе слева направо. Ну, значит,
как раз при опускании сканируешь прямой чуть-чуть вниз, эта точка вычертит некую кусок границы,
значит, мне нужно эти сайты, сайты, отвечающие этим параболам, соединить ребром в графе деланной. И
никакие здесь даже не нужно, то есть этот алгоритм даже будет чуть проще, чем алгоритм для диаграмма
Воронова, потому что мне не нужно там явным образом хранить какие-то точки, которые являются
вершинами диаграмма Воронова, мне не нужно там какие-то с полубесконечными ребрами что-то делать
отдельно. Поэтому я просто, значит, делаю следующее. Каждый раз, когда параболы, отвечающие
пыжи, являются соседними в береговой линии, я просто добавляю ребро пыжи,
добавляем ребро пыжи. Всё. Ну и поскольку у меня этот алгоритм вычерчивает все ребра диаграммы
Воронова, значит, все вот эти вот вершины, да, попарные пересечения, которые мы здесь видим,
они вычерчают все ребра, значит, в частности, мы рассмотрим все пары сайтов, которые разделяют
какой-то общий кусок границев в терминах диаграмм Воронова. Хорошо. Вопрос, да,
формально мы получим граф, формально мы получим граф Дилане, но потом надо еще его дотреангулировать,
да. Ну давайте, давайте я скажу так, смотрите, действительно, мы здесь получим только граф,
потому что мы проводим ребра между сайтами, которые отвечают как бы соседним ячейкам диаграмм Воронова,
только граф. Значит, как его потом треангулировать? Ну смотрите, у нас вот, давайте просто выполним
этот алгоритм, в конце у нас получит какая-то такая картинка. Давайте я что-нибудь здесь довольно
вольное нарисую. Ну вот, ну вот, что-нибудь такое. Есть какая-то такая, есть какой-то такой граф на
плоскости. Значит, мы можем сделать следующее. Смотрите, мне нужно как бы по сути выделить грани
в этом планарном графе и все их произвольным образом дотреангулировать, потому что я знаю,
что можно как угодно это делать. Значит, то есть что у меня есть? У меня есть набор сайтов на
плоскости, какие-то ребра между ними проведены. Я знаю, что граф планарный, мне нужно выделить
грани. Значит, это делать очень просто. Давайте мы в каждой вершине отсортируем по полярному углу
все векторы, исходящие из данной точки. То есть вот из этой точки, скажем, 3 ребра выходят. Ну понятно,
в каком порядке они идут. Сначала это, потом это, потом это. Это легко сделать, ну просто там, грубо
говоря, там посчитаем угол с положительным направлением оси ОХ и в этом порядке их отсортируем
как раз таки. Ну или просто по векторному произведению. Вот в таком порядке их все пройдем.
И дальше, чтобы выделить одну конкретную грань, я встаю в произвольную точку и начинаю идти,
собственно, ну там вот взял произвольный вектор, давайте пойдем сюда. Значит дальше,
какой вектор у нас будет следующим? Ну мне нужно встать в эту точку и найти вектор следующий
за вот этим. Это, соответственно, либо какой-то бинпоиск, либо мне нужно просто подвязать,
указать ссылочку, что вот это ребро справа налево соответствует этому ребру слева направо.
Соответственно, за ним идет, скажем, вот это. Ну просто там увеличить номер на один. Дальше,
я понимаю, что за этим ребром идет вот это. Опять, пришел в эту вершинку, у меня есть
какое-то текущее входящее ребро, надо понять какое следующее. Ну опять, я понимаю,
какой номер имело обратное ребро, значит мне нужно просто следующее ребро взять, а это вот это
ребро. Потом вот это и мы вернулись туда, откуда начали. Тем самым выделили грань, и соответственно,
которая ограничена четырьмя ребрами. Вот, и так делаем просто, пока не обойдем все ребра, тем самым
у нас как раз выделятся все грани, и затем просто каждый из них является выпукланногоугольником,
который я знаю состоит из тех вершин, я могу его спокойно дотреангулировать. То есть, по сути,
в конце нужно просто выделить грани в планарном графе. Выделить грани в плоском графе, давайте
напишем. Плюс дотреангулировать их. Сейчас, сейчас, ну смотрите еще раз, что у нас есть,
у нас есть какая-то точка, в нее пришел некий вектор, я хочу понять, какой вектор ему как бы,
ну обратно, в обратную сторону ведет, чтобы находиться следующий к нему. То есть, у меня вот
из этой точки все векторы направлены из этой точки, а здесь наоборот из нее, поэтому мне нужно как бы
обратный вектор найти. Ну, давайте тогда сделаем следующее, давайте каждое ребро, которое мы видим,
скажем из ПИ в ПЖ. Вот мы увидели ребро из ПИ в ПЖ, оно там соответствует какому-то ребру в порядке
обхода вокруг ПИ. И оно же, точнее от ПЖ к ПИ, соответствует какому-то ребру в порядке обхода
вокруг ПЖ. Ну, вы давайте тогда просто для каждого конкретного ребра между парой вершин, мы скажем,
что, ну то есть там еще сделаем один бинпоиск, один раз предпочитаем бинпоиском, какие здесь ребра
друг другу соответствуют. То есть, у меня есть вот это вот ребро из ПИ в ПЖ, оно, не знаю, имеет
второй номер здесь, и первый номер в порядке от ПЖ к ПИ. Значит, тогда просто я сделаю один бинпоиск
по обратному ребру, пойму, что второе ребро отсюда, то есть первое ребро отсюда, и свяжу их просто,
что если я пришел по второму ребру сюда, то я нахожусь в первом ребре вот отсюда. То есть, я один
раз предпочитаю все такие пары соответствует ребро и обратный к нему, просто, ну, как бы там
указателями или номерами. Ну, можно, да, но скорее, действительно, это не очень полезно, можно просто
явным образом каждый раз делать бинпоиск. Да, пока все ребра не обошли. То есть, вот мы обошли одну
грань, можем опять встать сюда, взять первый неиспользованный ребро, это вот это, пройти вот эту
гранью и так далее. Окей? Нет, нет, нет, нет, у нас будет еще вот такая внешняя грань. Не надо, мы
всегда, ну, давайте, значит, на этой картинке я всегда кручусь вот так, просто существовой, тогда
на самом деле здесь, ну, и здесь, если я пойду по этому ребру, я на самом деле обойду как раз внешнюю
грань, то есть я обойду вот так вот, у меня получится внешняя грань нашего многоугольника. Да, если я вот
встану вот здесь вот и буду обходить просто существователь, я как раз вот эту гранью обойду, то есть у меня будет
вот эта грань, вот эта грань, и внешняя получится, например, вот таким обходом. Как понять, получили мы
нужную грань или внешнюю? Сейчас, одну секунду. Ну, смотрите, мы в конце получаем многоугольник как
вершин, если это внутренняя грань, то как вот было здесь, он получается обойден в порядке против часовой
стрелки, а вот эта штука на самом деле обойдется в порядке по, вот этот многоугольник обойдется в
порядке по часовой стрелке, потому что мы как бы обходим его внешность, то есть я встал вот сюда,
сейчас, или это обман, одну секунду. Да, то есть, нет, окей, окей, окей, секунду. Ну, можно, скажем,
по площади считать, потому что это выпуклая оболочка, то есть внешняя грань, она, как раз,
ограничена выпуклой оболочкой исхода многоугольника, и просто та грань, которая, собственно, ограничена
выпуклой оболочкой, это внешний, ее можно игнорировать. Ну, можно просто площадь посчитать,
сказать, что самая большая, это есть выпуклая оболочка. Ну, потому что еще раз. Как у нас
выглядит картинка у нас граф делане он он является значит каким каким-то
разбиением выпукло оболочки на на грани есть что внешняя грань но вот как раз
если мы тогда все эти грани объединим то больше ты выпукла оболочка и самая
большая грань ее границы в точности выступает выпукла оболочка у всех
остальных граней что-то поменьше
окей
ну вот мне вроде тут как раз вроде ничего страшного нет в отделении
выделение грани если у нас такой очень хороший планарный граф все все
грани выпукла многоугольника нет никаких отростков то как бы все все вполне
легко делать из любых ну просто там не знаю у меня точки
нумировано от нулевой до минус первой давайте от из нулевой есть не не
пройденное ребро пойдем по нему есть есть еще пойдем по нему и так далее пока
есть не пройденные рёбра запускаем просто до фэс из них не до фэс даже
просто там обход какой-то ну рекурс и так вы говорите
так ну а давайте двигаться дальше есть давайте еще такой краткий обзор
какие есть алгоритмы рядышком вот с этой тренировка с деланой и диаграмма
воронова значит есть алгоритмы с выходом в 3d которые сводят наши задачи к
задачам более ну как бы формулируем более просто но в трехмерном случае
скажем вот здесь довольно тяжело формулируется ну там вороной еще
относительно просто но деланая формулировка довольно тяжело вот значит можно
выйти в трехмере трехмерное пространство и там задача будет
проще но легче они к сожалению не особенно решаются то есть там есть конечно
алгоритмы какие-то тоже за инлоген вот но они скорее так для для общего
развития что ли итак давайте напишу выход в 3
мы сделаем следующую странную штуку вот есть у нас наша плоскость где нам
нужно было скажем построить риангуляцию деланая давайте мы добавим осет
направленную вверх и на этой картинке соответственно тут есть какие-то
координаты x и y на этой картинке давайте я еще нарисую
параболоид сдаваем уравнением z равно x квадрат
плюс y квадрат ну это будет какая-то вот такая картинка давайте просто параболе
его нарисую вот и дальше сделаю следующее все точки плоскости точнее сайты
которые мне лежали в моей исходной плоскости r2 я подниму просто на наш
параболоид то есть если у меня была такая точка точка x и y на то я ей в
соответствии поставлю точку x y x квадрат плюс y квадрат x квадрат
плюс y квадрат просто поднял на параболе значит тогда я утверждаю
следующее значит ну давайте тоже теория мы скажем что если я подниму все сайты
на параболоид и найду нижнюю часть выпуклой оболочки всех этих поднятых
точек так вот проекция этой нижней выпуклой оболочки на плоскость x и y
является в точности графом деланэ значит
проекция нижней выпуклой оболочки
точек на параболоиде
в плоскость x и y это в точности граф деланэ
поэтому ну там либо докажем либо я как-нибудь коротко обрисую доказательства
поэтому да если теперь мы взять на веру мы могли бы свести задачу построения
треангуляции деланэ к задаче нахождения выпуклой оболочки точек в трехмерном
пространстве но выпуклая оболочка определяется так же как всегда да это
минимально выпуклое множество все их содержащие соответственно если есть тут
много точек на нашем параболоиде ну что это какой-то многогранник будет
многогранник гранями выступают как раз вот гранями там выступают ну в основном
треугольники да но иногда бывают какие-то тут конечно я не смогу это
никак нарисовать короче какая-то такая сложная штука будет многогранником
многогранник машина которого лежат на параболоиде вот какая-то такая штука я
же что нижний его как бы проекция нижней выпукло оболочки это точности
граф деланэ поэтому да если бы научились вдруг внезапно находить
выпукло оболочку в 3d то мы бы могли найти граф деланэ ну соответственно его в конце
до треангулирует собственно выдели в грани и опять-таки проведя все необходимые
диагонали до треангуляции вот значит простых алгоритмов у выпукло оболочки в
3d особенно нет есть довольно простой заин квадрат путем заворачивания просто
подарка так же как у нас есть заворачивание подарка в двумерном
случае мы просто там скажем ну давайте кратко в двумерном случае как мы можем
строить выпукло оболочку заворачивания подарка мы берем одну сторону дальше из
всех точек выбираем самую крайнюю и говорим что следующая сторона потом у
нас вот эта сторона опять из всех точек выбираем самую крайнюю то есть
рисуем все вот такие векторы понимаем что это самый крайний но соответственно
это будет следующая сторона так просто идем да и строим самую самую крутую
возможную касательную к нашему нашу точку значит ну вы три примерно что что-то
то же самое мы взяли некую одну плоскость ограничивающую наш
многогранник с одной стороны ну и дальше там давайте просто вокруг какого-то
ребра попытаемся построить следующую возможную
плоскость которая наиболее точно сужает наше наше множество точек ну то есть
отделяет как можно больше пространство от наших точек тем самым получим как
раз новую брать вот это будет за н квадрат потому что у нас если грани
линейное количество грани линейное количество то все равно чтобы проверить
что будет следующей грани мне нужно все точки перебрать и так n раз поэтому
будет квадрат к сожалению вот но есть алгоритм за н луген ну там он какой-то
какой-то страшный то есть грубо говоря еще на лекцию но вообще да если бы мы
научились здесь находить выпукла оболочку то в принципе магнитных игров
деланы еще раз ну конечно выпукла облачка всегда единственная это минимальная
выпуклая фигура такая что она всегда по определению просто единственно ну
точнее следствия определение что она всегда существует единственная
не понял еще раз пожалуйста да не на самом деле смотреть на самом деле откуда
у нас чем опять отличается треангуляция от графа тем что выпукла оболочки у нас
могут быть грани не треугольные скажем есть у нас там четырехугольная грань она
спроецировалась в четырехугольную грань графа деланы если я отреагулирую
то мы просто поднимется будет ребро просто на грани и все ничего страшного
ну если поднять то это будет граф просто с диагональями на граних да да да ничего
страшного так значит ну давайте значит факт а что существует алгоритм за н луген
строящий выпукла бочков 3d что алгоритм строящий выпукла оболочку в 3 за вот он
луган ну давайте сейчас уже будет просто какая-то обзорный кусок
лекции доказывать ну как бы какой-то сложный алгоритм он есть и хорошо так
давайте я немножко попробую доказать вот это утверждение что действительно нам
достаточно спроцировать нижний выпукла оболочку так я начну со следующего давайте
я рассмотрю касательную в какой-нибудь точке к нашей параболе нашим параболой
вот скажем пусть у меня есть точка с координатами а б а квадрат давайте напишем
уравнение касательной плоскости касающийся вот здесь вот наша парабола то есть ну вот
что-то вот такое будет что-то вот такое как-то вот так наш наш параболы касается значит это
будет плоскость задаваемым каким-то таким уравнением z равно что-то там на x плюс что-то
там на y плюс что-то там да она будет явно не не горизонтальная поэтому она может иметь такой
вид ну то есть кроме вот этой вот она собственно это будет затронулю сейчас да она будет явно не
вертикальная да у параболы нет вертикальных касательных плоскостей поэтому можно точно
написать в таком виде вот но на самом деле коэффициенты при x и при y легко останавливаются
просто из того что это касательная а значит коэффициенты здесь должны быть просто равны
производным до частным производным вот этого нашего уравнения задающего наш параболой по
x и по y а потому что по сути касательная плоскость это приближение первой степени к нашей фигуре
значит мне нужно просто взять производные частные по x и по y поэтому здесь коэффициенты будут 2 a и 2
но это просто частные производные частные производные уравнения z равно x квадрат
плюс y квадрат точки а б а квадрат б квадрат вот это доказываем нет это сложный факт это там
на отдельную лекцию вот мы доказываем теоремы значит эти эти коэффициенты понятно ну и
соответственно свободный коэффициент здесь восстановился просто из того что если это
фиксировано то у меня эта плоскость должна проходить собственно через эту точку поэтому
я могу ее подставить наш уравнение и понять что свободный коэффициент должен быть вот такой
минус а квадрат квадрат если его поставлю таким то как раз при подстановке вместо
x а вместо y б у меня как раз получше 2 квадрат 2 b квадрат минус сумма то есть
просто сумма квадратов равно как раз а квадрата квадрат поэтому это уравнение
действительно касательная и в этой точке действительно происходит касание так хорошо
теперь давайте рассмотрим плоскость с теми же самыми коэффициентами при иксе и при игреке
поднятую вверх на некое ну давайте пишу r квадрат я увеличу свободный коэффициент
на r квадрат соответственно моя плоскость поднимется немножечко выше давайте новую
картиночку поднимется немножечко выше и будет как-то пересекать наш парабол наш парабол
давайте я нарисую какой-то такое вот сечение да соответственно плоскость она вот содержит
этот вот окружный на самом деле в общем случае будет эллипс да пересекающий ну как раз являющийся
сечением нашего параболой да вот и плоскость на как как-то вот так вот проходит да продлевает
наш наш эллипс куда-то вверх вниз причем расстояние вот такое вертикальное расстояние от этого эллипса
до точки касания равно r квадрат то есть я я поднял точку вот у меня было здесь касание я
поднял плоскость на r квадрат стало сечение ну такое вот эллиптическое отстоящие по вертикали
на r квадрат от точки касания вот хорошо значит тогда отуждаю следующее я отуждаю следующее что
значит точка пл лежит внутри описанной окружности
треугольника pi pj пока то есть как раз точка пл нарушает легальность если только если
после поднятия точка пл лежит ниже плоскости задаваемой вот этими вот тремя точками то есть
смотрите еще раз да это было что-то подготовительное теперь рассматриваем сначала ситуацию в плоскости
вот у нас есть какие-то три точки образующий треугольник я описываю вокруг вокруг них
окружность получается пи пж пк окружность вокруг треугольник я говорю что точка пл в нем лежит в
этой окружности лежит в этой окружности если только если после поднятия давайте я буду поднятия
обозначать волной как бы ну поднятие на парабалоид pl лежит ниже плоскости
пи пж пк вот волна значит поднятие поднятие на парабалоид поднятие на парабалоид
у меня были какие-то точки здесь в плоскости да там не знаю пи пж пк я тут построил какую-то
окружность в ней оказалась точка пл тогда утверждаю что пл будет лежать ниже плоскости
после поднятия ниже вот этой плоскости после поднятия их в r3 на парабалоид вот и тогда
как раз если мы докажем то у нас точности получится что вот это вот это корректный
треугольник ну то есть формально эти вершины лежат в одной грани граха дилане если только
если вот это вот это плоскость ограничиваясь ни ограничивающаясь ниже нас наш многогранник
то есть точности это является гранью выпуклой оболочки потому что выпукла оболочка снизу она
просто ограничена какими-то гранями если приведу плоскости через эти грани то как раз ниже них
никого будет не может ну просто просто просто так работает выпуклая оболочка вот мне с некий
выпуклый многогранник так я не представляю как это рисовать честно говоря не вот что-нибудь
такое да вот такой вот многогранник если я провожу плоскости через его грани то они как
раз отделяют ну точнее они таковы что все остальные точки лежат как бы выше да выше этой
полуплости выше этой плоскости а ниже никого нет соответственно вот как раз здесь точности
написано что треугольник корректный то есть лежит в одной грани графа делана если только если вот
это вот штука задает грань нашего выпукла ну нашего многоугольника то есть наша выпукла оболочки
вот ну и тем самым тогда у нас вот то вот утверждение будет верно значит почему это верно
да почему наличие точки в окружности равносилен тому что точка ниже какой там плоскости но
давайте мы посмотрим на эти три точки по ипожпк поднимем их на парабалоид это будет как раз какая-то
вот такая вот плоскость ну то есть для каких-то коэффициентов а б а квадрат ну точнее для
каких-то а б р квадрат у меня как раз получится что вот эта вот плоскость да проходит через точки
п и с волной пока с волной так сейчас немножко их поднимаю да п и с волной выглядно там лежит
сейчас п и с волной вот то есть я могу поднять эти точки построить по ним плоскость сечение
этой плоскости с нашим на парабалоидом будет как раз эллипсом до которой я вот после проекции
на по Tolstoy да otros怕 как раз перейдет в эту самую апис Executed нашего треугольника
то есть я тоже даже если спроекцировать теперь этот эллипс получается с сечением получается
с сечением этой окружности тьфуты получается с сечением плоскости и парабалоид и Josie на
плоскость то у меня как раз получиться окружности описан Madam why понятно что
она будет проходить через эти наши точки просто потому что через них проходит в
в R3. А почему это будет окружность? Так, почему после проекции будет окружность?
Потому что вот этот z на самом деле, это x квадрат плюс y квадрат, да, то есть что
такое вот этот эллипс? Это такие точки x и z, что выполняется вот это вот равенство,
да, потому что они еще и на проболоде лежат. Но если я вот здесь вот аккуратненько все
сгруппирую, у меня получится уравнение x минус a в квадрате плюс y минус b в квадрате равно
r в квадрате. Она просто перенес вот эти штуки туда, это туда, r квадрат оставил справа. Получается,
что проекция этого конического сечения на самом деле действительно является окружностью,
треугольника. Ну и все, собственно, тогда понятно, что точки, лежащие внутри окружности,
точки, лежащие внутри окружности, это такие точки, где здесь значок меньше. То есть точка,
вот если я скажу, что x и y это координаты точки PL, то ее принадлежность внутри окружности,
это значит, что здесь значок меньше, это как раз значит, что она лежит ниже этой плоскости,
а PL внутри окружности, если только, если в этом равнении здесь меньше, значит в этом равнении
здесь меньше, значит просто PL лежит ниже нашей плоскости. Ну все. То есть у нас получается не
просто точки поднимаются на параболлоид, но еще и окружности вот этих вот, описанных как любого
треугольника, они поднимаются в эллипсы, такие, что все, что под ними, это как раз внутренность
нашей окружности. Ну и все, соответственно, чтобы найти все вот эти вот валидные треугольники,
мне нужно найти все плоскости, которые снизу ограничивают наши поднятые точки на параболлоиде,
это в точности нижнего паклоболочка, вот и все. Ну как? Отлично. Так, да,
да. Да, да, конечно. Нам нужно фиксировать ребро. Да, да, да. Вот. Хорошо. Так, это у нас получается
сведение делане к чему-то в 3D, на самом деле к выпаколобочке в 3D. Значит, дальше я могу еще
сделать что-то похожее для Воронова. Значит, смотрите, вот здесь мы уже описали уравнения
касательных, уравнения касательных полкласскостей в данной конкретной точке. Так вот теорема. Ну
давайте я напишу пусть P, точек PN, это множество сайтов. Дальше пусть H и T это плоскость,
давайте не так, давайте напишу касательная плоскость к параболлоиду, касательная плоскость
к параболлоиду, точке P с волной. То есть у меня есть набор сайтов на плоскости,
я их все поднял на параболлоид и в каждой из них как бы провел касательную плоскость. Так вот
тогда я утверждаю, что проекция верхней огибающей всех этих касательных плоскостей является диаграмм
Воронова. Проекция верхней огибающей всех этих N плоскостей на плоскость XY. Есть
сущности Грамм Воронова исходного множества сайтов. Вот здесь мы уже рассматриваем не точки,
а плоскости касательные в этих точках и вот берем их верхнюю огибающую. Это когда я,
вот давайте картиночка опять в меру моих художественных способностей, у меня в некоторых
точках проведены касательные плоскости. Здесь такая штучка, здесь штучка, короче какие-то
штучки здесь нарисованы, спереди есть еще такая плоскость. Верхняя огибающая, это когда вы для
произвольной точки плоскости XY проводите вертикальный луч вверх, смотрите какие плоскости она
пересекает, какие из вот этих вот касательных полплоскостей она пересекает, и брать просто
самую верхнюю. Она пересекла вот эту с точки здесь, пересекла вот эту с точки здесь, ну и там еще
какую-нибудь вот такую в точке вот здесь. Значит вот это как раз самая верхняя в этой конкретной
точке. То есть вы как бы в каждой точке, по каждой каранаде XY берете самую высокую точку,
принадлежащей хотя бы одной плоскости и говорите, что вот она как раз лежит в верхней огибающей.
Ну то есть такая картинка сверху. Представьте, у вас есть такой стакан, вот такой параболический,
он как-то обрублен некими полуплоскостями, вы смотрите сверху и вот как бы то, что у вас видно,
та плоскость, которая видна сверху, это есть вот верхняя огибающая всего ваше множество.
Вот. Ну и соответственно опять мы свели задачу по строению Диаграмма Воронова к
чему-то в трехмерном пространстве. Задачу формулируется сильно проще, чем сама Диаграмма
Воронова. Есть просто набор плоскостей, надо найти их в верхней огибающей. Там тоже есть,
конечно, алгоритм Зейн Луган, но он тоже неприятный. Вот и так, доказательства. Доказательства.
Да. Не совсем, не совсем, не совсем. Не совсем, ну смотрите, вот есть у вас вот такой стакан.
Вот так посекли, и вот так посекли, скажем. Понятно, что вот эта плоскость, она вот здесь вот
доминирует, а здесь она проигрывает. Поэтому если вы снизу станете, вы будете видеть вот эту как раз,
поэтому на верх не нужна. Вот. Доказательства на самом деле простое. Давайте мы вот возьмем точку
x, y в плоскости и поймем, что именно вот эта вот плоскость, которая самая верхняя, соответствующая этой
точке. То есть мне нужно среди всех плоскостей h1 и так далее hn найти такую, в которой z-координата
для точки x, y максимально возможна. Да, но я знаю, чему равна z-координата в точке x, y. z это всегда
2ax плюс 2by минус a квадрат плюс b квадрат, где ab это координаты очередного сайта,
где ab координаты сайта, координаты очередного сайта. Вот. Тогда что происходит в случае,
если это z максимально возможная среди всех всех сайтов с координатами ab? Значит,
вот это выражение больше, чем все остальные для всех других h' и b'. Давайте напишу, что 2ax
плюс 2by минус a квадрат плюс b квадрат больше, чем 2ax плюс 2by минус h' квадрат плюс b' квадрат,
где ab это некий сайт, а h' и b' любой другой сайт. То есть вот эта плоскость самая высока в точке
x, y. Значит, она больше, чем все остальные. Вот. Ну, здесь, если как-то сгруппировать,
то у нас как раз получится... Я хочу получить a-h' в квадрате плюс b-b' в квадрате. Нет,
не так, не совсем. Сейчас, сейчас, сейчас. Я хочу получить a-x в квадрате плюс b-x в квадрат
против h' минус x квадрат плюс b' минус y квадрат. И тем самым я получу расстояние от одного сайта
до точки x, y и от другого сайта до точки x, y. Значит, они отличаются на x... Окей, да. Значит,
давай тогда в обе части добавим x квадрат плюс y квадрат. От этого неравенство не изменится,
но зато я смогу здесь выделить полный квадрат. Здесь будет написано минус a квадрат плюс 2ax.
Минус x квадрат. Минус, значит, вот есть такая штука. А дальше плюс минус b квадрат плюс 2by
минус y квадрат. Больше, но все то же самое, только h' и b'. Окей, я вычел из обеих частей x квадрат
плюс y квадрат. Значит, дальше тогда я могу здесь написать полный квадрат, и у меня как раз
получается что... Что написано здесь? Здесь написано минус расстояние от x, y до ab в квадрате.
Минус квадрат расстояния от x, y до ab. А здесь написано тоже минус квадрат расстояния от x,
y до a' и b'. Поэтому написано вот здесь вот. Вот это вот неравенство означает, что точка ab
самое близкое к точке x и y. Так, ну придется все-таки новую доску заюзать.
Значит, давайте я еще раз напишу аккуратненько, минус x квадрат плюс y квадрат меньше, чем минус
x квадрат. Значит, просто dist от x, y до a, b меньше dist от x, y до a, b. Ну, собственно, все.
Это означает, что вот та самая верхняя плоскость в соответствии с точкой x и y, она соответствует
самому ближайшему сайту. Поэтому, когда я проецирую мою верхнюю огибающую на плоскости x и y,
у меня как раз что будут ребрами и вершинами? Ребра – это пересечение плоскостей, да, таких,
что там одна – это ближайшая к одному сайту, а соседняя – ближайшая к другому сайту. Тогда их
пересечение – это как раз точки на границе между сайтами, на границе между ячейками сайтов. Ну,
вот тогда, соответственно, как раз прямой отрезка пересечения двух плоскостей – это в
точности граница между двумя ячейками. Если у меня три плоскости пересекают в одной точке,
то, соответственно, проекция – это точки вершины диаграмма Воронова. То есть у меня как раз… Ну,
по сути, самое главное – это что вот эта вот подстановка x, y в уравнение плоскостей – они в
каком-то смысле задают расстояние от точки до сайтов. И если я беру верхнюю огибающую,
то есть самую высокую плоскость в данной точке, пересекающей наш луч, то у меня как раз вот она
соответствует тому сайту, который ближе всего к точке x, y. Значит, соответственно, здесь просто
автоматически возникает диаграмма Воронова. Ок? Ну и все, значит, соответственно, если научиться
внезапно откуда-то находить верхнюю огибающую, то мы сможем после проекции получить диаграмму
Воронова. Но опять это там какой-то сложный англичан еще. Так. Вот. Ну все, тогда вроде с Вороным и
Диланэ мы все сказали. Последний сюжет рядом с геометрией лежащей – это так называемое
кд-дерево. Начнем мы будем рассматривать 2d-дерево. D от слова dimension, ну, то есть как бы 2d-дерево,
2-мерное дерево, 3d-трехмерное, kd, соответственно, k-мерное. Вот. Значит, это такая общая, некая общая
структура, которая позволяет отвечать на разные запросы для данного множества точек. Все, значит,
Вороной и Диланэ осталось позади. Теперь еще вот отдельный кусочек программы. Давайте на нем
сконцентрируемся теперь. Просто такой отдельный сюжет. Значит, давайте именно жить в случае 2d,
то есть в случае двухмерной плоскости. У нас есть две координатные оси x и y. И в ней есть некие
точки. В этой плоскости есть некие точки. Ну, скажем, давайте они фиксированы и не меняются.
Есть фиксировано множество точек. И давайте скажем, что поступают два типа запросов. В каждой
точке ассоциировано какое-то еще число, то есть в каждой точке написано некое число, аи-тое какое-то,
ажитое и так далее. И запрос это либо изменение значения в точке, либо подсчет суммы в прямоугольнике.
Значит, изменение аи в точке, либо сумма в прямоугольнике.
Вот. Ну, на самом деле, если у нас задача статическая, то это можно было бы решать просто
деревом Фенлика и деревом Фенлика. У вас, вроде, была такая задача в первом семестре. Ну, если,
то есть, на самом деле, лучше два дерева ничем не лучше здесь. Оно лучше, только если у вас множество
может расширяться. Ну, пока давайте вот именно такую постановку посмотрим, когда множество точек
фиксировано, изменяя в точке и сумма в прямоугольнике. Значит, смотрите, здесь, на самом деле, идея весьма
простая. Единственное, что здесь сложное, это анализ симптотики. Значит, идея. Давайте мы,
так же как в каком-нибудь дереве отрезков, будем делить наши точки пополам. Вот есть у нас набор
точек на плоскости. Давайте поделим их на две равные части какой-нибудь вертикальной прямой.
Ну вот, у меня так хорошо получилось, что здесь 6 точек и здесь 6 точек. Нет, да, все правильно.
Поделил вертикальной прямой. Да, и дальше, соответственно, у меня есть два куска. В каждом из них
я делаю то же самое, только делю уже не вертикальной прямой, а горизонтальной. То есть, здесь у меня есть,
скажем, по 6 точек в каждой штуке. Вот здесь вот эта прямая разделяет их на куски одинакового
размера. А здесь, ну, например, сейчас я их поярче нарисую, вот эта прямая. Они уже заметили,
совсем не обязательно одна и та же прямая. То есть, это какие-то куски прямых. Дальше,
рекурсивно, у меня есть некие кусочки. Я каждый из них опять как-то подразбиваю,
но теперь уже опять вертикальный прямой. Так чтобы с левой справа лежало примерно поровну. Здесь
уже будет у нас нечетное количество точек, поэтому я буду делить на примерно равные куски. Вот,
ну, здесь, скажем, будет одна точка, здесь две точки. И опять, вот эта штука нужно горизонтально
прямой разбить на две равные части. У меня будет вот такое доделение. Вот, ну и так далее. То есть,
у меня в каждом куске, в каждом текущем куске я провожу либо вертикальную прямую, либо
горизонтальную, чередуясь так, чтобы все множество точек разбилось примерно пополам. Если,
соответственно, какой-нибудь плохой случай, что у меня много точек на медианном иксе,
мне нужно провести вот такую прямую. И, короче, не получается, что как бы надо что-то вот такое
провести в каком-то смысле. Ну давай тогда просто формально считать, что я провожу все равно вот
такую прямую, но только вот эти вот точки я отношу влево, а эти точки отношу вправо. То есть,
это не обязательно прямая разделяющая прямая, но, по сути, у меня точки, порядочные по х и по y,
я провожу вот такую штуку, и они еще и по y как-то ограничены. То есть, либо так, либо давайте,
для удобства буду говорить, что нет точек с одинаковыми х и с одинаковыми y. То есть,
всегда можно так разбить, вот так вот хорошо, чтобы не было таких проблем. Но, на самом деле,
они тоже не являются проблемой. Надо просто взять вот эту прямую и сказать, что первые,
сколько точек идут влево, остальные идут вправо. В итоге у меня получается такое дерево, повторюсь,
у меня чередуются прямые, которые разделяют наш текущий кусок плоскости, либо вертикальные,
либо горизонтальные. Но каждый раз при спуске в дочернюю ситуацию у меня число точек делится
примерно вдвое. Я примерно пополам разбиваю нашу множество точек. Одно множество точек идет влево,
другое идет вправо. Я каждый раз примерно в два раза уменьшаю число точек. Поэтому глубина
такой структуры будет логарифмическая. Каждый раз число точек делится в два раза. Глубина
логарифмическая, конечно. Глубина логарифмическая. Ну и время построения будет n log n, потому что раз
глубина логарифмическая, то каждая конкретная точка лежит примерно в логарифмичных уровнях,
поэтому это все можно построить на самом деле n log n. Надо только пояснить, почему можно за
линейное время проводить вот такую разделяющую прямую в данном множестве точек. И это вопрос
уже к вам. Как, если у нас есть множество точек, найти вертикальную прямую, разделяющую на два
равных куска? За линию хотим. Бин пояс, там будет логарифм еще лишний, тогда будет лог квадрат.
Нет, всем не обязательно, потому что может быть какая-то очень далекая точка, которая портит вам
все. Так, ну тут я хочу, чтобы вы мне все-таки сами ответили. Вот смотрите, давайте я прошу задачу,
давайте я рассмотрю одномерный случай. Все точки находятся на прямой, я хочу их разделить на два
равных куска. Хорошая идея, можно действительно посортировать и просто вывести n пополам на
статистику, но проблема в том, что у вас, когда вы меняете вот это направление прямой, у вас
меняется порядок, и причем довольно непредсказуемо. То есть вам нужно как бы хранить, и при этом еще
но что точек сужается, ну короче такое. Мне очень приятно. Вот без сортировки хочу.
Да ладно, я же даже сказал уже правильные слова. Да, за сколько мы ищем? За линию, да,
конечно, поэтому как бы просто ищем вот эту, ну по сути мы ищем медиану, да, медиана. У нас
есть алгоритм, который делает за линию, даже детерминированно невероятно. Вот, ну и все,
соответственно, чтобы найти очередную разделяющую прямую, я там смотрю либо на все х, либо на все
y, в зависимости от того, какую прямую провожу, нахожу медиану за линию, вот и собственно тем самым
разделяем наш точек на два примерно равных. Так, хорошо, значит построение будет аналоген. Вот,
запрос, ну, значит, давай еще скажем, что, то есть у меня по сути что есть, смотрите, у меня есть,
по сути, каждый вот, на каждом шаге у меня есть набор точек, да, которые лежат в некоторой,
вот давайте еще нарисуем на каждом шаге баундинг бокс текущий. Вот у меня был множество точек,
какой это изначально. Чтобы найти его баундинг бокс, мне нужно взять минимальный х, максимальный х,
минимальный х, максимальный х, ну, то есть ограничивать со всех четырех сторон такими прямыми
параллельными сам координатами. Значит, это у меня был баундинг бокс в начале. Дальше, я как-то разбил
вот такой прямой и опять у меня есть, то есть, по сути, я как бы спускаюсь на уровень ниже,
у меня есть два на что точек, в каждом из них давайте опять посчитаем баундинг бокс. Значит,
здесь он будет, какой-то вот, сейчас будем учиться. Давайте я сначала баундинг бокс нарисую,
да, вот здесь будет такой, здесь будет такой какой-нибудь, вот, ну, что-то такое, ну и так далее. То есть,
каждый раз у меня сужается баундинг бокс моего множества точек. Так вот, как тогда отвечать на
запрос, скажем, первого типа? Давайте я буду в каждом вот этом текущем баундинг боксе, то есть,
на каждом уровне моего вот этого рекурсивного спуска, я буду хранить сумму тех чисел, которые
лежат в нашем прямоугольнике текущем. Тогда, если мне, скажем, поступит запрос суммы в
прямоугольнике, который, например, целиком содержит весь наш прямоугольник, весь наш баундинг
бокс, то мне нужно просто вернуть сумму в этом прямоугольнике. Если он как-то там пересекает,
то давайте просто рекурсивно запустимся слева и справа с учетом пересечения нашего большого
прямоугольника запроса с нашим большим прямоугольником. Это будет там какой-то кусок здесь,
какой-то кусок здесь и так далее. То есть, еще раз, главное, что я хочу сказать,
что мы в каждой вершине два дерева храним сумму чисел в текущем баундинг боксе.
Сумму чисел в текущем баундинг боксе. Вот. Тогда запрос первого типа оборваться за алгорифом
просто, потому что мне нужно проследить, как АИТ разбивается в этом нашем, то есть мы каждый раз
делим множество на два, надо проследить путь конкретной точки АИ и, соответственно, во всех
вершинах нашего КД дерева, во всех баундинг боксах, в которых она содержалась, нужно там
изменить сумму на дельточку. Поэтому запрос первого типа обрабатывается просто за алгорифом.
Просто проследить путь АИ в этом самом интерактивном разбиении рекурсивном и везде сделать изменение
суммы на дельточку. Новая минус старая. Вопрос, что делать с запросами суммы в прямоугольнике.
По сути, ровно так же, как мы делаем в дереве отрезков. Вот у меня есть текущий баундинг бокс.
Давайте его нарисую вот так. Есть текущий баундинг бокс и есть текущий запрос. Давайте его нарисую
вот так, жирным. Тогда, ну простые ситуации. Если запрос полностью содержит баундинг бокс,
то мне нужно просто вернуть значение из баундинг бокса, сумму во всем прямоугольнике. Первый
просто случай. Второй просто случай. Если они не пересекаются, давайте нарисуем. Вот был баундинг
бокс такой и он был целиком вложен в прямоугольник, который нас интересует. Тогда нужно просто вернуть
сумму из этого баундинг бокса. Все, что у нас доступно, это входит в наш прямоугольник. Второй
просто случай. Если наш текущий баундинг бокс не пересекается с запросом, тогда надо вернуть ноль
просто. Там много точек, лежащих здесь и здесь, а он имеет сумму ноль. Ну и интересный случай,
когда он как-то пересекается, но не вложены они. Ну вот что-то такое как раз. В смысле маленький
вложен в большой. Если такое, то можно сразу сузить и сказать, что они вот так пересекаются,
потому что вот эти точки все равно у нас не влияют. То есть у меня в любом случае получается некое
пересечение баундинг бокса с прямоугольником запроса. И тогда я его, соответственно, что
делать? Я рассекаю наш прямоугольник некой вертикальной прямой, медианной по x или горизонтальной
по y. И дальше иду либо влево, либо вправо, либо и туда, и туда, если существует пересечение нашего
прямоугольника с баундинг боксом внутри каждого из детей. То есть алгоритм на самом деле очень
простой. У нас есть текущий баундинг бокс и запрос прямоугольника. Эти две ситуации отдельно
и файм. То есть либо сразу завершаемся добавив к ответу либо ноль, либо сумма в всем баундинг
боксе. А дальше, если ни то ни то не произошло, я перехожу на уровень ниже, я знаю, как мой
баундинг бокс рассечется на два более маленьких. Скажем, здесь будет такой баундинг бокс, здесь вот
такой. Ну и соответственно, просто рекурсивно запускаюсь от обоих детей, то есть вот от этого
баундинг бокса и прямоугольника запроса, от этого баундинг бокса и этого прямоугольника запроса.
И там они дальше, собственно, рекурсивно также делаются. То есть по сути ровно так же, как в
дереве отрезков. У нас есть все множество точек и некий запрос. Я либо сразу завершаюсь,
либо иду в тех детей, где переченье не пусто. То есть я просто иду в тех детей,
иду в детей, где переченье не пусто. Такой тоже очень простой для реализации алгоритм. У нас есть
баундинг бокс слева и справа. Смотрим, пересекается ли запрос с этими баундинг боксами. Если да,
то идем в соответствующий ребенка. Если нет, то не идем. И здесь, как ни странно, асимботика будет
гораздо хуже, чем алгоритм. На самом деле, асимботика будет корневая. Корень визан.
Так, вроде время есть, поэтому можно доказать или по крайней мере частично доказать. Я утверждаю,
что если так в тупую делать, то количество баундинг боксов, то есть вершин в кадре дерева,
которые мы обойдем, будут корневыми. Для этого нужно аккуратно проанализировать то,
как у нас пересекается прямоугольник запроса с текущим баундинг боксом. По сути, давайте вспомним
временно, как мы действовали в дереве отрезков. Дерево отрезков мы делали примерно так. Мы встали
в корень, и нам нужно найти пересечение с каким-нибудь отрезком. Мы сначала идем вниз, пока этот отрезок
запроса лежит целиком в одном из сценовей. То есть мы сначала спускаемся куда-то. Затем у нас
происходит реальное пересечение нашего отрезка. То есть у нас отрезок разбивается на два под отрезка,
и прямоугольник запроса, отрезок запроса, он как-то вот так вот пересекается и с левым, и с правым.
Вот здесь мы раздвайливаемся, а дальше у меня вот здесь у нас получается, что текущий запрос это
суффикс, а здесь текущий запрос это префикс. Дальше мы доказываем, что тогда, если я иду здесь вниз,
то я либо иду влево, а справа беру целиком, либо влево вообще не иду, и справа запускаюсь
рекурсивно. То есть вот здесь вот как только у меня расщепляется наш запрос, он становится сразу
либо суффиксом, либо префиксом, и в этом случае уже легко доказать, что оставшееся число вершин,
которые мы рассмотрим, он логарифмичный. Вот логарифм. Давайте что-то такое же сделаем здесь. То есть
тут по сути смотрите, что мы сделали. У нас было изначально все в общем положении, то есть есть
некий отрезок, есть некий запрос внутри него. Вот мы либо оставляем ситуацию такой же, пока отрезок
запрос лежит целиком либо слева, либо справа, то есть это как раз первая начальная ветка. А впервые,
когда мы расщепились, мы переходим к суффиксу и префиксу. То есть у нас есть ситуация вот такая
общая, когда отрезок это не суффикс, не префикс. Есть вот такая ситуация, когда отрезок это суффикс,
есть вот такая ситуация, когда отрезок это префикс. Ну и дальше, собственно, у нас есть по сути
три возможных ситуации. Дальше мы доказываем, что время работы для каждой из них логарифмичный.
Что-то такое сделаем здесь.
Значит, давайте обозначу, у меня будет такое обозначение, т с индексом прямоугольник и запрос от m.
Это значит, что мы сейчас находимся в уровне кд-дерева, который содержит n вершин, то есть
на верхнем уровне n вершин, на втором n пополам, потом n4 и так далее. То есть сколько вершин на
текущем уровне в каждой вешине нашего кд-дерева. А это наиболее полная информация, которую мы
гарантированно знаем про наш запрос. То есть изначально мы ничего не знаем, кроме того,
что по сути мы ничего не знаем. То есть вот там, в дереве отрезков, я в какой-то момент знаю,
что он суфикс, в какой-то момент знаю, что он префикс. Тогда я могу точно нарисовать,
что они вот здесь вот касаются. А вот здесь вот, изначально, я ничего не знаю, он никого не касается,
ни сверху, ни снизу, ни слева, ни справа. То есть он может быть как-то там, как-то вот так вот пересекаться.
Во-первых, я могу заведомо выкинуть все, что находится вне нашего баунинбокса. Во-вторых,
это больше информации, чем вот это. Здесь как бы написано, что он касается справа. А
здесь написано, что фиг его знает. Вот поэтому давайте рисовать так. То есть общая ситуация будет
такая. Значит, какие здесь есть случаи? Давайте рисовать вертикальную разделяющую прямую. Значит,
ну может быть такое, что я имею какую-то вот такую картинку, тогда после проведения вертикальной
прямой мне нужно идти только в левого сына, и в нем ситуация такая же. То есть опять есть некий
прямоугольник, который где-то внутри лежит. Либо интересная ситуация, когда мы пересекаемся вот так.
То есть давайте я напишу, что мы либо идем... Так, давайте вот так нарисую. Либо мы идем в
аналогичную картинку с параметром n пополам плюс 100 единицы. Либо у нас этот прямоугольник запроса
рассекся на два, и я запускаюсь от обоих сыновей, но с новым допусловием, что здесь есть привязка к
границе. То есть по сути вот этот прямоугольник запроса сейчас привязан к границе нашей баунинбокса.
Это уже хорошо. То есть это как бы новая информация, которую мы здесь сейчас будем отображать. Но смотрите
здесь дальше, когда я спускаюсь в рекурсию, у меня меняется направление разделяющей прямой.
Если сейчас она была вертикален, то после этого будет горизонтальная. Я не хочу рисовать отдельно
случай для вертикальных и горизонтальных прямых. Давайте я лучше вместо этого поверну мою картинку
на 90 градусов там по часовой стрелке. И тогда следующее, как бы то, что было горизонтально
разделяющей, станет вертикально разделяющей. Поэтому вот здесь вот я могу написать, что это
время равно времени вот такому вот, а там пополам. Плюс времени. Здесь я, видимо, должен
нарисовать, где прямоугольник сверху нарисован. Привязан к верхней границе. Ну как бы понятно,
что это одно и то же время. А поэтому я пишу здесь просто двойку. То есть еще раз, после спуска в
рекурсию у меня по факту прямоугольник привязан к правой или левой стороне, но прямая
проводится горизонтально. Если я поверну 90 градусов, то у меня картинка будет такая. У меня
прямоугольник привязан снизу или сверху и проводится вертикальная прямая. Ну понятно,
что это одно и то же. Похоже, что это одно и то же. На самом деле действительно так и будет. Но давайте
я для простоты и скажу, что и случай симметричный одинаковый. Хорошо, появилась новая картинка,
когда прямоугольник привязан к нижней стороне. Давайте поймем, чему равно время работы на n
точках в этом случае. Опять я провожу вертикальную прямую. Надо понять, как у меня рассекается эта
штука. Ну первое, давайте опять здесь буду рисовать. Простой случай, когда у меня отделяется целиком
наш прямоугольный запрос и идет в одну из двух сторон, тогда мы свойствуемся к той же ситуации
с n пополам вершинами. Либо же, либо у меня наш прямоугольный запрос и пересекается с линии
разреза. И соответственно, когда я запускаюсь слева от вот такого уголочка и справа вот от такого
уголочка. Надо только не забыть их повернуть. Значит здесь, когда я поворачиваю, у меня будет
запрос, скажем, вот такой вот, на левый нижний уголок. Давайте вот так поверну, а там пополам.
Ну и здесь тоже, если перейду на 90 градусов вот так вот, то у меня будет верхний левый уголок,
но понятно, что с точки зрения вертикальной прямой это одно и то же. Поэтому здесь напишу опять-таки
двойку. Согласны? Вот. Ну что, появилась новая штука. Давайте ее напишем.
Значит опять, вот картинка сейчас такая. Я знаю, что прямоугольник привязан к левой нижней,
к левой и к нижней сторонам. Я пробую вертикальную прямую. Ну здесь опять, либо у меня прямое
разделение вообще его не затрагивает, тогда я остаюсь в такой же картинке, только уже с n
пополам точками. Так, кстати, я здесь пишу глупость, потому что я вот здесь забыл повернуть. Да, вот,
я же провел вертикальную прямую и повернул, поэтому на самом деле здесь картинка вот такая.
У меня касание будет с левой стороны, а не с правой. Вот. Ну на самом деле все несущественно,
потому что у меня будет все равно, короче, здесь все медики будут, ну в общем, давайте так для
правильности сделают. Итак, здесь я прошу вертикальную прямую, справа, например, никого нет,
а левый чувак тогда поворачивает на 90 градусов, у меня получается верхний левый треугольник,
но опять-таки с точки зрения вертикальной прямой это то же самое, что левый нижний треугольник,
поэтому я здесь оставлю ту же самую картинку. Вот. Либо же я рассекаю наш уголочек как-нибудь,
вот так вот. Вот так его рассек. Вот. И у меня тогда остается после вращения опять ситуация,
что у меня, смотрите, здесь привязка к трем сторонам, левая, нижняя и правая. После вращения
это будет, видимо, что-то вот такое. А если это первое на 90, у меня будет как раз, да,
будет как раз вот эти стороны, вот он пополам, плюс вот эта штука при повороте на 90 останется
уголочком, поэтому я оставлю здесь уголочек. Ну, если действовать так дальше, если рассматривать
все возможные конфигурации вложенности прямоугольника запроса в bounding box, то вот здесь
все было хорошо. В DO все было идеально, а у меня было как бы все в 103 ситуации. Либо никуда,
либо влево, либо вправо. Но если слева и справа, то это сразу зовут и не сработает, потому что
целиком отрезок вложен в bounding box. Здесь как бы случаев побольше, ну потому что у нас сторон
побольше, да, и 2,5 сторон многовато что-то. Вот. Ну давайте, то есть что у меня еще есть? У меня
остается вот это вот, да, не прописанное, и вот это не прописанное. Давайте я скажу, что вот это
примерно аналогично вот этому, не буду делать, времени все равно не остается, ну в общем, на пальцах
давайте остаток доведем. Вот с этим разберемся. Там все равно все довольно аналогично. Значит,
от этой штуки опять давайте посмотрим, что будет, если я прожу вертикальную прямую. Значит,
вертикальная прямая, она либо не пересекает наш прямоугольник запроса и его поворачивает,
то есть у меня будет картинка. Сложно мне. Да, низ короче, нижняя сторона. Так, либо он его
пересекает, да, медианный х его пересекает, у нас получается что-то такое. Т от полностью закрашенного
бауненбокса плюс, ну то же самое, где эта штука, это там нижняя какая-то часть, левая нижняя правая.
Вот, но при этом понятно, что вот эта штука это вот единица, да, потому что алгоритм работает так,
что как только прямоугольник запроса вложен в бауненбокс, мы просто сразу возвращаем всю
сумму из бауненбокса. Вот, ну и остается, смотрите, вот эта вот штука, и они на самом деле друг
через друга будут выражаться, и оттуда как раз получится корневая асимптотика. Значит,
давайте нарисуем последнюю такую рекурренту. Значит, здесь, если я прожу вертикальную прямую,
ой, вот просто, видимо, два, а нет, я прожу такую и вращаю, да, забыл, что я вращаю,
значит, я провожу вертикально, мы точно знаем, как она рассечется, это будет просто левый нижний
и правый нижний угол, вот, но только после вращения мы опять вернемся к такой картинке,
поэтому будет две вот такие конскурации. Вот, вот это самый важный момент, что у нас есть такая
картинка, она сводится к одной такой, а она вот этого сводится к двум предыдущим, то есть у нас
получилась рекуррента, выражаешь, то есть первая через вторую и вторая через первую, видно? Вот,
хорошо, значит, ну давайте здесь напишем, что, то есть, посмотрите, у меня вот эта штука выразилась,
эта штука от единицы, поэтому у меня остается просто в любом случае вот это вот выражение,
а потому что это одно и то же, отличается оно от единицы, поэтому это от единицы плюс, когда у
нас левая нижняя верхняя, левая нижняя правая привязка, ну вот, значит, я могу опять эту штуку
расписать, вот это вот, могу расписать через вот это, будет два, t от нижняя левая правая,
вот n на 4 плюс от единицы, и я наконец-то замкнул нашу рекурренту, то есть я просто вот это вот
расписал по этой формуле, и тем самым написал замкнутое выражение для рекуррента, когда у нас
привязка к левой нижней и правой сторонам, вот, ну а решение такой рекуррент, то есть что у меня
тут написано, что f от n, это 2 f от n на 4 плюс от единицы, ну это просто, например, по мастер-тиореме
корень из n, то есть либо мастер-тиорема, либо как-нибудь руками можно доказать индукцией,
то есть мы берем логарифм двойки по основанию 4, это будет как раз на степени одна вторая, вот это
вот это там что-то бесконечно мало по сравнению с от корнем из n, поэтому асимптотика просто берется
из ну как бы n в степени логарифм двойки по сравнению 4, тоже напишу это, n в степени логарифм двойки по
сравнению 4, ну вот и все, теперь если аккуратно все это проанализировать с конца в начало,
можно показать, что все симптотики на самом деле тоже корневые, ну давайте немножко это сделаем,
значит тут понятно, что корень, вот это мы уже доказали, здесь смотрите, эта штука, то есть я знаю,
что вот это от корня из n, дальше t, когда у меня привязка к верхней левой нижней сторонам от n,
это то же самое для n пополам и левая нижняя правая, но я знаю, что эта штука, это примерно корень
из n пополам, плюс шоут и низ, значит это просто корень от корня из n, просто потому что выражается
через что-то корневое с коэффициентом пополам, ну остается корень из n зависимость. Дальше,
здесь мы либо делимся пополам и сводимся к той же задаче, либо мы, вот здесь вот написано от
корень из n и сводимся к той же задаче, то есть смотрите, у меня задача сводится рекурсительно
сама к себе, когда у меня уголочек покрашен, я либо сразу свожусь к задаче в два раза меньше,
либо прибавляю корень и свожусь к задаче в два раза меньше, поэтому суммарное время работы не
больше, чем корень из n, плюс корень из n пополам, плюс корень из n на 4, корень из n на 8 и так далее,
потому что я каждый раз делюсь на два и в худшем случае прибавляю корень от текущего значения.
Если я скажу, что вот здесь вот корень, это конкретно c корня из n, время работы для уголочка не
больше, чем c корня из n, плюс c корня из n пополам, плюс c корня из n на 4, ну в общем по всем
степеням двойки. Это будет геометрическая прогрессия, что все сворачивается просто
от корни из n. Геометрическая прогрессия с шагом меньше единицы, которая имеет какую-то конечную сумму,
поэтому все опять корень из n. Здесь корень из n, ну и тогда если я здесь все докручу, то тоже
аналогично, собственно используя то же самое соотношение про геометрическую прогрессию. Здесь
будет от корня, здесь будет от корня. Последнее, мы получили структуру, которая отвечает на все за корень,
но на реальных данных, вот давайте последнее, на реальных данных работает хорошо, давайте вот так
просто скажу. На реальных данных, работает быстро. Ну потому что, грубо говоря, понятно, что на
реальных данных тот прямоугольник запроса который нам поступает, он, ну то есть вот здесь мы оценили
всегда худший случай, что прямоугольник запроса он всегда как бы, ну вот типа мы рассматриваем
всегда худший случай, что он как бы напополам
рассекается влево и вправо, но понятно, что рано или
поздно, если примогулик какой-то нормальный, случайный,
грубо говоря, то он рассечет, ну как бы уйдет в одну из
двух половин, и поэтому ассистентрика будет сильно лучше, чем
корень.
То есть теоретически можно показать только корень,
но как бы на практике получается, что эта штука работает
весьма-весьма-весьма быстро.
Все.
Спасибо.
