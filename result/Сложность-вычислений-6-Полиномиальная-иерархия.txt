По плану сегодня последняя лекция, совместная для PMI информатика и для PMF. Со следующей недели
по пятницам, они вроде уже были в прошлую пятницу, начнутся лекции Сергея Шестакова.
Конечно, можете продолжать ходить на мои, потом программа немножко разойдется, но не очень сильно.
Вот эта лекция и следующая посвящены Пальномиальной иерархии.
Пальномиальная иерархия. Давайте я сначала объясню, откуда она берется.
К ней можно с разных сторон приходить. Например, если идти с стороны математики, то есть такая
аерисметическая иерархия, это вы проходили на логике, все проходили. Можно сказать, что
Пальномиальная то же самое, только там кванты ограничены Пальномиальным перебором, и функция
вместо разрешимой, итоговое множество вместо разрешимого будет лежать в П. Но можно идти
наоборот, не от математики, а от задач. То есть глобальная ситуация такая, что есть куча разных
задач, которые откуда-то берутся, и мы хотим понять, какие из них проще, какие сложнее.
Например, рассмотрим задачи точная оптимизация. Ну, например, найти кликовое число.
Например, найти кликовое число. То есть что это значит? Это означает, что, можно это обозначить
в какой-нибудь язык. Клик, клик-намбр. Значит, это множество пар, если коротко, то это множество пар G и K таких,
что ω от G равняется K. То есть что это значит? Это значит, что размерные большие клики в этом графе
это K. То есть есть к вершин, которые все друг с другом соединены, а K плюс одной вершины уже нет.
Но, значит, если задача про просто клико, что существует клик размера K была в NP и была в NP
полной, то здесь не очень понятно, почему это вообще в NP. Ну и на самом деле неизвестно,
в NP это или нет. Потому что, смотрите, доказать, что есть клик размера K, можно просто предъявить эту клику.
Но доказать, что нет большей клики, непонятно как. Как доказать, что чего-то нет. Но иногда можно
какими-то рассуждениями, но в общем случае непонятно. Ну и наоборот. Если мы тут напишем,
что клик в число меньше либо равно K, то есть нет клики из K плюс одной вершины, то это будет задача из K и NP.
Но тогда непонятно, как опровергнуть то, что все клики размера строго меньше, чем K. В общем, как-то
ни в NP, ни в K и NP такая задача не ложится. С другой стороны, если P равно NP, то тогда это тоже очевидно
в P. Например, можно даже просто перебрать все K, их всего N вариантов, перебрать все K и понять,
в какой момент ответ с да меняется на нет. А можно и танвоечным поиском пойти. Если мы умеем проверять,
что есть клик размера K, то мы можем и точно размерные и большие клики найти. Если P равно NP,
то это тоже в P. Но с другой стороны, безусловно, ни в NP, ни в K и NP это как-то не ложится. А где же это лежит?
Типа того, да. На самом деле вся полинаминальная иерархия будет такой же. Спойлер, что если P равно NP,
то тогда вся полинаминальная иерархия схлопнется. Но хорошо, давайте вернемся сюда. Можно сказать так,
что это пересечение таких пар G и K, что кликовое число больше либо равно K, и таких пар G и K,
что кликовое число меньше либо равно K. Тогда вот это вот лежит в NP, а вот это лежит в ко-NP. То есть
это получается пересечение языка из NP и языка из ко-NP. Обратите внимание, что это совершенно не то же
самое, что пересечение NP и ко-NP. То есть языки, которые пересечены NP и ко-NP, они и в NP, и в ко-NP.
А здесь нет. Мы сначала берем язык из NP, потом язык из ко-NP, и их уже пересекаем как множество. И вот
это, наоборот, скорее всего ни в NP, ни в ко-NP не будет лежать. Есть еще один способ это представить.
Вот такое множество пар G и K таких, что кликовое число больше либо равно K. Значит, за вычетом
таких пар G и K, что кликовое число больше чем K плюс 1. Тут уже оба этих множества будут в NP.
То есть вот это вот в NP, и вот это вот в NP. И, соответственно, это будет разность двух
языков из NP. Это мотивирует название. Есть такое название DP, где D от слова difference,
как раз разность, difference polynomial. Это как раз множество A без B таких, что A в NP, B в NP.
Но это то же самое получается, что может пересечений. A в пересечении с B таких, что A в NP,
B в ко-NP. Не, но это все-таки очевидно, потому что такое разность от пересечений с дополнением.
А дополнение к NP в ко-NP? Вот так, хорошо. Теперь как это будет выглядеть, если мы это
запишем в кванторах. Смотрите, у нас же и для NP, и для ко-NP у нас было эквивалентное
определение через верификаторы и через кванторы. То есть у нас было X. X лежит в A тогда и только тогда,
когда существует Y такой, что V от XY. Это у нас NP. А X лежит в B тогда и только тогда,
когда для любого Z W от XZ. Это у нас ко-NP. А тут получается следующее. Если у нас пересечение,
ну то нужно просто конъюнкцию взять того и другого. Тогда получается, что X лежит в пересечении тогда
и только тогда, когда существует YV от XY и для любого Z W от XZ. Ну а дальше эти кванторы
можно вынести. Значит это равносильно тому, что существует Y для любого Z. Так, я просто
напишу V и W, значит аргументы там такие же. Или можно наоборот вынести. Это называется
предварённая нормальная форма. Для любого Z существует Y, значит V и W. Вот, но тут уже есть
некоторое, что называется альтернирование. Это существует для любого, для любого существует,
значит это альтернирование. Ну и на самом деле вот то, что вот такими штуками задаётся чередованием
кванторов в конечном количестве и потом полиномиальным предикатом, это и будет полиномиальная
иерархия. Вот, но пока давайте я ещё приду несколько примеров, когда такое возникает. Так,
значит примеры. Ну например, может быть задача о минимизации формулы. Задача о минимизации формулы.
Значит тут ставится вопрос. В принципе вопрос с точки зрения оптимизации такой. Какая самая
короткая формула, которая эквивалентна данной? То есть тут дана формула phi. Вопрос,
значит какова самая короткая, какова самая короткая, psi, эквивалентная phi. Ну, значит,
смотрите, ясно, что эта задача, в принципе, она более сложная, чем задача о выполнимости и более
сложная, чем задача от автологии. Потому что, смотрите, если формула, это, конечно, немножко зависит
от точного языка, но эти проблемы можно решить. Если формула невыполнима, то самая короткая
эквивалентная это тождественная ноль. Если формула в автологии, то самая короткая, значит,
самая короткая эквивалентная это тождественная 1. Ну, там дальше, в принципе, получается,
если она или тождественная ноль, или тождественная 1, то там одинаковая длина у самой короткой. Ну,
в общем, с этим как-то можно побороться. Вот, например. Ну, типа того, да. Да, например, так,
действительно. Вот, ну и в целом не очень понятно, как это делать. Вот, ну а можно писать формулу. Да,
смотрите, это задача поиска. Значит, это задача поиска либо самой короткой формулы, либо длины
самой короткой формулы. А задача с ответом «да» или «нет» будет такой, существует ли формула,
которая эквивалентная и более короткая, чем соответственно фи. Да, то есть задача с бинарным
ответом будет такой, что есть формула фи и пара из формулы фи и числа k, такая, что
существует ψ, значит такая, что ψ эквивалентна фи и длина ψ меньше или
равна чем k. Ну, конечно, да. Смотрите, вот какая она задача минимизации?
Задача минимизации вершинного покрытия. Да, у нас тоже вопрос, есть ли вершинное покрытие размер
меньше, чем данное. Вот это ВНП получается. А здесь есть ли эквивалентная формула длины
меньше, чем данный порог. Но это уже не ВНП получается, потому что даже если формулу
предъявить, на первый взгляд это НП, что к вам существование. Но проблема в том, что даже если
формулу предъявили, то непонятно, как проверить вот эту вот часть, как проверить, что формула
эквивалентна, потому что прямая проверка это построение таблицы истинности, а это экспедиционное
соответственно действие. Вот, поэтому чтобы в конце был полинамеральный предикат, нужно написать так,
значит, существует psi такое, что для любого x, значит, psi от x равняется phi от x, и длина
psi меньше, чем k. На длину мы уже как-нибудь посчитаем, а вот здесь нужен второй квантор
всеобщности. В общем, этот квантор можно вынести наружу, как всегда бывает в предварённой
нормальной форме, и получается альтернирование, что существует потом для любого. Так, ну вот такие
вот цепочи, называются sigma2. Ну а чтобы подчеркнуть, что в конце будет полинамеральный предикат, то ставят
еще сверху индекс p. Вот, или еще есть другое обозначение, значит, sigma2 p. Тут это либо понимать,
как синонимы, либо вот эту вещь определять по-другому и доказывать, что это одно и то же. Я не знаю,
мы это, наверное, пропустим, там, техническая вещь, но если в следующий раз останется время, то соответственно я
расскажу про то, какое еще может быть определение у этого, почему это одно и то же. Так, ну сейчас хочу еще
несколько примеров привести. Так, а у вас была теория М. Рамсея? Не было. Сейчас, а кто знает, что такое теория М. Рамсея о раскраске?
Понятно. Сейчас, вот есть такая задача школьная. Сейчас, есть такой анекдот, что социологи путем
анализа дружеских связей выяснили, что в любой группе шести человек есть либо трое попарно знакомых,
либо трое попарно незнакомых. Вот, на самом деле это теорема. Теорема довольно просто. Доказывается,
что в любом графе из хотя бы шести вершин есть либо три вершин попарно
соединенных, либо три вершин попарно несоединенных. Многие знают, как доказывается.
Теорема Рамсея это обобщение вот этого простого факта. И там есть целая теория Рамсея, где очень много
этих теорем. Но одна из теорем звучит так, что не просто для 3 и 3, а для любых двух чисел S и T есть
некоторое большое число R, что если в графе больше чем R вершин, то там есть либо клик размера S,
либо независимо от того, что размеры T. Вот, например, есть такая теория М. Рамсея. Ну и дальше есть
очень десятки разных формулировок, там какие-нибудь гиперграфы, какие-нибудь там раскраски, там и так далее.
Вот. Мы рассмотрим вот такую формулировку. У нас тут будут тройки графов G, H и K. Да,
на самом деле в этой теории Рамсея там много чего известно, но много чего и не известно. В
частности, неизвестно, чему равны вот эти числа, вот эти пороги R большое, если S и T хоть немножко
большие. Да, по-моему, там для 6 и 6, по-моему, уже точно неизвестно. Или там для 3 и 10,
кажется. Не знаю, 3 может известно, там 4 и 10 точно не должно быть известно.
Ну, хорошо.
Так, ладно, я удерживаюсь от комментариев. В общем, тут постановка такая, что есть три графа G, H и K,
и спрашивают следующее, что при любой раскраске ребер графа G в два цвета, да, то есть смотрите,
вот эта вот исходная задача про клики независимого множества, можно формулировать,
что мы красим ребра полного графа в красный и синий цвета. И, соответственно, есть либо граф
полностью соединенный красными ребрами, либо граф размера S полностью соединенный красными
ребрами, либо размеры T полностью соединенные синими ребрами. Вот, соответственно, здесь мы тоже
красим два цвета ребра, но не полного графа, а графа G. Да, то есть для любой раскраски,
так, не дайте здесь палочку, для любой раскраски из ребер графа G в два цвета, да, скажем,
красный и синий. Либо существует красный подграф изомовный H, существует красный подграф,
дайте я словами напишу, значит, красный подграф изомовный H, или существует синий подграф
изомовный K. Да, то есть спрашивается, верна ли вот такая вот версия теоремы Рамсея для вот
этой вот тройки графов. То есть исходная теорема, это когда они все полные, да, значит, G это полный
там на R большой вершинах, это на S вершинах, это на T вершинах. Вот. Ну, здесь уже видна структура,
надо только сделать комментарий, что вот то, что прям подграф изоморфин H, это тоже непонятно,
лежит в P или не лежит, но можно дополнить еще, что существует подграф и изоморфизм. Так что этот
изоморфизм действительно задает вложение H в красный подграф графа G при такой раскраске.
Вот. То есть тут получается структура для любого существует. Значит, для любого существует,
это получается P2. Пальномиальное. Да, кстати, значит, если вы путаете, где там sigma, а где P,
то мнимоническое правило. Значит, нужно, во-первых, смотреть на первый квантор. Ну, это скорее
определение, что если первый квантор существования, то тогда sigma, а если первый
квантор сообщества, то P. Вот. Но как это запомнить? Ну, можно по-разному. Например,
так. Смотрите, sigma это сумма. Sigma это сумма, а сумма похожа на дизъюнкцию. В строгом смысле она
равна дизъюнкции, если вы понимаете 0 как ложь, а любое положительное число как истину. Так бывает
в языках программирования. Ну и тогда реально. Реально тогда сумма это дизъюнкция. Если там
никакой остаток не берется, а просто 0 это ложь, а любое положительное число это истина. Тогда сумма
это и есть дизъюнкция. Ну а дизъюнкция существования. Дизъюнкция верна, если существует хотя бы
одна единица. Ну а P наоборот. P это произведение. Произведение это конъюнкция, а конъюнкция это
всеобщность. Ну да. Да, конечно это. Не, ну а то, как я сказал, это полезно как бы с разных точек зрения.
Да, то есть это сразу. Сразу вы вспоминаете, что существование дизъюнкции одно и то же. Так,
ну ладно. Смотрите, это примеры, где у нас одна перемена квантора. Обратите внимание, что если
квантры одинаковые, то не нужно ничего добавлять. Да, увеличивать индекс. Просто нужно объединять
вот эти вот объекты, которые, например, существуют. Существует подграф и существует изоморфизм. Это
то же самое, что существует пары из подграфа и изоморфизма. Так, ну давайте еще парочку примеров,
где уже возникнет цепочка из трех кванторов. Так, во-первых, есть такое понятие кликовая раскраска.
Кликовая раскраска. Кликовая раскраска это такая раскраска, при которой любая максимальная,
то есть неувеличиваемая клика раскрашена хотя бы в два цвета. Да, то есть это раскраска вершин
графа такая, что любая максимальная, то есть неувеличиваемая клика содержит вершины хотя бы
двух цветов. Да, то есть содержит вершины разных цветов. Вот, и вот, значит, максимальность клики,
в отличие от максимальности размера клики, можно проверить, что можно просто перебрать все оставшиеся
вершины и посмотреть, можно их добавить к клике или нельзя. Вот, но тем не менее, самих максимальных
клик может быть очень много, даже экспедиционное количество. Вот, поэтому просто так, ну понятно,
что вопрос ставится, есть ли раскраска в кацсветов. Вот, и тут получается тоже пока еще сигма два,
то есть существует раскраска, значит, что для любой клики, если k это максимальная клика,
если k это максимальная клика, то тогда я вот так напишу, раскраска этой клики это не константа,
то есть там есть хотя бы два значения. Вот, значит, это еще один пример сигма два, да, потому что вот это
все можно проверить за полином. Вот, но дальше, значит, можно заметить, что в отличие от обычной раскраски,
кликовая раскраска не наследуется в подграф, то есть если весь граф обычным образом раскрашет
скат цветов, то любой подграф тоже раскрашивается, и та же самая раскраска годится. Вот, но для кликовой
раскраски это неверно. Простейший пример такой, значит, рассмотрим пятиугольник, в котором проведена
одна диагональ, тогда его можно покрасить кликово в два цвета, значит, один-один-два, тут два-один.
Максимальные клики это вот этот треугольник, и в нем есть вершины разных цветов, ну и вот эти три
рыбра отдельные, там тоже есть вершины разных цветов. Вот, а вот если вы посмотрите на пятиугольник
без диагоналя, то для него кликовая обычная раскраска это одно и то же, потому что тут
треугольников нет, значит, максимальные клики только рёбра. Вот, ну и конечно два цвета тут нельзя
покрасить, значит, тут нужно три цвета. Тут хотя бы три цвета. Вот, при этом он подграф вот этого.
Ну и, соответственно, получается такая задача, называется наследственная кликовая раскраска,
или наследуемая кликовая раскраска, или, точнее, наследуемая кликовая раскрашиваемость.
Значит, верно ли, что и данный граф, и любой подграф можно кликово покрасить в два цвета?
Да нет, не обязательно одно и то же. А, это важно, нет, значит, я специально говорился, раскрашиваемость,
то есть там могут быть разные раскраски. Я думаю сейчас, если одна и та же раскраска,
то это будет то же самое, что просто обычная раскраска, то что всегда можно взять такой подграф,
где данное ребро не будет входить ни в один треугольник, и тогда у этого ребра должны
быть разные цвета. Так что тут да, тут прям важно, что для разных подграфов будут разные раскраски.
Вот, так, ну и тут будет,
значит, тут будет уже цепочка из трех кванторов.
Для любого подграфа существует, ну, значит, все то же самое, существует раскраска для любой
максимальной клики. Наследуемая кликовая раскрашиваемость.
Получается, что для любого подграфа, для любого подграфа существует раскраска,
значит, здесь для любой клики, ну и дальше все то же самое. Вот, и вот это называется P3.
Значит, первый квантор для всеобщности и два альтернирования, то есть три группы кванторов.
Вот, так, ну осталось sigma3. Значит, на самом деле, для там четырех и выше уже как-то нет особо
естественных примеров. То есть почти все, что возникает на практике, будет на втором или третьем
уровне. Ну а в теории чередование может быть сколько угодно. Так, значит, последний пример,
это задача о размерности вапника Червоненкеса. А это у вас было где-нибудь? Размерность вапника
Червоненкеса. Это в машинном обучении такая, в теории машинного обучения важная концепция.
Сейчас я напишу. Значит, это еще VC, размерность называется
вапника Червоненкеса. Так, давайте я это расскажу, это вообще интересная штука.
Я не знаю, я думаю, что с первого раза не будет понятно, зачем она вообще нужна, но хотя бы
формально давайте разберемся, что там происходит. Значит, это вообще у какого объекта она бывает?
Этот объект это семейство множеств. То есть у нас есть какое-то семейство множеств,
С1 и так далее, СКТ. Они все под множество какого-то объема еще множества. Значит, 1 и так далее N.
Так, значит, тогда определение такое. Значит, вот это вот размерность вапника Червоненкеса от
вот этого там С красивого семейства множеств. А значит, это максимальный размер множества
D, что вот это D это под множество вот этого объема еще множества от 1 до N. И кроме того,
значит, для любого под множество, для любого X под множество D существует индекс И такой,
что вот это СИТ, пересеченное с D в точности равняется X. Да, С красивый это набор из вот этих СИТ.
Так, сейчас, образование закончилось. Значит, почему это такое вообще может быть нужно? Смотрите,
что вообще такое машинное обучение? Что дан какой-то набор примеров, и мы, соответственно,
хотим про них что-то понять и потом предсказать про те примеры, которые не дали. Но вот можно
считать, что вот эти СИТ это как бы те примеры, которые нам дали, а мы хотим как бы что-то,
чему-то научиться про то, как эти СИТ образованы, и мы можем задавать вопросы, а вот такой-то ИТ,
сейчас, ну не ИТ, и у нас вот здесь, там же ИТ элемент объема еще множества в СИТ там лежит или нет.
Ну, не знаю, можно считать, что, например, какой-то опросник такой длинной в Н вопросов. И, соответственно,
на каждый вопрос можно ответить да или нет, но и, соответственно, СИТ это множество вопросов,
на которые там данный человек ответил да. Вот, и мы хотим там что-то понять про это общество,
например. Ну или еще там может быть миллион разных примеров. Вот, тогда смотрите, что это такое?
Это вот если мы будем смотреть конкретно на вопросы, сейчас, ну и может быть так, вот в
статсиологии бывает так, что там ответ на какой-нибудь один вопрос с высокой вероятностью предсказать
какой-нибудь другой вопрос. Вот, но вот это множество ИКС, это такое множество вопросов,
что ответы на него не предсказывают ничего. Да, то есть получается, что, может быть, например, так,
что мы, значит, что, например, это вот какие-то там группы вообще возможных ответов на вопросы,
и мы по неизвестной группе хотим понять, по неизвестным ответам хотим понять,
какой группе она принадлежит. Ну а, соответственно, если мы будем задавать вопросы из вот этого ИКСа,
то мы ничего не сможем понять. Ну то есть сейчас, что значит ничего не сможем понять? Сейчас,
наверное, наоборот. Мы ничего не сможем понять, а мы сможем как бы наиболее интенсивно сузить
число вариантов. Ответы на вопросы из этого ИКСа нам как бы не... Каждый раз мы отсекаем какие-то
варианты. То есть тут нет лишних вопросов из этого ИКСа. Даже если на какие-то вопросы мы уже
получили ответы, мы всё равно не можем пропустить какой-то вопрос, чтобы не потерять исключение
каких-то вариантов. Вот так. Ну, не знаю, может, я немножко путанно объяснил, но, в общем, вот это
используется. Есть, конечно, много других примеров. Но дальше, чтобы это поставить как вычислительную
задачу, нужно всё-таки чётко сказать, как у нас этот набор эссыток задаётся. Сейчас, давайте я
закончу рассказ и сделаем перерыв. Потому что, если они все задаются в явном виде,
если все эти множества задаются в явном виде, просто перечислением элементов, например, то тогда
вообще ясно, что вот это размерство не больше, чем логарифм от K, потому что у нас есть два в
тепени размер D разных подмножеств, и для каждого подмножества должен быть свой эсытый. Поэтому ясно,
что вот эта размерность не больше, чем логарифм в H, двоичный. А тогда, например, все строки для
ныка можно перебирать. Если в явном виде эсыты задавать, то это будет не очень сложная задача.
Не знаю, в коэнпе, наверное, она будет. Или даже сейчас. Или вообще даже в п, потому что
не в п, а в квази-п, что ли. Нам нужно перебирать подмножество размера логарифм. Это не два в тепени
логарифма отчетов сочетаний из N по логарифму. Это, в общем, N в тепени логарифма K, а если K само,
там порядка N, то это будет как раз N в тепени логарифм. А вот это можно вообще просто перебрать.
Подождите, это мы D перебираем. D у нас размер логарифм. Для D будет квазиполином вариантов,
а если D фиксировано, то тогда все х перебрать это полином, потому что это два в тепени логарифм,
и все и перебрать тоже полином, потому что это K. Если в явном виде, то это будет квазиполином,
ну или там, по крайней мере, в NP, наверное, будет лежать, что если нам предъявили D,
то тогда мы все остальное можем проверить. Но, может быть, неявно заданное S такое,
что у нас есть, скажем, N формул, фе-1, фе-1, ну или не формул каких-то еще описаний,
вот. И, соответственно, значит, phi it от x, так, нет, сейчас, давайте, и у нас будет, пусть будет
по-прежнему индекс МС, значит, вот, phi gt от i равно единицы тогда и только тогда, когда g лежит в S it.
Вот, то есть формул подставляем номер множества, а формул говорит, данный элемент лежит в множестве или не лежит.
Вот, и за счет этого мы можем, в принципе, описать гораздо больше семейства. Да, то есть теперь K может
быть тоже порядка N. Сейчас, нет, не порядка N, а порядка экспонента от N, потому что теперь,
ну, как бы порядка экспонента у длины описания, длина описания, длина формул, значит, число
переменных, ну тоже типа длина, ну и меньше, конечно, но может быть порядка, типа длина делить на 100,
например, или что-нибудь такое. Вот, а число разных i, это два в степени число переменных, то есть
может быть два в степени N на 100, например. То есть тут K может быть два в степени, скажем,
омега большое от N. Значит, омега большое означает, что есть какая-то константа, может быть маленькая,
но положительная. Вот, тогда это все пристанет работать, да, потому что теперь логариф станет
снова линейным, да, и перебирать себе под нож, что мы не сможем. Вот так. Ну и тогда,
тогда получится sigma3 сейчас. Значит, смотрите, размерность вот этого семейства, заданного
формулами phi1 и так далее, phiN, значит, больше либо равна, чем d, значит, тогда и только тогда,
когда существует, ну, значит, теперь как бы все эти кванторы уже нельзя убрать, существует d под
множество, 1, так далее, N такое, что для любого x под множество d существует и, значит, такое,
что, ну, как там написано, сейчас, давайте вот все в термах фежи-то я напишу. Значит, у нас получается,
что тут, в принципе, еще один квантор, но и последний квантор полинамиальный, да, я его давайте
напишу, значит, что для любого ж уже элемента 1, и так далее, N у нас получается, что, а, сейчас,
он не 1, тогда N, а d только можно написать. Так, для любого ж из d получается, что ж лежит в x тогда
и только тогда, когда phi ж от i равняется единице. Так, ну вот, хотя здесь даже 4 получается квантор,
но последний будет полинамиальным, да, потому что нам нужно перебирать просто все элементы
этого множества, да, то есть последний это полинамиальный перебор, вот, ну, а это понятно,
просто мы напрямую вычисляем, да, и проверяем, вот, а вот все остальные, да, значит, существует,
для любого существует, уже никак нельзя сократить, да, то есть получается, существует, для любого
существует это sigma3. Так, вот такой пример. Так, ну ничего, понятно? Хорошо, дайте сейчас перерыв,
я пока сотру. Значит, общее определение, что такое класс сигмаката и что такое класс пиката.
Значит, а лежит в сигмакатом полинамиальном, значит, если существует полинамиально вычислимый
v, откаплю с одного аргумента. Так, ну ладно, не буду писать. Значит, такое что? Значит, такое что для
любого x? Верно следующее. Значит, x лежит ва тогда и только тогда, когда существует y1, для любого
y2, существует y3 и так далее. Ну а в конце, в зависимости отчетности, значит, если k нечетный,
то последний существует, если k отчетный, то последний для любого. Значит, y ката и дальше v от x,
y1 и так далее, y ката. Да. Да. Нет, это правда. Это правда, что должна быть вот
полинамиально вычислимое должно быть от длины x. То есть вот этот полином, он от длины x. И тогда
автоматически все y тоже будут полинамиальны, потому что просто больше не прочтет этот v. Да,
это как СНП. Либо альтернативно можно сказать, что каждый y ограничен полиномом, и кванторы,
соответственно, внутри всех слов длины полином. Так, хорошо. Значит, p ката аналогично,
только наоборот. Значит, p ката аналогично, но, соответственно, первый квантор наоборот. Для
любого y1 существует y2, для любого y3 и так далее. И здесь для нечетных для любого,
для отчетных существует y ката, v от x, y1 и так далее, y ката. Вот. Значит, и тогда получается
такая диаграмма. Значит, смотрите, если k равно 0, то тогда, значит, сигма 0 полинамиальная,
то же самое, что pi 0 полинамиальная, и то же самое, что просто p. Значит, 0,
никаких кванторов нет, и просто v от x получается. Вот. Значит, дальше сигма 1, это НП. Значит,
один квантор, что они, это НП. И, конечно, p вложенный в НП. Значит, дальше pi 1, и это ko-NP.
И тут, соответственно, p вложенный в ko-NP тоже. Вот. Значит, дальше в сигма 2 и pi 2 вложение вот
такое вот, и крест-накрест. То есть каждый, а, кстати, вот то Dp, оно где-то между ними еще,
соответственно, Np и ko-Np вложено в Dp, а оно вложено в сигма 2 и pi 2 и даже в пересечение. Вот.
Ну и так далее. Значит, и так далее они все вот так вот друг в друга вложены. А в итоге есть pH.
Значит, все это вместе вложено в pH, а pH это просто объединение по всем k. Да. Определение pH,
что это объединение по всем k, там, от нуля до бесконечности, сигма kt pt. Ну или pi kt pt,
за счет этих вложений все будет то же самое. Так, а откуда вообще эти вложения берутся? Ну,
оттуда, что мы можем просто добавить фиктивный квантор. Да, то есть можем сделать вид, что у нас
есть тут еще одно yк плюс первое, но от него вы не зависите, на самом деле, но квантор мы по нему
поставим. Вот. Раз от него ничего не зависит, то неважно, какой и ставить квантор, в какую часть
формулы. Да, то есть можно поставить в конец, тогда это будут вот эти прямые вложения. Можно
поставить в начало фиктивный квантор, тогда это будут вложения крест-накрест. Так. Ну хорошо.
Вот, поэтому это и иерархия. Да, иерархия, потому что такие вот вложения. Так. Ну дальше,
как всегда, когда есть вложения, то всегда интересно, будут ли они строгими. Да, то есть вот
вопрос про P и NP, это вопрос про вот это вот начальное вложение, строго оно или нет. Значит,
мы не знаем, строго оно или нет, но зато мы знаем, что если оно не строгое, то есть они равны, то тогда,
как я сказал в начале, вся эта конструкция схлопнется, да, и получится просто, что все это одно и то же.
Значит, теорема такая, что если P равно NP, то тогда P равно pH.
Если P равно NP, то тогда P равно pH. Так, как это доказывать? Ну вы, наверное, уже знаете, что если
P равно NP, то P равно CoNP. Значит, если P равно NP, то тогда P равно CoNP. Значит, просто потому,
что мы перешли к дополнению, а дополнение к P это P, а дополнение к языкам из NP это CoNP.
Так, хорошо. Ну а дальше надо действовать по индукции. Дальше, например, посмотрим на sigma2.
Значит, пусть A лежит в sigma2. То есть мы получили, что X лежит в A тогда и только тогда, когда, скажем,
существует Y для любого Z, и тут какой-то V от XYZ. Ну а дальше, смотрите, вот если мы посмотрим на множество
пар XY таких, что для любого Z V от XYZ, то вот такое будет лежать в CoNP просто по определению.
Значит, такой лежит в CoNP, потому что здесь один квантор всеобщности. Раз он лежит в CoNP,
то он и в P тоже лежит. Следовательно, лежит в P. То есть получается, что для любого Z V от XYZ
равносильно просто W от XY, где W это полиномиальный алгоритм. Вот, ну тогда и вот это вот.
Значит, тогда существует Y для любого Z V от XYZ равносильно существует Y W от XY. А это у нас получается из NP.
Поэтому A лежит в NP. Ну а поскольку мы начали с того, что P равно NP, то тогда A лежит и в P. То есть вот мы
получили, что sigma2 тоже равно P. Ну и P2 аналогично. Ну и дальше по индукции. Дальше по индукции мы последний
квантор отцепляем, заменяем на какой-то другой предикат полиномиальный. А все предыдущие схлопываем
по предположению индукции. Так, ну что, понятно? Может быть, конечно. Может быть, что, скажем,
NP не равно NP, а NP равно кое NP. Такое не исключено. Но общее правило такое, что если на каком-то уровне
произошло такое схлопывание, то тогда оно продолжится выше.
Так, значит, общая теорема, что три условия эквивалентные. Значит, обобщенная теорема, обобщенная с предыдущей,
это называется коллапсирование полиномиальной иерархии. Значит, это теорема о коллапсировании pH.
Значит, теорема такая, что следующие условия эквивалентные. Так, первое, что сигма-к полиномиальная
меняется сигма-к плюс первому полиномиальному. Значит, второе, что сигма-кт равно пкт. Но здесь только если k больше нуля.
Если k равно нулю, то это мы уже рассмотрели, это получается статья арема. Просто для нуля это верный то и другое p.
А то, что p равно NP, из этого не следует. Если NP равно кое NP, то тогда сигма-2 равняется сигма-1, то есть равняется NP.
И третье, что вся полиномиальная иерархия. Вся полиномиальная иерархия равняется сигма-ктp.
Так, хорошо. Да, если k равно нулю, то только первые и третьи эквивалентные, это мы уже доказали в той теореме.
Если k больше нуля, то они все три эквивалентные. Да, конечно, ка одно и то же.
Ну хорошо, давайте сначала из первого-второго. Доказательство из первого-второго. Да, он легко получается.
Значит, из первого-второго будет так, что просто π-катая полиномиальная вложена в сигма-k плюс первая полиномиальная.
А если мы предполагаем, что k плюс 1 равно к атому, то, соответственно, это равняется сигма-катому.
То есть π-катая вложена в сигма-катая. Так, дальше, а вот это мы, кстати, не обсудили. Ещё нужно показать в обратную сторону, что сигма-катая вложена в π-катая.
Но это делается вот как. Что если а лежит в сигма-катом, то тогда а с чертой лежит в π-катом. Почему?
Ну, потому что если мы к такой формуле с альтернированиями добавим отрицание, то это отрицание пронесётся вглубь, все квантры перевернув.
Но при этом отрицание полиномиального тоже полиномиальное, то есть в сердцевине останется полиномиальный предикат.
Поэтому получается, что а с чертой записывается в такой же формуле, но где все квантры перевернуты, и, соответственно, в конце тоже полинов.
Так, хорошо. Дальше, из предыдущего, если а с чертой в сигма-катом, то тогда отсюда, если а с чертой в π-катом, то отсюда оно и в сигма-катом.
А дальше мы еще раз переворачиваем, берем дополнение к дополнению, и получаем, что тогда у нас а будет лежать в π-катом.
То есть получили обратное вложение. Теперь любой элемент сигма-катого лежит в π-катом, значит сигма-катая вложена в π-кат.
Ну вот, значит, вложения в одну сторону и в другую, значит они равны. Значит, из первого и второго получилось.
Так, какое-то направление еще очевидно. Из третьего и первого, наверное, очевидно.
Самое, наверное, очевидно из третьего и первого, просто из определения.
Потому что сигма-к плюс первое между сигма-катом и п-аше, если они совпадают, то тогда сигма-к плюс первое тоже с ними совпадает.
Но, правда, из второго такие штуки иногда по циклу доказывают, потому что из первого и второго, из второго и третьего, из третьего и первое.
Но из второго и третьего на самом деле так напрямую не получится. То есть из второго и третьего все равно через первое пойдет.
Давайте все-таки кратко запишу.
Значит, у нас сигма-катая полинамиальная вложена в сигма-к плюс первое, это вложено в п-аше.
А если это равняется сигма-катая, то тогда и сигма-к плюс первое тоже равняется сигма-катая.
Так, теперь давайте из второго первое.
Значит, из второго первое будет похожее рассуждение на то, что мы выделяем какой-то фрагмент и его заменяем на другую формулу с кванторами.
Значит, смотрите, пусть у нас а лежит в сигма-каплю с первым, то есть х лежит в а тогда и только тогда, когда существует фрагмент.
Значит, смотрите, пусть у нас а лежит в сигма-каплю с первым, то есть х лежит в а тогда и только тогда, когда существует у1, для любого у2, существует у3 и так далее.
Значит, и тут какой-то там для любого или существует ука плюс первое, а тут в, а вот х, у1, у2 и так далее ука плюс первое.
Грубо говоря, мы выделяем вот эту вот часть, и она будет в пикатом, а если у нас пикат равно сигма-катая, то она и в сигма-катом тоже лежит.
То есть вот это лежит в пикатом, следовательно, лежит в сигма-катом, и потом мы заменяем все кванторы.
То есть у нас получается, что существует у1, существует какое-то z2, значит, для любого z3 и так далее.
Здесь тоже, наоборот, существует для любого zk плюс первое, ну и дальше в, не в, а w, x, y1, z2 и так далее zk плюс первое.
Ну а дальше вот эти кванторы мы объединяем и получаем сигма-катая. То есть тут существует пара y1, z2.
И все вместе получается сигма-катая.
Ну, наверное, понятно, формально надо сделать, как мы там делали. То есть мы рассвариваем множество пар из xay1,
для которых все дальнейшее верно. Такое множество лежит в пикатом, значит, он лежит в сигма-катом по предположению.
И дальше мы расписываем такую формулу, тогда получается, что исходное a тоже в сигма-катом.
Тут, конечно, мы используем, как мы используем штука больше нуля, так что добавление вот этого внешнего квантора не влияет на индекс.
Да, почему не влияет? Потому что здесь уже есть квантор существования, это штука больше нуля.
То есть мы используем штука больше нуля.
Ну, типа того, да. Не, выделить мы можем, но если она нулевая, то там не будет квантора.
Нет, ну подожди, тут ка плюс первое, если ка плюс первое, там он есть, но просто не будет следующего квантора.
Но даже если ка равно нулю, то здесь ка плюс один это один, и это как бы np получится.
Нет, потому что нам нужно, чтобы внутри был уже квантор.
Нам нужно, чтобы добавление вот этого внешнего квантора не поменяло глубину.
А оно не поменяет, если есть первый квантор, с которого все начинается.
А если здесь нет вот этого квантора, существует z2, то тогда это увеличит, и мы ничего не докажем.
А если он есть, то тогда должно быть штука больше нуля.
Ну вот, понятно, что мы доказали, что ка плюс первое вложено в каты, а каты в ка плюс первое всегда вложены, значит они равны.
Так, ну и последнее, значит, из первого третья.
Ну, точнее, можно с вами здесь второго третья сделать, но сейчас, короче говоря, смотрите, тут такое будет хитрое рассуждение.
Может по-разному рассуждать, но мне нравится такое рассуждение.
Значит, из второго третья.
Значит, смотрите, пусть у нас sigma kt равняется pkt.
Тогда по первому, не по первому, а вот по предыдущему получается, что выполнено первое.
Что sigma kt равняется sigma k плюс первое.
Но дальше, аналогично, точнее, переходя к дополнениям, мы получим, что pkt равняется pk plus первое.
Потому что pkt это все дополнения к языкам из sigma kt, pk plus первое все дополнения к языкам из sigma k plus первое.
Если это одни и те же языки, то это тоже одни и те же языки.
И тогда получается, что у нас получилось, что sigma k plus первое равняется pk plus первое.
И также равняется sigma kt.
Хорошо, но дальше можно как бы действовать по индукции.
Далее получим, что sigma k plus второе равняется pk plus второе, равняется sigma k plus первое и равняется sigma kt.
Ну и дальше по индукции.
И по индукции получится, что sigma k plus lt равняется sigma kt.
И, следовательно, объединение их тоже равняется sigma kt.
Вот такое рассуждение.
Теперь, что дальше будем изучать?
Мы будем изучать полные задачи.
На вопрос, есть ли полные задачи в pH?
Есть ли pH?
Нет.
Ну да, совершенно верно.
Дело в том, что каждый уровень замкнут относительно коллапсирования.
Если B в sigma kt и A сводится к B, то тогда A в sigma kt.
Соответственно, если pH полная задача, то тогда C лежит в sigma kt с одной стороны,
потому что она лежит в pH. Она лежит в pH, значит, на каком-то уровне.
С другой стороны, для любого A из pH A сводится к C.
И, соответственно, из этого получается, что pH просто равняется sigma kt.
Если есть pH полная задача, то тогда pH коллапсирует.
Но что точно есть?
Точно есть полные задачи.
Ну, во-первых, NP и QNP полные, это мы уже знаем.
Но и дальше и sigma2, p2, sigma3, p3 и так далее тоже есть полные задачи.
На каждом уровне существуют полные задачи.
В следующий раз мы эти полные задачи поизучаем.
Будут некоторые примеры.
Ну и дальше, если успеем, то немножко поговорим про еще другие характеризации pH.
Например, если NP строится на нетерминированных машинах,
то pH на специальных альтернирующих машинах.
Если будет время, мы про это поговорим.
Все, спасибо за внимание.
До встречи.
