Итак, сегодня нас ждет увлекательная трехчасовая
лекция, хотя и интерактивная, про прикол и C++20.
Никакие карутины на другом курсе, вам уже все рассказали
про карутины на втором курсе.
Как там задачи с карутиными?
Какие карутины?
Так, карутины были на курсе конкарнси.
У вас были?
Да.
Ну все, больше их не будет.
Дальше уже сами.
Вот там я вам не помощник.
Тем более, что там и в 23-26 что-то фиксит, правит,
и там непонятно.
Мы будем только про эти концепты говорить, но там оказывается
столько говорить, что вот нам на три часа вот так вот
хватит.
Ну вот, сосредоточились, собрались силами и поехали.
Первое, о чем надо сказать, это о named requirements.
Слышали такие слова?
Они с нами непонятно с какого стандарта, наверное,
с самблок первого.
Сразу видно, кто всю ночь ботл.
Ну что такое named requirements?
Вот есть какое-то слово, имя, и там написано, что
подовлетворяет требованию итератор, если у него тыры-пыры-пыры-пыры.
Что-то написано.
Какой-то оператор плюс, еще чего-то.
Там еще виды разных этих итераторов начинаются,
и много их, короче, в стандарте.
Очевидно, что это не самая хорошая идея, вот эти вот
requirements.
Ну как бы в чем их смысл вообще?
В некоторых местах стандарта говорят, что если вы используете
вот этот алгоритм, то от вашего типа требуется исполнять
вот такие требования, а если вы их не исполняете,
надевать behavior.
Ну вот как часто вы залезаете в стандарт, написав там свой
итератор или какой-нибудь свой контейнер и проверяете,
что все эти требования строго соблюли?
Каждый раз.
Ну, это вброс, да, вот статистический.
В среднем народ вообще не парится, как хочет, так и пишет.
И, ну, иногда внезапно оказывается, что все-таки какие-то требования
нарушены, у нас undefined behavior, и один раз на миллион
внезапно оказывается так, что компилятор вокруг этого undefined
behavior что-то оптимизирует, и потом ты сидишь неделю
дебажишь, не можешь понять, что пошло не так.
Это, конечно, супер редкие случаи, обычно там все проще,
что там какая-нибудь ошибка компиляции просто вылазит,
что, мол, я сломался.
Ну, все равно неприятно, хочется, чтобы как-то
попонятнее было.
Ну, собственно, вот список минусов кратко.
В коде мы никак эти named requirements не описали.
Поэтому, ну, нужно куда-то еще лезть, что-то там смотреть,
неприятно.
А сообщения об ошибках абсолютно жуткие, да?
Ну, сейчас посмотрим на них.
Ну, и проверять, собственно, насколько наш тип подходит,
мы должны просто глазками.
Это как-то немножко тупо, сидеть и высматривать,
где там я что там ошибся, где там что-то не удовлетворил.
Ну, поэтому, очевидно, и вот зашел весь этот разговор
о том, к чему мы в самом конце сегодня подойдем, о концептах.
Вот такой примерчик.
Вот stdsort, он требует random access-атератора.
Понятно, почему, да?
На forward-атераторах за какую симпточку можно сортировку сделать?
Ну, как бы это и верно, и нет.
Тут каверзный вопрос.
Разрешается ли доп-память?
Вот если доп-память разрешается, то можно и за n log n тоже.
Да, если не разрешается, то действительно за квадрат,
потому что там, ну, как-то нужно что-то типа пузырька делать, наверное.
Вот.
Ну, соответственно, такое требование наложено
на ваши итераторы, которые вы sort-запихиваете.
Ну, вот случайно пришел стажер, такой код написал.
Что мы получим?
Ну, казалось бы, если бы у нас был нормальный язык,
нам бы сказали, ой, извините, простите, вот этот итератор,
он как бы forward, а это же знаете, что значит?
Там его только вперед-назад двигать нельзя,
а просто как-то плюсовать нельзя,
и вот мы как бы это, извините, выберите другой контейнер, пожалуйста.
Ну, то есть РАСТ вот так делает.
Но на языке C++ говорят вот так, и это прекрасно.
Ну, то есть тут нужно обладать некоторым опытом и скиллом,
чтобы понять, в чем проблема.
Тут реверс-итератор какой-то упоминается, и что-то ну жутко.
Хочется более адекватных сообщений об ошибках как минимум.
Что я хотел сказать?
Ну вот еще, помимо алгоритмов каких-то обобщенных,
мы иногда пишем обобщенные структуры данных.
Ну, для них тоже как-то хочется понимать,
а что вообще требуется вот от этих вот шаблонных аргументов.
Здравствуй.
Ну, наверное, можно догадаться, что тут внутри key-value написано,
наверное, это какой-нибудь мапчик упорядочный.
Наверное, тут оператор меньше требуется.
А может, это хэш-мапчик, и требуется std-hash.
Ну, и вот непонятно, и нужно какие-то комментарии идти смотреть,
или просто пробовать, или код читать.
Да, вот, ну, а что? Ответа нету в коде.
Нужно как-то вне структуры языка ответ на этот вопрос искать,
либо методом тыка.
А бывают еще более сложные случаи,
когда у нас не просто что-то конкретное можно подставить,
ну, аля там требуется, чтобы хэш был у ключа.
А бывает, что мы в зависимости от того,
какими свойствами обладает тип T,
наделяем этими свойствами сам контейнер.
Вот так вот.
Поняли, что я сказал?
Ну, по-моему, даже на схемке понятно,
что std-ri-t можно двигать, ну, делать move,
только если сам t-move был.
И вот это вот тоже наследование каких-то свойств,
оно как-то никак не выражается,
и это вообще сюрприз, и комментарии, и все это неприятно.
Поэтому мы начнем углубляться в C++20,
где все это фиксится.
Ну, я сказал как бы концепты,
но концепты будут в самом-самом-самом конце.
Потому что до них нужно еще дойти.
Тут другие слова будут.
Первые слова — это constraint.
Ну, по-русски это ограничение.
Ну, можно выпендриваться и пытаться говорить по-русски,
но я думаю, я не справлюсь,
и буду все равно иногда проскакивать constraints,
а то и чаще.
Другие constraints.
А очень просто.
Новое ключевое слово добавили — requires.
Ну, и вот вы что-то пишете,
и можете написать после заголовка шаблона requires.
А дальше какое-то булевое выражение.
Тут тупо написано.
Вот этот шаблон требует, чтобы n был не больше 10.
Понятно? Понятно.
Ну, если подставить и больше,
то ошибка компиляции вам напишут.
Требование не выполнено.
И отлично.
Вот так, ок, вот так ошибка.
И вот эта вот вся конструкция вместе requires что-то там,
это называется requires clause.
Почему я акцентирую внимание на какой-то терминологии дурацкой?
Потому что будет еще requires expression.
И нужно не путать.
А вот, собственно, вот тот кусочек,
который уже после слова requires написан внутри этого clause,
это называется constraint.
Ну, и констрейтов, конечно, может быть, несколько,
но сейчас все это увидим.
Вот еще примерчик.
Это переменная.
Ну, шаблон переменной, если быть точным,
и причем constexpr,
оно просто превращает какое-то число в минус число.
Ну, и тут навешан constraint,
что тип числа должен быть знаковый.
Это, конечно, дурацкий примерчик,
но суть можно и на переменных тоже писать constraint.
Ой, а вот это я более не переправил,
надо переправить.
Ну ладно, на юзингах можно писать constraint внезапно.
Я вот не знаю, насколько это полезно, но можно.
Ну и, конечно же, на функциях можно.
Но можно двумя разными способами.
Вот следите за руками, что называется.
В чем разница сверху и снизу?
Видите?
Да, тут оно сразу после заголовка шаблона,
а вот здесь после уже круглых скобочек,
то есть после сигнатуры функции.
Ну и можно и там, и там написать,
чтобы совсем круто было.
Чем отличается? Да ничем.
Просто вот это преобразовывается вот в это.
Сейчас все будет.
Ну вот в таком виде ничем не отличается.
Можно просто переписать это на одну такую штучку,
где два раза написаны персенты.
Ну и чем честно отличается?
Это тем, что вот здесь, когда вы пишете
сразу после template что-то там,
у вас уже есть все названия шаблонных аргументов.
То есть имена вот эти вот, которые относятся к чему-то,
что вы в треугольных скобках написали,
они у вас уже в области видимости.
Можно обращаться к ним.
Вот здесь к имени вы обращаемся.
А когда пишем вот здесь,
к именам, которые шаблонные аргументы,
можно еще и к именам аргументов функции обращаться внезапно.
Ну как бы к именам этим вы обращаться можете,
но это будут не сами аргументы.
Это вот важно понимать.
Вот эти все требования, они в compile-time проверяются
на этапе компиляции где-то.
То есть можно, например,
ну тут примерчика, к сожалению, нет,
но если мы здесь какой-нибудь,
блин, не знаю,
массив какой-нибудь сделаем произвольной длины
и назовем его foo,
то вот здесь мы можем написать size of foo.
Да, то есть можно упоминать имена аргументов, но...
Если это constexpr функция,
то можно ли упоминать?
Нет, все равно нельзя.
Для constexpr функции мы считаем,
что все равно есть два этапа.
Этап компиляции, а потом этап интерпретации
внутри компилятора.
Поэтому то же самое.
Еще раз, о чем был его вопрос?
Что?
Да, вопрос был
для constexpr функций,
где аргументы известны в compile-time,
нельзя ли случайно их как-то
использовать в Requires?
Ответ нет, нельзя, потому что даже для
constexpr функции мы различаем
два этапа. Первая это компиляция
в кавычках, второй этап
это интерпретация.
Ну и то и другое происходит во время работы компилятора,
а не в runtime, но это все равно
два разных этапа как бы.
Не обязательно.
Но если он все-таки во время компиляции был,
то вот...
Наверное, то же самое для constval, верно?
Да, конечно, все то же самое.
Про constval будет позже.
Так вот,
зачем такие выкрутасы на самом деле
нужны?
Можно было просить вас догадаться,
но тут уже есть люди, которые что-то знают,
поэтому неинтересно.
А нужны это вот для этого на самом деле.
Приглядитесь.
Чувствуете, в чем понт?
Это вот максимально
круто.
Может, кто-нибудь может сказать
причину, почему это максимально
круто и где вот такое очень хочется
писать?
Для кого там иклец, для кого дробнется?
Ну, для кого-то да.
Ну, если пофотатся
этот метод использовать,
то, ну, с копируемым
типом, то он просто
сейчас работает как нужно, а если будет
не копировано, то будет ошибка
компиляции, которая явно укажет,
что данный метод
не инстанцировался.
Да, но
самый главный понт в том, что
это вам позволяет для контейнеров
вот то, о чем я уже упомянул,
делать как бы наследование
свойств от
шаблонного аргумента.
Потому что здесь пример с клоун.
Ну, если бы вас
попросили это сделать на C++17,
кто у нас самый сильный
программист? Нет,
не хватит. Вот если
просто сюда написать какой-то enable if не хватит,
вам просто дадут ошибку, что
ой, не смог скомпилировать, тут
что-то проблема.
Да, да, да, да, да, вот именно.
Нужно еще сюда шаблон
навесить, сделать
здесь один аргумент, который будет
равен void, потом второй аргумент,
который будет enable if, туда подставить
первый, который на самом деле...
Ну, как бы да,
я хотел услышать именно эти
детали, что нужно будет вот
эту функцию саму шаблонной сделать.
Но если здесь это еще как-то
приемлемо, то конструкторы
копирования и мува,
и операторы присваивания копирования
и мува, их делать шаблонами
нельзя, поэтому с помощью
enable if вы их отключить не сможете.
Понимаете, в чем цимис,
а с помощью этого одной строчкой
можете.
Вот если вы когда-то пытались писать
какие-то шаблонные контейнеры
в библиотеке, в чем-то приближенном
к реальной жизни, вот вы на это
должны были наткнуться. И вот я
натыкался и чертыхался, что мы до сих пор
на C++20 не перешли.
А теперь все так
удобно.
Да.
Смотри,
представим, что мы хотим, чтобы вот этот
враппер у него был...
Давай так, чтобы он работал
как бокс в расте.
То есть это аналог
UniquePTR, но который можно копировать.
Но что значит скопировать
UniquePTR? Это значит скопировать сам объект,
который внутри лежит.
То есть такую структуру данных хотим сделать,
назвали враппер. Вполне резонно.
То есть оно хранит что-то на куче,
чтобы, например,
с помощью форвардекларации
что-нибудь не инклюдить. Вот такие какие-то приколы.
Но копировать мы тоже хотим.
Ну, а когда мы хотим
копировать? Тогда и только тогда, когда
в копируемой.
Но здесь же написано тривиально, копируемой.
Ну, не важно.
Здесь какой-то дурацкий пример, который
я написал год назад, а то и больше.
Надо
запомнить и вставить сюда
хороший пример. То есть можно представить,
что здесь написано просто из копии.
Можно представить, что здесь написан
оператор копирования,
конструктор копирования
и просто из копиабл.
И вот тогда, вот в этом суть.
Мы как бы явно удаляем оператор
копирования, если нет
оператора копирования УВ.
Можно?
Ну,
на прошлый парик смотрели как раз,
что если у нас есть метод,
который может
сделать потенциально
СЕ,
мы
можем его не вызвать.
Да, да, да, да.
Да.
Почему нам это здесь не подходит?
Потому что мы хотим в итоге,
нам зачем делать его копируемым
или некопируемым таким хитрым образом?
Вот у STD-вектора такого свойства,
как я сейчас описываю с вот этими
вот реквайерсами, его нету.
Но это в некотором смысле плохо, а в некотором
смысле хорошо. Вообще,
блин, конечно, это бы просто с кодом
отложить, вот наконец, если у нас останется
время.
Давайте действительно вот этот вопрос
отложим. Те, кого это сильно волнует,
обязательно напомните мне в конце.
Ну, что это очень тонкий момент,
но он может вам пригодиться.
Семинары или семестра?
Пары, вернее двух пар
с сегодняшнего занятия. Вот,
откладываем на потом. Давайте пойдем дальше.
Здесь так можно только отвечать,
включать, или можно какие-то другие
штуки вписать?
А сейчас
увидим.
Ну, можно, короче, ответ.
Все можно, кроме того, что сейчас
расскажу нельзя.
Вот такой код.
Нельзя.
Ну, то есть,
что мы хотели? Мы хотели
разные классы, вернее как,
разные шаблоны для одного и того
же имени использовать,
в зависимости от шаблонных аргументов.
Вот это два разных шаблона,
они не специализации,
ничего, это просто два разных шаблона,
но с одним именем.
И компилятор вам скажет
а-та-та. Нельзя два разных шаблона
с одним именем, но разными
реквайерсами. Ну, казалось бы, что мешает
разрешить, но вот так оно работает.
И изменять это никто не планирует.
А если
это все-таки специализация?
То все можно.
Буквально все, я просто помню,
что иногда компилятор
очень странно
понимает, какой
constraint строже какого.
Про это тоже...
Про это подробнее
поговорим.
Про это все подробнее
поговорим, как там, что там выбирает.
Просто вот, для начала
запоминаем, что
просто два разных шаблона с разными реквайерсами
написать нельзя. Для классов,
для переменных и там
тоже самое, я почти уверен,
но лучше проверить. А вот для функций,
для функций, мы же можем
две разные функции с одним и тем же именем
написать. Можем, это
перегрузки называется. Вот для функций перегрузки
есть, для всего остального нет.
Поэтому вот этот механизм перегрузок
вот спокойно взяли и встроили
этот механизм реквайерсов.
То есть, как бы без вот этого
реквайерса, что бы вот такой код вызвал?
Вопрос.
Какую?
Редиклорейшн.
Ну, наверное,
да, наверное, редиклорейшн
могло еще быть
что-то про амбигиус, ой, стоп,
про амбигиус кол, ну, то есть
эти перегрузки, они как бы полностью
одинаковые. Они слишком одинаковые.
Мы не умеем их отличать без вот этого
реквайерса, а реквайерсы нам позволяют
их отличить.
Ну, соответственно, так делать
можно теперь.
Вот да, если
требования в них могут
навременно выполниться, то у вас будет
амбигиус кол, то, что называется.
Ну, как бы компилятор не знает,
что выбрать, это или это. Они оба подходят.
А вот
теперь пришло время поговорить как раз
про то, как, собственно, работает
вызов функции
в C++. Вы думали, вы знаете? Нет, вы не знаете.
Три этапа таких
общих.
Конечно, все это в гораздо больших деталях
можно освещать, но
это дома, заперевшись в ванной, читаете
стандарт. Три главных этапа
это поиск всех имен, которые
подходят. Вот про это еще в прошлый раз
мы что-то говорили немножко, да,
что, видя в тексте
программы какое-то имя, компилятор
шагает искать, какие сущности
определенные в программе подходят
к этому имени. Они там в правильных
namespace должны лежать, там как-то
аргументы еще могут влиять, еще
что-то. Вот ищем имена.
Нашли множество имен.
Что в этом множестве имен для функции может быть
для вызова функции?
Какие сущности
для выражения вызова функции?
Ну, функции-то да. Могут функции
методы еще.
Шаблоны.
Вот, это то, что хотел услышать.
Принципиальная разница между ними есть.
У вас этот сет множества
имен, оно состоит из
функций, ну там любых неважных методов,
что угодно, и шаблонов.
И вот если функцию вы можете просто взять
и вызвать, то шаблон еще надо инстанцировать,
как-то что-то там сделать, найти.
Поэтому принципиально по-разному
мы их обрабатываем. Ну, то есть
имена функций мы там
на следующий этап прокидываем и пофиг,
а вот имена шаблонов, для них второй этап
делается. Мы выводим
типы, если они явно не указаны,
в прошлый раз говорили, можно вызвать шаблонную
функцию, не указав шаблонные аргументы, нам их
выведут. Вот ровно здесь оно
происходит, а потом
подстановка собственно шаблонных аргументов
и инстанциация шаблона.
Вот она здесь происходит.
Если вы помните еще что-то про
SFINAE, то это вот
ровно вот про это.
Инстанцируется сигнатура,
именно сигнатура только,
функция. Если происходит ошибка,
вот при инстанциации
этой сигнатуры,
что одной из множества,
мы ошибку не выдаем,
мы просто выкидываем
из нашего множества эту функцию.
Вспомнили, что такое SFINAE с этой точки зрения?
Я надеюсь.
Возможно, здесь стоит прилепить какую-нибудь диаграмму
со стрелочками, но уж не судьба.
И последний этап.
Теперь у нас
в множестве есть только функции,
шаблонов больше нет. Мы их все заинстанцировали,
затайп дидюсили.
Теперь есть только
названия, какие-то сущности функции,
берем и выбираем из них
наилучшую. Вот это вот overload resolution
называется как раз.
Ну и вам там когда-то, наверное, Илья
рассказывал долго и нудно, что там какие-то правила,
кто лучше подходит, инты там, клангам,
что-то вот, ну, про это не будем.
Это скучно и нудно, и оно не
поменялось. А поменялся второй этап.
C++20.
Теперь у вас
самым последним шагом
в втором пункте проверяют
констраинты.
Вот те самые, про которые мы сейчас начали
говорить. То есть мы уже там
подставили,
вывели типы,
подставили в сигнатуру
функции эти
типы и выкинули функцию с рассмотрения,
если там свиная произошла.
И дальше уже идем проверять констраинты.
Если они не удовлетворены,
тоже выкидываем функцию.
Вот.
Собственно, это и позволяет
нам вот за счет
этих реквайерсов
как-то перегружать еще более хитро.
Потому что мы просто
фильтруем вот это вот множество найденных
имен по каким-то там предикатам
относительно шаблонных аргументов.
Окей.
Надеюсь, вот это вот вы не будете упускать
из головы или запомните, что такое
есть и сможете потом нагуглить просто,
потому что когда у вас адские ошибки
шаблонные происходят, нередко приходится
на это как-то ориентироваться, чтобы понять
что вообще происходит.
Но мы идем дальше.
Что вообще в констраинты можно вписывать?
Вот реквайерс
и что дальше? Ну я сказал там бульевые выражения,
но не только.
Конечно, можно писать вот эти концепты
загадочные, пока их не существует.
И можно писать конъюнкцию и дизъюнкцию.
Но конъюнкция
и дизъюнкция они
они не простые, они золотые.
Ну и вот в ближайшие
10 слайдов мы будем пытаться подобраться к тому,
чтобы понять, что там за конъюнкция и дизъюнкция
и почему они золотые, а не обычные.
А...
Да.
Какие-то вот слова
говорить и по факту
непонятно, что они значат. Поэтому сейчас
будем очень подробно это все демонстрировать.
На примере вот этого.
А походу дело еще и с констекспроме разберемся.
Функция.
Тут написан какой-то код. Давайте
секунду. Две даю, чтобы посмотреть.
Что такое
StaticStream? InputFileStream.
Короче, мы
читаем из файла int и возвращаем.
Функция.
Я геймдевелопер.
У нас не существует исключений.
Они отменены.
Если файла нет, то чего?
Есть.
Ну патч выпустишь,
пофиксишь баг. Ну какие проблемы?
Зачем это все нужно?
Да.
Зачем это нам нужно? Эту функцию нельзя
посчитать в компайлтайме. Согласна?
Просто нельзя и все. Там какие-то
исключения есть, еще что-то. Нельзя и
отлично. Запомнили, да?
Дальше везде она будет.
LoadConstants, повсюду еще 10 слайдов,
надо помнить. Ее нельзя в компайлтайме.
Добавляем вот такой кусок
кода.
Здесь constexpr функция,
которая в одной ветке
просто возвращает x, а в другой
ветке умножает его на
загруженные с файла значения.
Скомпилируется ли это?
Кажется.
С какого-то стандарта
можно не constexpr функцию
в теле constexpr.
Ну в общем, да, вы правы.
Это скомпилируется вот в таком виде.
Пятерочку сюда вставили,
выбралась первая ветка,
все работает.
Просто 5 вернули.
А вот так, ну,
я думаю, понятно, что
уже без вариантов не должно это
компилироваться.
Почему так
происходит?
Куда?
А, нет, еще один вопрос.
А вот так скомпилируется?
А до этого
constexpr?
Ага, все, вы включились.
До этого был constexpr.
Да, то есть
вот так нет, потому что мы потребовали
в compile-time вычислить функцию
compute, а вот так мы сделали,
и уже все нормально будет.
Потому что, ну, функция compute и функция
compute, вычислим ее в run-time.
Не важно, что на constexpr отмечено,
это нас ни к чему не обязывает.
Вот мораль всего этого,
что constexpr это рекомендация вообще-то
для функций. Она говорит,
я разрешаю тебе
компилятор, считать эту функцию в compile-time,
если можешь,
пожалуйста, посчитай.
Ну, и сам обязуюсь там какие-то вещи вообще
делать. Ну, вот тут
написано, какие вещи вы как программисты обязуетесь
делать, указав функцию constexpr.
Литеральный тип
для аргументов, для ретерна.
Ну,
что такое литеральный тип вообще, не будем
говорить. Какие-то инты, флоты, все работает.
Тыкайтесь, смотрите, работает или нет.
В зависимости от стандарта, разные
вещи работают, так что вообще убой
ни в коем случае не надо пытаться
запомнить.
Что?
Структуры тоже литеральные,
но с некоторыми оговорками.
Надо просто тыкнуться, попробовать, если сработает
класс.
Нас интересует больше всего
последний пункт.
Хотя бы для одного набора
аргументов функцию должно быть
можно вычислить в compile-time.
Угадайте, что иначе.
Убе.
Как ты это проверишь?
Проблема останова эквивалентно.
Не может компилятор проверить,
что все нормально будет.
Нет, просто убе.
Ты не понимаешь,
суть убе.
Давайте повторим суть убе.
Убе это значит, что
ваша программа не является программой
на C++.
Это не обязывает ни компилятор
ни к чему, ни итоговый бинарь,
который у вас компилируется, если вам повезет
ни к чему. Может произойти все, что угодно.
А
соответственно, тут тоже компилятор
старается проверять убе.
Есть всякие проверочки, которые
компилятор способен сделать, какое-нибудь разыменование
nullptr, если вы прямо напишете
in звездочка равно null и разыменуйте.
То вам, конечно, компилятор скажет,
так ты же тут null написал, как ты его разыменуешь.
Но
в общем случае, вот как понять,
есть ли набор аргументов,
при котором можно запустить
функцию в compile-time.
Давайте
вспомним matlog.
Там была замечательная теорема.
Кто-нибудь вспомнит ее название.
Что-то там нетривиальное множество
программ
не является
разрешимым.
Не помните?
Клине?
А?
А может и не клине?
Ну я тоже не помню.
Но суть теоремы помните, надеюсь,
что вот любое нетривиальное свойство для программ
выбрали, и вы уже его не умеете
проверять. Не вычислимо.
Вот и все.
Ну и свойство вот это, оно тоже
как бы не вычислимо. Поэтому компилятор вам помочь
не сможет. Если ваш там
функция ни при каких наборах
аргументов не компилируется
в нельзя
выполнить в compile-time,
то у вас вообще-то UB.
Ну то есть какая дальше развитие событий может быть?
Вы реально эту функцию зовете и вам реально скажут
ой, я не могу с таким набором аргументов
вычислить, все плохо. А может вы такую
функцию не зовете, но это все равно UB
и ваша программа все равно не считается
программной C++.
О!
Не знаю.
Наверное смысл в том, чтобы
тебя в тонусе держать.
Ты должен чувствовать боль,
чувствовать вот это вот, что на иголках,
на иголках. Всегда проверяй
что ты пишешь. Если хотя бы одного набора
нет, то все, твою программу
сломаем.
Да ничего не будет на самом деле, все нормально
будет.
Это одно из тех мест, где все нормально на самом
деле будет. Но это как бы
и ограничение, и развязывает нам руки.
Это все
к тому, что у нас с констраксом
компилируется, отбесы нет.
Да, потому что, заметь,
не для всех. Здесь квантер,
существование не всеобщности. Вот это самое главное
на самом деле.
То есть у тебя может быть только один набор
аргументов, с которыми все работает и в компелтайме
вычисляется, а все остальные наборы аргументов
ну ничего работать не будет. За счет этого
и работает вот этот пример, что
вот так нельзя, вот так можно. Вот с этим набором
аргументов все компилируется, а с этим нет.
То есть оно как бы и
развязывает нам руки с одной стороны,
а с другой стороны, ну нафига они
впихнули это сюда.
Почему от list1? Почему нельзя
зачем undefined behavior
на ровном месте в стандарт впихивать?
Ну возможно.
Ну вообще
ну просто
позволить.
Ну не знаю. Короче, это вот
странное место, что они вот так вот
компилировали, но будьте внимательны.
Меняем
красная стрелочка.
Новое слово
для кого-то.
Предположите, что оно значит.
Да, это значит, что функция всегда
считается только в компелтайме.
Вы запрещаете компилятору
считать ее в рентайме.
Ну и такой код просто
скомпилируется, потому что
ну там всякая ленивость, он даже смотреть
внутри этой функции не будет, но как только вы
вот так напишете,
вопрос.
Скомпилируется или нет?
Да,
все то же самое.
Там все еще точно такие же ограничения,
что ну типа мы не
проверяем для всех наборов аргументов,
мы для конкретного. Вот пятерка.
Можно в компелтайме с пятеркой вычислить?
Можно. Вычисляем, получаем 5.
О,
ну вот так
точно нет,
а вот так тоже нет.
Потому что теперь мы
компилятор как бы увидит.
Нужно в компилтайме вообще-то,
потому что конставал написано,
а мы не можем, и все.
Окей, ну я думаю,
тогда должно быть понятно, зачем вообще ключевое слово
конставал добавили.
Иногда мы хотим гарантировать себе,
что вот это сложное вычисление, которое
предподсчитывает какую-нибудь таблицу
прыжков куда-нибудь, чего-нибудь,
мы хотим гарантировать, что оно в компилтайме
считается.
Пример, когда аргумент 5
и нет констэкспор?
Ну, когда аргумент 5
и на переменной нет констэкспор,
вопрос к вам, что будет?
Ну, в принципе да.
Ну, вернее как?
Не факт.
Потому что я вот не уверен,
если вы констэкспор здесь напишете, и здесь
5, будет ли он вычислять в компилтайме?
Наверное, будет.
А может и нет.
Да вот в том-то и дело,
что по-моему не делает.
И ради этого еще одно ключевое слово добавили в C++.
Да.
Которого, да, кстати, у меня в презентации нет.
Давайте я вам быстренько скажу.
Можно перед переменными теперь писать
const init.
Это что говорит? Что переменная, она обычная.
Это просто обычная глобальная
переменная, но мы хотим,
чтобы выражение,
которое она инициализируется,
вычислили в компилтайме.
Почему-то она и в констэкспор отличается.
Констэкспорт переменная,
она еще и константная.
А const init только
инициализируется в компилтайме.
А дальше в рантайме ты ее менять можешь.
Неужели функционал спориальный кому-то нужен?
Кому-то нужен, да, в embedded.
Там ребята пишут под
микропроцессоры всякие,
с частотой полгерца,
не знаю, и вот им очень важно.
Да-да-да, всякие вышки там
мобильные, какие-нибудь...
Короче, им бед везде.
Да, это тоже полезно, но
мне не удается на работе добиться,
чтобы что-то констанитилось, потому что
пока тяжело.
Все плохо.
Можно вопрос?
Если вернуться на несколько свадебных данных,
где у нас был вот так,
в видеорке.
Здесь мы пришли к лучшему, что скомпилировали.
Так же, как констэкспорт.
С точки зрения стандарта,
программа корректная?
Да.
То, что скомпилировалось,
еще не значит, что...
Это абсолютно корректно, с точки зрения стандарта
все нормально. По крайней мере, я так думаю,
но уверенным в этом никогда нельзя быть.
Просто здесь же...
Ты сказал, что не проявляется для всех
аргументов потенциальных.
Это избыточно было бы делать, потому что достаточно
АСТ посмотреть просто.
У нас в одной из веток вызов функции...
Так ты забываешь про теорему Клини вроде.
Теорема Клини говорит, что
смотри на АСТ, не смотри, ты все равно
никакое нетривиальное свойство точно
проверить не сможешь. Только евристически.
То есть это может быть включать какими-нибудь
дополнительными отцами проверки,
но это точно должно быть в стандарте.
Да, ты не можешь в стандарте требовать
от людей решать проблему останова.
Это центральная идея стандарта.
И вот должно быть возможно написать
в виде компилятора. Если это невозможно,
то это плохой стандарт.
Давайте дальше поедем.
Да, const и val на функциях
значит, эту функцию запрещено
считать в run-time, только в compile-time.
То есть вот...
Вот такая штука все равно даст ошибку тебе.
Потому что ты функцию пометила
как const и val,
это значит, что в run-time ее считать нельзя,
а в compile-time мы
умрем из-за того, что
из файла читаем число.
А когда здесь был const export,
это была рекомендация.
Можно в compile-time,
если тебе нужно.
То есть мы не можем написать
for там,
say in что-то,
и в зависимости от того,
что вышло, вызвать в компьютере.
То есть мы так написать уже
не можем, если она const и val.
Если у тебя в зависимости от того,
что пришло...
Я вызываю хорошую функцию,
а пришла двоечка
или ноль,
вызываю в компьютере. Так написать не могу.
Да, потому что у тебя компилятор
должен знать значение этой функции.
Если по-простому сказать,
то в const и val функцию
можно только const export переменные
подставлять, если совсем
по-простому. На самом деле, конечно же,
там опять правила, вот эти вот
constant expressions прекрасные.
То есть const int тоже можно
подставить в const и val функцию.
Нет.
Я знаю, что в Rasty подобные штуки
появляются, но
в Kotlin тоже мне кто-то, кажется,
рассказывал. Но нет, у нас такого
пока нет, мы страдаем.
Такого, чтобы компилятор
по предшествующему коду мог
делать предположения о дальнейшем коде.
Например, видя if,
помнить, что этот if...
Вот если мы внутрь него зашли,
компилятор как бы помнит, что это условие
выполняется, и из этого
делает какие-то дидактические выводы
о свойстве всего, что внутри.
Например, вот было if x
равно равно 2,
который с input ввели
x,
вот эту функцию compute от x вызываем.
Казалось бы, компилятор мог догадаться.
Мы только что проверили, что x равен 2.
Пошли в ветку.
И здесь, в этой ветке, x он всегда
2. То есть выражение
x, оно как бы константно,
потому что мы внутри if, который проверяет,
что он равен 2, но нет, мы так не умеем.
Некоторые языки умеют.
Ну вот да.
Да.
Некоторые языки умеют все это проверять.
Они знают, когда он остался таким же
двойкой, когда его изменили,
а в плюсах так не получится.
Все нормально.
Да, но выражение
тебе важно не переменные,
от которых вызываешь, а выражение.
Выражение, от которого ты вызываешь
компьютер, должно быть константным.
Литерал 2, константное выражение.
Это если констэкспорт.
Да.
А если констэкспорт, то
коль скоро у тебя все аргументы
константные выражения, он, наверное,
вызовет в компайл тайме.
Если хотя бы одно из них не константное выражение,
то точно в рантайме.
По-моему, так.
Констэнит, это
только про переменные, оно говорит.
У меня переменная
инициализируется долго, там какой-то алгоритм
вычисляет число p до 10
знаков. Я хочу, чтобы ты
этот алгоритм в компайл тайме запустил.
То есть выражение,
инициализирующее
переменную, должно быть вычислено в компайл тайме.
А потом эта переменная
должна быть просто
обычной переменной в рантайме, ее должно быть можно
менять. То есть
констэнит плюс конст
равно констэкспорт для переменных.
Вот так вот давайте запомним.
То есть мы можем констэнит
писать в ветках, которые в рантайме.
В ветках, которые в рантайме.
Нет.
Вот инициализатор констэнит
должен быть константным выражением,
известному в момент компиляции.
А потом
можно менять уже эту переменную,
как хочешь, в рантайме.
Опять же, поступает число
x равно 2.
И дальше я пишу
констэнит
ин z равно компьют 100.
Вот так я могу сделать? Да.
Ну у тебя выражение компьют 100, а нет,
100 давай 5.
Компьют 5 можешь.
Потому что компьют 5 это константное выражение.
Ты потребовал, чтобы z
инициализировалось в момент компиляции,
оно инициализировалось в момент компиляции,
а дальше по коду ты можешь сделать
плюс-плюс z, например.
Спокойно.
То есть это констэкспорт, но без конст.
Ну вот так
странно. Давайте дальше ехать.
Ну вот, честно говоря, я не уверен, что происходит,
когда ты вот тут вот пишешь
конст... Нет, сейчас.
Вот когда у него есть
выбор, по-моему, там ничего не требуется.
В этом проблема. Он может
решить так, а может решить всяко.
Либо там какие-то правила очень сложные,
предлагаю открыть стандарт и вот это
вот вычитать. Давайте дальше ехать,
у нас еще столько материала,
а еще я вас прошу следить за временем,
потому что я сейчас дико увлекусь, и нам нужно
на перерыв. Еще полчаса,
и мы идем на перерыв. Но за эти полчаса
мы должны добить вот эту цепочку рассуждений.
Я напомню, что про все это мы не по приколу
начали рассуждать, а потому что
я сказал, пообещал,
что в констрейнтах
волшебные два амперсанда
и две палки.
К чему это все?
Да, вот мораль констатовал нельзя в рантайме,
а констэкспорт был
рекомендацией. Вот теперь
будет самая суть. Вам нужно
напрячься сейчас всем,
все, кто выключался, пока мы беседовали о разных
напросах на сущных, включитесь.
Все еще тот же компьют,
он констэкспорт.
Взяли его.
И сделали из него констэкспорт буль.
В зависимости от n и результата
от компьюта,
будет буль либо true, либо false.
Это такой предикат
на типах,
на числах. Он в compile-time для каждого
числа говорит хорошее число или плохое,
или удовлетворительное, или нет.
И вот если мы вот так вот сделаем
для пятерки,
ну тут уже написано, что все будет ок,
а если для сотни, то все сломается.
Ситуацией принципиально
не отличается то, что было до этого.
Просто мы вот этот вот вызов
компьют от 5 или компьют от 100
затолкали куда-то под шаблон
в инициализатор, и теперь вот есть еще
шаблонный аргумент. Все то же самое.
Дальше идем.
Это констэкспорт буль.
Констэкспорт значит переменная
должна быть инициализирована в compile-time
и не меняться никогда.
Поэтому оно скажет
проблема, как это я тебе вычислю
от 100 в compile-time.
Идем дальше.
Помимо из acceptable
появился из good.
Пока мы ничему не верим.
Но вот утверждается, что да,
действительно вот это будет работать.
Если вот кто-то из вас не верит
мне, а такие должны быть, вбивайте в good bolt.
Иногда тут
бывает, что на слайдах лажа, иногда бывает, что
я за ночь успел забыть, какой
вывод был у конкретного слайда.
Но здесь, кажется, все будет нормально работать.
Почему?
Да, тут
точно такая же ситуация.
Потому что мы вот, ну
этот два или, это тот же самый
выпросительный знак, который у нас внутри
компьютера. Вот тернарный оператор
внутри компьютера, от этого,
от этих двух палок особо не
отличается здесь.
Да.
Вот они все трое работают одинаково
в таких контекстах.
И из good и из acceptable
ну, примерно одно и то же.
Идем дальше.
И ставим вот сюда.
Вопрос. Что будет?
Все нормально будет?
Я думаю, что нормально.
Ну да.
Ну да.
А теперь, наверное, нет.
Теперь?
Да.
Сделем, что да.
Нормально.
Как будто бы да.
Сейчас у нас
не изменилось то, что мы просто
переписали условия на напрямую в билет.
Да, ничего не поменялось, вы правы.
Это серия слайдов, на которые
даже я себя запутываю, потому что тут
каждый раз хочется сказать, а теперь изменилось, а теперь
нет, ничего не меняется.
Вот абсолютно неважно, мы там выписали
это определение из good и прямо
уже впихнули, нет, все еще так же работает,
все нормально, никакого отличия нет. Пока.
А теперь
да.
Такой, секой
отличия нету.
Нет, значит мы все
перепутали. Давайте вбивать good bolt.
Вот видите, я обещал, что
я за ночь забуду, я забыл.
Судя по подсказкам дальше
здесь будет даже
не здесь после, а дальше.
Good bolt.
Шлеп, шлеп, шлеп, шлеп.
Я прямо чувствую, как мой
компьютер с ума сходит.
Я надеюсь, он не умрет.
Ну вот мы как бы не доверяем
каким-то там презентациям,
мы доверяем только компилятору, а компилятор по факту
что говорит? Что вот этот вот
вот эта палочка, disjunction
да, disjunction, она у нас
казалась неленивой.
Сейчас проверял acceptable и
сказала плохо.
Ну оно пошло в из good,
проверяет
disjunction и как бы оно
не видит, что вот это вот true, да?
Но почему-то все равно идет сюда.
А, а почему оно идет сюда?
И что значит идет сюда?
Вот, вот
где деталь, да, вот где
деталь, которую я пропустил. Потому что
смотрите, разница-то в чем?
Вот здесь мы выражение вычисляли,
так?
Мы, ну как бы нам значение
было важно. Тип, у вот этого
load constant понятно какой.
Это вот эта функция, у нее там тип int
от ничего,
ну мы запустили от ничего, получили int.
Но вот здесь-то надо понять какой
тип хотя бы.
Для этого нужно инстанцировать шаблон.
А когда мы
с пятидесятью попытаемся этот шаблон
инстанцировать,
все умрет.
Поняли?
Даже себя умудрился
запутать. Но мы разобрались.
Что значит ответ?
Нет, пока ответов нет, только вопросы.
Вот так.
Сейчас оно опять
поиздевается надо мной.
Давай full screen.
Ну?
Сейчас еще раз просмотрим и проговорим.
Это важно.
Да чтоб его!
Пожалуйста, работай.
Давайте просто slideshow
даже без презентер
мода уж.
Так.
Проговорим еще раз
в самый последний,
чтобы совсем закрепить
и больше не тупить.
Вот здесь
мы считаем
выражение.
Вот здесь
мы считаем выражение.
Мы считаем выражение.
Выражение считается лениво.
Увидели, что это true?
Во вторую ветку считать
выражение идти не надо.
Первую вернули, о!
Вот здесь
все становится наоборот.
Здесь мы даже тип
не знаем вот этой фигни.
Вот это вот выражение
это
специализация какого-то
шаблона. Нам надо идти искать шаблон,
инстанцировать его и смотреть,
что там получилось.
Что-что?
Ну,
можно.
Ну, вообще-то
да, вообще-то можно сделать так, чтобы
в зависимости от вот этого
n вот здесь был разный тип.
Одной и той же переменной.
Одной и той же шаблона переменной.
То есть нам как минимум, чтобы
затайпчекать программу и понять, какие типы
где, нам нужно пойти инстанцировать.
Соответственно, вариантов у нас
нету. Мы не можем.
А если бы из Excerpt так же была некорректно,
но там был бы шаблон, а там скажи так
ну, аргумент, который проводит
некорректно, то что там у компьютера?
Короче, я не понял,
что ты сказал, но видимо вопрос в том, что если
здесь были бы круглые скобочки?
Да, вот если бы здесь были круглые
скобочки констекспро функция,
все бы работало, как раньше.
Почему работает не как раньше?
И что даже меня убило?
Это то, что скобочки треугольные меняют ситуацию.
Нету ленивости.
Вот здесь вот. И вот это вот просто
не скомпилируется.
Вот. И вот это тоже не скомпилируется.
Потому что мы все еще сразу пойдем
подставлять эту 50, вот сюда,
сюда, сюда. Подставили
ошибка. Не скомпилировалось.
А вот здесь
будет все работать.
Вот в чем златость этих
двух палочек.
Оно
увидев, что вот это вот
что вот это вот вернуло true,
оно даже инстанцировать шаблоны
во второй половинке не будет.
Но ничего не пойдет туда
делать, смотреть вообще.
Да.
А нам и не важно.
Ну, вернее как, мы точно знаем,
что это должен был бы быть
бул.
Короче, оно еще более злато работает.
Да, кажется, что
да, он просто даже не будет проверять это.
Ему будет все равно. Но лучше вбить в
Godbolt. Но суть всех
этих рассуждений в том, что
во-первых, мы не можем
с помощью констэкспорт булов
брать и как-то вот сокращать
себе количество кода, которое мы сюда
пишем. Это сломается.
Потому что, ну, это пример искусственный,
да? Дико искусственный.
Но суть остается той же.
Если у вас вдруг даже подстановка
шаблона приводит к какой-то ошибке
подстановки,
никакой SFINAE не сработает,
и у вас просто будет ошибка компиляции.
Всей компиляции.
А вы, наверное, хотели, чтобы если вот тут
в том, что вы в requires запихали, где-то там
любая ошибка произошла,
вы хотели, наверное, просто false получить
и отключить эту функцию.
А вот там был такой requires на время,
как остается, а он последний был.
Так оно же здесь получается, мы должны
инстанцировать, не надо типать.
Или это просто было причастление?
Нет, там инстанциация происходит
вот с самого вот этого шаблона.
Вот этого вот.
Ну, тут есть
маленькие детали, конечно, а
пойдет ли оно инстанцировать
те вот штуки, непонятно.
Надо стандарт вычитывать.
Давай главную мораль
все поймем и запомним, что
дизъюнкция и конъюнкция
в requires-ах, она более ленивая, чем
дизъюнкция и конъюнкция
просто в constexpr булах.
Или в принципе у вас в коде.
Она ленивая относительно типов, она вот даже
на типы смотреть не будет, если
получила тот ответ, который искала.
Ну и да,
перегружать вот эту конъюнкцию-дизъюнкцию
нельзя, как бы.
В каком-то смысле.
То есть если вы здесь напишете
какие-то типы,
для которых перегружен оператор две палки
и возвращает в итоге буль,
то вот этой ленивости вы не получите.
Да?
Ну, чем отличается
встроенный оператор двух палок
от бами перегруженного?
Ключевое отличие.
Вот это вот точно
должны были явно проговаривать на парах
когда-то.
Да, вот когда вы свой перегруженный
оператор две палки делаете,
у вас будут оба аргумента
вычисляться, ленивости не будет.
А встроенный и ленивый.
Здесь то же самое. Если вот это вот
и вот это вот не были какие-то ваши
типы, для которых вы свой оператор
две палки определили,
то вас ждет поражение.
Ленивость вообще отвалится и у вас будет
просто ваш оператор две палки как функция
зваться.
Да.
Окей.
Ну,
еще одно, что это наталкивает,
что вот constexpr bool,
хочется ведь вот эти вот сложные выражения
запихивать в какие-то
переменные что-ли,
как-то имена давать вот этим
сложным набором каких-то требований,
как-то их вот выпихивать куда-то. Но constexpr bool
не подходит, потому что работают
по-разному.
Это должно вас натолкнуть на мысль о том,
что такое концепт. Но об этом чуть позже.
Вот, эти работают
по-разному. Все, мы справились.
Наверное, время
перерыва перед тем, как мы пойдем дальше.
Правда ведь?
Десять минут.
Ну, за десять минут вот про это мы успеем поговорить.
А потому что тут просто.
Да?
Да.
То, что вы увидели,
это буквально из того,
что вы написали
о том, что
сначала инстанционные шаблоны,
а потом проверяются requires.
Вот, по-моему, это не совсем так.
Нет, наоборот, что там в одном пункте
было и инстанционные шаблоны, и requires.
Да, вот в каком порядке это в рамках этого
пункта делается, по-моему, все-таки requires
и проверяются самыми последними, а
подстановка шаблонов имелась в виду не тех,
которые где-то у вас в рамках вашей
функции, а именно, что
на вход пришло множество функций,
подходящих под ваше имя,
и множество шаблонов функций.
И под инстанциацией имелась в виду именно
инстанциация этих шаблонов функций,
которые нашлись по имени,
чтобы получить уже настоящие функции.
Вот они инстанцируются.
И потом уже проверяются requires.
Вот, то есть тут надо
не запутаться.
А вот у нас на requirements сейчас был
тоже шаблон.
Да.
Ну, вот потому что так работает
оператор две палки, в этом
суть того, как он работает.
Оператор две палки в requires выраживать
в этих constraints, он особенно
и работает вот так. Если у него
что-то не скомпилировалось во второй ветке,
он вообще false просто делает, насколько
я помню. Может даже так.
Ну, об эту деталь
вы разбиваться будете не часто,
но иногда будете, а может и не будете,
как повезет.
Впрочем,
как и со всем материалом,
наизусть сейчас запомнить все это
от вас я, конечно, не требую, это невозможно.
Я хочу, чтобы это где-то
осело, что какая-то тут закорюка есть,
и вы смогли потом нагуглить эту закорюку.
Вот.
Давайте дальше по-быстрому, вот там
сколько? 8 минут, вот на этот раздел нам хватит.
Помимо requires,
который мы уже видели, requires
close это называлось, напоминаю,
в C++ добавили еще одно
использование этого ключевого слова, requires
expression.
Ну, почему одно и то же ключевое
слово используется в двух местах?
Ну, давайте посчитаем,
сколько у нас там есть C++
типов статических чего-то.
Статические переменные,
статические переменные функциях,
статические глобальные переменные,
в классах оно там по-другому
работает, а еще статические функции
по-другому работают. Ну, вот
экономим мы ключевые слова, понимаете?
Ключевые слова дорого,
вдруг мы там кому-то код сломаем,
поэтому надо как можно больше фигни
назвать одним словом, чтобы все запутались.
Зато legacy код не сломаем.
Итак, к чему это все?
requires expression,
вот это вот.
Что оно делает?
Во-первых, это все вместе
бульевое выражение.
Ну, они как будто созданы друг для друга, да?
Вот requires close и requires
expression. Одному нужно
бульевое выражение, другое им является.
И вычисляется оно
как бы вот в компайл
тайме это выражение, всегда.
А значение его true,
если все, что вы в фигурных скобках написали,
скомпилируется.
Видите, что я там написал?
Тут какой-то v есть шаблонный
аргумент.
И в requires expression я написал
v фигурные скобки,
то есть дефолтная инициализация
v. Соответственно, выражение это
будет true, если v можно
инициализировать по умолчанию,
то есть там структурка какая-нибудь,
либо есть конструктор без аргументов.
И false, если нельзя.
А есть какой-нибудь
requires after?
Ну, как было декл-тайп,
выражение, а потом
подозрение.
И вот
хотелось бы requires adapter,
чтобы, типа, если тело скомпилировалось,
то да. Так, утверждается, что
такое сделать, в принципе, можно с точки зрения
компиляторов, но ни в коем случае не нужно.
А в чем смысл requires adapter?
Давай не будем даже думать.
Вот под конец этой пары
я, наверное, могу сказать, почему это плохая
идея, что имелось в виду и почему не надо
так. А сейчас просто не будем
грешном думать. Будем думать о хорошем,
о том, что вот мы так написали,
и вот для Интайта будет true.
А если написали какую-то штуку, которую
удалили, дефолтный конструктор
без аргументов, то будет false.
Это всяко
удобнее, чем то, что вас, возможно,
заставляло Илья на первом курсе делать,
чтобы проверять такие вещи. Правда?
Что?
Вот с финайе
и там начинаются какие-то специализации,
которые там, если скомпилировалось, то и это
нет.
Ну, аналогичные
штуки из дефолта констракта был, он
нас наверняка заставлял писать. И там был какой-то
ад. Просто стрёмное, стрёмное.
Здесь всё вообще
красота.
Дальше идём.
Не в ту сторону? Нет, в ту
сторону.
Это что, лишний слайд?
А, это слайды
перепутались. Ой, ладно.
Следующий забавный синтаксис
можно
переменные, аргументы впихнуть
в requires expression.
Да,
вот уже сказали, это деклвал.
Помните такое у зверя?
Вот когда вы там пишете какое-то
жуткое с финайе, вам иногда нужно
проверить, что работает такое
выражение, и вам там, типа, нужно из воздуха
взять какую-то переменную,
какого-то типа.
Теперь для этого есть явный, чёткий
синтаксис.
Ну и понимать всё это вместе нужно
следующим образом.
Если нам даны va
и vb, то есть две переменные
типа v, то
должно компилироваться следующее выражение
a-b.
Это можно понимать как некий квантор
всеобщности, на самом деле.
Откуда a и b берутся?
А не откуда.
Это бульёвое выражение, это всё
как бы предикат.
Синтаксис со скобочками, это квантор
всеобщности по любым a и по любым b,
оба из которых типа v.
А в чём ещё одна плава?
Ну, не знаю.
Нет, здесь можно, конечно, они и ссадь
делают, но...
Ну так как-то более понятно, ты же...
То есть проверяется, что для них перегружено
оператор в 4? Да.
Что имея две переменные в коде
где угодно типа v, ты можешь их
вычесть. То есть такой код
скомпилируется.
И интуиция про квантор всеобщности, она очень
правильная здесь.
Для любых двух переменных a и b можно их
друг из друга вычесть. Вот если это верно,
то всё выражение будет true.
Если это неправда, то это будет false.
Но, конечно же, никакую всеобщность
компилятор не проверяет, он как бы
это...
Что?
Вот.
Вот я тоже как-то писал код и очень хотел,
чтобы ещё можно было пихнуть квантор
всеобщности по типам. Нельзя.
Так, стой. Я не очень...
Вот человеку интересно извращение,
это вот его лично.
Это не извращение, это вполне нормальный
use case. Я хочу проверить.
Нет, у меня тоже был нормальный
use case. Да, я вот...
Хочется проверять наличие шаблонного метода.
Да, да. Вот ровно такое
же у меня было. То есть представьте,
вы хотите проверить, что
у a можно вызвать метод
get шаблонный с любым типом.
Не знаю, зачем вам
это может быть, но хочется.
Вот этот синток...
Вот эта вся фигня
никак вам не позволит это сделать.
Да, много чего интересного можно было бы натворить,
но нет.
Ну, смотри, хочется написать
a.get и в треугольных
скобках любой тип. Что типа
не просто для конкретного типа, а для
произвольного. Такой квантор всеобщенности
по типам. Нельзя.
Что?
Да, там опять проблема остановки где-то вылезает,
но вот приходится
таким обходиться.
А, переменные типа v внутри
requires нельзя. Вот это важно.
Сюда можно вписывать только
выражение, expression.
Statement сюда писать нельзя.
Да, можно несколько expression через
точку с запятой. Сейчас про это подойдем.
Нет,
через точку с запятой. Здесь как бы каждая строчка
отдельная expression.
Да.
Да.
Почему? Обычный код.
Если нам дана переменная типа
rvalue ссылка на v,
то и так далее.
При этом как имя, если ты ее назовешь вот здесь,
у тебя обычным образом все работает.
Если
у имени переменной
всегда категория expression
lvalue.
То есть оно точно так же работает, как
если бы функцией все это было.
Что еще раз?
А минус равно b можно написать,
потому что а минус равно b это expression.
Ну да, для int
а минус равно b
тоже возвращается ссылку на int вообще-то.
Тут все по-обычному работает.
Вся lvalue у нас
здесь работает как у обычной функции,
но как бы без
use case сложно что-то еще сказать.
Все как обычно работает.
Еще раз, они работают как аргументы функции.
Это просто какая-то переменная
типа v.
Ну, функция обычная,
если вы принимаете аргумент типа v
и называете его вот здесь.
Это какая категория значения?
lvalue.
А здесь lvalue.
Я говорю, все по-обычному работает.
Да.
Да, нового синтаксиса
чтобы объявлять в скопе expression
у нас нет. Здесь объявляются
именно что переменные.
Такие же как объявляются аргументы функции.
То есть оно работает
точно так же как функция
объявили, все то же самое.
Окей?
Вот насчет этого, надеюсь,
прояснилось, ничего настолько
сложного здесь нет. Все тупо пока.
Ну и использовать это можно очень легко
и очень полезно, очень эффективно.
Вот такой код пишите и радуйтесь.
Ну вы знаете, наверное, про вот эту вот
функцию distance в стандарте она есть.
Она считает расстояние между двумя
итераторами.
Ну и почему ее вообще следует использовать?
Да, а ровно потому, что здесь написано.
Если у вас
хорошие итераторы,
random access, то вы можете вычесть
и за от единицы найти расстояние.
А вот если итераторы плохие,
то как бы беда
и нужно просто в цикле один двигать,
пока он не дойдет до второго, и тогда
уже вы насчитали сколько-то там.
Ну вот, и тут мы с помощью
if constexpr, это C++17,
надеюсь, все знают,
сделали либо одно, либо другое.
Окей.
Requires, requires.
Ну понятно же, да, что написано.
Где-то еще такое.
А, noexcept от noexcept. Видели?
Noexcept от noexcept.
Ну опять же,
есть noexcept clause, который
на функции навешивается,
и этот noexcept clause может принимать
бульевую константу, типа
noexcept от true или noexcept от false,
включать или выключать, в зависимости
от того, что происходит.
А есть noexcept expression,
который на вход берет другой expression и говорит,
является ли он noexceptом.
Поэтому можем еще сюда написать
noexcept от noexcept от
r-l. И вообще-то должны.
Но я сюда
не вписал.
Еще же есть template, template, typename, typename.
А, ну, по-моему,
template, template, по-моему, мы уже
видели, да. Ну у нас
языкающийся язык слегка,
под целевую аудиторию
под нас.
Дальше будут концепты, и на этой ноте, я думаю,
перерыв.
