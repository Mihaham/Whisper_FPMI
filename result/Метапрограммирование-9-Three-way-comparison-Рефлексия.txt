Сегодня у нас будут две темы, почти никак не связанные, но в каком-то смысле противоположные,
потому что от космического корабля никаких удивлений не будет. Давно ждали, и вот наконец
появилось. А вот от рефлексии мы должны получить катаасис. Ну, во всяком случае,
рефлексия ближе ко второй половине. Поэтому космический корабль. Наконец-то операторы
сравнения в плюсах стало удобно использовать. Ну, почти, со звездочкой. Появился новый оператор
тройного сравнения. Более того, операторы сравнения теперь бывают дефолтными внезапно. То есть
всякие простые кейсы, когда и держу понятно, как вы хотите сравнивать какие-то объекты. Компилятор
теперь сам умеет выводить и генерить. Но более того, компилятор теперь умеет догадываться,
как выразить один оператор сравнений из другого. И теперь нет нужды писать по шесть разных
операторов сравнения. Вот, в общем и целом оно всё так, но дьявол, как всегда, в мелочах. Поэтому
давайте повнимательнее об этом всём поговорим. Первый вопрос. Вот эти два выражения, они
эквивалентны? А равно равно Б и А не меньше и не больше В? Ну, вроде бы нет. Вот это верно,
они действительно не эквивалентны. Например, для флотов. Кто-нибудь знает пример конкретного флота,
который ломает эту идею? Нам? Нам, да. Нам имеют очень странные свойства сравнения, и он не
позволяет нам просто так сказать, что травенство это то же самое, что ни меньше ни больше. То есть
чтобы вот это вот работало, нужно, если в терминах УКТЧ, кто его помнит, чтобы множество образовало
лун, линейно-опрядачное множество. Но это ещё не всё. Есть более тонкая штука. А, я забыл брать
подсказку, чёрт. В общем, вопрос такой. Вот А равно Б именно через оператор сравнивания, и А не отличима
от Б? Одно и то же или нет? Не отличима это значит, что ты никак не сможешь написать код,
который отличит два элемента друг от друга. Ну, что за такое? Подсказка не наталкивает на мысли?
Ну так какой ответ, да или нет? Да, они опять не эквивалентны. И вот как именно это пример
опровергает? Если мы сравниваем точки на плоскости по Х, то точки с одинаковым Х, но разным Y они
будут равны по оператору равно равно, но мы можем их отличить. Например, взяв у обоих из них Y,
и вот эти Y уже будут разными. И вот то, что слева называется эквиваленс, а то, что справа,
называется equality. И чтобы это было одним и тем же, нам вновь нужно сохранение предикатов.
Помните, когда мы говорили про концепты? Именно так. Ну, любое отношение эквивалентности можно
трактовать как равенство, но тут всё очень сильно убирается в вопрос, а что такое вообще равенство?
И как вы, возможно, помните изматологики, этот вопрос убойный, и можно в него копать бесконечно
много. Вот тут предлагается такая терминология, стандарт, насколько я понимаю. Ну то есть,
оператор равенства, он вам сдаёт какое-то отношение эквалентности на объектах, но оно не обязано
как бы работать как вот реальное равенство. Если вы вспомните аксиоматику, как его символа равно,
то там одна из аксиомов и вообще основная была, что для любого X, X равно X. И обратное, соответственно,
наверное, что-то типа, нет, обратное не верно, ну типа, сейчас как это сказать. Тут опять опираемся
во всякие артефакты матлогики, смотря как это всё определить, смотря какая модель, какая
интерпретация, смотря по-разному. Но понт в том, что бывают такие элементы, такие вещи, такие
объекты, которые как бы, вижу понятно, что неравны с такой повседневной точки зрения, например,
две точки, но при этом какой-то оператор равенства может говорить, что они такие равны. И вот в этом
состоит отличие терминов. И чтобы отличить все вот эти разные степени, какой вообще порядок у
нас, какое у нас равенство, стандарт нанесли три вот таких типа. Давайте думать, что это просто
янама. Вроде на самом деле не так, но почти так. И эти янамы ровно соответствуют тем трем категориям,
которые мы рассмотрели. Соответственно, стронг ордеринг — это линейно порядочное множество,
но не просто, а еще и сохраняющее свое равенство при любых функциях. То есть, если вспомним пример с
точками на плоскости, вот функция проекции на оси y, она не будет сохранять равенство. Потому
что у нас могли быть две точки с равными x, но при проекции на y результат вот применения этой
функции проекции, они уже как бы неравны эти результаты. То есть, равенство не сохраняется.
Weak ordering — это просто любой лун не обязан сохраняться равенства, и partial ordering — это
частично порядочное множество, то есть чум. Чуть поподробнее. Strong ordering состоит из следующих
элементов — less, equivalent, equal, greater. И может показаться странным, разве мы только что не сказали,
что в случае стронг ордеринга equivalent, equal — это одно и то же. Ну так и да, это одно и то же,
и equivalent здесь есть чисто для консистентности, потому что equivalent есть у всех других ордерингов,
и чтобы нам проще было как-то писать обобщенный код, его добавили и сюда. Ну тогда вопрос, а зачем
добавили equal? Чтобы подчеркнуть, что здесь equivalent — это не просто equivalent, а вот прям посильнее
утверждение. Соответственно, строго говоря, что значит это сохранение равенства? Это значит,
что любая функция, которая видит только то, что доступно по константной ссылке кому-то извне,
то есть приватные кэши мутабельные мы не учитываем, любая такая функция должна сохранять
равенство. Если а было равно b, то и f, а равно b. Заметь, f не обязан тип сохранять, то есть f может
из нашего конкретного типа в какое-то другое переводить, у которого очевидно должно быть тоже
определено равенство. И идея вот именно в этом, что если объекты в понимании человеческом равны,
это значит, что они неразличимы по константссылкам. То есть как бы мы не извращались с этими
константссылками, как бы мы не пытались что-то публичное оттуда достать, мы бы не смогли понять,
в чем отличие между ними. Это вполне естественное ожидание от любого адекватного типа. Если равны,
то не отличимы. Викордеринг почти то же самое, только икул не определяют, подчеркивая, что здесь
эквивалентность не гарантирует этой неотличимости. А partial добавляет нам unordered, то есть два предыдущих
они требовали, чтобы любые два элемента, они были либо равны, либо меньше, либо больше. Одно из трех,
а вот здесь может быть четвертый вариант, что они вообще никак не упорядочны. Вот, как-то так.
Ну вот мы определили три каких-то енамчика с какими-то элементами, и все эти элементы
консистентны и одинаковы, но вот хочется какой-то универсальный простой способ по элементу одного из
эти ордерингов понять, что он обозначает. Больше, меньше, равно, но при этом не прибегает к шаблонному
коду. Для этого ввели в стандарт, не знаю, справедливо ли это назвать, костылем, но такой красивый хак.
Вместо того, чтобы явно сравнивать с какими-то элементами янама или строить шаблоны, мы будем
сравнивать эти элементы с нулем. Соответственно less это всегда меньше нуля, независимо это less
и strong, weakly, partial, ordering. Equivalent equal всегда равны нулю из любого из ордерингов, greater
больше и unordered не равны нулю. Соответственно, что конкретно там будет в unordered, не уточняется.
Да, и сравнивать вот эти элементы этих янамчиков, их можно только с нулем, именно с нулем,
литералом ноль, в коде должно быть написано просто ноль. То есть даже если вы constexpr переменную
объявите и присвоите и ноль, и потом с ней будете сравнивать, это anti-fine behavior, так делать нельзя.
Нужно явно в коде писать меньше, больше или равно нулю. Ну макрос, в крайнем случае.
И соответственно с любыми другими типами сравнения ДУБ, да, даже сам том, сравнение ДУБ, несмотря
что литерал ноль, он как бы int. И между собой их тоже можно сравнивать, но в каких ситуациях это
нужно я сейчас не скажу. Ну и на этих оркерингах вполне естественным образом получается
свой порядок на этих оркерингах. Вот эти стрелочки означают сильнее чем. То есть стронгордеринг
сильнее чем виг, а виг сильнее чем паршоп. Но и с другой стороны оно значит, что то, что сильнее,
можно преобразовать в то, что слабее. То есть если какие-то объекты можно сравнивать по
стронгордерингу, это нам автоматически говорит, что их можно сравнивать и по виг и по паршал.
Из одних эксем следуют другие. То есть паршал базовая, виг добавили еще одно требование, стронг
еще одно требование. Как-то так. Соответственно космический корабль или НЛО, по-английски его
и spaceship называют и flying saucer. Ну согласно стандарту это называется three-way comparison,
то есть трехстороннее сравнение. Оно выглядит в общем случае вот так, возвращает какой-то из
ордеров, может быть как non-member, так и member, и на вход принимает по концу ссылкам объект.
Ну тут вы должны сказать, что ну позвольте, в плюсах можно операторы перегружать как
мы хотим, для любых типов, любые возвращаемые значения, любые аргументы. Почему именно так?
Ну действительно оператор spaceship можно перегрузить как вообще вы хотите, возвращая оттуда что угодно
и принимая что угодно, используя его как угодно, но крайне не рекомендуется это делать. Мы скоро это
увидим, причины этому есть, они достаточно веские. Ну окей, оператор spaceship мы можем определить для
нашего типа, но хочется как-то более формализованно сказать, что оператор spaceship
определён корректно. Конечно же, для этого завезли и концепт, который собственно можно
использовать, чтобы проверять есть ли у типа spaceship. Он выглядит поначалу как-то страшно,
как обычно, но если разобраться, всё легко. Первое требование weekly equality comparable with.
Ну на самом деле это просто говорит о том, что есть оператор равенства и неравенства. Они
определены и консистентны. То есть равно это не равно всегда. Purchase order with это тоже самое,
но для меньше больше и меньше либо равно больше. Те же самые требования, что меньше это не больше
либо равно. Вот, и последнее, это то, что выражение меньше равно больше, ну или a spaceship b,
определено и возвращает что-то, что сильнее, чем категория, которую мы указали. Сверху видно,
что этот концепт принимает вообще говоря произвольную категорию, но по умолчанию
partial ordering. И вот этот вспомогательный концепт compare size, он приводит к наименьшему элементу и
требует, чтобы этот наименьший элемент был таким же как cat. Сложно как-то сказать. Common
comparison категории t внизу, это наименьший элемент среди набора в порядке на ордерингах. Тот,
что я показывал из трех ордерингов. Мы говорим, что минимальный элемент в этом порядке это и есть
cat. Ну то бишь, что spaceship для a и b вернет нам что-то либо такой же силы как cat, либо более
сильной. Выглядит достаточно сложно для того, что в итоге получилось в стандарте, но раньше
ордерингов было пять, если я не ошибаюсь, и вся эта машинерия имела больше смысла, чем когда их
всего три, а как мы увидим в итоге, еще и не рекомендуется не использовать ни один из них,
кроме стронга. Ну да ладно. Ну как-то так. Тут сразу вопрос должен возникнуть. Мы только что
говорили в начале, что теперь можно не определять шесть операторов сравнения, а тут в концепте требуют,
чтобы уже были определены и равно-равно, и неравно, и меньше, и больше, и все остальные. Ну требуют,
а не требуют, но в язык добавлена новая фишка, которая дает вам их бесплатно. То есть это требование,
оно такое фантомное на самом деле, как мы увидим. В итоге, мне кажется, что вот эти два требования,
weekly, quality, partial, ordered, live, они нужны только если вы захотели заоптимизить и самостоятельно
руками. Написали операторы меньше, больше и прочее. А во всех остальных случаях тут на самом деле
все автоматом гарантируется. Единственное, что нам важно, это что spaceship определен и возвращать
нужную категорию. Ну да ладно, идем дальше. Конечно же, для обстроенных типов spaceship сделан.
Для integral он конечно же возвращает strong ordering, тут никаких сюрпризов. Для floating point partial,
как мы уже сказали, у нас есть нам, он то ли ни с кем не сравним, то ли даже себе не равен,
то ли еще что-то. При ближайшем рассмотрении оказывается, что только partial получается.
Соответственно, для янамов тоже есть ordering, и он совпадает с тем, какой типы указали использовать
для этих янамов. Надеюсь, вы помните, что после эту точку можно указывать янамам,
какой тип использовать. И если мне сейчас память не изменяет, то этот тип всегда обязан быть
std integral, а значит, ну всегда strong ordering. Кажется, что написано про underlining в стандарте,
возможно, это заделка на будущее. Последние это pointer, для них есть strong ordering. Кажется,
тоже никаких сюрпризов. Сюрприз есть только с одним пунктиком, когда вы используете вот этот
встроенный меньше равно больше для целочисленных типов, работают все приведения, как и в любой
другой арифметике, но не с bool. То есть, если вы сравниваете int с long-long, то у вас и то,
и другое приведется в long-long. Но если вы сравниваете int с bool, то это будет ошибка компиляции,
bool можно только самим собой. Почему такое исключение, я не уверен. Возможно, ладно,
я не уверен. Вот, но тут стоит еще сделать одно уговор. Возможно, вы это знали, возможно,
не знали, но сравнивание произвольных указателей это unspecified behavior, вообще говоря.
Нет, там вроде прямо сразу уб, если указатели не имеют общего происхождения.
По-моему, unspecified именно, а не undefined. Ладно, еще гляну.
Да, так вот, о чем идет речь. Если у вас указатели указывают в адреса, которые являются частью одного
объекта или одного массива, то все нормально. Они сравниваются адекватно в порядке хранения внутри
массива или объекта. Но вот если вы указываете в два разных объекта или два разных массива,
то их сравнение внезапно становится implementation defined, то есть unspecified. А почему так?
Комитет верит, что до сих пор существуют архитектуры, на которых память нелинейна,
то бишь не представляет собой массив подряд идущих байтов, от 0 до 2 в 48. Если у вас есть
примеры таких архитектур, обязательно мне об этом сообщить, и мне реально интересно,
где вообще такое найти? Вот эту мифическую архитектуру с сегментированной памятью.
Мне в голову так и в рту приходят, но и куда возможно? Но куда это все равно не стандартные C++?
В общем, не знаю. Если кто-то располагает информации, почему это до сих пор не убрали,
пожалуйста, расскажите. Ну да, так вот, почему у нас там...
Насчет указателей. В стандарте есть какая-то цитата, судя по описанию сравнения неравных
указателей на объекты, тут есть пункт про то, что указатель выглядит как partial ordering даже.
Ну да, имеется в виду именно это. Идея в том, что у нас бывают архитектуры с сегментированной
памятью. Они раньше были, их было много, а сейчас уже где-то было найти. То есть у них не была одна
оперативная память подряд идущая. Даже на GPU тогда она не сегментированная. Какую вам
абстракцию операционная система предоставляет? Виртуальная память, она идет подряд. То есть
иллюзия того, что вам выделили огромный чанк на 2.48 байтика, что хотите с ним, то и делитесь.
И вот предполагается, что бывают такие операционные системы, которые работают не так, которые не
предоставляют вам виртуальное адресное пространство, работают как-то по-другому. Возможно,
это происходит, когда на embedded-системах, где несколько чипов с памятью, эти чипы
напрямую предоставляются программе и считаются как бы вообще отдельными областями памяти. То есть,
например, какой-нибудь битик отвечает за то, к какой планке памяти микроконтроллер обращается.
Теоретически стандарт такое поддерживает, но это очень странно. Вот. Я не там читал,
все-таки действительно он специфивает. Надо отдельно читать обычные операторы сравнения,
отдельно трехсторонние, вот я не туда полетел. То есть, вот тут как бы такой конфликт. С одной
стороны, в стандарте издревле принято считать, что существует архитектура с сегментированной
памятью. С другой стороны, поинтеры выдают в стронгордере. Ну, видимо, потому что невозможно
понять, в какой момент этот уб действительно уб, а поэтому невозможно сказать, когда нужно
возвращать аннорго. Ну и это сильно усложнило жизнь тем, кто пишет код, хоть сколько-то обобщенный,
если поинтеры partial сравнивались. Ну да ладно. Так, идем дальше. Этот код. Работает ли он? А тут
уже ответ есть. Работает. Вам не кажется, что это магия? Компилятор научили понимать, что неравно
это не равно. Представляете, до чего технологии дошли? Что не позволяло это сделать еще 30 лет назад?
Загадка. Вот. Но теперь действительно достаточно только оператор равно определить вообще где
угодно, в любой ситуации, и неравно автоматом будет доступен. Более того, если вы определили
оператора spaceship, то вам доступны все операторы. То, о чем я говорил раньше, в концепте указаны
вот эти вот требования, чтобы равно-неравно остальные четыре штуки были определены. Ну так
если spaceship есть, то они уже определены как бы. Так что вот так. Не очень ясно, почему именно такой
концепт. Да. Но даже круче можно. Вот здесь уже сложнее понять, что происходит. Давайте внимательно.
Есть Q, есть C. Две разных структуры. Мы определили оператор сравнения C и Q. Слева C, справа Q. А внизу в
мы сравниваем слева Q, а справа C. То есть не в том порядке, как определили. И это все равно работает.
То есть компиляторы научили понимать, что равенство должно быть транзитивным,
симметричным всегда, даже для разных типов. Ну а теперь подробнее. Как именно это работает?
Есть вот такая табличка. Слева написаны исходные выражения, которые встречаются у вас в коде.
Вообще говоря, выражения как слева должны привести к чему? Мы начинаем формировать список перегрузок,
которые нам подходят. Потом выбираем из этих перегрузок наилучшую и ее используем. Теперь
чуть по-другому. В этот список перегрузок подмешиваются так называемые переписанные
кандидаты. То есть обратите внимание, когда мы пишем они равно B, в список перегрузок,
то есть различных операторов не равно, подмешают как кандидата оператор равно. Странная штука,
правда ли? Но при этом, если именно этот кандидат был выбран из всех перегрузок, в итоге в код
вкомпилируется не вызов оператора равно, а отрицание вызова оператора равно. То есть вот так
странно она работает. При грузке одних операторов теперь могут находить другие операторы. Ну и тут
про приоритеты стоит сказать. Приоритеты абсолютно естественные. Вот то, что с синеньким отмечено,
это так называемые синтезированные кандидаты. Это значит, что там переставлен порядок аргументов.
И вот их стараются в последнюю очередь брать. То есть вот внизу порядок. Сначала мы стараемся
обычных кандидатов найденных, как раньше, для операторов брать. Потом переписанные. Здесь это
всего две строчки. Мы можем не равно переписать на равно, не поменяв местами аргументы. И можем
любой оператор в сравнении переписать на spaceship. Мне кажется, тут нужно еще указать слева,
где собачка, что равенство тоже может быть. По-моему, я не уверен. Кажется, не совсем. По-моему,
это выпиливали как раз. Ага, то есть равенство все-таки не выражается через spaceship и табличка
правильная? По-моему, да. Там где-то писалось, что они в какой-то момент заметили, что они
раньше что-то перестали использовать в районе spaceship и выпили какие-то кучи всего. Надо
пересчитать, короче. Но вроде правда, что-то написано. Ну, будем надеяться, что прошлый препод сделал
правильную табличку. И пометим себе, что все эти вещи запоминать наизусть не нужно, а нужно
помнить, как в цепо были переперн слезть и все это перечитать заново, когда понадобится. Вот,
соответственно, просто сравнение меньше-больше через spaceship либо spaceship с переставленным. И
обратите внимание, сам spaceship может быть переписан через spaceship. Это важно с переставленными
аргументами. К тому, почему это важно. Давайте вот такой оператор spaceship рассмотрим. Вот он
нехороший. Он int возвращает. Я сказал, что не стоит int возвращать. Ну и что он делает? Он
возвращает просто разницу. И, конечно же, если эта разница меньше нуля, то числа были меньше. Если
она равна нулю, то равны. Если больше, то больше. Но проблема тут не в этом. Проблема возникнет,
если мы вот так сделаем. Вот тут два декл-тайпа написаны. Какие, по-вашему, типы будут выведены
этими декл-тайпами? Отмечу, что тут теперь две разных структурки. Возвращается все еще int,
и порядок, к которому эти структурки переданы в spaceship, здесь разные. А вот тут фиксирован
порядок. Ну давайте, что в первой строчке выведется? Ну конечно нет. Мы здесь просто вызвали оператор
меньше равно больше. Да, согласно приоритетам, если обычный кандидат, как и раньше, вот типа
традиционный кандидат, подходит, все остальные не участвуют вообще. Ну действительно, вот этот
оператор меньше равно больше. Просто функция, просто определена. Подходит, подходит. Он всех
побеждает. А вот когда мы B и A меняем местами, то обычный кандидат нам уже не подходит. Смотрим
в табличку. Самая нижняя строчка. Для A spaceship B есть синтетический кандидат, B spaceship A. B и A
переставляются местами, но при этом переписанное выражение, оно сравнивает результат B spaceship A
с нулем тоже spaceship. То есть многоуровневый spaceship. И в итоге мы получаем strong ordering. И вот это
еще один веский аргумент, помимо, собственно, того, что у вас переписываются выражения. Не
использовать ничего, кроме ordering. Пользователь не ожидает. Вернее, даже не так. Не пытаться
использовать теперь эти операторы ни для чего, кроме честных сравнений. Вот если вы такой же
фанат функциональных языков, как я, вам, возможно, хочется иногда оператор больше либо равно использовать
как какую-нибудь нам хитрую функциональную конструкцию, делающую что-то с функциями. Не стоит,
потому что она начнет переписываться как другие какие-то операторы, начнется всякий бред с
перестановкой аргументов, выведением strong ordering вместо того возвращаемого типа,
который вы хотели. Будет больно, не стоит. Едем дальше. Ну, если вы любитель STL, то наверняка
знаете про функциональные объекты less, less equal, greater, greater. Это такие типы, у которых
определенные операторы круглые скобки, которые любой шаблонный D сравнивает с соответствующим
оператором. Да, меньше, больше и так далее. Ну и теперь такое же для CompereStriva есть. Никаких
сюрпризов. Но есть бонус. Когда вы используете вот этот функциональный объект для сравнения
указателей, он внезапно гарантирует strong ordering и уже никакого уб. Почему так? Ну, как бы вот так.
То бишь, если вы собрались писать алгоритм STD log тупым путем сортировки мьюдексов по адресам,
вы теперь можете это написать согласно стандарту. Вам нужно всего лишь использовать CompareStriva.
Хотя раньше тоже можно было к Inkspot RT скастить, и это тоже работало. А еще STD less и STD greater тоже дают.
Тоже дают? Тоже дают порядок на указателях. Именно поэтому можно в мапе их использовать,
как указатель в мапах, как ключи. А, точно. Блин, да, это очень логично на самом деле. К сожалению,
с Reway мы все еще не можем использовать никаких стандартных алгоритмах, так что да. Но скажете вы,
а как же левость? Вот это все новое накрутили, а кода уже написана куча, и оно будет все не дружить
друг с другом. Если мы внезапно начнем общенный код на оператор spaceship писать,
использовать новый функтор, все полетит. Но на самом деле не полетит. Давайте попробуем
BinPolsk написать на spaceship. Написали. Заметьте, раньше, если бы вы писали BinPolsk для произвольного
T, вы бы в обоих ветках F A вызывали соответствующий оператор сравнения у T. А есть ли это строки?
Да? Строки сравнивать дорого. И поэтому какое-то время все жаловались, что у Lulu надо строк MP
использовать, а не операторы меньше-больше равно для строк производительности, и т.д. и т.п.
Теперь можно такой же производительности, как у сей, добиться и на плюсах, используя spaceship.
Сэкономили nano, micro, ms. Ура! В крупных подбазах это, кстати, возможно, повлияет, потому что одно
сравнение строк вместо двух, и если у нас весь код чуть более чем полностью состоит из сравнения
строк, это весьма весомо. Вот. Так что профит. Но теперь вместо T подставили старый тип какой-нибудь.
Докажется, даже те же самые строки в стандарте еще оператор spaceship не определяет. Но я не уверен.
Возможно, определяют. Ну и что делать? Нам дали старый тип, для него нет spaceship, а зато есть все
старые операторы сравнения. Напомнить, приходит вот такая штука, и ее рекомендуется использовать во
всем обобщенном коде. Она пытается использовать spaceship, если не получается, делает за два сравнения
с помощью старых операторов. Если быть точным, с помощью меньше и равно.
С строком все-таки завезли оператор. А, завезли? Ну, здорово. Ну, к моему классу T строка,
который написали 20 лет назад, еще не завезли. Так что штука полезная, тем не менее. Да, ну,
если мы, соответственно, собрались вот так вот двумя путями T через либо spaceship, либо через
старое, то сразу как-то вот надалкивает на мысли, что точка кастомизации нужна, чтобы вот подкостыливать
библиотеки. Ну и действительно так и есть. Тут написано, что точек кастомизации 6. На самом деле
точками кастомизации являются только strong order, weak order и partial order. Первые три. Остальные три
просто добавляют fullback на традиционные операторы сравнения. Так вот, что делает стд что-то
order? Первые три. Он, первое, пытается использовать цпошку с таким же названием. Надеюсь, вы помните,
как это работает. В контексте, где неопределенно стд xorder, он пытается вызвать функцию xorder,
если такая глобальная функция находится для соответствующих типов, используется она,
если находится ADL-ом что-то, используется оно. Ну вот, то есть неблоид, тот самый. Опять. Дальше
идет кастомизация флотов внезапно. Он гарантирует нужный order, то есть для strong
order strong, для weak order weak, ну partial order и так. Оказывается, в стандарте ee-e-e что-то там,
что-то там, то есть в стандарте флотов, есть способ как упорядочить сильно plotting point числа.
И ровно этот способ и используется. То есть, если вы хотите флоты сравнивать строго,
вам нужно использовать именно вот эти вот функции. Ну и поэтому в общенном коде, собственно,
не рекомендуется спейс шип использовать как таковой. Вот либо эту штуку, что-то order,
либо с holdback. Вот. Дальше идет функтор compare3way в общенном функциональном объекте. И после этого
xorder пытается использовать более слабый порядок, более сильный. То есть, если мы запросили partial
order на int, то он проигнорит первые три пункта, а в четвертом обнаружит, что функция strong
order для int работает. Используем ее как-то так. А order fallback просто пытается сделать что-то
order. И если не получилось, используют выражение «через меньше равно равно». То есть, если меньше,
то вернуть минус один, иначе если равно вернуть ноль, иначе один. Соответственно, в общенном коде,
то есть в шаблонах, всегда используем fallback как вариант. И только его, во избежание казусов,
проблем и плохого кода. Дальше идем. Что я хотел сказать? Да, кажется, этот код должен быть вам
знаком, если вы когда-нибудь решали вычислительную геометрию на олимпиаде. Часто приходится точки
закинуть в какой-нибудь мэпчик, в какую-нибудь другую хитрую структуру на порядках основанную. Но
для точки на плоскости вот такой оператор сравнения лексикографический, он абсолютно
бессмысленен. В чем смысл физический? Почему именно в таком порядке? Почему наоборот? Почему
не повернуть систему координат? То есть, как бы он даже в преобразовании никаких не сохраняет
систему координат. Это какая-то плохая функция для точек на плоскости. Поэтому рекомендуется
использовать ровно вот эту цеплошку для таких случаев. Если вам нужно закинуть в обещанный
алгоритм, который не предоставляет компаратора вашу точку, но и при этом использует спейс шип и его
друзей, используйте цепло стронг ворда, объявляете глобальную функцию и все в шоколаде. Правда,
пока в стандарте нет ни одного алгоритма, который бы использовал вот эти вот вещи,
но когда-нибудь они наверное появятся. То есть, как бы сделали хорошо, но не до конца, как обычно.
Да, то есть знания классные, но бесполезные. Возможно, если вы свой обещанный код алгоритма
будете писать, вы захотите это сделать не через компаратора, а через точки кастомизации. Иногда
это разумно, иногда не очень. Так вот, следующий пункт программы — дефолтные сравнения. Теперь
можно так делать. Кажется, радость. Кажется, круто, ура. Логично предположить, что все будет
лексикографическое, но на самом деле никакой радости нет и ничего лексикографического тоже нет.
Да, об этом чуть позже. Сейчас PRO меньше равно больше, его тоже можно делать дефолтным,
и оно вам сгенерит бесплатно оператор равенства. И вот тут уже все будет хорошо.
Мне не нравится порядок слайдов, ну да ладно. Даже так можно сделать, но при определенных условиях.
Подробнее. Для меньше и его друзей это все не работает. То есть вот это определение равно дефолт,
оно ничего не сделает, вообще ничего. Никак не повлияет на результат работы программы. Почему так?
Ну так сложилось. А вот для равно оно будет работать, для спейсшипа тоже будет адекватно
работать. То есть если вы хотите дефолтные операторы сравнения, вы либо равно определяете
дефолтным, либо спейсшип. Про то, что вот эти вот пять штук можно делать дефолтными, вообще забудьте.
Но чтобы понять, как они это делают, нам нужно понять такое, как экспандут листов subobjects.
Но оно определяется ровно так, как звучит. Все базовые классы, все поля, ну и рекурсивно идем.
А массивы соответственно по элементам сравниваются. Заметьте, что это значит, что на std-векторе
все может сломаться, если он конечно не определяет сам оператор меньше равно больше.
Тут такая проблема может быть. Так вот, как работает дефолтное сравнение.
Берется экспандут листов subobjects для левого и правого аргумента равенства.
И просто требуется, чтобы все они были попарно равны. Но кажется, что hf работает так, как и хотелось бы.
Здорово. То есть запомнили, оператор равно можно всегда описать дефолтным. Все будет круто, все будет работать.
Кроме особенных случаев, когда у вас какие-нибудь кэши внутри или что-нибудь такое.
Но это так. Сменьше равно больше. Конечно же, оно делает лексикографическое сравнение в таком порядке, как
подобъекты были объявлены. Ну то есть согласно этому определению, насколько я понимаю, мы сначала идем
рекурсивно в первый базовый класс и для него получаем экспандут листов subobjects, потом второй базовый класс и так далее.
А потом к всему этому дописываем все свои поля, попутно разворачивая массивы как отдельные элементы.
Вот. В порядке объявления средства поля разворачиваем.
И я думаю, код лексикографического сравнения вы все умеете писать.
Вопрос только, какой ордеринг будет возвращаться в случае авто.
Ну, здравый смысл подсказывает, что должен самый слабый из всех ордерингов, что вернули spaceship для x-ых ибрикад.
Ну, оно так и есть. Но при этом, если хоть один из этих spaceship-ов вернул не ордеринг, то все ломается, конечно же, как обычно.
Возвращайте только ордеринг.
Что еще? Да, ну, самый слабый, это вот опять, так же, как в самом концепте с 3-way comparable определялось, ну, только наоборот, самый слабый, а не самый сильный.
Да, но если у вас не у всех подобъектов определен ордеринг, может, где-то у них авто указано или еще что-нибудь такое, то вы можете явно прописать ордеринг.
Или если вы хотите его усилить явно.
И таки да, а если вы хотите, чтобы ордеринг был не ордеринг, то вы можете прописать ордеринг.
И таки да, а если вы хотите, чтобы ордеринг был не ордеринг, то вы можете прописать ордеринг.
Или если вы хотите, чтобы ордеринг был не ордеринг, то вы можете прописать ордеринг.
И таки да, а если вы хотите, чтобы ордеринг был не ордеринг, то вы можете прописать ордеринг.
И таки да, а если вы хотите, чтобы ордеринг был не ордеринг, то вы можете прописать ордеринг.
И таки да, а если вы хотите, чтобы ордеринг был не ордеринг, то вы можете прописать ордеринг.
И таки да, а если вы хотите, чтобы ордеринг был не ордеринг, то вы можете прописать ордеринг.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Но мне кажется, с этим все равно не стоит рисковать.
Дефолтное равно, так?
Да.
А вот с переписанными операторами пока непонятно.
А вот с переписанными операторами пока непонятно.
Да, то есть, видимо, поэтому равно не переписывается в spaceship.
Да, то есть, видимо, поэтому равно не переписывается в spaceship.
Да, то есть, видимо, поэтому равно не переписывается в spaceship.
Потому что у нас есть...
Потому что у нас есть...
Если мы дефолтный spaceship используем, и так есть дефолтное равно.
Если мы дефолтный spaceship используем, и так есть дефолтное равно.
Если мы дефолтный spaceship используем, и так есть дефолтное равно.
Более того, обычно на равенство
Более того, обычно на равенство
и можно проверить более эффективно, чем на меньше или больше.
и можно проверить более эффективно, чем на меньше или больше.
Бывают же еще типы, на которых нет порядка,
но у них есть оператор равенства.
Но у них есть оператор равенства.
Такое тоже бывает.
Такое тоже бывает.
Вероятно, для того, чтобы с такими типами
не возникало каких-то конфузов,
равно не переписываются в spaceship.
Мне кажется, с этим пока надо смириться.
Мне кажется, с этим пока надо смириться.
Когда-нибудь эту деталь мы для себя сами откроем
в один прекрасный день.
Чуть-чуть осталось.
Давайте потерпим, сколько у нас там времени.
Давайте потерпим, сколько у нас там времени.
А, час прошел.
Да, скоро будет перерыв.
Так, что в этом случае получится?
Так, что в этом случае получится?
Кем будет автор?
Паршал.
Кажется, что
по логике должен быть паршал.
И кажется, он действительно есть паршал.
Здесь должен был быть какой-то понт,
но я забыл.
Возможно, мы просто утвердили,
что все поняли,
как работает вот этот дефолтный spaceship.
Берет наиболее слабый
из всех подобъектов.
Есть флот.
У IntaStrong у флота паршал.
Наиболее слабый – это паршал.
Опять возникает вопрос про легаси.
Но я уже забыл, какой.
А вот такой.
Если у нас есть какие-то
объекты из библиотеки,
откуда-то еще,
все операторы сравнения, в принципе,
определяют.
И мы его хотим использовать в новом коде,
где хотим автоматически выводить
оператор spaceship.
Должно ли такое работать?
Конечно же, должно.
Legacy написано миллионы строк.
Мы такое хотим поддерживать.
Поэтому я вас немного обманул.
На самом деле,
когда вы указываете явно
возвращаемый ordering в дефолтом spaceship,
это еще и помогает
компилятору в тех ситуациях,
когда все операторы сравнения
как бы есть
у какого-то подобъекта,
а spaceshipа нет.
То бишь с legacy-кодом работать.
И ровно в этой ситуации
автор работать не будет.
Если мы вот здесь вместо
стронгордеринг напишем автор,
компилятор скажет эге,
а какой ordering ты хочешь?
Чего возвращать?
Сам он по операторам сравнения
догадаться не может.
Операторы сравнения могут
как угодно работать,
пока явно ordering не уточнили,
работать не будет.
И тут тонкость в том,
что
x и y теперь сравниваются
не spaceship,
на самом деле,
когда мы указываем
что они сравниваются уже не spaceshipом,
а в специальном
sinstreeway,
который и по сути
то же самое, что fallback,
только
хитрый.
Мне кажется,
они просто не смогли нормально
сформулировать стандарт, но то,
что имеется в виду, понятно.
В зависимости от того,
что указали в redte,
вот такие фы получаются.
Либо из strongordering
соответствующие элементы,
либо из wika,
либо из partial.
Последний пункт программы
по spaceship
рекомендации, как его использовать
в своем входе.
Каждый тип должен делать
одно из трех.
Но определять все
операторы сравнения
имеется в виду каким-то образом.
Либо через spaceship,
либо руками,
если этого так хочется и необходимо
производительностью.
Это первый вариант,
когда тип упорядоченный.
Второй вариант.
Тип только сравниваемый.
Он должен определять только равенство и неравенство.
И третий вариант.
Про тип ничего нельзя сказать,
ничего не должно быть определено.
Это очень естественные категории,
и если вы посмотрите в любые другие языки,
там это работает почти всегда так же.
Объявляют какие-то
трейды, тайп-классы, интерфейсы
и прочие монстры,
которые говорят
equality и ordering.
Ordering подразумевает equality,
а все промежуточное
считается плохим стилем,
плохим кодом и прочее.
Следующий гайдлайн.
Сравнение должно идти
по множеству тех вещей,
которые по факту копируются,
когда вы копируете объект.
Иначе это было бы странно.
Если сравнение использует
что-то некопируемое,
например, кэш какой-то,
то вот вы скопировали объект
и равенство изменилось.
Из меньше превратилось в больше.
Это очень неожиданно и неприятно.
Просто человеческая натура не ожидает такого.
Поэтому давайте так не делать.
И наконец,
не используйте никакие ordering
без кроме strong.
Внизу написано equality and equality
should be identical,
но подразумевается именно,
что, пожалуйста, не используйте ничего,
кроме strong.
Потому что с чумами
мы не умеем делать примерно ничего.
У нас нет никаких алгоритмов
для чумов.
Мы не можем закинуть их в мэпчик.
Мы не можем какие-то
вычислительные алгоритмы,
типа геометрических,
использовать для чумов.
Так что только strong ordering
кроме случаев, когда вы можете
и себе, и другим доказать,
что здесь действительно
необходим weak или partial.
Да, предпочитайте
default эти операторы сравнения,
оператор spaceship.
Но несуть важно, что там дальше написано.
Дальше.
Не заводите операторы сравнению
типов, для которых
эти операторы сравнения
не имеют смысла.
Например, делайте в вашей библиотеке
для точки в онумерном пространстве
оператор spaceship default
это предъятельно.
Ну, сама структура точки,
математическая концепция,
она не подразумевает никакого порядка.
И люди этого не будут ждать.
А с какой целью
так делается обычно?
Чтобы в мэпчик засунуть.
И гайдайн состоит в том,
чтобы не делать так,
а либо через тут цепочку
кастомизировать, когда мэпчик начнет
это поддерживать, либо засовывать
просто правило хорошего стимуля.
Я не понимаю,
что значит следующий гайдлайн,
но на всякий случай я его оставил.
Если кто-то понимает,
поведайте.
Кажется, это патология, да?
Используйте слабый ордер,
а слабое сравнение.
Спасибо, Кэп,
в этом все определение
век ордера.
Последний гайдлайн
мы уже говорили,
не используйте меньше равно больше,
используйте compare
fallback,
как он назывался,
strong, compare, strong
order, fallback, вроде так.
По крайней мере в обобщенном коде,
делайте с конкретными типами,
spaceship и spaceship,
в шаблонах только с fallback.
Этот совет долгое время
считался нормой,
теперь не считается нормой,
но не знаю в общем.
Тут была некая мотивировка,
что
с свободными функциями
проще работать,
когда у вас представляется порядок
аргументов, да?
То есть как бы, если вы
хотите сравниваться с int,
то вы определяете в своем классе
member, оператор сравнения
с int
и второй оператор сравнения с int,
который free function,
потому что a меньше int
и int больше a,
и то и другое должно работать.
Но теперь у нас есть переписывание,
и эти советы все не актуальны
по поводу того, как лучше
member или free.
Теперь можно писать как угодно.
Последний совет
противоположен предыдущему.
Да, и
тут есть некоторая
аргументация,
все аргументы
они не валимы.
То есть
с одной стороны раньше говорилось так,
теперь говорится сяк,
и я скажу следующее, делайте как хотите.
Теперь оба решения
эквивалентны как по мне,
у кого-то слово friend это
триггер, это начнет
трясти, пена из рта,
так что лучше не произносить.
Не знаю,
может у кого-то в кодбазе забанено слово
friend, и поэтому лучше member.
Мне кажется как бы
и последнее.
Ну не делайте сами с partial ordering ничего
вообще, ну пожалуйста.
Ничто не поддерживает
partial ordering в этом мире.
И смысла так делать нет.
Кажется его вообще в стандарт
завезли только ради флотов,
чтобы в очередной раз
всем напомнить о том,
что существует надо,
и нельзя просто так впихивать
флоты во всякие разные алгоритмы,
не думая, что из этого получится.
Типа, задумайтесь.
Вот, следующая тема
от рефлексии для бодтипов,
но перед этим мы отдыхаем,
если есть какие-то вопросы, давайте сейчас
нам всех них постараемся ответить.
Да, равно
и меньше нельзя,
давай вернемся к
переписыванию,
что нам позволяет определять меньше
операторов. Вот эта там табличка.
Операторы сравнения,
меньше-больше,
переписываются только через spaceship.
То есть если ты хочешь минимум
операторов обойтись,
тебе нужно равно и spaceship.
Ну что значит все?
Ну как правило, у тебя очень
элегантный код в spaceship получается.
Представь, как ты строки
и будешь сравнивать через spaceship.
Ты идешь подряд,
и как только нашел
что-то неравное, возвращаешь
меньше или больше.
А потом в итоге,
вне цикла,
если дошел до конца и ничего не нашел,
возвращаешь и код.
То есть spaceship, это незначительство,
нужно написать и меньше, и больше
внутри него. Как правило, реализация
spaceship проще, чем реализация
меньше и больше соответствующая.
Для длинной арифметики такая же реализация
spaceship, как для строк.
Вот, как-то так.
Так что,
в итоге мы все свели к домовым операторам.
Просто вместо большей или меньшей
оператор для сравнения
теперь spaceship.
Как-то так.
Итак,
пришло время научиться
рефлексировать.
Но для того,
чтобы научиться рефлексировать,
нам надо понять,
что мы собрались рефлексировать.
То есть, что такое подтипы?
Подтипы это ничего, в принципе.
Раньше в стандарте было такое
определение, как plain old,
data, type.
Но теперь его нет, есть
определение trivial и
copyable и так далее.
CDTrivial, по-моему, тоже есть.
Но оно не совсем
совпадает с тем,
что мы имеем в виду.
Но тут примерный список
того, что имеется в виду,
обозначен. По сути,
это структурки из сеть,
грубо говоря. Внутри которых
могут быть другие структурки,
но в итоге все сходится к
интам, флотам и прочим
драматильным типам.
Почти.
Все это, конечно, очень нестрого.
Просто
пытаемся себя
оберечь от
всяких
кейсов, где вообще ничего невозможно сделать.
Например, битовые поля мы будем
рассматривать. Это извращенство.
Дефолтные значения
для полей мы не позволяем.
Приватные не позволяем.
То есть в целом должно вот как-то так
выглядеть.
Так вот, что мы собрались с этим всем
делать? Мы собрались
в compile-time
определять количество
полей,
типы полей
и ссылку на поля
по его индексу.
И, конечно,
никакие лютые
припроцессоры нам не дозволены,
как есть в некоторых
расширениях плюсов,
вроде Qt
и припроцессора
Unreal Engine. Мы хотим
просто подхачить это, вот, используя
стандарт.
И рассмотрим несколько способов
все эти дела сделать.
Какие-то из них лучше, какие-то хуже.
Суммарно все костыли,
но на этих костылях основаны
некоторые библиотеки.
И если кто-то из вас
уже читал домашку
последнюю, там от вас
требуется название
янамов,
вытащить
количество элементов янама
и по индексу,
и не только по индексу,
по индексу и по его значению
выдавать элемент янам.
Но все это в какой-то степени
связано, но не сильно.
Я думаю, те, кто пытался
решать, наверное, пока это никто,
но тем не менее, те, кто пытался
решать, должны были увидеть,
что там упоминается
такая вещь, как претефанкшн,
который умеет свои шаблонные аргументы
показывать.
Это макрос,
выводящий название функции,
включая шаблонные аргументы.
И на основе этого
предлагалось и вытаскивать
название янама,
название элементов янама
и даже лучше.
Но вот здесь
такие привыки нам
не особо подходят.
Это нам не поможет посчитать
количество элементов,
количество
полей в структуре.
Количество и
номера элементов янам
работало, если вы придумали,
как решать задачу, а здесь нет.
Зато работает
другой тюк.
Что будет, если мы сделаем
вот так?
Все нормально будет.
Оно возьмет инициализируется
нулями, если что.
А так?
Х будет единичкой,
а Y инициализируется нулем.
И так тоже все будет работать.
А вот так уже не будет.
Поняли, как находить количество
элементов?
Да.
И это даже сложно назвать
костылем, если честно.
Это вполне естественный способ понять, сколько элементов
в структуре.
Ну то есть задача проста
написать шаблон, который вот то же самое,
что мы сейчас делали руками,
делает автоматом.
То бишь перебирать arcs
от 0 до
бесконечности.
В какой-то момент мы встретим
то, что не компилируется,
и в этот момент нужно ответом
дать size-1.
Итак, вопрос.
Откуда взять, собственно, аргументы?
Мы тут такие умные единичку
и char указывали,
но мы же хотим произвольное, в принципе, типа
поддерживать, да, более-менее.
Какие есть идеи?
Кто-нибудь помнит про
операторы каста?
Помним, помним.
Нам нужен шаблонный
оператор. Да!
Мы можем сделать шаблонный оператор
каста, который позволяет
нашу структуру,
которую мы назовем ubi-констрактор,
кастоваться к любому типу.
То есть синтаксис
обычно оператор и название
типа, да, ind, bool или что-нибудь такое.
А мы сделали его шаблонным
и подставили сюда произвольный тип.
И я не помню,
мы в это влезали или не влезали,
когда говорили про шаблоны в самом начале.
Вывод типов работы для операторов
каста.
Оно способно понять, какой шаблонный тип
здесь указывать.
Вот.
И, собственно, на этом основном есть трюк.
Шаблонный ССТ
аргумент здесь нужен
просто для удобства.
То есть к самой этой структурке он не имеет
отношения. Это вот, как мы ее использовали,
собрались.
Использовали мы ее собрались так.
Знаю много букв.
Давайте постепенно попытаемся разобраться.
Читать будем,
начиная с третьей строчки.
constexpr, sidestack, count,
field, simple.
Оно принимает индекс sequence.
Про индекс sequence
помню, мы вроде с ним играли все же.
И, соответственно,
по переданному ей индекс
sequence, она восстанавливает
последовательность
sidestacks, там,
DAD, видимо.
Дальше
она берет и
в эту последовательность
дописывает нолик
и просто передает
ее в себя же дальше рекурсивно,
указывая T.
Единственный настоящий шаблонный
аргумент.
То есть пока это просто вот та рекурсивная
часть.
И самое главное
здесь это вот
constraint на второй строчке
constructable from.
То есть эта функция
вызовется,
вернее, подойдет
среди набора перегрузок,
только если T конструируется
от ubic-конструктора от ish.
Ну, а если
она не подошла, нам
нужен fallback.
Ну вот же.
Как и говорили,
берем size of ish
и вычитаем единичку.
То есть мы будем стартовать
с пустого index sequence
и
пытаться конструировать
с T от ubic
конструкторов
столько штук, сколько элементов в i
в index sequence.
Пока у нас получается,
вызывается вторая перегрузка.
Она каждый раз дописывает еще по одному
молику в index sequence.
То есть index sequence в размере растет.
И вот как только у нее перестало
получаться конструировать, мы провалимся
в первую перегрузку
и выдадим ответ
size of i-1.
Понятно, почему
это работает?
Надеюсь, что да.
Пока ничего
сложного, просто код
на слайде выглядит
неприятно.
Ну и
запускать это мы собрались
соответственно вот так.
Пустой index sequence передаем
и конкретный их термин.
И это будет работать.
Вопрос,
что здесь выдастся?
Наверное,
1.
Почему 0,
почему 1?
Потому что он может запилить
конструктор копирования.
Да, именно так.
Хотелось бы, чтобы было 0.
Мы от 0 аргументов пытаемся
сконструировать. Работает.
Дальше пытаемся от одного аргумента.
И у нас срабатывает конструктор копирования.
Неприятно.
Тут нужно подкрутить
костыль.
И вместо constructable from,
который мы там использовали выше,
можно ли сконструировать
от ubic?
Использовать свой концепт.
Который явно
делает именно агрегатную унициализацию,
а не какую-то там,
какую constructable делает.
И вот она
запретит, если мне память
не изменяет, формулировка такая,
запретит вызывать конструктор
копирования, если для этого требуется
implicit cast.
Ну и ubic
именно implicit cast приводим к
нужному типу, поэтому
копирование не произойдет.
И вот теперь это точно
полностью работает.
Здесь мы его заменили в requirement.
А, для ubic
правильно поделались.
Что, для ubic?
Это ты вопрос задаешь.
У ubic это
exposition only, так сказать.
Да.
Не рассматриваем всякие
патологические случаи.
В целом, все хорошо.
Раньше это делали
по-другому.
Почему-то.
По-моему, это придумал Антон Полухин
вообще всю эту тему.
И технология была такая.
Давайте оценим количество
полей, которых
мы делали.
Ну, в общем,
давайте оценим количество полей
структурки сверху как
sizeof этой структурки.
Весьма логичное предположение.
Так как каждый объект
в плюсах, он не может быть
меньше одного байта.
Да?
Битфилды сразу вообще не рассматриваем.
Ну и базовые классы тоже.
Да.
Соответственно, с базовыми классами
это тоже, кажется, возможно, сработает.
Но лучше не рисковать.
Ну типа UBO там все-таки работает, поэтому...
Да, UBO.
Это ты в правильном направлении мыслишь.
Но в целом и в общем
оно как бы работало.
И дальше мы брали
и наоборот уменьшали количество
аргументов.
Вероятно, задачу про ИНАМ
вы хотите решать примерно так же.
Только оценку брать из другого места
и проверять
работает или не работает
другим способом.
Да, и соответственно вместо концептов
юзалась ФИНАЕ. Здесь тоже можно
завязать, но концепты.
Но с 17 стандарта
эта штука вообще плохо будет
работать.
Появилась вот такая
штука. Возможно, вы про нее
слышали.
Называется No Unique Address.
Вот тут упомянулось уже UBO.
Это...
Стоп, что?
UBO?
Андрей, при чем тут UBO было?
Оно было к тому, что кажется
я могу наспаунить там
сотню базовых классов, которые
займут 0 байт.
Это EBCO называется?
Ну я это называю EBO, типа empty
base просто.
UBO?
Я сказал E, empty.
А!
А, EBO, все, я понял.
Да, в общем,
просто UBO это термин из компьютерной
графики. У меня уже все...
А что назначают?
Uniform Buffer Object.
Но не важно.
Да, есть такая штука как empty
base class optimization.
Мы, кажется, говорили о ней.
То бишь, что происходит?
Если вы наследуете класс, у которого
нет полей, то под него не выделяются
байты. Вообще.
А вот этот атрибут волшебный
с 17 стандарта появившийся,
он позволяет просто полю сказать,
что у тебя может не быть уникального
адреса.
То есть так же, как у предка
могло не быть уникального адреса, он занимал бы
0 байт. Так же и поле теперь
может занимать 0 байт.
То есть размер
этой всей структурки x будет
4 на
адекватных архитектурах.
То бишь, таким же, как сайзы фонта.
Ну и это ломается,
если вы сверху оцениваете размер
своего класса как
сайзов.
Так что да.
Еще одно примечание.
Вот если новый уник адрес отмести,
то
можно
всю эту технологию
бинпоиском делать.
Почему она
ломается снова уник адрес?
У меня
вылетело из головы.
Нет, я не понимаю,
почему она ломается. Мне кажется,
можно и снова уник адресом тоже сделать
залогариф. Но каким образом?
Проверяем до 0,
проверяем до единички.
А дальше пытаемся увеличивать вдвое.
То есть 2, 4, 8,
16, пока не перестанет проходить.
Потом получившись им травал,
делим пополам.
Это тоже будет работать залогариф.
В двоичном подъеме такая технология
используется, когда мы как бы не делим
пополам, а пытаемся
расти на степени двойки.
Но подобные извращения
в домашке, если хотите, напишите,
но, по-моему, без этого сработает.
Следующий пункт
самый адский.
Как вытащить типы болейки?
Мы посмотрим на 4 решения.
Хорошего среди них
сразу говорить не будет.
Все они в какой-то степени плохие.
Так что надо выбирать то, которое
вам в душе резонирует
с вашим духом
авантюризма.
И вот первое, мне кажется,
совсем плохое.
Никому не рекомендую.
Я даже половину информации о нем
выкинул из лекции.
Потому что совсем умыло.
Я сам заснул, когда в прошлом году
это рассказывалось.
Но для справки.
Вот мы написали UBIQ.
Давайте даже реализуем
этот метод.
Когда мы внутри этого оператора
кастом, мы знаем тип.
Потому что он нам вывелся.
Что если мы его
как-то вытащим наружу?
В принципе, все дальнейшие
способы, кроме последнего,
основаны на этой идее.
Вопрос только в том, как вытаскивать тип наружу.
Мы же не можем его в переменную засунуть.
Ну, можем.
Давайте организуем множество
кострелей и научимся
конвертировать любой тип в чиселка.
И как это делать?
Это вопрос, не имеющий
однозначного ответа.
Миллион вариантов придумано.
Один другого хуже.
Конечно, всем стандартным типом
можно наплодить
идентификаторов каким-нибудь
macros.
Можно даже сделать macros для
регистрации пользовательских типов,
которые тоже каким-то образом будут
ID-шник выдавать, но не автоматом.
А мы сами будем прописывать
ID-шники, потом они начинают конфликтовать.
Не расчеряем.
Потом...
Да.
Но что делается?
Пользовательские типы.
Яна.
Это тоже пользовательские типы,
но они немножко отличаются.
Самую главную проблему
все-таки составляют указатели
и CV-квалификаторы.
Вот как вы будете отличать
тип int от int-звездочка
от int-2-звездочки
от int-3-звездочки.
И так далее до бесконечности.
Ну а с интов не хватит.
Очень неприятно.
Количество типов экспоненциально
растет на самом деле.
И вот ответ
костылять.
И мне так не нравится костылять,
что я про него даже не буду рассказывать
подробно. Я покажу вот эту картинку.
Нижние
желтенькие байты.
Картинка, кстати, из доклада
Полухина, если я не ошибаюсь.
Желтенькие байты зарезервированы
под сам тип
с правой стороны ID-шника,
который 64 бита занимает.
А с левой стороны ID-шника
биты идут тройками.
Каждые тройки
биты соответственно обозначают
навешен ли конст,
навешен ли указатель,
навешен ли вола тайл.
И эти тройки могут
идти сколько угодно,
ну, вернее, сколько влезет.
Заметьте, пользовательские типы здесь
на самом деле не поддерживаются.
То есть
вот эти пять битиков
это только на встроенные типы.
Можно расширить для пользовательских,
но все равно это все-таки костыли,
мне это так сильно нравится.
Ну, чтобы чуть лучше понять,
все-таки посмотрим внимательно
на этот пункт.
Там подряд идет
0.1.0, троечка,
а потом 0.0.1.
И почему
так?
Вот красное
оно относится к самому внешнему
указателю,
на который
не навешен конст на самом деле.
Потому что конст, который
слева указан, он, как вы знаете,
на самом деле относится к самому
шарту.
То есть это указатель
на указатель на конст-шорт.
И
вот это
мне даже кажется, здесь неправильно указано.
Нет, кажется, идея в том, что
единичка
означает просто указатель,
1.0 означает указатель
на конст,
0.1.1
означает,
видимо,
указатель на волота,
1.0.0 указатель на конст волота.
Еще сюда ссылки можно
приобрести.
Еще вопрос, а как квалифицировать сами указатели?
Добавив еще один блок.
Хотя, да, видимо, они квалифицируются
на конст волота. Они следующим блоком квалифицируются.
В общем,
эту идею можно добить до ума
в некоторых системах
промышленных. Это даже доводилось
до ума и использовалось прямо.
Но мне это так не нравится,
что я вам не рекомендую податься в домашки
и это написать.
Так вот, прос.
Это просто работает, хоть что-то,
хоть как-то вытащили.
Соответственно, дальше нам еще обратно
нужно научиться конвертировать
число в тип
тоже костылями и ефами.
Конст текст про ефами,
прошу за мисс.
Но, да,
недостатков полно.
Тут почти ничего не поддерживается,
полная боль. Так что давайте следующий способ.
Это такое
реактивное решение
немножко.
Вот мы знаем здесь тип, да,
но мы его не можем
вернуть. Это, надеюсь, еще в прошлый раз
все поняли, да, что мы как бы
так как мы эти юбики
засовываем в конструктор дэшки,
ничего вернуть из этой функции напрямую
не можем.
Ну, подобные проблемы
еще возникают, когда мы какой-нибудь
асинхронный код пишем.
И там была идея такая,
давайте не возвращать наружу
через возвращаемое значение,
а колбэк использовать.
То же самое.
Мы постараемся
сюда затолкать колбэк,
но будет это все
сделано, конечно, очень
неудобно,
потому что нам нужно
будет накопить
каким-то образом
пак из всех этих типов,
которые пришли в разные юбики.
Соответственно,
теперь юбик еще и принимает
пак, и
каждый следующий
юбик
он должен будет взять у предыдущего
юбика этот элемент каким-то
образом
и засунуть свой.
Давайте внимательно
на это посмотрим.
То есть как бы раньше
мы все юбики сразу впихивали,
а теперь мы как бы будем
ну, вернее, уже
найдя размер структурки,
мы будем эти
юбики сначала
как бы
будет второй проход
от нуля длины
до n, и в этом
втором проходе мы будем каждый раз
накапливать
типы.
Причем этот второй проход идет рекурсивно.
Мы изначально запускаемся
от только одного аргумента
соответственно
t от юбик-констрактора
одного.
То есть он внутри себя
уже знает первый тип
и запустит опять рекурсивно
foreach field and depth
уже с одним известным типом.
Теперь мы запустимся от двух юбиков.
И вот второй из юбиков
нас запустит
с соответствующим
вторым типом.
То есть
во втором аргументе,
втором юбике уже будет известен второй тип
и мы запустим foreach
уже от двух типов.
Надеюсь, эта идея ясна.
Спросите вопрос. Мне кажется, она не очень ясна.
Возможно, вам нужно посмотреть
этот код, а мне помолчать.
А как мы поймем, что у нас все конец?
Мы все нужные типы ставили.
У нас что-то рекурсивно вызывается
foreach field.
Ну да, этот момент здесь упущен.
Но его надо дописать.
Но мы до этого еще можем
с помощью юбиков найти количество полей
и соответственно
ровно столько запустить
по глубине, сколько мы можем
запустить по глубине, сколько мы можем
запустить по глубине, сколько мы можем
запустить по глубине.
Сколько запустить по глубине, сколько нужно.
Еще мы можем сравнить
sizeOfTypes
с sizeOfE.
Собственно,
по-моему, это дальше по
слайдам даже делается, если их не вырезал.
Да, мы добавим перегрузку.
В тот момент,
когда sizeOfTypes станет таким же,
как количество полей,
которые мы до этого узнали,
которые мы до этого узнали,
мы запустим калбэк.
Ну да, тут
была попытка продемонстрировать,
что ретерном ничего никуда вернуть не выйдет,
мы обратно из всей этой глубокой
рекурсии полетим
и ни к чему хорошему не придем.
Зато
калбэк мы вызвать можем.
И калбэк будет
тоже шаблонный compile time.
Да, все, весь этот код,
что здесь написан, нужно какой-нибудь текст пропометить
по-хорошему.
Ну да, все типы узнали,
их столько, сколько нужно,
мы их можем в калбэк засунуть,
а в итоге
запускать это вот как-то так
из внешнего кода.
Пихаем forest-field-meistract
и пихаем лямбду.
Лямбда шаблонная,
и в types нам придут в итоге
список типов, которые есть
в структурке.
Мы их можем напечатать,
ну и примерно больше ничего с ними не можем сделать.
То есть это как бы не решение проблемы,
мы до сих пор не смогли вытащить
из юбика тип,
мы просто
позволили дописать еще немного
кода в итоге к этим всем юбикам.
Иногда этого хватает,
то есть это не самое плохое решение,
но хочется большего.
Хочется большего.
Да, прос мы поддерживаем
на самом деле все типы.
Вот эта технология,
ей без разницы какие типы
в структурке.
Виктора, стринги, все поддерживается,
все замечательно.
И даже другие структурки.
Вообще все.
Но мы не можем вытащить результат.
Еще одна большая
проблема,
это то, что эта штука работает за квадрат инстанциации.
То есть нам нужно
проинстанцировать все
для всех длин
типов от одного до
два.
Как мы знаем, это квадрат.
И это может работать действительно долго.
Рома, насчет инстанцирования.
Да.
А верно ли, что у нас самый первый юбик
постоянно будет к списку
дописывать поле первого,
ну, к своему списку будет дописывать
тип первого поля?
Первый раз инстанцировать?
Да, да, я тоже эту проблему тут заменил.
И вот что-то тут вообще наэкспоненциальный
прикол смахивает какой-то.
Да, надо тут это обрубить.
Я думаю, здесь это неопробленно,
потому что на слайды не влезло.
Дописывать я поленился,
если честно.
Ну и опять же слайд был бы гораздо больший и страшнее.
То есть вот здесь необходимо
для всех, кроме последнего аргумента,
каким-то образом им сказать,
не запускай дальше рекурсию.
Ну, то бишь,
если и
нумируются
от 0 до n,
то...
Ну, в общем, это неудобно.
А, ну, там вы не делали сайзовом параметру парка?
Да, нет, это неудобно.
Нам нужно все равно таскать за собой.
Ну, как бы,
это неудобно.
А...
Ну, как бы...
Да, нам нужно сделать,
чтобы и был от 0 до
сайзового параметра пака,
а дальше в юбик еще как-то передать...
А, ему и так параметр пака...
Дальше что-то даем?
Да, то есть нужно сравнить и с сайзовым параметром пака.
Ты прав.
Ну, в общем, да.
Это доделывается,
и, в принципе, работает.
Но за квадрат.
А вот дальше будет круто.
Что же там может быть словом
«аркейн» помечено?
Даже не знаю.
Так.
Ты не спылиришь.
Я все не спылиришь.
Возможно, кого-то ждет Катарсис.
Вопрос.
Всегда ли
верен этот статик ассорт?
Да.
Почему так не верен?
Тут угловые скобки нужны.
Ну ладно.
Ну это да.
Я копирую некоторые слайды
с прошлого года.
Половина.
Так что ошибки тоже остаются.
Ну, хотелось бы, что
я бы сказал, что
у нас есть
очень много
ну, хотелось бы, что
да, очень хотелось бы,
если бы мир был
так добрый к нам.
А вот так.
Нет.
А тут нет. Почему?
Может, даже оператор быть
неопределен. Что-что?
Оператор может даже быть
неопределен.
Ну да, но давайте считать,
что все-таки это адекватное равенство.
Ну тогда, если это адекватное,
то по определению должно быть.
Ну, что значит
глобальная функция?
В constexpr функциях нельзя
использовать глобальные переменные.
Да, заметьте, там и тут
constexpr.
И статические переменные тоже в constexpr
функциях вроде как писать нельзя.
Хотелось бы, чтобы
это было всегда так.
Ведь все, что у нас до сих пор
было в compile-тайме,
оно работает
как в математике, как в функпрове.
Очень декларативно.
Вы объявили что-то, это оно всегда такое.
Имутабельно.
Но никогда не меняется, и все нормально.
Reference transparency
есть такое понятие.
Неважно, по какой ссылке вы
обращаетесь к значению,
оно всегда одно и то же.
Что-то вроде того.
Если честно, уже не помню
правильную формулировку.
Но суть ясна. Все имутабельное,
есть только значение, никаких переменных.
Но вот оказывается, что все это...
А, еще вот такой пример.
То есть мы даже никакие функции
не вызывали.
Вот объявили две переменные.
Одного и того же типа.
Да? Будет ли у них одинаковый тип?
Может и будет, а может и нет.
Ну, хотелось бы.
Но ответ на все три
вопроса нет.
Вы что, думали, в сказку попали?
С оговоркой, что только
в современном.
Мы сделаем вот так.
Надо потупить
и понять, что происходит.
Первая структура.
У нее есть два шаблонных
аргумента. Первый, который ни на что
не влияет. И второй,
не типовой,
который равен
дефолту.
Но
каждая лямбда
имеет уникальный тип
и уникальное значение.
Каждая лямбда, вообще любая.
И при инстанциации
этого класса
считается, что вот этот дефолтный
аргумент объявлен там, где происходит
инстанциация.
То есть при разных инстанциациях
будут разные лямбды.
Даже более того,
если вы один и тот же первый аргумент
подставите,
int и int, как было в прошлых примерах,
все равно оно
будет заново инстанцировать этот класс,
считая, что опа, второй аргумент
отличается, потому что это новая лямбда.
Да, это работает вот так вот странно.
Ну и во втором
примере тоже понятно, что происходит.
Каждый раз, когда мы вызываем
эту функцию в любом виде,
это будет новая инстанциация шаблона,
которая будет возвращать
новое уникальное значение.
Магия.
Так вот, как это относится
к нашему делу?
Мы хотим вытащить тип.
Давайте познакомимся
с дефектом стандарта
номер 2118.
Я не знаю, точно ли в стандарте было 2117
дефектов до этого,
но размер
числа впечатляет.
Вот такой код есть.
Уже когда с порцияртоп
упоминали,
что френдов можно писать
в классах
и даже объявлять.
Вот так написали,
и больше ничего не написали.
Что это будет?
Конечно же, это будет ошибка компиляции.
Лобхол не объявлен.
То, что мы написали в его френдом
для тега,
означает, что в внешнем скопе
произошла
декларация лобхола.
Но диффинишена нет.
Поэтому извините.
Компайл Aurora.
Но тут есть
детали.
Давайте даже пока сюда
посмотрим.
Лобхол возвращает
авто.
А если вы помните
предыдущие разговоры,
как только мы возвращаем авто,
декларация
как бы декларацией для функции
не считается.
Потому что мы всю сигнатуру функции
не описали.
Мы сказали, что
а вы, види мне, сигнатуру из тела.
В шаблонах это удобно.
Что делает
френд авто лобхол?
Непонятно.
Он как бы делает декларацию
во внешнем скопе,
но как бы ее не делает,
авто не позволяет
декларировать.
А теперь мы добавляем вот это.
И тут
мы сделали
френда лобхол,
но еще и определили его.
Да, в ЦРТП мы так делали.
И собственно с оператором Spaceship
также делали.
Определяют френда внутри класса.
Он попадает во внешний скоп,
с помощью ADL находится.
Никого не шокируют текущие слова.
Правда, если шокируют, то вопрос знайте.
Как ты мог все забыть?
В общем, если вы написали
вот такую функцию
френд с определением
внутри класса,
это просто значит, что вы во внешнем скопе
определили новую функцию
с таким названием,
которая автоматически
френд для текущего класса,
но при этом
эту функцию нельзя вызвать явно.
Ее можно вызвать только с помощью
ArgumentDependentLockup.
Когда из аргумента
мы понимаем, в каком на Emspace
лежит функция.
Смотрим еще раз на код.
Два шаблона.
Оба они объявляют
френд автолуп холл.
Но первая из них объявляет
только
объявляет, а вторая еще определяет.
Если мы вот так напишем.
Изменилось ли что-то?
Нет, мы же не специализировали
френд автолуп холл.
Да, ничего не изменилось.
Мы не инстанцировали луп холл,
а поэтому
френда нет.
Мы про это, кажется, уже упоминали,
что когда вы френда
вписываете таким образом шаблон,
начинается магия.
Подобная функция у вас
определяется для каждой инстанциации.
Так как мы еще ни разу
не инстанцировали луп холл,
пока что нет ни одного
определения в коде для функции
луп холл.
Но как только мы
инстанцируем
луп холл,
внезапно оно
будет работать.
То есть теперь
функция луп холл определена.
В зависимости от того,
вписана ли у вас в коде уже вот эта
строчка, а вернее
обработана ли уже компилятором,
вот это выражение
даст разный результат.
Оно либо
ошибку компиляции даст,
либо скомпилируется.
Понимаете ли вы,
что мы научились делать?
Мы научились
хранить один бит
в памяти компилятора.
Устанавливается?
Его из нуля в единицы.
Да, мы научились
пока только из нуля в единицы
его устанавливать.
А мы не можем сделать
декл-тайп
от возвращаемого значения
получить сразу тип?
Что, что еще раз?
Если делать декл-тайп
от луп холл,
то тег ноль,
то мы получим тип наверх.
Правильную сторону выслеживаешь.
Я не знаю,
честно, что произойдет,
если два раза инстанцировать луп холл.
Это все
очень близко
к призыву ктулзу.
То есть тот код,
что вы увидите,
он стандарту подлежит.
Это не undefined behavior,
это не unspecified behavior.
Это код,
про который стандарт
просто ничего не говорит.
Мы задумались,
что так можно написать.
Раз код стандарту не противоречит,
значит все окей.
Но на стандарт
ничего не говорит.
Поэтому непонятно,
что начнет происходить,
если мы два раза луп холл напишем
или еще подобные вещи.
Я бы сказал,
что если мы второй раз
напишем луп холл
с таким же интом,
то будет ошибка компиляции,
потому что ambiguous.
Мне кажется так.
Но я не уверен.
Так вот.
Мы добавим
еще и т.
И это т,
оно как раз будет
кажется спасать
и у нас будет
кажется спасать
от этой ошибки
ambiguity.
Да, мы же собрались написать
рефлексию для любой структуры.
Если мы собрались
как-то это использовать,
хотелось бы, чтобы нашу рефлексию
можно было не один раз за всю программу использовать.
Соответственно,
t это будет тип структуры,
f это тип поля,
а n это номер поля.
То есть
как это понимать?
Верхняя структурка
определяет для каждого t
и для каждого числа n
флажок,
который может быть 0 или 1.
Изначально все эти флажки нот.
А нижняя структурка
пишет в этот флажок
1
и волшебным образом
протаскивает f
через этот флажок.
Я бы даже сказал так.
Это optional тип,
переменная типа.
Для каждого t и n
нижняя структурка
пишет тип
в это поле.
Осталось научиться
вытаскивать.
Ну, уже сказали,
вытаскивать мы будем декл-тайм.
Итак,
loophole
от tag от t и n
внизу желтым подчеркнутое,
это глобальная
переменная типовая
внутри компилятора.
В loophole get
мы просто
читаем ее.
Если не выездит,
то ошибка компиляции,
можно даже
это с детектить
с помощью свиная.
Но нам это не интересно сейчас.
А сверху
ubik,
который мы до этого смотрели.
А, кстати, я не сказал ubik
от слова ubiquitus,
то бишь
универсальный в каком-то смысле.
Вот, и этот новый ubik
он выглядит в принципе
так же, как и старый.
Только мы теперь еще и t-шку
делаем.
И внутри каста
мы делаем loophole set.
Таким образом,
в этот слот
с ключом
ti
пишем type.
После этого в любой момент
можно запустить loophole get
с нужным ключом,
структуркой номер поля
и выключить тип этого поля.
А дальше мы их можем затолкать
в тюкл и передать пользователю.
По-моему, это отлично.
Так вот,
что по этому поводу
говорят
серьезные дяди?
Читаем дословно.
This technique is arcane
and should be made informed.
Я не придумал слово arcane.
Это официальная терминология.
И да,
все согласны, что эту технику
надо выпилить,
но никто не знает как,
поэтому продолжаем танцевать.
И на основе
этой лютой техники
можно придумать еще кучу всего
очень страшного,
очень-очень страшного.
Но мне кажется, мы уже сегодня
не успеем все это страшное
посмотреть.
Я предлагаю вам самим играться.
Есть ли какие-то еще вопросы
про вот эту штуку?
Может быть, вы не поняли
и вам нужно еще раз посмотреть на код?
Кажется, тут можно обобщить
до какого-то там type2ply
или еще какого-нибудь более крутого ключа.
Кажется, что можно.
А как только ты попробуешь,
ты будешь жалеть о своем решении.
Ну, я как-то уже пробовал.
Я пока еще не осознал
несколько шагов.
Там на каждом шагу
ошибки компилятора,
которые говорят тебе ни о чем.
Вот ты просто пытаешься
что-то сделать с этой техникой,
а тебе компилятор говорит, ошибка, я ошибся.
И все.
И ты никак не понимаешь,
что происходит, почему.
То есть это такие дебри,
с которыми весело иногда поиграться.
И мне даже удалось,
по советам ребят с реддита,
сделать примитивную версию
боров чекера,
который автоматически следит
за тем, где начинается один регион
и где он заканчивается.
Да, вот настолько.
Но оно, конечно, работало отвратительно
из-за специфики того,
как именно вот эти вот
сеты происходят.
Нужно иметь в виду,
что вот этот сет, он происходит
не в момент запуска функции,
а в момент инстанциации.
То есть как только мы тело
оператора каста инстанцировали,
лобхол сет уже сработал.
И у нас все в нужный момент
происходит только за счет того,
что мы параметризировали этот
оператор каста
в куче шаблонов
и Т, и И, и еще и Тайпа.
Ладно, давайте
подумаем
преимуществами недостатки.
Вот я бы сказал, что это
самое лучшее решение.
Оно поддерживает все,
никаких костылей
просто идеально.
Ну, как никаких костылей.
Если древнюю магию
темную с призывом
ктулфу не считать
костылем, то это не используется.
Еще и быстро работает компиляция
здесь за вот единицы
получения каждого этого.
Ну и да, это могут пофиксить,
но шансы малы, поэтому
я предлагаю домашку либо вот этим способом делать,
либо следующим.
Вот прошлый лектор это решение
назвал хорошим,
но это зависит от вашего взгляда на жизнь.
Кто-то может назвать его
в десять раз хуже предыдущего,
это уже дело вкуса.
В семнадцатых плюсах добавили
вот такую штуку.
Стракчер к байндинге.
Знаете про них? Используйте.
Да.
Классная вещь.
Позволит ли они нам...
Великолепная. Что-что?
Великолепная вещь.
Позволит ли они нам вытащить
типы?
Да, что такое стракчер к байндинге?
Если value это агрегатный тип
tuple,
stdra, структурка,
в общем и целом любая штука,
которая понятна, как разбить
на несколько частей,
то ты можешь написать следующий синтаксец
через запятую
какие-то идентификаторы
в квадратных скобках.
Слева авто, справа равно value.
И оно тебе автоматом
разобьет value
на вот эти части.
Заметь, что здесь a, b и c
будут непеременными,
это будут
алиасами на обращение
к частям value.
То есть если value это tuple
из трех элементов,
a, b и c это будут
алиасы на std get 0,
std get 1, std get 2.
Если value это массив из трех элементов,
то a, b и c будут
алиасами на value 0,
value 1, value 2.
Или если value это структурка
из трех полей,
то a, b и c будут алиасами
на обращение к элементам этой структурки
через точку.
И можно писать
авто-амперсант, авто-два-амперсанда
и просто авто.
Соответственно, это будет влиять
на что-то.
Если честно, я забыл,
как конкретно это работает,
но с точностью до
деталей можно считать,
что мы объявили новую переменную,
которая либо ссылка,
либо копия, либо
rvalue-ссылка.
Но на деле это именно алиасы,
а не новые переменные.
То есть если вы запишете что-то в a,
оно определено как авто,
кажется, это вообще не сработает
и не скомпилируется.
Не уверен.
В общем, это все не важно.
Главное, что мы умеем структуру
по ее полям разбить.
Ну, мы знаем
количество элементов уже у структуры,
напишем через запятую столько
переменных, и вот их готово.
Мы вытащили типы.
Просто декл-тайп нужно вернуть.
Да.
И да.
К сожалению,
придется сделать так.
Пока что
structured-байндинги
не поддерживают развертку
паков
внутрь них.
Очень хочется, предложение в стандарт
есть, но пока что это не поддерживается.
Соответственно,
предлагается написать вот такую
кастыльную штуку.
Наверное, даже нагенерить ее
с помощью макросов.
Что здесь происходит?
Мы принимаем по ссылке структуру
типа T. Используем
наш метод для подсчета количества
полей. В compile-тайме
заметьте.
И дальше, с помощью
ifconstexpr, понимаем, сколько
элементов в structured-байндинг
нужно написать.
А дальше
мы можем вернуть
дюпл ссылок
на каждый из полей.
И это очень круто.
Потому что мы, во-первых, теперь знаем
тип каждого поля,
а во-вторых, еще можем по номеру,
что раньше анонсировалось,
записать в нужное
поле.
Есть ли вопросы по тому, как вот это работает?
Сейчас тут же
возможно
придется немножко
повоевать с тем, что
std-tie на всю ссылку навешивает?
Мы хотим вернуть
ссылки в этом идее.
Просто
если мы пытались
метаприковы делать,
то там придется руками срывать
постоянно. То есть тут была идея
еще и бесплатно получить
возможность по номеру поля
присваивать ему что-то.
И вот этот четвертый метод
бесплатно позволяет
это сделать.
ОК?
Думаю, что ОК.
Ну,
мне кажется, что вот эта
необходимость в копипасте для всех
размеров — это боль.
С другой стороны, как мы
уже уяснили,
аскел, скала,
fsh — все не стесняются
в пластичь 60 раз определение
тепла и
нормального. C-sharp тоже самое.
Возможно, и нам
это норм, обернуть в macros
и поехали.
Хотя я не уверен, как macros-ами нормально
через запятую нагенерить
нужное количество
structured-binding.
Думаю, это можно
сделать, но это уже
macros-ная магия, а в ней
я не эксперт.
Да, можно
лучше,
можно перегрузками.
Да,
как бы тут
диспетчеризация через теги идет.
Последний аргумент — вот этот sizeT
подчеркивание с чем-то
с числом в аргументах шаблона.
Это такой же тег
или valueTag, как мы видели уже много
раз.
И результат constexpr функции можно подставить
в шаблонный аргумент и дальше
диспетчеризироваться под тегу.
Это, возможно, чуть удобнее, чем
писать with constexpr.
В принципе, преимущества такие же, как у
предыдущего — это идеальное
с точки зрения пользователя решение.
Но как бы
тут вот опять, сколько нужно
этих,
для какого максимального
размера нам нужно наопределять.
Говорили когда-то, что 100
мегабайт — достаточно для любой задачи.
Ну вот как теперь?
Достаточно или нет?
100 — достаточно или нет?
А вдруг кто-то из джейсонов
генерирует структурки в плюсах,
а у них там нормальная тема — вообще
200? Не понятно.
Так что да.
Ну и остался последний пунктик.
Это, собственно, получить ссылку на поле
по индексу. Для четвертого подхода
со structured binding — это бесплатно.
Предыдущие три подхода
ничего в этом не говорят.
Поэтому мы должны придумать
отдельный костыль.
По сути, он сводится к тому, чтобы
скастить нашу структуру к теплу.
Ну, с рендермет кастить.
Конечно же, это undefined
behavior.
Ну и что тут происходит?
Мы опять получаем количество
полей.
Мы достаем
наши...
Вернее, не так. Мы
объявляем функцию
asTubl.
Ее через любой из предыдущих упомянутых
методов можно реализовать,
которая просто
делает
tubl с теми же элементами
как типы
полей у структурки.
То есть тут
на слайде, на самом деле, много визуального
шума.
Единственное, что важно, это что using tubl —
вот этот tubl, у него
типы элементов такие же, как
у полей в нашей структурке, в том же порядке.
Дальше
мы нашу структуру value
рендермет кастим к этому теплу
и делаем
другую индексу.
План надежный, как
швейцарские часы.
Одна проблема только.
Теплы иногда
компрессируют элементы.
Им это никто
стандартом не запретил.
То есть, как вы знаете,
есть некоторые требования к layout
структурок в стандарте.
Про выравнивание, паддинги,
прочие штуки.
И они для AsTubl
немного отличаются.
Соответственно,
вот этот рендермет каст
на каких-то компиляторах может сломаться и полететь.
Ну и, конечно же,
это UB.
Но нам
надо сделать свой tubl, чтобы
это точно работало.
Если мы сделаем
свой tubl, у которого
гарантированно так называемый
standard layout, то есть такой же layout,
как у структурок, то
мы в шоколаде.
Так.
К чему это было?
Да.
Tubl мы свой используем?
А. Есть
читерная попытка
избежать UB.
Что
если мы посчитаем,
вот все эти касты
к tubl как бы
проведем, но воображаем.
То есть,
выяснили tubl
и
выяснили
в этом tubl offset
интересующего нас элемента.
Да. Если у нас и структурка
tubl одинакового layout,
то offset
от начала структурки или tubl
у нужного индекса,
поля нужного индекса,
он будет одинаковым.
Соответственно, мы
выясняем
эти offset
достаточно
простым образом.
Берем DPL,
tubl, то бишь,
и берем get
tubl,
и разница
и будет offset.
Для этого нам, конечно, необходимо создать
пустой tubl соответствующего
типа.
Там уже давно
много слайдов назад было,
с tubl input возвращал
tubl с
такими же элементами, но пустой.
Он его не заполнял.
Вот. Как только этот offset
мы имеем,
мы можем
взять и применить такой же offset к
оригинальной структурке,
то есть скастить ее к чару,
предпоследняя строчка,
прибавить offset,
а
результатирующий offset
обратно зареинтерпреткастить
к нашему типу поля.
И вот тут уже как бы все хорошо,
вот этот реинтерпреткаст не является
UB.
Но при этом разыминование
этого указателя все
равно является UB.
Потому что в стандарте очень
хитрым образом вся эта вещь прописана.
Важно не только
куда указывает указатель,
а откуда вы его получили.
И вот указатель, который вы
получили нелегально, он все равно
вас будет, как бы
все равно приведет к UB.
Если вы когда-нибудь слышали
об std-london,
вот там похожая проблема.
Компилятор помнит,
откуда вы притащили этот указатель,
и помнит, что вы нашалили
akata и pantyfan behavior.
Ну, конечно, по факту ни один компилятор
этого не помнит.
И это помнит только
виртуальная машина C++,
которая описывается в стандарте
мифическое.
И это решение по факту
работ. Есть такая библиотека
boost.pfr.
В ней реализовано
ровно это. То, что мы вот здесь
сейчас с вами обсуждали.
И получение
по индексу указателя
вот именно этот метод,
а получение самих
типов я забыл.
Вот.
Как-то так.
Кажется, мы
дошли до конца
презентации.
Мой голос умирает.
Но это успех.
150 слайдеров.
Да, про вот эти вот хаки
с рендер-бредкастами. Есть ли какие-то вопросы?
Видимо, нет.
Надо собраться с мыслями.
В принципе, у нас еще есть
некоторое время.
Давайте попробуем
пошалить.
Мы
Ну, вернее, я
попишу код,
потому что
тут непонятно,
какой код писать.
Да, лучше
это.
Так.
Это все не то.
Спасибо, Силлайн.
Спасибо, Силлайн.
Так.
Наверное, мы начнем
отсюда.
Потому что тут уже
нужный код
определен.
Да.
Тут уже, в принципе, есть
все, что вам нужно.
Вот кейкзампус для
выполнения DZ
с помощью вот этого
читерного, хитрого метода.
Давайте лучше
поиграемся с самим
юбиком.
Вернее, с самим фолом.
Нет, стоп.
Да, нет.
Да, нет.
Вот.
Вот отсюда начинается
фол.
Значит, вот это нас не интересует сейчас.
И
вот это нас сейчас не
интересует.
Ладно, нас ничего не интересует.
Пусть все это будет закомменчено.
Все равно коммитить то, что сейчас напишу,
не буду. Тут уже достаточно
адекватный фигмент.
Например, закоммитчено.
Да,
как мы поняли,
вот эта пара аргументов выступает
своего рода
ключами.
Вот это F,
который мы возвращаем
из лупхола в итоге.
Вернее,
экземпляр, который мы возвращаем
и в итоге превращаем автор в нее,
служит значением.
В каком-то смысле это такая
мутабельная мапа
в компиляторе.
Давайте
попробуем сделать вот что.
Попробуем написать
constexpr функцию
которая возвращает
каждый раз число на один больше.
То есть счетчик.
constexpr.
Какая будет общая идея?
Ну, сейчас я убрал отсюда
второй аргумент, и сейчас у нас есть
просто мапчик
из идутов
в класс.
Вернее, даже не так.
В maybe класс.
То есть
изначально, когда мы вот это
не инстанцировали,
соответствующий счет ни во что
не отображается.
Как только инстанцировали,
отображается.
Давайте попробуем
научиться детектить,
отображается ли во что-то
конкретный общий
идут.
Общая идея будет
какова?
Использовать
Sphinae либо
Constraint.
Тут
были некоторые проблемы
с тем, что Sphinae работает
чутка по-другому.
Но мне кажется, нам сейчас удастся
достать и отработать на Constraint.
А...
Давайте попробуем
объявить
следующую constexpr
функцию.
constexpr bool is set
для соответствующего int.
Она будет
требоваться,
чтобы
loophole от
тега attend
был определен.
И эта перегрузка
будет возвращать
true.
Соответственно, будет
и вторая перегрузка, которая уже
ничего не требует
и возвращает false.
Пока что ничего сложного.
Все очень понятно.
Да, конечно же,
я вот так хочу сделать.
Давайте
попробуем, сработает ли это.
Сейчас
по умолчанию loophole не для кого,
конечно же,
не установлен.
И мы попробуем сделать
static assert
на то, что
is set 0.
А не is set o.
По дефолту работает.
То есть, вот эта перегрузка
отбрасывается,
мы идем в эту.
Окей.
И мы инстанцируем
loophole set
с 0,
но не важно чем.
Попробуем теперь
за static assert, что is set.
Да, так мы, конечно, ничего не поймем.
Нам нужен
loophole ubic, мы хотим его забилдить.
И ничего не вышло.
Интересно, почему
возможно,
из-за порядка компиляции
мы сделаем вот так.
Кажется,
это сработало.
А до, оно должно
выдать ошибку компиляции.
Действительно.
Да.
То есть, до
loophole set
вызов loophole не компилируется,
после компилируется.
А я знаю, почему у нас
ничего не сработало.
Потому что для 0
мы уже
инстанцировали,
так сказать.
Вернее, мы уже нашли
перегрузку, которая нас интересует.
Вот эту.
И вот этому даже не пытаемся инстанцировать.
Кажется.
Давайте
вспомним, что в самом начале
разговора про темную магию.
Вспомним, что в самом начале
разговора про темную магию.
Мы добавим вот такую штуку.
Тем самым
заставив компилятор
каждый раз заново искать инстанциацию.
Так.
Хоба.
Ничего не получилось.
Какая новость.
Если у кого-то есть предположения,
обязательно о них скажите.
Занимаясь черной магией,
такое бывает, что
ничего не работает, непонятно, почему.
Давайте подклетим, что ли?
В подсказке используется
SFINAE.
В подсказке используется
SFINAE.
В подсказке используется
SFINAE.
В подсказке используется SFINAE.
В подсказке используется SFINAE.
Делаем это.
Сфинаэв,
смартфон.
Сфинаэв,
смартфон.
Штант.
Штант.
Штант.
Штант.
Штант.
Штант.
Штант.
посмотрим хоть немного. да, хорошая идея. я примерно тем же занимался пару дней назад,
но в другом проекте, который я вам показывать не могу, потому что там планы длиннейших домашек,
а внезапно это работает. ну, в общем, кажется проблема в том, что оно считает вот эту
перегрузку более приоритетной, и вот эту даже не пытается рассматривать. да, соответственно,
давайте как-то навяжем компилятору, чтобы вот эта перегрузка была более приоритетной. я предлагаю
это сделать так. сюда принять int, сюда принять float. теперь и set нужно вызывать от аргумента,
причем именно от 0, вот именно от литерала 0. почему это сработает? вот эта перегрузка принимает
на вход int, а 0 это int, и не нужна implicit cast, поэтому эта перегрузка более приоритетна,
если доступны обе из них. да, для флота нужно за implicit cast, поэтому float откидывает. и теперь оно
кажется... да чтоб его... ну хорошо, хорошо, убедили. давайте уберем вот это и посмотрим,
почему оно не хочет убирать вторую перегрузку. теперь хочет. кажется, мы все еще не избавились от
вот этого каширования результаты инстанциации. вот вообще это каширование, насколько я помню,
в 8 гцц когда появилось, оно поломало очень многие реализации constexpr счетчика. нет, тут все
работало. я просто помню, что была такая история, когда я интересовался этой темой,
и по итогу пришлось просто искать запрос constexpr счетчика, работать в гцц8. нет, я на выходных
написал код, который работал в планк 13 и гцц10. все нормально. мое уважение. вопрос только,
как я это сделал. давайте попробуем последовать примеру прошлогодним.
и вот эту штуку кинуть сюда. да, инстанцировать будем зубовым. даже больше? нет, ладно,
допустим, так и останется. что он скажет? все равно failed.
вопрос. он скомпилится или constexpr-каунтер прошлогодний? а он скомпилился. давайте сравнивать.
окей, я кажется понял. вот эта тема не работает. нам нужно сюда принимать авто и каждый раз
его указывать заново. давайте напишем wrapper. вот такой.
и возможно теперь это сработает.
да.
нет.
есть некая очень тонкая комбинация. есть очень тонкая комбинация параметров,
которая позволяет этому работать. ладно, давайте посмотрим, какой у меня компилятор включен.
пробуем много�иться.
и там
а не указывали ли тут явно нет да указывали это и так был гсс а если накладки
черт
не на самом деле это очень сильно удивляет
а констекс про каунтер а стоп кажется не нажал это так
констекс про каунтер на клавиа работает
о
Ох!
Ну, давайте тогда просто прочитаем код констект не imagine.counter,
почему-то абсолютно аналогичный код здесь почему-то не работает ok ну тут все то же самое тот же самый
луп холл только мы теперь ничего не устанавливаем и просто его определяем кстати тут уже прописан был
это не должно работать
но возможно именно в этом и отличия что здесь була там авто это немножко по-разному работающие
механизмы взлома компилятора но поинт тот же пока мы не инстанцировали в райтор луп холл не
определен и вызываться не будет странно
во во важный поинт вот если вот так сделать и попытаться сделать requires я вот здесь написал
когда-то раньше да то это работать не будет вот этот requires скажет вам ок даже если у
вас просто определена объявлена функция но не определена и чтобы вот с таким requires оно
работало важно именно авто здесь использовать в этом же примере используется был но при этом
мы не просто requires пихаем эту штуку мы требуем ее значение посчитать результат и записать в
шаблонный аргумент ну чуть подробнее что именно мы требуем как именно пойдем с класса
рида ридер запускается рекурсивно он начинает всегда с нуля это именно счетчик рекурсии и
всегда увеличивается также вешка есть но она просто прокидывается насквозь именно чтобы
каширование избежать да это вот опять вот это лямбда чертова и здесь она чем-то работает не
работает фаза лумы не совпало вот но в какой момент обрубится рекурсия в момент когда вот
эта штука приведет к ошибке это будет имидиат контекст для этого шаблона так называемо поэтому
произойдет с финайя то есть с финайи здесь не в том что флоп холл не объявлен он объявлен в том
что нереализован и поэтому вычислить его значение для того чтобы присвоить этому дефолтному
аргумент не выйдет произойдет ошибка подстановки и мы улетим вот в эту штуку в ридер уже от флота
да тут видите опять трюк используется чтобы приоритизировать вот это вот интерфлот но как
только мы сюда улетели мы запустим райтор который собственно лоб холл сет тоже самое да и он
соответствующий ячейку соответствующий номер напишет себя как бы это выглядит странно но на
самом деле тут два шага первое мы инстанцируем брайтер от это это создаст функцию холл а также
это н позволит вернуть наружу вот почему именно так пропустить надо не знаю и в итоге из всей
этой рекурсии вернется первая н при котором еще не был объявлен лоб холл а также лоб холл станет
объявлен для этого то бишь когда мы для нулевого запустим оно сразу провалится сюда объявит лоб
холл для нуля и вернет ноль в следующий раз когда мы запустим мэкс где нуля уже был объявлен
лоб холл и ну то есть мэкс просто ридер от нуля запускает да это сейчас мы туда не посмотрели пока
не суть важно в следующий раз когда мы ридер от нуля запустим он увидит что глуп холл для нуля
есть выберется вот это специально вот эта перегрузка она пойдет рекурсивно и уже теперь
провалится в первую и для единички мы тоже поставим лоб холл и вернем единичку и так далее
то есть такая последовательность флажков каждый из которых устанавливается последовательно
когда мы до него доходим и в итоге мы умеем в констекспере получать а б и ц если запустим
а б и ц разные 0 1 2 магия
мне все-таки интересно может кому-то удастся почувствовать потому что их иного
способа не почему не работает вот эта штука вероятно я знаю почему вероятно не знаю
я бы попробовал следующий брать вот это
брать вот это и здесь теперь трубу возвращать а вот здесь именно что вызывает лоб холл
интересно почему оно пытается определить имя может это из-за того что я уже тут кодом
все не пытается отлично
да но это у нас не имидиат контекст никакого с финэ не произойдет все еще нужно вот это
холл сад сломался а да мы теперь не хотим
так
окей кажется оно действительно должно быть помечен констекспер да слушайте скорее всего
из-за этого все не работала да я тут начал придумать какие-то танцы с бубном просто
true но пол оба все 2 3 потом такие
опа да кстати на вопрос что будет что будет если два раза сделать сет кажется ничего он
просто два раза сетнусь ну вернее что это значит сет происходит при инстанциации лоб холл сета
если мы второй раз такой же лоб холл сет используем по инстанциации это уже есть по
форме инстанциации не будет а вот если ее заинфорсить с помощью лямб лучше об этом не думать
но на самом деле это не сработает потому что если мы сюда еще лямб до запихнем чтобы запретить
кеширование инстанциации это будет уже другой слот то есть мы даже гет не сможем сделать так
что да не так все просто кажется а нет сможем слушать
3 definition вот все то есть когда мы в двух разных инстанциациях сделаем то это будет
3 definition все сломается а так работает и теперь мы можем засердцить что ну например сначала
установить третий и он будет установлен правда колдовство
я даже могу обернуть лоб холл сет функцию
да каунтер мы уже разобрали не интересно
кажется вот так
вот по моему это идеальная вертка теперь это выглядит даже читаем я бы сказал если учитывать
то что мы здесь делаем просто сет и сет но возвращает констекспробул другое устанавливает
плак то есть если вы покажете этот код невинному человеку он сперва может и не понять что-то
происходит да ну что какие-то глобальные перемены устанавливать ассерты до статик статик ассерты
одно и то же выражение разные моменты времени разный результат жесть вот и в общем на этом
все можно если это еще и с макросами скрестить сделать аналог скопов из раз-то там
ну или приизвестим у всем антику в каком-то смысле но мне не удалось добить эту идею до
конца а здесь кажется никто раз там не увлекается поэтому давайте наверное на этом закончим я
очень рекомендую поиграться еще с этой темой это очень весело но хоть и опасно для здоровья
наверное все-таки это за коммичу
как только это все
скоммичу в таком виде если захотите раскоммитить те и
что здесь было раньше в общем ладно на этом все
надеюсь вы испытали катарсис чуть-чуть домашку выложу через часик скоммичу тоже через часик
и ну запись тоже будет выложена но всего что в папке сам экземплу вам должно хватить чтобы
пришли домашку если у кого больше нет никаких вопросов то всем спасибо всем пока
