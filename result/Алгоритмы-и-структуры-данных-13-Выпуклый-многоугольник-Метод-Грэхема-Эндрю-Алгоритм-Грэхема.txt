Ну да, в общем-то да, мы подошли с вами, на самом деле, к заданию,
к каким-то выпуклостям, хотя там по-разному, потому
что следующая задача, которую у меня тут по списку мы
должны с вами обсуждать, это конечно задача лежит
ли точка в многоугольнике.
Ну начнем с невыпуклого случая.
Так, все, пишем, да?
Пишем?
Хорошо, отлично.
Так, замечательно, пойдемте.
Давайте начнем с экзотического невыпуклого случая, нарисуем
тут какую-нибудь гадость.
Да, это не, ну, я думаю, очевидно, да, не выпукло, это многоугольник
я рисую.
Да, да, да, да, да, если вот в этом месте угол будет
не такой, да, сразу перездача, да, да, да, конечно, так,
так, значит, вот, и вот задача, там, дана точка, скажите,
пожалуйста, лежит ли точка в многоугольнике?
А, то есть, у меня не пусто, хотя вы теперь, явно, что
если еще чуть-чуть нарисовать, вам будет даже на картинке
не очевидно.
Вон туда, там, где у вас вот эти вот, да, да, они очевидны.
Да, тогда вот где-то туда, вот, а, ну, да, в данном случае
просто это канал выхода очевиден, да, да, да, да,
ну, окей, хорошо.
Ну, теперь давайте к этому проскакать, решать такую
задачу.
Берем, делаем граф, делаем все точки, делаем все точки,
короче, очень маленькие, которые, вот, и по этой сеточке
делаем DFS, соответственно, если DFS вышел, значит, лежит,
если не вышел, значит, лежит.
Ну, да, да, да, да, да, да, от создателя.
Сколько, сколько мест в этом зале?
847 тысяч на 10 минус 3, да, примерно, видимо, из этого
же разряда ответ, конечно, да, вот, да, окей.
Ну, конечно, классический метод, на самом деле, немножко
другой.
Классический метод называется, а давайте проведем куда-нибудь
лучик и тупо посчитаем, сколько раз этот лучик пересекчет
в многоугольник.
Типа, нет, ну, на уровне идей как бы кайф, потому что
если пересекчет не счетное число раз, значит, мы находимся
в многоугольнике, если счетное, значит, мы вне многоугольника,
все просто.
По модулю одной гадости.
Гадость называется, а что, если луч случайно пересекчет
там попало, прошел через вершину?
Ведь, действительно, у нас же бывают там всякие подлые
или вот такие, или вот такие еще бывают.
Или там вообще вот это вот безобразие все бывает.
Вот, и теперь давайте вот немножко подумаем, как
решать эту проблему.
Просто очень много разных способов, на самом деле,
есть.
Потому что, ну, по-разному.
Ну, как бы, если мы верим в добы, то можно, конечно,
привести просто рандомный луч и сделать еще и надежное
решение в духе, если луч случайно прошел через
вершину, значит, генерируем еще один луч, и так пока
нам не повезет.
А, в общем-то, повезти нам должно с вероятностью
один, на самом деле.
Вот.
Ну, как вы знаете, вероятность, да, повезет с вероятостью
там, то есть нам не везет с вероятостью ноль.
Это не значит, что нам не везет совсем.
Да.
Ну, вы уже там люди грамотные, собственно, это знаете.
Вот.
Ну, а единственная проблема, что это, конечно, в каких-то
и, то есть это надо там в идеальных доблах с какой-то
идеальной точностью.
Хочется как-то решать задачу абсолютно точно.
Что можно сделать?
Можно, по идее, провести луч из 0,0 в бесконечность.
Да.
Да.
Ну, действительно.
Во-первых, классический метод, что если многоугольник
целочисленный, то, на самом деле, если у вас тут точка
x, y, то можно провести луч, ну ладно, раз я тут вниз провел,
в точку, я не знаю там, бесконечность и y, ну скажем, минус 1.
Чем приятен луч, тем, что между этими двумя точками
целых точек нету, ну точно нету.
То есть в олимпиадом программировании почти, наверное, вот такой
метод просто будет работать.
Бесконечность, видимо, должна быть простым числом.
Ну, нет, зачем просты?
Не, абсолютно не обязательно.
Победа зачетается не в том, что это простое число,
а в том, что у вас вот эта точка и эта точка лежат
на соседних горизонталих целых.
Вот.
То есть поэтому тут по барабану.
Надо, чтобы этот инф был как бы правее на самом деле
всего многоугольника и правее вот этого x еще, кстати, важно.
Проблема только, что нужно это проверять пересечение квадратно.
Нет, ну мы уже с вами в прошлый раз обсуждали, как проверить,
там пересекаются ли отрезок и отрезок.
Ну если так, то да.
Ну да, но обычно это...
Но проверить, даны два отрезка, надо в целых числах
проверить, пересекаются ли они да или нет.
А это зачем нам?
Ну нам же надо проверять.
Ну метод-то не изменился.
Да, метод не изменился, он все еще за линию работы.
Что еще можно сделать?
Ну еще есть, вот я в своей научной работе столкнулся,
еще есть ситуация, что делать, если у вас тоже,
то есть точки находятся, то есть точки не целочисленные,
но все-таки они находятся в каком-то поле,
которое абсолютно, там значение, которое абсолютно точно вычисляются,
ну типа a плюс b корней из 2, a и b рациональные числа,
там с произвольной длинкой.
Да, и что в таком случае можно сделать?
Вот как в этом случае бы решить задачу абсолютно точно?
Ну здесь идея такая.
Значит лично у меня такая идея.
Значит проведем, так давайте я нормальный маркер возьму.
Значит проведем горизонтальный луч вправо,
но наша задача провести не горизонтальный луч вправо,
а луч чуть-чуть-чуть-чуть выше.
Что такое чуть выше?
Я просто провожу тут все лучи во все вершины,
которые тут выше, и выбираю из этих лучей самые низкие,
то есть тот, у кого тут угол поменьше.
Ну сравнивая их, естественно, не вычисляя в явном виде угол,
вот подчеркиваю, боже упаси, да,
то есть тут почти всегда, если вам требуется прямо в даблах вычислить угол,
то значит ваше решение пошло куда-то не туда,
потому что крайне редко это нужно, реально.
Но самое главное, то есть проверяйте, кто из них там ближе,
можно просто с помощью векторного произведения,
который вычисляется в целых числах, ну или в том же поле.
Это понятно, о чем я говорю, да?
Так вот, выбираем самый низкий идущий луч,
вот он идет в эту вершину, а мы идем тут в эту вершину,
и теперь надо просто провести любой луч, который находится между ними.
Ну можно, в принципе, даже бисектрису провести,
но я не уверен, правда, что она прямо в том же поле уместится,
но это нам и не нужно,
потому что, на самом деле, если вы просто сложите вот эти два вектора,
вот такой прелограммчик, то, в общем-то, диагонолог,
то, в общем-то, вот вам и направляющий вектор для этого луча между ними.
Вот, в принципе, еще вот таким вот образом можно,
это тоже будет достаточно надежно работать.
Так, что еще можно?
Есть еще, конечно, такой экстраварантный метод.
Есть еще такое, давайте проведем луч вниз.
Но какие могут быть проблемы?
Нам может не нравиться, что тут у нас могут быть точки,
а давайте применим ко всей этой картинке афинное преобразование.
Так, знаете, что это такое?
Ну, идея такая.
Значит, смотрите, каждую точку можно...
Ну, смотрите, у нас на плоскости есть какой-то базис.
Вот давайте я так на пальцах покажу,
и каждая точка, на самом деле, имеет типа вот это умножить,
то есть вот этот вектор умножить на х,
и вот этот плюс вот этот вектор умножить на х, правильно?
Так вот, давайте попробуем...
Что значит применить афинное преобразование?
В моей интерпретации это сделать так.
Давайте нарисуем абсолютно те же точки, но вот этот базисный вектор,
подменим на вот какой-нибудь вот такой.
То есть по сути мы эту картинку вот так вот перекорежем.
Но если мы сделаем этот вектор,
он пойдет достаточно вправо,
то у нас там никакие две точки, на самом деле,
на одной вертикали уже не попадут.
И тогда после этого можно уже спокойно в полученной картинке опускать луч.
Да, но очевидно, что при таком афинном преобразовании
то, что было внутри, останется внутри, там останется снаружи и так далее.
Там есть много замечательных свойств всяких афинных преобразований.
Нет, странно, что у вас не было.
Где-то у вас должно было это быть.
Странно.
Ну ладно.
Это немножко может быть экзотично.
Но на самом деле есть, конечно, веселый практический способ,
который говорит так.
Вот смотрите, у нас была проблема, что вершины могут попадать на луч.
И на самом деле, если у нас есть проблема,
то есть два способа работы с ней.
Первый способ, вот мы тут исследовали,
это давайте пытаться этой проблемы всеми правдами и неправдами избегать.
Ну мы, в принципе, три неправды придумали.
Но на самом деле предлагается и другой подход.
Давайте посмотрим в глаза этой проблеме и подумаем,
а сильна ли вообще большая эта проблема?
На самом деле, если вдуматься,
может, на самом деле проблема не так страшна?
И оказывается, действительно, что оказывается, есть очень красивая идея.
Решение я тут не случайно нарисовал почти все возможные...
Нарисовал тут все возможные случаи пересечения.
Так вот, на самом деле, идея оказывается такая.
То есть мы по-прежнему перебираем все отрезочки.
Для каждого отрезочка проверяем, пересекает ли этот отрезок луч,
то есть имеет ли одну общую точку.
Но теперь идея такая.
Если он пересекает, то его нужно учитывать не всегда.
Учитывать как?
Понятно, что мы считаем количество отрезков,
которые у нас пересекли луч, и меряем четность.
Так вот, идея в том, что надо учитывать не все отрезочки.
А надо учитывать только такие отрезочки x1, y1, x2, y2.
Такие что, внимание, я провел не просто прямую,
а просто горизонтальную прямую.
Это точка x, y.
Я провел горизонтальную прямую, идущую, допустим, вправо.
Так вот, надо учитывать те и только те отрезки, у которых...
у которых, смотрите, например,
минимум из y1, y2 меньше либо равен y,
меньше, строго максимума из y1, y2.
Не самая плохая формула, правда?
То есть более того, этот метод на самом деле еще хорош тем,
что, возможно, он будет неплох по константе.
Вот.
Ну, то есть, видимо, для кого это векторное произведение?
То есть вам на самом деле проверить,
если у вас есть задача, пересекает ли отрезок горизонтальный луч.
Вам нужно проверить, во-первых, пересекает ли этот отрезок вот эту горизонталь,
то есть выполняются ли какие-то вот такие условия.
Ну, а если выполняется, то с помощью какого-нибудь одного
видимо векторного произведения вы можете проверить,
эта точка лежит с нужной стороны или нет.
А учитывая, что мы там, когда у нас несколько отрезков проверяли
на пересечение, у нас там возникали,
как там, по-моему, то ли два, то ли даже четыре векторных произведений.
Поэтому этот метод действительно хороший именно константой.
Нет.
Ну, чтобы просто проверить, вот данный отрезок, скажите, пожалуйста,
пересекает ли этот отрезок луч.
То есть он пересекает или он находится вот с этой стороны, например?
Ну, в смысле, вот это мы умеем как-то делать.
А почему нам нужно было какое-то произведение еще кроме?
Ну, потому что раньше мы говорили так.
То есть у нас была задача, даны два отрезка, пересекаются ли они.
На прошлом занятии мы решали эту задачу с помощью четырех векторных произведений.
Ну, если прям в общем ее решать.
А здесь заметим, что у нас есть два отрезка,
которые пересекаются с этой стороны.
Ну, если прям в общем ее решать.
А здесь заметим, что здесь вместо этих четырех
можно убрать эти четыре и оставить только одно максимум.
Потому что мы здесь пользуемся тем,
что мы пересекаем отрезок не просто с рандомным отрезком,
а с горизонталью.
Игрок равно чего-то.
Поэтому на самом деле что нам надо делать?
Нам надо проверить, например, вот это условие.
И если это условие выполнено,
то тогда нам надо просто мысленно направить отрезок снизу вверх
и после этого с помощью одного векторного произведения проверить.
Верно ли, что Х игрок лежит слева от него?
Вот. То есть получается вместо четырех векторных произведений одно.
Вот.
Но остается только маленькая проблемка.
Надо, правда, убедиться, что это условие вообще работает.
А то как-то читерство,
потому что у нас тут куча случаев, их как-то надо разбирать,
но утверждается, что все эти случаи,
вот это условие прекрасно кушает вот ровно в этом виде.
Ну да, давайте пройдемся по этой картинке.
Ну, во-первых, самый простой случай,
когда отрезок просто пересекает луч,
я думаю, сомнения не вызывает.
Так, дальше.
Смотрите, вот этот случай.
Смотрите, ну это вот один из самых сложных.
Тогда смотрите.
Этот отрезок мы учли,
этот отрезок мы не учли,
потому что здесь вот тут будет равенство.
А этот отрезок учли.
Получается суммарно,
то есть этот заворот мы не учли и правильно сделали.
Так.
Ну, кстати, абсолютно аналогично,
кстати, рассматривается и вот этот случай.
А теперь давайте рассмотрим то же самое снизу.
Снизу, да, этот мы случай не учли,
но теперь легко заметить, что мы и эти два тоже не учли.
То есть разница, то есть тут два учли, тут два не учли,
но ссор одинаковый.
Вот.
Что у нас в этом углу?
Ну, тоже ничего не учли.
Да, красивый случай, конечно, вот такой.
Здесь оказывается, что мы вот этот случай,
вот такой.
Здесь оказывается, что мы вот это учтем,
а это нет.
Видно, да?
Так, ну и остается только вот эти случаи,
но они по сути одинаковые,
когда это не учитываем, это не учитываем, это учитываем.
Кайф.
То есть вот такой, на самом деле,
здесь вот очень красивый метод.
В принципе...
На самом деле можно заметить, что это то же самое,
если бы мы подняли нашу прямую на эпсилон вверх,
и тогда бы это было прям честное условие.
Да, да, абсолютно правильно.
То есть на самом деле, да, это...
То есть на самом деле просто идентично тому,
что действительно мы бы могли поднять этот лучик интуитивно
вот на, соответственно, вверх,
на прям очень-очень-очень-очень-очень-очень-очень-очень маленький эпсилон.
Да.
Когда принадлежность не поменялась и...
Ну, правда, практически не поменялась, да.
Да, нет, то есть мы чуть-чуть лучик поднимем,
если мы совсем чуть-чуть поднимем,
то лучик не будет пересекать никакую вершину заведомо.
Не будет пересекать вершину, и...
Да, а пересекать отрезки будут ровно те, которые мы здесь будем учитывать.
Ну да, и принадлежность той точки нашей не поменяется.
Ну, типа да, да, да.
Да.
Тут важный момент, сейчас или неважный.
Угу.
Ну, смотри, если бы у меня точка лежала строго на стороне,
то от поднятия чуть-чуть вверх она бы стала лежать внутри,
от поднятия чуть-чуть вниз,
стала бы лежать снаружи.
Нет, вот тут просто...
Потому что мы проверяем на принадлежность не точку x, y,
а точку x, y плюс эпсилон, которую мы подняли.
А, все.
Не, ну нет, эту вот точку мы не поднимали, если что.
В нашем способе проверки мы сейчас...
Нет, мы подняли не ее,
мы как бы провели горизонтальный луч,
и этот горизонтальный луч чуть-чуть выше подняли.
Да, на горизонтальный луч он проходит не через точку x, y,
а через точку x, y, и эпсилон.
Не, не, в смысле правый край.
А, ты так мысляшь?
Нет, я мыслял по-другому.
Я мыслял, что точка x, y осталась,
но мы просто луч чуть-чуть приподняли.
А в плане угол?
Да.
А, ну где нет, я мыслял, что параллельно.
А, ну да.
А, ну хорошо, да, можно мыслить и так.
Что-то давайте точку чуть-чуть приподнимем.
предполагает, что она не лежит на границе. Да, но понятно, что тут можно чуть-чуть поднять так,
чтобы ее принадлежность к многоугольнику не поменялась. Ну можно и так, пожалуйста. Так что вот
такая вот красота. Идейное доказательство такое, но это приводит к очень красивой реализации,
а константа, как выясняется, важна. Потому что, как выясняется, вон тут тарир. То есть, конечно,
сложно было ожидать от пасковского четвертинала, чтобы подсунуть задачу, где решение с правильной
сим-тотикой может работать от 5 до 20 секунд, конечно. Хотя рекорд, там, по-моему, Итмоз дала,
там какая-то команда Итмоз дала эту задачу, кстати, с 1.7. Прога, конечно. Там подлая задача
оказалась. Там была задача в том числе на то, чтобы ее правильно написать.
Ну вот, что делать, подло. Ну что делать? Что делать тогда? Как бы в концерте у нас олимпиады не
только по математике, но и по программированию. Ну да, ну да. На самом деле правильно. На прошлом
полуфинале, а на позже вообще надо было Хишберга писать. Ну и правильно. Нет, ну на самом деле
правильно. В общем-то, Хишберг вещь такая, которую полезно уже знать. Ну это уже другой вопрос. Ну вот,
вот ребята ЦС дали. Это уже прошлое. Надеюсь, просто отмечаем, что есть такое красивое решение,
с такой красивой константой. Вот, ну а теперь мы переходим к выпуклым многоугольникам. Да,
ну вообще, я думаю, у нас вообще, по-моему, сегодня практически все занятие будет посвящено выпуклости.
Там в самых разных ее проявлениях. Да, ну для этого просто, поэтому можно даже для фундаментальности
даже просто задаться уже просто прямым вопросом. А что такое вообще выпуклость? Вот давайте так. Что
такое вообще выпуклая фигура? Теорема, что относительно каждого отрезка. Ой, какого отрезка? А если фигуры
не многоугольник? Вот просто, не, глобально. Вот если вы хотите доказать, что многоугольник выпуклый,
тогда и только тогда, когда у него там что-то. Так, еще раз, полуплоскость. Так.
Ну вроде, ну по моему определению, да. Вот, ну по определению маклога, короче, там ломается. Да. А что,
а что вам говорили на маклоге? Можно отделить от друга прямой, не пересекающийся. Если я возьму такую же снизу
и справа, только не включая точку. А фигура там не подразделала, что она замкнутая? Ну, в условии не было написано,
когда мы вчера себя обсудили. Ну, короче, ну по этому примеру. Да-да-да. Тут возникает вопрос, каким
определением выпуклости вы пользовались в маклоге? Нам не давали определение, нам дали задачу в билет,
а нет, ну тогда, нет, просто непонятно, что такое выпуклая фигура. Нет, в нашем-то случае мы пойдем просто,
то есть мы скажем, что фигура, даже не фигура, а просто множество, просто под множество точек на
плоскости, хотя на самом деле и в пространстве там, и где угодно. Значит, выпукло, будем говорить,
если для любой точки P1 и P2, лежащих, правда, не на R2, а в A, а в множестве A, верно, что отрезок
P1-P2 лежит в A просто как под множество точек. То есть на самом деле вот таково официальное
определение выпуклости, которое можно вводить практически там в любых адекватных пространствах,
вправивается.
Вот, ну значит, тогда, да, ну здесь автоматически, конечно, возникают маленькие приятные свойства.
Какие? Например, ну например, мистическое утверждение, если там A1 и A2 выпуклы, то, конечно же,
A1 пересеченное со 2 выпукло. Более того, на самом деле я могу пересечь, ну отсюда очевидно,
что я могу пересечь 3-4 сколько угодно выпуклых множества, но фишка в том, что я могу на самом
деле пересечь любое количество множество, даже несчетное. То есть там можно даже просто
такую теорему, то есть пусть, там пусть ИТЬ, да, пусть ИТЬ это набор выпуклых множеств каких-то.
Ну вот, тогда пересечение всех этих множеств, то есть пересечение всех А, которые лежат в ИТЬ,
выпукло. Выпуклый множество, компактный класт, так? Ну, смотря что такое компактный.
Типа, если пересечение, короче, пересечение пусто, только если какой-то префикс пересечения пусто.
Ну, короче, если у нас есть последовательство выложенных множеств, и пересечение какого префикса не пусто, то есть...
Ой, ну я так не готов комментировать, что я помню, что там 4 эквивалентных определения какие-то были,
в разных пространствах. Ну, потом вас это все на фонконе еще ждет, на самом деле. Сразу предупреждаю,
поэтому я тут лучше словам типа компактности отношусь очень аккуратно. Ну вот, ну не важно.
Так вот, внимание, внимание. То есть да, ну как доказывать это утверждение? Ну, в общем-то из
определения легко следует, что если какие-то две точки лежат в пересечении, то эти две точки лежат в
каждом из этих ножет, значит, отрезок лежит в каждом из этих ножет, значит, отрезок лежит в пересечении, ура, пересечение выпукло.
Так. Ну, прям на хор сразу. Не, ну на хор у нас посложнее чуть-чуть будет. Там конверт с халтриг какой-нибудь там, да.
А вот вопрос, а что делать с объединением выпуклых ножет? Да, не поможет. Потому что оказывается,
что если вы объедините вот такую параболку, ну можно, да. Ну скажем так, знаете, вот этот
пример может быть чуть более показателен. То есть давайте вот такие две параболки объединим,
и их объединение очевидно не выпукло. Что? Да. Ну оказывается, если шляпка гриба выпуклая множество,
ножка гриба выпуклая множество, их объединение не очень. Да, вот так себе это можно вообразить.
Ну как минимум, а, ну как минимум, потому что существуют вот эти вот две точки объединения.
Пересечение выпукло, объединение нет. Это вот важный, это важный принцип. Вот, ну здесь действительно
можно дальше много действительно вводить. Но давайте начнем такую разминку. Дан многоугольник,
скажите, пожалуйста, выпуклый ли он? Да или нет? Ну, относительно каждого ребра. Может считать,
что знаки все в определении одинаковые. Так, ну здесь, нет, ну здесь это может быть достаточно опасным,
потому что в принципе, да, хочется сказать, что, потому что стандартное определение в школьной
геометрии многоугольник выпуклый, если он, если там через каждую сторону можно провести там
прямую и окажется, что многоугольник с одной стороны от нее лежит. Нет, это да, ну просто,
нет, я просто опасаюсь, что просто проблема будет в том, что звать теперь сести вот из
этого определения это доказать, что это верно вообще. Ага, как говорится, осталось только выяснить,
каким образом. Да, где было год назад? Выправленно ли это доказывали? Тут? Да. А в этом нет,
с предыдущей группой доказывали, это да. Нет, это конечно наглое читерство в своей стороны,
да, все, что рассказывал предыдущая группа вы, очевидно, знаете, поэтому это все будет на
экзамене, понятно, но мы с вами на этом на лекции время тратить не будем. Поэтому давайте переходим
дальше. Итак, с чего начнем? Ну, давайте изучим, например, как строить миностов с помощью там софт
хипа или там какие там еще красивые вещи. А, ну, конечно же, как искать кратчайшее расстояние в графизове
плюс Е, там, естественно, там продвинутые, там современные алгоритмы поиска потока, там,
да, давайте, вот это вот все, а эти все мелочи, в общем-то, это, да, да, да, да, мечта, мечта,
а что? Нет, ну, вариант, конечно, да. Да, действительно, все время, действительно, в последнее время ко мне
приходят все более и более продвинутые студенты. Нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет,
нет, нет, нет, нет, нет, нет.
А как же это показать? А на самом деле вот как. Так, давайте ориентируем многоугольник против часовой стрелки.
Вот, а мы с вами уже в прошлый раз, кстати, научились это делать. Вот, как ориентируем? Ну вот, то есть просто вычислим площадь и, соответственно, ориентируем так, чтобы она была положительная.
Да, ну, про площадь мы в прошлый раз подробно говорили. Вот, и так пусть у нас площадь положительная, то есть обходим многоугольник против часовой стрелки.
Итак, вот у нас мы находимся на каком-то ребре. Ну, давайте три точки на одной прямой мы будем ориентировать, идущие подряд.
Итак, вот предположим, что у нас обнаружилось следующее, то есть следующее ребро. Утверждение. Ну, как бы мы идем против часовой стрелки, то есть как бы многоугольник остается от нас типа слева.
И теперь маленькое утверждение. Тогда утверждается, что следующее ребро обязано поворачиваться строго влево. Почему? А вот почему.
Потому что если оно повернется строго вправо, вот как-то так, то тогда можно вот в эпсилонокрестности этой точки, то есть в вершинке, взять тут точку, тут точку и провести между ними отрезочек, которые целиком, кроме концов, в многоугольнике не лежит.
Опять пользуемся леммой с прошлого занятия. Какой леммой? Что мы можем найти ушко, в котором нет других. Да, здесь почему я делаю это именно в эпсилонокрестности?
Ну, здесь даже не лемма, а просто возьмем такой эпсилонокрестность, в которой никакие другие вершины и отрезки не попадают.
Ну, потому что тут же могут там вот многоугольники стеретически куда-то сюда зайти.
Но почему такие есть?
Потому что у тебя конечные числа отрезков, и для каждого из них расстояние не нулевое.
Поэтому давайте возьмем минимальное расстояние, поделим его пополам и скажем, что это эпсилон.
Вот. Таким образом получается, что если мы ориентируем многоугольник против часовой стрелки, то необходимым условием является то, что все у нас,
что действительно у нас все, то есть каждое следующее ребро относительно предыдущего поворачивается именно влево. Это необходимо.
А теперь внимание, вопрос. Достаточно ли?
Почему?
Вот. А это на самом деле интеллектуальная задача.
Ну, давайте все-таки немножко подумаем.
Вот, допустим, мы взяли многоугольник, взяли против часовой стрелки, и неожиданно выяснилось, что это вот условие прям для него замкнуто выполняется.
Ну, хорошо. Давайте возьмем отрезок две точки и отрезок, который не выполнен.
Так, давайте. Вот давайте. Допустим, выяснилось неожиданно, что у нас тут есть две точки на многоугольнике.
Ну, вот такие что, если их соединить, то окажется, что этот отрезок не целиком лежит внутри многоугольника.
Можно, в принципе, даже так, давай я сразу уточню.
Можно взять супремум, просто взять две точки, которые обе лежат на границе, может быть даже в вершине, а все остальные точки этого отрезка в ауте.
Логично, да?
Нет, вот эти точки могут быть вершинами, могут быть не вершинами, могут на сторонах лежать.
Понятно, да?
Да, но после этого, кажется, их можно перегнать в вершины.
Так, ну да.
Просто идя по ребрам вверх.
Да.
Да, да.
Да, совершенно верно.
Во-первых, да, стандартный прием в геометрии.
Давайте просто эту, например, давайте попробуем пошевелить этот отрезочек.
То есть если обе эти точки лежат на ребре, то есть на ребрах, то давайте в какой-нибудь из сторон просто эту точку, это двигать, двигать, двигать.
Рано или поздно, то есть рано или поздно произойдет там сенсацион, там одно из сенсационных событий.
Либо мы у одного из этих отрезков придем в вершину, либо мы тут еще где-то наткнемся на вершину.
Предмет другого рукавича.
Ух ты.
Не уверен.
Думаешь нет?
Это прям, это каноничнейшая геометрия.
Нет, ну нет, ну нет, ну нет, ну нет, ну нет, ну нет.
Нет, ну я действительно уверен, что действительно в топологии, просто действительно без этой логики никуда, естественно.
Это правда.
Так что да.
Но таким образом, значит, мы сначала достигли того, что у нас есть какая-то вершинка.
Нет, то есть у нас, то есть теперь получается отрезок у нас соединяет вершинку с чем-то еще.
Но это что-то еще вполне может быть и отрезочек.
Так, ну теперь идея, что, ну в принципе при желании этот отрезочек можно теперь тоже шевелить, то есть там двигать эту точку вдоль ребра.
Правда надо еще правильно выбрать в какую сторону двигать.
Не факт.
Знаете какая подлянка может быть?
Нет.
А впрочем, действительно, смотрите какой чит.
Да, то есть действительно смотрите какой чит.
Самое тупое решение.
Продолжаем этот отрезок, обрезанный отрезок, продолжаем вот так вот двигать.
Да, ну в общем случае тут конечно что-то посложнее будет.
Ну по-моему нет.
Вот только одну точку из этих двух.
Вот вторую, которая еще не в вершине.
А, просто.
А, понятно.
Так, ну хорошо.
Давайте сделаем так.
Будем ее, давай, хорошо.
Как нам Миша сказал, так делайте.
И чего мы достигнем?
Вот мы достигнем.
За концов мы опять либо точку на стороне встретим.
Так.
Так.
Либо вот туда придем.
Вот.
Ну да, я согласен, что это, наверное, не супер много дает.
Нет, ну на самом деле тут по-разному можно делать.
Ну ладно, да, лучше двигать вверх переносом.
Да, ну хорошо.
Да, тут по-разному можно.
Ладно, давайте двигать переносом.
То есть параллелизировать мы все в ауте, в ауте, в ауте, в ауте.
Если мы случайно в какой-то момент натыкаемся на какую-то третью вершину,
то опять же какой-то отрезок отсекаем.
Вот.
Но заметим, что это будет происходить в конечное число раз.
Вот.
Ну вот.
Но действительно, что может произойти?
Ну в идеале, конечно, очень хочется сказать, что кончится это тем,
что этот отрезок просто схлопнется в одну вершину.
Еще мы действительно заметим, что если схлопнется в вершину,
то легко видеть, что в этой вершине условие поворота нарушилось.
Нет, даже не наверное, а точно.
Потому что относительно этих ребер это все должно происходить справа.
Мы же отрезок у нас в ауте находится.
То есть это означает, что отрезок устроен как-то вот так и так.
Что?
Да, совершенно верно.
Если мы уперлись действительно в одну вершинку, то конечно,
действительно налицо проблемы.
Но может возникнуть ситуация теоретическая, что почему не выяснилось,
что в какой-то момент этот отрезок просто уйдет на бесконечность.
Может действительно выясниться, что они как-то шли, шли, шли, тут шли.
И в какой-то момент неожиданно тут оказалось, что мы наткнулись на вершинку.
И тут многоугольник дальше идет куда-то вниз.
И начиная с этого момента у нас этот лучик торжественно уходит на бесконечность.
Когда вниз можно?
Перевернем и поменяем порядок.
Нет, зачем переворачивать?
Все гораздо проще.
Мы этот отрезок просто теперь поведем вниз ровно тем же методом.
Просто если и там мы уйдем в аут, то тогда у нас получится такая красивая речка,
которая разделила многоугольник.
Строгость.
Вот.
Идем в понятие речка.
Сформулируем так.
Строгость я скажу так.
Рассмотрим на каждом отрезке серединку.
Эта серединка явно движется относительно непрерывно.
Ладно, кроме вот этих точек, где эту проблему мы как-то решим.
И тогда у нас, если это правильно рисовать, то получится просто такая линия,
просто делящая плоскость на две части, в каждую из которых находятся части многоугольника.
Точек, где мы эту проблему как-то решим.
Да, да, да.
Нет, я не хочу сейчас прям совсем...
Если на яйцах они не будут с обеих сторон спрашивать.
Нет, ну скажем так.
Я могу вас, может быть, попросить какие-то из этих моментов додумать,
но думаю, что запиливать прям предельное идеальное доказательство я не буду.
Давайте Скопенкова позовем.
Ой, если мы будем Скопенкову...
Слушайте, я боюсь, я не сдам Скопенкову.
Я бы не взялся сдавать это Скопенкову.
Потому что, знаете, скажем так, есть одна лаквусовая бумажка, действительно.
Просто в одном месте.
Чем отличаюсь я от Скопенкова?
Вы знаете меры?
Нет.
Нет, меры я как раз не знаю.
Да, меры я как раз не знаю.
У меня такого предмета не было.
Просто смотрите.
На самом деле, терема у любого простого n-угольника сумма углов равна pi умножить на...
Сколько там?
На n-2.
Ну, известная терема, да?
Или что то же самое, 180 градусов на n-2.
То есть у треугольника 180 градусов сумма углов,
у четырехугольника 360 и так далее.
Но фишка в другом.
Нет, фишка в том, как я люблю это доказывать.
Сейчас я расскажу доказательства, которые лично я засчитываю.
Скопенков почти, наверное, и нет.
От перебушка?
Да, еще круче.
Значит, рассмотрим многоугольник.
Смотрите.
Давайте пройдемся по многоугольнику.
Ну, например, против часовой стрелки.
И при этом меня жутко интересует.
Я вот буду...
Когда я иду, я иду, иду, иду, иду.
Потом прихожу в вершину.
Я как бы поворачиваюсь вот на этот вот угол.
Там бета 1 я его назову.
И иду вот сюда.
Потом поворачиваюсь на вот такой угол бета 2 и иду сюда.
Понимаете, да?
Теперь заметим следующее.
Этот угол бывает как положительный, так и отрицательный, что важно.
Но если многоугольник не выпукл, этот угол будет отрицательным.
Мне это важно.
Так вот.
Чему равна сумма углов на самом деле многоугольника?
Заметим, что каждый угол вот этот альфа 1 обладает таким приятным свойством,
что альфа 1 плюс бета 1 равно π.
Причем даже если бета бывает отрицательным, но это просто означает,
что там вот какая-нибудь вот такая безобразие произошла.
Но обратите внимание, здесь тоже тогда получится просто, что...
То есть как бы бета 1 оказывается вот таким вот отрицательным на самом деле.
И вот альфа 1 вот такой, но сумма их 108 градусов.
Видно, да?
И тогда смотрите.
И тогда получается, что сумма всех углов многоугольника
она равна, получается, π на n минус сумма углов бейтого.
А теперь визитическое утверждение.
Что такое сумма углов бейтого?
Насколько я суммарно повернулся, пройдя по всему многоугольнику?
Вот насколько я повернулся?
Вот просто шел я тут шел, поворачивался, поворачивался, поворачивался, поворачивался там.
Вот шел, шел, шел, шел.
Шел шел шел, шел шел.
Тут еще поворачивался, там вот поворачивался.
Спиралька у меня тут была какая-то.
Но в итоге пришел я в ту же точку и смотрю туда же.
Какой вывод из этого я могу сделать?
вывод что сумма бетах ну как минимум делится на 2p правда вот но остается только действительно
сделать чуть более аккуратное рассуждение и убедиться в том что на самом деле это сумма
углов не просто делится на 2p а если мы шли против часовой стрелки то просто равна 2p
а моя но а если подчасовой то минус 2p ну доказательства может быть такое заметим
что если мы чуть-чуть пошевелим вершинки многоугольника то очевидно этот угол суммы этих
углов никак не поменять она будет как во-первых она будет меняться непрерывно
верится даже это меняется непрерывно да а во-вторых ну вот а в тэф так как этот сумма углов
очевидно делится на 2p значит она получается меняться не будет позже как бы непрерывности
таких квантовых скачков не бывает но после этого остается только любой многоугольник на самом деле
довести просто аккуратно до ну иногда просто до состояния треугольника ну можно ну там надуть
это там аккуратная такая операция вот нет ну на самом деле там ну там по разному можно делать то
есть можно там можно как мы раньше там по индукции доказать там что-нибудь про сумму углов там я
добавляю это либо добавляю эффективные ребра либо там отрезать эти уши на самом деле ну и так далее
вот то есть на самом деле вот то есть вот примерно такое вот такое доказательство как бы я с
удовольствием зачиту да очень удобно да ты вот то есть это вот то есть копенков почти
наверное нет конечно такой не зачтет ну как ну знаете ну как бы там уже то есть как-то
слишком визуальный какой-то образ вот то есть там по хорошим видим надо там может быть действительно
там а что то ли интегралы какие находить то ли что-то еще в этом роде то есть ну вот да вот
он потребует что надо вводить какие-то индексы отходы прошу страшные слова сочетать вот ну то
есть то есть как бы как по мне для ну то есть как бы как по мне так то есть с одной стороны я
крыша сторонник того чтобы все решения надо доказывать но с другой стороны как по мне это
доказательство мне кажется достаточно четко но тоже верно да нет согласен да может быть
топологии действительно имеет смысл вводить за это бою там в этом в этом смысле больше строгость
но впрочем тут я не берусь а причем тут никита андрусов и что
понятно нормально вот так же от perceber да но поэтому как поBT prophet да да то есть на самом
деле иногда вот такой полез так вот но сад и так и так ну мы тут действительно про вып spouse тоже
доказали вроде как и вот то есть здесь так porta что выпукловому угольника действительно есть
такое приятное свойство но более того на самом деле но вот ну что тут еще можно вывести хотя
ладно это мы позже скажем пока же как бы для чего нам это надо еще допустим что еще можно делать с
выпуклым многоугольником ну на самом деле можно заметить маленькую приятную вещь то есть можно
ведь что если у нас есть задача там лежит ли точка выпуклым многоугольники то как бы есть у
нас этот многоугольник просто лежит в порядке обхода против часовой стрелки то мы эту задачу
можем решить уже даже не за линию а за логарифу вот да тут важно как потому что на самом деле
часто было тут опять это еще одна задача извыкла все понимают что как-то можно потом когда дело
дойдет до кода начинает сказать а ну там понятно надо вот эти вот горизонтальные прямые значит
провести там какой-то день поиск за бабахой проверить ли точку лежит внутри трапеции и так
далее да вот но тут опять это еще один когда вот как бы слушать когда тут лучше слушать
внимательно потому что как бы как бы если вы можете написать так но как бы вы рискуете
агрести ну бывает возможно не выпукло вы не смотрел какой-то случай которых выпукло не
бывает но на самом деле можно тут найти за логарифом все гораздо проще значит ситуация такая рассмотрим
первую попавшую вершину какую-то нулевую вот нулевая первая минус первая и во первых
давайте за от единицы проверим лежит ли точка вообще в этом углу как вы это проверим кстати
ну по сути да ну на самом деле вот если у нас многоугольник против часовой стрелки то надо
просто проверить что вот это на это должно быть больше нуля с векторным произведением конечно и
вот это на это должно быть больше нуля то есть легко убедить то是 любая иная комбинация это
авт сразу но там бывает еще равенство нулей но как бы тогда можно сказать что здесь это на
это должно быть больше либо равно нуля а это надо меньше и мы oli и так хорошо то есть но вот так
хорошо вы убедили что то еще лежит в этом углу но это все не значит что она лежит вместе с
в другоугольнике, а может так сказать за этой чертой.
Тогда идея такая, проведем все вот такие лучи, очевидно
точка, то есть как бы удобно, если мы стоим в этой точке,
то перед нами получается вот такой вот веер из прямых.
Вот, и нам жутко интересно, между какими двумя этими
лучами лежит наша точка.
Это очень легко найти просто бинарным поиском по ответу.
Ну просто там берем очередной луч и говорим так, если у нас
векторное произведение это на это меньше нуля, значит двигаем правую границу,
а если там оказалось, что это на это больше нуля, значит двигаем левую. Понимаете, да?
То есть получается в бинпоиске, то есть в бинпоиске мы там каждую проверку делаем
с помощью одного векторного произведения.
Итак, в результате мы нашли, между какими двумя лучами лежит наша точка.
То есть тогда получается, что у нас между этими двумя лучами есть вот эта вот ребрышка и точка.
Теперь остается только проверить, лежит ли точка в треугольнике.
Но здесь мы видим, что не надо проверять, прям лежит ли точка полностью,
прям полный треугольник проверять, а вместо этого достаточно проверить только одно.
Надо проверить, с какой стороны от этого отрезочка, от ориентированного против часовой стрелки,
лежит точка справа или слева. То есть опять же векторное произведение вот это на это.
Если получится меньше нуля, значит out, если это на это больше нуля, значит in.
А если ноль, значит эта точка на этом отрезке просто и лежит, кстати.
Можно и даже дополнительно не проверять.
Ну вот, в общем-то, получился такой достаточно очень простой метод.
Боже вас упаси, тут какие-то горизонтальные прямые рисовать и поиски искать.
Надеюсь, этим никто не занимается. Вот, не занимается?
Все, кто не пришли будут такие. Ну да.
Нет, вот это было страшно, на самом деле, когда на финале,
потом на пробном туре дали задачу, пересеките многоугольник и полукруг, найдите площадь.
Как бы они из курса знали, что там как-то за линию делается, но выяснилось,
что они искренне думали, что надо просто там как бы, ну понятно,
напроводим там вот этих прямых и как-нибудь пересечем там круг и трапецию.
Вы про кого? Ну, про последних финалистов.
Линкет? Вот так, вот, ну вот, так, ну, кстати, об этом, нет, о пересечении.
Вот мы с вами в прошлый раз площади всякие искали, да?
Так вот, да, вот мы не успели с вами обсудить такую важную задачу.
Давайте отвлекемся немного от выпуклости. Вот задача.
Дан круг, дан многоугольник. Найдите площадь пересечения.
Да, на самом деле абсолютно любой там ограничение там,
я не знаю, что угодно, там сто тысяч, может даже миллион на самом деле.
Найдите площадь пересечения.
Как-нибудь найти точки пересечения. Нет, ну точки пересечения, конечно,
круглый многоугольник найти легко. Вот, ну там очень много каких-то вариантов есть.
Ой, хотя да, ой, это ж про, а это ж надо отдельно про круги еще говорить.
А, ну вот. Ну хотя давайте для начала. А, кстати, действительно, давайте вот, да,
для начала решим маленькую техническую задачу. Как пересечь хотя бы круг и прямую.
Для начала.
Найти точек пересечения. Ну их 0, 1 или 2. Вот давайте все и найдите.
Ну, короче, это может быть не супер утимальный алгоритм, но по коду,
учитывая все написанное нормально, я просто опускаю периметигуляры в центре напрямую.
Так, понятно. Ну, в принципе, да, один из классических методов такой. Ну вот,
но как можно, кажется, у меня другой. Значит, смотрите, какой. Как задается прямая?
Прямая называется, как всегда. То есть прямая равно, как всегда, p плюс vt. То есть это, в принципе,
множество, которое называется прямой, где p – это точка напрямая, v – направляющий вектор, правда?
Так, окружность у нас задается как центр и r, правда? То есть, можно сказать, что уравнение,
ну, то есть, на самом деле окружность – это у нас такое уравнение вида такие точки p, что, значит,
скалярное произведение p – c на p – t, скалярное произведение равно r2. Так, ну, давайте вот это
вот подставим сюда. То есть, получится уравнение вида p плюс vt на p плюс vt равно r2. Да,
минус t, согласен. Минус t. Да, то есть, если раскрыть это по линейности, то получится
квадратное произведение, там, просто квадратное уравнение вида там v на v на t квадрат. Вот это,
кстати, заметим, что это, естественно, не ноль, потому что v – не нулевой вектор,
да? Вот. Плюс 2 на скалярное произведение p – c и v на t плюс, соответственно, там,
pc – pc минус r2 равно нулю. И все, остается только теперь решить квадратное уравнение,
причем еще и с формулой половинного дискриминанта. Ну, вот это вот, ну, знаете эту классику, да,
там, понятно, d на 4 равно вот это вот там, там, p – cv в квадрате минус там v на v. Ну, да. Нет,
ну почему? Можно пользоваться, нет, можно пользоваться обычной формулой, просто тут
четверки лишние будут. Ну, вот, но как бы нет. Вот. То есть, это вот вы пишете, а дальше пишем,
что t1,2 на самом деле равно получается минус там p – cv плюс-минус корень из этого дискриминанта
поделить на там vv. Ну, там. Нет, ну там, скажем так, тебе придется, ты там строишь
перпетикулярий и пересекаешь прямые. Там, видимо, тебе все равно, в то ли какое-то уравнение придется
решить. Да, но, правда, переченья прямых, да, по моей философии пишется ровно так же,
как мы помним, да. Да, ну вот, ну, ну, тут да. Ну, не знаю, нет, а по мне наоборот, знаете,
что просто в геометрии особая подлость бывает, что надо рассматривать случаи. Вот. А здесь, как бы,
вот, когда вы пишете такое явное уравнение, то есть, вот этот метод хорош тем, что случаев
никаких нет. Точнее, случаи, на самом деле, просто полностью описываются просто случаями в
квадратном уравнении. То есть дискриминант меньше 0, значит, пересечения нет, дискриминант равно 0,
значит, решение ровно 1, дискриминант больше 0, значит, решение 2, и вот они. Вот в пересечении
прямых, кстати, тоже это было хорошо, потому что мы там на раз определяем, то есть, действительно,
то есть, уравнение там, если коэффициент t равен 0, значит, прямые параллельные или совпадают.
И это было прям вот в точности. То есть, не случайно мы там делим именно на векторное
произведение направляющих векторов, прямых оказывалось. Ну, я боюсь без этого никак.
Да, боюсь, да, без этого, без этого боюсь просто никак. Но решение по-любому, тут я боюсь просто
решение не целочисленное и не рационально числами. То есть, без вариантов. То есть,
где-то выплывет. То есть, там, конечно, есть всякие более приятные вещи. Оказывается,
что отразить точку относительно прямой, кстати, оказывается, можно вполне себе в целых числах.
Ладно, в рациональных. Вот, там, да, то есть, там, если аккуратно расписать формулу,
то выяснится, что там, действительно, корнемодическим образом убиваются. Но не буду
сейчас это делать, оставим в качестве упражнения. Вот. А чем еще, знаете, чем еще приятен этот
способ? На самом деле, для нас он будет очень полезен в нашей задаче. Почему? Значит, еще
неожиданное у него преимущество будет заключаться в том, что если вы обходите многоугольник, ну,
скажем, против часовой стрелки, хотя по барабану, по какой там на самом деле, ну, как-нибудь вот так,
да, то удобство окажется в том, что когда вы будете искать точки пересечения, вы их сможете найти и
записывать ровно в том порядке, в котором они вам встретились. То есть, если вы вот идете, скажем,
вот против часовой стрелки, то есть, в эту сторону, то вы, как бы, уже взяв сначала меньше корень,
потом больше, как раз увидите сначала вот эту точку, а потом вот эту. Но вам еще, да, останется
только проверить, что вы пересекаете не прямую, а отрезок, но это совсем легко, потому что тогда
окажется, что т-шка, просто надо проверить, эта т должна лежать на отрезке от нуля до единицы. Вот,
еще и такое дополнительное. То есть, дополнительное приятное удобство у такого метода есть.
До единицы. Потому что, потому что в качестве П вы возьмете вот эту точку, а в качестве В
вот весь вот этот вектор, поэтому получается. Поэтому получится прям до единицы. То есть,
очень удобно. Вот. То есть, более того, то есть, в принципе, получается, давайте будем считать,
что это тоже вершина многоугольника. То есть как бы это типа Маша Трейкурова. Так, кто такая Маша
Гера Трейкурова? Это как внимательный зрителю, как внимательный читатель уже понял, это есть героиня
нашей повести. И не надо мне рассказывать, что вы не читали Дубровского. Да ладно, это предшкольная
программа. Это школьная программа шестого класса. Ну вот там вот. О господи. Да-да-да-да-да. А если
Владимир Макбет, то только Мценского уезда. Так что ли. Нет, странно, Дубровский там достаточно
трогательная история, как-то. Ну как по мнению, не знаю. Чего? Ну да, хотя давайте вспоминать, что
да, что присредило в мире, когда вы были в шестом классе. Так сколько это было 8 лет назад? Питон 3.7,
по-моему, еще не вышел. А, но да, зато отгрымел Олимпиадов в Сочи. Хотя ладно, в 2015 году вроде
такого интересного уже ничего не было. Так вот, смотрите, какая у меня неожиданная идея возникает.
Как мы ищем вообще площадь многоугольника? Ну площадь многоугольника мы ищем так. Мы
становимся в какую-то точку, то есть как бы потом берем какую-нибудь козу, ставим ее на многоугольник,
там привязываем ее, и коза начинает обходить многоугольник, а мы смотрим, какую площадь мы
замощаем, правда? При этом, если мы поворачиваем, если коза нас поворачивает против всего стрелки,
то заметаемую вот эту вот площадь мы считаем со знаком плюс, а так со знаком минус. Да,
то есть площадь мы, напоминаю, по прошлому разу ищем ровно так. Так вот, как искать площадь
переченья круга и многоугольника. Так вот, неожиданный чит. Делаем абсолютно то же самое,
но мы становимся в центре круга и замощаем мы при этом именно, то есть когда мы тут проходим,
то мы замощаем не весь треугольник, а пересечение этого треугольника и круга. И это, оказывается,
несложно. Ну, во-первых, потому что заметим, что у нас любой отрезок, либо такой, теперь,
когда мы добавили точки переченья, он либо целиком лежит внутри круга, либо целиком лежит вне.
Удобно, да? Причем, кстати, очень легко проверять. Вообще, как проверить, кстати,
этот отрезок лежит внутри или вовне? О боже. Ну, можно. Я проверял по-другому. Я просто брал
середину отрезка и проверял расстояние до нее. Ну, расстояние до середины отрезка или
расстояние до отрезка? Расстояние до отрезка это там что-то сложное какие-то. Нет. Да, так что
немножко другое. Вот, то есть надо просто, ну, то есть, по сути, надо взять середину отрезка и
проверить, лежит ли она внутри круга, да или нет. Так вот, но идея очень простая. Оказывается,
что если отрезок лежит внутри, то надо к ответу прибавить просто то же, что и раньше, то есть
векторные произведения вот этого на этого. Ну, там пополам, конечно. А можно и пополам. А что делать,
если отрезок лежит вне? Ну, тогда надо просто в явном виде найти вот этот ориентированный угол
с помощью функции атан-2 и прибавить к ответу не треугольник, а площадь вот этого сектора. А
чего у нас равна площадь сектора круга с радиусом r углом альфа? Конечно, альфа пополам. Ну,
потому что если бы альфа была, ну, потому что явно этот сектор явно пропорционален углу, а если
угол 2 пи, то там площадь круга, как известно, пи r квадрат. Поэтому получается 1 2 альфа r квадрат.
Вот пи r квадрат. Ну, потому что пи – это половина полного угла. Ой-ой-ой-ой. Слушай,
ты это осторожно, потому что я сейчас расскажу еще одну веселую байку. Это называется, да,
как получить за презентацию по-английскому чуть ниже баллов, чем могло бы быть. Вот. Нет,
не-не-не, на самом деле там, нет, там просто в агире. Ну, нет, у меня просто было такое,
что надо было сделать презентацию. Я, говорите, нашел в интернете, сделал доклад на одиозную тему,
там называется Pi is wrong. По-английски пи. На полном серьезе существует такое полушуточное
движение, можете потом погуглить, реально чистая правда, которое говорит о том, что пи введено
неправильно. Ну, потому что давайте подумаем, что такое пи? Пи – это отношение, ну, по официальному
определению, число пи – это отношение длины окружности к ее диаметру. Внимание, вопрос,
какого, извините, а почему диаметра? У нас круг вообще чем задается, диаметром или радиусом?
Наверное, естественно, задавать радиусом. Поэтому вместо пи надо вводить, логичнее было бы ввести
константу tau, которая равно длина окружности делить на радиус. Нет, казалось бы, как, ну,
понятно, идея на разнице никакой, то есть точность лишней двойки. Но дальше вычисляется,
просто выдается огромное количество различных формул, в котором почему-то рядом с пи неизбежно
есть двойка. То есть, скажем, формуле Сирлинга, например, там в корне 2 pi находится, или там полный
угол у нас, например, 2 pi, а не вот какая-нибудь константа, или там еще, то есть там дальше прям
целый список, и везде эти двойки. То есть, сколько вот этой вот краски от принтера можно было
сэкономить. Да, там реально такое кубик приводится. Вот, почему заняться нечем. Нет, на самом деле,
нет, тут просто... Нет, по-разному. То есть, более того, я, главное, аккуратно делал, то есть,
как положено, презентация должна быть из трех частей. Так вот, в третьей части у меня
рассматривается. Вот есть такая, казалось бы, единственное исключение, где 2 pi нет. Это как
раз формула площади круга. 1 pi². Ну вот, там 1 pi². Но на самом деле, как я просто, да, вот это
действительно, видимо, совсем добивает это, потому что я там в третьей части. А давайте докажем,
почему там площадь круга 1 pi². Не, не волнуйтесь, ничего сложного не будет. Смотрите, рассмотрим круг.
Ну, давайте так. Что такое вообще длина окружности? Ну, на самом деле, ее можно рассмотреть так. Давайте
рассмотрим какие-нибудь описанные вокруг нее многоугольники и скажем что-то типа, что... Нет,
ну понятно, строгость я понимаю, но тем не менее. Иногда бывает. Ну, смотрите, ну просто идея такая,
видите, вот есть такой многоугольник. Но давайте подумать, чему равна, если у нас есть описанный
вокруг окружности многоугольник, чему равна его площадь? Ну, заметим, что она равна сумме площадей
вот этих треугольников и у каждого из этих многоугольников высота равна ровно радиус,
правда? Поэтому площадь треугольника равна 1 2 периметр многоугольника на r. Логично, да?
Чего? Какой периметр? Периметр вот этого многоугольника. Утверждение. Да, периметр,
сумма длин сторон, да? Так вот, давайте, ну вот, то есть можно в принципе, то есть теперь давайте
устремим количество сторон бесконечности, и тогда p будет стремиться к длине окружности. И тогда
получится, что площадь окружности равна длину этой окружности, длина этой окружности у нас равна
чему? Там в идеале tau на радиус. И r2. То есть по идее, на самом деле, вот тут 1 2 была бы осмыслена,
и она бы символизировала, что окружность это такой предельный многоугольник, у которого площадь
ровно такая была бы эта связь. А тут она упущена, на самом деле. То есть тут она как раз осмысленна,
то есть на самом деле 1 2 tau в квадрат была бы формула более красивой и показательной, на самом
деле. Особенно если учесть, что площадь треугольника отчасти из того, что у нас площадь треугольника 1 2.
Так что вот такое. Единственная проблема, что такое решение может не уложиться в критерии. Я же напоминаю,
я это в презентации по-английски рассказывал. То есть преподавательство честно сказал,
что я ничего не поняла. По формальным критериям там какие-то 16 из 20 набралось,
но как бы по содержательной части она просто там просто честно сказал, я это оценить не могу.
Нет, ну я не знаю там как бы вопрос. Ну там сложно сказать, хотя нет, но я полагаю,
что как бы ладно, если она допустим гуманитарий, но вместе там вроде тоже сидел еще 10 физтехов,
которые по идее вроде там этот уровень школьной геометрии вроде тянуть должны. То есть заметьте,
то есть я в принципе это мог там каким-нибудь там от школьников из 8 класса рассказать спокойно.
Нет, ну просто понятно, что учитель английского вряд ли будет называться физтеховским образованием
или техническим. Ну собственно ладно, это на самом деле не принципиально. То есть тут более
интересно, что движение такое есть, то есть вы там если погуглите там Pi is wrong, то можно найти
не просто презентацию, а даже просто целую лекцию. И там человек будет даже агитируется,
что день Pi на самом деле 14 марта праздновать не надо, а на самом деле надо праздновать день
Tao 28 июня. Соответственно, да, то есть послушайте, там очень интересная лекция, то есть там еще
более подробно на самом деле это все расскажут, но понятно, что это конечно юмор, но в каждой шутке
есть доля правды. То есть доля правды, которая здесь подается именно в том, что это о роли не совсем
четко введенного определения. То есть да, понятно, что мы уже конечно из истории человечества уже
число Pi не выпилим, конечно. То есть это конечно прям очень жесткое решение должно быть, чтобы
там весь мир собрался и принял жесткое волевое решение, что забываем о Константе Pi и теперь
разговариваем только на языке Tao. Да, это невозможно, то есть думается да невозможно, да и в общем-то не
особо осмысленно, там просто может быть не рентабельно. Но на самом деле на будущее может и
стоит задумываться, вообще как правильно вводить определение, чтобы было максимально красиво и
показательно. То есть на самом деле тут вот такие решения. Ну вот, ну а если вы пересекаете там
круг и многоугольник, то на самом деле есть вот такой простой метод и боже вас упаси делать это
каким-то вертикальным сканлайдом и пересекать круг и трапецию.
Так что вот такая красота очень прям рекомендую. Вот так что пересекайте круг и многоугольник,
пожалуйста, просто быстренько пишите это и прям вот ждет вас очень быстрое счастье. Вот геометрия
вещь такая, есть там куча вещей, которые если вы знаете как правильно делать, то вас ждет
неожиданное счастье. Но геометрия в общем об этом. Тут как нигде в олимпиадном программире вещи
о профессионализме, то есть о том, что многие вещи надо просто знать как правильно писать.
Вот и чем больше вы таких вещей оптимально знаете, тем как бы больше у вас есть преимущество перед
теми, кто их не знает и будет там в каждом из десяти мест программы там писать какой-то геморрой.
Вот, значит это пересечение. Да, но если уж что-то об этом говорить, что еще можно сказать про
окружности. Но надо, конечно, обсудить как пересекать две окружности. Ну нет, ну почему,
блин. Ну правда, с таким методом, конечно, пересекать его не получится. Нет, хотя можно,
конечно, попытаться. Радиальная ось это что? Что это такое?
Это если соединить их в центры и в середину перпетикуляра. И что? И что с ним надо делать?
Нет, это прямая, которая проходит через точки пересечения окружности. Только там не середина
перпетикуляра. А, ну можно. Нет, ну давайте так. Ну да, можно, конечно, сказать, что нарисовать
два уравнения вида там х-х0 в квадрате плюс игрок минус 0 в квадрате там равно r в квадрате.
Если взять такие два уравнений, вычислить заново другой, то получится уравнение прямой. Мы
свели задачу пересечения окружности прямой, правда заданной не двумя точками, а уравнением. Вот.
Ну, честно скажу, да. Ну, на самом деле, а что будет, если мы применим вот этот метод? Ну,
вторая окружность вот, допустим, записывается вот так. А как записывается первая? Ну, первая
записывается каким-то, первая записывается каким-то мистическим уравнением в духе,
да, она записывается просто уравнением вида там с0 плюс, значит, там, допустим,
от альфа на v0, где альфа, значит, там, допустим, ну давайте просто r и что это? А что такое а от альфы?
Это просто матрица поворота соответствующего вектора. Ладно, тут не v0, а тут, конечно,
какой-нибудь вектор, вот этот вот, r0,0. Логично, да? Так, ну а теперь давайте думать. Подставим
его вот сюда, да, то есть у нас получится, значит, с0 плюс а от альфа на, значит, r0,0,
значит, минус c1, так сказать, в скалярном квадрате равно r1 квадрат. Так, ну что у нас получится?
Так, ну, видимо, в силу там всех линейностей получится у нас что? Значит, там что-то типа
а от альфы там в квадрате на r0,0, да, или нет? Так, давайте так. К чему равно а от альфы на r0,0,
запятая а от альфы на r0,0? Так, чему это равно?
Ну, внутри будет а на транспонировано. Ну, кажется, что это должно быть что-то очень такое. Конечно.
Мы домножаем вектор на сам себя. И длина его не поменялась. Ну, это же как бы мы ж по определению
говорим, что вот это вот, это вектор r0,0, повернутый на угол альфа. Вот. Так что тут получается,
получается так. Значит, r0 квадрат плюс два скалярных произведения а от альфа на r0,0, запятая c0-c1
плюс c0-c1 в квадрате минус r1 в квадрате равно нулю. Ух ты, уравнение даже похоже на линейное.
Так. Осталось только выяснить действительно, как тут вот эту альфа по этому уравнению найти.
Да, ну тут понятно, можно там где-то на r0 поделить. Так что соответственно, да.
Вот. Поэтому слушайте другой метод. Вот мы говорим о том, что ладно, такой метод действительно вызывает
какие-то проблемы. Хотя может быть, хотя может быть его довести можно. Но можно как бы свести
задачу к пересечению окружности прямой, причем прямую задавать двумя точками. Как это сделать?
Очевидно, надо применить инверсию. Да, что такое инверсия? Да, это такое мистическое
прообразование плоскости, которое перероняет некоторые окружности не только в окружности,
но и в прямые. Так, что такое инверсия, вы не знаете? Ну вот. Ну ладно, ну вот. Нет, ну там
обычно инверсия это преобразование. Ну там инверсия, например, в точке 0,0 это преобразование
вида, что какое-нибудь комплексное число z там переходит в какой-нибудь там, ну там,
комплексный один делит на z. Да. Ну почему сопряженное? Ну идея в том, что если у тебя была
тут точка на расстоянии r, то оно переходит в точку на расстоянии 1 делит на r. Это инверсия в
точке 0,0. Так вот, у этой инверсии, не будем доказывать, есть мистическое свойство. Что если
вы делаете инверсии с точкой 0,0, то оказывается следующее, что все окружности, проходящие через
точку 0,0, превращаются в прямые. Ну вот. А все прямые, не проходящие через точку 0,0,
превращаются наоборот в окружности, проходящие через 0,0. Да, вот такая магия,
такая математическая магия есть. Вот. Ну а если окружности не проходят через точку или там нот,
то они просто там в другие окружности превращаются. То есть там получается такая красивая идея,
что прямая это такая предельная окружность. Вот. Ну просто этим можно воспользоваться там,
то есть на самом деле просто применив инверсию, то есть в точке, в одной из точек,
лежащих на окружности. Правда, желательно это сделать так, чтобы эта точка не лежала на
второй окружности. Поэтому там какие-то случаи придется рассматривать. Но тут практически везде
придется, к сожалению, в пересечении окружности, эта меркская задача, там придется в любом
решении и случае рассматривать. Потому что, честно скажу, вот. То есть я говорю, какие-то такие идеи,
потому что на самом деле я, естественно, не пишу не так-не так. Ну и, как ты сказал, я тоже не пишу.
Саратом, это саратом, господа. Вот. Хотя странно, да. И так, значит, идея на самом деле очень
простая. Если я возьму, допустим, у меня есть два центра, там C0, C1 и радиус R1, R0, R1, то что такое
точка пересечения окружностей этих окружностей? Это, на самом деле, третья вершина вот такого
треугольника со сторонами R0, R1 и вот этот C0, C1. Правда? То есть мы должны найти какую-то,
что такое точка пересечения окружностей радиуса R0 с центром C0 и радиуса R1 с точкой C1? Это такая
точка, у которой расстояние до C0, R0, расстояние до C1, R1. То есть они обнаружат вот такой треугольник,
возможно, вырожденный. Вот. То есть, в принципе, можно, но вот. Вот. Ну, а первых, но вот здесь вот
возникает вопрос. Действительно, существует ли такой треугольник? Ну, для того, чтобы проверить,
существует ли такой треугольник, вам придется проверить, что R0, R1 больше хотя бы либо равно,
чем расстояние C0, C1, а также R0 должно быть, R0 плюс модуль C0, C1 должно быть больше либо равно R1,
и R1 должен быть плюс модуль C0, C1, то есть больше либо равно R1. И все эти условия надо проверить,
потому что нарушению каждого из этих условий соответствует конкретная картинка. Вот,
например, если вот это условие неверно, то это означает, что окружности просто лежат вне друг
друга. А если вот неверно, скажем, вот это условие, это означает, что на самом деле окружность
с радиусом R0 просто лежит целиком внутри R0. Да. Причем более того, когда в этих условиях возникает
равенство, то на самом деле это означает, что у нас тут есть внутренние касания. Видите, у
окружности касания бывают как внешние, так и внутренние. Но первое, что мы делаем, то есть,
проверяем эти условия. То есть, если они строго, то есть, если какой из этих условий строго не
выполняется, то значит, вы просто сразу будете, что точек пересечения нет, с вами были, подписывайтесь,
до свидания. Ну или там, давайте другой тест, если задача мульти-тест. Вот. А в любом ином случае
треугольник, хоть и вырожденный, но существует. А что это означает? Означает это следующее,
что мы можем найти вот этот вот угол альфа. Ну таких треугольников, очевидно, два симметричных,
но вот угол вот этот альфа можно найти. Каким образом? Можем найти его... Нет. Можем. Давайте,
для этого надо просто вспомнить, что вы когда-то были восьмиклассниками. Да, в восьмом классе у
нас есть такая штука, как Теремокосинусов. Да, у кого-то в восьмом была. Но нет, ребят,
знаете, есть такая школа, Восковская средняя специальная музыкальная школа имени Гнесиных.
В ней учат на профессиональных пианистов. Так вот, на экзамене в девятом классе по математике
вопрос такой Теремокосинусов там был. А как вы думаете, сильная ли там математика? Нет, поверьте,
там математика была достаточно слабая. Ну и там просто не особо была слабая. В чем специфика такой
школы? Школа рассчитывает на то, что все дети учатся на профессиональных музыкантов. То есть это
означает, что основная работа у них начнется после школы, когда они придут домой, пообедают,
сядут за инструмент и, собственно, реально начнут работать. Поэтому в школе там особо не грузили.
Ну и тем более понятно, что там не будут предполагать. Поэтому там многие из этих вещей,
то есть там уже, на самом деле, для детей это будет просто очень сложно. То есть вас, возможно,
будут держать в лучшем случае за гения, в худшем за умника, на самом деле, если для вас легким будет
хоть что-то из этого. Ну вот, нет, ну по-разному, да. Ну вот, нет, ну как сказать, нет, это уже от вас
зависит. Нет, ну в чем проблема? Нет, до какого-то момента я держался, я не знаю. Но правда,
после девятого класса я в итоге, собственно, уже окончательно ушел в 57-ю, но это уже отдельная
история. Но это я просто к тому, что терема косинусов уже точно в любой школе должна быть
не старше, чем в восьмом классе. Да, но нет, что такое нет? Нет, ну как сказать, я седьмого
класса на самом деле ходил влевослушителем там в один мат-класс. И что такое синусы косинус,
хотя бы на уровне там катет гипотенузия. Это рассказывалось в седьмом классе.
Мне рассказывали на физике в восьмом классе. Да, странно.
Ну да, жалко, к сожалению, да. Вот может по этому геометрию надо в первый семестр
приносить, пока все ходят. Ну по-разному, да. Но в данном случае, да, у нас есть терема косинуса,
ладно, так или иначе, она у нас есть. Согласно ей мы честно пишем, что r1 в квадрате равно r0 в
квадрате плюс там c0 c1 в квадрате минус 2r0 на c0 c1 на косинус альфа. Ну из чего там понятно,
косинус альфа равно там бла-бла-бла, поделить на бла-бла-бла. Уж не буду расписывать шо на шо.
Но косинус известен, но тогда просто идея очень простая. Смотрите, косинус известен,
синус равен, естественно, корень из 1 минус косинус в квадрат. И тогда идея такая, смотрите,
то есть что нужно, чтобы найти вот эту точку? Надо взять вот этот вектор, относить на точке c0,
повернуть его на угол альфа, а мы с вами уже умеем делать, если мы знаем косинус и синус. То есть
заметьте, нам сама альфа не надо знать, нам надо знать только косинус и синус. Вот теперь вот у вас
вектор смотрит, но теперь надо просто домножить его на какую-то константу так, чтобы вот длина
стала не вот какая она была, а r0. То есть есть такая операция нормирование вектора. То есть
делаем так, чтобы вектор смотрел туда же, но его длина была 1. То есть это как бы у нас операция,
то есть v превращается в v поделить на модуль v. То есть это называется нормирование вектора. То есть
когда вы его поделите на свою длину, то он теперь смотрит в нужную сторону его длина 1, а теперь,
если вы домножите на r0, то он тогда попадет в нужную вам точку. Вот здесь и вот здесь. Вот сейчас
расскажу, лично я пользуюсь вот ровно таким методом. То есть вот эти случаи надо рассмотреть,
но если точка существует, там точка пересечения, то соответственно угол находится, причем этот как
бы это термокосинус прекрасно кушает случаи, когда альфа равно 0 или 180 градусов.
Но это здесь. Ну да, но это уже отдельный случай, который надо рассмотреть, это не совпадают ли
окружности просто в принципе. Да, это правда. То есть там, но это да. Ну почти многие из вас,
наверное, рано или поздно в каких-нибудь лкашах или других школах сталкивались с задачей,
найдите все точки пересечения окружности и напишите, что есть сара too many points,
если их бесконечно много. Наверное, сталкивались, ее там везде дают. И это одна из самых болезненных
задач на самом деле, потому что с непривычки можно столько ВАша грести. Ну вот, кажется,
вот просто мой способ на самом деле достаточно надежен, потому что он там не придирается к тому,
где эта точка находится, здесь, здесь или там здесь, то есть независимо там альфа острый,
тупой, там r0 маленькое, большое, то есть на самом деле, то есть тут все в этом смысле достаточно
надежно. То есть все одинаково. Вот так вот таким вот образом мы пересекаем окружности. Ну что
еще надо знать про окружности? Ну, конечно же, надо уметь к окружностям искать касательные.
Вот, да, касательные, конечно, сегодня тоже будут играть важную роль в нашей математике.
Чего есть? Умеем, и что?
А прям вот настолько нагло, да? Ну можно и степенью точки, конечно. Да, смотрите,
какой оригинальный метод. Теперь дана точка вне окружности, дана окружность. Найдите касательную.
Да, как найти? Ну, очень просто. Проведем касательную какую-нибудь и проведем прямую
через центр. Вот, допустим, вот это расстояние до центра у меня оказалось l, а радиус r. И вот
это вот расстояние, допустим, равно d. И тут Биша вспоминает еще одну школьную теорему.
Вот она была на квале ACPC, я ее тоже применял. О, классно, да? А вы не применяли? Сразу скажу,
не помню. К сожалению, нет. Да, и у нас есть теорема степени точки, которая говорит нам о том,
что вот это на вот это равно вот это на вот это. Ну, равно на самом деле просто вот это на вот это.
Балатская теорема, помните? Более того, то есть эту штуку можно назвать степенью точки, в чем эту
степень точки можно ввести даже не только для точек вне окружности, но и для точек внутри
окружности, потому что внутри это тоже правда. Ну, там доказывается с помощью каких-то там вписанных
углов. Ну, потому что ноль, да. Хорошо. Так вот, но в данном случае эта теорема говорит нам о
следующем. То есть можно просто вот это D теперь очень легко найти, потому что D квадрат равно там L
минус R на L плюс R получается. Ну, то есть L квадрат минус R квадрат. Правда, заметим, что можно было
не выпендриваться, а заметить, что вспомнить более простой школьный факт, что радиус, проведенный в
точку касания перпендикулярно-касательный. И тогда вот это будет просто теорема Пифагора.
Ну, хорошо, нет. Я согласен. Все, что нет, помните? Теорема степени точки. Ну, окей. Теорема степени точки
дает замечательное знание, которое пользуется полезно. Вообще, в принципе, школьную геометрию
как бы помнить полезно. Вот. Это всегда хорошо. Но так или иначе, короче, вы этот D нашли, альфу вот эту
вы тоже нашли. Ну, потому что, скажем, cos альфа равен, очевидно, D делить на L, а sin альфа равен
просто R делить на L. Ну и дальше решение абсолютно то же самое. То есть поворачиваем этот вектор и
нормируем на длину D. Поворачиваем сюда, поворачиваем сюда, вот вам и две точки касания. Не очень сложно,
правда? Ну, это повторение нашего алгоритма пересечения окружностей. Ну, по сути, да. Идейна
тоже. Да, мы могли вылить воду из чайника и сказать, что теперь нам надо пересечь эту окружность
вот окружностью с центром здесь и радиусом. Вот. Ну, как красиво, да. Ну, выливать воду из
чайника выглядит не очень красиво. А вот, ты знаешь, вот тут баланс. Нет, с точки зрения
CPC это не супер, потому что тебе эту библиотеку потом придется переписывать, и чем она у тебя более
взаимозависимая, тем больше ты ее будешь переписывать. Вот. Это раз. Во-вторых, в реальной жизни на самом
деле тоже надо еще внимательно думать, потому что, как бы, чем больше ты используешь эти примитивы,
тем больше ты заинтересован в том, чтобы эти примитивы побыстрее работали. Вот. То есть, конечно,
можно написать прям красиво, но если там один примитив будет использовать пять других примитивов,
вместо того, чтобы напрямую использовать формулу, то он будет работать в 10 раз дольше, чем мог бы.
И это тебе может там в каких-то приложениях просто критично навредить. Поэтому тут баланс. Вот. Так
что, да, это тут вот. Так что, касательная тут такая. Вот. Так, что у нас еще? Так, ну, конечно,
здесь нельзя не упомянуть о том, как построить общая касательная к двум кругам, но каждый из
которых, естественно, расположен вне друг друга. Но тут, конечно, есть подлянка в том, что общих
касательных тут, вообще говоря, четыре. Раз, два, три, четыре. И каждую из них надо искать. Но искать
достаточно просто. Смотрите. Потому что, на самом деле, допустим, у нас есть R1 и R2. И, допустим,
оказалось даже, что R1 меньше, чем R2. Ну, в случае чего свапнемся. Тогда внешние касательные можно
найти так. Давайте построим здесь вот такой прямоугольник. Вот. На вот этих точках касания
и центре меньшей окружности. То есть, заметьте, это прямоугольник. То есть, вот эти прямые параллельно.
Вот. Тогда здесь образуется треугольник. То есть, это вот длина, вот эта длина этого перпендикуляра.
Ну, то есть, так, вот это расстояние, это L, это мы знаем. Это R2-R1. Эту штуку мы теперь
потерями Пифагора находим. Ну, а самое главное, находим вот этот угол. То есть,
действительно, поворачиваем, нормируем. И еще надо просто перенести его в правильную сторону на перпендикуляр.
Что? Я так? Сейчас. Откуда вы знаете, в каком направлении идет вообще касательный? Что значит в каком направлении?
Откуда вы знаете направление вот этого вот? А очень просто. Смотрите, я поворачиваю на угол альфа против часовой стрелки, допустим.
Откуда вы знаете? Ну, вот. Ну, я его синус знаю. Нет. Знаю. Ну, я... Как вам все еще нужно направление? Нет, нет.
Нет, нет. Альфа я не в направленном смысле знаю. Потому что я, как бы понятно, я на тот же угол альфа поворачиваю в эту сторону и поворачиваю.
И получаю тем же способом вот эту касательную. Ну, скажи так, я нахожу вот эту вот, то есть вот эту вот штуку.
Как вы находитесь? Вы не знаете, какая... Прекрасно знаю. Я вот эту альфу поворачивал, делал поворот здесь на альфа против часовой стрелки.
Потому что я захотел. Потому что я знаю, что если я поверну против часовой стрелки, я найду одну касательную.
Если я сделаю по часовой стрелке, я найду другую.
Вы не знаете радиус сам? В какую сторону он повернут? Откуда вы это знаете?
Какой радиус? R1, R2 я знаю.
Миша, ну ты же знаешь два катета. Ну, в смысле, такие потянувшие катеты.
Ну, в смысле, да. Вот эту штуку я знаю. Это расстояние между центрами.
Эту штуку знаю.
Эту я знаю. Это просто разность между радиусами.
Ну, а что мешает?
Еще я знаю, что это треугольник прямоугольный.
Ну, по сути, да.
Можно и так сказать, да.
То есть давайте я тут сдую обе окружности в R1 раз.
И получится, что я тут по сути... Вот это вот все, что я делаю, это я ищу касательную.
Сюда.
Окей, а потом мы уже знаем направление, знаем укасательную.
Ну да, то есть я должен повернуть вот этот вектор на 90 градусов тоже против часовой стрелки.
Хорошо.
А что происходит с внутренней касательной?
А внутренней укасательной придется искать по-другому.
Смотрите.
Нет, здесь идея очень простая.
Берем R1 меньше, R2 больше.
Так вот, теперь я сделаю читерским способом.
Так, вот у меня тут какая-то вот такая касательная.
Вот какая-то вот такая.
Так вот, у меня идея такая.
Давайте я эту окружность сдую в точку, а эту наоборот.
Там неожиданно раздую на радиус R1.
То есть я хочу, чтобы вот это было R2 плюс R1.
Тогда я утверждаю, что вот эта касательная просто превратится в касательную из этой точки.
Ну тоже самое.
Вот.
И дальше, ну вот.
Ну да, и дальше будет вот буквально опять тот же прямоугольник.
Тут уже R1 будет.
Ну вот, тут будет какая-то L.
И в общем-то, ну короче, вы поняли.
Вот.
То есть общие касательные можно искать так.
Ну вот, ну впрочем, да.
Впрочем, это еще не самое веселое.
Сейчас, видимо.
Нет, понимаете, дальше просто начинается самая интересная задача в этом блоке.
Задача будет называться построить касательную к выпуклому многоугольнику.
Давайте уже раз анонсируем.
Вот, да, она там.
То есть ну как сказать, мозг повзрывать придется, но кажется, что после этого будет больше.
Ну, конечно же, можно и будет.
А вот, вот.
И вот так.
Ну да, и вот.
И вот так.
Вот так.
повзрывать придется но кажется что после этого будет если если я тут ничего из этого блока не
упустил можно будет такие тогда поговорить либо про торнарный поиск либо про выпуклые оболочки
ну все зависит от порядка потому что сегодня хочется обсудить и то и то но у нас есть но я
уже сказал сегодня у нас большое занятие выпуклости да торнарный поиск это важная
часть занятия выпуклости кстати вот да нет у нас практически все сегодня выпуклости вот
если успеем то может быть даже у нас сегодня конверт халтрик возникнет на самом деле а там
мне там есть а там таки есть что обсуждать великий и могучий конверт халтрик ну постараемся но тут
не ну совсем без отвлечений сложно потому что отвлечение помимо всего прочего это как бы способ
немножко там выдыхать в процессе вот значит смотреть и так значит задача дан выпукло многоугольник
и дана точка вне его надо найти касательное к многоугольнику кстати да здесь уже можно
определить а что такое вообще касательное вот что такое вообще касательное к многоугольнику
потому что тогда это это определение будет считать что вот это вот это не касатель
вот да ну можно говорить через вершину да но на самом деле я бы обобщил немножко
смотрите давайте я скажу так ну можно сказать так предположим что у нас есть замкнутое выпуклое
множество ну давайте пусть будет ограниченное для удобства но чем оно не обязательно ведь оно
не обязательно вот с этими углами потому что оно может быть и овалом каким-нибудь или
круг кстати подходит тоже да так вот я люблю определять касательную и кстати это вот очень
удобно действительно так определять мыслить именно в таких терминах следующим образом значит
рассмотрим угол любой угол от нуля до 2 пи и для каждого из этих углов вот существует направленная
прямая с направлением альфа вот такая так вот я хочу сделать вот что я хочу такую прямую
где-нибудь далеко далеко далеко начать нарисовать от многоугольника и двигать ее относительно себя
влево так чтобы фигура полностью оказывалась слева от этой прямой вот и результате у меня
получится что касательное в направлении альфа это такая прямая которая проходит через хотя
бы одну точку множество и при этом оставляет и при этом все это множество лежит в левой
полуплоскости относительно этой прямой до прямая направленная то есть ну чтобы у нас за но то есть
у нее есть напарник такой параллельный напарник угол пи плюс альфа а именно
касательно через точку где мы изменяем угол да но не касательно который мы угол фиксируем но
изменяем положение но нет ну не совсем так заметь я утверждаю что ну пока по каждому углу касательно
ровно одна да для многоугольника заметим что через точку можно провести несколько касательных
да я имею в виду что мы можем фиксировать угол и искать касательно вот таки да а можем
фиксировать но в принципе да нет ну на самом деле нет но определение на самом деле более
менее согласуется вот потому что часто нам имеет смысл воображать даже множество этих касательных
в целом а на самом деле касательно можно еще воображать себе так смотрите давайте я возьму
какую-нибудь прямую вот так вот прижму ее к многоугольнику да и дальше я хочу ее поворачивать
влево постоянно прижимая к многоугольнику вот будем ее прижимать прижимать прижимать прижимать
тогда она значит некоторое время будет вращаться вокруг вот этой точки и пока она не упрется на
следующие ребра после этого она ночью мы начнем ее вращать уже вот здесь ну и таким образом на
самом деле если у провернуть касательную на 360 градусов то она прям вот многоугольник обойдет и
вернется в исходную точку но это просто такой образ который вот полезно иметь потому что на
самом деле на этом образе будут базироваться решение нескольких задач которые мы будем
рассматривать вот вот такая красота но нас интересует сейчас немножко другое нас среди
этих касательных нас сейчас интересует конечно какая-то какие-то две касательные которые
проходят через заданную точку какая-то вот такая касательная и какая-то вот такая
вот как же это сделать
вот ну здесь тоже вопрос в аккуратности потому что понятно что если вы там дать
вам пять минут подумать то скорее всего это какие-нибудь бенпольский придумать
просто нельзя просто ну посмотреть с каждой из точек с каждой из вершин
можно но только вот и ну хорошо ты вот возьмешь первую попавшуюся вершину
хочется залог вот то есть залог отдельная песня потому что но смотрите просто тут
идея на самом деле оказывается давайте предположим что нас многоугольник идет против часовой стрелки
что это означает это означает следующее что вот если мы стоим если мы опять пустим козу по
многоугольнику а сами стоим в этой точке да то есть здесь коза топ на этих ребах коза будет
идти как бы направо а вот на этих ребах коза будет идти как бы налево от нас требуем но касательно
конечно мы к выпуклу многоугольников но если коза бегает по выпуклу но нет то есть там
скорее всего вы просто тогда сводится касательно их выпукло оболочек да тогда
за то что у нас у нас выпукло многоугольник да все нормально вот то есть в принципе нам на
самом деле то есть у нас есть ребра которые смотрят налево есть ребра которые смотрят
направо и надо просто найти две граничные точки по сути правда понимаете да ну да ну налево
это значит что векторы произведения вот этого на этого больше нуля ну как бы смотрите вот
то есть как бы вот здесь точка кого-то налево поверить когда тут идёт точка она вот как бы
вот так идет вот то есть вот это вот да то есть проверки ну произведение вот то есть мы просто
ну да но единственная проблема что как бы да если если мы знаем одну точку касания то вторую мы
естественно бенпольском без труда найдем но проблема в том что мы заранее ничего не знаем но значит
идея оказывается такая но единственное что мы знаем если мы возьмем первую попавшуюся точку то
мы за от единицы легко поймем она лежит на вот этой дальней часть который идет налево или на
ближней части который идет направо правда вот допустим выяснилось что она лежит на дальней
части тогда смотрите какая у меня неожиданная идея вот давайте мы это вот вот возьмем пусть
она лежит на дальней части тогда оказывается смотрите я давайте я сейчас этим ребрам присвою
ципы вот это будут ребра до точки касания здесь будет ребра первого типа потом между точками
касанье второго типа а после второй точки касания третьего типа надо найти границу между
рубрами первого второго типа и ребрами второго третьего теперь внимание вопрос дано ребро как
определить его тип ну и как так ну поверь PRESID мы легко определим она второго типа или какого-то
А теперь у тебя вопрос, как отличить первый тип от третьего типа? А что значит до или после? Это нулевая точка, напоминаю.
Да, потому что заметим, что ребра третьего типа лежат справа от этого луча, а это слева.
То есть поэтому по любому ребру вы теперь легко определяете его тип, и получается теперь можно просто любым бинпоиском найти границу между первым тип и вторым.
Минус решение в том, что тут приходится рассматривать случай, потому что мы предположили, что мы взяли первую попавшуюся точку, и она лежит на дальней части.
А если она попадет на ближнюю часть, то тогда вам придется делать абсолютно то же самое, но типы тут будут немножко инвертированы.
А элементарно вы рассмотрите два ребра, и как вы говорите, эти ребра идут вправо, вот здесь они идут вправо, а здесь они идут влево. Напоминаю, у нас многоугольник против часовой стрелки ориентирован.
То есть нам вообще и важно такое ориентация?
Ну да, это нам, к сожалению, принципиально. То есть можно, наверное, эти два случая реализовать единым образом без копипасты.
А еще придется учесть случай, если мы случайно попали в точку касания сразу.
Но тем не менее, это, кажется, одно из самых красивых и надежного, что тут можно написать.
То есть вы это пишете?
Ну да.
Общий касатель.
Так, вот это отдельная песня.
Да, ну тут так, да, тут так, конечно, не получится. Хотя нет.
Нет, слет у меня будет даже вопрос.
Нет, ну смотрите, на самом деле...
Но на самом деле, да, нет, хороший слет и вопрос, на самом деле, да.
Задачи даны, не пересекайте выпрыгного угольника, найдите общие касательные к ним.
Но на самом деле, здесь на самом деле вот эта вот цель.
Что?
Вращающийся сканлайн может вам неожиданно помочь.
Так, нет, давайте подумаем.
Хорошо, вот у нас...
Так, да.
Так, да.
Так, нет, давайте подумаем.
Хорошо, вот у нас...
Вот.
Действительно, что же делать, если у нас два выпрыгного угольника?
Так, в принципе, да, у меня слету возникает такое вот решение.
Значит, давайте будем вращать сканлайн.
И давайте допустим мы начнем с какого-нибудь более левого многоугольника.
Ну какого-то многоугольника, наверное, есть самая левая вершина, правда?
Да.
Вот. И начнем вот с этой касательной вертикальной.
Вот.
Вот.
Так вот.
Идея, на самом деле, такая.
То есть, очевидно, что в этот момент времени у вас, наверное...
То есть, второй многоугольник будет относительно этой касательной слева, правда?
Согласны?
Да. Нет, второй...
А, если вот так, то слева.
Вот.
Тогда смотрите, какая идея возникает.
Если я буду вращать эту касательную, то некоторое время у вас этот многоугольник все еще будет слева, да?
То есть, мы тут будем рисовать вот так касательную, вот так касательную.
Поворачиваем, поворачиваем.
И вот, бах-бах, мы наткнулись на внешнее общее касание.
Да?
Ну как?
Мы наткнулись на...
Ну, не совсем на это.
Вот.
Нет.
Ну, в какой-то момент...
Нет, ну, в какой-то момент касательная нота...
Вот.
Ну, в какой-то момент...
Ну, как бы да, смотрите.
Вот у нас прямая как-то крутится, вот ее направление.
Правда, иногда тут еще поворачивается, да?
Но и как бы многоугольник оказывается у нас слева.
Вот.
Причем...
Ну вот.
Ну и в принципе утверждать, что в какой-то момент мы наткнемся на многоугольник.
Причем более того, относительно точки касания на самом деле мы...
То есть, этот многоугольник будет впереди.
Вот.
Ну, потому что, видите, мы тут как бы смотрим вниз, и тут пока угол такой.
Вот.
Мы наткнулись.
После этого некоторое время прямая будет поворачиваться-поворачиваться,
и она будет пересекать этот многоугольник.
Потом наткнется вот эта какая-то вторая общая касательная,
после которой мы заметим, что тогда у нас многоугольник неожиданно окажется справа.
Ну, как бы, все ли на этом?
Нет, потому что сейчас у нас теперь многоугольник полностью лежит справа от него.
Потому что на самом деле будут еще два события.
Будет еще вот событие, когда мы наткнулись опять на многоугольник, но уже задом.
То есть, тут он был многоугольник спереди, а там был сзади.
Вот.
И тоже он там пробежится-пробежится, но хвостом мы его тоже заметем,
и после этого мы вернемся сюда.
Это же правда, что если мы можем...
Вот тут мы взяли самую большую часть.
А если мы возьмем теперь самую правую и также по ней на два пройдем, то это будут два других.
Чего правую, какое правое?
Ну, хочу взять самую правую, прямую, посмотрящую вверх, пройти по ней, тоже найти две касательные.
Нет, ну тут аккуратненько.
Там, знаете, там же...
Нет, там дальше как начнутся всякие случаи вида пум-пум-пум-пум и пум-пум-пум-пум,
так что поаккуратнее надо.
Так что, честно скажу, лучше опираться на один многоугольник.
Ну вот, то есть суть на самом деле в том, что у вас по сути есть четыре события,
и как бы, ну вот, и надо просто, возможно, в каком-то бинпольске уметь аккуратненько
отличать один случай от другого.
Ещё там вопрос, когда она перепрыгнула, то есть если мы этоiera, то почему мы ее мылим Evans?
То есть если мы мылим Ronin, то есть если мы мылим Ronin, то есть если мы мылим Ronin,
то что мы мылим?
Еще там вопрос, когда она перепрыгнула, то есть она была полностью слева, а потом стал не
полностью слева, нам нужно понять на какой наклон проворнуться, чтобы именно попасть в многоугольник.
Ну вот, на самом деле, смотрите, да, можно, но слету я не очень понимаю,
можно ли как-то сделать за линию, если честно. Потому что слету я, например, понимаю,
как это сделать за N лог N какой-нибудь. Ну, например, самое тупое, что можно сделать за N лог N,
сделать просто, во-первых... Чего? Почему N лог N даже? Нет, смотрите, дело в том,
что, то есть идея такая, во-первых, мне очень хочется, конечно, понимать вот для
каждой касательной, которая идет вот так, просто вот этой касательной, проверять,
какого она типа. Пересекает ли она многоугольника, если не пересекает, то она от него и проходит справа,
слева или, а если пересекает, ну вот, ну или как. И тогда это сводит нас к другой задаче,
вот вообще в принципе задача, кстати, тоже сама по себе интересная. Дан многоугольник дано
направление, приведите к многоугольнику касательную за данным направлением. Ну,
здесь достаточно просто, потому что если вы заранее для многоугольника предпочитаете самую нижнюю
точку какую-нибудь, да, и самую верхнюю точку, да, то есть это вот точки касания горизонтальных
касательных, да, то в принципе вам, когда, если вам дается, ладно, не такое направление,
а какое-нибудь там вот такое, то вы на самом деле по вот этим ребрам просто запускаете бинпоиск,
потому что по сути вот эти ребра отсортированы по полярному углу, и вам нужно просто вот эту
касательную просто в них встать, по сути. Понимаете, да, то есть очень легко, тогда очень легко тут
получается бинпоиск и векторное произведение в них. То есть типа вот если у вас векторное
произведение вот это на это оказалось меньше нуля, значит вам там касательная где-то дальше,
там если это на это оказалось меньше нуля, значит наоборот где-то ближе было. А что тебе не нравится?
Сейчас, а у нас может быть картинка, что мы типа вот, то есть мы идем тут вверх, а там вниз.
Ваня, почему именно верхняя и нижняя, то есть почему именно верхняя и нижняя точка?
Ну просто для... Ну понятно, что подойдут любые... Ну просто чисто может для удобства,
чтобы с векторным произведением было все адекватно. Потому что бинпоиск на полном
многоугольнике не получится, там как бы со знаками векторного произведения проблемы будут.
Вот что ломается, если мы взяли две соседние вершины? В смысле? Не верхняя и нижняя, а две соседние.
Ну ломается то, что не обязательно... Ну просто утверждение такое, что как бы и с этой стороны,
и с этой, верно следующее, что для любых двух касательных, проведенных к одной стороне,
верно, что одна идет раньше другой тогда и только тогда, когда у них векторное произведение больше 0.
Если ты возьмешь две соседние точки, возьмешь там только касательно вот эту и эту, то там вот на вот
этой вот штуке на самом деле это уже не так. То есть касательная, то есть вот эта вот векторная
умноженная на вот это может дать уже и меньше 0 вполне. То есть если тут поворот больше 180 градусов.
А там утверждается, что никогда не будет поворота? Нет, а тут не будет. Смотри, я специально взял
шлок, две горизонтальные касательные. Это две касательные, между которыми угол 180 градусов
ровно, что в одну сторону, что в другую. То есть тут как бы все касательные вот в этой
стороне, с этой стороны они смотрят вверх. Вот. То есть вот в чем идея на самом деле. Вот. То есть
видим, что касательную в заданном направлении можно находить за логарифом. Ну и тогда получается,
если ваша задача дан луч проверить, пересекает ли он многоугольник, а если нет, то он там проходит
него справа или слева, то надо просто построить касательную в этом направлении и посмотреть,
где она ниже этого луча или выше.
Честно, за логарифом построю из этой вот вершины касательную. Потому что вот этот угол...
Мы только что научились из точки касательной многоугольника за логарифом строить. Да,
вот так вот как-то. Вот. Ну на самом, да. То есть, в принципе, поэтому за n лог n тем или иным
способом можно. Более того, я вам даже больше скажу, на самом деле есть подозрение, что это
можно за o от n методом параллельного вращения. Потому что что нас, в общем-то, сейчас интересует.
Интересует вот что. Смотрите, как это сделать за лигию. Вот. Смотрите, то есть идея такая. Давайте
нарисуем две вертикальные касательные и будем их параллельно вращать. Очевидно, то есть в какой-то...
Сначала у нас, допустим, одна касательная находится правее другой. Но очевидно, нас, на самом деле,
интересует случай, когда в какой-то момент эти касательные неожиданно совпали. Правда? То есть,
пока мы вот до нее поворачиваться будем, у нас эта касательная будет правее. Правда? Вот. Идем,
идем, идем. Ну вот они наткнули. Что будет происходить после этого? После этого эта касательная будет
некоторое время левее. Вот как-то так это будет выглядеть. Вот. Видно, да? Но дальше произойдет
следующее. В какой-то момент мы, то есть в какой-то момент, мы неожиданно обнаружим, что, то есть,
ну, в этот момент, в общем-то, начиная с этого момента, вот эта левая касательная пересекает
многоугольник. Правда? Видно, да? Значит, она идет, идет, идет. И вот в какой-то момент мы наткнулись на
вот эту вот вторую общую касательную. Ну вот. В это, ну вот. То есть, после этого она пересекать
перестала. Но заметим, что, кстати, вот эти вот аккуратные повороты и ситуации, когда они наложились,
вот эти касательные, можно отслеживать прям за линию. Таким вот двумя, потому что мы тут повороты
будем делать, естественно, двумя указателями. Вот. После того, как мы их повернули. Ну вот. То есть,
в результате, ну вот. И, в общем-то, когда отследить, то есть, если вот эта вот касательная начала
пересекать многоугольник, то, в общем, где она его пересекает, какие конкретно стороны пересекает,
мы тоже можем там вот этими двумя указателями аккуратно отслеживать. В результате, в какой-то
момент, в каком-то направлении у нас мы найдем вот эту вот левую касательную, такую вот
аккуратненькую. Вот. И наткнулись это. Ну вот. Нет, ну просто это если одним превращением. Да,
потому что можно сказать, что это, да, можно говорить о том, что давайте вращать не две с
направленной касательно две разнонаправленные, а так пока это игнорировать. То есть, пока мы
просто поворачиваем эти касательные, поворачиваем, поворачиваем, просто веришь, что в какой-то момент они
опять наложатся друг на друга и таким образом мы найдем. Да. Да. Ну, то есть получается, да, что если
ваша задача найти только две внешние касательные, то с этим заморачиваться не надо. То есть, просто
поворачивайте, там ловите моменты, когда там касательные поменялись местами один раз, потом
ловите момент, когда они наложились второй раз. То есть, обогнали друг друга второй раз. И вот вам и
две касательные. И это, в принципе, уже делается за линию. Ну да. То есть, как бы, если вы хотите
внутреннее, то, по сути, да, надо просто вращать, то есть вращать просто разнонаправленные, но
разнонаправленные касательные. Так что вот такое красивое мясо у нас получилось. Не, ну,
а что, хорошее мясо. Такое глобальное. Стоп, они же не параллельные. Почему? Ну, они почему?
Параллельные, но просто с 80 градусов. Мы же их также можем поворачивать. Они же вот так будут двигаться. Нет,
почему? Я же их обе буду против часовой стрелки вращать. То есть, они как-то вот так начнут
двигаться. В чем проблема? И будут всегда внешние. Ну нет, почему? То есть, как бы, это касательная
прижатка к этому нугольнику, это к этому, они там бу-бу-бу, и в какой-то момент они вот наложатся вот
здесь вот в момент вот этой касательной общей. Так что вот. Так, то ладно, кажется, вроде все,
это все, что хотелось. Давай еще, давай-давай. Ну да. Ну, когда они обгонят друг друга. Вот. То есть,
ну просто в этих вершинах мы видим, что это касательная левее вот этой. Потом мы их там
поворачиваем на угол, либо вот на этот, либо на этот, вопрос кто меньше. Кстати, тоже отдельное
упражнение как с помощью векторного произведения. Там без всяких вычислений в явном виде углов,
на кого надо поворачивать. Значит, повернули. Проверили. Верно ли, что это касательная все
еще левее этой? Окей. Повернули еще, проверили, что это все еще левее. Поворачиваем в качестве
в какой-то момент. Проверяем, лежит ли это касательная левее. Ой, не лежит. Упс. Ну, вот
эта прямая лежит левее вот этой. Ну, то есть, если я встану на эту прямую и буду смотреть на нее,
вот эта касательная будет лежать левее. Да, вот ровно в момент касательной. Мы,
конечно, не знаем, когда наступит этот момент касательной, но мы знаем, что будет
там перед этим какой-то момент, вот когда эта касательность, скажем,
через эту прямую проходила, и тут касательная была левее, ноpartоом мы, допустим, повернулись вот до
этого ребра, и тут вот эта касательность стала неожиданно правее, чем вот этой вот. И
И тогда мы знаем, что где-то между ними есть общая касательная, и по сути,
это, видимо, и будет означать, что эту касательную надо просто через вот эти две вершины провести.
Вот у вас заступил момент, когда действительно у вас тут произошел обгон.
Теперь вы просто на самом деле идете дальше и ждете следующего обгона,
просто вы знаете, что там произойдет второй обгон.
И этот второй обгон произойдет ровно, когда будет вот эта вот та самая общая,
вторая общая касательная внешняя.
Вот и все.
В самом деле такая.
Просто как вообще действительно можно решать такую задачу?
Но здесь, конечно, рекомендуется просто метод...
Нет, почему нормально?
Ну, можно применить метод сканирующей...
Можно же там афинное преобразование применить всегда.
Значит, есть метод сканирующей прямой.
То есть что он означает?
Ну, то есть вот у нас есть какой-нибудь многоугольник, как всегда, экзотический, да?
Там вот какого-нибудь такого там мерзопакостного года.
Вот.
Ну ладно, я остановлюсь на этом.
Вот.
Значит, будем идти с канлайном.
В каждый момент времени у нас есть...
Ну, точнее так, почти в каждый момент времени.
Значит, наш вертикальный сканлайн种 небольшой,
гело-гело-гело-гело-гело.
Вот.
Ну, в общем, вот это вот.
значит, наш вертикальный сканлайн пересекает несколько
отрезков.
При этом мы видим следующее, что если идти сверху вниз,
то некоторое время сканлайн идет вне многоугольника,
потом идёт внутри многоугольника, потом вне, потом внутри,
потом вне, потом внутри и потом вне, потом вне,
внутри, вне, внутри, вне,展е, и дальше уже идет на бесконечность
естественно вне.
Более того, в принципе, если вот таким сканлайном
идти, то мы замечаем, что эти отрезки у нас некоторое
время фиксированы, но в какой-то момент там появляются
новые.
То есть когда-то появляется вершина, и это означает,
что у нас тут мог появиться даже два новых отрезка,
или исчезнуть два отрезка.
Вот видно, да?
Ну или мог один закончиться, а появится новый.
Но идея тогда такая.
Ну, по крайней мере, давайте просто сейчас обсудим идею,
после этого будем обсуждать технические детали.
Предположим, что в какой-то момент сканлайн наткнулся
на точечку.
То есть у нас обычно есть два типа событий, то есть
какие-то события, типа отрезок начался, отрезок закончился,
и мы наткнулись на точку.
Ну вот, тогда идея такая.
То есть давайте, допустим, мы эти отрезки храним в
каком-нибудь, в чем-нибудь типа сета.
Тогда если вы наткнулись на точку, вам надо проверить,
сколько отрезков в этом сете находится ниже вашей
точки.
Если их оказалось четное количество, то точка вне,
если нечетная, то она внутри.
Ну или если в каком-то отрезке она там оказалась с помощью
сета, его тоже находите, то тогда она просто на нем
и лишит.
Понятная идея, да?
Да, нет, наверное.
Вот, хорошо.
На уровне идеи все красиво.
Но дьявол, как всегда, кроется в белочах.
Какие тут мелочи возникают?
Ну, начнем с того, что сет не скажет вам.
Ну, во-первых, да, вопрос.
Какой компаратор сету скарбливать?
Ну, если вы храните эти отрезки в сете, то сет же требует
не просто отрезки, а еще и компаратор.
Так вот, какой компаратор сету скарбливать?
Ну, это еще полбеды, потому что скарбливать-то понятно,
что для любых двух отрезков можно определить, какой
отрезок находится ниже или выше.
Нет, в общем, не обязательно динамически.
Если данные два отрезка, у которых проекции по Х пересекаются,
то вы можете просто определить, кто ниже, кто выше.
То есть там, конечно, придется рассматривать такое,
что, имейте в виду, что когда вы рассматриваете вот этот отрезок,
вот этот отрезок, то этот вы должны рассматривать как более высокий.
Вот там вот всякие такие подлянки начинаются.
Вот.
Но как бы допустим, это тем или иным способом
завод единицы решается.
Дальше что?
Ну, дальше возникает проблема.
Сет не скажет вам, сколько элементов находится меньше задного.
И дело даже не в том, что эту точку надо еще оформить
как отрезок и пихнуть в сет.
Но как бы проблема в том, что сет умеет искать
какой-нибудь лавербаунд и пербаунд.
Но он не умеет сказать вам,
сколько отрезков находится ниже или выше.
Ну, тут разные варианты.
В разной степени тупизны.
Первый сет тупизны.
А что?
А что сет прямо стрелевский надо?
Давайте-те картячку напишем.
Все берем и пишем.
Кстати, у такого метода есть преимущество,
что если вы это поняли, что вам надо не это,
чуть другое, то в дикартячку вы поправите быстро.
Там у вас больше возможностей.
Но минус в том, что придется писать дикартячку.
Какой еще метод?
Есть, конечно, знаменитый,
есть, конечно, как всегда, его величество
гну, что-то там, по БДС.
Да, знаменитый, да.
В широко известные в узких кругах
изучавших не просто C++, а конкретные компиляторы.
Потому что в стандарте этого нет.
Стандарт про это не знает.
Но в гнушных компиляторах
есть специальные виды двоичных деревьев поиска,
в которых можно делать что-то более умное.
Например, как видим, самое простое применение
на катую порядковую статистику в сетах находить.
Да, можно так.
Но есть, конечно, более наглотие.
Я утверждаю, что на самом деле с сетом обойтись можно.
Идея такая.
А давайте заявим, что у вас многоугольник
идет против часовой стрелки.
Можем такое сказать?
Тогда смотрите.
Вот жила была точка.
Допустим, вы там в сете нашли ребро,
ну там как бы гловербаундом нашли
первое ребро, которое не ниже.
И быстренько за вот единицы поняли,
не лежит ли точка на нем.
Тогда как определить у вас точка внутри или вовне?
Да очень просто.
Вам нужно просто на этом ребре было бы
хрорить какую-нибудь информацию на тему того,
а при обходе против часовой стрелки
оно идет туда или туда?
Потому что если оно идет, скажем, туда,
то вы легко понимаете, что это точка вне.
А если в эту сторону, то, наоборот, внутри.
То есть на самом деле,
обычный STD-сет
прекрасно решает.
Прекрасно решает.
Вот.
Состик, кстати, неожиданно.
Я про сколько лет это рассказываю,
мне только сейчас в голову пришло.
Вот.
Миша, тебе это тоже пришло?
Зачем? У меня есть ордер и цепь.
Нет, ну да, потому что популярный метод
ордер и цепь это как бы сейчас
просто де-факто может быть стандарт.
Но на самом деле, в ордер и цепь
в ордер и цепь тут необходимости нет.
Потому что надо. То есть если вот...
Ордер и цепь это в принципе то,
что у вас получится, когда вы возьмете...
То есть это тот вот, это сет из ПБДСа,
который умеет в какую порядку и статистику.
Ты его можно назвать не ордер и цепь,
а, например, different equation course.
Там type-d.
Вот.
Ну, короче говоря, не надо этот ПДС,
вот просто так делайте и все.
Хорошо.
Ладно.
С эту задачку исправили.
Но есть другая подляночка.
Есть еще такая веселая подляночка.
Такая веселая подляночка.
Она заключается в том...
Значит, она заключается в том, что
есть вертикальные отрезки.
Ну, повернуть сказали.
Да нет, можно их предварить.
Нет, тут как всегда два варианта.
Можем сделать так, чтобы вертикальных отрезков не было.
Для этого, если хотим целых числах,
то у нас есть афинное преобразование какое-нибудь.
Вот.
Но это, я боюсь, может привести
к каким-то проблемам с типами.
Вот.
Второй вариант отдельно проверить.
Да, можно обнаглеть.
Можно сказать так,
что давайте считать, что у вас
вертикальных отрезков нет вообще.
Потому что в любом ином случае
все, что вам нужно, будет это
данный набор вертикальных...
Под задача мелкая.
Данный набор вертикальных отрезков.
И данный набор точек.
Для каждой точки скажите, пожалуйста,
не лежит ли случайно эта точка
в одном из этих вертикальных отрезков,
да или нет.
На самом деле плюс этого подхода в том,
что мы также обрабатываем вершины,
которые вертикальные отрезки длины 0.
Потому что если точка попадает в окрестность вершины,
там не особо приятно в самом сете происходить.
Но если плюсепсию написать...
На самом деле, я утверждаю,
что если правильно написать...
То есть если правильно написать,
сортировать события при одинаковых х,
то на самом деле этого всего не надо.
Я верю, но я
несколько раз пытался правильно сортировать,
но до конца правильно так и не смог.
Багу словил много, поэтому...
Понятно, понятно.
Теоретически такое есть.
Была под задача.
Куча вертикальных отрезков и куча точек.
Для каждой точки, скажите, пожалуйста,
лежит ли она хоть на каком-то из этих отрезков.
Эта задача, понятно,
тем или иным способом решается.
Например, отсортируем все отрезки
по х при равных х,
естественно, по высоте.
Для каждой точки вы просто бинпоиском найдете
нужный отрезок, если он есть.
Логично, да?
Так что...
Можно это отдельно написать.
Для программистов вашего уровня
это проблемы не будет.
То есть для каких-нибудь
восьмиклассников на регионе это могло быть
полноценной едва ли не третья задача, конечно.
Ну ладно, вторая.
Хорошо, вторая.
Хотя нет, вторую сейчас полегче дают.
Все-таки скорее третья.
В первый день, конечно.
Вот.
Ну во второй там уже...
Нет, во второй что-то помощнее дадут.
Там, причем, такой стандартный
тоже геом, здесь тоже там.
Потому что у нас будет, например,
стандартная задача на сканлайн,
это найдите какую-нибудь площадь объединения
прямоугольников со сторонами параллельными
А7-координат.
То есть там, по-моему, на регионе
была едва ли не такая задача.
Вот. Ну окей, доживем.
Значит, смотрите, это у нас вертикальные прямые.
Ну, то есть можно их так делать.
Но на самом деле я утверждаю, что если
очень-очень-очень аккуратно сортировать
события, то на самом деле проблем не будет.
Потому что мне, например,
хочется сделать вот как.
Значит,
события придется...
Я предлагаю при равных х...
Значит, при равных х...
Я предлагаю так. Во-первых,
я предлагаю при равных х
все события сортировать, естественно,
по игроку.
Понятно, да?
Далее.
Еще я предлагаю,
при равных х сортируем
по игроку.
А, ну да.
Но тогда, в общем-то, остается
только одно.
Тогда нам
еще останется...
Что нам останется?
Останется нам следующее.
Останется только, надо понять, что делать,
если у нас в точке
сомкнулись два события. То есть у нас же в точке
могли сомкнуться два события, если это вершина, правда?
Что?
Нет, ну два события
с одинаковым х и одинаковым игроком.
Ладно, могло быть три, ладно.
Но два отрезка сомкнулись,
и это еще и точка сверху.
Ну, кстати, да, совсем в принципе, конечно,
это можно решить сразу, точки закидаем в сет,
и там для запросов всех выясним,
не вершина ли это.
Это как бы уже совсем...
Можно эту мелочь написать.
Можно в принципе попробовать и об этом.
Можно говорить, что при равенстве
игроков тогда сортируем
по классическому порядку, что сначала
событие, типа, отрезок начался,
потом событие,
значит, соответственно, точка из запроса,
а потом событие,
отрезок закончился.
Но там, правда, в сете
будет еще такая...
Но там еще будет, конечно, маленькая техническая проблема,
что два события вот
такого вида, на самом деле, не понятно,
как сортирать, потому что для этих двух отрезков не понятно,
кто из их отрезков выше, а кто ниже.
Хотя, видимо, любой адекватный компаратор
в этом плане должен сказать, что боевая ничья.
Да, проблема.
Поэтому придется, да, что... Если произошла
такая ситуация...
Боевой ничью нужно разрешать каким-то любым
детерминированным образом какую-то историю?
Нет, ну да. Но хочется просто ее
детермируй так, что сначала появится это событие,
а потом исчезнет это. Ну, чтобы у вас не было
ни в коем случае времени. Поэтому, видимо,
придется для удобства считать,
что конкретно...
Хочется конкретно в этом случае считать, чтобы вот этот
отрезок, конечно, был ниже
вот этого. Конкретно в этом случае у вас
это может быть... Если у вас еще точка
запроса пришла в ту же вершину,
то у вас может быть это
угол внутри,
а может быть и снаружи.
В зависимости от этого вам нужно в разном
порядке добавлять и удалять вот эти
два отрезка. Ну вот поэтому я хочу, чтобы вот
если... Ну да.
Из-за этого либо нужно отдельно обработать
запросы в вершину,
что я и сделал, или
что мы уже обсудили, либо там вообще
не получится в нормальном порядке отсортировать.
Нет, а зачем нам этот порядок?
А, ну да.
Ну просто нет, я отражаю так,
что если зафиксировать так, что
вот этот отрезок будет
ниже вот этого, и при этом
мы зафиксируем, что при равных
иксах и равных игроках
мы сортируем именно в этой ситуации,
тогда у нас сначала добавится этот
отрезок, потом мы проверим точку, убедимся,
что он там где-то лежит,
потому что мы лавербаундом найдем вот этот отрезок.
Нет, у вас
могло быть четное число отрезков,
и что?
Сейчас, ну короче,
у вас четность
может нарушиться.
Да, но если вспомнить, что мы только что придумали метод,
в котором нам на четность вообще
начхать. Ну
в этом методе четность.
То есть обратите внимание,
вот это у этого метода неожиданные преимущества,
нам начхать на четность,
то есть нам начхать на четность, там важно
только направление.
Ну короче про нюансы того не могу говорить, но если
да я понимаю это да да проблема согласен вот да в этом плане согласен вот ну там
когда чуть больше будет проблем если тут возникнут всякие вот эти вот
вертикальные случаи в вертикальных случаях надо тоже делать аккуратно что я
отрижаю что надо делать просто что типа сначала добавят то есть ну правда если
мы будем соревновать сначала по иксу по игроку то мы просто в вертикальных
отрезков будем считать что сначала у нас этот отрезок появляется и мы считаем
что его высота ну типа здесь а потом он исчезает его высота типа
здесь но это как если бы как бы чуть чуть повернули там на эп
селом на эп closely вправо то как бы этот отрезок был бы
чуть чуть вот так вот он и да и мы бы смотрели сначала здесь события 84
надо немножко по-другому рассматривать вот то есть правда там согласно этому
методу на самом хотя а нет если нет да у нас проблема чтобы ежа точка попадала
сюда ну вот нет почему тут хочется как раз и убедиться но можно как бы нет
но да но мы ну как смотрите мы с какой целью сейчас общаемся мы сообщаемся
общие идеи это понятно но как бы мы говорим о диаметре хочется максимально приблизиться
к тому чтобы все таки как бы идею доводить до максимально там простого и надежного кода
поэтому поэтому смотрим вот ну то есть вот ну вот ну то есть есть конечно такая надежность что
есть а нам хочется избирать событий происходящих в одной точке при равных x о self и гыках то
это избегается так то есть просто давайте возьмем все лыжие точки для каждой из них проверим не
является ли она вершиной, ну как мы это проверим, запихнем вершины в сет и все, правда?
Как мы от нашего метода комбинируем с лотиками?
Так никак, потому что он просто все, я утверждаю, что если у нас рыжая точка не попадает ни в какую вершину,
то на самом деле там все обрабатывается автоматически. Ну там есть, конечно, пара дополнений,
и звучат они так. Потому что, во-первых, если, например, рыжая точка лежит на вертикальном ребре,
обработается это так. Сначала произойдет событие, которое добавит нам в сет это вертикальное ребро,
потом появится рыжая точка, которой мы лавербаундом найдем это вертикальное
ребро и выясним, что рыжая точка на нем лежит, а потом произойдет событие, по которому мы это
вертикальное ребро тупо удали. Все. Получается, вот эта ситуация рыжей точки, лежащей на вертикальном
ребре, она убилась сама собой. В этом случае мелочи на самом деле есть такая. Всякие мелочи
возникают, если, наоборот, тут есть вертикальное ребро, есть какая-то рыжая точка.
То есть, тут, конечно, вот определенные проблемы могут возникнуть. Но, с другой стороны,
тут уже тогда, допустим, у нас тут сверху должно быть вертикальное ребро, но его у нас еще нет. И
вообще у нас тут вообще ничего нет. Но тут тогда возникает вопрос, а куда многоугольник идет дальше?
Потому что, если он идет вот так, то заметим, что этого всего на момент появления рыжей точки
ничего нет, и мы идем просто до ближайшего ребра, которое находится сверху и идет слева от
многоугольника, и по нему мы все понимаем. А если у нас оно пошло как-то вот так, то тогда,
получается, вот это ребро будет, а эти ребра нет, поэтому с этим ребром мы блестяще разбираемся.
Потому что мы его еще не успели удалить. Смотрите, надо максимально аккуратно обрабатывать
ситуации, когда у нас все в одной точке. И знаете, я тут сейчас неожиданно придумал,
чтобы не заморачиваться ни с ними, ни с компилятором. Знаете, что надо сделать?
Надо, если у нас события одинаковые в одной точке, надо сначала выкинуть отрезки.
Хотя нет, это не... Нет, это плохо. Там не работает. Ну да. Там может быть нечетно, а может быть нечетно.
Нет, отчетность тут ни при чем. Тут другая проблема. Вот я бы хотел, что давайте сначала мы все
события убьем, потом все события откроем, а потом вот так. Но тогда просто возникает вот этот вот
случай, в котором мы рискуем не понять, что эта рыжая точка здесь находится.
Короче, лучше не думайте обработать. Короче, если мы обработали, это единообразно не
обработается. Но нет. Я верю, что какой-нибудь способ может быть. Нет, ну в принципе неплохо,
что мы уже придумали в принципе такой сканлайн, который может некорректно обрабатывать только
в ситуации, когда точка является вершиной многоугольника. Все это вообще, просто в отдельный
сет закидываем и не паримся. Вот. Так что в принципе вот такую... То есть это уже можно сказать,
и даже сканлайн оказывается не самый убойный, как выясняется, мы еще и с сетом справляемся.
Окей. Но есть... Но у этой задачи есть еще экзотика. А что делать, если мы не хотим делать это сканлайном,
а мы хотим делать это в онлайне? В контесте нет вообще. Невозможно. Да ладно. Ну на самом деле,
самое интересное, что этот метод можно реализовать таким образом, чтобы точки у вас появлялись в
качестве событий. Да. То есть на самом деле идея в том, что этот сет можно сделать персистентно.
То есть просто прогоняемся сканлайн и храним все версии сета, которые в процессе хранятся.
Тут уже придется дикардачи писать. Ну да. Тут придется. Тут вы ничего не поделаете.
А есть способ без персистентного дикардачи? Мне неизвестен. Так. А так может и есть. Да,
но мне неизвестен. А так в принципе да, да, да. А так в принципе... То есть конечно недостаток
конечно в том, что этот сканлайд вам придется за n log n делать, конечно, не за n. Потому что
каждое событие все-таки так или иначе за логарифом будет. Как вы хотите за n делать? Вот то то и оно,
что никак, я не знаю. Даже не персистентно. Ну да, но у нас пока в принципе даже и в онлайне это
в общем-то n log n очевидно. Нет, ну просто идеально, ну мне кажется, идеальным был бы здесь алгоритм как
бы от n предподсчета и логарифом на запрос. Нет, я сейчас конечно не готов это обсуждать,
но из каких-то идей, из каких-то пары умных книжек возникает ощущение, что может быть даже
удастся доказать, что быстрее, чем за логарифом на запрос вы это не сделаете в принципе. А черт его знает.
Нет, это мы сидим с сетом, может быть просто не надо делать сет. Может существует какой-нибудь
там очередной метод четырех русских. Кто такой Никифор Кузнецов? Ну может я расскажу,
я не знаю. Для этого мне надо, чтобы за ближайший год я как бы откуда-то понял,
как это делать быстрее. Ну может, в конце концов да. А Никифор умеет делать это сканлайн за линию.
Нет, ну все возможно, все возможно, я не знаю там. Нет, это вещь так. Папа, какой папа?
О господи, приходит к нам папа римский. Понятно. Как говорится, бедным папа,
почему только не приходится заниматься. Римский папа смотрится успокоее. Так,
ладно, это был негугуль. Ну ладно, раз уж об этом зашла речь, что еще вообще можно делать сканлайном?
Ну есть, конечно, вариант задачи попроще. Ну там, на самом деле, да, есть две задачи попроще.
Но одна, конечно, абсолютно классическая задача, которую дали в прошлом году как шестую задачу
региона. Или даже третью. Я сильно удивился, но там действительно задача ушла недалеко от каких-то
абсолютно стандартных конструкций вида. То есть дано несколько прямоугольников,
стороны которых параллельный осямкоординат. Ну, например, мне очень хочется найти точку,
которая покрыта наибольшим количеством многоугольников. Ну, например. Или просто мне там
дано куча запросов, и в каждой запрос эта точка, какая-нибудь рыжая точка, мне жутко интересно,
каким количеством прямоугольников она покрыта. Но это задача решать как-то попроще. Да, то есть
здесь просто делаем сканлайн и любая версия ДО, которая вам подходит. Можно сделать прям,
ну если не хочется думать, то можно прям неявное ДО. Вот, то есть как бы понятно,
что речь у нас идет о массовом прибавлении. Если у нас все оффлайн, а скорее всего так и есть,
то можно в принципе координаты сжать и сделать все это нормальным ДО. Ну в онлайн. Ну типа.
Нет, то там такое, да. Вот, что еще есть? Ну, на самом деле, да, есть конечно, то есть там разные,
то есть таким методом с прямоугольниками можно делать очень много чего. Самое сложное,
что можно делать, это допустим, это найти в сумму площадь объединения этих прямоугольников.
Да, потому что в ней приходится дольше всего думать, какое ДО надо сделать.
Ну по сути, да. Ну да, тут просто оказывается, если вы хотите объединения, то вам нужно, понятно,
в каждой точке мы все еще храним, сколько многоугольников у нас проходит, и нам надо
находить, через сколько клетчик проходит хотя бы один многоугольник. Как это сделать? Но это для
этого нужно просто знать, а через сколько клетчик проходит ноль многоугольников. То есть идея
оказывается, что у нас дерево отрезков на прибавлении и минимум, причем вместе с минимумом мы храним
сколько у нас минимумов. Ну либо сделаем просто чуть-чуть дальше, короче, добавим прямую, где всегда ноль.
Ну, например. А, ну да, да, пожалуйста. Да, то есть вот такие на самом деле идеи начинают возникать,
да, но это просто вот, да, ну просто такие технические вещи, иногда вот просто, как все равно, нет-нет,
она правила направится, что такие даже умные люди просто такого не знают. То есть там начинают
там что-то придумывать, что-то это, вот тут ничего придумывать не надо, тут уже все давно придумали.
Вот здесь вот простое, не заезженное решение. Ну или наоборот заешенное. Вот, но тут как бы да,
вот получилось качественно. Ладно, идем дальше. Но на самом деле с конлайном конечно решается
вообще суперкуль, одна суперкультовая задача. Суперкультовая задача называется доно 100 тысяч
отрезков. Скажите, пожалуйста, существует ли два из них, которые пересекаются? Вы все культовость потеряли.
Почему? Что такое все культовость? Если где-то в условии фигурирует пьяница или курение, то сразу
культовость возрастает пропорционально. А, ну да, а типа у нас в контесте это значит называется не
курить. Да, рядом с внутренней точкой. Ну да, но задача тем не менее классическая. Итак,
доно 100 тысяч отрезков пересекаются ли хотя бы два из них? Как решать такую задачу?
Нет. Вот, все еще круче. Мы пройдемся с конлайном. Мы снова пройдемся с конлайном,
потому что дело в том, что пока мы не дойдем до пересечения, мы отрезки, мы все отрезки можем
прям честно хранить. Вот тоже опять у нас уже был компаратор, который по двум отрезкам говорит,
кто ниже, кто выше. Мы в 2D живем, конечно. И мы давайте честно эти отрезки так храним. Но при этом
идея такая, что когда у нас появляется новый отрезок, мы его как бы добавляем в сет. Кстати,
на самом деле есть такая веселая техника, как писать компаратор. Компаратор будет ссылаться
на глобальную переменную y, которую вы будете в процессе с конлайном увеличивать. Тьфу,
ладно, не y, а x. Где он находится? И тогда, когда вы будете два отрезка сравнивать,
он будет просто вычитать x координату одного отрезка, x координату другого и сообщать,
у кого меньше. Значит, смотрите, какой тут возникает неожиданный чит. Чит возникает такой,
что когда у вас появился новый отрезок, вы не просто его добавляете в сет, а еще и проверяете.
Вот смотрите на двух соседей в сети и говорите, а не пересекается ли этот отрезок с кем-то из
этих соседей? А я не сказал, что я закончил алгоритм. Вот. Но в принципе, заметим, что таким образом
можно какие-то пересечения найти. Если компаратор в какой-то момент сказал, что я нашел два отрезка,
то все, можно выбрасываться с криком «да». Ну а с каким криком еще мы выбрасываемся? Ну да,
мы обычно выбрасываемся с криком «ном салюшн», «минус один», а мы теперь выбрасываемся с криком
«да». Ну хорошо. Но как бы, допустим, мы прошли весь сканлайн и не выбросились. Значит ли это,
что пересечений не нашлось? В таком виде, конечно, нет. Ведь давайте подумаем, могло же так,
наверное, случиться, что вы добавили два, что есть два пересекающихся, допустим, отрезка,
допустим, вот такие два пересекающихся отрезка, и неожиданно вы их как бы добавили в сет,
и неожиданно не нашли, что они пересекаются. Могло быть такое? Да, конечно, могло. Ведь вполне
вероятно, что между ними на самом деле там влезла еще пара радостей. Ну давайте предположим,
для простоты, что вот этот отрезок, то есть вот это пересечение, это первое по иксу пересечение.
Вот могло быть такое, да? Могло. Но теперь идея такая, что раз это самое первое пересечение,
то до этого момента никаких проблем не будет. Но тогда сканлайн будет делать следующее. То есть
сканлайн постепенно все эти отрезки поудаляет, и рано или поздно перед вот этим пересечением
эти отрезки окажутся соседними. Поэтому у меня теперь дополнительный чит. Мы делаем проверку не
только когда отрезок добавляем, но и когда отрезок удаляем. А именно, когда пришло время удалить
отрезок, вы смотрите на его двух соседей и спрашиваете, они пересекаются ли они. Вот. И вот теперь,
собственно, тогда алгоритм уже работает. Вот видим, уже доказательно работает.
Ну да, проблема. Не, ну там да. Не, ну с инвариантом да. Ну тут инвариант вот аккуратен.
Потому что на самом деле инвариант эти можно, на самом деле как бы наука в принципе может эти
пересечения даже отлавливать и в этом месте эти отрезки в сете свапать даже. Потому что на самом
деле, то есть, конечно, в олимпиадах я такого не встречал, но вообще как бы в науке есть теоретические
задачи. Дано n отрезков, найдите, пожалуйста, все пересечения. И она работает за что-то типа n log n
плюс, что-то типа там получается едва линия n log n плюс k, где k реальное количество пересечений.
Или n plus k умножено log n. Ну да, мы просто берем. То есть, да. Ну типа да. Ну то есть,
суть заключается в том, что на самом деле события надо хранить в сете сразу тоже. И просто для любых
двух отрезков, которые пересекаются, мы говорим, что вот в момент пересечения будет событие,
когда их придется посвапать. И тем или иным способом свапаем. Ну, например, рассматриваем,
как бы тут события, вот это вот там, допустим, если это точка х, что там, и х минус и эпсилон,
и х плюс и эпсилон. То есть там какая-то такая логика начинается. То есть там, конечно, видимо,
так или иначе придется рассматривать там всякие совсем мерзкие случаи, когда там несколько отрезок
пересеклись. Ой, а если это еще и вертикальный отрезок, это вообще раз. Да. Ну, то есть просто
с вертикали, если вас задача просто найти хоть одно пересечение, ну как бы, пожалуйста. Нет,
ну бывает такое. В принципе, такое приходится иногда писать. То есть там в 2009 году, например,
на Всероссе там в жюри пришлось это писать в качестве чекера. Ну потому что там была задача...
Почему они не могли написать за квадрат? Потому что там 100 тысяч было.
Знаете, там задача была дан кактус размера 100 тысяч. Ну там, конечно,
прыл крыша компьютера и провода, конечно, были, но по сути дан кактус на 100 тысяч. Расположите
его вершины в квадрате миллиард на миллиард и нарисуйте ребра так, чтобы ребра были прямыми,
пересекались они только в вершинах. Время пошло. Это же просто не курить. Нет,
не просто не курить. Тут как бы у нас отрезки независимые. А так вообще получается дан граф,
и надо проверить, что ребра не пересекаются где-кроме как в вершинах. То есть вот эти вот то,
что отрезки могут попасть друг на друга в вершинах, это нам придется тем или иным способом учесть.
Нет, я не говорю, что это совсем непонятно как делать, я говорю, что просто жюри пришлось это
сделать. То есть нет, жюри, естественно, успешно сделали. В конце концов это первая задача в сероса
была. Ну там реально не самая сложная задача была. Ну ладно, по современным меркам, в общем-то,
это главное. Весь тот серос вам нужно как кубок МФТИ давать. Ну вот, так что есть подозрение,
что вы там за три часа реально там задачи три-четыре, может быть, даже закроете. Там шестих. Ну,
всего шести. В фражер-туре там было по три задачи. Ну, с одной стороны, можно сказать,
что там как бы на том, на пять часов давали три задачи, 300 баллов, ну, 300 баллов ни у кого не было
ни за тот, ни за другой тур. Там лучший результат был, по-моему, в первом туре 262, во втором, по-моему,
по-моему, две там, ну, сколько-то в этом роде. А, ну, я помню, что там чемпиона было 430. Вот,
но, правда, там была оговорка, что да, во-первых, там было из шестиста, во-вторых, напоминаю,
это были те времена, когда тестирование было оффлайн. Да, когда можно было после контракта
узнать, что ваше крутое решение без 100 баллов получает 40. Нет, ну, нет, 1 нет,
на тестах и условиях тестировалось. Так что нет. Но, взрослые,
дальнейшее тестирование было глубоко вашим делом. Вот, ну, странно. Хотя, пройдите,
пройдите, ну, как минимум, а, ну, маницепт, наверное, возможно, потому что регион-то вы должны
писать по всероссийским правилам. Так что вот это еще такая задача, значит, на сканлайн. А,
ну, есть, конечно, еще задача в таком максимальном кресте, которую я должен был рассказать в начале,
ну, я просто ее расскажу, потому что она там в программе экзамена обычно присутствует.
Можно не рассказывать. Ну, нет, я кратко расскажу задачу,
просто задаю, о чем я спрашиваю. Как решать ее, то сейчас поймете. Задача такая, дано несколько
отрезков, каждый либо вертикальный, либо горизонтальный. Хочется найти, ну, крест, понятно,
это вертикальный и горизонтальный отрезок, которые пересекаются. Хочется найти крест,
но есть максимально суммарной длины или там максимального произведения. Каждый отрезок
либо вертикальный, либо горизонтальный, да, почти наоборот. Вертикальный, горизонтальный. Ну,
то есть понятно, что по сравнению с предыдущими задачи уже совсем ни о чем, да. Хотя, возможно,
декортячку вам тут, ну, учитывая вот эти случаи, декортячку или ДО, конечно, по-любому писать
придется. Вот, чтоб там максимумы какие-то на отрезки искать, но это и проблема. Вот, значит,
это у нас сканлайн. Так, это у нас сканлайн. Сколько у нас там времени? Час до конца. Да,
прямо уже интрига. Ладно, еще чуть-чуть перерыва выдохнуть надо. Заморозка. Что такое заморозка?
Когда камера выключается, ну, короче, перекрывается камера, и все, в следующий час результаты нет.
А, ну, да, да, да. А потом только после конца экзамену узнается, что там было.
Красиво, да, красиво. Ну окей, нет, реально серьезно, перерыв надо. Что вы хотите рассказать дальше?
Ой, хорошие вопросы. Что я хочу рассказывать дальше? Ну, по идее, я хочу про это, наверное,
ну, видимо, имеет, наверное, смысл поговорить про выпуклооболочки. Ну, я не знаю, там дальше
должны быть выпуклооболочки, должно быть торнарный поиск. Ну, во-первых, давайте сразу. Так,
чтобы найти выпуклооболочку, надо ответить на такой вопрос, который, возможно, не все восьмиклассники
ответят. А что такое выпуклооболочка вообще? Ну, мы берем все возможные комбинации дневника,
элементы, конечно. Все, восьмиклассник уже убер. Ну, да, как-то выпуклооболочка, это как волна
физики. Мы не будем говорить строго определения, давайте просто будем изучать свойства. Вот,
но на самом деле выпуклооболочка даже абсолютно любому множеству можно легко ввести. Значит,
определение звучит следующим образом. Значит, пусть у меня есть какое-то множество. Да, совершенно
верно. То есть пусть у меня А, значит, это абсолютно, обратите внимание, даже абсолютно
призвольное множество, там никаких требований к связности нету. Внимание, ну вот, тогда выпуклооболочкой,
тогда конв от А, более известно как выпуклооболочка А, это пересечение таких множеств В, всех таких,
что А является под множеством В, и В выпукло. Так это уже другой вопрос. Вот это нам еще предстоит
выяснить, чему равна выпуклооболочка конечного числа точек. Вот, но есть вот такое определение. В
принципе, я часто люблю, можно ввести было бы второе определение и сказать, что конв от А это
минимальное по включению выпуклое множество, содержащее А. Вот, не понятно, почему это как бы
адекватно корректно, но на самом деле, просто если сказать, что у вас есть вот такое выпуклое
множество, то тогда становится корректно. То есть можно сказать, это свойство такое. То есть как бы
есть, то есть как бы вот это пересечение, то есть такое ядро всех выпуклых множеств А, значит оно
заведомо содержится в любом выпуклое множестве, оно конечно выпуклым является. Вот, да, можно себе
такое сказать. В принципе, то есть на самом деле выпуклооболочка может быть абсолютно любым
множеством. Да, то есть она может быть в принципе, то есть она может быть и кругом, но там, например,
выпуклая оболочка какой-нибудь вот такой вот гадости, это у нас что такое? Ну, по сути, вот. Видно,
да? Ну да, ну если взять круг и, допустим, выколоть какую-то точку, то тогда выпуклооболочка это
просто ничего не вык... Ну да. Да, вот это интересно. Да, если выколоть точку на границе,
то выпуклооболочка окажется весь круг, кроме вот этой точки. Да, это немножко неожиданно.
Правда, часто, чаще всего нам, конечно, потребуется искать выпуклооболочку замкнутых множеств. А что не так?
Мне не нравится, что если мы возьмем окружность и выпуклооболочка круг,
reass зан Sym siso simɷ Нет. И так мы можем
со несколькими точками делать.. Можем. Даже со счётным числом.
Да. Но если мы возьмём окружность без окружности,
это и выпуклооболочка внезапно не станет кругом. Не станет.
какой момент происходит фазовый переход но в тот момент что ты выкинул не счетной
так да тоже не обязательно если она не будет нет если оставшимся на что не всю
доплотно то нас отрежется не точка а уже вот такая вот типа а но это да ну по сути
ну видимо фазовый переход проходит когда ты счетная заменящина не счетные я могу
выковать не счетная множество спокойно я могу оставить да да да да да ну хорошо
ну хорошо хорошо пожалуйста да ладно это можно крышку опнуть да вот так хорошо но обычно
интересует более простой вариант нас интересует просто обычно конечно нас
интересует что да да да да но просто n точек то есть множество а это обычно просто n точек
хочется найти выпукло оболочку спрашивает что же такое выпукло оболочка из множества из n точек
не обязательно что такое общий много ну тут аккуратно а то знаете от у меня там
диссертации там помпаге еще понятия открытый многоугольник там выяснялось что то есть для
меня это вот это вот тоже было удобно считать многоугольником да это лучшие но там просто
хотелось пересечение полуплоскостей просто там произвольно рассматривает там пересечение
пупски еще более экзотические случаи если тоже мы видим уже в следующий раз рассмотрим вот значит
ну что делать с точками но на самом деле да есть маленький подлый случай но первых если точка
одна то выпукла оболочка точки это она же есть да что множество из этой точки оно оказывается
выпукла как бы контринтуитивно это не звучало вот но также еще верно что если все точки лежат
на одной прямой то выпукла оболочка это конечно отрезок такие базовые случаи есть а теперь
давайте предположим что выяснилось что ну какие мы там три точки не лежащие на одной прямой в
этом множестве найдутся давайте попробуем построить выпукла оболочку хотя да как бы по камере
по легенде мы пока даже не догадываемся а что это вообще такое а теперь давайте думать как же
строить выпукла оболочку так но на самом деле можно заметить но в принципе на самом деле можно
заметить ну да остается только по доказать доказать что это оказывается доказать что это
работает вот но как же но опять давайте значит скажем вот что а как вы думаете вот выпукла
оболочка это вообще замкнутая множество или нет хорошо но вообще а можно ли сказать что-нибудь
духе если множество а замкнута то его выпукла оболочка заведомо замкнута
ну да по ходу до замкнутая да но заметим до что заметим что множество из энточек замкнута
поэтому наверно выпукла оболочка конечно это явно замкнутая множество а еще можно легко заметить
что это множество ограничено почему ну потому что заметим следующее что если у меня тут да
множество из но если вот сам да но множество из энточка но ограничено следует но не выпукла
оболочка ограничена потому что она заведомо лежит внутри вот такого bounding бокса логично да а на
самом деле у всех ограниченных замкнутых множество на самом деле выпукла оболочку
ну вот можно искать при на самом деле весьма приятным образом давайте искать касательный
да я не знаю как выглядит но что но давайте искать к нему касательный вот я утверждаю такое
нет никакого отвала что вы придумываете нет никакого отвала вот смотрите я утверждаю чтобы
была вот такая касательная я хочу найти касательный я хочу найти касательную выпукла оболочки в этом
направлении значит я утверждаю следующее что это сделать просто я просто возьму эту прямую и
буду издалека вот так вот параллельно двигать до тех пор пока не она не наткнется на там на собственно
какую-нибудь точку этого множество кстати это это работает но даже в замкнутом множестве это
тоже будет работать прекрасно вот то есть давайте вот такую касательную найдем то есть вот мы там
до ближайшей точки дойдем если мы нарезаем торт с датчиками которые отлавливают если мы съели
какой торт но да да да но в данном случае помоет называется так мы этим ножом пытаемся вот так
вот резать если мы наткнулись на датчик он там если нас долбануло током значит мы останавливаем
да у нас бесконечный нож да у нас вот так у нас такой но что-то приводит то есть не вот так вот
а вот именно так вот так вот смотрите так вот я утверждаю нет смотрите нет на самом
деле немножко магии магия заключается в том что то что я тут нарисовал это действительно касательно
ну в каком плане касательная я утверждаю что действительно вся выпукла оболочка будет находиться
слева от этой прямой это нашли самую правую точку да да да важное мистическое свойство
полуплоскость выпуклое множество да равно как статьи вся плоскость вот нет и это знаете
это иногда бывает очень удобно потому что ну в принципе заведешь есть у меня попала
1 то есть более того я вам даже я вам даже еще скажу если у меня на эту касательную попала
ровно одна точка то я утверждаю что больше не одна точка этой прямой то есть там скорее всего то
есть скорее всего больше не одна точка этой прямой на самом деле в к вам не попадет то есть я
Я утверждаю, что здесь это совсем очевидно,
ни одна точка этой прямой в выпуклую оболочку не попадет.
Здесь это совсем очевидно. Почему?
Потому что я могу вот эту часть, вот этот лучик чуть-чуть повернуть,
и у меня получится вот такой угол,
который тоже является выпуклым ножем, он содержит все.
Удобно, правда?
Ну, более точно, хотя не знаю, в общем случае,
если у нас просто замкнутая нож, что-то там, конечно,
возможно, придется чуть-чуть подоказывать еще.
Ну что, допустим, у вас дано призвольное замкнутое выпуклое множество,
и у вас там касательная, то есть такая вот касательная,
проходит через одну точку, утверждение тогда,
и выпуклой оболочки на этой касательной будет только одна точка.
Это правда?
Хотя да, это правда, потому что многоугольник
там, в общем случае, можно какие-то вот такие вот делать, на самом деле.
То есть отклоняться можно не прям в этой точке,
а там типа чуть-чуть отойти и там отклоняться.
То есть вы там, получается, на какое-то расстояние, видимо, где-то отошли.
А хотя нет, с расстоянием тоже придется думать.
Ну ладно, ладно, давайте, ладно, не будем в эту сторону думать,
ладно, не будем тогда.
Нет, если замкнутая множество,
то кажется, что, скорее, не правда.
Мы можем просто подходить к нему, уходя на бесконечность.
То есть мы по синусоиде к нему подходим, отходим,
все ближе и ближе, но при этом эти,
все ближе и ближе уходят на бесконечность,
поэтому замкнутость не нарушается.
Ну да, ну да.
И тогда нам придется всю прямую взять.
То есть придется...
Кажется.
Сейчас, нет.
А, ну, ой, чего?
Да, ну тут вопрос.
Видимо, нужно еще учесть, что множество ограниченное.
Да, то есть если множество не ограничено...
А, это вообще лажа.
Если множество замкнутого не ограничено,
кажется, его кладболочка может быть не замкнутая.
Спокойно.
Вот из того же примера.
Ну да.
Если множество замкнутое...
Ну не ограниченное.
То мы начинаем к этой прямой подходить?
Ну да, нет, если множество...
Ну да.
Если множество замкнутое, но не ограниченное.
Ага.
И что нам это даст?
Ну я начинаю подходить к нему все ближе и ближе,
но точки не накапливаются,
потому что уходят на бесконечность.
И поэтому придется взять всю прямую.
Вот.
Но я могу саму прямую не брать,
но все, что...
То есть я могу саму прямую не брать,
как открытая ножица.
Ну, там...
Ну да.
Получится, да.
Ну я тебе...
Так.
Ну да, если оно еще не ограниченное,
с такой вот границей, то да.
Получится вся открытая полуплоскость.
Хорошо.
Да, действительно.
Ладно.
Но если у нас замкнутая и ограниченная...
Ну ладно, не будем сейчас обобщать,
это времени мало у нас.
Ладно, давайте нас сейчас
интересует в концерте случаи для N точек.
Поняли, что в ту сторону тоже...
Нет, на самом деле я сейчас для чего это делаю.
В принципе, я хочется подчеркнуть,
что в принципе это такой метод,
что выпуклое ограниченное нож,
что на самом деле задается
вот этими опорными прямыми или касательными,
как мы их называем.
Да, еще они называются опорными прямыми
или даже коллиперами.
Да, задачи на этот метод
у нас тоже будут.
Через неделю, естественно.
А пока же про выпуклоболочку
я могу же сказать так.
Вот наткнулись мы вот на эту касательную, на эту точку.
Теперь идея такая. Давайте это направление
немножко поворачивать.
Что будет происходить?
Ну, будет происходить следующее.
Что мы тут будем... Некоторое время
мы эту касательную просто вокруг этой вершины будем откровенно
поворачивать, и она будет
опираться ровно на эту точку. Правда?
У нас есть минимум вот этих углов поворота.
Да, но в какой-то момент этот поворот
наткнется на еще одну точку.
Тогда смотрите, что у нас произошло.
Тогда мы замечаем маленький приятный факт,
что вся выпуклоболочка лежит
внутри вот этого
угла. Да?
Вот. Вне этого угла ничего
не лежит, но с другой стороны заметим,
что вот эта вот штука,
то есть вот этот вот
отрезок, он уже в выпуклоболочке заведомо
лежит. Правда?
Потому что обе эти точки
оказывается заведомо лежат на
лежат на выпуклоболочке, в смысле на границе
выпуклоболочки.
Потому что сам отрезок выпуклоболочки
лежит, но вот рядом с ним
вот уже все, что не с той стороны,
справа от него уже в ауте.
А вот это все, кстати,
в выпуклоболочке не лежит.
Понимаете, да?
Что у нас происходит дальше?
Ну дальше продолжаем вращать
касательно, только уже вокруг этой прямой, абсолютно
тем же методом. И натыкаемся
на следующее.
Вот.
Видно, да?
Ну и так далее.
То есть на самом деле вот так честно вращаем.
То есть на каждом шаге по факту мы там просто находим
какую-нибудь точку с
такую, что вот этот вот угол
как можно больше.
Да, как их на практике находить?
Да очень просто. То есть на практике
это делается так, что если
мы находимся на какой-то крайней точке,
то получается существует какой угол
что меньше 180 градусов, внутри
которых все эти точки находятся.
Я это буду звать книжка такая.
А внутри этой книжки как бы
сравнивать точки по углу,
это то же самое, что сравните по векторному произведению.
Правда?
Нет, это джарвис.
Ну вот.
Это на самом деле метод заворачивания
подарка в явном виде.
То есть мы просто так
проходимся касательно, вот это вот проходим.
Там проходим,
проходим, проходим и в какой-то момент
у нас все-таки мы поворачиваем на 360
градусов и касательно возвращается
в эту точку.
Единственное, конечно, что изначально надо было бы
то есть надо было бы
изначально конечно стартовать не с рандомной
касательно обычно стартует где-нибудь
с самой нижней точки, то есть коризонтальной касательной.
Вот и получается вот действительно
такая вот штука. То есть получается
смотрите, то есть в результате у нас замкнулся
многоугольник, который является границей
в оболочке. То есть мы показали,
что все, что справа от каждого из этого
ребра, оно по-любому в ауте.
Понимаете, да?
Понимаете?
Ну потому что касательно, потому что
заметим так, что все, что касательное
заметает вне этих отрезков, мы доказали,
что оно в ауте.
Ну очевидно оно все вне этого
многоугольника и замела.
Отсюда, в общем-то,
и следует, что, во-первых, то есть мы доказали
что если есть хотя бы три точки, не лежащие
на одной прямой, то выпуклый оболочек
этих n-точек является выпуклый многоугольник
с вершинами в этих
точках.
Вот. Понимаете, да?
Вот.
Этот метод называется метод
Джарриса.
Более известный как заворачивание подарка.
Его асимптотика
N-H.
Да, это вот, кстати, важно.
То есть в худшем случае, конечно, N-квадрат,
но в реальности, то есть имеет
смысл оценить как N-H, где H это
реальный размер выпуклой
оболочки.
Да, тут без вариантов.
Вот. Потому что бывает
иногда что, бывает что алгоритм вполне
себе полезен. Если там выпукла оболочка,
у вас там маленькая.
Вот.
Слючайте другой метод.
То есть в принципе это все
можно мыслить, на самом деле, немножко по-другому.
То есть еще один метод
поиска этой выпуклой оболочки
звучит на самом деле так.
Так, давайте я сейчас все сотру
и скажу так.
То есть более известный, который обычно пишется,
хотя тут пишут по-разному.
Но классический метод
звучит так.
Смотрите.
Ну, во-первых, среди этих точек
заведомо найдется самая низкая точка.
И как мы уже поняли, это
среди самых нижних точек выберем, например, самую левую.
И мы поймем, что эта точка
заведомо является вершиной выпуклой оболочки.
Правда?
Вот возьмем эту нижнюю точку и
рассмотрим ее
книжку.
А теперь заметим следующее.
Что я не знаю, через какие вершины пройдет
выпуклая оболочка,
но у меня почему-то есть жуткое
подозрение,
что эта выпуклая оболочка
будет проходить как бы
строго справа-налево.
То есть если я по этой выпуклой
оболочке пущу опять ту же самую
козу, а сам стану здесь,
то коза у меня будет идти
строго справа-налево. Правда?
Ну, неправда. Почему?
Ну, за исключением вот этих вот двух
отрезков, конечно же.
Ну, в плане не справа-налево,
а...
Ну, если идти против часовой стрелки, то справа-наль.
Ну, если коза будет
идти против часовой стрелки, то она вот в этот...
Тут будет идти как бы справа-налево.
Это выдает нам следующий
алгоритм. Давайте-ка
вот эти все точки относительно нас
отсортируем по полярному углу.
Ну, то есть
кто правее, кто левее.
Но как отсортировать? Напоминаю, что не надо.
Честно, я удивляюсь,
но даже умные олимпиагики в этом месте
реально начинают вычислять угол.
То есть на полном серьезе угол между вот этим
и вот этим или полярный угол какой-то.
Так вот, ребят, не надо.
Во-первых, там не крост,
а скилл.
А, хотя...
А, может и крост, ладно.
Ладно, может и крост, ладно.
Ну, короче говоря, то есть сравнивать
две точки по полярному углу нужно, конечно,
просто с помощью векторного произведения
в целых числах без всяких этих ваших атан-2.
Понимаете, да?
Ну вот.
Да-да-да, ну и...
Как это да...
Ну да, ты же да...
Да, ты же вызываешь атан-2.
С утра вызывал, но я принял контракт.
А, ну да, все.
Реклама, да.
А, все-таки видели эту рекламу, да.
Да, ну вот.
Так вот, начнем их сортируем.
Важный момент еще, что при равных полярных
углах давайте их отсортируем по
расстоянию от этой точки.
Да, кстати, в идеале заметим, что можно здесь
расстояние искать без вызова функции
сqrt.
Потому что, на самом деле, ну, во-первых, можно
вычитать квадрат расстояния, во-первых.
А, вторых, заметим, что вам
это расстояние здесь можно сделать вообще
манхеттерским.
Зачем манхеттерское расстояние? Хорошо, что вам не придется
лишнее умножение вызывать. Это тоже оптимизирует
констант. Ну, незначительно,
но оптимизирует.
Но придется вызывать... Нет.
Вызывать модуль — это if.
If работает явно дольше,
чем умножение.
Да!
Ну, я бы сказал, что нихрена.
Ну, потому что if, у него две ветки,
и он еще нужно выбирать, что делать.
Ну и что? Ну да.
Нет, ну, по-моему, на поверхе
умножение и деление по константе работают дольше.
Ну, типа деление работает, а умножение?
Ну, умножение тоже.
А умножение, что ли, там, не замарахивайся.
В целых чисел очень быстро работает.
Ну, по-моему, if как-то...
Ну, то есть if он...
Нет, ну, безо...
Там всего лишь два модуля.
Нет, ну, я бы сказал, что там всякие умножения
и сложения if работают там быстрее
всяких там умножений, даже умножений,
не говоря уже о модулях. Ровно поэтому мы там
обычно процентики иногда заменяем на if
больше либо равно mod, но минус равно mod,
и это реально очень круто работает.
Нет, по модулю это взяться так.
Ну, вот процентики.
Ну, я бы сказал, что, по-моему, мне кажется,
что умножение тоже...
Так тоже операция более жирная, чем
любой под...
Ну, может быть, важно.
Ну, в данном случае
не сильно важно, потому что
ядром этих операций все равно является
векторное произведение с двумя умножениями.
Так или иначе.
Так что не проблема.
Ну, не важно. Суть, на самом деле,
в следующем.
Дальше просто оказывается, что после того,
как вы Zn log n это отсортировали,
оказывается, что вы можете
на самом деле идти...
То есть теперь идея такая. Давайте по этим точкам идти
в порядке сортировки, вот прям
честно идти-идти.
Но при этом выясняется следующее.
И при этом заявляет, что
если в какой-то момент вы пришли
в новую точку, у вас обнаружилась не выпуклась,
то есть у вас поворот не в правильную сторону,
то утверждается, что
все, что вам надо, это просто
там предыдущую точку
выкинуть. Может, даже не одну.
Вот. То есть, например, в данном случае у вас получается
вот так, вот так.
А тут, допустим,
вот так. Я вот даже подальше
чуть-чуть точку нарисую.
Ну, вот.
Допустим, вот так.
Вот.
Тогда здесь мы эту точку выкинули,
а тут, смотрите, какая ситуация.
То есть тогда и вот эту мы придется выкидывать,
но и вот эту, и даже вот эту,
заранее скажу.
Вот.
Ну, в принципе, классический механизм,
то есть, по сути, мы эти точки добавляем в стэк,
и как только образуется не выпуклость, мы их выкидываем.
Вот.
То есть там получается дальше что-то там вот такое,
там потом вот такое,
вот такое, вот такое.
Вот. Ну, там ладно,
некоторые точки я пропущу, но, как бы,
суть одна.
Вот.
Ну и в итоге вот мы, в итоге вот так вот сюда и придем.
Ну, останется только аккуратненько
по индукции доказать,
что когда вы дошли до какой-то точки,
то, в принципе, вот там вот,
то есть в том, что лучик вот так вот замел до этой точки,
вы реально выпукло оболочку нашли.
То есть вот это, вот это реально выпукло оболочка
вот этих точек.
Потом, когда там следующую добавляете,
там, собственно, это будет достаточно легко уже в этом убедиться.
Вот.
Это называется
алгоритм Грехама.
Он работает
за N log N.
Или даже, если быть точнее,
O от N плюс сортировка.
По полярному углу. То есть, если вы умеете по полярному углу
скорее быстрее, чем за N log N,
то у вас этот алгоритм будет работать
быстрее, чем за N log N.
Другой вопрос, что маловероятно,
что вы так прямо умеете, потому что на самом деле
задача о сортировке, допустим, N чисел
прекрасно сводится
к заданию по строению выпукла оболочки.
Потому что что нужно, чтобы сортировать
числа x1, x2, x3 и так далее?
Нужно просто
построить выпуклую оболочку
у точек x и запятая
x и в квадрате.
Вот задача.
Отсортировать.
Решение.
Возьмем вот такие N точек,
построим у них выпуклую оболочку.
Да. Откуда я взял эти точки?
Ну, точки я взял вот откуда.
То есть, я просто их на параболке
нарисовал вот такие точки.
Да.
И что?
Нет, ну это я просто к тому, что...
Нет, а почему это работает?
Ну, потому что выпуклая оболочка
упорядочит точки ровно вот таким образом.
Ну, там начало может быть
откуда-то не оттуда, но это уже легко.
И там с точностью десектического сдвига
это будет сортированный порядок.
Ну, так вот,
вот,
вот,
вот,
вот, с десектического сдвига это будет сортированный порядок.
Да, но фишка в том, что выпуклая
оболочка, что у нас много уголек
должны задаваться в порядке обхода, а не просто
какие точки у вас на выпуклой оболочке.
Вот.
такие вот иксики чего вот ну это так сведение правда единственное да но это
просто я просто хотел хотел просто показать что на самом деле задачи
ассортировки из ада там задачи выпукло оболочки это где-то близкие задачи
возможно примерно одинаковые сложности на самом деле конечно да то есть ну
полярный угол да честно если говорить по моему опыту то конечно когда я это
впервые с этим столкнулся в восьмом классе где-то то мне было сложно потому
что я тригонометрию как следует еще не знал ну якобы еще не знал там не
векторов там не синусов за пределами 90 градусов там не там не прочего не
прочего прочего то есть как бы там но поэтому там сложно было поэтому там вот
сортировать но то есть у меня там задачи полярный угол точки на самом деле
вызывала беспроспретный во вообще ничего не мог с ним сделать как выяснилось
потому что я не знал просто что такое аксинус толком ну то есть я нашу аксинус
дай так как бы что если мне аксинус а равно б значит синус б равно а но как бы
то что он это так синус он возвращает как бы там условно это б будет от минус
пидо пипа лам да пипа лам это была для меня не тривиальная идея вот поэтому я
использовал метод который не требует сортировки поэтому мистическому полярному
углу то есть более простой метод который вот заведомо надежно работает
называется метод грехома эндрэ да эндрэ это фамилия если что они то что вы
подумали да естественно вы про станкевича подумали ну ну конечно да ну
как вы да он просто периодически он известен именно под этим именем почему
вот идея заключается в том то есть идея заключается в том что значит здесь
предлагается эти точки эти точки отсортировать то есть не сортировать по
полярному углу а отсортировать их тупо по иксу и после этого смотрите взять
самую левую точку самую правую и тогда провести вот это ребро и тогда тогда
будущее выпукло оболочек распадется на две части которые мы будем можем
условно называть нижней частью выпукло оболочки и верхней частью выпукло
оболочки вот ну или там там кружка или там вот эта чашка и крышка нет это грехом
грехом эндрэ да так у нас ой у нас много алгоритмов да вот то есть смотрите как
теперь построить нижнюю часть выпукло оболочки после сортировки по иксу но
очевидно ровно тем же методом просто вот идем слева направо там выпиливаем там
какие-то точки так что-то выпиливаем выпиливаем там что-то выпиливаем то есть
как всегда но вот давайте сразу выпиливаем ой нет сначала вот так потом
вот так потом вот так там вот ну очень в принципе я думаю вы поняли я тут
рисовать не понятно да вот понятная идея вот теперь фишка что можно теперь это
а теперь можно пройдясь справа налево можно абсолютно тем же методом построить
и верхнюю часть то есть обратить внимание тут я это называю нижней частью верхней
часть но надо аккуратно что иногда хочется говорить называть это нижняя
половина и верхняя половина но естественно у нас никаких решений на
то где точек больше и насколько нету то есть может на самом деле вся выпукло
оболочка вот тут снизу и лежит что какая люба сложный прикол так вот то есть
принципе метод удобен конечно тем интуитивно что сортировать в этом случае
надо не по полярному углу а реально по иксу то есть принципе если у вас все иксы до ста тысяч
кстати там целые числа от нуля до ста тысяч то вы можете сортировать просто подсчетом то есть
я тоже здесь напишу асимптотику от м плюс сорт но вот просто у этого метода есть преимущество
что сортировку быстрее чем звен логин здесь конечно сделать гораздо реальнее там такой какой-то
компаратор мистический что там будет грустно вот но минус конечно в том что вам придется сделать
два прохода за он то есть построить нижнюю часть и верхнюю часть вот ну там понятно что можно это
сделать без копипасты там вот этими или иными способами но вот то есть конечно понятно что
там если вас значит просто построить выпукло оболоких учащик конечно использует вот этот
метод с поля там с полярными углами точнее векторными произведениями но можно принципе так вот так это
у нас такой грехом эндрю но конечно говоря об алгоритмах конечно построение выпуклых оболочек
зан логин нельзя конечно не поменю упомянуть его величество разделяй властвуй но я пока просто
отмечу что есть такой алгоритм принципе то есть алгоритм кихп уже там уже известного нам кик патрика
если не ошибаюсь конечно у нас был кихпатрик сорт но помните этот изделательский ну по биткам
там типа типа сортируем дабл юбитные там б битные числа типа делим их на б пополам
значит сортируем эти там по б пополам там но эти в регистрах там было вот ну ладно не важно так
вот тут идея такая давайте но тут просто идея заключается в том что давайте точечки значит
разделим просто какой-нибудь вертикальной прямой ли чем еще на две две равные части или может
даже просто разделим построим рекурсивно выпукло оболочку одного выпукло оболочку второго об том
просто объединим за линию выпукло оболочки в значит двух многоугольников обратите внимание
мы сегодня чем-то подобным уже занимались то есть вот тем же самыми вращающимися касательными
можно сделать нам так скажу нет на самом деле понятно что писать тут это конечно не особо
осмысленно но на самом деле смысл в том что просто ведь тисто теоретически на самом деле эти задачи
могут быть поставлены в 3d то есть тут задача найдите трехмерную выпукло оболочку то есть отметим
там тоже есть алгоритм там как бы заворачивание подарка на самом деле будет работать за там
квадрат тоже но можно на самом деле вот такой разделяем властвую забабахать за н логин но
объединяться он конечно там будет не вот этими вращающимися касательными а какую-то там пленочку
вращать придется вот да поэтому мы поэтому мы подробно в это копать не будем да
значит поэтому вместо этого мы займемся другим значит видимо последнее что я сегодня расскажу
значит за оставшиеся наверное 10-15 минут это вот что смотрите у нас есть фактически два варианта
как написать выпукло оболочку за н логин и за наш какой из этих алгоритмов лучше ответ да
зависит ответ дп зависит от того кто больше логарифом или выпукло оболочек ну можно конечно
написать ну да можно конечно так сделать написать заворачивание подарка если заворачивание вы
поняли что вы уже сделали логарифом операции но то в принципе в этом месте надо остановиться и
запустить алгоритм за н логин получится за минимум из и наша и н логина но притве вообще в принципе да то
есть как бы есть такая глобальная идея что если у вас есть два алгоритма решающих одну задачу то вы
можете запустить их так сказать параллельно и как только один из алгоритмов решит то остановить
получится умеем решать за минимум это называется нет ну это было не лучше если например две половины
нужно как-то объединять но при этом нельзя сколько из них больше то мы запускаем в обоих
ну типа да она здесь у нас будет еще круче значит наша пошла сейчас мы изучим алгоритм
который будет искать выпукло оболочку за значит это алгоритм чена будет называться
не настолько тут будет n лог аж вот прям совсем хорошо если выпукло оболочка логарифом то он будет
тогда искать его за n лог лог и хотя если там целые числа то можно и так за н лог логом найти
выпукло оболочку ну мы же умеем искать овать целые числа за n лог лог и
а это неважно нет просто а там неважно что мы мы про сортировку и так знаю ее оптимальную
асимптутику ну ну пока в какой-то модели камешков тут конечно сложно применять модель камешков
потому что нам для этих камешков еще надо как-то уметь определять там кто там в относительно
какой полуплоскости от кого лежит нет я так скажу я не буду не смогу и к сожалению не могу
сейчас углубиться в детали но скажем так то есть там на самом деле есть какие-то методы которые
позволяют давать нижние оценки на границу там нижние оценки на то за сколько у вас алгоритм
будет что-то искать вот то есть но подробнее нас но то есть какие-то подробности я вам
но смогу порекомендовать кстати сразу книгу то есть есть такая книга прям на русском языке
кстати в том числе есть хоть она конечно не там не русская вот то есть вот препарата шеймус
вычислительная геометрия вот но это если книги брать по что есть у меня там я сейчас вот не
скажу авторов там там есть еще еще у нас один язык учебник который тоже можно как как учебник
использовать хотя в принципе хотя конечно есть конечно тут основное что я в этом смысле реально
прям очень хочется просто души прекламировать именно в геометрии это конечно лекции киры
вяткиной киры вяткиной вот то есть начнете просто вот можно найти просто ее видео лекции ну
смотрите в питере есть такая штука как компьютер science club ну это там может быть что-то типа там
нашего шада вот ну в принципе да практически да похоже на шат только там может быть может
где-то больше в сторону математики но хотя нет все-таки попpop вот но вот там есть тоже какие
то курсы так вот весь к labeling там вот есть запись остается видеозаписи там кула курс
а вот собственно киры�яткиной то это абсолютно это абсолютно реальный ученый как то действующий
ученый в области вычислительной геометрии вот абсолютно где нот то, естественно, действующий
ученый то есть многое там то есть поэтому там многое из того что я рассказываю то есть можно
увидите у нее, то в частности она замечательно рассказывает и про треангуляцию Доланэ, скажем,
и про диаграмму Варанова. В отличие от меня, она там даже код напишет. Странно, так что в принципе
очень рекомендую. Да, ну и этого я тоже не сказать не мог, это важно. Так что просто Кировяткина,
а вот это мы легко обсудим. Значит, смотрите. Тут идея такая. Алгоритм говорит такое. Предположим,
что откуда-то с небес по факсу нам прислали точный h. То есть мы точно знаем, какого будет у нас
размера выпукла оболочка. Тогда мы сделаем неожиданную штуку. Разделим эти n точек на
множество по h точек, в чем не важно как просто. То есть я тут нарисую их, конечно, для удобства
не пересекающимися, но в реальности они могут и пересечься. Вот, то есть какие-то тут точки,
вот h, h, h. Так вот, в каждом из них за h лог h, вот любым выше описанным алгоритмом мы найдем выпуклую оболочку.
Вот. Это у нас займет сколько времени? Это займет получается h лог h умножить на сколько раз мы это
делаем. Делаем это n делить на h раз, то есть получается как раз тот самый n лог h. Вот,
понятно, да? Так вот, теперь у меня идея. Сейчас я буду заворачиванием подарка искать объединение
вот этих вот выпуклую оболочку вот этих многоугольников. Нет, смотрите, там идея будет
примерно, то есть идея будет базироваться, ну, примерно, нет, ну как, у меня есть n многоугольников
вот этих, да? Может быть, даже пересекаются, да? Но там просто фишка будет примерно следующая. То есть я
сейчас буду искать их выпуклую оболочку. Искать буду так. Вот. Ну, то есть искать я буду их практически,
вот, то есть практически тем же методом. Ну, вот, тем же методом, ну, в каком плане? Вот. Искать,
соответственно, буду в том плане, что, ну, просто тем же заворачиванием подарка. То есть я буду,
то есть где-то я буду пытаться просто вращать, то есть, допустим, там вращать, может быть,
там те же самые касательные, вот, те же самые, да, я их сумма нот, то есть буду их вот так вот,
ну, то есть просто провращать эти касательные, я могу за линию, правда? Потому что каждая нот,
ну, по крайней мере, если я в качестве касательной буду, то есть, там, вот, хранить прям конкретно
опорную точку. Да? Ну, потому что суммарный размер N, правда? Вот. Ну, правда, ну, как? Ну,
не совсем там N, потому что на каждом шаге, конечно, вам придется за O от N делить на H,
честно выбирать, а куда вы там переходите. Ну, где вы конкретно делаете повороты, правда? Но там,
ну, вот. Но для нас это, в общем, даже, там, значит, там это будет примерно так. То есть,
мы вместо этого будем делать так. То есть, вот мы находимся, вот, самой правой с нашей
точки зрения касательной, вот находимся в этой точке. Теперь думаю, какая будет следующая? Она
может быть конкретно на этом многоугольнике, да? А может быть еще там, соответственно,
то есть, соответственно, где то. Но давайте, вот, на каждом многоугольнике попробуем найти,
найдем правую касательную. Изначально, допустим, в тупую, да? Вот. Ну, я пока нот. Ну, вот. Ну,
и понятно, если я тут найду вот эту правую касательную из каждой точки, ну, а мы находимся
заведомо вовне, потому что мы же, в принципе, по контуру всего ищем, то тогда у нас получается,
что, ну, то есть, получается, что выбрать нужный вариант у нас получается за n делить на h,
правда? За n делить на h умножить на поиск касательной. Ну, первый раз я нахожу касательную в тупую.
Суммарно получается n. Хорошо. Вот, просто, вот, буквально можно в тупую найти. Но фишка просто в
следующем. Давай я перейду в следующую точку, в оболочке. Тогда я утверждаю, что вот эта вот
касательная, она на самом деле сдвинется вот так вот против часовой стрелки. Логично, да? Ну, там
просто либо она будет правой касательной, либо выяснится, что этот лучик уже на самом деле вот
куда-то сюда пересекает, поэтому мы должны из этой точки сдвинуться в следующую и проверить,
подходит ли она нам. И будем прям честно двигаться до тех пор, пока не наткнемся, собственно,
правой касательной. Ну, там легко заметить, да, что, как бы, если у вас есть многоугольник, есть
точка, то проверить верно ли, что вот эта правая касательная вы сможете просто за 1, правда? Понимаете,
да? Вот. То есть там идея такая, то есть это получается на самом деле, то есть вы это будете,
это получается такой метод n делить на h указателей. Ну, буквально. Потому что вы эти касательные
двигаете честно за n делить на h, то есть там суммарно они двигаются указателей за n и получается,
что у вас, то есть тогда на каждом шаге вы следующую точку находите за n делить на h,
да? Вот. И тогда получается, что суммарно это все у вас работает за n плюс n делить на h на
размер выпуклой оболочки. Ну да. Просто, как бы, поиск мы делаем не за логарифом, как раньше,
а вот просто идем указателем. Ну короче, у нас же эта точка сильно переместилась вниз. Ну не
обязательно. Ну в данном случае, да, если она вот потом отсюда переместилась вот сюда, то как бы,
да, то есть касательная, ну здесь-то она, кстати, как раз нормально, она осталась на месте, но здесь
она, конечно, переместилась сильно, да, тут пришлось вот так ходить, но как бы это не глобально,
потому что, как бы, с точки зрения каждого многоугольника будет происходить следующее,
у вас есть многоугольник, есть какая-то коза. Ну вот, наша любимая коза, которая ходит по какому-то
внешнему контуру. Ну может быть, даже иногда соприкасающимся с самим многоугольником, да? И вы
у этой козы, в каждом, пока коза ходит, поддерживаете ее правую касательную, но так как она ходит по
контуру против часовой стрелки, то получается и касательную, то есть точка касания этого правого
у нее аккуратно двигается вот так. Вот, да, это вот N делить на H, но чему у нас равен? Мы знаем,
что размер выпуклой оболочки у нас H, то есть получается, что вот этот вот сам проход,
это объединение вы сделали за O от N, то есть получается вот такая комбинация заворачивания
подарка Игрехома. Вот эти указатели бегают за N, выбор каждый раз вы делаете за N делить на H,
но мы же помним, что у нас выпуклая оболочка сама размера H, и вы этот проход сделали за O от N.
Ну, может, и могли. Так, ну, действительно, как мы это могли сделать? Ну, могли,
нет, ну, да, мы могли, конечно, соптимизировать как, ну, да, то есть мы могли вместо H здесь,
конечно, взять K, и что у нас там получится? N делить на K, то есть там получается что-то N
лог K, да, плюс сколько там? Плюс получается, плюс N, плюс, значит, N делить на K на H,
и теперь возникает вопрос, какое оптимальное K при этом надо выбрать, да? Ну, должно быть так,
то есть по идее надо брать, конечно, что K лог K примерно H должно быть, то есть я бы сказал,
что K, видимо, должно быть в идеале где-то H делить на лог H, так-то получается.
Что, правда, что ли?
Хотя нет, если я подставлю K как H делить на лог H, то-то что у меня здесь получится? Тогда
я подставлю вместо лог K, у меня получится лог H делить на лог H, там, лог H минус лог лог H,
но это тоже самое лог H, так что, по сути, то есть, на самом деле, нет симпатической оптимальности здесь нет.
Остается, остается теперь изобрести небеса и факт, с которым нам этот H присылают,
но на самом деле все гораздо проще. На самом деле, этот алгоритм можно уточнить, можно сказать,
что этот алгоритм находит выпуклооболочку, если она размера не больше H, а если она больше H,
то он за N лог H узнает, что размер выпуклооболочки больше, чем больше, чем H, согласны?
Так вот, так вот, эта идея говорит нам теперь так, что, а давайте теперь искать так выпуклооболочку,
подразумевая, что H равно 1, значит, скажем так, 2, 2 в квадрате, 2 в степени 2, 2 в степени 2,
2 в степени 3, 2 в степени 2, 2 в степени 4, 2 в степени 2, 2 в степени 5, 2 в степени 2, 2 в степени 6 и так далее.
Ну, короче, смотрите, я беру такую последовательность H, что у каждого следующего
логарифа в два раза больше предыдущего. Понимаете, да? Но теперь заметим следующее,
что, допустим, я где-то остановлюсь, то есть в какой-то момент выяснится, что у меня H не
превосходит вот этого вот, и я за N лог H, за N лог вот этого вот выпуклооболочку найду, правда?
Вот. Но заметим следующее, что так как мы работали за N лог, там, для каждой итерации,
тут работали за N на вот это, тут на N, потом перед этим было N на вот это, на вот это и так далее,
то есть, короче, весь этот алгоритм работал за O от N на алгоритм вот этого, согласны?
Но теперь остается только заметить, что логарифом вот этого не более чем в два раза больше,
чем логарифом реального H. Согласны? Есть кто живой? Вот. То есть отсюда получается,
что при переборе вот таких вот H оказывается, что у нас все работает за N лог H.
Ну, короче, там написаны числа вида два в степени, два в степени G. Ну ладно,
давай единичку не будем писать. Вот так. Ну, можно, в принципе, два в степени,
два в степени ноль не писать, потому что если точки не лежат на одной прямой, то выпуклооболочек
имеет размер заведомо 3, хотя бы. Поэтому, в принципе, можно отсюда начинать. Так что вот
такая неожиданная красота. Ну, понятно, что там, скорее всего, найдется красивая несимпатическая
оптимизация вида, а давайте сначала предположим, что H не больше чем 10 и попытаемся за 10 H проверить
этот факт в тупую. Ну, там, ну, это константа 10, понятно, она там, конечно, может быть поправлена влево,
вправо, в радость, но соответственно. Ну, вот и все. Так что вот таким вот образом мы научились искать
выпуклые оболочки. Вот, то есть действительно, то есть понимать, конечно, полезно, на самом деле,
разные из этих алгоритмов. Вот, потому что там, конечно, в конкретных задачах по геометрии там,
конечно, разные из этих алгоритмов могут вам неожиданно выплыть. Скажем, алгоритм,
которым Андрю выплывает, если вам там какой-то выпукло оболочку надо как-то в онлайне поддерживать.
Ну, там, знаете, какой-нибудь типичный какой-то, то есть типичный какой-нибудь прием для решения
задач на каких-нибудь там седьмых, восьмых задач на все, это какое-нибудь там дерево,
отрезка выпуклых оболочек. Все сталкивались? Нет. Нет? Осторожно. В какой-то момент можете
столкнуться. Ну, на всяких серосах или там где-нибудь еще там. Ну, на открытке да.
