Сегодня у нас тема с вами. Она такая, находится между алгоритмами и плюсами. Почему? Потому что
мы с вами наконец-то уходим от сортировок и приходим к новым вещам, которые помогут нам
вообще понять некоторые механизмы того, как работать с данными. Сортировки это были первые
такие наши попытки как-то характеризовать массивы данных, как-то их упорядочить,
что-то с ними сделать для того, чтобы вообще работать с ними далее. То есть сортировка сама
в своем представлении не то чтобы сильно много ролей и сильно важности вам не давало, но в случае
если вы отсортируете какой-то конкретный массив и дальше уже сделаете какие-то с ним действия,
это будет гораздо быстрее, чем вы искали какие-то там элементы и что-то с ним пытались сделать.
И существуют различные подходы к данным, к тому, что нам вообще в принципе необходимо,
и это радует. И мы с вами пройдем достаточно много еще как минимум в этом семестре различных
структур данных, которые нам помогут в той или иной мере, в тот или иной момент. Но сегодня мы с
вами будем говорить про достаточно простые вещи. Это листы, стек и очередь. Лист, стек и очередь.
Ну в какой-то степени можно сказать, что мы еще поговорим про дек, если у нас останется время. Но
сразу скажу, дек существует не в таком виде в плюсах, поэтому все, что вы могли знать до этого,
это не совсем правда. Вот, начнем с простого. Смотрите, у нас есть массив. Что такое массив?
Это порядочные элементы в памяти, которые являются еще однотиповыми. То есть, если у нас
массив n-тов, то мы храним только n-ты, а если у нас там массив doppelhoff, мы храним только doppelhoff.
Но главное, что они подряд в памяти. Что это нам вообще позволяет делать с ними? Как вы думаете,
что хорошо в массиве? Ну это уже относится к типу данных. Меня интересует сам массив. Ну
давайте напишем какие-нибудь чиселки, не знаю. 3, 2, 2, 4, 7, 9, 3. Как вы думаете, такой человек учится
в стихе или нет? Кто знает, вдруг это чей-то прогноз или мой. Все бывает. В общем-то, смотрите,
вот у нас есть какой-то массив данных, оценок, не важно чего. Что мы умеем быстро с ними делать?
Брать по индексу. А что такое взять по индексу какой-то элемент? Это же то же самое,
что разыменовать А-плюсы. Согласны? Помните такой из плюсов? Вот, это мы умеем делать быстро. Это
делается за О от единички. Согласны? То есть мы можем обратиться к n-тому элементу, к i-тому
элементу за О от единицы. Это то, что позволяет нам использовать массивы как оптимальную структуру
данных в случае, если мы обращаемся постоянно к элементам. Но существуют проблемы другого
характера. Предположим, что мне нужно взять и удалить какой-то элемент из массива. Как я это буду
делать? Я должен сдвинуть абсолютно все элементы на один. То есть, если я хочу с вами удалить
какой-нибудь элемент и получить, к примеру, 3, 2, 4, 7, 9, 3, то за сколько это будет работать?
О от н. То есть удаление элемента это О от н. А если я захочу вставить? Тоже будет О от н. Классно это? Нет.
Вот здесь начинается дилемма. На самом деле всегда так в жизни с любыми вещами, которые вы захотите
сделать. Если где-то хорошо, значит где-то плохо. То есть, вы не можете сделать настолько идеальную
структуру данных и сказать, что она все делает за О от единицы. К сожалению, это невозможно,
иначе бы мы все учили только ее и не смотрели на все остальное. Поэтому всегда приходится выбирать,
что нам необходимо в тот или иной момент. Может быть, нам нужно быстрое обращение к элементам,
тогда массив — идеальная структура, и мы постоянно берем и обращаемся к элементам. Может быть,
нам нужно будет удалять элементы или как-то вставлять их периодически. Это другой уровень,
и это другая структура данных, о которых мы сегодня с вами и поговорим. То есть, здесь важно
осознавать, что любая структура данных применяется в конкретной ситуации, и вы самостоятельно должны
научиться принимать эти самые решения. А что же мне делать здесь? Понятно? Вот. И первое,
с чем мы с вами познакомимся, и на самом деле, на чем мы сегодня будем строить всю лекцию — это листы.
Те, кто учил питон, знают, что такое лист в питоне. Но лист в питоне — это то же самое,
что массив. Лист — это немного другая вещь, на самом деле, с точки зрения плюсов. С точки зрения
плюсов лист бывает односвязный и двухсвязный. Это первое, что вы должны понять. То есть,
бывает два таких вида. Односвязный и двухсвязный. Что это вообще такое? Что за связи? Одна и две.
Что здесь происходит? Давайте с вами рассмотрим следующую структуру данных. У нас есть некоторые
ячейки, где мы будем хранить какое-то значение, так называемый ключ, а вторая ячейка будет
указывать на следующий элемент. И мы будем так делать сколько нам необходимо раз. То есть,
к примеру, я беру и говорю, что давайте тот же самый массив перепишем. Вот у меня есть 3, а нижняя
ячейка указывает на ячейку другую. Три, два, четыре, семь, девять и три. Похоже на массив? Похоже.
А теперь давайте поговорим вообще, как структура выглядит, что мы с ней будем делать. На самом деле,
вот каждая эта часть называется нодой. Ну, в английском нода, по факту узел, я не знаю,
как хотите назовите. Но я буду всегда называть это нодами. И ноды, они формируются не постоянно
как массивы в памяти компьютера, а они формируются так, что они просто создаются и друг на друга
указывают. Здесь очень важна роль тех самых указателей, которые у нас есть. То есть,
если рассмотреть эту ноду и взять динамическую память, то они вот где-то вот тут вот существуют,
в некоторых рандомных моментах, куда запихнул их компиляторы и друг друга указывают. Вот так. Вот это
и будет лист. То есть, лист на каждом из этапов будет брать, и это односвязанный лист, у него одна
всего лишь связь. Он будет на каждом этапе брать и создавать какие-то элементики и вставлять их
куда-то. Давайте подумаем, чем хорош лист. Для того, чтобы вставить какой-то элемент или удалить,
нам достаточно просто переподвязать этот элемент сюда, а отсюда сюда, а эту связь удалить. Так
мы вставляем новый элемент. Нет, почему? Одна связь. Ага. Да. Но если мы знаем, действительно,
указатель у нас есть, куда вставить, то все хорошо. Не поверите, для того, чтобы удалить какой-то
элемент из массива, вы тоже вряд ли знаете, у вас есть индекс. Вы говорите, я удалю и ты элемент,
а если он соотносится, ну грубо говоря, не знаю, вы должны удалить минимум, то что вы должны? Взять
и пройтись по всему массиву, а потом еще сдвинуть все на n. Поэтому здесь все зависит от того, знаете,
вы указатели или нет. Грубо говоря, за счет чего вы находите этот самый указатель. Давай я пишу с
вами ту самую структурку ноды, которая у нас будет. У нас есть восхитительное слово
стракт, с которым вы сегодня познакомились, правда? Вот. Давайте опишем эту ноду. Что это за нода-то
такая? Смотрите, в ней хранится какое-то значение или какой-то ключ. Но я буду писать ключ. Вот у меня
есть тот самый ключ. И что в ней еще хранится? В ней хранится указатель на следующую ноду. То есть
какой тип имеет это? А, нод-звездочка, да. Нод-звездочка. Ну здесь можно назвать это просто next.
Давайте так назовем. Да. 3, 2, 6, 4. Это все. Это все значение. И вот это является нодой в нашем
понимании. Теперь смотрите, что важно понимать об односвязанных списках вообще в принципе. Ну
как бы нода-то есть. Это хорошо. Но главное в односвязанном списке что? Откуда мы еще пойдем? То есть
любой лист односвязанный, к примеру, нам необходимо взять и понять откуда мы идем. То есть что является,
так сказать, головой этого листа. Согласны? Вот поэтому на самом деле к этому всему добавляется
еще одна структурка. Давайте я тут буду писать. Да. Какое-то значение, которое хранится. Вот массиве
в ячейке у вас хранится чиселка. Вот здесь тоже чиселка. Вторая ячейка это тот самый указатель.
Вот это и есть указатель. Смотрите, вот отсюда я указываю сюда, отсюда сюда, отсюда сюда. Понятно?
Конечно можем. Или плохо другой вопрос, но конечно можем. Нам никто не мешает этого делать.
Да, конечно. То есть последний элемент, для того чтобы понять, что он последний,
он должен указывать, что его next это nullptr. Это правда.
Вот. Теперь смотрите, как выглядит этот лист. Ну, если рассмотреть прям как лист-лист,
взять написать некоторую структуру. Давайте не тут. Давайте вот тут. Структ. Ну, forward-лист.
Forward-лист. То, что в этом листе хранится, да на самом деле всего лишь один указатель.
Как вы думаете, как я его назову?
Вот это и есть лист в нашем понимании. Но что важно здесь всегда осознавать,
что предположим-то такие структурки-то у нас есть, надо научиться с ними работать.
Что нам нужно научиться делать? Для начала лист создается, и создается он со значением,
что у него главной элемент nullptr. Лист пустой. Согласны? Вот. Можно по умолчанию здесь написать
равно nullptr, но я так делать не буду. Можно это сделать, но типа вот здесь, как в вашей
душе угодно. Это не будет ни ошибкой, ни чем. Вот. Я лишь скажу просто в самом начале,
что это будет nullptr. А дальше мы должны начать добавлять эти ноды. То есть мне нужна по-хорошему,
давайте сюда напишу. Мне нужна какая-то функция add, которая скорее всего будет voidовская,
но это не сто процентов. Которая будет принимать тебя. Что? Лист? Правильно?
Ну, я буду добавлять элемент в конец пока что. Или мы сразу захотим в сериал.
Хорошо. Тогда нам нужен, тогда нам лист особо-то не нужен на самом деле. По какой причине? Потому
что у листа есть только одно head. Конечно, сюда можно добавить size, сколько у нас элементик
в группах хранится и так далее. Вы здесь можете модифицировать, как вам удобнее. Вот. Но окей,
если мы будем с вами просто добавлять элементы, то нам что нужно? Нам нужен указатель просто на
некоторую ноду. Правильно? Чтобы понять, в какое место мы будем вставлять. Из-за этой
ноды будем что-то делать. Правильно? Вот здесь мы делаем с вами ноду звездочка. Какой-то указатель.
Правильно? Которая будет указывать на что? На какую-то из нод. Ага. Вот. И, например, какое-то
значение D я буду вставлять. Не ноду, а D. Чиселка. Согласны? Что в этом случае я с вами должен
делать здесь? Я пишу это специально на плюсах, не потому что я стал к вам... Я начал вам рассказывать
все про плюсы, а потому что указатели есть в плюсах. Вот. С псевдокодом немного сложнее. Там нет их так
таковой. Вот. Поэтому я пишу именно так, как есть. В начале что мы должны сделать? Мы должны сказать,
что у нас должна появиться новая нода. Правильно? Поэтому я пишу нод звездочка,
new, нода равна new, нода. Согласны? Даю это в динамическую память. Дальше у этой новой ноды
что я должен сделать? Я должен сказать, что у нее значение ключа чему равно. Д. И пока кажется все,
потому что следующий мы не понимаем какой. Но мы с вами договариваемся, что если я указываю на
какую-то ноду, то я вставляю после нее. Правильно? Согласны? Тогда я должен сказать, что у нее нода.
Next. Чему она равна?
Ссылку на ПТР? Правда? ПТР, next, нода, звездочка.
Стрелочка для вас равносильна следующему, что я делаю звездочку от какого-то от ню нода,
например. Это я смотрю элементы, которые находятся в структурке. Правильно? Ну,
разыми новую структуру. Точка. Точка next. Пока все понятно. Окей. Вот. Мы начинаем указывать на
следующую часть. Что нам осталось сделать? Нам осталось, смотрите, у меня появилась вот эта стрелочка.
Согласны? Да? Мне осталось просто поменять вот эту стрелочку. Правда? Ну, давайте это сделаем.
То есть мы скажем, что ПТР, next, это новая нода. Согласны? Это и есть оставка.
Он указывал на четверку. Теперь я взял и поменял на шестерку. Ну, то есть у меня была вот такая
стрелочка, я ее сразу поменял. Вот. То есть я не удалял эту связь, я просто взял и заменил. Да.
И вот к вам вопрос. Ставить элемент я вставлю. Я даже представляю, куда мне вставить этот элемент.
Да? Но. А когда у меня лист пустой? Куда вставлять? К ПТР я обратиться не могу. У
на ЛПТР ничего не существует. Согласны? То есть здесь должно быть что-то, что создает новый элементик,
новую очередь, грубо говоря. Новый лист, прошу прощения. Новый лист. Согласны? Что-то должно
да произойти. Интрига. Как назовем такую функцию? Create list. Ну хорошо. Так. Куда?
То что? А тогда как вы будете обращаться к этому листу? Так. Нам нужно, смотрите, во-первых,
вам нужно как-то эту структуру впихнуть туда. Согласны? Потому что иначе он не будет понимать,
что происходит. Может, я просто сумасшедший, у которого там ПТР и НалПТР, я просто в рандомные
места что-то пихаю. Такое тоже возможно. А вот. Вот такое. Тестирование, грубо говоря, у нас не
проходит. Тестирование на дурачка. Что поделать? Ну как бы мы будем считать, что мы все-таки умные
люди и будем туда НалПТР пихать. Согласны? Вот. Что же касается Create? Ну давайте хорошо.
Create, Create. Мы с вами по чуть-чуть должны описать эту всю очередь, а потом найти ее применение
вообще. Очередь-то очередь, ой, лист-то листом. Но какое применение-то в итоге у нас будет? Мы
будем с вами от этого отталкиваться. Давайте сделаем Void, Create, List. Ну вообще Forward, List,
но давайте Ablist. Хорошо. В одну сторону смотрит. Вот. Поэтому и Forward. Что он делает? Он принимает
к себе лист. Ну скорее он даже принимает его по ссылке. Ага. Ну и когда мы его будем создавать,
наверное, мы будем создавать с каким-то значением первым, правда? Поэтому я здесь
делаю int D также. Окей. Ну заходите пустой создавать, ну создайте с нулем. Менять всегда можно.
Хорошо. Мы создаем этот листик. И что мы делаем? В этот момент мы должны сказать, что у него
должен появиться новое 2 у этого листа, потому что пока у нас он безголовый. Это не очень хорошо.
А? F нижнее подчеркиваемое. Что я в этом случае делаю? Я говорю следующее, что мне нужно создать ноду,
и первая нода, когда она будет одна единственная, куда будет ptr next смотреть? 0 ptr. Поэтому здесь я
просто говорю, что f лист точка, потому что он по ссылке, ага, head равняется. Почему? New нода,
да? Спойлер, вот там вот я так писал через равно. Неприкольно, так не пишут. Я пишу здесь D и
на lptr. Красиво. Мы создаем лист. Да. Лист и D. D это вот тот самый первый элементик,
здесь это троечка, грубо говоря. Ещё вопросы? Можно. Другой вопрос. Можем, конечно.
Это правда, но нам нужно просто head будет двигать и всё. То есть это отдельный add должен быть. Мы
договорились, что мы вставляем с вами за элемент. Просто если бы мы договорились,
что мы вставляем перед элементом, то мы последний элемент никогда бы не поменяли.
Вот. То есть я рассуждаю здесь в таких вот вещах. Вы можете написать там forward add и не знаю там,
ой, не forward, не... pref add и post add. Ну типа перед вставить, после вставить. Можете так
расписать. Это не сильно важно, но они будут похожи между собой. Вот. Я создал этот f лист.
Красиво? Или не очень? Или не нравится? Почему forward list? Давайте ещё раз. Forward
list. Чего не так? Какой пустой перемен. Ну смотрите. До этого вызова функции head считалось пустой.
Ну на lptr он указывал. Не то чтобы сильно пустой, но да. Да. Да. Ну вот f list.head.
Ещё раз. f list.head. Я обращаюсь именно к этой ноде. Я говорю, что этот указатель равен new
ноде. Это уже указатель, куда передают d и lptr. Да. Так я образую первую ноду ту самую. Да. Ну то есть
представьте, что у меня всех элементов нет. Вот куда эта тройка должна указать? На lptr,
если всех элементов нет. Вот всё. И смотрите, как бы это я сделал. Delete делается аналогично. Но
давайте его напишем. Если мне нужно удалить какую-то определённую ноду. То есть создавать
теперь я могу. Добавлять могу. Осталось удалять. Согласны? Вот. Тогда чё я с этим делаю? Я пишу,
что это тоже void-овская функция. CandleLit. Здесь благо нам не нужно договариваться,
мы удаляем перед или после. Поэтому просто удаляем. Мне нужна только лишь нода,
которую я удаляю. Как мне удалить это? Как вы думаете? А теперь вопрос. Как мы обратимся к предыдущему?
Ой. А? А функция обращения к предыдущему будет за сколько работать? За вуатен? Некруто.
Это не работает же. Они же в рандомных моментах существуют. У тебя же динамика,
динамическая, ну выделяет динамическую память в каких-то случайных местах. Что делать? Да.
Не бывает индексов? Это уже двухсъязанный список. То есть мы так решаем проблемы, правда?
Удалять элемент, который после идет? Хорошо. Будем удалять элемент, который идет после этого
ПТР. Решение? Ну решение в принципе. Вопрос следующий. А что если идет после NALPTR?
Если идет, то... Ну мы же можем удалить сам этот элемент, если у нас дальше идет NALPTR. Мы понимаем,
что он где? В конце. Но вопрос. А другой элемент, который... Вот тут мы удалим,
предположим. Да, вот этот будет указывать на удаленную память. Плохо. Это нельзя.
Видите, как много интересного здесь происходит? Кажется, что просто. Что делать? Хорошо, давайте
типа... Смотрите, сегодня лекция больше такая, импровизация у меня. Я все понимаю,
как это работает, я все это знаю, я все это рассказать могу, но мне интересно послушать вас и получим
что-нибудь. Вот. Так что давайте отталкиваться от этого. Давайте будем действительно удалять ноду
после. Какую? Как? Ровно так же, как крейтли сдалить. А как? Как к ним обратиться?
То есть, да, но мы же должны будем удалить оттуда. То есть, если мы переложим,
к примеру, вот здесь вот, вот это мы пытаемся удалить. Что в этом случае должно произойти?
Тогда мы вот этот элемент должны вот сюда перенести, правильно? Элемент, и на следующий элемент уже много.
Нет, почему? Числа не связаны между собой, ПТР между собой связаны.
Давайте, мы предыдущий элемент. Смотрите, правильно ли я понимаю. Вот я хочу удалить
эту семерку, да? Что вы мне предлагаете? Хорошо, давайте эту четверку удаляем. Что мы хотим?
Семерку передвинули. А теперь мы ничего не передвинули. Мы не умеем передвигать. Еще раз,
мне нужно удалить ноду. Если я не сделаю дилит, у меня будет утечка памяти. Когда у меня есть дилит,
у меня утечка памяти. Что делать? Ну, то есть, идея здесь, ну, в какой-то степени жизнеспособная.
С тем, что давайте вот эту семерку сюда переложим. У меня будет 7 и 7, да? А потом вот эту вот мы возьмем
и перенесем сюда. А другого варианта у тебя не будет. А какая разница? Ты удалишь эту или эту? Тут один и тот же кей.
Почему он перестанет быть связанным? Почему? Не станет. Единственное, в чем будет проблема,
что типа последний элемент мы так уже не удалим. Ну, то есть, давайте еще раз. Если вы мне говорите,
вот просто переложить кей сюда и удалить вот эту штуку, тогда я не могу последний элемент удалить.
Если я буду удалять next, тогда я не смогу удалить.
Вот, то есть, давайте здесь мы как бы сделаем что? Как вы хотите удалять элементы? Смотрите,
перекладывая что-то, это гораздо дольше, потому что, мало ли, эта структура занимает
очень много времени. Понимаете? То есть, мало ли, эта структура состоит из массива из тысячи элементов,
к примеру. Для того, чтобы их перевести друг от дружки, когда вы будете работать именно с рэями,
не с симассивами, а с рэами. Ну или какие-то вот структуры данных. Представьте, у меня там тысячи
полей. Вы все должны копировать между собой. Это плохо. Это нельзя так делать. Поэтому,
давайте договорились, что буду удалять следующий элемент после моей ноды. Странно? Странно,
правда? Но как это работает? А в конце удалим, типа final delete будет для хеда. Ну либо delete
хед. И в случае дилита хед, мы что сделаем? Мы просто передвинем хед на следующий элемент.
Будет он NullPTR или NullPTR, это нас уже не будет интересовать. Понятно?
А? Ну я могу написать хед равно NullPTR? Могу. В чем проблема? Короче, давайте с вами все-таки
напишем? Вот так. Его еще раз. Ну а в чем проблема? Нет, подождите, типа я напишу хед равно, а хед next.
Будет либо NullPTR, либо не NullPTR. Тут меня не интересует уже. Вот, то есть, смотрите,
мне приходится как-то выкручиваться. Вообще, типа не прикольно, не классно. Но давайте,
сейчас что-нибудь да напишем, там что-нибудь да заработает, и вы примерно так и решаете контест.
Вот, так что я все знаю. Копировать данные нельзя. Как ты их поменяешь? Никак. Еще раз.
Указатель указывает на всю ноду. На всю ноду. И указатель мало занимает, это факт. Но ты не
можешь взять и переложить что-то. У кого? И толку. Но эту семерку-то я должен переложить?
Нет, потому что вот этот будет все еще указывать сюда. Давайте это. Соберитесь. Понимаешь,
что уже не тривиально? Кажется, очень простой структур данных, правда? Простейше тебе вообще.
Вот столько вопросов возникает. Это всегда так, на самом деле. А если кажется, что просто,
значит, что-то вы сделали не так. Такое бывает. Короче, если мы будем удалять следующую ноду,
то это все достаточно просто. Как это сделать? Мы говорим, что мне для начала нужно сохранить
указатель на ту ноду, которую мы будем удалять. И предполагать, что это не... Ну, то есть,
мы должны будем указывать на следующий элемент. То есть, когда мы удаляем следующую ноду,
мне нужно указывать на следующий элемент. То есть, если я удаляю девятку, то мне нужно указать
вот сюда, к примеру, в тройку и так далее. Предположим, что такой элемент существует,
либо мне без разницы, если даже NullPtr, потому что удаление NullPtr к чему приводит?
Ни к чему. Его можно удалять. Поэтому я говорю, что нода звездочка newNext, не знаю, или как-нибудь так,
next равняется ptrNext. Вот так. Я раз перешел к следующему элементу и два перешел. Или, понятно,
что я сделаю? Смотрите, хорошо, давайте я поступлю по-другому. Да, окей, я понял, я вас сломаю.
Давайте я здесь сделаю newNode, а deleteNode. Она равняется ptrNext. Согласны, что я буду удалять,
ну ноды, вот это буду удалять. Правда? Теперь смотрите, я говорю, что ptrNext он чему равен?
Он равен deleteNode. Согласны? Вот я удаляю еще ноду, я должен взять newNext. Правда? Согласны?
Вот я это и делаю здесь. Ну а после этого что делаю? Вот я это удалил. DeleteNode показывает на ноду,
которую я должен удалить. Поэтому я должен на самом деле здесь просто написать с вами delete,
delete, deleteNode. Ну, вам не понравилось nextNext со стрелочками, поэтому я.
Вот мы можем сохранить либо указатель на следующий элемент от удаляемого,
либо мы можем сохранить указатель на удаляемый. Да, вот дальше вам придется вот типа вот у нас
был createList, вот у вас нужно удалить лист и так далее. Согласны ли вы с тем, что это ну какой-то
неприятный способ? Господи, стойте, вы чего? Вы куда? Я надеялся, что вы все понимаете. Смотрите,
у меня есть нода PTR. Вот это PTR. Она указывает дальше на какую-то еще ноду, да?
Это удаляемая нода deleteNode. Согласны? А вот это у нее следующая нода. Что я сохраняю? Я сначала
говорю, что deleteNode равна PTRnext, то есть вот она удаляемая нода. Согласны? Что я должен дальше
сделать? Я должен у PTR своего взять и пересечь его вот сюда. Согласны? А, и то есть я вот эту
связь нарушил. Теперь я просто так от deleteNode не могу подобраться. И для того, чтобы к ней
подобраться, я убил здесь. И после этого удаляю ноду. Ну, удаляю указатель, который был выделен
через NU. Я удаляю ноду. Я удаляю то, что хранится в этой ноде. Как вы писали deleteRay? Вы удаляли
указатель или вы удаляли весь массив? Вот ровно суть такая же. Да? Красиво? Не может. Вот,
но на самом деле вот односвязанные списки очень полезны. Давайте поговорим с вами немного про
другие структуры данных. Почему они не работают? Это нужно удалить, это правда. Но на самом деле
не хед, а вот этот кусочек, вот типа такого, когда у нас NullPTR в конце. Когда из одного элемента
состоит, грубо говоря. Вот эта часть, она неприятная. И хед тоже как-то неприятно удаляется. Все это в
принципе не очень приятно. Для нас выглядит так, что типа кощунство какое-то. Мы столько ИФов делаем.
Вы над этим поразвлекаетесь дома побольше. На самом деле достаточно писать ИФы здесь. Но я объясню,
зачем я сейчас вот это все рассказывал вам. Вот это все дает вам понимание следующего, что у нас
есть такая структура данных, и на самом деле она описываемая. Кажется, что здесь много строк,
на самом деле не так много. Ну типа тут чуть-чуть. Посидеть да потыкаться в них. Правильно ИФы
настроить еще на самом деле. То есть крайние случаи рассмотреть. Что же касается, то есть вот сюда я
могу написать там if ptrNext равен NullPTR, тогда я удаляю просто вот эту. Но мне нужно как-то там
понять, как мне сделать предыдущие элементы и так далее. Здесь я могу искать find какие-то
элементы, удалять за OATN и так далее. Существуют более разумные вещи на самом деле с этим всегда.
Но смотрите, мы с вами должны сегодня познакомиться с двумя еще очень важными вещами,
которые используются просто в неистовом количестве. Первое это stack. Кому знаком stack?
У вас много? Что такое stack? Давайте знаком и знаком, но не знаю. Вот такое может быть. Тарелка.
Да, stack реализован по принципу, а лифо. Кто понимает, как это расшифровывается?
Last in, first out. Тот, кто пришел последний, всегда будет выбывать первым. И в этом плане очень
интересно смотреть, чего нам тут делать. И вот этот stack по принципу лифо, мы будем смотреть,
как его реализовать. И stack сама по себе полезная структура данных. Например, для скобочных
последовательностей очень хорошо подходят. Правильных и так далее. И работает это именно
со stack. Stack можно представлять тарелочками, мусорным ведром, чем хотите. Где в действительности
элементы вот так наслаиваются, а потом они кладутся сверху, убираются сверху. Вот это и есть stack.
И stack может быть реализован на односвязанном списке. Кто представляет, как?
Можно добавлять только в конец и убирать только из конца, да? А? Какой? Как их связывать
между собой? Вот эти элементики. Вот смотрите, у меня есть элементики вот такой stack. Какую
сторону, во-первых, они будут все связаны? Вниз? А? В любую? А как удалять? Вот. Вопрос,
для какого варианта, чтобы я мог легко удалять элементы и легко их класть и
понимал куда? Смотрите, если я организую это вот таким вот образом, то в чем у меня будет проблема?
В том, что у меня есть голова, а класть мне надо в конец. Это плохо. Я должен так весь пройти. И
что делать? Как с этим жить? Конечно, есть вариант, что я буду указывать просто на этот элементик
еще. То есть у меня будет помимо head tail еще конец. Но это некрасиво. Здесь легче все элементики
связать вот так. И потом нужно подумать, как здесь удалять тогда все. То есть смотрите,
у меня есть два варианта. Первый я иду вот так, второй я иду вот так. В этом случае мне нужно
удалять верхний элемент. Согласны? Как удалять верхний элемент? Вот. Например. Но в действительности
удалить этот элемент это не очень сложно. Почему? Потому что если это является head,
то я просто должен переподвесить head сюда, а этот элемент удалить. Согласны? И вот оно будет
всегда так удаляться. То есть вот мне тут самое удаление head здесь и понадобится. Когда я буду
добавлять элементы, то что я буду делать? Я буду создавать здесь элементик и писать,
что он указывает на head, а потом head переподвешу сюда. Согласны? То есть вот тут stack есть так
называемый push и pop. Ага. Давайте их опишем, это интереснее. Поговорим про них. То есть вы уже
поняли, что с листом дела не очень, но вам придется с ним что-то делать. На самом деле со
stack. Что будет храниться в stack? Внутри stack само по себе будет что? Вообще по-хорошему там
односвязанный список, но вам можно сделать здесь просто, грубо говоря, голову ту самую. И сказать
следующее, что у меня есть нода. Ну, ноды у нас сохранились ровно такие же. После этого мне
нужно к примеру wait push. Я должен вставить элемент каким-то значением там x. Да? Как я вставляю
элемент? Я беру этот элемент, сначала его создаю, показываю, что он указывает на тот самый head,
а потом head переподвешу. Согласны? Поэтому здесь кроме index, прошу прощения, но я нужен еще и stack.
Вы можете дальше его просто написать. Вторым аргументом, но вообще лучше первым. Что я в этом
случае получаю? Что я делаю-то вообще? Все просто. Я говорю, что нод-звездочка. Не знаю, пусть будет
нода просто с маленькой буквы. Равно new. Ну да? Какие значения должны быть у этой нью ноды?
x и s точка head. Согласны? Ну, x это число, которое оставляю, push уже его. Push это положить сверху.
x и head. То есть теперь вот это вот мой созданный элемент вот здесь вот. Он уже указывает на ту самую
голову. Что осталось сделать? Поменять голову. Согласны? Написать, что x равняется ноде.
Согласны? Когда у нас пустой stack, это обрабатывается корректно? Да, обрабатывается
корректно. Потому что что у нас здесь? Здесь будет на lptr. Согласны? Все будет хорошо.
Указательно ноду. Мы не удаляем push вставить. Push закинуть что-то. Вот. Потому что у меня вниз
идет. У меня head сверху. Следующий момент. Связанным попом это удаление. Pop удаляет верхний
элемент. Я должен удалить. Иногда поп должен возвращать элемент, который удаляет и так далее.
Здесь сами решайте, как хотите реализовывать. Я буду удалять без возвращения этого элемента.
Я делаю поп. Как мне удалить верхний элемент? Мне нужно сначала найти вот эту новую head,
которая будет. А потом удалить head и переподвести. Согласны? Я сначала нахожу это новое и так далее.
Согласны? Какая здесь может быть проблема? Из-за того, что я нахожу следующий элемент,
что будет у меня, когда стэк пустой? Грустно будет, правда? Вот. Поэтому в этом плане лучше
написать что-то вроде if s.head не равно nullptr. То есть только в этом случае мы что-то делаем.
Если там nullptr, то мы ничего не делаем. Потому что стэк так пустой. Зачем мне еще поп? Бывают
такие задачи, где гарантируется, что стэк никогда не будет пустой. Вот. Там разные бывают условия,
поэтому просто смотрите на это. If этот нужен будет или нет. А дальше я говорю, что нода
звездочка new head равняется s.head, стрелочка next. Понятно, почему так? С, смотрите, вот я
эту ставку сейчас уберу. Вот у меня сейчас так находится. Head указывает сюда. Новая голова будет
указывать на следующий элемент. Согласны? Я говорю, что s.head, вот этот элемент, стрелочка next.
Понятно? Вот. Я говорю, что новая голова равна этому. Следующее, что я делаю, я делаю delete.
s.head удаляю эту голову и говорю, что s.head равняется new head. Красиво?
Все, что нужно. Да. Как мы что? Указатель на следующий. Да. Указатель, ну вот через один.
s.head был тут, я на следующий смотрю. Next head. Head next. Ну вот он. Следующий элемент. Вопросы есть?
Согласны, что stack писать проще? Реализовано тоже на односвязанном списке. Это указатель на
ноду. Ноду. Тоже указатель на ноду. На следующую ноду после head. А head мне нужно удалить.
s.head не указатель на следующую ноду. s.head это указатель на самую главную первую ноду. Вот.
То есть если смотреть здесь, это вот это вот. Вот это с точки head. Да. Указатель на эту ноду. Я
должен буду переподвесить на следующую. Да. Какое я push? Ну то есть stack для чего предназначен?
Для push каких-то значений. 7, 3, 8, минус 1. Чиселки? Часть всего. Бывают не чиселки? Бывают чары
какие-нибудь. Есть вопросы еще? Ноду, в которой хранится ключ и то, что следующий элемент равен
хеду. И хед переподвешиваю. Ну то есть у меня в начале, когда я делаю push. Давайте еще раз. Всем
остальным понятно или нет? Так на всякий случай. Давайте еще раз. Вот я должен вставить элемент. Я
создаю вот эту ноду. Хед у меня указывает вот сюда. Да. Согласен? Отлично. Теперь я делаю. А я что
должен сделать? Я создал вот этот элемент, новую ноду. Эту новую ноду я связываю с хедом. То есть вот
это вот с хед, это оттуда. И теперь я должен хед переподвесить сюда. Вот теперь встал такие.
Хорошо. Вот это все в стэке. Есть вопросы к стэку? Понятный стэк. Посмотрю на вас тогда дальше. Вот.
Окей. Это то, что касается стэка. То есть last in first out это очень полезная штука. Существует еще
другая вещь. Очередь. Представьте, что вы идете в поликлинику МФТИ. Вот. Не самое приятное чудо и там
очередь часто бывает. Вот. Вы приходите в эту очередь и становитесь в нее. По какому принципу оно работает?
По принципу FIFO. First in first out. Тот, кто первый пришел, тот и получил. Ну или в мир, о чем вы стоите,
не знаю. Может в поликлинику вы не ходили уже. Вот. Этот человек старый. Все. Сыплюсь. Короче. Да.
Очередь работает немного по другому принципу. Давайте я все это буду стирать. Давайте думать,
как эту очередь вообще можно реализовывать и можно ли как-нибудь просто это делать.
Смотрите. Что касается очереди. Очередь выглядит так, что у нас есть эти элементики.
И, ну, предположим, очередь идет туда. То есть я должен удалять элементы какие? Вот отсюда.
А добавлять? Вот сюда. Как жить? Ну, то есть смотрите, мне нужно как-то удалять с конца,
вставлять в начало. Так. Два указателя каких? Да. Вот именно поэтому я вам специально не рассказывал
двухсвязный список, потому что как только двухсвязный список вы узнаете, вы считаете,
что очередь нужно делать через двухсвязный список. Нет. Достаточно через одна связка.
В какую сторону здесь стоит направить все? Влево или вправо? То есть, да, у меня будет
указатель действительно на tail и на head. Что делать? Как жить? Направо? Направо. Вопрос
следующий. Как не удалять элементы? Ну, я буду удалять этот элемент, а как я вот tail
возьму и передвину сюда? Зову от единицы. Ладно. Направляю в другую сторону. Как добавлять
элементы? Правильно. В этом плане правда. То есть, смотрите, хоть моя очередь смотрит в ту сторону,
направлять очередь необходимо в другую. Для корректной здесь реализации. Почему это просто?
Потому что здесь tail, когда будет удалять, он будет в действительности удалять элементы,
переходить просто к следующему. Когда он будет добавлять сюда элементы, то что мне достаточно?
Мне достаточно head связать с ним. Правильно? Вот. И перенести head вот сюда. Все просто?
Просто. Догласна? Да. Sorry. Давайте сделаем вот так. А нет, стоп, удаление. А удаление сначала,
все правильно, головы в очереди. Добавление в конец. Прошу прощения. Вот в эту сторону.
Право налево. Еще куда? Как вам еще это объяснить? Давайте еще раз отру. Вот. С head до tail.
Tail вставляется, в head удаляется. Да, я прошу прощения. Что-то я неправильно сказал.
А пишем такую очередь. А потом чуть-чуть расскажу еще про двухсвязанные списки.
С ними все проще, вы там легко сможете все, что хотите удалять, делать и так далее.
Но если мы говорим с вами про очередь, то в этой структуре, кто знает,
как правильно читается очередь по-английски? Просто кью, друзья. Вот. В этой структуре лежит
следующее. Лежит указатель на tail и указатель на head. На самом деле, на самом деле в стэк
периодически добавляют size, в кью добавляют периодически size. Зачем это нужно? Иногда
нужно выяснить, сколько элементов в стэке находится. И либо мы будем перебирать все
элементы. Либо просто хранить здесь size при push, увеличивать size на 1, при pop уменьшать.
Понятно? Аналогично здесь можно сделать. Пока я вам без size делаю, без всего, но вы это можете
делать самостоятельно. Я думаю, добавить строчку вы умеете, правда? Вроде несложно. Вот. У нас есть кью.
Еще раз. Вопрос снят. Все. Если вопрос снят, то все хорошо. Окей. Давайте с вами описывать все это.
В очереди все называется не pop и push. А кто знает как? А? Нет. Еще раз.
Декью. Это удаление, но не инкью. Ну давайте с вами скажем, что у нас есть insert, есть delete. Хорошо?
Дальше, если вас попросят как-то по-другому называть, то называем по-другому. Окей. Если я говорю с вами
о вставке, а в мою очередь q какого-то элемента x, что в этом случае я с вами делаю? Я делаю
следующее. Я вначале создаю ноду. А нода куда будет указывать? А? Нет. Нод tail. Я же вот это...
А. Прошу прощения, да, на NLPTR. Туда. Да. На NLPTR. Все верно. То есть я делаю нода, звездочка,
а new-noda равняется new-noda с x и NLPTR. Правильно? Согласны? Отлично. Теперь я говорю, что tail
next, а q tail. Правильно. q tail next равно new-noda. А после этого, что я должен сказать? Что tail, q tail,
q tail равен new-noda. Все. Какая здесь есть проблемка? О том, что q tail, если NLPTR, то это все плохо,
то вот этой строчки не нужно. Мне достаточно будет просто создать элементик и сказать,
что tail теперь new-noda. Согласны? При добавлении. То есть вот это должно работать только в одном случае,
если tail не равен NLPTR. Да? Да. Ну то есть если пусто, тогда tail будет NLPTR. Поэтому вот здесь вы
должны написать if q tail не равен NLPTR. Вот так и вот так. То есть вот эта строчка, она только в
этом случае работает. В остальных все то же самое. То есть если у нас, к примеру, пустая очередь,
тогда я создаю ноду и говорю, что q tail равно new-node. Правильно? Правильно. Все просто. Единственное,
что если у нас был NLPTR, то куда должен head указывать? Вот. То есть у нас есть проблема в том,
что если очередь была пустая, то head был NLPTR. Но я добавил элемент. Хедом что должно произойти?
Да. Поэтому здесь я должен написать с вами еще кое-что. Что если q head равен NLPTR. Да? А здесь не
равен. Здесь не равен. Можно в else идти. Хорошо. Можно в else тут написать else там что-то еще. Ну,
как хотите. Действительно. Но если q head равен NLPTR, тогда q head равен new-node. То есть не забывайте
об этих вещах. То есть смотрите на те самые крайние случаи, которые существуют. Вот. Это
просто всего лишь ставка. Что будет с удалением? Почти, да? Вот. А сделаем здесь void delete.
Из очереди. Просто из очереди. Ничего больше не надо. Я беру и удаляю эти элементики. Все нормально,
все хорошо. Теперь следующий момент. Я удаляю элемент из q. А может ли очередь быть пустая? Может
быть. В каком случае очередь пустая? Если head равен NLPTR, ну или если tail равен NLPTR,
правильно? Ну, или если бы мы добавили size, если бы size был равен нулю. Можно написать любую
здесь. Давайте напишем. Если head не равен NLPTR. Если head не равен NLPTR, то я должен удалить этот
элемент. Правильно? А я его удаляю. И на что мне будет указывать head? На следующий после этого
элемент. Правильно? Согласны? Поэтому здесь я говорю следующее. Все так же, нода, звездочка.
Делить нода равняется q.head. Я удаляю тот самый head, который у меня есть. После этого я говорю,
что q.head равен q.head next. Все правильно. Согласны? Согласны. Переношу. И дальше я делаю delete.
Delete нода. Согласны? Ну удаляю. То есть я head переподвесил и удаляю этот элементик. Вопрос,
это все я должен тут написать или нет? Правильно. Если у меня после этого q.head стал равен NLPTR,
то я должен сказать, что q.tail тоже должен стать NLPTR. Согласны?
Нет. Да, мы уже удалили, поэтому оно все изменилось.
Так, хвост. Смотрите, q.tail равно нью ноде. Это нью нода, она может быть NLPTR и NLPTR,
поэтому мне тут без разницы. Оно всегда равно нью ноде. Мы же вставляем элементы,
элемент хоть один всегда да есть. Вопросы. Понятно, как работает очередь? Вопросы есть
к этому всему? Все понятно. А смысл? Тогда для полного вашего познания и чтобы ваше
мировоззрение было полностью знакомо со всем, что существует в мире, на данный момент к вам
применимое. Мы с вами чуть-чуть, вот пять минуток нам будет достаточно, существует другой двунаправленный
лист. Что это такое? Смотрите, когда мы с вами говорили про лист, мы говорили, что мы его
направляем в одну сторону, правильно? Двунаправленный лист управляется в две стороны. То есть у него
один указатель смотрит на предыдущий, другой на следующий, а этот будет смотреть сюда, а этот сюда,
это сюда, это сюда. Можете его самостоятельно реализовать? Я думаю да. Вот, то есть ключ будет
храниться сверху и так далее. Тем хороша такая очередь, тем что мы также можем вставлять элементы
в любое рандомное место. Мы можем с вами удалять элементы из любого рандомного места. И причем
здесь delete будет работать ровно так, как мы планируем, что если мы удаляем конкретный элемент,
то мы очень легко его удалим, потому что у нас есть указатель и на предыдущий, и на следующий.
Правильно? Все становится гораздо проще. И вот на таком вот двухсвязном списке работает
так называемый дек. Пишется он декью. Что это такое? Никогда не пишите, Господи, дек как доску.
Меня один раз убили, когда мне написали вот так. Я сломался. Я вначале не понял, что это значит. А дек
это двунаправленная очередь, поэтому она декью. Ну вот кью есть? Напишите декью. Декью и е, хорошо.
Ну на самом деле дек это такая структура данных, которая позволяет нам добавлять
элементы в начало и в конец и удалять элементы из начала и из конца. То есть она работает,
ну вот она не просто так называется двунаправленная очередь, потому что и в одну сторону как очередь,
и в другую сторону как очередь. И вот этот дек, он позволяет как раз-таки вставлять вот эти
элементики туда-сюда и удалять туда-сюда. Это первое ваше знакомство с деком. В действительности
дек реализован в плюсах вообще по-другому. Вот кто там спрашивал, можно ли зациклить лист,
вот это оно. Оно сделано с помощью такого циклического буфера, где каждый элементик это
лист отдельный, направленный в одну из сторон. Там много всего интересного на самом деле благодаря
этому. А сделано это было только для одной причины, для того чтобы можно было обращаться по индексу
в деке. Зову от единички. И всё. Вот, на сегодня лекция закончена. Всем большое спасибо.
