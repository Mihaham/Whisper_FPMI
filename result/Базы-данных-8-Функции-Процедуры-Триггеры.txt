Восьмая лекция нашего курса, функции процедуры триггера, расширенные возможностями.
Позгресс, процедурное расширение, позволяющее добавлять сложную логику обработки запросов.
Сегодня посмотрим на эту тему и будет сегодня лекция чуть короче обычного.
Функции процедуры, в принципе здесь, поскольку вы уже люди, представляющие себе,
что такое компьютер science и программирование, функции процедуры для вас соответственно,
вещь вполне знакомая. В позгрессе здесь нет каких-то серьезных нюансов по сравнению с
общепринятыми подходами, исключение здесь, пожалуй, составляет только то, что в отличие
от типичных императивных языков, с которыми вы встречались, то, что в позгресс, во всяком
случае в том процедуре расширения PLPG SQL, которая по умолчанию используется в позгрессе,
функции процедуры там пишутся не на императивных языках соответственно, а на таком вот немножко
доработанном варианте SQL, то есть по сути дела получается тоже смесь декларативной с императивной
парадигмой. Можно писать как функции, так и процедуры, в позгрессе соответственно,
отличаются они довольно просто, процедура не возвращает никогда никакие значения и есть разница
с точки зрения вызова функций процедур, вызов происходит посредством специальной команды call,
в то время как вызов функции допустим в принципе в любом месте, где можно расположить встроенную
функцию SQL для того, что вы можете, если из таких вот относительно фантастических примеров назначить
функцию на заполнение по умолчанию какого-нибудь поля в таблице, сделать там не дата стэмп,
а не дейт стэмп, а сделать какую-нибудь свою специфическую функцию, которая будет вам выдавать
например время исключительно там в вашем каком-то формате, условно говоря, конечно,
не ограничивается, не только можно время менять, можно в принципе, повторюсь, в любое место,
где употреблены функции встроенной SQL, можно вставлять, можно помещать в свою определенную
функцию при условии, что она соответственно подходит по контексту, по принимаемым,
возвращаемым значениям и таким образом существенно расширять встроенный функционал.
Также на TLPJ SQL, в частности, возможно писать не только сугубо функции процедуры,
есть еще подкласс функций специфических под названием триггера, то есть такие функции,
которые выполняются условно независимо от ваших действий, ну скажем так, они конечно
зависит от реально производимых действий, но есть нюанс заключающийся в том, что они
непроизвольно выполняются при операциях, добавления, удаления, обновления данных к таблице.
Также, по умолчанию, модуль TLPJ SQL встроен в поставку стандартной позгрысы, но при желании
его можно исключить, таким образом повысив, например, безопасность на некоторой степени
базы данных, тем что она будет более предсказуема и меньше соответственно возможностей будет по ее
изменению, если уж у него пользователь, то у каких-то сторонних администраторов. А как уже было
сказано, функции и процедуры различаются, два вида хранимых процедур, то есть родовое понятие
хранимые процедуры, но видовое, одно из видовых понятий, как бы такое-то автологично немного,
тоже называется процедурой, то есть как уже было сказано, не возвращает результат процедуры в
отличие от функции, специальный оператор вызова и также важное еще отличие функции от процедуры
заключается в том, что функции всегда выполняются в рамках одной транзакции, а процедуры могут
транзакциями управлять. В качестве хранимых функций и процедурах можно использовать
оператор SQL, в любом случае для языка PLPG SQL, потому что Postgres в принципе понимает не
только PLPG из коробки, он также понимает C по умолчанию, как внутренний язык базы данных
Postgres, также еще Python, Perl и TCL. Для других языков также есть свои расширения, можно в принципе
писать свои функции и на них. Также важно отметить, что у нас нет каких-то способов передачи внутри
процесса базы данных, скажем так, нет прямого способа, задокументированного в стандарте или
в документации непосредственно, нет там команды SafeResult, какого-то условно говоря, такого нет,
мы не можем передавать данные внутри процесса нашей базы данных, в широком смысле, так может
быть много процессов. В общем, у нас нет возможности напрямую передавать эти данные через какую-то
переменную или глобальную переменную, а у нас данные передаются между вызовами функций и
процедур путем предоставления пользователям внутри своего запроса из клиентского приложения.
Ну, как уже было сказано, что у нас есть несколько, грубо говоря, встроенных языков,
на которых можно писать под программы. Главное, чтобы он был известен серверу, есть известные
серверы из коробки, что называется, есть неизвестные, для них, повторюсь, есть
здесь вы в принципе не ограничены. Ну, конечно, чем нативнее уровень, тем оптимальнее будут
работать ваши запросы, и самое главное, тем прочее будет оптимизатору запросов ваши запросы считать,
составлять по ним статистику и как-то прогнозировать с точки зрения составления
деревьев запросов и каких-то оптимальных путей выполнения тех команд, с которыми
вы обращаетесь к серверу базы данных. В этом смысле, в идеале, лучше писать, конечно, лучше,
не то что лучше, проще для сервера писать, чтобы вы писали команды на PLPG SQL.
Синтаксис приведен на экране такой минималистичный, синтаксис создания функций.
Да, мы отдельно про процедуры в данном случае не говорить не будем с вами, потому что по большому
счету это практически синонимичное изложение будет. Поэтому, с точки зрения синтаксис,
с точки зрения примеров, по сути дела все, о чем мы сейчас скажем, применительно к функциям,
применимо и к процедурам. Небольшие различия подробно описываются в стандарте документации.
А синтаксис приведен на слайде, он минималистичен в том смысле, что если вы обратитесь к документации,
увидите, что, конечно, гораздо более разветвленное есть описание, но по большому счету все,
что нам нужно, это для создания функций, имеется в виду команда Create Function или Create Procedure будет
в случае процедуры, имя функции с параметрами и команда Returns, после которой следует тип
возвращаемого значения, и тело функции и указание на язык. Важно отметить еще, что у нас есть различного
рода модификаторы, например, переменных. Мы можем назначать тип In, Out, Variedic, In, Out, то есть мы можем
задавать явно по отношению к переменным, могут ли они принимать возвращаемые значения или не могут,
может ли функция их перезаписывать или нет. Функция может возвращать пустой тип Void, то есть не
возвращать ничего, грубо говоря, можно обозначить это как Void, и по сути дела ваша функция станет
аналогом процедуры. Обязательно указывается язык, и варианты указания описания тела функции можно
указывать в одинарных хавычках, можно в двойных долларах, лучше в двойных долларах указывать,
и внутри тела может быть объявление в виде блока. Если что-то простое пишется,
там можно, конечно, максимально все это упростить, но по умолчанию у вас есть три,
ну здесь даже по сути, это тогда, наверное, четыре ключевых слова для объявления блока,
это Declare, оно не обязательно, BeginEnd обязательно и exceptions тоже не обязательно для обработки
исключения. На уровне Declare вы объявляете описание локальных переменных, их имя, их тип данных,
да, кстати говоря, тип данных, она можно указывать в переменную и тип данных в объявление функции.
Можно указывать просто тип данных, и тогда вы должны будете обязательно следить за тем,
что вы передаете и за тем, как вы обращаетесь к своим аргументам.
С точки зрения, опять же, возвращаясь в будущую структуру объявления, определение функции,
вернее, в разделе BeginEnd содержится список выполнимых операторов, как сказано было,
да, допускается раздел exception, обрабатывающий исключения, но он тоже не обязателен. С точки
зрения синтакса, что возможно, ну понятно, здесь все довольно классическим образом выглядит,
набор операторов для витления, вот условный оператор if-then и он начинается, оператор if-else,
вернее, прошу прощения, начинается он с if условия then и может либо иметь внутри себя какое-то
разветвление за счет союза else, да, или заканчивается просто по проверке единственного условия.
Можно сделать проверку альтернативных вариантов через оператор case, здесь есть два варианта уже
более сущностно отличающихся, мы можем проверять через case when условия или мы можем проверять
значение выражения, если мы после case непосредственно написали какое-то выражение, то после when можем
писать варианты значений, которые это выражение принимает и соответственно ветвить нашу логику
по этим значениям. Есть операторы цикла, базово цикл обозначается через команды loop and loop,
ключевые слова, вернее, внутри этих ключевых слов находятся операторы выполняемые, а количество
повторений цикла определяется с помощью заголовков, тоже в общем-то знакомых по
семейству и подобных во всяком случае языков точно. While условия, форма переменная in начало,
многоточие, конец buy и после buy можно шаг указать переменной и for it, если у нас есть какой-то
массив данных. Заголовки при этом пишутся перед ключевым словом loop первым, без заголовка цикл
повторяется бесконечно. Обратите внимание на for цикл for у нас он имеет такой необычный,
наверное, синтаксис с точки зрения наших процедурных классических языков, потому что мы
обозначаем после слова in начало, многоточие и конец нашего диапазона, в котором мы работаем по
циклу. То есть не предельные условия на границу, а обе границы цикла ставим, причем в такой не
совсем классической записи, через многоточие. Посмотрим на примеры, ну тоже довольно все здесь,
довольно все, наверное, понятно с точки зрения работы с функциями в процедурных языках. Здесь
в данном случае функция, которая у нас выведет предложение hello world, ну предложение hello world
она выведет, конечно, с репетом того, какой селек запрос написан в конце. То, о чем мы с вами
говорили, да, все это в данном случае у нас есть. Create Replace Function в данном случае проверяет
команда, если функция создана, она ее замещает, либо создает заново. А переменная P передается в
функцию, переменная с значением, с типом данных текст, объявляется также внутри блока Declare,
внутренняя переменная V тоже создача, с типом данных текст, и в блоке Begin End у нас происходит
конкатонация двух текстовых фрагментов и, соответственно, представление конца восклицательного
знака. С конечной строка будет hello world с колесательным знаком. Вот пример посложнее с циклом.
В данном случае у нас внутри цикла будет выдаваться значение номер нашей итерации,
по сути дела. Обратите внимание на цикл 4, как он написан, 1, 2.5 и опять же до заголовок цикла у
нас перед ключевым словом loop идет. Еще более сложный пример в данном, ну во всяком случае
громоздкий. В данном случае мы определили не просто числовую переменную, мы определили еще и
массив числовой в блоке Declare и мы итерируем нашу функцию по этому массиву, начиная с наименьшего,
заканчивая наибольшим числом массиве и тоже выводим значение каждого элемента полученного.
Пример функции с ветвлением с операторами if else. В данном случае у нас функция выведет положительное
число, ну ответ она выведет, что это положительное число, поскольку мы в select запросе передали число
5 и функция с примером ветвления через оператор case выведет ответ отлично, потому что
у нас переданный балл больше 90 и соответствует первому из обозначенных условий.
Также пример процедуры, ну как мы с вами говорили процедура у нас встречается в первую очередь тем,
что ничего не возвращает сама по себе, но в данном случае она вполне себе способна на побочный эффект,
на изменение базы данных, ну как собственно говоря и функция теоретически, но здесь на что
нужно обратить внимание. Вот у нас есть блок обработки исключения и в случае если у нас будут
какие-то проблемы связанные с тем, что функция вставляет email в базу данных, почту какого-то
пользователя вставляет, ну не create, а update user скорее так нужно было бы ее называть, но
функция вставляет данные о адресе электронной почты пользователя и если у нас
уже есть пользователь с данным email, то у нас соответственно не выполнится наша непростая
функция, еще и транзакция откатится назад по команде rollback в блоке exception. Здесь такой
немножко надуманный пример, потому что у нас по-хорошему надо было бы наверное update user
email что-нибудь такое делать, получается урезанный, мы вставляем вроде бы уже в существующего
пользователя запись его электронным почтом ящики, но попрошу не обращать внимания на
какую-то существенную, на сущностную часть вопроса, на содержательную с точки зрения того,
что функция делает, важно то как она делает в данном случае, в данном случае она создает
процедуру, данные функция процедуры в данном случае процедуры не выдают итоговых никаких
значений, опять же у нас здесь нет returns, ключевого слова, да никакого типа данных не обозначено,
есть блок exception, соответственно напоминаю, что вызываться такая процедура будет по специальной
команде call, call create user и ни в коем случае мы ее не сможем в запросе select использовать.
Обязательно использовать коммит? Нет, не обязательно по большим учетам, то есть в принципе у нас
окончание процедуры тоже получится автокоммита, тоже должно закончиться автокоммитом, ну здесь для
больше такой что ли наглядности и под условие что возможно есть какие-то параллельные транзакции,
давайте лучше мы здесь сделаем коммит в явном, явно сразу после добавления и на этом как бы все
закончим, а дальше уже там вот raise notice при приятное дополнение, лагирование операции,
как бы ни на что не влияющее, то есть не будем ждать пока система отработает, может у нас будет,
не знаю, поток выходной заполнен и мы ждать выполнения raise notice будем больше, чем по сути
дела проводить вставку данных в таблицу, поэтому коммит не обязателен, но желателен в случае если мы
хотим явно обозначить точку завершения транзакции. Есть и негативные последствия использования
функций процедур, но они такие, они не технологические, то есть дело не в изъянии технологий функций
процедур как таковой, а дело в собственно тех кто функции процедуры пишет и их использует, то бишь
у нас, ну во-первых, раздельное выполнение запросов, то есть вложенные запросы могут
преобразовываться в операцию соединения, если мы используем наш стандартный SQL syntax, однако
если мы размещаем наши под запросы какие-то структурированные запросы внутри функции, то
здесь мы добавляем для оптимизатора такое вот, как бы белое поле, он не всегда может просчитать
корректно, что и как происходит внутри наших функций процедур и вместо того, чтобы оптимизировать
наш запрос так, как он бы его оптимизировал, если бы это был чистый SQL, он будет, ну вот, я извиняюсь,
ступую идти по нашим инструкциям без каких-то исключений, ну как, если вы помните, у нас
обозначен был порядок выполнения SQL запроса, когда об этом говорили, то есть селек запроса,
в частности, мы когда говорили об этом, мы говорили, что у нас на уровне from и join идет
сначала декартовое произведение, причем буквально получается почти всегда, ну с точки зрения
описания, грубо говоря, да, идет декартовое произведение в отношении, если у нас несколько
отношений в запросе, и только потом идет фильтрация, даже если мы используем, на самом деле, join,
inner join, он какое-то условие, но на самом деле, конечно, никогда практически у нас не работает,
не то что никогда, а в минимальном числе случаев работает декартовое произведение,
оптимизатор максимально пытается всегда запросы сокращать для выполнения непосредственного,
ну вот, а здесь бы, наоборот, грубо говоря, было бы всегда декартовое произведение всех наших
join, потом выборка по условию, потом дополнительная выборка по условию, и так далее, и так далее,
ну вот, такой, может быть, надуманный пример, но смысл в том, чтобы вы понимали, у нас оптимизатор
внутри функции может не понимать, что происходит, для него это не всегда прозрачный код, даже если
мы там, казалось бы, пишем обычный SQL. Попущенный эффект функции процедуры, ну, собственно говоря,
то, о чем мы немножко вскользь упомянули только что на примере процедуры, как вы сами видели,
у нас функции процедуры могут в принципе повлиять на содержимое базы данных, если мы допустили
логические какие-то ошибки при формулировании наших функций процедуры, если мы что-то не
предусмотрели в нашей схеме данных, то последствия использования функций процедур,
последствия их работы могут быть неочевидными, могут нарушать, даже в том числе целостность
данных, если она неоптимальным образом поддерживается, ну, опять же, это ошибки не
технологические ошибки на уровне использования и пользователей, а недоступность оценок стоимости,
ну, вот, собственно говоря, да, это по сути дела то же самое, что и связано, во всяком случае,
связано с первым пунктом, оптимизатор не видит, не всегда может видеть, что происходит, не всегда,
во всяком случае, может понимать, что происходит внутри вашей функции процедур, и, как бы,
по умолчанию, ему проще, по большому счету, делать все последовательно, нежели оптимизировать.
Триггеры, особый вид хранимых процедур, пользователь их не вызывает непосредственно
на исполнение, их обусловлены действиями по модификации данных, insert, update, delete, truncate.
Триггеры это, по сути дела, просто функция, но у них есть небольшие особенности в определении,
и есть особенность по назначению триггера на конкретную таблицу или конкретное поле таблицы.
Триггеры могут существенно дополнить или изменить семаничку стандартных операторов SQL,
ну, в принципе, как и функции. И триггеры используются, в том числе, для поддержания
целостности базы данных, то есть, помимо штатных средств стандартного SQL, ключей, ограничений,
дефолтных значений, триггеры тоже являются таким средством, более продвинутым, более сложным,
позволяющим указывать более сложную логику, тоже являются средством поддержания целостности данных.
Ну, как бы, можно их рассматривать, скажем так, во всяком случае, они не обязательно являются,
способом поддержания мы можем всё что угодно с ними делать, но, конечно, лучше так делать не стоит,
лучше их в каких-то разумных пределах концептуальных для себя определить и использовать.
Ну и вот как один из вариантов поддержания целостности. Для создания триггерной функции
при определении хранимой процедуры нужно указать особый тип выходного значения.
Returns trigger, как показано на слайде. Вот, собственно, в принципе, главное отличие функции обычного триггера.
Помимо этого, собственно, триггер создается отдельным предложением Create, отдельный командный
Create trigger и обязательно при этом указывается, во-первых, время его срабатывания, а во-вторых,
события, на которые он срабатывает. Ну, конечно, да, имя таблицы. Ну, опять же, условно говоря,
получается, как вы видите, у нас не все здесь элементы обязательны, но вот время события и
имя таблицы, это вещи обязательные. Ну и, собственно говоря, необходимо задать, собственно, функцию,
которая будет выполняться при срабатывании триггера. Событие, как мы с вами говорили, insert, update, delete, truncate.
Обратите внимание на такой sub-bullet, sub-point. Существуют еще триггеры, которые не привязываются к действиям указанным,
а привязываются к командам DDL, то есть create, alter, drop, вот такого рода. Но они работают, скажем так,
несколько иначе и тоже, скажем так, у них несколько иной синтаксис, и мы их не будем рассматривать,
и сейчас не в курсе, в принципе, это как бы немножко отдельная тема. Мы будем сосредоточены на триггерах,
которые привязаны к data manipulation language и указанных командах. Триггерная функция должна вернуть либо null,
либо запись или строку соответствующую структуре таблицы, для которой сработал триггер.
Предложение for each row statement определяет, будет ли функция триггера срабатывать один раз для каждой
строки, либо SQL-оператор. Если не указано ничего, то подразумевается, что for each statement будет
работать триггерная функция, то есть для всего оператора. Для триггеров ограничений можно
только указать команду for each. Условия работы. Время срабатывания before, after и instead of и,
собственно говоря, события, и на что мы можем их назначать. Здесь что нужно обратить внимание,
на так называемые сторонние таблицы. По сути дела, речь идет о каких-то внешних данных. Данных
из внешних по отношению к базе данных таблиц. Может быть проще будет с точки зрения английского
языка это foreign tables. То есть повторюсь, да, таблицы, находящиеся, данные, находящиеся за
пределами нашей текущей базы, к которым мы обращаемся. Ну да, в общем-то из таблиц условия,
когда какие триггеры работают, в принципе, наверное, понятно. Здесь что еще можно сказать,
да, что у нас триггеры можно, помимо таблиц, вешать также и на представления и обуславливать
работу представлений каким-то. Когда у нас, соответственно, изменяемые представления меняют
данные в некоем отношении, можем таким образом триггерами менять явную логику, скажем так,
добавляя какие-то условия. Триггеры подразумевают, что при их использовании создаются специальные
переменные. Специальные переменные в триггерных функциях, ставные приведены на слайдах, они
используются для обращения внутри-триггерной функции к объектам базы данных. Ну, new, old, новая строка,
старая строка, tgName имя сработавшего триггера, tgName, tgWhen, когда, соответственно,
level, role и statement в зависимости от определения триггера, op, операция, table, name, таблица,
table, scheme, схема, название схемы. И еще из интересных, наверное, специальных переменных tgNarcs,
число аргументов в команде create trigger, которые передаются в триггерную функцию. Есть еще переменные,
некоторые, прошу прощения, некоторые переменные, там парочка, примерно, они остаются для
поддержания обратной совместимости. Есть более специфические переменные, если обратитесь к
документации, вы видите, но в принципе основные, перечисленные на слайде, new, old, name, when и так
далее. Несколько примеров. Создание триггера checkUpdate, соответственно, до обновления в таблице
счета для каждой записи, будет срабатывать функция, проверить обновление аккаунта.
Здесь, в принципе, то же самое практически, да, но create or replace триггера, соответственно,
будет заменен уже существующий триггер, если он существует. Обновляем баланс для таблицы
аккаунта, для таблиц и счетов. И более сложный пример, это триггер, который при любом добавлении
или изменении строки в таблице сохраняет в этой строке информацию о текущем пользователе,
и отметку времени. Кроме того, также он проверяет указания имени сотрудника и зарплаты с положительным
числом. Ну, то есть, по сути дела, здесь совмещение, да, отработки не просто какого-то более сложного
триггера, но и версионирование таблиц, о котором мы с вами говорили на позапрошлой лекции.
Создаем таблицу с сотрудниками, да, вот имя, заработная плата,
прошлая дата и прошлый пользователь. И создаем пункт наш триггерный,
ну и, собственно, что она делает. Во-первых, проверяет, указано ли имя сотрудника и зарплата.
Обратите внимание, у нас здесь идет new, как вы только что увидели, это обращение к временной
переменной, ну не к временной, а автоматически созданной переменной при использовании триггера,
то есть мы и обращаемся к новой строке. Если в новой строке имя сотрудника не заполнено,
тогда выдаются исключения, что мы не можем, что имя сотрудника не может быть пустым, нулевым.
Проверяется дальше также значение зарплаты в новой строке и тоже выдаются исключения в случае
отсутствия информации. Также указывается, что проверяется заработная плата на негативное
значение, по сути, не имеющее какого-то смысла, и также выдаются исключения. И, наконец, у нас в
нашу версионную часть таблицы, даже версионную часть записи, ту часть, которая отвечает за
прошлое значение, заносится данные о том, какой пользователь вносит значение и текущее
время, собственно говоря. Ну и заканчивается тем, что триггер функция возвращает запись new и,
собственно говоря, заканчивается само тело. Обратите внимание, у нас здесь между знаками доллара
есть дополнительная метка amp-stamp, ну, по сути дела это тегирование, это метка вот этого вот литерала
заключенного в двойные доллары. Ну, она в данном случае не является принципиальной, но принцип
синдексис допускает уточнение вот таких вот литералов двойных, заключенных в знаке двойного
доллара и обращение к такого рода информации, к такого рода меткам. И, собственно, мы создаем
теперь триггер amp-stamp, и мы назначаем время его использования до того, как вставляем или изменяем
данные в таблице amp, и для каждой записи мы обязываем триггер выполнять функцию amp-stamp,
описанную вот радио.
