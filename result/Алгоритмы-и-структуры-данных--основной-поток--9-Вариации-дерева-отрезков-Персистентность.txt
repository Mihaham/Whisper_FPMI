Здравствуйте! Давайте начинать. Мы продолжаем говорить про деревоотресков, то, что начали в
прошлый раз. Сегодня посмотрим всякие разные модификации, как можно в разных задачах это
использовать. Давайте начнем с динамического деревоотресков. Возможно, кому-то из вас привычнее
название неявное деревоотресков, но я предпочитаю динамическое. Задача, на самом деле, такая же,
как обычно. Давайте самую простую рассмотрим, потому что остальные более-менее так же просто
переносится. Представьте, что у вас массив был изначально не маленький, типа размера n,
который можно было сохранить в памяти, а представьте, что у вас был очень большой какой-то массив,
скажем там, размера 10 в 9. Ну и понятно, вы в памяти его сохранить не можете, но, допустим,
вы знаете, что изначально все элементы нулевые, и дальше с элементами происходит все то же
самое, что обычно, то есть обновление в точке суммы на отрезке. Короче, как обычная задача для
деревоотресков, только массив большой, грубо говоря, и изначально заполнен нулями. Давайте
напишем, что а0, а1 и так далее, а с индексом c-1, или не хочу я c писать. Давайте c как-то
необычно. Значит, изначально нули, ну и те же два типа запросов, это обновление в точке и сумма
на отрезке. Ну понятно, мы не можем создать деревоотресков на n элементах, потому что
слишком много, оно там даже в какую-то адекватную память не поместится. Тем более сверху надо
этим еще что-то достраивать. Давайте сделаем такую простую вещь. Давайте мы деревоотресков
наши, как будто бы виртуально построим на вот этом всем большом массиве. Но понятно, что изначально
там будет куча вершин, и во всех вершинах будут нули, потому что сумма в каждой точке будет 0,
ну потому что в поддереве все нули. Давайте нули не хранить. Давайте вот те вершины, в которых,
грубо говоря, в поддеревях которых еще ничего не происходило, то есть если вершина контролирует
какой-то вот такой вот подотрезок, и здесь ничего не происходило, к этим элементам не было
вообще никаких обращений, ну давайте просто эту вершину как бы не хранить. В ней все равно 0. Если
внезапно в какой-то момент времени мы захотим до нее дойти, то ее отсутствие нам однозначно говорит,
что там ничего не было, там все нули. Ну давайте так и сделаем. Давайте изначально заведем только
корень, давайте на всем нашем большом массиве. Изначально заведем только корневую вершину,
скажем, что она отвечает подотрезку всего массива от 0 до 1-1, ну и скажем, что в ней сумма 0.
Вот. А левого правого сына этой вершины просто нет. Левого правого сына нет. Ну и дальше,
когда будут поступать какие-то запросы, типа там обновление в точке, нам надо будет,
обновление в точке просто, надо от корня дойти до того самого листа, где хранится значение.
Давайте просто встанем в корень, ну и вот пойдем по тому пути, который надо. Если в какой-то
момент я пытаюсь перейти в вершину, которой нет, которую я еще не создал, ну давайте ее создадим,
мы и так понимаем, что там как бы 0, ее можно в любой момент создать, если надо, и пойдем дальше
просто. Так до листа спустимся. В момент, когда я пытаюсь перейти в еще не созданную вершину,
я всегда могу ее создать, сказать, что там сумма нулевая, ну и пойти дальше в ее поддерево,
туда, куда нужно. Вот такая очень простая идея. Просто давайте не хранить то, к чему
еще не было никаких обращений. Вершины, в которых мы еще не бывали,
давайте их просто не хранить.
Но они изначально все нули, поэтому их можно не хранить. Мы скажем, что у нас
такое соответствие, что если вершина еще не существует, значит к ней не было
запросов, значит сумма по дереве ноль. Ну и соответственно это для листьев тоже
верно. А если нам нужно что-то в листике поменять, ну давайте встанем в корень,
пойдем по той веточке, которая надо, чтобы дойти до того самого листа, ну и по
дороге все вот эти вот вершины создадим. Все вершины вот здесь, которые изначально
не созданы, давайте их создадим. В частности, создадим вершины, отвечающую
листу. Ну и там будет храниться то значение, которое надо.
Еще раз? Повторите, пожалуйста. Не понял, лог?
А, ну давайте разберемся, как это хранить. Храниться очень просто. Мы заводим
структурку, внутри которой, ну соответственно структура вершины какая-нибудь там,
структнот. Да, вот черный ящик, который хранит вершину. Что мне нужно хранить
в вершине? Давайте хранить координаты контролируемого подотреска. Что я
внутри храню? Я храню TLTR, координаты вот эти вот. Я храню сумму в подотреске,
и давайте буду хранить указатели на обоих сыновей, левого и правого. Давайте
я в C-стиле напишу. Note звездочка left, sun как-нибудь, и note звездочка right, sun.
То есть в каком-то смысле буду хранить указатели или какие-то ссылки на
детей. По умолчанию детей нет, по умолчанию здесь какие-то там нулевые
значения, обозначающие, что просто нет ни того сына, ни другого. И в момент, если
мне нужно будет перейти в какого-то из сыновей, если там не нулевой указатель,
то я могу в него перейти, я знаю, что это за сын. А если его нет, то я могу создать и
сказать, что теперь вот эта вот текущая вершина ссылается в качестве нового сына
туда-то. Я создаю новую вершинку и провожу указатель, что вот эта вершина
своим левым сыном имеет такую-то вершину. И как раз, если я храню указатель
на соседнюю, ну как на какого-то левого сына, я умею с стрелочками переходить.
Так же, как у нас было в, ну как бы, как в односвязанном списке у нас было, у нас
просто есть стрелочки в следующую вершину. Вот те же самые стрелочки я буду хранить.
Стрелку влево, стрелку вправо. По умолчанию они показывают в пустоту, а если есть
ребенок, то я его создаю, у меня указатель показывает туда, куда надо. Вот такая идея
простая. Вот, давайте напишем какой-нибудь апдейт, например. Как работает апдейт?
Ну, там как-нибудь вершину какую-нибудь принимаем. Не знаю, можно по указателю,
но не важно. Значит, принимаем позицию, где нужно изменить, и принимаем дельту,
на которой, принимаем х, на которой надо увеличивать значение. То есть это я буду
делать аппостой, плюс равно х. Вот. Ну, условия выхода из рекурса. Если мы пришли в лист,
то надо просто в этом листе сделать плюс равно. И давайте я в любом случае скажу, что v сам,
да, все-таки надо по указателю, да, потому что я не хочу копировать эту вершину, я хочу вот ту
самую вершину, которая, которая есть в дереве, я в ней хочу какие-то поля менять. Значит, поэтому
мне нужно будет вот так вот v сумм плюс равно х сделать, да, то есть я в вершинке v увеличу поле
сумм на х. Вот. Если пишите на джаве, то просто точка здесь. Вот это поле этой вершины изменяется
на х. Затем, если мы спустились в лист, то можно сделать return. Да, если vtl равно vtr,
тогда return. Мы спустились до листа, ниже идти не надо. Ну вот, а иначе понимаем, куда надо пойти в
лево или вправо, то есть скажем, как обычно, tm это полусумма координат t или tr, кругленно вниз. Ну
и понимаем, что если пост меньше либо равно tm, то надо пойти влево и, если что, лево сына создать,
а если больше, то надо пойти вправо и, если что, его тоже создать. Да? Вот, то есть если пост меньше
либо равно tm, то значит надо пойти влево, как обычно. Но давайте еще проверим, что левый сын
существует, а если не существует, то его создадим, потому что его несуществование просто значит,
что к нему еще не было никаких запросов, там ноль, в его всем под дереве ноль, поэтому можно просто
завести и все вот эти вот поля, там, сумму поставить нулевой. Ну давайте я не буду писать код, давайте
я напишу, что если левого сына нет, то его надо создать. Если левого сына нет, его надо создать.
Вот. Ну и просто запускаемся рекурсивно для левого сына, штаб date, where left sun, post x. Вот. Ну и
аналогично для права, давайте я не буду писать, там то же самое, только ну как бы здесь будет
противоположное условие, если правого сына нет, то его надо создать и спуститься вправо сына.
Значит, аналогично для правого сына. Кажется, все. Ну просто else можно писать. Ну да, вообще,
если пост больше чем tm, это правда. Ну вот вроде все, как обычно дерево отрезков, прям вообще
полностью. Только давайте не хранить вершины, к которым еще не поступало запросов. Если мы в них
не были, мы не храним. А если хочется, да, вот в момент, если мне хочется пойти в левого сына,
которого еще не существует, давайте его создадим. Благо мы знаем, какие у него все параметры. Мы
знаем, какой подотрезок он контролирует, стл птм в этом случае. Мы знаем, что там сумма нулевая,
потому что запросов не было. Ну и по умолчанию у него ни левого ни правого сына нету, потому что это
как бы пустая вершина, в ней ничего нет. И детей тоже нет. Все. Согласны? Вот, хорошо. Давайте скажем,
что это работает за log n времени и log n памяти. Ну log n времени понятно, потому что просто спуск
в дереве. Но по пути в худшем случае, я посещаю логарифмическое количество вершин, и в худшем
случае мне их все нужно создать. Поэтому вот здесь вот может потребоваться заведение, создание еще
логарифмического количества новых вершин. То есть, возможно, плюс от log n до памяти. В отличие от
обычного стандартного деревоотрезков, мне здесь приходится создавать новые вершины, у меня выделяется
новая память в процессе обработки апдейта. Поэтому здесь надо учитывать, что память выделяется.
Я создаю сыновей, поэтому память я из системы забираю. Ну вот. Ну, понятно. Ну, хорошо. С гетсамом
не сильно хитрее. Гетсам делается так же, как в обычном деревеотрезков. Только можно даже сделать
так. В момент, когда мы пытаемся спуститься в вершину, которой нет, вот, например, как в этом
случае, я пытаюсь пойти в левого сына, а левого сына нету. Можно просто туда не идти, потому что
если левого сына нет, то на самом деле это означает, что там все нули. В его подделе все нули. И если
я хочу узнать там сумму с какого-то подотрезка, то я автоматически знаю, что он нулевая. Если там
ничего не происходило, там все нули. Сумма автоматически с любого подотрезка нулевая. Поэтому
когда мы пишем get some, надо сделать проверку, что, если мы хотим пойти в левого сына и он есть,
тогда переходим. Иначе просто его скипаем, потому что если левого сына нет, то там сумма ноль. Вот.
Там даже никаких новых вершин заводить не нужно,
там просто это делается за логарифом времени, что
отлоган времени, ну и без ду памяти.
То есть там что-то тратится на стек рекурсии и так
далее, но новых вершин в дереве не создаётся.
С точки зрения структуры у меня ничего не увеличивается,
я так вольно напишу, что без ду памяти.
Мы ничего не удаляем, если вершину создали, то она у нас есть, мы ничего не удаляем.
Единственное в самом конце, когда у нас закончилась обработка всех запросов,
тогда чтобы память у нас не утекла, надо всё дерево очистить, ну просто все вершинки удалить.
А до этого момента мы ничего не удаляем, вот если вершина создалась, значит она есть,
для неё всё корректное будет, у неё будут корректные поля ТЛТР, у неё всегда будет
корректная сумма, у неё будут какие-то указатели лево-направо, мы её никогда не удаляем,
кроме вот в самом конце, когда заканчиваем обработку всего.
Так у нас какой-то момент памяти сломается, мы же не сможем создать всё дерево?
Ну, тогда мы не сможем сломать дерево, если у нас запросов, типа там, не знаю, очень много, порядка N.
Ну, наверное, такого не будет. Ну, скорее всего, имеется в виду, что у вас есть большой массив,
и в нём только к какому-то маленькому числу элементов вступают запросы, ну там, не знаю,
N10 в 9, а запросов у вас, типа, 10 в 6. Ну и тогда у вас не очень много будет вершин,
и с этим можно спокойно работать. Ну а если у вас ко всем элементам появляются запросы,
то ничего лучше, чем обычный дерево отрезков, конечно, не получится, если там, не знаю,
если запросов столько же, сколько элементов, то в худшем случае у вас всё дерево будет живое,
все элементы будут живые, ну ничего лучше, чем явно дерево отрезков хранить, ну как бы не получится.
Ну, это и запросов много, а если у вас много запросов, очень много времени на их обработку,
ну просто их надо все считать, по крайней мере. Короче, это обычно так не работает.
Так, дальше идем? Вот, хорошо. Значит, представьте себе теперь, что у нас можно было бы запросы знать
заранее. Вот, то есть сейчас я живу в такой парадигме, что у меня запросы поступают один за другим,
и мне нужно в каждом момент времени отвечать на тот запрос, который только что поступил.
Пришел запрос, я ответил. Пришел запрос, ответил. Пришел запрос гетсуммы, я запустил процедуру,
вывел, что она вывела. Больше ничего не делал, ну как бы, и жду следующую. Вот, а представьте,
что если все запросы известны заранее, внезапно. Значит, пусть все запросы известны заранее.
Вообще говоря, в реальных задачах это довольно вольное допущение, потому что, ну обычно там вам
поступают к вашей структуре какие-то запросы, приходят какие-то пользователи, что-то от вас
хотят, вы хотите им как можно быстрее отвечать. Вы не можете сначала дождаться всех запросов от
всех пользователей, и потом уже там что-то с ними делать. Обычно вам надо онлайн, но в некоторых
задачах, особенно в некоторых подзадачах, можно считать, что запросы есть в оффлайне,
например, вы там что-то делаете и вам нужна какая-то вот подпроцедура, которая делает
что-то такое. Но при этом вы знаете, какие запросы вы делаете ко всей вашей структуре. Ну вот если
у вас какая-то очень большая задача, и вы знаете какие запросы будут поступать к вашей структуре.
Ну, бывают такие ситуации.
Либо, например, не знаю, у вас какая-нибудь именно,
что какой-нибудь офлайновый протокол.
Представьте, что у вас есть какой-нибудь сервер,
к нему клиенты отправляют свои запросы.
Например, какой-нибудь аукцион закрытый.
Сначала все клиенты присылают свои ставки,
за сколько они готовы купить.
Вы все это узнаете, вы все это прочитываете,
никакую информацию не публикуете.
И потом только после этого на все внезапно как-то отвечаете.
Это редко, но бывает, скажем так.
Что тогда можно сделать в таком случае?
Можно сделать то, что называется сжатие координат.
Но это очень простая штука.
Давайте мы считаем все запросы,
сохраним все те координаты, все те точки,
с которыми мы что-то вообще делаем,
к которым что-то поступало, какие-то запросы поступали.
И на этих координатах построим обычное дерево отрезков.
Поскольку координат мало, если мы считаем,
что запросов не очень много.
Если запросы можно быстро обработать,
если их не очень много,
то активных координат,
активных точек, к которым что-то происходило,
будут не очень много.
И давайте на них построим обычные дерево отрезков.
Например, был у вас огромный какой-то массив,
вы считали все запросы, и знаете, что активными,
то есть те элементы, в которых хоть что-то будет изменяться
это там вот этот, вот этот, вот этот, вот этот и вот этот. Ну, какое-то маленькое подмножество,
если запросов мало, то и активных элементов тоже мало. Вот. Тогда давайте просто все перенумеруем,
скажем, что это элемент нулевой, это первый, это второй, это третий, это четвертый. Ну, слева
направо их занумеруем сплошными целыми числами. Вот. И дальше уже вот на этих пяти элементах
построим обычное деревоотресков, и потом будем отвечать на все запросы используя маленькое такое
удобное деревоотресков. Вот. Такая идея. Значит, это можно спокойно реализовать. Ну, давайте я сделаю
что-нибудь, например, такое. Давайте я заведу массив, не знаю, какой-нибудь координаты. Да,
это список вот всех тех позиций, вот на запросы pos, на запросы обновления в точке, которые
характеризуются двумя числами pos и x. Давайте все pos я сохранил в какой-то вектор. Значит,
cord это список всех значений pos. Всех значений pos по запросам первого типа. Вот. Ну, то есть я
просто отчитываю все запросы, все эти pos добавляю в список координат, потом если что сортирую и
дубликаты удаляю. Если в какую-то точку несколько раз происходили запросы, то мне достаточно только
один раз сохранить, мне нужны ее дубликаты. Она будет по одному разу. Давайте скажем, что
удаляем, сортируем, в конце вот этот список сортируем, удаляем дубликаты. Сортируем,
удаляем дубликаты. Ну вот. Потом на этих координатах, их вот так вот номируем сплошными
числами 0, 1, 2, 3 и так далее. Строим на этих координатах уже новое дерево отрезков, маленькое,
обычное. И дальше как обрабатывать запросы. Но если приходит запрос update, то есть мы дальше опять,
мы все запросы считали, теперь разрушаемся в начало и начинаем на них отвечать. Если приходит
запрос update в точке, то мы сначала понимаем, вот скажем, пришел какой-то pos, нам надо a pos
увеличить на x. Давайте сначала с помощью, например, бинарного поиска поймем, какой номер у этой
позиции в списке всех координат. Вот не знаю, например, если мне сказали pos вот это вот, то я с
помощью бинпоиска всех вот этих точек, ну по этим, по всем этим точкам, знаю, что pos имеет номер 3 в
списке координат. То есть, например, если это там, ну давайте напишем 0, 1, 2, 3, 4, 5, 6, 7, 8. Вот.
Значит, это все координаты массива. Координаты используемых у меня будут, получается, вот там,
где стрелочки. 2, 4, 6, 9, 13. Вот. Если мне приходит обновление в девятой точке, то я с помощью бинпоиска
в списке координат нахожу, что девятка находится на третьем месте, значит знаю, что она соответствует
третьему элементу в дереве отрезков. И дальше просто запускаю обычный update в элементе 3. Не в
девятке, а в тройке, потому что я все перенумеровал. Я сжал, я сжал вот этот большой массив до массива
размера 5, и дальше в этом сжатом массиве уже делаю какие-то обновления. Ну окей. Вот. Это будет
уже за логарифом от длины вот этого списка сжатого. Ну давайте скажу вот logq. Если всего было q
запросов, то максимум q элементов в этом списке, ну и отвечаю я за логарифом, потому что сначала
один бинпоиск по вот этому списку, потом за логарифом я в дереве отрезков делаю ответный запрос.
Ну вот. А если приходит getSum какой-нибудь, например, давайте напишем. Какой-нибудь getSum 5, 10. Вот. То есть
вот на таком отрезке меня просят найти сумму. Ну понятно, тогда как бы меня не интересует все,
что слева, все, что справа, и вот эти элементы, которые пустые, их тоже можно отбросить, потому
что там и так нули. Значит мы можем найти первый элемент больше либо равной пятерке в нашем списке
координат. Это шестерка будет. И последний меньше либо равной десятки. Это будет девятка. И на отрезке
между шестеркой и девяткой, то есть на самом деле на отрезке со второго по третий элемент в новой
номерации, я делаю запрос на getSum. Потому что как бы все элементы от пятого до шестого мне не
интересны, потому что там не было запросов, они нулевые всегда. Все элементы с девятого по десятой
тоже пустые, ну как бы здесь не было запросов, там ноль. Я их могу смело отбросить, искать сумму
только вот на этом отрезке, но это отрезок между вторым и третьим элементом. Соответственно опять я
делаю два бинпоиска, сдвигаю границы вот это вот пять до шестерки, десять до девятки, определяю в
каких-то позициях находится 2 и 3, дальше getSum на отрезке 2 и 3 в маленьком дереве отрезков.
Нормально? Ну хорошо, да. Массив очень большой, его нет в памяти, но он нулями изначально заполнен.
Дальше те, к которым поступали какие-то запросы обновления, мы только на них храним DO. Так, ну вот
такие дела. То есть если внезапно у вас запрос известен заранее, то можно не писать вот такую
более тяжеловесную структуру, можно не заводить отдельный класс для вершинки, можно написать
обычные DO, которые мы делали в прошлый раз. Но это работает быстрее, потому что, ну по крайней
мере у вас логарифм от другой величины. У вас здесь был логарифм от n, где n это длина исходного
массива, а здесь логарифм q, где q количество запросов. Но если там q сильно меньше чем n, то это выгоднее.
Хорошо. Так, ладно. Теперь давайте поговорим про персистентность.
Дальше GetSum в обычном дереве отрезков запускаем. Да, мы нашли элементы, но мы знаем их номера в
списке координат. Ну окей, давайте другой пример. Вот не 5, 10. Давайте что-нибудь поинтереснее возьму.
Давайте 3, 12. Вот такой большой отрезок с этого по вот этот вот. Значит, я бинпоиском определяю
наименьшее число большей и равной тройки. Это вот это вот. И наибольший и не большее 12. Это вот это
вот. Ну то есть, грубо говоря, я вот на отрезке с 3 по 12 нашел первый активный элемент слева и
последний справа. Вот. Значит, я знаю, что вот они. Я знаю их номера в списке вот этом вот. Ну значит,
это 1, это 3. И дальше в обычном дереве отрезков запускаем GetSum на отрезке с 1 по 3 элементов.
Ну потому что это отрезок с 1 по 3 элементов в вот этом вот сжатом массиве. Когда я все вот эти
нули выкинул нафиг. Когда вот этого всего нет. У меня есть только 1, 2, 3 на этом отрезке. Я на
отрезке с 1 по 3 элемент суммирую. Потому что все остальные выкинул. Сжал. Дальше персистентные
структуры данных. Персистентные структуры. Значит, персистентность означает, что структура в
каком-то виде хранит информацию обо всех своих предыдущих версиях. Хранится информация обо
всех предыдущих версиях. То есть на примере дерева отрезков у нас там изначально какие-то
элементы. Потом постепенно происходит запрос изменения. И вот мне хочется иметь, если что,
иметь доступ ко всем предыдущим версиям. То есть если надо, я должен уметь откатываться
к какой-то прошлой и той версии. То есть у меня было изначальное ДО. Потом что-то изменилось один
раз, второй раз, третий раз и так далее. И вот если что, я хочу уметь откатываться к какой-то старой
версии. Не знаю, второй, например. Или не откатываться, а просто что-то про нее узнавать. Вот что было в
момент времени тогда-то-тогда-то. Как выглядел дерево. Вот. Ну, например, просто система контроля
версии какая-нибудь. Вам надо делать какие-то комиты, вам надо изменять какой-то код, вы многократно
делаете какие-то правки, у вас сохраняются все эти изменения. И вы, если надо, имейте доступ ко
всем вот этим вот предыдущим версиям. Вот то же самое. Так, ну давайте начнем, например, с массива.
Сейчас. Момент. Ну ладно. Ну представьте себе, был какой-то массив изначально. 0, 1 и так далее,
а не минус 1. Давайте следующие очень простые два типа запросов сделаем. Значит, во-первых,
это обновление, ну изменение какого-то элемента в момент времени t. Ну давайте скажем, или давайте
в этой версии вот так. Значит, у меня поступают v, pos и x. Мне нужно заменить post элемент на число
x, где v это новый номер версии. Новый номер версии. Ну то есть у меня все версии нумерованы вот это,
скажем, нулевая, потом первая, вторая, третья, четвертая и так далее, и вот эти v идут в порядке
возрастания. Все в новой, то есть я создаю новую версию массива, как бы копирую всю старую информацию
в новый массив, и в новом выполняю присваивание posто равно x. То есть v у меня каждый раз увеличивается
на единичку. Все новые и новые версии добавляются. Ну это правда, конечно. Я просто подчеркиваю,
что каждый раз создастся новый массив, и его номер это вот его версия номер v. Это можно
не передавать, можно локально, ну в смысле внутри программы хранить. Просто я хотел подчеркнуть,
что вот есть какой-то номер v у каждой версии. Так, сейчас, момент. Это чуть сложнее делать.
Давайте покажите в идее, что у меня, ну как бы, вот есть один массив, он постепенно как-то меняется.
Вот была первая версия, ну не знаю, что Вы соцзакомители, у Вас поменялся код на такой-то,
массив стал таким-то, потом такой-то массив, такой-то массив, и так далее. То есть он меняется
непрерывно версия к версии, и все, что Вы хотите, это иметь, узнавать какое было значение в старый
момент времени в какой-то позиции. Не знаю, там get v pos, это просто вывести значение апостова в этой
версии, вывести значение элемента apos в версии v. То есть скорее мы не хотим менять какие-то старые
версии, мы хотим, мы хотим просто к ним доступ иметь, и если что, да, то есть не знаю, я смотрю
какую-то старую версию своего кода, и если надо, его перекопирую в новый массив, то есть создаю новую
версию и в него перемещаю то, что было в старом массиве. Поэтому, как бы, старые версии я менять
не хочу, я буду менять только новые, создавать только новые, но имею доступ к старым. Вот так сделаем.
Еще раз. Ну, это вопрос про реализацию уже, как мы это будем делать. Давайте скажу, как мы это
будем делать. На самом деле, конкретно эту задачу можно решать следующим образом. Давайте просто для
каждого элемента хранить список всех его изменений, его истории изменений. Давайте для
любого поз храним историю его изменений. Ну, изначально мы знаем, что в нулевой версии каждый
элемент имел такое-то значение. Изначально нулевой элемент был такой-то, первый такой-то и так далее.
Вот. Что происходит, когда поступает запрос изменения? Ну, очень просто. Меняется один конкретный
элемент, и поэтому мы можем сказать, что для постового элемента в его истории появляется новая,
не знаю, новая веха. Он изначально был там какой-то, а потом как-то менялся, и вот на в этой итерации
его значение поменялось на х. То есть, скажем там, вот этот запрос обрабатывается так, что пост
элемент как-то себя вел до этого момента, а потом, в момент времени в, он стал равен х. Давайте я
просто такую пару добавлю, что в этой версии, версии номер в, значение стало равно х. Значение
стало равно х. Вот. И все. А у остальных элементов, понятно, история не поменялась, потому что они не
изменили своих значений. Их история остается такой же, как была, я их просто не меняю. То есть,
на самом деле, я просто буду для каждого элемента поз, для каждого индекса массива хранить список
пар, ну это массив пар, вектор пар, вектор пар, момент времени, в который произошло изменение,
и на какое значение поменялось, собственно, это число. Когда произошло изменение, и на какое
значение произошло изменение. Вот. И все. Поэтому, соответственно, это я буду обрабатывать просто за
единицу, pushback-ая соответствующий вектор правильную пару, потому что в такой-то версии значение
поменялось на х. А для ответа на такой запрос, я смотрю на список, соответствующий постому
элементу, и мне что нужно смотреть? Ну вот, пост и элемент имеет какую-то историю. На что изначально
в нулевой версии он был, скажем, равен х, потом, не знаю, в четвертой версии стал равен y, в десятой
стал равен z, в какой-нибудь шестнадцатой стал равен a. Так, a занято, b. Ну вот, короче, какая-то
история, что в какие-то моменты времени он менял свои значения. И меня, скажем, спрашивают,
а чему равно апостол в момент времени 8? Ну вот, какое было его значение в восьмом момент времени?
Да, давайте бинпоиском определим наибольшей и меньшей равной в. В нашем случае это будет вот
эта вот четверка. То есть у меня можно запустить бинпоиск по первым элементам пар и понять,
что на четвертой, как бы в четвертой версии значение было равно y, потом оно не менялось
вплоть до десятой итерации, и только на десятом шаге, в десятой версии его значение стало равно z.
Но поскольку восьмерка меньше, чем десять, то оно еще не успело поменяться с y на z,
поэтому ответ это просто y. То есть формально для каждого в, точнее для поступающего в,
мне нужно найти последний номер версии не больше, чем в. Потому что если в этой
версии он поменялся, то надо в включительно. Последний номер версии не больше, чем в,
и вывести вот второй элемент этой пары. То есть на таком-то шаге оно поменялось на данное
значение, и потом уже не успеет поменяться, до в этой версии дальше изменений не будет,
только когда-то в будущем они будут, но до этого момента еще нас не спрашивают. У нас v меньше,
чем следующий. Ау? Ну конечно, я просто для каждого пост храню вот такой вектор пар. Для каждого
поста я храню историю в виде вектора пар. Вот это вот, это вектор пар. Вектор, но вектор,
который pushback в конец умеет, то, что у нас было, добавлять новый элемент в конец. Когда приходит
такая штука, я просто в соответствии вектор pushback au, номер версии, новое значение, а когда приходит
запрос get, я делаю bin поиск в соответствующем векторе и понимаю, какое изменение предшествовало
в этой версии, соответственно, какое значение в этом элемент. Кажется, все. Значит, тогда эта штука
работает за единичку, давайте здесь напишем, вот эта единичка, потому что просто pushback,
ну амортизировано, потому что pushback работает на самом деле за амортизированную единицу. Давайте
так для красцы напишем, для точности вернее. Вот, ну а здесь просто логарифм. Причем логарифм от чего?
Ну, в каком-то смысле, да, давайте напишу логарифм q, где q это общее количество запросов,
вот так. Или скажем, ну то есть, не обязательно лог v, потому что если v маленькая, то у нас
bin поиск по большому массиву, не совсем лог v, скорее именно лог q, где q это общее количество
запросов. Потому что в худшем случае у меня история одного элемента может иметь длину q,
и я вот на массиве длины q делаю bin поиск. Поэтому лог q. Потому что здесь на самом деле pushback,
pushback вектор работает только за учетную единицу, а не за чистую, поэтому по этому звездочку. Да,
да, да, потому что там внутри какой-то массив, его в худшем случае надо в два раза расширять,
да, и поэтому это учетно только. Вот. Так, понятно с массивом? Знаю как хранить. Хорошо,
теперь давайте попробуем перстентный stack придумать. Перстентный stack. Честно говоря,
я не уверен, что получится, ну ладно, давайте попробуем. Мне просто пришло в голову, почему бы
нет. Справедливо, да.
Таким мы не будем заниматься, конечно. Сейчас, один момент. А, понятно, почему. Да. Какую хранить
информацию? Ну вообще, что умеет делать stack? Он умеет там типа push, pop и top узнавать, да, ну
и видимо надо добавить запрос типа top в этой версии. То есть это функционально как у обычного stack,
только еще с доступом к информации про предыдущей версии. Вся информация, только только top у меня
может быть. Да. Справедливо, можно здесь вместо q написать количество запроса типа get. Да, это
правда, но q это оценка сверху, поэтому лог q общая, можно написать точнее, что q, qget можно так написать.
Вы правы, да. Будет лучше оценка, но как бы зависит от задачи, мы как бы априори не можем сказать,
сколько будет таких запросов, сколько таких, возможно их примерно поровну, и эта оценка нам
не улучшит ничего особенного. Если у вас q в два раза уменьшится, то то же самое будет.
В каком смысле, да, только даже можно без поисков. Смотрите, что можно сделать, можно на самом деле
просто каждый раз не stack топов, а скорее список топов, ну вектор топов будем хранить. Да, то есть
смотрите, вот если я stack храню в виде списка, как обычно, например, у меня stack в таком виде хранится,
вот здесь вот дно, вот здесь вот топ, куда элементы добавляются, откуда они удаляются и считываются.
Значит, можно что сделать? Давайте мы просто будем хранить список всех вот этих вот верхних
элементов. Тогда как обрабатывать новый запрос? Если у меня топ удаляется, то есть происходит
операция pop, тогда у меня новым топом становится вот это, я его добавляю в вектор топов. Давайте храним
список топов. Что происходит, если происходит запрос pop? У меня верхний элемент удаляется,
новым топом становится его сын, и вот его, то есть это удаляется, топом становится этот товарищ,
мне нужно его добавить в список. Надо добавить новый топ в список. То же самое значит с запросом
на самом деле push. Если какой-то новый элемент добавляется в качестве нового топа, то его надо
добавить в список топов. То же самое. Теперь как отвечать на запрос get топ в какой-то версии? У
нас есть список всех всех версий, они занумерованы числами 1, 2, 3 и так далее, и мне нужно просто
как бы посмотреть на значение в этого элемента. У меня как раз они все хранятся, у меня все топы
хранятся у всех версий стеков, которые были за все время работы программы, у меня хранятся
указательно все вот эти вот топы во все времена, во все моменты истории. Я знаю в каждом момент
времени, чему равно значение в топе. Когда приходит запрос там, не знаю, get топ в момент времени v,
я просто смотрю на этот список, смотрю в нем в этот элемент, и это будет ответ. Кажется даже так.
Похоже? Да, ну наверное можно было бы и на массиве это сделать. Тогда мы даже больше умеем,
получается тогда мы для каждого элемента знаем, то есть как бы если для каждой позиции опять-таки
завести список всю историю его изменений, что там нулевой элемент 1, 2, 3 и так далее, историю
изменений этого элемента, когда он отсутствует, когда он присутствует с таким-то значением,
когда с другим, и там можно было бы тоже пускать bin поиск, но был бы лишний логарифм, потому что
здесь мы умеем за единицу отвечать на запросы, просто потому что у нас все топы хранятся в одном
массиве в каком-то, и чтобы найти в эту версию, надо просто посмотреть на wet элемент этого списка,
этого массива. Нет, потому что если у нас какой-то элемент был топом там в какой-то
в этой итерации, у вас есть для этого элемента его история всех изменений, когда он был какой,
когда его не было, когда он был x, когда он был y и так далее, его надо в этом длинном списке найти
его положение в этот момент времени, это bin поиск. Вот, а здесь вроде будет чисто единичка, то есть
если хранить, ну грубо говоря, хранить указатели на топы во все моменты времени, тогда мы можем
быстренько на все отвечать. Так, нормально? Вот, хорошо, ну и теперь давайте что-то содержательное,
персидентное дерево отрезков посмотрим. Вот, значит, ну мы хотим делать, давайте так, опять же,
у меня будут запросы обновления, да, update в точке, и с каждым update у меня обновляется номер версии,
типа вот у меня была какая-то нулевая версия дерево отрезков, потом пришел первый update,
стала первая версия дерево отрезков, пришел еще один update, стал вторая, еще и так далее и так далее. То
есть версии у меня меняются с апдейтами, а get some, давайте позволим себе, ну давайте научимся
отвечать на get some к любой старой версии. То есть у меня update так и остается, да, update в точке,
после запятая x, значит в это время создается новая версия, да, создается новая версия,
так же как в массиве, да, у меня при изменении создается новая версия. Вот, а get some пусть научится
обрабатывать любые старые версии, то есть get some и передается не только l и r, но и номер версии v,
вот. Ну найти сумму в этой версии, найти сумму элемент в этом отрезке в этой версии DO.
А в чем у вас отложенная операция заключается?
Это может, непонятно как это делать, на самом деле. Мне кажется, что нет, потому что, да, ну список
изменений в подделье, да, как бы. Или так, да.
Да, хорошо, но это будет тогда лог квадрат, да, в худшем случае?
Ну да, то есть естественно у меня будет логарифом вершин в DO, которые я рассматриваю в каждой,
я еще запускаю один поиск, это лог квадрат. Вот, причем это, наверное, не оптимизится,
потому что у меня неизвестны заранее запросы, и там трюк, как во Fractional Cascading не пройдет,
чтобы до логарифма это уменьшить. Наверное, будет лог квадрат. Но в целом, да, то есть можно применить
то же самое. Можно в каждой вершине хранить историю изменения, изменения суммы в ней,
и делать те же самые бинарные поиски в каждой вершине. Но это лог квадрат, давайте так не будем.
Давайте мы сделаем что-то поэффективнее с точки зрения времени. А именно, ну давайте мы просто
будем, когда что-то в вершине изменяется, давайте мы вместо изменения значений в вершине,
давайте создадим новую вершину просто. И в ней сохраним всю информацию, которая должна быть.
Вот, например, было какое-то изначальное дерево отрезков. Правильная DO, нулевая версия DO.
Дальше мне приходит запрос апдейта, и мне нужно, скажем, вот на таком-то пути конкретном каком-то,
во все элементы поставить сумму плюс х. То есть апдейт в этой точке прошел на х,
у меня все вот эти вот суммы на этом пути увеличиваются на х. Тогда что я сделаю?
Давайте я просто возьму, продублирую этот путь, создам новые вершины, вот ровно такой же структуры,
отвечающие этому пути. В этом DO я ничего менять не буду, я поменяю только на новом пути,
во все эти вершинки поставлю плюс х. То есть я только в новых вершинах увеличу значение суммы на х.
Вот, и дальше смотрите, у меня был изначальный корень, давайте его назову root 0, изначальный
корень моего деревоотресков. И теперь появляется новый root 1, новый корень деревоотресков вот с уже
этим обновлением, с изменения на этом пути. Причем, смотрите, по большей части эти два дерева должны
совпадать, потому что они отличаются только поведением на этом пути. А все остальные вершины,
ну как бы было бы очень неразумно просто все остальное копировать сюда. Я не хочу создавать
новое DO линейного размера, и все остальные вершины просто тупо копировать. Вместо этого давайте я буду
просто ссылаться, что теперь у меня корень, ну скажем вот, если у меня здесь левый сын менялся,
то есть если у меня в левом сыне произошло плюс х, то правый у меня остался на месте, остался таким же как
был, там значение осталось. Так вот, давайте тогда скажем, что в качестве правого сына вот этого корня
выступает правый сын старого корня. То есть у меня вот такой указатель будет вести вот сюда вот.
Просто потому что нет смысла все вот это под дерево сюда перекопировать. Я могу явно сказать,
что, окей, правое под дерево вот этой штуки такое же, как было вот здесь. То есть по факту просто в
качестве правого сына будет выступать правый сын старого корня. И в каком-то смысле я сделал вот
то самое перекопирование, ничего не заводя новой память. Я просто сказал, что теперь правым сыном
выступает вот этот вот. Ну и там дальше, если мне нужно будет пойти как-то в правого сына, то он как
раз переместится сюда и будет вести себя здесь так же как надо. То есть я не копирую, я сделал то,
что надо. Да, добился такого же поведения. Ну вот так и будем делать. То есть когда происходит
апдейт, я завожу новый корень. То есть я опять буду хранить список корней всех версий DO. Я завожу
новый корень. Вдоль того пути, на котором происходят изменения, создаю новые вершины. То есть вместо
этих вершин создаю новые. В них делаю апдейт. В них во всех суммы изменяется, делаю в них во всех
плюс х. Вот, а все остальные вершины этого дерева соответствуют вершинам вот этого дерева. То есть
какие они здесь были, такие они здесь и остаются. Например, вот здесь у этой вершинки левый сын оставался
на месте, значит здесь левый сын должен идти на самом деле вот сюда вот. Ну и так далее. Все, короче,
вот во всех моментах, когда у меня есть неиспользованный сын, который непонятно какой,
я его просто назначаю таким же, как он был в левом дереве, в предыдущем дереве. То есть в момент,
когда у вершины скажем вот здесь вот, один сын изменяется на плюс х, а другой надо оставить
такой же, как был, давайте просто перенаправлю его на соответствующего сына в предыдущем дереве.
Вот и все. То есть у меня опять же будет храниться некая структурка нот, которая хранит указатели на
левое правое сына, значит left sun, right sun. Ну и соответственно каждый сын это либо новая вершина,
которая отличается от старой добавлением х, либо это указатель на того же самого старого
правого сына. Вот здесь вот right sun такой же, как здесь right sun. Еще раз? Код писать в смысле?
Не-не-не, у меня нет. Будем прописывать. Right sun у меня все всегда определены. Мы считаем,
что здесь массив маленький. У меня как обычное DO, то есть не динамическое. Обычное DO, все у меня
вершины определены, у меня нет никаких неопределенностей. И просто в момент,
вот когда у вершины скажем, вот я завел новый корень, я понимаю, что изменение поз лежит в
левом поддереве. Тогда я просто правого сына копирую отсюда, ну не копирую, а перенаправляю
указатель на правого сына вот здесь вот, а в левого рекурсивно запускаюсь и запускаю апдейт от него.
То есть я перенаправил этот указатель, ну то есть я его явно прописываю, да, вместо того, чтобы
показывать на какую-то новую вершину, он бы показывать туда же, куда показывал раньше,
а в левом поддереве я запускаю изменение рекурсивно и делаю там плюс х на пути. Вот, значит,
ну тогда соответственно апдейт у меня работает за лог времени, потому что я точно так же просто
иду вдоль какого-то пути DO, но опять-таки за плюс логарифм до памяти, потому что мне придется
вот, ну как бы я этот путь перекопирую и создаю новую вершину в количестве таком же, как было
здесь, поэтому я добавляю еще от логен до памяти. Вот. Ну а потом, чтобы отвечать на GetSum,
ничего девать не нужно, потому что у меня, смотрите, у меня есть версии. Для каждой версии v у меня есть
соответствующая версия корня, то есть у меня есть root 0 для нулевой версии DO, root1 для первой
версии, для второй, для третьей и так далее. В каждой версии у меня есть свой корень. Все, что я
вижу стоя в соответствующем корне, это его поддерево, то есть здесь, скажем, левый сын, это
вот это вот, правый сын, это то же самое, что было в прошлый. То есть вообще говоря, всё его поддерево
корректно определено. Поэтому, когда у меня приходит запрос getSum в lr, я просто встаю в
этой корень и запускаю там обычный getSum lr. Потому что у меня корректное DO, у меня корректно
определены все левые правые сыновья, и мне нужно в этом дереве отрезков, в этом дереве отрезков,
найти сумму на отрезке с lpr. Но это, я вам и даю, это обычный запрос к DO. Да.
А если у нас достаточно большое количество таких версий, и мы раз за разом ссылаемся в каком-то элементе?
Это не страшно. Это не страшно, потому что на самом деле, что только ссылаемся. Ну, давайте картинку еще раз нарисуем.
Мы ничего ничто? Да, не расходуем. Потому что, вот смотрите, вот было одно DO, было другое. Скажем,
пусть изменения происходят только в левом поддереве. Было третье, вот было четвертое. И,
например, всегда правый сын у меня один и то же. Правое поддереве у меня, например, не менялось.
Тогда как это на самом деле реализовано? Это реализовано так, что просто у меня указатель отсюда
на правого сына ведет вот сюда. И, значит, когда я иду отсюда направо, я сразу попадаю сюда.
Здесь правый сын у меня, допустим, не изменяется, он указывает вот сюда вот, но что такое это? Это,
просто вот это. Они у меня равны. Когда я перехожу в правого сына, это указатель. На самом деле здесь
его нет, потому что указатель ведет сразу вот сюда. Дальше я что делаю? Я указываю,
что правый сын нового дерева — это то что было правым сыном предыдущего, а правый сын предыдущего
вот он. Поэтому я указываю не сюда а сразу вот туда. Вот здесь, тоже самое. Что такое правый сын
предыдущего по дереву. Это вот то вот. Поэтому я вот так вот сразу делаю указатель, и у меня как бы
переход за единицу именно что? Потому что у меня в правильное дерево оно переходит, и там все это
по дереву автоматически рассматривается. Вот. Кажется, все. Так, окей. Давайте с помощью такой
штуки вернемся чуть назад, и по-другому решим задачу, которая была про fractional cascading.
Напомню задачу. У нас был массив, и мне нужно было находить количество чисел не больше, чем x,
на отрезке с L по R. На отрезке с A L по A R. Вот. Значит, это было в конце прошлой лекции. Мы там
построили дерево мерч сорта, то есть склеивали, сортировали векторы, объединяли их с помощью мерч
в один отсортированный, и там как-то хитрым бинпоиском, храня как-то стрелочек, как-то это
за логарифом отвечали. Теперь давайте применим персидентное дерево отрезка, решим ту же задачу,
ну чуть-чуть меньше подумав, скажем так. Писать, наверное, здесь побольше, потому что вот с этими
указателями надо возиться, но думать меньше. Так. Ну давайте я сделаю следующее. Давайте,
значит, шаг нулевой, я все элементы убью. Что бьем? Все элементы. Дальше я пойду по массиву в порядке
возрастания элементов. Сначала найду, где лежит минимум, потом где лежит вторая порядковая статистика,
третья, четвертая и так далее, и буду один за другим постепенно оживлять элементы. То есть я
сначала оживлю минимальные, потом второй по минимальности, третий и так далее. Дальше, значит,
оживляем элементы по одному в порядке возрастания. То есть, например, если был массив, скажем, 5, 1, 3, 4, 2,
то я сначала оживлю единичку, то есть изначально все мертвые, потом единичка живая, потом двойка,
вместе с единицей живая, тройка, ну и так далее. Короче, изначально все мертвые, потом иду не слева
направо, а в порядке увеличения. Сначала один оживает, потом два, потом три, четыре, пять. Вот. И давайте,
значит, я заведу дерево отрезков и в каждой вершине буду хранить количество живых под деревья. В вершине
ДО храним количество живых элементов под деревья. То есть изначально все нули, и дальше они постепенно
превращаются в единички. Один ожил, сделал плюс один на пути, второй ожил плюс один на пути и так далее. Вот.
Нет, нам обычного хватит, потому что длины Н всего лишь, и у меня все элементы оживут, поэтому динамическая
бессмысленно. Потому что они все равно все оживают, мы ничего не выигрываем за счет динамичности. Вот.
Ну и все. И мы сделаем это с помощью персидентного ДО. Значит, это будет персидентное ДО, мы будем помнить
все версии. Вот. А дальше очень просто. Приходит запрос, сколько чисел не больше, чем х. Давайте мы
с помощью бинпоиска поймем, что за версия в качестве живых элементов содержит только те самые числа,
не больше чем х. То есть у меня изначально все мертвы, потом они постепенно оживают один за другим. И вот в
какой-то момент, давайте найдем тут момент времени, когда живые это в точности те, которые не больше
чем х. Вот есть х. У меня ДО оживает, в ДО элементы оживают один за другим в порядке возрастания. В какой-то
момент живые это в точности те, которые не больше чем х. Смотрим в эту версию ДО и изучим суммы на
отрезке. Потому что там единички это живые, то есть те, которые не больше чем х, нолики это мертвые те,
которые больше чем х. Сумма на отрезке есть количество живых на отрезке, то есть количество тех самых
чисел, которые мне надо. То есть. Значит, теперь ответ на запрос. Находим версию,
в которой все элементы не больше, чем x живы, в которой живы все не больше, чем x, ну дальше просто
get some на треске LR. Get some на треске LR. Все. Ну, бинарным поиском, например. Представьте,
что вот у нас есть массив чисел. Что мне, значит, как я делаю вот этот первый шаг? Как я по всем
элементам иду в порядке возрастания? Ну, нужно, наверное, этот массив отсердствовать и запомнить,
где какой элемент лежал. То есть я все равно знаю, где минимум, где вторая статистика, где третья,
и так далее. То есть я этот массив посортировал и знаю, в каком месте каждый элемент лежит
относительно исхода нумерации. Дальше, когда приходит x, я просто запускаю бинпоиск по вот
этому отсоршенному массиву и понимаю, в каком месте, в какой версии все элементы не больше,
чем x живы, а те, которые больше, еще мертвы, а мы их еще не оживили. Ну и, собственно, вот эта
версия, мы знаем ее номер, мы знаем номер позиции такой, что вот в этой позиции все не больше,
чем x живые. Мы знаем этот номер, мы в этой версии DO делаем запрос. Давайте посчитаем, на самом
деле, не очень много. Да. Не, на самом деле, просто n log n и будет. Значит, я утверждаю,
что предподсчет у меня работает за n log n, потому что у меня, на самом деле, просто n запросов к
DO. Вот таких вот запросов обновлений у меня n, так как всего n апдейтов. Да, у меня изначально все
мертвы, потом я n элементов оживляю. Каждый запрос обрабатывается за логарифом, ну при этом,
да, еще логарифом n памяти добавляет, потому что я изменяю путь, у меня плюс log n памяти,
поэтому здесь n log n времени и n log n памяти. Временней памяти. Ну все, а потом на запрос я за
log n просто отвечаю, потому что я сначала бин поиском нахожу x в массиве отсортированном и потом
делаю еще за логарифом get some в соответствующей версии DO. Поэтому на запрос я отвечаю за логарифом.
На запрос логарифом. Вот, вроде не очень много, не очень страшно. Да. Ну два log n получилось как раз.
А у меня версия-то n. А у меня версия столько, сколько элементов в массиве, их n. За log n бин поиск и
потом еще log n в DO. Все правильно. Вот, понятно? То есть, смотрите, мы как бы в задаче, которое явным
образом не апеллирует к версиям, да, как бы нам, ну тут не написано храните версии какие-то, да, вот
как здесь. Явным образом это написано. Вот, но мы как бы, если что, можем какие-то задачи, используя
персистентное, используя как бы знания о всех предыдущих версиях, можем какие-то другие задачи
решать. Вот так тоже бывает. Так, хорошо. Хорошо. Ну давайте такую еще вариацию посмотрим. Давайте
посмотрим на двумерное дерево отрезков. Задача аналогична одномерной, когда у нас есть массив,
только теперь у нас есть табличка. Скажем, у нас есть квадратная табличка чисел n на n.
Вот здесь стоят какие-то числа. Табличка n на n. Она изначально заполнена числами, скажем там,
а и та житая, и поступает также два запроса. Update в точке, то есть надо поменять конкретно а и та житая
на что-нибудь. И второе, но если раньше была сумма на подотреске, то теперь естественно сделать
сумму на подматрице, на подпрямоугольнике. Ну то есть скажем, найдите, пожалуйста, сумму вот в
таком вот прямоугольнике. Ну просто об общении на двумерный случай, скажем так. Ну не обязательно,
в общем случае может любой прямоугольник быть. Ну давайте что, вот что-то такое может быть. Любой
прямоугольник. Вот, то есть у меня есть update в точке, update в точке и get sum на прямоугольнике,
скажем так. Get sum на прямоугольнике. Вот. Да, да, да. Прямоугольник задан координатами там своих
концов. Лево, верхне, право, нижне надо найти на нем сумму, да. Вот, ну смотрите, поскольку у меня
здесь вход уже имеет размер n на n, то есть у меня есть такая квадратная табличка, я считаю,
что они все какие-то изначально имеют какие-то значения, то есть в них во всех что-то изначально
записано. Ну поэтому как бы у меня уже будет квадрат в симптотике, хочешь не хочешь. У меня там
есть матрица квадратного размера, поэтому мы сейчас будем работать за что-то типа n в квадрате,
умноженными кинтлагарифмами. Вот. Ну идея на самом деле очень прозрачная. Мы сделаем дерево отрезков
по одной координате, скажем. Давайте я введу какую-нибудь здесь нумерацию. Например, вот так вот.
Скажем x, это скажем y. А нет, не хочу. Давайте обычные ивклидово введу. Вот здесь вот x,
вот здесь вот y. Вот. Смотрите, по x-ам у меня есть нумерация столбцов 0, 1, 2 и так далее, n-1.
Давайте я вот на этих столбцах построю дерево отрезков. Что это значит? Как бы в обычной версии
DO, в одномерной, у меня вершина отвечает под отрезку чисел. Теперь, если я строю дерево отрезков на
x-ах, то у меня вершина будет соответствовать под отрезку столбцов. Не под отрезку чисел, а под
отрезку столбцов. Ну вот, например, давайте что-нибудь простое нарисуем. У меня есть 4 столбца. Вот такая
матрица 4 на 4, еще разбитая вот такими горизонтальными тоже линиями. Значит, у меня будет DO,
который выглядит как-то вот так вот. Вот. То есть у меня одна вершина отвечает этому столбцу,
одна вот этому, одна вот этому, одна вот этому. Дальше вершина отвечает вот этим двум столцам
одновременно. Это вот этим двум столцам, а это всем четырем столцам одновременно. Ну то есть,
как одномерно, только на столбцах, скажем так. Каждая вершина теперь отвечает отрезку столбцов,
там с какого-то по какой-то. А дальше давайте мы в каждой вершине вот этого DO, внешнего по x-ам,
что такое вершина DO? Это какой-то отрезок столбцов. Давайте теперь здесь внутри
сделаем внутреннее DO по y-кам. То есть вот у меня вершина DO, давайте я здесь нарисую какая-то вершина,
она отвечает некоторому под отрезку столбцов. Давайте теперь вот на этом отрезке столбцов
построим дерево по y-ку. То есть у меня будет дерево, которое контролирует его вот здесь,
вот сбоку. Давайте опять какой-нибудь пример. Пусть будет здесь четыре элемента. Нет, давайте пять,
раз, два. Вот так. Будут отдельные вершинки, отвечающие вот таким вот строчкам размера 3.
Потом как-то они так вот склеются, например. Вот так вот склеются, например. И вот так вот склеются,
например. Вот. То есть теперь внутри каждой вершины по x-у я храню вложенное такое дерево отрезков на вот
таком вот соответствующем этой вершине отрезку, вот на таком отрезке столбцов. И дальше я опять этот,
как бы рассматриваю это все как некая неделимая, неделимую табличку по x-ам и делю по y-кам. Вот
внутреннее DO в этой точке v будет делить по y-кам. Соответственно, каждая вершина здесь отвечает
некоторому подотреску y-ков. Ну а x у меня фиксирован, да, x от такого-то до такого. Вот. То есть как бы
именно что двумерное дерево отрезков. В каждой вершине DO по x-ам у меня будет храниться DO по
y-кам. То есть я вот некий подотрезок фиксировал, некий подотрезок с x-ин до x-max я вырезал из таблицы,
дальше как бы склеил это все в неделимую штуку по x-ам и дальше режу по y-кам с помощью вот такого
DO горизонтального. Вот. И давайте теперь в каждой вершине вот этого вложенного DO хранить сумму
соответствующего под прямоугольника. То есть здесь будет храниться сумма вот такая, здесь сумма вот
такая, ну и так далее. То есть в каждой вершине внутреннего DO я храню сумму вот с того под
матрицей таблицы, которая ею контролируется. Вот я утверждаю, что такого хватит. Ну почему,
давайте разберемся, как делать апдейт в точке. Что такое апдейт в точке? Вот у меня была какая-то
матрица. Какая-то матрица. Где-то в какой-то точке надо сделать плюс x. Давайте плюс z,
потому что x, y у меня координаты. Я делаю плюс x в точке. Что меняется? Какие вот эти вот вершины,
в каких вершинах происходит изменение? В каких вершинах сумма увеличивается на z? Ну те, которые
и по x-у контролируют вот эту точку. То есть мне нужны такие вершины, которые отвечают отрезку
столбцов, содержащему этот столбец. Вот этот вот. Давайте там. Какой-то иный столбец. То есть мне
нужны все такие вершины. Но мы знаем, что если у меня по x-ам построено дерево отрезков, то все
такие вершины, содержащие конкретный итый столбец, это путь просто от этой точки до корня.
Ну или, например, от корня до итого столбца. Мы знаем, что изменение в дереве отрезков по x-у
происходит только в этом логарифме вершин. От корня до итого столбца. Вот на таком пути.
Вот здесь вот во всех точках надо сделать плюс z в соответствующей координате. Хорошо. То есть у меня
есть логарифмическое количество вершин внешнего DO, которые по x-ам построены. Каждая вершина
внешнего DO это на самом деле DO по y. Вот такое вот. И где-то здесь происходит плюс z. Вот в какой-то
там точке делается плюс z. Значит мне нужно теперь в этом внутреннем DO всем вершинам, которые
содержат эту строчку, сделать плюс z. Ну потому что этот плюс z и так лежит в этой таблице. Мне
нужно во все вершины, контролирующие эту строчку, сделать плюс z. Это вот это, вот это, вот это,
вот это. То есть опять некий путь от корня до житой строки в этот раз. От корня соответствующего вот
это вот дерева до житой строки. Да, да, да. Все правильно. Вот давайте я какие-то слова напишу,
потому что я много говорил. Что-нибудь давайте зафиксируем. Да, да, да, да, все правильно.
Ну давайте пару слов я все-таки зафиксирую. Значит внешнее дерево отрезков по x. Внешнее дерево
отрезков по x. Каждая вершина внешнего DO соответствует внутреннему DO по y. Вот.
Когда происходит апдейт в точке? Апдейт в точке и жи. Апдейт в точке и жи. Ну давайте так в два
этапа и напишу, что сначала я определяю все вершины внешнего DO, которые контролирует
и ты столбец. Определяем все вершины внешнего DO, контролирующие и ты столбец. И потом для
каждой из них переходим в соответствующее внутреннее дерево отрезков, которое свое для
каждой вершины внешнего. И дальше вот в этом внутреннем, в каждом внутреннем делаем, ну обновляем
ответ для всех вершин, контролирующих и житую строчку. Для каждого из них, для каждой из них
в соответствующем DO обновляем ответ для всех вершин, контролирующих и житую строчку.
Вот. Ну из такого описания, кажется, видно, что это работает за лог квадрат, потому что я
сначала выделяю логарифмическое количество вершин во внешнем DO, здесь будет лог вершин. И
дальше для каждой из них, во внутреннем, это еще логарифм. Ну потому что, потому что это путь
от корня до листа. Значит, суммарно это работает за лог квадрат. На запрос типа update. Вот. Согласны?
Супер. Удивительно. Ну ладно. Ну а с get some ничего хитрого нет. Значит, мы знаем, давайте get some.
Ну во-первых, а это неважно, неважно. Но что здесь большая табличка? Мне нужно найти сумму вот на
таком, скажем, прямоугольнике. Давайте я сначала порежу этот прямоугольник на координаты по x,
ну на как бы на подотреске по x. Вот у меня есть координата x. Я знаю, что если я смотрю,
если я рассмотрю вот это набор столбцов, вот с этого по этот. Рассмотрю такой набор столбцов,
то он покрывается логарифмическим количеством вершин в дереве отрезков. То есть там выделяется
какое-то логарифмическое количество во внешнем DO. Такие, что, скажем, это контролирует целиком
этот столбец, а этот целиком вот эти два. То есть первое, что я делаю, то я разделяю диапазон по
налогарифмическое количество вершин во внешнем DO.
А дальше я понимаю, что каждый из этих вершин
соответствует внутреннему DO,
и мне теперь нужно в каждом из них
вычленить сумму на отрезки
с такого-то y под такое-то.
То есть я сначала покрыл
небольшим числом вершин
отрезок по x, и дальше в каждое из них
запускаю то же самое по y.
То есть я вычлениваю какой-то вот, скажем,
вот такой подотрезок по x,
и дальше мне нужно внутри сделать сумму
с такого-то элемента под такое-то.
А это гетсам во внутреннем DO.
Тоже лог квадрат поэтому.
То есть еще раз, я сначала разделяю диапазон по x
на вершины внешнего DO,
потом в каждом из них
запускаю гетсам просто на отрезки по y.
С y минимально, а по y максимально.
Понятно?
Супер.
Это тоже лог квадрат получается.
Потому что опять, я сначала внешне
покрыл логарифмическим числом вершин,
а мы знаем, что любой отрезок
покрывается жадным образом логарифмическим числом вершин
во внешнем DO, и в каждом из них
еще один гетсам, это еще лог квадрат.
Ну, как бы, еще логарифм, всего лог квадрат получился.
А их можно не искать,
можно просто явным образом
завести дерево отрезков на x.
Вот как я здесь рисовал,
вот таким образом такой DO храним.
А у меня каждая вершина отвечает
некоторому диапазону x, диапазону столбцов.
Дальше, каждый из этих вершин
либо ссылается
на внутреннее DO,
то есть имеет некий номер v,
и мы для номера v создаем в это дерево отрезков
внутреннее, либо просто эта вершина
и есть DO, то есть
вместо вершины можно хранить коробочку,
которая является деревом отрезков внутреннем
просто, и дальше внутри этой коробочки
что-то делать.
Ну, вот так вот как-то.
Так, нормально?
Ну, и соответственно можно,
если очень хочется,
можно сделать
то же самое трехмерное,
четырехмерное, ну и так далее.
Ну, и камерное, да, тоже можно.
Н-мерное можно, но это
N в N уже будет какая-то,
что-то не очень приятное.
Вот, хорошо.
Так.
Ну, и давай тогда последний сюжет,
рядышком с этим, связанный.
Так, где мой мил?
Где мой мил?
Так, давайте еще такую задачу посмотрим.
Похожая вот на то,
что мы сейчас сделали,
чуть-чуть еще это обобщим.
Значит, смотрите, представьте, друбо говоря,
смесь динамического и вот этого двумерного.
Представьте, что у вас таблица большая была,
не как раньше N на N,
и вы могли N квадрат в памяти хранить.
Она прям большая, ну скажем,
не знаю, 10-9, 10-9.
Это плоскость,
координатная плоскость.
И здесь есть мало точек.
Здесь есть мало точек,
с которыми происходят какие-то изменения.
То есть изначально у вас даны координаты
всех этих точек,
изначально в них лежат какие-то значения,
и вам надо делать два типа запросов.
Как обычно, изменить в точке,
вот, только update не в произвольной точке,
а вот в одной из тех N, которые,
ну или там давайте их,
ну да, пусть их будет N,
в одной из тех N точек,
которые изначально нарисованы.
То есть есть большая плоскость,
и в ней всего N точек.
Update в одной из них,
либо сумма в прямоугольнике.
То есть единственное отличие,
что у вас, грубо говоря, табличка большая,
вам нельзя ее полностью хранить в памяти,
но в ней мало точек.
В ней мало точек,
в которых будет просветить изменения.
Их всего N.
Вот.
На что здесь можно сделать?
Ну, на самом деле...
Смотрите, поскольку точки нам известны заранее,
давайте мы запустим
сперва сжатие координат.
Сжатие координат.
Мы можем все эти координаты,
мы можем все эти точки считать,
можем посортировать их по X, по Y,
ну и соответственно, вместо того,
чтобы иметь координаты порядка 10 в 9,
у нас будут координаты порядка N,
и на этом уже можно будет построить дерево отрезков.
Первое, что я сделаю,
это я сожму координаты по X только пока что.
Сожмем.
Координаты.
По X.
Вот.
То есть все X-координаты свалю в один вектор,
посортирую, удалю дубликаты.
Теперь для каждой точки я знаю,
какой ее номер в этом списке отсортированных X.
Какой у нее X в списке.
Вот.
Дальше давайте построим внешнее DO.
Значит, строим внешнее DO по X.
Внешнее DO
по X.
Поскольку я это сжал,
у меня табличка стала примерно такой,
то есть у нее маленькое количество столбцов.
И здесь, на этой вот X-координате,
я могу построить обычный дерево отрезков.
Какая-то такая штука у меня будет.
Что-то такое.
Значит, теперь опять каждая вершина
дерево отрезков отвечает
какому-то под набору столбцов,
под отрезку столбцов, точнее.
Каждая вершина отвечает вот такому отрезку столбцов.
Теперь давайте мы
для каждой вершины внешнего DO.
Смотрите, у меня здесь на самом деле
в среднем точек не очень много.
У меня всего суммарно в этой таблице N точек.
И если я высеку только такой
маленький диапазон X-ов,
такой подотрезочек,
скорее всего здесь точек будет еще сильно меньше.
Если всего их N, а я выделяю такой подотрезок,
то здесь точек меньше,
чем во всей таблице.
Так вот, давайте мы построим дерево отрезков
не на всем вот этом вот
диапазоне Y-ов,
а только на тех Y-ах, которые есть в этом столбце.
То есть, грубо говоря,
смотрите, я для этой точки, для этой вершины
знаю, какие точки попали
в эту полосочку, в этот диапазон столбцов.
Я теперь
сортирую их по Y-кам,
и только на этих сжатых Y-ках
построю внутреннее DO.
То есть у меня внутреннее DO в этой точке
устроено не по всей таблице,
а только по вот этой вот полосочке.
И, соответственно, там будет точек
меньше, чем
во всей таблице.
Значит,
каждая вершина В,
каждая вершина
внешнего DO
соответствует
вертикальной полоске,
значит,
запоминаем, давайте запомним
все точки,
попадающие в эту полоску.
Запомним
все точки,
попадающие в эту полоску.
У них
сожмем координаты по Y-кам
и построим внутреннее DO по Y-кам.
У них сожмем
Y-координаты
и построим
внутреннее DO по Y-кам.
Построим внутреннее DO по Y.
Ну а дальше уже отвечаем так же, как и раньше.
То есть единственное отличие по сравнению с задачей на
таблице N на N, это то, что я вот это внутреннее DO
строю не на всех точках всей таблицы, которая есть,
а только на те, которые попали внутри вот этой узенькой
полосочки, которая высекается конкретно вершиной внешнего
DO.
Вот в этой полоске я считаю все точки, сортирую их по
Y, они приобретают новый порядок внутри этой полоски,
и я вот на этих точках строю DO, вот такой внешне горизонтальный.
Ну тогда я утверждаю, что вот это вот все, весь этот
предпочет можно устроить за N лог N, кажется, ну давайте
посчитаем.
Вот я утверждаю, что это можно сделать за N лог N.
Почему?
На самом деле потому что, вот давайте посчитаем
вообще просто, сколько раз каждая конкретная точка
куда-то входит.
Да, она входит в логарифмическое количество таких полосочек
вертикальных, потому что это значит, что она должна
попасть в какой-то из Ella's.
보이, она должна контролируется вершиной их логарифмическое
количество, значит получается, что каждая точка I, будет
находиться всего в логарифмическом количестве внутрен original
DO.
Потому, что внутреннее соответствует вершинам внешнего.
Значит, каждая точка будет в соответствующем списке
всего лишь в логарифм раз, поэтому память N лог N.
Оно каждая точка всего в логарифмическом количестве
вершин DO хранится, значит памяти всего N лог N.
И более того, можно это построить тоже за n log n.
Ну почему? Потому что, что я сделал? Я сначала посортил по x.
Дальше мне что нужно? На самом деле, мне нужно просто в каждой вершине
вычислить те точки, попавшие в эту полосочку,
и сжать их по y, то есть посортить по y.
Но это сделать очень просто. Смотрите, если, например, в таких вот тривиальных
полосочках из одного столбца все это сделаю, то есть, ну, построю внутреннее
DO для всех вот этих вот листиков.
Во всех таких тривиальных столбцах я нашел ответ.
Что мне надо делать дальше? Дальше мне нужно просто слить вот эти два списка.
То есть, если я знаю список точек здесь, список точек здесь,
в отсортированном по y порядке, то дальше, чтобы получить список точек здесь,
мне надо их просто слить с помощью merge.
Потому что они здесь посорщены по y, здесь посорщены по y,
и я их могу склеить за линейное время от их суммарного количества.
Значит, я здесь знаю список точек в этой полоске в порядке возрастания по y.
То есть, они уже сжаты, и на этом можно строить DO.
Получается, что суммарно, ну, как бы, то есть, я по факту просто делаю merge
вот в этом внешнем DO, на этом мне нужно log n времени и log n памяти.
Нет, просто подождите.
Сама сортировка во всех каждом из столцов триллиамета,
ну, сумма всех сортировок будет на log n?
Еще раз, смотрите, я сортирую, на самом деле, только один раз,
только по x.
Внутри, смотрите, ну, для вот этих вот листиков у меня нет сортировки никакой.
Я просто знаю, какая единственная точка лежит в каждом столбце.
Справедливо.
Скажем так, если считать, что все координаты по x,
по парам различные, то такого не бывает.
Хорошо, на самом деле можно сказать, что, типа, это на самом деле работает,
и если у вас есть совпадающие координаты.
Смотрите, можно просто сделать так, что у вас вершина отличает не целиком полоски,
а, ну, короче, вершина отличает точки.
Подумайте.
Все, спасибо.
Аплодисменты.
