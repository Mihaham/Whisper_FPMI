сегодня у нас будет давайте поменяю еще так вот так лучше сегодня у нас будет с вами завершающая
тема по сортировкам в каком-то виде мы больше на них останавливаться не будем мы наконец сегодня
поговорим о последний из них который мы должны разобрать в нашем курсе и как раз таки постараемся
с ней понять что это такое что называется пирамидальные и что там происходит вот кто
не знаком с такой сортировкой ура это для всех что-то новое это хорошо потому что quicksort
обычно знаком mordsort тоже пирамидальная не всегда вот хотя сортировка достаточно забавная и
интересная в том плане за счет чего она построена и первое что там есть ну как бы это что вообще такое
пирамида смотрите пирамида вот здесь вот так сказано это пасть это объект массив во первых
который можно рассматривать почти как почти полное бинарное дерево у кого-то видимо закончился
семинар или я не знаю да вот понял так вот в общем-то здесь так написано объект массив который
можно рассматривать как бинарное дерево смотрите само по себе бинарное дерево это один из вопросов
того вообще что это такое и как это выглядит мы с вами проговорим про бинарные деревья попозже
пока все что вам нужно знать про бинарные деревья это то что у этого дерева есть корень и у всех его
вершин есть не более двух детей то есть если рассматривать именно бинарные деревья то
можно называется бинарная потому что би-2 вот можно вот так вот сделать можно здесь вообще
это будет бинарным деревом но это не является пирамиды что такое почти полная пирамида с точки
зрения ой после полная бинарные дерева с точки зрения пирамида если мы с вами
возьмем пирамидку то есть почти винарное дерево какое-нибудь если у него заполнены
в те слои кроме быть может последнего и последний должен быть заполнен слева направо полностью то
то есть вот это является пирамидой если я добавлю вот так элемент это тоже
будет являться пирамидой но если вдруг я возьму и уберу здесь левого сына а
скажу что у меня будет правой то это уже не является пирамидой понятно сейчас
что было
хорошо давайте еще раз а когда мы говорим с вами о пирамиде мы с вами
говорим о бинарных деревьев понятно что такое бинарное дерево пока не больше
двух детей хорошо бинарное дерево это такое
такая некоторая сущность где у нас есть корень вот это и у каждой из вершин
не более чем двое детей и все что подвластно этому принципу это является
бинарным деревом существует различные виды бинарных деревьев бинарные деревья
поиска пирамиды и так далее они все обладают каким-то определенным
свойствам которые необходимы но сама бина само бинарное дерево оно любого
такого вида даже вот это является бинарным деревом
но у меня есть корень и у каждого не более одного у не более двух детей
понятно вот а если же мы с вами говорим про пирамиду то это почти полное бинарное
дерево почти полное будет означать здесь в этом контексте что у нас заполнены все
уровни этой пирамиды кроме быть может последнего то есть мы не можем сделать
вот так если мы не заполнили предыдущий уровень нас такого здесь
невозможно это раз а во-вторых последний уровень должен быть заполнен полностью
слева направо то есть не может быть такого вот если это пирамида то я к
примеру уберу отсюда вершину скажу что она у меня будет здесь нет мне сначала
должна быть вершинка здесь теперь стал понятнее всем хорошо вот то есть вот
такое называется пирамида и почему это называется объект массивом типа почему
с чего бы а в действительности пирамида это такой такой приятный объект который
можно перекладывать с точки зрения пирамидки а на массивы и так далее причем важное
свойство пирамида если это пирамида по максимуму как в этом примере что родитель всегда больше
своих детей вот это будет означать что это пирамида по максимуму если всегда меньше то
пирамид по минимуму ничего сложного здесь окей а давайте напишем какие-нибудь чиселки скажем
что вот у нас такая пирамида как это переложить массив ну давайте здесь возьмем там 10 9
8 7 6 4 да пирамида и куча это одно и то же но я предпочитаю все-таки пирамида потому
что она слово hip вот и все это в англоязычной литературе все-таки хип у нас применяется
вот таком виде а куча больше применима к динамической памяти потому что динамическую
память тоже периодически называют кучей может быть путаница здесь я предпочитаю слово пирамид вот
смотрите здесь все выполняет тому свойству что у нас каждый из родителей больше чем его дети
равно быть равно может здесь у нас нет такой категоричности я просто показываю на таком
примере вот у нас вот такая вот есть пирамидка нужно что-то делать и как-то ее перевести в
понятный нам вид с точки зрения языка программирования то есть понять как это
вообще легко перевести сделать как это можно сделать а это делается достаточно просто вы
должны заполнять массив идя по уровням сверху вниз и слева направо что это означает здесь это
означает здесь следующее что вы можете взять сначала 10 потом 9 потом 8 7 6 и 4
10 9 8 7 6 4 вот в таком порядке можно перекидывать эту пирамиду вообще с пирамиды связано
достаточно много интересных вещей на тему того что типа ее применение с точки зрения сортировки
вот вам очевидно но на самом деле она удобно и периодически бывают такие структуры что вам
нужно вставить там куда-то в середину какие-то элементы в массиве и для того чтобы это делать
быстро это удобно использовать здесь пирамиду на самом чтобы сохранялось какое-то определенное
свойство а потому что здесь мы как бы говорим с вами про больше меньше но больше и меньше может
быть по любому признаку из объектов только обязательно по числу который там стоит может
быть именно по ключу может быть еще что-то на самом деле здесь много разных применений вы еще
увидите применение пирамиды с точки зрения так называемой очереди с приоритетами с декартовым
деревом вот все это там будет применяться поэтому это такой важный объект на самом деле но первое
где мы рассмотрим это сортировки самое понятное самое простое что происходит с ней вот пока
понятно что я сделал да 7 и 8 да что нет да мне никто не запрещает здесь поставить
семья здесь поставить 8 мысля родитель больше детей все нет конечно конечно будет наоборот здесь
у нас главное свойство оно одно что родитель больше максимум за единичку ну как извлекаем ну
так ну ну да тут примерно в этом на самом деле и мы к этому придем но по чуть-чуть вот у нас
есть такая пирамидка классно прикольно что с ней делать непонятно в принципе вы часто будете с
таким сталкиваться на самом деле поэтому нужно понять что вообще с ней делать пирамиды бывают
не только по максимум бывает по минимуму то есть можно развернуть эту пирамидку и сделать так
что сверху минимум но я буду рассматривать с максимум просто для удобства мне да нет но здесь
их нельзя поменять местами потому что 8 иначе мы нарушим да ну смотрите можно пирамиду сделать
примерно следующую не знаю там давайте 15 а 4 13 0 2 им могу здесь еще сделать 7 здесь давайте там
не знаю 11 здесь там минус 1 пирамида пирамида что еще раз
да нет смотрите дети справа здесь они меньше а дети справа здесь больше получается разной
но именно так просто взяли да повернули нет в действительности здесь неважно как это дети
располагаются между собой нас вообще это не интересует нас интересует одно лишь
свойство от родитель всегда больше чем его дети все и вот вопрос когда я перевел вот это вот
эту пирамидку к примеру а к массиву давайте расставим индексы в этом массиве 0 1 2 3 4 5 скажите
кто-нибудь видеть закономерность точки того как связаны дети с родителем по индексам могу ли
я понять что является из этого ну вот то есть вот у 8 понять что девятка его родители нет
так и что делать и что делать не а как нет но это перебор тогда мы тогда было долго
не интересно рассказывать вот ну как интересно но долго вот что-нибудь полегче да пробуйте
понять закономерно давайте я расставлю 0 1 2 3 4 5 а ну давайте даже продолжу у меня будет здесь
какой-нибудь 6 здесь седьмой нет мы хотим по индексу понять кто родитель а кто ребенок
смысле 3 7 минус 3 4 индекс седьмое здесь 3 минус 1 нацело на 2 это что будет означать
индекс родителя да первое что вы должны были заметить что если у нас есть индекс то его
родителям этого индекса будет индекс минус 1 пополам у этого 7 минус 1 3 6 поделить на 2
не договорил вот если я взял бы здесь восьмой какой-нибудь элементик тогда 8 минус 1 это 7 7
численно на 2 3 и так далее тут для всего бы так получилось то и смотрите первое что я легко
заметил что я теперь могу легко определить родителя и получил такую взаимосвязь вопрос
а теперь у меня есть индекс я хочу получить левого ребенка у меня есть индекс я хочу получить
правого ребенка что делать дам здесь это у меня будет двоим плюс один а здесь будет двоим
плюс два а если бы мы рассматривали своими массивы в которых начинается все с единички
но здесь был бы может попроще и пополам 2 и 2 и плюс 1 но сути не изменилось ничего не изменилось
и в действительности взаимосвязь с родителями важна с родителями с детьми и так далее помните
об этом вот это всегда важно это всегда нужно в том числе и здесь а кроме того а интересный
факт так как это почти полное бинарное дерево и у него заполнены все уровни кроме быть может
последнего то его высота всегда тета от логарифма потому что у нас всегда на степени ну степень
двойки присутствует понятно это почему вот это все достаточно просто пока ясно откуда все взялось
посмотрели поняли отлично а я иногда да буду так пролистывать небольшие спойлеры а потом
заново возвращаться всякий случай чтобы они вам ничего не забыл хорошо вот мы с вами это все
получили а что же нам вообще с этим делать а для того чтобы перейти к тому мы же как-то должны
получить пирамиду вот у нас есть какой-то массив данных мы должны как-то получить эту пирамиду
должны что-то с ней сделать мы должны с вами понять а как вообще можно восстанавливать
свойства и вот то что я сейчас находил вот эти взаимосвязи поможет нам восстанавливать
те самые свойства и первое свойство следующее представьте у меня есть какая-то пирамида
ну давайте опять возьму там 15 не знаю 11 10 105 скажу что слева меньше давай что-нибудь придумаем
здесь а 9 8 а нет нет ладно хорошо тогда наоборот здесь 6 5 9 8 вот так вот сделаем
что пока подходит что вы смеете почему здесь этот больше этого здесь это и больше этих
я вас понял пусть будет так здесь 2 4 например здесь 0 1 здесь давайте возьмем не знаю там
3 например так вот я хочу сделать таким вот образом представьте следующую картину какой-то
момент а я осознаю что вот это 11 мне не надо просто не хочу и беру из меня его 11 на к примеру
минус 1 видите у меня нарушилось свойство пирамида я хочу его восстановить что мне с этим делать
нет здесь не севтап здесь вот правильная мысль смотрите я в начале должен поменять с кем-то из
детей для того чтобы причем с максимальным из них для того чтобы сохранилось свойство то есть
если я поставлю сюда пятерку у меня все также будет грустно но если я поставлю сюда шестерку
то шестерка больше чем 5 и все хорошо поэтому я попытаюсь поменять это такими местами получаю
с вами 15 давайте только ту ветки напишу но помните что есть другая ветка хорошо просто для
экономии времени я получу с вами 15 6 здесь минус 1 здесь 2 4 ну и так далее здесь что-то еще существует
у меня все еще нарушено это правило то есть я опять должен посмотреть на его детей выбрать
максимальный и поднять его наверх то есть вот здесь получить 4 и тогда после всех этих
манипуляций я с вами получу такую пирамиду 15 6 10 здесь у меня будет 4 2 минус 1 5 0 1 10 8 9 3
я восстановил свойство пирамида вот это то что я сейчас с вами проделал называется просеиванием
вниз да потому как бы вниз этот элементик прокатывается потому что он уменьшился в случае
пирамида по минимуму наоборот он увеличивается и тогда он тоже просеивается вниз вот я смотрю
именно на вот этот вот момент и понимаю ага если я элемент изменю тогда я могу восстановить
его свойства восстановить свойства пирамида во всем этом массиве причем я могу это сделать
достаточно просто почему я же тут должен найти из детей какие-нибудь максимальные элементы
обращаться к детям я умею ладно пусть будет так вот и поэтому я могу быстро за от единички
найти темист самого большого ребенка среди возможных из этих двух или одного смотря кто
это есть здесь хорошо вот таким вот образом я могу реализовать тот самый сив даун сив даун
как выглядит ну смотрите я в начале с вами беру левой и нахожу левого ребенка с помощью вот этой
формулы вот здесь написанный а после я нахожу правого ребенка ну и говорю что пусть у меня
максимальный все еще находится в этом индексе потому что я не знаю я должен остановиться или нет
потому что представьте что вместо здесь а ну здесь у двойки там было бы минус 5 минус 7 здесь
минус 8 минус 3 вот я бы поставил минус 1 я дальше бы просеивать не должен был то есть у меня
должны быть какие-то остановочные механизмы здесь все они должен прям вниз вниз эти и здесь
звучит следующее давайте я возьму предположу что этот индекс является максимальным после
чего я проверю со всеми его детьми причем заметьте у меня здесь написан а их и тут
написано кстати неправильно написано если левт меньше сайза или если рай меньше сайза поправлю
потом в итоговой презентации просто меньше и меньше и меньше равно не должно быть ссоре здесь
ошибочка в общем-то если левый ребенок меньше сайза и а само значение лево ребенка оно больше
чем моего максимального тогда я должен сказать что максимальный значит это ребенок
тоже косяк простите давайте перепишем это красиво давайте с вами это быстро сделаем я не думаю что
займет много-много времени я сделаю это где-нибудь вот здесь прошу прощения делал достаточно быстро то есть
смотрите наш некоторые севдан а это и сайз вот ну у меня есть левый ребенок но я его просто
нахожу у меня есть правый ребенок но я говорю что этот максимальный он равен и и что я должен
сделать на всякий случай вам все здесь напишу есть ли у меня левый индекс меньше чем сайз именно
меньше и а от левта больше чем а от моего максимального тогда в этом случае я буду
что-то делать скажите мне а что если левт будет больше а бывает такое что левт больше райт да где
индексы ну левт левт это именно вот вызов этой функции да что размер массива ну количество
элементиков вот это левт чайлд от и это рай чайлд ты хорошо я прям допишу это именно индексы
возвращают вот вопрос вот это выполнится или нет ну вот я могу обратиться к левт
а правильно короткая логика слушайте этого человека как тебя зовут слушайте артур и не
будет вам горе мне видимо сегодня много будет цитат ладно короче в действительности а с точки
зрения плюсов существует короткая логика и короткая логика говорит нам о чем если у нас
есть и и выполнен и не выполнено первые условия то второй мы даже проведать не будем потому что
ноль и что-то всегда ноль понятно то есть если вот это окажется фолс то согласны что окажется
фолс все выражение да вот это и есть та самая короткая логика которая иногда играет роль вот
вам пример этого обращения то есть он не будет вот это высчитывать он не будет даже сюда заходить
потому что если это фолс тогда и мне не важно что здесь это все будет фолс понятно это важный
момент здесь и здесь написано корректно с точки зрения плюсов вот тогда все тогда вот я ну то
есть у тебя в какой-то момент ты выйдешь за границу массива и будьте грустно вот и в этом случае
что мы говорим мы говорим просто что у нас максимальный элемент он равен тому самому
левт но а потом для того чтобы найти все-таки самый максимальный среди всех всех этих трех
элементов мыши должны сравнить с правым ребенком вот но здесь аналогично мы с вами делаем только
здесь мы говорим что райд меньше сайза заметьте мне тут тоже нужно писать потому что иногда
бывает левый ребенок существует а правого нет вот райд меньше сайза и а от райд будет
больше чем а от этого максимального причем мы не знаем этот максимально уже стал левым ребенком
или нет или все еще остался самим родителям непонятно здесь поэтому в этом случае мы просто
должны именно сравнить таким вот образ и дальше мы говорим что вот этот максимальный ребенок
в этом случае это тот самый правый а зачем а зачем проверять что левыми а конечно конечно здесь
это все уже есть вот таким вот образом мы с вами находим и нам нужно понять а так как мы рекурсивно
должны снижаться спускаться вниз потому что мы если один раз пустились мы дальше еще раз должны
для детей проверить и еще раз и еще раз до тех пор пока не остановимся какой момент мы понимаем что
мы останавливаемся мы понимаем это в тот момент когда у нас максимальный среди вот этих трех
элементов вот то есть вот здесь вот минус 1 6 5 вот здесь вот это минус 1 2 4 и так далее вот
мы среди этих троек смотрим когда мы говорим о том что нас максимальный среди этих трех
это тот самый элемент с индексом и и в этот момент мы с вами останавливаемся поэтому условия
остановки точнее здесь не условия остановки условия продолжения рекурсии скорее написано
оно звучит следующим образом что если у нас вот этот максимальный не равен и это означает
следующее что среди его детей нашелся элемент больший значит нужно продолжать что-то делать с
этим тогда в этом случае мы с вами берем просто и свопаем а а от и и а от этого максимального
и кроме того мы должны сделать еще один сев даун для этого элемента то есть для
а индексом largest и с размером size размер никак не изменился вот мы это обязаны еще
раз сделать для того чтобы вот избежать случая вот когда вот здесь опять нужно его опустить
или и так далее размер всего массива размер все пирамиды вот вот вот вот смотри у сколько тут
элементов 1 2 3 4 5 6 7 8 9 10 11 12 ну я вот это не беру вот это является сайзом если вы
представите это видимо сива ну вот этот элемент вот эту пирамиду то это 15 давайте
здесь напишем 15 что там а минус 1 нет давайте возьмем итоговую пирамиду лучше чтобы не
запутали 6 10 4 5 8 9 2 минус 1 0 1 ну здесь 3 вот размер этого массива ну здесь в этом массиве
столько же элементов сколько пирамид согласны вот и получается что размер это
количество элементов это массиве или количество элементов пирамиде все одно и то же
вот это когда это работает ну возьми вот этот элемент у него индекс 11 11 умножить на 2 плюс
1 это 20 3 ой да я уже все да это 23 23 больше сайза у него нет детей такая логика да
вот это и будет означать что у нас нет и никого
почему у нас эти функции они просто возвращают 2 и плюс 1 или 2 и плюс 2 они возвращают 2 и плюс
1 и 2 и плюс 2 вот эти функции это левый ребенок это правый ребенок нам никто не обещает что мы
не выйдем за границу массива вот еще есть вопросы к сейвдауна понятно что здесь было вот таким
образом мы восстановили нашу пирамиду в случае изменения одного массива причем уменьшение его
элемента а что делать если увеличится да нужно просить его вверх это называется просеивание вверх
и в том здесь все еще проще просто сравнить два элемента да потому что здесь ну давайте
что-нибудь нарисуем еще а давайте сделаем здесь опять 15 а 4 7 1 2 ну возьму такой простейший какой-нибудь
и вот я поменяю 2 на 8 если всего один элемент то означает что вот здесь вот второй ребенок он
всегда меньше чем его родитель а если я этот элемент увеличил и он стал больше родителя то он
автоматически больше и второго ребенка понятно поэтому если я поменяю их местами то у меня все
будет хорошо и я так должен опять же буду продолжать до тех пор пока не остановлюсь вот здесь
мне всего до одного раза достаточно окей вот ну и сфтап ну как бы нам нужно здесь уже обращение
к перренту я пока здесь дальше вернусь к ремне работа нам нужно всего лишь обращение к перренту
то есть я смотрю кто у меня является родителем и просматриваю если этот родитель он меньше чем
этот элемент тогда его про я их меняю местами и делу сфтап опять все ничего здесь критичного нет
окей вот а теперь вернемся к времени работы вроде бы очевидно правда что всегда он работает за
что если я скажу что не очень чем возьмем какой-нибудь пирамидку
я сделаю вот так вот я могу просеивать либо влево либо вправо либо влево либо вправо согласны
но просеиваясь вниз вот здесь вот элемент стоять тикс он может либо сюда ути либо сюда ути
плюс-минус равно вероятно назовем это так неважно а плохо что делать
да
сверху можно ограничить как алгоритм почему
да так
на один могут различаться почему кто вам такой рассказал то есть денечка не считает смотрите
я объясню в чем здесь кроется проблема если вы говорите что у нас есть логарифм
например двоичный оттен и логарифм двоичный оттен минус один такой минус один
константы я не отрицаю вопрос сколько у нас элементов минусуется вот этих пример
а что пытаюсь типа просто понять вашу логику да да да это понятно
вот вы представляете типа минус половинка элементов вы сделали
так да это это правда да в действительности это можно объяснить именно так это хорошее
объяснение здесь но есть более формально более формально звучит следующим образом даже если
мы возьмем почти полное вот с левой стороны мы возьмем как будто бы полное дерево справа
и не полное дерево так разделим пополам что вот здесь у нас максимум элементов здесь нет а всего
элементов пирамиде n когда спойлер такой маленький будет меньше либо равно чем 2 и на 3 здесь меньше
либо равно чем и попало всегда вот эта часть максимум дает 1 третью n вы даже можете посмотреть
на это все дерево и понять почему смотрите у меня здесь четыре элемента здесь у меня только 6
вот ну если в общем смотреть типа на все это корень как бы относится то сюда то сюда плюс
минус 1 но в том суть что вот тут количество элементов оно больше чем здесь если что интересный
факт вот если рассматривать это с такой точки зрения то в этом случае вы говорите что у вас
всегда уменьшается разброс по элементам которым вы ходите то есть вот это вот t от n оно придет
максимум к t от n t от 2 в третьих n ну потому что у нас время алгоритма оно должно зависеть как-то
от n я говорю что один раз пустится это тоже самое что там t от единички это раз плюс спустится
по под дереву из двух третьих элементов максимум потому что здесь две третьих здесь их n полам то
есть максимум мой будет вот такой 2n на 3 можно можно интересно вот но суть примерно в этом ok
продолжаем дальше вам перерыв не нужен нужен дальше хорошо можно дальше да
вот это вам вопросик как раз таки на подумать но если ты порисуешь ну вот ты можешь просто
сначала порисовать деревья увидишь что вот здесь количество листьев так почему две трети на самом
деле это связано с количеством листьев в дереве из n элементов грубо говоря то есть смотри вот
это x вот это x но они одинаковые сколько у дерева с x элементами может быть листьев
в самом деле x плюс 1 вот такое объяснение вот так что так окейм что касается сифта по аналогично
на самом деле но здесь так как мы вообще поднимаемся вверх то у нас не может быть
определение типа мы уменьшаемся в две трети ну в 3 вторых раза старая раз здесь всегда будем
уменьшаться типа на уровне и всегда смотреть на эти уровни поэтому получаем тот самый благориф
заветный тоже и вот мы подходим к самому интересному представим следующий у нас есть
с вами массив данными и вам ему нужно построить пирамиду у кого какие идеи как это делать
мы мы идем к пирамидальной сортировке чтобы сортировать элементы я понял так
а как мы можем восстановить свойства пирамиды смотрите мы восстанавливали
свойства пирамидов в случае когда пирамида всего один элемент в ней менялся
у меня вопрос в этом случае а что делать если оно там не выполнено нескольких уровней
так
так так то есть вы мне предлагаете создать то мы массив правильно
так и там закидывать все самые или элементики
тогда за сколько будет работать по строению пирамида которые мне назвали прикольное это
надо быстрее быстрее выше сильнее нужно всегда к этому а это сортировку пока я пирамиду строю
так
ну вообще в действительности добавляйте по одному элементику это логично но что еще раз
как
ты их просто так не солью что-то корня нет вот если корень был туда я вообще не отрицаю но
без корня ты их просто так не солью а тогда где под корень останется этого корня
получается опять благорифа пойдем не понял в общем в действительности рассуждение о том что
добавлять элементы пирамидку по одному и как-то сев дауни они имеют смысл и это правильно и
хорошо но нужно и делать это с другого конца а а давайте с вами напишем какие-нибудь данные и
построим пирамиду тогда я думаю вы поймете что я имею ввиду продиктуйте мне любые чиселки 3
7 10 давайте чуть так 5 6 1 28 учился в этой школе сразу видно так а минус 7 давайте так
и остановимся пожалуйста вот хорошо у нас есть вот такая вот недопирамидка и она не выполнил
здесь свойство о том что у нас в действительности лежат максимальные элементы сверху смотрите я
вот эти связи пока уберу вот у меня эти элементы есть что я хочу сделать я хочу сказать вот на
этом примере следующие возьму сначала все листы которые у меня есть 1 2 3 4 5 это мои
листы пирамиде листы это у кого нет детей вот будем 7 лет так живу а вот смотрите у нас есть
листы у которых нет детей согласны и то что а элементы пирамиды из одного элемента является
корректный согласны ли вы тогда что вот это все является под корректной пирамидой ми по факту
правда давайте теперь рассмотрим добавление нового элемента я рассматриваю эту пятерку и
она образует под собой вот такую вот пирамиду из трех элементов мне необходимо восстановить
корректность что я могу сделать для того чтобы остановить здесь корректность попробовать так
как вот эти корректны а вот этот некорректен если у нас в корне находится некорректный элемент
что я должен сделать просеивать вниз то есть сив даун я здесь делаю с вами сив даун и получаю
вот это 5 и 179 я меняю их местами и получаю здесь 179 и 5 хорошо ну хорошо вот рассмотрим
следующий элемент он образует под собой вот и его дети являются корректной пирамидой
значит у нас один элемент всего лишь неверный и он находится в корне значит все что мы можем
с ним сделать это сив даун и опять смотрю что здесь будет происходить ну когда я сделаю здесь
сив даун я получу здесь 28 а здесь 10 пойду дальше стим им 6 и 179 ну очевидно
смотри этот элемент находится в корне ну вот момент эти элементы в корне конечно потому что
только он является некорректным все его дети являются корректными пирамидами ну потому что
во-первых листы были здесь корректны но это корректные пирамиды да я добавил один элементик
вот здесь к примеру он и сделал сив даун я восстановил корректность пирамида понятно а
если я восстановил корректность пирамида то это тоже стало корректной пирамиды и получается
когда я уже сел я говорю что у него этот корректный пирамид на пирамиды
ну почти почти почти но нет ну смотрите я сейчас дальше это другой вопрос пока я просто иду с
низу вверх и справа налево вот вот у меня вот такие элементы здесь 28 являются корректными
пирами вот я добавляю последний свой элемент корень но он у меня некорректен значит я с
вами должен что сделать сив даун я делусь даун и меняю 3 со 179 но не ограничивается только тем
что он опускает на один раз он же и рекурсивно это делает поэтому сравнить 3 и стать сюда ставлю
7 сюда 3 дальше 3 5 минус 7 но очевидно что сюда становится и смотрите корректно ли это пирамида
корректно за счет чего она становится корректно за счет того что в каждый момент времени у нас
есть корректный под пирамида грубо говоря с корнями в каких-то числах и мы с ними работаем
выглядит вот так кто мне скажет почему я иду сайза минус один пополам
родитель для самого последнего элемента
да это первый лист запомните во-первых пирамиде что в пирамиде все листы
имеют индекс какие 2 и плюс один ну мы как должны найти индексы листов то есть я
же начинал там с листов грубо говоря смотреть а я говорю следующее вот у меня есть 2 и плюс
один что означает лист что 2 и плюс один больше либо равен чем size и 2 и плюс два больше чем
больше либо равен size но очевидно что я буду рассмотреть чисто первое уравнение неравенство
вот получается что здесь и больше либо равен чем size 1 полам вот это все является листами все
элементы с таким вот индексом являются листами поэтому я иду вот у меня построение оно шло
откуда оно шло с листов вот все листы они и так корректно их трогать не надо нужно идти левее
а потом вверх все листы являются корректными пирамидами
где они не входят больше либо равны сайс минус один пополам сайс минус один пополам а вот а вот это
так еще раз если это лист у него нет ребенка значит если у него нет ребенка значит его дети
грубо говоря находится замыселем чем нет зачем ну у тебя гранично сверху сайзом еще раз все индексы
листов находятся от сайс минус один пополам до сайза не включая зачем только вот то есть
смотрите благодаря вот этому вот мы можем сказать что мы знаем индексы листов и здесь и здесь и
напред и на последнем уровне и на предпоследнем уровне вот мой любимый вопрос который ставит
обычные людей в тупик на экзамене скажи мне индексы листов мне вот говорят то и такое ну вот
я нарисовал вот эту вот пирамидку где у меня есть и этот части это части я спрашиваю а тут и все
ломаются в этот момент не ломайтесь проблема в том что вот достаточно вот этих вот вещей понятно
а нет что получить индексы листов которые везде где угодно которые могут быть и на последнем и
не на последнем у тебя пирамида может быть полной прям бинарным полным деревом то есть
для всего работает она работает для таких пирамид и для я имею ввиду под полный я имею в виду вот
такую пирамиду если я сделаю сев даун для листа что-нибудь изменится ну типа и вы можете там
написать сайз минус один пополам минус один вот единственное там даун ту нулик вот за это опять
прошу прощения вот не вычел но да надо делать это до нуля у нас пирамида с нуля строить вот а ты
понял или нет на чем люди ломались обычно экзамен когда я говорю вот у меня есть пирамида скажи
мне индексы листов мало кто забывал вот что что для индексов листов достаточно вот этого
те пытались вывести мне через степени двойки это все из-за этого были проблемы запомните все
гениально просто индекс где мы находимся вот
достаточно достаточно я только из него и делаю вот этот вывод вот ну просто написать нужно и
то и другое вот ну и да инвариант это как раз таки то что я с вами говорил то что у нас когда
мы находимся на и там месте вот здесь вот и то я подразумевается итерация на и и и и и то у нас
все индексы и плюс один и так далее до сайз минус один они являются корректными пирамидами сначала
все листы являются потом у нас добавляется один элементик мы восстанавливаем корректность пирамида
она становится опять корректный и так далее за сколько это работает за еще раз за инлуген согласно
что за инлуген плохо плохо и кто мне скажут на экзамене что это работает за инлуген я
честное слово даю вот прям вот на те крест не знаю типа я отправлю на приздачу у меня уже иногда
нерв не хватает на это все это не работает за инлуген хотя хоть это так и выглядит
почему по очень простой причине вот помните вы мне предлагали строить дей строить пирамиду добавлять
элемент потом и вы там севда у нас и втапить и так далее здесь я предлагаю немного другую
системы мы делаем просто севда он всегда это раз и вопрос а сколько мы будем раз севда у них
согласна ли вы с тем что если элемент находится на предпоследней то мы его максимум один раз
севда а если ну чуть повыше то два и так далее здесь уже логариф я не спорю правильно док смотрите
здесь количество элементов большое а здесь он один то есть у нас количество действий вниз не
так много но элементов много количество действий вниз много но элементов мало это нужно просто
аккуратно расписать всегда и тогда у вас все получится не квадрат это вот он работает
сейчас вот покажем с вами как это работает смотрите а что такое высота в пирамиде на высоту в
пирамиде мы возьмем это как число ребер в самом длинном простом нисходящем пути как бы это
страшно не звучало простой нисходящий путь означает что там нельзя крутиться постоянно ну туда-сюда
ходить вот нисходящий вниз идет и вот мы сколько идем до как до самого дальнего листа вот так это
является высотой вот такое определение ну высота у нас естественно округление логарифом просто вот
есть следующее утверждение над которым я предлагаю вам именно подумать его достаточно просто его
сможете объяснить что на любом уровне на высоте аш находится n делить на 2 в степени аж плюс один
элементов а нижний уровень у него а аш 0 количество ребер вот ну 2 в степени 0 плюс 1 это 2 ну то
есть на последнем уровне не более чем он пополам вон я с вами показывался немножко выше в два раза
меньше на 4 и так далее в этом суть вот и тогда что мы можем сказать о времени работе время работы
здесь это т ну это сумма от высоты нуля до округления логарифма это раз ну мы суммируем по всем
высотам сколько находятся элементов на каждой высоте это n делить на 2 степень аж плюс один и
за сколько работает севдалм в этом случае в худшем за от аж правильно не он не за от
логарифма в этом случае а за от аж согласны а у это такая линейная функция можно мне все вносить
это не страшно но если у вас есть сумма вот я вношу сумму и я выношу n и 2 потому что сумма не
зависит от n ну там нет параметра n там аш идет вот поэтому это могу вынести получается нас о
от n пополам и сумма аж делить на 2 степень аж смотрите а вы дошли до рядов маклоуэрна вот
это все нет что тогда тогда вот примечание это для вас если у вас есть x и оно делится на 2
степени x то это бесконечный ряд имеет сумму 2 это хорошо что тебя очевидно вот но в действительности
это бесконечный ряд имеет сумму 2 ну и все а значит я вот эту сумму которая у меня есть а аж
делить на 2 степень аж могу сверху оценить двойкой просто но это если это бесконечности рассмотрю
согласна все у нас получается вот он да да
сейчас 2 3 4 5 6 7 8 9 9 согласен 9 лимитов а ой подожди вот какой левой у них высота 0
они отдельно считаются вот здесь высота 0 вот здесь высота 0 вот здесь 0 вот здесь
0 вот здесь 0 вот здесь 1 вот здесь 1 в семерке 2 ну где вы видите здесь нисходящий путь из рёбер
в универ
у них высоты другие у них высоты не то что вот это вот все является высотой 1 нет тоже важно
понимать окей конечно принято
какую еще раз формула почему она получается вот это именно какой конкретно кусочек не ясен
первый шаг смотрите у нас на высоте аж находится а n делить на два степень аж
плюс один элементов согласен а сев да он за сколько работает за о от аж но от высоты
максимум высоты вот получается что у меня по n делить на два степень аж плюс один на о
согласен вот столько будет там элемент но я же должен просуммировать по всем высотам
возможным получаю вот эту сумму суммы согласен отлично а теперь о является линейной функцией ну
то есть все суммы которые не запихая они нормально будут там жить поэтому о я могу вынести за скобку
а внутри у меня остается n делить на два аж плюс один еще аж от ошки и все ну грубо
говоря у меня получается там а n делить на два степени аж плюс один и аж вот это все является
под суммой но эта сумма она идет по аж значит я могу вынести n пополам к примеру но n не
зависит от аж они ну они зависящие но не в этом смысле здесь не по n идет у нас сумма а по аж вот
а здесь получается аж аж делить на два степени аж но дальше это ограничено двоечкой
окей принято в каком-то виде хотя бы ладно так что да допомните этот факт обязательно
экзамен спрошу и спрошу только не только я вот одного человека так отчислил что вы были
серьезными момент а вообще я отчислил по моему жизни своей только одного человека но там было
коллегиальное решение не только мою вот а там не только в этом скажу честно ну как бы да там же
для того чтобы вас отчислить нужно сначала вам дать передачу потом комиссию и только вот после
комиссии вас отчисляют на комиссии всегда присутствует два человека так что там успокойтесь просто так вас
не отчислят если вы что-то дознаете нет никакой беды если вы конечно с переперездачей больше не
получите но это так отдельно причем заметьте снег то уже выпал вот это пора да да а вот так вот
ладно а переходим к самой пирамидальной сортировке на самом деле у пирамидальной
сортировке достаточно простая идея вот если у нас есть с вами пирамида построенная уже построена то
как я могу из нее получить отсортированный массив давайте вот здесь вот это опять же нарисую вот у
меня с вами это пирамидка давайте обсудите колок попозже вот завтра все верно а при
пирамидальной сортировке смотрите согласны что сверху у меня всегда стоит максимум давайте
но я же хочу отсортировать их по возрастанию вот моя задачка здесь давайте я вот этот вот
максимум отправлю в конец массива и забуду про него то есть в этом случае если рассмотреть
весь мой массив давайте первоначально он будет выглядеть как 179 число состоящее из трех цифр
неприятно писать долго 5 6 11 10 10 3 и 7 вот мой массив чего
чего логен так ладно а
минус 7 вот чего я делаю на первом своем действии я говорю следующее давайте я поменяю 179 и
минус 7 местами я получу здесь 179 здесь минус 7 здесь все также 7 28 5 6 11 10 и 3 я получаю
вот такой кусочек и говорю ага тогда в этом случае вот здесь это выглядит как 179 а здесь
минус 7 и я обрубаю вот эту связь то есть я просто уменьшаю сайз пирамида на 1 тогда в этом
случае у меня пирамида теперь будет строиться до вот этих элементов и здесь 179 уже стоит на
верном месте это максимум из всех чисел и все что у меня плохо в пирамиде это минус 7 которое
стоит здесь согласно а если у меня изменилось всего одно число как в корне то как мне восстановить
корректность пирамиды сделать сев даун я делу сев даун это минус семерки она уходит сейчас скажу
сюда 28 вот сюда она уходит а здесь был 11 вот а у меня получается 28 я теперь ставлю 28 в
конец ну то есть промежуточным шагом когда я сделал сев даун у меня будет здесь 28 7 11 5 6
минус 7 10 3 вот это промежуточный шаг и я снова беру этот максимум который у меня здесь есть и
ставлю его уже в конец этой пирамида а конец этой пирамида это тройка получать здесь 28 179 3 7 11 5 6
минус 7 10 теперь я буду пирамиду строить до сюда то есть когда я вытащил этот максимум то я
уменьшать буду пирамиду когда его положил в конец смотрите я просто свопают местами и
получаю то что мне нужно и я буду продолжать так делать дальше делаю сев даун для тройки
заметьте сверху оказывается не всегда самый маленький элемент минус 7 вот здесь вообще живет
но сев даун я должен продолжать дальше у меня встанет туда на место места 11 потом 10 ну и так
далее и я вот закидываете элементы в конец всегда получу то что мне нужно и я так получу
необходимую мне отсортированную последовательность понятно что я сделал да да да да
что у нас левт больше сайза сайз меняется да и что но опять же еще раз там же короткая логика как
делает мы вначале проверяем вот этот левт меньше сайза и если это правда тогда мы только продолжаем
что-то они наоборот вот поэтому пирамидальная сортировка выглядит вот так здесь тоже даун ту
андаун ту единичка здесь правильно потому что элементы за одной пирамидки это будет там
минимальный элемент то есть смотрите я вначале делаю билд хип трое пирамиду по имеющимся данным
причем я как бы не создаю дополнительные массивы ничего такого не делаю дальше я прохожусь от
сайз минус 1 до единички и делаю следующее я свопаю но его элемент с и там свопнул уменьшил
размер моей пирамиды и делаю сев даун сделал сев даун значит восстановилась корректность
моей пирамиды появился сверху опять максимум опять его закидываю в конец уменьшаю сайз и
делаю сев даун и так продолжаю вот это является пирамидальной сортировкой есть ли к ней вопросы
нлоган всегда но вас самый худший случай какой здесь возможен на самом деле возможен
следующее если верхний элемент всегда вниз будет скатываться правда ну прям вниз вниз вниз высота
пирамиды чему равно лого риф сколько раз он может скатиться вниз вот прям до лого рифма
вот весь крайность крайность типа а смотрите у меня есть элемент на самом верху но тут
какое-то действие вот у вас есть последний вот этот уровень находясь еще на глубине
лого рифм двоечный а сколько раз вот этот элемент может оказаться вот здесь снизу то есть
я сев даун же буду минимум все время вниз ну а меньше n пополам но может быть n пополам
то есть худшее время работы n пополам возможен ага потому что здесь 2 в нулевой 2 первые и так далее
количество элемент если рассматривать у нас всегда в два раза больше здесь будет сумма двоичная а
здесь будет просто 2 в степени эту штука поэтому здесь всегда может быть н пополам элементов то
есть здесь меньше либо равно чем n пополам а это означает только лишь одно что если это меньше
либо равно чем n пополам то возможен случай когда мы n пополам раз будем ходить лого рифм двоичных
от Н. Ну и у вас вот у от Н логин. Понятно? Да. Билдхип действительно за у от Н. Сивдаун
сколько сколько стоит сивдаун? Логорифм. Согласен? Да. А сколько раз повторяешь
сивдаун? Н. Вот. Но это самое простое, с простое это объяснение. Лучше всего
вот говорить, как я сейчас вам рассказал про худший случай, грубо говоря. Вот он
вариант, что у вас на глубине логорифм двоечных от Н может быть Н пополам
элементов. Значит в этом случае вот, ну вот, худший вариант. Вот. Смотрите, а хипсорт
работает хуже, чем мерчсорт. Вот. Но иногда бывает лучше, чем квиксорт. А
маленький спойлер такой на то, чтобы вы выжили в итоговом контесте. Если вдруг
вам в итоговом контесте просят написать сортировку с 99 процентами вероятности
квиксорта вы не написали. Спойлер. Ну типа это проверялось много раз. Много кто пытался
это делать. И такое, ну чтобы вы понимали, ну сколько я тут, 7 лет учусь. Там и то и другое
бывает, но чаще всего типа то, что вы писать не умеете его. Вот. В баск. Но я говорю, это не
только вы, типа это и мой первый курс такой был, и потом был, и потом, и потом. Вот все это
время, пока я вот на все это смотрел. У всех, все кто выходил с контестов всегда говорили, типа блин,
у меня квиксорт не зашел. Вот. А в общем, а мой посыл следующий. Если вы понимаете, что там
нужна у вас логарифмическая сортировка, мерчсорт сложно ошибиться. Хипсорт тоже сложно ошибиться.
Если вы их поняли, то они очень простые. Вот. Квиксорт просто ошибится. Поэтому осторожней. Но это
так, типа, ваши в будущее, вот те, кто там досмотрел до этого момента. Может быть, они там поймут какое-нибудь
священное знание. Вы, главное, что вы запомните это. Поверьте, вспоминайте эти слова во время
контеста итогового. Это другой вопрос. Да нет, почему? Окей. Вот. В принципе, именно относительно
пирамиды, это все, что я вам хотел рассказать. Единственное, что существует, мы почти не остановимся
на этом. Очередь с приоритетами называется такая штука. Вот. Очередь с приоритетами — это вот это. Вот.
То, что является пирамидой, является очередь с приоритетами по факту. И приоритетом там выступают
какие-то ключи чаще всего. Ну, представьте, не знаю, типа, вы пришли в МФЦ, вот. Но у вас там
работает знакомая. Вот у вас нулевой приоритет. Вас проведут моментально. Но если вы пришли,
как обычный человек, тогда ваш приоритет там один, грубо говоря. И вот здесь устанавливаются
приоритеты. И все идут в порядке очереди, но только вначале обрабатываются там нулевые приоритеты,
потом только первые, потом вторые и так далее. Понятно? Вот. А сущность вот примерно в следующем.
Есть ли у вас какие-нибудь вопросы? Да. Этот вопрос я оставлю без отсвета. А что поделать?
Это не четыре ребенка. А что поделать? Кто? А пирамида является ли это сортировкой? Смотрите,
с точки зрения стабильности она нестабильна. Она нестабильна. Она может их поменять местами,
и ты этого не заметишь. Поэтому данная сортировка не является стабильной. Количество
здесь свопов тоже N log N. То есть все свопы – это те самые сивдауны. Вот. Важный момент про… Я вам
же сказал, что иногда квадратичные сортировки лучше, чем все остальные. Или нет? Нет. Возможно,
я кому-то это сказал, когда ко мне подходили после. Но это важный момент. Смотрите,
когда мы с вами говорили про количество свопов, мы говорили, что оно также играет роль. То есть время
работы – это одно, количество свопов – это другое. Представьте, что вам нужно менять между собой не
просто элементы, а массивы. Массивы из N элементов. Поменять массивы из N элементов, когда это будет
в некоторой структурке вашей, вам необходимо будет, для того чтобы одно перемещение сделать,
это будет работать за O от N. Потому что вам нужно посвопать все элементы в массивах. Чисто
указатель не сойдет. Вот. Смотря что ты будешь менять, но если я говорю про векторат, то нет. Ну,
там не так это будет. Вот. И если я возьму ту же сортировку выбора, где количество свопов всего
за O от N, тогда эта сортировка, с одной стороны, по времени работает за N квадрат. Согласны? Вот
в нынешней ситуации. Но из-за того, что у нас свопов O от N, то эти свопы выполнятся тоже за O от N
квадрат. Ага. А теперь представьте, у меня есть быстрая сортировка. Она работает как бы за N лог N.
Но у нее N лог N свопов. А каждый своп работает за O от N. Тогда за сколько работает эта сортировка?
За N квадрат лог N. Она хуже, чем сортировка выбора. Вот такие вот удивительные метаморфозы вы
можете встречать. Вы об этом должны всегда думать. И в этом плане не забывать. Во всем остальном,
в принципе, все на сегодня. Всем хорошего вечера и удачи!
