Так, ну что, здравствуйте. Давайте начинать. Я продолжу говорить про потоки. Первое, что мы
сделаем, это найдем так называемый глобальный минимальный разрез с помощью алгоритма Шторвагнера.
Мы имеем искать минимальный разрез как бы между двумя вершинами. Есть граф,
фиксированная с маленькой и t маленькая. И задача там была такая, разбить все множество вершин на два
куска. Так что s в одном куске, t в другом куске. И при этом нужно было минимизировать суммарную
capacity ребер слева направо между множествами. Здесь постановка похожая, только у нас не
фиксировано вот эти с маленькой и t маленькая. У нас просто есть какой-то большой граф, и нам
нужно в нем найти минимальный разрез в том смысле, что просто нужно как-то поделить все множество
вершин на два куска, s и t, так чтобы минимизировать суммарную capacity всех ребер из s в t. Вот такая
задача. То есть мы отказываемся от ограничений на s маленькой и t маленькой, что они должны
лежать в разных кусках. Мы просто говорим, что нужно просто найти какое-нибудь такое разбиение,
минимизирующее величину такого разреза. Поэтому он глобальный, то есть мы среди всех разрезов
выбираем минимальный по величине. Но давайте формализуем. Во-первых, давайте я для лопаста скажу,
что уже у меня неориентированный граф. Так же, как всегда, у меня есть какая-то не отрицательная
функция capacity из ребер в не отрицательное целое число. И определение, что такое глобальный
минимальный разрез. Это такая пара множеств s и t, что они, во-первых, так же как раньше в
дизюктом объединении давали бы все множество вершин, то есть они не пересекаются и суммарно
покрывают все. Ну и при этом, наверное, нужно сказать, что они не пустые, потому что если
позволить кому-то из них быть пустым, тогда разрез нулевой, просто никакие ребра не пересекаются,
это выраженный неинтересный случай. Но если сказать, что оба не пустые, это уже интересно.
Дальше, как обычно, величина разреза c с t это сумма capacity всех ребер с с в т, сумма по у с с в с т,
с ув. Ну и соответственно, нужно найти такой разрез, на котором достигается минимум вот
этой вот штуки. Вот эта штука минимальная. Так, такое определение. Понятно? Хорошо,
ну, наверное, если мы умеем искать минимальные разрезы, то глобальный минимальный разрез хоть
за какую-нибудь символику мы точно найти сможем. Как, например, можно было бы в тупую его найти?
Да, перебрать что? Ну, разделение их, наверное, 2 в n. Всего суммарно вот этих вот разбиений
всех вершин на 2 множества, их 2 в степени n, это многовато. Можно как-нибудь получше, хотя бы
запыленном какой-нибудь. Ну да, мы же умеем искать, если у меня добавляется допограничение,
что s маленькая вот здесь вот, а t маленькая здесь вот, и мы умеем находить mincut. Мы знаем,
что mincut связан с maxflow из s в t. Если мы находим одно, то мы находим другое автоматически.
По теориям Форда Фалкерса у нас есть двойственность между максимальным потоком и минимальным разрезом.
Вот, поэтому можно было бы, скажем, просто перебрать все пары s маленькая и t маленькая,
найти максимальный поток между ними, и после этого выбрать минимальный среди найденных
максимальных потоков. Понятно? Ну, просто потому что если s большой и t большой не пустые,
то какие-то две вот хотя бы по одной вершинке в них должно быть, значит, их можно перебрать.
Вот, значит, это было бы, грубо говоря, что-то типа квадрат умножить на время работы потока.
Если я все пары перебираю, потом умножаю на поток, будет квадрат на поток. В смысле,
в квадрат умножен поток. Ну, конечно, да, можно сказать, что, скажем, вот вершина номер один,
ее можно застолбить, присвоить ее обязательно первому множеству s большое. Потому что граф не
ориентированный, да, от того что я перекину единичку, ну, от того что я поменяю местами s и t,
у меня capacity, величина разреза не увеличится, поэтому можно считать, что единичка всегда в s
большом. Ну и тогда можно просто перебирать, можно s фиксировать равным единице, а t перебирать
в каждой всех вершин. И тогда будет время работы n, уже умножен на поток. Вот, значит, ну и здесь
можно было бы тоже немножко схитрить, с этой точки зрения это бесполезно, но в нашем алгоритме
это понадобится. Значит, смотрите, вот пусть давайте я в самом общем виде скажу, что я нашел какой-то
минимальный разрез между s и t. Пусть я нашел минимальный разрез. Понятно тогда, что либо это
глобальный минимальный разрез, то есть либо это то, что я ищу, либо мое предположение о том,
что s и t находятся в разных долях неверно, то есть вот фиксирование их по разной
стороны от разреза было неоптимально. Значит, у меня всего два варианта, либо s и t в разных долях,
либо в одной. Вот если в разных, я уже нашел mincut, а если в одной, то значит можно их как бы склеить.
Вот если я считаю, что их было неоптимально разделять в разрезе, то значит их можно склеить.
Тогда можно было бы сделать буквально следующее. Давайте вот эти две вершинки просто объедини,
мы скажем, что это одна большая вершина. Ну как я это сделаю? Ну вот просто если была
s маленькая, t маленькая, тут были какие-то ребра, тут были какие-то ребра, давайте я просто
эти две вершины склею и ребра объединю. Да, ну формально, значит, если у меня было какое-то ребро,
значит, если ребра у них, если были какие-то ребра ведущие в одну и ту же вершинку, скажем,
u, и здесь было написано x, здесь y, тогда после склейки у меня будет просто одно ребро веса x
плюс y. Ну то есть я как бы объединяю и суммирую capacity в том случае, если ребра у меня склеились.
То есть вот эти два ребра схлопнутся и станут одним большим ребром с capacity x плюс y. Ну и тогда
можно было бы сказать следующее, окей, значит, если s и t не в разных долях, то их можно склеить,
и дальше уже решают задачу на меньшем графе. То есть уже задача на графе на n-1 вершинке,
потому что я одну удалил. Понятная идея? Вот, значит, еще раз, да, либо я точно знаю,
что они по разные стороны от резреза, тогда поток между ними, это глобальный менткат,
ну потому что можно было бы фиксировать, я смаленькая здесь, ты маленькая здесь,
либо же они должны быть в одной доле, ну тогда их могу склеить, потому что если они в одной доле,
то том �ет не изменится от того, что я склею, то есть да, от того,
что они в одной доле, у меня все равно все вот эти вот ребра, они либо одновременно не
перецекают разрез, то есть либо они вот такие, либо они вот такие, тогда можно склеить это все в одно
толстое ребро. Вот. Вот эту идею мы будем использовать. Хорошо. Ну, собственно, вот такие вот
потоки в алгоритме, их, конечно, можно реализовать, но они будут не самыми оптимальными. Вот можно
получше сделать алгоритм Шторвагнера. Как работает алгоритм? Он устроен следующим образом. Значит,
он строит некую перестановку вершин. А1, А2, А3 и так далее, АН. Да, это перестановка вершин.
Значит, как он ее строит? Ну, А1 он выбирает произвольный. Неважно. Вот. А дальше АИТ каждый
раз выбирается так, чтобы суммарная капасити всех ребер между АИТ и всеми предыдущими было
как можно больше. То есть вот мне нужно взять такую АИ, чтобы сумма капасити всех ребер между АИ и
всеми предыдущими, то есть А1, А2 и так далее, АИ-1, чтобы суммарная капасити была как можно больше.
Вот я выбираю АИ таким образом. Значит, как я это формализую? Ну, давайте я, во-первых, обозначу,
чтобы не очень громоздкая была запись. Я, во-первых, обозначу, что для произвольных подмножеств,
множество вершин, величина, давайте скажем, просто ЦАТБ, это сумма, как обычно, ЦАБ. То есть это как
величина разреза, только величина пары, любой пары множеств. Они обязательно А и Б образуют
разрез, просто любая пара множеств. Тогда Ц это сумма капасити между ними. Вот, ну еще давайте я
буду считать, что АИТ, АИ-1 это множество вершин с первого по Иту. Вот, тогда в качестве АИ я
выбираю такую вершину В, для которой вот такая вот вещь максимальна. Будьте здоровы. Что написано,
да? Арг максимум, то есть выбираю ту вершину, на которой достигается максимум, вот этой величины,
значит, где В у меня пробегает по всем вершинам, кроме уже набранных. АИ-1 это набранные до этого
момента, 1, 2 и так далее, АИ-1. Значит, В любая, кроме вот этих. Ну а здесь написано в точности вот
то, что я здесь словами проговорил. Суммарный вес всех ребер между вершинкой В и всеми уже набранными.
Вот. Ну вот давайте таким странным образом определим нашу последовательность. То есть я
сначала выбираю А1 произвольно, а каждое следующее уже определяю через предыдущее. Ну здесь,
возможно, некая неоднозначность, потому что, возможно, на нескольких вершинах достигается
максимум. Ну не важно, выберем любую из них. То есть если максимум в нескольких точках достигается,
выберем любую из вершин. Вот. Ну тогда, вот если я построил такую перестановку, тогда оказывается,
что разрез, найденный на самом последнем шаге, то есть разрез между последней вершиной и всеми,
кроме нее, это на самом деле минимальный разрез между двумя последними вершинами.
Вот такой забавный факт. Мы его сейчас докажем.
Вот. Ну что здесь утверждается? Смотрите, мы как-то набираем вершинки, мы их как-то
занумировали, А1, А2 и так далее, Аn. Вот давайте посмотрим на две последние. Аn и Аn-1. Вот утверждается,
что когда мы выбирали Аn и смотрели вот эту ситуацию, для i равно n я посмотрю, тогда у меня
здесь находится Аn, а здесь все остальные. Вот оказывается, что вот этот разрез, когда Аn отдельно,
а все остальные в другой доле, вот этот разрез оказывается минимальный, если бы я искал
минимальный разрез между Аn и Аn-1. Между этими двумя вершинками мин разрез, это в точности вот это вот.
Вот. Ну если в это поверить, а мы докажем чуть позже, значит, если в это поверить,
тогда что получается, смотрите. Это значит, что если я построил такую перестановку,
то мне известны две вершины, между которыми я знаю минимальный разрез. То есть перестановка
построена, значит, я знаю, что между двумя вот этими конкретными вершинами я знаю
мин разрез. А значит, можно использовать вот ту идею. То есть я нашел какой-то мин разрез,
либо он уже оптимальный, можно завершиться и печатать ответ, либо их можно склеить и перейти
графу на 0-1 вершине, решать там рекурсивно. Соответственно, алгоритм, ну там не знаю, ans
равно минимум из ans и вот того, что мы, того, что я здесь посчитал, да. Вот. Затем, значит, склеить
an-1 и an, объединив ребра, ну и рекурсивно запуститься на вот этом графе с 1 вершиной.
Рекурсивно запуститься на графе с 1 вершиной. Вот. Ну и так делать пока, скажем, в графе не
останется две вершины. Если в графе всего две вершины, то, наверное, понятно, как выглядит мин
кат, да, минимальный разрез. Ну, это просто вот такое разбиение. Если их всего две, то никак по
другому их разбить нельзя, значит, величина разреза будет просто равна стоимости вот этого ребра.
Ну вот, смотрите, вот давайте в этой картинке я скажу i равно n. Это что значит? Значит, an, ну как бы
вот эта вот величина, которую я мерю, это суммарный вес всех ребер между an и всеми остальными. Вот.
Вот утверждается, что вот в этот момент времени как раз, когда здесь находится одна по себе
an, а здесь все остальные, вот этот разрез тривиальный, когда вот эта сама по себе, а все остальные
отдельно, вот этот разрез будет минимальным между двумя последними. То есть его величина равна
минимальным возможному разрезу между этими двумя. Ну, на две части, да. Нет, ну смотрите,
у меня картинка будет такая просто. Вот одна доля, вот другая. an и an-1 в разных долях,
все вершины разбиты, величина разреза равна сумме вот этих вот ребер просто. У меня все вершины
уже распределены, у меня всего n вершины в графе, я их просто как-то занумеровал. Сначала a1,
потом a2, потом a3 и так далее. На n-ом шаге я все вершины уже исчерпал, поэтому an будет одна
сама по себе, а здесь все остальные. Так, еще вопросы. Хорошо, ну давайте тогда сначала симпточку
посчитаем. Кажется, здесь что-то будет порядка n куба. Ну почему? У меня глубина рекурсии будет n,
потому что на каждом шаге я склеиваю две вершинки, и так делаю n раз, получается,
суммарно. Вот, а дальше мне нужно посчитать, за какое время я вот эту перестановку нахожу.
Ну вот за квадрат, видимо. Как можно эту перестановку за квадрат найти?
Ну вот явно считать, наверное, не получится, потому что вот эта вот штука, если вот это
каждый раз за линию считать, тогда максимум находится за квадрат, не нужно это n раз сделать.
Ну можно оптимизировать, наверное. Ничего не напоминает, кстати, вот эту формулу,
как мы находим очередную вершину. Ну и ладно. Это похоже на dx или на prima, на самом деле,
потому что, ну чего, как в prima, например, мы работали, мы каждый раз выбирали вершину,
из которой ребро во все предыдущие минимально возможно. Среди всех ребер из текущей во все
предыдущие, вот я минимальное ребро выбираю, но должно быть как можно меньше. Тут что-то похоже,
только тут не минимум, а сумма, и максимум берется. То есть я рассматриваю все ребра во все уже
рассмотренные вершинки, суммирую их и нахожу такулы, для которой это максимально. Ну можно
сделать так же, как в prima. Можно просто для каждой вершины v хранить сумму этих ребер в уже полученные,
доставать максимум, ну и обновлять можно тоже легко, потому что когда я очередную вершинку a и
t добавляю вот сюда, то есть добавляю в множество уже изученных, у меня понятно, как изменяются все
величины для остальных вершин. Давайте, как обычно, считать, что d от v это сумма, просто скажу,
c между v и a текущим каким-то, тогда когда у меня очередная вершинка, скажем, a и плюс один
добавляется вот сюда, когда я расширяю мое текущее множество a и t на a плюс первое,
тогда мне нужно просто рассмотреть все ребра, исходящие из a плюс первого, и до вот этих всех
вершин увеличить d, потому что добавились вот такие ребра, значит для этих вершин изменилось d.
Ну то есть если я просто для каждой вершины храню вот эту величину, текущую величину,
разреза между ней и всеми уже рассмотренными, тогда ее легко динамически поддерживать,
просто добавляя очередную вершинку, ну и находить максимум можно за линию,
просто. Вот, тогда как раз будет квадрат суммарно. Так, надо повторить? А? Надо? Шок. Хорошо,
значит еще раз давайте я перепишу. Да, вот пусть d, v это вот такая вот вещь. Я для каждой вершинки,
значит a и это у меня какой-то внешний глобальный счетчик, который вот a1, a2, a3 и так далее a и. Давайте
пусть для каждой вершинки у меня хранится вот это вот. Тогда, чтобы найти на следующем и плюс первом
шаге вот это argmaximum, мне нужно просто взять вершину v с максимальным d от v. Это идет за линию.
Соответственно вот этот шаг у меня будет работать за o от m. Просто нужно пройтись по всем
неиспользованным вершинам и взять максимальное значение d от v. Дальше. Дальше я v добавляю в аи,
в аи плюс первое точнее, у меня появляется новая рассмотренная вершина. И значит вот если раньше у
меня было аи вот таким, то теперь у меня здесь появляется одна новая вершинка, я перехожу к новому
мнению аи плюс первое. Значит тогда мне нужно пересчитать все вот эти d с учетом того, что
вот эта мнение расширилась за счет добавления новой вершинки. Ну для этого я просто рассматриваю все
ребра, исходящие из вот этой вот вершинки, и для всех концов всех этих ребер увеличиваю d. Ну а если они
лежат, то их игнорирую. Ну это неважно, смотрите, у меня может просто для каждой вершины хранится
булистский флаг, взял ее в перестановку или нет. Если я ее взял, то здесь в argmaximum она не учитывается.
Потому что смотрите, у меня перестановка за квадрат находится. Для каждого i я за линию
нахожу argmaximum, за линию обновляю дешки для всех соседей. Итого для каждого i я за линию нахожу
аито. Так делаю n раз, потому что у меня перестановка длины n, значит вот эта часть работает за квадрат.
И так я делаю n раз, потому что у меня рекурсивные спуски в графе на все меньшем числе вершин. Да,
да, да, перестановка за квадрат и на одну вершину уменьшаем. Итак, n раз. Так, хорошо. Вот, отлично.
Теперь давайте доказывать вот это утверждение. Если мы это докажем, то алгоритм получается уже
закончился, потому что мы знаем вот это, значит мы знаем, что он будет корректным. Так, хорошо. Ну,
для этого мне нужно, видимо, будет сначала следующее утверждение. А, не так. Не так.
Я сначала скажу следующее. Пусть s большое, t большое – это какой-то разрез между двумя последними вершинами.
Значит, я хочу показать, что его величина будет больше равна, чем то, что я уже нашел.
Да, я хочу показать, что это минимальное, то есть что это меньше, чем любое другое. Это
моя цель. Давайте фиксирую конкретный разрез st. Так вот, утверждение. Назовем аи активной,
если аи и аи-1 лежат в разных множествах s и t, то есть одно в s, другое в t. Ну, давайте вот так
напишу. Значит, если аи-1 лежит в s, а it в t, или наоборот, а it в s, аi-1 в t. Активная – это если она
и предыдущая в разных долях. Одна в s, другая в t. Так вот, тогда утверждается, что для активной
вершинки а верно будет вот такое неравенство. Да, для активной, для активной аи-t. Если аи-t активна.
Пока давайте просто формально это воспринимать. Да, вот один разрез, вот другой разрез утверждается,
что эта штука не больше, чем вот это. Доказательства. Индукция по активным вершинам.
Давайте рассмотрим первую активную вершину. Вот а1, а2, а3 и так далее. Давайте рассмотрим
первую активную. Что значит первая активная? Это такая, что все предыдущие лежат в другой доле,
а вот она в какой-то новый. То есть это что-то такое. Вот пусть ажитое – это первая активная. Да,
давайте база индукции. Ажитое – это первая активная. Что это значит? Это значит, скажем,
что она лежит в t, а все остальные предыдущие лежат в s. Ну или наоборот. Это в s, а эти в t.
Неважно. Первая активная. Все предыдущие были в одной доле, и вот впервые мы переключились
с одной долей на другую, когда переходим к ажи. Так, ну тогда здесь вроде тривиальное
равенство достигается, потому что что вот здесь написано? Здесь написано суммарный вес всех
рёбер между ажи и всеми предыдущими. Да, это вот то, что написано здесь. А справа что написано?
Справа написано s пересечь с ажи, то есть как раз вот эти вершинки. t пересечь с ажи – это
будет как раз эта одна вершина. Поэтому здесь написано просто сумму всех вот этих рёбер,
а здесь написано величина вот такого разреза. Ну понятно, что поскольку других рёбер нет,
то она же в точности просто равна сумме всех таких ребер. Понятно? Ну вот, база тривиальна,
то есть даже равенство получается. Даже равенство. Чудно. Переход. Пусть аута и аветая
это две последовательно активные вершины. Две последовательно активные вершины.
Что это значит? Значит, ау активно, то есть ау и ау-1 в разных долях. Затем ау-1, ау-2 и так далее,
вплоть до ав-1 будут там же, где ау, потому что они не активны, то есть доля не сменяется. А вот
ав уже сменяется, ав в другой доле. Ну поэтому я давайте вот такую картинку нарисую, большую.
Значит, это у меня будет s пересечь с ав, это t пересечь с ав. Вот эта маленькая, это s пересечь
с ау и t пересечь с ау. Ну тогда я могу нарисовать примерно так, что поскольку у меня все между
ними не активные, с у-1 до в-1, все между ними не активные, значит они там же, где у. Если у у меня,
скажем, вот здесь, то у меня все остальные вот здесь, ау-1 и так далее, ав-1, они все в той же доле,
что и у. Ну а ав где-то вот здесь. Понятно? Ну либо опять же там, возможно, s и t поменены местами,
но это неважно, поскольку у меня граф не ориентированный, s и t у меня можно всегда
менять местами, и я могу считать, не умоляя общности, что ау-t лежит ровно вот здесь, в s.
Ну вот, хорошо, тогда давайте что-нибудь писать. Я хочу оценить сверху вот такую вот величину.
Сначала давайте я ее распишу следующим образом. Я разобью вот это множество на 2 не пересекающих
куска, будет ау-1 и, соответственно, все остальное. Ну могу так сделать, потому что c по определению
линейная функция, если я вот это множество разбиваю на 2 куска, ау-1 и все остальное,
тогда c просто суммут этих вот. Дальше я буду каждый этих слагаемых по отдельности оценивать.
Первое, я могу оценить сверху вот такой вот вещью. Почему? Я поменял v на u вот здесь.
Почему нерависть выполняется? Да, по определению. Потому что ау- это как раз в момент рассмотрения
вот этого множества, ау- это вершина с максимальным вот этим значением, а v когда-то в более позднем
моменте времени выбрано. У нас сначала ау, потом аv, значит для ау достигается максимально возможное
значение вот этой величины. Значена, в частности, больше, чем вот это. Ну давайте подпишу в силу
выбора ау. Так, хорошо. Это простой момент был. Второй момент. Мне нужно доказать, чтобы неравенство
сошлось, чтобы вот это было не больше, чем вот это. Мне хотелось бы, чтобы здесь было написано
следующее. Не больше, чем c, а в это. Нет, нет, нет. А, надо это продолжить. Да, сейчас, надо еще продолжить
и вот здесь по индукции договорить. Надо, я поторопился. Значит, смотрите, можно вот, поскольку ау-
ты активна, то я могу к ней применить предпочтение индукции и записать, что c, ау и ау-1 не больше,
чем cs пересечь с ау-1. Нет, просто ау и t пересечь с ау. Ну а это просто предпочтение индукции.
Так, правда? Правда. Поскольку она предыдущая активна, для нее можно применять предпочтение индукции,
ау. Здесь ау и здесь и здесь. Так, вот, хорошо. Первое слагаемое оценили, теперь я хочу оценить
второе. Чтобы неравенство у меня сошлось, мне нужно, чтобы здесь было написано не больше, чем.
Минус то, что написано здесь. Вот это я хочу.
Потому что, если это будет верно, то у меня как раз после сложения вот эти штуки сократятся,
и останется, что вот эта c-шка не больше, чем вот эта c-шка, а это ровно то, что мне
нужно для индукции. А это ровно вот это утверждение. Так, хорошо. Почему вот это верно? Давайте
перепишу более удобно. Давайте я вот это перенесу сюда. Я хочу доказать следующее. Хочу, что c
аv и аv-1 без ау-1, вот это я сюда переписал, плюс то, что написано здесь с минусом, пересечь с ау,
меньше либо равно, чем вот это вот. Вот это я хочу доказать. Ну вот, а это очевидно,
если на картинку посмотреть просто. Давайте я все вот эти вот вещи здесь нарисую. Вот первое,
это c между аv и множеством аv-1 без ау-1. То есть первая слагаемая, это на самом деле суммарный
вес всех вот этих вот ребер. Между аv и всеми с v-1 по утру. Это суммарный вес вот этих вот ребер.
Это первая слагаемая. Вторая слагаемая, это суммарная величина вот этого разразия между вот этими
долями. То есть суммарная стоимость всех вот этих ребер между вот этими маленькими облачками.
А справа написана суммарная величина вот этого общего разреза. Ну понятно, что одно не больше
чем второе. То есть слева до знака неравенства я посчитал вот эти вот ребра по одному разу и
вот эти ребра по одному разу. А справа у меня вообще все ребра между долями посчитаны по
одному разу. То есть в частности вот здесь вот еще вот эта больше чем вот правая часть неравенства,
больше чем левая, по крайней мере вот на все вот эти вот ребра. Потому что у меня же такие
ребра еще есть в графе. Вот они все не учитываются слева, а справа учитываются. Поэтому правая только
больше чем левая. Ну опять, если все ребра не отрицательны, тогда у меня правая только может
быть больше. Ну и тогда если я вот это доказал, то я вот это доказал. А значит после сложения у
меня вот эти вот товарищи сокращаются и остается, что вот это не больше чем вот это,
что и нужно для индукции. Так, нормально? Кайф. Ну все, значит уже не доказали, а теперь можно
использовать. Зачем оно нам было нужно? Зачем оно нам нужно? Ну оно нужно нам для следующего. Можно
заметить, что аэнная всегда активна, потому что я знаю, что s и t это разрез между вот этими
двумя. Значит аэнная в одной доле, аэносовин в другой. Ну по определению разреза. Они в разных
долях. Значит аэнная точно активна, значит для нее можно написать неравенство. Значит для нее можно
написать неравенство из утверждения. Не больше чем. Но вот здесь, когда я пересекаю s и t с аэнным,
я пересекаю просто со всеми вершинами, значит я ничего не делаю. Поэтому здесь можно пересечения
отбросить и просто написать c, s, t по утверждению. А это то, что нужно. Это ровно то, что нужно.
Потому что у меня s, t разрез между двумя вот этими вот вершинами, значит они точно в разных
долях s и t. А активная это ровно это и значит, что она и предыдущая в разных долях. Все. И раз она
активная, то для нее выполняется утверждение. А значит верен факт про то, что, ну по факту вот это
вот, как раз вот это и значит, что вот этот вот тупой разрез, где все вершины кроме аэнной в
одной доле, аэнная в другой, здесь все кроме нее, вот это самый оптимальный разрез, разделяющий
вот эту и вот эту вершину. Так, вроде все тогда. Так, вопросы можете? Ну хорошо, тогда давайте
перерывчик и потом следующая тема.
Это то, сколько стоит каждая единица потока. Если я передаю по этому каналу столько, ну там,
одну личку водички, тогда эта передача стоит по ступе. Если две лички, два коста, если три
лички, то три коста каждая. А то есть, если я пускаю без потока, тогда у меня там штраф, за это единица будет
без мостов. Вот. Ну и задача следующая. Давайте возьмем кост ка холл. Это найти поток
уничтоженной карты, минимально возможной стоимости. Ну где стоимость, это сумма штрафов по всем
городам. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот
oy
can
harder
buldings
end
gust
ф extensive
그렇죠
clock
Почему к слову? Почему я фиксирую вещество потока?
Если мне нужно сказать максимальный поток минимальных стойностей,
то можно сначала найти максимальное к, то есть максимальную вещество потока,
а потом найти кост к слову, вот в этом как.
Но давайте осмотрим более утонченную задачу, где к фиксируем.
Вот это максимальный кост, а вот какой-то конкретный вещество.
Вот, а в этом будет очень простой.
Ну, давайте сначала я скажу, что делать с обратными ребрами,
потоковую задачу.
Ну, давайте скажем, что если у меня было ребро с параметрами капасик и кост,
то у меня к нему всегда добавляется обратное ребро.
Понятность, мы любим капасик, как всегда.
А вот стойность я делаю просто минус кост.
Ну, и это более-менее соответствует интуитивному пониманию того, что такое обратное ребро.
Это возможность отменить поток текущий по применению ребра.
И значит, скажем, если я слева-направо упустил какой-то поточек
и потратил кост рублей на это, чтобы его отменить, я могу его отменить,
пройдя справа-налево, и тем самым заплатить минус кост,
ну, те самые кост рублей, которые отменили.
А, поэтому, как всегда, обратное ребро позволяет отменять уже текущий поток по данному ребру.
Поэтому здесь твой метод интуитивный.
Вот, теперь у меня задача такая, там есть граф, как всегда с обратными ребрами.
Но теперь уже у меня косты бывают всякие разные.
Даже изначально, если у меня косты были положительные, не отрицательные,
тут уже хочешь-не хочешь, придется работать с отрицательными.
А если я перешлю на круглый кост, у меня знаки бывают всякие разные.
Ну и тут нам придется повозиться.
Понятно, что что-то нужно будет с кратчачьими куфтями делать,
в графах с отрицательными, а не с отрицательными ребрами.
С ребрами отрицательные стоят.
Но, в Англии здесь, тем не менее, весьма простой.
В Англии это работает так.
Я просто, как раз, нахожу в оставшем сети самую дешевую путь из SFD
и пускаю для него единичку потока.
То есть, ну, как бы вот, жадная вещь.
Я буду пускать, вот я кафлово заглю на 5 лучек,
и каждую, каждую единичку потока буду пускать вдоль самого выменного пути.
То есть вдоль того, который дешевле всего с доль.
Из SFD самую дешевую путь, ну, вот в сернах костя.
То есть, я просто найду самую дешевую путь в сернах костя из SFD,
пущу для него единичку потока.
Если перестрою все, я добавлю обратную еду.
Опять, нахожу новый, кратчачий путь, пускаю для него единичку потока,
провожу обратную еду, и так далее, карта.
Да, давайте, так, с моим единичкой пушкой пустить единицу потока
вдоль кратчайшего людей из SFD.
Ну, останутся движения.
Вот это карта.
Такая история будет, если не оптимальна,
то жарный моим дельтритом будет находить правильный объект.
Вот. Ну, а кратчайший путь мы будем как-нибудь искать,
например, Фордом Уэллом.
Потому что у меня здесь бывают отрицательные хосты,
поэтому, наверное, DX-треку умолчания не обойдешься,
раз есть отрицательные стоимости, DX у меня работает отрицательные стоимости.
Ну, можно, например, Фордом Уэллом пустить,
он как раз все это спокойно обрабатывает.
Надо еще обсудить, что делать с отрицательными циклами.
Ну, вот скажем, если их не появляется,
если отрицательный цикл сжевельно крикается,
тогда можно просто на каждый раз искать Фордом Уэллом,
находить кратчайший путь и по нему пускать в дичь.
Вот. Ну, как мы делаем?
Почему вы обратно говорите «брат», или вот так?
Ну, так же, как и раньше.
Потому что...
В чем смысл, да? В чем здесь ноль?
Значит, ноль.
Смысл вот этой «брат» в том,
что мы позволили отменять поток по прямой.
И если, скажем, я вот здесь пустил единичку потока,
тогда по антисимметричности у меня вот здесь в черт минус единичку потока.
Но тогда это значит, что остаточная капаситей этой игры — это один.
Капаситей минус flow — это один.
Это как раз и значит, что я могу единичку отменить.
И только ноль мне как раз таки не свойственно угладать, да,
чтобы капаситей минус минус flow было flow равно.
Поэтому здесь ноль.
Так, ну хорошо.
Давайте двигаться в сторону и показать сроковеренности.
Проверить манну.
То есть для этого мы сначала совершим ретейлизм.
Теперь минимальность потока.
Ретейлизм.
Минимальность.
Стойный поток.
Ну что, пусть.
Ну что?
Ну что?
Ну что, пусть.
Этична потока ровно так.
Тогда, если это ноль костка flow.
Если и только если.
Уже f.
И мне цикл подэффектной стоимости.
Вот.
То есть перед тем, как двигаться к осознанию самолётов,
давайте выведем характеристики внимальности.
Жечь то, что поток минимален в плане стоимости.
Если достаточно сети нет, то обязательно сети.
Если только сети нет, то обязательно сети.
Вот.
Ну, по одному сторону будет очевидно.
Откуда? Куда?
Загадка.
Куда?
А в Ж5 нет пути из СТ?
Нет, нет.
Можете ездить.
Тут никакого посуды.
Слева и правая.
Слева и права очевидно,
потому что если лезвый кост,
ну, в Жf есть отрицатель цикла,
то можно просто вдоль этого цикла
прибавить единичку потока
и получить поток меньше и меньше стоимости.
Значит, если в Жf есть отрицатель цикла,
то вдоль него можно пустить единицу потока.
Значит, тогда величина потока не изменится.
Ну, потому что я просто добавил единый замок
по маршруту, он не влияет на величину потока.
Вот, но при этом стоимость уменьшится.
Поличнее.
Поличнее.
Ну, если есть циклы,
то можно по ним пустить поток,
но меньше стоимости.
А что на твоей фиге?
О, извини, Сергей.
Вот, ну здесь справа налево.
Жаль, что верный обратно.
Если нет циклов, то обязательно понимать.
Ну, давайте верно противного пойдем.
Да, вот эти переходы,
дарный, очевидный.
Давай.
А что нам мешает?
На самом деле, мы не обязаны.
Потому что в определении потока у нас есть просто три свойства.
Непривышение капазити,
антимитричность хранения потока.
В частности, там не в нигде ограничения,
что там потом должен быть функция связи
или что-то такое.
А, даже если у вас есть одна нинчика потока вдоль пути,
и висящий будет цикл,
это корректный подход.
Главное, что выполняешь все свойства.
То есть связи не произойдут.
Так, ну теперь обратно.
В обратную сторону давайте вход противного.
Пойдем.
Значит, пусть уже вверх и нет интересных циклов.
Но при этом f не минимальный.
Давайте скажем тогда,
это где звездочка, понимаете?
Значит, f звездочка,
это непоскорпорный.
У нас, соответственно, его стоимость,
строго меньшим, стоимость f.
Возьмем какое-то
настоящее внимание.
Давайте я поделим следующее.
Давайте скажем,
g,
это звездочка, не в секс.
Просто давайте формально,
лучше в один поток из другого.
Ну, то есть для каждого,
для каждого, для каждого,
ну то есть для каждого и правда,
я скажу, что увеличена потока
g на этой игре равна разности
в этих двух ключах.
А на этой игре g неожиданно,
это разность звездочки и f.
Я утверждаю, что это,
во-первых, поток,
во-вторых, поток влеченой.
Давайте это
поймем, что это так.
Ну, надо уточнить,
не а вы где, а g.
Это важно.
Не вышкодом драть,
а именно в остатке 10 g.
Ну, почему? Что происходит в этом потоке?
Надо просто присвоиться, доверите?
Значит,
первое, что в этом потоке не большим
компасити. Ну, я знаю,
что g и f, это разность
f звездочки и f.
Дальше, я знаю, что f звездочки не большими
целки и f.
Но это в точности остатчная компаси.
Я живу в графе g и f
в остатчной сети.
Здесь у меня остатчная компаси
ровно вот такая, c-f,
что значит g не больше, чем остатчная компаси.
Дальше, вот дальше, ребята, дальше
антисимметричность, очевидно,
если у вас f звездочки антисимметричны,
то это разность f звездочки антисимметричны.
Да, ну, хорошо.
g в q в
равно f звездочки в q в r
минус f в q в r.
Дальше, если я меня
местами u и v, то у меня выносится минус
за знак потока
антисимметричности потока.
Здесь написано, минус f звездочки
v u
плюс f v u.
Ну, и это в точности
минус zhu v u.
Так, ну и третье
сохранение.
Сохранение тоже давайте даже бесспорно надышу.
Значит, идея, смотрите какая.
question
...
...
...
...
...
...
...
...
...
...
...
...
Ну или формально просто, что мне нужно, мне нужно чтобы сумма вот этих вот всех потоков была нулика, точнее сумма вот этих, равнял сумму вот этих. Ходячка равна исходячку.
Ну я знаю, что для редзвездочка это так, и для этого это так. То есть если я хочу что-то из любого, то для радости что-то я не буду делать.
Сохранение тоже. Сохранение потока тоже, например.
Ну все, начнем с потока. В оставшемся теже.
Почему она лишь не ноль?
Ну понятно, что у меня есть два потока дельчинка, каждая. Я один с дельчинками встаю, и конечно ноль должен получиться.
Да, в общем, потому что поток, поскольку есть какая-нибудь старта, я знаю, что здесь я не толокаю старта, и здесь я не толокаю старта, если одно из двух будет, чтобы как раз ноль остался.
Поэтому то поток дельчинной ноль вознашивает.
Чудесно.
Но что такое поток дельчинной ноль?
Мы с вами помним лему о декомозиции потока.
Если есть некий поток, то он всегда предстоит в виде суммы нескольких путей из st и нескольких циклов.
Но поскольку здесь у меня поток дельчинной ноль, то g просто нескольких циклов.
Они не одного пути, потому что каждый путь это плюс один поток.
Значит, просто нескольких циклов.
Нескольких циклов по старшему теже.
Ну, кстати говоря, что можно сказать про стоимость этого потока?
По старшему теже.
Плюс, понятно, что просто из-за единения с ним, стоимость этого звёздочного минуты превратится.
Потому что на каждом дельче у меня стоимость...
Ну, как раз это будет считаться.
А это не считается.
Потому что это будет нежелательно.
Вот. Получается, что...
Получается, что это какой-то поток дельчины ноль отрицательной стоимости.
То есть, получается, у меня в шее отрыв...
Выбираем несколько циклов.
По ним дельчинная единица потока, ну...
Считается, не важно, несколько циклов, суммарная стоимость меньше нуля.
Ну, значит, в частности, есть такой деканулетор меньше нуля.
В противоречии с тем, что уже в некую церковь.
Да, давайте обещаем.
Значит, уже в 10-11 церкови.
В противоречии.
Стоимость.
Так.
Да-да.
Ну хорошо, значит, мы показали наши смятения.
И мы поняли, что минимальная стоимость потока достигается ровно тогда.
Когда в остаточной сети нет циклов дельчатин.
Ну хорошо, тогда чтобы наш алгоритм работал в этом, в общем, здоровом, алгоритм такой
Просто выпускаем каждый раз только в чаще, в нижнюю потоку
Мне нужно доказать, что если изначально не было отрицательных циклов, то их никогда не будет появляться
Потому что минимальность, то же самое, что отсутствует из этих циклов
Мне нужно показать, что если изначально поток был минимален, если изначально нет циклов отрицательных
То каждый раз после пускания в нижнюю потоку кит не появляется
Ну вот давайте покажем
Подожди
Пусти
Уже?
Нет
Ааа, опять пускай лодку
Пусть п, а чаще пути засыпляли
Соответственно пусть есть поток в нижней 1 доль в том числе
Пусть есть
Поток в нижней 1
Доль в этом
Тогда в остаточной сети позже нету циклов отрицательных
Вот
Вот, но этот движение как раз будет нам означать, что если мы пускаем поток в только чаще пути
То если он изначально был минимален, да, минимальность отрицательных циклов на предыдущем шаге
То и дальше будет минимален, потому что отрицательных циклов не появляется
Значит каждый минуток будет минимален, так как на каждом шаге будет продолжать быть минимален
Отсюда будет немедленно все предкорректировать
Так, вот эта задача вроде тоже будет сложная
Давайте, ребята, потихоньку пойдем
Давайте скажем, что пусть какой-то С
Это циклон F
Вот так
Так, вот так
Да
Вот так
Вот так
Значит, теперь посмотрите, что в основном есть
Есть, есть, есть, есть, есть, есть путь
И есть еще один цикл C
Где-то он там, не знаю
Вот как-то так вот выглядит
На нем тоже 1
Ну, давайте считать, что на нем 1 поток
Тогда давайте сложим
Так же просто чисто арифитически сложим W3C
То есть на каждом репелленте пишем поток равный сумме P и C
Тогда я скажу, что в сумме это тоже будет поток
В исходном нашем графе уже
Мы решили 1
Ну, понятно, потому что мы решили 1
И при этом его стоимость будет меньше, чем стоимость P
Отдайте, очевидно, потому что
Стоимость C отрицательна
Значит, их сумма вместе меньше, чем стоимость P
Ну, а это бред, потому что, смотрите
Потому что P, а это что?
Это был кратчайший путь из СС
То есть по факту F это
Ну, поток вычисления 1
Долька кратчайшего пути
А P плюс С, это только кратчайший путь из СС
Долька кратчайшего пути
А P плюс С, вот другой поток
Вычисления 1, еще более дешевый
То есть у меня есть вот этот вот
Доль самого дешевого пути
А есть какой-то еще более дешевый
Ну, как он может выглядеть?
А это все равно какой-то путь
Точнее, поток вдоль какого-то пути
И еще, может, какие-то циклы
Но поскольку все циклы не отрицательные
Значит, стоимость здесь может быть только больше
Потому что еще и путь не кратчайший
Да, сейчас я повторюсь
Значит, смотрите, вот с этим можно согласиться?
Пока что нет
Пока что нет, хорошо
Значит, смотрите
P плюс С, это просто чисто ритмически
Также я на каждом любе складываю
Поток вдоль пути
Плюс путь кратчайшего пути
Давайте перейдем к тому, что будет поток в G
Ну, давайте как-то трогать
Давайте тоже так на звуку, если будет G мальча
А, ну нет, как?
А, хорошо
Ну, кстати, путь он не кратчайший
Да, и не кратчайший путь
Еще раз, знаете, P плюс С
Также ритмически можно проявить, что этот поток в G ниже
Это О?
Да
Вот, дальше понять, что его стоимость меньше
Стоимость P
Потому что она отличается на
Плюс по С, но она отличается
Потому что С отличается
Сейчас тоже есть
Тогда давайте рассчитаем на звуку
Пусть это будет там G мальча
Значит, это будет поток
В G
В G
Давайте мы нарисуем
Я знаю, что такое поток в G один
Это путь и несколько циклов
Кстати, по линии ригмпозиции
Если у меня поток в G один, то это один путь
И несколько металлических циклов
Давайте вот здесь
Это какой-то путь
И какие-то циклы
Зачем они не мальча?
И какие-то циклы
Ну, это все происходит в исходном графике
Тогда, что здесь со стоимостью?
Смотрите, все циклы не отрицательные
По предположению
А, потому что G нет
Значит, все циклы не отрицательные
Ну, и П штрих
Это какой-то путь
Вес которого, понятно, делает
Больше равен, чем вес П
Потому что П это кратчайшая
По штриху какой?
Значит, стоимость П штриха
Больше равна, чем стоимость П
Потому что это кратчайшая
Это какое?
Ну, все, противоречие
Потому что суммальная стоимость G тогда
Получается, хотя бы у нас П
Плюс еще столько не отрицательных дольцев
Но при этом это меньше, чем П
Противоречие
Противоречие
Противоречие вот с этим
То есть, штрих это любой путь?
Ну, не любой
А тот, который получается при складывании
В какой-то путь
Значит, в частности
Более дорогой, чем самый короткий
Так
Считаю, что доказал
Нормально?
Вот так вот
Все, суммольное
Что отрицательных циклов не появляется
Если пускать какой-то кратчайший путь
Значит, отсюда
Сразу следует корректность
Нашего исходного алгоритма
Что если в исходном графе
В самом первом же
Нету отрицательных циклов
Нет циклов отрицательного веса
Просто кара спускает в фордегалонах
Пускай там одни чехол
Циклы с ним появляются отрицательными
Значит, на каждом шаге будут вот так минимальные
А на отрицательных циклах
Вызывает с учетом подошвы?
Нет
Только
Вес цикла
Только с точки зрения
Сольности
Ну да
На каждом шаге
Какая-то стоимость
Она не лучшая
Ну, смотрите еще раз
Вот у вас есть исход, игра в G
Давайте для простыды
Все кости положительные
Изначально понятно
Все стоимости положительные
А понятно, что циклов с задних нет
Но потом, когда вы пускаете по очереди
У вас появляются обратные ребра
Да?
И на них отрицательные косты
Появились отрицательные ребра
Потенциально они возили с задних циклов
Вот я доказываю, что такого не бывает
Хотя отрицательные ребра и появляются
Но циклов не появляются
А значит, на каждом шаге
Потом понимают
Вот
Хорошо
Если
Если в исходном G нет
В исходном G
Не было
Отрицательных циклов
То отрицательные косты
Так, ну
Пасим с точки
На питотика
Можно писать таков
Можно в G
Потому что
У меня так раз
Сидит в фордону
А фордон как раз в стоке работает
Вот это в нейми реализация
На, если просто так раз
Сидит в фордон
Теперь давайте обсудим
Как это можно
Оптимизировать
Значит
Оказывается, что
Можно перед образом использовать
Дэйвстрок
Если хитренько
Что-то в этом графе поменим
А именно
Давайте рассмотрим
Пенсионалы дросс
Возможно, на семинарах это рассмотрим
Значит, смотрите
Моя цель сейчас
Это избавиться вот вот
Вот этого вот большого множителя
И свести его к дэйвстру
Мы помним, что
Дэйвстр работает в идеальной реализации
За делу G
А если начать с пучки
Работает за делу G, чтобы сильно лучше
Я хочу двигаться в сторону
Оптимизации фордону
За дэйвстр
Что я для этого сделаю?
Давайте просто
Я скажу, что в каждой вершине
Написано какое-то число
Какое-то целое число
И тогда
Измененная функция
Весовая функция кост
С учетом вот этого потенциала
Будет вести себя так
Это изначальная
Стоимость гибра
Плюс потенциал начала
Минус потенциал конца
Я думаю, будет верно
Формально
Во всех вершинах написано
Какие-то числа
И стоимость гибр
Изменены в соответствии с этим правилом
Каждый гибр увеличивается
Что хорошего в таком преобразовании
Как минимум следующее
Такое преобразование
Сохраняет
Кратчайший путь
В следующем смысле
Я скажу про измольный путь
В исходной весовой функции
Кост
Или новая обновленная кост
Там стоимость потенциала
У меня
Стоимость пути предсказуемо поменяется
Если изначально была такая сумма
Стоимость всех этих преобразований
То дальше как она поменяется
При переходе к потенциальным функциям
Добавится все отец, вышлится вот это
Добавится вот это, вышлится вот это
Поэтому все промежущие
У меня будут цена плюс-минус
Поэтому они как бы попору
Там потенциалы промежущие
Не учитываются
И получается, что суммарный вес
Этого пути изменится
Плюс все отец, плюс все отец
Если всего это большой путь P
То новая стоимость
Пути P
Это старая его стоимость
Плюс все отец, плюс все отец
Вне зависимости от того
Вне зависимости от того
Какие конкретно промежуточные вершины он насыщает
Потому что все промежуточные сокращаются
Согратятся
В частности это означает
Что какие пути изначально
Были кратчайшими
До перехода к потенциальным функциям
Какие пути были кратчайшими, такие остаются
Ну и наоборот, какие стали такие
У меня все пути вместо вот ftr
Изменились на константу
Значит чтобы
Но минимизирую одно, я не минимизирую другое
Давай
Идеальная такая
Давайте попробуем ввести
Такую констанционную систему
Так выводит это
Поставление в вершину чисел
Чтобы новая весовая функция
Была у себя не отрицательна
Это моя мечта
Сделать, чтобы всегда все по фигу не отрицательны
Если кости фиг все не отрицательны
Тогда можно было
На вот этом графе
Измененной, обновленной весовой функции
Пускать dx
Ну а поскольку у меня кратчайшими
Пути не изменились
То dx я бы нашел те же самые
Пути в исходном графе
То есть то, что мы делаем dx
Было бы тем, что нашел в исходном графе
А dx лучше и быстрее
Поэтому ее используем в реакции
Вот
Давайте это сделаем
Мне нужна какая-то такая
Потенциальная функция phi
Я которую выполняю
С этой границей
Чтобы всегда не отрицательны
То есть значит, что подойдет следующее
Давайте просто возьмем
И потенциально отрицаю
А проделим вот так
Дист и страх
Ну, дист в терминах
Исходные стоимость на функции course
То есть у меня будет граф
В начале же
Там были своими стремностями
Давайте посчитаем
Простояние от S$
Ну, как посчитаем
Видим с помощью форда Беллона
Все-таки один раз в год
Их не придется
Вот я один раз запущу форда Беллона
Дист и страх
Посчитаю все расстояния
Вот этого всех решения
Положу phi of V равным этому расстоянию
А дальше
Если я ввел такую
потенциальную функцию
То я отрицаю, что когда автоматически
Все обновленные стоимости будут не отрицательны
Вот почему я это делаю
Что такое
Коску вверх
Плюс phi of U
А мне нужно, чтобы больше phi of V
А вот если это вверх
То все обновленные стоимости будут не отрицательны
Ну понятно, почувствую phi of V
Это кратчайшее расстояние от S$
А что написано слева
Это кратчайшее от S$
Плюс phi of S$
Ну тогда понятно, что
Оптимальная, самая короткая
Стояние от S$
Слева написано потом в путь
Сначала от S$
И потом плюс phi of U
А справа написано как-то
Самый короткий от S$
Значит это вверх
Мораль такая, что
Если у меня потенциальная функция
Совтадает с функцией расстояния
То обновленные
Стояния всегда не отрицательны
То есть из этого
Следует, что
Сюда не отрицательны
Мы считаем, что у нас к вам граждан
Не было отрицательных
Да
Ну, собственно, у меня и вот этот инженер
Работает только в предположенном состоянии
Что где-то есть
Упражнение 17
А в последнем у нас записано
Кост phi
Да, кост phi
Кост УВ
А, просто кост
Да, просто кост, phi, phi, phi
А Дист СВ это
В терминах стоимость
Да
Давайте подишем терминку
Так же
Ну, хорошо
Значит, тогда
Как будет устроено дарение?
Сначала, ну, если я все-таки хочу
Использовать потенциалы, то мне сначала
Нужно будет впустить хотя бы раздольчик
Который добавлен, чтобы найти вот эту функцию
Давайте его запущу, найдет все потенциалы
Тогда, что после этого
Происходит?
После этого я перехожу
К обновленной сети, где уже все
Стоимости не отрицательны
Стоимости не отрицательны
Тогда понятно, что
Кращевший курс ЗСФ
Он на самом деле
Будет идти по ребраму
Строго нулевого веса
Все ребра на этой пути будут иметь
Строго нулевой вес
Терминах новой весовой зоны
Ну, почему?
Потому что phi это просто
И они идти
Вот на этом прочахе пути
На настоящем прочахе пути
ЗСФ
Я на каждом ремне написал
Стоимость, плюс расстояние до начала
И минус расстояние до конца
Потому что потенциалы в этих точках
Отличаются на месте этого ребра
И я здесь отставал вес и минус
Разный потенциал
Поэтому все обновленные стоимости
Будут на этом где отрицательны
Значит, что? Ну, окей
Вот у меня сегодня будет ЗСФ
У меня есть ЗСФ
Потому что все ребра нулевого веса
Когда я протягиваю дичьку потока
У меня возникает обратные ребра
Но на них тоже получается нулевой
Нулевать
Потому что у меня всегда кости
Минус кость получается
Значит, в этом графе
Эти серебра тоже имеют нулевой кост
Ну, нулевую в стоимости
В терминах новой
Потому что если я пустил дичьку потока
на другого ребра
Появилась обратная тоже в стоимости
Вот
Ну, и там возможно какие-то из этих пропали
Потому что они нашитились
Какие-то из ребров с левого права могли пропасть
Но при этом пока что отрицательных фермеров
Не появились
Но зато у меня
Возможно, могло сломаться эту тарабища
Потому что граф как-то поменялся
Если бы я не добавил фермеров
Возможно, вот эта тарабища бы нарушилась
Но граф по-прежнему
Не отрицательный
Поэтому
Чтобы пересчитать
Чтобы обновить
Чтобы вот эта возраста сохранялась
Я могу уже дейсты пускать
Поскольку у меня серебра не отрицательная
Вместо того чтобы еще раз считать потенциалы
Я могу здесь пустить дейсту
И пересчитать потенциалы уже по дейсту
И после этого будет выполняться это свойство
И значит можно будет еще и еще раз
Пускать поток
Пускать поток, пока что не будет
Ну, давайте, во-первых, запишу какую-то процедуру
И будет
Применить потенциалы с ним
Да, но это просто вот это преобразование
Что я доказываю ребра
Его вес
Его вес
Кибу вверх
И изменяю на потенциал начало
И потенциал конца
И это министерная
Вот
А дальше, как у меня тут работа по коридору
Я сначала один раз
Запускаю форда Белман
Из точки с
Применяю этот потенциал
То есть я не веду, что
Форда Белман вовершает мне
Список расстояния
Список расстояния
Дальше я ему применяю
Как потенциал
То есть я считаю, что потенциал равен расстоянию
Поменял все стоимости всех ребер
С помощью этой процедуры
А дальше у вас только раз будут стоящие
Вот так
Ну, мне сложно сделать
Нужно пустить днику потока
Вдоль пути нулевого веса
Вот я так и так и так и решу
Пусти
Днику потока
Вдоль
Пути
Вдоль
Вот, ну, там
Например, можно сохранить было вот здесь
Потому что я же только что пустил форда Белмана
Я только что ушел пустить эти пути
И так можно было бы сохранить
Как выглядят все конкретные пути
Вот вдоль вот этой пустить днику потока
То есть я пускаю поток
У меня возникают обратные ребра
Вот
Призникают
Обратные
Ребра
Ну, а дальше просто беру
Считаю номер потенциала с помощью DX
И применяю его
Вот, я буквально сделал
То, что я сказал
А я сначала перешел к новой
Стоимость этой функции
И я считаю, что все косты теперь мне не отрицают
Вот в этот момент все косты не отрицают
Дальше
Я должен буду пускать по единичке потока
Вдоль кратчайших пути из SVT
Посмотрите, поскольку
Я сюда захожу
Либо после вот этого форда Белмана, либо после вот этого Dexter
Ну, значит, к этому моменту
Я вот только что посчитал все кратчайшие состояния в графе
Значит, я знаю кратчайший путь из SVT
Я по нему могу пустить днику потока
Я пускаю поток
Граф перестроился
Но в нем все еще
Все стоимости не отрицательны
Ну, например, нарушиваются
Ну, хорошо, а давайте пущу Dexter
Поскольку все стоимости не отрицательны
Я могу его пускать
Я пущу Dexter, посчитал саму функцию
Опять-таки, да, посчитал все состояния
И применил ее, чтобы опять
То есть я опять пересчитал все стоимости
Так, чтобы
Ну, то есть с учетом такого потенциала
А значит, когда все опять все стоимости не отрицательны
Я могу опять пускать поток
Дольни волны
То есть вы пускаете поток
И потом пропишешься
И работаем сразу с функцией, да?
Ну, конечно, да, конечно
Вот
Ну, учетом асинтозика давайте ставим
Скорее всего это не понятно
Асинтозика
Ну, как раз Dexter
С Fordown мы работаем за V&E
А Dexter, ну, если заморочится
И, кстати, мы начнем пущу, то
Делаем V&E
Понятно, это у Ксилия лучше, чем KV&E
Что было исходно в Fordown
Не, ну почему?
Сколько у нас работает?
А, я финиш сказал
Это как-то без финиш
Это с бинарной пущей
Вот, если заморочится
Другую выводую
Если заморочится
Другую выводую
Но даже без V&E все равно получается хорошей
Ну, вот на этом все, спасибо
