Смотрите, сегодня мы с вами поговорим про основу теории графов, поговорим немножко про
BFS. Теперь мы переходим к большому такому блоку, связанных с графами. Все, что у вас будет дальше,
это будет все связано с графами. Единственное исключение будет это сегодня, если мы успеем
все-таки вернуться к амортизационному анализу, но это не точно, потому что на прошлой лекции мы не
успели это все-таки сделать. Попробуем совместить сейчас, хотя, может быть, вы видели у Булата,
но мы рассмотрим какие-нибудь основные быстрые вещи и поймем, как это все работает. Вот, как-то
так. Давайте начнем говорить теперь про графы. Что вы знаете про графы? Так,
что вы знаете про графы? Да, по сути своей правды. Нужно просто понимать, как их теперь хранить
внутри нашего компьютера. Да, для нас граф это будет пара множеств, множество вершин, множество
ребер, и у нас могут быть ориентированные графы, могут быть неориентированные графы. В зависимости
от этого, как бы, можно по-разному на них смотреть и смотреть на то, какие у нас есть ребра, каких
ребер нет и так далее. Вот. Вроде бы ничего сложного, я надеюсь, вы все это прекрасно и так осознаете.
Иначе бы очень странно, что вы были бы во втором семестре. Но ладно. Мульти графы. Есть мульти
ор графы, есть мульти псевдографы. Это тоже, по-моему, достаточно понятно. Правда? Мульти множества,
когда у нас есть множество ребер, мульти множество, это даже называется, что оно может повторяться.
Вот. Да. Мульти графы, да. Ну здесь, здесь в одну и ту же сторону. Вот, то есть у нас
один в два. Вот два ребра есть одинаковых. Что еще раз? Да, это по сути не простой граф. Мульти граф,
когда у нас есть повторяющиеся ребра. Это нам нужно, это нам важно будет дальше, а по одной простой
причине, потому что, ну грубо говоря, представьте, у этих ребер будут разные веса. Когда мы начнем
делать веса у ребер, нам нужно это оценивать корректно. Понятно? Вот. Такое возможно. Что же тут
поделать? Ну псевдограф, ну как бы, все то же самое понятно. Вот. Просто будет неориентированно.
Степень вершины. Вам, я надеюсь, знакомы, что это число просто инцидентных ребер. Полустепень
исхода и полустепень захода вершины тоже понятно. То, что входит, то, что выходит в любую вершину. Да.
Степень вершины связан с данной вершиной. Вот. Ну как бы, основное утверждение, что у нас сумма всех
степеней вершин в неориентированных графах – это двое. Ну а в ориентированных графах мы знаем,
что у нас сумма входящих равна сумма исходящих ребер, и это равно просто сумме ребер. Ну,
количеству ребер. Вроде бы не должно быть сложно. Если что, останавливайте, спрашивайте.
А дополнительное определение связанное с тем, что такое путь. Путь у нас просто это последовательные
вершины ребер, где каждый реброс соединяет соседние вершины в последовательность. То есть,
мы можем выстроить какую-то последовательную, вот вам будет путь. Простой путь – это где у нас не
будет повторяющихся вершин, а цикл – это какой-то замкнутый путь, где начало совпадает с концом.
Всё понятно, всё достаточно просто. Здесь должно быть. Вот теперь переходим к чему-то более
такому содержательному, нематематическому, содержательному беда. Вот. Будем смотреть,
как мы можем хранить графы в памяти компьютера, какие есть способы и что мы будем делать.
Первое – предположим, что у нас есть вершина. В вершина мы будем давать номера. Номера от нуля
до v-1. Всё понятно, всё просто. Дальше, для того, чтобы нам было легче писать и легче на всё это
смотреть, вместо модуля v и модуля e, то есть вместо множества, сколько там находится, мы будем
просто писать v и e. А там в оценках графов и так далее, в оценке времени работы. Поэтому здесь
всё будет понятно, что это будет там число. Я не буду это писать прямо постоянно. Поэтому,
если вдруг увидите такую ошибку, знаете, это не ошибка. Просто иногда лень писать. Всё просто.
V множество, а модуль v – это мощность множества. Ну да. Ну, не знаю, вот вы взяли граф на
пяти вершинах. Вот 5 вершин, число 5 – это у вас как раз-таки мощность вашего множества. А как
эти 5 вершин вы обозначаете буквами, цифрами, как хотите. Вот. Это само множество составит.
В нём будет 5 элементов. Да. Мы смотрим только на конечные. Мы приводим это в реальную жизнь. В
реальной жизни я не видел бесконечных. Вот. Есть такая вот проблемка. Поэтому да, конечные именно.
Окей. Первый самый простой способ хранить наш граф – это можно просто представить его списком
ребер. У нас будут номера вершин. Мы знаем, что там вершин какое-то количество v. Значит,
если я представлю весь список ребер, согласны ли вы, что он задаёт мой граф единственным способом?
Существуют точки. Я знаю все точки. Ещё раз. У меня не только список ребер есть. У меня есть
ещё номера всех вершин. Ещё. Согласны. Всё-таки. Хорошо. Вот. Это самый простой, самый первый способ,
как нам сохранить вообще граф с помощью списка ребер. Но в этом случае у меня вопросы к вам.
Сколько памяти будет задействовано? Сколько? Квадрат чего? Нет. Ответ неважно. Ну,
ещё раз. У меня есть v и есть e. Ограничение буквками вот этими поставьте. E. Ну,
как бы список ребер, логично, что e. Кто такое сказал? Ну, хорошо, если мульти. А ещё,
если у меня разреженный граф, то это будет o от n скорее. Я должен ограничивать всё-таки
минимальным таким числом. Вот. Окей. Память понятна. Обход всех ребер за сколько будет? Обход.
Но мне надо просто пройтись по ребрам. Обход всех ребер подразумевается, что я могу просмотреть все
ребра и выбрать нужное мне. За e. Ну, я просто пройдусь по всем ребрам. А поиск ребра? Тоже за
e. А получение соседней вершины? Вот у меня есть какая-нибудь вершинка v. Я хочу найти вершинку,
которая является его соседом. E. Хорошо. Окей. Да, а всё это связано с тем, что ну как у нас хранится
вообще вот этот весь список ребер. Можно ли как-то улучшить список ребер? Нет, давайте ещё раз,
просто список ребер. Я хочу оставить список ребер. Вот у вас есть вот такой список. Можно ли
что-нибудь с ним придумать такое, чтобы было полегче в некоторых вещах? Можно хранить как-то.
Что-то сложное, давайте проще. Отсортировать. Если мы лексикографически вот это всё отсортируем,
что у нас будет происходить с поиском ребер и получение соседних вершин? Можно использовать
это самое важное здесь. Да, если мы отсортировываем их вот грубо говоря по началу нашего, ну откуда
грубо говоря идёт ребро, то в этом случае мы можем спокойно бинпоиском найти необходимые нам
соседей. Логично? Логично. Для ориентированного графа. Вот. За логарифм всё просто. В середину
смотрим, дальше влево-вправо. А получение соседних вершин за сколько?
Вот у меня есть вершинка В. Я хочу найти соседей. Е? Не е.
Логарифм, но не совсем. И не е. Давайте все остальные тоже. В целом. Мы храним список ребер.
Это перебор. Е квадрат прям перебор здесь будет. Давайте ещё.
Лог Е плюс В. Почти. Почти получилось. Смотрите. Ну ещё раз. Вот у меня есть вот мой
список ребер. Я с помощью бинпоиска согласна, что могу найти вот где начинается мое В. И где
заканчивается мое В. Ну как бы бинпоиском это находится. Это будет логарифм от количества
моих ребер. Да? Сколько вот этого вот? Так. Подождите. Праздники ещё не наступили. Вот сейчас
лекция будет, потом будут праздники. Давайте. Сколько у нас может быть? Ну то есть смотрите,
мне нужно вывести всех соседей. Сколько у меня здесь может быть? В чём максимум? Точное число.
Вот мы вводили с вами В, Е. Были ещё какие-то вещи. Степени вершины были. Что я должен прибавить?
Понятно откуда это произошло. То есть ещё раз. Это все вершины, которые имеют начало В. Всё. Вот.
Это достаточно просто и понятно. Отчего? Мне нужно вывести всех соседей. Ну тут один.
Два. Ой, Н. Ну у тебя есть все. Подожди. Ещё раз. Я хочу соседей, куда я могу прийти. Вот. А, хорошо.
Извините. Всё. Я понял. Да. Соседи. Соседние вершины мне считаются именно те, куда мы можем прийти.
Да. Вот это? Нет. Почему? Кто тебе такое сказал? Да. Подожди. Больше, чем ребер или больше,
чем лог, Е. На всякий случай для всех остальных. Вот моя солнышко. Тут логарифм. А? Кто такое сказал?
Чего? А, ну в этом плане, конечно, да. Ограничено всё Е квадрат. Ну нет. Давайте мыслить максимально
ближайшим числом, которое нам необходимо. Давайте не рассуждать. В пространство уходить. Всё работает
с бесконечностью. Зачем нам всё это изучать? Ну нет. Давайте не будем таким образом делать.
Мы будем смотреть вот эту верхнюю границу почти точно и пытаться её оценить. Окей? Вот. Да.
Откуда Е лог Е? Откуда вы это берёте? Подождите. Я сейчас свернусь в первый семестер. Откуда Е лог Е?
А, в этом плане. Нет. Мы сразу хранить их будем сортированными в списке и предположим,
что это был предподсчёт. Вот. То есть вот та сортировка это был предподсчёт. У вас всегда в
задачах, у вас почти никогда не будет добавления чего-то. Вам будет дан сначала граф. Вы его
считываете, вы его обрабатываете, а после этого отвечаете на запросы. Вот. Поэтому это считайте
предподсчётом таким. Ещё вопросы? Вот. Сейчас. Почему? Хорошо. Ещё раз. У вас может быть граф,
какой-то там, не знаю, в котором Е и в котором В. Вы отсортировали за Е лог Е, да? А потом вам
приходит Е квадрат запросов на то для конкретных там вершин. Вы с таким и столкнетесь. Ну либо всё
просто. Ну, Е квадрат запросов, В квадрат даже запросов, это тоже будет сильно больше, потому что
возможно такое, что у вас, не знаю, вот у вас есть какой-нибудь граф, и когда вы соединяете там
вот примерно вот так, у вас Е примерно В, у вас граф представляется разреженным. То есть у вас не
полный граф, не почти полный граф, ничего такого. Вот. В квадрат запросов почему бы не сделать?
Повторяющихся. К вам приходят пользователи гуглят одно и то же, к примеру. Ну типа, ну да,
вот этот человек там гуглит какое-нибудь аниме, этот гуглит то же самое, и другой человек такое же
аниме смотрит. Ну извините, такова жизнь. Вот. Ну или все вы хотите купить билеты, не знаю, на
Дюну-2, к примеру. Позже же гуглите, гуглите. Вот. Так что как-то так. Второй вариант, то, что там сказали
уже про табличку, это называется матрица смежности. Заводится таблица В на В, где в ячейке Иты-Житы будет
хранится метка наличия или отсутствие ребра. Либо количество ребер, либо вес этих ребер. До весов
мы попозже дойдем. Вот. И в этой таблике очень легко смотреть, соединено Ита или Житое ребро. По памяти
это, естественно, занимает сразу В квадрат. Вот. А что касается обхода всех ребер, поиск
ребра и получение соседних вершин? Обход В квадрат. Так, поиск. Откуда получился лог-квадрат?
В ячейке Иты-Житы лежит есть ребро или нет ребра? Ну да. А что ты подразумевала тогда под табличкой?
Откуда получился квадрат, я тогда пока не понял. Ладно. Хорошо. В действительности, да. В этой
таблице достаточно просто смотреть, есть ребро или нет ребра. Мы можем пойти с Иты-Житой в ячейку
и посмотреть, есть там нолик, нет там нолика, есть единичка, нет единички. В зависимости от этого дать
какой-то ответ. Есть ребро между ними или нет. И значит, что у нас все будет связано. Вот здесь
вот написано о матрице смежности для ориентированного графа. Как вы думаете,
какой матрицей смежности должен быть для неориентированного графа? Нет. Симметричный.
Для неориентированного графа она всегда... А? У вас все равно в квадрат памяти. Ну да,
если вы там будете рассчитывать, чтобы вам в два раза скостить, и вам выглядело хорошо,
то да. Но этого почти никогда не произойдет. Я больше того скажу, что матрицы смежности и
списком ребер вы будете крайне редко пользоваться. Да. Сегодня очень интересные вопросы, я скажу.
Хорошо. А получение соседей вершины за сколько будет? У от чего? В. Почему В? Да. То есть,
нам необходимо пройтись по всей строке или по всему столбцу, в зависимости от того,
как хотите. Но мы рассчитываем, что в итой здесь мы ставим ребро, если с итого по житой оно есть.
То есть, жита это строка, жита это столбец. Поэтому да, нам достаточно пройтись по одной строке и
рассмотреть, есть там единичка, нету, тогда мы выведем или не выведем данного соседа,
и получим всех наших соседей. Пока понятно, что происходит. Как вы думаете, какой еще есть вариант?
Ой, нет. Вершина хоронить, куда они могут перейти? Неприкольно. Бинарное дерево,
что-нибудь простое, но достаточно. Похоже на матрицу смежности чем-то. Я надеюсь,
вы там обсуждаете именно этот вопрос. И какой итог вы получили? Да что ж такое это? Ладно,
а нордерецет не надо. Смотрите, это списки смежности. Смежности хранится следующее. А у вас
есть, грубо говоря, массив. На самом деле, это вектор векторов, где вы просто сохраняете,
не знаю, для нулевого элемента всех его соседей. То есть, для того графа, который там выше,
это у нас получается один, ну давайте я запишу там два, один. Ну то есть, тут будет массивчик. Для
первого и для второго. Для первого у нас получается два. Вот. У вас будет такой вот вектор векторов,
сейчас это расскажу и отвечу. Будет такой вектор векторов, и память у вас будет храниться в плюс
е. Почему в плюс е? Да, не больше чем е мы можем запушить этих вершин. А теперь вопрос по поводу
обхода ребер. Так, поиск ребра. Нет. Давайте еще раз. У меня здесь хранится, я знаю,
что отсюда начинается. Я хочу вам найти ребро 1, 2. Вот это представил. Представил.
Вот е. Всегда. Или степень вершины. Степень вершины, видимо. Хорошо.
Ну степень вершины не всегда равна е. Хорошо. А получение соседей вершин за сколько?
Хорошо. Да, в действительности это так почти кроме последнего момента. Последний момент,
у вас же есть уже сам вектор. Вектор из всех ваших соседей. Еще раз, для нас соседями мы будем
считать, вот именно для ориентированных графов, это то, куда мы идем, куда мы можем прийти.
Ага, мув, семантику проходили. СТД мув, знаете, как делать. Ну вот, если что, у вас есть вариант.
В общем-то, на самом деле со списками смежности все просто. Ну как бы у вас есть список такой
поквартирный, вы смотрите на каждую вершину и думаете, что происходит. Вот этот вариант почти
всегда чуть больше предпочитают, чем все остальные. Но иногда бывает такое, что нужен либо тот вариант,
либо другой вариант, в зависимости от алгоритмов вам понадобится тот или иной. Вот, есть алгоритмы,
которые полностью построены на списках ребер, есть алгоритмы, которым лучше всего будет матрица
смежности и так далее. Мы будем каждый раз на это все смотреть, будем оценивать, будем думать,
лучше или не лучше, и у нас очень много различных асимптотик появится в этом семестре. И вы должны
в зависимости от задачи понимать, какую задачу вы, во-первых, решаете от тех условий, которые были,
плюсом, какой алгоритм использовать. Вот, потому что не всегда подходят один и тот же алгоритм.
Что важно? Важно, что вместо каких-то массивов и списков, списков смежности можно хранить либо
бинарное дерево поиска, если вы очень хотите повеселиться, либо хэш таблицы. Потому что в
этом случае вы сможете отвечать очень быстро есть такое там число или нет. Понятно? Вот,
тогда у вас время поиска ребра будет действительно быстрее симпатически,
но на хранение будет уходить больше времени. Да. Никак, по порядку просто их кидаем. Если в
векторе делаете так. Если у вас будет вектор unordered set, то это у вас само как-то существует.
А зачем? Здесь другой вопрос. Если это нужно, то храни просто с помощью бинарного дерева поиска
просто. Вот. Если тебе нужно быстро понимать, есть ли там что-то, то можно хэшами. Вот. Прям сортировать
это смысла нет. Вот. Легче использовать какой-нибудь другой. Что ж вы там такое обсуждаете? Предложите
еще вариант. Вот есть бинарное дерево поиска, есть unordered set хэш таблицы. Что еще предложите?
А где ты увидел поиск ребра зовут единица? Ну, у тебя есть вот этот вектор? Ну вот,
это и есть все твои соседи. Еще раз. У тебя есть целый вектор. Кто сказал? Передай его по ссылке и все.
Передав вектор этой ссылки, получите. Если не хотите менять по константной ссылке,
если хотите типа полностью избавиться от вашего графа, возьмите и по R-value ссылки передайте.
Ага. Еще вопросы. У вас сегодня очень странная лекция. Получается, если честно, да. Соседом,
да, мы будем считать такое, но в действительности можно считать по-разному, в зависимости от того,
как вы это хотите сделать. В общем-то, важный момент здесь такой. Если вдруг вы встретите
неориентированный граф, вы будете просто считать, что он ориентированный и проводить
ребро в одну сторону и в другую, например. А если говорить про соседей в общем виде,
что это еще те, кто к нам приходят, то здесь уже, да, нужно будет проходиться по всему вашему
списку смежности. Другого варианта у вас не будет. Ага. Окей. Теперь, надеюсь, когда мы поняли,
как можно хранить граф, мы переходим к первому базовому алгоритму, называющемуся BFS. Слышали
такое? Нигде не слышали. Это обход графа в ширину. И это самый первый, самый базовый, самый понятный
алгоритм, который потом, в дальнейшем, ляжет в основу остальных. Существуют две вещи BFS и DFS.
Все правильно. Вот. Это очень любят спрашивать на собеседованиях. Такое периодически случается,
потому что дальше смотреть не так интересно. Ну, в общем-то, что такое обход графа в ширину? Для
начала нужно понять, что такое обход графа. Обход графа — это просто процесс посещения всех вершин и
ребер. Мы должны пройтись по всему, что нам необходимо. Как правило, сами обходы осуществляются в какой-то
определенной последовательности с учетом структуры графа и с целью выяснить какие-то определенные
свойства. Эти обходы могут выглядеть по-разному. Вы можете делать их каким угодно способом.
Что такое обход графа в ширину? Обход в графе ширину работает так. Вот мы находимся в какой-то вершине.
Давайте пойдем ко всем соседям, которые у меня есть. От них пойдем ко всем соседям, которые есть у этих
соседей и так далее. И у вас будет такое наслоение друг на друга. У вас будут слоями просто происходить.
Что можно отсюда извлечь интересного? Посетили или не посетили все вершины? Хорошо, да. Еще.
Вершины, у которых нет исходящих ребер. По сути, это близко к связности. Просто вопрос,
вы какую связность хотите? Сильную, слабую? Вот. Еще. А? Цикл. Ну ладно. Что еще раз? Нет.
Если я посещал соседей, я не хочу больше посещать. Зачем мне идти в одно место еще раз? Еще.
До реализации мы дойдем. Вопрос флагов. Что именно не оптимально для тебя?
Какую структуру? Нет. Нет. Ну у нас будет отдельный массив какой-нибудь. Предположим,
да. Можно использовать массив. Были мы или нет. Еще раз. Привыкните к тому, что все вершины графа
это чиселки. А если это чиселки, вы просто их храните в массиве. И если вам достаточно
массива юст, ну то есть было использовано, не было использовано конкретная вершина, то в этом
случае вы легко ответите на вопрос. Посетили мы не посетили эту вершину? Ага. Давайте поговорим о том,
что тут можно делать и вообще как с этим жить. Но вы мне не назвали очень важный момент здесь. Да.
Что ты подразумеваешь под подвесить?
В действительности то, что ты сейчас сказал, очень похоже на то, что мы как раз разбили по слоям и
сказали типа кто в каком находится. И в действительности это кратчайшие пути. Если у вас ребра не имеют веса,
а просто вы считаете количеством, грубо говоря, какой путь, то этого достаточно. Мы, во-первых,
про связанность вы сказали, но фактически это достижения из этой вершины каких-то других. Не
всегда связанность означает это одно и то же с достижением какой-то другой вершины. Вот. Это
первое. Второе, это те самые кратчайшие пути, потому что находясь в одной вершине, это расстояние
0, все соседи расстояние 1, соседи-соседи это расстояние 2 и так далее. Ну понятно,
как это расходится. Да? Нет? Да? Да, кивают. Хорошо. В каком смысле? Если мы говорим про
урграф и сильную связанность, то это означает, что для любой пары вершин вы из вершины В доходите в
У и из У в В. Вот это сильная связанность. Связанность с неориентированным графиком,
что у вас есть путь из В в У для любой пары вершин. Да. Вот. Если брать связанность и сильную связанность,
назовем это так. Окей. Понятно с кратчайшими путями, что я хочу делать. И действительно,
все алгоритмы БФС это кратчайшие пути. Как это выглядеть? Вот давайте теперь смотреть на это все.
Смотрите, у меня есть нулевая вершина. Ну, я ее обозначил нулевая, вам скажут,
не знаю, там от пятой вершины нужно посчитать. Я возьму ее просто как нулевой, вы можете делать
все что угодно. Вот. У меня есть соседи, к которым мы придем. А вначале у меня будет массив Дист,
а от 0 до n-1 равный бесконечности. Скажите, когда я нахожусь в этой вершине, какое расстояние до нее?
Ноль. Отлично. Вот. Поэтому я говорю, что Дист там вот этого равно ноль. И начинаю стартовать именно
с этой вершины. Заметьте, заметьте, мне здесь не нужен никакой массив использованной или не
использованной вершинки. Почему? Да. Согласны, что я уменьшить не могу, если общищаю всех. А теперь
смотрите, для всего этого я буду использовать очередь. Я же хожу ко всем по очереди. Вот.
Что будет гарантироваться в этой очереди? Смотрите, я в эту очередь складываю просто
все вершины своих соседей. Ну, то есть я вот встаю в вершине, положил всех соседей вот у своих
соседних вершин. Потом пришел в другую вершину, положил всех соседей этой вершины в данную очередь.
Потом пришел в другую вершину, опять положил всех соседей в данную очередь. И так далее. Я вот продолжаю
вот это все время делать. И когда я прихожу в новую вершину, я хожу к ним вот именно по этой
самой очереди. И смотрю, доступна мне эта вершина или нет, был я в ней или нет. Если был,
то ничего не делаю. Если не был, то я опять беру всех соседей. Все просто. На руках понятно?
Ну так, на словах. Что я сейчас делал? Страшно. А? Еще раз.
Ну смотрите, я нахожусь в нулевой вершине и такой, ага, вот это положу, вот это положу. Нет,
мы кладем по одной вершинке. По одной вершине я кладу все остальные. А что я делаю здесь? Смотрите,
хоть алгоритм вам написан, я боюсь, что вы можете сразу... Нет, вам не понравится,
что здесь происходит. Давайте, я тот же начало возьму оттуда. Вот моя нулевая. Я говорю,
что в моей очереди Q будет лежать в начале нулевой вот этот элементик. После этого,
когда я в нее зашел, вот в этой вершине нахожусь, я что делаю? Я добавляю всех его соседей. Ну,
а 1, 4, 6. И выхожу из этой вершины. Я ее посетил. И когда я выхожу из нее, я говорю,
что dist 0 равен 0. Ага, ну как бы, вот я сделал так. А когда я буду класть свои вершины сюда,
а вот dist 0 равный 0, он был в самом начале. Скажите, сколько у меня расстояние будет до соседей
моей нулевой вершины? 1. На 1 больше, чем я был в этой вершине, согласны? Ровно так же,
что для этих соседей будет на 1 больше, чем у них. Согласны? Я делаю всегда плюс 1,
поэтому тут D это единичка, единичка, единичка. Окей? Теперь смотрите дальше.
2, 3, 5, 8, 7. А давайте тут вообще ничего не будет. Что у нас происходит дальше? Дальше я
иду по этой очереди и достаю новую вершину. 1. Расстояние ее 1. До следующих вершин 2, 3, 5,
сколько расстояния будет? 2. Я сразу это прописываю. У меня тут 2, у меня тут 3, у меня тут 5.
Расстояние до этих двух. 2. Я их все посетил, все посмотрел и выкидываю. А теперь представьте,
еще не знаю, что у меня из пусть будет, сейчас я думаю, из 5 пусть будет 8. Вот так до конца доведем
эту всю штуку. Что происходит дальше? Вот я посетил единичку, давайте я вот здесь вот их подкрашу.
Дальше я буду идти в 4 и добавлю восьмую вершинку, которая пришел. Согласны? 8. Ну,
у шести никого нет, я просто на нее забью. Вот, и я их вычеркиваю. Вот скажите мне 8,
там будет 3. А у меня вопрос, ой два, прошу прощения, да. У меня вопрос, вы видите,
что происходит с расстоянием? Что происходит в этой очереди дальше? Ну вот у меня 3, 5,
8. Предположим, вот сделаю 2, 3, у них ничего. Сделаю 5 и вижу опять 8. Я иду как будто бы 8,
но приду ли я туда? Нет, у меня уже 10 равен 2. А теперь вопрос, согласны ли вы с тем, что в этой
очереди каждый шаг, каждая итерация вот того, когда я добавляю, всегда будет хранится какое-то
расстояние х в начале и не более чем х плюс 1 у всех остальных. То есть моя вся очередь,
она фактически будет разбиваться вот как-то вот так. Я не могу поставить там х плюс 2 никогда,
потому что я рассматриваю все элементы сначала и от них добавляю что-то в конец. Теперь давайте
смотреть на сам весь этот алгоритм. Ну у меня есть Дист, у меня есть... Как?
Не может быть, плюс 2. Плюс 2 не бывает. Вот. Отлично. Смотрите, мы с вами храним два массива Дист,
если вдруг вам нужно восстановить путь, то есть откуда вы пришли, из какой вершины, но это не
всегда надо, здесь в зависимости от того как необходимо. Дальше я делаю очередь и говорю,
что Дист со своей стартовой вершины Source у меня ноль. Но после чего я делаю до тех пор,
пока моя очередь не пустая, беру вершину из моей очереди, смотрю всех ее соседей,
всем соседям, если мы их не посещали, то есть если Дист у меня это бесконечность,
всем соседям делаю Дист равный плюс 1 от той вершины, где я сейчас нахожусь, говорю,
что там parent у меня, я пришел из вершины В, которая у меня написана, и пушу в очередь. Окей,
понятно. Понятно, как работает BFS. Что произойдет после того, как я его закончу?
У меня ко всем вершинам будут расстояния от данной конкретной вершинки. Согласны? Сколько это работает?
Вот В, так. А? Вот В.
Вот В, хорошо. Еще есть варианты? А? А сумма степени вершины чему равна? В плюс Е,
почему В плюс Е? И смотрим соседей. Вот это правда. Вот В плюс Е, если мы идем с помощью списка
смежности. Почему? Потому что мы ходим по всем своим соседям. Мы должны пройтись по каждому
соседу, и неважно, был он или нет, мы все равно должны проверить, вот этот их должен сработать,
который после фора идет. Понятно? Нельзя рассуждать только с мыслью о том, что у меня есть что-то внутри
или нет. А если вдруг у вас нету списка смежности, а у вас матрица смежности, тогда будет В квадрат.
Ну, вы просто постоянно для каждой вершины проходите по всем ее соседям и смотрите есть
сосед, нет соседа, есть сосед, нет соседа, поэтому будет В квадрат. Понятно время работы? За В плюс
Е звездочку получаешь. Вот, отлично. Хорошо, давайте докажем корректность данного алгоритма. Потому
что без этого уже никуда, нам нужно доказывать, что действительно что-то работает, а не просто на
словах это делать. Давайте покажем, что в массиве Дист у нас действительно хранятся кратчайшие пути.
Первая лемма это то, что мы с вами в самом начале рассматривали, что у нас в очереди все вершины
расположены по неубыванию Дист и их расстояния различаются не более чем на единичку. Ну как бы,
как эту лему сделать? Мы с вами это показали, в действительности это можно сделать по индукции,
где по индукции в самом начале пути у нас что? Находится одна вершина и для нее все это верно,
согласны? У нас неубывающая последовательность из одного. Вот, дальше переход следующий. Мы делаем
для какой-то итерации К, тогда в начале очереди расположены вершины со значением Х, Д, как хотите.
Вот, в конце с значением D плюс 1, но так как мы вытаскиваем первые вершины, то мы добавим в
конец нашего списка, в конец нашей очереди элемент с со значением D плюс 1. То есть опять в начале
у нас идет какое-то количество D, может быть нулевое уже к этому моменту, после него D плюс 1.
Переход корректен, база есть, итог получили. Понятно? Точно? Хорошо. Ладно, теперь смотрите. Нам
нужно доказать, что там действительно хранятся необходимые нам расстояния. То есть для любой вершины
В, расстояние В, давайте сначала докажем, что оно больше либо равно, чем ρ от S до V, где S это
расстояние от S до V. То есть числа, которые хранятся в 10, они больше либо равны этому числу. Почему?
Окей. Ой. Да, но в действительности я опять здесь просто сделал по индукции, но можно ровно таким
же способом сделать. Ну то есть просто расписав через плюс 1. Окей? Вот. Так как у нас есть какие-то
расстояния, все достаточно просто. А теперь теорема самой корректности, что после работы вашего
BFS для любой вершинки V у вас в действительности D равен расстоянию, к кратчайшему пути. Необходимо
это доказать. Как это доказывается? Доказывается это от противного. Пусть существует какая-то вершина
X, где у нас расстояние D, расстояние до вершинки этой X будет меньше, чем D, который мы нашли.
Пусть V – это минимальный аргумент от РОСХ, это как раз-таки где ДИСТХ больше, чем РОСХ. Понятно,
что я здесь сказал? Отлично. Вот. Пусть у него есть parent, у него есть родитель. А родитель этой
вершинки V. А P, ну как бы предок, истинный, это вершина V. Ну что подразумевается? Смотрите.
Как будто бы вот в этом случае мы должны сказать следующее. Вот у меня есть вершинка V, и выглядит
это так, что я пришел в нее из U, и это проблема. А правильно было бы прийти из P. Вот что там сказано.
Окей? А что происходит в этом случае? Я говорю, что в этом случае у меня расстояние до V. С одной
стороны, по моему алгоритму DIST V равен DIST U плюс 1. Согласны? Это тот родитель, который есть. А с
другой стороны, RU от SV равен RU от SV плюс 1. Ну то есть расстояние до этой вершины. Отлично.
Тогда, и кроме того, мы имеем, что DIST от V больше, чем RU от SV. Но это наше предположение,
что такая вершина еще существует. Ага. Понятно. Вот. Чудненько. Тогда в этом случае у нас DIST U больше,
чем RU от SP. То есть расстояние до вершины этой U должно быть больше, чем расстояние до этой
вершины P. Согласны? А тогда в этом случае мы получаем противоречие, потому что мы сказали,
что в нашей очереди все хранятся по неубыванию расстояний. Это первое. А значит,
мы вершину U обработали раньше, чем вершину P. Представьте, что у меня здесь, не знаю,
значение 5, а здесь значение 6. Мы с вами сказали, что в нашей очереди все значения всегда идут по
неубыванию и отличаются не более чем на единичку. Мог ли я в начале обработать U, а только потом P?
Нет. Потому что у меня так очередь устроена. В начале лежат все-таки меньше. Вот. А в то же
время я говорю, что вершина V минимальная по аргументу RU от SV. RU от SX, точнее. Минимальная из всех таких.
Значит, для всех вот этих она верна. Согласны? То есть вот здесь подразумевается, что D от P равно RU от SP.
Мы говорим о том, что в этой вершине это вернул, потому что V я взял минимальную такую.
Ну а как бы мы не могли сделать такого? Мы не могли не в том порядке их взять. Значит,
у вас где-то бага только. Но именно в алгоритме DX ничего не изменяется. Поэтому это неверно. Мы
пришли к такому противоречию. Понятно ли вам противоречия? Кому непонятно. Да. Ой,
господи, БФС, простите, пожалуйста. У меня влаги уже просто к концу вечера. Я имею 30 работ.
Проблема. Это БФС. DX это другое, мы пройдем его попозже. Понятно с БФС, что мы сделали?
Понятно, как мы доказали, что это корректно. Все смогут это сделать. Конечно. Ну без доказательства
я скажу, что ты не знаешь, что алгоритм вообще корректен. Ты мне будешь писать его,
во-первых, на листике. Для того, чтобы проверить, что ты умеешь писать код, у тебя будет контест.
Вот. На контестах ты показываешь свое умение писать код. А все-таки теоретическая база алгоритмов
тоже тебе нужна. Вот. И тебе нужно доказать, что это работает корректно. Иначе потом в дальнейшем
ты не сможешь доказывать, что у тебя корректно вообще работает что-либо. Что тоже не очень хорошо.
Конечно, сейчас это решается тем, что миллион тестов у вас существует. Вы напрот пока не
протестируете, ничего не выкатите. Но это тоже работает не всегда. Нужно видеть. Но часть всего
баги просто именно с точки зрения архитектуры какие-нибудь есть. С точки зрения кода. С БФС все ясно.
Хорошо. Тогда давайте усложнять задачу. Смотреть, что у нас есть. Давайте возьмем
взвешенные графы. Что такое взвешенные графы? Это значит, у каждого ребра у нас есть какой-то вес.
Вот. И от этого будем отталкиваться. Первое рассмотрим 0 как граф. Ой, 0,1 граф. Значит, у вас
каждое ребро имеет вес либо 0, либо 1. Ну, грубо говоря, у вас есть либо телепортация, либо вы
ножками ходите. Ну, как бы, что поделать. Здесь нужно понять, а что нам делать.
Да? Ты уверен? Представим следующее.
Проверять это еще раз, а тогда мы должны класть все ребра постоянно.
Ну, это не совсем мне нравится идея. Ну вот представим такое. У меня была вот эта вот
нулевая вершинка. 1, 2, 3. Нулевая 0. 1, 1, 2, 3. 0, 0. Что-то не так. Должно быть везде по нулям.
Согласен? Вот. Находить минимум не всегда корректно. Просто ты будешь обрывать абсолютно
всех тогда. А представь еще, тем более, следующую картину. Что ты пришел вот в эту единичку,
поставил неверное, а у тебя здесь еще одна вершина была. И ты сказал, что до нее расстояние
осталось 2. Вот я, предположим, после единички там что-нибудь поставил бы. Мог я так? Ну,
точнее, не после единички, а вот после двоечки бы это выглядело так, что здесь было бы не 3,
а давай здесь 5 номер. Ты бы сделал здесь 5, потому что я в единицу-то пошел, смотрю на ее соседей,
ставлю здесь 2, а здесь у меня станет уже 3. Как? Что значит сначала по нулям?
Так, как это достичь? А как мне этого достичь?
Циклом прохожусь по всем соседям. У меня там все единички.
Ну нет, еще раз.
Я вначале обработаю это, станет 2.
Куда добавлять? А? Я их так добавляю.
Ничего не понял. Добавляем.
Ну, они опять будут стоять всех после всех.
Сейчас, подождите, BFS у меня все-таки работает вот так, вот так, а потом вот это и вот это. Да? Ну,
в чем противоречит твоя логика сейчас? Мы так не можем, это не BFS. BFS ходит по всем соседям.
Хорошо, ладно, но это больше похоже на DFS. Узнаем попозже? Еще есть идеи?
Тоже не поможет. Вот аналогичный пример здесь.
Еще. У нас есть очередь, есть еще. Давайте подумаем о деке. Что мы можем сделать такого в деке,
что не можем делать в очереди? Отлично. А теперь смотрите, что я должен сделать с нулевыми,
чтобы они выглядели правильно. Правда, будет выглядеть не как BFS, что мы слоями ходим,
но в то же время, если мы будем добавлять сначала, мы не рушим всю логику того, что у нас как бы в
начале идет расстояние coin D, потом D plus 1. Логика остается ровно такая же. Да? Он построен не
совсем на массивых указателях, он построен на циклическом буфере. У вас есть реализованный дек?
У вас есть STD-дек? Все зависит от того, успеть было от к вам контейнеры рассказать или нет. Это
другой вопросик. Ну он успеет вам рассказать? Ну тогда, думаю, да. Мы подумаем еще, но думаю,
да. Смотрите, суть именно в этом, что вы нулевые вершины ставите в начало, единичные ставите в
конец, нулевые грубо говоря, приоритетно рассматриваете. И тогда ходите действительно по нулевым.
Просто их нельзя именно в той кучке, как ты сказала, что мы смотрим на нулевую и от нее все нулевой
смотрим. Что если будет еще разветвление? Можем. Проблема в том, что будет у нас вот так еще нулевое и еще нулевое.
А как мы их запишем? Как мы пройдемся? Я же потом должен раскрутиться по твоей логике назад и идти обратно.
Я не понял тогда. Да. Хорошо, если напишешь, типа, тогда в этом случае ты можешь, напиши мне в ВЛС просто,
тогда и скинь типа посылку. Мне интересно понять, что ты хочешь. Может быть, я не понимаю. Ну или просто
после подойдем. Вот. Ну и как бы здесь мы это все с вами делаем. Вот. Окей? Понятно? Что не понял?
Какой вопрос? Что не понятно? Какой из шагов? Давайте еще раз. Еще раз у нас есть 0,1 градусов.
Мы решаем аналогично БФС, ровно так, как было. Единственное, что мы будем использовать не очередь, а дек.
И все вершины, до которых нам идти через нулевые ребра, мы кладем в начало. А все вершины, до которых нам нужно идти
с расстоянием 1, мы кладем в конец. Да. Самое начало дека, по сути своей. Вы когда будете доставать,
смотрите, когда вы рассматриваете какую-то вершину В, вы достаете ее сначала, из самого начала. То есть
еще раз. У вас есть какая-то вот эта вот очередь. Вот твоя вершина В. Ты сначала ее достал, а после этого
ты смотришь на всех соседей данной вершинки и говоришь, ага, вот до этой вершины у меня 0 и до этой
0. Значит вот эту нулевую я ставлю сюда, вот эту нулевую оставлю сюда, а вот эту единицу ставлю сюда.
Понятно? Будем сразу обрабатывать, да. Ну как только мы свои закончили, да, мы сразу будем обрабатывать их.
Но в этом нет никаких противоречий. По сути нулевые вершины, нулевые ребра, что означает, что это все
склеивается между собой? Понятно? Поэтому это ровно то же самое, что нам необходимо.
Но в любом случае получится пути только в случае, если вы закончите весь БФС. Что-то ты смеешься, я боюсь, что ты что-то не понял.
Да, но почти наверное у тебя никогда не будет чисто нулевого пути. У тебя будет где-нибудь единичка по серединке.
Мы хотим найти расстояние от одной вершины до всех остальных.
Смотря что ты хочешь. Еще раз. У тебя может быть граф 0,1. Может быть невзвешенный граф, мы считаем,
что все ребра имеют вес 1. Может быть граф 0,1. Тогда в этом случае вам необходимо говорить о том,
что вам нужно как-то переобработать это все, потому что вы должны сказать, что до этой вершины расстояние
все-таки 0, а не 1. Давайте перечерчу. Если бы мы делали просто БФС, то вот в этом бы случае у нас было бы так,
что вот из этой нулевой вершины здесь расстояние 1, здесь расстояние 0, здесь расстояние 0, все.
Потому что я бы смотрел вот это, вот это, вот это. И это была бы проблема. Мне нужно сначала вот так пройтись.
Вот это 0, вот это единичка. У меня здесь расстояние, ну типа вот 0,1 граф.
Я пытаюсь понять вопросики. Еще один. Хороший вопрос. А как ты думаешь, почему?
Ну смотрите, в начале же, в начале же мы говорили, что у нас массив расстояние, вот этот D,
он бесконечностями заполнен. Да? И мы говорили о том, что если мы не посетили вершину, то мы, а означает, что там лежит бесконечность.
Теперь я говорю нет. Нужно сделать что-то другое. И мы делаем следующее, что мы говорим, что Dу плюс вес нашего ребра,
давайте так, dv, vu, он должен быть меньше, чем Dу. Что из этого, что означает?
Это расстояние от той вершины, где я иду. Вот это принимает значение, какое? 0,1. А вот это, ну какое-нибудь.
Если я нашел путь меньше, то я должен переделать. Почему это здесь важно?
Ну в действительности у вас будет ровно вот этот же пример. Смотрите, почему это нужно?
А я же как делаю DFS? Ой, ну я делаю BFS, прошу прощения. Я иду просто по соседним вершинам. Мне же никто не говорит,
какой порядок соседних вершин, правильно? Представим, что у меня вот есть нулевая вершинка. Вот 0 здесь есть,
да? Я обрабатываю всех его соседей, ну расстояние 0. Я обрабатываю вершину 1 сначала, вершине 1 какое
расстояние будет? 1. А вершине 2? 0. Ой, да. Вот 0, 0 я отсюда убираю, по сути. У меня здесь становится 2,
с состоянием 0. И из 2 я должен прийти куда? В 3. Ну то есть у меня 2 здесь заменится на 3, будет опять 0. А из 3 я куда должен прийти?
А у меня там уже есть единичка. Понятно? То есть из-за этого порядка у нас может быть баг. Вот и все. Теперь
понятно на вопрос почему? Еще вопросы есть? 0.1 BFS понятно? Что еще раз? Тебе как ответить,
формально или нет? Формально тогда тут написано не очень правильно. Эта весовая функция, она идет из пар,
ну из ребра в число. Вот, это функция просто. Но здесь написано вывод, по-хорошему нужно две скобки
указать. Тогда это будет от ребра куда-то. Вот, чтобы математики не ругались. То есть да, в действительности как бы,
ну если ты хочешь прям вот прям полностью, тогда должно быть записано вот так. Ну это по сути из множества
ребер чиселки 0.1. Вот это есть функция. Да, он либо 0, либо 1. Вопросы еще есть? Либо я как-то непонятно
рассказываю, либо это новенькое. Презентацию я, кстати, за день выложил. Она вчера появилась. Кто-нибудь видел ее?
Ну вот, понимаю. Ладно, это не конец. Представьте, что у меня не 0.1 граф, а 0.k граф. Как жить? К число, то есть у вас
0.k означает, что у вас все целые числа. До к, да. А как вставлять в серединку-то?
У нас даже на 0.1 тогда так не сработает, если ты в конец вставляешь. Нужно какое-нибудь гениально
простое решение. Первый способ вы должны придумать. Ладно, второй. Так, отлично. На какие? Да, если вдруг
вы встречаете ребро с весом больше чем единичка, то есть 2-3 до к, давайте каждое это ребро закинем
туда, а фиктивные вершины. Я это ребро превращу в следующее. Давайте еще порисуем. Возможно,
я сегодня, конечно, много вопросов вам просто задаю, но представьте, что у меня из в в у ребро
весом к. Что я должен сделать? Я хочу сделать примерно следующее. Если у меня здесь к, сколько
здесь должно быть вершин? К-1. Вот я введу какие-нибудь вершинки, ну не знаю там, т0, т1,
т, что у нас там, к-2. И скажу, что все эти ребра имеют вес 1. Тогда какой задачи я свел?
Предыдущий к 0.1 bfs. Вопрос, а за сколько это работает? Ой, тут все-таки написано, я это,
я уже этого не помню. За сколько работает? Не совсем. Сумма ребер плюс сумма вершин.
Ну, по сути своей да, но только, ну, давайте сверху уж оценим, скажем, что это к,
плюс в. А почему это так? Ну, как бы мы говорим о том, что каждое ребро мы разбьем не более чем
к минус, ну, не больше, чем на к минус одну вершинку. Ну, к-1e. Плюс у меня еще было в
дополнительно, но это как бы к. Ну, в принципе, можно. Проблема в том, что сумма длин ребер,
ну ладно, ну так. Тебе очень не нравится, видимо, то, что я когда-то сказал, что мне нужны степени
вершины. Хорошо. Ну, в действительности, да, сложности к, плюс в этого достаточно. То есть,
в такой случае достижим сам по себе и мы с ним можем работать. Окей? Понятно, как мы это сделаем?
Давайте придумаем второй способ. Да. Извините. Второй способ не нужен. Я хочу быстрее. к,
плюс в это достаточно долго. Я надеюсь, вы это понимаете. Если у меня большие-большие ребра.
Смотри, что-то хочет делать рекурсии, но нет. Это уже DFS-сет не работает.
Я, давайте, дам подсказку. Нужно создать несколько очередей.
Если ты сразу скажешь, как сделать с к очередями, то, считай, я тебе поставлю плюс один балл на экзамене.
Скажешь? Сразу. Ты мне скажи смысл. Видимо, нет. Хорошо, ладно. Давайте вернемся к задаче.
Да. Да, по сути, это первый вариант.
Давайте мы сделаем примерно следующее. Вот самое начало. Пусть у меня будет kv-1 очередь.
Почему kv-1? Это максимальное расстояние, которое возможно. И пусть у меня очереди нулевая,
первая, первая, и так далее. Вот. И в случае, когда мы берем какую-то и-ту вершинку с расстоянием,
там, не знаю, равное какой-нибудь c, и смотрю на всех ее соседей, на всех соседей вершины и,
ну, какую-нибудь вершину у. И до нее расстояние пусть будет t. Тогда я добавлю эту вершину у
в очередь от c плюс t. Почему так? Потому что благодаря этому я буду смотреть. А дальше,
как я смотрю на все эти очереди? Я смотрю на все эти очереди по очереди. Здесь как бы другого
варианта не будет. То есть вы смотрите сначала на нулевое, потом на все первое, на второе,
и так далее. У вас все идет вниз. И тогда согласны, что я вершину у рассмотрю после того,
как у меня расстояние, ну, вот всех предыдущих, у них расстояние будет меньше, чем у. Согласны?
То есть оно вставится вот куда-нибудь вот сюда. Максимальный путь какой? Максимальное расстояние
у графа. Почти. А есть ли у меня граф взвешенный? Так. Вопрос еще есть? Какой? Давайте еще раз.
Я вставляю в очередь равную длины пути. Это максимальный путь, который возможен. То есть
невозможно расстояние больше. Ну, смотрите, я превратил k e плюс v в k v плюс e скорость алгоритма.
Хорошо. Или какой вопрос? Как очереди используем? Очереди. Я только что объяснил. В очередь с
индексом равным расстоянию до моей новой вершинки, вот до соседа у, к примеру. Пусть у меня расстояние
до вершины и, до вершины и равно c, у нее есть сосед, до которого расстояние t от вершины и. То
есть расстояние до у c плюс t здесь считается, правильно? Я говорю, давайте я в очередь с индексом
c плюс t добавлю свою вершину у. Вот. Тогда я до этой вершины, я буду обрабатывать очереди в порядке
индексов и вот рассматриваю полностью, что там происходит. Тогда в этом случае рассматривая их
в порядке очереди, я скажу, что я обработаю до моей вершины у те вершины, у которых расстояние меньше.
Почему я делаю таким образом? Потому что, если у меня расстояние до вершины меньше, до у, к
примеру, и у меня есть какие-то еще вершины, до которых расстояние было меньше, я должен рассматривать
здесь вот какой-нибудь вот такой вот крючок. То есть, предположим, что у меня здесь c плюс t,
а здесь у меня расстояние, не знаю, там c плюс 1, а t больше единички. Я должен рассмотреть эту вершину
раньше. Ну подожди, когда ты рассматриваешь отелей, ты ставишь дист, правильно? Массив дистов у тебя
будет в итоге? Так, массиве дистов будет хранить с расстояния? Вершина от какой-то конкретной?
Да, и запихиваем в очередь ее. Почему? А вот здесь вот на самом деле, когда вы будете обрабатывать всю
очередь, вы не можете заранее сказать, есть у вас такая вершина в очереди или нет. Такого варианта,
к сожалению, здесь нет. Вы просто их записываете в очередь и смотрите расстояние у них получается
нужно или нет. То есть, одна вершина может быть хранится там, не знаю, в пяти очередях. Может
быть такое? Может быть. Так, а дальше как? Я пришел, не знаю, в вершину с весом 5,
к у меня 7. От этой вершины 5 существует еще одна вершина с расстоянием 5. Куда я добавить ее должен?
Пятую? Пятую, тогда я обработаю сразу же. Что неправильно? Какую из очередей из семьи я должен
добавить? Но ты близок, да. Элементик, да. Мы идем по всем этим очередям и смотрим. Если у меня,
я достаю элементы из этой очереди, смотрю, ага, расстояние здесь С плюс Т до этой вершины У. Я
смотрю, а расстояние до этого было меньше или нет? Если меньше, то я пропускаю просто этот шаг.
Если оно было таким же или большим, тогда я записываю это С плюс Т в расстояние У. Чем что?
Еще раз, предыдущая работала за сколько? За КЕ плюс В, правильно? Сколько у меня здесь
очередей? Сколько раз я добавлю сюда элементики? Сколько всего? Почему? Знаю. Один элемент может
быть добавлен несколько раз, да, я не спорю, но сколько раз он может быть добавлен? Степень вершинки,
правильно? Сумма входящих степеней вершин. Сумма входящих степеней вершин чему равна? Сумма всех.
Е. Е. Просто Е. Сколько, если я добавляю все вершины, а если сумма всех степеней Е,
то сколько раз я добавлю все вершины? Сюда, в очереди. Е. Теперь смотри, я каждую вершину
обрабатываю и обрабатываю за от единички. Да, мне сложно. Согласен? Отлично. Все должны пройтись.
По КВ минус одной очереди, всего вершин Е, получая свою симптотику КВ, ну, минус один, хорошо, плюс Е.
Е это количество, вот здесь вот элементы возможные.
Опять не успели обрабатывать. Что ж такое? И вниз, и влево. Ну, влево, ой, и вправо,
сколько раз я вправо схожу? Е раз. Согласен? Давай еще раз. А что мы должны с этим сделать?
Почему? Я не в каждой очереди храню Е штучек.
Да, смотри, давай еще раз. Я иду в любую очередь. Хорошо, я иду в любую очередь. Я
убираю этот элемент, смотрю на следующий, убираю этот элемент,rolling этот элемент. Иду
дальше. Обратите по индексу я могу быстро? Иду дальше, убираю эти элементы. Я убираю за вот единички.
Сколько раз уберу элементы? Е раз. Согласен? Сколько раз по индексам должен сходить? Хожу
индексам завод единицы. Сколько раз ты должен сходить по индексам? KV-1. Все. Смотрите, есть
улучшение. Sorry, что чуть-чуть задерживаю. Улучшение, которое говоришь ты, только чуть-чуть другого
характера. Давайте мы не будем хранить KV-очередей. Вот, мы попробуем улучшить память, но не улучшить
время, потому что KV-очередей много. Давайте мы будем хранить K-очередей, но если я нахожусь в
моменте х, ну не знаю, вот 5 я как раз дал. 1, 2, 3, 4, 5, 6, 7. Вот, я нахожусь вот в пятерочке. 0, 1, 2, 3,
нет. 4, 5. Вот. Вот, я нахожусь вот на пятой своей очереди, расстояние 5, к примеру. Я прихожу
к вершине, какой-то U, которая здесь находится, и говорю от этой вершины U до какой-то вершины T
расстояние 5. Куда мне добавить эту вершину T? В действительности, смотрите, согласны ли вы с
тем, что от вершины U я не могу уйти больше, чем на K? То есть, я не могу вернуться в эту же ячейку,
например. Да? Но я могу помещать их вот ниже и потом выше делать. Давайте я буду остатки
отсмотреть от K. То есть, я от каждой вершины все равно не уйду дальше, не приду в тот же остаток,
как минимум. Другие могу, согласны? И чем ближе остаток с точки зрения числа именно вверх идти,
тем это число будет ближе. Согласны? То есть, я не выхожу за его границу. Поэтому,
когда у меня будет 5, а здесь будет 0K6, то что я сделаю? Я сделаю 5 плюс 5 и возьму от этого
остатка деления на 6. Что я получу? 4. Куда я поставлю этот элемент T? Сюда. Вот. А теперь,
смотрите, я должен не просто сделать на 6, я должен на 6 плюс 1. Почему? Потому что если бы я прибавил
6, то я бы попал ровно в эту же ячейку. Согласны? Я должен чуть-чуть расширить и сделать K плюс
одну очередь. Поэтому их будет вот так. Я чуть-чуть расширяю воронку. Потому что сколько у меня
возможно остатка деления на K? K. А мне нужно сделать так, чтобы я не попал в одно и то же.
Да? Сейчас. Раз, два, три, четыре, пять, шесть. А, да. Извините. Шесть. Вот. Вот это вот максимальное
расстояние, которое у меня возможно для 0.6 графа. Это вам нужно будет написать в контест,
если вы хотите получить хорошую оценку. Реализовать это нужно. Если вы хотите оценку. Ну да, ладно.
Хорошо. Относительно, правда. Ну, с точки зрения весов не могу точно сказать. Да, вроде бы так же.
Да, но в этом году у вас еще и будет экзамен по плюсам, по-моему. Вот. Кто-то радостный,
кто-то нет. Сделаем фото. Готово. Ладненько. И я вас отпускаю.
