Вот, давайте начнем третью лекцию. Точнее четвертую, но третью лекцию мы до конца не довели,
поэтому мы с вами посмотрим на такую штуку к интерьеру Meetability. У нас есть такие вот примитивы
separate RFSL, которые мы сейчас посмотрим. Смотрите, у нас есть правило memory-safety, главное в расте,
которое говорит, что мы в любой момент либо имеем сколько-то немутабельных ссылок. Забегая
наперед, скажу, уже, наверное, вам можно говорить об этом. На самом деле, когда мы говорим мутабельная
ссылка и немутабельная ссылка, мы чуть-чуть вверх, потому что в рамках RASTA это только интуиция.
На самом деле, немутабельная ссылка означает shard-ссылка, а мутабельная ссылка — это unique-ссылка,
то есть она только одна. И в этом смысле она чуть более правильна, чем мутабельная и немутабельная.
Ну, вы можете оставаться в мыслях о том, что это мутабельная и немутабельная ссылка,
я думаю, вы почти, наверное, не сломаете ни в какой момент себя понимание. Вот у нас может быть либо
несколько немутабельных ссылок, либо одна мутабельная. Но иногда бывает такое, что нам
хочется мутировать объекты при том, что мы имеем только обычную ссылку.
Плохо, конечно, что я не успел посмотреть слайды. Так, давайте посмотрим. Так как у нас RASTA не
должен ломать свои фундаментальные свойства safety, то в таком случае то, что мы сейчас будем делать,
я заранее предупреждаю, оно будет иметь какой-то overhead в runtime. Он не может это проверить
compile-time, поэтому для того, чтобы safety сохранялась, он проиграет это в runtime.
Тот паттерн, которому будем говорить, называется Interior Metability. В RASTA он очень явно возникает,
в плюсах и подобных языках на самом деле тоже возникает, но вы его просто не видите,
потому что он не формализован в этих языках.
Смотри, вот есть чисто RASTA пример изменения чего-то внутри RSI. RSI у нас внутри не мутабелен.
Есть некоторая причина, которую мы на этой лекции объяснять не будем, почему внутри мы не можем
заменять объект. Для того, чтобы что-то мутировать внутри, нам нужно будет использовать
RASTA Interior Metability. Чуть более конкретно, помните ли вы Atomic или Mutex? Думаю, конечно, помните,
я прихожу, вы разговариваете про конкарнти. Как минимум один ассистент, как минимум один семионарист,
поэтому ситуация другая. Да, ну в общем, какая ситуация у нас? Atomic это, когда вы пользуетесь
RASTA Atomic, у вас несколько потоков имеет ссылку на него. Вот это собственно Interior Metability,
это мутабельность через обычную ссылку, через шарот-ссылку. Для того, чтобы это работало, вам
нужно давать какие-то гарантии, потому что если вы будете мутировать это из нескольких потоков,
или как мы увидим дальше, даже однопоточно что-то мутировать неправильно, то вы можете получить
и в плюсах. Ну то есть в плюсах ты не увидишь это, потому что в RASTA, опять же, очень-очень хорошо
все формализовано, и ты увидишь просто. Очень явно. А в плюсах это сложно найти. Вот. Ну вот,
Atomic, Mutex, Ravalloc и вообще любая мутация через обыкновенную ссылку. Мы на этой лекции не будем
говорить про многопоточную модификацию, будем только про однопоточную. В какой-то момент мы вернемся
к Atomic, Mutex, Ravalloc и прочему, когда мы будем говорить про многопоточную страсть.
Давайте начнем с такой абстракции, которая называется CEL. Вот. У нас CEL содержит какой-то тип T,
и как он решает проблему того, что у нас может несколько потоков, например, ну,
давайте не про потоки, как он решает проблему того, что у нас может модифицироваться значение
внутри него. Он его просто либо пресваивает в этом значении, либо когда мы достаём оттуда значение,
то он его просто копирует, он не возвращает ссылку. Вот. И более того, обратите, пожалуйста,
внимание на то, что мы от T требуем, чтобы он был копия. Мы сейчас поговорим, почему это именно копия,
а не клоун, например. Вот. У него достаточно немного самых важных функций, там есть еще
некоторые, но нам важны эти три. Создать новый CEL, записать какое-то значение и взять значение.
Ну, как видите, сет у нас просто моет на три значения, а get у нас достает именно копию.
Причем более того, вы можете создать CEL даже когда у вас T не копия, но get у вас будет работать
только тогда, когда T именно копит. Вот. Там вот так вот это устроено. Вот. Ну, с этим, я думаю, понятно.
Ну, в принципе, да. Это, наверное, создано для того, чтобы для каких-то типов, которые копии не
имплементируются, CEL все равно можно было создать. Ну, я не знаю, зачем. Вы будете это использовать
в основном для всяких интов, например. Что еще? Так. Ну, опять же, например, если у тебя RCE32,
то ты не сможешь RCE32 менять. Тебе захочется закономерно иногда через шар отсылку его менять.
Ну, RCE, да, это шар отсылка просто. Вот. И, соответственно, тебе захочется сделать RCE CEL.
RCE CEL, потому что у тебя внутри тип INT. Он легковесный, он просто копии, поэтому
мы можем воспользоваться CELом. Ref CEL, забегай наперед, это то, что возвращает именно ссылки,
считает хронотайны. Вот. У нас есть такой вот важный вопрос, почему мы запросили копии, а не клоун.
Дело в том, что у нас клоун может быть фигней, который делает какую-то произвольную логику внутри.
Копии — это именно копирование байтиков строго, а клоун — это то, что может имплементировать
user, выводить что-то на экран, каким-то образом очень хитрым копировать и так далее. Так что
давайте мы посмотрим вот на такой примерчик. Давайте мы сделаем bad clone, внутри которого
будет какой-то дейта, это i32, и указатель, который представляет ссылку на какой-то CEL.
Ссылку на CEL, которая внутри option на точно такую же структуру. Вот так вот. Примерно запомнили, если что, вернемся к слову.
Это lifetime. Можешь пока что считать, что lifetime мы здесь написали просто потому, что нас компилятор попросил.
Ну и вернемся к lifetime, буквально через лекцию две, и будем уже очень подробно говорить про то,
почему это в расти необходимо. Это время жизни переменной, и конкретно время жизни ссылки.
То есть ссылка не может пережить объект. Поэтому мы вынуждены это написать и на структуре повесить тоже такое ограничение.
Ну пока что вот конкретно здесь ничего плохого нет. Если что, мы предполагаем, что у нас CEL на данный момент
стандарт библиотеки стал на некоторое время именно clone. То есть просит именно clone, а не copy.
Этим и отличается. Ну и давайте мы имплементируем clone для bad clone.
Ну что мы делаем, мы берем ссылку на наш же дейта, выводим, ну просто выводим для наших целей,
чтобы мы увидели какой будет результат дейта на экран. Потом мы, заметьте, мы очищаем наш текущий указатель, наш текущий, наш текущую ссылку.
Вот. Давайте я даже убежусь, да. У нас ссылка на CEL здесь, если что, да? Вот ссылка на CEL и option.
Вот я говорю, что этому CEL нужно установить pointer в now. То есть у нас там сейчас внутри нет никакого значения.
Ну и после этого мы вводим какое-то новое значение. Ну и возвращаем новый bad clone.
Вот такое вот хитрое что-то происходит. Давайте мы посмотрим, как это можно сломать.
Если что, мы будем пересматривать слайды, если нам будет плохо понятно, так что не волнуйтесь.
Вот. Создаю какой-то CEL, потом я создаю, ну делаю, устанавливаю значение CEL set сам bad clone.
Ну и создаю bad clone соответственно. Какое-то значение у дейта есть и ссылка, это просто ссылка на текущий CEL.
То есть по сути у меня на данный момент CEL указывает сам на себя, так. А потом я делаю CEL get.
Когда я делаю CEL get, то в таком случае у нас происходит clone внутри.
Потому что мы запросили теперь вместо copy clone. И соответственно получается, что у нас начали эти выводы работать, так.
Мы пришли к этому коду, когда сделали get. Понимаете, да?
Итак, у нас сейчас в дейте написано какое-то значение, а указатель — это нас же текущий CEL.
Итак, и вот теперь мы берем какое-то, дейта — это ссылка на наша текущая данная,
выводим наша текущая данная, которая у нас есть, там 1, 2, 3, 4, 5, 6, 7, 8.
Потом говорим, что наш текущий CEL мы убираем просто, за нуляем.
И после этого выводим его заново. Но дело в том, что он сам на себя указывал.
И получается, тем самым вот user имплементировал такой от clone
и получил undefinedBehaviour. Это один из возможных только выводов.
Ну вот, например, ноль может вывестись. Соответственно, если у нас CEL будет с clone,
то тогда это будет unsound. Unsound, напоминаю, означает то, что наша абстракция не является safe.
Ну ты очистил CEL, который содержит дейт.
А если бы мы свой CEL реализовали, то тогда что бы у нас вышло при запуске?
У нас там паника была или что?
Если бы мы реализовали свой CEL с clonem?
Да.
Ну вообще у нас это было бы safe, на самом деле.
Мы сейчас увидим, как это работает.
Там внутри CEL используется такая штука, называется unsafeCel.
UnsafeCel – это просто то, что направо и налево нам раздают указатели.
Она просто ничего не проверяет.
Короче, проблема в том, что когда мы сделали CEL, ну у нас вот эти CEL поменялся незаметно.
Да, у нас поменялся CEL, и соответственно, то, что мы дальше делаем, просто не валитно.
Поэтому очень тяжело разрабатывать раз бывает.
Ну не разрабатывать на раз, а разрабатывать именно раз,
потому что вам нужно подумать о том, как сделать вашу абстракцию обязательно sound.
Давайте чуть-чуть точним.
Если вы пишете только safeCode и пользуетесь тем кодом, который safe,
то в таком случае у вас любая абстракция будет sound,
потому что вы использовались safeCode.
Если вы пользуетесь unsafeCode,
то вы должны убедиться в том, что ваша абстракция вокруг unsafeCode – sound.
То есть то, что она безопасна и то, что она при любом импуте,
не будет давать вам memory, unsafety, undefinedBehaviour.
Это пример того, как можно было бы сделать unsound на стандартной библиотеке.
Просто вы запросили forCell вместо copyClone.
Теперь юзер может сделать себе undefinedBehaviour, просто что-то неправильно написано.
Ну вот непонятно, зачем людей на нём ссавят вообще.
Как его можно использовать?
Мне кажется, вещи просто выкатывали или нет?
Да, мы сейчас увидим это.
Вообще вы, например, можете это увидеть в задачах домашних, в MPC, например.
Там используется refcell для того, чтобы какой-то shard состояния поддерживать.
Мы его хотим мутировать, и для того, чтобы это было безопасно, нам нужно использовать refcell.
Я не буду спорить с тем, что на самом деле interiorMetability в однопоточном Rust-е – это overhead.
То есть это вынужденная, скажем так, боль, которая появляется из-за того,
что он хочет с одной стороны что-то через ссылку менять,
и с другой стороны Rust хочет оставаться safe.
Поэтому появляется вот такой вот компромисс в виде cell и refcell вынужденной.
Поэтому это, наверное, та вещь, которая закономерного может не понравиться, действительно, в Rust.
Вот, есть ещё refcell.
Кстати говоря, вам же всё понятно, что мы сами себя убили только что.
Получается, когда мы вот такой вот код исполнили, pointer set.
Ну если что, посмотрите ещё, пересмотрите дома.
Рисуйте и увидите, что там очищается.
Вот.
Refcell отличается от cell тем, что он возвращает ссылки.
То есть он, если мы обновляем объект, он действительно туда моет объект,
а если мы делаем get, то он вернёт ссылку, а get.mute вернёт, соответственно, табельную ссылку.
Ну, на самом деле это, конечно, не get, а get.mute называется, а чуть по-другому.
Ну и, соответственно, там внутри мутабельной и немутабельной ссылки подсчитывается,
чтобы вы не сделали две мутабельные ссылки и, соответственно, не сломали фундаментальной гарантией Rust.
А, да.
Это варантейна, после которой происходит проверка тегажей гарантии?
Да.
Очень хорошо.
Коператор просто не может проверить то, как ты пользуешься refcell,
и приходится идти на такой к нам промес.
У нас есть тут get и get.mute, а borrow, borrow.mute, которые возвращают какие-то ссылки на внутренний объект.
Как вы можете заметить, это какие-то обёртки, не просто ссылки,
а ref и ref.mute, которые при дропе будут что-то менять в сейдле, то есть счётчик внутренний.
А get.mute это делает?
Get.mute возвращает мутабельную ссылку,
но он спаникует, если у тебя уже есть мутабельная ссылка, либо шаред-ссылка.
Сейчас, можно вопросить про cell?
Как мы вообще будем изменить int, например, если у нас rc или cell int, да?
Я хочу его изменить.
Ну, просто напишешь rc set и внутри поменяешь int.
А, там не изменится set, окей.
Просто такой вопрос, почему не всегда использовать ref cell?
Ну, cell просто бывает эффективнее, когда у тебя небольшой копия типов.
Ref cell именно ссылку возвращает.
Тебе, возможно, не захочется ходить по ссылке лишний раз.
Конечно, компилятор это соптимизирует с большой вероятностью, я не проверял, честно.
Но кажется, что если вы в ref cell запихнёте int, то тогда он будет работать как просто cell.
Просто потому что.
Хотя по ссылке же всё равно, нет, он не соптимизирует это.
То есть cell просто бывает эффективнее.
Да, get mute, он проверяет, что ты действительно можешь сейчас получить мутабельную ссылочку.
Ну, boro mute возвращает какую-то обёрточку ref.
Она работает точно так же, как обычная ссылка.
Но когда ref выйдет за свой scope, то есть drop произойдёт,
оно тогда сделает минус в кантере внутренней ссылки.
Boro mute, соответственно, сделает то же самое, только если boro считает shard ссылки,
то это будет unique ссылки считать, mutable ссылки.
Нет, не можешь.
Если ты сделаешь второй раз boro mute, то в таком случае ты спаникуешь.
А, там же ещё ref mute, оно может завершиться.
А, да, оно спаникует, а там ещё есть try boro, try boro mute, которые возвращают ошибку.
То есть не паникуют, а именно ошибку возвращают.
Get mute и boro mute, в чем заключается?
Ну, get mute, он именно проверяет то, что у тебя вообще ничего другого нет
и паникует в случае, если не получилось.
Не, погоди.
Здесь видишь mutable и boro самого селфа происходят ещё внутри.
Get mute.
А где?
А где?
А где?
А где?
А где?
Вот именно и boro самого селфа происходит ещё внутри get mute.
А здесь происходит обычный boro селфа.
То есть компилятор может на этом уровне ещё проверить.
Так, просто, зачем мне вообще get mute когда-то использовать?
get mute когда-то?
Может, когда-то захочется.
ты просто знаешь, что у тебя сейчас гарантированно
один экземпляр, ну то есть нет вообще никаких экземпляров ссылок
возможно тебе GetMute будет полезно сделать, чтобы
иметь полный доступ
ну да, GetMute эффективнее, потому что вместо счетчика ссылок
у тебя компилятор есть
ну и как я говорю, что достаточно такой распространенный паттерн
использует cell и refcell вместе с rc
rc для того, чтобы у нас
rc сам по себе был safe
ну, sound, abstraction, то он внутри
делает немутабельными объекты
свои, а для того, чтобы их мутировать, вам нужно
использовать cell либо refcell
очень отдаленно напоминает ключевое слово mutable в плюсах
но на самом деле это не так, конечно
как-то так
вот, это здесь можно видеть пример
того, как можно внутри листа
ну, то есть как можно имплементировать лист
на rc и refcell
только он будет неэффективный, лучше так не делать
то есть вообще в расте, писать в safe.raste
любые структуры, которые друг другом владеют
то есть здесь по сути две ноды будут друг другом владеть
плохо, не надо так делать
дерево?
нет, у нас еще объестий нет
объестий не нужно писать
там бор, там не нужно
ну, Боря, там эксклюзивное владение
на все, а здесь получается друг другом владеют
и соответственно получается, что нужно
чтобы ты в runtime пересчитал все эти ссылки
раз, к сожалению, можешь проверить это в compile time
и заставлять тебя проверять это в runtime
да, но они же друг другом не владеют
ребенок не владеет родителем, например
я буду исключительно вниз
как же внутри работает refcell?
как я уже сказал, там внутри используется unsafe code
там есть такая штука, называется unsafe cell
это будет такая небезопасная структура, которая
не будет вообще ничего проверять, она будет просто нам
строго возвращать какие-то указатели, ссылочки
по нашему желанию
это будут наши безопасные обертки вокруг этой структуры
сейчас вот то, что мы посмотрим
в домашней не используйте unsafe cell, во-первых, вы не сможете
нормально попользоваться, потому что она unsafe
во-вторых, в общем, пожалуйста, не пытайтесь
это я просто вам показываю на данный момент для развития
вот, unsafe cell выглядит так, максимально глупо
там внутри просто значение какое-то, типа T
а еще вопрос, а почему в стандартной библиотеке
это связанный список не реализован?
он реализован в стандартной библиотеке
двухсвязанный, там же вроде двухсвязанный есть
как раз там даже в библиотеке лист, который
есть двухсвязанный
у нас есть такие вот функции, которые возвращают
либо pointer, либо ссылку
на T
ну и, соответственно, они
являются все небезопасными, поэтому вы не сможете
нормально попользоваться этим всем делом без unsafe кода
для этого вам нужно, в общем, гарантировать
гарантии REST, а давать самостоятельно своими руками
соответственно, правильное определение cell и ref cell
это выглядит примерно вот так
cell, соответственно, внутри просто содержит это же значение
с помощью unsafe cell, ну и его заменяет
ref cell, как вы можете заметить, вот имеет какой-то
boro flag и внутри unsafe cell
интересно, почему здесь вот у boro есть
сам используется cell внутри ref cell
как вы думаете, почему так?
а почему
не просто boro flag?
ну смотри, boro flag, наверное, где-то есть
а нет, ну в общем, boro flag может считать, что там
это просто yinam, на самом деле это не yinam
в стандартной библиотеке, но это неважно, это означает
одно и то же, внутри написано либо то, что
нет никаких ссылок, либо какое-то
количество shared ссылок какое-то указано
либо mutable ссылка одна
ну то есть там три варианта yinuma, с двумя понятно
и у shared ссылки там еще число сколько shared ссылок
ну, я не очень понял, что ты сказал
все дело в том, что
когда имеешь несколько ссылок, то
для того, чтобы сам вообще вот этот вот
вот этот вот флажок boro поменять, нужно через ссылку пройти
то есть у вас interior rentability идет сам ref cell
в данном случае
поэтому приходится здесь тоже фигачить cell
ну давайте сам еще раз
так как мы не можем проверить наши варианты компиляторам
и все это сдвинуть в runtime
проверять в runtime
в случае cell мы просто копируем значение
ну и заметили то, что мы не можем использовать clone
потому что это небезопасно
в случае ref cell мы просто даем какую-то ссылку
и считаем в runtime, чтобы все было безопасно
а вот C++ у нас
ну мы все равно должны подчиняться орднершупу
потому что если мы не будем им подчиняться
то у нас либо будет совсем не поддерживаемый код
либо у нас будут какие-то баги
ну в общем-то в плюсах вы это должны руками поддерживать
то, что вы правильно модифицируете через ссылку
и у вас ничего не ломается
несмотря на то, что вы можете сделать ошибку, это на самом деле быстрее
и использовать меньше памяти
то есть если вы хотите использовать такой же в плюсах
то вам нужно будет использовать unsafe код
то есть если вы, например, захотите написать тот же самый лист
вам нужно использовать unsafe код, потому что там есть
ноды, которые владеют друг другу
ну и вот такая вот общая фраза
unsafe дает вам силу и ответственность C++
вот это конклюзион нашей третьей лекции
изучили, что такое трейты
что такое Exotic Size Types
ну подробно не опускались, но изучили, по крайней мере, что такое действие
знали какое-то количество трейтов стандартной библиотеки
сравнились с плюсами
и, надеюсь, поняли, что такое интервью табилитики
это правда, и я надеюсь, что вам понравилось
и я надеюсь, что вам понравилось
ну и вот и все, что у нас было
надеюсь, поняли, что такое интервью табилитики
это правда, или нет? Что-нибудь нужно рассказать?
в таком случае давайте перейдем к следующей лекции
на этой лекции мы изучим, что такое Cargo
и что такое модуля
научимся писать Rast code теперь уже не в одном файлике
познакомиться с Cargo и с тем, как он управляет пакетами, но только на
каком-то необходимом минимуме, а мы прям подробно искать не имеем.
Будем сравнивать с системой сборки из мира плясов?
Так, что ты сказал еще раз?
Будем сравнивать с системой сборки из мира плясов?
Это имеет мало смысла как-то. Ну посмотрим сейчас, увидим.
В принципе нам понравится, я думаю, Cargo, это одна из самых крутейших фичей
Раста. После овершипа, наверное, собственно, потому что он дает нам
безопасность Раста. Без безопасности Раст бы, наверное, был примерно
бесполезен, потому что какой смысл иметь язык, который все так же не
безопасен, и все, что у него есть, это пакетный менеджер.
Ну таких на самом деле уже много.
Ну это на самом деле дополнительная фича, которая делает Раст
крутым. Вот. Ну еще в конце, надеюсь, мы успеем
полностью поставить на иператоры.
На самом деле мы должны успеть, потому что Cargo это достаточно
простая и быстрая тема.
Вот. Cargo это пакетный менеджер Раста.
В C и C++ таких нет. Абсолютно вообще нет никаких стандартизированных
решений, там есть только какие-то разрозненные имплементации.
Пакетных менеджер так вообще очень мало, систем сборки еще какие-то есть,
но очень мало. Вот.
То, что делает Cargo, это качает ваши зависимости.
То есть, например, если вы какой-то крейт используете внешне,
то есть читаете внешнюю библиотеку в своем проекте, то вам достаточно
написать одну строчку в манифест Cargo, как мы сейчас увидим.
Компилирует пакеты за вас, то есть он вызывает за вас
компилятор Rasti.
Капит, собственно, ваши пакеты, ну, как сказать, распространяемые,
то есть публичными, заливает их на крейтсилу.
То есть, чтобы им мог воспользоваться любой желающей.
Ну и всякие другие вещи. Там есть, например, conditional compilation.
Там можно писать произвольные скрипты для сборки, build scripts.
Можно прикручивать другие языки, например, C.
Вот. Ну, это мы все когда-нибудь посмотрим.
Так, у меня чуть-чуть съехал, вот здесь вот мои нарсировали.
Вот.
Crate – это compilation unit Rasti, то есть это единицка компиляции.
Это примерно то же самое, что и пакет в других языках.
Ну, вы, наверное, слышали, что такое пакет, там, кого-нибудь Go.
Это похоже.
Вот это вот то, что можно сделать с помощью команды Cargo New Bean.
Example.
И получается примерно вот такой вот.
Вот такого вида папочка.
Если что, внутри Cargo Log по умолчанию не будет.
Я вам показал, чтобы вы заранее обратили внимание,
что когда вы что-то собираете, у вас еще появляются файлы Cargo Log.
Мы посмотрим, зачем он нужен.
Если он именно после сборки появляется.
Да, после того, как ты первый раз собираешь пакет.
Пакеты могут быть наши, ну, крейты, загружены на Crate SEAL.
Это то, что поддерживается в комьюнити Rasta.
Это Crate Registry.
И в нем доступны все самые популярные пакеты.
Ну, там, например, будем в какой-то момент изучать всякие от Tokio, Cert.
Что там еще интересного есть.
Хочу сказать, это что-то, что делают параллельные тераторы район.
Вот вспомним о зоне.
Мы будем смотреть на такие вот прикольные крейты,
которые на самом деле настолько крутые,
что в итоге даже увеличивают число платформ,
на которых можно исполнять код.
Я подробнее объясню, что это значит на соответствующей лекции.
Там просто есть интересная статья в этом.
Так, ну, вот примерно так выглядит файл Cargo ToML.
Наверное, вы когда-нибудь у него заглядывали,
когда делали домашку, что это такое.
Как видите, ToML-формат
это какой-то очень простой формат.
Если вы знакомы с форматом имя,
то это практически то же самое,
но стандартизированное и, в общем-то,
такой простой, хороший формат,
в котором можно описать какие-то зависимости.
Вот у нас есть такой вот package.
Это как оно называется?
В общем, entry.
Есть entry-package, есть entry-dependencies.
У нас здесь указано имя пакета,
версия нашего пакета,
edition пакета, мы сейчас узнаем, что это.
И в dependencies я указал, для примера,
пакет clap называется,
который предназначен для того,
чтобы парсить аргументы с командной строки.
Например, на нем написан ровер.
Вот, так.
Cargo ToML содержит в себе несколько entry.
Это некоторая часть из них.
Package может быть имя пакета,
версия пакета,
указано списком автора пакета,
edition само Rasta,
версия компилятора минимальная для сборки,
билд скрипты и прочее.
Ну скрипты, они тоже на Rasti даже пишутся,
и там можно собирать произвольный код,
который даже не растовый.
Потом есть dependencies, понятно,
всякие версии пакетов,
необходимые фичи,
что такое фичи, тоже посмотрим.
А фичи,
сам entry у нас фичей означает
какие-то дополнительные возможности
нашего корыка пакета.
Ну, например,
давайте дальше по лекции покажу.
У нас есть целая глава про фичи, посмотрим.
Вот.
Можно всякие написать,
для dev, release, test и bench
профайлов,
написать то, как их компилировать.
Например, сделать так, чтобы у вас
всегда на O3 компилировался
профайл dev,
то есть это ровно означает debug.
То есть, если у него пишется профайл dev,
внутри укажете, что вы хотите,
чтобы он компилировался
с максимальной оптимизацией,
то карга это сделает.
По умолчанию, если что,
там оптимизации нет никакой.
То есть, вы можете указать для каждого профайла,
как он компилируется
и указывать даже новые какие-то профайлы.
Вот.
У крейтов есть несколько типов крейтов.
Во-первых, bin – это, соответственно,
просто приложение,
runnable, executable
и lib – это compiler recommended trust library.
Оно имеет тип
одной из следующих библиотек,
которые четыре снизу указаны.
Компиляторы выбирают среди них
в зависимости от того,
что вы компилируете,
как вы компилируете,
под какой платформе и все такое.
Вот.
Есть динамическая библиотека RAST.
Это какой-то растовый формат,
в котором динамически линкуется.
Кстати, lib – это уже статическое
системная библиотека.
cdlib – это, соответственно,
растовый код,
компилируется в какой-то библиотеку,
которая может быть вызвана
даже си, не динамическую.
rlib – это такая статическая
растовая библиотека,
которую вы можете переликовать
в своей программе.
Вот.
Ну и, соответственно, bin…
процмакро еще есть тип.
Мы с ним познакомимся буквально
примерно на следующей лекции,
узнаем, что такое макросы процедурные,
и будем их писать.
Вообще предполагается,
что bin и lib
будут хватать примерно
для всех ваших типов проектов.
Но если вам захочется,
то вы можете указывать
более конкретно,
как вы хотите,
чтобы ваш проект компилировался.
То есть вот эти все типы,
они вам нужны
только тогда,
когда вы хотите
что-то ручками очень точно поменять.
Вот.
Версии в Cargo.
Вот мы видели версию
нашего пакета,
версии наших зависимости.
Они все изменяются
согласно такой штуке
«назвать всем вер».
Вы слышали о ней?
Ну, вот так вот,
примерно слышали, да.
На самом деле,
это такой индустриальный формат,
который используется
во многих пакетных менеджерах.
Например, в npm используется.
Вот.
Он выглядит так.
Там есть…
Ну, на самом деле,
я рассказываю его вариацию
для Cargo конкретно
в немножко упрощенном виде.
Вот.
Там есть такие вот
три циферки,
три числа.
Мажор,
минор и патч.
Мажор – это
мажорная версия.
Она показывает,
что вы сделали какое-то
изменение API,
которое, в общем-то,
изменяет тотальное поведение
вашей библиотеки.
Например,
поудаляли какие-то
публичные функции,
добавили там,
не знаю,
полностью переработали
то, как у вас
это работает,
и так далее.
Минорно – это когда вы
добавляете какой-то
функционал,
и это обратно совместимо.
Ну, то есть, например,
добавили новую
публичную функцию,
в которую он добавляет
каких-то фичей,
но при этом не ломает то,
что у вас уже есть.
И патч – это, соответственно,
когда вы делаете
какие-то багфиксы.
Вот.
А что значит must be changed?
Вот это хороший вопрос.
Потому что кажется,
что ничто не мешает
версионировать как дату.
Нет, смотри,
на самом деле мешает.
Да, и что?
Во-первых,
потому что,
ну,
вот это вот
cal-ver,
по-моему, называется,
когда ты как календарик
это меняешь,
это на самом деле
не соответствует тому,
как устроено вообще,
в общем,
как устроено
версионирование пакетов
всем вере,
то есть они не совместимы.
Это, во-первых,
во-вторых,
cargo,
он, соответственно,
выбирает версии
ваших зависимости.
Ну, мы там посмотрим
буквально на следующем слайде,
как он будет менять
эти вот,
выбирать эти зависимости.
Это не соответствует
тому,
как выбирает
и резолвет
зависимости cargo,
соответственно,
сломается компиляция,
если ты видишь,
как cal-ver.
Ну, это так,
небольшая проблема.
Ну, ты можешь, конечно,
это делать
для какого-нибудь
своего бинарника,
потому что бинарник
он только для тебя,
грубо говоря,
никакие зависимости
ему не пользуются.
Ну, тут такое дело,
что если ты пишешь
в библиотеку,
строго следует всем веру,
потому что
это, по сути,
единственный недостаток
всем веры,
то, что люди
вынуждены ему следовать.
Если они
что-то ломают,
например,
меняют
мажорную версию,
когда они сделали
backfix
или, например,
сделали backfix
и,
не так,
давайте поменяли
там, допустим,
API,
при этом
поменяли
мажорную версию.
И в таком случае
cargo, он считает,
у него есть контракт,
что вы всем верам следуете,
он поменяет
образом версии
и у вас ничего
не скомпилируется.
Все.
Ну, то есть,
это очень-очень важно,
следовать именно
строго всем веру.
Это его
серьезный недостаток,
потому что,
если вы от него
отходите,
то в таком случае
все начинает ломаться.
В остальном,
всем веры – это прекрасная вещь.
Вот.
Так.
У нас есть
ну,
примеры того,
как у нас
должна меняться версия.
Например,
у нас была
версия 1.3.7,
мы сделали какой-то
backfix,
стало 1.3.8.
Была версия 1.5.5,
добавили какие-то
новые функции,
стало 1.6.0.
То есть,
зановили версию патча
и поменяли
минорную версию.
Ну, соответственно,
мажорный там апдейд,
там очень сильно
все поменяли
и поменяли версию
1.7.2 в 2.0.
Как-то раз вот,
не помню,
какая библиотека была,
но было такое,
что они поменяли
версию на 2.0,
но было очень много
пользователей,
которые оставались
на 1.x,
в общем,
дальше в версии.
Для того,
чтобы такого не было,
что они поддерживают
код из старой и новой,
они сделали так,
что следующая версия
1.x,
она просто
оборачивала
вокруг себя
API 2.0 версии.
То есть,
таким образом,
они продолжали
поддерживать только
новую версию API,
но при этом
старые пользователи
продолжали пользоваться
кодом в том виде,
в котором они
пользовались им до этого.
Так,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
chaos,
chaos,
onu,
ой вот это
ой вот это
ой вот это
ой вот это
ой
ой вот это
ой вот это
ой вот это
ой вот это
ой вот это
хо
пе
пе
ой
про
ид
релиз поэтому версия мажорная часто нулём является в рамках раз-то ну если
вы будете смотреть на карито и в этом случае у карга есть специальное правило что если
у вас мажорная версия ноль то в таком случае minor то есть вторая циферка это
мажор а патч это minor
ну смотри ты только-только сделал свою прекрасную библиотеку она у тебя не
финально ты будешь каждый день там менять и полностью ломать в ней аппи как
хочешь но ты хочешь ставить мажорную версию нулём потому что если ты сделаешь
единичкой то в следующем релизе понадобится сделать согласно симвера уже
двоечкой потому что ты там серьезно что-то поменял
да то есть карга этому соглашению следует в таких случая кстати говоря
советуют выкладывать свои библиотеки на гитхаб то есть там можно написать из
какого репозитория из какой ревизии вы качаете свой пакет собирайте ну то есть
использовать именно ну в общем гит репозитория не заливать на крейтс его
потому что иначе в таких случаях людей может быть не предсказуемый спецэффекты
что у них обновилась версия и вы там все сломали вот когда все часто меняется
там начальных этапах достаточно сложно у нас тут что-то сломалось да это это
должна была быть вот это вот это да она что-то уехала так карга то мл если вы
будете писать не просто версию напишите то есть если вы напишите версию то карга
будет выбирать любую совместимую то есть по сути это то же самое что вы
напишете вот эту вот галочку семер компейт будет то есть соответственно
если вы напишите 1 2 3 то в таком случае карга выберет любую версию которая
меньше 2 0 потому что они подходят потом если вы напишите тильду который тут не
видно то в таком случае он будет выбирать по последней только циферки то есть под
циферки бак фиксов
может погромче смотри здесь ведь dependences здесь можно написать конкретную
версию либо крышечку и конкретную версию в таком случае у тебя карга
будет выбирать любую версию меньше чем 4 0 то есть он скачает любую там
последнюю которая есть на крейтс его и будет именно с ней комплирует твой
пакет
вот ну то же самое стиль да и у нас будет изменяться только минорная версия
абсолютно аналогично вот со звездочкой любая любая минорная может написать
больше ли бы равно 1 2 тогда карга уберет вообще любую версию который больше
либо ровно текущий вот
нас кстати говоря всех задачах написано больше либо равно не знаю на
сколько это хорошо но я подумал для вас что лучше если вдруг серьезно
поменяться библиотека я это прямо знаю и прям починю что-то в задаче чем если
она будет постоянно одной версии когда я буду во второй раз проводить курс у
нас там неожиданно сломать половину задачи
теперь давайте выясним что такое карга тмл и карга лог то мл он объясняет
какова зависимости на так в общем смысле например указываете что я там хочу
версию 3 0 да и в таком случае карга будет соответствующий всем вер версию
меньше четырех выбирать карга лог это уже соответственно карга как пакетный
менеджер он же рисовывает прям зависимости какие там нужно пакеты
прелинковать что как скомпилировать и карга лог содержит конкретно какую
версию нужно скачать и к чему я нужно присобачить то есть это уже результат
какой-то работы карга это не нужно руками изменить вот вот как раз узнаем
сейчас вообще цель карга лог это объяснить указать какие были версии
зависимости в последний момент когда у вас пакет успешно собрался но это очень
ну в общем-то очень хорошо хорошо добавлять например в гид этот файл
и карга лог когда вы например бинарник какой-то собираете вот если чтобы у вас
пользователь просто скачал ваш библиотеку просто собрал то есть там
зависимости вы зарисовывались точно так же как у вас точно также собралась
библиотека и все ура с теми же зависимости
это неправда это в гид игнор не нужно добавлять в случае бинарников а вот
в случае библиотеку как раз лучше добавить потому что библиотека от нее как
раз зависит пакет то есть у нее есть какие-то даун стрим пакеты которая ей
пользуется соответственно если вы укажете там карга лог в таком случае у
карга карга будет не очень хорошо когда он увидит этот блок файл он будет
вынужден использовать какие-то дополнительные дополнительные пакет
скажем так библиотека просто не видит всей ситуации и хочется видеть
конкретно в общем лучше чтобы именно бинарник создавал вот этот весь лог
файл вот потому что он видит всю ситуацию какие у него зависимости какие
зависимости у зависимости там все рисовывается и создается конкретный
файл а вот в случае библиотеки это уже неправда потому что она знает только
там не дальше своего носа что чем она пользуется тем она максимум
руководствуется поэтому лучше всего не добавлять карга лог файлик карга лог
в гитагнор в случае библиотеки это понятно
это просто то что в конце сделает карга во что скомпилировать не по сути ты
выбираешь только либо бин либо лип ты можешь выбрать конечно и там ди лип
да тебе большинство ситуации либо бин либо лип хватит это просто для общего
развития показал
так есть еще такой такой бинарник карга эдит вы можете его поставить с помощью
карга инстал карга эдит и сможете модифицировать свой файлик карга то мэль
может обновлять в библиотеке в карга то мэль то есть сам парсит ваш файлик то
мэль и ходит на крейс и усмотреть какие последние версии пакетов и заменяет их
просто иногда бывает полезно воспользоваться тем бинарником он за вас меняет
версии
например upgrade еще все все зависимости на последний меняет версию
так интересно вот у раз тоже тоже есть версии вот последняя стабильная 1.59 и на
самом деле тоже 1.59 но в случае nightly там 1.61 кажется то есть это только для
раз на самом деле тоже меняет свои версии согласно всем веру до версии 1.0 раз
точно также как и вообще любое любая библиотека любое приложение она очень
часто менялась очень сильно меняется любое приложение и раз тоже менялся ему
было сложно дать какие-то гарантии пользователям там плыть до того что если
вы посмотрите какие-то ранние версии раз-то совсем не похоже по синтаксису
разве что только по идее что хочется в конце иметь ну после того как раз
дошел до 1.0 ему нужно было принять решение как же дальше
будут меняться версии чтобы дать пользователям гарантии что у нас код
будет хорошо компилироваться то есть вы написали например программу что она
вас компилируется на каких-то более поздних версиях компилятора
вот для этого они перешли вот на такую штуку которая называется она вот модель
стабильность без голодания
простой на стабильность просто это модель была впервые появилась в веб
браузерах и используется конкретная модификация для именно компилятора самого
вот это наверное так все чтобы вы не сделали ну то есть все что не делается в
компиляторе раз-то оно сразу же приземляется так в мастер бранч сразу что
да мерзится и все каждую ночь каждый день ночь не знаю по какому времени это
происходит но в общем-то мастер превращается в на это и релиз как вы
понимаете если что-то только закомитилась там может потенциально
например что-то сломаться поэтому на эти это небезопасная штука и на ней но ее
нужно выбирать осознанно чтобы у вас если что-то сломать то сам виноват в
общем-то вот только стейбл вам дает какие-то гарантии
каждые 6 недель создается бета из текущего состояния мастера и ну то есть
для того чтобы найти оно постепенно тестируется там какие-то бакфиксы
происходят в том раз 6 недель об давайте создадим из текущего на эти
релизы назовем его бэдкой потому что у нас появились за эти 6 недель новая
коммита новая фичи давайте мы сделаем новую версию
зима бета вот и и в общем-то другая прошлая бета то есть раз 6 недель тоже
происходит прошлая бета становится стабильным релизом раз то есть раз по
сути обновляется раз в 6 недель
вот так что каждый день выходит
это на это но у него же тоже есть версии ну да
точно также как и вообще у раз то есть например следующая стабильный релиз раз
то по моему должен быть 1 61 что-то вроде бы не вроде бы 1 61
ну то есть найти он версионируется а потом в какой-то момент просто
становится один из релизов стейбом как-то так примерно также работает во
браузере свое версионируем то есть вообще вкратце у вас есть три канала это
найти бета и стейбом найти это прям совсем нестабильно только вот работа
вышла и меньше суток бета это что-то что уже по крайней мере плюс-минус
опробировалась и прямо сейчас она является релиз кандидейт и стейбл это то
что уже пробировал с пользователем по крайней мере 6 недель всем все понравилось
и вот стейбл успешно работает вот ну и как вы понимаете раз в 6 недель у нас
раз раз 6 недель у нас какой-то апдейт в таком случае раз у нас на месте не
стоит и постоянно обновляется вот ну и соответственно некоторые возможности
которые только только появляются компилятор и на самом начало обозначаются
какими-то там обозначениями что это находится только на этли ну то есть это
анстейбл вот и для того чтобы у вас все работал то есть чтобы скомпилировался
какой-то код который есть только в на этли то он нужно осознанно указать что
я хочу включить вот это вот фичу то есть примерно также вы можете увидеть
это в задаче try там у нас есть в файле либо rc мы там включаем фичу который
собственно гад включает гад это generic associated types это то с чем вы
познакомитесь в этой задаче отдельно
иногда бывает такое что вам нужно обновить язык таким образом что какие-то
вещи просто ломаются то есть они не обратно совместимы например в 2018 году
добавляли ключевые слова асинка и вейт естественно код в котором были
переменные асинка и вейт он перестанет компилироваться потому что это ключевые
слова как же мы поступим с этим у нас же тогда сломается если мы просто выкатим
очередной раз релиз компиляция очень многих проектов для этого существует
такая версия называется editions это пример я сказал вот появляется такая
штука называется edition edition это по сути ну вот знаете c++ 20 c++ 17 14 вот
примерно точно также раз 2015 2018 2021
когда вы включаете определенный edition то в таком случае у вас во первых вы
можете edition столько вверх менять вниз не можете это по логичному причину на
самом деле потому что если вы так делаете то это breaking change потому что вы
перестали пользоваться каким-то новыми фичами на которые в общем сейчас
посмотрим пример хотя можно даже наверное сейчас ходить прийти например
если у вас функция какая-то публичная интерфейс и использовала синг потом вы
перестали ну в общем она перестала быть осин кто в таком случае у вас сломать
компиляция проектов других производителей вот ну как работает
editions когда вы включаете edition то у вас включается дополнительная
возможность и у раз-то какие-то слова становятся ключевыми какие-то появляются
новые возможности этот ну в общем этот выбор вы должны сделать осознан в карга
то мл по умолчанию все проекты убирают самый последний edition который доступен
в данный момент у нас я проектом прежде 2021 в 2021 вышел буквально вот этой осенью
то есть он совсем молодой вот ну и соответственно вы можете даже
компилироваться у вас может быть такое что у вас текущая версия компилятора
ну ваш текущий проект edition 2015 собирается ваша зависимость 2021 на
зависимость зависимости 2015 никому ничего не мешает так компилироваться просто если
вы не включите нужный edition то в таком случае у вас не будут доступны какие-то
возможности вот и все то есть получается что мы ничего не ломаем
пользователей с другой стороны добавляем какие-то серьезные новости
которые потенциально ломают язык если что наверное нужно это обмозговать и
потом спросить еще в чате но если есть какие-то вопросы прям сейчас спросить
ну да как стандарт плюсов
не когда выходит новый edition то все в новом edition
то есть это от дитев такая вещь
ты можешь сидеть на старом это правда не очень хорошо вот чтобы автоматизировать
эту миграцию на новый edition rast сделал так чтобы вам это было проще сделать
появляется команда cargo fix с edition который за вас фиксит большинство
проблем связанных с переходом на какой-то новый на какую-то новую версию да там
есть вот дальше пример там есть в расе есть row identifiers то есть после них
можно писать даже ключевые слова можете их писать в том числе
если вы стоите на только делать это не надо это скорее в таких вот случаях
по сути это единственный наверное случай когда он нужен row identifier
ну в общем это все делается абсолютно автоматически и удобно ну правда все
проблемы карга за вас не пофиксит есть некоторые вещи которые он не может
все-таки сделать и в таком случае вам придется все-таки руками
но это я конкретно про edition сейчас говорю fix edition то есть он фиксит
именно edition но новый так есть фичи ну то есть например вы можете сделать так
чтобы у вас появлялись какие-то новые возможности вашем крейте если кто-то
укажет грубо говоря как вы хотите чтобы комплировался ваш крейт вот ну это
например здесь вот у вас есть фича bmp bng iso и default точнее нет у вас есть фичи
bmp bng iso да после этого если у вас пользователь выбирает default то в
таком случае включается только iso в общем фича вот наверное не очень понятно
объяснил да смотри у тебя есть фичи называется bmp bng они пустые потому что они
просто что-то включают ну вот смотри у тебя есть ну пусть здесь будет bmp
написано и оно включит какой-нибудь bmp и начнет комплироваться ну соответственно
это какие-то скажем так root фичи вот это вот это уже над множество то есть ты
можешь включить фичу она включает под набор какой-то фичей необходимый для того
чтобы она работала ну да не аддитивно
так мы будем это обсуждать сейчас у нас будут модели дальше было бы лучше
наверное если бы я здесь написал кумить функцию включается функция при
условии какой-то фичи
ну да это это да больше похоже на и в дефа там есть лучше кфг ив такой в общем
мы им собственно и пользуемся но это чуть попозже обсудим когда будем именно
conditional compilation заниматься вот смотрите у нас есть такие вот фичи в
request библиотеке если что это прям строчка из ровера
request это каблиотека ну по названию можно догадаться что это как request
только с другим названием вот и здесь смотрите я включил какие-то выбрал
версию включил какие-то две фичи называется блокинг и мультипарт
блокинг мне включила по получению реквеста на синхронная библиотека она
написана на токио токио это такой считайте асио только на самом деле круче
токио умеет больше вот блокинг это включает блокирующие взаимодействия с
блокирующей отправлять запрос мне просто не нужно было писать их
синхронно в ровере поэтому я включил блокинг потому что ну так гораздо проще
код писать ну и мультипарт это возможность
какие-то джессоны от проводить то есть там можно бы скомпоновать запросы
отправить соответственно мне появились фичи там появились два модуля блокинг
мультипарт которые позволяют мне собрать запрос и отправить его
блокирующим указом без этого оно просто не скомпилируется скажет что
нужно включить фичу какой-то вот когда крейд комплируется он собирается со
всеми фичами которые нужны всем зависимостим его так и очень важный
вопрос есть но фичи аддитивно и как вы думаете что может пойти не так если бы
фичи были не дити ну то есть если бы я мог один крейд скомпилируется одним
набором фичей другой с другим ну не так вот ну смотрите я компилирую все фичи
со всеми необходимыми фичами и что произойдет если я допустим возьму
какую-то фичу и как бы как бы сказать наверное лучше просто сразу к примеру
перейти что-то объяснить
вопрос конечно хорошо построил вот смотрите давайте к примеру уже перейдем
нас раз частенько используется для эмбедд программирования
ну и некоторые крейд у нас содержит себе фичу новой стд такой которая
разрешает ну раз можно без стандартной библиотеки компилирует просто нужно для
эмбедд разработки и соответственно крейд и некоторые
предоставляли предоставляют если они не обновлены но стд фичу что же может
пойти не так из-за того что такая фича была вообще как вы думаете
ну ладно давайте отвечу у нас изначально ну стд это естественно на
множество новости и то есть новости где-то отсутствия стд когда вы
добавляете стд в таком случае у вас появляются какие-то новые возможности
правильно аддитивно соответственно если вы добавили фичу новой стд в таком
случае если вы фичу добавляете это у вас убавляются возможности незаконно да
а проблема в том что представь себе такую ситуацию у тебя есть два крейта
один использует твой креит который ты написал снова стд он использует фичу
новости д-2 крейт использует в честь иди карга считают что эти фичи не
аддитивно а дитина и соответственно он думает ага но я добавлю новость и д это
же только добавит возможности не удалит добавят новости здесь соответственно
крейт которые снова сидеть и скомпилируется и на ура а тот который требует стд то
он сломается просто потому что он требовал библиотеку и стеде мы ее отрубили только что
добавив новую фичу я думаю всех запутал
а зачем тебе отключать, может понадобится фичу?
Нет, лучше в данном случае нужно так сделать, нужно добавить фичу не новой стд, а и стд и по умолчанию включить сборку
в таком случае для всех пользователей будет собираться библиотека с стд а когда кто-то
потребует новой стд тогда он просто отключит эту фичу, соответственно в данном
случае крейт и оба скомпилируются на ура потому что у нас есть и с стд фичой и
с новой стд, они как бы друг друга дополняют два кусочка и у нас
скомпилируется оба крейта. Смотри, то что каждая следующая фича не убавляет
возможности, а добавляет. Это фича новой стд, это ошибка некоторых людей которые
раньше добавляли ее в крейт, то есть какие-то крейты вот люди неправильно
дизайнировали у них была фича новой стд, которая подразумевается просто по
названию, она не аддитивна, потому что она убирает стд и не добавляет, соответственно
карга думает, но они же аддитивны, подключу новой стд и все сломалось просто, вот так вот
ну это как раз то что объяснил
есть такая вот практика чтобы имплементировать какие-то дополнительные фичи как
фичи крейта. Например есть такое официальное Rasta API guidelines как писать код на Rasta, то есть
как дизайнить API. Ну и в общем-то там советуется что для своих типов пожалуйста сделайте фичу
который называется CRD и в которой появляются для ваших типов serialize и deserialize. Что делает этот крейт?
Ну возможно вы проходили курс по распределенным системам, вы наверное вспомните такую вещь
что вам для того чтобы посылать что-то по сети, вам нужно это в общем-то серилизовать, а потом когда
оно из сети вышло, десерилизовать. Вот CRD как раз то и делает, какие-то популярные форматы умеют
серилизовать и десерилизовать. В частности JSON, где-то YAML и подобное. Ну и Rasta API guidelines настолько этот крейт
популярен часто используется, что советую этому в общем-то добавьте пожалуйста себе эту фичу чтобы
пользователь при желании мог воспользоваться тем что у вас для типов имплементировано serialize
и deserialize. Так, в общем такая фича дает возможность пользователю как-то условно либо выбирать между тем
хотят ли они включить какую-то фичу и соответственно компилировать что-то или не компилировать. Как-то так.
Ладно давайте пойдем, это наверное последний слайд этой части. Мы все это время разговаривали
и просто взяли и забыли про Rasta API, даже ни разу не сказали про него. И знаете это на самом деле хорошо,
потому что мы все это время пользовались Kargo и даже не заметили то, что под низом там вообще-то
RASC валяется, который все компилирует. Вот если вы например пользуетесь C или C++,
вот не скажу конечно, что там вы не видите никогда GCC и Client какой-нибудь. Ну то есть,
ну это зависит от системы сборки, ну вообще в целом это в общем недостаток плюсов,
что вы постоянно должны знать о том, каким вы компилятором пользуетесь.
Да, примерно так бывает.
Есть ли у нас вопросы какие-нибудь по Kargo?
Ну наверное Kargo Ship, что-то такое типа Crate.
Это корабль, который ввозит, я себе представляю Overgreen корабль, как он называется.
Наверное примерно по этой причине. Ну и Rasta, знаете, там типа ржавчина,
как то ассоциируется с тем, что какие-то из Crate.
Теперь мы научимся разделять область видимости и писать все в нескольких пайлах.
Поднимите руки те, кому приходилось писать достаточно большие проекты на C.
На C писал только два человека, три.
Скажите, вы же сталкивались с тем, что у вас был namespace-палюша.
То есть вы несколько функций, одно название было у них.
Например, там вы брали две структуры данных, какой-нибудь лист писали и писали еще что-нибудь,
хештаблицу, у обеих есть какой-нибудь метод emit, и в итоге, когда вы импортируете два заголовочных пайла,
то в итоге у вас получается конфликт просто имена, в случае с C.
Вам, естественно, хочется иногда написать одинаковые имена, но для этого нужно как-то
разграничить область видимости. Например, сказать, что это относится к листу,
это относится к хештаблице и все такое.
В начале ты пишешь им модуль, и потом только в функции.
Модуль файбер, файбер и прочее, это работает.
То есть там есть что-то типа namespace?
Там есть namespace, но это не то, что убивает.
Я работаю там, где пишу только на C.
Ну вы, наверное, разбирайтесь, как это делать.
Я в любом случае знаю то, что в языке нет никаких напрямую возможностей.
То есть как вот я написал с Лизой.
У нас все были наследования.
Наследования все, это все.
У нас индекс B3, он написан на C шаблонный, он Define.
Он был написан на C шаблонный, его перебисали на C.
Короче, там все вот эти штуки.
Это жестко.
Так, давайте тогда продолжим пока что.
Ну, в общем, получается, я тогда немножко соврал,
что нет вообще никаких хороших способов решить эту проблему.
Все-таки, наверное, есть.
Он один, и он любит культуры коды.
Да.
Вот, в плюсах есть Namespace.
Namespace это, в принципе, достаточно простое.
И, в принципе, такой practical solution.
В принципе, к ним особо вопросов нет.
А что мы будем делать в расе для того,
чтобы запревенцировать Namespace в получении?
Ну, для этого есть такая штука, называется module.
Смотрите, визуально напоминает кого-то мы какие-то Namespace написали.
Еще было не очевидно, что эту модулю можно заплатить.
Вот, ну это, в принципе, можете считать, что это и есть Namespace пока что.
Оказывается, потому что это шире, чем Namespace.
Но конкретно на этом слайде оно именно так и работает.
Ну, например, ufu полное имя, соответственно, one nested nested 2fu
через двойные двое точек.
Это должно быть достаточно быстрая часть лекции,
потому что она простая.
Вот.
Ну, давайте попробуем воспользоваться useme.
useme вот, напоминаю, в модуле 2 находится.
Вот 2 useme.
Ну, давайте воспользуемся.
Упс.
Как же так вышло?
Приватная функция внутри.
Знаете, в плюсах, например, у нас были бы Namespace
и в Namespace все публично.
А здесь у нас приватная функция.
Нам прям так и пожаловались.
Давайте воспользуемся ключевым словом pub.
Pub, собственно, вот означает ровно это.
Сделай это публичным для всех parent modules,
ну, для всех модулей, которые сверху.
Вот.
То есть, например, если бы я написал pub struct fu,
то в таком случае я бы стал публичным
и в nested, и в one, и в corny.
Так.
Здесь я, соответственно, стал публичным в corny.
Вот.
Вот.
Вот.
Я, соответственно, стал публичным в corny только.
Заметьте, что в модуле 2
мне не нужно становиться публичным,
потому что это и есть мой модуль,
и внутри него я все вижу.
Вот.
Ну, давайте объявим структуру fu.
То есть вот one nested nested fu.
И теперь выясним, что у нас
модуль приватный.
Поехали вот эти вот штуки.
Здесь у нас должен приватный модуль, и вот здесь.
Ну, он должен показывать на nest.
Ну, он должен показывать на nest.
Ну, он должен показывать на nest.
Вот тут.
Ну, для того, чтобы сделать
своего публичного, нужно, естественно,
написать ключевое слово pub.
То есть получается, что
не так как C++, у нас
и модули, и все, что внутри,
оно по умолчанию приватно.
Ну, интересно,
почему так получилось, что он
взял и попросил у нас не one сделать
публичным, и не два,
как в прошлом случае.
А именно nested.
Как вы думаете, почему так происходит?
Ну, грубо говоря, да, первое препятствие.
Потому что у нас модуль, который лежит
внутри нашего модуля, он для нас публичен.
То есть сам по себе модуль, само имя
для нас публичен,
а то, что внутри, уже нет.
Точно так же, если бы у нас была структурка,
структурка была бы публична здесь.
Если бы я здесь снизу написал структурку.
1 и 2
это такие модули, которые находятся
в root-module. Это, собственно, то, что я сказал,
в корнях.
Нам не нужны никакие права для того,
чтобы иметь доступ
к чему-то, что внутри текущего модуля
находится. У нас всё публичное.
То, как раз о чём я уже сказал.
Давайте сделаем nested публичным,
допишем пап, там ключевое слово.
Потом, если мы попробуем это ещё раз комплектовать,
он скажет nested2 приватно.
Нам нужны, естественно, nested2 и
фу, сделав публичным.
По понятным причинам, они для нас приватны,
вот точно так же.
Как-то так это выглядит.
Обратите внимание на то,
что фу...
В общем, если мы
не допишем пап в nested2,
то в таком случае
это не сделает
публичным,
потому что у нас есть препятствие
в виде модуля nested2, который для нас приватен.
Понятно ли это?
Так.
Ну, теперь давайте попробуем добавить
поле bar. Вот здесь вот.
Bar находится вот тут, в модуле 2.
Вот он писал 2 bar, да?
Попытаюсь это скомпилировать.
Здесь опять, конечно, съехало всё.
Не знаю, почему так происходит.
Здесь должен быть 2.
Он говорит, что я не знаю
такого модуля.
А всё почему?
Потому что у нас в пути относительно.
То есть, если мы написали 2 bar,
то мы ожидаем, что здесь внутри nested2
есть какой-то модуль 2,
а внутри него есть, собственно, bar,
который мы ожидаем увидеть.
Если вы хотите, чтобы мы
смогли воспользоваться 2 bar,
то нам в таком случае нужно воспользоваться
ключевым словом create.
Ну, читайте это.
В общем, slash — это
корневая папочка, как в системах Unix.
В таком случае мы начнём
с root-модуля,
а не с текущего.
То есть, если он писал create
2 bar, то в таком случае я
сначала перепрыгну сюда,
потом зайду сюда.
Понятно?
Мы можем строить вот такие
fully-qualified names
либо относительно корня
от коневого модуля, либо
от текущего.
Ну, мы либо от текущего
относительным путём идём.
Ну, мы сейчас увидим, там ещё есть ключевое слово super
для того, чтобы к родителям ходить.
Вот.
А create — это строго в начало нас принесёт.
Так.
Блин, что-то не понимаю. Всё посъезжало,
хотя вроде нормально вставило.
Вот. Ну, он нам говорит, что вот это вот
поле приватное теперь.
Вот, видите, вот пробуем скомпилировать, говорит, нам bar приватно.
Если...
Вот мы попытались сконструировать full
и получили такую ошибку.
Ну, всё почему? Потому что у нас
собственно, поле bar приватное,
и нам нужно его сделать публичным.
У нас в получении структура
все поля приватные.
Это, например, правда ли
кого-нибудь вектора? Ну, вы помните, например,
что в вектор вы не можете заглянуть
в указатель внутри, потому что там всё
в получении приватное. Если вы хотите сделать
какое-то поле структуры публичным,
то вам нужно написать ключевое слово pub.
Постарайтесь это не делать лишний раз.
Ну, то есть, если у вас есть причина,
то в таком случае pub дописывайте.
А если нет, то лучше напишите там getter,
setter и какие-нибудь конструкторы
и так далее. То есть, не нужно открывать
пользователю внутри
свои поля. Ну, всё, в принципе,
точно так же, как и все плюс-плюс логически.
Так, и нам калом теперь поехал.
Влево.
Вот, смотрите, я написал pub перед bar.
И у нас теперь всё компилируется.
Давайте, наверное, ещё нужно будет
про отдых подумать.
Чуть-чуть.
Ну ладно.
Чтобы поле стало публичным,
иначе я не могу сконструировать, собственно, тип.
Ну, смотри, вот bar я использую здесь.
Так? Ну, я его сделал.
Да, вот я попытался создать
два bar.
То есть, создать foo, и мне, соответственно,
нужно bar передать.
Так как у меня вообще поле bar
приватно, то в таком случае не могу это сделать.
Мне пришлось pub дописать.
Так, ну давайте тогда отдохнём чуть-чуть.
Давайте добавим теперь
в наш инамчик вот такой вот вариант.
Example nest2 foo.
Ну что ж, как это будет работать?
Итак, ну вот,
получается мы создали bar,
потом foo,
и экземпла
сделали. Ну, естественно,
t будет one nested count.
Знаете, тут не так,
как в структуре.
То есть, в структуре нам нужно поля делать
публичными.
Как мы это делали в прошлом примере.
А
конкретно в этом примере
нам не нужно делать никакие
enumeration варианты публичными.
Потому что если он доступен сам enum,
то нам доступны все его варианты.
Теперь давайте попробуем
имплементировать mytrade для foo.
Это достаточно легко
так вот делается. Я пишу
impo create one mytrade
для текущего foo.
В расе нам не нужно
чтобы объект был pub.
Когда он
объявлен в одном из
родительских модулей.
Ну, то есть, соответственно,
mytrade, как вы видите, несмотря на то,
что перед ним нет ключевого слова pub,
я к нему могу иметь доступ.
Понятно, да?
Потому что он находится в одном из родительских модулей.
Теперь смотрите, как можно написать.
Помните вот это вот два двоеточия?
Это бывает полезно, например, если у вас
это в родительском модуле.
Когда вот так вот три модуля, то, конечно, лучше написать create two bar.
Ну, чисто для примера,
вот смотрите, можно
n раз написать super вначале.
Для того, чтобы куда-то уйти.
Это, по сути, то же самое, что
двоеточие, когда вы пишете в консоли.
В терминале.
Это будет работать абсолютно точно так же.
Обратите внимание, вот create тоже
супер-супер написал там, супер-супер-супер
два бар. Все отлично работает.
Теперь давайте я имплир
напишу в каком-то вообще другом месте.
То есть, не рядом со структуркой foo.
Мы так тоже можем делать.
Я не советую так делать.
Ну, раз нам это разрешает сделать.
То есть, смотрите, у нас
simple create one my trade
for nested foo. Неста два foo.
И вот оно отлично работает.
Ну, и сам foo можно имплиментировать в произвольном месте.
И нам ничего не нужно дописывать.
Кстати, здесь добавил self.
Тут есть ключевое слово self.
Давайте пока что прикинем, что его тут нет.
Потому что случайно здесь появился.
Если бы my trade был dev.
Да, да.
Потому что он был тогда не в родительском модуле.
Нет никакой.
Да, он все понимает, что
один импл на весь крейт должен быть.
Мы сейчас как раз об этом поговорим.
Да, может где угодно импл написать.
Окей, я хочу сделать несколько имплов.
Я такой хитрый, сделаю несколько имплов.
Мне что-то подсказывает, что
self я все-таки должен был в каком-то моменте объяснить.
И, возможно, что-то потерял случайно.
Давайте я на всякий случай скажу.
Если self здесь написано
в скобочках, то это означает то, что у вас видимость.
Вот папа говорит,
всем потомкам я виден.
А self говорит, я виден только своему родителю.
То есть я буду виден только внутри nested.
А внутри one я уже не буду виден.
И внутри родительского тоже не буду не виден.
Исключительно внутри
этого модуля и родительского модуля.
Так, ну давай сделаем несколько имплементаций.
Ну имплементация одного это уже трейта.
Для одного это уже фу.
Вот так вот.
Говорит, что
две конфликтующие имплементации.
Есть такая штука, называется coherence.
Что она говорит?
Она говорит о том, что у нас в любой момент времени
в крейте должна быть только одна имплементация.
То есть раз должен знать,
какую имплементацию он использует.
И там должна быть только одна, вообще
на весь крейт.
То есть более конкретно, вот
прям написано, что
for any given type of method
and method.
Что-что?
Теперь давайте прикинем,
что было бы, если бы я попробовал имплементировать
трейт-дисплей для типа boop
в библиотеке.
Помните такой для вывода?
Вот, а я теперь имплементирую его
для типа boop
самостоятельно.
Да, он уже есть, там уже выводится true
либо false с помощью дисплей.
Соответственно, раз такой
на это посмотрит, ты поймешь,
что вообще-то и в библиотеке есть
имплементации, и здесь.
И он, в общем-то, не может
выбирать рандомно. Он должен выбрать
какую-то конкретную имплементацию.
И мы должны как-то это все уравновесить для того,
чтобы у нас была в любой момент
одна имплементация, у нас ничего просто так не ломалось
в коде, да, и
в зависящем от нас в коде.
Давайте мы попробуем посмотреть на всякие примеры
того, как мы будем
разрешать имплементировать имплы.
То есть, в каких местах.
Как-то странно дважды повторились.
Очень странно. Я помню даже,
как писал. Здесь пример.
Ну ладно.
Я вообще ничего не понимаю.
Здесь абсолютно точно был пример.
Давайте тогда посмотрим
на этот сразу.
Смотрите, давайте
прикинем, что у нас есть два крейта.
Два крейта, один
содержит в себе.
Вот
два крейта, один содержит в себе трейт, это
крейт A. Крейт B содержит
в себе внутри структурку.
Давайте мы
в крейтах D и C
попробуем поимплементировать
этот трейт для этой структурки.
Если имплементирую
и в D и в C его,
в таком случае там будут какие-то разные имплементации.
В крейте I, который зависит
от D и C, у меня
все сломается компиляция, потому что у меня есть
две комплектующие имплементации.
И смотрите, эти крейты друг от друга
независимы. У нас по-прежнему одна
имплементация.
Одна имплементация вроде бы все правильно, но при этом у нас
сломалась компиляция. Мы не хотим, чтобы
так было. Поэтому нам нужно сделать
так, чтобы у нас
как-то разрешали имплементации
только крейты строго либо A, либо B
для структуры
и для трейта.
Это как раз
о чем я сказал.
Ну, знаете, здесь
для того, чтобы это пофиксить, у нас
будет вот такое вот правило.
Для начала давайте в простом виде
на него посмотрим.
В простом виде она говорит о B.
А в следующем, что мы можем сделать
имплементацию для трейта.
Имплементацию трейта для структуры
только там, где либо объявлен
трейт, либо где объявлена структура.
Только в этом крейте, либо в этом
крейте.
Если это один и тот же крейт, то в таком случае
мы можем имплементировать
трейт для структуры только в этом крейте.
Верно понятно?
Смотрите, здесь
NoteModule написано в скобочках.
Это как раз
о том, о чем мы говорим, что без разницы,
где вы имплементируете, главное, чтобы
это было локально для вашего крейта.
То есть конкретно
в данном случае мы могли
имплементировать
трейт только в
крейте B, потому что крейт A
ничего не знает о структурке, которая объявлена
в B, а B знает и о том трейте
и структурке. Он же имплементирует.
Если бы мы разрешили имплементировать
это еще для D и для C, то тогда бы у нас
сломались компиляции.
Поэтому с таким
правилом понятно. Только где объявлен
трейт, либо там, где объявлена структурка.
Трейт нужно имплементировать
для структурки. Понятно?
У нас есть такая штука, называется Blanket
Implementation. Это как раз то,
что мы изучали на прошлой лекции.
То, как имплементировать какой-то трейт
для всех типов.
Во-первых, мы сейчас
посмотрим на всякие exceptions,
исключение из правил
этого простого.
Только трейт, который может имплементировать
трейт, может имплементировать
такой Blanket Implementation.
Им уже не нужны никакие структуры,
никакие типы специальные, чтобы сделать импл
вот такой вот.
И, собственно, если бы мы разрешили
так делать,
то в таком случае у нас бы были
для разных типов, у нас же там
по всем типам пробегают, которые выполняют
какие-то условия. В конкретном данном случае у нас условий
нет, любой T подходит для моей
трейта. То есть, если бы там была написана
тема и копия, то в таком случае
мы бы имплементировали
mytrade для всех копий типов.
Если бы мы разрешили не только в нашем
крейте Blanket Implementation
писать, то в таком случае у нас
бы могло случиться
в третьем крейте, что
два Blanket Implementation подходят и опять
конфликт имплементации.
Выясняется.
Нам это не нравится.
Вот.
Поэтому мы...
Это правило 1. Blanket Implementation
можно писать только там,
где крейт... собственно, сам трейт
объявляет. Только крейт, который
объявляет трейт.
Во-вторых, есть фундаментальные
типы, для которых все равно хочется
имплементировать какие-то трейты,
даже несмотря на то, что они стандартные
библиотеки. Ну, ссылка
и ссылка на mute, наверное, даже
не так очевидна, как с боксом.
Ссылка и ссылка на объекты, это если вы сделаете ссылку
на T, это считается типом стандартной
библиотеки.
Ну, это же логично, потому что вы взяли...
Например, если вы сделаете век T,
это же тоже тип
стандартной библиотеки.
Даже если T это
ваш локальный тип.
Поэтому получается, что нам нужно какие-то
особенные правила для этого вести.
Ну, с боксом тут даже было бы понятнее,
чем с ссылкой. Ну, с ссылкой тоже,
как это пойдет. Вот, мы хотим имплементировать
такой трейд, который мы вскоре узнаем,
что это такое.
Называется intIterator
для myType, для ссылки
на myType.
Так как оба идут в стандартной библиотеке
и intIterator, и ссылка,
то в таком случае у нас бы
по нашим правилам,
ну, по нашему orphan rule старому,
который мы посмотрели на простенький, это бы не прошло.
Но так как мы
разрешили специально
имплементировать
для нашей ссылки на T,
где T это наш локальный тип,
в таком случае
все заработает, потому что myType,
в таком случае, ну, ссылка на myType считается
локальным типом.
Ну, более конкретно, здесь компилятор
делает так, он просто стирает тип
перед тем, как это проверить.
То есть, стирает ссылочку,
для него это локальный тип здесь.
Вот, как-то так.
Я надеюсь, вы поняли, почему
ссылка, ссылка
myTypeBox, во-первых, делает
тип стандартной библиотеки
из нашего локального типа,
потому что мы оборачиваем.
Почему мы хотим это имплементировать?
Потому что, если
мы не имплементируем, то в таком случае
мы, ну, в общем,
это слишком фундаментальный тип, чтобы не дать
возможность имплементировать для них что-то.
Вот, и какие у нас проблемы
возникают с базовым
орфандром.
Вот.
Также есть
какие-то такие
лимитированные случаи, когда нам хочется
для какого-то foreign type
имплементировать
наш trait.
Ну, вот есть from, который из стандартной библиотеки
myType, такой это наш локальный тип
для вектора i32.
Ну, и смотрите, здесь получается
from из стандартной библиотеки вектора,
из стандартной библиотеки i32, из стандартной библиотеки
под стандартным нашим правилом ничего не работает.
У нас ничего не локально.
Мы, тем не менее, понимаем, что
имплементировать это безопасно.
Потому что myType, он локаден для нас.
И мы хотим ввести какие-то специальные правила, чтобы
это работало.
Вот есть такой специальный правил.
Если у нас есть импл по...
Ну, это, наверное, будет не очень просто
понимать. Ну, если вы прошлого правила не поняли,
то, наверное, с этим еще тяжелее будет.
Здесь импл...
Вот, допустим, мы
генерик по какому-то списку аргументов.
Фарейн трейд тоже какой-то
список аргументов.
Ну, и для какого-то там t0 имплементируем.
Это можно сделать только в том случае,
если, по крайней мере,
1t и ti это локальный тип.
То есть, вот в этом списке
есть какой-то локальный тип.
И ни 1t
до этого ti
не является...
не является ни одним из этих
генериков.
Очень сложные правила. Его,
наверное, достаточно сложно было придумать.
Ну, то есть,
сам по себе правило, наверное, не сложное, но
придумать даже не знаю, как это можно было додуматься.
Но оно действительно работает.
Генерики можно
использовать в t0.ti
до тех пор, пока они covered
by intermediate type. Ну, что такое
covered типа, это если
они обернуты в какой-нибудь век t, например.
Как-то так.
Давайте посмотрим какой-нибудь
примерчик.
Вот у нас какие-то x, y,
и т.д., z это какие-то генерики,
по которому, в общем,
и a, b, и т.д.,
c это какие-то локальные по отношению к нам
типы. Вот
импл до x, y, z
написали for int rate. И смотрите, у нас
первый локальный тип где находится? Он
на второй позиции.
До этого у него не встречаются
никакие из этого списка генериков объекта.
Все хорошо, соответственно.
А дальше мы можем писать все, что захотим.
Вот b по отношению к нам
локален, c локален, век x можно
использовать, во-первых, потому что x уже можно
использовать. У нас локальный тип до этого
встретился, во-вторых, потому что век x это
covered type, то есть и то, и то.
Более того, вы можете написать век
x даже вот тут, то есть до h.
Потому что это был бы covered type.
Вот это такое правило, с которым
наверное вам редко придется
жить, но оно бывает полезно.
Так.
Давайте обратим внимание на то, что
имприментация вот такая вот,
то есть локал type для t
валидна, а вот t для локал type
не валидна. То есть
обратить внимание, здесь правило нарушается,
то что у нас локальный тип, а до него
есть какой-то generic из этого списка.
Чтобы было понятно,
почему это ломается, давайте посмотрим
вот на
такой вот пример.
Пусть у нас есть вот такая вот имплементация
в одном крейте, а
во втором крейте мы написали вот такую вот имплементацию.
Обратите внимание,
что у нас здесь вот their type,
ну это хоть и наш
локальный какой-то, но он же
вот здесь мой generic по нему, поэтому
their type может попасть сюда,
здесь вот мой generic по t,
соответственно, локал type может попасть сюда.
И мы получили, что у нас одинаково
для para-interade совпадает
в общем-то
имплементация. Все generic совпали,
соответственно, конфликтует имплементация.
Он как-то так очень хитро.
А здесь вообще полностью поехал форматирование.
Я вообще не понял, конечно,
я чинил, есть такое чувство, что
можно
по-быстрому это перекомпилировать, возможно.
Просто там, по идее, должно быть все уже нормально.
И что-то подсказывает, что это
подчинит нам все.
Еще можно на всякий случай.
Ну это, конечно, сильно.
В общем,
вот, по-моему, он подчинился, да?
То есть мы все это время жили просто
со слайдами, которые почему-то не обновились.
Ну ладно.
Там, кстати, возможно, еще есть примерчик,
который я хотел вначально.
Нет, это все-таки какой-то косяк, ладно.
Все, вернулись обратно.
Ну вот,
все, вернулись обратно.
Представьте, что мы это все поместили в LibRC
и опубликовали наш крейт.
Так как мы поместили pub до
one,
и one находится у нас в нашем root module,
то в таком случае у нас
все стало публичным,
то, что внутри находится.
То есть обратите внимание, если у нас это находится
в LibRC, LibRC
находится, ну, сам по себе является
корневым модулем.
И в таком случае,
раз уж мы написали pubmod,
то в таком случае мы стали доступными другим
крейтом, который нас импортирует.
Соответственно, другой крейт,
который от нас зависит, он бы мог
просто взять и, например,
дойти до
ну, до какой-нибудь, в общем, публичной
имплементации. Здесь конкретно
везде написано self-crate, и
в общем-то нам ничего не будет доступно.
Если бы здесь было pub, то в таком случае можно было бы импортировать
one-my-crate
из нашего крейта.
То есть это pub перед модулем
в данном случае, раз уж он
находится в корне, означает то, что
мы станем доступными другим крейтом.
Так.
В том числе, если мы не
используем foo, ну, это как раз
то, что я говорил, и здесь
можно супер дописать для того, чтобы
сделать, ну, мы стали публичными
только в нашем
и родительском модуле.
Да, и self
как раз означает
то, что только в этом модуле, вот.
Self означает то, что мы только в этом
модуле и родительском публичном.
А, сейчас, что-то я запутался.
Сейчас у меня, наверное, тут на красном слайде.
Что-то я не понял.
А, наверное, потому что все понял.
Супер, просто дело для нас
публичными на всю.
Ладно, короче, я уже
сам запутался как-нибудь.
Self должен в текущем модуле
сделать нас публичными.
Наверное, я, наверное, догадываюсь в чем
дело.
Не, не, не, не бессмысленно. Там, наверное,
просто в родительских модулях мы перестанем быть
видны. Я просто помню, что это тестировал,
я подзабыл, что там было.
Там у всего есть различия.
Вот, давайте я потом
в чате напишу.
Кроме того, у меня где-то есть пример.
Чтобы, ну, я к этой лекции
собирался вам скинуть прям пример крейта,
чтобы вы, вот это вот, все, вот, ровно то,
что мы на лекции с one nested могли
на это посмотреть и потыкаться.
Вот. Еще можно
с pubinpaf.
Ну, то есть, есть такой вот
in и какой-то путь.
Смотрите, путь должен быть обязательно
каким-то родителем.
То есть, я не могу написать там in
crate 2.
Я обязательно должен написать
один из подпутей моих.
То есть, in crate one nested.
И в таком случае я
стану для всех виден потомков,
которые не дальше,
чем этот crate,
не дальше, чем этот модуль.
То есть, таким образом я буду не виден в
корневом модуле,
не буду виден в корневом модуле,
но буду виден в модуле nested.
Ну, и точно, в том числе nested2 и
так далее.
Примерно понятно?
Так. У нас есть еще
keyword use.
И мы тоже пользовались.
Он предназначен для того,
чтобы какие-то имена импортировать.
Вот.
Ну, как это делается?
Например, давайте вот такую фигню
посмотрим.
Странно, кстати, что
у меня сразу же идет пример.
Ладно, use предназначен для того,
чтобы импортировать имена.
Вы уже пользовались им однозначно в домашке
и видели там, например, use, nested,
rc, rc.
Примерно такое.
Вот, смотрите, в этом вот конкретном
примере у нас есть
ля, внутри есть модуль b.
У нас тут есть енамчик какой-то,
функция, еще один енам
и структура. Везде, заметьте,
вот это вот приватное, здесь есть какие-то приватные
поля. То есть функция
поднимает на вход приватную.
Приватный элемент, енами приватная,
здесь вот структурка,
и в структурке здесь вот приватный,
приватное поле.
Ну, то есть поле публично,
оно сам тип приватный.
Если вы это попробуете компилировать,
то тогда раз вам не даст
тип,
который приватный,
вынести за пределы скопа.
Например, в плюсах,
если бы вы сделали внутри класса,
внутри private, объявили
какую-нибудь структурку, как мы сейчас
посмотрим, то
можно было бы с помощью публичной функции эту структурку
достать, потому что
доступность типа имени не одно и то же.
Обратите это одно и то же.
Вот.
Ну, здесь две такие ошибки,
и обратите внимание, здесь нет енама
в этих ошибках, а все потому, что он здесь.
Он в варнинге.
В отличие от структурки и функции,
в енамах можно использовать приватные
типы
внутри енама.
Но это пока что, потому что в дальнейшем
это уже будет
hard error, то есть уже
не варнинг, а именно ошибка.
Тут такое вот стоит у Rasta.
Была такая вот ошибка, и сейчас ее фиксит.
Как-то так.
Ну, это все плюс-плюс, как раз такой пример.
У Example будет, соответственно, тип
экзамп.
Так.
Теперь модули и файлы.
Вот смотрите, у нас была вот такая структура,
какая-то хитра.
И это было очень похоже на какие-то
Unix веб-путины, то есть Scranet это был
какой-то краневой путь, а Super
это был к родителю.
Это на самом деле не совпадение.
Это так и работает,
как бы,
как бы.
Но, в общем, это все
просто.
Это не совпадение.
Это так и работает.
Ну и прямо сейчас превратим вот это все добро
вот в это.
То есть все модули, модуль каждый
из себя представляет какие-то файлы.
На самом деле. То есть вы можете писать
внутри файла модуля, а можете
в качестве модуля использовать папку
либо файл. Ну сейчас посмотрим, как это работает.
Каждый файл, во-первых, является
модулем.
И путь до него, это собственно
включая его имя,
это и есть путь
до него, как
до модуля в программе.
Исключение это только MainRC
либо RC и ModRC.
Они свое имя игнорируют.
Скажем так.
То есть ModRC либо RC, вы находитесь
по умолчанию, если вы пишете код, вы находитесь
в корневом модуле. В ModRC
вы находитесь в модуле, который соответствует
тому, в каких папочках вы находитесь.
Где?
Да, ну смотри,
у нас есть такая вот файловая система.
Ну ты примерно помнишь, что там
one, nested, nested2,
вот это вот было.
Смотрите, у нас вот здесь либо RC,
внутри, если мы пишем код либо RC,
то мы находимся в корневом модуле.
Если мы пишем код в 2RC,
который вот здесь вот,
то мы находимся в модуле 2.
Так?
Соответственно, смотрите, вот здесь вот папочка,
а внутри папочки у нас ModRC.
Соответственно, то,
что находится внутри ModRC, имеет
путь просто one,
модуль one.
Если бы здесь был какой-нибудь файлик, там не знаю,
exampleRC, в таком случае
до него бы был путь
one, exampleRC внутри файла.
Если бы внутри
exampleRC писали был какой-то код,
то получилось бы примерно так.
Вот.
Ну и, соответственно,
почему мы вообще сделали папку?
Потому что мы хотим, чтобы у нас был модуль,
и внутри модуля был и код,
и, соответственно, другой модуль.
Вот.
Но если у вас внутри модуля только код,
то вы можете ограничиться файлом.
Даже не можете ограничиться файлом.
А если вы хотите внутри модуля сделать
другой модуль и еще файлы,
то вам нужно сделать папочку,
внутри нее ModRC,
соответственно, по модулям либо файлы,
либо еще папочки.
Я думаю, что будет нагляднее, если вы
потом после лекции посмотрите прямо
на вот этот же код,
который расфасован по файликам,
и увидите, как оно работает.
То есть я скину прямо,
оно будет рядом с лекцией лежать код.
Вот, как я сказал, 2RC есть
путь CrateFoo,
Crate2, соответственно,
полный. И у nested2RC, соответственно,
Crate1, nested, nested2,
как можно увидеть.
Соответственно, вот наш Crate,
Crate1, nested, ну и соответственно
название файла nested2.
Как-то так.
Когда у вас, у вашего модуля
не только код и другие модули,
но, как я сказал, нужно создать папочку
и внутреннюю ModRC положить.
Например, внутри модуля
RC,
но ModRC в nested будет путь
Crate1, nested,
и не будет
двоеточие мод,
как в случае файлика.
Модули недоступны для всей программы
по дефолту.
Чтобы
включить модуль
в всю программу, то вам нужно использовать
PubMod.
Ну то есть, если вы хотите
CRC1ModRC,
то есть добавить еще один какой-то
модуль, чтобы у вас был путь
Crate1, nested,
то вам нужно сделать PubMod, nested.
И тут обратить внимание, у нас MyTrade
сидит, потому что мы хотим, чтобы у нас
в Crate1
был еще
MyTrade
соответствующий нашему коду.
Так, ну...
Соответственно, каждый модуль
один раз подключает
и дублирует.
Да, он только один раз подключает.
Более того, вообще, на самом деле, SlowMod работает
по сути так же, как и Include.
За все compilation unit здоровый,
поэтому он просто это все поставляет
и скопилирует все как один пайл.
В смысле, Include уже может
копировать?
Ну, Include копирует, но если ты напишешь
второй раз Mod, я даже не помню, что
сделает Rust.
Я не про то, что если
два багата одинаковых, а если вот
мы импортируем
какой-то модуль, а в нем импортируется
второй модуль.
И, соответственно, на верхнем уровне
мы отдельно еще раз
с самого начала этот модуль
импортирует модуль. С самого начала этот модуль
попадет в этот модуль, а потом вот сюда
вниз еще. Соответственно, получится
есть трех файлов.
Ну вот у нас три модуля,
три файла. Один, два, три.
В первом написано
будет BobMod2
и BobMod3.
А в третьем написано BobMod2.
А, не будет ли второй раз
импортироваться? Нет, не будет.
Ну, считай Pragmalance написано.
Более того,
Rust, как мы уже видели,
в каком порядке у вас идут
декларации структуры. То есть, может сначала
пользоваться структуру и потом написать ее
декларацию. Это легально.
Потому что в Rust есть гарантия
на то, что у вас одна декларация структуры,
одна декларация функции
и так далее.
Поэтому он может себе такое позволить.
Ну вот, собственно, RC.
С примером с RC use.
Не знаю, как use попал куда-то наверх,
но как есть.
Вот.
use std rc rc. И после этого
мы создаем rc new.
Обратите внимание, что за счет того,
что я сделал use, то в таком случае
у меня сразу же доступно имя.
Мне не нужно писать полностью std rc rc.
Хотя бы я мог это сделать.
То есть, я бы мог без use написать просто
полностью имя, и в таком случае у меня бы все работало.
Просто, что это удобно.
Более того, мы можем дать alias.
Вот такое вот. То есть, вот с нашим
примером 1.1.2.foo
вместо того, чтобы это писать, можно написать
stest и после этого пользоваться
foo как тест. И все.
Примерно похоже на Python.
Но,
более того, импл блоки.
Если у вас импл блок
для структуры просто, то он доступен
у него публичисть
ровно такая же, как, собственно, у самой
структуры. А если у вас импл
блок trade для структуры,
тогда у вас публичность минимальная
из доступности трейта и структуры.
То есть, соответственно, структуры,
потому что вы не сможете создать структуру,
и, соответственно, воспользоваться трейтом.
А для того, чтобы воспользоваться функциями трейта, нужно импортировать сам трейт, как мы это могли видеть, например, в домашней комме.
А для того, чтобы пользоваться функциями write, нужно было имплементировать traitWrite.
И обратите внимание, что я к тому же ему еще дал такое вот приватное имя, underscope.
Это означает то, что мы импортируем методы трейта, но сам трейт не импортируем.
То есть это нам позволяет в текущем скопе создать, например, свой traitWrite.
Почему бы и нет? Второе имя.
А если бы мы так не сделали, тогда бы write постоянно думал, но у нас write уже есть в скопе.
Мы его импортировали.
То есть это достаточно удобно для того, чтобы не засорять в лишний раз на импспейс.
Иногда бывает.
Сейчас если чем нам импортировать write из скопы?
Помню.
Ну еще раз underscope вы сказали, мы использовали...
Underscope говорит, что ты заимпорцировал trait, но не само его имя.
То есть тебе дадут доступные методы trait, но не сам trait по имени.
Потом у нас есть такое ключевое слово use называется.
Как я уже сказал несколько раз.
Потому что в томате считаю.
Ну смотрите, у нас здесь можно еще воспользоваться ключевым словом self.
Оно и заимплементирует только текущий модуль.
Ну заимпортирует.
Смотрите, у нас в std-collections сидит hashMap.
Соответственно, если я сделаю use std-collections self, тогда у меня заимпортируется hashMap.
Соответственно, если я попробую...
Ну в std-collections hashMap defaultHasher, здесь сидит defaultHasher, который мы уже знаем с прошлой лекции.
Если я так заимпортирую, то это не скомпилируется.
Вот если бы я заимпортировал std-collections, просто use std-collections,
то тогда бы здесь мог написать collections hashMap,
а здесь мог написать collections hashMap только с маленькими буквами.
Ну смотри, это означает импортировать все имена в этом модуле.
Все, что внутри модулы std-collections.
Вот он тогда заимплантирует hashMap.
DefaultHasher находится не в самом std-collections, а в std-collections hashMap с маленькими буквами,
а потом уже defaultHasher.
То есть по факту он заимпортирует вот этот hash нижнее подчеркивание map.
Только так как модуль сам по себе нет смысла импортировать, то это не скомпилируется.
Вот как раз по иерархии не пойдет.
Тут есть пример, когда мы пойдем по иерархии вниз.
Смотри, есть звездочка.
Звездочка это все имена импортировать.
Не нужно их злоупотреблять, конечно.
Self только внутри текущего модуля.
Дальше не идет.
Звездочка она импортирует все имена дальше.
Вот у нас, например, modA, modB, enumC.
И после этого я пишу useA, два две точки, звездочка.
И после этого я могу написать b, c и x.
Потому что b импортировал, дальше c и x.
Потому что они тоже импортируют.
Если бы ты написал a self, то в таком случае у тебя бы ничего за ней не заимпортилось.
Да.
Сама modA ничего нет, поэтому ничего не заимпортится.
Еще можно...
Здесь пропало два двое точек.
Если вы хотите заимпортить все варианты enum,
то в таком случае вы можете написать нод,
как здесь написано a, b, c, 2, 2 и точка, звездочка.
В таком случае вы сможете воспользоваться напрямую вариантом enum.
Именно так сделано в собственном стандартной библиотеке.
То, что вы можете написать сам и нам в коде,
это заслуга того, что там импортированы все варианты enum.
В код.
Да, в прелюде.
Про прелюд мы сейчас поговорим, но для начала...
А, знаешь, сразу про прелюд.
Так.
Стиди, это тоже крейт.
Естественно, как и все, она так задизайнена в расти.
Его версия зависит от версии вашего компилятора.
Когда мы пишем программу на расти,
вы не должны...
В общем, вам не приходится писать полностью имена.
Стиди, век, век или use, cd, box, box.
Потому что это уже за вас сделано.
Это сделано в модуле cd-прелюд.
cd-прелюд – это тот модуль, который неявно добавляется в ваш код.
Ну, то есть там написано use, cd, прелюд, звездочка,
и все из прелюда импортируется.
А сам прелюд, в свою очередь, в другие юзы имеет.
То есть, например, внутри имеет pub, use, cd, век, век.
И, соответственно, вон выступен вектор в вашем коде.
Вот.
От прелюда можно отказаться.
Наверное, не нужно.
Он в целом никаких отрицательных, скажем так, черту у него,
того, что он компилируется, нет.
Вот.
Ну, это, кажется, все.
Что прелюд.
Так, импортируем крейт как приватный какой-то модуль.
Для начала.
Ну, это какой-то мод крейт.
Потом мы...
Сейчас, еще секундочку.
А ну да.
Это то, как мы...
Ну, смотрите, у нас есть какой-то модуль MyCrate.
Обратите внимание, что он приватный.
Ну, то есть, вдруг мне захочется из чего-то приватного
достать какое-то имя.
Один из вариантов это сделать вот такой вот pub, use.
Вы пишете pub, use, и в таком случае вам доступно имя foo
в другом крейте.
MyCrate foo.
Ну, то есть, use – это примерно как using gifc++.
Ну, using gifc++ имеет другое, более широкое значение,
а use в Rust используется только для того, чтобы импортировать имена.
Как-то так.
Так, ну и с этим понятно.
Так, ну и важное такое замечание.
Std – это такая библиотека, которая старается быть максимально маленькой.
Ну, то есть, она предоставляет вам только самое необходимое крейте.
И самые необходимые функции.
Ну, это, знаете, такой Unix way.
У нас там есть какое-то минимальное окружение, которое работоспособно.
А после этого все, что хотите, докидываете в пакеты.
Вот как в Linux это, например, устроено.
Это потому, что у нас есть какой-то минимальное окружение,
например, устроено.
Это потому, что очень сильно упрощает поддержку.
Ну и вообще, это хорошее разделение ответственности.
Ну, например, хешмапы есть примерно в каждой программе,
поэтому стд библиотека имплементирует какую-то свою хешмапу.
А вот, например, еще есть такой пример.
Есть вещи, которые нет в каждой программе.
Например, какой-то асинхронный код.
Но тем не менее, так как асинхронные рентаймы можно написать очень по-разному.
И Rust очень хочет сделать так, чтобы у всех асинхронных рентаймов
было примерно одинаково...
В общем, им можно было примерно одинаково пользоваться
с точки зрения пользователей.
Поэтому Rust предоставляет такие трейты как future,
ключевое слово async и await, macros и join и select.
Об этом мы попозже познакомимся.
Но то, о чем я вам хочу сказать,
это то, что это все предназначено для того,
чтобы как-то весь зоопарк асинхронных крейтов,
крейтов, связанных с асинхронностью,
как-то стандартизовалась в стандартной библиотеке.
То есть чтобы они через стандартную библиотеку,
через строительство стандарта библиотеки работали.
Соответственно, есть, например, ключевые слова await,
которые работают вне зависимости от того,
какой библиотекой асинхронности вы пользуетесь.
Например, async STD или Tokyo.
В первом случае мы добавили хэшмапу,
потому что он примерно в каждой программе,
и это необходимо добавить.
А здесь мы хотим так сделать,
потому что мы хотим зоопарк как-то стандартизировать.
Понятная идея.
То есть в Раффите, скажем так,
стандартизация работает на уровне крейтов,
в отличие от плюсов?
Да, на крейтов.
Она работает на уровне имплементации?
Да, тут крейты есть, есть trade future,
там всякие контексты, полы,
мы с ним попожим.
Так, мы закончили как раз
со всем связанным с модулем,
если какие-то вопросы.
Мы действительно, кстати, быстро прошли.
Наверное, пойдем дальше.
Я думаю, мы, кстати,
уже через 15 минут может закончим.
Ну, там меньше 40 слайдов.
Мы уже прошли что-то типа 140,
поэтому нет.
Ну, хорошо, у нас есть такая,
ну, в общем, в отличие от плюсов,
итератор такая неспецифичная структура,
не конкретная структура,
это trade.
Как мы уже поняли,
в раффите есть имплементации.
Нет, ну почему?
Есть имплементации для вектора,
для слайса, для хэш-мап,
хэш-сетов, ве-три-мэп,
там итераторы можно даже из опшена сделать,
ну, очень много чего.
На шоу трейдов
в стадилибе
раффер все равно повыше,
чем подобными это фигни.
Так, окей.
Ну, у нас
вы, наверное, уже успели
попользоваться итераторами в домашке.
Мы как-то к ним
подошли достаточно поздно.
Итератор достаточно простенький
с виду трейд,
безобидный.
Итератор с айтом
это то, что мы возвращаем
next, которое возвращает опшен
с self-item.
Ну, и мутирует соответственно итератор,
потому что итератор должен как-то меняться,
когда вы из него уберете элемент.
Ну, и еще важный вопрос,
ну, важное такое замечание.
Если возвращается наун,
то мы по умолчанию считаем,
что итератор закончился.
На самом деле
вам никто не запрещает
возвращать какие-то самы,
возвращать опять наун и так далее.
Но большая часть имплементации
трейд в стандартной библиотеке
все же полагается на то,
что вы после наун больше ничего не возвращаете.
Ну, и соответственно,
не удивляйтесь,
если у вас, например,
итерация закончится раньше времени
из-за того, что у вас не подряд
возвращаете элементы. Нормально.
То после этого момента
большая часть имплементации
в пункте стандартной библиотеки
считает, что дальше ничего не будет.
Все будет на.
Не, ну, тебя никто не мешает
сделать так, чтобы next поочередно
возвращал сам что-то там, но
сам что-то там.
Возвращает next,
а предследующий сейчас еще раз.
Нет.
Она не вызывает еще раз после науны.
Там даже есть такой
итератор fuse метод,
с ним будешь познакомиться в домашке
интертулс.
Он просто оборачивает итератор так,
что если он увидел наун, то он после этого
перестает даже обращаться к итератору.
Он просто автоматически наун возвращает.
Это удобно, потому что мы тогда
не продолжаем истощать итератор.
Это не все методы.
На самом деле 71 штука.
Просто у них есть дефолтная имплементация
у итератора.
Кроме next, есть еще
более-менее простой сайд скинутый last.
После этого там мэпы,
flatten, pickable
и так далее.
То есть всякие удобные обертки.
Сейчас обсудим.
Как раз у нас будет.
По сравнению с плюсами
это вообще input итератор.
Мы с плюсами
тоже чуть-чуть поговорим.
Прежде чем мы продолжим,
давайте сначала обозначим
две вещи. Во-первых, в раше все
итераторы ленивые.
Во-вторых, как вы могли заметить,
у нас возвращается не ссылка на item,
не мутабельная ссылка на item,
а сам item, то есть нам передается владение элементом.
Это очень важно для того,
как мы будем имплементировать дальше
какие-то методы итератора.
Давайте поговорим сначала
про методы ссылки на self.
На самом деле этот метод только один.
Это sizeHint.
Он дает lower и upper bound.
То есть дает пару
не меньше скольки элементов
в итераторе и не больше скольки
элементов в итераторе. По умолчанию
возвращает ноль бесконечности.
То есть там дефолтная такая имплементация.
Естественно, как вы понимаете,
вы можете
имплементировать это так, что даже
будет возвращаться для вашего итератора
перегрузить имплементацию.
Сделать так, что
там возвращается какое-то совсем неправильное значение.
Поэтому
если вы пишете unsafe code,
будете когда-то писать unsafe code,
то в общем-то
не используйте это для проверки границ.
Это не то,
к чему вы должны доверять.
Это просто какое-то значение, чтобы
выделить память заранее.
Например, вы хотите сделать
коллект вектор, в таком случае sizeHint
удобно использовать для того, чтобы заранее
выделить нужную память вектор.
А может быть lower bound
можно доверять?
Ну lower нет.
А почему можем?
Ну lower можем дать больше,
чем реальное число элементов в итераторе.
Например, lower bound и upper bound
это 10 и 10, ну там 10 и 11 точно.
И все, там реально
один элемент в итераторе.
Соответственно, мы не можем доверять lower bound.
Ну тут нет
никакого контракта, вы просто
не можете этому доверять на самом деле.
Это просто, ну как есть.
То есть вы можете...
Например, для выделения памяти
заранее векториком.
Если вы коллектите что-то вектор,
например, вы там
в итератором как-то обрабатываете элемент,
кладете вектор. Эффективно до вектора
заранее память нужно выделить.
Берете там под upper bound
какой-нибудь оба, выделяете сколько
выделите.
Ну там есть, если что,
во-первых, мы сейчас
посмотрим еще на exact size
итератор, который знает свой точный размер.
Но это все равно вещь, о которой мы не можем доверять.
А потом есть еще
один trusted land итератор. Это уже
unsafe trade.
И вот этой вот штуке можно доверять.
Если пользователь неправильно
имплементирует ее, то в таком случае
вы можете этому доверять в unsafe
коде, и если пользователь неправильно имплементировал
unsafe trade, то он сам себя обналишил с братьями.
Вы просто забиваете на это.
Потому что это unsafe trade,
у вас контракт. Это все.
Так, давайте
на методы self посмотрим. Это самые
интересные методы, потому что они поглощают
итераторы и превращают их в какой-то
другой объект либо другой итератор.
Last, это самое простое.
Он просто будет вытягивать элементы из
итератора до тех пор, пока не поймет, что
ему вернули наут. Если вернули наут,
возвращаю последний элемент, который
видел и закончил.
Это просто функция, которая в цикле что-то делает.
Обратите внимание,
что это не lazy функция. То есть если вы
вызываете last, то в таком случае, прямо в месте,
где вы вызывали last, у вас полностью
итератор истощится.
Потом есть enumerate.
Enumerate это такая штука,
которая делает из нашего итератора
другой итератор, который
возвращает пары и значения.
И это индекс какой-то.
Он будет 0, 1, 2 и так далее,
ну и значения соответствующие.
То есть мы просто по сути возвращаем пары
номер элемента и
сам элемент. Для этого нам нужно
создать новый итератор,
который будет содержать в себе какой-то счетчик.
Потом pickable.
Pickable это соответственно
там у нас будет буфер из одного элемента.
Когда будем создавать
pickable итератор,
то в таком случае мы будем
брать один элемент из нашего
текущего итератора и класть его в буфер.
Когда
нас будут просить pick и сделать pick,
это если что посмотреть на первый элемент
текущий, но не забрать его.
Нам будет возвращаться ссылка
в описании.
Нам будет возвращаться ссылка
на текущий айтем.
То есть это итератор,
который умеет в пик.
Есть count, который тоже не ленивый,
просто считает число элементов внутри
итератора.
Если мы в пик,
то второй раз вызываем, то он
тот же элемент.
Так.
Вот count не lazy, такая штука.
Очень простая, просто донал,
что читает.
LTE это, собственно, перегрузка
для того, чтобы сравнивать итераторы.
Это, естественно, не ленивая операция,
потому что она будет их сравнивать на меньше
и должна пройтись по всему итератору,
чтобы выяснить, какой из них
меньше какого.
Еще один интересный вариант,
такой фильтр.
Пусть у вас есть
итератор итераторов.
То есть итератор,tonel, который возвращает
в качестве элемента другое итератор.
Вы можете
его превратить в подряд идущие итераторы.
Если у вас был вектор
векторов,
каждому из векторов
написано 1, 2, 3.
Если вы каждый вектор превратите
в итератор, а потом
是的 этаée в profitability,
вы получите итераторы, итераторы.
А, кстати, здесь не фильтр должен быть, а флэтм, флэтм, да, я очень накосячил, это должен быть флэтм, конечно.
Вот. Ну, он будет работать, если что, лениво, флэтм.
Он будет просто доставать элементы из итератора.
Когда он перейдет к тому, что у одного итератора нет элемента, то в таком случае достанет следующий итератор из исходного и будет его истощать.
Да, потому что это будет ссылка на сам, собственно, pickable, потому что у нас такие правила владения.
Так, потом у нас есть еще методы, которые мутируют self.
В-первых, map.
Он возвращает итератор, который маппится ко всем элементам, ну, маппит все элементы из него типа в другой.
Это ленивая операция, то есть вам не нужно полностью обходить весь итератор, класть какие-то элементы в буфер, создавать новый итератор.
Вы просто будете каждый раз, когда он вызывается next, будете применять функцию.
Ну, то есть, собственно, так работает итератор map.
Он создает какой-то новый итератор, который содержит внутри себя функцию, которую вы собираетесь вызвать, и исходный итератор.
И каждый раз, когда вызывается next, применяет к next функцию и возвращает значение.
Ну, или none, да, если мы уже закончили.
Вот есть такая вещь, про которую не все знают.
Это biref.
С ее помощью, кстати, можно очень-очень легким образом решить задачу cycle в домашке.
Ну, там у IterTools есть часть задачи, называется cycle, где нужно сделать ленивый какой-то, lazy cycle.
Где там нужно лениво повторять итератор.
Вот biref там очень сильно помогает сделать короткое, красивое решение.
Она возвращает мьют ссылку на селф.
И в таком случае, когда вы будете нажимать next, то в таком случае у вас не будет исходный итератор как-то съедаться.
Ну, это удобно, например, как сказать.
Как сказать?
Смотрите, вы, например, взяли Iter, да, потом написали точку biref,
потом вы можете написать точку take10 и потом точку collect.
В таком случае вы получите первые 10 элементов итератора в каком-то векторе, допустим.
А исходный итератор не умрет от этого.
А если бы вы сделали take, collect без biref, то в таком случае у вас исходный итератор бы съелся.
Вот такая вот идея.
Да, он так и делает.
Не, просто исходный итератор тоже пройдет вперед.
То есть если ты сделаешь Iter, то этот collect получишь вектор.
То после этого, если ты будешь продолжать использовать Iter, то он будет с десятью уже съеденными элементами.
То есть это вместо того, чтобы писать какой-нибудь for, это просто удобно, чтобы продолжать использовать функции итератора.
Просто помутировать итератор вместо того, чтобы у вас есть.
Вот так вот.
Так, есть n. Возвращает n на элементы итератора.
Ну, просто едает итератор и возвращает n на n.
А, мьюцелл возвращает n на n, соответственно, все элементы до n его съедает.
Вот. Ну и all там проверяет, чтобы какой-то предикат выполняется на всяких элементах.
Соответственно, не ленивая операция.
Так.
Есть еще такой trait.
Ну, давайте с итератором понятно, как он работает, как он устроен,
как примерно выглядят его методы, 71 метод.
Они просто делают разные вещи.
На самом деле, идеи на ничем не отличаются от того, что я показал.
Тоже создается какой-то итератор с какими-то там, возможно, буферами или что-нибудь такое флажками.
И какую-то функцию выполняют.
Понятно это примерно?
Вот. Есть еще trait intoIterator.
Он отвечает на следующий вопрос.
Если у вас коллекция имплементирует intoIterator, то означает, что ее можно превратить в итератор.
Соответственно, если у вас есть итератор, то он автоматически имплементирует intoIterator,
потому что итератор уже является итератором.
Просто возвращаем self.
Так.
Это очень часто обузится в стандартной библиотеке,
поэтому если будете смотреть методы, которые у итератора,
там будет очень часто вместо итератора написано intoIterator,
потому что удобно будет иногда засунуть вектор,
просто сразу вместо того, чтобы писать вектор intoIter.
Вот как раз intoIter это та функция, которая, смотрите, следает нашу коллекцию
и превращает ее в итератор.
Например, вот тут.
Смотрите, у нас вектор 1, 2, 3.
Берем intoIterator и превращаем вектор в итератор.
Обратите внимание, что если я попробую воспользоваться вектором,
это не скомпилируется, потому что я только что именно что сделал в итераторе,
превратил свой вектор в итератор.
Исходного вектора у меня нет больше.
У меня есть итератор, владеющий всеми элементами вектора.
А вот если вы напишете vec.iter, то в таком случае вы не съедите вектор,
вы получите итератор по ссылкам на вектор.
Iter это уже не концепция стандартной библиотеки,
это просто отдельная функция вектора, которая возвращает именно ссылки на элементы,
а не элементы по значению.
Как-то так.
So, intoIterator это, по сути, перегрузка для того, чтобы использовать что-то в форе.
То есть до этого мы перегружали операторы плюс, минус, битовые сдвиги.
А теперь мы можем даже перегрузить в цикл for.
То есть у нас все работает через итератор, и все, что может быть превращено в итератор,
может использоваться в цикле for.
Примерно вот так вот оно обессахаривается.
Был у нас какой-то вектор, и вместо этого мы внутри компилятора сделал какой-то
интератор, а после этого while'ом воспользовался.
Здесь не должно быть этого 3D.
Не должно быть тапчика.
Тут понятно, да?
Да, если ты сделаешь for по вектору, то у тебя его не будет.
В конкретном данном случае у тебя for съедает.
А, смотри.
Там будет примерчик.
Там будет еще ссылка и ссылка на Mute на VEC.
Посмотрим.
Так.
Да, и тут написано то, что это как итератор, в том числе является интер-итератор,
потому что он сам в себя превращается легко, то он может быть использован в форе.
Теперь вопросы, как это работает?
Да, правильно.
Здесь имплементация для ссылки на VEC и ссылки Mute на VEC.
Там возвращается итератор по ссылкам и итератор по амутабельным ссылкам.
Соответственно, это то, как работает итер и итер Mute.
Да, тут у нас именно по ссылке.
Потому что у нас внутри получается так, что мы от ссылки на VEC делаем inte-итератор.
Это не пожирает наш итератор, это пожирает ссылку на VEC.
Просто семантически.
Соответственно, у нас получается итератор, просто обычный по ссылкам.
Потому что у нас так написан код.
Соответственно, когда вы писали range, на самом деле они тоже являются итераторами.
Здесь оно так работает, что у нас есть синтаксис от A до B.
На самом деле это синтактический сахар для range, range from, range to и range from.
Ну, смотрите.
Вот вы можете написать, например, for e, от 0 до 10 выйдет какой-то код.
И там от 0 до 9 у вас будет итерация.
Если вы напишите от 10 до чего-то там, то в таком случае вы тоже будете итерироваться, просто у вас конца нет.
В первом случае у вас создается range, а в втором случае у вас создается range from.
Есть еще range to и range from.
Range to – это когда у вас нет левой границы, есть правая.
Range full – это когда нет ни того, ни другого, просто две точки.
А как без левой границы?
Отход начинается.
Без левой границы как вообще?
Итерироваться не получится без левой границы.
Они не являются итераторами.
А для чего это?
А это нужно, например, в матчах.
Если ты хочешь поматчить числа от минус бесконечности до нуля и от нуля до плюс бесконечности,
то можно сделать это с помощью красот этих рейнджей.
То есть range to и range full – они для матчей используются?
Да, они такие вот синтактические, чистые вещи.
А по range from получается итерировать?
Да, по range и range from уже можно итерироваться.
Это range – это range from, просто синтактический сад.
А range from получается до бесконечности?
Да, до бесконечности.
Цикл, если там внутри нет брейка, никогда не останется.
Просто и будет. У меня 11, 12, 100, 500 и так далее.
А при переполнении, по-моему, это неконечно?
Не при переполнении, а там паника, скорее всего.
Я не проверял, но вы вряд ли дойдете до этого момента.
Давайте по правде.
Не, ну получается, он тогда закончится.
Ну, как сказать?
Я думаю, никогда не в нашей жизни.
Почему не заметишь, что он плакет?
Говори так.
Кстати, в шаде была забавная вещь.
Люди жаловались на то, что вектор паниковал, когда он пытался выделить 2 в 64-1 памяти.
То есть, когда кончался U-size внутри.
Я не совсем понимаю, в чем претензия попробовать выделить столько памяти на компьютер.
Ну, в плане, что U-size переполнился.
Все-таки это как раз еще не переполнение.
Это как раз максимально невозможное значение.
Которое можно...
Ну, для этого иметь в виду, что пуш может запаниковать, когда он пытается запушить.
А там уже пытаешься еще больше, чем это.
Ну да.
Ну, не знаю, конечно, почему люди жаловались.
Ну, смотрите, когда вы замастерите с контакт-итераторы, вы сможете писать примерно такой вот код.
Например, здесь вы сделали итератор по пифогоровым тройкам.
Это же вообще не читает.
А что это за моды?
Так.
Ну, смотрите, у нас triplet.
Вот это вот, как мы уже обсудили, range по U32.
Потом у нас flatmap.
Ну, flatmap что делает?
Он одновременно...
Он ожидает, что у вас внутри будет в качестве возвращаемого значения итератор.
То есть если бы вы сделали просто map,
ну, тогда бы у вас получился после этих вот первых двух строчек просто итератор итераторов.
А flatmap он еще делает flat.
То есть flatmap это по сути map flat.
Вот.
Ну, и по сути после второй строчки у вас получится
массив-парк, где
ну, в общем, бесконечный итератор парк,
где у вас есть какое-то первое число
и второе меньше строго, чем первое.
Ну, там типа будет один, получается,
один-один,
два-один, два-два и так далее.
Сейчас, а почему triplet вообще закончит
исполнение?
Triplet не закончит, это бесконечный итератор какой-то.
Ну, настолько бесконечный, насколько U32 просто валяет, конечно.
Сейчас.
Сейчас это второй, поэтому там один-один,
один-два, два-два.
Ну, не важно.
В общем, как-то примерно так.
Да.
Да, в второй строчке мы добавляем уже третье число,
то есть которое меньше либо равно, чем второе.
Вот.
Вот.
Я, конечно, очень хотел на эту лекцию обсудить и closures,
но кажется, что мы не успеем.
Я поэтому не добавлял.
Я так не понял.
Если этот под копировать полностью,
он не будет исполняться?
В плане.
Ну, здесь вот ты в этой строчке
сделаешь бесконечный итератор
пифагоровых triplet.
А здесь мы уберем из этого бесконечного итератора
пифагоровых triplet первые десять элементов.
То есть он не будет просто все их подсчитывать?
Да, он не будет ничего считать, пока это не ленивая операция.
Да, они все ленивые.
У нас в расе все ленивое,
поэтому это будет лениво все подсчитываться.
Поедем на deadline.
Так.
Ну, соответственно, фильтр, там все подходящие отроки
фильтруем и все работает.
В общем, если вам понравится
функциональное программирование,
раз функциональный язык
без ГЦ приходите.
Да.
Так. Потом мы можем
сконвертировать не только в итератор,
а из итератора тоже.
То есть у нас есть from итератор,
это что-то,
что принимает на вход,
ну, у нас есть функция, которая принимает на вход
T, где T это какой-то интейтератор.
Ну, всякие итераторы, если что,
являются итераторами.
То есть у нас просто еще можно
с помощью вектора, то есть по сути мы можем написать
там не знаю, hash map,
from it,
и там внутри век
из 1, 2, 3.
Ну ладно, не 1, 2, 3, а там парки.
Потому что
он имплементирует интейтератор
вектор, а hash map
имплементирует из итератора пар.
Все, ну, то есть такое вот.
Не, подождите, сейчас будет
такой прикольный синтоксический сахар.
У нас еще 10 минут, кстати.
Вот примерно вот так вот, да.
Ну, это по сути то,
как работает коллект.
То, что мы много раз
им пользовались, не совсем понимали как,
но коллект он ожидает на вход,
ну, вы пишете точечку, он ожидает
то, что вы ему в качестве
коллект ожидает,
то, что вы соберетесь в какую-то
фигню, которая из этого
итератора текущего собирается.
Вот полиморфная такая фигня получается.
А теперь совсем неожиданно.
У нас интейтератор внезапно для result
option и unit
имплементирован.
Как же это работает?
Ну, смотрите.
Давайте use case.
Вот, например, в Rover это используется
для result.
Просто бывает такое, что у вас есть
ну, например,
итератор, который
возвращает там либо
ошибку, ну, то есть итератор
либо ошибка, либо значения, да?
На первой ошибке у нас получается?
Да, на первой ошибке.
Суть в том, что мы хотим как раз
вместо того,
чтобы итерироваться и ручками
проверять была ли ошибка, просто сделать
коллект, и в таком случае у нас либо
вернется вектор каких-то значений,
допустим, вектор, можно и в хашмап,
и все, что хочешь, все, что from
inter работает.
Либо ошибка первая.
То есть это удобно. В Rover это
используется в нескольких местах.
Вот это optional result показывает, кажется,
transposed или что-то подобное.
Вот это, по сути, оно, да?
Не-не, transposed это именно делает
option result либо result option,
представляет местами, а здесь
а здесь как бы итератор этой фигни
вносится внутрь.
Ну, я в этом, типа, пробился внутрь
что-то типа того, похоже
на transposed.
Но давайте разберем
пример, чтобы было понятно. Вот у нас
как имплеметируем from итератор для
result,
как вы можете заметить, v это какая-то
коллекция, в которой мы хотим собраться.
a это элементы
нашего итератора. То есть у нас
итератор item имеет
result ae, то есть
у нас итератор по значениям a
и ошибкам e, а мы хотим превратить
его в result из какого-то собранного
собранной коллекции, допустим,
вектора и ошибки.
Вот.
Примерно такая вот декларация.
И работает оно так. У нас есть какие-то
integers, вот.
И мы хотим их распарщить.
Вот пишем integers
intuiter, то есть превратили вектор в итератор.
Потом делаем
map,
exparse, ну и получили
соответственно какую-то фигню, которую
имитирует итератор, где item
это result из u32
и parsing error.
То есть ошибка
parsing int.
После этого мы коллектим. И вот к чему это
приколлектится. То есть видите вот этот
вот тип.
Итератор вот по этому фигне
превращается вот в это вот.
Это очень красиво, это я, кстати, узнал
тоже на конференции, когда был.
Было прикольно.
Ну вот как видите это заколлектилось
в OK из вектора 0.17.242.
Вот, еще есть
то же самое для option.
Ну работает идеально точно так же. У вас там есть
итератор по option и
собственно какая-то коллекция. То есть
вы хотим в общем коллекцию это собрать.
Ну точно так же
вот, например, вектор из 1, 2,
11, 12, если мы попробуем сделать
в цикле check sub
и заколлектить,
то в таком случае, ну здесь, кстати,
очень важно писать.
Если ты можешь
отнять, то в таком случае ты возвращаешь
сам, что получилось.
А если ты не можешь, ну то есть
там, например, тип у32.
То есть ты не можешь от нуля отнять
еще
единичку. В таком случае наум
возвращается. Вот.
У меня раз был хотя бы один нам,
то веще вектор
пролетелся в трубу. Точнее там
ну в банках.
Ну да.
Если бы check sub вообще вывезал,
что вы не смог, тогда нет.
Так тут же check sub на
элементы. Здесь check sub
на каждый элемент, соответственно,
возвращается саму 32.
Ну да. Ну то есть мы не смогли
отнять такого на уме.
Да, но это ошибка. Да, это все
возвращает ошибку. Первую ошибку возвращает.
То же самое
есть для юнита.
Ой, боже. Если у нас есть
титаратор по юнитам, то мы можем его склопнуть
в юнит. Ну это бывает удобно, например,
когда вам хочется
либо вывести
ошибку, либо просто ничего не сделать.
Ну то есть вывести OK и все.
Вот, например, у нас в WriteLn
возвращает result unit
в данном случае.
Если у нас
успешная запись, тогда просто unit.
Если не успешная, тогда OK unit.
А если не успешная, тогда error.
Ну и там, соответственно, ошибка записи.
STD его result.
Вот.
Ну и когда мы делаем коллект,
то мы, соответственно, итератор по
result unit
превращаем просто в result unit.
Где будет либо первая ошибка,
либо OK unit.
То есть по сути мы дважды применили
промотератор и в один раз зарезалки,
в второй раз для юнит. Да.
Красиво.
Сейчас, то есть тут мы еще раз
записываем, а дальше просто
выводим итоговое значение
либо все хорошо, либо
где-то случилось... Да. Здесь это assert
провалится, если в итоге что-то не получится
записать.
Там будет какая-то ошибка.
Так.
Есть у нас еще exact size итератор.
Ну, так он работает,
что...
В общем, он означает то, что итератор точно
знает свой размер. В таком случае
у вас и size skin
должен возвращать точно
правильный upper lower bound.
К сожалению, так как это пользовательская
имплементация,
мы не можем гарантировать то, что
он правильно этим воспользовался, и, соответственно,
мы не можем
полагаться на это в unsafe code.
Ну, к счастью,
как я говорил, есть такой еще trade
trusted land. Он unsafe trade.
Для того, чтобы имплементировать unsafe trade,
нужно вообще ключевое слово unsafe.
Соответственно, человек сам подписывается на то,
что он правильно имплементировал этот
итератор. Ну, этот trade.
Если вдруг что.
Вот.
Еще есть double-ended
итератор.
Итератор двухсторонний.
Но это итератор, который, ну, он, во-первых,
умеет то же самое, что итератор, во-вторых, он умеет
все что-то сзади делать.
Ну, он умеет сзади там что-то ходить,
fold, find,
такие вот вещи.
Ну, потому что next есть
в итераторе.
Ну, смотри, мы же видишь
супер по отношению к
итератору.
Next это первый.
Смотри, у нас одновременно,
если объект имплементирует double-ended итератор,
то он и итератор имплементирует.
Соответственно, там есть next и next-back.
Next он двигает с этой стороны, next-back с этой.
И более конкретно.
Например,
вектор 1, 2, 3.
Ну, и мы делаем какой-то итератор.
Ну, и смотрите,
у нас next возвращает 1,
next еще раз возвращает 2,
а next-back возвращает 3.
Он пошел с другой стороны.
Второй ассерт закомменит так и что?
Ну, в плане, если вот этот вот
раз комменит, то второй закомменит.
Вообще, да, будет
корректно. Оно точно так же даже
пройдет, там же 1 и 3.
Ну, типа у тебя 2 указателя, по сути, будет.
Ну, вот да, вот просто
название next-back.
Соответственно, вы,
ну, раз уж, как я говорил,
итератор возвращает какие-то владеющие
значения. В данном случае,
конечно, у нас владеющие ссылки, но
об этом итератор не знает, конечно.
Соответственно, мы не можем
дважды вернуть один и тот же элемент,
если у нас закончился
итератор. Вот, если я сделаю
next-back еще раз, то я получу, конечно же,
не тройку, не двойку, а
просто сэршен фейли будет, потому что
на он вернется.
Вот.
Давайте про клярфон с поговорим, кстати, сколько там?
А, ну еще пять слабых.
Как раз спим.
Я надеюсь,
что кто-то из вас делал
домашнюю по
итераторам.
Пятая какая?
Нет, которая четвертая.
Вот. Как мы заметили
на лекции, как увидели
в домашке, ну, тут написано Will C,
для кого как,
достаточно сложно написать тип итератора.
То есть, если вы делали, то у вас наверно
там возникали всякие
fuse, там generic
chain, внутри еще какой-нибудь
там map и так далее.
Потому что итераторы,
для того чтобы вернуть
итератор, для того чтобы какую-нибудь дополнительную
к нему фичу дать, вам нужно
при случае pick
иметь какой-нибудь буфер из одного элемента.
Вот. И, соответственно, у вас
получается какой-нибудь
pickable структурка,
которая, так,
выберете исходный итератор,
кладите pickable и там еще
pickable содержите буфер.
Так.
Примерно такое.
Ну и, соответственно, size of
complex strator и size
of its parts.
Вот. Ну, как я и говорю,
там может быть такой сложный
тип
и, в общем-то, size of это фигне,
это size of частей.
Кстати, я вот сейчас
подумал, я, наверное, вам в этой
строчке мог набрать, потому что у нас все-таки
раз со своей
моделью того, как он
кладет все в памяти, он может в итоге
сделать так, что size of окажется меньше.
Ну, не больше точно, конечно, не меньше может
быть.
Хотя может и больше
оказаться, если там будет.
Да, там может и больше даже
оказаться, если у вас, например, итератор
имеет 8 байт, там какой-нибудь
64 внутри.
То, что вы содержите дополнительно,
это какой-нибудь бул.
Да, и тогда у вас
будет еще
страйт в конце.
Так.
В общем-то, всякие состояния,
просто флаги на стеке.
Там буферы на стеке и так далее.
Потому что итератор просто какая-то небольшая
структурка зачастую.
Ну и вот.
Так как компилятор знает,
кем мы функции вызываем, вы, конечно,
типов не видите, но компилятор
их знает, он знает, кем функции вывозить.
Соответственно, он делает
активные inline вызовы и даже
делает всякие
викторизации. Например, есть
флетом,
который викторизуется.
То есть там викторизуется каждый отдельный
итератор эффективно.
И все это быстро работает.
Что это значит?
Что значит викторизация?
Про симд ты помнишь?
Симд инструкция, помнишь?
Попрос.
Это как класса был?
Так.
В первую очередь вместо как класса должны были
что-то там по умножению на адресы инструкции.
Ну, например,
если ты делаешь какой-нибудь мэп,
а мэп у тебя внутри делает
плюс один.
А потом у тебя, не знаю,
флетом.
Если ты хочешь сделать флетом,
в таком случае тебя может быть эффективно
симд инструкция использовать.
Ну, компилятор где нужно,
их вставит.
Там даже вплоть до того, что
флетом специально так написано, чтобы это максимально быстро работал.
Так.
Знакомая картиночка.
Да, это из плюсов.
Еще как.
Ну, как вы понимаете,
в плюсах сколько там?
Пять типов, шесть типов?
А, замечательно.
Ну, это просто первая ссылочка в интернете,
которая нашлась, когда я делал.
А так, да.
Ну, да.
Да, ну вот
random access умеет там какие-то
случайные значения двигаться.
B-directional в две стороны
там как хочет бегает.
И, в общем, такая вот
сложность появляется.
Да, ну, в общем,
такая вот сложность есть
со всем этим. Дело в том, что это все
кроме input итератора,
по сути, под определение итератора
не особо попадает.
Особенно, какие-нибудь random access
итераторы, потому что
ну, блин.
Ну, это не очень
адекватно, когда вы можете, например,
двигаться на какое-то произвольное значение вперед.
Не, ну, это может проинтерироваться
вперед, но это не очень хорошо,
когда ты используешь итераторы для того,
чтобы индексироваться.
Это итератор должен
интерироваться, не индексироваться.
Поэтому это не очень логично.
Более того, это, наверное, еще не очень удобно,
то, что в плюсах есть одновременно
и begin и end.
То есть во всех языках,
в которых только можно, там в питоне,
в джава есть
какой-то next.
В джаве есть еще has next, я знаю.
В общем-то, итераторы работают так,
что они просто идут куда-то вперед.
А в плюсах это и правда
только для input итераторов,
самого минимального, он же имеет смысл
как итератор.
Вообще
нужно, конечно, чуть-чуть встать на защиту плюсов.
Это все сделано не просто так, это сделано...
Ну, когда делали, я не знаю,
закладывали ли они такой смысл, но сейчас,
по крайней мере, можно с помощью концептов сделать
какие-нибудь специальные,
специфичные для итератора
иллюминизации. Если у вас continuous итератор,
то вы знаете, что у вас все беспрерывно в памяти,
а я все очень быстро.
Еще одна мысль, это то, что
вообще говоря, сравнение,
как бы, вот это разделение работы
с рейнджами на отдельный begin,
отдельный end, в результате можно использовать
для того, чтобы абстрагировать.
А что такое сравнить begin с end?
Вот вся идея рейнджей в том,
что сравнить begin с end, это вообще говоря
достаточно абстрактная
операция, которая может вести только
иллюминизацию,
как бы реализовывать все эти
веселые гнивы операции в терминах,
вот сравнить begin с end
и прикроить итератор.
В плюсах есть
какие-то, возможно, преимущества
такого дизайна,
но как итератор
имеет смысл только input иterator.
Почему мы не хотим
это иметь в расе?
Они такие универсальные, классные,
но на самом деле только input иterator,
как раз говорю, имеет смысл
как итератор.
C++ это небезопасный язык,
поэтому, например, если у вас есть
в расте, вы, как я уже говорил,
итератор всегда забирает владение над объектом,
там item владеющий.
Поэтому если бы то же самое было бы в расте,
то чтобы он мешал, например, в случае bidirectional
итератора, забрать элемент, двинуться вперед,
двинуться назад, забрать элементы и так далее.
Ну и тогда бы
получалось, что какие-то очень-очень
странные проверки получаются, и это вообще
не итератор.
В плюсах мы вынуждены возвращать ссылки.
В принципе, вы можете там
умывать объекты всякие, при случае вектора
взять и по итератору
умывать объект, но это небезопасно.
В какую-то произвольную позицию
оставляете просто дырку,
которая в любой момент может
как-то сломать вам
остальные программы.
В общем, еще есть проблема то,
что в плюсах
итератор предназначался
как какой-то адаптер для того, чтобы
спрятать детали
реализации
за вами.
В плюсах, если используется
continuous итератор, то
как сказать...
В общем, вам
выпячивает то,
что у вас этот объект
обязательно continuous что-то сохраняет.
А если вы захотите
прям беспрерывно памяти,
если вы захотите что-то изменить,
в таком случае в API, то тогда это
будет breaking change, потому что
пользователи могли что-то
на это полагаться.
В случае REST так не получится,
потому что если у вас есть итератор,
то это строго какая-то абстрактная вещь,
которая возвращает какой-то элемент,
вы просто итерируетесь.
Поэтому на самом деле в плюсах,
в том числе, есть проблема с тем, что
вместо того, чтобы прятать
детали реализации, вы их показываете.
Вот, как-то так.
Например, в плюсах
примерно такой код скомпилируется.
У вас есть randomIteratorBegin,
end и вы можете
зафигачить стд-сорт.
А что если бы
randomIterator имплементировал для листа?
Я же могу.
Он будет не эффективным,
и стд-сорт скомпилируется.
Это, конечно, скорее придирка,
вот этот слайд,
как есть.
Такой будет работать.
Там же есть,
мы же поговорили с итератором,
есть bidirection.
Только он не будет прям ходить в две стороны,
в плюсах это какой-то один указатель,
а в Rasty он поток.
Просто мы знаем, что у потока есть конец
и двигаемся в другую сторону.
Еще очень важный момент.
В Rasty, если вы хотите, например,
n-ый элемент взять, как в случае random access
итератор, то вам нужно обязательно
передать
саму коллекцию.
Если вы не знаете коллекцию,
в случае плюсов вы смогли
воспользоваться этим,
как раз кейс слайда.
В плюсах вы могли
воспользоваться тем, что у вас
random access итератор,
а в случае Rasty вы будете точно
видеть, какую структуру вы используете.
Соответственно, вы получаете
те гарантии, которых вы ожидаете
от именно этой структуры.
Вот.
Примерно так.
Если вопрос...
Кажется, что нет.
В таком случае лекция закончилась.
Всем спасибо.
Всем пока.
