В целом мы в принципе после вчерашнего, после прошлого
раза должны уже полностью понимать муфсимантику.
Вот.
И на самом деле то, что я сейчас буду говорить, оно
уже скорее не прям муфсимантика, а это скорее такие смежные
вещи.
Идей на вся муфсимантика уже нами пройдена, вместе
с форвардом и тому подобное.
Тем не менее есть еще одна очень смежная, очень родственная
муфсимантики тема, а именно X-values, RVO и Copy Elision.
Не больно, а приятно.
Да-да-да, не больно, а приятно.
Вот, как, значит, есть такое высказывание, не помню
чьё.
Pain is inevitable, suffering is optional.
Вот.
Смотрите, я до сих пор не произносил этого слова
X-value, ну то есть я его произносил так осторожно, но не рассказывал
что-то такое.
Я вам рассказывал, что есть R-value и L-value, и мы в принципе
все классифицировали и разобрались, как оно работает, но на самом
деле внимательные слушатели могли заметить, что вообще-то
есть еще один вид value в C++11, это X-value.
И с ним еще два появляются, PR-value и JL-value.
Сейчас я все напишу, не переживайте.
Так, значит, смотрите, смотрите, на самом деле, вот, сакральное
знание таково.
Вот, для того, чтобы понимать муфсемантику, достаточно
знать только две value-категории.
Вот, вот это неочевидный факт, когда люди читают
лекции какие-то по муфсемантике или когда люди пытаются
заботиться сами по книжкам муфсемантики, пишут статьи,
они зачем-то вводят все пять категорий, но если на самом
деле глубоко разобраться, сам я разобрался, как я
уже сказал не с первого далеко раза, вот, это, значит,
вот, с вершином многолетнего опыта, так сказать, рассказываю
вам истину, которая мне открыла сравнительно недавно.
Чтобы понимать муфсемантику, нигде не нужно использовать
понятие X-value, поэтому я до сих пор его не вводил.
Все то, что мы до этого прошли, оно только лишь опирается
на R-value и L-value, а понятие X-value, оно нужно на самом
деле для другого, вот, для этого, для того, чтобы правильно
понять, как работает RVO и копия Legion.
Для того, чтобы пройти ревью до гейнтеза.
Это смежная тема с муфсемантикой, но на самом деле муфсемантика
и без X-value прекрасно бы работала.
Так вот, мы, чтобы жизнь совсем скучной не казалась,
ведем еще три value-категории сейчас вместе с комитетом
C++11 и скажем, что вообще-то, начиная с C++11, у нас будет
не только L-value и R-value, у нас будет L-value, так, какой
из этих маркеров пишет, у нас будет L-value, X-value и
PR-value.
Это сейчас что?
Я говорю, что выражения бывают одной из трех категорий,
L-value, X-value, PR-value, X-value и PR-value вместе называются
R-value.
То есть, на самом деле, R-value подразделяется еще на
два вида.
Это бывает либо X-value, либо PR-value, L-value больше ни на
что не подразделяется, но L-value и X-value вместе называются
GL-value.
Значит, я говорю, что теперь мы R-value классифицируем
еще на две подразновидности, это будет либо X-value, либо
PR-value, L-value — это наше старое L-value, как мы его знаем, R-value
— это наше старое R-value, как мы его знаем, и L-value
и X-value вместе называются GL-value.
Значит, теперь я вам просто расскажу, что такое X-value,
а все остальное будет называться PR-value.
Так вы помните длинный список того, чем бывает R-value?
Я сейчас просто перечислю вам, что называется X-value,
а все остальное — это PR-value.
То есть, PR-value формально определяется как все то
R-value, которое не X-value.
X-value давайте для начала я расшифрую.
Это расшифруется как expired value.
Слово expired, ну что значит expired?
Ну такое просроченное, устаревшее, протухшее продукт в магазине, expired.
Вот, expired value, которое выкинуть уже пора, оно, ну все, испортилось, пора его выкинуть.
А PR-value в то же время — это pure R-value.
Что значит pure?
Нет.
Pure — значит, ну pure, металлы бывают, pure, да, типа чистый металл.
Pure — это такой настоящий, подлинный R-value.
Не какой-то там с примесями, а самое, что ни на есть, — настоящее R-value.
То есть R-value бывает настоящим R-value, ну вот таким вот самым, что ни на есть, правильным,
и просроченным каким-то выкинуть, который пора.
Вот, а что такое GL-value?
GL-value означает generalized L-value, обобщенное L-value.
Есть некоторые вопросы по поводу такого naming.
То есть, короче, если L-value, она становится L-value.
Отгадайте, что является X-value, вот исходя из этих названий.
L-value, ой, X-value называются как бы то, что раньше было L-value, но его move-нули.
Вот идея в чем.
То есть X-value — это как раз либо статик каст к типу с двумя амперсандами.
Либо результат вызова функции, которая возвращает тип с двумя амперсандами.
Либо еще некоторые технические пункты, ну то есть либо это знак вопроса двоеточие,
где один из оперантов или оба операнта X-value, я не помню.
Либо это запятая, где правый оперант R-value, ну и так далее.
Две основных вещи, которыми является X-value, это вот что.
Ключевые два пункта при линии X-value — это вот эти два.
Остальные — это технические пункты, понятно, очевидные.
То есть вот как раз те R-value, которые связаны с двумя амперсандами,
R-value у нас было и раньше, в C++03.
Что?
Возвращаемое значение из функции.
Ну, это результат вызова функции, у которой возвращаемый тип с двумя амперсандами.
Ну, понятие X-value видимо только с 1 стилем.
Чем она протувшая тогда?
Это что самое ее есть?
Нет, это… Что такое?
Это ссылка на какой-то объект, но R-value — ссылка.
X-value — ссылка означает, что этот объект…
Ну, выкинуть на свалку, можно у него забирать поляпора.
Значит, X-value — идея в том, что это некоторый объект,
который реально в памяти лежит, и он жил, существовал,
но его move-нули.
Ну, то есть его либо скастили, не обязательно static-cast,
любой каст к типу с двумя амперсандами, разумеется.
Его либо скастили к типу с двумя амперсандами,
либо вернули из функции ссылку с двумя амперсандами.
В частности, результат move-а — это X-value.
Вот.
Также X-value является, значит, знак вопроса двоеточие
из опятая в понятных каких сценариях.
А также еще некоторые выражения, которые мы с вами увидим.
Ну, например…
Ну, например, там, скажем, обращение по индексу
к объекту, который был R-value, скажем.
Ну, там что-то такое.
Ну, если у вас был вектор из каких-то строк,
и вы сделали std move от этого вектора, квадратные скобочки по индексу,
то получится X-value, потому что оно…
Ну, понятно, что его забирать можно.
Вектор-то вы move-нули, значит, его содержимое как бы просроченное.
Аналогично, если вы…
Это вот как раз тот самый пример, который я в прошлый раз пытался было сказать,
но позапрошлый даже, но не очень корректно сказал.
Если вы взяли какой-то R-value и к полю обратились,
причем это поле само было объектом.
Вот там уточнение.
Мы с вами выясняли, что если просто к полю обратиться,
это еще не R-value.
А если вы взяли R-value объекту и обратились к полю,
и само поле было объектом, то это тоже X-value считается.
Короче говоря, это когда вы точкой обращаетесь к R-value объекту
или квадратными скобочками по индексу обращаетесь к R-value вектору.
Или, видимо, стрелочкой.
Или стрелочкой.
Ну, и в общем, ну, и либо когда вы кастите.
То есть идея в том, что это такие виды, такое value,
которое было полноценным объектом, но его как бы move-нули.
То есть вот это то value, для которого нужно вызывать R-value-шные операции.
Хотя оно было, как казалось бы, полноценной переменной.
В противоположность этому PR-value.
Это штука, которая, ну, формально это просто все остальное R-value,
а неформально.
Вот это тоже довольно такая, не сразу пришедшая ко мне интуиция, я не знаю.
А может быть не move-нутая R-value?
Что с не move-нутой R-value? Что?
Не move-нутая R-value.
Ну, A плюс B у тебя.
Вот A плюс B результат суммы. Это R-value.
Его никто не move-ал, оно просто на месте создалось, и это R-value.
Так вот.
Ну?
Ну, если тип поля M был классовым,
например, у вас в поле была строка,
и вы сделали вот такое точка M, где M это строка,
тогда выражение будет считаться X-value.
Если вы его передадите в функцию, которая может принимать const string&,
или string 2&, вы попадете в версию со string 2&.
Потому что эта штука, по логике вещей, должна быть move-нута.
А как выражение из нескольких частей, где одна часть X-value,
другая X-value, это будет R-value считаться?
Что такое части? Какое выражение?
Пусть у нас вот была какая-то строка, которая была X-value,
мы к ней прибавили строку R-value.
Строка... Не может.
Это положение двух строк?
R-value определяется для верхнего уровня.
Для этого выражения?
Бинарный плюс от R-value, я же вам говорил.
Обычное R-value, причем не move-нута.
Бинарный плюс вообще для строк.
Это некоторый оператор переопределенный.
У него есть возвращаемый тип, просто string.
Тогда он по R-value.
Вот.
Зачем это все?
Вопреки распространенному заблуждению,
это, как я уже сказал, для понимания,
как работает move или forward не нужно.
Зато это нужно для понимания,
как работает вот эта штука.
Copy-elision.
Что такое copy-elision?
Давайте рассмотрим следующий код.
Я пишу string...
Например, я пишу string...
О, какой хороший маркер.
string s равно...
Ну, если это string, я имею в виду,
равно string круглые скобочки.
Как это по-вашему должно работать?
Оно вызовется...
Сколько конструкторов вызовется?
Ну, хотелось бы...
А как это работает?
Он возвращает move.
То есть, если мы...
Вызовется ли move-конструктор для нас?
Да.
Допустим, у строки есть move-конструктор.
Вообще очень хотелось бы,
чтобы это произошло просто как конструктор
для строки.
Кто считает, что вызовется move-конструктор?
Ну, по идее ложечки.
Ну, по идее ложечки.
Я...
Вы все никак не запомните,
что если я задаю такой вопрос,
на кто считает, то правильный ответ не такой.
Нет, конечно, не вызовется
никому move-конструктор.
А, хорошо.
Это похвально, да.
Да.
Если подходить к этому делу
чисто формально, так сказать, педантично,
то есть идея, что
в нашем C++03 мире,
как мы это себе видим,
да даже в C++11 мире,
в рамках того,
что мы формально изучили,
это некоторые expression,
здесь называется конструктор по умолчанию,
а это некоторые инициализации,
то есть мы должны строку S конструировать
от того, что справа,
то есть как бы мы должны строку S
сконструировать от вот этой штуки,
которая является R-value строкой,
конструктор строки.
Но комитет давным-давно понял, что это какой-то бред
и вообще-то незачем делать
дважды вызов конструктора,
когда можно один раз сделать.
Но как это формально
как формально сказать,
в каком случае
компилятор имеет право
не вызывать
второй конструктор. Другой пример.
Давайте представим, что я сейчас
делаю следующие. У меня есть некоторая функция,
посмотрите, пожалуйста, на второй пример.
У меня есть, я вам привожу
еще один пример подобного рода,
представьте, у меня есть функция, которая принимает
строки, я не знаю, по ссылке,
неважно, по какой даже,
и я передаю в нее следующую вещь,
string от
string от
вот так вот,
от ничего. Сколько
конструкторов вызовется?
Один.
Все еще. Создаться лишь одна строка.
Эта штука будет просто
как бы, забьет компилятор
на нее.
Да. Не важно, сколько раз
я напишу, не важно, сколько раз
я напишу string от string от
string от чего-то.
Компилятор, да, это
по сути тот же самый пример.
Компилятор в таких ситуациях просто
забивает создавать
промежуточный временный объект.
Он сразу создает финальный объект, который
должен у него в конце получиться
сразу на нужном месте в памяти.
Он не делает временный string,
чтобы из него moveнуть сразу.
Это явление как раз называется
copy-elision. Вот вас где-нибудь
на каком-нибудь
собеседовании или экзамене сейчас могут
спросить, copy-elision это
как объяснить такое copy-elision
в двух словах? Это когда вместо
копий конструкторов вызывается move-конструктор, это
неправильный ответ. Правильный ответ
copy-elision это явление, когда компилятор
избегает вызова и копии,
и move-конструкторов. Он просто
забивает на создание временного объекта.
Вот что такое copy-elision.
Какой вопрос?
Там нет
никакого труга, чтобы
заставить его там попытаться
в два объекта это сложить.
Что-то в духе t равно s равно string.
Вот, давайте я вам скажу,
я не знаю, это какой-то
сложный вопрос, не могу.
Результат присваивания.
Это же string от vector от string
от одного
от нуля.
Я не очень понимаю, что такое string от vector от string.
Это хороший вопрос,
сейчас я тебе про это расскажу,
сейчас я чуть позже расскажу про этот пример.
Давай
я запишу его.
String от
vector от string
от vector из строк
от одного
от одного
от нуля.
Сколько раз
вызовется конструктор? Это хороший вопрос.
Да.
Нет, здесь copy-elision уже не спасет,
не сработает.
И вот почему. Потому что существует
как раз формальное правило, когда компилятор
имеет право не создавать промежуточный
временный объект. Отгадайте когда,
для чего я вам рассказывал про эти категории,
когда он pair-value.
Значит, если у вас
компилятор видит, что есть некоторое
pair-value, из которого создается
другое pair-value, из которого создается другое
pair-value и так далее, из которого
наконец-то создается объект,
переменная какая-то, ну или
финальное выражение,
то все промежуточные pair-value
компилятор имеет право просто не
создавать.
Можно еще раз формально
ответить?
Если у вас есть
pair-value, из которого создается
несколько раз pair-value,
а в конце наконец что-то создается
и выражение на этом заканчивается,
то все эти промежуточные штуки, которые являются
pair-value выражениями компилятор имеет
право не создавать.
Вот именно здесь это и происходит.
Вот здесь вот
создается pair-value, из которого
создается string, который придется в строку.
Если я здесь сколько угодно раз бы написал
string от какого-то pair-value,
от какого-то еще pair-value,
то компилятор имел право просто это все соптимизировать
только настоящий только финальный стринг нет потому что x value это сейчас потому что x value
это по смыслу это то что реально существует в памяти вот x value это некоторая реально
существующая вещь в памяти а pair value это штука которая вообще может не существовать она может
только в каких-то промежуточных рассуждениях фигурировать но под нее может фактически не
создаваться даже в памяти ничего не факта может быть и существовать если компилятор ну например
вот это же компилятор в итоге должен создать чтобы его по ссылке отдать но я не понимаю что
значит нужна это какой-то короче pair value это то что компилятор имеет право просто не создавать
вот оно может как как выражение быть написано но реально в памяти ему ничего не соответствует так
кто ну я не знаю давай ты стринг положим в смысле стринг от стринг от abc но abc это будет
конс чар звездочка конс чар звездочка конечно же существует где-то в статической памяти и кстати
возможно поэтому она и l value как раз потому что для под нее же нужно выделить статическую как минимум
память строковые литералы нужно хранить статической константной памяти но промежуточный стринг все
еще может быть не создан а этот стринг конечно будет создан потому что по ссылке нужно туда
отдать промежуточный не будет создан да если вы напишите стринг от стринг от abc в кавычках то
у вас лишь один раз выдается конструктор стринг это начиная си плюс 117 причем гарантированное
поведение до си плюс 117 это было такое implementation defined но желательное поведение а начиная си
плюс 117 это гарантированное поведение называется гарантированный копии лежан кстати наш
соотечественный кантон полухин принял участие в разработке этой фичи стандарт насколько я помню
вот если я ничего не путаю да
если у тебя есть значит смотри если ты делаешь стринг сейчас давайте вы задаете правильные
вопросы я давайте сначала расскажу все что хочу а потом вы у вас часть вопросов вот падет я еще
пока не рассказала вот про этот пример я сейчас как раз про него и расскажу я его записал чтобы не
забыть про него и про этот пример я тоже запишу потому что они все относятся к одному и тому же вот
я скажу стринг от abc плюс а на самом деле это все об одном и том же а это еще одно явление
которое называется temporary materialization существует следующие явления для того чтобы вот с такими
ситуациями правильно разбираться в стандарт вели следующие понятия называется temporary
materialization что такое temporary materialization это явление когда r-value превращается в x-value
pair-value превращается в x-value смотрите temporary materialization вот смотрите у выражения есть
категория и если вы почитаете формально стандарт то на самом деле когда у выражения меняется
в л и категории это тоже считается кастом ну то есть вы существует например понятие неявный
l-value to r-value cast вот существует понятие неявный pair-value to x-value cast и он как раз и называется
temporary materialization что это значит это значит что в некоторых ситуациях выражение которое является
pair-value при некоторых его использованиях должно быть компилятором сконвертировано
в x-value а следовательно как последствия должно быть создан объект под него это происходит в
частности когда вы обращаетесь к полю или обращаетесь к методу или когда вы скажем так
когда это самое старшее я не помню как это формально сказать в общем когда это когда вы
привязываете его к переменной ну вот когда у вас есть что-нибудь такое string&s равно string это
тоже temporary materialization то есть вот это выражение само по себе pair-value но из-за контекста оно
должно быть компилятором как бы трактовано как x-value то есть под него должно быть создан
реальный объект если выражение реально если к выражению привязывается некоторая переменная
должно произойти temporary materialization то есть реальное создание объекта под соответствующего
это выражение как ну кон string&s да вот да ну или string&s то есть когда вы привязываете когда
происходит когда вы привязываете переменную к выражению это кстати происходит здесь когда вы
когда вы в передаете вот это там же у вас что-то принимается его фактически привязываете
переменную к этому выражению происходит temporary materialization когда вы обращаетесь к полю или к
методу вот например здесь происходит temporary materialization потому что что такое vector string
от одного квадратной скобочки 0 ну вообще-то это x-value если уж так-то вообще вот это само по
себе выражение x value потому что это один из примеров x value я же говорил помüllt про
квадратные скобочки если я квадратными скобочками обращается к вредному объекту
то это x values а значит для него не ра б не т я сказал это раньше про квадратные скобочки
здесь я говорил про тύпс не только не записал вот это времlett vector который сам по себе
пр väl но обращение квадратными скобочками к нему это уже выражение x value это означает что
этот вектор реально должен быть создан он не может проглотить все это и как бы не
не создать только финальный стринг.
Чего?
Здесь я должен создать хоть одну строку.
Вот если бы это стринг передавалось куда-то там
еще и не происходило, под стринг сам по себе вот
этот создавать, можно ничего не создавать.
Что значит просто стринг-амперсант?
Если ваше pair value это и есть все выражение, то это как
бы верхний синтоксический уровень expression, то это все
равно оно создается.
То есть стринг от стринг от стринг от стринг создастся
один стринг, потому что на последнем уровне произойдет
temporary materialization.
Вот он все pair value проглотит сколько надо раз, и на последнем
шаге он будет считать, что это x value, потому что это
финальная стадия вычтения выражения.
Здесь произойдет это, потому что мы к переменной
привязались, здесь произойдет это, потому что мы к переменной
привязались, когда функцию передали, здесь произойдет
это, потому что мы к переменной привязались, здесь произойдет
это, потому что мы к оператору обратились, то есть мы фактически
сделали к этому вектору точка оператор квадратной
скобочки от чего-то.
И здесь произойдет тоже temporary materialization, потому что
мы опять к оператору обратились, то есть мы либо мы вызвали
метод плюс от чара у строки, либо мы вызвали функцию
оператор плюс внешнюю от стрингом персанта чего-то,
но мы в любом случае привязались к переменной.
Вот здесь вот происходит temporary materialization, то есть здесь
реально будет создана строка, а потом создана вторая строка.
Но если при этом я напишу, скажем, стринг s равно вот
такое, то будет создано всего две строки, а не три.
Первый раз будет создано строка вот в этой ситуации,
а второй раз будет создано строка, являющейся их суммой,
и для нее произойдет copy lesion, потому что эта строка
уже pr-value снова.
Да, вот эта вот штука начинает считаться x-value, а следовательно
под нее нужно реально создать объект.
Из-за оператора плюс?
Из-за того, что мы вызываем, по одному из правил, мы вызываем
метод строки, но если это внешняя функция, то это
значит, что мы стринг этот передаем по ссылке в какую-то
внешнюю функцию, а это тоже temporary materialization.
Да.
Я имел в виду то, что тут у нас конструктор от другого
стринга что-то делает, и наоборот он увеличивает
какой-то счет.
Что значит конструктор от другого стринга?
В смысле, допустим, у меня не стринг, а какой-то метод,
который в конструкторе выводит все ауты, я создался.
Так, еще раз, тихо.
Послушайте, вот если у меня конструктор этой строки,
это вообще вопрос такой тоже, а-ля вопрос собеседований.
У меня, допустим, тип таков, что он логирует свои конструкторы
и деструкторы.
В конструкторе он пишет «я создался», в деструкторе
он пишет «я уничтожился».
Сколько раз будет написано «я создался» в этом примере?
Один.
Один, да.
Конструктор не будет сделан, в этом и прикол.
Жаль вас.
То есть, если мы окажемся на то, что…
Вот, компилятор оптимизирует промежуточные вызовы объектов.
Он считает, что ПРВЛ можно не создавать, если они
ни к чему не привязываются.
И сайд-эффекты не проверяют?
И сайд-эффекты игнорируются, не будет сделано.
А что еще?
Кайф.
Чтобы вот такой код работал и не создавал тебе промежуточный
стринг.
Вообще-то, он так-то много сайд-эффектов конструктор
стринга делает.
Он там…
РВО, да, ну по сути, да.
Мы считаем, что конструктор в копировании только копирует.
Но вот только мы хотим, чтобы конструктор в копировании…
Я слишком долго.
Давайте дальше.
Ну, типа, я все сказал.
Ну, формально вот это так работает.
А если вы…
Чего?
Подожди.
Чего ты хотел спросить?
Почему стринг, особенно стринг со скобочками, там
что-то превращается?
Что еще раз стринг?
Правый, верхний, зеленый пример.
Почему там…
Потому что я инициализирую переменную посредством
этого выражения.
А, в смысле, само это выражение…
Само это выражение используется для инициализации какой-то
переменной.
Это только так один move, так?
Нету move, а тут один ровно конструктор.
Даже так?
Да.
Если бы move, то это бы работал ровно так же, как бы не было.
Правое выражение.
Ну, я не знаю, как это в стандарте аккуратно написано.
Здесь не делается… Не создается промежуточный стринг.
Ну, я не знаю, как еще вам сказать.
Создается ровно один стринг, вот этот.
И он и считается этим S.
Ты сначала сказал, что вот эта штука работает, когда
pair value.
А сейчас ты говоришь, что это превращается в X value.
Формально для компилятора temporary materialization называется
cast pair value X value.
Во время этого каста происходит реальное создание объекта.
В то же время, если мы… Это происходит, например,
когда мы инициализируем переменную посредством этого
выражения.
В то же время… Ну, там как-то это написано.
Я не могу дословно процитировать стандарт, но там написано
так, что создается ровно одна стринг в этом случае,
и она и является это S.
Не создается второй.
В этом вся идея.
Чего?
Не, давай не надо, мы сейчас это очень долго застрянем
на этом.
Возможно… Слушайте, возможно, я… Можете, пожалуйста…
Возможно, я вас обманул в том плане, что это все-таки
создается X value, несмотря на то, что… Ну, я не помню
досконально, формально, вот как описано.
Там очень запутанно описано это, потому что там написано
много костылей в стандарте, как правильно, что, к чему,
в какой момент, каким value считается, чтобы все работало
как надо.
Но работает это в конечном итоге так, что если у меня
переменная с помощью этого инициализируется, то
ровно один раз создается объект, а если у меня много
раз делается pair value и ни к чему не присваивается,
то в конце создается объект под него.
Вот здесь создается объект, потому что это X value.
Вот здесь создается объект, потому что вызывается
оператор, это становится X value.
Здесь создается только один объект.
С оператором это X value.
Да, вызов оператора у временного объекта делает его X value.
И объект под него создается.
Вот.
В частности, еще, например, если вы говорите string…
Вот смотрите такой пример.
String s равно vector string от одного квадратной скобочки ноль.
Сколько здесь вызывается конструкторов стринга?
Нет, тут я говорю, я вот string нециализирую этим.
Но он обязан создать объект vector?
И оператор копирования.
Во время вектора он создает, пока будет создавать вектор…
String, наверное, один.
Нет, пока он будет создавать вектор, он создает string.
Значит, он создает string, когда будет создавать вектор,
а дальше ему просят квадратные скобочки ноль.
И по идее эти квадратные скобочки должны вернуть ему
одиночный амперсант, то есть deal value.
Ну вот, кстати, да, здесь ответ зависит от того,
реализована ли R-value версия квадратных скобочек.
Я думаю, что реализована.
Чего?
В любом случае, это будет уже X-value.
Вот это выражение?
Нет, потому что это перегруженный оператор.
Если он возвращает ссылку…
Если он возвращает L-value ссылку…
Да, я вам неправильно сказал.
Вот здесь результат этого оператора,
он зависит от того, какой там тип возвращаемый.
Если это L-value ссылка, то это будет L-value,
и он скопирует его.
Он же так natuurlijk не может возвращать
одновременно L-value ссылку и R-value ссылку.
Нет, у тебя мог бы быть две версии оператора.
Один для L-value, другой для R-value.
Возвращаем изначально типpants.
Возвращаем его значение.
Что?
У тебя может быть два разных оператора квадратной скобочки,
один для L-value векторов, другой для R-value векторов.
Один будет возвращать L-value ссылку,
и тогда это будет L-value выражение,
другой будет возвращать R-value ссылку,
и тогда будет R-value выражение.
Наверное, так.
Во втором случае это будет x-value, оно мувнется.
А в первом случае, наверное, оно все-таки копернется.
Но в случае вектора, я уверен, что будет правильно работать,
потому что у вектора реализовано все, что надо.
Правильно это будет?
Ну да, должно мувнуться, я думаю.
Я верю, что вектор реализован так, что там правильная версия.
Вы сказали, что оно, в суть, это x-value, правда?
Вот эта часть будет x-value, потому что к ней обратились
квадратными скобочками, и временный вектор должен
создаться по этому.
А вот это будет, наверное, там ошибся, что это всегда
x-value, это зависит от того, что возвращают квадратные
скобочки.
Квадратные скобочки могут вернуть l-value ссылку, и тогда
это, наверное, будет l-value все-таки.
Значит, это что угодно, как и pair value.
Но это не pair value точно.
Нет, если квадрат с копчика возвращает вам копию, то
это будет pair value по обычным правилам.
Но квадратный скобочек возвращает вам ссылку, это значит,
будет либо l-value, либо x-value.
тогда это мувница, вот если это будет x-value. Но если вы... если у вас был... я другой пример
хотел показать... если у вас был вектор, если у вас был вектор, если у вас был какой-то тип и в нем
было поле строка, вот что будет здесь? Вот здесь будет move. Ой, не так. Если у вас был, значит,
какой-то объект и в нем поле... вот вы создали временные объекты, в нем было поле строка. Вот
это будет move по вот этому правилу, потому что обращение к полю временного объекта, если это
сам объект, то это x-value по вот этому пункту, и тогда это будет мувница, несмотря на то, что казалось бы
там l-value. Но нет, это x-value по этому правилу. Вот. Я понимаю, что я все мог запутать, но да ладно.
Так, давайте. Копии лижен обязательно происходит, начиная с 17, если вы pair-value,
из него создаете pair-value, из него и так далее создаете pair-value, до тех пор, пока вы либо не
создадите x-value наконец-то, либо вы не пронициализируете какую-то переменную этим,
либо пока выражение не закончится. Так, еще раз, последний раз говорю, больше не возвращаюсь
к этому. Если у вас есть выражение, в котором несколько раз из одного pair-value создается
другое, то все эти вызовы pair-value компилятор обязан просто проигнорировать и сделать только
самый последний, который наконец является собой присваиванием переменной, на котором вычтение
выражения заканчивается. Или это x-value. Какой вопрос? Да. Где мы возвращаем копию? Что?
Что? Нет, ты такого не говорил. Я сказал x-value это pair-value reference. Что? Где? Вот это. Я уже, блин,
говорил это. Я уже говорил, что здесь будет. Здесь будет temporary immortalization один раз,
потом вернется pair-value и произойдет copy-elision. Первый раз произойдет temporary
immortalization, второй раз снова создается pair-value и оно не будет move-аться,
потому что это pair-value произойдет copy-elision. Создаться две строки. Первый раз вот это,
второй раз та, которая получилась в результате и произойдет copy-elision. Да, вот этого оператора.
Да. Второй раз происходит copy-elision. Вот в словосочетании temporary materialization давайте
сделаем, как в восьмом классе школы учили, анализ этого словосочетания. Это, значит,
словосочетание со связью какой? Ну, тем не менее. У нас бывает словосочетание согласование,
управление и примыкание. Вот это какая связь? Вот, значит, неправильно считать,
что это словосочетание вот так вот разбирается, что это прилагательное, это существительное. Нет,
значит, в этом словосочетании главное слово материализация, а это, значит, вот так вот это
разбирается. Значит, здесь оба этих, оба этих слова существительные и связь здесь управлены. Ну,
это сложно говорить про связь, потому что это английский. Temporary это существительное,
материализация временного. Temporary это некоторая вещь, которая материализуется. Вот если вы
правильно понимаете перевод этого словосочетания, то вы правильно понимаете, что это такое. Неправильно
считать, что это временная материализация. Нет, это материализация временного объекта,
который мог бы и не создаться, но создался, потому что стал x-value. Вот. Ну,
вот не знаю. Так вот. Так. Что такое RVO? Что такое RVO теперь? Time for teletubbies. Ладно,
вы слишком молодые, вы не знаете этих приколов. Что такое RVO? Ну, RVO это copy-leash,
который при возврате из функции происходит. Так было до C++17. Начиная с C++17 чуть-чуть
определение изменилось, но суть осталась той же. А когда вы из функции возвращаете pair value,
ну, то есть у вас есть функция, которая возвращает какой-то t, и тут значит t значит x,
что-то происходит, return x. Ой, нет, виноват. Вот для начала рассмотрим просто такой пример.
Return t. Что происходит? Вот здесь вот создается всего 1t, а не 2. Потому что происходит опять
copy-elision. Вот такая copy-elision, которая при возврате из функции происходит, называется return
value optimization. Так. Ну, это тривиальный пример. Не тривиальный пример. Это когда у вас есть вот
такая вещь t, x, и вы делаете return x. Это уже формально не считается copy-elision, начиная с C++17,
если я ничего не путаю. Но это все технические детали стандарта, а суть в том, что компилятор опять
скорее всего не сделает промежуточного x, а сразу создаст вот этот t на месте возврата. Да,
скорее всего, потому что вот это уже не гарантирующаяся copy-elision. Это уже не гарантируется,
но так делают почти все компиляторы. Ну, можно извратиться и попытаться написать такой код,
в котором компилятор не догадается. Ну, например, если вы из разных путей из функции возвращаете
разные объекты, то компилятор может не догадаться, это соптимизировать, и тогда у вас будет, значит,
лишний объект создан. Но в таком стандартном сценарии, когда вы вначале объявили ответ и его же и вернули,
чтобы не случилось, когда у вас нет разных return, разных вещей, компилятор сразу вот это создаст на
месте возврата функции. Вот. Правда там, ну вот, например, если у вас функция кидает исключения в
некоторых ситуациях и выходит нештатно, то тоже у компилятора может не получиться, потому что откуда
он знает, ему, значит, что делать. Ну, в общем, можно придумать сценарий, в котором компилятор,
наверное, это не соптимизирует. Но вообще он должен постараться, скажем так. Вот это называется
nrvo named return value optimization. Вот это named rvo. А даже если компилятор не сумеет соптимизировать это,
он обязан сделать move. То есть, если вы из функции возвращаете переменную, я не уверен насчет других
lvalue, но если возвращаете просто переменную из функции, которая временная, ну, которая локальная
переменная этой же функции, компилятор должен постараться это соптимизировать и не создавать
вообще никакого лишнего объекта. Но если у него не получилось соптимизировать так, чтобы copy
legion случился, то, по крайней мере, он обязан сделать move вместо копирования. Ну, move, в смысле move
оператор, move конструктор, а не copy конструктор вызвать. Ну, а что там у вас реализовано, это к вам
вопрос. В связи с этим является ошибкой, свидетельствующая непонимание. Вот это такой тоже
хороший вопрос. Написать вот так. Некоторые так пишут и продалбываются. Написав так, вы делаете
строго хуже, потому что компилятор и так бы попытался move-нуть, если у него не получится
рво, но так вы не дали ему сделать рво уж точно, он не вынужден будет move-ать. Ну, потому что это
xvalue. xvalue он должен move-нуть. Вот. То есть писать move вот в такой ситуации неправильно. А,
если мы по какой-то странной причине хотим, чтобы он обязательно move-нул. С другой стороны,
если у вас там есть какой-нибудь оператор, скажем, big integer, оператор плюс от, и вы такой
оптимизированный оператор написали, который первый оператор по R-value ссылки принял,
или который его вообще по значению принял, то вот тогда вам move имеет смысл написать,
потому что это же не локальные перемены, но он не мог сразу ее создать на месте,
где у него будет возврат. Да. Вот здесь вам можно писать move, да. Ну, когда вы big integer,
оператор плюс. Кстати, сейчас надо подумать, вот если вы так, если вы по значению приняли big
integer, то сможет он его move-нуть или нет? В смысле, сможет он его оптимизить на выход?
Наверное, все-таки сможет. Наверное, да, вот в такой ситуации я бы move не писал,
но вот в такой точно нужно move написать. Если я принял его как R-value, то надо move писать.
Нет, если вы напишете return a и не сделаете move, то будет копирование. А если вы приняли
pair-value с ссылки и хотите вернуть по значению, то вам надо move писать. Слушай, ну с lang-tidy мы уже
выяснили, что иногда советуют странные вещи. Так, так, так, так. Все ли я сказал про RVO?
Вроде все я сказал про RVO, что хотел. Обычное RVO, когда у вас было не X. Было обычное RVO до этого
примера. Все, кажется, я все сказал по поводу этого. Так, нам остался последний пункт,
связанный с move-семантикой, и он будет называться применение move-семантики для реализации pushback.
Сейчас мы вернемся снова к вектору нашему старому доброму и перепишем pushback уже на уровне даже
не средний и не старших классов, а почти на идеальном уровне. Вот сейчас мы, кажется,
впредпоследний раз вернемся к pushback и напишем его почти как следует. Последний раз, ну типа да.
Так, слушайте, мне тут надо ответить на телефончик.
Да, здрасте. Слушайте, у меня для вас грустные новости, уже не актуально оказалось для нас.
Да, да, да. Все, хорошо, до свидания. Такс.
Пункт десять точка восемь, а move-семантика в векторе. Вектор pushback давайте прям конкретно скажу.
Плохо видно? Давайте свет выключим. Нет, он включен там. Да, ну чуть-чуть получше стало.
Получше стало? Давайте может желюзию задвинем, может чуть-чуть поможет. Стало лучше.
Ну стало получше по-моему. Все прекрасно. Так, господа, теперь с нашими новыми знаниями давайте
напишем pushback правильно. Я даже не поленюсь вот это все скопипастить. Да, напишем pushback
почти правильно, значит. Во-первых, я скопипачу часть про локацию. Я напоминаю, что да, если capacity,
давайте так, если capacity сейчас равно size, то мне надо сделать все вот это. Так? Вплоть
докуда? Вплоть до? Вот это кажется нужно убрать, а сделать здесь вот так. Так? Если capacity равно
size, то вот так. Писать-то писали, только господи, как же мне не нравится наше обозначение, это
отвратительно, потому что у нас нет полей capacity и size. Мы выбрали другой путь. Слушайте, давайте
я все-таки перейду на привычное мне обозначение. У меня будет два числа, ну потому что и так, и так
умереть хочется. Давайте я просто скажу, что у меня все-таки есть массив и, значит, два числа с
size и size cap, потому что иначе и так будет куча багов. Не-не-не-не, это будет неэффективно. Ты что?
Зачем мы не платим за то, что мы не используем? Мы не хотим делать заранее реаллокацию, если она нам
не нужна, прям сейчас. Нет. Так следующего раза может не быть. Ну вот если будет, тогда и сделаем.
Господа, много вопросов нет, мы сейчас опять не успеем. Так, давайте заново смотреть. Мы выделяем
новый массив. Как мы его выделяем? Ну теперь мы уже знаем, что надо через trades обращаться к
локатору. У нас тут написано, что такое trades? Да, у нас написано, значит, alloc trades. Значит alloc
trades allocate. От чего? Первым аргументом надо передать локатор. А как его передать? Ну надо
передать себя, видимо. Я напоминаю, мы это и есть allocator на самом деле. Мы приватный наследник
allocator. К сожалению, это не сработает, потому что, потому что, потому что, потому что мы приватный
наследник с точки зрения allocator, мы не allocator. Давайте я сделаю, как это по C++20 все-таки делается.
А именно, там есть аргумент. Кто помнит, как он называется? No unique address, да. Я вам про него
говорил. Ну, я просто allocator объявляю своим полем, у которого может не быть уникального адреса.
Ну, могли, но это, но это долго. Ну, в смысле, это некрасиво. В смысле, непонятно. Так,
во-первых, давайте тишину создадим. Что непонятно? Это было уже, я про это рассказывал. Эта штука
начинается C++20, которая позволяет вам пустое поле, чтобы не занимало ни одного байта. Да,
более того, нужно. И те, кто так не сделает, будут правильно переделывать. Ну, если вы сделаете
наследником, может быть, кстати, и засчитаем. А вам больше нравится приватный наследователь
чем вот это, да? Я понял. Да, проходили, да. Прикинь. В каком пункте? В пункте 9.3, кажется. Когда
я рассказывал про EBO в Allocator. Господа, мы сегодня должны закончить вовремя, а поэтому я хочу не
отвлекаться на вопросы по предыдущим темам. Мы сделали Allocate. Дальше, мы сделали Constract опять
через Allocator Trades. Мы говорим Alloc Trades, Constract, new R pluses. Ну, значит, Alloc первым
аргументом опять new R pluses begin it. Не begin it, а что? R plus, R it. Теперь, если мы сделали Catch,
то мы говорим Alloc Trades destroy new R pluses g. Только первым аргументом опять передаем Allocator.
Дальше мы здесь опять говорим Alloc Trades deallocate и первым аргументом опять передаем Allocator.
Здесь мы говорим опять Alloc Trades.destroy и первым аргументом передаем Allocator.
Да, new cap отличный вопрос. А что такое? Да, new cap нам нужно сделать size t, давайте скажем new cap,
равно 2 умножить на cap. Ну, я скажу это минимум, точнее максимум из 2 умножить на cap и единицы.
Ну, потому что если у нас исходная к пейсте была ноль, то мы должны 1 сделать, правильно?
Ну, я сейчас не пытаюсь соблюдать code style в идеальном варианте, поэтому,
но если хотите могу написать вот так. Так поможет. Так, и последнее Alloc Trades deallocate.
Значит Alloc Trades deallocate что? Первым аргументом опять Alloc, дальше R и какой параметр был? Cap.
Вот. И в конце мы должны сделать cap равно new cap. Так? Правильно я ничего не забыл.
Я переименовал поля, у меня есть, ну да, delete равно R, delete не равно R плюс CZ, плюс-плюс delete,
вот так, да? Так, ну на самом деле я пока ничего нового не написал, это я просто переписал то,
что мы и так знали, только через Allocator Trades. Вот, и теперь здесь я должен сделать снова Allocator Trades,
Alloc Trades 2.2.construct. От чего? От R плюс CZ, а кстати, что такое R? Нам нужно еще сказать R
равно new R, правильно? Правильно? Вот, R плюс CZ, value, ну и Allocator первым аргументом, и плюс-плюс CZ, так?
Совершенно верно, да. А если у нас исключение вылетит где-нибудь здесь, ну нам надо на самом деле
вот это перенести вверх, вот это нам нужно перенести сюда. Что? Значит, нам в pushback нужно,
это проблема, почему мы pushback через reserve не можем выразить не тривиально, потому что нам
нужно сделать констракт вот этого всего, потом констракт последнего, и только если все это произошло
удачно, начать все освобождать, и только в самом конце сделать плюс-плюс CZ. Ну да, если мы что-то
поймали, то мы делаем throw, вот это уже исключение не кидает, и мы просто вот здесь вот заходим,
это если cap было равно CZ, ну а иначе мы просто должны сделать вот это, ну здесь, кстати, нам
можно и не делать try, потому что если это кинет исключение, то мы просто сразу же вылетим, а вот
это можно перенести за if, кажется, правда? Да, cap равно new cap нельзя, это правда. А, и саром согласен,
да. Согласен. Какую ишку? Зачем? Этот же мы никогда не будем делать
лоцировать, делать destroy. Какой? Что new R? Где? А, new R плюс CZ, да. Так, вот это то, как бы выглядел
наш pushback до того, как мы придумали move семантику. Что? Что почему? Потому что мне
нужно вот этот констракт последнего элемента сделать внутри try, и если он не удался, то мне
нужно диалоцировать все то предыдущее. Reserve, допустим, я все реалоцировал, все переложил,
и последний элемент кладу, и он exception кидает. Тогда мне нужно антиreserve делать, что ли? У меня
нет такого. Я должен вот это все внутри try запихать, чтобы, если что, диалоцировать все. Я про insert
вообще ничего не говорил. Ну можно, да. Так, ну вот. Хорошо. Теперь move семантика появилась. Что
позволяет нам move семантика сделать? Мы, напоминаю, у нас была одна из проблем в pushback, и мы не хотели
копировать при перекладывании, а вот здесь мы именно этим и занимаемся. Правда? Мы хотим здесь
написать не RIT, а std move от RIT. Правильно? И здесь мы хотим, а вот здесь мы хотим написать std move
от value или нет? Мы не можем, потому что, ну мы можем, но оно const, поэтому все равно это не будет
работать как move. Вот здесь мы не должны писать move. Понятно, почему? Это правильный вопрос. Нам бы неплохо
в pushback уметь принимать R-value тоже. Да, если бы мы приняли R-value, то мы могли бы сделать std move.
Да. Мы могли бы написать универсальную ссылку здесь и делать forward в месте, где мы value
передаем, в allocator. Да и в самом allocator нам надо forward делать. Вот здесь вот, теперь у нас тут
allocator написано, я напомню. Здесь нам надо делать не так, а вот так. Я напоминаю. Правильно? Кстати,
вот здесь можно же избавиться от reinterpret cast, потому что мы теперь знаем, что у нас есть вот
такая функция. Нам больше не нужен reinterpret cast. Игейно. Да. И здесь мы делаем просто оператор delete,
собственно так это и надо писать. Оператор delete, причем без квадратных скобочек, кстати,
заметьте. Да. И что это доказывает? Я, видишь, делаю без квадратных и говорю, заметьте. Я тебе
больше скажу, если ты в векторе проверишь, какой он вызывает оператор, то он вызывает new без
квадратных скобочек. Проверь. По-моему, он вызывает оператор new без квадратных скобочек.
Зачем? Он просто byte выделяет вот в таком количестве. Он выделил нужное количество byte,
освободил нужное количество. Да, запоминает уже не он, да. Ему не нужно делать new с квадратными
скобочками. Зачем? Это переусложнение. Так вот. Чего? Я не помню. Escape нажал, наверное. Так.
Так вот. Здесь мы могли бы написать SD forward от value, но вот сейчас важный момент. Мы не хотим
принимать в pushback универсальную ссылку, потому что это будет означать, что мы должны pushback
сделать тоже шаблонным. А это значит, что он будет принимать не только T, а еще все подряд другие
типы. И нам либо нужно писать шаблонную магию, чтобы он принимал только T, либо он будет уметь
делать конверсии либо статик ассерт, либо он будет принимать и другие типы, делать какие-то
неявные конверсии и будут странные ошибки компиляции. Короче, стандартный pushback так
не написан. Стандартный pushback на самом деле просто в двух версиях написан. Один принимает
const T&T, другой принимает T2&T. Я говорю, можно, но мы не хотим, потому что это переусложнение.
Это будут какие-то непонятные ошибки для пользователя. Стандартная библиотека
делая... стандартная библиотека разобатывается по принципу добавления функций, а не переписывания
существующих. Да, так будет copy-pass, но это стандартная библиотека. В смысле нам надо выразить
просто эти два pushbacks через одну общую функцию, какой-нибудь приватный pushback, который
принимает уже универсальную ссылку, но переходить в него из этих двух pushbacks только с нужным типом.
Вот. Ну, в принципе, можно так и сделать. Давайте я так и сделаю. Значит, template,
type name, u. Давайте я скажу pushback private, который принимает u, двойной амперсант.
Чего? Потому что мы его приняли по констей амперсанду, как мы его move-ить будем.
Теперь мы будем делать forward от value, а не move. Значит, теперь у нас есть так,
у меня тут отступы неправильно стоят что ли. Теперь мы сделаем void pushback
от const t&value. Вот pushback. И здесь делаем, у нас есть pushback дома. И здесь делаем std forward,
но здесь вообще нам не надо никого forward. Тут мы знаем и так, кого мы передаем. А здесь делаем
pushback от std move от value. То есть здесь мы сделаем pushback от t&value. И сделаем pushback private
от std move от value. Я уже объяснял, прости, пожалуйста, я не буду повторять, потому что иначе нам придется задержаться.
Здесь мы делаем теперь forward. Все нормально в теории. Ну, очевидно, нет, нам еще много
исправить предстоит. Но, по крайней мере, вот с точки зрения move-ов нормально? Вот. Где? А, вот здесь тоже forward, это правда.
Все, мы победили. Мы победили лишнее копирование в pushback, в векторе. И при докладывании вектор самого
вот этого объекта и при реалокации победили лишнее копирование. А, прежде чем вас расстроить, ну,
спойлер, проблема. Тихо, не спойлери. Ну, я только что хотел заспойлерить, да, ну ладно. Подожди,
подожди, подожди, пока забудьте про то, что он сказал. Давайте пока по-другому, о другом подумаем.
Спокойно, не нервничайте, не надо нервничать заранее, еще ничего плохого не случилось.
Тихо, тихо, спокойно, дышите ровно. У меня к вам вопрос. Значит, сейчас небольшое лирическое отступление.
Как вам такая идея? Почему бы мне не написать pushback следующим образом? Я говорю void pushback
от t в value принятого по значению и move там уже внутри. Не делать forward, а делать move вот здесь.
Смотрите, если я в этот pushback передам l value, он скопируется, а потом я его move. Если я в
этот pushback передам r value, он сразу же move-нется и потом я его снова move-ну. То есть я избежал
снова лишних копирований и избежал еще и копипасты. Еще раз, я в pushback буду принимать t по значению
вообще. Потому что таким образом одним махом я решу проблему и для r value и для l value и не буду
нигде лишний раз копировать. И мне всего одной версии pushback достаточно будет. Подождите,
мы не обсуждаем exception пока. Вот с точки зрения чисто move и копирований. Да, ну то есть я избегу
лишних копирований, я буду просто move-ать лишний раз возможно. А до этого я не move-ал. Ну это
аргумент. Я делаю на один move больше, но я все еще избавляюсь от копирований. Нет, функция move-то
ничего не делает, но move-операция перекладывает поля. Я сейчас вам скажу некоторую мысль огорашивающую
человека, к ней неподготовленного. Если вы будете когда-нибудь читать современный код на C++ каких
нибудь крутых топовых разработчиков гугла или яндекса, вы можете обнаружить внезапно, что почему-то
они по значению функции все время передают, они по ссылке. Потому что на самом деле то, что вот я
сейчас предложил, это одна из идиом современного C++, которая позволяет не делать копипасту для r
value ссылок и для l value ссылок. Если у вас все типы корректно поддержат move семантику, то вам просто
выгоднее по значению принимать и не париться с копипастой. Вы можете просто принимать свои
функции по значению и move-ать. Тогда если пользователь хочет вам передать l value, вы его один раз
скопируете во время передачи, но потом move-ните. А если пользователь хочет передать вам r value, вы
просто два раза move-ните. И вам не нужно копипастой делать для разных видов ссылок. Понимаете, как
прикольно? То есть вы можете иногда действительно увидеть, и это тоже кстати такой вопрос на глубокое
понимание, которое тоже задают иногда. Скорее это бывает так. Вы приходите работать и видите,
что в коде все по значению принимается. Вы приходите к теми людьми и говорите, ты что дурак?
Зачем ты по значению принимаешь? Ты же лишний раз копируешь. А потом вам объясняют, что вообще-то это
это вы, дурак. Это современный C++, вы ничего не понимаете. То есть на самом деле в современном
C++ принято принимать по значению. Если все типы корректно поддержат ему в семантику, то вам не
нужно будет делать перегрузку для двух видов ссылок. Теперь следующий вопрос. Но почему же в
Векторе-то мы так не сделали? В Векторе все-таки мы делаем две перегрузки. Одну для C++, другую для T2.
Ну да, потому что там лишний move. В принципе это уже достаточно аргумент. Но мы тоже не можем так
делать, потому что у нас нет гарантии, что T поддерживает move семантику. Это работает только,
если все типы гарантированно поддержат move семантику. Но в Векторе далеко не обязательно
лежит тип, который move семантику поддерживает. Если у вас тип не поддерживает move семантику,
то лишний move для вас, то будет лишнее копирование. Вы не можете себе этого позволить. Понятно? То есть
СТЛ-овский Вектор все равно делает перегрузку для двух видов ссылок. Но если вы пишете код на
современных плюсах, а хотите избежать копипасты, то вот вы можете воспользоваться идиомой и просто
передавать по значению. И не будет копипасты для разных видов ссылок. И не надо париться с
универсальными ссылками. То есть да, мы вот эту вот все вот 0,75 года изучаем, чтобы прийти к
выводу, что вообще-то принимать по значению норм тему можно было так и делать. В принципе так
и так тоже работает. Главное move не забывать писать. А теперь, уважаемые господа, главный вопрос
сегодняшнего вечера. Что мы испортили, сделав это? Конечно же мы потеряли exception safety. Потому
что смотрите, когда мы раньше копировали, ну вот у меня есть резерв. Да, он перекладывает объекты.
Да, я все еще не понял. Вот смотрите, я делаю pushback и начинаю move отсюда-сюда. И вот на третьем
муве произошел exception. Я уже положил сюда два полноценных новых объекта и move их отсюда.
То есть здесь лежат пустые объекты. И третий, третий был конструктор, не было у меня исключений.
Теперь у меня неприятная ситуация, с которой я раньше еще не сталкивался. У меня в этом массиве
половина объектов пустые, а половина еще не переложенные. В этом половина созданных объектов,
половина нациализированной памяти. И я на третьем объекте споткнулся по штуке у исключения.
Я не могу начать перекладывать эти объекты обратно, потому что будет второй exception. Что же делать?
Как мне соблюсти move семантику, соблюсти exception safety при поддержке move семантики при резерве векторе?
Вы принято!
Ну по ощущениям там любят потом любить делать.
Как же нам победить проблему лишних копирований? Мы ведем 3 дополнительных и the value. Вы принято.
Тем не менее нет. На сей раз комитет пошел иным путем.
Мы просто будем вот как себя вести. Если move конструктор кидает исключения, мы не будем move,
мы будем копировать по старому. А как мы это проверим? А мы будем проверять, он no accept или нет?
Для этого у нас есть следующая специальная функция, которая называется move if no accept.
Действие этой функции следующее.
Если move конструктор для данного типа no accept, то она возвращает рвл в ссылку, а иначе лвл в ссылку.
Вы никогда не пробовали играть в КВН?
Нет.
Давайте я вам напишу, что делает функция move if no accept.
Что делает функция move if no accept?
У нее возвращаемый тип какой?
Я хочу вернуть рвл в ссылку, если move конструктор был no accept и лвл в ссылку иначе.
Что я должен написать?
Я должен написать, если нечто, то вернуть одно иначе другое. Какой тип?
STD conditional.
STD conditional T.
Тут проблема, потому что я не знаю, какой условий пока написать. Надо как-то проверить, является ли move конструктор no accept.
Если вы внимательными слушателями были, то у нас было ключевое слово, которое проявляет некоторые выражения no accept.
Ключевое слово no accept.
Как я это могу сделать?
Наивный способ сделать вот так.
Это наивная реализация, она неправильная.
Естественно, не смогу, но accept не вычисляет выражения под собой, он лишь проверяет no accept.
Но accept проверяет, правда ли, что все думают, что есть no accept.
Правильно.
К сожалению, это некорректно, потому что tag может быть no accept, и тогда все вместе будет no accept.
Вот.
Давайте я не буду, короче, я оставлю здесь to do.
Я сейчас не буду рассказывать, как это реализовать. Мы реализуем это попозже.
У нас осталась to do, как реализовать.
Проверка является move конструктор no accept, у изотронов ничего лишнего.
Я могу здесь сказать так, для этого есть специальный tag trade, который называется is no fro move constructible.
Я не буду сейчас.
Нет, нельзя, но это слишком сложно, я сейчас не буду про это рассказывать.
Нам нужно пройти еще кое-что, а потом мы сможем это реализовать.
Is no fro move constructible where?
Это tag trade, который проверяет правда ли move конструктор no accept.
Если это правда, то мы что возвращаем?
Что мы возвращаем?
Что мы возвращаем?
Точно ли?
Да.
Это такое возвращаем ити?
А принимаем ити, у нас будет просто tempersum.
А мы там дольше не должны где-то remove reference?
Нет, не должны, потому что сюда я принимаю не по универсальной ссылке, а по обычной ссылке.
Потому что сюда мне никогда не нужно передавать RBL.
Потому что no accept принимает просто tempersum.
И поэтому мне не нужно remove reference делать, у меня просто будет либо T2, либо const tempersum.
Потому что я хочу либо возвращать RBL в ссылку, либо возвращать const tempersum как обычную ссылку для копирования.
Что я здесь напишу?
Ну то есть я возвращаю то, что мне вернул move,
но оно становится const tempersum, если move конструктор был не no accept.
И T2 tempersum иначе.
А нормально ставить там T2 tempersum, а не remove reference?
Да нормально, я только что объяснил почему.
Сейчас секунду, а у нас мета была no accept?
Да, это безусловно, это правда.
Еще вопрос, ну кроме тех, на которые я уже отвечал.
Ну хорошо, давайте еще раз скажу почему нормально.
Потому что я принимаю не универсальную ссылку, а обычно RBL в ссылку.
Мне поэтому не нужно remove reference.
Вот именно эту функцию я здесь и использую.
И теперь у меня соблюдена move семантика.
Соблюдена exe в сети, извиняюсь.
Так, сейчас я правда кое-что открою.
А, нам это не важно писать.
Давайте я вам следующий вопрос задам.
А если у меня тип вообще не поддерживает копирование?
А только move не поддерживает?
Что тогда делать?
Такие типы бывают уже, напоминаю.
Например, uniquevtr, который мы правда еще не проходили, но пройдем через 15 минут.
Или trap.
Ну в общем бывают типы, которые не умеют копироваться, умеют только move-аться, мы с вами это обсуждаем.
А физи не будет?
Нет, сегодня я у этого пара.
Но видимо надо требовать, чтобы у таких типов обязательно был move-конструктор на exe.
Нет, все проще.
Vector делает следующим образом.
Если у вас, там написано следующее.
Если move-конструктор не на exe, то если есть copy-конструктор, то используем его, а иначе move все равно и забиваем на exe сети.
То есть Vector так делает.
Он пытается move-ить, если там noexcept.
Если нет, он пытается копировать.
Но если нет copy-конструктора вообще, то он забивает на exe и move-ит, и тогда не до этого никакие границы.
Это как за exe сети.
Да, иначе вы тогда бы Vector не смогли копировать.
Тогда не от этого.
Дестрой не новый exe.
Если дестрой не noexcept, то это вообще не свидание.
Тут похоже.
Да.
Вот.
В связи с этим, если мы посмотрим на определение move-ноexe в стандарте, мы увидим, что оно вот такое.
Оно чуть сложнее, чем я написал.
Оно std-conditional, но не просто из nofromove-constructible, а еще проверка, что из copy-constructible.
То есть посмотрите, пожалуйста, при каком условии он возвращается в темп двойной персант и при каком какой-то темп персант.
Если этот тип nofromove-constructible или не copy-constructible, то va вернет std-conditional, а иначе conditional.
Да, это отрицание.
Да, да, да. Ну, я сформулировал отрицание.
Move-noexcept как раз проверяет, правда ли Vector, она специально для этого и существует, она проверяет, правда ли Vector не noexcept move-constructible или copy-constructible.
Если что-то из этого, тогда он будет... Ой, я неправильно сформулировал.
Да, и copy-constructible. Если что-то из этого верно, то он вернет lvl и иначе lvl.
Почему?
А тем, что тут constexpr добавилось.
А мы не будем показывать.
Вот, это вопрос тоже такой, ну, я не знаю, для продвы это может быть вопрос не на отл, но, в общем, это такой вопрос на глубокое понимание того, как Vector работает.
Вот, допустим, вы реализовали строку и забыли написать noexcept move-constructible, вы с удивлением обнаружите, что Vector будет копировать вашу строку при перекладывании, а не move-ить все еще.
Именно поэтому, если вы в вашем типе забудете написать noexcept move-constructible, то при использовании Vector вы обнаружите, что в pushback он копирует ваш тип полностью, а не move-ает, потому что он вот так вот устроен.
Можно закупить copy-constructible.
А если вы забудете, то закупим.
Папа, если мы нарешим noexcept move-constructible?
Так, давайте расскажу последнюю вещь, и мы на перелыв пойдем, красна в пара закончилась.
Последняя вещь такая, вот это просто, я не знаю, это вопрос уже на отл 10, наверное.
Угу.
Ну, для вас это не будет вопрос, потому что я вам его засподню.
Но вообще, для тех, кого я этого никогда не слышал, это, этим может быть, я не знаю.
Значит, сейчас я вам расскажу, как завалить собеседующего на собеседовании, если он попросит вас реализовать pushback.
Найс.
Это полезно, это.
Да, собеседуешься на собеседовании.
Да, да, да.
Просто, как правило, когда собеседующий просит вас реализовать pushback, он ожидает от вас не многого, но не этого.
Вот сейчас, в общем, высший полотаж.
Чего угодно, но нет.
Что можно спросить у собеседующего по поводу реализации pushback?
А как он просит?
А что должен делать pushback?
Смотрите.
Смотрите, смотрите, пожалуйста.
Давайте представим, что у меня есть вектор строк.
Подожди.
Тихо.
Вот у меня есть вектор строк.
Да.
В, вот, допустим, четырех строк, каждый из которых равна овц.
Ну, все понятно.
И я говорю, v.pushback.
Опять.
В.
Третий вопрос.
Что произойдет?
Что произойдет?
Скопировать.
Скопировать.
Что произойдет, если вот буквально выполняет тот код, который мы написали?
А мой move, потому что это...
Что делает pushback?
Он видит, а, место кончилось, надо реалацировать.
String, отличный T.
Поддержит move-семантику, move-конструктор, no accept.
Значит, мы начинаем перекладывать.
Перекладываем, классно.
Берем этот массив, все move-ем.
Значит, сюда вот это все кладем.
Массив...
Здесь лежат пустые объекты теперь.
И теперь, наконец, мы можем положить сюда новую строку.
По ссылочке.
Она нам была передана вот так, по этой ссылочке.
Откуда у нас эта ссылочка?
Сюда.
Что же мы положим?
Пустую строку, да?
Нет, а можно...
Что же делать?
Плакать.
Что делать, если мы вектор?
Пытаемся положить элемент от того же самого вектора.
По ссылке.
А разве мы не положили его куинем?
Нет, мы по ссылке приняли.
Мы его приняли по ссылке.
А ссылку кладем сюда.
А отсюда мы уже move-ем.
Сколько можно?
А можно перед вообще всем это move-ить куда-то в левое место?
А можно создавать левое место?
Значит, ответ такой.
Это...
Сначала история вопроса.
Однажды этим вопросом задался один мой коллега у меня в андексе, когда мы уже там...
Мы уже для работы, в общем.
Просто что-то пришел и спросил, а вот я тут задумался.
А как это работает?
То есть вы поняли, что никто из нас не знает ответа, полезно читать исходники.
Исходники гениальные.
Просто когда вы делаете pushback, вы должны выделить массив
и сначала покутаться на место, я не положил этот объект,
а только потом перекладывать остальные.
Тогда это будет работать корейки.
Именно так и должен быть написан pushback,
иначе вот этот пример будет валить тест.
Правильный pushback реализован так.
Сначала после того, как вы реализовали,
вы кладете этот объект на место M,
а потом только перекладываете остальные,
и если не получилось, то все понятно.
Но сначала вы кладете объект на место,
потом перекладите остальные, а не наоборот,
иначе у вас этот пример сломается.
На этом мы закончили голодесятую.
