Значит, я напомню, что прошлый раз я начал рассказывать
про эллиминацию кванторов, то есть в некоторых моделях
любая формула равносильно бескванторная.
Это сильно сужает выразительные возможности модели, это
важный такой случай, который нужно иметь в виду.
И я доказал несколько лем, я их не буду передоказывать,
но напомню в процессе.
А сегодня я хотел бы рассказать примеры, когда удается
эллиминировать кванторы.
Ну и вот первый пример относительно простой и тем
не менее важный и интересный, он такая модель, рациональное
число, сравнение чисел на равенство по величине,
сложение и две константы 0 и 1.
Ну мы в прошлый раз обсуждали, что автоморфизма у этой
модели нет, поэтому если хотеть доказывать невыразимость
каких-то кванторов в этой модели, нам нужны какие-то
средства.
Ну в прошлый раз я проверил, что предикат х равно целый
и невыразимый в этой модели, это в общем-то не очень сложно.
И мы уже немножко пообсуждали, как там устроены термы
и атомарные формулы, это я сейчас тоже напомню.
А сейчас я хочу вот доказать, что эллиминация квантора
в этой модели возможна.
То есть любая формула может, будет эквивалентная,
некоторая бескванторная.
Более того, эта эллиминация эффективная, по формуле
существует алгоритм, который по формуле строит равносильную
бескванторную.
Ну в частности, если формула замкнутая, то мы получаем
алгоритм, который проверяет истинность формулы в этой
модели.
Почему?
Потому что после того, как мы эллиминируем все кванторы,
у нас замкнутой формулой у нас вообще переменных
не останется, у нас останутся только константы.
То есть будут атомарные формулы вида там одно число
больше другого или равно другому, мы можем вычислить
значение этих атомарных формул и дальше посчитать
обычным образом значение булевой формулы, которая
у нас получается.
Таким образом это дает способ про любую замкнутую формулу
в этой модели первого порядка определить истина она или
ложна.
Алгоритм.
Хорошо, а как же мы это будем делать?
Ну я напомню сразу, что нам нужно, давайте здесь
может быть я напишу, достаточно эллиминировать кванторы.
В таких ситуациях, первая ситуация, чуть более общая,
у нас есть формула вида, существует y и дальше некоторая
кванторная формула.
Это я в прошлый раз доказывал, сейчас я доказывать не
буду, но там доказательства не очень сложные, нужно
пользоваться леммой, а заменю и постепенно эллиминировать
кванторы один за другим, начиная с нижних.
Но можно усилить этот результат.
Достаточно эллиминировать кванторы в формулах, где
а это конъюнция атомарных, атомарных формул и отрицание
атомарных.
Ну я быстро напомню идею этого доказательства, нужно
взять формулу такого вида, вот эта формула бескванторная,
то есть это булева формула, куда вместо переменных
подставили атомарные формулы в нашей сигнатуре.
Ну и теперь что мы делаем, мы преобразуем эту булевую
формулу к dnf.
Мы знаем, что для любой булевой формулы существует
равносильная dnf.
А дальше пользуемся перестановочностью квантора существования
и дизюнции.
Я сейчас выпишу соответствующую общезначимую формулу, она
нам буквально через 2 минуты понадобится, поэтому лучше
ее иметь в виду.
Это общезначимая формула, она вообще для любых формул
верна, но в частности, если a и b бескванторная, то
же верна.
Таким образом, когда мы говорим о том, что в модели
можно иллюминировать кванторы, достаточно учиться решать
задачу вот только для таких формул.
Давайте посмотрим, что это за формулы, ну теперь уже
применительно к нашей модели.
Я напомню, что атомарные формулы в нашей модели имеют
вид, ну я прям переписываю те предикаты, которые есть
пока что.
Что такое отрицание атомарной формулы?
Это отрицание строгого неравенства, это понятное
дело, не строгое неравенство, а отрицание равенства,
ну тут надо написать отрицание, значит не отрицание, а дизюнкцию.
Значит t1 строго меньше t2 или t2 строго меньше t1.
То есть, если я беру конъюнцию вот таких вот формул, обратите
внимание, сейчас я возьму тряпочку, тут лишнее отрицание
появилось.
У нас, когда мы записываем конъюнцию атомарных формул
и их отрицаний, у нас появляются, во-первых, не строгие неравенства,
но не строгое неравенство, вы понимаете, оно может
быть записано как опять-таки дизюнция строгого неравенства
и равенства.
Ну и равенство можно выразить через не строгое неравенство,
вот строгое неравенство и не строгое, их эквивалентным
образом не преобразуешь в случае рациональных
чисел, тут возникает некоторая сложность, но мы ее сейчас
преодолеем, это не очень большая сложность.
Давайте вспомним, как устроены термы.
Ну, у нас есть функциональный символ плюс, то есть, что
мы можем делать, как мы можем строить терм, можем
брать константы, можем брать переменные и складывать
их.
В результате получится линейная функция, то есть
любой терм, это по сути дела линейная функция.
С целыми и не отрицательными коэффициентами.
Ну, целые и не отрицательные, потому что мы одну переменную
можем несколько раз использовать, значит, если она войдет
два раза, появится коэффициент два при этой переменной.
Ну и константа тоже самая.
То есть, по сути дела, теперь смотрите, как избавиться
от этих дизъюнций, если мы хотим от них избавиться.
Ну, очень просто.
Давайте подставим в конъюнцию вот эти вот равносильные
выражения вместо отрицания равенства и раскроем скобки.
У нас получится конъюнция членов, где иногда бывают
дизъюнции.
Ну, мы пользуясь дистрибутивностью конъюнции, дизъюнцией раскроем
члены.
И представим это в виде дизъюнции, уже конъюнции,
вот таких вот неравенств.
Значит, то есть у нас в конечном счете вот эта вот формула,
давайте я ее как-нибудь в звездочку поставлю, чтоб
не переписывать, и где-нибудь вот здесь помечу, что звездочка
равносильна конъюнции неравенств.
Вот каждому терму отвечает своя линейная функция.
Ну, давайте я пока ограничусь нестрогими и нестрогими
неравенствами, я немножко переусложняю.
У нас, видно, вот эта вторая эквивалентность позволяет
нам оставить строгое неравенство и равенство, но рассуждение
технически, оно будет не сильно проще, поэтому давайте
более общий случай рассмотрим, он более показателен, в более
сложных примерах он удобнее.
То есть фактически мы получаем такой вопрос, у нас есть
система неравенств на переменные, переменные принимают
рациональные значения, коэффициенты уже произвольные
целые.
Почему?
Потому что у нас же, смотрите, у нас вот есть вот такие
термы, значит здесь целый не отрицательный коэффициент,
здесь, но когда мы запишем это в виде неравенства вот
такого с нулевой правой частью, коэффициент уже
может приобрести любой знак, потому что если мы
переносим из левой части в правую, знак меняется
где-то больше, где-то меньше, значит может получиться
отрицательный коэффициент, то есть коэффициенты здесь
произвольные целые числа.
Но это все, они в любом случае целые числа, у нас есть
конечное число таких неравенств, и что нам нужно, посмотрите
на формулу, существует такой у, что выполняются
все эти неравенства, то есть на х надо смотреть как
на параметры, у нас есть система линейных неравенств
от одной переменной, но с параметрами, и мы хотим
записать условия разрешимости этой системы в терминах
параметров, то есть хотим избавиться от у, вот что
нам нужно сделать, и записать это без кванторов, ну сейчас
станет ясно, что это не так уж сложно, хотя есть технические
проблемы.
Ну давайте, как это мы сделаем, во-первых, у нас могут быть
неравенства, куда у вообще не входит, давайте смотреть
на формулу, вот тут конъюнция, чего-то там, в том числе
неравенства, куда у не входит, но мы тогда знаем, у нас была
такая лемма, что если у нас есть, я где-нибудь здесь
запишу, квантор существования по конъюнции, вообще говоря,
это неравносильно, в общем случае так неверно, но если
а не имеет параметра х, то есть если нет свободного
вхождения х, то это уже верно, мы это специально доказывали,
это для преобразования к предваренной нормальной
форме было нужно, но это вот некоторый вообще факт,
поэтому все такие неравенства мы просто сразу вынесем,
там уже у нет, и хорошо, у нас будет конъюнция на
все остальные условия, никакого квантора тут не нужно, значит
останутся только неравенства, куда входит у, следующая
техническая проблема может сходить с коэффициентом
каким-то целым, если он входит, тут мы делаем такой трюк,
входит каким-то целым коэффициентом, давайте поделим неравенство
на модуль этого коэффициента, не, даже на сам коэффициент
давайте поделим, мы знаем, что если мы делим на положительное
число, то неравенство сохраняется, если делим на отрицательное
число, то неравенство меняется, то есть в конечном счете
мы, да, и потом у нас уже коэффициент при у становится
единицы, и мы сделаем еще такую вещь, мы у перенесем
в левую часть, а в правой части будем писать что придется, что у нас там получается. То есть у нас
будет система такая вот у меньше каких-то линейных уже функций от x, у меньше либо равен каких-то
других линейных функций от x. Ну вот я индексы пишу разные, чтобы было понятно, что это вообще
говоря разные неравенства. Ну там какой-нибудь ck, t от x, k тоже пробегает. Сколько-то таких
неравенств может быть. Ну и сколько-то нистрогих неравенств снизу. Ну пусть будет l. Вот нам нужно
про такую систему записать условия разрешимости. Ну, идейна понятная, это метод интервалов,
которые в школе изучаются. Вот у нас есть интервалы и нам нужно написать условия, что у них есть
пересечение. То есть нам нужно указать какую-то точку. Вот я отметил какие-то случайные точки. И
нужно указать вот какую-то, что существует такая точка, что все неравенства вот из второй группы,
они вот с этой стороны, причем неравенство из четвертой группы, могут прямо в эту точку попадать.
А все неравенства из этой группы справа, но опять-таки из второй группы могут попадать прямо в эту точку.
Вот нам нужно такое условие записать. То есть более-менее ясно, что все определяется упорядочением
вот этих вот правых частей. Оно при разных значениях x может быть разным, но из этой
трудности мы можем какой выход найти. Мы можем сказать, что существует подходящее упорядочение,
в котором есть нужный нам интервал. Сколько подходящих упорядочений? Допустим, всего
ну там, не знаю, n большое неравенство. Ну и соответственно правых частей. Давайте теперь
вот эти вот c и t от x, я для краткости буду обозначать там какие-нибудь, не знаю, r альфа.
То есть чтобы не, поскольку у меня четыре группы неравенства, я хочу им дать однородные имена. И
теперь я хочу сделать следующее. Я, во-первых, хочу выбрать какую-то перестановку этих правых частей.
То есть p это перестановка. А дальше я хочу указать это, я считаю, что я их выстроил в
порядке возрастания. И мне теперь надо еще указать знаки. Нужна расстановка знаков.
Тут что-то, тут где-то может быть равно. Вот какие-то такие знаки.
Сколько всего расстановок знаков? Ну у нас есть n-1 место, и на каждом можем поставить,
по сути дела, два знака. Раз я предполагаю, что я упорядочу в порядке возрастания,
там может стоять знак строгого неравенства или просто равенства. Значит у нас получается всего
n! это количество перестановок умножить на 2 в степени n-1 вариантов. Ну число большое,
но конечное. Мы же доказываем, что формула существует, и что мы ее можем выписать алгоритмом.
Нас не интересует, что этот алгоритм может работать очень долго. Я рассказываю не самую
экономную версию иллюминации квантера в этой модели. Вот здесь как раз можно очень сильно
сэкономить, но нас сейчас экономия ресурса не интересует. Алгоритм может работать сколько угодно
долго, лишь бы он остановился в какой-то момент и выдал нам ответ. Давайте теперь про каждый знак
поймем, что происходит. Просто для каждого варианта упорядочения правых частей запишем свое условие,
свое условие разрешимости. Вот у нас есть эти правые части, которые сейчас обозначаю,
рытые для экономии. Некоторые могут совпадать в зависимости от рассталовки знаков. То есть я
считаю, что я сейчас зафиксировал упорядочение правых частей и знаки между ними. А теперь,
что я хочу сказать. Смотрите, у меня появляется вот n таких знаков, они дают n плюс один интервал.
Ну от минус бесконечности до r1. Даже давайте 2n плюс 1, вот так вот удобнее. Это несколько
расточительно и вам может показаться, что это не нужно и действительно здесь это не нужно. Но в
более общей ситуации это может оказаться важным. Я хочу сейчас нарисовать некоторую схему,
которая без особых, с модификациями, но сработает в более сложной ситуации. То есть я во-первых
выберу вот такие одноточечные интервалы, отвечающие точкам r1, r2 и интервалы между ними. То есть вот этот,
потом r1, r2, ну и так далее. То есть у меня получится много таких интервалов. Много,
но конечное число 2n плюс 1. И смотрите, давайте возьмем какой-нибудь интервал. Что мы можем сказать?
Во-первых, некоторые интервалы могут оказаться пустыми. Например, если r1 равняется r2, то интервал
открытый числа, который строго больше r1 и строго меньше r2, он пуст. И ясно, что когда у нас уже
записана вот эта вот расстановка знаков, мы эти пустые интервалы сразу можем найти, сразу их
выбросить. Поэтому я буду говорить о непустых интервалах. Вот у меня есть непустой интервал,
он может из одной точки состоять, неважно. Но если я беру в нем какое-то значение у, то вот эти
вот неравенства, истинные или ложные, одновременно для всех у из этого интервала. Потому что, смотрите,
все правые части, они либо левее всех этих у, либо правее. Значит, знак неравенства не меняется.
Поэтому про каждый интервал я могу сказать, является ли он решением вот такой системы. И условия
разрешимости системы – это дизъюнция. Существует такой интервал из этих 2n плюс 1. То есть это не
кванторсуществование, а прям дизъюнция. Берем первый интервал. Записываем условия, что вот как у
нас расставлены правые части, все они больше, чем наша точка. Ну, такое иногда бывает, иногда не
бывает. Но вот такое условие мы записываем. По-моему, следующее. Вот скажем, здесь между r1 и r1 плюс 1,
что мы должны написать? Мы вот все вот эти вот должны посмотреть, что вот сюда попадают все неравенства,
где y больше либо равен. Вот так вот. А сюда те, которые меньше либо равен. И со знаком равенства у
нас особое отношение. Равенство может выполняться только вот в одноточных интервалах. Почему я их
выделил? Что если я нахожусь внутри открытого интервала, там все неравенства строгие. Ну,
а если я нахожусь на одноточном интервале, то для каких-то правых частей будет выполняться
равенство. Надо посмотреть, где это нас устраивает. Таким образом, мы получаем условия. Дизъюнция по
порядкам, по расстановкам знаков, по интервалам. Такого предиката, я его напишу сейчас неформально,
интервал удовлетворяет системе. А вот это вот условие, давайте теперь смотреть, из чего оно
состоит. Что значит, что интервал удовлетворяет системе? Ну, это означает, что должны выполняться
неравенства между правыми частями. Что какой-нибудь там c1 меньше, чем c5. C2 больше, наоборот, чем c1. Ну,
опять-таки вот, то есть у нас есть для каждого интервала те правые части, которые меньше,
которые больше, ну и которые равны в общем случае. И мы должны записать условия, чтобы выполнялось
неравенство. Понятно, что нужно. Нужно, чтобы те, которые меньше этого интервала, они попадали бы вот
сюда. Те, которые больше, попадали бы сюда или с точностью до равенства. И вот примерно так.
Может быть, для простоты нестрогое неравенство нужно было убрать, тогда было бы проще. Тогда
появились бы равенства, все равно это требовало проверки отдельной. Большого выигрыша нет. Но вот
здесь, смотрите, дизъюнция, вообще говоря, очень большая, но все равно получается n факториал умножить
на 2 в степени n-1 умножить на 2n плюс 1 членов в этой дизъюнции. А каждая дизъюнция это неравенство.
Сколько этих неравенств? Вот если у нас всего n, что у нас фактически есть? Мы разбили наши n правых
частей. Ну вот, в самом общем случае, мы разбили их на три группы. Равно, меньше, больше. В самом
общем случае. И мы должны записать соответствующие неравенства. То есть, написать n-1, да, и в сумме это
должно давать n большое. Мы должны записать вот столько строй их неравенств вот здесь. Столько
строгих неравенств, наоборот, вот это вот сюда. Ну и для нестрогих неравенств нам нужны еще вот
неравенства, то есть, что те, которые нестрогие, у нас еще попадают вот сюда, там, ну что-то порядка,
там, n квадрат. На самом деле нужны пары, конечно, ну пусть будет n квадрат. 2 неравенств, которые
нестрогие. Ну видно, что если это в сумме n, каждый из этих слагаемых точно не больше там, чем 2 n
квадрат. Ну и значит, у нас опять-таки длина вот этого система неравенств, которую мы записываем
в конъюнцию, она будет конечной. Нас волнует конечность сейчас. Мы за эффективностью не следим. Тут
можно выиграть очень много, потому что неравенства не сравниваются по транзитивности, мы можем много
чего не писать в эти дизюнкции и конъюнции, но давайте сейчас про это не думать, просто вот таким
самым простейшим способом будем действовать. Ну а что означает конкретное неравенство, ну вот скажем
вот такое. Заметьте, что тут у нас уже коэффициенты рациональные. Я напомню, что когда мы приводили к
этим неравенствам, мы еще делили. Ну понятно, что если мы умножим на НК знаменателей, это положительное
число, мы получим соответствующее неравенство с целыми коэффициентами. Ну а теперь надо
в обратную сторону перейти к атомарным формулам. У нас есть неравенство с целыми коэффициентами,
значит если коэффициент вдруг отрицательный, мы эту переменную переносим в правую часть, если
положительные оставляем, ну вот так вот перебросим, чтобы неравенство превратилось в сравнение двух
линейных функций с неотрицательными целыми коэффициентами. А это мы видели, вот там вот у нас
прям мы специально написали, что это в точности то, что нам предоставляет наша модель. Мы можем
записать конъюнцию таких атомарных формул, то есть каждое такое неравенство это атомарная
формула, ну или ее отрицание. Если меньше либо равно, то это надо, значит, ставить отрицание к
строгому неравенству. Ну если равно, у нас такое есть. Если отрицание равенства, ну мы должны
записать это в виде дизюнции. В любом случае у нас получается булева формула. У нас получается
булева формула без всяких кванторов. Заметьте, что это формула очень простого вида. Дизюнция,
дизюнция, дизюнция, потом конъюнции, ну может быть некоторые члены конъюнции сами по себе
дизюнции, когда нам нужно выразить в нашей модели нестрогое неравенство. Я мог бы добавить нестрогое
неравенство в модель, но это принципиально бы ничего не изменило. Рассуждение от этого сильно
проще бы не стало. Ну вот. И что? И получилась бескванторная формула, которая равносильна
исходной, потому что это и есть условия разрешимости нашей системы неравенства линейного. То есть мы
избавились от квантора существования. Ну и полемя, которое я в прошлый раз доказал, означает, что мы
можем избавиться от квантора существования для любой формулы в этой модели. То есть вот такое
доказательство. Видно, что в сущности во многом оно держится на том, что наши предикаты устроены
достаточно просто. Они задают линейный порядок, ну там с точностью строге неравенство или нестроге,
и мы это используем для эллиминации. То есть вот то, что написано вот здесь, вот эти попарные
сравнения. Это и есть метод удаления переменной при решении уравнений. При решении неравенства
то же самое есть. Мы можем удалять, если допустим все неравенства нестрогие, так проще понять. Мы
можем удалять переменную, если мы запишем верхние оценки на эту переменную, нижние оценки. Полученная
система неравенства в смысле разрешимости. Разрешимость эквивалентна разрешимости системы
неравенства на правые части. Все нижние оценки должны быть не больше всех верхних. Если неравенства
нестрогие, этого в точности достаточно. Если неравенства строгие, там начинаются нюансы. Нужно вот
учесть, что если у нас интервал сжался в точку, то строгого неравенства там не добьешься. Поэтому
я написал вот такую более сложную конструкцию. Я сейчас объясню, почему я так сделал.
Для этой модели мы справились. Модель правда очень игрушечная. Давайте посмотрим на уже не
игрушечную модель, а такую, которая действительно интересна многим, а именно на алгебрутарского.
Я напомню, что алгебрутарского это такая модель. Это действительные числа. Это действительные
числа. Те же самые сравнения. Но теперь, что существенно, у нас есть еще и умножение. И
константы пусть будут 0 и 1. То есть основная разница состоит в том, что у нас действительные
числа нам нужны, чтобы, например, существовали квадратные корни. Но добавлена операция умножения.
Вот это очень существенно. И на самом деле, как мы позже поймем, если заменить здесь, ну прорациональные
числа я говорить не буду, это тоже правда. Но если заменить здесь, скажем, на целые, на натуральные
числа я буду менять. Это то, что называется модель вифметика. С ней все гораздо хуже, чем с алгебритарского.
А вот в этой вот алгебре иллюминация кванторов возможна. Это называется теорема Зайденберга
Ротарского. Возможность иллюминации кванторов в этой алгебре. И доказательство более-менее следует
вот этим вот пути. Единственная разница теперь какая. У нас вот тут были линейные функции,
а теперь у нас есть умножение. Поэтому у нас теперь будут многочлены. И в многочленах уже не
так просто делить, потому что мы тогда перейдем к рациональным функциям. Поэтому на самом деле у
нас получится вот что. У нас получится, когда мы будем преобразовывать вот так атомарные формулы,
у нас получится система полинамиальных уравнений. Я для краткости всю ее не выписываю. Тут такие же
наборы переменных. Просто неравенства могут быть строгими, могут быть нестрогими. Ну если бы тут
были строгие равенства всюду, множество решений полинаминой системы уравнений. Да, а коэффициенты
целые тоже. Ну по той же самой причине, что и раньше. Если бы у нас были только равенства,
такие бы множества назывались алгебраическими множествами ВРН. Ну N это общее количество
переменных. А если неравенства, они называются полуалгебраическими множествами. И в сущности,
вот с точностью до той леммы, про которую я говорил, что можно иллюминировать только квантор
существования, навешанный на формулы, которые являются конъюнциями атомарных и их отрицаний,
мы получаем, что нам теорема Зайденберг-Атарского в сущности утверждает следующее, что если я возьму
проекцию полуалгебраического множ六, то проекцию, это как раз взятие квантора существования. То есть
вот у меня написано полуалгебраическое множество. Теперь я хочу взять его проекцию. То есть
написать условия, что есть такой у, который вот попадает под эту точку. Так вот что
оно тоже полуалгебр Again гибр itч. То мы можем это записать в виде неравенств. Т и probability
что모, как раньше нам нужно решать параметрическую систему неравенств и уравнений.の что
уравнения можно задать двумя неравенствами, от одной
переменной.
Но только теперь неравенство, соответственно, нелинейная
функция, она многочленная, и это, понятное дело, сложнее.
Но тем не менее, вы знаете, вас в школе учили в некоторых
случаях, как с этим справляться.
Вот я сейчас напишу пример, который вам должен быть
известен.
Вот у нас есть уравнение параметрическое с параметрами
p и q, x квадрат плюс px плюс q равно нулю.
Как написать условия разрешимости этого уравнения?
Теорема Зейденберг-Гатарского говорит нам, что можно написать
алгебрайческие условия с неравенствами на коэффициенты
p и q.
Ну и да, вы знаете, как эти неравенства записать.
Нужно, чтобы p квадрат минус 4q было не отрицательным.
То есть вся теорема Зейденберг-Гатарского обобщает решение квадратных
уравнений.
Ну те, кто знают про метод штурма, по-моему, не знают,
но в стихе, к сожалению, никто его не учит, никто
ему не учит.
Поднимите руки, кто знает, как устроен метод штурма
определения количества корней многочленов на отрезке.
То есть у взадного многочленов действительно имеют коэффициент.
У взадного отрезок нужно сказать, сколько корней
на этом отрезке.
Ну вот не знаете, да, и я вас этому не учу в алгебре.
Это можно было бы делать в курсе алгебры, если бы
он был чуть длиннее, а так не помещается.
Потому что там метод штурма очень близок к алгоритму
Ивклида.
Там на самом деле нужно немножко модифицировать алгоритм
Ивклида, начитать последовательность многочленов, посмотреть,
как меняются их знаки на концах интервала и по количеству
изменений знаков сказать, сколько корней.
Но это вот некоторая такая хитрая вещь.
И это тоже частный случай, потому что понятно, примерно
про то же самое.
Когда мы хотим сказать, что у нас количество корней
бескрадностей.
Когда мы хотим сказать, что на отрезке есть ровно
три корня, это означает, что существует x1, x2, x3, такие
что они все разные, там x1 меньше, x2 меньше, x3, и каждый
является корнем.
Ну и еще, что они попадают на отрезок еще не равенство.
То есть, ясно, что это можно записать в виде условия
алгебритарского.
Ну а в общем случае нужно что-то сделать, и это что-то
очень напоминает то, что я делал.
Потому что, смотрите, каждый многочлен, что мы знаем про
многочлен в степени n, что у него не больше, чем n корней.
То есть нам нужно опять-таки представить себе такую
мысль напрямую, действительно, на ней отметить возможные
корни и расставить знаки, потому что с многочленами
что-то, вы знаете, бывает такая история, что корень
у него есть, а знаки тем не менее по обеим частям
от корня одинаковые.
То есть нам нужно расставить знаки, и вот нужно найти
все возможные способы, все области на нашей переменной,
какие знаки можно получать.
Это прямая y, и конечно эти области зависит от x, но
зависит они будут алгебраическим образом.
Вот тут начинаются технические сложности, и я не буду рассказывать
технические доказательства тюремы Зейденберг-Атарского.
Идея примерно та же, что и была, только в случае
линейных функций мы сразу могли писать сравнения
между линейными функциями.
А здесь немножко сложнее, нам не хватит тех функций,
которые у нас есть изначально.
Мы должны это множество расширить.
Мы должны брать для этих функций производные.
Зачем нужны производные, можно, например, понять вот
здесь.
Как определить, что корень именно такой, но это значит,
что у него вторая производная положительная.
Нам нужно брать многочлены с остатком.
Делить многочлены с остатком.
Ну это техническое требование, но нужно, тут возникает
еще одна сложность.
Я Вас учил, что нельзя делить многочлены с целымию коэффициентами
с остатком, но будем делить модифицированным образом,
потому что деление многочленов с целыми коэффициентами
остаткам возможно, если у нас каждый коэффициент делимого делится на достаточно большую степень
старшего коэффициента делителя. Потому что где возникает дробь, когда мы смотрим,
вот мы делим, и у нас возникает необходимость поделить на старший коэффициент делителя.
Но если, эту трудность как можно преодолеть? Ну давайте, нам будут нужны только знаки этих
многочленов. Поэтому давайте умножим на большое положительное число, на старший коэффициент
делителя в очень большой степени. Ну столько сколько у нас может быть шагов при делении столбиком.
И тогда деление с остатком станет возможным. То есть такое модифицированное деление с остатком.
Плюс нужно уметь из многочлена выделять старший член и остаток. То есть нужно уметь делить на
части. Старший член и остаток. Это тоже понятно почему. Потому что вообще на х в кубе, скажем,
плюс один и минус х в кубе плюс один, ведут себя по-разному, когда х стремится к бесконечности.
Один стремится к плюс бесконечности, другой к минус бесконечности. Ясно, что нам нужно это знать,
потому что у нас будут интервалы, и нам знак на конце интервала при больших положительных х,
при больших отрицательных х нужен. Поэтому нам это нужно брать, и нужно брать остаток,
чтобы продолжать манипуляции. То есть это много таких операций, их нужно все выполнять. Причем,
чтобы можно было считать знаки всех многочленов, которые получаются, мы должны эти операции
интерировать. То есть мы взяли исходные многочлены, поделили их с остатком как только можно,
разделили на старшие члены на все, что осталось, взяли производные, получили новое множество
многочленов, мы должны к нему опять применить это дело. Процесс конечный, потому что степень
многочленопределений с остатком уменьшаются, при взятии производной тоже уменьшаются. Ну и когда
мы выделяем старший член, ну тоже вот мы выделили старший член, то что осталось имеет меньшую степень,
а из старшего члена уже старший член заново не выделишь. Это он и будет. Поэтому этот процесс
конечный, он очень большой, он гораздо больше. Тут я написал с очень большим запасом, это
эллиминацию квантора в модели рациональных чисел со сложением можно выполнить более эффективно,
а в случае алгебритарского вот не видно способа как избежать вот того, что мы должны выписать кучу-
кучу многочленов, написать на них вот условия, что там один больше нуля, другой там меньше нуля,
тогда мы можем для исходных многочленов определить знаки и проверить выполняется ли для вот такой
расстановки знаков для всех многочленов выполняется ли наша система не равна. Ну и опять-таки вот
написать вот такую вот вещь. Там будут всюду конечные дизюнкты. Так, сейчас нужно сделать перерыв,
я буквально вот два слова закончу. Конечные, но их будет очень много. Давайте я еще все-таки
один комментарий про алгебритарского сделаю после перерыва, а сейчас перерыв. Потому что они
уже сейчас особо нужны не будут. Я хотел еще одну вещь сказать про алгебритарского. Напомню,
что задачи элементарной геометрии выражаются как утверждение в алгебритарского. И алгоритм
лиминации кванторов дает алгоритм решения любой задачи элементарной геометрии. Берете там
задачи из EG и запускаете этот алгоритм. Но есть проблема. Вы видели, ну я так попытался в очень
общих чертах описать как устроен алгоритм. Истребление одного квантора стоит нам дорого. Мы
добавляем очень большое количество условий. Потому что у нас возникает большое количество
многочленов, мы должны на них написать неравенство. И это мы истребили только один квантор. А если их
несколько, это нужно повторить несколько раз. И получается совсем плохая оценка,
которая была у Тарского. Она вообще там башня степеней двоек. Это очень плохо. Можно улучшить
до 2 в степени 2 в степени n, где n размер формулы. Это сравнительно несложно. Но дальше уже не очень
то улучшишь. А нет, извините, по-моему башня из трех степеней двоек это вот иллюминация одного
квантора два в степени два в степени. На самом деле потом Коллинс улучшил иллюминацию одного
квантора до просто однократной экспоненты. И это уже довольно сложная вещь. Это я не буду вам
объяснять. Я и сам подробности не все знаю. Но что существенно? Существенно, что доказано,
это утверждение доказано, что никакой алгоритм не может разрешать алгебру Тарского быстро.
Любой алгоритм, который по формуле Валгебритарского определяет истинно или ложно, по замкнутой формуле,
он работает за время, которое экспоненциально велико по сравнению с размером формулы. Очень
много утверждений в теории сложности носит условный характер, что если там что-то выполняется,
то тогда нет хорошего алгоритма. Вот то, что я сказал, это безусловное утверждение. Это просто так,
вот такого алгоритма нет, это доказано. Уже 50 лет как доказано. Поэтому надежда решать все задачи
геометрии с помощью алгоритмов, разрешающих алгебру Тарского, она иллюзорна. Даже алгоритм
Коллинза, который существенно быстрее. Экспериментировали люди на компьютерах,
где он работает, но он ломается на очень простых формулах. То есть я не думаю, что какую-нибудь
сколь-нибудь интересную теорему из элементарной геометрии он сможет доказать. Может быть какие-нибудь
самые простые сможет, но вряд ли очень много. Я не знаю, что медианы пересекаются в одной точке,
он почти заведомо сможет доказать. Что-нибудь менее очевидное. Люди от геометрии знают,
что задач по геометрии очень много, их каждый год придумывают десятки, если не сотни. И
люди каждый раз придумают какой-то свой способ решения. Это связано с тем, что хорошего алгоритма,
который работает одинаково для всех задач элементарной геометрии, просто нет. Это то,
что я хотел сказать про алгебру Тарского. Дальнейших подробностей, к сожалению, уже сказать не смогу.
Я хочу еще один пример привести, важный. Это называется арифметика Презбургера. Я уже,
по-моему, про нее говорил в прошлый раз. Сейчас я модель немножко по-другому сформулирую. Это вот
почти что такая модель, только мы заменяем рациональные числа на целые и добавляем
предикаты сравнимости по модулю N. Я напомню, что если оставить вот такую сигнатуру и заменить на
целые числа, там кванторы нельзя иллюминировать, потому что есть формула, которая выражает предикат
х-четное число. Существует такой у, что х равнится у плюс у. А если добавить предикат сравнимости по
модулю N, то такая уже теория допускает, вот такая модель, извините, допускает иллюминацию кванторов.
И в сущности там все очень похоже на то, что я рассказывал. В чем возникает дополнительная
сложность? Когда мы преобразовали систему линейных нераз, нам нужно было в некоторый момент делить,
но в целых числах делить уже нельзя. И выход такой, мы должны брать остатки по модулю, вот у нас есть
какой-то коэффициент, на который мы хотим поделить, ну точнее, наименьший общекратный этих коэффициентов.
Мы должны разбить все целые числа на арифметические прогрессии в зависимости от остатка по этому модулю.
Арифметическая прогрессия, по сути дела, тоже такое линейное множество, а плюс bt, где t это какой-то
целочистный параметр, и вот на этот целочистный параметр мы уже можем писать неравенство. То есть
получается так, что нам нужно еще условия, какой именно остаток там по какому-то конкретному
константному модулю возникает. Это приводит к увеличению формулы, и здесь опять-таки можно доказать,
что арифметика Презбургера, хотя разрешима, но разрешается плохо, все алгоритмы работают
Это некоторые важные факты для логики, что вот модели вроде бы разрешимы, есть алгоритмы их
разрешающие, но все они работают долго, на этом основаны разные другие результаты такого типа,
но это я рассказывать не буду, и в параллельном курсе теория алгоритма этого вам тоже не расскажут,
на самом деле это естественная тема для следующего семестра, когда вам будут рассказывать про
сложность с ограничениями на ресурсы, ну там на время, вычисления или на память, но насколько
я знаю, и там про это не рассказывают, это все-таки основную технику рассказывают уже несколько лет,
как в этих курсах, то что называется диагонализация, но технические подробности как формулами Валги
Бритарского задать произвольные вычисления достаточно длинные, они все-таки, ну там просто
много технических подробностей, это надо все аккуратно записать, на это не остается время, то есть
идея в общем такая, что формулой Валги Бритарского вы можете написать утверждение, что данные там,
машины Тюринга у вас уже появились, нет? Нет, ну появятся, в общем данная программа работает там
за данное время T и дает такой-то ответ, вот по длине записи этой программы в разумной модели
вычисления можно написать формулу Валги Бритарского, которая не сильно длиннее,
которая равносильна этому утверждению, то есть идея примерно такая, что вообще результат любого
вычисления, причем долгого вычисления, вы можете представить в виде формулы Валги Бритарского,
это совершенно неочевидный факт, потому что, ну как это сделать, как хотя бы закодировать очень
большое число, но оказывается есть трюк, я тоже сейчас про это уже рассказывать не буду, можете
где-нибудь попробовать посмотреть, как это делается, а я хочу перейти к следующей теме, она тоже отчасти
связана с выразимостью, но немножко другая, значит это то, что называется элементарная эквивалентность
теории, только не теория модели, значит давайте я как-нибудь обозначу, вот тут уже надо говорить
слово теория, что такое элементарные теории модели, я напомни, что теории я называю множество
замкнутых формул, произвольные, а что такое элементарная теория модели, это формулы первого
порядка замкнутые, которые в этой модели истинны, то есть в каком-то смысле, это все утверждения о
модели, которые истинные утверждения о модели, которые можно записать формализме первого порядка,
ну в каком смысле нас это элементарная теория интересует, мы хотим конечно различать, какие
утверждения истины, какие ложны в данной модели. И вот примерно это нам и нужно.
Теперь вот мы говорим, что модель М1, я даже не знаю, как записать эту эквивалентность.
Я потом придумаю какое-нибудь лучшее обозначение. Элементарный эквивалент на
две модели, если их элементарные теории просто равны. Любая формула у модели,
естественно, должны быть в одинаковой сигнатуре, иначе вообще непонятно,
почему бы формулы были равны. Берем формулу, интерпретируем ее в модели М1,
интерпретируем ее в модели М2. И обязательно, если формула истина в одной модели,
она обязательно истина в другой модели. Если она ложна в одной модели,
она обязательно ложна в другой модели. То есть множество истинных формул просто совпадают.
Ну это по определению. Это определение такое. То есть мы говорим, что модели элементарно
эквивалентны. Примеры элементарно эквивалентных моделей очень легко построить. Представьте,
что модели изоморфные, существует изоморфизм. Вот так, как мы в прошлый раз писали автоморфизм,
мы можем также определить изоморфизм. И ясно, что изоморфизм, это практически пересказ доказательства,
который был в прошлый раз, он сохраняет значение замкнутых формул. Ну и поэтому, конечно, они
элементарно эквивалентны. Но элементарная эквивалентность гораздо слабее изоморфизма. У
нас есть много примеров элементарно эквивалентных теорий, которые не изоморфны. И в сущности у нас
такие примеры появятся. У них может быть даже разная мощность. Ну вот, например, ой, про эту
модель я уверен, что она элементарно эквивалентна. Я, пожалуй, не возьмусь вам это доказывать. То есть
я могу, конечно, посмотреть, как это умные люди делают, но, по-моему, там без очень сильной возни
не обойтись. То есть не то, чтобы она совершенно невозможна, но я не вижу простого способа все это
сказать. То есть более-менее очевидно, что если я там вместо Q поставлю R, то будет то же самое. Ну
когда у вас есть неравенство и уравнение с целыми коэффициентами, то какая вам разница
действительно или рациональные числа? То есть это некоторый такой факт, который легко доказать,
что если у вас есть решение, то обязательно такой система неравенства есть и решение с рациональными
коэффициентами, но нам нужно чуть больше, нам нужно, чтобы любые формулы были равны. И там есть свои
сложности. Я сейчас не хочу особо в это вдаваться. Ну, для более простых моделей существенно что,
что Q и R отличаются даже по мощности. Они не то что не изоморфные, там носители имеют разную
мощность. У нас нет шансов построить объект между носителями этих моделей. И вот такие примеры у
нас будут, но более простые. От чего? Элементарная теория по определению. У вас есть модель и мы
рассматриваем все формулы первого порядка, замкнутые, которые в этой модели истины. Это
просто по определению. Давайте я как-нибудь это напишу. А то я написал элементарную эквивалентность,
а само это не написал. Значит, phi истинно в этой модели. Ну и phi замкнуто. Мы для простоты
будем ограничимся замкнутыми формулами, не замкнуя предикаты какие-то, задают это сложнее.
Ну, большой разницы нет. На самом деле для невыразимости нам потом нужно переходить к предикатам.
Я надеюсь, что у меня будет время обсудить хотя бы простейший пример доказательства
невыразимости. Опять-таки возникают технические сложности. Идея это, в общем-то, понятна.
Ну вот, и возникает вопрос, как проверить, вот данные две модели, как проверить элементарно
не эквивалентно или нет. Оказывается, есть очень красивый и удобный в применении критерий
элементарной эквивалентности. Но он не очевидный. Он потребует некоторых новых конструкций. И
сегодня я разве что успею ввести основной инструмент, с помощью которого эти критерии
формулируются. Это то, что называется игрой Ренфойхта. Ну, игра происходит на паре моделей.
Значит, про модели сигнатура. У нас будет ограничение на сигнатуру. Сигнатура – только
предикатные символы. Ну, вы скажете, как же так без функций, без констант. Я вас убеждал,
что они нужны. Они нам понадобятся в других ситуациях. А здесь они нам мешают. Но с точки
зрения выразительной возможности, предикатные, функциональные символы и константы мало на что
влияют. Вот пусть у нас есть модели константа С. Давайте зададим предикат х равно С, который
исчезнет тогда и только тогда, когда х равен С. Тогда, смотрите, если у меня есть какая-то атомарная
формула, куда входит С, но я остальные переменные не пишу для краткости. Как ее можно переписать в
этой сигнатуре с таким предикатным символом? Нужно записать условия. Существует такой у,
что он равен С и теперь уже формула, куда вместо константы подставлен на у. Ну и все. Константа
исчезла, но по сути дела она есть. Мы просто задали вот такой предикатный символ. Ну и соответственно,
если у нас есть функциональный символ, ну давайте н плюс один арный предикатный символ запишем.
Такой, что это единицы, если у равняется f от x1 xn и нулю иначе. Ну и понятно, что опять-таки,
когда у нас в какой-то терм входит вот такая функция, но я должен просто добавить условия,
существует переменная такая, что выполняется вот это вот и дальше использовать вместо
соответствующей функции вот эту переменную. Понятно, что если у нас сложный терм, мне придется
написать конъюнцию нескольких таких условий для верхнего, потом для тех, что подставлены,
но в конечном счете вот после конъюнции нескольких условий вот таких вот предикатных символов у
нас все получится. Поэтому в выразительных возможностях мы себя не ограничиваем,
но станет немножко проще. Значит, в чем состоит игра? Я вообще не знаю, учил ли вас кто-то играм
комбинаторным? Учил, не учил, более-менее. Я знаю, что в школе, если кто-то в Москве жил,
то наверно в турнире Ломоносова принимал участие, он не только в Москве проводится,
там есть конкурс по играм, в котором там чуть ли не с шестого класса люди участвуют. В общем,
я надеюсь, что какое-то представление о том, как устроены игры, вы знаете, потому что не хочется
тратить время на объяснение очевидных вещей, которые большинству известны. Но если кому-то
что-то непонятно, вы не стесняетесь уточнить. Значит, игроков два. Один будет называть N от
слова новатор, а второй будет называть K от слова консерватор. Значит, цели игроков различны.
Новатор хочет убедить, но он высказывает такой тез. Эти модели разные. Консерватор говорит,
нет, эти модели одинаковые. И вот игра эта, по сути дела, дисплот между ними. Они приводят
доводы. Какие доводы они могут приводить? Ну, во-первых, игра состоит в том, что в начале новатор
выбирает K. Положительное число. И дальше происходит уже K раундов. На каждом раунде в начале
новатор выбирает элемент из модели, скажем, M1 или из M2. То есть это на его усмотрение. Консерватор
должен ответить элементом из другой модели. То есть, если новатор выбрал из первой модели,
консерватор должен указать из второй. Если из второй, то, наоборот, из первой. То есть,
по смыслу, что происходит? Ну, новатор, прежде всего, говорит, так, мы долго диспутировать не
будем. Вот за 10 раундов должны управиться. Это решает новатор. Он обещает за заданное время убедить,
что модели разные. Хорошо, говорит, консерватор, давай. И вот новатор начинает. Он говорит, вот у
меня в модели есть такой-то элемент. Он достает этот элемент, показывает за его. Ну, что должен
сделать консерватор? Он же пытается увидеть, что модели одинаковые. Значит, он из другой модели
должен взять какой-то элемент, сказать, вот нет, модели одинаковые. Вот смотрите, вот он. Вот он
показал этот, а вот я показываю точно такое же, но из другой модели.
Ну, поэтому новатор может выбирать, из какой модели он вытаскивает очередной
элемент, но консерватор должен отвечать в другую модель. В результате, как
подводится итог игры. Вот они сделали ходы к штук, и у них
получились последовательности элементов из первой модели и из второй модели. На
каждом раунде выбираются по одному элементу из одной модели, и по одному, и
с другой. Теперь подводим итог игры. Значит, если у нас в сигнатуре есть какие-то
предикаты, ну давайте я их условно напишу вот так, p1, p2, ps. Если какой-то
из предикатов на каких-то, ну он может, предикат может быть разной арности, он на
каких-то из элементов этой модели дает разные значения. Вот это вот в первой
модели, а во второй модели тот же самый предикат на соответственных элементах.
K у меня уже было, тут как всегда нужно много букв. Вот если такое нашлось, то выиграл новатор,
иначе выиграл консерватор. То есть, если все предикаты из сигнатуры одинаковые значения
принимают на соответственных моделях. Консерватор говорит, ну посмотрите, что там новатор объяснял,
что модели разные. Вот я предъявил, он мне называл какие-то элементы, вот я ему предъявил элементы
точно такие же, все одинаково. Что вы хотите от меня? Ну а если новатор сказал, получил вот такой
набор, он говорит, ну послушайте, ну консерватор мог выбирать на свое усмотрение соответственные
элементы, но вот он выбирал-выбирал, а получилось, что все равно на них предикаты разные. Ну модели,
значит, разные, то есть ничего консерватор не смог нам убедить. То есть, вот такие правила игры.
Ну и они все-таки не вполне очевидны, поэтому сегодня я успею разве что разобрать несколько
примеров таких игр. Попроще, посложнее, ну и самый сложный, не знаю, надеюсь, что успею, но посмотрим.
Хотелось бы. Ну самый простой пример, просто чтобы прибиться к определениям, давайте рассмотрим
модель, две модели. У нас всегда игры на двух моделях. Модель натуральные числа с порядком и
целые числа с порядком. Я хочу, как раз, чтобы модели были попроще, чтобы быстрее можно было в эти
игры играть. Ну, кто выигрывает в игре Ренфойхта на таких моделях? Выигрышная стратегия есть у
новатора. Ну, кто выигрывает, это я прошу прощения, вы знаете, наверное, что когда есть игра и говорят,
кто выиграет, это имеет в виду, что существует выигрышная стратегия. То есть, не просто, что в какой-то
партии выиграла, что вот у одного из игроков есть правило, которое определяет, как ему делать ходы,
чтобы выигрывать. И вот тут выигрышная стратегия у новатора. Значит, он, во-первых, выбирает два раунда,
а дальше делает следующее, первый раунд. Он выбирает, давайте, вот здесь я буду обозначать
A и T, а здесь B и T для определенности. И вот новатор выбирает натуральное число ноль. Это новатор
выбирает. Ну, консерватор в ответ должен выбрать какое-то целое число. Теперь новатор выбирает
целое число, которое на единичку меньше выбрано консерватором. И что должен сделать консерватор?
Он должен указать какое-то натуральное число. Вот это вот B2. Консерватор вынужден, поскольку
новатор уже выбрал целое число, консерватор должен выбрать какое-то натуральное число. Но,
смотрите, B2, прошу прощения, по выбору новатора строго меньше, чем B1. Значит, чтобы все предикаты
сохранились, у нас один предикат. Нам нужно выбрать такое натуральное число, 2, которое строго меньше
нуля. А такого нет. Поэтому, какой бы ход не сделал консерватор, он проигрывает. То есть видно,
на самом деле, я думаю, вы уже начинаете чувствовать, что какая связь между элементарной
эквивалентностью ноль в этой модели, он определяется на натуральных числах. Это наименьшее число. Нет
такого натурального числа, которое строго меньше нуля. Это свойство ноль определяет. А в Z
такого числа нет. То есть вот есть формула, которая истинна в одной модели и ложна в другой модели.
Разречает эти модели. Ну хорошо, давайте теперь для следующего примера. Мне понадобится,
а нет, еще не понадобится. Давайте возьмем порядок на рациональных и на действительных числах.
Вот тут выигрышная стратегия есть, наоборот, у консерватора. Ну почему? Давайте подумаем.
Значит, консерватор должен играть против любого числа ходов. То есть вот новатор,
он выбирает какое-то число K, а потом консерватор должен отвечать на каждый ход новатора как-то. И он
будет поддерживать такой вариант, что вот у нас после какого-то количества ходов S выбраны вот
такие рациональные числа и вот такие действительные. И нужно, чтобы существовала перестановка.
Ну мы упорядочиваем. У нас числа убирались в каком-то порядке, но мы хотим просто упорядочить
по величине. И та же перестановка должна также упорядочивать по величине. И вторую группу,
это, заметьте, одна и та же перестановка. То есть, если a1 меньше, чем a2, b1 тоже должно быть
меньше, чем b2. И при этом, если api от i равняется api плюс 1, у нас могут быть одинаковые числа в этой
последовательности, то тогда и соответственные b тоже равны. Ну это называется порядковый
изоморфизм. То есть, мы хотим, у нас есть две последовательности чисел, они порядковые изоморфизмы.
Что это означает? Что если мы их упорядочим по включению, то вот они будут идти, вот соответственные
числа будут одинаково упорядочены, как по-строгому не нравится, так и по-нестрогому. То есть,
если у нас первое число, допустим, оно самое маленькое в одном и в другом, допустим все остальные
строго больше, а второе и третье в a равны, ну тогда они должны быть равны и в b. То есть,
выполняются строгие и нестрогие неравенства одинаковым образом. Ну вот в терминах, как я
говорил, разметки знаков должны совпадать. То есть, где-то меньше, где-то равно, вот они
должны быть одинаковы на обоих последовательностях. Это цель, это я пока еще стратегию не сформулировал.
Я сказал, что консерватор будет поддерживать такой инвариант. Ну и смотрите, если ему действительно
удастся поддерживать такой инвариант, то ясно, что когда игра останавливается, вот это вот условие
будет не выполнено. То есть, все числа будут сравниваться одинаково. То есть, фактически нам
нужно объяснить, почему можно такой инвариант поддерживать. Но это не очень сложно. Вот представьте,
что новатор выбирает какое-то следующее число x, которое там между a и t. Чтобы не писать лишнюю
букву p, я предполагаю, что a и t плюс 1 как раз соседние. То есть, это я рассматриваю именно
соседний интервал. Ну тогда, поскольку к этому моменту рассуждение индуктивное. Предполагаю,
что консерватор сумел это поддерживать, условия порядкового изоморфизма, ну сколько-то раундов.
Мы сейчас объясняем, что на следующем раунде он тоже это может поддержать. Ну а в начале никаких
чисел нет. Понятно, что пустые последовательности порядкового изоморфизма. Ну тогда, значит,
если это q, то тогда у нас есть строгое неравенство, и мы можем выбрать, консерватор будет выбирать
какое-то число y, которое тоже находится в строгих неравенствах между b i и b i плюс 1. Понятно,
что это сохраняет порядковый изоморфизм. Мы выбрали в соответственном интервале разбивания. Если a i t
равнялась a i плюс 1, и новатор выбрал это, ну тогда b i t тоже равняется b i плюс 1, и консерватор
выберет это же самое число. То есть от того, что новатор сделает повторение, консерватору хуже не
будет, он тоже повторит это число. У него же есть такая возможность. Ну и ясно, что если новатор,
наоборот, ходит в r, то консерватор может сделать ход в q. Тут мы что используем? Тут мы используем
свойства плотности порядка. Между любыми двумя элементами, что в рациональных числах, что
в действительных, обязательно найдется элемент, который строго между. Если элементы различны,
а меньше b, то найдется элемент, который строго меньше. Для рациональных чисел это верно,
а для целых, скажем, это было бы неверно. Можно легко понять, что, как в первом примере практически,
что если мы сравним порядок q и порядок z, то там новатор выиграет. Ну более-менее он как раз
сделает, выберет вначале целые числа там 0 и 1. Консерватор должен что-то выбрать среди
рациональных. И после этого он среди этих рациональных возьмет в середину отрезка,
которая строго между ними. И куда деваться консерватору? Консерватор не может выбрать
целое число между 0 и 1. А здесь может, потому что и тот, и тот порядок плотный. Поэтому здесь
выигрывает новатор. Ну это вот два примера попроще. Сейчас будет пример посложнее. Я надеюсь успеть
его рассказать. У меня еще почти что 10 минут. Значит, это вот какой пример. Во-первых, по-прежнему
натуральные числа. А второй порядок, ну вот он чуть похитрее. Надо будет сейчас объяснить вам,
что это такое. Это n плюс n. Я не знаю, определяли ли вам такие порядки или нет раньше. Но это,
давайте вот я здесь сотру. Сейчас определю, как мы берем сумму порядков. Что это за порядки? Мы берем
копии этих порядков, которые не пересекаются. И считаем, что они упорядочены так, что первые
элементы из копии p строго меньше, чем из копии q. Давайте я здесь прямо напишу. Мне все равно это
нужно сейчас для конкретного варианта. Вот мы пишем в начале обычные натуральные числа. Копии,
значит, ну как, у нас есть два дубля натуральных чисел. Их как-то нужно различать. Давайте я буду
штрих ставить. Вот мы перечислили все натуральные числа, а потом есть еще число 0 штрих, которое
больше всех старых натуральных чисел. Ну а дальше уже штрихованные числа тоже идут в том
же самом порядке. Давайте тут знаки поставлю, как мы и хотим. Вот такое вот множество. То есть оно
тоже счетное, но в нем две копии натуральных чисел. В начале обычные натуральные числа и вторая
часть, которая состоит тоже из натуральных чисел, но все они больше, чем вот эти. То есть у нас
такой вот такой порядок насчет на множестве задан. Ну и вот две такие модели. То есть один порядок,
другой порядок. Являются ли они элементарно эквивалентными? Тут уже вопрос менее очевидный,
потому что вроде бы на глаз видно разница между этими порядками. Вот все-таки вот этот элемент
0 штрих, он обладает такой особенностью, что какой бы вы меньший элемент не взяли,
отрезок между этими элементами содержит бесконечно много чисел. То есть ясно, что эти
порядки неизоморфны. Счетное множество объекции вообще говоря есть, но порядок сохранить мы не
можем. Потому что на натуральных числах, конечно, любой отрезок он конечный. А тут есть бесконечный
отрезок. Но бесконечный отрезок непонятно, как задать формулы первого порядка, которые используют
только отношения меньше. Мы можем написать любое конечное сравнение, что а1 строго меньше,
а2 меньше, а3 меньше, а1000. А как записать, что вот конечный отрезок? Непонятно. И действительно
выигрышная стратегия есть у консерватора. Идея очень похожа на предыдущую. Мы хотим
поддерживать, но у нас порядок, то есть у нас предикат вообще один, и в сущности консерватор
будет опять поддерживать вот такой порядковый изоморфизм. Но сложность теперь в том, что
буквально поддерживать не получится. Потому что из-за того, что я сказал, в одном порядке есть
такие бесконечные отрезки, а в другом нету. Поэтому консерватор делает хитрее. Его стратегия
теперь уже будет очень существенно зависеть от к. И он будет делать так. Он будет определять разрывы
уровня k. Давайте я лучше и напишу. Это означает, что расстояние между элементами порядка больше
или равно, чем два в степени i. То есть своей стратегией консерватор будет поддерживать не
вполне, не просто порядковый изоморфизм, а чтобы можно было продолжать эту стратегию, он будет
поддерживать более жестко. Он будет поддерживать изоморфизм с этим дополнительным символом. Я
вот этого буду записывать как х, ну там давайте, не знаю, два знака буду ставить. То есть что х очень
сильно меньше у. И вот идея консерватора состоит в том, что он хочет каждый раз, когда у него есть,
ну вот уже выбранные. То есть нужен такой вариант, что после, давайте я вариант запишу.
После и ходов наборы порядковой изоморфны
на уровне k-i. То есть другими словами, что если у меня скажем там a-pi-t меньше на уровне i, то есть
далеко от b-pi-t, то b-pi-t тоже должно быть вот так вот строго меньше, ну сильнейшее на таком вот
уровне. Только k-i, прошу прощения, и тут g тогда надо написать. То есть идея такая, что теперь,
после k ходов консерватор выбирает, глядя на первый ход новатора. Новатор же заранее объявляет,
сколько ходов будет сделано, и консерватор на это количество ориентируется. Но после k ходов
здесь получатся наборы порядковой изоморфны на уровне ноль. А что значит уровень ноль? Это значит,
что y-x больше либо равно единице, то есть y и x не совпадают. Ну тогда понятно, они различаются,
у нас получается обычный порядковый изоморфизм. То есть чтобы добиться обычного порядкового
изоморфизма после k ходов, консерватор должен вначале уметь различать ну вот до 2 в степени k. Вот
числа ближе, чем 2 в степени k или дальше. А в одной модели у нас есть бесконечные разрывы, они
конечно будут с любым k попадать. Но существенно, что среди натуральных чисел бесконечно много,
и опять-таки для любого k мы можем найти достаточно большой разрыв. То есть если консерватор вот эту
стратегию сможет выдерживать, то он победит. И я утверждаю, что он сможет это сделать. Почему?
Потому что ну давайте там есть много простых случаев, когда числа равны, когда числа близки
друг к другу. Ну то есть значит у нас условия порядкового изоморфизма еще такое, что вот если
у нас выполняется, что я тут написал, я прошу прощения, а и b между собой не сравниваются конечно.
Если у нас выполняется какое-то условие, давайте я уже напишу без лишних индексов, а то они меня
сбивают с толку. Не вот разрыв уровня какого-то, а прям строго меньше, то это означает, что вот мы
знаем, что вот эта вот разница, она просто одинакова. Вот отсюда порядковый изоморфизм в данном случае
означает нечто более сильное. Что мы хотим, вот этот если написан не разрыв какого-то уровня,
а прям строго меньше, это значит, что вот они просто одинаковы. И вот я хочу удовлетворять
такому более сильному усвою. У меня осталась одна минута, но с тому идею я успею рассказать. Идея
очень простая, потому что смотрите, вот берем два соответственных числа, но опять-таки я для
простоты пишу без индексов. Если здесь разрыв большой, ну вот после и ходов, разрыв был уровня k-i,
то есть вот здесь вот у нас больше чем два в степени k-i разница между этими числами, ну и
между соответственными числами тоже разница такая же большая. Если новатор куда-то пошел,
у нас получилось два отрезка, но хотя бы один из этих отрезков будет больше либо равен чем два
в степени k-i-1. Когда мы бьем отрезок на две части, хотя бы одна не меньше чем половина. И поэтому
у нас обязательно будет одна из частей разрыв уровня k-i-1, ну для определенности справа. Я уже
должен заканчивать. Ну а тогда слева либо тоже разрыв по-прежнему вот уровня k-i-1, либо он уже
меньше, и тогда мы просто выберем соответствующее число вот точно, чтобы выполнялась вот это
дополнительное условие. Но это вот самые сложные случаи. И ясно, что если разрыв бесконечный был,
но вот во второй модели, ну если консерватор заранее позаботился, что в первой модели был
достаточно большой разрыв, он все равно сможет его удовлетворить. То есть наше же вот это вот
условие, оно бесконечность и очень большую конечность не различает. Поэтому нам все равно.
Но нужно позаботиться о том, чтобы изначально разрыв был достаточно большой, чтобы у нас было
место сделать много ходов туда. Ну вот примерно так. Все, я должен заканчивать. Спасибо за внимание,
ну вроде бы успел.
