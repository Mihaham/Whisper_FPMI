В прошлый раз мы долго-долго говорили о том, как он строится
за линию, а главное почему, и даже не успели толком
поговорить на тему того, а что с ним вообще еще можно
делать.
Ну то есть, есть, конечно, очевидный момент.
Очевидный момент то, что задача о том, что найти под
строку в строке, теперь в суфистном автомате очень
просто.
Каким образом это сделать?
Каким образом это сделать?
Да, задача, дадан текст С и, возможно, его суфистный
автомат.
Да, дадан запрос П, входит ли строка П в текст С.
Ну сколько раз от следующего, хотя для начала давайте
так первый вопрос, там хотя бы входит ли она вообще
туда, да или нет.
Давайте как это сделать?
Ну можно сделать все терминальные, а можно сказать проще.
Можно сказать, давайте просто попробуем пройтись в автомате
из стартовой вершины по строке П, если полностью
прям по всем символам прожили, значит она входит.
Более того, да, если мы дошли еще и в конце до терминальной
вершины, значит это еще и суфикс, ну а если нет, то
нет.
А вот следующий вопрос, а если я хочу узнать сколько
раз эта строка входит в строку С как подстрока.
Ну вот пока я стираю.
Сейчас сколько терминальных вершин достижены за крышей?
Чего?
Вау, это тут причем.
Это будет означать, сколько префиксов этой подстроки
являются суфиксами строки.
Ничего не понятно.
Не, ну может надо типа пройтись и попрыгать по каким-то
суфиксам.
И чем это поможет?
Чем поможет?
Я сейчас об чем проблема, я не очень понимаю.
Так, ну в ту...
Мы нашли подстроку.
Так, нашли.
Дописываем в нее что-то дальше.
Мы в конце концов от каждого правления дойдем до терминала.
Ну если в тупую идти, да.
Если рандомно, то тоже да.
Нам нужно сколько различных терминальных вершин.
Ну по сути, да.
Вопрос, только вопрос по правочке, не сколько различных
терминальных вершин, может быть тут важное уточнение,
а с какими способами мы из этой вершины можем прийти
в терминал.
Это важно, потому что два разных способа прихода
в терминал дают вам две разные строки.
Да, кстати, это вот важный момент, знаете, потому что
смотрите, найти с какими способами дойти до терминала
это можно сделать простой динамикой.
А дойти...
А сколько терминальных вершин вы можете попасть?
Я, честно говоря, за адекватно симпатику не умею решать
эту задачу.
Ну да, скорее всего никто не умеет, хотя...
Нет, может кто-то и умеет, я не знаю.
Ну вот, да, я не знаю, я пока тоже так и не придумал.
Вот, но правда фишка в том, что это решение слишком
сложное.
Вот.
Чего?
Вот так.
Да, написать динамику для каждой вершины, сколько
способов дойти до терминала в фоциклическом графе, это
очень сложное решение для этой задачи.
Есть существенно более простое.
Топ-сорт.
Не, причем топ-сорт.
Ну решение топ-сорт.
Еще тупее.
Вот.
Если вы, конечно, понимаете, как у нас устроен суффиксный
автомат.
Ну окей.
Мы попробовали префикс отсудиться.
Теперь вам попробовать префикс отсудиться.
Да, это ничем это поможет.
Не.
Все гораздо проще.
То есть нет начала, конечно, то же самое.
Вы берете строку P и проходите в автомате по этой строке.
И вот вы пришли в какое-то мистическое состояние.
Ну назовем его Q.
Тогда количество вхождений строки P в текст S равно.
Можно по количеству идти по суффиксным ссылкам.
Так идти по суффиксным ссылкам.
В детей.
В детей.
А что нам дадут дети?
Сейчас.
Ну суффиксная ссылка, она же как бы уменьшает строку.
Ну вот так, уменьшает, да.
Но нам же не надо уменьшать.
Нам же надо...
А поэтому я хотел проходить не по суффиксным, а по развернутым
суффиксным ссылкам.
По развернутым.
Да, ну типа, когда мы проходим по развернутым, то мы выписываем
что-то вначале.
Нет, хотя нет.
А, а может я и наврал.
Может это решение оптимальное, да?
Так с чем-то я это перепутал.
Сейчас я подумал, я подумал про то, сколько у вас можно дойти,
но это очевидно не правда.
Нет, почему?
Сколько дойти до терминала, это правда.
Сейчас, ну там.
А, ну впрочем, нет.
Да, это неправда.
Ладно.
Да, правда было бы, если бы я сказал, да.
Да.
Если бы я вас попросил найти, кстати, вообще, каков размер
класса эквивалентности строки P?
Строки P?
Угу.
Класса эквивалентности...
Ну, сейчас, это просто размера длина P, минус длина...
Ну, длина, да, длина Q, на этот раз вот, да.
Да, да, да.
Ой, а в предыдущий раз это я наврал, да.
Ой, ну да.
То есть это вот раз размер класса эквивалентности.
Но если вам интересно количество вхождений,
то действительно, видимо, самое оптимальное
это просто на этом автомате потом еще динамичку написать.
Не знаю.
Ну, бывает такая задача.
Что такое длина Q?
Чего?
Что такое длина Q?
Длина Q?
Ну, смотрите, это длина максимальной строки
в класса эквивалентности в соответствующем вершине строки.
То есть мы как бы напомним, что когда мы строили
суффиксный автомат, мы этот лен в явном виде поддерживаемый,
он нам очень сильно помогает.
Сейчас тут вопрос.
А что такое в терминах задачи может быть класса эквивалентности?
Ой, там бы...
А вот прям честно и говорим.
На плане можно написать размер класса эквивалентности,
но это как-то тупо.
Нет, ну там были задачи, что говорим,
что у каждого...
Нет, там говорится обычно так, что
у каждой подстроки есть позиции,
где ее вхождение заканчивается.
Будем говорить, что...
Да, ну там...
То есть, короче, он никак адекватно не определяется?
Чем-то вот, да.
Нет, ну это вот да.
Ну, то есть как-то там, может, задачи чуть-чуть переформулировали,
но не более.
То есть там просили задачи, которые, по большому счету,
те же суффиксы автомата.
Да, найдите размер класса эквивалентности,
вы видите их в возрастающем порядке.
Это типа проверка, что вы написали за автомат.
Ну да, оно такое, да, просто...
Простое, да, простое упражнение.
То есть самое главное в этой задаче не тупануть,
потому что можно было тоже сказать,
что, допустим, у вас есть суффиксный автомат,
как черный ящик, да?
Тогда, как бы, какое количество строчек у нас...
Тогда у нас две строки эквивалентны,
тогда и только тогда, когда они приходят в одну и ту же вершину.
Давайте найдем это количество динамикой.
Вот, в принципе, так тоже, кстати, это та же...
Да.
Ну, собственно, да, мы можем и такую динамику,
при желании, написать.
Но это как бы в задаче на статик РСК
написать дерево отрезков.
То есть, да, вы его быстро напишете,
да, скорее всего, получите там мгновенный accepted,
но просто, скажем так, кто-то сделал то же самое
на 10 минут быстрее вас.
Вот, ну или там, за какое время
вы там пишете дерево отрезков.
Вот.
Ну, хорошо.
Вот.
Вот.
Ну да, в этом смысле да.
То есть более того, в принципе, там...
Господи, какие там разные задачи
на суффиксный автомат бывают, там смешные.
Вот у меня вообще вспомнилась такая веселая.
Там даже Алиса и Боб играют на строке в игру.
Значит, игра такая.
Да-да, строка С там...
Да, на строка С, допустим, да,
и дается ее исходно какая-то под строка П.
Алиса и Боб играют, значит, в такую игру.
Каждый...
Каждый из игроков по очереди приписывает
к строке П какой-то символ.
Так, по очереди, по очереди, по очереди.
Ну, выбирают сами какой, естественно.
Ну а единственное условие приписывать надо таким образом,
чтобы, соответственно, строка П
все еще оставалась под строкой строки С.
Проигрывает, естественно, тот, кто не может сделать ход.
Так.
Ну вот, давайте допустим, до нас строка П,
кто выиграет при правильной игре.
Давайте для разминочки.
Ну, по сути, да.
Правда, ретроанализм в классическом виде даже не нужен,
потому что граф ациклический.
Да, то есть там все-таки помним, да,
что на ациклическом графе можно и простую динамичку написать.
Да.
То есть, по сути, игра идет даже не столько на подстроках,
сколько на автомате.
И мы там ходим по вершинам.
Это да.
Более того, обычно задача дается даже в более продвинутом виде.
Значит, Али, там, допустим, Боб,
значит, исходную строку выбирает Боб,
он очень добрый, он хочет выбирать такую строку,
чтобы Алиса могла выиграть.
Так вот, задача.
Так вот.
Но почему?
Нет, это называется джентльмен.
Почему глупый-то сразу?
Если поддаваться человеку,
это высказывать ему неуважение.
Поэтому это нифига не джентльмен.
Ну, как сказать?
Если человек не знает о том, что ты ему поддаешься.
Но ты все еще высказываешь ему неуважение.
То есть ты заведомо выбираешь такую строку,
что ты всегда побеждаешь?
Нет, ну скажем так, если бы там было не...
Нет, понимаешь, если бы там он и жрал вместо Алисы с Андреем,
то в принципе да.
Но когда речь идет о девушке,
которую ты хочешь порадовать,
знаешь, можно в принципе и поддаться.
Миша свою сестру ты тоже уничтожает, да?
Да.
Мы всегда на прессе играем, я выигрываю всегда.
Ей, наверное, очень интересно.
Ну, не знаю.
Ой, кошмар.
Я еще выигрываю за нее против меня.
А потом делаю так, чтобы она ошиблась, да?
Логично, да.
Сначала я делаю так, чтобы она его...
Она ошиблась и я обманываю,
а потом показываю, как она могла меня выиграть.
Да, все понятно, понятно, понятно.
Ну ладно.
Она радуется.
Да-да-да-да-да.
Ну вот.
Так вот, но там задача еще более крутая.
То есть, чтобы совсем Алиса оценила, тут был интерес такой.
Вот у нее в общем-то запрос такой.
Как бы понятно, что ему хочется выбирать какие-то разнообразные строчки,
чтобы не было очевидно, что он там все время и поддается.
Поэтому вопрос.
Какую каты в электрографическом порядке под строку может Боб подсудить?
Сейчас, но это все еще мы выписываем просто все.
Сейчас, стоп, что?
Какие все?
Ну все мы не выпишем, очевидно, их там может быть все.
Выписываем все классы эквалитости.
Так.
Ну внутри.
А там?
Ну там...
Не, ну в классах эквалитости тоже есть моменты.
Плохо.
Да, классы эквалитости это да, но вот...
Так, ну-ка давайте-ка.
Нам же нужно просто каты по...
А ка маленькая?
Произвольная.
Я беру для ка не больше, чем 10 в пятый.
Да, каким же образом?
Мы берем все классы эквалитости и засовываем просто все их начала в кучу,
потом достаем из кучи минимальный, а из то...
Минимальное сопротивление.
А как ты определишь какое состояние меньше другого?
Ну...
Нельзя просто по автомату идти в эксекривическом порядке?
И без юзина.
Потому что в одну и ту же вершину можно попасть несколькими способами,
а несколькими принципиально разными путями.
Ну суммарно путей...
Квадрат?
Ну если вершина...
По числу подстрок.
Тогда нам не возвращаться, наверное, нет смысла?
Есть, но...
Но вообще...
Хотя...
Мы знаем все концы.
Хотя нет, наверное, нет.
Хотя нет, вершина возвращаться есть смысл, потому что это означает, что там просто...
То есть в одну и ту же вершину, если она выигрышная, входит несколько подстрочек.
Но как бы одна может быть в эксекривическом порядке маленькая, другая большая.
И каждый из них может нам пригодиться.
А какая задача?
Да, самый важный вопрос.
Значит, задача еще раз.
Значит, у нас вот есть игра.
Надо найти каты в лексиграфическом порядке под строку строк.es,
стартуя из которой выигрывает Алиса.
Хочется сделать следующее.
У нас все подстройки софиксов друг друга.
Хочется как-нибудь развернуть строку, чтобы они были префиксами,
а префиксы на лексиграфические...
Ну, тогда ты будешь приписывать символы в начало, правда, по этому.
Нет, ну, построить можно для ребежных отдельно.
И к чему-то нам помочь?
У нас, если мы построим субтамарные ребежные строки,
то у нас все классы валентности будут строки с суббиксами друг друга,
а в исходной строке это получится префиксы друг друга.
А префиксы очень хорошо сравниваются на лексиграфическую минимальную.
Сейчас мне как-то странно все-таки что-то.
Ты предположишь развернуть строку и сказать, что там, где решаем ту же задачу,
только символы в начало дописывали?
Нет, я хочу развернуть строку,
построить просто субтамар.
И что это тебе даст?
После этого у нас валентности в нем,
это какой-то набор суббиксов друг друга.
То есть каждый класс в валентности это набор строк,
каждый суббикс предыдущий.
Ну и что?
Ну правда, класса валентности вообще по-другому устроена, да?
И что?
Ну хорошо, да, в исходной строке им соответствовали какие-то префиксы друг другу,
и что это даст?
Ну и видимо строку тоже можно свернуть.
Ага, и приписывайте символы в начало.
Я предлагаю посчитать для каждой вершины,
с какими способами из нее достижемы проигрышные.
Так.
Или выигрышные.
А, ну да, проигрышные.
А хотя нет выигрышных.
Ну по сути так,
каждой выигрышной строке соответствует пути стартовой статистики.
Ну по сути так,
каждой выигрышной строке соответствует пути стартовой вершины до выигрышной.
Нет, ну мы говорим, начинает у нас Алиса, напоминаю.
Поэтому с выигрышной.
Ну да.
Ну поэтому к первому символу, да.
Делаем то же самое, если,
ну если к больше, то есть если,
тогда мы просто отнимаем это к количеству.
Ну короче говоря, как в поиске всяких там катых правильных срочных последовательностей.
Нет, ну идея простая.
Нам нужно, скажем так,
нас интересуют пути стартовой вершины до выигрышных вершин, правда?
Да.
Каждой верши пути соответствует строка, мы из этих путей хотим найти каты.
Да.
Так вот, вот какая это идея?
Давайте с помощью динамики для каждой вершины посчитаем
количество способов дойти из этой вершины до выигрышной.
Хорошо.
Да, именно не путайте,
именно не количество, не до скольки выигрышных вершин можно дойти,
а сколькими способами можно дойти.
Да, это такая тупая линейная динамика, да.
Ну вот.
Ну тогда у нас есть какая-то идея, что давайте думать,
то есть у нас есть стартовые вершины,
по какому символу пойти?
Там из нее там тактят буквы А, Б, С, там и так далее.
Но как бы вот мы пытаемся пройти по символу А
и знаем, получается, сколько хороших строчек начинается символ А.
Вот.
Ну да.
То есть дальше такая.
Так понятно, да?
Да, Димка.
Вот.
То есть вот такая вот красивая нот.
То есть такая красивая задача.
Да, конечно, обязательно надо учесть,
что когда вы находитесь в вершине,
она может быть сама по себе выигрышная,
поэтому пустую строчку тоже надо учитывать.
Ну суть такая.
Ну хорошо.
Слушайте, сейчас я вам тогда повеселее дам.
Эта задача может нас начнет приводить немножко в другую сторону.
А теперь представим себе.
Теперь, смотрите, абсолютно та же самая,
то есть в контесте дают две задачи с абсолютно идентичным условием.
Только поменяли одно слово.
У нас их нет.
Нет.
Чего?
У нас их нет.
Ну у нас их, к сожалению, нету.
Хотя...
Можно, в принципе, и добавить.
У нас так мало задач, как раз.
Ну...
Не хватает, если честно.
Не хватает.
Слушайте, осторожно.
Я не всегда на слух, как бы, понимаю, уровень сарказма в голосе.
Поэтому, как бы, я могу это принять за чистую монету и добавить.
Все задачи так настроены работать?
Хотя, с другой стороны, да.
У вас там такой хороший, да.
Хотя ладно, у вас там в этом году это CPC бонус еще.
Так что, да.
Ладно.
Так вот.
Ну там так вот.
Задачи там отвечаются одним словом.
Слово «конец» заменяется словом «начало».
То есть символы теперь добавляются в «начало».
Ну, тут уже кажется, что можно все развернуть, нет?
Только проблема...
Ну, как сказать, с точки зрения...
Если задача была бы просто выигрышная или проигрышная, то да.
Только теперь у тебя все еще задача — найти каты в несекретическом порядке, выигрышную строчку.
Да, но это тогда будет каты с суффикса.
Чего?
Так вот.
Нет.
А, да, нет.
Нет, да.
Чего?
Какая еще раз задача?
Значит, задача.
Играют два игрока.
Начинают они со строки P, которая является подстрокой строки S.
Они по очереди приписывают к строке P в начало на этот раз.
По одному символу.
Причем приписывают так, чтобы строка оставалась под строкой строки S.
Проигрывает тот, кто не может сделать ход.
Кто выиграет при правильной игре?
Это была бы простая задача.
А теперь вопрос.
Найдите кату в лексикографическом порядке под строку строки S, исходя из которой выигрывает первый игрок.
А вот здесь нас, очевидно, интересует только лонгест строки.
Думаю, что к остальным приписывание однозначно определяется.
Да, ну к остальным оно...
Да, то есть действительно, оказывается, если строчка не является лонгестом в своем классе эквивалентности,
то приписать к ней можно только один символ, и за пределы этого же состояния мы не выходим.
Правда, есть маленькая оговоречка, что в зависимости отчетности количества строк,
вопрос, кто в этот лонгест попадет и будет из него выходить.
Ну понятно, но мы можем выбрать как бы сжатое дерево на лонгест под строку,
считая длину вот этого вот ребра.
Это просто разность вот этих вот.
И, естественно, таким образом...
А этих лонгест под строку у нас уже вот M.
Это как-нибудь поможет?
Это как-нибудь поможет?
Ну надо только...
Так, нет, что на сжатое дерево на лонгест, там еще вопрос, какой переход.
Ну, переход...
Потому что можно попытаться подумать, хотя бы действительно над задачей,
что давайте для каждого лонгеста каждой вершины определим выигрыш на этой строке или проигрыш на этой строке.
Хотя бы для начала.
Спрашивается, как же?
Мы для всего класса определили выигрыш.
Да!
Мы ж только что обсудили, что на этот раз это уже неправда.
Потому что если лонгест выигрышный, то лонгест без одного символа это проигрышная ситуация.
Так что там как бы...
Сейчас, если мы развернем, то мы сможем понять, что они...
Что выигрыш, что они проигрышные?
Смочь, что мы сможем, но...
Но раз развернем, у нас никакой связи не будет.
Но там просто вот с катой в лексографическом порядке будут проблемы, да.
Поэтому нет.
Давайте сразу скажу.
В данном случае лучше не разворачивать.
Бум, бум, бум...
Бум, бум, бум...
Бум, бум, бум...
Стоп, а если Боб добрый, то он не будет Алисе поддаваться во время игры?
Не-не-не-не.
Играть-то они будут нормально.
А, тогда лучше было, чтобы Боб выбирает стропы, на которые играют Алиса и Вася.
Господи...
И Боб и парень Алиса, а Вася...
Так, погоди, погоди.
Нет, тут как бы, знаешь, тогда уже не путать.
Просто если уж Алиса и Боб, то тогда там Клара должна возникать.
Ну или там я тебе Карл еще можно.
Чего?
Ну почему Алиса и Боб?
Потому что A и B.
Следующий должен быть C.
Так, ну тогда извините.
Ну тогда извините, давайте тогда...
Тогда уже как положено.
Лиса-Алиса, Кот-Базилио и Лось-Валера.
Ну логики.
Тогда хоть как бы все.
Анастасия и Борис.
Ой, нет.
Лиса-Алиса и Кот-Базилио.
Нет.
Лиса-Алиса и Кот-Базилио.
Я настаиваю.
Так.
Вот.
Вот точно.
Может вам в контест эту задачу добавить?
Ну а чего бы нет?
Там простая задача на питончике.
Быстро пишется.
Ну да.
Ну там так.
Диафантовое уравнение на десять сотый.
Как раз в тему нашего семиастров.
Ага.
Нет, там главная задача.
Так сама по себе вроде не самая убойная, но...
Ой, скажем так.
Когда я переводил ее с английского, собственно, я получил огромное удовольствие.
Вот так.
Ну ладно.
Давайте хоть с этой задачей разберемся.
Тут я еще могу вам тоже рассказать.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
У нас же эта задача эквивалентна предыдущей.
Только если мы лексикографически справа-налево сравниваем.
Да.
Ну вот.
Предыдущей задачей мы строили, ну начинали искать со стартового
состояния.
И что?
Может, можно как-то начать искать, типа начать строить
путь с конца, а не сначала.
Ну там, там проблема в том, что в каждую вершину входит
несколько стрелочек по одной и той же букве.
Да просто самих вершин несколько.
Каждый из них может продолжаться.
Не, ну за квадрат все еще можно.
Не, ну за квадрат, да.
Хотя нет, стоп.
Не, ну за квадрат все еще можно.
Не, ну за квадрат, да.
Не, ну за квадрат, да.
Не, ну за квадрат, да.
Не, ну за квадрат, да.
Не, ну за квадрат, да.
Не, ну за квадрат, да.
Не, ну за квадрат, да.
Не, ну за квадрат, да.
Не, ну за квадрат, да.
Не, ну за квадрат, да.
Не, ну за квадрат, да.
Не, ну за квадрат все еще можно.
Не, ну за квадрат, да.
Хотя нет, стоп.
Все пути можно просто перебрать.
Нет, ну перебрать-то да.
Для каждого пути бы еще определять, выигрышный
он или проигрышный.
Хотя, конечно, да, если бы у нас была возможность
хотя бы выписать все подстройки, скорее всего,
даже без всякого суффиксного автомата задача бы решалась.
Ну или там такие, он нужен, чтобы там как-то адекватно
описывать строчки в автомате, разве что.
То есть это еще все-таки подстройки в строке.
Нет, тут, ну хотелось бы, конечно, чуть-чуть побыстрее,
очень сильно.
Знаете, но не говорите, или не знаете и думаете.
Да, правильно.
Думаю, что знаю.
Да, именно.
Ну то есть так, я оставляю себе мизерную вероятность
того, что мое решение не верну.
Но на этот раз...
Не-не-не, знаете, возможно, мы сегодня в конце, если
останется время, мы рассмотрим задачу решения, которые
я не знаю.
Но у меня ощущение, что оно какое-то вот достаточно
простое, поэтому, конечно, тут собесными усилиями должны
осиить.
Вот, но это не она.
Вот, ну это не она.
Поехали.
Ну давайте так, подсказочка.
Так, ну давайте хотя бы действительно, как хотя бы
понять для каждой, то есть действительно для каждой
вершины, лонгест ее выигрышный или проигрышный?
Понять для каждой вершины?
Ну да, давайте хотя бы для, хотя бы с этого начнем.
Ну так, сейчас.
Ну начнем с простого вопроса.
С простого вопроса.
Допустим, вы находитесь в состоянии Q, в какой-то
строке X, которая равна лонгест от Q.
Ну там, с индексом S, конечно.
И вы решили приписать к ней символ A.
Понимание, вопрос.
В какое состояние вы перейдете?
А это не будут прыжки после ссылок, пока у нас нет
входящего символа?
Сейчас.
Не-не-не.
Переход по символу A был бы, если бы мы в конец приписывали.
Мы же сначала приписываем.
То есть это как бы наоборот, на самом деле.
Смотрите, должна быть какая-то вот мистическая вершина,
в которой лежит строка AX и возможно еще какие-то.
То есть из нее суффиксная ссылка наоборот в это Q ведет.
Вы находитесь в лонгесте Q.
И вы решили к строке X приписать символ A.
Получается, у вас должна быть какая-то строка AX.
Но заметим, что по определению суффиксной ссылки получается,
что состояние, где лежит этот AX, должна вести суффиксная
ссылка в Q.
То есть более того, мы с вами даже уже это обсуждали,
когда доказывали линейность этого счастья.
Мы обнаружили, что как устроены суффиксные ссылки.
Суффиксные ссылки устроены так, что есть какие-то вот
строки типа там BX, там допустим DX.
Ну и там какие, в общем, на какие символы X можно
продлить влево.
И каждому из них, и вести в нас будет ровно столько
суффиксных ссылок, сколько различных символов у нас
можно слева приписать.
Более того, да, у нас получалось дерево с суффиксными ссылками.
Просто из этих заображений даже выводили там сколько
там вообще состояний.
Я не уверен, что мы это обсуждали.
Нет, мы это обсуждали.
Мы же как-нибудь...
Мы теперь ходим не по ребрамам, а по суффиксным ссылкам.
На каждой суффиксной ссылке.
В общем, даже хуже не по суффиксным ссылкам, а по обратным
суффиксным ссылкам.
Да, то есть придется провести дополнительную работу,
то есть для каждого состояния сохранить вот по каждой
буковке свою типа обратную суффиксность.
Почему плохо?
Потому что у нас стартовое состояние не одно.
А столько сколько хороших машин.
Поэтому у нас переход будет сразу из всех этих машин.
Но на самом деле не угадал.
Стартовое состояние у вас как раз одно.
Потому что по обратным суффиксным ссылкам.
То есть на самом деле это я просто обманчиво нарисовал.
На самом деле суффиксные ссылки скорее справа-налево идут.
Но если у нас автомат весь идет слева-направо, все
стрелки туда, то суффиксные ссылки наоборот справа-налево.
То есть на самом деле правильная картинка, конечно, выглядит
скорее так.
Тут вот допустим АХ, БХ, ДХ.
И тогда оказывается, что как раз мы идем в ту сторону,
все равно по обратным ссылкам.
То получается стартовое состояние как раз одно.
И это стартовая вершина.
Так что тут так как раз.
Ну такие даже это может сказать не стартовое состояние,
а так может быть.
Чего?
Не может быть.
Что не так?
Что тебе не нравится?
Мы считаем количество строк.
То есть короче говоря, если мы хотим определить,
является ли П выигрышный, мы просто проходим все это
П и потом найдем из него?
Ну не совсем так.
Мы проходим все должны пройтись по П, прийти в ее
состояние, посмотреть как П по длине отличается от
лонгеста, посмотреть результат от лонгеста и там возможно
его инвертировать, если расстояние до него ничего.
А для лонгеста вот так вот пройтись по обратным ссылкам.
Но для лонгестов тоже аккуратно, потому что когда
Ну не совсем.
Ну почему?
Во-первых та же динамика, но единственное только маленькое
оговоречко, что вот этот вот АХ он лонгестом быть
не обязан.
Будь здоров.
Поэтому оговоречко-то.
Поэтому оговоречко та же самое.
Да.
То есть да.
Ну вот.
И то есть мы начинаем сначала.
Вот.
Так то есть смотрите.
То есть мы научились.
Мы еще не решили задачу.
Мы еще не совсем решили задачу.
Мы научились для каждой вершины определять является
ли выигрышным ее лонгест.
А точнее лонгест, ну и все остальные соответственно
символы тоже.
Все остальные строчки тоже.
Как мы это сделали?
Ну вот.
Давайте сейчас я проговорю, как мы это сделаем.
На всякий случай, чтобы было всем понятно.
То есть как мы это определяем?
Очень просто.
Определяем это справа налево.
Ну потому что ход из лонгеста это ход по обратным суффиксным
ссылкам, приписывая какой-то символ, который заранее
предподсчитывается.
Ну понятно, что если у вершины нету детей в дереве суффиксных
ссылок, значит получается из нее пойти нельзя.
Вот.
Соответственно.
Но.
Вот.
Но если ходы есть, то мы, во-первых, тогда пытаемся
делать эти ходы, но для каждого хода, но каждый из этих ходов
теперь может, но для этого каждого хода теперь нужно
аккуратно определить, является ли он выигрышным или прорешным.
Как определить?
Ну заметим, что если АХ является лонгестом, то
мы уже заранее предподсчитали, этот ход будет, эта строка
выигрышная или прорешная.
Но если АХ не лонгест, то надо посчитать длину АХ.
Ну это длина Х плюс один.
Мы посчитаем длину, длину лонгеста того состояния.
И если у них разница четная, тогда значит надо скопипастить,
скопировать тут результат у АХ, потому что через
четное число ходов как бы мы достигнем лонгеста.
А если расстояние нечетное, то оно поменяется.
Почему?
Потому что там до этого лонгеста ходы будут форсированы.
Так это понятно, что я говорю, да?
Да?
Все.
Вот.
Вот.
То есть поэтому для каждой, поэтому теперь так.
Итак, для каждой конкретной строки, то есть для каждой
конкретной строки П мы теперь не разворачивая автомата
умеем определять выигрышная строка или прорешная.
Ну понятно, для этого просто надо прийти по строке П
в нужное состояние и проверить там внутри этого состояния
разность длин у лонгеста и у этой строки П.
Вот.
Ну теперь возникает такой интересный вопрос.
Как же нам найти теперь кату в легчеграфическом порядке выигрышную строчку?
Нет.
Ну не совсем так.
Ну как сказать?
У нас тоже ребра на них тоже написаны в буквы.
Ну, как сказать?
Что мы словно собираем типа за другой стороны?
Ну да.
То есть там то, что в карта.
Потому что нам бы как бы уметь желательно тоже определять,
допустим, сколько выигрышных слов начинаются за одного префикса.
Так о чем проблема?
Мы не научились этого делать.
Пуше у нас там, да.
Сейчас.
А в чем проблема?
В том, что эта фраза не рождает решения.
Ну в плане опять делаем динамику.
Сначала мы насчитали выигрышную.
Ну выигрышная, стойте извини, лонгеста.
Потом, допустим, еще раз делаем динамику.
И теперь уже считаем количество доступных выигрышных.
И нужно опять аккуратно пересчитывать.
Погаи, что значит доступных выигрышных?
Как бы если вы пришли в выигрышную вершину,
это не значит, что вы пришли в нее по строке,
которая является выигрышной.
Ну, в плане...
Количество доступных выигрышных можно считать не только из выигрышных.
Нет, ну не путать понятия.
Потому что у нас как бы понятия...
Лучше сейчас не употреблять словосочетание выигрышная вершина.
Что будет сегодня на лекции?
Ну, как минимум, вот это.
Ну, как дальше сувдерева с укранином будет?
А что?
Просто люди спрашивают.
Видимо, пытаются понять, нужно ехать или нет.
Ну дальше сувдерева с укранином,
потом попробуем, собственно, закончить галилосейфераса
и, возможно, еще задачи решить.
Не подсказывай, что они неприятны.
Ну, пожалуйста.
Хотя забавно, через 45 минут после начала
загадить и спрашивать, а имеет ли смысл ехать.
Ну окей.
Не, ну мы осуждаем такие.
Да.
Да.
Если это не нагибин с Мустафиным, конечно, да.
Ну почему не суть?
Так.
Сейчас.
Ну, короче.
Так, что нам вообще нужно?
Нам нужно для строки.
Например, для лангеста.
Вы считаете, что это будет?
Вы считаете количество чериков,
в которых количество способов?
Сейчас.
Что такое вообще выигрышные?
Вот тот и прикол.
У нас выигрышная прорывочная строка под строка теперь,
а не в вершину.
Это понятно, но это не особо мешает.
Ну, пока сильно мешает.
Потому что как бы...
Потому что вы не можете просто потому, что скажешь,
что вы под строки по подстроке пришли в вершину,
вы просто так теперь не можете сказать,
что это строка теперь выигрышная или прорывочная.
Ну, кажется, мы все можем насчитывать для лангеста.
Да, для лангестов мы научились начать.
Так.
А потом мы можем насчитывать не только выигрышные,
но и прорывочные.
Когда мы будем не выигрышные приходить,
то они могут сфокусировать.
Ну, может.
Но только надо вот точнее что-то сказать.
Приходить-то мы можем куда угодно.
Ходить туда-сюда мы можем как угодно, но...
А, то есть мы, короче,
две строки хотим понять количество способов выигрывать.
Да.
Первым ходом...
Нет, сейчас.
Количество...
Количество выигрышей,
которые можно получить на строке, или что?
Ну, в идеале хочется понять количество как бы путей,
количество как бы таких вот выигрышных под строк П,
желательно, начиная сейчас с какого-то префикса.
Только тут вот.
Ну, вот.
Ну, вот.
Ну, вот.
Ну, вот.
Ну, вот.
Ну, вот.
Ну, вот.
Нет, ну если просто внимательно посмотреть,
как устроены выигрыши.
То есть, как мы уже поняли,
не все строки, соответствующие одному и тому же состоянию,
являются выигрышными или проигрышными.
То есть кто-то является выигрышными,
кто-то является проигрышными.
Но надо очень четко осознать,
какие подстроки являются выигрышными в одном состоянии,
а какие проигрышны.
... в одном состоянии они чередуются.
чередуются другие месла но та вот как бы это и по-другому сформулировать
только какая проблема ну вот скажем так если по-другому сформулировать решение станет
очевидным если формулировать так решение непонятно вот так скажем если я скажу точнее
что я имею ввиду я пропалю решение пока это еще нет решения мы пока только для
лонгеста научились понимать как для каждого именно лонгеста является ли он выигрышным
мы это делаем следующим образом мы говорим что вот допустим вершина отвечает лонгесту
да мы пытаемся дать ну да пытаемся потом переходим смотрим все ссылки которые у него
торчат и в зависимости отчетности ну короче вот это пересчитываю да но
в зависимости отчетности и выигрышности лонгестов этих вершин да вот вот а потом
мы хотим для вершин уметь понимать
сколькими способами но не знаю сколько из него вообще
очевидно все не выигрышные ну что не опасная формулировка можно понять десятью способами
причем будет каждому собеседу будет очевидно что ты имел в виду именно то что он думает
если к ней может быть когда-нибудь лет через 5 он поймет что ты имел в виду другое но
но в этот момент он очень сильно удивится
нет ну ладно не будем зависать формулировка лежит так нам чтобы понять про подстроку выигрышная
надо знать две вещи первое является ли выигрышным состояние лонгестов которые мы пришли и второе
счетность длины строки п но на самом деле заметим следующее что в каждом состоянии есть есть
строки длины четной длины и строки нечетной длины и заметим что какие-то строки одной
всегда выигрышными в этом состоянии а строки другой чётности являются проигрышными логично
да вот то есть поэтому по большому счету то есть идея возникает на самом деле такая то есть то
есть по большому счету то есть теперь то есть на самом деле можно просто раздвоить состояние то
то есть раздвоить состояние, и сказать, что мысленно динамику,
то есть мы будем считать, естественно, ту же самую динамику, да, то есть там,
ну вот как раньше, раньше мы считали динамику,
что для каждой вершины мы говорим, с какими способами можно прийти в выигрышное состояние, да?
Ну, в предыдущей задаче было такое.
Ну, это за один шаг, видимо.
Почему за один шаг?
Просто дано состояние, с какими, с какими, сколько существует путей,
по которым мы можем прийти из него в выигрышное состояние.
Видимо, не путей, а способов игры.
Нет, путей, буквально путей, потому что мы же стартовые подстроки искали,
в каждой, в каждой подстроке соответствуют пути стартовой вершины.
Сейчас, ну, мы можем вообще вершину раздвоить.
А, все.
Все, ну можно раздвоить, ну, не, да, но можно раздвоить, по сути, для динамики.
По которому туда-сюда прыгали.
Ну, типа, ну...
Короче, и сделать все, как в изначальном графе.
Ну, в смысле, ну, и для такого графа уже спокойно сделать,
считая, что это у нас какой-то абстрактный граф с абстрактной игрой.
Ну, такое, ну, ну, где-то, ну, где-то так, но тут, ну, можно,
но можно, наверное, где-то и так мыслить тут уже, как угодно.
Да, то есть я бы мыслил по-другому, то есть я уже там, то есть я бы там динамичку
насчитывал, что, действительно, что у нас только, только у нас теперь
состояние в динамике это не, это не состояние в автомате.
То есть состояние в динамике это пара из состояния в автомате
и четность длинных строки, в которые мы пришли.
Вот.
Потому что вот такая пара уже, действительно, можно считать,
что является выигрышной и проигрышной, тогда можно запускать предыдущие решения.
Сейчас, ну, можно вопрос?
Сейчас, чего?
Зачем нам нужна четность строки, конечно?
Ну, потому что внутри одного состояния, смотри, вот, лонгест,
например, допустим, лонгест выигрышная строка.
Тогда лонгест без первых символов это проигрышная строка.
А лонгест без двух первых символов выигрышная строка.
Сейчас.
Мы хотим, мы стоим, мы хотим посчитать количество, значит,
если мы считаем из вершины.
Мы хотим написать для вершины, сколько строк мы можем приписать
к данной, которые будут выигрышными.
Да, но при этом мы должны знать ее счетность.
Ну, если мы для лонгеста считаем.
Да, мы на разных языках говорим, по-моему.
Если мы говорим, что вершина это лонгест.
Но вершина это не лонгест.
Вершина это несколько строк, каждый из которых, в общем,
некоторые из которых выигрышные, некоторые проигрышные.
Поэтому лучше так не мыслить.
Почему?
Вот именно потому, чтобы не путать понятие вершины
и понятие строка.
Потому что как бы это не одно и то же в данном случае.
То есть нельзя с одной и той же меркой подходить
к нескольким строчкам, приходящим в одну вершину.
Ну, хорошо, представитель.
Лонгест это представитель вершины.
Если что, да.
Мы считаем, вот...
Если мы стоим, значит, наша динамика,
которая считает количество
путей до хороших вершин,
это количество строк, которые можно приписать
к вершине,
чтобы получить вершину строку.
Ну да.
Соответственно,
если...
А что происходит, если мы от представителя
добавляем один символ начала?
Если вы это делаете и не выходите
за пределы состояния Q,
у вашей текущей строки,
вы, как минимум, выигрышность меняется на проигрышность.
Только как минимум, просто потому что заметим, что...
Ну, как сказать?
Ну, на самом деле да.
Эээ... Нет.
То есть остается те, что нет, это неправда.
То есть то, что вы приписывали раньше для выигрышности,
когда вы в этой строке слева приписали символ,
они резко стали проигрышными наоборот.
Нет, я хочу не приписывать выигрышную строку, а чтобы
после приписывания строка стала выигрышной.
Допустим, жила-была какая-нибудь строка игр,
которая не является лонгестом.
Ты к ней нашел, что приписать справа, чтобы получилась выигрышная.
Да, заметим, что это приписывание сначала...
Приписывание слева к игроку единственного символа, который ты можешь приписать, а он единственный.
Так вот, оно у тех всех подстрок выигрышность меняет на проигрышность резко.
Нет.
Да.
Потому что...
Я имею в виду...
Сейчас.
У нас действительно разные понятия.
Я имею в виду, что если мы к текущей строке допишем что-то справа,
получим выигрышную, это ту из которой мы начнем и выиграем.
Набор слов.
И...
Ну, то есть, количество строк, которые...
Значит, количество строк, которые, во-первых, выигрышны, если мы из них начнем.
И...
И, во-вторых, получается, из нашего представителя добисывание слева какого-то количества силы.
Ну, допустим, у тебя такое есть.
Когда количество таких строк совпадает для всех строк из класса эквалидности?
Нет.
У меня свойство не зависит от того, к чему я приписываю.
Ну, значит, мы говорим на разных языках, потому что, как я понимаю слова, которые ты сказал, нет, это неправда.
Как минимум, потому что может так быть, что...
Как минимум, потому что, как бы, игроку, может быть, к игроку ты захочешь приписать эпсилон, но он окажется выигрышным.
Может такое случиться.
Но Джилл был игрок, который не является лонгестом в своем классе эквалидности.
И он, допустим, был...
И у него там, ему выигрышно оказалось приписать строку эпсилон.
Ну, типа, сам игрок выигрышным оказался.
Так вот, утверждение.
Если ты припишешь к игроку слева символ А, то тогда строка А, как к строке А игрок, нельзя будет приписать эпсилон так, чтобы он стал выигрышным.
Окей, то есть у нас плюс один может происходить.
Ну, не может происходить, а всегда будет.
То есть когда вы ходишь в одном состоянии, то есть у тебя ход форсирован, поэтому как бы выигрышность-проигрышность строго меняется.
Ага, ну то есть короче говоря, это...
То есть у нас единственное, что происходит, когда мы начинаем от представителя переходить к более мелким строкам, это у нас происходит...
К более мелким, чего?
Более...
Более мелким, да.
Да ладно, мы к более крупным всегда переходим, мы же символы приписываем.
Представителя...
Слово представителя даже...
Это лонгест.
Не обязательно.
Я не знаю, в моем понимании представителем дельшины может быть кто угодно.
То есть вы считаете динамику для лонгестов?
Ну скажи так, да, мне удобно считать, ну удобно считать для лонгестов, да, потому что у них...
Потому что переход из лонгеста ведет в другое состояние.
С левой вообще ничего не припишешь.
Почему на оба?
Да.
То есть приписать, правда, возможно скорее всего несколько...
То есть короче, когда мы уменьшаем длину строки, вот от этого лонгеста, у нас добавляются выигрышные сами эти строки, если они выигрышные были.
Больше ничего не измен dx3
Но нет-нет-нет, неправда, я опять же сказал, если лонгест был проигрышный, то значит лонгест без одного символа, если он лежит в этом состоянии, он заведомо выигрышный.
Это если на строках которая добавится выигрышная.
Нет.
Если в этом состоянии еще там лежит строка лонгест без 3 символов, то это тоже выигрышная строка.
Да, но я имею в виду то что лонгест без 3 символов из лонгеста без одного мы не получим.
Что на хит без?
Ну в плане из строки лонгест без одного символа, мы можем получить, какие выиграешь настояние. Возможно он сам?
Нет, из состояния лонгест без одного символа можно получить только лонгест.
Ну еще возможно самого лонгеста без одного символа.
Нет, ну в смысле ход ты можешь сделать из лонгеста без одного символа, ты можешь сделать только один ход. Сам лонгест. Все.
Возможно мне не нужно делать ход, я уже выиграю с ним.
Вы же сами так все говорили.
А, ну нет, с точки зрения, ну игра как бы, нет.
Ну не с точки зрения игры.
Я говорю выигрышность или проигрышность.
Мы же это вроде бы ищем.
Нет, мы не ищем количества выигрышных вершин.
Ну не вершина, а строк.
Ну нам, ну количество выигрышных строк у нас тоже так. Не особо, не особо.
А что мы ищем?
Ну то есть количество выигрышных строк начинается за одного префикса.
Вообще-то мы ищем.
Чтобы динамику считать.
Количество, ну да, да, да, да.
Ну вот, там решено.
И это количество для внутри класса экварианности
отличается только на те строки внутри самого класса экварианности,
которые являются выигрышными, мы их не учили в лонгесте.
Чего?
Ну то есть...
Кажется, если мы возьмем...
Сейчас, вот у нас была вершина, да?
Это лонгест.
Мы знаем, что вот тут можно что-то дописать, вот тут что-то дописать, вот здесь что-то дописать.
И это все будут выигрышные вершины.
Допустим. Ну если лонгест проигрышный, то да.
Вот пусть лонгест выглядит как-то так.
Так.
Тогда если мы возьмем строку...
Для лонгеста мы насчитали количество таких дописываний, да?
Да.
Теперь возьмем строку BAX.
Теперь, у нас есть два варианта.
Либо она самовыигрышная.
Да?
Ну, и что?
Тогда у нас будет плюс один количество выигрышных.
Строк, очевидно.
Это первый вариант.
Второй вариант, что мы допишем что-то слева, а слева мы можем дописать только А.
Только букву А.
И это будут все варианты отсюда.
Только это обычно к решению задачи не будет иметь никакого отношения.
То есть, короче, для строки BAX у нас количество выигрышных вершин.
О боже, не-не-не.
Я извиняюсь, но ты считаешь только...
Нет, ты извиняешь, для каждой строки считаешь количество выигрышных строк суффиксом которых она является.
А нам, простите, нужен.
А нам префикс нужен.
Нам динамику надо считать.
Чтобы вот как раньше было.
Дописываем слева, но когда в лексикрафическом порядке выигрышную мы ищем, напоминаю.
Можно еще раз висеть алгоритмом?
Ой, ой, ой, ой. Слушай.
Ну, не знаю. Ну попробуем, хотя, конечно.
Хотя, такими темпами уже не вижу смысла, если честно.
Но алгоритм такой.
Сначала для каждой вершины мы определяем, является ли выигрышным просто ее лонгез, да или нет.
Да.
Вот, описанном алгоритм повторять не буду.
После этого мы говорим о том, что в каждой вершине в классикваленции лежат какие-то подстроки.
Они бывают четные длины и нечетные длины.
И строки одной четности являются выигрышным местом, а строки другой четности нет.
Это мы тоже знаем.
Более того, для каждого стене еще и считаем, какой четности какие.
Ну, потому что, соответственно, кто совпадает с лонгезом, у того тоже самое, что с лонгезом.
Иначе нет.
То есть дальше у нас решение должно быть по идее таким.
Вот мы ищем кату выигрышную строку.
Вот мы стартуем с тартовой вершины.
Там говорим, что допустим, проверяем, пустая строка вообще является выигрышной или проигрышной какой-нибудь.
Ну, если является, вычитаем один.
Так вот, дальше берем переход по символу А.
Переходим вот в это состояние, помни о том, что у нас строка длины 1.
Вот.
Внимание, вопрос.
С какими способами из вот этого состояния с нечетной строкой можно попасть в выигрышное?
То есть можно попасть в выигрышное.
То есть продлите их только в право, а не в лево.
Вот мы каким-то образом вот это число мы должны с небес по факсу откуда-то достать.
Продлите их вправо, а не в лево.
Продлите их вправо, а не в лево.
Сейчас мы проверяем те строки, которые начинаются с А.
Так, ладно, более простая задача.
Видимо даже она не оказалась очевидной, я на это рассчитывал.
Хорошо, дана строка С. Найдите катую в диктикографическом порядке ее под строку.
Просто.
Так, мы переходим по этому.
Ну мы смотрим начало.
Смотрим все ведущие из него символы.
И переходим.
Ну понятно, если проверяем количество.
То есть нам нужно найти...
А, нам нужно для каждой вершины...
Найти количество...
Ну то есть то, что мы уже считали.
Ну почти.
В данном случае было бы просто из этой вершины найти количество путей из нее куда-нибудь.
Это считается простой динамикой.
То есть это нот.
То есть тогда мы считаем, если это число больше, значит мы идем по этому символу, если меньше, то вычитаем и пытаемся идти по символу В.
Ну вот так.
Ну тут, надеюсь, понятно?
Вот, так вот, по идее мы хотим применить ровно ту же технологию.
Да, хотим.
Вот, только теперь из этого состояния вопрос.
То есть мы находимся в этом...
Только состоянием теперь у нас является еще...
То есть не только то, что мы находимся вот здесь, а еще тот факт, что мы пришли сюда по строительнике четной длины пока.
Да, ну мы спрашиваем все строки, которые начинаются...
Мы по сути ищем количество строк В, которые начинаются с символа.
Да.
Что нам для этого надо?
Ну нам по идее получается так.
То есть мы говорим, мы хотим...
Мы пришли...
То есть в общем случае это будет звучать так.
Мы пришли по какой-то строке П вот в это состояние с заданной четностью.
С заданной четностью длины строки П.
С какими способами мы из этой пары можем попасть в какую-то выигрышную пару.
Мы путаем понятие состояния автомата и состояния динамики.
Потому что состояние динамики это пара из состояния автомата и четности строки.
Вот.
То есть тут уже динамику мы считать можно.
Вот.
То есть как она нот?
То есть там она нот.
То есть...
Да, потом она нот.
Потому что...
Действительно, про каждую такую пару мы знаем.
У нас пара теперь является такая выигрышной или проигрышной.
И соответственно, когда мы к этой паре там приписываем какой-то символ А,
то четность меняется, состояние тоже меняется.
И мы там уже смотрим, меняется на что.
На там...
Ну там, четность меняется, состояние меняется.
И мы там, собственно, прибавляем к ответу то, что мы там насчитали там.
То есть вот такая, по идее, технология.
Вот.
То есть поэтому вот такую динамику можно посчитать и потом после этого тут ходить.
Вот, помня, что здесь нечетная, потом когда мы по следующей буквы пойдем,
там для нас таки будет четная и так далее.
Ну похоже.
Ну вот да. Кошмарь.
Вот.
Ладно.
Ой.
Хотя да.
Ну вот.
Ну ладно.
Давайте уже переходить в существенному дереву.
А то что-то уже...
А то как-то да.
Задача, конечно, может не самая простая, но и не настолько сложная.
О, спасибо.
Ну вот.
Ладно.
Значит, будем сейчас строить другую структуру данных.
Ну, собственно, третью из суффиксной триады.
А, мы еще суфмассы не построили.
Ой, точно.
Кошмар какой.
Это значит, надо еще и суффиксные массивы.
Суффиксные массивы.
Суффиксные массивы.
Суффиксные массивы.
Суффиксные массивы.
Это значит, надо еще и суффиксные массивы строить.
Ой, ой, ой, ой, ой.
Ну ладно. Оставим насладенько.
Вот.
Да.
Что тогда? Чтите, не привычно, что мы обсудили суффиксные автоматы
и не обсудили суффиксные массивы.
Как-то так.
Это так еще никогда не было, на самом деле.
Ну, логично, потому что суффиксные автоматы обычно проще.
А, ну нет.
Дерево полиндромов это не суффиксные триады.
Ну, то есть как бы дерево полиндромов,
оно все-таки решало конкретную задачу про полиндромы.
Вот.
Ладно. Мы сейчас попробуем решить...
Значит, так откатываемся.
Мы снова пытаемся решить задачу вида дан
какой-то текст, какая-то строка С.
И мы хотим искать быстро в ней подстроки.
Ну, хотя бы понимать там,
дана строка П, и желательно О от П понять,
является ли у нас это П подстрокой строки С.
Значит, сейчас мы пойдем другим путем.
Немножко.
Хотя начало такое же.
Вот, допустим, у нас там есть опять наша любимая строка Аббатсаба.
Вот, возникает вопрос.
Предположим, что мы говорим,
что на предподсчет можем потратить сколько угодно времени.
Вот.
Но зато потом мы хотим, чтобы для каждой строки П
мы отвечали на запрос быстро.
Тогда, как бы, если забыть о всех этих автоматах,
то какой самый тупой способ это сделать?
Просто построить БОР из всех подстрок, правда?
Вот.
Вот просто самый тупой способ.
Ну, потому что, да,
у нас же есть у нас есть структура данных
какой-нибудь
то есть какая-нибудь структура данных сет строчек,
то она обычно реализуется через БОР.
Вот.
Аббатсаба.
Вот.
Ну, можно тут даже...
Вот.
И, по идее, вот БОР будет выглядеть вот примерно
вот таким образом.
А, ну вот внезапно и все,
только я должен пару крестиков еще нарисовать.
Хотя можно крестики и нарисовать.
Да, предпределена задача
только подстройки в строке искать,
в общем-то крестики не обязательно.
Вот.
За какой всем точку можем построить такой БОР?
Ну, очевидно, за квадрат.
Да.
Вот, буквально за квадрат,
и получается квадрат предподсчета,
и после этого ответ на каждую строку П от П.
Но квадрат, конечно, нас
ни по памяти, ни по времени не устраивает.
Но, уже глядя на эту картинку,
понимаю, что вообще, на самом деле,
вот эту штуку можно немножко
экономнее хранить.
Потому что, смотрите, какая ситуация.
Заметим, что у нас что-то в этом графе
подозрительно мало развилок.
Видно, да?
Но, с другой стороны,
заметим, что между развилками
путь идет однозначно,
и этот путь обязательно соответствует какой-то
подстроке стратеез, правда?
Да, ну, не обязательно суффиксу.
Ну, правда, если идет в лист, то это, конечно, суффикс,
но, в принципе, тут может быть и вот
до развилки и не обязательно суффикс.
Хотя...
Тогда возникает следующая идея, да?
То есть, как бы, чтобы мы же
тогда давайте мысленно иметь в виду,
что у нас эти состояния имеют
место быть,
но в реальности мы их хранить не будем.
Вместо этого
мы будем
делать так.
Мы, значит, каждый такой
путь сожмем в единое ребро,
на котором
мы будем писать,
что на самом деле оно соответствует
цепочке из каких-то
состояний.
Ну вот, по ним можно переходить
по каким-то буквам, и эти буквы образуют
подстроку стратеез.
Ну вот, и мы будем записывать,
какую конкретно, кстати, очень удобно
оказывается записывать в виде полуинтервалов.
Вот.
Вот.
Вот так пишу.
Вот.
Получается вот такая штука.
Ну, если вы хотите хранить крестик, то там...
Ну ладно, давайте,
если вот, чтобы совсем
убедительнее было, если не хранить крестик,
то получается вот так.
Вот такая красота.
То есть, видите, количество...
То есть, видите, вместо квадрата
что-то размер какой-то стал минималистичен.
Вот, конкретно для аббатсабы количество
ребер оказалось даже меньше, чем
длина самой строки.
Вот. Но это, конечно, не обязательно.
Теперь у тебя есть какой-то вопрос.
А насколько много
может быть... Вот эта штука называется
прям вот официальное определение
сжатый суффиксный бор.
Или суффиксное дерево.
Вот.
Ну, а это просто называется
суффиксный бор.
То есть, просто определение суффиксное дерево
это сжатый суффиксный бор.
Вот, а дальше уже начинается.
Сжатый суффиксный бор это суффиксный бор,
который сжали.
Сжали это...
Ну, вы поняли.
Вот.
Теперь у нас есть какой-то вопрос.
Вот сколько может быть
вершины ребер в таком суффиксном дереве?
Вот когда мы видим, что
вершины возникают только вот тогда,
когда нужна реальная развилка.
А почему?
Ну, у нас развилок не больше,
чем суффикс.
Ну, по сути, да.
Можно и так сказать.
Да, более точно звучит так.
То есть, на самом деле, давайте
построим это суффиксное дерево
но немножко по-другому.
Я сейчас буду просто
заведу просто коинь
и буду добавлять суффиксы по очереди.
Делать я это буду так.
Добавлю суффикс аббацаба.
У меня тут появится переход
по букве А и ноль С.
Вот.
Сейчас я буду тут черненьким
писать.
Сейчас я...
Ну, на самом деле, то есть, это ребро
соответствует, то есть, только первая
буква, буква А, а на самом деле тут целая
цепочка.
Вот. Но как бы понятно, что
корневая вершина по-любому
является типа развилкой, да, поэтому
без вариантов. Вот.
Теперь, но я вот здесь
написал черным то, что мы в явном виде
не храним, но подразумевается,
что оно на этом есть.
Теперь давайте добавим строчку
аббацаба.
Ну, здесь все просто.
Как бы здесь заметим,
что мы уже из корня должны идти куда-то
в другую сторону, поэтому вот
берем В, там пишем
тут соответственно от сколько там?
От 1,7 на этот раз.
И здесь
пишем аббацаба.
Вот.
Дальше происходит интересная вещь.
Мы добавляем суффикс аббацаба.
Но если бы мы его добавляли в обычный
борт, то мы бы должны были пройти
по букве А,
а потом идти куда-то.
Для того, чтобы это сделать, нам
пришло время провести
операцию распилить
ребро.
В общем, действительно, да, английский
язык, он как бы беднее
русского языка. Потому что как будет
по-английски распилить ребро?
Ну, скорее
сплит.
Нет, кат это ребро отрезать.
Кстати, вот и да,
проголила сейфер со смешной вопрос.
У нас была задача распилить строчку
на W1, W2.
Так вот, как вы думаете?
Как в английской,
какое слово в английской статье в этом месте
возникало?
Нет.
Нет.
Там какое-то странное,
редкое слово, которое используется.
Да нет, нет, вы это слово
почти наверное знаете, но
возможно не ожидаете, что оно будет использовано здесь.
Break, separate.
О, не, не, не.
Не.
Да, вы упадете.
Внезапно, да?
Да, то есть там
Лемма там формирует
There is a path W equal to
this.
Нормально.
Ну вот.
Вот.
Ну это так такое
лирическое отступление, это которое мы может быть дойдем еще.
Ой, господи.
Ну ладно.
Я, в принципе, не знаю,
что это такое.
Ну ладно.
Ну можем, кстати, дойти,
потому что как вы выяснили, что скорее всего
видимо в следующий раз все равно придется строчки обсуждать.
А то я уже думал, что
ой, в следующий раз придется геометрию уже
говорить.
Вы, наверное, ничего про меня не хотели же сказать, кроме
сувиксовать дерево?
Ну смотрите, нет, логика такая.
По идее, я вам должен
рисовать сувиксное дерево и суфмасс, ну куда без этого, да?
Значит, также хочется
рисовать галилосейфереса, дальше
у меня все-таки мечта рассказать вам
дерево тандемных повторов все-таки.
Да, пока это,
честно скажу, пока это мечта.
Потому что я тоже скажу так,
пока я только начал вот это стучать.
Каждый год
есть что-то новое?
Ну конечно, ну.
Ну как? Ну не могу сказать,
что я эту фишку позаимствовал у Райгора, если честно.
Ну как бы.
Но если Райгор так же делает,
то значит хорошо.
Ну хорошо.
Вот.
Ну а что делать?
А то как-то это.
А то знаете, если я буду
из года в рот рассказывать буквально одно и то же,
ко мне в какой-то момент все на паре перестанут ходить.
Почему? Потому что на самом деле
в видео на ютубе это все уже есть.
И я даже
больше скажу, скорее всего там люди могут
быть там, то есть
скажем так, как выясняется, некоторые в школе
начинают эти лекции слушать.
То есть знаете, мне было очень приятно, когда
пришел мой 11 классик, но я рассказывал эту историю.
Там говорил
знаете, ну вот у вас там ошибка.
Почему? Знаете, я вот Волкаша
мне попросили рассказать лекцию про Гомариху.
Ну вот.
Я готовился по лекции, используя ваше видео.
Так вот у вас там ошибка.
Так что осторожно.
Там может быть ошибка.
Вот.
Нет, ну мы там разбрались какая, то есть там
были ошибка уровня, что кое-что недостаточно
четко там проговорили доказательства.
Там где-то в конце, но не важно.
Давай.
Так вот, ладно.
Значит, тут мы что делаем?
Значит, в данном случае посплитили
репрошены, посплитили. Это означает, что
тут у нас теперь 1,7, тут 0,1.
Тут
переход по букве A, тут переход по букве
B, а тут переход по букве C.
И тут под строка
3,7.
И дальше пишем
цаба.
Так, теперь добавляем собственно
цабу, ну здесь все гораздо
проще.
3,7, имею в виду
цабу.
А это, ну это зависит от того, надо вам это делать
или нет. Часто этого, кстати,
в большинстве задач этого, кстати, даже не надо делать.
Хотя, нет, если есть
то есть так, обычно этого специально
не делают. Ну, во-первых, это
будет как бы немножко портить
алгоритм, который мы в будущем
будем построим. А во-вторых,
если вам очень хочется это сделать,
то есть мистический
да, то метод
называется метод диезика.
То есть допишем просто какой-нибудь диезик,
который там заведомо не встречается
в этой строке, желательно чтобы он был еще и меньше.
Там по некоторым причинам.
И тогда у вас собственно
все суффиксы будут заканчиваться в листах.
Так что само по себе
это не принципиально.
Вот, да, диезик.
Ну, как бы.
Если вы больше, да, ну можно, а вы сейчас
еще кто-то приписывает доллар, но я диезик люблю
больше. Вот.
Лучший диезик, да.
Нет, хотя по-разному. У кого-то диезик, конечно,
с решетки ассоциируется, но это уже...
Ну, как сказать, что
как лучше звучит решетка или диезик?
А то просто решетка
это что-то про тюрьму, а диезик это что-то про музыку.
В смысле, про тюрьму и решетка это
типа про бумы всякие.
Ах, ах, да.
А, ну если у вас такие ассоциации, ну тогда...
Прямо сейчас какая-то чья ассоциация?
А, ну да, да, да, вот, правильно, все, да.
Как-то, а вы о чем подумали, да, да, да, понятно.
Ладно.
Суть, в общем-то, одна.
То есть обычно, если тут, ну можно
финальные вершины поставить и сделать тут еще пару сплитов?
Можно не делать.
Но обычно этого...
Обычно не делают.
Но что я тут хотел этим показать?
Я этим хотел показать следующее, что
добавление каждого нового суффикса
добавляет вам максимум
один лист, потому что если повезет, не добавит
ничего, если у вас
уровень среднего везения добавит
только одно ребро и один лист,
ну там, ответвление от корня,
ну или могло быть еще, например, что
прямо отсюда ответвление произошло
от уже существующей вершины.
Или если вам совсем-совсем не повезло,
то вы тут подсплитили
ребро, значит, на нем появилась новая вершина,
от которой появилось новое ребро и лист.
То есть, в переводе говоря,
на каждом шаге появляется не более
чем две новые вершины.
Кстати, если у нас
окажется...
Ну вот. То есть, в принципе, уже
вывод, на самом деле, простой.
Количество вершин в суффиксном
дереве не более чем 2n.
Ну не совсем 2n, формально 2n
плюс один, конечно.
Потому что у вас для пустой строти одна вершина.
Да, но заметим, что
после добавления одной буквы у вас будет две вершины
и одно ребро по-любому.
Вот.
Да, вот. Поэтому получается
2n,
2 вершины и 2n минус одно
ребро. Ну правда,
в данном случае достаточно просто привести пример,
когда эта оценка
будет достигнута.
Ну, кстати, да. Причем практически в любую
строчку, да.
Да, то есть, в принципе,
можно сюда дописать... Да. Вот, кстати,
даже давайте внимательно посмотрим, что
происходит.
Чего?
Ну, давайте так.
Нет, смотрите, просто
идея такая. Давайте предположим, что у нас тут был диезик.
Чтоб поменялось.
Ну, кроме того, что мы тут храним,
должны хранить не 7, а 8.
Вот.
Так, вот тут... Ну, давайте
я вот сейчас сразу дорисую. То есть,
если мы добавляли
все суффиксы
датсабы включительно, да,
то мы можем заметить, что получится
что-то подобного рода, правда?
Такой, только тут не восьмерчик, а конечно же
единичка.
Вот.
Теперь мы хотим добавить...
То есть, раньше мы говорили, что мы хотим
добавить АБУ, но она уже есть, поэтому не
заморачиваемся. Но теперь
тут получается
строка 3,8.
А тут 7,8.
Вот.
Это мой АБА диезик.
Так, значит, такой же
сплит нас ждет, когда мы будем добавлять
БА диезик.
Вот. Тут тоже переход
по диезику.
Вот.
Вот.
Вот.
Вот.
Вот. Тут тоже переход по диезику.
И 7,8.
Значит, тут под строка
тоже 3,8. Тут становится
1,3. И тут переход по символу
Ц, кстати, я тут забыл тоже написать.
Вот.
Ну и так, что мы еще делаем?
А, ну конкретно здесь, кстати, нам повезло
новой вершины мы и создадим, потому что здесь
просто у этой вершины появилось третье ребро.
Да, да, да.
Да.
Да.
Да.
Ну, ладно.
Не могу с Лютой, если честно, гарантировать.
Мне кажется, что нам...
Хотя...
В тот момент, когда мы дойдем до другого символа,
отличного ТА, у нас просто из корня
выведется еще одно ребро.
Ну,
здесь это тоже происходит.
Ну, в плане, когда у нас вывелось одно ребро,
у нас добавилась одна вершина Льви.
Ну, это да.
Ну, допустим. Хорошо.
Ладно.
Да, можно утверждать...
Ну да. Хорошо, ладно, действительно.
Да, как выяснилось, у нас тут
два вершин, у нас будет только если строка
состоит из одного и того же символа.
Ну, плюс в конце другой.
Так, ладно. Слушайте, а есть кто живой
вообще?
Нет, мы тут просто активно общаемся с Мишей,
а все как-то мрачно сидят.
Это называется... Мы обсуждаем вещи, которые
там называют всем, кроме нас, Мишей
очевидны. Вот, я не знаю.
Или...
Или на самом деле все выпали уже там на третьей минуте
обсуждения.
Нет, просто непонятно с какой целью.
Нет, ну пока мы... Ну, цель
очень проста. Может быть, пока
чуть-чуть поиграться с деревом и понять, как оно
устроено.
Вот.
То есть да, скорее не цель,
скорее путь, да. То есть может быть даже
скорее путь. То есть у нас нет какой-то цели доказать
фактического утверждения.
Но тут больше речь идет, да,
скорее о пути.
Это да.
Вот.
Так вот.
Ну, значит, так мы объяли, что в принципе
сжатый суффиксный борт вполне себе линейная структура данных
и очень-очень-очень-очень
бы хотелось научиться его
строить за линейное время.
И...
Как это сделать?
Да, любители халява скажут, ну что, давайте
построим суффиксный автомат и по нему DFS запустим.
Вот.
Но это будет такой нот.
Но будет одна маленькая проблема. У этого решения
сразу скажу. Потому что в принципе
такое решение может иметь место, более
скажем так. По идее есть практически mia
хорошие решения построить по
суффиксному автомату суффиксное дерево.
Есть тоже решения построить по суффиксному
массиву и массиву LCC.
Да.
Оба chang guardiola раз.
Но, эти решения будут для нас иметь один маленький
недостаток.
Недостаток будет называться...
То есть для этого вам нужна дана фиксированная
строка, вы построили фиксированный структуру данных,
а потом по ней построили фиксированный
суффиксное дерево.
не онлайн. Да, вот не совсем онлайн. У нас у суффиксного автомата было, а до него и у дерева полиндромов, был такой прикол, что мы добавляли в строку s по одному символу и модифицировали текущую структуру данных, но в каждый момент времени по модулю каких-то допущений это была уже корректная структура данных, правда?
Ну а по суфф автомату он не будет так устроен?
Что с суффиксным автоматом?
Так что сейчас мы просто придумаем достаточно простой алгоритм. Да, он простой, алгоритм Украина простой, считается.
Знаете, на самом деле так, если знать все секреты, то фокус действительно не очень сложный. То есть код тоже действительно не самый страшный.
То есть в него просто, может быть, один раз надо въехать, но там все нормально. Вот такая код. Нет, он просто считается, потому что на самом деле, честно скажем, что алгоритмов построения суффиксного дерева напрямую много, на самом деле, линейных.
То есть алгоритм Украина, по-моему, алгоритм едва ли не 94-го года, далеко не самый первый. То есть до него там были алгоритм Вайнера, алгоритм МакРейта, может быть, какой-то из них в каких-нибудь ЛКШ вам даже рассказывали.
Нет, он нам просто Капилевич пытался рассказывать когда-то там в далеком 2008-м, но у него не получилось. Ну, точнее так, у него там может и получилось, но этого никто не понял.
Вот потом пришел Станкевич, рассказал Уконина и количество акцептов увеличилось на 10. Вот. А, ну я это уже рассказывал. Уконин считается в этом смысле одним из самых простых.
То есть так, глобально он, конечно, да, может быть, будет немножко там каким-то взрывомозговым немножко алгоритмом, но тем не менее разобраться можно, потому что давайте внимательно будем смотреть.
А суффик там отчитается с лёгкими алгоритмами?
Да. Нет, он, конечно, существенно проще будет суффиксного дерева, хотя делать они будут очень похуже.
Это без шансов.
Ну, нет, как сказать, сам по себе алгоритм на уровне кода, в общем-то, простой.
В плане, чтобы въехать в алгоритм в устроение суффик-томата нужно умереть?
Нет. Нет. Ну, как сказать, если бы я поставил себе цель просто рассказать заклинание, которое там делается, то я бы его рассказал быстро, вы бы его поняли.
Ну потому что там заклинание звучит так. Мы в каждой вершине храним лены, храним суффиксную ссылку.
Даже я примерно могу описать, что оно значит.
А дальше так, скачем по суффиксной ссылке, дорисовываем ребра, которые ребро нашли, говорим PQ.
Если тут лен от P плюс 1 равно лен от Q, то значит просто замыкаем суффиксную ссылку и не паримся.
В противном случае делаем клона и там перевешиваем суффиксные ссылки.
Там всё. То есть более того, для этого заклинания даже легко доказать, что оно работает за линию.
Но сильно более нелегко доказать, что это вообще работает.
То есть в суффиксном автомате будет гораздо сложнее понять доказательства алгоритма.
Здесь доказательство будет сильно проще.
А тут магии на самом деле не будет.
То есть там такой может быть сложный по написанию алгоритм, но выжить можно.
Ну если бы геома, то любая геома.
Нууууу, по-разному, да.
Ну там разные геомы случаются, конечно.
Вот, ну ладно, смотрите.
А то доживём мы с вами такой диаграммы Воронова.
Ну посмотрим, что там будет, да.
Вот, значит, смотрите.
Внимание.
Значит, смотрите, так, как я уже сказал.
Так, кстати, не пришло ли нам время перерыва-то вообще?
Ой, а Миша, почему пришло?
Смотрите, значит, как мы хотим строить суффиксное дерево.
Как я уже сказал.
Мы хотим хранить строчку и в некотором смысле хранить нот.
И суффиксное дерево.
В каком-то виде.
Ой, ребят, лучше вылезайте с телефончиков.
Тут сублимация суперега начнёт, чтобы было достаточно быстро.
О господи.
Не надо ругаться такими словами.
Короче, у нас свои есть.
Вот, значит, смотрите.
Итак, мы хотим брать строчку и приписывать к ней по одному символу.
Да?
То есть мы хотим приписывать по одному символу.
Вот, допустим, будет у меня там какая-нибудь строка обаца-баба.
Вот, я хочу приписывать по одному символу и смотреть, как меняется суффиксное дерево.
Потому что алгоритм у меня в перспективе будет, что для каждой строки я храню суффиксную ссылку по модулю некоторых допущений.
Но давайте сейчас я буду делать это в тупую.
Вот, мечта строка такая.
Пока строка пустая.
Как она будет выглядеть?
Да, тупо, вершина.
И ещё я буду для удобства...
Так, а есть ли у меня тут красный маркер?
О, у меня есть красный маркер.
Во, ура, у меня есть красный маркер.
Ура.
А, стоп, погодите.
Так, у меня же...
Погодите, я же...
У меня же есть рыжий маркер.
Вот.
Ну, посмотрим, поможет ли он нам.
Но я просто люблю эту штуку рыжим маркером рисовать, как-то привычнее.
Значит, смотрите.
Я буду сюда вот...
Пишем вот рыжий маркер,
который говорит нам в том, что суффикс номер ноль заканчивается здесь.
Это нам в некотором смысле будет удобно хранить.
Ну, как бы понятно, суффикс номер ноль,
это как бы суффикс, который начинается символу номер ноль.
Напоминаю в нашей терминологии.
Вот, такая договорённость у нас поет.
Итак.
Приписываем символ А.
По идее, что должно произойти в обычном суффиксном боре?
Вот, не вжатом.
Я, по идее, из каждого суффикса
должен добавить переход по букве А, правда?
Или пройти по нему, если он есть?
В нашем случае получится следующее.
То есть я добавлю переход по букве А,
скажу, что здесь вон
ребрышка по 0,1
и тут у меня будет возникать
такая буква А.
Вот.
И теперь я скажу.
Давайте возьмём тряпочку.
О, Сева пришёл.
Вот.
Сева саму коня? Да ладно.
Ой.
Ну да, да, да.
Как говорится, других сокоманников
звали, видимо, Фурье и Тарьян.
Да, да, да.
Интересно, да.
Собрались как-то
Фурье, Уканин
и Тарьян и образовали команду
СПС. Интересно, да. Какое они место будут
в опенкапах занимать?
А, ну ладно, потом выяснилось, что Фурье
умер, поэтому они...
Поэтому
Тарьян позвал
своего старого друга. Нет.
Называется Дэнила Слейтера.
Но они с ним хорошо структуры данных
обсуждают.
Прикольно.
Ну да, да, да.
Против них вышли четыре русских, да.
Да, они заявили,
что, знаете, в старом СПС в команде было
четыре человека, так что идите лесом, да.
А у китайцев недобор?
У китайцев? Ну почему? Пришли ли
Чао там со своими структурами?
А, это Гомориху ещё пришли
там эти все. То есть там, ой, там такой
чемпионат начнётся.
Два.
Гомори и... Ну вы поняли.
Вот.
Ладно, так вот.
Дописываем букву Б.
Дописываем букву Б.
Тогда, значит,
вот отсюда мы должны перейти по букве
Б. Но как мы это сделаем? Так как мы находимся
в листе, то самое тупое,
что мы можем сделать,
это вместо вот этой единички написать
двоечку. И мысленно,
уже на этот раз мысленно
написать здесь символ Б.
Так, ну
ещё, конечно же, нам надо отсюда
вход по букве Б забабахать. Давайте его забабахаем.
Будет буква...
Чего? Почему ё-моё? Пока
вроде всё адекватненько.
Вот.
То есть как бы мы делаем
много технических действий, но
сами по себе они не страшны.
То есть вот.
Чего?
Вот. А пока... А мы не будем общать,
мы будем оптимизировать вот это.
То есть видите, я пока храню, так делаю
очень тупой алгоритм.
То есть я просто храню текущие суффиксные
дерева прям в том виде, в котором оно должно быть.
Ну единственное, только я там
лишних вот этих вот терминальных
вершин не храню. Ну понятно, что
если мне придёт приказ, что строка закончится,
я вот в тех местах, куда эти стрелочки
указывают, я поставлю вершинки.
Кстати, вот о чём я говорю,
сейчас мы увидим на примере буквы А.
Так, ну начнём с того, что, смотрите,
если у вас вот стрелочка показывает
в лист, то заметим, что она всегда будет
теперь указывать в этот лист, правда?
То есть может быть вот это ребро будет подпиливаться,
конечно, но по большому счёту, чтобы
там добавить эту букву, нам просто тут
вместо двоечки
на указывающем ребре,
сюда придётся написать троечку.
Я буду это делать.
Вот.
Вот, значит тут я пишу А,
тут я пишу А. А вот с двоечкой
интереснее, потому что на этот раз переход
по символу А уже есть.
И смотрите, как мы это будем делать.
То есть смотрите, мы будем подразумевать,
что, по идее, суффикс может заканчиваться
даже не просто не в листе, но и не в вершине.
Вот. То есть видите,
я пока здесь ничего не создаю.
То есть, боже упаси.
То есть просто двое нот.
То есть у меня будет такое понятие, забирая
вперёд ноты, что у нас всё будет реализоваться.
Тетчет хет.
Чао?
Вас издас.
Ну типа, у детей, если там
конит не в конец
поставить, а просто
в смысле хет поставить на рандомный
комит, то
не набраешь.
Нет, ну пойх... Ой, ну
это сложно для меня.
Нет, я понимаю,
у вас да, но у нас, знаете, я учился в далёком
2009, у нас даже у КТЧ не было.
Так что, как бы, поедете.
Так что, как бы, мои знания по сравнению с вашими,
как бы, знаете, там вот,
слушайте, знаете, вот у Вазика
Азимова вот рассказ такой есть, знаете.
Когда-то, то есть
то есть утверждаете, что когда-то в будущем
возможно люди перестанут ходить в школы.
Потому что когда им просто исполнится
восемнадцать, они просто соответственно
будут приходить, им просто будут
там автомат, там какой-то компьютер будет
просто определять их лучшие способности
и просто вкладывать им в голову лучше
знания.
Не помню, как называется, но вот
не сталкивались с таким рассказом?
Нет. А вот есть там шикарный
рассказ. А что они будут делать до восемнадцати?
Нет, ну не помню,
ну там что-то будут
делать. Можешь какие-то моральные вещи
обсуждать или что-то ещё.
Ну вот, а профессию, нет, а профессию
прям вот... Ну вот.
Нет, профессии, да.
Нет, ну там, правда, там такое, там
там прикол в том, что профессию
вам сразу дадут, все они мечтают.
Правда, потом выяснили, что
следующему поколению профессию дадут
лучше, потому что профессия
всё-таки развивается. Но там, собственно, история
парня, которого вместо того, чтобы дать ему
крутую профессию, отправили в какой-то
специнтернат.
Нет, ну там, я не помню, как конкретно,
он там что-то,
он сбунтовался против системы,
он куда-то там сбежал, потом
его поймали, сказали, ой, молодец, ты прошёл
испытание. А в чём прикол?
А прикол в следующем, понимаешь, мы, конечно, можем вложить знания,
но кто-то их должен продвигать.
Так вот, на самом деле, там только где-то максимум
1% вообще населения Земли может
реально что-то придумывать новое.
Так вот, поздравляю, ты один из этих процентов.
Но маленькая проблема, что вот тебе
придётся учиться по старинке.
Нет, нет,
нет, на этом рассказ уже заканчивается.
Нет, есть книга про рог
из Жвалиевского по странах.
Там очень прикольный концепция,
но там есть часть того,
что ты делаешь.
Вот, так что там,
вот, так вот, значит,
тут у нас пока хреним, так?
А теперь буква С.
Да, ну да, да, да.
Значит, что мы делаем с буквой С?
Ой, хотя это страшно, да.
Как это говорят, обратно, да, как-то
тёмная сторона, поле чудес обратное, да.
Где-то в подвале, значит,
как говорится, там
два телохрани, там два телохрани,
то есть два бандита там привязали
какого-то там игрока.
Ну, а там приходит такой Якубович,
значит, и так начинает ему бить руками
просто огурцом, крича
«Кто тебе подсказал
букву С!»
Очень страшно
выглядело.
Там никто не подсказывал, я сам догадался,
кто тебе подсказал.
Вот так.
Вот, значит, так.
Теперь, смотрите, пришло время
прийти по букве С,
здесь нельзя.
Вот, поэтому мы тут создаём
новое ребро, вот на этот раз
пилим вершину,
то есть пилим мы ребро,
вершину-то мы не пилим.
Вот, значит, тут мы
пишем, что тут переход по букве Б,
тут переход по букве С,
тут буква С,
тут, соответственно, сами понимаете,
что?
Там три-четыре получается,
вот, и двоечка
так жественно отправляется
в лист.
Нет, вот, смотри, ну вот.
Так, теперь троечка.
Ну, троечка,
для троечки мы тут создаём новое ребро,
три-четыре,
вот, и троечка тоже отправляется
вот сюда.
Ну, вот, ну, а здесь
образуется новое четвертик.
Вот.
Так,
тут что? То есть, видите, смотрите,
что мы на каждом шаге делаем?
Мы делаем следующее, что,
то есть, видите, мы, получается, у нас есть несколько
рыжих указателей,
и мы эти рыжие указатели куда-то
продвигаем по очередному символу,
или если они находятся в листе,
то просто дописываем,
то есть, увеличиваем на единичку,
под строку соответствующего концу ребра.
Видите, да?
Видно, да?
Так вот, давайте объявляю первую оптимизацию,
которая может пока показаться
неосимпатической, но в будущем она сырает.
Ну, пока всё делаем так.
Да.
Ну, теперь, смотрите, давайте первую оптимизацию, которую мы сделаем,
просто вот, пока неосимпатическая.
А давайте вот эту вот чиселку,
вот эту вот четверку,
переписывать никогда не будем.
Значит, первая оптимизация говорит,
кстати,
да, кстати, на тему скорости обсуждения.
А кто вообще когда-нибудь писал Уканина вообще?
Да ладно.
А нафиг он нужен?
Ну, мало ли.
Ну, как-то, знаете,
такие продвинутые люди, как вы, как-то обычно
где-нибудь Уканина дописали когда-нибудь.
Ну, мне вот
после сессии в первом
смеси стало скучно, и я начал писать
Белонет. Ну, точнее Бронова.
Короче, алгоритм форчена.
Вот.
Так, ну вот, официальное
объявление такое.
Я знаю, что когда у меня ребро
ведёт в лист, там по-любому будет в конце стоять число,
равное длине строки.
Так вот у меня сразу
идея на будущее. Я буду обозначать
это символом бесконечность.
То есть обозначать, что в каждый момент времени это просто
текущая длина строки С.
Что это мне даёт?
Это мне даёт возможность
на самом деле лишние символы
не перебирать.
Видите, да?
То есть на самом деле обратите внимание,
потому что, как вы уже могли заметить,
если у меня какой-то суффикс
стал заканчиваться в листе,
то он в этом листе будет заканчиваться
теперь всегда.
То есть, да, путь до него будет
всё время удлиняться, да, тут будет куча
ответвлений появляться со временем,
но сама вершина не изменится.
Вот.
Но можно заметить
ещё маленькое приятное
свойство,
которое в будущем тоже
сыграет.
Смотрите, вот случайно,
вот у нас сейчас есть суффикс от 0 до 4.
Смотрите, заканчиваются в листах
0, 1, 2 и 3,
а 4 не заканчивается.
Да?
Ну ладно, пока ещё не самое показательное свойство.
Но давайте добавим
ещё пару символов.
Сейчас я добавлю букву А.
Смотрите,
то есть, заметим, что
суффиксы с 0 по 3 я в принципе уже не трогаю.
Всё, они мне не интересны, я уже начинаю
перебор с 4.
И 4
действительно,
то есть, 4 теперь просто отправляется сюда,
а здесь у меня появляется 5.
Но обратите внимание, ничего не поменялось.
То есть, дерево само по себе
не поменялось. Видите, да?
Вот.
Что дальше?
B.
Где у вас тут будет D?
Буква B.
Буква B говорит там, что у нас
значит тут вот 4
отправляется сюда,
5 отправляется
вот сюда,
и 6
появляется здесь.
Дальше.
Буква A.
Вот. Ну и здесь
4 я даже перерисовывать не буду,
я по стрелочку вот сюда направлю.
4 направляется сюда,
здесь тоже всё просто,
вот сюда, значит
6 теперь отправляется вот сюда,
и 7 вот здесь.
Теперь буква
B.
Теперь.
Так. Ура!
Из 4 перехода по букве B нет,
придётся делать сплит в этом месте.
Сплит получается делим так.
Отсплитчиваем тут 2 символа,
поэтому тут получается 1, 3,
тут 3 бесконечности.
И сюда
отправляется переход по букве B.
То есть так пишем
сразу от семёрки до бесконечности.
И тут у нас буква
B.
Здесь она типа подразумевается.
Ой, а я тут везде забыл писать,
потому что тут-то везде уже давно
подразумевается A, B, A, B.
И тут
A, B.
И тут C, A, B, A, B.
Вот.
Да, на самом деле.
То есть так чёрные, видите,
чёрные это удлиняются, но синие
от этого не трогаются.
И куча рыжих тоже.
Значит, 7 бесконечность,
и 4 находят
своё вечное пристанище.
Такой
свой вечный
причал.
Вот.
Так, далее что у нас?
Дальше у нас
отправляемся
в пятый суффикс.
Видим, что тут тоже приходится
чуть-чуть попилить.
Тут буква B, тут буква C.
Тут буква B, тут тоже буква C.
Так, здесь у нас тоже
7 плюс бесконечность.
И, значит, соответственно,
да, вот этого ребра.
Значит, 1 бесконечность больше нет.
Есть теперь 2 ребра. 1, 3.
3 бесконечности. В общем, такая
равность.
И пятачок тоже
отправляется в свой домик.
Вот.
А вот шестёрочка
и отправляется, потому что тут переход
по букве B внезапно есть.
Вот.
И семёрчика есть.
Ну, и восьмёрчика.
Ну, давайте уж,
чтобы закончить работу, давайте
по букве A сделаем, но тут по букве A
ничего не поменяется, потому что
отправляется в эту вершину.
Там шестёрочка, кстати, тоже
в вершину отправляется. Восьмёрчика
отправляется в вершину.
И девяточка.
Но смотрите,
как интересно получается.
По мистическим причинам,
смотрите, вот обнаруживается, что
суффиксы с нуля, с нулевого
по пятого заканчиваются в листах,
а все остальные заканчиваются не в листах.
И вообще
всегда у нас так было, что если смотреть
суффиксы с нулевого по n, то
до какого-то момента они начинаются
в листах, а потом находится первый
суффикс, который начинается не в листе,
и начиная с этого момента, все
суффиксы почему-то заканчиваются
не в листе.
Внимание, вопрос. Это мы...
Это я такую удачную строку взял?
Да.
Или так будет всегда?
Еще раз как?
Утвержение такое,
я хочу понять,
я вот задумываюсь,
у меня есть набор суффиксов
с нулевого до n,
мне хочется брать, какие из них
заканчиваются в листе, какие не в листе.
Так вот, утверждение.
Почему-то так всегда получается, что
в этом списке сначала идут
суффиксы, которые
заканчиваются не в листе,
вот в нашем случае до пятого,
и там является вот шестой
суффикс, который заканчивается не в листе,
и все последующие, почему-то
тоже заканчиваются не в листе.
Э false??
На самом деле, да.
Во-первых, маленькое утверждение.
Под строка в суффиксном дереве
заканчиваются в листе,
когда и только тогда, когда она
а), является суффиксом
В других вхождений, кроме суффикса, у нее нету.
Вроде мысль логичная, да, мысль предельно логичная.
Но тогда заметим следующее, что подстрока не заканчивается в листе тогда и только тогда,
когда у нее есть вхождение в строку, которая не является суффиксом.
Понятно, да?
Ну, потому что мы можем дальше продлить.
Ну, типа да.
Так, вот это сейчас вот понятная идея или...
Надо подумать, потому что это, в принципе, если вы сейчас этого не поняли,
то как бы дальше будет там сублимация супер эго.
Вот. Ну, вроде понятно.
Ну, то есть, короче, как мы это доказываем, если она раньше входила,
то мы продлим просто собиус, в котором она входила до конца
и у нас это будет не лист, потому что из нас будет идти что-то еще.
Ну, да.
Вот. А если она раньше не входила, то очевидно это суффикс?
Нет, ну тут даже не раньше больше, а просто пока вот тут усиление.
Допустим, у нас в строке N есть подстрока P.
Утверждается, она не заканчивается в листе тогда и только тогда,
когда у нее есть вхождение, которое лежит не в конце строки S.
Доказательства.
Любая подстрока – это префикс суффикса.
Да.
Да, такое мистическое правило всегда есть, да?
Префикс суффикса.
Но тогда заметим, что...
Ну, вот, то есть, если подстрока, что означает, что она имеет вхождение,
которое не лежит в конце строки?
Это означает, что она является префиксом какого-то суффикса,
который по длине больше.
Да.
То есть, это означает, что если мы в суффиксном дереве идем по этому суффиксу,
то тогда это означает, что мы должны начать с этой строки P,
а потом еще куда-то дальше идти,
но, следовательно, из самой строки P дальше есть куда пойти,
следовательно, это не лист.
Логично, да?
Но и с другой стороны, в чем мы заметим, что этот суффикс,
даже если он суффикс, он сам по себе тоже не обязан идти в лист,
потому что может оказаться, что у этого суффикса есть еще другое вхождение,
с более длинным суффиксом, и тогда оказывается, что это тоже не лист.
Это, как в нашем случае, суффикс ABBA, который, видите,
он сам по себе суффикс, но он заканчивается не в листе,
потому что его есть куда продлить.
Вот есть еще суффикс ABBA, например, или ABBA, ABBA, ABBA, ABBA.
Но теперь маленькая фишечка.
Если какой-то суффикс заканчивается не в листе,
то суффикс можно продлить до большего суффикса,
то все меньшие суффиксы тоже можно продлить до какого-то большего суффикса.
Ну, если какой-то суффикс заканчивается не в листе,
то есть его можно продлить до большего суффикс.
То все меньше его суффиксы тоже можно продлить до больших суффикс.
То есть как бы вот если АБАБА продляется до АБАБА, то и БА продляется как минимум до того же БАБА.
Ну можно и картинку. Ну типа да. Ну просто вот. Ну то есть ситуация такая, давайте действительно
нарисуем в общем случае. Жила была строка С. Допустим у нее был какой-то вот суффикс, у которого было
вхождение где-то еще. То есть его можно было продлить на самом деле вот на вот этот суффикс.
Но тогда рассмотрим, вот у этого суффикса рассмотрим суффикс на единичку меньше. Тогда
заметим, что у него тоже есть как минимум вот это вхождение, которое можно продлить еще вот на это.
То есть это означает, что после того как мы прошли по этому суффиксу, мы еще можем как минимум по этой
строке вниз идти. А может там еще куда-то если повезет, может там еще развилки есть. Вот. То есть вот в
чем идея. То есть отсюда означает, что действительно имеет место утверждение о том, что существует такое
понятие как вот мы его будем называть First Not Leave. First Not Leave. То есть первый не лист.
Это официальное название? Нет, это мое название. А какое официальное? Не знаю. Честно скажу, статью не читал.
Вот. То есть First Not Leave это позиция. Напоминаю, у нас в этом дереве нет вершин. Есть позиции.
Ну такие вершины тоже есть. Но вообще говоря, когда мы проходимся по строке, мы попадаем не в
вершину. Мы попадаем в позицию. То есть мы знаем на каком ребре мы находимся и где конкретно.
То есть если мы попали в вершину, то мы говорим, что мы находимся на ведущем в нею ребре,
просто в самом конце. То есть помните, если вы пройдете сейчас по строке обоца,
вы попадете куда-то вот сюда. Это позиция. Вот. Понятно? Вот. Значит это был First Not Leave. Ну как
был? Он у нас был, есть и будет. Потому что First Not Leave сейчас будет играть у нас ключевую роль в этом вот.
Все. Кстати, если понятно, что это такое, скажите, пожалуйста, к чему сейчас равен First Not Leave?
Ну правильно. 6. Конкретно в данном случае он равен, конечно же, 6. Как мы доказали, что отрезок
вот этих позиций в листах, а потом не в листах? Доказали мы так, что если какой-то суфик заканчивается
не в листе, то и все меньше заканчиваются не в листе. Нет, мы именно так сказали. Что если кто-то
заканчивается не в листе, то отпилив от него несколько символов, мы тоже получим суфикс,
заканчивающийся не в листе. Но тогда и получается, что вообразим себе ситуацию. Ну там нулевой суфикс,
видимо, всегда будет заканчиваться в листе, тут без вариантов. Вот. Идем, идем, идем, и вот
натыкаемся на первый суфикс, который заканчивается не в листе. Чего? Может статьи, да. Вот, кстати,
после строки аббатс, кстати, так и было. Вот. Но тогда, как мы только что доказали, все последующие
тоже будут заканчиваться не в листе. Да. Потому что все последующие суфиксы являются суфиксами
этого суфикса. Да. Все последующие суфиксы являются суфиксами этого суфикса. Ну да,
на скороголовку не тянет, конечно. Вот. Вот. Итак. Так вот. Так вот, у нас только что был алгоритм,
который работает за квадрат. Так вот, сейчас я предложу вам. Так вот, мы, во-первых, делаем
бесконечности, а, во-вторых, сейчас на основе фестнот лифа я сделаю другой алгоритм, который
тоже будет работать за квадрат. Нет, нет, это не тот алгоритм. Вот другой алгоритм. Сейчас. Чего? Ну,
сейчас будет. Ладно, будет так. Так что теперь следующая версия, другую версию, которая будет
приближаться. Теперь у меня следующая идея. Да, оптимизация с бесконечностями остается. Но теперь
у меня идея, что я, ну, не хочу. Вот не хочу я хранить прям все вот эти штуки. Прям, если я буду
хранить в явном виде все эти указатели, то будет больно. Более того, слёту даже кажется, что, если я
даже скажу, что да, я теперь знаю, что я могу хранить фестнот лиф, который у меня только
увеличивается, естественно, да. Ну вот. И могу перебирать только от него до, до n. Но это всё равно
в перспективе квадратненько будет, правда? Поэтому я пойду другим путём. Значит, я, ну вот, то есть я
пойду другим путём. Сейчас я попробую сделать абсолютно то же самое. То есть, ну, по крайней мере,
дерево будет изменяться также, но рыжий указатель я буду хранить только один, на фестнот лиф. Вот.
Сейчас вот всё на ваш, сейчас мы это всё, сейчас будет это чудо на ваших глазах.
Ну да. Наверное. Хотя, как это приду вулуконен, я не знаю. Если честно. Так, это мало ли. Тем более
я вот утверждал, что я буду рассказывать, как рассказывал мне ещё Гольштейн. Но, по-моему,
Гольштейн рассказывал не так. Вот. Но я не помню, как конкретно. То есть, я помню, что он как-то так
рассказал так, что я, по крайней мере, там после часовой лекции я там просто понял всё. То есть,
после этого выяснилось, что я даже могу сесть и на джави это ещё и написать. Да, это неплохо,
учитывая, что я, по-моему, это, по-моему, единственный хоть насколько-то сложный алгоритм,
который я в своей жизни написал на джави. А нет. А нет, не единственный. Я потом ещё писал какие-то
решения. А, потом я ещё писал решения на джави, когда мы там готовили тот контест Петра Заводского.
Вот. Так вот. Ну что, поехали. Итак, first not leave. Начнём с первой буквы. Давайте сразу напишем
вот эту первую букву. Буква А. Тут у нас подстрока от нуля до бесконечности. Тут имеется пока,
ну вот, пока имеется в виду А, потому что у нас пока вот сейчас С равно А сейчас. И, значит,
first not leave у нас сейчас равно 1. И он указывает вот сюда. Видим, да? Вот. Значит,
первая у меня идея такая. Добавляем букву Б. Да, тут мысленно прерисовывается, как всегда,
буква Б. Так, мне не нравится этот маркер. Так. Вот. Вот. Итак, смотрите. Значит,
тут-то приписали, но это неинтересно, потому что что может поменяться с точки зрения этой
штуки? Поменяться может следующее. То есть, это указатель первый, который находится не в листе,
который может что-то поменять. Давайте припишем к нему букву Б. Так, перехода по букве Б нет,
поэтому автоматически здесь у нас объявляется переход по букве Б там 1 плюс бесконечность.
Значит, первый указатель торжественно отправляется сюда. И поэтому в этом месте
first not leave увеличивается на двоечку. Итак, смотрим двоечку. Ну, двоечка это у нас сейчас вот просто
это пустой суффикс, поэтому он просто указывает сюда, пока ничего криминального не происходит.
Теперь приходит буква А. Значит, буква А. Так, а теперь смотрите какая интересная ситуация. На
этот раз переход из first not leave по букве А происходит. И происходит вот сюда. Так вот,
я утверждаю, что дальнейшие суффиксы перебирать не надо. Нет, он-то не в листе,
но фишка в другом. Теперь давайте подумаем, а может ли так, вот хорошо, мы конкретно вот в
этом суффиксе перешли по букве А, то есть переход состоялся, ничего создавать не надо было.
В будущем дереве, конечно, все остальные ребра должны тоже заканчиваться не в листе,
но я хочу доказать немножко другое. Я хочу доказать, что следующие переходы по следующим
ребрам тоже ничего нового не создадут. То есть в плане у нас мог быть рыжий указатель,
который с номером больше, но который ниже, чем он. Но не ниже, а вдруг там выяснилось,
что там перехода в букве А в следующих указателях нету. Почему? Страшно, потому что это означает,
я хочу доказать, что если этот указатель сдвинулся, то дальше ничего перебирать не надо.
Да, это для нас будет потенциально очень круто, потому что это потенциальная линия уже. Но на самом
деле можно показать, что дальше переходы по букве А тоже будут существовать, потому что
доказательство очень простое. Если перехода по букве А в каком-то из следующих указателей нету,
то значит, что следующий указатель перейдет в лист. А такого быть не может. То есть можно
это увидеть и так. Просто это из цикла, когда я делал алгоритм, у меня так получилось. Правда,
выясняется, нельзя ли это увидеть с точки зрения устройства строки. И на самом деле это можно
увидеть. Потому что давайте я нарисую ту же картинку, но в общем виде. В общем виде жила
была у тебя глобальное дерево. Страшное, страшное, страшное, страшное, страшное, страшное, страшное,
страшное. Жил был у тебя какой-то суффикс, который жил может быть здесь, может быть даже на вершине.
Ты попытался, ты добавил к строке букву А, и он возьми и сделай тупо переход. Потому что тут
только с буквы А случайно и была. Или вот из этой вершины переход по букве А тоже и был. Вот.
Тогда я утверждаю следующее, что когда ты будешь брать указатели соответствующим меньшим суффиксам,
там тоже магическим образом переход по букве А всегда будет, и ничего нового ты не создашь.
То есть если у нас был суффикс, из которого есть переход по А. Ну да. По большому счету да,
это означает, что допустим этому указателю соответствовал суффикс П. То есть это означает,
что у нас была строка С, у которой был суффикс П. И тут выяснилось неожиданно, что если приписать к
строке А, то выяснилось, что переход был. Что это вообще означает? Это означает маленькую простую
вещь. Это означает, что буква П уже встречалась ранее, и более того, после какого-то из ее
вхождения шел символ А. То есть строка ПА уже была под строкой строки С. Ну да. Вот. Но если строка
П обладала таким свойством, то если я возьму какой-нибудь суффикс П штрих строки П, то он тоже
будет обладать таким свойством. Правда? Следовательно там из всех меньших суффиксов переходы по строке А
тоже уже будут существовать. То есть получается мистика такая, что если у вас FirstNotLeaf сделал
честный переход и ничего нового не потребовалось создавать, то на этом алгоритм может остановиться.
Более того, даже верно так. То есть может у FirstNotLeaf быть, конечно, более сложная ситуация,
как мы в будущем увидим. Он сделает переход, увеличится. Сделает переход, увеличится. То есть
там что-то создаст новое, увеличится. Создаст новое, увеличится. А потом обнаружит, что где-нибудь там
на пятерочке переход делать уже можно сделать переход без создания чего-то нового. Тогда в этом
месте он тупо сделает этот переход и остановится. Вот. Ну вот. И тогда, слушайте, тогда это уже начинает
напоминать линию. Потому что каждое нетривиальное действие FirstNotLeaf увеличивает его на единичку. А
суммарно он больше чем N стать не может. Правда? Да. Да. Итак, значит, смотрите, пока у нас FirstNotLeaf
равно 2, давайте еще чуть-чуть поэмулируем для понива, просто для ощущения того, что происходит.
Да, тут, конечно, мысленно мы говорим, что тут ABA, тут BA. Вот. Дальше. Буква С. Вот тут показательный
пример. Что происходит? Значит, буква С, значит FirstNotLeaf находится здесь. Он соответствует суффиксу
А, который теперь превратился в суффикс АС. И нам придется его попилить. Попилили. 0,1, 1
бесконечность, без проблем. И отправили букву С сюда. Да, кстати, давайте тут тоже припишем. Тут С,
тут С, тут С, тут 3 на бесконечность. Вот. Красота. Итак, FirstNotLeaf, правда, теперь торжественно
превращается во что? В тройбан. Ну, как всегда, у нас двоечка превращается в тройбан. Классическая
ситуация на фистике. Вот. Вот. Значит, тройбан находится здесь. Находился, по крайней мере, да. И
теперь из него надо перейти по букве С. Из этой вершины нет перехода по букве С. Наша фирма это
учла. Значит, мы его сейчас заведем. Вот. Ну, это уже там, на 1-этажную Америку, да. То есть,
вы поставили будильник, будильник сработал, вы проснулись, и теперь можете приступать к утренней
гимнастике. Люди не любят делать утреннюю гимнастику. Наша фирма это учла. Наш электрический
пояс будет массировать вас самым добросовестным образом. Вам даже ничего не нужно делать. Пять
минут, а у вас уже есть физическая нагрузка. Ну, или какая-то там такая реклама в 30-х годах имела
место. Вот. Итак, буква С. Тройбан отправился сюда, поэтому еще более классическая ситуация на
фистехе. Тройбан превращается в четверку. А у нас все хорошо. А у нас оценка не уменьшается. Как
это часто бывает. Ну, потому что четверка может быть перемещена в пятерку. Нет, у нас, правда,
четверка может быть перемещена в пятерку, но это пока. Пока и сейчас четверка уже тупо в корне,
потому что четверка у нас это уже пустой суффикс. Поэтому мы сейчас по этому остановились. Ну,
что теперь будет? Теперь будет буква А. Так, есть переход по букве А? О, чудо, есть. Так, кстати,
я тут, да, С. Ну, тут все вот эти буквы А я должен нарисовать. Вот. И тогда я вижу, что лежит товарищ,
да, ешкин, перемещается вот сюда. Ой. Хорошо, говорим, мэм. Вот. Да. Ну, понятно, пятый суффикс
тоже был. Но замечаем дальше, что пока это фестнослив делает переходы, больше вообще суффиксное
дерево не меняется. То есть мы просто идем, идем, идем, идем, идем, идем. То есть, вот, давайте я
сразу два шара пропущу. Вот мы идем БА, и мы обнаружим, что рыжий указатель идет сначала сюда,
потом сюда. И, в общем-то, больше пока ничего не поменяется. Ну, вот. Ну, то есть мысленно,
конечно, поменяется. То есть на всех ребрах с бесконечностями мысленно появятся вот эти БА,
но я напоминаю это все мысленно. Вот. И вот наконец появилась буква Б. Буква Б появляется.
Вот. Ну, значит, тут перехода по букве Б, Б нет, поэтому мы тут рисуем 7 плюс бесконечность,
там Б, С. Там тут мы, соответственно, один уже вместо единицы тут пишем 3, тут пишем 1, 3. Вот. А
рыженький указатель куда-то девается, потому что он теперь превращается в пятерку. И вот теперь
самое мистическое. Четверка соответствовала строке АБА. Теперь она должна соответствовать
строке БА. Вот единственное, что мы здесь пока не делаем за линию, это не ищем, где находится БА.
Вот. Ну, допустим, пока предположим, что с небес по факсу нам присылают, где она находится. Вот она.
Ну, замечаем, что перехода по букве Б тут тоже нет. Значит, как всегда, пилим, отправляем. Значит,
пишем тройбан. Вот. То есть тут рисуем еще. А, у меня тут черненьким что-то недорисовано. Да,
потому что тут как бы ЦАБа, а тут просто теперь Б. И тут Б. А, ну тут везде еще Б, конечно. Вот. Так.
И фест тот лифт становится шестеркой. Шестерка соответствует суффиксу А. Где же он находится?
Что? Где? Да. Ну, пока можно просто в тупую пройти по этому символу, найти, что он находится здесь. Но
здесь переход по букве Б внезапно есть. Поэтому мы торжественно идем вот сюда и на этом останавливаемся.
Потому что тут идея такая, что раз из этого суффикса мы перешли, то из всех остальных мы тоже перейдем.
Там ничего нового не создастся. Ничего больше делать не надо. Ну и завершающий штрих в нашем случае,
добавляем букву А. Рыжий указатель торжественно справляется вот сюда. Ну и все. Больше ничего не
происходит. То есть вот такой алгоритм. Обратите внимание, по модулю черного ящика, который нам
сообщает, где находится следующий фест тот лифт, алгоритм уже работает за линию. При этом черный
ящик очевидно реализовывается на квадратах. Да, у черного ящика есть, конечно, напрашивающая
реализация, потому что по фест тот лифт мы можем догадаться, какой суффикс имеется в виду и в тупую
по этому суффиксу пройти. Правда? Понимаете логику, да? А какие у нас тут общие оценки? Кроме этого все
работает за линию. Да. То есть у нас все работает за О от Н плюс за какое время мы делаем переход по
рыжему указателю. Ну потому что, точнее, вот рыжий указатель, ну потому что мы говорим, что вот фест тот лифт,
он там и увеличить фест тот лифт на один. Но когда вы увеличите этот фест тот лифт на один,
вам нужно знать, где соответствующий суффикс в дереве заканчивался. Да.
Ну не совсем так. Потому что, надо аккуратно говорить, что добавление каждой буквы может
делать таких скачков больше, чем один. Ну потому что может у вас в этом фест тот лифт шестой,
значит добавили ребро, фест тот лифт семь. Нужно тоже новое добавить ребро. И перешли. То есть
добавление каждой буквы фест тот лифт может увеличиваться несколько раз, а не один. Вот имейте
в виду эта говорочка. Но, конечно же, очевидно, что суммарно фест тот лифт, конечно, добавит не
более чем N новых вершинный ревер. Ну, то есть добавит он больше, потому что он, конечно,
часто еще распил и делает, но соответственно. Кстати, это тоже еще одно доказательство того,
что в, ну хотя ладно, это уже не является там новым доказательством относительно предыдущего. Вот. То
есть это там уточнение, это может быть сказать уточнение, как конкретно это происходит, то,
что мы в том доказательстве говорили. Вот. То есть единственное, что нам теперь надо, что нам
теперь надо научиться, это по суффиксу, по суффиксу предыдущей строки из без символа находить
следующий суффикс, желательно как-то за быстро относительно. Понимаете, да? Как же это сделать?
Ну, на самом деле, это делать очень легко. Что? Это точно корневуха.
Почти, наверное, там какая-то подлянка будет, конечно, где-то, что там надо ходить и так далее,
но мы пойдем другим путем. Значит, мы заменим черный ящик на другой черный ящик. Черный
ящик будет называться суффиксная ссылка. Ну, логично, да? Нет, ну да. Могло показаться,
сочетание может показаться неожиданным для тех, кто не изучал ни дерева полиндромов,
ни ахакарасик, ни суффиксный автомат. Но после них как-то уезжающая суффиксная ссылка тут нигде не
возникнет. Как-то сложно. Единственная проблема, что придется теперь конкретно здесь уточнить,
а что такое суффиксная ссылка? А вот что это такое. Потому что, смотрите, давайте,
потому что для каждой вершины можно вводить такие позиции. Вот я, смотрите,
я вот черным введу понятие PES от POS. Что такое PES от POS? Что, где-то это уже было, да? PES от POS?
А, там типа рифма какая-то, да? А PES от POS там, да? Ну ладно. Ладно, мне сложно сказать, какие тут…
А, а, КОС, о господи. Нет, знаете, это как из цикла, да, знаете, там бывает, что там на интеллектуальной
игре так, значит, так, вопрос давайте. Принцип действия гранитовой палочки. Там два игрока
покатились со смеху. Там просто так жутко. Что вас больше всего насмешило, эбоитово или палочки?
Там, давайте еще раз. Принцип действия гранитовой палочки. Парень, это принцип. А ты принцип,
нет, ты принцип. Вот. Как это называется? Отрывок из номера самой там, съемки программы самой умной в
Казахстане. Ну, я не знаю, почему казахи посчитали, что там будет именно так, но было смешно. Да, вот.
Да, именно там считают, что это. Зови прямые, которые не пересекаются. Рельсы. Черт с тобой,
я засчитываю этот ответ, потому что мы иначе так никогда не закончим. Да, 1-0. Красавчик, братуха.
Вот. Ладно, такой. П-сет-пост, это что такое? Это строчка, по которой мы в эту позицию придем.
Понятно, да? Ну, пост – это позиция в дереве. Она может находиться как в вершине, так и внутри
вебра. Понятно, да? То есть как бы вот есть у нас позиция. Так вот, в принципе, я аналогичным
образом могу ввести позицию п-с от в. Вот, то же самое, только уже на этот раз от вершины. То есть
это частый случай п-с от поза. Так вот, а теперь определение. Нет, на этот раз пришло время
использовать зеленый маркер. Значит, сув от в. Можно ввести сув от поз, но он не вводится.
Значит, смотрите, сув от в. Это такая позиция, что п-с от поз. Суфикс. П-с от в. Ну и, как вы уже
догадались, длина п-с от поза – это в точности п-с от в минус 1. Вот. То есть я это нарисовал
зеленым и черным. Знак следующий, что черное мы, как и раньше, в дереве в явном виде не храним,
а вот суфиксную ссылку мы в каждой вершине в явном виде хранить будем. Правда, да, то есть
особенная мистика будет заключаться в том, что а как конкретно ее находить. Вот вы только что
создали вершину, надо ее найти. Ну, во-первых, как ее кодировать, надо еще сказать. Ну, подождите,
ну как ее кодировать? Ну вот. Ну давайте задумать. Тут, конечно, вопрос, потому что вопросы могут
быть такие, что на самом деле она как бы помолча, а не суфиксная ссылка от вершины может вести куда-нибудь
в середину ребра, и более того, в перспективе это ребро может сильно меняться. Оно может обрезаться
сзади, оно может обрезаться спереди, а еще оно может просто превращаться в вершину в какой-то
момент, правда? Нет, вот эта позиция. То есть условно говоря, у вас есть такая пустыня, там где-то
это такой путь между Ластвересом и Солтейксити, но я не знаю, я не разбираюсь, называется в географии
Англии, соответственно. Да, настолько. И там, значит, какая-то пыльная дорога стоит,
и около какого-то кактуса стоит ваш режеуказатель. Но фишка в том, что это сейчас как бы там
бесконечность, впереди бесконечность, позади бесконечность, потому что, как мы помним,
ребро может расплититься на два, то есть посередине там построили какой-нибудь город с казино. Вот,
чтобы из Ластвереса было быстрее ездить. Потом могли еще сзади построить, потом пристали, слушайте,
хороший кактус, давайте вокруг этого кактуса город построим. Но там, я не знаю, так появляется
там какой-нибудь город, его как-нибудь там назовут, как назвать простой провинциально-американский
город? Ну, естественно, Санкт-Петербург. Ну, Том Сойер предупреждал. Вот, соответственно,
и так далее. И вот у вас тут город появился. Вот тут примерно то же самое могло быть,
казалось бы, но на уровне идеи. Но на самом деле есть мистическое утверждение.
Значит, если В не лист, то суфот В – это вершина. Вот прям усерда. Ну, по крайней мере, сформируем
так аккуратно. Когда у нас дерево фиксировано, то есть вот у нас есть строка, есть корректное
дерево. Так вот, для любой не листовой вершины, кстати, забирая вперед, для листов мы суфиксную
ссылку даже насчитывать не будем, просто потому что она нам не нужна. Так вот, значит, так вот,
для любой, если вершина В – это не лист, то есть вершина В – это внутренняя вершина, то суфот В – это
точно вершина. То есть не середина какого-то ребра, а прямо сейчас эта вершина. Нет, если мы верим в
это утверждение, то это нам дает надежность, потому что понятно, что эта вершина меняться не будет. То
есть если в этом месте находится вершина, она там будет находиться всегда. Да, могут меняться дороги,
ведущие в нее и из нее, но город от этого никуда не денется. То есть мы там никогда не будем
понимать. То есть мы можем построить на трассе новый город, но понимать решение, что Детроид
переносится там на пару километров вправо, потому что, ну я не знаю, потому что я так хочу. Вот,
мы так не будем. Вот, понятно, и почему же это? Ну, у нас типа есть путь до нашей вершины,
и потом развилка до двух разных суффиксов. Когда мы отпилим от него первый символ,
у нас наши два суффикса все еще останутся суффиксами. Соответственно, после отпиления
мы пройдем по тому же самому пути, у нас снова будет развилка до этих двух суффиксов. Поняли
идею? Значит, идея такая – жила-была вершина В. Что же это за подстрока такая, которая ведет
вершину В? То есть пусть это какая-нибудь подстрока на этот раз Q. Что означает,
что она попала во внутреннюю вершину? Это значит, что так как у нас сжатое дерево,
то у нас из вершины идет хотя бы два ребра. Эти ребра идут по каким-то буквам. Они идут,
да, даже правильно, вот так. То есть они идут тут по какой-то букве А и тут по какой-то букве
В. Но тогда мы вынуждены заключить, что QA и QB – это подстроки строки С. А теперь отпилим от Q
один символ в начале. Получится Q'. Но тогда мы замечаем, что строки Q', допустим, A и QB – это
тоже подстроки строки С. Следовательно, когда мы пройдем по Q', тоже в этом месте обязана быть
развилка. Значит, Q' приводит вершину У. То есть вот, оказывается, такая неожиданно простая идея.
Итак, значит, суффиксная ссылка всегда показывает вершину.
Ну раз есть QA и QB, то есть Q' и QB. Совершенно верно. Пока, в общем-то, не сильно сложно. Ну и все,
в общем-то. Ну как все. Я сейчас проделаю тот же самый алгоритм, но буду предполагать,
что нам откуда-то с небес по факсу присылают суффиксные ссылки. Модификация будет, конечно,
незначительная, но тем не менее. Вот, поехали.
Значит, поехали. Давайте, как всегда, С равно пустая строка. Значит, когда добавляем символ А,
ну и здесь ничего не происходит. Просто добавляем переход по букве А, пишем тут от нуля до
бесконечности и говорим, что first not leave, ну давайте я сейчас не буду его прописать,
писать для экономии времени. Хотя нет, буду лучше писать. Он указывает сюда, и он равен единице.
Так, что у нас происходит дальше? Буква B. Мы пытаемся из этого указателя перейти по букве B,
у нас не получается. Поэтому мы создаем новое ребро на один бесконечность, пишем, как всегда,
тут переход по букве B, тут переход по букве B. Тут пока в этом ничего не меняется. Так, но first
not leave торжественно превращается в двойку. Но почему? Но как мы это на уровне алгоритма теперь
узнаем? Мы говорим, что если мы только что создали ребро из корня, то из этого мы делаем вывод,
что следующий указатель просто в этом корне придет и он должен там остаться, потому что тут был
суффикс длины 1, останется суффикс длины 0. Понятно, да? Тут разные лайфхаки есть, в принципе,
в реализации часто тут создают какую-нибудь фиктивную вершину, в которую сюда ведет
переход по буквам A, B и так далее, всему алфавиту короче, а нота сюда из корня ведет
суффиксная ссылка, чтобы было удобнее прыгать. Мы создали ребро, скакнули по суффиксной ссылке,
сказали, что переход по букве B есть, перешли по нему, вот мы здесь. Вот часто так делают. Я так,
кстати, обычно не делаю. Не знаю, это и циклоновкус, и цвет. Кстати, в вахкарасике такое тоже любят.
Вот, ну и в дереве пелендромов соответственно тоже. Вот, так вот, буква А. Так, ну тут понятно,
что к этим ребрам мы мысленно приписываем там букву А. Так, теперь смотрим. Так, рыжий указатель
говорит, есть ли переход по букве А. Есть? Есть. И мы переходим. Все, в чем переходим,
говорим, что больше ничего не делаем. Теперь буква С. Да, где-то опять притаился Якубович с
огурцом. Да, но вот. Есть ли переход по букве С? Нету. Значит, что мы делаем? Пилим, значит,
прямо сейчас на этой трассе создаем новое ребро. Ну понятно, тут пишем 0,1, тут пишем 1
бесконечность. Тут пишем новое ребро по букве С. Тут пишем там 3 бесконечности. Вот, но этот указатель
даже туда не приходит, а теперь мы из этого указателя должны перейти по суффиксной ссылке.
Прям вот отсюда. Значит, но мы как мы сказали, предположим, что суффиксную ссылку нам присылают
с небес по факсу. Да, но с небес по факсу нам неожиданно сказали, что суффиксная ссылка
из-за ведет, ну куда она ведет. Да, но мы об этом поговорим позже, потому что у нас в этой ситуации
возникнет. Да, но идея правильная, спасибо. Но мы пока чуть позже. Пока суффиксная ссылка говорит,
что мы тупо идем теперь в корень. Из этого в корне мы говорим, что перехода по букве С нету. То есть,
смотрите, мы сейчас находимся вот здесь. Кстати, это соответствовало того, что вот реже указатель
превратился в 3. Вот, теперь мы переходим по символу С.
Ну вот. И теперь отсюда мы переходим по суффиксной ссылке. Переходим в том условно сюда, возвращаемся.
В общем, короче говоря, реже указатель сидит здесь и больше никого не трогает. Так, ну ладно,
тут указатель придется видимо подлиннее сделать. Потому что, что у нас происходит дальше? Так,
ну дальше давайте сократим себе немножко жизнь. Вот. И переговорим, потому что тут АВА, вон тут
переходы есть, поэтому реже указатель идет сюда. Видно, да? А вот теперь появляется буква Б. И вот тут
неожиданная идея. Смотрите. Да, мы тут как бы, раз понятно, мы тут пилим, тут получается 1, 3,
3 бесконечности. Это понятно. Вот. Тут переход по букве С. Да, тут соответственно этот там АВА,
естественно, тут дописывается. Давайте сразу его тут допишем, чтобы больше об этом не думать. И
тут АВА какой-то. Вот. Да, тут мы создаем ребро. И так, значит, тут переход по букве Б в ситуацию 7
плюс бесконечность Б. И что получается? И теперь мы идем по суффиксной ссылке. С небес по факсу
суффиксная ссылка говорит нам о том, что у строки АВА суффиксная ссылка должна вести в то место,
где заканчивается БА, правда? Вот здесь. Ой, а вершины-то нету. А ведь мы же говорили,
что вершины, суффиксная ссылка обязана ввести вершину. А у нас ее нету. Как так получилось? Да,
да. Да, я вас где-то обманул. Но не в этом, значит, не голил сейфер, а тут я вас как бы вряд ли обманул
где-то. Кого добавить? Вот. Нет, добавить только Б надо, добавить там. Нет, БА у нас уже есть,
целиком БА добавлять не надо. Да. Вот. Но идея другая. Идея такая, что утверждение было верно,
оно как бы было верно для строки АВА целиком, его правильного суффиксного дерева, и суффиксного
дерева для этой строки целиком. Но тут фишка в том, что мы как бы в промежуточном состоянии. Мы
построили новую вершину, но еще не сказали, что не надо строить других вершин. И в принципе вот
эта ситуация говорит нам маленькую простую вещь. Если тут вершину нет, значит, можете ее прямо
сейчас тут создать, потому что все равно новый переход из нее потребуется по той самой букве Б.
Понятно, да? То есть просто прямо сейчас на этом месте создаем новую вершину. Вот. То есть как бы
черный ящик сказал, слушай, город должен быть там, а его нет. Слушай, ну ты же Петр Первый,
ну с построй, господи. Ну там болото, и че? Так че, не империя, вы шо, не империя шо или шо? Вот.
Вот. Ладно, по географитам, это конечно явно не какой-то там город на море, конечно, находится.
Значит окей. Значит, рыжий указатель перескакивает сюда, неожиданно для себя обнаруживает, да,
для себя неожиданно, но не для остального мира. Шоакаса перехода по букве Б тут нету, и он
теперь торжественно его строит. Вот пишем 7 бесконечность, там тут был переход по букве С,
тут был переход по букве Б, и получится радость. Значит, да, тут буква Б. Ну и теперь, соответственно,
вопрос. Сейчас, а почему там обязательно, вот, возможно там не было вершины. Ну. Ну короче,
почему там следующая буква, которая внутри этого ребра не может быть просто Б? А идея очень
простая. Ну вот. Ну убедиться в этом можно так. Вот, допустим, тут строка П была, да? Тут была
какая-то более длинная П, условно говоря, там ДП. Ну Д маленькая, П большой, да? Вот. Мы уже знаем,
что в строке ДП здесь развилка есть. То есть, ну как бы развилка в будущей строке точно будет.
Я бы даже сказал, она только что появилась. Ну да. Чего? Ну нет, может быть, она тут даже есть,
но мы просто, если тут и развилки нет, то мы и суффиксную ссылку тут считать не будем.
Смотри, если развилки до добавления символа не было, значит тут в принципе был один символ,
но в принципе так и происходит. То есть был один символ, и он не тот, который нам надо. Тогда,
когда ты тут суффиксной ссылки попадешь в середину ребра, значит там был тот же символ,
что был раньше. Ну можно и рассказать, что типа если бы там не было вершины, то значит бы там
точно не было развилки, а у нас она была. Ну да, значит и тут раньше тоже развилки не было, да. То
есть может она только что появилась, значит и там она сейчас появится. Вот, да, десятью способами
можно убедиться. Там, нет, как бы могут начаться более какие-то крутые вопросы. Ну да. Но если у
нас не было вершины, то ее уже точно еще нет. Нет, да, на самом деле там могут еще попредираться,
потому что скажут, слушайте, а вы только что добавили ребро, и может быть вот эта вот строчка новая
баба, она уже появилась вот здесь. Вдруг такое произошло? У меня длина. Да, на самом деле, то есть
мы замечаем, что да, тут все в порядке, потому что мы тут скачем по уменьшению длин, поэтому то,
что мы тут делаем на самом деле на существование развилки для более коротких строк не влияет
никак. Да, но просто это надо выточить. Если мы скакнули куда-то, где нет вершины,
вопрос про то, создавать ли вершину. Ну по большому счету да. Если мы скакнули туда, куда нет вершины, значит там точно нет развилки, а у нас уже точно есть развилки. Ну да, значит и тут она развилкой сейчас появится.
Вот, так, ну поехали. Теперь придется из этой вершины скакнуть. Ой, а у нас пока нет суффиксной ссылки.
О, великий черный ящик, скажи нам, где суффиксная ссылка? Он говорит, здесь. Ну вот вы видите, а, ну да, мог бы догадаться.
Вот, ну хорошо, есть ли тут переход по символу B? Неожиданно выясняется, что да, мы переходим и радуемся жизни. Все, на этом останавливаемся.
Так, ну все, что нам остается теперь добавить букву A и сказать, что вот тут переход по букве A есть, мы по нему переходим и ничего не меняется.
То есть вот так выглядит алгоритм по модулю появления суффиксных ссылок. Вот, понятно, да? Вот, кайфец.
Ну а дальше понятно. А что дальше понятно? У нас насчитана суффиксная ссылка для ближайшей сверху разбилки. Да.
И мы просто берем ее и двигаемся вниз по стоку, насколько мы сами знаем. Ну да, то есть в принципе это тупой алгоритм поиска суффиксной ссылки, который работает за квадрат.
Почему за квадрат? Скажем так, верное утверждение, что это работает за квадрат. А, окей.
Давайте. То есть надо еще, давайте сейчас просто сформулируем, потому что да, вот. То есть действительно тупой вариант, как за квадрат найти суффиксную ссылку для вот свежеобразованной развилочки.
То есть идея такая. Чего? Я даже не понимаю, ну в плане, это правда, это действительно O от N квадрат, но я не понимаю, откуда тут N квадрат действие могло взяться.
А вот откуда, смотрите. Мы поднимаемся, потому что как мы ищем суффиксную ссылку? Идея такая. Мы поднимаемся в родителя, в свежеобразованного родителя этой вершины.
Да, кстати, редкий случай. Был у нас родитель, был у нас ребенок, ребенок резко стал внуком и родитель сказал, вот так, теперь вот он этот родитель.
Мы позицию храним без привязки к родителю, что? Нет, в смысле почему? Ну в смысле без привязки, не понял.
Ну мы сам этот указатель храним, как вершину и сдвиг, видимо. У нас уже хранится родитель.
Нет, я о другом. Я фишка говорю, что был родитель, был ребенок. А теперь ребенку сказали, поздравляю, у тебя теперь новый родитель.
Я себе тут придумал нового ребенка, он настолько крутой, что он теперь твой родитель.
Да, дико звучит, но если заменю понятие ребенка-родитель на начальник-подчиненный, то это нормальная ситуация.
То есть в каком-нибудь стартапе это в принципе нормально. То есть создатель стартапа сначала руководил непосредственно всеми, а потом, когда стало слишком много, нанял там дополнительно менеджеров.
В принципе нормальная ситуация.
Идея такая. Мы поднимаемся в родителя, поднимаемся по строке P.
Теперь на самом деле возможны два случая. Более популярный случай говорит, что эта вершина не оказалась корнем.
То есть до строки P мы тут еще шли до какой-то строки Q.
Но тогда идея такая. Надо просто пройти по уже существующей суффиксной ссылке вот у этой вершины.
Вот. Ну и сюда мы приходим по строке Q'.
Что такое Q'? Это как бы та же строка Q, но без первого символа.
И теперь надо просто из этой вершины спуститься по строке P.
Абсолютно то же самое.
Вот. Это самый популярный случай.
Хотя ладно, вопрос. Потому что есть, конечно, второй случай, когда оказалось, что эта вершина корень.
Тогда из корня надо спуститься по строке P меньше.
Понимаете, да?
Ну вот вопрос. За какое время вы тут сделаете этот спуск?
К вопросу о квадрате.
Наверное, там могли быть лишние развилки, да?
Ну вот.
Так, ну начнем с простого. Самое тупое, что можно сделать, это спуститься по самой строке P.
Прямо по одному символу.
Но это будет то от P, это тогда будет заведомый квадрат.
Теперь мы можем воспользоваться тем маленьким приятным свойством.
Мы знаем, что мы точно можем спуститься.
То есть там не получится так, что мы пытаемся прийти по какому-то символу, а он возьми и не пройти.
Это означает, что пока у нас нет развилок, мы можем просто втопить педаль газа и ехать до ближайшей вершины, либо пока у нас длина не закончится.
То есть мы знаем, что мы в следующую букву отправлялись вот в это ребро.
Сколько нам надо пройти? 179. Какова длина ребра? 57.
Давайте телепортируемся в конец и оттуда проходим еще 122.
То есть мы точно знаем, что эти 57 букв совпадут с тем, чем нам надо.
Логично, да?
То есть по факту мы будем работать здесь за то, сколько у нас тут лишних промежуточных вершин на пути образуется.
Это уже лучше, чем за у от п, но пока от квадрата нас не спасает.
Не правда ли?
Потому что вы идете не за количество символов в строке п, а за количество вершин, которые вы на этом пути встретите.
У нас эти промежуточные вершины, когда они образовались, они плохо исчезают обратно.
Как плохо? Вершины вообще не исчезают, я тебе больше скажу.
Но в плане кажется, что прибавляться может много, а вычитаться вроде мало.
Ну тут дело не в этом.
В нашем случае ситуация будет...
Нет, понятно, что мы знаем, что суммарно вершин будет создана мало, не более чем n внутренних вершин будет создана.
Даже от минус один я бы сказал.
Вот это мы уже знаем.
Но фишка в другом.
Я скорее про то, что если мы будем считать суммарное число вершин на пути от корня до нашей вершины, то оно плохо убывает.
Ну да, и ведь действительно.
А давайте посмотрим на промежуточные вершины на этом пути q от корня.
Теперь заметим, что у каждой из этих вершин есть суффиксные ссылки.
И они все, кроме может быть одной этой вот, ведут ровно на этот путь.
То есть получается, на самом деле, до вот этой вот вершины, то есть когда мы от этого вот скачка, получается количество промежуточных вершин, может оно не менее чем сколько их было тут минус один.
Так то же самое, потому что им всем соответствуют строчки, которые являются префиксом вот этой строки q.
И тогда, если они предъявляют один символ, то они все станут префиксами q'
То есть важно, что они в разные еще переходят?
Ну конечно. Ну да, в разные длины.
То есть максимум, что может произойти, это одна из этих строчек могла превратиться в пустую строчку.
И тогда она как бы не промежуточная, а просто корень.
Поэтому тут количество вершин промежуточных могло уменьшиться на одну.
Но не более. То есть оно могло уменьшиться на одну, могло не уменьшиться, могло даже увеличиться.
То есть получается, от этого скачка, смотрите, от этого скачка у вас глубина, глубина, если мерить ее именно в количестве вершин, то есть в дереве, она уменьшилась не более чем на один.
А с каждым таким скачком вперед, эта глубина увеличивается на один.
То есть у нас прикольная ситуация, что сувикс на ссылку может идти в большую глубину, чем мы.
Да, по вершинам в глубину, да, совершенно верно.
То есть конечно по длине пэса это конечно не так, но по глубине вершин так.
То есть получается, смотрите, у нас этот рыжий указатель, можно внимательно смотреть на глубину этого рыжего указателя, но измеренную не в длине пэс, а в вершинах.
Получается, то есть как-то глубина работает.
Когда мы создаем новую вершину и идем в родителя, глубина по факту не поменялась.
Ну, как хотите, можете считать, что она поменялась, можете считать, что она там изменилась на один, это неважно.
То есть изменилась на один, потом она скакнула по сувиксной ссылке и стала не менее чем такая, как была минус один, а потом сделала несколько скачков и каждый раз увеличилась.
Получается, смотрите, такая не совсем стандартный амортизационный анализ, но тем не менее.
Изначально у вас у рыжего указателя глубина очевидно ноль, да, и теперь на каждой итерации у нас происходит следующее.
Мы не более чем два раза уменьшаем глубину на один, а потом делаем сколько-то скачков, каждый из которых увеличивает глубину на один.
При этом более чем n глубина никогда не станет.
Но кажется, из этого следует, что суммарное число вот этих скачков вниз у вас больше чем 3n не будет.
Вот, понятно?
Вот.
То есть можно свести как-то методу потенциала в том виде, в котором он у нас был.
Сказать, что потенциал равен, скажем, текущей длиной строки минус глубина этой вершины.
Ну, чтобы он изначально был ноль, никогда не.
Просто кажется гораздо удобнее вводить чуть-чуть более обобщенный потенциал, у которого начальное значение f0 может быть каким угодно,
и просто говорить, что у нас оценка это типа f0 плюс...
Ну да, можно и так.
Ну а можно уже и не вводить.
Вот.
Ну можно не вводить, а можно просто, да.
Так его и...
Ну, во-первых, глубина, у нас нет понятия высоты обычно в дереве.
Ну нет, если оно и есть, то это как бы расстояние от вершины до листьев.
Но тут как бы еще раз подчеркнем, что здесь мы рассматриваем две разные глубины.
Потому что глубину в суффиксном дереве можно верить как длину пессо, то есть насколько длинной строке можно прийти,
а можно мерить по количеству вершин, промежуточных вершин на пути.
Это две разные глубины, потому что, как оказалось, что суффиксные ссылки всегда уменьшают глубину в смысле пессо, естественно, ровно на 1,
но в смысле количество вершин на пути, глубина может увеличиться вполне.
Вот.
Так что вот так мы ищем суффиксные ссылки.
И выясняется, что эти суффиксные ссылки, оказывается, амортизированы тоже еще-то за линию.
А мы больше ничего, в общем-то, нелинейного, кроме поиска суффиксных ссылок и не делали.
А ну все, победно.
Да.
Как всегда.
В общем, не сильно-то и сложно, если знать все секреты.
Да нет.
Это несложный алгоритм.
Это несложный алгоритм.
Ну да.
Вот.
То есть, единственная проблема, что...
Сколько бы ни было легко писать.
Да.
А тут вот наоборот.
По крайней мере, тут, кажется, может оказаться не сильно тривиально, как это вообще, собственно, воплотить в программу.
Да, неважно.
Ну, как хотите.
Честно скажу.
Скажем так.
Обычно у меня, на самом деле, в программе, подразумевается, что дальше я там просто
либо пишу код на доске, либо открываю компьютер и пишу код там.
Не, ладно.
Если без шуток, то важно.
Давайте.
Ну вот.
Зачем тебе это?
Вот.
То есть, нет.
В принципе, да.
То есть, я могу показать, действительно, как это, как, по крайней мере, по моему мнению,
можно написать.
С такими вопросами можно.
Вот.
Но вы же не будете иногда меня спрашивать, как писать этот код?
Ну, нет.
Ну, могу и попросить, в принципе.
Нет.
Ого.
Отпад.
Комиссия.
Как писать УКО?
Не знаешь?
Вылетай.
Костя писал на комиссии код, а на экзамене, вроде бы, ничего не писали.
Костя писал на комиссии.
Там, правда, передача была.
Комиссия.
Чего, Костя?
Какой Костя?
И в коллеге.
Писал код на комиссии.
Он писал с кем-нибудь ретроанализ.
А, ну, ретроанализ, да.
Но ретроанализ и вот это.
Ну, сравните, ребят.
Я думаю, я вам не открою страшные тайны и скажу, что вот это вот вопрос.
Вот вопросом на три точно не будет.
Вот на хоре или на отел, я еще подумаю.
Ну, идейно тут ничего на отел нет.
Ну, скажем так.
Ну, в смысле, это чистый вопрос на флору, если не просить писать.
Ну, надо смотреть.
Это же зависит от того, как бы, да, потому что там в какой-то момент...
Сделайте сул автомат на отел, пожалуйста, а дальше что-то будет.
Да, совсем доказательствам.
Ага.
Нет, ну, надо смотреть, что там будет.
Да.
Хотя надо смотреть, что там было на самом деле на отел.
А, ну да, сул автомат.
Ну, Галил Сейперас в двух ипостасях.
Да.
Деланы?
Индусы?
Индусы нет.
Нет?
Нет, индусов даже и в экзамене обычно нет.
Нет, индусов обычно нет в экзамене, потому что они всегда были в качестве теоретической задачи в ДЗ, на самом деле.
Да.
Вот.
Ну, сейчас ее там нету, но...
Ну, алхо тракумагнический варьер, вот это все.
Но там, в общем, тоже не самый...
Но это, очевидно, не самый убойный алгоритм в вашей жизни.
Там, собственно, в потоках и посложнее были.
Да.
Так.
Что там еще?
Деланы?
Нет.
Теорема Карзанова это на хор.
Так, естественно.
Так.
А вот всякие вот Деланы и Вороной, вот это да.
Это, скорее, конечно, на отел.
Да.
Ну, там, точнее так, до какого-то момента там, наверное, на хор.
Ну, тут тоже, на самом деле, будет вопрос наут.
Что такое суффиксное дерево вообще в принципе?
Построение закладов.
Ну, естественно, да.
А вот сам алгоритм Уканина, да, он может оказаться есть.
Так, а который час вообще?
Что?
Который час?
12-14.
А, то есть пришло время еще одного перерыва, да?
Да.
Да.
Вот.
Так нормально?
Да, так нормально.
Так.
Ну, поехали.
Значит, как же у нас будет...
Значит, поехали.
Класс.
Саффикс 3.
Ну, такое самое простое, что можно сделать.
Так.
Ну, а первое, давайте заведем...
Придется завести структурку ноде.
Как завести структурку ноде?
Что у нас будет в вершине?
Так.
Ну, давайте поймем.
Давайте соберем у нас кучку.
Что мы хотим в вершине вообще хранить?
В позиции.
Э, какую позицию?
Какую позицию?
В сдвигах.
Угу.
Какого сдвига?
В вершине, а не в позиции.
В вершине, а не в позиции.
Ну, возможно, на разветвление.
Так, наверное, переходы.
Ну, тут-то, не имеет смысла, на самом деле, сразу договориться.
А как мы будем хранить позицию?
Так.
Ну, то есть понятно, что у нас, конечно, вершины мы и в явном виде дерева не будем хранить по указателям.
Конечно, мы будем все-таки вершинке хранить в каком-то векторе.
То есть я вот сразу вам заранее скажу, что у меня тут будет вектор ноди-нодис.
Вот.
А вы прям очень хотите, да?
Нет, ну просто вы так сказали, как будто это само собой разумеющееся.
Ну, потому что...
Ну, на самом деле, да, не то, чтобы прямо само собой разумеется, конечно.
Я не уверен, что много проблем по памяти.
Нет, проблем по памяти не будет.
Может быть там...
Нет, ну как хотите.
Хотите, можем и на указателях написать.
Не проблема.
Да нет, нет, просто чисто.
Вот.
Ну, на самом деле, смотрите.
Ну, обычно как задавать позицию?
Ну, обычно позиция, скажем так, классический вариант задается очень просто.
Она задается, куда мы идем.
То есть, так сказать, vertex2 и расстояние до.
То есть удобно для позиции просто говорить, что мы идем вот в эту вершину.
Ну, в вершину у нас всегда идет одно ребро, поэтому достаточно хранить расстояние.
А вот информация о самом ребре.
Что там, кто-то еще там собирается прийти?
Уже нет?
Не, просто ты там активно так переписываешься.
Может там кто-то еще сейчас на эту финалочку сейчас решил ломануться из долгопробного, не знаю.
Быстрее едет.
Да, да, да.
Электричка толкает.
Да, да, да.
Прямо быстренько это добежал до лобни, там разбудил в депо, собственно вынул электричку, понесся.
Так вот, но в вершине нам придется много чего хранить.
Но начнем с того, что нам придется хранить, конечно, детей.
А теперь внимание, вопрос.
Хорошо, переходы из мапчика, пусть будет мапчик для простоты.
У нас будет из чаров.
Из чаров?
Куда?
Ну, там нужно хранить длину ребра.
Нам хуже.
Нам нужно хранить не длину ребра, нам нужно хранить его под строку этого ребра.
Не, ну пару, например.
Ну вот.
Но на самом деле, ну пару.
Какую пару? Нет, ну пару можно хранить, нет, ну пару тут, как бы, какую пару?
Как минимум, куда переходить, в какую вершину мы приходим хранить, переходить придется так или иначе, правда?
Какую структуру?
Ну, transition.
Типа переход.
Transition очень долго писать.
Заведи структуру tr.
Ну, можно. Ну, смотри, знаете, что-то у меня редкий случай.
Обычно я, конечно, я часто, честно говоря, вот вообще пишу, когда у меня прям здесь прям позиционы находятся.
Почему находится позицион?
Так, ну во-первых, да, кстати, да, естественно, как вы понимаете, саму строчку я буду здесь хранить.
Вот.
А также еще в самой ноде.
Вот давайте.
Еще мне придется хранить саму подстрочку, по которой я вхожу в себя.
Мне это по-любому придется откуда-то знать.
То есть lr.
Ну вот.
А еще придется хранить, видимо, родителя.
Потому что как-то без родителя все-таки никуда.
Ну, когда мы будем распиливать ребро, родителя нам узнать придется.
Потому что, как вы уже догадываетесь, у нас там ферст нод сув, то есть там ферст нод лиф, мы будем хранить все-таки в позиционе.
Что не так?
Нод это вершина.
Да.
А где мы храним номер этой вершины?
В смысле?
Ну вообще, в позиционе мы храним вот вертекс ту, это номер вершины.
Номер вот в этом векторе.
Это понятно.
Ну, а вопрос тогда в чем?
Ну вот.
Сейчас-то я вот пишу позицион.
На самом деле, что-то у меня сейчас возникает ощущение, что в принципе достаточно хранить, собственно, знаете, я даже так буду писать.
T vertex.
Ладно.
Или в нашем случае T ноде.
А то у нас что-то синонимия какая-то пошла.
Вот давайте избавляться.
Вот.
Поэтому тут int lr.
Тут T ноде.
Ну, T, хотя нет, что-то тоже плохо, да?
А то как-то ноде это стракта, T ноде это какой-то int потенциально.
Ну даже на.
Вот.
Как-то да, путается какая-то немножко.
Ну ладно.
Значит да, int там lr у меня пусть будет просто индексами.
То есть это под строка, но имеется в виду, как бы под строка, вида именно от l включительно до r не включительно.
Вот.
Так lr parent.
Так.
А что-то еще нужно?
А!
Немная ссылка.
Вот.
Суфта.
Вот.
Значит, смотрите.
Как у нас теперь нодис будет работать?
Значит, что нам вообще нужно в каждом m3?
Нам нужно хранить строку, нам нужно хранить сами нодис, то есть сами вершинки.
И, конечно же, его величество.
Сейчас.
А lr это какая под строка подробитель от у нас?
Да.
Вот.
Все?
Да.
Ой, да.
Вот.
Так, вроде, кстати, как мы уже выяснили, а больше нам, в общем-то, ничего и не надо.
Вроде.
Я надеюсь.
Но для консистентности вроде больше ничего не надо.
Но давайте теперь думать.
Что нам вообще потребуется?
Так.
Ну, а первое.
Давайте реализуем, как всегда, все с конца.
То есть, ну, во-первых, у нас будет void pushback, так сказать.
Вот.
Ну, точнее.
Ну, можно так.
Вот так.
А есть какие-то аспекты, в которых это лучше, чем суффиксные автоматы?
Скажем так.
Ну, скажем так.
Могут встретиться задачи, которые с суффиксным деревом решаются, а с суффиксным автоматом нет.
А такие есть в контакте?
Дай бог памяти.
Но если там есть задача 3 substring, то да.
Ну, да.
Дай бог памяти.
Но если там есть задача 3 substring, то да.
Другой вопрос, что вы можете суффиксное дерево построить не вот так, а через суффиксный автомат.
Если у нас сегодня останется время, мы даже сегодня обсудим.
Вот.
Так вот.
Значит.
Итак, как мы будем делать pushback символа?
Так.
Ну, во-первых, давайте сразу скажем int равно s length.
И, соответственно, что мы теперь скажем?
s.pushback.
Значит, shard.
Вот.
Ну, типа того.
Значит, ну, теперь.
Теперь мы будем говорить.
Ну, дальше у нас будет устроено.
Так.
А теперь давайте думать.
Как вы думаете?
А теперь вот выбирайте.
Будем ли мы хранить эту лишнюю вершину, в которую идет суффиксная ссылка из корни, или не будем?
Нет.
Нет?
Есть другие пожелания?
Всем да.
Ой.
Понятно.
Да.
Всем.
Ладно.
Нет.
Убал я как-то.
Нет.
Сейчас вопрос в том, будем ли мы применять этот лайфхак?
Ну, давайте применим.
Нет.
Вот для этого.
Это надо просто сейчас вот, смотрите.
Дело в том, что начнем мы вот с чего.
Видимо, придется начать с инициализации.
Просто вот пустое.
Да.
То есть даже не инициализация, а такой конструктор.
И пишем.
С у нас пустое.
А вот, а вот что такое нодис?
Вопрос.
То есть у нас два варианта.
Либо мы создадем только один коринг, либо мы эту фиктивную вершину сразу создаем.
Вот.
Ну ладно.
Значит, если мы не хотим, то тогда, значит, создаем только одну вершину.
Ну вот.
Ну я это люблю писать вот так.
Значит, в ноде мы пишем.
Значит, корень это что такое?
Значит, мапчик из него, естественно, пустой.
LR пусть будет 00.
Parent нет.
Суффиксной ссылки нет.
Вот.
Все.
И как вы думаете, к чему равен first not leave?
Да.
Ну да.
0 и 0.
Ну да, логично.
Да, поэтому мы всегда считаем, что мы не корень.
Да.
Корень.
Корень не лист.
Вот.
Ну а теперь пишем.
Значит, теперь дальше работаем так.
Ну как у нас устроен этот поход по символчару?
Пока не, вот такие функции лучше сразу прописывать.
Пока не can go из позиции first not leave.
Вот.
Ну мы в будущем просто будем знать, что мы как бы по позиции символа можем понять, можем ли мы по нему пройти.
И более того, даже пройти мы эту отдельную функцию напишем.
Вот.
Вот.
Напишем while can go.
Вот.
Значит, дальше у нас будет работать так.
Int way.
Ну вот.
Значит, смотрите.
Значит, в этой позиции теперь, раз мы ничего не можем сделать, значит, надо сделать переход из нее по символу q, правда?
Здравствуй.
Как мы это будем делать?
Ну во-первых, начнем с того, что вершина v у нас, скажем, что это build nodi if need at first not leave.
Вот.
То есть она будет говорить так.
Я хочу, чтобы у меня в этой позиции была вершина.
То есть, если она и так там есть, то мы возвращаем ее в номер, а если нет, то мы строим новую вершину и ее там создаем.
Ну вот.
Yeah.
Вот.
So what's next?
Значит, создали эту вершину v.
Теперь из вершины v добавляем новое ребро.
То есть, прям тут честно, nodis от v точка children.
То есть children от q равно чему?
И какой номер этой новой вершины будет?
Not size.
Совершенно верно.
Так, вообще этой вершины пока нету.
Ну понятно.
Но мы ее сейчас заведем.
Pushback.
Pushback.
Пушбек.
Пушбек.
Пушбек.
Пушбек.
Пушбек.
Пушбек.
Пушбек.
Пушбек.
Пушбек.
Пушбек.
Пушбек.
Пушбек.
Пушбек.
Пожалуйста.
Значит, ну мапчик там пустой.
А что там вообще должно быть, давайте вспомним.
Так, должен быть children, должны быть ele.
Чему равны ele?
Ну, ка ваши ставочки?
Под строка, в которую мы входим в эту вершину.
какая была
но n мы сохранили вот я люблю что это это наценный символ я вот специально ровно в этом и ровно так
это сохранил да так и скажем инфинити ну может там констану вот так что у нас там дальше
parent и суф так кто не у родитель мы это кто в и тут конечно минус один по суфиксной ссылке
так вот здесь есть кстати сразу предупреждаю будет у нас маленькая подлянчика
built но да и в нит не будет строить суфиксную ссылку вот такой чит неожиданный вот и дальше
вот ну вот так вот так а дальше теперь мы из этой вершины вы должны скакнуть чего не будет
потому что возможно нам придется рекурсивно эту суфиксную ссылку очень долго строить
ну может в принципе можно но знаете почему-то хоть потому что может так случиться что тебе
надо как бы у этой решения построить суфиксную ссылку там она находится на середине ребра поэтому
ты там создаешь новую вершину значит тебе оттуда придется построить суфикс нет ну точно так
перспективе то есть тебе все равно придется делать так тоже можно сделать но я честно я почему-то
интуитивно я хочу это вы избегать поэтому я сделаю это линьева теперь то есть по идее я
дальше должен был написать что-нибудь вроде фест нот лиф равно просто позицион от значит
вот так я напишу суф вот так я напишу даже чтобы было понятно что это метод гет суф значит от
в запятая 0 просто вот эту вершину суфиксной ссылки перейти то есть у меня это будет функция
которая будет то есть дайте вообще в принципе удобно бывает такие функции сделать потому что
чтобы функция сама полезла им салон одеса отве точка суф вот это все не тур вот давайте
слушать вот или дано соответственно то есть она внутри себя скажу если она минус один значит
там построить эту суфиксную ссылку если нет то нет это мы сделаем в будущем вот но это но на
самом деле такое присваивание сделать недостаточно почему потому что может так случиться что как бы
суфиксной ссылки не существует по идейным причинам идейная причина называется а вдруг в корень
вот поэтому так и напишем если вы у нас равно root вот я тут специально пишу константа потому
что если вы неожиданно вот то есть если она root то как бы то тогда идея такая first not
тогда в явном виде пропишем хотя она и так она равна явно этому и после этого мы делаем
ретурн вот в противном случае мы переходим по суфиксной ссылке while продолжается почему я
это делаю я хочу после while сделать first not leaf равно go от first not leaf вот то есть как бы то
есть видите то есть как бы и вот то есть в принципе я мог бы тут этого ретурна не делать витя то есть
очень важно что если я тут напишу бряк это будет ошибка понимаете да то есть бряк я
здесь право не имею писать потому что я как бы сделаю тут ретурн чтобы избежать вот этого вот
вот вот в принципе в общем-то основные идеи алгоритма то есть так идеи алгоритма
скелетик я уже написал теперь пошли писать всякие технические вещи так что нам надо
написать ну давайте начнем с функции can go а я тут забыл приват паблик радость чего
на хит поехали внимание внимание смотрите сейчас будет ну вот и так
bull can go от из вершины из какой-то там position пост charge вот значит смотреть
значит смотрите ну тут два у меня два случая если пост точка дист не равен нулю то ретурн
ретурн get символ от пост равно что ну допустим есть функция get символ которая по позиции
внимание позиции на ребре который не совпадает с вершиной дает этот единственный символ вот
но в противном случае что нам надо сделать ретурн
чего где багов каких багов нет пока да правда выяснилось что я тут еще породил какие-то
функции на это просто пишу такой код более понятный то есть может быть там такой таком
контесте конечно можно написать коты и попроще дети вершины потому что в этом случае позиции
позиция находится в вершине значит я должен палить детей сказать есть у меня ребенок в
который идет переход по символу чи нет просто знаете вот бывает очень удобно сделать вот как
мап от цитрица такой чар инт ссылочка то с этим надо очень аккуратно пользоваться но этим прям
хочется взять вот children int v вот ретурн нодис от в точка children более того дайте часто бывает
вообще сейчас я вот я даже заранее создам чтобы было удобно то есть еще им вот такой
еще можно написать то есть для чего я это делаю чтобы мне потом было удобно переприсваивать
вот то есть можно здесь parent вот ну и как вы уже догадываетесь если это скопи пащу и сделаю
из этого сув потому что суфта мне придется переприсваивать я просто не хочу везде писать
но десат бла бла бла точка суфт равно там вот это все безобразие вот т.е. children
нод а ну и children в общем-то у меня отправляется в эту шкопилочку
так теперь у меня отправляется еще есть функция get символ давайте сразу ее закроем до чар
get символ от позицион позицион я сказал поз так ну а первых давайте для безопасности
скажем ассерт пост точка дист ту больше либо там больше нуля
вот ну и надо ретурн теперь с от чего а вот скажите как мне теперь выкопать этот символ по позиции
ну а именно взять конец и сдвинуться на поз точка дист да да да здесь я даже вон там
функцию на эре конечно заводить не буду хотя в принципе морга вот то есть видите как хорошо
вот это преимущество полу интервалы здесь я не должен плюс-минус единичками мучиться вот
так что получается кен го реализовали понятно да ну вот теперь давайте реализуем функцию го
так здесь выгодно наоборот здесь выгодно закончить сказок что как бы если позиция у вас не нулевая то
надо просто просто вычесть из диста единицу шагу это будет такая небезопасная функция в том
плане что она будет подозревать что пройти по этому символу точно можно мы это знаем
понимаете да вот но теперь возникает проблема что если позиции была на ребре то есть расстояние
до вершины у нее адекват какой-то больше нуля то надо просто вычислить единицу и не париться но
если мы находимся в вершине то надо выйти на то надо выйти на какую-то новую дорогу и на этой
дороге сделать один шаг правда значит поехали значит если оказалось пост точка дисту равно
нулю но за что нам тут остается им тв равно пост давайте так скажем пост точка нодя ту мы
находимся в вершине в хотим теперь смотреть куда int nv равно нодя сотве ну короче говоря вот
shielding от в логично да ну и пост равно теперь это новая теперь позиция которая смотрит вершину
до которой теперь нужно пройти расстояние которое равно как вы думаете к чему
нет пока нет ну пока не на один меньше на один меньше видите мы в конце вычтем хотя можете
на можно и на один меньше потому что для экономии можно просто написать он elza
да вы правы
так что же здесь тоже написать интрига
ага ну что конкретно вот какие буквы я тут должен печатать
ну да а как их посмотреть
да да да прям так и пишем здесь здесь нет смысла можно было писать эротенуэ и
минус элитом но данном случае пишем все-таки минус один раз так заказывали да или убираем
это тэлс или тут пишем минус один на ваше усмотрение ну может быть так даже вот так
красивее на самом деле потому что мы рассмотрели два независимых не связанных друг с другом
случае тут тут как мысли тут как угодно так но вот мы реализовали техническую функцию
вот попереча но давайте вернемся что нам теперь еще надо реализовать
о следующий наш идет вообще функция build node if need так build node if need так int build node
if need так только не м2 opposition post а чем не скомпилируется какие например почему
ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау ау а
не capitulate
да это уже написалiff ruining
ну там нет там да ну там так и д lending то есть на самом деле ты понял алгоритм
если ты можешь его написать хоть как-нибудь, чтобы надо, хотя тут, хотя тут кого как, у кого-то
иногда бывает, кто-то вообще бывает, что бывает, я понимаю алгоритм, но я не понимаю, как это написать,
я сам этого никогда не понимал, у меня как-то вот обычно был такой, что если я понимаю алгоритм,
значит я сажусь и его пишу, но да, нет, может быть еще бывает, что чисто теоретически я не понимаю,
как это, но возможно человек может идейно понимать алгоритм, но как бы обладать еще
все-таки не очень продвинутыми скиллами собственно кодинга, не, ну что, не, что там,
сортировка событий, как сортировка событий, ну события такие хранятся, ну это да, мы вообще да,
как-то останется у нас время, можно вообще там потратить отдельные четыре с половиной часа,
чтобы это написать, может даже меньше будет, нет, не, не волнуйся, мы сейчас не собираемся четыре с
половиной часа это писать сразу, тем более, что алгоритм, вот сейчас нам еще знаешь, сколько геометрии еще дожить надо,
нет, к сожалению, это слишком классическая вещь, чтобы до нее не дожили, нет, ну как-то знаете,
все-таки классика, классика есть классика, в любом уважающейся курсе алгоритмов как-то диаграмма
Воронова в том или ином виде есть, то там просто как всегда, это как геометрия, технические детали
возникнут, потому что геометрия это о том, что вы понимаете алгоритм, пишете его, получаете во 38,
потому что вы там пару случаев не учли, вот так вот, билд, но дыхнет, итак, мы находимся, итак, мы находимся на шоссе
из Лас-Вереса до Лос-Анджелеса, и нам нужно построить новый город, ну и теоретически, потому что в
реальности можно сразу начать, если пост.dis2 оказался нулем, то мы просто возвращаем, то есть
просто возвращаем в какой вершине мы находимся и не паримся, просто вот сразу, в противном же
случае нам придется создать новую вершину, так, как же мы ее создадим, а вот здесь нам придется рисовать,
так поехали, так, не понял, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой
ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой
указывает куда-то вот сюда
даже не так
позиция поз указывает вот рыженькая позиция поз указывает куда-то вот сюда и
нам надо это ребро посплитить
как мы это сделаем? нам просто надо очень аккуратно ввести обозначение
допустим вот эту вершину мы обозначим за В, а ее родителя
обозначим за ПВ
вот пойдет
вот видно
или может как-то или чтобы было понятие может как-то по-другому это обозначить
нормально хорошо еще мы знаем что как бы понятно что у нас тут под строка идет с LPR
а
должно вот то есть а что должно произойти должно произойти следующее
нет я пока только ребро сплитчу
нет суфтный слух погоди доживем еще до суфтной ссылки ой доживем вот
смотрим должна появиться вершина N, V
которая тут соответствует ребра от L до
чего-то а тут от чего-то до R
чего-то это R-Post.Dist
ну и тут соответственно R-Post.Dist
ну короче говоря чтобы не заморачиваться это будет называться mid
ну когда мы L отрезок делим на две части у нас в середине появляется mid обычно да
как пафосно звучит
да
как говорится где-то на Смоленской площади сотрудники гордо расправили плечи
сложный прикол да вот
да который в Москве находится на Смоленской площади вот
но это Сталинка такая наверное на ГЗ МГУ похожая вот
ну в принципе побывайте там красиво на самом деле вот
ну вот
ну и в МГУ да ну просто смотри там просто идея такая просто как как попасть в МИД очень просто выходишь на Арбат проходишь его там прям до конца
значит вы там выходишь на Садовое кольцо поворачиваешь там голову налево собственно видишь израменную высоточку это МИД
да но они не в конце но они не в конце Арбата находятся да
а уровень сарказма как всегда остается недомысливание да в прочем
хотя нет зависит от контекста
потому что как бы
на уровне стереотипов как бы не будет судите там правда это или нет и там считается что допустим там на уровне там там программирование там не очень сильно например
но в этом как минимум
в МГУ
в МГУ
ну вот ну а математики там наоборот как раз достаточно сильные ну то есть математика у нас тоже
ну ну матфак какой-нибудь да
я думаю там люди могут пересекаться в принципе
не кстати это надо смотреть у нас сейчас все андрей Городский у нас в случае там
продолжает то есть он там несколько лет назад он продолжал являться там заведующий кафедр математической статистики в угодной мехматии МГУ
господи спокойно да не берем они куда господи все мы успеем значит смотрите не волнуйся
ой
ладно значит хорошо хорошо в равно пост точка нодя ту нет я просто пока вводим обозначение
int p в равно
ну parent короче от вы
там l равно
но
господи
вот
но вот ну короче вот то что мы обсуждали то я и написал ладно
чисто теоретически есть крыша лайфхак потому что на самом деле вот это вот нодис от вы тут вызывается очень много раз
поэтому в принципе может быть оптимальнее формально звучит так но где нодя в равно нодис от вы
вот
поэтому тут вот и пи и вот так вот переменные после этого мы сохраняем
прям-то так и написать но девая точка
значит parent
но вот но видите для чего я это делаю это я делаю для того чтобы меня нодис от вы несколько раз не вычислялась
потому что там ну то есть скорее всего компилятор это крыша там как-то оптимизирует но есть подозрение что может нам и не повести
вот хотя конечно тут надо этим пользоваться аккуратно
потому что дело в том что мы тут как сейчас же как вы догадываетесь мы собираемся сделать pushback и
будьте внимательны когда мы сделаем pushback вот эта вот вершина торжественно инвалидируется
вот это вот ссылка в случае понимаете да
поэтому как бы да
поэтому конечно с точки зрения с многих точек зрения правильно так не делать я должен показать что как бы так теоретически можно оптимизировать но
делать так не будем
поэтому давайте вот так сделаем
вот
вот но вообще но так вот им всякий вот элер мы так на всякий случай сохраняем
вот
теперь вот видите вот именно вот по parent way видите то есть мы не по ссылке обращаемся специально сохраняем так вот
что нам теперь надо
теперь надо во-первых
создать новую вершину
то есть int nv равно ну давайте nv очевидно равно нодис точка size
да вот это мы все создали
так но давайте что
но да но вот но давайте соответственно pushback не но pushback у нас в общем-то тут классический вот я тут могу просто
где-то у меня этот pushback уже был я его просто скрипи пащу
вот
вот
то есть ну принципе понятно ему как всегда будет соответствует по строка тен инфинити
но правда родитель у нас будет теперь да тут тот же сам не в а nv
и суть с этой ссылки нету потому что это лист
да вы спокойно переписывайте даже возможно не подозреваешь что я вам наглую наврал
потому что это не совсем то
потому что лист нам создавать пока нет но потому что под строка то потому что это не лист мы создаем
мы создаем
что мы создаем мы создаем
мы создаем вершинку которая вот лежит на середине вот это вот nv и она не лист
и как бы подстрока ей соответствует вполне себе от эля да мидо на самом деле а родителем у нее является
пв и суть с этой ссылки у нее пока нет и
вообще желательно чтобы кстати переход из нее тоже должен быть
кстати вот внимание вопроса можно вот в этот мапчик на уровне инициализации прописать переходик не знаете
вот я тут могу написать какую-нибудь там вот там то есть вот я тут пару не могу написать какой-нибудь там
надо будет еще перед ней написать что это надо будет перед ней написать пэйер в угловых скобочках
хорошо
ладно children от nv
с мид очевидно теперь равно в атаке
но это я просто написал что из нее вот есть ребро по символу с мид
ну и конечно же я теперь должен обновить переход из пв по символу сл и он у меня равен чему
чему он равен да конечно вот
так что я забыл поправить
нет новое не заметил новое ребро добавлять это не это мы должны не в этой функции делать
чего ну да но заметим что в самой вершине в сведения а под строки родители резко
поменялись правда поэтому придется написать так parent от в теперь у меня равен nv
ну и придется написать нодис от в точка эр точнее это не поменялся а вот эль теперь равен мид
а что не так да вот
да только parent от в вот так вот так что такая штука у меня теперь получилось так что нам
теперь осталось но естественно нам осталось реализовать поиск суффиксной ссылки правда
вроде все что нам осталось значит поиск суффиксной ссылки ну суф тут все просто
хотя суф а ну вот он мы его даже уже написали это как бы в идеале бы хотели это да так но как
бы суфом там мы будем пользоваться немножко другим где мы им пользовались да мы написали
фунду должны цепь функцию getсуф но давайте посмотрим int getсуф от вершины вы ну и говорим
ну во первых сразу говорим что если вы равно root если вы это корень
ну вот или ну если она корень то сразу возвращаем минус 1 ну ладно минус 1 формально
ну ладно минус один так минус один ладно тут понятно вот возвращаем минус 1 если суф от
в не равно минус 1 то возвращаем просто суф от в логично да в противном случае мы тоже
возвращаем в противном случае тут очень аккуратно надо писать так int св равно calculate то есть
вычислить суф от в значит тут вот после этого написать равно св и ретурн св да вот казалось бы
почему я не могу написать тут ретурн суф от в равно calculate суф но это была одна из моих самых
но я по моему рассказывал уже про это одно из моих самых эпических багов в моей жизни то есть
если бы я если бы я тут написал как напрашивается нет нет вот так писать прям красиво нету можно
вообще написать хорошо я можно написать вот так хорошо но бага останется да с большим удивлением
узнаете что вы лезете в вектор находите там суф возвращайте на него ссылку то есть компилятор
вычисляет эту ссылку а потом запускает вот эту функцию в процессе которой вектор может
инвалидироваться и тогда вот на этот момент выяснится что у вас проблемы
точнее вот таки он вычислят присвоить ссылка инвалидировалась он возопил или по крайней
мере в лучшем случае просто присвоил куда-то не туда а в худшем просто возопил что у вас
все плохо ну для кого как вот но вот да поэтому да в чем боль того когда вы в дебаге в панике
пишите вот что-нибудь вот подобные тесве этом цер там блаблаблайство то внезапно бага исчезает
вот да то есть вы тратите полдня для того чтобы это понять вот поэтому тут над этим аккуратно
пользоваться ну или в худшем нет ну как для импят можно вообще конечно эти вершины в статическом
массиве хранить тогда вас никаких проблем не будет вот так то что все что нам осталось это
посчитать суфиксную ссылку правда это по-моему единственная функция которую мы не реализовали
ну давайте как ищет но вот калькулейт суф от инт в так ну давайте так нам нужно определить
по какой строке мы спускаемся интер равно нодис от в точка р и это надо было написать
равно нодис от в точка л вот по такой строке мы спускаемся правда так спускаемся мы откуда
конечно же из вершины какой-то но давайте так позицион поз мы идем из по позиции поз
так ну то два варианта если в в у нас бывает равно руту или не равно если оно не равно руту
то что-то нод то тогда у нас позицион поз будет равно к чему но к чему-то и нулю где что-то
это суф от пера от родителя суф от перонт от в вот а тут даже вот так тут кстати часто пишут вот так
противном же случае к чему делаем
не так но в противно вот хотя нет так не пойдет все-таки мы не будем тут баловаться
стандартными операторами лучше через выфы потому что если не равно рут то как бы поз равно вот
этому в противном же случае что мы будем делать в противном же случае идея такая идем мы по тому
же корню точнее так то есть условно то есть поз равно позицион от себя же и нуля только маленькая
проблема и елю мы прибавим то есть суть теперь заключается в том что мы должны спуститься в
дереве по подстроке lr из заданной позиции понятно да знаете обычно если вы там попадете в
какой-нибудь шат вам восточно в этом смысле на ревью будут пить больно по рукам и требовать
этот этот спуск вынести в отдельную функцию вот написано это будет вот примерно так то есть
функция будет подразумевать то есть вот это функция гол он говорит что мы находимся позиции
поз хотим спуститься по подстроке или гарантируем что это можно сделать понятно да а чем даже
неправильно она будет еще и спускаться по позиции то есть допустим пишем поз равно
гол он и ретурн билд ноде и в нит от этой позиции понятно логика да вот да да да святое дело
да ну и теперь пришло время гоу и лонга значит позицион go alone позицион позицион чем более того
кстати в принципе в будущем когда-нибудь вам может это и пригодится и интерь спускаемся по
подстроке или значит ну тут все очевидно ваил значит работаем ваил л меньше у вас r то значит
вам нужно куда-то пойти но во первых если у вас поз точка дисту не равен нулю то надо просто
пройти то как бы надо пройти на расстояние д которое равно очевидно минимумы из того что там
на этой дороге осталось и r минус л и плюс равно д ну и соответственно пост точка дисту минус
равно д может в принципе на этом мы и закончим в противном же случае нам придется выйти на
большую дорогу но вот в этом месте или меняться не будет а просто скажем что пост равно позицион
от чего пост точка но диту точнее нет пост но диту а children от пост но диту соответственно
с этого придется на эту дорогу выйти точнее так int nv точнее тут неправильно придется написать так
то есть куда мы идем мы значит записываем вот таким вот образом а поз от этой вершины равен
nv и соответственно нодис от нв точке минус нодис от нв точка л то есть типа вот вышли по хорошему
надо было видимо эту функцию тоже написать потому что мы это где-то уже где-то мы уже об этом думали
вот ну и в конце конечно просто ретурн поз ну вот в общем-то мы это и написали
красивенько вроде да но если вот так вот жать то получается вот такой объем кода
но правда обратим внимание я тут конечно может написал сильно там больше символов чем нужно
для каких-нибудь олимпиад потому что как бы я писал просто надежно аккурат после я как бы писал
просто мы надежно аккуратно максимально разделяя на функции половине случаев это в общем-то и не надо
ну когда как нет ну тут как привычно потому что давайте вам потому что ну-ка давайте прям
мне уже даже самому интерес сравнить обычно прям настолько так никогда не писал вероятно у меня
тут где-то хранится вот и попроще такой боже ванн мд босс у меня где-то было и ну-ка давайте-ка
господи так вот версия которой я писал четыре года назад но include суфик стрита было значит есть
надежно ну-ка опен так
нет это я показывал да видимо как положено то сейчас я как бы сейчас я уже как бы в детали
c++ не влезаю потому что как бы прозвать уж возле этого есть другой курс точнее вас уже был
ну давайте ну ну объем подопали полупом получился сильно меньше
да уверен да но до 23 так нет смотри тут 112 строчек тут 143 что там по моему был где где-то
я там 30 строчек сэкономил давайте думать где это еще в один год а ну вот где потому что вот
это вот вот это вот с плечи не ребра видимо я тут выписал прямо вот сюда видите да
во-первых я там вот этот лайфхак кстати с дополнительной вершины таки имел место это
была вершина номер один корень у меня был нулем так ну здесь по классике правда без
лзов правда но по классике вот так а ну я еще этих вот ведь лишних функций вот этих вот типа
одет вот это что-то там не писал давай сейчас раз у компьютера попробую быстренько и поправить
ой так хорошо на чуть позже так ну вот то есть принципе да тут альтернатива то есть получается
конечно да реализация в сумме конечно получается гадостная немножко но в принципе выжить можно тут
вот такая у нас получилось помочь чуть более красивая на самом деле но в том плане что у нас
просто все как-то так на функции просто поделено и в каждой понятно там более-менее понятно что
делается
так что вот такой вот так что вот такой вот не сильно сложный как выяснилось алгоритм
есть ли тут какие-то вопросы а у вас
да да да ну правильно да когда разминка в круэне да вопрос у меня простой вопрос почему и не
матрос да как говорится можно конечно надо кто-то быстренько пытался выскочить у меня простой
ответ потому что ты студент но вот но потом пришел суровый осетин и так она просто у меня
простой вопрос почему я не матрос вы матросов нет вопросов нет нет у матросов нет вопросов
презвестная фраза но в данном случае она просто тут ну честно говоря не знаю не вот ну не знаю
возможно просто так в народе пошла крейтариф может может про чем там была какая-то красивая
история когда она появилась может у матросов нет вопросов у матросов есть идея так то ладно
если нет вопросов ладно тогда я включаю интернет и мы сейчас попробуем тогда давайте до пилить
веселую задачку нет нет нет нет нет если вопросов по украину нет то с этим мы закончили дальше
дальше все что мы будем так что дальше в принципе могу же это микрофончик забирать там камеру можете
сворачивать а мы тут просто займемся техническими вещами ну вот ты вот сейчас спрашиваешь
