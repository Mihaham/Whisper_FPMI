В общем, получилось так, что в начале первой половины мы как-то очень сильно летели и прилетели к тому, что большинство курса сейчас сидит на задачах еще контрольных две назад прошлой и до темы, которая по идее сегодня должна была быть, это языки первого порядка, большинство еще не дойдут в развернутых задачах.
Ну, я поэтому сюда и пришел.
Да.
Поэтому давайте еще раз немножко вспомним, что было раньше, как-то попытаемся еще раз посистематизировать, и если у вас будут какие-то вопросы по прошлым темам, я еще раз их посмотрю, отвечу.
Итак, ну, в самом-самом начале мы поговорили про языки первого, ой, просто про формальные языки. На ОКТЧ вам рассказали такие базовые концепции теории множеств, там формализовали все базовые понятия теории множеств, ну не все, чуть больше таких вот понятий фундаментальных будет в следующем семестре матлогики.
То есть вот эта первая половинка ОКТЧ у вас войдет в экзамен не только по ОКТЧ этого семестра, но и в экзамен по матлогике следующего семестра.
Поэтому вот не думайте, что то, что читалось про теорию множеств, это какая-то фигня, полгода отучились и забыли. Нет, мы с этим еще потом столкнемся и продолжим это изучать.
Дальше мы поговорили про булевые функции, про семантику всего этого добра и теперь мы начинаем погружаться в синтезис.
Мы посмотрели исчисление высказываний, исчисление резолюций и это все на самом деле очень похоже.
Идейно у нас есть некоторая такая формальная система, в которой мы можем как-то доказывать факты и опровергать.
Ну опровержение это по сути доказательство отрицания.
У нас было исчисление высказываний и исчисление резолюций.
И там и там у нас были какие-то аксиомы, были какие-то правила вывода.
Было понятие вывода.
И главное, что у нас было, у нас было на самом деле три теоремы.
У нас была теорема корректности.
Второе это была теорема о полноте.
Это прям самые базовые две теоремы, что теорема корректности мы не выведем ничего плохого, а полнота о том, что все хорошее мы выведем.
То есть полностью все хорошее Fulmer вывели.
И третья теорема, это теорема компактности.
Теорема компактности, идея вот такая, что у нас, давайте мы не будем смотреть на полноту некоторой системы формул.
Полнота системы формул, что значит все хорошее, все хорошее.
Формально, в рамках выводимости, что у нас есть такой набор, даже, блин, я не знаю, как сейчас говорить без логики первого порядка.
Ну ладно, если мы зафиксируем набор перенесений, то мы не будем смотреть на полноту.
Ну понятно, что просто на наборе переменных выполняется, это значит, что если переменная та единица, переменная вторая тоже единица и так далее, следовательно то.
Вот такую теперь формулу нам надо вывести.
Вот что значит, если мы зафиксируем набор переменных, то на каком-то наборе переменных все формулы будут выполнятся.
И вместо того, чтобы смотреть на каком-то очень большом множестве формул полноту этой системы, мы рассмотрим на произвольных конечных множествах.
Просто потому, что у нас порой, да не порой, мы всегда, мы не можем рассмотреть на полноту.
У нас всегда в счетном заключается в том, что, ну вот, A верно, B верно, C верно, там, 2A верно, 2B верно, 2C верно, так вообще, пошли произвольные N A, N B, N C верно.
Ну и тогда мы такой, ну да-да, для этого мы будем смотреть на полноту.
Точно также идея теорема компактности, что мы рассматриваем в произвольные конечные pessim nor
Если там везде есть полнота системы, значит и на счетном этом множестве все тоже может быть компактно.
Более того, мы даже рассматривали, по-моему, не для счетного, а для произвольной мощности бесконечной.
Все эти три теоремы очень хороши, и само по себе исчисления высказываний, исчисления экзолюции очень хороши.
То есть, исчисления высказываний изначально мы вели для того, чтобы просто говорить о выводимости и истинности формул.
Исчисление резолюций у нас появилось для того, чтобы теперь работать более оптимально с тем же самым,
потому что для исчисления высказываний как-то выводить это все очень непонятно как-то гаритмически делать,
какая там будет вообще симптатика и что происходит.
А для исчисления резолюций у нас плюс-минус есть какой-то алгоритм проверки истинности формул и даже не выясненности, просто выполнимости формулы.
Но понятно, что просто задав какими-то булевыми операциями произвольные формулы, нам не хватит этого аппарата, чтобы говорить о произвольных объектах.
Например, в анализе мы уже в самом начале начали говорить про какие-то кванторы, более сильные предикаты, которые не про булевые формулы.
И идейно вот это стремление вести хотя бы кванторы, а еще по-хорошему вести произвольные функции,
которые оперирующие с какими-то качественными объектами, а не булевыми константами, еще предикаты навесить.
И вот вся эта идея приводит нас к новой такой формальной системе, которая будет называться исчисления предикатов.
О самом исчислении предикатов мы поговорим вообще в конце семестра, потому что пока мы будем к нему просто постепенно двигаться.
Для начала нам нужно, чтобы начать говорить про кванторы, предикаты, функции, нам нужно все это формализовать.
Что это такое, как это живет в синтаксическом мире.
И это делается следующим образом.
Как принято от логики, большинство определений мы даем индуктивно.
Итак, начнем с того, что выделим несколько классов объектов.
Странно, у меня что-то в конспектах, которые я готовил, я что-то не расписал, ладно, поехали.
Первый класс объектов это индивидуальные переменные.
Сейчас мы будем говорить про языки первого порядка.
Это то самое множество ВАР, которое я до этого уже где-то использовал.
Это очень хорошее множество, из которого если нам нужно насыпать переменных, мы можем брать сколь угодно, конечное число.
Потому что все формулы у нас все равно это косли конечной последовательности каких-то символов.
Дальше мы говорим про такую штуку как сигнатура.
Не знаю, на программировании вам рассказывали что-то про сигнатуры, но возможно вы уже слышали.
Например, есть такое понятие как сигнатура функции в программировании.
Сигнатура функции это название, описание аргументов.
И вот точно также сигнатура функции это описание аргументов, которые она использует.
Что может формула использовать? Она может использовать функции.
Она использует соответственно это функциональные символы.
Следовательно функции используют предикатные символы.
У нас есть предикаты.
Следовательно функции используют предикатные символы.
Особым случаем функциональных символов будут константы.
Это подможество функциональных символов.
Как нам... чем вообще...
Нет, давайте чуть позже про это поговорим.
Третье это...
Третье и так дальше пункты.
Третье это кванторы будут.
То есть теперь мы... что сделали?
У нас было изначально множество переменных, обязательно всегда.
Вот как тогда в формулах.
Теперь мы докладываем в вычислении высказываний,
когда мы определяли просто произвольные пропозициональные формулы.
Мы туда докладывали, как это делать.
То есть мы докладывали, как это делать.
То есть мы докладывали, как это делать.
Когда мы докладывали произвольные пропозициональные формулы,
мы туда добавляем то, чего нам раньше не хватало.
А нам раньше не хватало кванторов,
нам не хватало каких-то функций и предикатов.
Вот как только мы это все положили,
у нас стала чуть более большая широкая система,
в которой можно больше выразить.
А все остальное, как было раньше, так остается.
Что у нас было раньше?
Три операции.
То есть импликация, конъюнция, дизюнция, инверсия.
Пятое скобки.
Ну и еще, так как функции будут требовать себе перечисление аргументов через запятую,
нам нужно сказать, что запятую тоже мы разрешаем использовать в формулах.
Пятая.
Вот.
Формально вот все, что мы добавили.
А теперь нам нужно по аналогии с пропозициональными формулами показать, как мы вводили.
Давайте сейчас вспомним, что было у нас в пропозициональных формулах.
У нас было пустое слово, это пропозициональная формула.
Фи-Пси пропозициональная формула.
Следовательно, фи-конъюнция-Пси, фи-дизюнция-Пси, фи-импликация-Пси и инверсия.
Фи это пропозициональная формула.
Тут давайте вспомним в…
Вспомним о КТЧ и скажем, что такое у нас были предикаты и функции.
У нас было некоторое множество А, некоторое множество В.
И мы говорили, что функция это некоторое подножество Декартова произведения множеств.
Это некоторое подножество Декартова произведения множеств.
Такое, что у нас для каждого А из А существует и единственно Ф от А.
То есть, мы запрещали многозначность функции.
Все. Это была функция.
А предикатом у нас было просто множество А.
Предикатом мы называли произвольное подножество А в степени N.
И называли это Энарным предикатом.
Аналогично мы можем говорить про Энарность функции.
Если А есть произведение А1 на АН.
Ну или обычно будем говорить про функции, которые действуют просто из одного множества.
То есть, мы говорили, что функция есть из одного множества.
ну или обычно можем будем говорить про функции которые действуют просто из одного множества
будем говорить что а1 равняется это будет просто nt степень какого-то множества
но в общем случае понятно что у нас может один аргумент принадлежать одному множеству
а второй аргумент принадлежать другому множеству как перейти от такого случая к
случаю что мы действуем из одного множества давайте просто возьмем то исходное множество из nt
степени которого действует функция как объединение всех вот этих элементарных множества 1 так далее
а n дальше мы будем говорить что а равняется какой-то множество m в степени n
теперь следующий трюк заключается в том как мы будем переходить от предиката
к пулевой функции зачем нам это надо за тем что мы хотим как-то подставлять функции предикаты
внутрь пропозициональных формул для этого нужно то что подставили чтобы это было
бульва константа какая-то
ну давайте подумаем что можно сделать с функцией теперь будем описать вот так вот м в м на будет
понятно что с функцией как-то не очень хорошо единственный способ как действительно функцию
перевести в бульва константу давайте ее дальше преобразуем в нечто что будет действовать из mn
плюс 1 0 1 и будет говорить будет равняться нулю есть у нас действительно такое такая пара была
и если это будет 1 и 0 в противном случае но мы заметим что здесь было n здесь n плюс 1 у
нас уже поменялась арность поэтому говорить о каком-то хорошем преобразовании не можем мы
получили новый объект который идейно будет совпадать с предыдущим но это абсолютно новый объект
поэтому функции как-то подставлять явно в пропозициональные формулы мы не можем а что
с предикатами предикаты же это по сути просто некоторые подножество мт степени давайте
назовем это подножество подножеством п и я буду говорить это будет п и тогда мы можем заменить
подножество на что-то что действительно будет возвращать 0 единицу на что на индикатор этого
множества
индикатор это функция которая верна единицы тогда и только тогда когда условия верну и нулю в
противном случае то есть предикаты действительно мы сохраняя валентность сохраняя смысл можем
превратить в нечто булева а функцию нет ну и понятно что вот таким образом мы можем из
функции переходить предикатом путем повышение арности отображение
все теперь мы идейно понимаем что вот вместо фи и пси в исчислении языках первого порядка у
нас будут стоять какие-то предикаты теперь надо как-то формализовать все эти предикаты и что из
них получается для этого мы получаем две такие конструкции первая конструкция это обобщение
функции терм это по сути функция состоящая из функций
его идея заключается в том что мы разрешаем функции принимать на вход значение функции на
каких-то аргументах самым простым сучаем терма будет являться что ну просто индивидной
переменной когда мы к переменной ничего не применили никакую функцию первое множество
ар второе
мы можем подать какие-то константы
и третье мы можем имею уже какие-то там термы навесить на них функцию все равно получим терм
терм
под множество и так как то
т1 так далее тн это некоторые термы тогда у нас
в тире функциональный символ и нарный
обязательно и нарность то есть мы можем подставлять ровно то количество аргументов
которые функция принимает тогда мы говорим что f от t1 запятая tn это тоже терм
по поводу констант
мы говорили что константы это функциональный символ
но для любого функционального символа мы можем говорить про его
и нарность просто количество аргументов который он для себя требует вот какая
арность будет у константа ко какие идеи
ну да константа она не зависит ни от чего она всегда есть константа поэтому она нулярно
то есть и по сути в термах мы что сделали мы базис наш задали базу задали в не функции и
функции нулярны а вот эта штука позволяет такую своего рода арность если мы сделаем ее
глубиной
ну дерево посмотрим на откуда пришли аргументы функции и получим с такой
дерево разбора и вот если мы поговорим про такую арность в рамках еще глубины самих
аргументов мы позволяем ее расширять потому что изначально мы ну мы ничего не могли расширять
никак у нас было такие самые элементарные случаи все вот идея того что такой терм теперь нам
нужно поговорить про то что есть то что образуют предикаты у нас там там там там что происходило у
нас у нас глобально все равно будут получаться формулы поэтому назвать то что мы скомбинируем
из предикатов снова формулы мы не можем значит нужно придумать какое-то новое название но люди
не захотели особо заморачиваться и придумали название атомарная формула или просто атом
так этот атом будет происходить
у нас есть некоторые предикатный символ
п-энарный предикатный символ и в него надо подать какие-то аргументы что
будет у себя принимать что будет принимать инарный предикатный символ в качестве
аргументов но давайте посмотрим на определение предиката он будет принимать какое-то множество
значений из какого-то множества м а что дает нам какой объект дает нам значение из множества
м это термы так что давайте просто подавать в инарный предикатный символов n термов
п-т1 так далее п-т-н
т-и-т-е терм
тогда мы получили некоторую действительно атомарную формулу из
из предиката
а теперь имея элементарные бруски вот эти вот фи и пси мы ровно тем же способом просто говорим
поехали вот теперь формула
у нас была база балл забыла пустым словом ну понятно что теперь мы можем стартовать не только
с пустым словом но и из какого-то просто предиката он же по сути сам тоже некоторые
константа давайте начнем стартовать с него
да
но эти будут
дальше мы просто берем все что было раньше фи и пси принадлежит форм
следовательно фи конъюнция пси фи дизъюнция пси фи импликация пси не фи тоже формула
все хорошо но мы расширили возможность добавлением квантером поэтому нам надо как-то еще
разрешить использование квантеров делать сто третьим правилам новым что фи формула
следовательно существует икс фи существует икс пси тоже формула
может любой икс фи откуда у нас пси взялась спасибо для любого икс и условия на
то что такое икс икс тире это индивидуальные переменные просто иначе мы это не формализовать
что-то такое теперь все вот
таким образом мы смогли расширить наши определения и получить формулы в произвольном
языке первого порядка сейчас дай давайте я гляну на что у нас будет в контрольной
интерпретации будут значит начнем говорить про интерпретации
итогом
сейчас мы будем говорить про интерпретации поэтому давайте если у кого-то есть непонятки
с тем как мы формально определили что такое язык первого порядка и формула в рамках языка
первого порядка вот давайте сейчас их все разберем видимо нету хорошо тогда
можем спокойно говорить о том как нам вкладывать семантику корректно в подобный синтаксис
семантика будет это всего следующее мы вводим такую штуку как интерпретация
давайте только про сигнатуру добавлю сигнатурой мы считаем картеж из f f1 так далее fn
нет вру все-таки мы сначала пишем предикаты 1 pn f1 fn
давайте 1 и 1 и вот 1 и вот n
что будет обозначать подобная запись
1 pn это предикатные символы их n штук
сверху мы пишем в скобках верхним индексом их арность как только мы закончили определять все
предикаты мы начинаем определять функции f1 так далее fn эти функциональные символы тоже
имеют какую-то валентность или арность запишем аналогично сверху в скобках
тогда интерпретация будет заключаться в чем в том что у нас новая есть некоторый картеж
первый объект который нам нужно зафиксировать
первый объект который нам нужно зафиксировать это ну конечно же множество м мы вот про него
говорили что функции как-то действует из его некоторой степени в самого него и предикаты
действует из него в 0 1 поэтому давайте сразу фиксировать что за множество и
как только мы его зафиксировали мы начинаем интерпретировать а что
такое сейчас по ощущениям у меня где-то телеграма открыт и он мне просто по ушам так пилюкает
все
нам нужно интерпретировать что такое каждый символ предикатный он или функциональный поэтому
интерпретирование некоторого символа мы будем записывать в квадратных скобках и дальше
значок самого этого символа 1 и 1 так далее fn и n мы сказали о каким действительно предикатом
соответствует эти символы дальше у нас есть интерпретирование функциональных символов f1
и от 1 f и ам и от м все
по по по по по пом
тогда что есть из себя
п к и к это есть некоторая функция из м в степени и к
в булевые константы давайте не будем их считать обычными числами 0 1 мы специально их выделяем
булевые константы 0 1 не то же что 0 1 натуральные fк т й к т по определению это мы из множества
степени м й к т ведем само себя
таким образом мы можем дать некоторый смысл всем тем обозначением формули который мы ввели
но если посмотреть внимательно на определение формулы первого порядка мы забыли одну очень
важную вещь мы не сказали как интерпретировать например в кванторах эти ксы что это такое
давайте теперь ведем только понять как это интерпретация сигнатуры
то есть у нас была сигнатура f и п 1 и 1 так далее п и n и n f 1 и от 1 так далее
f м f и от м по ней мы построили интерпретацию кванторы как мы помним использовали себя под
капотом иксы которые из множества вар так я правильно понимаю что у нас сигнатуре по сути
любые наши символы которые задали могут лежать и вообще абсолютно любой номер даже не имеющий
сигнатуре может быть произвольные вообще значки которые ты хочешь ты можешь сказать что вот я
считаю букву а предикатом такой-то такой тайнарности все в рамках этого ты начинаешь
строить формулы понятно если я могу там условно говоря сигнатуры завести и написать там кучу
знаков там например равно больше равно меньше равно и ничего другого в частности все эти знаки
равно все знаки сравнения вот это все это действительно некоторые предикаты они должны быть
включены в сигнатуру и в общем случае у нас как мы помним из прошлой контрольной у нас нет
возможности в будущих функциях добавлять символы равенства а теперь мы можем спокойно всунуть
символы равенства в сигнатуру получить формулу которая будет действительно формулой со знаком
равенства вот мы проинтерпретировали как-то сигнатуру теперь нам нужно как-то вложить
семантику в множество индивидных переменных тогда это все также называется ну не также это
называется уже оценкой переменных вар по хорошем интерпретация сигнатуры тоже своего рода
отображение но не совсем отображение теперь же оценка вар в рамках интерпретации некоторые
будет называться функция пи действующие из множества вар в множество м
произвольная функция причем давайте не будем называть ее функции потому что это понятие в
матанализе часто используется и подразумевается что она может быть не определена где-то нет это
будет именно такое хорошее матлоговское отображение которое определено на каждом
аргументе и принимает значение только одно вот это оно ни в коем случае у нас нету такого что
для какой-то на какой-то переменной пи не определена она обязательно определена на всех возможных
индивидных переменных сколько бы их не было а их у нас счетно хорошо ну и логично что это
функция не обязательно будет инъективной потому что множество вар у нас счетно м можно взять
конечно м ну по принципу дирекле понятно что какие-то две переменные совпадут значение
на каких-то двух переменных совпадут хорошо оценкой мы называем произвольную такую функцию
без разницы какую именно вот тогда как теперь нам вложить семантику в производную формулу
первая порядка вот у нас формула
но прежде всего чтобы оценить ой чтобы интерпретировать как-то формулу нам
нужно зафиксировать интерпретацию дальше зафиксировал интерпретацию нам нужно в рамках
этой интерпретации зафиксировать некоторую оценку переменных
первое фиксируем интерпретацию дайте назовем это множество называется множество мы
надо не по уродски у меня получается писать маткалом для тех кто будет там
техать вот интерпретация ее обозначаем техе вот специальный весь красивый шрифт математики
как только вы где-то видите это маткал вот первое что мы делаем мы фиксируем интерпретацию даже
второе мы фиксируем оценку пи
да из интерпретации при этом взяв множество м а дальше начинается наше любимое начинаем
строить дерево разбора у нас было некоторая формула мы построили ее дерево разбора
и в какой-то момент мы можем прийти к чему мы можем прийти к переменной давайте в а можем
прийти какой-то константе как мы будем интерпретировать переменную как константу
переменную мы интерпретируем следующим образом это значение пи на в как мы интерпретируем
константу берем из интерпретации у нас там зафиксировано что это константа означает все
и начинаем теперь сворачиваться как мы можем сворачиваться первое что мы можем делать мы
можем свернуться по термам как мы сворачиваемся по термоitte Mouse так первые два пункта мы уже
сказали как теперь нам нужно определить что такое функциональный символ ёнарный от каких-то
А может быть вопрос, а у нас могут быть предикатные символы валентности ноль, ну типа булевые константы в формуле?
Да.
Ну так мы можем в теории и до такой штуки дойти.
Давай подумаем.
Тогда давай я сделаю так.
Почему мы не можем прям до них по-хорошему дойти?
Вот у нас формула разбиралась как что?
Формула мы дальше можем либо свесить квантор, либо разбить формулу на какие-то другие подформулы по логическим операциям.
И в элементарных случаях мы приходим к атомарным формулам.
А атомарные формулы, они берут в себя n штук термов.
Нулярный предикатный символ, то есть булевая константа, это ноль или один.
Она будет для себя требовать ноль термов.
Ноль это тоже число, поэтому как ты будешь интерпретировать ноль термов?
Для этого нужно сказать как нам интерпретировать термы.
Так что в том случае просто нам мы пришли с пустое множество.
Но как-то пустое множество тоже нужно интерпретировать.
А, ну да, ладно.
Все, поэтому сначала мы интерпретируем термы.
Я извиняюсь.
Сейчас 5 сек.
О, все произошло.
Так, у нас есть...
Оценка.
У нас есть некоторый функциональный символ n от t1 и т.д.
Мы хотим его интерпретировать.
Тогда что это значит?
Это означает, что у нас есть интерпретация этого символа.
f, n в ноль.
f, n в из и.
И уже сюда мы подаем интерпретацию термов t1 и т.д.
Мы до этого их уже где-то чуть ниже по дереву получили.
Все, теперь мы умеем интерпретировать произвольные термы.
Теперь нам нужно интерпретировать сами предикатные символы.
У нас был p, n.
Вот t1, tn.
Интерпретация его сейчас...
У нас p, n от t.
1, t, tn.
Все точно так же.
Снова p, n.
Из интерпретации берем и...
До этого как-то проинтерпретировали его аргументом.
Теперь у нас есть что?
У нас есть формулы конъюнции.
p, 1.
Атомарная формула 1, атомарная формула...
Ну ладно.
Формула phi, формула psi.
Конъюнция, дизюнция, импликация.
Мы интерпретируем как...
Проинтерпретировали сами phi и psi.
И применили к ним логические операции.
Отрицание phi...
Проинтерпретировали как отрицание интерпретации phi.
И...
Существует x.
Так, с...
phi...
Для любого x, phi...
И тут мы делаем то, что я рассказывал в прошлый раз.
Существует эта дизюнция по всем x из m.
Phi от x.
Только не так.
Давайте сейчас.
С оценкой...
Особой.
Особой.
Для оценки особой будет...
Для оценки особой есть...
Давайте я скажу так, что это есть...
phi, сечение на m без m.
Этого символа.
И...
Phi от x.
Phi от...
Сейчас скажу.
Сейчас.
Phi от var без x.
Phi от x равняется m.
Вот.
Идея на что мы взяли.
Мы взяли теперь из исхода наши оценки.
Выкинули...
Значение этой оценки на некоторой...
Переменной x.
А вместо x подставили значение m.
Вот.
Для каждой дизюнции.
Ну и аналогично точно так же здесь.
Только...
Только теперь берем конъюнцы.
Ну и на этом все.
Мы так сможем получить интерпретацию.
Исходные формулы.
Как строится интерпретация, оценка.
Все понятно?
Хорошо.
Тогда...
Еще у нас есть...
Все.
У нас еще есть одно важное определение.
Множество параметров.
Параметр формулы psi.
Как определить множество параметров?
Ну...
Я скажу сейчас.
Не формальное определение.
А дальше чуть более формально.
Поймем как это сделать.
Множество параметров формулы phi.
Это множество всех...
Сто всех...
Ну...
Множество всех...
Переменных...
В phi без...
Без тех...
По которым...
Стоит квантор.
Идейно...
Не буду прям выписывать определение параметров множества.
Что мы делаем?
В термах мы просто каждый раз...
Увеличим множество параметров.
Что если это переменная...
То множество параметров это само по себе.
Константы – это пустое.
Дальше.
Для такого терма множество параметров.
Это объединение всех таких параметров.
От термов...
Для атома у нас множество параметров.
Атома – это множество параметров.
Это объединение множества параметров для каждого из термов.
Для конъюнции дизьюнции...
и инкубликации инверсии...
Это...
объединение параметров для каждой платформулы, а в кванторах мы берем параметры платформулы phi и
ух ты, у меня нет phi, поэтому здесь phi, и из него убираем x. Все. Тогда у нас есть множество параметров,
мы можем как-то различать параметр, по которым стоит квантор, по которым не стоит квантор,
тогда назовем переменные, по которым стоит квантор. Свободные,
свободные, принадлежит параметрам, связанные, не принадлежит параметрам. То есть,
есть какой-то квантор, который связал эту переменную. И еще одно очень важное определение,
как в прошлый раз у нас было понятие тавтологичности, теперь у нас есть. Точно
также выполнимость, что существует, выполнимость это что? Существует интерпретация, существует
оценка, на которой формула верна. Теперь у нас есть. Существует интерпретация, существует оценка,
тогда если, вот так я хочу сделать, пропозициональная формула, первый порядок. Вот у нас была выполнимость.
Ладно, давайте я сделаю вот так вот. Как у нас была выполнимость? Существует выполняющий набор.
Теперь у нас, теперь вместо выполняющего набора, то есть своего рода фиксации значений, у нас мы
фиксировали значение при помощи ценки интерпретации. Значит, существует интерпретация, существует
оценка. Что такое выполняющий набор в рамках пропозициональной формулы? У нас все, если мы
их рассмотрим как формулы языка первого порядка, то все те переменные на самом деле это некоторые
предикаты. Тогда у нас будет интерпретация, в которой каждой каждому предикатному каждой
предикатной константе будет сопоставлено либо 0, либо 1. И вот эта интерпретация будет выполняющим
набором. Вот, поэтому чуть просто расширили, позволив, что давайте мы добавим какие-то аргументы
для формулы и скажем, что теперь если она выполнима, ну туда. Понятно, что я буду пока говорить не
совсем про выполнимость. Когда мы перешли к логике первого порядка, у нас по-другому чуть
начали называться эти вещи, но смысл их остался тем же. Точно так же у нас теперь тавтологичность.
Вот, что значит выполняющий набор? Ну, давайте Бух. Уберем его название выполняющим. Существует
набор, что интерпретация phi на нем это 1. Вот если мы теперь квантор существования заменим на
квантор всеобщности, то это получим тавтологичность. Но ровно так же и здесь заменяем квантор
существования на квантор всеобщности. Получаем, что если для любой интерпретации, для любой оценки,
у нас формула phi равняется нити, это в некотором смысле в своем тавтологичности. Но только теперь
мы называем это не тавтологичностью, а общей значимостью. Мы помним, что тавтологичность
формулы равносильно, даже не так, что тавтологичность формулы мы можем легко определить просто,
посчитав ее значение на каждом возможном наборе. Это какое-то экспоненциальное время, но мы можем
это сделать. А вот оказывается, что в общем случае проверять форму первого порядка на общей значимости,
задача неразрешимая. Формально, что это такое, это будет определено позже, но главное, что сейчас
понимать, что не существует алгоритма, который в общем случае проверит общей значимость формулы,
и более того, его существовать и не может. То есть, чтобы мы не написали, какую бы программу она не
проверяла, всегда найдется формула, на которой она корректно не отработает. Корректно не отработает
это, возможно, что она даст неверный ответ, либо она в принципе просто не сможет дать ответ на
эту формуле. Она не остановится никогда в учествии о числении. Ну и, так как теперь мы получили какие-то
кванторы, у нас чуть больше расширилось, мы хотим построить с его урода нормальную форму для формулы.
Для пропозициональных формул у нас были какие нормальные формы? У нас была конъюктивная нормальная
формула, дизюктивная нормальная формула и еще нормальная формула, которая называлась полиномом
Жигалкина. Теперь мы хотим аналогично построить какую-то нормальную форму для языков первого порядка.
Называется она pnf, предваренно нормальная формула. Как она выглядит? Что у нас сначала стоят кванторы,
а дальше стоят формулы без кванторов.
Также отметим, что когда я до этого писал все формулы с кванторами, я там после существует,
нередко писал двое точек, после любого писал значок, выполняется. Этого в нашей
формализации не определено. Соответственно, все то, что я до этого писал, не является формулой.
А правильным будет только навешивание скобок вместо вот этого добра.
Давайте посмотрим, как вообще переводить к нормальной форме, какой алгоритм. Для того,
чтобы приводить к нормальной форме, давайте я сначала скажу про понятие эквивалентности формул.
Фи эквивалентно си, буду обозначать вот такой значком тильда. Если фи следует си и си следует фи,
вот у нас теперь новая формула. Как мы помним, значок эквивалентности расписывается как конъюнт с
импликацией в две стороны и говорим, что это вообще значимое. Все. Так вот,
замена на эквивалентную формулу в предваренно нормальной форме осуществляется при помощи
нескольких элементарных преобразований. Первые два преобразования заключаются в
переименовании множества связанных переменных. Давайте один правило. Если у нас было для любого
x-ax, мы можем переименовать это все для любого y-ay. Аналогично 1b, про существует x-ax переводим в
существует y-ay. И с этим правилом надо быть очень внимательным. Оно работает только в том случае,
когда переменная, на которую занимаем, она уже является занятой. Что значит занятой? Что она либо
уже как параметр, тогда это нельзя делать, или, если по ней стоит квантор, это тоже делать нельзя.
Ну, к примеру, что если у нас было для любого x-ax, у, вот это вот не эквивалентно, конечно же,
что для любого y-ay. Потому что здесь наша формула зависела от множества параметров,
было y, а здесь оно стало пустым, уже не совпадает. Ну и понятно, что если у нас было что-то типа,
существует x для любого y, x, y. Вот это вот тоже что-то странное. Вот это вот прям очень
странная запись, поэтому так тоже делать нельзя. Теперь по аналогии с правилами,
чего там, правилами вывода, мы начинаем говорить про преобразование для каждого,
скажу, для каждой операции. Первая у нас операция всегда... что есть у нас есть для любого x,
то мы делаем своего рода закон Де Моргена. Не, здесь это, по-моему, конъюнция, соответственно,
как только мы выносим, конъюнция заменяется на дезюнцию. Существует x, ax. И аналогично 2b для
существования. Снова поменяли квантор, сохранили. Это у нас правило для инверсии.
Так, теперь у нас идут правила для конъюнции и дезюнции.
Если у нас есть одна формула, которая зависит от x, вторая формула не зависит от x,
тогда мы спокойно можем выносить квантор. Давайте даже не так. Можем выносить квантор.
И для любого и существует.
Так, готово, готово. Ну и не забываем оставлять скобки.
Так. Абсолютно аналогично будет, если я сделаю все для импликации и для
дезюнции. Давайте сразу запишу, что аналогично
4ab-5ab для импликации. Но только, да, все. Это мы знаем, как делать. Хорошо. Отмечу,
что надо быть внимательным с тем, что я пишу справа. Поэтому здесь корректно и для импликации
абсолютно так же. Но если у нас для любого x а от x средует b, то что? То это будет
эквалентно уже существует. Вот так вот. Это будет эквалентно уже существование x, а от x средует b.
Почему так? Ну мы знаем, что импликация это не a плюс b. То есть под капотом у нас лежит отрицание
для любого x, а от x следует b. Вот что у нас под капотом. По первому правилу мы можем сделать
существует x не а x, следует b. Тогда мы знаем про коммутативность дезюнции. Мы можем сделать b,
или существует x не а x, и дальше мы можем вынести квантор x. b или не а x. Ну а дальше мы все то же
самое приведем обратно и сведем к существует а от x следует b. С этим надо быть очень внимательным,
пожалуйста. И еще есть, ну давайте я не буду давать это правило. В этом году мы будем ограничимся вот
этими пяти правилами. Первые правила. По сути закон деморгана для кванторов. Второе, третье, четвое,
второе, третье, сейчас. Первое правило это замена переменных. Второе деморган. Третье, четвертое,
пятое внесение квантора из второго аргумента. На этом вроде бы вообще все. Если есть вопросы,
давайте их как-нибудь разберем сейчас и пойдем решать тренировочный вариант.
Это вот были озвучены сейчас правила приведения к нормальной форме. Да. Все вот их пять штучек,
их мы применяем, комбинируем с собой и получаем. Идея какая в приведении нормальной формы своего рода
алгоритма? Первое, что мы делаем, мы заменяем все возможные формулы на новые различные. После этого
у нас теперь получается каждый квантор будет действовать по какой-то своей различной перемене
от всех остальных. Чтобы она не совпадала ни со связанными уже имеющимися, ни с параметрами,
все. Она у каждого своя. Теперь как только мы получили каждую свою, мы можем по правилу двойки
вынести все кванторы из отрицаний. И после этого у нас останутся только простые операции типа
конъюнции, дизюнции, импликации, по которым мы можем вносить кванторы. Ну и что мы делаем? Мы
просто их используем. Ну давайте вот. Отдельно для этого случая я сделаю правило 6. А6б, даже не так.
3a, 3b, 4a, 4b- просто коммутативность с первого. А вот 5'a и 5'b будут уже
отличаться. То есть у нас было для любого x'a x'b. Эквивалентно существует x'a x'b и существует
x'a x'b. Переводится для любого x'a x'b. Мы еще добавим правила для другой компоненты.
Теперь у нас задачи будут какие? Там будет три задачи. Раз, два, три задачи. Первая просто на
то, чтобы определение роли. Две на интерпретацию уже. Это типа сложные задачи, не тестовые первые. Нет,
это тестовые. А, это вот самые простые, понятно. Да, это тестовые. Ну, тестовые не всегда самые простые.
Как мы помним, в прошлый раз была задача 33, которая сложнее некоторых развернутых. Поехали. У
нас для каждого символа a, b, c, d, x, y, n нужно определить. Давайте начнем смотреть. Если почему-то стоит
квантор, то понятно, что это индивидуальная переменная. Так что мы знаем, что у нас есть квантор по x,
квантор по y. x, y это тире индивидной переменной. Дальше нас будут просить, как конкретизировать,
как они свободно связаны ходят. Для этого мы смотрим в остальных вхождениях. Вот, например,
здесь для любого x будет действовать только на вот эту область. Если вне этой области мы не встретили
нигде x, то все супер, он войдет только связанным образом. Так и есть. Вот здесь у нас нету x. Значит,
x у нас будет только связанная индивидуальная. y, он не здесь. Область действия этого квантора вот.
Но он встретился там, где этот квантор еще не действует. Значит, он входит как свободным,
так и связанным образом. Хорошо, с y и x мы определились. Теперь смотрим,
что кванторы могут стоять только по предикатам. Значит, a и b у нас сразу предикаты. Как определить
валентность? Смотрим дальше в скобочках, сколько аргументов. У a у нас два аргумента,
у b у нас один. У d у нас один аргумент. Предикатный d1, а имеет валентность 2. Все. А решились,
d решились. Внутри у предикатов какие могут стоять? Внутри у предикатов стоят только термы.
Значит, b и c это либо константы, либо какие-то там функциональные символы, короче. Вот здесь у нас
b и c это все то, что входит в предикаты. Значит, это все функциональные символы. Задача определить
наша теперь только ехарность. У b два аргумента, значит b бинарный. У c один аргумент, значит c
унарный. А теперь вишенка на торте n. В целом, после того, как мы это сделали, мы знаем точно всю
информацию про предикаты, точно знаем все про функциональные символы, знаем все точно про
индивидные переменные. И у нас, если остались что-то, то это какие-то переменные. Вот, например,
n у нас осталось. Что в таком случае происходит с ними? На самом деле, а давайте без на самом деле,
какие ваши предположения? Что такое n? Константный символ? Оп, это именно то, что я и хотел слышать.
Нет. Да, n может быть действительно константным символом, если мы включим сигнатуру. Но n мы
можем и не включать сигнатуру. Тогда это будет просто переменная. Так же, как x и y. Ну, что-то
индивидная переменная, входящая только свободно. И снова нет. Вот, у нас есть два варианта, как мы
можем интерпретировать n. Мы можем n интерпретировать как константу, а можем интерпретировать n как
индивидную переменную, которая входит свободно. И правильным отвечать здесь. Данных недостаточно
для определения. Мы не можем точно сказать, n это константа или n это свободная переменная.
А что не хватает, чтобы определить, как должна выглядеть формула, чтобы можно было определить?
Ну, либо, сейчас скажу, как она должна быть. Ну, мы сможем по n сказать точно. Либо, если у нас где-то
встретится квантор по ней, тогда мы точно можем сказать, что это индивидная переменная,
как в случае с y. Вот, например, здесь у нас y стоял, по нему нет квантора. Но мы смогли понять,
что это индивидная переменная, потому что по ней стоит квантор где-то в другом месте формули.
Иначе, без интерпретации я тебе ничего не скажу. Без интерпретации сказать это,
какой символ я не взял. В зависимости от интерпретации он может варьироваться. Я могу подобрать
интерпретацию там, где это будет константа, могу взять интерпретацию другую, в ней это будет
свободным символом. А я правильно понял, что предикатные символы и функциональные,
отличаются тем, что предикатные идут сразу после кванторов, а функциональные это как
аргументы предикатных символов. Да. Ну, еще не обязательно сами предикатные символы будут
идти после кванторов, но может быть и без кванторов, что просто будет записано следовательно
D от X. Вот это D тоже предикат. Главное, что мы кванторы и логические связки ставим только
по предикатам. А все, что внутри предикатов, это функциональные. И, на всякий случай,
если опять дадут джести в этом году, внутри функциональных могут быть только функциональные.
Если вы только встретили какой-то символ из сигнатуры, то есть там дальше после него идут скобочки,
вот если вы встретите какой-то символ, после которого идут скобочки, и он внутри каких-то
других скобочков, это точно функциональный символ? Вот железно. А если вы встретили какой-то
символ вне скобок и по нему стоит там квантор или логическая операция, значит это оно. Значит,
это предикатный символ. Еще один частный случай. Ничего, мы докатились. Что если у нас есть А,
и дальше внутри уже что-то там. А1. Это предикатный символ, это мартная формула. Это предикат будет. Но
такого не будет почти наверно, потому что тогда мы не сможем вогнать какие-то логические операции,
и интересного ничего не будет. Все. Поэтому задача просто самый зеленый, который только можно.
Лутаем на халяву 0,8 баллов. Единственное сложное, это вот помнить про этот случай. Если вы запомнили
этот случай и внимательно его осмотрели, у вас сразу 0,8 баллов за контрольную есть.
Следующий номер будет про в каких интерпретациях верна формула. То есть,
на вам задана формула, задана интерпретация, вам нужно понять, хороша ли она, верна она или нет.
Поехали. Ну я обычно, в таких случаях, я вместо А, я просто записываю формулу без буква,
потому что она смущает. На сети натуральные числа А это знак меньше. Существует х до любого
у, что А, что х меньше у. Правда ли, что существует такой х, что для любого у он будет его меньше?
Ну конечно же нет. У нас есть просто ноль, меньше которого нету чисел натуральных.
Откуда мы знаем, что х и у это натуральные числа? Может быть х и у это какие-то элементы множества,
на котором вообще нет порядка. Мы откуда знаем, чему х и у принадлежат? Возможно я да, я по-моему
просто не сказал, как называется множество м. Вот когда мы зафиксировали интерпретацию сигнатуры,
множество м, это называется носителем. И вот как мы помним дальше, у нас интерпретация была,
это мы действуем из этого множества. Оценка переменных всех, это тоже мы поставляем каждой
переменной значение какого-то из зафиксированного множества, называемого носителем. Так вот теперь
у нас что здесь происходит? Мы говорим, что носитель натуральные числа. Тогда что мы сделали?
Мы говорим, что существует х из натуральных чисел. Давайте даже так. Существует х натуральным числом
для любого у. В натуральном числах выполняется, что х меньше у. Вот во что выродилась наша формула.
Аналогичный тут. Если мы это запишем по-матански. Сейчас понятно, почему мы говорим, что обязательно х и
у натуральные. Да, там написано было в начале. Да, супер. Верно лишь, что меньше равно. Да, здесь
будут какие-то факты а-ля теории групп, какие-то возможно геометрические факты. Вот это я не
люблю. И вот она началась. Носитель прямые на плоскости. Существует такая прямая на плоскости,
что для любой произвольной прямой на плоскости они будут иметь общие точки. Правда ли это?
Ну нет. Почему? Потому что на плоскости нет такой прямой, что она с любой другой прямой имеет
общую точку, потому что для любой прямой можно взять параллельную ей. Супер. Пожалуйста,
пункт В. Пункт Г. Носитель большие окружности на сфере, а означает имеют общие точки.
Большая окружность на сфере это окружности, получаемые сечением плоскостью, проходящей через
центр шара. Подождите, а мы сказали, что В это неверно? Да, это неверно. Тогда не надо обводить
всё. Г будет верно по идее, потому что у нас, вообще говоря, любые две такие окружности имеют
общие точки. Я в геометрии не силён, но да, это так. Ну, то есть, ну, как я делаю это? Ну, что, рисуем
шарик. Ну, вообще, это интуитивно понятно. Ну ладно. Ну вот да, у меня точно так же идея в том,
что, ну, интуитивно понятно, что будет выполняться. А если не знаешь, кто такие большие окружности на
сфере? Тогда нужно спрашивать на контрольный. А, то есть, так можно, если вот я не знаю, что имеется
в виду, то можно спросить. Ну, вам сто процентов сунут какой-то там факт геометрический с непонятными
понятиями. Если непонятен, спрашиваем, вам ответят. Понятно, что, ну, контрольная должна проверять
не знание геометрии, а знание математической логики, хотя последние работы будут в обратном.
Тут факт в том, что если не особо шарите за геометрию, ну, простите, у вас, возможно, будут беды на этом
задании. Ну, типа, я не знаю, почему это верно, но интуитивно понятно, что, ну, как мы не порисуем.
Большие окружности, это что ли те, которые по диаметру нарисованы? Ну да, это получается,
у нас есть вот центр, вот шара, и они получены сечением некоторой такой плоскости, проходящей
через этот шар, через центр шара. Не будем эти ужасные рисовашки. Ну, в общем, мы интуитивно
понимаем, что это верно. Почему к людям, шарящим за геометрию? Точки на плоскости, а означает,
находятся на одном луче, выходящем из начала координат. Ну, тут тоже все тривиально. Возьмем
X, точка в начале координат. И что будет верно, неверно? Тогда для любой точки Y она будет лежать
на одном луче, выходящем из начала координат, с точкой X. Да, все верно.
Ну, есть одно но. Если мы считаем луч закрытым, если луч открыт, то неверно.
А, открытый луч, это у которого начало выколот, да? Да. Закрытый луч – это ноль. Закрытый – ноль,
плюс бесконечность открытый. Я не знаю, ввел ли вам Лукашов уже понятие открытых множеств, но...
А, ну ввел. А, ну теперь понятно. Открытый называется луч, который открыт... Как множество? Закрытый,
который... Ну, не закрытый, замкнутый, по-хорошему надо писать. Ну, а тут вот вообще говоря не уточнено.
Да, поэтому тут опять надо идти и спрашивать, что именно имеется в виду. Ну, тоже опять-таки с
начальной школы определение луча – это изначально закрытый, все-таки замкнутый. То есть, мне кажется,
так надо иметь в виду. Насколько я помню, что было у меня в школе, когда это водилось,
это было давно. У нас было два луча. У нас был луч с проколотой... Ну, открытый луч и замкнутый.
У нас было два луча. Какой именно всегда у нас конкретизировался. Что именно здесь за лучом
умеется, да Бог его знает. В общем, сейчас я пока покопирую. Глобально задача проверяет ваше знание
геометрии. Если их нет, то тут ничего не сделаешь. Поэтому я... Сейчас пошли последние контроллеры,
их очень не люблю. Здесь нужно знать геометрию. Так, а если у меня вообще на прошлых контрольных
мало решено, то вот какие задачи по этой теме мне дадут? Вот эти три дадут? Это тестовые. Они будут
у всех. До этого будут задачи... Ну, посмотрим, прошлые контрольные будут задачи по выводимости,
по методу резолюции. Вот прошедшие их прошлые две контрольные. Теперь у нас что? У нас была
формула. Мы фиксировали интерпретацию, проверяли какая интерпретация хорошая. Теперь мы фиксируем
интерпретацию и проверяем насколько хорошая формула. В обратную сторону. Что у нас происходит? У нас
есть некоторые чумы, в котором есть один максимальный элемент, но нет наибольшего.
Для этого нужно вспомнить, как у нас в порядках было. Определение максимального элемента.
Какое у нас было определение максимального? Что существует такой x, что не существует y,
такого, что x больше y. Ну, то есть в формальных определениях раньше у нас было только 2k квантора.
На самом деле мы можем расширять возможность нашего языка путем ведения некоторого синтоксического
сахара. А именно, ведением квантора не существует. Квантор существует и единственный. Как делается
квантор не существует? Ну, это отрицание для любого. Квантор существует и единственный. Ну, если
существует и дальше для любого, мы говорим, что если так верно, то они совпадают. Эти два элемента.
Это то же самое, что существует x, что для любого y неверно, что x больше y. Наибольший,
наибольший мы называем супремумом. Существует x, что для любого y, x больше либо равно y. Теперь
внимание. Казалось бы две формулы. И очень часто хочется вот эту штуку переписать вот сюда. И вроде
бы, ну действительно, какое отрицание к тому, что x больше y. x не больше и равен y. Но в общем
случае это вообще неверно. Отрицание того, что не x больше либо равно y, это x и y несравнимы.
Или x меньше либо равно y. Вот вот этот вот важный случай, про него надо помнить. В частичном
порядке на множестве не обязательно все элементы сравнивы. Если у нас лум, то в линейном порядке на
множестве понятие максимум и супремума равносильно. Просто за счет того, что, как мы видим,
вот у нас это отрицание убирается в кейс, когда они не сравнимы. Вот. Тогда поехали смотреть. Вот
теперь все эти формулы будут так или иначе плясать от того, что мы здесь записали. Либо еще мы можем
что сделать. Можем вынести квантер вверх, что и получим идейно. Если мы вынесем отсюда квантер
вверх, мы будем не... Верно, что для любого x существует такой y, что x будет уменьшим.
Ну блин, я еще знак перепутал.
Я еще сижу и думаю, что это фигня. Вот. Да-да-да-да-да-да. Вот теперь корректно.
Ну теперь у нас есть какие-то наброски по тому формулам. Смотрим, как это
попробовали накомбинировать и где это сделали неверно. И еще обязательно помнить,
что ровно один. Я не совсем это понимаю. Как это? Ну то есть нет наибольшего. Значит,
у нас больше, ну в диаграмме Хасе условно больше одной компоненты связности. Но при этом максимально
ровно один. Сейчас-сейчас-сейчас. Нет наибольшего компонента связности. У нас... Стоп. Компонента
связности, она имеет смысл, когда у нас есть отношение к валентности. У нас здесь отношение
порядка. Можно нарисовать диаграмму? Например, я могу сделать как? Вообще этот баянистый
пример я не знаю, почему вам не рассказывали на доп-семинаре. Я в прошлом году когда вел,
это было первое, что я рассказывал. Здесь вот имеется в виду, что бамбук до бесконечности. Как
мы это делаем? Два в нулевой, два в первый, два во второй поехали, а здесь три. И отношение у нас будет
делимостью. Ну это про минимальный наибольшего. Для максимального возьмем просто проинвертируем
порядок. Будет два в первый, туда. Тут отношение... Ну короче, тут отношение кратности, делимости,
в каком... Какой именно без разницы? Вот у нас. Получается наш один максимальный элемент будет
тройка, потому что... Но наибольшего не будет, потому что... Потому что у нас как минимум три,
два не сравнимо. Вот пример такого множества. Это качественный пример, на него можно ориентироваться,
вообще его хорошо помнить, особенно к экзамену. Вот это надо заботить. Вот этот вот пример. А с
небесконечными множествами такое может быть? По-моему, нет. С небесконечными вообще по идее... Ну,
я, по-моему, даже кидал все-таки ту запись, я, по-моему, сохранилась, я ее не убирал про КТЧ. Мы
доказывали в прошлом году, что для конечных множеств наличие наибольшего и максимального
элемента равносимно. Ну, идея в чем? Если есть максимальный элемент... Сейчас. Сейчас скажу.
Если есть наибольший элемент, то он будет обязательно максимальным. Правда ли,
что один максимальный элемент будет наибольшим в конечном частично порядоченном, если он ровно
один? Если он ровно один, то что? Там, по-моему, короче, доказывается индукцией по высоте диаграммы
ХС. Ну, для одноэлемента множество очевидно верно, для множества n-1 плюс верно произвольного,
множество длины меньше n, тогда для множества длины n. Но пусть не так, пусть у нас есть ровно
один элемент, он наибольший. Давайте сделаем так. Я просто вывешу потом отдельное доказательство,
почему так, для конечных множеств. Единственный максимальный, равносимно наибольший. Я себе
запомнил, я просто потом выложу доказательство, почему это так. Пока на это тратить время не
будем, мне надо еще это вспоминать. Хорошо, давайте смотреть, что происходит с первой формулей. Нам
говорится, что существует такой x, но это очевидно, что вот, скорее всего, тот элемент, что неверно,
что существует x, что x меньше его. Все, вот эта штука, эта задала, что он максимальный. И
существует z, что неверно, что z, и существует такой z, что неверно, что z будет меньше,
если неверно, то у нас два варианта, что либо он z несравним с ним, либо z будет больше x. Но понятно,
что z больше x быть не может просто по-перему, значит z несравним. Есть несравнимый. Ну,
если у нас существует этот, который несравнимый с ним, значит он уже будет не наибольшим. У нас
есть один максимальный, который не наибольший, но нам не сказано, что он будет единицей. Поэтому
если у нас здесь будет таких два x, два несравнимых элемента, ну, например, я могу сделать что?
Я могу сюда добавить пятерку еще, то вот эта формула сломается. Во-втором, у нас снова вот
эта вот везде задана в начале максимальность. Что? У нас здесь сказана несравнимость. И теперь
для любой такой вершины v, что если v максимальная, то она совпадает.
Ну, то есть что? Сначала мы сказали, что существует максимальный, который не сравним с чем-то. А дальше
говорим, что для любого другого максимального, любого другого элемента, если он максимальный,
то это сам по себе x. Ну, значит это требование на единственность. Поэтому вот теперь b корректно.
В пункте v у нас существует элемент, он максимальный. И если для любого z из несравнимости с ним следует,
что существует больше его, то он не максимальный. Итак, у нас сказали, что существует элемент,
он максимальный. Если какой-то другой элемент несравним с ним, то он будет не максимальным.
Будет ли такая формула корректной? Про наибольший как будто ничего не сказано. Ну, смотри, в прошлом
случае, как мы получили на что не наибольший. Вот в пункте b мы получили что? Что есть несравнимый.
Он не максимальный. А у меня вопрос к слушателям. Сейчас только у меня интернет пропал или? Да,
у меня тоже пропал. Я ничего не услышал. Можете, пожалуйста, повторить? Понял. Вот в прошлой
формуле мы получили не максимальный, не наибольший за счет того, что мы сказали,
что есть несравнимый. Вот в пунктах i и b у нас была показательность того, что он максимальный,
но не больше, за счет того, что есть несравнимый. В пункте v мы говорим, что если элемент максимален
и для любого несравнимого мы говорим, для него должно быть верно, что он не максимальный. То есть,
по идее, мы как-то попытались схлопнуть с несравнимостью, и тогда он не максимальный,
значит он единственный максимальный. Ну, давайте не буду вас томить. Ответа здесь нет в силу того,
что здесь импликация, если он несравним, а что если у нас в принципе нет несравнимых,
тогда вот эта вся штука, она верна. И это сказано, что просто он максимальный. Максимальный во всем
сравнимом он будет наибольшим в луме. У нас по порядку действия, сперва импликация, потом конъюнкция?
У нас скобки. А, вижу, вижу, да. Вот если мы отдельно бы добавили требования,
что есть несравнимый, то тогда все было б супер. Пока у нас беды. В пункте G нас говорят, что он
максимальный, и существует, и для любого Z не существует такого, существует такое тэш, что...
А, но это просто по сути определение того, что нет наибольшего.
Вот у нас определение того, что такое супремум. У нас говорят, что здесь нету супремума. У нас сказано,
что есть максимальный, нет супремума. Опять же, нигде условия на то, что их не может быть два, у нас нету.
Пункт D. Это у нас нет супремума. А теперь что такое для любого V? Для любого V это как раз то
требование на... как бы мы раскрывали, квантор существует единственный. Что для любого V,
если тот максимальный, то он совпадет с ним. То есть это уже требование на то,
что существует единственный максимальный. А дальше мы говорим, что нет наибольшего.
Всё. Эта задача сама по себе не сложная, но тут можно накосячить, просто не прочитав,
например, тут требование про ровно один. А можно D помедленнее ещё раз? Ну смотри,
вот эта вторая часть, она про... это про наибольший, что его нет. Вот эта штука,
это что существует максимальный. А теперь что такое вот условие? Если для любой и для любой вершины V,
если она является максимальной, вот это требование, что если вершина V является максимальной,
то она совпадает с X. Это есть требование на то, что X единственным. Стало понятно или нет?
Да, спасибо. То есть тоже номер сам по себе не сложный, но надо быть внимательным,
могут засынуть неприятного. А вот на среду, на контрольной будет аналогично, но только другое
какое-то множество и всё, а так суть та же. Суть будет абсолютно та же. Пять формул задана вам
какая-то интерпретация, вам нужно сказать, какой-то формул не выполняет. На чуме именно. Или там может
быть что-то другое, не чум. Давайте. А это прошлое контрольное? Это из прошлого года или это нынешний
тренировочный вариант? Это из прошлого года тренировочный, скорее всего, будет в этом так же.
То есть номерация не совпадает, скорее всего? Да, номерация не совпадает. Но в прошлом году,
если мы посмотрим, там что было. Вот интерпретация, можно смотреть, что здесь,
вот у нас здесь чего только нет, здесь есть геометрия, даже там есть что-то про слова.
Вот в 2018 году было про два различных слова, два различных максимальных 19.
У порядочных хотя бы два минимальных 31. У порядочных есть наибольший, но нет наименьшего.
Ну в целом вроде бы, если бы работало правило индукции, то кажется, что в этом году должно
быть тоже, что есть какое-то частичное порядочное множество, для него и свойства про наибольшую
и дальше проверьте, что оно выполняется. Если действительно в этом году все так сохранят,
все так сохранят, то того, что нужно помнить про вот эти два определения и дальше просто подумать,
порисовать диаграммы, это будет достаточно. Если так, то задача вполне может претендовать на
зеленый цвет, но я не знаю, что будет в этом году, потому что в той формулировке,
о котором написали в чате, там было что-то типа, какие-то замкнутые формулы обозначают такое-то
свойство интерпретации, но понимаете, могут подобрать не обязательно интерпретацию как
частично порядочное множество и про максимальные, минимальные, наибольшие, наименьшие элементы,
но будем надеяться, что у вас все сохранится. Теперь PNF. Задача просто зеленая настолько,
сколько можно и решается за пару действий. Просто сейчас максимально быстро решим,
как она делается. Первое, смотрим, у нас вот X, он действует по этому переменному. Дальше Y,
по вот этой. Z действует по этой, X действует по этой. Дальше и все. Теперь смотрим, какие
перемены у нас остались. Все те, что остались, это свободные переменные. У нас остался Y,
у нас остался Z. Все. Тогда теперь я переименовываю все связанные на новые не повторяющиеся ни с чем.
Поехали. Для любого кси. А от кси Y. И существует Z. B, Z. Жух, жух. Следовательно,
не. Существует мю. Для любого ню. С, ню, мю. Или D, Z. Все. Теперь я переименовал на все свободное.
Значит, теперь я могу применять правила 2, 3, 4, 5. Поехали. Вот для первой штуки я прям могу
спокойно их вынести. Они различные, вторая штука от этого не зависит, поэтому я спокойно их выношу.
Получаю для любой кси. Существует Z. Кси Y и B, Z. Следовательно, во второй скобке вот у меня здесь
отрицание. Значит, я его вношу под эморгану вовнутрь. Существует мю. Для любого мю.
Существует ню. Неверно, что с, ню, мю. Или D, Z. Вынесу квантер из второго.
Не забываем, как я сейчас ставить обязательно скобки. Как только вы забыли скобку, вы получили
неформулу. Соответственно, у вас неправильный ответ. Вот здесь вот обязательно скобки должны
быть сверху. Сейчас, сейчас, сейчас, сейчас. Нет, здесь не... Сейчас. Я знаю, что меня просто смутило.
Ладно. В общем, видимо, правила на скобке можно опускать самые верхние. Здесь вот не стоит скобки,
вот эти вот две. По-хорошему должны быть, но их решили опустить. Ладно. А мы вот квантеры из скобки
с конъюнкцией существует в любой... В любом порядке можно выносить. Да. Да. Если они различны,
то выносим их в произвольном порядке. Если бы там были одинаковые, то мы можем в определенных
случаях выносить одинаковый квантер, но не будем о них говорить, потому что они скорее запутают.
Просто переименовываем все на абсолютно разные, и тогда мы можем в произвольном порядке вытянуть
верх. Я могу вытянуть так, могу вытянуть вот так вот и вот так вот. Просто мне больше нравится
вытягивать прямо по тому порядку, который есть. А квантеры во второй строке, они относятся только
к С, да? Где они не относятся? Если бы они относились к С, то смотри, то должны
было бы стоять вот так вот скобки. Так у нас скобки нету, значит они действуют только вот на это.
Все, теперь я могу из... Давайте, для любого X существует Z, а X, Y, Y, B, Z. Следовательно,
для любого mu существует nu, не C, nu, mu или D, Z. Теперь взяли, вынесли вообще все на самый верх.
Для любого X существует Z, для любого mu существует nu. Сейчас я не допонял, почему вы там поменяли
существует на любой до этого квантеры. А у нас было не любой, а вот так. Да, я применил своего рода
Ага, и он сразу к обоим этим квантерам действует. Ну смотри, по-хорошему как ему происходит. Он сначала
вот сюда идет, у нас выходит для любого mu, неверно, что для любого nu. Потом я второй раз
его делаю. А, понял. Вот, итак, мы можем произвольное количество раз просто их перещелкивать. И внутри
остается у нас формула, что A, X, O и B, Z, следовательно, не C, nu, mu или D, Z. Все. У нас вначале
стоят квантеры, дальше у нас квантеров не стоит ничего, значит мы получили pnf. А со второй на третью
строчку это какое правило? Со второй на третий я вынес nu и vines. Это получается, я применял
правило второе и какое там, четвертое. Второе, третье. Прямо если совсем все формально описывать,
то нужно на каждой новой строчке писать. Я так делал в прошлом году, интересно.
Вот как и так, вот идеальное в этом плане, идеальное описание того, как вы делаете. Сначала
мы пишем первый шаг. Переменовы связаны в переменные, сказали, что сделаем, записали,
все. Переменовав. Дальше теперь говорим, что в несении отрицаний под квантер,
значит у нас что было? Этих правил нет каких-то там названий крутых, просто так говорим. Просто так
говорим. Вот, например, да, надо было. Несение отрицания под квантер. У нас здесь есть отрицание,
говорим, что вносим отрицание под квантер. Взяли, внесли. Дальше что? Теперь мы говорим,
что в левой части выносим все квантеры в левой части. У нас были вот-вот-вот квантеры, вынесли,
получили вот. Помним, что при импликации квантеры с левой части должны меняться местами. Это все
сделали, все хорошо, вынесли, получили. Теперь говорим, что выносим квантеры из правой части. У нас
здесь только один, его вынесли. Все, получили предваренно нормальную формулу. Вот они везде так
будут. Переменовали переменные, внесли отрицание. Дальше из левой части, из правой части вынесли
квантеры вообще в цену. Вот они везде так будут. Даже вот в решениях. Это я все выложу,
можно посмотреть. То есть задача, она вообще максимально простая. Ноль думания мозга,
просто пишем, тратим бумагу. Формальное, ну то есть это то, что мы у себя делаем. Формальное
оформление, вот как там, как я показал. Оно самое хорошее, такое полное, формальное описание того,
что вы сделали. Копировать, вот. А теперь задача неприятная, прям очень неприятная.
Если у вас есть задачи, какие-то не очень сложные с прошлых раз, с прошлых разов делайте их,
на эту задачу забивайте. Чтобы в домашней потом еще сложнее было. Ну или ты просто потратишь
время в пустую, потому что, ну вот там есть задача же была, которая про, определите при каких Н,
в каких классах оно лежит. Ну успеть ее за время контрольной решать другие задачи,
ну это очень трудно, очень-очень трудно. И причем, что если ты хоть где-то, хоть одно не
описал, у тебя задача не решена, все. Поэтому я ту задачу очень не люблю. Эта задача тоже неприятная,
потом еще будет задача неприятная, буду говорить, что лучше их вскип, и если хватит времени,
потом сидим делаем. А может мы тогда лучше разберем с прошлой контрольной что-то, что у многих
не решено еще. Ну давайте эту сейчас глобально. Ну что происходит? Является общезначенная формула.
Логика у нас здесь будет точно такая же, как когда мы нас спрашивали про тавтологию, нас давали.
У нас сверху лежит какой-то знак. Мы смотрим, возможен ли случай, когда он равен нулю. Он равен
нулю тогда и только тогда, когда это ноль, а это один. То есть чтобы показать общезначимость,
нужно показать, что если выполняется все вот это, то обязательно и это тоже верно.
Значит мы показали общезначимость формулы. Давайте говорим, тогда мы говорим, пусть посылки
общезначимые. Ну даже не посылки общезначимые, пусть посылки верны. Тогда, так как у нас здесь
квантора конъюнции, тогда верно. Первое, что для любого x, a, x, x, своего рода рефиксивность.
Второе, что для любого x, для любого y, если a, x, y, то существует z, b, x, z.
И третье, что для любого x, а для любого y, что если b, x, y, то для любого t, b, t, y.
И в конце от нас хотят, что у нас существует x, y, что мы взяв x, y, применив а и b, и то и то
будет верно. Давайте делать каким образом. Если для любого x, а, x, x, если для любого x, а, x, x, то зафиксируем
x с чертой такое, что а, x, x, верно. Ну если для любого, значит для какого-то, вот все хорошо, вот мы
зафиксировали. Во втором случае у нас было для любого x, а для любого y. Но если там для любого x, а для любого y,
то и для x, вместо которого мы подставим наш фиксированный x и y, вместо которого тоже мы
подставим фиксированный y. У нас будет что? У нас будет выполнено, что а, x, x, следовательно,
существует t, существует z, b, x, z. Ну хорошо, если мы знаем, что а, x, x, верно, тогда существует z,
который мы положим за z фиксированный, что b, x, z. Снова зафиксировали какую-то
переменную. Теперь у нас b за z, верно. Если у нас есть фиксированный b за z, то если для
любого x, а для любого y, вот третье условие, то и для x, вместо которого мы подставим x фиксированный
y, вместо которого подставим фиксированный z, будет выполнено, что b, x, z, следовательно,
для любого t, b, t, z. Это верно, тогда мы имеем, что для любого t, b, t, z. Но если это верно,
тогда будет истинно, что b, z, z выполнено. Все, у нас что b, z, z выполняется, но а, x, x,
для любого x, а, верно, значит, тогда и для z выполняется, что а, z, z. А значит, если мы возьмем x
равный вот этому z и y равному тоже z, мы получим, что это формула истины. Все, значит, существует
такое x, а существует такое y, значит, формула общезначима. Глобально задача будет решаться
следующим образом, что она практически всегда общезначима, здесь будет импликация, поэтому нам
нужно, сказать, зафиксировать верность всех посылок, их разбить, и дальше мы говорим, что вот,
но если существует, выбираем какой-то фиксированный, потом для этого фиксированного подставляем для
следующей формулы, и так вот мы выводим. Какое в итоге у нас существовать будет, и подходить
под то. Все. Задача неприятная в том смысле, что нужно будет понять, как работает формула, ничего
такого, кроме этого, сложного нету, но разобраться в ней, это уже большая задача.
Ну давайте, вот, задачи из прошлых вариантов. Это в начале начинается задача из четвертой
контрольной проводимости. Там была задача про, в каком порядке уводится из гамма, на которой,
как я помню, много посыпалось, и у многих было там ноль. В чем беды? Давайте смотреть. В А у нас
есть такая штука, это аксиома 1, действительно. В Б у нас это не аксиома, по моду спонс мы
поменять не можем, соответственно, это что-то, что войдет в множество гамма. Все. Пункт В мы записали,
по сути, аксиома восьмую. Так, а мы в гамма запихиваем сразу всю формулу Б? Да. А мы можем,
и так вообще для любовей, или там в каких-то случаях оптимальнее будет запихнуть в гамма
какой-то кусочек, чтобы потом сразу две формулы были верны, чтобы оптимизировать, или так не нужно
делать. Смотри, ноль оптимизации. Мы решаем ДП. На каждом шаге мы проверяем, если вот алгоритм
следующий. На каждом шаге вот динамическое программирование чисто. Первые две формулы,
они либо аксиомы, либо, если это не аксиомы, то все, это обязательно джит гамма. Для всех остальных
мы смотрим, либо это аксиома, либо это вывелось по моду спонсов предыдущих, либо, если это неверно,
то это гамма. Все. То есть максимально в тупую делать? Да. Ноль оптимизации, не нужно думать
про то, что сейчас мы зафигачим алгоритм за алгоритм, там еще как-то там оптимизируем, у нас две
выполнится, то мы идем и прям в тупую на каждом шаге принимаем решение. Это аксиома, моду спонсов,
или гамма. Вот как раз тут беды пойдут от того, что мы начнем думать, что давайте сейчас вот
оптимизацию и дальше нам в следующем, в зависимости от того, какие следующие, мы сейчас прооптимизируем. Нет.
Мы не знаем ничего про следующие, мы решаем только на основании предыдущих. Максимально тупое
динамическое программирование за квадрат. Поехали. Это первое, у нас всегда будет аксиома. Нет,
первые две, они всегда, либо аксиома, либо гамма. Если это аксиома, то нам повезло. Если не аксиома,
не повезло, значит точно гамма. Первая аксиома, значит это аксиома. Вторая, это никакая не аксиома,
значит это точно гамма. Смотрим третье. Первое, что мы проверяем, что это аксиома. Это аксиома.
аксиома восьмая которая вот это дальше вот это вот это вот это вот она аксиома восьмая у нас
может быть усложненная аксиома то есть там вместо одной переменной которая в аксиоме может быть
какая-то формула здесь да да мы говорили тогда что на самом деле то не совсем аксиомы а схемы
аксиом что вместо а б и ц те могут поставляться произвольные пропозициональные формулы
вот точно также здесь мы поставили произвольные эти сейчас пропозициональные формулы вот пункт г
пункт г скорее всего практически вот все те кто посыпали посыпались на нем почему мы видим
что пункт г получается дважды применением моду спонанса с а и б чтобы применить дважды моду
спонанс мы должны записать вывод в вывод результат первого моду спонанса то есть
г могло бы вывестись по моду спонанс если мы применили моду спонанс к а и в получили
вот эту вот штуку и только потом применили моду спонанс к с б но мы не можем это сделать
потому что вот этой штуки у нас выводе нету а раз этой штуки выводе нету то по моду спонс она
ниоткуда не получится но если на нем откуда не получится по моду спонанс и аксиом и она тоже
не является значит это гамма все так а сейчас там же в результате применение моду спонанс два
раза у нас будет из двух формул отдельных выводится п просто почему нет в г сейчас ну
если мы г а сейчас я подумаю посмотри г мы можем вывести по моду спонанс если мы применим
сначала моду спонс об потом моду спонанс б в но как только мы применили моду спонанс а в мы
записали результат этого и потом к этому результату применили а вышел нас нигде этот
результат не записан а все вижу да поэтому у нас второй раз применять моду спонс мы не
можем у нас не к чему все то есть буквально как мы проверяем то что это моду спонс мы просто
смотрим по всем возможным парам до нее если хоть одна пара дала туда больше одного раза
применять не можем только по парам смотрим прям можно даже запрограммировать как это работает все
не аксиома не моду спонс значит гамма 6 аксиома пункт е откуда может быть получен единственный
способ откуда получить по моду спонанс это пункт е но у нас нету п значит это не моду спонс значит
гамма все но это очевидно что это не аксиома пунжа по моему мобом
пунжа мы получаем по моду спонанс из изгей зе хорошо пункт з откуда мы можем что получить мы
вообще нигде до этого такую структуру не встречали значит по моду спонс мы не можем
нигде получить значит просто проявим то что таксиома это не аксиома значит это гамма все на этом
этапе мы определили все возможные выбрали из этого где поставили с гамма получили ответ
есть еще какие-то вопросы
но то есть этот пункт очень простой его ну ничего и экстра нету про выводимость
оставим чуть позже это сделаем то давайте 38 пункт тут 37 там с ой какой идеей не прям
ладно бог с вами оставлю прям то что я решал у нас но первое что мы сделали первые 7
реза первых просто 7 дизюнтов это то что мы получили из исходной формы вот они 1 2 3 4 5 6 7
я просто писал так теперь я начинаю применять метод резолюции первое что я хочу делать я хочу
делать метод резолюции среди двухместных дизюнтов такой я могу сделать только один 1 и 3 я
получу куэр как только у меня больше не получается ничего вывести из двухместных дизюнтов я
начинаю применять двуместный трехместным так чтобы одна переменная склеилась и осталось
3 новых я немного не понимаю что мы делаем и зачем у нас есть метод резолюции мы хотим
проверить выполнимость этой формулы то есть мы хотим вывести либо выполняющий набор либо
вывести пустой дизюнт все что мы делаем первое пытаемся проводить резолюции внутри двухместных
так мы получим либо новый двухместный либо получим вообще одному одну переменную сейчас мы вот
мы ищем какие-то значения пе ку эр эс при которых у нас будет наш конъюнкт и дизюнк то есть
выполняться быть верно мы вообще задача такая что мы ищем значение переменных пе ку эр эс чтобы
вся конъюнкция выполнилась ну да это понятно промежуточные промежуточные мы промежуточные
тут опять задача на 0 включение мозга вот точно так же как и здесь 26 задачи вообще я я даже не
думал что она может быть не зеленый а это просто зеленый не включаем мозг не пытаемся ничего
оптимизировать точно так же и тут не нужно включать мозг не нужно ничего пытаться оптимизировать
просто берем и в тупую применяем как можно но как сколько нужно столько раз и применяем метод
резолюции начинаем с того что метод резолюции применяем к двуместным к двуместным вот внутри
1.3 пытаемся как-то провести метод резолюции например можно 1.3 получили вот куэр все как только
не получается ничего нового вывести начинаем применять двуместные к трехместным чтобы
переменные совпало вот например р и р здесь совпало чтобы нам получить двухместные не
заменить переменную какую-то получить трехместный а наоборот сократить его так вот я могу пополучать
85 вот у меня есть куэр и есть пятый я могу р оставить я получу не плр как только я получил не
плр у меня есть плр я сразу вывожу переменную чем раньше выведем переменную тем лучше
все я вывел р как только я вывел р первое что начинаю делать я начинаю бездумно избавляться
от этой переменной везде вот везде где есть не р я начинаю все упрощать я упрощаю что по по по
я начинаю прощать я начинаю прощать это упрощать это и получаю вот эти два дизюнта
все теперь я смотрю получилось ли у меня что-то хорошее пум-пум-пум-пум дайте посмотрим
внимательно получилось ли у меня что-то хорошее у меня сейчас одиннадцать ну да пока ничего
хорошего не получилось хорошо мне не получилось ничего хорошего но у меня появилось много новых
двухместных дизюнтов снова пытаюсь применить двухместный к двухместным вот например один
и 11 ну ладно я не так делаю ладно можно было 11 спущить не ps я применил 4 11 сейчас не 4 11
напомните пожалуйста как вот если мы узнали если мы вывели одну переменную какую-то как мы
упрощаем выражение с ней как мы упрощаем смотри вот у нас есть нер значит имея air мы можем
это убрать по методу резолюции а потому что у нас по сути r это то же самое что что сейчас что
пустая формула или или что сейчас ага по методу резолюции мы получим то есть да все вижу
вот так же здесь вот у меня есть что у меня есть ку и не ку или с есть не п или ку я проведу
метод резолюции по нему получу п или с также могу провести теперь что
сейчас прошу прощения четверо четыре
надо дичь тарю давайте сейчас мы долго будем понимать что дальше делал поэтому
вот есть не п не ку и с есть не п ку я беру их схлопываю в не ps беру один 11 не п или с
у меня вот мы видим что здесь не п или с есть не п или не с значит я из них выложу не п
об новый набор как только вывели какую-то переменную совет то отмечать сразу все
которые выполнено вот у меня здесь это был выполнен пайар теперь у меня не п меня выполняется
набор вот этот вот теперь и вот этот все у меня есть не п значит дальше я беру избавляюсь везде
от вот например я могу это избавиться давайте 15 я избавлюсь 414 от п получу ку или с хорошо у
меня есть ку или с есть не ку или с я беру сразу увожу с 11 15 я вывел с хоп смотрю что у
меня выполнилось у меня выполнился это и это и теперь последний шаг 17 у меня есть с из 16 и у
меня есть 2 ку или не с я могу вывести ку у меня это выполнилось у меня теперь отмеченными
галочками все эти дизюнки которые выполнились у меня выполнились все дизюнки значит я вывел
выполняющий набор то есть выполняющий набор какой будет п ку и с какие они должны
переменной применять не п это 0 ку это 1 1 1 понятно а там могла бы быть в теории
какая-то не выводимая формула или они дадут а как тогда это 4 это 5 должна быть 5
вот тогда что у меня выведется тогда значит я на каком-то шаге выведу переменную и отрицание
ага из этого нас выведется противоречие и причем мы это получить как сможем смотри у нас когда
мы отмечали выполнимость когда вот я отмечал когда отмечал галочками какие дизюнки выполняется
я проверял что все выполнимы и в конце я получил 4 набора переменных если какой-то из них у
меня оказался не помечен галочкой значит тогда в нем лежат противоположные литералы уже выведеном
тогда я смогу просто применив столько раз сколько нужно избавиться от всех этих переменных и
получить пустой дизюнк вот для этого я отмечаю галочками и еще раз галочками чтобы что галочками
я отвечаю отмечаю чтобы понять у меня выполняющий набор или мне нужно будет еще вывести пустой
дизюнк потому что как только у меня есть у меня в конце например получится так что будет формула
там плюс формула какая-нибудь там будет типа или неку или не р и она мне не будет помечена галочкой
потому что действительно всех этих переменных она не выполняется тогда я просто к ней беру и
применяю метод резолюции столько раз сколько нужно чтобы вывести пустой дизюнк потому что я
смогу избавиться от п смогу избавиться от ку смогу избавиться от r и получить пустой но в этом
сакральный смысл как это нам поможет решить задачу что-то не понимаю это не обязательно это
не обязательно зато у тебя ну так ты просто можешь чтобы понимать что действительно ли тот
набор который ты вывел он будет выполняющим возможно ты просто не сможешь быстро так вывести
отрицание переменной ты такой ну я вывел все переменные ну значит все молодец а возможно у
тебя что-то не выполнилось это вот точно будет нам гарантировать что мы корректно вывели
выполняющий если все перемены выведены то и любая комбинация из них легко разрешается насколько
я понимаю любая комбинация из них да а что если у нас изначально был какой-то дизюм в котором
было не из них а ну поэтому мы отмечаемся те которые будут хороши все спасибо да это
простой задача давайте с выводом 29 первое что я сделаю я сделаю это
я сразу проведу лемма дедукции даже не буду вот не буду тратить место на нее вот у меня
здесь есть формула я просто делаю лемма дедукции 29 это мы помним первое правило в этом этой штуке это
просто делать лемма дедукции все если нам нужно вывести отрицание то единственный то единственный
способ как это делать это брать правила разбора случаев правила разбора случаев заключается в том
что нам нужно добавить что это было сейчас я все скажу как оно правильно звучит я его открою
что если мы добавим эту формулу то мы сможем вывести какую-то перемен какую-то формулу отрицания
но я обозначу это гаммой не нужно будет показать что из гаммы а следует б выводится
некоторая формула и из гаммы а следует б выводится отрицание этой формулы для того чтобы понять что
за формулу делать нам нужно как-то там в гамме попытаться по приводить по наводить красоты
у меня там разве любого нет конъюнция таких ну первое что я могу сделать если у меня есть конъюнция то
эти из гаммы сделаю что я могу от гамма меня есть из гаммы выводится что у меня по правилу
по правилам вывода из дизъюнца у меня будет из гаммы выводится а или с и в среду с и отсюда я
смогу просто вывести гамма а или с и вот еще вот такую формулу я не буду сейчас писать особо
подробно вот то есть так дальше как мы помним у нас есть прекрасная схема с правилом разреза что
если из гаммы вывелось б из гаммы б вывелось а то из гаммы вывелось а заключается она в том что мы если
из гаммы что-то выводится мы можем это засунуть в посылке вот мы получили что из гаммы выводится
эти штуки значит мы можем досыпать их вот сюда даже вот это я сотру я сделаю следующим образом что
запишу гамма дальше а или ц б следует не ц и из этого всего должно должно выводится не а или б
я могу пополнить гамму выводом из нее дальше зачем я это сделал прежде всего для того что есть вот
такая вот формула очень хорошая и я могу применить к ней контрпозицию вот это с новой
значится дельта из дельта из дельта будет выйти на не ц следует не б потому что из б следует не ц
по контрпозиции выводится не ц следовательно не б почему это так ну потому что сейчас
ну я просто переформулирую у нас есть там было одно из правилов вывода как мы
помним было правило вывода что так вот тогда из этого водится гамма аб гамма не
выводится вот одно из разрешенных правилов вывода тогда я могу по лемме дедубца его привести к
форме вот такой вот ну и понятно что я могу вот здесь просто дописать что ну и даже не буду
и вот этот я не очень хочу писать явно я просто сокращу это до этого там нужно будет ну чуть
больше расписать там типа будет что что мы сверху сделаем тофтологически вот этот из этого
дальше ну поменяем по контрпозиции все теперь мы тогда сможем вот сюда навесить вот эту формулу
добавить в дельту дельта не не ц следует не б должно уводится что-то должно уводится не а следует
б пока вот да я сразу сказал что мы хотим в идеале потом добавить а следует б как-то
провести с этим операции но пока я не буду потому что непонятно что я хочу уводить у меня было ц
в исходной формуле здесь у меня есть двойное отрицание ц значит потенциально я хочу что
сделать я хочу вывести б не б для этого мне нужно вывести ц следует мне нужно из ц вывести не ц
отдельно вы выпишу из ц должно вывести с не ц снова выводим отрицание отрицание мы выводим
по правилу разбора в случае не ц должно вывестись что-то и ц не ц должно вывестись отрицание чего-то
но и трудно понять что это будет ц и не ц все вот автологическому выводу тогда я смогу
сюда добавить ц и провести моду спонанс там пару раз правила разреза через несколько
павелов разреза мы вот сюда добавим это не ц следует б и не б мы получим не б и вводимость
у меня есть не б заключательным шагом я захочу за использовать а или б а или б это своего рода
из не б следует а но действительно не не б или а то же самое что это и у меня есть не б значит
я смогу вывести а тогда что мне теперь нужно будет показать следующим образом что из а или
б должно выводиться не б следует а полиэмидидукции а или б не б вводится а как нам показать что это
у нас есть следующее правило правило называется левые дизюнции мы можем если а и не б вводится и
б или не б но слева этот автологический справа это право отвода и с отрицания все мы показали что
все это справедливо значит тогда мы можем вот сюда снова по правилу разреза дописать туда еще
где это написано я смогу еще дописать а я получу вот такое множество посылок
как только я получил попу попу как я хорош хорошо как только я получил такое множество посылок то
теперь у меня есть уже смотрите вот есть а есть не б есть а это очень хорошо потому что есть
простые перемены то теперь я могу уже придумать что будет делать правила разбора случаев извиняюсь
если я добавлю а следует б вот сюда я смогу получить по моду спонанс
б вывести а если я добавлю сейчас я смогу вывести б если добавлю но также я смогу вывести не
б просто как посылку а значит тогда я просто выведу а следует вот глобально то есть решение
какое будет мы повторяем все то что я сделал доводим до такого состояния посылок дальше
проводим правила разбора случаев и показом что из этого всего будет выведено не б тут уже какое-то
будет там множество на мега из него выведется не б из него выведется а б или не с него выведется
что б по моду спонанс тогда из этого всего мы получим по правилу разбора случаев там выведется
не а либо и тебе не понятно что я сделал тут туда тут очень неприятная задача но ок
вопрос да даже несколько первый вопрос какая вообще цель у задач что надо
показать выводимость у что это значит это значит что на истину нет нет что
значит показать выводимость ну нарисовать вот это вот дерево но оно к чему должно приходить
нанов внизу дерева будет написано выводится вот это вот формула но так он не в верху segundo
будет, по идее, тривиальные вещи, то есть из А выводится А, что-то такое. Вверху у нас будут
либо тавтологические выводы, либо выводы затрицания. Там типа, что я делаю? Где это было у меня? Вот
такого вот будет на листях. Ещё у нас могут быть там вверху моду спонансы. Ну и всё. Иногда
удобно будет сделать, выписать какие-то правила типа такого, назвать это правилом звёздочка и
просто потом в дереве сразу листья записать вот это вот. По правилам звёздочки. Потому что дерево
очень часто просто не будет помещаться в листе. То есть вывод нужно доказать, что это выводится из-за
аксиом и моду спонанс. Правильно? Что значит показать вводимость? Нам нужно предъявить
вывод. Вот мы записываем вывод. Ну вывод то есть из чего? Из аксиом и моду спонанс, правильно?
Не только, ещё и к другим правилам. Другие правила тоже из аксиом и моду спонанс. Ну в
глобальном счёте да. Хорошо. Дальше такой вопрос. Как построить план решения? Вот мы видим формулу,
нужно доказать выводимость. Как мы понимаем, что нужно делать? Ну план примерно такой. В 29 задаче
мы делаем как можно больше раз. Как можно больше раз мы делаем этот. Правила дедукции. Правила
дедукции. Как только произвели правила дедукции у нас справа либо всё останется хорошо и мы начинаем
слева. При помощи вот этого правила разреза, как я тогда показывал где это было. Наверное это было
в четвертой. Вот в конце я когда показывал прошлые дни. Вот. И мы берём как-то пытаемся внутри гамма
понавыводить всякого добра и чтобы потом использовать это добро вывести А. Либо у нас получится как в данном
примере. Вообще я в решениях прошлых лет когда выкладывал, там был пример. Либо у нас получится
просто справа отрицания чего-то. Вот как здесь. Трицание этого. Тогда наша задача будет сведена к
тому, что нам нужно применить правила разбора. То есть дописать вот сюда по ссылкам еще.
Надо вот ко всему этому дописать А следует Б. Вывести какую-то формулу и её отрицание.
Как понять это? Ну просто смотрим внимательно, нет там пристального взгляда. Общего говорить
нет. Вот если. Ну вот короче есть формула. В ней вот этот значок штопора. Получается решение
начинается с того, когда этот значок где-то в середине. У него что-то справа и что-то слева. А вот
у меня в контрольной было, что вот этот значок он появляется применением правила дедукции. Чтобы
это правило применить, нужна импликация в формуле. А у меня там не было таких импликаций, чтобы
применить правила дедукции. Получается я значок штопора не получил в формуле. И что тогда делать?
Ну я смотрел во всех вариантах. Он везде есть. Такого быть не может. У меня его не было,
ещё там у кого-то у моего одногруппника не было. И он там как-то начал разбирать по как-то
эти самые, типа, случаи разбирать. Это в какой контрольной? Это точно этот номер 2930? Ну да,
какой-то из них. Такого быть не может. Скорее всего, значит вы просто в скобках запутались и не
увидели. Он всегда будет. Просто так задачи-то построены. А чем разбор случаев отличается от
исчерпывающего разбора случаев? Тем, что в то, что разбор случаев мы можем использовать в обоих
номерах правила. Исчерпывающий, это вроде правила ТНД, его можно использовать только в 30-м. Да, его
нельзя использовать в 29-м, потому что он использует их все в 11-м при доказательстве.
А разбор случаев как-бы что используется? Я не помню уже доказательств. Там правило такое.
Правило разбора случаев, оно формулируется так.
Вроде бы он так. Да, это разбор случаев. А правило исчерпывающего разбора случаев
включить следующим образом. То есть смотри, правило разбора случаев. Мы выводим внутреннюю
и варьируем внешнюю. А здесь мы выводим внешнюю и варьируем внутреннюю. Ну и вот такая.
Ага, понял, спасибо. Их нельзя путать. Ох, 30-ю. Смотрите, как 30-е решается. 30-е решается следующим
образом. Вот у нас есть такое правило. Вот такая штучка. Нам нужно увести, это применил для
мой дедукции. По правилу левой дезюмции я могу здесь записать просто через запятую.
Теперь что, если я смогу вот это показать, то я могу сделать вот записать вот эту вот уводимость
сюда, дописать ее вот сюда и по правилу разреза я смогу показать, что это выведено. То есть смысл
тут правила разреза в том, что я могу эту формулу вывести из какой-то более удобной и тогда то,
что называется законом силы гизма, я смогу вывести эту. А это более удобно сила того,
что я смогу тогда применить два раза левой дедукции еще дополнительно. И моя задача тогда сведется
просто к этому выводу. Почему если я выведу, а сейчас скажу, почему если я приведу к этому выводу,
все будет просто. Я дважды применю лему а дедукции. Да, у меня здесь добавится а и b.
У меня есть, например, что у меня есть, например, вот такая первая штучка. Без разницы,
в самом деле. Есть такая первая штучка. Тогда я смогу записать первую аксиому добавить.
Или сейчас есть более хорошие правила? Ладно, да, его запретили. Так, по-хорошему,
блин, его бы добавил я. В b следует ab. Я могу добавить дальше. По моду спонанса и правилу
разреза я добавлю ab. Моду спонанс правила разреза я добавлю b следует c. b следует c по правилу
моду спонанса и разреза я выведу из этого c. Вот это ровно то, что остается справа у меня от
штопора. Поэтому будет все корректно. И смысловая задача тут просто в показательстве такой
выводимости. Вот это следование. Как это делать? Для этого, очевидно, нужно будет использовать
правила разбора случаев, потому что до этого оно нигде даже не использовалось. Здесь от вас хотят
использовать правила разбора случаев. Глема дедукции a следует b следует c. Выводится не a или не b или c.
Это трех переменных как-то сложно. Давайте посмотрим, что происходит двумя переменными.
То есть я хочу для двух переменных показать, что если b следует c, выводится не b или c.
Что мне добавить такого, чтобы у меня было справедливо вот это? Ну давайте я добавлю вот
сюда. Ну c и не c я добавлю. b следует c, c выводится не b или c. Но это просто аксиома какая у нас.
Ну это, короче, modus ponens плюс аксиома седьмая. А можно спросить, это последняя задача,
которую мы разбираем, да? Ну я еще одну расскажу, это опять последняя. Ну что там, ну просто я уже
идти хотел, я просто хотел спросить. В табличке по матлогу с результатами, там же вроде бы есть
задачи у каждого, которые ему дадут на следующий контроль. То есть можно посмотреть,
что у тебя будет, да? Ну все, спасибо большое за допусиминар. Не за что. Очень инфруктивно,
до свидания. Получается тут, а справа вот такая штука делается. Тогда что мне здесь делать? Я
могу, я могу, может мне уже написано где-то здесь. Да, я могу, например, сделать контрпозицию к этой
штуке. Я, идея на что, я просто применю контрпозицию к этой штуке, тогда я смогу записать вот сюда не
c следует не b. У меня есть правило. И я смогу по modus ponens вывести не b. А если у меня есть не b,
то я могу вывести это по аксимуме 6. Вот. И так я выведу из b следует c вот эту штуку. То есть что
получилось? Я просто добавил второй аргумент и смог из этого вывести. Аналогично тут, я буду
добавлять что? Я добавлю здесь. А, реально, что-то вообще туплю. Это все очень сложно. Я очень
плохо рассказал. Все плохо, плохо, плохо, плохо. Я добавлю b и добавлю не b. Как вы поняли, тут не
особо важно что добавлять, то это сработает. В общем, b и не b. Если я добавлю не b, то это все
по аксимуме. Если я добавлю b, применю modus ponens c, по аксимуме это вывелось. Все в разы проще.
Точно так же здесь. Я добавлю a и не a. Если я добавлю не a, то это автоматически вывелось. Если
я добавлю a, то я проведу modus ponens, получу b следует c. Тогда тут аналогично. Я добавлю либо не b,
все вывелось, либо добавлю b, тогда у меня останется c и c даст вводимость это по аксимуме.
Все. Так вот глобально решается эта задача. Если это чуть красивее записать через дерево,
все получится. А вот 37-й, он будет посложнее. Ну, давайте я это там оставлю, не буду писать.
Что происходит? От нас требует записать формулу, что
любое слово по горизонтали и вертикали ограничено черными клетками краем таблицы или краем таблицы
лежало в. Хорошо. Вот что у нас происходит. Давайте просто рассмотрим сначала для горизонтали,
для вертикали это будет получена просто перемена индексов. А мы уже разбирали, что 37-й. Да. Это
вторая задача в резолюциях. Это в прошлый раз было. Вот здесь просто нетривиальный ход пошел. Тогда
нам надо будет сказать, что зафиксировать края. Отрезочек мы хотим сказать, что теперь скажет под
отрезочек и это есть слово. Под отрезочек мы можем зафиксировать двумя переменными и вот таким вот
образом что. Один не больше и, не больше й, не больше н. И у нас есть правило, что либо и это
край, то есть ениция, либо предыдущая у нее черная. Основично для й. Сразу получаем проблему. У нас
нету понятия равенства в формулах. У нас не разрешены. У нас только переменные и будет операция.
Тогда вот эта проблема решается следующим образом. Мы разобьем это на четыре случая. Первый случай,
когда мы и зафиксируем за единицы. Значит здесь это просто выродится один меньше й, не больше n.
Нет, меньше n. Мы просто везде вместо и пишем, что там единицу. Дальше у нас будет случай и один
меньше й меньше n. И у нас дальше будут йоты. Либо один меньше и меньше n. Тогда вместо йот мы
пишем везде n. Либо вообще то и то это края таблицы. То есть и равняется 1 и йот равняется n.
Отдельно записали все для n. Вот такая вот будет формула. Разбили на четыре случая и избавились
тем самым вот этих проблем от равенства. Ладно. Хорошо. Дальше. Для каждого нас нужно будет проверять,
что это слово. Значит внутри нет черных. Как проверить, что внутри нет черных? Для любой
переменной. Такой, что для любой о не превосходит. Йот не превосходит. И у нас она не черная.
Значит неверно, что О плохая. Давайте просто ПМ. Все. И дальше нужно проверить, что это слово лежит.
Как мы проверим, что слово лежит? Сказать, что все в совокупности равны слову? Ну, это плохо.
Потому что это уже плохая длина. А вот если мы скажем, что существует слово, что каждого символ
совпадет с текущим значением, просто проитерировав, мы сохраним полинолеальную длину. То есть существует
такое слово, что для любого l меньше длины этого слова. У нас если этот символ такой-то, то у нас
на этой позиции 1, иначе на этой 0. Но у нас же нету переменных, которые говорят о том, что какое-то
слово вот оно равняется. Какая-то вот переменная равняется 0, а какая-то 1. Как решать нам такую
проблему? Точно так же, как в прошлый раз делали. Мы не можем что-то внести в формулу,
тогда давайте это условие занесем в итерацию. То есть мы сделаем отдельная итерация по единицам и
отдельную итерацию по нулям. Но у нас же само слово по отдельности может быть очень длинным. То
есть у нас сказано полином от n и от k. k это просто количество слов, а n это размер таблицы. А что если
у нас каждое слово само по себе экспоненты от k и n? Тогда идет в логику следующее, что первое,
если слово будет длины больше n, то в таблице оно однозначно не попадет. Значит нам уже не имеет
смысла итерироваться по словам длины больше n. Это первое ограничение. Как только мы это ограничение
совпали, то если мы начнем итерироваться по словам по длине n, по длине v, то мы сохраним
полиномиальность по n. Значит все в порядке. Вот мы решили таким образом проблему. Как только мы
начали итерироваться по хорошим v, мы сделаем что? Давайте итерироваться по таким i не превосходящим
длину v, что v и t будет равняться единице. Ну то есть мы пойдем итерацию по тем,
которых v это единица. Мы занесли эту логику в итерацию. Это можно. Все. Как только мы
начали стрелиться по таким, что нам осталось? Нам нужно понять, что на каких-то позициях у нас
должна стоять единица. Ну это просто у, там вот этот вот итератор такой таблица. Аналогично и по v.
Как нам понять в какой штуке у нас и это позиция в слове, а начинали мы итерацию с номера, ну блин,
не и, давайте q, а начинали итерацию мы с и. Значит здесь должно быть и плюс q.
Минус один, потому что у нас номерация в словах соединится. Ну и аналогично мы сделаем по таким,
что равняется нулю и будем требовать и плюс q минус один. Все. Вот так вот формула будет строиться.
Как это полностью записать? Может быть я позже пришлю полностью заполученную формулу,
она будет очень большой. Ну идея на так. На этом в целом все.
Тогда все, всем спасибо. Это я твой единственный зритель. Да.
