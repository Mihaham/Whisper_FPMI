Добрый вечер, у нас сегодня последний наконец-то дерево
поиска.
Красно-черное.
Я считаю, еще один из подходов к тому, как можно было бы
реализовать желаемый функционал, напомню, это основные три
операции Find, Insert, Erase, ну и сегодня еще одно, так сказать,
ультимативное дерево, которое все это умеет делать.
Потому что определение, корневое, бинарное дерево
поиска называется красно-черным, пока что все как обычно,
корневое, бинарное дерево называется красно-черным.
Если выполняются одновременно следующие пять условий.
Во-первых, все вершины покрашены в один из двух цветов, либо
в красный, либо в черный.
Каждая вершина покрашена в один цвет, ну в один из
двух цветов, красный или черный.
Во-вторых, корень всегда черная вершина.
Корень дерева черный.
Третье условие.
У нас, на самом деле, в этом дереве будут вершины двух
типов.
Вершины нормальные, в которых хранятся какие-то ключи.
Ну вот эта вершинка, и там в нем какой-то х, в ней
какой-то х, который является элементом нашего множества.
А будут еще фиктивные вершины, просто пустые.
Я их буду рисовать прямоугольниками.
Вот будут пустые прямоугольники, где ничего не хранится,
но чтобы все хорошо работало, вот они будут нужны.
То есть, на самом деле, вершины будут двух типов.
Нормальные, где хранятся ключи, и пустые фиктивные
прямоугольники, которые всегда черные.
Итак, вершины бывают двух типов.
Ну, обычные и пустые.
Обычные и пустые.
Так вот, у каждой обычной вершины ровно два сына.
У каждой обычной вершины ровно два сына.
А все пустые вершины черные и не содержат ключей.
Пустые вершины черные и не содержат ключей.
Именно что они не несут смысловой нагрузки в плане
хранения нашего множества, но это какие-то фиктивные
вершины, которые нужны для соблюдения свойств
дерева.
Например, если бы у меня в обычном дереве была бы
какая-то вершина, скажем, с одним сыном, если бы
у меня была такая картинка в обычном дереве, то чтобы
это было хорошее красно-черное дерево, поскольку мне нужно,
чтобы у него было два сына, я буду вот здесь довешивать
пустой прямоугольник.
То есть насильно буду у каждой вершины заводить
сына, если там чего-то не хватает, и у него будет
соответственно пустая вершина, которая будет обозначать
прямоугольником, и она будет всегда черного цвета.
Такая пустая черная вершинка.
Так, четвертое условие.
Не бывает двух красных вершин подряд, то есть не может
быть такое, что родитель и ребенок оба красного
цвета.
Как бы это коротко написать.
В и родитель В не могут быть одновременно красными.
Быть одновременно красными.
Ну и так для любого В, в смысле, никакая вершина
не может быть красной одновременно со своим родителем.
Да.
Ну, как обычно у нас дерево поиска, что это такое?
Это нам нужна структура на множестве элементов.
Да, да, вот элементы множества, это ключи у меня, да, я всегда
смешиваю эти понятия.
Вот, и пятое условие такое, что на любом пути от корня
до листа, до любого листа одно и то же количество черных
вершин.
На любом пути от корня до листа, от корня, ну, достаточно
требовать от корня, оттуда будет следовать, что от
любой вершины до любого ее потомка листа.
Значит, от корня до листа одинаковое количество
черных вершин.
Значит, ну, как правильно спросили, если это верно
для корня, это, на самом деле, верно для любой другой
вершины.
Вот представьте, у вас есть дерево, у вас есть корень,
вы понимаете, что какой бы вы путь ни рассмотрели,
количество черных на нем всегда одинаковое.
Ну, тогда если я рассмотрю какую-то другую вершинку,
скажем, вот на этом пути, v, то как бы я ни рисовал путь
в поддереве v, на всех этих путях тоже будет одно
и то же количество черных вершин, в смысле, да, потому
что если вот здесь, вот есть какие-то два различных
пути с различными количествами черных вершин, тогда, если
их продлить вот этим вот префиксом, этим началом,
то и тогда на этих путях будут разные количества
черных вершин, да, поэтому требование про корень оно
вылечет требование, что для каждой вершины, вот
если вы встали в вершину и как угодно идете до какого-то
листа, на любом таком пути одинаковое количество
черных вершин.
Определение.
Хорошее?
Мне тоже нравится.
Вот, не будем задаваться вопросом, как это можно было
придумать.
Давайте докажем, что с этим все работает.
Значит, простая лемма.
Ну, во-первых, давайте я введу определение bh от
v.
Это черная глубина на black height вершины v.
Что это такое?
Вот у вас есть вершина v.
Мы уже обговорили, что любой путь из v до потомка листа
всегда имеет одно и то же количество черных вершин,
так вот пусть bh от v это то самое количество.
Вот сколько здесь на этом пути черных вершин?
Значит, формально bh от v это количество черных вершин
на пути, ну, как бы на любом пути, имеется в виду на
любом пути от v до листа.
Давайте я для удобства скажу, что не считая v, не считая
v.
То есть, если v черная, то я ее не учитываю в bh.
Да.
Вот если предстоит такое дерево, что корень, слева
лист, справа вершина, а в вершины лист.
Вот так?
Так.
Ну, тогда и здесь тоже должен быть лист, потому что мне
нужно, чтобы в вершины было обязательно, если вершина
обычная, то есть с ключом, то там у нее два сына обязательно.
Это нормальное дерево, да.
Листья у вас всегда фиктивные элементы, листья это те,
у которых нет детей.
Зависит от цветов, потому что bh количество черных
вершин, ну в зависимости от раскраски, там bh может
быть какой-то.
Да, какой вопрос?
Здесь для любой могу определить, потому что еще раз, если
у меня для корня это верно, то есть если от корня до
любого листа, скажем, k черных вершин, на любом пути от
корня до любого листа, вот у вас везде k, тогда если
я фиксирую любую v другую, скажем, отличную от корня,
то в ее по дереве тоже на любом пути должно быть
какое-то m одинаковое количество черных вершин, потому что
иначе было бы два разных пути, которые можно было
продлить до корня, тогда на этих путях было бы разное
количество.
Так, то есть я просто ввожу вершинку и считаю количество
черных на пути, на любом таком пути вниз, оно будет
одинаковое по пятому свойству.
Значит тогда в под дереве v находится хотя бы 2 в степени
bh от v минус 1 вершин.
Ну то есть наше любимое соотношение, что размер экспоненциален
по глубине, значит наоборот глубина логарифмична по
размеру, отсюда и будет следует, что глубина всегда
маленькая.
Вот, ну доказательства, здесь правда простая индукция,
а правда индукция не по черной глубине, а по обычной
глубине вершины v.
Доказательства, индукция по глубине, давайте даже
подчеркну, что не черной, а обычной, не черной, а обычной
глубине вершины v.
Ну значит база, давайте скажем, глубина h, h от v равно
1, да, это когда у меня просто одна вершина, такая, что
у нее в под дереве ничего нет.
Но если это вершина, и у нее в под дереве ничего
нет, значит она сама по себе лист, поэтому она обязательно
фиктивный элемент, без ключа, раз у нее нет детей, то это
обязательно фиктивная вершина.
И вот здесь я обманул на самом деле, мне нужно не
вершин, а ключей, ну или тоже самое обычных вершин, потому
что у меня вершины есть нормальные, есть вот эти
коринжовые, которые пустые, я хочу нормальные, в смысле,
которые содержат что-то.
Мне нужно оценить количество ключей.
Так вот, если у меня вершина находится на глубине 1, ну
в смысле глубина ее под дерево 1, тогда значит у нее просто
нет детей, значит это фиктивная вершина, пустая, значит она
черная, у нее ничего нет, ключей здесь 0.
Ну если мы посчитаем 2 в степени 1-1, как раз получится
неправильно что-то.
А нет, нормально, нормально, нормально, значит bh в этом
случае это 0, потому что любой путь от этой штуки
до потомка содержит 0 черных вершин, потому что я ее
саму не считаю, я в bh саму вершину не учитываю, поэтому
черная глубина у меня здесь 0, 2 в степени 0-1 как раз будет
0, значит база вроде верна.
Нет, по дереву сыней, но поскольку здесь нет ключа,
то здесь 0 ключей.
Переход от h к h плюс 1, ну пусть есть какая-то вершина,
глубина под дерево которой h плюс 1, значит это обязательно
обычная вершина, у нее есть два сына, давайте поймем
какие у них черные глубины, вот если здесь была черная
глубина bh, ну тогда наверное понятно, что в обоих вот
этих поддеревях черная глубина хотя бы bh-1, потому что
у меня разве что только одна вершина отбрасывается.
Ну значит тогда наверное суммарно в этом поддереве
ключей будет хотя бы 2 в степени bh-1 плюс 1, это вот
здесь вот в левом поддереве плюс то же самое для правого
поддерева, вот здесь вот хотя бы столько по предположению
индукции ключей, ну еще плюс 1, потому что мы сказали
это вершина обязательно является обычной, то есть
не эффективной, в ней хранится какой-то ключ, ну вот если
все здесь, так, извините, минус 1, а извините, минус
вот этот минус, а минус сюда перекочевал, все нормально,
вот, ну здесь что-то сокращается, степени двойки превращаются
в одну степень, 2 в степени bh и как раз минус 1 осталось,
переход сделали.
Да, конечно, ну конечно, имеется в виду, что там t красно-черное
дерево, бла-бла-бла.
Нет, смотри, я имею в виду, что есть какое-то большое
красно-черное дерево, я в нем рассматриваю все поддеревья,
и дальше я фиксировал какое-то v, рассматриваю поддерево
этой вершины, само по себе это правда, но само по себе
не обязательно красно-черное, потому что v может быть красным,
это, конечно, единственное, что может нарушиться, ну
неважно, я говорю, что для поддеревьев красно-черного
это верно, ну и здесь я везде работаю в поддеревьях и,
соответственно, переход с поддеревьев в поддерево
все нормально.
А тут я нигде не писал, где глубина, я черную глубину
только пишу.
Ну там h, h это было вот это, а стало h плюс 1 вот это.
У меня глубина и черная глубина это разные сущности,
глубина это просто количество вершин на пути, а черная
глубина это количество черных вершин на пути, поэтому
это разные вещи, и здесь мне не важно параметры h, мне
важно только, что он уменьшился, и я могу к обоим поддеревиям
принять подражение индукции.
Ну вот, значит, и отсюда немедленно получаем такое
утверждение, что в красно-черном дереве с n ключами глубина
не превосходит удвоенного логарифма вот n плюс 1.
Ну доказательства.
Нам надо соотнести глубину и черную глубину, поскольку
у меня есть лемма для черной глубины, а здесь речь идет
про обычную глубину, мне их надо как-то соотнести.
Ну вот представьте, было у вас красно-черное дерево,
напомню, глубина это просто количество вершин на пути
максимальном, а черная глубина это, конечно, черных
на таком пути.
Вот вопрос, как они соотносятся.
Ну, можете ли вы мне сказать какое-то неравенство, как
можно h оценить через bh?
Меньше 2 bh.
Да, давайте я немножко вот так перепишу, я напишу,
что bh больше на h пополам.
Да, вы правильно сказали все, я вот так просто напишу.
Почему?
Потому что на любом пути у меня нет двух красных
подряд.
Одно из свойств, что нет двух красных подряд.
Значит у меня минимально возможное количество черных
вершин на любом таком пути, оно хотя бы половина от
общего количества.
Причем, если я знаю, что я еще и начинаю с черной и
заканчиваю с черной, они там максимум чередуются,
как раз таки черных будет хотя бы половина.
Ну и все, дальше утверждение леммы, значит вот это мы
показали, что черная глубина хотя бы аж пополам, а дальше
по лемме мы понимаем, что количество ключей, которое
равно n с одной стороны, с другой стороны больше
либо равно 2 в степени h пополам минус 1.
Ну и отсюда в точности вот то неравенство получается.
Ну а раз n больше, ну чем вот эта штука, значит n плюс
1 больше либо равно 2 в степени h пополам, вот логарифмируем
по основанию 2, умножаем эту двойку, переносим сюда
и как раз получается, что двойный двойческий логариф
больше либо равен h, да, ну вот, несложно.
Получается, что если мы каким-то образом добьемся соблюдения
всех вот этих вот пяти свойств, у нас как обычно автоматически
будет неглубокое дерево, да, два логарифма, это вполне
себе хорошо.
Вот, значит в частности, тогда, например, на find мы
автоматически отвечаем за от логарифма, потому
что find в дереве поиска всегда работает за глубину дерева,
мы просто идем, понимаем, куда надо идти, поэтому
у нас find уже автоматически работает за логарифм.
Вот, осталось понять, что делает синцерт и мейерейзом.
Ну, будем сейчас это делать.
Ну, давайте insert x.
У нас то же самое, это же дерево поиска, видите, я даже
написал, что дерево поиска, поэтому нам надо как обычно,
если мне нужно найти x, я сравню x с корнем и иду
либо в лево, либо в право, тут все как обычно.
Вот, как будем делать insert?
Смотрите.
Ну, давайте сначала попробуем сделать, как это мы делали
в обычном дереве поиска, вот встали в корень, идем,
ищем место, куда надо вставить x, вот идем, идем ищем, соответственно,
если x меньше, чем текущее значение в данной вершине,
идем налево, значит идем направо.
Вот, так мы в какой-то момент дойдем до позиции, куда
в идеале надо подвесить x, в нашем случае эта позиция
обязательно будет фиктивным пустым листом, потому что
я когда спускаюсь, я заканчиваю свой спуск, когда в вершине
ничего не хранится, то есть когда я иду-иду-иду в какой-то
вершине, скажем, пошел налево, а здесь уже все, здесь уже
тупик, тут нет элемента, нет ключа, насчет фиктивной
вершины.
И вот сюда мне в идеале, мне бы в идеале просто сюда
x написать, было бы вообще шикарно.
Ну, я не могу писать x в пустые вершины, поэтому придется
это повозиться.
Ну, давайте сделаем так, давайте я, в момент, когда
мне нужно такую штуку сделать, давайте я нарисую здесь
красную вершину x и подвешу к ней два фиктивных черных
сына.
Сейчас будем это чинить, да, у меня могли нарушиться
какие-то из вот этих свойств, сейчас будем их чинить.
Ну, по умолчанию я нахожу место, куда надо поместить
x, вставляю его туда, крашу красным и подвешу к нему
двух черных сыновей, ну, как и надо, да, потому что
если у меня нет детей, то значит мне их нужно подвесить
и сделать их черными обоих.
А если мы окрасим в черный цвет эту вершину, то ничего
же не нарушится?
Может нарушится вот эта штука про черную глубину,
потому что вы взяли, точнее она точно нарушится, вы
взяли и на этом пути, если она будет черная, вы на этом
пути увеличили черную глубину, потому что здесь была одна
черная вершина, был фиктивный черный лист, а вы взяли
и его увеличили, вы взяли, продлили, ну, как бы еще раз
двойли и увеличили черную глубину.
Я же изменил дерево листов, там.
Да, ну, смотрите, вот у вас был корень, у вас была какая-то
другая ветка, на которой там черная глубина какая-то
BH, и на этой ветке тоже была BH, если вы просто ее сюда
подвесили, то вас нарушили с условием про черные глубины.
Поэтому, чтобы как раз сохранять черные глубины, мы вставляем
красную вершинку.
Вот, значит, как правильно заметили, у нас может нарушиться
четвертое свойство, то, что не может быть одновременно
две красные вершины подряд, то есть может быть такая
проблема, что вот этот товарищ тоже был красным.
Давайте я его назову Y.
Какая еще проблема может возникнуть, скажите, пожалуйста.
Еще раз?
Нет, вот такого как раз не будет.
Да, вот если х-корень может быть проблема, потому что,
скажем, если у меня было изначально пустое дерево,
да, и я вместо вот этой вершинки подвешу красный х, то у меня
может нарушиться условие про то, что корень черный.
А с черной глубиной как раз все хорошо, потому что,
ну, давайте я еще раз картинку нарисую, что было, что стало.
Вот было, вот так вот, стало, вот так вот.
Как раз черная глубина здесь сохранилась, потому
что вот что у вас вот здесь вот было, сколько черных
вершин, то и здесь на всех таких путях осталось то
же самое количество черных вершин, потому что вы просто
вставили красную, она на черной глубине влияет.
Да, да, у нас вот есть требование, что у нормальной вершины,
ну, как бы, если нет детей, то надо подвесить.
Ну, в смысле, ну тут что-то еще там, я не знаю, что там,
я вот ту ветку не смотрю просто.
Вот, значит, мы поняли, что… А я не говорил, что она
обязательно черная.
Сейчас, подождите, еще раз, вот мы поняли, что могут
быть две проблемы.
Второе и четвертое свойства могли нарушиться.
Больше никакие.
То есть, либо я взял этот х, он у меня внезапно стал
корнем, ну, то есть, если дерево было пустое, я просто
вставил число х, покрасилось в красный, тогда у меня
красный корень.
Либо же у меня родитель, у меня вот эта штука тоже
красная, мне надо это чинить срочно.
Давайте научимся чинить.
Ну, вот, то есть, смотрите, мне нужна, давайте вот сейчас
абстрагируемся конкретно вот от этого инсерта, что
мы там сделали.
Давайте решать такую задачу.
То у меня было корректное красно-черное дерево, я
что-то в нем поменял, давайте я вот так его нарисую.
Да, значит, я что-то в нем поменял, и у меня одно
из двух возможных произошло нарушений.
Либо это все дерево, у меня красный корень, либо у
меня есть родитель, и он тоже красный.
Ну, вот, такую проблему будем решать.
Ну, сейчас будем решать.
Первую проблему решать очень легко.
Если наше текущее поддерево это все дерево, то есть,
если вот это вот это все, а выше ничего нет, и у
меня корень красный, то фик boundary легко, просто
надо корень в черный цвет перекрасить.
Она cis на Kirby У меня все починится.
А у меня ничего не нарушится, корень станет черным.
А с черными глубинами ничего не произойдет, потому
что на каждом пути лежал корень, поэтому все черные
глубины, все черные пути сохранились.
Поэтому корень можно всегда бесплатно перекрашивать,
Давайте напишем, что если x стал корнем, его можно
просто перекрасить в черный.
Ещё раз?
Ещё раз?
Не, ну может, конечно, но как тогда вы будете вставлять
x вот сюда?
Когда я его сюда вставлю, у нас черная глубина нарушилась.
Поэтому тут непонятно, что делать если x черный.
Хорошо.
Значит, как тогда бороться с нарушением четвертого
свойства, что у меня две подряд красные вершины?
Ну, смотрите, если у меня и x красный, и его родитель
красный, вот x красный, и y красный, тогда у y точно
есть родитель.
Потому что если у меня раньше было корректное
красно-черное дерево, то y не мог быть корнем, а
значит, у него обязательно есть родитель, давайте
его назову g, дедушка, grandparent.
Ну, а раз есть родитель, значит, он обязательно черный,
кстати говоря, потому что изначально в дереве не
было нарушений одноцветности, не могло бы здесь одновременно
две красные.
Значит, у него есть какой-то ещё сын, отличный от y, давайте
его назову u, ankle.
Анкл вершины x, дядя вершины x, вот, вот эту штуку я сейчас
буду рассматривать.
У меня есть x красный, у меня есть его родитель
красный, у меня есть его родитель g, черный, и u, который является
дядей вершины x.
Дядя, ну, в смысле брат, папа, ну, понятно, что вот такая
терминология, да.
Дедушка, папа, мы сейчас их ещё будем раскрашивать.
А мы пока не знаем, да, вот сейчас надо про это подумать.
Ну, давайте случай простой, случай первый.
Пусть дядя красный, пусть u красный.
Тогда мы сейчас вообще всё починим.
Значит, этот красный, там есть ещё какая-то подъём
наверх.
Давайте я покажу, как мы это всё перекрасим.
Давайте мы вершину g перекрасим в красный, его детей покрасим
в чёрный, x кажется останется красным.
Ну, и все поддеревья, которые здесь были, я их оставляю.
То есть я не меняю поддеревья, я только меняю цвета вот
этих вот вершин.
Я пока просто так делаю.
Сейчас поймём, типа, можно так делать или нельзя.
Я так сделаю, давайте поймём, что нарушится или там, что
починится.
Ну, по крайней мере, у меня вот этот конфликт разрешился.
Да, у меня теперь x, y разноцветные.
Что может теперь нарушиться?
Может нарушиться, что у g родитель тоже красный.
Либо может нарушиться, что g – это красный корень.
То есть опять, либо 2, либо 4-я слоенность нарушилась.
Но теперь уже с вершиной g, а больше ничего не нарушается.
То есть у меня по-прежнему все вершины покрашены, по-прежнему
у меня есть вершины обычные, есть фиктивные.
Я тут структуру дерева не менял, поэтому третье
свойство автоматически сохраняется.
Может нарушиться 4-я, а с 5-м давайте про чёрную глубину
подумаем.
Почему с чёрной глубиной всё нормально?
Потому что, смотрите, какая у меня была чёрная глубина.
Я как-то от корня мог идти через, скажем, g, y и x.
Здесь было из этих трёх вершин одна чёрная.
На этом пути тоже осталась одна чёрная.
На этом пути была одна чёрная, на этом пути осталась
одна чёрная.
Поэтому можно легко понять, что какой бы вы путь не
рассматривали в старом дереве и в новом, на нём
сохранится количество чёрных вершин.
Потому что я вот так их перекрасил, что любой спуск
сохраняет количество чёрных.
Похоже?
Мы поняли, что всё, что может нарушаться, это опять
либо второе, либо четвёртое свойство, но уже для вершины
g.
Ну, давайте тогда мы запустим ту же самую процедуру, которая
будет чинить.
Вот, смотрите, мы раньше были в x, мы понимали, что
у нас вот было какое-то дерево, которое могло конфликтовать
либо с родителем, могло быть две красные подряд, либо
x был корнем и при этом красным.
Мы свели задачу к такой же.
Мы находимся в вершине g, конфликт либо то, что уже
родитель тоже красный, либо то, что уже корень.
Мы свели задачу к аналогичной подъёмам наверх.
Давайте запустим рекурсию, она будет нашу проблему
решать.
То есть, мы стояли в x, что-то починили, перешли в x, починили,
поднялись выше, ну и так далее.
Просто рекурсивно подниматься, будем всё чинить.
Ну, что это в случае разобрали?
Ну, точнее, свели к аналогичному на как бы меньшей глубине.
Аналогично разбираем рекурсив.
Вот, теперь в случае второй.
Дядя чёрный.
В случае два.
У.
А же обязательно чёрный, потому что, смотрите, вот
у меня, ещё раз смотрите, у меня проблемы могли быть
только с тем, что я вот в этом дереве что-то нахулиганил.
Это что значит?
Значит у меня отец красный, но отец красный обязательно
чёрный.
Потому что вот это верхнее дерево, я не менял, у меня
было корректное красно-чёрное дерево, я похулиганил только
здесь, поэтому вот здесь конфликтов быть не могло.
Я их могу только здесь генерировать, когда что-то перекрашиваю. Они, соответственно, поднимаются наверх.
Поэтому дедушка g точно обязательно черный.
Теперь красный, но мы завели задачу аналогично. У меня проблема была вот здесь, а теперь она вот здесь.
Между g и родителем. Давайте рекурсивно будем эти конфликты решать.
То есть я показал, как решить конфликт для x, подняв его в g.
Но потом решу конфликт для g, подняв его в еще дедушку и так далее.
А если же корень?
Если же корень, это тянется очень просто. Можно просто перекрасить.
В любом момент времени, если мы стоим в красном корне, если у нас все нормально, кроме того, что корень красный,
ну давайте просто перекрасим. Вот у меня есть изначальная проверка.
Если я стою в красном корне, давайте я его просто перекрашу и победю.
Подряд может идти черное и красное. Не может быть красное и красное.
Черное и красное может быть.
Но вот это вполне нормально.
Красное и красное. Единственное ограничение, что красное и красное может идти подряд.
Ну пока мы все не разобрали, но это будет за логарифом работать.
То есть по факту я просто поднимаюсь снизу вверх и чиню все конфликты.
Будет за логарифом за время пропорциональной глубине.
Итак, это все просто. Мы просто перекрасили цвета и отложили проблему на дедушку.
И дальше он ее рекурсивно решает выше.
Что значение?
Нет, я такого не говорил.
Я говорю, что пустые обязательно черные.
Но черные не всегда пустые.
Этого нет в свойствах.
Ну, просто х нельзя черным красить.
Потому что черная гуда нарушится.
А, ну да, еще и красный.
Откуда у нас вообще пустые?
Так, хорошо. Давайте пример красно-черного дерева нарисуем.
Видимо это должно быть полезно.
Просто пример какой-нибудь я нарисую сейчас.
Так, два. Нет, здесь вот так вот.
Да, продон.
Сложно. Четыре, и че надо не путать.
Ну, вот, например, черный.
Четверть.
Четыре.
Четверть.
Четверть.
Четверть.
Четверть.
Четверть.
Четверть.
Ну, вот, например, кажется, корректное красно-черное дерево.
Смотрите, у меня в корне десять, и он черный.
Дальше у него есть справа...
Нет, нарушил, извините.
Сейчас починю.
Вот здесь пусть будет красный, какой-нибудь пятнадцать.
И здесь у него два сына вот таких фиктивных.
Во, хорошее дерево.
Значит, корень черный, в нем десять.
У него есть два сына.
Один черный, другой красный.
У вот этого красного оба сына фиктивные, пустые черные листья.
Я прямоугольники всегда рисую черными.
Они у меня всегда черные.
Тут ничего не хранится.
Черная глубина, смотрите, два.
То есть у меня есть корень, красная и черная.
Суммарно здесь две черные вершины.
Что на этой пути, что на этой пути, две черные вершины.
Теперь здесь левая ветка.
Здесь черный.
Да что же я опять все сломал-то?
Значит, здесь...
Вот давайте сделаем вот здесь Ч, здесь Ч.
Какой-нибудь...
Тринадцать.
Так. И здесь тоже должно быть что-то черное.
Вот, виноват.
Давайте черную глубину сделаю тройкой.
Тогда у меня вот черная, вот черная, вот черная.
Глубина три получилась.
Здесь тоже вот черная глубина, например, три.
Черная, черная, черная.
И здесь тоже черная глубина три.
Черная, черная и вот эта черная.
Пустая вершина это лист всегда, да.
Вот.
Тут нет двух красных подряд.
Тут бывают черные вершины с ключами.
А пустые всегда черные.
И черные глубины все одинаковые.
От корня.
Похоже на правду?
Ну вот.
Все, вернемся сюда.
Давайте чинить.
Давайте чинить случай, когда у меня, соответственно, дядя черный.
Это что значит?
Вот у меня какая-то такая картинка.
G, Y, X.
Проблема в том, что у меня X и Y красные.
Дедушка у меня по-прежнему может быть только черным.
Потому что
родителям красный не может быть красный
в раннем более корректном красно-черном дереве.
И здесь у меня есть черный дядя.
Вот.
Тут есть два случая.
Так.
Это я оставлю.
Может когда-нибудь попробую.
Вот.
Я оставлю.
Может когда-нибудь попозже сотрем.
Случай.
2.1.
Случай такой.
X лежит по ту же сторону от Y.
Что и Y от G.
Что и Y от G.
То есть вот как на нашей картинке.
X это левый сын Y. Y левый сын G.
Ну либо наоборот они оба правые сыновья.
Картинка будет аналогичная.
В этом случае
я хочу сделать вот такой вот поворот.
Соответственно у меня Y поднимется в корень.
Вот этого текущего под дерево.
G и U спустятся вот сюда.
Делаю стоящую перекраску.
Вот.
И таким образом раскрашу вот эти наши 4 вершины.
Соответственно под деревья которые здесь были
они остаются.
Вот все что там было подвешено.
К XU.
К Y. К U.
Ну они аналогичным образом как при повороте
сохраняются
какие-то подвешенности здесь меняются.
И какие-то остаются.
Вот. Я повернул и немножко перекрасил.
Теперь я утверждаю что у меня корректное красно-черное дерево.
Ну в общем давайте разбираться.
Давайте с черными глубинами сначала.
Смотрите у меня
на любом пути от G
Так что здесь написано?
Это че?
Черный дядя у меня черный.
Извиняюсь.
Значит
на любом пути от G
куда-то вниз я вижу
две черные вершины. Вот здесь.
Точнее не так.
Смотрите у меня здесь.
Ага. Тут надо анализировать.
Давайте думать.
Если у меня раньше не нарушалось свойство про черные глубины
Пусть оно скажем вот здесь была какая-то
черная глубина B-H.
Здесь будет B-H-1
потому что одна черная отрезалась.
Здесь B-H-2 в этих поддеревях.
B-H-2..
здесь тоже B-H-1 потому что без одной черной.
Здесь snack B-H-1 остается
потому что я отрезал красную.
Здесь тоже B-H-1 потому что я отрезал красную,
и здесь тоже B-H-1.
Значит тогда
у поддеревев у меня
черные глубины остались
с такими же, потому что я сами под деревья не поменял.
Теперь какие здесь? Тут остается bh-1, потому что я красную добавил.
Здесь bh-1, потому что у меня были две одинаковые, я добавил к ним черную,
осталось на 1 побольше. Здесь осталось bh-1, потому что я подвесил красную.
Ну а здесь теперь bh, потому что у меня здесь черная.
1 плюс bh-1. Значит, у меня сохранились черные глубины.
У меня раньше на любом пути оттуда до любого листа здесь было bh,
вот здесь суммарно было bh черных вершин, и здесь то же самое.
То есть теперь все пути сохранили количество черных.
Поэтому с пятым свойством все нормально.
Дальше со свойством, потому что не может быть двух красных подряд, очевидно.
Здесь нет двух красных.
Ну да, ну давайте тут я буду считать.
Ну типа можно не считать, тогда-то минус один где-то появится.
Короче, все нормально.
Значит, двух красных подряд здесь нет.
Нет проблемы с тем, что y и родитель y, оба красные, потому что этот черный.
Ну и мы все обчинили на самом деле. У меня стало корректно красно-черное дерево.
На, я все конфликты починил. Все, значит наше дерево стало корректным.
Дерево стало корректным.
Получается, в момент, когда я дошел до той ситуации, что у меня дядя черный
и x по ту же сторону от родителя, что родитель от дедушки,
тогда я могу за один поворот и несколько перекрашиваний все починить.
У меня больше никаких конфликтов в дереве нет.
Вот профит. Причем смотрите, еще раз, папа с том, что мне даже не надо подниматься выше.
У меня нет никакого конфликта во всем дереве. Я все починил.
У меня y черный, поэтому какой бы ни был здесь родитель выше, у меня здесь нет конфликта.
Да, ну и соответственно он черный, поэтому он может быть корнем, если что.
Поэтому у меня нет конфликтов, я завершаюсь. У меня нет смысла подниматься выше, я все починил.
Кажется, их ровно n, если я правильно все понимаю.
Нет, n плюс 1.
Ну их порядка n в любом случае.
Вот, ну в случае второй, в случае 2-2, это когда, наоборот, x по другую сторону.
Не буду писать, что x держит по другую сторону от y, чем y от g.
То есть это картинка такого типа. У меня, скажем, y находится слева от родителя, а x справа.
Ну а случай то, что у черный.
Значит здесь черный, тут красный, тут красный, здесь черный.
Вот, тогда я, смотрите, сначала сделаю вот такой поворотик, вот это ребро превращаю.
Теперь у меня опять вот эти две вершины красные, а эти черные.
И я свел картинку к предыдущей.
После того, как я их провращал, у меня теперь уже x, y и g находятся по одну сторону.
Ну а такое я умею чинить, мне нужно просто вот здесь повернуть и перекрасить.
То есть я вот это вот вращаю, а это могу стереть.
То есть по факту вот здесь я применяю случай 2-1.
Я делаю поворот, x у меня лезет в корень, y слева.
Ну а раскраска такая же, как здесь, коче-коче.
Ну и опять можно пронаблюдать, что мы все обчинили.
У меня опять все нормально с черными глубинами, у меня нет двух красных подряд.
Если x корень, то он черный, все хорошо, короче.
Мы опять все обчинили.
Ну то есть по факту мы просто одним поворотом свели задачу к предыдущей,
а случай 2-1 мы решать уже умеем.
По факту просто аналогично к случаю 2-1.
То есть в этом случае нам тоже не нужно подниматься наверх.
Мы двумя поворотами и перекраской от единицы вершин,
то есть не более чем 4 вершины я перекрасил, я решил свою проблему.
Я избавился от проблем того, что есть какие-то коллизии со свойством 2 и 4.
Мне нет смысла подниматься наверх, я уже все починил.
Понятно?
Ну вот, мы разобрали инсерт.
Еще раз, как работает инсерт.
Мы сначала спустились от корня в поисках x.
То есть мы спускаемся, ищем место, где должен был бы быть x по-хорошему.
Доходим до какого-то фиктивного элемента, до черного прямоугольника, где ничего не лежит.
На его место вешаем красный x с двумя черными фиктивными сыновьями.
И дальше решаем такую задачу, что вот у меня есть какая-то вершина x.
Какая проблема? Она красная.
Проблема, что она либо красный корень, либо у него красный родитель.
Тогда у меня две красные подряд.
Ну и вот так вот решаю.
Я рассматриваю два случая.
То есть я смотрю на родителя, на дедушку и на дядю.
В зависимости от цвета дяди я что-то делаю.
Либо перекрашиваю, поднимаюсь наверх, как было в первом случае.
Либо за несколько вращений я полностью решаю свою проблему.
Я избавляюсь от всех противоречий.
Вот такой инсерт.
Вопросы, может?
Чем удобно?
Ну вот в частности, смотрите, вот здесь можно заметить, что у меня после инсерта всегда максимум два поворота.
А это более-менее самая тяжелая операция.
Потому что перекраска – это просто перестановка одного бита.
А поворот, мы помним, что при повороте мне нужно много указателей перенаправить.
Что там родители поменялись, дети поменялись и так далее.
Но вот здесь у вас всего два поворота.
Это неплохо.
Я чуть позже, в конце лекции, сравню все деревья, которые мы уже знаем и скажу, чем это лучше.
Но пока что видно, что здесь всего два поворота максимум при инсерте.
Это средний поворот?
Ну нет, за вот эти поворотов как бы.
Но здесь уже как раз оптимизация константа, грубо говоря.
Потому что мы считаем, что поворот – это дорого.
Мы хотим, чтобы поворотов было мало.
Ну по сравнению с перекраской это дорого, скажем так.
Вот, хорошо.
Давайте ехать дальше.
И рейс.
С рейсом тот же самый будет прикол, что там будет достаточно всегда от единицы поворотов.
И этим он выгодно отличается красно-черно от остальных.
Что нам достаточно от единицы сделать перебалансировок, чтобы все общинить.
Ну вот, что делать с рейсом?
Давайте его сначала в дереве найдем.
Вот есть х, который мы хотели бы удалить.
Давайте сразу скажем следующее.
Как мы вообще удаляем из обычного наивного дерева?
В случае, если у меня, скажем, один сын или вообще ноль детей,
то я могу вот того единственного сына, который есть, просто подвесить на место х, а про х забыть.
Ну и как бы раз слева ничего нет, я просто вот это сюда поднимаю.
Это в случае, если у меня нет детей или один сын.
В случае, если у меня два сына, я, например, нахожу максимум в левом поддереве,
поднимаю его сюда и удаляю максимум отсюда.
Давайте сделаем то же самое.
Давайте найдем х.
В случае, если у него два обычных сына, два неэффективных сына,
то я найду в левом из них максимальный элемент m,
подниму его на место х и удалю его отсюда.
И это хорошо тем, что у m уже максимум один нормальный сын.
Максимум один обычный сын, потому что правый у него обязательно эффективный.
Что такое максимальный элемент в дереве?
Это когда мы идем направо-направо-направо, пока мы находимся в нормальных вершинах.
Последняя вершина, вот эта максимальная вершина, у нее правый сын обязательно, черный эффективный лист.
Значит, у него из детей есть максимум только один левый, ну обычный.
А этот пустой, его можно всегда удалить, если нужно, его можно игнорировать, скажем так.
Первый шаг такой, что если у х есть два обычных сына,
то находим m максимум в левом под дереве,
ну или аналогично, можно минимум в правом под дереве, как обычно,
тут лево и право под деревом ничем не отличаются,
можно искать минимум в правом, если вам удобнее.
Ну давайте я найду максимум в левом,
поднимаем m на место x,
и удаляем m.
Теперь, после этого, можно считать, что у удаляемой вершины,
у них есть максимальная вершина,
у них есть максимальная вершина,
у них есть максимальная вершина,
теперь, после этого, можно считать, что у удаляемой вершины максимум один обычный сын.
У удаляемой вершины не больше одного обычного сына.
Так, ну теперь давайте разбираться с тем, какая может быть картинка.
Случай первый.
У х нет детей, нет обычных детей, есть только фиктивные,
ну и он красный, например, пусть будет так.
Пусть х, который я хочу удалить, красный,
и у него нет обычных детей, то есть оба фиктивные,
то есть картинка вот такая.
И я хочу х удалить.
Скажите, пожалуйста, что можно сделать в таком случае?
Да, можно просто вот это все по дереву заменить на один фиктивный черный элемент.
Тогда ничего не сломается, гарантированно.
У меня точно не возникнет двух красных подряд,
потому что я красный, то есть черный элемент,
и у него нет обычных детей, то есть оба фиктивные,
то есть картинка вот такая.
У меня точно не возникнет двух красных подряд,
потому что я красный только высек.
У меня не нарушилась черная глубина,
потому что я убрал красную,
если у меня был путь от корня до сюда, например,
вот какой-то такой путь,
то от того, что я убрал отсюда красную,
количество черных не поменялось.
Ну и более-менее как бы все.
Остальные условия автоматически выполнены.
Поэтому в случае, если моя вершина красная
и оба сына фиктивные, то я могу просто заменить ее
на фиктивную вершину и сразу победить,
больше ничего не делать.
Значит, в случае второй самый неприятный,
это когда в этом же случае
х черный,
значит у меня есть черная вершина,
у нее есть два фиктивных сына.
Вот этот случай сложный,
мы его будем рассматривать чуть позже,
то есть тут как бы более сложно,
смотри далее,
попозже его разберем,
потому что там очень много под случаев.
В случае третий более приятный,
мы разобрались, смотри, мы разобрались в случае,
когда у х нет обычных детей,
оба фиктивные,
остался случай, когда один обычный,
один фиктивный.
Вот есть х, есть какой-то обычный,
есть фиктивный,
потому что я сейчас живу в идее,
что у меня максимум один обычный.
Значит, картинка такая.
Что тут может быть с цветами?
Что здесь может быть с цветами?
Скажите, пожалуйста, какого цвета эта вершина?
Нет, она обязательно красная,
эта штука обязательно красная,
потому что будь она черной,
представьте, вот у вас есть черный обычный сын,
и есть черный фиктивный,
вот будь эта штука черной,
у вас тогда не сошлась бы черная глубина,
потому что если у вас есть обычная черная вершина,
то как минимум,
ну там в ее по дереве есть хотя бы один черный сын,
да, ну рано или поздно мы встретим
черный лист вот здесь,
и значит здесь, по этой цепочке,
у меня черного листа хотя бы два,
вот черный и вот черный,
а тут один, нестыковочка.
Значит, эта штука черной быть ни при каких условиях не может,
может быть только такое,
что эта вершина красная,
но если это красная,
то это обязательно черная,
потому что, то есть я считаю,
что я живу в хорошем красно-черном дереве,
то есть изначально у меня все верно,
я хочу удалить x,
тогда у меня, соответственно, если это красная,
то это обязательно черная,
нет двух красных подряд.
Да.
Откуда нам знать, что получившееся дерево,
как мы поменяли местами m и x,
корректно,
вы ведь ничего не знаете про цвета и x?
А я не сделал с цветами,
я просто числа переставил,
я вместо x поставил m,
а мы в обычном дереве такое делали многократно,
то есть я цвета не поменял,
я не поменял структуру,
я только m поставил вместо x,
число, у меня осталось корректное дерево,
мне нужно просто m высечь слева.
Вот, значит еще раз,
с y черным быть не может,
поэтому он красный, поэтому эта штука черная,
и у этого y тогда обязательно
оба сына фиктивные листья,
потому что если бы у него была какая-то
обычная вершина в качестве детей,
то она обязательно черная,
и там где-то в подделье есть еще черные листья,
тогда бы у меня опять не сошла черная глубина,
вот здесь было бы два черных на пути,
а здесь один всего.
Поэтому у y не может быть черного
обычного сына,
значит у него оба сына фиктивные,
фиктивные листья.
Не хранящих ключей.
Все, поэтому получается в третьем случае
у меня гарантированно удаляемая вершина черная,
его сын, который обычный,
красный, а вот все остальное черные фиктивные листья,
больше ничего нет.
То есть в третьем случае,
если у x есть один сын,
обычный, то корзинка обязательно такая.
Ну и здесь тоже очень легко лечится,
надо просто y поднять вот сюда
и покрасить его в черный.
Тогда у меня нет проблем с тем,
что есть два красные подряд,
потому что я красную только удалил,
и все хорошо с черной глубиной,
потому что если здесь, скажем,
было две черные на любом пути,
что здесь, что здесь,
то здесь тоже и на этом пути две черные,
поэтому с глубиной все хорошо.
Похоже?
Ну вот, поэтому мне осталось разобрать
только второй случай,
когда у меня есть черная вершина
вот такими вот детьми.
Так, это я, наверное, могу стереть.
У x?
Потому что я свел его
к случаю, когда у него максимум один.
Если у x два сына, я нахожу максимум
и удаляю максимум.
Так, ну что?
Давайте думать.
Вот, давайте я вот
такую штуку сделаю.
Давайте я в этой картинке
сделаю то же самое, что выше,
то есть по факту высеку x
и подвешу на его место просто черный лист.
Тогда что сломалось?
Сломалась только черная глубина.
Потому что раньше у меня
на любом пути от корня в этом поддереве,
вот я до сюда ходил, было две черные,
а теперь в этом поддереве одна черная.
И, соответственно, если там у корня
есть какие-то другие ветки,
то у меня нарушилось условие про черные глубины.
Вот в этом поддереве
глубина черная поменялась,
если в другом сохранилась,
то у меня проблем.
Ну, ничего страшного, давайте я вот так вот сделаю
и сейчас буду чинить.
Что я буду чинить?
Давайте эту задачу сформулируем.
У меня было корректное
поддерево красно-черного дерева,
я в нем что-то удалил
и уменьшил черную глубину на единицу.
Потому что если здесь было h,
то я теперь вот этот х высек,
у меня осталось бы h-1.
Такую задачу будем решать.
То есть у меня было корректное поддерево,
в нем что-то удалилось,
то есть была вот такая картинка,
стало вот такая какая-то.
И при этом черная глубина уменьшилась
на 1,
а корень вот здесь,
мне сейчас будет важно,
что корень вот здесь черный.
То есть у меня была здесь bh,
то есть отсюда была черная глубина bh,
здесь стало bh-1
и корень черный,
то есть черная глубина уменьшилась на 1,
корень черный.
Ау?
Ну в этом случае же черный.
Корень, в смысле корень вот того поддерева,
где я произвел удаление.
Вот здесь черный,
я сейчас буду это сохранять.
То есть я обобщил конкретно вот этот частный случай
на что-то более общее,
и сейчас в этом более общем случае буду решать вот эту постановку
поднятия снизу вверх и починки всего,
что мы сломали.
Вот.
Значит тогда, сейчас я буду жить
в такой парадигме. Смотрите, у меня вот
вот это поддерева,
в котором я уменьшил на 1 черную глубину,
ну, это плохо.
Потому что если у меня есть
такой путь и такой путь,
то вот здесь должны быть одинаковые черные глубины,
а здесь уменьшилось на 1,
поэтому у меня проблема, что здесь и здесь разные глубины.
Это плохо.
Но давайте это будем чинить.
Я буду считать, что вот то дерево в котором
произошло это изменение,
вот произошло в этом поддереве,
здесь bh поменялось на bh-1
и здесь корень черный. Давайте решать такую проблему, что у меня, ну и для удобства я считаю,
что это поддерево правый сын своего отца, если отец есть. Если нет, ну в смысле левый,
если эта штука слева разбирается симметрично. Так, хорошо. Ну ладно, вот у меня есть поддерево,
где произошло изменение. Давайте посмотрим на родителя А. Давайте разберем два случая,
какого цвета А. Случай 2.1. А красный. Если А красный и в одном из его поддеревов уменьшилась
черная глубина, то обязательно у А есть еще один левый сын. Такой, что вот здесь вот вершина Б
обязательно черная. То есть если это красная, то обязательно черная. Ну потому что у меня вот
здесь было какое-то нормальное дерево, глубина которого уменьшилась, значит и здесь было дерево
такой же глубины БА, значит здесь обязательно вершинка Б. Черная, в смысле. Вот, и давайте
теперь разберем еще два случая. Есть ли красные дети УБ? Случай 2.1. Можно?
Ну да. Кого? Вложенных конструкций много. Какой чекер? Чекер на корректность? Кода? Наверное,
нет. Понимаю. А так вам очень интересно, да? Ну вот, значит случай 2.1. У Б есть красный сын.
У Б есть красный сын. Давайте разберу случай, когда он справа. У меня есть А, у меня есть Б,
и вот здесь вот у Б есть красный сын С. Значит здесь К, здесь Ч, здесь К, и вот в этом поддереве
произошло уменьшение глубины. Вот здесь вот мы что-то нахулиганили. Тут остались какие-то поддеревья.
Тогда что я делаю в этом случае? Я делаю парочку вращений. Сначала вот такое,
потом вот такое. Вытаскивая тем самым С в корень. Значит сначала С поднялось сюда,
Б осталось слева, и потом А я еще спустил направо. Значит у меня после вращений ситуация будет вот такая.
Вот этот треугольник перешел сюда, вот это поддерево стало вот здесь. И раскраска у меня будет,
тут красная, тут черная. Вот. Значит уже в этом случае опять все починилось. Ну почему? Давайте
разберемся с черными глубинами, например. Вот здесь было Бх, стало Бх-1. Ну да, да, да. Ну давайте я все-таки
вот распишусь с числами, мне кажется, так будет формально чуть-чуть. Вот если здесь стало Бх-1,
значит здесь было Бх, потому что раньше было все хорошо, то есть раньше до удаления вот эта черная
глубина согласовывалась вот с этой. Значит здесь было Бх, здесь черная, значит здесь Бх-1. Тут красная,
значит здесь Бх-1 остается. Поэтому все вот эти вот поддеревья имеют у меня сейчас черную глубину
Бх-1. И тогда все хорошо. Здесь Бх, здесь Бх, здесь Бх. Вот. Черные глубины пофиксились,
то есть у меня сохранилась вот черная глубина всего этого поддерева была раньше такая же,
как стала теперь. Поэтому относительно корня у меня все сохранилось.
В начале, да, но я в какой-то момент перейду так же, как у меня было после инсерта, я в какой-то
момент сведу задачу вот из этого треугольника в этот треугольник. И тогда у меня будет вот в
этом дереве что-то удалилось, уменьшилась черная глубина, и там уже есть какие-то дети. То есть,
смотри, мы забыли про вот эту картинку, давайте про нее забудем. Я решаю вот эту задачу, что у меня
было поддерево, я уменьшил Бх на 1, было Бх стал Бх-1, и корень черный. Вот. Какого конкретного типа
это дерево я не говорю, ну какое-то, которое раньше было корректным. Вот и здесь, да, то есть изначально
это просто черный листик, но в какой-то момент я перейду к этой же задаче, вот от дедушки запущусь,
и там уже будет какое-то более сложное дерево, но мне не важно какое. Ну вот, вот я решу, что все
починили. Все починили почему? Ну, например, вот с родителем конфликта не будет, потому что если А
было красное, то обязательно родитель черный. Поэтому от того, что С красное, тут конфликта не
будет. Ну и вроде все свойства тоже сохраняются, точнее восстанавливаться, чиниться. Вот. Ну то же
самое, если С было бы левым сыном Б, там можно было бы аналогично повернуть, чтобы вытащить С в корень,
ну, точнее, неважно. Короче, там будет аналогично. Давайте хоть какие-то детали закроем. Вот. Второй
случай противоположный, когда у меня, значит, случай 2-1-2, когда у Б нет красных детей. У Б нет
красных детей. Тогда меняем Б на красный. И А на черный еще. Ну да. Значит, картинка была вот такая.
Вот здесь оба сына черные, да, а в этом по дереве что-то произошло, в этом по дереве Б аж
уменьшилось. Тогда я просто возьму, перекрашу А в черный, Б в красный, по дереве я оставлю
такими же, какими они были, и утверждаю, что все починилось. И утверждаю, что все починилось.
Логично? Сейчас я вот что-то перестал понимать. Ну да, смотрите, потому что если здесь было,
если здесь стало Б аж минус 1, а раньше было Б аж, значит, вот здесь вот Б аж, потому что раньше
было согласование, а потом пропало. Значит, тут Б аж минус 1, потому что это черное. Опять-таки,
все по дереве у меня черной глубины Б аж минус 1. Здесь Б аж минус 1, потому что это красное. Здесь
Б аж. То есть с черными глубинами все хорошо, и опять у меня здесь была черная глубина Б аж, и она
осталась Б аж. То есть опять от корня ничего не поменялось. На любом пути от корня в этом под дереве,
куда-то вниз, была Б аж черных вершин, и осталась тоже Б аж. Поэтому с черными глубинами все
сохранилось. Двух красных подряд не возникло, потому что перекрасить Б я имею право в красный,
потому что оба сына черные, но и все обчинилось. Опять все обчинилось. А предположение,
убой не от красных детей, поэтому оба сына черные. Смотрите, от того, что перекрашиваю вершину в
черный, проблема может возникнуть только с черной глубиной. Но я вроде пересчитал, проверил,
что с черными глубинами все хорошо. Никаких других свойств вроде не нарушается.
Вот, что-то разобрали. Мы разобрали случай 2.1, когда А красный. Остался случай 2.2, когда А черный.
Случай 2.2, А черный. Вот у меня есть поддерево, в котором произошло уменьшение глубины черной
на единичку. А черный, вот есть Б. Давайте теперь берем цвет Б. Какого цвета Б?
Начнем с красного. Случай 2.2.1, Б красный. Вот. Ну раз она красная, то у нее оба сына черные.
Давайте рассмотрим право из них. Насчет сын черный. И еще под случай, есть ли у С красные дети?
Есть ли у С красные дети? Это самый сложный. После этого будет получше. Не считайте. 2.2.1.1. У С есть
красный сын. Ну пусть он опять будет, например, слева. Вот. Ну и здесь какие-то были поддеревья.
Так, да. Что будем делать? Что-то сейчас опять провращаем и починим. Так, я хочу цепь наверх поднять.
Сейчас сделаю вот такие вот вращения, подняв тем самым цепь в корень. Это сначала вот это,
потом вот это. Что у меня будет сначала С. Так, и D слева, поэтому оно останется слева. Вот. Здесь
наши поддеревья. Здесь вот то самое, в котором треугольник, это всегда то, у которого глубина на
один поменьше стала. Так, ну и с цветами тут B красный, остальные черные. Вот. Так, давайте я перерисую,
что это мне просто не видно с той доски. Значит, это получилось из ситуации, когда у меня был черный,
красный, черный, красный. Значит, тогда, ну смотри, двух красных подряд здесь нет и с родителем,
между С и родителем С тоже проблем нет. Остается только с глубинами разобраться. Значит, здесь
было BH, стало BH минус один. Поэтому здесь было BH, раз они раньше согласовывались. Здесь остается
BH, потому что это красное. Здесь BH по-прежнему. Тут BH минус один, потому что это черное. Тут
BH минус один, потому что это красное. Вот. В поддеревьях у меня глубины не поменялись,
поэтому я их переписываю без изменений. BH. BH минус один. BH минус один. Так. Сейчас, что у меня?
А, вот здесь еще. Продон. Так, и здесь BH минус один. Нет, беда. Чего? Сейчас, сейчас, сейчас, сейчас.
Так. Ну. Так, такого, это что-то не то. Как же? С Д какая-то проблема. Сейчас. А, нет.
Да и не там думать. Сейчас, а где она? А, она справа будет, видимо, да просто. Да,
продон, Д справа. Извините, я вращать разучился. Значит, я сделаю вот так. Да,
у меня Д стало правым сыном Б. Извините, просто картинка, просто поворот неправильно
нарисовал. Вот. Все, все, все, все. Да, так как раз все хорошо будет. BH, BH минус один. BH минус один.
Извиняюсь. То есть, после вот этого поворота Д как раз подвешивается справа к Б, а С поднимается
наверх. Вот. И тут как раз все хорошо. Здесь BH минус один, BH минус один. Здесь BH, потому
что это черная, здесь оба BH. Здесь остается BH, потому что это красная. Здесь оба BH минус один,
здесь BH, потому что она черная. Ну и здесь BH плюс один. Ну и тут выше она тоже была,
было BH плюс один, потому что это черное.
Значит, с черными глубинами опять все хорошо.
В этом поддереве изначально было BH плюс один, осталось BH плюс один,
поэтому с глубинами черными все хорошо.
Еще раз?
Если оба сына УА красные, оба сына УА не могут быть красными,
потому что вот это поддерево имеет своим корнем черную штуку.
У нас такой вариант.
Так, ну случай противоположный.
Случай 2212, УС нет красных детей.
Значит, тут картинка попроще.
Значит, у меня было черный А, красный Б, у него черный сын С,
и здесь оба сына у него тоже черные.
А вот здесь вот поддерево уменьшишься глубины.
Значит, тогда я сделаю, кажется, всего один поворот вот такой вот,
и у меня будет БАС черное.
И вот так вот их перекрашу.
Вот как раз поворот, Б поднимается наверх, А направо,
и те подвешатся слева К, все правильно.
Нет. Смотрите, предыдущий был 2211, когда УС есть красный сын.
Противоположный 2212, УС нет красных детей, все нормально.
Проверяйте.
Значит, ну здесь тоже с черными глубинами все хорошо.
Можно я вот здесь не буду прорисовывать.
Честно-честно. Можете проверить, если не верите.
То есть тут опять, если посчитать черные глубины, то опять все сойдется,
это поддерево станет хорошим, и я все починил сразу.
Так, значит, случай 2211 мы полностью разобрали.
Вот это вот мы полностью разобрали. В случае, что Б красный,
независимо от того, есть УС красные дети или нет, мы оба случай разобрали.
Теперь разошаемся на шаг наверх. Случай 2222.
Еще раз?
Ну иначе, да, иначе с глубиной не получится.
Если бы здесь была черная, тогда здесь глубина черная была слишком большая,
а так как раз сойдется.
Ответ на все вопросы почему, потому что так работает, а по-другому, наверное, не работает.
Итак, 2222, Б черный.
Вот, и последние два подслучая, есть ли у Б черные дети.
Все, все, последние два, обещаю.
Есть ли у Б красные дети?
Красные дети.
Не торопитесь события, давайте здесь разберемся сначала.
2211 есть.
Ну...
Значит так, А у меня черный, Б у меня черный, пусть у меня есть справа красный сын С.
Вот здесь пришло уменьшение, тогда...
Так, я просто... Опять у меня два поворота.
Вот такой.
Нет, 2211, вот он, 2211, это Б красный.
И он разберется на два подслучая.
Это Б черный.
И теперь я в этом случае опять ифаю, есть ли красные дети.
Значит, если есть, то я делаю вот такие два поворота.
С вылезает в корень.
И я все кашу в черный.
Значит, давайте проверим, да? Здесь было Бх, стало Бх-1.
Значит, здесь было Бх, потому что раньше согласовывалось.
Тут Бх-1, Бх-1, потому что это черное.
Тут Бх-1, потому что это красное.
Значит, в поддеревьях у всех осталась черная глубина Бх-1.
Тут Бх, потому что это черное.
Тут Бх, потому что это черное.
Здесь Бх-1, потому что это черное.
И здесь тоже было Бх-1, потому что здесь было Бх, здесь было Бх, это черное.
Значит, опять с черной глубиной все хорошо, все починили, дерево стало корректным.
И последний случай.
Как я сейчас делаю?
И последний случай.
Когда, соответственно, у Б нет красных детей,
в случае 2-2-2-2, у Б нет красных детей.
А у нас нет планы Бх, у нас Бх, у нас Бх, да, потому что раньше было здесь Бх, и раньше было корректное дерево.
Ну все, значит здесь А, здесь B.
Это черное, это черное.
И у Б оба сына черные.
Тогда, делаю великую вещь, вот эту штуку просто перекрашу
в красный, потому что могу, потому что эти оба черные,
значит я могу эту перекрасить в красный.
Значит, здесь bh-1, здесь bh, потому что раньше согласовывались,
здесь bh-1, здесь bh-1, bh-1, bh-1, здесь bh-1, здесь bh.
И здесь тоже было, а здесь было bh-1.
Смотрите, произошла проблема.
В последнем случае у меня внутри этого подерево как
бы все хорошо, но глобально черная глубина уменьшилась
на один.
Тут было bh-1, стало bh.
Но это ровно та задача, которую мы сейчас рекурсивно
решаем.
У меня, смотрите, у меня было вот это поддерево,
где все было хорошо, но черная глубина уменьшилась
на один, а корень черный.
А я взял следующее, я взял родителя, тут что-то перекрасил,
и задача стала ровно такой же.
У меня было корректное красно-черное дерево, я взял корень,
а у меня остался черным, а черная глубина уменьшилась
на один.
Это то, что я решаю, поэтому я просто рекурсивно
поднимаюсь наверх.
Рекурсивный подъем вверх.
Все.
Конец.
Ну, в смысле, случай в конец.
Вот.
Значит, еще раз и рейс.
Первый, ну там мы что-то делаем, первый случай,
третий случай простые, второй случай мы обобщаем его
на вот эту более общую задачу, что мы находимся в поддереве,
где у которого черная глубина уменьшилась на один.
Дальше делаем кучу случаев, большинство из которых просто
за несколько поворотов, там, за два поворота кажется
всегда, и несколько перекрасок, все вообще чинит, чинит
вообще все дерево, и делает вообще все хорошо.
И последний случай сводит нашу задачу к аналогичной
только на уровень больше.
То есть я вот здесь что-то перекрасил и наша задача
стала теперь вот такой.
В этом дереве черная глубина уменьшилась на один.
И я вот теперь для этой вершины решаю ту же самую задачу.
И вот то, что меня спрашивали, да, у меня же это дерево всегда пустой черный лист.
Вот здесь это уже какой-то содержательный побольше дерева.
Ну вот, я, соответственно, поднимаюсь наверх, пока все не починю.
Вопросы, может, по случаем кем-то. Я рад.
Смотрите, логарифм на подъем, да, то есть при подъеме снизу вверх у вас может быть в
худшем случае логарифм, но дорогих действий и поворотов у вас два всего, максимум всегда.
Потому что если вы сделали поворот, то вы все починили сразу. Вот, значит, теперь давайте последние
пять минут быстренько проговорим, что мы получили. Давайте сравним красно-черный и АВЛ.
Смотрите, здесь, про глубину мы знаем, что здесь примерно два логарифма двоичных,
нам и доказывали в начале лекции. Про ВЛ у нас там был логарифм по основанию Фи, по основанию
золотого сечения. Глубина примерно лог Фи, по основанию Фи в смысле. Вот, это примерно полтора логарифма двоичных.
То есть с точки зрения константа глубина вот здесь поменьше. В смысле, с точки зрения мультиплеектива,
но множители глубины. Тут константа поменьше. Погодите. Поэтому здесь, грубо говоря, вот общий
совет такой, что если у вас много файндов и мало инсертов и эрейзов, используйте АВЛ,
потому что у него глубина поменьше, файнды не меняют структуру дерева, они работают за полтора
логарифма. А если у вас много инсертов и эрейзов, то используйте красно-черные, потому что они хоть
вот здесь константы побольше, но они делают меньше тяжелых операций. То есть вот здесь в АВЛе,
ну в эрейзе точно, может быть очень много, когда мы в АВЛе что-то чинили после эрейза, у нас может
быть очень много поворотов. Ну вплоть до логарифма, когда мы вот идем, мы там что-то вращаем,
чиним дельточки. Вот здесь поворотов может быть много, а здесь всегда максимум два. Поэтому здесь
мало тяжеловесных операций и кочепы предпочтительные в случае, когда у вас много вот таких операций. То есть
тут мы уже боремся за константу, грубо говоря, и мораль такая, что при файнде, если у вас много,
если у вас файнды доминируют, если у вас много файндов, используйте АВЛ, если доминируют инсерты эрейз,
используйте красно-черные. Что? Да, сет красно-черный, ну обычно. Насколько я знаю, нет. Вот это сравнение
вот этих двух. Значит они хороши тем, что они всегда, ну они детерминированы, они не используют
рандома, они всегда на каждом запросе отвечают за чистый логарифм. Это за полтора логарифма,
это за два логарифма, в худшем случае. Вот, значит, что мы еще знаем? Мы знаем сплей. Чем он хорош?
Ну он хорош тем, что недавние запросы находятся близко к корню. Мы там специально так делали,
что последний запрос находится прямо в корне, ну соответственно несколько последних находится
около корни. Поэтому у него понятно какой плюс, что недавние запросы отвечаются за быстро. Если
много раз к одним и тем же элементам поступают запросы, мы на них быстро отвечаем. Значит недавние
запросы, запросы близко к корню. Вот, ну а минусы понятно, что там только амортизационная оценка,
и каждый конкретный запрос может работать задолго. В худшем случае за линейное время. То есть каждый
конкретный запрос может быть долго, но суммарно работает быстро. Ну как обычно в амортизационном
анализе. Вот, ну про дикартовое дерево мы тоже знаем, что оно вероятностное, то есть там только
мотожидание логарифмическое на глубину. Вот, ну скажем оно обычно его хватает. То есть оно проще
всего пишется, на мой взгляд, и там умеет спокойно сплититься, мерзиться в отличие от красно-черного
AVL, где эти операции более сложны. Значит плюс, что здесь быстро работает, ну как бы нормально
работает сплит и мерч в отличие вот красно-черного AVL. Минусы то, что оно вероятностное. Вот, ну и
B дерево, оно хорошо на больших объемах данных. Большие объемы данных. Мы говорили, что там как
раз самая сложная операция это вот обращение к диску, подгрузка содержания вершины в оперативку.
Ну а минусы, что на маленьких объемах данных оно не лучше, чем все остальные. То есть оно дает
выигрыш. Если у вас какое-то внешнее хранилище данных, в остальных случаях оно ничем не лучше
красно-черного AVL. Все, деревья поиска, отпускаем. Всем спасибо.
