сегодня у нас конечно все будет попроще вот настолько попроще что возможно что скорее всего
к концу занятия мы все-таки будем обсуждать фурия так что да но тем не менее кое-что веселенькое
мы все-таки обсудим например фурия да в общем-то дать это действительно понятно до шоу да была
бы конечно мечта нет а давайте-ка отсудим как построить миностов с помощью собственно софт хипа
но нет мы этого мы этого пока делать не будем значит вместо этого закроем пару дырочек которые
остались с прошлого раза там с прошлых разов ну во первых самая простая дырочка как построить
линейное время миностов с помощью атомной кучи вот но на самом деле секрет лакчик там открывается
просто да вот мы с вами вчера в прошлый раз пытались там подогнать симпатику пользуясь тем
что там там все работа что там экстракт мин работает не за логарифом а за логарифом делить
налогариф логарифов и у нас ничего не получилось так вот это нормально называется выжимается кайф там
не за счет этого что про атоме потому что атомик хип круп даже не этим потому что помните да
атомик хип да но напомним да в каких случаях по перемене матамики вообще кстати оптичках
но тут проблема такая же мы не можем просто к абсолютно призвольным элементам взять
применить атомик хип давайте вспоминаем о чем это вообще да это о целых б битных числах помните
да то есть мы то есть скажи это не о даблах это не о призвольных там шаблон с компаратором нет то
есть ну как вы понимаете да не может быть так чтобы то есть как бы в призвольном случае как
вы помните не может быть вот этой вот кучи которая у нас там за от леденицы делает все кроме
там достает экстракт мин за меньше чем логарифом потому что тогда у нас ассортировка работает
быстрее чем за логан а такого невозможно да вот но если вы знаете что числа это какие-нибудь ваши
б битные числа то есть числа с которыми работает ваш процессор то тогда атомик хип с ними
справляется но сила атомик хипа даже не в том что там логан делит налог логан это даже скорее
следствие потому что основная идея заключается в том что если у вас или анот то есть если у вас
количество элементов хипе не превосходит лог квадрат n где n это что где 222 все перешел вот это
два степени максимально число ну да где n да ну типа да где n влезает в эту вашу разрядность то
есть там как минимум меньше там чем два степени б может быть в некотором смысле даже сильно там
не будем сейчас вдаваться в эти подробности вот ой точно может это дереван md boss еще можно
обсудить вот если у вас есть вот такое n и вас гарантируется но и у вас там гарантируется что в
каждый момент времени элементов в куче не больше чем вот столько они могут быть произвольные
битные числа но их вот не более чем вот столько то тогда выясняется что у нас тогда и даже экстракт
мин начинает работать за от единицы то есть крутизна в этом на самом деле понимаете да ну
как вы уже радуетесь помните там по структуре можно радоваться что лог квадрат тут может
быть достаточно условен что нет хотя нет нет лог квадрата принципиально ладно не будем то есть
можно подумать на тему того а нельзя ли то же самое доказать про лог куб там лог 4 лог 5 там
и так далее но этого мы пожалуй пока на всякий случай делать не будем вот и так вот у нас есть
такой лог квадрат вот таки все делается за от единицы как же нам тогда искать минус 100 с
такими весами а оказывается предельно просто то есть это означает что мы какую-то фазу то есть
помню в чем нас вообще заключался алгоритм фред монотериана он заключался в том что мы
фиксировали какой-то можем зафиксировать какое-то число к и за время я плюс в лог к с помощью там
какой-то кучи фиба начи мы мы создавали какие-то под компания под деревья будущего минимального
причем так чтобы разверх каждого был как мы каждый содержал как минимум коверши вот мы
вот ну не будем сейчас повторяться но мы вот мистическим образом это умели делать делали мы
это вот с помощью там кучи фиба начи и пользовались мы тем что экстракт мин у нее работает за лог
а все остальное включая декрески работает за единицу чем нам помогает атомик хип а вот чем
она вот ну чем там чем нам поможет вот и более того там оказывалось что если там первую фазу
мы как-нибудь делаем что кара в но допустим там двое там двое делить новое а лучше два в степени
двое делить новое то тогда получается что это вот и дальше там подозревалось что мы заводим к
2 к 3 где там каждое следующее равно два степени предыдущие и тогда получалось каждое следующее
фаза е плюс там что-то типа вы и ты делить на два степени к и т на там нет просто на к и т а тут
на там логарифом двоичной два степени к и т ну и получался вполне себе шлеп шлеп то есть
фаза получается спокойно так вот то есть но столько каждый следующий фаза работает в зву
плюс я теперь если у нас есть атомик хип то что у нас получается то когда есть у нас есть
атомик хип то давайте просто скажем что к1 равно даже не лог квадрат а просто лог в тогда заметим
что у нас все операции с такой ключей будут работать за единицу логичной и тогда получается
получается первая фаза будет тупо работать за я плюс вы что да но это была
куча фибоначи а вот с атомик сипом да то есть да заметим что вторую фазу мы
конечно уже будем делать вполне себе кучу фиб можем уже даже делать кучу
фибоначи можно даже оставить тот же атомик хип но не принципиально вот ну
хотя там даже лучше не атомик хипа вот эту вот вторую версию то есть внутреннюю
версию которая вот с этим вот так вот тогда но заметим что к2 можно вполне
себе делать как два степени к1 то есть тупо в и тогда получается е плюс в
делить на логарифм двоичный в умножен логарифм двоичный в шлёп шлёп радость то
есть таким образом получается что просто за две итерации фредба нотариана
линейная мы все но мы нашли минус то ура вот то есть вот такой вот пихалыч
получился но даже не пихалки так что все что вам остается просто реализовать
атомик хип вот тут конечно маленькая подляночка да что реализовать его мягко
говоря не просто хотя нет хотя нет реализовать его очень просто учитывая что у нас давайте
подумаем что вам для этого нужно вам нужно реализовать кучу ну помним да мы сводим вам
уже то есть n нас не происходит 2 в ладно так и быть 64 так там 264 то есть вам нужно реализовать
кучу которая содержит в себе не более чем 64 в квадрате элементов но мы помним как мы это
делали мы это сводили к там с помощью там каких-то хитрых деревьев мы это сводили к какой-то тот
же самый там тоже те же размер только степень не одна не два а 1 пятая так но с другой стороны да
но вот то есть в нашем случае логан не превосходит 64 то есть там видимо меньше чем там два в шестой
получается в степени 1 пятая ну то есть приводим вам остается только реализовать кучу которая
работает за от единицы если в ней содержится не более чем 3 элемента может 4 я верю вас вот
структура данных явно придумывается с прицелом на далекое будущее когда-нибудь когда-нибудь когда
битность будет миллионной там вот это все тогда это алгоритм может начнет нормально работать вот
может и не начнет вот да но тем не менее вот значит это первое что хотелось бы тут значит
как какую дырочку добить если тут вопрос какие-то вот нет отлично тогда мы значит это мы убираем
значит так ну к миношу но вот значит это мы еще вернемся это мы еще вернемся а пока значит закроем
более сложную дырочку значит мы вернемся сейчас вектор смысле к дереву доминаторов
казалось бы какую дырочку мы там не закрыли ну даже не алгоритм а структура данных да мечта у нас была
следующим да то есть нам хотелось реализовать структуру эвол линк апдейт значит вот такая
вот значит эвол линк апдейт что за структура данных но нам хотелось чего-то но нам там хотелось
чего-то примерно следующего у нас есть подвешенные деревья вот есть у нас какие-то там подвешенные
деревья и мы не будем сейчас совсем уж обобщать но хотелось пример следующий да у нас вот есть
несколько деревьев но самое главное на каждой вершинке написано какая-то там чиселка
вот вот там несколько таких деревьев изначально у нас вообще как всегда там
n деревьев каждый стоит из одной вершинки и нам с этой структурой данных хочется делать
следующие вещи во первых хочется делать эвол от в что такое эвол эвол означает что мы берем
какую-нибудь первую попавшуюся вершину в хотим пробежаться от нее до корня и что-то вычислить
то есть от этих чиселок но в общем случае там можно там там тариан в этом здесь начинает
вводить там какая-то ассоциативная операция там причем операция которую вполне себе можно
назвать быть вот вот да можно ее но мы мы еще но но мы сейчас этим заниматься не будем совсем то
есть что вот то есть какая-то такая операция но вот в нашем случае это мы очень хотим делать мим
вот ну там да там какие-то там высота какие-то там таймы на и там какие-то там из доминаторов
там каких-то вот это вот все там было не будем сейчас повторять в общем суть вот суть такая что
еще хочется делать еще хочется делать линк линк от в в это означает взять корень в и подвесить к
нему корень в нет ладно врал нет или не наврал нет не наврал да давайте вот мы рассмотрим
такой вот может это может это более простая версия хотя на самом деле нет вот рассмотрим
такую вещь когда мы подвешиваем корень корлю это важно и остается кое-что еще
и его величество апдейт от в и на этот раз x в нашем случае это операция сказать что вал от
в мим равно x вот такую структуру данно хотелось бы реализовать вот так ну вот ну как оказалось
вот как что если вот то есть в принципе мы помнишь мы научились реализовывать дерево доминаторов
за линии за от чего от н линков плюс м эвалов помнится там даже толком апдейтов не было хотя
нет апдейты может и были почему потому что когда но что возможно когда мы там к вершине подвешивали
какие-то под деревья мы проем мы там ровно в этот момент узнавали там ее какой-то полудоминатор
поэтому апдейт возможно и будет вот мы не будем сейчас вдаваться такие детали тем более чтобы
все равно вот ровно в этом виде сейчас все и порешаем вот не будем сейчас это все переповторять
вот почему мы сейчас не будем переповторять потому что тут вытекает такой вопрос вот
за какой всем точку мы могли бы реализовать вот это вот
вот давайте хотя бы со вот хотя бы слету
ну где-то лагарифа но это называется какой лагарифа
прям вот так да да действительно да действительно без ар служит противорятием от всех этих зелий
действительно зачем что-то готовить это да да это проще да в самом деле ради чего мы в прошлый раз
не страдали но допустим страдали
так а керман у нас поди где пристес тогда а где еще собственно где еще да да мы ж
пока еще это алгоритм этого построения дерево через софт и пусть уж не придумали вот вот а на
самом деле мы страдали для того чтобы во первых доказать две мистические теоремы теоремы
говорят следующее что в принципе заметим что основная идея первое заключается в том что на
этом вот можно делать эвристику сжатия путей потому что мы не делаем никаких откатов ну
с про откатом еще поговорим вот соответственно в данном случае как очевидно что там достаточно
легко там делать сжатия путей поддерживать не например минимум хотя кстати да сразу скажем
что бывает минимум можно тут делать плюс там допустим можно делать например вот сумму и тут
делать плюс равно почему в общем-то и вот и можно достаточно легко делать там какой-нибудь сжатия
путей и у нас была даже мистическая теорема про снм которая применима в принципе сюда она говорит
что если там подключать подвешивать деревья абсолютно произвольным образом давайте напишем
рема 1 у нас была то есть если в этом там то есть если в снм использовать только эвристику сжатия
путей там только эвристику сжатия путей то но то тогда то время работы у нас какое
там не превосходит у нас от чего если бы если все было так просто нет все благо все было сложнее у
нас все было гораздо сложнее сейчас где же она у нас где же у нас это маги это ой сам ее не
помню то что вот а вот она это от м умножить на максимум из единицы и логарифом n квадрат
делит на м через на логарифом 2 н делить на м ну да да да неправильно да конечно
ну хорошо хорошо ну конечно конечно ну понятно понятно все вы придираетесь
да было доказано в круге чему да мы конечно доказывали логарифом но и просто логарифом но на
самом деле вот этот результат чуть мощнее шедак где м равно n это про в чистом виде логарифом это
да но если м начинает приближаться к н квадрату то эта штука начинает приближаться к единицу и
это логично вот чего что он кто сказал у нас м запросов ну вот нету не надо звать
вот но если надо и со мной вам по-хорошему тоже называть не надо это не садом все-таки вот но
к эсене мы здесь отсылаемся потому что мы делаем буквально тоже что в сенеме как бы не заморачивать
поэтому так вот ну конечно в нашем случае n равно m прошпакает логарифа но как бы у нас была и вторая
терема которая стоила нам еще там потребовал там куча каких-то там лем там если используется
эвристика сжатия нот используется эвристика сжатия путей стека сжатия путей
вот и и для любого аж нот и а нет сейчас вот сейчас мы сейчас мы экзотически напишем и
существуют такие константы с больше либо равно единицы и а больше единицы такие что для любого
аж больше либо равно нуля верно что количество вершин ранга аж в не сжатом
дереве
не не превосходит cn делить на а в степени аж то время работы
tm операции
вот тут оно и возникает от м на том обратную функцию кермана от чего-то там чего-то
было ну да ладно мы это называем альфа тм помните такую тему вот и помнить она была в наглую заявил
нам тарьян статья про эволинк апдейт со ссылкой на статью пресса дым в котором
такой те ремни не было там был немного вот то есть дайте там это такая типичная ситуация
шоу ну как бы язык чуть подумать то это станет очевидно почему это станет очевидно потому что
ну давайте помню даже давайте напомню что такой ранг вообще до высота поддельно да то есть
или что то же самое расстояние до там максимальное расстояние до листа находящегося у меня в подделье
вот там доказательства базировалась на том что что вершин ранга аж у нас не более чем
н делить на 2 в степени аж ну там но мы это базировали на чем мы это мы там делали весовую
ивристику и поэтому гарантирует что у вершины ранга x хотя бы 2 в степени x потоп вот вот но
здесь но вот но здесь неожиданно почему-то оказывается очевидным что на самом деле можно
вот так то есть заява такая что если мы будем по две если линки у нас будут организованы таким
образом что будет верно вот это условие то тогда оценка керма но обратная функция керма на достигнута
будет более того но я не буду сейчас конечно передаказывать все леммы ну собственно
тем более все там передаказывать особо и не надо в общем-то вот заметим что то есть ключевое у
нас в общем-то другое помните у нас там была мистическая лемма в которой мы доказывали штаб
н и ты минус элитой не происходит 5 восьмых н где сначала мы поверили шла да пусть будет двое
но потом доказали про 37 так вот там помните так вот помните там просто основная но основная там
базировалась начал на том основной базировалась основное там базиров oxidato что у вас возникало
там мистическая сумма помните там что то вот что то сумма какая-то аитель там что-то а и тжطые там
делит на два в степени аить и жито tra 2Dr дает ну мы поняли вот мы
это говорили что это не происходит там 2n какой-то у нас в ляда бесконечностей мы знаем что это в
короче от единиц там можно конкретно подкручивать там какая конкретно
константа но сути одна вот то есть в общем-то доказательства легко подкрутить
в том плане что если как бы что поменяется если у нас треба если у нас нам
придется пользоваться этим ну поменять столько тем что тут придется
забабахивать с ну вот оно собственно там где-то а здесь надо просто не не двойку
забабахивает вот эту константу а
теперь вот давайте подумаем верно ли что вот их делить на в степени x это
сходящийся ряд а почему чего а будут так так погодите а чего так чем вы сейчас
на мотане занимаетесь римана ничего себе обычный интервал у вас уже были а это
есть обычные точно вот это да ну да да да да да сейчас интернет а это другое это
реклама была знаете там вообще нету знаете прикол там просто в общаге там
была реклама там помимо всего порченда был интервал и бега интервью и все
широчайшие возможности от действия нуля до функции дирекля не верьте слухом
распространяемым старым римом о том что там существует функции которые не
интегрируем и полибегу до сих пор ни одна из этих функций не построена в явном виде
вот так как и такая реклама была очаровательной может а в четверке до
сих пор висит можете там погулять посмотреть вот так ладно ну ничего но
просто лиды поиди у вас стоп лидис вы сейчас интервью идите чем и пошел в
прошлом семестре занимались чего а ну вот нет ну как бы нет это все будет то
есть у вас там начнется там признаки тирихле принципе обеда там сходимости
и так далее нет этого веселье у вас там этого да добра навалом но но в нашем
случае в общем-то ладно это доказать тоже не сильно сложно потому что
доказательства будет примерно такой же потому что давайте эту сумму распишем
так распишем 1 1 Więкла. А 1 делить на там а в квадрате а тут даже не 1 получается
так вот так 1 делить на квадрате 1 делить на вкубе там один делить на в4 и так
далееila 1 велик на в квадрате один делить на вкубе один делить на в 4 и
и так далее. Тут 1 делить на f кубе, 1 делить на f четвертой и так далее, ну и так далее.
Вот. Вот. Все. Мы это доказываем в сходимости этого ряда пока. Вот. Ну раскладываем вот в
такие слагаемые. Ну тут как раз вот тут один раз один делить на а, тут два раза там один делить на
а в квадрате, ну и так далее. Теперь заметим, что теперь мы знаем, что если а больше единицы,
то эта штука сходится. Правда? Теперь фишка. Мы знаем, что она сходится. Она сходится
к какой-то мистической величине b. Допустим, да? Но теперь заметим, что тогда вот эта штука
сходится к b делить на а. Это b делить на а в квадрат, это b делить на а в кубе, ну и так далее.
В общем, и того тогда получаем, что эта сумма не превосходит b в квадрате. Ну даже уже неважно,
чего главное сходится. То есть оставляем вот. Чего? Вопрос? Так что вот такая вот красота получается.
Ну вот, то есть и действительно получается, что на самом деле теорема есть, но как бы да. Правда?
Как говорится, тальян считает такие доработки очевидными. Ну собственно, надо представить,
действительно, ничего сильно сложного тут нет. Вот. Но остается только маленький вопрос. Да,
как же нам этого добиться? Вот давайте подумаем. Вот дело в том, что в эсенеме понятно, как можно
этого добиться. Потому что когда в эсенеме от нас просят объединить два дерева, там то,
какое дерево к какому подвешивать, оставляют на наше усмотрение. А здесь этого нет. Здесь нам
прям линк задает, какое дерево на какое вешать. Вот возникает вопрос, что можно было бы сделать?
Менять местами. Какие значения местами менять? Да, ну в идеале хотелось бы. Осталось только,
чтобы, то есть нет, это в принципе, конечно, все можно. Осталось только, ну вот. Осталось только
действительно как-то аккуратно делать. Вот давайте просто для разминки хотя бы поймем вот простую
вещь. Вот допустим у нас операция сложения, вот хотя бы. Как нам все-таки подвешивать получше?
Нет, так же как в эсэдем, ну пока нельзя. То есть нам принципиально, потому что когда вы
подвешиваете w к v, то d, то как бы результаты валов для всех вершин под дерево w должны
увеличиться на вершину v, на значение вершины v. И при этом, что важно, для вершины, для вот этих
всех вершин ничего поменяться не должно. Да, ну вот действительно есть такой действительно красивый
чит. Да, что если, ну вообще так, предположим выяснилось, что там размер под дерево w больше,
чем размер под дерево v, и хочется конечно подвешивать w к v, а наоборот. Вот, ну тогда
идея такая, что если тут допустим было написано какое-то число, если у w тут написано какое-то
число aw, а тут написано какое-то число av, то действительно возникает тогда идея такая, что
подвесить надо конечно v к w. Ну вот, но при этом немножко пошаманить с чиселками. Каким образом
пошаманить? Да очень просто. Надо здесь написать там что-то типа av плюс aw, а здесь написать что?
Нет, не совсем так, погодите, погодите. Если я напишу здесь av минус aw, а просто
minus aw. Да, вот теперь хорошо. Ну по модулю того, что как бы у нас получается тут тонкая разница,
что есть, что у каждой вершины есть реальный, то есть как бы есть оригинальный корень,
который должен быть, есть какой-то реальный корень, который мы сюда храним, даже наоборот,
нет, он называется нереальный, он наоборот называется виртуальный. Ну, тонкая разница,
смотрите, то есть как бы есть понятие, то есть у Тарьяна, Тарьяна в этом месте говорит, что есть
вот такое нормальное дерево, так сказать, реальное, а есть виртуальное дерево, то есть это,
которое там вот в результате всяких вот этих вот сжатий путей тут образовалось, а в нашем случае
все еще хуже, потому что у нас окрасы еще и корень мог подшаманиться. Вот, но конкретно в операции
плюс нас это особо не волнует, вот, потому что здесь действительно для каждой, потому что как бы
для каждой вершины мы можем найти корень и для каждой вершины мы гарантируем, что действительно
сумма равна чему надо. Ну и конечно, ну вот, ну вот, ну и конечно апдейт в корне дерева делается,
ну понятно, элементарно, надо пойти в виртуальный корень и к нему соответственно прибавить
чиселки и получится хорошо. Вот, то есть вот тут такой кайф, в оригинальной статье Тарьяна в этом
месте говорим, что пусть это операция ассоциативная, у нее есть какой-то там правый обратный или левый
обратный, ну и так далее, в общем, или что-то в этом роде. Вот, ладно, нам сейчас это не особо
интересно, потому что самое интересное для нас, конечно же, это что? Это научиться работать с минимумом.
Апдейт, ну апдейт делается, тут ключевое, что v обязан быть корнем,
поэтому делается он просто, то есть как бы что значит vx? В точке зрения плюс равно x это означает,
что ко всем эвалам теоретически нужно уметь прибавлять просто один и тот же x, то есть вы
отправляетесь в корень дерева, ну он правда будет не v, а там какой-то реальный корень и к его значению
тупо прибавляйте x, как бы никаких проблем нет. Вот, да, но здесь вот, да, но это для нас не самое
интересное, то есть точка зрения дерева доминаторов нам жутко интересно, чтобы эта штука помирилась
с минимумом. Вот, да, ну здесь, кстати, давайте я даже вот эту сумси, ну вот, то есть это я сейчас
сотру, давайте это я сотру, так все давайте забыли о сумме, то есть вот эта идея осталась,
а вот сумма нам сейчас не интересна, сумма слишком легко побеждается, была для примеров. Да, но здесь
конечно важно подчеркнуть, что в апдейте мы делаем именно мин равно, то есть не заменить значение
корня на произвольное, а именно его уменьшить, декриски сделать по сути, но в данном случае скорее
декрис root получается, но соответственно, вот, но что же получается, значит как же этот минимум сделать,
но здесь возникает маленькая подлярчик, вот, значит, да, значит, смотрите внимательно,
сейчас будет немножко, да, сейчас будет немножко магии, вот, потому что действительно мы тут не
случайно вводим теорию, неожиданно начинаем усложнять теорию, потому что сразу скажу,
просто так гарантировать, что у нас, просто так гарантировать, что у нас все будет хорошо,
нельзя, да, а что такое хорошо, ну, мы будем говорить, давайте я сейчас веду маленькое,
значит, возникает такое маленькое техническое определение, значит, определение, значит,
ребро, допустим, в, у, которое равно, там, ради, там, parent от в,
будем называть его хорошие, да, ой, извините, так хочется побаловаться, хорошие или не баловаться,
ну вот, ну ладно, значит, если сз от у больше либо равно 2сз от в,
нет, ладно, не буду, ладно, не буду баловаться, вот. Чего? Нет, нет, нет, нет, нет, это, ну, опять
это у нас легкое ребро, а в-третьих, в данном случае нет понятия легкости тяжелости такого,
почему, потому что, на самом деле, у нас, там, победа, собственно, в основном эсэнемия заключалась в том,
что у нас все ребра делались лёгкими целенаправленно, все ребра были хорошие, поэтому победа, вот,
здесь нам придётся сразу, скажу, ослабить опенчение, значит, определение такое, ребро,
в и у, которое равно parent от в, значит, мы его будем называть среденькое, среденькое, если сз от parent
от у больше либо равен, чем 2сз от в, да, подразумевается, что этот parent ещё и существует,
вот, да, значит, сз имеется в виду в не сжатом дереве, вот, сейчас это вот, сейчас, да, там написано
2, да, это важно, давайте, тут я, давайте, вот, то есть, как видите, в чём заключается средненькость, да,
то есть, как бы, вот, то есть, как бы, жёстко это ребро хорошее всё, идёшь к родителю, родитель два
раза круче тебя, вот, всё, тогда это ребро хорошее, оно прям вот улучшает жизнь в два раза, а вот ребро
средненько, если, ну, как бы, обращение к родителю ещё так не помогает, но если дойти до дедушки, то точно
всё хорошо, так что ребро средненькое, ну, я не знаю, честно говоря, я не знаю, вот как бы вы перевели
введённый Тарьяном термин медиокр, вот как-то переводить, вот, вот тут, тут реально гуд было,
ну, вот, да, вот, нет, ну, давайте, смотри, потому что по таким синоним, вот, пожалуйста, средненько,
ну, средненько и получается такое, да, хотя, наверное, можно было перевести неплохое,
заурядное, не, ну, заурядное, а там в серию говорю, заурядное, что, ну, а так как это, да, как говорили,
все натуральные, да, да, терема, да, терема, да, против это терема, все натуральные числа интересные,
надо доказать, что пусть это не так, тогда найдётся минимальное, там, неинтересное число, ух ты,
интересно, чем же оно такое неинтересное, это классика, да, так вот, так вот, утверждается,
значит, так вот, терема, значит, сейчас будет, может быть, с известными оговорками, но, тем не менее,
если, я так сформулирую, если все ребра, допустим, средненькие, ну, ладно, давайте, я говорю,
или ведут в корень, в корни, точнее, то тогда, я вот, ну, вот, то деревья, я так напишу, удовлетворяют,
условия, теремы два, с, там, с равно, а равно, корень из двух, вот такая неожиданная заява,
вот, да, я, по идее, да, если совсем патальяно, то я должен бы сказать,
что дерево называется сбалансированным, если вот это вот, вот, ну, вот такая интересная заява,
спрашивается, а точно, верите ли вы, так, нет, ну, давайте, нет, просто зачем введено
с, корень из двух, а введено, ну, вот зачем, мы хотим показать, что, там, при вот таком, при вот
таких условиях, мы хотим показать, что количество вершин ранга h у нас не более чем, там, получается,
в нашем случае, корень из двух n поделить на корень из двух в степени h, ну, если h равно нулю,
то все очевидно, а если h равно один, то тоже все очевидно, потому что шлеп-шлеп n радость,
да, вот, зачем, собственно, этот корень из двух и взялся, так, что, может быть, чисто для базы
индукции, так, давайте, разбираться с переходом, так, вот, как, там, доказать, действительно,
то есть, вот эту штуку, если у нас h больше либо равен двух, в предположении, что для
меньших рангов все доказано.
Ну, да, хочется, конечно, осталось только выяснить, а из каких соображений мы вообще можем сказать,
что у нас вершин ранга h не более чем хоть сколько-нибудь, а чем оно поможет? Вот,
как, там, в данном случае, средненькость поможет. Ну, да, ну, хотелось бы, но они говорят что-то
про СССР, поэтому в идеале, конечно, наверное, хотелось бы, наверное, что, то есть, это,
видимо, будет следовать из там леммы, что там какой-нибудь леммы, что если, ну, такое, что СЗ
от вершины В должно быть больше либо равно, чем что-то там связанное с рангом, а что связанное с
рангом? Ну, наверное, ну, давайте попробуем, что корень из двух в степени h минус один. Ну, в принципе,
ну, заметим, что если я сейчас, да, где я вот напишу, что h равно ранг от В. Ну, заметим,
по большому счету, что, в общем-то, из этой леммы, если нам такую лемму удастся доказать, вот эта
сиаремма доказывается автоматически, правда? Видно, почему? То есть, видно, почему тут я вообще
минус один какой-то написал, да? Вот, да, тут действительно так. Вот, ну, давайте разбираться.
Вот. Ну, действительно, как это доказать? Ну, видим, база индукции там для h равно 0 и 1, очевидно,
да, минус 1 подогнанными для того, чтобы для h равно 1 работал. Так, ну, теперь давайте смотреть.
Ну, если у вершины ранг больше либо равен 2, то есть, вот жила была вершина В, у нее ранг h,
но тогда у этой вершины есть внучек. В общем, не просто там внучков у него может быть много,
но у нее есть явно внучек ранга h-2. По предположению индукции, у нее тут СЗ больше либо равен,
чем корень из двух в степени h-2-1. Логично, да? Просто я вот то же самое условие написал. Так,
переходим сюда. И что же здесь получается? Тогда вот, то есть, мы знаем, что все эти ребра,
все такие ребра, которые не ведут прямо в корень, являются средненькими. Значит,
переходим к дедушке и получаем, что здесь СЗ от В больше либо равно, чем получается 2 на корень
из двух в степени h-2-1. Ну, так как у нас корень из двух в квадрате это 2, то получается шлеп-шлеп.
Равно корень из двух в степени h-1. Доказательство окончено. То есть, вот такое вот неожиданное
послабление. Ну, в принципе, отсюда можно вывести, что мы теоретически могли бы ослаблять и до
про дедушек и так далее. Но нам сейчас достаточно ослабить только, собственно, до дедушки. То есть,
таким образом, задача в минимуме сводится к следующему. Надо так организовать операции
и слияния, чтобы у нас все деревья, которые получаются, состояли исключительно из средненьких
ребер. То есть, если они будут состоять из средних ребер, то мы автоматически победили.
Так, есть ли на этот момент какие-то вопросы? Так, все понятно? Вот, да, в телефоне тоже самое написано.
Значит, тут теперь начинается самое интересное. Так, сейчас я вот это все... Так, ладно, это все
можно убирать? Так, вот это все можно убирать или что-то из этого желательно оставить? Вот. Ну,
давайте так. Ладно, мысленно, только главное, что сейчас надо запомнить, это определение средненького
ребра. Вот, как бы запомнили, что как бы мы победим. Ну, вот что, как бы средненькость это победа.
То есть, нам да.
Так, а у нас теперь вот что. Значит, сейчас тут будет действительно немножко магии. Так, значит, мы
делаем минимум. Так, главное сейчас не перепутать, потому что, к сожалению, вредный тарьян в оригинале
делает максимум, сразу предупреждаю. Так, значит, смотрите. Значит, идея такая. Значит, сейчас, значит,
начнем сразу со страшного слова. Значит, каждое дерево я буду хранить не совсем в виде дерева.
Я и сделаю неожиданную штуку. Смотрите. Значит, только данных будет. Ну, понятно, что изначально у меня там
все. Ну, понятно, что изначально у меня там, понятно, все деревья состоят из одной вершины, да. Ну, из одной
вершины дерево там состоит, понятно как. А теперь смотрите. Каждое дерево. Ой, не тот маркер. Значит,
каждое дерево будет у меня состоять из цепочки деревьев. Смотрите внимательно. То есть у меня будет вот такая
цепочка деревьев с корнями V1, там допустим V2. Ну, V1 равно V. Это будет основной корень. Но внутри будут
вспомогательные корни. Вот. То есть они будут соединены вот в такую цепочку. Ну, там, там список
какой-нибудь там, что угодно, неважно. Вот, смотрите. То есть все, то есть идея будет такая. Смотрите
внимательно. Все вершины будут находиться, ну, которые должны находиться в под деревья, будут
находиться вот в этих вот деревьях. Ну, не обязательно пяти, но вот сколько их тут есть. Ну, давайте я тут
поставлю многоточие VK, чтобы не было. Значит, тут вот висеть какие-то деревья, да, забирая вперед они
будут хорошими, там, средненькими. Да, хорошими они не будут, на среднем, но это как бы мы будем потом по индукции
доказывать. Вот, вначале они какие-то будут. Значит, идея будет такая. Значит, еще будет такой важный вариант,
что там, допустим, что вал от V1 будет у нас, да, там, допустим, больше, чем вал от V2, больше,
чем вал от V3, больше и так далее, больше, чем вал от V3. Ну, значит, сразу такую сформирую так. Если там есть
равенство, то на самом деле никто не мешает вам из этих двух деревьев быстренько сделать одно, причем подвесить
одно за другое так, как вы считаете нужным, то есть по адекватной ССДшке. Нет, в корне минимум храниться не
обязан, тот и проблема. Ну и, как вы уже догадались, когда у вас будет цель сделать апдейт от какой-то
вершины, лежащей тут где-нибудь внутри, то вы будете делать это сжатие путей только до своего
промежуточного корня. То есть вот сюда вы бегать и сжимать не будете, то есть только внутри этого
дерева. Понятно, да? Эвал. Да, как будет делаться апдейт? Нет, хотя нет. Как делаться апдейт, как всегда,
понимание операции значит, что сейчас будет уровень easy, уровень medium, уровень hard, уровень easy. Как делать
эвал? Эвал просто делать сжатие путей в своем дереве. За пределы его мы не выходим, то есть там вот
дошли до V4, все, значит, вот выше не ходим. Понятно, да? Ну, собственно, тут очень-то бесполезно, потому что,
ну тут очевидно, да, это как бы бесполезно, потому что здесь все равно валы больше. То есть мы такое
делаем, сжатие путей, но не сжимаем. Да, потому что можно было бы сказать, что у нас есть виртуальное
дерево, оно состоит так из вот этих вот деревьев и вот эти все корни тоже на самом деле тут идут,
вот это, так сказать, потом как родители, то есть корни. Ну вот, но просто вот конкретно эти
ребра мы просто так на халяву не сжимаем, пока во время эвала точно. Да, что делать с эвалом? Что
делать с апдейтом? Да, но еще важный момент, конечно, в каждой вершине мы СЗ-шку храним. Ну,
обычно в корне дерева, как вы помните, СЗ-шку хранить в общем-то не проблема. Значит, смотрите,
немножко магии. Значит, как делать апдейт? А что нам нужно, чтобы сделать апдейт? Нам
нужно сделать мин равно х. То есть нам дам какой-то х, и надо вал в один заменить на
минимум из себя любимого и х. Но если х оказался больше либо равен этого вала, то вообще ничего
делать не надо. Но, допустим, оказалось, что х все-таки меньше. Причем, скорее всего, что-то мне так
подсказывает, что-то мне почему-то подсказывает, что х на самом деле будет меньше чаще всего не
только вал от В1, но и меньше всех вешек на некотором префексе. Вот до какого-то момента он
будет меньше, а потом в какой-то момент он бац и старит там больше либо равен. Логично, да? То есть тут
больше либо равен, а тут меньше. Тогда идея такая. Тогда, во-первых, начнем с того, что можно все эти
значения, тогда все все значения в корне мы заменяем на х. Это, во-первых. Во-вторых, следующее,
что имеет смысл сделать, что имеет смысл сделать, это, конечно же, объединить эти деревья в одно. Ну
прямо вот по цепочке вот эти два объединить, потом результат объединить вот с этим, ну и так далее.
Объединяем, конечно же, таким образом, что подвешиваем меньше пассажки дерева к большему. То есть это
очень удобно, потому что у нас, ну это удобно как минимум, потому что новые ребра, которые появляются,
они уже сразу хорошие. Да, кстати, да, маленькая лемма, хорошее ребро, хорошее ребро является
средненьким. Ну ладно, хорошо, да. Ну хорошо, как только оно перестанет вести в корень, оно будет
средненькое. Вот так. Значит, хорошо, средненькое, так средненькое. Вот. Ну правда, это, конечно,
еще не гарантирует, что там ребра, которые перед этим вели в корень, стали средненькими сами по себе.
Но это мы будем доказывать постепенно. Вот. Но здесь, соответственно, это сжатие делаем, и более того,
уже на уровне амортизации выявляет ощущение, что эти слияния деревьев нам достанутся за бесплатно,
потому что, как вы уже догадываетесь, у нас количество деревьев увеличиваться не будет,
только уменьшаться. Поэтому никаких проянот. Поэтому сжатие нам достается фактически за
бесплатно. Вот. И так. Но это был уровень медью. Тут пока все просто. А теперь начинается
уровень хард. А как, собственно, объединить два таких интеллектуальных путя? Пути. Путей.
Путю это вообще язык, что-то это единственное число какое-то. Путёв. Вот.
Смерчить. Ага. И предлагает прям честно бегать по этим путям и их мерчить. Ну, будет сомнительно
просто потому, что на это количество деревьев не будет уменьшаться и непонятно, откуда возьмется
там хоть какая-то амортизированная симпатика. Вот. То есть это как-то само вообще долговато.
Поэтому, значит, действовать будем немножко по-другому. Так. И так делаем. Внимание. Делаем линк.
Значит, первое, что делаем, то есть первое, просто сразу, это делаем update a w значением
вал от w. Прям вот сразу с порога. Просто как волфой на счёт два сразу. Просто. Раз, два,
update w, вал w. Всё. Вот. Ну, я надеюсь, вы от этого там, собственно, не перекуридулись через себя
три раза. Вот. Начится. Перекуридулись. А в чём вопрос? Ну, так. Так. Ну, вот. Значит,
сейчас мы хотим слить вот эти два дерева. Вот. V и W. Мы гарантируем, что вал здесь. То есть сейчас
мы уже гарантируем, что вал от V меньше либо равен, чем вал от W. Нет, хуже. Больше либо равен.
Ну, это так. На всякий пожарный. Вот. Ну, и теперь высягает вопрос. Так кого же, куда же подвешивать
G? Как же подвешивать G? Вот. Ну, наверное, надо подвешивать меньше к большему. Да. Ну,
потому что, да, начнём с того, что в вершине V и W можно хранить не только СЗ каждого поддерева,
но и можно хранить, наверное, СЗ всего, всей вот этой вот конструкции. Правда? Не очень сложно.
Так вот. Так. Ну, давайте, давайте ещё деревья как-нибудь обзовём. Альфа 1, альфа 2, альфа 3,
альфа 4, альфа 5. А эти деревья назовём там бета 1, бета 2, бета 3, бета 4, бета 5, бета 6, бета 7.
Ну и так далее. Вот. Та переча. Значит, кого же, куда же подвесить G? Как G жить G? Ну, жить
оказывается достаточно несложно. Значит, мы хотим подвесить. Всё, нет, сложно жить, да? Нет? Ладно.
Господи. Вот. Как говорится, да. Как это страшно, когда о сложности жизни говорят студенты первого
курса. Да. Ладно. Значит, смотрите. Ну, а первым, значит, рассмотрим два случая. Значит, такой стандартный
метод. От создателей таких хитов как, заметим, что там, называется там, докажем по индукции.
Значит, рассмотрим два случая. Случай номер раз. Неожиданно оказался, что глобал СЗ от В оказался
неожиданно больше либо равен глобал СЗ от В. Тогда, что мы делаем?
Хочу. Так или не делай. Хотя надо подумать или нет. Вот, если глобал СЗ или локал СЗ.
Нет. Вопрос не введения, а вопрос в данном случае именно по сути. Ладно. Значит, смотрите. Идея
вот такая, что хочется подвешивать меньше к большему вот в таком интересном формате. Значит,
в этом случае мы будем делать так. Значит, вот эти вот альфы никуда не денутся. То есть это всем,
значит, это вот все как бы будет. Там В3, там допустим. То есть там В4, В5. Это все на месте. Это
все на месте. Это все никуда не девается. Это все хорошо. То есть тут альфа 2, альфа 3, альфа 4,
альфа 5. Вот. Так. А вот если я... Ну вот, но идея такая. Так вот, дело в том, что я хочу просто
взять вот эту вершину, на которой висит вот это целое под дерево. Вот это вот альфа 1. Так вот,
я хочу на него еще кое-что навесить. Кое-что это бета 1, бета 2. Ну, принцип вы поняли. Бета 7.
Так что у меня теперь вот такое вот супер под дерево вершины В. И тупо взял и повесил. В чем?
Обратите внимание, хуже, пока что с точки зрения правильных эвалов, хуже не стало. Правда? Это вот
самое главное. Это прям основное. Да, без этого там смысла нет. Но утверждается, что достаточно,
тогда если у нас с СЗшкой повезло, надо просто повесить вот так и не заморачиваться. Вот. Так что
вот такая вот неожиданная нот, такая вот неожиданная красота. Вот. Хотя, действительно,
глобал СЗ для этого нужен или нет? Потому что нам же нужно теперь по индукции доказывать,
что серебро средненький. Вот. Ну, впрочем, ладно, по нотам, что нам это пока дало? Пока нам это
дало, что у нас появились ноты. Там появились какие-то новые. Ну, давайте смотреть. И теперь
второй случай. Второй случай, когда выясняется глобал, ну, будьте готовы стереть у себя,
может и локал будет сейчас. Когда наоборот. Когда как-то вот тут много, тут мало. А вешать
хочется В к В. Что делать? А тут, смотрите. А тут тогда возникает идея такая. Мы все равно будем
вешать В к В. Но в более хитром виде. Значит, у нас теперь будет супер цепочка В. Значит,
вот это вот W со своими В1, В2, В3, В7. Сколько там? В5, В5, В6. Вот это вот. В4. Вот. Значит,
все это мы подвесим к W. Заметим. И вариант сохраняется. Ну ладно, если тут равенство,
то мы их схлопнем как-нибудь. Вот. Но на вершине В, на вершину В я теперь повешу все. Все в смысле
альфа-1, альфа-2 и так далее альфа-5. Вот такая вот у меня идея. То есть повешу прям вот так,
прям в явном виде. То есть у меня вот альфа-1 будет. То есть вот давайте я даже более точную
картинку нарисую. Что да, ну да, много ребр создаем. Сейчас, где-где? Что имеет в виду?
Ну типа. Вот. Вот. Вот. Так. И вот тут-то мы начинаем выяснять. Что мы начинаем выяснять?
Ну кроме того, что кто-то уже засыпает, конечно. Отличается тем, что в первом случае мы схлопнули
вот это подвешиваемое дерево. А тут мы схлопнули то, к которому подвешивают. Ну как схлопнули,
вот так подвесились. Конечно, внутри меньких жатей не делали. И теперь нам хочется поглядеть
на эту интеллектуальную картинку и неожиданно сказать, что ура! У нас теперь внутри там деревья
все ребра средненькие. Остается только маленький вопрос. С какого перепуга?
Нет, ну давайте разбираться. Что? По индукции. Нет, ну смотрите. Ну логично, что, наверное,
по индукции. Ну можно по индукции, а можно просто. Смотрите. В каждом из этих двух жатей у нас
появляются новые ребра. И хочется доказать, что эти ребра в будущем будут средникими. Логично,
да? Ну как это доказать? Ну очень просто. Во-первых, смотрите. Кстати, важно обратить
внимание, что новые ребра у нас появляются не только в рамках линка, но и в рамках апдейта.
Правда? Более того, кстати, какая-то часть апдейта уже могла тут появиться, потому что, помните,
если у нас тут образуются равные какие-то элементы, мы их там хотим схлопывать. Но заметим,
что они нам погоды не делают, потому что ребро, которое появляется в результате объединения двух
вершин с одинаковым корнем, оно автоматически становится хорошим. Но хорошее ребро значит в
будущем уж средненькое точно. Хорошее ребро в будущем не ниже среднего будет. Пока логично.
Вот. Топереча. Топереча. Но что же делать? Нет, это очень приятно. А что делать с вот этими
ребрами, которые вот образовались либо вот в этом случае, либо вот в этом? Ну для этого надо
посмотреть. То есть мы знаем, что когда-нибудь в будущем, возможно, из вершины В1 будет торчать
ребро куда-то в родителя. И нам хочется в этот момент сказать, что когда этот родитель определится,
все эти ребра будут средники. Ну, собственно, по сути, ровно это и надо доказать. Тут может
быть немножко нетривиальная индукция какая-то, может быть, там покажется нетривиально. Но вот
смотреть надо именно с этой точки зрения. То есть надо посмотреть, когда появляются новые ребра и
показать, что они в будущем когда-нибудь, то есть когда они перестанут быть корневыми,
они станут средникими. Но давайте смотреть. Во-первых, когда, вот давайте вот первый случай рассмотрим.
Жила была вершина В1 и в какой-то момент в будущем она перестала быть корнем, там ее куда-то повесили.
Но куда повесили? Если ее повесили в результате какого-то апдейта, то ее повесили на хорошие
ребра, а хорошее ребро своих детей автоматически делает средниками. Вот, логично, да? Вот, поэтому это
не очень интересный случай. Вот, более интересный случай, и вот тут-то нам вот с этими глобулами
придется подумать, глобул имеется в виду или локал какой-нибудь. Надо тогда подумать. Хорошо,
вот мы здесь тут действительно что-то повесили. А теперь, хорошо, а каким может,
откуда еще может взяться ребро из В1 куда-нибудь, если не из апдейта? Откуда еще такое ребро может
взяться? Да, ну тут что-то же происходит. Переподвешивание, да, но может быть в процессе
предповешения вершины В подвесить? Да, а каким образом может это произойти? Каким-то может быть.
Да, да, это называется не видно, а вот так, вот, да, конечно, да, то есть, конечно, то есть,
на самом деле это может, то есть, либо произойдет в апдейте, либо произойдет вот так. Хотя,
нет, ладно, даже не так, не важно. Хотя, да, ладно, даже не так, то есть, не сведение конкретно
к этому случаю, а просто глобально, когда неожиданно будет линк, который уже вершину В подвесит к чему-нибудь.
Но давайте посмотрим, что там будет, ну вот, что там, соответственно, будет происходить. Так,
ну а теперь давайте думать, а какой случай. Ну вот, с другой стороны, заметим, что схлопывание,
может быть, вот, то есть там будет какое-то схлопывание, но схлопывание кого непонятно.
То есть, схлопывание кого там будет понятно не очень. Но с другой стороны, заметим,
ну вот, то есть, заметим, что сейчас у нас ребра ведут вершину В, и на них, и новыми
ребрами стали вот эти вот б1 б2 и так далее да заметим следующее что если новое
схлопывание второе произошло по второй схеме то тогда у нас объединились
буквально вот эти вот деревья правда
но тогда если они объединились то тогда заметим что тогда но то есть то есть они
как бы все объединились и подвесились к новому корню да и тогда у этого корня
сз оказался больше чем глобал сз вот этого вот а глобал сз этого вот больше
либо равен чем даже два глобал сз в потому что мы его сюда присоединили так
вот смотрите давайте давайте внимательно значит тут значит так тебе бы это где бы
это аккуратно нарисовать и так давайте представим что у нас был выполнен линк
там линк от vw по первой схеме
а потом был выполнен линк от
допустим ув по второй схеме тогда смотрите что у нас произошло
значит если у нас линк от vw вот по такой схеме произошел то новыми то у нас как бы к
вершине v то есть на вершине v висели вот и висел вот этот вот альфа 1 а также там еще на ней
продолжает висеть там альфа 2 альфа 3 и так далее но вот но новинка заключилась в том что мы сюда
повесили вот новые деревья новые балалаечки вот эти б1 б2 и там соответственно б это ну сколько
там допустим 7 на нас собственно сейчас вот про эти ребра интересует да то есть вот эти
ребра стали новыми поэтому нас интересует эти ребра в будущем будут ли средниками или нет
но что произойдет дальше потом появился линк от ув то есть линк от у то есть допустим у нас
тут был еще какой-то давайте еще где-то посередине образовалась вершина у и у нее тут деревья там
где вот это гамма 1 гамма 2 гамма 3 там допустим гамма 4 ну и допустим все так вот и решили и не
она вот решили мы к ней подвесить вершину вы и неожиданно это образовалась по второй схеме
но вот
тогда значит что он вот что у нас тогда произошло тогда но вот действительно если
мы решили по ноту решили решили подвесить в акул а у нее размер а нота сейчас ну да ее размер
оказался меньше начало то есть то есть у нее но тогда тут будет что тогда получается что мы
должны были вот схлопнуть вот эту гамму правда то есть получилось примерно следующее
но вот то есть получилось у нас действительно какой-то там с там допустим гамма 1 там гамма 1
тут получается гамма 2 там какие-то вот еще гамма 3 допустим гамма 4 еще и тут еще цепочка что это
за гамма я но вот значит тут получается дабл ее значит и тут висят соответственно бета 1 бета 2
бета 3 и так далее вот нет и правильно да значит неправильно потому что во первых тут альфа альфа
2 альфа 3 и так далее а во вторых тут еще висят какие-то бешки так что это поменяло
мы заметим длительного ничего не поменялось они остались корневые пока все в порядке правда
поэтому на самом деле да то есть интерес то есть скорее интересно становится
но вот это интересно когда вот это вот но вот это но теперь ждем когда у нас сама
вершина в еще куда не подвесится но это но теперь смотрите вот тут два варианта то есть
действительно что может поменяться для вершины в почему ну вот и да теперь да теперь да страшно
но теперь у нас тоже два варианта и вон вот потому что там и в одном из этих нот и в одном из этих
вариантов все вот эти под деревья подвесится к вершине у видно все ноты все эти деревья подвесится
вот потому что для них пока для них ничего не поменялось пока ничего не
очевидно и ничего не поменялось они как были корневыми вот эти новые красные
гобры так и остались нет они все еще висят на корне своего дерева то есть в напоминаю
она не подвешена на самом деле то есть просто вы перестала быть глобальным корнем но
локальным корнем своих деревьев она осталась вот теперь не текает вопрос а что собственно в
будущем может произойти вот в будущем но в будущем на самом деле может произойти примерно
следующие то есть вершина то есть на самом деле в будущем один из вариантов это то что вот все это
дерево слопнется воду то есть мы неожиданно захотим все вот это вот подвесить к вершине
что это за вариант кстати она это вот тот самый вариант вот то есть если мы к вершине
у захотим подвесить еще что-то причем большего размера и тогда получается да что эти деревья
станут потомками вершины у на которые висит вот это все вот но вот но соответственно теперь
очень хочется сказать что конечно же и конечно с этот глобально там на созерту будет висеть
весь этот глобальный размер который хотя бы в два раза больше чем глобальный размер вот этих бэш
вот хочется почему-то в это поверить
а почему нам это не поверить а ведь обратите внимание вот когда мы делали линк в в по 1 мы
это делали в предположении что вот эти вот деревья суммарно имеют вес меньше чем вот это правда
следовательно вот глобальный cz от этого увеличился хотя бы в два раза правда поэтому если то есть мы
в значит соответственно подвесили к у а потом в какой-то момент это дерево схлопнулась в чем
не важно в у она схлопнулась или во что-то еще но хотя заметим теперь следующее что у нас там
ну заметим следующее что дерево у нас дерево у нас теперь устроен так что ну либо схлопнется
но либо глобально схлопнется объединиться все в одно да в будущем либо но там допустим вот эти
ув или кто-то там еще они неожиданно объединяться потому что них там окажутся одинаковые лейблы
но как мы помним если вершина в подвесит в результате такого объединения то там уже все
ребро хорошее оно автоматически сделать эти ребра средники да а если мы вот а если в какой-то
момент там произойдет вот это вот схлопывание а пока оно не произойдет принципе с вершины
останется корнем но то тогда кажется что там она то тогда все это все эти ребра будут участвовать
значит в глобальном дереве то есть окажутся так сказать то есть эти эти деревья оказывается внуками
то есть эти вершины окажутся внуками корни и сзшка у них будет содержать все эти альфы поэтому
значит их поэтому тут будут явно больше чем в два раза чем то что было раньше
вот так что получается что значит что у нас получается мы рассмотрели случаи когда у
нас линк vw был по 1 а линк от ув по 2 видно да ну да есть только не выяснито что это
стало что это основной интересный случай ну давайте разбираться потому что давайте посмотрим а что
делать если у нас линк ув окажется то есть там действительно линк ув окажется по первому
случаю нет почему не пойдет как раз пойдет вот давайте разбираться так хорошо вот
случай 1 2 допустим рассмотрели да вот хорошо давайте сейчас я вот давайте давайте уши давайте
рисовать сейчас на картинке так рисовать где тут запутаться действительно есть
смотрите внимательно значит линк ув допустим теперь по 1 что у нас тогда что у нас тогда
а тогда будет следующее значит то есть что у нас произошло значит что такое слияние по 1 это
означает что нас вот эти ушки остались то есть жила вот это ушко на месте гаммы на месте вот
вот гаммы вот и значит и к ним мы неожиданно решили подвесить вот это все
ну да то есть получилось альфа 1 ну давайте так повесим тут альфа 1 альфа 2 там альфа 3 и
так далее но самое для нас приятное шумы тут но вот нет ситуация
тут на самом деле есть маленькая хитрость маленькая хитрость ситуация на самом деле
ухудшилась потому что куда делось верх�� è вотblind вот в этой первой ситуации куда
делать сама вершину W, то есть она на самом деле
куда-то делась, она находится вот здесь W1, поэтому сама
вершина V на самом деле куэрнот, то есть на самом деле, поэтому
я тут немножко наврал, альфа 1 висит мне здесь, то есть
на самом деле в результате этого слияния, то есть
теперь бесит вот здесь на нем бесит альфа-1 и вот это все
бета-1 бета-2 и так далее и все вот это вот это теперь
единое дерево вот с гаммой вот с гаммой 1 вот поэтому
не все так просто поэтому в этот момент эти эти красенькие да то есть это вот да не
совсем так я плохо рисовал то есть вот теперь бета-1 тут висит бета-2 висит и так далее поэтому
вот эти красные ребра они теперь уже они уже не корневые и надо прямо сейчас доказывать что они
средненькие как же нам это сделать вот это интересно смотрите глобал смотрите
глобалта сайс увеличился а локал нам же нам же локал нужен
ну давайте так ну да чего нет у нас ладно смотрите но так нет но опять мы знаем следующее
что сумма всех гамм она больше чем сумма всех вот этих вот в плюс в почему потому что мы так
складываем вот да но да но с другой стороны да заметим что сумма всех альф при этом напоминаю
да больше ли правда чем сумма всех бет потому что вот мы тут так сливали да поэтому да то есть
эти ребра бы на этих ребах висели беты а вот на этом на этой вершине уже теперь висят не только
все беты но и все альфа поэтому все в порядке нет вот скажи чего нет не обязательно смотрите
ребра из бет ведут вершину который помимо самих бет висит только альфа 1 остальные альфа выше
висят да поэтому да вот поэтому да поэтому нет но от хорошести еще нет так таким образом
случаи один один рассмотрели так ну что осталось еще два случая господи тесно генерида и тесне
не взяли четыре случая как-то быстрее и рассмотреть пошутить альфа там что-то там просто пару строчек
написал там типа из разряда ну там все там вот вот но собственно нам-то нам-то в общем-то не
принципиально так как бы мы люди мы люди простые надо рассмотрим 8 случаев и 16 и 32 и 64 вот так
да потом нам немножко надоест позовем мудрецов потом выяснилось что нас ограбили потом да вот
потом мы вспомним что там один шахматист уже так одного правителя нагрел по этой схеме знаете
про знаете схему да нет но там легенда была такая что там там разные варианты но суть такая что
там звать условно там один один крутой там шахтам впал в депрессию выражай современным языком
абсолютно депрессия просто типа все скучно то есть там я типа там вроде все есть как бы да все
везде все удовольствие как-то что-то нет и пришел какой-то бегя корея но ты говори слушай да сейчас
эти излечу он да откуда ты можешь знать меня тут он самый крутый лекарь не знает что со мной а я
знаю допишите просто скучно ну просто ты как тебя как-то не чем думать за те другие думать нечего
делать за тебя все делают в общем короче эти принес лекарства которые заставит тебя думать и
показывает ему шахматы вот вот это игру назвал шахматами потому что нужно излечить шаха вот
но вот и стали играть шахматы но вот и но как-то стал выздоравливать потому что действительно так
стало и вообще стало интересно стал вообще долго вообще думать на размышляет от каждым ходом ну там
играли играли в какой-то момент он даже первые партию выиграл и возрадовался вот и говорит слушай
давай слушай я тебе слушай спасибо тебе огромное слушай вообще что ты хочешь дам тебе все он слушай
у тебя в стране столько бога но то там разные легенды говорят до доброго слушай понимаешь
что мне слушай у тебя в стране столько бедных накормить пожалуйста вот лучшим подарком ой да
давай я тебя хочу дарить а не ну мне-то немного надо смотри вот видишь шахмату доску смотри значит
мне немножко риса надо вот смотри значит вот это на первую клетку кладешь одну рисинку на
следующую две на следующую четыре и так удваивай пока доска не кончится да да господи да легко
сейчас мы тебе это ну догадывается чем закончилось да да да да да не закончится
но у него всех хранили чехла все бы там да в общем ночем одна из версий легенд говорит шуму вот
то что товарищи в итоге голову отрубили да вот другие легенды нет но чем вы это шок был вот так
что вот такая вот так что такая вот схема да простая вот значит что у нас теперь значит какие
у нас случаи а ну теперь у нас значит поехали так давайте предположим что у нас теперь произошел
линк в в по 2 по второй схеме то есть тут у нас оказалось наоборот альфы меньше бет поэтому у нас
теперь целая значит у нас тут целая цепочка вот этих бет целая цепочка вот этих там вот
бет не буду дорисовывать то а тут есть вершина в на который неожиданно повесились все альфы там
альфа 1 альфа 2 и так далее так что мне причем ну как повесились ладно не все повесились альфа 1
он не повесился потому что он на ней так и висел а все остальные а вот все остальные за новые ребра
повесились вот и вот там про эти ребра теперь жутко интересно так ну теперь давайте разбираться
что же про и зайдет дальше так ну видимо давайте аккуратненько два случая рассматривать если
дальше у нас ну заметим да что тут у нас могло произойти что могло произойти ну во первых
заметим что прежде чем мы вершину вы куда-то повесили могло схлопнуться вот это все правда
могло сломаться но с другой стороны ладно от того что она схлопнулась нам не горячо не холодно
ну ладно хотя нет если заметим что если хотя бы вот этот путь уже схлопнулся то тоже хорошо
почему потому что вот эти ребра неожиданно стали хорошими уже в принципе победа вот ну а теперь
давайте думать а могло ли так случиться что эти ребра перестали то есть вершина вы перестала
быть корнем но при этом дерево не схлопнулась как такое может быть ну кроме объединений в обдайте
конечно да то есть это могло но вот но то есть это могло конечно случиться когда мы неожиданно
то есть когда мы неожиданно года опять reduce видимо вершина w пристать быть корнем ну заметьте
давить у нас кое-кое не стой advance, как вы его то есть если линк то есть линке вот вершина в
остается корнем всегда вот поэтому да поэтому неизбежно attractedทуве но давайте смотрите по
какой себе ну давайте ладно давайте уж по порядочку пойдем по первому да
аналогично аналогично прошлому по два ну ладно ладно хорошо ладно но впрочем
линк ув по два к чему он нас приводит но нас опять приводит к той же ситуации
жила была вершина у жила была вершина в на которые висят там и дальше все эти
беты вот вот значит соответственно тут у нас альфа один тут значит вот эти вот
ребра но пока ничего не произошло они остались к огневым вот но с другой стороны мы теперь
знаем что в общем теперь свершено вы ничего не произойдет пока все это дерево не схлопнется
понимаем да но при этом когда это дерево схлопнется эти все то есть когда все это
дерево слопнется вероя то есть это все эти деревья поветость тут подвесится к одной вершине может
уможет там какой-то еще будущей вершине на который будут висеть уже не только в со своими альфами но
и там к ней будут подвешены все беты а мы знаем что сумма всех альф у нас меньше чем сумма всех
бет понимаем да поэтому получается что в будущем никаких проблем не будет понимаем или убираем
ну мало ли вот то есть поэтому да то есть в будущем будет так то есть потом видимо ничего
кроме схлопывания произойти не сможет вот а если у нас линка тувэ произошел по первой схеме
если он произошел по первой схеме то что тогда так ну по первой схеме это означается что
но вот это значит что у нас там образовалась какая-то вершина у к которой неожиданно подвесили
саму вершин там то есть тут как ну во первых тут гаммы какие-то всякие да тут там гамма один тут
вот давайте вот даже более аккуратно нарисую тут гамма 2 и так далее но вот но вот это вот под
дерево неожиданно объединилось с кучей всего а именно во первых тут то есть на ней повесилась
вершина в со своими альфами и вот этими вот радостями альфа 2 альфа 3 там альфа 3 да вот а
вторых ноги еще и что самое для нас приятное повесились все беты там бета 1 бета 2 и так далее
вот ну что тут тогда сказать что уж в вершине у теперь на вершине у лежа висят не только все
альфы но и все беты а вес всех бет был больше вот то есть видео но то есть как бы у нас такое
отложенное подвешивание получилось то есть как бы то есть везде логика оказалось в том что мы
как бы больше то есть больше то есть меньшее деревья подвешиваем к большей цепочке в расчете
на то что в будущем это большая цепочка схлопнется и тогда эти ребра собственно и станут среденькими то
есть вот такая вот то есть такая вот красивая версия оказалась которую в принципе даже не
очень сложно реализовать если вам когда-нибудь такое потребуется ну там мало и дадут вам задачу
в которой там это дерево доминатором за инлоген не работает ты или ц вот прям сидите прям уминайте
но там мало и можно дадут вам там дерево доминаторов на 5 миллионов там мало ли мы все тогда вам все
что вам останется просто реализовать вот это вот собственно вроде как даже нет ну в общем-то
что это откровенное на убой да то есть как всегда то есть чип сложит то есть сложнее
действительно убедиться что все это работает но идеи на ничего сложного нет то есть обратите
внимание то есть вам даже за рангами следить не надо то есть обратите внимание за рангами даже
не надо следить все что вам нужно следить за со смер coping contrasts вы вот как всегда в общем как
а как это очень-то в в классическом основе принято рамки считать не надо надо считать
сэшки глобал сэшки и повешивать одно другому и там немножко стека ну в общем-то как бы есть
подозрение шоу как бы вы на своем жизни реализовывали что-то и повеселее например
декспер мутейшн на подотрезке не реализовывали ну ладно а ну как с этим кто в итоге реализовал
декспер мутейшн на подотрезке а ну вот кто-то реализовал таки да вот ну окей хорошо
так ну да пожалуй действительно пришло время пойти за кофе вот сейчас мы поговорим про
минимальные астовы в ориентированных графах так вот сразу уже прошлый раз возник вопрос а как
это вообще а суть на самом деле предельно простая у нас есть граф ну то что мы называли графом
потока управления то есть у нас есть граф в котором ориентированный граф в котором все вершины
достижимы из корня и это все что известно то есть никаких там от цикличности никто естественно
не гарантирует то есть тут все что угодно может быть даже может быть даже как-нибудь вот так
хотя-таки ребра нам не принципиально вот но все ребра взвешенные то есть тут какие-то
чиселки могут быть даже отрицательные числа что самое страшное не то чтобы нам это сильно
принципиально но тем не менее вот вот и наша задача найти минимальный астов что такое вообще
астов в данном случае астов это просто подвешенные за вот эту вершину эр просто абсолютно любое
астовное дерево ну то есть такие n-1 ребер по которым из эр можно дойти до всех вершин но
вот как-то так это примерно и будет выглядеть ну например вот так вот какой-нибудь вот такой
типичный астов ну и наша задача конечно же найти астов минимального веса так ну вот
спрашивается как же это сделать как же найти астов минимального веса ну для начала хотя бы
за какую-нибудь датику да леммочек на этот раз у нас к сожалению не будет но будет вместо этого
мелкое соображение мы заметим что в каждую вершину да начнем с простого давайте убьем
отрицательные ребра заметим что можно убить отрицательные ребра простым естественным
лайфхаком дело в том что в каждую вершину кроме корня будет входить в любом астове будет
входить ровно одно ребро поэтому если я каждому весу вершины в ходе там ребе ко всем ребрам
входящим в какую-то вершину добавлю допустим 3 то давайте тут плюс 3 и еще тут плюс 3 а было
тут допустим но минус 2 пусть будет пусть было вот где ну тут-то есть мы сейчас про это вершины
мы говорим про все ребра которые входят вот в эту вершину вот им прибавили 3 я утверждаю что
минимальные астовы от этого не поменялись да потому что это же следующее что у всех всех всех
астовов теперь вес увеличился на 3 поэтому кто из них минимальный кто максимальный не поменялся
да здесь все предельно просто и мы можем заметить что прибежавшие за в плюсе я могу в общем-то
полечить этот вопрос для всех вершин более того я даже могу еще обнаглеть я ж могу не только
прибавлять эти ветвица но если они оказались слишком большие еще и повычитать я могу добиться
того чтобы в каждую вершину в каждой вершины минимальные ребра которые в нее входила имела
вес 0 могу такое сделать да вот сделаю я такое за в плюсе и тогда у меня можно и тогда еще за
в плюсе можно проверить просто сразу голубую мечту идиота а нельзя ли случайно на нулевых
ребрах построить астов вот просто нельзя ли дфс от дойти до всего если повезет то удастся
и в этом случае тогда надо просто сказать что это минус 100 мы победили но что делать если нам
не повезло говорят нам два китайца а почему они нам это говорят так кстати а что знает так
а кто кстати знает что говорят эти два китайца так что прямой вот кто знает алгоритм двух китайцев
да да да а кто знает как зовут этих китайцев я не знаю там нет в программе экзаменов там
написано что-то но я не помню там помоги одного зовут литвен хонг по моему а другого как-то еще
вот правильно да для китайцев да смотреть первые те которые возникают и так мы тут
что-то пошаманили допустим значит мы сейчас знаем пока имели что у нас все ребра не отрицательные
поэтому я говорю следующее смотрите допустим у меня неожиданно образовалось ребро который
идет из корня куда-нибудь веса 0 утверждение я прямо сейчас должен его добавить в астов
но точнее не то чтобы должен там бывают я не могу гарантировать то есть тут надо быть как
всегда аккуратно я не могу гарантировать что это ребро лежит во всех минимальных астовах это
конечно может быть неправда потому что тут мало ли какие тут нулевые рюм вот тут какая цепочка
нулевых рюм да но точное утверждение звучит так существует минимальный астов с этим ребром
доказательства предельно просто то есть допустим рассмотрим минимальные астов которые
не содержат это ребро вот ну как-то вот так вот тогда идея такая в эту вершину какое-то
ребро входит и оно больше либо внуля но теперь аккуратно заметим что мы можем да на этой вершине
даже еще и какой там под дерево висит но тут вот тут нужна аккуратность да то есть видите
аккуратно видно что так у нас ребро из корня то мы можем убить это ребро и добавить вот это
ребро в астов и астов главное останется астовом и главное хуже не станет так что получается такое
у нас появилось первое шагное соображение если появилось такое есть такое ребро просто быстро
добавляем в астов можем мысленно пока мысленно даже эти две вершины теперь сжать в одну ну потому
что это ребро у нас уже все нужно у нас навсегда но теперь мы можем повторить эту операцию причем
повторить эту операцию можем не только с ребром торчащим именно из эра но и из этой вершины
выводит нас к это следующим вот мы запускали dfs то думали куда мы можем из эра дойти по ну
левым рёбрам ну левым рёбрам вот так вот как то красиво радостно красиво и радостно
вот тогда отрижайте нам возможно мы дойдем не до всего такое вполне возможно но по камере
докуда дошли мы точно можем спокойно добавлять в астов и не заморачивать понимаете да хорошо
говорим и да это мы можем теперь добавить в астов им и это сжать в одну ну минимальное ну не
минимальное а нулевое напомню что мы напомним мы добились того чтобы у нас каждый все ребра
но чтобы каждую вершину ходила хотя бы одну нулевую вот это вот это то же самое что рассмотрим
скажешь каждую вершину минимальный ребро который в нее ходит вот что это за нули заметим следующие
шутка как каждую вершину входит 0 то мы вынуждены заключить вот жадным образом ходя ходив
походя походив походю ну вот точно передвигается назад по ребрам ну а реально спасибо мы явно
рано или поздно зациклимся то есть мы нашли вот такой цикл то есть хотя бы хотя бы один
нет просто нет еще хуже у нас есть сколько-то там кавершин в каждую из них ходит ребро причем
не из этих поэтому в таком графе цикл обязательно есть вот на самом деле вытекает неожиданная идея
этот цикл тоже можно сжать в мета вершины в каком смысле а вот в каком ну просто идея у нас
будет такая мы сожмем вот эту вершину вот это в мета вершины и вот это мета вершины у нас
граф получится меньше и мы можем запуститься типа рекурсивно и тогда вот и тогда будет идея
действительно такая что потом когда мы будем разжимать ну понятно что в корне все вот это
разожмется и там ребра ведущие из этой мета вершины превратятся в ребра ведущие откуда-то отсюда и все
хорошо вот что будет происходить вот с этой металлической вершины из вот этого цикла
вот давайте тут 0000 вот и у нас обнаружится какое-то ребро входит когда мы тут построили какие-то
там начинают выходить но мы замечаем что вот это входящий ребро входит в круг из этих четырех вершин
вот такие идеи у нас возникает более того заметим что я тут вместо к циклу мог взять
просто какую-нибудь не тривиальную компонент усиленной связности даже обратите внимание только
но здесь уже только текает вопрос а почему это сработает но проблема в том что вот тут мы это
доказывали просто добавляя по одному ребро аккуратненько а вот здесь на самом деле это не
так очевидно то есть почему вообще вот это сжатие валидно почему обязательно их надо объединять
вот в единое такое нулевое поддельном уж не надо этого делать нет ну не факт подождите в дереве не
факт ну внутри нет что иметь в виду достижим они как же будут да давайте
это ребро это это ребро это как
тут ничего не поделаешь но это не совсем так дело даже не в том что это не оранжево-красный
может быть маленькая подлянка подлянка может заключаться в том нет там как бы
просто аккуратно тут надо быть аккуратно что как бы эти вершины не оказались в этом дереве предками
этой просто это может привести к зациклу вот почему я говорю тут аккуратно потому что очень
хочется сказать что давайте аккуратненько докажем да давайте просто аккуратненько докажем что вот
просто эти серебра можно там что эти ребра можно вставить взамен каких-то и получится просто дерево
не хуже но в чем подлянка теперь будет подлянка будет такая жила была казалось бы вот это первая
вершина вот да у нее тут было входящее да и вот мы тут решили рассмотреть вот это вот ребро с
нулем вот тогда но и мы тут говорим так в эту же вершину наверно кто-то входит да ну так давайте
это ребро убьем а это добавим хуже не стало только теперь начнет вопрос а почему при этом
дерево осталось дерево казалось бы как дерево могло перестать быть деревом простым естественным
образом ну собственно это единственная ситуация когда такое в общем-то возможно примете да
удалилось это другое а тут сюда то есть могло то есть как бы это ребро то есть
могло так оказаться что это ребро ведет из потомков предка в том деле и тогда пора вот то есть
заметим что вот это вот подмену нулевого ребра можно делать только в том случае если на текущий
момент оно не ведет из потомков предка вот если оно ведет из если оно ведет не не в своего предка
то такую замену локально по крайней мере сделать вполне можно почему нет поэтому
вот поэтому теперь нужно привести эти замены аккуратно ну нам в общем-то не нужно доказывать
что нужно привести именно эти ребра нам нужно доказывать что просто хотя бы там то есть что
можно этот цикл сжать вершину то просто доказать что это они образуют связанные дерево
логично вот на самом деле скорее такая то есть как бы рассмотрим наше дерево то есть если прям
вот очень аккуратно да то есть рассмотрим наше дерево дерево дерево дерево и вот эти вот четыре
вершины окажутся где-то под дереву раскиданы тогда у меня возникает естественная идея то есть
да выберем просто из этих четырех вершин там вот этой вот этой вот этой вот этой выберем
просто тупо самую высокую и все и тогда из нее уже тут нулевые ребра можно проводить правда
операцию нужно проводить аккуратно потому что дело в том что там допустим скажем вот тут вот
скажем так после того как вы тут подменили вот это ребро допустим на вот это то есть тут как-то
предки потомки сильно поменялись но правда при этом вот это нулевое ребро вы уже не трогаете вы
как бы можете вы уже сказали что это ребро существует поэтому его как бы жали да и потом после этого
сжатия как бы у вас тут вот допустим какой-то из этих ребер сжалось и вы тут в этом цикле
повторяйте операцию понимаете да в алгоритме этого делать из-за в коде это делать естественно
не надо мы просто доказываем что эту вершину можно сжать и будет все хорошо то есть что мы
доказываем что существует тут надо тоже аккуратно сформулировать да что даже после вот
этой сжатия вот этой мета вершины то есть можно сжать эту вершину то есть существует дерево в
вот эти вершины образуют связанное под дерево на рулевых ребрах что именно после
жабы потому что тот факт что существует такое дерево и существует дерево с этим иishops у
и с этим вот ну просто это мои любимые предъявки на экзамене там какого-нибудь вот сами понимаете
вот вот то есть мы здесь достаточно независима то есть на самом деле к алгоритме это конечно приводит
к достаточно простым вещам потому что мы делаем это то есть теперь говорится так мы делаем
и террации на каждой и террации мы во первых запускаем дфс из эра по нуля по нулевым ребрам и
все вот это сжимаем да если мы уже все обошли то мы победили а если нет то вот таким жадным
образом находим цикл а лучше раз уж все равно мы делаем за линейное время так найдем компоненты
сильной связности прямо жадно найдем компоненты сильной связности и все их сожжем но очевидно что
независимые компоненты можно сжать там аккуратненько убедиться вот значит все это сжали и после этого
ищем минимальный остов рекурсивно и после этого значит потом все это аккуратненько разжимаем вот
по этой технологии то есть это собственно классический алгоритм двух китайцев
то теперь высказывает вопрос за какой чем точку он работает
да да к сожалению лучше чем вы такой конкретно алгоритм в такой интерпретации оценить не
получается почему да просто потому что нам возможно нам на каждой итерации не ведет и
мы схлопываем только один цикл из двух вершин ну ладно может из трех получается вейт ну как бы
каждую итерацию мы конечно делаем за в плюсе в смысле за е потому что я как минимум вы минус
один вот поэтому отсюда и получается вы и вот но оказывается есть и вот но оказывается
действительно можно попытаться что-нибудь и более продвинутая спрашивается что же тут можно
сделать более продвинутого но оказывается да идея на самом деле оказывается такой да оказывается
нам то есть но то есть оказывается неожиданность такая ну а первых заметим что на каждом шаге
прям заниматься тем что за в плюсе там добиваться того что у нас серебра не отрицательные и там
и каждую векшину хоть нулевую габароном не обязательно что я для этого потому что на самом деле
каждой же мы просто можем сказать что назовем ребра там просто там назовем грибра хорошим если
она сейчас минимальное более-то в ближе и но вот правда и нам вот тогда что у нас происходит тогда
когда на самом деле может просто сказать то есть можно вот так делать а можно просто сказать что
заметим то есть можно алгоритм делать чуть-чуть по-другому
не так вот глобально по нулевым ребрам компоненты сильной связности Principal
все будет еще проще
то есть давайте возьмем первую Say specifically
просто минимальная входящие в нее ребра
не более, но теперь смотрите какая идея то есть на самом деле можно интерпретировать это так
значит потом мы значит из этой вершины значит тоже в нем находим тоже берем минимальное ребро
значит идем идем идем идем и рано или поздно произойдет одно из двух событий первое либо
мы неожиданно придем в корень и тогда это означает что все вот эти ребра можно спокойно
добавить во 100 и просто вот это вот все схлопнуть понимаете да то есть сломнуть в единую вершину и
больше не рассматривать вот ну хотя отдельная песня а что такое схлопнуть мы же не хотим
плюс все все слопать но с другой стороны да но как бы снм то у нас никто не отменял например да
как как слопать вершины можно с помощью сломать сломать ну можно с помощью но желать то конечно
какой-нибудь откатываемый сэмм делать конечно чтобы потом разжимать удобно хотя при этом в
данном случае это не обязательно потому что мы уже записали что вот эти ребра идут в ответ
ну маленький технический нюанс понятно что ребра у вас конечно меняются потому что раньше
ребра шло из пятерки в семерку теперь оно шло там из девятнадцати в двадцать три потому что
пятерки семерков такие мета вершины попали допустим да но как бы и самая простая вещь
данном случае это просто каждому ребру прицепить на прикладе идейшки мой записываем что у нас там
восток пойдут ребра там первое второе третье и двадцать мое вот ну и три последних ряда еще вот
ну как бы там ну знаете да вот вы там как олигархи вы исходно мансийска галстуки
покупают вот так же вот этот этот этот три последних ряда вот вот есть то же самое вот
значит смотрите что нас будет дальше хорошо с этими ребрами взорвались высотом мета вершину
создали берем следующую вершину да это теперь как невая поэтому значит берем следующую вершину
и делаем то же самое идем идем идем и возможно она в нашу мета вершину и пришла но ничего
при схлопнем ничего страшно вот но в какой-то момент значит тут идем идем идем идем идем
идем пришли и такое бывает вот спрашивается что в таком случае делать тогда заметим
что логично схлопнуть это все в единую вершину вот значит сломать единую вершину и пойти из
нее дальше единственное только мелкая оговорка когда вы схлопываете вершины надо научиться
искать из них минимальные ребра вот как же их искать если на каждом шаге прям то есть в данном
что ну как сказать минимальные ребра вот они тут схлопнулись то есть придется что-то
придется что-то выпить вот придется как то вот выкинуть то есть нам нужна какая то
есть оказывается нужна какаяencial структура данных который умеет по этом во первых по верше не
находить минимальные ребра в ahhmeет как-то во-первых во-вторых умеет как-то объединить
какие-то два множества и в третьем еще и какие-то ребра если я оказалась что мы 1947
еще и удалять да вот да у нас самое простое что у нас для этого есть от
сливаемой кучи вот да кто-то там конечно может написать там переливайку
какой-нибудь но переливайка не надо переливайка это лог квадрат нам лог
квадрат не нужен у нас есть сливаемая куча которые все это делают за логарифом
вот то есть оказывается действительно давайте для каждой
вершины все входящие в нейоробрах они в сливаемой куче по компаратору веса и
тогда у нас действительно на каждом шаге мы из вершины просто берем находим
должны найти просто минимальное ребро то есть просто стоим минимальное ребро
если оно ведет стужи мета вершину как мы по СНМ узнали то мы это ребро
выкидываем соответственно выкидываем и собственно повторяем нот и дальше там
соответственно идем но правда здесь конечно есть мелкая оговорка оговорка
будет заключаться в том что вам потом этот цикл придется конечно как-то раз
сжать вот такая вот то есть такая на самом деле мелкая проблема возникнет вот
значит но это собственно не особая проблема потому что когда вот ну то есть
технически это решается просто потому что то есть потому что в будущем когда
вы будете разжимать вершины у вас просто у вас уже будет дерево в которую будет
сходящее ребро поэтому вы собственно просто из этого цикла будете знать там
начиная с начиная с какого момента ребра вообще брать или что то же самое
какое из этих ребер выкинуть даже этого достаточно вот то есть тут тогда то есть
это будет конечно да не немного неприятно может быть технически
реализовывать но ничего страшного на самом деле в этом не будет так потому
что подлянка конечно будет потому что за циклов тут будет сколько угодно
будет например еще за цикл какой-нибудь да вот мы тут там скажем вот еще зациклились вот
потом мы тут пошли пошли пошли пошли еще и вообще и прям вот сюда н formed и
прям сюда неожиданно пришли вот потом бабаха еще даток вот подлянка в этом плане
да тут тут тут вообще вот так вот глобально да то есть на самом деле у
вас тут целая иерархия на самом деле появится но ничего страшного потому что
если вы потому что смотрите я вы же для каждой компоненты у вас тут компонент
очевидно не более чем 2 и минус 1 получится и для каждой компоненты вы
можете прям в явном визе виде вектор и векторов там просто выписывать а из
каких компонент вы их вообще взяли из каких компонент а самое главное из
каких ребер по идишникам правда поэтому на самом деле то есть когда вы будете
распаковывать какую-то компоненту но там просто в обратном порядке вы будете
распаковывать вы для меня будете знать какой входящий в него либо будет
собственно будет находиться и после этого собственно все эти там ребры из
цикла брать но потом уже распаковывать сами по себе компоненты вот так же вот
ну да то есть особенно если для каждой компоненты хранить в явном виде какое
ребро в нее входит, а вы это, параллельно, господи, что получается вообще, что-то на
скидку получается не сильно сложная реализация, причем более того работает она
уже за сильно более удобоваримую асимптотику E log V получается. Почему E log V?
Да, действительно, действительно. Хотя здесь, здесь начинается применять стандартный
лайфхак. Не, ну не в смысле там это зачеркнуть и переписать, конечно, да. А идея простая. На самом деле я
не только не меньше, чем V-1, но и не больше, чем V квадрат. Почему? Потому что, в принципе,
ничем не мешает, потратив внимание Z plus V времени, избавиться от кратных ребер. Да,
но напомню, да, классическая идея заключается в том, что мы ребра можем отсортировать по вершинам,
причем за линейное время. Ну, честным подсчетом отсортировать сначала там по первой вершине,
при равных первых по второму. Ну, будет просто аналог цифровой сортировки, правда? Вот. И тогда,
после того, как выход сортировки, у вас в списке все кратные ребра будут идти подряд, и вы с чистой
совесть можете оставить из них перебросы минимальным. Вот. Поэтому, то есть, на самом деле,
да, Z log V, но которая спокойно упиливается до Z log V. Вот. То есть, просто ликвидации. Ну,
просто ликвидации, да. Вот. То есть, вот получается еще один, ну, вот один такой,
тоже красивый алгоритм. Да. То есть, к сожалению, мы тут, видимо, не будем копать вообще, а они
нельзя ли еще быстрее. Ведь, наверное, можно, наверное, человечество придумало. Нет, там. Ну,
и чем он поможет? Лог В поделит. А, ну ладно, он лог В в данном случае поделит на лог лог В. И что?
Такой алгоритм, да. Хорошо. Кроме, что лог В делит на лог лог В, ну, может, ну, вот,
вот, на всякий вопрос, не могут ли тут и тут прийти фареды-гутарьяны и сказать, что надо просто
это буду делать, и будет ха-ха-ха. Ну, тут можно думать, потому что там везде можно, на самом деле,
раскапывать. Вот, что, уже нагуглили что-то. Е плюс В лог В. Нет, Е плюс В лог В это, нет, Е плюс В лог В начинаю
думать, а не пихнуть ли нам кучу фибоначи. Так, стоп. Так, хорошо. Погодите, а я действительно,
ну, правда, прям четыре умные фамилии на кучу фибоначи. Нет, ну, давайте подумать, да, давайте,
если это будет еще и куча фибоначи. Так, чем это нам поможет? Ну, на самом деле, тут проблема,
сильно нам это не поможет. Почему? Может, так, к сожалению, экстракт минов у нас будет все еще Е.
Почему? Потому что нам придется подоставить, потому что вполне вероятно, что нам придется
подоставать еще кучу ребер, на самом деле, кучу ребер, прежде чем мы найдем, действительно,
ребро, которое из этой компоненты куда-то ведет. Такая техническая проблема есть. К сожалению,
доставание из кучи фибоначи у нас, все-таки, быстрее, чем с логарифом не работает. Поэтому,
конечно, видимо, чтобы адекватно ее использовать, видимо, нам придется подумать. Да, потому что,
в конце концов, четыре автора просто так на это набросились, очевидно. Да, еще и пять. А там
еще и Тарьян пришел, да, сверху. Ну, мало ли. Нет, ну, тут, да, действительно, надо допиливать,
вообще, слушайте, хорошая идея. Нет, на самом деле, вот этих вот мелочей, на самом деле,
как вот как-то допилить, это, на самом деле, можно изучать достаточно долго. Потому что,
вот если переходить к следующей теме, да, по этой теме пока тут, есть какие-то вопросы по этой
теме. Нет. Нет, а я пришел, это лучший алгоритм. Ух ты. Ой, классно. Ну да,
погоди, погоди, погоди. Но дело в том, что когда тебе все равно из кучи придется удалять
ребро, потому что тебе ж эти списки слить придется. Нет, смотри, в каждой вершине это размер V,
отсортировать их можно, но просто, а вот в мета-вершине это уже проблема. То есть там надо
либо в этой вершине действить, там просто как бы, как бы мы не дошли до, ну, я не знаю,
насколько читикской будет использовать хэшмапчики. Нет, ну, в принципе, есть такой чит,
потому что никто нам не мешает здесь использовать какие-нибудь сливаемые хэшмапчики. Ну, сливаем,
ну, в смысле, хэшмапчики, короче. Ну, это для того, чтобы избавляться от кратных ребер. Ну,
правда, вы от них избавитесь, а потом вам все равно их придется сортировать. Это как бы вам не
поможет. Хотя, нет, хотя нет, хотя да. Нет, ну, просто да, это получится, вы будете V лог V тратить
на сортировку, делать вы это будете там где-то там 2V раз, получается V квадрат лог V. Нет, в общем,
ладно, там давайте не, ладно, есть подозрение, что вряд ли мы сейчас с вами окажемся за 5 минут,
у меня там, собственно, где-то, типа, там пяти очень умных авторов. Ну, как очень
удобно, потому что, по крайней мере, эти фамилии там фигурируют, собственно, не только здесь,
потому что, скажем, главное, вообще фигурирует еще в одном месте, которое, которое тут нам,
на самом деле, сейчас тоже может оказаться полезным. Ну, как-то сейчас, в общем-то, не очень,
потому что если говорить о динамике инвективити оффлайн. Так, а кто знает, как у нас писать
динамик инвективити оффлайн за корень? Нет, так, давайте так, об чем вообще задача? Так, ну,
задача такая, дан неориентированный крафт изначально допустит, надо отвечать на 3 типа
запроса. Первый тип запроса добавить ребро, второй удалить ребро, третий, скажи, пожалуйста,
вот эти две решения в одной компанице связаны с телевизором. Так, вот, внимание, вопрос,
кто умеет это, значит, мы будем решать это в оффлайне? Все запросы даны, надо заканчивать
удопомогимое, всем против, у нас на запросы ответить. Правовается, кто умеет решать
динамик инвективити оффлайн за корень? Ну, допустим, корни из В, или там корни из Q.
Ну, вот, нет, что так. Так, сейчас дойдем, лог-лог. Нахер смотрите. Так, мои, значит,
кто умеет? А кто умеет залог? Вот. А Копелевики умеет? Вот. А теперь будем пить им мы. Ну,
вдольный. Ну, в первую очередь, что он тут умеет, он умеет, говори, в параллельно,
добавить ребра, удалить, там, добавить ребра, удалить ребра и говорить, сколько в графе мостов.
Да ладно, сейчас мы это тоже будем уметь. Ну, там диплом просто небольшой, там 20 проничек,
в общем-то, поэтому, это грех не суметь. Да, это, да, у нас официальная отсылка на литературу такая
будет. Да, дипломная работа Сергея Копелевич. Научный, да, как это, научный руководитель А.С.
Лопатин, рецензент А.С. Танкевич и так далее. Ну, и там, и кто-то допущен к защите там завкафедры,
вот его фамилию я уже не помню. Вот, ну, можете гуглануть. Да, пожалуйста. Нет, кстати, самый простой
способ, на самом деле, найти дипломную работу, один из самых простых, это загуглить следующее.
Чего? Адамант? А что? Ну, Адамант. Ну, что? Ну, фирма такая в Питере есть, там это, а еще
керлинг-клуб там такой есть, там сборная России тренируется, ничего. Ну, вот. Ну, вот. Ну,
а еще это там, ну, а еще это ваши старшие товарищи. По имени Александр Кульков, да. Нет, просто это
очень удобно, потому что если погуглить, там появится пост на Кодфорсе от него, где там есть
какое-то описание от него, ну, у него есть просто прямая ссылка на этот диплом. Вот. Вот, тоже можно
подсчитать. Вот. Вот, конечно, тоже. То есть, честно, да, допустим, я тебе не могу сказать, что он там
идеальный, но вот, в принципе, премьер-клепяник, я думаю, поймет. Так, ну, начнем, ладно, давайте начнем,
разминку. Куко-корнейство не получится, но куко-корнейство гарантировать могу. Потому что, в принципе,
динамик конвективити у нас может решаться по запросу просто идея такая давайте разобьем
наши запросы на блоке по ну например корень нот по коренеску вот по коренеску запрос то есть
получится у нас уделить на корень низку или даже ладно давайте простоты зафиксируем как
оторвать выберем больше давайте будем обрабатывать гроза просто группками пока
но идея такая ближайшие ка запросов они будут касаться не более чем ка логично
поэтому дейта давайте временно удалим эти ка ребер из графа вообще даже если они тут
были но все остальные рёбра соответственно они либо полностью в этом блоке будут либо полностью
не будут поэтому давайте запут потратим в плюсе времени ну ладно но вот давайте там и потратим
в плюсе временно это реально в плюсе потому что связать графа никто не обещал и соответственно
сожмем этот граф в компоненты связности в каком плане потому что заметим что запросы будут
касаться не более чем заданных 2 к вершин ровно как и ребра правда поэтому в принципе можно то
есть на самом деле все остальные то есть на самом деле все остальные все остальные рёбра и вершины
более чем там 2 к интересующих нас компонент связности чин надо просто жать компоненты
связности оставить из них не более чем пока те кто нас вообще интересует после этого мы
честно проходимся по запросам если надо удалить ребра удаляем если надо добавлять добавляем если
надо проверить лежат ли вершины в одной компоненте связности запускаем dfs в чем
dfs будет работать за от как потому что к вершины карьеру в результате получается в плюсе плюс
что такое значит еще раз на хигевуха начинать запросы добавить там вот прям честные запросы
запроса запроса просто просто добавить удалить проверить проверить проверить проверить мы делим
на блоке по к вот пока запрос мы хотим обработать этот блок напоминаем мы живем
обрабатывать будем во первых заметим что все эти запросы во первых они коснуться не более чем
коробер а во вторых не более чем 2 к вершин поэтому идея такая давайте выкинем временно все
ребра которые задействованы в этих запросах а все остальные сожмем в компоненты связанности из
этих компонент связанности мы рассматриваем только те не более чем 2 к компонент которые
касаются вершин и так у нас сейчас есть два не более чем два к вершин и не более но после
этого да добавим да там после этого надо не забыть добавить те ребра которые мы здесь
удалили а зря на который на этот момент еще существует что мы после этого делать тогда
после этого мы честно проходимся по этим к запросам и честно добавляем и удаляем
ребра а если но вот но вот а если нам соответственно приходит какой-то запрос то есть приходит запрос
проверить ли две вершины лежат и в одной компоненте мы тупо запускаем dfs ну ладно я
набрал как квадрат конечно вот ну и равно это получается ку к плюс ку на вот ка плюс там в
плюс е делить на ка и на самом деле получается от ку корней из в плюс е на самом деле при ка
равно корень из в плюс е очевидно но можно решить и вот не могу сказать что это будет
но тем не менее классическая ситуация что вы написали корнем уху доказали что это не корень
лог а именно корень написали но она работает 12 секунд от 4 авторские авторы разводят руками
говорят извините у нас было решение целого квадрат который работает полторы типичная
ситуация подобного рода задачи вы конечно не знаете какой-нибудь другой технологии параллельно
но его мы тоже можем заодно обсудить так а кто когда-нибудь встречался с параллельным
бен поиском так кто свидетель я а что случилось что да с параллельным бен поиском сталкивай
все а ну тоже примерно те вот это ну да а вот какие-нибудь сливаемые так никто не
да в диване вопрос какие алгоритмы используется в элипиадах ну ничего
поэтому действительно давайте разбираться и так откуда же
а или его все знают нету вообще все
перминт 3 биц нет но это которая мастер но хотя бы базовая версия которая мастер но
делает например ну как всем ну что такое всем нужно да потому что как бы тем
но с другой стороны это касается уже всех предметов какой из них пригодится вопрос
если ей заниматься не дать им до сколько людей заниматься культурой не не но скажи так
перенадриваться тоже не надо но есть на 7 на 7 пожалуй ну тут смотря какой то есть
перия там переубиваться это физкультура конечно не надо обычно там классическая
рекомендация обычно там говорят что там ходить если будете там ходить хотя бы там день 10 тысяч
шагов то в принципе нормально тем более что в какие-то дни естественно если занимаетесь
какой-то там другой то там волейбол там играете плавание там какой-нибудь в принципе это тоже
пойдет то есть совмещать это с десятью тысячами не но это то что поделать так
в следующий раз будем изучать сермины трибис по китайским статьям литература будет вот это
китайский что тут пошли какие-то разговоры про вот эти вот вещи мы удивляемся что это
так популярно что у нас китая как-то все это уже давно давно на завтра кушают но я тут поэтому
тут составил статью шума там составил статью шумов китайная поэтому все буду ну вот и там
перечисление такому задачу как минимум 15 все стоит что-то такое ладно беремся к динамикой
connectivity offline хотя бы беремся к динамикой connectivity offline предлагается совершенно неожиданно
раз уж у нас все запросы есть а давайте-ка на этих запросах запросы выигрываем на
100 градусов я имею ввиду просто я нарисую вот так вот я больше
и нарисуем на них дерево отрезков
так вот что раз вы есть как у запросов давайте вот это дерево отрезков
такие вещи неожиданно но на самом деле в каждой вершине мы храним все ребра которые существуют
на протяжении всего соответствующего момента для каждого ребра существует так называемое время
жизни у каждого ребра есть как бы дата рождения и дата смерти а любой отрезок жизни может разбить
на логарифом отрезочков деревья вот так вот у меня выскакивает идея такая допустим у меня отрезок
живет ну я не знаю допустим вот допустим вот он появился а вот допустим вот ну допустим вот
в этом месте он там вот в этом месте комте он убился тогда я просто добавляю это ребро вот
сюда вот сюда вот сюда вот сюда и вот сюда а сюда и добавляю вот именно ребра это важно
вот именно ребра мы храним и тогда эти так а ну а первых заметим что суммарный размер тогда
сумме суммарная количество ребер во всем дереве естественно получается влога так вот так не
попались плацейку конечно у нас же тут кузов вот так вот я теперь идея такая нет у меня теперь
идея такая да потому что у нас понятие как такового ну или если вы считаете что
изначально у вас и ребер было тогда вам придется сказать где плеску на лоб если быть вот ну думаю
тоже поняли шутню значит суть предлагается такая что нам нужно значит зачем мы все это сделали
сделали вот зачем рассмотрим вот этот момент времени допустим вот это я хочу знать а какие
ребра у меня в этот момент времени вообще в графе есть ну допустим не в этот момент времени а
сразу после него какие у меня есть очевидно ровно те что находятся вот в этих вот вершинах
дерева просто это все аккуратно вот а как у нас объединить какие наши структуры данных
которые умеют хорошо объединять ребра но это самое смешное нет просто с линкатом уже
может зайти нет просто смотрите просто оказалось бы это нет просто какая тут просто идея
возникает а пока без линката может и зайти и садить просто действительно то есть по идее если
вы хоть допустим вот это ну если это запрос на добавление удаления не очень уже интересно а вот
если это запрос на лежат ли две вершины в одной компоненте тогда выскакать такая идея а давайте
давайте просто с помощью cnm добавим графу все вот эти ребра потом вот эти ребра потом вот эти
ребра потом вот эти ребра потом вот эти и после этого проверь у квадрата у квадрата
еще не квадрат это бесконечное число да да да да да да очень-очень-очень-очень-очень
очень медленно растущая но бесконечно большая поэтому поэтому хочется конечно много раз
например вот эти все ребра в граф не добавлять хотя заметим что если тут есть какие-то ребра то они
добавятся навсегда поэтому хочется научиться делать так называемый смм с адкатами
смм с адкатами что такое смм с адкатами
это такая структура данных которая хочет уметь делать find от в там юниум от уэ и cancel
просто cancel why just cancel because this operation cancels previous operation and and exactly
previous and forever
да что операция отменяет навсегда вы можете сказать что у вас сделанные операции хранятся
в стеке find и там вот эти вот юнионы даже даже не файн да именно юниор хотя и файлы можно тоже
но по факту нас интересует именно и то есть они будут они находятся как бы в стеке и cancel
делает делать следующий он берет юнион и отменяет его то есть отменяет его результат то есть и
вот тут начинается интересный вопрос за кое-чем точку мы такое можем забабах так ну вот да вот
заметим что обратная функция вот не да тот конечно кобелевич пишет важную приятную штуку на
самом деле cancel не отменяет асимптотику того что было раньше потому что все действия нет там
вот почти буквально такое написано вот там буквально до дезберева что в принципе на асимптотику
действительно cancel и не влияет почему потому что то что делалось при непосредственно юнионе можно
в явном виде просто сделать те же операции но в обратном порядке он допишет буквально а давайте
прямо просто писать каких нечейках памяти мы шоу и на шоу поменяли я вот примитивно тупо вот
вот а потом просто вот то есть возьмем и перезапишем вот то есть там буквально такое написано но
видимо но поэтому после этого хочется как-то тогда файнд юнион получается за а керману работают
ну вот к сожалению да потому что тоже сказали что мои слова выдраны из контекста как всегда
конечно же да нет амортизатор это это все работает без амортизации то честно асимптотика была
честной то конечно никаких проблем буквально так это и делается вот но но но но то есть если вы
там есть у вас там будут держать я путей которые вы будете там которые вы будете
составлять ковырять носу еще раз и еще раз и еще раз и еще ну вот ну вот соответственно у вас
будут проблемы да так ну пробовала так это чемпионат вера по кличу можно обсуждали да да хорошо
вот ну как это да это как-то бинокль с функцией повтора но вот вот то же самое
не должны быть потому что у нас амортизатор это было как бы так он вывезли исследует амортизацию
вот это уже было значит поэтому конечно просто так не получится конечно то есть если мы хотим
делать такой cnm с амкатами то нам нужен find union честный какие есть ну есть ли аживная
версия а давайте ну как бы самая большая проблема у нас что она делает амортизацию
по сути эвристика сжатия путей давайте ее отменим нет не cancel а в смысле даже начинать
зато будем использовать весовую в рейсе ну или ранговую то в данном случае уже не
принципиально тогда если делать только ранговую рейс и ко или весовой то тогда у вас
файн будет работать за логовая а юнион как сказать можно сказать логовая а можно сказать единица
если подозревать что у его это подним нет проблема в том что у нас там все операции
амортизированные то есть нам гарантируется что если вы делаете все эти операции подряд со всеми
сжатиями то будет м на сжатия а если вы каждую операцию можете отменить ну как векторе короче
то есть если векторе честно отменять пушбэк путем отмену все эмортизации которая там была то
как бы лимейности вот если делать все честно то юнион отменить вообще кстати предельно просто
даже еще проще потому что для этого нужно просто сказать что как бы так при юнионе мы назначили
тебе родителя так вот родителя больше нет в смысле не не не он то есть просто как бы ты
снова крутой квалифанта ну вот ну классическая ситуация такой вот логовая на самом деле формально
говоря тут появляется конечно опять товарищ габов уже упоминавшийся сегодня и более того
опять не один и он выявляет точнее они мы тут с товарищами посоветовались хотя это с чего
я взял хотя с чего я взял что он с кавказа и решили что на самом деле см с честной асимптотикой
может быть сделан с асимптотикой логовая делит на лог логовая это круче чем логовая
а лучше не придумали да можете гугла мы придумали скажем так такое как минимум упоминается в
дипломе капеллевича но диплом не устаревший там года 12 там 12 года может быть с тех пор
что-то поменял вот хотя там мало ли там он взрослый решал эти задачки более того мы сейчас
будем обсуждать тоже самое но с мостами и тут он сказал следующий я честно там поискал там
покинута по каким-то там журналам действительно еще и там по статьям вот с этими вот авторами
и вообще ничего на эту тему не нашел да у меня оказывается лучше это мне я придумал
что типа более крутой алгоритм хотя я нот почерно как так получилось я не понял практически
честно написал в статье это называется этот факт мне представляется удивительным
тоже отдельная песня вот даже это это тоже так в качестве локального прикола можно видимо
заботить какой-то момент хотя да вот но не важно но давайте поймем какой чем
точку нам этот логу возможность делать это за лог выдают то есть как это вообще нам помогает
помогать следующий запустим дфс поэтому берем а когда мы входим в вершину мы как бы добавляем
ребра в граф честно там сжимаем компоненты а потом когда выходим из вершины мы отменяем
все эти действия в самой вершине в самой вершине тут вам потребуется максимум там
два файнда сделать вот и но и на каждый ребро соответственно тоже сделать юнион который
тоже типа два файнда и одна отмена но получается то есть у нас получается общее число ребер в
дереве отрисков значит у нас это получается на паре то есть на алгоритм получается асимптотика
кулаку логовая ну при большом желании делить налог логовая да кто-то да кто-то уже попытался
это сделать не ну не совсем квадрат ну квадрат пока
квадрат или новое получится не а нет а вот ну согласен надо оптимизировать
так сколько у нас времени то вообще ах ну что вот ладно давайте смотреть нет давайте
теперь с вами вы внимательно подумаем давайте давайте не вот давайте немножко внимательно
подумаем а каким был вот после наша цель сейчас будет локально все-таки сократить это хотя бы
сократить это до кулок чего-нибудь не помнит а мокку получится логовая но вот до чего-нибудь
вот давайте теперь думать как бы нам действительно но то есть как бы нам действительно давайте
подобно счет чего но что было бы на самом деле эти лог квадраты поубивать но сразу подсказка
то есть вот нельзя ли было бы нам вот эти вот конечно вот вот как-то вот вот возникает вопрос
а главное за счет чего вот нет просто даже даже вот интересно как какие ассоциации вообще
могут быть у вас вообще в какую сторону теоретически вообще можно в этом лдп с и так есть пока
так вот откуда как вообще лог квадрат приводите вообще теоретики иногда превращается в лог
нет четырех не ну 4 русских там 4 русских просто все логи убирают на самом деле
не ну да одна из людей на самом деле действительно вытекает том что близких
вершины то есть вот в низких вершинах действительно хочется рассматривать поменьше вершин просто
заметим что если но это заметно что нету ни одного запроса то в нем можно опять вообще не ходить
нет нажимать даже не за счет вот чего а да но а если запросы в ней есть вот допустим там
у этой вершины 4 запроса то связано не более чем с 8 вершинами поэтому можно задуматься они
взяли на более высоких уровнях вот например вот на этом уровне попробовать свести задачу к
графу на 8 вершинах и там и канут то есть уже там каком-то адекват адекватно сжатому
графу который вас интересует только вот эти 8 вот ну потому что вот да да потому что реально
интересует 8 вершин потому что даже если тут какие-то ребра там допустим добавляется удаляется да
да потому что да запросы тут на 8 вершин максимум но с другой стороны там добавить
от нас могли попросить чуть побольше претекает вопрос действительно как же
а с другой стороны можно делать следующие вот можно
так же как Amy как тут можно действительно аккуратненько работатьPlease
давайте думать как тут можно действительно аккуратненько работать так чтобы без SM
ведь самое смешное что на самом деле а что она а зачем нам нужен и сыном то вообще
да лежа но действительно действительно там допустим лежат ли в одной компоненте или нет
но с другой стороны мы эти компоненты постоянно тут каждый векшине сжимаем сжимаем сжимаем да
а если мы эти компоненты непонятной коррупции вот тупо дфсом ну например
да казалось бы вы скажете дфс работает за не за от количества гребер а за от в плюс
количество но на самом деле заметим что сжимать компоненты я могу именно за от количества гребер
здесь но при условии что вот эти более ранние уже сжат я это могу очень легко сделать но причем
в принципе отменяема так ну а первых так смотрите первая технология я думаю сталкивается такой
ситуации когда вам нужно мотив юзер то есть дфс и при этом мотив юзер внулять за от единиц
садились когда-нибудь такой технологии ну такая чемпионе в налоге вспомним что
у нас будет интон и у нас будет мистическое значение цепь будет означать что вершина
помечена и будем говорить что если вышина цета там юзер я написано ц значено помещено если
написано что угодно другое значение помещено и тогда как все зачистить просто увеличить цены
единичку классической технологии это но этот но тут можно тоже чуть чуть усложнить можно но
первых этот юзер можно зачистить а во вторых теперь можно добавив соответственно то есть
теперь можно сказать так допустим у нас то есть идея у нас будет так а когда мы уже приходим в
эту вершину сверху мы будем считать что у нас уже есть какой-то граф на каких-то вершинах
причем список этих вершин у нас есть то есть есть у нас просто граф нам просто список вершин
первая вторая третья там 57 179 все хорошо 104 там 404 еще 218 вот и на них тут и все какие-то
поэтому я но вот мы там добавляем ребра на этих вершинах честно запускаем dfs если выясняем что
57 179 объединяется ну в какую башу они объявляются 236 очевидно вот логично вот вот соответственно
ну и так далее ну или просто если во что-то объединяется компоненты то там появляется
вершина номер следующая и мы все эти вершины теперь просто перекрашиваем в этот цвет вот ну и
вообще для каждой вершины но вот ну и там допустим для каждой вершины как-нибудь там
аккуратненько храним ее там текущие номера что что сейчас сейчас как выходить
смотрите но тут разные технологии могут быть ну во первых при такой технологии как я сказал
можно делать так смотрите для каждой вершины мы просто говорим в какой компонент она попала
логично да вот ну вот но заметим что это следующая компонента тоже там на более
следующую компоненту попасть правда ну могло такое быть но тогда получается когда мы дойдем аж
надо сюда у нас будут две вершины и у каждой получится такая цепочка высоты логарифа
поэтому можно поэтому сейчас мы требуем себе кулаку поэтому как бы мы можем тут за честную
асимптотику в общем-то за честно за честный логариф просто прогуляться и выяснить они в одной
компоненте или нет то есть все что нам нужно это просто выпускать dfs вот этот вот вот это вот
единственная только единственная проблема что для то есть единственная проблема что проблема
почему это так просто не сработает но фишка будет том что для каждого ребра в будущем вот здесь
нужно будет тем же методом проверять а каким компонентом оно вообще принадлежит поэтому не
все так просто если в ядном виде делать это для каждого здесь ребра то у лог квадрат снова
начинает нас привет вот теперь внимание вопрос как же нам выкрутить но когда же какие варианты
у вас так ну то есть вы предлагаете все но тогда что сейчас но просто уверена смотрите вершина то
у нас просто ребра у нас как бы заданы в исходных вершинах и мы же наверное не хотим трогать эти
вот ребра до того как мы тут вот пройдем и все сожраем или хоть так так у вершины нет вершины
ты мы конечно таким так а ну да действительно то есть идея получается такая то есть давайте
в каждом час погодите погодите каждый а в принципе да тоже получается что-то типа с
откатами то есть давайте будем поддерживать то есть когда то есть допустим когда мы пришли
в вершину мы уже то есть мы для каждой исходной вершины мы знаем в какой компоненте она сейчас
лежит в чем честно то есть вообразить себе можно это так на самом деле для каждой вершины можно
завести просто стэк просто стэк компонент в которых она лежит то есть когда если там
две компоненты объединились в одну то для каждой из вершин компонент мы добавляем стэк новую
компоненту а потом когда выходим типа обратно мы и стэк ее выкидываем то есть
будет
тогда мы тогда мы для каждой вершины который Заметь им, что мы в каждой вершине дерево
отрезков можем в тупую хранить какие вершины тут вообще есть и для каждой из них, и допустим
у нас будет вариант для каждой из этих вершин мы уже тупо знаем в какой компоненте она вот по
результатом предыдущих связанности лежит тогда идея такая запускаем вот
этот вот для каждой вершины часто прописываем себе и добавляем стэк в какую
новую компоненту она попала или даже осталась в старой понимаете пока да
понимаете или или умираете или даже не юз нету юз от как я уже сказал он как
бы отменяемый это как бы не проблема вот хотя в принципе можно юзет можно
делать можно юзет делать и как бы обычные просто как бы очищать не все
вершины права одного до миллиона а только те которые тут явно в виде
прописаны вот вот вот но пишка в том что во-первых мы пробежать в серебра мы
значит часто переименовали на них запустили дфс то есть на них запустили
дфс жали компоненты все это сделалось получается за от вот количество вершин
которые тут среди то есть видите как каждую вершину обрабатываемся количество
вершин после этого мы соответственно торжество пошли сюда с отменой потом
пошли сюда с отменой потом отменились из себя что значит отменились мы еще
раз пробежались по всем этим вершинам и отменили сведения о новых компонентах
то есть до там достали истеком да вот тогда получается что и после нот и тогда
заметим что мы когда приходим запрос то мы на этот запрос отвечаем вообще уже
за единицу просто за единицу из каждой вершины мы теперь
работаем за количество вот вершин которые тут в этих запросах есть
ну все вот
реализация тоже вроде как даже сильно убойный не вы
убили вот ладно логовое убили вот но кулаку у нас теперь есть вот то есть вот
получается такая как-то да как тут честно сказал каприлёвич ладно это не
первоисторический алгоритм который решает эту задачу за кулаку но как бы
утверждается что-то алгоритм там где в 92 года который был раньше он был
сложнее да тут как-то попроще там видимо все другие компоненты
но вот ну тут вот для пляжа для программирования помогает вот так что
получается что оказывается кулак за за кулаку это упихывается так ну вот ну
ладно там действительно да вот да ну ладно раз уж мы где-то рядом ходим
наверное стоит на всякий случай упомянуть про параллельный бин поезд то
параллельным бин поиском правда решается не совсем эта задача ну
классическая задача я сказал на параллельный бин поиск скорее такая немножко
другая задача вот давайте уголки предположим что у вас ребра только
добавляются вот вам заранее известно что вот добавляются ребра
ну вот так вот и у вас есть куча значит 100 тысяч ребр добавляете 100 тысяч
запроса значит запросы значит каждый запрос даны
вершины ув и вас спрашивают начинает с какого момента эти вершины лежат свои
в одной компанией связанности то есть ну понятно изначально они были не в одной
компанией связанности в конце они скорее всего там граф стал связан спрашивать
начинает с какого момента вот ну и классический метод ну просто рассказываю
на всякий случай вдруг там там кто-то не знает вот то есть да классическая
технология звучит так прогуляемся поэтому значит то есть идея такая
значит как будет но по идее для каждого так как у нас это функция
монотонная то есть сначала нет нет нет я потом да да да да да да да то
теоретически для каждого ребра мы могли запустить бин поиск вот но это было бы
долго это было бы там сколько куна ве на там и кирмана какого-то
чего ну да да еще бин поиск еще и лишний лог поэтому мы пойдем другим путем мы
скажем так вот у нас допустим где-то был вот момент времени ку пополам
успеху пополам запрос давайте приближимся прям честно заку пополам то есть за там
потратим значит ку на альфа времени чтобы узнать у каких запросов ответ не
превосходит ку пополам а у каких превосходит ну потому что она а сколько
у нас тут ребер а давай а ладно давай чтобы не путать это будет ку а вот тут
ребер будет е тогда ладно тогда значит давайте тут будет е пополам и тогда у
нас тут получается там е на обратную функцию кирмана какую-то там
е и вы вы тогда легко получите ответ на эту задачу вот пока я имею у вас будет
группа запросов у которых ответ там меньше этой границы и будет группа
запросов которых больше да размеры как-то с сопоставляет что там между
собой соотносится как угодно но теперь у меня идея такая ведь смотрите для
этих ребер по идее пин поиск должен запросить е поделить на 4 а для этих 3
е делить на 4 да но знаете что и тех и тех мы теперь
можем обработать за единые и операции я потрачу теперь еще е на обратную
функцию кирмана операции и значит тогда рассматриваю е делить на 4
и вот тут еще 3 е поделить на 4 сначала эти потом эти вот и у меня тогда тут
разобьются ребра которых ответ где-то здесь и тут ребра которые где-то здесь ну
и здесь тут есть какие-то ребра вот тут здесь а какие-то ребра вот здесь вот
получается у каждого ребра пин поиск выполняется то есть мы за от е на
folder для каждой для каждого ребра выясняем в какую сторону бин поиск ему отправить
то есть на каждый этот то есть так получится логарифом и террации то есть
на каждой террации у каждого ребра есть отрезок на который он попадает то есть
понятно что когда он попадает на какой-то отрезок значит мы берем
середину этого трезвика говорим что мы вот в этом месте то есть фактически мы
прогуливаемся опять по этим ребрам и в нужном месте просто хотим проверить так
это место это ребро в этом месте эти вершины из одной компоненты связанности или не из одной
и в зависимости от этого значит у нас отрезок двигается там сокращается наполовину либо влево
либо вправо. В результате итоговая симптутика получается О на Е, на там получается сколько там
логариф, ну во-первых на обратную функцию термана, а во-вторых на дот и в конце мы делаем это получается
ЛОГ-ЗЕ-РАС. Вот это называется параллельный бен поиск. Я так понимаю подробнее о нем
Говорить нет смысла потому что многие из вас не... Что? Где Куууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууууу
Бамана тоже жрут
Нет, нет, смотрите, должно быть лог Е почему?
Что в бинпоиске лог Е итерации
Не-не-не, да Е пополам
Е это ребра которые мы добавляли в граф
Кууу это количество вот этих паров
потому что у нас все запросы работают за керман в явном виде запросы к см м принадлежат
и две вершины одной компания связности в этот момент времени это в явном виде запросы к
керману к см м но к обратному керману да так что такая вот красивая у нас ситуация
еще какие-то вопросы тут чего алгоритм алгоритм у
алгоритма имеет куда-то где-то в параллельном поиске ну нет ну это может так кажется но
дело в том что мы не ну как-то ощущение но это да вы знаете тогда обидно да обидно это бывает когда
вы выкладывает в контексте что вы там дали кучу одинаковых задач они как бы если внимательно
посмотреть они не одинаковые просто одна на поток другая на просочетание да просто одна
на строке она на геометрию но просто так как везде сконлайн поэтому кажется что они одинаковые
ну нет не но знаете ситуация вы проводите конкурс задачи обещаете лучшие задачи взять на
контесте вам значит присылают задачи а вам все жалко выкинуть ну все хорошие нет понятный там
топ 3 вы конечно награждаете но вот ну почти тоже жалко понимаете там просто условия конкурса
если мы задачу не дали возвращаем ее автор ну мы так проводим мы так конкурс задачи проводили как-то
как-то раз вот даже на первой курсе даже китайский автор нам задачку прислал даже да хорошо было
нет хорошей задачи были нет всего я больше скажу да что третье место дали вот давно
так обнаружилось что конечно на конкурс дать никому в общем-то это да обычно да
авторам задачи скорее всего вам есть и куда предложить и так без всяких там вот эти не говоря
уже о том что да видимо пока это по каким претензия вызывается там красивые задачи конечно с
объективизм чистой вот нет там претензий вроде особо не было хотя у меня в последнее время
возникает ощущение что там мое представление хорошести там задачи конкурса сильно расходится
там сомнения в сообщество ну вот то есть я не всегда понимаю почему но вот сейчас видимо
приходит время перерыва но после перерыва нам придется подумать над более сложной задачей
значит вернуться к этому и подумать а как тут искать мосты а вот это уже можно реально
называть будет алгоритм капелевича нет хотя это тоже можно назвать алгоритм да
так задача новая теперь продвинутая задача теперь у нас задача ну можно так ну по-разному
можно но на самом деле как выяснилось удобнее даже усложнить задачу удобно мысли так даны
дайн граф у каждого ребра есть вес они тоже добавляются удаляются так вот у вас есть запросы
добавить ребро удалить ребро и найти сумму весов всех мостов можно пытаться делать ну или там
параллельно вот там можно это вот так удобно можно ее как-то поддерживать или еще ну или
принципе основной крыша запрос индустрируемый здесь такой данные две вершины лежат ли они в
одной компоненте ребриду следовательств да или нет или иногда вам может посадить то
забыл предъявить я не люблю когда я с кем-то разговариваю кто-то в телефоне сидит вот просто
девушки к сожалению совсем не понимают тем не менее вот девушки умеют делать параллельно
так интересно так нет да наверное так ладно ну как кто сталкивался
с девушками сталкивались наверное все у нас тут как минимум одна группа есть
уже не было ну было две ну так ладно ладно сложный прикол ладно хорошо ладно
беремся к постам и так задачи как же нам все-таки так же нам все-таки ту же технологию нацеливаем
примерно на ту же самую там на тоже самое кубок куб ставочку но при этом нам очень каким-то
но при этом чтобы это были махты они тут после так но теперь заметим что просто так с
нотой заметим просто так объединить конечно не получится в том плане что объединить мы конечно
можем за линейное время объединить то есть там допустим за линейное время обе найти все
компоненты реберной ду связности это для нас не проблема проблема будет заключаться в том что
конечно граф которые получат компоненты на ду связности это дерево более того не просто дерево
а большого дерева то есть сказать что оно там вот допустим будет вот на этих двух вершинах ну нельзя
пока имели на халяву нельзя в принципе да мы себе ну можем наверно там попытаться то есть
попытаться как-то это действительно по представлять ну хорошо давайте вспомним еще раз повторить как
вы добились того что у нас кубку было здесь руками помахали так ну да нет ну у нас было два момента
во первых мы ухитрялись как бы рассмотрев тут все то есть мы говорили что мы рассматриваем
те вершины действительно которые затрагиваются и при этом еще но вот затрагиваются вот когда мы
сверху пришли какие компоненты были мы рассматриваем только нужные нам вершины и с ними и вокруг
них как-то пляж ну тут заметь но тут так просто не получится потому что может получиться дерево
и ребро тут может там и каждый там дополненный ребро может там объединять целый большой цикл
давайте начнем за какую-нибудь адекватную симптомику мы можем решить вопрос давайте
вот поймем хотя бы просто ну не которые у квадрата естественно ну давайте подумаем
ну давайте так вот можно было бы вообще не заморачиваться может какими-то
сапкатами там или что-нибудь еще в этом роде могли бы мы попытаться
ну да но правда и только для того чтобы понимать кого объединять во второй снэп
вот нам нужно на самом деле еще хранить кое-что там придет хранить эти дерева этих компонент
могли бы мы хранить какой-нибудь основные дерево
ну-ка вот ну просто добыча в каждом из тех ребер которые у нас есть хранить
какой-нибудь основные дерева вот да самое туда то есть самое тупое даже если добавление
ребра привело к объединению двух компонентов значит оно у нас в дереве значит оно добавляется
ну вот нет нет более того дерево можно даже сделать подвешенным ну самое тупое как его
можно сделать это конечно линкат вот нет не совсем так нет вы с нами оно не совсем подвешенное
потому что как бы когда там добавляется ребра вы не знаете кого кого с кем вы
соединяете двух этих компонентах вы там не обязательно корень с корнем соединяете
даже корень с не корнем вот поэтому не все так просто вот тут возникает вопрос как бы нам
можно как бы нам сделать так чтобы действительно объединять именно но вот чтобы чтобы нам допустим
объединять именно чтобы нас там появлялись какие-то подвешенные деревья как бы нам такое сделать
что да ну да да нет ну как сказать нет ну что такое мы линку нет там в амортизации будет
хорошая потому что как бы мы отменить линк за логарифом можем потому что отмена линка линка
называется кат да вы умеете но правда да не хотела на первых порах можно поверить в линк
но хорошо даже если мы это но даже если мы это дерево будем хранить линкатом первой
секрет вопрос дать чем это нам будет помогать помогать там пока но пока это будет не очень то
что когда мы захотим потому что что нам потребуется в этом линкате делать да причем
самое страшное что линкат в этом месте и рискует пофейлится потому что жил был у вас линкат
вот оно и вам тут неожиданно вот этой вершине приходит ребро вот это ребро добавить что логично
сделать логично наверное найти вот этот вот путь дай бог чтобы это еще потом как предку
было они вот и все вот это вот жать мне кажется но это называется кажется что ну
вот как за вот тут кажется полномочия тут его немножко все кончились нельзя просто так взять
линкат мертв
вот линкат мертв да
можно ли как-то дерево сделать чтобы как-то было попроще вот можно ли какой-нибудь
не линкат сделать а чтобы это дерево было там какой-нибудь в явном виде там в явном виде
ну да ну и желательно чтоб вода шел какие-то деда мы желаем
нет удалять надо да нет ну как онлайне но там нет но там много чего надо уметь
ну конечно если у нас была структура данных тоже что мне делать только еще и там брать
допустим какой-то пути объединять его и тоже налоговить ну вот то кажется при это в принципе
кажется кулок квадратное лицо особенно если вы еще и судно там храните но помните мы что
там хотели типа там сумму весовка сумму каких-то нам весов мостов хранить да да
только откатывать потом не забудь откатывать присваивание тут как бы такое вот поэтому
мне тут конечно придется действительно делать какую-то аккуратность вот хотя с другой стороны
давайте подумать но хотя да мечта была бы как-то по дереву хотя вот действительно то есть
теоретически мечта была бы наоборот раз у нас оффлайн они взяли то есть может быть там просто
деревья хранить так чтобы заранее предсказывать там собственно корни будет ну просто кого там
куда подвешивать будут чтобы взять на самом деле надо еще думать а если в этом необходимость
почему а вот почему потому что но на самом деле на самом деле но вот то что когда вы
работаете с вот этими ребрами мы говорим может возникнуть такая идея что ладно если у нас
там идея на самом деле возникает такая что предположим что у вас не выглядит оно каким-то
таким вот и сильно экзотическим вот так вот и вот так вот и вот так вот
но допустим что образовалась в этой вершине поэтому вы знаете что эта вершина на самом
деле будет связана только с какими-то запросами тогда возникает такой если тоже
еще один красивый олимпиадный лайфхак где-то оно сжато вопрос как его сжать но вот мы знаем
что все запросы как то добавление удаления там проверка на двух ребер да или там найдите там
сумму какого-нибудь да а на пути потому что если она будет ну или это будет означать что
в одной компоненте утверждается надо у всех этих пар вершин взять л цашки тупо вот я буду
закрашенным цветом выбирать просто взять это то есть любую вершину который в двух различных
под деревьях есть значит там я скажу что вот они хорошие вот тогда окажется что любые то есть
то окажется что любые какие-нибудь две эти вершины соединены путем таган рок и шахта да да да
но фишка в том что если две вершины соединены путем которых нет вот никаких промежуточных
фиолетовых то фишка кажется в том что на этих промежуточных даже если на них тут висят под
деревья в этих под деревьях ничего фиолетового нет с точки зрения будущих запросов на самом деле
то есть вот это вот этот мост навсегда останется мостом он там будет там придаток висеть но его
там можно не рассматривать но более того а вот эти пути это тоже все эти мосты они будут либо
одновременно будут мостами либо одновременно не будут поэтому по факту их можно заменить на
единый мост весом равным там просто сумме старых весов это позволяет нам соответственно с
нот сжать грав вот действительно было у нас допустим допустим каких-нибудь б вот этих вот
обведенных прошу а сколько у нас тогда будет закрашен ну вот и минус одна да
вот на самом деле такая
вот а знаете почему потому что б у него
вот этих вершин там интересных но то наверно то наверно там можно добавить 2
ну да то есть ну то есть общий число вершин не более чем 4 но в общем короче линия
сейчас зор starving
идеально за идеально быстро ну идеально быстро а то есть за идеальный быстр intuitive
ну хорошо как его да но после измена и не коп nuovo colonel да вы как бы наверно
ДФС по нему какой-нибудь запускать можем, да, то есть мы можем какую-то предобработку за линью делать.
Поэтому тут появляются ноты. То есть тут появляются наши любимые Farah Colton и Bender.
За спиной которых сидят, собственно, полюбившиеся нам четыре руки.
И говорят, что в принципе можно сделать линейный подсчет и LCA искать за единицу.
Все LCA мы найдем, и после этого вот этот сжатый граф мы уже тогда...
Ну, по крайней мере, сжатый граф с точки зрения вот этих вершин мы находить можем.
Вот.
Ну вот. То есть более того, после того как мы сделали вот этот сжатень, перешли в репусю, например, вот сюда.
Теперь получается мы добавляем порядка B ребер.
И, в принципе, на этих добавивших ребра мы можем прям за то же линейное время, в явном виде,
все компоненты ребер нужно связанно с ней найти и даже это дерево пересчитать.
Могли бы, да?
Вот.
Да, Игорь, ну...
Что-что?
Ну, да. Единственное там... Что, не так?
Еще раз, сколько мы находим черные, в смысле, закрашенные перелеты?
Да, вот. Хотя самое смешное, что, по-моему, за DFS по этому дереву и находим. Даже 4 русских, по-моему, даже не надо.
Почему не надо?
Потому что нам, потому что фактически можно заметить следующее.
Вот, понятно, нам нужно LCA, потом LCA, LCA и так далее, казалось бы.
Но, на самом деле, я утверждаю следующее. Нас интересует только вершины.
Под деревьях, как минимум, двух различных, под деревьях которых есть что-то фиолетовое.
В общем, да, правда, ну вот.
То есть, на самом деле, там, на самом деле, 4 русских тут даже, по-моему, не нужны.
Хотя, нет, может, где-то и нужно, потому что, ну, капеллеры еще они где-то там были.
Я пока не понял.
Потому что, ну, вы знаете, может, мы сейчас будут еще понаблюдать.
Но смотрите внимательно.
Ну, смотрите внимательно.
То есть, как бы, то есть, люди...
Нет, DFS будет делать за количество тех вершин, которые ему передали.
Да, а то есть, эти вершины?
Да, но это же будет, по сути...
Ну, смотрите, то есть, это будет, ну вот, то есть, это будет предобработка, как бы, здесь.
Потому что что мы делаем?
Ну вот.
Ну, просто идея такая.
То есть, нам изначально, то есть, изначально дан граф.
В общем, даже не дерево обратить внимание, а вообще лес, по-хорошему, нам дан.
То есть, отмеченно, ну вот.
То есть, нам дан лес.
В янтом виде леска бывает.
Когда мы приходим в вершину, значит, нам известно, ну вот...
Когда мы приходим в вершину, то есть, нам дается лес не более, чем там получается, допустим,
не более, чем два B-вершин.
Где, ну ладно, не более, ну вот.
То есть, не более, чем где-то там 4 или 5 B-вершин, где B это количество запросов на этом отрезке.
Допустим, да?
Вот. И мы с этим деревом, ну вот.
Ну и там, понятно, про каждую вершину, тут, естественно, мы можем считать,
ну, случайно, вот этих старых технологий, там, с обновляемыми юситами и вот этими стэками всеми, да?
Что про каждое ребро мы уже знаем, кто они вот в этой терминологии, да?
И нам теперь нужно два раза вести задачу вот этой и вот этой.
Значит, сюда мы пришли, нам дано уже это дерево в терминах вот этих вершин.
Что мы делаем?
У нас есть, значит, от там 5 B...
У нас есть 5, там сколько там, 5 B-вершин, да?
И есть B, возможно, новых ребер.
Ну вот.
Ну, сколько-то вот здесь ребер.
Их, очевидно, не больше, чем B, да?
Очевидно?
Не очевидно.
Это не очевидно, потому что их не черта.
Да, потому что их не черта, а не B.
Их может быть сколько угодно.
То есть, на самом деле, да, придется...
Да, то есть, к сожалению, то есть, возможно, тут как бы в качестве помещенных ребер придется...
Ну, хотя в общем-то это и не важно.
Потому что, да, у нас есть до 6 ребер.
Но для всех этих ребер мы знаем, кто они в терминах.
Хотя нет, не знаем.
Да, неправда, мы не знаем.
Нет.
Знаем или не знаем?
Не, не знаем.
Вот, нет, пока еще не знаем.
Вот, нет, пока еще не знаем.
Скажите, кто они в терминах вот этих B, мы, к сожалению, не знаем.
Хотя очень бы нам этого хотелось.
Нет, у нас только одна маленькая фишка.
У нас вот в этой вершине есть еще какие-то ребра, которые мы еще должны добавить.
Вот.
Мы как бы знаем, кто эти ребра в терминах старых с сжатей.
Но вот.
Но как бы мы...
Но кто они в терминах вот этих вот B, этого мы еще не знаем.
Потому что нам еще только предстоит эти сжатия сделать.
То есть, как бы тут проблема такая, что не очень понятно, как сделать вот это сжатие до того, как мы добавили все ребра.
Потому что если бы нам гарантировалось, что все ребра, с которыми мы в этом подзереве будем работать, они касаются только вот этих вершин, то, конечно, был бы кайф.
То тогда, да.
Тогда мы бы, честно, были бы сжатие.
Вообще все, мы бы уже сразу победили.
Так что, видимо, где-то здесь нам начинает...
Нам нужны вот эти вот все фарохи, колтоны и прочие бендеры.
Значит, как же нам справиться с этим?
Вот реально, как же?
То есть я сначала добавить, потом сжатие?
Нет.
Но проблема в том, что мы тут добавили сжали, но потом уложили еще тут вот в этих вершинах какие-то ребра, которых вы не знаете.
Тоже видимо.
Правда?
Правда, есть вот эта маленькая кишка.
Вот эти ребра, которые тут...
Если ребро попало в эту вершину, значит оно заканчивается где-то здесь.
Если бы оно попало в эту вершину и заканчивалось позже, то оно бы не попало в эту вершину, просто потому что оно было бы лучше.
Поэтому заметим, что все эти ребра, которые тут дальше находятся, они уж к этому подотреску точно отношения имеют.
Поэтому сжатие в этой точке после добавления вот этих ребер вполне валидно.
Неужели мы обошлись без фарух колтон бендера?
Ну давайте аккуратненько, максимально аккуратно.
Какой вариант мы сраним?
То есть мы утверждаем...
Когда мы входим в вершину, мы гарантируем, что здесь у нас есть граф, который связан только...
Гарантируется, что там есть граф, который связан только с ребрами, которые имеют отношение к предыдущей вершине.
Не к той, к которой мы сейчас вошли, а именно к предыдущей.
Понятно, да?
То есть наша задача, когда мы переходим к детям рекурсивно, нам передать им граф, уже сжатый на моё подделье.
А так у меня просто вот тут есть какой-то лес вот в этих вот фермерах.
Вот.
Но этот лес у нас ещё гарантируется, что он размера не более чем 5б, но б на этот раз это всё вот это.
Понятно, да?
То есть не более чем 5, допустим 5, хотя там 4.
Ну вот, на количество запросов вот этих вот.
Смотрите, смотри, в этом граф ровно не даёт.
Просто мы пометим вот так вершину, если она запрадивается вот этим запросом вот здесь.
Там, допустим, там каким-то там добавляя.
То есть их там идёт лучше 5б.
Вот.
Поэтому те вот ребры, которые там будут добавляться здесь, как мы уже знаем, они тут на самом деле просто имеют этому отношение.
Вот.
Поэтому когда мы максимум, что может произойти, вы добавите ребро, оно соединяет два разных дерева.
Но сейчас для нас в этом ничего страшного нет.
Потому что вы добавляете, потому что у вас тут оказалось там б вершин.
Да?
То есть б, ну вот.
Ну вот.
Тут будет б.
И если у вас тут будет б интересных вершин, то как бы гарантируется, что вы сюда передали дерево размера не более чем 5б.
Это инвариант.
Теперь идея такая.
За время получается 5b плюс z с индексом v.
То есть сколько тут ребр вот этих вот было, сколько их тут живёт.
Вы, соответственно, вы добавили эти ребра в явном виде в граф.
Потому что для каждого ребра вы знаете, кто у них эти вершины в этих терминах, да?
А вы же знаете, что они имеют к ним отношение.
И вы за это время честно находите прям все компоненты рёберной досвязности, которые тут образуются.
Более того, не просто находите, а на них чуть дерево строите.
Это всё делается за линию.
Вот.
После того, как вы сделали это за линию, теперь за примерно ту же линию.
Значит, теперь вы берёте все вершины, которые тут вообще возникают в процессе.
В запросах и тут 2b, да?
Вот.
Ладно, тут уже не 2b, тут уже их b-штрих, конечно.
То есть берёте, значит, это b-штрих.
И, соответственно, делаете после этого сжатия, ну, за время получается...
Ну, сколько там получается?
За эти вот 5b вы делаете сжатие на, получается, 5b-штрих.
То есть где b-штрих?
То есть b здесь, а b-штрих типа здесь.
Вот.
То есть сжали на b-штрих, и после этого этот граф вы уже с чистой совестью передаёте сначала сюда, потом сюда.
Всё, что вам потом останется, это откатиться обратно.
Но в данном случае, на самом деле, просто можно там...
Ну да, откатиться, это значит там для каждой вершины восстановить её предыдущую компоненту, но это там старые технологии со стеком работают.
Пока, вроде.
Или нет.
Капелёв ещё где-то хочет до фара Холтон Бендера.
А мы пока, по ходу, не хотим.
Нет.
Ну выкидывай.
Нет, ну как сказать, мы в явном виде храним какие вершины нам нужны, и на этих вершинах у нас есть дерево.
Ладно, лес.
Вот.
А храним мы для каждой вершины только её компонент ураганидусвязности, в которой она лежит.
Вот.
Да, так что это да.
Для каждой компоненты, когда она новообразовалась, мы как бы записываем из каких старых она образовалась, поэтому мы там...
Сейчас.
Хотя нет, мы храним из каких старых она образовалась, и нам нужна...
Нет, погодите.
А, знаете, тут ещё фишка, видимо.
Сейчас, что у нас...
Вот опять, мы на эту фишку уже...
Для каждой конфетной вершины исходной у нас тут сказано, что эта вершина оказалась в пятой компоненте.
Тут сказано, что пятая компонента превратилась в седьмую.
Тут сказано, что седьмая перешла в двадцать третью.
Ну и так далее.
И тут вот возникает вопрос, не будет ли у нас опять...
То есть как бы это, конечно, явно выдает нам какие-то лоб квадраты, но как бы вот возникает вопрос...
Как там вообще для каждой вершины теперь...
Там хранить, в какой она компоненте лежит.
Ну, тот же, у нас есть массив снюд, который на самом деле массивстая там.
И когда какая-то вершина какого-то сюда попадает в какой-то компонент, мы просто...
А, ну да, заметим, что...
Ну да, да, да, заметим, что да.
Обновление у нас тут касается только этих вершин, поэтому обновляем мы столько и только с иби.
Да, и откатываемся только с иби.
Да, и откатываемся только с иби.
А остальные вершины даже не трогаем, такие будь себя.
Да или нет?
Так, или так что, все...
Не, ну не то чтобы...
Линия оттекла.
Не, ну что ты имеешь в виду?
нет у нас появится вот эти вот фиолетовые вот эти вот сжатые
нету мы знаем что которые фиолетовые вот не закрашены нет они вообще затронут
этими запросами не будут вот поэтому то есть по сути у нас у каждой вот то есть
получилось даже там где-то отсылка то есть вот нам как бы да самое главное
чтобы нам вот для всех понять кто они вот в этих вот сегментах на самом деле вот поэтому
вот то есть это вот это вот это для нас самое главное тут надо поэтому там надо уметь аккуратно
потому что если мы тут аккуратно то есть во первых для видимо в каждой вершине как всегда
нужно будет хранить список всех исходных вершин которые тут достигнуты и гарантировать что когда
вы приходите в эту вершину вы про каждую вершину точно знаете кто она в новой терминологии и
тогда уже эту новую терминологию и вроде так и вроде даже получается как потому что что вам
нужно чтобы выкликнуть новую терминологию вам нужна компоненты ребра на двух связанности вот
в этом графе правда значит каждую окей ну хорошо ну значит вот тогда нам уже так берем тут
компоненты ребер на двух связанных взяв нам в виде их выписываем за от 5б прям как вектор
векторов и каждую компоненту ребер на двух связанности объявляем как компонент и тогда
перебираем все вот эти вершины для каждый из них прописываем что при запуске в рекурсию дальше
они на самом деле будут еще новыми компонентами то есть вот и в стеку пикиваем потом достаем
поэтому как бы получается что но вот после этого значит тогда для списка всех вершин и здесь и
здесь мужик все знаем вот дайлса можно было находить за быстро в этом необходимости
один один общий dfs сам все сделал что вот нет вроде даже никуда вроде даже нигде не
вот такая вот ставочка так ну шо ура но как все-таки там каждый ну как все вершины мы работаем
на линии числа вершин которые тут задействованы получается и передаем так что получается
пишем статью что делаем то же самое но без фарах холтон бендера да да да да
но
как я уже сказала даман ходы портас вот это нет он там в конце же где-то сказал
там что-то упоминал давайте пошли на конкретную статью
да да вопрос как бы вопрос как бы в каком контексте на не сослался нет ну он как
нет ну ну это да правда тут возникает вопрос зачем он как бы хотел он видимо
хотел как-то в онлайне дерево сжимать что не да но тут на него сослался потому что дайлса
можно искать за единицу поэтому как бы вопрос как бы где он это применяет потому что нам это вот
тут не нужно мы с вами тоже с вами вещи пострашнее но как бы нету понятнее но то нет ну что там
хорошо посылался в принципе дфс придумал но это кто придумал что такое придумал
дфн шейте говорить стандартный рекурсивный перебор допустим какой-нибудь вообще как бы по
тому там едва ли не в девятнадцатом веке какие подобные мысли уже были мы говорим что как бы
вы говорим о тарьяне потому что по камере по камере это первая такая вразумитая именно активная
статья именно дфс значит она именно тарьяна 75 года это которую видел я то есть нет кто придумал
да да да да да да да наверное с китая да
хотя не так тот первым был нет по этой логике можно думать а кто придумал поиск ширину стать
интересно да массивы как технологию ну но я подозреваю что нет они там умею
брать нот нет ну как сказать это уже придумали наверное программисты все таки
да нет потом что такой массив массив это последовательность регистров на самом
деле выделение их вот с точки зрения нашей модели это просто вот мы сказали
шоу вот от сих до сих вот это массив да да уже надо хотя проблема тут я просто
вот главное мне просто страшно это что вот я да страшно это откладывать то про
теперь вот у нас выплыл сервен три бит а вот тоже хочется обсудить
дополнить мне ну ну кон теста да да да да типа найдите сами не но это нет
вот такой китайцы умеют доказывать что это логарифа
4 русских не причем не можно предположить что только четыре русских вообще в мире
только умеют доказывать сегменты да но тут оно в простых вещах вот там вопрос как
всегда вопрос как каким конкретно и в разных разных задачах по-разному вылезает
к сожалению да но технологии тем не менее есть ладно ладно будем думать ладно может я
конечно могу взять так себе навсегда сейчас как-то до следующего делаем сервен
три биться я прям свято клюшу больше ничего не будет но это как-то так не
хочется я просто знаете еще просто проблему что просто пока настроение
действительно это человек чувствует что к концу семестра как бы ничего нового
скорее всего скажем так дать что-то новое будет сложнее
ладно новая да правда новая это мои личные потому что новая относительно меня
никогда вот тот и прикол да поэтому ну что делать не знаю я пока не знаю я
пока не одно не рассказывал ой ну это нет ну как по себе биться не но там же
нужно копать там такие отдельности я уже наверное там не копну то есть как бы нет
вот нет ладно это бесконечно долго можно думать хотя хотя не знаю может
конечно надо просто уже отдохнуть от нового будто не наконец уже действительно
да надо но вот наверное да надо но вот но это надо бфс надо так что да что такое
фурье а не но не забыть его потом просто такая тема которую можно
обсудить уже там на последнем майском занятии действительно уже в сонном
состоянии тогда потому что это не но нет кое-что не смотреть противопроведка кое-что
там есть нет ну самое крутое что там есть из нового такой который может быть не
все знают это а 2 а бфс конечно а 2 а бфс дайся а 2 а вот ситуация такая задача
танка в эвершим сериала все веса от миллиарда до двух миллиардов найти
как чаще расстояние от стартов и решим до всех остальных утверждений это
делается за е плюс в да делается там мистически там мистически бфс
а ну да ну да сосылка на меня так вот это они есть нет эти там там единая логика
если так в качестве анонса что там может быть потому что на самом деле там
получается так на чем мы как бы даже не с бфс освал нового алгоритма
у меня терминологияיש волнового алгоритм который просто говорит вот
есть стартовая вершина эти докторов можно дойти есть те documents
которые можно дойти и как далее то есть можно там respects и
веки
у меня constitution
обыosphere бф сомняrix вОр Todos abuse
dairy а в perseбутеsom
Мы начинаем добавлять веса, потому что с одной стороны веса бывают от одного до ка, пока целые, потом бывают от нуля до единия, потом еще и с нулем.
Получается, получается делать, неправильно делать, за е плюс вк. Е плюс вк чисто из-за количества к череде, количества флоев, которые вы должны рассмотреть.
Дальше, соответственно, выплывает, что слои там может быть по-разному. Оказывается, выясняется, что из серебра от одного до ка они могут быть и дробными, и просто слои, это просто ваше расстояние, которое вы нашли, только округленное вниз.
И оказывается, это тоже прекрасно работает. Там надо аккуратно, потому что если веса от одного до ка дробные, то это работает, если веса от нуля до ка, то это фейлится.
Ну вот. Ну просто вот. Ну вот. Но с другой стороны оказывается, что если у вас рёбра от одного до ка, и при этом потом у вас два варианта, либо слои вы в явном виде храните, но как-то округляете, либо у вас третья версия.
Ну вот. А давайте просто воображать, что у нас слои какие угодно, но мы просто вместо этого храним в каком-нибудь сетике, какие слои вообще есть.
Ну там слово за слово в общем-то выводится неожиданно. То есть тут интересно именно, что я вот дэкстр увожу не просто, а алгоритм дэкстр, он делается вот так. Доказательство вот такое. Ну как вам обычно рассказывают.
На самом деле вот хочется вывести, что дэкстр это такой просто бфс на бесконечном числе слоев на самом деле. То есть абсолютно тот же бфс.
То есть смысл этой части вот ровно в этом скорее.
Ну вот. Дальше там ещё обобщение дэкстр, на какие ещё функционалы пути она может обобщиться, тоже надо обсудить.
Ну там ещё всякие мелочи типа астарт. В общем, короче, там есть что обсуждать.
Ну там про Флойда Форд Белман я молчу. Там тем более, что выясняется, что там восстанавливать путь, то на самом деле когда-то это был вопрос на отел.
Ну да, потому что если просто от балды возьмёте какую-нибудь тупую версию, то там фиг докажете.
Там будущее бронзовые призёры, там чемпионата мира, там могли 2-3 часа сидеть доказывать.
Ну вот.
Нет, там по-разному можно, просто либо жрать кучу памяти, тогда всё железо-бетонно, либо не жрать эту кучу памяти, тогда как бы удачи доказать.
Нет, можно. Я тебе правильно делаю, но это просто надо правильно делать, потому что если неправильно делать, то возникают куча непоняток и всё.
То есть это вот к тому, что он хочет рассказывать в кончайших путях.
Нет, в общем-то ничего сложного. Нет, я чисто теоретически есть мечта, чтобы в курс вошёл, конечно, этот самый лучший алгоритм, конечно, который ЗВ плюс Е это всё делает.
Да, алгоритм. Задача. Веса целая, не отрицательная, но произвольная. Ладно, бейбитная.
Так. Найдите корчайшие пути. Так вот, есть алгоритм, который делает это ЗВ плюс Е.
Ну, алгоритм. Да. Да, но это расстрел.
Ну, когда-то был, но, скажем так, насколько я понял, был только в качестве лекции, тоже скорее в виде общих намёток, а не в виде конкретного логика, поверьте.
Если мы будем конкретно это изучать прямо заново, то, как бы знаете, софт-хип действительно будет очень халявной структурой.
Вот. Так что да. Нет, ну это другой вопрос. Нет, вероятно, алгоритм у нас сейчас не в теме изучения, вероятно, алгоритм.
Да. Но там, правда, у нас нет корчайших путей. Там есть, да, там есть минус 100 за УАД Е.
Ну, да, ну он с мыслям от ожидания. Вот Е. В чём очень простой алгоритм, в чём простой релиз, в чём даже алгоритм, но вот красивый.
Ладно, всё. Ладно, да, у нас получилось всё.
