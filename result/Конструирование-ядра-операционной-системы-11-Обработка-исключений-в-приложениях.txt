Сегодня у нас будет отвитвление от наших основных лекций про ядро. Сегодня я больше буду
разговаривать про user space, а конкретно про то, как всякие аппаратные исключения, трапы и так
далее обрабатываются не в пространстве ядра, а в пространстве пользователей. План такой, в
основном я буду разговаривать сегодня про операционную систему Windows, в ней гораздо больше
для этого инструментов и я просто про нее гораздо больше знаю, но про POSIX системы мы тоже затронем.
И в конце еще поговорим про то, как можно обрабатывать, точнее не как можно, а про то,
как устроен механизм исключений в тех языках, в которых он есть. То есть, наверное, в основном
тут я буду говорить про C++, но Rust и, наверное, Go тоже во всех этих языках исключения устроены
примерно одинаковым образом внутри. Немножко о сути вопроса. Те, кто пользовались Windows,
наверное, видели вот такую картинку, такое диалоговое окно при запуске разных программ.
Что происходит в программе, когда выскакивает такая ошибка? К ней приводит код примерно
вот такого содержания, когда мы пытаемся разыменовать некорректный указатель. Здесь мы
пытаемся разыменовать указатель очень маленькой величины, то есть он в первой страничке находится,
которая, как правило, по-моему, во всех операционках современных никуда не отмаплена специально,
чтобы ловить такие ошибки. И мы пытаемся прочитать значение по некорректному указателю. У нас
происходит pageFold и программа завершается. В принципе, здесь не обязательно... Точно такая же ошибка
будет выводиться, если мы обратились по правильному указателю, но с неправильным действием. То есть,
если у нас, например, страничка только для чтения, а мы попытались сюда что-то записать,
вот будет то же самое. Также к подобным ошибкам приводится исполнение привилегированной
инструкции, например, in-out в user space или если мы попробуем таблицу гдт загрузить,
тоже это будет исполнение привилегированной инструкции. Что еще? Сюда же можно отнести
исполнение некорректной инструкции. Тоже выскакивает исключение. Соответственно,
вот это вот то, что я в данной лекции называю аппаратными исключениями, через тот же механизм
проходит. В принципе, почти все экзепшены, которые мы объявляли ранее в лабораторках,
практически все проходят наверх в user space, если операционка это сделала. Есть некоторые
исключения, которые обрабатываются особым образом, например, исключение fpu-unit и исключение
sse. То есть они, как правило, в тихую там обрабатываются ядром, просто выставляется флаг,
что произошло исключение. Если программа захотела его прочитать, она его может прочитать.
Нет, почему?
По этому адресу загружено, в окрестностях этого адреса загружен код с приложения. То есть здесь
видно, что инструкция по этому адресу, то есть да, вот пользовательские адреса в Windows начинаются
на 7f, ну точнее на 4.0 7f, и там ядерные адреса начинаются с 4f и так далее. Здесь вполне себе
адрес инструкции это валидный.
В Windows часть ядра замаплена в user space каждого приложения для того, чтобы оно могло к нему
обращаться.
Нет, конечно, там замаплена только определенная часть, которой нужно обращаться пользователям.
Ну и в принципе, даже если не замаплена, все равно все ядро работает на верхней части
адресов и приложениям туда ходить запрещено. Там так исторически устроено. То есть оно не
обязательно может быть отмаплено, но вот эти вот верхние адреса, они для приложений недоступны.
Там есть такая штука, что вот в 32-битном Windows раньше адресное пространство было поделен
пополам, два гигабайта нижних для приложений, два гигабайта верхних для ядра. Виртуальное
пространство поделено было. Потом чуть попозже, по-моему, в XP добавили специальный флаг при
загрузке, чтобы для ядра выделить только верхний один гигабайт, а для приложений три, то есть чтобы
они могли пользоваться по большим количествам памяти. Но это было вынесено во флаг, чтобы
обратную совместимость не сломать. Когда появились 64-битные Windows и там все с этим стало
чуть попроще, там адресное пространство большое, такой проблемы нет. Но поскольку там 32-битные
приложения все равно тоже работают, вот в 64-битной Windows 32-битные приложения все запускаются как
будто бы вот с этим флагом, называется slash3gb. Там, я сейчас так точно не помню, там по документации
в Квинде было записано, что какими-то битами в указателе можно пользоваться произвольно. Туда
можно свои данные записывать, потому что ядро их игнорирует. И вот эта штука, она ломалась,
если расширить. По-моему два верхних бита, что ли, или как-то так. Нет, один получается бит,
да. Если мы пополам поделили пространство, то один бит можно было использовать. Не знаю,
насколько много программ реально это использовало, но вот такое было и,
слава богу, сейчас уже это не совсем актуально. Теперь поговорим о том, как обрабатывать такие
исключения. То есть в большинстве случаев программам это не требуется. То есть вот такая ситуация,
она не должна происходить в нормальной программе, и это в принципе правильно, что операционка
просто завершает процесс. Но операционные системы вообще предоставляют механизм для того,
чтобы такие ошибки обрабатывать. Начнем с POSIX. В POSIX системах, в Linux, в Unix, во всех них есть
специальный механизм, который называется сигналы. Его можно себе представить как обработку сигналов,
в принципе можно себе представить как обработку прерываний. То есть у нас исполняется программа,
ей можно отправить сигнал. Это может сделать либо ядро операционной системы, либо другие
программы тоже могут посылать. Есть особенные сигналы, которые другие программы посылать не
могут. В большинстве программ ничего дополнительно делать не нужно. На каждый сигнал есть свой
обработчик по умолчанию, который в операционной системе в runtime крутится и исполняет эти сигналы.
Но у программиста есть возможность обработку, этот обработчик переопределить. Для этого есть
функция POSIX API SigAction. С помощью нее мы можем переопределить или задать обработку разных сигналов.
В данном примере мы переопределяем обработку сигнала SigSig. Это тот сигнал, который по умолчанию,
если ядро присылает его приложению, то приложение пишет в консоль SegmentationFault и завершается. Я
где-то читал, что SegmentationFault это так называлась аппаратная ошибка на какой-то из родных
платформ, на которых Unix разрабатывался. Сейчас слово Segmentation не имеет никакого отношения к тому,
что за ошибка произошла. Так можно понять, что прилетел сигнал SigSig. Он может прилететь и если
неправильное обращение к памяти, и если General Protection произошел, и там еще какие-то есть.
Наверное все сейчас не назову. Еще раз?
SigSig не уверен, что можно. Можно попробовать. У нас есть индивидуальное задание сделать в
обработку сигналов. Это как такой канал IPC. Ядро знает, где у приложения находятся обработчики
сигналов, и это все дело проходит через него. Мы отправляем сигнал, говорим, что его нужно отправить
вот такому-то процессу. Оно проходит через сискол, и он уже там его отправляет дальше.
Ну, значит, а мне некорректный в каком смысле?
Я думаю, что там есть какие-то проверки по этому поводу. Я
по поводу POSIX подробно не могу сказать. Наверняка на это есть куча статей. Я в основном про Windows.
Что будет происходить здесь в процессе выполнения вот этого небольшого куска кода? Мы зарегистрировали
обработчик сигналов. Дальше мы попробовали сделать некорректное обращение к памяти.
На моменте, где мы вызываем функцию printf, исполнение программы прерывется,
мы попадем в обработчик сигналов. Дальше мы можем что-то с этой ошибкой сделать, можем ничего не делать.
В принципе, здесь не так много вещей, что мы можем с программой сделать, потому что, ну, даже если мы
вернемся из обработчика сигналов так, чтобы программа не завершалась, все равно мы попадем
обратно в то же самое место, и нам нужно будет как-то либо исправить этот указатель,
либо пропустить инструкцию, которая к нему обращается. Это весьма нетривиально, и я бы сказал,
что делать так плохо. Хотя для этого есть механизмы, о которых ближе к концу я расскажу.
Теперь Windows. Здесь разработчики Windows пошли чуть дальше и сделали такой более общий
механизм для обработки исключений. Он называется structured exception handling и позволяет с помощью вот
такой вот конструкции, очень похожей на исключения в C++ сделать обработку, в том числе и аппаратных
исключений. То есть что здесь происходит? Мы оборачиваем наш код, в котором, возможно, будет ошибка
в блок try и делаем, и вот здесь вот будет записано обработчик этого исключения. Как будет происходить
исполнение в данном случае? Мы входим в блок try, происходит исполнение, после этого мы попадаем в
функцию filter. Задача этой функции, зная информацию об исключении, здесь во входные параметры будет
подан код ошибки, всякие там разные данные, то есть если это access violation, то там будет сказано,
там какой был адрес, какой тип доступа, там read-write-execute и так далее. Если это general
protection, то там будут тоже какие-то подробности связаны с тем, где это произошло. Задача функции
filter просто сказать, хотим мы обработать это исключение или нет. Дальше, если мы сказали,
что хотим, мы попадаем в вот этот обработчик и программа продолжает работать дальше,
ну то есть мы в блок try уже обратно не возвращаемся. Здесь пока понятно?
Да, сейчас я про это скажу. Ну это тот же самый механизм. Ну да, тут по-разному, то есть в
Microsoft Compiler это пишется вот так, для пользовательских приложений и для драйверов,
по крайней мере в Microsoft Compiler текущем, возможно раньше там были. Да, как в плюсах, можно еще
finally поставить. В блок finally мы как бы вернемся в любом случае. Эти блоки можно еще вкладывать друг
друга. Теперь, как это все работает. В Windows есть две реализации механизма всех, они используются
на разных платформах. Почему так произошло никто не знает, я не сумел найти в интернете. Я сначала
думал, что первый механизм был просто придуман раньше, а потом был придуман второй, но судя по
всему нет. Оба были придуманы в 91 году. Почему на x86 стали использовать один механизм, а на всех
остальных платформах стали использовать другой, не знает даже человек, который в Microsoft
Блоге об этом написал. Ну, по крайней мере он так говорит, что он не знает. Да, вот первый
механизм, который из таких актуальных, точнее нет. Единственная платформа, на которую используется
первый механизм, это 32-бит на x86. Это называется stack-based всех, то есть structured exception
handling с использованием стека. И второй механизм называется table-based всех. Он используется на
всех остальных платформах, там на 64-битном x86, на обоих армах и на всех исторических архитектурах
других он тоже использовался. На мипсе, на PowerPC и на альфе. Я сейчас все это объясню.
Ну, если именно про сигналы, то в POSIX они используются не только для обработки
аппаратных исключений, но и для реализации, например, общения между программами. Например,
можно, например, там есть как минимум два сигнала, это user1 и user2, на которых можно
забиндить любые пользовательские действия. То есть удобно из одной программы, бывает,
отправить сигнал в другую, для того чтобы что-то ей сообщить таким образом.
А если речь идет именно об ошибках, то, ну как минимум, да, хорошо бы вывалиться в
отладчик, например, в этот момент или хотя бы stack trace записать, то есть, но в Windows через
этот механизм работают, я знаю точно, что некоторые программы пытаются как-то поправить
исполнение программы, если вот что-то подобное возникает и не завершаются. Например, пытаются
перезагрузить процесс, в котором это произошло. Ну да, то есть, в принципе,
использования можно достаточно много всяких разных придумать, но в основном это обработка
ошибок. Ну то есть, как правильно сказать, лагирование, да, для того чтобы потом было проще это все отлаживать.
Так, два механизма есть, две реализации есть у всех. Сейчас говорим про ту, которая работает на
stack, которая уже как бы legacy считается, но она все равно актуальна, потому что Windows это единственная,
по-моему, оставшаяся операционка, в которой 32-битные приложения все еще активно используются,
несмотря на то, что на 64 бита уже давно все перешли, и он там актуален, этот механизм.
Да, потому что если поменять этот механизм, придется пересобирать
все программы, и тогда теряется, собственно, идея обратной совместимости, можно что-то сразу на 64 бита пересобрать.
Что происходит, когда мы исполняем программу, в которой есть вот этот блок try? Когда мы входим в него,
компилятор кладет на stack специальную структуру, которая называется Exception Registration Record.
Как он находит то место, куда ему нужно ее положить? Эти структуры должны
формировать с собой список, и указатель на первую такую структуру хранится в структуре связанной
с потоком, она называется thread environment block или tab. Там много есть всякой полезной информации,
например, туда складывается контекст при переключении контекстов, и вот в том числе
складываются указатели на Exception Registration Record. Что находится в этой структуре? Там находится
указатель на следующую такую структуру, и там находится указатель на специальную функцию,
которая называется Exact Handler. Что она делает, я скажу чуть попозже.
Так, вот мы вошли в блок try, положили на stack эту структуру, дальше начинаем исполнять код,
и когда мы доходим до обращения к неправильному указателю, у нас, естественно, сначала
происходит PageFold в ядре. Ядро видит, что PageFold пришел из user space. Это значит,
что нужно включать вот этот вот обработку, механизм обработки исключений. Он заходит вот
в tab, начинает по порядку перебирать весь этот список, и как он устроен, то есть вложенные
внутри себя блоки try, они будут в начало списка добавляться. То есть первым обработка
придет в самый вложенный обработчик исключений. Что происходит при переборе? Ядро вызывает
функцию Exact Handler. У нее в параметрах, ей передается достаточно много параметров,
но там самое главное, это ExceptionRecord, в котором есть ExceptionCode, и еще всякая разная другая
информация об исключении. Я там сейчас не буду вдаваться в подробности. Дальше в эту функцию
еще попадает информация о том, в каком месте произошло, в каком фрейме произошло это исключение.
Контекст, ну то есть контекст как при переключении процессов, то есть там все регистры находятся.
И этот Exception Handler, он внутри должен вызвать функцию Filter, чтобы понять, обрабатываем мы
исключение здесь или нет. Если мы не обрабатываем здесь исключение, то мы дальше перебираем по
списку вот эти вот ExceptionRecord, до тех пор пока не дойдем до того, который все-таки это исключение
обработает. Если мы дошли до последнего элемента, в котором все F записаны, то это
дефолтный обработчик исключений, и ядро само там обработает его, то есть оно вот выведет то окошечко,
которое на третьем слайде я показывал, и завершит программу. Ну естественно, что когда мы
вошли в блок try, нам нужно положить структуру на стэка, когда мы из него вышли, нам нужно эту
структуру со стэка снять. И в этом и заключается, на самом деле, главный недостаток этого механизма в
том, что мы на стэк кладем вот эту структуру, в которой есть ссылка на функцию. И поскольку
стэк у нас доступен для записи, то у нас появляется точка, в которой мы можем перезаписать вот эту
функцию на что-то, что нам надо, и потом вызвать исключение, которое в принципе не так сложно
вызвать. Там достаточно просто некорректную инструкцию исполнить, и вот, пожалуйста, даже не
нужно там никаким адресам обращаться, ничего. Этим пользуются злоумышленники и писатели всякого
вредоносного ПО. Этот механизм пытались патчить неоднократно, но принципиально вот эту вот
проблему с тем, что стэк доступен для записи, без ломания обратной совместимости, исправить не
получается. Это вот первый недостаток, связанный с безопасностью, и второй недостаток он связан с
тем, что нужна поддержка в компиляторе. То есть здесь вот внутри под этим словом try находится
код, который кладет эту структуру на стэк, потом ее нужно снять со стэка. В принципе в проекте ReactOS
у нас получилось на Define захачить эту логику, но там мне удалось побороть одну проблему. Это что
вот здесь должен быть компиляторный барьер. Да, чтобы компилятор случайно не перемешал,
ну чтобы он не вывел инструкцию за блок try. Там все равно есть с этим проблемы, то есть мы можем
побороть перепорядочивание того, что внутри try с инструкциями внутри блока try, но, например,
если мы обращаемся к каким-то внешним переменным, то там возникают проблемы, они могут быть
соптимизированы. Там нормально, эту штуку на Define сделать не получилось. В кланге есть pull
request на поддержку вот этого механизма. Там он поддерживается в принципе всех. Ну барьеры понятно там есть,
но он пока висит, непонятно что с ним там будет. Требуется поддержка от компилятора, долгое время
это все поддерживало стоковым свц. В гцц, где-то в версии 4.8, если я не ошибаюсь, появилась поддержка
try-except механизма для 64 битных приложений. И в кланге есть и то и то, но там тоже называется это,
что нет поддержки асинхронного всех. По сути это значит, что может произойти перепорядочивание.
Они это сделали как-то средствами компилятора, я так досконально не смотрел. Мы проверяли,
оно в больших частах случаев работает, но иногда возникает какие-то вещи, и мы смотрим
ассемблерный код. Видно, что либо там какой-то барьер не поставлен, либо они переупорядочили
инструкции куда-то не туда. Я думал как-нибудь заняться, разобраться в чем там дело. Может быть
попробовать написать в рассылку, чтобы они там как-то побыстрее принимали этот патч в кланг,
но пока до этого не дошел. Еще один недостаток данного механизма это в том,
что у нас есть определенный оверхед даже если исключения не произошло. То есть нам в любом
случае нужно выполнить код для того, чтобы положить структуру на стэк и для того,
чтобы ее снять, даже если исключения не было. Это в зависимости от того, как Krontime сделал.
Это структура связанная с потоком. TreadEnvironmentBlack. Она в ядре хранится,
то есть у нас все потоки, ну она хранится в ядре и она отмаплена в сам поток. Ну в принципе да,
то есть например еще в этой структуре хранится ссылка на область TreadLocalStorage,
то есть данных локальных ток для данного потока. Во втором механизме попытались исправить
большинство проблем, которых есть в первом и все-таки из-за этого мне кажется, что скорее всего
он был сделан позже, просто нам никто не признается. В table-based exception handling больше
не используются операции со стэком и вместо этого информация о том, о вот этих блоках try и accept
хранится в специальной секции исполняемого файла. То есть вы наверное знаете, что в Windows
используются PE файлы вместо ELF формата и там есть специальная секция, в которой хранится
информация о блоках исключений. Я здесь привел пример. Основная там структура называется
runtime function. Честно говоря, мне не до конца понятно, почему она называется именно так. Там
находится адрес начала блока try, конец этого блока и структура unwindata, я ее не стал здесь
на слайде приводить, она достаточно большая. Там по сути находится вся информация, которая нужна
вот это вот. То есть там находится ссылка на вот эту функцию accept handler, там находится ссылка на
блок finally, если он есть. Там еще есть некоторая информация, которая требуется для обработки
исключений и она генерируется компилятором, точнее даже не компилятором, а линковщиком скорее,
в процессе генерируемого исполняемого файла. И такой способ избавляет от двух проблем. То есть
в первую очередь у нас здесь нет overhead, когда исключения не произошло и все проблемы с
безопасностью, которые были со стеком, они здесь тоже уходят, потому что эта секция pdata, она
маппится всегда как read-only. То есть когда мы уже загрузили программу, то поменять его нельзя.
Как происходит исполнение в случае table-based всех? То есть когда мы входим в блок try, ничего компилятор
не делает, то есть вся информация уже записана. Блок accept, он хоть и пишется здесь формально,
по факту он находится там где-то в другом месте в программе. Что происходит, когда происходит
исключение? Гидро начинает проходить по вот этой вот таблице, которая в pdata находится,
находит по очереди все обработчики исключений и точно также их вызывает. Здесь наверное вот
один есть минус по сравнению с способом со стеком. Все-таки для того, чтобы перебрать табличку,
нужно чуть больше ресурсов, чем для того чтобы пройтись по списку, но разница там не такая
большая и она нивелируется гораздо лучше безопасностью. Еще я хотел сказать такую вещь,
что хотя этот механизм всех в Windows используется не только в user space, но и в kernel space тоже.
Несмотря на то, что это такой момент не особо распространенный, как правило исключения всегда
запрещены в ядре, но вот в Windows решили пойти другим путем. Там с помощью этого механизма
проверяют в первую очередь валидность указателей, которые пришли из user space. То есть когда нам
нужно использовать, когда мы в syscall хотим использовать указатель из user space, мы его никак
не проверяем, а просто код который его использует оборачивается вот в этот блок try и вот таким
образом обработка исключений происходит, я бы сказал, более красиво что ли с точки зрения программиста.
Для этого он там и есть, то есть если мы оборачиваем, если там как происходит,
мы оборачиваем этот указатель в блок try, доступ к нему, и дальше делаем все как обычно. И тогда,
если у нас это исключение где-то там в обработке page fault возникло, то мы его в exept и обработаем.
Нам прислали плохой указатель. Все, возвращаемся с syscall, что вы нам что-то не то прислали. Если бы
такого механизма не было, нам бы пришлось иметь отдельную функцию, которую можно вызвать перед
этим. По сути мы бы как бы два раза вызывали бы проверку. Одну руками, а вторая бы вызвалась
в обработке page fault. В Windows вот сделали таким образом. Еще один есть механизм в Windows для
обработки исключений. В какой-то момент, перед разработкой Windows XP очевидно, в Microsoft решили,
что механизм всех он недостаточно гибкий, он не позволяет делать некоторые вещи. Например,
если у нас в программе есть супер крутой, супер умный обработчик исключений, он там умеет
из любой ситуации выходить, но какой-то из библиотек... и этим обработчиком обернута вся
программа. Вся программа засунута в блок try. Нет, нужно в мейне можно его написать, чтобы весь
остальной код вызывался оттуда. Представим, что у нас есть один большой обработчик, который умеет
все. И где-то там в библиотеке, которую мы используем, тоже есть обработчик всех, но программист
поленился и решил, что если есть ошибка, мы просто завершаемся. И тогда, поскольку обработчик,
который находится в библиотеке, он вложен относительно нашего общего, до него исполнение
просто не дойдет. Секил его нельзя переопределить.
В сектерме так можно, потому что для этого как раз и нужен секил, потому что если мы вызвали сектерм,
программа все не завершается. Значит, она там либо зависла, либо решила, что нужно пропустить
этот сигнал. И тогда есть секил, который уже нельзя переопределить, и там, безусловно,
приложение будет завершаться. Я сейчас расскажу про еще один механизм, который,
которым можно выйти из обработчика сигналов куда-то еще. Так, начиная с Windows XP, в Microsoft
придумали такую вещь, как Vector Exception Handling. Это как раз больше похоже на сигналы в POSIX.
Как это устроено? Этот механизм обрабатывает все исключения, которые происходят в процессе.
То есть сначала они попадают в этот обработчик, а потом всех, или наоборот. Я точно не помню.
Да, иначе бы смысла в этом не было. Сначала обработка исключений попадает вот в этот механизм,
а потом уже всех. Как он работает? Здесь уже не нужна никакая поддержка со стороны компилятора,
просто если мы хотим повесить обработчик такого исключения, мы вызываем функцию Add Vector
Exception Handler и говорим, что вот это исключение мы хотим обрабатывать. Там есть Call First и,
по-моему, типа Default или что-то такое, который его добавит в конец. Да, можно сколько угодно добавить.
Там то значение, которое возвращает эта функция, там по нему можно будет потом удалить именно тот обработчик,
который нужен. Да, то есть можно добавить сколько угодно обработчиков одного и того же исключения,
например, если мы хотим в библиотеке его обработать и в нашей программе, то можно добавить их два. Они
будут вызываться по очереди. Собственно отсюда и название Vector Exception Handling, потому что вот они,
как бы, мы там проходимся по вектору и вызываем все зарегистрированные обработчики. Ну вот такой
механизм, потому что там список может быть и пустой, и не пустой.
Тогда получится, что мы можем два раза вызвать обработчик. Один раз мы его вызовем, а второй раз
мы его вызовем. Если хочется, чтобы после этого обработчика в случае неудачи вызвался еще вот такой
и вот такой, например, то эти два обработчика можно вызвать не подвязывать, а вызвать вручную в конце.
А Vector, чтобы можно было не делать ничего вручного, никаких предложений о том, что дальше будет?
Да, можно повесить обработчик на все функции. В смысле на все экзепшн и один,
который будет там уже дальше сам разруливать. Вроде здесь все. В общем, если зарегистрированы
вот эти векторные обработчики, то сначала вызываются они, а потом в дело вступает механизм всех.
Теперь немножко про программные исключения. В Windows механизм всех можно использовать и
могут использовать и сами программы. Есть функция RaiseException, которая работает таким образом,
что мы попадаем в блок экзепт. В POSIX сигналы могут отправлять другие программы, причем можно как
самому себе сигнал отправить, так и из другой программы и даже пользователю доступнуть,
для того чтобы их отправлять. Также языки, в которых есть встроенная поддержка исключений,
могут использовать механизм. Ну, механизм сигналов, наверное, нет, а вот механизм всех используется для
того, чтобы в рентах библиотеки реализовать поддержку исключений. То есть, например,
в Microsoft библиотеке внутри в качестве бэкэнда для плюсовых исключений используется всех. Тут даже
есть одна такая дополнительная возможность, это позволяет в плюсовых обработчиках обрабатывать
аппаратные исключения тоже. Ну да, либо по двайнам. В линуксе у KCC по крайней мере
runtime используется так называемый frame-based exception handling. Это механизм,
очень похожий на table-based всех. То есть, там тоже есть специальная область в эльфнике,
в котором записаны блоки try и обработчики исключений для них. И когда происходит исключение runtime,
он туда лезет, смотрит, где находится обработчик и туда передает управление. Да,
тут там система не участвует. В принципе, KCC же не поддерживает всех на Windows. На Windows
он там тот же самый механизм используется, как в Linux. Да, exception нельзя другому процессу послать.
Да, для взаимодействия между приложениями и процессами в Windows можно либо общую память
использовать, либо оконные сообщения. Но это тоже целый механизм в Windows. Оконные сообщения из
Windows. То есть, там любой процесс, даже если у него нет окна, оно не показывается, может создать
объект окно, который будет принимать эти сообщения. В mPaint, если окна непосредственно нет,
посылать смысла нет, он просто пропустится. Да, там есть зарезервированные значения для
пользователей, для программистов, которые можно использовать как хочешь. И еще один есть
механизм для обработки исключений. Обычно его реализуют runtime библиотеки, когда ничего другого
реализовать нельзя. Это использование функций setJump и longJump из C. Эти две функции позволяют
сделать глобальный go-to. Когда мы сначала вызываем setJump, он сохраняет определенный контекст,
и потом мы этот контекст можем передать в longJump из любого другого места программы, и мы
переместимся туда, где мы вызвали setJump. И вот тут как раз вот этот, точнее не конкретно этот,
а подобный этому механизм можно использовать для того, чтобы из сигналов по сексовых перемещаться
в какую-то другую область программы. Только для этого там есть специальные функции, они называются setSigJump
и SigLongJump или longSigJump, не помню точно. В общем специальные версии этих функций для сигналов,
потому что в по сексе по стандарту небезопасно вызывать setJump и longJump из обработчик сигналов.
У меня сегодня все.
