Я думаю, можно начинать. Сейчас мы немножко опять вернемся к сетям. Во-первых, у вас остается до конца
модуля две лекции, сегодня и через неделю. Соответственно, через две недели что будет?
Контрольная. При этом на семинарах у вас у кого-то осталась одна тема, у кого-то две темы.
И тема это низкоуровневое сетевое программирование. Напомню, что у нас есть стэк протоколов под названием
TCP-IP. Что этот стэк протоколов подразумевает? Что у вас есть некоторые пакеты, которые называются
IP-пакетами. Они гуляют между разными хостами в сети, возможно, довольно сложными маршрутами. И по
протоколу IP можно передавать самые разные данные. Например, внутрь протокол IP можно запихать
сегменты TCP, которые подразумевают установку двустороннего соединения. И с точки зрения
прикладного программирования у вас socket TCP-IP будет выглядеть точно так же, как двунаправленный
канал с обычной установки соединений. Делается не бесплатно, естественно. Элементарно,
handshake по протоколу TCP занимает несколько обменов. К сожалению, на проекторе не очень видно,
потому что проектор не очень хороший. Что вообще подразумевается при взаимодействии по протоколу
TCP? У вас все сегменты TCP имеют некоторый порядковый номер. Этот порядковый номер присваивается
ядром операционной системы, и вообще говоря, он имеет сквозную номерацию. То есть у вас может
быть запущено несколько процессов, каждый из процессов подключается к своему серверу. И ядро
просто делает достаточно большие номера этих пакетов. И если вы запустите, например, утилиту
Wireshark, то Wireshark уже демонстрирует вам номера пакетов, пересчитанные относительно начала
взаимодействия. В чем заключаются задачи ядра при взаимодействии по протоколу TCP? Поскольку у вас
по сети ходят IP пакеты самыми разными маршрутами, они могут доходить вовсе даже непоследовательно.
Уже задача ядра, прежде чем выдать конкретному процессу, который использует взаимодействие по
сокетам, выстраивание всех нужных пакетов с данными в правильном порядке. Если какие-то
пакеты не дошли, то выполняется запрос к противоположной стороне с просьбой отправить повторно.
И ядро вообще делает полное экранирование прикладного интерфейса уровня прочитать,
записать от какой-то там магии, которая лежит с точки зрения сетевых протоколов. И этим удобен как
раз протокол TCP, который является видом сокетов для потоков взаимодействия. На самом деле для
потоков взаимодействия существует не только протокол TCP, когда давно существовала такая
операционная система под названием NovelNetware, очень популярная для серверного применения,
в частности шаринг файлов, принтеров. И там использовался вовсе не стэк TCPIP, а очень
похожий стэк протокол IPX и SPX. Это один из примеров того, что протокол TCP вовсе не является
единственным стриминговым протоколом. Кроме того, для поточного взаимодействия вы можете
использовать не только сетевые соединения через сокеты с номерами портов и IP-адресом,
но и обычные UNIX-взаимодействия, когда используется адресация по локальным именам файлов.
И вот при создании сокета нужно явным образом как-то указать, какой протокол будет использован.
Если вы указываете цифру 0 в качестве последнего параметра, то ядро автоматически выбирает
семейство протоколов, которые будет использовано. Если у вас взаимодействие идет по сети интернет,
то с очень большой вероятностью будет выбран именно протокол TCP, если укажете SOCKS3. На самом деле
если указать цифру 6, то результат будет тот же самый, потому что цифра 6 явным образом фигурирует
в каждом IP-пакете. Это просто номер протокола TCP для того, чтобы противоположная сторона могла
разобраться, что дальше делать при распаковке этого IP-пакета. Кроме потоковой передачи данных,
бывают еще и другие виды взаимодействия и соответственно типы сокетов. То есть потоковая
передача предназначена для двунаправленной последовательной передачи данных. Кроме того,
существует еще и достаточно популярен способ передачи данных только в одну сторону в виде
коротких сообщений, которые называются датограммы. Для этого обычно используется протокол UDP. И можно
взаимодействовать с сокетами на низком уровне, то есть читать данные и передавать данные,
вручную разбираться уже с теми заголовками бинарными, которые в этих данных присутствуют,
ну и возможно даже сделать какой-нибудь свой протокол вместо протокола TCP, вместо протокола
UDP и даже вместо протокола IP, если вдруг вам этого захочется. Итак, начнем сверху-низ.
Протокол UDP. Заголовок протокола UDP, в отличие от TCP, очень простой. Там всего лишь 8 байтиков,
2 байта под номер порта отправителя, номер порта получателя. То есть точно так же, как в протоколе
TCP, у нас есть некоторое пространство имел под названием номера портов, которые связывают с
определенными службами, и длина сообщения плюс контрольная сумма. Все, вот очень простой заголовок,
в отличие от протокола TCP, где есть еще номера пакетов, куча флагов, и какой размер сообщения
вы можете передать. Здесь у вас все ограничивается размером payload, который вы можете запихать в конечном
итоге. В IP пакет, размер IP пакета сверху у нас еще ограничен размером Ethernet кадра. Есть параметр
при установке настройки сети, называется message transfer unit. Обычно в большинстве случаев это 1500 байтов
для Linux Mac OS, либо 1492 байта под Windows. И вот это максимальный размер, который вы можете передавать
внутри одного кадра Ethernet. У нас есть несколько байтов на заголовок IP, это 20 байтов. 8 байтов
еще занимает сам заголовок UDP. Ну и вот несложно рассчитать, какой максимальный размер сообщений,
которые вы можете отправить с помощью одной датаграммы. И датаграммы, это просто короткие
сообщения. Вы их отправляете в произвольном порядке, опять же, они могут доходить разными
маршрутами, и никто не гарантирует порядок, к которому не дойдут до получателя, и дойдут ли вообще.
Вы это проконтролировать никак не сможете. Но на самом деле интернет у нас плюс-минус более-менее
работоспособен, если не говорить про Fistech, если не говорить про общую ситуацию в стране. Но можно
считать, что вероятность того, что у вас ничего не будет доходить, достаточно низкая, значит у вас
просто все перестанет работать. И можно считать, что протокол UDP достаточно надежен, с точностью до
того, что вы не знаете, в каком порядке вам пакеты могут доходить. И зачем вообще он нужен? Какие есть
преимущества? Почему бы просто не использовать обычный протокол TCP, который гарантирует нам все,
что только можно гарантировать? С точки зрения программного интерфейса очень удобен, поскольку
это обычное двустороннее взаимодействие. Вся суть протокола UDP в том, что имеет заведомо более
низкий overhead. В частности, вам нужно отправить три сегмента только для установки TCP-соединения,
по UDP это не требуется. TCP-соединения точно также нужно еще и закрывать аккуратным образом. Для UDP,
в принципе, это не предусмотрено, потому что никакого постоянного соединения у вас нет. У вас есть
просто перекидывание данных в одну сторону, сервер может вам, если захочет, отправить в обратную
сторону тоже какие-то данные. И здесь, если вам важен порядок пакетов, хорошо договоритесь уже на
более высоком уровне, что делать с теми пакетами, которые вам в какой-то момент времени прилетели.
Какие обычные сценарии использования протокола UDP? Когда-то он был очень популярен в то время,
когда были распространены торренты, учитывая последние политические соображения, когда внезапно
вдруг разрешили... пиратить, конечно, это очень плохо, но рутрекер разблокировали, торренты,
видимо, скоро опять вернутся. Вот там протокол UDP использовался очень активно, поскольку передача
данных производилась в первую очередь только в одну сторону к получателю торрента. Протокол UDP,
кстати, тоже один из недостатков. Если у вас трафик направлен преимуществом в одну сторону,
например, вы выкачиваете большие объемы данных, то в обратную сторону все равно приходится гонять
большое количество IP пакетов просто для того, чтобы подтверждать получение каждого TCP сегмента.
То есть протокол TCP удобен, когда у вас более-менее сбалансирован объем данных,
который передается в разные стороны, но если у вас преимущественно идет скачивание в одну сторону,
то он уже становится неэффективным. Из современных применений протокола UDP это
видеостриминг, Zoom, Google Meets, все остальное, Jitsi Meet, например,
open-source решение аналогичное. И еще одно очень очевидное применение, где использование протокола
UDP заведомо более выгодное, чем TCP, это множество протоколов под общим названием VPN. Что такое VPN,
я думаю, рассказать не нужно. Вы и так уже, наверное, все знаете, хотя делать вид, что не знаете.
Почему VPN более выгодно использовать именно через UDP, а не TCP? Потому что все равно у вас VPN это
некоторые туннели, виртуальная какая-то сетевая карта, у которой есть свой IP-адрес,
своя маршрутизация, и фактически вам нужно эмулировать передачу езернет-кадров вместо
езернет-проводов, вместо Wi-Fi, просто вы все это запихиваете в некоторый туннель программный.
И здесь вам не нужно делать никакую проверку целостности, что данные доходят, что доходят в
нужном порядке, потому что все равно поверх вот этого симулированной сетевой карты виртуальной
этого туннеля у вас будет своя реализация TCP, поэтому просто запихиваем каждый езернет-кадр
в UDP пакет и отправляем на VPN-сервер. И обратно тоже получаем. У нас есть некоторый способ сделать
дополнительную прослойку в сетевой иерархии, ввести новый сетевой уровень, либо несколько сетевых
уровней, если вы делаете огромную цепочку VPN-ов. То есть у нас на уровне канальной передачи данных
традиционно выделяется интерфейс езернет, сетевая плата, хотя совершенно не обязательно это может
быть езернет, это может быть какое-то виртуальное устройство, виртуальный туннель, и у каждого
езернет-устройства тоже есть свой адрес. Причем этот адрес связан с каждым конкретным устройством,
если вы внимательно изучите все наклейки на ваших ноутбуках. Правда, наклейки не в всех ноутбуках
бывают, некоторые производители их просто не клеят. Одна из наклейок это MAC-адрес вашей
Wi-Fi-карты. Как правило, считается, что MAC-адрес жестко привязан к конкретному производителю оборудования,
конкретному экземпляру оборудования, но на самом деле это не жесткое ограничение, и MAC-адреса у
некоторых производителей можно перенастраивать. В частности, если вы настраиваете какой-нибудь
роутер, у большинства роутеров есть возможность присвоить какой-нибудь произвольный MAC-адрес.
И вот этот MAC-адрес как раз используется для того, чтобы адресовать ваше устройство. Забудем пока про
все IP-адреса. Они нам не нужны. Для чего нужны MAC-адреса? Они нужны для того, чтобы могли общаться
между компьютерами, которые находятся близко друг к другу. То есть все устройства в пределах одной
Wi-Fi-сети. Если вы сейчас подключили стилю сеть МИПТ, то я могу найти ваш адрес. Если через МИПТ-НГ,
значит мне нужно переподключаться. Либо в пределах одной локальной сети соединенной
проводами до первого маршрутизатора. Какие бывают устройства для проводной коммутации сети Ethernet?
Есть устройства пассивные, так называемые хабы. Они уже практически все вымерли, можно найти только
где-нибудь в барахолке у каких-нибудь дяюшек, которые делают ретро-музей с компьютерного железа.
Фактически это просто коммутаторы кабелей с предусилителем, которые никак не смотрят на
ваши MAC-адреса. Чуть более распространенные устройства это так называемые свечи. Они же
коммутаторы не намного дороже, чем хабы, но они умеют перенаправлять трафик в зависимости от того,
какой у него MAC-адрес. Чуть более осмысленная нагрузка на отдельные кабели. Более продвинутое
устройство называется роутер. Как правило это обычный хост, обычный компьютер с обычной операционной
системой. На самом деле с точки зрения логической организации сети это самый обычный хост. Самый
обычный компьютер, у которого есть свой IP-адрес, и роутер может просто принимать данные из одной
под сети, перенаправлять другую. В этом его задача. До первого роутера, то есть в пределах некоторой
Wi-Fi сети, до выхода сеть наружу, до первого роута по проводам, все компьютеры могут общаться между
собой, даже не имея IP-адресов. При этом все-таки IP-адреса нам нужны. Для чего они нам нужны? Для того,
чтобы выходить куда-то за пределы нашей микросети, ну и иметь доступ до выхода в глобальную сеть.
Естественно, если вы уже подключились к какой-то сети, то скорее всего IP-адрес вам уже присвоили,
и между компьютерами в локальной сети и физическими MAC-адресами, которые соответствуют вашим
устройствам, есть однозначные соответствия. Некоторая таблица соответствия IP-адресов и
MAC-адресов, она недолго живущая, в Linux заживет 30 секунд, потом обновляется. И для назначения IP-адресов
используется протокол ARP. Здесь мы уже говорим про назначение адресов по какому-то протоколу,
имея в виду, что никакой IP-адресации у нас нет. То есть что у нас может передаваться в одном
Ethernet-кадре? Идея в том, что в одном Ethernet-кадре могут передаваться не обязательно IP-пакеты,
а все что угодно. Для этого в кадре Ethernet есть два байта, которые выделяются под тип данных,
которые у нас расшифруются, там передаются. В частности, это может быть какой-то IP-пакет для
протокола IPv4, либо пакет для протокола IPv6. Это совершенно разные пакеты, несмотря на то,
что назначение протоколов одинаковое. У нас под ними тем же кабелем могут гоняться как IP-пакеты,
так и пакеты системы NovelNetware, которые по протоколу IPv6. И это ничему не будет противоречить,
потому что они будут иметь разные константы в поле тип Ethernet-кадров. Кроме IP, бывают еще
некоторые другие протоколы. В частности, протокол ARP, который предназначен для того,
чтобы выяснить IP-адрес какого-то компьютера по его MAC-адресу, либо наоборот. И для того,
чтобы иметь возможность смотреть эту таблицу, есть утилита под названием ARP. В некоторых
дистрибутивах она входит в штатную поставку, в некоторых дистрибутивах эта утилита не входит
в штатную поставку и нужно ставить отдельно. Я сейчас ее запущу не в Linux, потому что это будет
неинтересно, а под macOS, потому что это хост-система. ARP. Давайте посмотрим, кто у нас тут рядом есть.
Сейчас я нахожусь в сети под названием MIBD. Я вижу два ноутбука, один десктоп. Видимо,
тут кто-то есть еще кроме меня. Если я запущу эту утилиту еще через некоторое время,
то результаты могут отличаться, потому что жизненный цикл таблицы 30 секунд периодически
обновляется. По этой таблице, зная IP-адрес, можно выяснить его MAC-адрес и, соответственно,
когда вы хотите отправить какой-то AP-пакет к какому-то компьютеру с вашей локальной в сети,
не используя маршрутизатор, вы знаете, что какой-то компьютер находится рядом, то достаточно отправить
его напрямую, завернув AP-пакет в какой-то Ethernet-кадр и направив конкретному какому-то компьютеру.
Дальше, если мы запихиваем что-то в наш Ethernet-кадр, то есть у нас есть некоторый Payload размером до
1500 байт, и вот туда уже можем запихать тоже, что имеет свои заголовки, свои данные. Чаще всего
там ходят IP-пакеты, либо IPv4, либо IPv6. IPv4 более распространенный протокол, хотя у него огромное
количество недостатков, и он уже подразумевает, что у вас должен быть назначенный IP-адрес. При этом
пакеты могут гулять как угодно по сети. Допустим, вы хотите отправить к некоторому серверу под
названием yandex.ru, у которого есть определенный белый IP-адрес, какие-то данные. Вы эти данные
подготовили, завернули в AP-пакет, какому из компьютеров нужно их направлять. Если у нас есть
Wi-Fi-роутер, то ответ, наверное, достаточно очевиден. Нужно отправить это роутеру, у которого тоже есть
свой IP-адрес уже назначенный, который находится в той же локальной подсети, что и ваш компьютер.
Если это локальная сеть с кучей проводов, то здесь уже все не так однозначно, роутеров может быть
несколько, и куда именно дальше отправляются ваши Ethernet-пакеты, содержащие нужные AP-пакеты.
Это определяется таблицами маршрутизации. Есть старинная классическая утилита по названию
Root, которая есть как в линукс-дистрибутивах, но в некоторых последних версиях дистрибутивов ее
нужно ставить отдельно, так и является стандартной для FreeBSD macOS, которая позволяет,
конечно, имея права Root, модифицировать таблицу маршрутизации, назначать какие-то из компьютеров
ответственными за то, чтобы перенаправлять дальше весь трафик. В линукс это делается универсальной
командой под названием IP, это универсальная команда, потому что она позволяет делать все,
что угодно, настраивать таблицу маршрутизации, настраивать сетевые интерфейсы и так далее.
С параметром Root либо с буквкой R эта команда может отображать таблицу маршрутизации,
либо при наличии соответствующих прав ее перенастраивать. Итак, если мы хотим выяснить,
как достучаться до какого-нибудь сервера, например, yandex.ru, это вариант FreeBSD и macOS,
в линукс Teletor Root тоже существует. Куда мне нужно постучаться? Мне нужно отправить пакет,
как ни странно, в некотором гейтвейу, у которого есть адрес net120.ipoe.users.mit.ru, у которого есть свой
IP-адрес. На самом деле все пакеты будут отправляться именно туда, дальше этот сервер под названием
net120.ipoe.users.mit.ru будет смотреть, по какому из маршрутов выгоднее отправить во внешнюю сеть
yandex.ru. Мой пакет его, конечно же, модифицирует. Для чего нужна модификация заголовков IP-пакетов?
Связано это с тем, что когда я отправляю какой-то пакет, он имеет внутри себя адрес отправителя.
Какой адрес отправителя у меня будет? Какой-то не совсем легальный для использования извне,
начинающийся с 10, 211, чего-то там. Это серые адреса, предназначенные только для локальных сетей.
И, соответственно, яндексу надо будет отправить куда-то обратно ответ, чтобы получил именно я,
а не кто-то другой. Он будет отправлять ответ провайдеру, провайдер будет отправлять уже
МИП-телекому. МИП-телеком уже будет разбираться по своей таблице маршрутизации, на какой из
вай-фай роутеров на фистехе нужно отправить этот пакет, а дальше уже конкретный вай-фай роутер будет
разбираться, какому устройству нужно его доставить. Под линукс примерно все то же самое. Утилита
называется IP. Тут куча вариантов, что можно настраивать. Вот IP road, левая буковка R. Отображаю,
что дефолтный... Да, вывод немножко другой, но он примерно совпадает. Поскольку линукс у меня
в виртуалке, тут результат немножко другой. Есть один дефолтный маршрут через устройство с
определенным именем и через определенный маршрутизатор, у которого есть какой-то IP адрес.
И маршрутов может быть несколько, в том числе несколько маршрутов по умолчанию. Это относится
к любой UNIX-системе, не только к линуксу. Для чего вам могут понадобиться несколько маршрутов?
Например, если у вас есть несколько сетевых плат, то, во-первых, вы можете разные сетевые
платы использовать для разных подсетей. Например, одна сеть внешняя, не очень защищенная,
все-таки внешний мир. Другая сеть исключительно для внутреннего потребления, куда лазить особо
не нужно, защищена фаерволом. Так и просто иметь несколько оплинков, независимых друг от друга.
Например, у вас есть основной провайдер, плюс у вас есть, на всякий случай, дополнительный канал
связи через мобильную сеть, на случай, если там забудете проплатить за интернет или провайдер
какие-то проблемы возникнут, мало ли что. Эти каналы могут использоваться для резервирования,
ну либо, если они доступны одновременно, то почему просто трафик не раскидать равномерно
по разным маршрутам. На самом деле, в линукс можно настраивать приоритетность каждого из маршрутов,
так называемый вес, с которым пакеты будут отправляться, с какой вероятностью по каждому
из ваших оплинков и других маршрутов. Ну и плюс, опять же, вы можете достаточно гибко настраивать,
какой из маршрутов у вас для каких IP-адресов используется. Зачем это бывает нужно? Ну, например,
у вас есть основной маршрут, плюс вы подняли VPN-тунель, зачем вам весь трафик гонять через VPN?
Ну, примерно половина интернета доступна без VPN, можно на этом сэкономить. И вот как у нас
происходит настройка присвоения каких-то IP-адресов. То есть понятно, что без IP-адресов вы можете жить,
поставить два компа рядом, прокинуть между ними провод. Все хорошо, все замечательно. Если компьютеров
становится слишком много, то в принципе можно тоже вручную прописывать. В Windows это делается тем,
что вы залазите в свойства сети, кликаете мышкой много где, вы вбиваете циферки. В линукс все делается
с текстовыми конфиг-файлами, но так, наверное, на самом деле уже давно никто не делает. Это
жутко неудобно. Даже для серверов настройка выполняется динамически. Для этого в локальной сети
должен присутствовать один либо несколько специальных серверов, которые называются DHCP
сервер. Сам протокол называется DHCP, Dynamic Host Clean Protocol. Для чего нужен протокол,
для чего нужны эти серверы? Для того, чтобы выдавать, имея пул каких-то IP-адресов,
IP-адрес вновь подключившимся к компьютеру. Вновь подключившимся это значит, что либо вы
подключаетесь к Wi-Fi сети, либо втыкаете кабель, либо кабель был вотнут, вы просто включаете
компьютер. Как происходит назначение какого-то IP-адреса от сервера к клиенту? Сначала клиент
отправляет широковещательный запрос. Здесь уже отправляет широковещательный запрос по UDP
протоколу. Если есть UDP, то, соответственно, у нас должен быть уже настроен IP, но IP у нас еще
не настроенный IP-адреса нет, и поэтому отправляется запрос с ненастроенного IP-шника 4.0 на специальный
IP-шник, у которого все биты единичные. Это так называемый широковещательный запрос,
который отправляется всем компьютерам локальной сети, его слушают все, но не все обязаны отвечать.
Те хосты, которые выполняют функциональность DHCP сервера, как правило это роутер, но на самом деле
роутеров может быть несколько, они в ответ тоже широковещательным образом, поскольку пока еще
нам не сообщили свой IP-адрес, сообщают возможные варианты, какие IP-адреса свободны, и дальше клиент
может взять какой-то IP-адрес, есть предложение несколько, то клиент может еще подумать, что такой
IP-шник мне нравится больше, чем другой, после чего отправляет реквест уже конкретному серверу,
что да, я хочу забрать этот IP-адрес, все, сервер подтверждает и считается, что клиент уже настроен.
При выключении компьютера, при перезагрузке клиент может послать серверу запрос на то, что IP-адрес
освобождается, и сервер имеет право этот IP-адрес назначить кому-то другому. Делается в Linux
это отдельным демоном, который называется DHClient. Что это за интересный процесс? Это тот процесс,
который вы можете наблюдать, если вы включаете компьютер, у вас загружается Linux, что-то у вас с
сетью не очень хорошо, в некоторых дистрибутивах вы можете долго 15 секунд наблюдать, пока там
висит надпись starting DHClient, на самом деле, если у вас systemd-дистрибутив, то это все
делается фоном и не тормозит загрузку системы, и если у вас сеть работает, то как минимум вы
можете видеть, что в системе болтается один процесс, который называется сбин DHClient с
параметрами, который запущен, если его остановить, то вы потеряете IP-адрес, если у вас несколько
сетевых интервесий, то будет несколько таких процессов. Его задача как раз то, чтобы поддержать
в актуальном состоянии IP-адрес, периодически его обновлять, и запускается он в момент настройки
сети. IP-адреса это все хорошо, только кто-нибудь помнит IP-адрес Яндекса? Какие IP-адреса вы помните
вообще? 127.01, замечательно, очень простые цифры. Какие еще IP-адреса полезно помнить? На самом деле
достаточно помнить только IP-адрес 4.8, 8.8.4.4, ну и еще 4.1, на всякий случай. Если вы помните
только эти IP-адреса, считайте, что вы можете найти в интернете все что угодно, потому что по
этим IP-адресам располагаются сервера, которые содержат в себе информацию о том, как имена
превращать в IP-адреса. И на самом деле каждый DNS-сервер не обязан хранить информацию обо всем
интернете. Если он что-то не знает, он может отправить запрос уже вышестоящему DNS-серверу,
это иерархическая система. Иерархическая система, с одной стороны, она не обязана
одновременно все помнить, это достаточно экономично, но есть и некоторые недостаток. Например,
если вы покупаете какой-нибудь домен и хотите быстро свой сервер на этот домен привязать,
но быстро не получится, нужно подождать до 15 минут, пока по всей цепочке DNS-серверов
это новое имя, новый IP-адрес у вас раскидается. Итак, DNS — это как раз служба, которая работает
тоже по протоколу UDP, как и протокол DHCP, предназначена для того, чтобы отвечать на вопросы,
как найти сервер с таким-то адресом. И что это могут быть за адреса? Да, DNS может не обязательно
использовать тот, который присвоен вашим провайтерам. Если вы используете что-то по умолчанию,
то в файлике IT-серии.sov.conf, скорее всего, будут прописаны строчки в момент установки соединения
на им-сервер и какой-то IP-адрес. Обычно используется два на им-сервера, на самом деле не обязательно два,
можно и больше, достаточно иногда всего лишь одного. Это просто для того, чтобы балансировать
нагрузку. Вот IP-адрес 81.5.91.37 — это что-то физтеховское, автоматически присвоенное маршрутизатором,
но никто не мешает вам с правами рута открыть наредактированный этот файл, прописать IP-адрес
4.8, чтобы всегда гарантированно использовать гугловские DNS. Только при следующем подключении к
сети этот файл будет перезатёрт, и лучше править немножко другой файлик — tc-network-interfaces,
там ручками прописать DNS-name-servers, и это будет использоваться, в том числе при назначении DNS-серверов
через DHCP. Ну и как этим сервисам пользоваться? Почти везде есть команда по названиям nslookup.
Простая, тривиальная. Вот, например, nslookup yandex.ru — неизвестный адрес, потому что я
опечатался. А вот если вы написали правильное имя, то получаете ответ — имя сервера yandex.ru,
адрес такой-то, имя сервера yandex.ru, адрес такой-то. Так, а к кому из них верить?
Какой из IP-шников правильный? На самом деле все правильные. Никто не мешает в одной
DNS-записи держать несколько IP-адресов, связанных с одним именем. Для чего это бывает полезно? Для
балансировки нагрузки. Если у вас сервис очень популярный, высоконагруженный, то имеет смысл
раскидать на несколько серверов. В каком порядке будут эти сервера использоваться? На самом деле
здесь можно использовать любой из них, и браузеры обычно просто поочередно запросы отправляют каждому
из них. Но на самом деле это только у крупных сервисов. Если вы поищете что-нибудь поменьше,
чаще всего у вас будет только один IP-адрес. И вот кто нам выдал? Нам выдал сервер 81.5.91.37.
Это что-то фестиловское от провайтера. Есть еще чуть более продвинутая утилита,
которая называется Dig. Делает примерно то же самое, что и у нас Lookup, но вывод выдает более
подробный. Результат получаем тот же самый, точнее результаты получаете в названии,
точку. Что это точка в конце означает? На самом деле правильное доменное имя, по всем правилам
записанное, заканчивается на символ точки. То, что вы в браузерах эту точку в конце не вводите,
но просто сделано для удобства, и все к этому привыкли. Но по стандарту точка должна быть в
конце то же самое. Это полное имя. В чем особенность отличия утилиты Dig от NSLookup? Кроме того,
что ее вывод отличается внешне. Принципиальным отличием еще является то, что я могу явным
образом в таком виде собакой и дальше циферки указать, какой именно DNS-сервер я хочу использовать,
чтобы получить какую-то запись. В данном случае Google нас не обманывает. Результат дает тот же
самый. Кстати, фистеховский сервер нам дополнительно выдал еще какие-то потроха внутренние. Для чего
бывает полезно использовать какой-то конкретный DNS-сервер, к которому вы доверяете? Банально вы в
метро подключаетесь. В метро сейчас тоже стало непопулярно. Кто-нибудь вообще пользуется в метро
или в электричке Wi-Fi, или вы уже не пользуетесь и правильно делаете. Если вы пользуетесь каким-то
общедоступным бесплатным Wi-Fi, понятно, что бесплатный сервер только мишеловки. Сейчас уже не так
популярно, как раньше, а раньше любили просто подменять контент, вставлять рекламу. Заходите на
какой-нибудь сайт, вам внедряется какой-нибудь баннер от московского метро. Сейчас это делать
сложнее, потому что используется практически посеместное протокол SSL, и просто взять и
подменить что-то не получится. Один из способов как это сделать, не используя дорогостоящую
интроспекцию трафика, это просто перенаправлять ваши запросы DNS на какой-то внутренний сервер
рекламодателя, который будет вам выдавать какой-то свой контент, ну и использовав в качестве
прокси, чтобы выдать какое-то настоящее содержимое. В общем-то не очень безопасно.
Но DNS это один из способов как обезопаситься, хотя он явно далеко недостаточный.
Что еще полезно надо знать про DNS? Записи бывают разных типов. В выводе NS Lookup вы видели только
IP-адрес и больше ничего. Если посмотреть на тот же самый Яндекс.ру, то можно увидеть намного
более интересное что-то. Яндекс.ру, хотя не очень интересно, здесь записи типа A, это записи,
так точнее, видимо, я что-то у утилиты DIG не все спросил, там нужна опция, чтобы она все выдала.
Qtype, давайте запрошу записи вида MX. Утилит DIG надо еще я указывать. В общем, бывают разные
виды записей. Например, запись типа A, это обычная запись, которая используется, например,
SSH сервером, telnet сервером, HTTP сервером. То есть основная запись, которая содержит IPv4 адрес.
Куда отправить запрос? Из браузера. Куда отправить? Нужно отправить данные при попытке подключения по
SSH. Для чего еще может использоваться имя яндекс.ру? Например, если написать символ собачки перед
яндекс.ру, то мы что получаем? Еще какие-то буковки перед символом собачки. Мы получаем почтовый адрес.
И для этого как раз используется другой вид записи под названием MX. Он может иметь необязательно
IP адрес, он может иметь отсылку на какой-то другой реальный сервер. Можно выяснить его IP адрес
точно так же обычным образом. И не факт, что он совпадает с IP адресом яндекс.ру. То есть у нас
бывают разные типы записей. Кроме почты, есть еще отдельные типы записей, например, для протокола
Jabber, который когда-то использовался Google Talk. Сейчас его переймали в Google Meet. Ну и так далее.
То есть бывают сервисы, которые могут иметь свои отдельные типы записей. Адрес 4А обычно используется
для синонима адреса А, но только для IPv6. То есть он содержит не 32-битное значение, а 128-битное.
И еще может быть ситуация, что у вас на одном физическом сервере болтаются несколько сайтов.
Соответственно, сервер должен иметь несколько имен. И дополнительные алиасы создаются с помощью
записей типа Cname, которые содержат вовсе не IP адреса, а просто обычные тексты, отсылки на какие-то
другие имена хостов. С DNS разобрались. Это то, для чего используется UDP. В реальной жизни, даже если
вы не пользуетесь торрентами, не пользуетесь VPN и живете в каменном веке, все равно с протоколом UDP вы
сталкиваетесь как минимум на уровне DNS и на уровне протокола DHCP. Следующий тип низкого уровня
взаимодействия, помимо UDP, это еще более низкий уровень, когда вы целиком можете прочитать
содержимое всего пакета, например, внутри IP пакета, включая заголовки TCP, UDP, или придумать
свой протокол. Либо вы можете на системе Linux придумать свой протокол вместо IP. Для этого вам
нужно будет залазить уже внутрь в кадра Ethernet. Нисколько не доступ к IP. Могут делать не все,
либо пользователи root, либо, помните, Linux Capability, когда вы настраиваете на какой-то
бинарный файл дополнительные атрибуты, это расширенные атрибуты файлов, которые позволяют,
не повышая привилегий до рта, выполнять какую-то отдельную функциональность. Одна из
функциональностей Capnetro позволяет на низком уровне открывать сокеты и дальше читать из
этих сокетов данные, которые тупо читаете из сетевой платы, забираете целиком и смотрите
на их заголовки, дальше с ними что-то делать. При этом они могут содержать целиком данные TCP,
UDP, но дополнительно можно еще включить, чтобы можно было модифицировать заголовки IP.
И еще более низкий уровень. Это уже ковыряться на уровне кадров Ethernet, то есть вытаскивать всю
полезную нагрузку, которая затем заворачивает Ethernet пакет, но еще ниже опускаться тут уже
на программном уровне невозможно, это требует уже аппаратных средств. Для этого используется
пространство имен Packet. Понятно, что если вы будете из сокета читать все на самом низком
уровне, то вы будете ловить абсолютно все, любой мусор, включая ARP. Чем это плохо? Тем,
что у вас будет огромное количество данных, и здесь вы можете уже сильно запутаться.
И если у вас есть какое-то отдельное пространство имен, в частности, когда вы
используете адрес FamilyUnix, в качестве адреса вам нужно указывать имя файла. Когда пространство
имен интернет, вам нужно указывать IP-адрес плюс номер порта, и что-то подобное есть для пространства
имен пакетного уровня. Именно там нужно указывать номер сетевой платы. Когда у вас появляются
некоторые сетевые платы, появляются в том числе и динамически, потому что сетевой платы вы можете
подключить через USB. ЕДО присваивает им какой-то порядковый номер. Если вы наберете команду
под Linux, назовем ее EF-config. Под Linux нет только команды, это только под Mac 3BSD. Точнее,
можно поставить либо IP-L, то получите список сетевых интерфейсов, которые у вас в текущий момент
настроены. Например, Loopback-интерфейс 127.0.1, сетевая плата. И вот у них есть порядковые номера 1,
2 и так далее. Вот у них есть еще сетевую плату USB, либо в виртуалке, поменяйте настройки,
появится какая-то еще другая сетевая плата. Они могут быть либо настроеными, либо не настроеными.
У них есть порядковые номера, все это доступ к ним осуществляется. Седьмой раздел Man страницы
NetDevice дает ссылку на системный вызов под названием IOCTL, с помощью которого можно отправлять запросы и
по именам сетевых интерфейсов, соответственно, получать их порядковые номера, которые дальше
можно использовать для RAV пакетов. Для чего я вам все это показываю? Для того, чтобы показать
реализацию на низком уровне, как можно просто смотреть на происходящее в вашей сетевой плате.
Так, создаем socket, который имеет пространство non-packet и предназначен для сырой передачи данных.
Если указать третий параметр, который выполняет роль фильтра, что мы отловливаем все Ethernet пакеты,
то будете ловить все. Опасненько, но ладно. На самом деле в прот такой код пускать очень хорошо.
Затем вам нужно выполнить операцию bind, то есть связать ваш socket с каким-то адресом, и для этого
нужно выяснить индекс, порядковый номер вашей сетевой платы, делается с помощью стен вызова IOCTL,
то есть вы знаете имя сетевой платы. Сетевой платой номируют в Linux, которые в Wi-Fi,
обычно именуются WLAN, какая-то циферка 0, 1, 2, чаще всего 0, сетевая плата Wi-Fi всего 1.
Если это Ethernet, то либо ETH и циферки 0, 1, 2 и так далее, либо на некоторых устройствах,
если у вас сетевая плата сделана на одном чипе, но при этом имеет несколько выводов,
то может называться EMP 0, 1, 2, это порядковый номер сетевой платы, и если она имеет несколько
разъемов, то SYNC номер 0, 1, 2, 3, 4, 5 и так далее. Вы знаете какое-то имя, дальше вы это имя
используете для того, чтобы выяснить индекс, все, ну а дальше стандартный адрес, адрес family,
протокол, то есть фильтр, который вы хотите навешать, индекс, связываете байном, ну а дальше
тупо обычным реквам читаем какие-то данные, оттуда мы можем вытащить, поскольку это будут IP пакеты,
IP адрес по определенному смещению, ну и зачем показывать код, когда можно продемонстрировать
его работоспособность. Итак, компилируем, скомпилироваться оно скомпилировалось,
запускаться уже не хочет. Operation node permight на стадии создания сокета, почему это происходит?
Ну потому что я не являюсь пользователем root, зато я могу разрешить обычному неприлегированному
пользователю создавать низкоуровневые сокеты, setcap, capnet, troll. Так, вспоминаем capabilities,
какие права мне нужно тут навешать, какие флаги. Во-первых, флаг permissive, очевидно,
должен быть. Что еще? Вот я про одну буквенную флаги сейчас как раз и спрашиваю. Permissive,
чтобы разрешить, что еще нам нужно? На счет минус E, так нужно или не нужно?
Флаг E тоже нужен. Почему? Потому что в начале нашей программы мы уже создаем сокет,
то есть предполагаем, что права у нас должны быть проставлены. Мы тут не лазим с помощью
на проверку флагов. Так, экзампл 1. Тут, естественно, требуются уже права врута.
Так, главное не забывать свою пароль. Это очень грустно. Ну и после этого можно запустить
программу. Так, ну сейчас она будет мне протоколировать все, что происходит по сети,
на сетевом интерфейсе, который там был указан. Но для этого нужно выполнить консистенцию операцию,
но пусть будет тот же самый DIG к адресу 4.8 для index row. А тут еще какое-то взаимодействие идет.
Какой-то IP адрес 10.211. А, это SSH. Все. В общем, вы можете ловить все пакеты,
лазить в их содержимое. Вот для этого требуется повышение привилегий, потому что было бы странно,
если бы обычный пользователь мог залезть в произвольный пакет, который отправляется по сети.
Так делать нехорошо и небезопасно. Так, зачем вообще это может понадобиться вам? Есть такая
замечательная утилита, называется TCP dump, которая делает примерно то же самое,
как программка, которую я вам сейчас показал. Утилита Wireshark, помните? Да, только на семинарах.
В общем, есть такая замечательная утилита Wireshark, которая позволяет анализировать все,
что происходит по сети. На самом деле есть еще консольный вариант утилита,
который делает все то же самое, называется TCP dump. Вот пример. Как сделать так, чтобы ловить все,
что происходит у вас через сетевой интерфейс TCP dump emp0s5. И удовлетворяет условиям,
что адрес назначения это 4.8, порт назначения 53.53, это номер порта для DNS сервера. Давайте
будем ловить все такие запросы. Конкретному IP-адресу. ДСТ порт 53. Но здесь требуется правобога.
ДСТ 4.8. Естественно, нужно что-нибудь отправить. Видно, что отправили какой-то запрос, порта,
номер такого-то, с запросом, который TCP dump понял, что это DNS, и смог его разобрать,
что мы спрашиваем запись типа A на имя yandex.ru. Тоже самое вы можете писать в красивом виде
внутри окошка утилиты Wireshark, которая с графическим интерфейсом. Вот как такую штуку сделать? Один
из вариантов это использовать низкоуровневые пакеты. Вы тоже самое можете написать в утилите
Wireshark, только тут есть одна маленькая тонкость. Вот Wireshark. Отвратительно, конечно, на проекторе.
В общем, для тех, кто не видит, что происходит на проекторе, это утилита Wireshark. Я открываю
сетевой интерфейс, тут куча всего болтается, там логи того, что болтается по CP, я могу писать
фильтры. Да, вот этот Wireshark, он вовсе не под Linux запущен, он запущен под Mac. А если внимательно
посмотреть седьмой раздел по пространству имен пакет, тут есть всякие Linux специфичные
заголочные файлы. Если я тоже самое попрошу седьмой раздел по пакет, уже под macOS, ничего такого нет.
Если я посмотрю ман по socket, то опять же есть свои пространства имен, которые могут частично
пересекаться с Linux, могут не пересекаться, но никакого пространства имен пакет не существует.
Тем не менее, Wireshark одинаково работает, так под Linux, так под macOS. То есть, на самом деле,
то, что я вам рассказываю про перехват на низком уровне каких-то пакетов, я вам тут немножко обманул
про реальный use case. И утилиты типа Wireshark и TCPDump, они работают немножко по-другому. Давайте
посмотрим на запрос, что мы хотим к тому же утилите TCPDump. Так, destination port 4.8,
ну хорошо. И вот если я добавлю опцию минус D, то наша программа превратится в что-то похожее на
языке ассемблера. Пример, который приведен на слайде, примерно такой же. То есть,
нам нужно, он немного отличается. Так, допустим, мы хотим отловить все пакеты, которые содержат
заголовки UDP и IP. Да, вот через точки запятой, это я уже вручками написал комментарии, это не вывод
TCPDump, что он здесь содержится. Нам нужно загрузить какое-то число 12, выполнить инструкцию jump or
equal с каким-то числом 86DD. Что такое 86DD? Это всего лишь порядковый номер протокола по названиям IPv6,
то есть та константа, которая фигурирует в заголовке Ethernet. Дальше мы перескакиваем к строчке либо 6,
если истина, либо false, тогда на строчку номер 2. На строчке номер 2 мы проверяем, что если какое-то
странное значение, где-то там, а, значение которое по смещению 12 совпадает с 0x800, это просто 16-битное
значение, которое указывает, что в заголовке Ethernet у нас используется протокол IPv4. По поводу того,
откуда берутся эти константы, еще раз я вернусь к слайду, вот этом, там где заголовок Ethernet.
С глушным файлом нет Ethernet.h, как раз содержат все эти константы, он универсальный под разной
операционной системы. Дальше мы проверяем, является он IPv4 адресом, если ОК, то идем дальше. Затем нам
нужно проверить, что он является действительно протоколом UDP. Для этого мы загружаем 23 байт,
вот 12 байт, 23 байт, это все относительно начала пакета. Загружаем 23 байт, смотрим на какую-то
константу, 17 это UDP, 6 это TCP, это все можно посмотреть обычным Wireshark, тут ничего нового для вас
нет. Ну и возвращаем уже дальше какое-то большое значение, либо число 0. Что это такое? Это некоторая
маленькая программка. Заметьте, что это не язык ассемблера RX86, это не язык ассемблера ARM. Это
какой-то свой язык, похожий на язык ассемблера, который описывает маленькую программку,
которая называется фильтр. Классический BPF фильтр, от слова Berkeley Packet Filter, существует
практически в любой UNIX системе. Это очень старая реализация, для чего она нужна. И вот эти
программки выполняются достаточно быстро. Для чего это нужно? Для того, чтобы выполнять фильтрацию и
в зависимости от того, что вам прилетело по сети, либо принимать пакет, либо не принимать, но если вы
принимаете, вы можете с ним делать что-то дальше. Что такое? Отдельная инструкция. То есть вот каждая
строчка от того кода, который я вам привел, она представляет, может быть транслирована в некоторую
риск-инструкцию. Что такое риск инструкции? Чем не от сыск инструкции отличаются? Длина инструкции,
риск это значит, что каждая инструкция имеет какой-то фиксированный размер в отличие от сыск. Каждая
инструкция содержит некий обкод, что это представляет собой эта инструкция. Два восьми битных значений
это номера строк в случае, если она является условием, то куда надо прыгать, если true либо false.
Ну и возможно может иметь какое-то константное значение, например, для инструкции сравнения,
загрузки и так далее. Не более чем тряслеубитное. Общий вид инструкции по взаимодействию с
очень старого процессора, которого уже давно не существует. И вот такие инструкции интерпретируются
некоторой виртуальной машиной, которая находится внутри ядра. То есть весь этот код выполняется
сначала транслируется во что-то, потом выполняется внутри ядра. Вот чуть более сложный пример,
как отловить все пакеты, которые отправляются на гугловский DNS, который имеет адрес 4.8. Как
эта штука работает? По смещению в 12 байт относительно начала пакета мы смотрим,
что это у нас за пакет такой. Если это IPv4, то продолжаем дальше. Если нет, значит не судьба,
хотя можно обобщить на IPv6 тоже. Дальше по 23 смещению относительно начала пакета мы смотрим,
чем он является UDP или TCP. Нас интересует только UDP. Дальше мы загружаем по очередному смещению,
которое мы посчитали или посмотрели в аэршарке, четырех байтное значение IP адреса. Напомним,
что в IPv4 у нас IP адрес просто какое-то 32 битное значение. Дальше сверяем с константой 8.8.8.8. Очень
красивая константа. В случае успеха мы возвращаем значение минус 1, в случае неуспеха значение 0.
Каждая функция, реализованная на Berkeley Packet Filter, должна возвращать количество байт,
сколько нужно пропустить. Если это число 0, значит пакет целиком отклоняется. Значение минус 1,
оно просто превращается в 32 битное значение по правилу обратного дополнительного кода максимально
возможное значение, то есть 2 в 32 степени минус 1. И, значит, мы тем самым пакет пропускаем.
Вот что с этим кодом, написанным на языке псевдо ассемблера, можно сделать? Очевидно,
его можно во что-то транслировать. Вот эти самые структурки. Как это сделать? Открываем
документацию, которая находится в исходниках ядра Linux. Дальше по этой документации смотрим на
команды, смотрим их обходы, но так делать не очень удобно. Но если есть какой-то язык, пусть даже
не совсем полноценный, то видимо есть компилятор, который выполняет транслирацию с этого языка во что-то
более пригодное к использованию. И находится этот компилятор, как ни странно, в исходниках ядра
Linux. И для того, чтобы его получить, вам нужно скачать исходники ядра. Эта утилита, которая
тут требуется для компиляции, она не входит в стандартную поставку дистрибутивов. Так,
исходники ядра Linux. Качаются достаточно легко, просто легко находятся, все open-source, ничего не
закрыто. Ой, как это все выглядит на черном экране, отвратительно. Итак, ядро Linux,
стабильная версия, которая была выкачана сегодня, она более свежая, чем тот Linux,
под которым я все показываю, но это не страшно. Что вообще можно сделать с исходниками ядра Linux?
Первым делом, когда вы скачали, вы даже не можете его скомпилировать. У нас сначала настроить,
делается это либо команды make-default-config, создает config или dev-config, создает файл по
названиям .config, который основывается на дефолтной конфигурации сборки. Если вам нужно собрать ядро
под себя, делайте make-menu-config. Так, you display to small. Ну ладно, сделаем чуть побольше букву.
Появляется такая менюшка. Ой, опять же вы ее не видите, но я надеюсь на видеозаписи это будет
лучше видно. Тут вы можете пробежаться по всем настройкам ядра, которые включить, выключить,
что-то собрать в виде отдельного модуля, что-то вкомпилировать внутрь ядра. В общем, огромное
количество параметров. После этого, самое интересное, вы запускаете make и что дальше идете делать?
Идете спать. Это долго. Либо make-j20, чтобы задействовать все 20 ядер своего ноутбука. Это будет
уже быстрее, но я уже начинал собирать, поэтому у меня достаточно быстро соберется. В общем,
происходит достаточно долго, но не суть важна. Более интересно, что в исходниках ядра есть разные
тулзы, разная документация, которую кроме как в исходниках ядра вы не найдете. А именно,
во-первых, вы можете зайти сначала в раздел documentation. Там в этом разделе documentation есть файлик,
нет, networking, и там есть файл по названиям BPF, нет, не BPF. Фильтр,
EMAX, фильтр, RST. Рестрактарик текст, то есть плейн текст с некоторой минимальной разметкой.
И, пожалуйста, все очень подробно про BPF, даже с примерами, как это написать в псевдокодах.
Псевдокод имеет в виду то, что у нас 16-битное значение команда, 2 8-битных значения,
константорство убитное. Пишется жутко, давайте лучше это нагенерируем. Еще что интересного,
кроме раздела documentation есть каталог под названием tools. В этом тулз у нас есть BPF,
компилируем. Что-то собралось, что-то не собралось. Не собралось, потому что тут надо ставить еще
дополнительные библиотеки к тулзам. Самое главное тут файлик под названием BPF, подчерканье ASM,
который мы скопируем себе куда-нибудь поближе. Он нам еще пригодится. Теперь что мы можем с
помощью этого файлика сделать? Мы можем написать программу filter в обычном текстовом виде. Все то
же самое, что я вам проведал на слайде. Маленькая простая программа filter, которая применяется
к каждому входящему визуально этот пакету, смотрит на то, что внутри него содержится,
IP не IP, UDP не UDP, какой у нее IP адрес. Либо принимает этот пакет, либо отклоняет.
Что мы можем сделать с этой программой на Assembler? Наверное,
скормить этой тулзе под названием BPF, ASM. Фильтр получаем. Какие-то циферки на выходе,
какие-то байтики. В таком виде, наверное, не очень осмыслены. Есть замечательный флаг,
минус S или минус C. Получаем вывод немножко в другом виде. На что это похоже? Очевидно,
это какие-то структурки с циферками, соответствующие тем командам, которые мы
можем куда-нибудь теперь вкомпилировать, и будет нам счастье. Запишем это в какой-нибудь файл.
Пока не записываем. Пример программы, которая теперь выполняет фильтрацию,
мы уже используем пакетного фильтра. Точно так же, создаем сокет на низком уровне,
присоединяем его куда-нибудь. Все то же самое, что и в предыдущем примере.
Теперь нам нужно подготовить некоторую программу в виде последовательности инструкции.
Сок-фильтр. Каждый элемент структуры – это код плюс 2 байта, это смещение инструкции для
true, смещение для false либо константа. Затем мы эту программу прицепляем к нашему сокету,
используя стейн вызов сет сок-опт. Если программа корректная, то все замечательно.
К нашему сокету прицепился фильтр. Дальше мы читать сможем только нужные нам пакеты,
все остальное будет отбрасываться. Либо если что-то некорректное, то сет сок-опт вернет
какую-то ошибку. Если ошибка, значит надо как-то на это реагировать. Самое интересное,
как теперь сделать эту программу. У нас есть транслятор из псевдосемблера в последовательности
вот таких структур. Что делает конструкция решетка include? Что делает? Фактически это копия пасты
control-c, control-v. Если я от кого-то из вас на комиссии услышу, что решетка include подключает
библиотеку, это означает, что вас надо отчислять. Предупреждаю сразу. Такие перлы я уже слышал.
На комиссии это очень странно. Решетка include просто делает тупое включение текста и все,
больше ничего. Но и заодно там еще выполняется процессинг всех внутренних include. В оси никакой
не подключение библиотека. То есть мы можем сделать какой-то текст. Решетка include может
подстричаться где угодно, в любом произвольном месте. Поэтому сохраняем вывод нашего ассемблера
в текстовый файл, который будет дальше включен в наш example2.com. Теперь можно скомпилировать
нашу программу. Запускаем, прежде чем запустить ее. То же самое с setcap, row, example2.
Запускаем и отправляем запрос на яндекс.ru. Мы поймали среди огромного количества пакетов,
которые чем угодно инициируются. Поймали ровно один пакет с текущего IP-адреса на сервер 4.8.
Делается это все внутри ядра. Что хорошего в этом пакетном фильтре и что плохого? На самом деле
хорошего в нем то, что он работает внутри ядра и вам не приходится, потому что пакетов может
проходить много. Не приходится копировать постоянно что-то из пространства ядра,
в пространство пользователей, в пространство ядра. Зачем это лишнее взаимодействие? На пакет
прилетел в ядре, ядро его отклонило и все, замечательно. Работает намного быстрее. Есть,
конечно, некоторые ограничения. Если что-то у нас работает в ядре, что-то, что по идее может
запустить даже обычный пользователь, даже не обязательно root. Чем это опасно? Можно написать
какую-то программу, которая будет... что делать? API достаточно ограниченный, вы просто принимаете
пакет или отклоняете, то есть просто возвращаете какое-то число. Но вы можете написать какую-нибудь
программу бесконечный цикл. Чем это плохо? Прилетает какой-нибудь пакет, у вас бесконечный цикл,
который выполняется ядром, а не в полезном пространстве. И все, хана системе. На самом деле тут
проектировали фильтр далеко не дураки, они предусмотрели защиту. Чтобы программа не выполнялась
бесконечно долго, циклы реализовать тут невозможно вообще никак. То есть у вас есть... допускается
инструкции jump, но они допускают jump только вперед. Назад jump сделать невозможно. Для чего? Для того,
чтобы нельзя было организовать циклы. Ну и размер программы у нас тоже имеет осмысленный размер,
не более чем 4096 инструкций. Считается, что для простых фильтров сетевых это более чем достаточно.
И как выполняется загрузка программы? Загрузка программы на самом деле достаточно тривиальная
вещь. Вы уже что-то... иметь какой-то скомпилированный код, загружать ничего особо не нужно, у вас в памяти
уже что-то находится. После этого в момент... все этот опыт, когда вы подключаете к программу,
сначала выполняется верификатор BPF, который проверяет, что ваш код является безопасным.
И верификатор имеет полное право отклонить вашу программу. В этом случае сетцокопт вам скажет
ошибку, не очень осмысленную, конечно, инвалид-аргумент. Могли бы что-нибудь более читабельное сделать.
Значит ваша программа, скорее всего, просто не прошла верификацию, потому что верификатор
посчитал ее потенциально опасной. Потенциально опасной она либо слишком большая, либо содержит
прыжки назад. После этого, уже если программа успешно прошла верификацию, она подключается к вашему
сокету и начинает работать уже в режиме ядра. Это достаточно безопасный механизм. Но чем эта
конструкция плохая, достаточно старая. Несмотря на то, что это простой risk-by-code, все равно
требуется интерпретировать. И когда у вас объемы данных достаточно большие, то хочется уже выполнять
какой-то нативный код процессора. Поэтому этот классический BPF, который существует в любой
UNIX-системе, по-моему, даже в Windows присутствует. Разработка очень старая, но понятно, что уже
устаревшая. Теперь мы уже забываем о том, что у нас бывают другие системы, помимо Linux. Забываем
про FreeBSD, MacOS, все остальное. Это все детские игрушки. В Linux в 2013 году, я написал на слайде 2016,
потому что в 2016 году включили в состав ядра эту функциональность. Появилась новая реализация,
называется Extended Berkeley Packet Filter. Расширенная реализация, которая подразумевает, во-первых,
just-in-time-компиляцию кода для наиболее популярных архитектур. Я не знаю, поддерживается ли архитектура
ARM64. В следующей неделе я это выясню. Для ARM64 точно есть трансляционно-нативный код, огромный API,
который позволяет не только фильтровать пакеты, а делать привязку фильтров не только к сокетам,
но и к разным внутренним подсистемам ядра. До чего это бывает полезно? Например, выполнять
логирование происходящего с вашей программой на уровне ядра, мониторинг жизнеспособности,
очень полезные фичи — это фильтрация системных вызовов, которые нельзя вызывать и так далее.
В общем, новый развесистый фреймворк и самое главное, что тут не обязательно писать программы на
псевдо-ассемблере. Можно написать программы на чем-то высокоуровнем и дальше транслировать,
что-то высокоуровнем, имеется в виду язык Си и даже Питон. Дальше транслировать в
нативный X64 код, либо в байт-код для тех платформ, которые не поддерживают нативную компиляцию. Все
это опять же выполняется в пространстве ядра после верификации, что программа безопасна,
выполняется достаточно быстро. Сделано это в 2013 году товарищем с какой-то подозрительной русской
фамилией, хотя работает он в компании Facebook, которая ведет себя не очень красиво. Если вы
увидите какую-то картинку, то, скорее всего, эта картинка не нарисована никем, а сгенерирована
нейросеткой. Это означает, что лекция закончилась. Напоминаю, что следующая лекция последняя в
этом модуле, потом контрольная.
