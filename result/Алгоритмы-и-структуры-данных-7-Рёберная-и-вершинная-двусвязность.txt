Добрый день.
Мы продолжаем говорить про графы, про приложение
DFS.
Напомню, в прошлый раз мы сделали следующее.
Мы определили, что такое мост.
Мост – это ребро в неориентированном графе, такое, что его удаление
делает граф несвязанным.
То есть, изначально мы считаем, что граф связанный, удаляем
вот это одно ребро, тогда граф становится несвязанным.
Удаление которого делает граф несвязанным.
Хочется тогда понять, что будет, если таких ребер
нет.
То есть, как выглядят такие графы, в которых нет мостов,
и соответственно, как выглядят такие кусочки в каком-то
произвольно связанном графе, в котором есть мосты.
То есть, удалили какие-то кусочки, которые вот становятся
несвязанными после удаления никакого одного ребра.
Определение, пусть же это неориентированный граф,
тогда мы вводим такое отношение эквивалентности.
Говорим, что вершины У и В, ребер надвусвязаны.
Если существует два пути между ними, два пути между
У и В, такие, что они не пересекаются по ребрам.
Если между У и В существует два пути, которые не имеют
общих ребер, напишу так, которые не имеют общих
ребер.
Ну, значит, картинка какая-то такая, вот есть две вершинки,
есть какой-то один путь, есть какой-то другой путь.
Потенциально они могут пересекаться, но только по вершинам.
То есть, возможно, есть в пересечении этих путей
какая-то общая вершина, или они могут несколько
раз пересекаться.
Но главное, что нет общих ребер.
Тогда мы говорим, что они находятся в этом отношении
эквивалентности реберной двусвязанности.
Как всегда, для приличия надо доказать, что это отношение
эквивалентности.
Реберная двусвязанность – это отношение эквивалентности
на вершинах.
Мы это сейчас с вами докажем, потом поймем, как в графе
выделить компоненты реберной двусвязlavности.
И тогда как раз компоненты – это такие множества
вершин, компоненты реберной двусвязанности, которые
получаются в факторизации по этому отношению, íкотор
мы докажем, что они являются отношением эквивалентности.
это когда между любыми двумя вершинами есть, по сути, два непересекающихся пути.
Ну, по ребрам, по крайней мере.
И это значит, что если вы какое-то одно конкретное ребро удалите,
то граф останется связным.
Потому что, если оно и участвовало в каком-то пути от У до В,
то обязательно существует какой-то другой путь от У до В, который это ребро не содержит.
Потому что он с этим путем не пересекается вообще.
Значит, если мы рассмотрим все такие компоненты,
то это будут как раз вот такие куски, что в них нет мостов.
Наибольшие, по включению множества, такие, что в них нет мостов.
У них нет мостов.
Так, ну, здесь, значит, как всегда.
Что у нас? Рефлексивность.
Ну, понятно, если У равно В, то между ними, конечно, существует два пути.
Надо просто стоять на месте, там ноль ребер, и они поэтому не пересекаются.
По ребрам пересечений нет.
Симметричность, очевидно.
Потому что если есть два пути из У в В, не пересекаются,
то есть, собственно, пути из В в У.
Потому что граф не ориентирован, ребра можно проходить справа налево,
все останется точно так же, они пересекаться не будут.
Вот, ну и третья, транзитивность здесь чуть похитрее.
Транзитивность.
Смотрите, вот есть у меня два пути от У до В, реберно не пересекающиеся.
Есть два пути от В до ВВ, тоже реберно не пересекающиеся.
Я как-нибудь вот так вот нарисую.
Основная проблема может быть в том, что когда я рисую вот эти вот пути от В до ВВ,
они могут как-то пересекаться с тем, что я нарисовал раньше.
Могут пересекаться по ребрам с путями, которые от У до В идут.
Поэтому просто склеить, скажем, пути от У до В, от В до ВВ,
одну пару пути склеить и другую пару пути склеить, возможно, не получится,
потому что у них может быть где-то вот здесь пересечение, скажем.
Если эта штука содержала какое-то ребро здесь,
то тогда нельзя брать вот эту вот часть пути от У до В.
Нам будет такое пересечение.
Поэтому надо чуть более тонко здесь рассуждать.
Давайте скажем следующее.
Пусть С это реберно простой цикл
между У и В.
Мы знаем, что между У и В есть два ребра непересекающихся пути.
Значит, есть какой-то цикл.
Ну, собственно, если вот эти два пути пройти вот так вот,
сначала от У до В, потом от В до У, то это будет реберно простой цикл.
То есть это какой-то цикл такой, что все ребра в нем не повторяются.
Значит, вот его рассмотрим, говорим, что это С.
Все вершинки, все ребра образуют цикл С.
Дальше пусть, я скажу так,
П1 и П2 это два пути от В до В, которые не имеют общих ребер.
Ну и, наконец, пусть Q1 и Q2
это первые вершины соответствующих пути, которые попали на цикл С.
Вот это все.
Пусть С это реберно простой цикл,
Это первые вершины соответствующих путей, которые попали на
цикл С.
Первые вершины путей P1 и P2, которые лежат в С.
То есть есть наш цикл С, давайте я его так разверну
для удобства, чтобы он не сам пересекался.
Есть у него две вершинки у и в.
Дальше есть два пути, P1 и P2, которые начинают где-то
там в W и как-то вот так вот ходят, и оба заканчиваются
в В.
Давайте просто тогда, здесь он может быть много раз
пересекает цикл С, возможно даже по ребрам пересекает,
но давайте просто рассмотрим первое пересечение по вершине,
вот эта вершинка и вот эта вершинка, соответственно
Q1, Q2.
Просто в пути от W до В находим, какая первая вершина лежит
на цикле С и говорим, что это Q1, Q2.
Тогда давайте картинку перерисую.
Что мне нужно?
Мне нужно найти два ребер на не пересекающиеся пути
от У до W.
При этом у меня есть какой-то цикл С, на нем отмечены две
точки Q1, Q2.
Такие что из вот этих вот Q1, Q2 есть такие пути до W,
которые между собой не пересекаются и с циклом не пересекаются.
Еще раз, они не пересекаются, вот эти два кусочка не пересекаются
между собой, потому что это куски путей по 1 по 2 с одной
стороны.
С другой стороны они не пересекаются с ребрами цикла
С, потому что если бы пересекались, то соответственно на этих
кусках была бы более ранняя вершина, которая лежала
бы в цикле.
Вот это вот все, это ребра и вершины, не лежащие в
С.
Значит, можно поступить очень просто.
Можно от У, скажем, идя в одну сторону, дойти до Q2,
затем взять вот эту часть, давайте напишу, что это часть
пути по 2.
И то же самое здесь, от У дойти сначала до Q1, потом
закончится частью пути по 1, часть пути по 1.
Ну и все, и у нас получилось как раз два ребер на простых
пути.
То есть тут идея, конечно, такая, что нужно просто склеить
путь от У до В, потом от В до W, только нужно немножко
поаккуратнее это сделать, потому что если в тупую
склеить, то они могут пересекаться, чтобы этого исключить надо
просто взять вот какие-то экстремальные вершины, самые
близкие к W, и потом вот так вот наш цикл обойти.
Так, ну и вот, я утверждаю, что вне зависимости от того,
как Q1, Q2 попали в этом цикле, у нас обязательно получится
так сделать.
Но потому что картинка будет обязательно такая.
Есть какой-то цикл, в нем выделена вершина У, еще какие-то
две вершины Q1, Q2, которые могут совпадать, и при этом
нам не важно, в каком у них порядке расположены.
Например, там могло быть, наоборот, тут Q1, тут Q2, или
они вообще могли быть одной вершиной.
Но это ничего не меняет, даже давайте, вот худший
случай, когда они равны, когда это одна и та же вершина.
Тогда можно просто от У, скажем, против числа дойти
до Q1, затем взять вот эту часть пути по 2, ну, окей,
часть одного пути дойти до W, и потом пройти в другом
направлении, взять часть другого пути тоже дойти
до W.
Здесь будет пересечение по вершине этих двух путей,
но не по ребрам, потому что эти ребра цикла, тут нет
одинаковых ребер.
Ну, здесь я уже тоже говорил, что здесь ребра не пресекаются,
то есть нет общих ребер, и у частей этих путей тоже
нет ребер из цикла, поэтому мы получили два хороших
пути.
Согласны?
Ну, значит, есть транзитивность, значит, отношение эквивалентности
и, значит, есть, как бы, основание говорить о компонентах
ребер над усвязанностью.
Компоненты ребер над усвязанностью, ну, это просто класс эквивалентности
по тому отношению, которое мы так что ввели.
Класс эквивалентности относительно, давайте, по отношению ребер
над усвязанностью.
Так, ну, и, соответственно, вопрос, как найти эти компоненты,
ребер над усвязанностью.
Ответ очень простой.
Достаточно найти в графе все мосты, давайте я вот
так нарисую, значит, достаточно найти в графе все мосты,
и тогда оставшиеся компоненты связанности будут компонентами
ребер над усвязанностью в исходном графе.
То есть вот я нарисовал так мой граф, здесь там, ну,
много ребер, так что здесь нет мостов внутри вот этого
облачка, а вот эти отдельные перемычки между кружочками
– это мосты.
Тогда если я удалю все мосты и буду рассматривать
просто компоненты связанности в получившемся графе, то
это будут в точности компоненты ребер над усвязанностью.
Значит, утверждение такое, компоненты реберной двусвязанности
в G – это компоненты просто связанности, компоненты
связанности в графе G минус мосты, G минус мосты.
Так, значит, нам это надо доказать.
Давайте сфокусируем внимание на какой-нибудь компоненте
связанности в нашем графе.
Докажем, что здесь все вершины попарно находятся в отношении
ребер над усвязанностью.
То есть вот я удалил мосты, рассмотрел какую-то одну
компоненту связанности в получившемся графе.
То есть по сути я рассмотрел некое множество вершин,
ну и ребер между ними, такие, что все ребра здесь не
мосты.
Я мосты удалил, оставил только не мосты, поэтому
здесь в этой компоненте все не мосты.
Вот как устроено множество вершин, таких что все ребра
не мосты.
Все ребра не мосты.
Давайте вспомним, как мы вообще находили мосты,
у кого у нас там был критерий.
Мы находили, во всем графе мы находили, мы запускали
DFS.
У нас в каждой вершинке присваивалось время входа,
ты на тв.
И мы еще для каждой вершины определяли return на тв.
Это, напомню картинку, мы стоим в ве, можем спуститься
куда угодно в под дерево до вершинки w произвольной,
и потом один раз по обратному ребру прыгнуть куда-то
в у.
И нужно было, вот это вот red на тв, указывать самую
высокую вершину, куда мы можем прыгнуть наверх за
один шаг, за один прыжок, спустившись предварительно
куда-то вниз по под дереву.
Ну и соответственно все вот эти вот, мы говорили,
что, точнее, ребро является мостом, значит, это мост,
если только если, так сейчас вспомним условия, видимо
red на тв равно t на тв, так же мы написали.
Вот, хорошо.
Значит, тогда вот здесь, в этой компоненте все ребра,
наоборот, не такие.
Вот эти равенства не выполнены, значит, вот давайте я посмотрю
сначала древесные ребра, те ребра, которые проходят
наш ДФС.
У древесных ребер вот это равенство не выполнено,
раз это не мосты, значит, не удалены, поэтому не равенство,
sorry, равенство не выполнено.
Значит, вы помните, наоборот, red на тв меньше, чем t на тв.
Ну потому что red всегда не больше, чем t на тв, там
был большой минимум, в котором в частности участвует
t на тв от текущей вершины, и еще там какие-то другие
вершины.
Поэтому если здесь не равенство, то точно меньше.
Окей, то есть вот у меня есть такая штука, по всем
ребрам, если я возьму какое-то древесное ребро в t на тв,
я знаю, что return у этой вершинки меньше, чем t на t.
Тогда давайте докажем следующее, что если v2 это древесное
ребро, если v2 это древесное ребро, ну вот в этой компоненте
связанности, в новой компоненте связанности, то v2 лежат,
ну как бы, между ними, короче, они лежат в отношении реберной
связанности.
То есть между ними есть два реберно-непересекающихся
пути.
Есть два реберно-непересекающихся пути.
Так, у меня вопрос к вам, как, если я знаю, что v2 это неудаленное
древесное ребро, и знаю вот это, как найти два реберно-непересекающихся
пути между ними?
Да, это первый путь, а второй?
Ну да, да, да, да.
Давайте запишем.
Ну, я напишу так, я напишу, что первый путь это просто
ребро v2.
Первый путь это просто ребро v2.
А второй путь, значит, ну раз мы знаем, что reta2 меньше,
чем t и n2, это означает следующее, что под дереве t можно куда-то
спуститься, так что потом можно будет прыгнуть за одно
ребро, и потом, соответственно, мы окажемся в вершине, которая
лежит раньше, чем t.
Раньше, чем t.
Ну и, значит, от нее еще можно спуститься до v.
Потому что мы обязательно попадем в какого-то предка,
ну вот в этом нашем дереве, мы пойдем в какую-то вершину,
чем t.
Значит, это либо v, либо еще более ранее, чем v, поэтому
если нужно, мы потом до v спустимся.
Ну и что?
Надо еще сказать, что все вот эти ребра не мосты, чтобы
они существовали в нашем графе.
Ну, понимаешь, что это не мосты.
Для всех вот этих ребер существует такой спуск, который
ведет их выше, поэтому здесь равенство на этих ребрах
не выполняется.
Это обратное ребро, обратное ребро мы не удаляем.
Ну и здесь то же самое.
По дереве всех этих вершин есть прыжок более высоко,
поэтому все эти ребра тоже не мосты.
Значит, все эти ребра сохранятся, и вот вам два неперескающие
пути.
Итого мы доказали следующее, что после удаления мостов
внутри каждой компонентной связанности точно все,
скажем так, все пара вершин, соединенных
с деревесным ребром, они точно в отношении нашим хорошим.
Ну а поскольку дерево DFS оно как бы связывает, оно
позволяет нам обойти все вершины каждой компоненты,
значит, если каждые соседи лежат в отношении, значит,
все вот эти чуваки по транзитивности все в одном отношении
лежат.
Все вершины в каждой компоненте связанности, они точно
лежат в одной и той же компоненте реберной связанности.
Отсюда первый вывод, что каждая компонента связности
в графе g минус мосты точно подмножество одной компоненты
переребрана до связности g.
Потому что любая пара вершин в этой компоненте, соединенная
древесным ребром, лежит в отношении, значит по транзестивности
вся компонента по парам лежит в отношении, поэтому
это все подмножество одного блока, одного класса эквалемности.
Но остается доказать, что если у вас вершины лежат
в разных компонентах связности после удаления мостов,
то они в разных компонентах реб Muk relative связности.
Но это очевидно, если они нет в разных компонентах
связанности после удаления мостов, значит на любом
пути между ними лежит хотя бы один мост.
Поэтому не может существовать двух непресягавших путей
между ними.
Обязательно есть какой-то мост.
Такое, что после его удаления у меня пропадает путь,
значит все эти пути этот мост содержит.
не может быть такого, что вершины из разных компонентов связности попадают в
одну и ту же компоненту реберной связности. Поэтому, ну вот, мы доказали, что каждый
вот этот кружочек это в точности компонента реберной связности. Так, давайте тоже зафиксируем.
Вершины разных компонентов связности
не могут лежать в одной компоненте реберной связности,
так как на пути между ними есть мост. Ну а значит, все они проходят через этот мост.
Так, хорошо. Ну и теперь еще можно заметить, что когда мы сжимаем вот так вот компоненты
реберной связности, то есть находим классы эквивалентности по введенному отношению
эквивалентности, то на самом деле у нас получается такое дерево. И вот этот граф,
который я нарисовал, кружочки большие это компоненты реберной связности, а ребра между
ними это мосты. Вот это вот все мосты. Можно показать, что это дерево, то есть граф без циклов.
Так же, как у нас было в конденсации ориентирована графа, когда мы находили
компоненты сильной связности, мы там выделили компоненты сильной связности и доказали,
что если сжать это все в конденсацию, то есть рассматривать компоненты как отдельные вершины,
то тогда там не будет циклов, будет дак. То же самое здесь. После сжатия
компонент реберной связности будет дерево. Дерево, то есть граф без циклов.
Доказательств такое же от противного. Если есть цикл, то можно найти два пути между нашими
товарищами, между какими-нибудь вершинами, значит они все должны сжать в одном классе эквивалентности.
Представим, что после сжатия есть какой-то цикл вот такой, например. Ну тогда рассмотрим
произвольную вершину вот здесь, произвольную вершину вот здесь. У и В. Что можно тогда сказать?
Так, момент. Давайте для удобства скажем, что это не произвольная вершина, а вот те, куда ведет,
скажем, вот это вот ребро. Вот это вот будет в У, а это скажем в В. Тогда понятно, что есть путь
от У в В, скажем, идущий сюда, используя этот мост. Здесь как-то, ну понятно, раз это компоненты
связанности после удаления мостов, то здесь есть какой-то путь. Ну и соответственно здесь тоже по
мосту можно дойти до В. Второй путь можно сделать такой. Значит мы сначала от У доходим здесь до начала
этого ребра, а потом телепортируемся по мосту. Здесь идем, поскольку компоненты связанности
доходим до начала этого ребра, ну опять здесь все то же самое, доходим до сюда и потом до В. Вот мы
получили два ребра не пересекающихся пути между У и В, хотя предположили, что это, ну это класс
эквивалентности, значит тогда У и В должны были бы лежать в одном и том же классе. Если есть цикл,
то У и В должны лежать в одном классе. Противоречие.
Да, да, действительно можно так, да. Если есть цикл, то все это не мосты, потому что любой из них
можно выбросить, а останется связанность. Согласен. Так, ну хорошо, значит вот мы научились находить
компоненты, да, и поняли, что граф имеет структуру дерева после жатия этих компонентов,
ребер на до связанности. Значит, ну последнее замечание, что работает за линию, конечно, все.
За N плюс M, за число вершин плюс число ребер, ну потому что по сути это опять DFS. Сначала мы
сбустили DFS, чтобы посчитать все реты для всех вершинок. Значит дальше, используя это, мы умеем
определять, является ли ребро мостом или нет, но дальше нужно просто там, скажем, удалить все
мосты и запустить там, по всем вершинам проходиться. Если она еще не посещена запускать DFS,
проходить все, что из нее достижимо, это отдельные компоненты. Тогда суммарно мы обойдем как раз все
вершины ровно по одному разу, каждый ребро ровно по одному разу, поэтому всем точка линейная по размеру
графа. Так, хорошо. Значит, немного альтернативный вариант, как можно было бы находить вот эти
компоненты без явного удаления мостов и дальше прохода по новому графу. Это не то что какая-то
новая идея, но я напишу альтернативный алгоритм. Он будет действовать следующим образом. Давайте мы
заведем очередь вершин, куда будем, значит, куда изначально положим корень нашего дерева,
то есть ту вершину, от которой мы запустили первый самый DFS. Купу шрут. Дальше алгоритм будет
работать следующим образом. Он достает вершину из очереди, пустит какая-то вершинка V, и давайте
мы просто начнем обходить все, что из нее достижимо, используя не мосты. Что такое не мосты? Это мы знаем,
это древесное ребро V2, это мост, если return at 2 меньше, чем return at 2. Поэтому давайте просто
запустим DFS из вот этой вершины, которая посещает только, ну, которая использует только древесные
ребра, у которых return меньше, чем TIN. Значит, обработка вершины из очереди. Обойти все
ребра, обойти все, что достижимо под древесным ребром, под древесным ребром, так, ну, не в эту,
давайте уже назовем X, Y, которые не являются мостами, то есть у которых return от конца
меньше, чем TIN от конца. Это мы, собственно, тогда обойдем вот эту компоненту, но при этом еще,
смотрите, раз мы ее все обойдем, то в частности обойдем те вершины, из которых торчат еще какие-то
мосты. То есть вот, скажем, на этой картинке, если я запускаюсь, если я начинаю обрабатывать эту
вершину, то я здесь все обхожу, обхожу, обхожу, это все не мосты, я их все посещаю, и в частности я
увижу вот эти вот вершинки, из которых торчат мосты. Тогда давайте, когда я увижу такую вершинку,
я прохожусь по этому ребру и добавляю конец этих ребр в очередь. Я вижу такие ребра, это там X1, Y1,
X2, Y2, вижу, что это мосты, значит, не обхожу их в этом DFS, но добавляю их в очередь. То есть это как бы начальные
вершинки, из которых надо будет еще обойти вот эти компоненты. Поэтому я их добавляю в очередь,
и потом из них, пока очередь не пустая, достаю вершинку, все обхожу, опять здесь все обошел,
и увидел вот эти три моста, добавил их, вот эти вот конечные вершинки в очередь. Если видим мост
X, Y, то добавляем Y в очередь, купушь Y. Ну вот, то есть явным образом не нужно даже перестраивать
граф. Вот, например, можно с помощью такого, ну, по сути, по очереди просто все компоненты обходят.
Понятно? Хорошо.
Так, ну тогда мы идем дальше. Рассматриваем новое отношение к эвалентности, вершины эдуфиазности.
Ну, давайте даже не так. Давайте сначала начнем тоже с точки сочленения. Значит,
точка сочленения, сочленение, вот по-английски это cut point в связном графе G. Это такая вершина,
удаление которой делает граф несвязанным. Такая вершина, удаление которой делает граф несвязанным.
Ну, так же, как у нас раньше мы ребра удалили, теперь давайте вершины посмотрим удалить. То есть,
ну, идея такая же. Вот есть у нас какая-то сеть и теперь мы спрашиваем себя, какие не ребра нам
критически важно поддерживать для обеспечения связанности, а вершины. То есть, какие такие
компьютеры, серверы нам важно поддерживать так, чтобы вообще они могли между собой общаться. Если
они посылают друг другу сигналы как-то по цепочке, то вот какие вершины нам нужно поддерживать.
Так, ну, тогда я утверждаю, что используя вот эти вот ретёрны, которые мы посчитали по нашему
DFS для всех вершин, мы сможем сейчас найти критерии того, что вершина является точкой сочленения.
Вершина В является точкой сочленения ТС, если и только если выполнена одна из двух. Первая,
В это корень, то есть та вершина, от которой мы первой запустили DFS, корень нашего дерева,
корень дерева обхода. И при этом у В торчит хотя бы два древесных ребра. Значит, из В исходит хотя
бы два древесных ребра. Ну, это, собственно, значит, что в дереве обхода у корня хотя бы два сына.
Второе условие, когда В не корень, тогда у В, значит, из В должно исходить хотя бы одно
ребро древесное. Значит, В не корень, из В есть древесное ребро в некую вершинку ТУ. Такое,
что return от ТУ больше либо равно 3 над В. То есть, если мы запустим наш обычный DFS,
посчитаем вот эти вот returnы, так же, как мы считали это, когда находили мосты, то достаточно
просто будет для каждой вершины проверить. Ну, либо это корень, тогда у него хотя бы два сына,
либо это не корень, тогда нужно просто пройтись по детям и узнать, есть ли хотя бы одного ребёнка
такое неравенство. Доказательства. Ну, давайте сначала начнём со случая не корня. Пусть В не
корень. Пусть В не корень. Не корень дерева обхода. Тогда как это выглядит? Вот есть В,
раз В это не корень, значит, у него есть какой-то родитель в дереве обхода. Такую стрелочку даже
нарисую. То есть, напоминаю, что DFS мы обычно часто пишем, передавая текущую вершину и её предка.
Вот пусть P это тот самый предок, когда мы запускали наш DFS. Так, я, наверное, доказываю справа-налево.
Ну, или сейчас. Сейчас вместе всё докажем. Вот есть вершина В. Если из неё есть какое-то
древесное ребро исходящее в некое тум, такое, что выполняется то неравенство, то что это значит?
Это значит, что из всего вот этого поддерева я не могу прыгнуть выше, чем В. То есть, вот здесь
неравенство больше или равно. Ну, самое лучшее, самое высокое, это я, возможно, могу прыгнуть В,
но не выше. Не могу прыгнуть в вершины с меньшим тейном. То есть, скажем, до P я точно не допрыгну.
До P я не допрыгну. То есть, как бы я ни старался, вот всё, что достижимо отсюда в поддереве и
прыжок один по обратному ребру не поднимет меня в P. Поэтому, если В удалить, то вот это вот поддерево
станет компонентой связанности отдельной, из которой я не смогу попасть в P, например. Значит,
мы получили, что граф распадается. Если есть древесное ребро ВТУ, такое, что return от ТУ больше
В, то после удаления В нет пути между ТУ и П. Между ТУ и П. Ну, значит, граф несвязный.
Теперь обратно. Пусть у В все дети, наоборот, хорошие. Такие, что у них ред меньше,
чем ТУ меньше, чем ТИ на В. То есть, пусть есть В, это я в обратную сторону доказываю. Пусть есть
П. Значит, это что было? Справа налево, теперь слева направо. Вот есть у него куча детей, и у каждого
return меньше, чем ТИ на В. У них у всех return меньше, чем ТИ на В. Это значит, что из всех вот этих
поддеревьев есть обратное ребро в П или выше. Поскольку return у них меньше, чем В, значит,
я могу подняться выше, чем В. То есть, это либо родитель В, либо еще куда-то выше. Ну, значит,
если это удалю, то у меня, конечно же, граф остается связанным. Я могу из любого поддерева прыгнуть
куда-то туда наверх и потом дойти до П. Из любого поддерева могу прыгнуть куда-то наверх и потом
дойти до П, просто спустившись вниз. Поэтому связанность не нарушается. Все вот эти вот компоненты,
они будут связаны с П. Ну, значит, они связаны между собой, скажем, можно попасть отсюда сюда. То есть,
если я могу отсюда пойти до П и отсюда пойти до П, то, понятно, я могу под П сделать вот такой путь.
Между ними, то есть, тоже есть пути. Значит, если для всех детей return у меньше,
чем 3 над В, то после удаления В все дети связаны с П. Все дети связаны с П, значит, граф связанный.
Вот это случай, когда В не корень. Когда В корень, тут еще проще ситуация. Пусть В корень.
Значит, тут два случая. Либо у него, ну, случая, когда у него 0 детей, значит, что в графе всего одна
вершина. Понятно, что она не является точкой исчления, потому что удаление вершины, ну,
как бы оставляет граф связан. Между любыми двумя вершинами есть путь, потому что вообще вершин нет.
Давайте такое не будем рассматривать. Пусть у В ровно один сын. Пусть у В ровно один сын в дереве обхода.
Что это значит? Вот есть В, есть какое-то ребро из В вту. Такое, что если мы запускаем DFS от
ту, он обходит вообще весь граф. Больше нет вершин, которые не достигнутся из ту. Они все посетятся.
Значит, если В удалю, то у меня все пути сохранятся. Между ними всеми есть пути,
потому что они все достижены из ту. Поэтому В не точка исчления. Если это верно, тогда DFS от ту
посещает все, кроме В. Значит, удаление В не влияет на связанность,
не влияет на связанность. Ну, если хотя бы два сына, значит, между этими под деревьями нет
никаких ребер, поэтому удаление корня оставит нам хотя бы две компоненты, между которыми мы не
сможем телепортироваться. Если у В хотя бы два сына, то картинка такая, что вот есть В. Мы
нашли какого-то сына, запустили от него DFS, обошли все, что возможно, и при этом обошли не весь
граф. Потом нашли какого-то другого сына, запустили от него DFS, обошли опять все возможно. Ну, там
возможно обошли все, возможно есть еще какие-то дети. Но главное, что если мы запустились отсюда,
обошли все, что можно, и не попали куда-то, значит, понятное дело, после удаления В у меня пропадают
пути отсюда-сюда. Значит, ну кратко напишу. Тогда дети не связаны после удаления В. Ну, значит,
тоже мы доказали в обе стороны, что если меньше, чем два ребенка, то это не точка счленения. Если
хотя бы два, то точка счленения. Вопросы? Хорошо. Ну, тогда наш алгоритм, нахождение,
по крайней мере, точек счленения, он работает, в общем-то, так же, как алгоритм поиска мостов,
что мы сначала насчитываем вот эти ретерны, которые по сути какая-то ДП-шка на дереве. Мы
насчитываем все эти ретерны, а дальше для каждой вершины просто проверяем вот это условие. Получается
опять линейный алгоритм. Давайте какой-нибудь пример нарисую. Пример. Как это может выглядеть?
Вот если у нас есть такой граф, то как здесь выглядит точка счленения? Ну вот, понятное
дело, точка счленения, потому что после ее удаления, скажем, отсюда нельзя будет попасть сюда. Вот
точка счленения, потому что после отк mediа нельзя будет попасть отсюда сюда. Вот точка
счленения и вот точка счленения. Так, давайте еще какой-нибудь пример нарисуем, давайте вот
здесь чего-нибудь подвешу еще. Вот так. С жирным выделено точка счленения. Значит, тут можно заметить
Две вещи. Во-первых, что если есть мосты, то понятное дело, оба конца моста являются
фришками сочленения. То есть если удалить ребро, то мы знаем, что если ребро
является мостом, то после его удаления граф не связан.
Поэтому, ну то есть если в графе, сейчас, момент. Еще раз. Да-да-да, вы правы, это я
погорячился. То есть скорее, если это мост, и здесь хотя бы две вершины,
и здесь хотя бы две вершины, выше-ниже этого ребра, то эти обе точки сочленения,
потому что после удаления, скажем, одного из них, я не смогу попасть снизу наверх.
Надо хотя бы, чтобы было по две вершины сверху снизу. Вот есть еще мост, обе его. Да,
давайте тогда, чтобы это проиллюстрировать, можно еще вот здесь добавить. Тогда вот это
точка сочленения, а это нет, хотя это мост. Спасибо. То есть вот это мост, но только это
является точкой сочленения. Но главное, скорее, я хотел показать следующее, что бывают такие
точки, которые не инцидентны мостам, но при этом все равно являются точками сочленения. Вот она,
например. Она соединяет вот этот квадратик с этим треугольником. Понятно, что после ее
удаления у меня граф становится несвязанным, но она никаким мостам не инцидентна. Вот, хорошо.
Значит, такой, так вот это все выглядит. Ну и можно, давайте, наверное, сильно, ну посмотрим.
Значит, можно также определить отношение вершины и додосвязанности, чтобы затем выделять
вершины и додосвязанности. Как раньше мы выделяли, как бы классы Take-equality-ности
по 요�rock волей, то есть максимальные по включение множество такие что все вершины
попарно имеют два пути не перес Bottom по ребрам, то теперь тоже самое и можно сделать по вершинам.
Только чтобы это было отношение эквивалентности, нам придется завести это отношение на ребрах,
а не на вершинах. Потому что вот теперь мы не можем сказать, мы не можем завести отношение на
вершинах, который говорил бы, что между вершинами есть два вершина не пересnee VER-шИна,
ни пересекаешься пути. Потому что это уже будет не отношения эквалентности.
Например, между вот этими вершинками есть 2 ни пересекаешься пути по вершинам.
Вот этот и вот этот. И вот между этими двумя тоже есть. Вот этот и вот этот.
Но по транзестивности мы не можем сказать что отсюда, есть два ни пересекащих пути сюда.
Потому что они все проходят обязательно через точку пос boron.
Поэтому мы не можем такое отношение вести на вершинах. Значит вместо отношения на
вершинах мы ведем отношение на ребрах. И это уже будет хорошее отношение. И тогда по нему все
распадется на следующие компоненты вершины двухсвязанности. Вот эта вот будет одна компонента,
вот эта другая, вот это третья, мост отдельная, вот компонента, вот компонента, вот компонент,
еще мост, вот компонент и вот компонент. То есть они будут пересекаться по вершинам. Пожалуйста,
вот эти вот две пересекаются по вершине, по точке сленения, но не по ребрам. Это как раз
иллюстрация того, что это отношение к вершине по ребрам. Ну, определение. Пусть g неориентированный
граф. Тогда говорим, что два его ребра, давайте связанное добавлю. Ну да, давайте считать, что мы
только со связанными работаем, иначе в каждой компоненте отдельно такой алгоритм можно пускать.
Значит, говорим, что два его ребра вершин надусвязаны, если выполняется одно из двух. Значит,
два ребра e1, e2. Это либо одно и то же ребро, либо они лежат на общем вершине в простом цикле.
На общем, вершин на простом цикле. Вот такое отношение. На что на самом деле это очень похоже на то,
что у нас было про реберную недосвязанность для вершин. Значит, там напомню, когда мы
определяли для вершины реберную недосвязанность, мы говорили, что между вершинами есть два
реберно не пересекающихся пути. Ну, это то же самое означает, что они лежат на каком-то общем
реберно-простом цикле. Потому что если их объединить, то, то есть если два пути склеить, то получится цикл
реберно-простой. Кроме случая, когда они совпадают. Если они совпадают, то вполне возможно цикла нету,
но они все равно в отношении, потому что между ними есть два не пересекающихся пути. Поэтому вот
этот случай, то есть на самом деле, если бы мы формулировали в тех же терминах определение для
реберной недосвязанности вершин, тогда у нас было бы то же самое. Либо две вершины одинаковые,
либо лежат на реберно-простом цикле. Поэтому это определение можно также переформулировать.
Так, ну, сюда вернемся, значит в тверждение без доказательства. Отношение вершинной
двусвязанности, вершинной двусвязанности, это отношение эквивалентности на ребрах.
Отношение эквивалентности на ребрах. Доказ точно так же, значит симметричность и рефлексивность
очевидны, транзитивность точно так же. Есть там два ребра какие-то, E1, E2, E3. Мы берем какой-то
цикл вершинно-простой между E1 и E2, рассматриваем там два куска пути от E2 до E3, пересекаем,
ну, в общем, все то же самое. С поправкой на то, что вместо реберной простоты нужна вершинная
простота. Вот, ну и тогда теперь мы можем профакторизовать, поэтому, отношение эквивалентности,
найти класс эквивалентности, определение класса эквивалентности по отношению вершинной
двусвязанности, значит, называется блоком, ну, то есть, можно сказать, что компонента
реберной двусвязанности, компонента, сори, сори, вершины двусвязанности, компонента вершины
двусвязанности, вот, или блок, короче. По-английски это называется bi-connected component. Вот, ну, будем говорить
блок для краткости. Значит, ну, вот на этом, на этом рисунке кружочками обвезены как раз блоки,
но алгоритм выделения блоков. Алгоритм я опять на очереди напишу, значит, у меня будет очередь
каких-то ребер, я буду обходить все, что возможно, что лежит в том же блоке, и в очередь добавлять те
найденные ребра, которые, как бы, лежат в других компонентах, в других блоках. Значит, смотрите,
да, вот что я еще хотел на том примере проиллюстрировать, что каждая конкретная вершина может,
как бы, мы ее можем пометить точкой сшлиния много раз, а именно, от каждого ребенка, у которого
ретерн больше равен, чем ее t-in. То есть, если у него есть много детей, у которых ретерн больше
реальность, то согласно этой вершины, чем t-in от v, то соответственно эта вершина много раз будет помешана
точкой сшлиния, и это как бы значит, что после ее удаления вот эта будет одна компонента, вот эта
одна компонента, вот эта одна компонент, и так далее. То есть, если, скажем, я здесь не было бы
равенства, то у меня было бы много блоков, которые на v, вот так вот, подвешены. Вот, то есть, главная
мысль, что v может быть пометчена, может как бы, является точкой сшлиния много раз, а именно ровно
ну, будет компонент после удаления, ну там, плюс один
возможно, от того, что есть еще верхняя компонента,
которая отвалится.
Вот, давай тогда сделаем следующее, значит мы заведем
очередь ребер.
Так, ну я напишу edge, q, это очередь вот этих вот как
бы ребер, которые доказывают то, что начальная вершина
этого ребра является точкой шлининия.
Значит, очередь ребер доказывающих, что их начало это точка
шлининия.
Ну, проще говоря, это просто те ребра, которые я нашел,
ну, те древесные ребра, которые я нашел, у которых
ретерн меньше равен, чем тин вот этот вот, ну вот как
раз те ребра, которые показывают, что начало, начало ребра
это точка шлининия.
Тогда, в агритм следующий, мы встаем в корень, проходим
по всем древесным ребрам, смотрим те из них, которые
удовлетворяют тому условию, добавляем их в очередь.
То есть, ну в нашем случае корень не помечен точкой
шлининия, потому что когда мы скажем, ну запускаемся
DFS вот отсюда, мы посетим весь граф, поэтому древесное
ребро отсюда будет только одно, поэтому оно не пометится
как точка шлининия.
Но, тем не менее, это ребро как бы неформально доказывает,
что это точка шлининия.
То есть, если бы там выше кто-то был, то это была бы
точка шлининия.
Значит, первый шаг добавить в очередь на самом деле
просто все древесные ребра, исходящие из корня, все
древесные ребра, исходящие из корня, потому что каждое
такое ребро как бы отдельно само по себе доказывает,
что корень точка шлининия, если бы выше кто-то был.
А вот если там еще кто-то есть, и я знаю, что из всего
этого поделива нельзя прыгнуть выше, чем в корень, то значит
после ее удаления она была бы точкой шлининии.
Ну так, неформально.
Значит, первым делом добавляем в очередь все эти вершины,
сори все ребра.
Ну и дальше делаем похожий трюк, значит у меня есть
ребро, то есть я, по сути, вошел в новый блок, в новую
компоненту вершины десвязности.
Вот давайте, вот это вот ребро, я нашел это первое
ребро новой компоненты вершины десвязности, нового
блока.
Тогда давайте я просто запущу DFS вот отсюда, обходя все
ребра, которые не вот такие, которые не доказывают,
что это точка шлининия.
То есть отсюда, скажем, я вот это вот все обойду,
сложу их в одну и ту же компоненту, но при этом я найду вот
эти вот ребра древесные, которые доказывают, что
текущий вершина точка шлининия, вот это, вот это и вот это.
Тогда я их добавлю в очередь, и потом, ну, с ним мы проделаем
то же самое.
Есть ребро, первое ребро в блоке, я от него создаю
новую компоненту, обхожу все, что возможно в этой
компоненте, скажем, вот здесь все обойду, и дальше
все вновь найденные ребра, доказывающие, что это точка
шлининия, добавлю в очередь.
Так, второе, пока очередь не пустая, очередь не пустая.
Ну, мы по сути делаем, давайте я достать, достать ребро
в эту из очереди.
Значит, дальше запустить что-то типа DFS и STU, и все
ребра, которые не доказывают, что начало ребра это точка
шлининия, отнести к той же компоненте связанности,
что и в эту.
Значит, DFS и STU, все ребра, не доказывающие, т.е. такие
ребра, у которых ред вот здесь вот, меньше, чем тин
вот здесь вот, значит, ред вот здесь, меньше, чем тин
вот здесь.
Это тогда значит, что эта вершина, ну, как бы, не является
точкой шлининия с точки зрения вот этого ребра.
Все такие ребра добавить в тот же блок.
Ну, а все остальные ребра добавить в очередь и их рассматривать
одно с другим, пока очередь не опустеть.
Значит, остальные просмотренные ребра, добавить в очередь
так, ну, на примере давайте вот этого графа опять это
сделаем.
Давайте я жирным выделю еще древесные ребра здесь.
Вот древесное ребро, значит, вот так вот мы пойдем, вот
так вот, ну, туда я уже не пойду.
Вот, жирным выделю древесные ребра.
Значит, на первом шаге я добавляю вот это ребро
в очередь.
Из корня больше нет никаких других исходящих древесных
ребр, я добавляю только его, говорю, что это начало
очередного блока.
Дальше, достаю это ребро из очереди, обхожу все,
что возможно из этой вершины, которая не доказывает, что
текущий вершины точка ш organs.
То есть, из этой вершины есть много исходящих ребер,
древесных, вот эта, вот эта, но у этой не доказывает,
что точка ш organs, потому что это как-бы говорит, что
мы переходим в новую компонент, это тоже говорит, что мы
переходим в новую компонент.
И поэтому мы перейдем только сюда.
Ну, здесь тоже видим обратное ребро, об decidedly, обратные
ребры, понятно, лежат там же, где и текущие вершины,
потому что они еще выше куда-то поднимаются, поэтому
мы вот тем самым найдем одну компоненту вершин до связности, и при этом найдем
еще три ребра, которые мы положили в очередь. Мы положили вот это ребро в очередь,
вот это ребро в очередь, и вот это. Они являются как бы началами новых блоков.
Ну и с ними то же самое. Значит, вот отсюда мы это ребро из очереди достаём, обходим
всё, что возможно, находим целиком новую компоненту вершин до связности, больше
ничего не находим. Дальше обрываем, скажем, вот это ребро. Видим, что отсюда нет ни
одного ребра, которое бы доказывало, что оно не точка шлининия. Поэтому это будет
отдельная компонента с одним ребром, но зато мы найдем, что вот это вот ребро
доказывает, что это точка шлининия, поэтому даваем его в очередь.
Сейчас в очереди вот это ребро и вот это два, ну мы их также не рекурсивно,
а в вайле пока очередь не пустая, обрабатываем. Вот, вопросы?
Смотрите, есть древесное ребро v2, я говорю, что оно в кавычках доказывает, что v это
точка шлининия, ну нет, даже без кавычек, если r2 больше и равно 3 на v. То есть как раз,
что его удаление делает так, что вот это всё под дерево, perdон, после удаления v,
ну да, после удаления v, я не смогу из этого под дерево прыгнуть выше, чем v. Соответственно,
наоборот, оно не доказывает, если это неравенство выполнило в обратную сторону, тогда наоборот,
что я могу по этому ребру пройти и всё равно потом отсюда прыгнуть,
куда-то наверх, значит, якобы, должен продолжить эту компоненту вершины десантности.
Ну, для удобства я бы сказал так, у нас есть первый DFS, который находит таинные ретёрны,
а дальше есть вот этот алгоритм отдельно, который по очереди, ну то есть в очереди все
ребра обрыватывает и запускает ещё отдельный DFS, то есть скорее два DFS,
а первый находит ретёрны, а второй просто всё обходит, ну, не выходящие за границы
текущей компоненты, и все плохие ребра, наоборот, добавляют в очередь.
Ну да, но это несложно, конечно. На самом деле, это не обязательно делать,
потому что если вы не перемешиваете порядок ребер, то у вас как бы, ну и второй алгоритм сам может
понимать, какие ребра древесные, потому что если просто, ну, он обходит ребра в том же порядке,
значит, всегда, когда он пойдёт вниз, это древесное ребро. Так, ну хорошо, вроде мы закончили с этими
компонентами с двусвязностью. Три связанности я уже не умею, не знаю, что это даже, поэтому
возьмём ещё отдельный кусочек про эйлеровые циклы, эйлеровые циклы, эйлеровые пути.
Так, определение. Вершина называется изолированной, если она не инзидента ни одному ребру. Ну или так,
она не является концом ни одного ребра. То есть просто это вот прям точка, подвешенная в пустоте,
а весь граф где-то вот отдельно от неё располагается. Она ни с кем не соединена,
нет ребер никаких ни в неё, ни из неё. Значит, если бы граф был не ориентированный, то мне нужно
было бы просто сказать, что у неё степень равна 0, на степень это число просто ребер,
которые из неё исходят. Число ребер, который её содержит скорее всего конца. Если бы граф был
ориентированный, то мне нужно было бы сказать, что в неё не входит ни одно ребро и не изходит ни
одно ребро. Потому что в ориентированной графе степень не определяется, определяется входная
степень и исходящия степень. Поэтому, значит, это в случае неориентированного графа я говорю,
0, а в случае ориентированной я говорю, что in degree равна
0 и out degree равна 0. То есть ни одно ребро не входит
и ни одно ребро не выходит. Это если граф ориентированных.
Теорема. Пусть g это такой граф, который становится связанным после удаления всех
изолированных вершин. Неориентированный. Пусть g это неориентированный граф, становящийся
связанным после удаления всех изолированных вершин.
Я забыл определить error в цикл, ну ладно. Тогда в g есть error в цикл, то есть такой цикл,
который проходит по каждому ребру ровно один раз. То есть цикл, проходящий по каждому ребру,
ровно один раз. Если и только если, продолжите утверждение теоремы. Все верно. Степень
всех вершин чётная. Замещание в сторону. Смотрите, мы говорим про error в цикл, который посещает все
ребра по одному разу. До этого, когда мы говорили про динамику по маскам, мы рассматривали гамельные
циклы, которые пытались посещать все вершины по одному разу. Эти задачи принципиально разной
сложности, по крайней мере на текущий момент развития алгоритмической науки. Гамельные циклы
мы не умеем находить или проверять существование за какое-то адекватное время. А для error в цикла
есть такой простой критерий, что нужно проверить связанность изолированных и дальше нужно
просто проверить, что все вершины чётной степени. Такое большое различие в сложности
определения существования гамельного и error в циклу. Просто для принятия к сведению, поднимите
пожалуйста руки те, кто видели эту теорему. Давайте мы её докажем, нам всё равно строить алгоритм,
мы построим конструктивное доказательство. В одну сторону очевидно, что если есть error
в циклу, то понятное дело, что степень у всех высшинчётная, потому что что такое error в циклу?
Ну это какая-то такая картинка. Что-то вот такое, вот такое. Цикла, проходящая по всем рёбрам,
надо тогда сказать, что степень всех высшинчётная. То есть есть ещё понятное дело, где-то изолированные,
которые не нужно посещать, потому что они ни с кем не соединены, они там рёбер из них нету,
значит с ними всё хорошо, у них ноль чётная. Ну а дальше понятное дело, что если мы проходим,
значит если мы берём какой-то цикл, можно сказать так вот, мы приходим в вершину, значит нашли
входящее в нее ребро, затем вышли и нашли исходящее, то есть когда мы заходим в вершину и выходим из нее,
мы по сути находим два ребра, которые инцидентны. Значит вот нашли два ребра из нее, здесь тоже
самое, нашли два ребра, которые инцидентны этой вершине и так далее. Ну там на пересечении,
есть ребро входящего и исходящего когда мы шли вот так, есть опять входящего, исходящего когда
шли вот так. Поэтому если мы пустили все ребра, то больше никаких ребр нету, и у каждой вершины
на этом цикле, понятно дело, четные степени, потому что мы в нее зашли, вышли, степень изменили на два каждый раз.
Да, мы можем входить несколько раз, но вот это как раз соответствует этой картинке, что мы можем, скажем,
увеличить на два несколько раз степень какой-то вершины, это ничему не противоречит.
Ну вот на пальцах как-то так. Просто рисуем картинку, понимаем, что в каждую вершину мы как бы...
Ну заход в вершину, это означает увеличение степени на два. Значит всегда все степени четные.
Так, ну вот в обратную сторону, будет похитрее, мы сейчас напишем алгоритм.
Мы считаем, что наш граф связан, давайте сразу там изолированные вершины игнорируем,
пусть наш граф связан и все степени всех решит четные. Тогда хочу написать такую процедуру
нахождения Эйлерова цикла. Эйлер от вершины В делает следующее, пытается проходить все вершины,
все ребра торчащие из В, и давайте для каждого ребра поддерживать оно уже посещено или нет,
помечено оно или нет. Тогда делаем следующее, пока есть хотя бы одно непомеченное ребро,
значит пока из В есть исходящее непомеченное ребро, непомеченное ребро,
значит мы какое-то такое одно ребро конкретно находим, пусть в ВУ такое ребро. Тогда,
во-первых, я хочу поместить его помеченным, помечаем его как использованным, помечаем его
использованным, чтобы не ходить по ребрам два раза, ну и рекурсивно запускаемся от вершинки У.
Вайл кончился, в конце принт В, конец. Академик просто встает в вершину, пытается найти какое-нибудь
исходящее ребро, которое еще не использовано, не помечено, если он его находит, то просто
рекурсивно запускается от, то есть помечается сначала его помеченным, конечно, использованным,
потом запускается рекурсивно от конца этого ребра. Вот и в конце, если Вайл целиком отработал,
то мы печатаем вершину В как очередную вершину нашего цикла. Так, как это работает? Давайте на
конце примера нарисуем. Ну вот что-нибудь такое. Вот, есть некая вершина С, и мы, соответственно,
из мейна запускаем Иль Ротес. Тогда в результате вот этого запуска я утверждаю, что мы обойдем все
ребра ровно по одному разу, и напечатается у нас какой-то Эйлеров цикл. То есть последовательная
вершина, которая, если по ней идти в этом порядке, то получится Эйлеров цикл. Ну давайте промоделируем,
как это работает вот здесь. Значит, сначала мы встаем в Эйлер Ротес, пытаемся идти просто по
ребрам, помечая их использованными, и рекурсивно запускать от конца этого ребра. Например, вот здесь
мы пошли сюда пометили использованным, рекурсивно запустились отсюда, пошли сюда, сюда, сюда,
например, вот так пошли. Идем, идем, идем, идем, идем, идем. В конце запускаем Эйлер Ротес и видим,
что теперь же уже из С нет ни одного не помеченного ребра, они все помечены. Поэтому первое, что мы
сделаем, это напечатаем С. То есть мы нашли вот такой цикл, опять запустились Эйлером от С,
то есть у меня теперь в стеке рекурсии вершинка С два раза лежит. Сначала вот из мейна, и потом
еще когда мы весь цикл обошли, мы ее опять кладем на стек рекурсии, достаем, видим, что нет ни
одного неиспользованного ребра, значит печатаем. Потом откатываемся в рекурсии, понимаем, что у всех
этих вершинок нет ни одного не помеченного ребра исходящего, значит поэтому начало нашего цикла
оно вот такое. Ну давайте я как-нибудь тут обзову их там 1, а 2 и так далее. Пока. Тогда мы их вот так
напечатаем. Рекурсия развернется до этой вершины. Дальше отсюда есть, конечно, какие-то исходящие
ребра не помеченные. Например, мы пойдем вот так. Вот. Запускаемся рекурсивно от нее, от нее,
от нее. Здесь, например, мы пойдем вот сюда. Потом опять запустимся рекурсивно вот от нее и дойдем
вот так. Вот что может быть, например. Тогда что? Тогда я дойду до этой вершины и она будет без
не помеченных исходящих ребр, я ее должен буду напечатать. Потом рекурсия развернется досюда и
досюда. Так, ну давайте, как ее назвать? Давайте я назову у. 1, у, 2. Это будет у. Потом мы развернем
и напечатаем у. 1, у, 2. Потом напечатаем у, потому что из у нет исходящих. Затем мы вспоминаем,
как мы попали в у. Мы попали из нее, проходя по этому циклу вот в ту сторону. Тогда мы их тоже
напечатаем. Там b1, b2, b3, b4. Затем мы опять из рекурсии, из стек рекурсии достанем у. Опять видим,
что из нее нет исходящих, поэтому печатаем у. Ну и потом, значит, наконец нам нужно будет вот
здесь вот так у. 3, у. 4 напечатать. Рекурсия развернется. Потом она развернется до вот этого
x, из которого опять нет исходящих ребр, поэтому мы его печатаем. Ну и наконец вот эту вот последнюю
вершинку t мы тоже напечатаем и дойдем до s, который тоже в конце напечатаем. Вот такой будет Эллеров
цикл. Это пример работы. Тут в странном порядке. Относительно того, в каком порядке мы просматриваем
ребра, это все порядок совсем не такой, в котором мы его просматриваем. Еще раз, я начал вот так вот,
а цикл начинаю вот так вот. Дальше здесь я как-то вот так вот обходил и первое, что напечатал,
так, ну первое, что напечатал, стало у, да, ну то есть потом я как бы в обратную сторону разворачиваю.
Если я прошел вот так вот эту восьмерку, то я как бы с конца начинаю печатать. x, у. 1, у. 2, у. Вот этот
вот хвост я напечатал, потом я как бы в обратную сторону развернул. Ну а получился, как видите,
Эллеров цикл. Давайте я его нарисую. Мы сначала прошли вот так, до x, потом вот так, до у,
потом разворот. Ну в общем, вот эту восьмерку так обошли в каком-то порядке и потом вернулись в
с. Так, вот, ну и хочется сказать, что в общем случае мы нашим Эллером все посетим,
серебра по одному разу, получишь Эллеров цикл. Смотрите, смотрите, вот мы когда эту рекурсию
развернули, мы дошли до х. Значит мы запускаемся рекурсивно отсюда, отсюда, отсюда, отсюда, отсюда,
отсюда, отсюда, отсюда и это будет первая вершина, которую мы увидим, без исходящих
неотноточных ребер. Поэтому ее вот здесь напечатаем. Значит, главная мысль здесь такая, смотрите,
давайте мы рассмотрим вообще первую вершину, которую напечатаем. Понятно, что это с. Почему?
Вот мы запустились айлером от вершинки S и делаем следующее.
Мы просто идем, пока не устанем.
Вот идем, идем, идем, идем, идем, идем.
Каждый раз, заходя в вершину, когда мы заходим в вершину,
мы, по сути, уменьшаем ее степень на один,
потому что мы отмечаем одно из ребер в нее помеченным.
И затем, когда выходим, тоже уменьшаем степень на один,
потому что еще одно ребро нашли.
И поскольку все вершины изначально имеют четную степень,
то единственная вершина, где мы можем завершить этот обход,
это только S.
Что значит, что мы завершаем обход?
Значит, мы больше не видим ни одного исходящего ребра.
Но если я вычитаю по два из каждой вершины,
то значит, я могу продолжить путь,
коль скоро исходная степень была двойка.
То есть я буду так ходить, ходить, ходить, ходить,
и закончиться могу только в S.
Это первая вершина.
То есть эта вершина, когда я из нее вышел,
у нее стала как бы нечетная степень.
И значит, не продолжить путь я смогу только, если приду в нее.
Потому что у всех остальных она всегда четная остается.
Мы вошли-вышли, остается четная степень,
только у нее нечетная.
Значит, у S исходная степень может быть,
то есть она исходно четная,
но когда я выхожу из нее, она становится нечетная,
значит завершить это я буду обязан в ней.
Поэтому мораль следующая,
что когда я что-то печатаю,
это значит, что я нашел какой-то вот такой цикл.
Первая вершинка будет напечатана,
это обязательно S.
Вот оно, S стоит в начале.
Значит, затем моя рекурсия начнет разворачиваться.
Ну и, например, там первые несколько вершин
будут без еще исходящих ребер,
то есть с ней, скажем, были степени 2.
Вот я их так обошел, просто напечатал.
А затем будет вершина с исходящими ребрами.
Ну тогда картинку можно представить следующим образом.
Вот давайте мы этот цикл как бы вычтем
из нашего графа исходного,
тогда степень всех вершин останутся четными.
И я, по сути, запускаю Эйлера от вот этой вершины,
Эйлер от X.
Вот как в этом случае, я дошел до вершины,
из которой есть разветвление,
у меня запускается там Эйлер от X.
При этом все эти ребра уже помечены использованными.
Ну тогда понятное дело, что опять,
если я запускаю тупой просто обход
и пояс какого-то цикла,
то завершиться смогу только в X.
Потому что раз я пометил все вот эти старые ребра использованными,
то эта вершина будет единственной вершиной нечетной степени,
когда я запускаю Эйлер от X.
То есть я вот вышел первое ребро,
и единственный момент, когда я могу закончиться,
не найти исходящих еще,
это только вот здесь,
потому что все остальные четные степени имеют.
Я буду вот так вот обходить наш граф,
всегда буду завершаться в той вершине,
из которой я начал.
То есть если я из вершины вижу какое-то исходящее ребро,
то вот этот Эйлер видит какое-то исходящее ребро.
Тогда он первым делом напечатает,
то есть первая выведенная вершинка будет X.
Это нам гарантирует то,
что когда мы разворачиваем вот эту штуку,
всю рекурсию,
то мы сначала напечатаем вот этот кусок пути,
потом напечатаем X,
здесь как-то этот цикл обойдем,
опять напечатаем X,
и потом продолжим разворачивать нашу рекурсию.
И в каждом минуте времени мы действительно,
то есть соседние вершинки обязательно будут соединили ребром,
потому что,
из этого соображения,
мы получили простую рекурсию
и просто поднялись
между связанными ребром вершинами,
либо вошли в такую более сложную рекурсию,
когда нужно обходить новый цикл,
и по индукции сначала обошли цикл,
потом опять напечатали X,
потому что из X не остался ребер.
Наверное, максимально формально,
что я могу здесь сказать.
Давайте какие-то мысли запишем.
Элеротез
завершается
на вершине S.
То есть это первая выведенная вершина.
Дальше.
Когда мы этот S напечатали,
давайте удалим из графа все использованные ребра.
Удалим мысленно
все использованные ребра.
Значит, опять останется,
что степень всех вершин чётная.
Опять.
Степень всех вершин чётная.
Всех вершин чётная.
То есть, по сути, мы нашли какой-то цикл,
он льёт в стеке рекурсии.
Мы его удаляем,
поочерёдно выводя вот эти вершинки.
Затем можем опять попасть в какую-то вершину,
из которой есть неиспользованные исходящие ребра.
То есть вершина положительная,
доходим до неё,
в стеке рекурсии.
Доходим до X.
Ну и там, скажем, по предположению индукции,
там индукция почту ребер в графе.
Мы удалили какой-то цикл.
Дальше считаем, что у нас
находится корректный
Эйлеров цикл со стартом в X.
То есть мы обходим всё, что у нас есть.
Мы обходим всё, что из него достижимо.
Печатаем по индукции.
Соответственно у меня напечатается
корректный весь цикл.
Ну и дальше я продолжу разворачивать
внешнюю рекурсию, у меня напечатается дальше
продолжение этого пути.
То есть я до сюда дошёл,
отвлёкся на то, чтобы напечатать этот цикл,
и потом опять продолжил печатать цикл,
который я в самом начале нашёл.
Всё, поэтому единственное, что мне нужно,
это что все степени чётные,
для того, чтобы цикл обязательно завершался там же,
вот в общем-то и всё.
Так, ну здесь
не очень формально, понимаю,
но формальнее давайте не будем.
И требовать этого
с вас я тоже не буду.
Ну да, кажется всё.
Ну симпточка тоже понятное дело линейная.
А, сори,
чтобы до начала симпточки
надо сначала алгоритм написать.
То есть мы его написали так,
как бы без кода, я бы сказал,
потому что нам нужно как-то
понимать, когда есть исходящее ребро
непосещённое,
как его находить.
Как находить
непомеченное ребро.
Здесь можно, например,
применить такой трюк.
Давайте мы
заведём структуру ребро,
struct edge.
Значит, ребро ханит
два параметра, откуда оно и куда.
Две вершины, откуда куда.
И, соответственно, ну поскольку
у меня граф не ориентированный,
я, если вижу ребро из У в В,
то я его по сути раздваиваю
и превращаю в ребро из У в В,
из В в У.
Ну и всё, мы так делаем,
когда пускаем, скажем, DFS
по неориентированному графу,
мы каждое вот такое ребро,
если мы видим ребро из У в В,
то мы в список для У добавляем В,
и в список для В добавляем У,
то есть по сути раздаваем ребро всегда.
И дальше давайте сделаем так.
Давайте скажем, что вот эти два ребра
имеют номера, ну скажем,
2k и 2k плюс 1.
То есть если у меня это было ката-ребро
в моём входном файле,
то эти будут ребра номер 2k и 2k плюс 1.
Что у вас первые два ребра,
которые у вас хранятся,
это по сути одно и то же ребро входного графа,
который вы раздвоили.
Дальше, второе и третье тоже одно и то же самое ребро,
ну, противоположные ребра просто.
4-5 противоположные ребра, ну и так далее.
В общем случае, 2k и 2k плюс 1
это два противоположных ребра
из У в В из В У.
И это удобно следующим,
что если E это одно из ребер,
тогда E 41 это другое ребро.
Ну потому что вам нужно просто поменять чётность,
скажем, если вы видите 5-ое ребро,
то, значит, дополнить, ну обратное к нему,
это 4-ое, то есть вам нужно
поменять чётность последнего бита.
Поменять просто последний бит, значит,
из 5-ого сделать 4-ку.
Наоборот, скажем, если вы видите 2-ое ребро,
то вы знаете, что с ним в паре стоит 3-е,
а обратное ребро это 3-е.
Но это как раз отличается от 4-ого ребра.
А обратное ребро это 3-е.
Но это как раз отличается чётностью,
просто нужно поменять чётность последнего бита.
Поэтому дальше всё очень просто.
Мы заводим массив UST
для ребер,
ну скажем, там размеры 2m
для ребер.
И когда мы какое-то ребро
помечаем использованным,
мы помечаем использованное также обратное к нему.
То есть у нас там будет строчка в стиле
равно Ustat exur 1
равно true.
Это помечает использованным
ребро и обратное к нему.
То есть мы не только по е не можем проходить,
но и по обратному тоже.
Поскольку у меня это всё-таки одна сущность,
я не то что его раздвоил и могу ходить туда-обратно
по одному разу,
а могу суммарно по ним пройти ровно один раз.
Мне нужно их оба пометить использованными.
И тогда давайте я,
давайте напишу, значит мы заводим вектор
ptr
для всех
для всех вершинок.
Значит как мы тогда пишем while в
ailer?
ptr это номер
первого неиспользованного ребра.
Первое
неиспользованное ребро.
Значит while какой?
Пока
ptr от v
меньше, чем
gvt.size
То есть скажем, ну gv это у меня список
всех исходящих ребер.
Если есть средний хотя бы одно неиспользованное.
ptr от v это указательное первое не просмотренное ребро.
Значит во-первых, если оно
использовано, надо его скипнуть
и увеличить ptr.
Значит сначала я скажу, что e это
gvt
ptr vt
Если use от e, continue
use от e
ну тогда plus plus ptr от v
и continue.
То есть ptr от v это грубо говоря
кандидат на первое не просмотренное ребро.
Если я вижу, что он посещен,
то gv ptr vt
это то самое ребро, которое мне сейчас хочется посмотреть.
Если оно использовано, если оно помещено
использованным, то я просто перехожу
к следующему и делаю continue, возвращаюсь вот сюда.
Иначе я нашел какое-то ребро,
все до него рассмотрены, это первое
неиспользованное. Ну значит дальше нужно
просто сказать, что там пусть v
u точнее
это
конец ребра
e
пометить его использованным, вместе
с xor1 вот эту строчку сюда вставить.
Что я помечаю это ребро e
использованным, дальше увеличу
ptr, потому что это ребро уже стало использованным
плюс ptr от v.
Ну и дальше eiler от u.
Eiler от u, все.
То есть это просто техническая реализация, вот
той штуки, когда мы выбираем какое-то
неиспользованное ребро. Мы для всех ребер
храним оно использованное или нет, храним первого
кандидата на неиспользованное, и
пока это использовано, будем просто увеличивать.
Увеличивая этот поинтер, пока не дойдем до первого
неиспользованного.
Все, и тогда вот теперь видно, что
асимптотика будет линейная.
Потому что за счет этих поинтеров
для каждой вершины
суммарно мы пройдем ну просто все ребра
слева направо для нее, один раз.
Потому что если есть какой-то
ptrv, то мы просто
либо непосещенный
мы запускаемся рекурсивно и увеличиваем ptr,
либо оно посещенное, и тогда мы его просто скипаем.
Значит суммарно все ребра, все
вершины рассмотрятся по одному разу. Профит.
Все, спасибо за внимание.
