значит давайте краткое содержание предыдущих серий ладно код попробуем не писать на этот раз
или почти не писать так туда дот но так давайте я просто забыл все цвета которые мы все это
рисовали так вот напомните мы бенемиальные деревья эти псевдобенемиальные деревья мы
какими цветами рисовал так пиолетовым хорошо так значит давайте так вот у нас были фиолетовые
деревья у них был фиолетовый next и фиолетовый вот фиолетовый брат которого мы назвали next и
фиолетовый ребенок которого мы назвали child вот то есть это вот все у нас было было было было было
то есть причем там дирея были конечно не совсем сбалансированная но гарантировалось что у каждой
вершины ребенок и брат одинакового ранга так ранг мы чем обозначали а логично да да был у нас
ранг а и был у нас коричневый да так собственно каждое дерево мы оборачивали в голову и
собственно что такое у нас собственно soft hip это вот такое двоичное такие вот такая цепочка
хедов более известная в науке как двусвязанный список мы знали что значит у каждой из них тут
есть какие-то деревья деревья строго возрастающих рангов по крайней мере если верить корню то есть
деревья конечно да если у вас там ранг 8 значит значит там в дереве 256 ключей да мы тут деревья
храним крыши экзотические тут крыши вершин будет не 256 да а сколько там вершин кстати будет
меньше так вот давайте задачка на воспоминание предположим что мы храним вот софт хип в котором
есть 256 ключей ничего не попортилось сколько сколько вершиночек будет соответствующим
дереве мимо мимо да вот 511 конечно но все очень просто потому что это будет потому что это
будет идеальное такое дерево высоты соответственно 8 высоты по ребрам да и количество листов у вас
будет равно там 256 потому что помним да что каждая вершинка просто идет по мэксом до вот уровня
листа ну в идеале конечно вот поэтому получается у вас такое полное двоичное дерево и на нижнем
уровне 256 листов следует на вершинту 256 128 432 и так далее до одного это естественно 511 вот так
ну окей разомнулись как говорится да дальше будет сложнее конечно вот а ну самое главное так
какого цвета какого цвета мы забыли вот да совершенно верно то есть мы не просто тут
еще это мы еще да для каждой вершины храним минимум на суффиксе ну конечно деревья у нас
ну если брать уж все цвета то мы помним что дерево устроен экзотическим образом что ну понятно
что все эти вершины соответствуют как бы одному ключу но на самом деле они все соответствуют
одному какому-то веселому листу ключей то есть мы говорим что все эти ключи у нас ключи у нас
проходят под кодовым названием сики который находится вот здесь сики мы обозначали кажется
рыженьким было дело да так так ну что вот сики тут вот абсолютно такой же сики вот мы
гарантируем шести больше набираем всего того что тут вот в этом списке находится и помним
да что то есть идея у нас то есть идея в том что да мы хотим делать пенмяльную кучу но при
этом некоторые элементы объединять в такие классы эквивалентности и собственно сравнивать
их по соответствующей этим сике вот тоже соответственно да в прошлый раз мы прям
очень подробно с этим да ну как сказать ну можно сказать что ранг это такая мистическая величина
которая хранится в вершине там ну там связь ее хоть какой-то реальностью могла бы быть так то
есть ранг это то есть ранг это фактически если если бы ничего не удаляли ничего не портили то
сколько деревен вот то тогда собственно как то есть какого ранга это было бы как биномиальное
дерево вот можно так сказать вот мой но это ну или сказать что там есть и ранг като значит
соответственно эта вершина составлена из 20 из там два степени как ключей например ну или как-то так
психологически так а что нам надо от него требовать нет просто два но первых просто два
степеника а вторых тут имеется в виду следующее то это мы в прошлый раз говорили о том что каждой
вершине может соответствовать набор ключей которые были когда-то во всех деревьях из которых
это дерево составлено вот то есть как бы да каждый раз когда мы там какой-нибудь ключик удаляем как
говорится до вызываем сифта память остается вот помним у нас оказалось так интересно что у каждой
вершины соответственно ранга к таких вершин как можно по индукции доказать ровно два степеника
вот то есть по аннот память все время остается вот но вот но собственно отсюда и следующее как
минимум и ранг не превосходит логарифма но она самом деле сейчас мы тут то есть по но то есть
из этого уже следует что там все этом а симптоме не происходит логарифма а если еще и тут вот
называется по шамане то симптомика будет еще меньше оказывается ну да ну сейчас будем
вспоминать потому что ну помните какая у нас была идея когда мы пытаемся вот дли вот если
вспоминать дельфин основная его идея была следующим следующее мы лезли собственно в вершину с
минимальным секеем и лезли в ее список достаем из этого списка рандомный элемент и говорим что
вот поздравляю это минимум давайте его дали вот но если выясняется что этот список пустой
то неожиданно но то выясняется но то тогда что мы делаем мы вызываем от этой вершины но
точнее не вызываем си а сначала проверяем сколько детей у этой вершины если выяснилось что меньше
чем ранг пополам то тогда мы объявляем что этой вершины больше нет все оставшиеся эти
деревья объявляются отдельными деревьями и вы их в мэл живаем обратно а если детей достаточно
много то мы пытаемся обойтись своими силами и вызываем функцию сифт вот было дело что ну да
вот вот сегодня мы попробуем выжимать еще круче но давай но давайте для начала вот
посмотрим на код значит как у нас это так значит пишем сифт значит функция соответственно у нас
воидовая так так ну придется нет ну как сказать я могу короче попытаться описать на пальцах
ну естественно с использованием эпсилона без этого никак но вот но давайте так
показала практика полно если мы начнем писать код может легче будет хотя хотя хотя хотя ну
давайте смотреть вот допустим нам передали там как-то она как-то у нас называется там
нодя звездочка допустим рут вот то есть цель такая что я считаю что у меня в кое вот мне
да но корректное дерево я знаю что у меня там в корневом листе ничего нет я хочу
собственно это испорт то есть хочу этот лист удалить и откуда-то из детей собственно там
что-то подковырять но для этого я буду говорить что если подковыривать нечего то есть если
выясняется что значит если выясняется что не там что там было в начале написано рут блабла
next да то есть если соответственно рут next у нас нету но вот 100 вот то соответственно что
мы тогда делаем но вот но мы объявляем что рут сикей тогда у нас там рут сикей равно плюс
бесконечность ну и соответственно выбрасываемся вот ну можно было еще там какой-то лист наверное
составит в общем-то плюс бесконечность это означает что как бы ничего нет ничего не
можем сделать вот так но если выяснилось что next есть и соответственно часть есть то мы
естественно каза то казалось бы мы тут запускаемся тут чуть пониже напишу то есть берем этот рут
next и пытаемся что-то выковыривать уже из него что-то выковыривать это означает вызваться рекурсивно
было дело да вот ну почему пока прям сразу вот да ну ну не совсем так на самом деле когда мы
только начали shift практически с самого начала это и делаем так но теперь пришло время но вот
разобраться да вы тут что-то поковыряли сикей там мог и поменяться скорее всего увеличится
поэтому что мы делаем поэтому мы конечно объявляем что если оказалось что давайте
рыженьким пишем действительно рут чайлд если у чайлда сикей оказался неожиданно меньше чем
рут чайлд ту рут next сикей то мы неожиданно то мы тогда ну ничего неожиданного не делаем то
мы неожиданно объявляем swap swap соответственно от рут чайлда и рут next вот после этого там
и я но вот ну мы естественно теперь должны скопировать в себя новый сикей рут сикей равно
чему теперь да рут next сикей вот вот ну и вот но вопер да еще что не помешает сделать заявить
что если оказалось что он бесконечный могло ж такое оказаться правда да если он оказался
бесконечный потому что ну как бы у нас тут случайно оказалось что два дерева на самом
деле пусты да то что такое вершина плюс бесконечность она просто пустая то есть
просто вот факт того что как бы она бесполезна там пустая я и но соответственно теперь что нам
тогда остается но в общем конечно вот даже наверное фиолетовым напишем что мы удаляем
рут чайлд то сирии все теперь удаляем и ребенка удаляем и брата удаляем в общем
да чего последний остался и тот уже ежелец то есть в общем-то все умерли остался только
рут это называется поэтому и остается только выброситься вот ну да но это по нет ну вот
от последний такой едиальный ребенок остался так что еще могло быть но допустим нам повезло
как бы но да значит допустим нам фантастически повезло и хотя бы брата у нас еще есть могло
и так случиться но вот но могли соответственно так случиться что ребенка у нас вот что ребенка
тем не менее нет belonging только что потому что мы тут посвалом сделали плюс бес蓬astian
конечности посвапали и что мы тогда делаем но естественно но вот вот тогда мы помним
нас была мистическая технология вида что если тут плюс бесконечность а тут лишний брат то
давайте скажем что этого промежуточного брата мы уберем вот ну можно и так сказать да нет ну как
нет у нас нет ну как сказать если ребенок лишний ну как сказать помню зачем нам братья помните
да каждый брат нужен за тем чтобы следить за нашими детьми одному ребенку один брат но кроме
меня конечно у меня свой ребенок есть да но если я понимаю что ребенок за которым я слежу он уже
все то соответственно лишний брат мне тоже не нужен ну я в хорошей структуре чуть-чуть
вот значит поехали что мы тогда делаем начну соответственно пишем так мой ребенок пишем мы
это ребенок моего брата вот нет погодите погодите да мы забыли их написать не всегда
же мы там это где дети и братьев отбираем зачем а вот нет ну тут бы я не сказал что мы это прям
забыли так нет тут не совсем так просто мне кажется это можно как бы в самом конце сделать
на самом деле вот значит смотрите но сейчас вот подумаем потому что я сказал так что пока мы
вот с этим разбираемся пока все как бы нормально вот то есть теперь пишем что если оказалось что
у меня root child во первых child сетей это неожиданно плюс бесконечность то давайте этого не тот только
в этом случае мы вспоминаем шел одна раз то есть как бы да то есть если ребенок есть то
собственно брату удалить не надо все нормально так то пишем что мой ребенок это теперь ребенок
моего брата соответственно как говорится брату это не нравится ничего страшного мы пишем что
теперь тогда наш брат это тоже брат нашего брата вот root next next так еще да но еще да в этом месте
конечно немножко грустно получилось потому что да по-хорошему этого брата еще поделить надо
да и ребенка бы не помешала но как мы уже договорились мы не в этом мы сейчас излишки
обращать внимание на называется там утечку памяти не будем но могли бы тут там пару технических
строчек написать на эту тему так ну и все в общем-то а больше в общем-то здесь ничего не надо делать так
вот теперь как нам правильно заметили как вы так что-то надо с листом сделать
вот здесь но здесь как бы по-хорошему говоря мы должны были написать что-нибудь типа root так
как мы это лист называли так и называли да кейс там так и написать что root но вот ну соответственно
да root next соответственно кейс вот ну и в общем-то на этом все то есть как бы и сифт от обычной
биномиальной кучи в общем-то на этом бы заказ в общем так бы и выглядел примерно но мы там не
будем повторять там все доказательства что там почему там все работает завод единицы кроме
инсерта а если мы как бы нигде не нашли не пустой список а у нас нет смотрите цель сифта вот
обратить внимание мы нигде не проверяем что вот этот список не пустой то есть помните дамы еще
мы этого не реализовывали но имели в виду что вообще удаление может быть из произвольного
места то есть если сказали ударить ключик то значит мы отправляемся в список где лежит этот
ключик и достаем этот элемент то есть теоретически может быть что там все списки пустые или там
почти все но это нас не волнует потому что цель цель сифта не соответственно добиться того чтобы
какой-то список стал не пустым цель сифта удалить пусть список корневой список который оказался
пустым вот собственно и все ну типа того а как там могло стать что он называется пустой
так нет погодите значит мы только что смотрите что мы сейчас только что провели так сейчас
сейчас ну смотрите дело в том что сейчас нету дело дело в том что мы добились того что сикей у
нас все еще равен не бесконечности это означает что наш вот когда если мы до сюда дожили то у
нашего брата ключик тоже значит не пустой а по видимо это означает что там и списочек еще жив
может он и пустой но он жив но если у него нет детей он был бы плюс бесконечности мы бы всеке
это узнали вот обратите внимание да то есть у нас могло быть так что да мы пошли в next и
next оказался плюс бесконечность но ровно за этим у нас вот этот свап и стоит видите то есть как бы
если у меня мой ребенок оказался меньше чем брат то давайте их поменяю местами вот но если
там этот ребенок после этого оказался плюс бесконечность то я его соответственно потом
ликвидирую но если и как бы и ребенок и next оказались плюс бесконечность уж совсем уже то
тогда да соответственно тогда эти дети уже смысла не имеют вот но соответственно нет
поэтому так вот вот в идеале было бы так вот ну типа того но не одну на самом деле видите
она там целое дерево может перекорюшить вообще да вот но теперь но на самом деле есть фишка то
есть здесь мы пользовались тем что мы прям передаем этот список но на самом деле здесь будет
работать по следующему принципу иногда мы будем хотеть сделать это по второму раз то есть на самом
деле вот теперь то есть это вот то есть теперь надо добавить какой-нибудь мистический цвет так
какой мы мистический цвет еще не использовали вот этот вот да это какой желтый да вот так вот
и ну по большому счету делать будем следующее говорить будет следующее то есть мы выполняем
вот эту всю операцию и говорим ну вот значит и по нот и соответственно после этого говорим
если выполнено мистическое условие но вот то тогда мы но тогда мы делаем вот это еще раз
вот то есть примерно выглядеть это будет так то есть for допустим int 0 значит меньше либо
равно 1 но давайте так вот можно писать плюс плюс быть вот примерно вот так вот это мы сделаем
и будем говорить если значит идти равно равно 1 и не выполнено мистическое условие
то ну соответственно тогда брякнуться
то есть в чем идея в некоторых случаях мы говорим то есть как бы смотрите если бы делали
это тупо один раз то действительно в каждом списке был бы не более чем один элемент и все было бы в
порядке это было бы кивалетно тому что все элементы есть просто напротив некоторых стоят флаги на тему
того что они удалены и оказывается были ну то есть знаете это как в классическом фильме да то
есть это называется да да как как мы выяснили что да зачем человек что человек сделать в компании
непонятно потому что он там принимает заказы его секретарша собственно она же относит там другой
кабинетом его начальнику и он там собственно сам с ними что-то делает как говорится мы дамы
покопались в бухгалтерии выяснилось что он был уволен три года назад но все в силу ошибки в
программе он все еще получал зарплату вот так чему это вспомнил но так нет чему-то вспомнил
но не важно так вот нет суть все в общем-то вот так вот что у нас будет здесь мы хотим то есть
иногда чтобы списки сжимая там объединялись как это будет происходить то есть вообще говоря
изначально сифт вызывался для пустого списка с целью его удаления и он удалялся за счет того
что мы тут вот постепенно все вот указатели на него будем переписывать там переписывать на другой
список который мы там откуда-то выкопаем вот но но но это что было но теперь идея такая иногда
мы значит достаем секей значит достаем этот новый список а потом говорим вот в некоторых
мистических слове говорим так знаете что этого мало как говорится брата давай еще то есть он
нам выковы он то есть мы говорим что значит так у тебя же есть список вот прикинься что его
нет скажи что тут пустота и достань мне еще и тогда мы говорим но вот и тогда он достает какой-то
еще список и мы эти списки объединяем то есть в результате получится что вот это вот простая
строчка на самом деле заменится теперь на сильно более мистическую но который я обозначу так
смотрите root next но я так немножко по бетоновски напишу что в тот список который там был
так так ладно значит смотрите вот это мы закрыли значит вместо этого вот вместо этого
зачеркнутого мы напишем примерно следующий вот я тут повыше напишу я напишу root kiss
такие вот значит берем этого брата и говорим так вот ты мне тут достал kiss
пожалуйста таки добавь в этот список пожалуйста и еще то что уже есть у меня
вот root соответственно kiss и после этого говорит так ну окей все значит root соответственно
вот ну вот ну и соответственно root kiss тогда равно root next kiss вот примерно так это должно
выглядеть вот ну да
ну так тут да тут нет тут даже проблема что не только дети но и как бы и родители указывали
на тот же самый список да вот действительно возникает вопрос действительно нет ли этого но
нет но вот но некоторые противоречия есть но тут хочется показать смысл да то есть какой у нас
смысл то есть смысл в том что то есть ну смысл том что можно считать что как бы этого списка
соответственно нету но с целью такой безопасности можно написать что а потому что в этом месте
смысл смотрите то есть так но смотрите то есть дело в том что как бы эту мысль то выразить да
пожалуй может этот код ее недостаточно хорошо выражает наверное но просто нет имеется в виду
смысл смысл такой что next вот давайте ладно вырези попробуем вырезать его таким образом
смотрите то есть давайте скажем что значит нашего списка не существует вот допустим
root соответственно кис точка ну давайте так root kiss равно ну допустим ну допустим условно ну
птр не совсем конечно ну птр потому что видите то есть иногда мы пытаемся с кем-то что-то
объединять то есть может быть правильнее сказать что там да ну то есть чего с что
такое со сной ну можно ну птр можно сайз 0 но я просто хочу избежать это понятие создание
нового списка но вот ну хотя можно конечно это составить давайте вот
ну можно так делать да но вот ну просто смотрите давайте ладно если вы так неделю
назад делали давайте сейчас так сделаем просто минус будет заключаться в том что вот это вот
может быть некорректность потому что мы можем пихнуть оказывается пустой список то есть ну
правда я не уверен правда что у root next на самом деле то есть что вообще у
эстейлевского листа есть понятие extent но вот но допустим вы там сами можете написать функцию
объедать добавь пожалуйста в конец списка еще один список а если вы его а если он пустой то
ничего не добавляйте ну так что ладно эти диагноты эти детали мы пропишем то есть видим да что как
бы то есть root next сейчас подожди сейчас почему пустой нет root next не обязательно пустой нет
нет нет мы эту магию написали ровно из-за того что сифт может запускаться два раза если бы его
запускали один раз то конечно мы тупо присвоили не парились я поэтому тут так и написал
да он только перед форум обязательно это важно потому что мы говорим что в некоторых случаях вот
это вот есть мистическое условие что в некоторых случаях мы говорим что нам мало и отправляемся
брату и говорят пиши еще и он нам но вот он нам выковыривает еще соответственно листов и мы
себе в список добавляем вот в чем глубокий смысл ну ребят что что нет это как это нет
такого такого быть не может у нас каждый элемент находится ровно в одном списке в каждый момент
времени это как вот ровно для того чтобы это не произошло мы ну вот это себе и написали то есть
как вы смотрите видите когда вы вызываете даже второй раз сифт от нул птр а тьфуат от next то
первое что он делает это отказывается от того на что он раньше указывал так и так и во время
первой во время второго что да да это вот да это нужно это важно для того что как бы когда
мы второй раз вызываем сифт мы первый лист потерять не должны если мы написали что вот кейс
мы же нигде после этого вот кейс не обновили то тогда как это нигде ну нет смотрите то так
первый раз она действительно когда вот на самой первой террасы действительно ничего не делает
это эквивалентно вот этой строчки да совершенно верно но на второй раз если вот звезды сойдутся
она как раз что-то делает поэтому ровно из-за этого мы эти строчки вообще писали
да
не будет
как у него в паде у него в подделье но у него в подделье нету ссылок на этот кист потому что
там он там пробегается по всему этому пути там может быть по всему этому пути от него
категорически отказывается но вот ну или но так конечно дани там могут поставаться и не совсем
там отказываться действительно от списка но вообще говоря как бы давайте можем по индукции
проследить, что в итоге сифта, то есть оказывается все в порядке, в том плане, что
каждый путь братьев указывают на свой какой-то список, но нет, но не совсем, как
выясняется, но вообще исходно сифт вызывается, когда корневой список пустой, но
это исходно. Ну да, ну то есть исходный сифт в этом и смысл был, чтобы этот список
полностью исчез и у нас как бы количество списков уменьшилось на один.
У сына не обязательно. Не-не-не, вот в мистическое условие такого не подразумевает как раз.
Нет, мы его не потеряем, вот эта вся вот махинация вот эта вот ровно ради этого и была. Обратите
внимание, после самой первой итерации мы в root keys написали то, что было пополучено из root next.
Теперь, когда, если произошла вторая итерация, то происходит следующее. Жил-был root next, то есть
мы ему сказали сифт, он первое что сделал забыл о том списке, на котором он, который нам только что
передал. То есть вообще забыл, а как следствие там забыл, соответственно их как-то забыл.
Вот, после этого значит происходила какая-то магия-магия-магия, но после этого он там значит
выковырил еще. Потому что по факту он как бы, помните сифт устроен так, что он как бы по всему
пути пробежал и весь путь об этом списке забыл. Вот, вместо этого там выковырилось что-то еще. Вот,
и это что-то еще теперь вот благодаря этому прибавилось к тому, что было попоявилось перед этим.
Next забыл, но у него там потом в итоге что-то появилось в результате сифта. Ну да, вот,
поэтому мы писали, что значит, смотрите вот next, ты и все твои братья указывают на какой-то список,
так вот, значит добавь туда еще вот это. Ну говорит, отлично, а теперь у меня тоже шея у тебя, вот так.
Вот такая вот мистика неожиданная. Вот, ну а теперь самое интересное, да, вот вы с
нетерпением ждете, когда же в этом коде будет Эпсилон, да? Прям можно сказать третьей недели
уже пошла, как мы этого ждем, да. Ну во-первых, да, смотрите, ладно, завуалируем процесс. Во-первых,
у нас будет мистическая константа R, ну как будет, была уже, которая равна плюс два корня на
логарифм 2, на 1 делить на Эпсилон. Да, ну если Эпсилон это заданная константа исходная,
помните, да, ну параметр куча, то по ней мы вычисляем вот это. Понятно, да? И теперь немножко мистики.
Так вот, значит, мы убедились, что мы есть, мы убедились, что next у нас есть, когда мы уже дойдем
до второго сфта, поэтому мистическое условие будет такое. Значит, вот, мистический, итак,
внимание, мистическое условие. Внимание, внимание, да, значит, значит, это условие звучит так,
значит, мистическое условие, во-первых, значит, что, ну чтобы это произошло, нужно, чтобы,
во-первых, так, ноди, так, опять фиолетовый, ноди, стрелочка, кто? Ну вот, ноди, нет, внимание,
ноди ранг должен быть, во-первых, больше, чем R, то есть обратите внимание, второй сифт мы делаем
только для достаточно жирных вершин, то есть для, если ранги, пока ранги маленькие, нам по
барабану. Что? Да, типа root, да, давайте. Значит, причем слили нод, но это, это необходимо,
но недостаточно. Еще нужно выполнить одно из двух маленьких проверочек. Значит, во-первых,
либо этот ранг нечетный, но, типа, мы будем это делать не каждый, там, типа, каждый второй раз.
Ну, если докажете, что он работает, то будет нормально. Нет, ну, я не знаю, забегая вперед,
у меня есть подозрение, что вы замените на каждый четный больше, либо равный двух,
может, у вас даже и сработает, хотя, ну, вот, так вот, ну, тут, давайте, вот, следуем автора,
вот, знаете, тут, как бы, так вот, или, но это еще не все. Если ранг четный, то не беда,
потому что есть еще второй шанс. Скажи, пожалуйста, а у твоего брата? Нет, а если,
еще такой шанс, что если у нашего брата ранг меньше, чем у нас, да, ну, казалось бы,
это же всегда так, да, но не всегда меньше, чем наш ранг минус один. В общем, короче,
если мы удалили, если ребенка там удалили, да, ну, да, то есть у нас, ну, да, вот,
когда мы вот как раз тут брата удаляли вместе, там ребенка вместе с братом удаляли, да, то есть
обнаружилась ситуация, что действительно у нас у брата ранг меньше, чем наш ранг минус один.
То есть, ну, мы помним, да, как это устроено у нас. В идеале, если у меня ранг 9, то это означает,
что вместе со мной у нас в семье 10 братьев. С рангами 9, 8, там, вот это, 9, 8, 7, 6, 5, 4, 3,
2, 1, 0. Вот, поэтому если кто-то из них удален, ну, значит, то есть, как бы, значит какой-то
ребенок соответствующий удален, и по рангам можно даже следить, каких конкретно детей не
хватает. Ну, и братьев соответственно тоже. Вот. Ну, да, ну, мы помним, померло не более чем 5,
потому что на смерти шестого ребенка, нет, не более чем 4, потому что на смерти где-то там
пятого ребенка, по-моему, мы расформируем, мы нашу семью расформировываем, помните, да? То есть,
дети объявляются самостоятельными товарищами, они там создают свою кучу и вмерживаются,
собственно, в исходную. Вот. А. В смысле? Потому что мы... Сейчас.
Потому что, смотрите внимательно. Потому что, смотрите, что произошло на первой
итерации. Значит, во-первых, ребенок существовал, да? Мы обнаружили, после того, как мы посвапались,
мы обнаружили, что ребенок не просто существует, но еще и не бесконечность. Вот. Если он бесконечность,
то, соответственно, мы его там, соответственно... То есть, если он стал бесконечностью,
тогда мы его ликвидируем. А если он не бесконечностью, то мы гарантируем, что уж дети у него, ну, уж как-нибудь
да есть. Сейчас нет свап... Ну, как сказать? Нет. Ну, ранги у нас одинаковые, так что там... Как-то
даже странно. Так, свапнем нет детей. Так. Просто не все представить, как мы делали. Нижнего уровня нет детей.
Сейчас. Так. Так, может, и нету. Так, сейчас.
Так. Нет. Ну, если... Ну, скажем так. Тут понимаете, какая ситуация? Если бы мы посвапали... Сейчас. Нет.
Сейчас. А где мы? Мы где-то тут во внуков ходили, что ли? Ну, в последнем условии мы заменяли на внуков.
Где вы? Где вы? Где вы внука? Видите, я не вижу внука. А, нет, ну, смотрите, если там пустое указатель, значит, мы себя подвесим. Так, а...
То есть, как это здесь ошибок-то точно не будет? А, она... Ну вот. На следующей строке, да. А, ну да, то есть, если там все...
Так, так, так, так, так, так, так.
Сейчас. Ну, у нас, ну, формально у нас проблема в том, что да, вот в этом месте может оказаться, что там мы вот удалили этого брата, брат оказался последним, поэтому у нас эти указатели неожиданно стали подвесить.
А это плохо? Ну, вот мы... Это плохо, это плохо, если мы потребуем вызова вот этого сифта.
Ну, видите, даже нет, вот здесь уже Root Next мы обращаемся и все, это уже плохо.
Не-не-не, здесь-то это неплохо, потому что в этом месте в самом первом Next еще существовал.
Ну, там дальше, там где Root Next, кейс, мы делаем обращение и все.
Э-э-э.
Ну, ты заебать можешь просто.
Ну, в принципе.
Переделить там нашего экстра.
Так, переделить, так, ну, да, так, ну, действительно, да, если выяснилось после этого, что...
Так.
Ну, да.
Ну, да.
Ну, про... Нет, тут, нет, тут, смотрите, тут еще тонкая фишка, что могло быть так еще, что да, мы хотим этого лишнего брата удалить,
но этого лишнего брата еще какой-то собранный список остался,
и нам бы забывать о нем не хотелось, да, поэтому, наверное...
Да, поэтому, наверное, правильнее было бы все-таки, конечно, не сюда идти, а вот сюда.
То есть, как бы со списочком решить проблему, а потом уже лишнего брата удалять.
Так, хорошо, конкретно здесь тогда проблем уже нет, да?
А что вы там поменяли?
Я поменял то, что вот эти две строчки у меня теперь не в конце стоят, а перед ИФО.
Это те, у которых есть право-зеленые.
Чего?
Вот эти, у которых есть право-зеленые, да?
Это голубые.
Тут нет зеленых строчек.
А, конечно.
Так, а вторая проблема, это то, что мы можем вызываться от...
Ну, типа, ну вот.
Ну да.
Нет, ну да, то есть, ну вот.
Ну да, можно, конечно, вот сюда прямо так и вставить, что да.
А, ну можно прямо в мистическое условие, конечно, вставить, что, как говорится,
есть откуда вынимать еще, да?
То есть, типа, ранг наш больше N, и как бы...
Рут next вообще.
И после этого вообще думать.
Ну, потому что, а какой смысл вызывать второй раз root next, если там, извините, если там пусто?
То есть, как бы это ничего не даст.
Еще вопрос вот.
Когда у нас был обычный сифт?
Потому что он гарантировался после сифта.
То есть, мы могли вызвать сифт?
У нас опять мог быть пустой список повышения.
И что бы мы тогда делали?
Я не совсем помню.
Ну, в принципе, вот мы вызывали сифт.
И у нас опять пустой список вышел после сифта.
Что мы в таком случае делали?
А, итак.
Да, мы там прям вот совсем в наглую.
Поэтому я и говорю, цель сифта не сделать так, что пустой список стал не пустым.
Цель сифта ликвидировать пустой список один.
Если там на аванс сцену выйдет другой пустой список, значит удалим и еще.
То есть, да, возможно, у нас было много пустых список, но значит в этот момент пришел армагедон.
То есть, когда он прилетел getmin, мы начинаем эти сифты раз за разом вызывать?
Да, ну типа сифты, да.
Ну да, по модулю того, что помните, что после того, как вы вызвали один раз сифт,
вы тут еще суффикс min, естественно, пересчитали.
Ну, потому что тут могло поменяться.
Ну и так далее, да.
И так далее, да.
Поэтому мы там этот delete min в wild true оборачивали.
То есть wild true говорит, так, отправься, пожалуйста, где у тебя тут минимум.
Так, полезь в его корень.
Так, список пустой.
Нет, ух ты!
Так, доставай оттуда элементы и пошли отсюда.
О, пустой, да, ну вызывает сифт.
Или там, ой, что, слишком мало детей, да.
Ну ладно, расформировай чертям.
Ну, ну да.
Ну да.
Ну, знаете, скажем так, там называется, там техническая задача.
Нет, ну да.
Ну вот delete hat типа там говорят, что возьми этого дерева,
оно теперь существовать не должно, давай возьми там детей,
составь из них кучу и в мер же обратно.
Но там все как бы, но там все предельно чисто,
там никаких мистических эров там нет.
То есть просто сделай как в биномиальной куче и не парься.
Так вот.
Зачем мы это, соответственно, мистическое условие вставили вообще?
Ну а какие у нас, ну вот, нам теперь надо доказать, что,
ну две вещи надо доказать.
Мы делаем больше операции, значит работаем быстрее.
Ну, да, на самом деле более, ну скажем так,
мегапарадоксальная формулировка звучит так,
мы делаем больше объединений листов,
и значит работаем быстрее.
Потому что заметим, да, что,
кажется, что мы стали делать больше сифтов,
поэтому у нас там получается какие-то вот,
вместо нормального линейного сифта у нас там какие-то вот
разветления пошли, да.
Но на самом деле заметим, что каждый раз,
когда мы из какой-то сифт вызывает себя рекурсивно два раза,
где-то в куче погибает один лист.
Помните, да?
То есть, помните, ну вот,
то есть каждый раз, когда с каждым ответвлением
погибает один лист.
Поэтому самому себе ничего страшного в этом нет.
Вот.
И дальше, на самом деле, получается весьма забавно.
Потому что, смотрите, давайте себе мысленно,
то есть, смотрите, мысленно вообразим
себе, вообще, действительно,
вот, количество сифтов.
Вот давайте начнем с симптотики, да.
Ну, цель симптотики доказать, что
суммарно все сифты работают
за
O от R умножить на N.
Ну, то есть, если куча была составлена
из N свежевставленных элементов,
ну, или там как-то с смершенной,
из куч, в которой суммарно было вставлено N элементов,
то я утверждаю, что все сифты в ней
работают суммарно
за O от R умножить
на N элементов.
Ну, когда амортизировано, да, то есть, если мы докажем,
что количество сифты суммарно работают за это,
то мы можем просто добавить
лишнее O от R в каждый инсерт
и тогда считать после этого,
что сифт работает за O от E.
Ну, один лист удалить.
Да, то есть, смотрите, как мы доказывали,
что он как бенвельная куча
работает. Мы говорили следующее,
каждый сифт убивает там ровно один
лист.
Но, как бы, мы говорили, что
мы уже тратим, то есть, когда
мы создаем лист, мы тратим на него,
там, мы кладем на него логарифом
монеточек в самом начале, да.
Поэтому, говорим, что, когда
мы вот этот лист удаляем, а этот сифт,
если вот без развилок, он работает за логарифом,
то мы объявляем, что
м-м-м-м-м-м-м.
Ну, в отличный раз мы, ну,
что мы объявляем,
мы объявляем, что давайте эти логарифом
оплатим этими монеточками, и получается
непосредственно его удаление, тогда будет
стоить 0.
Все остальные операции можно доказать.
Да.
Но там доказательства будет особо
не, собственно, особо не поменяется.
То есть, остальная-то суть та же.
Ну, то есть, возможно, будет иметь смысл
перевспомнить действительно все доказательства,
но давайте вот начнем с сифтов.
Тем более, что там нужно доказать-то две
вещи, вот, там первая из них,
может быть, еще более простая, это почему
у нас вообще Rn.
Вот, потому что,
смотрите, вот это
мистическое условие, заметим,
устроено так, что, ну, смотрите,
да, то есть, ну, во-первых, каждый сифт,
то есть, если вы вызвали сифт,
то он, соответственно,
удаляет, соответственно,
один списочек, да?
Удаляет, удаляет, удаляет.
Но, смотрите, пока он
идет-идет-идет, но заметим, что
то два не позже, чем
через R шагов,
а, скорее всего, и меньше,
он, на самом деле,
сифт разветвится.
То есть, мы вызовемся не только отсюда, но и отсюда,
но заметим, что каждая развилка
уничтожает
еще один список.
Чего?
Ну да.
А что?
Мы сверху идем?
Мы сверху идем.
Чего?
Ну, у нас
мистическое, ну, мистическое условие,
так что, то есть, мы, как бы,
ну, тут два варианта, то есть, ну, на самом деле, даже
не из R, а мы, на самом деле, быстрее,
мы, на самом деле, не более, чем через два шага,
на самом деле, ответвимся.
Да, у нас так,
на самом деле, там дерево будет,
дерево, если его так воображать в себе как дерево,
то оно там будет ответвляться быстро,
и тут вот дальше оно тоже будет
ответвляться быстро, то в какой-то момент мы достигнем
ранка меньше либо равно R, и тогда тут будет
идти цепочка, цепочка, цепочка, цепочка,
которая, ну, и, собственно, и все.
То есть, она будет длинной R, и все-таки уткнемся.
Вот.
То есть,
теперь, значит, анализировать можно так.
То есть,
давайте так, на удаление вот этого списка,
допустим, мы мысленно потратим
вот эти R.
Значит, когда мы вот
ответвились вот тут,
мы на удаление вот этого списка,
ну, тут он тоже, видимо, потратили
вот какие-нибудь вот эти вершины, их тоже от R, да?
Вот. Тут как бы тоже,
ну, тут будет вот, может быть, так,
тут еще тоже могут быть какие-то ответвления, естественно.
Могут быть даже и сразу
ответвления, почему нет.
Но в какой-то момент это заканчивается,
заканчивается, заканчивается, заканчивается,
и так далее.
Вот. То есть, этот список так,
вот, соответственно,
ну, вот потом там еще
какие-то списки, ну и так далее.
То есть, вот на удаление,
скажем, там вот этого списка, к этому списку
мы еще вот этот прицепим, ну и так далее.
Ну то есть смысл такой,
что как бы реальное время работы
сифта, это от количества,
как бы так сказать,
сказать, вершин, то есть это не совсем вершины дерева,
правда?
То есть это как бы я нарисовал дерево вызовов сифтов,
да?
То есть реальное время работы сифта, это конечно от количества
этих вершин, правда?
Ну вот.
Но заметим теперь следующее, что какое количество списков
мы удаляем?
То есть количество списков мы удаляем, оно равно 1
плюс количество вершин у которых тут типа два вызова,
правда?
Ну, утверждение, количество, сколько сифт реально удалит
списков?
Он реально удалит не один список, то есть вот первые
вот эти операции как бы будут удалять этот один список,
но заметим, что если мы тут решили ответвиться, то
в общем-то и из этой вершины, ну вот, то есть как бы список
соответственно удалится, точнее подмёрзется к вот
новому списку, которую мы тут нашли, тут вот в чём
проблема.
Вот.
То есть поэтому каждая развилка, она уменьшает
количество списков на один.
Так, Петя, если мы тут вызвали второй раз список, то даже
если он не пустой, то как бы мы его, то есть смотрите,
когда мы первый раз вызвали сифт, вызвали, да, у нас
здесь оказался какой-то новый список взамен удалённого,
правда?
А теперь мы вызвали сифт второй раз, тут появился
какой-то список другой, да?
Вот.
Но заметим, что произошло, что у нас произошло.
Произошло теперь то, что мы этот список объединяем
с вот этим.
Нет, элементы не могли исчезнуть, тут просто эти
два списка превратились в один список, поэтому количество
списков всё ещё уменьшилось на один.
Ну, элементы, которые мы достали этим сифтом, так
вот, пожалуйста, только не путайте это дерево с
реальным деревом, это вообще другое.
Это дерево рекурсивных сифтов, то есть вот этот
сифт и этот сифт вызывались, вполне вероятно, от одной
и той же вершины на самом деле.
Я нарисовал рекурсивное дерево вызовов сифтов.
Что?
Что?
Чего, ещё раз?
Не, не за каждый, не за каждый, потому что, ну, в
идеале, смотрите, в идеале, если ответвлений не было
вообще, мы как бы прибираемся по вот этой, там, у нас была
цепочка, то есть мы прибирались по, вот, по списку next'ов,
да?
И удаляли один список и делали это за от длины
вот этого списка.
Вот.
Но здесь обнаружилось, что иногда мы вызываемся,
то есть раньше мы говорили, что у нас прямо вот есть
магистральная цепочка вызовов сифтов рекурсивная,
да?
Но выясняется, что в некоторых случаях мы начинаем неожиданно
вызывать сифт второй раз.
Может быть даже от той же вершины, что и первый,
но вызываем второй.
Ну, потому что нам же нужно будет доказать еще второе,
что покорапченых, то есть каждое объединение, то
есть смотрите, каждый раз, когда выполнено мистическое
условие, где-то в мире корраптятся новые элементы.
А помните, что у нас цель не просто, чтобы это работало
быстро, но еще и чтобы количество покорапченных элементов
было не слишком большое.
Да, поэтому мы тут вот, поэтому вот это очень аккуратная
подгонка.
Да, мы это будем доказывать, естественно, что там покорапченных
не сильно много.
Да.
Чего ответляемся?
Так, ну видите, у нас код устроен так, что мы как бы
из одного сифта вызвать себя можем не более чем
два раза.
Ну да, ну то есть, смотрите, нет, видите, там написано,
что если обнаружилось, что на второй итерации
не выполнено мистическое условие, то мы просто брякаемся.
И только после этого мы вызываем второй сифт.
Ну по-любому удаляем, да, безусловно.
Ну нет, потому что когда мы самый-самый первый раз
вызвали сифт, этот список был пустым.
Мы в ином случае сифт исходно просто бы не вызывали, но
это в самом-самом первом случае.
А когда потом мы их вызываем, мы их вызываем вот в этом
месте, когда выполнено мистическое условие, но мы делаем очень
аккуратно.
Мы говорим, что, так, дорогой брат, и все последующие
братья, забудьте о списке, на который вы сейчас указываете.
То есть, вот видите, мы не случайно пишем, забудьте.
Вот, и достаньте мне еще элемент, достаньте мне
еще какой-нибудь список из тех, кто у вас есть.
И после этого то, что вы достанете, объединяется
с тем, что есть уже у нас.
Поэтому ничего не потеряйте.
То есть, обратите внимание, сифт никакие ключи не удаляет.
Он их там может как-то перекладывать в другие списки, в смысле
списки с ними еще как-то объединять.
То есть, на эти списки могут начать ссылаться другие
вершины.
Но не более того, сами по себе элементы в сифте
не удаляются.
То есть, удалением элементов занимаются другие функции.
У нас же ранды next и child строго меньше?
Строго меньше.
И, что самое важное, строго равен.
Ну, ранды next и child равны между собой, в смысле.
И они строго меньше нас, да.
Ну, тогда мы будем, типа, разговариваться два раза,
два раза, а потом какой-то момент перестанет играть
у нас дерево.
Ну, не совсем.
Видите, у нас еще...
А, еще кидают.
Но, видите, во-первых, вот это условие говорит, что
там не просто меньше, а, в смысле, через один меньше.
Так что вызываться будем не просто так.
Так вот, то есть, что тут теперь, значит, если вот
вообразить в себе это, то тогда отсюда получается
мистический факт.
То есть, у нас, если вообразить в себе действительно дерево,
внимание, дерево рекурсивных вызовов сифта, то получится,
что дерево не более чем двоичное.
Вот.
И более того, заметим, что расстояние между развилками
там, вот между развилкой и следующей развилкой,
оно тут, в общем-то, или там ребенком не превосходит
R.
Ну, даже расстояние между развилкой и развилкой
вообще не превосходит двух.
А, ну и в конце тут висит цепочка длины не более
чем R.
Ну ладно, там R плюс один, это мелочи уже.
Вот.
И что?
Ну, потому что у нас, видите, у нас ранг должен быть больше
R, поэтому тут может быть цепочка R, R минус один, R минус два
и так далее до нуля.
Поэтому R плюс один.
Не-не-не.
Кстати, да, R-четная, обратите.
Обратите внимание.
Да.
Но это все мелочи.
То есть, получается вот такой, то есть, такой вот двоичный
нот.
То есть, получается такое двоичное дерево, и получается,
что если, ну вот, то есть, получается, что, значит, мы
сжимаем, то есть, удаляемое количество списков равно,
получается, один плюс количество развилок.
Вот.
Это, соответственно, но заметим, что, но заметим
следующее, что один плюс количество развилок – это
количество листов, правда.
Ну вот.
Но с другой стороны, я утверждаю, что на самом деле в таком
дереве, как несложно там доказать по какой-нибудь
индукции, ну, на том, что это должно быть для вас
уже простое упражнение, что количество вершин в
таком дереве грузивных вызовов O от R.
То есть, O от R на количество листов и есть.
Да, ну хорошо.
Значит, ну простые вещи такие можно видеть, ну,
можно видеть следующим образом.
Что вы идете по дереву снизу вверх, и неожиданно там
у вас есть какие-то листы, по ним цепочки, цепочки,
цепочки, и вдруг какие-то две цепочки объединились
в одну.
Мы сейчас доказываем, что количество перекрестков
– это количество листов.
Нет, мы пытаемся, ну я пытаюсь просто на пальцах показать
простой факт, что там, ну вот, то есть, если у вас
есть, значит, какое-то там двоичное дерево и длины
всех цепочек не более чем R, то количество вершин
в ней – это O от R умножить на количество листов.
Ну вот.
Ну у нас условия так же, то есть у нас тут либо в конце
висит цепочка размера R, либо мы тут где-то выше,
но расстояние между развилкой и развилкой вообще не происходит
даже не просто R, а 2.
Хотя, в общем-то, даже если бы она не происходила R,
нас это бы тоже устраивало.
В общем, с количеством вершин в длине у вас будет R на
количество листов?
Ну да.
Ну O от, конечно.
Да, может быть, умножить на 2, там, например, вот это
все.
А?
А до оптимизации у нас рекурсивные сифты вообще
вот так выглядели.
Там вообще развилок не было, и эта длина была
логорифом.
И нас это устраивало.
А?
Ну да.
Ну как бы, да.
Нет, на каждой, нет.
Ну, во-первых, так, соответственно, для чего, если утверждение
для вот Rn, то для каждой развилки у нас удаляется
лишний список.
То есть, мы удалили количество списков, равное 1 плюс количество,
значит, количество развилок, и потратили на это время
равное 1 плюс количество развилок, умноженное на
R.
Утверждаю я.
Вот.
Ну, потому что R на количество листов мы потратили, да?
А после этого в начале цепочки начинаются там какие-то
вот по количеству листов вершины, которые там начинают
объединяться, причем на расстоянии от себя не более
чем 2.
Почему, наверное, может быть, 12 цепочек больше, чем R1?
Откуда?
Ну, R плюс 1, допустим.
Ну, просто заметим, что если тут была цепочка, 12 цепочек
больше, чем R, значит, тут ранг какой-то как минимум
R плюс 1, а R плюс 1 это уже нечетное число, и у него была бы развилка.
А?
Ну, не R плюс, это О от этого, умножить на 2, если быть
точнее.
Смотрите, самый тупой факт.
Предположим, что, допустим, у вас цепочек нет вообще,
у вас есть только листы и развилки.
Тогда, если в таком дереве у вас L листов, то есть такой
мистический факт, что у вас в дереве не более чем
2L минус 1 вершина.
Ну, там доказательство выглядит в духе, что идем
сверху вниз, там у нас есть листы, и как бы в каждой
развилке как бы два листа как бы объединяются в один,
и у вас как бы на одну вершину цепочку меньше.
Вот.
И как бы у вас, получается, изначально было L, потом
стало 1 и уменьшались не более чем на L минус 1 раз,
то есть уменьшались, получается, не более чем L минус 1 раз,
значит всего 2L минус 1.
Здесь доказательство абсолютно то же самое, только мы говорим,
что когда у нас две цепочки объединяются в одну, нам
приходится этого ждать, уже там это не на одном шаре
прям сразу произойдет, а там не позже, чем через
L шаров это произойдет.
Вот.
Поэтому количество вершин там O от L.
Ну смотри.
Ну жила-была развилка, да?
И теперь поехали.
Так, у этой вершины, почему у нее не произошло, почему
у нее не произошло?
Потому что, во-первых, ну как сказать, смотри, потому
что, да, ну допустим, она четная.
Ну теперь два варианта.
Если тут развилки не произошло, значит эта вершина тоже
четная, да?
Ну есть, ну потому что если бы она была не четная, то
развилка произошла.
Или-или-или, это важно.
Так.
Ну что, еще вопросы?
Почему инвериант?
Что?
Инвериант.
Что инвериант?
Сохраняет.
Ага.
Так, ну то есть наконец перейдем ко второму вопросу, почему
количества покорапченных элементов вот этим вот
сифтом не слишком много?
А может, у нас перерыв, потому что формально пара заканчивается.
Нет.
Так, я уже неоднократно говорил, да, тут есть большая
утечка памяти.
Потому что вот ведь здесь утечка памяти, обратите
внимание, сильно.
Ну, ставить лишние две строчки, то есть там сохранить
вот эти два указателя сюда, значит удалить две вершинки,
потом их там поставить обратно.
Не, а с листом.
С листом?
Ну два варианта, да.
Либо как-то тут аккуратно преследить, либо что самое
надежное, это просто шарит ПТР.
Ставить он тогда автоматически это будет.
Шарит ПТР.
Ой, боже мой.
Сколько вам еще предстоит на C++ узнать?
Ну, просто есть такая, что такие штука шарит ПТР.
Она просто имеет в виду следующее, что это пистическая
структура, которая указывает на какой-то объект и владеет
как бы и, потому что гарантирует, что в этот объект можно
попасть только через этот указатель и через какие-то
его копии.
Вот.
Причем, значит, зачем-то нужно.
Нужно следующее, что вы этот объект не удаляете,
гарантирую, что как только там вызовется деструктура
самого последнего указателя, указывающего на этот
объект, значит в этот момент объект будет удален.
То есть об этом заботится сам шарит ПТР, и вы об этом
не думаете.
Ну это же долго будет.
Почему?
Ну, в смысле, это просто гарантичка, декция, практика.
Нет, а симпатически это вообще ни на что не влияет.
Ну понятно.
Вот.
Ну вы понимаете, что это там очень важно, да?
Ну, там есть количество этих штук, ну то есть там понятно
есть какие-то реализации, но это не следует.
Ну там такая есть, конечно, накруточка, но как бы
эта накруточка дает вам просто безопасность.
Поэтому ничего страшного.
То есть нет, ну как сказать, если уж говорить о предельной
эффективности, есть симпатической, то это называется там
в 0.5 такого вообще, там обычно апдериты можно не
заворачиваться.
Ну там.
Ну да.
Да и Нью можно один раз вызвать там 10 седьмой
аластировать и потом использовать.
Да там чаще выгода уже бывает создать большой буфер
вместо Нью писать, а там дай мне какой-нибудь 57
лучей какой-то.
Ну да.
Да нет, а зачем?
А зачем можно даже не без Нью, а просто ее глобально
объявить и все.
Просто тогда ты собственно гарантами не будешь
тратить на выделение этой памяти.
Ну да, но просто так ты это тратишь уже после начала
кода, а так ты при компиляции это уже сделал.
Тут еще такой лайфхак есть.
Так, ну что, ладно, давайте попробуем это зафиналить
наконец.
А то когда-нибудь это должно закончиться, наверное,
да?
Так, давай.
У нас сифт работает за 1, потому что мы на каждый
список положили R монеты.
Да, мы на каждый список положили R монеток.
И соответственно, когда мы удаляем списки вот с
помощью такого сифта, мы этими монетками получается
эти операции оплачиваем, да?
Собственно, поэтому получается учетная стоимость сифта
0, а учетная стоимость инсорта от этого не поменялась.
Почему?
Потому что там...
Ну так, учетная стоимость инсорта, как раз там вот
мы вместо логарифма монеток на ее удаление кладем вот
эти вот R монеток на удаление.
Мы еще там какие-то монетки клали на какие-то там объединения
или что-то еще, но этих монеток было вот единицы.
Вот.
То есть поэтому теперь...
Обратите внимание, теперь учетная стоимость инсорта
стала от R, ну то есть от лога 1 делить на эпсилон, как
заказывали.
Так, так, еще вопросы по...
Вызывается свежепроводенному есть?
Ну вот, ну теперь попробуем финалочку.
Да, то есть сжимать, конечно, можно было до упора, можно
было всегда вызывать сифт до тех пор, пока вершины
не удалится там, я не знаю, или пока этот список не
пустой, там что-нибудь еще в этом роде.
Но наша цель была такая, нам еще нужно, чтобы покорапченных
элементов, напоминаю, было поменьше.
А теперь вот давайте думать.
Сколько у нас вообще может быть покорапченных элементов?
Ну, во-первых, заметим, что...
Ну, обычно заметим следующее, что если в списке находится
один элемент...
Ну, значит, так вот.
Смотрите, вот в самом начале у вершины был создан список
и в нем находится какой-то элемент.
Ну, во-первых, давайте так, начнем с того, что...
То есть давайте так, в каких списках у нас может находиться
более чем один элемент?
Так, это вопрос.
Еще раз.
Ну, которые получились после второго прохождения в сифте.
Ну вот, а с точки зрения, например, рангов.
Какой вопрос еще?
Ну, в каких списках вообще находятся покорапченные элементы?
Ну, на самом деле, ну, как минимум...
Ну, да, размер как минимум два, это понятно, да.
Но и заметим следующее, что...
Ну, утверждение такое, что если элемент, вот сам по себе
элемент имеет ранг r или меньше, то он не покораптится.
То есть если этот элемент там перейдет...
Ну, то есть видим, да, что один и тот же ck, конечно, находится
там в разных рангах, да, но давайте у каждого элемента
считать, что у него ранг вот равен вот своей вершинке.
Вот.
Тут можно заметить действительно мистическую штуку.
То есть можно заметить, что пока элемент имеет ранг r,
он не покораптится никогда.
Есть такое ощущение, да?
Да, меньше либо равно r.
Ну, просто потому что мы можем заметить, что если мы
приходим случайно в силу каких-то разветвленных там
либо shift вызываем от маленького дерева, да, то есть заметим,
да, что простое наблюдение.
Если мы вызываем shift от дерева ранга r или меньше,
то делается абсолютно честный shift без всяких нижних
размилок, правда?
Логично, да?
И там ничего не портится, обратите внимание, потому
что мы заметим, что сама по себе порча происходит
только в тот момент, когда мы начинаем какие-то
листы сливать, правда?
То есть если мы объединяем 2 листа, вот тогда у нас
действительно все действительно портится.
А пока у нас никаких слияния нет, ничего не портится.
Причем более того заметим, что сама по себе порча
происходит именно в момент слияния, то есть когда
называем второй сифт, то получается, что там видимо
можно сказать, что все элементы, которые оказались в листе,
которые мы получили в результате этого сифта, он окажется
соответственно, то есть все эти элементы будут испорчены.
Ну может быть кроме одного.
И при этом, правда, все, которые были на первом рекурсивном
вызове получены, они тоже испорчены, потому что лист
объединился.
То есть может там есть кто-то один неиспорченный, но на
самом деле его можно уже не считать.
Так что вот такая вот тут интересность получилась.
И теперь, соответственно, давайте думать, значит кто
же у нас тут испорчен будет теперь.
Ну давайте смотреть.
Так, где бы нам тут?
Ну давайте вот условия оставим.
Значит, на самом деле ключевое утверждение такое.
В статье оно называется там Лемма 5.1.
Ну 5, наверное, мы уж так не будем.
Итак, значит, мистическая лемма, формулируется она
так.
Размер вот этого вот листа, так сказать, допустим,
у вершины В кииз не превосходит.
Ну я так пишу, максимума из единицы и весьма мистической
величины.
Смотрите.
Ну вот, если бы это было все, да?
Ну вот.
Но на самом деле там будет написано примерно следующее.
Там будет написано 2 в степени V rank пополам минус R пополам.
Это я сказал примерно.
Да.
Да, то есть сколько вообще может быть?
Ну понятно, что вот обратите, почему я максимум пишу?
То есть если у нас рамк не превосходит R, то как бы
мы заявляем, что размер списка никогда не превосходит
один.
Но это, в общем-то, достаточно очевидно, потому что, как
мы уже сказали, если мы вызываем сифт от вершины
ранга R, то там, собственно, ничего не происходит.
То есть там списки не объединяются.
Вот.
Ну вот, точно, значит, точно.
А, ну вот, нет, я почти угадал.
Смотрите.
Еще вот так надо.
О.
Так.
Вот.
Вот.
Но давайте думать, ну как всегда, тут 2 вопроса.
Откуда такое утверждение берется и чем оно нам помогает?
Но теперь давайте думать, как же мы можем такое утверждение
доказать?
Как же мы его докажем?
Ну, естественно.
Ну а как еще, собственно, давайте смотреть по индуции.
Ну, на уровне базы все понятно, потому что там в самых-самых
началах у каждой, ну вот, там допустим, у каждой вершины
действительно там размер списка равен один, и это
нас устраивает.
Вот.
То есть когда у нас начинаются проблемы, ну когда два дерева
объединяются, списки от этого не объединяются, но
один из этих, у одного из этих списков ранг повышается.
А, да, подчеркиваю, да, что я тут написал V-кис, но
на самом деле имеется в виду, конечно, я рассматриваю
верхнюю вершину из списка.
Потому что, как бы, можно так сказать, что давайте
рассмотрим там, допустим, любую вершину V любого ранга,
дойдем по, значит, до конца списка до нуля, да, по
братьям, и тогда скажем, что, оказывается, размер
списка там не может, не больше, чем один, потому что
это, на самом деле, у этого вот последнего брата тоже
кис.
Но здесь имеется в виду, что вот это вот V – это верхний
из братьев.
Будь здоров.
Вот.
Ну вот.
И теперь, соответственно, думаем.
То есть можно говорить даже вот, удобно мыслить даже
что у каждого списка есть ранг.
Ну, потому что на каждый список указывает обычно
такая указатель из цепочки братьев.
Вот нам жутко интересно, собственно, ранг самого верхнего
из этих братьев.
Ну, логичь, помните, да?
Ну, братья – это в принципе у нас, как бы, в биномиальной
куче в первой версии вообще было, что у нас нет никаких
братьев, а просто одна вершина контролирует, там,
называется, там, некоторое количество детей.
Это равное в худшем случае, собственно, этому рангу.
Вот.
Ну, а теперь давайте смотреть.
Как же это у нас будет происходить?
Вот.
Ну, проблемы, ну, как сказать?
Ну, основные проблемы возникают, конечно, в сифте.
Потому что там в других местах, ну, там, как бы,
бывает иногда, что во всех местах, кроме сифта, количество
элементов в списках не увеличивается.
Правда?
Зато увеличивается иногда, зато может иногда увеличиваться
ранг списка.
Ну, например, когда два дерева вы объединяете, то
у одного из списков ранг получается увеличивается.
Да, но это, как бы, называется, только ослабляет ограничение.
Вот.
То есть проблемы у нас начинаются только когда у нас,
только в сифте.
Ну, давайте смотреть, что происходит в сифте.
Ну, если мы вот пришли в вершину V и говорим, ну,
вот, значит, пришли мы в вершину V и говорим, так,
у нас тут сейчас пустой список, мы хотим его проигнорировать
и сделать сифт.
Вот.
Ну, тогда, можно сказать, по предположению индукции,
можно сказать, что, то есть, мы вот вызываем сифт
от Next и получаем что-то еще.
Вот.
И получаем список.
Причем, скорее по-видимому, получаем, ну, вот, причем,
видимо, получаем список размера не более, чем вот
такого.
Понимаете, да?
Потому что когда мы его получаем, этот список еще
ранга вот этого VNext.
Ну, и тогда получается, если этот сифт вызов был один,
то тогда просто этот список повышает в себе ранг и
ограничение от этого, собственно, только хуже не
становится.
Вот, понятная идея, да?
То есть, самое интересное происходит, только если у
нас получилось два объединения.
Но что тогда?
Вот.
Ну, давайте подумаем.
Что у нас тогда?
То есть, как у нас тогда такое могло произойти?
Вот.
И откуда тут берется именно округление?
А вот откуда.
Смотрите.
Вот, допустим, вы вызвали, действительно, сифт от
V, да?
Сифт от VNext.
То есть, давайте скажем, что ранг от V, то есть, ранг
от V равно чему?
Какую букву вы предсчитаете в этом месте?
T.
Давайте.
Буква ыть.
Не, ну можно было, конечно, букву ына.
О господи.
О господи.
Ять, о господи.
Ну, давайте, хорошо.
Итак, вот пусть ранг от V равно до ять.
Ну вот.
Значит, смотрите.
Тогда обнаруживается следующее.
Значит, мы вызвали сифт от этой штуки.
А потом вызвали его второй раз.
Ну, во-первых, ну, соответственно, смотрите, вот вызвались
два раза.
Ну, первый раз тут, соответственно, ранг не превосходит ять
минус один.
Поэтому получается, что в разверс списка у нас уже
отсюда получается что-то не более чем два в степени
округлённая вверх.
Значит, значит, ять минус один пополам округлённая
вверх.
Минус R пополам.
Размер списка, который образовался в nxt по результатам первого
сифта.
А к одному можем пользоваться предположение, что в этом
случае мы используемся такой тонкостью, что в тот
момент, когда мы вызываем сифт и работаем с этим списком,
этот список имеет ранг вот такой вот.
Ну, не более чем такой.
Вот.
Итак, теперь он повышает ранг.
Ну, повышает ранг, но вызвался второй сифт.
Теперь давайте думать, по каким причинам мы неожиданно
вызвали, значит, по каким, ну, по каким причинам мы
вызвали второй, ну, второй, короче, да, второй сифт.
Ну, тут два варианта.
Значит, мы должны рассмотреть два варианта.
То есть тут первый вариант.
Ну, то есть в каком случае?
Ну, понятно, что тут ранг больше R, очевидно, и у нас
два варианта.
Первый вариант простой.
Если этот ядь, процент два равно один.
Ну, тогда это на самом деле для нас достаточно приятно,
потому что мы замечаем, что вот это вот округление
тут можно снять.
Да?
То есть если у нас вот, то есть произошло, то тогда
вот это вот, то есть давайте рассмотрим случай, когда
у нас ядь не делится на два.
Тогда у нас получается, то есть первая сифта мы получили
что-то не более чем два в степени ядь минус один
пополам.
Ну, потому что ядь минус один чётное число.
Вот.
А второй раз мы получили не более чем, а в общем-то
столько же.
Минус один пополам.
Минус R пополам.
И теперь, то есть получается, что в списке вот вершины
V ранга ядь окажется сумма не более чем вот сумма.
А в сумме это у нас сколько?
Ну да, то есть это можно два в степени один плюс.
Значит этот ядь минус один пополам.
Минус R пополам, да.
Вот.
Что это такое?
Это равно два в степени ядь плюс один пополам,
минус R пополам.
Вот.
Так, что-то не получается, да?
Мы рассматриваем случаи, когда мы звали C второй раз
по причине того, что ядь не делится на два.
А почему?
А, ну да.
Да, то есть да, действительно.
Заметим, да, мистическую штуку, что это в точности
два в степени ядь пополам и кругленный вверх, да.
Вот.
Да, просто так получилось, да.
Потому что он вот нечетный.
Ну, формула откровенно тут немножко подогнана, но вот так, да.
Хорошо, то есть если ядь равно один, то вот действительно
лемма выполнилась.
Если оно нечетное, да.
Ядь процент два равно один, конечно.
Так.
Ну, теперь думаем.
А теперь давайте себе представим.
Сейчас, а если мы вот в этот момент вдруг возьмем
и уберем то, что у нас...
Мы же все-таки об этом думали.
То есть это просто оптимизация какая-то.
Ну, может быть, да.
Но сейчас...
Нет, ну надо смотреть.
Кажется, да.
Сейчас все это верно.
Да, это верно будет.
Нет, если...
Смотрите.
Нет, просто смотрите.
Если мы будем...
Если мы будем всегда требовать, чтобы...
То есть мы будем всегда требовать, чтобы...
Ну, тогда...
Смотри.
Нет, смотри.
Ну, да.
У тебя могут быть только четные.
У нас же было требование, что там каждые два раза
разветвление обязательно произойдет.
А так у тебя даже не каждые два раза,
не каждый э-раз не получится и так далее.
Вот.
Так что...
Так это называется.
Автор думал, условия подгонял.
Соответственно.
Ну, впрочем, по предыдущей структуре тоже видно,
что автор явно думал.
Причем сильно.
А давайте здесь минус 1,24 поставим?
Так.
Значит, смотрите.
Хорошо.
Это случай рассмотрения.
Давайте рассмотрим второй случай.
Второй случай, когда неожиданно, давайте,
ядь на два делится.
Но второй shift, тем не менее, вызван был.
Что это значит?
Ну, во-первых, это означает, что здесь вот это
y-1 пополам, это то же самое, что...
Что просто что это равно?
Это ядь пополам минус 1, минус r пополам.
Если этот ядь...
Что это?
Ну вот.
А, хотя...
Нет, ядь минус 1 пополам...
А, наврал, наврал.
Просто иди, ничего.
Вот так.
Вот.
Мы же вверх окуляем, да?
Да.
А что у нас здесь?
Два в степени...
Ну, тут, видите, я...
Что снизу?
Два в степени, ядь пополам.
Ну, просто смотрите, если там, допустим, ядь был равен,
я не знаю, 28.
28 минус 1 пополам, округленная верх.
Это то же самое, что 28 пополам просто.
Вот.
Так.
Правда, что-то меня тут, конечно, начинает смущать.
Там же, когда ранг, вот, брата, он должен быть меньше, чем...
Чего?
Чего?
Еще раз.
Если у нас четный ранг, то, значит, выполнилось второе условие.
Да.
Да, это значит, что у нас хотя бы над 2 меньше.
Да.
Ага.
Нет.
Ну, тут, вот, смотрите, вот.
Ну, тут, смотрите, какая подлянка.
Подлянка заключается в том, что в первом, скажем так,
в первом севте это условие никто не проверял.
То есть, правда, вот, именно проблема в том, что в первом,
да, в первом севте это условие никто не проверял.
Поэтому ограничиваем как можем, но вообще, конечно,
да, выглядит странно, как будто, потому что мы уже
ограничение получили, а мы еще оттуда будем что-то
выковыривать.
То есть, да, можно сразу выковырить.
На самом деле, это действительно тут написать, что здесь
после второго севта у нас тут будет как минимум
яд минус 2.
То есть, яд минус 2 пополам, а это без округления,
обратите внимание, потому что, вот.
То есть, получается, просто, вот, минус 1.
Так.
Ну, а что ж тогда делать?
Да.
То есть, видим, что возникают какие-то вот странненькие
проблемки.
Вот.
Да, вот, в идеале, конечно, да.
Хочется сказать, что, а может быть, тут все-таки
округление вниз?
Вот, если округление вниз, то конкретно тут доказательство
сойдется, правда?
Так.
А что там было?
Вот.
Ну, к автору, давайте сами придумаем.
Хорошо.
Вот.
Значит, смотрите, давайте вспомним, что у нас
вить минус 1 было.
Ну, вить минус 1 было, тогда обратите внимание, тут
был бы просто, то есть, яд минус 1 пополам, тут куда
не округляй, получится 2 в степени
вить минус 1 пополам минус r пополам.
И это надо было еще умножить на 2,
то есть, прибавить 1.
Прибавляем 1,
это равно 2 в степени
яд плюс 1
пополам минус r пополам.
Так.
Нет, ну,
минус 1 пополам плюс 1, это то же самое,
что здесь плюс 1.
Ну да, я давно, да.
Но я вот этот плюс 1 отсюда и взял.
Ну да,
я оговариваюсь.
Ну что, мы тут 2 буквы
не вводили же. Вот.
Так.
Ну вот, это вот яд плюс 1, значит,
пополам.
Так яд нечетный.
А, нет.
А, ну да.
Поэтому да, что-то тут вот,
тогда в эту сторону округление
как-то почему-то не работает. Странно.
Так.
Ну-ка интрига.
Чего мы не использовали?
Нет, второе условие
мы пишем, когда
если идти равно 0,
тогда вот это условие выполнено.
А так как бы его получается
негде использовать. Вот чем проблема.
Чего-чего-чего-чего?
Ну, нет.
Вот мы и чешемся, где
мы его где-то вот тут должны использовать
и как бы тут по сумме должно адекватно сойтись.
Ну вот.
Здесь мы его использовали то, что тут
да.
Ну, что тут как бы
идь минус два пополам. Вот мы как-то так
это использовали.
Ну вот, да. Так, странно.
Почему-то да,
странно.
Нет, должно сходиться.
Прям всю, да.
Не, так
настолько на халяву
не получится.
Ага.
Так.
У нас же уменьшили вершины, но ранг меньше, ищет а, ну раньше вот ранг у нашей вершины
ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше
вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше,
ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а,
ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг
а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот ранг меньше, ищет а, ну раньше вот
имеется ввиду, что вот это вот на самом деле делается не, собственно не в цикле
смотрите
почему без этого
но без этого у нас лемма не работает
последний да вот идея такая последний иф не в цикле да но потому что ну вот
но вот нет а собственно к чему нас привело вот смотрите но тут идея такая то
смотрите допустим с допустим после сифта неожиданно выяснилось что у нас теперь
ребенок плюс бесконечность вот говорим вот хорошо вот нам надо его вот нам прям
сейчас его приспичило удалять или вот зачем нам его сейчас удалять вот почему
почему бы нам не вызвать второй сифт что-то сначала вызвать второй сифт а потом уже
радоваться не могли он плюс бесконечность ну да то есть наоборот может выяснить
давайте да то есть допустим брата по выковыриваем брат там еще какой-то тоже
ребенок же есть ну вот и как бы вызвать то есть в общем таки что от этого поменялось
казалось бы ничего ну то есть по крайней мере почему там
алгоритм от этого должен перестать работать непонятно то есть разница будет
то что ну то есть скажем так есть есть шанс что у нас будет то есть вот у вас
был вопрос да откуда у нас появляются вершины с плюс бесконечностью да вот
возможно вот по этой причине у нас есть лишние вершины с плюс бесконечностью то есть на самом
деле кто-то говорит я вершина ранга 28 у меня еще есть 22 ребенка вот да на самом деле не
бесконечных всего два но там все остальные плюс бесконечность за этот счет меня пока еще не
удаляют то есть как бы ревизия еще мертвые души не нашла это называется вот то есть вот
примерно так мне это предлагается видимо делать вот и поэтому получается следующий чит смотрите
то есть то есть зачем мы это сделали а вот зачем дело в том что то есть дело в том что тогда
гарантия что это нам гарантирует что сифт вызывается всегда от то есть эти вот при развилке
он вызывается от абсолютно одинаковых рангов ну ну да ну то же смотрите когда вы пришли в
вершину у нее есть брат и ребенок они одинаковых рангов но вот заметим что сифт от вершины саму
вершину не меняет и не удаляет он может сделать плюс бесконечностью до сам он ее не удалит вот
и тогда получается что да то есть и может показаться даже что вы едва ли нет не от одной
той же вершины сифт вообще вызываете нет это конечно не так потому что перед вторым сифтом
они там с ребенком могли и посвапаться случайно вот но ранги у них одни и те же и тогда но вот и
тогда вот с этим округлением тогда все прокатывает в смысле нет но там просто нам вот при такой
формулировке леммы нам очень жестко надо что там если ранг вершины четный то тогда у обоих
запусков сифта он уменьшился хотя бы на два то есть просто вот просто тогда вот действительно
если мы тут пишем о круглении в ве как вот это йать минус 2 пополам тогда тут пишем это тут пишем
на то же inform но тут округления уже даже убрал потому что я от минус два вот это тоже что твое число
но вот и тогда у нас получается что-то типа два в степени я от пополам минус 2 минус
2 пополам ой паром не минус 2 здесь вот пополам тут limits пополам 9 плюс одинHiclapping
Но этот плюс один благополучно с этой минус два убивается, и получается два в степени ядь пополам минус r пополам.
А это то же самое, что ядь пополам округлённая вверх. В общем, всё чётенько.
А?
Просто как мы решили пропустить всё? Мы два раза запускаемся от брата?
В смысле? Мы не как выправляем? Нет, мы продолжаем два раза запускаться от брата.
Нет, ну вот вы говорили, что оценка не работает, потому что...
Ну, смотрите, да, те... Нет. Нет.
Ну, смотрите, там... Ну, могло произойти следующее.
То есть, теперь мы сделали следующее... Мы сейчас добились следующего, что это мистическое условие, оно, на самом деле, это мистическое условие можно было проверить прям сразу.
Не обязательно на вторую итерацию, а на первую.
Потому что раньше могло бы быть... То есть, могла сложиться грустная ситуация, что у нас был наш ранг чётный, и ранг next у нас, этот, там, ядь минус один.
Вот, мы как бы запустили от него next, и в результате этого, там, вот, пошаманили, и в результате, и соответствующий ребёнок неожиданно удалился.
Вот.
Соответственно.
Ну, вот.
Где, где минус три?
Ну, вмести whole condition. Ну, минус один заменить на минус три, и особо ничего не поменялось.
Ну, или на какой-то другой констант заменить.
Ну, сейчас, я не знаю, как вы там... Ну, то есть, помните, нам же надо, чтобы длины цепочек были какие-то, там, желательно не больше, чем r, да?
Ну, да, то есть, ну, как сказать, нет, ну, вопрос, как бы, а что бы это дало?
То есть, если...
Просто это ничего бы не дало, потому что, если тут ранг минус один, то, как бы, при чётном яте, то есть, на самом деле, мы уже получили вот это, и сколько тут не прибавляй, а всё равно получится больше.
Так что, что минус три, что минус восемь, тут уже не важно.
Поэтому, да, тут вот оказалось, видите, там, видимо, для технической реализации, оказывается, нужно вот, то есть, как бы, да, бесконечного ребёнка удаляйте, пожалуйста, не сразу.
Ну, да, но я не знаю, то есть, понятно, что структура выглядит так, что тут, скорее, можно допилить доказательства до того, что всё и так работает, потому что, казалось бы, мы просто, как бы, убрали что-то лишнее.
Вот.
То есть, нот, то есть, действительно, это просто нот.
Нет, хотя, с другой стороны, это не совсем так.
Дело в том, что, видите, нет, на самом деле, есть подозрение, что структура, может, могла бы обвалиться.
Видите, тут же, видите, нам же нужно, то есть, на самом деле, нам нужен трейдов.
Нам нужен трейдов между тем, что структура быстро работает и что количество покорапченных элементов не слишком быстро растёт.
То есть, мы добились того, что оно растёт так, что размер списка ключений превосходит вот этого.
То есть, если бы мы там действительно поторопились бы, допустим, поторопились удалять ребёнка, то тогда, то есть, это бы привело к тому, что мы чаще бы делали разветвление.
Но если делать разветвление прям чаще, то тогда, получается, и покорапченных элементов могло оказаться несколько побольше.
А чем мы вообще используем этот вариант с покорапченным элементом?
То есть?
Ну, для чего он нам нужен?
Ну, он нам нужен, ну, как сказать?
Нет, он нам нужен для того, чтобы покорапченных элементов было не слишком много.
Вот мы с помощью этой леммы сейчас попытаемся оценить, сколько у нас в каждый момент времени покорапченных элементов.
А, давай.
Ну, типа да.
Простите, я туплю, может, вы ответили на вопрос, как мы разобрались с тем, что у нас в случае, когда у нас ранг, например, нечётный, но вторая ситуация.
Нет, наоборот, когда ранг чётный, но вторая ситуация.
Но в итоге, да, небольшим шаманством в реализации, да, разобрались в итоге.
Что мы сделали?
Вообще мы не стали торопиться удалять ребёнка.
То есть мы удаляем, думаем, не удалить ли нам ребёнка только в самом конце.
А, то есть, окей.
Вот.
То есть, как бы, это нам нужно для того, чтобы, вот, там, то есть для того, чтобы мистическое условие, там, может быть, чуть-чуть отдалить.
То есть, потому что оказалось, что могла произойти такая ситуация, что на первой итерации мистическое условие не выполнено, а на второй итерации мистическое условие уже резко стало работать.
И это нам, вот, по крайней мере, лемму портило.
Может быть, можно доказать какую-то более слабую версию леммы.
Но это вам уже остаётся, да, самостоятельное исследование.
Вот.
Вообще, в принципе, да, могла быть интересная задача, кстати, действительно.
Вот.
Как бы, вот.
Хотя, да, знаете, это просто эпическая задача на какую-нибудь оценку на экзамене.
А предположим, что мы этот ИВ всё-таки туда вставим.
Какую асимптотику можно доказать?
Точнее, так, можно ли доказать, что эта асимптотика верна?
Или можно, например, приводить примеров так, что это не будет работать?
Вот.
Нет, ну а что?
Здесь не ответим, всё меняется.
Ага.
Если человек хотя бы пытается, то тоже пить.
Ну.
Нет, ну, хотя бы пытается, ну, знаете, это как...
Да, сейчас хотя бы...
Не, хотя бы, да, хотя бы пытается, да, это уже там набор, да.
Это называется дважды пять.
Дважды два, пять, свободен.
Там дважды два, семь.
Ты ушёл, ты вернись.
Так, если мы дальше, а дальше потом.
Дважды два, Псков.
Так, вернулись все, у кого были цифры.
Ну и так далее, да.
Так вот.
Значит, чему мы эту?
Ну, во-первых, теперь идея такая.
Ребят, слушайте, да?
Значит, смотрите, теперь, на самом деле, возникает такая интересная мысль.
Надо...
То есть, вы заметили, что покорапченные элементы у нас все находятся,
в листах, ранга больше чем р, правда?
Как мы уже поняли, что пока у нас лист имеет...
Ну, опять, да.
То есть, да, мы обнаружили, что пока у нас лист,
как можно заметить, интересный такой факт, что у листов ранг только увеличивается,
уменьшаться он не может.
Сначала у нас ранг нуль, а топ ранг там постепенно увеличивается-увеличится,
но уменьшится он не может.
Сначала у нас ранг ноль, а топ ранг там постепенно
увеличивается-увеличится, но мельшаться он не может.
Вот.
Ну там кажется, конечно, что когда вы там меняете
местами ребенка и чайлда, то был лист какой-то там
у длинной цепочки, а стал у короткой, но это не так.
Потому что, напоминаю, когда они так меняются в этом
месте, то оказывается, что просто это мы просто снизу
на самом деле этот лист протаскивали, поэтому на
самом деле он там прям увеличиться не успел.
Вот.
Поэтому остается только пробежаться, только пробежаться
по всем вершинам ранга больше, чем r и просуммировать
вот эти вот степени двойки и подумать, сколько получится.
Вот.
Ну а теперь внимание и вопрос.
Спрашивается, а сколько у нас, соответственно, может
быть, вершин ранга ядь?
А почему нет-то?
Нет, ну как, кстати, помните, да, у каждой вершины есть,
не только у корня, а у всех есть былое величие.
Причем эти белые величия, если вершины не являются
под предками-потомками друг друга, эти белые
величия не пересекаются.
Типа, да, у меня свои великие предки, у тебя свой фундамент,
короче, у меня свой.
Вот.
То есть, соответственно, каждая вершина помнит о
своих великих потомках, но и заметим, что великие
потомки, как вы помните, у нас не удаляются, но
только там при объединении появляется новая вершина,
у которой как бы теперь вот объединение двух кладбищ,
помните, да?
Ну то есть там, ну пойте, в прошлый раз, но там у нас
припорядили образ, что у каждой вершины есть потенциальные
и живущие потомки, а есть, собственно, это кладбище
там тех, кто когда-то был, но умер.
Вот.
Ну вот, то есть, в этом смысле, когда два дерева объединяются,
то есть два города объединяются, у них как бы кладбище
объединяются, но в данном случае мыслим так, что
да, кладбище как бы объединены, но как бы кладбище
делится на два под кладбище, то есть там два под кладбище
делятся еще там, собственно, под кладбище, ну в общем,
иерархия такая.
И в итоге у каждого паскетов в шкафу.
Ну, ну не знаю.
Ну да, нет, вот это, конечно, может напомнить скелет
в шкафу, который решили похоронить, конечно, это да.
То есть да, когда мы понимаем, что да, когда мы, то есть
когда мы поняли, что наше время пришло, мы кладем
себя в шкаф и закрываем дверь.
Потом, когда выясняется, что да, у меня есть брат,
у меня есть ребенок и не оба скелета в шкафу, то
соответственно мы их хороним.
Вот, а нет, тогда, а нет, мало того, что мы их хороним,
так мы еще и после этого кладем в шкаф себя.
Да.
Да, это хорошо, да.
Ну как хорошо, да.
Вот, по крайней мере, весело.
Так, особенно тому, кого да, ну ладно.
Ну вот.
Чему это нас приводит?
В общем, приводит это нас к тому, что действительно
у нас оказывается, что у нас в каждый момент времени,
то есть такое может быть, давайте посмотрим там,
Лемма два.
Допустим, количество вершин ранга ить у нас не более чем,
ну допустим, n поделить на, n поделить на 2 в степени
вот этот вот ить.
Ну и ять.
Лучше бы ить, конечно.
Нет, ладно, ить это, конечно, там, да, операция с полуфинала
2010 года, но да.
Ну а что там, ну да, там.
Ну правда, это такой вопрос как переводить, конечно.
В английской версии не было, потом в русской версии
появилась.
Операция ить, это там, что-нибудь там, операция на матрицах,
которая там делается каким-то там образом.
А, нет, ну вот.
А, нет, не так.
Операция ить от двух чисел.
Раскладываем их в десятичной степени, как бы друг
под другом в десятичной там, в десятичной степени
и для каждой пары чисел выполняем операцию и.
Вот.
Операция и, ну это просто там матрица, которая двум
цифрам там ставит в соответствии цифру, там типа там
ноль и ноль равно нулю, а все остальные прям произвольные.
Ну и там ваша задача найти операцию ить от а, а там
а, ить, а плюс один, ить, а плюс два и так далее
до б.
А и б до десяти в восемнадцатый и время пошло.
Кто переводил условия 2010 года?
В 2010-м никто не переводил.
Ну потом в группе хард потом появилось, да.
Ну собственно я же и переводил.
А, ну вот.
Ну собственно.
А, ну Вася решал эту задачу, так что соответственно.
Так.
А вот зря.
Вот.
Ну мало, ну не причитал он эту задачу, да, бывает.
Ну когда ты решал полуфинал десятого года?
Скорее всего в прошлом.
Нет, а, ну вот.
Ладно.
Не, ну не на...
Не, ну Вася конечно много проходил сменку в пхард,
но не настолько, да.
Ладно.
Так вот.
Значит чем нам это помогает?
Давайте помогает нам это тем, что давайте просуммируем.
Значит по всем рангам.
Допустим по всем рангам.
Допустим.
Значит.
От r плюс один до.
Ну, наверное, лог 2n округленного вниз.
Но больше у нас ранги не бывают, как вы помните, да.
Мы просуммируем вот такую вот интересную величину, как.
Ну, во-первых, n делить на 2 в степени.
Ну, количество стока вершин.
И в каждой из них у нас получается.
Два.
Там два в степени.
Собственно, y пополам.
Округленное вверх.
Минус.
R пополам вершин.
Вот.
Понятно, да?
Да.
Да.
То самое n.
Ну, во-первых, это можно оценить как.
Какую единицу?
Какую единицу?
Ну, когда мы суммируем it от r плюс один, то уже не надо.
Вот.
Но это меньше либо равно.
Ну, давайте вот это вот округление.
Можно как it пополам.
Ну, можно писать так.
Ну, заметим, что.
Да.
Есть маленький приятный факт.
Например, it пополам меньше либо равно, чем it пополам.
Только вот здесь плюс один.
Только вот здесь плюс один.
Значит, это меньше либо равно, чем.
Значит, сумма по тем же самым it.
Там log 2n.
Что у нас там получается?
Я предлагаю просто, смотрите.
Домножить всю сумму на два.
Ну, точнее.
Да, это не повлияет на симдотику.
И убрать поправление вверх.
Ну.
Ну, можно и так, в принципе.
Ну ладно, если так хотите, пожалуйста.
Можно сделать так.
Не более чем 2n.
Нет, ну не совсем.
Нам же нужно.
Тут надо очень аккуратно.
У нас же не симдотика нужна.
Мы оцениваем количество покорапченных элементов.
Нам нужно доказать, что их не более чем epsilon умножить на n.
Напоминаю.
Вот как-то это вот должно сойтись.
Поэтому давайте лишней двоечкой тут не разбрасываться.
Потому что скорее всего автор думал, цифры подбирал.
Как всегда.
Поэтому тут давайте.
Поэтому давайте тут будет.
Ну, я не знаю.
Можно попробовать тут через корень из двух развлечься.
Вот.
Там.
Так, тогда тут будет вот так.
И минус r пополам.
Это равно тогда к чему?
Тогда это равно.
Значит n на корень из двух.
На такую сумму, как 2 в степени.
Ить пополам.
Ладно.
2 в степени минус.
Даже странно.
Минус ить пополам.
Минус r пополам.
Где ить у нас суммируется от r плюс 1.
Какого-то там несчастного алгорифма.
Ну, уже по барабану до чего она суммируется.
Потому что очень хочется его суммировать.
Видимо уже прямо до бесконечности.
Потому что все равно арифметическая прогрессия.
Правда?
Но как бы мы знаем, что эта сумма не превосходит.
На самом деле.
Если я сюда просто ить подставлю.
То есть получится n корень из двух.
2 в степени минус r.
Но потому что, смотрите, вот эта сумма
она имеет вид 1 делить на 2 в степени
там, я не знаю, k плюс 1.
Плюс 1 делить на 2 в степени k плюс 2.
Плюс и так далее.
Плюс 1 делить на 2 в степени l.
Логично, да?
Ну, только тут k равно r,
а l равно
лог 2n.
Округленный вниз.
Но заметим, что если я даже
просто до бесконечности сумму допилю.
То есть если я сумму эту до бесконечности пилю,
то ее предел будет равен
в точности 1 делить на 2 в степени k.
Нет, я...
Это понятно?
Вот я отсюда и пишу,
то есть я...
А,
я вас понял, да.
А, тут проблема в том,
что шаг тут, к сожалению,
не 2, а корень из 2, да?
Ну, ладно.
Тогда я уточню так.
2 на 1 плюс корень из 2
на 2 в степени r.
Вот так это на самом деле будет.
Но я все эти слагаемые
разобью на пары соседних.
То есть как бы слагаемые
и слагаемые там деленные еще
дополнительно на корень.
А, тут можно даже не...
Вот.
То есть как бы если их разбить на пары,
то это будет там 1 плюс 1
делить на корень из 2 на уже тоже
геометрическая прогрессия, но на этот раз
уже с шагом одна вторая.
Ну,
потому что тут шаг
не 1, а
2,
а
3,
а
4,
а
5,
6,
7,
8,
9,
ну, потому что тут шаг не 1,
а не 2,
то есть как бы они тут увеличиваются не на 1,
а одна вторая. Получается шаг аерисметической
прогрессии как бы там.
Ну, то есть если слагаемые вот разбить на пары,
ну, то есть у нас там...
Ну, то есть получается на самом деле так.
Получается
на самом деле так.
1 делить на 2 в степени там
допустим k плюс 1.
Вот давайте так.
1 k плюс 1 пополам плюс 1
делить на 2 в степени k плюс 2 пополам
там плюс 1 делить
на 2 в степени k плюс 3 пополам
плюс и так далее.
Допустим до бесконечности, да?
А, нет, давайте тут вот
если я тут все-таки напишу 1 плюс
корень из 2, то что это вот можно написать,
что это равно 1 плюс корень
из 2 на
1 делить на 2 в степени
k плюс 2 пополам
k это 2, да?
k это
в нашем случае r на самом деле потом.
Да.
Да.
Как я сейчас делаю это...
А, ну там...
У нас первая члена
это 2r плюс 1 пополам.
А, ну хорошо, тогда
ну 2r получается, да, где-то.
Где-то так.
Так.
Сейчас, ну вот 2 в степени
1 плюс 6 пополам
плюс и так далее.
То есть, заметим, что
а эта штука уже идет шагом
одна вторая, то есть это у нас равно
на самом деле 1 плюс корень из 2
1 делить на 2 в степени
k пополам.
Ну, да.
Откуда у нас там вообще кое-что взялось
с самого начала?
Ну, потому что, видите, у нас была геометрическая прогрессия
корень из 2.
Вот. Я как бы вынес 1 плюс корень из 2
и как бы вот
если из этой, то есть как бы это
вот эта сумма от 2, это что такое?
Это вот эта умноженная на 1 плюс корень из 2.
Следующие это вот эти два, слагаем их на 1 плюс корень из 2.
Все.
Так.
Ну, получилась, в общем, какая-то константа.
Вот. Да, может быть,
не идеальна точно как у автора, но
получила, ну вот. Но, по крайней мере, теперь давайте
подставим, что такое 2 в степени минус r?
То есть, на самом деле, да, то есть
2 в степени минус r, да, то есть это
как бы по-нашему это получается равно
там
значит, 2 плюс
корень из 2 r
поделить на
2 в степени
2 плюс, значит,
2 логарифма округленных
вниз, 1 делить на епсел.
Количество покорапченных элементов, мы считаем.
Вот.
Так, ладно, давайте вот это я сотру, а то что-то как-то
ой, места уже не хватает.
Так, теперь смотрите.
Что приятно.
С точки зрения меньше либо равно
так, я тут
ой, я, да, n должен убить.
Так, тут n. Заметим 2 плюс
вот эти вот зачем, видите, отчасти зачем
это были 2 плюс 2 вот логарифма,
не только для технической радости,
а еще это нужно было бы для того,
чтобы
соответственно сказать, что это с точки зрения
меньше либо равно вот эти 2 в квадрате убивают
вот эти 2 плюс корней из 2.
То есть получается это не более, чем n
на 2 в степени
2 логарифма, 1 делить
на епсел.
Вот.
Как мы
в знаменателе 2 в степени r плюс 2 логарифма
1 делить на епсел.
Чего-чего?
А, это не только с точки зрения.
Вот. Вот получается примерно так.
То есть, ну, видите, в знаменателе,
поэтому тут можно убрать это округление.
Но 2 в степени лог 1 делить
на епсел получается это. То есть получается
n поделить надо. Тут даже
вообще весело. 1 делить на епсел
в квадрате.
Это равно даже епселон квадрат n,
что интересно.
Ну, неплохо, Дэн.
Чего епселон больше?
Не, ну, епселон квадрат
n это лучше, чем
епселон n даже.
Коррапченных элементов даже сильно
оказалось меньше, чем мы думали.
Ну, не особо меньше.
В смысле,
у нас епселон,
если, например, она треть, то у нас вместо одной треть
одна девятая. Так нет.
Ну, у тебя асимплотика
асимплотика работает
логарифм от епселона.
Ну, да.
Поэтому, когда 2 епселона делить в квадрате,
асимплотика не меняется. То есть,
если мы теперь скажем, что у нас епселон штрих
равно епселон квадрат,
то мы, по сути, догадали то, что мы изначально хотели.
Ну, по сути, да. То есть, может быть,
можно даже задуматься, что r можно и ослабить
чуть-чуть.
Ну, да, получается.
Может, получается, что у нас как будто
это двойка даже.
Но нет, может быть, знаете как,
эта двойка, может быть,
взята для технических нужд,
для того, чтобы у нас там этот ранг всегда был
хрен с ним чётный.
Ну, помните, нам там где-то это
как-то чуть-чуть технически помогло.
В какой-то момент дело было.
Вот. Поэтому можно и так.
Ну, вот. Можно, конечно, пересмотреть, но,
по-моему, да, там...
То есть, тут надо глянуть. Интересно там.
То есть, может, мы чё потеряли, я не знаю,
по дороге? Ну, вроде нет.
Давай.
Мы же посчитали вот эту сумму,
получили единиц, терянная на 2,
не ка пополам.
А тут у нас...
Чего-чего?
Вот мы посчитали вот эту сумму
с кашками.
Потому что, ну, смотрите, потому что получается,
ну, как вы смотрите,
если я вот так вот объединю,
то у меня получится тут это
ить плюс р, да?
Ну, вот. То есть, ить начинает
с r плюс 1, то есть, вот эта штука
начинает с 2r плюс 1.
Следовательно, то есть,
равно 2r, тут, получается, должно быть
2 в степени 2р пополам, отсюда r, да?
Вот так.
Угу.
Так.
Ну, да, нет,
странно тут.
Да, странно.
Как будто...
Ну, может.
Ну, не знаю.
Ладно.
Так, ладно.
Там, честно скажу, у автора, может, там вычисление,
конечно, немножко по-другому, но...
Чего автор?
Ну...
Не, ну он там...
Не, ну он там сразу пытался какую-то сумму
делать, но я не знаю, вот мы тут...
То есть, можно, конечно, у автора было бы спросить,
что мы, как бы, честно,
по всем листам там всех рангов
честно вот это просуммировали, у нас уже
эпселон квадрат n получился, так что...
Так что вроде не пострадали.
Давай.
Давай.
Потому что
в сеть ни одна из этих
вершин не является потомком друг друга,
и у каждой из этих вершин
как бы есть память о своих
два степени ядь
в элементах, именно элементах.
Ну, которые были
когда-то в ней или в деревьях,
как бы...
Нет, только не обязательно, потому что
могло быть так, в жиле были два дерева
ранга r-1,
там поудаляли по паре
ключей, а потом эти деревья взяли
и объединили.
Вот, могло быть так.
Вот. Но, как бы, тем не менее,
в ней сохраняется память
от тех, то есть, каждое дерево оно как бы
создано из там...
То есть, каждая вершина хранит в себе
какую-то память. Если две вершины объединяются
в более высокое дерево, то это более высокое
дерево хранит память обо всех.
То есть, иногда у нас случается,
что как бы, помним, да, что вершина
какого-то ранга исчезает.
А дети там...
Но у детей там память о своих
потомках от этого все равно никуда не
исчезает.
Но эти деревья...
Но тогда это...
Тогда эти вершины предки друг друга
и сразу сапопарно различными рангами.
Вот.
Как мы доказывали, что у нас
ранги больше, чем блокарифы
таким же образом?
Ну, тоже по инду...
Ну, часто по индукции доказывали, что
как бы...
Каждая вершина ранга
какого-то там ранга х
содержит память ровно
2 в степени х своих собственных
вершин.
Какой?
Вот.
Вот строчка с...
Там, где сумма начинается,
всякие вычисления...
Возникает
самая правая штука
в первой строчке, там неравенство n х2
на 1 плюс х2 на 20
и минус f, да?
Вот как мы к этому перешли
от первой штуковины?
Да.
Потому что вот эта штуковина имеет
вот такой вид.
Эта штуковина равна вот этой штуковине.
Да.
Ну вот, а эта штуковина
уже геометрическая прогрессия шаром 2.
То есть, можно сказать, что
если тут суммы до бесконечности,
то это 1 плюс х2 на 1 делить на 2 в степени как
пополам.
Ну и все.
Вот так и перешли.
Нет.
Видите, тут минус... Тут как бы
мы знаем, мы не с r плюс 1,
а с r плюс 1 плюс r пополам.
А, все понял.
Вот, поэтому 2r.
Так, ну что?
Еще вопросы есть?
По вот этому.
По вот этому. Вот.
Это будет на экзамене.
А, как же.
А зачем нам это сказать?
Очевидно, мы это все-таки
поделим, чтобы дать статистику.
Вот.
Вот это, вот это да.
И вот это хорошая вещь.
Мне кажется, что
это будет в жизни использоваться каждый день, Миша.
Ой, ладно.
Мне кажется, единственное
время, когда мы будем провозить.
Ну это значит,
что такое полезный.
Так.
Так, ладно, господа.
Так, геома тоже будет,
не волнуйся.
Сейчас.
Сейчас, что значит новые деревья?
А, ну, нет.
Вот там фишка такая. Смотрите.
Без лишних вот этих вот удалений,
там, удалений вершины новых молдов,
у нас там все работало по принципу,
что на корне,
условно, там,
на корне каждого дерева находится,
допустим, монетка,
которая будет, ну вот, и там,
когда вы сливаете 2 дерева,
вы одну монетку тратите, а вторую прикладываете на корень.
Так вот, там будет все нормально.
По той простой причине, что
допустим, у вершинки выпиливаете ребенка,
вот в этом вот месте,
да, то вы, как бы,
на, условно, саму эту вершину
кладете монетку.
И тогда получится,
что если вы решили пройтись
по ряду, обнаружили, что тут надо
его удалять, то выяснится, что
вы как бы выпилили там не менее, чем половину
детей, и у вас на этом ряду, значит, лежит
не менее половины монеток.
Этими монетками,
эти монетки вы, собственно, там детям раздаете,
и все в порядке.
Там вот такой
тонкий.
Вот такой вот тонкий шаманство.
Так.
Ладно.
Так что пришло время, наконец, выдохнуть
и перейти к чему-нибудь еще.
Чего?
Так, значит, смотрите.
Так, а вот тут сейчас будем решать честно,
демократическим путем.
Нет, давайте так.
Нет, честно скажу, я вам хочу...
Нет, я хочу сейчас дать какой-нибудь блок,
по которому можно, действительно, дать, наконец,
хорошее домашнее задание.
Вот, и у меня есть два...
Нет, смотрите, у меня есть два... Нет.
Нет, у Atomic Hip...
Нет, не на столь.
Проверят, проверят.
Так, смотрите.
Так, ребят, ребят, ребят.
Ребят, ребят, ребят.
Так, тишина. Ребят, давайте не тянем время.
А то как выданут.
Значит, смотрите.
Значит, смотрите.
Блоки, на самом деле, предлагаются
следующими. Первый блок уже обсуждался.
То есть, хочется...
Это мы будем активно обсуждать всякие двоичные
деревья поиска.
Ну, то есть, да, их у нас там много.
То есть, это там у нас...
Это будет АВ, как минимум, АВ,
это будет красночерное дерево,
это будет сплей дерево,
это будет Б дерево, конечно.
Б.
Б.
Вторая буква латинского алфавитом.
Вот, а Б...
Вот.
Ну, вот.
Нет, ну, естественно, там упомянем,
конечно, дикартьячку.
Упомянем в том плане, что тервера мы не знаем,
поэтому доказывать ее не будем,
но нам это и не будет нужно.
Потому что, если мы хотим делать сплит, мёртвый, прочий,
и реверс на подотреске, который вы любите делать в дикарьтехах,
на самом деле, и АВ,
и Б дерево, и даже красночёрное дерево
прекрасно умеют это делать.
Просто мало кто об этом знает.
Но на самом деле, они всё это умеют.
Вот.
Чего? Да.
Ну, я не знаю. Нет, на самом деле, вам понравится.
Значит, это
один блок.
Блок второй.
Ну, в общем,
ладно, не буду тут долго анонсировать.
Блок второй – это про фурье.
Значит,
что такое фурье?
Ну, давайте я тебя уже полностью анонсирую.
Ну, про фурье там тоже
на самом деле блок достаточно большой.
Ну, потому что понятно,
помимо самого фурье,
мы делаем не только умножение многочленов,
но и деление многочленов.
Также мы научимся делать
длинные деления даже чисел.
Да.
Ставка за nLogin.
Вот.
Да, я утверждаю, что
я умею делить числа
длины 100 тысяч
с остатком за nLogin.
Чего? По какому модулю?
FFT? Нет. Ну, FFT по модулю
тоже упомянем, куда же мы денемся.
Вот. Может быть, даже в связи
мы какую-нибудь течежку обсудим.
Нет, там будут
еще всякие вещи. Потому что, во-первых,
будет еще многомерное преобразование
DP. Там есть, конечно, всякие
веселые свертки, типа SOS DP
и его друзей.
Там вот эти все. Так.
Еще там будут...
Ну, так.
А, еще...
А, еще будет неожиданное
решение рекуррент.
Ну, там в том плане,
смотри, там фишка будет такая.
Ну, для вас понятно, не секрет, наверное,
что если вам дана рекуррента какая-нибудь,
типа AN равно там, скажем,
AN минус первое, плюс 2 AN
минус второе, плюс там
28 AN минус третье, да?
И вы там хотите вычислить
а какое-нибудь миллиардное
по модулю миллиард 7.
Как? Боже упаси.
Ну, для вас самое тупое, что можно сделать,
это как бы возвести матрицу 3 на 3
в степень. Да.
Там может быть какой-нибудь там берлекамп.
Но, на самом деле, с помощью Фурятины
мы это научимся делать тоже за...
за еще быстрее,
то есть научимся делать это для рекуррента
размера 100 тысяч.
Вот.
Вот еще такие вещи.
Потому что интересно.
То есть мы сейчас решаем...
Вот. Если мы выбираем одно,
то другое мы никогда больше... Нет, это не верно.
Нет, разумеется, оба блока обязательно
будут. Но я, правда, про второй
блок, я уже не знаю, будут ли они в каком семестре
они будут в этом или в следующем.
Но оба блока обязательно будут, куда ж без них.
Поэтому...
А, ну да, ну и всякие
мелочи, вот эти вот там, типа,
интерполяция многочлена там, вот это все.
Но это все уже там... Относительно этого всего
это все мелочи. Вот. Поэтому вопрос
только такой. С чего мы начнем?
Так, значит, смотрите.
Значит, предлагаю так, ладно.
Значит, предлагаю вам это немножко там,
там, поиграть в кикера
с этой мыслью.
Поэтому давайте сейчас мы
действительно там, давайте
сколько-то выдохнем. И после этого
тогда, собственно,
демократически выберем и начнем.
Ну а теперь, внимание у нас,
теперь...
Вот.
Вот.
Ну а теперь, внимание у нас, теперь
кто за то, чтобы проходить
FFT? Поднимаем руки.
FFT!
Ну вы чего?
Так.
Так. Руки держим выше.
Так. Высоко держим руки.
FFT!
Так. Вверх, вверх, вверх.
Руки преравниваются к испорченной блюте. Не надо.
Так.
6, 8, 11.
И, соответственно,
16, 18. Спасибо.
Так. Ну ладно.
Да.
Нет, тут есть только...
Хорошая попытка у нас.
У вас тут не сорок.
А еще некоторые
любят второй раз руки поднимать, только
на это надежда. Итак, кто за то, чтобы проходить
OVL и прочее сбалансированные
FFT?
Да.
Так. 1, 2, 3, 4, 5, 6,
7, 8, 9, 10.
Да!
Итак.
Так что да.
Не, ну что, знаете, да.
Не, ну знаете, в общем-то, там
сериал «Слуга народа» тоже с этого начинается.
По всем вопросам... По
одним вопросам побеждает один кандидат.
По другим – другой.
В общем, если бабах 65%
вообще у аутсайдера. Ну вот.
Просто потому что за ним никакой олигархи не стоял.
Так что, нет.
Никакой геомы мы изучаем FFT.
Все.
Да, кстати, да.
К вопросу окрикливо меньше.
К вопросу окрикливо меньше.
Вот. Знаете, смотрите.
Так. Все.
Значит, тишина. Итак, чем мы будем
заниматься? Заниматься...
Так, сначала мы возьмем микрофон. Да.
Так. Все.
А, жалко без... Ну вот. Ладно.
Ладно, в любом случае, это было честно
записано на камеру голосования.
Так.
Да, да, да.
Ну ладно.
Да, да, да. Просто кто-то
вбросил. Да, да, да.
Ладно.
Смотрите.
Вот.
Ну, на самом деле, как бы, отчасти
мотивация, конечно, то, чем мы сейчас будем
заниматься, вызвана, конечно, из задач
длинной арифметики.
Ну вот.
Потому что, как знают все сишники
и не задумываются питанисты,
действительно, числа бывают длинными.
Вот. То есть, теперь вот C++,
если вы хотите работать с числами
порядка 10, например,
100, или 1000,
или даже 100000,
то неожиданно выясняется, что
надо что-то специальное
кодить на эту тему.
Вот. Но дальше...
Ну вот. Ну как же мы будем
хранить... Как же вообще такие длинные числа
можно теоретически было бы хранить?
Ну, например, вот.
Как удобно работать
с числом вида 9, 8, 5,
4, 2, там, 0, 1, 5,
2, 3, 6, 9, 2, 2, 5,
2, 2, 2, 2, 2,
2, 2, 2, 1, 5,
9, 7, 3, 2,
8, 0, 8,
1, 0, 0, 1, 3,
2.
И вот тут еще 3.
Вот.
Вот.
Ну не важно.
Вот просто дано такое число.
Как с подобного рода числами работать?
Ну, конечно, самое тупое
можно было хранить эти стильы в обстрочках.
Но это не самое удобное,
что можно сделать.
Ну, самое удобное, первое,
обычно, что приходит в голову,
это, конечно, завести вектор
и хранить там
просто, скажем, по циферке
в ячеечке.
Например, 2, 3,
1, допустим, там
0, 0,
там, соответственно, 1, 8,
там, 0,
0, 2,
3, 7,
9, 5,
ну и так далее.
Ну и так далее.
Чем вообще такое
удобно?
Ну, на самом деле, если вам вот тут
возникает вопрос, что с этими числами нужно делать?
Самое первое, что приходит в голову,
то есть обычно это сложение,
вычитание, ну и какие-нибудь там сравнения.
Вот.
Ну, заметим, что
если у нас есть, допустим,
два числа такого вида, вот второе мы
сразу напишем в таком виде.
4, 8, 2, 6,
0 там, ну от балды я сейчас что-нибудь напишу.
7, 7,
7, 8, 0,
2, 4, 3, 6.
Так, ну да, разряды даже
почти совпали.
Вот.
Ну почти. Ну вот.
Тогда мы обнаружим, что сравнивать эти числа достаточно
легко. Как сравнивать эти числа?
Ну, во-первых, сравнить по количеству
разрядов, если они различаются, то значит,
у кого меньше разряд, тут и меньше, правда?
Вот.
У кого тут меньше разрядов?
Да, это оптический обман,
у них количество разрядов по 14.
Вот.
Да, просто
видите, так вот.
А, ну да. А, тут мы еще не
дописали. Ладно, второе точно меньше. Хорошо.
Но если бы у нас число ограничивалось
вот этим по 14,
то тогда пришлось бы сравнивать
честно за линию. Каким образом?
Ну мы бы сравнили самый старший разряд, если они не совпадают,
вот как у нас, то
ну собственно, у кого меньше этот разряд,
то число и меньше. Если
эти равны, то равны и эти, и эти,
и так далее.
Вот.
То есть сравнивать достаточно легко.
А как же эти
числа, если мы хотим эти числа
складывать? Ну,
и здесь мы поверим, что продвинутый поток, наверное,
сможет достаточно легко реализовать сложение
столбиком, правда?
Тем более, ну алгоритм изучался
во втором классе.
Да ладно.
Так, ну значит, давайте покажу,
как сложить эти числа столбиком.
Да, это быстро, смотрите.
То есть складывать столбиком
так, складываем разряд, 2 плюс 4,
6, 3 плюс 8, 11.
Так, раз 11, значит
1 пишем, 1 в уме.
Так, 1 плюс 2, и еще
1 в уме, получается 4.
Вот.
Значит, тут
получается 6, 0,
8, о, 15, 1 в уме,
значит, тут, соответственно, 8,
8, ну и так далее, короче.
С точки зрения кода, на самом деле
теоретически, да,
можно сразу, конечно, этот перенос хранить,
а можно поскладывать так, можно в эти
ячейки положить прям 6, 11,
3, там 6, вот прям
почленно сложить, 8,
15, там я не знаю, 7, 8,
там какой-нибудь 0.
А почему не может быть
10 в уме?
Почему не может быть 10 в уме?
Так, сейчас 7, 8,
тут на самом деле будет 2, 5,
потому что вот так вот, значит
11, 12, 11.
Вот.
Но когда вы складываете, у вас
в каждое время бывает не больше чем 9,
плюс не более чем 9, плюс не более чем 1,
прям по индукции, поэтому в сумме будет не более
чем 19 и в переносе не более чем 1.
Вот.
И поэтому сработает это теперь так.
То есть вы теперь пробежитесь по этому массиву
и каждый раз, когда видите что-то больше
либо равное 10 значит то, что делится
на десять, перекидываете сюда.
То есть получается 6, тут получается 1,
тут получается 4,
6, 0 там 8.
Тут, значит, получается 5, тут получается 8,
тут получается 8, 2, 5.
11 – это значит 1, тут
уже 13. Тут получается 3,
перекидываем 1, тут получается 12,
то есть 2 и 1.
Вот.
Это, если вкратце.
Вот.
Ну, аналогичным образом уже рассмотреться самостоятельно, можно попробовать сделать и вычитание.
Разница только в том, что там в некоторых местах будут возникать отрицательные числа,
поэтому вам придется где-то прибавлять 10 и вычитать единицу дальше.
Ну, прежде чем двигаться, ну, хочется обратить внимание еще на следующий чит,
что с целью несимпатического ускорения обычно замечают, что вот можно хранить эти числа не в десятичной системе счисления.
А в системе счисления с основанием, вот я его называю, осен, равно, например, 10 тысяч.
Ну, самое простое, пока 10 тысяч.
Нет, можно и в двоичечной, конечно, хранить, но это...
Но просто так, то так не попереводишь.
То есть... А, ну давайте вот.
Тогда просто в чем преимущество?
Ну, преимущество в том, что в каждой ячейке типа int вы можете хранить теперь не одну цифру, а сразу по четыре.
То есть, вот, например, тут будет 132, ну, там с ведущим нулем.
Дальше у нас там будет что?
Там 810 тоже с ведущим нулем.
Ну вот, что у нас там дальше?
Потом у нас 7320 будет идти.
А это там, соответственно, 2159, потом там вот эти вот четыре двойки.
Потом там 5 и еще три двойки.
Ну и так далее я не буду уже дописывать.
То есть, преимущество в том, что можно делать абсолютно то же самое,
только там переносить не десятку, а 10 тысяч.
То есть, асимпатически ничего не поменяет, не асимпатически выгода очевидна,
потому что работает в четыре раза быстрее.
Ну, начнутся там мелкие технические проблемы на тему того,
когда вы захотите это число напечатать на экране.
Потому что, как бы, в каждой ячейке, кроме самой первой,
вам нужно напечатать ровно четыре цифры,
то есть там с ведущими нулями в случае чего.
Но это мелкая техническая проблема.
Вот, ну там сложение, вычитание, сравнение делаются идентично.
Причем более того, по идее, можно это сделать шабло,
шаблонным параметром даже вот эту степень.
Потому что можно делать так, а пока мы складываем и хотим складывать в интах,
то можно вообще развлекаться и делать 10-9.
Вот.
Представляете когда-нибудь длинную арифметику с основанием миллиард?
А ведь на самом деле в инты умещается прекрасно, очень рекомендую.
Ну вот, ну там, ну пока, ну вот.
Не, ну как, 10-6, с точки зрения умножения уже все равно плохо.
А так, с точки зрения сложения можно уже и 10-9.
А если мы вспоминаем, что у нас 64-битные машины,
скорее всего, лонг-лонг-инт работают одинаково,
то вот это тоже прекрасно будет работать.
Да.
Да.
А при выводе на экран, когда вы видите число меньше 1000,
например, то вам как минимум 1.0 тут придется вывести.
Ну это просто мелкое техническое замечание.
Вот.
То есть пока вы складываете, вы читаете, все в порядке.
Что еще можно делать?
А, ну вот, штука, которая нам вот эту 10-18-ую радость
немножко, значит, поумерит в пыл.
Если от вас захотят эти числа умножать на короткое.
То есть на короткое это на какое-то x, x меньше осна.
Ну нет, то есть умножение, технология умножения на осн
понятно, что, ну, то есть можно сказать так, делаем
абсолютно то же самое, то есть подчленно умножаем,
а потом проходимся слева направо и делаем перенос.
Проблема только будет заключаться в том, что произведение
осн на осн будет приводить к числу порядка осн в квадрате
в лучшем случае, правда?
Вот.
И тогда получается, что, как бы, если числа до 10-18-ой,
то у вас будут проблемы.
То есть надо как минимум 10-9-ой тогда.
Как максимум?
Ну вот.
Но на самом деле, если вы хотите, чтобы все вычтения
вылезали в int, вот когда-то была привычка, что делаете
желательно без лангов, потому что там в int все быстрее,
то тогда, поэтому это и приводит к тому, что традиционный
осн это все-таки 10-4-ый.
Вот.
То есть тогда получается вот умножение на короткое,
а еще можно делить на короткое.
Ну и делить на короткое тут уже никаких переполнений.
Нет, оно потребует каких-то переполнений, потому что
у вас там будете идти справа-налево, у вас будет
остаток, который вы будете умножать на осн,
прибавлять следующее число и делить.
Ну там тоже деление столбиком следует.
Вот.
Да, достаточно простые операции.
В общем-то, ничего умного они не требуют.
Правда?
А деление что нужно делать?
Ну делить на короткое.
Ну делить соответственно тоже столбиком.
Что?
Ну второй класс, ребят.
Ну что такое?
И что теперь?
Можно чекать?
Для блоков можно быстро.
Ну да.
Ну вот.
Ну ладно, я могу показать, как делить длинное на короткое,
конечно.
Ну вот давайте, например, поделим 9, 8, 7, 2, 4, 6, 3.
Давайте поделим на короткое число 7.
Значит делается это так.
Так, 9, 9 поделить на 7.
Пишем 1.
Значит тут типа вычитаем 7, тут в остатке 2, т.е. модуль.
Сносим 8, 28 поделить на 7, 4.
Получается 0.
Но это будет не настолько эффективно, вы сейчас по одной цифре идем.
Ну да.
Вы хотите примера, когда тут 3 цифры будут?
Давайте, пожалуйста.
Значит, ну по одной цифре это будет работать за линию.
Если вы хотите побыстрее, то значит ладно, запасайтесь калькуляторами.
Значит поехали.
7, 4, 9, 0, 0, 8, 6, 5.
Вы хотите поделить на, ну для простоты там, я не знаю, 123.
А можно на 1 для простоты, пожалуйста?
Нет.
У нас заказали, что блоки будут по 3.
А на 0?
Или вот даже, вот я давайте еще вот так 6 напишу.
Это как бы тоже блок.
Ну а теперь 6 делим на 123.
Получается 0, тут получается 0, остается 6.
Приносим следующий блок.
274.
Так, сколько будет 6274 поделить на 123?
Чего?
Ну да, но не за пределы основания в квадрате.
Потому что у вас тут число меньше, чем 8 строго остаток.
Потому что.
Поэтому то, что результат должен уложиться вот в эти циты.
Сколько?
Остаток 1, а частные 51.
Так, значит тут 51.
Остаток прям попали, да?
Ну хорошо.
Отлично, 1.
Так, 1900 теперь поделить на 123.
Сколько будет?
7, 8.
15?
Ну пожалуйста, 0, 15.
Так, остаток какой?
55.
55?
А, или это от балды там сказано, да?
Так, и вот-вот уже побольше чисто.
Так, 55865 теперь поделить.
454.
Чего?
454.
А остаток какой?
23.
А, я уже боялся, что сейчас 0 будет.
Во.
Так, ну теперь вот можно, да, теперь уже можно на том же калькуляторе проверить,
что вот это на это плюс вот это равно вот этого.
Вот.
На самом деле вот механизм выглядит именно таким образом.
Как мы понимаем, что нужно всегда выделять по три цифры?
Ну потому что мы сказали, что осен равно тыша.
То есть мы просто заранее себе прописали, что у нас блоки по три цифры.
Были бы по четыре цифры, ну как бы мы бы...
И тут число бы мы считали как по четыре.
А в ответе по три цифры как бы?
Ну так всегда и определяем, что их вот по три цифры.
Их всегда по три цифры.
Тут тоже как бы три цифры, просто тут вот.
Три нуля.
Нет, ну я могу, конечно, писать формальное доказательство,
конечно, от того, что это работает.
Нет.
Ну да.
Ну как-то да.
Ну просто я не знаю, просто как-то вот.
У вас это все должно было быть во втором классе.
Так вот.
Ну вот, я тоже в общем-то сейчас не хотел этим заниматься.
Ну так, я просто к тому, что действительно это достаточно просто,
чтобы я это достаточно просто закодить.
В общем, делаться это все будет за линию.
Вот.
Но проблемы начинаются, когда мы хотим умножать,
скажем, длинное на длинное.
То есть вот представьте, у нас есть два числа длины 100 тысяч.
И мы хотим друг на друга домножить.
Перемножаем это в короткие.
Перемножаем длинное на короткое и сдвигаем.
Нет, ну можно длинное на короткое,
а можно просто на самом деле в тупую.
То есть смотрите, если у вас число, давайте допустим,
осн равно 10 для простоты.
Сейчас увидите, почему, кстати, имеет смысл именно 10.
То допустим, у вас есть массив A,
там 0, 1, 2 и тарталия n-1.
И массив B от длины, ну например, тоже n-1 для простоты.
И тогда, значит, перемножение могло бы выглядеть так.
То есть мульт от AB.
Значит, мы говорим c,
значит, точка assign,
допустим, 2 умножить на n и 0.
Дальше говорим, что for i равно от 0 до n-1,
for j равно от 0 до n-1,
c i plus jt
c i plus jt
plus равно a i t
умножить на b jt.
Логично, да?
И дальше мы бы сказали что-нибудь в духе,
что for i равно от 0 до 2n-2.
Значит, мы говорим, что c i plus 1
plus равно c i t
делить на 10 в нашем случае,
и c i t
там.
Давайте только не на 10, а давайте все-таки на 8, конечно.
И c i t процент равно 8.
Вот так могло выглядеть самое тупое умножение за квадрат.
Ну, здесь сразу оно обдороживает там технические моменты.
Насколько большие числа в процессе этой c-шки могли возникнуть?
8 в квадрате.
Нет, больше.
n в 8 в квадрате, да.
Вот.
Но на самом деле так.
Порядок получается n на 8 в квадрате.
Это надо внимательно смотреть.
То есть получается n как минимум надо выбирать так,
чтобы n на 8 в квадрате случайно не вылез за лонг-лонг.
Ну, на самом деле, да.
Кто-то мог бы справедливо заметить, что если тут произошло переполнение,
так давайте мы тут сразу его там перетенем в следующую
и тогда у нас с переполнением и будет сильно лучше,
потому что там будет там, потому что этих переполнений будет меньше.
Ну, там можно уже на эту тему рассуждать.
Это 2 в квадрате.
Да, но...
Чего? Почему 2 в квадрате?
Ну, потому что это переполняется.
Ну, это переполняется, но тогда, когда вы делаете перенос,
у вас там перенос уже получается...
То есть каждый перенос не более чем на 8,
то есть получается там в каждой ячейке получается там
ну, что-то типа n на 8 или 2n на 8, что-то в этом роде.
Ну, по сравнению с 8 в квадрате это...
Вот.
Но на самом деле мы даже не будем в это копать по одной простой причине.
Потому что у этой задачи есть брат,
в котором эта проблема не исчезает.
Брат называется...
А давайте перемножать не длинные числа, а многочлены.
То есть давайте себе представим...
То есть давайте...
То есть альтернативная версия могла быть,
что у нас есть вот такой многочлен Аt,
вот A0, A1t, плюс и так далее,
плюс An-1t в степени n-1,
и есть второй многочлен.
Вот Bn-1 на t в степени n-1.
Вот.
И я хочу найти произведение этих многочленов.
Ну, видим многочлена.
Тогда заметим, что код выглядел бы абсолютно так же,
только вот просто...
Только здесь бы мы остановились.
То есть чем отличается с перемножением многочленов?
Это перемножение длинных чисел.
Никаких потом вот этих вот переносов не надо.
Правда?
И по большому счету, да,
мы на самом деле не будем в этом копать по одной простой причине.
На самом деле, может быть, будем решать на самом деле задачу
именно перемножение многочленов в основном по вот этой вот причине.
Потому что по факту перемножение длинных чисел
будет заключаться в вида
превратите числа в многочлены,
перемножьте многочлены этой вашей фурьятины,
ну или чем вы там будете,
а мы там чем-то еще будем.
Вот.
Соответственно, и потом после этого в результатах,
соответственно, то есть вы там получили вот эту вот штуку,
и после этого тогда мы делаем переносы и радуемся.
Вот.
Понятно, да?
То есть как бы задачи по идее братья.
Но очень бы хотелось, конечно,
чтобы эта задача как-то решалась,
вот чтобы перемножение многочленов
решалось не за n квадрат,
а как-то побыстрее.
Вот хотя бы перемножение многочленов.
Как же это сделать?
Корацуба.
Да, Корацуба.
Мистическая фамилия,
относящая нас в какую-то пыльную аудиторию,
ну ладно, не очень пыльную аудиторию
мехматой МГУ в 60-е годы.
Да, но я понимаю,
что я сейчас рассказываю уже Дите Баян,
но тем не менее.
Но история действительно очень красивая,
представьте, в 60-е годы,
значит, на своем научном семинаре,
то есть это уже научный семинар,
то есть не в смысле мы там это,
то есть как бы научный семинар,
то есть о реальных вот научных проблемах,
вот такой вот ремонт академик Калмогоров
рассуждает.
Вот ситуация, смотрите какая.
Есть у нас вот такая веселая задача
как перемножение, допустим,
длинных чисел.
Как ее делать за квадрат,
знали там едва ли не древние вавилоняне.
Ну там, в общем, несколько тысяч лет
уже человечество прекрасно знает,
как это делать за квадрат.
А вот быстрее за столько же тысяч лет человечество
как-то пока так и не придумало.
И скорее всего, это означает,
что это в принципе невозможно,
поэтому надо искать действительно
пути, как доказать, что это невозможно.
И, собственно, продвигать математику,
то есть узнавая, где у нас тут какие ограничения,
тем самым вот это интересно.
Ну буквально, едва ли не в конце семинара,
к нему подходит,
вот никогда, сколько лет рассказываю,
никогда не помню, то ли студент старших курсов,
то ли аспирант младших,
и буквально в три строчки
объясняет Калмогорову, что он неправ.
Что же это были за три строчки?
Я нашел число,
которое разорвется на независимом пространстве
в номере Атлантического Безболиста.
СМЕХ
УСМЕХАЕТСЯ
УСМЕХАЕТСЯ
УСМЕХАЕТСЯ
Ничего себе.
УСМЕХАЕТСЯ
УСМЕХАЕТСЯ
Я возьму два простых числа,
Вот, ну да, потом меня выгнали с контрольной второго класса, правда, ну да.
Так вот, нет, две строчки были такие, значит три строчки примерно такие.
Ну ладно, то есть они там более быстро, мы их рассмотрим чуть более медленно,
у нас чуть более строчек получится.
Ну во-первых, когда мы, допустим, мы перемножаем два многочленна,
пока для, без особого ограничения общности, мы будем предполагать,
что все эти многочлены имеют размер n, где n равно степени двойки.
Да, кстати, я сразу подчеркну терминологический момент.
Я различаю понятие размер многочлена и степень многочлена.
То есть я говорю, что у меня многочлен размера n, если у меня у него есть n коэффициентов.
Степень, то есть обратите, степень этого многочлена, она не превосходит n-1,
а может и меньше, если вот тут нули.
Вот, но мы будем с вами говорить, что...
Да, не знаю, привычнее что ли.
Честно говоря, я не знаю, почему мне привычнее это писать, ну вот.
Нет, знаете, хотя я знаю, почему.
Дело в том, что, как многие из вас знают, на самом деле у нас тут вскоре вылезут комплексные числа,
а в комплексных числах как-то называть переменную x бывает не очень,
потому что можно ее перепутать с x координаты.
Поэтому там обычно многочлены от t начинаются.
Ну или там можно было многочлены от z, конечно, писать.
Так вот, давайте без ограничений обществе считать, что у нас размером многочлена ровно степень 2, причем 1 этаж.
Так вот, как мы будем умножать?
Умножать будем так.
Мы скажем, что A разобьем многочлен на 2 многочлена.
Мы скажем, что A от t это многочлен A0 от t плюс t в степени n пополам на A1 от t.
Где A0 от t и A1 от t это многочлены размера n пополам.
Вот, как это может выглядеть?
Ну, например, A0 от t это все то же самое только до n пополама.
Вот.
И A1 это то же самое только начиная с A n пополам.
То есть очень приятно здесь вот такая примерно штука приятная.
Это было A от t, а теперь будет B от t.
B от t тоже мы аналогичным образом скажем, что это B0 от t плюс t в степени n пополам на B1 от t.
Вот такая красота.
Что сейчас будет?
Теперь мы попробуем свести задачу перемножения A на B, но я не буду тут от t писать для краткости,
к рекурсивным запускам перемножения многочленов на размера n пополам.
То есть, смотрите, A умножить на B это что такое?
Это A0 плюс A1 на t в степени n пополам, все это надо умножить на B0 плюс B1 на t в степени n пополам.
Это равно. Чему это равно?
Ну это равно на самом деле.
Если пораскрывать скобки, я сразу напишу.
A0 B0 плюс t в степени n пополам на A0 B1 плюс A1 B0 плюс t в степени n на A1 на B1.
Все делается элементарно.
То есть мы делаем 4 рекурсивных вызова, получаем какие-то произведения и после этого за o от n исхлопываем.
За какое симптомико это работает?
Получается, t от n равно 4t от n пополам, плюс o от n.
Я даже раскрывать эту 8 точку не буду, у нас есть мастер теорема, который говорит нам о том, что t от n равно чему?
N в степени логарифом по основанию 2 от 4.
Молодец, красоба.
Это n квадрат.
А теперь, говорит этот студент, заметим, что вот эта вот штука,
каждую из этих двух штук нам вычислять не надо, нам надо только сумму.
И эта сумма оказывается равна следующей штуке.
A0 плюс A1 на B0 плюс B1.
Вот.
Да, только надо, ну по модулю там что-то надо вычесть, но то, что надо вычесть, на самом деле вычислять уже не надо.
Потому что вычесть надо в точности A0 B0 и A1 B1.
Красота.
Но тогда получается, то есть по факту получается, да, у нас конечно увеличивается константа, но вот этот вот от n остается от n.
А количество произведений вместо 4 становится 3.
И здесь логарифом уже не 4, а 3.
Ну, в рекурренте.
Да, то есть мы сказали, что эту штуку, оказывается, можно вычислить вот по такой формуле.
Заметим, что вместо того, чтобы вычислять каждое из этих произведений, надо вычислить вот это произведение, ну и вот эти вот 2.
И, собственно, после этого эта штука вычисляется.
А, у нас 3 произведений.
Ну да.
Ну вот, так что вот такая получается магия.
То есть получается в 3 строчки. Мы говорим, что получается, что умножать многочлены быстрее, чем за n квадрат.
Вот вам, пожалуйста.
А почему там написано дальше, что это от n квадрата?
А, да.
Да, правильно написать, что теперь это приблизительно θ от n в степени 1.58.
Бла-бла-бла.
Вот. Да. Соответственно, да.
Ну вот, как всегда, я люблю иногда задавать такой человекашний вопрос, если лекция не связана с этим.
Как звали этого студента?
Да, студента звали Анатолий Александрович Корацуба.
Да, совершенно верно.
Вот. Ну то есть, да, там дальше уже легенда гласит, что там Колобогоров просто это трижды поменялся в лице и побежал это публиковать.
Не-не-не, конечно, от имени Корацубы, но просто там дальше легенда как-то использует какие-то административные лазейки, чтобы это публиковать как можно быстрее.
То есть там просто едва ли бы уже принятую к печати статью, там как будто быстро что-то допилили, как будто второй не связанный с ней раздел, в котором было вот на страничку описано вот это.
Ну вот, получился это просто вот, ну потому что действительно прорыв.
Как на том сценаре сказано, то с три тысячи лет никто не мог заметить что.
То есть вот это называется на тему того, что все, что можно просто придумать, уже придумали до вас.
Вот пример того, что это может оказаться не так, просто никто...
Ну понятно, то есть как бы все в математике открывается отчасти по принципу, да, ну там во многом, конечно, из того, что вы там знаете много старых идей,
но обнаружили, что на что-то вот просто под правилем углом никто не посмотрел, а вы посмотрели.
Вот.
Ну вот.
Так что побежали публиковать и вот оказывается.
Но сразу какой вопрос в науке тут, конечно, возникает.
А нельзя ли бы, да, то есть нельзя ли побыстрее?
И первая даже идея.
Вот вы тут поделили на два.
А не получится ли быстрее, если поделить на три, например?
Вот давайте можем даже, вот знаете, я вам даже там по, называется, сколько-то минут дам, вот попробуйте.
Как думаете, если поделить наращение на две части, а на три, можно ли пошаманить так, чтобы получилась более быстрая симптомика?
Вот.
Ну я тут даже пока, даже напишу, что нам примерно надо вычислить.
На Е-части?
А?
Нет.
На Е?
Почему на Е?
Может, ну Е с точностью до константа это все равно?
Да.
Ну вот, давайте вот посмотрим.
Если А равно, допустим, A0 плюс там A1 на Т в степени N на 3, плюс A2 на Т в степени 2N на 3, да?
Ну это я пока пишу, вы уже там, вы пока думайте.
Так.
N на 3 плюс B2 на Т в степени 2N на 3.
И, соответственно, пишем.
АВ равно, ну тут можно сразу написать, A0B0 плюс, значит, A0B1 плюс A1B0 на Т в степени N поделить на 3, плюс A0B2 плюс A1B1 плюс A2B0.
А, это еще не все.
А нет, это все.
На Т в степени 2N на 3, плюс там, что там еще?
А1B2 плюс A2B1 на Т в степени N, ну и плюс там A2B2 на Т в степени 4N на 3.
Ну вот, спрашивается, к скольким рекурсивным произведениям многочленов размера N поделить на 3 это можно свести?
Ну, видимо, не меньше, чем 5.
Ну да уж, как-то меньше, чем 5, действительно, сомнительно.
Так, ну давайте, 7 каким образом?
О, 6 можно, ух ты.
Так.
6 остальных это каких?
Ну давайте так вот.
За 5? Ух ты.
Ну каким образом?
Так, ну давайте, ладно, давайте 6.
Так, давайте так вот.
Так, давайте, там кто-то заклассал, значит, за 6.
Вот так, начнем вот с этого.
А, за 7, ну давайте, хожу, вот это вычислили, дальше.
Так, дальше, еще.
Так, A0B2, A1B2.
A0B1.
Этого хватает?
Ну у нас вот верхнее вот это общее тоже есть, так.
Так, вы утверждаете, что этого хватает?
А почему этого?
А, ну потому что, а, если мы из этого вычтем вот это, это и это, то получится A0B1 на B0B1, да?
А из него мы вычитаем это и это, получаем вот это.
Так, вот это мы получаем, а вот это мы получаем откуда?
Я считаю.
Что мне продиктовали, то я сказал, я написал.
Всего в тупую произведение 9.
А, то есть считаем, считаем все кроме средних, да?
Да, без средних мы считаем все кроме средних.
Вообще я хотел A0B1 на B0B1, A0B2 на B0B2, A0B2 на B1B2.
А верхнее не нужно помешивать?
Ну там по-разному, да.
Ну давайте я вот так уже напишу.
А нет, тут A0A1 на B0B1, так.
И что там еще хотелось?
A0B0A1B1A2B2, вот.
Утверждаете, что этого хватает?
Еще A0B2 плюс A0B2?
Ну тогда типа просто сразу вверх.
Ну можно и так, да.
Мы на каждую столбку написали.
Ну пожалуйста, пожалуйста.
Ну можно и так, можно и это, видите, тут суть одна.
Да, ну хорошо.
Да, то есть...
Ой, ой, ой.
А, ну...
В смысле, A0A2 на B0B2.
А, то есть прямо вот...
Ну блин, у нас две уже такие столбки есть.
Так.
Ну давай, давай без блин только, пожалуйста.
Так, а тогда...
Окей.
Так.
Ну действительно, да.
Заметим, что из этой суммы вот этих штук мы получаем как минимум вот это.
Так, вот это мы получаем из этой штуки вот этих.
Вот из этой штуки каких-то вот этих мы получаем с одной стороны вот это плюс вот это.
И еще добавляем вот это, оно тоже есть.
Да, ну вроде справились.
Ну это асимпатически получается n в степени log3,6.
А теперь мы добавляем plus, log3,6.
Больше.
Ну вот больше, откуда вы знаете?
Вы уже в калькуляторе проверили?
Нет, я так просто слету просто я не знаю почему.
То есть нет, я знаю, что как бы да, это меньше.
То есть это больше, да, это я знаю.
А, хотя нет, это легко.
Так, хотя тут вот...
То есть log3,6 мы сравниваем с log2,3, да.
1 плюс log3,6.
Ну да, то есть это да.
1 плюс log3,2.
И тут, а тут получается 1 плюс...
Просто log3,6.
Чего?
Просто log2,4.
Так, log2,3.
И что?
Вычтем.
1 плюс 1 делить на log2,3 против log2,3.
И кто больше?
Не, ну как сказать?
Тут вы...
Ну ладно, лучше на калькуляторе посчитайте
и убедитесь, что это больше.
Поэтому если мы хотим здесь
выжать максимум, то как-то надо
как-то обойтись 5 произведениями.
А?
А при четверке там что будет?
Ну давайте сходим в стройка, разберемся
для начала.
Ну мы уже жили в стройке.
Нет, у нас получилось 6 и мы обнаружили,
что это хуже.
Поэтому есть мечта, а может быть пятерка?
Пятерка, я там сразу скажу, будет лучше.
Она есть?
А вот вопрос.
Ну нет, я могу за 5 минут
потребовать доказать, что нет.
Поэтому, да, на самом деле утверждение есть.
Даже вот интересно, хочется попробовать.
Получится.
Спасибо.
Спасибо.
Спасибо.
На компьютере можно перебывать.
Спасибо, что мы выбирали 5.
Да.
Зависит, сколько-то по 5.
О, блин.
О, блин.
Ну внимательно надо
слушать было.
Пытаемся придумать,
как здесь делать не 6 произведений,
а 5.
Ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
так так это раз что еще оставить сейчас так вот эту сумму взяли так вот эту сумму вот
эту и вот эти я правильно понял а то есть вообще 4 так а 2 б 2
так и так сейчас ну вычекиваем да но тут
то есть как бы мы мы как бы вычеркнули вот это и добавили вот это то есть мы
утверждаем что как минимум вот скажем что каждый из них мы каким-то образом видимо восстановим
но это шестое мы же на 5 ставим ну нет ну есть подозрение что нам как-то все-таки 5 значений
надо найти так сейчас еще часки да ну то что хотим
я ну как сказать вот человек что идем пока не придумала как доказать шушу вот быстрее
там нельзя нет можно там доказать что быстрее чем меньше чем за 5 нельзя потому что там доказать
что они там какие там линейно независимые там там все дела вот это все то есть мы хотим там то
есть доказать что мы хотим вон тут тоже послагаем и какого-то такого вида поэтому доказывает что
мы там можем из них получить только линейное пространство не линейно независимый блаблабла
мы все то есть там в этом поэтому меньше пяти да но как бы сделать за 5
но да не такая тривиальная задача но это называется да
но кто-то кто-то нашел я не знаю честно я честно то же свое время нашел то есть
знаете это делается очень просто вы приходите на чайную церемонию там ритуал чайного молчания
там была трейсер прихожу а там ритуал чайного молчания значит ну то есть вам просто наливают
чай но там сообщает что это за чай но как бы вы должны молчать ну подразумевается что вы там
в течение часа полутора должны там погрузиться в себя действительно размышлять о своих проблемах
там каких-то вот там что-то решать задачи но конкретно в тот момент у меня никаких проблем не было
не но там нет там чи были разные там пуэру лун там еще какие-то умные слова там в которых я
честно говоря к сожалению не разбираюсь вот нет нет это было не в чайном ките это в локусе было
но не важно вот а чайный кит кстати по моему как минимум переезжает но неважно вот так вот ну
вот но соответственно но поэтому думали но вот поэтому действительно собственно чем заниматься
тра ну соответственно вот возникает думать а как же тут действительно сделать из трех слагаемых
побыстрее но вот но в результате в результате попив попив чаю действительно в хорошей тихой
компании можно придумать следующее смотрите значит я предлагаю след на самом деле ну вот
то есть слагаемый можно сделать такие а 0 на b значит а 0 плюс а 1 плюс а 2 до b 0 плюс
b 1 плюс b 2 сейчас будет вообще внезапность а 0 плюс 2 а 1 плюс 4 а 2 на то же самое так ну
и сколько там нам 5 слагаемых надо да пожалуйста пишем тройбан вот плюс там 9 б 2 и что-то еще
пишем ну что-то еще то же самое с четверчкой вот б 0 плюс 4 б 1 плюс 16 б 2 вот но на самом
деле как вы уже заметили конечно что да то есть здесь на самом деле можно было написать тоже
1 умножить на и там 1 в квадрате умножить да а тут можно было написать а 0 плюс 0 умножить на
а 1 да плюс 0 умножить на 2 то есть как бы мы можем сказать так что мы представили а и
б как догочлен третьей степени по сути да ну просто в идеале мы хотим подставлять
т в степени на три но будем подставлять что-нибудь еще просто получается следующее просто заметим
просто ну то есть на самом деле просто по факту если сказать что вот это вот допустим ну там
рекурсивно как и быть заменим на какую-нибудь еще букву например там д0 вот это вот на д1 вот
это вот там получается д2 вот это вот д3 и там соответственно вот это вот это д4 да то на самом
деле мы можем получить что вот эти вот числа всякие там допустим а 0 плюс вот вы хотели x
плюс x а 1 плюс x в квадрате а 2 на b 0 плюс x на b 1 плюс x 2 на b 2 то есть на самом деле это
равно в точности то есть получается д 0 плюс д 1 на x плюс д 2 x квадрат плюс д 3 x в кубе плюс
4 x 4 все то есть получился такой обнарочен и вы получили его значение в пяти точках то есть все
что вам то есть все что вам остается ну там то есть получаете эти дешки то есть вам нужно найти
по сути эти дешки и у вас есть какая-то матрица там матрица матрица вендермонда по сути умножен
Потому что, наверное, D равна, соответственно, вот этим вот значениям.
То есть я прям вот здесь и напишу.
То есть так и напишем.
1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4, 8, 16, 1, 3, 9, 27, 81, 1, 4, 16, не перепутать, 64, 256 на, соответственно,
D0, D1, D2, D3, D4, равно вот этому вот.
А вы этого мне посчитали?
Нет, у меня бумажки-карадашки там были.
Нет, я не помню, вот что у меня там K5 у меня и без этого выплыло, а потом стал думать дальше и как бы обобщилась вот так.
Потому что, ну, заметим, да, вам придется, конечно, обратить эту матрицу, но это делается за константу, за константу вычислений заранее.
Можете это в захард кодить потом, эту обратную к этой матрице, но как бы нали-нали вы, наверное, уже знаете, что обратное существует и единственное, да?
Ну, я не знаю, вообще, нали-нали вы должны, что у такой матрицы определитель не нулевой и даже знать, чему он равен.
Не, матрица нужна, это может быть.
Ну, это же определитель.
Какой безобразный.
Ну вот, ну ладно, покажите, просто поверим, как простой факт, что матрица, скажем так, если я в каждой строчке напишу степени вот от нулевой до N-1 каких-то чисел, эти числа будут по парам различны, то определитель будет не нулевой.
Если он будет равен, там переберем все пары чисел и там нужен определитель их разность.
Ну, там типа более низкая минус более ранняя.
Вот это можно, там это при желании в качестве упражнения можете там даже подоказывать.
А можете погуглить, матрица Вандермонда.
Вот давайте я напишу фамилию, вот Вандермонд одним словом.
Не через дефис, не морд, там вот это все, да.
Ну вот, а вот так.
Ну, получается, теперь N-степени лог 3,5.
Ну, 5 это константа.
Ну, вам один раз в жизни нужно обратить эту матрицу.
Константового размера.
То есть, получается, теперь решение такое.
Вы, значит, берете коэффициент, многочлены 0, 1, 2, 0 за линию находите.
Рекурсивными запусками, вычисляете вот там, вычисляете вот эти вот значения, вот эти вот многочлены.
Находите эти перемножения вон там рекурсивными запусками.
А, потому что здесь еще вот B0 плюс 0 на B1 плюс 0 на B2.
Находите их рекурсивными запусками.
Пятью рекурсивными запусками.
И потом по вот этим значениям среди многочленов вы их обнажаете на матрицу.
Ну вот.
Да, ну, константного размера.
И получаете еще.
Ну, точнее так, это уже значение.
Я это уже число напоминаю, да?
Нет, хотя нет, это не число.
Это многочлены.
То есть, у вас получается многочлены.
То есть, у вас там получается многочлены.
Вы их домножаете на матрицу, получаете пятерку многочленов.
И из них потом, собственно, получаете и итоговый результат.
За сколько мы умеем обращать матрицу?
Да какая разница за констант?
Матрица константного размера обращается за константу.
А там нам надо будет делить на короткое число, да?
Ну да, ну или там написать...
Ну вы там напишите, можно написать какие-нибудь там рациональные числа.
Это не проблема.
Вот.
Значит, так, кто-то из вас уже посчитал, наверное, на калькуляторе,
что это получается, наверное, меньше, чем m в степени log2,3, да?
Получается 1,46.
Так, уже неплохо, да?
Вот в корень уложились.
Но на самом деле, можешь мыслить дальше.
А если константа не 3, а 4, то заметим, что мы тоже тут можем развлечься.
То есть значение пронтует и будет не 5, а уже 7.
И матрица тут будет 7 на 7, да?
Но это все еще константа.
Мы ее все равно один раз вычисляем.
Да, мы ее один раз вычисляем.
И получается, теперь дальше получается, получается еще меньше.
m в степени log4,7.
И вообще получается в итоге, что у вас для любого k получается,
ладно, не k, то есть если вы выберете константу там какую-нибудь,
то есть будем делить на там допустим l частей,
то у вас получится асимпточка m в степени log по основанию l,
2l минус 1.
Ну l это же константа, да?
Так, куда у нас стремится?
Вот, log по основанию l, 2l минус 1.
К чему?
Если это стремится к бесконечности, то это стремится куда?
Правильно, к нулю.
Ну просто потому, что это не превосходит, а хотя нет, неправ, к единице все-таки.
Да, да, к единице.
Ну потому что это, ну потому что log, если бы единицу это убрали сверх,
log l, 2l это то же самое, что 1 плюс log по основанию l, 2, это точно стремится к нулю.
Поэтому это стремится к единице.
Вывод отсюда. В результате есть мистическая теория.
Но как бы заметим, что у нас это не значит, что мы придумали алгоритм,
который работает за O от N.
Это означает следующий факт.
Для любого epsilon больше нуля существует алгоритм перемножения многочленов размера N,
работающий за O от N в степени 1 плюс epsilon.
Ну да, для достаточно большого N.
На самом деле еще хуже.
Мало того, что достаточно большого N, так еще и в предположении, что у нас эти коэффициенты достаточно короткие.
Потому что когда у тебя будет, скажем, если у тебя там будет 100 тысяч, то у тебя тут будет 100 тысяч в степени 100 тысяч.
То есть поэтому как бы совсем прям любое, это только еще в наглом предположении, что у вас числа там,
ну то есть либо совсем мелкие коэффициенты, либо вы предполагаете, что у вас компьютер умеет работать с достаточно большими числами.
Нет, это можно рекурсивно посчитать.
Ага, ну еще там что-то допиливать.
Ну может быть.
Ну это все допиливается с R степени 1 плюс epsilon.
Ну может быть, да.
Честно говоря, не знаю.
То есть в принципе, да, вот оказался такой интересный факт.
Там по-моему фамилия, там по-моему это называется что-то типа алгоритм Шенхагео-Штрассена.
Ну то есть я не знаю, может быть это они там что-то по-другому делали.
То есть честно, я как бы что придумал, то рассказал называется.
Ну естественно, да.
Так что вот оказалось.
Но правда, смотрите, тут интересная симпатическая подлянка.
Что то, что мы для любого epsilon умеем решать с степень 1 плюс epsilon, это не означает, что мы умеем решать за линию.
Да.
Сейчас, а мы, вот это разуждение при увеличении деления на большее число частей.
Все равно сохраняется то, что a0 плюс x1 плюс x квадрата 2.
Ну и плюс и так далее, на сколько частей разделили.
Ну конечно.
Ну конечно.
Ну по факту, смотрите, мы здесь написали абсолютно то же самое, только вместо x стояло t в степени на 3.
Вот собственно и все.
То есть да, то есть это в общем, да.
То есть в общем-то, как на самом деле заметил еще, собственно, называется еще мой, то есть собственно мой научный руководитель.
Он заметил, что в общем-то в каратсубе мы тоже вот что делаем.
Мы представляем, что действительно a0 и 1 это такие действительно многочленные степени 1 или размера 2.
Ну и в которые мы пытаемся подставить константы там скажем 0 и 1 на самом деле по большому счету.
Вот.
Ну то есть на самом деле да, то есть здесь конечно не совсем то, но по большому счету единственное различие от этой схемы, что вот тут вот есть,
то есть как бы вот a0, b0, то есть мы посчитали бы a0, b0, а вот эту вот штуку и то же самое, только тут еще двойки бы стояли.
То есть ну мы вместо этого там посчитали 1, b1, это проще, но суть на самом деле такая.
А?
Да, на самом деле это парадокс в том, что если мы придумаем алгоритм, который работает за n log n, то он уделает все вот это.
Вот.
Да, обратите внимание, да, что все эти алгоритмы n log n уделывает.
Да, то есть помните, то есть видите тут вот 7 точек, это конечно такая нетривиальная вещь.
Вот.
Так.
А сейчас.
Сейчас.
Так вот.
Вот.
Так вот.
Так вот.
Чего такие проблемы? Не понял.
Ну если l увеличиваем, то как бы вот у вас там, ну во-первых, по факту у вас будет и матрица большая, хоть и константовая, но очень на практике очень большого размера.
Но самое главное проблема, что там в этой матрице числа будут огромного размера.
Поэтому как бы этот алгоритм не работает в модели, в которой, например, у вас, ну скажем, в нашей любимой модели w-bit в чисел это работает так себе.
Да.
Да, потому что везде получается матрица Вандермонда.
И мистический факт из науки, что вот конкретно матрица такого вида, они линиями независимы.
То есть они имеют не нулевой определитель.
Как я сказал, это называется матрица Вандермонда.
Ну странно, не знаю, у нас в курсе линала такая матрица была.
Как-то вот откуда-то она возникала.
Так вот.
Значит попробуем, поэтому давайте, ладно, тут мы, значит, прекратим, значит, это все шаман, немножко прекратим.
Соответственно, тут делать такие шаманства и пойдем другим способом.
Соответственно, тут делать такие шаманства и пойдем другим способом.
Собственно, еще одним, значит, пойдем еще одним вариантом разделяй и властвуй.
Значит, смотрите, то есть попробуем внести сюда, то есть как бы это, то есть это мы называем выжимали максимум из одной идеи, что многочлен можно разбивать на две части.
Но на самом деле возникла идея, что можно не просто разбивать многочлен на две части, а вот,
а еще, но развиваться следующей мыслью.
Вот давайте думать, чтобы задать многочлен, нам нужно n чисел.
Ну если мы хотим задать многочлен размера n, да?
Ну теперь возникает вопрос, а что это за n чисел?
Вот какими n числами можно задать многочлен?
Ну самый простой метод, казалось бы, да, просто написать его коэффициент, что тут думать?
Но с другой стороны, а есть альтернативный метод.
Если я знаю, что многочлен размера n, на самом деле я утверждаю, что мне хватит, если я буду знать значение этого многочлена в точках 0, 1, 2, ну и так далее, n-1.
Ну потому что, вот вы знаете, что у вас был многочлен в степени, то есть размера n, и вы знаете его многочлен значения в n точках, да?
То есть тогда вам придется просто решить систему 1, 0, 0, там и так далее, 0, там вот такого вида a1, a2, a n-1.
У вас n-1 точка должна быть.
Нет, размер n, нет, у нас размер n, степень n-1.
Это важно.
Вот поэтому очень удобно мыслить в терминах размера, тем более, что вам алгоритм все равно будет произвеваться, забирая вперед, что вы тут будете нолики пушбекать туда в конец.
То есть размер увеличивается, степень нет, поэтому лучше давайте мыслить в терминах размера, это как бы ближе к, так сказать, физической сути происходящего.
Вот.
Значит, тут соответственно у нас, да, a от 0, а вот эти значения мы знаем откуда-то, a2 и a от n-1.
То есть вот такая если, ну вот тут 1, 0, 0, тут 1, 1, 1, 1, 1, тут 1, 2, 4, 8 и так далее, там 2 в степени n-1, тут получается 1, 3, 9, там 27 в степени, там даже 3 в степени n-1, ну и так далее.
Да, тут a3.
Ну вот.
Вот.
Ну то есть, вот.
Ну то есть, если вы фактически систему уравнений говорите, чтоб жил был многочлен, мы не знаем коэффициентов, но знаем, что в точке 0 он равен вот этому, в точке 1 вот этому и так далее.
То же самое, что как бы у нас вот эти коэффициенты удовлетворяют вот этой системе уравнений.
Вот, понятно, да?
Да.
Вот.
Так что все, что вам остается, это как бы обратить, то есть скажем так, то есть мы знаем, что эта матрица опять в андермон, да?
Она, у нее определить не равен нулю, значит решение этой системы существует и единственно.
То есть следовательно по значениям многочленов этих, в точках 0, 1, 2 и так далее, n-1, многочлен восстанавливается однозначно.
Понятно, да?
Более того, на самом деле, заметим, что мы к 0, 1, 2, 3 и так далее можем не привязываться.
Если я тут напишу 2, 3, 5 и так далее, и тут напишу какое-нибудь там p, n-ное какое-нибудь там, то есть n-ное простое число, например, да?
То суть от этого не поменяется.
То есть конечно матрица конкретная поменяется, тут будет 2, 2 в квадрате, 2 в кубе и так далее, 2 в n-1, тут будет 3, 3 в квадрате, там 3 в кубе, там 3 в n-1, там сколько там? 5, 5 в квадрате, 5 в кубе и так далее, 5 в степени n-1.
Ага, ну и так далее, и там соответственно p, n, p, n в квадрате, p, n в кубе и так далее, p, n в степени n-1.
Вот такая красота. То есть матрица поменялась, суть нет, потому что она все еще обратима.
Еще раз, как мы спрямуем матрицу?
Я даже не умею отвечать на этот вопрос, если честно.
Ну просто если мы знаем многочлен, его значение в точках 2, 3, 5 и так далее, это эквивалент, вот если эту матрицу перемножить на коэффициенты, это то же самое, что в этот многочлен подставили 2.
То есть в первой строчке двойку, тут потом тройку и так далее.
Ну вот, все то же самое.
Да, только разница в том, что здесь я конечно надо не 0, 1, 2, 3 писать, а писать именно там 2, 3, 5 и так далее, p.
И вообще к числам можно не привязываться, это могут быть n различных чисел, в чем сами по себе эти числа абсолютно различны.
То есть если я тут напишу какие-нибудь заранее фиксированные числа t0, t1 и так далее, tn-1, то неожиданно обнаруживается.
Ну вот, то как бы восстановить, если у меня эти конечно t-шки известны, то здесь я тоже абсолютно то же самое пишу.
То есть 1, t0, t0 в квадрате и так далее, t0, tn-1.
Тут 1, t1, t1 в квадрате и так далее, t1 в степень n-1.
1, t2, t2 в квадрате и так далее, t2 в степень n-1.
Да, то есть надо, что действительно t-шки, то есть jt равно tk тогда и только тогда, когда j равно k.
А с чем мы найдем решение?
Ну с того, что это снова матрица Вандермонда.
А это тоже матрица Вандермонда?
Да.
В практике вот определение.
Матрица Вандермонда это когда мы берем n чисел и пишем вот это все.
Ну ладно, может матрица Вандермонда вот эта транспонированная, конечно, но это уже детали.
Ладно, от транспонирования матрицы ее ранг не меняется, как вы помните.
Мы проходили ранг в случае 2 на 2 и 3 на 3.
Нет ранг, ранг.
Ну определить, определить, там определение определителя такое, что очевидно, что не меняется.
Так что вот, так вот, ну вот и тут соответственно понятно.
Вот, то есть тогда к чему я это все?
Я это все к тому, к следующему.
К следующему.
Значит я это к тому, к следующему.
Что получается, если мы, ну потому что предположим, что мы мистическим образом умеем как-то переходить из вот этого формата в вот этот формат.
Тогда если мы это быстро делаем, то на самом деле получает, тогда нахождение произведения может выглядеть следующим образом, смотрите.
Дело в том, что, значит раз мы, вот допустим мы знаем а0, а1, а2 и так далее, аn-1.
Мы можем перейти к значениям a от t0, a от t1 и так далее, a от tn-1 соответственно.
Ну и тут давайте от t2 напишем для ровного счета.
Вот, где-то рядом мы тоже самое сделаем с многочленом b.
Вот были коэффициенты, стали значения естественно в тех же самых точках.
b от t1, b от t2, b от tn-1.
Вот.
Итак, вот допустим мы ищем, пытаемся найти многочлен c, который вот c от t, который должен быть равен a от t и b от t.
Заметим, что я теперь по вот этим двум последовательностям, я могу очень легко получить значения многочленов c в точках t0, t1, t2 и так далее.
То есть знаете, вот когда мы храним многочлен в виде значений в точках, то перемножать их очень легко, то есть надо просто поточечно поперемножать, правда?
Ну просто потому что c от какого-нибудь t-житого это очевидно тупо a от t-житого, умножить на b от t-житого, что тут думать?
Вот. Это мы прям за o от n времени потратили.
И что нам после этого остается?
Да, страдать остается, да?
А как мы так быстро посчитали за o от n?
Прямо?
А значения не могут быть большими?
Ну, предположим, что нет.
А как не могут?
Пока нот называется, поверим, что не могут.
Там достаточно хорошее t, вот так скажем.
Вот.
То есть пока нот, предварительно можем временно поверить, что мы умеем делать вычисления для произвольно длинных чисел.
Мы все равно многочлены перемножаем.
Ну, по факту реально нот.
И тогда раздаем значения в точках c.
Теперь мы обратным переходом получаем вот-вот-вот, соответственно, c0, c1, c2 и так далее, cn-1. Ура!
Ну, кажется, нам надо, правда, больше точек для интерполяции.
Вот.
Ну да, есть одна действительно маленькая тонкость.
Маленькая тонкость заключается в том, что по n значениям многочлены c восстановить вряд ли получится.
Потому что размер многочленов заведомо больше, чем n.
Вот, поэтому идея такая. Докидаем тут ноликов.
И докидаем лишних t-шек.
То есть пусть у нас t-шек будет 2n.
То есть тут тоже докидаем 0, 0 и так далее ноликов.
То есть докидываем тут t, n и так далее b от t2n-1.
И тогда мы уже получаем у c-шек 2n-2n точек.
И после этого получается восстанавливаем все 2n коэффициентов c.
Ну, на самом деле их не более чем 2n-1, то есть это по-любому 0 будет, но давайте для ровного счета оставим.
То есть вот такая схема.
Да, рискну, конечно, наврать, но это называется схема Кулитьюки такая.
Хотя может это не она, ладно, неважно.
То есть смотрите, если мы умеем мистическим образом переходить для многочлена от вот такого вида к вот такому и обратно,
то мы тогда за такую же асимптотику умеем и перемножать два многочлена.
Вот, понятна схема?
То есть основная задача это по значению в точках получить коэффициенты?
Да.
Ну, точнее так, надо по коэффициентам быстро получить значение в точках и по значениям в точках получить, наоборот, значение коэффициентов.
Коэффициентов.
Чего?
Нет, коэффициентов 2n.
Ну, мы будем считать, что 2n для простоты.
Хоть этот, конечно, почти, наверное, 0, но не почти, наверное, просто 0.
Потому что там при перемножении наращения в степени не более чем n-1, получится наращение в степени там не более чем 2n-2.
Но тем не менее нам будет удобно так считать, потому что вот это вот требование, что n у нас степень двойки, оно никуда не девается.
Вот нам то, что n это степень двойки, продолжить быть удобно.
Так вот.
Итак, внимание.
Какой задачи мы а?
Сработает.
Если мы еще посчитаем, добавим еще пару ноликов и посчитаем значение многочлена a или значение многочлена b в какой-то еще одной точке.
Ни в одной?
Нет, кроме этих, кроме тех, которые мы еще добавили, мы добавим еще по ноликам, ну, сколько-нибудь ноликов.
Ну, не сколько.
А зачем?
Будем получать нули в цшках следующих или нет?
На самом деле, ну, будем, конечно.
Получится многочлен размера еще большего размера, размера как минимум 3, но как бы все равно, какая разница, если все равно его значение это произведение.
Хорошо, а до этого цшки, которые мы получали, до cn-1, мы получали цшки, которые будут совпадать с конечным многочленом?
Ну, конечно.
Ну, в смысле, они будут совпадать, да, потому что значение многочлена c в каждой точке это произведение значения многочлена a в этой точке и значение многочлене b в этой точке.
Это определение понятия произведения многочленов.
И мы ждем то, что коэффициенты при многочлене c длиной n, которые мы получали до этого, и коэффициент при многочлене, ну, первой n коэффициент...
Нет, там будет...
Они не будут совпадать.
Не, не будут, это другое, к сожалению.
А почему еще?
Ну, ладно.
Ну, потому что проблема в том, что мы знаем, что произведение, ну, дорожчение c имеет произведение, то есть он, как бы, дорожчение на размере 2n.
Следовательно, по значениям в 2n точках его можно восстановить.
Ну, следует, поэтому мы эти 2n и подгоняем.
Вот, итак, задача.
То есть теперь n в 2n можно забыть.
И теперь говорим, что у нас есть n равно 2 в степени k, у нас есть только один многочлен.
То есть a t равно вот этот вот a 0 плюс a 1 t плюс a 2 t квадрат плюс и так далее e.
И это должно быть со a t 0, a от t 1, a от t 2 и так далее, a от t n-1.
Надо вот в обе стороны это как-то делать.
Ну, каким образом делать?
И теперь следующий лайфхак.
Как вы могли заметить, какие конкретно t-шки мы можем выбирать под свое удобство, правда?
То есть схема устроена так, что t-шки выбираем мы.
Так вот, t-шки мы выберем следующим образом.
Значит, n равно 2 в степени k, помните, да?
Так вот, я попробую зафиксировать такое число w n, удовлетворяющее следующим свойствам.
Во-первых, w n в степени n равно 1.
И можно написать так, w n в степени n пополам не равно 1.
А вам слабо.
Это называется.
А, но еще будет желательно подогнать так, чтобы w, условно, n пополам было равно, конечно, w n в квадрате.
Вот еще я себе дополнительное требование такое сделаю, чтобы это было удобно.
Я хочу найти одно такое w n.
Чего?
У нас же уже n использовано под размер, почему мы еще раз взяли, поставили n?
Потому что для, ну я рассматривал n в степени 2, и для каждого n я выберу одно такое число w n, обладающее вот такими свойствами.
Так, может быть какой-нибудь другой переменный обозначим?
Потому что у нас же n под размер занято.
Нет, w, вот это w важное, оно именно от n зависит.
Так, хорошо, а для любого n равно?
Равного 2 в степени k, я скажу, ну то есть w, ну их бывает несколько таких w, но я буду выбирать так, что w с индексом n пополам должно быть равно w n в квадрате.
И куда мы уже поставляем все любые n, которые являются степенями?
Чего? Ну вот сюда, да. Ну и для любого n мы такие подбираем, да.
На всех n являющихся степенями 2 мы выбираем w n.
Чего? Мы одно число ищем в итоге.
Ну пока одно, оно будет порождать все остальные.
Да, правда, ну правда тут можно сказать, сразу возникает ощущение, что да, в действительных числах вы такого вряд ли найдете, да?
Ну если n хотя бы 4.
То есть знаете ли вы такое число, что у него четвертая степень равна единице, а квадрат не единица?
В действительных числах?
Но предположим нам повезло, и мы перемножаем многочлены не в действительных числах, а в более адекватном поле.
Ну что такое поле же, вы знаете?
Вы знаете?
Вот давайте, ну более адекватное поле, это поле в котором, ну я не знаю, можно найти какой-то более адекватной корененной степени из единицы.
Ведь что эти свойства по большому счету значат?
Эти свойства, ну вот, потому что какие я t-шки хочу предложить?
Я хочу предложить в качестве t-шек такие, что t g t у меня должно быть равно w n в степени g.
Ну то есть в качестве t-шек я хочу, чтобы это было 1, w n в первой, w n в квадрате и так далее, и тут w n в степени n-1.
Но я утверждаю, что вот этого вот необходимой достаточно, чтобы эти, ну ладно, необходимой не обязательно, конечно.
Но я утверждаю, что вот этих условий достаточно для того, чтобы сказать, что эти чиселки попарно различны.
Ну там тоже такое простое упражнение на УКТЧ.
Там с алгоритмом, у вас там может алгоритм Евквита там где-то встретиться в доказательстве и так далее.
Ну вот, но это уже мелочи, это уже технические детали.
Вот, то есть ну и так же там легко доказать, что если вы живете в поле, то это понятно, что в какой-нибудь поле не будет делителей нуля, естественно, но в поле нет делителей нуля, то у вас тут обязательно будет минус 1.
Ну потому что если у вас уравнение x квадрат равно 1, то как бы это по-любому эквивалентно тому, что x минус 1 на x плюс 1 равно 0.
И если делителей нуля нет, то x, то получается либо x равно 1, либо x равно минус 1, тут без вариантов.
Так, но это мелочи.
Нормально мы его определили.
Нет, мы пока даже не определили, а задекларировали, что Wn мы выбираем так, что оно удовлетворяет вот таким свойствам.
У нас, во-первых, n степень двойки.
Да, n степень двойки, это важно.
Ну там потому что, так как так у нас Wn степень n равно 1, то как бы минимальный период будет либо n, либо делитель n.
А все делители n это степень двойки как раз, поэтому там получится, что если еще какой-то степень какого-то делителя n равно 1, то степень n пополам тоже будет 1.
Вот, вот, вот.
Так вот, чего?
А это нам будет удобно просто.
Нет, нет, ну просто заветьте маленькое приятное свойство, что Wn в квадрате подходит, если бы у нас размер многочлена был не n, а n пополам.
То есть оно вот буквально этим свойством удовлетворяет.
Нет, конечно.
Ну просто нет.
Вот, так что-то такая красота получается.
Значит, ну краткая идея, откуда мы вообще это Wn возьмем?
Как мы сказали, в поле действительных чисел такого нет, в поле рациональных чисел тоже тем более.
Ну у нас?
Ну в Z по PZ тоже как повезет.
В смысле?
Ну как бы там все будет зависеть от того, имеет ли отношение число P-1 к степеням двойки.
Ну да.
Так что не совсем все.
Ну давайте так, то есть самое простое и общее решение, говорят, давайте выйдем в поле комплексных чисел.
А как вы?
Ну комплексные числа у вас уже были?
Вот, так что-то как-то сомнительно были.
Да, у вас во втором классе прямо это cos и sin было, да?
Вот.
Ну идея здесь простая.
Что?
Ну действительно, чтобы просто объявить, то есть как бы в комплексный классический вариант Wn это просто E в степени там 2Pi поделить на n.
Или что то же самое, cos 2Pi n плюс I на sin 2Pi n.
Вот такое приятное число.
Ну что это за число?
Ну если вот в комплексных числах тут порисовать чуть-чуть, то мы обнаружим, что вот у нас единичная окружность допустим, да?
То тогда дальше у нас получится примерно следующее.
То есть вектор, соответствующий этому числу, это вот единичный вектор с полярным углом 2Pi n.
Приятно он тем, что если вы его будете возводить в степени, то вы получите, если это Wn, то это будет Wn в квадрате, это будет Wn в кубе, и вот эти все углы будут равны.
То есть вот как-то вот так это вот красиво будет выглядеть.
Правда тут я для m равно 20 конечно рисую, вот такая красота примерно получится.
Но суть вы поняли.
То есть вот легко обнаружили, что Wn удовлетворяет этому приятному свойству.
Это не единственный вариант.
Иногда бывает, многие спрашивают, почему в последнее время в олимпиадной информатике завирусилось мистическое число 98244353.
И вас очень просят находить ответ по модулю именно вот этому, а не этим вашим миллиардом 7.
Секрет очень простой.
Дело в том, что это равно, поправьте если я ошибаюсь, но по-моему это 119 на 2 в 23 плюс 1.
А что это означает?
Что это означает?
А это означает, что в поле, то есть если мы рассмотрим P по вот этому вот мистическому числу, то мы тогда знаем, что в этом поле есть 119 на 2 в 23 ни нулевых остатков.
Правда?
Ну мы там знаем...
Ладно, сейчас.
А, поле не P называется, там вот Z вот так называется, да?
Так вот, в этом Z работает малая теорема фирма, которая говорит о том, что любого X не равного нулю.
Там верно, что X в степени 998224353 минус 1 сравнимо по вот этому модулю мистическому.
Так короче, оно равно мод.
Все.
Вот, с единицей.
Да, это вот мод.
Вот, но это мы просто знаем, это как бы для любого простого мода верно.
А, это еще простое, это важно.
Вот.
Но на самом деле есть более мистическая теория, которая говорит о том, что в любом таком поле есть первообразный корень.
Что такое первообразный корень в ZP?
Значит, смотрите, определение такое.
Так, давайте я еще другой маркер возьму.
И напишем.
Значит, определение такое.
То есть там.
Доказывайте это не будет, потому что это как бы, если вы еще не доказали это на УКТЧ, то докажете обязательно.
Вот.
Ну как-то я не могу поверить, что у вас как-то в курсе УКТЧ вы обойдетесь без понятия первообразный корень.
Значит, первообразный корень в, соответственно, ZP.
Значит, первообразный корень в ZP.
Это такой х, что числа 1х, х квадрат, х кубе и так далее, х в степени p, минус 2, по парно, разли, нот, различные.
А, о, привет.
Туда уже можно сесть или лучше туда сначала?
Да, ты садись, в общем-то.
Не, элементы ZP.
Нет, почему?
Нет, это означает, нет, просто смотрите, по большому счету х, то есть как бы, если вы такой х находите, то в ZP мы этот х можем назвать х, то есть это w с индексом p-1, правда?
А теперь заметим, если у нас вот наша p оказалась равно вот такому числу, 119 на 2 в 23 плюс 1, тогда я могу найти на самом деле, то есть сказать, что w, допустим, 2 в 23, это равно, ну вот, то есть w с индексом, допустим, 2 в 23, это получается w с индексом mod-1,
и все это в степень, ну, по сути, mod по деликта 2 в 23, ладно, mod-1.
Ну, это как бы, ну, как бы вот я вот просто провел аналогию, да, то есть я хотел вот взять, хочу взять такую, то есть я сказал, w p-1 это такое число элемент ZP,
что вот все степени до p-1 включить на попарно различное, p-1 степень равна единице, ну, p-1 степень у всех равна единице, вот, ну и, соответственно, это называть первообразной коренью.
Вот мистическая теорема говорит о том, что он есть, но там, по-моему, всегда есть, там даже есть мистический алгоритм, который пытается найти его перебором, и там утверждает, что он достаточно быстро да найдется.
Ну, или можно спустить вероятность алгоритм, который там скажет, что вероятность того, что вы наткнетесь на, то есть есть теорема о том, что первообразный корень существует, а здесь следует там,
что, видимо, этих первообразных корней это φ mad p, поэтому, если вы тыкнете рандомный остаток, то там получается с вероятностью фiyat p поделить на p-1, вы соответственно найдете первообразный корень.
То фiat p-1, конечно, пардон, поделить на p-1, найдете первообразный корень. Стоится только написать адекватные тесты, является ли число первообразным корнем, да или нет?
да или нет. Ну для этого надо перебрать все делители числа по и минус 1,
возвести x в степень по и минус 1, делить на это делитель и получить там вот.
Так что ладно, потом это на 0,5 на камере поставите, собственно, там можете послушать.
А можно не слушать, потому что все это все равно будет только тч. Ну и в принципе это логичная
вещь. Ну а заветим, что если у вас есть вот уже по парно различных степеней уже размера 119
на 2 в 23, то если возьмете из этой последовательсти каждое 119 число, то у вас получится как раз такой
цикл из 2 в 23 чисел. То есть тогда это означает, что вот в таком zp получается вы можете находить
wn, вот n порядка 2 в 2 даже до 23 степени где-то. Обычно вы там в задачах перемножают многочлены
по модулю там размера порядка миллиона, поэтому получается этого вам хватит. То есть вот такая вот
идея. То есть там просто в некоторых задачах действительно идея бывает, что сделайте фурье только
вот не по комплексным числам, а вот поэтому вот. То есть я поэтому специально такое определение
написал, чтобы оно и для комплексных чисел работало и для простого модуля. Вообще оно будет
работать в любом просто в любом поле, в котором у вас найдется там элемент порядка 2, там
собственно порядка n по большому счету называется. Но найти первообразный корень и возвести его в
119 степень. Ну или там если вам нужно n, если n у вас 2 в 16, там 2 в 15 какой-нибудь, то вы
там этот вот первообразный корень возводите в степень 119 на 2 в 8 получается. Ну потому что тогда
у вас из этой последствия получится каждое 119 число, да? Причем заметим, что получится степь вот
1 х 119, х 119 на 2 и так далее. Ну если вы тут каждое 119 возьмете. Вот там 1 х 119, х в степени 119
на 2 и так далее. Но тогда получится, что этих всех чисел получается вот это поделить на 119 раз
меньше и они все попарно различны. Но х 119 в следующей степени там будет равно тоже 1 получается.
Но это зацикленная последовательность, можно сказать. Вы берете каждое 119. То есть поэтому
получится число, поэтому получается w вот 2 в 23. То есть получается, что у него будет свойство,
что это число в степени 2 в 23 будет равно 1, а все предыдущие степени его единицы неравны.
Ну там разные щиты могут быть. Там смотрите какие щиты могут быть. Вы можете на самом деле
найти по несколько, еще есть щит, несколько таких модулей, проделать произведение по разным
модулям, а потом скомбановать результат. Еще так можно. Не обязательно еще. Нет,
может быть и 2 в 22, пожалуйста. Вы берете w2 в 23 и возбудите в квадрат, получаете w2 в степени 22.
Что? Ну да, то есть понятно, что проблема в том, что n если будет 2 в 25, то конкретность по этому
модулю у вас уже не получится. А для любой степени 2 в 23, пожалуйста. Ну вот, ну там вот пошла. То есть
кто-то придумал задачу модуля, потом кто-то развлекся в фетерозаводске, дал контест,
где во всех задачах был такой модуль, но только в одной из них нужно было реально фурьей писать.
А потом пошла мода, чтобы не спалить лишнюю, чтобы не было такого, что увидел этот модуль,
значит думай в сторону фурьи. Но в результате там и на всех кодфорсах вообще пошла мода,
давайте использовать вот этот модуль. Ну не знаю, нет, я решал раунды, там вот эти модули были.
Ну ладно, видимо, хорошо, ладно. Ну ладно, давайте так, это наверное зависит от автора, то есть ладно.
То есть как бы я думаю так, в ДИВ два раунда, я скажу так, в ДИВ два раунда это смысла не имеет,
потому что я думаю редакторы просто там, сейчас как редакторов-то? Ладно, координаторы,
вряд ли дадут вам добро на дачу в ДИВ два раунда, а дачу на фурье. Ну 20 человек да, но из ДИВа два.
Ну и потом нет, там все-таки, ну я не знаю, я по-моему, я встречал, я все-таки максимум,
где я помню фурье, это все-таки скорее ДИВа-ДИВье все-таки. Ну ДИВ два уже точно давали потоки,
поэтому... А, ну окей, ладно. Там стандарты растут постепенно. Не, ну растут, да. Ага. А если не
превратится в комплексные числа, потому что мы просто нашли такое... Так вот. Омега Н. Так вот,
я собственно к чему? Сколько у меня, сколько-то времени-то вообще? Минус шесть. Ай-яй-яй. Так,
ну ладно. Ладно, я с утра опоздал, поэтому да. Нет. Обожаю этот аргумент, сам сюда так делаю.
Поскольку я опоздал, мы задерживаемся. Нет, ну бывает поразу. Ладно, пока стираю. Нет, еще был,
как предпочитает, говорит, что ладно, я сегодня, к сожалению, опоздал, но в качестве извинения я
вас пораньше отпущу. Так вот. Значит, поверим в существование такое WN. Нет, на самом деле,
сейчас мы само по себе фурье, просто на уровне идеи как это делать за N log N получим достаточно
быстро. Значит, идея будет такая. Мы снова будем делать разделяй и властвуй. Только следующим
образом. Мы введем многочлен А0 от T и А1 от T. Они снова будут размером N пополам, но они равны.
На этот раз, смотрите, к чему-то более читерскому.
Теперь мы коэффициенты делим на коэффициенты с четными индексами и коэффициенты с нечетными индексами.
И теперь немножко мальки. Я утверждаю, что А от T равно А0 от T плюс T на А1 от T.
Внимание, вопрос. Какие два символа я должен добавить в это равенство, чтобы оно стало верным?
Нет, нужно, чтобы это было верное равенство, а не верное утверждение. А то так можно не равно,
а это тоже не факт. Так, что говорите? Так, ладно, времени мало, поэтому давайте без лишних шуток.
Короче, квадраты сюда надо поставить. А теперь зачем я вот это потребовал? Дело в том, что давайте я теперь
попишу синеньким. Значит, внимание, А от Wn в степени g. Это что такое? Это получается А0 от Wn в степени 2g плюс Wn в степени g на A1 от Wn в степени 2g.
Казалось бы, надо вычитать значение многочлена А0 и А1 в этих вот точках от n, но мистический факт.
Дело в том, что когда как мы говорили, что Wn пополам равно Wn в квадрате, то получается, что Wn в степени 2g это Wn пополам в степени g.
Вот нам зачем это было надо. Понимаете, да? То есть получается это равно А0 от Wn пополам в степени g плюс Wn в степени g на A1 от Wn пополам в степени g.
То есть для того, чтобы найти значение многочлена А во всех вот таких n точках, нам надо просто найти значение многочленов A0 и A1 размера n пополам в точках вот по n пополам вот этих вот точках.
Что мы делаем рекурсивно? Неплохо так, правда? То есть запускаемся рекурсивно, после этого за O от n. Их восстанавливаем в значение.
И получаем, что 8 точек у нас получается t от n равно 2t от n пополам плюс O от n. Чему равно t от n? Ну, конечно, n log n, да. Мы уже там миллион раз встречали.
Нет, какой последний? Нет, ну сейчас. А, да, вы правы. На самом деле по-хорошему вот эта схема нам, то есть мы сейчас log n смогли вот в эту сторону.
А теперь как сделать в обратную сторону? Теперь на уровне идеи. Дело в том, что те действия, которые мы делаем, можно легко обратить.
Обратить... Смотрите, значит... Ну, сейчас, что? Я стирал только что про n log n. И вот это вот я сейчас стру. Вот это я не собираюсь стирать, боже упаси.
Значит, смотрите. На самом деле тут идея следующая. Вот мы знаем, что по значениям a0 и a1 мы можем восстановить значение a.
А теперь я хочу сделать тот же самый алгоритм, только наоборот. А для этого вопрос. Как вы думаете, если я знаю значение многочлена a в этих точках, могу ли я получить значение a0 и a1 в этих точках?
Ну, смотрите. Вот как вы правильно заметили, мы хотим, наоборот, вот отсюда перейти сюда. То есть по вот этим значениям я хочу получить вот эти значения и вот эти.
Но если мы научимся это делать за линию, то как бы мы будем по каждым n значениям получать n пополам значений тут, n пополам значений тут, запускаться рекурсивно, получать коэффициенты,
и потом их, собственно, вот таким вот образом вписывать. То есть тут получится коэффициенты a0, a2, a4 и так далее, тут a1, a3, a5 и так далее.
Суммарно получится за n лог n, если мы по вот этим значениям получим вот эти значения, то есть вот эти значения за линию.
Как же это сделать? Оказывается, идея очень проста. Смотрите, дело в том, что для любого g меньше, чем n пополам верны следующие факты.
A wn в степени g равно a0 от wn пополам в степени g плюс wn в степени g на a1 от wn пополам в степени g.
А еще я знаю, что a от wn в степени g плюс n пополам, чему это равно?
Это равно, чему это равно? g плюс n пополам плюс wn в степени g плюс n пополам на a1 от wn пополам в степени g плюс n пополам.
Вот, логично, да? А теперь вспомним, что wn пополам в степени n пополам равно единице.
Логично, да? То есть получается, что я тут могу сделать, то есть я вот это n пополам и вот это n пополам могу убрать.
Логично, да? Ну еще для красоты я могу убрать вот это n пополам и написать вот тут минус, потому что wn в степени n пополам очевидно равно минус единице, правда?
И тогда, смотрите, и тогда получается по значениям wn в степени g и wn в степени g плюс n пополам мы получаем значение многочленов a0 и a1 в точке wn пополам в степени g.
Потому что, видите, у нас просто система линейных уравнений из двух линейных уравнений с двумя неизвестными.
Ну wn в степени g плюс n пополам это то же самое, что wn в степени g с минусом.
Вот, то есть это просто система. То есть получается, что вот это там, отсюда можно вывести, что там, скажем, a0 там от wn пополам в степени g.
Это, на самом деле, равно там что-то типа a0 в степени g точке, плюс значение g плюс n пополам в этой точке и поделить пополам.
Вот, но там вторая точка тоже подобным образом ищет. Вы читаете, делитесь, тогда степень радуетесь.
Отсюда следует, то есть получается, что по вот этим формулам, значит, если вы знаете вот эти значения все n, то вот эти вот все тут n пополам и тут n пополам вы тоже знаете.
Вы их узнаете, вот за линию узнаете, запускаетесь рекурсивно, там получаете коэффициенты и их, собственно, обратно смерживаете.
То есть получается обратное преобразование. Вы тоже успешно делаете.
Ну, как минимум, в принципе. Естественно, в следующий раз мы будем подробно обсуждать, как это делать не таким черномагическим способом, а более приятным.
То есть это редкий случай, когда нам придется рассмотреть, как это нормально кодить.
Потому что если вы будете реально писать рекурсивно, то это будет работать в 10 раз быстрее, чем у, там, называется, тех, кто пишет правильно.
Да, только не быстрее, а медленнее, к сожалению, да.
Но квадраты тоже разные бывают, знаете.
Ну, по крайней мере, как минимум, в принципе, вот это мы делаем.
Ну, на самом деле, вот подстановка именно вот таких w и называется быстрое преобразование.
Возвращение в фолье.
Вот. Или сокращенно b, p, f.
Соответственно.
Вот. Так что подробнее.
Ладно, по умолчанию, да.
Со страшным подозрением, что продолжим мы с этим разбираться через две недели.
Ну, если только случайно не выяснится, что в Бангладеше есть возможность провести удаленные лекции.
