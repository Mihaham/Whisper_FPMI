ну пока включается проектор давайте вспомним на чем мы остановились значит последнее о чем я
рассказывал это ошибки компиляции их классификация вот ну и в общем-то мы почти закончили введение
я лишь а где так отчего больше маркеров нету что вот это да а эти плохо пишут но печально ну ладно
отличный проектор заработал вот ошибки компиляции но мы обсудили что там бывают что ваша программа
некорректно компилятору для компиляции вот но еще две вещи два важных понятия о которых надо
сказать прежде чем начать что-то интересное изучать это рантайм-эрроры и так называемое
убэ значит есть ошибки компиляции которые мы обсудили бывают рантайм-эрроры это для любителей
значит для педантичности я скажу что я продолжаю параграф 1.7 рантайм-эрроры что такое рантайм-эрроры
ну вы наверняка встречались в своей жизни с таковыми ну есть компайл тайм-эррор и рантайм-эррор
что такое рантайм но это ошибка которая случилась уже в ходе выполнения когда файл скомпилировался
исполняемая программа создалась но в ходе выполнения что-то пошло не так какие есть
примеры рантайм-эрроров ну например деление на ноль да да ну в общем-то вы два главных
примера и назвали а если точнее то как точно вот называется то что происходит если вы делите
на ноль это называется floating point exception так называемая значит это в джаве кажется она
так называется zero division exception но на самом деле в случае с плюсами происходит ошибка на уровне
процессора ну потому что когда центральный процессор ваш делит целые числа и понимает
что там операция деления на ноль то он возникает то вызывается такая так называемая исключительная
ситуация там это все как-то через операционную систему с операционной системы как-то процессор
взаимодействует в итоге ваша программа убивается а в консоль пишется floating point exception еще
в скобочках может быть написано так называемая core dumped сейчас я вкратце скажу что это значит вот
а если у вас происходит обращение по несуществующему индексу то это что ну это как повезет вы
можете обратиться и получить просто рандомное число но если вам это если вам не повезет как
раз вы получите рандомное число а если повезет вы получите runtime error почему так ну потому что
потому что если вам не повезет то вы обратитесь по рандомному индексу этого не заметите программа
продолжит дальше работать и проблема вылезет где-нибудь в неожиданном месте например у пользователей
яндекс такси такси приедет через 20 лет а не через три минуты как это полагается вот вы
продолжите работать будет просто баг в реальности какие-то подобные числа но это может привести к
беде уж лучше бы упали вот это ошибка называется segmentation fault segmentation fault сейчас я как раз
продемонстрирую оба этих случая вот у меня тут как раз подгрузился проекта давайте я вам
продемонстрирую наверное свет надо выключить и сделать покрупней
как это выглядит это если из консоли делать так что-то у меня какие-то примеры со вчерашнего
дня остались ну вот просто к индексу которому которого не существует но обращение не к своей
памяти что строго говоря любое вот ну давайте я покажу давайте назову этот файл le.cpp ну первый
пример с утра я немножечко не в форме так значит ну давайте я скажу вот так просто и
сделаю вот с клавиатуры а выведу без хитрости совершенно результат деления ну тут лишняя
точка запятой но не страшно вот значит компилируем а запускаем ну давайте не знаю поделим 25 на 4
получается 6 логично теперь давайте поделим 3 на 0 о 1 point exception core dumped это не еще раз
я еще не говорил что это такое сейчас скажу вкратце но вообще я думаю что это скорее тема
семинаров вот я думаю что федя вам как-то расскажет вот это ближе к концу семестр причем скорее
будет вот ну floating point exception так называется ошибка которая происходит в процессоре значит
ну и дальше там через операционную систему как-то он сообщает вам что случилось такое вот что
такое core dumped это значит что система сделала dump состояние программы которое было на момент
когда это произошло и в принципе можно дебаггером залезть и посмотреть это состояние увидеть там
в какой именно строчки ну так прям не получится нужно с некоторыми флагами скомпилировать чтобы
это было видно но вообще можно по этому файлу который там лежит специальной директории понять
что именно произошло в ком месте вот зачастую это бывает полезно когда у вас такие ошибки
происходят там на каких-нибудь серверах и после там суток работы например у вас чуть-чуть упало и
вы хотите понять а что именно там упало и вы такие открываете этот файл и смотрите это на жаргоне
называется корка от слова core вот core это типа состояние ну скажем так типа ядра не знаю почему
использовать слово core вот но в общем оно задамплено и можно увидеть что там было вот давайте продемонстрирую
вам сек фолд ну давайте заинклудим какой-нибудь вектор с массивом сработает но формально говоря я
не рассказывал что такое массива поэтому лучше покажу на примере вектора вы что думаете у нас
все очень продумано значит а вектор вот давайте я заведу вектор из пяти элементов и такой возьму
и скажу ну ну вот если я скажу вывести мне в 10 то ничего плохого не будет будет просто
рандомное число вот если я скажу в 10 присвоить единицу тоже на самом деле ничего плохого скорее
если мы не слишком далеко заходим за границу это как правило не сек фолд нет кп ст у него 5 для
знатоков на самом деле дело в том что но это вообще не относится к теме нашего курса но там
история вот какая убивает нас же должна убить операционная система в конечном счете она нас
убивает за то что мы обращаемся не к своей памяти но память выделяется странично операционная
система не выделяет нам ровно 5 этих интов выделяет нам какую-то страницу в которой там сколько-то
килобайт допустим и если мы остаемся в рамках этой страницы то формально мы совершаем нелегальную
операцию но операционная система пока об этом не знает потому что мы находимся в пределах того
куска которая нам выделила однократно для того чтобы мы им пользовались если мы выйдем далеко
за его пределы вот если например 100 тысяч напишу то вероятно ну да даже если по отрицательному
индексу обращусь вероятно еще все будет нормально потому что я недалеко вышел за пределы а нет вот
теперь случилась проблема потому так вот сейчас произошло что-то интересное потому что
да это не секвел то что-то другое так вот это и даже интересно это даже не знаю почему
а все да да ты молодец действительно да да да да это правда это правда кто понял что он
сейчас сказал ну хорошо да там да слева от самого массива хранится число которое ему задает
размер массива а я его нагло переписал поэтому когда вектор стал уничтожаться он как будто бы
стал освобождать не то количество памяти которая надо и из-за этого случилась другая ошибка вот
double freo corruption вот но давайте все-таки продемонстрируем секвел то есть секвел то не
случилось обращение по этому индексу это еще не ошибка вот но вот если я 100 тысяч сделаю можно
кстати напоминаю писать вот так то вот это уже секвел и кстати возможно секвел даже вот это
они только записи то есть возможно чтение да уже чтение по 100 тысячному индексу это уже секвел вот
ошибка сегментирования вот ну мы заодно с вами увидели третью еще третий вид runtime
значит это когда случается вызов функции abort которая означает аварийное завершение
программы но аварийное завершение программы случилось вот из-за того что некорректно
освобождение памяти там было вот но если вы не понимаете что там произошло с этим минус один
это пока не важно значит это мы кстати это мы уже сегодня обсудим на самом-то деле вот потому
что сегодня я опять у вас буду вечерней парой вот мы ускоренно двигаемся вперед вот но пока
вот сек фолт и лакфинг поэт эксепшн а почему бы компилятору не отлавливать такое в компайл тайна
вот значит ответ неправильный на самом деле это математически невозможно они просто долго
значит ну невозможно просто да можно доказать теорему и вы докажете это во втором семестре
на мот логике что вообще говоря невозможно написать программу которая по произвольной и другой
программе отвечает на произвольный нетриثмальный вопрос то есть что значит нетрифмальный вопрос
значит такой вопрос что ответом не всегда является да и не всегда является нет вот нельзя по данной
программе определить вообще говоря происходит в ней деление на 0 или нет это алгоритмически
нерешаемая задача. Можно только начать выполнять программу, и оно либо произойдет, либо нет, либо
программа зависнет, и ответа мы так и не дождемся. Ну, короче, нельзя в compile-time просто предсказать,
случится это или нет. И поэтому компилятор бы, конечно, и рад, может быть, какие-то вещи на
этапе компиляции отследить. Поэтому, например, компилятор, если его, если компилировать там с
максимальным количеством предупреждений, он про некоторые места вам скажет. Здесь, вероятно,
будет вот такая-то плохая вещь. Но вообще говоря, компилятор, конечно же, не в состоянии все эти
вещи отследить, поэтому полностью застраховаться от падений в runtime никак нельзя. Это просто
невозможно математически. Ну ладно, с другой стороны, правда, можно сделать эти падения более
мягкими, так скажем. Ну как, например, в питоне, то есть там, ну или в джаве. Там не доходит того,
что вас прям убивает операционка, там происходит так называемое исключение на уровне языка,
которое поймать можно. Вот, а в плюсах нельзя. Вот у вас есть напрямую обращение к памяти,
и это означает, что вы не застрахованы. Вы никак не можете, допустим, обращать в 100 тысяч,
вы не можете написать, условно говоря, try catch, который бы сделал вам, если обращение не по
правильному индексу, то ошибка поймана, и вы дальше работаете. Вот, через обращение квадратными
скобочками так не получится, потому что это прямое обращение к памяти, и вас дальше либо убивает
операционка, либо нет. Вот, чего можно? Нет, есть, конечно, способы, безусловно,
на этом все можно делать, но прямое обращение по индексу в плюсах, оно не так работает,
как в некоторых других местах, например, в джаве. Вот, но про это мы еще попозже поговорим. Вот,
а пока мы поговорим напоследок вот про что. Вот это есть, значит, райн-тайм-эрроры,
противоположно компайл-тайм-эрорам, которые в момент компиляции случаются. Вот, ну еще есть
так называемое УБ, и вот это самая божественная вещь, которая есть в плюсах. Вот, вы ее все будете
очень любить, и я уверен. Значит, УБ, сокращенно от undefined behavior, так называемое неопределенное
поведение. Ну, тут, наверное, вот так. Значит, что такое УБ? Смотрите, вот вы олимпиадники,
и вы все, наверное, в своей жизни много решали разных задач по алгоритмам, и зачастую вы,
когда решаете задачи по алгоритмам, там в условии написано. Ну вот, на вход дается там сначала
число n, а потом n целых чисел. Каждый из чисел не превышает миллиард, а, значит,
само n не превышает 10 в пятый. Ну, а ваше вывести нужно там то-то. Вот. Представьте, что вам вы
решаете такую задачу, а вам на самом деле дали n, которое превышает 10 в пятый, или число,
которое превышает миллиард. Как ваша программа себя поведет в такой ситуации? Зависит от
программы. Дело в том, что, ну, этот человек ошибся, просто это неконкретный тест, правда? Ну,
вы не обязаны, если в условии сказано, что на вход должны подаваться такие данные, то ваша
программа не обязана корректно работать, она вообще не обязана каких бы то ни было гарантий, что она
делает, если тест некорректный. Некорректный тест, о чем речь вы, что хотите от нас. В условии написано,
что программа должна на вход подавать это, а она на вход подает не это, и что, какие проблемы?
Вот. Теперь представьте, что вы это разработчик компилятора, а компилятор это тоже программа,
которая входные данные преобразовывает в выходные данные. Для компилятора входные данные это код
ваш на плюсах, а выходные данные это машинный код. А условия задачи, это что? Это стандарт C++ на
1500 страницах. И там написано местами в этом стандарте, гарантирует, что корректная программа
не должна содержать этого. Если она это содержит, ну, значит, такие случаи вы не обязаны учитывать,
дорогие разработчики компилятора, делайте что хотите. Вот это называется УБ. То есть, если вы
в своей программе пишете что-то такое, относительно чего в стандарте написано, ну, так писать просто
нельзя, нет никаких гарантий на этот счет, вы не должны так писать. Это УБ. То компилятор вам,
логично, ничего не обещает, потому что компилятор действует в предположении, что вход корректный,
вход корректный для него означает, что, ну, в частности, например, вы не переполняете int никогда.
Если программа такова, что в ней происходит переполнение int, компилятор ничего не обещает,
вообще ничего. Он может какой угодно вам код сгенерировать в ответ на то, что вы переполнили
в своей программе int хоть в одном месте, строго говоря. Вот, давайте я вам продемонстрирую такой
замечательный пример, который, кстати, взят с сайта КФ, и автор этого примера, значит,
небезызвестный всем Майкинер Заянов, спасибо ему, как говорится, за, значит, за то, что замечательные
системы Код Форс и Полигон, да, как же без этого. И пример такой, вот давайте представим, что
у меня есть. Нет, 4 пробела. Это не таб, но я нажимаю таб, но ставится 4 пробела. Ну как,
это vmerc сделано, ну что вы удивляетесь, ну что вам. Точка vmerc, вот тут написано, что setup 100
равно 4, это ширина таба, shift width равно 4, это, по-моему, я не помню. Да, могу, могу. Какой-то из этих,
ну какая-то из этих команд заставляет его табы на пробелы менять. Возможно smart tab или smart
indent, нет, ну я не помню, ну короче какая-то из них. Это не я говорил, не путайте. Expand tab,
да, это не я говорил, это у вас в, я говорил, что можно, сколько хотите, пробелов, лишь бы одинаковое
количество, но обычно либо 2, либо 4. Вот, ну в яндексе ставят 4 обычно, в гугле 2. Можете делать,
ну да, 2 это не догма, можно 4, главное одинаковое количество, но табы нельзя, да. Так вот,
возвращаемся сюда. Вот смотрите, такой пример, давайте я напишу, значит, цикл, ну не знаю там,
вот, и выведу, нет, даже не так, я вот просто выведу до 300, я сейчас этот пример воспроизведу,
выведу и, и выведу, значит, результат умножения и на вот такое, нет, вот на такое, получается 12
миллионов 345 тысяч 678, ну если я это умножу на 100, это получится миллиард, а вот если я это умножу на 300,
то уже будет переполнение. Это, конечно, хотим, да. Вот, сейчас я это скомпилирую, замечательным
образом запущу, но надо новую строку только в конце. И, ну и ничего интересного не произошло,
в общем-то, начиная с какой-то итерации, у меня просто произошло переполнение и стали отрицательные
числа вместо положительных, ну ладно. Вот, но есть такой замечательный параметр компиляции,
который как раз, вот я вам говорил про минус о маленькое, выходной файл, а есть минус о большое,
кто знает, что минус о большое? Оптимизатор, да, это вы руки поняли, что знаете. Значит,
есть такой замечательный параметр и, на самом деле, зачастую вы, сами того не подозревая,
компилируете с ним, возможно, он у вас у кого-то по умолчанию стоит на стройках.
Минус о большое, а дальше можно писать ноль, либо один, либо два, либо три, либо фаст,
либо еще, ну либо, в общем, много чего можно писать, можно писать минус о g, ну неважно,
короче, давайте я ограничусь только разбором случаев ноль, один, два, три. Это значит,
что компилятор оптимизирует, то есть он старается некоторые вещи, которые очевидно
можно сделать быстрее, делать быстрее. Если компилятор может доказать, что ваша программа
эквивалентна некоторой более простой программе, скажем так, ваши действия, для пользователей,
невооруженным глазом, то, что делает ваша программа, неотличима от того, что делает некоторая более
простая программа с меньшим количеством операций, то компилятор имеет право сделать такие
преобразования. Вот, я сейчас не буду вдаваться в детали, значит, ну, например, да, ну, есть много
разных оптимизаций, которые там он делает, в том числе там как раз оптимизации возвращаемого
значения, там не делать лишних копирований, когда он видит, что можно их не делать, там можно просто,
если у вас есть какое-то вычисление в длинном цикле, то он может его просто оптимизировать,
заранее посчитать, чему будет равно число после этого цикла и сразу сказать, что пусть оно будет
равно этому, зачем мне это делать в runtime, если я могу сразу сказать, чему оно будет равно и так
далее. Вот, ну, то есть, там, например, если вы пишете выражение какое-то длинное с вычислениями,
компилятор просто сам вычислить, чему оно равно, и сразу переменную запишет это выражение, чтобы
в runtime не делать этих вычислений. Вот, ну, часто такой консенсус, это O2, то есть, это такой
не максимальный уровень оптимизации, но такой достаточно неплохой, то есть компилятор достаточно
много оптимизаций делает, в том числе, там есть такая оптимизация, как разворачивать циклы, там,
что по unwind for loops, вот то, что я сказал, что если вычисление какое-то в цикле, то компилятор может
просто, видя, к чему оно приводит, заменить его на конкретное значение. Вот, я скомпилировал,
получил warning. Да, значит, есть такой, такая опция оптимизации aggressive loop optimizations,
которая как раз, видя, что происходит в цикле, может его, ну, так сказать, развернуть, сделать
его не циклом, а просто заранее просчитать все, что будет в цикле, и либо забить на весь цикл целиком,
либо его развернуть просто в одну строчку, ну и так далее. Вот, вот O2 он заметил, что тут будет
проблемка, и кто знает, что будет, если я сейчас запущу? Это-то понятно, а что будет происходить
в рантайме? Что конкретно будет сейчас? Я запущу, и что будет? Бесконечный цикл будет? А, нет,
то же самое, почему? Непонятно, так, хорошо. Так, у меня не получился пример, это мне не нравится,
давайте. Чего? Сейчас, дайте-ка я подумаю. Давайте я не буду и выводить, нет, нет, давайте я не буду
и выводить, а буду только вот это выводить. Сейчас, возможно. Давайте я сделаю еще раз O2, и вот так сделаю.
Сейчас, подождите. Хорошо, я поступлю хитро, я значит сейчас...
Чего? Как ты это сделал?
Вот этот пример. Казалось бы, в чем разница, да? Давайте я попробую этот пример к нам.
Да, вполне возможно, от этого что-то поменялось. Давайте, значит, попробуем скомпилировать,
и теперь запустить. Сейчас, попробуем. Да, вот все, бесконечный цикл. Да, значит, разница в том,
что там перевод строки был Слэшен, а тут Эндл. А и не нужно понимать. Нужно понимать глобальную причину.
Да, вот смотрите, вот этот пример. Ну да, Эндл приводит к очищению буфера вывода, а Слэшен не
приводит. Как это влияет, ну не знаю. Вот как-то повлияло. Ну это известно там компилятору,
почему он так решил соптимизировать. Ну откуда взялся бесконечный цикл, вы понимаете,
почему он взялся? Откуда он взялся? Ну мы не гарантируем, а какая логика руководствовался
компилятор? То есть, что там написано на самом деле в компиляторе? Что делает компилятор
реально такого? Почему он бесконечный цикл это превратил? Значит, смотрите, какая логика.
У компилятора. Тут в этом цикле есть условия и меньше 300. А в самом цикле есть умножение и вот
на это число. Но компилятор же работает в предположении, что Инт никогда не переполняется. А если в цикле
есть умножение вот настолько, то и всегда меньше 300. Ну, базовое предположение компилятора. Инт
никогда не переполняется, иначе я ничего не обязан. Ну не может же программист написать такую
программу, в которой Инт переполняется. Это мне гарантировано стандартом, что в корректной
программе Инт не переполняется. А в этой программе Инт умножается на вот это, а условие правиложения
цикла и меньше 300. Так зачем мне проверять и меньше 300, если я и так понимаю, что это верно,
исходя из того, что Инт не переполняется. Компилятор просто соптимизировал проверку условия цикла. Он
имеет право не делать, видя, что вы умножаете на вот столько, ввиду того, что Инт согласно
предположению не переполняется. Вот вам пример того, каким бывает УБ. Примеры УБ включают в себя много
интересного. Я вам скину статью, не прямо сейчас, но после пары. Можете в принципе нагуглить,
статья называется «Неопределенное поведение и великая теорема фирма». Там чел заметил,
что идея в том, что если вы условием продолжения цикла сделаете проверку великой теоремы фирма,
особо умный компилятор может заметить, что вы вашим условием продолжения цикла или вашим
под ифом у вас написано, что делать только если вот это вот, значит, авн и плюс бвн равно цвн.
Компилятор может заметить, он же знает, что для всех Интов уж точно это не выполнено,
и хотя из этого просто забить на все эти вычисления и ничего не делать.
Ну то есть компилятор пишут люди, а люди-то знают, что великой теорема фирма доказана,
поэтому они могут такую оптимизацию добавить. То есть оптимизации будут разными интересными.
Когда мы делали O3, чего? Чем O2-O3 отличается или что? Там еще добавляются дополнительно
агрессивные оптимизации, O3 это уж совсем агрессивная оптимизация, от этого компиляция
становится сильно дольше, в разы дольше, но зато код работает быстрее. Вот, ну просто компилятор.
Так он потому и роняет скорее всего, что там УБ. Офаст это значит он уж совсем делает что-то
агрессивное. Вот, ну я короче это все к чему, что когда вы пишете код, в котором УБ, если вы даже
не включаете оптимизатор, компилятор уже имеет право что-то плохое сделать, но если вы включаете
оптимизатор, то исход совершенно неизвестен. Был компилятор когда-то один, в какой-то версии
какого-то компилятора, по-моему не же плюс-плюс, но чего-то другого, это тоже в той статье есть,
компилятор запускал какую-то консольную игру в случае какого-то УБ, то есть там была какая-то
игра консольная и компилятор понимал, что если случается такое, то просто я вместо исполнения
программы запускаю эту консольную игрушку, имею право, потому что УБ означает, что могу делать что
хочу. Да-да-да, это как Google Chrome типа NoInternetConnection, так компилятор типа УБ, играй в динозаврика теперь.
Такое тоже бывает. Потому что компилятор решил не проверять условия и меньше 300, зачем он
сэкономил на этом? Компилятор саптимизировал условия, он не стал его проверять, зачем? Это
экономия ресурсов. Нет, конечно, если бы не было переполнения, программа корректна, все было бы хорошо.
А, если бы не было переполнения, стал бы он проверять? Ну тоже, видимо, не стал бы, да.
Не, ну даже если, вот у нас не было переполнения, как он понимал бы, когда нужно перервать этот цикл?
Значит, он проверял бы, не знаю. Еще раз, здесь написано, можно не проверять, здесь написано,
можно не проверять это условие, потому что и происходит переполнение, потому что и точно не
превосходит 300, значит это условие всегда верно, значит то убрать можно, все. Если бы у тебя было
написано и меньше 100, то это рассуждение не работало, тебе бы приходилось проверять,
потому что ты не можешь быть уверен, что и меньше 100, если умножается вот на это, а если умножается,
а если и меньше 300, ты можешь быть уверен, поэтому это можно не делать. Но я не знаю,
как работает компилятор, это не вопрос ко мне, это вопрос к тем, кто писал G++. Логикой,
ну я объяснил еще раз. Ну это скорее всего такая логика, да, почему это могло быть так,
но компилятор, это все на уровне догадок, мы не знаем, что на самом деле делает G++,
можно посмотреть в исходнике G++, как он это делает, но мы не будем это делать, мы просто поняли,
что UB приводят к неожиданным эффектам, и все. Ну да, но если вы не из-под суда запускаете,
то, значит, вам не разрешат. Минус O0, не делай никаких оптимизаций. Ну вот в параметрах
компиляции нужно написать минус O0, но это все равно не защитит вас, ну можно написать явно
минус W, но no aggressive loop optimizations, можно написать no aggressive loop optimizations,
но это не защитит вас от каких-то других неожиданных оптимизаций, которые вы можете
пропустить. Короче, просто не допускайте UB в программе. Не допускайте ни UB, ни RE,
и CE тоже не допускайте. Вот и все, в этом и секрет, понимаете, просто давайте писать без ошибок.
Да, и все будет отлично, и просто вот Othol10 будет у вас сразу. Как говорил один мой сокомандник
в Яндексе, зачем опять написали неправильный код, надо же сразу было писать правильный,
ну сколько можно договариваться, чтобы писать правильный. Вот так и вас я призываю. Давайте
писать правильно, не будем писать неправильно. Какие еще примеры UB есть? Ну если там переполнение
NTA происходит, то да. Переполнение unsigned NTA не приводит к такому. Переполнение вот
знакового NTA это UB, переполнение без знакового NTA это не UB. Почему так? Потому что без знакового
NTA хранится вполне понятным образом в двоичном представлении, а знаковый NTA, он может храниться
разными способами, и как раз стандарт не регламентирует, как он должен храниться,
поэтому в стандарте и написано. Ну если переполнено, то что угодно может быть.
Разработчики стандарта подумали о том, что знаковый NTA можно разными вариантами хранить в
двоичном представлении, ну а разработчики компилятора рады стараться. О, что угодно может быть,
так мы можем это заиспользовать, чтобы оптимизатор бы эффективнее написать. Вот какие есть еще
классические примеры UB? Ну то есть переполнение NTA, ну на самом деле переполнение NTA это второй по
популярности пример UB, первой популярности это конечно обращение по несуществующему индексу,
вот например V, вот то самое V какое-то обращается, это UB, формально. Ну в реальности это иногда
Runtime Error, а иногда нет. Какое? Да, сейчас поговорим, да как раз. Вот. Чего? Да, это тоже UB. Вот. Ну
какие еще есть примеры UB? Ну например, давайте подумаем, что еще есть такого. Наверное два основных
примера, это вот обращение по несуществующему индексу и вот переполнение знакового NTA. Ну
еще примеры, ну много разных примеров, сотни, тысячи их. Чего? А, да, если кстати вы, о сейчас я вас
обрадую кого-то, возможно. Если вы локально написали int x точка запятой и ничем не
проинциализировали, то это формально UB. Ну просто если вы в локальной функции написали int x и не
написали ничем не проинциализировали, то формально это UB. Ну в мейне, например, да, в локальной области
видимости, в любой. Может, да. Вот как раз то есть статья, которую я вам скинул, там первый пример,
как компилятор может использовать этот факт для некоторой оптимизации. Сейчас. А, нет. Ну да,
там есть такой пример, то есть вы написали, например, Bool B, а дальше у вас написано if B
сделать что-то, потом if не B сделать что-то. Компилятор не делает ни того ни другого, потому что,
ну а зачем, типа, я имею право, поскольку мне непонятно чему равен. Компилятор,
рассуждая так, наверное, мне же не сказали чему равен Bool, значит он вероятно равен не этому.
Значит, ему можно, его можно, вот эту часть можно не делать. И, значит, могу не делать,
то есть компилятор, например, может так это соптимизировать, да. Вот этого я не помню,
если использовать, если его не использовать, UB или это, я не знаю, возможно только обращение к нему UB.
Это обращение уже. Я не знаю, ну я не знаю, я не помню тонкостей, просто не пишите,
просто не пишите так и все. Ну вот я не уверен на счет этого случая, ну вот int x вывести x точно
некорректно, а int x ввести x не знаю, но на самом деле кажется, что в C++20 все-таки это пофиксили
и сказали, что все-таки это не UB, есть определенные ограничения, что компилятор имеет право делать,
но по-моему C++17 это все еще UB, по-моему, начиная с 20-х они все-таки это пофиксили и сказали,
что ну все-таки нет, но это все-таки не UB. Вот, ну давайте теперь я расскажу про то,
что такое unspecified behavior. Есть еще так называемый термин unspecified behavior. Это уже сокращается
тоже как UB, но UB зарезервированная аббревиатура для вот этого. Unspecified behavior это ситуация гораздо
лучше, это когда, ну то есть вот например int x по-моему C++20 это как раз unspecified behavior.
Что значит неуточненное поведение? Это значит, что компилятор, ну не гарантируется,
что именно произойдет, но может произойти лишь что-то одно из перечитленного, не вообще что
угодно. Вот, классический пример unspecified behavior я вам показывал, когда вы пишете, ну все,
я на самом деле уже показал, что хотел, можно выключить на этом. Классический пример unspecified
behavior это когда вы, ну вот делаете, ну в прошлый раз видели пример, когда вы пишете там f плюс
g там умножить на h. Это unspecified behavior, потому что неизвестно в каком порядке будут вызваны
функции, я про это уже в прошлый раз говорил. Вот, ну есть шесть возможных вариантов учислений,
но их шесть, а не бесконечно много. Вот, у b это когда у компилятора бесконечная свобода,
бесконечно много вариантов, что он имеет право сделать, увидев такой код. Вот, а у хотя бы счетный,
это правда. Вообще все, что может делать компилятор счетно, потому что лишь счетным
количеством, счетное количество бинарных файлов он способен, на самом деле даже конечное,
потому что память ограничена, к сожалению. Но ладно, вот, это unspecified behavior, значит вопрос
на понимание последнее, и мы заканчиваем эту тему и идем дальше. Да, про это пример еще
пара слов. Вот это я вам говорил, что есть понятие порядок, приоритет операторов,
operator precedence, а есть понятие order of evaluation. И вот приоритет operator precedence и order of
evaluation это независимое понятие. Если вы можете, если вы откроете cpp-reference, там есть страница
operator precedence, которая говорит, как компилятор синтаксически парсит это выражение, то есть,
что умножение должно быть выполнено раньше сложения. Но есть понятие order of evaluation,
и это уже понятие, относящееся к runtime, то есть в каком порядке реально будут вычисляться
аргументы. И вот для некоторых операторов order of evaluation определен, например, для оператора
запятая, как мы выясняли, определено строго, что сначала вычисляться левый, потом правый.
Для оператора присваивания, начиная, правда, лишь c++17, как я уже говорил, определено строго,
что сначала вычисляться правый, потом левый. Ну и там для некоторых других операторов тоже
строго определено, что сначала вычисляться одна сторона, потом другая. Но вот для оператора плюс,
как и для оператора умножить, order of evaluation не определен, поэтому возможны все шесть вариантов.
А еще есть такой пунктик, который говорит, что если у вас в одном и том же выражении есть изменения
одной и той же переменной, неупорядоченная относительно друг друга order of evaluation,
ну, например, вы говорите, плюс плюс х умножить на плюс плюс х, то вот это уже уб, а не unspecified
behavior. Значит, там в статье order of evaluation есть пункт, ну в стандарте он есть просто, что у вас
выражение, в котором модифицируется одна и та же переменная неупорядоченными способами относительно
друг другу, то есть вы делаете модификацию одной и той же переменной, и неизвестно, что раньше будет,
это или это. Вот тогда просто не забили и сказали, ну тогда уж это уб, мы не будем тут прописывать
возможные варианты. И вот такое, если вы напишете, компилятор может оптимизировать. В частности,
я вам говорил, что вот когда у вас было, значит, до C++17 вот такое выражение, плюс плюс х равно
х плюс плюс, да, это было уб до C++17 и стало просто, ну и перестало быть уб и даже перестало быть unspecified
после C++17, потому что в C++17 добавили фразу, что в операторе равно вычисляется правая часть
раньше левой, полностью причем вычисляется, и с этой поправкой уже это становится однозначным
выражением. А до C++17 это было уб, именно уб, то есть мы разные компиляторы давали кто 0, кто 1,
кто 2, как я говорил, но формально они имели право выдать что угодно. Такие дела. Ну вот, да, так вот,
последнее, что я хотел сказать, это про то, почему вообще уб существует. Вопрос, почему бы компилятору
не превращать всякий случай уб в runtime error просто? Очевидно, вот из этих всех трех вещей,
C, E, R, E и уб, уб самое плохое. Вот кому-то из вас может быть сейчас не очевидно, но это становится
очевидно, когда у вас много лет опыта. Вот обычно люди, которые только начинают на плюсах писать,
считают наоборот. Бесит компилятор со своими ошибками, выполняй просто и не пендривайся.
Да, ну многих очень бесит ошибки компиляции там всякие дурацкие в начальной стадии, типа опять
что-то этому компилятору не понравилось, я не понимаю, опять что ты не можешь сделать? То ли дело
опитон? Типа написал и пошел выполнять, а там где-то упало, ну и ладно. Главное, ты же дошел до
этого места, хоть что-то сделал. Обычно людей, новичков, C,E бесит больше, чем R,E, а R,E больше,
чем уб. Потому что, ну блин, обратился я к десятому элементу, их всего пять. Ну что,
я тебя жалко что ли? Ну выведи рандомное число, казалось бы. Вот, а еще сильнее людей бесит ворнинги.
Уж ворнинги компилятор вообще бесит очень сильно. Да. А знаете мем типа, вот компилятор жаловаться,
что забыл точку запятой, почему бы он сам ее не поставил? Компилятор редко жаловаться,
что забыл точку запятой, обычно он говорит expected и дальше какая-то длинная. Ну если он ее ожидал,
почему он сам ее не поставил? Ну, компилятор все-таки открывает ваш файл на чтение,
а не на запись. Нет, ну стоп, ну если делать так, то он на всех так занимается, он там вставляет
что хочет и ошибка тогда становится настолько хуже. Да, ну короче, вот, на самом деле все наоборот,
да, ну не так как кажется многим начинающим, уб это самое плохое, что может случиться с вами,
RE это чуть получше, CE это совсем хорошо. Ну а отсутствие ошибок это вообще вот то,
к чему стремиться стоит. CE это совсем хорошо, потому что компилятор сказал вам, что ваш код неправильный
еще до того как исполнение началось. RE это значит, что вы упали и программа перестала работать,
но по крайней мере она не сделала ничего плохого. А УБ это значит, что все, вы уже можете, ну то есть
если у вас там, не знаю, какой-нибудь самолет летит и ваша программа управляет, значит,
посадкой самолета, то CE это значит, что просто вы не смогли запустить эту программу, RE значит,
что она упала и вам пришлось, значит, в ручном режиме что-то делать, а УБ это значит, что она
просто работает и внезапно что-то, ну там самолет начинает кремло так вниз, УБ это значит,
что ваша программа молча начинает делать какие-то рандомные операции, совершенно работает неправильно
и что угодно начинает происходить, но вы этого не видите, вы не понимаете, вы думаете,
что происходит, нормально же работает, все хорошо и вдруг внезапно все взрывается, она не падает,
а просто начинает делать бред и вы не замечаете. Вот, да, самолет падает, ну или там яндекс,
беспилотник вырезается во что-нибудь там, ну вот короче, вот, но вопрос, почему же тогда не сделать
все УБ, а не превратить в RE, ведь можно же было бы, вот, это можно, так, например, и сделано в питоне,
вы поняли уже, да, какой ответ, почему так не сделано в плюсах, конечно, компилятор мог бы любую
потенциально опасную операцию оборачивать в невидимый для вас, ну типа, когда вы обращаетесь
по индексу к неправильному элементу, компилятор не делает это прям непосредственно, ну не
превращает это сразу в обращение по индексу, он за вас дописывает ИВ, типа, а надо проверить
размер, и если размер не такой, то упасть, но тут компилятор такого не делает в плюсах, в плюсах
компилятор просто обращается, ну дальше его либо убивает операционная система, либо не убивает,
и он возвращает рандомное число, то же самое там с делением, ну с делением на ноль, я, кстати,
не знаю, как в питоне дела обстоят, я не помню, целые числа, ну не, ну, наверное, там тоже,
там тоже исключение, потому что там целые числа, это на самом деле объекты, и они там, в общем, да.
Да, на флот и в плюсах делить можно, на ноль, я имею ввиду, да, если вы делите даблы на ноль,
то это не УБ, это просто особое значение дабла, которое называется инф, ну у дабла есть там
определенные какие-то значения, ну да, да, да, да, да, там или на, но я не помню, вот, короче,
ответ, потому что плюсы заточены под эффективность, мы рискуем вот такими эффектами возникающими,
зато у нас все работает в разы быстрее, чем на других языках, потому что мы непосредственно сказано
обратиться к 10 элементу, обращаемся к 10 элементу, без лишних, так сказать, предосторожностей, сказано
поделить A на B, делим просто процессор, говорим инструкцию D, вот, да, это на это, все сломается,
ну, значит, нас убьют, ничем проверять дополнительно не будем, в этом и ответ,
то есть УБ это такой вот спецэффект C++, за счет того, что мы напрямую имеем дело вот с железом,
можно сказать, а не оборачивав дополнительные фы, чтобы там, не дай бог, случайно что-нибудь не
произошло плохое, вот, все, мы на этом закончили главу первую, введение, которое называлось,
и теперь мы перейдем к главе второй, можно на этом даже, даже я на этой торжественной ноте пойду
водички себе налью, а мы пропустили 1.6, там должно было быть, я вам должен рассказать,
как работает IF, FOR, SWITCH, WHILE и DO WHILE.
Так, ну, не знаю, если кто-нибудь хочет еще там все водички налить, можете там налить или не знаю,
нет, сам IF, нет, проверка условия работает быстро, вот переход на одну из веток IF может работать
долго, что такое IF для процессора, это значит, что нужно вычислить какое-то выражение, а дальше
посмотреть на значение этого выражения, и либо сделать прыжок в другое место исполняемого кода,
либо пойти дальше, вот, и какая из веток пойти дальше, а какая из веток сделать прыжок в другое
место, это вот, как повезет, вот, одна из веток для процессора означает прыжок в другое место кода,
а это значит, что нужно ему перезаписать кэш, ну, потому что у процессора закэширована сколько-то там,
какая-то часть кода наперед, и если ему приходится сделать прыжок, причем этот прыжок большой,
далеко, то приходится подгрузить новый, новый кусок кода, и вот это как раз и долго, то есть,
вот за счет этого может быть долгий условный переход. Так, ну что ж, глава вторая, давайте я ее назову
указатели, ссылки,
константы и приведения типов.
И параграмма 2.1 будет называться указатели,
Пойнтеры. Пойнтеры это божественная вещь, которая пришла к нам из языка Си, вот, ну, с богом,
как говорится. Ну, наверное, вы догадываетесь, что у компьютера есть оперативная память,
и когда программа работает, переменные хранятся в оперативной памяти. Ну, на самом деле, конечно,
все несколько сложнее, и они хранятся не всегда именно в оперативной памяти, иногда они хранятся
где-нибудь в других местах, да, а иногда не там, не там, а прям в процессоре, но для простоты,
не углубляясь в архитектуру компьютера и на низкий уровень, не залезая, это все вы будете на втором
курсе делать, мы будем считать, что переменные хранятся вот в оперативной памяти просто, только
в ней. Такая упрощенная модель мира, вот, а оперативная память, ну, что это такое, это некоторая последовательность
byte. Значит, у этих byte есть номера, вот, ну и можно заинтересоваться, вот, переменная данная, а
какой у нее номер байта, если в оперативной памяти смотреть, это называется адрес, вот, ну,
еще раз, у вас есть какой-то огромный пул массив оперативной памяти, вот, у всей оперативной
системы есть там большое количество оперативной памяти. Вот вопрос, я хочу задать, вот, у данной
переменной, какой номер байта в памяти, вот, в этой вот, которая выделена, значит, для этого
существует такой оператор, унарный амперсант, ну, то есть, я могу сказать, вот, у меня есть int a,
там равно 0, а потом я скажу int, ну, я не скажу int, я скажу вот так, там cout, наверное, все-таки,
знаете что, давайте-ка, я, наверное, все-таки это буду писать не на доске, а показывать на коде,
а то как-то это будет странно, сейчас я буду всякие операции показывать, вот, давайте-ка, лучше все-таки
так, значит, да, сейчас буду сразу демонстрировать.
Ну, не знаю, а что, на камере не видно?
А типа, доску видно и ту и другую, да, вы хотите сказать? Слушайте, ну, не хочу, это как-то,
я не знаю, как это, давайте в следующий раз об этом заранее подумаем просто, сейчас я уже не хочу
переделать, ну, вот давайте я, значит, заведу какую-то переменную и посмотрю, какой у нее адрес,
адрес берется, собственно, вот таким вот замечательным оператором, а, давайте я x назову,
а то мне как-то привычнее с x, значит, так, уже без "-o2", давайте на этот раз, а то мало ли что,
Pointers, вот, мне выявилось некоторое шестнадцатеричное число, ну, почему шестнадцатеричное,
потому что так определен оператор вывода для указателей, ну, собственно, давайте для начала
поймем, какой тип вот у этого вот выражения, когда я взял адрес, я создал сущность некоторого
нового типа, который называется указательно int, и тип этот называется, значит, обозначается int
звездочка, int звездочка P, а слово pointer равно амперсант x, значит, операция амперсант,
это операция, я сейчас напишу вот так вот в математической нотации, значит, операция амперсант,
это операция, которая по любому типу T дает мне тип T звездочка, ну, жаль,
ну, хотите я сотру, да, ну, то есть, вот, унарный амперсант по типу T дает мне тип T звездочка,
вот, был int станет int звездочка, был double станет double звездочка, ну, вот, для этого
типа, для звездочки, для указателей вывод в поток определен так, что оно выводится в шестнадцатеричном
виде, просто, ну, хорошо, ладно, а если я хочу сделать наоборот, у меня есть указатель, а я хочу
посмотреть, что под ним, то есть, сам указатель или некоторый адрес памяти, если у меня есть
переменная типа int звездочка, то я могу задаться вопросом, а что под этим указателем, то есть,
какой int скрывается по этому адресу, тогда мне нужна обратная операция, вот, и сейчас, вот тут
все обычно путаются, потому что эта операция называется звездочка, значит, звездочка это как
часть типа, так и операция, обозначающая по указателю получение значения под ним, значит,
унарная звездочка это операция, которая по указателю возвращает то, что под ним, так, то есть,
из типа T звездочка возвращает вам обратно T, так, я не сохранил, значит, сейчас будет 1, вот, хорошо,
да, ладно, ну, я могу, в принципе, сделать, я могу взять, у play я могу тоже взять адрес, вот
эта операция называется взятие адреса, а вот эта операция называется разыменование, значит,
по-английски dereference, вот эта звездочка называется dereference разыменование, я могу
взять адрес и уп, и тогда у меня получится вещь типа int две звездочки, вот, и я могу вывести,
например, значение pp, да, и так можно делать сколько угодно раз, то есть, звездочек сколько
угодно может быть, указатель на указатель, да, вот, да, шучит в какой момент, да,
ну как, вот в этот момент, в какой еще, сначала мы объявили x, потом мы создали переменную p,
которую самому мы положили рядом с x и в нее записали число равное адресу x, потом мы объявили
переменную pp, которую положили рядом с p и в нее записали адрес pp, чего?
Ну, взять и адрес, она просто называется, по-английски, ну, адресов так и просто называется,
вот, обратите, кстати, внимание, что числа отличаются на 4, а знаете почему? Ну, потому
что они рядом лежат реально, то есть, сначала лежит x, он 4 байта занимает, а p лежит рядом
с ним, ну, поскольку он 4 байта int занимает, то p на 4 байта правее, видимо, лежит, и они, то есть,
pp это адрес p, адрес p на 4 байта правее, чем адрес x, то есть, они лежат в памяти рядом, буквально
на 4 байта отличаются от их адреса. А как в памяти за x бронируется память? Что значит бронируется?
Ну, компилятор, ну, как? Вот как он понимает, что под x лежит именно этот человек в памяти?
Подожди, это какие-то два разных вопроса, я ничего не понимаю, что ты хочешь конкретно
спросить, как, что происходит? Да, да, следом за ним объявлен p, ну, его кладут рядом следующим.
В этом и есть работа компилятора, собственно, превращать обращение к переменным в обращение
к реальным адресам, ну, как бы, к регистрам процессора на самом деле. Компилятор транслирует ваши
обращения к переменным в обращение к каким-то там ячейкам, которыми уже процессор манипулирует.
В этом, собственно, есть основная задача компилятора, в общем-то. Ну, как компилятор это делает, ну, ну,
сложно это, про это у вас отдельный курс будет, я даже думаю. Ну, это будет, скорее всего, еще плюс 8.
А какой размер? Значит, какой размер у Индзвездочки? Скорее всего, 8. Ну, почему скорее всего? Потому,
что 64-битная машина, значит, на ней 8 будет. Там вот типа компилятор есть, на 22-битном компиляторе,
даже на 64-битной машине? Да, ну, возможно, ну, возможно. Ну, давайте я выведу еще, выведу еще адрес pp.
Ну, я уверен, что сейчас будет 8 разницы, потому что, ну, я-то знаю свой ноут. Ну, разница действительно в 8
получилась. Вот, 163.67 было, E8 стало F0. Ну, то есть, сайзов одного указателя это, как правило,
как правило, 8 байт. Как правило, я говорю, потому что, ну, большинство все-таки сейчас
компов, наверное, 64-битные. Не знаю. Не знаю. Дело в том, что тебе адресовать память, у тебя
память 64-битная, значит, что? Что у тебя адреса, это как раз и значит, что у тебя адреса 8-байтные,
то есть, у тебя оперативной памяти, вообще говоря, не два в тридцать второй максимум, может быть,
а больше. Тебе нужно адресовать больше, чем два в тридцатарой ячеек. Для этого тебе нужны 8-битные
адреса, а не 4-битные. Ой, 8-байтные, а не 4-байтные. Можно ли как-то это искусственно уменьшить,
я не знаю. Ну, кажется, что, не знаю. Может и может. Вот, ну, короче, примерно вот обычно так,
что указатель занимает 8-байт. Ну, хорошо. Да. Вот, отличный вопрос. Давайте поговорим немножко
об этих операторах подробнее, что звездочка и амперсант. Начнем с того, что я могу вот так
сделать. Я могу результату разыминования что-то присваивать. Потому что результат унарной звездочки
это lvalue. А почему? По определению. Ну, это шадр из памяти, ты туда можешь записывать. Значит,
ну, почему это lvalue по определению? А почему так такое определение? Ну, потому что логично,
что вы, наверное, по разыминованному указателю хотите что-то записывать. Я могу по под p что-то
записать. Вот у меня под p лежит int. Я могу в этот int положить другое значение. Это будет в параграфе
2.5. Нет, 2.6. Так, хорошо, ну, да, логично. Что? Конечно, x изменится. Вот, теперь будет, ну,
могу проверить, что x поменяется на 2. Вот. Ну, я могу что-то присвоить и самому указателю.
Например, я могу сказать p равно 2. Ну, тут, конечно, будет проблемка с тем, что, значит,
если я просто напишу некоторое 16-ричное число, да не важно какое число, это же не важно в каком
виде я пишу число 16-ричным или нет, оно будет int. А указателю надо присваивать указатели. То
есть, если я попробую p присвоить какой-то int, это будет ошибка компиляции. Он скажет, вы пытаетесь
присвоить int звездочку, присваивайте int. Нельзя. Ну, можно, конечно, сделать cast, то есть, сказать,
сделай, пожалуйста, считай это указателем, это число. Но ошибка компиляции как раз защищает
вас от того, чтобы вы понимаете, если вы присвоите указателю просто число int от балды написанное,
то что произойдет, когда вы разыминовать его, попытаетесь? Ну, конечно же, у b. Ну, по факту
секфол, скорее всего. Если я попытаюсь указателю присвоить рандомное число, а потом обратиться
по этому указателю, то я почти наверняка попаду в память, которая мне не принадлежит, а операционка
меня убьет. Причем, далеко мне не принадлежит. Вот. Но я могу присваивать указатель к другой
указателю. Ну, то есть, я могу, у меня может быть какой-то int и другой int, и я могу указателю
на один int присвоить указательно другой int. Ну, в принципе, ничего интересного. Вот. Могу ли я, например,
написать p присвоить pp? Оно не объявлено. Ну, могу ли я вот здесь написать p присвоить pp или pp
присвоить p? Не могу, конечно, потому что одно это int звездочка, другое это int 2 звездочки. Типы
разные, так делать нельзя. Вот. Ну, то есть, компилятор строго следит за тем, чтобы вы присваивали
указатель только одинаковых типов. Ну, хорошо. А что будет, если вот здесь его явно скастовать?
Ну, смотрите, почему плохо, почему вот если бы, допустим, было можно присваивать int 2 звездочки
или наоборот. Ну, вот проще объяснить, почему плохо вот так. Вот, допустим, компилятор мне разрешал такое
присваивание. Что это бы означало? Это бы означало, что указателю на int звездочка под указатель на int звездочка
я положил, я в указатель на int звездочка записал, на самом деле, указатель на int. Что будет происходить,
как будет разуменоваться этот указатель? Он же указатель на int звездочка, поэтому реально мне считается
8 байт под ним. А я туда положил указатель на int, поэтому легально только 4 байта считать с этого места.
И вот вам и УБ. То есть, если вы указатель на один тип присваиваете указатель на другой тип, то когда
вы считываете под этим указателем, вы считываете не то количество байт, которое по идее надо бы,
в зависимости от того, что там лежало. И получаете УБ таким образом, что вы считываете уже нелегальную
память. Вот, что еще можно делать над указателем А? Так вот, а что такое взятие адреса? Взятие адреса
это операция, результат которой R-value. Вот, а у нарной имперсанта R-value. И кроме того, а взятие
адреса можно делать только у L-value. Ну как, впрочем, и разуменовывать можно только L-value.
Значит, разуменовывать можно только L-value и адрес брать можно только у L-value. Но опять же,
смысл в том, что брать адрес можно только у существующих реально в памяти переменных,
а у невременных значений, которые вот 2, например. Так же, как разуменовывать можно только что-то,
что... А, нет, я вас обманул. Разуменовывать можно и R-value. Это неправда. Разуменовывать можно R-value,
потому что я же могу написать вот так. Разуменовывать можно R-value. Да, плюс один тоже можно, конечно.
Разуменовывать можно и R-value, и L-value, а вот брать адрес только у L-value. Брать адрес только у
реально существующего значения. И это отвечает на ваш вопрос, можно ли написать амперсант от
амперсант от X? Ой, что я написал? Нельзя, потому что только у L-value можно брать адрес.
Вот. Кстати, если я напишу без скобок, что будет? Синтаксическая ошибка,
потому что это конъюнкция логическая. Да, здесь что-то другое у него произошло. Возможно,
двойной амперсант, написанный у Нарны, для него что-то другое означает. Возможно,
это какое-то сокращение для какого-то старого симп... Ладно, не будем разбираться.
А где мы в памяти храним глубину указания? Что значит глубина, не понял. Что значит глубина
указания? У нас же есть int звёздочка, int две звёздочки. In звёздочка, in две звёздочки,
просто тип. А где мы в памяти храним? Это double или это int? Или это string? Аналогичный
вопрос. Нигде. Это просто компилятор только знает. In звёздочка, in две звёздочки, это типы
переменных. В рантайме нет понятия тип в рантайме. Процессор ничего не знает о типах. Он оперирует
только с числами целыми. Ну, там и с дробными ещё иногда. Но о типах это указатель, или это int,
или это char. Он ничего не знает. Только компилятор знает что-то про типы. Все эти понятия in звёздочка,
in две звёздочки существуют только для компилятора и для нас с вами. И их смысл в том, чтобы
разрешать или запрещать некоторые операции над этими объектами, над этими переменными. Компилятор
понимает, что pp это не такой тип как p, поэтому присвоить нельзя. А когда уже скомпилировано,
процессор ничего этого не знает. Просто делает что написано. Понятно ответил?
Ну, массив массивов есть и надо создать. Если в C создаёшь массив массивов, то ты
фактически создаёшь указательный указатель. Потому что в C массив это указатель по сути,
а массив массив это указательный указатель. К этому мы скоро перейдём.
Давайте дальше. Что ещё с указателями можно делать? Можно к ним числа добавлять.
Например, можно сказать p плюс равно 1. Что будет значить p плюс равно 1? Ну,
это значит будет взять следующий элемент за p. Ну, давайте я вот на таком примере это вам
продемонстрирую. Смотря в каком. Вот в векторе да. Причём, по-моему, начинает только c плюс
плюс 17. Так, вот давайте я заведу вектор там из десяти элементов. Ну, давайте я заведу вектор
там 1, 2, 3, 4, 5. И сейчас вам продемонстрирую. Сейчас только вектор заинклужу. Смотрите,
смотрите. Вот я беру. Всё это закомментирую нафиг. Вот я беру вектор и в нём беру. Говорю,
in звёздочка p равно адрес v0. Могу так сделать? Могу так сделать. У постфиксных операций
приоритет выше, как мы уже знаем. Поэтому будет корректно. Адрес v0. Теперь говорю p плюс равно
1 и вывожу звёздочка p. Всё корректно. Что будет выведено, если всё корректно? Или нет? Или что-то не так?
Значит, нет. Всё корректно. Всё правильно. Здесь нет. Здесь нет уб. Всё нормально. Выведется 2.
Давайте проверим. Ну ничего он не скажет. Всё нормально. Здесь нет никаких нелегальных операций.
Всё нормально. Вот я взял адрес. Вектор хранит этот массив где-то в оперативной памяти. Он на самом
деле хранит его в динамической памяти, но не важно. Мы взяли адрес, получили его, увеличили на 1. Что
происходит, когда я говорю к указателю добавить 1? Он переходит как бы к следующему. Вот что означает
добавление числа к указателю? Вот тут как раз ключевую роль играет тип. Это указатель на что? Он
добавляет к нему столько байт, сколько надо для хранения одного элемента такого типа, как на что
указатель. Поэтому на самом деле п плюс равно 1 фактически означает увеличить п на 4. Ну значение
численное п. Если бы это был указатель на дабл, то увеличение указателя на 1 означало бы увеличение
численного значения на 8. Ну и так далее. А если стринг, то на size of стринг. Ну на size of вот этого
типа как раз. Кто знает? Кто откуда знает? Он это кто? Компилятор или процессор? Компилятор,
процессор не знает. У процессора написано увеличить на 4. Компилятор, откуда компилятор знает,
что если вы пишете a плюс b, то это нужно целые числа сложить. Если a и b это целые числа. Оттуда,
что компилятор про каждую перемену знает ее тип. И для разных типов он амперации транслирует в
разные инструкции процессора. Pay это указатель на int. Для указателей на int прибавление целого
числа означает это. Компилятор транслирует это. Прибавь 4 к числу для процессора. Компилятор
помнит типы всех переменных. Size of от любой переменной он константин. У стрингов и у векторов
тоже константный size of. Точка size это не то же самое, что size of. Можно сделать plus plus p. Это
то же самое. Как и... Ну, p plus plus. Post-ex increment, prefix increment работают по тем же правилам,
что и для int. И plus plus p это то же самое, что p plus равно 1 для указателей. И можно
decrement сделать. И можно вычесть число целое. Вот если я сделаю p plus равно 5 уже, то это будет,
как если бы я обратился к пятому элементу. Ну, то есть за границу. Это уже уб. Ну, то есть,
я просто иду в... Ну, там ноль. Ну, у меня, кстати, минус вел, минус экстр, видите, ничего не сказал.
Да, это уб. Вот. Что еще можно делать с указателями? Можно брать разность двух указателей. Ну,
еще можно сравнивать, кто меньше. Можно спросить, кто меньше. Вот давайте я заведу указатель на v0
и указатель на p2. Не знаю, назову его, хоть это и плохой код стайл. v1. И спрошу, p меньше, чем p2.
Ну, это буль. Мне сейчас выведут 1, то есть true. Значит, указатели можно проверять на равенство,
а также на меньше-больше. Ну, проверка понятна. Какой адрес меньше, тот и меньше. Ну,
и разность можно брать. Как брать разность? Разность — это сколько шагов нужно пройти от
первого, чтобы дойти до второго. Это будет int. Разность двух звездочек — это int. Разность любых
двух вообще. t звездочек — это int. Ну, там, это size t на самом деле. Нет, не size t, это знаковое
число, потому что разность может быть отрицательной. Какой именно это тип, я не помню. А, ptrdivt,
да, спасибо. ptrdivt, который может быть либо int, либо longlong, смотря какая у вас размерность.
Это 1, но я могу сделать p-p2, это будет минус 1. Так, так, так. Какой вопрос был?
Что за вопрос? Плюс плюс к чему? Подожди, подожди. Плюс плюс к чему? Плюс плюс от чего? Если ты возьмешь,
а как ты берешь указатель на первый элемент сета? Это не указатель, это итератор.
Что происходит, когда нам не читаем указатели? Ну, вычитание указателей — это сколько? Формально
говоря, это взять их численные значения и поделить на размер. Просто. То есть сколько шагов нужно
про... Сколько нужно добавить к p, чтобы получить p2. Вот и все. Ну, к p2, чтобы получить p, да.
Не может, потому что указатели разных типов вы не сможете взять. Нет, вы не сможете,
присвоить никогда значение, не кратное 4. Ну, если вы, если вы присваиваете, если в корректной
программе не можете, не кратное size of int. Если вы int звездочки вероломно присваиваете int, ну,
то есть через cast вы просто говорите, присвой. Нужно cast сделать для этого. Ну да, если, но это уже
убе. То есть просто, если вы берете рандомный int и присваиваете его int звездочки, то это,
по-моему, уже убе. Просто нельзя взять int и сделать из него указатель. Да, уже это будет убе, скорее
всего. Ну, потому что нет ни одной ситуации, в которой из int надо вам указатель создать. Это
просто как бы не... Это абсурд. Вы ничего не знаете об адресах памяти, вы никак не можете взять
число целое и сказать, давай, ты будешь считать его адресом в памяти. Нет, так вы не должны
были так делать. У вас арифметик, ну, это убе, вы не должны конвертировать int потом обратно. Все,
что вы, все, что тебе может быть теоретически нужно сделать в арифметике указателей,
определено над самими указателями. А что тебе нужно с ними делать, это только добавлять числа
и брать разность и сравнивать. Умножать указатели на числа тебе никогда не нужно, поверь мне.
Я понял. Ну, кстати, хороший вопрос, да, не знаю. Ну, XOR, конечно, не работает по битвы,
я думаю, с ними. Да, не работает. Нет, вряд ли. Ладно, не знаю, про XOR вы, конечно, меня заставили
врасплох, не знаю, может быть, действительно, в этой ситуации вам придется конвертировать.
Ну, есть такая структура XOR List, это двусвязанный список, в котором вы экономите один указатель за
счет того, что храните XOR указателя, я забыл, правда, указатель на что, указатель на, по-моему,
указатель на следующий, указатель на предыдущий, да, и в итоге... По предыдущему вы можете узнать
какой следующий, да, типа того. Вот. То есть мы храним сначала, ну, создаем int, потом char,
потом int. Где это вы делаете, это вы про что? В программе. Создаем int, потом char, потом int. И что?
Ну, char он занимает один байт. Да. То есть между этими... Нет, int положится на следующий, 3 байта пропустится,
и положится int на следующий кратный 4. Ну да, он не занят и будет. Значит, нет гарантии, что все кладется
подряд, но есть гарантия, что компилятор положит int на адрес кратный size of int. Векторе. Больше
ни в каких. То есть, по сути, любой тип, любая переменная, она может занимать раза в два большую памяти.
А в array, ну, это не контейнер формально. То есть, любая переменная формально может занимать почти
что два раза больше памяти, чем ее size of на самом деле. Ну да. Может и не в два, может и больше, чем в два.
Какой вопрос там? Подожди, какой вопрос? Тихо, какой вопрос был? Да не у тебя, человек руку поднимал.
В строке тоже, но строка не контейнер, по-моему. Формально строка не является контейнером. Это очень длинное
определение. Можешь открыть на себе перейхаль на статью контейнер, и там длинный список требований,
что такое контейнер. Но это не вектор чара, в том-то и дело. Они похожи очень, но формально это не
вектор все-таки. Так. Да, у вас уже должна новая пара начинаться, поэтому я думаю, что мы на этом прервемся.
Вот. И... А у тебя какой вопрос был? Нет, конечно. Чар, например, занимает один байт всего. Но если ты
кладешь чары подряд друг за другом, то они и будут лежать подряд друг за другом. Но если сразу после
чара кладешь Инт, то у тебя три байта пропустятся потом. Ну, скорее всего. Это непонятно. Компилятор
может их переупорядочивать так, чтобы экономить. Но Инт он точно положит на адрес кратный четырем.
Что зачем? Зачем кладет Инт на адрес кратный четырем? Потому что процессор считывает из памяти
по четыре байта за раз, и он умеет инструкцию считывать только вот так. Если бы Инт лежал
разорвано, то процессору пришлось бы в два раза больше тратить операции на то, чтобы считать его.
Еще раз, что в ВКСО? Ничего. Он неопределен. Это некорректно. А ты что хотел сказать?
Вектор векторов, это был бы... Вектор не хранит в себе средний.
Почему ППС-1 перейдет в корректный указатель, если он двигается на сайзов вектора?
Минуточку. Если ты бы взял адрес В0 в векторе векторов, то это был бы не Инт звездочка, а вектор Инт звездочка.
Бог бы получил бы указатель на следующий вектор. Потому что вектор хранит массив не в полях, а в динамической памяти.
Сайзов любого типа константа. Сайзов вектора константа. Я расскажу это как раз в следующем параграфе,
который будет вечером. Сегодня вечерний парой будет продолжение. Все, давайте на этом закончим.
Пример называется memory reuse. Как можно догадаться из названия, здесь будет переиспользование памяти.
Да, смотрите. Вот я взял, объявил А, объявил указатель на А, а потом в локальной области видимости,
создал еще локальную область видимости, и в ней сделал В, и П теперь у меня указатель на В.
Вот, ну я выведу П, а дальше я такой выведу то, что под П лежит. Что произойдет? Ну и правильно, и хорошо, что не видно.
Значит, ну это УБ, потому что это обращение к переменной по адресу, который уже нелегален вообще-то, но по факту там будет два почти наверняка,
потому что ну что толку, он же не будет затирать нулями то, что там освободилось, то есть он завел переменную, мы взяли адрес ее,
она, там область видимости закончилась, ну и все, и теперь как бы формально обращаться к ней нельзя, но если мы попробуем, то скорее всего мы все еще увидим там два.
Нет, к звездочке П обращаться, это УБ. Ну вот, мы увидели сначала П,
мы сначала вывели П, вывести П это все нормально, ну П в своей области видимости находится, просто в ней лежит адрес, по которому обращаться уже нельзя,
а вот звездочка П, это уже УБ, потому что формально то, что под П лежит, уже свою область видимости потеряла, и это уже не наша память, мы уже не можем туда ходить,
но фактически она все еще наша, она все еще содержит двойку, хоть область видимости уже и закончилась, ну потому что зачем перезатирать, очевидно он не будет ничего перезатирать,
ну вот дальше интересно, я беру и объявляю еще четыре переменных подряд, это не по кодстайлу объявлять переменные несколько в одной строке, как мы говорили сегодня утром, но в учебных целях можно,
вот, я значит объявляю еще четыре переменных, вывожу их адреса, и, да, я говорю 3, 4, 5, 6, вот, и смотрю какие у них адреса, ну давайте посмотрим какие у них адреса, вот УБ был адрес 6С,
а у этих переменных адреса остались 6.0, 6.4, 6.8 и 6.C, опа, то есть одна из этих переменных перезатерла Б, она оказалась на том же адресе, на котором была Б, это оказалась Ф,
теперь если я делаю инкримент по указателю, ну, я инкриментирую значение, которое лежит под П, это все еще у Б, я не имею права так делать, но по факту там лежит уже не Б, а Ф по этому же адресу,
и фактически получается, что у меня от этого действия изменится одна из переменных, которую я позже завел, когда я вывожу, у меня получается 3, 4, 5, 7, 7,
А, 3, 4, 5, 7, а 7 это то, что под П лежит, собственно, уже не два, потому что там оказалась Ф, и, значит, в чем мораль этого примера, в том, что когда у вас какая-то переменная выходит из области видимости,
и вы продолжаете держать указатель на нее, то обращение по этому указателю, вообще говоря, может вам дать, оно может вам дать, как то число, которое там лежало, если оно до сих пор никем не перезатерто, так и сегфолд, если уже память отдана обратно операционной системе и вам не принадлежит, так и внезапно вы можете попасть, тыкнуть в какую-то другую свою же собственную переменную, и работая по этому указателю, вы можете на самом деле менять значение какой-то другой из своих перемен, когда у вас есть
что-то, которое завели позже, потому что память под новые переменные переиспользует старую память зачастую, вот такой поучительный пример, вот, где произошло, когда произошло, это ошибка, оставшаяся с утра, да,
ничего не гарантируется УБ, какое гарантируется, тут везде написано УБ, УБ, УБ, ну по факту, вот, может так получиться, и так на практике довольно часто происходит, что когда вы переиспользуете, когда вы обращаетесь по указателю на уже отжившую переменную, вы на самом деле попадаете в какую-то новую переменную, которая перезатерла старую, указатель указывает на тот же самый адрес, что и был УБ,
нет, УБ, потому что так решил комитет по стандартизации, в стандарте написано, если вы обращаетесь по указателю, который был, ну, то есть, вот, начиная с этого места все УБ, ну, то есть, начиная вот с этого места все УБ,
не важно, что я там дальше, случайно получилось, что я положил, ну, может быть, так получится, что туда попадет какая-то новая переменная, и тогда я попаду не в секфолт, допустим, но я могу попасть и в секфолт случайно,
нет никаких гарантий относительно поведения этой программы, вообще никаких, может быть, игрозмейка запустится, но на практике, скорее всего, будет, что?
С чего начинается УБ здесь в данном программе? С вывода, да?
Вот с этого места начинается УБ. Ну, УБ всякий раз, когда вот это УБ и вот это УБ, обращение к звездочке П после того, как Б закончил обусидимости, УБ всегда.
Все, вот такой пример я хотел показать, ну, а теперь я буду дальше на доске рисовать, наверное, до конца пары.
На ошибке мы так и не получили.
Ну, нет. Нам не повезло как раз. Повезло это, если был секфолт. Вот, надо правильную модель мышления вырабатывать. Если упало, это значит повезло. Если так случилось, это не повезло как раз.
Так, смотрю, Филипп, тут у вас же, блин, ну и чего, я сейчас буду стирать, конечно.
Я даже не знаю, как с этим быть. Видимо, я буду долго это стирать.
Надо было кого-то в перерыве заставить это сделать.
Да.
Ну ладно. Это что, очередь на четырех стэках?
А почему там написано four stack queue?
Там было сначала четыре стэка, а потом...
А, все, хорошо. А я удивился просто. Я про очередь на четырех стэках, что-то новое.
Это если у нас нет операции про...
А что это за очередь тогда такая интересная?
Очень полезно.
Можно нулестая, в принципе.
Нет причины.
Так.
Блин, рука устает реально от этого дела.
Так, последняя пара вещей, которые хочу сказать про указатели.
Во-первых, есть такой тип void-звездочка.
Это такой особенный указатель.
Он указывает на непонятно что.
Ну то есть, это просто указатель без уточнения куда, вот так скажем.
Вот void-звездочка относится к void не так, как все остальные t-звездочка относятся к t.
Void это просто ничего, а void-звездочка это просто указатель на что угодно.
Ну то есть, это просто указатель на какой-то произвольный байт памяти без уточнения, что под ним лежит.
Разыминовать void-звездочку нельзя, потому что непонятно какой тип получится.
И добавить число к void-звездочке нельзя.
И разность void-звездочек взять, по-моему, нельзя.
А что можно делать с void-звездочкой?
Ну, можно сделать приведение ее к какой-нибудь другой звездочке.
Ну, например, можно void-звездочку привести к int-звездочке.
А можно любой другой указатель привести к void-звездочке.
Ну то есть, void-звездочка это просто когда вам выделили сырую память.
Столкнемся вскоре с такой ситуацией.
Когда просто выделили сырую память и под ней пока ничего не лежит, никакие типы.
То указатель имеет тип void-звездочка.
Вы можете сказать, давайте это будет, допустим, int-звездочка и класть int по этим адресам.
Да, что?
А что если он, допустим, не кратен 4, а мы его кастуем в int-звездочка?
Не знаю.
На самом деле, такой ситуации довольно трудно добиться.
Мы же можем определить как бы с int, допустим, да, но мы же можем свою структуру сделать, которая будет какого-то странного размера.
И максимально вероятно, что эту штуку уже не будет делиться на размер этой структуры.
Дело в том, что всякий раз, когда вы получаете void-звездочку, она обычно кратна максимально возможной степени двойки, по которой типы ложатся.
Обычно это кратно 16.
Вот, поэтому такие проблемы только если искусственно себе создать можно.
Все функции выделения памяти стандартной возвращают указатель кратный 16, и на него можно класть что угодно.
Да.
Сам void-звездочка 8 байт, ну, на 60 битной системе, да.
Поэтому, наверное, логично его класть на места кратной 4.
При чем тут куда его класть, куда класть?
Он сам занимает 8 байт, само число 8 байт занимает, причем тут к чему равно это число?
Совершенно непонятно.
А vector-звездок 8 байт, да?
Vector, ну, зависит.
Сейчас мы обсудим, почему, что-то связов от vector.
Ну, мы вызываем пункт выделения памяти, мы же в нее передаем ядно, сколько байт выделить.
Да.
И что?
Это не противоречит тому, что он тебе вернет указатель кратный 16.
А, все понятно.
Да.
Вопрос, как void-звездочка занимает, что ему можно что-то кастануть к чему другому, ведь там же должна лежать...
Void-звездочку просто можно кастануть к чему угодно другому, queen-звездочки, например.
Ну.
Мы сейчас пытаемся сделать каст.
Да.
Объект-звездочка.
Да.
Как он понимает, что там лежит именно этот объект?
У него же разная может быть длина?
Сигнатура длины объекта.
Никак.
Когда ты кастуешь к объекту, он и понимает, какой длины там должен быть.
Ну, например.
Ничего не проверяет он.
Ты просто говоришь, волевым решением я утверждаю, что теперь под этим указателем double.
И он такой, хорошо.
Если после этого ты разыминуешь, а там был не double, то это UB.
Но если там реально был double и ты отгадал, то все нормально.
Чего?
Да, да, да.
Это просто указатель на срубам.
Что?
Чтобы у нас есть переменная, и мы хотим ее кастануть другому типу.
Мы в скобочках перед этой переменой должны писать тип.
Ну, скорее static-cast к этому типу вот этой переменной.
Это приведение типов стандартное C++.
Напишу в параграфе 2.7.
Понятно.
Я не буду сейчас рассказывать про приведение типов.
Это большая тема.
Сейчас нам не нужно ничего этого.
Я просто тут говорю, что вот звездочка – это указатель на производительную память.
Ну, хорошо.
Можете пока пользоваться вот таким вот приведением типов.
Можете сказать вот так.
Это будет приведение типов в стиле C.
Что?
Потому что бывают типы, у которых размер 16.
Например, long double.
Ну, или там что-нибудь еще подобное.
Обычно, ну и там int 128, int 128t.
Ну да, например.
100, 128, но я не уверен, он по стандарту или просто…
Короче, на практике там будет, скорее всего, указатель кратный 16.
Ну, там непонятно где.
Я пока не сказал ни одного…
Короче, это будет указатель кратный 16, и это будет указатель кратный 16.
А вы мне скажете, что это указатель кратный 16.
там непонятно где, я пока не сказал ни одного при…
Короче, просто void-звёздочка это тип, который… указатель
без уточнения на что.
Вот.
Он не даёт сам void-звёздочку поставать, например, к виду
звёздочке.
Кто не даёт?
Ну…
Если ты напишешь C-style приведения типов, то он скастует.
Всё получилось.
Так, ладно, ещё одна вещь – это null-ptr.
Это аналог нуля для указателей.
Если вам надо чем-то проинцелизировать указатель, ну, каким-то значением
по умолчанию, то можно писать null-ptr.
Вот, этот такой, как будто бы ноль, но имеющий тип
указателя.
Вот, в C было такое капсом слово null, вот, но оно имело
тип не указателя, а числа, и там из-за этого какие-то
были нехорошие проблемы.
В общем, короче, используйте null-ptr, если вам хочется.
А если его разыменовывать от тоже всегда R-E или тоже
U-B?
Кого разыменовывать?
Null-ptr.
Нет, формально это U-B, но на практике R-E, скорее всего.
Это доказывает, что неявный каст это что-то не работает.
Неявный, да, не работает, конечно.
Явный нужен каст.
То есть null-ptr типа null-ptr-T.
Этот тип неявно кастуется в любой указатель.
В void-звездочке мы можем присвоить void-звездочку либо null-ptr,
либо нужно сделать каст из другого указателя, явный.
Поздравляю.
То есть в целом можно null-ptr писать null и доставать
его явно к нашему типу.
Вот как это работает с нулем, я, честно говоря, не очень
понимаю.
Это все-таки вопросы в стиле, что-то в древние времена
какие-то костыли были, сейчас нет никаких костылей,
не надо писать null, надо писать null-ptr просто.
В СИ не было слова null-ptr, поэтому приходилось какие-то
писать извращенные выражения, вида null, который на самом
деле был вроде нулем, а вроде не нулем, то есть это
была какая-то константа, какого-то особенного типа,
которая...
В общем, я не знаю, я все это не хочу знать, вы просто
пишите null-ptr и все.
Все, я больше ничего не хочу говорить про указатели,
ну, точнее, про вот в рамках этой темы ничего не хочу
говорить больше про указатели пока что.
Вот, а сейчас мы поговорим про следующее.
Следующая тема, ну, такая подтема, она же параграф
2.2 будет называться виды памяти.
Я аккуратно избегаю слова types, стараясь говорить
синонимами, не types of memory, а kinds of memory, вот, потому
что types, сами понимаете, может означать много, немного
ненужного.
Вот, значит, виды памяти.
Сейчас будет такая немножко опять философия, как вообще
работает программа.
Что вообще такое компьютер?
Вот, да.
Что?
Пойнтеры, указатели.
Ну, чтобы не было у вас коллизий со словом types.
Types означает вполне конкретный термин в языке, а я избегаю
слова types, чтобы вы не думали, что это какие-то типы,
прям типы из языка.
Что такое компьютер?
Отличный вопрос, но в переводе с английского это значит
вычислитель, потому что компьют значит вычислять.
Да, если вы...
Ну, это уже издержки, так сказать.
Ладно, что такое компьютер?
Что такое компьютер?
Я думаю, вы знаете все-таки.
И, вероятно, вы все-таки знаете, что есть оперативная
память.
Да, в принципе, мы про это уже сегодня говорили, я повторяться
начинаю.
Но нас интересует вот какой вопрос.
Сейчас, когда вы загружаете свою программу, ну, когда
программа запускается, откуда она память берет?
Ну, то есть, как она...
Вот я вам говорю, вот операционная система там либо вас
убивает, если вы по своей памяти обращаетесь, либо
не убивает, если там, наоборот, если не по своей, либо
нормально все, если по своей.
А что вот это значит?
Своя память, не своя память?
Как это вообще...
Что это вообще такое?
Вот у вас программа запускается, есть у операционной системы
огромный пул оперативной памяти, ну, там, не знаю,
16 гигабайт.
Вот.
И в этой оперативной памяти, в огромной, где-то в вашей
программе выделен кусок изначально какой-то.
То есть, ваша программа, она же изначально запускаясь,
какое-то подношство оперативной памяти себе резервирует.
Ну, не она себе резервирует, а операционная система,
запуская программу, говорит ей, вот, хорошо, я тебе для
начала выделю вот такой кусочек оперативной памяти,
и это будет твоя память, то есть, по адресам вот
из диапазона от такого до такого, тебе я разрешаю
обращаться.
Ну, она ей прямо это не говорит, просто она операционной
системе решает, окей, я сейчас запускаю, и значит,
эта программа выделяет диапазон вот с такого по
такой.
И значит, вот адреса с такого по такой будут доступны,
а если она обратится в ней, то я ее убью.
Ну.
Я правильно понимаю, что любое указательное можно
вставать в любом указательстве?
Ну, смотря каким способом.
Ну, прямым способом.
Если сишным способом, то да, но именно поэтому сишный
способ не рекомендуется к использованию в C++.
Сишный, нет, сишный это в круглыми скобочками вот
так вот.
Да, но он не рекомендуется к использованию, имеем по
причине, потому что им можно прикосновать что угодно,
к чему угодно.
Так мы же и знали с нашей КМЦ.
Нет.
Что?
Все, ладно, ничего.
А, хорошо.
Ну.
Я хотел сказать, что еще, что я скомпилировал всю
программу через O1, и на месте в B она уже выдала не
двойку, кстати.
Ну, логи, ну да, может быть.
Да, у B круче.
Ну, да.
Вот.
Ну, с оптимизацией, там какая оптимизация скорее
всего произошла, он просто видел, что B нигде не используется,
его можно вообще не создавать, значит, вероятно.
Я так думаю.
А, возможно.
Вот, и все.
Есть еще другой вариант, что один слишком мало,
и она перестала reuse-ать.
Нет, нет, он просто скорее всего видел, что B нигде
не используется, поэтому его просто можно не создавать,
и все.
Ладно, так вот, значит, изначально в программе при запуске
выделяется какой-то кусок оперативной памяти,
небольшой.
А, вот, он состоит из трех частей, если упрощенно
это объяснять.
Вот, есть три кусока оперативной памяти, который в вашей
программе выделен изначально при запуске, состоит из,
ну, на самом деле больше, чем трех, там эти части делятся
еще на подчасти некоторые, но мы упрощая, скажем, что
три частей, и они называются, я не уверен, что они у меня
в таком порядке расположены, но они называются data, text
и stack.
Я сразу делаю дисклеймер, все то, что я сейчас рассказываю
неправда.
Ну, то есть как?
Я вам сейчас все рассказываю на таком уровне, вот, типа,
ну, вот, я вам, видим, смотрим на вершину айсберга, на
самом деле там все вот примерно настолько сложнее устроено,
но я вам рассказываю, типа, вот такое вот совсем-совсем
новичковое представление, то есть первый взгляд на
то, что происходит, вот.
Постепенно там мы к этой теме будем время от времени
возвращаться и, возможно, я буду эту картину уточнять,
а уж совсем вы ее подробно разберете на втором курсе,
когда как раз будете изучать низкоуровневые программирования
и тогда вы поймете, что на самом деле тут все в сто
раз сложнее и все устроено совсем не так и вообще вас
обманывает весь этот год.
Но пока я буду вас обманывать, потому что иначе ничего
понять невозможно будет сразу.
Давайте пока для простоты считать, что вот там три
части есть.
Вот.
А что такое дата для начала?
Дата это данные, которые ваша программа хранит перманентно,
так сказать.
Ну, вот, например, если у вас в программе есть какие-то
строки, ну, то есть вы в программе там, не знаю,
у вас программа выводит текст Дзен Питона, скажем,
Сиао.
Вот вы пишите Сиао, вот и дальше в кавычках длинных
напишите длинный текст.
Но этот текст уже должен где-то храниться при запуске
программы, когда она его выводить будет.
Его же даже где-то в оперативке хранить прежде чем выводить.
Вот подобные вещи хранятся в секции дата.
В ней еще хранятся глобальные переменные и константы,
да, ну, глобальные тоже, локальные нет.
Значит, в ней хранятся, ну, на самом деле, когда мы
говорим про строки, вот такие в кавычках написанные,
это тоже относится к глобальным константам, ну, потому что
это некоторая статическая информация, которая в течение
всей программы должна существовать, и к ней там
можно время от времени обращаться.
А также глобальные переменные, ну, и значит, ну, константы
это тоже переменные, строго говоря.
Вот.
Ну, и еще кое-что, но что еще, это мы потом уточним.
Вот, но по крайней мере вот это.
Теперь что такое текст?
Текст это, как вы думаете, что это?
Это не вот эти вот в кавычках, которые.
Это сама программа, да.
Значит, сам машинный код программы, которая работает,
он в оперативной памяти должен храниться, пока она работает.
Зачем так?
Ну, потому что, ну, а как?
Вот процессор выполняет инструкции.
Откуда он их берет?
Ну, у него вариантов-то не много.
Наверное, они где-то хранятся.
Где?
Ну, наверное, в оперативной памяти, потому что, ну,
процессор подгружает очередные инструкции.
Откуда он их подгружает?
Откуда он их подгружает?
Ну, из оперативной памяти.
На самом деле, конечно, там все опять-таки в 100 раз сложнее.
Там есть разного уровня кэши.
То есть там 1-й уровень кэш, 2-й уровень кэш.
Процессор там сложно подгружает из оперативки сначала в один кэш,
потом из этого кэша в другой кэш, чтоб быстрее все было.
Но в конечном итоге все равно их надо брать откуда-то из памяти.
Эти инструкции машинные.
Не из жесткого же диска их брать, правда?
Потому что жесткого диска совсем долго.
Когда у вас выполняемая программа ходится на жестком диске.
Когда вы ее запускаете, она подгружается в оперативную память,
чтобы из нее брать быстро было дальше эти инструкции.
Вот это текст.
Ну и стэк.
А что такое стэк?
Вот вы недавно реализовывали.
Переполняется.
В стэк?
Это такая структура, да?
Ну ладно, кому я это рассказываю.
Ну на самом деле, это область, в которой хранятся локальные переменные.
Вот, как раз локальные переменные, которые вы в мейне заводите,
ну и там в других функциях, они хранятся в некоторой под области памяти,
которая выделена изначально в вашей программе,
называемой стэк.
В дата, я же сказал.
Тоже на стэке.
Ну, это неопределенное, зависит от компилятора.
Он может соптимизировать и вообще нигде ее не хранить, например.
Он может сделать подстановку еще в момент компиляции.
В дате хранятся глобальные переменные, глобальные константы,
а также тексты, которые явно записаны у вас как строки,
текстовые данные, которые в коде программы фигурируют.
Где?
А где они хранятся, по-твоему?
Нет.
Нет, глобальные переменные существуют в течение всего времени работы программы.
И они хранятся в статической памяти.
Вот.
А вот эта область памяти по-другому называется static memory, статическая память.
Конечно.
Так.
Эээ...
Ну, поля вектора хранятся в статической памяти,
а сколько ты там запросил, это уже будет...
Сейчас мы как раз про это поговорим.
Чего?
Кстати, хороший вопрос про глобальный вектор.
Если вы прямо в глобальной области видимости сразу вектор проинциализировали,
то, может быть, он прямо этот массив и туда же и положит.
То есть он не будет динамическую запрашивать под него.
Вот это, кстати, хороший вопрос, я даже, честно говоря, не знаю.
Но если он будет конст-вектор, то точно положит?
Наверно.
Если не конст, то не положит.
Вот. Не знаю, если честно.
Хороший вопрос, надо поисследовать это.
Да, какой вопрос?
А можно, если нифига перемен, чтобы переполнить память?
Stack.
А глобальные переменные, чтобы было переполнение?
Нет.
Ну, дата, она определяется в момент компиляции.
То есть компилятор, компилируя вашу программу, смотрит, сколько в ней глобальных переменных
и сколько в ней вот этих строк.
Ну, и еще того, что он должен в статическую память положить, например,
локальные статические переменные.
И в зависимости от этого он как бы в бинарник прям вписывает информацию,
что моей программе требуется столько-то даты.
И вот какая она.
Ну, типа это в бинаре прям прописано.
С текстом то же самое.
Ну да, то есть вот этот весь бинарь, он подгружается.
То есть операционка, когда запускает, такая, окей, я запускаю.
Значит, даты здесь нужно столько-то, текста столько-то.
Ну, а stack стандартно 8 мегабайт.
Вот. Значит, вот это называется статическая память.
Это никак не называется.
А это еще называется, ну, это называется stack-овая память или автоматическая память.
Не путайте, пожалуйста, stack и статическую память.
И это очень распространенная ошибка, вот, свидетельствующая о непонимании.
Вот многие люди считают, что статическая память это и есть stack.
Ну, как бы есть статическая память, есть динамическая память.
Stack это, наверное, статическая. Нет.
Stack это отдельная область памяти, не статическая, не динамическая.
Она называется автоматическая.
Вот.
Статическая это вот там, где глобальные переменные хранятся,
а также еще кое-что мы чуть позже обсуд, что.
А вот что такое динамическая, сейчас я как раз и расскажу.
Но сначала давайте я про stack расскажу подробнее, но.
А вот иногда, когда происходит какая-то ошибка, вот, с выполнением stack-а, пишется еще какая-то ошибка.
Что-то типа hip, что-то overbuff, что-то такое.
Не знаю. Про что ты можешь мне показать, я тебе тогда скажу.
А, да.
Вопрос. Вот вы сказали, что, ну, понятно, если мы vector задаем как консанту,
то сам vector в полях хранится в дате.
Вот если мы пишем, например, конс-вектор равно там фигурной сходке.
Где? В глобальной области?
В глобальной области. На что, вот, и в векторе внутри указатель?
Положится ли он в дату или положится он в динамическую память, я уже сказал, не знаю.
Возможно, что в дату положится.
То есть, в смысле, указатель будет указывать?
Ну да.
Ну, я сказал, я не знаю, если честно.
Вот это на самом деле, это на самом деле некоторый позор мне,
потому что, конечно, такую вещь знать надо, но я, к сожалению, не знаю.
Да, и меня еще на камеру записали, мой позор. Да, хорошо.
Код функ
Код функций, конечно, в безбедарном коде хранится, да.
Так, отставить такие вопросы, подожди.
Лямбда функции – это объекты.
Возвращаемся к стеку.
Ну.
Я еще не рассказал про динамик memory, можно, пожалуйста, я расскажу, вот так, как планировал,
вы пока помолчите.
Значит, стек.
Когда мы кладем что-то на стек.
Когда мы кладем что-то на стек.
Что происходит?
Ну, в ран тайме хранится там так называемый стек-поинтер.
Ну, то есть, вот изначально стек пустой.
Ну, опять же, не совсем пустой, там кое-что лежит.
Ну, неважно.
Вот изначально, когда мы заходим в функцию main, давайте считать, что стек пустой.
Ну, это близко к правде.
Мы дальше заводим какие-то локальные перемены.
Вот мы завели одну переменную.
В этот момент от стека отхапывается 4 байта.
И, значит, теперь стек-поинтер указывает не на начало стека, а чуть правее.
Вот.
А адрес этой перемены, соответственно, вот такой.
Дальше мы заводим какую-нибудь новую область едемости, вот то, как мы там это делали.
Тут заводим B.
И в этот момент от стека отхапывается еще 4 байта,
стек-поинтер теперь указывает сюда, а адрес B это вот это.
Ну, если при этом я, например, написал бы double B,
то, как я уже говорил утром, там 4 байта пропустится,
и только с адреса кратного 8 положится B.
Вот.
Подожди, пожалуйста.
Сейчас.
Компилятор на самом деле не обязан класть подряд.
То есть, в рамках одной области видимости компилятор имеет право,
и мы наблюдали это сегодня, переупорядочивать как ему удобно.
Ну, вот даже тот пример, который я только что показывал, он это иллюстрирует.
То есть, они не прямо подряд лежат A, B, потом C, D, E, F.
В рамках одной области видимости компилятор имеет право
как-то их переложить в другом порядке,
исходя из каких-то своих внутренних соображений, почему-то он считает,
что так эффективнее будет их разместить.
Вот.
Но общая идея следующая, что когда вы открываете новую область видимости,
у вас на стэк новые перемены кладутся вот над теми, которые были в предыдущей области.
Когда область видимости заканчивается,
стэк, вот указатель стэка сдвигается назад,
и эти перемены как бы недействительные.
Вот.
Ну, конечно же, они не затираются.
По ним, по той памяти, реально все еще лежат те значения, которые там лежали раньше.
Но обращение по этим адресам формально уже УБ.
Что ты хотел спросить?
Стэкпойнтер, он лежит в даче?
Стэкпойнтер, он лежит нигде.
Он хранится во время исполнения.
Он из регистров, скорее всего, в процессоре.
Это не какая-то статическая штука, которая...
Это просто штука, которая во время исполнения хранится...
Ну, он хранится прямо вот в процессоре.
Вот.
Так.
Хорошо.
Что происходит, когда вы функцию какую-нибудь вызываете?
Допустим, у меня есть функция.
Я ее вызываю.
А тут еще что-то там происходит.
Там.
Сиаут С.
Вот.
Вот я вызываю Ф.
Что в этот момент происходит?
Ну, я проваливаюсь в новый уровень стэка.
То есть, как бы, я перехожу на следующий уровень глубины.
Я выхожу из этой локальной области в новую, вот сюда.
И в этой области...
Ну, понятно, что здесь С добавляется, да.
И здесь, значит, С выводится.
Я выхожу из функции обратно.
Все, что в этой функции локально было, забывается.
Ну, когда я делаю ретёрн из функции...
Ну, из Void можно делать ретёрн.
Что-то из функции, да.
Все локальные переменные из функции снимаются со стэка.
То есть, просто стэкпойнтер сдвигается назад.
Настолько, насколько нужно.
Если это были объекты, то там они уничтожаются еще.
Вызывается сгеструктура.
Но мы пока про это не знаем.
Просто, значит, снимаются со стэка локальные переменные.
Я возвращаюсь сюда.
Стэкпойнтер обратно указывает, где он был.
И, значит, новые переменные могут класситься, вот, затирая те, которые были тут.
Ну, в общем, механизм понятен, я думал.
Поэтому он называется стэк.
По своему принципу действия.
Вот.
Вопрос.
Вот, если я...
Сейчас как бы так спросить, чтоб это было...
Чтоб ответ был не очевиден, но в то же время вопрос понятен.
Значит, ну, вот.
Хорошо.
Когда я вызываю функцию, как процессор...
Ну, то есть, исполнение.
Как процессор понимает, в какое место кода ему прыгнуть?
Ну, то есть, это же некоторые машинные коды, правильно?
Мы идем, идем, идем, исполняем инструкцию, дальше вызов функции происходит.
Как процессор понимает, на какое место исполняемой коды ему прыгнуть, чтоб эту функцию начать исполнять?
Ну, как?
Это просто написано в коде программы.
Там написано jump вот сюда-то.
Потому что, когда компилятор компилирует, он все вызовы функции превращает...
Ну, на самом деле, это делает линковщик, но можно считать, что компилятор пока.
Он все вызовы функции превращает в инструкции вида прыгни на такую-то...
На такой-то адрес памяти, исполняя инструкции дальше оттуда.
Вот.
А вот теперь вопрос.
А как процессор, когда заканчивается функция, понимает, куда прыгнуть ему обратно, чтобы продолжить оттуда, откуда он был вызван?
Да.
Куда?
Как он понимает обратно, куда прыгнуть?
Вот именно.
Вот именно.
Когда вы вызываете функцию, понятно, куда прыгнуть, потому что это прямо в коде написано.
Но вы же можете вызывать функцию из разных мест.
И когда вы заканчиваете исполнение функции процессору, чтобы понять, куда вернуться,
нужно где-то знать адрес места, из которого вы прыгнули сюда.
Адрес той инструкции, с которой вы прыгнули начать исполнять эту функцию.
И как он это понимает?
А этого ему тоже на стеке сохранить надо.
Поэтому это называется stack вызовов.
Call stack.
Stack вызовов.
У вас на самом деле при каждом вызове функции на stack записывается еще и pointer дополнительно.
Это pointer на ту инструкцию кода, в которую нужно вернуться, когда вы назад из функции будете возвращаться.
Поэтому даже если вы функцию вызываете без параметров, если функция была с параметрами,
то параметры тоже бы на stack положились.
Но даже если вы функцию вызываете без параметров, каждый вызов функции это плюс как минимум один pointer на stack.
Понятно?
Адрес возврата.
Ну на самом деле там кроме этого еще много чего лежит.
Да, про inline я расскажу чуть позже, вероятно не сегодня, но значит в следующий раз про inline мы поговорим, что-то такое inline.
Вот.
Ну да, то есть каждый вызов функции как минимум один pointer на stack.
Вот.
Что происходит, когда я вот так делаю?
Бесконечная рекурсия.
Бесконечная рекурсия.
Я создал бесконечную рекурсию.
Что будет?
Да, если я делаю вот такое, ну даже если я здесь ничего не объявляю нового, бесконечная рекурсия это значит, что каждый вызов функции плюс один pointer на stack кладет.
И это значит, что в runtime просто произойдет следующее.
Мы будем бесконечно вот этот вот stack занимать, занимать, занимать.
В какой-то момент stack закончится.
А размер stack фиксирован изначально.
Он равен, как правило, 8 мегабайт.
Вы можете в линуксе посмотреть, чему равен размер вашего stack.
Для этого надо написать u limit – s.
Вот.
А как это все с go2 работает?
Ну, go2 работает.
Go2 – это просто, ну как, если вы используете go2, то у вас просто каждая метка, которую вы ставите в программе компилятором транслируется в какой-то адрес и соответствующий инструкции.
Когда вы пишете go2 – это метка, ну компилятор это превращает в jump на такой-то адрес, такую-то инструкцию.
То есть, если u limit – это 8 тысяч, тогда он может максимум 8 тысяч?
Нет, u limit – 8 тысяч – это и знать, что у вас 8 мегабайт, потому что он в килобайтах выводит.
Там можно man почитать и посмотреть, какие у него дополнительные параметры.
Да, что?
Если мы запустим программу local, то она только 8 мегабайт может съесть?
Да, если вы запустим программу обычным образом, то stack в ней ограничен 8 мегабайтами.
Ну, как правило, 8 мегабайтами.
А если через terminal запускать?
Да неважно, через что запускать. Stack в операционной системе – это глобальное ограничение.
Stack программы ограничена 8 мегабайтами. Это ограничение на уровне операционной системы.
Так, да, логичный вопрос. Если я отгару, задаю там вектор…
Отгадай, сам догадайся, какой ответ…
А, ты в text-классе?
Конечно!
А куда?
В динамическую память внезапно.
Ой, блин!
Вот это поворот, да?
Сейчас, а возможно ли как-то изменять размер стека для…
Можно, но это делается в разных операционках по-разному.
В Ubuntu это делается довольно непросто.
Ну, то есть, короче…
В общем, можно, но не сейчас про это.
Если вы знаете, как, я рад за вас.
Но давайте сейчас пока не будем это обсуждать.
Значит, можно изменять stack, можно изменять stack, запрашивать у операционной системы конкретно для данной программы другой размер стека,
но это слишком глубокие уже детали, мы сейчас не будем обсуждать.
Мы считаем, что stack фиксированный равен, как правило, 8 мегабайт.
И это означает, что вам подразумевается, что этого должно хватить для хранения всех локальных переменных и стека вызовов функций.
Ну, если в вашей программе stack вызовов больше, чем 8 мегабайт, то явно что-то не то.
Ну, не должно быть в программе локальных переменных и вызовов функций больше, чем на 8 мегабайт.
У вас уровень глубины рекурсии порядка миллиона, это явно что-то не то.
Ну, короче, считается, что 8 мегабайт достаточно.
И на практике его реально достаточно всегда.
Ну, то есть я не знаю реально случаев практически, когда бы нужно было использовать больше стека, чем 8 мегабайт.
Ладно, знаю, знаю один случай, знаю один случай.
Знаю один случай.
Во втором семестре мы его выбрали.
Короче, бывают, но редко.
И что проводят?
И при чем тут stack?
Ну, допустим, там вектор какого-то большого размера.
Да вектор не на stack хранится.
Ну, я же вам говорю.
Когда вы зовете вектор, он не на stack кладется.
В этом и прикол вектора. Вы понимаете?
Ну, вот если у вас огромный DFS на миллион, то, вероятно, что-то не то.
Ну, короче, просто поверьте.
Как правило, stack больше 8 мегабайт не нужен.
Ну, не просто же так такое ограничение выставили.
Наверное, потому что реально не нужно больше 8 мегабайт.
Если нужно, есть возможность это ручками подправить для конкретной ситуации.
Но это очень редко отбывает нужно.
Что?
Ну, операционка, насколько я знаю, для всех программ stack одинаковый.
Stack одинаковый.
Можно глобально изменить размер stack для всех.
Можно изменить размер stack.
Давайте не будем про это.
Ну, то есть можно много чего...
Что такое программа?
Ну, для каждого процесса у тебя свой stack.
Хорошо.
Куча тоже своя.
Конечно, а как?
А ты думаешь они, типа, отделят ее?
Делись.
Так.
Так вот теперь динамическая память.
Что делать, если вам stack не хватает?
Ну, вот вы же наверняка в своей жизни, Виктора, заводили и побольше, чем на миллион интов.
Конечно.
Кто бы сомневался, особенно ты, да уж куда-то, конечно, заводил.
Да? Ну, хорошо.
И как же они работают?
Ну, дело в том, что вектор, это как раз динамический массив.
Он потому и динамический, что в динамической памяти хранится.
Что такое динамическая память?
Это вы можете в рантайме, и вот сейчас мы приходим к разговору.
Второй раз мы упоминаем термин статический против динамического.
Статический у нас была до этого типизация.
Что значит статический?
Значит в compile-time известный.
Динамический это значит, который в рантайме только происходит.
Что такое динамическая память?
Это память, которая запрашивается в рантайме вашей программы.
Изначально вашей программе дано вот столько.
Но ваша программа, разумеется, может захотеть больше.
Она говорит, мне нужно массив на миллион интов.
Дай, пожалуйста, мне еще миллион, там, еще 4 мегабайта.
Говорите вы операционной системе.
Операционная система, окей, подожди.
Держи.
Вот.
Ну, примерно так это происходит.
То есть, когда вам нужна динамическая память, вы вызываете некоторую функцию,
которая…
Вы вызываете некоторый оператор, который с очереди вызывает некоторую функцию,
которая с очереди вызывает еще некоторую функцию в стандартной библиотеке,
которую с очередь передает управление ядру операционной системы,
которая что-то делает и в конце возвращает вам указатель.
Этот указатель – это новая для вас память, которая не дата, не текст, не стека, где-то вовне.
Опять же, я вас обманываю.
На самом деле все сложнее.
Но давайте считать, что так.
считать что это так это будет лучше всем от этого если указатель равен нулю он лежит сам в
начале вот всего вот это все вот этой указатель равен нулю он не нет он просто это просто это
адреса начинаются с какого-то непонятного числа и заканчивается каким-то непонятным
что это отрезок нет весь отрезок в компьютере а в смысле зависит от програды зависит от
ситуации ты запускаешь программу операционка такая так что тут у меня свободно вот этот кусок
ну вся наверное с нуля ну отгадай что тогда будет а именно сек фолд сек фолд это как раз и есть
ситуация когда вы обращаетесь по указателю вне этого отрезка и вне того что вам операционка
дополнительно выделил динамически но что да что произойдет когда вот здесь
происходит тековая flow к чему это приводит ну если вы попытаетесь туда что-то записать
это все равно будет сек фолд потому что текст вам только начнение доступен скорее всего я думаю
да не уверен я не пробовал но наверное можно вот что и в дефе это вообще не относится это
это при процессе причем тут и в деф я ничего не понимаю нет я ничего не понимаю хорошо вот
когда вы делаете бесконечную рекурсию чего это приводит это приводит к тому что вы
приполняете стэк происходит ошибка называемая стэк оверфлоу но к чему она приводит реальность
стэк оверфлоу это ситуация когда вы переполнили стэк либо вы слишком много завели локальных
переменных но это постараться надо на 8 мегабайт завести локальных переменных либо вы переполнили
стэк вызовов тогда вы в какой-то момент начнете ходить по минному полю ну то есть какое-то время
после переполнения стэка вы еще не схватите сек фолд ну потому что там сложные механизмы
операционная система там у вас есть некоторые зазор по которому еще можно наступать там какие-то
там страницы и стам в какой-то момент вы начнете наступать куда нельзя, но это минное поле в какой-то
момент вы наступите и вас убьют потому что вы наступили на то, что операционная система уже считает не
ваши чужое нет можно наступить на страницы которые вам выделено но страницы они чуть
шире чем на самом деле стэк и еще там есть разные
другие механизмы в общем уб просто и все вот на уровне
на уровне понимание наш на уровне абстракции плюсов
я говорил что мы живем в мире c++ у нас есть термин
уб вот термином уб описываются все ситуации вида я сделал
что-то запрещенное по отношению к операционной системе
вот в стандарте c++ нет никакой никакой терминологии
вида там сек фолт или там что-то там значит флотинг
поет exception в стандарте c++ отсутствуют в принципе
такие термины это термины уровня операционности уровня
ниже стандарт c++ лишь говорит вы обязаны так не делать
а если так делаете уб на практике я говорю что происходит
вот соответственно стандартом говорит вы обязаны не превышать
глубину стэка который вам выделен изначально а если
превышаете уб вот так вот динамическая память что
что такое динамическая память ну это значит способ
запросить дополнительно к тому что у вас есть еще
памяти как это делается и вот для этого существует
оператор нью как это пишется вы пишете ин звездочка ну
допустим мне нужно еще инт ин звездочка п равно нью
инт вот прям так а почему у нас в задачах ничего не
ломается нам выдают большой стэк ну то есть мы даем
задачу где там ну dfs на 1.6 ну прием на самом деле 1.6
значит в контесте у вас вероятно стэк действительно
специально увеличен ну возможно в контесте в настройках
просто стоит прикомпиляция флаг чтобы сразу запласть
ну не прикомпиляции может быть прикомпиляция может
при запуске чтобы стэк был побольше может быть вот
так вот ин звездочка п равно нью инт оператор нью у
него такой синтаксис вы пишете нью пробел дальше
название типа а дальше опционально вы можете написать в круглых
скобочках чему равенны ну то есть 5 например да значит
вы создали новый инт 1инт за значением 5 то есть создали
инт сразу принцелизировали пятеркой вот оператор
нью возвращает вам указатель на t где t вот этот тип который
вы тут назвали что он делает в реальности он ну тут уже
мы опускаемся на низкий уровень что происходит ну
как я уже сказал вызывается некоторая библиотечная
функция которая там еще вызывает мне в свою очередь
некоторую библиотечную функцию которая в конечном счете
передает управление ядру операционной системы то
есть на самом деле когда вы вызываете нью ваша программа
на маленькую долю секунды прерывается ну она опять
же не совсем правда ну давайте считай что правда то
есть когда вы запрашиваете нью вы на самом деле говорите
так а теперь мне нужна еще память поэтому операционная
система дай мне еще операционной и все и и отдаете управление
ей операционная система что-то делает и возвращает
управление вам в какой-то момент держи вот тебе указатель
динамическая да так у нее вся оперативная память
распоряжение операционная система на той операционной
системы что распоряжается всеми ресурсами компьютера
вот в том числе да она всем распоряжается а вами
может вас убить как мы уже выяснили вот ну можно но не сейчас обязательно есть
мир в труху но потом можно перегрузить оператор нью но потом значит хорошо
теперь когда вы так написали у вас п это некоторые указатель под которым 4
вам принадлежит если вы обратитесь хоть на байт влево или вправо от этого п это убе конечно же
вот дальше ну можно поэтому указатель менять значение понятно там звездочка
п присвоить один ну то есть все вот поэтому указатель лежит инты вы можете спокойно с
ним работать когда вам эта память перестает быть нужна вы обязательно должны сделать
противоположное действие а именно вызвать оператор дилит вы пишете дилит п дилит п это
ключевое слово дилит это ключевое слово нею это ключевое слово то есть зарезервированные
слова языка дилит п этот вызов в свою очередь противоположные симметричные функции которые
обратной функции скажем так которая говорит операционная система все считает что я освободил
она такая окей ну там в свою очередь что-то происходит и все управление возвращается
оператор дилит ничего не возвращает то есть не возвращаемый тип void
давайте в перерыве после пары мы пора это поговорим я не хочу сейчас честно на такие
вопросы отвечать давай давай пока что-нибудь нормального обсуждать они вот это так хорошо
вот вот здесь есть такой важный момент а мы подошли к одной из важных развилок таких вот знаете
вот вот вы когда идете по дорожке по тропинке в лесу бывают роковые повороты что вот да бывает
вы значит вот ну как бы вы сейчас один из тех моментов когда определяется наша судьба на ближайший
год вот что я имею в виду ну я имею в виду что в других языках все не так и вот это не так оно
феноменально совершенно образом меняет весь стиль программирования на этих языках когда вы
так делаете в джаве вам не надо писать никакой дилит там вообще нет такого слова дилит ну или
в си шарпе когда вы так делаете и вообще когда вы делаете так в нормальных языках нет никакого
дилит вот это очень такой это ключевой момент ну я уж не говорю что в джаве вообще и указателей
то нет и там вот но это не так критично критично что нет оператора дилит как и в питоне нет
ничего подобного в языках которые скажем так попроще эта конструкция совершенно не так выглядит
когда вам нужна динамическая память вы просто говорите new и все больше вы не паритесь на этот
счет в плюсах не так в плюсах вы обязаны сами освобождать всю память которую когда-либо
запросили у вас отсутствует так называемый сборщик мусора как устроено выделение динамической
памяти в джаве и в прочих языках например си шарпе с сборкой мусора когда вы говорите new ну
вам выделяется память но у вас в runtime параллельно с вами всегда незаметно от вас работает еще
некоторая некоторая ну так скажем под процесс что ли который следит сам за тем сколько вы
выделили используете ли вы то что вы выделили и когда он замечает из некоторых соображений что
все кажется вы больше это не используете то есть когда вы потеряли все ссылки указатели на то
что вы выделили он сам делает дилит это называется сборщик мусора гарбач коллектор вот в джаве в
этом самом в шарпе и в питоне и вообще во всех нормальных языках есть garbage
коллекторы они garbage коллектор это средство языка которая незаметно от вас
работает во вран тайме всегда вы не садите ну его кажется можно отключить там
каким-то хитрым спор питоне кажется есть функции который отключает garbage
коллектор но по умолчанию он работает и он замедляет выполнение вашей программы
незаметно для вас но он следит за тем что вы все что выделили освободить и не
используете освободилась бы понимаете а в плюсах нет понятно почему нет потому
что мы за эффективность топим вот но это критический момент из-за которого
программируем на плюсах становится там раза в два сложнее потому что всякий раз
когда вы написали new и либо забыли сделать delete либо сделали лишний раз
delete у вас большие проблемы всякий раз когда вы сделали new и забыли написать
delete вы отжираете операционки кусок оперативной памяти который пропадает как
бы без вести что называется нет до тех пор пока программа ваша не убьется то
есть когда программа завершается операционка подчищает операционка то
помнить что она вам отдала она подчищает но если у вас сервер который
работает круглосуточно и вы в нем где-то делаете new вот например если у
вас программа выка звонки которая где я сейчас ну и вы там делаете new
которая у вас бывало когда-нибудь такое ну ладно выка звонки вот например
одно фотошоп он тоже на плюсах кстати написано по моему у вас бывало когда
не такое что в фотошопе работаете и вдруг ни с того ни с сего оперативная
память вот так вот вот начинает расти расти расти расти используя оперативной
памяти бывало да такое ну скорее всего скорее всего это потому что там где-то
не уделается от элит забывая ну то есть там что-то происходит и где-то и в
виду того что слишком сложный код забывается сделать дилет для как для
какого-то нью и оно там происходит в цикле и все пока программа работает у
вас оперативная память занимается все но не отдается обратно вот я не знаю ты
что я думаю швадоби работаю что ли ну я не знаю это эти баги они время от
времени возникают в больших проектах там раз там в какое-то время ну есть
какой-то баг по фиксе какой-то может нет то есть у вас может быть миллион
мест где вызывается нью и во всех них вы должны сами проследить что дилет
вызывается ровно один раз не больше не меньше и вовремя да что статический
массив как следует из названия выделяется на статической памяти если
имеешь ввиду массив который объявлен локально то он не статический он
выделяется на стэке если напишешь статик инт а то это будет статической
памяти если просто инт а квадратной скобочки это будет на стэке давайте про
массивы я поговорю когда будет тема массива она будет следующей после этой
да вот если второй раз вызвать дилет но опять же есть есть ответ на разных
уровня глубины значит давайте сначала как математики дадим самый абсолютно
точный абсолютно бесполезный ответ будет убе теперь более полезный ответ но не
точный ну скорее всего будет секвелт ну потому что ну будет дабл ну или будет
дабл фрио корапшин как мы видели там вот ну в общем будет какая-то антайма
эррор вероятно а может и не будет может быть компилятор соптимизирует как-то
или что-то заметит по ходу и не станет этого делать вот а двойное удаление это
очень частая причина падения программ на плюсах вот я бы сказал что наряду с
обращением по неправильному индексу двойной дилет это вот ну по крайней мере на
первых порах вот когда вы будете писать какой-то код вот вот в основном
потоке люди уже в чате там что-то начали писать кодить по алгоритму уже начались
мы еще с ними это не успели пройти они а что у меня дабл фрио корапшин почему
что я сделал неправильно я вот всего лишь выделил нью а потом что-то ну короче
это частая причина потому что вы особенно когда пишете о пешный код вы
можете не проследить что дилет вызывает на самом деле два раза не один по одному
и тому же место и все и у вас беда значит отличный вопрос что произойдет если я
вызываю нью а оперативной памяти нет больше на меня не хватает ну на самом
деле будет run-time-err со словами сейчас терминейт колд автор throwing an
instance of std bad alloc aborted core dumped вот я я вспомнил точный текст но ну на самом
деле оператор нью бросит так называемое исключение которое будет
после чего вызывается функция abort и будет ошибка abort core dumped ну да разумеется я имею
в виду оперативной памяти обобщен в обобщенном понимании оперативная память это все на самом
деле не совсем оперативная память может быть еще файл подкачки тут может быть ладно не важно
ну в общем это абстракция мы на самом деле работаем не с физической памятью а с виртуальной так
называемой памятью то есть пространство адресов оно транслируется в физическую память как-то
по-своему это отдельная еще тема но это не относится к нашему курсу мы считаем что у нас
оперативная память непрерывно и как бы она вот такая вот большой кусок один да значит ну если
памяти не хватит туда то вы упадете эту ситуацию можно обработать но про это мы тоже будем позже
разговаривать мы пока считаем что такого не происходит ну вот теперь если вам надо так о чем
мне еще надо вам сказать по этому поводу вроде я все даже сказал а окей это значит динамическая
память так вот а как же устроен вектор то на самом деле вопрос который так долго всех волновал
наконец давайте я вам расскажу а то как-то вы очень видимо не комфортно себя чувствуете что
сайзов вектор это 48 и всегда и все но вектор это что вектор это динамический массив который
в себе хранит указатель и два числа по факту что такое вектор потому что не только это он
хранит но я не буду вдаваться в такие подробности на самом деле у вектора у вектора вектора именно
размер поменьше чем 48 я думаю 24 сайзов от вектора 48 многовато мне кажется поменьше я думаю либо
16 либо 24 должен быть может быть у вас там просто числа бы короче из чего состоит вектор 24 ну вот
вектор состоит из одного указателя и двух чисел одно число называется сайз другое число
называется кэпэйсити вот и все что хранит вектор а указатель указывает куда-то в динамическую
память ну смысл вектора в том что он за вас он скрывает от вас все вот эти вот действия когда
вы делаете pushback он за вас ну вы знаете как работает динамический массив он там если закончилась
кэпэйсити то нужно расшириться в два раза и переложить все на новое место освободить старый
кусок если там не закончилось то значит надо сдвинуть сайз ну и короче но сам вектор как
как переменная он маленький в нем всего лишь вот это вот и все лежит там указатели два числа а
указатель уже указывает на динамическую память понятно что ну я и думаю что 24 вот почему 24 ну
потому что вот это 8 ну и видимо вот эти по 8 еще да ну потому что сайза кп тоже должно быть
наверное 8 байтами потому что если у вас 64 битная система то вообще говоря у вас же может быть
вектор размера ну ну да типа у вас 32 битной недостаточно ну у этих переменных сайз т типы
ну и размер сайз т на 64 битная система вероятно 8 поэтому по факту у вас хранится
один указатель два числа то есть 24 вот на самом деле там хранится еще кое-что вообще говоря но
мы не будем об этом в стандартном случае там только это хранится не 12 а 16 а если 30 ну видимо
12 да ну а что вас смущает то же самое со строкой строка хранит тоже указатели два числа то же
самое со всеми стандарт с мэпом сетом что-то что хранит мэп ну он хранит там указатель
на начальной вершины и там еще какие-нибудь пару чисел там какие-нибудь до красно-черного
дерева нужных и сайзов любой переменной константа сайзов любого типа точнее константа
константа известный момент компиляции причем поэтому не надо удивляться что сайзов от вы
берете сайзов от какого-то там странного дерева мэп unordered map и он всегда там 48 ну он всегда
такой просто все то что там и меняется размер у него у чего оно в динамической памяти лежит
а у вас хранится только указатель на стеке понятно теперь почему сайзов от всех этих вещей
константа и понятно почему такая константа я надеюсь ну давайте я сейчас не буду считать ну
придет время мы поразбираемся из чего там состоят ноды но ну сколько-то занимает какие-то там
поля хранятся ну что там ну это сложно там сложно понять что такое короче ну как красно-черное
дерево ну что у него там указатель на лево сын направо сына на предка дата собственно ключ
и еще флажок бел красное или черное ну и все вот окей последнее о чем я должен здесь сказать это
локальные статические переменные что такое локальные статические переменные вы можете
произвольную переменную объявить статической например я могу сказать вот здесь ну любую
локальную любую локальную переменную назвать статично static int ц равно нулю это означает что
она будет храниться теперь не на стеке, а в дате. Вот.
И это означает, что ее значение будет сохраняться между
вызовами этой функции. То есть она теперь, один раз
создавшись, на всю оставшуюся программу будет существовать.
Вот. Например, так можно считать, сколько раз функция
была вызвана. У меня тут cout был. Ну вот я могу, например,
написать cout++c. Это я при каждом новом вызове функции
буду число на один больше уводить. Неважно, откуда
я вызываю эту функцию, неважно, с какого уровня вложенности.
Где мы static написали в этой функции?
static int c. Вот. Перед объявлением переменной. Да, прям в ней.
А она, разве, каждый раз наналяться не будет?
Нет. Значит, статическая переменная инициализируется
один раз при первом заходе сюда, и все следующие заходы
игнорируется эта строчка просто. Статическая переменная
создана, ну, она инициализируется в момент, когда ее только
впервые, как бы, в общем, первый раз в первом заходе,
а потом, да. И что?
Ну, c. Это другая c. Это локальная c, а та глобальная
c. Это, ты возвращаешься к разговору о том, как устроены
области видимости. То, что я сейчас сказал, не отменяет
всех тех разговоров про то, как устроены вложенные
скопы. Это переменная более локальная, чем глобальная,
поэтому в этом контексте c означает эту c, а не ту.
А в чем плюс статика? Чтобы глобальных переменных
не создавать, например. Не знаю. Чтобы у тебя в глобальной
области видимости не было каких-то странных переменных,
которые доступны из всех функций и во всех областях
видимости видны. Ну, я могу предполагать, почему он такой.
А, три указателя хранятся. А, кстати, да, это логично,
потому что это же быстрее, наверное. Потому что тебе
не надо арихметику указать. Ну, хотя спорно, не знаю,
что из этого быстрее. Ну, наверное, да, это быстрее,
потому что… Да, наверное.
Наверное, это мудрая оптимизация, но, наверное, так оптимальнее
хранить. Да.
Есть ли какое-то ограничение на размер статической памяти?
Можно ли его статическими переменами сделать неадекватно
большим? Ну, можно. Это опять-таки ограничение
на уровне операционки ставится. Т.е. там аналогично стэгу
есть какое-то ограничение, которое можно переполучить?
Не знаю. По-моему, по умолчанию нет ограничений. Вы можете
запросить статический массив какого угодно размера,
и он создастся. Ну, я пробовал в свое время. Ну, просто
это означает, что когда ваша программа загрузится
в оперативку, это означает, что сам ваш бинарник будет
весить вот столько, сколько вы попросили. Ну, это правда
зависит от того, инициализирован этот массив или нет. Ну,
на самом деле, дата подразделяется на инишалайз-даты и аннинишалайз-дата.
И вот инишалайз-дата – это дата, которая вписана прямо
в бинарника, а аннинишалайз-дата, которая… Ну, короче, это
вот как раз то, о чем я не хотел рассказывать. Но
в целом можете какой угодный размер запросить. Да?
А получается, в цене нельзя обратиться из другого
скопа какого-то из… Ну да, целокальная переменная
для f. По ее указателю можно?
По указателю можно. Причем это будет не у b.
А указателю вообще куда угодно можно запросить?
А ты что хотел спросить? Ты это и спросил, да? Ну,
к указателю можно. Можно вернуть отсюда указатель
на int, то есть я могу сказать вот так, например.
И использование этого указателя будет легально
во всей программе. Потому что это статическая переменная,
она один раз создана, и все, она существует до самого
конца программы. Вот по этому указателю можно будет
обращаться всегда. А мы можем delete быть?
Если сделать… Кого? Этот указатель.
У b тогда будет, но на f.
Delete вызывать можно только для динамической памяти.
Delete можно вызывать только для указателя, который
был вам возвращен как результат вызова new.
Причем ровно с тем же типом и ровно на том же байте.
Вот если вы хоть на 1 сдвинетесь правее-левее, и там delete,
все, у b.
Кстати, мне предпочитать, что нельзя, что ли, и не гарантируется,
что по указателю можно обращаться. Конечно нет,
локальная переменная уничтожается, когда ты из функции выходишь.
Все, она не действительна. Дальше по этому указателю
битой будет… Ну там будет неизвестно что.
То есть получается, что в статик memory есть свободное место?
Статик memory резервируется компилятором в момент компиляции.
Он видит, что есть статическая переменная в f такая, значит
дополнительно плюс 4 байта к статической памяти надо
заранее запросить. В сумму всех размеров статических
переменных это и есть размер даты. Все размеры статических
переменных сумма компилятор знает, пока компилирует.
Если вы обращаетесь к переменной до инициализации,
это все равно у b. Так. Ну. Нет, давайте я дальше
пойду, иначе мы так очень… Короче, если остались вопросы,
давайте потом, после пары. Еще 10 минут хочу потратить
на рассказ о чем-то другом. Да, вот эта ситуация, когда
вы выделяете какую-то переменную через new и не освобождаете,
называется memory leak. Утечка памяти. Memory leak. Это не
так плохо, как у b, но это все-таки плохо очень и в
корректной программе не должно быть memory leak. Но memory leaky
они компилятором не выявляются, конечно. Выявляются они
только в рантайме и то специальными средствами. Вот. Ну в ангрид
например, да. Вот. Когда вы будете сдавать задачи
в контест, они могут проходить тесты, но обладать утечками
памяти. И мы такое будем отдельно проверять специальным
образом, про это попозже расскажем вам. Ну в общем.
Можно бы сначала в основном что-то предъявить, а потом
… Да, конечно, конечно.
Санитайзерами? Ну да, санитайзерами.
А если там массив условно для мейна был создан в динамической
памяти? Давайте я, пожалуйста, двинусь
дальше, вы задаете вопросы после пары. Мы очень медленно
двигаемся. Я иду дальше, сейчас рассказываю про массивы.
Вот как раз все, что вы хотели узнать про массивы, сейчас
вы сможете спросить. Значит, следующий пункт называется
массивы или рейс. Так, параграмма 2.3 называется массивы.
Что такое массив? Ну как вам объяснить?
В общем, все знают, что такое массив. Давайте я покажу,
как объявлять массивы. Ну, на то вы и про два, что вам
рассказывать всякую ерунду? Может вам еще как if писать
надо рассказать? Значит, как объявлять массив? Это
объявление пока функции мейна, не массива, не путайте.
Значит, ну стандартный синтакт есть такой, я пишу тип,
ну например опять, может дабл для разнообразия, давайте
дабл. Дабл, название массива, например,
а в квадратных скобочках столько. Ну, например, сколько,
например, десять. Вот. Да, вот это массив из десяти
элементов. Я его ничем не пронициализировал, поэтому
он пронициализирован рандомными числами. Вот. Да, если в глобальной
области, то нулями, по-моему, будет пронициализирован.
Ну, в стандарте, наверное. Что? Это будет статик? Кто?
Этот? Нет, это будет автоматизм. На стеке массив. С чего бы
статик? Это массив на стеке. Вот. Соответственно, отличный
вопрос на понимание, что если я напишу дабл а, десять
миллионов? Это сразу стек оверфлоу, да, и вероятно
секфолд. Значит, на стеке вы не можете объявлять массивы,
которые переполняют стек. Ну, логично. Вот. Надежный
быстрый способ сделать стек оверфлоу. Вот, собственно,
объявить массив размера больше, чем байт на стеке.
А что? Какие варианты? Стек оверфлоу это название
ситуации, которое вызывает обращение по несуществующему
индексу. Это причина возникновения секфолд. Стек оверфлоу
это другая причина возникновения секфолд. Там, разыменование
несуществующего указателя. Это другая, третья причина
возникновения секфолд. Так. Я могу изначально проницилизировать
его чем-то. Я могу написать вот так, например. Ну и
хватит. По-моему, да, если я не укажу остальные, то
они нулями просто заполнятся вроде как. Вот. Но я могу
написать десять чисел, и он проницилизируется
десятью числами. Да-да-да. Если написать равно пустые
скобочки, то это, кажется, будет десять нулей. Слушайте,
какие большие массивы. Ну, пустые скобочки можно написать.
Какие ошибки? Может, это был как раз стек оверфлоу?
Ну, вполне возможно, что, ну, слушай, не знаю. Так,
что надо сказать про массивы? А какие операции массивы
поддерживают вообще? Ну, массивы поддерживают, как
ни странно, обращение по индексу. Можно писать
а и т, и, значит, это будет обращение к и тому элементу
а, а. Нумерация с нуля. Но, что более интересно,
и вот что самое важное надо понять про массивы, массивы
это на самом деле почти то же самое, что указатели.
Почему почти? Ну, не совсем. У них различия все-таки
есть. Но в основном это почти указатели. Когда функцию
передаешь, там нужно написать как раз указатель. Да, ну,
значит, существует неявная конверсия из массива в
указатель. То есть, я могу неявно сконвертировать
массив из даблов на указатель, в указатель на дабл. Легко.
Это неявная конверсия, называется array to pointer conversion. Вот.
P и A, по сути, это одно и то, что из себя представляет,
ну, массив в памяти из себя понятно, что представляет.
Десять даблов подряд. Но, что вот эта конверсия будет
делать? Что будет такое P? P это будет адрес начального
элемента, да. Вот. Соответственно, я могу на самом деле к указателям
тоже применять операции, как будто они массивы. Я
могу вывести P первое, и это то же самое, что A первое.
То же самое, что, видимо, звездочка от P. Да. А 1ll от P, это то же самое, что P от 1?
Там просто 1 от P. Что такое 1ll? А, господи, вот это. Да.
Смотрите, что на самом деле означает операция квадратной
скобочки в языке C, если речь идет о массивах или
о указателях. Это на самом деле эквивалентно написать
звездочка от P плюс 1. Это прям строго эквивалентно
для указателей и массивов. Не для векторов, только,
боже упаси. Вот. Если у вас это объект, там, вектор
или стринг, это не так работает. Квадратные скобочки для
классов, плюсов, работают не так. Но для осишных
поинтеров и для указателей это работает вот прям строго
так. В частности, можно написать 1 с квадратными скобочками
P, и это будет то же самое, потому что это будет означать
звездочка от 1 плюс P. Вот. Да. Что ты? Да-да-да-да, подожди.
Ну-ну-ну. Не явное приведение массива к даблу, это не считается
плохим бурстайлом? Не к даблу, а к указателю на даблу.
Нет, не считается. Это как раз, это как раз, это C-стайл,
но это как бы классический. А вот тут на самом деле большой
вопрос про последнюю строчку. А как у нас определяется
размер одного элемента? Кого? В смысле размер одного
элемента. Вот это прям заменяется вот на это. Что значит размер?
Какой размер? Вместо этого компилятор делает это,
и все. Сложение указателей с числом, указатели с числом
мы уже понимаем как складывается. Вот, можно обращаться к
массивам по отрицательному индексу. Вот смотрите, я
например могу сказать так, double P равно a плюс 2. Тогда
я могу спокойно вывести минус первый элемент P,
и это будет корректно. Массив с чем? С префиксу? Да,
ну вы можете завести массив, в котором будет индекс минус
1. Просто вам нужно указатель, ну как бы вам нужно указатель
на начальный элемент поставить на самом деле не на начальный
элемент, а вот на следующий за ним, да. Да, вот. Значит
всякий раз, когда вы с массивом пытаетесь произвести какую-то
операцию, то он не явно конвертируется в указатель, кроме там пары
случаев. Ну вот, когда вы говорите a плюс 2, это вы значит
берете указатель на, просто на второй элемент, то есть
a второе. Вот. И вы получаете адрес вот этого элемента
в результате. Ну и дальше можете вот так обращаться.
Вот. Чем массивы такие отличаются? Как массив
принять функцию? Да так же, надо просто по указателю
принимать. Если вам нужно a передать функцию, то вы
просто принимаете в нее double звездочку, и происходит
неявная конверсия при передаче. Нет, вы можете явно написать
именно массив размера 10, но это не обязательно. Можно
просто принимать звездочку и нормально. Вот. Давайте
последние пару вещей скажу, и все уже на сегодня. Значит
чем массивы отличаются от указателей, тем не менее?
Массивы нельзя, ну вот, например, нельзя вот так с массивом
сделать. Нельзя делать плюс-плюс-а в отличие от указателя.
Ну потому что массив, это все-таки массив, и как? Ну,
это не одно число, не один указатель. Он у него какой-то
должен быть, ну он на стеке занимает много места. Нельзя
просто инкрементировать, это не понятно, что значит.
Массив это массив. Это другой тип. Это такой тип. Вот. Тип
этого переменной, это массив даблов размера 10. 10 это кстати
тоже часть типа. Вот. А size of от массива, в отличие
от size of от указателя, это сумма size of всех его элементов.
Size of от вот такого а будет 80. А size of от п это будет 8 просто.
Это с-е. Это нестандартное расширение языка, которое
поддерживается не всем компиляторами. Так, а последняя вещь, которую
я вам скажу, массивом нельзя присваивать другие массивы.
Смотрите, если у меня есть другой массив размера
10, допустим, b это тоже массив размера 10 из даблов, и я напишу
a присвоить b, это будет с-е, потому что нельзя массиву
присваивать массив операторам присваивания. Вот указателю
можно присвоить массив, а массиву что-либо присвоить
нельзя. Просто нельзя, так решил комитет по стандартизации,
и это логично, потому что ну а как, у вас на стеке
лежит массив, а за ним другой массив, допустим, как вы,
типа, у вас что кусок стека пропадет от такого, как
это сделать, непонятно. Вот это пример l value, которому
нельзя присваивать. Я вам говорил, что такие примеры
будут. По определению, любая переменная сама по себе
это l value. С массивами можно делать все то же, что с указателями,
только не, еще раз, обращаться квадратными скобочками,
складывать с числами, брать разность, разыминовывать.
Все то же, что с указателями, но только не сдвигать сам
а менять сама нельзя. Вот, ну, я вам, правда, не рассказал
про оператор NU с квадратными скобочками, ну ладно, ну,
то есть, можно выделить массив просто на динамической
памяти, квадратные скобочки написав. Ну ладно, это в
следующий раз, все на сегодня, если есть вопросы, подходите
спрашивайте.
