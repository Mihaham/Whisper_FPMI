Всем доброго дня! Мы с вами продолжаем изучение наших алгоритмов и сегодня мы будем доказывать алгоритмы Erli.
Те, кто смотрит записи, на текущий момент может поставить паузу на видео и осознать, что происходит на доске,
потому что здесь уже выписаны основные операции, по которым у нас строятся алгоритмы Erli.
У нас есть с вами операция Scan, которая двигает букву, при этом у нас позиция ситуации меняется.
Мы немножко переобозначили обозначение для того, чтобы было понятно, что ситуация это не что-то, принадлежащее какому-то множеству,
а что это тройка объектов, которые у нас существуют в объекте.
У нас есть три операции Scan, которая позволяет нам двинуть букву за точку,
операция Predict, которая позволяет спуститься в дерево разбора, внутрь раскрыть не терминал,
и есть операция Complete, которая закрывает определенные правила.
Наша цель сейчас пройтись по алгоритму, который делает следующее.
Он пытается максимально прокинуть все возможные операции для принадлежности слова грамматики.
Наша цель, опять же, у нас есть какое-то слово, нам нужно проверить принадлежность его произвольной грамматики.
И нам нужно доказать сегодня основную лему о корректности и полноты,
которая стоит в следующем, что если мы правильно с вами напишем алгоритм, нигде не накосячим,
это важно, потому что в коде все-таки можно накосячить,
то у нас ситуация А, стрелочка, альфа, точка Б и G появляется в наших выводах тогда и только тогда,
когда существуют такие Пси и Альфа, что из Альфы у нас выводится символ с Итова до Житой,
то есть получается у нас из вот этой последствия терминалов будет выводиться символ от Итова до Житого,
а это значит, что позиция родительской точки, которая у нас была в деле вывода на картинках,
она как раз будет от нулевой до Итой.
И дальше сделаем следующее, что у нас с вами есть из С3 вывод до того, как мы спустились в наш не терминал А
символа с нулевого до Итого, потом за один шаг мы раскрываем не терминал А по нашему правилу
и с А выводим Альфа, Бета, и дальше за какое-то количество шагов мы раскрываем нашу Альфу
и выводим символы с этого до Житого.
Нам нужно будет доказать это лему в две стороны.
Значит, во-первых, что если у нас в правиле, выводя вот такими правилами наше соответствие,
мы получаем вот такое дерево вывода, и с другой стороны, если у нас появляется какое-то дерево вывода,
то мы получаем с вами вот такой результат, то есть что у нас такое правило появляется.
Напомню, что у нас с вами есть стартовое предположение, что у нас с вами в грамматике
существуют правила из С' выводится С, и начало нашего алгоритма это следующая ситуация.
С' стрелочка точка С00.
Да, это означает, что мы начали наш разбор.
Это такая водная часть, сейчас будут доказательства.
То есть, если у нас ситуация существует, то у нас делан вывод.
Давайте мы сначала будем доказывать утверждение с левого стороны вправое,
и начнем рассуждать про следующее.
Будет индукция по количеству шагов алгоритма.
Итак, база индукции какая?
Да, вот мы начальная ситуация, база. У нас появилась ситуация, вот она.
Как тогда построить вывод?
Ну, смотрите, S' выводит, смотрите, V00 S' ε.
Вот с этим согласны выражения?
Я просто взял, подставил И равное нулю.
Apti равное ε.
Потом за один шаг мы с вами раскрываем S'Vs.
И при этом точка у нас стоит здесь.
То есть у нас получается α тоже равняется ε.
И мы можем сказать, что это тоже символ с нулевого по нулевой.
И в нашем случае, в наших определениях это будет V и gt.
Ой, извините.
То есть видите, все вроде честно в наших определениях.
Хорошо, это база.
А дальше проверяем переход.
Какая операция вам сегодня больше нравится?
Скан, предикт или комплект?
Скан. Ну хорошо, давайте начнем со скана.
Значит нам нужно проверить, пусть у нас какая-то операция появилась по скану.
Мы можем сказать, что это у нас, извините, ситуация появилась вот такая вот.
Альфа точка бета и g плюс один.
Ну тогда давайте напишем, какой у нас получается вывод, мы ожидаем.
Но он у нас получился из того, что а, альфа точка, так, только альфа, а точка бета.
Точка а бета и g появился был до.
А это значит, что по предположению индукции мы можем сделать следующее.
Мы можем написать вот такую вещь.
В ноль и, а, и.
И за один шаг у нас раскрывается ноль и.
Дальше у нас идет альфа, а бета, си.
Да, собственно, вот оно у нас правило перед точкой.
Теперь смотрите.
Из-за того, что у нас альфа выводит v и gt.
А v и gt равняется а.
То, что у нас выводится из альфа, а?
Проспаемся.
Ну, конечно же.
V и gt плюс один.
И в итоге, в нашем случае, для вот того дерева вывода,
си остается тем же самым, да?
А вот это будет такой альфа штрих,
который мы хотим вывести.
То есть вот оно, альфа а, которое выводит символ ситого дж плюс первого.
То есть позиция точки у нас сохраняется.
То есть здесь некоторые манипуляции.
Важно понять, что именно вот этот символ был точно таким же.
Так, со сканом понятно, что произошло?
Хорошо.
Следующая операция – это предикт.
Предикт.
Значит, у нас появилась ситуация вот такая при предикте.
А это значит, что у нас было какое-то правило до этого.
То есть у нас был...
Значит, существовало правило.
А, альфа точка б бета и ж.
Ну раз у нас существовало такое правило,
то смотрите, давайте выпишем, что у нас происходит.
У нас происходит следующее, что из штрих
у нас выводится v нули.
Дальше у нас вводится апси.
За один шаг у нас выводится v ноль и альфа бета б пси.
Это предположение индукции.
Двигаемся дальше.
Значит, для того, чтобы у нас применилось предположение индукции,
мы должны за один шаг каким-то образом раскрыть b.
Ну давайте посмотрим.
Поскольку у нас из альфы выводится v и gt,
то вот это все превращается в вывод v ноль gt.
B бета пси.
И вот здесь мы как раз уже за один шаг
раскрываем, смотрите, что v ноль gt,
я напишу здесь, смотрите, важно,
эпсилон гамма бета пси.
Зачем я написал эпсилон?
Потому что эпсилон это то же самое, что w gt gt.
Делает специальный трюк, чтобы показать, что на самом деле у нас вот это вот альфа,
которая у нас существует в условиях леммы, на самом деле это пустое слово.
А мы раскрыли это все до того момента, как мы получаем символ с нулевого pgt.
То есть в итоге у нас для вот этого правила индукционный вывод тоже будет существовать.
Я вижу какие-то смущения.
То есть наша цель, как только мы заходим в какое-то внутреннее дерево вывода,
проверить, что было до этого,
и проверить, что закрывалось, как только мы спустились в это дерево.
Так, с предиктом понятно, что произошло?
Так, хорошо.
Собственно, прописываем вот такую вот вещь.
Так, хорошо. Здесь мы тоже все разобрались. Теперь с комплитом.
Значит, с комплитом все сложнее.
Так, а где тряпка?
Тряпка, ты где?
Тряпка спряталась.
Нет. Никто не видит синюю такую вещь.
Нет, там есть, но правда это просто сильно замедляет скорость нашего чтения.
Обычно тлокомплименты, которые мы делаем, они просто замедляют скорость нашего чтения.
Нет, там есть, но правда это просто сильно замедляет скорость нашего чтения.
Обычно тут сухая тряпка лежала.
А?
Нет.
Нет.
Что, вы думаете, что я могла это?
А?
А, вот ее кто. Все, я говорил, что я видел. Ее в компьютер засунули.
Еще бы доску от цифровалеба.
Как?
Ну вот.
Итак, комплит давайте разбирать.
Значит, предположим, что у нас с вами появилась ситуация альфа, бета, точка b, и g.
Тогда, значит, у нас есть два вывода.
Первая, то у нас было правило какое-то бета, стрелочка, гамма, точка, k, g.
А и было альфа, альфа, точка, бета, бета, и k, t.
И давайте мы сейчас выпишем два предположения индукции.
Значит, первое предположение индукции будет следовать, что из эш-трих, давайте начнем со второго лучше.
Из эш-трих выводится символа нулевого по итой.
Дальше у нас получается с вами, что у нас, а, пси.
Дальше за один шаг раскрывается это все, в, нулевое, ит, альфа, б, бета, пси.
А здесь у нас получается, что на самом деле у нас есть вывод в, нулевое, k, t, гамма, пси-штрих.
Вот, при этом, так, я что-то погорячился, бета, и за один шаг, b, нулевое, k, t.
Не, не, не, мы же для правила пишем.
Не, там же от корня у нас все зависит. То есть, мы все выводы вот в этой лемме, которые используем, пишем для корня.
То есть, как только у нас появляется вывод, то мы его выводим от начала слова.
Вот, значит, смотрите, что у нас получается. У нас получается вот такой вывод, и теперь нам надо их грамотно сконкатенировать.
Что мы хотим с вами? Мы хотим, чтобы, на самом деле, из альфа, бета, выводился символ с итовопокатой.
С итовопожитой. Потому что, вот, смотрите, вот это вот, вот этот вот вывод, он по факту работает, давайте я напишу так, в кавычках, работает для i.
То есть, работает для позиции родительской точки, которая у нас здесь закодирована.
А значит, нам нужно понять, почему у нас из альфа, бета будет выводиться символ с итовопокатой.
Ну, давайте рассуждать. Значит, из вот этого вот, да, у нас граф не планарный, будет следовать, что гамма выводит символ с катовопожитой.
Ну, и из этого будет следовать, что b выводит символ с катовопожитой.
Да? А из вот этого, будет следовать, что из альфа выводит символ с итовопокатой.
И используя вот эти два свойства, мы получаем, что из альфа, бета выводится символ с итовопожитой.
А это как раз то, что мы хотели вывести между родительской позицией и нашей текущей.
Окей? Вот. Давайте еще раз продублируем. Собственно, была позиция. Была еще раз позиция.
Пишем предположение индукции. Из альфа выводим символ с итовопокатой. Из бета выводится символ с катовопожитой.
В итоге мы получаем, что из альфа, бета выводится символ с итовопожитой.
Что из альфа, бета выводится символ с итовопожитой.
Итак, понятно ли доказать это в одну сторону? Что сделали? Мы проверили базу индукции, мы проверили предположение индукции.
Да, то есть переход индукции для всех трех правил. В одну сторону доказали.
В другую сторону доказали. Да. Сейчас буду полноту доказывать.
То, что если у нас существует такой вывод, то такая ситуация у нас точно появится.
То есть наша цель будет найти как раз предыдущие выводы, которые у нас были, из них вытащить возможные ситуации и потом показать, в какой части алгоритма эта ситуация появилась.
И это первое взрывающее мозгодоказательство.
Да. Ну что, сейчас будет индукция по трем параметрам одновременно на того, чтобы это все сошлось.
Ага. Так. Ну давайте доказать корректность.
Зафиксируем количество шагов, которые было здесь в этой лемме.
Пусть вот этот вывод у нас был за к шагов, вот этот вывод был у нас за л шагов.
Полноты. Блин, я все...
Рефакторим презентацию в прямом эфире.
Так, где это у нас?
Не, это...
Нашел.
Да.
Все, вроде больше не... Да.
Это полнота.
Да.
Это все доказательство.
Короче, возьмите, зачеркните на слайде.
Да.
Ну, много чего знаю. Вот тут нарушение паттерна dry.
Кстати, нарушение паттерна dry это так искать в любые презентации в Powerpoint.
Потому что там происходит дублирование слайдов в огромном количестве.
Ладно, мы доказываем полноту.
Теперь внимательно, по какому параметру мы будем ввести индукцию.
Я пока не буду это писать на доске.
Мы будем ввести индукцию, смотрите, по вот такой штуке.
По трем параметрам.
Первый параметр – это по длине вывода, по длине g.
Дальше мы введем индукцию по сумме, по факту, по длине раскрытия от s до, по факту, раскрытия последствий не терминалов альфа.
И третий параметр – это параметр, за сколько мы раскрываем символы с итого до житого.
Давайте я напишу g, k плюс l, l.
Тобственно, g – это понятно.
Здесь, скажем так, длина полного вывода.
Нет.
До житого символа.
А вот это вывод от итого до житого.
Ай.
А?
И вот оно.
То есть, за сколько мы выводим альфа?
Ну что, поехали базу проверять.
Ну что, поехали.
Ну что, поехали.
Ну что, поехали.
Ну что, поехали.
Ну что, поехали базу проверять.
Что?
Какие-то вопросы?
Индукция по тройке или к графическому порядку?
То есть, если первое меньше второе, то сначала используется первое.
Сначала по первому, потом по второму.
При равенстве первых используем по второму.
При равенстве вторых используем третий.
А?
Ага.
Так, скажите, база какая будет?
0,0,0.
Так, давайте напишем, что у нас получается.
Значит, из этого штриха,
за ноль шагов мы выводим
В0, И, А, С.
Дальше за один шаг мы это раскрываем.
Альфа, точка бета.
Альфа, бета, С.
И дальше за ноль шагов.
Опять же, подчеркну.
В0, И.
Мы раскрываем.
Что?
А что должно быть?
А, В, И, ноль.
А?
Ну да, сейчас будет два нуля.
Я просто формально выписываю это все дело.
Так, ну давайте рассуждать.
Значит, первое, что мы понимаем с вами,
вот из вот этого, что А равняется штрих.
Си равняется Эпсилон и равняется нулю.
Да?
Логично.
Дальше.
И при этом у нас G равняется нулю.
Так, давайте вот здесь раскроем.
Так, Си, ноль.
Ага, смотрите.
Дальше мы за один раз раскрываем наше правило.
Это значит, что альфа, бета это на самом деле не что иное как С.
Потому что единственное правило, которое у нас существует в правиле,
из вывода С штрих, из С штриха это С штрих С.
То есть, у нас есть единственное правило, что из Д штриха мы в ОМС.
Поэтому у нас получается, что вывод вот такой.
То есть, что у нас в левой части это С штрих.
Давайте напишем у нас.
Прилежит правил нашей грамматики, да?
А дальше смотрите, что мы понимаем.
Мы понимаем, что из альфа выводятся в выводе С штриха.
То есть, у нас есть единственное правило, что из Д штриха мы в ОМС.
Но мы не понимаем.
Мы понимаем, что из альфа выводится в 00 равняется С.
Из этого будет следовать, что в равняется С.
А теперь смотрите чудеса.
Нам нужно доказать, что если у нас встретился такой вывод,
то какая ситуация должна существовать?
У нас должна существовать корректная ситуация в алгоритме.
Вместо А у нас подставляется С.
Вместо альфа у нас подставляется эпсилон.
Точка остается здесь.
Вместо бета подставляется С.
00.
То есть, у нас должна быть ситуация,
из С штрих выводится точка С.
А такая ситуация у нас есть?
Да.
Тобственно, это начало.
Как мы получили, что бета равно С?
Мы понимаем, что альфа-бета это С.
Дальше мы понимаем, что из альфы за 0 шагов мы вывели ВИТ-0.
А это значит, что альфа выводится с символом с 0 по 00.
То есть, у него альфа это пустое.
За 0 шагов.
Смотрите, мы из альфы за 0 шагов вывели С по 00.
То есть, это то же самое.
Вот видите, как мы начинаем очень сильно пользоваться рефлексивностью в отношениях штопора.
Это был простой пункт.
Следующий пункт, который нас ждет.
Вот тут важная идея.
Заключается следующим.
Давайте посмотрим на последний символ альфы.
Вот в этой цепочке, которая у нас есть, рассмотрим последний символ альфы.
Какой может быть такой же символ альфы.
Ж Hofr, что мы здесь собрали Singlet-1.
Вот场я С, у нас могучаяrome.
Аullet-1.
Ну и вот такие hills, до Aunt Edna.
Эк nasty.
Да миг наאת M played Eboard-1.
videmment,剛剛 бы болтали бутылки,vettekybest BH,
Какой он может быть?
Ваши варианты.
Да, давайте я их правильно расставлю в качестве приоритетов,
потому что тут надо правильно понять.
Во-первых, это может быть буква.
Второе, что это может быть?
Это может быть пустое слово.
Третье, это какой-то не терминал.
Рубрика «Интуиция», какое правило из каждых мы будем
выводить, будем искать с вами.
То есть, каждое из этих случаев будет соответствовать
появлению в каком-то правиле.
Как вы думаете, если последний символ альфа, терминал,
то это что будет?
Это будет скан.
Если эпсилон, это предикт, вот видите, точка здесь,
а если терминал, то будем искать комплит.
Да, именно так.
Давайте напишем.
Мы можем сказать, что здесь у нас будет а равно а штрихно
получается b, здесь у нас будет а равно эпсилон а
штрихно b.
Ну и здесь надо уже будет разбирать три возможных
случая.
Итак, первый случай.
Альфа штрих равняется b, альфа штрих равняется
альфа штрих на b.
Значит, смотрите, что мы с вами понимаем?
Мы с вами понимаем, что если у нас новый символ появляется
таким, то нам нужно каким-то образом получить предыдущий
вывод.
И тогда мы можем с вами написать.
Давайте я напишу это все дело.
Так, заказ символов.
Мы выводим символ с нулевого паитой.
Дальше у нас будет альфа апси за один шаг в нулевой
и, значит, альфа, давайте я сразу раскрою, альфа штрих
бета, а нет, нельзя раскрывать, а можно раскрывать, бета
апси.
Ну и дальше у нас с вами получается еще какой-то
вывод.
Значит, смотрите, что мы понимаем с вами?
Мы с вами понимаем, во-первых, что из альфа штрих бета
будет выводиться символ с итово пожитый.
Да, ой, из альфа штрих бета, это просто по тому, как этот
вывод появился, правая часть.
Ага, давайте сделаем из этого два вывода.
Символ номер первый.
Из альфа штрих выводится символ с итово пожитый минус
первый.
Логично?
Второй вывод, который можно сделать, g-ты символ нашего
слова равен b.
Да?
Хорошо.
Так, а теперь смотрите, мы можем для…
А?
Ну да.
Ох ты.
Мачесная.
Да, g-1.
Погласен.
Так, тогда смотрите, для g-1 k плюс l и l мы можем применить
предположение индукции.
И тогда у нас существует ситуация вида, смотрите,
из а стрелочка альфа штрих точка b бета и g-1.
Пользуемся предположением индукции то, что вот у нас
есть вот этот вот вывод, только здесь он был с итово
пожитый символ, а здесь он с итово пожитый минус
первый.
Так, а теперь смотрите, фокус.
Объединяем эти два условия, то есть мы, во-первых, понимаем,
что g-ты минус первый символ это b, а вот этот вывод такой.
Вопрос.
Вот здесь появляется правило вот такое вот, а стрелочка
альфа штрих бета точка b и g, кто нам разрешает сделать
такой вывод?
Scan.
Scan позволяет нам сделать такой вывод.
Хитро получается, да?
То есть мы воспользуемся первым переходом по нашей
алгоритме.
Ещё раз.
Мы делаем вывод, выписываем предположение.
Так, секунду, только пока что параметры представились.
Так, то есть вот такие вот ситуации мы пытаемся с
вами находить в нашем алгоритме, доказать нашему алгоритму.
Так.
Да.
Да.
А потому что, смотрите, вот получается следующая
вещь, что поскольку у нас с вами правило, какое у нас
было?
А стрелочка альфа штрих b бета, да?
То есть у нас именно правило такое имеет вид.
То есть это я объясняю, почему l такое.
Смотрите, вот эта вот бета, которая у нас находится,
она дальше раскрываться никак не будет.
Поэтому количество раскрытия из альфа штрих бета будет
ровно такое же, как количество раскрытия из альфа штрих.
Потому что b это буква, а у нас грамматика контекста
свободная.
Вот.
А при этом вот все, что было до родителя, мы никаким
образом не портили.
Поэтому k будет тем же самым.
Ну да, тут даже не важно, сколько здесь стояло, все
равно этот первый параметр нас перебивает.
Хорошо.
Второй переход.
Давайте рассмотрим второй случай.
Он такой.
Сейчас на слайде будет подкрепительная картинка,
без которой будет очень сложно разобраться.
А?
Так.
G.
Неужели мы хотим перерыв устроить?
Давайте я попробую это.
Я, конечно, не эксперт в орудовании этим всем делом,
но давайте...
Просто она сейчас будет размазней эта доска.
Ага.
Да.
Чего?
Да.
Да.
Да, да, да.
Ну вот это одно из немного доказательств, в которых
нужно именно понимать, типа, что делать.
Нет.
Параметром, да?
Да.
Значит, смотрите.
Давайте начнем...
А, тут картинки сразу.
Давайте посмотрим на картинки.
Эгей, смотрите.
Вот у нас вот такой вот вывод есть.
Да.
То есть за как шагов мы раскрыли так, за один шаг мы раскрыли так.
А дальше смотрите, что у нас происходит.
Давайте зафиксируем количество шагов,
в котором мы раскрывали B.
То есть смотрите, что мы понимаем.
Мы с вами понимаем, что альфа штрих бета...
Давайте я это буду писать, потому что...
Значит, некоторый подкрепительный факт.
Значит...
За как шагов...
Кстати, можно картинки рисовать на колоке?
Это даже это.
Так.
Значит, смотрите.
За один шаг мы раскрываем альфа штрих бета.
Да.
И потом за L шагов мы это раскрываем символом с Итова Дожитой.
Ага.
Это наше предположение индукция.
Да.
Ну, тогда мы можем сказать, что пусть у нас альфа штрих,
за какое-то количество шагов тогда, за T шагов,
может раскрыть символы с какого-то с Итова Попетой,
а бета тогда за один шаг раскроется в какой-то не терминал гамма,
а за количество шагов L минус P минус 1...
Ой, сколько там?
L минус T минус 1.
Будет раскрывать символы с Иппетова Дожитой.
Ага.
Так.
Теперь самое сложное.
Смотрите, здесь надо выписать, заметить две картинки.
То есть, во-первых, нам нужно заметить, почему бета-стрелочка-гамма-точка
будет являться ситуацией, которая у нас уже появилась в алгоритме.
Для этого нам нужно нарисовать эту картинку целиком.
И я попытаюсь это пояснить.
О, кстати, доска нормально стирает так-то.
Чуть не доска, а это.
Альфа штрих бета.
Дальше, значит, у нас вот это за Т шагов раскрывает символ Иппетова Дожитого.
Ой.
А еще, я кажется...
А, нет, все нормально.
С Иппетова Догатой.
А вот это вот раскрывается за один шаг.
Блин, я всегда забываю.
А, по этому.
Вот.
А гамма за L-T-1 шаг.
И тут возникает мем про то, что в русской и английской раскладке одна и даже буква
по написанию находится на одном и том же месте.
Так.
Значит, смотрите.
Рубрика «Собираем конструктор».
Значит, давайте я на картинке это поясню.
Вот давайте выделим вот эту вот вещь.
Колька шагов вывода в обмеденном месте?
K плюс 1 плюс T.
K плюс 1 плюс T.
Значит, давайте напишу так.
Для B стрелочка гамма.
Значит, первый параметр.
Позиция, которая здесь, это g.
Дальше.
У нас идет K плюс T плюс 1.
Плюс...
Смотрите.
L к чему равняется в нашем случае?
Количество шагов вывода с Итого Дожитого.
Плюс L минус T минус 1.
И здесь количество шагов L минус T минус 1.
То есть вот это вот сколько мы вывели до не терминала B.
А вот это сколько раскрыли это?
После не терминала B.
Так, чему это равняется?
Это равняется g.
K плюс L.
Видите, индукция по второму параметру не прокатывает.
Потому что оно то же самое, равенство.
А здесь уже будет L минус T минус 1.
Которая меньше, чем L.
Ага.
А это значит, что для этой штуки мы можем написать правила.
Что у нас существует ситуация из B стрелочка гамма точка KG.
Ага.
Такие, что за...
Тут вспоминаются рекламы этого, зарубежных курсов из Мытища.
Это легендарный мем, ну и вы чего?
Ладно, в конце лекции покажу.
Полное видео.
Так, значит теперь смотрите дальше.
Здесь еще второй вывод нужен.
Утверждается, что есть еще вывод, альфа стрелочка альфа штрих точка B бета.
И G. И KT.
Откуда мы вот это получаем?
Тут, к сожалению, нет маркеров другого цвета.
Но тут, смотрите, параметры будут такие.
Во-первых, здесь будет параметр K.
С которым есть проблема.
То есть, если K меньше G, то все замечательно.
Проходит индукционный переход.
Но если K равнивается G, нам надо двигаться дальше.
Количество шагов вывода от, получается, родителя до вот этого A.
Это K.
Плюс...
Плюс количество шагов раскрытия вот этого терминала альфа.
K плюс T.
И T.
Так.
Да.
Вот так, да?
Вот так.
Итак, смотрите, то есть у нас либо G меньше K.
Ой, наоборот, G больше K.
Либо, если у нас K равняется G.
Так, здесь P, да.
Вот так.
Смотрите, то есть, либо у нас P меньше, чем G.
Либо P равняется G, тогда нам нужно двигаться по второму параметру.
А K плюс T, мы видим, что с вами меньше, чем K плюс L.
Да, потому что в L правил, вот этого вывода входит, в том числе, T правил.
Ну а тогда из вот этих двух правил мы получаем, что у нас альфа...
Альфа штрих бета.
Точка бета.
И G.
О комплит.
И вот здесь.
И вот здесь.
И вот здесь.
О комплит.
Через термины существуют выводы, здесь уже писать невозможно.
Рисуются картинки.
То есть мы схлопнули наш конструктор в двух местах.
Так, это понятно.
На колоке пока ничем.
Поэтому мы сроки, так сказать, с ней спрашиваем.
Ну, на колоке точно ничем.
На экзамене можно будет пользоваться в одной теме конфекта.
Она будет еще.
Вот они выводы.
Да, вот конкретный вывод еще раз, кому хочется посмотреть.
Останавливайте на паузу, фоткайте, в общем, все что хотите.
Следующий, третий случай.
Альфа штрих равняется пустому слову.
Белая доска.
Да, да, да, блин.
Как говорится, рейс кондицион у меня случится тогда.
Так.
Так, что там?
Альфа...
Да.
Альфа штрих равняется епсилам.
То есть у нас получается, с вами...
Опять же, тут будет некоторая картинка.
Вот такая вот.
Давайте посмотрим, собственно, каким образом у нас был получен А.
То есть у нас с вами, смотрите, по идее должно быть,
из А выводится альфа-бета,
но поскольку альфа у нас это пустое слово, то мы получаем вот такую вот ситуацию.
Давайте я тут ее нарисую.
Из эш-штрих мы, получается, сда, ка шагов.
Получаем силу в нолито.
Дальше у нас идет А.
И дальше за один шаг мы получаем с вами что-то,
что у нас состоит точка.
Здесь вот у нас пустое слово.
Я специально подчеркну вот эту вот всю вещь.
И давайте поднимемся на шаг вверх
и посмотрим каким образом родился у нас символ А.
То есть там мы спускались вниз, здесь мы поднимемся вверх,
а что значит, что у нас появился не терминал А?
Это значит, что существует какой-то не терминал, который его породил.
Получается вот такая картинка, что у нас сверху существует какой-то не терминал В,
который вот тут вот висит,
я тут тонко нарисую, и вот он порождает не терминал А.
То есть у нас получает следующая вещь,
то есть за штрих, за k-t-1 шаг мы породили какое-то слово с нулевого попета.
Дальше у нас появляется какой-то не терминал В
и некоторый С-штрих.
Здесь за один шаг мы с вами порождаем какой-то гамма,
и дальше у нас появляется какой-то не терминал В
и некоторый С-штрих.
Мы с вами порождаем какое-то гамма,
и дальше у нас какое-то альфа дельта.
И получается за один шаг здесь у нас получается бета,
а здесь количество шагов чему равняется у нас?
k-t-1, здесь получается t шагов, мы порождаем слово с этого поитой.
Еще одна важная идея, которая есть в этом доказательстве,
что если у вас есть какой-то не терминал и непонятно что с ним делать,
посмотрите как он был выведен.
Вот, мы посмотрели как он был выведен.
Ну давайте теперь рассуждать, что мы здесь видим.
Наша цель получить правило альфа стрелочка точка бета.
По предикту.
Значит, как мы его можем получить?
Нам нужно посмотреть на вот это вот поддерево.
Угу.
Ну давайте представить какие у него предположения индукция.
Собственно, здесь у нас i,
которая равняется g в нашем случае.
Да?
Да, альфа равно и апсилон.
Блин, надо еще раз поправить презентацию.
Так, смотрите, значит здесь у нас символы совпадают.
А теперь считаем количество суммарных выводов, которые у нас есть.
Значит, здесь у нас получается следующая позиция.
Первое, что здесь у нас возникает, это k-t-1+,
позиции, из которых мы попытались вывести вот этот не терминал.
Да, здесь, кстати, за ноль шагов мы выводим апсилон.
Так, а хотя это неважно.
Так, смотрите, то есть у нас получается вот для вот этого дерева,
для вот этого дерева.
Так, сейчас секунду.
Вот здесь количество позиций, которые мы вывели.
Это k-t-1, вот если мы рассмотрим вот этот вот блок.
Плюс количество позиций, в которые мы выводим из гаммы что-то.
Это t.
И получается здесь количество выводов, которое у нас идет из гаммы v и g-t.
Это количество позиций равняется t.
Вот, при этом мы с вами понимаем, что изначально у нас коррекция,
параметризация была такая.
Смотрите, и равная g.
Дальше, давайте напишу до.
Здесь у нас было k плюс l.
l в данном случае будет равняться нулю,
потому что из апсилона за ноль шагов мы выводим пустое слово.
То есть нам нужно сравнить конфигурации i и k-0.
То есть нам нужно сравнить конфигурации i и k-0.
И конфигурации i и k-1t.
Какой из них больше?
Левый или правый?
Да, левый.
А это значит, что вот та конфигурация, которая здесь,
она меньше, чем текущая по индукции.
По параметру индукции.
Значит, по предположению индукции мы можем сказать, что у нас из...
Получается, существует ситуация.
B, стрелочка, гамма, точка a дельта.
Так, a дельта.
Господи.
Позиция родительской точки P и...
Дальше у нас есть позиция b...
Есть правило a, стрелочка, бета.
А из этого будет следовать, что по предикту...
Существует ситуация и и.
Ура, мы доказали с вами лему.
Так, давайте вопросы.
Наконец-то мы можем освободить эту часть доски.
Нет, сама лемма нам сейчас понадобится.
Нам нужно доказать теперь факт, что слова выводятся тогда и только тогда,
когда алгоритм заканчивается корректно.
А?
А мы пока доказывали математический смысл.
Вот это всего.
В ходе алгоритма у нас все работает.
Да, на самом деле, доказывается, будет в одну строчку.
Не-не-не-не, ну стоп.
Смотрите.
Смотрите.
Какая-то это факта.
Из a штрих.
Смотрите, за один шаг мы можем вывести s.
Да?
Давайте начнем так.
Что слово лежит в языке, задаваемом грамматикой.
Тогда и только тогда.
А?
Из s можно вывести...
Во-первых, w нулевое, нулевое s.
s.
А дальше мы можем сказать, что за какое-то количество шагов
мы можем вывести слово w нулевое до длины w.
Зачем я так страшно написал это все дело?
Да, смотрите.
Что у нас получается?
В нашем случае i равняется нулю, а g равняется длиной слова.
Тогда мы можем сказать, что это эквалютно тому,
тогда и только тогда, когда у нас существует ситуация
из a штрих стрелочка с. 0 длина слова.
А это верно тогда и только тогда, когда алгоритм выдает true.
Все, теперь мы можем пользоваться алгоритмом.
Ага.
Да.
Я, кстати, из-за этого диплом повсердцу по проге не получил в свое время.
Нет, из-за похожей ситуации.
Что у меня кое-какой w не был на быстром алгоритме.
Который я писал.
Какой-то корнер кейс был, который нужно было фиксить.
Так вот, то есть мы теперь можем сказать, что ура!
Мы доказали с вами корректность алгоритма.
Теперь за оставшееся время нам нужно посчитать B8 точку.
Пятая степень.
Это прям тупая.
Это вообще умная B8 точка.
Значит, смотри.
Давайте оценим.
А симптотика нашего алгоритма,
значит, для того, чтобы ее оценить,
нам нужно понять, собственно, какие у нас базовые блоки есть.
В общем, еще раз эти базовые блоки.
А теперь давайте посчитаем, сколько всего ситуаций у нас может быть.
Вот.
Вот.
Вот.
А теперь давайте посчитаем, сколько всего ситуаций у нас может быть.
Для конкретного G.
Колька.
Смотрите, у нас с вами есть A.
Стрелочка Альфа точка Бета.
И G, которая фиксированная.
Вот это О длины нашего слова.
И это А.
А это А.
И это А.
И это А.
И это А.
И это А.
И это А.
И это А.
И это А.
А это по факту, давайте назовем U большую А G.
Это суммарное число всех правил в правой части.
То есть это назовем, сколько, грубо говоря, у вас всего буквок.
Когда вы выписываете всю грамматику, сколько у вас всего буквок будет.
Да, суммарная длина всех правил.
То есть всего ситуации у нас будет то...
На количество правил грамматики.
Да, для конкретного G.
То есть всего их будет квадрат на количество правил.
Это суммарное.
Давайте я напишу.
Число символов правых числа.
Число символов правых частях правил.
Давайте и левых частях правил.
Образно говоря, вы выписываете на бумаге все ваши правила и считаете сколько буквок написали.
Хорошо. А теперь давайте посчитаем, сколько раз мы делаем каждую операцию.
Помните у нас цикл был, while меняется.
Пока у нас ситуации для G-того элемента накапливаются.
И если грамотно это все реализовать, то оказывается можно получить оптимальную симптомику.
Вот здесь мне надо было объявить множество дешитое, которое является множеством ситуации, у которых правый символ равняется G.
Только здесь он появляется.
То есть у нас мощность каждого множества это количество не терминалов, а количество правил от модуля G на длину слова.
Так, а теперь смотрите, каким образом нам необходимо хранить ситуации.
Мы, кажется, это обсуждали уже с вами, что если у нас с вами есть какое-то правило а стрелочка а, стрелочка альфа, там не знаю,
C, точка бета и G, то поскольку нам надо эффективно обращаться, во-первых, к G, а во-вторых, к C,
то давайте мы будем хранить их в множестве дешитое от символа C.
О, от терминала или нет терминала.
Так, чтобы быстрые ситуации не происходили.
Так, чтобы иметь быстрый поиск к элементу.
Более того, поскольку у грамматика у нас всегда плюс-минус одна, давайте я тут скажу, что в принципе можно сделать так,
что поиск был за 1 через универсальную хэш-функцию либо еще каким-то образом.
Да?
Да.
Фиксит, фиксит.
Да, фиксит.
Ну да, списочек создать, заиндексировать, все.
Да.
Собственно, здесь говорится, что храним правила вида таком, правую часть можно хранить в виде связанного списка
либо как-нибудь там, для того, чтобы можно было быстро получать следующий символ, который идет за C.
Да, это нам тоже понадобится.
Важная вещь, что если у нас символ, в храм КЦ-правил нету точки, добавляем символ end of word,
называем в F$.
Можно, кстати, по-отечественному, по-патриотски, вставить символ рубль.
Не знаю.
Лайфхаки.
Лайфхаки.
Быстрее вычлите ID для каждой ситуации.
Ну, то есть, если вы не хотите, грубо говоря, использовать unorderedMap и unorderedSet, хотя в реализации можно будет их использовать.
Для того, чтобы алгоритм был нормальным.
Нормальный был код.
Читабельный.
Ну, типа, быстро надо, надо уметь.
Грубо говоря, за O от 1 доставать джиты от ней терминала.
Ну, да.
Вот.
Ну, там меньше.
То есть, смотрите, если хотите быстрее, то, собственно, вычлите ID.
Если вам нужно меньше памяти, то можно через F$ делать реализацию, и оно будет работать.
Так.
Давайте со сканом, просто.
Так, давайте со сканом разберемся.
Собственно, что здесь нам надо сделать для скана?
Вот чтобы вот такую вещь получить.
Один переход.
Нам нужно по факту проэтерироваться for loop'ом, for циклом, по джитая от а.
Понятно это?
Давайте напишу.
Can for situation in the jitter от the jitter.
Скан будет выглядеть вот так.
Ну.
Ну.
Ну, да.
Ну, да, поэтому джита, то есть, вот это тоже, это у нас будет список, на самом деле.
Да, то есть, это джита от вжита, это будет список.
То есть, джита от чего-то, это будет список.
Да, то есть, джита от вжита, это будет список.
То есть, джита от чего-то, это будет список элементов, список ситуаций, у которых справа после точки стоит этот символ.
Да, конечно же.
Конечно же, пробегаем всегда по актуальному джиту.
А?
Вот, смотрите, а симптотика будет в итоге для скана, для конкретной буквы, просто мощность этого множества.
Логично.
А мощность этого множества ограничена сверху мощности самого джитого.
Хорошо.
Предикт.
Что нам нужно сделать в предикте?
Придикт.
Придикт.
Придикт.
Придикт.
Придикт.
Придикт.
Придикт.
Придикт.
Придикт.
Придикт.
Придикт.
Придикт.
Придикт.
Да.
Да, нам нужно пробежаться по всем SEA терминалам и пробежаться по всем правилам,
а?
Нет, там нужно еще аккуратно. Вот как раз то, что вы сказали, что не надо повторяться по всеми терминалам.
Вот, тут важно помечаем, была рассмотрена уже текущая ситуация.
Эпсилон. Ну типа они все эпсилон порождающие.
Да, ну квадрат именно не от длины слова.
А, количество правил в грамматике в квадрате.
Да, то есть здесь модуль от g в квадрате будет.
Да, тут всякие приколы с амортиционной сложности возникают.
Да, ну скорее всего на длина будет.
Там по факту, смотрите, что нам нужно. Перебирать правила b-strelochka.gamma, это количество правил в нашей грамматике.
Дальше рассматривать правила djt на b, и добавляем это правило в djt.
При этом, смотрите, мы можем в принципе сказать следующее, что каждая новая ситуация, которую мы добавляем, она добавляет один элемент djt.
Поэтому количество добавленных правил при помощи предикта в квадрате в квадрате в квадрате в квадрате в квадрате в квадрате в квадрате в квадрате.
Поэтому количество добавленных правил при помощи предикта.
А? Вопрос как?
Ну да, там квадрат.
А, именно одна ситуация.
Да, смотрите, здесь идет амортизационная оценка.
Амортизационная оценка.
Ну да, либо амортизационная оценка.
Смотрите, идея такая, что каждый раз, когда мы добавляем одну ситуацию, то есть когда у нас срабатывает предикт, у нас добавляется одна ситуация в djt.
Соответственно, количество добавленных правил по предикту суммарно, у нас, напоминай, в алтру там стоит, будет равняться o от модуль gt.
Каждый перебор такой занимает нам o от количества правил гамматики.
Получаем o от модуль g на g квадрате.
Так, с этой симпточкой понятно?
Сейчас самое сложное.
Самое толстое, самое сложное, на самом деле, с точки зрения оценки.
Здесь важно сразу сказать, что когда мы делаем форд цикл по вот этому комплиту, важно не повторяться два раза.
То есть не выводить одно и то же правило дважды.
Одну и ту же ситуацию.
Поэтому, несмотря на то, что кажется, что здесь можно написать фор по вот этому, фор по верхней части и фор по нижней части,
если вы так напишете, вы получите четвертую степень сразу.
Можно получить.
Смотрите, здесь нужно оценить, когда у нас меняется верхняя часть, а когда у нас меняется нижняя часть.
То есть когда у нас добавляется вот это правило.
А это правило может появиться по следующим причинам.
Либо у нас нижнее правило новое, либо у нас верхнее правило новое.
То есть оно добавилось на текущей итерации цикла.
Вот, поэтому нужно отслеживать аккуратно пары операций, по которым мы можем сделать.
Значит, когда это у нас меняется?
С отслеживанием второго не очень все сложно.
Да, просто у нас добавляется новое правило в джитое, оно сразу попадает в кандидаты вот сюда.
Ну да, да, да, транзитивное.
Ну вот, тут надо аккуратно оценить, чтобы оно было за квадрат.
Понять откуда оно за квадрат получается.
Здесь важное, посмотрите на правила.
Которая у нас в b-стрелочку точка гамма.
Вот, и на самом деле смотрите, тонкий момент.
Первое правило здесь тоже может поменяться.
То есть оно тоже может оказаться новым, если здесь k равняется g.
Вот, то есть такой тест можно привести, пример.
Смотрите, почему здесь куба не получается?
Потому что здесь транзитивное замыкание интересное.
Правила джит, вот эти вот берутся из джитова доллар.
Да?
А сколько вот таких вот правил сверху?
Как их можно оценить?
Смотрите, у нас есть правило b-стрелочка гамма точка k, g.
Ну, этих кажется джитое всего.
Сверху оценка.
А дальше, здесь нам нужно правило, откуда брать?
Здесь нам нужно брать правило из дкт от b.
Логично?
Вот, сколько таких правил у нас есть?
Логично?
Вот, сколько таких запросов у нас будет в сумме по всему алгоритму?
Да.
То есть это сумма по всем джитам раз и сумма по всем дктам.
Точнее, смотрите, вот это у нас фиксированное.
Джитая доллар мы можем считать фиксирована мощность этого множества.
От доллара.
А здесь будет следующее.
На о большое от суммы мощности дкт пока от 0 джи.
Вот это асимптотика.
От 0 до джи.
Вот.
Ну, собственно, теперь нужно оценить.
Это все дело.
И получается, что мощность суммы от 0 до джи, джитых, это о большое от длины словах квадрата на количество правил грамматики.
Вот.
А вот это как сверху оценить?
Ну, потому что каждый из них от длины слов...
Ну да, даже к умножить на количество правил грамматики.
Вот.
В основном утверждение, что это дает нам асимптотику.
Вот такое.
Смотрите.
Количество правил грамматики такие.
То есть, смотрите, что нужно тут сделать?
Важно, что...
Вот почему здесь не получается четвертая степень?
Потому что по факту...
Ну да.
Ну, нет, тут почему асимптотика этого шага не четвертая степень?
Потому что по джи мы, на самом деле, вычисляем k, имея наши правила грамматики.
То есть, я здесь просто взял и умножил на о большое джи, это все дело.
Но что здесь идет именно перебор по правилам грамматики, по факту.
То есть, суммарное количество комбинаций, вот такие, сверху и снизу, оно будет о большое от модуль v в квадрате на модуль g в квадрате.
Так.
Вот это осознание есть?
Один шаг работает, а тут все равно эти...
Да.
Компли...
Суммарное количество комплей для фиксированного джи будет равняться о большое от модуль v в квадрате на модуль g в квадрате.
Да.
Видите, что у вас так-то написано?
А у меня нет.
Чего?
А у меня нет.
А у меня нет.
А у меня нет.
А у меня нет.
Чего?
А!
Стоп.
Да, согласен.
Да.
Кубическую я хочу получить.
Ну вот, просто я объясняю, откуда она получается.
Нет, квадраты не хочу получить.
Да, мы хотим доказать, что это все-таки клубическая, не четвертая, не пятая степень.
Ну вот...
А почему-то все пишут алгоритмы за четвертую, за пятую степень.
А?
Ну вот.
Да.
Ну да.
Вот с этим обычно проблемы возникают, с тем, как оно пишется.
Теоретически это понятно.
Теоретически-то да, а практически вот нет.
Вот, смотрите, у нас всего...
Значит, здесь квадрат.
В скане у нас линия, в предикте тоже линия.
Это на каждой житы.
В итоге какая симптотика у нас с вами?
Да, собственно, модуль G на...
То есть, симптотика у нас...
Так.
Теперь задача со звездочкой.
Однозначно, грамматика это та, у которой любое слово разбирается единственным образом.
Однозначная грамматика это та, у которой любое слово разбирается единственным образом.
Упражнения со звездочкой.
Операция complete для однозначных грамматик будет занимать вот такую симпточку.
Ну, плюс-минус оно...
Там нет, там оценка сверху будет, там чуть-чуть сложнее.
Ну, да.
Ну, к неоднозначно становится G.
Ну, понятно, что типа фиксированное значение.
Ну, да, но там надо только чуть формально доказывать, а так идея верная.
То есть, видите, оказывается, что для большого числа грамматик эта симптотика превращается в квадратичную.
И в среднем она будет болтаться между квадратичной и кубичной по количеству операции.
Все это зависит от числа неоднозначности в нашей грамматике.
Вот, и тем более неоднозначно разбирается наше слово.
То есть, в среднем получается симптотика от квадрата до куба.
От длины слова.
То есть, в алгоритме Коконьянгеракасами у нас точно куб, а вот здесь у нас получается от квадрата до куба.
Вот, значит, смотрите, здесь уже получается такая вещь, что это плюс-минус один из оптимальных алгоритмов.
То есть, для произвольной грамматики мы не сможем с вами что построить что-то более выгодное.
Вот, но если мы сузим множество классов грамматик, которые мы рассматриваем, то можно достичь линейного алгоритма, а длины слова.
Вот, и к этому мы еще вернемся, но не через лекцию, не даже, наверное, скорее всего даже через две лекции мы к этому вернемся.
Вот, значит, в итоге мы доказали, что у нас алгоритм вот такой.
Вот, и в следующей лекции мы рассмотрим такую абтракцию, как МП-автоматы, автоматы с магазинной памятью.
И заодно выведем автомат, который позволяет проверить принадлежность слова грамматики.
Вот, и там уже как раз будет некоторая мотивация, связанная с тем, а как построить парсер за линейное время для некоторого подножства грамматика.
