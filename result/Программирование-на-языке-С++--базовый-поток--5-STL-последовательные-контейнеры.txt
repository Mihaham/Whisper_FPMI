Сегодня мы с вами начнем рассматривать темы, связанные с работой стандартной библиотеки C++.
На самом деле это не совсем правда, потому что у нас лекционные занятия и практические занятия будут в целом по направленности немного отличаться.
Но в целом глобальный план состоит в том, чтобы погрузиться чуть глубже в устройство стандартной библиотеки, понять как она работает, понять за счет чего она работает, почему она стандартная, почему она реализована на шаблонах, как она достигает того, что работает с практически любыми данными и так далее.
Сегодня поговорим, и на самом деле в следующий раз тоже поговорим про контейнеры.
Давайте для начала начнем с того, что определим, что такое контейнер.
Контейнер – это такой тип данных, который обеспечивает хранение объектов других типов, а также интерфейс для доступа к ним.
На самом деле все довольно просто.
Контейнер – это просто в обыденном понимании, есть некоторое хранилище, туда вы можете что-то положить, вы оттуда можете что-то достать, вы можете узнать, есть ли в этом контейнере то, что вам нужно и так далее.
Контейнер – это некая интерфейс, которая позволяет вам каким-то образом управлять набором данных.
Что такое последовательный контейнер?
Последовательный контейнер – это контейнер, который обеспечивает, грубо говоря, некоторую четкую последовательность хранения элементов.
То есть, грубо говоря, вы всегда можете конкретный элемент, конкретный объект положить в нужное место вашей структуры данных.
Грубо говоря, вы хотите, чтобы ваш элемент находился на самом вершине, на самом первой позиции вашей структуры данных, вы это можете сделать.
Вы можете положить элемент в конец вашей структуры данных, можете положить элемент в середину структуры данных.
То есть, в каждый момент времени вы всегда знаете, где, в каком конкретном месте находится ваш объект.
Это зависит от последовательного добавления элементов, это зависит от того, в какой момент был добавлен элемент, ну так и иначе вы сами можете контролировать то, где какой элемент находится.
Окей, то есть у вас все данные расположены строгой какой-то последовательности, вы точно знаете, что на второй позиции, допустим, находиться элемент х, на десятой позиции находится элемент у.
И так далее, и более того, вы эту последовательность элементов можете контролировать, вы ее можете создавать самостоятельно.
Вот в этом состоит суть последовательных контейнеров. Понятно?
Вот. Ну проблема или просто представление в том, что на самом деле все контейнеры c++, как мы с вами впоследствии увидим, являются последовательными.
Я natürlich не всегда interconnect훈ag, ну, потому что структура данных может как-то особину образом
менять ваши элементы так, чтобы ей было удобно.
Классический пример из алгоритмов, которые вы уже изучали,
это, наверное, куча пирамид или то же самое
динамическое дерево поиска. То есть я не могу просто так
взять и вставить элементы в произвольное место.
Потому что из-за этого нарушится структура моих данных.
Например, в дереве поиска мы точно знаем, что все элементы,
все элементы, которые меньше x находятся слева,
все элементы, которые больше x находятся справа,
в куче тоже есть свои иерархии. В общем, в этих структурах данных
мы не можем положить элемент в то место, которое мы хотим.
В последующих контейнерах мы так делать можем.
Дальше, с вашего позволения, я пропущу несколько слайдов,
просто сделаю такую обзорную экскурсию по контейнерам,
потому что, наверное, все-таки имеет больше смысл
рассматривать контейнеры на практике, знакомиться с их методами,
их устройством и так далее уже вживую, решая практические сдачи
или обсуждая на семинарах. Я остановлюсь на моментах,
которые будут нам интересны в плане, скажем так, теоретического
рассмотрения C++. Ну, в общем, все вы, наверное, знакомы уже
с таким классом, как RA, то есть все его, я надеюсь, реализовывали
в первом семестре. В общем, RA – это просто аналог
обычного стишного массива, который представляет
некоторый набор методов и некоторый более удобный
интерфейс для работы с стишными массивами. То есть, их можно
копировать в отличие от стишных массивов, можно передавать
по значению, можно передавать по ссылкам. В общем, они стильные
модные молодежные, их стоит использовать вместо обычных
стишных массивов. Следующий контейнер, с которым, ну, так
или иначе, мы с вами вроде как не знакомились ни на
практике, ни на лекции, это контейнер-вектор. Вот если
STD RA – это был контейнер, который являлся аналогом
обычного стишного массива, то есть обычный массив, я
имею в виду, который мы создаем просто задавая размер.
RA 10. То есть, это массивы, фиксированные длины, в которых
вот тут стоят константы времени компиляции. STD
Vector – это, по сути, аналог динамического массива,
который мы выделяем с помощью NU. То есть, если нам вдруг
размер массива не известен на этапе компиляции, если
он, допустим, вводится с клавиатуры, или если размер
массива превышает допустимый размер стэковой памяти,
то, напоминаю, в этих ситуациях мы используем динамическую
память, и, собственно, Vector является полным его аналогом.
Ну, причем со всеми приколюхами, которые вносит ООП в нашу
жизнь. Это с деструктором, с конструктором компирования,
и так далее, и так далее. Ну, собственно, как я уже
сказал, с методами поближе познакомитесь на практических
занятиях. Что тут больше всего интересного? Ну да,
собственно, Vector в отличие от Array позволяет изменять
данные, то есть, он позволяет добавлять элементы, позволяет
удалять элементы. То есть, имеет методы pushback, popback,
insert, erase в произвольное место массива. То есть, если Array
– это массив с фиксированным размером, то Vector – это массив,
который не имеет какой-то определенный фиксированный
размер. Про устройство можем поговорить сейчас. В общем,
как устроен Vector? Как Vector добивается того, что он позволяет
довольно быстро добавлять элементы в конец, удалять элементы
из конца? В общем, как он устроен в общих чертах? В общем,
Vector на самом деле довольно хитрый тип, потому что,
вот, смотрите, когда мы с вами выделяем память с помощью
new int n, то при этом происходит следующее. У вас выделяется
память для хранения n элементов, и при этом вам гарантируется,
что вы можете использовать только эти n ячеек, которые вы
видели. Ну и при этом, соответственно, все эти n ячеек, они
создаются, то есть, они реально хранятся в памяти, то есть,
тут реально создаются какие-то объекты. Ну, допустим, есть тут
new int, какой-то тип, а вам гарантируется, что для каждого
элемента будет вызван свой конструктор по умолчанию.
Вот. Vector устроен несколько хитрее, потому что он учитывает
то, что, в принципе, в теории он может в дальнейшем расширяться.
То есть, на самом деле Vector устроен следующим образом.
Значит, у него есть три принципиальные характеристики.
Значит, первая характеристика, это, ну, собственно, понятное,
делает указатель на сами данные. То есть, вот здесь у нас
какой-то указатель P, то аналогом вот этого указателя P будет указатель
на динамические данные, которые выделил Vector.
А дальше уже начинаются хитрости, связанные вот с чем.
Дело в том, что Vector на самом деле хранит памяти, ну,
несколько больше, чем вам на самом деле нужно. Вот.
Вот эта характеристика памяти, которую он на самом деле хранит,
называется Capacity или вместимость.
Вот. Это то, сколько элементов может вместить в тебя Vector
без дальнейшего переведения памяти.
То есть, мы с вами понимаем, что если вдруг у меня есть
массив n элементов, и мне нужно добавить в этот массив еще один элемент,
мне придется выделить новый кусок памяти большего размера,
копировать старые данные в новый массив и, соответственно,
добавить же элемент в освободившуюся ячейку.
Вот. Vector поступает хитрее, Vector, в общем, ну, понятно дело,
он не хочет постоянно делать переведения для каждого добавления,
поэтому он хранит памяти чуть больше, чем ему нужно.
Вот. И вот эта характеристика, сколько элементов он может вместить
в себя без переведения памяти, называется Capacity.
Вот. Вторая характеристика, это Size.
Вот. В контексте данного примера, Size в этом случае равен n.
Да, то есть, тут мы выделили память для n объектов,
и тут реально хранится n объектов, вот.
И, если в моем массиве, ну, то есть в моем векторе,
хранится n элементов, то вот это…
за вот это значение, сколько реального элементов
хранится в моем векторе, значит, эта характеристика хранится
в поле Size, да? нуили ее можно получить с помощью вызова
соответствующего метода size.
Вот. Ок. Да.
Значит, ну соответственно, есть несколько методов,
которые позволяют контролировать вот эти две характеристики,
Вместимость массива и его размер. Одна характеристика, один метод называется
резерв. Ну там какое-то количество элементов. Вторая характеристика называется resize.
Resize вот n. Что делает резерв? Резерв никак и не изменяет размер, то есть резерв никак на самом
деле не изменяет количество хранимых элементов. Все, что делает резерв, это увеличивает capacity до
тех пор, пока он не будет удовлетворять условия, что capacity больше либо меньше, чем n. То есть
резерв от n говорит следующее. Зарезерируй память для хранения n элементов. Ну как минимум n элементов,
на самом деле может быть чуть больше. А resize говорит следующее. Выстави size значение n. Почему
это приводит? Если у вас resize уменьшает размер, то вот эти элементы будут уничтожены. То есть у вас
размер массива уменьшится, и эти элементы, которые тут находились, они будут уничтожены. Если
resize наоборот увеличивает размер, размер вектора, то вот эти вот элементы будут достроены соответствующими
значениями. Либо значениями по умолчанию, либо значениями, которые вы указали через запятую.
Окей? То есть как у нас есть две характеристики, одна capacity, которая отвечает только за само хранилище,
то есть, грубо говоря, вот у вас есть полка, и на полке есть свободные места. То есть полки
не заняты, но теоретически их можно будет потом дополнить. И size, сколько реально вещей у вас
хранится на этих самых полках. Ну и соответственно с помощью функции reserve вы можете либо увеличить
вместимость, докупить новый шкаф, доделать новые полки и так далее. А с помощью resize вы
можете либо убрать какие-то вещи с полки, либо добавить какие-то вещи, которые реально хранятся
в векторе. Окей? Пока это пропустим, в общем, что хотелось бы, на чем бы хотелось сегодня заострить
внимание. Сегодня хотелось бы поговорить про следующие интересные методы вектора и поставить
некоторую проблему, которую, к сожалению, на нашем уровне развития мы пока решить не можем,
но, надеюсь, к концу сегодняшней лекции научимся это делать. Смотрите, в чем проблема. Значит,
как я уже сказал, у вектора есть такой замечательный метод как pushback. Что делает метод pushback?
Pushback просто берет и добавляет элемент в конец вектора. Но, опять же, если вектору памяти хватает,
если capacity больше, чем size, то он просто добавляет новый элемент концу size. Если же вместимости
не хватает, то вектор переводеляет память. Естественно, все это скрыто от ваших глаз,
то есть он внутри себя переводеляет память, копирует старые элементы, добавляет элемент.
Смотрите, в чем тут может быть проблема. Проблема может быть следующим. Давайте посмотрим,
например, представь себе, что у меня есть вектор векторов. Такой, естественно, может быть. У меня
может быть динамический массив, который внутри себя хранит динамические массивы. Нормально.
Вот, вектор векторов. Что я делаю? Допустим, в какой-то момент я в этот вектор векторов vw хочу
добавить очередной вектор. Как я это делаю? Я говорю vw.pushback std vector int, допустим, 10.1.
Добавляю мой вектор, еще один вектор размера 10. Либо с помощью метода insert в начало вектора
добавляю, в начало вектора тоже добавляю какой-то другой вектор. Что тут проблема? Давайте посмотрим
вот на этот код и попробуем пошагать. И попробуем по шагам понять, что он делает. Вот я написал,
vw.pushback std vector int, 10.1. Ну, что такое вектор 10.1? Это вектор размера 10, который хранит,
короче, это вектор, который хранит 10 единиц. То есть, конструктор вектора, который принимает
два параметра, он принимает первым параметром размер, а вторым параметром, чем эти элементы
нужно заполнить. То есть, тут я создал вектор из 10 единиц и запихал его в конец вектора vw. Давайте
посмотрим, что при этом происходит. При этом происходят следующие вещи. Первое. Создается
временный вектор, согласны? То есть, pushback это функция, функция передает какой-то временный
объект. Этот временный объект должен создаться, согласна? Создание. Создание вектор 10.1. Второй
пункт. Что происходит дальше? Ну, а дальше этот вектор передается функцию pushback. Да, pushback
его принимает и что делает? Ну, заполняет. Заполняем ячейку vw этим вектором. Вопрос. Как
вы думаете, что будет вызовано на втором шаге? Как будет создана эта самая ячейка? С помощью чего?
Смотри, когда создается объект, что происходит? Что происходит при создании любого объекта?
Что? Нет, при создании объекта аллокация не всегда происходит. Что? Вызывается конструктор.
Чтобы создать произвольный объект, в частности, вектор должен быть вызван конструктор, согласны?
То есть, заполнение ячейки неизбежно приведет к тому, что тут вызовется конструктор.
То есть, заполнение ячейки на самом деле вызовет конструктора. Вопрос. Какой конструктор будет
вызван? Вот я передал в pushback временный объект и, соответственно, с помощью этого временного объекта
мне нужно заполнить ячейку. Какой конструктор в этом случае будет вызван? Перемещение, да. То есть,
если мы создаем объект, скажем так, с помощью временного значения, то, соответственно, в этом
случае у нас вызывается конструктор перемещения. Перемещение я. То есть, происходят две вещи.
Смотрите, тут уже возникает проблема. В чем? Мы создаем временный вектор, а потом этот временный
вектор перемещаем внутри другого вектора. Возникает некоторая проблема с тем, а зачем мы делаем два
действия? Смотрите, мы создаем вектор, а потом... То есть, мы создали вектор только для того, чтобы
его взять и переместить в нужное место. Согласитесь, это довольно странно с обычной точкой зрения.
Опять же, давайте вернемся к примеру со шкафом. Вот представьте, вот вы взяли какую-то вещь, сначала
ее положили в какое-то временное хранилище, а потом из этого хранилища взяли и переместили
внутрь вашего шкафа. Ну нет же. То есть, если нам нужно, чтобы что-то появилось внутри шкафа,
мы просто берем эту вещь и кладем сразу туда. То есть, вообще говоря, хотелось бы, чтобы этот вектор
просто-напросто за один шаг взял и создался внутри нужной ячейки. Согласны? Вот. На самом деле,
тут еще более... с этим pushback есть еще одна более страшная проблема, которая заключается в следующем.
Теперь давайте представим, что вектор хранит не вектора, а вектор хранит какой-то тип A,
у которого нет конструктора перемещения. Допустим, A10.1.
Вот просто вот я для своего класса A сказал, что этот мой класс перемещать нельзя. То есть,
конструктор от A10.1 равно delete. Вопрос. Что тогда будет происходить на втором этапе? Да,
смотрите, если объект нельзя переместить, тогда он будет копирован. А копирование, в общем случае,
мы с вами понимаем, оно работает долго. То есть, смотрите, что-то произошло. Я создал временный
объект, а потом взял этот объект и трачу время на клонирование этого объекта, чтобы потом создать
его внутри вектора. То есть, если брать аналогию со шкафа, вы берете вещь, вы хотите, о, я хочу,
чтобы эта вещь оказалась у меня в шкафу. А давайте я куплю еще одну вещь, пусть одна вещь лежит у меня
в руках, а вторая вещь окажется в шкафу. Но это, естественно, работает не так. Еще более страшная
проблема. Теперь давайте я запрещу копирование. Вот. У меня есть тип A, у которого нет ни конструктора
копирования, ни конструктора перемещения. Вот. То есть, объекты типа A нельзя ни копировать,
ни перемещать. Вот. Их можно только создавать. То есть, я могу создать просто переменные этого типа. Вот.
Но при этом копировать и перемещать друг друга нельзя. К чему это приведет? Да, в принципе,
тогда pushback к этому вектору применим не будет. То есть, если вектор хранит элементы, которые нельзя
копировать и перемещать, тогда окажется, что их просто-напросто их нельзя будет хранить в моем
контейнере. Но это же какая-то ерунда. Почему? Потому что кажется, что если мне нужно взять
какую-то вещь и просто-напросто положить ее в шкаф, я как бы хочу уметь это делать. То есть,
какая разница? Вектор, какая тебе разница? Умею я копировать элементы? Не умею копировать
элементы. В общем, кажется, что это нужно суметь сделать. Ну, опять же, при условии, что у нас не
происходит никаких переведений, перелокации памяти. На самом деле, возможно, это, в принципе,
как-то не сработает. Ну ладно. В общем, проблема ясна. То есть, так или иначе, у меня есть лишнее
копирование либо лишнее перемещение. То есть, у меня есть явное требование на то, чтобы, в общем,
я мог вот эти вот временные объекты либо копировать, либо перемещать. Согласны? Вот. И в любом
случае есть некий лишний шаг в виде создания объекта, а потом его дальнейшего копирования
перемещения. Вот. Соответственно, для решения этой проблемы в векторе есть отдельный метод,
который называется emplace. На самом деле, он появился в C++11, но в целом мы уже не делаем разниц
обычного C++11. В общем, у вектора есть метод emplaceback, который устроит хитрым образом. Что он
делает? Значит, смотрите, pushback принимает объект, который нужно вставить в мой вектор.
Emplaceback принимает параметры конструктора, которыми нужно создать объект в нужном месте в памяти.
Вот. Сравните вот эту запись и вот эту запись. Что я сделал тут? Тут мне пришлось создать объект
для дальнейшего перемещения или копирования в вектор. Здесь же я просто обскал, вектор,
возьми вот эти параметры, а потом в нужную ячейку просто создай нужный элемент с этими
параметрами. У вектора в треугольной скобке я указываю тип. То есть у меня каждый контейнер
хранит элементы определенного типа. Вот. Поэтому если у меня вектор, допустим, хранит элементы типа A,
STD, вектор от A, vw. Вот. То когда я делаю vw emplaceback и передаю ему параметры, он просто-напросто
берет ячейку нужную и с этими параметрами 10.1 создает нужный элемент. Окей? Emplace в переводе
это просто разместить. Вот. То есть как бы возьми эти параметры и размести объект сразу в нужном месте.
То есть тут я избавляюсь просто. То есть тут, если у меня тут было создание объекта и потом копирование
или перемещение, то тут у меня просто-напросто выполняется один шаг. Да. Создание, ну я так напишу,
A10.1. Ну вот тут. В нужные ячейки памяти сразу. Все. Одно действие. Все. Я сделал, что хотел. Создал
именно в той ячейке, то есть именно в конце вектора нужный мне элемент. Понятно? Вот. Значит, это было
предисловие на самом деле. Значит, о чем бы я на самом деле хотел поговорить. Давайте посмотрим на EmplaceBack.
Вот. Попрос, который я бы хотел рассмотреть, он следующий. Вот смотрите. С pushback на самом деле более-менее
все понятно. Ну, то есть у вас есть задание, в первом задании у вас есть задание string, то есть
реализовать свою строку, и в принципе там тоже есть метод pushback, и с ним все понятно. То есть pushback
принимает один объект, и этот объект мне нужно сделать так, чтобы этот объект оказался в конце
моего контейнера. Все довольно просто и понятно. Теперь. Давайте я вам скажу следующее. Давайте с вами
реализуем метод EmplaceBack. Да, то есть ну с pushback все понятно, но не интересно, там если памяти хватает,
то просто-напросто заполняем последнюю ячейку, если памяти не хватает, то переведем память,
и так далее, и так далее. Все. Это уже скучно. Идем сюда. Давайте реализуем EmplaceBack. Никто не
против. Давайте попробуем написать. Вот, допустим, я написал вектор, а вектор у меня имеет шаблонный
параметр, шаблонный параметр t, и я начинаю писать. Ну, пусть EmplaceBack возвращает void, пишу EmplaceBack,
и что? Что принимает EmplaceBack? Да, смотри, то есть я на самом деле утверждаю, что мы вообще не
знаем, что тут будет передано. Почему? Потому что t это произвольный тип, абсолютно произвольный
тип. Вот. Знаю ли я, как создается абсолютно произвольный тип? Нет. У типа может быть,
ну, во-первых, существует большое количество конструкторов. То есть есть конструктор копирования,
есть конструктор перемещения, есть конструктор одного аргумента, двух аргументов, трех аргументов,
и так далее. То есть, с какими параметрами будет вызываться EmplaceBack, я не знаю. Вот. Более того,
я не знаю, какие в принципе конструкты у меня существуют для типа t. Да? То есть, смотрите,
еще раз, идея. С pushBack все понятно. Почему pushBack простой и тупой? Потому что pushBack принимает
конкретный объект. Вот, конкретный объект типа t. То есть, если у меня шаблонный параметр t,
он принимает конкретный объект типа t. EmplaceBack вообще не знает, что ему передадут. Даже если предположить,
что тип t известен заранее. Не знаю, у вас тип не тоже шаблон, а вот вам прям заранее известен тип.
Все равно, для конкретного типа t может существовать огромное количество конструкторов. Да? И какой
конкретный конструктор будет вызван для EmplaceBack, непонятно. Что делать? Как написать функцию,
которая может принимать все что угодно. То есть, не то, что все что угодно, а все что угодно,
причем в произвольном количестве. Вот на этот вопрос мы сегодня постараемся ответить. Все,
предусловие закончено, давайте переходить к теме. Тема шаблоны с переменом числом аргументов.
Ну, собственно, начну опять же с... Еще раз повторю, проблема. Вот, допустим, у нас возникло желание
написать что-то наподобие EmplaceBack. То есть, чего-то, что может принимать непонятное количество
параметров. То есть, количество параметров может быть равно как 2, как так, 3, там, 4, 5 и так далее.
Ну, собственно, тут предоставили еще какие-то примеры. Например, функция printf. То есть,
функция из библиотеки C. Но в целом эта функция, она утверждает, что она может принимать произвольное
количество аргументов. То есть, первым аргументом передаем ей формат строку, а остальные аргументы
передаем. Ну, собственно, дальше мы передаем аргументы, которые соответствуют этой формат строке.
При этом формат строка может содержать какое угодно количество специальных символов. Ну,
соответственно, printf должен уметь принимать в себя произвольное количество параметров. Второй
пример, с которого вы, возможно, тоже знакомы, это функция makeUnique. Вот makeUnique, она, по сути,
устроена примерно так же, как EmplaceBack. То есть, как устроен makeUnique? makeUnique это шаблонная
функция, которая в качестве своего шаблонного параметра принимает тип умного указателя,
который нужно создать. Ну, в данном случае makeUnique от A это умный указатель UniquePTR,
который указывает на объект типа A. Вот. Ну, и в своих параметрах принимает аргументы конструктора,
с которыми нужно создать этот элемент. Ну, то есть, makeUnique от A, допустим, 1, 2, по сути, аналогия
с привычным нам newA от 1, 2. То есть, с makeUnique точно такая же проблема. makeUnique принимает просто
параметры конструктора, но при этом, естественно, заранее мы не знаем, а сколько этих параметров
будет, какие это параметры, какой тип они имеют, и так далее, и так далее. Вот. Собственно, давайте
посмотрим, что можно предложить в качестве решений в этих ситуациях. Ну, этот слайд, на самом
деле, просто чисто для такой исторической справки. В общем, как с этим всем справлялись в языке C,
то есть, как были устроены функции в языке C. Значит, в языке C существовался специальный аргумент,
многоточие, ну, или эллипсис, который указывался в конце параметров функции. Ну, в общем, если мне
нужно было написать функцию, которая печатает int, то я мог, например, сделать так. Передать ей
на вход, ну, собственно, поток, в который нужно вывести эти самые int, дальше, например, указать
количество int, в который нужно вывести, ну, и дальше указать аргумент многоточия. Ну, собственно,
в этом аргументе многоточия у меня бы, по сути, это аргумент многоточия означал принять произвольное
количество параметров, да, сколько угодно. Вот. Дальше нужно было, в общем, совершить некоторые, там,
приседания, некоторую магию. Например, нужно было создать специальный аргумент violist, который,
собственно, ну, это специальный такой тип, который умеет работать с этим самым произвольным количеством,
произвольным количеством параметров. Дальше нужно было вызвать macros va start, в котором нужно
было передать вот этот самый объект violist и передать параметр, который предшествует этому
самому многоточию. Вот. Ну, и дальше использовать, ну, и дальше для получения этих самых аргументов
нужно было использовать macros va arc, ну, собственно, с параметром вот этого, вот это самое violist,
и дальше тип, тип аргумента, который я хочу получить. Вот. Ну, то есть, тут в целом, как бы,
тут все для примера, в общем, в языке C все работало примерно, примерно вот так. Вот. В чем тут
проблема? Проблема заключается в том, что, ну, давайте, кто-нибудь понимает, в чем проблема вот этого кода?
Почему этот код небезопасен? Да. Да, во-первых, непонятно количество параметров. То есть, тут мы,
как бы, верим, надо посмотреть, у меня есть параметр int n, который вроде как отвечает за количество
параметров, которые я передал. И вообще говоря, мы тут просто-напросто верим, что пользователь не
ошибется. Мы верим, что пользователь передаст нам нужное количество параметров n. Вот. То есть,
это проблема. То есть, тут мы не можем узнать, сколько параметров нам реально было передано.
Еще проблемы. Да. Да, вот, смотрите, у меня есть специальная функция va arc, которая, это не функция,
простите, это macros, вот, которая принимает второй параметр, и вторым параметром я должен явно
указать, какой тип я принимаю, да, какой тип я ожидаю. Вот. То есть, если мне вдруг пользователь
передал неожиданно, то есть, не тот тип, который я там указал, вот, или вдруг указал, то случайность
не тот тип, то, соответственно, получаю неопределенное поведение. Вот. Ну и вообще говоря,
этот код довольно многословен, да, то есть, необходимо там завести va list, va start, не забыть
про va end. Да, кстати, я сказал, что после va start нужно обязательно сделать va end. Вот. Ну и,
собственно, получать все аргументы с помощью va arc. В общем, это не безопасно, это неудобно,
и вообще c style. Вот. Значит, что у нас есть в языке C++? А точнее, в языке C++, начиная с 11
стандарта. C++ предоставляет шаблоны с переменным числом аргументов. Давайте разбираться с интоксисом.
Значит, если в C++ хочется написать функцию, которая может принимать произвольное количество
аргументов, мы пишем шаблон с переменным числом аргументов. Значит, как они выглядят? Значит,
если нам нужен, если мы хотим передать функцию произвольное количество аргументов, причем непонятно
какого типа, мы пишем следующий синтаксис. Class многоточий, ну и даже каким-то образом называем
вот эти самые аргументы. Arcs. Что означает эта запись? Эта запись означает, что шаблонный
параметр arcs будет являться так называемым пакетом параметров. Пакет параметров. То есть,
вот в этом аргументе, вот в этом аргументе будет храниться список типов, которые я передал
функцию. Вот. Дальше. Я пишу функцию print и указываю следующее. Например, указываю arcs многоточия
arcs. Что означает эта запись? Эта запись означает следующее, что моя функция может принимать
произвольное количество параметров типов. То есть, раньше я шаблонный параметр указывал явно,
класс T, класс U, класс V и так далее. Тут я говорю, что этих шаблонных параметров может быть сколько
угодно. На самом деле хоть 0, хоть 1, хоть 2 и так далее. Вот это многоточие принимает, давайте так
напишу. От нуля до примерно бесконечности, с вами там есть естественно какое-то ограничение. Я не
помню сколько, вам хватит. Вот. Шаблонная функция принимает произвольное количество шаблонных
параметров. Вот. Ну и, собственно, эти параметры передаются в функцию вот таким образом. Вот. Вот
это шаблонный, вот это пакет параметров типов, а вот эта вот переменная, которую я создаю arcs,
тоже является пакетом параметров, но пакетом параметров этих самых, ну значений передных
функций. Вот. То есть, пока можно считать, ну пока можно, в общем, про это думать так, что вот это,
это просто некоторая сущность языка C++, которая хранит внутри себя в виде списка
типы, которые переданы в эту функцию. Вот это, это некоторая сущность языка C++,
которая внутри себя хранит список аргументов, которые в эту функцию переданы. Окей? Да.
После void print. Просто название функции. Вот. Вот эта функция print, давайте перейдем примеры.
Вот эта функция print может работать вот так. Тогда arcs, это будет пустой список, ну и arcs с
маленькой буквой тоже будет пустой список. Print может принимать, например, 1 и true. Вот.
Тогда arcs, это будет список из int и bool, а arcs с маленькой буквой, это будет 1 и true. Окей?
Вот. Ну, когда я говорю список, на самом деле, это не совсем список в смысле языка C++,
в смысле аргументов, это просто там, некоторые пакеты, которые в жатом виде хранит вот такую вот
информацию. Вот. Окей? Вот общий синтаксис такой. Давайте, давайте разбираться. Собственно,
ну вот эти вот самые пакеты параметров, да, класс, многоточки и так далее, можно использовать,
естественно, не только в функциях, но и в шаблонах классов. Вот. Но, в общем, стоит помнить по следующую
проблему. Дело в том, что вот эти вот пакеты параметров, они работают жадным образом. Что это
означает? Это означает, что как только вы начали заполнять пакет, C++ не остановится его заполнять до
тех пор, пока он не прочитает все типы. Значит, примеры следующие. Ну, давайте посмотрим на первый
пример. Вот тут у меня есть шаблонная функция function, которая принимает шаблонный тип T и
дальше произвольное количество других типов. То есть, эта шаблонная функция принимает хотя бы
один шаблонный параметр. Окей? То есть, функция, которая принимает хотя бы один шаблонный параметр,
записывается вот так. Я бы говорю, что она принимает какой-то шаблонный параметр T и дальше
произвольное количество других параметров. Вот. Ну и функция принимает аргумент TX и дальше
произвольное количество других аргументов. Вот. Соответственно, что происходит? Если я функцию вызову
от 0 и 0.0, то в качестве типа T выведется тип int, естественно. В качестве пакета параметров
args выведется пакет, в котором хранится только тип double. Вот. Если я функцию function вызову явно
от трех int, то, соответственно, у меня в качестве параметра T выведется тип int. В качестве параметра,
в качестве пакета параметра выведется, ну, собственно, да, тоже выведут типа int-int,
потому что я в треугольных скобках явно указал. Вот. Ну и, собственно, вот параметры будут переданы
в функцию, которая принимает три int. Тут все понятно, да? То есть, первый шаблон параметра ушел в T,
а остальные шаблонные параметры ушли в args. Вот. Теперь более хитрые примеры. Смотрите, а что
произойдет, если я вот в шаблонном описании, вот в этом template, поменяю местами класс T и класс args?
В этом случае произойдет следующая странная история. Ну, по-прежнему, если я вызову function
от 0 и 0.0, то в качестве типа T, точнее, в качестве типа, да, смотрите, как это работает, да, function
от 0 и 0.0, компилятор смотрит на то, как объявлена функция function, и компилятор видит, что в функции
function первый параметр относится к типу T, поэтому, ну, там 0, поэтому тип T будет выведен как int. Вот.
Но остальные параметры — это args. Соответственно, в args у меня указан 0.0, да, поэтому это тип double,
то есть пакет параметров типов, args хранит только значение double. Теперь начинаются странности. Что
произойдет, если я в этом случае вызову function от трех int? В этом случае произойдет следующее. В
этом случае произойдет проблема, про которую я сказал. Проблема заключается в том, что пакеты
параметров типов, они работают жадным образом. То есть, как только вы начнете заполнять пакет,
этот пакет никогда не закончит свое заполнение, ну, до тех пор, пока вы не закончите, пока,
соответственно, вы не встретите треугольную скобку. Когда я написал function int int int, вот в
этом случае компилятор заявит об ошибке, скажет, что, погодите, ну, я понял, да, пакет нужно
заполнить тремя intами, а чем нужно заполнить t? Непонятно. То есть, вот, я написал function int int int,
и, собственно, в качестве первого шаблонного параметра указан класс многоточия args, и, собственно,
компилятор начал заполнять этот самый args. Он взял int, взял int, взял int. Все, пакет параметров
закончен, все, точнее, параметры закончились, значит, описание пакета закончено. Дальше он хочет
понять, а чему равен тип t, и тут он поймет, что, ну, как бы, погодите, ну, тип t, типу t ничего
не соответствует, да, потому что все ушло в args. Вот, в args три параметра, вот, в пункцию предали
три параметра, значит, тип t невозможно вывести. Что? Смотрите, в первом случае у вас в описании
template class t. Class t идет в начале. Когда вы пишете, давайте так. В первом случае у вас написан template
class t, дальше class многоточия args. Ну, там void f. Ну, там неважно что. В этом случае, когда вы пишете f от int,
int. В этом случае компилятор смотрит сюда и понимает, что вы вызываете функцию f с
конкретными шаблонными параметрами. Ну, компилятор ставит соответствие вот этому списку, вот этот
список. И, собственно, что он понимает? Ага, первый элемент списка это t, поэтому t равно int. Дальше,
второй элемент списка начинает с дополнения пакета параметров, ну, и поэтому он сжирает вообще все,
что находится от вот этого места до конца. То есть args, это int, int. Окей? Что придет, если я поменяю эти
штуки местами? Давайте, тут class многоточие args, запятаю class t. Вот, и сделаю то же самое.
В этом случае снова я начинаю, ну, собственно, компилятор хочет поставить соответствие вот
этот список, вот этому списку. Ну, что он делает? Видишь, что первый параметр int. Он видит, что первым
параметром идет пакет параметров типов. Пакет параметров типов не знает, где он заканчивается,
поэтому он жадным образом просто забирает в себя все. То есть вот начинается пакет, я говорю,
что я завожу пакет параметров типов args, значит туда запихиваю int, дальше туда запихиваю int,
туда запихиваю int. Все, пакет закончился, точнее, все, список параметров закончился,
поэтому пакет завершил работу. Вот. Чему равен тип t, пока не понятно. Ну, окей, потом разберемся. Вот.
И смотрим на то, как вызывается функция function. Функцию function передается три аргумента. Ну,
компилятор такой, ага, три аргумента. Ну, соответственно, все эти три аргумента, значит,
это вот эти самые args. А чему равен t, непонятно. До сих пор. Все, ошибка. Вот. Проблема понятна?
Та же самая проблема возникает, если я, ну, смотрите, снова, я возвращаюсь к исходному описанию
template, то есть класс t, класс многоточия args, но при этом поменяло местами параметры функции.
Видите, да? То есть сначала идет args многоточия args, а потом tx. Вот. Здесь уже обратная проблема.
Вот с таким описанием все будет окей. Почему? Потому что понятно, что первый параметр это t,
а остальные два параметра это args. Вот. Но если вы вызываете функцию function от 0 и 0.0,
то компилятор начинает действовать жадным образом. Да, он видит, что первым аргументом функции
function идут, ну, вот эти самые варарги. Да? Вот. Поэтому он говорит, что 0 это args int, 0.0 это args
double. Ну, на этом все. А дальше он видит, что, ой, у меня еще есть тип t. А для тип t вы ничего не указали.
Вот. Окей? Вот. Ну, наконец, последний пример, самый худший, это когда у вас вот этот вот самый
пакет параметров типов идет в начале, и пакет параметров функций тоже идет в самом начале. В этом
случае эту функцию, к сожалению, никак не получится вызвать. Потому что и в первом, и в втором случае
у вас просто-напросто вот эти вот класс многоточия args и args многоточия, они просто-напросто съедят
все параметры, и для t-шки ничего не останется. То есть компилятор скажет, ой, а я не знаю,
как увести t. Я все съел. Окей? Вот. То есть на самом деле мораль состоит в том, чтобы вот эти вот
класс многоточия args писать в конце описания, ну, либо в конце шаблона, ну, либо в конце самой функции.
Окей? Вот. Ну, иначе возможны вот такие вот приколы. Да.
Сейчас еще раз, я совсем понял. Так, тут последний пример, и мы там...
Сейчас, последний пример, так? А, предпоследний. Так, и что мы делаем?
Инт. Ну, там типа, допустим, 0, 0.0. Так, ну, давайте посмотрим, что будет происходить.
Предпоследний пример. Ну, собственно, в предпоследнем примере у меня в описании шаблона указаны
тип t и args многоточия. Вот. В этом случае, ну, просто нам составим соответствует этот список
к этому списку. Это означает, что мы т-шки, в качестве т-шки, вводим int. В качестве argsa, ну, пока ничего не понятно.
Вот. Смотрим теперь сюда. Окей, компилятор понял. Ага, 0 это... А, сейчас, нет. Так, дальше смотрим на вызов
функции, а функция принимает args многоточия и t. Вот. А, ну, вот в этом случае снова будет проблема.
Почему? Потому что компилятор увидит, что функция function объявлена как args многоточия. Ему нужно
попытаться понять, что такое args. И он начинает пытаться. Он понимает, ага, первый параметр это int.
Второй параметр это double. Все, список закончен. Ну, на этом все. А дальше компилятор понимает, так,
погодите, args у меня int double, t это int. То есть, функция у меня принимает три параметра, а мы
передали два. Как так? Просчитался, но где? Ну, еще раз, мы в тезе писали int, но вот про args мы пока
ничего не поняли. Он может быть, ну, погодите, он может быть пустым, но компилятор-то не знает,
пустой он или нет. Пока компилятор не знает, какой он. Чтобы понять, что он пустой, ему нужно
проделать какую-то работу. Ну, это как, ну, не знаю, ему нужно вывести параметры, ему нужно вывести
параметры для args. То есть, ему нужно понять, пустой он или нет. Вот, собственно, компилятор видит,
что вызывается function, который первым параметром принимает произвольное количество аргументов. Вот.
Он смотрит на вызов вот этой функции и видит, ага, первым параметром действительно идет произвольное
количество элементов. Причем все мое. То есть, 0 это мое, 0.0 это мое, все, я понял, что args это int и double.
Вот. То есть, компилятор сгенерировал функцию, которая принимает int, double и в конце int. А дальше
компилятор снова возвращает сюда и видит, а погодите, тут же всего два параметра, а не три. Вот.
Где он будет дефолтным? Ну, если тут... А, ну, не, это не важно, потому что связь с дефолтным значением,
она происходит после этапа выбора шаблона. То есть, сначала будут проведутся вот эти шаги, а потом
с нужным значением свяжутся значения по умолчанию. Значение по умолчанию, еще раз напомню, не влияет
на вывод шаблонного параметра. Да. Да. Нет, давайте по порядку. Как происходит инстанцирование
шаблона? Вот. Давайте я коротко запишу снова. У меня есть t, у меня есть args многоточие, а функция f
принимает args многоточие и t. Вот. Я вызвал функцию f от int 0, ну, допустим, 0.0. Для начала компилятору
нужно понять, что это за шаблонная функция. Для того, чтобы компилятор сгенерировать код, ему нужно
понять, что это за функция. Ему нужно понять, что это функция f от каких шаблонов параметров.
Для этого ему нужно заполнить тип t и заполнить тип args. Тип t он берет вот отсюда. Так, все,
вот первый шаг, тип t он берет отсюда. Int. Дальше компилятор анализирует, а что же такое вы ему
передали сюда? Вы ему сюда передали int и double. Окей. Значит, компилятор видит, что функция f
принимает произвольное количество шаблонов параметров. Вот когда компилятор это видит, он
впадает в режим берсерка и берет все, что ему впадает с под руку. Он видит, что args многоточие,
все, это мое. Int мое, double мое. Все. Компилятор сгенерировал вот такую функцию. Функцию f,
которую принимает int, int, double. Все. Как выглядит эта функция? Эта функция выглядит так.
int x, int y, double z, ну типа. Вот. Все, он сгенерировал такую функцию. Теперь он пытается,
ну теперь он, собственно, пытается вот эти вот параметры связать с этой функцией. Видите? Ага,
0 это x, 0.0 это y, а тут что? Ой. Так, я перепутал. Да, у нас, а нет, все нормально. Нет, все
нормально. У нас int, int, double, а не int, double, int. А, да, простите, да, да, да. Вот тут я
перепутал. Да, тут сначала args, а потом t. Да, то есть тут сначала double, а тут int. Да, согласен.
Ну, в любом случае 0 связывает с x, 0.0 с double, а на z ничего не осталось. Последние параметры
дефолтное значение? Ну, давайте разбираться. Допустим, тут написано t равно int. Ой, не t равно,
равно нулю. Давайте разбираться снова, что произойдет. Я пишу f от int, то есть в качестве параметра
t будет int. Дальше функция вызывается от двух значений. Снова, тут вот до этого даже не дойдет,
потому что компилятор увидит args и все. И тут начался сущий кошмар. Ноль, первый аргумент,
0.0, второй аргумент. Все, args имеет два типа. Все. Теперь, то есть компилятор генерировал вот такую
функцию int x, double y, int z равно нулю. Вот. А, ну, кстати, тут да. Тут, кстати, скомпилируется,
похоже. Потому что 0 уйдет в x, double уйдет в y, а третий параметр окажется так, что имеет
дефолтное значение. Да, тут, кажется, сработает. Да. Но все равно это плохой стиль, потому что,
чтобы разобраться с тем, что на самом деле вот это сработает, ну, потребовалось какое-то
время. Вот. Поэтому ставить параметры в начале не стоит. И чем, если вы указываете args многоточие,
да, ну, вообще просто собранные параметры переменным количеством аргументов, то лучше указывать
в конце. Окей? Хорошо. Так, ну, в общем, мы довольно много времени потратили вот на понимание того,
как работают args, args, что они принимают, в общем, как они, какие типы при этом выводятся. Ну,
собственно, самый интересный вопрос это, а как их использовать? То есть вот я все время говорю,
что вот есть пакет параметров, пакет типов. А как, собственно, из этого пакета достать
конкретный тип, да, или как из этого пакета достать какой-то конкретный параметр? Вот, собственно,
давайте об этом начнем говорить. Значит, ну, пункт номер ноль состоит в следующем. Значит,
по пакету параметров, вот в отличие от языка C, по пакету параметров вы всегда можете понять,
какое количество аргументов там было передано. Ну, смотрите, вот пакеты параметров, а вот,
смотрите, вот в отличие от языка C, пакеты параметров они обрабатываются на этапе компиляции.
Подстановка шаблонных параметров происходит на этапе компиляции, а раз это происходит на
этапе компиляции, то уже на этапе компиляции понятно, сколько аргументов принимает функция, да? Вот. А раз на
этапе компиляции известно, сколько аргументов принимает функция, то я на этапе компиляции могу
узнать, сколько там параметров передано. Вот. И делается это с помощью операции sizeof. Вот пример.
Вот у меня есть функция function, я пишу класс многоточия args и дальше, собственно, принимаю какое-то
количество параметров. Вот. А, тут, кстати, пример про то, как все аргументы принять по
константной ссылке. То есть мы на самом деле на args можем навесить все что угодно. Давайте тоже
прокомментирую, кажется, у меня там слайды есть, но можно прокомментировать. В общем, если я напишу args многоточие
args, то это означает, что все параметры будут переданы по значению, да? Как передать все параметры по ссылке?
Я пишу args, ссылка многоточие args. Как все параметры передать по константной ссылке? Ну, пишу const
args, ссылка многоточие args. Вот. Как передать по указателю? Ну, собственно, пишу args, указатель
многоточие args, ну и так далее. Вы просто-напросто нужный модификатор навешиваете на вот этот вот
args. И тогда все параметры будут иметь вот ровно такой тип. То есть тут все параметры будут иметь
тип ссылка, тут конст ссылка, тут звездочка. Первое, просто по значению. Ну, типа то же самое,
как если вы написали, допустим, tx. Вот тут то же самое, как если вы написали t&x. Тут
конст т&x, тут t со звездой x и так далее. Ну, то есть это просто-напросто типа, на который ничего
не навешано. Да, не звездочки, не апельсанды, ничего. Отдельного поведения нет, к сожалению, нет.
Можно, короче, на самом деле можно, то есть на самом деле можно принять типы в зависимости
того, что вам передано, но об этом в следующий раз. Про универсальные ссылки потом. Вот.
Окей. Ну и теперь, собственно, с помощью операции сайзов многоточия можно понять,
сколько параметров было передано в функцию. Вот у меня есть функция function, которая принимает
произвольное количество, произвольное количество аргументов. Я могу применить операцию сайзов к,
ну, самому пакету параметров типов, то есть аркс с большой буквы. Могу применить сайзов
многоточия к аркс с маленькой буквы. В этом случае у меня всегда будет просто
обсвободиться количество параметров, которые, которые было передано в функцию. Например, если
вызову function от 1, 2, 3, то у меня выведется две строки со значением 3. Окей. Вот. Ну это вот
такой просто нулевой пункт. Собственно, как понять, сколько аргументов было передано в функцию. Вот.
Теперь давайте поговорим про то, как функции вызывать. Вызываются функции следующим образом.
Значит, есть три способы, ну, таких принципиально три способы вызвать функцию с переменным числом
аргументов. Первый способ – это вызвать другую функцию, которая принимает произвольное количество
аргументов. Значит, этот способ называется распаковка пакета. Ну, это такой читерский способ,
который начинается с следующих слов. Допустим, у нас уже есть какая-то функция,
которая может принимать произвольное количество параметров. Ну, допустим, как-то за вас реализовала
такую функцию, вот. Как мне взять вот пакет, пакет параметров, и целиком передать его в другую
функцию. Вот. Чтобы это сделать, необходимо такая операция, как распаковка пакета. Значит, смотрите.
Тут у меня написано, то есть, представьте себе, что у меня написана функция print, которая может
принимать произвольное количество параметров. То есть, пак crises can be printed opening the
количество параметров vseout. А я пишу функцию printTitle, которая до вывода всех этих типов пишет некоторые из заголовок.
Какую-то отладочную информацию или какой-то лог.
Функция printTitle выглядит следующим образом. Она принимает пакет типов class.args, дальше она принимает первым параметром заголовок,
который нужно вывести в начале, а дальше принимает параметры, которые нужно вывести затем.
Функция printTitle выглядит следующим образом. std.seout.title, то есть я вывел заголовок, а дальше вывожу все остальные параметры.
Чтобы вызвать функцию print от всех параметров, которые были переданы функцию, я использую синтаксис распаковки пакета.
Это принт, args, многоточие.
Вот эта вот запись, в целом, можно считать, что она представляет вот эти данные вот в таком виде.
Ну, а 0, запятая а1, запятая а2, и так далее, а n-1.
То есть args, многоточие, вот эта вот многоточие, которая написана уже внутри функции, означает распаковать пакет.
То есть расправить пакет, первый, второй, третий, и разложить их вот по порядку.
Второй пример. Что еще можно делать с этим самым пакетом?
На самом деле, вот эти вот параметры в процессе распаковки можно каким-то образом модифицировать или каким-то образом менять.
Вот пример ниже. Сумма квадратов.
У меня есть пакет параметров args, ну и, собственно, сумма квадратов принимает произвольное количество аргументов.
Вот. Допустим, у меня уже есть написанная функция sum, которая принимает произвольное количество параметров и просто-напросто суммирует все аргументы.
Вот. Как мне сделать так, чтобы эта сумма суммировала квадраты всех значений?
Ну, собственно, я делаю, ну, я поступаю так, как написано выше.
Да, я пишу sum, args умножить на args многоточие. Вот.
В чем заключается этот синтаксис распаковки?
Вот пусть у меня есть какая-то функция f, и я хочу каким-то образом модифицировать пакет параметров.
Я могу сделать следующее. То есть я могу применить какую-то операцию к пакету args.
И дальше указать многоточие. Вот это вот g означает просто-напросто произвольную операцию.
То есть с этим args я могу сделать все, что угодно. Вот.
В этом случае это будет расписано так. f от g а0 запятая g от a1 запятая g от a2, ну и так далее.
Понятно? То есть вот это вот sum от args умножить на args многоточие означает sum от a0 умножить на a0
запятая a1 умножить на a1 запятая и так далее. Вот.
То есть перед распаковкой вы можете применить нужную операцию каждому элементу пакета,
и таким образом он будет распакован вот в то, что вам нужно. Пример понятен?
Вот. Ну и еще примеры. Допустим, я хочу напечатать адреса передаваемых аргументов.
Тогда я принимаю все аргументы по константной ссылке. Вот. Print addresses.
Ну и каждому аргументу применяю операцию получения адреса.
Print % args и многоточие. Тогда у меня каждому аргументу будет применена операция взятия адреса.
Вот. И передана функцию print. Вот.
И еще функция print part sums это функция, которая считает частичные суммы.
То есть считает допустим сумму всех элементов без нулевого элемента,
потом сумму всех элементов без первого элемента, сумму всех элементов без второго, ну и так далее.
Теперь давайте, ну собственно, самый интересный вопрос.
А нет у меня такой функции. Ну вот все. Вот мы вот только изобрели вот шаблоны с переменочным аргументом.
Нужно написать самую первую в мире функцию, которая принимает произвольное количество аргументов.
Как это сделать? Значит, есть два способа. Первый способ старый, второй способ новый.
Начнем, как обычно, со старого способа.
Значит, старый способ – это мета-откусывание, ну или мета-рекурсии.
Вот. Смотрите. В чем проблема?
Проблема стоит в том, что ну давайте напишем какую-нибудь функцию.
Ну давайте функцию print напишем.
Проблема состоит в том, что вот этот вот пакет параметров – это довольно-таки непонятная сущность.
Вот. И если вы все это время надеялись, что я вам расскажу, что на самом деле пакет параметров – это вектор,
или на самом деле пакет параметров – это array, вот не так.
Пакет параметров – это просто пакет параметров. Вот такая сущность.
Вот. И как-то на самом деле в Github C++ нет какого-то определенного инструмента,
который позволит вам работать с этим пакетом.
То есть нельзя сказать, что ARX 0, или там возьми ARX 1, и так далее.
То есть вот пакет – он просто пакет. Вот он целиковый.
Вот такая вот целиковая история. Ну это не знаю.
В достаке он привезли, и вот завязали как следует.
И их фиг развяжешь. Вот та же самая история.
Вот пакет, который не развязывается.
Вот. Поэтому просто так взять и достать оттуда аргументы, и обрабатывать их по отдельности,
ну вот непосредственные функции, к сожалению, не получится.
Вот. Вопрос, как обмануть компилятор.
Вот. Да, смотрите.
Знаете, в чем тут проблема? В чем проблема вот этой функции?
Проблема вот этой функции в том, что мы взяли все аргументы,
сразу запаковали вот в одну сущность.
И вот из этой сущности мы ничего отдельно выделить не можем.
А давайте напишем такую программу.
Давайте выделим один отдельный элемент из этого пакета,
и весь остальной пакет.
Давайте перепишу эту функцию другим образом.
Давайте я скажу, что у меня функция print.
Функция print принимает какой-то произвольный параметр t,
а потом все, что угодно.
Ну, давайте так напишу t, x,
args многоточие args.
Вот, смотрите, то есть я сказал, что первый аргумент,
который я передам в функцию print,
он пойдет в аргумент t.
А все остальное пойдет в args.
Ну, смотрите, ну кажется, что стало чуть понятнее.
Почему? Потому что если у меня есть первый аргумент,
то мне нужно вывести в аргумент std cout x.
Ну и дальше там не знаю, пусть с новой строки все выводится.
Понятно?
Вопрос, а что делать с пакетом параметров?
Ну что значит, мне же надо,
то есть у меня же задача стоит не в том, чтобы вывести первый аргумент.
Мне нужно все аргументы вывести.
Да, смотрите, у меня же есть функция print.
Давайте я вывожу в функцию print.
print от args многоточие.
И в этом стоит откусывание.
Да, вот эти параметры снова передаются в функцию print,
и уже первый аргумент вот этого пакета параметров
откусится в x.
Понятно? То есть давайте пример.
Вот я вызываю print от 1, 2, 3.
Что происходит в этом случае?
У меня откусывается x равный 1
и args равный 2, 3.
Согласны?
Единицу я увожу,
а дальше вызываю функцию print от 2, 3.
Что откусывается?
Двойка откусывается в x,
а в пакете args остается тройка.
Что происходит дальше?
Вызывается print от тройки,
откусывается тройка,
которая выводится,
и остается args пустым пакетом.
Что происходит дальше?
Вызывается print.
Ну смотрите, у меня не важно, пустой пакет, не пустой,
я же вызывал print от пакета.
Если пакет пустой, то сюда передается 0 параметров.
Вызывается print без аргументов
и ошибка импиляции,
потому что откусывать нечего.
Понятно?
Да, ну собственно, смотрите, так как мы реализовали
функцию рекурсивно,
рекурсия должна когда-то кончиться.
Поэтому тут нужно рассмотреть особый случай.
Особый случай это, видимо, как раз-таки
print без аргументов.
Давайте отдельно напишем функцию, просто void print,
которая не принимает никаких аргументов,
но она просто ничего не делает.
Если вы сказали напечатать ничего, то я ничего не печатаю.
Когда вызываю print, то будет вызываться
уже вот эта функция print,
и все, на этом завершится работа.
Окей?
Вот этот откусывание.
То есть я просто напишу рекурсивную функцию,
и все остальное, и дальше просто
всю эту функцию рекурсивного вызываю,
и по очереди по одному элементу откусываю.
Ну да, по очереди просто откусываю элементы
и обрабатываю их
с помощью рекурсии.
Окей?
Ну вот.
Давайте посмотрим на пример, тот самый пример
с функцией print.
Тут у меня
чуть по-другому написано, то есть тут у меня
конец рекурсии был, когда в функцию print передали
ноль аргументов, вот тут конец рекурсии,
когда в функцию print передали один аргумент.
Вот. То есть если функцию print передали
один аргумент, то просто-напросто его ввожу.
Вот. Если в функцию print передали
один аргумент и еще что-то,
то вызывается
функция print, то есть печатается
head, ну вот тут параметры я назвал head
и tail, классическое название на самом деле.
То есть откусывается голова, и дальше вызывается
print от хвоста. Вот.
Когда я вызываю print от 1, дальше
строка, дальше 0.0, все прекрасно обрабатывается.
Понятно, да?
Вот.
Значит, второй пример для суммы.
Вот.
Сумму можно тоже реализовать,
ну, короче, сумму точно так же можно реализовать, да?
То есть базовый случай, то есть конец рекурсии,
когда в сумму передали один аргумент,
то есть если у меня в сумму передали один аргумент, то я просто-напросто его
возвращаю. Вот. Если в сумму передали
много параметров, то есть, точнее, более одного
параметра, то я беру этот
первый параметр и складываю его с результатом
суммы от хвоста, да?
То есть я беру head плюс сумма
от всего остального. Согласны?
Все, таким образом получается сумма.
Вот. Тут
да, тут я еще обратил
внимание, смотрите, вот на вторую функцию,
на возвращаемое значение,
тут я указал auto, то есть я не помню, явно мы
проговаривали это или нет, но вообще говоря, для возвращаемого значения
функции можно указывать auto, и если
по return можно этот тип увести,
то компилятор этот тип увидит.
На самом деле использование auto в качестве возвращаемого значения оно не очень
рекомендуется, но тут на самом деле оно осмысленно
по двум причинам. Первая причина,
все все понимают, то есть понятно, что сумма возвращает
сумму всех аргументов, то есть более-менее понятно
какой тип, да? Тип, ну, тип
это результирующий тип для суммы
всех элементов. Вот. А второе
замечание стоит в том, что тип на самом деле
явно написать можно, мы про это поговорим ближе
к концу семестра, как? Вот. Но он
будет настолько сложный и большой, что
в целом лучше написать auto,
чтобы никого не путать, окей?
Вот. Поэтому
в общем, auto просто автоматически уводит тип возвращаемого значения,
тут такое можно делать, ну, в шаблонах функциях
или в обычных функциях, вот. Но это делать не
рекомендуется. Вот.
Окей?
Так.
Хорошо. Ну, наконец,
современный метод
использования
шаблонов,
в общем, страшно сказать, но
с момента появления современного метода,
точнее, от современного метода
до создания вот этих самых шаблонов с переменающим
аргументом прошло 6 лет, то есть
был стандарт с плюс 11, потом...
И вот это вот fold expressions появились и плюс 17.
Вот. То есть, как на самом деле
стоит реализовывать функции
с переменами числонов аргумента?
Для этого стоит использовать выражение
свертки.
Что такое выражение свертки?
Выражение свертки, на самом деле, по сути,
это просто-напросто
еще один способ
распаковки параметров.
Смотрите, тут мы обычно
распаковывали параметры
просто через запятую, грубо говоря.
Применяли какую-то операцию каждому аргументу
и через запятую их перечисляли и передавали функцию.
Выражение свертки это следующее.
Я могу написать, допустим,
args. Дальше какая-то операция
многоточие.
Вот.
И это будет означать, что все аргументы
ко всем аргументам
нужно применить бинарную операцию op.
Да?
То есть, вот там сверху написано.
Аргументы op многоточие.
Это означает, что нужно взять а0
и применить операцию ко всему остальному.
Вот если многоточие пишется справа
от операции, то это означает, что
будет так называемая правая свертка.
Это значит, что сначала будут выполняться операции
над последними аргументами.
Сначала, допустим, сложатся последние два аргумента,
потом сумма этих двух аргументов прибавится
к предпредпред последним аргументам,
ну и так далее.
Ну, собственно, запись понятна.
Есть также левая свертка.
Операция. Дальше, собственно, пакет параметров.
В этом случае операции
выполняются слева направо.
То есть, сначала a0, a1, потом к результату a2,
потом к результату a3, и так далее.
Наиболее интересные, наверное,
случаи 3 и 4 — это
так называемая распаковка с анициализацией.
Что такое init? Ну, представьте себе, что у вас
ну, грубо говоря, вы хотите применить
операцию, вы хотите сделать следующее.
Вы хотите сложить a0
плюс a1, плюс a2, плюс a3
и так далее. Ну, и там прибавить
какое-то начальное значение.
Это начальное значение можно указать, ну, либо
справа от многоточия, либо слева от многоточия.
В этом случае будет просто GooGoo,
с некотором начальным значением.
То есть, добавляется
некоторое начальное значение. Norwegian speak.
Ну либо левое sốло с начальным значением.
OK?
在. plot.
В Muitoareth Penguin.
На самом деле, это начальное значение очень важно
в контексте, например, реализации
функций print. Давайте посмотрим на примеры.
Вот реализация функции print с испортным выражением
сперки.
Смотрите, никакой рекурсии, просто-напросто одно выражение,
ровно то, чего мы вроде как и хотели.
Вот есть шаблонная функция print, которая принимает
пакет параметров args, все аргументы мы принимаем
по константной ссылке, и дальше пишем просто-напросто
следующую fold expression.
std seout, выводим многоточие, дальше args.
Какому из fold expressions соответствует этот вот синтаксис?
Смотрите, 1, 2, 3 или 4.
Да, смотрите, 4, seout это init, операция побитого с двига
влево это вот это вот самое op, дальше вот ноготочие,
дальше вот это операция, дальше пакет параметров.
И собственно это распаковывается вот так, как написано внизу.
Сначала seout применяется к 1 параметру, потом результат
этого seout применяется к 2 параметру и так далее.
Но мы с вами знаем, что если я применяю seout к чему-то,
то что тут возвращается?
Да, возвращается сам seout.
Поэтому, когда я в следующий раз применяю seout, то у меня
по сути seout применяется к y, то есть у меня seout применяется
к 1 аргументу, потом seout применяется к 2 аргументу,
к 3, 4 и так далее.
То есть понятно, да?
Понятно, почему это работает.
То есть просто происходит распаковка с помощью некоторой
бинарной операции.
Ну и то же самое с суммой, но с суммой все гораздо
проще.
У меня есть аргументы args, я принимаю их по константной
ссылке и дальше возвращаю свертку с операции сложения.
Дай пишу args plus многоточие.
То есть тут у меня на самом деле правая свертка, то
есть тут у меня сначала складываются последние
два аргумента, потом это все складывается с третьим
аргументом, с четвертым и так далее и так далее.
Если хочется применить левую свертку, то есть если
хочется на самом деле, чтобы складывались слева
направо, то можно применить return многоточие plus args.
Понятно?
Вот.
Так.
Задайте какие-нибудь вопросы, если есть.
Что?
О!
Да, про этот вопрос сейчас мы поговорим, есть какие-то
вопросы по синтаксисту вопроса.
Все окей, да?
Ну, в общем вот, fold expression это ваш друг, можно пользоваться
им и писать собственно функции с переменным числом аргументов.
Вот.
Да.
init – это просто некоторый объект, к которому применяется
операция.
Ну, давайте так.
Ну, init – это просто какой-то объект.
Вот.
То есть если я пишу init plus многоточие plus args, то это
то же самое, что init plus a0 plus a1, ну, давайте так,
напишу просто init plus a0 plus a1 plus a2 plus a3 plus и так
далее.
Plus – это операция левоассоциативная, поэтому вот
так.
Ну, init – это просто некоторый объект, к которому прибавляется
все остальное.
Ну, это может, ну, естественно, должен быть тип, который
к которому применима операция сложения с a0.
Ну, тут, например, вот, во втором примере у нас в качестве
init выступался this out.
Ну, почему?
Потому что если я просто напишу ко всем параметрам
применю операцию по bit.ly с двига, то все элементы
просто будут сдвигаться относительно друг друга.
Да.
А тут я применил this out, и теперь, собственно, this
out применяется к первому параметру, потом результат.
Это this out тоже применяется к второму параметру и так
далее.
Так.
Еще вопросы?
Так, ну, теперь давайте погрузимся чуть глубже.
Смотрите, на самом деле, вот в этой реализации есть
несколько косяк.
И косяк заключается в том, что, ну, да, все действительно
будет выведено на экран, но тут не будет никаких
пробелов.
Почему?
Потому что если я применил std this out a, std this out a, b, c,
и так далее.
То есть, если я увожу все вот так вот подряд, то,
ну, естественно, никаких пробелов не появляется,
никаких переносов строк не появляется.
Вот.
Вопрос.
Что делать?
Как сделать так, чтобы у меня появились пробелы?
Ну, вот, к сожалению, так не получится.
То есть, если я напишу вот так, что-то типа std this
out a, c out, многоточие, не знаю, там, arx.
Вот.
Ну, во-первых, это не скомпилируется, потому что, ну,
такого синтеза, ну, просто среди всех выражений свертки
такого выражения нет.
Вот.
Если я напишу вот так, то это скомпилируется, но
это скомпилируется как?
Вот, что получится тут?
Да, сначала все выведется, а потом в конце выведется
один одинокий пробел.
Вот. Что делать? Что добавить? А, в args пробел, ну типа через каждый args наставлять
пробелов. Кстати, это интересная задача, типа вот взять args и между каждым
args вставить пробел. Вот. Но я не уверен, что сейчас мы хотим это реализовывать.
Вот это вот как раз такие идеи. Точнее, а, каждому args добавить пробел? Ну смотри, а как
вы добавить каждому args пробел? А если тип не костуется к string view? И не как-то
изменить. Ну можно, короче, ну можно написать свой собственный класс, у которого
выбор с произволием типом будет работать как cout и плюс добавление
пробелов. Ну давайте так, какой-нибудь неинвазивный мет, который бы не заставил
нас писать какие-то новые типы, какие-то новые функции. Через что? Ну да, один из метных
это использовать откусывание, но не хочется. Хочется вот в рамках этого. Смотрите, на
самом деле, давайте просто вспомню, как это происходит на самом деле. Ну как мы
обычно выводим данные через пробел? Ну мы обычно пишем что-то типа std cout x
пробел, потом std cout y пробел, ну и так далее. Ну там обычно это происходит в цикле,
да, ну так или иначе. Мы просто используем разные, мы просто используем для каждого
вывода свою операцию, да, то есть cout x пробел, cout y пробел и так далее. Согласны? Вот.
Вопрос. Есть ли какая-то операция, которая позволяет выполнить несколько операций подряд?
Короче, я утверждаю, что нам сейчас нужно делать свертку не с операции вывода в поток,
а с какой-то другой операции, которая позволит несколько операций выполнить вот в одном выражении.
Операция запятая, вот. Давайте вспомним, что у нас на самом деле есть такая замечательная операция,
как запятая. Ну и на самом деле с запятой тоже можно делать свертку. Да, то есть я могу написать
номер args запятая многоточие. Что это означает? Это означает нужно применить операцию запятая
к каждому аргументу, ну точнее ко всем аргументам. То есть args 0, args 1, args 2 и так далее. Так. Ну и
собственно, что делаем? Предлагаю написать вот такой код. std sout, std sout args, дальше пробел,
запятая многоточие круглые скобки. Давайте разбираться. Вот, смотрите, что стоит слева от
запятой? Тут стоит пакет. Вот. Смотрите, если args пакет, то функция g применена к args это тоже пакет.
Окей? Тут стоит args, это пакет. И к args я применил следующую операцию, выводов поток сиал и
последующего вывода пробела. Вот. То есть это операция, которую нужно применить к отдельному
аргументу. А теперь мне вот эту операцию нужно применить к каждому аргументу. Что я делаю? Я
ставлю бинарную операцию запятая многоточие, вот вам свертка. Давайте проще. Просто если я написал
вот так вот f от args, запятая многоточие, это было бы то же самое, как f от a0, запятая f от a1,
запятая и так далее. Теперь представьте, что в качестве f выступает вот это вот. Понятно? Тогда
будет std sout args, вывод пробела, запятая std sout args, вывод пробела и так далее. Понятно?
Ну вот. Ну тут чуть наоборот, но ладно. Да-да-да, вот эти круглые скобки обязательно, потому что
они ограничивают пакет. Вот. А, внешние? Внешние тоже обязательно, да. Давайте с плюсом. Если
я напишу вот так, все понимают, что это a0, плюс a1, плюс и так далее, плюс an-1. Так? Ну, на самом
деле, там правая статья, ну то есть там сначала будет справа, то есть складываться будет справа
налево, но в целом идеологически понятно, да? Нет, смотрите, вот у меня функция print,
которая принимает отдельно head и отдельно в список параметров. То есть тут я, блин,
тут я на самом деле просто-напросто перемудрил, наверное, тут просто реализация функции print,
которая не печатает лишних пробелов. Вообще говоря, можно и без этого обойтись, давайте целым. Как
проще всего эту функцию реализовать? Просто template class многоточие args, void print, args, ну там по
константной ссылке можно, многоточие args. Все, вот это единственная точка, которая содержится в функции
print. Вот. Она выведет все параметры через пробел, ну там в конце еще будет лишний пробел, ну ладно,
бог с ним. Окей? Вот. То есть как это работает? Это работает так, что, ну вот, давайте с операцией плюс
рассмотрим. Вот args плюс что-то раскрывается вот с такую штуку. Если я к функции args применю
какую-нибудь f от args, многоточие, то у меня будет f от 0, f от a0, плюс f от a1, плюс и так далее.
Тоже понятно. Теперь мысленно заменяем f вот на, ну то есть представь себе, что f делает вот такую
штуку. Да, функция f, она просто-напросто берет args, точнее берет аргумент и к нему применяет
слева cout, справа вывод пробела. Все. std cout args пробел и плюс заменяем на запятую, потому что
запятая тоже операция. Все. В итоге получается, ну вот это вот cout, давайте напишем, cout a0,
пробел, запятая, cout a1, пробел, запятая, ну и так далее. Ну head тут нужен просто, ну смотрите,
head мне нужен для того, чтобы я сначала вывел head, а потом все остальное через пробел. Ну потому
что смотрите, вот в этой реализации как у меня все выводится? У меня выводится a0-пробел, a1-пробел,
a2-пробел и так далее, an-пробел. То есть у меня в конце оказывается лишний пробел. Вот эта
реализация просто написана для того, чтобы вот лишнего пробела в конце не было. Ну тут ладно,
я переусложнил просто. Вот реализация. Окей? Ну и все, и последняя проблема. У вас мог возникнуть
вопрос, ну смотрите, вот мы можем принимать произвольное количество параметров, а можно ли
сделать так, чтобы я принимал произвольное количество параметров, но определенного типа. Например,
я хочу написать функцию сумма int, и эта сумма int должна принимать только int. Могу ли я, например,
написать вот так? Ответ нет, к сожалению. Вот. Просто так написать нельзя. На самом деле, в общем,
эту проблему тоже можно победить, но с помощью шаблонной магии. В общем, если вам очень хочется,
то можно попробовать написать что-то подобие такого. Вот. Вот такие штуки мы с вами тоже будем
рассматривать, но ближе опять же к концу семестра. Но в целом мораль такая, что, к сожалению, шаблоны
с переменом числом аргументов не позволяют очень просто написать функцию, которая бы принимала,
например, только int или функцию, которая бы принимала только вектора и так далее. То есть это
сделать можно, но довольно сложно. Что тогда, всем спасибо, до встречи на следующей неделе.
