Так вот, план у нас на сегодня заключается в том, что мы заканчиваем разговор про муфсимантику,
а это значит, что если у вас есть какие-то вопросы по ней, то вам нужно максимально
использовать этот день. Вот вся та каша в голове, которая у вас осталась после предыдущих двух
разов, а она, вероятно, велика. Я постараюсь ее сегодня размешать и подать к столу. Так,
ну давай вопрос. У меня друг из основных спросил, что такое муфсимантика. Не смог ответить. Я понял,
что ничего про нее не знаю. Ага. Точнее, я понял, что ничего адекватного про нее не знаю. Хорошо.
Знаю, что есть какие-то парочки магических инстинктов. Давайте, да, ну давайте попробуем еще
раз ответить на вопрос, что такое муфсимантика. Вот я вам два часа суммарно, то есть полчаса в
первый раз и полтора часа во второй раз рассказывал какие-то вещи. Начали мы с каких-то
магических заклинаний, потом я вел какие-то странные формальные определения, и мы начали
какие-то примеры разбирать. Давайте, прежде чем копать на самый глубокий уровень, все-таки
систематизируем, что мы уже знаем. Итак, что такое муфсимантика? У нас были проблемы. Мы иногда
хотим перемещать объекты вместо того, чтобы копировать. Когда мы, например, делаем pushback
вектор временного объекта, мы хотим, чтобы создавался только один раз объект, а не два,
чтобы не было двойного копирования. Когда мы делаем реаллокацию векторе, мы хотим то же
самое. Когда мы делаем swap, мы хотим, чтобы объекты мувались, чтобы это не значило, чтобы не
пересоздавались они полностью, а просто забирали друг у друга поля. И вообще можно придумать много
других сценариев, но это самые очевидные, в которых мы бы хотели, зная, что наш объект, ну как бы,
не нужен на старом месте переложить его поля в новое и там про него забыть, а не копировать его
полностью, чтобы потом там сразу уничтожить. В этом идее. Что мы для этого изобрели? Мы для этого
изобрели какую-то волшебную функцию move, которая делает, это нам, да, мы раньше думали, что делает
move на самом деле, move делает каст. По сути, move это, ну, такое название, скрывающее действительность.
Вот можно даже сказать, что move это не очень удачное название, потому что на самом деле эта
функция является ничем иным, как custom care value. Вот почувствуйте аналогию между, у нас с вами было
между custom constant, custom derived и custom care value. У вас, у нас в три раза возникала логическая
ситуация. Вот почувствуйте аналогию. Хороший математик, кто-то, кто видит аналогии, как говорил,
по-моему, Арнольд, да, не помню, кто это говорил, нет, кто-то другой говорил, извиняюсь. Тебе вообще
стыдно не знать, какой Арнольд. Вот, смотрите, давайте я вам приведу аналогию. У нас были,
послушайте, пожалуйста, сейчас, у нас были не константные и константные ссылки. У нас раньше
были такие ситуации. Вот у нас есть int и есть, значит, int&% и constant&% Чем отличается int&% от
constant&% формально? Да просто тем, что над ним больше действий разрешено. Вот, и мы можем,
имея int, его подать как сюда, так и сюда, но имея constant, мы не можем его подать сюда, мы можем
подать его сюда только, а чтобы подать сюда, его нужно скастить, то есть нужно сказать некоторое
специальное, эксклюзивное, так сказать, слово компилятору, я приказываю тебе, считай, что он
такой, не забудь про то, что он константный. Вот, константный int, мы не можем подать туда,
где ожидается обычный int. Мы для этого должны сказать, const cast на тебя, чтобы ты считал,
что так вот можно с ним поступать. Аналогично у нас была ситуация с наследованием. У нас были
base&% и derived&%. И были derived и base. Вот мы можем вот по этой ссылке подать как derived, так и
base. А по этой ссылке мы можем подать только derived. Если мы хотим подать base, чем отличается
derived от base, тем, что к ним больше действий разрешено, все те, которые над base и еще какие-то.
Если мы хотим по ссылке на derived подать base, то мы должны сказать явно static cast к derived&% от
base, считай, что он такой, вот, вообще-то он derived, вообще-то он base, тип у него,
base с точки зрения компилятора, но мы говорим static cast просто к компилятору, считай, что он
derived и делаем одним действием, как будто он derived. То же самое, по сути, происходит в move. Вот здесь
вот мы делаем const cast, вот здесь мы сделаем static cast. А функция move это, по сути, аналогичную
роль играет в ситуации, когда у нас есть int&&& и constant&&. И есть rvalue, а есть lvalue. Так вот,
ну, что такое lvalue? Ну, прям какая-то переменная просто. Сюда мы можем подать как rvalue, так и lvalue,
а сюда только rvalue. И что такое move? Это просто cast, аналогичный вот этим двум. Когда мы хотим
по rvalue, ссылке, отдать lvalue, чем rvalue от lvalue отличается? Тем, что, ну, тут уже так не скажешь,
не больше операции разрешено, но тем, что его как бы move, у него можно забирать поля и оставлять
его в пустом состоянии. Вот когда мы в конструктор приняли что-то, в чем для нас принципиальная
разница? Мы приняли lvalue или rvalue? Ну, lvalue, когда мы приняли, мы обычно считаем, что его портить
нельзя, а rvalue его как бы портить можно, оно временное. Чем для нас отличается идея на rvalue
от lvalue, когда мы принимаем куда-то? Тем, что rvalue приняв, мы считаем, что оно временно его
портить можно. И за счет чего это обеспечивается? Если мы реально rvalue отдали, то мы его и так можем
сюда получить. Ну, вот если мы вызываем f от чего-нибудь, я не знаю, от t круглой скобочки,
это rvalue, это временный объект, и он и так попадет в эту версию. Но если мы хотим вызваться от x,
чем бы ни был x, x это переменная, а значит lvalue. И если мы хотим отдать его сюда, где его испортят,
мы должны сказать cast. Вот этот вот move это ничто иное, как просто cast, подсказка компилятору,
что считай его таким, я тебе приказываю. Ты вообще-то думаешь, что он lvalue, но я тебе говорю cast
к rvalue. И весь этот механизм rvalue ссылок, он нужен как раз для того, по сути это такая аналогичная
защита тому, как мы cast к не консту. То есть вообще-то по умолчанию, если у вас есть какой-то объект,
реально существующий x, вы не можете его отдать туда, где ожидается rvalue. В эту функцию вообще-то
по умолчанию ожидается только вот такие штуки, временные выражения. Но move позволяет вам
настоящую переменную, обычную живую переменную, скастить туда и отдать таким образом туда,
где ожидает временный объект. Вот что такое move. Вот у вас после предыдущих двух раз могло это не,
ну я как говорю там, сначала мы воспринимали move как магию, потом она вводила формальное
определение. Но вот сейчас у вас, я надеюсь, начинает вырисовываться какая-то картина. По
сути все эти определения про то, чем является rvalue и lvalue, они нужны для того, чтобы вот эта
вся история корректно работала и проследовала вот эти вот аналогии. Понятно? То есть еще раз move,
она позволяет вам по сути заставить компилятор считать, что это rvalue и вести себя с ним так,
как будто это временная штука. А значит выбирать ту версию перегрузки, которая предназначена для
временных штук, только что созданных и не существующих в памяти вообще возможно. Вот
вот эта штука, она может быть временной, налету созданной, даже не положенной на стэк. move говорит
компилятору, веди себя с этой штукой так, как будто она вот такая и отдавай ее в соответствующую
версию. Поэтому rvalue ссылки позволяют унитализацию только от rvalue, чтобы lvalue в них не попало,
а если хотите rvalue, то нужно сказать явный каст. move это и есть каст. Ну как, вам теперь стало
понятно move семантика? Вот, отлично. Да. Нет, мы делали, это два разных конструктора. Нет-нет,
есть copy конструктор, есть move конструктор. move конструктор, есть конструктор. move конструктор
это конструктор перемещения, есть copy конструктор, это конструктор копирования, не бывает конструктора
перемещения копирования. Да. Для строки. Почему мы не могли то же самое, ну просто написать его в
обычном копе конструкторе. Что значит в обычном копе конструкторе? Это просто бы выдал lce,
потому что обычный конструктор понимает const string% и ты не имеешь права менять ее поля, хотя бы
по такой банальной причине это бы не работало. Не обсуждается. Нам нужно разное поведение для
lvalue строк принятых и для rvalue строк. Что такое rvalue идейно? Вот я вам написал, сначала мы воспринимали
rvalue как что-то, чему нельзя присваивать, но это некорректно, это наивное определение, хотя исторически
оно было первым. Дальше он написал длинное формальное определение. А в чем интуиция этого
определения? Что такое rvalue идейно? Это то, что временное, оно не лежащее где-то в памяти,
не созданное как полноценный объект. Оно временное, на лету созданное, компилятор даже, вообще говоря,
может не класть его никуда. Оно может в регистрах процессора считать как что-то мимолетное. rvalue
это что-то мимолетное и временное, короче. Вот если у вас что-то в жизни происходит мимолетное,
то это называйте rvalue. Произошло rvalue вчера и забыл я уже сегодня, что было. rvalue это что-то
временное, которое возможно даже не лежит в памяти ни в какой. Оно в регистрах просто лежит
процессора и сразу будет забыто. А вот все то формальное определение, это просто формализация
нашего понимания, потому что такое временная штука. И в этом определении существенные нетривиальные
пункты это cast.rvalue.ссылки или возврат.rvalue.ссылки из функции. Вот cast.rvalue.ссылки и возврат.rvalue.ссылки
из функции это два случая, которые не интуитивны rvalue. Это как бы принудительно rvalue. Вот rvalue.ссылка
позволяет вам какой-то объект, который существовал в памяти и уже как переменная был lvalue,
скастить, ну трактовать как rvalue, чтобы при перегрузке оно отходило туда, где временный
объект ожидается. Значит rvalue идейная, это временная штука. Так потому что она ничем не
отличается от обычной ссылки, кроме двух... Она по свойствам как ссылка, полностью как ссылка.
rvalue.reference это такой тип, который по свойствам абсолютно как ссылка себя ведет. Но у него есть
два главных отличия от старых ссылок, которые мы теперь называем lvalue.ссылками. И я их называл.
Два главных отличия в том, что во-первых, будучи возвращенной из функции или из каста, rvalue.ссылка
дает rvalue.expression. И это ключевое свойство. Это свойство, благодаря которому все работает.
Потому что именно благодаря этому свойству после move мы получаем rvalue, которое потом,
благодаря второму свойству, попадает вот в эту версию. Второе свойство это, что rvalue.ссылка
может быть только через rvalue проинцелизирована. Во-первых, ampersand заканчивается буквой D.
Правильно говорить ampersand? Да. Я знаю. Я буду говорить это столько, сколько потребуется. Я же
преподаватель, мое дело вас заставить это запомнить. Вот. Может писать constant 2 ampersand? Ну, я еще раз
говорю. Эта штука, которая в чистом виде, вот непосредственно она, вам вряд ли когда-либо понадобится.
Но она может возникнуть как наложение двух свойств. У вас может быть какой-нибудь константный объект,
который вы move'ните. Вот. Я же могу, например, где-то в какой-то функции, да хоть в шаблонной,
получить какой-то x и решить его отдать как rvalue куда-то. Я тогда напишу std move от x. Эта штука вернет
мне тип, какой был у x с убранными амперсандами и навешанными двумя амперсандами, то есть rvalue.
Но конст никуда не денется, если там был конст. И вот эта штука, если у x произвольный тип,
неизвестный мне, вообще говоря, такая штука может мне вернуть константный тип с двумя амперсандами.
Что произойдет, когда я константный тип с двумя амперсандами, пытаюсь отдать куда-то,
где есть перегрузки для rvalue и для lvalue. У меня стандартный сценарий, у меня есть перегрузка f,
которая принимает, ну скажем, string 2 амперсанда и перегрузка f, которая принимает const string
амперсант. И представим, что я хочу отдать const string 2 амперсанда. Куда я попаду? Конечно же,
во вторую. const это ничего не испортит, потому что сюда я не попаду по принципу константности,
а это все принимает, это все съест. Это логичное поведение, то есть если вы move-нули константный
объект случайно, то у вас все равно не получится отдать его в такое место, где его испортят,
потому что константность, независимо от rvalue-лишности, работает и не дает вам пойти
сюда, потому что константность рушается, а эта штука все съедает. Еще раз, непосредственно сам по
себе он никогда не нужен, ну по крайней мере я не знаю случаев, когда он прям нужен, но он может
случайно возникнуть в какой-нибудь шаблонном коде, как наложение двух свойств, и тогда после
move-а вы все равно сюда попадете, потому что константность вас спасет. Зачем? Зачем
вводить дополнительные костыли к правилам, если без костылей все работает как хочется? Так мы не
сходим, я как раз об этом и говорю, что благодаря константности мы не попадем сюда опять-таки,
а пойдем сюда. Если мы случайно получили const2ampersand, мы все равно не попадем в версию,
где его испортят, потому что константность защитит, и мы пойдем сюда. Ну такое, я не знаю применение,
константность не сильнее, это просто независимые два свойства, каждый из которых независимо
они не сильнее. Вот эта штука принимает как R-value, так и L-value, причем как константное,
так и неконстантное. Это мы еще и с первого семестра знаем. А эта штука принимает только
R-value, да еще и причем только неконстантное. Куда же мы пойдем, если мы вызовемся от
константного R-value? Сюда. Да. Вот если мы написали auto x равно, и вот const, ну что? Auto x равно что?
Ну равно вот R-value reference, const R-value reference. Что значит равно? X, auto x равно? Y какому-нибудь,
ну который является const R-value reference. Который является, тип которого const R-value reference?
У вас отбросится и const и амперсант, по-моему у вас все отпадет. Чего? А, так я же auto без
амперсантов написал. Auto без амперсантов означает, что у меня отбросится reference,
а значит и const отбросится. Так, да. Тип этой штуки просто t. Тип этой штуки просто t, да. Ну нет,
не константное. А с чего бы ей быть константной? Какой-то другой экспресс. Как? Какой экспресс? Ну,
как? Ну, как я тебе скажу, как констанция определяется? Ну, нужно 5 страниц считать
правил, как она определяется. Ну, вот у этого оно не константное, потому что здесь тип t явно
сказан какой. Хорошо, а если там будет какая-нибудь функция, другая j, которая будет возвращать,
например, const string, просто const string. const string? Да. А константные объекты из
функций возвращать, это, кажется, вообще warning, начиная с и плюс плюс 20. И это бессмысленно. Как
раз по той причине возвращать const t из какой-либо функции, не накладывая амперсант. Это вообще
deprecated практика. И начиная с и плюс плюс 20, это, по-моему, даже warning. Если, ну, это, короче,
не рекомендуется так делать. Ровно потому, что это бессмысленно. Это вы, получается, навесите
const на штуку, которая временная, ввиду чего вы не сможете попасть сюда, если надо будет,
и тем самым вы потеряете в эффективности ничего не выиграв. Не надо накладывать const на временный
объект. Он временный, его можно, как RL, ее трактовать и отдавать туда, где из него быстро и эффективно
заберут данные. А если вы const навесите искусственно на него, то вы потеряете это свойство и будете
медленно копировать вместо этого. Потому что ты, дело не в том, что ты move, вот у тебя есть
const rvalue ссылка, и ты move от нее делаешь. Ты можешь случайно наткнуться на такое. У тебя может
в шаблонном коде где-нибудь быть x, который иногда const, иногда не const. И ты его move-аешь.
Ну, тебе дали rvalue штуку, и ты move-аешь ее, но иногда она может быть константной, и тогда ты
получишь константную rvalue ссылку. И за счет константности ты будешь защищен от вот этого.
Константность — это просто дополнительное свойство, которое работает независимо,
оно тоже может тебе помочь правильно перегрузку выбрать.
Почему тогда в шаблонном коде не может встретиться ситуация,
какая из функций возвращается const t? Ну, например, потому что я могу функцию принимать что-нибудь такое,
вот функция с таким возвращаемым типом, она будет не отбрасывать const с таким принимаемым типом,
здесь const t — константность не отбросится. Если здесь t был с константой, то и он и пойдет с
константой. А если я в возвращаемом типе напишу t, то тут const уже отбрасывается. Ну, короче, когда я
ссылку возвращаю, вы же помните правила вывода шаблонных типов, когда я ссылку навешиваю на тип,
const в шаблоне не отбрасывается. А если я возвращаю просто t или принимаю просто t,
то const с него снимается. Если я хочу const чтобы не снималось, то мне нужно явно написать const t,
но это уже cringe. Так никто не пишет. Вот если я константную ссылку возвращаю, то это нормально.
А если я просто объект возвращаю, то const с него снимается, потому что это бессмысленно. Но если
вы явно напишите const t, то вам может компилятор warning скажет.
Да, совершенно верно. Вы должны оставить поля
этого объекта в каком-то условно пустом, чтобы это не значило, но корректном состоянии, чтобы он
еще пережил вызов деструктора нормально после этого. Moved-нутый объект, из которого сделали
move присваивание, он еще полноценно им можно пользоваться. То есть, вот бывает, знаете,
задают такие вопросы на собеседованиях или на экзаменах. Вектор какой-нибудь int v равно move
от другого вектора, от vv. И спрашивают, а вот теперь если я к vv обращусь, это ub или нет? Нет,
конечно, это не ub. Просто он пустой. Вот. Ну это какой-то другой вектор был. Вот я взял,
где создал вектор move из другого вектора. Что теперь с vv? И к нему можно обращаться? Можно. Он
просто пустой. И потом будет вызвано деструктор. Ну пустого вектора деструктора просто ничего не
сделает. Вот. И теперь также вы должны понимать, что функция move сама по себе. Вот, допустим,
у меня был вектор. Я написал move от vv. запятой. Все. Что произошло? Да ничего не произошло. Компилятор
эту строчку просто из кода выкинет. А это просто ничего не делает. Да, это все равно,
как если бы вы меня спросили, а вот если я напишу статик каст гдирайф тамперсант,
в скобочках от B, точка запятой, что произойдет? B сломается? Да ничего не произойдет. Просто вы
скаставали и не воспользовались тем, что скаставали. Ведь эти касты, они все нужны только для
разрешения перегрузки, по сути. Поэтому сама по себе функция move ничего не делает с объектом.
Делает с объектом операция конструирования или присваивания. А move лишь говорит компилятору,
в какую версию пойти за счет каста. Вот. Более того, вместо move всегда можно было бы писать
просто статик каст к двум персантам данного типа и это было бы это было бы аналогично было. Просто
чтобы не заставлять людей думать об этой фигне, move, ну, сейчас вы, понимая вот это все, уже должны
понимать, что вместо move всегда можно просто писать статик каст к вашему типу с двумя персантами,
это будет также точно работать. Move это и делает, по сути. Просто он делает это шаблонно для всех
типов. Remove Reference T нужно из-за того, что там T шаблонная. Но если у вас T конкретная,
то вы можете без всякой магии с шаблонами это сделать. Вот. Но move так называется, чтобы люди
кто не хочет в этом разбираться, могли в этом не разбираться. Чтобы обычным пользователям,
которые, значит, как бы сказать они их, а? Да ну нет, олимпиадники они все-таки поумнее обычно.
Ну в общем, пользователям, ну, чувакам, которые, чувакам, которые, чувакам, которые пишут на плюсах,
но на самом деле не хотят разбираться в том, как устроено вот это все, можно было просто писать
move и оно как-то работает. Это то, с чего мы начали. То есть, собственно, мы и начали с того,
что если вы ничего не знаете про move семантику, то вот все, что вам нужно знать на минимуме,
значит, starter pack c++ разработчика для прохождения собеседований. Как пользоваться move? Ну вот так,
все. Что делает move? Ну это сложный вопрос. Вот. Но теперь вы понимаете, что делает move. Он просто
делает каст, который заставляет выбирать другую перегрузку. А эти правила с ревелусылками
специально такие, чтобы правильно работала перегрузка. Вот. Миша понял. Кажется, что-то
понятно. Это мы проверим, безусловно. Да. Нужно даже. Вот сейчас, нужно, сейчас у вас прям вот момент,
когда нужно вот задать вопросы, чтобы, так сказать, преисполниться. В чем преимущество использовать
R-value референс перед L-value референсом? Что значит преимущество? Ну, как бы, всем выигранного
производительности. Если мы делаем там swap от R-value объектов или это L-value объектов. Так,
во-первых, объекты не бывают R-value и L-value. То есть, если мы делаем, что? Если мы делаем,
так опять, блин, ты задаешь какие-то… Тебе нужно вернуться к пункту 10.1 с самого начала, где я
рассказывал про мусемантику, и вспомнить примеры, из-за которых мы ее изобрели. Я в начале этой пары
очень коротко их повторил. Нам нужно было swap-ать объекты, push-back-ать вектор, перекладывать из одного
вектора в другой. Я спрашиваю, что именно происходит, что делает R-value более эффективным?
Что делает… Если у тебя есть две строки, и тебе нужно присвоить одну строку другой, или создать
одну строку из другой. Вот у тебя есть стринг. Стринг S равно S1, где S1 — другая строка. S1 — это
строка другая. В ней есть указатель на массив, размер и capacity. Этот указатель ведет на какой-то
длинный массив. Что бы делало стандартное конструирование? Оно бы создало такой же указатель,
size и capacity, и перевыделило бы этот массив, скопировав бы его по байтово. Что сделает move
конструирование? Оно сделает этот указатель таким же, как этот. Этот указатель будет указывать
сюда. Никакого нового массива мы строить не будем. Числа будут такими же, а этот указатель будет
nullptr, и числа занулины. И это работает в завод единицы, в отличие от стандартного конструирования,
копирующего, которое завод от N перекладывает, полностью глубокое копирование делает.
Оно просто забирает поля у того и зануляет ему. А не создает полноценную копию. Да, а move — это
функция, которая делает по сути каст, благодаря которому компилятор предпочитает эту версию,
а не эту. Вот, если вы вызываетесь… Помните, я вам вначале говорил, что для такого случая f от…
Ну, там был не совсем такой пример. Ну вот, если я говорю в вектор pushback вот такой string.
Да, pushback вот такой string. Вот, если вы помните, там был разговор, что здесь move избыточен.
Конечно, избыточен. Это и так R-value. Здесь не нужно говорить компилятору явно, что сделай,
пожалуйста, R-value, считай это R-value. Это и так R-value. Мы и так попадем в версию, которая вот для этого.
Если мы в вектор делаем pushback только что вот прямо в этом expression созданного объекта, то мы и так
попадем в версию, которая для R-value. Потому что у pushback на самом деле тоже две версии. У pushback
есть версия для R-value и для L. У pushback есть версия, которая принимает конс с t амперсант у вектора.
А есть версия, которая принимает t2 амперсанда. И чем они отличаются? Просто лишь тем и больше ничем,
что одна из них, когда делает placement new, делает t от этого x, а другая делает t от std move от этого x.
Потому что приняв что-то, как R-value ссылку, вы и дальше move-аете. Собственно, когда вы что-то
приняли, как R-value ссылку, вы понимаете, что если что, это можно дальше портить, отдавать, как будто это R-value.
Все проблемы по объективе инициации получается у конструктора t. Конструктор t? А, ну, конструктор и
оператор присваивания. Нет, вы можете и другие. Ну, я говорю, например, pushback по-разному реализован,
в зависимости от того, какой V-value он принимает. Вот это, конечно. A++ изменяет a на 1. Нет,
A++ изменяет значение переменной a на 1. Как отличает? Понимаешь, чтобы сделать A++,
тебе нужно взять ячейку памяти и записать в нее значение на 1 больше предыдущего. А чтобы сделать
move от V-value, вообще в runtime ничего не происходит. Во время исполнения происходит ничего буквально,
ровным счетом. Вот эта строчка ничего не значит для процесса. Кто заходит? Компилятор.
Компилятор генерирует задача компилятора сгенерировать ассемблер из C++ кода. Да, ну,
выкинет из ассемблерного кода, я имею в виду. То есть в ассемблерном коде как будто нет этой
строчки, потому что она ничего не делает. Она не транслируется ни во что. На самом деле это
сначала транслируется в так называемый Intermediate Representation общую для многих языков, а потом уже
в ассемблер, но это вам на втором курсе расскажут. Ну да, по сути move это просто штука,
которая, можно воспринимать это как подавление некоторых ошибок компиляции и все. То есть по
сути move это инструкция для компилятора, что с этой штукой можно выполнять те операции,
которые ты бы думал, что с ВВ нельзя. Так, окей, тем не менее у нас вообще-то еще есть целых аж,
еще аж целых несколько вещей, которые надо обсудить. Ну все стандартные объекты так себя ведут,
и любой пользователь от ваших объектов будет ожидать того же самого. Если вы сделаете иначе,
формально стандарт вы не нарушите, но вы рискуете получить пулю в лоб. Если нет чего,
дефолтного конструктора. Не знаю, для каждого типа решайте по-своему, я не могу вам общий рецепт дать.
Я думаю, что я бы хотел пойти дальше, ну давай быстро. Да, мы попадем в копий конструктор.
Кого? Кого генерирует? Прости, пожалуйста, но я не буду пересказывать, потому что в начале прошлой
пары я минут 15 рассказывал, как компилятор обрабатывает эти случаи. Компилятор не генерирует
move конструктор, если у вас есть нетривиальный копий конструктор. Мы про это подробно говорили
в начале прошлой пары. Вот, я уж наверное не буду повторять. Так, можно просто шепотом,
я не знаю, хотя бы. Так, еще одна вещь, которую надо сказать. Я напоминаю, у нас параграф 10-5 был,
R value референса с их свойства. Так вот, это все мы еще в нем. Так вот, у нас еще есть одна штука,
которую я здесь расскажу, это референс квалифаерс. Рев квалифаерс. Что такое квалифаерс, помните?
Ну это, ну это вот у вас была ошибка, что-то там дискарт с квалифаерс, когда вы константность
нарушаете. Да-да-да-да, мы прям здесь, ну это потому что тоже относится к свойствам ссылок,
отдельный параграф под это заводить как-то странно. У вас в классе может быть какая-нибудь версия F,
которая там выводит единицу, и версия F-константная, которая выводит двойку. Вот. И это
называется конст-квалифаер. То есть вот эта версия только для константных работает, а эта
для всех, в общем-то. Вот. Да, и когда вы говорите x.f, если у икса константный тип, то он, ну короче,
все понятно, не будут повторять, вы и так знаете, как работает. Не логично ли? Не напрашивается ли у вас
какая-нибудь идея еще одна? Сделать RLU-квалифаер. Смотрите, что можно делать, начиная с C++11. Можно
смотреть, что можно делать, начиная с C++11. Можно сказать void-f амперсант, а здесь два амперсанта.
Это не бред, это C++11. Структура же не может быть RLU. Структура не может, но expression-то может.
Вот если я вызываюсь у x, вот так, где x? Это s. Причем неважно, x был ссылкой на s, RLU ссылкой на s,
константный. Я попадаю сюда. А если я от std.move от x напишу точка f, то я попаду сюда. Или если я
сделаю вот так. Слушайте, кстати, я сделаю немножко шаг назад, я забыл вам сказать такую вещь.
Это же бред. Да не бред это. Что тебя смущает здесь? Мне кажется, это повод для багов. И эта версия
вызывается у LWL выражений, а это у RWL выражений. Вот и все. Точно так, ну ее можно комбинировать
с константностью. То есть вы можете написать, допустим void-f, конст амперсант. Амперсант
ставится, значит, в самом конце, вот здесь. Ну не в самом, перед try он еще ставится. И перед noexcept,
наверное. Вот, вот это версия для константных LWL, а вот это для RWL. Соответственно, вот эта версия
может быть вызвана от любого объекта, ну от любого expression, означающего данный объект. А это
только у RWL. То есть если вы сделаете std.move от x.f, когда это может быть полезно? Ну представьте,
что у вас в структуре S какие-нибудь данные лежат. Какая-нибудь строка, например. И ваш метод
возвращает эту строку. Ну возвращает данные из объекта, дает вам какие-нибудь данные из объекта.
Тогда имеет смысл сделать две версии. Одну, на случай, если объект LWL, тогда вы возвращаете
копию данных. А другую, на случай, если объект RWL, тогда вы просто move эти данные из полей.
Потому что это же RWL, это временный объект, значит, данные у него можно забрать.
Ну пусть у меня возвращаемый тип string и там и там. И у меня есть поле типа string. И здесь я говорю
return вот это string, это значит его копия создастся. А тут я скажу return std.move от этого string. Это
значит, я просто его опустошу и возвращу просто в... Да. Конечно. Const вызывает, ну,
константная версия, которая voidf const, вызывается от константных объектов, но они могут быть как RWL,
так и LWL. А const&% вызывается только от константных... А, да, да, я понял, да. Кажется,
что эта штука тоже от RWL должна вызываться. Да, похоже, что нет тогда. Потому что если вы напишите
const&% это будет и для RWL тоже работать. Там есть тонкость, то есть вот эта штука... Я на самом деле
не уверен, надо перепроверить, надо перечитать или протестить, но я сейчас не буду. Вот эта штука,
ну, если вы напишите ampersand без const, то вы только от LWL сможете вызываться. А если напишите
const&% то, по-моему, это работает по правилам обычных константных ссылок, то есть вы можете
вызываться как от RWL, так и от LWL, оно просто не явно скастется к const&%. Да, да, по сути так и есть. И вот
этот квалификатор, он, по сути, это то, по какой ссылке мы хотим принять наш объект with.
Думаю, нет. Я думаю, что это мышление обманывает в строго меньшем под множество случаев,
чем стандартное. Ну, то есть оно наоборот проясняет многие. Ну, оно вложено. Нет,
это мышление обманывает в меньшем количестве случаев, чем предыдущее мышление. Нет, нет, нет. Ваше
мышление стандартное обманывает вас в некотором под множество случаев, а это мышление не обманывает
в некоторых из старых случаев, но, возможно, продолжает обманывать в каких-то новых, в каких-то других
случаях. Повторяю мышление. Когда вы вызываете x.f, это на самом деле как будто вы вызываете метод
s.f с параметром первым x и дальше с другими параметрами. Ну, просто этот метод, он как бы
неявным аргументом принимает, ну, как в питоне, он как будто неявным аргументом принимает ваш x,
и этот квалификатор на самом деле просто говорит, по какой ссылке x он хочет принять. И это объясняет,
что вот по этой ссылке вы только std moved x можете отдать или вы можете дать временно созданный.
Что в локаторах? Нет, в локатор trades, локатор trades метод статический, а это метод нестатический.
Так, окей, референс-квалифаеры. Понятно ли, зачем могут быть нужны референс-квалифаеры?
Сдохнуть? Что такое R-value конструктор, я не понимаю вообще. Нет, во-первых, амперсант,
буква D на конце, правильно говорите амперсант, да. А во-вторых, нет, конечно, для конструкторов это
бессмысленно. Вы и квалификаторы для конструкторов не можете писать, вы и конст не можете писать.
Это правда. Так, нам осталось прояснить что. Ах да, я забыл сказать, как раз вы меня отвлекли
вопросами, я забыл сказать еще одну важную мысль про R-value ссылки. Послушайте, пожалуйста,
важную мысль про R-value ссылки. Возможно, это третья по важности мысль про R-value ссылки,
которую я скажу в принципе. Первые две вы должны уже знать. Третья мысль про R-value ссылки,
которая объясняет оставшееся их поведение, это что они реально, как и обычные ссылки,
неотличимы от объектов, на которые они ссылаются. Вот вы мне говорите, вот помните у нас был
пример, int двойной амперсант x равно чему-то там, а потом f от x, и мы внезапно попадаем в версию
для L-value, а не для R-value. Да потому что ссылка это полноценное имя объекта, не должно быть
разницы, через какую ссылку мы обращаемся к объекту. Вот это вот правило, оно согласуется
с интуицией, что ссылка, она неотличима от объекта. Если бы у вас в зависимости от того,
какая это ссылка, вы попадали то туда, то туда, то это получалось бы, что у вас x это какое-то
неполноценное имя объекта, оно как-то его по-особенному называет, так что вы попадаете в другую версию. Нет,
так не работает со ссылками с любыми. Любая ссылка неотличима от исходного объекта. И
разница R-value ссылок с обычными только в том, что инициализироваться они могут R-value,
ну и move-ать, если вы move-ать и получаете R-value. Но это уже полноценное имя объекта и ведет на себя
как L-value. Поэтому если вы в версию какой-то функции приняли R-value ссылку и хотите дальше ее отдать
как R-value, вам нужно move опять делать от нее, потому что она полноценное неотличимое имя объекта. Но
благодаря тому, что вы приняли ее как R-value ссылку, вы как раз и знаете, что move над ней можно
сделать, и это легально, потому что вам ее отдали в предположении, что вы будете с ней как с R-value
обращаться. Имя объекта уже само по себе является L-value. Ну x, да, это L-value, конечно. Вот, ну раз уж у нас
немножечко такой порядок изложения запутан, я вам говорил в первом семестре, что ссылка это
неотличимая от объекта. Ну, короче, ссылка никак неотличима от объекта, кроме одного случая,
который мы пока умолчим. Кроме какого случая? Вот если вы внимательно слушали Федину пару в
прошлый раз, вы должны уже знать какого. Нет, decal type. Вот decal type это та единственная конструкция
в языках C++11, которая позволяет вам отличить, настоящий это объект был или ссылка. Потому что
если вы пишете decal type от x, decal type от x y равно x, например, вот я так напишу, это будет CE, ошибка
компиляции. Вот это ошибка компиляции. Почему? Потому что это им два амперсанда. Decal type помнит
какой тип формально на самом деле. И вы написали как будто бы им два амперсанда, y равно x. CE,
потому что нельзя инициализировать R-value ссылку через L-value. Понятный пример? Вот этот вот
пример. А вот если писать decal type от x, y равно sdmove от x, окей, все. Два амперсанда. CE, конечно.
Естественно, это самый базовый пример, который, помните, про R-value ссылки, который мы забрали в
прошлый раз. Так, господа, у нас, что? Когда нам нужен decal type с двойными скобочками? Просто на
практике не очень понятно. Никогда, просто скорее, если вы так напишете, то у вас будет дополнительный
амперсант. Почему decal type? Просто для логирования. Давайте не сейчас, пожалуйста, можно после пары,
но мы сейчас не успеем оставшуюся часть. Нам нужно с вами, у нас с вами осталась одна нерешенная
проблема. Помните какая? Почему move так странно реализован? Почему он принимает и возвращает такие
странные типы? Move принимает, напоминаю, t двойной амперсант, а возвращает remove референса t
двойной амперсант. Почему? Да, самый главный вопрос, почему, какого черта move принимает t
два амперсанда, если он, если весь его смысл в том, чтобы скастить к двум амперсантам, почему он
принимает t два амперсанда? Это главный вопрос, на который нам осталось ответить. И вот если мы
успеем на него сегодня ответить, то мы, ну не совсем, конечно, молодцы, но почти молодцы. Хотелось бы
еще кое-что успеть, ну да ладно. Ну может Федю чуть-чуть задержу, ладно. А для того, чтобы ответить на этот
вопрос, нам нужно с вами пройти еще одну штуку, которая называется проблема perfect forwarding и
универсальные ссылки. Это то, о чем Федя заикался вчера, в прошлый раз, но не, ну он вам, так сказать,
дал некоторые намеки. Ну давайте, я сейчас напишу, так, какой маркер из этих нормальный,
вот этот. Значит, пункт 10.6 будет называться, нет, это плохой маркер, perfect forwarding и,
ну их можно называть forwarding references, а можно называть universal references. Давайте
будем говорить universal references. А забыли про проблему, ну мы сейчас исследуем некоторую другую
проблему, которая не связана с мувом, никак, почти, ну отдаленно связана с мувом, но поняв ее,
мы поймем, почему мув так реализован. Вообще, на самом деле, я мув мог бы реализовать, просто
приняв туда t&, и это было бы почти всегда правильно. Вот я могу в мув отдать t&, я вам написал реализацию,
которая, я напоминаю, я не буду писать заново, потому что это долго, template tape name t, возвращаемый тип это std
remove reference от t, и на это наверно 2&, а принимаемый тип t 2&, и вопрос, почему, черт возьми,
2& принимаемый тип. Я мог бы принять 1& вместо 2&, и это бы работало почти всегда правильно,
это бы работало неправильно, когда, вот кто понимает, в каком случае, когда в мув мы и так отдали rvalue,
а такое вообще могло бы быть, потому что в мув мы могли бы случайно отдать rvalue, ввиду того,
что какая-нибудь функция вернула нам rvalue, и мы отдаем его в мув, желая, чтобы оно по-любому
стало rvalue на выходе. Вот, и тогда это просто не компилировалось бы, если мы в мув бы принимали
такую ссылку, то случайно отдав в мув, и так rvalue, мы получили ce. Нам нужна такая реализация мув,
которая принимает irvalue, но можно перегрузить две разных, а тем не менее, вот я утверждаю,
что оказывается достаточно просто написать мув от t 2& и все, это будет универсальная,
она так называется, универсальная ссылка. Пока еще непонятно, сейчас я эту проблему
проиллюстрировал на более прикладном примере. Смотрите, вот у нас есть функция pushback,
которая, ну на самом деле даже не так, у нас есть в векторе такая функция emplaceback, знаете такой
метод. Вот мы с вами, кажется, его не обсуждали, но вообще-то у нас есть в векторе такой метод
emplaceback, который принимает много аргументов, то есть что такое emplaceback, это вы создаете объект,
кто знает, что такое emplaceback, чем от pushback отличается. Давайте расскажу, у вас допустим вектор строк,
и я говорю v.emplaceback, там не знаю, 5 запятая а в одинарных кавычках, что я сделал, я в этот
вектор положил строку длины 5, стоящую символов a, я не пишу здесь std string от 5 запятая а, emplaceback
позволяет мне непосредственно в памяти, которая принадлежит вектору, сразу сконструировать стринг
от нужных аргументов, а не создавать временный промежуточный стринг, который, ну я потом мувать
буду или копировать буду, emplaceback позволяет мне сделать еще эффективнее, не создавать вообще
промежуточный стринг, а сразу создать стринг от нужных аргументов на нужном месте, понятно?
Вот, вот, у emplaceback сигнатура, ну ему нужно переменное количество шаблонных аргументов
принять, template, typename, t, вот, emplaceback, и вот тут, typename многоточие args, и вот тут возникает
вопрос, а как их принять-то? По какой ссылке? Ну, мы бы написали const args ampersand многоточие args,
да, у нас есть пока мы только один способ знаем принять все что угодно, не копируя, у нас был
другой пример на самом деле, ситуация, когда нам нужно было принять переменное количество шаблонных
аргументов, каждый из которых мог быть как rvl и так и lvl, в чем проблема? У нас может быть каждый
из аргументов по отдельности как rvl так и lvl, часть этих может быть rvl, а часть lvl, и вообще говоря
мы не знаем, кто кем будет, у нас была и другая проблема, мы, кто вспомнит тот молодец, какая у нас
была функция еще одна, вот с такой же почти сигнатуры, где был typename args, и мы написали
const args ampersand, потому что другого способа у нас не было, у нас была allocator construct функция,
когда мы говорим allocator construct от аргументов конструктора, мы там тоже должны принять
переменное количество шаблонных аргументов и отдать их в placement new, но каждый из этих аргументов,
мы-то теперь знаем, что это все не так-то просто, у нас аргументы могут быть как rvl и так и lvl,
и если у нас allocator construct будет написан так, как он раньше был написан нами, то у нас никому
в семантике ничего нам не даст, потому что мы все равно будем копировать все аргументы, вы понимаете,
что при нашей реализации allocator, которая была до этого construct, мы будем копировать, потому что
мы даже если приняли эти аргументы в pushback или в emplaceback как rvalue, в construct они будут
отданы опять как lvalue, потому что по константной ссылке приняты и никакого move мы не сможем
сделать с ними, когда мы их отдадим наконец в placement new, мы опять их скопируем, понимаете,
вот когда мы сделаем pushback от std move от чего-то, мы примем его по t двойному амперсанду и дальше
отдадим в construct, alloc.construct на месте ptr от этого x, который мы приняли, ну от std move от x,
который мы приняли, потому что мы rvalue и дальше его move, но сюда-то он придет по константной ссылке
опять, потому что у нас нет версии для rvalue здесь, на этом этапе, ну точнее в construct у нас нет
версии для rvalue, и значит в placement new дальше он пойдет опять как lvalue, и значит мы его все-таки
скопируем, как же нам решить проблему с тем, что мы имея какой-то объект, правильно передаем его
дальше, независимо от того является он lvalue или rvalue, был он нам дан как lvalue или rvalue изначально,
в частности как мы это делаем, когда у нас переменное количество шаблонных аргументов,
если бы у нас был всего один шаблонный аргумент, мы могли написать перегрузку,
одну для конст него амперсант, другую для него с двумя амперсантами и просто ходили бы то туда,
то сюда в этот констракт, но у нас переменное количество шаблонных аргументов и половина из них
может быть rvalue, половина lvalue, и тогда те из них, которые rvalue надо move-нуть при отдаче в new,
placement new, а те, которые lvalue move-ать нельзя, что же делать, ну комитет думал-думал и понял,
что надо делать костыль, совершенно верно, ничего тут не попишешь, потому что у нас нету,
не хватает синтаксиса, чтобы выразить эту идею, нам нужен костыль, именно костыль, иначе это никак
не могу назвать, нам нужен костыль, чтобы нам нужен специальный синтаксис, который бы позволял
принимать как rvalue, так и lvalue, и как-то приняв их различать, что было реально передано,
lvalue или rvalue, и они придумали этот костыль, он называется universal references или forwarding
references, вот эта вот штука forwarding references, она же universal references, решает именно эту
проблему, и на самом деле мы пишем не const args ampersand здесь, а мы пишем args двойной ampersand,
как выглядит на самом деле сигнатура функции construct, она выглядит так, значит void construct,
ну вот там t звёздочка ptr, ну тут еще t, и дальше args двойной ampersand многоточие args,
вот это костыль, здесь мы используем двойной ampersand, несмотря на то, что можем принять как
rvalue, так и lvalue, как же это чёрт возьми работает, ведь мы же договаривались с вами, что rvalue,
что когда мы два амперсанда принимаем, это только rvalue может быть пронициализировано,
понимаете, это не согласуется с тем, что я говорил раньше, как будто бы я говорил одно,
а написал другое, мы же договаривались, что двойной амперсанд может принимать только rvalue,
нет, это работает по-другому, это работает вот так, но есть исключение из правил,
которое является костылем, не в множественных параметрах дела, а дело в том, что если это два
амперсанда, которые навешаны на шаблонный параметр, который является шаблонным параметром
этой самой функции, в которой мы объявляем, то правила другие, значит исключение из правил
значит так, по ссылке с двумя амперсандами можно принимать только rvalue, за исключением
случая, когда эта ссылка шаблонный параметр функции, которую мы и определяем, может быть,
если это шаблонный параметр вот той самой функции, которую мы сейчас определяем, если это не шаблон
параметров всего класса, вот например, если бы я здесь, тут нету type name t, так, потому что это
и для и для одиночных параметров нужно, тебе бывает нужно какую-то функцию написать универсально,
это как для move, например, тебе нужно принять в нее и rvalue и lvalue и одинаково обработать,
ну это копипастить код всегда бы пришлось, да, именно move подпадает под это исключение, в move
принимается t, который является его собственным шаблонным параметром и поэтому два амперсанды
на t ведут себя иначе, чем два амперсанды во всех предыдущих случаях, а шаблонная функция,
которая принимает только rvalue, а можно написать статик assert на то, что это rvalue и я покажу вам,
как это сделать, нет, я сейчас вам покажу, как это сделать, короче, ты потерпи 10 минут,
пожалуйста, сейчас мы дойдем до этого и ты поймешь, короче, исключение с правил такое,
если у вас это исключение не работает, вот, вот если бы я здесь написал t двойной амперсант,
это бы не работало, это бы принимало только rvalue, потому что это t не является шаблонным
параметром констракта, оно является шаблонным параметром всего класса, аналогично, когда мы
пишем pushback от t двух амперсандов, вот внимание, у нас есть две версии pushback теперь, pushback от
const t амперсант и pushback от t два амперсанда, вот этот pushback, который от t два амперсанда,
это не исключение, это не универсальная ссылка, это rvalue ссылка, потому что эти t два амперсанда,
там t не от pushback, а от самого вектора, а если у вас это шаблонный параметр не функции, а самого
класса, откуда функция или чего-то внешнего, то это не попадает под исключение из правил, только
если это тип, шаблонный параметр того с той самой функции, которую мы определяем, это исключение
из правил, и при этом не разрешено писать ни const, никакие бы еще это ни было украшатели на этот
тип, то есть вот если я например здесь напишу const args два амперсанда, это уже не исключение из правил,
const args два амперсанда это только rvalue, это не универсальная ссылка, если я напишу допустим,
не знаю, vector от args и два амперсанда, это тоже не исключение из правил, это тоже rvalue ссылка,
а не универсальная ссылка, универсальные ссылки прям захардкожно, это костыль, они имеют строго
вот такой вид t, где t шаблонный параметр и функции и два амперсанда и все, если вы что угодно еще
навесите, будет не универсальная ссылка, точно также работает это и с авто, вот вспомните,
что вам Федя говорил на прошлой паре и проассоциируйте это с тем, что я вам сейчас
сказал, когда у вас есть авто в принимаемых параметрах или когда вы говорите авто два
амперсанда x равно чета, авто два амперсанда ведет себя также, как если бы это была шаблонная
штука с template.title.net и два амперсанда, то есть как универсальная ссылка, авто два амперсанда
тоже подчиняется этому исключению из правил, вот, в частности, например, если вы там написали,
а ну ладно, сейчас я вам расскажу в чем исключение, значит по такой ссылке можно понимать как rvalue,
так и lvalue, а теперь вопрос, а хорошо приняли мы его, а как нам дальше понять, оно является rvalue
или lvalue, то есть оно как переменная, конечно, является lvalue, оно было принято как rvalue или как lvalue,
как нам понять, то есть как нам теперь реализовать констракт, вот мы сейчас пишем констракт и
нам нужно написать placement new от ptr, t от, ну args многоточие сюда надо отдать, но что написать-то
надо, мы если мы напишем просто args многоточие, то это будет lvalue, определение lvalue никто не
отменял, args это по-прежнему lvalue, никакое оно не rvalue, это имя переменной, ну многоточие,
распакованный пакет, если мы так напишем, это будет опять копирование, мы ничего не добились,
если мы напишем sdmove от args, мы мувнем все аргументы, и те которые были lvalue изначально,
и те которые были rvalue изначально, потому что move он все кастует к rvalue, нам нужна какая-то еще
одна функция специальная, магическая, которая, которая что? Это lvalue все, args это lvalue,
мы не напишем перегрузку для move, мы напишем другую функцию, называется stdforward, которая как
раз вот эту ситуацию решает, мы вызываем сейчас stdforward с шаблонным параметром args от args,
и она так устроена, что если изначально args был принят как rvalue, то она его мувнет, а иначе не
мувнет и вернет lvalue ссылку, откуда forward узнает надо move или нет, а из шаблонного параметра,
просто правила вывода типа в этом случае другие, помните вам Федя в прошлый раз говорил, что если
вы приняли вот по такой ссылке и приняли вы lvalue, то args будет с одним персандом на самом деле,
а это как раз для того, чтобы вы по типу того, чем является args, могли понять оно как lvalue или
как rvalue вам пришло. Значит, я сейчас пишу следующее заклинание, t от stdforward,
stdforward с шаблонным параметром args от args, многоточие, и это волшебная функция номер два,
которая глядя на этот тип, либо move, либо не move свой аргумент, ну то есть либо возвращает
lvalue ссылку на аргумент, либо возвращает rvalue ссылку на аргумент. Как она понимает это? Она
понимает это потому, если амперсанд на этом типе. Если на этом типе есть одиночные амперсанд,
то она вернёт одиночные амперсанд ссылку на этот тип. Если на этом типе нету одиночного
амперсанда, то есть если это либо 0 амперсандов либо 2, то она вернёт ссылку с 2
амперсандами на этот тип. Таким образом, благодаря правилам вывода шаблонного типа,
которые навешивают амперсанд искусственно, если это было принято как L-value, вы получите L-value
на выходе в том и только том случае, если изначально вам отдали как L-value. Это называется perfect
forwarding, идеальная передача. Сейчас я реализую forward. Конечно же, вы думали, вы избежите этого?
Да, по сути forward просто casted karx, это правда. Да, по сути да. Давайте реализуем forward сразу.
Это что, кринш? В смысле, почему? Что-то никогда шаблонную функцию от аргументов не вызывал?
Как это не похоже? Многоточие это распаковка пакета, пакетом является все это. Мы с вами
fold expression написали вообще. Да, да. Что? Во-первых, forward работает от одного элемента. Да, конечно.
Это многоточие, оно через запятую повторяет SD forward от всего подряд. То есть move всегда
превращает в R-value, не зависимо от того, чего он делает. Да. Forward это условный cast karx value,
move это безусловный cast karx value. Что вы ему не дали, на выходе получите R-value, ссылку на это.
Forward это такой cast karx value, что если вы ему дали вот с этим шаблонным параметром с
амперсандом, вы получите R-value, ссылку. А если дали шаблонный параметр без амперсандов или с
двумя, то получите R-value, ссылку. А давайте сейчас мы реализуем и поймем, как он поймет. Сейчас мы
реализуем forward просто. Ну в этом же пункте я просто реализую forward. Какие еще вопросы были?
Хорошо, а template type name T.
да нет нет нет не только множественных у тебя move пример функции которые нужно
принимать как rvalue так и lvalue вот move это банальнейший пример но можно придумать и другие примеры можно
придумать функцию которая делает что-то длинное и дальше передает этот смысл названия perfect
forwarding в чем почему оно perfect perfect forwarding в смысле передать ну пересылка да идеальная
пересылка вы приняли объект какое-то value и отдали его дальше сохранив вид value вот что вам
что такое perfect forwarding perfect forwarding это о том как принять объект и отдать его дальше в том же
виде value в котором вы его приняли это не обязательно только для множественных
аргументов нужно это может быть много для чего нужно мы не храним в том-то и дело сам объект
сама переменная это всегда lvalue да причем забудь про пакет блин все нет многоточия здесь один
аргумент у тебя у тебя есть переменная она всегда lvalue да за счет того что шаблонный параметр
выведется по-другому если это было lvalue я тебе говорю и федя прошлый раз про это говорил если
у вас вот такая сигнатура функции и вы передали lvalue то arc станет равен типу с навешенным
искусственно одиночным персандом если вы вызвались это у вас пример был в прошлый раз
если вы вот у меня был int x и я вызвался от x а функция у меня была шаблонная которая принимала
t двойной амперсанд если я так сделаю то t будет равен int амперсанд да и значит передав forward
этот arc ну то есть этот t мы будем видеть что нас вызвали шаблонным аргументом т с амперсандом
а значит мы вернем t амперсанд и по сути что надо сделать реализации формат это просто
проверить наш шаблонный аргумент он сам персандом с одиночным или нет и если да то не делать
муфа если да то сделать наоборот да да причем тут пакет вообще ничего не меняет конечно может
для каждого аркс выведется свой тип многоточие это просто синтеп просто банально как если бы
через запятую написал template arc 1 type name arc 1 запятая type name arc 2 запятая type name arc n
arc 1 2 амперсанды arc 1 arc 2 амперсанды arc 1 и так далее arc n arc n это просто повторение
через запятую всего этого для всех типов для каждого конечно же выводится независимо
конец многоточие здесь стоит многоточь вот это все через запятую повторяется для
всех аркс из пакета для каждого арка отдельно выводится все это просто пакет fold expression это
если поменять это все было соединено каким-то бинарным оператором например или и тут еще многоточие
стояло это не fold expression это просто распаковка пакета стандартная c++ 11 fold expression появились
только c++ 17 это штука c++ 11 да чего ничего чего ничего а реализуем форвард давайте реализуем
форвард хотя бы сегодня я обещал федя что вы будете знать как работает форвард когда он придет
поэтому нам надо поторопиться что пора в принципе дает того что я ему дом войти я не обещал так
какой превозвращаемый тип должен быть вообще короче не знаю упражнения на даже не знаю на что
придумайте как должен быть реализован форвард что должен он принимать и что должен возвращать
хорошо молодец я не расслышал просто нам нужна нам нужно разное проведение в зависимости от
того вот это те которые нам пришло как шаблонный аргумент оно с амперсандом или без
значит смотрите давайте он сначала напишу неправильную реализацию форвард неправильная
реализация форвард давайте возвращать т2 амперсанды и принимать т2 амперсандо
нет значит тем не менее это довольно не тривиальный вопрос почему это будет
неправильно работать оно принимает как смотрите я вас сейчас кручу верчу запутать хочу я принимаю
сюда как рвл так и лвл что мне и нужно и возвращаю как рвл так и лвл что мне и нужно причем если
было лвл то здесь будет один амперсанд и я верну один амперсанд потому что по правилам
склопывания ссылок я напомню вернется т с одним амперсандом здесь было рвл то здесь же не
будет т ну ты ты же у меня без амперсандов будет если там было рвл так еще раз мне нужно из
форварда возвращать т амперсанд или т2 амперсанда смотря был ли исходит и т с амперсандом или без
если ты был сам banned то когда его приму сюда он и будет сам бжан сильно что один амперсант
плюс два пасана это один амперсанд значит это будет тем персант и я сделаю каст к т амперсанд
и вер transitioning и здесь здесь будет по одному амперсанду и вернутьordum если ты был с двумя
амперсандами или без амперсандов вообще, то здесь будет 2 амперсанды, здесь 2 амперсанды,
здесь 2 амперсанды, и я верну 2 амперсанды. Вопрос, почему это неправильно работает?
Чего?
Это неправильно работает, потому что нужно сделать вашу блоговую параметру, потому что этот t просто заново выведет.
Нет, нет, нет, нет. Я явно передаю сюда t.
Так это же l value, разве нет?
Кто l value?
Перемены, которые вы передаете.
Аркс, да. Нет, если я явно передаю, подождите, если, подождите, если я явно передаю функцию шаблонный параметр, то я, конечно же, побеждаю правила вывода.
Ну, я явно говорю, с каким шаблонным параметром я вызываюсь.
Ну окей, смотрите, вот, аркс это t2 амперсанды, когда у нас аргумент функции это...
Подожди, аркс вот здесь?
Да, ну пусть это, пусть аркс, ну да, пусть передаваем it правильным, это какая-то...
Стринг, давайте говорить стринг, стринг 2 амперсанды.
Стринг 2 амперсанды, то аргументу функции это тоже стринг 2 амперсанды, мы туда передаем l value.
Да, это правильно, это правильный ответ, почему это не будет правильно работать.
Ничего не возможно.
Значит, это просто не будет компилироваться в случае, когда у нас на самом деле было l value здесь.
Потому что мы принимаем стринг 2 амперсанды, ну вот представьте, что мы разбираем случай как...
Если у нас случай с одним амперсандом, все нормально, если мы разбираем случай с двумя амперсандами, то у нас будет CE.
Почему? Потому что тип аркс, он без амперсандов на самом деле, ну, аркс 2 амперсанды, это стринг 2 амперсанды.
Просто аркс, это просто стринг, мы вызываем SD forward от стринг шаблонного параметра, от аркс.
Аркс это l value, здесь тип оказывается стринг 2 амперсанды, и мы принимаем l value.
Так это же CE, мы не можем от l value вызваться по l value ссылке.
Это в параметре написано, это remove, reference.
Точно! Именно поэтому в параметре forward нужно принимать не T2 амперсанды, а наоборот SD remover reference, а T.
Значит, когда мы реализуем move, мы принимаем T2 амперсанды, а возвращаем SD remover reference, а в forward мы наоборот делаем.
Амперсанды, да, во-первых, хорошо, ладно, ну я на всякий случай, я просто не расслышал.
Смотрите, еще раз, предположим, что тут написано T2 амперсанды X.
Это на самом деле вопрос, который, ну, я не знаю, это, ну, ну нет, это вопрос не на ОТО, скорее, ну, вы про 2, для вас это будет вопрос на HOR 7 где-то.
Почему такая реализация forward неправильная? Это не очевидно, вот это вопрос на понимание, почему так нельзя.
Почему нельзя принять T2 амперсанды и вернуть T2 амперсанды?
Казалось бы, я для случая, когда l value у меня здесь будет 1 амперсант, здесь будет 1 амперсант, здесь 1 амперсант.
Я принял l value и вернул тип с 1 амперсандом, что и нужно.
Но проблема, когда я принимаю, подожди, проблема в том, что я, если мне здесь дали r value, оно превратилось в l value, args теперь l value.
А тип у него string 2 амперсанды, args равно string.
Значит, я вызываю std forward с параметром string от args, где args l value.
И приходя сюда, я получаю тип шаблонного параметра string с 2 амперсандами.
А принял я l value.
То есть я пытаюсь string 2 амперсанды проинтересировать через l value. Это ошибка компиляции.
Какое исключение? Я явно сказал, какое T я подставляю.
Я forward'у явно говорю, какое T я подставляю.
Если я forward'у явно не буду давать шаблонный параметр, это просто CE.
Потому что это идея не может работать, потому что forward'у нужно явно передавать шаблонный параметр, чтобы он знал, как ему себя вести.
Мне нужно сохранить для forward'а вот этот шаблонный параметр.
Я явно подставляю сюда шаблонный параметр, и здесь образуется string с 2 амперсандами.
T равно string 2 амперсандами.
T 2 амперсанды равно string 2 амперсанды.
Тогда я по l value ссылке пытаюсь проинтересировать l value.
Это CE. Чего?
У нас все перестает работать, потому что не работает l value дальше.
Здесь я делаю явный подставок шаблонного параметра, поэтому T 2 амперсанды работает не по тем правилам, по которым надо.
Не по тем правилам, по которым работает универсальная ссылка.
И это универсальная ссылка.
Но я явно говорю, с каким типом я вызываюсь, и поэтому правила типов не работают вообще.
Если я явно говорю функции, с каким T я ее вызываю, то никаких правил вывода типов не применяются, используя тот T, который я дал.
Да.
Что такое forward от 1? С каким шаблонным параметром?
Forward с шаблонным параметром int от 1.
Можно.
Подожди.
Подожди, пожалуйста. У forward есть вторая перегрузка.
Мы не полностью пока forward реализовали.
А как раз для таких случаев, как вот такие вот умненькие ребята, значит, предлагают, есть все, комитет предусмотрел.
Значит, смотрите, комитет все предусмотрел.
Поэтому я принимаю не T 2 амперсанды, а standard move reference от T с одним амперсандом.
С одним амперсандом, а не с двумя.
Потому что если я буду принимать его с двумя, я проблему свою не переборю, я буду по-прежнему R-value.
Я снимаю все амперсанды с T и навешиваю одиночный амперсанд.
А почему без cons?
Как бы вы пойдешь в 3?
И от remove reference.
Почему такое тимисочение?
Ааа… Чего? Какое? Подожди.
T это тип. Remove reference это метафункция.
Короче, чтобы тип минимального значения был con, a и вот так.
Remove reference это метафункция, она и так от T снимает.
Она с T просто снимает амперсанды, а cons, если был, он там останется.
вот и возвращай вот это и это правильно работает в обоих случаях если это был т
амперсант мы с двумя персантами если мы приняли строку как рвл и сюда аркс это стринг мы с
шаблонным параметром стринг вызываемся от лвл и стринга попадаем сюда здесь этот тип превращается
в стринг 1 амперсант нет тип иногда бывает стринг с амперсантом а зачем рему в референс это
отличный вопрос правильно почему бы не понимать да почему во классно вопрос номер два да да да
отлично я забыл о давай заходи вопрос номер два почему почему нельзя так написать сейчас мы увидишь
тут разбираем интересные случаи мне кажется свет можно включить уже весь значит окей с двумя
персантами мы поняли что так нельзя а почему с одним амперсантом нельзя
подожди нам и не нужен вывод типа для форвардом мы ему явно передаем шаблонный аргумент
в каком случае реализация вот с ты одиночным персантом будет работать неверно это более
сложный вопрос чем предыдущий когда мы перейдем рвл ию а когда и зачем мы можем передать
форвард рвл но подождите ведь тогда и такая реализация тоже не будет работать
да нам не старая перегрузка короче давайте я не буду не буду ждать вы потом как бы те видос
пересматривать вы может осознайте есть две причины почему так не надо делать одна менее
веская вторая более веская сначала начну с менее хотя кому как начну с менее веской причины если
я буду принимать т амперсант просто как и т2 амперсанта в принципе то форвард будет работать
и без явного указания шаблонного параметра а это значит что если я случайно забуду указать
шаблонный параметр это не будет ошибкой компиляции и сделается все время версия которая мне не нужна
может быть вот то что я принимаю такой тип лишает компилятор возможности самостоятельно вывести
шаблонный параметр и мне необходимо явно его указывать всякий раз при вызове форварда если бы
форвард принимал вот это то он бы автоматически выдел шаблонный параметр я бы мог просто забыть
его указать и тем самым получил бы не ту версию которая мне нужна это не было бы никакой не
ошибка ни в орнинг а это это первая причина менее веская ну или более вескому нравится вторая
причина я могу вообще говоря форвард как ему вызвать от результата вызвать чего-нибудь другого
но вот у меня есть какая-нибудь функция ты которая который я результат который хочу
форварднуть если она мне вернула лвл и ссылку я хочу значит ее и дальше как лвл и передать а
если вернула рвл это я хочу и дальше как рвл и передать я хочу вот эту штуку сделать либо
рвл и либо лвл и в зависимости от того что было тут сейчас это какой-то дурацкий пример потому
что оно и так оно и так правильно сработает сейчас подождите подождите подождите значит нужно
посложнее пример давайте подумаю какой пример когда я могу получить а подождите сейчас сейчас
блин что-то забыл пример слушать шаблонная функция есть шаблонная функция f которая
сама что-то возвращает и ее результат я хочу форварднуть
да я явно указывают т
а так правильно смотрите эта функция она может случайно вернуть мне lвл вот я нахожусь в каком
нибудь в какой-нибудь шаблонной функции в которую принял x и допустим я здесь хочу делать не от
аркс вызов а от еще чего-нибудь от аркс например от f от аркс но я хочу делать форвард не с тем не
в зависимости от чем мне это f вернуло в зависимости от что здесь было понимаете то есть у меня может
быть функция какая-то вызвана вызвана от этих аргументов которая тоже иногда мне дает рвл иногда
lвл но я хочу дальше форвардить эту штуку в зависимости от того вот здесь она была рвл или
лвл может быть такая ситуация что я сюда принял эту штуку как лвл нет не так я сюда принял эту
штуку как рвл это функция вернула мне лвл но я все равно хочу ее форварднуть как рвл потому что
здесь на этой уровне я знаю что она рвл поэтому иногда мне бывает вот а может быть другая ситуация
эта штука мне была рвл и f мне вернула рвл и я форварднуть я хочу как рвл но то есть иногда
бывают сценарии в которых мне все-таки нужно вызывать форвард от рвл поэтому только лишь
такой перегрузкой я не обойдусь и мне нужна вторая перегрузка вторая перегрузка отличается от
этой ничем кроме того что статик ассерт написан значит вторая перегрузка выглядит так ты двойной
персант форвард что-то у федя какой-то взгляд как будто ему самому страшно вторая перегрузка
выглядит так ты двойной персант форвард от всего того же самого с двумя амперсантами и она делает
то же самое но только здесь изначально написан статик ассерт что ты не лвл ю референс потому
что если мы пытаемся форвардить то что здесь было лвл ю референсом а мы хотим его как рвл ю
трактовать то это неправильное использование форварда и мы ци кидаем в этом случае кто не пройдет в эту
версию если f вернула мне рвл ю ф меня вернула рвл ю и здесь было принято как рвл ю я хочу
форварднуть как рвл ю тогда вот на тот случай мне как раз нужна вторая версия как раз то что
сказал f форвард от инт от одного если у меня была ситуация что мне здесь приняли что мне здесь
дали лвл ю а это f почему-то вернула мне рвл ю и я хочу его как рв а в смысле ци будет сейчас
наоборот наоборот наоборот здесь было лвл ю а здесь рвл ю и я хочу в эту версию я хочу
форварднуть его как лв как наоборот блин я все перепутал я хочу как рв я что хочу я хочу
нарушить вид вл я хочу форварднуть как рв то что не было рв вот я хочу вот вот это было
лв вот это стало рв и я хочу форварднуть его как лв и это значит что я попадаю во вторую версию
ст с одиночным аперсаном и вот так не должно быть и форрот мне должен ци кинуть в этом случае
это зависит от того чему равно аркс еще раз сценарий сюда я принял это как лв но
по какой-то причине ввиду того что я не аккуратно здесь что сделал вернулась
рв и изначально которое было лв вернулась как рв тогда я пытаясь отдать его форвард с
параметром с лв должен получить ци потому что форвард не скажет чувак ты нарушаешь тебе
далее лв ты не должен передавать дальше как рв ты должен и дальше передавать как лв статика
что вот этот тип это лв референс вот этот тип лв референс ну например так можно писать все
на сегодня давайте так собственно сегодня вопросы про тайп на им и тайпов не принимаются потому
что я вам скидывал как те функции реализован кто хотел посмотрел я считаю и
ну хорошо смотрите у меня есть 4 функции которые делают типа одно и то же принимают x возвращают
x вот ну казалось бы все должно быть очень просто смотрите у меня есть вектор из стабулов
давайте попробуем угадать какой тип возвращает функции ну сначала какой типу вектора давайте
вектор был да класс вы еще здесь а у этого какой тип вектор был все верно что такое больше
я не знаю как отвечать на этого ну смысле формально это функции ну оператор не странно
сейчас в чем вопрос еще раз значит ребят но я считаю что вы должны знать что такое шаблонные
аргументы если что это были шаблонные аргументы они передаются через угловые скобочки так же
известный как больше меньше так как как как же вас кокнуло то ну хорошо давайте так если дому
вектора что вернется два амперсанды три амперсанды кто больше ну сколько два или
а вот кто один почему один а почему один амперсанд откуда взялся это правда но откуда взялся
1 скобочки это expression ну в общем я утверждаю что вы не правы так хорошо так а вот этого какой
тип ну просто вызываем создаем вектор спрашиваем какой давайте вот помните у нас
есть два вида дикол тайпа вот в какой вид из дикол тайпов мы пойдем в обычный что делает
обычный ну да смысл когда мы попадаем в обычный тип когда мы просто называем объект да но тут
мы не называем объект мы создаем новый объект это expression я считаю это вектор был так вот
один амперсант или два два почему два это expression airvalue но помните там была небольшая не то
что путаница но сложный в конце семинара что я говорил что вот если у нас от expression дикол
type вызывается и expression категория l value то у нас всегда будет амперсант а если категория
airvalue это иногда 2 амперсанда иногда 0 амперсанда вот мы там еще про x-value что-то
поговорили мне кажется 0 амперсанда вы еще еще нет хорошо ну в общем тут я утверждаю что будет
0 амперсанда мы это еще проверим да а вот здесь вот должно быть что почему 2 я бы поставил на
вот это но честно говоря я их не давно уже выпускал да типа скобочки вроде должны были
добавить ничего да какая-то фигня какая нет
смотри что тебе должен вернуть вектор булов от нуля вектор был от нуля что должен вернуть
нет конечно же не был бит референс этот промежуточный объект он где-то хранится
он создается на лету при доступе по квадратным скобочкам векторе был не хранятся не нам не
возвращается ссылка на него нам создается новый объект и возвращается он без всяких ссылок
поэтому я ставлю на то что здесь будет бит референс без ссылок а здесь
вообще не мне кажется что хорошее правило так сказать большого пальца это что есть у
количество амперсандов сохранится вот то есть если было 0 накинется 0 если было 2 типа
накинется 2 получится 2 примерно так ну вот собственно говоря если верить в это правило
большого пальца то здесь у нас накинулась 2 амперсанды я утверждаю что будет бит референс
да да ну смотри и это рвл и это рвл но вот здесь не было амперсандов на самом деле века ну типа
вектор булов вернет тебе новый объект новенький на него никого референция нет он его по значению
вернет где без скобочек я тут все возможные варианты по моему разобрал по количеству скобочек
после вот шестая функция у нас вызывается нужно принять он вызывается от объекта или от экспресс
кстати говоря кстати говоря ну как бы в этом случае неважно ответ будет один тот же какой-то
пойдет дикл тайп я кстати говоря не уверен потому что формально если не ошибаюсь оператор квадратной
скобки это одно из исключений которое не считается выражением считается доступом но не уверен
считается ли кастомный оператор квадратной скобки типа написанной они но что считался
смысл в том что на самом деле то что вывести не зависит от того как бы куда мы считаем в
какой дикл тайп мы попали вывести одно и то же я утверждаю вывести вывести должен быть референс
без амперсандов
хорошо сколько ты хочешь чтобы ссылок навесилось
чем одна ну рвл обычно 2 типа значит ну смотри те квадратные скобочки просто возвращают новый
объект даже вообще без референсов на него просто сам объект по значению это рвл если из функции
возвращается объект это рвл самая классическая
нет это не то ну давайте хорошо посмотрим результаты еще раз разберем быстренько
вопрос и пойдем дальше я думал что вы все дома посмотрите этот палик вы ж прости скидывать
identity 1 давайте посмотрим что такое identity 1 это мы авто икс return авто передаем туда 1
и еще варианты
все больше нет вариантов но я тогда с вами соглашусь это инт хорошо identity 2
что такое identity 2 вот так скобочки добавились
почему инт потому что на вывод типов для авто expression это у нас или просто название
объекта никак не влияет я напомню это важно только для дикел тайпа
хорошо identity 3 от единицы у нас вообще 3 автоводной строчки я замечу ну теперь он будет
да все так это инт и последний тоже инт а на бонусные баллы скажи почему желтеньким посвящена это
строка потому что у нас это декл тайпа это декл тайп скобочка скобочка но двойные так вот и поэтому
он будет выводить не тип expression ну и видимо все плюсов не очень нравится то что мы нет но это
warning желтенькая warning нет warning warning тут потому что действительно у нас ссылка на время объект это
подсказка к тому что вернется а персант почему вернется а персант потому что мы добавили
скобки по правилам дикл тайпа это теперь expression что это это l value значит один а персант вот
такая цепочка рассуждений приводит нас к ворнингу а ворнинг в чем сейчас компилируем и увидим значит
давай референс local variable все так ну и запускаем что у нас так 0 1 2 2 смотрим 0 1 2 2 пока
рассуждения наши верны 0 0 0 0 2 0 0 0 0 2 и потом все инты кроме последнего кажется мы справились
теперь да может что-то из этого максимальное возмущение у вас вызывает какой какой-то из
номеров а вот скорее не очень понятно почему вектор от нуля да если бы это был вектор от нуля
тут бы все поменялось в смысле векторы тентов тут бы конечно же все поменялось ну смотри давай
посмотрим что такое вектор булл квадратные скобочки это у нас есть construct b его назовем да
вот есть какая-то функция b get b вот когда мы называем вектор булл от квадратных скобочков
скобочек происходит что-то вот такое вот тут-то понятно почему это прямо rvalue вот вот это то
есть мы создаем новый объект и возвращаем его по значению вот квадратных скобочках создается
новый объект и возвращается значит rvalue у него 0% по правилам большого пальца 0% и навешано
ну правила большого пальца заключается в том что декл-тайп от экспрешена навешивает на
rvalue типа не изменяет количество персантов rvalue потому что он создает новый как ты можешь
вернуть 1% даже не скомпилиться потому что вот это вот rvalue тоже типа можно написать что-то
вот такое и потом return res но это очевидно плохо потому что res разрушится что еще раз
почему два персанта потому что да вот вот здесь да нет в третьем ну хорошо смотри
стд move от вектора это что во-первых это экспрешен значит идем в декл-тайп экспрешен
стд move это функция функция которая вернет нам стд vector bool 1% 1% если функция возвращает
rvalue ссылку это rvalue мы попали в декл-тайп от экспрешена получили rvalue значит
сохранили количество персантов значит остается два персанта окей окей ладно давайте это все
грустная часть вообще на семинар должен быть наверное не очень забудробительным сегодня
ничем что в чем вопрос ну потому что тут скобочки тут нет скобочек то есть ну вот
это запись эквилент на записи вот такой это была это это была хитрость чтобы вас запутать
вот это одно и то же окей окей давайте начнем у нас не очень забудробительный семинар мы
сегодня узнаем как как жить здорово ну почти смотрите так или я тут мне нужна твоя
помощь сетат это отдельный пункт да 11.3 значит пункт смотрите значит аббревиатура
си тад что такое сетат это класс template argument deduction вот что такое класс template
argument deduction это вывод шаблонных параметров класса ура как мы жили до того как вели сетат
да как мы создавали пары знаете ли вы как мы создавали пары стд мэйк пэр почему мы
создавали пары с помощью стд мэйк пэр да потому что функции шаблонные типы вывести можно то
есть могли написать представьте у нас есть какая-нибудь переменная pair int double и мы хотим
у нас нет ее потому что у нас нет
utility да но вообще говоря канонически пара по-моему лежит в utility да квад ну типа если мы хотим
чему-то ее присвоить мы могли бы написать либо стд еще раз полностью повторить тип
int double 1 2 либо мы могли сделать специальную функцию помощник
которая бы автоматически вывела за нас что это int double вот что удобно чуть меньше текста
что в квадратных скобочках как именно вот так ну замечательно а что это такое ну вот это типа
что это да который почему стало понятно какие типы у него потому что компилятор их
подставил кажется с помощью ситада про который мы говорим вот сейчас так можно сейчас так можно
раньше был нельзя вот собственно такая же проблема была вы можете довольно много таких штук найти мы
должны некоторых из них уже смотрели вот мы помните про итераторы говорили было тогда такое когда-то
вот там у нас была функция стд бэк инсертер вот стд бэк инсертер на самом деле это
функция помощник для итератора стд бэк инсерт итератор вот чтобы не писать стд бэк инсерт итератор
от полное название типа мы делали стд бэк инсертер от конч стд вектор там ну смысле не стд вектор
а мы у нас был вектор мы передавали туда в этот вектор да и вот компилятор сам понимал что
вызываем стд бэк инсертер от вектора и так далее вот окей собственно говоря давайте поговорим про
ситад теперь с помощью некоторого механизма компилятор может догадываться как это делать на
самом деле механизм этот несколько отличается от того как выводится шаблонные параметры у
функций делается примерно следующим образом у вас для каждого конструктора который есть у типа
создается такая воображаемая функция помощник то есть если у вас есть какой-нибудь тип да
темплейтный и скажем у нас хранится кандидата есть там конструктор от
вот так замечательно что происходит значит у нас сгенерируется такая вот тут на самом деле
тексты по переференции очень смешной читать потому что гигантские предложения в которых написано
для воображаемого типа генерируется гипотетическая функция для которой потом запускается какие-то
процессы вот значит генерируется гипотетическая функция значит кое-нибудь с от value вот собственно
говоря давайте назовем ее make s вот как мы бы и написали которая возвращает там значит она
с от т шаблонная и возвращает она нам с от t вот value ну только форварер с аргументом
нормально вот как бы это суть происходящего сложится там и длинные текты из описания начинаются
из-за того что компилятор для вас сейчас генерирует много конструкторов за вас для
этих конструкторов которые генерирует он тоже генерирует вот такие вот типа вспомогательные
функции вот соответственно сейчас мы можем написать с с от 1 вот теперь можем там вывести
тип us это будет s от int вот какие есть ограничения самое важное ограничение которое будет портить
нам жизнь это значит что нельзя написать вот так вот кто мне скажет что я тут не так
сделал ну я не указал темплэйтный размер то есть я могу либо указать вот так ну только 4d вот
вот так и указать могу я могу указать вот так вот так могу он догадается что 4 да вы должны
либо указать все шаблонные параметры явно либо не указать никаких вот сетат применяется
только конструкциям в которых вы ноль параметров указали явно вот что еще ну понятно что шаблонные
типы должны быть выводимы я не могу написать вот так ну компилятор не догадается он не может
понять что это такое вот он даже вот так вот не поймет что это такое вот
ну давай с круглых
да есть можем ну короче фигурные скобочки ну ладно наверное короче можем фигурные скобочки
на самом деле умеет вызывать конструктор и круглый умеет вызывать конструктор фигурным потом
добавили больше возможностей с тем что они могут вызывать там агрегатную цилизацию все остальное
но фигурный фигурный теперь тоже умеет в агрегатную цилизацию на самом деле то есть типа если
напишу не знаю вот это кажется тоже сработает нет нет окей это не сработает ну тут только так и
так нельзя но viable конструктор дедакшн гайд вот он вывести не смог кстати что интересно а вот
подождите кстати может и смог вот здесь есть одна интересная деталь давайте какой файл кто-то
помнит смок сам делится нормально почему же на меня тогда ругается подсветка синтаксиса потому
что значит забавный момент в двадцатой версии стандарта добавили больше вариации больше
различных правил по которым генерируются эти вспомогательные функции и в двадцатом стандарте
вот так делать можно я почти уверен что его так можно делать давайте проверим да а 17 еще нет и
вот нет два компилятора и гц ц он это уже поддерживает а мой кланк не поддерживает
потому что не довольно новые оба на кланк 15 сколько-то
а гц ц тоже довольно новые вот соответственно почему это некоторая проблема потому что если
мы захотим написать свою пару вот пара простейшая пишется вот так да
то есть вот на самом деле эта пара в двадцатом стандарте делает очень многое и она как-то в
целом очень почти во всех случаях заменит вам стандартную пару можно спросить о каждой
зоне стандартная пара а там 900 строк кода по разным причинам в паре да ну больше вот у нас 5
так что не все не все так просто зачем а вот выясним зачем ну вот смысл в том что если мы
взяли свою пару то мы не можем делать вот так да а хотелось бы ну знакомый компилятор не
но до двадцатых не могли вот на самом деле есть способ как бы указать компилятору вот эту
вспомогательную функцию руками греть вот ты не сгенерировал эти покажу как вести тип вот у этого
есть особенный синтаксис который имеет именно такой смысл и никого другого смысла не имеет
значит смотрите вы пишем ну в нашем случае шаблон потому что наша функция должна быть
шаблонной мы передаем два аргумента и по этим двум аргументам мы хотим понять какого типа пара
да затем мы пишем название класса мы пишем название класса пишем стрелочку и после этого
пишем вот если мне дали такую функцию то какой тип у меня должен получиться тип у меня должен
получиться пара от т у и хобана наш пара компилируется вот формально что происходит вот компилятор
генерирует как бы незримых вот таких штук кучу смотрит на штуку для которой нужно применить
он выбирает между всех это называется дедакшн гайд типа гайды к тому как выводит типы смотрит
на все эти дедакшн гайд выбирает максимально полезный подходящий смысл и
ну в смысле ну да на самом деле это не функции ты не можешь это вызвать это именно гайды эти
гайды генерируется где а кажется можно не указывать я просто по привычке указал то есть
это выглядит как объявление функции но это не объявление функции вот я просто по привычке написал
да действительно можно сделать так ну в смысле вот в таком случае сам но мы все еще
можем добавлять свои мы например можем сказать что потому что комплину типа кланки еще не
поддерживает дополнительные но смотри у нас есть дедакшн гайды которые автоматически
генерирует компилятор 20 плюсов и генерируется больше чем 17 их 20 их хватает чтобы просто
для вот такой конструкции сразу же понять вот в таком выражении какой должен получиться тип
как будто да поэтому в 20 плюсах и добавили чтобы такой простой случай работал вот вот я пытался
это объяснить ну в общем случае в смысле в общих чертах первая смотрит все дедакшн гайды какие
есть сгенерированный и пользовательские у пользовательских при равенстве приоритет
мы выбираем на более подходящий дедакшн гайд после этого мы его используем только для того
чтобы понять а какой тип у нас получится и затем мы пытаемся представить что вот здесь было
написано что здесь вот этот тип то есть в нашем случае здесь как бы вот так да и потом уже
для этого типа происходит выбор самого подходящего конструктора то какой конструктор выберется уже
не зависит от дедакшн гайда вот такая небольшая тонкость с мыслью как-то о ты имеешь
ну смысл хорошо смотри у нас есть название типа он видит 100 тип это на самом деле шаблон вот
это шаблон после шаблона идет видимо токен как-то название identifier и потом фигурные скобочки
это какая-то инициализация окей у меня есть шаблон у шаблона нет никаких параметров ну давай
попробуем подидюсить потом происходит то что я писал если получилось замечательно если не
получилось ц.е. так понятно какой-то какой
ему неважно именно для дедакшн гайда нет ему хватило ну в смысле понятно что ну видимо
смысл он сам генерил но я тебе говорю у тебя есть как он же его не генерирует прям плюсовым
кодом поэтому до компилятора это куча разных ифов типа а если тип подходит для того чтобы
для него нужно сгенерировать конструктор тогда нужно мне загенерирует дедакшн гайд даже если
конструкта нет и вот больше этих ифов добавили в двадцатых плюсах как раз типа того вот да
сейчас у нас есть конструктор который мы объявили для него сгенерировался дедакшн гайд у нас
все вывелось если мы берем конструктор у нас как бы есть этот конструктор если мы укажем явно
тип int double у нас сконструируется но дедакшн гайд не сгенерировался для такого случая вот
окей давайте покажу еще один случай когда дедакшн дедакшн гайды да да да да да да
да для записи замечание было в том что ну формально это не конструктор это типа
возможность агрегатно инициализировать поэтому для конструктора которого нет
не сгенерировался дедакшн гайд вот от 20 плюсов добавили вот этот дополнительный
if что если есть агрегатное то попробуем сгенерировать еще раз это типа функция
вообще у которой название равно названию класса но это дельный синтез такой вот вот такой
фигурных тут нельзя я уверен на 99 процентов ну нельзя но я сказал сразу же это вот такой
специальный синтез он означает то что означает вот если что в стандартной пары собственно
говоря я могу показать там действительно 900 строк кода во первых а вторых есть дедакшн гайд
вот специально если у нас поддерживаются дедакшн гайды мы делаем вот ровно то что
я написал вот поэтому пара стандартная сработала вот для всех конструкторов он
генерируется например для конструктора копирования тоже будет дедакшн гайд для
каждого конструктора который есть у класса сейчас он считает так мне нужно понять какой
у меня получится слева тип ага у меня есть подсказка от пользователя подходит ли она под
мой случай подходит пользователь говорит что получится если бы вот это была функция у нее бы
вы ага подсказка от пользователя если бы это была функция я бы у нее вывел типы int и double
значит получилось бы пара int double эта подсказка подошла считая что у меня выявился тип int double
ok пара от int double пытаюсь ее инцелизировать от единицей и двойки я могу могу инцелизирую вот
но давайте все-таки ну мне кажется я одно и то же по кругу говорю да можем мы можем да дедакшн
гайды мы можем делать разные собственно давайте посмотрим типа самый классический пример который
есть это вот у нас есть вектор какой нибудь вот и мы хотим чтобы у нас был значит конструктор
шаблонный конструктор вообще да ну раньше это делалось вот так
там
вот да и наш класс тоже шаблонный вот собственно говоря если у нас есть вектор и мы этот вектор
хотим сконструировать скажем от двух итераторов листа чтобы там у нас ну у нас вектор просто
скопировался или от двух итераторов другого вектора вот ну логичная кода другого контейнера
потому что почему это нужно потому что контейнеров может быть сколько угодно итераторы у всех
одинаковые а типа у всех разные в смысле итераторы ведут себя одинаково поэтому я могу захотеть
создать вектор от листа или от дека или от мапа чего угодно как мне понять а какого типа будет
этот вектор а вот дедакшн гайд нам поможет без дедакшн гайда вообще непонятно вот компилятор
здесь нужно взять какую-то обратную функцию на типах вот он этого не делает вот он этого не
делает даже у вас на лекции был пример с этим с ремуф референсом он там же сдается а тут ему
нужно что по-хорошему сделать взять итератор trades value type потому что этот итератор там может
быть например указатель да и вот мы в таком случае пишем что мы пишем вектор от итер итер
нам выдаст стд итератор trades either value type это все вектор и это все type name вот при этом значит
вот мы так можем указать что если нам дали два итератора то есть два чего-то что похоже на
итератор вот вот это вот тоже чтобы сработало том если мы можем взять value type то давайте считать
что вектор от value type и мы попадем на нужный конструктор класс ну вот я показываю ну потом
я смогу сказать вот у меня есть какой-нибудь стд там не знаю лист интов лист и я смогу написать
вектор век от лист точка begin лист точка end мне не нужно указывать типы он по итератору понял
какой тип будет у вектора а как ну то есть смотри для него вот вот смотри вот у нас есть такой
конструктор который принимает какой-то произвольный тип и мы не указываем даже
какого типа вектор откуда ему знать а да важное замечание дедакшн гайды
генерируется для конструкторов в основном шаблоне типа если я потом напишу где-то что а вот между
прочим у не знаю там и пары от стд стринг и стд вектор стд стринг какой-нибудь особенный
конструктор для него ничего не сгенируется вот все вот такое замечание то есть можно сказать
так чтобы ничего не генерируется нет да
не произойдет ли проблемы с тем что он дедакшн гайде попытается взять
нет не думаю не произойдет
сейчас еще раз смысле почему ну то есть ну смотри ну хорошо у меня есть
так
окей хорошо
ну нет он просто говорит что он не понимает по задзет он не может вывести
ну давай попробуем скомпилировать ну да но этот поэтому конструктор не можно понять какой тип
вот кластин плейт аргумент дедакшн фейлт говорит значит кандидат со ст ст ну не могу понять
что такое ты а шапка линковших он скомпилировался ну смотри тут скорее всего произошло вот что он не
смог вот эту часть сделать и отбросил эту функцию он попытался заменить шаблонный параметр сказал
что раз замена не удалась это не ошибка вот это очень полезное правило которое пригодится нам
окей так давайте быстро глянем так что еще раз потом пока не важно
окей так что посмотреть так ладно нормально давайте поговорим немножко внезапно сменим
тему казалось бы ну на самом деле не сильно вот мы тут немножко поговорили про пары значит поговорим
про такой очень полезный класс в стандартной библиотеке как тупл вот у него есть свой
хедер отдельный кто-то знает здесь что такое тупл кортеж да то есть что это такое у нас есть
класс куда можем складывать различные типы а причем
идейно что это такое вот у нас как бы есть структура мы передаем какие-то шаблонные параметры
вот и она сделает следующее она говорит но вот первый мы шаблонный параметр там
т1 вот будет тут когда-нибудь дата 1 потом т2 будет дата 2 и так сколько указали параметры
столько и получится у нее полей вот как она это делает мы наверное уже не успеем сегодня
посмотреть ну может быть в другой раз но это можно написать самому на самом деле вот то есть
мы напишем int int int это как бы структура из трех интов если напишем in double структура из
трех доблов вот из нтн табла заговорился вот зачем-то может быть полезно ну например если
у вас есть какая-то функция не знаю вы работаете с экраном и вам нужно вернуть там точку на
экране вы не хотите заводить отдельную структуру специально для этой функции там точка структура
поинт в отдельном на им спейсе у которой там int x int y и возвращаете структуру только из
этой функции можете структуру просто вернуть стд тюпл иинт инт ну или пару то есть там
гет кордс чего-то вот вот можно так сделать ну или там давайте до дабы иинт инт и какой-нибудь
уинт 32 т значит обычно этот свет вот допустим нам какая-то точка возвращается не знаю точка на
которую показывает мышка ее цвет вот такие о вот вот так классно соответственно я считаю
справедливые вопросы должны быть как что-то прочитать из тупла вот я сказал что мы как будто
бы дата 1 но понятно что на самом деле там не так так как у нас может быть неопределенное
количество аргументов тупле вообще не очень понятно как они называются называются вот ну
и у нас нет к ним прямого доступа не можем сказать точка даты или точка дата 1 вот у нас есть
свободная функция стд гет вот у нее есть шаблонный не типовой параметр вот может передать туда
сост 0 там гет от тупла вот это типа получить первый элемент получить второй элемент что
еще можно значит у гета есть ну да соответственно можно изменять там вот здесь я могу написать там
равно 0 x там 0 0 ff 0 0 ff что-нибудь такое какой-то цвет задать например что еще можно делать значит
есть удобная у гета функции функциональность что по туплу и гету можно значит указать тип и
и в том случае если этот тип один в тупле нам на этапе компиляции там найдется некоторой
шаблонной магии типа где он именно лежит и вернуть ссылку на него вот собственно возвращает нам
ссылку вот это туплы соответственно ступлами была та же проблема что и с парами раньше
представим что вам нужен тупл из даже не так представим что у вас есть структура
у которой есть тупл внутри ну тупл конечно же ссылки на инт и на стд стринг вот это тоже
легально в тупле можно хранить ссылки как и в структуре почему нет вот и мы хотим написать
значит как-то конструктор для этой структуры вот нам сбрело в голову как вы считаете как как
как это можно было бы сделать ну представим что нам дают тупл даже нет нам дают собственно
говоря и и стд стринг амперсант с вот как бы мы могли инцидировать дату по вашему
но есть функция мэйк тупл как и мэйк пэр
так что у нас там но мачинг констракшн не работает почему-то казалось бы а я не писал стд
да все равно не работает почему же
блин я почему-то думал что на этапе компиляции не поймает
ну давайте вот так
понятно да
так как бы показать эту хитрость ладно давайте прямо скажу значит на самом деле мэйк тупл чуть
более хитрая функция чем кажется она в отличие от мэйк пэр не просто берет и создает тупл вот
она делает кое-что более хитрое что же она делает она например убирает ссылки у типов
то есть даже я знаю почему не работала потому что она и так убрала ссылки у типов
и так тоже не сработает нет обещально
ладно вот
давайте посмотрим другим способом
такой
так ну так нельзя
вообще отказывается работать таким
образом, ну и хорошо, я немножко запутался, ну мы распутаемся. Окей, ну простой
способ понятно работает, у нас получится тупло от двух интов. Вот, и у тупла есть
один if, так сказать, захардкоженный на типе стандартной библиотеки, если вы
передайте ему std-reference-wrapper, вот, то он сделает кое-что хитрое.
Сейчас вам покажу, что. А мне казалось, вы его обсуждали уже в чате, нет? Так, вектор,
уберем вектор. Ага, std-reference-wrapper, окей. Смотрите, он вывел int&percent, хотя это
был std-reference-wrapper. std-reference-wrapper это просто структура, которая хранит
указательно какой-то объект и притворяется, что это референс. Да, но она нужна для
некоторых h-кейсов, где референс нельзя принять, но хочется передать. Вот, ну вот
такая особенность, что если вы передадите в make-tuple-reference-wrapper, он
превратится в ampersand. Интересная особенность. Да, и что еще make-tuple на
самом деле убирает у типов все референсы, также превращает, ну, array в
поинтеры, вот, функции-выказатель на функции.
Ну, что-то вроде. Но на самом деле чуть больше она делает.
Нет, вот это явно сделано специально, то есть, видишь, то есть, у нас есть
template, мы получаем какие-то произвольные элементы, мы на эти элементы к ним
применяем функцию на типах, которая, собственно, делает все, что я описал, вот,
и возвращаем tuple из вот этих элементов, где decay-strip там, оно же не
находит просто так. Ну, да, он не здесь где-то, ну, не суть.
Я не уверен. Я не уверен. Вот, что есть еще интересного. Есть, на самом деле,
функция helper, чтобы специально работать с референсами, значит, функция, которая, на
оборот, навешивает референсы на ваши аргументы, которые вы дадите, и создает tuple
референсов на то, что вы передали. Значит, std tie, ic, а я тут char хотел
сделать, чтобы было поинтереснее. Вот, значит, std tie нам вернет tuple из
референсов на эти переменные. Вот, зачем это может быть нужно? Ну, раньше это
могло быть нужно, например, чтобы просто делать оператор сравнения. Что можно было
сделать? Так как у tuple есть сравнение, можно было написать какой-нибудь bool less, там other,
pair other, и написать std tie first, second, меньше tie other.first, other.second. Вот. Это такой был
простой способ написать сравнение у, например, простых типов. Сейчас это не особо применяется,
потому что сравнение само работает. Вот. Но есть некоторое другое применение. Ну,
я, чтобы не писать оператор меньше, я написал less. Вот. Есть другое применение. Вот, например,
есть функция, которая возвращает, значит, две штуки и цвет. Две каринеты и цвет. Вот у нас уже
есть где-то определенные и переменные под это. То есть, что бы мы могли сделать? Мы могли получить
сначала от этой функции этот tuple tuple и потом приравнять. Вот. А что бы мы могли еще сделать?
Мы могли сделать лучше. Мы могли написать std tie, типа свяжи мне, пожалуйста, x, y и color,
и сделай get cohorts. И он бы сразу записал эти три переменные. Довольно удобно. Вот. То есть,
еще раз напомню, он просто навешивает 1% на все. Тут никаких особо... Навешивает 1% и создает tuple
ссылок на то, что ему передали. Вот. Вот. Временный объект в смысле... Да, сюда ты единицу передать
не можешь. Ну, потому что, собственно говоря, вот там было видно в реализации, что он просто там
без всяких каких-то хитростей, с универсальными ссылками или еще чем-то он просто принимает
lvl ссылку и все. Вот. Окей. Что еще нужно сказать про tuple? Есть третий способ создавать tuple. И вот
он уже чуть более хитрый. Значит, называется std forward s tuple. Вот. Как вы думаете, что он делает?
Интересное предположение. Напоминает ли вам это что-то?
Ну, смотрите, он принимает универсальную ссылку. Std tuple явно указанного вот такого типа. Что это
значит? Давайте подумаем. Еще раз вспомним. Если мы приняли rvalue, то elements это что?
Нет, elements это 0 амперсантов. Если rvalue. Если rvalue, то либо 2, либо 0. Да, либо 2, либо 0. И вот эта штука в сумме дает 2.
Здесь у нас будет 2 амперсанта. Ну, вот у вот этого типа в сумме 2 всегда, да. Но вот этого типа может быть не 2.
У вот этого большого 2, да. Да, да, да. В сумме получится 2 всегда. Если rvalue, если lvalue,
то вот у этого суммарного типа получится 1 амперсант, да.
Ну, давай посмотрим. Вот, собственно говоря, если мы сейчас изменим x, то изменится и в тепле x.
Если мы изменим в тепле, то изменится и в настоящих x. Забавно.
То есть, понимаешь, он каждый тип отдельно forwarded.
Типа, если у нас было 3 первых аргумента, это lvalue, они стали lvalue ссылками. Последний аргумент был rvalue. Он его сохранил как rvalue ссылку.
Можно вернуться к какой-то функции? К стандартной функции.
В строке с ветерным 2 амперсанта, если сам elements уже... Ну, это по сути мы же elements и навешиваем 2 амперсанта, да?
Да. А сам elements уже будет либо амперсант, либо 2 амперсанта, в зависимости от того, что мы передали rvalue.
Ну, это 0 амперсантов. В сумме так работает.
Но, еще раз, у тебя универсальная ссылка выведет 0 амперсантов, если туда единицу передашь. Потом ты навесишь 2 амперсанта и получится int 2 амперсанта.
А если ты не навешишь вот здесь 2 амперсанта, то ты передашь просто elements, то есть просто int.
И он сохранит вот тот int, который я передал, не rvalue ссылку, а просто int. И это два разных поведения принципиально.
Ну, если forward принят elements 2 амперсанта, так что... Нет? Да.
Я представлю, да.
Я, видимо, не понимаю, что происходит. Ну, как... В общем, какой тип будет у elements, когда мы универсальную ссылку поставляем, и что происходит?
Какой тип будет у elements? Ну, смотри. Ну, хорошо, давай.
Еще раз. Вот у нас есть универсальная ссылка.
Давайте разберем.
Окей. Вот. Давайте еще раз вот это вот все закомментим.
От чего повызывать вы хотите? Вот от единицы могу. Могу так сделать, потом q от i.
Могу еще q от std move от i. Можно так не делать, пожалуйста. Вот.
Но давайте подумаем, что у нас получится?
Вот. Я утверждаю, что от единицы...
У нас будет 0 амперсантов и 2 амперсантов.
0,2, 1,2, 1,2.
Ну, и давайте подумаем, что у нас получится?
Ну, я утверждаю, что от единицы...
1,2.
Потому что такие правила для универсальной ссылки.
Окей. Кого-то еще есть вопросы по этой части?
Так.
Ну, потому что такие правила работы универсальной ссылки.
Ну, я не знаю, что сейчас...
Ну, смотри. Хорошо. Почему так?
Когда forward передаем, да, что-то, мы потом обычно forward передаем t, да?
И вот t для forward это будет символ. Если у него нет ссылок, значит rvalue было.
Значит, если у него 1 амперсант, значит это было lvalue.
Да. Нет.
Я не знаю. Ну, вот давайте. Ну, не будет. Как?
Ну, это универсальная ссылка. У нее особые правила вывода типов.
Если она получает rvalue, значит тип без амперсанды, на который навешивается 2 амперсанды.
Окей. В таком случае, если мы поняли, как работает вот эта штука,
то forward as tuple, он вот для каждого элемента tuple эту операцию производит просто forward.
Окей. Так, сколько у нас времени?
Минус 18 минут.
Минус 18 минут.
Минус 8 минут.
Окей. Что tuple быстро?
Нет, это быстро мы не сделаем.
Давайте быстро без edge-case посмотрим на такую вещь, как structured-binding.
Значит, смотрите.
Мы можем делать следующую вещь. Вот видите, что делал std-tie?
Оно брало существующие переменные и собирало их в tuple.
А мы можем сделать наоборот. Мы можем взять, например, tuple и еще некоторые вещи
и разбить его на отдельные переменные.
Вот такой особенный синтаксис.
авто, квадратные скобочки,
не знаю, ver равно, что у нас здесь, ну, verg равно forward.
Так.
Ладно, тут слишком сложный пример. Давайте тогда...
А вот tuple.
Вот. Что произошло?
Мы объявили как бы
типа три новые переменные
и принципизировали их
соответствующими значениями, которые лежат в tuple.
Вот.
Сейчас это копии. Мы можем сделать
на весь этим персант, чтобы это были ссылки.
Вот. Можем делать их константными.
Вот. В этом смысле никаких особо сюрпризов.
В каких ситуациях это применяется?
Значит, первое.
Если у вас справа стоит tuple или para,
или ray из стандартных типов.
Для std ray это тоже работает.
То есть, если вы скажете, что у вас есть std ray int 3 rr,
то здесь вы можете сделать rr.
Вот это будут три константные ссылки на int.
В таком случае.
Вот. Если справа стоит сишный массив,
то есть, мы можем написать int
не знаю, давайте char
3 char
равно
a, b, c
и здесь char.
Почему не нравится?
А, потому что я не туда тройку написал.
Вот.
Можно так сделать.
Но здесь, соответственно, их должно быть столько же.
Меньше нельзя.
Ну, больше тоже нельзя, понятным причинам.
Указатель уже бы не сработало.
Да.
Ну, понятное.
Указатель уже бы не сработало.
Да, в смысле?
А это неважно.
Это же все на этапе компиляции происходит.
Вот. Так нельзя.
Собственно, потому что это происходит на этапе компиляции.
Компилятор не может удостовериться, что все нормально.
И
самое интересное
это, если у вас есть структура,
которая, благодаря некоторым правилам, она достаточно простая.
Да, например, не знаю, точка.
Здесь есть int x, int y.
То вы можете написать
x, y
равно point, например.
Какие правила?
Re-division of x.
Ну, x, x, y, y.
Какие правила?
Все поля должны быть публичными.
Все поля должны быть
либо в самой структуре,
либо в одном из ее родителей.
То есть, если я тут напишу
uh
another point,
который от point
паблик
вот
то я могу сделать another point.
Но если я сюда добавлю что-то еще,
например,
int 32t color,
то уже не могу.
Ну, так тоже не могу.
Но чтобы они все были на одном уровне наследования.
Вот.
Ну, соответственно, как работает вот эта же вещь
и как работает вот эта вещь, более-менее понятно.
У нас есть структура, компилятор смотрит первое, второе, третье поле,
компилятор у нас есть либо массив,
он смотрит, берет первый, второе, третий элемент массива.
С array и туплом и парой немножко более хитрая история.
Значит,
потому что эти структуры не удовлетворяют мне не тому, что они массив,
не тому, что они вот такие простые.
Есть специальный синтактис, чтобы
указать компилятору, что с моей структурой можно делать вот так.
Вот.
Чтобы вот так можно было делать, мы для своей структуры должны написать
значит
значит
мы должны специализировать два шаблона стандартных.
Это tuple-size
и tuple-element.
Значит tuple-size нам должен вернуть
размер, ну, то есть сколько у нас элементов в структуре,
чтобы можно было проверить,
что у нас правильное количество штук в авто написано.
А tuple-element должен вернуть тип.
Вот.
И еще после этого должна быть функция get,
которая собственно вернется
элемент соответствующего типа.
Нет, tuple-size это структура,
то есть у нас есть std tuple-size.
И что мы должны сделать?
Что вроде
struct std tuple-size от another point
и здесь пишем size t static
value равно 3 там в нашем случае.
Вот.
И тогда он
уже решит, что, ага,
это недостаточно простой тип,
но пользователь что-то мне сказал.
Вот.
И сейчас он будет на меня ругаться за то,
что мне не хватает get.
Он не понял,
он понял, что я ему хочу сказать,
что можно с моей структурой так делать,
но я не сказал как.
Вот, поэтому get не хватает.
Да, нужно еще
get определить.
Так же, да?
Вы еще про type что-то говорили?
Да, type.
Ну, у нас должна быть вот такая же штука,
значит,
только от
size t index
tuple-element
another point
index
и здесь будет using
это где лежит?
type, что именно?
Что вы рележите, я не понимаю.
Оригинальный шаблон я даже не знаю,
честно говоря.
И что мы делаем?
Вот, но если бы здесь было int,
мы бы всегда возвращали int.
Сейчас для скорости сделаем вот так.
Так, что мне нравится?
А, потому что
видимо в обратном порядке.
Да, вот так.
И нам еще нужна функция get.
Ну, у нас будет всегда возвращать, например, int,
get
от нашего
another point
Нет, по-моему, это не обязан быть,
если это get.
И мы делаем return
p.
не знаю, x
template
size t
index
Ну, здесь, конечно, нужно не всегда
x возвращать, понятно.
Но вот все, теперь это скомпилировалось.
То есть, это все такие
быстрые наброски, чтобы показать, что если мы указали
вот эти три вещи,
компилятор по другим правилам теперь сказал,
чтобы работать с этой структурой в таком контексте.
Вот, пока она возвращает фигню,
нужно доделать.
Ну, это типа в качестве упражнения.
Get ни к чему не привязан, просто
функция.
Да, ну, должна быть либо свободная функция get,
либо кажется можно, чтобы это была
функция член класса.
Можно ли передать, если своей структуре
передать шаблонный параметр int,
можно ли потом ее распаковывать в int
аргументах?
В int аргументах.
Не понял?
В typical size можно будет ее распаковать.
Кого?
Если, например, у меня есть шаблонный аргумент int
А, если шаблонный аргумент у структуры,
да. Ну, типа у вас просто будет
что-то вот такое тут.
Вот тут опять будет такое.
В плане, оно автоматически не определится,
если у меня, например,
в root 3 будет ray размеры.
Не, автоматически тут ничего не определится,
тебе нужно все прописывать.
Нет, в плане, он же автоматически
определяет для pointer.
Для кого?
Для pointer. Что он определяет?
Как распаковывается. Ну, это еще раз, у тебя есть
три разных правила, одно для массивов сишных,
одно для простых структур, и вот это
третье, где все руками.
Вот у меня может быть структура, в которой, например,
сишный массив.
Ну, нет, так, ну, тогда
она может распаковаться, но, типа,
единственным элементом будет сишный массив.
Типа, элементы массива ты так уже не получишь.
Ну, все, ладно, давайте тогда закончим на этом.
А, последнее, что я скажу, что
вот этот синтаксис,
его также можно внутри фора использовать,
что очень удобно, например, проходиться по мапу.
Можно писать const
auto
kvalue
v.
там какой-нибудь m.
Вот, и внутри
использовать этими kvalue.
Наверное, да.
Да, все.
Все, теперь точно все.
