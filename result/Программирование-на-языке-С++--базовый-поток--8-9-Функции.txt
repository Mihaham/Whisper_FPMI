Лекция номер 8, которая будет посвящена функциям.
Это прекрасная тема, потому что функции — это новый этап в нашей жизни изучения программирования.
Когда мы начинали с вами изучать программирование, мы говорили принципы,
на которых строится вообще программа. Они были сформулированы еще в 1945 году.
Кто помнит, какой главный у нас принцип, как программа исполняется?
Последовательно. У нас есть некий код, он исполняется последовательно. И после этого
появилась идея структурного программирования, что он исполняется последовательно. Иногда нам
надо сделать какие-то решения, какой-то выбор. Вообще говорят, что вся жизнь стоит из выбора и
последствий выбора, которые мы совершаем. Вот вы, например, решили поступать на физтех, наверняка
ваш жизнь как-то от этого изменится. Последствия выбора вы еще на себе ощутите. Если бы, например,
вы поступали в другой вуз, там были бы другие последствия выбора. Если бы никуда не поступали
в третий, тоже интересный выбор. Можно в армию было сходить или еще что-нибудь поделать. Поэтому
всегда есть у вас выбор. Вот это у нас появилось вветвление. Ну а потом вы прекрасно знаете,
что жизнь наша не такая совершенная. Иногда надо выполнять много-много каких-то действий,
например, там вот день сурка. Если вы смотрели, вы понимаете идею, что жизнь человека очень часто
монотонна. Мы встаем, идем на работу, возвращаемся с работы, смотрим YouTube, ложимся спать и так далее.
И у вас мы встаем и ходим на пары, идем в столовую. Я, честно, тоже сходил после нашей пары в столовую
КПМ, и вот жив, все нормально. Видите, все еще перед вами. Так что проверил на себе. Идете в
столовую, и после этого тоже вечером что-нибудь там расшариваете друг к другу. И после этого
обязательно программируете. Мы договаривались, что у нас каждый день час хотя бы программирования.
Обязательно программируете, ложитесь спать. И вот примерно у вас тоже такой повторяющийся процесс,
этот цикл. И вот у нас программирование, наше составление программ было из трех ключевых вещей,
линейное, ветвление и цикл. Но если бы вся программа наша была только такая, нам очень сложно было бы ее
разрабатывать, например, совместно с другими. Или даже самому вам было бы сложно, если проект очень
большой, никак его не декомпозировать на какие-то законченные блоки, в которых вы можете, например,
быть уверены, что оно работает. Потому что когда у вас огромная программа, то как мы ее отлаживаем?
Мы пытаемся понять, что вот эта часть работает, а вот эта часть не работает. Вот знаете, как вот
телевизор, когда мастер приходил, раньше, я помню, когда я был маленький, у нас был такой большой
телевизор, мастер как приходил чинить? Он на дно вытаскивал деталь, вставлял вместо нее работающую.
Ага, это не эта деталь, методом исключения. Но мы точно должны понимать, что какие-то части, вот мы в них,
например, уверены. Вот эту часть мы отлаживаем, потому что если у нас такой хаос, и мы не понимаем,
как вообще поделить на части, то отлаживать сразу миллион строчек кода очень сложно,
практически невозможно, или искать там ошибку. И Страуструбт, создатель языка C++, вообще сказал,
что функции были созданы для того, чтобы навести порядок в хаосе программы. Поэтому функции,
это первое, что появилось в структурном программировании, такая абстракция,
которая позволяет нам декомпозировать программу на какие-то законченные блоки. У функции есть
некая точка входа и выхода, это некий вообще, как можно сравнить с черным ящиком, и это называется
инкапсуляцией, скрытие того, как этот черный ящик работает. Вам важно знать только что, что есть некий
интерфейс, когда вы получаете некие данные входные, и этот интерфейс, там какие-то параметры. Потом
как-то оно там работает, и вам не важно знать как, и после этого получаете ответ. Например,
функция суммы двух чисел, какой у нее будет интерфейс? Мы получаем два числа, она как-то там
тужицу-тужицу складывает супер алгоритмом, и получаем на выходе результат суммы двух чисел или функция
модуля числа. Когда мы с вами, бедный оператор, простите, что я все время хожу, но я вот такой вот,
вот не могу стоять на месте. Функция модуля числа, это когда вы даете какое-то число, там происходит
супер сложное условие, зависимость от того числа положительно и отрицательно считается его модуль,
и вы получаете ответ. И вот эта инкапсуляция, это скрытие данных от пользователя, который
пользуется этой функцией. То есть пользователь, в данном случае для нас, это другой программист,
который пользуется какой-то библиотекой или функцией. Ему не важно содержание, мы должны
быть уверены, что когда мы вызываем какую-то библиотечную функцию, но, например, я не знаю,
которую мы с вами уже пробовали или функцию пау в изведении степени, вы должны быть уверены,
что она правильно вам работает, вы не должны лезть в библиотеку Microsoft Visual Studio, проверять,
что в степень там возводится действительно правильно, потому что мы доверяем библиотекам,
которые у нас есть. И это вот тот самый новый уровень абстракции, который появился,
который позволяет теперь совместно разрабатывать программы. Когда он появился, у нас где-то в
70-х годах. Понятно, что мы идем с вами исторически, то есть дальше у нас были другие вещи, но что это
нам дало? Это дало, что один человек пишет одну функцию, другую-другую функцию, мы можем
декомпозировать большой проект, потом это соединять. И у нас есть законченные вот эти блоки. Ну и сами,
когда вы пишете теперь одну программу, вам надо... Слушайте, лекция пять минут назад началась,
а вы уже заснули, а что же будет через три часа? Вот, у вас день с урка неправильный, вы ночью не
спите, видимо. Значит, мы с вами сейчас используем функцию, но дальше у вас будет целый курс на втором
семестре объектно-ориентированное программирование. Как вы помните, я вам говорил, что наше кафедрое
программирование будет с вами целых три семестра. У некоторых это три экзамена, у некоторых два,
в зависимости от групп. Я вам писал в начале семестра эту табличку. Так вот, это будет новый
уровень. Абстракция — это классы, когда мы будем уже не совсем замыкать только функцию, но и добавим
к ней некие данные, и это будет у нас с вами следующий этап. Но пока вот функции. Теперь давайте
запишем формальное определение функции. Это именованная последовательность описаний и
операторов, выполняющие какое-либо законченное действие. Функция — это именованная последовательность
описаний и операторов, выполняющая какое-либо законченное действие.
Выполняющая какое-либо законченное действие. Именованная последовательность описаний и операторов,
выполняющая какое-либо законченное действие. Любая программа на C++ у нас состоит из функций. Как
вы помните, у нас есть одна особая функция, с которой начинается выполнение программы. Это
функция main. Она должна обязательно присутствовать. И любая функция должна быть объявлена и
определена. Что такое объявление и определение, сейчас мы рассмотрим более подробно, потому что это
очень важные вещи. Итак, сначала синтаксис. Каким образом мы работаем с функцией? Есть
необязательная часть объявления функции, называющаяся class. После этого идёт тип возвращаемого значения
функции, потом имя функции. У него тоже есть идентификатор, потому что как у вас есть имена,
так и у переменных имена, так и у функций имена. Всем понятно, как к кому обращаться.
Вот. И после того, как у нас есть имя, у нас есть некий список параметров. Он тоже у нас
идёт в квадратных скобках. Это значит, что необязательная часть синтаксиса. То есть может
не быть у нас параметров функции. Она может быть без параметров. Если мы говорим, что это полное
определение функции, то мы сразу делаем тело функции. То есть те операторы, которые у нас идут,
внутри называются телом то, что у нас исполняется. Какой класс у нас может быть? По умолчанию у
нас всегда класс экстерн. Можно его не писать. Это значит, что функция у нас видна во всех
модулях. Глобальная видимость. И у нас есть статик. Это значит, что данная функция видна только в
пределах данного модуля. Данного файла, где у вас располагаются функции, потому что у вас программа
может стать из нескольких модулей, которые собираются линковщиком уже. Теперь про тип.
Давайте поговорим. Тип у нас может быть с вами любой, кроме функции массива, но может быть
указателем на функцию массив. Пометьте себе это, пожалуйста. То есть любой, кроме функции массива,
но может быть указателем на функцию массив. Имя. Это правило стандартного идентификатора.
То есть я могу назвать 456 функцию? Нет, а как мне назвать? А 456. Это я корейских сериалов
насмотрелся, простите. Я, как вы думаете, могу назвать функцию? Это будет более сложный вопрос.
Давайте вы над ним подумаете, можно ли назвать функцию как и переменные. Давайте чуть позже с
этим разберемся. Писок параметров. Ну, собственно, параметры, которые у нас будут функцией, они
объявляются через запятую. Все, что пока нам надо знать. И у нас, как я сказал, есть объявление,
а есть определение. Вот с этим давайте сейчас разберемся и приведем пример. Например, я в
начале хочу объявить ту самую функцию суммы, о которой я рассказывал. Это некая супер сложная
функция, которая складывает два числа. Я хочу сделать сначала ее объявление, то есть не
реализовывать тело функции, а объявить, что такая функция будет где-то реализована чуть позже в коде.
Но до первого вызова этой функции мы должны объявить для того, чтобы компилятор знал,
что такая функция будет и какие у него параметры, и правильно работал с ней. То есть вот если я хочу
где-то здесь ее использовать, то она должна до этого места быть объявлена, что есть такая функция. Итак,
функция сумма. И есть разные способы. Я могу просто написать int int, не писать даже имена
никакие, когда я объявляю. Я просто говорю, что у меня будет вот такой у меня прототип. То есть у
меня будет функция суммы реализована, где будет два int приниматься, один int возвращаться. Обязательно
ставить точку запятой, закрывать объявление функции. Можно написать сюда переменные? Можно. Они
должны совпадать с определением или как-то иметь значение? Нет, они ни на что не влияют. Они
все равно игнорируются компилятором при компиляции. А зачем тогда их писать? Какой смысл писать
здесь переменные, если они все равно игнорируются? Кто-нибудь может привести разумную причину,
иногда полезно в объявлении писать имена переменных. Ну, например, приведите примеры
переменных, которые вы там напишете. Там делимое частное. То есть вы имеете в виду,
что совершенно верно. Когда функция несет, например, деление одного числа на другое,
чтобы не запутаться, что на что делится, называя переменным нужным образом, мы просто подсказываем
фактически это некий комментарий, говорящие имена такие, которые сразу скажут человеку,
что в этой функции какой параметр, не надо смотреть в комментарии. То есть это действительно
единственный разумный способ, когда нам надо писать здесь эти имена. Теперь у нас есть функция
main, она идет наследом, и в этой функции мы будем сейчас с вами использовать нашу сумму. Давайте объявим
a равно 2, b равно 3, c и d. Пусть у меня такая вот несложная программка. Я могу вызов сделать c равна
сумма a и b. В данном случае у нас функция стоит в правой части оператора. Присваивание. Что
происходит здесь? Мы подставляем a и b, они подставляют сюда. Причем функция еще не определена,
мы не знаем, как там это делается. Сейчас определим позже. Какой-то результат вот этого
работы черного ящика. Я хочу к Распринскам инкапсуляции до вас донести, что нам вот момент
вызова неважно, как она работает. Это делает другой человек. Мы можем декомпозировать там
на разных людей, если это какая-то команда, или даже на себя, но в разные временные промежутки,
и можем не помнить, как оно, или даже не знать, а потом написать, что очень тоже интересный момент.
Мы уже знаем, что нам это понадобится, но еще не знаем, как это сделать, но уже можем на это
ссылаться. Это знаете, как начинать инвестировать миллион долларов. Вот я шел сюда, а там плакат
известной компании, когда надо начинать инвестировать. Вчера рядом со столовой как раз,
чтобы никто мимо не прошел. Но если ты вчера не начал, то сегодня уже еще не поздно. Мое мнение
другое, что если ты в этом ничего не понимаешь, то лучше все-таки сегодня не надо начинать. Там
есть более профессиональные люди, которые радостно возьмут ваши деньги и как бы на ваши
неопытности заработают. Это же фактически перекладывание денег из одного кармана в другой.
Если это не ваш перекладывается, вам не очень от этого инвестирования приятно. Так вот,
здесь то же самое. Мы не знаем, как это реализовывать, и мы не знаем, можем с вами
сказать, вот когда у меня будет миллион долларов, я буду делать такую стратегию. Здесь то же самое.
Я знаю, что у меня будет сумма, и как ее делать неважно. Теперь можно ли использовать еще как-то
эту сумму, кроме как просто явно вызвав в правой части операции присваивания. Что ты еще
можешь делать? Конечно, можно, например, использовать в выражениях. Можно, например,
вывести на экран. Я не пишу здесь не include, не using. У нас весь такой код все-таки больше про
содержание, поэтому потом не рассказывайте мне, что она не компилируется. Да, она не компилируется,
потому что я не включил в библиотеке. Но все остальное правильно. Я просто помню на второй
лекции, когда мне вы сказали, вся сумма c и d. Вот я так, c и d не введены. Давайте не будем плохой
код писать, например, a и 2. Вот, a и 2. То есть, я могу в разных местах, в любом выражении. Здесь
я могу не обязательно использовать переменные. В данном случае, могу использовать константы,
могу использовать 2 умножить на a. То есть, совершенно разные у меня есть моменты,
как я эту функцию вызываю. Сейчас я хочу задать вопрос. А может ли функция, в принципе, не это,
а какая-либо стоять в левой части оператора присваивания? Не в правой, а в левый. Давайте
мы проголосуем. Поднимите руки, кто считает, что может. Поднять руку придется все равно.
Ага, когда заставили что-то сделать, вы начали решили послушать, что же вообще тут происходит,
и перестали ботать мотан. Значит, функция в данном случае, видите, вот здесь у нас,
стоит в правой части оператора присваивания, в правой. У меня вопрос гипотетически про какую-то
функцию, не про эту вообще. Может ли быть такая функция, которая будет стоять в левой части оператора
присваивания? Надо поднять одну руку, если вы за, то левую, если вы против, то правую, чтобы не было
у нас давления людей друг на друга, чтобы все подняли одновременно. Вот я считаю до трех,
и на три вы поднимаете левую или правую руку вверх, и не смотрите на соседа. Если вы считаете,
что в левой части может стоять функция оператора присваивания, поднимайте левую руку,
правую руку, правую, давайте так правую. Я просто показывал для вас левую, чтобы вы не перепутали.
В общем, давайте другой способ. Этот очень сложный, хорошо, очень сложный, очень сложный. Мы
делаем так. Я понял, что голосование должно быть очень простым. Если вы согласны с тем,
что функция может стоять в левой части оператора присваивания, и уверены в этом, то поднимите руку.
Если вы считаете, что нет, не поднимайте никакую руку. Все, 1-0 у нас, двоичное голосование, давайте.
Все, что не ложь, что истина, любая рука, нога, ухо, которое поднято вверх, считается истиной,
как C++. Итак, поднимаем руку тех, кто считает, что может в левой части. Давайте я посчитаю,
сколько вас. Раз, два, три, четыре, пять, шесть, семь, восемь, девять, десять, одиннадцать, двенадцать,
тринадцать, четырнадцать, пятнадцать, шестнадцать, два, офигенная еще степень двойки. Шестнадцать
человек проголосовало, нас здесь несколько больше, наверное, наверное, человек сто, да, поэтому
мы узнаем, вот это меньшинство, оно было право или нет, на второй лекции. Вот, хорошо. Теперь нам
надо реализовать, но это хороший способ, это знаете, как ютубе говорит, там жмите лайк, ждите,
ждите это самое, мы расскажем там в спецвыпуске, да, вот я. Или как вот этот сериал, который я все
выходные смотрел и не мог остановиться, потому что всегда заканчивался на самой интересной серии,
на самом интересном месте. Вот, теперь надо реализовать эту функцию, так что я надеюсь,
что до второй лекции зато вы останетесь и узнаете ответ. Тоже нетфликсовские приемы удержания
студентов максимальной посещаемости. Значит, функция сумма, теперь ее определяем с вами, определяем.
И здесь я обязан, конечно, писать имена, потому что я буду сейчас ссылаться на эти
переменные, это локальные переменные внутри функции. Функции, очень сложный функционал,
она складывает два числа и возвращает. И обращаю ваше внимание, что a и b в данном случае это
переменные, которые объявляются внутри функции. Они рождаются в момент начала работы функции и
уничтожаются вместе с функцией. Это локальные переменные для функции. Они тоже на стэке,
как и все переменные временные, автоматически у нас хранятся на стэке, но a и b у нас в данном
случае вот такие. Теперь давайте я напишу вам одну программку, у нас будет с вами еще один
интерактив, но более сложный, где надо думать, а не только поднимать руку. Напишем с вами функцию.
Функция f принимает одну переменную, это один int у нас, который ей передается. Внутри функции
объявляется еще одна переменная типа int. Потом мы печатаем с вами
nmp через пробел и переводим строку. Делаем while. На прошлой лекции мы уже посмотрели сложные вещи,
как работает c++, поэтому while a-minus-minus сегодня уже не доставит вам никаких
сложностей. Внутри while, чтобы нам было еще интереснее, объявим статическую переменную.
Внутри while объявим статическую переменную. Теперь еще одна переменная int p равная нулю.
И печат, и out, это для тех, кто еще не понял, как работает постфиксный инкремент, еще одна
задача. Через пробел печатаем n, m++, еще один пробел, p++, я вот здесь сотру, чтобы мы не
разрывали строчку и перевод строки. Итак, мы печатаем с вами n++, m++, p++ и перевод строки.
Закрываем эту функцию f, закрываем while, закрываем функцию f. И давайте продолжение
вот на этой доске напишем с вами. У нас будет функция main, в которой мы с вами делаем следующие
вызовы f от 3, f от 2 и return 0. Ну, как обычно в таких случаях, наш вопрос, что будет на экране,
если вы компилятор c++, вам дана программа, откомпилируйте, напишите в тетради, чтобы вы
напечатали на экране, если вы были компилятором. Значит, что здесь в этой программе происходит?
Смотрите, у нас сначала выполняет всегда функция main, поэтому когда вы какую-то программу
исполняете, мысляйте как компилятор. Мы начинаем с main, и первое, что происходит, вызов функции с
параметром 3. Вот функция, вместо a у нас подставляется 3. Давайте просто распишем себе, если мы были компилятором,
как бы мы действовали. Какие у меня на данный момент вообще есть переменные? У меня уже есть
одна переменная локальная, это a. Почему? Потому что я вам сказал, что когда мы передаем какой-то
параметр по значению, как здесь, это фактически мы объявляем перемену a, как мы объявили missure
локальную для функции, здесь в этой строчке объявляется переменная a, и в нее копируются
значения, которые ее передали. Вот эта строчку копируется в a, но чтобы она скопировалась,
конhésitez, чтобы перемену надо завести, поэтому у нас есть как минимум переменная a,
в которой хранится сейчас 3. В следующей строчке у нас объявляется переменная m, в которой хранится
граница ноль. В следующей строчке происходит очень
важное, что не надо забывать, мы печатаем на экран nmp.
И если вы напишите все это правильно, но не напишите
nmp, формально вы не выполнили задачу, потому что там вопрос
был, что будет на экране. nmp будет первой строчкой.
После этого делаем некий while, while а-минус, постфиксный
декремент а равно 3 сейчас. 3 это истина. Соответственно,
после того, как мы войдем, мы сразу убавимся на 1,
но после тока войдем. Ну, не совсем после тока войдем,
после тока проверится это условие, скажем так. И
внутри цикла мы с вами заводим переменную статическую,
переменная n. Она обнуляется только один раз, первый
раз, когда ее заводят. Она больше не будет обнуляться,
иначе от нее было бы странное сохранение значения между
функциями, если она все время обнуляется, когда натыкается
на свое прошлое объявление. Поэтому она обнулилась
вот здесь и все. Потом идет еще одна переменная p, и
она обнуляется. И потом идет nmp. Вот у нас сейчас в данный
момент 3 0. Эта первая строка была почти у всех правильна.
Наверное, у всех даже была правильная из семи человек,
что я смотрел. Дальше там появились у некоторых
минусы. Минус 1 там где-то я видел, еще что-то, но вот
nmp все сделали. На незачет вы все справились. Дальше
у нас идет цикл while. У нас сейчас a равно 2, 2 это истина,
значит входим внутри цикла. Убираем 1, фиксный декремент
Н у нас уже повторно не обнулится. И после этого печати, что
у нас сейчас хранится на nmp? Они все у нас на единичку
прибавились, и N повторно не обнулится. А вот p у нас
обнулится здесь снова, потому что это обычное
объявление переменной. Мало того, p вообще заново у
нас инициализируется. Почему? Ну потому что p где обновилось,
внутри блока. Вот здесь оно прибавилось до единички,
а здесь оно в это моменту, вот здесь уже p. Если бы
за блок вышли, не было, но у нас она в цикле, но мы ее
берем с вами и все равно обнуляем. Все. И вот у нас
текущее состояние nmp стало 1, 1, 0. Почему у нас 1, 1, 0?
Потому что у нас m и n не меняются, n настолько один раз
инициализируется, а p меняется. И в следующую
итерацию у нас будет следующее. Мы опять прибавим 2, 2, 1, p у нас
снова будет 0 и будет 2, 2, 0. Все, цикл больше не
выполняется, потому что у нас данный момент a уже стало 0, после этого мы пошли в последнюю
итерацию цикла. И 0 это у нас ложь, поэтому мы выходим из этого цикла, как только мы выходим
из этого цикла, мы выходим из функции, функция ничего не возвращает, и на этом мы закончили эту
работу функции и снова в нее входим уже с параметром 2. Вот параметр 2 практически дублирует нам
ситуацию, только у нас будет a равно 2, то есть мы два раза с вами будем повторять эту итерацию
в данном случае. И mnp, вначале у нас, что вообще произошло с m? m у нас новый, потому что как
только функция у нас закончил работу, m у нас с памяти удалился, то есть каждый блок
для... каждый блок у нас для функции является окончание блока, фактически, скажем так,
для переменной ее смертью, потому что конец блока, все, я больше здесь не нужен, и меня из
памяти двигают. Именно поэтому у нас с вами m заново объявляется. Единственное, кто выжил в
результате этой страшной игры, это у нас с вами n. Почему была она статической? Статические переменные
между мыслями функций сохраняют свое значение, в этом их предназначение, статическая переменная.
Вот это статик, это такая коварная вещь, мы уже рассматривали это на одной из первых лекций,
но я хочу вам напомнить о том, что мы в любом случае инициализируемся один раз и между вызовем
функции сохраним свое значение, поэтому n у нас, вот эта двойка, будет превращаться в тройку,
а m и p снова станут нулями, потому что вот он ноль, вот он ноль, и это наша первая будет
итерация. Вторая итерация, соответственно, у нас здесь будет четверка, m, которая объявлялась
здесь, прибавится, станет один, а p у нас все время рождается заново, поэтому это ноль.
p внутри блока, вот правильный был ответ, один человек написал, в основном проблемы,
конечно же, были с статической функцией, но как здесь получился минус один у кого-то,
я правда не понимаю, у нас же везде плюс-плюс, как можно было минус один, у нас может быть
перепутали, а может быть перепутали, что это а, печатается, ну хорошо, может быть,
ошибки, не важно как получены, главное, что это ошибки, главное делать их на контрольных,
ничего страшного, кто сейчас ошибся, правда, я очень ценю тех, кто вообще старается и что-то
делает и показывает, кто ничего не делает, спит или ничего не пишет, это вот намного хуже,
чем пытаться понять. Так, у нас с вами пять минут перерыв и после перерыва продолжаем обмен
информации. Так, я на перерыв прошу взять кого-нибудь вот этот супер инструмент и
нормально помыть всю доску, ладно, чтобы у нас, так, обмен информации, значит,
функция может общаться с внешним миром, есть для этого три способа, закройте дверь наверху,
пожалуйста, тоже, закройте, да, не надо нам сквозняки устраивать, итак, эпидеологическая
обстановка, мы еще сами себя тут будем, функция может обмениваться тремя способами, и самый
первый из них, самый неправильный, но в то же время он есть, поэтому мы не можем его обходить,
это через глобальные переменные, глобальные переменные, то есть в данном случае глобальных
переменных, что значит обмен информации, если функция, это нигде черный ящик, который как-то
функционирует, ему же надо как-то с внешним миром взаимодействовать, как минимум получать
значение, отдавать значение, возможно какую-то дополнительную информацию получать, как этой
функции взаимодействовать со всем внешним миром, вот способ номер один, глобальные переменные,
то есть у вас есть некие переменные, которые хранятся у нас статической памяти, они являются
глобальными, они объявлены до функ, закрой дверь пожалуйста, и они доступны везде,
кроме чего скажите, вот вы да, всегда ли доступны глобальные переменные, вот у вас есть какая-то
переменная а, и потом начинаются функции, вот эта переменная а, она во всех функциях видна или нет,
во всех, все ли согласны, а если не статик, а нам придется поставить фигурные скобки,
потому что как минимум у нас открывается фигурными скобками, поэтому как минимум
фигурными скобки у нас всегда есть, то есть если она не перекрывается, правильный ответ, да,
не надо мудрить, даже если она вне, если она просто в блоке самого мейна, то она все равно перекроет
вот эту а, и в данном случае, когда с момента ее объявления, уже у нас она будет скрыта,
этот локальный контекст скроет глобальный, и тем самым доступа к ней у нас не будет или будет,
да, у нас есть операция доступ к области видимости, теперь вопрос, а хороший вообще этот метод,
работать, получать, обмениваться, то есть вот если у нас одна функция есть, есть другая функция,
не знаю, давайте назовем ее f2, она тоже у нас может получать а, вот эту, например, это через
доступ, это просто если здесь нет ни киха, и в этом случае хороший этот метод, то есть мы можем здесь ее
менять, здесь соответственно получать, когда нам надо, потому что мы поменяли ее после вызова этой
функции, например, f2 из мейна, вот вам нравится такой метод обменной информации или он не очень
хороший считается, ну кто-нибудь скажите, наверняка же вы читали про программирование,
может в школе учились, в школе говорили, что это плохо, кто так сказал, ты из какой школы, из пятого
лицея, через дорогу, но там просто это самая сила физтеха распространяется, вы говорили правильно,
почему это плохо, как вы думаете, чем этот метод плох, на самом деле это не только в пятом лицее,
я думаю, говорили, если вы слушали, везде, это плохо, потому что это очень опасный метод,
глобальные переменные вообще надо не использовать, глобальные переменные это плохо, но почему,
все говорят, что это плохо, но почему непонятно, потому что очень легко допустить ошибку, например,
есть какая-то функция f3, которая вообще не знает о том, что f2 и мейна хорошая жизнь, они через
а решают свои проблемы и как-то там работают, а это f3 вообще писал другой программист, случайно,
может быть, не объявил или как-то там так сделал, что-то там задел эту а и все испортил, понимаете,
то есть у вас никакой защиты нет от дурака, так называемой защиты, то есть он мог даже ее не
объявлять, подумал, что он объявил, что это его локальные переменные, она, например, не объявилась
или что-то еще произошло, он пропустил эту строчку и просто написал равно 5, и оно работает,
потому что она же есть глобальная, и вы взяли и испортили вот этим товарищам передачу информации
между собой, поэтому через глобальную переменную очень в этом плане и как раз того, что мы
компсулируем плохой у нас метод, поэтому мы стараемся глобальные переменные никогда не использовать,
но, конечно, такой способ возможен, если нам очень надо, тогда мы будем с вами это делать.
Второе. Это через возвращаемое значение.
Возвращаемое значение.
Функция может возвращать значение, когда вообще функция у нас завершает свою работу,
мы
оператором return возвращаем какое-то значение, которое функция должна в соответствии с типом,
который она возвращает, вернуть. Если у вас, например, функция должна вернуть int, называется f1,
то правильно, например, написать return 1. Вы возвращаете значение равное единице в точку ее вызова.
Вот если у вас функция ничего не возвращает, вы не можете вернуть единичку, потому что это
будет неправильно, у вас несоответствие типов, то есть это нет, а если, например, у вас функция double,
f2. Могу ли я здесь вернуть 1? Как вы думаете, вот такой синтез правильный, скомпилируется или нет?
Да, почему? Приведение неявных типов правильно int приводится к double, у нас идет такое
преобразование к double. А вот давайте посмотрим теперь вот на такой пример. Пусть у меня есть
некая функция, которая возвращает указатель на int. Ведь мы же не обязательно должны
int возвращать. Можем указатель int. Ничего не принимает, но возвращает указатель на int.
Я внутри функции объявляю локальную переменную a, присваиваю ей начальное значение равное 5 и
после этого возвращаю адрес. Да, вот это у нас, напоминаю, операция взятия адреса. Не путайте
со ссылкой, в зависимости от контекста вы должны понимать звездочка и амперсант, что значит в
каком контексте. Вы же думаете, как компилятор, а значит, у вас есть как минимум какая-то логика.
И вот такой код, и завершаю на этом функцию. Вопрос, нравится ли вам это? Может быть,
есть какие-то у кого-то сомнения? Поднимите руку, выскажитесь. Кто хочет сказать, только поднимите
руку, у нас не хаос. Мы же ввели функции, поэтому они борются с хаосом в программах.
Если никто не поднимет руку, я спрошу. Вот у вас желтая, самая яркая здесь кофта,
поэтому вот вы ответьте. Да, ну опять я спрашиваю, вы не слушаете. Вот код, ничего ли вас здесь не
смущает? Хорошо, вы уже сегодня много отвечали, вы тоже. Давайте мы разнообразие ведем, чтобы все
поработали у нас. Вот вы на первой партии на этом ряду в белой кофточке, пожалуйста, да. Что вы
думаете? Хорошо, да, пожалуйста. Как вас зовут? Иван, да, расскажите. И что происходит-то? Мы с вами
создаем переменные в памяти и возвращаем адрес, совершенно верно, локальный переменный, который
сейчас удалится. Так делать нельзя, потому что вы возвращаете адрес того, что сейчас будет
уничтожено. И поэтому это код с потенциально огромным количеством проблем, правильно? Потому
что он может привести к очень непредсказуемым последствиям, поэтому так нельзя возвращать
указатель на локальную переменную. Ну и наконец, давайте рассмотрим третий, самый главный способ,
как мы будем с вами передавать информацию через параметры функций. Третий напишем через
параметры. И вот это то, на чем мы сейчас заострим свое внимание в этой части лекции,
как функция общается с внешним миром через параметры. Пока я не перешел к следующей теме,
я хотел вот здесь еще про ретурн кое-что сказать, пара комментариев. Скажите, а как вы думаете,
рентурн должен находиться в самом конце последней строчкой при работе нашей функции? Или где-то,
может, в середине тоже? Может. И что тогда произойдет, если в середине он находится? Дальнейшие
строчки за ним выполнятся? Нет, то есть он выходит досрочно. Это считается плохой стиль,
когда у каждой функции должно быть желательно одна точка входа, одна выхода. Не должно быть никаких
потайных дверей, потому что это затрудняет прозрачность этой работы функции, когда вы
анализируете, как она работает. Потому что вы когда смотрите, вы видите, что она возвращает,
а если на самом деле в середине что-то может вернуть, вам надо весь текст просматривать. Поэтому
считается, чтобы так называемого спагетти кода не было, у вас должна быть одна точка входа,
одна выхода, а не какие-то там дырки такие, которые, я не знаю, какие-то животные делают в земле и
ползают. Вы не знаете, откуда они выползают. Да, давайте еще сделаем вот это самое. Давайте.
Бак на бак это фича, а не бак уже, я понимаю. Как бы делать-то мы можем, но по правильному стилю
нет. Можно по-другому там, не знаю, ввести логическую переменную или поставить все то,
что если это, там тогда и скобочку и все остальное у тебя выполняется, а иначе у тебя просто будет
сразу ретурн вместе с ним. То есть можно так расположить, что он естественным образом пропустит
все остальные строчки, и тебе не придется, например, в else поставить все остальные строчки
внутрь else, весь тот блок, и тебе не придется, не придется, в общем, выходить досрочно. Просто
надо, чтобы эти строчки не выполнялись естественным путем. Знаете, естественная смерть должна быть,
недосрочная. Так, какой еще вопрос? Да. Не написать ничего. Да, потому что он будет
у вас автоматически, у вас будет предупреждение, вы, наверное, видите, но у вас вы можете
действительно так делать, но это считается плохой стиль, и вы должны обязательно следовать этому типу,
который вам дан для того, чтобы не просто выходить, но возвращать еще значение без
какого-то значения по умолчанию, что мейн немножко особенная функция, я расскажу,
когда мы сейчас дойдем до нее, но мы стараемся следовать хорошему стилю, возвращаем всегда то,
что нам хотят. Значит, теперь еще у меня вопрос, а как вы думаете, можно ли вообще не написать
ретурн? Можно, она естественным образом закончится, опять же, это тоже самый вопрос,
что у вас ничего не возвращается, то есть это фактически то же самое, что просто написать ретурн
без параметров, нет последней строчки, но вот что в этом случае будет, мы сейчас рассмотрим,
и параметры функции у нас бывают совершенно разные, и давайте рассмотрим это на примере,
объявим функцию, которая в себе, я такой для вас пример написал, который содержит все виды,
все три способа передачи параметров в функцию, так пусть у вас есть некая функция f,
которая принимает три переменные, переменная i у нас будет приниматься по значению,
это у нас будет по значению, подписываем себе, чтобы не путать какой есть способ,
по значению, переменная g у нас будет по адресу, переменная g и звездочка g у нас с вами будет по адресу,
мало того у нас еще будет с вами переменная k по ссылке,
переменная k по ссылке, давайте здесь даже не будем ее определять, объявление просто закроем,
и перейдем теперь к функции main, которая будет работать с нашей функцией, которую мы определим
позже, то есть это просто объявление я написал, какие типы принимаемых значаемых,
возвращаемых значений и порядок этих типов, так пусть в main у меня есть следующие переменные,
тоже i, g и k, потом у меня с вами, пусть у меня в main будет три переменные,
давайте напечатаем i, g и k, как мы вот уже с вами делали и напечатаем собственно i, g и k
на экран, какое они сейчас имеют у нас значение, и пробельчик g, пробельчик k, перевод строки,
так вот наши три переменные, теперь вызываем функцию f, первый параметр у нас передается по
значению, второй как мы говорили по адресу, поэтому надо дать адрес, это операция взятия
адреса, а третий по ссылке, ссылка является синонимом имени, просто даем то имя, синонимом
которого она является, обращаю внимание, что вот это адрес, а вот это ссылка, еще несколько слов
про терминологию, вот эти три параметра называются фактическими параметрами, давайте напишем все
фактические, фактические параметры, а вот эти три параметра называются формальными параметрами,
формальными, формальные фактически параметры не обязательно совпадают, например здесь у нас
формальным параметром является переменная, типа int, а здесь может быть какая-то константа
фактически, например пятерка, вот здесь уже константа не может быть, потому что это синоним
имени ссылки, здесь должна быть переменная какая-то, здесь какой-то адрес, он может по разному
быть также передан, поэтому формальный параметр, это то, что у нас стоит в заголовке, те типы,
которые мы принимаем, а фактически то, что будет подставляться на место, это формальных параметров
в данном конкретном вызове этой функции, фактически параметры меняются от вызова к вызову, теперь
давайте main, мы все-таки будем с вами писать, красиво, return 0 сделаем, так здесь я не могу
писать, да вы говорили здесь плохо видно, тогда наверное вот здесь, чтобы не стирать нашу часть
теперь давайте реализуем с вами нашу функцию f, наша функция f, очень важный нюанс, вот здесь я
написал i, j, k в реализации, когда я пишу определение, я могу написать совсем другие имена, вот те
имена игнорируются, они могут не совпадать с этими, чтобы совсем вас не запутывать, я напишу пока
такие же, но в принципе вы можете писать любые и браться будут в реализации именно эти, которые
вы пишете в самом определении этой функции, но типы должны совпадать безусловно, иначе у вас будет
ошибка, в объявлении определений типы должны совпадать все, что делает функция, она и увеличивает
на единичку, j увеличивает на единичку, k увеличивает на единичку, давайте функцию закроем, и я наверное знаете,
что еще сделаю, какой чит, простите, я вот эту строчку cout продублирую, она здесь тоже будет,
вот перед ретурном, чтобы мы написали до вызовы и после, можно я не буду это писать на доске,
но вы просто вставите себе еще раз печать вот этих i, j, k, то есть она у нас продублирована здесь,
вот здесь cout и после f, такой же cout, i, j, k распечатывается, и сейчас давайте тогда разберемся,
что это такое, это самое важное, понять как оно работает, для этого рассмотрим опять все то же
самое, что мы делали, у нас есть три вида памяти, у нас есть глобальная память статическая, у нас
есть стэк, есть динамическая, здесь все действие на самом деле происходит в стыке, потому что,
если когда вы начинаете анализировать, как работает программа, всегда смотрите сначала,
вот main это наше начало, первым делом заводится в стэке три переменные i, j и k, и присваиваются
им начальные значения 1, 2 и 3, не бойтесь вначале рисовать, когда вы делаете указатель ссылки,
это очень помогает пониманию, потом у вас cout и jk, но это как бы то, что напечаталось на экран,
и jk, это первая часть ответа, это было у всех правильно, это мы уже поняли, потом идет печать
и jk, ну 1, 2, 3, там тоже как бы сложно ошибиться, потому что их только что присвоили, и вы прям
сразу их и вывели, а вот дальше идет вызов вот этой функции f, и здесь интересно, как вызывается
функция f, смотрите, здесь функции вызов f по значению, это первый способ передачи параметра,
что значит по значению? Значит, я копирую значение в новую переменную, вот i, которая здесь,
и i, которая здесь, это разные переменные, вот это i находится в контексте этой функции,
поэтому объявляется внутри этой функции это i, когда мы находимся в другой функции,
мы ничего не знаем про переменные предыдущей функции. Вот это функция main, вот это функция f.
Когда работает функция f, она не знает ничего про переменные main, потому что они равны
эти функции. Это не глобальные для нее переменные, такие же локальные переменные другого черного
ящика. Вот если вы внутри черного ящика, вы знаете либо что там внутри вашего ящика, либо глобальное,
что вам сверху спустили там какие-нибудь, я не знаю, правила заповеди ваших всех черных ящиков,
и вы глобальную переменную все знаете. Можете менять там и так далее. Ну поэтому плохо,
кстати, вы менять, вы уже поняли. Но что в другом черном ящике, в соседней функции, вы не можете
посмотреть, поэтому это такие же локальные переменные. Она может что-то передать, вот она вам
передает. И первое, что она вам передает здесь, параметр, это по значению, мы просто копируем его,
и здесь создается своя переменная и, которую я могу назвать по-другому, горшок, цветок,
как угодно. Поэтому то, что она имеет одно и то же имя, ни на что у нас не влияет. Скорее только
на ваше запутывание. Вот дальше идет, и если мы эту переменную меняем, то меняется вот эта
переменная, к этой она уже никакого значения не имеет, она один раз скопировалась и все. Это передача
по значению. Поэтому вот здесь, когда в функции произойдет работа этой строчки, мы и++ увеличим
на один, но именно это и, которое находится внутри функции f. Как функция закончится, эта переменная и
радостно исчезнет, потому что она живет только время работы функции. И на экран напечатается в
следующей строчке, когда будет печатать снова и. Какое и? То, где оно печатается из main,
единичка никак не поменяется. Поэтому первый ответ это 1. Это передача по значению. Это безопасная
передача. Почему? Потому что ты можешь менять значение, пожалуйста, оно никак не испортится в
основной программе, в другой функции, откуда тебя вызвали. То есть по значению сделать копию,
я не знаю, как вот вы на своем айфоне или андроиде делаете копию фотки, чтобы там отредактировать,
если не хотите потерять оригинал. То же самое. Мы здесь что-то там с этой переменной делаем,
но оригинал остается. Это плюс, что он у нас сохраняется, минус это время. Время на копирование
и на память. Смотря какой объект, но тем не менее, вы же его каким-то образом переносите,
то есть вы его дублируете, и второе вы еще и память занимаете. Поэтому у вас в данном случае,
простая переменная, может быть сложная у нас структура, поэтому разные могут быть совершенно
у нас ситуации. В данном случае у нас, видите, эта переменная раздвоилась. А дальше второе g,
g у нас с вами по адресу. Что такое адрес? Это значит, что g, вот это g, это вообще другое g,
это просто int, который живет в мейне. А вот в функции f вторым параметром является int звездочка.
Это int звездочка, который тоже назвали g для вашего запутывания. Могли назвать вот
всем самым цветком или в чем он там стоит, и это было бы правильно, это совсем другое,
другая переменная. Это другая переменная с другим типом, она живет в f, и какое ей
дали начальное значение, то есть ее инициализирует фактическим параметром. Адрес какой-то переменной,
какой должен быть адрес, который указывать на int, это указатель на int, нам должны были дать
какой-то адрес int. Вот нам дали адрес вот этого g, и вот у нас получился указатель на это g. И
теперь, когда мы работаем с этим g, мы его разыминовываем. Здесь, видите, вот это звездочка g,
разыминование приводит нас вот сюда, и меняем уже на единичку вот это g из мейна, потому что мы
работаем через указатель. И это способ, когда мы меняем что-то во внешнем мире, то есть когда нам
дают параметры, а мы их еще меняем. Когда мы всовываем там вот руку в черный ящик, а высовываем,
она там вся обожжена. Вот как в фильме «Дюна», который я недавно смотрел. Вот, и в этом случае
мы меняем. А теперь давайте в программировании какой-нибудь пример, когда нам надо менять
параметры, которые нам передают. Жизненный пример, дайте, когда нам надо менять параметры. Самая
простой функция с двумя параметрами. Зачем им менять? Подожди, это какая-то странная функция. Я
говорю, сложи мне 5 и 8. Она не только их складывает, но и 5 и 8 меняет. И говорит, на самом деле,
у тебя было 3 и 4, и результат 7. Давайте другую функцию. Простую. ВАП совершенно верно. Меняете
значение двух переменных. Вот в этом случае, когда вы свапаете две переменные, вам дают две
переменные, и вам надо их изменить, потому что у вас суть функций в изменении значений, в отличие
от суммы. Давайте. Это был единственный способ си, старом добром си, менять переменные, которые нам
передают через указатели. И так всю жизнь они делали. И это громоздко. Почему? Здесь мы пишем адрес,
здесь нам все время надо разыменовывать. Поэтому в C++, когда он появился, как мы знаем благодаря
Strauss-труппу, и потом уже был стандартизован, появились ссылки. Как раз ссылки появились для того,
чтобы упростить изменение параметров функции, но без этого все время громоздкого синтакса
указателей. Потому что здесь теперь к у меня ссылка. Вот это к ссылка. И я передаю ей синоним
имени. То есть, на самом деле, как в матрице, доложки не существуют. Этого к здесь не существует
второго. Никакая копия не делается. Мы просто с вами работаем вот с этой переменной всегда. И когда
я буду обращаться в функции в K, то будет идти обращение непосредственно вот сюда,
потому что это ссылка. И здесь я экономлю и на синтаксисе, и на простоте, и не делаю лишние
переменные благодаря этому. И K++ изменяет вот эту переменную. И вот наш ответ 1, 3, 4. Несколько
человек его получили. Не большинство, к сожалению, но это говорит о том, что, по крайней мере,
вы не зря ходите на лекцию. И вот такая у нас картина. Теперь понятно, почему ссылка. Обратите
внимание, когда вы смотрите на вызов функции, вы не можете понять. Вот между И и К, здесь никакой
разницы. Когда вы смотрите только на вызов, вы не знаете, изменится ваша переменная или нет. То
есть вы можете посмотреть только вот сюда, если здесь по значению, если здесь по ссылке. Потому
что если по значению, она точно не изменится. Это безопасно. Если по ссылке, ее могут поменять.
Это уже опасно. Как нам сделать, чтобы передавать по ссылке, но ее не могли менять так же,
как по значению. Ну это можно сделать. То есть можно было ее отдублировать и уже свой дубликат
передавать. Если его испортят, но это был дубликат. Но это, опять же, не совсем эффективно. Зачем нам
большие могут быть разные объекты дублировать? Это и память занимает, и время на копирование.
Если мы копируем какой-нибудь массив, это от Н до К. Совершенно верно. Делать ссылку
константной. Это что значит? Это значит, что мы можем с вами совместить удобство двух этих
методов. А именно, не надо дописывать, пожалуйста, потому что у вас иначе программа не будет
работать. И вы мне скажете, что она не компилируется. Это просто конст не даст нам вот здесь вот этой
строчки поменять. Но если у нас такая ситуация, что я хочу передать по ссылке и при этом не
запретив возможность менять свою переменную, я делаю константную ссылку. И последнее, что я хотел
на этой лице вас спросить, а для чего нужны константные ссылки? Если у них хоть какие-нибудь
преимущества перед передачей параметров по значению? То есть, смотрите, значение нужно, чтобы вы точно
не меняли объект, вы делаете его копию, с ним работаете. Константная ссылка тоже самая. Она
хочет, чтобы вы не меняли объект, поэтому вам этот объект передают, чтобы вы его не могли изменить.
Но у этого метода, возможно, есть какое-то преимущество перед классическим методом 72 года. Да.
Подождите, у вас в этом и суть, что вы не меняете элементы. Но что лучше-то? Да, пожалуйста.
Мы не копируем элементы, мы работаем с тем же самым элементом, просто заключив его в капсулу,
что его нельзя менять. Мы не просто даем дубликат, говорим, делайте с ним что хотите, а мы даем то
же самое область памяти, где лежит исходный объект, но просто запрещаем его менять. Этим
константная ссылка нам более эффективна. Да. Конечно, в этом и есть разница. Вот ответ на
этот вопрос, что мы не тратим время и память на копирование элемента. Но это способ только был
C++, C его не было. Я, честно скажу, я как бы не считаю, что и C там не надо изучать. Это вот такие
религиозные споры, лучше C или C++. Я считаю, что надо все знать. Но было бы странно, если бы я вам
рассказал только указатели и не сказал, что дальше как бы происходило с человечеством. Но у нас еще
будут последние лекции, где мы с вами еще затронем и умные указатели, то есть развитие языка не
останавливается, поэтому постепенно мы с вами все методы изучим. Но в данном случае ссылка,
конечно же, облегчила жизнь. И вы можете передавать по ссылке, вы можете передавать по адресу и по
значению. Мы будем все способы зависимости от задачи использовать, но вам надо будет уметь
работать совсем. И, например, когда вы будете писать декартовые деревья, вы прочувствуете указатели,
у нас будут многие задачи на указатели, связанные со структурами данных, например, списки. Поэтому вы
попробуйте все способы своей жизни. Все, мы делаем с вами большой прерыв теперь между лекциями.
Насколько по расписанию должен быть прерыв? Десять минут и возвращаемся сюда. Лекция номер
девять. Значит, давайте краткое содержание предыдущих серий. Такой у нас будет рекэпда.
Мы с вами изучали функции. И главное, что мы говорили, что функции необходимы для инкапсуляции и
структурирования нашей программы на какие-то отдельные блоки, которые друг другом непосредственно
не связаны, а общаются с внешним миром тремя способами и между собой. Это глобальные перемены,
не очень хороший способ. Через возвращаемые значения ретурн. При этом мы сказали с вами о том,
что у нас по-хорошему должна быть всегда одна точка входа и одна точка выхода, чтобы функцию
можно было легко анализировать. И поэтому нежелательно выходить из функции досрочно.
Если вам надо выйти досрочно, то можно написать так свои условия, чтобы какие-то строчки не
выполнялись. Молодой человек, закройте там окно, пожалуйста. Я не хочу сам уйти на карантин
досрочно. Еще важно, что функция должна возвращать значение. Значение должно быть такое же,
как в заголовке. То есть то значение, которое должно возвращаться, должно быть в соответствии
типов, либо неявное преобразование. Возможно, как в нашем применении Sintu Wind Double.
Если значение не совпадает по типу, то это будет ошибка. Если ничего не возвращается, вот у нас
был, кстати, интересный вопрос. Давайте на него кого-нибудь спросим, а я скажу прежде чем правильный
ответ. Если ничего из функции не возвращается, вот у вас просто есть функция, я вообще не написал
ретурн. И, кстати говоря, это тоже так на экзаменах могут спрашивать. И вот вам вот конкретно иногда
даже специально дают меньше входных данных. И задают такой вопрос, посмотреть, как вы мыслите,
сдадите ли вы уточняющие вопросы или сразу дадите ответ. Вот вы, молодой человек в белой кофточке,
да. Вот вы не оборачивайтесь, это вы. Как вас зовут? Миша. Нет, Максим, нет. У вас белая кофточка
далеко, вот у него поближе. Вы на одной линии, но почти. Михаил, скажите, так можно из функции
не делать вообще ретурн, нигде его не написать? Ну, это вопрос некорректно поставленный. Надо
сейчас кучу всего переспросить. Во-первых, смотреть, с какой функции. Что значит,
из какой функции? На что нам надо посмотреть? На тип возвращаемого значения, да. Если это void,
окей. Теперь, ну, если она ничего не возвращает. Но это не полный ответ. Какой у нас еще есть особая
функция? Вы еще спрашивали про нее, а почему вот в этой функции можно? В стандарте C++ 2009
написано, что если из Main ничего не возвращать, то вернется ноль по умолчанию. Но это только в
Main. И это считается плохой стиль, поэтому лучше мы будем с вами писать и не делать этого. Хотя
из других функций, конечно, этого делать нельзя. Возвращаемое значение, способ обмена. И, наконец,
третий самый главный способ обмена. Это через передачу параметров. И там у нас было три вида
параметров. По значению, по адресу и по ссылке. И мы говорили, что по значению это копирование
объекта. И с этим объектом можно делать все, что хочешь. Он никак не связан с исходным объектом,
когда мы его передавали. Исходный объект не меняется, при этом вы не можете с помощью этого вернуть
какую-то информацию. Вы можете только получить такой досторонний канал связи. По адресу вы можете
и получить, и вернуть, потому что вы его получаете через адрес, через указатель, и меняете,
соответственно, через этот же указатель. Тем самым, с места вызова вашей функции у вас изменение
объекта происходит. Например, если у вас функция меняет значение двух переменных. И, наконец, третье по
ссылке. Когда мы говорим, что это практически предыдущий способ с улучшенным синтаксисом и
с экономией памяти. И после этого мы с вами рассмотрели константные ссылки, которые на самом
деле очень важны в том плане, что если мы не хотим менять объект, но хотим иметь преимущество ссылок,
не расходовать лишнюю память, не делая копии объекта, есть так называемые константные ссылки.
Вот метод передачи по константным ссылкам у вас будет очень частый в объектно-алитированном
программировании. Вы прям будете видеть его сплошь и рядом. Вот это конст какой-то тип, там, амперсант,
это будет то, что вы будете писать так часто, как даже сейчас все не представляете. Поэтому эти
методы, разумеется, будут очень часто вами использоваться. А сейчас давайте рассмотрим маленькую,
следующую подтему, связанная с функцией передача массива в качестве параметров.
Передача массива в качестве параметра. Передача массива в качестве параметра.
Массив всегда передается по адресу, передается указатель на его первый элемент. Другого способа
передать массив C++ нет, поэтому если я хочу передать массив, я должен дополнительно к
этому массиву передать информацию о количестве элементов этой массивы, потому что просто адрес
на первый элемент массива мне не даст полную информацию о самом массиве. Мы сейчас говорим
только о классических массивах, мы говорим про векторы, другие остейлевские контейнеры,
это все у нас будет позже, сейчас мы говорим именно о массиве. Пусть у меня есть некая функция
сумма, которая находит сумму элементов массива. Если я хочу получить массив, я с вами завожу
указатель на int, это будет указатель на первый элемент массива. И дополнительная информация,
которая мне нужна, это количество элементов в данном массиве. Это функция ищет сумму, она обнуляет
счетчик, проходит по всему массиву. Мы передали информацию, что в массиве n элементов, поэтому
это n мы можем вот здесь использовать и, складывая все элементы, находим сумму с помощью сокращенного
оператора пресваивания, операции пресваивания. Возвращаем с вами обязательно результат, если не
вернем, у нас будет ошибка, это не функция main. Вернули результат, теперь как работать с данной
функцией. Нам нужна, например, функция main. В этом main мы можем завести какой-то массив
из пяти элементов. Присвоить ему начальное извачение и вывести сумму этого массива,
вызвав функцию сумма с двумя параметрами. Адрес имя массива мы даем, который является, как вы
помните, адресом первого элемента этого массива, нулевого, мы говорим первого, понятно, что нулевого,
то есть начало этого массива в памяти. И количество элементов в нем, это у нас параметр по значению,
здесь может быть константа, может быть выражение, в отличие от других способов, когда мы с вами на
припасылке, здесь не может быть константа или выражения, поэтому можно придать константу 5,
хотя стиль программирования, конечно, плохой, магические числа, мы говорили, так не делать,
надо бы сделать было константу, но именно такой учебный скорее пример, и тем самым мы печатаем
сумму на экран. Ретурноль напишу, буду занудным, но хороший стиль. Вот у нас с вами есть такая
способ, могли бы здесь написать еще по-другому, просто другой синтаксис, показав, что это именно
будет передаваться массив, это тоже указатель для компилятора, не будет иметь никакой разницы,
такой способ и другой способ. Теперь давайте более, еще один сложный, рассмотрим вопрос,
ну не сложный, у нас пока все просто, это передача имен функций в качестве параметров,
передача имен функций в качестве параметров, давайте здесь его сделаем, передача имен функций,
давайте просто даже передача функций, напишем грамм, функций в качестве параметров.
Пусть у меня есть некая функция, которая ничего не возвращает,
функция f, которая принимает один параметр int, я ее сразу же определю эту функцию, в ней будет
ровно 0 строчек внутри. Теперь сделаем указатель на функцию, помните у нас была проблема курицы
и яйца, когда мы изучали указатели, нам надо было пройти указатели на функции, а функции мы еще не
знали, ну вот сейчас мы может быть немножечко, если кто-то тогда не понял, будет понятнее,
что такое указатель на функцию. Мы по правилу, когда такие сложные конструкции видим, всегда с вами
действуем по следующему правилу, мы уже подобный пример с вами рассматривали, мы находим сначала
переменную, вот она переменная, это точно не ключевое слово, int это ключевое слово, void ключевое
слово, переменная не может быть ключевым словом, поэтому легко понять, что переменная, то что не
ключевое слово, это переменная. Теперь действуем по правилу, что это такое указатель, доходим до
первой скобки видим, что здесь ничего нет, значит, доходим до этой по правилу
право-лево. Это указатель на что? Дальше идем направо на функцию, которая
возвращает, принимает int и возвращает void. То есть pf это указатель на
функцию, которая принимает int, возвращает void. Вот такая, например.
Это одна из таких функций, которую я могу написать, которая принимает int,
возвращает f, то есть pf может быть указателем на f. Ну давайте я ее
собственно и присвою ей f. Я не одну функцию присвоил другой, а это на самом
деле самый простой синтаксис. Можно было бы написать вот так с точки зрения
языка, это одно и то же адрес начала функции в памяти. То есть я могу как бы
написать операцию взятия адреса, а могу написать просто как и с массивом то
же самое. Связь функции указателей тоже все плюс-плюс очень простая. Имя функции
это адрес этой функции, и мы просто в этот адрес присвоили этот адрес. И
теперь самое интересное, для чего этот указатель нужен. Я могу эту функцию
вызывать не через ее имя, а через указатель. То есть у меня есть некая
функция f, здесь какие-то строчки кода. Я завел указатель на функцию, которая
указывает на начало этой функции. И теперь если я вызову pf, то вызовет cf.
С теми же самыми должен быть параметром, разумеется, потому что указатель у нас
типизированный, он указывает не на все функции, а только на конкретную, которая
принимает int и которая возвращает void. Иначе как компилятору проверять
правильность, когда он будет компилировать всех параметров.
Зачем надо? Я услышал вопрос, я расскажу. Это не бред, это нужно. Не думайте, что люди
делали это, чтобы усложнить вам жизнь только на колоквами. Нет. Например, я
могу вызвать функцию f на самом деле через указатель, можно было вызвать по
другому. Можно было бы разыменовать указатель, да, вот так бы дойти до
значения этой функции и дать значение. Но так не пишут, поскольку первый
синтаксис проще. Но он корректен, и первый, и второй синтаксис. Но давайте в
качестве ответа на то, зачем это надо, я приведу вам пример. Давайте вот на этой
доске объявим тип. Итак, type-def сдаёт некий пользовательский тип. Пусть у меня
тип-f это указатель на функцию, которая принимает int, возвращает void. pf это имя
нового типа. Теперь я могу использовать просто как тип. Давайте я создам функцию f1.
Давайте сейчас чуть легче напишем, чтобы вас сразу не путать. Простите,
это я сотру, это будет следующим нашим усложнением. Сейчас придумаю простой пример.
Пусть у меня будет массив. Называться меню. Некий массив, тип которого pf, а pf мы
только что создали. Что это такое? Это указатель на функцию, принимающую int,
возвращающую void. Массив таких указателей на функцию. Здесь нет количества элементов,
потому что мы сейчас явно пронициализируем какими-то функциями. С именами new, open, save.
Мы с вами конструируем меню в какой-то программе. И в этом меню будут у нас действия. Нажал
пользователь new, новое окошечко в варде, нажал open, открывается файл, нажал save,
сохранился файл. У нас есть такие три функции, которые делают этот функционал.
Адреса этих трех функций мы записали в массив указателей. Теперь, если я хочу вызвать какую-то
функцию в зависимости от сценария пользователя, я могу вызывать ее не зная имени. И это самое
главное для чего это делается. Я могу вызвать, например, первую функцию из них. Open с параметром 10.
Теперь у меня легко логику не привязывать к именам. Я могу программировать абстрагируешься от имен,
заменив имена номерами. И это очень удобно, потому что я могу это делать в цикле. Я не
могу new, open, save писать в цикле какие-то слова, правда? А номера могу вызвать все эти элементы.
Именно поэтому я могу от имен перейти, например, к номерам. Поэтому нам полезны указатели. Это
один из примеров, когда это можно сделать. Ну и давайте сейчас, как обычно, в конце какой-нибудь
под темой у нас, как всегда, пример чуть сложнее. Опять объявим некий тип type-def,
где у нас pf, это указатель на функцию, которая принимает int, возвращает void. Сделаем теперь
функцию f1, которая принимает переменную pf типа pf. pf маленькое имя переменной, pf большое имя типа,
которое мы сами сконструировали. pf это указатель на функцию, принимающую int, возвращающую void.
И эта функция будет через свой указатель pf, через эту локальную переменную вызывать
что-то там с параметром 5. Поскольку функция возвращает void, это ничему не присваивается,
и возврат идет при корректный вызов, поскольку 5 это как раз int. С типами все хорошо. Теперь давайте
void f int cout i. В данной функции f мы просто выводим на экран то, что нам передали. Теперь делаем main,
и вызываем функцию f1 с параметром f. Мы должны передать в качестве параметра указатель на
функцию, которая принимает int, возвращает void. Вот мы даем такой указатель по вот этому способу,
что у нас имя функции является одновременным адресом начала функции, и подставляем функцию f.
Таким образом, f будет указывать в данном вызове на функцию f. Мы можем в другом вызове, понятно,
по-другому. И как будет работать это следующая строчка в f1, когда мы вошли внутрь, это вызов
функции через указатель pf. В данном случае нам он указывает на f, поэтому f вызовет с параметром 5,
и на экране будет 5. Вот такой сложный способ получить пятерку. Какой еще раз вопрос? Объявляет
новый тип для того, чтобы вы просто в синтаксе, если каждый раз не писали эту мантру, то вот как
здесь я объявляю, чтобы f не объявить, надо написать все время вот этот тип, а мне он здесь нужен
как минимум вот здесь, и я просто упрощаю себе синтакс и считаемость кода. И мне понятно,
что это, и легко читать заголовок функции, то есть pf это новый тип данных, то есть я могу делать так
называемые пользовательские типы данных. Например, я вот обозначил за какой-то тип,
назвал там pf, мог назвать его Вася, и будет тип Вася у вас. Вы можете свои типы делать из
существующих и называть их как-то по-своему, чтобы вам было легко читать этот код. Так,
давайте следующий маленький подпункт. Возвращаемое значение по ссылке. Это очень
интересный пример, который я вам хочу рассказать. У нас было однажды контрольное, я вам рассказывал,
что уже много лет я преподаю на фистехе, и наш поток, собственно, я и создал, и в одной из первых
лет у нас была такая контрольная, где был такой вопрос, который очень понравился студентам,
они очень хихикали. А именно, в каком необычном месте может стоять вызов, может стоять функция?
И все догадались, что это за необычное место, какой-то странный вопрос. Вот это
как раз то самое необычное место, может, мы это плохо сформулировали. Где может
использоваться функция? Так, внимание на экран. Что же такое? Итак, пусть у меня есть глобальная
переменная X, я пропускаю подключение библиотека, обращаю ваше внимание, подключение пространств
имен, потому что мы с вами пишем только мясо, суть. Но мясо программы, это самое главное,
как у вас главное мясо, зачем нам жир-то? Вот эти include, это все так, это не суть. И еще давайте
сделаем такое определение, пусть у меня будет функция setX, не принимать параметров,
а возвращать ссылку на int. Так тоже можно. Мы возвращаем ссылку на int. Меня очень радует,
когда на наши лекции приходят, сначала они думают, что они все знают про C++, некоторые,
кто уже писал A+, B, и им кажется вот, но когда начинают погружаться, оказывается, есть чуть
больше чем. Нет, я понимаю, что те, кто никогда не слышал о C++, у вас, конечно, вынос мозга,
но вы извините, надо было поступать другой вуз. Делаем функцию main. И в функцию, вызов функции,
располагаем в необычном месте, в том самом, которое в тот год всем вынесло мозг, никто не
догадался, ну потому что, может, правда, был вопрос криво сформулирован, но не знаю,
мне нравилась эта задача. В левой части оператора присваивания мы пишем setX, вызов равно 92. Так,
как бы, редко кто-то делает. И это корректный синтаксис, вызов функции с левой части в данном
случае, это lvalue у нас. Почему? Сейчас разберемся. Так, вызвали функцию, распечатаем теперь x,
и напишем return 0, и напишем теперь саму функцию, вот здесь, реализацию нашей функции. И так,
определение пишем, функция setX. Тоже самое, у нас параметров нет, есть возвращаемые значения по
ссылке, и она возвращает глобальную переменную x просто. Давайте даже для интереса, вот здесь
тоже напечатаем этот x до и после этой функции, до вызова и после меняет, как она меняет. Итак,
смотрите, что здесь у нас. Смотрите, у нас функция возвращает ссылку, ссылка это синоним имени,
на какое имя она вернула нам ссылку, глобальную переменную x, вот на эту. То есть, этот setX на самом
деле будет ссылаться в данном случае на x, поскольку функция возвращает ссылку, она вернула ссылку на x,
и к x присвоится 92. Именно поэтому от 0 мы поменяемся до 92. Вот, и если вы думаете,
что это нигде не используется, это используется. Мы будем это использовать, например, в перегрузке
операций, когда будем писать класс многоугольник и для доступа к индексу. То есть, это реально
используемые вещи, такой синтаксис нужен, и когда мы присваиваем в левой части элемент массива.
Вопрос, мог я здесь написать return 3? Нет, почему? Непонятно, какому имени ему стать
синонимом. То есть, он должен быть синонимом имени. Если я синонимом имени человека,
я не могу привязаться к столу. Поэтому у нас с вами 3 нельзя, и здесь ему нужно было, как только
конкретная, существующая переменная. А можно было сделать локальную переменную x, она бы скрыла
глобально, и вот так. Что? Она погибла, а мы пытаемся ей присвоить. Тоже неверно. Но ВОП будет
больше применение данного факта, просто обратите на это внимание. Теперь давайте следующий маленький
подпункт про функции. У нас много будет таких вот сегодня. Я вам говорил, что функции — большая тема,
поэтому ее на две лекции с вами изучаем. Встраиваемые функции. Итак, следующая подтема
про функции — встраиваемые функции. Встраиваемые функции. Иногда функция вызывается и пишется,
на самом деле, для того, чтобы упрощать нам синтаксис, хотя она очень простая. Ну давайте приведем
пример. Пусть у меня есть функция float, которая считает среднее значение двух чисел. Она дает,
перенимает 2n, x, y, и поскольку среднее значение может быть не целым, мы сделали тип float и
возвращаем просто с вами их среднее значение. Для приведения типов, обращаю внимание,
используем 2.0, чтобы деление не было целочисленным. Итак, мы сделали среднее значение двух чисел и
вернула эту функцию. Теперь есть функция main, которая будет использовать эти вызывы. Объявим
несколько переменных, a, b и c, присвоим им начальные значения. Ну и теперь давайте будем
использовать нашу функцию average, которую мы уже написали, чтобы ее поэксплуатировать. Не зря же мы
ее писали. Итак, cout. Наша функция от a и b. Можно ее дальше продолжать вызывать. Напечатаем теперь
от b и c, от a и c, ну и так далее. То есть я могу же несколько раз в программе вызывать эту функцию.
Как вы думаете, что здесь не очень эффективно? Ну, для одной переменной типа int не будем
заморачиваться. Это эффективно на больших объектах. Что-то другое. Это что у вас такое? Это делает вас
умнее? Или вы готовитесь к спасвяту в субботу? Итак, что еще вообще, когда функция есть,
не совсем эффективна с точки зрения вызова функции? А вы что делаете с своим телефоном?
Что? А он у вас увеличитель? Я думал, вы там ответы ищете. Это, извините, это реакция.
Преподаватель, когда много работает, он уже сразу смотрит на студента, уже сразу думает,
как он пытается списать данный момент, даже если он не на экзамене. Инстинкт. Вот. Так,
ну что вот функция? Почему вы много раз вызывать функцию не очень хорошо? Да, молодой человек,
пожалуйста, как вас зовут? На последней партии как? Не слышу. Иван. Хорошо. Рекурсии здесь нет,
мы просто ее вызываем с вами несколько раз. Но каждый вызов, что нам стоит? Давайте по другому
вопросу. Что нам стоит вызов функции? Он что-то стоит или нет? Почему вызов функции это время?
Кто может объяснить? Давайте для этого посмотрим, как функция вызывается вообще. Кто такой вызов
функции? Спустимся чуть-чуть ниже, представим себе, что мы компиляторы, мы наш код переходим,
переводим машинный код, и нам надо это скомпилировать. Вот мы шли по строчкам. У нас
была строчка, строчка, строчка, строчка. Потом хоп, в этой строчке вызов функции. Вот здесь какая-нибудь
функция F со строчками. Что ему надо сделать? Ему надо сюда перейти. Может просто перейти,
или ему надо что-то еще перед переходом сохранить? Во-первых, где он был? Правильно,
это очень хороший ответ. Прежде чем куда-то переходить, запомните, где вы были. Ему надо
сохранить адрес возврата, так называемый, чтобы, когда функция ретурном тут вышла в
какое-то месте, он знал, куда вернуться, куда это сохраняется в стейке перед вызовом функции. То есть
тут хоп, новая в стейке запись, адрес возврата. Еще что-то надо ему сохранять перед тем,
как он туда провалится. Есть у процессора так называемые регистры. Это так называемая самая
быстрая память, которая используется для ускорения вычислений и много чего. И этот
это называется контекстом процессора. И контекст процессора надо тоже ему сохранить,
прежде чем он уйдет отсюда. Потому что здесь эти переменные с этим контекстом работают. И тут
он ушел, вернулся, ему все поменялось. Это вот как я отвернулся к доске, повернулся, а здесь все в
одежде из игры кальмаров. Вот. И вот чтобы этот контекст не поменялся, мы с вами должны сохранить
его перед вызовом и вернуть ему, чтобы эти строчки вообще не заметили, чтобы в них выходили,
или заходили. Что все было для него как есть. Вот как я был, вот так у меня все лежит на столе,
ничего не изменилось. Неважно, что тут функция какая-то в это время вызывалась. Она тут бегала,
не знаю, сломала мне стол, выпила мою воду, но мне, когда я повернулся назад, все вернулось. Вот
этот контекст сохранен. И это время. Это время на копирование. Сначала из регистров в стэк,
потом из стэка в регистры. Плюс вот эти переходы. А ради чего это время? Ради вот этой строчки,
ради вот этого выражения. Если бы функция была серьезная, мы ради нее такую подготовку сделали,
а внутри функции всего лишь два числа складываются, делится на два. Но если я вот здесь буду писать,
х плюс у делить на два ноль, х плюс у делить там на два ноль. Но это, конечно, тоже не дело,
если буду дублировать это. Поэтому встроенные функции, это те самые функции, которые обладают
преимуществом функций с точки зрения того, что вы инкапсулируете код, вы его повторно не пишете,
он у вас один раз написан. И при этом она не вызывается вот по этому методу. Что значит не
вызывается по этому методу? Это значит, что когда компилятор компилирует, он в этом месте просто
тело функции подставляет. Фактически здесь напишут эту формулу. И здесь напишут эту формулу. Не будет
делаться вызовов. То есть функция встраивается в текст, и это называется встроенная функция.
Чтобы она такой стала, давайте до float напишем слово inline.
Inline.
Inline. Это если у меня только одно определение. Inline – это как бы все-таки просьба. Это не
указание. Это указание, что вы хотите это сделать, но компилятор сам решит,
может он это сделать или нет. То есть это просьба на то, что встройка мне эту функцию. Что плохого?
Код растет, потому что вместо вызова у вас теперь весь код. Если здесь 10 строчек,
здесь будет 10 строчек, здесь 10. То есть сам код растет, потому что вы ее встроили. С другой стороны,
нет затрат на ее вызовы. Вот здесь у нас просто написано определение. Если бы у вас было
объявление, потом определение, вы можете написать в любом месте. Обычно пишут в объявлении эту
функцию. И то же самое, кстати говоря, со статик. Когда мы делаем функцию статик, мы тоже можем ее
объявлять не везде, но надо как минимум в первом объявлении по стандарту сделать ее статик. Если
вы сделаете втором, это будет ошибка. Несмотря на то, что Visual Studio, например, эту ошибку не дает,
по стандарту это ошибка. Но я вам уже говорил, что Visual Studio – это тот компилятор, который немножко
портит программистов. Он там обнуляет, что не должен, не дает ошибку, когда надо. Потому что он
гнуси++ более следующий стандарту компилятор, поскольку он как раз… А Microsoft, она немножечко вас
расслабляет. Но это неважно. Это такие нюансы. Главное, что вы должны понять, что можно в первом
месте объявить, а потом нет. Следующая наша по тема – аргументы по умолчанию. Ну или параметры
по умолчанию. Давайте напишем параметры, как мы сегодня говорили. Параметры по умолчанию.
Это еще одна интересная наша тема на сегодня. Пусть у меня есть какая-то функция.
И в этой функции у меня есть два параметра. Первый – обычный int, а второй – не совсем
обычный, а со значением по умолчанию. Теперь я могу эту функцию вызывать разным способом. Могу вызвать
обычно с двумя параметрами. Не знаю. А могу вызвать вот так. И это правильно. Потому что если
я не дал второй параметр, то по умолчанию подставится ноль. Вот что значит функция с
параметрами по умолчанию. У вас есть некие параметры, которые заполняются значениями по умолчанию
и в зависимости от того, что вы написали, будет либо ноль, либо тот параметр, который вы передали.
Давайте еще одну такую функцию со значением по умолчанию напишем. Например, функция f1.
int равно 100. Это прототип, обращаю ваше внимание. Мы пишем сейчас объявление, но не определение.
Здесь интересная особенность синтеза. Сейчас звездочка пробел равно нулю. Потому что если
я хочу дать указателю на char параметру по умолчанию ноль, я должен делать пробел. Если
этого не сделаю, у вас будет сокращенное умножение умножить равно. Сокращенное
присваивание с умножением. Он не разберет лексему. Иногда надо расставлять пробел,
чтобы понимать компилятор, что вы хотите от него. Теперь у меня есть функция f1, которая будет
где-то ниже у нас определена. Это только объявление. В объявлении можем не указывать
имена переменных. В определении мы все определим и напишем ее тело. Как мы будем вызывать эту
функцию? Для вызова, кстати, нам не нужно пока определение. Можем вызов делать до того,
как оно сделано. Компилятору главное до вызова увидеть объявление, чтобы он мог проверить
корректность вызова и уже подставлять адреса. Такой вызов допустим. Вы даете f1, один параметр,
первый, он обязателен, и два следующие у вас необязательные параметры. Можно с двумя параметрами.
А и 10. Тоже корректно. В этом случае третий параметр вы не даете, он будет у вас каким-то
инициализирован нулем. А, 10 и наше любимое слово из пяти букв, как вы помните,
матан в прошлых серии. Значит, а, 10 и матан. Значит, у нас с вами все три параметра заполнены,
незначение мы по умолчанию. Вот задали вопрос, можно ли написать так. Я как раз хотел рассказать,
но ты молодец, ты чувствуешь, смотришь прямо в глаз, а не в бровь. Итак, вот у вас а, он не хочет
второй давать, но матан он не может бросить, поэтому третий он хочет. Я, кстати, не знаю,
по-моему, на записи мне сказали, я не смотрел записи ни разу, вопросы, которые вы говорите не
слышные, поскольку петличка далеко, это правда? А, ну, значит, надо ходить на лекции, чтобы слышать
вопросы. Зато вы слышите ответы и должны по ним восстанавливать, какие были вопросы. Значит,
в данном случае был вопрос, можно ли пропускать параметр. Нет, нельзя. Это неправильный синтаксис,
не компилируется. А вопрос к вам меня, почему так сделали сознательно разработчики стандарта?
Почему они в параметрах по умолчанию запретили пропускать? То есть правило какое здесь? Если ты
пропускаешь какое-то, дальше ты обязан все остальные тоже пропустить. То есть если какое-то
ты не указываешь параметры больше, все остальные тоже не указываешь, они тоже все будут правее
по умолчанию. Это правило было сделано сознательно. То есть нельзя вот такой вызов сделать f,
a, 5 запятых, там b. Уже вы догадались, наверное, для чего, чтобы вот эти запятые не пересчитывать.
Знаете, когда я как-то в вербанке счет пересчитывал, ноль, ноль, ноль, ноль, ноль, там сколько этих
ноликов, не ошибиться. Сложно, когда вы видели, когда вот этот номер счет, и вам надо его написать,
и там вот эти 8 нулей подряд, ты пальцем водишь, сколько же там нулей. Чтобы то же самое здесь,
чтобы то же самое здесь у вас не пересчитывать запятые и пропустив запятую не тот параметр,
подставив, потому что ты там не 9, а 8 сделал запятых, просто решили, чтобы люди не страдали этим
разом запретить так делать и все. Залог ошибок это потенциальный, поэтому запретили. Это вот что
касается правил. А теперь еще у меня к вам вопрос, как вы думаете, зачем это надо, зачем вообще
параметры по умолчанию могут быть полезны? Кто даст какую-нибудь версию? Не было бы параметров
по умолчанию, все было бы хорошо, а тут коп, какие-то параметры по умолчанию появились. Ну а зачем
тогда его делать, если он не нужен никогда? Если он всегда ноль у вас практически, тогда и не нужен
почти всегда, но есть более разумные объяснения, для чего они точно нужны. Да, я хочу, чтобы кто-нибудь
догадался, у вас 100 человек и 100 человек точно должен один быть почти разработчиком C++,
родственником дальним страус трупа, по пятым пожатию руки в фейсбуке, да?
Не совсем. Давайте подумаем о совместимости. Смотрите, вы написали какую-то библиотеку.
Чтобы никто не знал, какие значения, тоже плохо, потому что, ну как-то только разработчики знают,
что по умолчанию. Нет, смысл был… Это уже ближе. Смотрите, вы написали какую-то функцию в своей
библиотеке. И эту библиотеку используют миллион программистов по всему миру. Это самая лучшая
функция. Все купили, заплатили вам по доллару, там, не знаю, вашу библиотеку в AppStore, вы стали
богаче Цукерберга, и вообще все хорошо. А потом вы решили заработать еще больше денег и написали
новую версию этой функции, которая чуть более совершенно делает еще больше, но ей надо чуть
больше параметров. Если вы просто добавите параметров, у вас в новой библиотеке она будет
работать, а со старыми, которые не знали, что вы ее обновили, совместимость потеряется, поскольку
они вызывают двумя параметрами, а у вас уже три. И чтобы была совместимость со старыми версиями,
вы можете просто добавить третий, как пример, по умолчанию и видеть, что если вас вызвали со
двумя параметрами по умолчанию, значит они используют там старую версию или поставить тот,
который не испортит вам новую версию. Вот для чего делается, в том числе, в первую очередь для
обратной совместимости, потому что важно, чтобы код не только исполнялся вот в этой конкретной
версии. Вы же когда новую Windows 11 устанавливаете, у вас не перестают приложения, которые были для
Windows 10 работать, и вам надо все заново там покупать. Это было бы очень странно, поэтому обратная
совместимость с вашими программами и с библиотеками, для этого делаются такие вещи.
И переходим к следующей нашей теме, перегрузка функций, перегрузка функций.
Перегрузка функций.
Давайте запишем определение. Перегрузкой функций называется использование нескольких функций
с одним и тем же именем. Перегрузкой функций называется использование нескольких функций с одним
и тем же именем, но с различными типами параметров.
Но с различными типами параметра.
Пусть у меня есть функция максимум, которая ищет максимум из двух чисел,
принимает два int, возвращает тоже int. Допустим, я хочу сделать еще одну функцию максимум,
но которая принимает не int, а например, принимает две char звездочки, указатель на char,
и эти две строки у нас будут, ищет максимальную строку по длине, какая длинее, и возвращает эту
строку. Я бы должен был бы к вами делать другую функцию, но это неудобно. У меня так слова закончатся.
Пусть у меня будет такая же функция с тем же именем, но с другими типами параметра. Это называется
механизм перегрузки, который у нас в C++ есть. А именно, я возвращаю функцию, возвращаю значение
с функцией char звездочка, тоже называю ее max, но здесь у меня уже другие параметры, другие типы
параметров char звездочка и char звездочка. Это подстрока наибольшей длины. А давайте я сделаю
следующее, например, возьму функцию, которая мне находит максимум из моего числа и длины строки,
и возвращает это число в качестве ответа. Еще один пример я придумал, когда я могу
использовать функцию max, но и наоборот, max из длинной строки числа тот больше, какое число больше,
то и вернется в качестве результата. Теперь в основной программе пусть у меня будет какая-то
функция f, которая принимает следующие параметры int a, int b, char звездочка c, char звездочка d. Вот у
меня есть некая функция, которая сейчас будет вызывать наши перегруженные функции. Я могу вывести на
экран max из ab, идет вызов первой функции, потому что a и b у меня int. Из этих четырех функций компилятор
выберет подходящую по параметрам. Выберется первая int, int. Дальше max из cd,
выберется вторая char звездочка, char звездочка. Дальше max из ac, понятно, что вызовется третья
int и char звездочка, и max из cb вызовется четвертая. То есть я вызываю разные функции, но использую одно
и то же имя. Это позволяет мне оставаться в том синтаксисе, в котором я работаю, потому что в старом
добром си не буду ничего плохого говорить про си. Прекрасный язык. Все-таки си плюс тус просто устранил
эти недостатки, которые все были. Нельзя было все продумать изначально. Как там называются у вас
функции? У вас есть функция abs, которая до перегрузки, как это было, abs возвращает у вас
абсолютное значение. Поскольку у нас по расписанию заканчивается, это заглядывают, а то меня сейчас
придут, наверное, выгонять. Вот сейчас в 25 все-таки или в 30? А в следующем во сколько начинается? А у них
5 минут, окей. Abs для int. Например fabs, абсолютное значение. Может быть вы встречали такую функцию
для вещественного числа, для дабла. Для комплексного там было caps у нас, для long было abs. И поскольку
нет когда перегрузки, нам надо придумывать новые имена для разных типов. И это, конечно же, жутко
неудобно. Именно поэтому перегрузка устранила у нас вот эти проблемы. Просто можем теперь писать
одно имя и в зависимости от того, с каким параметром вы вызываем, компилятор то или другое значение
подставляет. Теперь важный вопрос. Как вы думаете, на выбор, на выбор вот когда происходит так
называемый resolution, разрешение с точки зрения компилятора, какую именно функцию выбрать,
потому что у него 4 max вы вызываете, ему приходится подбирать. На что он смотрит? А именно, а можете
закрыть дверь, пожалуйста? Что же такое это? А охрану будем ставить, чтобы следующая лекция по
истории нас не вытесняла. У нас еще время. Ну, по-моему. Значит, на что мы будем смотреть? Вот на это
или на это тоже? Вот вопрос. Только на входные данные. Мы игнорируем значение, мы не знаем.
Тиаути это неважно, это отличный пример как раз, когда мы не можем анализировать выходное значение,
потому что некоторые, когда пишут перегрузку, думают, ну я же присваиваю int, а я присваиваю
чар звездочки в данном случае эту функцию. Почему он не смотрит, куда это присваивают? Да потому что
он не может все, он как бы не анализирует, что вы дальше с этим делаете. Он только вызывает функцию и
все, а дальше вы можете это печатать, можете куда-то присваивать, можете вообще ничего с этим делать,
это никак не влияет. Поэтому вот это значение левое, то есть возвращаемое значение, не участвует в так
называемой сигнатуре той уникальной записи о функции, которая состоит из имени типов и порядки
этих типов. То есть для него важно имя, типы и какой у них порядок, 2 int в таком-то порядке. И вот здесь
мы смотрим 2 int, вот порядок, или там int, чар звездочка, чар звездочка, вот эти отличаются не типами,
но порядка этих типов. А что такое встроенная функция? Это не встроенная функция, это функция
из библиотеки. Нет, конечно, если вы как бы не знаете, как это работает, потому что вы ее не пишете,
при вызове вы об этом не думаете, это уже разработчики этих функций решают, как они ее напишут,
вы только свои можете такими сделать. Вот здесь важно вот это, но бывает у нас не точное
соответствие типов. И в данном случае мы делаем так называемые преобразования типов,
мы уже с вами встречались, например, у нас есть некое продвижение типов,
bool, char могут преобразовываться в int, load в double. Мы уже с вами говорили, что int у нас тоже
стандартно преобразовывается в double, такое у нас преобразование есть, и указатели могут
преобразовываться на пустой указатель звездочку. Но перегрузка нам бывает доставляет очень много
проблем, когда мы начинаем с вами какие-то делать очень сложные комбинации, совмещая перегрузку,
еще с чем-то и может быть такая двухзначность. Давайте рассмотрим пример, который покажет нам,
что и перегрузку, и параметры помолчания, особенно если комбинировать вместе, то у вас
будут просто супер такие сложные вещи. Итак, пусть у меня есть некая функция, у нас так много
материала, мы даже перерыв на второй парень делали, но неважно, float f, и так пусть у меня какая-то
функция. Так пусть у меня есть функция f, которая принимает и и возвращает float. Эта функция ничего
особенного не делает, она просто пусть, например, вернет просто и, которой ей дали. Давайте еще
одну функцию, double f, и она перегружена по даблу, и нам надо здесь тоже самое можно сделать,
просто вернуть, например, и умножить на 2. Вот у нас есть две функции перегруженные, одна float
принимает, другая double. То, что возвращает, никого не волнует. Теперь в мейне. Создадим
с вами переменную x типа float, и создадим переменную y типа double, и тоже дадим такое же значение 10,9.
Теперь я, ой, давайте double, да, я уже тороплюсь, поскольку слышу смех историков в коридоре,
чувствую, что сейчас через минуту они ворвутся такой толпой, и мы не устоим, там их два раза больше.
Итак, c out, c out f от x, c out f от y. Здесь все круто, x float, y double, все вызывается первое,
потом вызывается второе. Никаких проблем нет. А вот теперь, если я напишу c out f от 10, то у него
нет точного соответствия, поскольку 10 может быть преобразовано как во float, так и в double,
и если есть какая-то неоднозначность, это называется двухсмысленный вызов, и вызова не происходит.
Это не скомпилируется, потому что он точно не может знать, что вызывать,
потому что 10 это не float и не double, а может быть преобразовано и туда, и туда. Ну и давайте еще
последний пример дадим с вами на неоднозначность при перегрузке. Вот такой. Так,
пусть у меня есть функция f, которая принимает int, возвращает int, и в теле функция, она просто
возвращает то, что она приняла. Пусть есть другая функция f, которая принимает два параметра,
но второй из них по умолчанию. Ну она что-то там делает, return, а умножить на b, например. Вот такое
у него простое тело. Теперь main. Мы с вами вызываем функцию f, печатая результат с двумя параметрами.
10 и 2. Сейчас одну минуточку. И после этого я вызываю с вами. Все здесь нормально. f с одним
параметром 10. И что ему выбрать? Они перегружены, но здесь у меня значение по умолчанию, и он может
как этот вызвать, так этот. Это неоднозначно связано, что у вас перегрузка со значением по умолчанию.
Этот вызов невозможен, он двухсмысленный. Это все, что я хотел вам рассказать. На этом
наш лекции закончено. Спасибо. Спасибо большое и до следующего раза.
