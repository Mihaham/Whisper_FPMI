Значит, мы сегодня начинаем вторую большую тему курса, это теория числимости.
Собственно, вот эта часть курса оправдывает слова теории алгоритмов в названии курса.
До этого теории алгоритмов почти не было. Можно было, конечно, на самом деле резолюцию немножко связать с алгоритмами.
Это такой алгоритмический метод. Но сейчас общая теория.
Общая теория, что вообще такой алгоритм, что такое алгоритмическая задача, какие задачи решали мы и так далее.
Начнем с того, что такое алгоритмическая задача.
Алгоритмическая задача, это любая постановка, где есть вход и выход, и вход и выход записываются в конечном счете в речные стола.
То есть нужно преобразовать вход в выход, и совместные вход и выход записываются двоичными словами.
Соответственно, можно этими двоичными словами кодировать разные-другие объекты.
То есть слова могут кодировать по-другому.
То есть слова могут кодировать натуральные числа, графы, матрицы натуральных чисел, рациональные числа,
может быть через мантицию порядка, может быть через числитель-взаменатель, может быть как-то еще.
Можно какие-то более сложные структуры, какая-нибудь там группа, или что-нибудь там еще более сложные наборы таких структур.
Что такое граф? Это тоже простейшая структура, что есть список вершин и список ревербер.
А может быть, например, взвешенный граф, когда у каждого ревебра еще есть вес.
Может быть, еще что-то такое хитрое.
В конечном счете это все перекодируется в бита и получается двоичное слово.
Вот это называется конструктивные объекты.
Конструктивные объекты – это то, что можно закодировать лавами, кодируемые лавами.
То есть натуральные числа, рациональные числа, матрицы, графы, прочие конечные структуры.
Про это кодирование мы в явном виде говорить не будем.
То есть мы будем считать, что какое-то кодирование есть.
Но если оно задача очень нужна будет, то мы внимательно на него посмотрим.
А так, чтобы просто как-то все записано.
То есть нам здесь не нужно будет какие-то конкретные программы написать.
Нужно будет просто обсуждать, что они есть.
Хорошо.
Я вот так написал, что нужно проявлять вход-выход не очень четко.
Это потому что бывают разные конкретные постановки.
Конкретные постановки.
Значит, ну могут быть вычисления функция.
Это означает, что и вход, и выход – это конечное двоичное слово.
Ну и соответственно есть какая-то функция f, которая двоичные слова, отображает двоичные слова.
Второй вариант.
Второй вариант – это распознавание множества.
Значит, распознавание множества означает, что там два возможных ответа.
То есть распознавание множества – это то же самое, что вычисление предикад.
То есть можно писать, что есть какой-то предикад, который получает ново и соответственно возвращает 0,1.
И вот его нужно вычислить.
Ну и распознавание множества означает, что нужно установить – лежит x в a или не лежит.
Значит, или по входу x установить верно ли, что x лежит в a.
Третье еще бывает. Задача поиска.
Задача поиска означает, что есть некоторые отношения.
Значит, дано отношение бинарное r, которое под множество 0,1 со звездочкой в квадрате.
И нужно по входу x установить верно ли решение уравнения или установить, что решения нет.
Обычно говорят, что решить уравнение значит найти все корни.
Вот здесь будет ссылка, что найти один корень.
Потому что если все корни, то это, на самом деле, первая постановка, что есть конкретное значение список корней, которые нужно установить.
Вот, значит, а здесь вход x, значит, а выход, значит, либо y такой, что r от x и y равно 1.
Так, сейчас, если он пропадет, то не так можно, да?
Если не существует, значит, если для любого y, значит, пара x и y не лежит в r.
Ну, тут соответственно отличие в том, что нет какого-то приписанного ответа.
Конечно, на самом деле, вот эта специальная сила, еще тоже как нам закодировать.
Ну, можно, например, сказать, что если ответ, что такого y нету, то мы выводим 0, а если такое y есть, то мы выводим 1, а потом, соответственно, вот какой-то подходящий y.
Вот, и все еще это будет не то же самое, что первоначальное вычленение функции, потому что нет конкретного значения, а есть много подходящих.
Так, хорошо, значит, теперь еще на самом деле бывают постановки, в которых мы вредим как какой-то алгоритм, но там какие-то непрерывные аспекты возникают, значит, это мы будем игнорировать.
Давайте я один раз напишу, что бывает, а потом мы их проходить не будем.
Значит, не рассматриваем непрерывные постановки.
Может быть, как бы непрерывные точки и дискретное время, значит, тут пример метод Мьютона.
Значит, метод Мьютона численного поиска корень уравнения.
Знаете, что это за метод? Я думаю, что вы в каком-то виде его проходили, но даже если нет, то это очень легко понять.
Значит, есть вот какой-то график, и мы хотим найти корень, где график пересекает весь обстыз.
Момент такой, набираем какую-нибудь точку и из нее проводим касательно.
Дальше в этой точке поднимаемся назад на эту кривую и из нее проводим касательно.
Потом снова поднимаемся и еще раз проводим касательно и так далее.
Соответственно, здесь происходит работа с какими-то непрерывными штуками.
Здесь проводим касательную, ищем пересечения.
Главное, что вещь-то производная в произвольной точке, да, произвольная функция.
Конечно, если это функция какая-то хорошей формулы задана, то можно как-то симулина посчитать.
Хотя рисуют непрерывные картинки, на самом деле это будет работать с какими-то конечными выражениями.
Но метод всегда работает, но не всегда, если условия соблюдены, какая-нибудь гладкость нужна и так далее.
Такой процесс всегда сойдется корню.
То есть, смотрите, тут, во-первых, у нас непрерывные точки, дискретное время, но еще и ответ получается через бесконечное число шагов в пределе.
В общем, такое мы не рассматриваем, потому что в реальности, чтобы это использовать, нужно это как-то приблизить.
Мы приближенно проводим касательную, какое-то число утратцы делаем, потом останавливаемся и так далее.
А если эти оговорки сделаются, это будет алгоритм, как мы рассматриваем.
А в таком идеальном виде это будет за рамками теории.
Еще есть такая тема, протоколы справедливого дележа.
Протоколы справедливого дележа.
Там даже какие-то еще более сложные штуки.
Есть протоколы, которые работают в непрерывном времени.
Например, есть вот такая история.
Этот отрезок называется пирог.
Есть два человека, которые его делают, и у каждого из них разные ценности.
То есть нельзя отмерить общую рулетку и поделить ее пополам.
Одному нравится какие-то одни кусочки, другому какие-то другие.
Но есть вот такой метод ежа.
Иногда это еще рассказывают про пиратов и сокровища.
Что было пиратов такое телесокровище, оно очень разнообразное, можно поделить.
Но один метод вот такой.
Это я нож нарисовал для пирога.
Этот нож движется лево-направо в непрерывном времени.
И, соответственно, каждый игрок может сказать стоп в любой момент, тоже непрерывный.
И получить кусок лево от ножа.
Но имеется в виду, что у каждой меры есть медиана.
Такая, что слева от медиана и справа от медиана одинаковая ценность.
Но и до чей медиан этот нож раньше дойдет, тот и крикнет и получит кусок слева от ножа.
Это тоже выглядит как алгоритм, но в строгом смысле алгоритм не является, потому что здесь вот такое непрерывное время.
Это слайд единственный, где я такие штуки рассматриваю.
Дальше у нас все будет дискретное.
И время, и объекты, и получение ответа все будет конечное.
Хорошо. Следующее, про что мы поговорим, это вычислительные модели.
Это тоже в нашем курсе в большей степени семинарская тема.
На семинарах какие-то группы уже были, в каких-то не было, но будет семинар про машины тюринга в подробностях.
Здесь я скажу кратце.
В принципе, существенную часть теории можно изучать вообще без какой-то конкретной модели,
ну а просто на базе такого обыденного опыта, что мы пишем программы, как-то программировать умеем,
и примерно понимаем, что компьютер делает.
То есть можно представить себе, что алгоритм – это программа на вашем языке.
И для существенной части теории не нужны какие-то мелкие детали.
Что именно это за программа, как она работает и так далее.
Но кое-где все-таки нужно.
Когда доказывается, что программы нужны не существуют, то все-таки желательно понимать, что именно не существует.
То есть про что именно мы доказываем, что такой штуки нет.
И особенно это нам пригодится, когда мы будем вычисления на программах кодировать через арифметические формулы.
Вот здесь уж без точной модели трудно обойтись, чтобы прям полностью доказать.
То есть мы будем доказывать, что для любой программы есть арифметическая формула,
которая, скажем, верна тогда и только тогда, когда программа на этом входе возвращает ноль.
Или тогда и только тогда, когда программа на этом входе останавливается.
А вход будет параметром арифметической формулы.
И, конечно, наши по-разному единицы можно перекодировать числа натуральные,
и тем самым, соответственно, иметь дело с арифметикой.
Хорошо. Так, значит, базовая модель – это машина Тьюринга.
На самом деле, в 30-х, 50-х годах было очень много разных моделей.
Но некоторые из них буквально уже остались только в истории.
Другие там где-то изучаются, но вот машина Тьюринга выдержала проверку временем
и входит во все учебники.
С одной стороны, достаточно проста, чтобы ее можно анализировать.
С другой стороны, достаточно сложна, чтобы довольно легко все программы писать.
Хорошо. А что такое машина Тьюринга?
Если я формальное определение как математический объект оставлю для семинаров,
значит, а здесь нарисую неформально.
Значит, у машины Тьюринга есть лента.
Давайте я там так напишу – лента.
И есть указатель.
Там есть указатель и есть процессор, можно сказать, управляющий блок.
Управляющий блок в состоянии электронку.
А о чем здесь есть программа?
Значит, программа стоит из команд.
Программа машины Тьюринга стоит из команд
Вида.
Значит, какое-то Q.
И T, а J T переходит в Q, R, T, A, S, T и еще направление.
Соответственно, что у нас тут получается?
Получается, что Q, R, T – это состояние.
Состояние из некоторого множества Q.
Значит, A IT, A J T и A S T – это символы из некоторого алфавита.
Конечного Q – конечный множество состояний.
Здесь гамма – это конечный алфавит.
А вот это D – это сдвиг.
Значит, налево, направо или на месте.
Соответственно, команда выполняется.
Но D находится в каком-то состоянии и указывает на какой-то символ.
И он в списке команд смотрит нужную команду.
Где Q IT – это нужные состояния, A J T – это нужный символ.
После этого смотрит, что там дальше написано.
И заменяет A J T на A S T.
Переходит из Q IT в Q R T.
И еще указатель сдвигает.
Значит, налево, направо либо оставляет на месте.
После этого есть новое состояние, новый символ и новая команда.
И она тоже исполняется.
И так пока не будет выполнено условие остановки.
Для условия остановки есть два варианта.
В зависимости от того, какую задачу мы решаем из предыдущих.
Если у нас первая или третья задача, то есть много разных ответов.
Тогда есть одно завершающее состояние.
Значит, есть специальное завершающее состояние.
Может быть, Q HALT.
И тогда означает, что если машина пришла в завершающее состояние,
то дальше из содержимого ленты по каким-то правилам довлекается ответ.
Значит, Q HALT – ответ на ленте.
Либо, может быть, два варианта.
Q ACCEPT – ответ да.
Q REJECT – ответ нет.
Если ответов тоничное число, то можно для каждого завести специальное состояние.
Кстати, что касается задачи поиска.
В принципе, можно сделать специальное состояние, что ответа нет.
А другое состояние, что ответ написан.
И если он уже написан, тогда мы его читаем с ленты.
Ну хорошо.
Чтобы модель замкнуть, нужно еще сказать, с чего начинается.
С чего начинается вычисление.
Там должно быть еще начальное состояние.
Ну и в самом начале машина находится в состоянии Q START.
На ленте написан вход, ну и потом она начинает работу.
Хорошо, есть еще другие модели.
Тоже я про них сейчас вкратце скажу, а подробно в нашем курсе не будет.
Значит, такие есть другие модели.
Ну быть вариация с лентой и ячейками.
Значит, вариация с лентой и ячейками.
Значит, это, например, машина просто.
Вот, могут быть машины с регистрами.
Машина с регистрами, где в регистре может храниться натуральное число.
Есть там несколько регистров, и в каждом прямо произволе натуральное число хранится.
И дальше какие-то операции, что может быть аризметические, там что-нибудь уменьшать,
увеличивать какие-нибудь условные переходы и так далее.
Есть там куча разных вариаций.
Значит, здесь в регистрах хранятся натуральные числа.
Значит, есть рам-машина.
Я слышал, что состояние машины описывается набором натуральных чисел.
Регистр можно сказать просто индекс, что есть первое натуральное число такое,
второе такое, третье такое и так далее.
То есть есть команда типа того, что если там в первом регистре ноль,
то мы там к третьим прибавляем четвертый, грубо говоря, и записываем в третий.
Ну и так далее.
И дальше там есть куча вариаций.
Например, есть программа, и скажем каждый раз мы там ее проходим сначала
и смотрим, какую команду можно исполнить.
Какую первую можно исполнять, то исполняем, потом снова смотрим.
А, ну изначально, например, что в первом регистре вход, а в остальных нули.
Вот.
Но в варианте есть очень много разных вариантов.
Так, дальше есть машины с произвольным доступом.
Рендом аксесс.
Машины с предвольным доступом.
Это рам.
Рам-машины.
Собственно, рам это есть рендом аксесс-машин.
И это, на самом деле, похоже на реальные компьютеры.
Вот смотрите, вот машина тюринга, она может только сдвинуться в соседнюю ячейку.
Там налево или направо.
А рам-машина может где-то отдельно напечатать номер
и дальше перейти в ячейку с таким номером в задний шаг.
Вот.
Ну, это как, бывает, там указатель, перейти по адресу, в памяти и так далее.
Вот.
Что еще бывает?
Ну, дальше бывают всякие исторические интересные штуки.
Значит, есть общерекурсивная функция.
Общерекурсивная функция, которую Чордж придумал.
Значит, есть алгорифмы Маркова.
Алгорифмы, именно через f, Маркова.
Вот, ну и так далее.
Очень интересно, когда слово алгоритм проникало в русский язык.
Вообще, вы знаете, откуда слово алгоритм произошло?
Это искаженное имя альхаризми.
Альхаризми – это персидский или среднеазиатский ученый, который, собственно, изобрел позиционную систему
счислений, всякое там сложение столбок и так далее.
Вот.
И соответственно, когда эти трубы были приведены на латинский,
то там вот эта альхаризми, она преобразовалась в алхаризмы или там как-то так.
И был прям в заграве.
Вот.
Ну и, соответственно, довольно долго алгоритмы не называли именно альхметические алгоритмы,
там сложение столбок, там деление уголков и так далее.
Вот это только для алгоритма.
Но потом, уже в 18 веке, начиная с Леги Цейлера,
уже там были сложные числовые процедуры, назывались алгоритмами.
И уже почти как мы сейчас называем.
Вот.
А в русском языке это долго было в старом названии,
и это писалось алгоритм через букву «фита».
Знаете, была революция буквы «фита», которая как «т», пишется.
Вот, начиналась как «ф».
Вот через «т» букву это писалось.
Вот.
И дальше как-то Марков, который это придумал,
он был такой историолежимный товарищ,
и он говорил, что нужно вот по-старому написать,
в общем, через «ф».
Ну, через «фита» уже нельзя, а через «ф» надо.
А дальше это как-то видимо повторично помекало там из немецкого,
там или откуда-то с буквы «т».
Ну и в итоге вот так сложилось, что в русском языке алгоритм пишут через «т»,
а алгоритм – это означает конкретную совершенно вещь у Маркова.
Вот.
Это более-менее так, что там есть некоторая строка из сил,
есть некоторые правила преобразования,
ну и тоже мы там смотрим, какое правило можно применить,
и смотрим там, куда это в итоге перейдет.
Если вкратце, то вот.
Вот.
Хорошо.
Ну, опять-таки, значит, мы вот все заглянули,
значит, если интересно, то там поищите в интернете или в книжках.
Не, может, почитать, что это такое.
Так.
Хорошо.
Значит, мы ждем все дальше.
Ну, наверное, уже, можно сказать, что-то учли мы функция.
Значит, это очень важное определение.
Значит, мы рассматриваем частично определенная функция,
соответственно, из 0,1 со звездочкой в 0,1 со звездочкой.
Вот.
Соответственно, может быть, что функция определена,
и у нее есть какое-то значение,
а может быть, что функция не определена вообще.
Вот.
Так вот, что же значит, что алгоритм, да, или там машина тюринга
вычисляет данную функцию?
Значит, определение.
Функция f, значит, из 0,1 со звездочкой в 0,1 со звездочкой,
частично определенная, вычислима, если, значит, если верно следующее,
если существует алгоритм, да, или там программа машины тюринга,
я тебе через машину тюринга напишу, значит, существует машина тюринга
М, это что?
Для любого х, для любого х из 0,1 со звездочкой верно следующее,
если f от х определена, если f от х определена,
то тогда М от х останавливается и возвращает f от х.
Ну, то есть, в случае машины тюринга означает, что она приходит в вывышающее состояние
и на ленте у нее написано f от х, если она не начинала со входа х.
Вот, а если f от х не определена, значит, f от х не определена,
то это означает, что М от х вообще не останавливается.
То есть, смотрите, у вас, значит, в каждой конфигурации у нас есть следующий шаг,
то есть не машина его делает, а потом еще один делает, еще один, еще один,
и ни в какой момент у своей остановки не выполняется.
Вот, значит, это очень важно, что она именно вот так не останавливается.
И в этом, кстати, отличие от задачи поиска, как я отформулировал.
Значит, задача поиска, как я отформулировал, если ответа нету,
то нужно остановиться и сказать, что ответа нету.
Вот, а здесь очень важно, что именно так.
Значит, не нужно требовать, не нужно требовать,
то М от х сообщает, то f от х не определена.
Так, хорошо, но да, кстати, возникает вопрос,
мы бы взяли одну модель машины Тьюринга, значит, а почему,
если мы возьмем другую модель, то не получится какое-то другое определение?
Ну, вообще-то для некоторых моделей получится другое определение,
например, если взять конечные автоматы, не знаю, там не рассказывали нигде что такое,
конечные автоматы, но это будет в этом следующем семе... да,
в осеннем следующем семестре на фаранах языках.
Ну, не важно, что это такое, значит, некоторая довольно ограниченная модель.
Вот, и в ограниченной модели как бы не все можно сделать.
Вот, но от машины Тьюринга можно все сделать.
Такой тезис, значит, тезис Чорча, ну и сейчас называют Чорча Тьюринга,
тезис Чорча Тьюринга, что любая функция вычислима на реальном устройстве,
так и вычислима на машине Тьюринга.
Это не математическое утверждение, это некоторые утверждения про реальный мир.
Значит, любая функция вычислима на физическом устройстве также вычислима на машине Тьюринга.
Так же вычислима на машине Тьюринга.
Вот, ну а пока, если мы в это поверили, ну в это можно только поверить, да,
то есть пока, так сказать, ни у кого не получилось собрать компьютер,
никто не вычислял что-то неучислимое, но теоретически можно помыслить там такой физический мир,
в котором это было бы неверно.
Так что в это можно либо поверить, ну либо считать, что это основанный факт в рамках физики,
что все эксперименты показывают, что это верно.
Вот, и это просто теоремой, если мы вместо производа на физическое устройство
поставим какое-то конкретное или какую-то другую модель.
То есть вот для всех тех моделей, которые были на предыдущем слайде,
и еще для кучи других, ну в общем, мы любим для всех других,
это может доказать как теорему, что все, что вычислимо в такой-то модели,
будет вычислим на машине тюринга.
Интересно, обратные модели, все предыдущие к ним относятся,
что если что вычислим на машине тюринга, то они вычислим здесь.
Это называется тюринг-полная модель или тюринг-полный язык.
Это вообще, что на нем можно вычислить все, что на машине тюринга, то есть просто все.
И, значит, моделя, собственно, гораздо больше, чем я перечислил.
Есть, например, игра-жизнь, конвейер. Слышали такое?
Хорошо, многие слышали. Значит, это такой простой клетчатный автомат,
по простым правилам, эволюционирующая система,
где лечитая плоскость у каждой клетки 8 соседей,
каждая клетка живая или мертвая.
И, значит, если мертвую клетку окружает ровно 3 живых, то там зарождается жизнь.
А дальше, на крайней мере, если она живая, то если 2 или 3 живых соседа, то остается живой,
а если меньше 2 или больше 3, то, соответственно, становится мертвой.
И так все одновременно по всей плоскости.
И там очень интересно эволюционирует система.
Ну и, в частности, можно составить такой ряд конфигураций,
что есть одна часть конфигурация и есть переменная часть.
И, соответственно, переменная часть как-то зависит от чисел.
Ну а дальше там какой-то исход зависит...
В общем, вот эта часть фиксируется как программа,
переменной как аргумент программы.
Ну а исходы там бывают всякие, что, например, она полностью аннигилирует,
то есть все сведется в пустую плоскость.
Или, наоборот, будет расти бесконечно, и так далее.
Ну вот так, хорошо.
Значит, в общем, этот тезис обосновывает то, что это определение разумно,
что его можно применять.
Хорошо, теперь что можно сказать?
Что можно сказать про вычислимые функции?
Так, ну вот есть такая простая теорема.
Простая, но важная теорема.
Композиция вычислимых функций вычислима.
Значит, композиция вычислимых функций вычислима.
То есть если f вычислима и g вычислима, то там f от g от x...
Значит, это f композиции g от x, то есть f от g от x тоже вычислима.
Такая-то более-менее элементарная, если на пальцах,
но и даже в модели тоже довольно элементарная,
что мы сначала вычисляем функцию g,
и когда она закончилась, то то, что получилось, мы поцелуем на вход функцию f.
Используем это как под программу.
Ну и это покрывает...
Да, мы, конечно, считаем, что ежедневно вычислимые функции вычислимые,
но это не так.
Это как под программу.
Ну и это покрывает...
Да, мы, конечно, считаем, что если одна из функций не определена,
то тогда и композиция тоже не определена.
Да, получается, что если же не определена,
то тогда даже внутренняя часть будет работать бесконечно долго,
иначе композиция тоже будет не определена.
Если же это из определённого f не определённо, то то же самое.
Вот, хорошо.
Ну, в частный случай это теория,
что, например, если мы там, скажем, единицу прибавим ко всем значениям,
или множим две вычислимые функции,
перемножим и так далее, всё это будут вычислимые функции.
Так, хорошо.
Значит, дальше давайте поговорим про разрешимые множества.
Разрешимые множества.
Ну, то, что я вначале назвал задачей распознавания,
можно ещё назвать задачей разрешения.
Ну, разрешимые множества означают, что для этого множества
задача разрешения вычислима.
Ну, иными словами.
А, вычислимо,
если существует машина Тьюринга m,
то есть что?
Если x лежит в a,
то тогда m от x...
Ну, давайте я вам пишу равно единица.
То есть, нам надо сказать,
прекратить, что x лежит в a,
то тогда m от x...
Ну, давайте я вам пишу равно единица.
То есть, можно сказать, приходит
принимающий состояние.
На уровне состояния получается, что приходит
q accept.
А если x не лежит в a,
то тогда m от x равно mu.
То есть, приходит
q reject.
В частности, для любого x,
m от x определено, то есть, останавливается.
Но здесь нет никакой границы
на время работы.
Вот есть еще теория сложности вычислений,
которые, я надеюсь, мы еще будем изучать
информатиками на втором, а состоянием в рейтинг-курсе.
Вот, соответственно, теория сложности вычислений,
важно, сколько шагов
еще делает машина тюринга,
прежде чем даст ответ.
Здесь неважно.
Значит, здесь любое конечное число подойдет.
Можно сказать,
что решимость множества
то же самое, что вычислимость его
характеристической функции.
Получается, что a
вычислимо
тогда и только тогда, когда
вот эта вот
характеристическая функция, значит, ха
от x,
который есть единица,
если х лежит ва,
и ноль, если х не лежит ва,
вычислимо.
Ой, тут разрешимо надо.
А разрешимо
тогда и только тогда,
когда характеристическая функция
вычислима.
Вот очевидно, это практически то же самое
определение, просто по-другому сказанное.
Так, хорошо.
А теперь, что еще важно?
Важно, что
разрешимое множество
множество можно
перечислить
по возрастанию.
Мы рассматриваем
алгоритмы
еще одного специального вида,
такие перечисляющие алгоритмы.
Значит, перечисляющие
алгоритмы
перечисляющие алгоритмы устроены так,
что у них есть вход
или даже нет входа.
Есть как-то поток вывода.
Поток вывода,
то есть есть
можно сказать, что
время от времени
машины приходят в состояние
напечатать новый символ.
Ну и новый символ может быть
скажем нулевым, может быть единицей
или может быть концом слова.
Значит, что слово закончилось,
печатает следующее.
Значит, есть
поток вывода,
поток вывода, в который
направляются
какие-то биты,
печатаемых слов.
Соответственно,
вот тут в качестве выхода
получается не какая-то конечная,
не конечный объект,
а бесконечная последовательность.
То есть получается выход
это бесконечная
последовательность.
Вот,

Ну, может быть, конечная, может быть, и конечная.
Соответственно, утверждение такое, что а разрешима тогда
только тогда, когда можно напечатать по возрастанию.
Вот, а здесь слева направо это очень простая программа.
Слева направо можно просто написать цикл, на конец там,
for each. Давайте я буду сейчас считать, что аргумент это число.
Значит, для каждого n 0, 1, 2 и так далее, значит,
я в строчку напишу, тут места нету. Значит, if n лежит в а, напечатать n.
Вот, соответственно, если не прижит, то просто к следующему n переходит.
Вот, вот то, что лежит в а, мы можем проверить вот этим алгоритмом.
Да, мы его используем как подпрограмму.
Так, да, нет, может быть, конечная. Так, хорошо, дайте примеры.
Примеры разрешимых множеств.
Значит, первый пример – это любое конечное множество.
Любое конечное множество – разрешима. Почему?
Потому что можно прямо в текст программы записать полный список.
Можно список его элементов записать в текст программы.
Вот, ну и как бы каждый раз, когда есть текст, просто сравнивать по списку, да,
и сказать, лежит в списке или нет. Вот, второй пример.
Значит, второй пример для множества четких чисел.
Ну, конечно, если у нас что в двоичной записи, то нужно посмотреть,
просто там ноль в конце или единица в конце.
А если в десятичной, то там будет пять вариантов, когда да, пять вариантов, когда нет.
Вот, если даже в троичной, то все равно нужно написать алгоритм,
и это будет очень-очень сложный. Ну вот, теперь смотрите, что будет происходить,
если мы вот такую программу будем применять.
Давайте, смотрите, есть у нас, конечно, множество.
В этом идем, там ноль лежит, не лежит, да, скажем, если лежит, то печатаем.
Да, один лежит, не лежит, два лежит, не лежит.
Вот, на какой-то момент мы дойдем до последнего слова, который лежит,
и дальше будет бесконечное число шагов, и на них на всех будет ответ «нет»,
и мы больше ничего не напечатаем. Вот. Ну, конечно, и так, конечно,
можно по возрастанию напечатать. Вот. А что с четными? Ну вот, а ноль лежит,
лежит, да, значит, мы его печатаем. Единица лежит, нет, не лежит, пропускаем.
Двойка лежит, лежит, печатаем. Тройку пропускаем, четверку печатаем, и так далее.
Вот. И вот здесь получается бесконечная последовательность.
То есть, в целом, смотрите, здесь вообще нет условий остановки.
Здесь нет условий остановки, то есть, заведомо бесконечно долго это будет работать.
Но вывод может быть конечен. Так. Ну, я в 40 минут, давайте попробуем закончить.
Да, то есть, работа всегда будет бесконечна, а вот вывод может быть конечен.
Ну, если в нём что-то самое бесконечное, то конечно, вывод тоже будет бесконечным.
Вот. Хорошо. Так, какие ещё примеры? Ну, собственно, всё, что угодно,
для чего может программа написать. А она всё будет перебирать. Она всё будет перебирать
бесконечным долгом. Вот эта машина будет работать. Потому что она всё будет, она никак не узнает,
что она уже дошла до конца. Она так и будет перебирать, перебирать, перебирать,
и работать бесконечно долго. Нет, смотрите, прошлое спрашивайте, можно конечно для того же множества,
если что-то конечное, то можно писать программу, которая у напечаток и расстания остановится.
Вот. Но она будет выглядеть не так. Вот эта программа будет работать бесконечно долго,
потому что она бесконечно много, она никак не узнает, что она уже дошла до конца множества,
и будет бесконечно много. Числа, которые убирать лежат, они не лежат каждый раз. Получается,
что нет, ничего не печатать, но и вот так вот бесконечности работать. Вот. Так. Ну да. Да-да-да.
Более того, даже для конечного множества может быть программа не такая. Например,
давайте я сюда напишу. Множество совершенных чисел. Знаете, что это за числа? Это числа,
которых сумма делителей, меньше их, равна самому числу. Вот. Первые 3, 6, 28 и 496. Вот. Но конечное
множество или нет, никто не знает, это открытая проблема. Значит, есть одна открытая проблема
конечного множества совершенных чисел или нет. Такая открытая проблема, существует ли нечетное
совершенное число? Да, тоже никто не знает. Вот. Но неважно, конечное множество или нет,
оно в любом случае разрешимое. Потому что можно разложить на множители. Если у нас не держит
время работы, то можно просто перебрать все делители, разложить на множители. Перебрать все
простые делители, разложить на множители, взять все комбинации, просуммировать и проверить,
совпало или не совпало. Ну вот. И, соответственно, получается, что тут как бы даже премионист не
будут знать, до какого М нужно перебирать. Даже если это множество конечное, то мы пока не знаем,
какое там максимальное М. Вот. А просто, кстати, такую программу, да, перебирать по очереди,
проверять совершенно или нет, это мы, конечно, можем. Вот так. Хорошо. Сейчас. Я тут в одну сторону
написал, в другую сторону эти для семинаров оставим. Теперь еще простого надо сказать про
разрешимое множество. Простые утверждения. Значит, если А разрешимо, то тогда А с чертой тоже
разрешимо. Здесь, конечно, есть некоторый универсум, да, либо универсум, это все были двоичные слова,
либо все натуральные числа, но и в этом универсум берем дополнение. Как это доказывается? Ну,
нужно просто взять отрицание от ответа. Тут нужно взять отрицание от ответа. Вот. Конечно,
получается, что х лежит во, тогда и только тогда, когда х не лежит во с чертой. То есть ответ для
А и ответ для А с чертой противоположен. Так. Ну и также утверждение, то если А и Д разрешимы,
то тогда, скажем, пересечение, объединение, или, скажем, дикартовое произведение,
в этом калкотинация, вот и так далее. Все такие штуки тоже разрешимы. Вот. Ну, например,
значит, калкотинация, конечно, для слов, но, в принципе, эту запись можно и для множеств чисел
понимать, что мы берем все возможные произведения числа из первого множества и числа из второго
множества. Это тоже логично так обозначать. Вот. Ну, значит, для калкотинации, ну, давайте,
для калкотинации А на Б, ну, как понять у нас слово является калкотинацией или нет? Ну,
нужно перебрать все возможные разбиения. Значит, перебираем все представления. Перебираем
представления слова W калкотинации У на В. Вот. И проверяем, что одновременно У лежит А и В
лежит В. Значит, вот если для какого-то разбиения и то, и то выполнено, то, значит, ответ да.
Это такая ДНФ получается. Дизьюнция по всем разбиениям, коньюнция вот этого и вот этого. И тут,
конечно, поскольку А и В разрешимы, то мы можем проверить одно и другое. Так. Ну, хорошо. Следующее
понятие, которое мы будем подробно изучать в следующий раз, это перечислимое множество.
Но, по крайней мере, определение и самые простые свойства давайте изучим сейчас. Значит,
перечислимое множество это те, которые тоже можно перечислить, но не обязательно по
возрастанию. Значит, определение А перечислимо, если существует вот такая перечисляющая машина,
перечисляющая машина множество слов, в выводе которых совпадает С. Но важно,
что они не обязаны идти по возрастанию. Если они идут по возрастанию, значит, мы это пропустили,
но это верно, что если они идут по возрастанию, то тогда это разрешимое множество. Значит,
здесь важно, что слова не обязательно идут по возрастанию. Это будет в следующий раз. Но,
смотрите, давайте пока поймем для начала, почему не все функции вычислимые, не все множества
разрешимые и так далее. Просто из-за мощности. Не все множества разрешимые, потому что всех под
множество континуум, под множество реальных чисел, а разрешимых не больше, чем алгоритмов.
Я, кстати, не предварил в начале. У алгоритма обязательно конечное описание. Я вспоминал,
но не застрял внимание, что у машины-тиринга обязательно конечное число состояний,
конечное число симфофавита и, как следствие, конечная программа. То есть она описывается
какой-то конечной строкой. Ну и, конечно, любая программа, которую вы напишете,
тоже будет конечная. Значит, алгоритм определяется конечной программой, значит,
следовательно, множество алгоритмов счетно. Ну вот, значит, революционных нож тоже счетно.
Ну и счетных все-таки будет, потому что любая конечная разрешимая уже конечных счетна.
Вот, всех разрешимых тоже счетно. Ну вот, значит, если разрешимых счетно, а всего континуум,
значит, есть неразрешимые. Вот, но доказать, что есть разрешимые, неразрешимые перечислимые,
так не получится, потому что перечислимых тоже счетно. Да, разрешимых, счетных перечислимых,
счетно, значит, то, что есть перечислимые, неразрешимые, это посложнее. Не, ну на самом деле
определить такое множество несложно. Например, явный пример, явный пример перечислимого,
неразрешимого множества, это из первого семестра общезначимые формулы с числением
предикатов. Ну, то есть, легкие предикаты. Общезначимые формулы первого порядка.
Значит, они перечислимы, потому что есть теорияма о полноте. Они перечислимые,
очень-очень выводимые, и мы можем просто написать вообще всевозможные выводы и все,
что там получается. И поскольку у любой общезначимый формулы есть вывод, то мы рано или поздно напишем.
То есть, перечисление – это просто перебор всевозможных выводов,
значит, перебор выводов из числений предикатов. Ну и, соответственно, печатание выведенных формул.
Конечно, чтобы это было нормально определено, нужно еще определить, в каком образом все
происходит, в какой сигнатуре, какие переменные и так далее. Но это мы так не договоримся,
значит, печатание выведенных. Значит, по теории о корректности печатаются только общезначимые,
а по теории о полноте все общезначимые будут напечатаны. Но то, что неразрешимо, то, что
нельзя по формули понять навсегда, истинно или нет. И это не простая вещь на теремы Чорча,
и это даже мы не будем в основном курсе доказывать, наверное. Ну и посмотрим,
может, докажем, но так это вообще будет в дополнительном билете для желающих в экзамене.
Ну вот, так, что еще надо сказать. Я, верно, напоследок, сейчас, может, на пару минут еще
задержимся. Напоследок я хочу тоже несложно, но очень важную терему доказать. В этой тереме
Поста. Значит, терема Поста. Значит, заключается в том, что множество А разрешимо тогда и только
тогда, когда и А перечислимо, и А с чертой перечислимо. Вот, значит, слева направо.
Значит, слева направо. Ну, фактически, может, доказали. Значит, если А разрешимо,
то тогда и А с чертой разрешимо. Это у нас было. А то, если разрешимо, то и перечислимо,
потому что можно перечислить по возрастанию. Отсюда получается, что А перечислимо. Отсюда
получается, что А с чертой перечислимо. Советственно, если мы начнем отсюда, то мы перешли сюда и вот
такой штука сюда. Но обратную сторону нужно немножко схитрить. Если, может, это конечная,
то мы и так знаем, что она разрешима. Значит, если А конечная, то тогда она разрешима. Если А с чертой
конечная, то тоже разрешима по той же причине. Если А с чертой конечная, то тоже разрешима.
Если же и А с чертой бесконечная, то тогда делаем так. Начинаем чередовать. Значит,
слово из А, слово из А с чертой, слово из А, слово из А с чертой. Значит, чередуем выводы,
не выводы, а слова. Значит, слова из выводов, а А с чертой. Опять-таки мы ждем встречи Х. Ждем,
когда встретится Х. Ну и, соответственно, если он встретился в А, то значит, он лежит в А,
если он встретился в А с чертой, то значит, он не лежит в А. А встретиться он заветно,
потому что он все-таки либо в А, либо в А с чертой есть. Поэтому точно все езда перечислены здесь,
значит, где-то он перечислится. Вот такое рассуждение. Следующий раз мы посмотрим
несколько взглядов на причинимые множества. Мы, наверное, двигаемся к доказательству,
что есть причинимые множества. Может, докажем. На этом спасибо за внимание.
