Давайте я напомню, что в конце сделали насчет симптотики.
То есть, что с автомат у нас получилась такая симптотика.
Линия, если алфавит считать константным.
Если алфавит, ну алфавит размера, считать константой.
Ну то есть, скажем там, то есть, наше самоодобное допущение,
что алфавит – это маленький латинский буквы.
Вот, тогда за длину строки мы можем построить автомат.
Это вот следует из того, что когда мы, ну там, если
аккуратно анализировать, сколько итераций цикловая
каждый раз мы делаем, когда мы стрелочки перенаправляем,
то каждое перенаправление стрелочек – это сокращение
пути по суфсылкам до последней вершинки.
Ну и соответственно, этот путь очень долго нельзя
увеличивать, нельзя долго уменьшать.
Каждое уменьшение значит, что потом мы это уменьшение
не сделаем.
Вот.
Ну и соответственно, если алфавит не константа, то
в общем-то все так же, как в боре.
Например, мы можем сделать симпатику что-то типа n лог
сигма, если в каждой вершинке будем хранить не массив,
а мапу.
На лог сигму.
Если в каждой вершине множество переходов из нее ведущих
будем хранить как мап из, ну там, чар в, ну нод-звездочка
или инт в номер вершинки.
Давайте я напишу нод-звездочка для как бы, чтобы было понятно.
Вот.
Ну а если повторюсь алфавит константа, то как бы это
линейное время.
И, например, зачем нужен сухвавтомат, помимо тех
задач, которые я надеюсь вы рассматриваете на семинарах,
мы можем с его помощью построить суффиксный массив за линейное время.
Напоминаю, мы разбирали алгоритм, который делает
за n лог n.
Вот.
А теперь, используя сухвавтомат, мы это можем сделать за
линию.
То есть явным образом его не строить, там как мы делали
по классам эквивалентности два степенька, вот, а напрямую
из сухвавтомата.
То есть алгоритм очень простой.
Ну, строим автомат для строки s, дальше сжимаем проходные
вершины.
Проходные не терминальные вершины.
Вот прям так же, как мы делали в сухдереве, когда проходная
вершина – это в которой входит одно ребро и выходит
одно ребро, то есть как бы если направление движения
понятно и однозначно определено, если мы в эту вершинку пришли.
То есть здесь она, ну, одно входящее ребро и исходящее
тоже ровно одно.
Вот если такая картинка, то есть вершина проходная,
что называется, проходная, то можем ее сжать и нарисовать
просто одно длинное ребро, на котором написано конкретинация
этих двух строк.
А то есть если здесь была альфа, здесь была бета,
можно просто нарисовать такое длинное ребро, на котором
написано альфа бета.
Конкретинация строк.
Вот, значит, проходные вершинки сжали, а дальше у нас получится,
ну давайте какой-нибудь, набросаю что-нибудь.
Например, какой-нибудь такой автомат получится.
Да, действительно, так, ну, тогда вот так нарисую.
Значит, что-нибудь такое будет.
Дальше, как обычно у нас все ребра, исходящие из вершины,
отсортированы по первым символам, да, из-за того,
что опять возникают вот эти конкретинации, то ребра
у нас отличаются не как вот эти вот строки различные
на этих ребрах, а первые символы у них различные,
потому что изначально вот у них были первые символы
различные, потом они как-то склеились как угодно, ну
и это свойство сохранило, что первые символы у всех
различные.
А дальше мы запустим на этом графе лексикографический
ДФС, но без пометок юст.
Значит, давайте я так напишу.
Значит, лексикографическое значит, что ребра мы рассматриваем
в порядке лексикографического возрастания, да, если есть
несколько переходов, то мы в первую очередь берем
тот, у которого, на котором буквы поменьше, первые буквы,
на котором меньше, то есть вот эти вот ребра, исходящие
из вершины, упорядочены по первой букве, сначала
мы используем это ребро, потом, когда рекурс вернется
сюда, это ребро, потом вот это ребро.
А без пометок юст, значит, ну как у нас работает обычный
ДФС.
ДФС, когда заходит в вершинку, помечает ее использованный
юст, и больше юст не пытается идти, потому что в обычном
ДФС нет смысла заходить заново в те вершины, где
мы уже были.
А вот здесь мы не будем эти пометки хранить и будем,
ну как если бы мы вообще об этом не задумывались,
будем, возможно, многократно проходить одну и ту же вершину
много раз.
Скажем, например, здесь, я, например, сначала пройду
вот такой вот путь, потом у меня рекурс и вернется
сюда и пройду вот такой вот путь.
То есть это ребро у меня пройдется дважды, соответственно,
эта вершина дважды, эта вершина дважды.
И это нормально, типа так и надо.
А в отличие от обычного ДФС, когда мы так не делаем
и мы не ходим по ребрам многократно, здесь мы можем ходить по
ребрам много раз.
Ну и соответственно, в процессе этого ДФС мы посещаем
какие-то вершинки, какие-то из них были терминальными,
ну, например, там вот эти вот были терминальными.
И каждый раз, когда мы посещаем терминальную вершину, мы
знаем, какую длину пути мы сейчас преодолели.
То есть если мы находимся в вершине, то мы знаем, каким
путем мы в нее попали, мы знаем, сколько символов
прочитано.
Значит, мы знаем, в какой суффикс мы попали.
И вот утверждается, что порядок, в который мы обходим
все эти суффиксы, и будет порядок совмасс.
Значит, сейчас запишу, храним прочитанную длину строки.
Если оказались в терминальной вершине, то передной суффикс
порядка совмасса, это вот та самая длина, которую
мы прочитали.
Если оказались в терминальной вершине, то вот эта вот длина,
это есть очередной суффикс порядка совмасса.
В порядке, который нужен в совмассиве, да?
Нам нужен первый символ и длина, да, первый символ
и длина только нам нужны.
Вот, весь алгоритм, то есть это просто тупой DFS, который
не использует юзды.
В основном это просто DFS, который, ну вот, когда попал
в терминальный, он написал какой-то суффикс.
То есть почему это корректно, более-менее очевидно, потому
что по сути, давайте раздожмем обратно все вот такие вот
ребра, по сути мы просто обходим этот автомат без
пометок юзды.
В каком порядке мы обойдем все суффиксы?
Ну понятно в лексографическом, да, потому что на каждом
шаге мы из исходящих ребр, каждый раз выбираем минимально
неиспользованные.
Тогда первый суффикс, который мы обойдем, это будет лексографически
минимальный, просто потому что мы каждый раз выбираем
лекс-мин символ.
Второй, соответственно, это второй по минимальности
и так далее.
То есть если даже не сжимать, или если сжимать, все равно
пути от этого не изменятся, проходные вершинки, мы понятно
дело обойдем суффиксы ровно в том порядке, в котором
нужно.
Просто вот в порядке лексографического возрастания.
Значит, вопрос только со симптотикой.
Ну давайте так, корректность, я напишу.
Корректность тривиальна, так как обходим все в лекс
порядке, обходим в лексографическом порядке.
Вот, значит, что здесь со симптотикой?
Здесь уже непонятная симптотика, да, мы не можем просто сказать,
что это линия, потому что мы просто DFS на графе, поскольку
мы иногда многократно проходим какие-то вершины и ребра.
Это не обычный DFS, а DFS без юздов.
И даже так это будет все равно линия.
Потому что, смотрите, давайте я напишу следующее.
Время работы пропорционально числу суффиксов плюс числу
посещений тех не сжатых вершин.
Плюс числу посещений тех непроходных вершин.
Значит, ну по сути время работы это просто, то есть
откуда число суффиксов, это вот то, что мы их печатаем
здесь, да, каждое попадание в терминальное это напечатает
суффикс.
А также это просто число посещений всех вершин.
Ну просто потому, что DFS так работает, каждый как бы
шаг DFS это попасть в вершину.
Когда мы встаем в вершину, мы просто берем первое
неиспользованное ребро и идем вдоль него.
То есть время работы, ну по сути, просто пропорционально
числу посещений всех вот этих вершин, которые мы
не сжали.
Но каждое посещение вершины, это на самом деле, ну все
посещения вершины, они на самом деле разные, потому
что они шли по разным путям.
Понятно, что в этом графе нет циклов, поэтому мы как
бы не будем петлять многократно поднимать тем же строком,
и на самом деле каждое попадание в вершины, скажем в эту,
вот первое попадание, вот второе, это на самом деле
попадание, отвечающее разным строкам.
Если это была какая-то вершина, какое-то состояние
суффрамата, какой-то класс эквивалентности, то по
сути мы попадем в него столько раз, сколько в нем
был строк в этом классе эквивалентности.
Сколько есть пути до него, много раз мы в него и попадем.
Ну по крайней мере 사람이 больше, потому что попасть
сюда можно только за счет строк, которые в этом состоянии
лежат.
Вот это число посещений заведомо не больше, чем
суммарное количество под строк s, которые оказались
в нежатом классе эквивалентности.
То есть, еще раз, потому что каждое пещение вершины,
вот как мы могли попасть в вершину, значит, мы от
старта как-то дошли.
И поскольку нет циклов, поскольку мы один тот же путь не можем
дважды обойти, мы в вершину можем попасть точно не
большее число раз, чем в принципе до него было
путей.
А каждый путь это своя строка вот в этом классе, потому
что попасть в вершину можно только прочитав какую-то
сроку из этого класса.
То есть, время работы – это, по сути, суммарное число
под строк, которые лежат вот в этих нежатых классах,
в непроходных вершинах.
Но осталось понять, что такое может быть нежатый класс.
Нежатый – это когда есть два исходящих ребра.
То есть, это некие классы эквивалентности, такой что
есть по крайней мере два символа, давайте их назову
там как-нибудь, х и у, такие что можно прочитать х, это
будет под строка, можно прочитать у, это будет под
строка.
И кто тогда, какие строки альфа вот здесь вот лежат?
Здесь лежат такие строки альфа, в частности, что альфа
х – это под строка с, под строка с, и альфа у – это
под строка с.
Теперь у меня к вам вопрос.
Вот знаем ли мы какое-нибудь свойство, что вот приписывание
символа – это под строка?
Вот где-то у нас было, когда мы говорили про софтомат,
что приписывание символа, можно приписать два разных
символа, х не равно у, что это остается под строкой?
Где у нас такое было?
Да, критерия лонгеста, только там приписывание с другого
конца.
Но смотрите, если я тогда буду приписывать с другого
конца, и напишу вот так вот, то есть я просто вот это
условие написал, ну как бы написал строчки справа-налево,
понятно, что это теперь тогда будет под строки с-реверснутого.
Тогда у меня вот такое условие, что неждатые вершины, то
есть из которых есть два исходящих ребра, это вот
такие вершины, то есть это вот такие строки, что слева
можно приписать нечто, что это будут разные подстроки
с-реверснутого.
Ну и конечно, что исходно тоже альфа было под строкой
с, конечно.
Альфа-реверснутого – это под строка с-реверснутого.
Значит, альфа-реверснутого – это лонгест в SR.
У нас был критерий, что если вот это вот выполняется,
то альфа-реверснутого – это лонгест в с-реверснутом.
Вот это вот означает, что альфа-реверснутого – это
лонгест, ну, лонгест в своем классе для софтомат, построенного
для строки с-ревертснутого.
Лонгест в своем классе, в автомате для s-реверснутого.
Ну а все о лонгестов в автомате мы знаем, что их максимум
линейное количество.
Потому что лонгестов столько же, сколько класса эквивалентности,
а классы эквивалентности столько же, сколько вершин,
то есть линейное количество.
Победа таких строк альфа, ведущих нас в то, что мы
эту вершину повторно рассматриваем, их максимум линии.
Значит, все время работа тоже линия.
Давайте это запишем.
Итак, если альфа ведет в нежатую вершину, то альфа-реверснутая
лонгест для s-реверснутого.
Следовательно, таких альфа максимум линиейное количество.
Ну и все, значит, время работать в суммарную линию.
Вопросы?
Так, да, сейчас, одну секунду, надо, наверное, это переделать.
Момент.
Да, надо здесь аккуратнее сказать.
Два входящих, одно из входящих, да, то есть, на самом деле,
не совсем правильно я сказал.
Сейчас, одну секунду.
Такие прыжки.
Ладно, на самом деле, окей.
Я тогда неправильно это сказал, да.
На самом деле, нам нужно только, чтобы одно изходящее
было.
Так, я это нигде не записывал, да, сейчас, жимая, проходная
вершина.
Проходная, это когда одно изходящее.
Проходная, в скобочках, одно изходящее.
Вот так.
Вот.
Ну, здесь нормально, потому что это была терминальная,
и я ее не сжимал.
Терминальная, я не сжимаю.
А проходная, это именно когда одно изходящее.
Вот.
И тогда у нас, ну тогда такой алгоритм довольно просто
сделать.
Просто идти по нашему автомату снизу-верх в порядке от более
глубоких тренировки, к менее глубоким, и для каждой
вершины ещё одна изходящее, если у неё одно изходящее
ребро.
Давайте, для каждой вершины понимать, куда ведет этот
длинный путь по, когда у нас однозначный путь восстанавливается,
когда куда ведёт этот путь по стрелочкам, когда она
одна, всего.
Когда без разветвлений.
Если мы знаем это.
ная.вершина, то есть скажем, есть вот такой путь, ведучий
сюда.
мы как бы храним вот такую ссылочку.
Если для этой вершины у нас тоже
только одно из входящих ребра, то я эту ссылочку
перекопирую вот отсюда.
То есть, если я знаю ссылку для вот этой
конец такого нисходящего пути по единичным
ребрам, то здесь я тоже его знаю.
По сути, это значит, я сжал вот эту промежуточную
вершинку. А если у меня из вершины есть
хотя бы два из входящих ребра,
то я ее не сжимаю, ну, потому что она
непроходная. Да, то есть, виноват.
Вот тут, когда я говорю, что одно входящее, это конечно
неправда, потому что даже если вот она
такая, есть какая-то альфа-альфа-штрих
и все равно одно бета, то нет смысла ее
оставлять, можно просто здесь написать альфа-бета,
а здесь альфа-штрих-бета. А нет смысла ее оставлять,
если она не терминальная.
Да, спасибо.
Так, ну вот, вот и все.
Так.
Теперь все,
про софт-автомат можно забыть.
А теперь давайте рассмотрим следующую задачу.
Есть длинный текст
и короткий шаблон.
Давайте текст T,
шаблон, ну, пусть будет
S.
А теперь
давайте рассмотрим следующую задачу.
Шаблон, ну, пусть будет S.
В простой задаче мы хотели бы найти,
ну, шаблон, в смысле просто строка.
Строка.
В простой постановке мы бы хотели
найти просто все вхождения S в T.
Все вхождения S в T мы знаем,
как искать это, ну, например, там
начинать префикс функцию такой строки,
тогда мы знаем все вхождения S в T.
Везде, где префикс функция равна
длине S, мы получаем
очередное окончание вхождения S.
Вот.
Но это так называемые точные вхождения.
Число точных вхождений
S в T
это префикс функция.
Вот. А что если мы будем
хотеть делать неточные вхождения,
скажем там, с одной, с двумя, с тремя ошибками?
Ну, то есть понятно, что возможно где-то
бывают опечатки, и это нормально.
Есть какой-то текст T длинный,
в нем, возможно, были какие-то
опечатки, и мы хотим найти,
где входит S с учетом того,
что может быть не больше, чем там
K опечаток, вот, в вхождении.
То есть задача такая,
нам нужно в тексте T
найти все такие подстроки длины
такой же, как S, что если
я сюда приложу S, то отличие
между вот этой подстрокой и S будет не больше, чем K.
Значит, наша новая задача, это
сделать число вхождений
не больше, чем с K опечатками.
Не больше, чем с K опечатками.
То есть все такие подстройки T
нужно найти, что они
отличаются от S не больше, чем
в K своих позициях, где K какое-то
задное число, там, два, три, что-то такое.
Вот такая задача.
Ну, насколько я понимаю, задача,
ну, мы ее уже обсудили в случае
K равно нулю, это мы уже умеем решать,
это просто число точных вхождений.
Значит, вроде тоже несложно, она решается в случае
K равно единице. Вот этот случай
либо и так был
семинарская мысточка, либо подумайте над ним,
как находить вхождение не больше, чем с одной ошибкой.
Вот это упражнение.
А теперь будем рассматривать общий случай, когда
какое-то произвольное задное число
целое.
И чтобы решить эту задачу, нам понадобится
что-то совсем другое, а именно перемножение
многочленов.
И вот сейчас, вдохновившись этой задачей,
мы перейдем к быстрому
преображению фурье.
Научимся перемножать многочлены
быстро, два многочлена друг на друга умножим быстро.
И потом решим вот эту задачу.
Вот, поэтому опять же про строки
можно пока забыть.
И наша цель
это имея два
многочлена
их как-нибудь друг на друга
быстро перемножить.
То есть получить многочлен
равный их произведению.
Ну где перемножаем многочлены?
Мы, собственно, так как в школе учили.
То есть это что такое?
Это сумма.
Ну давайте я так в тупую напишу
сумму по всем и
отглядываю.
Ну давайте я так в тупую напишу сумму по всем и
от нуля до м-1
а и тх вытой
на
сумму по всем ж
от нуля до м-1
а ж тх ж
ну просто вот эти скобки раскрыть.
Вот, ну понятно, что
есть решение этой задачи за время
типа nm.
Если считать, что n и m примерно
одинаковые, то у нас есть
реальное объектное перемножение за квадрат.
Скажем, если n равно m, то можно и за квадрат перемножить,
просто явно все эти скобочки раскрыв.
И там приведя подобное.
Это будет за квадрат.
Вот, а мы научимся за n log n.
Значит научимся
перемножать
многочлены
за o от
n log n.
Ну где n это больше
из двух nm.
Так, значит, самый важный факт,
который нам здесь нужен,
следующее утверждение,
какая-нибудь теорема Лагранда или что-нибудь такое,
утверждение будет следующее, что если у нас
есть значение
многочлена в k точках,
то сам многочлен,
если он в степени не больше k-1, восстановляется
однозначно.
Давайте немножко перформирую.
Если
дег p
не больше, чем k
и известны
его значения
в k плюс 1 различные точки,
p от x1 и так далее,
p от xk плюс 1
для попарно различных вот этих всяких
x-ов,
для попарно различных
x1 и так далее,
xk плюс 1,
то сам многочлен p однозначно восстанавливается.
Криво написал, но смысл такой,
что если наложить
на многочлен следующее ограничение,
что во-первых, его степень не больше, чем k,
а во-вторых, его значения в данных
k плюс 1 точки такие-то,
то есть мы знаем, что вот это какой-то y1
и так далее, это какой-то yk плюс 1.
То такой многочлен единственный.
У нас существует ровно один многочлен,
который удовлетворяет вот этому всему набору
оборотов.
Но если у нас есть значение,
то у нас есть значение,
что есть один многочлен, который удовлетворяет вот этому всему набору
ограничений.
Вот, ну это как, не знаю,
возможно, из школы даже утверждение,
что там есть какой-нибудь многочлен лижандра,
интерполационный,
или лагранжа, я их всегда путаю,
лагранжа, да, спасибо, или ньютона.
В общем, есть формула,
в которой можно явно этот многочлен написать,
ну и легко показать, что если два многочлена совпадают
на k плюс 1 точки,
и у них степень не больше k, то они идентичны.
Потому что их разность
имеет k плюс 1 ноль,
а нельзя иметь в общем нулей
большей степень плюс один.
Вот, ну и все, значит,
это как бы,
считаем это пререквизитом,
что как бы вы это где-то должны были слышать.
Соответственно,
наше перемножение будет работать так.
Вместо того, чтобы явно перемножать
по ику, мы сначала найдем
значение p и значение q
в каких-то достаточно удобных точках,
вот эти вот иксы возьмем достаточно удобными,
вот здесь написано, какие они, мы возьмем их просто удобными для нас.
Вот, найдем значение p и q в этих точках,
потом их поточечно перемножим,
а дальше у нас будет значение r
на этих точках известные,
нам нужно будет наоборот восстановить
вот, собственно, то, что тут написано.
Нужно по значению яма многочлена r в точках
нужно будет восстановить сам многочлен.
Значит,
ну, аутлайн алгоритма такой.
Найти значение
p и q в каких-то
удобных точках.
x1 и так далее, x, ну, давайте
напишу k плюс 1.
Затем поточечно перемножить
вот эти значения.
Ну, а то есть, если мы знаем значение p и значение q
в этих точках, то мы знаем значение r в этих точках.
Потому что r
от x этого,
это просто p от x этого, который нам известен,
умножить на q от x этого, который тоже нам известен.
И дальше уже восстановить r
по значениям в этих точках.
Восстановить r по набору значений.
Вот.
Чтобы
вот это восстановление
было корректным
и ровно таким каким нам нужно.
нам нужно, чтобы число точек, в которых мы берем значение, превосходило степень r.
Давайте напишу, что число х, вот этих вот х1 и так далее, которые написал х кап плюс один,
ну то есть ка плюс один, должно быть больше, чем степень r, должно быть больше, чем степень r,
которая равна n плюс m минус два. Нам нужно выбрать достаточно большое число точек,
а достаточно много точек нужно выбрать, чтобы этот многочлен, итоговый произведение,
однозначно по ним восстанавливался, то есть нам нужно, чтобы степень r была хотя бы вот такой,
чтобы число точек было, точнее больше, чем вот этот, больше, чем сумма степеней минус два. Ну вот.
И соответственно, само FFT, быстрое преобразование Фурье, соответственно,
Fast Fourier Transform, быстрое преобразование Фурье, оно делает следующее, оно берет многочлен p,
берет некий параметр, ну пусть будет k и находит значение, значение этого многочлена во всех
корнях из единицы степени k. По многочлену p и числу k находит значение p во всех корнях из единицы степени k.
Начну корни комплексные. Так, кого пугает в словосочетании комплексные корни из единицы степени k?
Никого. Хорошо. Вот. На всякий случай, давай что-нибудь порисуем, вспомним,
что мы про них знаем, про эти корни из единицы. Мы теперь переходим в поле комплексных чисел,
чтобы удобно было работать. Ну и у нас есть некое число k. Наш круг, вот этот единичный круг
разбивается на дуги, на k равных дуг. Соответственно, вот будет один из корней,
это будет единица сама по себе. Ну а дальше мы просто вот этот угол 2p делим на k равных
частей и соответственно, вот с этим промежуточком k у нас будут все эти корни располагаться. Вот этот
угол будет 2p делить на k. Вот в этих точках мы будем считать значение многошленов. Вот в этих вот
корнях из единицы. Так, правильно? Правильно. Вот, ну давайте это сделаем. Значит, смотрите,
пусть p это a0 плюс a1, плюс так далее, an-1, xn-1. Значит, угол fpt будет у нас делить многошлен
p пополам следующим образом. Он заводит два многошлена, p0, во-первых, вот такой вот. То есть
мы оставляем только коэффициенты с четными индексами, а степени x у нас будут такие же
как раньше, нулевая, первая, вторая, третья и так далее. Правильно я говорю, что это наоборот,
все нечетные индексы, ну а степени x такие же будут. a1 плюс a3x, плюс a5x2, a7x2 и так далее.
Только нечетные коэффициенты, а степени x как обычно в порядке возрастания от 0 до, ну то есть
без учет отчетности. Ну, примерно в два раза, да. Тогда есть следующее очень интересное соотношение
на эти два, ну на эти три многошена. Я его запишу так. p от x это p0 от x2 плюс x умножено p1 от x2.
Можно в этом легко непосредственно убедиться, потому что если я сюда поставлю вместо xax2,
то у меня будут как раз все четные слагаемые. a0, a2x2, a4x4, a6x6 и так далее. Ну а здесь сюда
давайте вместо xa поставим x2, будет a1, но я еще умножу его на x, будет a1 умножить на x,
значит a3 на x2, но еще на x, значит a3 на x3 и так далее. В общем все слагаемые в точности у нас
совпадут, поэтому будет верно такое представление. Вот, а дальше смотрите. Так, может k я здесь
зря написал. Ну да, ладно, давайте вот я здесь сделаю дописочку, что k от степени 2, чтобы нам
было удобно. То есть на самом деле вот это k нам же по сути не важно, какое конкретно k вот там
брать, оно должно быть достаточно большое, больше чем там сумма степени минус 2. Давайте для удобства
будем считать что k от степени 2, тогда смотрите, вот если я сюда подставляю корни из 1 степени k,
то после возведения их в квадрат, я получаю корни из 1 степени k пополам. Вот если здесь корень k
от степени из 1, то вот здесь он же, когда возвел в квадрат, это будет уже корень k пополам
до степени из 1. Ну если k четная, то если k от степени 2, то можно всегда будет так делить.
Ну просто потому что если у меня было число в k до степени дающей 1, то его квадрат в степени
уже k пополам, всего лишь дает 1. k пополам умножить на 2, это будет k как раз. Ну и здесь то же самое,
корень уже k пополам до степени из 1. А значит, чтобы найти значение p вот в этих k точках,
достаточно знать значение p0 и p1 в k пополам точках. Потому что когда здесь подставляется
одна из k точек, здесь подставляется уже одна из k пополам точек. Многие там склеиваются,
потому что если я здесь поставляю k разных точек, то здесь их квадрат уже будет k пополам разных точек,
там противоположные как бы склеются. Те, которые отличаются, ну не важно, в общем, что разных
точек здесь будет k пополам. Вот, поэтому это будет такой.
Значит, мы просим рекурсивно запустить вот fft для многочленов p0 параметра k пополам и p1 с
параметром k пополам. То есть мы рекурсивно найдем значение p0 и p1 во всех корнях за единицей степени
уже k пополам вдвое меньше. А затем просто по этой формуле за линейное от k время мы найдем значение
p во всех вот этих вот k точках. Да, то есть дальше за окошко находим значение p во всех корнях k до степени за единицей.
Вот, ну и собственно все. Тогда время работы нашего алгоритма подчиняется нашей любимой
линте. А чтобы найти значение в k точках, нужно два раза найти значение в k пополам
точках и потом еще за линию склеить ответы, чтобы получить самый ответ. Значит время работы это будет
колока. Согласны? Ну хорошо. Первый шаг есть. Вот давайте я его пронумерую. Вот он первый шаг
найти значение в удобных точках. Вот если в качестве удобных точек взять как раз корни за единицы,
в достаточно большом количестве, то это можно сделать не за там линию на каждую точку, а суммарно
за 0,0k. Вот пожалуйста алгоритм. Ну второй шаг тривиален. Если мы нашли по точке значение по яку в каких-то там
корнях из единицы, то дальше их перемножить. Все пары трудно составлять. То есть этот шаг всегда работает за от
числа точек, потому что мы просто перемножаем какие-то числа. Вот теперь третий шаг осталось понять, как наоборот
по набору этих корнях за единицы вернуться к многочлену. То есть если есть значение в корнях за единицы,
то как найти коэффициенты из многочлена? Вот иногда этим мы будем думать. Это сделать давайте мы немножко
переформулируем то, что мы вот только что сделали. На языке матриц. А именно мы нашли следующее соотношение,
весьма нехитрое, но очень полезное. Так сейчас. Я хочу написать видимо, что пусть ω это e в степени 2i
делить на k. То есть это вот эта вот точечка. Ну первый содержательный корень из единицы степени k.
А потому что я беру стройку с тем же номером 4,5, значит должен получить ипи-иди элемент. Вот эта правая
марка, то это b. Давайте перемножим. Что такое идио строка марки cb? Марка cb у меня сложная, минус i на 0, минус i на 1 и так далее.
Это все в ноль миксации. Это идио строка марки cb, а ипи слабее марки стуливые, но это все то же самое, как и снака брусья, и на 0, и на 1, и на 2 и так далее, и на 1, и на 2, и на 1, и на 1, и на 2, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1,
THIS C, Japanese NO, Japanese OK, Japanese NO ONLY ONLY ONLY ONLY ONLY ONLY ONLY NO центральный
Belor, okay.
и умножить. Поэтому перед столбеткой вот.
Но если мы его, если мы веки два,
две сетки перемножим в строку столбец,
то у меня попарно все произведения будут равны единице,
потому что я перемножаю число на его образ.
Значит, все произведения это n,
потому что складываю на x.
Если я здесь не все знак умножить,
то это будет просто про n.
Что им нужно? Я все вот эти,
и эти столбетки, и эти столбетки получу в n.
Вот так должно быть вот здесь вот эти столбетки и и.
Понятно?
Вот. Ну а если я возьму и и здесь, и и здесь,
чтобы они не равны и и,
то там должно быть множество. Давайте просто.
Перемножим опять и в строку в,
нажимим столбец,
дублью
и неравножим.
Добно получит все множество.
Ну, давайте, например, что-то такое.
Здесь на какой-нибудь здесь множество и на ноль.
И так далее.
Умножим столбец,
омега,���oken,
я нашел,
and,
умножим столбец,
и да page.
Так.
И намра стороны.
Уминем60
а так далее.
Уминем60
&
минус
g-минус 2 нужная минус 2
это геометрическая прогрессия
в которой
как это называется?
в номинате по поводу
почему он не равен геометрии?
потому что он не равно z
но это геометрическая прогрессия
это геометрическая прогрессия
как-то в номинате выступает только корень геометрии
никак
но теперь это не n
и я складываю вот эту подводу
давайте обогнать
эта песня фиксирована
с суммой x
теперь мы на ступене
мы знаем, что это такое
так
где?
где?
хорошо
так, верно
я никогда не буду думал о таком
спасибо
вот
ну и что соответственно
здесь будет модно
там все в общем в корень функционной сети
а там что?
там всегда будет модно
а, ну да
потому что если я для вот этого нужна 1 уницепсия
то у меня как раз получилась
почему уницепсия на корень сети 1 единицы?
потому что вот это вот
это ω в какой-то степени
ω сама подсказывала корень fn в степени 1
а теперь я ее и ее еще вот так возвел
ну тогда понятно, что она
тем более в n степени 1
если у меня было ω в n, это 1
у ω в степени j и n в n
тоже понятно 1
потому что вот n умножен 1
значит это корень уницепсия на степени
поэтому здесь просто прогресс
все, поэтому все откалили чеки
которые могут быть уницепсиями
ну вот
значит мы по сути нашли обратную
ну почти обратную
мы с ней будем работать
а в конце наделим надельное снимание
извините
да
вам надо купить купитель
передарить?
да
вот, значит смотрите
теперь у нас получается такая
если раньше мы умножали столбец
коэффициентов на матку w
то теперь нам нужно замножить
опять на некий столбец на матку w
где всюду ω
заменена на ω в минус 1
да, потому что по сути
нам нужно просто вот здесь везде
написать минус показатель
значит
раньше
вот здесь раньше
мы столбец
коэффициентов
столбец чеки
замножали слева на матку w
и перечеки на кисло ω
кисло ω в стову
и перечек
у нас обратная задача
там нам нужно наоборот
по набору значений
многощинных коэффициентов
получите его по детке в центре
то есть по коэффициентам
можно обидеть на w слева
то мне нужно просто
это нужно на w
и смотри чтобы не гнило
то есть теперь мне нужно
набор значений
так они у меня уже нет
да, может слева на матку
где какие-то из этой чеки
на кисло ω в степени в минус 1
и можно
и потом еще в конце не забыть
поделить на n
давайте вот так
припишу в конце поделить на n
тогда мы получим в точности
набор коэффициентов
исходного многочлена
вот
ну а эта задача
она по сути ничем не отличается от этой
только нужно всюду вместо ω
писать ω в минус 1
и если раньше у меня fft
что у меня делал fft
fft брало набор чисел
то есть воспринимало это все
как многочлен
и умножало слева вот на такую матрицу
у которой элементарный вот этот
ну примитивный корень
брался в качестве ω
а теперь нам нужно делать то же самое
только с ω в минус 1
потому что есть
опять некий столбец
нужно умножить слева на матрицу
где всюду вместо ω
написано ω в минус 1
тогда давайте мы считать
что наша вот эта исходная fft
может работать не только с ω
но и ω в минус 1
потому что по сути
в том нашем алгоритме
совершенно не важно
какой именно мы выбирали
примитивный корень
мы все равно
считали вот значение этого многочлена
во всех точках
во всех корнях
задвинутой степени n
там степени k
ну здесь по сути происходит то же самое
от замены ω на ω в минус 1
у меня набор корней не меняется
но все равно все
давайте кружочек нарисую
вот здесь у меня была ω
а здесь будет ω в минус 1
от того что я взял вместо ω
ω в минус 1
у меня набор корней не изменился
все равно все корни
это степени
продон
да все корни
это все равно степень ω в минус 1
раньше я считал что корни
это степень ω
но теперь тоже самое будет
только корни это степени
ω в минус 1
от этого алгоритма не изменится
вот для этого мы просто
используем fft
только с другим основанием
с другим примитивным корнем
используем
fft
с другим примитивным корнем
То есть E в степени минус 2p делить на k, вместо просто
2p делить на k. Ну и делим результат на n. Делим результат на n. Вот, тем самым мы с вами
смогли от набора значения прийти к набору коэффициентов, профита. Давайте теперь еще
раз все это напишем, что нам нужно от нашего FFT, какие он принимает аргументы, и еще раз проговорим,
как перемножить два многочлена во всех тонкостях. FFT принимает многочлен P, принимает k,
являющийся степенью двойки, степень двойки, и принимает примитивный корень омега. Так вот,
что все его степени образуют как раз-таки корни из-за степени k. Значит, первое, что он делает,
это добивает многочлен P до ровно k коэффициентов. То есть мы говорили, что у P может быть степень
меньше, чем k. Такое нам бывает нужно из-за того, что при перемножении у меня нужно,
степень увеличивается, нужно больше точек, значит исходная степень могла быть меньше,
чем точечка точек, где нам нужно посчитаться. Поэтому мы предварительно наш многочлен P
расширяем в точности k коэффициентов. Считаем, что оно равно вот такому многочлену. Здесь нам
нужно в точности ровно k коэффициентов. Если что, дополняем вот эти старшие просто нулями.
Дальше, ну там понятно, если k равно 1, то надо написать условия выхода. Если k – это 1,
то что такое? Корень первой степени 1 – это просто 1. Тогда наш многочлен – это просто
константа, значит нам нужно просто вернуть a0. Если k равно 1, то мы еще поддерживаем,
что степень P не больше, чем k. Точнее, число коэффициентов в P не больше, чем k. Там всего
одно число – это будет константа. И значение многочленов точек 1 – это будет просто a0.
Ну условия выхода здесь тривиальные. Иначе мы вводим наши два многочлена P0 и P1.
Давайте пропишу еще разочек их. Четные нечетные коэффициенты разбили на две группки. Запустили
FFT, P0, k пополам, ω квадрат, и FFT, P1, k пополам, ω квадрат. Потому что когда я перехожу от k
к квадрату, мне нужны уже корни не k той степени, а k пополам той степени. Но если ω был примитивным
корнем в степени k, то ω квадрат – это примитивный корень в степени k пополам. Вот опять же в
терминах круга, если вот это вот – это такая штука, что все ее k степени – это корни из единицы степени k,
то вот этой вот штуке как раз все степени от 0 до k пополам той – это будут как раз корни k
пополам той степени. Потому что каждый четный. Вот здесь вот берем – это будут как раз корни
четной степени – ω квадрат, ω в четвертой, в шестой и так далее. Ровно это здесь нам нужно.
Ну и дальше, p от ω итой – это p0 от ω в степени 2i плюс ω итой на p1 от ω в степени 2i. Все,
и это будет ответ. Для каждого i насчитываем эту сумму – это будет ответ набор размещения нашего
многочленов в нужных точках. Теперь умножение, да, ну не знаю, умножение многочленов. Давай так
напишу – умножение многочленов. p и q. Во-первых, напоминаю, нужно выбрать достаточно много точек,
так чтобы даже произведение p на q однозначно определялось в этих k точках. Ну для этого давайте
скажем, что пусть k, выберем k, достаточно большой степень у двойки, чтобы оно было больше, чем n
плюс m минус 2. Вот я тут писал когда-то, что число точек, в которых мы считаем значение, должно
быть больше, чем степень. Потому что при произведении степени складываются, поэтому k должно
быть такой степень у двойки, которая больше, чем n, давайте я так и напишу, больше, чем степень r
плюс степень q, ну то есть там n плюс m минус 2. Давайте просто идти по степням двойки, там 2,
4, 8, 16 и так далее, берем первую попавшуюся, которая больше, чем вот это, чем сумма степеней.
Дальше запускаем FFT на наших двух многочленах, вот с этим самым k, и в качестве омега берем,
ну давайте я так и напишу, 2p делить на k, на e в степени 2p делить на k, и то же самое для q,
с тем же k и с той же омегой, 2p делить на k. В частности, вот здесь, в этом FFT у меня многочлены
q и q автоматически дополняются до нужного числа коэффициентов, потому что раньше там было n и m
коэффициентов, а нам нужно k, но вот здесь вот на первом шаге мы его дополняем нулями до нужного
числа коэффициентов, поскольку k достаточно большой, больше, чем сумма n плюс m, то мы просто добиваем
нулями до нужного количества. Вот, значит запустили FFT, дальше, ну по точно перемножили, давайте не
буду это писать там в виде кода, просто напишу, что r от омега вжитой, это p от омега вжитой,
умножить на q от омега вжитой для всех g. То есть запустили FFT, нашли значения в нужном наборе
точек, потом их по точно перемножили, ну и теперь нам нужно просто обратно FFT на вот
это многощение r, то есть теперь у меня как бы r хранится как набор чисел, я воспринимаю
этот набор чисел как набор коэффициентов, вот собственно это столбец, вот он, и на нем просто
делаю то же самое только с противоположной омегой, e в степени минус 2 pi делить на k,
минус 2 pi делить на k, и не забывая что сделать, поделить на n, так давайте напишу, конечно,
что это a, return a9 на n, все, все перемножение многошленов. Когда что еще раз? Уточните вопрос,
пожалуйста, ну вот прям, ну типа нам надо написать там класс комплексных чисел, которые
перемножаются, складываются, вообще это просто комплекс, комплекс от double кажется это называется,
комплекс, это просто класс, который хранит там два поля, вещественную мнимую часть, каждый из
которых вот в double, ну там double или long double тут пишете, вот, просто это там класс с двумя полями,
вещественная мнимая часть, на которых определено умножение как надо, на комплексных чиселах
сложение там, ну деление нам вроде тут не надо, но деление на n надо будет в конце, вот, ну либо
сами пишете просто, если не верите встроенному, то можете просто сами свой класс комплекс написать,
там ничего хитрого нет, просто формулки, вот, как вас учили, как перемножать там x1 плюс i y1 на x2
плюс y2, ну там просто так и перемножаете, комплекс, include комплекс, ну или cmas в
худшем случае, ну вроде комплекс просто отдельный, да, да, да, вот это хорошее замечание, давайте
про это немножко поговорим, да, то есть на самом деле тут по ходу мы конечно переходим к вещественным
числам, ну к даблам, к погрешностям округления и так далее, и как вы правильно сказали, даже если
исходные два многочисленного были целочисленные, то вот здесь мы переходим в комплексные числа,
в комплексные числа, корни из однице, там вообще ни капли, ни целые вот эти вот вещественные мнимые
части, но понятно, что результат должен быть как бы целый, да, потому что мы взяли исходно два целых
многочленов, точнее, от вещественных, вот, ну чего, надо округлить просто, да, вот, офигенный совет,
но на самом деле тут как бы я могу только следующее сказать, значит, проблемы, проблемы округления,
как они решаются? Проблемы округления, ну, проблемы погрешностей. Значит, первая мысль, следующая,
что это все точно работает, то есть если вы просто в конце округлите до ближайшего целого, то у вас
все будет корректно работать, если по дороге все числа, вот, которые вы считали были, ну, не больше
чем 10 в 12 по модулю. Значит, пусть P и Q целочисленные, тогда R должен быть целочисленным,
ну, значит, в конце, значит, добавим округление, в конце добавим, добавим округление. Вот это все
точно работает, если все числа, которые у вас используются по дороге, по модулю не превосходит
примерно 10 в 12. Это OK, если все используемые числа по модулю не превосходят 10 в 12. Ну, это такое
эмпирическое, скорее, наблюдение, да, там, возможно, там, 10 в 11, ну, вот, примерно можно на это
закладываться, то есть если у вас такая задача, что вы понимаете, что если у вас даны два
многошлина P и Q, то коэффициенты в R, все коэффициенты в R не будут по модулю превосходить 10 в 12. Тогда
можно смело писать в комплексных числах, здесь все и не парится, у вас, типа, будет, если вы округлите,
у вас оно правильно округлится, потому что числа достаточно маленькие, чтобы их, чтобы на них еще
не успело накопиться ошибка, скажем так. Вот это, как бы, эмпирическое наблюдение.
Либо же второй подход, который чаще, ну, вот у нас там в контесте, возможно, будет, ну, и, как бы,
в таких задачах, там, чисто олимпиадных, где нужно, по сути, многошлина перемножить, это вычисления
в ZP. Переход в ZP для хороших P. Сейчас поясню, что это значит. Смотрите, вот мы до этого переходили
в C, поликомплексный чисел, потому что там есть такие очень удобные точки, корни за единицей,
к этой степени, что, ну, они, во-первых, ну, главное свойство, что есть такая омега, примитивный корень,
что все ее степени это вот корни там какой-то большой степени из однице. И более того,
там было верно, что для любого K есть свое омега, что все K степени этой омеги – это корни из
однице степени K. Вот. Для некоторых P то же самое выполняется в ZP, что для достаточно больших K
есть там такое хорошее омега, что все все ее степени задают тоже корни из единицы какой-то
достаточно большой степени. Ну, вот корни в том же смысле, что омега в какой-то степени – это
единица. Ну, поскольку ZP такое может быть там, где омега любое число из ZP. Вот. Значит,
сейчас я. По-моему, следующее верное утверждение. Если P равно 2 в степени A умножить на B плюс 1,
где B нечетная, то существует такое омега, которое обладает всеми свойствами вот того
самого примитивного корня из поликомплексных чисел, вплоть до степени 2 в степени A. Существует
такое омега, что, ну, во-первых, я напишу, что оно само по себе является корнем из единицы вот
такой вот степени. Ну, конечно, в ZP. Если я уживу в ZP, то все вот эти вычисления производятся,
конечно, в поле ZP. Ну и более того, все предыдущие степени – омега в нулевой,
в первый, во второй и так далее – это различные числа с таким же свойством. То есть все числа
омега в нулевой, омега в первой и так далее, омега в степени 2 в степени A минус 1 попарно
различны. Вот, то есть, вот, собственно, ровно это свойство у нас было основополагающее для
примитивного корня в поликомплексных чисел, что его нужная степень – это единица, а все меньшая
степень – это вот разные числа, которые, ну, конечно, в той же степени дают тоже единицу,
потому что, если я возвожу омега в какую-то степень, то это свойство, что возведение в степень
2 в степени A дает единицу, оно сохраняется. Омега в степени 2A минус 1, 2 в степени A минус 1,
то есть как бы все предыдущие, все до этой. Все числа, вот эти попарно различны. Вот, ну и,
соответственно, если у нас P достаточно хорошая, что вот здесь вот выделяется достаточно большая
степень двойки, то можно делать FFT для всех K, не превосходящих 2 в степени A.
Нет, нет, я же с нуля начал. Вот это же единица, это тоже единица, поэтому только. Почему? Нет,
их всего 2 в степени A, получается, ровно. От нулевой до 2 ватт и минус 1. Вроде все нормально.
Вот так вот я и говорю, что если P, если вот здесь выделяется достаточно хорошая A, то есть если P
удовлетворяет такому свойству, что здесь A достаточно большое, то мы можем выполнять FFT для
всех K, не превосходящих 2 в степени A. Вот если K такое, то в ZP можно делать такой же FFT,
можно делать такой же FFT. Ну, то есть, в смысле, там будет все то же самое по сути. Там такое
же разбиение на 2 многочлены и так далее. Вот, и соответственно, если мы там сами вольны выбирать P,
то просто давайте подберем P, что P минус 1 делится на большую степень двойки. Вот,
ну либо надеяться, что P, которую нам дают, оно такое. Так, давайте я какой-нибудь пример напишу,
я уже забыл, что там есть. Ну, самое мейнстримное для таких задач, как бы задачи, в которых прям,
если вы видите, короче, такой модуль, то это скорее всего задача на FFT, но это не точно.
Вот это я помню, я уже не помню. 119 на 2 в 23 плюс 1. Да, здесь ω равна 31. Что? Нет, главное 23. То есть,
если у нас P вот такое, можно проявить, что оно простое, и можно заметить, что вот это вот
выполняется, тогда вот по утверждению существует такое ω, что его все степени хорошие. Причем,
смотрите, 2 в 23 – это весьма-весьма-весьма большое число. И если у нас там, скажем,
исходные многочлены были степени, не знаю, 10 в 6 всего лишь, да, ну, не больше миллион,
то их произведение, 10 в 6 – это примерно 2 в 20. Их произведение требует у нас 2 в 21 примерно,
да, потому что сумма степеней спокойно сюда укладывается. Поэтому по такому модулю мы можем
спокойно переменять многочлены степени до 10 в 6 примерно. Вот. И тут не будет никаких уже
проблем с переполнением, потому, ну, точнее ошибок с погрешностями, потому что мы переменяем целые
числа, ну, там, в ZP, окей, там, нужно из НТа выйти в лонг-лонг, тогда никаких вообще погрешностей не
будет. Но это все, конечно, только мы работаем в ZP, соответственно, наш результатирующий многочлен
тоже только в ZP мы знаем все его коэффициенты. Если нам вдруг очень хочется сделать целочисленный
FFT в большом каком-то диапазоне чисел, то есть, то есть, провести обычное произведение, но не в ZP,
да, и причем там никакой P нам не подойдет. Давайте несколько P возьмем, а потом бахнем к ТС и теряем
об остатках. То есть, если мы знаем, скажем, то есть, вот, в таком, для такого P, можем перемножить
наши два многочлена и узнать r от x по модулю P. То есть, по сути, это когда я все его, все его
коэффициенты, так, ну, не по модулю P, это плохо говорить, ну, давайте я пишу процент P. То есть, по сути,
это когда все его коэффициенты я взял остаток по модулю P. Окей, сделал это для вот этого P. Дальше,
то же самое я делаю для какого-нибудь другого P, P штрих какого-нибудь, тоже возьму еще какое-нибудь
другое простое, которое также раскладывается, да, на достаточно большую степень, вот здесь,
у двойки выделяется. Сделаю то же самое, узнаю коэффициенты, точнее, остатки отделения всех
коэффициентов r на код новый P штрих. Так сделаю для достаточного числа простых, ну, и дальше,
соответственно, по-китайски теряем об остатках, я могу восстановить все коэффициенты уже без,
без погрешности. Если, скажем, мы знаем, что, на столах, давайте скажу, то есть, если я знаю,
что все коэффициенты вот этой штуки не превосходят там, скажем, 10-40, то мне достаточно взять, ну,
там, пять разных P-шек, пять разных простых, порядка 10 в 10, 10 в 9, узнать, узнать остатки
уделения этого многочлена по всем этим P-шкам, дальше, вот по этим пяти модулям я уже однозначно
восстановлю коэффициенты всех, все коэффициенты в нашем многочлене, потому что просто знаю по
достаточному числу модуля их, значит, знаю, как бы, ну, настоящие значения. Вот, ну, либо можно там
просто написать какой-нибудь свой класс вещественных чисел, который не там восьми байтовый,
а там чуть больше байтов это сделать, написать там свою какую-то длиночку и просто опять перейти в
комплексные числа, просто чуть более точную, чем, чем вот обычные типы позволяют, и будет тоже,
чем больше байт вы вкладываете в ваш дабл, руками написаны, тем больше, тем больше точность,
тем больше приятность, что вы не ошибетесь при округлении. Так, хорошо. Тогда давайте,
наверное, я сейчас обслужу еще, как делать Ft без рекурсии, и на этом мы закончим на сегодня,
потом вернемся к той задаче про строки, к которой мы вдохновились в начале пары. Ft без рекурсии,
Ft без рекурсии. Ну, как это иногда бывает, чтобы наш алгоритм работал быстрее, мы хотим его
написать без рекурсии, потому что когда мы разбиваем наш массив на два куска, рекурсивно
запускаемся на каждом из них, нам нужно будет куча памяти, у нас будут очень сильно вот эти
вот скачки по памяти между двумя рекурсивными вызовами, и, в общем, это работает за нужную
симпатику, но довольно долго, поэтому давайте попробуем от рекурсии избавиться. Для этого я
построю вот такое дерево, того, как у нас разбиваются наши коэффициенты. Давайте представим,
что исходно у меня был многочлен с 8 коэффициентами, давайте посмотрим, как эти 8 коэффициентов себя
ведут. Изначально это все был 1 массив, а 0, а 1, а 2, а 3, а 4, а 5, а 6, а 7. Вот был такой массив коэффициентов.
Дальше при первом же вызове мы разбиваем наши многочлены на четные и нечетные, точнее четные и
нечетные индексы. Влево идем с а 0, а 2, а 4, а 6, вправо с а 1, а 3, а 5, а 7. Сюда пошли четные,
сюда нечетные индексы. Дальше рекурсивно, когда мы оказываемся в этом многочлене, мы воспринимаем
уже вот эти 4 числа как коэффициенты нормального многочлена, в левую часть отправляем те из них,
которые четные, а 0, а 4, вправо и те, которые нечетные, а 2, а 6. Здесь то же самое, а 1, а 5,
здесь а 3, а 7. Ну здесь уже мы спускаемся вот в такие вот одноэлементные массивы,
а 0, а 4, а 2, а 6, а 1, а 7. Так это опять у меня было такое кривое, опять а 3, а 7. Вот. Ну нарисовали
полную историю того, как все эти наши коэффициенты спускаются сверху вниз. Что здесь приятно?
Приятно, например, то, что на нижнем уровне у меня написаны не просто коэффициенты многочленов,
но и значения тех же самых многочленов. Потому что на нижнем уровне мы писали условия, если карбны
единицы, то эти многочлены просто константы. И эти константы равны их значениям в любой точке.
Поэтому это не просто, как я говорю, это не просто коэффициенты, но это сразу значения многочленов.
Значит, я могу вот эти вот ячеечки воспринимать сразу как значения многочленов нужных в нужных
точках. А дальше происходит следующее. Давайте мы как бы вот эту рекурсию сверху вниз развернем,
будем считать, что здесь у меня написаны правильные значения нужных многочленов,
и теперь я иду сверху вниз, и как бы пытаюсь склеить, зная значения вот здесь, вот попытаюсь
найти значения вот здесь. Ну и, например, давайте переход отсюда-сюда. У нас был некий многочлен
там, там, какой-то П, он разбился на многочлены П0, П1. Здесь дают значения П0 в одной точке,
здесь П0 в другой точке, здесь П1 в одной точке, П1 в другой точке. Я хочу из этих значений склеить
и получить значения П в этих четырех точках и сюда их прям записать. Давайте сделаем.
Итак, представьте, что мы как-то так идем снизу вверх, и в какой-то момент у меня есть два вот
таких блока, где лежат в нужном порядке значения двух многочленов П0, П1 в нужных точках, и я хочу
из них склеить значения многочленов. Вот какой-то такой один из переходов сверху вниз, снизу вверх,
снизу вверх, поднимаемся. Что здесь за значения? Здесь значения в точке... Так, сейчас я немножко
потуплю. Тут нам нужны значения омега в нулевой, омега в первой и так далее, омега в n-1, а здесь
у меня значения омега в нулевой, в квадрате и так далее. Окей, сейчас давайте это напишу. Здесь
нужны значения вот в этих точках, а здесь есть значения в точках омега в нулевой, омега в квадрате
и так далее, омега в степени, ну, видимо, n-2. Давайте попробуем найти значение какое-нибудь,
вот, например, вот здесь. Что такое значение П в точке омега 1? Омега в первый. Ну, мы знаем,
что это П0 от омега в квадрате. Я возлил в квадрат эту степень плюс омега в первый, умножить на П1 от
омега в квадрате. То есть, чтобы посчитать, чтобы положить значение вот сюда, мне нужно взять вот
это значение и вот это значение и с нужным коэффициентом их сложить. Поэтому я нарисую вот
такие вот стрелочки, что это значение зависит от вот этого и от вот этого. То же самое давайте я
напишу для П от омега в степени n-2 плюс 1. Оно будет вот здесь. То есть, 1 плюс n-2 на пол
массива вправо. Чему вот равно это значение? Когда я возвожу в квадрат этот показатель,
у меня n-2 превращается в n и соответственно уничтожается, потому что омега в n-2. Остается
здесь П0 от омега в квадрате. Плюс здесь опять я это оставляю. Будет омега, ну давайте, окей,
оставим омега в n-2, плюс 1, умножить на то же самое. П1 от омега в квадратной степени,
когда я возвожу в квадрат, у меня это уничтожится, потому что омега в n-2 будет
просто омега в квадрате. Получается, что эта точка зависит от тех же двух, вот этой и вот этой.
Да, мне никакие другие значения не нужны. И так будет верно на самом деле для любой точке издвинутой
вправо на n-2. То есть, если я возьму здесь произвольный омега в ж этой и омега в степени
g плюс n-2, то они зависят от вот этой точки, которая прямо под ней идет, и от вот этой точки, которая
идет прямо под вот этой омега в степени g плюс n-2. Соответственно, я их значения могу вычислить
через вот эти два. То есть, мне нужно вот эти два значения, чтобы знать эти два значения.
Вот. Поэтому на самом деле, ну, собственно, формула перешеда здесь и как бы написана.
Если у меня есть содержимое вот этого массива на каком-то предыдущем уровне, вот оно,
то чтобы посчитать на следующем уровне, мне нужно просто по вот этой вот формуле как-то их там
склеить. То есть, если я беру вот это значение и из следующего куска на расстояние n пополам,
то я их с нужными коэффициентами складываю. Вот он коэффициент, если что. Там, значит,
тут такой, тут такой. И кладу одну сумму сюда, другую сумму сюда. Вот просто формула пересчета,
как мы, собственно, вот главная форма, мы по ней просто все пересчитываем. Значит,
просто если у меня есть вот один массив, я могу посчитать следующий просто там,
какими-то достаточно аккуратными сложениями и ну, как бы, просто переложить в нужные ячейки,
мне нужно значение. Но более того, это можно даже сделать без привлечения до памяти, потому что,
смотрите, если у меня есть вот этот массив, считать, что все это находится в одном массиве подряд написано,
тогда чтобы посчитать, скажем, вот это и вот это, я беру вот эти два числа, посчитываю их нужной
линейной комбинации. То есть, я знаю вот это и вот это, я беру их нужной линейной комбинации с
нужными коэффициентами и перезаписываю на те же самые места. То есть, я взял вот эти два числа,
сложил их так как надо с нужными коэффициентами и положил сюда, сюда и сюда, то есть, по сути,
я просто их перезаписал. Потому что они больше не нужны, они влияли только на вот
эти два числа, я их посчитал и сразу туда же положил. То есть, по сути, я просто могу на
на этом же массиве итеративно все пересчитывать. Разбивать
его на нужные кусочки, брать два значения, складывать
их с нужными коэффициентами и класть туда же, где они
лежали. И так сделать log n раз снизу вверх пройдя
и наш массив постоянно пересчитывать.
Последнее, что надо сказать, это следующее. Это надо
понять, в каком порядке эти коэффициенты лежат на
нижнем уровне. Здесь они лежат в порядке развернутой
обратной записи от 0 до n-1. Если я напишу вот эти
индексы в двоичной системе счисления и прощаю их справа
налево, то как раз получится 0, 1, 2, 3 и так далее. Например,
4 записываю обратно, то есть 4 в двоичной системе
это 1, 0, 0, читаю справа налево, будет 1. 2 в двоичной
системе это 0, 1, 0, дополняю до трех битиков. Читаю справа
налево, будет опять-таки 2. 6 это 1, 1, 0, читаю справа
налево, будет 0, 1, 1. То есть как раз нужно просто
инвертировать, прочитать справа налево индекс нашего
элемента и будет написано ровно тот элемент, который
нам нужен. Почему? Просто потому, что сначала идут
те, у которых, налево идут те, которые четные, а направо
те, которые нечетные. То есть здесь те, у которых
последний 0. Дальше у этих предпоследний 0, у этих предпредпоследний
0. То есть здесь должен быть те, у которых все нули. Кто
здесь? Последний 0, предпоследний 0, а предпредпоследний 1,
потому что мы в конце пришли в 1. То есть это как раз 0,
0, 1. И если я прочитаю наоборот справа налево, то у меня
получится ровно тот, кто здесь должен лежать. Из-за
того, что я вот так удобно бью на четные и нечетные,
у меня также, я однозначно определяю последний слой.
Но если я знаю последний слой, то нужно просто логарифм
N раз примить вот это преобразование, которое называется преобразование
бабочки, потому что вот такая картиночка, преобразование
бабочки. Ну и тем самым мы развернули рекурс сюда,
то есть мы посчитали последний слой. Дальше логарифм N раз
делаем преобразование бабочки ко всем элементам. И в конце
у нас получается массив значений многочленов в наших
н-точках. Все, спасибо.
