Всем доброго дня. Сегодня у нас последняя лекция. Сразу по организационным вещам. У нас заканчивается
семестр, значит на занятиях, на зачетной неделе мы с вами будем переписывать контрольные,
переписывать всякие, перездавать колоквы, все дела связанные с ними, а также у нас будет такое
мероприятие как удосроченный экзамен. Он будет у нас либо в субботу в 12.00, либо в понедельник в 11.00.
Следственно, кто у кого есть желание, записывайтесь. Значит сразу скажу, что если вы хотите сдавать в
субботу, то надо записаться по среду, включительно если вы хотите сдавать в понедельник, то надо
записаться по пятницу. Зачем это сделано? Для того, чтобы мы еще и смогли проверить ваши
контрольные практики и так далее в быстром формате. Ланика, давайте вспоминать, какая тема у нас была
в прошлый раз. Отлично, конечный преобразователь. Что мы с вами научились понимать про конечный
преобразователя? Да, отлично. И относительно каких операций мы поняли замкнутое конечное
преобразование? Композиция. Композиция, раз. Вот, и сегодня мы с вами как раз посмотрим,
что же можно с этим делать. Итак, для этого нам надо будет с вами показать некоторые факты,
а пример будет у нас следующий. Мы с вами показали в прошлый раз, что мы можем конечный, точнее
обычный гомоморфизм, представить в виде конечного преобразования, то есть построить его конечный
преобразователь. Давайте подумаем, как мы будем строить обратный гомоморфизм. Еще один пример.
Именно так, то есть. Ну и еще, так, ну, единственное, надо показать следующий
факт, почему мы можем определять относительно одной буквы. Вопрос, чему равняется phi от epsilon
для любого гомоморфизма? Epsilon. Почему? Потому что если мы возьмем phi от а, это у нас phi от
epsilon, phi от а на phi от epsilon. В данном случае только epsilon. Вот, поэтому такой пример будет как раз
работать, то есть нам достаточно определить образ каждой буквы. Вот, и теперь смотрите, у нас
получается следующее, что обратный гомоморфизм и прямой гомоморфизм являются конечными
преобразованиями. Ограничение на регулярный язык тоже задается конечным преобразованием,
и конечное преобразование занято относительно композиции. Вот, поэтому, значит, смотрите,
мы будем с вами, а, да, еще одно, еще одно определение понадобится, это не удлиняющий
гомоморфизм. Тоже сегодня мы с ним очень будем хорошо работать плотно. Я бы сказал,
что это гомоморфизм, у которого константа Липшица равняется единиц. Вот, определение.
Все знают, что такое константа Липшица? Да ладно. На каком-то отрезке. Вот это константа Липшица.
Для функции. Некоторые функции Фи. Вот, давайте рассмотрим, значит,
чему у нас может быть образ буквы при неудлиняющем гомоморфизме.
Длина этой штуки. Как будет сверху ограничено? 1. Значит, у нас всегда получается либо Фи от А,
это B, где B принадлежит гамма со звездой в нашем выходном алфавите, либо Фи от А равно пустому
слову. Вот, это нам еще понадобится в нашем занятии. Итак, смотрите, вот у нас есть какие-то базовые
блоки и есть замечательное утверждение, которое говорит следующее. Теремонева называется, она
говорит, что любое конечное преобразование можно представить в виде композиции трех более простых
конечных преобразований. А именно, значит, первое у нас идет обратный неудлиняющий гомоморфизм,
второе ограничение на регулярный язык и третье это неудлиняющий гомоморфизм. Кстати,
неудлиняющий, возможно, что это какой-то баг, сейчас посмотрим, потому что мне кажется все-таки,
что он не является неудлиняющим. В общем, будем доказать эту теорему. На самом деле,
доказательство не очень сложное. Да, ударение на последний слог. Это не Нива, на ней не ездят.
Можно представить в виде ограничений на некоторый регулярный язык, вот это неудлиняющий гомоморфизм.
Вот это у нас гомоморфизм, а это у нас какой-то регулярный язык. Так, ну что, а теперь смотрите
аналогию, которая у вас должна быть в связи с этой теоремой. Кто-нибудь помнит вот такой
замечательный факт. Встречались с ним? Да, сингулярное разложение матрицы. Причем мы
понимаем с вами в этом факте, что D это у нас диагональная матрица из квадратов собственных
значений, а U и V это артагональная матрица. То есть, любое преобразование можно представить в виде
поворота, сжатия, растяжение диагональной матрицы и еще одного поворота. Ну, всегда по-разному пишут,
просто для нотации обычную, ну, математических, если писать выкладки после этого, свойства,
которые используются, обычно именно говорят, что матрица V является транспонированной. Чисто для
удобства, для того, чтобы собственные значения хорошо выписывались и всякие формулы. Значит,
возможно, что вам этот факт нигде больше не понадобится, но если вы вдруг внезапно
займетесь каким-нибудь машинным обучением, этот факт у вас будет всплывать достаточно часто.
Ну, смотрите, гомоморфизм это у нас что такое? Обратный гомоморфизм мы можем сделать identity?
Identity у нас является гомоморфизмом? Вот. Дальше у нас идет ограничение на sigma со звездой. Да,
то есть identity на identity получается. Ну, а дальше наш гомоморфизм, который мы построили. Какой?
А, удвоение каждой буквы. Надо будет на примере посмотреть, сейчас доказательство
конструктивное будет просто. Вот. Я говорю, что не обязательно это будет не удлиняющим гомоморфизм,
а надо уточнить. Вот. Скорее всего это будет не так. Итак, собственно, давайте докажем эту теорему.
Идея такая. Что у нас с вами такое конечный преобразователь? Автомат.
Так, только у нас phi, кажется, да. А? Черт. А в таковом теореме, формулер в теорем,
у нас phi было, да? А, сейчас, секунду. А, это phi. Короче, я слепой. Хорошо. Вот. Хорошо.
Пофиксили. Так, смотрите, конечный преобразователь. Причем, какой конечный
преобразователь мы с вами можем взять? Какому простому виду мы с вами в прошлый раз приводили
конечный преобразователь? Да, у нас на переходе либо аэ, либо эб. А теперь фишка очень красивая.
Давайте возьмем слово. Пусть у нас и сигма со звездой, и гамма со звездой. Да? И сделаем
следующую вещь. Мы с вами сделаем трансформацию. Вот сейчас очень аккуратно. А мы с вами это, так,
psi, так, phi, не удлиняющий гамма-морфизм, сделаем следующее из дельта в сигма со звездой.
Дельта – это переход в автомате. То есть мы каждому переходу в автомате поставим
следующее соотношение. Phi от q1a q2b будет выдавать букву А. Вот. Единственное, давайте поймем,
что же такое дельта со звездой? То есть как алфавит надо множеством дельта делать?
Вывод в автомате – это на самом деле элемент множества дельта со звездой. Вот у нас переходы
либо такие, либо такие. Вот. Вывод в автомате – это будет элемент дельта со звездой. Ну,
поэтому это можно считать гамма-морфизмом. То есть по факту у нас по пути автомате этот
гамма-морфизм будет выдавать слово, которое мы принимаем из эстедеина. Ага. Гамма-морфизм
не удлиняющий, потому что это элемент дельты, а здесь либо буква, либо пустое множество. То есть
что у нас будет делать phi в минус первое? Оно берет слово, которое мы принимаем на вход,
и превращает его в путь в автомате. Дальше. Нам надо его ограничить на регулярный язык.
Согласны? После этого. Потому что у нас обратный гамма-морфизм может быть множественный.
Теперь у нас будет следующее. Я его сейчас поясню. Я пока в кавычках напишу.
Да, одной букве А может соответствовать несколько переходов, поэтому этот прообраз неоднозначный.
Да, обратный А? Да, ну то есть мы берем все множество, но из-за того, что нам не хочется,
чтобы лишние ограничения, ну какие-то другие прообразы у нас были, мы эту всю штуку ограничиваем
на множество путей в нашем автомате. От стартовы до завершающихся... Ага. Так, понятно почему R регулярный?
Потому что мы можем явно построить автомат, который принимает множество из дельты это. Ну то есть
там будет еще пример, но по факту R это у нас с вами... Сейчас. На ребрах дельта написан
буква алфавита дельта. Ну а дальше над этим алфавитом мы просто строим автомат. Собственно,
у нас и стартовые, у нас есть переходы, у нас просто алфавит меняется в нашем автомате.
С того, какие буквы на нем входа и выходы были написаны, на то, собственно, какое именно это
ребро. Все ребра можно переномировать. Тут единственное, надо сказать, что модуль дельта
будет этот. Модуль дельта меньше бесконечности, это важно. Иначе бы мы над этой штукой язык не
построили. Ага. Так, а теперь давайте подумаем, чем же у нас будет это. То есть смотрите, мы что
взяли? Мы взяли наш автомат, наш вход, перевели его множество ребер автомата, выкинули все лишнее.
Теперь что нам надо сделать? Склеить обратно. И у нас преобразование будет следующее. У нас
фи, ой, это от q1aq2ε будет равняться ε, и это q1εq2β будет равняться b. Все, приехали.
Нет, полагались, потому что здесь, если на входе несколько букв, то гаммарфизм сразу
является неудлиняющим. Ага, давай доказать те ряды. Как бы явная конструкция, но дальше как это
доказывать. Значит, давайте проговорим все-таки. То есть пусть у нас слово принадлежит некоторому
конечному преобразователю ψ, тогда рассмотрим пару. Сейчас попробую быстренько. То есть у нас
пара uv принадлежит нашему ψ, тогда и только тогда, когда существует вывод из q0u ε,
которые выводят в нашем автомате q εv, причем мы можем фиксануть ребра по пути delta1 и т.д. delta m.
Но тогда что у нас получается? У нас получается, что delta1 и т.д. delta m принадлежит прообразу
нашего обратного гаммарфизма от слова u. Ну а delta1 и т.д. delta n в другой стороне принадлежит
обратному гаммарфизму от v. Но при этом одновременно по построению delta n принадлежит у нас множеству r,
нашему языку r. То есть получается из этого мы сразу получаем, что у нас есть вот это
пара влежит в выкомпозиции. Дальше мы ограничим это все на регулярку, а дальше мы берем гаммарфизм.
В обратную сторону давайте рассмотрим, какие у нас с вами были преобразования.
У нас получается с вами пара u, v. Это на самом деле пара у дельта, дельта, давайте n какое-то,
на композицию delta n, t, delta n, t. Тут входы выхода на композицию delta n, t, v. Ну собственно из этого
будет следовать, что delta n, t это путь в нашем автомате. Из этого следовать будет, что delta n, t это у нас
получается опять же обратная трансформация, обратного гаммарфизма на это слово. И здесь тоже мы
получаем обратное преобразование. То есть в обе стороны доказательства строятся, ну и собственно
этим мы его можем закончить. То есть главное тут, смотрите, главное тут запомнить картинку,
как это делается. То есть запоминаем, входы мы переводим в ребра, ребра переписываем в слово в
регулярку, а потом по этим ребрам мы восстанавливаем выход. Давайте пример посмотрим. Так, понятно ли
доказательство этого факта? Потому что здесь на входе мы всегда принимаем одну букву
алфавита дельта. Да, алфавита дельта у нас, а выход всегда либо один, либо пустой. Давайте
попробуем построить два примера тогда, поскольку один пример уже запросили у нас. Собственно это
доказательство. Во, замечательная картинка. Только не знаю. Давайте мы, так давайте выберем свет.
Так, во, кажется так будет виднее. Видно, что на доске. Так, давайте попробуем с этой штуки сделать
какой-то пример. Алфавит ребер. Ну тут он у меня обозначен тетой, но на самом деле это дельта. То
есть у нас есть ребра Q01, Q02, Q13, Q23, Q33. Значит прямой гомоморфизм, а точнее обратный гомоморфизм.
Его можно построить, а вот регулярное выражение у нас будет вот такое. Напоминаю, что по любому
автомату мы можем с вами строить регулярные выражения. Эта теремоклиния у нас была в начале.
Собственно получается у нас регулярное выражение либо Q01, Q13, либо Q02, Q23, либо получается Q33
со звездой. И у меня, и кажется сейчас у нас был вопрос, как выглядит этот пример в случае тогда,
когда мы делаем удвоение каждой буквы. Ну если типа действует так, мы можем сделать похитрее,
можно построить конструктивное доказательство. То есть у нас есть ребро X, phi от X. Где наш гомоморфизм?
Это удвоение. То есть по факту X, X, X. Дальше мы переводим это в автомат,
который делает сначала по входу X выход епсилом. По епсилому пишет X. И дальше по епсилому делает X.
Вот такой вот. Давайте эту вершинку обозначим 1, эту вершинку 2. 1X эту вершинку обозначим 2X.
А эту вершинку обозначим 3X. И тогда регулярка у нас будет страшная.
Так. Давайте я так напишу. Сумма по X. 0,1X на 1,2X на 2,0X. Это со звездой.
Ага. То есть для каждого X мы эту петлю разворачиваем на последовательность трех путей.
Вот. И берем X, X со звездой. То есть это получается композиция слов длины 3.
Да. Ну и опять же обратный гоморфизм строится. Так. Понятны примеры? Как строить регулярные
выражения? Отлично. Теперь про применение этого факта. Оно позволяет нам доказать очень много
разных интересных фактов. Мы будем доказывать с вами следующее. Представим себе, что у нас
на входе подается автомат или регулярный язык. Как вы думаете, образ регулярного языка при
конечном преобразовании каким будет? Регулярным. Да. А конечный... свободного языка? Правильно.
Все. Мы сейчас это будем доказывать. Итак, смотрите, теперь на самом деле у нас есть аппарат.
Мы можем доказать на самом деле, что регулярные языки замкнуты относительно гомоморфизма
неудлиняющего, прообраза гомоморфизма и ограничений на регулярный язык. Вот. Поэтому
давайте это сформулируем как факт. Пусть у нас phi kp, r регулярный,
следовательно, psi от r. Как образ языка при конечном преобразовании? Регулярный. Да,
оказательство. Значит, представляем psi как некоторые phi в минус первой id на r, давайте r
delta композиция с некоторым это. Ну и нам надо доказать, что phi в минус первой от r будет регулярным,
ограничение на регулярный будет тоже регулярным, ну и соответственно гомоморфизм тоже будет
регулярным. Так, ну давайте подумаем. У нас phi неудлиняющий. Давайте решим уравнение.
Вот такое вот. Решаем уравнение в регулярных языках. У нас phi неудлиняющий гомоморфизм,
нам надо понять, как у нас решается это уравнение. Да, давайте обозначим множество х,
подножие sigma такое, что phi от x равняется epsilon. Тогда у нас получается v, это у нас x звездой.
Так, давайте сейчас. Вроде так, да? Ну x напишем как сумму буквок. Да, v принадлежит. Вот,
получается, смотрите, phi в минус первой от epsilon будет равняться языком, задавающим
регулярное выражение x звездой. Так ведь? Ага, задача сложнее.
Мы хотим понять, как решается вот это уравнение. phi от w равняется epsilon. Да,
который неудлиняющий гомоморфизм. Просто утверждение такое, что поскольку наш гомоморфизм не
удлиняющий, то любое слово, которое у нас есть, можно представить в виде каких-то базовых
компонентов. Так, ну что, давайте решать теперь phi от... равно b? Да, b это символ.
Ну да. Смотрите, так. Почему это так? Ну, смотрите, допустим, у нас слово разбивается в некоторые
компоненты. Так, пусть k минус 1. И только одна из этих букв может прийти в букву b,
остальные все должны перейти в epsilon. Пусть это буква k. Вот, тогда вот эти все буквы,
они переходят в epsilon. А значит, что вот эта вот штука
принадлежит языку, задаваемой x звездой. И вот эта штука у нас тоже лежит в языке,
задаваемой x звездой. А теперь смотрите, в чем фишка. Теперь давайте решать. Вот такое вот уравнение.
Произвольное уравнение. А, хотя бы два. Ну, смотрите, суть в том, что опять же,
я вернусь к слайдам, то есть как бы решение phi от x равно epsilon, это некоторое множество слов,
которое мы можем обозначать либо x, либо x epsilon. Дальше, если у нас есть уравнение для ad буквы,
то мы можем сделать вот такую вот вещь. Да, то есть у нас получается phi минус 1 adb,
мы можем обозначить как тоже. Давайте нотацию введем все-таки, чтобы не забыть. То есть,
это x epsilon, это x epsilon, а здесь у нас будет, вот это пусть у нас xb будет. Вот, а дальше утверждается
следующее, что вот эти вот все свойства можно переложить для общего языка. Для этого нам достаточно?
Где, где, где? А, язык задаваем регулярным выражением. Да, нам надо взять его элементы,
просуммировать все буквки и получить регулярные выражения. Вот тут детально на слайде написано.
Вот, и смотрите теперь, что у нас получается. У нас phi в минус 1 от произвольного слова,
вот слово в штрих. Это что? Нам надо разложить вот эту вот всю вещь на составные части. То есть,
у нас было слово, допустим, aba ca ba, вот это вот слово. Нам нужно заменить вот эту вот штуку на
следующее, x. О, господи, сейчас. Давайте какое-нибудь короче слово, aba. Aba у нас заменяется на следующее,
x, е, че у нас получается? x, е, xb, xe, xa. Вот такое вот регулярное выражение у нас будет приводить к образу
к образу АБА.
Вот.
Ну, я просто тупо написал.
Понятно, что они сокращаются.
То есть вот это сокращается, вот это сокращается тоже.
Ну, а дальше
что мы с вами говорили, товарищи?
Если у нас есть регулярные выражения,
что будет, если на автомате мы напишем регулярные выражения?
Регулярный автомат.
Множество языков задаваем регулярными автоматами
совпадает с чем у нас?
С множеством регулярных языков.
Так, давайте этот факт докажем,
а потом пойдем на перерыв.
Так, то есть мы доказали,
что если у нас есть неудлиняющий гомоморфизм,
то прообраз от него будет регулярным.
Так, следующий пункт.
L регулярный.
R дельта регулярный.
И чему у нас будет равняться id
на этот регулярную дельту от множества l?
Трещением языков.
Это какой язык у нас будет?
Трещение двух регулярных языков.
Так, хорошо. Ну а что с гомоморфизмом делать будем?
Заменяем регулярный язык и заменяем все гомоморфизмы.
Регулярный язык прогоняем через l и получаем регулярный язык.
Да, то есть образ любого регулярного языка
является регулярным.
Все, доказали.
Ну а давайте после перерыва докажем,
что для контекста свободных языков будет ровно то же самое,
только там будет некоторое усложнение.
В перерыв можете вспомнить,
как выглядит нормальная форма хомского.
Давайте потихонечку продолжать.
Давайте следующий факт,
который мы с вами будем доказывать,
что пусть у нас l это кс язык,
получается psi это у нас конечный преобразователь,
тогда
тоже кс язык.
Итак, давайте поймем,
какой из фактов мы быстро докажем.
Опять же, используем теория манева,
мы получаем,
что у нас
dphi это не удлиняющий.
Не, мы три доказали.
Вот первый.
Вот это первый факт,
которым мы доказывали, да?
Вот это сужение на регулярный,
а третье
заменили
в регулярночке везде буковки
на образ гомоморфизма,
от этих буковочек.
Получили регулярку.
Так, давайте поймем,
какой из этих трех пунктов
проще всего доказать,
обладая некоторыми нашими знаниями.
Обратный гомоморфизм, ограничение
на регулярный или
прямой гомоморфизм?
Да, ограничение на регулярный.
Пусть у нас l
это кс,
r это у нас регулярный язык,
получаем id на регулярный язык,
чему равняется у нас с вами
от языка l.
Все замолчали.
Показывают мысли,
да вон показано, да.
Смотрите,
это пересечение ks
и регулярного, а пересечение
ks регулярного у нас какой язык?
ks.
Мы это доказывали с вами.
Так, теперь делаем
обратный гомоморфизм.
И здесь нам понадобится
решение нашего уравнения,
поэтому я его стирать не буду.
Итак, смотрите,
пусть у нас l это ks язык,
следовательно, существует g
в n в хомского.
На самом деле нормальная форма
хомского здесь нужна чисто для упрощения.
Доказательства.
Такая, что l от g равняется l.
Какие у нас правила есть в грамматике
в нормальной форме хомского?
Ну, а на самом деле теперь
фишка в чем?
Смотрите,
х,
ой, х эпсилон,
это что у нас с вами?
Так, смотрите.
Мы знаем, как решается это уравнение.
Мы понимаем с вами,
что phi в минус l,
первый от эпсилон,
это что у нас с вами?
И это х эпсилон со звездой.
Давайте построим грамматику.
g эпсилон
равняется
s эпсилон,
а p
что там у нас?
n эпсилон, чего не хватает?
Сигма.
Только давайте сигма штрих.
Смотрите, фишка в чем?
У нас есть прообраз v эпсилон.
У нас есть грамматика,
которая по языку g
распознает наш язык l.
Идея такая,
как получить прообраз из этой фишки?
Давайте здесь заменим буквы
на их прообраза.
Да, только буквы на их прообраза
надо заменить красиво,
потому что все-таки здесь у нас регулярные выражения висят.
Поэтому мы должны
эти регулярные выражения превратить
в автоматы,
в грамматики, которые распознают именно этот язык.
То есть нам надо это все
заменить на phi в минус 1 от a.
А здесь это надо заменить phi в минус
1 от эпсилон.
Есть регулярки, соответственно мы пишем
вот такую грамматику
и для буквы a
мы тоже пишем такую.
Да.
И тогда мы заменяем нашу грамматику
на следующую.
Все правила.
Подвешиваем
всю эту историю.
s заменяем на
s эпсилон,
a заменяем на bc,
а a заменяем
на sa.
Да, и вот эти вот sa
у нас как раз задают прообразы.
Нашу букву.
Все.
Да,
понятно как строится
прообраз при неудлиняющем гаммарфизме?
Мы воспользовались фактом тем,
что у нас есть ограничение на регулярном языке.
Так.
Автомат по регулярке, мы для него
кс-грамматику строим.
Мы же по регулярке можем
кс-грамматику построить?
Мы делаем следующее.
У нас была классическая грамматика
в нормальной форме хомска. У нас есть выход буквы,
есть выход эпсилон.
Мы вместо выхода эпсилона хотим
положить сюда прообраз.
Поэтому мы берем для
вот этой штуки, строим
кс-грамматику.
У нас есть стартованный терминал
для этой грамматики.
Есть же?
Да, да, да.
Ну, то есть для х со звездой
давайте образно.
То есть у нас, если у нас есть
х эпсилон со звездой, то грамматика эта
задается так.
С эпсилон.
Как это, господи?
Х эпсилон
с эпсилон
или эпсилон?
Х эпсилон со звездой задается такой грамматикой.
Ну все.
А теперь мы делаем следующее.
Вот у нас была грамматика, мы берем вместо
эпсилона, подставляем сюда
эс-эпсилон.
И таким образом мы
вместо того, чтобы выводить слово
эпсилон, мы выводим прообраз слова
эпсилон при обратном гаммарфизме.
Саша, цель в том, чтобы вместо того, чтобы
выводить сам язык, выводить те слова,
которые для гаммарфизмы пригодились
в слова эпсилона.
Да, построить грамматику,
которую...
Чтобы писать букву А, нужно писать то, что для гаммарфизмы
идет в букву А.
Чтобы это выводить, мы вместо
грамматики эпсилона заменяем
маленькую букву А в правильных правилах
на грамматику,
которая привозит
эту маленькую букву А
в образе.
Вот.
Да, то есть получается у нас
образ...
Как он называется?
Фи в минус первое у нас тоже
КС будет, потому что мы явно
КС-грамматику построили для него.
Так, а теперь
вопрос. Как строить образ при
прямом гаммарфизме?
А?
Ну да, значит
С у нас
А переводилась в А,
значит мы вот это вот правило
трансформируем А, переводится
в образ этой буквы при
гаммарфизме.
Ну а С в эпсилон
на что заменяется?
На С в эпсилон, да.
Все.
Доказали.
Теперь вопрос.
Может ли быть такое
упражнение, которое за
1 решается?
Можно ли построить
конечное преобразование,
которое все слова вида
АВН и БВН будут переводить
в слова АВН и БВН и ЦВН?
При конечном преобразовании.
Почему?
Да.
Это КС язык, а это не
КС язык.
Ура!
Ну так же мы понимаем с вами следующее, что
нельзя никакую букву удваивать вот так.
Это тоже
нельзя задать.
Так.
Это вот одно из способств,
которое позволяет доказывать, что что-то
не является конечным преобразованием,
не сдается конечным преобразованием.
Как вы думаете, есть ли еще какой-то
способ?
Да.
Есть.
Да.
Хотите рубрику
«Эксперимент»?
Ну, это она.
Только мы ее сформулируем.
Только сформулируйте, вы сейчас ее вы.
Хорошо.
Итак, значит,
если у нас С есть конечное
преобразование,
то
существует что?
Да.
Дальше.
Какое слово? У нас нет слов.
Пары.
Так.
Такая что?
Так. Какой простой вид
у нас есть у конечного преобразования?
Либо А,
либо Э.
Да.
Сумма длин
больше равна...
Больше или больше равна?
По-моему, больше равна, чем П.
То есть мы пользуемся тем,
что у нас переходы либо
А, Э,
либо Э.
Да.
Существует такое у1,
у2, у3.
Такие что?
Так, условия какие?
Условия какие у нас?
Сумма длин у1, у2.
Да.
Так, что еще?
Да.
Угу.
Такие что для любого К
больше равно нуля.
Ой.
Не языку, а конечному преобразованию.
Доказательство.
Аналогично тому,
как это проводилось для автоматов,
только, собственно,
перехода.
Нет.
Тогда надо вспоминать доказательство.
Мы берем, делаем цикл,
делаем первое пересечение.
Тут у нас будет пара у1,
в1,
в2,
в3,
тут у нас будет пара у1, в1,
здесь пара у2, в2,
а здесь пара у3, в3.
Поскольку это первый цикл,
то в нем длина не больше, чем П.
Да, да.
А?
Ну да, у1, в1 могут быть любыми,
но в сумме они имеют длину не больше, чем П.
Да.
Да, первое пересечение.
Давайте какой-нибудь пример.
Мы, кажется, его начали обсуждать
в прошлый раз.
Давайте вспоминать, что такое
тивриб.
Тивриб.
Ой, тивирб только.
Это разворот слова «привет».
Шок-контент.
Ну что?
Давайте рассмотрим пример.
Почему нельзя
эту штуку задать конечным преобразованием?
Да, давайте слова подберем.
То есть, берем произвольное П.
Ага.
Теперь берем пару слов.
Которые в сумме длина больше, чем РП.
Давайте возьмем слова АВПТ и ВВПТ.
А слово В, тогда каким должно быть?
ВВПТ и АВПТ.
Понимаем, что в ВВПТ
и ВВПТ
поднимаем, что у нас
для любого разбиения
должно быть
выполнено вот такое соотношение,
что сумма длин
меньше, чем П.
Ой, больше равно, чем так.
Меньше равно, чем П.
Тогда скажите, что у нас такое
У1 и У2?
АВПТ
АВПТ
ВВПТ
Получается следующее, что
у нас У2
получается АВПТ
В2 равнается ВВПТ.
Мы можем взять даже
У1, У2 в квадрате, У3.
Получим, что это у нас
А в степени
Т плюс П
ВВПТ.
А здесь у нас получается
В в какой?
В в степени
П плюс С
АВПТ.
Получается, что либо у нас
Т больше нуля, либо С
ВВС больше нуля и у нас идет нарушение.
Ура!
Приходим к фейлу.
Как вы думаете, что еще
нельзя делать?
Что еще нельзя делать?
Это более сложный пример.
Почему нельзя переводить число
из двоичной системы в троичную?
Отношение должно быть рациональным
числом.
Что, на семинаре рассказали?
А, ну давайте разберем как раз.
У нас как раз есть время.
Не странно.
Так.
А может быть вопрос?
Я считаю, что мы не задали преобразование
не просто автоматом,
а степеном автоматом.
А просто странно, что такое преобразование
сохраняет эти возможности,
а то преобразование сохраняло?
То преобразование?
Не сохраняло?
Нет, скорее всего оно бы не сохраняло,
потому что
мы бы смогли тогда
АВН и БВН, кажется, переводить в
АВН, БВН и ЦВН.
Просто положить какое-то количество
букв А на стэк на входе, да?
А или нет?
Положить одновременно их же выводить,
а потом читать со стэка
Да, а потом читать со стэка
и как раз записать все буквы С.
То есть, смотрите,
предположим, что у нас
КП со стэком.
Мысленно предположим,
давайте построим,
как из АВН и БВН
перевести все АВН и БВН и ЦВН.
Идея такая,
у нас с вами есть АВН и БВН,
когда у нас встречается
буква А,
то мы делаем на стэк плюс А.
Ну, давайте даже...
Да, можно просто читать
АВН, АВН, БВН,
АВН и ЦВН на стэк.
А если мы закончим за слово
АВН и БВН карты?
Зачем нам это делать?
Не.
А!
Ну...
Да, он должен свалиться.
Ну, типа для слов вида АВН и БВН
он должен ничего не выводить.
Не, ну если у нас
нет ограничений на такое,
то кажется, что будет это.
Если у нас нет таких ограничений,
то у нас как бы для образования
работает и слово АВН и П звездочка,
и слова АВН и П звездочка,
АВН и П звездочка.
Можно сделать проще,
можно на вход получать АВН,
и тогда мы на входе получаем
языка звездочка,
а на выходе давайте АВН и БВН.
Ну, по крайней мере у нас, смотрите,
у нас не будет замкнутости относительно
автоматных языков.
Смотрите, да, давайте...
Ну да, потому что
тогда мы АВН
можем перевратить всегда в слово вида АВН и БВН.
Как?
Мы читаем букву А,
выводим аутпут А
и делаем стэк плюс А.
А потом мы делаем...
Из стэка вычитаем букву А
и пишем в аутпут букву Б.
То есть, по крайней мере,
замкнутости относительно
регулярных языков
в этой штуке уже не будет.
Получается, это теорически
может быть более общая история?
Ну да, но надо аккуратненько
исследовать эту всю тему.
Это куда можно двигаться.
Итак, давайте тогда последний пример
как раз разберем,
и дальше я немножечко подведу итоги
и куда, собственно, в этой
истории можно двигаться.
Аутро, так сказать.
Сделаем нашего курса.
Итак, смотрите.
Число в двоичной системе переводим в
троичной системе.
Тогда возьмем любое число.
Дай число из всех единичек
возьмем, образно говоря.
Оно переводится в какое-то число
х в троичной системе.
Теперь берем
лему о разрастании.
У нас получается следующее, что
у нас у1, у2, у3.
Это в какой-то получается
в сколько их тут?
П раз.
Вот, поэтому получается у2,
у нас с вами какое?
Это как 1,
1 и так далее
в катой степени.
А
слово в2,
это будет какое-то, ну пусть
т в троичной системе исчисления.
И дальше мы должны перебрать три варианта
с вами.
Первый вариант.
Если у нас слово у2 пусто,
то тогда в чем
у нас проблема?
То, что у нас
в2 больше нуля,
и мы получается
по любому числу в двоичной системе
исчисления, по такому числу в двоичной системе
можно получить очень много чисел
в троичной системе исчисления.
То есть у нас
получается
у3
переводится
в1, в2,
в катой, в3.
Стоится такого быть не может.
Аналогично мы можем посмотреть число,
если в2 равняется нуля.
Здесь мы получаем
у1, у2,
в катой, у3,
в1, в2, в3.
То есть опять же не прокатывается.
А если у нас у2
плюс в2
больше нуля,
то
смотрите, мы можем...
Как эту штуку сверху оценить?
Сумму этих двух чисел.
П.
И тогда, смотрите,
мы можем померить отношение
к нему.
Ой.
К чему эта штука стремится?
Ага.
Вот. Причем
у этой штуки какая-то ограниченная
дробная часть.
То есть знаменатель этой дроби не больше, чем
П. Да?
Ну а по факту, это к чему
должна стремиться?
А, так.
Так, если у нас число
два вентой,
да.
Да, ну в общем, к какому-то
логарифму, вот,
тут надо понять, что где стоит,
но в общем, а?
В двоичной системе должно быть более длинное число.
В двоичной системе должно быть более
длинное число.
Тогда наоборот.
Но эта штука не
одержит в множестве
рациональных чисел.
Да, поэтому у нас
в одном месте эта штука к одной
части стремится, а это к другой.
Проиграли.
Вот такой пример.
Так, у нас даже осталось
13 минут с вами.
Мы с вами даже,
кажется, закрыли весь блок.
Давайте посмотрим, может, что-нибудь.
А, более сложный пример.
Собственно, по-моему,
моим группам я дал это в домашке.
Почему нельзя
два числа перемножать?
Почему нельзя число в квадрат
переводить? И почему, собственно,
есть проблемы некоторые с правильным искобочным
последовательностью?
Значит, давайте теперь
поймем, куда
можно с этой стороны
двигаться. Во-первых, значит,
есть такая теория, которую мы
не будем рассказывать,
от Диари Махомского Шуцембирже,
которая говорит, что на самом деле любой
КС-язык можно представить
в виде комоморфизма
относительно
пересечения, кажется,
языка с правильным искобочным
последовательством на некоторые регулярные выражения.
То есть вообще как представляется
любое, попытаться разобраться,
как выглядит любой
контекст свободный язык. Это раз.
Вторая тема, которую можно поисследовать,
это посмотреть, что же будет с конечным преобразователем,
если к нему, допустим, стэк присобачить.
Третья история,
о которой можно двигаться, значит,
сразу скажу, это
новые типы парсеров появились,
так называемые parsing expression
grammars. И, собственно,
если
внимательно
посмотреть,
зайти
в замечательную
историю,
в релиз нол спайтон
3.10,
кажется,
где-то это здесь должно быть.
Видите, нол
не лл1 capacity of new parser.
Вот. И нас встречает
такая вещь, которая ни фига не видно.
В общем, раньше питон использовал
лл1 parser.
А?
Да.
Сейчас перешли на новую
тип парсеров под названием
peg parser.
В нем есть замечательный синтаксис,
в котором по факту
можно выводить, и пока что математически даже неизвестно, какому классу языков приводят пег-парсеры.
Какой класс языков они распознают?
Потому что, по-моему, через него можно AVEND, ABVEND, AVEND распознавать при некоторых ограничениях.
Ну и вывод в нем достаточно сложен.
То есть он подходит для какого-то типа, определенного типа грамматика.
Вот это куда можно копаться.
Значит, другая тема, к которой можно копаться, это связь, значит, так называемых контекстно свободных языков.
Получается однозначных контекст свободных грамматик.
И получаются этих, детерминированных автоматов с магазинной памятью.
Такие есть.
Возможно, вы помните такие штуки, если решали когда-то задачу с EG.
Там надо было, есть какое-то входное выражение, там надо было распарсить что-то, подобрать токен, который к чему-то подходит.
Вот, то есть это тоже можно смотреть.
Там, кажется, Виталий еще выкинул всякий список тем, которые можно прийти послушать к нему на доп-семинар.
Ну и последняя вещь, если совсем подниматься, то можно разбираться в этой штуке с контекстом свободными грамматиками.
Либо подниматься уже на машины тюринга и пытаться с ними работать с точки зрения некоторых ограничений по памяти.
Как раз эти классы NP, P-Space и всякие прочие вещи, это будет на курсе сложности вычислений.
Ну а можно пойти писать компилятор, сказать, ребят, нам этого хватит. Погнали писать компилятор.
И тогда уже будет веселье с тем, что на вершинах дерева вывода у нас будут уже не абы что.
То есть не какой-то узел дерева, а возможно будет висеть какое-то выражение на выходе.
И тогда нам надо будет уже проверять семантический анализ и строить другое дерево,
которое уже будет более приспособленным для какого-то типичного исполнения.
Вроде бы плюс-минус я перечислил все вещи, куда можно двигаться от этой темы.
Так что вот такой курс.
И давайте последняя вещь, которая может быть полезна вам.
Будет, что на самом деле все задания контрольных работ были сгенерены автоматически.
Наверное, вы слышали про это.
Да, собственно, на самом деле для того, чтобы падежи использовать,
почему мы приходили к конечному преобразованию, есть такой пакет Pymorphy 2 называется.
И, собственно, при помощи него можно строить какие-то простые конечные преобразования,
типа приведения слов к другим падежам и согласования с числительными.
Очень мощная тема.
Поэтому у нас в автоматическом генераторе вариантов контроля не было 2 буква, 3 буква, 4 буква.
И согласование это может тоже делать при помощи конечных преобразователей.
В общем, я думаю, на этом все.
Если есть вопросы, задавайте.
А так, думаю, спасибо, что пришли, выходили на лекции.
