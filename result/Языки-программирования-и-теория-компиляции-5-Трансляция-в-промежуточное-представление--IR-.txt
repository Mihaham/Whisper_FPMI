Всем доброго дня, мы с вами наконец-таки собрались
после перерыва.
Да, видимо, перерыв нам очень сильно подкосил.
От нас всего тут очень немного людей, но я надеюсь,
это к семинару хотя бы подправится.
В прошлый раз мы с вами начали рассматривать такое
понятие как таблица символов, и мы с вами научились строить
вот такие вот интересные объекты как таблица скопов
наших перемен.
То есть мы с вами сказали, что неплохо было бы для
каждого объекта в нашей симматической таблице научиться
определять его тип.
То есть у нас с вами не то что тип, а его симматическую
структуру.
То есть когда мы с вами встречаем допустим идентификатор
под названием scopeExample, хотелось бы сказать, что этот scopeExample
это будет именно название нашего класса.
То есть у нас есть несколько скопов и дополнительно
у нас должна быть таблица символов.
Я посмотрел некоторые реализации, и в этих реализациях оказалось
следующее, что в некоторых из них как раз скоп функции
и таблица символов находится в одной концепции.
Но опять же мы можем сделать не только так, а мы можем
еще сделать иначе.
Иначе в том плане, что грубо говоря, хранить таблицу
символов отдельно, а хранить дерево скопов отдельно.
Значит сразу скажу, что у глобального скопа, если
мы рассматриваем чисто объектно-ориентированный
язык, коем является у нас джава, у нас в глобальном
скопе могут быть только названия классов.
Если мы говорим про другие языки, то у нас там могут
быть переменные, у нас там могут быть функции, у нас
могут быть классы.
Значит внутри класса, у нас внутри скопа что находится.
У нас там могут быть либо поля, либо метода, а внутри
скопа определенного метода у нас уже, если мы не рассматриваем
лябдо функции, пока что давайте их выкинем, потому
что это интересный момент, у нас с вами будут как раз
переменные, которые мы с вами определяем, возможно
вызовы каких-то других функций, но в общем мы определяем
зачастую именно переменные.
И внутри текущего скопа может быть еще один скоп,
в котором мы с вами определяем объекты.
И как раз вот эти скопы иногда называют блоками.
И вот смотрите, у нас с вами есть вот такой вот пример,
и что мы можем с этим примером сделать?
То есть наша цель как раз объявить те переменные,
которые у нас умеются, плюс дополнительно сверху как
ни странно нам нужно будет определить, а каким образом
к этим переменным обращаться.
И для этого нам полезно понимать следующую вещь.
Нам полезно понимать, как эти переменные будут
объявляться.
Для этого давайте попробуем переписать ту функцию,
которую у нас есть в C-стайле.
Почему это важно переписать функцию в C-стайле?
Потому что мы тогда сразу для переменных будем понимать,
какой сдвиг от начала стека у них есть относительно
праймпоинтера.
Итак, как этот код будет переписываться?
C-89 года.
Итак, как он будет выглядеть?
Да.
Не-не-не, я говорю чисто про переменные, конечно
же.
Значит смотрите, у нас наши функции сначала будут
объявлены int a, дальше int x, после этого у нас будет
if b больше нуля, а равно пяти, return b плюс a, или else, я те
в докод пишу.
Ну, вот, значит, что это нам позволяет сделать?
Нам это позволяет сразу объявить следующую вещь.
Да, у нас есть int b, и здесь мы говорим сразу, что вот
эта переменная у нас по факту нулевая переменная
в нашей функции, то есть она нам передается на стек,
и если мы возьмем с вами праймпоинтер, то первый
элемент во праймпоинтер это будет переменная b, дальше
следующая переменная, которая у нас будет, это будет переменная
a, и после этого нам нужно будет объявить переменную
x.
То есть когда мы с вами будем идти в коде, нам надо
будет явно отслеживать, когда эта переменная была
объявлена.
Мы в прошлый раз с вами как раз посмотрели сущность
связанных со структурой объектов, и тут нужно сказать
следующее, что если мы с вами будем реализовывать
классическую таблицу символов, и будем смотреть именно на
скопы переменных, то у нас может возникнуть неприятная
ситуация.
Я сейчас попытаюсь найти пример как раз, почему нельзя
сразу объявлять таблицу скопов и по ней идти.
Значит, как раз нам Николай очень сильно в этом помог.
Давайте посмотрим на вот такой код.
Значит, while i равно равно нулю, так int i, так, вот такой код
Значит, давайте фигурные скопки.
Что у нас этот код выводит?
int i равно нулю, while i равно равно нулю, print i, int i равно единице
print i.
Да, он выведет бесконечный цикл.
Но смотрите, если мы с вами попытаемся сразу построить
таблицу символов и таблицу скопов, то у нас произойдет
следующий эффект.
У нас появится переменная i, а дальше в скопе номер
ноль у нас появится переменная i, тоже еще одна переменная
i.
То есть у нас появляется глобальный модификатор.
И в чем возникают проблемы?
Значит, когда вы будете объявлять вот таблицу скопов, вы
говорите окей, у нас уже с вами есть переменная, которая
называется i, то есть мы сразу построили с вами таблицу
символов на определенном проходе сканера визитера.
Значит, у нас с вами есть переменная i, и дальше говорим
окей, у нас эта переменная i есть, когда мы заходим
вот сюда, смотрим на ее содержимое.
Собственно главное, чтобы мы не зашли во внутренние
скопы в этот момент времени.
Если мы обращаемся к этой переменной, то все хорошо.
Если мы не обращаемся к этой переменной, а пытаемся
обратиться именно к этой переменной, то возникают
проблемы.
Потому что у нас эта переменная уже i становится равной единице,
по идее мы ее уже с вами стираем.
О, смотрите, вот такой пример, i равно 0, а вот здесь мы вставляем
i равно 5.
Да, ну а на интерац, даже если мы здесь поставим i
равная 0, то какая проблема у нас возникнет?
Мы уже зашли с вами внутренний скоп, мы пытаемся посмотреть
на значение переменной i, она по идее должна быть
объявлена в этом скопе, а значение у нее будет равно
единице.
То есть мы будем обновлять значение переменной, которое
находится не здесь, как это логически должно происходить,
а здесь.
Вот мы будем обновлять значение переменной, которую мы еще
не объявили.
И поэтому с этим нужно будет аккуратно обходить.
То есть когда мы в прошлый раз посмотрели пример, когда
мы на стеке объявляем переменные и их кладем, все нормально.
Если мы с вами будем визуально хранить таблицу скопов,
то все это в виде деревя, то придется еще хранить
идентификатор того, когда эта переменная была добавлена.
Нам нужно будет заводить timestamp, которое по входному
значению, грубо говоря, по индексу будет определять,
существует эта переменная еще или нет.
Потому что у нас возникнет вот такой вот сайд-эффект,
который не хотелось бы рассматривать.
Как угодно, можно хоть уникстайны сделать.
Ну конечно же, какой-то индекс, в котором мы заводим
наши элементы.
Это что касается построения таблицы символов.
Когда мы с вами уже имеем таблицы символов, нам нужно
будет сделать еще несколько визитеров.
Дальше у нас можно еще прогнать одну стадию
валидации визитеров, которая будет проверять, вообще
мы можем вызывать наши объекты или не можем вызывать
наши объекты.
Вот в чем проблема, давайте обсудим еще одного кода.
У нас тряпок немного осталось.
Это, к слову, о том, как нужно будет обходить визитером
эти все штуки.
А код такой, образно говоря, вот такое поведение.
То есть у нас получается класс foo, дальше у нас создается
объект типа bar, а потом внутри мы вызываем внутри
объекта bar объект типа foo.
Смотрите, если мы пойдем сразу объявлять таблицу
символов, то в чем проблема получается?
Мы заходим вот сюда, мы видим с вами, что у нас выполняется
конструктор класса bar, а класса bar еще нет, потому
что мы не дошли до этого места в программер.
Что мы с вами получаем?
Не, это не обязательно в конструкторе, я говорю.
Да, то есть смотрите, нам нужно будет, вот тут очень
важно сделать следующее, что когда мы будем вызывать
визитер для обхода всего этого, нам нужно будет либо
сделать два визитера, которые сначала просто построят
объекты, которые у нас нет, а дальше провалидируют
их вызовы.
То есть что здесь можно вызывать bar и методы bar, здесь
можно вызывать foo и методы foo.
Либо первый обход, который мы делаем с вами, когда мы
делаем визитера, мы находимся с вами в глобальном сколпе,
нам нужно будет проверить, сразу записать таблицу
классов, что у нас будут конкретные классы для того,
чтобы у нас хотя бы код в первом приближении
работы.
Вот.
Вот это понятно, что иногда визитерах нужно корректно
задавать порядок, что нельзя просто внутренне обходить
это все дело рекурсивным выпуском, иногда нужно заходить
именно внутрь.
Хорошо, а теперь давайте обсудим, какие нам визитеры
нужны, прежде чем мы с вами перейдем в промежуточные
представления.
Нам нужно, во-первых, научиться строить таблицу символов,
во-вторых, нам нужно будет валидировать эту таблицу
символов, в-третьих, нам нужно будет проверить
типы, вывести систему типов, потому что будет интересно,
если вы напишите код вот такой, int b равно var, вызываете
конструктор класса и присваиваете его к int.
Ну, можно, да, если мы хотим это сделать, нам нужно сделать
конвертацию типов, то есть по факту нам нужно будет
посмотреть, оператор равно для int, то есть там придется
делать некоторое преобразование, мы это будем опускать, пока
что это сложная для нас вещь, но и дополнительно,
конечно же, если мы говорим про такой код, то не нужно
забывайте про наследование, то есть для наследования
нам нужно будет еще одна, по факту, тот же самый аналог
таблице символов, только уже для наследования, то
есть нам нужно будет простраивать иерархию наследования
типов.
Это что касается визитеров, и последний визитер, который
нам понадобится, это визитер, который будет входить внутри
каждой функции и определять сдвиг относительно начала,
нужно будет для каждой переменной понять, какой сдвиг ее относительно фреймпоинтера,
чтобы мы к ней могли обращаться уже в машинном коде. Вот, и когда мы это все сделаем, мы с вами
можем уже как раз переходить к, так сказать, ER представлению. Я нажимаю на escape, оно не
escape-ится. Вот, поэтому мы с вами начинаем новую тему, как раз, которую мы, я думаю,
сегодня на семинарах будем смотреть, это трансляция в промежуточных представлениях.
Сразу скажу, что на семинарах мы с вами будем смотреть представление именно в LVM ER,
он более высокоуровневый, чем текущий ER, который мы будем рассматривать на лекции. Вот, я как раз
говорю, что у нас будет более низкоуровневое представление, просто по той причине, что
нам нужно будет считать обсеты относительно фреймпоинтеров. Давайте определим некоторые
особенности. Где мы сейчас находимся, мы наконец-таки заползли до вот этой части,
когда мы выходим из фронтэнда и начинаем работать как раз с вами в промежуточные
представлениях, говорить с вами про промежуточные представления. Так, что у нас с вами есть к этому
моменту? Значит, у нас с вами есть таблицы символов, у нас с вами есть проверка типов,
и у нас с вами есть примитивные фреймы. Что это означает? Это означает, что у нас для любой
функции, которую мы вызываем, мы знаем какие аргументы, каким образом эти аргументы кладутся на
стэк, то есть какие у них сдвиги относительно стартовых элементов, и наша цель будет как раз
преобразовать каждый фрейм в правильный код, который мы с вами можем проинтерпретировать.
И как раз нам помогут сейчас некоторые вещи создать как раз для составления промежуточного
представления. То есть цель будет построить дерево промежуточного представления, а во-вторых,
это понять как работает механизм создания фреймов. Да, то есть сейчас нам прямо фреймы не
нужны, потому что у нас высокоуровневая вещь. Когда мы будем уже спускаться в более
низкоуровневую вещь, мы про это поговорим. Итак, значит, давайте еще раз вспомним картинку,
зачем нам нужно промежуточное представление. У нас с вами есть front-end, мы можем написать
произвольный front-end на разных языках программирования, и нам нужно проводить стадии оптимизации. И как
раз стадии оптимизации проводится поверх промежуточного представления нашего кода,
а после этого мы с вами идем и все компилируем в определенный тип бэк-энда. То есть это у нас
может быть либо бэк-энд по какую-то архитектуру, либо у нас может быть какой-нибудь там,
образно говоря, какой-то экзотический бэк-энд для real-time operating system, например. Значит,
напомню еще раз, как выглядит код VR. Это вот все напоминания в первой лекции. Значит, в чем его
отличие? Давайте поймем. Справа, конечно. У нас здесь появляются индексы T1, T2, T3, T4.
У нас с вами по факту есть здесь виртуальный регистр. Мы можем прочитать значение из
виртуального регистра, записать значение в определенный виртуальный регистр. То есть справа
в этоиты это виртуальный регистр. И здесь как раз у нас статик single assignment form. То есть у нас
каждый раз, когда мы что-то делаем, мы строим новый виртуальный регистр. Кроме команды store,
которая записывает именно значение по регистру по определенному указателю. И здесь мы как раз видим,
что если мы вызываем какой-то функционал, то зачастую мы вызываем его поверх указателя на
наш объект. Поэтому нам нужно с вами как раз научиться приводить, возможно, не к такому типу,
но хотя бы к похожему типу. И как раз видите, здесь у нас есть i32. Здесь мы не запариваемся по
поводу того, какие у нас ассеблерные инструкции зафигинируются. А нам бы хотелось сделать что-то
более низкоуровневое. То есть у нас t1 должен быть аллотирован, это указатель относительно
фреймпоинтера. То есть получается t1 это фреймпоинтер, t2 это фреймпоинтер плюс 4,
плюс 4 байта, t3 это фреймпоинтер плюс 8, t4 это фреймпоинтер плюс 12. То есть у нас переменные
будут располагаться с вами на стеке. Так, ну хорошо, давайте тогда посмотрим, собственно,
какие есть необходимые свойства у LVM Skyar. Как раз первое свойство LVM Skyar заключается в том,
что мы будем с вами использовать статик Single Assignment. Один виртуальный регистр может быть
присвоен единожды. Мы можем изменить значение нашего виртуального регистра только при помощи
операции Store. Дальше, значит, у нас есть фии инструкции. Это важное свойство, по которому поговорим
чуть позже. Третье, у нас есть толчистые типы, причем они могут быть произвольными. То есть дальше
нам на уровне бэкэнда нужно будет решать, каким образом эти натуральные числа преобразовывают. То
есть в принципе, когда вы пишете LVM Skyar, вам может быть сказано, ну сделайте переменную i17.
Да, ну, наверное, мы с вами понимаем, что это скорее всего будут там два int и бул какой-нибудь.
Какой два int? Один short получает один байт, один бул. Да, в VR такое можно написать LVM Skyar,
но, правда, таким вот никто не пользуется. Но для була используют i1.
Да, его надо кастовать потом к i8 для разных операций.
Вот, дальше у нас используются только указатели. То есть у нас с вами аллок i64 или i64 звездочка,
и есть поддержка структур данных, и есть поддержка векторов. Она является рекурсивной.
Так, давайте рассмотрим пример фи инструкции. Значит, здесь есть определенный код. Вот,
смотрите, интересный код заключается в чем. У нас с вами есть функция m, которая принимает
на вход два мула, и второй Bool l. Он заключается в том, что это y, и смотрите внимание на оперант.
Здесь оперант две палки. Если был бы оперант одна палка, код был бы намного проще.
В чем особенность оператора две палки, двойной лопайп?
Да, это означает, что у нас переменная r будет вычитываться только тогда, когда переменная y равна нулю.
Если есть параллельное ядро, то можно. Это так делают, кстати. Более того, так на видеокарте
работает. Ну, потому что ему вперед просчитать что-то, для того чтобы потом подставить значение и
подставить все по маске. Ну, всегда зависит от всяких таких вещей. Вот, и как раз здесь есть у нас
пример этого кода в иаре. Значит, дальше, например, здесь мангл-инструкция, то есть define void,
и дальше z1 mbb. Что это означает? Это означает, что у нас дальше идет функция. В ней один элемент,
эта функция имеет название длины 1, название у нее m. Дальше у нас два аргумента, значит,
bb. Это по факту определение двух булов. Дальше у нас и1, мы видим с вами y. Дальше, значит,
мы что делаем? Мы с вами по факту сохраняем эти переменные во внутрь нашей функции, вот эти
вот две строки. Давайте увеличу этот код. Значит, дальше мы алоцируем переменную l, aloka. Дальше
мы конвертируем нашу i1 в i8 и храним это все в переменную. Store i from bool x. Дальше мы создаем
еще одну переменную from bool zx i1 y to i8. Это, если что, lvm код. Дальше храним значение наше,
при этом указан выравниваем. Дальше мы зачитаем значение этого всего дела. Почему-то обратно мы
это все конвертируем в bool, опять снова в i1. Да-да-да, не, по идее, тут можно было бы сразу...
Нет, у нас просто уже есть i1. Зачем, спрашивается... Да, протент можешь генерить любую вещь, согласен.
Да-да-да, согласен. Да, и вот смотрите, к чему мы приходим. У нас здесь переменная to bool есть и
дальше у нас есть br. Значит, br это либо jump, либо condition jump в зависимости от числа переменных.
Вот, и мы говорим to bool. Значит, смотрите, если to bool у нас true, то есть получается to bool это у
нас кто и 0, это y. Если y у нас true, то мы прыгаем с вами в end сразу, иначе мы прыгаем в правую часть.
Давайте посмотрим, что будет, если мы не прыгаем в правую часть, тогда нам нужно загрузить значение
и получить значение. Да, это особенность иара. Да, он не умеет проходить сквозь метки. Зачем это сделано?
Это сделано для того, что вот эта вот штука, вот которая от метки до бранчика называется basic
block'ом. Главная особенность basic block состоит в том, что их можно ставить в любом порядке.
Зачем это нужно? Объясняю, у вас дальше, значит, можно эти блоки будет объединить в трейсы,
вот, и дальше задать линейный порядок. То есть, допустим, нам окажется, что большая часть инструкции,
которая у нас есть с оптимизатором-компилятором, понимает, что ему надо зайти в правую часть,
в большей части случаев, чем не зайти в правую часть. Да, да, да, и поэтому мы как раз их соединим
в одну инструкцию. Вот, значит, дальше у нас есть прыжок и label, и вот тут начинается веселая
часть. У нас появляется fee-инструкция, которая говорит следующее, что если мы прыгнули из вот
такой метки, то поставь такое значение, а если мы прыгнули из другой метки, то поставь другое
значение. То есть мы говорим, что если мы прыгнули с вами из изначальной метки, то означает выражение
у нас true, действительно. Когда мы прыгнули в end, тогда когда у нас тубул равняется единице,
то есть когда наше значение равняется единице, значит у нас здесь уже результат true. Вот, а если мы
говорим про другую метку, вот здесь, то мы прыгнули отсюда, соответственно, нам нужно посмотреть какое
значение было в этой метке, которую мы, кстати, определили только внутри правой части. Да, это виртуальный
регистр.
Технически нет, но в большей части да, а дальше список условий.
Лорр РХС, да. Дальше кастуем и возвращаем в Void. Кстати, а зачем мы? Ну, сразу можно понять,
что компилятор, что это все было скомпилировано с опцией минусу ноль.
Ну вот, то есть он, как бы, генерировал сложный код. Ну да, в общем, вот такой вот код, собственно,
практиковать мы его будем на семинарах, на лекциях мы немного пойдем по другой части. Так, значит,
значит, смотрите, нам нужно будет сейчас, как ни странно, взять дерево, абстрактное
синтаксическое дерево с его структурой и переложить его в другое синтаксическое дерево. Но
синтаксическое дерево здесь уже будет не выглядеть не как список, да, ну, его можно представить в виде
дерева, при желании. Списка деревьев. Ну да, часто формали не образуют, но, в принципе,
мы их можем тоже анализировать, как в виде дерева.
Не, у нас может...
В ветке. Не, в исходном...
Не, ну бренч, они все-таки, ну да, они будут завязаны под другие переменные, да. То есть нам
нужно будет правильно эмитить наш выход, получать результат.
Ну да, тут уже реализаций много, да, я все-таки бы угадал, как это сделать, как это сделать.
Ну да, тут уже реализации много, да, я все-таки буду говорить про более такую
теоретическую основу. Значит, смотрите, и сразу скажу, что в ER дереве, значит, мы можем сказать,
что у нас есть аля в ER дереве, в кавычках, значит, у нас будут некоторые типы. Первое,
это экспрешена, это те, что мы будем считать. Значит, дальше у нас будут стейтменты,
это, собственно, операторы присваивания, там вызовы самих экспрешен, которые не влияют на
результат, там принт инструкции, кстати. Кстати, сразу скажу следующий момент, что принт инструкции,
это на самом деле не совсем стейтмент, это больше экспрешен. Да, ну вот, не, мы пока будем считать
все-таки отдельные стейтменты. Значит, дальше нам нужен будет экспрешен лист, зачем нам нужно
будет в какой-то момент времени экспрешен лист, в какой-то смысле, именно список экспрешен хранить.
Мы должны, да, оно хранит стейтмент лист. Да, когда мы вызываем функцию, у нас может быть
несколько аргументов, как раз в данном случае нам нужен будет экспрешен лист. Стейтфлис
basic утверждений и, значит, тут еще можно добавить, как раз коллеги добавили, что мы можем говорить
про такой панист как basicplog, который будет состоять из стейтных листов. И при этом в начале у него
будет инструкция видометки и в конце будет инструкция videojump. Это, кстати, тоже будет стейтментом.
Значит, смотрите, здесь вот такой вот список выражений предлагается экспрешен, давайте обозначим
их. Значит, тут надо тоже быть в какой-то степени аккуратным, потому что все зависит от дерева и яра.
Значит, мы с вами можем объявить, да, тут именно синтаксис такой, мы можем с вами объявить константу,
это по факту аналог нашего number expression. Дальше у нас может быть метка, это как раз через
которую мы будем с вами прыгать. После этого у нас может быть временная переменная tempT, после этого
у нас может быть с вами бинарная операция. Вообще, знаете, сразу скажу, что вы можете взять любой
собственный ER написать, главное его сигнатуру определить. А дальше здесь, в том яре, в котором
я основываюсь, есть такая вещь, оператор mem, memory. Значит, она позволяет вам по любому экспрешену
получить значение виртуального регистра, то есть, если в левой части вы его используете,
то вы получаете указатель на lvalue, который вы можете записать значение. В правой части это
Rvalue. Не надо. Ну да. Да, да, так тоже можно. Согласен, в принципе ER это и сделает. Да,
да, смотрите, у нас получается, что оператор mem по факту это либо оператор load в определенной
части. Мы загружаем наш указатель, дальше по нему пишем значение. Дальше у нас должен быть call
expression, это вызов функции s с аргументами list. И на самом деле здесь еще есть такая одна абстрация
в текущем дереве. Это в яре. Это некоторый аналог, который позволяет нам вычислить некоторые,
так сказать, утверждения s, после чего вернуть значение, результат выражения e. То есть,
это некоторый side-effect, который нам может понадобиться. Вот это оператор e sec, expression
sequential. Вот. Тут можно подумать, где это нужно. На самом деле это обычно нужно, когда нужно,
допустим, взять какую-нибудь переменную, скастовать ее к определенному типу, потом получить результат.
Это переглядный. Да, это выглядит как оператор запятая. Вот. Когда он все-таки нужен. Так,
список выражений, значит, список утверждений. Здесь как раз есть тоже некоторые абстракции,
которые есть. Первый оператор это у нас как раз присваивание значений в метку. Второй оператор
это оператор store. То есть, как бы мы получаем указатель на метку e1, вычисляем значение e2 и
после этого перемещаем значение в указатель. То есть, это оператор store. Вот. Вот этот оператор
это оператор, как он называется, давайте промотаем. Вот это оператор, то есть, вот это у нас оператор
load. Вот этот оператор store. Это псевдояр, так сказать.
Ну, это да. Ну, в какой-то степени да. В целом можно сделать так. Значит, дальше смотрите. Здесь,
конечно же, сразу почему скажу так, потому что когда это, кстати, из книги этой, создание
миниджава компилятора. Вот там они предлагают такой язык ER. Понятно, что в современных реалиях
мы понимаем, что его можно сильно упростить. Да, то есть, грубо говоря, если у нас есть conditional
jump, то conditional jump мы делаем на определенные условия, а не на некоторые операторы. Но все
равно тоже интересно посмотреть не только один пример ER, но и другой пример ER для того,
чтобы понять, как они соотносятся между собой. Значит, дальше у нас есть expression,
которая вычисляет в выражении E и игнорирует результат. То есть, expression будет на вход
принимать expression. Дальше у нас есть оператор jump, который делает прыжок в метку L. Это по факту,
если мы говорим в классическом и aria L вемовском, то это оператор burr без никаких операторов,
без никаких аргументов. Следующая функция это conditional jump. И вот смотрите, поскольку вот в этом
aria не предусмотрено тип boolean, то нам приходится выкручиваться вот так. То есть, что у нас есть
оператор, который принимает два выражения, и дальше мы вычисляем значение E1, вычисляем значение E2,
сравниваем их по операции. Если результат true, прыгаем в ветку T, иначе прыгаем в ветку F. В aria
мы бы сделали следующее. Мы бы вызвали какой-нибудь бинарный оператор в сравнение, загрузили бы это в
boolean метку, сделали бы прыжок в результат. Дальше у нас есть оператор sec. Кстати, про то,
почему это может быть деревом. Просто мы можем sequential объединить в список. И последнее стоит
вот это создание метки. Опять же, напомню, что это такой псевдоэфемерный яр, и это такая
дань история. Потому что LVM в то время еще, по-моему... Кстати, давайте узнаем, в каком году LVM появился,
первый релиз. Давайте посмотрим.
2003. А вот эта книжка написана в 2001 году, то есть она появилась еще до того, как появился LVM.
Поэтому удивительно, что есть какой-то другой яр. И, кстати, к слову, к ответвлению, знаете,
в некоторых компаниях, которые появились еще в бородатых 90-х годах, есть даже свои собственные
стандарты языка C++.
Чего?
Да. Ну, своя надстройка над компилятором и свои библиотеки поверх компилятора.
Вот. К примеру, есть такая компания, я не знаю, как она сейчас называется, по-моему,
она сейчас в России называется А4. Это бывшая компания Abbey. Вот, так там в Abbey как раз свой
собственный стандарт. Насколько я знаю, в Одинэйсе тоже в свое время был свой собственный
стандарт, но потом они его прокачали и они отстают на одну версию от стандарта, от классического
сейчас.
И, кстати, в Куде тоже свой собственный стандарт.
Смотрите, тут еще один важный момент. Хочу сказать, что, грубо говоря, в каких-то
стандартах могут быть разные языки промежуточных представлений. То есть, как бы, у GCC свой
есть ЯР, у вот этого языка свой собственный ЯР, у LV тоже свой собственный ЯР.
Так, ладно, давайте посмотрим как раз пример этого Яра. Значит, какие типы
экспрешенов у нас могут быть? У нас могут быть типы экспрешенов, это экспрешены, это могут быть
стейтменты, это выражения, в которых результат игнорируется. И третье, это условные выражения,
здесь явно выделяются условные выражения, которые необходимы для прыжков по меткам,
то есть, чтобы мы делали conditional jump. Вот. И, значит, если действовать по классической
реализации, то необходимо было бы сделать обёрт конвертера между классами. То есть,
каким образом, собственно, сделать экспрешены, которые там, грубо говоря, объект, который нам
берет что-то конвертирует в экспрешен, что-то конвертирует в стейтмент и что-то конвертирует
в conditional, то есть, которые при этом добавляют ветки true и false. Сразу скажу, что этот код не
скомпилируется, потому что true и false вряд ли вы сможете передать в прогументу функции,
если только никакой другой язык. Вот. Значит, смотрите, как это делается. Вот. И смотрите,
вот у нас есть вот такой вот код. Значит, если у нас а меньше b и c меньше d, то мы прыгаем в true
блок. Иначе мы прыгаем в false блок. Ну, собственно, здесь это можно конвертировать так. Нам нужна будет
дополнительная метка z, которая делает следующее. У нас создается несколько наборов секвенсов. Мы
сравниваем, значит, с a и b, прыгаем в метку z, если значение true. Если нет, то мы прыгаем в значение
в метку false. Дальше у нас получается, если у нас есть sequence, то он, собственно, появляется новая
метка z, и дальше делаем еще один jump. То есть вот так вот, вот эта вот штука превращается в conditional.
То есть она нам сгенерирует несколько блоков подряд. То есть вот это выражение, оно будет прыгать,
значит, либо в блок, который связан с true. Давайте я как раз тут чем удобен zoom рассказываю. Да,
то есть смотрите. Так, смотрите, вот у нас получается, объявляется метка. Значит, первое
секвеншал это у нас conditional jump. Он будет говорить, что мы прыгаем с вами, если условие выполнено,
то мы прыгаем в ветку z и ветку f. Дальше мы делаем следующее. Говорим, окей, значит, если у вас
метка z, мы ее объявляем здесь, и говорим следующее, окей, а здесь мы ставим еще один c jump,
lt cd, c меньше d, получается ветка true и ветка false. И при этом где-то вдалеке будет у нас ветка true,
собственно, ветка true и ветка с false, которые метки эти тоже будут объявлены, но это где-то
будет потом. То есть вот таким вот образом мы с вами можем конвертировать эту штуку в conditional
jump. Опять же, если нам нужно будет вычислить значение выражений, которое здесь есть, нам
нужен будет аналог fee инструкций по тому примеру, который у нас рассматривали в прошлом. Так,
поедем на этот пример. То есть если мы получается сразу прыгаем false, то мы сразу прыгаем false,
иначе мы прыгаем в эти метки. Хорошо, так, мы убираем эту запись, clear road drawings и поехали
дальше. Так, значит, для выражений, для стейтментов здесь сделается следующее. Значит, c jump,
а, так, это стоп, у нас что было, значит, для выражений, так, а, это для стейтментов было,
вот, для стейтментов, допустим, для expression, если мы сделаем, да, то expression верни себя,
и дальше смотрите, что мы можем сделать дополнительно, если у нас это, допустим,
не был какой-нибудь conditional, да, а именно мы получаем expression на вход конвертации в
conditional, то мы должны сгенерировать дополнительную инструкцию, что у нас выражение не равно нулю. То есть
то значение в expression, которое у нас было, оно не равняется нулю, если оно не равняется нулю,
то мы прыгаем в true, иначе прыгаем в ветку fall. Так, для стейтментов, давайте подумаем,
значит, каким образом происходит конвертация? Можем ли мы стейтменты сконвертировать в expression?
Нет. Ну да, да, да, не раз. Statement, statement. Да, это жрецное преобразование, а в conditional?
Это условное выражение, которое типа принимают в conditional jump, по факту. Statement. Навряд ли,
наверное, да. Ну да, именно так, то есть...
Да. Да, то да. Нет, нет, я скажу следующая вещь. Пока это такое псевдоярм. Если мы говорим
про этот ярм, у него будет еще одна из стадий, называется линия реализации.
Ну да, нет, поэтому для этого типа иаров его нужно еще причёсывать, чтобы он стал
линейным. На самом деле, я честно скажу, судя по опыту, я могу сказать, просто люди
булл не хотели придумывать. Булл придумывать. Да, второй тип перемены, и из-за этого возникают
все проблемы. Ну да, поэтому если у нас булл, то понятно, что большое количество экспрешенов
можно просто там conditional нам нафиг не нужен. Вот, смотрим условное выражение, сразу типа
делаем две метки. Так, значит, это мы обсуждили, значит, для условных выражений. Значит, если мы
говорим про условные выражения, то нужно учитывать разные блоки. И поэтому здесь, если так по-хорошему
говорить, если поддерживать все эти операторы, то нужно будет конвертацию этих операторов в
conditional делать. То есть, допустим, нам нужно, с вами будет конвертировать это все в экспреши. Условные
выражения, если мы не хотим булы, тогда нам нужно будет вот этот conditional превратить следующую
вещь. То есть, что нам нужно будет с вами, значит, объявить две метки r1. То есть, смотрите,
что происходит. Мы указываем, что r равняется единице, а дальше делаем две ветки f. Если мы делаем
jump в ветку f, то у нас r равняется нулю. То есть, давайте я тоже опять нарисую здесь, что здесь
происходит. То есть, смотрите, здесь мы объявляем r, присваиваем метку единички. Да, тут ассоции не
пахнет. Значит, дальше мы с вами делаем следующее. Вот это вот оператор nf, это он создает нам две
ветки. А дальше мы говорим следующее. Значит, делаем ветку 0, здесь у нас будет ветка f, ветка 0.
Вот, и с, и в ветку t. Вот, и дополнительно мы получается разворачиваем conditional. То есть,
получается у нас следующая вещь. Когда мы хотим условное выражение какое-то сконвертировать,
то мы должны получить значение результата r, которое будет пройдено через вот этот такт. То есть,
когда мы будем его конвертировать, у нас появятся две метки tef, через которые мы их как раз и
их сможем связать. То есть, у нас получается сайд-эффект вычисления наших выражений. Вот,
так такая сложная инструкция, которая скорее всего не очень приятно выполнять. Вот, и соответственно
здесь можно обсуждать, что можно сделать для других веток, для and or negate. Собственно,
если and, то мы создаем промежуточную ветку для первых true, во-вторых false. Значит, для or мы
выполняем оператор or, как в питоне он делается, или двойная палка. Мы делаем все то же самое,
аналогичное оператору and, и в операции negate мы меняем ветки местами. Ну, то есть, если у нас
было, грубо говоря, одно больше, чем второе, в выполнении jump ветки true и false, то мы их
меняем местами, получаем jump ветку false true. Кажется, все логично. Так, вот, так, это что касается
jump. Теперь давайте наконец-то придем к сути, как это все дело конвертировать. Первая операция
это чтение переменной. Вот она будет выглядеть вот таким образом. То есть, мы для нашей переменной
знаем сдвиг относительно frame pointer, поэтому если мы хотим взять значение какой-то переменной,
получить, загрузить значение какой-то переменной, то нам нужно сделать следующее. Нам нужно будет
сделать бинарную операцию frame pointer плюс ее сдвиг и взять ее в память. Это у нас оператор
workloads так будет выглядеть. Ну или вообще оператор store. Значит, теперь вопрос, как хранить массивы?
Тут есть несколько подходов. Давайте обсудим.
Гениально. Где у нас массив хранится будет?
Так, два варианта. На стейке куча и еще один. Да, можно засунуть их туда.
Ну, в общем, смотрите. На самом деле три варианта перечисли. Если брать Pascal like
вариант, то массивы это отдельные переменные, которые можно забивать в память. Если мы
C like массива возьмем, то это массивы указателей по факту, которые занимают некоторую последовательность
символов на стейке. Да, я и говорю, что это отдельный тип именно.
Пхп like тогда уж. Тогда уж пхп like. Мы можем с вами создавать массивы в куче. Причем мы будем
умулировать call внешней функции с набором параметров. Назовите, пожалуйста, функцию,
которую нам нужно будет вызвать для того, чтобы алоцировать участок памяти на куче.
Malog, да. Просто мы когда будем это все делать, то есть когда конвертация VR происходит,
нам нужно создать массив, просто убирать ее и пишете call Malog. Да, и получаете указатель на...
Конечно, можно.
Да-да-да. Ну, если посмотреть просто любой исполняемый файл, который у нас генировал,
в гел-файл у него есть утилита лдд. Просто посмотреть какие динамические либилитетики
там подключаются. И там по подавляющей большинства просто липси подключил.
Ну да, единственное, где это вы можете увидеть, что у вас что-то не использует липси, это надо зайти
взять docker образ busybox и в нем что-нибудь попробовать запустить. Ну да, часть механизма липси.
Так, ладно, давайте тогда перейдем к структурам. Значит, все подобные в языке поля структуры могут
иметь произвольное количество параметров, поэтому VR и LVM на самом деле существует понятие
выравнивания, то есть позволяет указывать для каждого перемена, как они выравниваются.
Вот, и, собственно, если мы говорим про наш механизм MEM, то мы можем дополнительно передать
параметр, типа какое именно выравнивание мы хотим использовать для наших переменных.
Дальше, веселая вещь. Собственно, как обратиться к элементам массива, на самом деле очень просто.
Взять указатель на начало массива, это оператор load, сделать сдвиг на него на определенное
количество слов, если мы работаем с вами в byte offset, либо сделать сдвиг на определенное
количество элементов. В VR и LVM, господи, как это называется, по-моему, GetElementInboundsPtr,
или как-то так, там специальная функция есть, GetElementPtr. В VR, я думаю, мы посмотрим это на
семинарах. Кстати, это касается элементов массива. Вопрос, все знают Питон? Типа, ну, на самом деле...
Нет, нет, нет. Смотрите. На самом деле, если мы посмотрим на все функции того, как выглядит
функция VR и LVM, то мы внезапно обнаружим, что они выглядят все как в Питоне, потому что у них
как раз первым аргументом будет передаваться указательность здесь.
Ну, это мы совсем уже в низку уровню спускаемся. Мы все-таки пока на ИАРе находимся. Вот. Значит,
на самом деле обращение к полям класса ничем не отличается от обращения к элементам массива,
просто нужно понимать, какой элемент относительно зысо находится для этого поля. Да. Да. Вот. Поэтому
арифметика. Ну, мне кажется, здесь все просто. Для арифметики бинарная операция. Вот. Значит,
если нужно делать условные выражения, то мы можем сделать следующее. Тобственно, мы объединяем их в
необходимом порядке. То есть, two conditional, true, false. Дальше, то, у которого условие у нас идет
then statement, то мы их находим после метки true. После этого мы здесь делаем jump метку after. После
этого мы пишем label false, указываем метку соусом. После этого делаем метку jump в after. И после этого
получаем after. Ну, дальше строковые типы. У нас создается именованная метка. Можем создать. Вот.
И все операции можем производить в runtime аналогично массивам, умеющимся. Вот. Тем более,
кстати, в питонии строка это, там, итерация по строке, это то же самое, что итерация по массиву
из чаров. Вот. Собственно, массивы и структуры мы можем тоже вызывать. Нам нужно будет делать
lock, malloc. А, кстати, важный момент. Нужно, когда вы выделяете массив, вы создаете массив размером
на один больше, чем количество элементов.
Да, согласен. Здесь просто про input все говорится.
Да.
Ну, да.
Так. Хорошо. Да. А вот это, допустим, то, как можно хранить значение. То есть, это
инициализация структуры. То есть, мы сделаем malloc, а дальше записываем значение элемента
наших массивов. То есть, я один, первый я записываю со двигом, второй со двигом на одно слово и так
далее. И после этого мы получаем нашу структуру. То есть, мы получаем наш указатель. То есть,
это прямо то, как можно прям массив сразу с унициализацией получить. То есть, вы пишете int
x, квадратные скобки равно, там, вот это вот. И сразу то, что вы в него записываете. Так,
что касается создания массива структуры. Циклы, кстати, переписываются вот так. То есть,
с while у нас получается, если не выполнена condition, то мы идем в done. Выполняем body,
go to в jump начальную метку. For обычно переписывается в while. Да, вот. Значит, если мы с вами хотим
callingConversions для функций и для методов класса, то мы вызываем call от имени нашей функции. Для
методов мы вызываем call от полного классификатора нашей метки класса и передаем аргументы.
Первым аргументом передаем указатель на this. Это callingConversions для меток. Так,
объявление переменных, кстати, здесь можно опустить. Либо мы явно их, если мы говорим
про RLVM, то мы делаем aloka. Вот. Так, это, так, я думаю, что на этом мы остановимся,
потому что здесь как раз уже идет callingConversions, который вот нам для практики сейчас не нужен. И на
семинаре мы тогда посмотрим примеры конвертации в RLVM. Вот. Там просто дальше последняя часть слайда
про RLVM. Если, допустим, надо будет, мы просто вспомним, как это делается еще раз. Так. Наверное,
на сегодня из основных моментов все. Значит, что мы с вами сделали? Давайте просуммируем. Мы с вами,
собственно, разобрали некоторые подводные камни с примерами с таблицей символов. Поняли,
что нам нужно для того, чтобы начать готовиться к IR, и в дальнейшем мы как раз разобрали, каким
образом можно все делать, конвертировать в IR. Значит, в следующий раз мы с вами посмотрим,
как эти некоторые инструкции можно оптимизировать. То есть посмотрим, как любой IR можно, в принципе,
приводить к линейному виду. Ну и дополнительно начнем говорить про оптимизацию. То есть делаем
классификацию оптимизации.
