Давайте вспоминать, на чем мы остановились.
Так, ну если так вспомнить, то глобально мы пытались
с вами в прошлый раз найти подстроку в строке, причем
пытались делать за линию, да, причем завод леденицы
дополнительной памяти.
Да, и собственно, этот маленький нюанс и приводит нас к тому,
что строчки пришлось изучать сильно глубже.
Дошли в итоге мы аж до такой замечательной вещи, как
префиксный период.
Ну давайте вспоминать.
Давайте вспоминать.
Так, надо выписывать определение, или как бы, да, но давайте
все равно.
Ну ладно, записывать не буду, но вспоминать давайте
будем.
Так, ну давайте вспомним хотя бы, что такое базовая
строка.
Давайте вспомним.
Что такое периодичная в формальном смысле.
Да, то есть ее нельзя распилить на несколько одинаковых
строчек.
Да, ну суть одна, понятно, хотя в случае да, у нас
к равно заняты и равно 4, хотя в принципе алгоритм
работает для любой константы к не меньше 4 на самом деле.
Поэтому к занято, но суть одна.
Да, теперь давайте вспомним, в каком смысле мы понимаем
периодичность.
Ну, по определению базовость такие или по…
Ну глобально.
Вот мы говорили, что строка является тампой периодичной,
если…
Ну, существует такая строка, что типа, если записать
много раз, тогда наша строка будет в префикс.
Да, именно префикс.
Ну да.
Или что то же самое, строка является периодичной, если
любые два символа в ней на расстоянии П совпадают.
Ну в принципе да, одно и то же.
Да, это у нас такие, можно сказать, основные действительно
понятия.
Да, дальше у нас там начинаются еще всякие там понятия типа
reach.
Ну вот, то есть типа там напоминают нам Z функцию,
да, помните, давайте вспомним.
То есть, давайте как бы мы сказали, что такое reach хотя
вот с индексом S от P.
Насколько далеко мы Пшкой можем пройти?
Ну вот.
Ну не совсем так.
Да, напоминаю.
Мы говорим, что строка S у нас, то есть у нас все
строки в один индексации живут.
А reach, это мы говорим, то есть надо найти максимально
возможную длину P периодичного префикса строки S.
Можно так сказать.
Ну то есть можно сказать, что это просто равно P плюс
Z функция строки S в точке P плюс 1 на самом деле.
Вот.
Ну тут вот удобный reach, то есть действительно очень
удобный образ.
Действительно, что, то есть мы хотим взять префикс
строки P и продолжать его П периодичным образом.
То есть идти по строке S дальше П периодичным образом,
насколько далеко мы дойдем.
Так, ну и давайте вспомним.
Теперь ключевое, давайте вспомним.
Вот.
То есть ключевое у нас определение, это, конечно, префиксный
период.
Так, ну давайте вспоминать, что такое префиксный период.
Ну базовое и четыре.
То есть мы помним, чтобы T была префиксным периодом
строки S, нужно чтобы T в степени K было префиксом.
И чтобы еще T была базовая, это важно.
Нет, определение префикса никуда не делось.
То есть, как бы понятно, строка является префиксом
строки S, если она получается из строки S, вычитывая удалением
нескольких символов с конца, возможно, там, возможно
нуля.
То есть, понятие префикса, более того, у нас возникнет
сочетание базовый префикс, но это будет, конечно, сильно
сломало, но строка называется базовым префиксом строки
S, если она базовая и она префикс.
Вот.
Да.
Вот.
А вот с префиксным периодом почему-то так не работает.
Увы.
Да.
Ну это вот у нас такие вот особенности разговора.
Вот.
Ну и, в принципе, если так не повторять всего того,
что у нас было, хотя в каком-то виде нам придется вспоминать,
то давайте вспомним, то в принципе у нас было, то
есть нам осталось только доказать мистическую теорему
о декомпозиции.
В смысле опять?
Мы в прошлый раз доказывали, разве?
Да.
Вот.
То есть теорема звучала так, что любую строку P можно
разбить.
Нет, в смысле это не конец.
Так-то теорема, конечно, очевидна.
О от модуля.
Чего?
От модуля V.
Так.
Так.
Так.
И вот еще так.
Еще одно мистическое заклинание.
Что это за шифт вообще?
Ну, в принципе, давайте еще раз вспомним, что до
шифт с индексом S от P это что такое?
Ну, в нашем случае можно написать что-нибудь типа
P минус префикс функции.
То есть, на какое минимальное количество символов можно
сдвинуть префикс длины P строке S, то есть так сдвинуть,
чтобы на месте пересечения, то есть вот как-то вот так
вот сдвинуть, чтобы на месте пересечения, то есть вот
этот вот конец совпал с началом.
Так, нет, погодите, погодите, нет, префиксный период у
нас другой.
Напоминаю, что K это у нас еще константа, которая
равна четыре.
Ну, не максимально, наоборот, минимальная, то есть, можно
так сказать, минимальная длина какого-то периода,
префиксы длины P строки S, если так формально говорить.
Мы с вами остановились на том, что если мы поверили,
что теория Ма не просто верна, а то, что мы любую строку
P от P можем распилить на две такие строки, и более
того, еще и найти, более того, еще и знать, есть ли там
префиксный период, и если да, то кто он, то выяснялось,
что действительно под строку P в любой строке S мы после
этого спокойно за линию ищем.
Так что да, это у нас вот было, но теперь нам остается
только эту лему каким-то мистическим образом доказать.
Так, ну ладно, ну давайте так, начнем с такого разминочного
утверждения.
Значит, разминочка, такая разминочка, серечье воспоминания.
Значит, давайте скажем так, пусть у строки S есть префиксный
период, префиксный период, какой P1, допустим.
Да, начинается этот момент, то есть мы начинаем доказывать
теорию Ма.
То есть мы сейчас не будем повторять как с помощью
этой теории мы собственно под строку строки ищем,
это как говорится, смотрите, там смотрите предыдущие
видео, ссылка, возможно, в описании, ну или смотрите
на канале.
Да, вот, соответственно, и значит, что у нас еще есть,
есть префиксный период 1 и базовый префикс, вот длины
P2, здесь тоже по-хорошему надо было бы слово длинных
ставить, тут понятно, вот причем, да, P2 больше P1, причем
еще и оказывается, что reach от P2 больше либо равно
чем 2P2, че, че происходит, ну вот да, да, увы, тут когда,
вот, так что происходит пока вот это, тогда говорим
мы, P2 больше, чем K-1, P1, неожиданно заключаемый, с формулировом
так, в некотором виде было, у нас была лимма 1, но она
формулировалась более жестко, она формулировалась, что
если у строки есть два префиксных периода, то они отличаются
друг от друга более, чем в K-1 раз, ну ладно, это не
лимма 1 была, давайте сейчас, нет, лимма 1 это другое,
да, то есть да, ну вот теорема, да, то есть такое у нас было,
но на самом деле мы отмечали, что теорема верна на самом
деле скорее в этом виде, но все-таки для того, чтобы
тоже еще так воспомнить и повторить, давайте попробуем
это еще раз доказать.
Ну то есть единственное отличие, что тут мы берем не префиксный
период, а префикс базовый.
Ну да, вот когда мы берем больше длины, мы берем просто
строку, которая, то есть просто базовый префикс,
но давайте разбираться, почему же это вообще так, так, давайте
как всегда, жила была строка S, жила была строка P2, которую
мы тут, то есть которая тут вот согласно этому ричу
два раза повторилась, и где-то тут у нее был базовый
нод, еще и префиксный период P1, а что значит префиксный
период P1?
Что?
Да, вот, то есть что значит префиксный период P1?
По-хорошему это означает, что P1 вот тут может быть,
то есть где-то, ну давайте тут у нас строчка S будет
там бесконечной вправо, потому что нас интересует
такое начало, то есть значит P1 у нас вот где-то вот таким
вот образом встречается.
Вот, ну правда тут нод, так, ну значит к этому, что можно
сказать, что нод, что мы теперь тут можем на этой
территории сказать.
Ну, опять-таки, если у нас меньше либо равно, тогда
мы K-1 один раз запишем P1, P2, а потом еще раз допишем
вправо, и оно все еще влезет в зону.
Ну вот, значит смотрите, да, что такое K-1?
Так, ну вот, ну K-1 это у нас 3, поэтому по сути, то
есть говорим теперь, что пусть у нас есть, то есть
если мы пойдем от противного, то есть если мы пойдем теперь
от противного и скажем, что там P2 не более чем K-1, то
есть не более чем 3P1, то звучать это тогда будет,
то есть скорее так, то есть тогда мы себе заявим, что
у нас, значит, этот вот P1, то есть вот 3 копии, а там
дальше 4 заведомо зайдут, так, P1, P1, P1, и еще там P1.
Вот, но тогда про эту, но тогда что мы можем сказать?
Тогда мы вот про эту строчечку красивую можем сказать,
что она, во-первых, P2 периодично и P1 периодично.
Логично, да?
Ну, ну тогда, ну вот, а дальше у нас воспоминается
наша неподражаемая лемма периодичности.
Она нам говорила следующее, то есть не буду сейчас писать,
но суть такая, что если у нас жила была строка, которая
была, давайте какие-нибудь другие буквы подберем,
допустим, она A периодично и B периодично, а еще ее длина
больше либо равна, чем A плюс B.
Тогда неожиданно, чего?
Мы наказали, что…
Да, ну мы в принципе усилили, вот, на самом деле.
Ну вот, ну это другой вопрос.
Вот, но как бы, как говорится, ради знания цена иногда…
Так вот, так вот, что если длина строки хотя бы вот такой длины,
то тогда оказывалось, что из этого всего следует,
что у нас строка нод AB периодично.
Ну, в случае длины A плюс B совсем легко доказывается,
потому что оказывалось, что строка там просто A
минус B периодично и далее по Евклиду, да, вот.
Ну вот, и, ну, там, то есть ценой некоторых усилий
оказалось, что действительно тут вот, то есть можно и
уточнить, что, скажем, если AB взаимно просты, то
единичку вычесть можно, а двойку уже нельзя.
Вот.
Нам это все еще не нужно.
Да, то есть на самом деле, да, то есть в принципе
в оригинальной статье теорема формулируется без нодом,
только там с упоминанием, что с нодом можно, но,
но вот, но на самом деле там, там для, там конкретных
сейчас целей нам на самом деле вот A плюс B вот так
достаточно.
Вот.
Ну, мало ли.
Ну, мало ли.
Тут, осторожно, где-нибудь рядом сидит какой-нибудь
там условный Александр Бабин, который в этом месте
начинает придумывать задачу, где A плюс B минус 1 будет
критично.
Так что осторожно.
Вот.
Так вот, значит, что, значит, что у нас тут рассуждение
говорит?
Так, значит, у нас строка P1 периодично и P2 периодично.
Длина этой строки заведомо больше, чем P1 плюс P2.
Следовательно, строка нод P1, P2 периодично.
Вот.
Но есть одна маленькая проблема.
Строка нод, так как P1 меньше, чем P2, то получается, что
этот нод является делителем P2 и не совпадает с P2.
А что это значит?
Это означает, что у нас тут имеет место вот этот вот
нодик.
Вот этот вот нод P1, P2.
Вот.
И это означает, что мы строку P2, вот эту длины P2 вполне
себе можем распилить.
Вот, собственно, просто взять и распилить.
На самом деле на кусочки вот такой длины.
И из этого будет следовать, что строка P2 не басовая.
Потому что P2 делится на нод P1, P2.
Это не будет работать, если P2 меньше P1?
Нет, это не будет.
Если P2 меньше P1, тогда мы не сможем заявить, что
нод P1, P2 заведомо меньше, чем P2.
А этим мы сейчас жестко воспользовались.
Мы еще воспользовались в том месте, когда мы сказали,
что P1 меньше либо равно, чем P2.
Потом мы прибавили слева P1 и P2.
Нам нужно было, чтобы мы P2 прибавили больше, чем P1.
Ну да.
Да, да, да.
То есть еще мы как бы хотели...
Еще нам нужно было LEMO периодично использовать.
Поэтому мы должны были сказать, что 2P2 больше, чем P2
плюс P1.
Да.
Другой вопрос, что на самом деле...
Да, мы знаем, что P2 больше, чем K-1P.
Но почему-то, честно говоря, я не очень понимаю, почему
K-1, а не K.
Ну-ка давайте вместе с вами подумаем, почему.
А как мы в доказательстве использовали то, что у нас P1
это префикс P1?
Ну, что это именно префиксный период, мы не использовали
особо никак.
То есть мы использовали, что это, так сказать, период.
То есть в доказательстве мы это использовали таким
образом, что пусть P2 меньше либо равно, чем K-1P.
В префиксный период мы использовали, когда говорили,
что можно записать P1 в K раз.
А, ну в этом смысле да.
То есть существует вот префикс K раз.
Ведь вот это не равен, когда тут меньше либо равно
обнаружилось, что тут K-1.
Что K-1 покрывает вот эти вот 2P2, и тогда оказывается,
что это строка периодичная.
Это тоже понятно.
Если бы у нас было не K-1, а K, то мы бы не смогли
еще раз приписать справа P1, потому что оно перестало быть периодом.
Нет, почему?
Пусть P2 меньше либо равно, чем KP1.
Тогда...
Если бы было припишем справа еще 1P1.
Нет.
И еще 1P2.
Нет, зачем?
Рассмотрим строку длины...
P2 плюс P1.
А, вот и да.
А, мы ж не всю строку длины 2P2 рассматриваем, да.
Мы еще чуть-чуть.
А, да, точнее, да, картинка, да.
Картинка неправильная, да, как всегда.
Вот.
Ах, вот в чем дело.
Тут я вот...
Тут-то я думаю, что-то не то.
Почему тут не выжили максимум?
Потому что да.
Потому что, да, будьте внимательны.
То есть, на самом деле, если у нас тут есть 2P2, то вон то
неравенство гарантирует только...
То, как бы, если P2 меньше либо равно K-1P, оно нам гарантирует
следующее.
Оно нам гарантирует там хлоп, хлоп и хлоп.
В общем-то, не более того.
То есть, 4 вполне может сюда не пойти.
Типа, в первой части я не понял, почему что-то так.
Проблема была в том, что 3 копии P1, они покрывают
только одну копию P2, а не две, как мы нарисовали
на картинке перед этим.
Ну да.
То есть, тогда говорить, что все вот это P2 периодичное,
P1 периодичное, мы не можем.
Ну да.
А, ну мы просто можем строку уменьшить, там все равно
это оценка...
Ну да.
Нет, там просто идея в том, что мы можем заявить,
что надо взять строку P2 плюс вот тут P1, и тогда она
тоже будет и P1 периодичное, и P2 периодичное.
Вот.
Да.
И дальше доказать то же самое.
Нет, нет, не будет P1, нам еще один блок надо взять.
А вот он.
Ну да, его надо взять.
Да, но даже не его взять, а на самом деле вот скорее
вот этот вот блок надо взять.
Вот.
Ну ладно.
Да.
Да.
Ну там начинутся детали, что этот четвертый блок
мог выйти за пределы P2, там вот это все, бла-бла-бла.
Но я не мог, все-таки из-за оценки.
Да.
Но это не суть.
То есть суть остается в том, что вот этот весь блок,
он P1 периодичен, с другой стороны, он P2 периодичен, как
префикс чего-то P2 периодичного.
Вот.
И его длина на этот раз P2 плюс P1.
Так что лемма сработала.
Да.
Все, разобрались.
Да, тут все-таки K-1, а не K.
Да.
Так.
Ну вот, отлично.
Немножко...
То есть доказательство у нас другое.
Нет, доказательство то же самое, только с уточнением.
Скажем так, доказательство такое, рассмотрим префикс
строки S длины P2 плюс P1.
Утверждение.
Он покрывается и четырьмя копиями P1, и двумя копиями
P2.
Следовательно, он P2 периодичен, и P1 периодичен.
Ну а дальше схема та же, опять же.
П2 периодичен, P1 меньше, чем P2.
Поэтому, значит, как бы это P2 распиливается на ГЦД,
значит, P2 небазовая.
До свидания.
Говорим омэ.
Вот.
Так что вот такое вот утверждение.
Вот немножко...
То есть немножко воспомнили логику, в которой мы жили
в прошлый раз.
Какая сейчас такая сейчас небазовая?
P2 получается.
Ну потому что если как бы это вот строка P2 плюс P1,
она ГЦД от P1-P2 периодично, и это ГЦД меньше, то это
ГЦД меньше, чем P2, это означает, что P2 можно разбить
на строчки длины ГЦД, они одинаковые.
Вот.
Так что вот, соответственно, разомнулись.
А теперь нас приветствует Лемма 3 с очень пафосным,
с очень пафосной формулировкой.
Вот.
Так.
Значит, смотрите.
Лемма 3.
Это будет прям пафос.
Ну не то чтобы пафос-пафос, конечно, но...
Внимание.
Значит, пусть у нас, соответственно, W это базовая строка.
То есть не префиксный период, а просто базовая строка.
Вот пусть она вот такая.
Да-да!
Существует разбиение...
Значит, существует разбиение W, равное W1, W2.
Такое, что для любого W штрих, то есть для любой строки W штрих
оказывается, что...
Внимание.
Сейчас вот будет эпично.
W2, W в степени k-1, W штрих не имеет префиксного периода
Меньшего длины W.
Вот такая, вот такая заява.
Так, ну что?
Как это можно переформулировать?
То есть идея такая же.
Если бы взяли строку длины W в степени k, то у нее был бы
префиксный период W, и больше бы у нее префиксных периодов
очевидно не было бы.
Правда?
Это вообще то же самое, что и циклический сдвиг.
Ну да.
Но тут такой оригинальный циклический сдвиг, обратите внимание.
То есть берем вроде циклический сдвиг на W1, но вот это вот
последнее W1 отпиливаем, а вместо него припиливаем
что угодно.
Нет, тут и прикол, тут W.
В смысле?
Так.
Нет, ну у первой-то да.
В смысле, если там есть какой-то период.
Так.
Нет, ну во-первых, там уже не период, а префиксный
период, напоминаю, да?
То есть префиксный период – это когда есть префикс
в виде четырехкопий.
Причем префикс базовый.
Ну нам, в общем-то, не принципиально.
Ну давайте так.
Начнем с того, что нам фактически, когда нам есть формулиру,
надо доказать, что нет префиксного периода меньше
W, надо по сути доказать, что как бы нету префикса
с четырьмя одинаковыми копиями, у которой длины меньше W.
Базовость этого префикса проверять даже не надо.
Потому что, как бы, то есть условно, если вы найдете
четыре копии и каждая копия меньше W, то и префиксный
период там еще меньше длины вы точно найдете, правда?
А раз возле префиксного периода только не уменьшается
того, что мы в конце дописываем какую-то, минимальная длина?
А, минимальная, да.
Как она может уменьшиться?
Ну не совсем так.
Если префиксный период уже был, какой-то минимальный
префиксный период уже был, то оттого…
А ну вот да, да.
Минимальный только уменьшится.
Нет, почему минимально увеличивается?
Если у какой-то строке был минимальный префиксный период какой-то, то от того, что вы к этой строке приписали какую-то буковку,
там, кажется, минимальный префиксный период не поменялся от слова «никак».
Нет, он мог перестать им быть.
Почему?
Нет, а нет, не мог.
Не, не мог.
Короче, я не понимаю, зачем вы в формулировке в f3, почему в Японии нельзя зажигнуть и говорить, что v2 v степени k-1 не имеет префиксных периодов.
Ну, на самом деле, как бы я не сказал, не я, а авторы, как хер надо, как-то авторы сказали бы доказывать, тут сейчас мы по такой схеме работаем, потому что, ну вот, но тут как бы фишка могла быть такая, могло быть, на самом деле, w штрих, как бы все равно усиление, потому что да, мы можем, то есть да, конечно, эта лемма требует доказательства того, что вот эта штука не имеет префиксного периода меньше w, но в ее случае, заметьте, это эквивалент,
эквивалент на тому, что эта штука вообще префиксного периода не имеет, вот, но тогда может так случиться, что мы припишем правильные символы и префиксный период, и префиксный период таки появится, и может оказаться даже меньше, чем w, потому что мало ли там, может w2, это там еще какая-нибудь достаточно маленькая строчка, вот, вот.
У нас мы берем, разбиваем строку, берем суффикс, потом дописываем саму строку х-1 раз, потом дописываем что угодно, и говорим, что не имеет префиксного периода длины меньше w, так?
Ну да.
Они нельзя просто на shift какой-нибудь.
Чего?
Нельзя просто на shift какой-нибудь отступить и сказать, что w2 это просто от шифта до конца.
Ну на какой shift? Я бы еще, ну начнем с того, что у w нет шифта.
От последнего символа w.
Чего?
Ну ладно.
Ладно, ну давайте так смотреть.
Ну действительно, давайте начнем с того, что, давайте сразу убедимся, что w' действительно нам погоды не делает.
Почему?
Потому что начнем с того, что, как вы уже заметили, вот этот вот префикс, он w периодичен, правда?
Ну нет.
Она не близает к его 14.
Нет, это говорит о том, что w не является префиксным периодом этой строки, безусловно.
Но w периодично эта строка является.
Так, давайте еще раз вспоминаем, что строка называется w периодичная, если у нее любые два символа, на их стороне w совпадают.
Делиться на w длина строки для этого не обязано.
Вот.
Нет, ну заметим, что по большому счету тут написано w2, w1, w2, w1, w2, w1, w2.
Вот.
Эта строка w периодична, и ее длина больше либо равна, чем 2w, кстати.
Ну k, хотя, ну k4 у нас мы зафиксировали.
Вот.
Поэтому тут 2w тут как-нибудь найдутся.
А что это означает?
Что если у этой строки, вот просто хотя бы у этой строки, да и у этой тоже, есть префиксный период длины меньше, чем w,
то вот этот вот утверждение нам неожиданно заявляет, что тогда этот префиксный период, он вообще, он там меньше, чем w делить на k-1.
Так, значит, давайте, то же самое, но я сейчас запишу, давайте.
А почему w базовая по условию?
W.
Нет, стоп.
Она, можно, базовость не w, а w2, w1.
Но, ладно, как говорится, утверждение, которое можно доказать, остается как упражнение.
Докажите, что циклический сбег базовой строки является базовой строкой.
Это, в плане, похоже на правду, но, скажем так, это нужно сказать.
Хорошо, да.
Хорошо.
Ну, как сказать, к сожалению, да.
К сожалению, у нас на лекциях пистеха нет возможности иногда проговаривать все 2w равно 4, к сожалению.
Ну, в плане, это важно, то есть, если это не понимать, то...
Ну, да, ну, просто видимо.
Ну, мы этим явно пользуем.
Нет, понятно, да, мы, конечно, этим пользуемся, но, к сожалению, тут есть трейдов между вот проговаривать все, что может быть непонятно,
и как бы подразумевать сурок.
Нужно не доказывать какие-то понятные акценты, а отговаривать, что они существуют.
Нет, это тоже часть трейдов, да.
Просто что-то, что-то возможное, да.
Ладно.
Хорошо.
Да, ну, во-первых, да, как бы, да, у базовой, да, если w базовая строка, то циклический сбег тоже, очевидно, базовый.
Значит, утверждение такое.
Значит, d2 wc1.
И это в нашем случае равно w2 w1 w2 w1 w2 w1 w2.
Это что такое? w периодичная строка, течная строка длины больше либо равно 2 модуль w,
причем w2 w1 базовая.
Там как бы остро, потому что я не уверен, что в статье или проговаривает, что циклический сбег базовой строки базовой.
Кстати, на всякий случай предупреждаю.
Вот.
Так.
Итак, w0.
Ну вот тогда.
Ну вот, в принципе, это нам говорит следующее.
Тогда, по утверждению, если у, значит, w2 w1 степени k-1 w' есть префиксный период.
Длины меньше, там p какой-нибудь один, длины меньше w, но то p1 меньше, чем модуль w, даже делить на k-1.
Просто вот, просто по утверждению.
Можете сказать, ради этого мы такое утверждение переписывали.
Что это значит?
Вот.
Ну в принципе, тогда я утверждаю, что если такой префиксный период есть, то он на самом деле прекрасно вписывается вот в эту строчку.
Ну потому что тогда вот просто вот из этого следует на самом деле, что kp1 это меньше, чем модуль w, значит, на k делить на k-1.
Что заведомо меньше, чем модуль w на, ну в нашем случае на k-1 хотя бы.
Ну чтобы вот в первые три копии описывались.
Вот.
Хотя на самом деле двойки уже хватает.
Да.
Вот.
То есть из этого это в принципе следует.
Ну то есть к чему это все?
То есть вывод из этого очень простой.
На самом деле нам абсолютно все равно какую w' ставить.
То есть мы можем подставить абсолютно любую конкретную w' и доказать, что префиксного периода нет, и тем самым мы докажем это для абсолютно любой строки.
Нет, мы еще круче w' будет равно w в степени бесконечность.
Ну суть в общем та же.
Вот.
Но надо для красоты.
То есть как мы поняли, что достаточно доказать то для одной конкретной w' вот исходя из вот этих вот.
Соображений.
Нет стоп.
А.
Стоп.
То есть.
А мы в эту сторону делаем.
А в какую?
Не понял.
То есть короче утверждение значит мы берем w' конкретную.
Да.
Доказываем, что у нее нет префиксного периода.
А отсюда от аисфакта выше следует, что чтобы мы не дописывали все равно не будет.
Да.
Потому что.
Ну да.
Потому что если он есть у кого-то, то он есть у всех.
Следовательно, если он есть у кого-то, значит он есть у всех.
Значит и наоборот.
Если его нет у кого-то, значит его нет ни у кого.
Вот.
Ну дайте себе переформулировки, конечно.
Как это закон Ломаносова.
Если где-то что-то накусит, то где-то что-то выкусит.
По уровню.
П меньше w может три модуля w.
Ну сам модуль w чего?
Сейчас общее умение.
Не, ну потому что k равно 4.
Ну вот тогда мы же отзываем под w вот эту строку w2 wk-1.
Нет, тут w в степени k-1.
Мне подается.
Само все w это вообще w1 w2, напоминаю.
Да, я помню.
пеника минус 1. Сама все w, это вообще w1, w2, напоминаю.
Да, я помню. Почему мы получили, что если есть период, то
он меньше, чем w1, w2? Ну, по утверждению.
Потому что мы заметили, что у нашей вот этой вот строки,
вон той, в качестве мы ее сделали, есть
базовый префикс длины модуль w.
А, единственное условие? Вот. Причем,
говорим, ричарь него больше, чем леброго, чем 2, но тоже налицо.
Ну вот, тогда, если есть префиксный период,
еще и p1, то тогда, верно, вот это неравенство.
Ну, если хорошо он меньше. Вот. То есть мы тупо воспользовались утверждением.
Да, такая вот веселая логика.
Так.
Сейчас о чем будет противоречить то, что
период маленький длины?
Что? То есть мы сказали сейчас, что если есть период,
тогда у него будет длина лучше, чем w1
на k-1. Ну да. И что
из этого следует? Ну, пока еще ничего.
Ну вот, ну сейчас мы, а конкретно сейчас это сказали, что
просто тогда окажется, что 4 копии
этого периода, они просто уложатся вот в эту строчку.
Да, и тогда не важен w'.
И тогда нам неожиданно окажется, что давайте допишем абсолютно
любое w', и, знаете, будет радость.
Вот. В результате мы говорим, что w', объявляем
просто w в степени бесконечности.
Ну, то есть строчка у нас теперь имеет вид w1,
то есть там 2w2, w1w2, w1w2, w1w2, w1w2, w1w2, w1w2, w1w2, w1w2.
Ой, доска кончилась. Не, вот.
Соответственно, вот.
И значит сейчас мы у этого вот будем искать
период, точнее попробуем доказать, что он равен w ничему кроме. Ну w-то очевидно, префиксный
период есть, видно, да? Вот, значит, как же мы это будем делать? Значит, идея тут такая,
значит, будем отпиливать, да, ой, слушайте, давайте, на этот раз я, пожалуй, лучше тут подпишу,
потому что, да, значит, смотрите, будем отпиливать, да ладно, прям как будто нет,
отпиливаем детей, это мы в кучах баловались год назад, там как бы без отпиливания и ликвидации,
там детей со всеми потомками как-то, как-то, ну да, ну да, где мы тут, ну вот, значит, смотрите,
то есть вот опять же мы сейчас будем искать отпиливать z, и вот такой вот,
ну то есть будем такие отпиливать z, что z в степени k, префикс вот нашей строки.
Так, как нам это-то обозвать? Ну давайте s обозвем. Вот.
То есть будем говорить так, то есть условно говоря while у s, ну и что? Пока у нее есть префикс,
значит z, такой z в степени k, точнее такой, что модуль z меньше, чем w, что мы будем делать,
отпилить от s минимальное такое z. То есть вот такая вот интересность.
Вот будем отпиливать. Ну короче говоря, вот этот пихонизм пополнять, читай вот эти две строчки,
какие 2s? z, это буква z, так давайте не путать, это буква z, вот это вот двоечка, разница должна
быть очевидна. Нет, z, вот видите, тут провальчика, тут выпуклость, тут в пуклость, вот тут выпуклость.
Видите, да? Остро выпирающая z. И это тоже. Обычно в лестнице у z пишут помечку. О господи,
как все хорошо, пожалуйста. Кошмар. Ну что, помогло? И так, ну давайте посмотрим. Да-да-да,
семерка еще, точнее союз семерки и альфы, да-да-да. Да-да-да-да. Так, ладно, значит смотрите.
Да господи. Значит смотрите. И так мы отпиливаем z. Отпиливаем, отпиливаем, ну вот. Так, ну что
можно прийти отпиливающиеся z сказать? Вот, ну во-первых, можно заявить следующее. Я утверждаю,
что отпиливающиеся z по длине увеличиваются. Не уменьшаются. Почему? Ну просто потому, что если
мы сейчас отпилили какой-то z, вот тут было 4 z, вот, а потом после того, как мы отпилили 4 z,
оказывается выяснилось, что мы смогли отпилить какую-то z поменьше, то тогда утверждается,
что эту же длину, правда ее циклический сдвиг, могли отпилить спокойно и раньше. Ну давайте
вот. Ну давайте посмотрим. Допустим у вас тут было вот 4 копии z, поэтому вы этот z отпилили,
да. Допустим выяснилось, что на следующем шаге, оказывается, можно отпилить поменьше. Там как-то
вот, там какой-нибудь z штрих поменьше можно отпилить. Но тогда смотрите. Тогда я утверждаю,
что вот эта вот строка длины, которая вот 2 z, она на самом деле не только z периодично,
но и z штрих периодично. Логично. Вот. Ну или, по крайней мере, да. Или если этот z штрих поменьше,
там надо вот чуть-чуть поянуть. Если он очень маленький. Да, ну просто, смотрите, да. Ну просто,
ну вот. Ну если совсем маленький, то сразу, то сразу проблем. То есть понятно, что 4 копии сюда
не влезают, потому что если бы они сюда влезали, они бы влезали и сюда. И тогда возникает вопрос
о дот. Ну хотя нет, но в общем-то без разницы. Смотрите, вот у нас жили, были 4 z штриха,
да. Вот здесь. Тогда возникает вопрос. Тогда вот эти 4 z штриха. Ну вот. Ну так. То есть у нас есть
два варианта. Либо z штрих умножить на k меньше равно, чем z умножить на k-1. Ну да. И тогда просто,
да. То есть если они вот в эти три копии. Да, могли и раньше, да. Ну да. Но тогда у нас эти три вот
этот строка из трех z, она z периодично и z штрих периодично. Следовательно, у них есть еще
меньше период. То есть z c dash, да. И тогда, в принципе, нот. Ну противоречие там в том,
что уж тогда 4 копии этого меньшего периода там в 2 z точно влезут. Да, наоборот, он делитель z.
То есть мы сейчас доказываем вот это утверждение, что. Вот да, что длины, то есть отпиливающие z не
убывают по длине. Еще раз. Как мы доказываем? Ну, говорим так. Предположим, что мы отпилили z,
а потом на следующем шаге выяснилось, что можем отпилить z штрих поменьше. Тогда у нас два варианта.
То есть у нас тут было 4 копии z. Одну мы отпилили, да. Заметим, что если у нас 4 копии z штрих попадают
в 3 копии z, то тогда они попадали вот в эти 3 копии z, потому что это одно и то же. И тогда выскакал вопрос,
а почему мы тогда z штрих не отпилили? Мы же на каждом шаге отпиливаем поменьше. Вот. Ну хорошо,
говорим мы. Предположим, что 4 копии z штрих вот сюда не влезло. Ну тогда что это означает? Тогда
это означает, что вот эти вот 3 копии z, они дают не только z периодичную строку, но и z штрих
периодичную строку. Но тогда у них есть период gcd от z и z штрих. Но этот gcd, он как бы делитель z,
причем собственный делитель z. То есть получается хотя бы две копии этого gcd здесь уже есть. Но
тогда вот уже в двух z есть хотя бы 4 копии z. То есть получается, что тоже оказывается было,
что отпилить и раньше. Вот вывод. То есть если отпиливаем по минимуму, то у нас будет все вот
так отпиливаться. Вот. Ну а теперь замечаем следующее. Заменяем. Ну вот. Ну в принципе,
тогда смотрите. Тогда у нас два варианта. Либо рано или поздно очередной z станет длиной модуль v,
и тогда обратите внимание, это ровно это означает, что мы победили. Вот. Нет. Это означает,
смотрите, что это означает. Это у нас где-то у нас закончился процесс file. Он там у нас закончился
где-то. Но с другой стороны заметим, что где бы он не заканчивался, у нас все равно остается какой-то
суффикс. Какой-то суффикс строки исходной w, который приписали w бесконечное число раз, правда?
То есть какой-то вот суффикс, там так сказать w4 какой-нибудь, в котором писали w w w w. И выяснилось,
что у этой строки нету префекса длины меньше, чем w. Такое, что тут хотя бы 4 копии его есть.
Нет, ну цикли и нот. То есть ну в принципе тогда, но тогда я утверждаю, что тогда просто надо
сказать, что w равно, там теперь w3 w, но w4 и в общем-то нот и его нот и его нот и в общем-то победа.
Вот. Чего? Вот, да, ну это если он, то есть мы просто начинаем, то есть как мы начали с w w w и в общем
вот так вот делаем, да. А почему нот? А почему он когда-нибудь остановился? Ну потому что мы
отпиливаем только строки длины меньше, чем w. Это раз. А во-вторых, заметим, что почему он может не
остановиться тогда. Это означает, что он дошел до нашел какую-то длину и начал эту длину отпиливать
бесконечное число раз. Но если у нас есть бесконечная строка и от нее бесконечно отпиливается какой-то
период, я не знаю, q, допустим, да, ну как это, он взял букву от балды, то тогда мы отсюда вынуждены
сделать вывод, что это бесконечная строка q периодично, правда? Ну, кстати, да, потому что если q меньше,
чем w, то вся эта строка w периодично и q периодично, значит она gcd от q и w периодично, этот gcd опять
меньше, чем w. Длина бесконечной строки, доказывали. Длина бесконечной строки больше, чем q плюс w.
Нет, ну я не знаю, тут как бы видимо вопрос, как ты себе воображаешь периодичную строку и доказать
это. Потому что я как-то воображаю, что при достаточно большой строке, если есть период a и период b, значит скакнем
на b, вернемся на a, получим b минус a, дальше и в клип. Поэтому если есть бесконечная строка, то мы как бы
вообще свободны. Тогда получается, что на одной и той же длины, не, мы бесконечно висеть не можем.
Да, совершенно верно, именно так. То есть таким образом вот и получается, что вроде как
вот. То есть более того, мы еще и предъявили такой алгоритм, относительный, конечно, алгоритм,
но относительно по сложности, потому что в принципе, конечно, за квадраты от единицы дополнительной
памяти, ну или там, ладно, за куб какой-нибудь в принципе, его забабахать можно. Мы сказали изначально,
что вот, допустим, существует w1, w2, а потом мы производили какие-то операции, сказали, что на самом деле w2 это будет w4.
Но не совсем так. На самом деле мы сказали, что нам по барабану какое w' на самом деле приписывать.
То есть на самом деле у нас была идея такая. У нас была строка w, w, w, приписываем w' и говорим,
что существует, то есть утверждается, что у этой строки существует, то есть мы можем отпилить меньше,
там строй, там, отпилить меньше, чем модуль w символов слева, так что оставшиеся строки не будет
префиксного периода меньше w. То есть по сути, лемма 3 утверждала ровно это. Понятно, да? Но мы тут
проговорили, что на самом деле в этой лемме абсолютно всё равно, какое w3 приписывать, потому что если этот
префиксный период существует, то он на самом деле в эти 4 w уместится, и даже в эти 3 w плюс этот хвостик уменьшится по-любому.
Поэтому мы сказали, что давайте доказывать эту теорему для вот такой строки. И дальше мы доказываем так.
Берем эту строку и начинаем от нее вот это всё отпиливать. То есть на самом деле тут можно было не от w2 отпиливать,
которое мы не знаем, а просто то есть идея, что давайте вот возьмем такую строку s и будем от нее отпиливать,
отпиливать, отпиливать, отпиливать и до тех пор, пока процесс вот не сойдет. То есть в какой-то момент
найдется ситуация, когда у вас не найдется там префикса с четырьмя копиями, длина которого меньше,
чем w. Сказали мы, и тогда утверждается, что строка будет у вас в виде какой-то w4 на суффикс, и тогда утверждается
значит w3, w4 и с кома я. Вот собственно и всё. Да, была, но вот сейчас я вот аккуратнее переформулировал,
и мы избавились от этой проблемы. Аюшки.
А проблем в том, что q меньше w, это значит, что этот gcd от q и w меньше, чем w. Следовательно w можно
распилить на одинаковые кусочки длины gcd от q и w. А w базовая. Вот мы неожиданно вспомнили о том,
что она базовая. Ну я бы сказал, ну да. А так вопрос был ровно по этой части,
в опросы был. А нет, ну мы второй раз пользовались, когда уже доказали, что нет двух периодов бесконечности.
А да, ну тоже. Так вот. Так что вот такая вот радость. Вот, но с другой стороны, теперь у нас есть
ещё. Что нам теперь предлагается? Теперь нам предлагается, ну вот предлагается тут неожиданно
ещё кое-что. То есть интересная прям интрига. Важное это замечание или нет, раз я его написал,
наверное важное. Теперь нам вот возникает вопрос, а сколько мы реально символом здесь
отпилим? Вот в этом мистическом процессе. Вот, например, можем ли мы отпилить в этом процессе,
ну скажем, вот целую копию строки w. Ну за один шаг очевидно не можем, а за два, за три, за 57.
Ну почти. Ну глобально говоря так же. Во-первых, мы отпиливаем z только в порядке неубывания,
то есть они не убывают, но гарантируем, что одна конкретная длина бесконечности
отпиливаться не может. И там уже проблемы с периодичностями. Нет, w мы не можем отпилить,
потому что мы не отпиливаем строки длины w. Нет, потому что если бы у нас просто отпиливали,
то в какой-то момент мы пришли к тому, что мы отпилили, дошли бы до того, что у нас есть
период w или её какой-то циклический сдвиг и тогда бы её до бесконечности отпиливали. Такое бы было,
но просто фишка в том, что как бы алгоритм за конечное число шагов до этого дойдёт.
Вот. Так вот, значит теперь вот мистическое замечание заключается в том, что оказывается
действительно мы не сильно много отпилим. То есть внезапно у нас есть мистическое утверждение о том,
что оказывается мы больше, чем модуль w не отпилим. Внезапно, да? Даже я бы сказал,
то есть тут замечание такое, то есть этот вот процесс отпилит строго меньше, чем модуль w символов.
Ну, то есть это у нас так даст нам, может быть, какой-то приблизит нас к мечте,
что это не просто абстрактный процесс для математики, но и нормальный процесс для
программирования, за адекватную симпатику. Ну вот, правда, возникает действительно вопрос.
Действительно, почему такое действительно может произойти?
Вот давайте думать.
Почему?
Так, ну действительно, да. Ну понятно, да. Вот начнём с того, что пусть мы тут отпиливали,
отпиливали. То есть сначала вот это отпилили, потом там допустим отпилили чуть побольше.
А потом-то вот шли-шли-шли, а потом в какой-то момент, бах-бах-бах,
ну вот есть там еще отпиливали- föлили, а потом неожиданно, пили, оп-оп,
но, точно и так. Да, потом в какой-то момент пошел заход сюда, мы это тоже отпилили.
А потом неожиданно взяли и начали, вот тут. Пошли по беспределу.
делу опять же в терминах этих зеток у нас получится что у нас для одной строк типа
z1, z2 и т.д. и zk, вот гцд 2 и zj будет
а не важно но утверждение такое
я ну хожу я сейчас попытаюсь попробую догадать лему попроще что предположим что у какого-то
суффикса да вы нот то есть нет хотя
собственно неважно
нет да там да ну ладно хорошо да булинат но давайте на ты хорошо да то есть как как минимум
можно пытаться заметить что если вы в какой-то момент стали отпиливать строки длины w делить
на три или больше но при этом меньше чем w то тогда строка w у нас оказывалась не базовой
да да то как минимум то строка w не базовая ну например ну можно слемой можно просто сказать
что рассмотрим эти рассмотрим эти четыре копии эти четыре копии включают себя там то есть на
самом деле покрывают хотя бы там одну копию да то есть даже три вот эти копии покрывает хотя
об одну копию w и получится что это строка там w периодично и автоматизано то есть
w периодично и вот это вот периодично значит там еще и гцд периодично значит ну просто ну просто
ну можно и так но я не знаю в таких вещах я не знаю не общут легче легче вспомнить почему они
они вспомнить что у нас есть какой-то черный ящик который мы пользуемся вот ну тут ну в
общем тут на вкус и цвет да можно отослаться но хорошо ладно ну ну я утверждаю что во-первых то
есть заметил что вот эти z пока не достигли w они все будут длины меньше чем w делить на три
ну ну как короче вряд ли можно отослаться там предыдует тогда будет потому что если тут мы
захотим отпилить что-то меньше w но больше либо равно чем w телит на три то там будет
противоречие с предыдущим утверждением там с предыдущими утверждениями вот ну хорошо
но дабл и 3 но не то чтобы нам это сильно по нот то есть не то чтобы нам пока это сильно
поможет но допустим но вот но тут нам говорится следующее то есть хочется рассмотреть примерно
такое значит да давайте вот так вот так вот да тут мы тут шли шли шли там как-то отпиливали
и тут вот с этого момента но с этого но с этого рановато наверное да раз два три четыре какую-нибудь
мы тут решили вот это отпилить и здесь неожиданно оказалось что раз два три четыре и мы решили
отпилить вот это то есть предположим что у нас произошел перехлёст да заметим во первых что
перехлёст произошел строго то есть не могло быть так чтобы отпилили ровно w символов
а мы пока не проверяли я этого не утверждаю боже упаси пока нет пока ничего подобного нет
вот пока мы как оно просто еще следуем то есть заметим да что вот на самом деле вот
эта вот штука тут действительно имел место какой-то не тревелит там перехлез положительной длины x
да но и да отпилили на больше то есть не могло быть так в какой-то момент что мы отпилили ровно
чем дабы ровно w да если мы в какой-то момент выяснил что пилили ровно w значит мы зацепились
логично да вот так теперь ну вот ну значит давайте теперь смотреть то есть мы тут неожиданно решили
отпилить вот этот иксик да вот так ну теперь вот предлагаю значит давайте по нот то есть давайте
посмотрим что же этот иксик нам даст значит смотрите значит этот вот иксик мы тут решили
в какой-то момент его попилить да но пусть мы значит да в этот момент от пили то есть
отпилина оказалось w плюс x но смотрите тогда заметим что этот икс был где-то здесь
давайте вот тут синеньким кинем нарисую вот тогда он у нас был вот здесь то есть вот тут тоже вот
вот он икс вот этот же самый да вот тут икс и тут икс вот но вот и собственно этот префикс
каким-то образом отпиливался правда было дело и более того была ситуация когда мы-то мы этот
икс впервые отпилили правда ну не цельным да во первых заметим что не могло быть так что мы
этот икс отпилили свое время прям целиком вот именно ровно икс отпилили потому что тогда опять
зацикл видно да вот тогда чему это нас приводит то есть приводит к тому что тут был какой-то
z штрих там какой-то может быть вот такой но я не знаю там какой вот то есть этот штрих который
мы тут в этом месте но значит который мы вот на очередном шаге отпилили и после этого отпиленных
у нас было строго меньше икс астрала строго больше в принципе да кстати приятная идея о том
что что вот эти вот позиции сколько у нас отпилина они как бы по модулю там по модулю w никогда
не повторяется потому что если повторяется то будет зацикл ну тут нет тут к сожалению надо
включиться и предположить что они записываются на камеру потому что как бы тут тут как бы тут как
бы занятие такое что мы тут все вместе мыслями такое что я вам записываю твердя я говорю там
говорю заклинания вы их записываете потом выучивайте нет вы все-таки сейчас что вы говорите
много утверждений какие-то используете какие-то не используйте ну куда но это нормальный процесс
мышления да да ну в смысле вы так рассказываете как будто вы сами придумываете и это тоже ну конечно
это тоже конечно более того если вы еще придумаете быстрее меня еще круче будет конечно
да нет это из другого да вот да а что другого икса не до этого и саму по-любому дошли да это
мы знаем вот да а вот нет вот через этот икс мы должны были точно точно перескочить
чего а и не факт нет это я просто так нарисовал видимо для удобства так-то так-то в общем-то
необязательно вот я даже больше скажу скорее всего но вот то есть скорее всего он и не
дошел потому что тогда но вот ну хотя нет там скорее всего и не дошел он должен быть сильно
нет мы говорили следующее мы бы предполагали что мы в какой-то момент первые в жизни покрыли
больше чем w да мы сказали что пусть это w плюс x тогда вот рассмотрим тогда заметим что мы в
какой-то момент в первые покрыли первые икс символов нет смысле
не обязательно
если оно так всех пугает то конечно давайте нет мы применяем вот этот механизм
то есть мы применяем механизм и отпиливаем сколько-то символов то есть отпилили сначала
была пилена символов потом сколько-то пилена потом еще побольше побольше побольше нет но так
ладно если с самого начала говорить туда мы в какой предположили что после очередного шага
мы там исчезли первые w символов и возможно еще сколько я сказал да точно сколько там мы
убили что ровно w исчезнуть не могло поэтому сказали что их w плюс x теперь нас жутко интересен
тот момент времени когда у нас исчезло не менее чем икс символов вот но вот вот это но теперь
заметим следующее ровно икс символов исчезнуть не могло вот а потому что если у нас какой-то
момент и то что тогда получится так у нас исчезло ровно икс символов а потом исчезло w плюс x и
ровно w плюс x символов следовательно дальше у нас исчезнет w плюс 2 икс 2 w плюс x 3 w плюс
x и так далее то есть будет за цикл просто сприт просто на этот раз сприт периодом
а это тоже невозможно потому что мы знаем что процесс остановится вот то есть принципе это
означает что у нас есть вот такой z-штрих в результате отпиливания которого у нас исчезло
строго больше чем x символов а вот теперь давайте внимательно посмотрим и подумаем и что
да как это говорит а у меня в бумажке записано не так или например либо z-штрих меньше чем икс
так вот теперь есть но у меня тут записано еще так так что из этого что из этого z-штрих
но значит тут тут неожиданно пополнился стоп нет а тут еще про значит смотрите потому что тут
мы отпиливать лет штрих а тут где-то отпиливали z вот которые побольше да нет прийти если мы
отпиливали за 4 за 4 за 4 прям отпиливали отпиливали и допилили прям до сюда то тогда у нас получается
что но тогда мы вынуждены будем заключить что там просто вся строка вся строка длины
z-штрих периодично и там начнутся проблемы начнутся проблемы с базовостью поэтому
когда мы здесь отпиливали мы здесь отпиливали z который заведомо больше чем z-штрих вот
вот то есть смотрите как она но да так что получается так то есть более того а ну тем
более что это да но то есть даже и без этого это не так то есть потому что смотрите ну да то есть
z-штрих то по-любому больше x правда ну вот значит что тут тогда что-то тогда можно заявить так
потому что да то есть у меня тут в каком-то виде записано что z-штрих это едва ли не префикс z
на самом деле вы внезапно не делит нет хотя не ну как взять ну давайте так и чего потому что
но потому что предположим что мы в какой-то момент выкинули ровно x а в следующий момент
выкинули ровно w плюс x вот да так но теперь давайте смотреть значит еще раз почему не могло
быть так что мы в какой-то момент отпилили ровно x а потом в следующий момент в какой-то из
следующих моментов отпилили ровно w плюс x почему такого быть не могло в этом вопрос
нет ровно w плюс x мы в какой-то момент отпилили бы это знаем уже давно
суммарно конечно имеется в виду они ну вот эти даблы плюс x то могло быть но тогда при этом не
могло быть что мы в какой-то момент вот отпилили за несколько шагов ровно и а потому что а тогда
смотрите тогда хорошо допустим мы отпилили x потом по применяли процесс отпилили w плюс x
но тогда я утверждаю что мы продолжая применять этот процесс мы отпилим 2 w плюс x чтобы вот отсюда
еще w тем же метод вот эти же даблы там надпилим ну да вот это да будет вот дальше можно тоже
сказать вот это w и вот дальше w то есть как бы вот это потому что до строка w периодично вот это
бесконечное напоминаю ну да вот это 2 w плюс x вот там будет 3 w плюс x и так далее то есть просто
я утверждаю что после того как мы отпилили вот это и вот это дальше мы просто отпилим вот это
за несколько за те же шаги что и здесь но просто потому что вот это вот строка и вот это вот строка
это одно и то же в смысле наверное по построению драсти мы как-то бесконечную строку строили-то
вообще мы брали исходную строку w и просто писали бесконечное число копий
ну вот поэтому получается не могло быть так,
что мы как бы если мы тут w плюс x отпилили то мы здесь ровно x отпилить не могли вот так так ну что
теперь значит тут у нас значит был отпил тут ну заметим теперь следующее что вот на этот
штрих но этот x можно теперь распилить то есть этот штрих можно распилить принципе ну давайте
вот может быть введем обозначение может потом на x и x видно да вот да можно вот тут попробовать
то есть более того мы то есть мы знаем что тут какая-то строчка x тут тоже есть ну не то чтобы
это нам там прям сильно поможет соответственно но тем не менее ну вот значит что теперь хочется заявить
вот ты что нота что нам теперь хочется вот ну во первых
что какой седьмой бы где седьмой бы карта всеми зачем чтобы картинка запуталась нет ну то просто
значит утвердили нот ну утверждение на самом деле такое теперь это возникает такое мистическое
утверждение зад штрих префикс зад осталось только выяснить как правильно определить зад штрих
ну вот видимо неправильно а правильно видимо сказать так надо сказать два штриха и сказать
что за два штриха это вот этот вот циклический сдвиг зад штриха можем такое сказать
вот вот здесь вот это вот то есть вот если вот пусть этот зад два штриха это соответственно
циклический сдвиг зад штриха вот на эту вот отметку вот тогда заметим что такой зад два
штриха заведомо является префиксом зета почему ну потому что тут у нас четыре копии зета да вот
а здесь у нас как бы но а здесь у нас как бы хотя бы три копии этого зад два штриха найдутся видно да
но потому что здесь три копии зад два штриха найдутся значит они здесь найдутся потому что
здесь и здесь это одно и то же так но вот вот то есть вот такая но то то есть вот такую вот
штуку мы видим то есть при этом но вот значит но вот что можно еще добавить такое причем значит
значит утверждается что этот то есть но вот утверждается что за два штриха в степени почему-то
к-2 вкладывается догадываетесь куда что уже угадали куда да в зет степени к-1
можно будет на экзамене такой же блокнотик взять нет чего-то какой блокнотик господи есть
оригинальная статья в которой не нормально английский принципе ну и потом этот блокнотик
вот мне тут так написано видимо когда я это писал когда-то вот пару лет назад видимо да
это все было очевидно сейчас уже нет но если бы я подготовился к тому что прям это наизусть
рассказывать то я бы это рассказал что но нет зубрит на самом деле нет ну по большому счету
надо на самом деле запомнить просто все ключевые моменты там остальное выводит
но честно честно скажу я зубы я прям вот запоминаем ключевых моментов не занимался
возможно я да возможно немножко зря да но где-то слуга как всегда где-то случайно
ну зачем это ну скажем так что-то это звать какой ответ вы хотите услышать что это можно
ко всему курсу применить зачем вообще мы все это делаем зачем мы с одного до памяти
меж писали понять понятно потому что там была куча идей которые мы потом дальнейшим
ну и что да другой вопрос зачем в тех местах где мы их использовали зачем мы это делали
почему там не важно тут важно трассе приехали завод единицы до памяти да нет такого нет
так понятно ладно так ну ладно давайте так так погодите давайте все-таки к этому
делу попробуем вернуться все-таки давайте так ладно значит за 23 1 2 3 значит пусть у нас за
два штриха значит к-2 вот утверждается что почему-то вот две копии этого за два штриха
заведомо вкладываются вот в эти 3 копии точно почему это очевидно потому что у нас 3 копии
за два штриха вкладывается в 3 копии так значит 2 может быть 3 забыли по статье нет потому что
но можно так сказать а потому что но потому что да можно сказать так вот но да но в таком
виде странное да хорошо да но тут действительно вот если внимательно рассмотреть хорошо значит
ладно у нас тогда игрок штрих за штрих значит к-2 а вот рассмотрим вот такую строчку можем такую
рассмотреть вот игрок штрих так за 4 у нас и к штрих игрок штрих это видимо вторая часть
да да нет вот у нас есть за 4 да и он вот этой вот границы языка распилился на x 3 и на
игрок штрих знаете вот это сдвинутые школьники когда геометрию решают но очень любят маленький
чертежи вот тоже там что-то x 3 сейчас и решить это начало z 2 так игрок штрих нет это не но
это дай га штрих это начало за два штриха но здесь я пишу z штрих 1 я понимаю что z 2 штриха
равняется игрок штрих видимо видимо что-то еще что-то из штрих и зет штрих это x 3 плюс
игрок штрих z 2 штриха равно игрок штрих плюс их штрих вот так вот так так что но вот то здесь вот
то здесь допустим заявка заявка вот такая вот то есть даже вот эта штука на самом деле прекрасно
вкладывается то есть утверждается что даже она уже вкладывается в z
вот так вот ну вот то есть куда-то там вкладывается ну здесь совсем очевидно да в
z в степени k-1 уж точно так но вот такая но то вот это просто хорошо что да что я
но то но что в принципе это значит что-то нет но просто нет вот
но нет просто то есть как бы сразу скажем то есть там противоречие хочется вывести
с тем что вот когда мы тут делали вот этот шаг на z штрих то мы на самом деле тут могли
бы отпилить и поменьше вот почему два нету мы докажем то как бы мы докажем что у нас не
могло произойти так что у нас тут произошел перескок через границу w но как сказать да как
бы при беда ну как сказать парда да то есть надо все надо всегда действительно попытаться цели да
осталось только выяснить действительно так ну что ж
не на отл не боже упаси не вот нет когда я это начали как я хочу без всякой подготовки
действительно там это там рассказать там рассказывать максимум за час действительно
это тогда может я задумываюсь над тем что это был не отл пока пока естественно
пока естественно без вариантов то есть это да вот вот вот сюда но там а там но
а кстати там его но в прошлом году так и было там было два билета собственно вот это теорема и
билет собственно как с помощью этой теоремы победить вот там собственно но правда это вода
то есть это как бы да ладно так ладно давайте ладно давайте как пожалуй оптимизируем процесс
пожалуй лучше оптимальнее будет мне действительно признать что так этому занятию подготовился не
очень вот после сделаем мы тогда по-другому значит тогда в следующий раз значит мы тогда
к этому вот к этому вернемся ладно давайте перейдем к чему-нибудь попроще и так суффикс на
автомат да но я думаю один но скажем так вы про он почему попроще потому что мы здесь будем
пользоваться объектом с которым вы уже активно работаете может быть даже домашние задания по
нему же делали делали ну вот не делали ну да да да ладно так вот значит зачем нам потребовался
неожиданно автомат ну потому что какая у нас цель да потому что напоминаю глобальная задача
которую мы решаем в теме лёх интерпретация в поиск подстрок в строке вот то есть мы уже решали
ее там в простом виде то есть дана одна подстрока 1 строка найдите за линию это там префикс функция
z функция или вот прости господи вот это гадость если уж хочется еще и по памяти ужаться вот можно
но вот если у вас несколько подстрочек и один текст то нас начинает выручать алгоритм аха карасик
вот который мы тоже в прошлый раз с вами обсудили или не в прошлый прошлый не важно вот но на самом
деле есть более крутая цель хочется взять текст обработать как-то его там построить по нему
какую-то структуру данных и с ее помощью искать в нем под строки за отом в онлайне в чем за
от длин этих подстрок в идеале но давайте подумать вот допустим действительно дана строка с я хочу
в этой строке с искать под строки ну чтоб типа дана строка п я хочу за от п понять является ли
строка п под строкой строки с да или нет но возникает естественный вопрос да возникает вопрос что это
может быть вообще за структура данных в которой эту под строку п можно найти ну вот допустим мы
не ставим себе цели там сделать эту предотвратку за прям какое-то быстрое время да то есть
предположим что у нас там текст можем обрабатывать бесконечно долго потому что
там это война и мир она уже 200 лет существует там ладно не 200 там 150 там сколько она там
существует там 130 там 140 вот поэтому мы ее можем там беска там сколько сколько угодно обрабатывать
но зато как обработаем так все будем искать за мгновенно что мы тогда можем делать да но
самое тупое конечно можно сделать это построить суффиксный бор вот то есть и попа ну допустим
ну получится ну в принципе да но тут по-разному можно делать потому что да ну давайте так вот как
первая идея то есть первая идея можно тупо взять все суффиксы и добавить в бор тем самым обратите
внимание мы добавим все под строки в бор вот получится вот что подобного рода са б а вот это
то что я построил называется суффиксный бор вот ну в принципе он строится за квадрат жрет квадрат
памяти и позволяет вам все под строки искать за отп а если еще на этом боре еще какой-нибудь
дфс забабахать то в принципе можно решать там всякие веселые задачи в духе там найдите первое
вхождение п там последнее вхождение п сколько там этих вхождений и так далее и тому подобное или
там при правильных динамиках вообще найдите катая вхождение строки п но в общем развлечений много но
конечно следующая уже идея возникает что квадрат это не та симптомика которая нас сильно радует
то есть хочется как-то хранить эту штуку побыстрее но на самом деле тут есть две идеи как этот бор
ужать вот мы сегодня будем изучать вторую значит вторая идея заключается в том что на самом деле
вот из этой вот картинки даже если тут помечу терминальные вершины там условно да вот давайте
так вот так все пометил ну да раз два три четыре пять шесть семь да всем ну можно пустую пометить
но не важно вот что ну допустим я просто в конце всех суффиксов поста ча почему ца а потому что я
с ума сошел да вот да совершенно верно вот вот и получается примерно следующий жили были
семь штучек и получилось радость но вот ну то есть вот но а ну можно ну когда как там на самом
деле можно помечать можно не помечать не сильно принципиально вот но тут возникает такая идея что
в принципе на самом деле то есть попами по количеству состояний в этом боре можно поэкономить
ну в каком плане экономить да ну а первых да заметим что да мало кто знает но бор
это такой детерминированный конечный автомат да даже не то чтобы вот вот то есть в общем-то не
то чтобы шокирующая новость вот но есть у нас возникает автомат то наверное хочется его
минимизировать а тут как-то уже по картинке явно видно что его есть куда минимизировать
потому что как минимум все вот эти конечные терминальные вершины можно торжественно
схлопнуть в одну то есть можно взять то есть как мы схлопываем вершины очень просто мы берем
тряпочку и и стираем лишние ребра и вершины вот а соответственно и стрелочки по букве а
мы просто отправляем в одну вот таким вот нехитрым образом мы это делаем
почему выигрыши есть мы у нас на три состояния меньше вот более того заметим
что я в принципе вот эти вот четыре состояния из которых торчит только по одной стрелочке в
одной тоже состояние тоже в принципе могу и схлопнуть вот то есть это в общем-то тоже то есть
эти вот состояние тоже на самом деле не сильно интересны потому что на самом деле все вот эти
строчки с б можно там отправить куда-нибудь вот сюда вот сюда бэшка бэшка бэшка бэшка
но и так далее ну я в принципе можно этот автомат конечно минимизировать до бесконечности но
таким образом его но таким образом на самом деле это не самый оптимальный способ на самом деле мы
это сделаем немножко по-другому чего ну и респонента не обязательно минимизировать
этот автомат можно и за полномерное время в принципе нет он чтобы сделать не что сделать
подека надо завести эффективное не терминальное состояние в который перегонять все переходы
которых нет нет погодите погодите погодите нет погодите нет погодите вы точно не путаете
с детерминизацией какого-то автомата вот детерминизация данного экспонента а если нет если он если он
детерминировано там за какой-то полином потому что там все было там где типа там что-то делаем
ну что-то мы там делаем едва ли там какие-то классы эквивалентности по-моему делаем локда
ладно но там да продвинутый какой-то алгоритм есть то есть там что тупой какой-то алгоритм был
проще что на каждый но вообще да нет мы сейчас да да нет мы обсуждаем мы по идее обсуждали
за сколько времени можно терминировать автомат вот если не терминировать а наоборот
а минимизировать уже детерминированный конечно автомат да да вот ну да есть то есть да но там
нет там в принципе у вас курсе должен быть алгоритм как минимизировать автомат за что-то
типа квадрата по моему но потому что там было такое что на каждом шаге у вас должны там состояние
должны делиться пом что-то типа на классы эквивалентности по принципу что что-то что типа что типа языки там
что-то типа что по строкам длины не более чем к вы попадете там в одни и те же состояния что-то
такое ну вот и там выяснялось что если строки если два состояния эквиваленты по строкам длины
меньше либо равно n то они эквиваленты в принципе там помкать ну какая такая идея сейчас я тут
детали не помню но вот но суть была такая вот но на самом деле да вот то есть но нам хочется
минимизировать этот автомат и в общем-то кстати действительно можно сказать определение то есть
можно даже просто вот написать это про видеопределение то есть пусть с произвольная строка
абсолютно произвольная вот тогда значит суффиксный автомат
автомат который мы будем обозначать как долг а тес
ну да директа и циклик ворт граф по мистической причине в оригинальной статье он так называется
вот долг долг нет есть док а есть док есть долг долг это разная вещь да нет там там другой
док нет вот и так значит так вот суффиксный автомат это минимальный вот что для нас важно
будет минимальный дк а языком которого давайте употребим такое такой термин является множество
суффиксов строки с вот ну пожалуй включая пустой то есть корону вот то есть нам интересно то есть
нам интересно построить чтобы он принимал суффиксы и только их вот вот и нам теперь вот
жутко интересно то есть можно ли это построить а самое главное сколько памяти будет жрать
конечно ну в принципе минимальный вот а что бывает другие определения минимальности
ну скажем так утверждение такое на самом деле фишка на самом деле такая что такое минимальный
автомат это автомат такой что ни у какой то есть это такой автомат что ни у каких двух вершин
нет одинаковых языков вот ну давайте вот немножко разомнемся давайте я сейчас давайте сейчас мы
построим суффикс на автомат строки аббатсаба смотрите каким-то читерским образом мы это сделаем
да то есть то что я сейчас скажу это конечно а симптатика лада будет полиномиальная но там
какой-то там степень будет там дай бог четвертая вот просто идея такая как построить суффикс на
автомат строки аббатсаба значит делаем это так смотрите значит смотрите внимательно значит
понятно что у нас будет стартовое состояние что такое стартовое состояние стартовое состояние
это состояние язык которого равен вот аббатсаба бацаба там от саба саба аба ба а и эпсила логично
да вот я буду на каждом станке его язык что такое язык состояние это множество строчек по
которым из этого состояния можно прийти в терминальные вершины понятно да вот язык это
вот состояние стартовая да и оно раз в нем эпсилон то автоматически оно терминальное так
ну теперь давайте думать какие переходы должны быть я утверждаю что у этого из этого состояния
должно быть ровно три перехода по букве а по букве б по букве ц видно да вот значит как мы
это будем делать вот но давайте сделаем переход по букве а по букве а мы должны
перейти в какое-то состояние у которого языком является множество строчек бацаба значит саба
ба и опять эпсилон ну значит опять это состояние терминальное так ну давайте бфс так бфс вот
значит б тут у нас получается язык от саба и что-то еще а вот нет эпсилона здесь нет на
этот раз обратите внимание потому что вот видите то есть как бы если у меня тут строчки начинают
с б то как бы дальше там еще что-то есть поэтому коэпсилон здесь нет поэтому это состояние
терминальное и возникает еще один язык ц то есть ц тут получается тут единственная строчка аба
это не терминал так то есть заметим что состояние с этими языками в этом автомате быть обязаны
обратить внимание вот видите да то есть принципе пока мы делаем достаточно вынужденные вещи и
более того объединить эти состояния никак не можем что у всех этих четырех состояний разные
языки видно да значит что же будет дальше так тут была оба цаба так вот здесь у нас
переходы получается по букве б по букве с делаем переход по букве б и оно нас должно вести в
состояние с языком от саба и а и вот тут мы делаем мы замечаем что вот эти вот два то есть
вот эти два состояния имеют абсолютно одинаковый язык а это автоматически означает что в общем-то
на самом деле стрелочку по букве б мы могли можем перернать просто прямо вот сюда вот далее так
но к этому состоянию перейдем из него есть только переход очевидно по букве а и мы попадаем в
состояние саба так но здесь давайте сразу себе сократим немножко работу потому что здесь мы
есть только переход по букве ц и оно ведет вот состояние с языком а видно да то есть но остается
здесь только оба ну что это означает это значит тут надо просто честно написать а б и а и здесь
поставить терминал и сказать что на этом все поздравляю мы построили суфи на автомат для строки
оба саба а мы там забыли а я я да но правда там да вот так что видим тут в общем-то
нет а да так что еще забыли а потому что тут эпсел он конечно так да да да да так но как видите
не сильно сложно получилось ну в принципе ну да то есть закроем четвертую степень наверное
как-то упихать можно там а с каким-то хэш мапами может даже и закуп вот ну есть понятно если
естественно мы его так строить не будем вот но первое конечно нас интересует но то есть хорошо
здесь там фантастически повезло потому что на самом деле мы здесь можем заметить что что у
него состоянии что на самом деле что какой-то автомат если правильно его нарисовать то можно
заметить что это просто такая строчка оба саба вот обратите внимание к которой мы прорисовали
еще несколько символов то есть еще несколько вот переходов и несколько эпселов то есть
но в принципе очевидно что тут у нас то есть очевидно что тут количество состояний линия просто
но на самом деле это не всегда так но по камере какие-то радушные надежды дает а может быть
всегда а может быть всегда оказываться больше количество состояний в суффиксном автомате не
сильно большое то есть будет такая мечта может мы его будем строить долго но зато когда построим
у нас будет там какая-нибудь очень маленькая структура вот но для того чтобы построить придется
по заниматься каким-то это то есть попозаниматься еще какой-то наукой а именно значит ну во-первых
давайте придется ввести еще какой-то пару понятий смотрите вот на самом деле у каждого
состояния есть вот этот вот язык но теперь но вот но что это за язык это говорит так что
предположим что мы в это состояние по какому-то слову пришли да то есть мы там пришли допустим
по какому-нибудь красивому красненькому слову x тогда что это за множество слов это означает
что какие слова можно приписать к иксу чтобы получился суффикс строки с правда и вот поэтому
можно в принципе аналогичное понятие ввести напрямую чисто чисто но чисто на языке строчек то
есть пусть допустим скажем x под строка s тогда говорим правым контекстом обычно это почему-то
правым контекстом называется том там обычно это пишут с индекс мс от икс но так еще часто пишет
красивая сейчас не хочу рисовать красивые буквы вот называется множество таких строчек игр что
икс игр суффикс с суффикс да суффикс с скажем так ну как что полезно будет сформулировать и так
и так так это чисто в терминах строки а так чисто да то есть в автомате это фактически будет до языка
автомата и ну сразу возникает идея да да во первых еще определение конечно что ну я так не буду совсем
мы будем говорить так что x1 эквивалент на x2 по s если правый контекст x1 равен правовому контексту x2
вот ну в принципе то есть с точки зрения автомата это означает что x1 x2 должны
приходить в одно состояние автомата потому что терминальный не терминальный другой вопрос
вот так но первое утверждение значит пусть значит x1 эквивалент на x2 и модуль x1
ну допустим больше чем x модуль x2 тогда вот здесь там полезно это будет смотреть именно с точки
зрения строчки потому что тогда я утверждаю что x2 это суффикс x1 это будет только первое утверждение
x2 x суть к сексаде
вот почему это так вот ну да из автомата это кошмар быть не очевидно а вот из строчки
прям совсем хорошо смотрите так давайте вот черный уберем потому что черный черный не работает
вот а синий почему-то работает вот значит что идея такая потому что что так что означает вот
что такое этот правый контекст ну можно сказать еще и по-другому то есть можно но что такое правый
контекст это набор таких суффиксов строки вот x1 так что эти вхождения продолжаются до суффикса то
есть выглядит это так что вот этот вот как бы и x1 то есть мы знаем где вхождение x1 строке s
заканчивается вот множество позиций где не заканчивается логично да вот а теперь
предположим что выяснилось что x2 заканчиваются ровно в тержи позициях вот прям совсем тержи
тогда кажется утверждение становится очевидным правда
вот вот
то есть более того на самом деле отсюда же можно вывести сразу еще одно утверждение что мало того
что есть два суффиксы x1 и мы будем говорить так что пусть x это суффикс значит x1 такой что
модуль x1 больше модуль x а модуль x больше чем модуль x2 тогда утверждаю я что правый контекст
этого икса естественно такой же как у x1 и x2
ну хорошо ну можно это и добавить
ну понятно что заметим что вот эти игроки они конечно являются суффиксами строки с да
ну очевидно что если x и x суффиксы 100 игрок тоже суффиксы да да ну просто потому что выяснять
что они заканчиваются в одних и тех же позициях строки с но потому что вот давайте вот мы на
вот пусть вот эти суффиксы это правые контексты строки x1 вот эти вот красенькие
это игроки ну да то есть мы рисуем все игроки и вы очевидно x и x да и каждому игроку соответствует
но более того на самом деле можно заметить следующее что рассмотрим строку x1 у которого есть вот такой
правый контекст а давайте от x1 отпиливать по символу слева заметим что вот эти элементы
из правого контекста никуда не денутся но в какой-то момент то есть но когда-то
наступит ситуация когда помимо этих товарищей в правом контексте наступит кто-то еще но когда
этот кто-то еще наступит то есть вот эти строчки начнется там найдется еще четвертое вхождение
какое-то да то там то тогда оно уже останется навсегда но отсюда в общем-то и следует то есть
в принципе вот то есть но на самом деле да то есть формально то есть мы это выразили формально
вот в этом виде но можно было бы и посильнее можно просто было бы показать что если у вас из x2
суффикс x1 то правый контекст x1 вкладывается в правый контекст x2 вот по большому счету в общем-то
из этого понятного утверждения вот эти вот товарищи автоматически то есть это вот это
второе автоматически выводится ну по большому счету потому что если тут вот вложение будет то
есть тут x1 вкладывается в x и x складывается x2 если при этом выяснилось что x1 равно x2 то
соответственно x там тоже туда же вот так что такое утверждение вот мы немного поняли то есть
что из этого следует что если мы ну то есть что такое состояние то есть каждому состоянию в
будущем автомате соответствует класс эквивалентности под строк строки s правда и
теперь мы с вами кое-что поняли то есть этим классом эквивалентности является то есть как
выглядит этот класс эквивалентности класс эквивалентности выглядит так есть какая-то
самая длинная строка и несколько вот какая-то нот и несколько под строчек которые получают
из нее удалением одного символа двух символов трех вот несколько идущих подряд вот сколько-то
является а потом но с какого-то момента обнаруживается что вот следующее уже не в том состоянии все значит
на этом класс эквивалентности заканчивается понятно да значит вот этот значит смотрите мы
даже введем определение то есть даже обозначение обозначение будет звучать так смотрите
дальше смотрите то есть пусть у нас и значит пусть значит тоже может определение точнее
введение обозначений как она как показывает практика да в статьях обычно если вы пишете
определение на самом деле будет обозначение то это не поприветствует то есть пусть x под строка s
тогда значит смотрите значит на первых скажем что вот это вот x вот в таких квадратных скобочек
с индексом s это класс эквивалентности вот значит то есть мы будем говорить что у x и
такой класс эквивалентности будем еще говорить что в этом классе эквивалентности есть лонгест
вот мы его так будем писать пусть лонгест это как вы уже догадываетесь самая длинная строка
и еще вы введем можно ввести понятие лен этого класса эквивалентности которая будет равна
просто длины этого лонгеста значит сразу предупреждаю на будущее естественно ни в
каком состоянии ну фактически заметим что вот этот класс эквивалентности на самом деле будет
у нас соответствует состояние но самое важное на их внимание то есть конечно же сам класс
эквивалентности лонгест его мы хранить не будем потому что лонгест это строка а вот лен его в
состоянии мы хранить будем вот лен мы хранить будем и он нам будет очень очень сильно помогать
так вот теперь пришло время подумать вот о чем смотрите что такое заметим что состояние
однозначно задается своим лонгестом правда еще нет нет лен это длина лонгеста знаешь
лонгест знаешь его лен даже нет но утверждение такое если пусть у вас есть строка s то есть
это как бы не то чтобы прям важное утверждение вот для понимания пусть у вас есть строка s и вы
знаете все там кто не является лонгестом а кто нет тогда я утверждаю что по этой информации вы
можете полностью восстановить состояние то есть все классы эквалентности почему
ну по большому счету да то есть тут идея такая то есть может что берем лонгест отпиливать
по одному символу до тех пор пока не наткнемся на лонгест вот мы говорим мы пытаемся утверждать
что если мы знаем все лонгесты то мы можем и классы описать да естественно мы говорим о
подстроках да даже не вершим просто мы просто знаем какие под строки являются лонгестами
какие не являются можно перебрать все у которых правый конец до конца строки
нет ну просто нет если мы вот знаем но я говорю так что состояние казалось бы
до что кирится так вот вот пусть лонгест есть да вот мы знаем что строка лонгест да давайте
сгенерим ее классы эквалентности как мы сделаем будем отпиливать от нее по одному символу до тех
пор пока не наткнемся на другой лонгест вот я почему-то утверждаю что это будет класс
эквалентности по одному символу сначала мы же знаем что каждый класс эквалентности устроен так
есть самая длинная строка там и несколько вот строк образованных именно отпиливанием по одному
символу вот поэтому давайте так и делаем до тех пор пока нам не нужно будет остановиться
я утверждаю что остановиться будет нужно просто тогда когда у нас получится другой лонгест
разумеется поэтому казалось бы да то есть каждый лонгест определяет свой класс вот таким вот
образом другой вопрос правда у меня возникает такой давайте подумаем вот вопрос вам наподумать
а почему когда у нас класс эквалентности закончится вот как бы следующая отпиливаемая строка будет
действительно лонгестом своем классе эквалентности а не кем-то еще потому что может быть она лежит в другом
классе эквалентности но она в нем не лонгест нет ну мало вот смотрите то есть жил был вот
допустим я строка икс которая была лонгестом мы тут отпиливали отпиливали в какой-то момент
наткнулись на первую строку игрок которая не лежит в том же классе эквалентности что икс вот
она не эквалентно иксу тогда внимание вопрос является ли игрок лонгестом в своем классе эквалентности
так рассмотрим его совпадает правый контекст да значит этот правый контекст вложен правый
контекст того что вы что ловы контекста икса правый контекст икса вложен в правый контекст этого
лонгеста так и из этого должны быть какие-то так а какие мне кажется можно и по обратной
стороны рассмотреть и получить что не совпадает но как-то да как-то вот должно быть но не хватает
какой-то четкой идеи а идея такая потому что давайте вот сейчас рассмотрим потому что на
самом деле эта идея сейчас он будет просто ключевой а что означает вот давайте вырубим
что означает что какая-нибудь подстрара игрок не является лонгестом в своем классе
эквалентности так давайте это уберем я думаю это уже не надо нам вот что означает что игрок
не является лонгестом и не поменять при этом класс эквалентности да то есть давайте вот
да конечно с точки зрения строки да вот жил был с да выяснилось что жил был у нас игр
вот давайте да то есть тогда она не то есть я утверждаю да что на самом деле движается такое
что игрок не является клоу лонгестом тогда и только тогда когда во первых игрок то есть
совсем везде во всех вхождениях игрока слева от него находится одна и та же буква
ну так должно быть да потому что должна быть если игрок не логи значит должна быть строка на
один символ больше с тем же правым контекстом то есть вхождение который заканчивается в тех же
местах видно да но тогда получается но так как у нас эта буква однозначная для всех игроков
то тогда получается что вот здесь мы тогда от икса к ней к игроку тогда прийти не могли
потому что вот этот вот бы игрок он вот ровно здесь и находится вот поэтому да получается мало
того что по лонгестом можно восстановить строчку но на самом деле мы доказали практически сейчас
просто очень важное утверждение ну по большому счету да то есть я мог бы сформулировать по
понятии правый контекст в виде где заканчивается вхождение соответствующей подстроки
если все символы совпадают то она не имеет ну то есть более того я утверждаю следующее что
игрок не является лонгестом тогда и только тогда когда слева от всех ее вхождений в строку s
расположен один и тот же символ да конечно да ну вот то есть но на самом деле сейчас я
переформулирую то сейчас скажу утверждение который по сути является его переформулировкой но
будет выглядеть и как прорыв значит просто лемма так ну на теорема на утверждение она как-то
помощнее теорема тоже это поэтому назовем ее по старой памяти лемма 9 1 но если у меня была
презентация там была бы лемма 9 1 или лемма 9 2 я не помню и звучит это лемма так значит пусть
x значит под строка с тогда значит x является лонгестом в своем классе эквивалентности
тогда и только тогда когда что когда верна следующая совокупность там вот верно хотя бы
одно из двух утверждений первое утверждение существует в алфавите два различных символа
такие что ax и bx под строки s ну то есть вот типа ну казалось бы да что означает что тут эти все
символы не одинаковые не все символы одинаковые то есть нет с левой одинаковых символов это
означает просто что тут существует два различных символа хотя бы два может и три четыре но тогда
и вопрос к вам почему я тут написал совокупность и что еще я туда должен записать нет мне зачем
да то есть еще тут не все одинаковые символы могут быть потому что одно из вхождений может
оказаться префиксом поэтому пишем x префикс как то есть все префиксы автоматически лонгесты и
это в принципе означает то есть отсюда можно сделать вывод что уж меньше чем модуле с плюс
один состояние у нас в автомате не будет да просто и так было понятно потому что потому что эти
префиксы будут репрессор просто цепочку со самой строки с да так что вот такое вот не хитрое утверждение
вот вот так что такая нот то есть да то есть доказательства этого утверждения но по сути
это потому что я его могу переформулировать когда что сказать что и этом x не является лонгестом
тогда только тогда когда во-первых игрок не префикс а во-вторых слева но автор существует
только один символ такой что этот символ плюс игрок это строка и по сути да ну вот да вот то
есть да заметим да то есть обратите внимание что если у меня тут произошла вот давайте вот такую
ситуацию нарисую то есть допустим если игрок еще входит здесь да я вот я тут для красоты я тут
рисую так что у меня как будто вхождение игрок и не пересекаются но подчеркиваю я это рисую чисто
для красоты то есть на самом деле различное вхождение строки игрок строку s могут и пересекаться
никаких проблем вот так вот если одно из этих вхождений было префиксом то тогда и то тогда даже
если перед всеми остальными вхождениями стоит одна и та же буква то тогда мы просто замечаем что
то есть тогда мы замечаем что класс эквалентности у строки бы игрок будет все-таки другой потому
что вот вот этого суффикса у нее там там уже не будет вот понятно вот так что такая красота и
теперь возникает но вот то но действительно как лемма тем не менее выглядит достаточно
фундаментально а теперь вот возникает такой естественный вопрос так вот то есть более
того кстати как это не странно мы еще не начали строить автомат но мы сейчас введем суффиксную
ссылку просто ну давайте сразу ее введем значит определение то есть определение пусть значит x под
строка с тогда значит вот это суффиксная ссылка суф от ее клау вот этого классу сув он
будет конечно нет строки от класса эквалентности это будет клауна вот значит это будет такой класс
эквалентности такой строки игрок что ну такой что значит игрок суффикс значит суффикс x класс
эквалентности x не совпадает с классом эквалентности игрок а ну есть ну или что то же самое для нас как
вы понимаете просто да иксы как неквивалентно и конечно же из них мы выбираем игр максимальной
длины вот это я буду называть суффиксной ссылкой почему однозначно чего ну и фигурные скобки
ну потому что ну я так записал ну возможно это записываю может не совсем общепринято но почему
это однозначно почему это не множество один элемент потому что видите модуль игр кепшу
отправляется в максимум то есть я рассматриваю множество таких суффиксов икса у которых класс
эквалентности не тот же вот то есть да обратите внимание кстати суффиксные ссылки абсолютно не
важно какого конкретно представителя в классе эквалентности возьму понятно да ну то есть по сути
витя то что это за суффиксная ссылка то есть это означает что ты сидя то есть получается если
мы вот какого-то икиса вот идем вот так ищем состояние то вот рано или поздно мы придем в
другое состояние мы можем тут продолжить это мероприятие и прийти в еще состояние и вот там
рано или поздно придем к пустоту тогда и если ему тут раз если им соответствуют какие-то
состояние, то вот суффиксная ссылка, то есть суффиксный
путь будет ровно вести вот таким вот образом.
Понятно, да?
Вот, то есть такая вот суффиксная ссылка, и это понятие нам
уже сейчас неожиданно поможет.
Каким образом?
А очень просто, потому что, да, ну...
Обратите внимание, пустая строка – это единственная
строка, у которой в правом контексте, размер правого
контекста – модуль s plus 1.
Ну, то есть у которой вхождение просто вот все как в самом
начале, так и в самом конце.
А, ну, можно сказать, что это единственная строка,
у которой в правом контексте лежит вся строка s.
Поэтому, да, есть такое простое утверждение.
А у кого еще строка s лежит в правом контексте?
Ну, почему у нас не может быть...
Ну, в плане, если сама вершина терминальна, и из нее переход
по символу тоже в терминаль.
И что?
Тогда у нас будет лежать вся строка s тоже.
Нет, при этом, чтобы строка s лежала в правом контексте,
у тебя должно быть так, что по этой строке s можно
куда-то дойти.
Ты можешь по строке s дойти куда-то из чего-то, кроме
стартовой вершины?
Сейчас, что?
Строка s лежит в правом контексте, значит, мы можем принять...
Значит, мы ее можем приписать к строке x и получить суффиг
строки s.
Ну вот, из этого следует.
Поэтому отсюда получается маленькое простое утверждение,
что класс эквалиберности Эпсилона равен множеству
состоящему из Эпсилона.
То есть не путать это не пустое множество, это множество
из пустого слова.
Значит, давайте скажем, что суффиксная ссылка от
этого Эпсилона не определена, но заметим, что для всех
остальных под строк, очевидно, суффиксная ссылка определена.
Потому что, как минимум, у любой не пустой строки
есть как минимум пустой суффикс.
Понятно, да?
Эпсилон такой, правый контекст от Эпсилона равен...
Чего он равен?
Ну просто s от i mod s-1 такой, что i равно 0.1s.
Да, у нас возникает подстрока от mod s до mod s-1, это типа
пустая строка.
А, да, как вы уже догадались, мы сейчас живем в ноль
андексации.
До этого нам это было не принципиально, но вообще
мы в ноль андексации живем.
Вот.
Так вот.
Так, господа.
Вот.
Ну а теперь...
Так, а теперь возникает вопрос.
Чего?
Какой вопрос?
Все?
Идем дальше.
Так вот.
Значит, дальше происходит следующая простая вещь.
Простая вещь звучит так.
Давайте подумаем.
Скажите, пожалуйста, вот дана, пусть у вас есть какой-нибудь
класс эквалентности, да?
Сколько у этого класса эквалентности детей?
Детей?
Сигнал.
Каких детей?
Каких детей?
Да.
Что такое дети?
Что такое дети вообще, да?
Вы имеете в виду?
Да.
А имею в виду я следующее.
Я имею в виду, что заметим, что суффиксные ссылки образуют
подвешенное дерево с коргем стартовой верши.
Согласны с таким утверждением, да?
Вот.
А теперь внимание вопрос.
Тогда в этом дереве, да, то есть у каждой вершины,
да, определен родитель.
А теперь у вас есть какая-то вопрос.
Как вы думаете, дана какая-нибудь подстрока х, которая является
еще и лонгестом, да?
Как вы думаете, сколько вершин, то есть сколько вершин
являются его детьми?
Вот если х это лонгест.
Детьми?
Детьми.
Вот не родителями, а детьми.
Вот пока я тут сотру еще пару определений.
Хотя нет, ну я вот это, ладно, утверждение я сотру,
а вот эти вот определения пусть пока живет.
Где?
Все.
Где?
Я не понимаю.
Это или?
Ну просто символ начала слова, это уже отдельный символ.
Можно сказать, столько, сколько различных символов
перед ним встречается.
Так ничего не такое, а ровно это и сказать, да.
Так вы спрашиваете про непоследствия на детей или про всех вообще детей?
Непоследствия.
Так.
А мы уже забыли, чем дети от потомков отличаются, да?
Да.
Какое безобразие.
То есть потомок это я и все потомки моих детей.
Потомки, понятно, что имеется в виду дети не все, да?
Обычно как бы да.
То есть дети это те, кто непосредственные дети.
Да.
Я не являюсь своим, то есть запомни, да, я своим ребенком не являюсь точно.
Вот.
И дедушкой моего ребенка тоже не являюсь.
Вот все тут важный простой принцип.
Я не являюсь своим ребенком и не являюсь дедушкой своего ребенка.
Все.
Вот.
Про дедушку уже непонятно.
Да?
Ничего себе.
Это факты.
Да.
Так.
Нет, это у нас тогда беда.
Этот семестер уже закончился.
Да?
Все?
С красно-черными деревьями.
Какие красно-черные деревья?
Нет, причем-то это уже да.
Нет, причем тут, погодите, у вас красно-черные деревья были
уже давно.
Не надо.
Тот движение, которое сказал Никита, оно понятно, потому
что на самом деле суффиксная ссылка, это значит мы от
самой длинной строки убираем последний символ.
Вот.
А сказал он следующее, что детей, если х это лонгез,
то класса эквалентности, то есть детей у класса эквалентности
х ровно столько, сколько символов можно приписать
слева к иксу так, чтобы строка осталась под строкой.
Ну, понятно.
Ну, потому что, да, по большому счету, да, вот обратите
внимание, как с игроком, да, то есть что означает,
что вот этот класс, суффиксная ссылка идет сюда, это значит,
что к игроку можно приписать символ b и получится вот
этот класс эквалентности.
Это означает символ начала файла.
Чего?
Да.
Ну, это, в смысле, имеется в виду пустой арене.
Нет, это...
Это тоже считается.
Нет, не считается.
Но в плане...
Нет, он не считается.
Ну и что, а какая разница?
Слева к игроку не считается.
Да, просто там никакой новой подстроки там не появляется,
да.
Но просто, да, то есть утверждение такое.
Если к...
П cartridge или этой...
Пусть у меня, допустим, игрок – это
логист.
Да, может, вполне.
То есть, может быть один ребенок, но это возможно
у игрока может быть единственное вхождение в s, вот это которое в префиксе. Тогда у него в принципе 0 детей.
Вот. Да, совершенно верно. Дерево с суффиксных ссылок. Но смотрите, это просто важный момент.
То есть действительно заметим, что детей у каждой вершины ровно столько, с какими способами можно
ее продолжить на один символ влево, так чтобы подстрока осталась под строкой. Но тогда что у
нас получается? Смотрите, у нас есть дерево из какого-то количества состояний. Ну, у нас
сколько-то лонгестов. Допустим, у нас лонгестов, там я не знаю, l пока. Пусть у нас l лонгестов. Или
какую-то еще другую букву взять. Ладно, пусть у нас l лонгестов. Они образуют дерево. Причем в этом
дереве существует не более чем модуль s плюс один листов. Точнее, ладно, не листов, а вершин с
не более чем одним ребенком. Внимание, вопрос. Нельзя ли как-то очень хорошо теперь оценить
количество вершин в таком дереве? Значит, у нас есть, то есть у нас есть дерево. В этом дереве есть
не более чем модуль s плюс один вершин, у которых там не более чем один ребенок. Потому что все
вершины, у которых не более чем один ребенок... Да, это префикс. Потому что у любого лонгеста не
префикса уж хотя бы два ребенка найдется, как мы выяснили. Нет, ну почему? Нет, ну не обязательно.
Но не совсем, но даже не количество листьев. Ну, допустим, давайте для простоты. Если бы нам было
известно, что дерево у каждой вершины либо хотя бы два ребенка, либо аналист, тогда бы мы... Ну вот,
и листов у нас, и допустим, у нас листов было бы, допустим, ровно q. Тогда мы бы точно знали,
что общее число вершин 2q... Ну ладно. Ладно, если у каждой вершины ровно два ребенка,
то было бы ровно 2q-1. Ну в данном случае... Давайте попроще пока. То есть да, я сейчас не записываю,
потому что это по идее должно быть утверждение из вашего дискрана на самом деле. Не было в таком
дискране разве? А, ну значит, видимо там считается, что такие вещи должны быть для вас очевидны.
Значит, смотрите. Хорошо. Ну давайте так, ладно, хорошо, разомнемся. Ладно. Упражнения,
которые могли быть у вас там в задавальнике по дискрану. В задавальнике по дискрану. Нет,
не путайте девильни и задавальника. Слушай, дебильник это то, чем вас закидывают на экзамене.
Задавальник это чем вас закидывают в семестре. У нас нет заданий вообще по АКТЧ. Чего? Да ладно,
нет. По дискрану должны быть домашние задания, потому что более того, я уже несколько лет назад видел,
они там выпустили даже целую книжку, из которой дают задания. У нас будет два задания,
из которых оценивается три лучших. Ничего себе. Четыре лучших. Четыре лучших, но почему два?
Ну я же как-то планировал, чтобы прошло полсеместра и не дали эту дону. Нет, он типа просто в начале
семестры не дает. Ага. Короче, нам обещали выкатить листочек с задачами для тех, кто хочет улучшиться
ценой в конце, но уже чуть-чуть из него дали сейчас, но в остальном ничего нет. Странно. А что у вас?
Нет, у нас дискран был в таком формате, нам там давали только на семинары, то есть были лекции
семинара на семинарах, но семинары по-разному. Кто-то семинары проводил в виде, давайте порешаем
такие вот задачи подобного рода. Там Дайняк проводил, просто он приходил и рассказывал еще
что-то веселенькое. Нет, причем иногда было действительно интересно на самом деле. Так,
господи, что ты там делаешь? Что ты делаешь? Да-да-да, и тыкает в него большим пальцем. Да-да-да. Ну,
знаешь, как-то да. Ну, да-да-да. То есть я не знаю, а то как-то ощущение, что если посмотрю с точки
зрения камеры, то может выяснить, что там еще какие-то объекты двигаются, и ты там их куда-то
там пытаешься поворачивать, там обконять кого-то, там вот это все. Ну вот, так вот. Ладно, вернемся
с ку. Значит, утверждение было такое, пусть у него есть подвешенное дерево, у которого у всех вершин
либо два ребенка, либо вершины лист. Тогда если у него листов ку, тогда всего вершин 2q-1. Ровно.
Ну, можно провести строгое доказательство по индукции. Нет, пока не надо. Пока просто о дереве
говорим. Просто простые сведения о дереве. Пусть у меня есть кулистов. Вот давайте, то есть я сейчас
покажу, как мне кажется это удобно мыслить. Вот пусть у меня есть кулистов и у всех остальных вершин
степень там детей два. Тогда у меня идея такая. Значит, у меня идея такая. У меня есть кулистов,
и я иду вверх. От кулистов у меня как бы идет вот эта вот ниточка к родителю. И вот я иду-иду-иду,
и вот опа! У меня неожиданно какая-то ниточка закончилась. Значит, я пришел в родителя. Но в
этом родителе у меня схлопнулись две ниточки. В этом месте две ниточки схлопнулись в одну. И
начиная с этого момента идет у меня теперь q-1 ниточка. Потом опа! Еще две ниточки схлопнулись.
Значит, теперь q-2 и так далее. И так мы дойдем до корня, когда у нас ниточка осталась типа 1.
Листами? В классе эквалентности, в которой не ведут других суффиксных ссылок. Или что-то
же самое. Получается, префиксы являются. И только они? Получается, да. В данном случае у нас
получается два модуля. В листе же может быть два префиксов? В листе? Нет. Префиксы бывают только в
соло. То есть только эти строки бывают? Нет, соло не обязательно. Листом только сольный префикс.
То есть лонгестом листа заведомо является префикс. Это да. Да. То есть могут быть кто-то еще вполне.
Почему бы нет? Тупой пример. АААХБББББ. Тогда у префикса АААХ на самом деле классы эквалентности ААХ, АХ и Х.
Вполне. То есть префикс не обязан быть единственной строкой в своем классе эквалентности. Но другой
вопрос, что конечно он будет единственным префиксом в своем классе эквалентности. Ну просто потому,
что там, допустим, если у тебя строка есть префикс длины 4, есть префикс длины 7. Они не могут быть
эквалентны друг другу. Почему? Потому что в правом контексте 4 есть более длинная строчка, чем все,
что может быть здесь. Вот. Поэтому отсюда можно вывести даже маленькую нотку. То есть да,
эквалентными они быть не могут. Но правда заметим, что листами они быть тоже не обязаны. То есть все
листы являются префиксами. Но не все префиксы обязаны быть листами. Потому что префикс в принципе
может входить в строчку и где-нибудь в другом месте. Правда? Ну, например, самое тупое,
потому что префикс из одной буквы. В редких случаях этот префикс входит в строчку только в одну. То
есть у него нет суффиксной ссылки. Это означает, что просто этот символ больше нигде не встречается.
Понятно, да? Вот. Но тем не менее мы можем теперь заявить, что количество листов... Смотрите как.
То есть у нас количество листов, то есть у нас в принципе даже количество вершин с не более чем
одним ребенком, не более чем с плюс один. Понимаете, да? Она взялась еще раз из того, что утверждение такое,
что если у лонгеста не более одного ребенка... Ну, значит, если какая-то строчка является лонгестом,
то мы знаем, что у него как бы у него либо двое детей, либо двое детей хотя бы, либо он префикс.
Все, вывод. Если не более чем один ребенок, значит это префикс. Вот. Значит, более того,
более того на самом деле... То есть более того на самом деле можно эту оценку даже уточнить.
Модуль s плюс один, можно сказать так. Можно даже написать, что это меньше либо равно s, если s не равно
а в степени n. Не равно, да? Не равно. Почему? Ну, потому что есть такой префикс, как пустой префикс,
правда? То есть соответствующий корню. А сколько у корней детей? Тоже давайте вопрос на понимание,
сколько у корней детей? Да, ровно столько же, сколько различных символов вообще в строке есть.
Почему?
Он никому больше не эквивалентен. Мы уже выясняли, что пустая строка не эквивалентна вообще никому.
А или в том плане, что пустая строка... Да, у него будут всегда дети. Вопрос сколько?
Ну, это не важно. Главное, что раз у него дети, он не лист.
Это не... Ну, как сказать? Наши интересуют утверждение не листов, а вершин с меньше либо равно, чем один ребенок.
Ну ладно. А вы хотите сейчас более сильную оценку доказать?
Ну, на самом деле, да. Нет, ну давайте так. Потому что про деревья и про один ребенок хочу сказать так.
Предположим, что у меня к... Ладно, п. Значит, п... Пусть у меня в дереве п листов и q вершин степени 1.
Тогда я утверждаю, что в дереве... Тогда я утверждаю, что из этого следует, что всего не более чем 2п-1q.
Степень 11 после сегодняего ребенка. Да.
Да, потому что из нее мы просто тупо сейчас сделаем вывод о линейности существенного автомата.
Мы уже получили оценку на 2п-1q. Да, но мы будем получать более точную оценку.
Нет, а что изменится от этой оценки?
Ну, на самом деле, я хочу доказать тебе рему о том, что состояние в автомате 2s-1.
Всегда? Нет, не всегда, а только в определенных случаях.
Очень легко доказать, что их 2s-1.
Нет, ну не совсем. Из вот этого на самом деле следует, что их 2s-1.
Да, но, еще раз, пустое слово никогда не лист. Значит, листов не больше чем 1.
Я вот для этого и формулирую.
Так, ну в плане... Ну, листов не больше чем s, потому что пустое слово никогда не лист, значит уже 2s-1.
Да. Ну, если мы хотим более точной... Нет, ну не совсем, там 2s скорее.
Нет, у нас не больше чем с листов, значит всего вершин 2s-1.
Нет.
Потому что, нет, нет, нет, там проблем пустую тоже надо учесть.
Ну, давайте эту форму аккуратненько скажем просто, что если у нас как бы...
То есть, на самом деле, смотрите, если у нас p листов и q вершин с одним ребенком,
то я утверждаю, что всего у нас вершин 2p-1, плюс q в точности.
Обязательные доказательства?
Вот столько будет, если у всех, если там детей ровно 2 всегда,
но и если не детей, если так, то меньше либо равно.
Обязательно уметь доказывать это утверждение, чтобы ответить на соответствующие вопросы?
Ну, для 2s-1? Ну, в принципе, необязательно.
То есть, мы сейчас боремся просто за какую-то...
Ну да. Ну, скажем так, если теорема докажите линейность, то, конечно, не обязательно.
Ну, на самом деле, то есть, мы 2s-1 получаем, если a p-1, то их просто...
Давайте вот думать. Сейчас давайте аккуратненько.
Вот, чтобы точную оценку, ну, все-таки неприлично быть, что там 2s-1 остальное имело.
Что-то все-таки неприлично, потому что все-таки грамотные люди все-таки 2s-1 знают.
То есть, давайте смотреть.
То есть, хорошо, ладно, в это утверждение мы поверили.
Ну, вы можете то же самое вообразить.
То есть, идем тем же самым сканлайном, но заметим, что схлопают.
То есть, так у нас линии сначала p, но там в какой-то момент вершины подменяются,
но когда появляется такая вершина, то количество линий не меняется.
Но когда появляется вершина степени 2 или более, то она схлопывает 2 или более ниточек в одну,
и таких новых вершин будет не более, чем p-1.
Причем более того, что важно понять.
Если все вершинки будут с двумя детьми, то схлопываться будет ровно p-1 раз.
А если найдется хотя бы вершина степени 3, то схлопнется 3 линии.
Так вот.
Значит, отсюда получается какой вывод?
На самом деле вывод получается такой, что если строка не равна...
Если в строке есть хотя бы a в степени n вершин...
Сколько вершин?
Если строка не равна a в степени n, то есть не состоит ни из одного символа,
то тогда получается, что у корня хотя бы два ребенка.
Следовательно, листов будет не более, чем модуль s.
А отсюда можно уже действительно сделать вывод, что количество вершин не более, чем 2s-1.
Нам еще важно, что...
Нет, это как раз и так было 10 больше, чем 1s.
А теперь еще важно, что этот корень не попал в вершину с 1.
Ну вот.
Давайте так.
Теперь я своролирую теорему.
Официальная формулировка звучит так.
Хотя что такое официальная?
Значит, она говорит, пусть модуль s больше либо равно...
Ну, допустим, два.
Тогда...
Тогда ее суффиксный автомат...
Содержит...
Не более, чем два модуль s-1 вершин.
Причем...
Причем, если...
Модуль s больше либо равно 3, то ровно...
Ровно 2s-1.
Тогда и только тогда, когда s равно...
Активный.
Активный.
Нет, а в степени как ас нет, потому что...
А в степени...
Ну, смотрите.
Давайте, почему я тут s больше либо равно 3 написал?
Потому что а в степени n содержит ровно n плюс 1 вершина.
Да?
Ну, кажется, что все разные.
Вот.
И тогда n-1 это меньше, чем 2n-1.
Тогда и только тогда, когда 2 меньше, чем n.
Вот.
Господи.
Нет, я тоже не подумал.
Вот.
Поэтому а в степени n нам уже не подходит.
То есть это на 2s-1...
А теперь давайте подумаем.
Какие условия должны выполниться, чтобы у вас было 2s-1?
Все остальные степени 2.
То есть...
Ну, во-первых, начнем с того, что...
Раз...
Что у корня должна быть степень ровно 2.
Правда?
Ну, у всех вершин должна быть степень 2.
У корня...
Ну, кроме листов.
У листа степень какая?
Тогда у корня степень получается...
То есть корень это не лист, значит...
У корня степень хотя бы 2, значит должно быть ровно 2.
Короче, нам не нужны вершины степени 1.
То есть...
Ну, не нужны, да.
Все.
А, не все.
И у всех по 2.
Вот.
И у всех по 2.
То есть нам нужна строчка из двух символов.
Ну, строчка из двух символов.
Нет, не в смысле, что она длины 2, а в смысле, что у нее
только 2 различных символов.
То есть она состоит условно из символов А и Б.
То есть первое интересное вопрос, в каком порядке эти
А и Б там расположены.
Но там возникает такое, как мы уже сказали, то есть
у нас должно быть ровно С листов, да.
То есть все префиксы должны быть листами.
То есть префикс, состоящий из первой буквы, должен
быть листом.
То есть получается, что эта первая буква не должна,
как мы уже убежали нигде встречаться.
То есть получается первая буква должна быть, а все
остальные должны быть, с ней не совпадать.
Так что вывод очень простой.
В степени N-1.
Все.
То есть внезапно только в этом случае у нас оказывается
в суффиксовом стомате ровно 2S-1.
Автомат выглядит экзотическим образом при этом.
То есть понятно A, B, B, B, B, вот.
И тут B, B, ну столько же B, ну и вот сюда.
Вот так выглядит автомат.
А какие следствия есть у второй части теории?
У какой?
Вот этой?
Ну более точная оценка на количество ребер, которые
мы сейчас перейдем.
Тут что-то нечисто.
Так.
А пока?
Все странно написали.
Так.
Дооборот, вынесу в сторону стрелочку.
В ту?
Не в ту.
Да в ту, в ту.
Чем мы просто можем взять и вот этот вот отрезок
переместить вон туда.
Какой?
Вот этот вот отрезок переместить вон туда или куда?
Ну нижний наверх.
Так.
Ага.
Ага.
Ну да.
А вот внимание, вопрос.
Почему я не могу вот эту вершину схлопнуть с вот
этой?
Потому что можете.
Не, не могу.
Потому что одна из них нет.
Да.
Одна из них терминальная.
Конечно.
Ну у вас три.
Потому что на самом деле все эти вершины терминальные.
А вот эти?
Нет.
А лучше.
Вот.
Поэтому они не схлопываются, да.
Лучше, да.
Лучше, да.
Да, да, да, да, да.
Ой.
Это называется, что объединяет Анастасию Волочкову и Элтона
Джона.
Да.
Участие в этой рекламе.
Да.
Почему оба раза эпично действительно получилось.
Да.
Вы видели версию с Элтоном Джоном?
Нет.
С Волочковым.
С Волочковым.
Кто это?
Да.
А, ну скажем так.
Назвать Аболиринут.
Бывший Аболиринт Большого театра.
Бывшая реклама.
Да вот.
Нет, ну там знаете.
Нет, ну там нет.
Да ладно.
Еще вы по телевизору не видели старую рекламу.
Играют там что-то.
Играют, значит, там пацаны в баскетбол.
Ну как?
Там куча пацанов и одного Волочкова.
Причем играет она почему-то в стиле балета.
Ну вот.
В чем там?
Играет не очень, потому что она пытается передвигаться
по балетному.
Там команды берут таймер.
И там Диман.
Что за балет?
Играешь жестче.
Ну она его там посылает как-то.
А он там с ней кидается.
Когда голодные, ты не в форме.
Волочкова кушает лучше.
И вместо Волочкова появляется парень лучше.
А вы знаете.
А сейчас тренд такой идет, что звезды там...
То сейчас называется самоирония.
Нет, самые эпичные, знаете, на кофейных автоматах,
там бывает, вот пока я стираю, знаете, там оказывается
есть американская версия, в которой снимался Элтон Джон.
Да, вот представьте, значит, какой-то там подвал, значит,
рэп батл.
То есть вот это там действительно рэп батл, а один рэпер заканчивает
там свои панчи, там говорит всё, раунд, и он говорит,
так, теперь ответим, там послушаем эмси справа.
Там выходит Элтон Джон и начинает чё-то очаровательное
петь.
Такой чё-то там, don't breaking my heart, там чё-то соответствует
противник.
Он мне сказал сейчас, да, а ему так, это сникерс, когда
голодный, ты не в форме, там лучше, ну, вместо Элтон
Джона появляется там какой-то там темнокожий, лучше, давайте
бит.
То есть это там шикарно на самом деле было, да.
Вот, так вот, прежде всего мы сейчас пойдём на перерыв.
Вот, нет, тут, ну, там, да, ладно.
Так вот, значит, теперь мистическая терема.
Сейчас мы попытаемся сделать упихон.
В, значит, если модуль S больше либо равно трёх, то в Дау ГТС
не более чем три модуль S минус четыре рэпер, вот
тут я точку поставлю.
Да, на этот раз рэпер.
Значит, внимание, внимание, обратите внимание, то есть
эта оценка от размера алфавита не зависит от слова никак.
Потому что их там два, три, пять, десять, N, ну, пожалуйста,
тем не менее у вас там рэпер будет мало.
Ну, если вы, конечно, там не полный строите, это там
по дк, этот ваш.
Ну, давайте брать, откуда мы берём такую радость.
А берём мы, ну, здесь так просто уже не придумаешь.
Значит, бюро, оказывается, есть такая весёлая конструкция.
Смотрите, на самом деле можно заметить, что у суффиксного
автомата есть не просто, есть стартовая вершина,
а есть, так сказать, конечная вершина.
Под конечной вершиной я имею в виду класс эквалентности
самой строки S.
Это единственная в автомате терминальная вершина, из
которой не выходит вообще никаких рёбер.
Да, то есть это единственная вершина.
Да, потому что я тыждаю, в суффиксном автомате есть
ровно одна вершина, из которой не выходят рёбра.
Да, других, очевидно, нет.
можно дойти до, ну понятно, до самого большого суффикса?
Ну нет, ну не совсем так.
Ну нет, из любого суффикса можно дойти прямо вот до этого суффикса.
Измена до этого?
Нет, до этого нельзя, потому что не любой суффикс является префиксом вот этого суффикса.
То есть, скажем, в строке abatsaba из строки ba ты можешь дойти до строки batsaba, но не можешь дойти до строки...
С точки зрения права в контексте.
В смысле?
Да, ну нет, правда, да, ты можешь дойти до...
Ну да, то есть, даже так, из любой подстроки...
Да, из любой подстроки можно дойти до какого-то суффикса, у которого в правом контексте лежит только пустая строка.
И, в общем-то, все такие строки, в общем-то, в этом правом контексте и лежат.
Вот.
Нет, пока ничего сложного.
То есть, получается, я поэтому эту вершину люблю называть конечной.
Потому что все исходит из старта и приходит туда.
Так вот, я, собственно, к чему?
А давайте запустим из нее DFS по обратным ребрам и построим дерево DFS.
Сейчас.
Если из нее что-то выходит...
То есть, на этот раз, да.
Оттуда можно дойти до какой-то терминальной.
Соответственно, понятно.
Ну да, совершенно верно.
А если ничего не выходит?
Ну да.
То...
Ну, справляем так.
Если ничего не выходит...
То есть, скажем так.
Вершины, из которых ничего не выходит, будут двух типов.
У них в правом контексте лежит либо пустая строка, либо ничего.
Но ничего лежать не может, потому что у нас нет таких вершин.
Мы такие вершины удаляем.
Следовательно, остается только вот такая.
Ну понятно.
Все такие вершины эквивалентны.
То есть, она одна.
Так вот.
Давайте так вот построим.
Значит, мы можем построить дерево...
Ну, такое вот.
То есть, на автомате мы можем построить подвешенное...
Вот такое подвешенное дерево.
Так сказать, скорь...
Только это уже не суффиксные ссылки.
Это уже реальные ребра автомата.
Нет, но это уже...
Оно не единственное.
Да.
Дерево, конечно, не единственное.
Боже упаси.
Но я просто говорю, что дерево существует, потому что оно...
Понятно, да?
Из любой вершины можно сюда прийти.
Как мы уже обсудили только что.
Вот.
В такой...
Ну, очевидно, что в таком дереве не более, чем два модулез.
Минус два ребер.
Логично, да?
Вот.
Теперь вопрос.
А сколько еще в этом дереве может быть ребер?
Узнавать мы это будем следующим способом.
Смотрите.
Пусть у меня, допустим, где-нибудь нашлось...
Допустим, вот такое ребро.
Да?
То есть, какой-нибудь ребро, которое в это дерево не попало.
Так вот.
Господа, внимание.
Я хочу сделать с ним следующее.
Я могу сопоставить этому ребру следующий путь, который
начинается в стартовой вершине.
Там произвольным образом доходит до этой вершины.
Там проходит по этому ребру.
А потом после него идет строго по дереву.
Понятно, да?
Повторите, пожалуйста.
Значит, рассмотрим какое-нибудь ребро, которое в это дерево не попало.
Сопоставим ему путь из вершины С в вершину Т.
Какое-то дерево доминации пошло.
Не.
Ну вот, один путь.
Значит, сопоставим путь из С в Т, который проходит через это ребро, во-первых.
А во-вторых, после этого ребра идет строго по дереву.
А до этого как?
А до этого как угодно главное в эту вершину прийти.
Да, кстати, на всякий случай.
Надеюсь, не надо это.
Надеюсь, является очевидным фактом, что этот граф отциклический, да?
Да.
Так мы же взяли дерево.
Нет, вообще суть это автомат отциклический.
Да.
Ну вот.
Ну, по крайней мере, минимальный.
Да, потому что он минимальный.
Да, не минимальный мог быть и циклическим, в принципе, да.
Нет, не мог.
Мог, мог.
Потому что, знаете, как могло быть?
Вы могли бы там просто взять цикл, из которого недостижимый
терминальная вершина.
Вот.
Да.
Так вот.
Так вот, смотрите.
Значит, смотрите.
То есть, каждому такому ребру соответствует такой путь.
А самое главное, каждому такому пути соответствует какая-то подстрока строки S.
Даже не просто подстрока, а суффикс строки S.
Да, вот досюда любой.
Но каждому такому зеленому ребру соответствует какой-то суффикс строки S.
В общем, даже не просто суффикс, а суффикс вот из этого класса эквалентности даже.
Но это даже сейчас не важно.
А не логист?
Что? Почему?
Нет, не логист.
Ну, потому что, ну как-то.
Потому что что такое класс эквалентности состояния?
Это множество строчек, по которым мы приходим в это состояние.
Так что раз мы пришли в это состояние, значит, мы в классе эквалентности строки S.
Так, где тут разрыв шаблона?
У нас каждая вершина свой класс эквалентности.
Да.
Почему она входит в класс эквалентности строки S?
Нет, вершины никуда не входят.
Входит путь, вот, смотри, вот есть путь красненький, да?
Да, в этот путь.
Нет, вершины никуда не входят.
Входит путь, вот, смотри, вот есть путь красненький, да?
Пути соответствуют подстрока строки S.
Так вот, это, так вот, подстрока, то есть это вот путевая,
путевая строка этого красного пути входит в класс эквалентности вот этой вершины.
Вот.
Вот это уже да, да?
То есть получается каждому, получается,
то есть каждому зеленому ребру соответствует какой-то красный путь, который является суффиксом.
Еще раз, что такое зеленое ребро?
Произвольное ребро не из дерева.
Да.
То есть мы взяли наше дерево, которое было суффиксным сылоком?
Нет, это уже не дерево суффиксных сылок, еще раз.
Просто какое-то острое дерево.
Просто какое-то, а просто какое-то остовное дерево с корнем в конечной, так сказать, вершине в суффиксном автомате.
Сейчас я не очень понял утверждение про класс последней вершины.
Что тоже называется класс?
Класс, это просто множество всех.
Ну, как бы это...
Каждой вершине соответствует класс эквалентности.
По которому на него можно дойти?
Да.
Окей.
То есть как бы в эту вершину можно дойти по самой строке С и, возможно, еще по каким-то суффиксам.
Хорошо.
Почему-то для любого зеленого ребра...
Та строка, по которой мы дошли до начала перебора, тоже будет.
Но для этого нужно, чтобы она была терминальна.
Чтобы оно...
Ну, в этом и глубокий смысл вообще, что как бы...
Что в каждой вершине, в каждую вершину можно дойти только по...
То есть только по строчкам соответствующей класса эквалентности.
Только, ну да.
Значит, по сути, альтернативное определение.
То есть класс эквалентности...
Класс эквалентности — это множество строчек, по которым мы приходим в одну вершину.
Высказали, кажется, убеждение, что...
Что это суффикс?
Что для произвольного вершины...
Нет, для произвольного ребра вот этот вот красный путь является суффиксом.
А, просто до вершины Т.
Ну да.
Да, потому что да.
Больше я ничего не утверждал.
Нет, до этого момента, конечно, он суффиксом быть не обязан.
Но фишка в другом.
Получается, мы каждому зеленому ребру сопоставили суффикс.
Более того, я утверждаю, что мы любым двум зеленым ребрам сопоставили два разных суффикса.
Понятно.
Ну, не совсем концерт.
Сейчас надо проверить, что у нас бывает такой ситуация, что если мы взяли зеленое ребро и по нему прошли дальше, то там могло быть пути на него меньше, чтобы...
Нет, тут просто фишка в том, что зеленое ребро — это последнее ребро на красном пути, которое не лежит в дереве.
Нет, но это означает, что по каждому суффиксу мы можем однозначно восстановить зеленое ребро, из которого мы его выкопали.
Нет, еще раз, у нас же много разных строгих вершин.
Да, но мы взяли конкретную.
Мы взяли такую из них, которая проходит по этому ребру.
Причем, внимание, после этого ребра прошла строго по дереву.
У нас в вершину не обязаны приходить все буквы различные.
А буквы тут при чем?
Кажется, что вот почему не может быть такой ситуации, что дальше, непонятно, что дальше для каждого зеленого ребра пути будут разные, почему не может...
А потому что мы его... Нет, скажи так, из этой вершины до этой существует большое количество различных путей.
Нет, тут еще раз, повторите утверждение, которое вы говорите, что мы когда-то делали.
Мы каждому зеленому ребру сопоставили ровно один суффикс.
Да.
Нет, не ровно один.
Нет, мы...
Может быть несколько.
Да, но мы выбираем, потому что у нас есть конкретный алгоритм, как конкретно мы сопоставляем суффикс.
Он говорит так.
А как мы выбираем первую часть?
Первую часть как угодно, просто как угодно дойти до этой вершины.
Хорошо, непонятно почему не может быть такой суффикс.
Первая часть пути плюс вторая часть пути совпало с какая-то другая вторая часть.
Ну, как минимум.
Но у нас автомат детерминированный.
Одна строка один путь.
Звучит как что-то китайское.
Одна строка...
А, сейчас.
Мы говорим, что у нас будет два одинаковых пути.
Чего?
То, что одна строка один получается.
Ну, как бы...
Скажем так.
Ну, потому что, какую бы вы строку не взяли, если вы пытаетесь пройти по строке из тактовой вершины, то путь восстанавливается однозначно.
Все, так что...
Вот.
Так что вот.
Так что единственное, что можно сделать, если у нас будет два одинаковых пути до Т, то у нас...
Вот.
Так что вот.
Так что единственное, что может быть, это что вы...
То есть, если вы взяли два зеленых ребра, то есть, могло ли быть так, что вы взяли два зеленых ребра и получили один и тот же путь.
Просто это зеленое ребро в этом месте здесь, а потом где-то еще.
Но это не бывает. Почему?
Потому что на каждом выбранном пути зеленое ребро, индуцировавшее его зеленое ребро, оно последнее ребро не из дерева.
Что-то вообще не то получилось. Получилось так, что мы каждому зеленому ребру сопоставили суффикс.
Да.
А, ну да, все хорошо.
Вот. В чем суффикс, причем каждому зеленому ребру свой. Что важно.
Просто когда получилось, что у нас ребра не больше чем...
Ну, на самом деле, мы так и выведем. На самом деле, из этого выводится, что зеленых ребр не более чем бодуле с минус один. Почему?
Потому что суффикс у нас всего с плюс один, ну, всего вообще.
Но, во-первых, мы не используем пустой суффикс, очевидно.
А во-вторых, один из этих суффиксов покрыт самим деревом.
Поэтому, получается, зеленых ребер не более чем...
Значит, зеленых ребер у нас получается не более чем... Ой, это не зеленый, да.
Не более чем модуль с минус один.
Отсюда получается оценка 3s минус 3.
Можете повторить?
Оценку на количество зеленых ребров.
Вот мы взяли ребро.
Их не более чем s минус один.
Вот мы взяли ребро и построили путь.
Нет. Ну, потому что, короче, лучше с конца.
Каждому зеленому ребру мы, нашим мистическим алгоритмом, сопоставляем какой-то суффикс.
Да.
Причем более того, к каждому зеленому ребру мы соправляем различные суффиксы.
Вот.
Вы, короче, почему не различные, меня убили.
Потому что, на самом деле, к двум разным строчкам соответствуют разные пути.
Да.
Строчки будут различные, потому что для каждого...
Сейчас.
У них либо вторая часть, сейчас.
Можете поподробнее рассказать об движении, почему две строчки различаются.
Так. Почему две строчки... Ну, что значит две строчки?
Мы, короче говоря, поставили...
Почему не можно сделать такую ситуацию, что две строчки совпадают?
Нет, этот вопрос может иметь... Я, возможно, просто не могу угадать, какой смысл ты имеешь в виду.
Я с лету знаю как минимум два.
Короче, чтобы пройти в автомате по этой строчке, мы можем ровно одним способом.
Проблема не... Это понятно?
Не берем на этом пути последнее ребро, которое не лежит где.
Последнее ребро, которое не лежит где.
То есть еще раз.
Ну, мы сейчас что сделаем вообще глобально? Как мы это доказали?
Мы сказали, что для каждого зеленого ребра есть ровно одна строчка, причем такая, что она является сулицей.
Посмотрим такую биекцию слову.
Нет, это не биекция. Это инъекция.
Ну, неважно.
Поэтому мы сказали, что зеленое ребро не больше, чем энергостерин.
Да.
Почему это инъекция?
Почему это инъекция?
Почему это инъекция?
Ну, потому что начнем с того, что...
Ну, утверждение такое, видимо надо найти, то есть ключевое утверждение, что двум зеленым ребрам один и тот же путь сопоставлен быть не может.
Что значит сопоставить путь? Какие пути вы сопоставляете?
Нет, я каждому зеленому ребру вот по такому алгоритму сопоставляю красный путь.
Кажется легче сказать.
Вот, рассмотрим зеленый путь.
Ну, кому как. На вкус и цвет. Я говорю так, как легче.
Ну, вот, значит, то есть сопоставляю путь к такому алгоритму. Я беру стартовую вершину.
Дохожу до нее произвольным образом до начала ребра.
То есть одному ребру может быть сопоставлено много путей?
Ну, точнее так. Да, у нас есть выбор, кого выбирать.
Да, путей может быть много, но мы выбираем конкретно один.
Так вот, значит, потом проходим по зеленому ребру и дальше мы идем до вершины Т строго по выбранному дереву.
Окей. Вот.
Вот вершине разным зеленым ребром мы выберем разные пути.
В смысле вопрос заключается в том, могло ли на вот этой красной скомканной нити лежать еще одно зеленое ребро?
Ну, более формально даже более ранний вопрос.
Могло ли быть другое зеленое ребро, которому мы сопоставили ровно такой же путь?
Мы же по пути, по пути мы однозначно определяем.
Да, по какому зеленому ребру мы восстановили? Как мы это делаем?
Мы идем с конца и находим первое ребро, которое не лежит на дереве.
Да, поэтому разным зеленым ребром соответствуют разные пути.
Да, разным путям соответствуют разные строки, а в нашем случае еще и разные суффиксы.
А суффиксов этих не более чем, различных тут может быть не более чем S-1.
Почему?
Потому что всего суффиксов не более чем S-1, это во-первых.
Во-вторых, пути у нас не нулевой длинный, поэтому как-то пустой суффикс не подходит.
А в-третьих, еще есть такой суффикс, по которому мы просто в дереве идем из S в T.
Поэтому как бы тут различных суффиксов может быть, которые тут могли появиться не более чем S-1.
Вот и все.
На этом мы получили 3S-3.
Совершенно верно.
Потому что пока у нас оценка на синие ребра 2S-2, а тут S-3, поэтому в общем случае 3S-3.
А теперь, почему я беру, а может тут даже больше 3.
Ладно, давайте напишем пока больше 3, если что, равенство прорисуем.
Потому что идея такая, почему я пишу 3S-4?
Потому что я думаю, а где может быть 3?
То есть 3S-3, если тут прям жестко 2S-2, и тут жестко S-1.
Но вот это вот жесткое 2S-2, оно означает, что у нас вершин 2S-1.
А мы знаем, что это бывает только вот в этом вот случае.
Поэтому проверим на этом случае руками?
Да, но на этом случае у нас сколько ребер?
Короче, 2S-4.
Да, господи?
Как бы вершина 2N-1 и есть цикл.
Нафиг нам оценка 3S-4, если 3S-3 тоже работает?
Нет.
Но потому что не всегда надо мыслить как олимпиагер, которому 3S-1 плюс-минус единичка по барабану.
Вот как-то, извините, иногда в науке бывает и плюс-минус единичка помогает.
Как это помогает?
Периодически случается, например, особенно если вы потом будете 2 в эту степень возводить,
или там как-нибудь еще, то где-нибудь там лишь единичка,
или наоборот, эту штуку вы будете возводить в какую-нибудь степень.
Причем не константную, что важно.
Какой задачи это может понадобиться?
А вот и дискрайния на самом деле, я вам подробно расскажу про такие задачи.
Но как вам поможет знание, что там меньше или правда именно 3S-4?
Ну, скажем так, честно скажем, то есть, на самом деле, да.
То есть, ладно, можете считать, что вы идете в заниматель для того, чтобы лучше понять структуру автомата.
Да.
Потому что, ну, честно скажу, да.
Обычно в половине случаев это именно так.
Я понимаю, конечно, вопрос, что зачем мы это делаем и так далее.
Но если мы будем только скрупулезно делать то, что хоть в какой-нибудь там где-то задача надо,
и не будем делать то, что якобы не надо, то как бы мы рискуем себя сильно ограничить.
То есть, все-таки у нас должен быть запас прочности и все-таки соображалски.
Ну, значит, давайте смотреть.
То есть, у нас тут получается 2N-1 вершина и ребер в ней тоже 2N-1.
Так, ну возникает вопрос, что 2N-1 равно 3N-3 тогда и только тогда, когда 2 равно N.
Так что, в принципе, можно, то есть, для троечки тоже пойдет.
А, хотя нет.
Нет, что-то не то.
Так.
А, ну да.
А, ну да, правильно, правильно, правильно.
То есть, вывод может быть очень простой.
То есть, на самом деле, 3N-3 не бывает никогда просто.
То есть, ответ 3N-4.
Ну, в качестве упражнения, то есть, ладно, теоретически может быть задача.
Господи, вот да, был бы у нас ассистент, может, дал бы в домашнем задании.
Найдите все строчки, у которых количество ребер 3N-4.
Нет, это не ваш ассистент.
Нет, это хорошее ПД.
Нет, это не то.
Ну, как вам, в обязанности, если он в старости, в его обязанности, как в старости, наверное, не входит проверять ваши домашние задания.
Нет, максимум, что может входить в его обязанности, это проводить с вами там какие-нибудь душеспасительные беседы на тему того, что как бы домашние задания делать надо.
Но проверять их это нет.
Ладно, так, ну что, требуете перерыв или пошли дальше?
Ладно, ну, в принципе, конечно, да, то есть, у нас уже, конечно, важный рубеж.
Мы уже показали, что размер суффиксного автомата линейен, причем независимо от самого алфавита, что приятно.
Ладно, теперь пошли его строить.
Ну, конечно, за УАТН его нельзя построить, как известно.
А почему?
Потому что, а как всегда, утверждение, если вы построили автомат, то, скорее всего, вы там и сортировку за УАТН сделаете.
Нет?
Нет.
Ну, там, потому что вы по суффиксному автомату можете суффиксный массив ДФСом построить.
Ну, это да.
Вот.
А, имеется в вид, что там...
Ну, да.
Но там так, да, там аккуратненько про алфавит надо говорить просто, да.
Вот. То есть, мы сейчас, конечно, ну, вот, видимо, то есть, надо еще оговариваться, что мы в этом автомате, мы еще и хотим, чтобы эти ребра как-то хранились, видимо, в порядке возрастания буквок или что-то в этом роде.
Дальше, возможность построить автованса УАТН плюс Сигма никак не будет в речи, потому что нет САП-тирожки.
На самом деле нет.
Называется сортировка подсчета?
Нет, ну, тут опасно, да, хорошо, потому что, в принципе, да, заметим, что если ребра не посортированы, то, в принципе, все ребра в вершинах можно за УАТН плюс Сигму действительно сортировать. Это да.
Ну, там просто общим подсчетом таким каким-нибудь.
Дмитрий, сколько мы планируем закончить сегодня?
Вот, хорош.
А у нас же расписание есть?
Ну, есть, да.
Есть, да.
Ну, да, одно дело расписание, другое дело наше занятие.
Так, ну, а во сколько мы формально должны закончить?
Формально?
Через 40 минут.
Ага, ну вот, очень постараемся. Давайте в темпе.
Ну, вот.
Формально у нас пара заканчивается в 17.20 на тимке, потому что 13.45 не начинается.
Нет, нет.
Кстати, да, почему мы так-так успокоился?
Потому что я в какой-то момент обнаружил, что, видимо, формально пара теперь тут тоже как на фистехе.
Так что, да, наше занятие здесь в 13.55 начинается, все нормально.
Возможно, что она нам об этом сказать.
Да.
Да, давайте, да. Уже и так, по-моему, стало исторически так складываться.
Ну ладно, давайте, значит, тогда фиксируем все.
Проговорим уже это то, потому что, честно говоря, я стал так спокойно, на самом деле, приходить двум ровно поэтому.
Ну, так, нет, все равно, ну, типа, кто-то приходит на строка пяти, потому что он думает, потому что...
Да, ну вот.
Все, да, неправ, хорошо, неправ, да, все, хорошо.
Формально, да, формально, да, все, давайте объявляем, все, да, все, пара в 13.55, все прямо.
Тогда это 13.55, 15.20, 15.30, 16.55, 17.05, 18.30.
Окей.
Ладно, ну ладно, давайте быстренько.
Итак, приступаем к построению существенного автомата.
А сейчас для простоты будем считать, что размер алфавита константа.
Так, ну начнем вот с чего.
Вот, значит, ответьте, как будем строить автомат?
Ну, примерно как дерево палендровов.
Ну, да, будут две важные, будут два важных сходства.
Первое, мы будем изначально строка S будет пустой, и мы будем приписывать к ней по одному символу.
И в каждый момент времени у нас будет корректный суффиксный автомат для текущей версии строки S.
Правда, с маленькой оговорочкой.
Оговорочка заключается в том, что мы не будем поддерживать терминальные вершины.
Ну, потому что мы в случае чего знаем, что вот представьте себе, что у нас есть полностью корректный автомат.
Что значит полностью корректный?
Значит, у нас есть там набор вершин, у которых есть дети.
Ну, там мапчик какой-нибудь, да.
Там дети, есть лен, есть суфф.
Что еще?
А, ну в принципе и все.
То есть единственное, что вам не хватает в этом автомате, это терминальных вершин.
Так вот, предположим, что у вас автомат полностью корректный.
Единственное только, что вы потеряли терминальные вершины.
Задача, как восстановить, где терминальная вершина находится?
Построить суфф ссылки.
Ну, суфф ссылки, допустим, уже есть.
Просто от последнего.
Ну да.
То есть надо взять вот эту вот вершину, которая S, и просто поскакать из нее по суффиксным ссылкам.
Вот. Ровно они есть терминальные, потому что ровно в них заканчиваются суффиксы.
Вот.
То есть вот такая идея.
Поэтому мы поддерживать терминальные вершины не будем.
Все, поняли идею, да?
А теперь давайте думать.
А вот действительно, как поменяется автомат для строки S, если мы приписали к ней символ C?
То есть у нас вот S переходит в S, C.
Вот как он вообще поменяется?
Ну, для этого надо подумать, а как поменяются классы эквивалентности?
Вот если мы к строке S припишем символ C.
Так, склеится.
Наоборот.
Нет, ну на самом деле, да.
Первое утверждение, что если кто-то был лонгестом в S, то он уже останется лонгестом навсегда.
То есть такой простой, такой принцип, longest now, longest forever.
Соответственно, да?
Вот.
Да, может даже быть поиск по времени.
Но единственная проблема, что со временем у нас могут появиться и новые лонгесты.
Вот, кстати, как минимум один новый лонгест вообще появился.
Это, собственно, строка S, C, правда?
Вот.
Но действительно, кстати, как вы думаете, вот давайте сразу для упражнения.
К чему равен класс эквивалентности строки S, C?
С в строке S, C.
Чего?
Нет, не только.
Что?
Еще раз, класс эквивалентности это может всех строчек эквивалентных ей.
Все пути до самой последней вершины.
А что это за пути?
Каким строчкам они соответствуют?
Мне интересно, каким строчкам они соответствуют.
Понятно, что всем суффиксам.
Нет, всем суффиксам.
Точным суффиксам будут?
Да. А какие конкретно?
Вот.
Объединение каких?
Объединение тех классов строк, из которых не было.
Эквалипция.
Не.
Да ладно, куда-то вы не туда мыслить.
Не просто.
Какие строки эквивалентны S, C?
Те суффиксы, которые не встречаются в строке, наверное.
Не встречаются в строке S.
Вот именно.
То есть просто вот можно так и написать.
Такое утверждение.
Класс эквалентности S, C это множество всех суффиксов S, C, не входящих в S как под строки.
Потому что, да, S, C это такая строка, у которой единственное вхождение заканчивается вот после вот этого символа C.
Вот.
То есть несколько суффиксов S, C обладают таким свойством.
А потом неизбежно появляется суффикс.
Мы будем называть его, кстати, S0, который встречается в строке S еще где-то.
Понятно, да?
Причем, типа, если он встречается, то очевидно все меньше его.
Да, все меньше его тоже очевидно встречается.
Но это да.
Более того, очевидно в этот S0 нам придется еще из класса S, C.
А это, кстати, будет новый класс, очевидно, да?
То есть провести суффиксный ссылок.
Понятно, да?
Я имею в виду, что, ну, смотри, вот этот класс новый.
Но новый по сравнению, ну, в каком смысле новый?
У нас был суффиксный автомат для строки S.
И был как и выше, у нас wasn't S, да?
Да.
И были какие-либо классы эквивалентности.
Мы добавляем символ С.
В некотором смысле у нас появляется новый класс эквалентности для строки S, C.
Он новый в том плане, что строки С, С у нас раньше не было и класса эквалентности у него тоже не было.
Почему с классой эквалентности и глобально поменялись?
Чего?
У нас с классой эквалентности​ сpersalined lines…
Да, формально говоря там класса эквалентности, ну, сформулиру�лы так, под строкиhu нас были старое и вот были новые.
Да, логично. Но там, конечно, классы могли перестроиться от слова кардинально. Совершенно верно. Вам могло так показаться.
У нас левые контексты не поменялись. Правые контексты тут удобно мыслить как позиции, в которых заканчиваются вхождения.
В правых контекстах ко всем строчкам приписали символы С у старых строчек, и у некоторых еще появился дополнительный Эпсилон.
У некоторых появился дополнительный Эпсилон. Это, видимо, те, которые заканчивались в ВС.
Наверное. Ну, которые оказались суффиксами этой строки. А еще эти классы эквалентности могли переформатироваться.
Хотя потому что к кому-то приписалось, к кому-то нет. Но давайте внимательно думать. А теперь давайте думать.
Потому что я хочу доказать Сиарему. Но с другой стороны, заметим, что старые классы эквалентности могли только посплититься.
Потому что, как мы помним, Longest Now, Longest Forever. То есть это означает, что классы эквалентности старой мог поменяться как.
Внутри его какая-то вершина объявила себя Лонгестом и отпилилась.
И сказала, что я Лонгест. Все, кто идет дальше, все будут за мной. Мы теперь в другое государство.
Вот. Так вот. А теперь мистическая теорема. Прямо теорема, да? Ну ладно, теорема. Хочу теорема.
Так вот. Мистическая теорема. Пусть. Значит, Х это Лонгест классы эквалентности Х в строке СС.
Ну вот. Тогда верно хотя бы что-то из следующих утверждений.
Вот утверждение такое.
Значит, либо может быть, что Х уже был Лонгестом ранее.
Ну то есть он был под строкой С и был там даже Лонгестом.
Еще у нас был случай, когда Х равно СС.
А теперь даже давайте думать. А что еще могло произойти?
Нет. Пустая строка была сразу Лонгестом.
То есть спрашивать, какие случаи мы не покрыли? Как еще?
Так вот теперь давайте думать. Смотрите. Что могло не попасть в этот случай?
Как об этом нормально думать? Как о вершинах, автоматах или как о вхождениях?
И так, и так. Ну я не знаю.
Так. Пусть Х Лонгест в своем классе эквалентности СС.
Тогда мы хотим расписать, в каких случаях это возможно.
Первое. Он был Лонгестом ранее. Он мог быть Лонгестом ранее. Он может быть СС.
Я хочу дописать что-то еще.
Если он не был Лонгестом ранее.
Осталось только случая, когда может быть Х был под строкой С.
Заметьте так, что все, что не...
Просто вопрос. Если Х равно СС, то он был Лонгестом в классе эквалентности СС.
Он не был. Нет. Он СС не был Лонгестом в классе эквалентности С.
СС был Лонгестом в классе эквалентности С.
Да. А вот является ли он Лонгестом?
Ну да. Он префикс, поэтому он всегда будет Лонгестом во всех последующих.
Так. Префикс всегда Лонгест.
Стоп. Тут что-то нечисто тогда.
Что нечисто?
У нас же...
У нас же приписался символ.
Приписал.
Символ опускаем или нет?
Куда опускаем?
Это происходит только в случае, если он был эпс.
Ну если у нас в пралом контексте был эпс, то есть эта штука была терминальна.
Ну была терминальна, а потом перестала быть терминальна. В чем проблема?
Нет. Еще раз. Третий случай.
Это в тот момент, когда у нас появился какой-то суффикс, который...
Суффикс СС.
Который раньше встречался.
Да. Но не просто раньше встречался.
Раньше встречался безбуховый цепь.
Нет, нет. Там немножко другое.
Так, давайте так.
Вы тут активно параллельно думаете, но явно просто на разных этапах.
То есть у нас был либо Х, Лонгест ВС, либо Х, это суффикс СС.
Да. Но давайте да.
Но мы пытаемся понять, какие из суффиксов нам подходят, какие нет.
Нет. Мы пытаемся понять, какие еще бывают варианты.
Ну в плане, если Х не Лонгест...
Во-первых, все Лонгесты...
То есть, кто еще может быть Лонгестом ВС, если он не был Лонгестом ВС и не СС?
То есть, короче говоря, мы утверждаем следующее.
Если Х был Лонгестом ВС, то он остался Лонгестом ВС.
Да.
Если Х Лонгест ВС, либо он был Лонгестом ВС, либо он является каким-то суффиксом СС.
Так. Нет, это мы еще не утверждаем, но такой вывод сделать можно.
Ну в плане это правда.
Так. Ну давай да. Да, но я сформулирую аккуратно.
Заметим, что...
И мы пытаемся выяснить.
Ну давайте да.
Ну в-первых, начнем с того, что у нас появились...
Рассмотрим, ну в-первых, Х он либо под строка С, либо не под строка С.
Да.
Да.
Все не под строки С находятся в этом классе эквивалентности.
Ну все под строки СС, которые не являются под строками С, лежат в классе эквивалентности СС.
Все новые под... Все новые под строки.
Нет, новые это те, кто не были в С.
Не были в С.
Да.
Ой, ой, ой, ой.
Так, еще раз.
Просто для понимания, то, что я сказал, это правда?
Так.
Что все новые лонгестые от Х, это могли быть только суффиксы строки СС?
Да.
Окей.
У нас есть еще критерии лонгестые.
Был критерий, да, и что?
То, что перед нами все символы...
Ну, то есть мы либо префикс, либо перед нами есть хотя бы два разных символа.
И что?
А какая разница?
Ну, вот это утверждение берется вообще без критерии.
Оно просто должно быть понятно само, если вы понимаете, что такое класс эквивалентности.
Еще раз.
Ну, что все новые, все под строки СС, которые не являются под строками С, лежат в классе эквивалентности строки СС.
Вот.
То есть никаких критериев не надо, чтобы понять это утверждение.
Ну да, потому что у них справа только один символ можно дописать вообще.
Ну не символ, а просто...
То есть у всех этих строчек только одно вхождение.
Вот здесь в конце.
Иначе было бы еще дальше.
Да, да, да.
Вот и все.
Так вот.
То есть таким образом, что вот сюда...
То есть если Х не СС, то он был под строкой С.
Но при этом у него был только один символ.
Нет, а теперь да.
Какие варианты были?
Тогда он мог быть Лонгисом ранее.
Да, ну префикс.
Но если он был префиксом, то он и сейчас префикс.
Но теперь думаем.
Хорошо, теперь остается только вариант, когда Х был под строкой С.
У нас что префикс-функция будет насчитываться?
Нет.
Значит, смотрите, Х...
Да погодите, не закидывайте параллельные вопросы.
Значит, смотрите, так действительно, как мы уже пришли к тому, что здесь должно быть какой-то случай, когда Х был под строкой С, Лонгис там в ней не был.
Но при этом, когда пришел символ С, он неожиданно Лонгистом стал.
Давайте думать, как это может быть.
Значит, смотрите, сейчас я это сотру.
Тогда получается, что был какой-то Х.
Лонгистом он не был.
То есть получается, у него были какие-то вхождения, но префиксом он не был, а перед всеми его вхождениями находился какой-то символ В.
И тут неожиданно выяснилось, что появился какой-то символ С, и он неожиданно Лонгистом стал.
Но префиксом он от этого не стал, очевидно, да?
Почему? Ну он мог быть.
Нет, ну не может быть так, что Х не мог, ну не может быть так.
Но если Х не является префиксом С, но является префиксом СС, значит Х равен СС.
Сейчас, стоп.
Нет, не так. Сейчас.
Но мог быть не Лонгист префикс.
А Лонгисту при чем?
Ну просто Х уже не был префиксом строки С.
Это вы предположение взяли?
Нет. Я это вывел из того, что Х не был Лонгистом С.
Нет. Ну в плане, у нас могут быть префиксы, которые входят только один раз.
И что? Какая разница? Мы точно знаем, что все префиксы являются Лонгистами.
Вот был у нас великий критерий, в котором говорилось, что префиксы Лонгисты все, у кого есть два продолжения влево, Лонгисты других Лонгистов нет.
Блин.
Я забыл, почему префиксы Лонгисты.
Так еще раз. У тебя еще критерий Лонгиста, это то, что у тебя предыдущая вершина, если ты допишешь еще один символ слева, условно в каждом вхождении своей строки, у тебя не появится еще всех суффиксов, которые также были в прошедшем условии.
Поэтому на каждого префикса, перед префиксом у тебя нет никакого символа, который может официально вмешать. Если ты возьмешь больше суффикс, больше суффикс не может ввести в эту же вершину, потому что он не будет ввести в следующий суффикс.
Ну, тот, который соответствует префиксу.
Но тут это двойственность ее, из-за того, что мы не вводим левую вершину, она тоже забывает.
Нет. Чего мы не вводим? Лему мы эту прописывали.
Она уже забыла.
Нет. Ну вот. Ладно.
Все префиксы являются с лонгистами по той вершине, что если мы рассмотрим вершину, которая соответствует этому префиксу и рассмотрим, понятно, что в этой вершине будет суффикс самый большой.
Ну да. Если продлить его влево, то это длинные суффиксы из правого контекста исчезнет.
А, вот именно поэтому все эти жилки являются лонгистами?
Да.
Как все те, перед которыми есть два раза.
Да, можно даже и без леммы обойтись.
Я просто перегазал.
Да-да-да. Но эту часть, если быть точнее.
Хорошо. Итак, значит, получается, наш великий лонгист не является префиксом.
Перед всеми его вхождениями у вас находится какой-то символ B один и тот же.
Так, ну раз он префиксом не является, но сейчас он лонгистом стал.
Ну вывод один, значит, получается, он, значит, при добавлении символа C появилось еще одно вхождение,
перед которым у нас вот этот символ неожиданно другой.
Ну да.
Так, ну теперь тогда вывод такой.
Внимание.
То есть X.
То есть получается, что этот X это такой суффикс СС, являющийся под строкой С.
Это во-первых.
Это во-первых.
А во-вторых.
А во-вторых.
А во-вторых, X максимальный такой суффикс.
А потому что это максимальный суффикс строки СС, который встречается в С.
Если бы это неожиданно.
Ну понятно, если бы она встречалась.
Да, но вот это неожиданность.
Доказательства очевидны?
Да.
Похоже на кролику и шляпу, честно говоря.
Еще раз что?
Да, причем когда, который, как выяснилось, танцевал у вас перед глазами, но вы не заметили.
Ну еще раз.
Что утвердил?
Что сказали?
Сказали, что если это будет суффикс по уже изученным причинам, а максимальный будет.
Потому что если он будет не максимальный, то это значит, что АС встречалась.
Это значит, что оно не будет логическим из-за того, что вершина не раздается.
Нет, но это не важно.
Может она и логична, но не важно.
Но главное выяснилось, мы уже выяснили, что перед всеми вхождениями X был другой символ.
Логичный.
Да.
Ну да.
То есть вывод, что АХ под строкой С не являлась.
Если был такой же, то у нас просто не станет ломкостом.
А если нет, то вот АХ все нету и значит больше.
Так что отсюда.
Вы не ожидаете, что у нас что за бред?
А, ну да.
Ну короче, мы как раз получили, что у нас на каждом шаге доверяется не больше двух фас эквалент.
Ну да.
Да.
Да, то есть более того, мы даже можем прописать какие конкретные.
То есть появляется точная СС и появляется еще обязательно С0.
Где С0 это тот самый, то есть давайте по определению.
То есть максимальный суффикс СС, являющийся под строкой С.
Нет, ну почему?
Нет, причем обратите внимание.
Я тут, конечно, не точно своролирую тиремму, но можно заметить следующее, что С0 точно в СС ломгостом является.
Вот прям это вот железобетона.
Почему?
А С2 всегда существует?
Конечно.
Ну как минимум Эпсилон.
Ну в плане в нашем углу С общий не встречается.
Эпсилон.
Да, С, а так совершенно верно.
Да, С0 может быть Эпсилон, если С это новый символ для строки С.
А, ну в плане он просто мог уже входить.
Кто?
С? Мог входить, мог не входить.
С0 мог быть уже ломгостом.
Мог, да.
А мог и не быть.
Ну да, потому что у нас не обязательно там С возможно какие-то.
Ну вот.
Так что теперь давайте думать.
То есть вывод очень простой.
То есть что могло произойти?
А в целом, что мы сейчас делаем?
Мы же обсуждаем, как строить суффиксный автомат?
В целом, да.
Но для этого мы замечаем.
Мы сказали, что мы его будем строить так.
У нас есть суффиксный автомат без пометки терминальных векшин для строки С.
И мы хотим приписать к строке С символ С и понять, как поменяется автомат.
Вот эта серия может говорить следующее.
То есть что классы эквивалентности практически не поменяются.
То есть изменится следующее.
Во-первых, появится новый класс эквивалентности вот этот вот СС, который состоит из всех новых строчек.
И во-вторых, может быть, то есть если вот этот вот С0 не был ломгостом, то он этим ломгостом старит.
И это будет означать, что соответствующий ему класс эквивалентности ВС распадется на два.
Ну или, если он уже был ломгостом, тогда новых классов эквивалентности не появится от слова «вообще».
Ну появится один СС.
Вот.
Ну появится тогда просто один СС.
Ну тогда слушайте.
Ну это уже неплохо.
То есть получается состояние не поменяется.
Почти.
По факту, да.
То есть на самом деле тогда вот так вот.
Вот так можно дописать утверждение.
На самом деле, да.
Неплохо.
Вот.
То есть получается, смотрите, состояние класса эквивалентности не поменяется.
То есть добавится один новый, и какой-то класс эквивалентности, может быть, попилится на два.
Все.
Ну тогда давайте думать.
Как поменяются между классами эквивалентности ребра?
И вообще, может быть, какие-то добавятся новые ребра?
Ну давайте, а давайте сделаем вот как.
Смотрите.
Ну начнем с простого.
Какие ребра должны вести?
Вот рассмотрим класс эквивалентности СС.
Так.
Ну во-первых, смотрите.
То есть давайте скажем так.
Вот у нас есть какой-то автомат уже.
Вот тут стартовая вершина какая-то, тут вот какие-то ребра есть.
Ну, заметим следующее, да.
Что для любых двух состоя, по идее, состояний, то есть для любых состояний можно, ну, по классам эквивалентности можно понять, нужно ли проводить по ним ребро, если да, то какое, правда?
Ну если мы знаем эти классы эквивалентности как множество строчек, правда?
Господи, что ж такое, я, опять же, сказал бы, сказал очень простую мысль.
Ну кажется, что да.
Я говорю так, предположим, вот каждое состояние, это вот мысленно, это множество строчек.
Да, мы его не знаем, но мысленно, да.
Но чисто теоретически, если бы мы знали для двух состояний их множество строчек, то мы могли бы точно сказать, нужно ли проводить между ними ребро, если да, то какое.
Ну, суть такая, и состояние, то есть, потому что если тут в это состоянии есть строчка Х, то как бы надо проверить.
То есть в это состояние нужно вести ребро по символу А, если как бы в это тут есть строка ХА, правда?
На самом деле нужно взять просто максимальную строчку.
Можно взять максимальную, можно взять любую, это неважно.
Просто иначе не совсем понятно почему однозначность выполняет.
Однозначность?
Ну, так.
Нет, ну не совсем так.
А если ты взял не максимальную, то тоже ты должен тогда по этой не максимальной плюс А тоже попасть в какое-то состояние, правда?
На самом деле нет.
Потому что если две строки у тебя эквивалентны, то у них правые контексты одинаковые.
А если ты припишешь к ним строку А, то, значит, останутся только те строчки в правом контексте, которые начинались на А, и тот и символ А этот еще от них отпилишь.
Ну, и в этом плане тоже, да.
Вот.
То есть как бы, да.
Вот, поэтому там как бы должно быть по барабану.
Вот.
Вывод.
То есть получается, ну, вывод такой.
То есть если состояния не поменялись, то есть как классы эквалентности не поменялись, то ребра между ними не появляются и не исчезают.
То есть что было раньше, остается раньше.
То есть условно говоря, мы должны смотреть, что происходит с ребрами, связанными с нашими новыми состояниями.
Вот, понятная идея, да?
Да.
То есть, ну, теперь надо смотреть, что поменяется.
Ну, начнем с того, что появится состояние СС, и мы должны теперь внимательно подумать.
А какое, ну, ладно, из него ребра, очевидно, не ведет никаких, но какие ребра ведут в него?
И из него ктив ребра?
Да.
Что такое ребро?
Нет, какие ребра ведут в него? Ребро, ну, палочка-то, стрелочка такая, я не знаю.
Это значит, что...
Ну, в плане, что ребро означает собой?
Переход состояния. Переход из состояния в состояние, да.
То есть, это означает, что если ты пришел в состояние по строке Х, а потом из этого состояния перешел по символу С,
то ты попал в состояние, в которое ты попал по строке ХС.
То есть, в него могут вести только ребра, которые...
Да.
Ну, так, ну, во-первых, да.
Вообще это, кстати, общее утверждение неожиданное и мистическое, что в суффиксном автомате в каждую вершину ведут ребра только по одному символу.
Внезапно, да?
Внезапно, да?
А теперь давайте вспомним, как устроено множество строчек, по которым мы приходим в состояние.
Или что то же самое, как...
Да, поэтому, да, вы не ходите ровно по одному и тому же символу.
Да, тут, да, это вот...
Каждый из них...
Вот, ну, теперь давайте подумаем.
Я что-то понял, а потом не понял.
Мы доказывали утверждение, что все строчки, которые ведут в нас, это последующие суффиксы друг друга.
Следовательно, все возможные...
Нет, стоп, это все строчки, которые ведут из нас.
Нет, в у нас.
Класс... Что такое? Значит, еще раз.
Альтернативный, например, класс эквалентности, это, по идее, это строчки, которые приходят в наше состояние.
То есть, это левый контекст.
Ну, может, ну...
Ну, может... Нет, ну, это не левый контекст, конечно.
Почему не левый?
Ну, правый контекст это все, которые исходят у нас.
Ну, если так, ну, если так, определяйте туда, хорошо.
Нет, вы так разве определяете на формалках?
У меня правый контекст, не левый контекст.
Да? Ну, не знаю, да.
Но я бы сказал, что правый контекст, то есть, изменение автомата, это...
То есть, да, докуда... То есть, как вы можете дойти из вершины этой терминала?
Ну, можно и так сказать.
Но я предпочел мыслить это, да.
Ну ладно, так вот, хорошо, это был СС.
Так, значит, теперь возникает вопрос, каким образом мы должны попадать по СС?
Ну, я утверждаю, что в СС мы должны попадать по ребрам по букве С из таких суффиксов строки С,
что их нельзя продлить по символу С, так чтобы они остались под строками С, правда?
Да, нельзя продлить, если можно было бы.
Ну вот, поэтому, значит, теперь давайте вспоминать, как там прибежаться по суффиксам строки С?
Ну, очень просто, надо взять вот это вот состояние С, да,
и тупо идти по суффиксным ссылкам, идем по суффиксным ссылкам,
до тех пор, пока из них нельзя пройти по символу С.
То есть просто нет перехода тупо.
Вот, идем, идем, идем, идем.
Видно, да?
Вот, во всех этих вершинах мы этот переход теперь торжественно рисуем, вот.
А симпатически мы это делаем достаточно бесплатно, кстати,
потому что мы знаем, что у нас в совокупности ребер будет мало.
Ну, если мы докажем, что суффиксная ссылка это оплачивает, то да.
Я бы так сказал, мы это делаем бесплатно,
потому что мы знаем, что суммарно мы нарисуем ребер не более чем 3s-4.
Ну и получается квадрат?
Нет, всего ребер, всего вообще.
А мы не удаляем, а мы ничего не удаляем?
Пока вроде нет.
Ну, как и конкретно вот эти операции, если мы ребер не будем удалять, то...
Да, если мы... Да, может когда-нибудь...
Хотя с другой стороны заметим, что у нас ни одного ребра удалено быть не может,
потому что мы классы эквалентности не убиваем.
У нас классы эквалентности может распасться на два.
Сейчас мы до этого дойдем.
То есть классы эквалентности, в котором лежит s0...
Кстати, где он?
Вот, давайте посмотрим на этой картинке.
Где находится...
У меня есть витлянские флешбеки.
Ни фига себе.
Точка.
Это, видимо, там, где переход по символу С есть, куда...
Да.
Да, так вот, мистическое утверждение.
Это и есть классы эквалентности s0.
Почему это было там же несколько?
Так, давайте еще раз.
Значит, мы...
Значит, мы хотим...
Мы попытались найти все переходы, которые нужно сделать в новое состояние С.
То есть для этого нужно...
То есть нам нужно найти все суффиксы С, которые в строке С не встречаются.
Все суффиксы С, это точно все строки, которые не было...
Да.
А что это такое?
Это очевидно суффиксы строки.
То есть на самом деле это надо приписать просто символы С ко всем суффиксам строки С,
которые нельзя продлить на символ С, как под строки строки С.
Да.
Мы делали это так.
Мы перебирали их в порядке убывания с помощью суффиксных ссылок.
Критерии очень простые.
Есть ли переход из вершины по символу С, да или нет.
У нас в С лежат только те строки, которые не было в С, и ровно они.
Да?
Ну да.
Так что вот я утверждаю, что мы ровно это и сделали.
Вот.
Теперь.
И вот мы нашли первую...
Ну ладно, могло так случиться, что мы так дошли до эпсилона и ничего не сделали.
Это такой отдельный случай, когда символ С является новым.
То есть в строке С он вообще не был.
Но тогда заметим, что если мы так до эпсилона, до стартовой вершины и дошли,
то в общем-то все, что нам остается, это из стартовой вершины тоже символ С.
То есть ребро по символу С нарисовать, сказать, что суффиксная ссылка из СС
отправляется в стартовую и больше ничего не делать.
Понятно, да?
Да.
Да.
Ну ладно, если С новый, то да.
Да.
Опять же пользуемся кучей критериев.
Ну да.
Так, к сожалению, тут рассчитывалось, что все утверждения, которые были ранее,
вы уже запомнили и, собственно, себе в душу уже пустили.
Вот.
Так вот.
Но предположим, что нет.
Мы нашли на этом суффиксном пути какую-то вершину, из которой по символу С перешли,
и именно в классе эквалентности именно этой вершины содержится С0.
Теперь возникает вопрос.
А С0 в классе эквалентности С был лонгестом?
Или нет?
Да если был, то ничего делать не надо.
Ну по сути, да.
Ну не совсем.
То есть все, что нам останется, это нарисовать вот эту вот суффиксную ссылку
и на этом остановиться.
Почему?
Потому что мы здесь перебрали суффиксы в порядке убывания.
Как только мы вот здесь наткнулись на первый суффикс,
строке С такой, что этот суффикс плюс С встречался в строке С.
Но, очевидно, дальнейшие суффиксы плюс С тоже будут встречаться в строке С.
Так, мы что, сейчас возвращаемся к доказательству теремы?
Не доказательству, еще раз.
На основе чего мы делаем то, что мы сейчас делаем?
Что мы сейчас вообще проверяем?
Мы добавили?
Ну мы добавили новый класс, то есть мы переходим от строке С к строке СС.
Мы добавили вершину соответствующую классу эквалентности СС.
Вот.
И пытаемся добавить в нее все ребра, которые в нее должны вести.
Потому что из нее ребр вести уже не может точно.
А вот в нее кто-то вести может.
Почему только в нее будут вести ребра?
Нет, почему? Ну не только в нее.
Почему новые ребра будут вести только в нее?
Ну потому, нет, этого я не говорил.
Я просто хочу найти все ребра, которые введут в нее.
Мы это сделали, хорошо.
Да.
Теперь мы говорим так.
Вот мы дошли до этой вершины.
Вот.
Назовем ее, кстати, П.
И из нее есть переход по символу С.
Мы ее назовем Q.
Все.
Тогда теперь говорим.
То есть мы знаем, что Q это класс эквалентности строки С0 в строке С.
Теперь мы говорим.
Почему Q это класс эквалентности С0?
Потому что мы по строке С0 ровно сюда и приходим.
Вот сюда мы приходим в максимальный, приходит максимальный суффикс строки С, из которого есть переход по символу С.
И при этом он в максимальный суффикс.
Потому что все больше приходили.
Да, потому что все больше были здесь.
Вот.
И теперь у нас возникают два случая.
Случай номер раз.
Оказалось, что С0 не просто лежит в этой вершине, а он еще и максимальный в этой вершине.
Он лонгест.
Пусть он лонгест.
Тогда никаких новых состояний, кроме этого, не появится вообще.
То есть лонгесты остались теми же плюс СС.
Вот значит состояние, только одно новое, состояние не поменяется.
Тогда все, что нам останется, это просто сказать, что суффиксная ссылка из СС ведет, собственно, в С0, так или иначе.
И в общем-то все.
Почему все остальное останется грехом?
Потому что остальные состояния не поменялись.
Потому что какие ребра могли быть?
Они могли быть либо между старыми вершинами, а между старыми вершинами новые ребра не появляются.
То есть ребра не появляются и не исчезают.
Потому что классы эквалентности не поменялись.
Классы эквалентности не поменялись.
Мы вот сказали себе так.
Что произошло?
Мы обнаружили, что при переходе от С к СС у нас множество лонгестов поменялось только за счет того, что в него добавился СС.
То есть это означает, что классы эквалентности не поменялись.
То есть поменялись не только в том плане, что добавился класс эквалентности СС, который взял на себя все новые подстроки.
Но тогда ребра между старыми классами эквалентности не появились и не исчезли.
Логично.
Они не могли только поменять.
Ну да.
Мы просто смотрим на те вершины, у которых классы эквалентности могли измениться.
Ну вот.
Ну не совсем.
Ну типа того.
А изменились они только вот у этой вершины новой классы эквалентности, поэтому в связи с этим могли возникнуть новые ребра.
Это нормально быстро обосновать, что для старых классов эквалентности между ними новые ребра не появились.
Так вот так же, как мы и говорили.
Как понять?
Утверждение.
Из класса эквалентности А в класса эквалентности В существует ребро по символу Х тогда и только тогда, когда в классе эквалентности А существует строчка Т, а в строке В существует строчка ТХ.
Ну точнее любой строчки из класса А.
Но это уже другое.
Да, то есть на самом деле это будет и одно и то же, но да.
В первом случае нам может не трудно.
Нет, там дальше будет уже теория о том, что если хоть одна нашлась, то и все подойдут.
А, ну это следует из С.
Это уже из БОТ тоже.
Боже, я просто привыкнуть об этом в теории.
А вот.
А вот надо будет вызвать термин классы эквалентности.
Да.
Окей.
Вот тогда получается, да, что если тут ничего не попилилось, то в общем-то только вот эти штуки добавятся и больше ничего не будет.
Сейчас мы, да, хорошо.
Вот.
Так что да.
Кстати, а давайте сразу еще поймем, а как там в коде будет определить, С0 является логистом в своем классе эквалентности или нет?
С0 является логистом в своем классе эквалентности или нет?
Надо просто проверить.
Мы умеем получать типа.
Да.
От какой суффиксной ссылки?
У нас при переходе в суффиксные ссылки у нас логист заменяется на логист в следующем классе.
Да.
Значит, это логист в следующем классе плюс один.
Но нам нужен не шортест.
Нет, у нас вопрос.
Модуль С0 является ли он логистом?
Ну вот длину логиста Q мы знаем, потому что мы напомним в каждом состоянии, лен храним в явном виде.
Мы знаем длину логиста этого.
То есть мы знаем логист Q, да.
Да, по факту да.
То есть мистическое утверждение.
Так это кодить – это уже просто кодить.
Ну, как сказать, мы же алгоритм понимаем.
То есть алгоритм для нас – это то, что мы можем закодить.
Да.
Вот.
Модуль С0 равно лен от П плюс один.
Буквально.
Да.
Модуль С0 равно лен от П плюс один.
Да.
Что такое П?
Вот это состояние.
То есть тогда все, что нам останется, это проверить.
То есть получается, что С0 логист тогда и только тогда, когда лен от П плюс один равно лен от Q.
Все.
И тогда нам повезло.
Сейчас.
Лена, так, мы знаем длину логистов П.
Угу.
А мы хотим сказать, что мы привыляем к этому логисту справа С.
Сейчас, что мы пытаемся выяснить вообще?
Мы хотим понять, что.
Что из 0 – логист.
Угу.
Что значит он логист вообще?
Ну, то и знать.
По определению, не надо ничего домысливать.
Просто определение, что он длиннейший в своем классе эквивалентности.
Все.
То есть он длиннейший, если его для нас совпадает с длиной длиннейшего в этом классе эквивалентности.
Так, сейчас.
А как мы понимаем?
А, стоп, а мы знаем, что…
Нет, стоп.
Подождите-ка.
Мы знаем длину С0, да?
Да.
Она равна лен от П плюс один.
Ага.
Окей.
Так что это если нам повезло.
А теперь финалочка.
Предположим, что нам не повезло.
Ну, тогда это и есть тот самый случай, когда С0 не был логистом, но резко стал.
Понятно, да?
Угу.
Но это означает, что класс эквалентности распиливается на два.
И тогда в этом месте происходит следующий чит.
Значит, у нас появляется новая вершина.
То есть это была вершина Q старая, а у нас появляется новая вершина, которую мы будем
изменить.
Она и будет равна классам эквалентности С0, но в строке СС.
Угу.
То есть был класс, то есть как бы еще раз.
То есть получается, Q был вот такой класс эквалентности.
Вот.
Где-то здесь была строка С0, и вот неожиданно класс распилился.
То есть это вот, это было Q.
Значит, класс распилился.
Клон распилился.
И теперь у нас есть клон.
Во.
Вот.
Значит, почему это клон?
Ну, потому что действительно, потому что на самом деле много информации из нее нужно скопировать.
Потому что, во-первых, заметим, что все переходы из Q нужно торжественно скопировать в клон.
Ну, потому что мы знаем, что, например, вот был переход из Q по символу A.
То есть мы знаем, что если ко всем этим строчкам приписать A, то мы отправляемся в какое-то одно состояние.
Но заметим, что мы-то теперь, да, класс распался, но мы-то все равно при этом переходе отправляемся в одно состояние, правда?
Вот.
Поэтому это означает, что переходы, значит, мы, получается, вот эти все переходы тупо копируем.
Более того, суффиксную ссылку, кстати, мы тоже копируем.
Потому что вот была у него какая-то суффиксная ссылка.
Вот куда-нибудь дальше, вот сюда.
Вот сюда, да.
Тогда теперь заметим, что из клона она будет показывать ровно туда же.
А вот из Q ее теперь надо перенаправить.
То есть как бы условно.
То есть если тут есть какая-то суффиксная ссылка в какой-нибудь там что-нибудь еще,
то мы, значит, объявляем, что у нас этой суффиксной ссылки больше нет.
То есть в нее ведет суффиксная ссылка из клона, а вот из Q и из Q теперь суффиксная ссылка ведет в клон.
Кстати, из SC у нас теперь суффиксная ссылка.
Тоже ведет не в Q, боже упаси, а в клон.
Понятно, да?
Еще раз, какие суффиксные ссылки поменялись?
Из Q мы перенаправили в клона, а из клона в суффиксную ссылку.
Да, в то, что была суффиксная ссылка раньше.
И все.
А, ну и SC еще отправили суффиксную ссылку в клон.
Ну это да.
Итак, мы разобрались со суффиксными ссылками, и мы разобрались с переходами из Q.
Но мы и не разобрались с переходами в Q.
А ведь действительно, смотрите, раньше у нас был какой-то переход из состояния, там я не знаю, господи, букв у меня уже нет, поэтому Вася в состояние Q, да?
По символу, ну видимо, С.
Да, тут уж точно переход был по символу, С без вариантов.
Но теперь внимание, вопрос.
Куда теперь вести переход?
То есть мы сюда вели переход, потому что тут все строчки у нас ведут куда-то, то есть если я возьму произвольную строчку из Вася и припишу к ЕС, то я получу какую-то строчку здесь.
Внимание, вопрос.
Я получу строчку из верхней части или из нижней?
Ну кажется, нужно сравнить Лен.
Ну да, для Вася, конечно, надо сравнить Лен, прибавить 1 и сравнить с длиной С0.
Но по-хорошему мы теперь должны найти просто, найти всех Вась, у которых этот переход ведет с длиной не более чем С0, и у всех их этот символ С торжественно перенаправить в клона.
Как я это сделаю?
Ну я знаю самую длинную строчку, из которой нужно перенаправить символ С.
То есть надо найти самую длинную, а потом просто отсекать по одному символу.
И эта самая длинная строчка, это, извините, вот лонгест от П.
Смотрите, это самая длинная строчка, у которой этот переход по символу С поменялся.
Потому что если была более длинная, то она окажется в классе эквивалентности не клона, а вот старого К, то есть вот этой вот верхней части.
Поэтому идея оказывается неожиданно тупой.
Мы продолжаем идти по суффиксным ссылкам до тех пор, пока у нас символ С, пока у нас переход по символу С ведет в К.
И пока мы вот так идем, мы идем, идем, идем, мы отпиливаем, то есть убираем эти переходы, но мы их не убираем, а заменяем.
И вот этот переход, ой, не туда, на вот сюда, вот сюда, вот сюда, по С.
Вот так мы идем до тех пор, пока мы не наткнемся на какую-нибудь вершину, из которой переход по символу С ведет еще куда-то.
Чего?
А, сейчас.
А, ну вот, я вам даже еще и скажу, куда он ведет. Знаете куда? Вот сюда он ведет, вот в эту суффиксную ссылку, кстати.
Я вас так обрадую немножко.
Да ладно.
Нет, я знаю, что там было по равной НП, но чтобы вот это.
Ну, то есть вот начиная с этого момента, мы перебираем, продолжаем перебирать, напомню, суффиксы строки С, из которых мы по символу С приходили в символ Q, вот именно в состояние Q.
Вот все эти, из всех этих суффиксов мы переводим стрелочки в клон. Ну типа состояние распалось, поэтому вот переходим.
Откуда могли взяться более ранние суффиксы, более большие?
Ну, элементарно, ну, более большие могли, ну, они взялись просто, они вполне могли взяться из, по-видимому, просто другой, просто другой веточки.
Вот так вот как-то это было.
Почему у нас две суффиксные ссылки разные?
Две суффиксные ссылки могут вести в одну и ту же вершину, это нормально.
Вот, то есть тут как-то так вот было.
Да, но те, которые были раньше, во-первых, мы не знаем, где они, а во-вторых, нам их и не надо трогать.
То есть, поэтому у них переходы сюда остаются.
А начиная с этого момента, мы как бы перегоняем в клон.
Да.
Вот.
Так что получается такая красота.
Ну, обратите внимание, видите, мы так идем-идем, переходы вели в Ку и там и клон.
Но очевидно, что тогда получается первый переход по Ц, который ведет не туда, он, конечно же, ведет просто в суффиксную ссылку Ку.
Ну, потому что я сейчас смотрю классы эквивалентности вот этих вершин, к которым припишусь.
Которые не могут перескочить, видите, вести в суффиксную ссылку от суффиксной ссылки.
Нет.
Так вот, последуете.
Когда ты бежишь вот по этому пути, у тебя есть какие-то строчки, каждый из которых это предыдущие минус-символы.
То есть, какие-то.
То есть, последовательно, классы эквивалентности по суффиксной ссылке.
Но там не минус-символы.
Ну, минус-символы.
Нет.
Ну, скажем так, ты перебираешь все вот эти строчки.
Просто ты их перебираешь не по одной, а скачешь.
Да.
То есть, ты прямо вот скачешь по вот этим вот отсечкам.
Но тогда, если ты ко всем им припишешь по символу С, то значит, ты будешь получать.
То есть, каждый блок перейдет в один блок, другой просто несколько блоков могут перейти в единый блок.
Вот, понятно, да?
Вот.
Но более, да.
Но эти блоки как бы тоже будут.
Но тогда эти блоки тоже являются тоже последовательностью строчек.
Строчек каждый следующий является предыдущий без первого символа.
И как следствие, то есть, суффиксная ссылка у них идет ровно подряд.
Потому что это буквально та же последовательность.
Такая же.
Такого же рода.
Ну, то есть, тут мы не будем проверять, что это переход ведет так.
Хотя можно в качестве ассерта в коде поставить, чтобы понять, что вы правильно понимаете, что происходит.
Но на самом деле это не надо.
То есть, вам нужно просто перебирать все состояния, из которых ведет переход по символу Q.
Но там либо вы дойдете до Эпсилона.
Либо вы там попытаетесь выброситься из Эпсилона.
И тогда скажете, что все, на этом все.
Тогда из нее переводите переходы, наклоны.
Вот.
Либо находите вершину, в которой переход по символу C ведет не в Q.
Тогда вы говорите, что на этом мы останавливаемся.
То есть, на этом все, с вами были, подписывайтесь.
И как бы ноты.
И алгоритм окончен.
То есть, как вы уже можете себе вообразить код.
Вот чем это приятно относительно суффиксного дерева.
Код здесь прям муа.
Потому что что вы делаете?
Потому что все, что вам нужно, храним автомат, храним суффиксные ссылки, все лены.
Значит, и храним последнее состояние.
Вот это S.
Алгоритм звучит так.
То есть, создаем новое состояние с C.
И, говорим, скачем по суффиксным ссылкам, пока отсюда, пока нет перехода по символу C.
Мы его создаем, перегоняем в эту вершину.
И вот мы нашли первый переход по символу C.
Ладно, если мы его так и не нашли, то больше ничего не делаем.
Так.
А, дальше алгоритм уже понятен, не надо обсуждать, да?
Ну вот, дальше говорим.
То есть, дальше говорим, приходим в эту вершину P.
Переходим по символу C Q.
Если LEN от P плюс 1 равно LEN от Q, то просто тупо объявляем, что суффиксная ссылка из S C идет в Q и больше ничего не делаем.
Ну, точнее, сохраняем, что последнее состояние теперь с C.
Если LEN от P плюс 1 меньше, чем LEN от Q, то мы создаем новую вершину клон, в котором копируем из Q суффиксную ссылку и переходы.
Что мы потом делаем?
Значит, потом объявляем, что суффиксная ссылка из Q ведет в клона, суффиксная ссылка из S C ведет в клона.
Я говорю, у вас устроено любое задвинание по черной магии.
Вы произносите какой-то набор букв длиной 10 или 15, и у вас стол превращается в козла и вылетает в окно.
И что это к чему?
То же самое.
Мы пишем какой-то набор букв длиной 10 или 15, и у вас стол превращается в козла.
Только мы перед этим уже 3 часа вроде понимали, откуда это заклинание берется.
Да, то есть мы уже не от балды пишем заклинание.
То есть не как там на лекциях часто бывает.
Суффиксный автомат, это вообще вот такая штука, как он строится.
Вот вам код, значит вот заклинание, оно работает за линию, может даже доказать, что оно работает за линию.
Почему оно работает, но это надо 3 часа разбираться.
Давайте лучше задачи порешаем.
Это не код, а бинарник просто.
Бинарник?
Бинарник?
Нет, бинарник нет, обычно вам все-таки код.
На Олимпиаде вам все-таки код дадут, а не бинарник.
На Олимпиаде дадут суффиксный автомат?
Конечно.
На студенческой?
Да.
Код суффиксного автомата?
Нет, код вам на самой Олимпиаде код вам не дадут.
Но задачи на суффиксный автомат дадут?
Дадут, дадут, бывает их там хорошее количество.
Это ладно, это понятно.
Когда?
Каждый раз, когда Филип Гриб выгоняет задачи на Олимпиад,
мы на все росты сегодня не пускаем.
Ну на все росты да, но вы уже в студенческом возрасте.
В студенческом возрасте суффиксный автомат это еще хорошо.
Вам могут и на суффиксное дерево задачи дать.
Судеева же проще.
Нет.
Идея надо, кодик нет.
А кодик никому не надо.
Ты просто суфмасс строишь и все, вот тебе судей.
Ну или так.
А потом вам скажут НЛогНТЛ, до свидания.
НЛогНТЛ не отсветит.
Нет, он работает за НЛогН, к сожалению.
Так, ладно, ребят, ребят, ребят.
Так, ребят, чтоб не зависать, потому что мы, к сожалению,
могло показаться, что мы уже победили, но еще нет.
У нас осталось маленькое мелочи.
Нам надо доказать, что это алкогитм работает за линию.
Высота дерева в ссылку уменьшается.
Нет, а что мы тут делаем?
Мы каждый раз добавляем в какое-то регулирование.
Нет, нет, нет, нет.
Если бы, если бы не одно, но вот в этом плохом случае
мы перенаправляем уже имеющиеся старые рембры.
Нет, ну да.
Нет, ну вот да, понимаете, да.
Положим монетку.
Нет, нет, но на самом деле, так что фактически нам желательно,
но тут на самом деле работает, но на самом деле тут тоже
уже третье сходство с деревом полиндрома.
Потому что фактически давайте заведем указатель.
Указатель на суффиксную ссылку.
Нет, хуже, на две суффиксные ссылки.
Ну, точнее так, ну вот.
То есть условно говоря, да, надо, то есть нам нужно,
хочется завести три указателя.
На себя, на суффиксную ссылку и на суффиксную ссылку суффиксной ссылки.
Вот, понятно, да?
Так вот, теперь идея такая.
Когда, значит, первая ссылка, ну первая указатель понятно,
куда переходит, прямо сюда, видите, да?
Вот эти две, теперь когда мы вот скачем тут, перегоняем символы С,
мы их просто тут вот эти два указателя скачут, скачут, скачут,
часто скачут, скачут и приходят вот сюда и вот сюда.
Видно, да?
После этого P переходит, ну, либо в Q, либо если не повезет,
вот в этого клона, да?
Ну, а это не важно, потому что что делает теперь вот этот указатель?
Ну, если P перешел в Q, ну ладно, а он делает все равно то же самое.
Он скачет дальше, пока вот это символ строки С, пока идут в Q,
он идет, идет, идет, потом наконец доходит до этой вершины
и переходит по ней вот во вторую ссылку.
Да, а вот теперь мы, да, то есть мы для линейности этим пользуемся.
То есть получается, что у нас три указателя,
ладно, один указатель тупой, неинтересно, а остальные что делают?
Остальные на каждом шаге скачут по суффиксной ссылке,
тем самым уменьшая свой лен, а потом проходят по переходу
и обратите внимание, каждый раз, когда мы проходим по переходу,
лен увеличивается ровно на один.
Да, ну, это не всегда, кстати, верно, что если вы перейдете по переходу,
то лен у вас увеличится ровно на один, вот ровно из-за этого у нас клон тут и возник.
Но конкретно в наших этих указателях так будет всегда,
то есть когда вы перейдете по символу, то лен увеличится ровно на один.
Но отсюда и следует, что каждый указатель делает не более чем n
суммарно скачков по суффиксной ссылке.
Еще раз, какие указатели?
Значит, указатели.
Указатель указывает на саму вершину f, на ее суффиксную ссылку
и на суффиксную ссылку суффиксной ссылки.
Эки, в принципе, то есть на самом деле скачками указателей можно описать весь алгоритм.
Потому что можно сказать, что сначала вот эта стрелочка переходит вот сюда.
Далее, мы скачем вот этим указателем, мы скачем вот этим…
Вот Tonya, как мы скачем скачем и вот наконец доходим до вершины p
ссылки и из вершины p мы переходим либо в q, либо в klon. Причем, когда мы перескочили
что в q, что в klon, len от этого указателя увеличился ровно на 1. То переча. Теперь остается только
найти, остаются только вот эти переходы. Но оказывается, это так же, как вы просто скачете,
скачете, скачете по суффиксным ссылкам, доходите до этой вершины, ну, у которой есть переход по
символу c куда-то не в q, и переходите по этому переходу. Вот. То есть вот такой вот указатель.
То есть я бы в принципе мог, то есть на самом деле, если бы я вам показывал старую презентацию. Вот.
Ну вот она, кстати, есть, да. Вот. Но там расстрел. Вот. Там потому что нет картинок,
там только буквы. Много букв. Очень много букв, много утверждений. Да. Вот. То я бы там сказал,
что докажем методом потенциалов. Потенциал для нас суффиксного пути из конечной вершины.
Потому что заметим следующее, что, ну, там утверждение такое, что если вы возьмете какую-то
вершину, у нее есть какой-то суффиксный путь. Если вы перейдете из нее по переходу, то суффиксный
путь будет не более, чем предыдущий суффиксный путь плюс один, а может и меньше. Понятно, да?
Так вот, здесь ровно вот этим методом мы говорим, что мы работаем, ну, реальное время работы это вот
от длины вот этого отрезка суффиксного пути. Правда? Но теперь заметим, что суффиксный путь для
СС, он будет как вот эта длина плюс один, то есть она будет не более, чем длина вот этого пути плюс
один. Правда, минус вот этот кусочек и плюс два. Вот, то есть как бы, ну да, ну, знаете, как это,
то есть как это говорить, это программа «Модный приговор». В нашей программе мы выбросим на
помойку весь гардероб этой женщины, а взамен подарим одно платье. Так вот, мы круче, мы подарим
два. Вот, возможно даже разных. Правда, одно из них уже копия другого, но, соответственно.
Так, и вопрос, а где лог? Лог? В алфавите. Если алфавит константа, то поздравляю, мы доказали,
что алгоритм работает за линию. Лог возникает, лог будет возникает, видимо, только в том месте,
что, как бы, что, ну, вопрос, как вы, то есть, допустим, задача, у вас есть вершина, вам нужно
найти переход по букве, по букве «П», там, ладно, по букве «Д». Нет, ну, мы же без хэша и работаем.
Потому что хэш — это какая-то странная подхачка, какая-то то ли вероятность,
то ли вредная подхачка. Вот так. Да, вероятность, но вредная подхачку.
Нет, стоп. Если вы хотите сказать, что с хэшами, мы можем делать сортировку за НЛГ, за заян. Ну, с хэшами.
Ну, на хэш-мапе. Ну, что? А как ты упал, сейчас?
Нет, ну, а что? Нет, с хэшами, ну, нет, ну, ладно, нет, ну, смотрите. Нет, ну, там, смотрите,
что происходит. На самом деле, допустим, нет, там просто ситуация. Сейчас. Там просто утверждение такое,
допустим, у вас есть хэш-мап или что-то другое, какая-то мистическая структура данных,
которая позволяет вам по каждому состоянию каждой букве за 1 понять, есть ли переход, если да, то куда.
Так вот, утверждение. За N плюс размер алфавита, в принципе, даже если он N, можно, то есть,
сейчас, нет, за N ли? Хотя нет. Сейчас, ну да, нет, если у вас есть хэш, ну вот, сейчас. Ну да, в принципе,
если у нас алфавита, то есть, по идее, конечно, если у вас есть алфавит, если у вас есть это,
то вы, в принципе, можете все пасуть. Ладно, это ничего не доказывает, правда. Нет, ну, с хэшами нет, сейчас.
Нет, ну как хэш, тут как бы не хэш, тут проблема бывает в другом. Представим себе, что символами
алфавита являются камешки, которые мы умеем только сравнивать, но, слава богу, не только на равенство,
но еще и на меньше больше. Хотя, в принципе, вот этот алфавит, в общем, с хэш-мапом может и на меньше
будет, и на тупо равенство работать. Но, правда, тут в предположении, что есть не только равенство,
есть какой-то там, какой-то супер хэш-мап, который, скорее всего, не существует в природе. Вот. Ну,
идеального, по крайней мере. Вот. Но, допустим, мы их, если бы их умели сравнивать, ну вот, то как бы,
да, теоретически, да, хотя, да, теоретически мог быть риск, что по-существному, ну, сформулируем так.
Или не сформулируем. Ну, ладно. Хотя, нет, вот получается, ладно, существный автомат, видимо,
иногда не получится. Потому что вот по суффиксному массиву, да, когда суффиксный массив – это есть сартировка, ладно,
суффиксный автомат – сартировки не подразумевают. Нет. Да, закладывает. Потому что вы должны,
потому что как строить суффиксный автомат по суффиксному, то есть суффиксный массив по суффиксному автомату?
Вы должны из каждой вершины переходить по всем символам в порядке возрастания. Ну, по большому счету,
как построить суффиксный массив за квадрат? Как бы это, тупо идем TFS без юзидов по всем вершинам.
Наткнулись там, прошли по символу, значит, записали символ в конец. Вернулись обратно, символ убрали.
Зашли в терминальную вершину, написали новый суффиксный массив. Это работает за квадрат,
в качестве упражнения придумайте как-то допилить за линию. То есть вот как-то так.
Вот. Но для этого вам пришлось бы в каждой вершине символы реально отсортировать.
Поэтому вот там локо возникает.
