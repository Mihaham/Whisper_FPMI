Да, в общем, всем привет. Сегодня, извините, приведу я. На повестке дня набор формул,
это, наверное, самая стабильная часть. Немного про ссылки, ну и про теория. Там побольше,
например, показываю. Да, в общем, набор формул уже третьей части. В общем, обычно при наборе
выключено формул. Ну, в общем, самым простым, что можно делать, использовать такую аннотацию.
Вот, еще можно двумя значками доллара, но это все такой немного старый стиль. И,
ну, наверное, в самом противном случае, конечно, можно вот так использовать,
но есть несколько проблем, например, как нам решить вопрос с номерацией формул или
с многосрочной формулой. Вот. Ну, придумали окружение equation. Ну, она вроде стандартная.
И в основном преущество она дает возможность идти на номерацию. И вообще, в общем, если писать
формулы тоже в виде окружения, то весь код будет выглядеть более структурно, потому что как только
начинает писать на лотехе что-то длиннее, чем там 100 строк, то уже сильно важно, чтобы это
выглядело аккуратно не только снаружи, но и сам код выглядел аккуратно, поэтому какое-то
единобразие и аккуратное формление достаточно важно. Ну, вот, например, если все использовать
в окружении, кто-то будет выглядеть аккуратно. Но equation еще не самое лучшее решение. Вот. Да,
но оно дает номерацию. Номерация привязана к секциям, если мы говорим в article. В книгах с
главами она начинается просто заново. Это все настройки по умолчанию, и, конечно же, их можно
перенастраивать. Вот. Но об этом тоже будет позже не сказано. Это уже такая большая портаж. Уже куда
более хороших способ писать выключенную формулу, это aligning в окружении. Aligning позволяет набирать
во-первых, много строк в одну формулу, во-вторых, делать в равном. Например, когда вы переносите длину
цепочку равности, может быть аккуратно выровнять первое равно в строчке. Вот. Ну или когда вы просто
пишете какое-то большое количество похожих уравнений. В общем, выравнивание по какому-то знаковому
типу равенства или неравенства может быть очень приятно украсить то, что происходит. Вот. Ну,
в общем, вот пример как это использовать. И aligning – это уже такой канонический способ писать
уравнения, потому что он, если все уравнения писать aligning, то их можно делать как однострочные,
так и многострочные, как с нумерацией, так и без нумерации. В общем, оно развязывает руки и
вызывает не задумываться лишний раз. Однако для каких-то конкретных целей может быть удобно какое-то
свое окружение. Например, правда может быть удобно окружение Multiline. Его особенность – оно
выравнивает первую строчку по правому краю, последнюю по правому, и все, что между как-то
по центру выровнено. Это нужно для писания очень длинных формул, и это может выглядеть лучше,
чем просто aligning. Вот. Про остальные не вижу смысла говорить подробно. Это уже такие специфичные
случаи. И, в принципе, про них можно прочитать. Вот ссылочка будет. Ну или загуглите. Да, вот. Я
уже говорил, что aligning можно использовать и без нумерации. Для этого нужно добавить звездочку.
Это работает не только с aligning, например, с cohesion, с multiline, gather и всеми этими. Тоже
так можно делать. Вот если вам почему-то не нужно нумеровать. Есть очень хитрый
macros. Я его не ставил в ориентацию, но, наверное, просто вправлю в чат в программе,
который позволяет включить умную номерацию формул. Чуть позднее объясню, что это значит.
Вот. Ну и такое немного экзотическое случая. Когда мы хотим как-то по-своему поместить формулу,
по-моему, один раз в жизни не пригодилось. В общем, есть команда tag. Там может быть любой
символ. Можно подместить звездочкой, там еще каким-то символом, словом. Вот. Ну вот. Но это
редкое использование. Уже более экзотически. Следующая проблема, с которой можно столкнуться при
наборе формул, это система уравнения. И для этого тоже есть такой стандартное решение окружения
cases. В общем, это математическое окружение. Это как обычное окружение, только уже внутри математического
мода. Ну, математического режима. И, в принципе, если правильно помню, это можно использовать не
только в выключенных формулах, но это... Не вижу особого смысла использовать окружение типа... Ну,
любые внутриформульные окружения в строчных формулах, потому что они все-таки в несколько
строк, и это портит структуру самих строк. Все-таки для этого лучше использовать выключенные формулы.
Ну вот. В общем, стандартный пример это система уравнений. Сколько угодно большая может быть. Ну,
в принципе, вот еще есть аналог окружения cases, это aligned. Он позволяет, как обычный aligned,
только, в общем, это внутриформульное окружение, позволяет там также уравнивать, как обычный
aligned, только уже внутри. Да, еще, наверное, самый популярный пример, все-таки, это набор матриц.
И есть, опять-таки, стандартное решение. Вот матриц. Оно может быть B-matrix. Это, значит,
обычные скобки. Может быть, B-matrix. Ну, первая буква B, это будут квадратные скобки. Может быть,
просто матриц, когда скобок вообще не будет. Ну, в общем, это все... Ну, там есть много вариантов,
можно просто погуглить. В общем, при наборе матриц. Ну, в общем, вот так можно брать матрицы.
Так, B-matrix. В общем, это пройдет и с обычной матрицей. Здесь B-matrix с обычной матрицей. Вот такая
классическая запись матрицы, квадратная матрица NN, может быть проверена с помощью C-dots,
V-dots и D-dots. В общем, диагональные. В общем, вертикально-диагональные горизонтальные точки.
В общем, в самом деле, это, наверное, ну, в общем, вот такой пример, как можно набирать матрицы.
Есть еще такой пакет Nice-matrix. Там, в общем, люди заморочились и придумали очень-очень-очень
хороший функционал для написания различных матриц, блочных, вообще, каких-то очень-очень
экзотического содержания. Там выделение под матриц. И на самом деле он очень, очень, они очень
хорошо это сделали. Очень просто все это написано. Очень легко этим пользоваться. И, самое главное,
там очень понятная инструкция, что делать. Там хорошие примеры. И на самом деле можно,
просто листая инструкцию, увидеть то, что нужно. И там будет написано, как это сделать, и пояснение,
как расширить. В общем, очень хорошее. Очень хороший пакет рекомендую. Вы можете посмотреть.
Я вот, когда столкнулся с потребностью, когда мне нужно было много матриц в своем документе
использовать, в общем, я столкнулся с проблемой, как это сделать все аккуратно. И, в общем,
смотри их с хороших. Да, следующий раздел сегодня. Ссылки.
Могут быть внутренние ссылки. Это, например, ссылки на формулы. Вообще ссылаться можно на все,
что, все угодно, что иметь на вирации. Будь то раздел, будь то теоремы, которые уже упоминали,
будь то таблицы, картинки, иллюстрации, разделы. В общем, все, что имеет на вирации,
можно ссылаться. Чтобы ссылаться, нужна, в общем, нужна команда label, аргументом,
где вы передаете название ссылки. И потом, с помощью ref вы можете
сослаться на эту ссылку. И будет, ну, в бульклорной версии, конечно, будет работать,
будет работать ссылочная система. В плане, что, если вы нажмете, ну, гиперсылка, в общем,
если вы нажмете, то вас перекинет к тому месту, на что вы ссылаетесь. И вот, например, вот эта вот
штука кликабельная, если я нажму на, в общем, вот, как здесь есть закон вируса, нажимаю сюда и нас
подкидывает на этот слайд. К этой формуле. Также с помощью page.gf можно указать не только саму, ну,
то есть не только, не только ссылку на саму формулу, но и на страницу, где это искать. И когда у вас,
если вы делаете какой-то большой конспект на десятки или больше страниц, и когда у вас там формулу
тоже уже перевались за сотню, ну, во-первых, обычно нумерация формул все-таки идет, ну, в общем,
какие-то циферками, а не вот такими вот пояснениями. И чтобы в этом все не запутаться, очень удобно,
во-первых, давать какие-то смысленные названия своими формулами, и во-вторых, вот на них,
при ссылках на них можно указывать страницу. Хотя, опять-таки, большинство PDF-ридеров уже
поддерживают ссылки, но не все. В общем, иногда ссылки могут не работать, поэтому, в принципе,
логично оставлять номер страницы, который находится. Ну, или там, если вы делаете книжку,
то это вообще must-have, я считаю, потому что когда в книжке непросто указание на формулу,
на очень многих страницах искать, это очень удобно. Да, в общем, код седьмого слайда немного
модернизировал, вот, добавил просто команду label, и теперь на нем можно ссылаться. Я на том же
слайде упомянул про возможность умыть ссылок. В общем, тот macros позволяет что делать? Вы просто
пишете все, просто пишете обычные все формулы без звездочки, и нумируются только те формулы,
на которые вы ссылаетесь. То есть, обычно какая проблема? Ну, какая дерема стоит у людей,
которые пишут? Ну, если вы пишете много формул, вы же не на все будете ссылаться. И иногда вот эта
номерация, там, очень-очень большая номерация может, в общем, путать, и, в общем, она излишняя
информация и неприятна. И вот этот macros позволяет, в общем, весьма эрегантно эту проблему решить,
то, что номера будут являться в такую тех-формулу, на которую вы ссылаетесь. Что, в принципе,
логично. Что-то такое удобное решение. Ну, еще немного про культуру самого теха. Чтобы не запутаться,
в общем, очень рекомендовано начинать с ссылки на уравнение с такого префикса, вот, как
equation 2.0, на всякие плавающие, ну, на окружение feature с fig, ну и так далее. На самом деле можно,
это как бы никак не зарезервировано, это просто, в общем, так принято такой стиль, можно на скит
свои окружения, свои ссылки делать. Поэтому, как бы, так только будет лучше, чтобы не запутаться в них.
Так, про это вроде все. Да, ну, ссылки, конечно, можно делать и на какие-то внешние ресурсы,
например, на сайта. Если нажать на эту ссылку, то откроется сайт Google. Вот так это можно делать.
И, в принципе, в принципе, тут больше даже нечего добавить. Да, я не знаю, показываю,
было ли, не помню, было ли просто в презентациях именно сноски. Вот, в общем,
ну, сноски, чтобы сделать сноску, нужно просто в нужном месте вставить footnotes и дальше текст
сноски, и появится номер сноски и сама сноска. На сноске, как и на все, что номируется, также
можно ссылаться. Например, ну, также нужно оставить где-то внутри сноски команда label и дальше
с помощью ref уже в ситуации. Вроде есть команда footref, вот, но это она либо есть в
консистентахном окружении, либо в консистентахном приезде, либо в каком-то дополнительном,
но это все так можно играть. В общем, все эти добавления, как там было ecref, figref, footref,
это все просто про, вот, например, на предыдущем слайде, ecref, он вместо просто номера обернул его
в скобочки, поэтому он принят, чтобы каждый раз не писать скобочки, обычно принято писать
номерацию формул в скобочках, и, в общем, именно ecref позволяет не просто номер формул, а номер
формул в скобочках. Figref вроде ничего, вроде по умолчанию ничего не меняет, но тоже можно
как-то его отдельно настроить. В общем, figref, ecref, можно по-своему настраивать ссылки, например,
ваш объект, если вы делаете какое-то окружение, у него будет номерация, вы будете в него ссылаться,
и вы можете сделать свою собственную на него ссылку, чтобы она как-то по-особому оформлялась,
например, как sm. Ну, добавить sm, ну или, например, для ссылок на страницу можно добавить sm.str,
ну, то есть sm.str, точка номер страницы. Так, да, дальше про теоремы. В общем, пакет amsm,
в общем, вот здесь в посылке есть мануал, самлеч короткий, и там, помимо того, что написано,
ну, то есть там очень короткое, но достаточно подробно написано про все, что можно делать с
расширением, ну, с теорем стайлу, и там также написано, например, популярные ошибки, то есть
почему полезно, например, иногда посчитать мануал, там очень часто написаны какие-то неочевидные
факты, как не нужно делать, потому что, вот, например, как они пишут known problems, в общем,
как не нужно делать, потому что, скорее всего, это вызовет ошибку. В общем, они не знают,
как это исправить, и поэтому рекомендуют так не делать. Вот, обычно какие-то экзотические
случаи, которые просто набираются в каких-то, в общем, очень экзотических ситуациях. В общем,
основной посыл amsm, ну, в общем, этого amsm, это работа с теоремами, в общем, с таким, с такой
преподавшей математической информации, как вот эти теоремы, лемы, утверждение, определение,
в общем, если читали какие-то математические книжки, там очень часто вообще нет просто текста,
там обычно просто набор всяких утверждений, лемы, пояснения, примеры, ну, в общем, так вот по кругу.
Да, ну, в общем, например, в презентации замечание выглядит вот такой, ну, вот, оно,
в презентации оно даже вот так немного выкидывает, ну, в общем, немного выдаётся вперёд даже стене,
вот там замечание, теорема тоже. Да, к слову, я тоже не видел в прошлых презентациях, если вы хотите
делать обычные кавычки, можете, ну, в общем, обычные кавычки, ёлочки делаются, вот, буквально,
меньше-меньше-больше-больше. Вот, всё-таки ближе к делу. Про термсталов, в общем, есть три типа,
ну, в общем, вот три типа, и разница лишь в том, как выглядит само название, то есть там слово
замечание, слово дополнение, ну, и в каком формате там курсивум, некурсивум, набранный текст.
Ну, вот, вот так можно создать своё окружение, ну, без нумерации, потому что со звёдочкой,
и, ну, вот, а с нумерацией, чтобы делать окружение с нумерацией, нужно, ну, точнее, не нужно, в общем,
ему можно делать просто с нумерацией, а можно ещё указывать зависимость. Как я помню, я говорил,
что, например, формулы начинают нумерироваться заново с новой секцией, точнее, они зависят, ну да,
то есть они зависят от номера секции. Также можно выстраивать иерархию нумерации в теоремах. Ну,
в теоремах обычно называют вот это любое окружение, типа утверждение, замечание,
определение, та же теорема. Вот, и, в общем, вот так можно выстраивать иерархию между теоремами.
Ну, давайте дальше уже я покажу больше на каких-то примерах.
Презентация, мы остановились на том, как можно сделать
на вспоминатель. Вот я их сделал и допустим.
Да, в общем, если я начну, например, новую секцию, секция, то, да, в общем, теорема будет
нумероваться вместе с номером секции, а вспоминатель LEM будет относиться к теореме. И если я
делаю еще одну вспоминатель LEM, например, то это будет 1.1.2. А если я сделаю новую теорему и после
нее вспоминатель LEM. Ну, в общем, принцип, видимо, ну, принцип, думаю, понятен. Ну, и каждый из них можно,
конечно же, делать ссылку. Например, main.crm1. Ну, где-то здесь можно на нее сослот. Да, в общем, и вот
это ссылка работает, то есть она кликабельная и, ну, как-то так. Также в теоремах, ну, именно в стиле plane
можно делать помещение или не обязательно аргументы. Например, теорема кого? Например, теорема
lagrm. И тогда это будет в скобочках другим текстом, точка сдвинется. Вот, ну, в общем, или там LEM,
или там вспоминатель LEM отрезутся. В общем, вот так можно делать именные LEM. Еще отмечу вот такую
фишку. Если указать необязательные параметры, ну, вот мы указывали обязательные параметры
в скобках квадратных в конце, после всех обязательных, тогда он говорит, что мы наследуем
нумерацию того объекта, который был этим параметром. Если мы укажем его сразу после названия теоремы,
там, main.theorem, sub.theorem, то это будет не наследование счетчика. Ну, то есть при
приписании нового счетчика начинает сьединиться к тому, который здесь. А это будет означать,
что эти среды делит общий счетчик, у них нумерация, как бы, единая. То есть будет теорема 1, потом LEM
2, потом LEM 3, потом теорема 4. Да, это может быть полезно, когда у вас есть две сущности,
на самом деле, одного рода, просто которые чуть-чуть по-другому называются, чуть-чуть по-разному
называются. Да, в общем, да, хорошее замечание. Спасибо. Ну, это, наверное, основное про создание
своих дотов, это, наверное, все, что нужно. Это, наверное, максимум, который можно сделать уже
с имеющейся theorem style. Потом расскажем про создание своего стиле theorem. И еще немного
идет здесь доказательства. В общем, доказательств тоже есть несколько. Да, в общем, доказательства
есть с нескольких особенностей. В общем, обычно как называют, как обычно выглядит доказательство.
Оно, как и полагается любому, так, ой, полагается любому доказательству, оно заканчивается на,
заканчивается квадратиком. И этот квадратик, в общем, по-английски, что-то да, это CAD. Вот,
ну и в общем, это, оно заканчивается символом CAD Symbol. И, например, можно, ну, теперь немного
фишек про доказательства. Во-первых, можно изменить само доказательство, например, очень часто может
быть, в общем, когда вы доказываете что-то, в две стороны может быть, ну, как это обычно, доказательство
делится на две части, в одну сторону и в другую, то есть необходимость и достаточность. И удобно
разделить доказательство так вот, то есть, если вы пишите не Laughing out loud ну, точнее, да,
не обязательный аргумент у... AO, у доказательства меняется мой словок доказательства, и
когда вы доказываете какой-то факт или, там, в общем, вот, необходимость или,
там, какой-то типа, ассоциатив, в общем, когда вы доказываете какое-то свойство
или, в общем, какое-то короткое описание для доказательства есть, в общем,
в общем, очень разумно его так разместить. Дальше, этот значок называется, как я уже говорил,
cat.symbol и по идее можно его переназначить на какой-то свой символ.
Сейчас, вроде так должно сработать. Да, теперь, догадались, это будет
заканчивать с крестиком. То есть, это умножение, на самом деле. Тут вместо этого может быть что угодно.
По-моему, бриллиант есть или как-то так. Нет, в общем, будем заканчивать с крестиком.
Ну, в общем, можете, если вы считаете, можете как-то в свое знаменовать окончание доказательства,
вернусь к стандартному. Когда вы пишете, допущая, у вас доказательства заканчиваются,
вот, заканчиваете какую-то формулу и квадрат уехать вниз. И для этого думали команду get here,
которая, в общем, заканчивается внутри формулы.
Пошло неплохо. Сейчас. Видимо, наступается просто кет.
В общем, было какое-то типа кет, который, в общем, так, ладно, я шумчат как это сделать,
чтобы сейчас времени. В общем, значком доказательства можно немного манипулировать,
как оно располагается. Это все опять такие вопросы эстетства. Основное, что можно сделать,
в общем, не забывайте, что там будет квадратик. Это все, что я хотел сказать. Есть какие-то вопросы?
Примеры.
Так, хорошо. Дайн, это здесь? Это, видимо, здесь? Кажется, вопросов нет, поэтому я могу подключиться,
добавить что-то от себя по темам, которые сегодня хотелось рассказать. Нужно попасть в минуту,
чтобы подготовиться, сейчас все будет. Так, ну, идем тогда, я прощаюсь и передаю финальное
словодание. И вот, что хотелось бы добавить про создание окружений и про счетчики. Это то,
что было анонсировано еще в прошлый раз и, в общем, связано между собой тема счетчиков. Это способ
создавать числовые переменные в техе, которые можно использовать, но в разных целях. Например,
в прошлый раз мы видели пример с созданием колонтитула, который использовал счетчик
DPAGE, чтобы использовать номер страницы в качестве нижнего колонтитула. Довольно естественное
желание, но это оказывается довольно широкая возможность, и счетчики могут отражать более-менее
что угодно, что нам потребуется. Можем создавать свои, в синтезе суд такой, new counter и название
счетчика, как название переменной, по умолчанию с значением ноль. Как мне значение, поговорим чуть
дальше. Второй вариант создания счетчика – создание целой пары, при которой второй счетчик,
он как бы оказывается вложенным с первым, и каждый раз, когда первый меняет свое значение,
второй обнуляется. Ну, это можно, например, сравнить с нумерацией теорем внутри одной секции. Если мы
делаем у теорем нумерацию в тезотекции, то в каждой секции они нумируют снова с единицы. И если
вдруг нам потребуется это сымитировать, не прибегая к окружению теорем, то писать мы будем именно так.
Значение счетчиков модифицируется такими командами. Есть команда step counter, которая просто
инкримитирует его на единицу. Есть add to counter, которая прибавляет любое значение, причем не обязательно
положительное, можно, собственно, и вычитать команда add to counter. И set counter тоже создает значение счетчика
на любое целое число, включая отрицательные. Ну, я не знаю числа границ, видимо, какой-то. Не думаю,
что когда-то может потребоваться больше. И для чего счетчики нужны? Их можно по-разному отрисовывать
на страницах. Как мы видели, вариант the page, где счетчик называется page, вот сейчас все эти
способы перечистим. Что делает этот код? Он создает счетчик, который называется name, и дает ему
точение 22. И далее я его отрисовываю в куче разных способов, которые ниже представлены. Есть вариант
the name, просто приписывание к названию счетчика, каким бы оно ни было, префиксы the и backslash,
делает его командой, эквивалентной их следующей команде, которая называется Arabic. Она принимает
на флот название счетчика уже без этих всех модификаций и отрисовывает его, ну, как обычное
арабское число, может быть, с минусом, если оно отрицательное. Да, эти два варианта не скомплировались,
потому что их принес в следующую строку. Это команды Roman с страшной закладной буквы. Как ясное
название, они по счетчику производят числа в римской нотации, равные ему по значению. Но там тоже
есть ограничения, соответственно, вход должен быть обязательно положительным и не превосходить
максимального числа, которое в римском стиме можно записать, что-то типа четыре тысячи. Но, опять же,
вряд ли такие большие числа могут вообще встречаться в реальном коде. И есть команды alph,
с страшной закладной буквы, они позволяют отрисовывать счетчик, как с точечкой буквы латинского
алфавита. Ну, соответственно, значение может быть только 1 ряд 26, причем, я полагаю, 0 не
включительно, потому что нулевую букву мы сейчас не существует. А все положительные значения
мепятся в соответствующей буквы латинского алфавита. И есть сколько-то счетчиков, которые стандартные и
к которым можно обращаться в ходе написания кода. Есть счетчики, отражающие текущую там секцию,
главу, подглаву и так далее. Ну, как всегда, можно обращаться с помощью префикса T, можно с
помощью там арабской или римской номерации. Это иногда может пригождаться. Есть счетчики,
отражающие номер текущей страницы, как мы уже видели, и аналогичные номер там текущей фигуры,
номер текущей таблицы, это то, о чем мы говорили в прошлый раз, или номер с носки, о чем было
упомянуто буквально сегодня. Есть счетчики, отражающие текущую позицию внутри нумерованного
списка. Чуть дальше будет пример, но вот нумеровный список поддерживает четыре уровня вложенности,
на каждом из которых номерация ведет, естественно, отдельно. И от номерации можно управлять,
мы скоро увидим как. Ну, и есть всякие номерации, номерации уравнений, которые мы опять увидели
буквально вот только что, который является общей и для там среды Align, Equation и прочего,
это хранится в счетчике Equation. Ну и как к ним обращаться, как их использовать. Есть такой пакет
enumItem, который позволяет управлять, как будет выглядеть номерованный список. В частности,
в начале команды, в начале окружения numrate мы можем указывать значение label и некого вида
выражения, синтаксис можно нагуглить, который управляет тем, как будут выглядеть номера
номеров на списке. То есть на команда ALG, закладные буквы, как это естественно ожидать из того,
что мы видели буквально только что, отрисовывают вместо чисел заглавные латинские буквы. То есть
первый item номируется буквой A, а далее была бы буква B, если бы не сделала следующего. Мы
к счетчику enum1, ну то есть римская единичка I, оставляли значение 5. С того момента следующий
item считается уже не вторым, а пятым, потому что мы его поменяли, и поэтому это будет буква F.
Это скорее экзотика, в таком сочетании команда вряд ли стоит использовать,
но по деятельности они пригождаются и имеют какую-то пользу. Прочечки сами по себе, наверное,
и все. И вот что я считаю добавить про окружение, чего еще не было сказано. Во-первых, их можно писать
целиком с нуля своей, не только используя встроенный пакет теорем и прочего. Есть такая
команда newEnvironment, я в прошлый раз ее анонсировал, и тут я в любом случае зафиксировал это синтаксис,
как она пишется. У нее есть три обязательных аргумента, это название нового окружения,
но опять же, оно не должно иметь конфликта имен. Как мы видели в прошлый раз, есть варианты
команд newCommand и renewCommand, где renewCommand определяет уже существующую команду, а newCommand
уже существующую команду просто не запускается, говорит, что имя уже занято. Здесь можно делать
тоже самое, но забудьте пока про newEnvironment, он нам не очень пригодится. И далее два блока из
переменных, в которых пишется код того, с чего начинается среда, и того, чем заканчивается среда.
Буквально в коде происходит следующее, каждый раз, когда встречается эта среда, вместо beginEnvironment
подставляется тот код, который мы указали в этом блоке, precedingCode, а вместо endEnvironment
подставляется тот код, который есть как seatingCode, и его же полученный файлик эмпелируется. Ну вот
такой пример. Если мы хотели совместить стиле жирного шрифта и центрирование, мы могли бы
сделать это, например, таким образом. Сделать новую среду, которая называется CenterBolt,
в которой открывающий блок это, собственно, beginCenter, который помещает все, что далее
внутри среды будет находиться в окружении Center, и bfseries, модификатор, который делает весь текст
дайдера жирным, пока не будет сказано обратное. Но обратное сказано не будет, мы просто упрям
себя в закрывающий блок, который будет выражена endCentrum, и посмотрим, как это будет выглядеть.
Текст завернутый в эту среду, он одновременно и жирный, и по центру вроде то, чего мы и хотели.
Вот такая вот полезная функция. И еще что не было сказано, тут я не успел прям примеры привести,
скопировал код StackWareFlow, но, по всяком случае, есть такая команда NewSerumStyle. Мы в прошлый раз
видели, что есть встроенный стиле теорем, там plane, remark и, кажется, definition. Казалось бы,
их уже хватает, чтобы покрыть все, что только можно покрыть, но вот не совсем. Если вам требуются
какие-то более специфические решения, типа изменения шрифта, там изменения каковцев отступов,
то это можно делать так. Есть команда NewSerum, у которой куча аргументов, все обязательные,
но если какой-то аргумент вы не хотите менять, вы просто оставляете его пустым, а те, что вы
хотите поменять, вы меняете на то, что вам нужно. Как и написано. Название стиля, то, насколько будет
большим отступ до теоремы и после нее, шрифты, то есть модификаторы шрифта, которые будут налогаться
на сам текст теоремы, не касаясь ее названия. Ну а headfont – это и то, что будет начисляться именно
названием. indent – это параметр отступа от левого края. head.tension – это по умолчанию теорема
1. и далее текст. Это тоже можно менять вот этим вот параметром. Ну а headspace – это, собственно,
размер пробелы между объявлением теоремы номер такой-то, точка, и основом ее текста. Ну и headspec – тоже
некие модификаторы, которым можно накладывать название. Необходимость редкая, но она возникает,
вот можно и пользоваться. Часто эта штука удобно сочетается с new environment. Если мы хотим,
скажем, чтобы наши теоремы были подчеркнуты красным фоном по какой-то причине или завернуты
в рамку, такое удобно реализовывать через new environment, а внутри него уже зашивать
использование какой-то теоремы. Думаю, что сегодня были довольно сложные примеры кода,
поэтому на этом стоит закончить.
