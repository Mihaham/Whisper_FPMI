Так, наверное надо начинать. Да, меня слышно нормально там на записи. Так, значит, вот
эти вот лекции следующие будут такими центральными, по крайней мере, в первой части курса. Они будут
посвящены теме NP-полноты. И в целом многие понятия, которые в этой теме возникнут,
прежде всего понятия свадимости, понятия полноты, они будут не только про класс NP,
но и, в принципе, про практически любые другие классы. Мы познакомимся вот с такой картиной,
как разные задачи расположены. Эта облачка, это весь класс NP. Тут как бы по вертикальной
оси наверх идёт сложность. Значит, вот где-то здесь в нижней части будет класс P. Значит,
дальше будет такое вот ножство NPH. Это NP-трудные задачи, а пересечение NP-трудных и NP-называется NP-полное.
Тут, соответственно, NPC. А вот эти вот NP-промежуточные,
те, которые в NP, но не полные и не пальномиальные. Соответственно, вот на всё это мы посмотрим.
Значит, если вы изучали, что ко М-свадимость в логике, значит, с PMF точно изучали, да, с PMF тоже было.
Хорошо, значит, в целом у вас есть понятия о свадимости, а вот АМ-полнота там была? Тоже была,
очень хорошо. Соответственно, вот свадимость в NP и NP-полнота примерно тоже самое. Только вместо
вычислимости будет полинавиальная вычислимость. Соответственно, определение сначала свадимости.
Значит, свадимость между вообще любыми двумя задачами. То есть пусть А и Б это два языка.
Значит, пусть А и Б это два языка. Значит, тогда А сводится к Б, тогда А сводится к Б,
и тут буквка П и означает полинавиальная свадимость или свадимость по карпу.
Значит, читается, как А сводится к Б по карпу. Ну или полинавиально сводится, да, это в принципе то
же самое. Значит, если верно следующее. Если существует полинавиально вычислимая функция F,
значит, так, ну тут нужно сказать, откуда эти языки берутся. Ну, например, они из двоечных слов.
То есть они оба под множество 0,1 со звездочкой. Конечные слова в двоечном алфавите.
Вот, тогда F будет, соответственно, тоже из 0,1 со звездочкой в 0,1 со звездочкой.
Значит, полинавиально вычислимая F из 0,1 со звездочкой в 0,1 со звездочкой. Значит, такая,
что верно следующее. Значит, такая, что для любого Х будет, что Х лежит в А тогда и только тогда,
когда F от Х лежит в Б. Вот, значит, такое определение. Так, самое главное свойство, давайте,
сейчас будет несколько свойств, но самое главное, которое мотивирует вообще это определение,
это такое, что утверждение, утверждение, что если Б лежит в П, а А сводится к Б, то тогда А тоже лежит в П.
Значит, это вообще зачем нужна сводимость, что мы сводим задачу к какой-то другой задачу,
которую мы уже умеем решать. Соответственно, если мы уже умеем решать задачу СП и у нас,
соответственно, умеем решать задачу СП, у нас есть задача СП, мы к ней свели нашу,
тогда нашу мы тоже умеем решать. Вот, но это вообще почти очевидное утверждение, основано на том,
что композиция полинов это полином. То есть, тут получается, что есть, значит, Б лежит в П,
это означает, что существует полиномиально вычислимый какой-то алгоритм или машина М,
значит, такая, что будет, что х лежит в Б тогда и только тогда, когда М от х равно 1. Вот. Ну,
и тогда получается, что х будет лежать в А, х будет лежать в А тогда и только тогда, когда f от х лежит в
B, а это тогда и только тогда, когда М от f от х равняется 1. Ну и, соответственно, если f полинально
вычислимо и М полинально вычислимо, то композиция тоже полинально вычислима, потому что композиция
полинов это полином. Ну вот, в общем, так и доказывается, надеюсь, что это понятно. Так, теперь давайте
парочку простых примеров. Накинь совсем простые примеры. Но, например, можно рассмотреть задачу
раскраски в три цвета. Значит, три раскраска – это множество графов таких, что существует раскраска
вершин в три цвета. То есть существует функция call coloring из вершин графа G в множество из трех
элементов, например, 1, 2, 3. Значит, такое, что для любого ребра УВ, который – ребро этого графа,
будет верно, что цвет У не равен цвету В. Значит, в общем, вот стандартное определение раскрашиваемости
в три цвета. Так, значит, а дальше другая задача будет задача выполнимости. Значит, задача выполнимости
сад. То есть это множество фи таких, что фи – это выполнимая буллива формула. Ну вот, утверждается,
что три раскраска сводятся к выполнимости. Ну, на самом деле и наоборот, но наоборот мы, наверное,
в следующий раз обсудим. А в эту сторону не очень сложно. На самом, мы на логике на ПМИ это даже
изучали. На ПМФ не было такого, да? Не было, да. Сейчас тогда обсудим. Значит, вот три раскраска
сводятся к выполнимости. Значит, смотрите, в чём идея. Единственное, что нужно как-то закодировать раскраску
через булливопеременные. Ну, смотрите, если было бы два цвета, то достаточно было бы одной
переменной на вершину. Если было бы четыре цвета, то двух. А тут получается, что как бы одна мало,
две много, но всё равно нужно использовать две, но один вариант исключить. Соответственно,
каждой вершине графа мы сопоставим две переменных – булливых ПУТ и КУТ. Ну и дальше будет,
если две перемен, то четыре варианта. Значит, 0, 0, 0, 1, 1, 0, 1, 1. Ну и вот нижние три варианта
мы будем считать соответствующими цветам. То есть это будет цвет 1, это 2, это 3. А 0, 0 будет
просто некорректным. Чтобы потребовать, чтобы все цвета были корректными, мы наложим условия
просто дизьюнцию. Значит, ПУТ или КУТ. Это условия для всех У. Это условия корректности. Но кроме
того, нужно ещё, чтобы это была правильная раскраска. То есть это условие того, что именно
три цвета, а ещё нужно вот это условие, что они различные. Но так и запишем просто, что вот это
как буллива строка из двух битов, различная, если У и В соединены ребром. То есть дальше условия,
что если У и В это ребро, то тогда должно быть условие ПУТ не равно ПВТ или КУТ не равно КУВТ.
И дальше нужно взять большую конъюнцию. Дальше возьмём большую конъюнцию всех этих условий,
и будет как раз формула, выполнимость которой равносильно раскрашиваемости графа.
Вот это ФИ. Это конъюнция всех условий. И мы получили, что ФИ выполнима только тогда,
когда граф раскрашиваемый. Можно вкратце обсудить почему. Важно, что здесь в две стороны
равносильность и в ту и другую сторону. Соответственно, наверное, справа налево проще,
потому что мы так и строили конструкцию. Если есть граф, у нём есть раскраска, тогда для каждой
вершины есть цвет, и мы этот цвет закодируем по этой табличке. Поскольку тут цвета 1, 2, 3,
то тогда все вот эти условия будут выполнены автоматически. Ну а кроме того, поскольку это
правильная раскраска, то у соседних вершин цвета разные, и поэтому вот эти условия тоже будут
выполнены. И поэтому конъюнция тоже будет выполнена, значит, ФИ выполнима. В другую сторону,
значит, в другую сторону пусть есть выполняющий набор значений всех переменных, так что все эти
условия выполнены. Тогда, во-первых, поскольку выполнены все вот эти вот условия, то варианта
0, 0 нету, а все остальные варианты по этой табличке нам доздают цвета. Поэтому получается раскраска
именно в три цвета. То есть мы скажем, что цвет вершины У это 1, если значение переменных 0, 1,
2, 1, 0 и 3, если 1, 1. Значит, это раскраска. Ну и правильность тоже получается из этого условия.
Раз все эти условия выполнены, то значит все соседние в разные цвета покрашены. Так, хорошо,
значит, вот это вот простая конструкция. Так, давайте я еще даже, еще проще опишу конструкцию,
чтобы показать место, где нужно не ошибиться. Да, это мы, я надеюсь, сегодня успеем доказать. Ну не любую,
но любую из NP. Потому что вообще задачи сколько угодно сложные бывают, а SAT все-таки лежит в NP.
Так, значит, смотрите, вот такая еще проще утверждение, что раскраску в три цвета можно
свести к раскраске в четыре цвета. Но здесь есть очень простое и неправильное рассуждение,
что мы возьмем просто тот же самый граф. Если он раскрашился в три цвета, то будет в четыре
тоже раскрашиваться. Проблема в том, что в этом рассуждении только в одну сторону будет импликация,
нужно, чтобы в обе стороны была импликация. То есть нужно как-то граф все-таки преобразовать так,
чтобы если новый граф раскрашивался в четыре цвета, то старый раскрашивался бы в три цвета.
Да, совершенно верно, совершенно верно. Тем не менее, правильная конструкция тоже очень простая.
Значит, нужно взять граф и взять одну новую вершину и ее просто соединить со всеми.
Да не проще, я бы сказал. Не проще. Нет, это...
Нет, подождите, нам в другую сторону нужно. Да, четыре кол к САТ усвоится точно так же,
а вот САТ к четыре кол, и это не сильно проще, чем к три кол, и это целая конструкция там на 20 минут.
Мы ее пройдем, либо на лекс, либо на семинаре обязательно, но не сейчас.
Вот здесь рассуждение так проводится, что смотрите, если старый граф раскрашивался в три цвета,
то мы его так и раскрасим, добавим четвертый цвет этой вершины. Ну и наоборот тоже, наоборот,
что если новый граф раскрашивался в четыре цвета, то какой-то один цвет должен быть в этой вершины,
а у всех остальных вершин должны быть другие цвета, их как раз три осталось,
поэтому старый граф должен раскрашиваться в три цвета. Так, ну я надеюсь, это понятно.
Так, хорошо. Давайте еще парочку простых свойств сводимости, общих свойств
сводимости изучим. Другие свойства сводимости. Так, ну во-первых, транзитивность,
транзитивность, если а сводится к b, значит аb сводится к c, то тогда а сводится к c.
Более-менее по той же самой причине. Да, по той же самой причине, что композиция полинов это
полином и композиция полинарного числемых функций и полинарного числема. Значит дальше есть переход
к дополнению, что а сводится к b, тогда и только тогда, когда дополнение к а сводится к дополнению
к b. Мы требуем большая полинарная вычислимость, да, то есть полинарная вычисленность это мы считаем,
что не просто в конечное время, а ограничено полиномом. Да-да-да, на любом входе. На любом входе
функция завершает вычисление за полином от длины входа. Не-не-не, сейчас, давай считать, что если
время ограничено, то оно везде ограничено, а если не о полином, то это оно как бесконечное время.
Переход к дополнению тоже очевидно, просто ту же самую функцию можно использовать и в
определении нервонасильности прийти к отрицанию с левого и справа. Ну и еще, наверное, сводимость
к NP. Значит, сводимость к NP, что по аналогии с первым утверждением, что если a сводится к b,
а b лежит в NP, то тогда a лежит в NP. Ну, тут тоже можно использовать какое хотите определение NP,
у нас есть определение через нетерминированную машину, есть определение через сертификат. Ну и
в принципе и там, и там. То есть можно также как здесь сказать, что мы берем композицию,
только здесь ем нетерминированное, и тогда композиция тоже будет нетерминированная и работать
за композицию этих полиномов. Ну а можно расписать определение через сертификат,
а в общем тоже получится. Да, здесь будет существовать какой-то сертификат f от x,
и тогда его же можно использовать для проверки x, что сначала по x вычислить f от x, потом к этому f
от x принять сертификат из старой алгоритм-проверки. На самом деле вот это нижнее утверждение не только
для AP, не только для NP справедливо, а вообще для очень многих классов, которые у нас в курсе
будут встречаться. Ну более-менее да. Ну конечно, да, конечно. Конечно у нас примерно так и будет.
То есть вообще общая идея такая, что вот эта сводимость, она вот для вопроса равны ли p и NP,
как придумано. И всегда, когда есть какой-то такой вопрос про равенство классов, и известно,
что меньше вложено в больший, то всегда возникает сводимость, и сама сводимость должна быть из
меньшего класса. Вот, а применяем мы ее к языкам из большего класса. То есть как здесь все вот эти
вот и 3 кол, 4 кол, и SAT, они все в NP, и вот мы их так друг к другу свозим. Так. Вот, кстати,
4 кол к 3 кол я не знаю элементарного рассуждения. То есть можно свести к SAT, потом SAT к 3 кол,
а вот так, чтобы чисто с графами работать, это я не знаю. Ну может и можно как-то. Вот так. Ну
хорошо, наверное теперь можно перейти к определению NP полноты и NP трудности. Вот это вот ключевое
определение первой половины курса, по крайней мере. Точнее тут два. Вот я там стер диаграмму,
там были NP трудная и NP полная. Значит NP трудная, то есть B лежит в классе NP-H, NP-hard.
Значит, верно следующее, если для любого A из NP верно, что A сводится к B. Это NP трудность.
Сейчас, кто имеет внимание по включению? Не, ну понятно, да, NP полная, это множество всех таких B,
для которых вот это выполнено. Конечно это имеется в виду. Ну а NP трудная, а NP полная,
это NP трудный и NP одновременно. То есть NP полная, NP complete. Значит это NP в пересечение с NP
трудными. То есть это те языки из NP, к которым сводится любой другой язык из NP. Ну типа того,
да. Да, в частности, посмотрите, поскольку NP вложено в EXP, можно перебором решить за экспоненциальное
время, то в частности любая задача из EXP будет NP трудной. Ну да, вы правы. Ну да, хорошо,
из EXP там, ну не более простые. Так, сюда эти словами тоже напишу. Те языки, те языки из NP,
к которым сводятся остальные из NP. Так, и это NP полнота. Так, ну еще есть NP промежуточные,
да, они были там на диаграмме, но давайте я их тут напишу тоже NP. NP intermediate. NP промежуточное,
значит это NP без NP полных и без P. Ну а если нет, то слева-слева направо. Ну давайте я более
однозначно напишу. Так. Что по словам множество? Что-то я не понял про эксиматику.
А, в смысле, что, не, ну да, если P равно NP, то тогда, смотрите, это интересная штука вообще. Вопрос,
что если вдруг P равно NP, то как это все выглядит? Смотрите, там будет два исключения, это как раз
пустое множество и, наоборот, все слова, язык из тех слов. То есть вот так, та картинка,
которую я рисовал, значит давайте я ее перерисую в случае, когда P равно NP. Значит, если, если P
равно NP, то это будет так выглядеть. Значит, вот это будет, значит, это будет P равно NP. Значит,
а NP полные будут все, кроме двух исключений. Да, то есть тут вот будет пустое множество и,
наоборот, все слова вместе, а вот это будут NP полные. А NP трудные будут все, кроме,
кроме, опять же, вот этих вот двух. А предвручных вообще не будет. Вот. Почему так будет? Ну,
потому что, смотрите, если утверждение, утверждение, если пересечение P и NP полных не пусто, то P равно NP.
Значит, почему это так? Ну, конечно, да, из определения. Получается, да, у нас есть там какая-то
задача, с одной стороны она лежит в P, с другой стороны любая из NP к ней сводится, но и по утверждению
сводимости к P, она тоже будет лежать в P. Отсюда NP будет вложена в P, а P вложена в NP всегда. Вот.
Хорошо. Ну, значит, дальше еще есть несколько очевидных утверждений, они более-менее следуют
из свойств сводимости. Значит, смотрите, если A у нас NP полная, значит, если A NP полная и A
сводится к B, то тогда B тоже NP полная. Ой, сейчас, пока NP трудные, пока, да, извините. Если A NP
трудная и A сводится к B, то B тоже NP трудная, потому что любая из NP сводится к A, потом A к B по
транзитивности любая к B. Вот. А с NP полными, ну, нужно еще дополнительно потребовать, чтобы B тоже
лежала в NP, да, то есть если A, значит, если A лежит в NP полных, значит, A сводится к B и B лежит в NP,
то тогда B тоже NP полная. Ну, например, по тем же причинам, что мы любую из NP свели к A, потом к B,
значит, любую к B, а B само в NP мы явно потребовали, и поэтому она NP полная. Вот. Соответственно,
вот это последнее утверждение, оно при всей своей простоте очень важно, потому что именно оно
позволяет получать новые NP полные задачи. То есть, в принципе, типичная ситуация, когда какая-то
новая задача где-то возникла, да, она по характеру переборная, но вот мы хотим для начала понять,
будет она NP полная или не будет. Вот. Но не будет это сложно, а вот если будет, то нужно,
во-первых, сказать, что она действительно переборная и лежит в NP. Но это обычно, это бывает несложно,
там какой-нибудь очевидный перебор, но бывает сложно. И во-вторых, нужно какую-то известную NP
полную задачу свести к данной. Вот. Ну и известных NP полных задач очень много, в том числе в разных
конкретных областях. Ну и с некоторыми из них мы познакомимся. Так. Ну ладно, это, наверное, понятно.
Хорошо. Но возникает вопрос, а почему хотя бы одна есть полная задача? Да, вот если у нас одна есть,
то мы ее уже можем сводить. Это мы уже поняли. Но с чего начать? Откуда хотя бы одну найти? Но вообще-то
это не тривиальный вопрос, да, то есть это вообще не в любом классе есть полная задача. Значит, есть
классы, в которых, ну по крайней мере, неизвестно есть полная или нет. Например, связанные с
вероятностными вычислениями. Вот. Но здесь есть. И есть так называемая генерическая NP полная задача,
generic. Значит, генерическая NP полная задача. Значит, обычно она TM SAT обозначается. TM это
Turing-машин. То есть Turing-машин Satisfiability. Значит, выполнимость на машине Тюринга. Ну и на самом деле,
так, как правило, если в классе есть полная задача, то в том числе вот такая задача будет в нем полной.
Я сейчас напишу, что это такое. Наверное, нужно написать, иначе вообще непонятно, на чем речь.
Значит, задача такая. Хотя на PMF это вроде должно было быть в семинарах, по крайней мере, в некоторых
группах. Значит, задача такая. У нас есть тройка из машины, входа и еще некоторого ограничения в
геонарной записи. Значит, вот эта степень, это значит единица, повторенная T раз. И, соответственно,
требуется проверить следующее, что существует y, значит, такой, что m от x и y, во-первых,
храняется единица, и, во-вторых, работает не больше, чем T шагов. То есть мы фактически зашили
определение NP через сертификат, зашили определение этого языка. Вот эта вот называется генерическая
задача, когда мы тот тип машины, через который определяется язык, зашиваем как часть условия задачи.
Значит, NP-трудность в данном случае почти очевидна. Нужно взять определение NP через
сертификаты. То есть нужно написать, что, скажем, х лежит в b, тогда и только тогда существует y,
такое, что m от x и y равно единице. Дальше в том же определении сказано, что m работает полинарное
время от длины x. Значит, m работает не больше, чем какой-то полином от длины x шагов. Ну и сводимость
будет устроена так, что x отображается в тройку из m, x и единицы, повторённой как раз по длины x раз.
Вот, значит, вот это сводимость. Ну и получается как раз по определению, что если есть такой y,
то он как раз закончит работу за сколько нужно, и как раз это будет означать, что x лежит в b.
А если такого y нет, то и тут такого y не будет, это будет означать, что x не лежит в b. Вот,
значит, это трудность. Ну а для того, чтобы оно само лежало в NP, как раз важна вот здесь унарная
запись, что m и t записываем в унарной запися. Значит, принадлежность к NP делается так, что вот это
вот условие можно проверить как раз за полинарное время, ну, грубо говоря, через универсальную машину
тюринга. Да, значит, что можно запустить m от x и y как раз на t шагов, значит, и тем проверить.
Ну вот это условие. Проверить, что y подходит. Да-да-да, на вход какое-то описание машины тюринга.
Ну универсальное как раз то, что мы здесь делаем. То есть когда мы запускаем m от x и y на t шагов,
то да, мы используем машину тюринга. Значит, важно вот что. Важно, что моделирование одного шага,
но требует какого-то не слишком большого числа шагов, поэтому общее число шагов вот этой
проверки будет как раз, ну уж точно по линомам от t. Да, там t в квадрате может быть, там зависимость
от деталей моделя. Но также важно, что это по линомам от t будет также по линомам от длины
записи ровно за счет унарности вот здесь вот. То есть у нас есть t символов вот уже в этой части,
и поэтому то, что работает по линомам от t, будет работать по линомам от длины входа. И поэтому это
будет в NP. Так, ну что, какие-нибудь вопросы? Ну смотрите, значит тут то, что мы не обсудили,
это вот эти вот, собственно, два исключения. Там, смотрите, какая фишка, что если p равно NP,
то мы как бы, то любая задача из, вообще, если мы рассмотрим две задачи из P, то они будут друг
другу сводиться за исключение того случая, когда кто-то из них вот такой вот. Да, значит,
тут, знаете, я тут-то напишу, что можно, значит, смотрите, если там b0 не лежит в b, а b1 лежит в b,
а a лежит в p. Тогда можно посмотреть на вот такую сводимость f от x, это будет b1,
если x лежит в a, значит и b0, если x не лежит в a. И тут, смотрите, неважно, откуда мы взяли b0 и b1,
потому что их всего две штуки. Если они, в принципе, есть, то вот такая сводимость будет
пальномиальной, такая функция будет пальномиальной, поскольку вот это мы можем проверить за
пальномиальное время. И это будет когда сводимость a к b. Ну, конечно, да. Нет, потому что если
уберете сводимость из большего класса, а не из меньшего, да, вот то, что я вот здесь говорил,
что нам сводимость нужна из меньшего класса. Но если они совпали, то мы, получается,
взяли сводимость из большего класса. А тогда, если мы как бы и так умеем решать задачу,
то не нужно ее куда-то сводить, мы ее просто решим. И именно это выражает вот та конструкция.
Так, ладно, давайте сейчас сделаем перерывчик и потом поговорим про другие по полной задачи.
Ну что ж, давайте продолжим. Давайте посмотрим на еще одну важную сводимость. Она тоже должна
была быть на логике для PMI, а на PMF, наверное, не было. Но, тем не менее, давайте на нее посмотрим.
Значит, есть такая задача 3. SAT. Это вариация задачи SAT, то есть выполненности формул.
Да, то есть это множество таких формул ФИ, да, что ФИ имеет вид, имеет вид 3 KNF. Значит, и,
ну, можно сказать, что ФИ лежит в SAT, да, то есть ФИ выполнимо. Что такое 3 KNF? Ну,
вообще, KNF — это конъюнкция скобочек, где каждая скобочка — это дизюнкция переменных или отрицаний,
а 3 KNF означает, что в каждой скобочке не больше трех литералов, то есть не больше трех переменных
или их отрицаний. Да, то есть вот это вот, значит, конъюнкция, конъюнкция дизюнктов,
конъюнкция дизюнктов из не более чем трех литералов. Вот. Ну, вот утверждается,
что выполнимость любой формулы свойствует к выполнимости 3 KNF. Да, значит, при этом,
заметим, в скобках это, ну, может, либо вернемся в какой-то момент, либо на семинарах, может быть,
будет, да, значит, при этом два SAT, да, то есть аналог для два KNF — это задача ИСП. Ну, или,
может, даже кто-то знает, как это решать. Ну, например, да, только доказать, что он сработает
достаточно быстро. Да, вроде на PMI была такая задача даже. А, не знаю, где-нибудь на алгоритмах
не было такой задачи? Было, да. Понятно. Два SAT, да. Хорошо, ладно, давайте это замечание в скобках.
Вот, а вот про сводимость. Поговорим, да, утверждение, что, значит, SAT полинамиально сводится к три SAT.
Ну, тут формально описание довольно громоздкое, так что давайте я на примере это покажу. Надеюсь,
что будет понятно. Значит, вот пусть у нас какая-то есть формула, но она как-то выглядит, да,
например, скажем, P и Q влечет, а тут, скажем, не R или S. Вот такая форма, она, конечно, очевидно,
выполнима, но я на ее примере покажу, как сводимость работает. Значит, сводимость устроена так.
Значит, мы фактически строим дерево синтактического разбора, то есть формула она из более мелких
строится потихоньку более-более крупная, и вот только вся формула получается. Вот, и мы для каждой
подформулы заведем свою новую переменную. Значит, например, вот это обозначим за T. Так,
но тут можно сокращать, давайте я не буду сокращать. Значит, не R обозначим за U, вот это
обозначим за V, и все вместе обозначим за W. И построим такую систему условий. 4 равняется P
конъюнция Q, дальше U равняется не R, V равняется U или S, W равняется T, T влечет V,
и еще W само по себе. Вот, и будем рассмотреть такую систему. Так, ну в общем случае, наверное,
понятно, что делать, что мы строим полное дерево разбора, для каждой подформулы заводим новую
переменную, делаем так, чтобы это было двоичное дерево, ну не более чем двоичное, либо отрицание,
либо двоичная конъюнция, дизъюнция или импликация. Вот, если мы там делаем конъюнцию трех,
то нужно на два шага разбить. Значит, и после этого записываем условия для каждой подформулы,
записываем, что перемена, которая есть соответствует, равняется нужной функции,
примененной к соответствующим компонентам. И кроме того, еще добавляем вот это последнее условие,
что перемена соответствующей всей формуле должна быть истинна. Вот, равенство понимается как
эквиваленция, как булева операция. Но утверждается, что вот эта система совместна тогда и только тогда,
когда исходная формула совместна. Почему? Ну, в одну сторону. Пусть у нас есть набор,
на котором формула истинна. Тогда это значит, что мы по этому синтактическому дереву считаем значение
всех подформул и в итоге получаем единицу. Но мы в качестве каждой новой переменной как раз значение
подформулы и возьмем. Которая получается, тогда ровно по правилам подсчета значения выражения
это все будет выполнено. И в итоге получилось единица, значит и последняя тоже выполнена.
Теперь наоборот. Пусть формула невыполнима. Это означает, что на любом значении она равна нулю.
Но тогда с новыми переменными есть два варианта. Либо мы в какой-то момент новую переменную берем
не по правилу вычислений, тогда соответствующее равенство будет ложно. Либо мы все вычисляем по
правилу, тогда последнее w будет ложно. То есть хотя бы одно нарушение здесь будет. Но получается,
что исходная формула выполнима тогда, когда такая система условий выполнима. А после этого
тут в каждой строчке максимум три переменных. Просто потому что у нас были бинарные операции,
у нас было два аргумента, и одна переменная это значение. Ну а дальше знаем же теорему,
что любая формула к KNF приводится. Если там всего три переменных, то это будет три KNF. А потом
мы возьмем большую конъюнцию всех этих KNF и получим ту форму, которая нужна.
Ну что, понятно примерно? Это, конечно, пальномиальная процедура. То есть нужно обосновать,
что синтактический разбор, это выражение со скобками, это пальномиальная процедура.
Наверное, что-нибудь такое писали где-нибудь. Искать закрывающую скобку, выделять под формулы,
что-нибудь такое. В общем, ясно, что это не очень сложная операция, и за пальном можно сделать.
Нет, тут все-таки нужно правильно дерево построить еще. Нет, реально это работа со скобками. То есть
нужно для каждой скобки находить парную и закрывающую, и дальше рекурсивно запускаться
от этого фрагмента. Ну или не рекурсивно, а как-нибудь более умно. В общем, это ясно,
что должно получиться. Но это примерно как было с 2 и 3 раскраской. Да, то есть тут, смотрите,
если у вас скобки только из двух литералов, то если один из них ложный, то второй автоматически
истинный. А если из трех и один ложный, то еще есть три варианта для оставшихся двух, и это увеличивает
перебор. Примерно такая ситуация. Точно так же было с раскраской в два цвета. Если один конец
ребра покрашен в один цвет, то другой точно в другой. А с 3 цветами же есть два варианта.
И там этот перебор накапливался. Так, ну хорошо.
Ну а сейчас познакомимся с теоремой, с которой вообще началась вот эта вся история с PNP.
Долгое время она называлась теоремой Кука даже в русскоязычной литературе, но потом справедливая
атрибуция восторжествовала, и она называется теоремой Кука-Левина. Это я обсуждал на первой
лекции, что Кук и Левин одновременно, независимо друг от друга, в разных странах и в разных
терминах, но в принципе доказали одно и то же. Теорема Кука-Левина. Ну можно, если коротко,
просто написать, что SAT это NP-полная задача. Ну и как следствие три SAT тоже NP-полная задача.
Да, вот из предыдущего утверждения отсюда следует, что три SAT это тоже NP-полная задача,
и собственно дальнейшие свадимости будут именно с три SAT начинаться. Любую задачу свели к SAT,
потом SAT к три SAT, а потом три SAT уже куда сводятся, и там такое дерево разрастающееся
получается дерево свадимости, они все друг другу сводятся. Смотрите, у нас уже был пример в самом
начале, что мы три раскраску свели к SAT. Ну и в принципе так не очень удивительно, что поиск
любого конкретного Y можно свести к каким-то логическим условиям, но все-таки тут чтобы
получилось полное доказательство, нужно так или иначе рассуждать про какие-то низкоуровневые
детали того, как машина тюринга устроена, на которой это все происходит. Давайте доказывать,
для одноленточной машины и для сертификатного определения. Доказательства. Тут будет
одноленточная машина, одноленточная машина тюринга и сертификатное определение.
Надо как-то закодировать данные. Это опять же можно делать по-разному, но смотрите, у нас есть
одноленточная машина, у нее есть одна лента, где-то в одной ячейке, в каждый момент в одной ячейке
находится головка управляющая и машина в каком-то состоянии. Есть понятие конфигурации машины
тюринга, состоит из содержимого ленты, координаты указателя и состояния машины.
Конфигурация – это содержимые ленты, содержимые ленты плюс положение указателя
и плюс состояние машины. Один из способов это все кодировать, это все написать в одну строчку.
Значит, вот так вот можно написать, сертификат тоже где-то на этой ленте записан, то есть нет,
не будет отдельной ленты для сертификата. Нет, а сертификаты мы тоже будем считать полимонной
длины. Просто смотрите, время работы машины тюринга полиномиально длины входа, а не сертификата,
и поэтому длину сертификата тоже можно ограничить тем же самым полиномом, поэтому все-таки оно будет
конечное. Так, давайте я допишу. Это вот такой способ кодирования, когда а маленькая – это символ
алфавита, а и b большие – это слова и какое это состояние. Имеется в виду следующее, что вот
это одна лента, здесь записано слово, до него идут сплошные бланки, при этом внутри а и b больших
тоже могут быть бланки. Это не запрещено, но заведомо, что левее а только все пустые клетки.
Дальше здесь символ а, на него указывает машина, находится состояние q, дальше слово b и дальше тоже
бланки. Вот так вот мы будем кодировать. Смотрите, машина работает какое-то время полиномиальное,
и соответственно в каждый момент времени будет своя конфигурация. И мы будем рассматривать таблицу
с этой конфигурацией, на которой будет как бы выровненное. И можно заранее ограничить размер,
если мы знаем время работы машины тюринга, то ясно, что число, опять же при стандартной модели,
когда за один шаг можно сместиться только на одну ячейку, заведомо число использованных ячеек будет
не больше, чем время работы. А время работы у нас полиномиальное. И тут получается такая таблица,
я ее так нарисую, а дальше я перерисую покрупнее. Вот здесь вот будет какое-то время t.
Здесь соответственно тоже можно выделить t ячеек. Тут будет начальная конфигурация,
начальная конфигурация, дальше там следующая конфигурация, и так далее. И в последний момент
будет какая-то итоговая конфигурация. И нам нужно сказать следующее, что в начальной конфигурации
будет x фиксирован, а еще где-то там будет y, то есть сертификат. И собственно это будет степень свободы,
что y может быть какой угодно. А дальше мы хотим, чтобы все переходы были корректные, а в итоге
была бы принимающая конфигурация, чтобы вот эта итоговая была принимающей. И вот это все нам нужно
записать формулой, причем полиномиального размера. Ну по крайней мере пока что ясно,
что у нас полиномиальное число переменных, потому что у нас число символов вообще константа.
Символы это либо символ алфавита, либо символы состояний и того и другого константа, в смысле,
что не зависит от x. Число символов константа, число ячеек t в квадрате, а t это полином,
то есть квадрат полинома это тоже полином, значит у нас всего полином переменных. Но конечно от
полинома переменных могут быть формулы длины экспонента, поэтому нам нужно показать, что здесь
формулу можно так построить, что она тоже будет длиной полином.
Не, сейчас, у нас вот такие вот слова записаны.
Q прям как символ в ячейке тоже. Сейчас, смотрите, вот здесь вот, внутри таблицы,
здесь будет не так, как вот здесь, а будет вот так. Значит A, потом Q, потом A и потом B.
Q это состояние, и Q мы тоже прям в ячейку напишем.
Ну мы это символом будем называть.
Ну да, то есть нужно сделать так, чтобы символы леночного алфавита не пересекались состоянием
машины, и значит по коду в ячейке могли бы понять однозначно, что это такое.
Ну типа того, да.
Так, ну хорошо, давайте я тут еще чуть-чуть подробнее нарисую.
В таблице конкретное исполнение.
Ну сейчас вот поговорим про это. Значит, во-первых, как выглядит начальная конфигурация.
Значит, есть какое-то начальное состояние Q1.
Да, давайте еще считать, что у нас лента слева ограничена, что у нас лента на стороне только вправо.
Для удобства будем так считать. Соответственно, здесь будет Q1, дальше будет X,
значит, некоторый блок, дальше пробел, значит, дальше Y, ну и дальше пробелы до конца.
Вот это мы будем называть начальной конфигурацией.
Теперь дальше, будем нумеровать, давайте с нуля нумеровать, значит, ноль.
Не, подождите, у нас есть X, который вход, написано на ленте, но кроме того, мы используем
сертификатное определение, то есть кроме X еще есть сертификат Y, и мы будем считать,
что они закодированы так просто через пробел, написано на одной и той же ленте.
Так, в общем, строки нумируют момент времени, ну и последнее будет какое-то P от N.
Вот, остался и нумеруют положение на ленте, ну и тоже, значит, будет 0, 1,
значит, так далее N, да, X длины N, значит, N, тут N плюс 1, значит, N плюс 2 и так далее, ну тут
какой-нибудь там M, ну и так далее, здесь тоже P от N, потому что как раз даже если указатель каждый
раз будет сдвигаться направо на один шаг, то он за P от N шагов как раз только до P от N сможет
сдвинуться. Вот, значит, итоговая формула будет из трех частей состоять, значит,
Phi будет состоять из трех частей, значит, Phi start и Phi accept и Phi step. Да, давайте еще
словимся так, что если машина пришла в завершающее состояние, а время еще не кончилось, то дальше она
просто ничего не меняет, то есть если где-то здесь по дороге это члене завершилось, то дальше все
последующие строчки будут тем же самыми. Так, хорошо, значит, как устроены эти формулы.
Phi start, ну Phi start выражает, что, а, во-первых, какие у нас переменные, ну переменные у нас в каждой
ячейке будет столько переменных, чтобы было достаточно закодировать любой символ алфавита и любое состояние.
Так, значит, тут так, P у нас полинов, ну давайте скажем Q и gt. Значит, Q и gt это набор переменных,
кодирующий символ в ячейке и g. Значит, это набор переменных. Ой, Q у нас состояние. Так, какие у нас еще буквы есть?
Ну не знаю, s давайте. Так, значит, набор переменных, кодирующий символ, о, s от слова символ,
кодирующий символ в ячейке и g. Так, значит, смотрите, как будет выглядеть Phi start. Значит,
Phi start фактически означает, что вот там написано то, что действительно, что в ячейке тоже то, что здесь написано,
но есть тонкость с этим y, потому что y мы заранее не знаем. Мы заранее не знаем, но мы знаем все-таки,
что y никакое угодно, а он должен состоять из битов, из нулей и единиц. Но вот это и запишем.
Значит, Phi start выглядит так. Значит, s00 это q1 и s01 это x1 и так далее, и s0n это xn.
Дальше s0n1 это пробел. И дальше будет так. Значит, s0n2 это, так, давайте я тут покажу,
в кавычке возьму ноль, что это как бы символ 0. Или s0n2 это символ 1. Ну дальше и так далее,
и так до m. И s0m2 это 0, или s0m2 это 1. И все последующие должны быть пустыми.
Значит, m плюс 1 это бланк и так далее. Последний это бланк. Так, какой вопрос?
Давай считать, что мы это знаем, потому что это определяется алгоритмом, который используется.
То есть мы знаем машину тюринга. В принципе, m это какой-то полином. В принципе, даже смотрите,
если даже у вас используются сертификаты разной длины, то вы, например, можете использовать
беспрефиксные кодирования и дополнять каким-то мусором, и тогда у вас те сертификаты станут одной длины.
Это правда, но есть общая граница, это время работы. В принципе, можно считать,
что этого блока вообще нету, а m просто идет прям досюда. В какой-то момент алгоритм решит,
что он уже все прочел из сертификата, все остальное можно стирать и использовать для вычислений.
А x у нас есть заранее. Смотрите, мы по x устроим формулу, и на самом деле это ровно
то место, где мы используем, какой у нас был x. Больше мы x нигде не используем.
Дальше phi accept будет очень простым. Будет просто, что где-то в последней строке
будет принимающее состояние q accept или и так далее, или s, p от n, p от n, это будет q accept.
Phi accept означает, что мы пришли в принимающее состояние. Ну и последнее, самое интересное,
это phi step. Как записать, что все шаги корректны? Тут есть некоторая ключевая идея.
Потому что, смотрите, вообще, конечно, каждая следующая строчка однозначно определяется
предыдущей строчкой. Но если мы просто как попало это запишем, то у нас будет как бы полином
аргументов, функция полинома аргументов может иметь экспоненциальную запись, если мы просто ее
стандартным образом куда-то приводим. И важно следующее, важно, что на самом деле именно в
машине тюринга любые изменения происходят очень локально. Смотрите, как работает машина тюринга.
У нее есть место указателя, и она заменяет вот эту клетку, куда указывает, и еще сдвигается либо налево,
либо направо. Соответственно, получается, что если клетка больше, чем на расстоянии 1 от положения
головки, то клетка вообще точно не изменится. То есть вообще почти вся лента не изменится, кроме небольшой
окрестности того места, где стоит указатель. Ну и на самом деле это можно выразить вот так вот.
Можно выразить вот так вот, что мы рассмотрим четыре клетки подряд, и утверждается следующее,
что вот эта вот клетка однозначно зависит от этих четырех. Значит, это однозначно
определяется четырьмя верхними. Так, почему четырьмя? Почему не симметрично? Но это с нашим
соглашением связано, что мы состояние и символ пишем в разных клетках, и тогда, например, если вот
здесь стоит состояние, то тогда, например, то куда сдвинется машина зависит от того, какой символ
вот здесь. И, соответственно, она может сдвинуться вот сюда, а может не сдвинуться. А в остальном,
применив правила машин тюринга, можно посмотреть, что это будет. То есть, например, если не здесь,
не здесь, не здесь нет состояния, то просто нужно скопировать то, что вот здесь. Если, например...
В смысле, почему проиграли? Смотрите, вот это...
Не-не-не, сейчас, подождите. Вот такие вот треугольнички, не треугольнички, а пентамины такие,
они по всем клеткам ездят, то есть вот такая функция, она так ездит слева направо и вычисляет,
каждую следующую клеточку. Как она работает? Примерно, что если не здесь, не здесь, не здесь нет
указателя, то она просто копирует символ отсюда, а если где-то здесь есть указатель, то есть символ
состояния, то она смотрит в программу и меняется соответствующим образом. В общем, в итоге...
У меня две минуты остается. В итоге фисте будет выглядеть примерно вот так вот. Это будет
большая конъюнция. Значит, большая конъюнция по i от единицы до p от n, а j от нуля до p от n.
И будет вот так вот, что s, i, t, j, t это будет некоторая конкретная функция, которая определяется в
машине тюринга f от, соответственно, s, i-1, j-1, s, i-1, j, t, s, i-1, j-1 и s, i-1, j-2,
где вот эта функция f одна и та же для всей таблицы и определяется машиной тюринга.
Значит, соответственно, это может быть большая формула, но ее размер не зависит от x. То есть
эта формула большая, но константная. И размер всей формулы будет как раз паттерн в квадрате в этой
фист-степ. Ну и дальше нужно уже лезть в детали, доказывать, что если это все выполнено, то
действительно вся таблица это корректное вычление машины тюринга. Ну и после этого что
получается? Получается, что если x лежало в языке, то тогда было корректное вычисление для какого-то
y, и если мы его подставим вот в эту формулу, то все условия сойдутся, все условия корректности
сойдутся. Но и наоборот, если есть корректное вычисление, то ровно так должна работать машина
для вот этого данного x и того y, который получается из значений вот этих вот переменных. И отсюда
будет получаться, что из выполнимости следует, что x лежал в том языке, потому что для него был
хороший сертификат. Ну вот вроде все. Спасибо за внимание.
