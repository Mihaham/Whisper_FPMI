Сегодня рк-разбор. Попытка посмотреть на что-то не в терминах автоматов, чтобы понять, что надо делать, почему это будет работать.
Была просьба взять предотвратительство, я докажу основную теорему. Некоторые ссылки оставлю открытыми, потому что кажется, что у меня может быть время.
Я стараюсь своей целью объяснить, что конкретно в этом ритме происходит, и как его реализовать.
С поправками на то, что там некоторые вещи будут неоптимальными, но я считаю это хорошее упражнение для политического трека, подумать как-то и писать прям пас.
У нас рк-разбор, о нем надо думать как о том, как предпочтать он ритм early.
На самом деле существуют задачи, я его в конце дан, так на подумать. У меня она была в домашнем задании, тут она будет очень стабциональная.
Ситуация есть, а ситуация там. На самом деле это одно и то же, но обо всем по порядку.
Рк-разбор это некоторая тема, набор правил. Любой разбор вида лр, перенос свертка, сделан функциями.
Это функция действия, это экшн-функция.
Функция перехода.
Как бы вы не писали лр, на самом деле то, что скроют на один способ писатель лр, есть некоторые другие способы, у вас будет система правил.
f это функция, которая на каждом шайке смотрит как символов.
Или не больше, чем как символов, если у нас строка кончилась.
Сейчас я напишу sigma объединен с пустым словом.
Умный все равно по этой степени.
И возвращаю это из действий.
Что нужно сделать? Вы видите как символов в следующей налете.
Нужно сделать либо перенос, либо свертку по какому-то правилу.
Либо у нас будет use 0, это свертка по другому правилу.
Это тоже самое, что принятие.
Либо отвернуть.
Что это за нулевое правило такое?
Назовем граммачку пополненной, если мы такое нулевое правило добавим.
То есть мы введем новый символ, это штриги, проводится сахарный символ, а здесь выводится все.
Это как бы НФКомского, вы хотите потребовать, чтобы вот этот символ нигде больше не встречался, в правых частях.
Если свернулись по новому правилу, то есть как только вы совершили свертку вот так, это означает, что ваше слово точно в языке.
Более того, вы это неправильно сделаете.
Это вы следоваете из того, что у нас будет лева, что если существует сплата, то есть какой-то вывод.
Вот здесь, если существует вывод, применяющий это правило, то это вывод нашим словом и будет.
Поэтому это reduce 0.
Здесь критично важно, чтобы символа не было в правых частях.
Иначе вы не поймете, вы выбили...
Вот в случае 180-х ленок, то есть IFS ε, вы не поймете, вы выбили это международное или уже окончательное.
Поэтому нужно, чтобы он был уникальным.
Здесь замечу, что в случае переноса мы не думаем, в какое состояние мы переходим.
Поэтому...
Ну тут, на самом деле, кроме...
Здесь еще мы видим уровня состояния в ПТС.
В терминах книги, которые сейчас рассказываю,
а это тот, кто говорит 430-е строительство Аха Ульмана,
будет система функций, ну, ту же самую функцию двух перемен.
Вот эта пара называется alert-таблицей.
То есть у нас творится alert-таблиц.
То есть эта вещь индексируется именно индексами.
И вот что-то происходит.
Находясь в каком-то состоянии,
то есть мы смотрим на строку таблицы,
и в виде окончательного мы выбираем, что делать.
После того, как мы что-то сделали, нужно брать какую-то таблицу новую взять.
Вот.
Здесь функция, которая принимает уже одну букву.
Либо σ, либо n.
И что делает. Ну, очевидно, что с ним кто-то находится.
Ну и показывает, куда надо идти.
Можете в состоянии. Вот.
Как происходит разбор?
Мы смотрим на слово, на его первые k символы.
Либо меньше, если у нас в символах меньше.
Мы их забираем, смотрим на функцию.
Делаем либо перерос, либо свертку.
Ну, если что-то из этих, то мы разбор уже закончили.
Если не перерос, то на переносе у нас появляется какая-то буква.
Мы берем букву здесь, отправим ее на стэк.
Что, как это произойдет со стэком, еще будет сказано.
Ну, вот у нас появляется маленькая буква.
На свертке.
Если у вас программатика кс свободная,
кс свободная,
то у вас правило в том, что вы не так, а альфа.
Если вы по нему свернулись, вы сгниливали большую букву.
Вот она.
То есть маленькая буква соответствует переносу, вы перенеслись,
и теперь вы взяли функцию перехода.
Вы перешли по этой букве.
Большая буква соответствует свертке.
Вы сгниливали большую букву себе сами,
поставили на стэк.
Она не переносится, она появляется на стэке,
ходит в этот ритм.
Пришел переход.
Это опись утора разбора.
Разбор тревелит.
То есть сначала посмотри, что он дужден,
потом перейди в новую таблицу.
Дальше, вот если мы помним алгоритм Erli,
что там происходило?
Мы строили дерево разбора,
и мы фокусировались на каком-то потере.
Вот у нас была штрих,
мы начинали разбор,
доходили до буквы,
и здесь брали какой-то кусочек.
Альфа, точка, флэта.
Алгоритм Erli.
Это был на коробке, вы это все знаете.
И в момент, когда мы были тут,
когда мы видели здесь большую букву,
мы фокусировались на этом поддереве,
а про это как бы забывали.
В комплит мы искали,
какое правило породило это правило.
И за это у нас был 20 квадрат.
На самом деле кубический,
но квадрат в лучшем случае.
В алгоритме Erli та же картина.
Вы по кому-то избираться,
вы не смогли всю историю.
Поэтому в стэк мы добавляем
не только ту букву, которую мы видим,
но автомат придет сверткой.
Тоже был на колоколе.
Автомат из двух состояний.
Смотрите, что это.
Здесь мы поставили букву Erli,
и потом правило либо читаем на стэк,
либо смотрите как бы все.
Нам нужно помнить, что мы уже до этого
по дереву прочитали.
Для этого на стэк мы храним не только символы,
но еще и состояние.
Поэтому наш стэк
в каждой адребе
имеет такой вид.
Там всегда будет это стартовое состояние.
Дальше буквы
и новое состояние.
x и, s и,
x и плюс один, s и плюс один.
Всегда скажут, что у нас состояние,
где мы сейчас находимся.
Поэтому когда мы делаем свертку,
мы сворачиваем не как здесь n символов,
то есть вот он, 2 альфы,
а 2 n символов, откатываясь назад.
Откатились назад,
это состояние, в котором мы находимся.
В случае с функцией перехода,
перенос, вы ставите букву сюда,
вот состояние, вы из него переходите
по букве,
смотрите здесь, пишете новое состояние тут.
Если свертка, вы все состерли,
у вас появится большая буква.
А.
Видите состояние?
Пишем состояние, которое там было.
Ну не пишем, потому что уже было.
Пишем больше буквы, которые мы получили,
делаем функцию перехода из этого состояния.
То есть почему я против автомата?
Потому что в автоматах вот вы
перешли по какой-то букве,
перешли по новом состоянии.
Единственный способ сменить состояние,
это перейти по какой-то букве.
Здесь не единственный способ.
Здесь можно уйти в другое состояние,
просто совершившись диноз.
Это важно помнить, что это не перепадка в автомате.
Это именно возвращение по истории.
То есть когда мы достроим вот это дерево,
мы фокусируемся вот на этом деле.
Думаете об этом как о какой-то линзе.
То есть вы поставите линзу тут,
смотрите на этот кусочек.
Вот, и так пока дерево не будет построено.
Теперь немножко прямо теория.
Человек был в разборке,
если тут есть вопросы, скажите,
как бы вы строили LRK,
снова же, не единственный способ,
что я вам сейчас рассказываю, что это оптимальные способы.
Сейчас если кому интересно кайфа LRK,
довольно интересная вещь,
он тоже может строить состояние.
Там не будут даже инквилиции,
но при этом
сложно состояние тоже будет какое-то.
Эмоциальная машина остается.
Последний шанс задать вопросы
по поводу разбора,
и сейчас переходим к строению.
Да.
Смотрите, что такое свертка.
Вы когда были
в шестой юнс автомате,
вы забирали LRK,
вставили A.
Что означало, что
ваш префикс, который вы прочитали,
ваш вывод слова, которые вы сейчас отбираете,
вот как я говорил,
альфа-пет, и вы об это свернули.
Означает, что
в выводе до этого, тут
стояла альфа-а, и оно раскрылось.
Вы его спили обратно.
То есть вы идете пошагово назад,
пока не будет только с.
Будут только отсюда идти h3, кажется, что все закончилось.
Это так работает, как сверток-автомат.
Потом вы заметили, что
здесь проблема с историей.
То есть вы не вспомните при какой,
при каких обстоятельствах вы попадали в это
поддерево, когда вы его начали детализировать.
Вы были early, когда
мы его изучали. Мы
явно проверяли, а какая ситуация в этой ситуации
породить, и комплетили все.
Здесь комплетить все не надо,
потому что есть сезонная ситуация, которая порождает.
Сейчас я буду в определении.
Поэтому мы точно знаем, где мы были
в момент раскрытия этого правила.
Асад сюда вернулся и пройти там
по большой букве. То есть
когда вы делали разбор,
у вас шла буква A, она открывалась
как альфа, б, бета.
Вы тут все поделали,
ушли в это поддерево.
Сейчас...
Нет, да, вот вы альфу прочитали,
все полностью здесь раскрывали,
начали читать б.
Дочитали это концерт, там еще много шагов прошло,
вы ее свернули.
Впервые нужно почитать. Вы видите
такой большой прыжок через нее, но
этот прыжок совершается в состоянии, в котором вы были,
когда это право раскрывали.
То есть здесь, наверное, в дерево.
Мы читали этот перерыв, читали его пассивно.
Чтобы прочитать большую букву B, нужно прочитать
все его поддерево.
Надо вспомнить, что мы когда-то тут находились,
а где мы тут находились?
Вот в этом состоянии, вот оно.
Поэтому на стеке мы пишем состояние, в котором мы были.
Состояние отвечает
за разбор вот этого поддерева, вот он.
Соответственно,
когда вы дерево дочитали, вам вот эта история не нужна.
Но поскольку у вас справа до длины n,
n букв,
а тут у вас
правило-буква-правило-буква,
то чтобы считать правило, нужно считать больше символов.
Поэтому два n.
Ну что это за состояние? Это состояние, в котором вы начали читать
вот это правило.
Вот эта вот буква B, она тут возникала.
Сейчас будет ситуация, это будет виднее.
Надеюсь, что это пока на вопрос,
или отослал подождать до ситуации.
Вот, ну сейчас-то все прояснится.
Ну, раз уже до ситуации,
давайте о ситуации поговорим.
Что сделаем, когда ситуация не видна?
Это вот такой объект.
У нас есть
alpha.beta
и u.
Вот, где
astrel alpha beta
лежит f,
это какой-то правило в романчике.
Вот, и u
все, присоединен к братой.
И есть ситуация, то же самое, как и early.
Она означает, что сейчас мы обрабатываем
вот это правило, вот оно тут.
Точка дошла до позиции alpha,
u это означает,
какое слово мы ожидаем после этого.
То есть мы моделируем вывод.
Я это говорил в своей группе, сейчас скажу тоже тут,
что когда выводите слово,
выводите его слева направо.
У вас s3,
потом s,
alpha 0, alpha 1,
alpha n
равно омега.
Вывод правосторонний, то есть вы
всякий раз находите самую правую букву, открываете
самую правую букву, открываете.
Вот.
Собственно говоря, это означает, что в этом выводе
последнее правило вот такое,
за этим правилом,
за beta находится
слово u. То есть утверждается,
что фиксируя слово, которое
мы будем детально, мы однозначно
прям следующие правила в выводе.
Давайте посмотрим тут.
Пусть у нас там alpha i имела вид.
Так, alpha a,
омега. И потом оно
открылось в alpha.
Вот.
Собственно говоря,
давайте здесь чтобы не плються, поставим разные буквы.
Вот.
Ну то есть у вас
буква a, это маленькие буквы.
Самая правую букву была a.
Вы ее открыли по этому правилу.
Вот она открылась, омега осталась.
Дальше тут beta, где-нибудь еще будет большая
буква, вы будете открывать.
Вот. Значит мы говорим, что
вот эта ситуация возникает, если есть такой
вывод. И тут
первый k-букв это u.
Что такое первый k-букв, сейчас будет сказано.
Но, значит,
в темноте стека мы читаем,
читаем, читаем. Мы дочитали вот это.
Вот оно.
Вот очко.
И мы предполагаем, что этот стек
откроется вот так.
Тогда мы дочитаем дальше beta
и свернемся.
Вот.
Значит теперь вот это более формально.
Значит назовем активным префиксом.
Если
существует такой вывод,
но который порождает,
что-то у нас из s-штрих
выводится, насколько угодно, правил
правым образом,
вот так,
за один шаг
выводится,
за сколько угодно правил
правым образом,
вот так,
за один шаг
выводится,
за один шаг
выводится,
за один шаг у нас выводится
гамма, альфа, бет.
Вот.
И
здесь.
Так, использовать обозначение
двухразночника это плохая примета,
никогда так не делайте.
Вот префикс. Что означает?
Есть такой вывод, при котором этот префикс получается на стреке.
Вспомним, как работает шифр
вот эта вот штука из двух состояний.
Она читает, читает, читает,
читает буквы, в какой-то момент сворачивает.
Вспомним, это стэк.
На стэке можно только то, что находится
правее всего. Нельзя взять со стэка,
это середины. Поэтому, когда вы читаете,
вы со стэка
срываете край и ставите его.
Что тут означает в темных префиксах?
Вы наберете бета,
в какой-то момент вы решите, вот там
недетерминировано, а тут по набору правил,
что пора бы свернуть.
То есть, вы сделаете выбор
в пользу такого вывода.
Вот. Почему этот выбор
правильный? Ну, определение такое
будет.
Что вот такой вывод, он
однозначно определяется. Но
это активный префикс. Если существует
такой вывод, при котором
вы можете получить на стэке.
Лемма. Тут только активные префиксы возникают.
Эта лемма связана с шифрами
и автоматами.
Сейчас, наверное, доказывать не будем.
Вот.
Ситуация для префикса
является допустимой,
если, ну,
все, что тут написано, верно,
что это означает, что в этом выводе
последнее правило
имело вот такой вид.
У принадлежит ферстка
А,
В,
В,
В,
В,
В,
В. Это что?
Почему это буквы? Потому что мы букву А раскрыли.
Это означает, что она была самой правой.
Тут везде. Только маленькие буквы есть,
они навсегда фиксированы.
Вот. Что такое ферст?
Вот.
Гамма это
какое-то произвольное
строка здесь.
говорим, что first k от гамма это множество таких слов w, то из гамма выводится wx
и либо w имя длину k, либо x пустое. Что это означает? Если мы вывели длинное слово,
берем первый k-бук. Если вывели короткое слово, берем его. Для того, чтобы говорить,
что слово, которое мы вывели, оно действительно полное, будем ставить в конце доллар. То есть
в таком случае мы не ставим w и доллар. Это конец строки, это все означает, что такая
ситуация только в конце. Так, вот на этом пока есть время создать какой-то вопрос.
Вот так что, если хотите, задавайте. Ситуация допустима для префикса. То есть у вас будет
некоторая функция, будет обозначаться как v, k, g от гамма. Это допустимые ситуации. Другой вопрос,
что здесь нужно взять прям все допустимые ситуации, но это сейчас будет детализировано. Вот,
но вот эти множества потом превратятся в множество состояния вот здесь. То есть из множества
ситуации будет тихить множество ситуаций. Так, сейчас проверю, ничего ли я так. И тут.
И здесь надо еще кое-что посмотреть. Я сейчас хочу сверить обозначение. Неделю я не напутал.
Читаю альфа бета 1. Да, с определением вопросов нет.
Так, помимо ферз нам еще потребуется следующее определение. Зачем оно потребуется, скажу позже.
Ну, пока какая-то интуиция. Так, то есть или там от гамма. Кажется, там было два аргумента.
Вот EFF это такой ферз, при котором вам нельзя открывать первый не терминал, как пустое слово. Вот,
это нужно для того, чтобы правильно сделать функцию переходов. Ну да. Здесь есть два случая.
Гамма от одного, ну да, мы же программисты здесь все. Так, если гамма от нуля это не терминал,
то это ферст от гамма просто. А иначе, вот это такие слова омега, вот это вот все,
то из гамма вводится в омега х. Вот, но здесь важно, что тогда не терминал, вот обозначим его,
как А. И в этом выводе неверно, ну я не знаю, значит А не раскрывается, как эпсилон. То есть,
что означает? Вы хотите точно зафиксировать первую букву? Вот. Для чего это нужно? Когда вы
будете делать переход, для того, чтобы взять переход, вот, у вас будет стоять точка А, но я не знаю,
вот это еще что-нибудь, вот, ну и еще что-нибудь. Вы захотите здесь взять переход по букве? Что
есть переход по букве? Ну, чтобы эта буква была, потому что если вы делаете переход,
ну вот здесь у вас получается для first, у вас будет first тут, и если это раскрывается,
как пустое, ну, вот это вот раскрывается, как пустое слово, вот тут, то вы прочитали одну букву,
которая находится дальше. Ну, здесь пока какая-то интуиция, а именно как определение, вам нужно
скрыть А как пустое слово. Более того, не просто не раскрыть А, ситуация, когда у вас А выводит B,
и отсюда выводится пустое слово, тоже плохая. Вам нужно, чтобы непременно первый символ открылся,
хоть какое-то не пустое слово. Вот, пока можно в этом подумать. Да. Да. Это множество строк, как и тут. Это
такие строки, которые являются первыми к буквам от вывода гамма, ну, либо короче, если выводятся
короткие слова, но такие, что первый не терминал, если он действительно первый, не открывается,
как пустое слово. Он непременно открывается, как какое-то не пустое слово. Вот. А так-то откуда-то
first? Ну, здесь очевидно видно, что тут содержат только first, но не все. Вот. Так. С определениями тут мы все
поговорили. Давай теперь прилягай к грамматику. First, E, F, понятно, да? Да, нет, нормально. Так, куда
вы идти? Давайте сюда уйдем. Теперь вопрос, что эта вот вся машина работает не всегда. Основное
предположение алгоритма, что, подсматривая следующие каосимволов, вот они тут, ну, или меньше,
чем если мы в конце слова, можем однозначно определить, что происходит. Давайте это напишем.
Грамматика G, ну, пополненная, текстом свободная, это леркограмматика, если, значит, давайте
напишем, что мы ожидаем. Мы хотим, что, читая по стеку и подсматривая буквы, правило придется
однозначно. Но в определении мы не можем писать, что мы что делаем со стеком, потому что это
определение. Нужно писать в темных выводах. Предлагаю, что существует два вывода. Ну, тут,
вот так вот, существует два вывода. Стрих-вывод, сейчас аккуратно все это припишу. Так, ну что так,
маленький демотиватор, мне переписывать с конспектом можно, вам экзамене нельзя. Вот.
Ну, значит, вам тем более не привыкать. Так, если существует альфа, а, икс, что отсюда выходит,
это за много шагов правосторонним образом. Альфа, бета, это было проще. И, два вывода,
гамма, бета, икс, что отсюда выходит, альфа, бета, игрек. Вот, здесь напишем, что гамма это префикс,
возможно, не собственный альфы. Вот, а, икс, это, сейчас, как суффикс у вас обозначался на
алгоритмах? Вот так. Правда ли, что вот это префикс, это суффикс? Кажется, да. Вот. И,
ферст-к от у, то. Значит, что вот написано? Вот, если был какой-то вывод, вы шли-шли,
получили альфа, а, омега, открыли как альфа, бета. Вот ваш префикс. Что касается алгоритма? Вы
как-нибудь прочитаете? Ну, напоминаю, вводим мы вот так, парфим мы обратно. Прочитаете нас так
альфа, бета. И зададитесь вопросом, верно ли, что я могу бета свернуть вот так? Вот. Для
этих двух выводов говорить, что неверно. То есть алгоритм сейчас стоит перед некоторой дилеммой,
что вот если я вижу бета, я могу свернуть а, либо мне нужно прочитать что-то еще и свернуть
б. Значит, тут напишем, что у нас свертка по правилу альфа, бета, а тут свертка по правилу
б это один, бета это два. Вот. Более того, тут вывод за один шаг, а тут не за один. Ну, давайте
смотреть, что это означает? Вы здесь прочитали гамму, прочитали б, прочитали, ну, прочитали
б. Открыли б как вот это вот. Потом это два поразбирали, оно ушло в у. В какой-то момент у вас
доедет до б дело. И вот оно раскроется. Тут написано, что нужно бета смыть а. Тут написано,
что нужно дочитать слово до это два. Тут его свернуть, получить вот это вот это правило. Тут могут
быть как-то терминалы, так и нет терминалы. То есть мы читаем, читаем буквы. Здесь набираем вот это
вот. На стеке получаем это один, бета это два. Только после этого сворачиваем. Более того,
не только бета свернуть, как здесь. Вот здесь мы бета свернули и получили а. А еще больше
сворачиваем и закрываем на b. Вот. И сейчас это такие две проблемные ситуации. Как мы решаем
вопрос тем, что говорим, что такого не возникает. То а равно b, x равно y и ай. Сейчас, это не ай, а
а нет, вот так нормально. Гамма, b, x. Что это означает? Что последнее правило у вас вот такое. То есть на
самом деле, даже если вы клонируете символ и все его правила замените, то это уже описание
бетелярка грамматики. Потому что тут не будет понятно, бета откуда сказать в а или в b. Вот. А
здесь написано, что эта ситуация однозначная. То есть у вас символ одинаковый. Здесь слово,
которое получается одинаковое. Тут вывод за один шаг и правило тоже открывается одинаковое. Вот.
Еще раз. Вот активный префикс. И какие ситуации там не возникают? Вот такая ситуация там не
возникает. Вот если такая возникает, то такая не возникла. Ну какая ситуация? Вот тут будет
а, стрелка, точка, бета. Вот здесь бета с точкой ситуация. И вот у, вот эти вот first. А здесь
будет ситуация b, стрелка, это 1, бета, точка, это 2. И тоже какое-то у. Все настолько плохо,
что тут надо делать свертку, а тут надо делать не пойми что. Казалось бы, это два можно читать
дальше, а можно не читать. Ладно бы, если вопрос был только в том, что свертка или не свертка.
Дальше до свертки не понятно по какому правилу. То есть это пределение максимально плохое. Вот если
это все верно, то тогда агроматика и лерка агроматика. Да? То а равно гамма. Ну смотрите,
что у вас здесь получился вывод. Так что получили на стеке а, бета. Поскольку у вас последняя
буква одинаковая. Поскольку у вас последняя буква одинаковая тут. Да, туда у вас бета свернется и
здесь должно быть одинаково, потому что вы получили ровно бету из этого правила. Либо здесь могут
быть истории с тем, что это один пуст, но это время даже разрешается. Вот, поэтому явно этого не пишут.
Вот, кажется даже не нужно. Но я этого не проверял. Вот стоит вопрос вот это вот. Что из этого
выходит пустое слово? Наверное ничего. Ну пусть выходит. Тогда получается, что тогда этот стек
мы можем породить двумя способами. Главное, чтобы бета правильно свернули. Вот. Ну можно думать в
термах того, что здесь просто вывод был одинаковый. Вот. Я призываю, думаю, в таком ключе для
реализации это не повлияет. То есть в реализации вы будете знать, что вы читали бета, полюсь
определение вы свернете в А и дальше поведешь что-то читать. Сказал что-то непонятно, надеюсь
прояснилось. Да нет? Вот. То есть если есть два вывода, то тогда последняя буквы придется однозначно
и правила придется однозначно, по которому надо свернуть. Вот. Это повод определения. Так, поехали
дальше. Сейчас поговорим что-то про допустимые ситуации. Значит как их строить? Я пока не скажу,
а попробую сказать почему это будет потом работать. Просто теперь опять девять. Значит допустимая
ситуация. Здесь мало того, чтобы допустить, нужно брать замутые допустимые множества. Здесь сейчас
это буду писать. Так, здесь А это множество ситуаций. А замкнуто.
Если для любой ситуации вида А, стрелка, эта точка Б, лежащим А, существует ситуация. А, ну здесь для
любого правила Б в бета множество правил. Ситуация Б, стрелка, точка Б, уж стрих лежит в А. Теперь давайте
разбираться что тут написано. Тут было У. Что это означает? В выводе, который этим правилом
порождался, У стояло за этим правилом. Почему тут не то же самое? Давайте смотреть. Было штрих, из него
вывелось гамма штрих А В, из него вывелось это альфа В, и тут было У. Вот. Дальше это Б как-то раскрылось.
Мы при просмотре ситуации наблюдаем раскрытие этой буквы. Тут буква А, мы в это раскрытие провели, но тут
буква Б, поэтому нужно делать вывод еще на один шаг. Так, кажется нерационально использую доску. Да, это префикс, про
который хочется не думать. Он сейчас не очень важен, поэтому потерял. Так, это Б раскрылось в бета, но дальше
вот это. То есть до раскрытия Б нужно вот это вот все дело пораскрывать. Тут какой-то наблюдаешь штрих. То есть из вот этого
выводится слово, а только потом бета откроется. И смотрите. Рассмотрим вывод, в котором раскрытие буквы А
последнее, проявляет эту ситуацию. Вывод, при котором раскрытие буквы Б последнее, проявляет эту ситуацию, но вот
второй вывод длиннее первого. Почему? Потому что мы должны открыть А, потом открыть вот это, потом открыть Б. Но при этом,
по сути, при разборе стэка это одно и то же. Потому что вы видите, что этот вывод является сейчас префиксом этого вывода.
Поэтому, если у нас есть такая ситуация, так она должна быть. Она допустима. Почему она допустима? Вот он префикс,
вот он тут. Вот этот же префикс. Просто тут точка стояла вот здесь, вот она стоит вот здесь. Потому что это
правила. А тут он стоит вот здесь, в том же самом месте. Мы слово прочитали настолько же,
насколько и здесь. Просто в тернах правила оно вот в самом начале. Почему? Потому что b раскрылось,
но то, что b открыло на b, вот этот вот bet, оно еще не прочитано на stack. Вот поэтому здесь точка в
начале. А что такое u-штрих? Ну здесь видно из картинки, что u-штрих это first k, вот альфа u.
Ну почему u? Тут понятное дело, что дубля могла быть длиннее, но на такую достаточно. u это уже хотя бы k
символов. Вот, здесь, надеюсь, понятно, почему тут разные слова будут. Вот, значит, вот это,
здесь мы допишем, что допустимые ситуации. Замкнутое множество. Так что такое, на самом деле,
WKG? Это замыкание множества допустимых ситуаций для гаммы. Что такое замыкание? Берем все допустимые
ситуации, берем всех замыканий, берем ничего другого. Ну там, было такое, окажется в мотоне,
везде такое, вот стандартная техника. Вот, как это строить, но сейчас становится понятно. Нужно
смотреть все выводы, брать все последние правила, замыкать, потом снова замыкать, так пока не
дойдете до конца. Это в теории, в какой-то диапратики сейчас еще будем говорить, но вот такое вот множество.
Вот оно тут. И последнее, что нам нужно, ну вот на самом деле, здесь action. Мы уже на самом деле построили,
зная, что мы находимся в ситуации S и первый K-букв, мы обращаемся к правилам этой ситуации,
смотрим K-букв тут. То есть, если эти K-букв, вот эти вот, совпали вот с этими K-букв, тогда мы
говорим, что мы сейчас избираем одно из этих правил. Ну а тут, правда, явно говорит, нужно ли
делать shift или reduce. Что такое reduce? Если тут находится ситуация вида B что-то, точка, точка
или в конце, это reduce. Почему? Потому что последнее правило в выводе прочиталось полностью. Вот, если вот это
все уберу, что это означает? При выводе мы откроем букву B, откроем это, и правило кончится. То есть,
не читая ничего. Вот, это уже прочитано, делай reduce. Почему версия делает reduce? Потому что эти K-букв,
мы их ровно тут и видим. А что такое shift? Смотрим на EFF от вот этого. Если вот это вот все, вот это все
слово, при раскрытии этой буквы, как не пустое множество, попадает вот сюда, тогда мы должны читать.
Для чего важно, чтобы это было A, не отрывать пустое множество? Потому что если A пустое, то мы его
проскакиваем, читаем букву тут. А мы этого не хотим. Мы хотим начать читать букву A. Вот это был
нужен EFF. Вот, так будет построен разборщик. А пока, да, точка перед A. Смотрите, это означает тут,
что вы хотите начать читать что-то с буквой A. Вам надо опять спричтать первую букву. Вам нужно
быть уверенным, что эта буква попадает сюда, потому что мало ли эта буква оказалась тут. Для этого
вы ввели EFF. Тогда вы проверяете, что если ваше слово, которое вы видите здесь, вот оно тут,
попадает в EFF от вот этого всего, от этой тройки. Когда вы уверены, что вы начнете читать правила
с буквы A, вы прочитаете. Ну, тут с буквы A рядом шатались какие-то ситуации вида точка альфы,
там что-нибудь. Ну, потому что вот так вы в этом замыкании. И вы вот здесь эту букву прочитаете.
Ну, здесь, либо еще где-то пониже. Мало ли тут еще большая буква а штрих. Здесь утром какие-то
ситуации. Вы прочитаете первую букву, которая скроется здесь как терминальная буква. Дальше
совершите редьюс, совершите переход вот по этой букве, маленькой букве. И перейдете в ситуации,
где у вас на буква будет сайд-оксант. А это вы уже как бы забудете. И начнете читать вот это правило.
Это соответствует деревья разбора тому, что вы тут, вот тут стоит большая буква а штрих. Вы
стоите тут. Буква маленькой нет. Идем еще ниже. Тут А2 штрих А. И так пока здесь не будет какая-то
буква маленькая А. Увидели букву, перенесли точку. Спокусились на этом по дереве. То есть в этих
ситуациях, как мы дальше заметим, про B ничего неизвестно вообще. Вот. А теперь вопрос, а когда мы
прочитаем букву А, как вернуться обратно сюда? Ну а мы это уже знаем, потому что тут на стейке,
вспоминаем, у нас стоит 0, X1, S1, X2, S2. И когда вы заредюсите все это, вы будете знать, что когда-то
где-то возникало B. Вот он B. А здесь мы будем на стейке в состоянии S1. Вот вы это все тут закроете.
Поймете, что вы сделали букву А, сгнидивали ее. Идете в переход. Этот переход соответствует тому,
что пронесли точку сюда. Вот она. Точка пронеслась. Для этого на стейке это все нужно помнить.
Вот. А теперь следующий вопрос. А что, если вам в вашей ситуации говорили две разные вещи? Вот.
По такой ситуации нужно делать shift, а по какой-то reduce. Приведу пример. Пусть у вас в AKG попали
две ситуации. Первая ситуация вида beta.u, и вторая ситуация вида... Дай, чтобы все совсем было плохо.
Вот здесь. Да, вот достаточно. И здесь вот так вот. Так, питон был. Вот оказай без знакома.
С первой буквы. Вот. И у от нуля равно А. Вот это как раз больше. Смотрите, что я должен сделать. Я,
видя слово u, должен сделать B. Или видя слово u, должен прочитать букву А, которая является первой
буквы слова u. Ну, тут понятно, что от одного до... Еще, чтобы была одна буква, это как-нибудь
буква B. Потому что была K-буква. То есть алгоритм посмотрит, что если ты видишь здесь слово,
которое сопалось с этим словом, и правильная точка в конце, то она идет reduce. То есть такая
ситуация означает, что где-то был вывод, заканчивающийся, на вот такое правило,
которое читается полностью. Но это значит надо сворачиваться. А эта ситуация означает, что
если где-то был вывод, чтобы закончить это правило, нужно прочитать еще букву А. И такое же слово
вот А и u от одного до конца слова. Эти два слова одинаковы. То есть при прочтении тут K-букв,
вы их не отличите. То есть вы не поймете у вас такой вывод или такой вывод. Да, и вот здесь ты будешь
как раз-таки играть, что эти две ситуации не возникнут. Это теряем 5-9, сейчас я буду выписывать.
Но для того, чтобы гарантировать, что это не возникает, вам и нужно ходить эту букву У.
Ну давайте сейчас какой-нибудь маленький пример для того, чтобы вы поняли. Почему не
всплывает? Вы по этому У определяете, какой шаг нужно сделать. Так, давайте какую-нибудь грамматику
рассмотрим. Верно ли, что вы придумали LR0 и не LR1 грамматику в домашнем задании? Давайте посмотрим,
что у меня там пристали. Это сейчас разберем. Ну, Георгий неправ, что поделать. Так,
ну про сейчас покажем, что тут нельзя делать LR0, можно LR1. Так, и BFA, CFA. Так, ну я позволю
себе добавить сюда вот такое. Так, и все. Давайте смотреть. Ну давайте начнем строить VKG. Мы видим
ну теперь какое-то нулевое множество ситуаций. Заодно и научимся пока строить эти допустимое
множество. Пока теряем 5-9 остается чуть дальше. Нет, смотрите, я сейчас делаю LR0 разбор, покажу
проблему. Потом сделаю LR1 разбор, покажу, что проблемы нет. Значит, ну кто не знает, это не LR0,
но LR1. Вот. Кто с этим сомневается, могу представить домашнее задание этого студента, там это все
доказано. Здесь, ну поскольку у нас слова пустые, я их не буду писать. Тут визитолы расстоят,
ну эпсилоны. Вот, этого не будем делать. Вот, давайте это замыкать. Ситуации. Ну любовь
нашей ситуации вот такой. Ну я пишу VKG. Вот оно. Ну я пишу ситуации допустимые для пустого префекса
сейчас. Да. Просто сейчас эти префекса не буду выписывать, а просто буду писать ситуацию, буду
как-нибудь переходить. Вот. Содержать, например, будет чуть позже. Ну давайте, для простоты,
это эпсилон. Замыкаем. Видим правило s.b. Пишем точка b. Значит, о букве тут я не думаю, потому
что это LR0 разбора, только смотрю на 0 букв вперед. Кстати, интересное замечание. Здесь, при LR0
разборе, вы определяете, что нужно делать, не глядя вообще на слово. То есть, что нужно делать
со стеком определяется однозначно. Если откроете нирк, там вот люди пишут таблицу какую-то. Давай,
как бы, понять, что мы по букве определяемся. Это неверно. В примере на нирке, если в строке
встречается редюс по какому-то правилу, там редюс по этому правилу встречается. А если shift,
то тут у нас разные шифты, ну вот функция g. То есть, не обманывайтесь. Вот, когда будет
стоять LR0 на нирке, там будет таблица. Но эта таблица в строке, все это определено вообще не зависит от
буквы. Ну вот здесь давайте разбирать дальше. S.C.C. Открываем дальше. B.A. Я до конца это не доведу,
я просто покажу противоречие. Ну смотрите, видите, я открою все, как тут написано. Вижу точку,
открываю. Вижу точку, открываю. Теперь давайте посмотрим. А для перфекса A. Забирая в будущее,
это будет go to. Но сейчас мы вот так не назовем. Для перфекса A мы должны взять, может быть,
ситуацию. Как мы это делаем? Смотрим, где можно пройти по букве A. Мы тут будем ходить по букве
A по слову, а тут принесем точку. Вот принесли точку. Значит, здесь B.A. с точкой C. Ну, что такое
перфикс A? Это перфикс Эпсилон с добавлением буквы A. Как прочитать букву A? Нужно найти правила,
в которых она фигурирует, и прочитать ее. Вот. Почему это верно? Это такая отдельная теория,
мы сейчас будем доказывать. Ну, вот так строится ваш стрелять в ситуации. Для Эпсилона оно строится
тем, что берете вот такую ситуацию всегда. А потом замыкаете ее, а потом делаете go to по
разным буквам. Например, что здесь можно делать? Go to по S, go to по B, go to по C, go to по A. Но я еще это
все делаю, так еще после перфекса противоречия. Если будет необходимость, можем это тоже разобрать.
Так, значит, ну, по букве A. Перенесли, перенесли. Ну, запятая там пустое слово, и бог с ним. Ну,
а теперь, вот мы находимся тут. Тут чисто технически, смотря на слово, смотрим, ноль букв. Ноль букв.
Эпсилон. Верно ли, что Эпсилон совпадает с Эпсилоном вот здесь после запятой? Ну, верно, потому что Эпсилон
один. У меня есть две команды. Reduce такой, Reduce такой. И все, я не знаю, что мне делать. Вот оно
противоречие. А в тернах вывода означает, что вы могли открыть букву A как AB и как AC. Существуют два
вывода. И не важно, что тут слова разные. Вот здесь мы даже слова еще не дочитали, а мы не знаем, что делать.
Это не LR 0 грамматика, потому что вот оно противоречие, явно видно. Да, вы не понимаете, какой Reduce
сделать. Вы можете делать Reduce, но просто можете делать больше, чем нет Reduce. Вот это пародит вам
Reduce 0, 1, 2, 3, R3 команду. Это пародит R4 команду. Конечно, выполняя любой из этих команд,
номер правила 0, 1, 2, 3, 4. Ну, как тут написано? О, ну уже не написано. ROT по этому правилу.
Вот. Понятно дело, что здесь мы прочитали букву A, а дальше будет буква B. Надо делать Reduce такой, а если
буква C, Reduce такой. Но мы-то букву B еще не видим, нам нельзя его смотреть. Это же LR 0. И поэтому тут
противоречие. А в терминах подглядывания что произойдет? Давайте посмотрим. Так, значит здесь будет
доллар. Потому что, если мы видим такой правильный конец, значит тут замыкает, тут ничего нет, поэтому тоже
доллар. И тут тоже доллар. Почему я пишу доллары? Потому что, когда я замыкаю, я смотрю, что находится после этой
буквы, чтобы раскрыть. Ну вот тут, смотрите. Тут был U, вот он был U, а осталось U3. Вот U3 определяется тем,
что находится после буквы B. Но тут после буквы A ничего нет. А вот здесь уже есть буква B. Видим букву B,
пишем сюда запятая B, запятая A. Что? Да, запятая C. Вот. Смотрите, в этом правиле, в этом правиле всегда такое.
Значит, S.S запятая доллар. Почему? Потому что после буквы S слова нет. Все слово содержится тут. Вот. А дальше,
как я тут писал? Замыкаем. Пишем правило. Какая стоит дальше буква? Эта буква состоит из двух частей.
Часть после буквы S правиле и часть, которая стоит после запятой. Пустое слово, пустое слово – это пустое слово.
Тут B и пустое слово – это B. Так. Ну, здесь пустое слово, пустое слово – это пустое слово.
То, что написано. C пустое слово – это C. Теперь вы видите, что вы отличаетесь с ситуацией.
Давайте посмотрим. Глуту по букве A. Парадит нам… Ну, то, что LR1 работает за линию – это тиремма,
которая доказывается. Вот. Сейчас я говорю теоретически. Строить это нужно оптимально,
поддерживая аккуратно first и везде аккуратно проставляя. Вот. Об этом поговорим к концу
семинара ближе, пока я хочу именно теорию разобрать. Это первое. Второе. Это последний таблиц.
Оно один раз делается. Оно может сделать сколько угодно сложно, но разбор потом будет линейный.
Это классно. Вот. Но вообще, вот эта вот вещь, она, кажется, работает порядка квадрата от количества
правил. Что-то такое. И еще на константу K, которая там везде тащится. Возможно, K в какой-то степени.
Я не осуждаю об анализе пострения этой таблицы, потому что это константно все. У вас от длины слова
это не зависит. У вас парсер, он работает в терминах как функции от длины слова. Вот это все от длины
слова вообще не зависит. У нас, значит, от C – от грамматики. Ну, не от C, от K – от грамматики. Вот. Это все
константы. Поэтому вот эта вот вся богадельная уходит сюда в констант и забывается. Кому интересно,
быстрее? Ну, вот так. Там уже состояния не будут множественными ситуациями, там будет что-то более
хитрое. Ну, а тем не менее. Вот, продолжаю здесь. Прошли по букве A. Вот здесь прошли по букве, а дальше
видим букву B. Видим букву C. Ну, что это означает? Если вы видели вывод, при котором это правило последнее,
зададим, что буква B. Если мы хотим, чтобы префикс расширился, мы в эту префикс эту букву добавим.
Но это же правило. Это все еще тот же самый вывод. Просто мы на него смотрим с точки зрения более
длинного префикса. После этого, правда, все еще B и C. А теперь то, что вы говорили. Подсматривая букву,
вы понимаете, что это Reduce 3, а это Reduce 4. И теперь вы можете это точно сказать, потому что у вас эта
буква есть. K равно 1. Видите B? Делайте Reduce 3. Да и Reduce 4. То есть слово U помогает разбить ситуацию на два
множества. Вы здесь противоречие, вы его разыгнали, вы его разрешили. На празднике что происходит? На
празднике люди пишут сначала ли разбор, если видят, что есть противоречие, что-нибудь делают, чтобы его
избежать. Никто не про это определение. Но я-то в конце тоже еще скажу, что как проиграть грамматика
LRK или не LRK. Запустите всю эту машину и посмотрите на таблицу глазами. Так, тут вопрос, надеюсь, нет.
Зачем нужно U? Разобрали. Так, теперь LRK. Ладно, давайте еще один вопрос. Диарею мы еще дальше оставим.
Как, значит, мы построили с вами VK гамма для всех перфиксов. Как мы построили? Построили для
Апсилона. Посмотрели, что в эту песню можно добавить. S, B, C, A. Вот. Добавили все это. Посмотрели какие-то
VK от S, VK от B, VK от C. Дальше, для них там тоже рекусины еще построили. Вот, значит, здесь существует, ну,
поскольку это LRK грамматика, существует теорема, что это процесс остановится, вы посчитаете все VK g.
Дальше вы говорите, что VK g, пронумерованные от гамма, это состояние. Вот они тут. Определяем функции
перехода, если состояние, в котором вы находитесь, которое вы знаете, потому что LRK как функции,
находится правило вида, ну, ситуация вида, не терминал, строка, точка в конце, какое-то слово U,
то по этому слову U вы тут пишете reduce. По какому правилу reduce? Ситуация определяется каким-то
правилом. Вот по этому правилу reduce будет. Дальше, это первая ситуация. Если вы видите здесь ситуацию вида,
ну, как я там писал, ну, что-то, точка, там, буква U, и ваше слово тут подает множество EFF от вот этого.
Здесь может быть дальше что угодно. Ну, давайте, ставим эту, чтобы вы не путались. Вот, 4EFF.
Надо делать shift. Что еще надо делать shift? Вы букву переносите, тут эта точка, точка пройдет дальше,
внутри буквы A, там какие-то правила будут. На самом деле, если у вас есть такая ситуация, то она же вам
по замыканию пройдет до другой ситуации, в которой когда-нибудь возникнет вещь вида, там,
какой-то штрихов, и здесь наконец-то найдет будет маленькая буква. Вот по эту букву вы shift'ете,
но вам это не нужно знать, потому что эта буква не явно прописана вот здесь, в этом EFF. Эта буква
появилась вот тут, и эти слова просто сравнили глазами. Слово, которое тут возникает. Вот, значит,
тогда надо делать shift. Вот, если ни одна ситуация не возникает, то тогда надо делать reject. Ну, на самом
деле, принятие accept это reduce 0. Если у вас возникает вот такая вот штука, то просто тут S, тут S, тут S.
Как делать переход? Ну, мы знаем, как делать. Вы делаете shift, если верно, что ваш аргумент
попадает вот сюда. EFF от вот этого. Как это думать в жизненных терминах? Надо найти вот здесь,
вот такую ситуацию. Она точно тут будет. Потому что когда-нибудь вам же нужно эту букву раскрыть,
а, аш три, а два штриха, а три штриха. Вот, если она никогда не закончится, то понятное дело,
что эта ситуация, по ней shift просто не работает, там reject будет. Сейчас, потому что эта ситуация
просто недопустима. Вот, но надо искать вот это. По замыканию, смотрите, вот. K букв. Да, вот K букв.
А состояние, вы состояние берете ситуации. Если такая ситуация есть, то такая ситуация тоже возникнет.
Тут есть небольшой вопрос, тема, что если у вас есть не терминалы, которые вообще никак не водят,
то тогда тут EFF просто пустой. Ну, то есть EFF это такой кастель для теории. Для практики вы просто
должны найти вот такую ситуацию и явно эту букву прочитать. Вот, а для теории вы видите,
что если есть такая ситуация и улежит EFF тут, то все верно. Так, здесь, надеюсь, вопрос опал.
А как-нибудь куда идет переход? Когда вы не нашли не вот это, не вот это. Режет означает,
что ваши конфигурации здесь, буквы, которые тут следуют, они никак не подозревают наличие
буквы U, наличие вот этой строки U штрих. Почему? Потому что, если бы был вывод, в котором эта
ситуация реально возникает, то есть там что-то происходит в конце U штрих, вот, строки в конце U
штрих, вот, если такой вывод есть, то вы этот вывод изучили и вы его здесь описали, что тогда вот этот
вот U штрих попадает сюда, либо попадает вот сюда. А если вывод тут нет, это означает, что этот вывод
просто не существует. Он существует не как вывод, даже не существует как последнее правило. То есть это
в принципе невозможно получить. И алгоритм, вот, ну, теория 5.9, о которой я сейчас постоянно уже говорю, говорит,
что если существует вывод, то обязательно такая ситуация будет допустим. Ну, на самом деле это
из определения более-менее следует. Сейчас. Да, это же допустимые ситуации. Вот, поэтому если уж вывод есть,
о котором вы хотите его получить, то ситуация должна быть допустимой, а у вас-то неверно. Тогда значит
вывода нет. А если вывода нет, значит ничего делать, ничего не делать. Отвергать. Не дочитывая слова до конца,
нам это даже не нужно. На, в этом случае, на это правило, в случае на это правило. То есть оно, какое правило
сейчас обрабатываете? Выше по дереву были другие правила. Эти другие правила помнится в соответствующих
состояниях. Вот, смотрите, в вашем примере, эта ситуация, эта множество ситуаций ничего не знают про вот
это. Когда вы прочитаете букву Y, вы взяли reduce, и сюда вернетесь, и тут взяли shift точки по B и точки по C.
А, ну что такое shift? Жк переход, функция g. Ну здесь все тривиально просто. Значит, из ситуации гамма по
букве X, какая бы она ни была, назовем вот такое множество Vgk. Вот. Ну, удивительно, правда? Что перейти по
букве X надо просто сюда добавить. То есть go to по букве X, это может быть ситуация для такого префекса.
Мы префикс расширили. Здесь в терминах вот у вас этот префикс расширяется на букву a маленькая, а тут на
букву b большое и c большое. Ну вот оно здесь происходит. Вот отсюда рождается функция g. Вот здесь. Ну как она
рождается? Подставляете сюда ситуацию S, сюда подставляете вашу букву, какая бы она ни была,
большая или маленькая. Получается множество ситуаций. Если мы утверждаем, что мы знаем алгоритм,
который находят все Vkg, то мы утверждаем, что мы go to полностью построили. Так, теперь термин 5.9,
наконец. Дожидались, да. Так, кто не уснул? Михаил уснул.
Бывает. Так.
Теремок, агрегнация алгоритма.
Ну вот на самом деле, кстати, кто в моей группе, вот здесь вот это все, это суть последней замашки.
Все-таки была шипка, я считаю, что на прокреке это можно не делать.
Ну вот некоторые будут делать тесты, они все это сделают все равно. Так, 430, 435, что-то буду искать.
Первый том. Ну давайте его формулировать.
Если грамматика, это LRK-грамматика, то. Даже не то, а тогда, только тогда.
Для каждого слова, длины K или меньше, верну следующие условия.
Какого условия верно? Пусть есть активный префикс.
Альфа, бета, активный префикс. Что такое активный префикс? Напоминаю. Это такой префикс, который
встретится в выводе на стеке. Ну вот тут у нас был гам-альф, а тут там будет альфа-бета. Просто здесь
мне бета нужно было тут, поэтому я приехал с обозначениями. Есть это активный префикс.
Префикс для цепочки слова. Альфа, бета, W. Слушайте для этого слова, что сразу после него,
вот какое слово получается. Альфа, бета, W. W это какие кабухи мы дальше будем видеть.
И для него допустимые ситуации.
Какие ситуации для него допустимые? Вот такая ситуация, как бета, точка, U и вторая ситуация.
Ну сейчас это ровно то, о чем я говорил. А1, бета, точка, вот так вот. В, причем
упина лежит вот такому множеству. Ну здесь, только к примечанию, бета 2, возможно, пустое. Возможно,
вводит пустое слово, тем не менее. Вот. Ну вот это невозможно. Да, на самом деле,
это пределение с соопределением. Ну просто вот это пределение нужно там построить.
Вот сейчас нужно где-то некоторые зуборубительные выкладки для этого. Но в чем смысл? Смотрите,
то же самое, что тут было. Такая ситуация, вот она тут. Это что? Это reduce. А такая ситуация,
если бета 2 пуст, то это тоже reduce. Если бета 2 не пуст, ну если бета 2 пуст, то у вас не EFF,
а просто first от W. Если бета 2 не пуст, это EFF, это shift. Это shift, это reduce. В таблице возникнут
две команды. Вот они. И мы говорим, что если допустимая такая ситуация, то такая ситуация
недопустима. Вот. Мы хотим, чтобы они не попали на время на множество. Тогда мы говорим,
что в множестве лежит либо это, либо это, либо ничего, потому что они временно лежать не могут.
А это означает, что у нас либо reduce, то в чем однозначный reduce, либо shift, либо ничего нет,
то есть reject. Вот такая вот теорема. Что, будем доказывать? Давайте докажем. Я тут не очень
знаменитого качества. Доказательство Лемма Огдана это значение от Л-10 на экзамене. Ее решают часа 3.
Ну, вы понимаете, что любая значение от Л-10 на экзамене решается не менее трех часов. Конечно,
Георгий над вами прикалывал осознанно. Наверное, он занят усадьбе миллион баллов, я так думаю.
Что-ли тоже Лемма Огдана, что ли, доказывать? Значит, необходимость. Ну, пусть, наверное.
Так, давайте сейчас все это рассмотрим. У нас есть две такие ситуации допустимые.
Значит, два ситуации допустимые. Существуют два вывода. Для этой ситуации, как выглядит вывод,
альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-
бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, альфа-бета, аль
фа-один, бета-один, сейчас, да, вы раскрыли как альфа-один, бета-один, альфа-один и бета-один высвернули в альфу, вот он тут, получили как-то бета-два, правильно-неправильно, альфа-один, бета-один, да, вот оно, вот это же, альфа-один, бета-один, бета-два, х, ну, вот это, вот это и теперь все одинаковые,
вот и буквы одинаковые, ну, у нас, сейчас, омега, х, это те буквы, которые там находятся дальше, ну, здесь, на самом деле, мы это не пишем, потому что тут уже написано, что эти ситуации обе возникли вместе в выводе, написано, что, ой, это еф-эф от бета-два,
так, где, вот тут, в определении, тут, да, ну, и здесь уже написано, что K-букв совпали, вот это написано, ну, поэтому здесь я это не пишу, не то, чтобы префиксы, у них K-букв одинаковые,
ну, я не знаю, что там, бог знает, что, что происходит, вот, ну, здесь, first K-букв равно U, ну, все по классике,
first K от х равно V, вот, и альфа-бета, это альфа-бета-один, да, альфа-один-бета-один, да, здесь у меня будет небольшой косяк, вот, то есть, не обязательно, что у нас именно альфа получается, важно, что,
важно, что вот это, вот это и вот это совпали, вот оно тут, ну, то есть, мы получили префикс альфа-бета двумя способами, ну, давайте посмотрим разбор случаев,
забудовительных два случаев, ну, тут нужно, на самом деле, сказать, что если это два редьюса, то сразу запределение следует, что они одинаковые, если это shift и reduce, то тоже запределение следует, что они одинаковые, вот,
три случая, они как раз таки выглядят, что это два редьюса с одной длиной, два редьюса с разными длинами и shift и reduce вместе, ну, понятное дело, что два шестаника фликтует, потому что если вы читаете букву, то вы ее просто читаете,
в этом случае один, бета два пуст, бета два пуст, так, давайте смотреть, так, отсюда следует, что если у нас бета два пуст, смотрим сюда, этого нет, значит, вот эти штуки одинаковые,
что уравновое, ну, то есть, раз вот эти вещи одинаковые, то тут первые буквы совпали, а если первые буквы совпали, то вот они вместе равны, вот мы же хотим сказать, что эти два правила в итоге выводят под строку альфа-бета-омега,
в чем тут кроется проблема, вот это альфа-бета, а омега она вот здесь, а если бета два у нас нет, то омега она вот здесь, значит, у и вы равны, так, значит, и вывод имеет вид,
из стрих альфа-а-омега, альфа-бета-омега, или с опуска, если вдруг возникает вопрос, задайте его обязательно, вот, и first равны,
начну, и там, так, поскольку ситуации различные, либо а не равно а один, либо бета не равно бета один,
давайте смотреть, ситуации разные, а бета два у нас нет, значит, у нас либо это не одинаково, либо это не одинаково, ну, либо оба, ну, вы понимаете, что в обоих случаях у нас
определение сломалось, что такое определение, у вас и буквы равны, где-то тут оно было, кажется, оно было, но мы его стерли, ну, вот, если вспомнить определение, у вас и буквы равны, и получаемые кусочки префикса равны, вот эти суффиксы префикса тоже равны,
в этом случае у вас буквы, в этом случае префикса, ну, все, вот это противоречие определению, g не lrk, это понятно сейчас?
Почему уровно v? Значит, пусть бета два пустой, если бета два пустой, у нас вот этого нет, вот, а тут следует, что раз мы выводили одинаково, то здесь мы, ну, слова, возможно, разделены, ну, просто по рассмотрению, кажется, что даже ω вну иксу, но нам это не нужно думать, мы здесь говорим, что,
вот, получаемое слово одинаковое, претензия тоже одинаковая, значит, что у него first одинаковые, тут first равно вну, тут first равно v, и значит, у и v равны, поскольку, вот, ω, оно, на самом деле, сопроводит вот этим, если этого нет, сопроводит в том, правильно-неправильно?
Вот, я сейчас боюсь сказать, что ω равна иксу, но мне сильно хочется отверить, вот, ну, если мы говорим, что мы выявили одно и то же слово, здесь, на самом деле, могут возникнуть проблемы с тем, что у иксе могут быть не терминалы, которые как-то потом раскрываются, вот, но именно то, что тут first равны, оно следует именно отсюда, вот, как вы сказали, у нас бета два нет, поэтому, eff, а у нас иксу, у нас иксу, у нас иксу, у нас иксу, у нас иксу, у нас иксу, у нас иксу, у нас иксу, у нас иксу, у нас иксу, у нас иксу, у нас иксу, у нас иксу, у нас иксу, у нас и
treatments, вот та партия выхода of actions, и, в Zugen е, е в иксу, е в иксу, е икс 대� дна, е ана икс, е икс икс, о riders, е е икс, е икс для негативных или в икс для негативных или beleza, chooses m
shirts for the ears and inks for that,
и там объясните, почему у вас правильное
работопустение в ЭКЖ, и вас вот это не
примет, то можно позвать меня. Я там поругаюсь,
чтобы это тоже принималось. Не одним автоматом
следует человека, говорят, в случае 2.
Ну, я готов принимать что угодно, если там
будет понятно.
Так.
Beta2 это просто строка.
Именно строка из букв.
Из терминалов.
Что это означает? Что тут написан shift, тут
написан reduce.
Beta2 равно z.
That's what it is.
Обозначим его так.
И выводы имеют вид.
Так, из штрих
α, омега,
α, бета, омега,
из штрих
α1,
а1х и дальше
а1х1, а1бета2, но это явно напишем.
α1, бета1, zx.
Почему тут перешел от греческой буквы к английской
букве, чтобы понять, что это строка из маленьких букв.
Вот.
Ставим равенство.
Этому тоже уже знаем.
Так, и
EF меняем на first.
Так, есть шанс у кого-то в зале показать, что он все понимает,
и писите, почему тут не EFF, а first будет написано.
Да, выдавая слово точно не пустое.
Не терминала нет, поэтому по определению EFF все одинаковые.
Так, а равно у.
Так, давайте покажем противоречие.
Так, хочу что-то, с чем не совпадает.
αa за x.
Точно не равно чему.
α1
и
1x.
Так, что тут написано?
Тут написано, что если бы это было LRK-грамматикой,
то поскольку мы здесь получили одинаковые префисы,
одинаковый кабух, то должно быть одинаковое правило.
Получается, что справа написано одно и то же.
Вот.
αa за x.
Отсюда следует, что в этом выводе
до свидания.
Подставим вот этот zx
и попробуем вот этот по a.
Так это LRK-грамматика, эти выводы должны быть одинаковые.
Означает, что это и z можно получить.
А эти вещи не совпали.
Так, как z не пусто?
Ну, видите, тут поскольку заднее пустое,
вот тут x букв, а тут стоит не терминал,
а тут стоит терминал.
Эти стоки не равны,
а это противоречие определению.
У нас в определении требовалось, чтобы...
Давайте здесь выпишу еще раз для того, чтобы...
Сдает 40 из маленьких букв,
а 1-то большая буква.
У вас изначально...
Вот ситуация.
Здесь хорошо бы написать...
Это явно противоречие.
Мы требовали αy, но γbx.
Начну там пишу α.
Это было определение.
Ну, вот оно у вас αay.
Вот это, это, это.
Вот это, это, это.
Ну, то есть, явно в определении мы требовали, чтобы эти выводы...
Оно значительно определяли последние правила.
Это означает, что...
Оно значительно определяли ста, которые мы видим.
То есть, если тут одинаковые ферсты,
то тут должна открываться одна и та же буква.
Точно до того, что если вдруг у нас
между этими выводами с префиксами один другого,
то есть а1 получается из а правилами гида.
Вот.
А1, что-то, давай так, а штрих, что-то из а штрих получается там,
а2 штрих, а что-то.
И потом в итоге получается а1.
Поэтому явно сказать, что прямо один этаж живой нельзя.
Бывают такие ситуации.
Вот. Но здесь просто задний терминал.
Это значит, что строки, которые мы тут видим, они разные.
Это просто противоречие с определением.
Я вот это выписал, потому что сейчас сам в этом немножко сомнился.
Вот. Ну, тут это видно.
Букво есть определение. Можете сейчас вот там подтвердить,
предоставить и увидеть, что ровно это мы и требовали.
Так, где оно еще раз?
Альфа АХ.
Вот он. Вот это, это.
И гамма БХ.
Гамма БХ вот.
Что-то такое.
Так, ну это второй случай, третий случай совсем будет попроще.
Так.
По поводу случаи два. Надеюсь, что стало понятнее,
что происходит. Ну то есть,
эта ситуация соответствует тому, что тут мы делаем шифт
и делаем продюс.
А в первом случае это два шифта.
Ну и давайте где-нибудь сделаем третью ситуацию.
Третий случай. Вот этот самый несодержательный. Мы его сотрем.
Существует не терминал.
Принадлежащий чему?
Бета два.
Последний случай.
Строка не просто не пустая, еще и слезательная не пустая.
Ну тогда следует, что здесь, чтобы взять редюс,
нужно сначала бета два как-то свернуть, а только потом
сворачиваться в А1.
Ну здесь это явно написано.
Бета два у нас выводит, что
Б у3,
У1, У2, У3
и
У1, У2 не
Эпсилон.
Ну то есть, это вывод содержательный.
Так.
Как
не терминал B не
меняется
на Эпсилон?
Почему на Эпсилон не меняется?
Потому что в EFF явно написано,
ну ладно, тут уже не написано, но было написано, что
первый самый левый терминал на Эпсилон не заменяется.
Мы гардерно читаем K букв.
В случае с одной буквой мы прочитали одну букву
и были уверены, что эта одна буква точно есть.
Тут мы уверены, что K букв точно есть.
Так есть два вывода.
Первый как будто и остался.
Альфа, бета, омега.
Второй вывод стал сложнее.
Альфа 1, бета 1, бета 2, х.
Альфа 1, бета 1, бета 2, х.
Альфа 1, бета 1, бета 1, бета 2, х.
Я пропущу тут два шага.
Бета 1, У1, У2, У3, х.
Ну то есть,
вот этот вывод поставили сюда.
Альфа 1, бета 1 равно альфа,
альфа, бета, как было до этого.
В определении
из определения
из определения
из определения, что мы требовали?
Так что тут целая куча длинных срок одинаковых.
Альфа, А, У1, У2, У3, х.
Альфа, А, У1, У2, У3, х.
Это вот то, что было там.
Равно альфа 1, бета 1
равно альфа 1, бета 1.
То есть мы посмотрим эти выводы не вот так теперь,
а вот эту часть и часть, которая с буквой Б.
У нас теперь сам правильный терминал поменялся.
Тут он был А1, а тут он уже не А1.
Для определения это уже будет Б1.
Альфа 1.
Так.
Бета 1, У1, Б.
Бета 1, У1.
Смотрите, у вас префикс
стоит сразу после точки. Вот точка, вот точка, вот они.
У вас префиксы совпали.
Это самое главное, что нужно понимать об алгоритме, что у вас
совпали префиксы и совпали части за правилами.
Префиксы вы контролируете. Что видит алгоритм?
Он смотрит, что у него есть на слове. Вот он вот это
не отличает, что это за правилам или внутри правилам.
Вот. Поэтому мы говорим, что тут за правилам, а если
стоит точка, ну вот это за правилам. А это стек, он
просто знает. Поэтому мы говорим, что мы всегда знаем
две вещи. Вот эту вещь и вот эту вещь тут.
Просто в тему чтения у вас вот эта часть
эта часть вместе свернется, ну там же написано было
first от альфа У.
Вот. Поэтому мы не знаем положение точки в правиле,
но мы знаем, что эта точка находится в слове где-то.
Так. Здесь что написано?
Мы рассматриваем два правых вывода. Порождающий
стек. Ну, тут
вывод с последним открытием, чтобы вот
получить этот префикс. И тут чтобы все было
буквами. Мы же хотели, чтобы у нас после
префиксов только буквы шли. Тут нужно открыть просто
букву А. А тут нужно открыть букву А1 и дойти
до буквы Б. Поэтому тут вывод стал длиннее, мы
фокусируемся на разных частях. Вот. Значит мы
требуем определения вот это. Это можете проверить?
Что-то, ну правда так есть.
Так.
Вот отсюда.
Считая, что альфа Бета
один равно альфа Бета.
Получаем
Ау1у2
равно чему?
Так. Ау1у2
Бета1
Вот.
Ну это оттуда получается при помощи
Постановки то, что у нас префиксы равны.
Так.
Сейчас посмотрим, как
это получилось из определения.
То есть,
вот эта часть.
Вот так.
Вот так.
Ну, это строки из букв.
Вот.
И тут из того, что у нас
EFF верен, вот эти вот строки можно убрать.
Осталось вот это.
Вот это и вот это.
Но если посмотреть внимательно, то
то, что они совпали, написано здесь.
Просто этот Бета2, он даже там открылся, открылся, открылся и получилось
вот это вот ровно и получилось.
У3 и потом Х, который вылез отсюда.
Где он?
Вот он Х.
Да, но они же не обо откуда взялись.
У нас же в правилах КАБУК зафиксировано.
Но эти КАБУК,
они выходят отсюда и отсюда.
Кажется так. Сейчас, минутку.
Так.
В определении требуется, чтобы они были равны.
Ага, вот.
Значит, у нас не только префикс, у нас еще и КАБУК
устроили, которые должны были записать. Спасибо, что меня
остановили здесь.
Вот.
Здесь написано, что вот эти вот строки совпали.
Вот он тут. У1, у2, у3, Х.
Вот этот кусок, который находится за Бета1, за префиксом.
Он совпал с куском за префиксом вот тут.
Вот где мы получали А, получали ВА.
так у у у нас возникало первого вывода я точно помню шон там был
ири где у нас возникло сейчас
Что, поехали по значению что ли? Так, ну тогда давайте разбираемся.
Так, и рекордация где-то повыше был.
У, по идее, должно получаться из, ну если мы говорим, что у нас есть веб,
в котором получается W, и вывод в котором из А1 получается вот тут бета 1, бета 2,
из бета 1 это даже открывается, то вот этот хвост, который находится после префикса,
соответственно хвосту здесь. Кажется должно быть верно вот так. Сейчас я посмотрю. Нервно сложная
теорема на самом деле. Так, давайте своими силами, сейчас попробую еще остылать, переписать и вытащить.
Что? Как потом сократили? Ну дальше на самом деле нужно смотреть, что у нас известно. У нас известно,
что альфа б, альфа 1, бета 1, вот. Видишь, что тут альфа 1, бета 1 есть как префикс, а тут нету.
Означает, что здесь можно поставить бета вместо этого. Вот этот альфа сокращается,
тут как-то сокращается, бета останется, и вот он тут будет. Сейчас вместо 1 бета надо поставить,
проверяем. Так, попробую еще раз это вывести. Вот, я боюсь, что напулся на какую-то опечатку,
но при этом настолько простая вещь, что сейчас мы, кажется, сами получим. Что? Нет опечаток,
согласен. Первый вывод. Вот он. Альфа а, омега, альфа бета, омега. Второй вывод. Альфа 1,
а1, а1 х, из а1, альфа 1. Так, из а1, из бета 1, бета 1, бета 2 пишем. Ну ладно, сейчас бета 2 раскроем.
Вот х, отсюда а1, бета 1, о1, б, у3х. Открыл вот здесь. Дальше а1, бета 1, у1, у2, у3х.
В терминах теоремы. Есть два вывода, где сам правильный терминал раскрывается. Мы дождались
момента, где сам правильный терминал не терминал. Тут б, тут а. Альфа 1, бета 1, у1. Это, кажется,
неправда, у вас точка. Вот у вас точка для активного префикса. У вас префикс. Вот. Вы смотрите на
эту, на эти выводы. Так, давайте сейчас это примерно напишу и мы сейчас с ним посмотрим. Так, чтобы
точно не наврать ужаса сложные вещи, именно потому что формальные. Альфа, альфа, бета, омега.
Так, ну ферсты совпали. С этим вопросов не возникает, потому что это явно просели. Отсюда следует,
что альфа, ау, но гамма, бх. Вот. То есть, альфа равно гамма, а равно б, х равен у. Давайте смотреть,
что у вас активный префикс. Вот он, альфа, бета. Тут, вот он, альфа, бета. Тут эта гамма, даже не эта гамма.
У вас вывод остается вот здесь. Вот. Сейчас попробую с этим посмотреть. То, что находится до правой
буквы здесь. Вы считаете, что вот это активный префикс теперь будет? Так. Ну равно смутное
ощущение, что это не должно быть так. Что? Да, это сейчас кажется, что такое должно получиться. Так,
определение. Вот буква, вот буква. Хорошо. Вот префикс. Тут у нас что является? Давайте посмотрим.
Нам нужно найти кусок, состоящий из букв. Тут этот кусок вот здесь, а тут это у3х. Вот.
Значит, ну из того, что мы написали, мы знаем как раз таки, что эти вещи совпадают с первым к буквам.
Хорошо. Значит, что мы вывели из b? Мы вывели у2. Тут что мы вывели? Так. Не, прежде, так вот он,
активный префикс тут. Активный префикс тут, он кажется, еще длиннее. Вот он такой. Вот. Вот это
я готов поверить. Так, ну раз они равны. Раз они равны. Так. Ну давайте теперь напишем тут. Значит,
а равно b. А равно b. Дальше. Гамма равно альфа. Альфа равно тому, что было здесь. Вот. И, неужели,
это удивительно. Нашли отпечатку Вахо Ульманью. Страшно становится. Так. И x. Здесь написано x равно y.
Вот это равно вот этому. Здесь что написано? x равно y3x. Вот. Ну поскольку оттуда следует,
что он равен еще и омеге, хочется получить, что на самом деле такая ситуация, в принципе, невозможна.
Так. У1, у2 не пустое. Это не пусто, потому что вывод не тривиальный. Так.
Подставляю. Меня вот этот меня смущает. Вот он. Если оттуда сказать, что у1 пусто,
тогда получается, что у нас b выводится сразу. Сейчас попытаюсь понять, где это надо сказать.
Получили два вывода. Хорошо. Так. Теперь здесь. Что является активным префиксом? Тут альфа,
бета. То, что было здесь. Но активный префикс точно тут альфа, бета. Тут он должен быть каким-то...
А здесь он получается... Кстати, нет, не полностью. Все-таки вы здесь неправильно говорите. Мы же
берем не все, что получается тут. А, ну как я говорил в начале, у нас возникла ситуация,
что здесь мы открыли по альфа, бета, а тут бета был длиннее. Тут у нас b открылась как это 1,
бета это 2. В начале, помните, такое было? Вот мы говорили, что мы вот это заберем,
это заберем в гамму, это как бета, а это откроем туда дальше.
Гамма то, что до b большой выйдет, но префикс у нас в итоге короче. То есть получается гамма
должно быть меньше, потом мы должны забрать. А если здесь говорить, что вот это гамма...
Давайте посмотрим на этот вывод вот так. Вот, и потом заберем вот так. А все остальное скинем...
Вот бету мы забрали, вот это мы забрали. А потом к тому, что вот оттуда как-то вылезет вот это.
И вот это остаток слова. Посмотрим на один шаг назад. Вот. Да, вы кажется,
тогда вот эта часть равна вот этой части. Что? B2 где? B2 это строка. B2 это вот она тут была,
и B2, по-моему, даже тут не вводится, просто равно. Вот так обозначили, да. Хотя B2 не терминальный
символ. А, мы видим последнее правило, то есть из него выводится. Тут был какой-то не терминальный
символ, он как-то пооткрывался, и предпоследний шаг выглядит вот так. Вот вам два вывода. Здесь
остановились, тут за один шаг получили это, а тут самый плохой случай реализовался. Так мы еще,
ну ладно. Так, тут мы дочитали до B1. Ну, здесь получается, что вот этот кусок, он очень длинный,
вот он тут. Мы оттуда сразу сюда идем, вот это тогда наш префикс, это наше слово. Тогда это слово
должно быть равно чему. Что смотрим? Вот этот этот. Давайте смотрим. Так,
и разбираемся. У1, у2, у3х. Остаток слова. Слово не удлинилось. Вот. Это уже что-то,
что должно быть похоже. На один шаг назад. Я бы уверен, что это получалось, когда это все
выписывал у себя сейчас перестало. Так, EF на First. Нам.
Даже что-то Y вообще не выводился. Так, а еще здесь получается что? Получается вот он тут. Ну,
давайте сейчас не терминал, когда разберемся. Тогда уже со словом потом будет видно, что у нас
буквы равны. A равно A1. Это мы получили. Рефиксы мы тоже получили. И еще гамма совпала. Вот здесь
совпало. Вот. Ну, просто отсюда должно получаться, что непременно у1, у2 пустое. Что? Ну, у3 как раз
таки попадет сюда. Вот. И как раз таки тут, поскольку оно пусто, а мы предположим, что оно не пусто в
терминах того, что здесь EFF, и здесь получается проблема. Вот противоречие, оно оказывается здесь,
что поскольку тут EFF, это не должно быть пустым множеством, оно получается пустым, потому что
восприятие такое. Кажется, распутались. Да, нет? Еще раз. Смотрите. Что значит, что у нас здесь
написано EFF? Ну, блядь, shift. Значит, если у нас бета2 не пустой, то открываться, первый не терминал,
как не пустое слово. Мы это предполагаем здесь и пишем тут, что вот это не пусто. Потому что такое
принято EFF. И мы такое вот рассматриваем. Но, если мы его расписываем в терминах определения,
мы получаем, что вот это слово должно совпасть вот этим словом. Чтобы они совпали, вот эти
непременно пустыми словами. Это означает, что если мы сконцентрируемся на этом правиле,
видим U, то здесь... Нет, вот U3, она попадает в V, вот так вот. Вот. Вот U1, U2 будут пустыми,
а U3х попадут сюда. Видите, U это бета2V. В бета2 у вас вылезет U3, вот. И U у вас останется.
Стало понятнее? Ну, здесь что написано? U лежит в EFF от бета2V. Что здесь означает? Вот он U,
U, который там возникнет. Тут U, а здесь V лежит вот здесь. Означает, что вот эта вещь совпадает
вот с этой вещью, а вот это не пусто, потому что EFF. Но мы и получили, что оно пустое,
как раз таки тут. Вот это строка. Вот. Да, все, себя точно убедилось, осталось вас убедить.
Так. Вот здесь, да? Так. X это тот же самый X.
Так. Потом, сейчас, где-то в словах не потеряться, потому что здесь у нас А1,
он открылся, открылся, открылся, пришел сюда. Вот. А1, бета1 и бета2 открывалось.
Надо спросить, куда точка попала. Ну, здесь в определении у нас префикс, вот он тут,
и вот он тут. А здесь, так, ну, мы используем понятие префикса. Сейчас я это найду и покажу.
И X. И X это не то, что выходит из правила. То есть сюда еще дополнительно что-то попало,
вот эта вот вещь. Ну, да, вообще получается, что вы правы, там не то, что у 2, там все ушки,
все ушки пустые. Кажется, получается так. Но в любом случае нам нужно доказать,
что у 2, у 3 пустой, у 1, у 2 пустой, а мы предположили, что они пустые, потому что ЕФФ. Ну,
третья ситуация соответствует какому-то шрифту, после которого происходит какой-то
редюс. Ну, самое плохое в своем определении, когда мы должны дочисать больше. Вот. Разбрались?
Наверное. Так, это надо еще порасписывать. Я это еще порасписать. Я еще раз пишу,
скину обязательно в канал. Канал общий, конечно. Не, ну, если это скину, то скину всем. Вот. У
меня это точно работало, сейчас это что-то развалилось. Я сегодня еще это порасписываю.
Я не верю, что я знаю кого-то, кто может это это нормально. Вот. Что? Ну,
давайте тогда в обратную сторону разберемся, чтобы сейчас не дайте теме. Так, ну, J это не
леограмматика. Построю вывод. Ну, построю эту систему вывода. Значит, это шрифт. Так, и
второе вывод. Какой-то гамма BX. Откроем гамму, откроем B, дельта Х. Еще что-нибудь поделаем,
получим альфа, альфа, бета, у. Ну, это все как тут. Чуть при которых альфа не равно гамма BX. Так.
И ферсты совпали. Ферст К равно ферст К. Y. Что? Ну, написано альфа Y равно гамма BX. Сейчас,
альфа АВ равно гамма BX. Сейчас проверю. Да, Y. Я прошу прощения, здесь описка. Так. Ну, значит,
там доказывается промежуточная лемма, которую я краски опустил, о том, что здесь без значения
общества можно считать, что прессикс длиннее. Сейчас объясню, как она доказывается. Гамма дельта
больше, чем альфа, бета. Что это означает? Что тут нужно, непременно, читать больше. Ну,
если больше читать не нужно, то давайте мы откажемся на пару правил назад и посмотрим,
в какой момент мы перестали читать. Вот. Это что-то совсем техническое, поэтому я это пока оставлю.
Ну, то есть, если вы вот, если вот это короче, то мы тут просто посмотрим на правила,
которые идут, следует дальше, рассмотрим его. Так, чтобы мы прочитали сильно больше,
чем здесь. Вот. Ну, поэтому будем считать, что тут пресс не длиннее, разбирая как-нибудь даль,
там получим бета и видим у. Вот. Ну, еще раз, что я считаю, что у нас случае короче? Что тут оно
короткое? Если вот это короткое, означает, что здесь есть не терминалы, которые в будущем откроют нам
альфа, бета. Давайте не терминалы открывать, открывать, открывать. Пока в какой-то момент слова,
которые будут фиксировать, фиксировать слова, пока не получится больше. Она точно получится больше,
потому что нам нужно здесь получить. Сейчас. Нам нужно получить здесь по слова длины к. Ну, вот. Тут
хвост слова, тут хвост слова. Вот. И если тут строка короткая, мы не терминалы, продолжаем дальше
открывать, открывать, открывать, пока строка не станет длиннее. И в какой-то момент скажем,
что вот это расширим. Дельта – это то, что уходит с бета. Вот. Так. Чуть дальше разбираемся.
Так. Чуть. Пусть. Чуть последнее. В этом выводе. Здесь вывод 0, здесь вывод 1. В 1 последняя строка.
Это. Ага. Последняя строка альфа 1. То есть, мы вывели вот это, потом получили это за один шаг.
Это длина открытой части не больше, чем альфа бета плюс 1. Ну, смотрите, мы вывели вот это,
и за один шаг получили вот это. Ну, то есть, это самая последняя цепочка, которая происходила
перед выводом вот этой. Ну, как это выглядит? Я писал такую вот цепочку с альфа 0, альфа 1. Это
последний. До него вот этот был. Вот. Значит, поскольку здесь больше, давайте поищем такую последнюю цепочку,
что? Может, самый первый. Ну, просто здесь хочется сказать, что здесь топ-префикс на стеке под длине
больше либо равен, чем альфа бета плюс 1. Ну, в конце больше. Вот. И давайте мы идем по выводам,
идем, идем, идем, пока в первый раз не будет хотя бы альфа бета плюс 1. Ну, вот, остановились. Так,
отсюда. Значит, куда-нибудь пойдем писать. Я очень хочу это стереть. Видимо, придется это стереть.
Альфа 1, который меньше ли равен, чем альфа бета, меньше ли равен, чем гамма бета. Ну да, в силу выбора.
Вот. Это потому что альфа 1 входит в альфа бета. Альфа 1, бета 1, то альфа бета. Вот там это было
написано. А здесь, ну вот он, исполнил вот это. Тут альфа 1 взят. Ну, мы хотим построить вот это,
может, на ситуации. То есть, мы говорим, рассмотрим выбор, в котором тут получается больше, чем здесь,
открывание терминала. После этого рассмотрим последнюю строку, на которой было короче,
потом стало длиннее. То есть, это первая такая строчка, что тот рефикс, который был на стеке,
то есть, предпоследний шаг, должен быть не терминала, был хотя бы альфа бета плюс один.
Но мы сейчас на построим. Мы хотим вытащить вот альфа 1, который был здесь, а1 и бета 1. Вот мы
сейчас выбрали альфа 1. Вот мы вот так выбрали. Альфа 1, а здесь а1. Вот и в выводе нет правила
бета в апсилон. Для чего нужно, чтобы не было такого правила, чтобы мы вот EFF капицаль. Вот,
почему это можно достичь? Давайте посмотрим, почему это можно достичь. Ну да, если бы это правило
применялось последним, то есть, если до этот класс в последний терминал, то значит, длина была
такая же. Ну, у нас апсилон, значит, длина не увеличилась. Значит, эта строчка не первая, на которой
длина стала больше. А мы взяли первую строчку, где длина стала больше. То есть, последнее правило
не открывать интервал пустым словом. Ну, а дальше, оказывается, мы уже все построили до конца.
То есть, надо это как-то произносить. Ну, таким образом, уровну first от Y. Не просто first от Y,
а еще EFF от Y, потому что тут явно написано, что не терминал не пустой. Вот, и получаем ситуацию вот
такую. Как раз-таки эта ситуация из вывода, на котором последнее правило, это то правило,
на котором первая раз длина стала больше. Да. Мы взяли такое правило, что тут длинный, до него
был короткий. Если не терминал открывался пустым, длина до него была такая же. Потому что пустое
слово имеет нулевую длину. Значит, это не первая такая ситуация. А значит, если первая такая ситуация,
то тут не терминал не открывается пустым. Означает, что first на EFF можно поменять. Этот вывод
генерирует нам вот такую ситуацию. Но вот этот вывод генерирует вот такую ситуацию. И уровну EFF от
beta2v, потому что мы явно нашли не терминал B, и явно сказали, что не пустой. В достаточном условии.
Да. Тут. Вот. Это. Ну, нам нужно получить, что альфа-1 не больше, чем альфа-гамма тут. Это,
это нужно здесь, чтобы сказать, что альфа-1 с этим кусочком проведет нам префикс. Вот он. Вот эта
вот вещь не больше, чем вот это. Означает, что вот эта штука не пустая. Вот. Ну, или, возможно, пустая,
но означает, что это правило, оно вот тут заканчивается. То есть, если beta1 пусто, то точка находится тут.
Это часть ситуации, что альфа равно альфа-1 просто. И beta пуст. Вот эти вещи равны, и там равенство.
Если тут не равенство, то beta не пуст, и beta1 тоже не пуст. Да, точка тут. Но нам нужно гарантировать,
что здесь правило хоть сколько-то прочитается. Надеюсь, понятно. Да нет? Так. Ну, нам нужно, чтобы это правило было
последним. Вот. Для того, чтобы оно было последним, нужно гарантировать, что альфа короче, чем здесь префикс.
Вот. Ну, не длиннее. Если альфа длиннее, чем тут префикс, это правило длиннее, значит, нам нужно
назвать не такую ситуацию, а какую-то ситуацию до нее. Вот. А мы хотим эту ситуацию явно описать.
Поэтому говорим, что альфа-1 короткий, значит, beta-1 либо пустой, либо еще какой-то. Но если он длинный, то beta
никак нельзя взять. Надо брать правила по range. Вот. Значит, здесь можно поставить вот такую ситуацию.
В силу того, что терминал открывается непустым словом, здесь пишем EFF. Получается здесь ситуация,
которая подсчитывает там противоречащие правила. Часть агроматика не ЛРК. Пример точно построится.
На самом деле, вот это для алгоритма особо не нужна эта часть. Вот это позволяет что гарантировать.
Если поставить таблицу, там есть противоречие, то грамматика точно не ЛРК. Вот. А необходимость
гарантирует, что если вы взяли ЛРК-грамматику, как-нибудь вы проверили, поставили таблицу, там все будет
хорошо. Это алгоритм. Ну, а это сказать заказчику, что он идиот. Вот. Вот вам таблица, там есть противоречие,
ваша грамматика неправильная, извините. Это была тирема 5.9. Значит, пункт 3 я распишу, пришлю в чат,
даже до экзамена. Вот. Это я готов пообещать. Так, ну и сейчас надо объяснить, как построить В. Это
совсем просто. Ну, да, уже объясняли. Значит, строим ВКЖ, это все. Ну, как его строим? Берем правила,
которые точно в выводе есть. Начинаем его пополнять, пока пополняется. Ну, замыкать. Смотрим, какие правила
вводятся. Замыкаем, замыкаем, замыкаем. Дальше нужно получить для остальных префиксов. Ну, как мы делали
взграмматику Артема? Брали, где ставят цитала точка перед А, переносили ее. При переносе говорим, что
тут GoTo. Это лемма, доказанная с лекцией, то GoTo от В. Кажется, Павел на нее подавал всю лекцию,
поэтому я точно сейчас доказывать не собираюсь. Вот, ну, как мы его определяли тут по x2, то это ВКЖ от
гамма х. Как его построить? Это замыкание, может, таких ситуаций. Альфа точка х бета. Слово. Вот, вот так
вот для ситуации вида альфа точка х бета. То есть, смотрите, как это сделать? Мы берем все ситуации,
где из 3 точки предыдущим, тащим точку туда, а потом что-то замыкаем. Утверждается, что это будут все допустимые
ситуации, только они. Это доказывается забодривительно в разном случае с выводом, но никогда это не детство.
Это было в лекции. Вот, вот такой алгоритм. Или теорема, кажется, теорема 5-10.
Можете посмотреть доказательства. Возможно, я когда-нибудь еще разобренирую аудиторию,
еще проеду такой сценарий, теорема 5-10 докажу. Да, да, да, ну, будем разбираться. Так, ну,
в общем-то говоря, это дается просто, вы смотрите просто в векторе все ваши правила,
потаскать эти точки и это замыкать. Ну, как замыкать? Смотрим все правила и пишем их, где у нас после запятого будет
стать first от вот этого. Построили vk от epsilon. Дальше где-то перетащились, еще и перетащились.
Это у нас будет vk g от x. Теперь в чем проблема? У нас строки и префиксов бывает много, а в них, конечно,
может со состояний. Но утверждается, что в какой-то момент вы начнете пересекаться. То есть,
не пересекаться, а совпадать. То есть, у вас будут префиксы длинные и короткие. То есть,
сами не знаю. x1, x2, xm. У него будет vk g совпадать с x и x и плюс 1 xm. То есть, оказывается,
что для префекса вот этот кусок важен, этот кусок не важен. Но это просто я вам буду
предупредить. То есть, вы тащитесь сквозь точку, пока появятся новые ситуации. Это bfs. То есть,
старта состояния и поехали, поехали, поехали. Протащили точку, замкнули. Протащили точку,
замкнули. И когда вы увидели, что, если у вас такое состояние уже было, вы в очереди кладете.
Когда вы увидели, что у вас очередь пустая, вы посмотрели все состояние. Go to мы сделали под
дороги. Как мы получали следующее состояние, как бы в обходе? Ну, go to делали. А все что go to у нас уже
построено. Go to это функция g. Функция перехода по автомату или функции перехода по
альтер таблицам. А функция действия мы тут и устроили до этого. Смотрим состояние, смотрим,
если стоит точка в конце, делаем reduce. Стоит точка где-то в середине, и тут не пустое, а простое,
делаем shift. Вот. Корректность полнота здесь доказана. На мне еще третий пункт. Засем все.
Если есть вопросы, задавайте. Полнота, если вы видите нелеграмматику, то при
построении нелерка от таблицы непременно получится противоречие. То есть в какой-то
момент у вас будет префикс и два стандарта, которые дадут проблемы. Для таблицы, это означает,
что у вас будет ячейка в таблице, в которой будут два разных действия. Вот. Давайте.
Да. Нет, вы нашли все в ВКЖ, и уже GoTo пункт уже делает. Это она есть. Да. Как яйт функцию f?
Reduce при условии, что вот это ваш аргумент. Да. А shift? Если бы это не пустое, и то, что будет,
тоже не пустое. Смотрите, вы пока строите алгоритм, вы тут идете по префиксам, по дороге
можно строить First и EFF. Я считаю, что те, кто прошли курс алгоритмов, понимают, как
построить First и EFF, и я по грамматике, по символю. Ну, тогда вы просто знаете EFF здесь. Вы
понимаете, если у вас V, лежит здесь. А это какой-то set слов. Вот. Ну, First нужно проверять, что у вас
тут не терминал, который не открылся пустым словом, и все. Вот. Пока добавляется, не ситуация,
пока добавляется новая множество ситуаций. Вы поставили старт в множество ситуаций, из него
получили новую множество ситуаций. Пока эти множество ситуаций поменяются как-то, главное,
помните, что это не вся ситуация. Ситуация поделится правилом с точкой и словом. Потому
что мне вот некоторые студенты сслают неправильные множество ситуаций, где тут доллар, а тут а.
А это одна та же ситуация. Нет, не одна та же. Тут доллар, а тут а. Если у вас одна та же ситуация, то у вас
лер 0, простите, а не лер 1. Пока ваше множество окажей меняется. Поставили в очередь вот это.
Достали из очереди черную ситуацию, протащили все точки, позамыкали. Если это не было обработано там,
не знаю, не стоит в флаг, что это было обработано, в очередцу. Достали из очереди, добавили в очередь
новые. Дальше надеетесь на судьбу в том, что когда-нибудь это все прекратится. Почему это прекратится?
Ну, если то, что у вас алгоритм это лерка, это будет заканчиваться. Это терема 5 в 8, кажется. Вот.
Что-то протосконечен. Такие вещи. Делайте до сходимости, по дороге строите go to, а потом
проходите по всем вкж и строите f. Ну f вы сами сказали, как строить, вот так и строить. Вот.
Ну как на практике проверяешь, что грамматика лерка? Если построили таблицу, там есть противоречие.
Берем терему 5-10 в обратную сторону, говорим, что грамматика не лерка. Если противоречия нет,
берем в прямую сторону, говорим, что грамматика лерка, таблица корректна, по ней парсим. Ну как
парсим, в начале снарапс удалось. Так, еще вопросы? У вас? У вас? Ну отлично. У вас? Третий пункт
точно докажу. Тут особо деваться некуда. Да? Ну смотрите, нам нужно, например, грамматики,
чтобы по прессу правила поделялось. Вот. Тогда получается, что тут это один шаг, это не один шаг.
Тогда, раз они совпали, вот. Здесь могли быть ситуации, когда они терминалы не терминалы раскрывают.
Например, ситуация, когда у вас там b в c, c в d, d в e, вот. И тогда x он пополнится. И мы не знаем,
что он не пополнится. Поэтому αay, вот, равно γbx. То есть это не полная строка. Для того, чтобы она
была полной, мы можем сказать, что мы возьмем и прицепим сюда, потом это откроем, получим вот это.
Есть омика какой-то. Вот. И поэтому, если мы взяли α до х, то мы не прочитаем буквы, которые из b
выходили. Вы понимаете, что здесь β в b находится не в конце, а в середине. Здесь это было написано. Вот.
И поэтому х еще пополнится чем-нибудь справа, слева. Вот сюда. Для того, чтобы это не произошло,
нужно потребовать, что если мы прицепим это сюда и приложим вывод отсюда, то слово не укорочится.
Ну а здесь это написано. Просто не терминал в терминалах грамматики. Вот. То есть получается,
что у вас префиксы такие же. Последнее правило такое же. Открывается такая же самая буква. Вот.
Здесь почему разные вещи? С точностью до того? Сейчас. Альфа, бета, у. Да, это могут быть разные
слова. Вот в чем прикол. То есть противоречие, если оно возникает даже при том, что слова разные,
алгоритм не знает, он находится тут или тут. Тут могло быть длинное слово, тут могло быть короткое
слово. Вот. Если бы мы говорили, что одно и то же слово разбирается, то тогда да. Здесь можно
вот эти вещи приравнять. Но это значит, что противоречие гипотетически возможно. Вы при чтении
не отличите, что длинное слово выводите или короткое слово выводите. И ровно потому, что в
определении у нас слова бывают разными, вот там вот здесь вот и мучились. То есть что надо
осознать, я это понял далеко не сразу, что это выводы разных слов. Поэтому, мало ли, как тут
альфа, бета раскроется еще как-нибудь дальше. Но при этом это слово оно откатится сюда, это
слово откатится сюда. И при парсинге обоих этих слов, если что-то с ним размножился, кто-то там
ждет, чтобы я отпустил. При парсинге этих слов эти ситуации возникнут, и они однозначно разберутся.
Вот. Ну, это определение его построил человек, который точно знал, что из этого может что-то
доказать. Поэтому, как его придумали, я тут не скажу. Ну, его изобрели для того, чтобы оно работало,
оно максимально емкое. Вот. И как мы тут видели, в первых трех случаях, мы увидели бы, если бы доклад
третий случай нормальный, это немножко развалился, что тут каждая буква верна на своем месте. Так,
еще вопросы? Нету. Ну, тогда всем спасибо. Ну, скажу, эта теория достаточно, чтобы написать, чтобы доказать,
нужно еще что-то послушать, что-то посмотреть. Вот. Я утверждаю, что LR, вот пока вы его не сделаете
там руками, ногами, никак. Я его писал год назад, у меня уже память пропала. Если что, все свободны.
Так. Небольшие диалоги.
