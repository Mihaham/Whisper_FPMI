так ну что шла да может тогда начинать хотя видео стартово объявление можно было делать
без камеры но пожалуй можно и на камеру сделать да на всякий случай так как мало кто из вас
наверное знает у нас воскресение cp си слышали о таком так надо всякие слухи поднимите руки кто
знает что такое cp си так на всякий случай а то а то мало ли тут мы обсуждаем то вы думаете
шейси пи си это там я не знаю там собрание там любителей котов там лишенки еще в этом роде
ну там мало ли да ну там господи там где-то их куд скампе пить и в том что там вчера было вот
это все вот там там плагиатом компетition там я не знаю вот что-нибудь такое вот соответственно
так давайте-ка поднимите руки кто уже увидел каким конкретно образом нужно туда регистрироваться
там какую конкретно антие точку там заполнять и так далее вот ну так вот рекомендуем вот значит
увидел крайне рекомендуется увидеть это можно увидеть просто у нас в группе вконтакте вот ну в
идеале у нас конечно там есть шоу наством есть соответственно у нас есть час понят before
я �ам панал там в котором соответствие объявления появляются но так вот соответственно ссылочка
уже есть вот так что соответственно рекль комп稱 해요 не откладывать но там и 라는
страция к аши до пятверга но какой-либо а к那个 же писалось рекомендуется кеша участвовать
тем более, что на нашем потоке бонусы будут. Да, это говорю уже я. Вот, так, что-то вот. А,
видимо, все-таки не новая информация. Или новая. Так, что-то вы тихие сегодня. А то, я не знаю,
может я просто говорю каких-то темов и все должны кивать, но на самом деле, конечно,
поэтому все все понимают и на кухнях будет обсуждаться что-то другое. Там что-то как-то
так звучит. Не знаю, что-то вы как-то не реагируете. Странно. Ну окей. Ладно, в общем,
подробно читайте, потому что пока лишь только скажем, что да. Так что присоединяйтесь,
участвуйте, ваше участие очень важно. Потому что, как вы помните, чем меньше вас участвует,
тем меньше нас участвует в полуфинале, это будет хруст. Вот. Помните, да? Ну и вообще. Ну и вообще
классический принцип. Если вы поучаствуете, то у вас будет шанс прийти в полуфинал,
а если не поучаствуете, то не будет. Логично, да? Вот. Логика. Так, ладно, по этой части какие-то
вопросы есть? Так, сейчас все уже увидели, где регистрироваться надо. И, собственно, там,
какую ссылку там давать друзьям, там и так далее. Вот это вот все, сказал один человек. Да, значит,
сразу скажем, зарегистрироваться можно. Если вам кому-то казалось, что регистрация закончилась
вчера, то нет. То есть более того, наша с вами регистрация только начинается и продлится до
пятого числа. Да. Так что не волнуйтесь. То есть в этом смысле все схвачено, все в порядке, так что,
как бы да, тем более что регистрация еще и продлена сверху, так что вообще все хорошо. Вот. Ну,
ладненько. Ладно, будем тогда переходить немножко по делу. И так, значит, сегодня в прошлый раз уже
начали говорить о сливаемых кучах. И вот в прошлый раз мы уже даже одну из них обсудили. Как
она называется? Вот на этот вопрос вы уже отвечаете. Да. Вот. А встать там в воскресенье подключиться
там одну задачу решить никто не хочет. Вот. И так. Значит, что такое у нас сливаемая куча? Вот. Ну,
сливаемая куча это у нас такая структура данных. Какой-то мистический опять черный ящик,
который хочет поддерживать операции вставки элемента. Там операции get-meme,
extract-meme. Ну, пока это все обычная куча. И, неожиданно, melt. То есть что такое melt?
Буду выяснять это, что мы кучу хотим объединять. То есть взять две кучи и сказать, а создать,
пожалуйста, из этих двух черных ящиков один черный ящик. Ну, в том плане, чтобы в одном черном
ящике лежали элементы того и того. Вот. Вот. Ну, мы с вами в прошлый раз уже обсудили биномиальную
кучу, которая делает это за ноты, которая выполняет все операции, кроме get-meme за логорифом. Почему
кроме get-meme? Чего? Ну да. Потому что мы все время храним там в явном виде указатель на минимум,
и это позволяет там просто получать минимум за единицу. В смысле, ну, в плане ридонли. Да,
вот доставать его, конечно, нам все равно придется за логориф. Вот. Но сегодня мы изучим и другие
кучи. Ну, потому что кучи у нас много на самом деле. То есть на самом деле мы с вами изучили в
прошлый раз, допустим, биномиальную. Сегодня нас страшно сказать, что ждет. Потому что нас ждет
сегодня левацкая куча, нас ждет сегодня косая куча, нас ждет куча фибоначи и,
видимо, начнем про мягкую кучу говорить. Вот. Да, будьте здоровы. Да. Вот. Так что так. Ну,
в принципе, можно сказать, что да, левацкая кося и такой уровень изи будет у нас сегодня. Ну,
вот. Значит, куча фибоначи будет минимум, ну а хард, соответственно, в конце. Да. Ну,
скорее всего, этот хард мы еще весь следующий раз обсуждать будем. Потому что мясо там будет,
то еще. Ну, вот. Но давайте начнем с развинки. Как бы еще можно сливать кучи? Ну, кроме биноми,
как их так удобно хранить, чтобы можно было сливать? Вот. Но давайте посмотрим. Вот,
альтернативный вариант есть такой. Давайте попытаемся все-таки хранить кучу в двоичном
дереве. Ну, это для нас уже не новая идея. Да, то есть давайте пусть у нас там будет какое-нибудь,
то есть какое-нибудь вот такое вот дерево. То есть гарантируется, что там все там дети всегда там
больше родителей, а там, ну или там больше либо равно и так далее и там подобное. Вот. Но фишка в
том, что дерево, то есть на этот раз давайте для удобства мы снимем требования балансировки. То
есть у нас вот, например, была наша классическая двоичная куча. То есть была у нас такая классическая
двоичная куча, вот, в которой там требовалась какая-то идеальная балансировка. Но здесь мы этого,
но здесь у нас этого требования не будет. А что же будет? Что же будет, что же будет, что же будет? Вот.
Ну, действительно, казалось бы, действительно, что за какое время мы могли бы, например,
извлекать минимум из куч. Ну, можно от размера, но можно все-таки от глубины, в принципе, это делать,
на самом деле. А можно от минимальной глубины, то есть найти там какой-нибудь минимальный,
на самом деле можно было бы найти минимальной глубины лист и там применить стандартную
технологию с ним. Вот, кстати, возникает вопрос, а на какой глубине находится минимальный,
на какой минимальной глубине находится лист? Почему? Чего многовато вершин? Корень. Так, чего корень?
Да, но они же пересекаются. А как можно брать корень не пересекающиеся путей,
учитывая, что тут в начале два ребра, например? Может. Ну да, действительно. Пока в таком виде все
просто. Действительно, что ближайший лист может быть на расстоянии от Н, потому что по таким
определением куча может быть и бамбуком. Да, увы. Но тем не менее мысль эта продолжает нас греть.
Значит, каким образом она начинает нас греть? Она продолжает нас греть. А вот каким. Потому что,
да, действительно, ближайший лист может быть на расстоянии линия, но мы зададим вопрос по
другому. А где ближайшая дырка? Вот. Ну, что я имею в виду под дыркой? Давайте уточним. Под дыркой я имею в
виду, значит под дыркой я имею в виду, что соответственно надо, что мы пытаемся идти с корня там
куда-то снизу вверх по какому-то маршруту до тех пор, пока мы не вылетим в аут. То есть не
пройдем по пустому указателю. Вот внимание вопрос. Какое минимальное расстояние до аута от корня будет?
Почему? Очевидно то, что легко доказать.
Ну, типа того. То есть, давайте предположим, что вот допустим до глубины h. Действительно, то есть до
глубины какой-нибудь h. Ну, глубину будем начинать с нуля, например, считать. До глубины h у нас никакие
вершины не пропали, то есть никаких вылетов нет. Но тогда заметим, что действительно у нас на
глубине h находится два в степень h вершин. Ну, вот это должно быть меньше либо равно размера кучи,
из этого следует, что h меньше либо равно двоичного логарифма N. Да, то есть, обратите внимание,
то есть пустота все-таки достигается за логарифом, хоть и лист может быть глубоко. То есть том,
чтобы же бамбуки, например. Да, если у нас тут вот это вот бамбуки веселые. Вот она. То тогда заметим,
что ближайший лист, конечно, далеко, но в аут мы зато вылезаем, вылетаем сразу. Давай.
Ну, конечно, нет, такое естественно может быть. Да, потому что обратите внимание, мы здесь как бы вот
ближайшая дырка находится на глубине два, но если бы вот пошли влево вправо там влево влево,
то вот дырка нашлась на расстоянии 5. Да, нам нас сейчас интересует ближайшее. Вот, но это вот
интересный факт. Вот, можно ли им пользоваться? Вот, собственно, первая куча, которую мы все
рассмотрим, начнет этим фактом просто очень сильно пользоваться и даже кое-что подгонять. Ну,
для этого давайте введем определение. То есть определение. Значит, рангом вершины назовем число.
Значит, допустим один, если хотя бы одного из детей не существует.
Да, хочется говорить, но или иначе, но нет. И один плюс минимум из V, так сказать, left, точнее ранг от V left и V right.
И иначе. Вот. Вот, понятно?
Вот такая гадость.
Вот. То есть, ну, фактически заметим, что этот ранг это фактически вот там, где у меня расстояние у меня в поддереве до аута ближайшего.
Ну, я тут начинаю съединиться, чтобы было, что ранг пустого дерева, например, равен нулю. Ну,
так просто может быть немножко удобнее. Вот. Так вот. Ну, заметим следующее, что у этой кучи есть,
конечно, маленькое преимущество. Ну, не, ладно, нет, это не преимущество, но интересная фича. Заметим,
что я могу в принципе поменять местами любые, у любой вершины поменять местами двух детей. И в
принципе с точки зрения варианта кучи ничего не поменяется. Правда. Так вот. Значит, я сделаю так.
Я хочу хранить кучу так, чтобы у каждой вершины левый ранг был больше либо равен правого. Ну,
то есть, условно говоря, чтобы она все время там везде в каждой вершине перекос был влево. То есть,
определение. То есть, такая куча называется, называется левацкой. Левацкой. Ну, скажем так,
тут диспозиция простая. Официальное название на английском языке leftist, не знаю, имеет ли это
отношение там к английской политике, я не знаю. Вот. Соответственно, да. Ну, кроме того, что там,
как бы, в какой-нибудь политике там встречается слово left, но там, соответственно. Вот. Но здесь,
соответственно, там в книжке Бабенко-Левина почему-то сделали перевод именно таким образом. Вот.
Так вот. То есть, в левацкой куче у нас будет для любой вершины будет верно, что ранг от левой
вершины больше либо равен правой. Вот. Ну, можно заметить, что, в общем-то, представленная на
доске сейчас куча, она почти левацкая. Ну, в том плане, что если я вот, скажем, 11 переброшу,
так сказать, вправо, то вот так она левацкой уже вполне будет. Видно, да? Правда, будьте
внимательны. То есть, может показаться, что левацкая куча, это у которой там слева элементов
больше либо равно, чем справа. Но, как вы уже догадываетесь, это не обязательно так. Вот. Что,
что, что? Ну, типа да. Да, но отметим, да, что на самом деле, конечно, тут по балансировке могут
быть, конечно, совсем экзотические примеры, например, вот такие. Вот. Это тоже левацкая куча.
Вот. И это тоже. И это тоже. А это нет. А это. Да, тоже нет. Потому что мы 14 подвесили справа к 12.
Да, вот если бы мы подвесили слева, вот тогда, конечно, да. То есть, помните, да, то есть,
в левацкой куче как минимум не бывает такого, что слева дыхка справа нет. Вот справа дыхка
слева нет. Это пожалуйста. Слушайте, а действительно, погодите, погодите. Вот я вас где обманул,
оказывается. Вот. А ведь, действительно, это куча левацкая. Потому что заметим, что ранка этой
вершины один и ранка этой вершины тоже один. Упс. Да, как-то обман был не там, где я выражал
интенсивно. Там больше либо равно, конечно. Да. Вот. Да. А вот если бы я вот такое нарисовал,
вот это был бы, конечно, фейл. Ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, о
ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой
ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой
ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой
Ну, давайте подумаем. Вот, как бы, что нужно, мы уже с вами в прошлый раз обсуждали, что нужно, чтобы вставить в кучу элементов? Правильно, не надо ее прям вставлять, надо сделать кучу из себя любимой. Вот, кстати, обратите внимание, нам, мы вот вы спрашивали тут, строго больше или больше, либо равно. Обратите внимание, что мы бы не создали кучу из одного элемента, если бы тут было строго больше. Вот. Вот. Но так теперь ничего не мешает нам создать кучу из там, из экземпляров.
Из кучи из себя любимого и вызвать слияние. Ну, то есть, все просто, да? Ну, то есть, типичная ситуация. То есть, вы хотите устроить там, как бы, как устроиться в компанию Яндекс? Очень просто. Есть компания Яндекс, есть компания вы. Мы вас объединяем. Вот. Делаем это за логарифом мощностей Яндекса. Вот. Соответственно. Да. Вот.
Так. Ну, а теперь возникает вопрос. Как же, как же удалить гендереминимум? Да. Ну, выясняется, если Яндекс организован ливатским способом, то, в общем-то, не сильно сложно.
То есть, потому что, когда мы убираем корень, то куча распадается на, ну, фактически, левой поддервой правой, и каждый из них является корректной ливатской кучей. Ну, значит, просто теперь берем детей и их сливаем.
Вот. Раньше вы дети были, жили поодиночке, но теперь вы будете одним целым. Да. Вот. Так что получается. Ну, вот. Так что, на самом деле, самое простое получается, это слить.
Ну, не то чтобы простое, но просто все остальное используется. В общем, в сливаемых кучах это практически всегда так. То есть, в общем-то, технология будет достаточно общей.
Вот. Итак, как же слить две кучи? Ну, вот. Ну, на самом деле, предельно просто. Смотрите, потому что, на самом деле, ливатскую кучу очень удобно рассматривать именно с точки зрения правого пути.
Ну, то есть, вот, допустим, рассмотрим, нам надо слить красную кучу, и мы ее будем рисовать так, смотрите. То есть, у нее есть правый путь, вот так, вот, 5, 9, 12, аут.
И у нее, ну, вот, и на каждом из этих элементов слева висит какое-то поддерево. Вот альфа 3, альфа 4. Вот. То есть, вот такая вот радость.
Вот. И, допустим, вам нужно слить с какой-нибудь синей кучей. Что это будет за куча? Ну, допустим, тут будет 4, там 8, я не знаю, 10, 11, ну, там 14.
Вот. И у нее тоже тут слева будут висеть какие-то поддеревья. Да, очень удобно их рисовать, потому что, как вы уже, наверное, догадываетесь, с этими поддеревьями, в общем-то, ничего особенного не произойдет.
Так, душу. Спрашивается, как мы это будем сливать, как вы думаете?
Вот. Ваши ставочки. Как это слить?
Ну, да, самое тупое, да, давайте подвесим вот это сюда и возрадуемся.
Ну, да, да, да. Только маленькая проблема. Ничего, что тут 12 больше 4. А тут 14 больше 5.
Да, то есть приятно, что свапать, конечно, куча можно, это да, но оказывается следующее, почему мы выделили именно правый путь? Потому что правый путь у нас длины не больше, чем логарифом.
Логично, да? Вот логарифом от слова логично, действительно.
Вот. Тогда вот идея такая. Смотрите, у нас тут фактически, если идти по правым путям, получится два отсортированных массива.
Тогда вы чекаете идею. А давайте эти два массива просто сольем. Просто вот в плане вот этих вот двух указателей и там, собственно, слияния.
Вот так вот как-то это будет. Там вот тут будет 7, потом будет 8, потом будет, что там будет, 9, потом будет 10, 11, потом будет 12 и потом будет 14.
Так, ну и к ним, конечно, мы подвешиваем альфа-1, тут подвешиваем альфа-2, там начинаем подвешивать. Ой, ой-ой-ой. Нет, какое альфа-бета, господи.
Да-да-да-да. Вот. Вот. И вот еще такая красота будет альфа-1, альфа-2, альфа-3 и прочая радость.
Вот. Ой, что-то я забыл. О господи. Да, у нас же, что-то у нас это пятачок перекрасился.
Так, альфа-1, альфа-2, альфа-3, альфа-4 и тот альфа-2, альфа-3, альфа-4, альфа-5. Вот такая вот красота нас с вами ждет.
Вот. Так что, действительно, такое влияние делается за логарифом, потому что об этих пути не более чем логарифом. Так что вот таким вот простым образом можно свить.
Так, а что сломалось? Да, ну нет, сами, ну что это, рамги не сломались, рамги определены так, что они как бы не совсем ломаются, но, конечно, условия инварианта на рамге, конечно, мог поломаться, это правда.
Вроде как примерно вот, потому что, действительно, вот для каждой из этих вершин, у каждой из этих вершин рамг, скорее всего, увеличился, ну вот, по камере правого ребенка, поэтому там никаких гарантий, естественно, на то, что ничего не поломалось, нет.
Но, что приятно, поломаться рамг мог только вот на этом вот пути, то есть, заметим, эти деревья мы вообще не трогали, поэтому там ничего не поломалось.
А теперь внимание, вопрос, как же нам подчинить, так сказать, условия на рамге на этом пути?
Правые повороты, нет, конечно, да, тут как бы куда, как бы вы еще, конечно, да, это молодые, зеленые, АВЛ не нюхали, так сказать, с красночерным деревом, но, на всякий случай, правый поворот это сильно более сложная вещь.
Ну ладно, не сильно, но, да, но, помните, да, там, как бы в АВЛ деревьях это свапать, да, свапать под деревьев не обойдешься.
Вот, но, действительно, идея в том, что, на самом деле, как бы, если у какой-то вершины есть проблема с рамгом, а какие проблемы?
Ну, у меня просто у правого под дерево рамг больше, чем у лева, а если посвапать? Ой, а так нормально.
Вот, ну и, собственно, это все, что здесь предлагается сделать.
То есть, тогда, ну как, самым оптимальным образом, чтобы их потом не искать, да, надо просто пробежаться по этому пути снизу вверх и у каждой вершины, проверить условия, ну, таких, во-первых, пересчитать рамг, во-первых, да, и, во-вторых, его посвапать.
Вот, вот, понятно?
Так, ну вот, и получается мэлт, и получается тогда мэлт мы сделали за логарифом, экстракт мин мы сделали за логарифом, гет мин за единицу, ну и вставку, соответственно, за ложарифом.
Ну, по сути, мы все сделали за мэлта, мэлт и логариф.
Так же, как видите, даже не сильно сложно. Если вы это еще рекурсивно писать будете, то, собственно, кода там будет вообще на ма.
Дорадуетесь, да?
Ну, потому что что там в коде надо будет написать? В каком числе я не?
Ну, там, проверить в случае, что там, если одной кучи нет, верните другую, да, а в противном случае, там, ну, ну, а в противном случае, там, как всегда, там, если, там, если у левой кучи корень там больше, чем у правой свап,
так или все-таки надо код написать?
Ну, давайте на всякий случай рискнем. Ну, там, в общем-то, несложно, да?
Так, вот давайте внимательно подумаем. Ну, для того, чтобы написать код, давайте поймем у нас, что у нас вообще есть.
Так, стракт нодея пишем на указателях, естественно. А вы уже знаете, что такое указатель?
Ну, в смысле занятия, плюс-плюс, естественно, да-да. Вот, хорошо.
Код style на алгоритмах вряд ли.
Нет, не будет.
Ой, Господи.
Значит, смотрите.
Так, тех, тех, тех, тех, тех, тех, тех, тех, тех, тех, тех, тех, тех, тех, тех.
Смотрите.
Так, тех, тех, тех.
Итак, стракт нодея. Что у нас должно быть в вершине?
Так, ну, во-первых, конечно, наш любимый ключик.
Так, значит, что должно быть наш любимый ключик?
Ранг.
Так, ну, давайте аккуратненько. Unsigned int rank.
И, конечно,
left and right.
Да, с этой точки зрения, а вы уже знаете, что такое дикартовые деревья?
Да, вот. В контексте предыдущего вопроса правильный ответ – нет.
Да, также вы не знаете, что такое DFS.
Вот.
Соответственно.
Вот.
А так вот, да.
А если верить домашнему заданию, то вы там вообще только решаете задачи.
Типа, найди второй минимум в массиве.
Видели уже эту задачу?
Да ладно, я ж как-то решил.
Не, ну, так вот, да. Думайте, думайте. Вы можете.
Чего?
За вот это.
То есть он хранит минимум?
Нет.
Нет, ключ – это сам по себе элемент.
Скажем так, вот эти вот числа, которые вы храните в черном ящике, они обычно называются ключами просто в науке.
Вот.
Ладно, да, спасибо за вопрос. Да, давайте вот.
Проясним это сразу. Это обычно называется ключ.
Да.
А ключи можно только сравнивать, да?
Ну, ключи – да.
Да, да, да.
Фактически мы работаем скрабишками.
Ну, или на языке C++ это называется.
У нас есть шаблон с типом TK и типом там компаратора.
Вот.
Черт.
Ну, окей.
Но я здесь пишу все.
Но я тем не менее, ладно, шаблон не знаю, но все равно мы пишем TK.
Ну, просто чтобы подчеркнуть, что здесь тип какой-то заданный пользователь.
Но чтобы не путаться.
Вот.
Ну, ранка понятна.
То есть можно, в общем-то, написать функцию create.
Ну, то есть, например, как это будет выглядеть.
Void.
Тьфу, ладно, какой Void.
Nodi, звездочка, create.
Если у вас есть задача создать кучу из одного элемента.
Да, в хорошем, это должен быть диструктор написать, но это и буду делать.
Пока.
Значит, TK.
Вот.
Хотя, по-хорошему, тут надо писать const, TK, ampersand, TK.
Эти-то слова вы знаете.
Молодцы.
Вот.
Значит, create.
Но здесь все просто.
Return.
Собственно, return Nodi.
Return Nodi.
Return Nodi is.
Там, соответственно, key, 1.
Там nullptr, nullptr.
Вот, собственно, и все.
А где он будет храниться?
Так.
Где он будет храниться?
Ну, в памяти.
Ну, а где?
У нас же функция завершилась.
Ну, правильный вопрос, то самый простой.
Какое слово я пропустил?
Так.
Чего?
Конечно.
Да, я пропустил слово new.
Вот, я тут даже пробельчик оставил.
Вот.
И так точно будет хорошо.
Ну, конечно.
Нет, потому что функция new, она что делает?
Она выделяет соответственно область в динамической памяти.
Которая нодка, которая не зачищается.
То есть это как бы, поэтому этот нод не уничтожится.
Но это же наша проблема.
Ну, мы уже обсуждали проблему утечки памяти, что это ноду вам когда-то придется удалить самим.
Ну, если вы там пишете тот же самый Яндекс.Пояс, то когда-нибудь вам придется эту вершину когда-то удалять.
А то как бы знаете, куча уже нету, а вершинка есть, и она ждет.
Да, вот сидит такая собачка, ждет хозяина, а ссылку на нее уже потеряли.
Да, ну вот.
Возвращает она, получается, ссылку?
Указатель.
Нет, new это он возвращает указатель на нее.
Видите, я тут звездочку написал.
То есть обратите внимание, это crate, это не вставка.
Понимаете, да?
Ну, потому что тут, как всегда, вставочка у нас тут будет работать за.
Потому что, если сказать ноде звездочка там insert.
Ноде звездочка.
Хотя, вот как тут правильно написать?
Вот по-разному можно писать.
То есть, ну на самом деле так.
Можно, вот смотрите, можно писать так, то есть на уровне парадигмы, как принято.
То есть, если надо вставить, вот можно писать вот так.
Или есть еще альтернативный вариант, если вы хотите прям вот в кучу вставить.
То можно вставить, например, еще вот так.
То есть написать, чтобы она была void.
Insert от ноде звездочка.
Собака root.
Фу, амперсант.
Какая собака, господи.
Ну почему, зачем?
Вот если я, например, в таком виде просто напишу root равно melt от root и crate от x.
Ну от keys в смысле.
Вот я ж могу вот так-то писать.
Философский вопрос.
Чего? Чего к позиции запоминать? Чего? Кого?
Ну, по указателю.
Ну это будет отдельная песня, как erasing из произвольного места.
Но это позже. Пока это чисто парадигменный вопрос.
Потому что на самом деле имеет место и то, и то.
Потому что, окажется, с одной стороны, давайте везде будем возвращать нод звездочка.
Чтобы почекнуть, что корень кучи может меняться с insert.
Ну вот, а можно сделать по-другому.
А можно говорить, что вот я хочу, чтобы у меня был указатель.
Вот куча, что такое куча.
Это какая-то структура данных, которая задается указателем на корень.
Вот давайте поэтому эта структура сама по себе как идейно поменяться не должна.
То есть у нас как бы внутри кучи добавился какой-то ключ.
То есть другой вопрос, что это указатель поменяет.
Мог поменяться, и мы это подчеркиваем.
Поэтому мы здесь void.
Ну естественно в melde мы так не делаем.
Потому что melde он занимает тем, что он получил на вход две кучи и создал из них одну.
Поэтому в принципе это вопрос восприятия.
То есть на самом деле может быть и так, и так.
Ну я, пожалуй, уже раз уж я написал так, я оставлю.
Но и идейно в этой версии только мне надо было только return здесь добавить.
В общем-то и все.
Вот так вот я в скобочках напишу, что в красной версии.
Тут надо было просто буквально слово return вначале написать и буквально эта строчка работала бы.
Ну знаете, что там можно написать return a равно 5, да?
Нет.
Нет, какое?
Нет, конечно.
Нет, смотрите.
Ну во-первых, выделение произойдет уже внутри.
melde ничего не выделяет.
Просто практически просто берет те же вершины и перенаправляет у них указатели, по большому счету.
И тут присваивание указателей.
Не более того.
Поэтому никаких new.
То есть как бы new это значит вы вершину скопировали в данном случае.
Или создали новую.
Но если вы тут написали new root и в скобках от melde, то как бы получается, что вы там скопировали вершину.
Ну я вот это имею в виду.
Так-то конечно new да, но ничего не копирует, оно создает в этом плане.
Так что вот insert у нас выглядит так.
Значит так, что у нас теперь?
Так.
Так, так, так, так, так.
Ой, когда-то на первом канале было шоу Большая стихка.
Вот.
Ой, почему я ее вспомнил?
Как?
Да, как это говорить?
Знаете, вот это классическая история.
Да, что знаете, идет на улице бабка.
Иду я по улице, на встрече у меня бабка идет.
Я говорю, слушай, дай 10 енот.
Что оно называется?
Дашь 10 рублей?
Я говорю, ну пожалуйста.
А дашь 1000 рублей?
Говорю, не дам.
Она, ну ты меня еще вспомнишь.
Вот к че вспомнил, вот не знаю.
Вот это вот, как говорится.
Ну вот это вот такая, так скажем так, Краснодарская классика такая.
Вот.
Значит далее.
И так, значит это был create, это был insert.
Так, теперь как сделать get mean?
Так, ну как всегда.
Такие там get mean.
Панна.
Так, ноги, звездочка, root.
Ну мы обсудили и поняли, что написать код не помешало бы.
Ну у меня создалось ощущение, что кто-то думал, что давайте напишем.
Ну вот, ну это действительно не помешает, чтобы точно все видели, что там, как это конкретно пишется.
Вот.
Значит get mean.
Ну тем более, кстати, в будущем нам это пригодится, кстати.
Так, ну get mean, понятно.
Так, ну во-первых, неплохо было бы возу пить.
Ну вот там типа если куча пустая, то конечно в этом месте нужно возу пить.
Ну вот возу пить.
Ну формально она говорит так.
Значит ей передается на вход какое-то булевое выражение или то, что она кастует к булу.
Если этот бул true, то значит она ничего не делает, значит все в порядке.
А если она false, то она возу пить.
Возу пить.
Там возу пить начинает там что-то кричать и выбрасываться из программы.
Да, официально это называется terminate.
Чего вообще прям все программа.
Ну то есть это типа вызывает искусственный runtime error.
Ну по-хорошему, конечно, это самый такой примитивный способ возу пить.
То есть самый такой тупой.
То есть просто.
То есть по-хорошему, конечно, так не пишу.
Как вы в будущем обязательно будете подробно изучать.
По-хорошему, тут надо написать, что if root,
то там throw,
какой-нибудь там new exception,
там называется условно empty heap,
называется exception.
Там от чего-нибудь от root или там как-нибудь еще там бла-бла-бла.
Вот.
Да.
Да, то есть по-хорошему так, чтобы как бы и там кто-то мог слови,
чтобы кто-то там мог этот вопешь на самом деле перехватить.
То есть тогда там какой-нибудь код это вызывающий,
он там типа там пишет что-то типа там try,
значит там try получить дитмин и там попытаться кейч.
То есть если ты его запил вот этим вот конкретно образом,
на частоте там 103.7 FM,
то значит тогда мы вас аккуратно перехватываем,
ага, пустая, хорошо.
Ну вот.
Нет, если не будет, скажем так,
если ничего не делать, то вылетит.
Абсолютно так же.
Но просто дело в том, что это исключение может быть выше по стеку запуска функций,
быть перехвачено.
То есть там где-то выше может быть написано такое,
try там допустим ans, там допустим ans равно дитмино true.
И теоретически можно написать,
ну тут вот так наверное,
и написать там допустим кейч,
значит empty heap, там exception.
И в принципе, то есть если это произошло,
то на самом деле просто выполнится вот эта часть кода,
и тут вы тут обсуждаете, что в этом смысле надо делать.
То есть я не знаю там принт, допустим.
Ну вот.
Там те дот пытались найти нот.
Пытались найти минимум.
В пустой куче.
Нет, почему нет?
То-то оно, что если кейч успешно произойдет, то будет выполнять.
Но если вы тут.
Нет, ну это не совсем jump.
Нет, это больше там.
Ну больше naive znl.
Там похоже на самом деле.
Нет, то есть это не jump.
То есть если тут произошла ошибка, то мы ее перехватываем.
Но обычно, конечно, эта ошибка видимо передастся выше,
потому что это все-таки механизм отлова ошибок,
но он нацелен на то, чтобы у вас ничего не произошло.
Ну там в каких-нибудь глобальных программах,
на самом деле, которые у вас на год-два работают,
типа поиска Яндекса.
То есть там, понятно, программа не должна вылетать из-за того,
что у вас там где-то в коде ошибка произошла,
потому что, мало ли там, кто и когда ее написал,
может там новенькая не отлажена еще.
Вот, ну а соответственно такую ошибку мы, соответственно,
перехватываем, аккуратненько обрабатываем,
продолжаем работать по-старому, но там условно разработчикам
передаем, что у нас тут бара произошла.
Вот, то есть это вот вообще зачем это нужно?
Понятно, что в условных там, в Олимпиадах, естественно,
это все не надо, но вот.
Но в реальном, то есть в Олимпиадах, конечно,
крестьянского вполне хватает.
Так или даже, можно сказать, даже гопнического такого,
да где-то даже.
Вот.
Ну ладно, не гопнического, а это такого.
Ладно, тут больше на ребенка трех лет похоже, на самом деле.
Да там двух лет.
То есть если все плохо, мы просто начинаем кричать.
То есть как бы, то есть здесь просто...
И всем плохо.
А здесь...
Что такое?
В обертке конфет и нет конфет.
Сейчас порешаем.
Все, и никто не кричит.
Вот как-то так.
Такая вот примерно разница.
Вот.
Так вот.
Ладно, в общем, ассект не ассект.
Ладно, уберем это.
А то у нас доска маленькая.
Так, но если root есть, то, конечно же, значит,
мы быстренько возвращаем его.
Что там мы делаем?
То есть return, root, стрелочка, key.
Все.
Ну и здесь все просто.
Это был get pin.
Вот.
Так.
Ну что у нас теперь?
Так, ну давайте напишем теперь.
Ладно, вот в этом зеленом стиле тогда уже void extract min.
Но на этот раз бы указатель по ссылке передавать.
Что мы в нем сделаем?
Так.
Ну, во-первых, ассект root.
Так, что мы теперь сделаем?
root равняется melt root left right.
Да, очень хотелось бы.
Но просто, ну, конечно, да.
Олимпиагики бы в этом месте написали бы просто
действительно root там равно melt от root left root right.
У нас копировать указатель налево направо,
не долить root.
Вот.
Да.
Но, конечно, в более, короче, адекватном коде от вас потребуется
ноде звездочка,
допустим, tmp
равно root.
Вот так.
То есть зачем мы это сделали?
То есть мы, ну, то есть мы это естественно сделали
вот здесь, правда, небезопасно, то есть по-хорошему.
Да, здесь вот, да, то есть указатель мы переприсвоили.
Теперь надо сделать delete tmp.
Ну и все.
Но, правда, тоже, видимо, не идеальный вариант,
потому что по-хорошему, если мы так об этом заботимся,
то нам по-хорошему, по-хорошему иногда бывает,
что нам в ноде неплохо было бы, конечно, и компара,
и какой-нибудь этот деструктор написать.
Ну вот.
Ну, видимо.
Нет, ну как?
Нет, ну как пофиг, на самом деле нет.
Ну вот.
Ну, на самом деле ладно, хотя, честно скажу, правильно,
на самом деле так, вот это мы пишем для себя,
а если бы мы писали идеальную кучу,
мы бы писали struct leftist hip,
внутри которой был бы указатель вот это ноде
и были бы обертки вокруг этого всего, на самом деле.
Ладно, это мы совсем не будем, это мы не будем писать,
мы сейчас как бы не для этого все делаем.
Так, ну и пришло время его величества melda,
а также мысли о том, а где его писать.
Extract min, вот у нас будет Extract min просто удалять,
хотя, ну, мог бы и вернуть при желании,
там я вам можно две строчки написать.
Вот разделил Get min, Extract min.
Вот.
Вот мы его вернем, и у нас будет elite пишет,
то есть у нас же return тогда в конце будет?
Нет, ну я бы дописал бы там что-нибудь,
типа там в начале tk ans, равно там root key и потом в конце.
Да, да, да, конечно, конечно, это как бы не проблема.
Вот.
Ладно, более этого можно было бы,
как вы узнаете, в следующем семестре написать std move,
от этого, от этого root key,
и это было бы даже более правильно,
потому что move семантика позволяет не делать копирования,
в подобного рода ситуация, не делать копирования,
а делать что-то более умное.
Вот.
Ну, потому что тупо, как бы сказать, да,
то есть это я не, как бы и так,
то есть как это называется, смотри.
Так, Вася, для безопасности нужна твоя копия.
Там Вась говорит, окей, вот моя копия.
Да, точная копия.
Да, отлично.
Ну, кому это надо?
Как бы и называется, то есть так делать не надо.
Почему так делать не надо?
Правильно, мы потратили лишнее время.
Вот.
Ну, там лишнее время, лишний патрон.
Ну, кому это надо, господи.
То есть на самом деле, как это называется потом вопроса,
господи, а не легче было Вася просто сказать,
что слушай, вот это, перейди сюда.
Вот.
Блин.
Вот.
То есть вот эта ситуация такая дебильная получится.
Вот.
Так.
Ну, соответственно, значит, пришло время немножко.
Значит, пришло время его величества.
Мэлда.
Так, как он сработает?
Мэлд.
Так, ну, давайте.
Там ноде звездочка.
Мэлд.
Так, ноде звездочка.
Хип один.
Да, мещерин будет ругаться за такой код.
Но, как говорится, мы похулиганим.
Вот.
Вот.
И так сливаем две кучи.
Как слить две кучи?
Ну, очень просто.
Значит, если не хип один,
хип один,
то...
А, я даже совсем в олимпиадном стиле напишу.
Хип два.
Вот.
Ну, если вы когда-нибудь случайно, я не знаю, там сливали декартовые деревья,
то, я думаю, такой код вы писали постоянно.
Но если писали не такой, то жаль.
Вот.
То есть вот.
То есть заметим, что отдельно рассматривать случаи, когда обе кучи пусты,
даже нет необходимости.
Вот.
И так пришло время обнаружить, что у нас есть хип.
Что у нас есть два не пустых куча.
Ну, вот.
И его надо как-то слить.
Так.
Ну, теперь возникает вопрос.
Кто же будет корнем?
Да.
Минимум из корней.
Но для того, чтобы не рассматривать случаи,
мы применяем еще один стандартный хак вида, что...
Чего?
Настолько олимпиадный метод.
Чего? Ну, вообще, да.
Ну, ладно.
Нет, ну, свапы.
Вот это тоже не обязательно олимпиадный метод.
Это как бы везде применяется во избежание копипасты.
Просто как минимум.
Вот в данном случае это получается.
Там, если хип один ки оказался больше, чем хип два ки,
то мы просто делаем свап.
Свап хип один, хип два.
Вот.
Это очень удобно.
Почему это очень удобно?
Потому что теперь мы гарантируем, что у нас минимум находится в хип один.
Вот.
Ну, и что мы теперь делаем?
Ну, и что мы теперь делаем?
Тогда мы говорим, хип один, райт, равно, соответственно, вызываем рекурсивный мэлд.
Хип один, райт.
И хип два.
Так.
Вот.
Ну и что? Теперь остается только,
ну, во-первых, проверить ранги.
То есть, если хип один, райт,
РК оказался больше, чем хип один, лэфт, РК,
то, соответственно, свап опять.
Свап хип один, лэфт,
и хип один, райт.
Вот.
Ну и, конечно, не забыть пересчитать ранги.
Хип один, РК, равно хип один,
хип один, лэфт, РК, плюс один.
Во.
Не сильно сложный код, да?
Так.
Вот. Да, сразу высекает, действительно, вопрос.
А я тут это не, да, не сильно ли нагло я тут себе начинаю представлять, что
оказывается, что у этого хип один оба ребенка существуют?
Ой, так, да, минимум, минимум, минимум.
Так.
Вот, действительно, высекает вопрос.
А не сильно ли нагло мне предполагать, что в результате этого молда
и левый ребенок, и правый ребенок у хип один будут существовать?
Ну, скажем так, гарантируем, что в результате молда
правый ребенок существовать будет, потому что мы только что убедились, что хип два не пустой.
Но существует ли левый ребенок хип один, этого мы не знаем.
Да, но кто сказал, что мы не сливаем, скажем, кучу из одного элемента с кучей из одного элемента.
Так что да, поэтому придется применить еще один популярный в олимпиадной среде лайфхак.
И писать здесь, конечно, немножко по-другому, то есть придется писать дед РК.
Вот.
Вот.
Вот.
О.
Так, ну и конечно здесь тоже придется дед РК писать, потому что мало ли.
Значит, дед РК от хип один.
Right.
Ну и плюс один.
О.
Так, ну, функция.
Ну вот, ну и там какая-нибудь стандартная функция.
Естественно, да, как она там пишется.
Ну уж совсем уж раз.
Там дед РК от ноде, звездочка.
Там root.
Так.
Значит.
И вот.
Вот.
Вот.
Вот.
Вот.
Так.
Значит, и тут мы пишем.
Ретурн.
Рут.
Вопросик.
Рут.
Значит, РК 2.0.
Да, вот, кстати, у нас вот в этом месте и сработало.
Если дерево пустое, то типа у него ранг 0.
Вот.
Ну, такая вот стандартная штука.
В принципе, в одну строчку даже вообще пишут.
Очень красиво.
Вот.
Так что это леватская.
Вот так пишет леватская куча.
Ну вот.
Так что вот такая вот красивая леватская куча.
Все операции за локарифом.
Все просто.
Как-то даже сильно проще, чем эта ваша бинумиальная.
Но как-то есть подозрение, что бинумиальную кучу, которую мы обслуживали в прошлый раз,
писать сильнее и сложнее.
Вот.
Так вот.
Ну и есть теперь другая фишка.
Вот.
Но, оказывается, казалось бы, все хорошо.
То есть вот мы тут практически на доске практически всю кучу написали.
Видите, кода тут вообще практически не особо много.
Но называется тут, идут и дальше.
Но кто-то может придраться дальше.
Казалось бы, чему тут можно придраться?
А вы, ну вот.
А выясняется, выясняется, что у этой кучи есть недостаток.
А давайте подумаем.
Да.
Пожалуй, давайте подумаем.
А если нам очень хочется тыкнуть какой-то первый попавшийся элемент.
И его там, соответственно.
То есть, ну вот, и нам бы его хотелось удалять.
Ну вот, научиться удалять.
Ну, в худшем случае, у отель в вершинах изменится ранг.
Так.
Оценки, конечно, не вырубают.
Так.
Ну, во-первых, начнется с того, что начнутся проблемы, конечно, с тем, что, конечно, у каждой вершины, видимо, придется еще и родителя хранить.
Ну да.
Но мы прописывать не будем.
По умолчанию, в общем-то, в дефолте, как бы версии кучи, в общем-то, никаких рейзов рандомного места не подразумевается.
Но уж давайте пофантазируем.
Так.
Допустим, нам нужно удалять из рандомного места.
Что делать?
Страдать?
Нет, ну господи.
Даже если мы сможем ее в глубину, ее поднять наверх, удалить, сделать стол.
Нет, ну как сказать, поднять ее на корень, это, конечно, хорошо, потому что, если уж подняли, то, значит, понятно, там просто сделали экстракт мины и возрадовались.
Возможно, у нас есть три кучи.
Но, наверное, не три, то есть мы берем то, что под рутом лежит без этой штуки, плюс послабанная в родителе и два потомка.
Какие два потомка?
Ну не только там.
Ну да, то есть казалось бы, да, действительно, как бы мечтой могло быть, что вот жила была вершина, мы хотим ее удалить.
Ну казалось бы, просто взять ее, удалить, там детей, соответственно, слить и результат слить оставшейся кучей.
В чем проблема? Почему это нас не устраивает?
Нас-то не устраивает по одной простой причине.
То есть при таком удалении у нас тут на самом деле могли быть, в пути до корня могли быть попорчены все ранги.
То есть по-хорошему говоря, мы должны пробежаться по этому пути и там посвапать детей, если с рангом...
Ну там вообще пересчитать ранги и там посвапать, если что-то произошло.
Вот, понятно, да?
И это может быть долго.
Куда проталкивать?
А как вы будете, ну вот, а как вы будете пересчитать ранги и там посвапать, если что-то произошло?
А как вы будете пересчитать ранги и там посвапать, если что-то произошло?
Куда проталкивать?
А как вы будете, ну вот, а как вы будете понимать, идя сверху, вообще, куда проталкивать?
Тем более, особенно когда глубина не логарифм.
Не, придется как-то, что-то придется сделать поумнее.
Чего?
Ну, конечно, делается, значит, не рассказывал.
И таки не предлагал даже быстренько придумать.
Только давайте чуть-чуть подумаем, как же это можно было бы сделать.
Прям вообще другую, прям элементы, прям все в другую кучу отправить, а за линию, да?
Это, конечно, да, но это не спортивно, но хочется, наверное, побыстрее.
За линию можно было и, извиняюсь, и, называется там, и сифтап сделать.
Проще было бы, и в большинстве случаев быстрее бы работало.
Так, слить ее с поддревом, а потом ее удалить.
Да?
Нет, в принципе, это уже интересная идея, кстати.
Да. Нет, там вообще уже начнется интересная идея.
А зачем отпиливать все поддревы, чтобы литр не был, чтобы он не был?
Да, нет, нет, нет, нет, нет, нет.
Вот, в общем, это уже интересная идея, кстати, да.
кстати да нет там вообще уже начнется интересная идея а зачем отпиливать все под
дерево давайте лучше вот как бы эти этого подъема подержим и под повесим его на
место этого элемента но правда правда проблема такая что ранг
правда же интересно от того что мы удалили вершину и слили две логба от
этого ранг увеличится нет ну то есть что-то из цикла мало ли там какой перекос но
вот хотя заметил что нет ура нет уран кеша нет ранг любой вершины не
происходит логарифма это безусловно но просто интересно может быть так что
был тут у этой вершины ранг 5 а мы тут слили детей ранг стал резко 9
так и сколько это будет работать да а кто сказал что путь до корни это лог
так а почему именно до первого левая ребра так то хорошо да заметим что некоторое время
там идем идем идем туда тут расстояние точно логарифма а левая ребра и чего а в
левом ребре что да логарифм да остался квизи да то есть оценка оценка логарифма
множество количества левых ребер да замягчать а если мы докажем что левых ребер от единицы то
будет кайф правда проблема не докажем да я боюсь он хотя нет может конечно там в смысле
какой-нибудь жутко амортизации может когда-нибудь и докажем конечно да но но нет тут все гораздо проще
да
куда проп. ну в нашем случае да да ну сейчас примет же не очень понятно нет я
но я утверждаю что ранг в ранг не имеет никакого отношения к размеру
давайте обновлять ранги пока они обновляются как только какой-то вершины ранг не обновился мы
остановимся но в принципе да да интересная идея что если в какой-то вершине выяснило
что ранг не поменялся то дальше ходить бессмысленно не факты не факт наоборот
но он же прийдите вот у меня был у меня ранг 5 был у меня тут ранг 3 поэтому тут был ранг 6
тут был ранг 4 а тут бабах вместо ранга 3 ранг я же достал 8
да он обновится и станет 6 но с другой стороны действий-то нет праведности
как бы да вот как бы нам вот а вот же вы все действительно а могли бы вообще добиться того
чтобы когда мы тут берем сливаем эти деревья чтобы у нас тут ранг и не стал больше ну например ну да в
принципе да кто сказал что мы эти результат этого слияния должны вешать сюда они потом когда-нибудь
они потом в исходные дерева тогда замечу ранг здесь точно уменьшится потому что он станет 0 но
тогда действительно и тогда логика начинает работать действительно это то есть логика нет
не сливаем отпиливаем прям отпиливаем эту вершину вместе с там поспотеем просто тогда
у нас остаются косяки с рангами у на этом пути но значит идем честно вверх и честно
пересчитываем но на этот раз действительно если ранг какой-то вершины изменился то он равен
предыдущему рангу плюс один и тогда получается что не более чем через логарифом шагов мы
встретимся столкнемся ситуация когда ранг вершины очередной вершины не поменялся и дальше ходить не
надо но да то есть получается у нас это то есть мы тут отпилили пошаманили все корректно то есть
единственное что у нас помимо этого останется вот это дерево в котором мы эту корень удалим но
то есть фактически экстракт мин сделаем да там эти деревья сольем результат сольем все а вот
потому что кодовая идея такая что вот ранг этой вершины точнее этого дерева неожиданно уменьшился
до нуля да теперь движение такое тогда вот рассмотрим у этой вершины у этой вершины ранг будет
либо 0 плюс 1 либо значит то что было тут но если он уже был один да то значит тут только
ничего не поменяется да значит тогда тут один что тут тут у нас ранг либо тогда два либо то что
было тут вдруг если тут висит 0 то тогда ранг будет один но тогда ранг не поменялся и получается
ничего делать не надо вот но если он поменял но поменяться он мог только в том случае получается
если как бы тут стало меньше и за счет этого ранг уменьшился и так далее то здесь тоже 3 4
и так далее все но да то есть получается мы таких шагов сделаем не более чем логарифом ура так что
в общем-то красота благодать хорошо но и получается что в некотором смысле рейзит действительно
делается за логариф так сколько у нас там времени проблемы уже ни в чем уже победили то
есть фишка оказалась том что на самом деле мы в какой-то момент ушли немножко не туда подумав
что удалили вершину давайте сольем под деревья и повесим и повесим их прям сюда этого это была
но это была проблема казалось что давайте лучше не там отпилим но вешать их не будем
лучше их там действительно смёржем но потом смёржем со всем остальным в конце оказывается
это хорошо работает так что вот такой вот так что вот такой вот маленький красота
такой вот красивый логарифмический куча вот да удалять можно так ну хорошо давайте думать
какие еще недостатки можно в этом выкопать но оказывается в этом практически идеальном куче
но особенности что в куче рейс из рандомного места вообще обычно не пишут то есть казалось бы
код прям вообще мах то есть маленький код константа очевидно тоже не угодно но тут как
говорится до писавшие всегда вчера писавшие вчера все сиб могут обнаружить что этого что у
этой кучи есть проблема она жрет лишнюю память да казалось бы господи сколько там этой памяти
а вот оказывается что в каждой вершине у нас хранится лишний ранг то есть лишние 4 байта как
минимум ну то есть указатель этом еще можем оптимизировать да потому что там какой-нибудь
статическое хранилища мы заведем там так бы там да в олимпиады языке это называется заведем
свое статическое хранилище там там в курсе c++ будет называться построим посчитаем там там
построим свой локатор так а такими словами вы еще тоже не ругаетесь да ну будете не волнуйтесь
да вы будете еще писать свои локаторы там это все вот вам еще предстоит вот но тут вы все тут
неожиданная задумка то есть давайте я напомню страх ноде но напомним что у нас там хранится
ключик ранг ансайнт вот и там что там лев трейд
говорим вот так вот нам эти 4 байта на каждый элемент не нравится
а все равно лишняя память вот знаете нет это и это ну в реальности это на самом
деле может быть критично потому что вот например вчера была интеллектуальная задача на напишите
вроде дикартовый дерево ну упихайте его по память вот да вот далеко не все справились да то есть
там я не знаю там видимо там вот ну как-то с этой проблемой справилось сильно больше народа чем
с проблемой упихай персистентная дыда да с параллельно так что перс перс дыды там всего
пять команд стало то есть там какой-то геометрию с эллипсами это больше народу сдало как-то вот
так что вот отдельная песня поэтому иногда по памяти приходится упихивать
если мы будем все время тут молды вызывать вызывать вызывать то как бы это будет
долго а если просто слить и подвести проблем в том что ранг тогда этого дерева может оказаться
как и странно больше чем ранг вот этого чем ранг этой вершины но вот есть такой риск да
ну потому что у нас нет а потому что у нас как бы ну то есть добавку слس подумать гарантии что
каждый следующий ранга будет больше то есть там проблема в том что да то есть там поэтому не
будет то есть не будет гарантий шоу как бы обновляться будет через это то есть невозможно
на всем пути то есть там то есть окажется что транг станет жирной и в результате так на всем
путира там сиранги поуменьшают там как-то но не поуменьшается поувеличиваются и тому проблем
но так я может может это можно обойти может а можно додумать что-то на языке вот этих правых
левых ребер вот но мы просто не будем этим заниматься вот так вот значит все же нот значит
то есть проблема на самом деле серьезная то есть более того вот возможно кто-то задавался вопросом
почему-то в стд сети не написано конь простая дикарчачка написано какая-то красно-черная
радость а вот одна из причин на самом деле но то что красно-черная радость не требует дополнительной
переменной вершины она там требует бит то есть просто один бит это вершина красная или черная
еще более того не бит куда-то там вот указатель не пихивает вот ну то что указатель весит там
допустим ваши 32 или там все 4 байта или что там сколько-то весь то скорее там вся 4 бита но
скорее всего какие какой-то из этих бит вы почти наверное не используете поэтому этим можно
пользоваться то знаете вот потому что оказывается одна из технологий там скажем
пихать задачу оказалось вот именно что там запустим дфс и там и удалим все вершины которые
дфс не прошел только ой юзет тоже весит очень много памяти но ничего страшного эти лучше там
в нижнем указатель и лучше там найдем пустой бит и будем там работать с ним нет шутки шутками
елки-палки реально такое написали ну что-нибудь такое да ну там развлечение такое но там указателей
правда не было там были как бы индексы на статический массив естественно но это уже
совсем другая история но в таких вещах на самом деле когда начинается такой пехон иногда
ощущение что про что некоторые фичи си продвинутого си плюс плюса лучше знать не то есть лучше перед
лучше написать но в скульном си будет хорошо ну вот так что да ну ладно но крисла да это было
вчера подробно то есть может быть какие-то там меньше подробности может когда-нибудь на
разборе обсудим вот сейчас не будет но пока лишь скажем такое что иногда прям вот это вот 4
байта памяти могут очень сильно раздражать вот спрашивается а можно ли сделать так вот можно
ли сделать так чтобы вот этого чтобы эти 4 байта памяти не хранить вот ну ладно тут сразу скажу
потому что просто так не догадает оказывается неожиданная фишка оказывается идея такая а
давайте это тупо ранг не хранить просто так практически просто вопрос по реализации на
самом деле только один так ну понятно что ладно это мы убираем и вот в этом условии надо написать
что-то другое я больше скажу так и есть но по хорошему ладно это называется просто
ифу берем а свапаем всегда то типа нам же нужно понимать когда свапать до свапы всегда господи
что ты паришься вот вот нет почему нет нет противского куча работает медленно так вот
мистическое утверждение которое мы сейчас будем долго и красиво изучать после переговора
это работает нормально нормально как сказал бы классик да найдет только не рандом не
рандомно а амортизировано не знаю не знаю не пробовал но мы не изучаем что они верят
пока я только скажу что эта куча называется касая вот
значит это такая ливацкая куча в которой значит ранды не считаются вообще а когда надо думать
а когда мы вот при мелде там свапы мы свапаем всегда вот так что так это мы будем значит пока
проблема но с точки но так и так с точки зрения вариантов конечно не проблема теперь мы уже с
точки зрения варианта можем выпилить все что угодно но тут все зависит от того как у нас
устроена амортизации там потенциалы с которыми будем жить вот поэтому придется конечно подумать
но вообще принципе как бы неплохо придется подумать на тему того что как у нас то есть
насколько это хорошо работает но здесь вот такое преимущество что можно один раз хорошо подумать
зато там в коде будет все там все элементарно без лишних рангов и по памяти оптимизировано
ну типичная ситуация в общем-то как бы пирс дд тоже оказывается работает это оптимизация то есть
ну то есть допустим вот то есть зачем вы удаляете вершины для того чтобы в том же буфере если вам
понадобится новые вершины переиспользовать правда теперь возникает вопрос а как найти какие вершины
переиспользовать а какие нет ну желательно быстро ну вот ну кто-то но дефолтный способ как бы давайте
просто заведем какой-нибудь там список в котором будем хранить какие вершины использовать еще
после там можно использовать какие нет но это тоже жрет лишнюю память поэтому что мы делаем поэтому
что мы делаем правильно мы поговорим так сначала используем тупо но когда там буфер закончился
мы значит там запускаем вышу выше описанных dfs а потом просто заводим указатель и тупо идем
слева направо так нужна новая вершина так это работа это занята занята это занята занята
это занята это занята не занята берем и в принципе если гарантируется что вы этим dfs как бы там
нашли где-нибудь там ну хотя бы там четверть треть звать буфера пустых да то в принципе амортизировано
это получается а симптомы там ничего не портит ну то есть это идея такая что пустые вершины еще в тупую
но там пирс дд я имею ввиду да причем тут перс дд вот но как бы да хотя кто вчера все си писал
ну нет все си нет как как вчера все писавшие убедились это ваще не для школьников это прям
это прям жестко не для школьников нет ну там не да не то чтобы там да не то чтобы там какие-то
там условия какие-то не те или там что-то еще в этом роде не но это все дочам оказался серьезный
я думал что это будет типа квала но оказалось что прям вот классный контест на самом деле да то есть
может он конечно мог быть сложнее потому что там всякие елки палки конечно справились за три
с половиной часа но давайте но но таких оказалось не сильно много да то есть там на самом деле
чего нет почему там помонута мне про что там что-то типа то ли три там по-моему ты по-моему там
то есть там справились и кто-то еще а все-таки 5 тоталки там 5 тоталов или 5
акцептов по этой задаче да а пингзу не ничего себе ну бывает так что да как бы правильно на все
себе побеждает тот кто пихает ларенька но чем короче говоря ладно это на самом деле
лирическое отступление но нам но но она нужно переходить более подробному изучение но изучать
мы этот кучу будем уже после перерыва до нас произошла магия монтажа видимо это за за время
перерыва наступила зима если судить по мне но так такие о чем мы ставили там мы ставились на
том что вливаться куче оказывается можно не считать рамк а в малдея как при проходе вот снизу
вверх swap делать прям всегда вот но мы утверждаем да значит мести но естественно все остальная
реализация не меняется от слова никак ну то есть всякие технологии в духе что там как бы вставка
это создание кучи из одного элемента и там и мерч или там экстракт минут это там мерч дитей
кофе и так далее это все остается ну и рейс мы пока вынесем за скобки нам придется его еще по
анализировать но мэлт это конечно то что нам действительно потребуется так ну давайте
смотреть вот утверждается что логарифом будет все еще иметь место но в амортизированном смысле так
ну давайте код ладно код я думаю всем понятен идейно все понятно это сейчас мы уберу это мы
давайте все поубираем вот но давайте смотреть значит за счет чего у нас будет амортизация
вот ну естественно конечно чтобы сделать амортизацию но у нас было три способа ввести
амортизацию мы воспользуемся последним то есть это самый удобный способ когда надо что-то
уже именно доказать ведь конечно отдельная песня когда этого будет когда этого было додуматься но
тем не менее идея очень просто дальше мы введем потенциал вот который будет равен к чему
вот так ну давайте так для начала ведем определение значит вершина да давайте скажем
определение вершина значит в если допустим сз от в райт у нее больше чем сз от в левт
как мы ее назовем тут я тут я понял что у меня в голове нет устоявшегося термина нет правая нет
плохо потому что правый ребенок это как бы не обязательно как бы правый ребенок тогда не
будет не обязательно является правой вот в этом смысле вершины ага право перекошенное ну давайте
две секунды подумаем покороче нельзя вот тогда у нас будет естественный термин право перекошенное
лево перекошенное но вот нет ну ладно давайте права кошеная так права кошеная хорошо
ладно только право сыкошенная все-таки
вот и теперь сейчас ведем потанцевал потанцевал это количество права скошенных в экшен
да важно отметить что так как мы изучаем сливаемой кучи то у нас как бы в системе
находятся несколько куч и мы в каждой из них нам интересные провоскошенные вершины нам
интересует их общее количество вот понимаете да так вот но давайте разбираться значит зачем
нам нужен такой провоскоз сейчас учит как болезнь до какой-нибудь а провоскоз головного мозга там
это нет или даже туда слушайте да у меня проблема какая у моих детей правоскоз он нету на самом
деле никакая проблема на самом деле у всех такая проблема просто у кого-то правоскоз у кого-то
левоскоз ну либо у кого-то идеальная гармония да я не знаю но это бывает редко то есть это совсем
уже прям близняшки нужные обычно да вот вот и так хорошо так правоскошенные вершины так но
теперь давайте думать как у нас но для того чтобы понять как у нас что-то будет меняться мы теперь
заметим следующие да сколько у нас может быть в куче права скошенных вершин сколько угодно это
максимально правильный ответ потому что да их может быть 0 их может быть n их может быть любое
количество вообще в принципе заметим что мы легким но то ли просто одним легким свапом можем
по идее любую вершину сделать провоскошенный или наоборот лишить ее этого статуса ну ладно с
оговорочкой что если у по такому определение конечно есть шанс что у вершины там два одинаковых
тогда провоскошенная она не станет вот но если такого везет если такого счастья нам не дали то
соответственно ничего не будет вот да провоскошен но теперь высказал просто давайте посмотрим
не сколько всего у нас может быть провоскошенных вершин а вот давайте посмотрим а сколько у нас
провоскошенных вершин может быть на правом пути вот этот вот вот этом вот замечательном правом пути
да нет ну совершенно верно действительно то есть право то есть действительно плохих
то есть действительно по идее как бы и куча может вполне себе быть правым бамбуком вот да бамбук
бывает правый и левый соответственно но понятно чем не отличаются да но логично вот так вот если
куча будет просто вот правым бамбуком то тогда провоскошенными будут все и как бы их может
быть сколько угодно да совершенно верно а теперь но теперь более веселый вопрос а сколько у нас
может быть не провоскошенных вершин на правом пути и вот тут-то выясняется что на правом пути
не провоскошенных вершин у нас оказывается логарифом вот ну почему потому что когда мы
идем снизу вверх когда мы приходим в не провоскошенную вершину то сайс увеличивается в два раза что очень
вот классическая достаточная идея даже весьма будьте здоровы да то есть да скорее всего в ее там
возможно кто-то из вас ее встречал там ну так где вы ее встречали чего ну как минимум хлд
конечно же хлд просто на этом базируется но ранговая истика ну в таких терминов тоже но там
скошенности такой не а ну ну там немножко не то все-таки не совсем вот но там на самом деле то есть
эта идея там было очень много где может встречаться то есть я думаю в каких-нибудь там мы еще там
не хотим сплэйтируем ее не встретим да но там много где может встречаться тут даже неожиданно
что мы ее встретили именно здесь уже в кучах вот но действительно оказывается не провоскошенных
вершин то есть это прям вот то есть такое мистическое синее утверждение на правом пути
пути не более чем двоичный логарифом n ладно так и быть плюс один не провоскошенных вершин
это новое про вот то есть но обратить внимание да я думаю понимаете тонкую разницу между
не провоскошенный и левоскошенный вот так вот сейчас значит и тут начинается шоу дальше шоу
дальше начинается вот какой так ну теперь давайте думать как наш потенциал будет меняться но на
самом деле заметим следующее вот вот у нас было вот это вот слияние да то есть у нас принципе
можно сказать алгоритм стоит из двух частей в первую можно себе такое вообразить понятно
что рекурсивно он конечно будет немножко по-другому работать но мы его можем себе
так сначала мы делаем вот такое слияние а потом пробегаемся снизу вверх и у каждой вершины делаем
свап понимаете да вот понимаете вот а теперь давайте подумаем а как это скажется на право
но на правоскошенных вершинах но идея очень простая вот мы сливали два дерева красные и
смотрите заметим что но первых с точки зрения интересует как поменяется потенциал ну потенциал
поменять так да что было у нас то есть помните да у нас было изначально две кучи красные синие
у каждой из них был свой потенциал да я не вовще потенциал входили как сумма вот но потом они
объединились в один и теперь но ты появилось там новое количество провоскошенных понимаете да но
заметим следующее что так как вот эти деревья не меняются то по идее их вклад потенциал в
общем-то особо но то собственно не поменялся да и не особо тоже правда поэтому значит то есть
давайте смотрим поэтому а что но а что же поменялось давайте скажем вот что давайте попробуем
ввести значит к-1 пусть у нас к-1 количество провоскошенных вершин
вершин на правом пути
первой кучи
кучи перед слиянием
вот
и так значит и будет еще к-2 значит к-2 тоже самое прям копии паста только вместо
слова первое будет слово второй и пусть у нас к тоже самое то есть мы скажем так после слияния
но перед
проходом свапов вот так скажем
да свап не сватов а свапов да вот понятно да а теперь давайте изучим давайте внимательно
поймем как мы могли бы оценить реальное время работы данного молда
что да заметим что вот этот проход на самом деле да был бы то есть реальное время получается
к-1 плюс там соответственно к-2 плюс 2 логин вот я даже так напишу я напишу к-1 плюс логин то
есть вот так потом пришел плюс к-2 плюс логин вот это было время работы непосредственно
мержа то есть самого слияния да вот да это еще не все то есть вот реальное время работы
потому что ну мы работаем за ну реальное время работы это у нас от количества суммарного числа
вершин вот в этих вот путях правда право не не факт вот у нас к-1 провоскошенных но еще
сколько-то не провоскошенных но не провоскошенных у нас логарифом поэтому я здесь вот логарифом
да у нас было утверждение на именно на правом пути не провоскошенных логарифа именно на
то есть если вы там от какой-то вершины до корня пойдете то это будет естественно не так но на
левом пути так вообще ну почем как по почем как повезет у нас инвариантов больше нет у нас
двоичное дерево формально говоря может быть каким угодно вот это вот к-1 плюс логин это к-2
плюс логин далее да это еще не все это было только слияние теперь у нас еще есть но вот
но в общем-то и все потому что да после этого надо пройти то есть сделать вот этот вот проход
конечно снизу вверх и сделать эти все свапы но это делается буквально за такое же время вот
хорошо это было реальное время а теперь давайте подумаем как меняется потенциал
то есть но давайте давайте смотрим потенциал до
давайте так потенциал до там был да но чтобы не было это в рекламе да ну вот фе 1 плюс фи 2
вот а теперь поехали потенциал после
после потенциал после что а теперь поехали значит будем теперь думать то что понятно
начинаем с фе 1 плюс фи 2 ладно только неправильно написал фе 1 плюс фи 2 правильно писать фе 1 плюс
фи 2 вот возможно у тех кто не смотрит лекцию слушает возникнет вопрос но лекцию надо
посмотреть вот и так потенциал после вот значит поехали тут фе 1 плюс фи 2 так значит теперь
смотрите как меня значит как поменялся потенциал в результате непосредственно маржа
нет эти у этих всех вершин провоскошенность поменялась прям принципиально можно сказать
мы может говорить мы старую провоскошенность затерли и нарисовали новую поэтому получилось
минус к 1 минус к 2 но зато плюс к мы убили права старую провоскошенность но появилась
новая а теперь неожиданный прям элегантный способ убить и эту провоскошенность прогуляемся
по этому правому пути снизу вверх заметим что это провозка что торжественно то есть у нас
это провоскошенность так вот так и скажу вот я так это вот мерзь без свапов но когда мы
прогуливаемся и свапаем заметим что каждая провоскошенная вершина перестает быть таковой
правда поэтому получается капру провоскошенных вершин исчезают но зато те кто не были
провоскошенными могут случайно ими стать но тут мы неожиданно замечаем что их не более чем
логариф неплохо тогда так что по идее вот этот вот сразу шлёп шлёп так тут это вот не это не
сигма это меньше либо равно вот так но теперь получает остается только написать учетное время
работы то есть учетное время работы у нас получается какое значит ну получается к1
нот получается у нас что-то типа там к1 плюс логан плюс к2 плюс логан ну вот
но и тут соответственно значит тут у нас фея нот но тут тогда что у нас получается теперь
прибавить потенциал в конце вычесть потенциал в начале да ну значит давайте вычтем потенциал
в начале он там был минус 1 минус фи 2 вот так значит потенциал в конце пишем плюс фея 1 плюс
вот давайте прям честно переписываем плюс фи 2 значит там получается минус к1 значит
тут 2 минусы да минус к2 так и сразу плюс плюс вот это вот меньше либо равно логариф
так ну что мы видим ну тут прям сразу шлёп шлёп шлёп шлёп шлёп шлёп
шлёп шлёп да плюс вот это вот вот это вот меньше и это все меньше либо равно трех логарифа
все что-то оказалось даже и не сильно сложно вот то есть в принципе это оказался такой
вот элегантный способ на самом деле если у вас проблемы с памятью то загнать ее в амортизацию то
есть амортизация есть конечно там какие-то свои минусы но если вас не требуется одновременно
и память то есть но если как бы ресурс по времени вот для вас более доступен чем ресурс по памяти
то в принципе такая куча вполне имеет право на существование ну там так потому что ну мы начинаем
с какой-то вершины потом говорим что там то есть у меня там сс-1 что каждое следующее будет 248
будет логариф вот но просто сама эта вершина она как бы а ну да вершина сс-1 она точно не
провоскошенная ну поэтому да хорошо да можно и убрать но я в таких случаях обычно пишу плюс
единичку типа потому чтобы не заморачиваться я в общем с этой ровно с этой целью на самом деле
у вас задачи про второй минимум я прошу найти 20 там от 2 там это от 2 степени они там саму
функцию это ровно для того чтобы вы там не заморачивались там минус 3 там плюс 5 там или там
что-то еще в этом роде то есть там наверное можно доточные константы наверное допилить но не надо
значит еще раз идем значит идем по сайзам то есть идем по правом пути снизу вверх когда
мы проходим по право скошенный по не правоскошенные вершине у нас неожиданно оказывается что сайз от
права право то есть когда мы проходим от этой вершины к этой вершины оказалась не правоскошенная
то сайз здесь у тебя какой-то x да сайз здесь больше либо равно x тогда здесь сайз как минимум
2x то есть следует на сайз у тебя увеличился в два раз но отсылка вот тому же хевилайта то есть
потому что фактически в терминах и вилайта это бы называлось это легкое ребро вот ставка с
хевилайтом вот хорошо столкнемся значит еще хорошо ну да то есть просто как то есть тут
официально когда просто идешь по ребру сайз увеличивается но когда идешь по ребру ведущему
вне правоскошенную вершину он увеличивается в два хотя бы в два раза следа но вот так как
изначально у тебя сайз 1 в конце он будет n то получается увеличится в два раза он может
не более чем логарифом раз вот вот собственно и все вот так что такая вот простее но так вот
так что базовая такая вещь ну и в общем-то все так что это как бы это была косая куча но не то
чтобы это совсем косая на самом деле то есть тут тут еще вопрос кто косея на самом деле потому
что это куча или это но впрочем конечно ладно видимо чтобы проиллюстрировать видимо надо
написать какой-нибудь визуализатор там докидывать туда какие-нибудь рандомные операции потом
смотреть как там куча в итоге во что она превратилась вот но это уже совсем другая история ну ладно не
совсем так вот но заметил что хоть и амортизировано но заметил что тут ничего не поменялось то есть
как бы к сожалению то есть вот этот хак избежать то есть этот вот хак нужен был только ровно для
чего чтобы лишнюю память не хранить просто загнать эту память в амортизацию вот ну скажем так по
сравнению с косой не особо то есть они в общем-то пройти практически братья-близнецы просто я я
фундаментальный фундаментальный но требую памяти называется а я типа называется среднем
такой же но на меня может заглючить но так на самом деле это братья нет нет нет ну скажем так если
до вас амортизация это не недостаток туда вот так скажем то есть у меня не достаток что она
каждая конкретная операция может быть за линию ну как вектор но да скажи так да то есть персистентная
косая куча это печально да а персистентная леватская пожалуйста или вот еще вот кстати
на тему недостатков давайте подумаем а как насчет кстати эгоизм вот чего так звать еще раз услышу
мат значит будем вылетать понятно да называется да просто на всякий случай я не глухой я все
прекрасно слышу вот соответственно это значит что у нас соответственно такое
на читали у нас поле но получается соответственно теперь как нам теперь задача как теперь удалять
удалить вершину из прайз вольного места
так чего-чего-чего-чего-чего изменить детей чего родителя так что что-чего снять так ну слили
что так и почему это будет работать хорошо
нет это безусловно нет да но пошло в аэртизации есть одна маленькая подлянка а может у тебя от
этой операции потенциал изменился то есть так-то конечно да казалось бы просто да вы
вроде договорились что мэлт вроде работает за логарифом да и можно там действительно как мы
уже говорили ранее да там отпилить вершину слить два под дерево и результат подвесить и вроде как
бы это работает теперь за учетом логарифом если бы не одно но но заключается в том что а вдруг
то есть как бы да у нас нет варианта но есть потенциал а теперь внимание вопрос а вдруг
в результате этой операции у вас там диким образом увеличился потенциал ну а вот потому
что рассмотрим вот эти вершины да почему
потому что давайте подниматься в поле вверх слить у них потенциал увеличился это у тех у кого
сначала вот то либром потом поднимать но раньше было более тяжелым теперь стало более легкий
ну да ну можно мыслить и так ну в принципе да так все понятно идем дальше да вот но я все-таки
повторю значит действительно просто проблема в том что но проблема в том что вот это вот
операция может изменить правоскошенность не только вот вот этих вершин но и всех
остальных если их там может их может там появится слишком много и тогда это увеличит
потенциал и сделает сделает учетную стоимость не логарифм за счет этого а логарифм плюс
безобразие поэтому так просто сделать на халяву совсем не получится но заметим следующий
заметил что в результате такого подвешивания мы можем заметить что только на этом пути вообще
состояние там это правоскошность вершин может поменяться правда но во всех остальных поддельных
ничего не поменялось просто но теперь смотрите что произошло в результате вот именно такого
подвешивания кстати на этот раз нам сильно поможет чтобы мы мысливать именно так сайз вот этого
поддельного уменьшился ровно на 1 за счет чего вообще ну что вообще могло произойти с вершиной
ну у вершины мог потенциал но вершина ну как она могла повлиять на потенциал но она могла
быть провоскошенной и остаться такой а могла не быть провоскошен и не остаться такой оба этих
случая потенциал не меняют от слова никак правда понятно да да но есть еще два случая первый
случай менее интересный вершина была провоскошенной а в результате этой
операции она ей быть перестала но это нам только в плюс потому что это
уменьшает потенциал правда поэтому нас интересует более страшная нас
интересует когда вершина не была провоскошенной но в результате этой
операции она ею стало потому что мы можем оценить теперь учетное время
работы сверху как логарифа от логарифа там вот эти три логарифа плюс количество
там свежих провоскошенных вершин на этом пути вот такой термин свежепровоскошенных
да да право свежеско нет на вот именно свежепровоскошенных а то право
свежескошенных немножко другое да а очень просто вот давайте внимательно
думать это могло произойти ровно одним способом если значит это происходило
в левом по дереве какой-то вершины и более того перенепо то есть по сайзам на
самом деле то есть надо сделать так чтобы не было так что то есть но что нам
нужно нам нужно чтобы стать до было больше либо равно а тут стало меньше по
сайзу но сайз уменьшился ровно на один следовательно это могло произойти только
если непосредственно перед там перед удалением тут был по сайзам была боевая ничья xx но тогда
при переходе тогда если мы вот будем переходить получается будем идти вот по этому пути то
проходя по таким ребра мы будем увеличивать сайз два раза и получается что таких конкретно
не более чем логовик то есть идея прям абсолютно даже только с той лишь разницей что нам в явном
виде все эти версии то есть эти вершины теперь распределены по пути к уже там как-то рандомно
но нам слава богу их искать не надо нам только аналитически достаточно показать что их логовик то
есть вот как интересно оказалось что дай рейс тоже работает но как выясняется все-таки рейс в
ливатской куче и рейс в косой куче это все-таки две большие разницы как неожиданно выяснилось в прочем
может быть на экзамене вы можете попытаться доказать что в ливатской куче на самом деле
такой рейс тоже на самом деле имеем имеет место быть просто мы не доисследовали вот так что
присягнет если то есть если на экзамене докажете будет хорошо вот я правда не гарантирую что это
правда нет 2x плюс один почему нет рассмотрим состояние этого дерева до удаления да тут был
xx и там в будущем тоже где-то вот тут будет там какой-нибудь игрок игрок да ну и так далее
сколько таких вершин но так как тут сайс x а тут сайс 2x плюс 1 поэтому в два раза но тем более
2x минус 1 это на самом деле тоже не глобально что можно было сказать так это же больше ли
было чем полтора x например потому что тут x тут x и еще сама вершина ну нет ну просто ну
скажем так ну просто ну просто эти вершины обладали этим свойством перед удалением да
после удаления тут стало x минус 1 тут x а тут 2x но от этого но все равно как бы но все равно
мы посмотрели как они были перед и из этого сделали вывод что их не более чем логарифа
вообще нет просто логарифа почему ну там конечно да тут не точная даже удвоение тут
удвоение плюс даже один но на самом деле это не глобально потому что мы тут можем скакать более
менее по числам типа там 1 3 7 15 в общем короче степень двойки минус 1 поэтому это все это на
самом деле все плюс минус одно и то же там в общем-то то есть там теоретически на это могла быть там
вот в первой 5 задач вашего дз могла бы втесаться еще какая-нибудь там шестая на эту тему там
покажите что на самом деле от того что вы тут прибавляете один ли вы читаете один никакой
логарифом там называется не поменяя то есть асимптотика от этого глобально не поменяется но
потенциал но но но да но учет это время все еще логари но просто в этом логарифе просто как бы
это уже будет не три логарифа получается 4 вот так то есть он как бы из точки зрения учет
но есть так такого потенциала он жирнее вот да то есть как бы там но все еще остался от логарифа
так есть ли тут еще вопросы вот вот он на самом деле крыши да заранее вообще скажу что чисто
теоретически вообще куча на самом деле огромное количество по моему если так вы просто там
гуглонете сейчас там вики-пей то там наверное там я думаю различных куч найдете там десятка
полтора а то и два ну понятно нет все мы их изучать не будем мы так собственно изучаем так сказать
самые культовые вот но в принципе там видимо разные кучи для разных нужд могут понадобиться
может там даже на работу когда-нибудь придете и может быть там вам на работе потребуется
использовать какой-нибудь лично ваш лично конкретная куча которую удовлетворяет там конкретно
вашим свойствам то есть на самом деле это тоже важная часть кстати теоретической науки
как говорится честно не сталкивался но хотя есть крыша д-экстра стандартные да да но там правда
вам хватает обычной кучи сливаемая там не нужна нет ну в нашем курсе будет на самом деле
классическое применение сливаемых куч когда мы будем искать минус стол в ориентированном
графе то есть есть стандартный алгоритм zve вот алгоритм двух китайцев да но у него есть
оптимизация да и логу и с помощью вот этого счастья вот так же мы в нот мы с ней в свое
время обязательно познакомимся вот это как но вот но подробности как всегда то есть на самом
деле как бы если вы хотите узнать как вообще зачем нужны кучи то на самом деле их там какие
нужны структуры данных то обычно самый крутой способ просто загулять оригинальную статью потому
что писал же кто-то научную статью в каком-то журнале по этому поводу то есть на самом деле
знаете вот самое интересное с точки зрения вот я сам к сожалению докопал на эту тему но вот эти
очень интересно в этом смысле покопать статью про сплей дерева вот потому что оно но потому что
есть вот я не помню когда она называется не сплей дерева она как и мы там какими там просто
динамические деревья слейтератаре она там просто хотя хотя нет она называется сплей
дерева потому что функцию прошло название функции сплей вводят собственно сами авторы
вот но там просто очень интересно потому что статья там начинается по шикарно то есть и так вот да
у нас и есть вот у нас задача сделать двоичные деревья поиска так ну вот как идет но есть конечно
дерево вл там есть там какие-то дикарты и так далее но у всех их там свой там лавиль там оно
жирная слишком там красночерная тоже не поворотливая вот там есть еще фингер 3 то есть
она там не гарантирует там не гарантирует логарифа но она там гарантирует какую-то там асимптотику
еще каких-то параметров которые там вот которые в каких-то задачах оказываются полезными вот то
есть там и отдельные статьи там и так далее но ты но но ты много чего но проиграть что мы да то
есть на самом деле деревья много под каждую задачу нужны свои там деревья но мы но на самом деле если
вы верите в амортизацию то на самом деле можно выкинуть все эти деревья а взамен мы предоставляем то
что делает все с плей дерева да с плей дерева нет не только то есть оно говорит так так во первых
конечно докажешь амортизировано каждая операция делается за логарифом это раз во вторых лаз было
какое-то дерево которое говорила о том что мы там если мы там один одну вершину условно тыкаем
там по с вероятностью по один вторую с вероятностью по два и так далее по рецепт то суммарное время
работы там вот это вот там по один лог один делит на по один плюс по два лока там один делит на
по два и так далее но вот это вот там интерпет шинона на самом деле если вы с такой такой сталкивались
а ну как то сталкивались понятием интерпет шинона там вот вот кто-то сталкивался да вот но сталкивать
еще будет у вас еще теории информации там это все вот то есть то это нет это прото там считается что
в некотором смысле там какой-то с точки зрения информации прям это вот прям минимальное время вот
то есть теоретически вот такое но можно доказать что сплэйдёрва работает из-за эту асимптомику тоже
просто надо другой потенциал подогнать или вот вы писали вот это вот фингер три там вот так вот
сплэйдёрва работает из-за этого асимп Mongo и вот и еще там несколько там пары деревьев так что
Так что если вы верите просто в амортизацию, если вам доступна амортизация, то выкидывайте все, пишите с плайдирова, радуйтесь.
Вот, нет, на полном сервисе там реально такое написано. Ну может не настолько рекламно, конечно, но суть примерно такая со всеми ссылками.
Поэтому там вот можно по идее покопать. То есть как бы и на разу бывает вопрос, вот зачем все эти деревья, потому что с точки зрения Олимпиад будет, зачем все эти деревья, если есть дикартика?
Но да, хотя на самом деле с точки зрения науки я вообще мог сказать, зачем нужна дикартьячка, когда есть АВЛ. Вот что умеет дикартьячка, что такого, что не умеет АВЛ?
Да, значит анонс на будущее занятие, да. Я утверждаю, что АВЛ прекрасно поддерживает сплиты и мержи. Ну ладно, не прекрасно, но поддерживает.
Более того, на самом деле и красно-черное дерево, кстати, тоже. Да, мы в этом с вами убедимся. Там на самом деле все деревья прекрасно поддерживают сплиты и мержи.
Так что на самом деле вам не нужно писать дикартовый дерево, вам нужно писать АВЛ. Вот.
Но возникает вопрос, почему мы пишем дикартач? Совершенно верно. Именно.
То есть, потому что ровно по этой причине, так мы сказали, зачем деревоотреска, когда есть АВЛ.
Потому что АВЛ делает все то, умеет делать все то же самое, что и деревоотреска.
Хотя нет, ладно, это не так. Там есть отдельные задачи, где там вы там, деревоотреска дикартовых деревьев, можете построить эти дикартовые деревья, дикартовые деревьев, вот уже сомнительно.
То есть там, да, поэтому нет. Деревоотреска все-таки оказывается не бесполезным.
А вот нужен ли фенвик? Вот.
Но тут, как бы, да, еще практика летела. Кстати, я вообще, поэтому дикартащик и разбирался.
Потому что так-то, в общем-то, АВЛ-дерево было изобретено еще в далеком 1962 году, а дикартащики, по-моему, вообще и два линии в 90-х.
Вот. Ну, можно там гуглануть. Ну, вот, соответственно.
Да там страны. Там, возможно, то есть есть, вроде, официальная статья под авторством Орагон Зидель.
И вот там, соответственно. Да, Орагон не склоняется. Догадываетесь, почему, да?
Как это, да. Что оригиняет таких авторов алгоритмов Орагон, Штор и Карасик?
Да, это девушки, да. Вот.
Так же, соответственно, да. Ну, это я пересисливал. Ну, потому что, да, у нас есть, я имел в виду, конечно, алгоритм там.
То есть там дерево, там, видимо, Орагон Зиделя, более известное, как дикартащик.
Соответственно, так же мы встретим, в третьем семестре мы встретим алгоритм Штор Вагнера.
Ну, а позже, в том же третьем семестре, алгоритм Аха Карасик.
Да, поэтому, пожалуйста, не говорите, пожалуйста, алгоритм Аха Карасика.
Да, правильно, алгоритм Аха Карасик. Да, Карасик не склоняется. Да, Мар, потому что Маркер.
Вот так. Ну, вот я теперь эмифер, а пока мы перейдем.
Так, следующие идеи. Зачем нам нужны дальнейшие кучи?
Потому что у нас в Ахире такая голубая мечта. А можно ли эти алгоритмы пошлеп-шлепать?
Ну, давайте сразу. Давайте совсем мечта. В идеале, наверное, хочется, чтобы все эти алгоритмы превратились в объединиться.
Почему же эта идея? Да, эта идея вызывает у нас смех, местами даже нервный. Почему?
Потому что если бы у нас нашлась бы куча, которая вот тоже работала бы, по крайней мере, с элементами, как с камешками и весами,
и все дело за от единицы, то у нас бы получилась сортировка за линию.
То есть если у нас это было, типа был бы какой-нибудь, называется там супер хип за от единицы, то у нас был супер хип-сорт за от.
Но такого, как мы уже сказали, не бывает в природе. То есть такое может быть только, ну, оговоримся, что такое может быть только если мы что-то про элементы знаем.
То есть, забегая вперед, мы догадываемся, что мы могли бы реализовать, наверное, кучу, которая, ну, может быть, там с какими-то оговорками, но там каждую операцию мы делали за лог-лог чего-нибудь.
Ну, например, у нас будет дерево Дебоса, скажем, которое будет за, там, будет за, работать за лог-лог-у, где у это максимальное значение вашего этого целочисленного числа.
Вот, но мы сейчас говорим о камешках, поэтому все логарифмы мы не убьем.
Да, но, как уже было сказано, у нас хедлайнером дальнейших идей будет амортизация.
Вот, давайте подумаем, предположим, что мы себе разрешаем амортизацию.
Да, про воскошенность я убираю, потому что мы себе разрешаем пользоваться не двоичными кучами.
Или там какая-нибудь бенмяльная куча нас устраивает, например, или там что-нибудь еще.
А вот теперь возникает вопрос. Хорошо, вот у нас возникает такая мечта.
Давайте, вот, хочется придумать что-нибудь еще, чтобы логарифм тут остался где-нибудь только в каком-нибудь одном месте.
Вот, например, а можем ли вот, вот опять куча, в которой, например, insert делается за логарифом, а все остальное за единицу?
Кажется нет. Амортизировано?
Амортизировано, конечно.
А мы же тогда можем...
Ну где?
Топтировка за n тогда будет, нет?
Не будет, потому что мы в эту кучу этн-элементов должны добавить.
Но там, ладно, отдельная песня, нет, если вы, конечно...
Нет, понятно, это, конечно, то есть, видимо, это просто будет гарантировать, что вы не умеете взять n-элементов и построить из них за o at n кучу.
Да, то есть этим свойством у нас обладала, конечно, наша двоичная куча.
Ну, в общем-то, все остальные кучи тоже этим свойством обладают, но, соответственно...
Так...
Ну...
Так...
Так, давайте так.
Так, вот давайте так, хорошо.
Ну, давайте так.
На самом деле, да, insert логарифом может быть.
Ну, крейт, да, но, действительно, если у нас крейт делается за единицу, то, конечно, у нас все плохо.
Да, ну, хорошо.
Ну, лог от... Вот мы, допустим, да, мы хотим реализовать кучу, что если мы с этими кучами суммарно делаем n-операции,
прям со всей системой, то как бы хотим, чтобы insert там был не более чем...
То можно показать, что там мы выполнили не более чем лог.
Так, ну, допустим, вот чтобы решить проблемы с хип-сортом, да.
Ну, обычно крейт, кстати, даже могут отдельно не впихивать, а на самом деле можно просто сказать, что пусть не там...
Пусть на самом деле мы, как бы, никогда не создаем новую кучу из одного элемента, а мы только делаем insert.
Потому что можно за этим, как бы сказать, создадим пустую кучу и сделаем мыли там.
И потом сделаем... Ну, давайте вот так.
Чего?
Так, какой вопрос?
Ну, create и melt... Ну да, часто insert может быть реализован как create и melt.
Ну, типа того, да. Ну, melt, он как бы и для других целей тоже подходит.
То есть он же... То есть melt еще нужен... Смотрите, мышь экстракта, вот у нас мечта может экстракт мин за единицу делать,
а мы же его тоже часто к melt сводим.
Ну, на этот раз уже без гарантии, но бывает.
Вот, поэтому да, тут вот.
Ну, вот тут мечта такая. Можно ли делать так, чтобы insert и create были логарифмическими, а все остальное единичными?
Чего?
Не реализована единица, но разрешает самортизация.
Конечно, можно.
Так, никто не нот. Да, сейчас уже явно в противоречии этому нет.
Так, спрашивается, как же это сделать?
Как же нам?
Или даже подсказка, как называется куча, которая все это умеет?
Нет, нет, ну просто фибоначивая.
Ну ладно, фибоначивая, конечно, как мы убедимся, тоже это так умеет.
Да, но она круче.
Я утверждаю, что есть более простые кучи, которые это умеют.
Приорити.
Но она у нее с мылдом проблемы.
Чего?
Да, вот у нас были идеи.
Помните, на самом деле, если бы у нас не было мылда, то мы бы сказали, что этим условиям прекрасно удовлетворяет обычная двоичная куча.
Почему? Потому что мы бы сказали, что давайте на каждый элемент мы кладем логарифм монеток.
Ну, ровно за счет этого create из одного элемента становится с логарифм.
То есть не потому, что мы реально делаем один, а потому, что мы тут монетки какие-то кладем.
И тогда, когда нам приходит время выпиливать этот элемент отсюда или отсюда, то мы делаем это реально за логарифм, но оплачиваем этими монетками.
Сливаемое ДО, чего? Что такое сливаемое ДО на камешках?
Так, давайте думать, насколько это проблематично.
Хочется сначала придумать, как делать монет за единицей, а потом все остальное придумать.
Вопрос, в какую сторону придумать.
Ой, как сложно.
Ну, наверное, можно, но...
Нет, хотя они не сядут. Я думаю, там, честно, лог квадрат будет.
Да ладно. То есть мы тут изобретали леватскую какую-то косуру кучу, что-то там доказывали про логарифм, потом выясняется, что можно просто натуркничка придумать не хуже.
Честно, зачем мы же эту косуру вообще обсуждали?
Так, я не слышу ничего.
Так.
Не, простите, если мы те же логарифм упираем, монеток потратим не на удаление, а на мэл, то мы потом на удаление не сможем потратить.
Нет, просто надо утащать, что создаем и какие монетки кладем.
Просто смотрите, наглый чит работает те же. Заметим, что когда вы сливаете две кучи, у вас уменьшается общее число куч.
А когда делаете крейд, количество куч увеличивается.
Так вот, возникает неожиданная идея.
Вот у нас были зеленые монетки, это на удаление.
А теперь мы давайте будем класть крейд еще логарифм синих монет.
Но они будут класться не на сам этот элемент, а на кучу в целом.
То есть идея такая, что на каждой кучу у нас будет висеть логарифм и монеток.
И когда мы будем делать мэл, мы по факту, значит у нас как бы есть тут синие монетки логарифм, тут синих логарифм монеток.
Тогда мы сольем эти кучи, оставим только один из этих логарифм, а вторым оплатим слияние.
То есть поэтому как называется куча, которая все это умеет?
Пеноменальная, левацкая, косая.
То есть любая, которая умеет сливаться, конечно, адекватно.
Кого поменяем?
Кого поменяем?
Чего у нас много не слышал?
Стоп, стоп, стоп.
Но, наверное, не совсем мы так скажем, потому что нет, если у вас будет все-таки insert единица, extract min за единицу, то у вас hip sort все-таки сработает.
Ну, желательно, да.
Нет, ну, может там какой-нибудь у вас будет gitmin, который амортизированно работает за единицу.
Нет, он не удаляет, он уничтожает одну из них.
Ну, как всегда, амортизация убивает персистентность, да, как всегда.
Потому что она сливаться нормально не умеет.
Она должна уменьшиться за размер меньше.
Да, умножить на логарифм.
Вот, но нет, за размер меньше умножить на логарифм, это да.
Остается только ввести какой-то адекватный потенцивал.
То есть, может быть, там можно как-то аккуратно с этой переливайки доказать, что там, на самом деле, учетная стоимость этих мероприятий какая-то неплохая.
Но я боюсь, там хуже лог квадрата у вас там может не получиться.
Ну, просто потому что, как минимум, потому что реально, если вы будете там, то есть у вас там будет n куч по одному элементу, вы их будете там, собственно, сливать, то как бы это будет буквально за лог квадрат работать.
То есть, как бы, поэтому вы, как бы, поэтому вряд ли вы сможете показать, что амортизировано там лучше, потому что, как бы, реальное время работы будет n лог квадрат на n операции.
Так, какой еще вопрос?
А вот при мэлде мы добавили логарифы мэн и монеток дополнительно на всю кучу.
При мэлде у нас потратятся они, правильно?
Нет, при мэлде мы ничего нового не добавляем, мы только тратим.
Потому что жили были две кучи, на каждой из них лежала по синим логарифам монеток.
Но вот, но идея такая, возьмем один из этих логарифов и оплатим им мэлд.
Вот, а на свежеполученную кучу получим второй логариф монеток.
Откуда?
Это те же монетки, которые были раньше.
Да, но их же получается их достаточно, чтобы потом еще...
Да, потому что мы же говорим, мы и говорим, что у нас суммарно в нашей системе за все время с нуля будет добавлено не более, чем n элементов.
Вот так.
Поэтому да, этого в будущем хватит.
Напоминаю, что амортизация это скорее некая абстрактная штука.
Потому что как связана абстракция с реальностью?
Допустим, у вас идея такая.
Допустим, что у вас insert работает за время t1, get-mean за время t2, extract-mean за время t3, meld за время t4, array за время t5, create за время t6.
Здесь реальные времена, а есть учетные.
Как вы теперь выясняете вопрос, что такое по сути учетное время в такой структуре данных?
Учетное время означает следующее.
Вам говорят, что если с нуля, то есть с какого-то определенного нуля, вы там будете делать операции, и у вас будет выполнено k1 этих операций, k2 этих операций и так далее,
то значит вам гарантируется, что каждая операция может делаться как угодно долго.
Но суммарное время работы, то есть t общее, оно не превосходит k1 на t1 учетное, плюс k2 на t2 учетное, плюс k3 на t3 учетное и так далее.
То есть в принципе вот еще один смысл того, что такое вообще учетная стоимость.
То есть помните, это просто способ оценки.
То есть как бы помните, вы нельзя сказать, что вы делаете 1 лог квадрат операции и страдаете, а потом неожиданно вы тут пошаманились потенциалом и доказали, что все там за 1 работает.
То есть помните, только это работает только за счет того, что формально мы умеем доказывать, что это не более чем лог квадрат, мы что-то замечаем что слишком часто работает быстрее лог квадрат, и это может быть способ доказать, что там на самом деле как-то можно посчитать эти операции по-другому.
Но если у вас реальное время работает лог квадрат, то вы там не сможете пошаманить потенциалом и доказать, что там на самом деле единиц.
то есть как бы и то есть ну будет это вот эта классика да я ничего не понимать в строительном
деле конечно да наверное силы кариолиса это важно но почему-то все-таки только у вас
стена под углом 40 градусов наклонена что-то надо будет почитать эту штуку конечно нет просто это
важно культурная вещь или вы уж сами ее почитали так вот такая штука есть и программисты строили
дома ну как кто поднимите руки кто читал такую штуку ну и и над матчет тоже да вот просто
популярная вещь может и куда углануть там шикарно то есть там садут этим с постоянными
референдами вот это вот там типа это там что-нибудь там там условно говоря там праздную день труда
коммунистов у нас там фирме нет праздник никто не портит но вот или там 9 мая там соответственно
то есть 9 мая праздную день победы военных фирме нет поэтому праздник никто не портит там ну и
так далее то есть референд 7 ноября день октябрьской революции до коммунистов нет поэтому да вот
так что соответственно вот такая вот красота у нас вот но это я на всякий случай так что нет
я сейчас собственно это вот к чему я это все то есть это хотелось показать что тут
действительно то есть на самом деле нек Shit так круто картизация на самом деле не такая крутая
потому что мы тут сейчас выяснила что любая куча либоhehe может то есть на самом деле сделать
что из этого это все там то есть типа и Rio of the 있�ан а остальная единица это на самом деле
недостижение то есть изобретать ничего не надо вот но у нас конечно сейчас будет посильнее
у нас сейчас да если бы я на этом закончился это было бы идеально да но мы уже выяснили что нет
поэтому но вот но в куче фибоначи ставка будет в том что у нас мы удалять будем за логарифом
так что вот такая вот у нас такая вот у нас ожидается красота да и это на самом деле круче
ну потому что то есть на самом деле тоже действительно так может быть неплохим достижением
потому что действительно предположим может быть такая структура данных знаете вот задачи
реализуйте структуру данных которые реализуют опера запросы там добавление и удаление но там
добавление поиск минимума допустим и удаление как решать задачу надо изобретать какую-то
структуру данных что-то там писать а потом выясняется так смотрим ограничение так
гарантируется что вставок не более чем миллион а удалений не более чем пять тогда выясняется
что вообще говоря правильным решением было бы как-то сделать просто сделать так что давайте
просто там скажем приставки там pushback в какой-нибудь там список или массив ну там с поддержкой минимума
а удаление но если надо удалять то значит давайте удаляем честно минимум поддерживаем честно там
может даже в тупую даже не поддерживать там 10 минимумов а прям вот в тупую совсем и это может
оказаться круче чем абсолютно любая это ваша куча логично логично да ну вот ну чему это
нас приводят поэтому оказывается что по идее вот такая куча это на самом деле могло быть
круче да чем у нас там всякое бывало так сколько у нас там времени ага нормально у нас времени
вот ну а теперь возникает вопрос как же мы это будем делать вот ну да какие тут идеи возникают
ну в принципе да на самом деле в начале на самом деле ничего сильно отличаться от минимума на
самом деле не будет потому что потому что действительно сейчас мы тут дарят не случайно
начал упоминать списочки сейчас мы на этих списках просто жить начнем да никто не любит
писать двусвязанные списки но как бы идейная они как бы это очень красиво вот да все амортизировано
да по камере пока вот то есть реализация конечно вот значит как же будет то есть
начинается на самом деле кайфежно знаете это прям вот по схеме там просто то есть по по схеме
там всех просто заманивание в секту потому что вы не поймете потому что как будет работать куча
на первых порах она будет работать неожиданно тупым образом значит изначально у вас будет
пустая куча и вы говорите ставь мне пожалуйста пятерку куча говорит и заносит 5 так еще указывает
что минимум здесь да у нас снова будет этот мистический указатель на текущий минимум так
а добавка пожалуйста семерку кучу и добавить семерку списочек а добавь пожалуйста двоечку
говорим мы да ну ладно поддерживаем что-то минимум вот то есть первые пора просто то есть
мы абсолютно сам он просто вообще тупым образом просто в наглую храним все в списке и больше
ничего не делаем прям очень нагло а ну нет пока еще вот так что пока все хорошо обдумать так
слушаем а теперь это а еще нот да в чем такие списки еще и мерзит ли смелдить легко да
просто вот да как говорили в одном колени берем и мы ладим да а теперь так а теперь экстракт мин
один момент и тут начинается самое интересное да вот и сейчас тут начнется действительно
буквально мясо потому что тут у нас куча значит понимает что как бы у нее тут это да через час
дедлайна надо послушать там 12 лекций да типичная такая ситуация но значит как как она будет но
какой-то амортизацию она себе выжрала вроде да какой-то логарифм времени дают ну и там
какой-то видимо более там вот что она в это время будет делать но тут она так она когда-то учила
так какие на сливаемой куче сливаемой куче как они там это ой так сейчас как-то это вот
сливаемая вот это как-то на б как-то дред какой-то там база вот это базука там бита а бенемиальная
во во бенемиальная слушайте так давайте может как-нибудь быстренько из этого бенемиальная сделаем
так так давайте как мы это будем делать так но ладно у нас это все пока как бы типуリ ангел
оль да так хорошо так хорошо так давайте вот так значит это 5 это у нас значит есть так значит у
нас такой есть так это будет типо куча ранга нуля а так так так отлично так 7-7 так тоже куча ранга
ноaly у нас же две кучи бы не могут быть чуть здесь а ну ладно так давайте 5 меньше семи давайте
подвесим так давайте вот так вот подвесим все так и теперь пишем что это ранга ноль до то есть
это теперь рад botheredина это вот police usta так вот так вот так вот вот так что у
нас дальше так 4 так еще четверочка есть как так 4 4 4 так
в рамках 1 так так 4 пока рак 0 так все в порядке еще неoug unmute
опу господи так опять carga 4 8 а так давайте снимаем снимаем снимаем
снимаем снимаем быстрее быстрее быстрее быстрей быстрее быстрее да вот так вот
Вот, значит, восьмерка, восьмерка, так, ой, господи, кто эти маркеры придумал? Я, я, так, все, о боже, так, 0, 1, я все перепутал, да, 1, 0, так, отлично, так, отлично, теперь у нас, ой, так, две кучи рангоди, а рангоди один, что такое? Ну, ладно, давайте сольем быстренько там, это все равно завод единицы делается, вот, так, значит, у нас, так, хорошо, тогда у нас тут получается два, тут получается, ну, ладно, тут вот, 1, 0, допустим,
вот, господи, слава богу, да, потому что мы, да, потому что мы ее удалили только что, слава богу, нет, я не про это, не, спасибо огромное, что ты мне приснился и задал вопрос, да, ну, вот, да,
так, давайте это еще семерки надо красиво нарисовать чтоб как бы мы делали вид, что это бенcer
вот, так, segment coincidence вот, зем tenho так, что у нас там еще так троечка так вроде пока ничего не надо
делать так так так хорошо так ой ну это теперь не одна куча так ну теперь мы соответственно до
все это делаем единый список и ну вроде выкручились ну конкретно этот это конкретно это
позолению сработал но теперь давайте разбираться значит теперь если действительно отложить юмор хотя
куча куча будет буквально делать вот это нет ладно лишних причитания она делать не будет
естественно но разве что в каком-нибудь дебак выводе разве что-то там да да и да ну это да это
да знаете там функция пишут и там то есть обычно там во многие функции передают там еще такой
були флаг вербус это типа знаете то есть кэпе е все он труту там дебак вывод что-то пишет если
нет но нет и тогда тут уже можно ним передавать а можно еще это если она истеричная если она
там веселая там если она там еще но нет но так не делают естественно для работы но развлечься
можно вот так вот но вообще реально она фигурначную кучу будет буквально делать вот это то есть как бы
смотрите то есть она как бы то есть она как бы не особо заморачивается то есть то есть она
такая вышедательная куча то есть пока вам нужно делать просто вставки но давайте предположим что
мы делаем пока просто вставки да то есть допустим и делается хотим реализовать вставки экстракт
мины и там допустим meld и да пока вот тогда идея будет очень простая то есть понятно вставку
она будет делать тупо впихивая в лист вершину если вы хотите сделать meld то она просто будет
взять просто два списка и тупо их сольет то есть только за единицу что буквально это будет
происходить вот но вот но экстракт мин но здесь конечно возникнет проблем придется минимум
пересчитывать но на самом деле да то есть более то есть менее стеричная версия куча скажет так
ладно мне по любому надо как бы за линию тут пробежаться что-то сделать а давайте-ка я еще и
называется составлю из них какие-нибудь красивые деревья например бенемиальные то есть в принципе
пока мы вот я временно вот вычеркиваю этот рейс нам придется конечно с ним отдельно по мучиться вот
вот то происходить соответственно здесь будет следующее смотрите но то мы соответственно будем
здесь идти идти идти слева направо но то есть происходить будет следующее мы будем в каждый
момент времени считать то есть более продвинутый вариант что у нас куча состоит из связанного
списка корректных бенемиальных деревьев ну кстати на самом деле может даже там зайти
иногда настолько корректных что на самом деле даже реальные списки тут скорее вот так будут
работать вот ну ладно не так скорее вот так конечно там обычно на большего ребенка ссылается
вот давайте для удобства я буду все-таки рисовать эти бенемиальные деревья как они по классике то
есть идея такая то есть мы храним корректные абсолютно бенемиальные деревья вот и перее значит
пока у нас есть инсорт мы не заморачиваемся просто поддерживаем минимум а как только достается
экстракт мин то есть экстракт мин соответственно у нас вызывает мистическую функцию консоли дейт
но в общем случае одинаковые могут быть вот как здесь это вот как бы бенемиальные деревья
в принципе могут быть одинаковые но консоли дейт будет добиваться того чтобы этого не было
вот понятно да вот то есть консоли дейт то есть прям официально он будет делать
то есть в каждой вершине будет храниться ее какой-то ранг примите да но мы помним
в бенемиальном тире обычно в каждой вершине можно хранить прям ее ранг тогда как это работает
тогда это работает так то есть мы просто заводим ну мы знаем что ранги у нас не
бывают больше чем логарифм правильно поэтому идея можно сделать так но раз мы тут все равно
тратим логарифм времени давайте там заведем массив на логарифм или там если хотите вектор
и будем в каждой клетке от нуля до логарифма хранить ссылку на дерево соответствующего ранга
то есть прям вот то есть у меня тут 0 1 2 3 там и так далее там логарифм то есть где-то пока
пусто где-то уже висят деревья вот давайте тут висит деревья нет погодите ну в процессе изначально
пусто везде но фишка такая будет что мы теперь перебираем все деревья и
пытаемся и сюда занисти допустим мы видим дерево ранга 2 ой
заносим мы видим дерево ранга ноль заносим мы видим дерево ранга там
логарифом заносим мы видим дерево ранга 0 за ой а у нас уже есть что делать
ну что страшно давайте их их померчим и тогда тут нуля нет а зато здесь единичка
красивая так а еще нас появилось дерево ранга 3 а теперь у нас появилось дерево
ранга 1 и тут вообще весело потому что мы тут объединяем получаем дерево ранга 2
ой а у нас еще одно есть значит тут тоже объединяем получаем дерево ранга 3
объединяем получаем дерево ранга 4 фух ну наконец-то можно позаписывать
то есть вот такая приятная вещь понимаете да то есть есть можно завести прям в явном
виде массив на логарифом но можно сделать и какой-нибудь вектор это будет даже оптимальнее
вот и в принципе вот это у нас вот вызывается периодически консолидейт на самом деле да
можно заметить что в принципе сам по себе такой консолидейт в общем-то может работать
за сколько ну при тебе да вам придется конечно работать за логарифом потому что вам в конце
придется пробежаться по этому массиву и выписать и создать из этих деревьев корректный список
ну получается да но правда тут возникает вопрос а какой потенциал возьмем или как мы себе это
будем мыслить но удобнее здесь мыслить в терминов но то есть действительно удобно мыслить что просто
все эти операции получается у нас как бы то есть получается так что у нас было что-то типа n
деревьев а стало ну логарифа да то есть хочется сказать что относить до какого-то потенциала это
делается за логариф но что это за потенциал тогда какие монетки но идея проста давайте
такая первая версия нашего потенциала будет такая просто потенциал это просто тупо количество
деревьев в головном списке чем вот меня интересует вот таки мы это будем доставать я сказал
от аж где аж это хип но это я буду пользоваться обозначения которые в корме не появлялись
вот давайте скажем что пока у нас вот сейчас потенциал это будет тупо т от аж просто сколько
деревьев куч тогда заметим что учетная стоимость ну то есть давайте подумаем тогда как у нас
консолидейт консолидейт проходит по списку да но заметь она вот значит что он делает он
проходит там проходит по списку ну дело это за от сколько там деревьев было да то есть там
реальное время работы вот количество деревьев вот это т вот но теперь получается потенциал до был
т а стал не более чем но стал логариф получается учетная стоимость логариф
но в первую очередь потому что у нас осталось логарифом деревьев понимаете да если у нас
толст меньше деревья вообще был бы кайф но вы логарифом деревьев остаться могло но и конечно
что еще поэтому принципе мы можем себе позволить на самом деле как бы потрогать пробежаться не
только пробежаться за т но еще и здесь за логарифом пробежаться и насти все деревья
так но приедет до эсско консолидейт да но давайте сейчас проговорим до правильный
вопрос на самом деле да что еще есть экстракт мия но что в экстракт мини мы делаем консолидейт
не сразу вообще как теперь давайте думать как мы вообще делаем консолидейт то есть это экстракт
мин в общем случае ведь в общем случае-то вполне вероятно что у нас тут весят какие-то деревья
и когда вы решили что-то удалять когда вы решили что-то удалять то наверное есть ну есть такое
подозрение да да ну и да да но идея очень простая да просто у этой вершины мы знаем что у нее
там не более чем логарифом детей мы все там в чем дети это корректные вполне себе минимальные
деревья поэтому мы эти деревья просто перетаскиваем в головной список и делаем буквально то же
самое то есть разница только в том что вот это t увеличится на логарифа но это нам асимптотики
естественно не попортит то есть само по себе это действие увеличит потенциал на логариф даже
если вы сделаете там каким-то мистическим образом завод единиц вот нет просто это как бы реальное
время работы это потенциал в конце это потенциал в начале да но например потому что мы в конце
должны потратить время чтобы найти все деревья которые выжили и составить из них список их
может быть до логарифа вот этом да мы считаем учетное время экстракта но правда можем еще
заметить посчитать учетное время инсерта заметить что как бы добавление вершины список на самом
деле потенциал увеличивает на 1 получается 1 плюс 1 от единицы
скорее всего да чего вот это экстракт экстракт мин делает старт мы знаем где находится минимум
вот значит мы говорим так мы эту вершину удаляем от нее остались дети детей мы просто вешаем
головной список это потенциал нам само по себе увеличивает логарифом после этого мы делаем
за учетную стоимость логарифом консолидейт чего нет он работая нет смысле учетное время
логариф учета стоимость работы логарифа то есть он консолидейт логарифом утверждаю я да нет
просто логарифом всех вершин а вот почему потому что у нас есть потенциал количество деревьев
за 3 вот у нас пусть у нас было 3 деревья да тогда консолидейт работает за реальное время т
плюс логарифом но вам уже логарифом что во первых там может быть создать этот массив да
да интересно да действительно заметим что каждое дерево матра обрабатываем я обязательно за
чистую единицу потому что молдов может быть много да но я бы сказал так на самом деле каждое
дерево мы обладают но тут идея такая дает очень важно давайте ее подчеркнем дело в том что каждое
дерево мы обрабатываем за единицу плюс количество мержей которые мы в этом месте
проскочим да но каждая колея но каждое слияние уменьшает количество деревьев на одно это важно
но вот и такие слияния будет не более чем там соответственно поэтому поэтому получается
нет можно сказать что учетная что на самом деле учетная стоимость конкретного слия там слияние
двух деревьев 0 то есть да поэтому буквально мы говорим что мы эти слияния не учитываем потому
что то есть мы учитываем когда мы их копируем мы учитываем когда мы их куда-то смотрим там пытая
кладем первый расписок но слияние дальнейшем уже не учитываем да такой вот парадокс слияние
весит 0 за это просмотр там а просто посмотрю это единица то есть посмотреть сколько-то стоит
слить нисколько не стоит да ну как это амортизация это нормально вот да как это
покататься на машине стоит 0 а посмотреть на нее а ну знаете нет а теперь классическая амортизация
в этом плане была приведена в 3 серии мультиков про богатырей да именно да что видели нет там
ситуация там то это считается там там как там князь захотел там князю предложили покататься
на слоне ой да я знаю там деньги стерешь там это не нет за прогулку за прогулку деньги нет
то точно он нам и клянусь ну типичный греческий такой мамой клянусь да вот ну вот ну собственно
там дает лестницу значит он залезает на этом едут красиво все он ладно все приехали давай давай
лестницу давай дай мне он погрешу слышали ты сказал прогулку что я беру деньги не за прогулка а
за то чтобы слезть слона вот это называется амортизация да да как это князь явно не был
знаком с амортизационным анализом поэтому да вот кто минимум
а у нас каждым время есть указатель где тысячи цеменевым да разумеется когда мы
составляем новую кучу кстати мы минимум еще и попутно насчитываем но это нам как бы
бесплатно будет шерстер все равно пробегает по деревьям этим так почему бы там минимум еще
не насчитать нет дети детей мы добавляем список просто тупо добавляем список и
делаем консолидейт ну вот ну и в конце консолидейта еще и минимум насчитываем заодно
конечно но если вы только что минимум удалили значит придется новый минимум найти так или
иначе да да но вы взяли все залогари что тяпка у вас в конце будет мало деревьев так что вот такая
красота да это бы прислияние кстати тоже придется учитывать что у вас там минимум был там был там и
надо из них выбрать лучший минимум ну то есть это из цикла да понятно это легко делается но
это надо сделать вот до чем-то как это не парадоксально но чем-то если бы не было операции
рейс и каких-то еще на самом деле мы в общем-то кучу фибонаки уже изучили да кто-то возможно
очень сложная структура данных вот ну не совсем ну до сан-дель я б сказал так что нет
у экстракта почти такой же но что-то экстракт называет консолидейт который работает за
помимо этого сам экстракт минчо делает помимо этого экстракт мин делает значит вот само удаление
вершины и вставку вот этих элементов список это делается за логарифом как честного времени так
и учетного я сказал даже честное время логарифом учетное время два логарифа потому что вы еще и
потенциал логарифом увеличиваете в этом месте вот после а после этого и за логарифом времени
учетного делаете консолидейт так но вообще да
когда вы добавляете когда вы добавляете одну вершину вы добавляете дерево нулевого ранга
да ну тогда нет ну тогда у тебя в результате трех мержей исчезли три
дерева появилась и дерево ранга 3 ну как-то и мы как но вот да мы это сделали за от единицы
плюс три мержа а теперь фишка с помощью поэтому потенциал у учетное время мержа 0 ну да ну в
нашем случае просто количество деревьев которые у нас имеют место быть потому что каждый мерш
уменьшает на 1 все поэтому как бы это единица как бы убилось так что такая радость два
бенемиальных дерева мы объединяем можем но как можно да но нет то есть ну не совсем
мэлдов то может быть и больше потому что деревья франга один мысли во объединять будем сильно
больше у нас тут их много может быть да но вот но как но вот но учетная стоимость равно длина
но основная идея такая суммарное число мэлдов у нас по-любому не более чем т-1 но если было
т деревьев да и каждый мэлд каждый слияние двух одинаковых деревьев уменьшает количество этих
дерев на 1 может нет объединение чего так тут надо не путать объединение глобально куча это
одно дело в нашем случае диреки идет об объединении как превращение 2 бенемиальных деревьев одинакового
ранга там 5 в одно дерево ранга 6 это делается за 1 где зачем какое свойство нет зачем оно нам
нужно нет деревья просто абсолютно корректная зачем нет мы же так мы так напомним как мы
объединяем бенемиальные деревья нет давайте так что такое бенемиальное дерево вообще ладно давайте
напомним раз об этом речь пошла то есть бенемиальное дерево ранга 0 напоминаю это у нас один вершина
бенемиальное дерево ранга 1 это один вершина которому подвесили один вершина бенемиальное
дерево ранга 2 это дерево ранга 1 к которому корню которого подвесили еще одно дерево ранга 1
чего а что такое размер камешка но да соблюдается вариант кучи естественно до
каждого элемента меньше своих детей да и что ну когда вас теперь садри да но тебе даны два
вот таких дерева ты хочешь создать из них одно вот такое как это сделать надо просто корню одного
из них подвесить другое какого-то какого кому надо просто понятно выбираем просто кто меньше
вот так и прям даже но вот а теперь это хорошо а если мы все-таки хотим сделать вот этот вот
рейс а теперь вот загадка как в этой ситуации делать рейс из произвольного места
но как тут сначала как а вкусно или не вкусно это как бы уже
так за линию не а за логарифом то удалить можно
то тогда подлянка садри если мы просто выпили там условно выпилим эту вершину вместе с под деревом
да то у нас тогда вот это глобально и теперь перестанет быть перестанет быть корректным
бенемиальным а мы этим жестко жестко пользуемся да вот есть такая подлянка очень жестко пользуюсь
все что у нас висят только корректно бенемиальные деревья да да
так значит стандарт но да нам предлагают стандартную техно
сейчас нет ну вообще нет стандартная технология так как это как удалили не
но это есть стандартная технология обычно что делать если вы хотите удалять элементы
из приоритеке вот балдка значил вот так говорят почему плохо приоритеке у потому что она
например говорят паскалисты да потому что вы не можете с приоритеке удалить элементы
произвольного места а мы на паскали можем вот вот нет ну паскаль в этом смысле лучше тем
что там нет приоритеке и вам придется писать самостоятельно то есть да минус придется
писать самостоятельно плюс как бы вы можете делать что вы хотите вот вот но под от да но
оказывается если вам приходит просто возьми элементы удали его то есть стандартная технология
удаления с приоритеке у которых вы так заведем рядом второй приоритеке у которой будем кидать
все что мы хотим удалить а когда мы будем искать экстракт мим то есть мы себе сделаем небольшую
амортизацию она будет так я достал минимум он равен 5 так а полезукая в удаленные элементы так
чему меня так чему мне равен минимум среди всех удаленных элементов так тоже 5 а так наверное это
был удаленный значит давайте отсюда удаляем и оттуда удаляем так теперь следующий минимум 7 так
кто мне минимум из выжить из это не до удаленных элементов так сказать то есть эти вторая куча
такая формаль элементы которые надо удалить но я еще пока поленился вот вот ну это зависит от
того верно лишь что приоритеке и по константе работает быстрее с этого хотя бы в два раза
если это так то то в принципе да должно работать вот правда опять же да да
но да да нет то есть вам нужно просто имена да но да то есть принципе да вот если использовать
такую технологию то в принципе да получится амортизировано адекватно да то есть как бы да
можно даже вторую кучу по моему сделать даже не фибоначивая даже обычной потому что равно
логарифм вот хотя но на самом деле отметим что конкретно в этой куче на самом деле можно было
сделать гораздо проще потому что глубина дерева каждого не происходит логарифм
ну понятно да класс-то да то есть все усложняется называется бабка за деть короче гораздо
проще было сделать сифтап заметил что нам фантастически повезло глубина каждого
дерева логарифм поэтому делаем сифтап и радуемся то есть делаем сифтап на плюс
бис на минус бесконечность то есть выводим минус бесконечность корень и корень торжественно
убираем чего то есть на самом деле да все было гораздо про да лакчик открывался сильно проще
вот казалось бы все кайф на этом можно остановиться но основная сила кучи фибоначи в том что есть
еще одна магическая и не просто критическая важная в науке вещь она называется дикрийский
вот пока вот потому что дело в том что я вам не все рассказал потому что дело в том что есть
еще вот операция дикрийский то есть она говорит так возьми вот этот элемент по итератору и
уменьши его не удали а уменьши вот так вот по идее да по дефолту как бы тоже логарифм но так
вот то есть да ну практически во всех вот этих вот кучах конечно же мы знаем что там мы это все
умеем прекрасно делать за логарифм потому что мы могли бы там удалить этот элемент скажем
а потом вставить в адекватном виде да но куча фибоначи это про возможно и едва ли не самое
главное ее магия она умеет это делать за единицу вот это просто едва ли не главное ее магия
мэлт нет слияние конкретных деревьев бесплатное они мэлт целом хотя но нет у
мэлт не бесплатно но мэлт на самом деле мэлт в том виде он не меняет потенциал вообще
а это неважно ну мы же у нас по умолчанию нет варианта о том что кусочек должен быть
консолидированный за три то есть зачем мы делаем вообще консолидацию консолидацию мы то есть
консолидация это такой способ на самом деле сделать т плюс логан операции так чтобы они были
оплачены зачем мы это делаем делаем это потому что когда мы удалили минимум нам хошь не хошь
придется минимум пересчитать да за отт ну тогда мы просто врубаем консолидацию которая тоже
работает за отт ну там за т плюс логарифом и но вот но потенциал она уменьшает вот в этом плане
обно тп нет я просто к чему консолидации мы вызываем для того чтобы там условно чтобы
полукоррупционным образом просто оплатить себе лишние операции в мэлте такой необходимости нет
потому что у нас нет инварианта о том что все деревья должны быть обязательно разных рангов
ну в общем случае нет пусть консоли дэйта да а так нет ну так и есть потому что два
ну связанных списка можно слить за о от единицы ну вот эти элементы да конечно да да и минимум еще
насчитываем сверху да типа ради чего бы все это вообще делали вот да вот но фишка конечно сейчас
будет декрески хочется делать за от единиц но это нам побеждает некое например вот возможно
вы сталкиваетесь с алгоритмом дейкстра если нот и как вы знаете в алифе там обычно в спортивном
программировании обычно в алгоритме дэкстра есть дуаль потому что дейкстра можно писать без кучи и
дейкстра можно писать с кучей ну или там сетом да да мало кто знает то дейкстр иногда без кучи
пишется да вот это мы с вами обсуждали уже когда-то вот но и возникает проблема потому что
ну за сколько она работает ну формально говоря дейкстра у нас работает за какое время в инсертов
е декрест киев и что там еще и в экстракт мином да то есть и теперь называется дейкстра обычный
там обычный до дейкстра это он если что да был такой ученый эцгервейный дейкстра
голландский ученый такой да к сожалению он уже умер и вот да редкий случай но вот да но к
сожалению ученые-изобретатели алгоритмов тоже иногда умирают вот и так значит инсертов
инсерты мы делаем в но инсерты мы делаем за единицу потому что у нас массив уменьшение тоже так как
это массив за единицу но зато экстракт мин делается завэ и того в квадрат если мы делаем дейкстра
с каким-то сетом или там двоичной кучей тогда инсерти делается за ну давайте так сет какой-нибудь
он делается за благо рифм дик листки тоже делается за благо рифм потому что мы как бы
удаляем и и рейс экстракт минут делаться благо рифм это вот получается и лог в что больше
в квадраты или лог в да как повезет если я в квадрат а там в квадрата лук Shakespeare
квадрат, если е там какой-нибудь в или в лог в, то лучше конечно нет. Да, вот, то есть и приходится
там эффект писать, но на самом деле, если у вас есть куча фибоначчи, если у вас есть куча фибоначчи,
по крайней мере, как она себя заявляет, то мы неожиданно, то тогда вставка за единицу,
декрестки за единицу, удаление за логарифом. Получается что? Правильно. Получается е плюс
в лог в. Ну а если учесть, что тут на самом деле формально в квадрат плюс е, то получается,
что это бьет и это и это. Ну ладно, тут вот так еще надо. В плюс е на лог в, формально, да. Вот.
Правда, да. То есть минус, конечно, заключается в том, что обычно у кучи фибоначчи такая большая
константа. Поэтому я там долгое время, я всегда там сейчас не удалось начать, но обычно занятия
по куче там должно начинаться по принципу. Здравствуйте, друзья. Сегодня будем изучать
кучу фибоначчи. Вот такая важная структура данных. Куча фибоначчи никогда не используется на
практике. Сегодня вы узнаете почему. Ну если быть конкретно, сборная Мурманска. Так что гляньте
там первое выступление 14-го года, не пожалеете. Вот. Так что, соответственно, вот. Но действительно,
то есть поэтому на практике конека, хотя, как и странно, кто-то мне писал, что в одной из версий
гнушного компилятора, где-то там в поставленной компиляторе библиотеке куча фибоначчи внезапно
нашлась. Нет, ну не вместо, конечно, позже упаси, но просто там, но просто где-то там, где-то там,
где-то там она нашлась. То есть понятно, это, конечно, естественно, в стандарте ее нет,
ну вот, естественно, но где-то она таки есть. То есть вот такая вот, такая вот развлекалочка.
Да. Вот. Ну вот, ну теперь у нас какая-то вопрос. Как же делать дикриски прям за вот единицу?
Так. Сколько у нас времени-то? Ой, ну да, времени у нас столько, что кажется, да,
но так же предупреждаю сразу. К сожалению, да, ради этого дикриски нам придется эту кучу покорежить,
и еще там пострадать подоказывать. Вот, то есть общая суть, то есть мы попытаемся суть не сильно
менять, но вот, но будет немножко больно. Но это боль мы себе сделаем, естественно, после перерыва.
Так, итак, но давайте думать, как же нам сделать дикриски? В принципе, кто-то уже
начинал думать в этом направлении типа, а что будет, если мы возьмем и возьмем или там какой-нибудь
элемент, да? Как сделать у него дикриски? Ну, заметим, что если мы сделаем дикриски у элемента,
который случайно оказался корнем своего дерева, то никаких проблем нет, просто уменьшили и все,
правда? Проблема только если он оказался где-нибудь глубоко в дереве. Но тогда,
что, давайте тогда все его под дерево отпилим и вынесем в корень. Казалось бы, потенциал от этого
поменяется на один неглобально, правда? Но выскакивает маленькая проблема, тогда дерево перестанет быть
бенемиальным. А у нас пока, в чем проблема? У нас пока анализ базировался на том, что у нас деревья
бенемиальные, да? Как жестко базировался, прям сильно. А насколько для нас это проблема, думаем мы?
И тут, значит, неожиданно приходит в голову такая идея. Слушайте, а может нас устроить,
если деревья будут почти бенемиальными? Ну, то есть, будем говорить так. Смотрите, что нам нужно?
Мы, конечно, давайте подумаем, мы могли бы теоретически просто забить на все, да? То есть,
просто вырезали и вырезали, будет такое бенемиальное дерево без одного под дерево. Но проблема в том,
что дикриски могут повторяться, и тогда дерево будет совсем какое-то испорчено, и вообще тогда
непонятно, за счет чего все хоть как-то работает, правда? Понимаете, да? Поэтому, значит, тут разумным
балансом оказалось следующее. А давайте делать вот как. Мы будем хорить бенемиальные деревья. Но
если вы... Ну вот, какие тут варианты были? Как можно сделать бенемиальные деревья? В принципе,
есть другой подход. Давайте будем гарантировать, что все деревья бенемиальные. Как мы это будем
гарантировать? А вот как. Значит, будем говорить так. Так, вот это дерево выпиливаем. Так, вот у этой
вершины, эта вершина теперь как бы некорректная, да? Ну, можно быть так. Давайте ее тоже выпилим,
и там, возможно, всех детей выпилим, и так далее, прям до корня. Все равно там что-то логарифом. Но,
по-моему, мы тут, по-моему, в итоге каким-то лог квадратом уже рискуем, да? Легче было уже сифта
сделать. А мы мечтаем о единицах. Значит, щит оказывается такой, смотрите. Значит, мы говорим так.
Вот мы тебя выпиливаем. Так, дорогая родитель, мы сообщаем тебе при неприятной вещи. Мы отпиливаем
тебе ребенка. Нет, не убиваем, а отпиливаем. Потому что ему выпала высокая честь войти в список
великих корней. Вот. Ну вот. Так, соответственно, да. И кто-то говорит, ну вот, да, а слушайте, клад,
мой ребенок, мне бы стать когда-нибудь корнем. Не, ну, у тебя есть дети, мы не можем тебя отпустить.
Но мы тебе дадим особую милость. Мы тебя пометим. Вот. То есть это мы тебе дадим орден. Мы тебе
дадим орден, что у тебя ребенок стал великим. Вот. Значит, проходит время. Ну ладно, хорошо живем.
Значит, появляются такие вот орденоносцы. Значит, кого-то выносят. И наконец приходит,
слушай, пришло время отпилить от тебя еще одного ребенка. О, вы мне дадите еще один орден?
Нет. Более того, мы тебе даже этот отбегаем. Ну и зачем мне это? А все просто. Понимаешь,
я думаю, детей у тебя осталось слишком мало. Там х-2. Поэтому мы тебя тоже сделаем корнем. Но у
меня же тоже есть родитель. Вот ему орден и отдадим. Но у него тоже орден есть? Да. Ну,
давайте, ладно, тогда его тоже в корень. И так далее до тех пор, пока не... Ладно,
мы тебе дадим орден. Так, стоп, ты уже и так корень. Ладно, поживешь без ордена. Так что это
операция, вырезание просто целой родовой линии орденоносцы. Ну как вырезание? Поднятие,
вознесение в ранг святых корней. Называется каскадинг-кат. К сожалению, автор структуры
мыслил непозитивно, поэтому тут есть вырезание. Но, впрочем, как видите, никто никого не убил.
Как бы классно, если бы в какой-нибудь там этой игре в кальварах. Тут погибло столько людей,
а потом все возвращались. Да никто не погиб, господи. Это был каскадинг-кат, на самом деле. То есть на
самом деле, да. То есть на самом деле мы все встали, пошли в студию и смотрели на вас по камерам.
Слушайте, такой шоу было. Да, то есть смотрите, вот действительно фишка такая. То есть еще раз,
да, то есть более формально. То есть мы говорим, что мы разрешаем у каждой вершины внутри дерева.
Ну то есть у корня может быть отпилино сколько угодно, в приводе говоря. Вот, наплевать. Но
у ребеночка, но если он не корень, то как бы вершина изначально была какая-то степень,
когда он стал не корнем. Ну когда, кстати, вершина становится не корнем. Ну внутри консолидейта,
когда мы тут решили какие-то два дерева объединить. Вот, и тогда у него в это время было х корней,
так вот. То есть х детей. Тогда, значит, мы можем у нее отпиливать детей, но не более одного. То есть
мы за этим следим так. То есть когда отпилен первый ребенок, мы помечаем вершину. Вот. Ну как говорится,
мы называем орден, но как бы в оригинале это называется марк, просто пометка. Но если мы решили
у него отпилить у помеченной вершины второго ребенка, то мы эту пометку снимаем, а вершину
отправляем в корень. И при этом, конечно, помечаем, значит, соответственно, ее родителя. Но если она
помещена, то ее вырезаем. Поэтому это называется каскадинг-кат. Понимаете, да? Вот. То есть это,
ну вот поэтому это называется каскадинг-кат. За какое время это работает? Вот. Ну, при таком
потенциале, в общем-то, к сожалению, пока это все не оплачивается ничем, правда? Но с другой стороны,
наверное, есть подозрение, что как бы каждая помета, что по идее, так как вручение, то есть если вы
просто удалили и дали орден, то, наверное, вручение каждого, то есть, наверное, вручение каждого ордена,
на самом деле, это потенциально, это закладка еще пары монеток на то, что вы потом еще удалите
ребенка и перетащите в корень, правда? Вот. Поэтому, да, тут логично, поэтому тут, значит,
потенциал модифицируется. Был т. а. и теперь у нас будет м. а. Это количество орденов, пометок.
Я вот так и напишу. Вот. И потенциал мы объявим, что он т. а. плюс сейчас будет внезапно 2 м. а. даже
для удобства. Ну, понятно, что по барабану на самом деле, да, то есть мы можем как бы и здесь будет,
то есть как бы и тут более жирные монетки класть, да, условно. Вот. Ну, типа там. Ну, типа там,
я не знаю, тут, ну как бы и типа тут иены, а тут чуть более жирные. Ну, там рубли, например. Вот.
Соответственно. Вот. Ну вот. Ну или там, я не знаю. Вот. Но не важно. Но оказывается, вот,
удобным тут двоечку класть. Сейчас мы увидим нот. Ну, давайте подумаем, почему. Вот. Ну,
на каждый орден. Ну, действительно, заметьте нот. Я утверждаю, что учетная стоимость такого
каскадинка, ну, максимум единица. Ну, потому что, смотрите, потому что, допустим, у нас
пришла команда выпилить меня. Тогда у нас, тогда у нас, значит, происходит что? Нот. Тогда у нас,
мы обращаем нот. Ну, если нам надо выпилить меня, а тут ордена нету, то мы как бы делаем все,
увеличиваем потенциал на три, правда? Потому что мы выпиливаем, значит, отправляемся в коре,
это плюс один к потенциалу и выдаем орден. Это плюс два, да, то есть вот единиц. А предположим,
что мы теперь пришла команда отпилиться от вершины с орденом. Что тогда будет? Ну, тогда,
смотрите, да, у нас единица реального действия сам отпил, да, значит, и единица увеличения
потенциала. Но зато мы орден в этот раз отбираем. Получается минус два. И тогда получается,
что учетная стоимость получения, то есть сама по себе стоимость отпила второго ребенка и
ликвидации ордена она ноль. Правда, осталось еще то, что теперь надо эту вершину тоже отпилить. Но
тогда, если у нее тоже орден, то отпил сам по себе ее тоже будет ноль. То есть получается,
в реальности мы как бы оплатим только вот самый последний отпил и выдачу орден. То есть получается,
что каскадинка работает за единиц. Нет, мы отпиливаем ее ребенка. Ну, то есть значит,
эта вершина перестает быть ребенком этой вершины. Мы ее отправляем в корневой список. Да,
мы потеряли вариант о том, что все деревья у нас это честное биномиальное. Ну вот, то есть пока
когда какое-то дерево, про которое нам еще придется что-то доказывать, это будет самая сложная часть,
кстати, этой структуры данных. То есть до этого момента, как видите, в общем-то убоя не было.
Нет, мы этот корень не удалили. У нас задача декрестки. Мы переносим эту вершину в корень,
чтобы уменьшать ее значение как угодно. Ведь если нам пришла задача уменьшить элемент,
а он в корневом списке, то мы его можем уменьшить и вообще ничего не делать. Ну,
только минимум разве что пересчитать. Поэтому с этой целью у нас команда эту вершину переносить
в корень. Вот, собственно, это мы и делаем. Ну, конкретика звучит так. То есть ровно поэтому я тут
рисовал, что детей желательно хранить на самом деле вот в таком вот двусвязанном списке на самом
деле. Вот, ну желательно, чтобы, конечно, из всех их ссылки на корень были, но вот, а из этого такой,
то есть тогда из двусвязанного списка можно за вот единицы удалить. Когда вершина перестала быть помешной,
когда нет, наоборот, что значит перестала, наоборот, как бы если у него родитель не был помечен,
мы просто пометим его и остановимся на это. Но если мы отпилили, а он был уже помечен,
то мы пометку снимаем, но эту вершину тоже вот рекурсивно просто тоже отпиливаем. Прямо
Нет, нет, мы отпиливаем рекурсивно эту вершину в том плане, что вот это вот все под дерево тоже
отправляется в корень, но уже с отпиленным вот этим деревом. Да, то есть оно уже ушло,
но как бы тогда потом вот это тогда тоже берем, потом вот это берем и так далее,
до тех пор, пока мы либо не дойдем до корня, либо найдем вершину не помеченную.
Да, но при этом и потенциал серьезно уменьшается. Вот я уже объяснил,
сейчас объясню по-другому тогда. Предположим, что мы тут прогулялись, но тогда что у нас
происходило? Мы решили выпилить вершину, и вот допустим, что у нас тут на ней висела цепочка
из К орденоносных вершин, и тут была еще одна не особо орденоносная. Тогда мы эти операции
тогда суммарно выполним за реальное количество действий К плюс один, правда? Вот, но только
значит потенциал в начале был какой-то Фи, а потенциал в конце был Фи, но заметьте вслед,
то есть Фи, сколько мы деревьев тогда новых сделали, К плюс одно новое дерево сделали,
но при этом пометок мы сняли К, поэтому получается 2К. То есть здесь получается шлеп,
да, это К плюс один, поэтому получается шлеп-шлеп-шлеп, ну Фи, конечно, тоже шлеп,
и того получается от единиц. То есть получается каскадин-кат сам по себе ничего не сделает. То
есть каскадин-кат такой работает за от единицы, что удобно. То есть относительно такого потенциала
и дикарески работает за единицу. То есть давайте сейчас, а давайте внимательно посмотрим, какие
проблемы это вызвало. Да, то есть идея нам сказали, что где-то мы пользовались, что у нас деревья
жутко биномиальные. Так, консолидейте, а как, ну вот, ну давайте думать, а как конкретно мы этим
пользовались? Ну казалось бы, а у меня теперь тупая идея, а как вы выясняли,
какой ранг у вершины? Ну не знаю, скорее всего, я даже больше скажу. Скорее всего мы это выясняли
очень просто. Мы шли в вершину и смотрели у нее значение переменной соответствующей. Вот,
тогда нет, потому что у меня просто такая идея. А давайте просто ранги пересчитывать таким же
образом. То есть давайте у каждой вершины будет ранг какой-то. Ну, допустим, у нее будет там
какой-то ранг, и он будет навсегда. То есть, знаете, кстати, можно даже подумать на эту тему,
потому что в софтхипе у нас будет такая идея, что у вершины есть великий ранг, вот она, и он
навсегда. То есть это означает, что у меня ранг 57. Это означает, да, я был великим вот этим вот
деревом на 2 в 57 вершин. Правда, у меня все поотпиливали, но когда-то я был, но я из дворян, да.
То есть, да, дворян, конечно, да. То есть, да, там, конечно, всех расстреляли, там это дедушку
расстреляли, про дедушку расстреляли, там папу расстреляли, меня расстреляли, там детей расстреляли,
но я был крутой. Вот, да, ну как-то так. А вот здесь тоже, вот, допустим, просто мы будем в каждой
вершине у нас будет ранг, и он будет тоже по такому принципу, да, что если мы сливаем, то есть ранг это
то, что написано в корде, все. Если мы сливаем два дерева с одинаковым рангом, говорим мы, то давайте,
ладно, у той вершины, то одну подвешиваем к другой, и у той, кого подвесили, ранг увеличиваем на единицу.
Ну, похоже на... Нет, ну просто нет, в итоге они просто не совсем этому соответствуют.
Ну, изначально, да, то есть, скажем, да, то есть, казалось бы, кайф, потому что, ну, казалось бы,
вроде кайф, давайте подумаем, вот, просто давайте предположим, да, что давайте, когда мы, скажем,
добавляем вершину в кучу, мы присваиваем ей ранг 0, очевидно, да, ну, почему бы нам не присвоить, да,
а потом начинаем там, действительно, как угодно развлекаться, в чем проблема.
Хорошо, да, согласен, но заметим, что в свете нового декресски у нас и рейс будет теперь сводиться к
декресске, то есть, идей такая, почему бы нам не сделать декресски на мизу бесконечности, а потом вызвать экстракт мин.
Да, вот, кстати, у нас новая парадигма, в свете декресски у нас теперь и рейс будет по-другому работать,
так как у нас теперь нет гарантии, что клубина логарифом.
Ну, смотря почему плохо, да, надо еще думать. Вот, давайте внимательно думать.
Вот тут надо внимательно думать, просто надо внимательно понять, где подлянка, потому что, давайте, то есть,
новая алгоритма, то есть, смотрите, обновление алгоритма, то есть, мы больше не зацепляемся, что у нас бенемиальные деревья,
но мы говорим, что у нас какие-то деревья. Вот, то есть, они у нас какие-то, то есть, какие-то, но у каждой вершины есть ранг,
который высчитывается так же, как вычислялся бы, если бы это были честные бенемиальные деревья.
То есть, в общем-то, то есть, честно, то есть, изначально у одной вершины ранг 0, когда мы объединяем два дерева с одинаковым рангом корней,
мы просто, как бы, один из рангов увеличиваем на 1. Понимаете, да? Вот, то есть, вроде кайф.
То есть, более того, пока нету ни одного каскадинка-то, в общем-то, это, как бы, бенемиальные деревья останутся честными бенемиальным деревьями,
то есть, все в порядке. Вот. Вот, после каскадинка-то, вот, конечно, начался шоу, то есть, мы теряем этот вариант, но давайте думать тогда у нас,
но алгоритм, как бы, теперь работает, то есть, он как-то работает, то есть, мы вот заклинание какое-то делаем, да?
Как-то вот заклинание там есть такое, картинка есть, вот, знаете, вот, Андрей Михайлович будет очень любить говорить, картинка.
Вот, что такое, например, производящая функция? То есть, что такое вот формальный степенной ряд? Это картинка.
То есть, вот это просто вид, что там 1, плюс 2х, плюс 3х в квадрате, минус 4 в кубе, и так далее. Это картинка.
Это не какая-то там функция, то есть, он может там сходиться, расходиться, там, бла-бла-бла, но формально это картинка, с которой можно делать вот, то есть,
как бы, сумма степенных родов, это тоже мы берем две картинки и делаем вот так. Вот, также их можно вычитать, умножать и даже делить.
Вот, ну вот, такой вот примерно смысл. Так, вот, возможно, я вам еще анонсировал, что у вас там будет, собственно, на лекциях Андрея Михайловича.
Вот. Вот. Ну, я не знаю, может, он, конечно, это не так как-то будет объяснять, но нам это как-то так он объяснял.
Вот. Давно, впрочем, это было. А когда это? А, ну да, в 10-м году, получается, это было. Ой-ой-ой-ой-ой, кошмар.
Хотя не, вот. Ладно. Ну, вот. Кошмар, знаете, и тут я понял, когда-нибудь ко мне придут студенты, я им смогу достаточно уверенно сказать,
да вы знаете, да я тут преподаю больше, чем вы на свете живете. Не, кстати, это получается, ну, что получается, лет через 5-6 это произойдет, получается, да.
А нет, вру-вру, нет, не правда, нет, низко. Не, это произойдет лет через 10, да. Не, ну да, я как бы 10-й год преподаю, поэтому да.
Поэтому нет, вам пока еще рано, да. Но не важно, ладно, не заморачивайтесь, это да. Да.
Не, вы в это время будете, нет, то это не ваши дети еще будут. Нет, я, конечно, не знаю, но для того, чтобы это было,
где-то нужно, чтобы у вас у кого-то были дети, причем которым уже где-то лет 9, понимаете, так что лет 9-10.
Нет, то что признавать, нет, если как бы, нет, если у вас есть дети и действительно они там действительно с вами живут, вы их воспитываете,
но на самом деле это круто. На самом деле, да, вот в таком контексте, но что-то мне подсказывает, что, что вряд ли.
Нет, это тоже неплохо само по себе, да. То есть там как бы важная оговорочка, да, то есть как бы печально, если дети есть, но они где-то там, да.
Так вот, ладно, значит, смотрите. Итак, алгоритм, значит, поняли, теперь давайте его анализировать.
Что нам надо теперь на эту тему думать? Так, ну давайте смотреть, за сколько работает insert?
Insert работает за единицу честного времени и увеличивает потенциал на один. Ну кайфец, вот единица, да.
Так, melt, ну давайте так с простого будем просто начинать. Ну там getmin, понятно, единица тупая без изменения потенциала.
Melt тоже честная единица без изменения потенциала. Что там у нас еще? Great, ну понятно, там допустим, честная единица там тоже.
Значит, decrease key, ну там erase сводится к decrease key, decrease key, как мы вот с вами только что убедились, но отработает за единицу.
Кайфец, да. Вот, хотя нет, вру, но erase правда вру. Чего melt? Melt мы делаем предельно честно.
У нас как бы двусвязанный список корней никто не отменял, с поддержкой минимума на нем.
Поэтому melt это просто берем два списка и сливаем их в один. Сливаем не в смысле мержа вот этого, да, с двумя указателями.
Так же, а в чем проблема? Вот пока да.
Глубина, погодите, что глубина? Мы где уже глубину не используем, обратите внимание. Мы erase перешаманили так, чтобы избавиться от зависимости от глубины.
Чего? А вот да, то есть на самом деле кульминация это кроется в экстракт-мини, потому что все остальное, кроме экстракт-мини, работает кайфово.
То есть каскадин-кат вот крутой, вот с таким потенциалом, это дикиски крутой. А вот с экстракт-мином проблема. Где проблема?
Хотя подождите, какая проблема? Мы просто как бы выпиливаем этот минимум, значит этих детей повышаем в ранге.
В ранге не повышаем, но как бы корнями объявляем и делаем consolidate. Вот и все.
То есть берем, казалось бы, количество пометок, обратите внимание, у нас могло только уменьшиться, потому что, напоминаю, важный вариант еще есть такой, что корни не помечены никогда.
То есть если вершина попала в корень, орден отбираем. Ну потому что типа вы уже попали на небеса, вам это уже золото не надо.
Но как бы каждая отмена ордена, она нам только улучшает жизнь. Вот. Но тогда без нее получается все равно кайфово, потому что мы consolidate, он работает за, сколько времени?
Он работает за t плюс log n, он убивает t деревьев, взамен оставляет логарифом. Получается суммарно логарифом. Ура, мы победили.
Но как бы мы выписываем, просто заводим массив на логарифом, заносим туда все, все деревья с такими рангами, если что, смерживаем.
Вот. А вот это вопрос, который все к чертям валит. А кто вам сказал, что при вот такой диспозиции у нас ранг вообще будет всегда не происходить логарифа?
Потому что на самом деле, если мы ухитримся доказать, что ранги не превосходят логарифу или хотя бы от логарифа, то мы победили.
Вот. Ну, кстати, да, для этого надо вспомнить, а почему раньше-то вообще мы так уверены были, что рангов до логарифа?
Да, именно вот, где мы, вот это единственное место, где мы пользуемся, но это было одно из тех двух мест, которые мы реально пользовались тем, что дерево биномиальное.
Что значит биномиальное? Это означает, что у дерева ранга k реально два в степени k вершин. Поэтому это означает, что ранги не происходят лог 2n. Понятно, да?
Вот. Но сейчас мы, к сожалению, такого заявить не можем. Максимум, что мы сейчас сможем сделать, это стереть логарифом и ввести понятие d от n.
Вот. Где d от n это максимально, ну я это буду называть максимальный возможный ранг вершины в куче размера n.
Ну или просто говорить, что пусть у нас есть какие-то n элементы, из которых мы как-то комбинируем различные кучи с помощью вот этих всех операций.
И тогда утверждается, что максимальный ранг, который у нас может получиться, он d от n. Тогда мы можем, тогда мы уже понимаем, что, то есть учетная стоимость, ну на текущий момент у нас пока не логарифом, а, формально говоря, d от n.
Понимаете, да? Причем более того, что интересно, на самом деле d от n, ну скажем так, в такой диспозиции на самом деле, то есть он может быть достаточно произвольным, потому что у нас есть вольность в том, как вообще это d от n делать.
То есть самое главное для нас, чтобы в консолидейте было, что когда мы сливаем дерево одинакового вот этого ранга, то есть, видимо, то есть слово ранг теперь уже теряет смысл, то есть просто говорить, что пусть у нас у каждой вершины какая-то чиселка.
То есть пусть у нас есть, будем говорить, что у нас у вершины какая-то чиселка, может она когда-то меняется даже, но при этом, когда мы сливаем два дерева одинаковой этой чиселки, то у одной из этих вершин чиселка увеличивается на один, допустим.
Или как-то еще меняется, нам даже не особо принципиально, потому что в общем-то d от n изъялся только из-за того, что мы гарантировали, что эта чиселка не бывает никогда больше, чем d от n.
А, нет, мы еще пользовали, нет, вру, мы здесь пользуемся тем, что когда вы сливаете два дерева, у вас ранг увеличивается.
Поэтому, то есть мы будем говорить так, что ранг увеличивается так, то есть чиселка, что когда у вас есть мерч, вот это вот, когда вы сливаете два дерева с одинаковым рангом, то ранг объединенного дерева, он на единичку больше.
Было дело. Вот, и этим мы пользуемся. Вот, но в остальных местах, возможно, эти ранги могут меняться как-то еще.
То есть, может быть, мы там, скажем, в каскадинкате, например, то есть отпиливаем там что-нибудь, ранг тоже там какой-то поменяли или что-нибудь еще в этом роде.
Вот, нет, как и раньше, но просто теперь смысл этого ранга какой-то другой. Вот хочется его ввести так, чтобы вот было не более чем d от n.
Вот, как введем ранг, можно его ввести, можно его ввести рандомно, типа один раз в Вильнии, тогда гарантировать, что он не происходит, ну, скажем, n.
Ладно, и то не факт. Потому что, ну, за очень-очень-очень-очень-очень-очень-очень-очень-очень-очень-очень много операций, конечно, мы можем добиться, наверное, того, что там этот ранг накрутить до бесконечности.
Ну вот, причем даже используя те же n вершины, ну там просто постоянно отпиливая детей и сливая. Правда, это потребует очень-очень-очень много вершин там операций, но тем не менее.
Вот, поэтому там возможно какая-то амортизация, но мы пойдем, но мы попробуем пойти другим путем.
Значит, как же вводится ранг? Ну, на самом деле, в официальной версии Кучи Фибоначчи понятие ранг на самом деле даже может особо и не быть.
Ну, то есть в реальной реализации у вас не будет понятия ранг, у вас будет понятие количество детей.
Понятно, да?
И тогда вот идея такая, то есть давайте будем, то есть здесь мы будем класть как бы корень, у которого столько детей, там 0 детей, 1 детей, 2 детей, 3 детей, ну и так далее.
Удобно, правда?
Да.
То есть внимание, еще раз, новая идея.
То есть рангом, этим, так сказать, рангом объявляем степень, то есть ориентируемся на степень вершины, то есть количество детей у нее.
Вот.
Да, 4, 5, 6, 7, 8 и так далее, и так далее до D10.
То есть нам надо, ну как бы мы заранее можем его не знать, но мы это все векторами можем хранить, понимаете, да?
Вот, то есть рисайте там что-нибудь.
Ну, то есть, конечно, то есть авторы, конечно, статьи предлагают тут завести сразу статический массив, потому что они знают, чему равно D от N.
Это константа?
Нет.
Нет, если бы, слушай, если бы это была константа, то мы бы тут рисковали везде от единицы получить, кстати, если бы это константа была.
Но если мы заранее знаем N, то как бы можем и статический массив завести.
Ну да, но для этого и даем, там надо что-то доказать.
Ну, в общем-то, на самом деле, сейчас наша цель будет доказать, что D от N это от логарифма.
Да, правда, N это не логарифм, а именно от логарифма, то есть да.
То есть надо доказать, что степень вершин не превосходит чего-то адекватного.
Вот, понятно?
Вот.
А теперь осталось только выяснить, чего не превосходит.
Но для этого мы подумаем вот как.
Смотрите.
Да, причем, ладно, кстати, наврали, что они хранят, потому что, видимо, в реализации степень хранить, наверное, все-таки придется.
Ну, потому что вам же, вы же не можете, то есть вам придется хранить степень детей для того, чтобы вот тут выяснять, куда класть.
Так вот.
Но идея, на самом деле, такая.
Смотрите.
То есть на самом деле ранг мы все-таки введем.
Значит, ранг будет таким.
То есть, на самом деле, ранг двумя способами можно определить.
Можно определить так.
У корневых вершин ранг это тупо степень вершины.
Понимаете, да?
Но как только вершина перестала лежать в корневом списке, то она свой ранг фиксирует, и он не меняется до тех пор, пока ее не вернут в корень.
Понимаете, да?
То есть, если отпилили ребенка, то есть, как бы, мой ранг 57.
Ну, у тебя да.
А у тебя отпилили ребенка.
Все равно 57.
Как бы, да.
Ну, у тебя всего 56 детей.
57 ребенок навсегда в моем сердце.
Я помню его.
Я крутой.
Мы отпилили второго ребенка.
У меня все равно 57.
А мы тебе переносим в корень.
Ну, тогда ладно.
55. Хорошо.
Да, вот примерно тогда.
Вот ровно так это и работает.
Ну, на самом деле, как бы, никому не заморачиваем, потому что в данном случае получится, что если вершина...
То есть, у любой вершины, на самом деле, ранг – это реальная степень плюс орден.
Если он есть.
Ну, если его нет, то, значит, плюс нихрена.
Вот.
Ну, такая не самая типичная ситуация, когда у вас как бы либо орден, либо нихрена.
Но тем не менее.
Вот.
Так что вот такая вот радость у нас возникает.
Так.
Вот так будем считать.
Еще раз.
Надо повторить.
Еще раз.
Значит, определение.
У каждой вершины есть степень.
То есть, количество детей.
Рангом будем считать.
Можно даже определение ввести рангом.
Будем считать количество детей плюс орден, если он есть.
Ну, если ордена нет, то просто количество детей.
Напоминаю, что важный вариант.
Что у корней орденов нет.
То есть, если вершина подает в корень, то орден снимается.
Но если его нет, то соответственно.
То есть, есть, конечно, знаете, рассказывают эти легенды про мистическую ложку,
которая умеет снять любой из глаз.
То есть, просто дают вам ложку в ее там, просто кладете в рот, и она снимает с вас глаз.
Но.
Но.
Если ни у кого с глаза нет, ложка травит сама.
И более того, сама потом отказывается вас лечить.
Вот.
То есть, такая вот подляночка интересная.
Вот.
Так вот, в данном случае это не так.
То есть, здесь такого не будет.
То есть, как бы, то есть, попали в корень, отдавайте орден.
Нет ордена. Ну и хорошо.
Ну, просто чисто это.
Типа, на высшем уровне.
Типа, ни у кого там никаких этих там бизнесов ретенов быть не должно.
Вот такая долога.
Вот.
И так ввели такой ранг.
И такой ранг.
То есть, типа вот такая степень, как она должна быть.
Так вот.
Тогда возникает идея такая.
Давайте, то есть, ну на самом деле нам с вами, все, что нам с вами нужно, это доказать теорему.
Ну, давайте так скажем.
Пусть у нас.
Там.
Вот так вот скажем.
Мин СЗ от Р.
Это будет.
Минимальное.
Количество.
Вершин.
В под дереве.
Что сразу?
Господи.
Не в этом месте ты, господи, говоришь.
Господи, будет следующая эта лекция.
Там софт хип будет.
Да.
Как бы тут все халява на самом деле.
Так.
Значит, в под дереве.
Вершины ранга.
Или ранга, я уже не знаю.
Ну ладно, Р.
Вот.
Мин СЗ.
И нам нужно доказать теорему.
Так вот.
Теорема.
Вот как это.
Знаете, типа депозит.
Все.
Не сталкивались это с веселым рассказом про экономику.
С кодовым словом депозит.
Но там это издевательство.
Это.
Что-то логика типа.
Представьте, у вас там три человека.
Оказались на небитаемом острове.
У одного из них есть дверь, а у другого в кармане 100 долларов.
Казалось бы, сколько стоит.
Сколько может стоить дверь.
Так вот.
Если у третьего есть блокноты, он создает банк, то на самом деле примерно к концу дня стоимость этой двери вырастет до тысячи долларов.
Для того, что он будет выписывать облигации.
Вот.
Но там отдельно почитайте, тоже весело.
Так вот.
Теорема.
Теорема.
Мин СЗ от Р больше либо равен.
А вот я не буду палить ответ.
Как всегда.
Я просто люблю рассказывать в стиле.
А давайте сами все выведем.
Просто вот концентрируюсь на идее.
То есть, если вы хотите просто причитать, что на самом деле там все устроено вот так и инварианцев лезут такие доказательства.
Вот.
Да, это, конечно, пожалуйста, в кармане этого всего добра будет.
Вот.
А у меня даже презентация была с этим всем, кстати.
Что-то я ее не показываю.
Правда, здесь я не показываю, потому что это сложный алгоритм.
И тут лучше будет, если мы будем разбираться как бы помедленнее и спокойнее.
Чего?
Вы сказали же, что все просто.
Все в этом все относительно.
Понятно.
Относительно марш сорта.
Тут все очень сложно.
Но относительно софтсепада тут все просто.
Вот.
Так что тут все относительно.
Так вот, больше либо равно чего.
Но для того, чтобы понять чего.
Мы давайте думать на следующем.
Так.
Давайте вообще думать, как устроено дерево ранга Р.
Вообще.
Давайте так.
Дерево ранга Р.
Допустим, если это корневой список, то у него Р детей.
А если не корневое, то значит детей как минимум Р-1 точно будет.
Правда?
Нет.
Но мне интересно посмотреть на детей.
Да, я согласен, что это количество детей и количество вершин по дереву.
Это не одно и то же.
Но начнем мы с количества детей.
Спокойно.
Ответ.
Не знаю.
Название намекает, что раз это не куча тарьяна, значит вряд ли это будет число тарьяна.
Но, соответственно.
Но давайте смотреть.
Детей у нас Р или Р-1.
Но меня интересует даже не это.
А какие у них самих ранги?
Ну, сформулируем так.
Ну, давайте вообще думать.
Дерево ранга 0, но с ним все понятно.
Как образовалось дерево ранга 1?
Но, наверное, это означает, что у него есть...
Если у тебя дерево ранга 1, то есть подозрение, что у тебя появилось, наверное, ребенок ранга 0.
Правда?
Или его вырезали.
Ну, потом.
И, возможно, его потом вырезали.
Может вырезали, может нет.
Но у нас, напоминаю, да.
Но понятно, в любом случае, если у тебя есть...
Понятно, что у тебя есть...
То есть, если у тебя ранг 1, и ты в корне, то у тебя либо есть под дерево ранга 0,
или даже большего какого-то, потому что мало ли у нас ранга до степени.
Либо, если ты не корень, то кто ты?
Ну вот, то ты некто, у кого, скорее всего, там по дереву уж какого-то ранга было.
Ну, возможно, его отпилили.
Ну, с другой стороны, заметим следующее.
Ну, мы сейчас по рангам смотрим, на самом деле.
Так, хорошо.
А если у меня ранг 2?
Как это могло быть?
Это могло быть то, как когда меня делали ранга 2, наверное, я был ранга 1.
Это означает, что у меня тут было нечто ранго.
Нечто ранго.
Ну, давайте так я пишу, как минимум 0.
И на меня повесили нечто ранго 1.
Логично, да?
То есть, тут как минимум 0 и 1.
Боря, ну, впоследствии кто-то из них мог отпилиться.
Ну уж, какое-нибудь одно дерево ранга 0 хотя бы тут точно есть.
Потому что отпилили не больше одного.
Так, давайте попробуем дальше думать.
Так, если у нас есть троечка, то что это означает?
Это означает, что, как бы, ну вот, то есть, троечка.
То есть, когда троечка формировалась, обратите внимание, помечена, она не была.
То есть, значит, у нее было реально два ребенка.
Причем у одного было больше либо равно 0 ранг, как мы уже выяснили, а у второго 1.
Потому что если вот, ну, как помню, у вершины ранга 2, как бы, получается, есть, изначально было два вот таких ребенка,
но просто какого-то из них, возможно, потом отпилили.
Но при непосредственно создании этой, при создании этого ранга, ну, соответственно.
То есть, когда эта вершина становилась ранга 3?
Там не должно быть два дерева ранга 2?
Должно быть, потому что я еще не дорисовал.
Оно было деревом, вот, когда их мерзили, да, то есть, когда вот при мерже эта вершина становилась ранга.
Вот. То, как бы, да, к ней подвесили еще вершину, значит, ранга 2.
Вот так. Неплохо, да. Неплохо, так, да?
Вот.
Ну вот, раз тут два.
Вот. Ну, хочется, конечно, сказать, что неужели тут всегда у вершины ранга 3,
пока на вкорне будут вот такие дети, но на самом деле не совсем.
Ну, точнее, тут-то они будут и такие, но на самом деле есть еще один способ, на самом деле, как стать, как стать вершиной ранга 3.
Ну да.
Прям отсылка к тому же Мурманску.
Там просто была история.
Да, занимательная история, как Андрей Сергеевич стал капитаном.
Просто еще будучи майором, он бы пытался прижать начальника местного ГУВД.
Вот. Ну, здесь примерно та же ситуация.
Да. То есть, он когда-то мог быть рангой 4,5 и 57, но просто у него попилили детей.
Да. Ну, на этом уровне всякое случается, да.
Вот. Ну, сейчас, конечно, реже, но в нашей ситуации.
Да. Вот.
Но что это означает?
Ну, это, в принципе, отсюда, то есть, когда он впервые становился троечкой, у него все здесь хорошо.
Но, в принципе, если он из 57 на самом деле становился, то у него там все было еще круче.
И, по-видимому, там, на самом деле, ранги были такие.
Чего?
То есть, ну, хотя нет, здесь, конечно, оговорка, потому что, да.
Ладно, детей могли, конечно, отпилить в итоге.
Да.
До не более одного.
Ну, получается такое.
Но давайте думать.
То есть, идея получается какая-то такая.
Но теперь давайте попробуем сформулировать это как лемму.
То есть, лемма.
Да.
Больше равно минци-з от r-2 плюс минци-з от r-3 вроде?
Ну, точнее так.
Если мы утверждается такое, что...
Ну, там хочется утверждать такое, что если мы их отсортируем по рангам,
то ранг каждого следующего будет не менее чем порядковый номер минус один.
Понятно, да?
То есть, утверждение такое.
Рассмотрим вершину, даже неважно, какого ранга, просто у него есть k детей.
Тогда я утверждаю следующее.
Что пусть отсортируем этих детей по рангам.
Мы можем детей по рангам отсортировать, правильно?
Вот, пожалуйста.
Так вот, лемма говорит, тогда...
Я утверждаю, что ранг it больше либо равен и минус один.
Вот у нас пока возникло интуитивное ощущение.
Вот.
А, все-таки начинаем умирать, да?
Точно?
Лучше вылезай, если головы не будет видно.
Соответственно.
Вот.
Вот.
И минус один.
Но давайте думать.
Но давайте думать, когда у нас диспозиция меняется.
Так, ну давайте по индукции.
База индукции.
По индукции, видимо, по количеству шаров, которые вообще были сделаны в куче фибоначи.
Когда вершина только-только создалась...
Ну, очевидно, все хорошо, потому что нет детей, нет проблем.
Вот.
Вот.
Ну, не в смысле, что нет детей само по себе не проблема, но тут как бы да.
Но как бы таких проблем, то есть как в утверждении, нет детей, нет проблем, связанных с детьми.
Ну, может быть, да, это не отличает, это отменяет проблемы с их отсутствием, но как бы да.
Вот так формально скажем, да.
Вот.
Значит, идем дальше.
Так, ну давайте смотрим, как у нас у вершины может поменяться список детей?
Так.
В каких ситуациях он меняется?
Так.
Ну, во-первых, меняется, конечно, ситуация с...
Вот.
Так.
С кем у нас меняется ситуация?
Ну, меняется, конечно, ситуация, когда...
Ну, во-первых, когда у нас две вершины одинакового ранга меняются.
Да?
Бывает такое?
Но если так произошло, то как бы если эта вершина решила слиться с кем-то,
то тогда они обе были корневыми, значит, у нее был ранг К,
и у ее соседа был ранг К, то есть была степень К. Правда?
Но тогда получается, что к этой вершине,
там, без граничей обществе к этой,
предъявилась еще одна вершина ранга К.
Но тогда получается, вот этот инвариант выполнен.
Понимаете, да?
Но, правда, с оговоркой, что может этот массив не отсортирован,
но, думаю, легко показать, что если мы эту К вставим в отсортированный список правильно,
то хуже от этого не станет. Правда?
Ну, потому что если К встанет в какой-то...
Ну, потому что очевидно, что если К встанет в какое-то место,
то есть, конечно, требования к этим вершинам увеличатся,
но заметим, что, так как у этих вершин тогда ранг и так не менее, чем К,
то все в порядке. Правда?
Так понятно, о чем я говорю?
Так есть кто живой?
Так есть кто живой?
А то, опять, на ICPC вы молчите, и тут вы молчите.
Что объединяет ICPC и вот это.
Самое смешное, что ничего вообще.
Я не знаю.
Ладно, давайте, да.
Как-то небольшое переключение для этого.
А ну, поднимите руки, кто уже зарегался на ICPC.
Так.
Давайте так.
А кто уже знает команду, с которой он будет регистрироваться?
Давайте так.
Правильный вопрос.
Так, поднимите руки, кто еще не знает, с какой командой он будет регистрироваться.
Так, понятно.
Нет, просто вы можете выше подниматься,
потому что вы можете еще друг на друга посмотреть.
Кстати, разделиться быстренько.
Так, ладно, давайте еще две статистики.
А кто уже знает, что он принципиально не хочет участвовать в ICPC?
Так.
Так.
Кстати, интересно, отчет так.
За школу надоело.
Чего?
А помочь товарищам?
Ну, как бы, от вас потребуется только зарегистрироваться,
там прийти, решить там парочку задач, собственно, в воскресенье,
и в общем-то все.
В воскресенье занято.
Все прям настолько занято.
А что у вас такого в воскресенье?
Этературный клуб.
И что, прям с 11 до 16 занят?
Нет, просто да.
Нет, то есть, конечно, дело добровольное,
но просто да, на всякий случай напоминаю,
что, по крайней мере, по моему курсу,
за это еще бонусы кидают.
То есть, если вы еще и хорошо решаете,
там могут быть бонусы в размере,
скажем, такой типичный бонус прошлых лет,
это вы получаете бонус к оценке,
что-то типа там количество решенных задач,
минус 8 поделить на 3.
Или минус?
Нет, максимум из этого и нуля, не волнуйтесь.
А может, аж и минус 7.
Там, посмотрим, я примерно формулу сказал,
точные цифры могут отличаться в зависимости от конкретного контеста.
Сложнее или проще?
Он будет практически как квал,
который вы в субботу решали, если вы такой решали.
То есть, в переводе говорят,
там где-то только с 8-9 задачи начнутся какие-то реально серьезные задачи.
То есть проще, чем в год 25?
Нет, гораздо проще.
Я говорю, как в субботе.
Если кому интересно, кстати, вот субботний контест,
могу тоже дать вам ссылку, можете виртуально написать,
если вы хотите посмотреть.
То есть, первая часть делается простой,
потому что тут задача привести чемпионат не самых сильных узов.
То есть, соответственно.
То есть, понятно, что, скорее всего,
вы первые 7-8 задач, скорее всего,
максимум часа за два именно пощелкаете.
Вот.
То есть, ничего такого сложного нет.
То есть, понятно, что этого может не хватить,
для того, чтобы побороться за выход в четверть финал
с вашими же одного узника.
Но, тем не менее, первые сколько-то задач вы решите на халяву.
То есть, скажем, в 17-м году, да, там вот так и было.
7 задач простые какие-то первые, там только в конце или 8.
А первые вот стоят, там вот действительно это задачи,
в которых надо подумать.
И то, на самом деле, там супергробами они не являются,
на самом деле, там такими, чтоб прям совсем их не решать.
Но, то есть, по меркам обычного контеста вчерашнего,
это могли быть такие.
Внутри средние или где-то среднесложные задачи.
Вот так, скажем, где-то.
То есть, они там в слотах где-то там между четвертой и восьмой стояли бы.
Вот.
Ну, может, даже чуть меньше.
Ну, да, по современным меркам, наверное, там уже уровень вырос.
Вот.
Но, тем не менее.
Вот.
Так что вот так.
А можете, пожалуйста, повторить, как мы ранги считаем?
Вот.
Значит, еще раз.
Возвращаемся к рангам.
Ранги мы считаем так, что пока вершина в корне,
ранг – это тупая ее степень, то есть количество детей.
Но, как только вершина перестает...
В тот момент, когда вершина перестает быть вершиной из корневого списка,
у нее ранг фиксируется и не меняется до тех пор,
пока она снова в этот корневой список не вернется.
Когда она туда вернется?
Ну, видимо, вот где-то либо в каскадинкате,
либо в каскадинкате, либо, допустим, она была ребенком,
ребенком минимума, который в экстракт-мини удалили.
Вот.
А как мы еще тогда Лемма еще раз доказывали?
А мы пока не успели доказать.
Лемма пока говорит так.
Так, рассмотрим вершину, рассмотрим все...
Рассмотрим ее, пусть у нее к детей.
Ну, просто ка это переменную ввели, пусть у нее к детей.
Отсортируем эти ка в порядке неубывания рангов.
Говорим мы.
Тогда утверждается, что ранг ИТО в этом порядке ребенка не менее чем и минус один.
Вот мы такое хотим заявить.
Понятно, да?
Вот.
Вот.
И мы тут начинаем смотреть, как этот вариант меняется.
Вот. То есть это пока Лемма.
Полного доказательства у нас пока еще нет.
Мы там все в одном месте остановились.
Давайте так. Немножко так.
Переключились после ACPC и возвращаемся на место.
Вот.
Соответственно, идем дальше.
Ну да, кстати, да.
Чем на экзамене вам поможет бонусик?
На экзамене у нас поможет очень просто.
У вас будут билеты на УДОВЛ, на ХОГЛ, на ОТЛ.
Если у вас будет ACPC бонус, вам не придется учить билеты на ОТЛ.
Чего?
Кстати, да.
Вот.
То есть для этого просто надо вот, как бы хорошо.
Бонусы, кстати, даются и за зачет, и за экзамен.
Вот.
Так что вот.
Вот.
Ну, там можете подробнее поспрашивать у ваших там старших коллег.
Действительно, как эти бонусы работают.
Но как показывает практика, так они.
Ну, несколько, некоторое количество усилий вам в итоге экономят.
Вот так скажем.
Вот.
Потому что, мало ли, вдруг вы случайно не решите задачу про второй минимум, например.
Вот.
Или там что-нибудь еще в этом роде.
Да, ну вот. И там не хватит.
А так, пожалуйста, сходили на ACPC, получили свой плутбал.
Отдельные счастливчики даже.
Плюс два.
Плюс четыре, помнится даже.
Ну вот.
Но там, честно, зависит от конкретных задач.
От конкретных задач, от конкретной формулы и фазы луны.
Но обычно, как бы, скажем так.
Обычно там бонусы выставляются так, что получить плюс один, это не очень сложно.
Вот получить два, это, конечно, уже там серьезный результат.
Да.
Вот.
Но плюс один вполне.
Да.
Ну, на квале не обещаю.
Не обещаю.
Ну, может быть на русском, может быть на английском.
Но на квале, как бы, вы будете сидеть из дома.
Да.
Да, поэтому, в принципе, я там пользовался Google Translate.
Вам там никто не запретит.
Вот.
Да.
Как будет проверять то, что с одного компьютера пишут?
Ну, с формулировом так.
Жюри не будут раскрывать методы, но они у них есть, поверьте.
Вот так скажем.
То есть там разные способы.
Это, наверное, следить, с каких аппаратов какие сабмиты происходят, например.
И так далее.
То есть там...
Нет, это, пожалуйста, конечно.
Нет, нельзя.
И потом, нет, вплоть до того, что от вас, ну, теоретически там рассматривается вариант.
Я не знаю, будет ли он принят, что может быть от вас потребуется какой-нибудь прокторинг.
Ну, условно, вы должны будете прям полностью себе записать, что вы делаете.
То есть если там поэтому вы будете писать с одного компа, и у вас там как-то неожиданно будет выяснилось, что у вас появился какой-то магический код откуда-то, то как бы это подозрительно.
Но там, нет, это вам не запрещает там писать, допустим.
Бывает, если вы там втроем окажетесь в разных городах, то в принципе, понятно, есть стандартные технологии, вида, что вы там подключаетесь, там сидите в одном канале, но просто гарантируете, что в каждый момент времени программированием занимается только один человек.
Но тогда проблема в случае чего решается так. То есть вы там просто записываете себя в зуме, просто все три компа с экранками, можно даже с камерами.
И тогда, если у жюри возникнут вопросы, вы просто предоставляете эти записи, они просто смотрят, что в каждый момент времени все было честно.
А чем пользоваться можно?
Ну пользоваться, ну до контеста обычно так, точно можно пользоваться всеми средствами, всеми письменными принадлежностями, всеми учебниками, книжками, пожалуйста.
Это можно было пользоваться, даже если вы очень пришли.
Ну а говорить о электронными устройствами никакими пользоваться нельзя, кроме, собственно, то, на чем вы пишете.
А нот обычно такая классическая.
Но на тему преднаписанных кодов тоже надо жюри спрашивать.
То есть там, я не знаю, гарантировать не могу, что там можно копипастить там свой какой-нибудь старый код.
Так вот, так это было по ACPC, так сколько у нас?
Так, а почему нас еще не выгоняют?
Ну ладно, пока нас не выгоняют, давайте это допилим.
Не, ну там вообще может выяснилось, что они там тоже нашли уже аудиторию, поэтому нас не потревожит.
Ну ладно, все.
А, фу, стоп, подождите.
Нет, у нас тут все синхронизировалось, поэтому пара заканчивается в 13.45 и нас будут выгонять в 13.55.
Так что, слава богу, все нормально, нас пока еще нормально.
Нет, ну на самом деле мы и близки просто к финишу, поэтому хочется это добить сейчас.
Смотрите, вот леммочка.
Значит доказываю, когда меняется диспозир, когда вот может поменяться вот этот список?
Ну список меняется когда?
Когда, либо к этой вершине что-то подвешивают, либо когда от вершины что-то отпиливают.
Ну во-первых, когда от вершины отпиливают, то этот инвариант, очевидно, не меняется.
Правда?
А когда припиливают, но тогда, заметим, что припиливают в точности вершину ранга К.
ранга к правда ну потому что у нас есть только один случай когда к вершине что-то припиливают
это объединение двух деревьев одинаковых рангов но вот и в тот момент когда эти оба дерева
являются корневыми помните да да нет наверное есть кто живой так тихо просто разговор какой-то
пошел где-то вот и так значит тут к но тогда я утверждаю что ну во первых прямо сейчас это
и вариант верен да единственное только оговорка что тут может быть строй знак больше но я утверждаю
что если это кап про свапать туда куда надо вставкой да то хуже от этого не станет ну потому
что ка по любому больше либо равно и минус один для всех этих позиций а если вот какие-то из
этих вершин продвинуться вправо то это будет означать что у всех их ранг уже больше либо равно ка значит
тоже все верно поэтому получается что лемма верна неплохо да вот но тогда если мы верим в эту
лему то тогда смотрите если у вершины ранга r то у нее как мы знаем не менее чем r минус 1 детей
правда тогда в принципе мы можем себе заявить что но опять то есть ну тут надо конечно тут надо
немножко аккуратненько на самом деле мысли то сейчас мы эту аккуратность пропустим но суть в том
что то есть там есть один там формальный формальный языковыка которые вас возможно потом когда-нибудь
спрошу но можно сказать следующее что значит есть r минус один детей у первого ребенка ранг хотя
поэтому получается здесь как то есть то есть это больше либо равно чем один ну сама эта вершина
плюс значит мин сз ранга 0 понимаете да плюс вторая у второй вершины ранг хотя бы один поэтому
тут мин сз от единицы потом будет мин сз от двойки и так далее и так далее плюс мин сз получается в
конце мы тут что напишем мимо да r минус два потому что у нас один ребенок может быть отпилен да здесь
а ко не аккуратность заключается в том что вообще говоря мы тут как будто не явно воспользуюсь тем
что мин сз это монотонная функция потому что здесь-то формально стоял вот здесь допустим в
какой 57 позиции дописано мин сз 56 да но на самом деле там на этой позиции могло стоять вершина
большего ранга а может быть вершина больше у вершины большего ранга мин сз меньше мало ли
формально говоря мы этого не доказали понимаете да вот но на самом деле это мы пока но перфом это
можно интуитивно поверить пока пока пока пока пока мы пишем шаблон доказательства а точная
доказательства в точном доказательстве все равно теорема будет звучать как мин сз больше либо
равно и там какая-то функция да и эту функцию потом вы будете аккуратно доказывать но там
чтобы не было зацикла по индукции по не только количеству вершин но и по высоте по высоте
дерева но то есть утверждение что вершина дерева р у которой под дерево высоты аж у нее вершины
меньше чем и какая-то функция которые зависит только от р вот понятно да но там этого и доказательства
сойдет вот не буду сейчас описывать но короче приводит нас к этой вот этой вот штуке то есть
вот такому утверждению но теперь остается только сделать вывод а чему равно как оценить снизу
мин сз вот но на самом деле утверждается что ладно это пока имею такая это может
сказать мы лему доказали а теперь из нее на самом деле выходит серияма то есть мин сз от
больше либо равно какого-то р какого-то числа фибоначи непонятно какого
но может р-1 может там плюс-минус какого-то вот так я пишу фиб от там допустим р какой но
тут но тут проблема в том что чисто фибоначи можно сильно по-разному определять давайте
мы воспользуемся к ним классическим определением мне кажется такое что нулевое число фибоначи это
будет у нас один первое число фибоначи тоже один но а дальше соответственно понятно каждая следующая
сумма двух предыдущих 2 3 5 8 что как скажете хорошо но тут ладно это это нам оценку еще
лучше сделать 0 1 1 2 3 5 8 13 и так далее вот но тогда я утверждаю что вообще будет едва ли
не вот такой кайф а нет вранье потому что извините мин сз от нуля все-таки один хотя нет он больше
либо равен нуля поэтому это нас устраивает вот но давайте думать ладно давайте сейчас посмотрим
по индукции это это сойдется но то есть база очевидно для нуля все понятно а теперь для
эра пишем так чему нас равна так чему нас равно фиб она значит то есть у нас получается пишем
один плюс там фиб 0 плюс там давайте f 1 я кратко буду писать f 2 плюс и так далее плюс f r-2 да ну
давайте проверять так как это называется ну почему ну а первых заметим следующее что как
ну как минимум нет ну да так а супер да то есть заметим что давайте скажем что 1 то есть 1 это
у нас равно фиба 1 и тогда после этого заметим что вот это вот это f 2 вот это вот f 3 вот это
вот f 4 и так далее то есть можно заметить что вот это вот это просто не больше либрала а тупо равно
f r просто по определению просто вот мистическое свойство чисел фиба начи 1 плюс сумма чисел
от нулевого до р-2 тупо равна р тому то есть ну вот откуда суп но вот то есть поэтому на
самом деле мистическая теорема звучит так что как бы что получается в поддереве вершины ранга
р хотя бы это число фиба начи остается только маленькая идея ну как теперь доказать но вот но
тогда из этого следует что получается д от н это номер максимального числа фиба начи не
превосходящего n остается только доказать что д от н имеет какое-то отношение к логарифму но
как это сделать нет ну на самом деле как бы наука как бы умеет показать что как бы в некотором
смысле у нас fn растет как какая-то константа на 1 плюс корень из пяти пополам степени то есть
принципе логари то есть тут можно что д от н это это от логарифма n еще подписать что логарифм
имеется ввиду не по модулю 2 по мод не по основанию 2 по основанию вот этому вот но это правда надо
еще там как-то аккуратно доказывать но можно там аккуратно по индукции доказать что f от n больше
либо равно вот это вот для подходящей константы шаблончик прописать понимаете да ну и то начиная
с n больше либо равна 2 видимо потому что мы тут с нуля стартуем да но это но вот можно так самое
тупое для вас это на самом деле доказать ну там мне кажется одна из самых тупих версий была бы
такая доказать что fn больше либо равно просто там два степени пополам то есть на самом деле вот
это уже хватает доказать это понятно с полпинка докажете да вот но как бы получается что тут
8 логарифм увеличился не более чем в два раз так что отсюда и получается что значит ранг а как
следствие степень вершин то есть ранг получается такой никогда не происходит д от н как следствие
степень вершин тоже не превосходит д от н ура так что получается дамы победили да что-то оказалось
даже ну то есть в конце конечно нас ждал небольшой убой но кажется по-моему он в итоге не таким уж
большим и оказался но еще раз мы показали ну мы получили следующее мы показали что в поддереве
ранга вершины ранга и всегда не менее чем это число фибоначи вершин но так как у нас всего
вершин n то получается ранг вершины должен быть такое чтобы д от н не превосходила н правда
но вот д от н не д от н в смысле чтобы надо чтобы это число фибоначи получается не
превосходила это понятно но мы что у тебя будет садить у нас а у тебя есть н вершин да они
скомпоновались какие-то деревья у этих у корней этих вершин из какие-то ранги да и пусть у одной
из этих вершин ранг r да тогда в ней какое-то количество вершин не превосходящие n да но
с другой стороны оно при этом не она не layered не больше n но не меньше чем это число фибоначи
следовательно это число фибоначи не должно превосходить n остается только
вопрос получается ранга должен быть таким чтобы это число фибоначи не превосходила
этого остается только показать что максимальная такое иерами от show to stickfull available то есть
не более чем получается там два двоичных логарифма n первых чисел фибоначий не
происходят например там можно так что в общем-то вот и все а вот кажется на нот
и кажется вот кажется на этом можно и остановиться но как говорится в следующей серии будет мощнее
хотя что-то в этом в этот раз даже наоборот по-моему в следующей я все время обещаю
что будет мощнее потом выясняется что не сложно
