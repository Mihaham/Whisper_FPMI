Как уже говорилось, в 99% случаев почему-то во всех сетях, которые вам требуются, пропустые способности целочисленной.
Верно или нет?
Да не только.
Ну нет, может иногда бывает, что там по дороге может проехать не более чем корень из трех пополам машин в минуту.
Понятно, конечно, полтора землекопа в античной культуре не новость, но все.
Хотя было бы круто, если бы он получил скорень из трех пополам землекопы, конечно.
Итак, давайте себе представить, что тогда можно сказать.
Ну, в принципе, уже зачастую можно заметить иногда, что если пропустые способности не только целые, но еще и не сильно большие, то иногда даже банальный метод Форда-Полкерсона даже каким-нибудь банальным ДФСом работает не сильно долго.
Ну, мы думали, что, например, мы, вот еще одна оценка на метод Форда-Полкерсона в таком случае, вот здесь у нас есть оценка С.
Ну, такие даже не оценка С. Теперь мы можем вообще оценить, что у нас метод Форда-Полкерсона на самом деле будет работать не более чем за О от Е умножить на, а сколько там потока вам реально надо искать.
Логично, да? То есть вот если целые числа, то так. Это можно еще оценить так.
Ну, еще, конечно, иногда размер потока мы, конечно, можем оценить не всегда, хотя иногда нам это пригождается.
Но, например, если у нас есть классическая оценка С, то есть нам известно, что все пропускные способности, вот я напишу, в математическом виде, не превосходят какой-нибудь ценой большого,
то мы можем тогда оценить, на самом деле, поток как Е умножить на вот так С на, ну, допустим, день от С.
Ну, заметим, что поток уж точно больше не будет, правда? Наверное, просто из истока больше не выйдет.
Так что можно вот так, или если уж совсем от степени избавиться, в принципе, можно написать ЕС на В и желание будет.
Да, согласен, только что в предположении еще нет кратности.
А где это, что это?
Степень. В данном случае исходящее.
То есть уже можно оценивать вот какими-нибудь таким образом.
В чем заметьте, это просто метод Фордовских сонов банально.
Ну, а если брать еще ситуации, когда нам не всегда нужен максимальный поток.
Вот, например, есть такая классическая задача, например.
Это, скажем там, Вася и Петя живут в одном доме, ходят в одну и тоже школу, в какой-то момент поссорились.
И они хотят теперь придумать дорогу от дома до школы, не обязательно качайшую, но так, чтобы по одной и той же дороге они не ходили.
Вот, например.
Вот спрашивает, как тогда такое решать?
Ну, допустим, для простоты, что дороги ориентированы.
Ну, да.
Ну, да.
Совершенно верно.
В этом случае просто, мы берем ориентированный граф, действительно объявляем,
что это сеть пропустной способности всех игр Одды, мы запускаем поток величины 2.
Вот этих нема не надо искать максимальный поток, нам просто нужно искать максимальный поток величины 2.
не надо искать максимальный поток, нам просто нужно искать максимальный поток в величине 2
это делается буквально двумя ДФС
но правда, раз уж об этом зашла речь, стоит упомянуть об еще одном лайфхаке, который помогает
а что делать, если они так поссорились, что они хотят не только в одной дороге не ходить вместе, но даже на площадях не встречаться?
можно раздавить еще
просто вот упомянем
а то потом по результатам ДЗК кто-то там говорил, что может только подобные вещи нельзя придумать
и как-то тот фальшу 42 человека как-то будет найти залог, как-то не помогает
понимаешь?
вот ситуация
короче, если абсурдироваться от Васи и Пети, данный ориентированный граф, надо найти 2 пути от С до Т
так, чтобы они не пересекались ни по вершинам, ни по ребрам
по вершинам, кстати, по ребрам автоматически
что делать?
ну, хочется тоже решать задачу потоком
но при этом сделать так, чтобы единица потока не могла проходить через одну и ту же вершину более чем один раз
как это делается?
тогда делается так
если у вас есть вот такая вершина, допустим У
то мы просто ее разваливаем
говорим следующее
что теперь у нас вместо вершины У есть вершина У входящая и У исходящая
значит все ребра, которые входили раньше, входят в выходящую часть
в аут входят исходящие
и здесь есть пропускная способность А
ну или там, если вам требует то, чтобы проходило не более чем сколько, то тут тоже можете написать
да, вот такой вот хак есть
как вы решаете, чтобы через одну вершину...
да, чтобы через вершину тоже никто не приходил
фактически мы давали пропускные способности вершинам
ну да, на самом деле оказывается тоже можно
конечно, на самом деле ориентированность тут особой роли не играет
на самом деле
поток же ориентированность это всегда то же самое, что была ребра в одни стадии
ну, по сути, да
ориентированность
там конечно есть одна маленькая оговорка
на самом деле
там просто может так получиться
смотрите, мы предположим сеть вот такая
это не ориентированная
да, не ориентированная сеть
не, проблема не будет в том, что он тут не найдет какую-то потоку, он его, естественно, найдет
просто если не очень аккуратно сделать, то просто что у нас тут получится?
вот такое раздваивание не получится, да?
а теперь какие ребра?
вот те, допустим, мы не раздваиваем, потому что начхай
вот
а тут получается вот такая какая-то ситуация
вот, а, и вот так
ну и еще два ребра забыли
да, еще какие? внутренние
а, вот эти вот, да
так
что-то не то
сейчас
первый выход вершины должны входить в начало
да, да, да, я ошибся
видимо, проблема
так, проблема будет в том, что мы как бы по одному ребру два раза пройдем
а как мы пройдем?
в чем проблема? вот, раз, а
да, все же нормально
да, как-то в данном случае проблем не будет
хотя, нет, хотя
хотя полностью не что
ну хотя, да, как-то в эту вершину мы же иначе как отсюда не попадем
да, да, да, думаю, все нормально будет
да
да
ну да, тем более, видимо вообще нет проблем
вот
ну даже если бы они были, можно было отменять поток и не париться
в случае чего
правда, потом отдельно восстанавливать, в общем, на самом деле это не нужно
вот, ну это вот, да, упомянули
да, это вот важно
но это как бы ситуация, когда нам просто требуется не максимальный поток, а поток величины два
все, тогда два DFS-а, радость
вот, но если поток все-таки большой
тогда возникает такая, ну первая тут естественная мысль возникает
вот, хорошо, вот у нас метод Форда Фолкерсона, он ищет хоть какой-нибудь
да, чтобы пустить хоть сколько-нибудь
а ведь можно задуматься
а сколько пути он может вообще
а может быть попробовать поискать путь, по которому можно припихнуть не один, а много
и так
начнется возникает такая, собственно, хитрая идея, которая ведуется масштабированию
масштабирование
вот такое вот слово, или по адресу это называется скейт
кажется, скейт гораздо круче звучит, все масштабирование, в контексте этого
философский вопрос
в зависимости от того, насколько гармоничной вам кажется речь без излишних амбицизм
мне кажется, очень гармоничное слово масштабирование вообще ни к чему я при чем
ну, шкейт и масштабирование
или как увеличение
ну, скейт, шкала, шкалирование
шкалирование потоку
следующая лекция
а в чем суть?
ну, суть очень проста
можно ее сформулировать так
давайте будем, значит, запустим метод Фордо Фолкерсона
но запустим его только по ребрам пропускной способности больше либорадной ц
ну, значит, позапускали
по каждой там, по всем путям сразу пропустили не меньше, чем ц
можно сразу больше либорадной ц плюс один, чтобы точно ноль пропустить
потом
после этого уменьшим, говорим, так, может быть, еще поменьше
давайте будем пускать ц пополам
потом ц пополам 4
чтобы это не один путь пускать, то есть пускаем, пока можем
вот, и так
ц поделить на 8, ну и так далее
и тогда 1
ну, понятно, что тут имеют место какие-то там округления в тулиную сторону, естественно
думаю, суть понятна, не будут тут писать 2 в степени, там, лом 20-то, округленное куда-нибудь
это не надо
вот такая вот идея
внимание, вопрос
а за какую же ассимптотику это будет работать?
логарифм ц шагов, на каждом шаге сейчас оттянем быстренько
ну да, логарифм ц шагов
ну вот
ну вот
ну вот
и на каждом шаге сколько-то DFS
и DFS работают за сколько?
за E
внимание, вопрос
а сколько на каждом шаге будет DFS?
не больше, чем
что-то типа D
для того чтобы это понять
мы с вами сделаем следующее
а давайте поймем
вот вы сделали только что
итерацию на C поделить 2 в степени
а внимание, вопрос
а сколько вообще потока осталось пихать?
каков максимальный поток в остаточной сети?
DFS, например, на следующую
ну не больше, чем DFS на 2 вкаток
это неправда
есть одна маленькая подлятка
мы сделали эту операцию
верно только одно
что нет пути из S в T
в котором каждое ребро, профессиональное способство имеет вот такое
но сами по себе большие ребра вполне могли остаться
поэтому
уже имеющимся на образах
идею о том, что давайте посмотрим ребра из S
надо модифицировать
у нас есть разрез
у нас есть разрез
раз мы знаем, что мы не можем по ребрам с такими способностями дойти из S в T
а давайте посмотрим, как всегда, а куда можем
вот, до куда шли-шли-шли и вот разрез
и давайте оценим пропускную способность этого разреза
то есть тут торчат какие-то ребра
к сожалению их максимальный
да
значит, на каждом из них написано что-то меньшее, чем C делить на 2 в степени K
ну по определению
а мы сейчас не идем по ребрам меньше в какую-то величину
меньше
мы только что пытались идти по ребрам не меньше, чем C делить на 2 в степени K
и вот в какой-то момент обнаружили, что из S до T дойти нельзя
вот S где-то здесь, T вот там где-то там
вот, и мы изучаем пропускную способность разреза
ну она, как бы, что такое, напомните, пропускная способность разреза
да
да
но ребра, которые у нас пересекают этот разрез, не более чем E
и пропускная способность каждого из них меньше, чем C делить на 2 в степени K
следовательно, у нас тут ERC делить на 2 в степени K
это размер, это верхняя оценка на максимальный поток в этой остаточной сети
ну теперь интересный факт
теперь мы думаем, а вот когда, вот у нас на следующей итерации, мы будем искать потоки, то есть каждый DFS найдет путь
то есть по которому можно протолкнуть хотя бы C делить на 2 в степени K, а минус этим
внимание, вопрос
сколько раз это может произойти?
2E, максимально
да, совершенно верно
то есть если у нас поток всего не более, чем вот 100, а на каждом шаге пропихиваем как минимум 100, то получается 2E
то есть мы доказали следующую терему
что на каждой итерации успешных DFS будет не более, чем 2E
ну, в смысле, от E
ну, смотри, она получается с точкой E квадратно ловится
да, совершенно верно
совершенно верно
действительно возникает
E квадрат лог C
а можно еще раз объяснить, откуда это?
у нас каждый DFS заод Е, на каждой итерации от Е DFS, а итерации лог C
перемножим
вот так и выглядит от
почему на каждой итерации от Е?
значит, смотрите еще раз
потому что после того, как мы сделали итерацию номер K
осталось нам пропихнуть вообще потока
не более, чем вот 100
причем, но когда мы будем делать эту K плюс первую итерацию
когда мы будем делать следующую операцию
то есть получается каждый успешный DFS будет пропихивать поток от хотя бы 100
но так как нам осталось не более, чем вот 100
то получается, что больше, чем 2E раз мы, собственно, ничего не сделаем
следовательно, каждая итерация DFS в 2E
или меньше
это же строгая
наверное, даже точно меньше, потому что тут только такая строгая
так что вот такая вот разминка
а
то есть чем это отличается?
то есть мы идем по большим ребрам DFS?
да
а потом по ребрам в 2 раза меньше
а потом по ребрам в 4 раза меньше
ну не меньше
если мы вот тут встретим большие ребра, то мы по ним тоже идем
ну да, в смысле
по маленьким находим
оригинальный сколько работал? 1,25?
да
Edmunds Card?
да
ну просто DFS
нам не важно, что DFS или PFS
если E примерно В, то это работает быстрее всех предыдущих, которые мы начали
да
ну можно еще просто поверить, что крайне редко, наверное, C будет больше, чем 2 в степени У
так что есть подозрение, что это чем получше
можно еще раз быстренько проведаться по оси
значит, количество итераций лог-C
каждый DFS работает за E
и на каждой итерации DFS-ов 2E
максимум
почему?
потому что мы хотим сейчас сделать K плюс первую итерацию
значит, мы перед этим сделали K
и привело это нас к тому, что на любом пути от S до T найдется ребро плюсовой способности меньше, чем цифли на 2 степени K
да
вот
я утверждаю, что в этом случае максимальный поток, который мы можем сейчас еще нам осталось пустить в остаточной сети
он меньше, чем EC поделить на 2 степени K
но если мы сейчас в это поверим, то тогда из этого будет следует, что на следующей итерации больше чем 2E DFS-ов не будет
не будет
сейчас
привариваем
а мы сначала по большим ребрам идем?
сначала по большим
это важно
раньше наш DFS что искал?
он искал любой путь из S в T
не нулевой
сейчас наш первый DFS будет искать только пути, у которых минимум на пути хотя бы C
нашли все такие пути, все их заполнили сразу по C потока
но не аккуратно все пути
согласен, не аккуратно
какого? размер большого?
мы переходим к следующему
увеличаем нижнюю границу в 2 раза и делаем 2
мы продолжаем DFS или просто с самого начала?
не, не продолжаем заново
лод абсолютно отдельно друг от друга итерации фонической
получается вот поэтому DFS лод
если мы поверим, что там остался поток и стока, то с такой нижней границы DFS-ов будет не более чем 2E
а, ну да
ну и все
откуда взялась эта граница на поток?
ну потому что, как всегда, предположим, что мы от S до T по вот таким ребрам дойти не можем
ну как всегда, рассмотрим разрез, в котором в доле S будет написано, а докуда он может
и рассмотрим пропсуя способность этого разреза
ну через этот разрез проходит не более чем G ребр, в каждом из которых пропсуя способность меньше, чем C поддеть на 2 степени
так что нашелся разрез, ну такой значит максимальный поток не больше
у нас, кстати, был максимальный поток, минимальный разрез, вот такое
мы это называем теремой форда полкерсона
да
терема форда полкерсона, это терема степотворительности 3 по 34
я вроде не могу
ладно, не разрез, это следует
тем более, чтобы доказать, что оно участвует так или иначе
так что это для нас важно
вот
но это если даже просто DF запускать
а что делать, если
если, ну вот, а что делать, если запускать
вот, например, алгоритм Динница
а можно в E-Log ценовить, смотри
это для нас не дарит
а, да, это для нас не дарит
это для нас не дарит
а, это у нас все равно в E-Log, да?
да, у нас лучше, ну в каком-то смысле
хотя, если все равно идти, а в E-Log ценовить откуда?
я вроде помню
ну да, вот у меня тоже безобразие, честно говоря
что-то Динец влаштадируем сам по себе откуда-то в E-Log ценовить
вот
но, попробуем вот что
на самом деле вот
начнем, потому что, конечно, у целочисленных сетей
есть такое принятное, такое подмножество сетей как
единичные сети
наши любимые единичные сети
кстати, мы вот здесь уже рассматриваем
то, что у нас, ну, трудностные особенности в назначаемом графике
пока мы еще не меняем
ну, да
конечно, забавно, что в некоторых случаях прописные способности могут становиться и 20 при желании
ну, если они не ориентированы
честно
но это равно лакомит
вот
а, ну, кстати, да
Ладно, вот еще Тихон спрашивал на прошлый паре, вот можем попробовать
это вот мы говорим, если у нас сети целые, да?
а что делать, если у нас прописные способности не целые?
нет, насовировать до последнего бита
нет, ну, может быть
ну, она же всегда просто вытескает по ГС
ну, где-то может быть погрешить, но с другой стороны, даже если предположить, что у нас все идеально точно
потому что мы, например, работаем в рациональных числах
по-моему, синтетика будет начинать от этого зависеть
ну
а если мы же поверим, что там
еще и заузеницы работают, да?
поверили
так я вам и поверил
нет, ну, если мы, да
нет, это, конечно, можно об этом думать, но если мы это, как всегда, поверим
часто в это верим, то можно действительно заметить следующее
что после того, как вы сделали
то есть вы сделали
значит, после того, как вы сделали
итерацию цепы длиной 20 степеника
то, что вы нашли, то есть вот размер потока
он больше либо равен, чем
размер, чем
размер оптимального потока
минус
ес поделить на 2 степени к, как вы только что увидели
поэтому, в принципе, вам все, что вам нужно
это, на самом деле, добиться того, чтобы
вот эта вот штука была достаточно малой долей
вот этого
и в результате у вас там получится какая-то
даже какая-то ассердочка
ну, там, правда, она будет зависеть от оптимального потока
ну, соответственно
ну вот
так что, соответственно, можно ее даже посчитать
что-то мне хочется
вот
давайте поговорим об единичных
теперь давайте представим, что у нас все
способности единичны
чем это приятно?
особенно если граф ориентирован
если граф ориентирован, то это приятно тем, что у нас
то у нас тогда достаточно степень тоже всегда будет единичный
ну, потому что, когда мы пропускаем поток по единичному ребру
оно убивается, появляется обратное ребро в способности 1
но это так ориентированно
если ориентированно, рассматривать как ориентированно
это не страшно
ну, да
так как мы не живем в матрице с межностью, то нам не принципиально
а теперь давайте представим себе
что мы в этой
ну, понятно, что
ну, вот
ну, то есть понятно, что кажется не теперь
вот в такой ситуации
время рабочее
время поиска поток
ну, и вот
вот
вот
вот
вот
вот
ну, а если мы ставим, конечно, методом форда Фолкерсона
то теперь его можно оценить как модуль f на
степени стока
ну, или степени стока
почему?
да
вот так
да, да
а почему у нас е появляется?
dfs
пока?
да
а теперь давайте представим
что мы запускаем алгоритм Деница
корень вывели?
ну, не сказка
сначала давайте вспомним, откуда он вообще взял
вообще какая там ассимптотика
там была ассимптотика
смотрите
v на ve
dv это количество фаз, то есть это вот
а ve это, так сказать, обработка одной фазы
поиск потери еще
но это в общем случае
а теперь давайте посмотрим, что поменяется в анализе Деница, если
соответственно все ребра единицы
соответственно все ребра единицы
вот давайте, что поменяется в анализе поиска плотирующего поток?
он вычтет, где не работает
а почему?
когда путь находит, он целиком удаляется
да, совершенно верно, то есть обратите внимание, что
когда у нас есть единичный краф, то когда мы найдем какой-то путь, удалится не одно какое-то ребро, а просто сразу все
поэтому получается, что пропуск этого пути можно упихать в е удаленное
и тогда получается, что одна фаза в единичной сети будет работать за у от е
ну а если бы там были пропускные способности какие-то с, то за ец
вот теперь начинается самое интересное
а можно ли как-то улучшить оценку на количество фаз?
да, разрешаю
ответил особый вопрос
ну вдруг там очень-очень-очень много кратных единичных ребят
вот
но
значит есть вместитель Оно
но я утверждаю следующее, что в единичной сети
количество фаз будет тут не больше чем в, а здесь будет не больше чем
или нет?
два
уничтожение просто
а после из в?
или е?
в общем случае пока из е
из в будет когда выяснится, что там нельзя через вершину протопнуть больше, чем один
это важно
а в общем случае кое-не из е
значит как-то все работает
ну тут я конечно немножко спалил, но работает это давайте подумаем
давайте сейчас сразу попробуем в общем случае применить анализ, который мы говорили
итак
введем
мистический бубен
который мы берем позже
а пригодится нам все это
давайте лучше сразу вводить бубен
и говорим
давайте сделаем бубен от итерации блокирующего потока
в чем нам сейчас даже плевать Диницет, Алсотра, может быть Хишвари или там любой другой атерит
вот сделаем бубен итерации
внимание, вопрос
каков у нас останется максимальный поток в остаточной сети после бубен итерации?
ну каждый путь после этого хотя бы к, бла-бла-бла
то есть давайте посмотрим, что у нас представляет собой остаточная сеть после бубен итерации
ну вот это, произвольная единичная сеть, только с мелким ограничением
расстояние от СДТ больше, чем бубен
давайте представим себе этот максимальный поток по остаточной сети
и декомпозируем его на пути
ну естественно мы имеем в виду, что он будет состоять только из единичной
и давайте себе представим
тогда когда мы его декомпозируем, мы заметим, что путь может проходить
только по каждому ребру проходит не более чем один путь
потому что у нас единичная сеть
ну правда заметим, что тут всякое может быть
нормальные герои могут как угодно идти в обход
но размер потока это количество этих путей
значит каждый из этих путей
на каждом из этих путей больше, чем бубен ребер
а всего ребер е
то не более, чем е
тогда это означает, что размер этого оставшегося потока не превосходит
ну сколько получается?
е поделить на бубен
понимаете, да?
да, нет, наверное
но тогда из этого следует, что так как оставшийся поток будет таким
то мы вынуждены заключить, что количество фаз ось комплокирующего потока
будет тоже не более, чем столько
потому что каждая фаза, кроме последней, неудачной
она нам хотя бы одну единицу из этого найдет
то есть таким образом мы можем оценить, что время количества фаз у нас не превосходит
бубен плюс е поделить на бубен
уже сразу было понятно, какой конкретно бубен мы возьмем
откуда, собственно, два корня е?
а почему f будет меньше, чем е делить на бубен?
ну потому что мы рассмотрели остаточную сеть
рассмотрели максимальный поток в ней
ну какой-то он там какой-то будет
и декомпозировали его на единичные пути
по каждому реберу проходит не более, чем один путь
но на каждом пути больше, чем бубен
потому что мы это делаем после бубен итерации
это значит, что расстояние от СДТ больше, чем бубен
почему мы точно будем декомпозировать?
у нас же может быть один путь, который в одну сторону проходит, а в другую обратно
почему у нас декомпозиция не может получить короткого пути?
потому что у нас не может получить короткого пути
это что, интригенды?
а полегаем вот это туда-сюда?
ну во-первых, эту циркуляцию можно отменить
да, есть теория, что любой поток можно декомпозировать до пути
и циклы
нет, любой поток декомпозировать до пути просто неверно
любой поток из СДТ или как это называется?
просто любой поток
да, любой корректный поток
просто входящий, выходящий
можно декомпозировать по всей аксиоматике
можно декомпозировать именно на пути циклы
любой цикл можно отменить
в любом случае, если случайно граф неориентированный
и у вас случайно что-то не то получилось
хотя непонятно как
ориентированным это проблема не будет сразу
если в эту сторону ребро изначально
и в эту сторону, то это будут два незамеченных ребра
и пусть поток течет и туда, и туда
и пусть потоки все равно можно отменить
не суть важна
мне все еще не очевидно, почему у нас
какой-то путь нечаянно не может оказаться короче, чем будет
у нас была тарема о том, что в новой сети с...
как это называется?
в каждой новой слоистой сети
да, в каждой новой слоистой сети нет короткого пути
у нас была тарема остаточная сеть
остаточная
да, мы этот поток еще именно в остаточной сети
но расстояние от СДТ у нас после каждой фазы строго увеличивается
но мы же больше
больше что?
нет, нет, я алгоритм спрашиваю
я бы хотел понять, почему мы смогли так оценить остаточный поток
потому что у нас потоки декомпатируются на пути циклы
пути не пересекаются по рюмкам
это важно
и на каждом из этих путей и каждый путь захватывает бубенгами
если они не пересекаются по рюмкам
не пересекаются, а у нас единичная сеть
нет смысле
наверное ускоряешься, просто у нас вот ребра, которые через уровень они не могут никогда перестать доступным
если они часто не доступны
верно ли, что слоистой сети есть максимальный поток
совпадающий с максимальным потоком всего этого
не обязательно
но я не оцениваю максимальный поток слоистой сети
я оцениваю просто
я сделал бубен и это раз единица он пустил какой-то поток
или единица неважно
у меня какая-то остаточная сеть
я в этой сети рассматриваю реально максимально поток
Просто абстрактно рассматриваем. Не ищем, просто рассматриваем.
Просто рассматриваем, да. Рассмотрим какой-нибудь максимальный поток.
Утверждение. Ну вот.
Утверждение. Его можно декомпозировать на пути.
И все эти пути будут вины больше, чем boobin.
А, они будут больше, чем boobin? Потому что если бы был хотя бы один меньше, чем boobin, то он бы был в...
То есть сейчас состояние застепа было бы...
Что было бы что?
Минимальный... Минимальный путь застеп был бы в своей стейсите тоже.
В нашей текущей.
Да. А в нашей стейсите...
Почему?
Он минимальной длины.
И?
Значит, он такой будет в BFS.
Сейчас. Может какой-то из ребров его сейчас, но сейчас насыщенно. В смысле...
Нет. Мы сейчас...
Ну, ничего.
Не понял.
Почему насыщенные ребры?
Мы в ресторане всегда ищем поненасыщенные ребры.
И слоистые сети всегда строили только на ненасыщенных ребрах.
Утверждение про то, что в итоговой декомпозиции не будет путей boobin, не очевидно.
Нет.
В смысле...
Тогда у меня возникает вопрос, почему в алгоритме динеца мы вообще поверили, что на каждой...
Что в следующей слоистой сети не будет пути, короче.
А какая разница?
Слоистая сеть строится на основе BFS.
Расстояние СДТ там такое же, как было на момент построения этой сети.
Когда мы говорим, что ищем поток высоса сети, мы говорим, что мы вообще забываем про ребра, которые сейчас насыщены?
Или, конечно, там как бы...
Нет.
Ну, когда мы строим BFS, мы забываем о них.
Ну, просто почему высоса сети может быть, ну, такая, как бы, на пути, что у нас затрагивается ребро, которое сейчас насыщено.
Потому что там другую, во правду, сторону тоже проходит.
Но оно тогда может быть вот тем, который сокращает путь.
Проблема какая-то такая.
Нет, пожалуйста.
Нет, тогда эта проблема просто у вас отсылка к вопросу по предыдущей лекции.
Потому что сейчас как бы ответ на этот вопрос такой.
У нас была теорема о том, что перед, на каждой очередной итерации поиска блокирующего потока, расстояние от СДТ строго увеличивается.
Это понятно.
Все, если вам это понятно, то здесь тогда вопросов быть не должно.
Они есть.
Они есть.
А что, потому что они...
У нас путь из декомпозиции, он не будет пучом какого-то конкретного, какой-то конкретный, это раз.
Ребра из разных итераций.
И что?
Мы доказали.
Значит, перед первой итерацией расстояние от СДТ было как минимум 1.
Да.
Перед второй как минимум 2.
Да.
Перед третьей как минимум 3.
Расстояние от СДТ вы всегда называете расстояние в остаточной сети.
Ну да.
Именно в остаточной сети и именно по ненасыщенной бревне.
Хорошо, да.
Вот, и тогда.
После, после бубен итерации расстояние от СДТ будет как минимум b плюс 1.
Да.
Следовательно, когда я в этой остаточной сети, в которой расстояние от СДТ больше чем b плюс 1,
а каждая, ну вот, рассмотрю декомпозицию на пути, то каждая из этих путей будет длинной...
Сейчас, мы остаточную сеть рассматриваем просто как независимый граф.
Ну да.
Остаточная сеть...
Декомпозиция на пути не...
Сейчас, если возьмем какой-то граф, забудем про существование общей остаточной сети, возьмем какой-то граф,
то в нем существует множество путей.
Именно в нем, не в его сети с учетом обратных ревер, просто в каком-то ориентированном графе
существует разбиение на пути равное максимальном потоку.
Ну, в смысле, не разбиение на пути, а просто декомпозиция на пути.
Ну хорошо.
И теперь мы разворачиваем остаточную сеть как независимый граф.
Ну, вроде да. Вроде нормально.
Ну, это важно. Давайте еще раз поговорим, что да.
Мы сейчас рассматриваем именно остаточную сеть после бубен итерации.
И максимальный поток, вот этот поток, это вот максимальный поток именно в этой остаточной сети.
Ну, потому что как бы максимальный поток в исходной сети, да,
это будет тот поток, который мы уже за бубен итерации пропихнули,
плюс максимальный поток, который там в остаточной сети остался.
Да. Ну, это вот.
Такая да. Выглядит как умная мысль, на самом деле нет.
Вот. Вот и все.
Ну вот. И поэтому мы рассматриваем, какой у нас максимальный поток именно в остаточной сети,
и у нас получается вот такая оценка за счет того, что расстояние от s2t в ней больше, чем в пути.
То есть каждый пути композиции больше, чем в пути.
Нет, хотел бы сейчас надо уложить, потому что сейчас дальше эта идея будет применяться в усиленной версии.
Вот.
Итак.
Ну, значит, соответственно, то есть как мы уже сейчас поняли,
значит, тогда у нас сразу получается, что фаз будет не более, чем два корня из E,
и каждый ряд ищется за E, то получается, что в единичной сети на самом деле
Динец.
Вот конкретно алгоритм Динеца сработает за E корня из E.
Вот конкретно алгоритм Динеца в том плане, что конкретно алгоритм Динеца вам блокирующий поток завод не дойдет.
Понятно?
Да.
Вот. Класс.
Вот.
Что?
А что такое губин плюс E деликат на губин?
Не.
Мы сказали, что вот сделаем губин итерацией и рассмотрим сколько осталось.
Осталось итерации, как мы выяснились, E поделить на губин.
Потому что у нас GB осталось не более, чем E поделить на губин.
Следовательно, количество итераций — то есть для любого губин, верно, что количество итераций не более, чем губин плюс E поделить на губин.
Остается только выбрать оптимальный губин, который в данном случае будет более низ E,
и получить, что вот можно вычить отсетку 2 корня из E.
А boobin... А, в смысле, это на...
Можем в любой момент выбрать чему район boobin. Это просто теоретические изменения.
Почему boobin? Почему ездили на boobin? Это понятно. А boobin?
Boobin это количество фаз, которые мы сделали перед этим.
Ведь за счет чего у нас расстояние от s до t больше, чем boobin?
Это количество запусков DFS, которые мы делали?
Нет, количество итераций блокирующего потока.
Внутри блокирующего потока DFS могло быть много.
Но они суммарно за блоке работают, но и другой вопрос.
Почему там просто boobin?
Потому что мы сейчас оцениваем не асимпторику, мы оцениваем количество фаз блокирующего потока.
Именно фаз.
А потом будем оценивать, чтобы асимпторика это количество фаз блокирующего потока
на сколько времени мы в каждую фазу делаем.
В классическом алгоритме Диница мы делаем фаз не более чем v,
потому что расстояние бывает только от 1 до v.
И каждую фазу делали за ve.
Сейчас же мы ухитрились доказать, что фаз в единичной сети 2 корень из e.
Ну если boobin поставить...
Правил boobin корень из e.
А одна фаза e это...
Ну там за счет того, что конкретно в алгоритме Диница выясняется,
когда у вас за сколько работает.
У вас работает на самом деле за ve, за e на 10 плюс e время удаления ребер,
а удаляем мы ребра за o от e суммарно.
А здесь теперь заметим следующее, что на самом деле теперь у нас просто эта часть исчезла,
потому что когда вы нашли путь от s до t, вы убиваете не одно ребро, а все сразу.
То есть по сути вы можете, когда продолкнули поток,
вы убили просто сразу все ребра и получается тоже упихнуть в те же самые неудаленные.
То есть нам даже не надо модифицировать алгоритм, чтобы у нас только количество этих раций.
Да, в том-то и фишка, да.
То есть он сам так делает.
Так, давайте это поймем.
Ну просто смотрите, откуда там бралось ve?
В e там бралось...
То есть e на 10 у нас всегда не больше, чем v.
Нет, это не то.
Ну то там o от e, потому что e на 10 плюс e.
Да, правильно.
Но теперь этот e на 10, теперь этого слагаемого нет.
Откуда бралось e на 10?
Откуда бралось e на 10?
Потому что вы за o от d, значит, пробихивали поток по пути.
И мы знали, что хотя бы одно ребро убьется, поэтому суммарно таких пропусканий будет не более чем e.
А теперь оценка меняется.
Потому что теперь мы говорим, что убьется не одно ребро, а убьется все сразу.
Поэтому по сути можно сказать, что этого слагаемого нет,
а на самом деле у вас есть только время удаления всех ребр.
Все.
Все, понятно.
То есть даже менять реализацию даже не надо,
потому что по сути это будет проходить просто, что вы пришли в вершину,
вы говорите, так, у меня активное ребро вот это,
ой, оно убилось, ладно, пошли дальше.
Но в сути это не поменяем.
А, это когда мы оптимизировали DFS?
Да даже не оптимизированный любой.
Какая разница?
А, да.
В исходном-то тоже, на самом деле, могли даже так.
Но самое главное, когда нашли этот путь,
нашли какую-то минимальную пропускную способность,
можете пропустить и пропускаете.
Не обязательно там какое-то убитое ребро прямо сейчас убивать.
То есть потом, когда следующий DFS придет в эту вершину,
он это ребро просто убьет сразу.
Просто первое, что делает, это убьет это ребро.
Но поэтому прямо сейчас можно не заморачиваться.
Вот такая вот красота.
Вот.
Так, еще вопросы по этой части?
А, это окончательная симпточка?
Да.
В общем, в данном случае можно достаточно легко даже попроводить всякие примеры.
Там, не знаю, это когда, там, попроводить примеры,
когда, когда, когда симпточка конкретно алгоритма 1 реально будет такой.
Ну просто е распределить так, чтобы у вас там были пути не длины 1, и длины 2, и длины 3 и так далее.
Тогда как ассоц курии будет.
Так что эта симпточка точная.
Но теперь уже, если говорить о,
вернуться к задаче по рассочетанию,
одно из классических применений единичных сетей.
Вот.
То возникает, конечно, мистический, знаете, умный алгоритм Хобкрофта-Карпа.
Вот наш два автора.
Вот.
Да, и ровно столько же слов на описание этого алгоритма.
Запускаем.
Да.
Самый смешной, что да.
Ну, на самом деле, я вас, конечно, подразумеваю, что алгоритм заключает в том,
что давайте построим сеть.
Ну, как мы в прошлый раз делали.
Ну, в общем, получается.
Когда в дудольном графе построить сеть, в общем-то, семер вариантов тут особо не возникает.
Давайте это сделаем.
Ну, то есть напомним, да, что есть у вас вот какая-то вот такая вот.
Такой вот граф какой-нибудь вот этот вот, да.
То, что мы делаем.
То, мы тут строим, как всегда, строим с, строим т.
Вот.
Соединяем так, все ребра ориентируем вправо.
И все пишем, что это один.
Ну, чтобы и по ребру, чтобы как бы ребро каждое, там по ребру поток приходил только один.
Ну, вы помните, еще в прошлый раз обсуждали.
Да и просто, да и просто.
Ну, вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
И что же у нас получается?
А получается примерно следующее.
Да, везде.
И теперь давайте запустим тут динеца.
Там алгоритм Хопкорфта как-то построим, вот такую сеть и запустим, где алгоритм динеца.
Но есть еще маленькая новинка, да.
Мы уже доказали, что тогда мы это просочетание найдем за Екарния из В.
Екарния из В.
Ну, это мы уже только что доказали.
Да.
Но на самом деле я утверждаю, что конкретно в данном случае можно уточнить оценочку и сказать, что Екарния из В.
Круто.
Круто.
Да.
Откуда же тут Екарния из В берется?
За каждой вершинкой небольшой один поток.
Да, в общем-то оттуда же.
Ведь смотрите какая интересная идея.
Ну, то есть логика та же.
Ну, начало логики та же.
То есть сделаем корень из В итерации.
То есть бубер равен корень из В, так?
И у нас получается какие-то декомпозиции.
Но теперь очень интересный факт, смотрите.
Ведь если внимательно посмотреть на исходную сеть, то можно заметить, что в каждой вершину либо входит ровно одно ребро, либо исходит ровно одно ребро.
Видите, да?
Заметим, что на каждом восстаточной сети, скажем, в эту вершину, все будет так же.
То есть в нее в каждый момент времени будет входить ровно одно ненасыщенное ребро.
Ну, просто действительно, если вы протолкнете через нее какой-то поток, то тогда что получится?
То есть тут получится какая-то единичка, допустим, единичка-единичка, да?
То есть тогда эти ребра убьются, но появятся обратные.
Теперь вот.
Появятся обратные.
И тогда получается все равно, как входило ровно одно ребро, так и будет входить ровно одно ребро.
Вот, понимаете, да?
Вот.
Но тогда из этого следует, что когда мы будем рассматривать...
Но тогда из этого следует, что если вы рассмотрите в подобного рода сети максимальный поток и декомпозируете его на пути, то на этот раз вот в такой ситуации пути будут не пересекаться не только по ребрам, но еще и по вершинам.
Вот.
Но вершин-то у нас, то есть получается...
Но получается каждый путь у нас длинный и больше, чем корень ESW, значит вот этих вот промежуточных вершин будет больше либо равно, чем корень ESW.
Откуда мы и заключаем, что останется фаз не более, чем корень ESW.
Так что отсюда получается, что вот у нас...
Оказывается, мы теперь умеем искать про сочетание, а жно зовут такую оседотику.
В принципе, вот красиво.
Можно еще раз?
Еще раз?
Да.
Ну, утверждение.
Делаем корень ESW итерации, да?
Да.
После этого у нас останется какая-то остаточная сеть.
Найдем в ней максимальный поток опять же, той же самой остаточной сети.
Декомпозируем поток на пути.
Эти планотки пути не будут пересекаться не только по ребрам, но и по вершинам.
Тогда и на каждом пути будет как минимум корень ESW своих вершин.
Ну, всего-то вершин В.
На каждом пути не более корень ESW.
Как не менее.
То есть, корень ESW, корень ESW, корень ESW, корень ESW, корень ESW.
На каждом пути не более корень ESW.
Как не менее.
Корень ESW вершин.
Причем, так сказать, своих для каждого пути.
Мы уже сделали первые корень ESW стадии, теперь у нас все пути, хотя, ну, больше равные, чем корень ESW.
Ну вот.
Так же, как в предыдущей, только теперь пути не вертоклеры, а вершины не пересекаются.
Вершины не пересекаются.
Так что, да, вот такая красота.
У тебя теперь корни ESW.
Это, как это, это умный алгоритм Ховкрофта.
Не знаю, была ли посвящена этому алгоритму прям отдельная статья.
Хотя, ну, хотя на две странички, в принципе, помогало.
Уровень заметка.
Ну ладно.
А теперь дальше.
У нас там было E делить на B, а тут у нас получается B делить на корень ESW.
А здесь? Ну там просто будет просто B.
То есть, теперь мы В поделить на B.
Ну потому что раньше мы покрывали ребра.
То есть, каждое ребро покрыто своим путем.
Ну вот, поэтому там и каждый путь покрывал там B, E, поэтому E поделить на B.
А теперь мы покрываем вершины.
Поэтому там будет B плюс V поделить на B.
Так что вот такой вот будет.
Ну вот.
Но здесь, оказывается, и это еще не все.
Не, не в смысле ассимптотики, лучше не будет.
Ну вот.
Но товарищ умник тем не менее усеклется и тут называется предложить веселую интересность.
Представьте, задачка.
Миллион вершин, два миллиона вершин.
Найдите, пожалуйста, максимальное просочетание.
Найдите и предъявите его.
Да.
Ну как максимальное?
Ответ будет признан правильным, если размер предложенного вами просочетания будет не менее чем 95.
Ответ будет признан правильным, если размер предложенного вами просочетания будет не менее чем 95 процентов от правильного.
А, ну то есть не точно.
Да.
Ну, можно сказать, что мы вначале будем очень быстро набирать нас.
Вот, да.
А насколько быстро?
В идее правильно.
А теперь давайте...
Какая еще раз идея?
Ну, пока идея такая вот.
Возникает что-то жуткое ощущение, что, скорее всего, на первых фазах, наверное, большая часть просочетания будет набрана.
Осталось только точно оценить, насколько быстро выбирается.
А теперь вот давайте внимательно на это посмотрим.
Вот давайте опять представим, что мы сделали Бубен и Тарас.
Вот опять Бубен.
А набираем, в смысле, просто жадно?
Рандомно берем пары?
Нет, ну, как это алгоритм делится, да?
Он строит слоистую сеть и как-то там ищет пути.
Как конкретно он их ищет, он зависит, наверное, от порядка игры.
Не, у нас же просто дан общий граф, да?
Ну, сейчас дан конкретный, да.
Не, у нас задача дан граф общего вида или обязательно двудольный?
Нет, двудольный.
Нет, двудольный.
Нет, двудольный.
Не, не, не, не настолько.
Вот, значит, Бубен.
Как тут Бубен?
Это мы сделали первые Бубен и Тарасы.
Да, вот представь себе.
Да, построили у двудольного графа вот такую сеть, запустили Диница, сделали у Диница Бубен и Тарас.
Итарация.
Значит, что же такое?
Значит, теперь давайте посмотрим на это все внимательнее.
Значит, как у нас устроены после Бубен итерации, ну, как устроен этот поток?
Ну, поток у нас это опять что-то, то есть какие-то вот эти вот пути, да?
Ну, поток оставшийся декабодируется на пути, да?
А теперь смотрите вот что.
Как устроен этот путь?
Ведь смотрите, в каждый момент времени, если проигнорировать, то есть в каждый момент времени, на самом деле, каждый поток символизирует какое-то парасочетание, правда?
И у нас, у каждой ребро, либо ребро включено сейчас в парасочетании, и тогда у нас в остаточной сети живет обратное, либо не включено, и тогда у нас в сети живет вот это ребро, да?
Так.
Теперь смотрите.
А теперь давайте подумаем, как устроен любой путь из С в Т?
Ну, он устроен очень просто.
Значит, заметим, что, ну, устроить он тут не сильно много вариантов, так как мы в С не входим, а в Т уже не выходим, ага, в двудольные, то на самом деле заметим, что любой путь будет устроен вот таким вот нехитрым образом.
Ну, да, в терминах алгоритма Куна это удвиняющая цикл, да?
Вот.
Вот такая рация.
Ну, теперь заметим вот что.
На самом деле, заметим, что в каждый момент времени, ну, то есть мы можем вот этот оставшийся после Губбина итерации путь, то есть оставшийся поток декомпозировать на пути, которые вот по ребрам и по вершинам не пересекутся.
Внимательно.
Ну, теперь рассмотрим каждый такой путь.
Вот у нас один, вот каждый по каждому такому пути мы можем протолкнуть только единицу потока, да?
Ну, теперь заметим следующее.
Заметим, что вот эти ребра в просочетании не участвуют, а вот эти, точнее их напарники участвуют. Видите, да?
Ну, которые вот идут справа-налево.
То есть вот правильно их, конечно, выше не нарисовать.
А что значит участвуют или не участвуют?
Ну, вот как я выше сказал.
Какой бы я тут поток в этой сети не запустил, да, то есть если у нас по этому ребру поток течет, то это как бы символизирует, что оно участвует в просочетании.
А в остаточной сети его представляет вот режим напарника.
А если по ребру поток не течет, то тогда это просто вот ребро слева-направо, оно представляет в остаточной сети слово сияется.
Ну, тогда получается, смотрите, какая ситуация.
То есть у нас получается, каждая единица потока в этой его, в оставшейся сети, в оставшейся остаточной сети, так сказать,
у нас каждая единица потока вот соответствует какой-то набор рыжих ребер.
И этих рыжих ребер у вас больше либо равно, чем будем.
Ну, давай.
Ну, тут, да, все тут пути еще нечетные, да, на самом деле тут не 1, 2, 3, 4, 5, а на самом деле 3, 5, 7, 9 и так далее.
Это поток в сети после губер-интерации.
После губер-интерации рассматриваем максимальный поток, и каждая единица потока соответствует вот такой вот губер.
То есть получается, если у нас было, соответственно, f губер, то есть это сколько мы нашли за губер-интерацией, да?
Ну, смотрите, тут, видите, в этом граф специфический, там он так устроен, что изначально кричащий путь не меньше, чем 3, потом не меньше, чем 5, потом не меньше, чем 7 и так далее.
Поэтому, да.
Или можно говорить, что вот таких ребер, или в переводе говорят, то есть одно такое, одно такое, и тут вот таких ребер не меньше, чем 0, не меньше, чем одно и так далее.
Ну, после губер-интерации не меньше, чем будем.
То есть получается, у нас есть поток f губер, то есть это просочетание, которое мы нашли до этого.
И потом у нас и есть еще f оставший.
Но заметьте, что количество рыжих ребер сейчас, да, после губер-интерации, это в точности f от губер, правда?
И тогда получается интересный факт, что f оставшиеся получается меньше либо равно f губер поделить, да?
То есть у нас, оказывается, то, что мы нашли раньше, то есть то, что мы нашли раньше за губер-интерацией, это хотя бы в губер-интерации раз больше, чем то, что нам осталось.
Ну, теперь все, что нам остается, это прибавить к этому неравенству с двух сторон f губер.
Вот здесь и здесь.
Тогда во что это превратится? f губер плюс f оста, это просто максимальное просочетание, оно же размер максимального потока, да?
То есть f просто.
И это будет меньше либо равно f губер.
f губер умножить на, соответственно, губер плюс один поделить на губер.
Ну, или что то же самое, f губер, то есть после губер-интерации мы сделаем больше либо равно, чем губер поделить на губер плюс один f.
Вот такой интересный факт.
Который я, собственно, и называю Теремонидомирюка.
19 итераций.
Да, то есть вот авторское решение так и предполагает, давайте просто сделаем 1, но сделаем там 19 итераций ДМС.
То есть не сколько там реально надо, а 19. Ну, или там меньше.
Вот так.
И тогда действительно оказывается, за 19 итераций мы найдем не менее чем 19,20 от максимального размера протокина.
Так что вот это называется Теремонидомирюка.
А можно еще раз повторить, что это за зигзак?
Мы сказали, что любой путь, представим, где ты входишь из стока в левую долю, входишь вот между ними и выходишь обратно.
Ну, у нас все ребра.
Это понятно.
Вот, и тогда получается любой путь из СТ, достаточно из сети, он выглядит вот таким зигзаком.
Теперь почему я тут рисую именно вот такие же ребра?
Потому что замечаем, что изначально все ребра смотрели слева направо.
И у нас тогда, а потом в процессе у нас либо по ребру не пошел поток, и тогда это ребро так и смотрит слева направо,
либо по ребру пошел поток, тогда этого ребра нет, но у него есть рыжий напашник, который смотрит справа налево.
И это единственный способ, как справа налево ребра могли получиться.
Поэтому я этот зигзак рисую вот именно вот таким образом.
То есть рыжие ребра – это те, по которым раньше шел поток?
Рыжие ребра – это обратные к тем, по которым реально идет поток.
Так, если вы случайно знаете, что такое алгоритм Куна...
А, вы-то пока не знаете, что это алгоритм Куна?
То есть я один не знаю, Куну до сих пор так и не помню.
А-а-а.
Затонные фазы уже прошли, уже неплохо.
Удлиняющая цепь.
Так, ну ладно, раз уж об этом зашла речь.
Ладно, давайте так можно...
Так, а вот там про Вубина.
В смысле?
Ну потому что...
Ну еще раз.
Ну потому что мы замечаем, что в каждой удлиняющей цепи, после Вубин-итерации Диница,
в каждой удлиняющей цепи будет хотя бы Вубин-рёбер из пор сочетания.
Следовательно, оставшиеся то, что нам осталось, не превосходит...
То есть основной факт на самом деле такой.
Вот это вот основной факт.
То есть то, что нам осталось, не превосходит то, что мы уже нашли, то есть количество рыжих ребер поделить нам будет.
Ну и что же мы делаем?
Вот это вот основной факт.
То есть то, что нам осталось, не превосходит то, что мы уже нашли, то есть количество рыжих ребер поделить нам будет.
Что такое фост?
То, что она...
Вот этот большевальный поток, который в остаточной сети после Вубин-итерации.
А почему как Вубин?
Нарисовали вы просто какой-то путь рандомный, который мы нашли.
Я его написал, конечно, не просто так, скорее из декомпозиции.
Вообще любой рандомный путь выглядит так.
А теперь пообразим себе декомпозицию потока этого оставшегося потока.
А и Вубин это количество или...
Нет, f-Vubin это размер потока после Вубин-итерации.
Он же количество рыжих ребер на текущий момент.
По случайному...
Рыжих ребер по всей декомпозиции.
Да, но не совсем.
Нет, не по декомпозиции, а вообще в графе.
Ну, не считая, конечно, рыжих ребер вот этих вот.
Вот эти мы не считаем, конечно.
Мы считаем только вот эту основную часть.
Можно вопрос?
Можно, не совсем понятно, почему...
Как связано f-Vubin с f-остаточным?
Ну, смотрите.
f-Vubin это количество рыжих ребер вот в этой части сети.
Да.
Логично, да?
То есть количество рыжих ребер.
А, f-Vubin это количество ребер уже на взятый поток.
То есть количество ребер взятых в расписание.
То есть количество рыжих ребер.
То есть количество обратных ребер.
Ага, все, теперь понял, да.
Ну, так получается, да.
И в каждой сети, в декомпозиции, в каждом пути будет вот Вубин своих рыжих ребер.
Так что вот такая разница.
А почему f-Vubin плюс f-оставшийся это f максимальное в изначальном графе?
Ну, потому что f-Vubin это тоже...
Вы делали Вубин-интерацией потока.
Какой-то поток вы нашли за эти Вубин-интерации, какой-то вам предстоит еще найти.
Вот мы сделали первый Вубин-интерацией.
И нашли f-Vubin поток.
Да, и у нас есть остаточная сеть текущая.
В которой максимальный поток f-остаточный.
Да, но почему максимальный поток в остаточной сети это максимальный поток в текущем графе сети?
Текущем графе сети.
Так, ну если вы даже не знаете...
Как это?
Знаете, я не умею объяснить почему травы зеленые немножко.
А, у нас есть факт, что максимальный поток в остаточной сети это максимальный поток графе?
Ну это не просто факт, это просто метод форта флукевсона как устроен.
Ну или просто пихаете-пихаете потоки, да?
Там соответственно, в каждый раз, когда вы пихаете единичный поток, в остаточной сети поток уменьшается.
Вот.
Вот.
Значит, вот соответственно.
Так что вот это была тяга будденей рука.
Так.
Денг, сколько у нас там времени-то?
Ну окей.
Ну раз уж об этом зашла речь, действительно, можно кратенько действительно обнаружить, откуда у нас при поиске просочетаний вообще берется алгоритм куна.
Ну точнее, что это вообще такое?
Ну на самом деле, действительно, заметим, что...
То есть давайте подумаем, давайте просто, ладно, хорошо, вот, его можно искатиться, но давайте себе представим, что мы ищем просочетания методом форта флукевсона.
Представим себе такое, да?
Можем такое представить, можем.
Тогда заметим, что каждый DFS, он, по сути, будет искать путь, ну вот, собственно, ровно такого вида.
Видите, да?
Но это если вот строить нот, это если прям в явном виде строить остаточную сеть.
В принципе, этот алгоритм будет работать за от VEP.
Почему за от VEP?
Потому что у каждой просочетания не более, чем у от VEP, и каждый DFS будет работать за от VEP и находить и увеличивать просочетания хотя бы на 1.
Правда?
Понимаете?
Вот.
То есть, заметим, то есть сейчас как бы для нас...
Значит, теперь поехали.
Значит, да, наша цель найти такую вот удлиняющую цель.
Ну, у нас есть терема Форда Балкерсона, который говорит, что найденное нами просочетание максимально тогда и только тогда, когда не существует вот такого вот, какого-то пути.
Да?
Но заметим, что, то есть если попытаться это переформулировать без, значит, истока истока, то тогда что у нас остается?
У нас остается путь, который начинается в вершине левой доли непокрытой просочетания.
Да, заметим же одно – что если вершина уже покрыта просочетания, то она покрыта навсегда.
То есть, там, конкретно каким ребром покрыта может меняться, но то, что она покрыта, уже сомнений не изв Release.
То есть, начинается в вершине левой доли, которая не покрыта просочетанием.
Бегает, бегает, бегает, бегает.
Причем, влево бегает по ребрам не покрытым.
в правой берет ток по ребрам из поросочетания и в итоге приходит вершина правой доли непокрытая
поросочетанием. Это вот называется удлиняющая цель. Надеюсь я никакую букву не пропустил.
Ну просто. Я сейчас не приведу то, что правила русского языка. Ну удлиняющая, ну просто
потому что слово удлинить тоже пишут с одно «m». Ну как бы удлинить, удлинить или нет, это все с одно «m» пишут.
Давайте правила русского языка потом погубим. Или по Яндекс. Яндекс может уже лучше.
А вот оригинальная алгоритма Фолкэксона немного другую вещь делает. Нет, на самом деле так. На самом деле немножко другой, потому что я отвечаю так, что он действительно делает форзо Фолкэксона, только делает это более красиво.
Медленно работает. Медленнее. Если запустить вместо кума Фолкэксона, будет видеть гораздо быстрее. Не уверен. Пост НКФ это истина первой станции. Да, но как-то сомнительно. Потому что если прям строить вот эту сеть и запускать Фолкэксона. Нет, нет, я не об этом. Я о том, что если взять и сделать такую же логику запусков как в Фолкэксоне, а не как в…
Нет, это странно, потому что казалось бы он будет делать ровно то же самое, только прибегаться по лишним бельшинам, по лишним лёмам.
Сейчас, не совсем оригинальный.
Просто видимо он разный представитель.
А, короче, если в тупую искать блокирующий поток Фолкэксона.
А что такое в тупую искать блокирующий поток Фолкэксона?
Нет, если его совсем в тупую искать, ну извиняйте, это значит кто-то плохо единицы написал.
Не-не-не, в смысле…
Ладно.
Нет, ну сейчас посмотрим.
Тут как бы еще зависит от размера просчитания на самом деле.
Потому что заметим, что этот ВЕ на самом деле…
Ну, точнее, в идеале на самом деле, когда мы говорим, что работает за ВЕ, на самом деле мы не совсем правы.
Ну, видите, который у нас сейчас есть.
На самом деле он работает за ZE, так сказать, F максимального потока.
То есть размер максимального просчитания.
Если там размер максимального просчитания 5, то он его найдет за 5 DFS.
Ну ладно, за 6.
Это метод форда Фолкэксона.
Да, прям тупой, да?
Теперь давайте…
Целочисленно.
Ну, мы просчитания ищем.
У нас не просто целочисленные.
Да, мы все еще ищем просочетания.
То есть алгоритм Кунна, он как бы дан был долгий граф, ищет просочетания.
Но мы пока…
Ну вот, значит, берем форда Фолкэксона.
Значит, теперь убираем S&T.
Что поменяется?
Что такое S&T?
Ну, и сток, и сток.
Ну, вот этот сток.
Добавили, да?
Все.
А теперь говорим, что давайте S&T, вот на S&T лишнее время не тратить.
А вместо этого давайте помечать, для каждой вершины лежит ли она в просочетании.
Можем даже в явном виде напарника сродить.
И на каждом шаге просто запускать DFS из всех вершин левой доли непокрытой просочетания.
То есть запускаем DFS.
Если из какой-то вершины мы вот неожиданно достигли вершины правой доли непокрытой просочетанием,
то вот удлиняющая цепь на лицо, и мы вдоль этой удлиняющей цепи улучшаем просочетание.
Ну, то есть что такое пропихнуть поток?
Это сказать, что вот эти ребра теперь лежат в просочетании, а вот эти теперь нет.
Но зато вот эти на месте.
Понимаете, да?
Мы сейчас попередом куна разбираем, что ли?
Да.
Вообще, приходим к алгоритму куна, это еще не он.
Так, еще раз, мы убираем S&T.
Убираем обратные и...
Нет, мы убираем S&T, а не обратные.
То есть пока мы просто говорим, что теперь вместо того, чтобы искать путь от S&T,
мы ищем путь от вершины левой доли непокрытой просочетанием в вершину правой доли непокрытой просочетанием.
Теперь следующая идея.
Давайте вместо того, чтобы хранить эти все прямые и обратные ребра,
будем хранить только две вещи.
Значит, смотрите, вместо этого мы будем делать так.
Смотрите.
Ведь на самом деле из каждой вершины правой доли может исходить только одно обратное ребро.
Это ребро просочетания, правда?
А вот давайте его в явном виде хранить.
Вот. Давайте его в явном виде хранить.
Тогда заметим, что вот из правой доли DFS...
То есть DFS, когда придет в вершину правой доли, у него все очень просто.
Либо из этой вершины нету рыжего ребра.
Ребра просочетания.
Тогда мы говорим, что ура, мы пришли куда надо.
Либо у нас из нее одно ребро так считает, и у нас только один вариант куда пойти.
То есть идем просто сразу в вершину соответствующую вершину левой доли.
То есть смотрите, у нас такая революция.
Мы вообще отказываемся от достаточной сети.
Единственное, что нам требуется, это то, что очень захочется, чтобы когда мы пришли в эту вершину, мы из нее вот сюда не ходили.
Вот по этому ребру не ходили, потому что его как бы нет.
Понимаете, да?
Но с другой стороны, если мы в эту вершину пойдем, она все равно нас сюда вернет.
Поэтому идея такая, что конкретно вот это ребро можно в общем-то и не угонять.
То есть самое главное, чтобы в нужные моменты времени у нас исчезало рыжее ребро.
Но на самом деле это не проблема.
Потому что, как я уже сказал, мы просто для каждой вершины правой доли будем хранить, есть ли в ней просочетание, и если да, то кто на партии.
И это и будет тем самым рыжим ребром.
То есть если вот после проталкивания потока по вот этой длиняющей цепи рыжее ребро будет перенаправлено сюда, то здесь просто одна переменная поменяется.
Понятно?
Вот.
То есть в результате, вместо того, чтобы вот эту вот писать всю сеть, мы уже приходим к весьма минималистичной реализации.
По крайней мере DFS из нее будет выглядеть, то есть граф у нас вообще будет выглядеть.
То есть что у нас будет вообще?
Вектор, вектор интгра.
И размер у него будет как размер левой доли.
То есть я буду создавать в доле граф очень просто.
У меня есть доля левая доля и правая доля.
И я буду просто для каждой вершины левой доли говорить, куда ведут из каждой вершины, в какие вершины правой доли.
Вот, понимаете, да?
Значит, в результате что нам еще потребуется?
Вектор инт.
Ну, а первых, юзет для левой доли.
И нам потребуется вектор инт.
Ну, я его назваю Порю.
Или как там, напарник.
Ну, можно тут написать слово ХОБРАВ, конечно, но...
Изначально тут минус один.
Ну, минус один будет в каждой вершине правой доли, а в минус один будет в правой доле.
Минус один будет в каждой вершине правой доли, а в минус один, значит, напарника нет.
А если напарник есть, там будет написан номер этого напарника.
Вот, понимаете, да?
И что же нас теперь ждет?
Нас теперь ждет маленькая приятная вещь.
То есть теперь DFS будет звучать так.
Он будет у нас в У.
И этот DFS будет говорить, верно ли, что удалось найти удлинающую цель, да или нет?
Удалось ли, вот, запустившись из вершины В левой доли,
В лежит у нас в левой доле,
дойти, да, вот, вершины правой доли?
Если да, то вот да, если нет, нет.
Ну, то есть DFS будет устроен очень просто.
Ну, во-первых, начнем с...
В данном случае оказывается целесообразно именно в этом месте проверять.
То есть, там юзит, давай.
То есть если юзит от В, то ну...
Соответственно...
Ретерпост.
Ну, а дальше тут, соответственно, форм.
Ну, тут вообще все просто.
Значит, пинт у гр от В.
Значит, пишем мы, если...
И вот здесь можно вообще красоту написать.
Если, смотрите,
pr от U равно минус 1,
то есть если напарника нет,
или напарник есть,
но DFS из него оказался неожиданно трушным,
то return true.
Нет, не так.
Вот так. Return true.
А.
Спокойно.
Что значит юзит?
Юзит это значит мы посетили в основном цикле.
Нет, юзит это означает,
что мы его посетили или не посетили в DFS.
А почему тогда мы его посетили в DFS?
Это означает, что мы в этой вершине уже были,
то есть типа туда не входим.
А, тогда как мы будем находить
увеличившийся поток,
если мы вот пойдем в вершину,
и если у нее уже есть ребро,
значит мы ее посещали.
В смысле?
Ну нет, если мы ее только что...
Нет, погодите, не понял.
Ну как бы это означает,
что если мы вот пришли в эту вершину по этому ребру,
то да, если сейчас пойдет DFS по этому ребру,
то он нам тут вернет false.
Один раз, но не второй.
А, то есть у нас перед каждым запуском
у нас очищается?
Да, ну не так.
У нас, мне кажется, немножко неправильно написано.
Правильно написано.
У нас же DFS в РСКВ
только из левой доли обязательно.
Да.
А почему это DFS от УМА,
а DFS от ПРАТУ?
А, в этом плане, да.
А еще мы нигде не присваиваем
новое значение ПРАТУ.
Ну да, пока у нас была цель DFS просто
найти существующую любвеющую цель, да или нет.
Ну да, да, да.
Ой-ой-ой-ой.
Как сложно.
Да.
UZIT от V равно true, да, совершенно верно.
Как давно я пыльчика-то
не писал, оказывается.
Так.
Просто такой написано, что у Гаррина сидишь
и не понимаешь, что там чего не хватает.
А там какая-нибудь UZIT не хватает.
Это, это, это.
И вообще, у Гаррито не хватает.
Ну и нет, еще не хватает, как минимум,
что в конце надо Гарриторию полнуть.
А что сделать, если мы берем
доставку экзамена алгоритма,
который ни разу из них не писали?
Как будто такого в семестре не было.
В каком семестре?
Нет, в третьем семестре экзамена
чечебалась.
Вот у нас основной цикл
по всем вершинам.
В каждой террасе
этого цикла мы очищаем
UZIT.
Где мы очищаем UZIT?
Ну как, но там
аккуратненько, сейчас вот увидите.
Еще раз, DFS нам
говорит, что?
Удалось ли нам найти удлинающую цепь?
Или дойти до правой вершины,
у которой нет на парке?
А мы давали еще раз
формальное определение этих
удлинающих цепей или нет?
Просто
пути достаточно сцепить.
Только сцепить у нас виртуальная такая.
Ну формально
остаточная,
это путь.
То есть это путь от вершины левой доли
в вершину правой доли,
где мы слева направо идем по ребрам не из пресочетания,
а справа налево идем по ребрам
из пресочетания.
Так что если совсем формально,
то вот это так.
Это удлинающая цепь?
Да.
Когда мы запустим внутреннюю цепь,
она сразу выйдет, потому что
это сочетание.
Из-за юзера?
Нет, вопрос как юзер.
Я бы сказал так, что как только мы нашли удлинающую цепь,
тогда юзер очищаем
и запускаем ДФС сзади.
На уровне идей.
То есть как бы
будет кун
будет работать примерно так.
Вот давайте я тут пример напишу.
Он будет работать так.
Ну допустим там
пишем
пора точка
assign
соответственно
модуль r
минус один изначально.
Значит bo
допустим
из ok
равно true.
И дальше
говорим что
while из ok
говорим так
из ok равно false.
То есть из ok будет символизировать то
верно ли что в эту итерацию удлинающая цепь
нашлась.
Дальше говорим
use it
точка assign
как всегда на
модуль l
соответственно 0.
Дальше мы говорим
значит перебираем
все вершины в левой доле.
Я вот так немножко
и формально напишу.
Перебираем все вершины в левой доле.
Это можно без модуля
или как можете воспринимать.
Да да?
И говорим
если
вот сейчас будет черная
баня, которую мы пока
не будем понимать как делать.
If that
is not
covered
by matching
то мы говорим
и теперь говорим неожиданно.
Если dfs
от v
то соответственно
из ok равно true
и бряк.
То есть
из ok равно true
и бряк.
И бряк.
Все.
Первое что тут может возникнуть
это если
да кто скажет
а если тут это
не надо ли тут проверить что вершину v
не покрыта?
Нет.
Но тут две причины.
Мало того что если что то dfs выбросится сразу
а во вторых заметим что
если вершина покрыта
а во вторых заметим что если
вершина не покрыта про сочетание
то мы в нее как отсюда
попасть не можем в принципе.
Поэтому достаточно
проверить что v не покрыт
про сочетание.
То есть это мы пока
подразумеваем что это
черная мания. Мысленно мы думаем
что можно поддерживать
не только p-r
можно p-r наоборот
поддерживать в явном виде.
Но правда
есть маленькая проблема.
Выглядит это так, но теперь мы
скажем вопрос а кто будет
улучшить цепь и улучшать про сочетание?
Нет.
Но оказывается ничего умного тут делать
не надо, потому что все что вам в этом месте нужно
это сказать что
p-r от u равно
v. Все.
Вот прям в этом месте.
То есть обратите внимание. То есть как только вы
делаете вот эту вот удлиняющую цепь
то она у вас прям
обрадуется и прям так и начнет.
То есть скажет что
у этой вершины теперь вот такой напахник
у этой вот такой, у этой вот такой, у этой вот такой
такой ура.
То есть окажется что
у вас удлиняющая цепь просто встает
и вы тут
и вы вот так вот поскачете.
Все.
А сколько раз может
цикл вайл проработать?
А сколько он может проработать?
Заметим что каждая цикл вайл это по сути
4,5.
А сколько же?
Нет, на самом деле обратите внимание.
Больше чем один поток.
Больше чем один.
Ровно один.
Как только нашли хоть один, брякнулись.
Вы брякнулись, прям бряк-брякнулись?
Прямо брякнуть.
Ну смотри.
А, ну да. Зачем?
Уберите брейк, будет быстрее работать.
Ну хорошо.
Ну можно и так.
Пока мы оставим бряк,
то я убеждаю, что то, что мы тут написали,
это просто такая
сильно модифицированная
и просто перевернутая
реализация форта.
Прямо идентично.
То есть форт тут единственное берется из-за того,
что был бы и сток, и сток,
это был бы просто идентично запуску ДФС
из-за стока.
Понимаете, да?
Вот.
Да, оно работает то же самое.
Да, может быть, локальная оптимизация, конечно,
бряк действительно не обязательно.
Можно и без него обойтись.
Хотя...
Честно, быстрее будет.
Может быть, быстрее.
Хотя, ну да.
Может, даже юзер имеет смысл защитить, конечно.
Нет, вот здесь не имеет.
Ну да, может.
Но не важно.
Ну не совсем так.
Но на самом деле это еще не классический форт.
На самом деле, то есть это еще такой,
это псевдокун.
На самом деле,
совсем кун это делает
другие образы.
На самом деле,
совсем кун это делает образы.
Он тупо перебирает все вершины.
И из каждой из них запускает ДФС.
То есть, примерно так.
Можно и...
То есть, такой классический кун можно замылить вот так.
Бугага.
Правда, то, что он работает, в отличие от всего предыдущего,
реально надо доказывать.
Ну, в каком смысле реально надо доказывать?
Потому что все предыдущее,
валидность всего остального,
это просто следовало из валидности форта Фолкерсона.
Правда?
То есть, обратите внимание, мы, по сути, ничего не доказывали.
То есть, мы сказали, что у нас уже есть форт Фолкерсона,
и из него, собственно, все это автоматически следует.
А вот здесь непонятно.
По крайней мере, на первый взгляд.
Потому что здесь утверждается следующее.
Почему-то утверждается,
что из каждой вершины
имеет смысл запускать ДФС только один раз.
Казалось бы, почему?
Но на самом деле,
это следует опять же
из более общей теории.
Которая будет гласить следующее.
Если...
Вот, предположим, что мы запускаем
метод Фольда Фолкерсона.
Вот сейчас будет мистическая теорема.
Даже не просочетательная.
Предположим, что у нас есть
то есть теорема.
Пусть мы
ищем
в сети
G
поток методом
Фольда Фолкерсона.
Ну тут даже наплевать.
ДФС мы-то ищем путь или нет.
ДФС мы-то неважно.
Просто методом Фольда Фолкерсона.
Пусть
в какой-то момент
времени
времени
из
некоторой
вершины
В
нельзя
дойти
до стока
Т
по ненасыщенным ребрам.
Ненасыщенным ребрам в остаточной сети разувереться.
Тогда, утверждаю я
никогда позже
с соответствующего пути
и не появится.
Вот.
Мистическая терема верна
не только для просочетаний,
а вообще для любых
остаточных сетей.
То есть казалось бы,
вроде как реображь там появляется,
исчезает в процессе, мало ли там
какие-то пути исчезают, какие-то появляются.
Но оказывается, что если пути
от В до Т в какой-то момент не было,
то есть если сейчас от В до Т
пути нет, то в будущем
его и не появится никогда.
Вот такая идея.
Такой приятный, интересный факт.
Откуда же этот факт берется?
А вот откуда.
Вот предположим,
что чудо произошло,
что вот пути не было,
не было, не было, не было,
а потом в какой-то момент бабазый появился.
Ну и действительно, у нас же не просто так,
то есть не из воздуха берутся.
То есть у нас, что такой метод Форда Пулкерсона?
Мы находим пути
в Т, пропускаем по нему потом.
Какие-то ребра появляются,
какие-то исчезают.
И вот давайте себе представим, что после
пропуска только что пути не было
из ВТ,
а потом вы пропихнули поток
где-то там в сети, и путь появился.
Как такое может быть?
Повелся обратная любовь.
И не только.
Давайте рассмотрим этот путь.
Или прямое восстановление?
Да, но это даже не важно.
То есть рассмотрим вот этот свежепоявившийся путь
от В до Т.
Как мы вынуждены заключить,
какие-то из этих ребер
появились только что?
Есть такой, да?
Какие-то были
и перед этим пропуском,
а какие-то появились только что.
Ну, давайте рассмотрим.
Вот этот путь, вот это ребро,
там допустим вот это.
Ну, я не знаю.
Ну и вот это.
Ну и не хочу совсем
прям быть последней.
Понимаешь, что это значит?
Это значит,
что у нас были
как выглядел вот этот вот
мистический путь от С до Т.
Ну, он как-то, как-то выглядел.
Значит, он тут ходил, ходил,
ходил, ходил.
Но в какой-то момент прошел через вот это ребро.
Логично, да?
Потом еще тут что-то ходил,
ходил, ходил, ходил, ходил
и прошел там, скажем,
через вот это, через вот это ребро.
Да, в каком порядке он их посетил,
мы не знаем.
Потом еще тут.
Потом прошел вот как-то так
и...
и пришел в Т.
Вот там еще он мог там по вершинам ходить
и так далее, да?
Ну, тогда смотрите, вот какая ситуация.
Рассмотрим последний,
вот на этом пути с ВТ,
рассмотрим вот последнее такое голубое ребро.
Последнее с точки зрения пути
от В до Т, конечно.
Ну, потому что это опять одно из тех доказательств,
где, как бы, давайте будем высказывать мысль
о бы как и в результате будет там
можно будет нарываться на всякие там предные
формальные вопросы.
Итак, вот, то есть рассмотрим вот все эти ребра,
которые появились, только что рассмотрим последнее.
Последнее на пути из ВТ?
Да.
Тогда я утверждаю...
А, хотя нет, даже не последнее,
наоборот, первое.
Потому что нам что надо доказать?
Нам надо доказать, что и перед пропуском
потока по этому пути
путь от В до Т будет.
Как это доказать? Это очень просто.
Идем по пути вот этому от В до Т
до первого голубого ребра.
До первого голубого ребра.
А от этого голубого ребра вообще,
от его конца, идем по вот этому
голубому пути, который только что был,
потому что мы по нему что-то пустили.
Вот, пошли вот так вот.
Следовательно, путь от В до Т и был.
И перед пропуском по этому голубому пути.
Доказательства окончены.
То есть получается вот такой глобальный факт,
что если от В до Т пути нет, то он и не появится.
Идем до первого ряда и до его конца.
А дальше по голубому.
Вот. Ну аналогичным способом можно доказать,
что если от С до В
в какой-то момент пути нет, то он и не появится.
Можно эти вершины сразу икногиривать.
Ну почему-то это даже еще более очевидно.
Так что вот есть такой вот, тоже из общей теории потоков,
такой маленький приятный факт.
Еще раз, секундочку.
Значит, мы из С идем
по пути, после которого у нас появились все ребра.
Ну точнее так, рассмотрим путь от В до Т,
который у нас неожиданно появился.
Он появился после пропускания
потока по пути из С в Т.
Рассмотрим этот голубой путь.
То есть так как
перед пропусканием потока по этому голубому пути
вот этого пути от В до Т
не было,
то значит тогда у нас на этом СТ
есть некие голубые ребра, которые являются
обратными к ребрам
на пути от В до Т.
Теперь я утверждаю, что
перед пропусканием потока от С до Т
по этому голубому пути
путь от В до Т по ненасыщенным ребрам
какой-то добыл.
Что это за путь? Очень просто.
Давайте идти по ребрам
до первого ребра с голубым напарником.
Точнее до его конца.
Эти ребра были
так как у них нет напарников,
то эти ребра были и перед
и перед запуском потока
по голубому пути.
И вот тогда
давайте до сюда мы дошли,
а из этой вершины до Т
мы уже можем найти по остатку голубого пути.
То есть следовать
на от В до Т можно было
по ненасыщенным ребрамам.
Что касается просочетания,
тогда эта интересная
теория дает нам возможность
в Куне не заворачиваться
и просто запустить один раз
ДФС из каждой вершины.
Правда, в такой реализации Куна
нет никаких проблем.
Ну как хуже?
В Э-то остается,
но оценить это теперь
как Е на максимальное просочетание
вы уже не можете,
потому что мы реально запускаем ДФС.
Я утверждаю, что на самом деле
можно достаточно легко
запустить ДФС
так, чтобы ассистентика
с максимальным просочетанием
состоять.
Если не нашли,
можно оставлять.
Да, совершенно верно.
Тут вот так напишем.
Зачистим в начале
вот там
и дальше перебираем вершины
и говорим, что если
ДФС удался,
то защищаем обратно.
То есть действительно заметим,
что если
в случае неудачного ДФС
граф не поменялся вообще.
А раз граф не поменялся,
то зачем старые пометки снимать?
То есть если вершина помечена,
значит вы из нее до вершины
правой доли низ просочетания
тупо не дойдете. Вы это уже знаете.
Так зачем же их снимать? Давайте туда второй раз не ходить.
И тогда серия подряд
идущих ДФСов
в таком случае
будет работать за ОАД.
То есть как только вы нашли,
граф поменялся,
придется делать защиту.
Так что в результате
все-таки
размер максимального просочетания
победить удалось.
То есть алгоритм
он хуже
работает,
чем
Д9.
Конечно.
Конечно.
Ну,
в реальности там
понятно,
что он приятен тем,
что он имеет, во-первых, очень крутую константу.
Не говоря уже о той мелочи,
тем более, что там очень хорошо работают
всякие подхачки в духе.
А давайте вместо
вот перед этим фором
попытаемся вставить фор, который будет
проверять только вот этот.
Ну, то есть сразу из вершины проверить.
А нельзя ли прямо сейчас выиграть?
Ну, или там бывает еще как-то
оптимизировать в среднем раза в два.
Найти просочетание
какое-нибудь жадно.
Вот представьте себе,
что вы набираете просочетание два раза.
Вот, просочетание жадно.
То есть просто, по сути, берете ребро
и говорите, так.
Так, это ребро можно добавить в просочетание?
Можно? О, берем. Это можно?
Можно? О, берем. А это можно?
Ой, оно со старым ребром просочетается. Не берем.
Ну и так далее.
А, это то есть с начальника брать?
Да.
Вот утверждение.
Да, утверждение.
И мы эту крылью от оптимального ответа
мы таким образом наберем.
Потому что у нас есть все требры
оригинального самого же просочетания,
каждая порция будет в двух.
Да, именно.
То есть давайте еще раз скажу
то же самое. То есть берем такой жадно,
да, то есть рассмотрим максимальное
реальное просочетание. Вот, допустим.
Вот пусть это реальное максимальное просочетание.
Вот.
Тогда
заметим следующее.
То есть это просочетание, если оно там
размера вот f max,
то заметим, что количество
вершин в нем 2
f max.
Ну тогда если мы
предположим, что мы
просочетание набирали жадно
и набрали
какое-то вот просочетание
вот какое-то, вот набирали, набирали
там, я не знаю, набирали
и набрали меньше, чем
f max пополам.
Тогда я утверждаю, что этими
голубыми ребрами
не покрыта ни одна из двух вершин
хотя бы одного из ребра.
Ну вот. Ну почему так?
Ну просто потому, что если мы набрали меньше, чем
стора,
ну вот.
Всего вершин меньше, чем f max.
Ну да.
Ну да, то всего тогда
всего покрытые вершины не более, чем
то есть строго меньше, чем
f max.
Ну вот, да. То есть оно, ну да.
А всего их 2 f max. То есть там просто
принцип телепия встает.
Ну или просто ребр всего f max.
Ну да, вот да, вот легче уже мыслить
действительно в тех, что каждое голубое
там, каждое голубое ребро
портит не более, чем
два ребра просочетания.
Портит в смысле блокировать.
Вот. И тогда получается,
если будет меньше, чем...
То есть получается, чтобы заблокировать их все.
Но если кто-то не заблокирован, то будет
возникать вопрос, когда мы его перебирали,
что мы его не взяли.
Так что вот оказывается, что
если вы просто жадно набираете про все,
вы уже полработы сделаете.
Оптимизация, которая сначала проходит
с циклом минус 1, потом с циклом f max,
делает пробку та же самая.
Или что более...
Не-не-не, ну не совсем,
она ж как бы...
Не совсем, она ж там из каждой вершины
начали висеть, напарника тупо не нашла.
Она ж у каждой конкретной вершины напарника
может не найти, тогда ж она реальный DFS
начала выпускать.
Это вообще сложнее показать, но она
делает меня хуже, чем столько
за первые Е действия.
А что такое первые Е действия?
Ну вот, за сколько мы это сделали все?
Ну да, но это мы отдельно работали,
DFS мы не запускали.
Во, да.
Но...
Нет, можно конечно заметить,
что потеряли Данилюка,
и действительно первая фаза Диница тоже найдет
хотя бы половину.
О, потому что
Губин разновал один.
Вот так.
Так что, в принципе, Динец
за куда-то не знаю,
но Динец это делает.
А,
а если учесть, что Динец
на первой фазе ровно этот шаг
и делает, что самое смешное.
А, кстати,
Путигины 3, да?
То да.
Это сильно ускоряет?
Два раза.
Ну где-то я, честно говоря,
я так не проводил эксперименты, но
знаете,
ходят случаи, что-то.
Знаете, как бывает?
Автор подобных задач,
кто пишет задачу там?
А, плевать, что там ограничения какие-то большие,
хорошо написанные.
Хорошо написанные.
Ну да, у этого автора, конечно,
хорошо написанные это может быть отдельная письма.
Ну вот так.
Значит, теперь представим себе,
что у нас есть жадь.
Что такое жадь?
Это абсолютно какой-то
произвольный, неориентированный граф.
Ну я сейчас определение
беру для абсолютно произвольного,
неориентированного графа.
Да, не обязательно планарного,
если что.
Ну там, с планарным графом-то отдельная письма.
Вот.
И смотрите.
Вот.
Значит, и тогда
с ним связаны
три приятные вещи.
Ну, давайте, красненько нарисуем.
Какие у меня там марки, видите?
Ну давайте вот такие.
Значит, смотрите.
Буковки такие.
Альфа джэ.
Это размер
максимального
парасочетания.
О.
Альфа джэ размер максимального парасочетания.
Вот. Ну это мы уже знаем.
А вот теперь два определения, которых мы не знаем.
Тау от джэ.
Мы знаем, что такое парасочетание случайно говорят.
Но определение понятно.
Что такое парасочетание?
Парасочетание это набор не пересекающихся
по вершинам.
Теперь.
Тау от джэ.
Размер
минимального
вершинного покрытия.
У нас нет долей.
Сейчас у нас абсолютно произвольный граф.
Ну то есть мы
как бы уже, когда мы находим...
Мы его не умеем искать, если что.
Нет, нет. Просто само определение.
Я не совсем понимаю. Вот мы потом разбили
на две доли.
Разбили на три доли.
Не три доли.
А что мы делаем? Ничего.
Обыделение.
Пока мы просто говорим, что у нас есть, в этом графе есть
بعάν.
Некоторые имеют большой ребер,
некоторые меньшее.
И максимальным парасочетанием мы называем парасочетание
с максимальным числом ребер.
Парасочетание это набор
ребер не зависимых по вершинам.
Никакие два из которых не имеют
общего вершины.
А вершины могут быть связаны между собой?
Конечно.
А они в двудольном графе могут быть
связаны между собой.
Потому что в двудольном графе тоже могла бы быть ситуация
Вот такие вот, вот что-нибудь вот такое, и на самом деле там есть еще вот такие бёбра.
То есть это ж допустимо в плане?
А в одной доле они могли...
А, а это в плане?
Нет, ну просто нет, это определение двудольное.
Когда мы говорим, что граф называется двудольным, если его вершины можно разбить на две доли так, чтобы внутри долей...
Да, здесь мы сейчас не рассматриваем двудольный.
То есть мы делаем абсолютно произвольный, не ориентированный граф.
Хорошо.
Мы ненадолго, но мы забываем о двудольности.
Это размер минимального вершинного покрытия.
Да, то есть это прошутское вершинное покрытие.
Значит, вершинное покрытие это такой набор вершин, вот такой вот набор вершин,
такой что каждое ребро инцидентно хотя бы одной вершине из этого ножа.
Ну, то есть вот там все ходит, хотя бы...
Ну да, то есть давайте так, смотрите, у подмножества в это вершинное покрытие,
покрытие, если...
Ну, то есть я не формально сказал, а формально это...
Ну, если формально писать, сейчас тут будет тупий звук, конечно.
То есть если для любого ребра E,
которое мы обозначим как УВ,
значит, оказывается, что У лежит в этом множестве У.
Ой, плохие буквы набрались, конечно.
Давайте...
Х.
Ну, что Х.
О.
В.
Вот так.
То есть для любого ребра E хотя бы одна из его вершин в этом множестве лежит.
То есть вершина мысленно взятая, потому что она покрывает все ребра торчачьи из неба.
Ну, естественно, каждое ребро может быть покрыто в таком множестве либо одной вершины, либо даже двумя.
Но, как бы, можно назвать вершину покрытием, если нет ребра, которые не покрыты ничем.
И, разумеется, ну, понятно, что такое ребро в вершинах покрытия всегда существует.
Ну, потому что можно просто в него взять все вершины.
Или все вершины без одной, кстати, всегда можно взять, это тоже нам хватит.
Но, на самом деле, конечно...
И нам, конечно, очень интересно, насколько мало можно взять вершин, чтобы все покрыть.
И, конечно же, и у него есть, конечно, такой замечательный нападник.
Ой.
Ой, а я в буквах нагнал.
Нет, это не альфа, это пи.
Альфа вот она.
Альфа, подожди.
Это размер...
Минимального, флаксимального ненависти.
Независимого множества.
Да, шутка и независимая множество.
Это множество вершин, которые не связаны ни одним ребром.
Да, совершенно. Никакие две из которых не соединены ребром.
И таких, конечно, вершин, ну, поэтому в идеале можно, наоборот, взять пустое множество.
Но, конечно, это не вершина.
И таких, конечно, вершин, ну, поэтому в идеале можно, наоборот, взять пустое множество.
Или одну вершину. Но хочется, наверное, взять как можно больше.
Но, знаете, тут оказывается интересным даже написать формальное определение.
Вот так и написать. Смотрите, игрок.
В это независимое множество.
Если, угадайте, что.
Если для любого Е.
Ну, так скажем. Если для любого Е.
То есть никакое ребро не соединяет две вершины из этого множества.
То есть, вот так, неверно, что У лежит в множестве Х,
и В лежит в В.
Вот, если совсем формально написать.
И вот так.
И вот так.
Или, что то же самое.
Не У, а Х.
Не, точнее, так, У не лежит, либо У не лежит, или, или, или, или, или, либо.
Не еще одну вершину.
Да.
Вот, что-то похожее, правда?
Вот, если формально написать, то есть есть что-то как будто прямо от одной вершины.
Что?
Не, ну не совсем. Видите, разница есть.
Тут как бы лежит, а тут не лежит.
Так мы объявили ИГЛИК.
Да, тут.
Да, да, да.
Это да.
Да, конечно.
Да, конечно.
Не, ну а то просто чисто, как бы уже просто,
обычно эта логика, которую вы продолжаете изучать,
уже должна спрашивать, а Х это что?
А тут вот какое-то это, как это называется?
Что называется? Незамкнутый предикат?
Или какое-то мудное сочетание, которое называется?
Нет, просто не помню.
На самом деле, по логике, как раз, нет, не было этого зачетка, это ни в чем не было.
Да.
Ну и еще будет.
Ой, почему-то кого-то он сильно пугает даже.
В наши времена почему-то все болялись такого страшного просто, как,
клянутое исчисление.
Только клянутое исчисление.
И то не в том предвече.
Ну почти плюс плюс у вас тоже экзамен.
Будут быть. Самый страшный, говорят.
Да?
Да.
Ну это да.
Ну да, да, да.
А то да, да, да, хоть и да.
Как говорится, с лекцией нет.
Ну знаете, иногда бывает, что это.
Лекции нет, экзамен сдавайте.
Нет, ну просто знаете, как логика,
потому что как-то хорошо вытверждается,
как-то, что где-то из гузер, там,
ну, в основном не наших, но там,
иногда практикуется такое, что,
на самом деле, вот какой смысл,
можно сидеть и читать лекцию, если все
материалы можно найти в учебнике.
Ну, потому что вот, ну, так там,
во всяких приметах, типа ватан или нав,
чаще всего это реально века.
Вот. Поэтому возникает такая практика.
То есть, на самом деле, лекция
существует только для того, чтобы лектору задать вопрос.
То есть, условно говоря, вы там
ботаете там, заданный объем материала,
потом, если что-то не поняли,
то, собственно, приходите и начинаете
задавать вопрос.
Вот.
Ну, вот. У нас почему-то это не происходит.
Видимо, потому что
с какой-то момента перестанут задавать вопрос.
Вот.
А потом выяснится, что что-то,
что-то знают. Так вот.
Значит, посмотрим внимательно.
Тао-аджи и альфа-аджи.
Что это такое? Ну, вот.
Ну, на самом деле, если очень внимательно
на вот это вот посмотреть,
то
сразу возникает мистическое
утверждение.
То есть, на самом деле, какое?
А утверждение такое,
что x, вот, произвольное
под множеством v, это
значит, вершинное покрытие,
не обязательно минимальное.
Вершинное покрытие.
Если и только
если
если
v без x
независимое множество.
На камере не видно?
Или там видно только тогда
этого?
Видно, все видно.
Все шикарно видно.
То есть, то действительно, если внимательно
посмотреть на формальное определение,
то в общем-то утверждение становится очевидно.
Ну, и даже можно и напрямую доказывать,
что, как бы, пусть это
x-вершинное покрытие. Если тут
зависит от множества, значит, есть ребро,
соединяющие две вершины
из дополнения x.
То есть, получается, этот x
какой-то ребро не покрыл.
Ну, и наоборот то же самое.
Я не тут минимальное не писал,
не тут подсимальное не писал.
То есть, не обязательно максимальное?
Да.
Они просто обыстомали, ходим паре.
То есть, там можно всяким
формулировать там всякие утверждения,
типа, что вершинных покрытий ровно столько,
сколько независимо от множества, например.
И это, видите, тоже отдельная тема.
Что-то там да.
Ой, да. Замечательно, да.
Так сказать, нельзя сказать, что
это же результат публиковать
в каком-то журнале.
Вот.
Так это да.
Вот.
Нет, ну, в каком-то математике так бывает.
Доказываешься, доказываешься, теряем у фирма.
Там находишь несколько доказательств.
Каждый из них валят.
Ну, там по разным причинам. Потом говорят, что есть у вас
одна маленькая незначительная ошибка,
то есть, если не исправить, то уже доказательство не получается.
И там придумываете второе доказательство,
и доказательство абсолютно правильное, только доказали,
вы не теряем у фирма. А там что-то другое
доказали, впрочем, давно известно.
Ну, вот потом вы там
просто играете числами,
находите интересный план.
Не ставите энциклопедию,
там просто, там, в которой есть все
в математике, и ваша теорема не находится.
Думаете, что это ваша теорема.
А потом через много лет просто находите
эту теорему, как олимпиаду,
олимпиаду Дескак-Шиклая.
Ну, вот.
Так вот.
На самом деле нас из этого всего будет интересовать
следствие. То есть, я могу сформулировать так.
Ну, следствие, на самом деле, очень прозрачное.
Что на самом деле
я даже вот так симметрично сформулирую.
Ну, понятно, да?
Чем меньше вершинное покрытие, тем больше
у него дополнение. То есть, мысль теорема в том,
что, это даже можно более точно сказать, что
дополнением к минимальному
вершинному покрытию является максимально
независимое дно штуны, ну и наоборот.
То есть, поэтому по факту,
во всех смыслах, нам на самом деле
отдельно альфа аджей
искать необходимости нет.
То есть, если мы найдем минимальное вершинное покрытие,
мы автоматически максимально независимое
дно штуны найдем.
В чем-то, заметьте, что самое приятное, я вот
случайно тут рисовал произвольный граф.
То есть, это вот эти утверждения
для произвольного графа.
То есть, мы здесь двудольностью не пользовались
никак.
Поэтому давайте
временно про независимое
дно штуна забудем.
Ну, не временно, на самом деле.
Безвременно, да.
Так что, значит, давайте
это все мы убираем.
То есть, мы поняли, что
с точки зрения глобальных идей
нам, в общем-то, независимое дно штуна
бесполезно практически.
Ну, не бесполезно, но в смысле
что
тратить много времени
отдельно от вершинного покрытия нам не надо.
А теперь давайте думать,
как связаны между собой таоджи
и пьеджи?
Ну да, заметим, что мы, конечно,
гордо
можем заявить, что
пьеджи больше либо равно,
чем таоджи.
Или наоборот.
Вот кто кого.
Пока я тут пишу слово
уплевнение.
Таоджи больше либо равно.
Пьеджи переписается,
на записи будет ничего.
Ну, пи какой-то не пи.
Вот это пи как пи,
а вот нижнее пи.
А вот это?
Оно как что-то х чертой.
Реполнение к х все нормально.
Ну как? Все красный свет
негликаешь хоть?
Что?
Красно-торанжевая на записи, думаю, не отличается.
Да?
Ну, у меня тут в голодах не очень
отличается.
Я думаю, просто свет
включить надо.
Ну, свет сейчас
ну, я не знаю, поскорей,
свет включить это называется, вон это
всуху открыть.
Вообще ничего не видно.
Без свет будет отсвечиваться.
Пьеджи меньше либо равно таоджи, думаю, в случае.
Почему так? Потому что таоджи
должен покрыть хотя бы
каждое ребро по рассочетанию,
а у каждого ребра по рассочетанию
свои две вершины.
А теперь есть какая-то вопрос.
Хорошо.
А может ли быть так, что пьеджи строго
меньше, чем таоджи?
Да.
Самый тупой пример, конечно, три ульбы.
Ну, тут понятно, да.
Просочетанием является
максимально обдымное ребро.
Но, к сожалению,
чтобы покрыть все три ребра, вам все-таки тут
две вершинки взять придется.
Вот так.
Вот так.
Вот так.
Вот так.
Но, оказывается,
если мы берем все в удольный граф,
то
оказывается,
здесь равенство.
То есть уже
это уже не утверждение.
То есть это пока простое утверждение, тут все несложно.
Но вот.
Но если мы возьмем в удольный граф,
то выясняется,
видимо, теория материнга.
Вот.
Прямо что-то узнаю.
Если
граф в удольный,
то
оказывается, что
пьеджи
равно таоджи.
Вот.
Это называется теория материнга.
Вот.
Вот спрашивается, как же
ее доказать?
Ну, собственно, мы ее не просто докажем,
а еще и укажем, каким образом,
если у вас есть максимальное просочетание,
то у вас есть максимальное вершинное покрытие выкопы.
Значит, смотрите внимательно.
Итак, вот у нас есть
в удольный граф.
В лице двух долей.
Ну, вот у нас есть доля L,
есть доля R.
Вперед. Смотрите внимательно.
И у нас есть трех.
Некоторые ребра лежат
в просочетании.
Мы их, естественно, ориентируем
справа-направо.
Еще у нас есть ребра, не вошедшие
в просочетание. Мы их ориентируем
слева-направо.
Так мы не будем.
Вот так вот будет.
Вот так вот.
Вот, ну, приблизительно.
А, еще, конечно же, вот так вот.
А, ну да, вот так вот, конечно.
Ваше просочетание не максимальное.
Господи, как ни рисую, я все равно
удоняющая целью, где-нибудь проскочу.
Так.
Сейчас.
Нет, надо как-то...
Сейчас.
Вот так надо сделать.
Ну, чтобы совсем красиво было,
надо вот так.
Окей.
Пойдет.
Вот сейчас пойдет, да.
Так вот.
Интересно теперь в следующем.
Мы сейчас проделаем
мистическую штуку.
Мы возьмем...
Зачем мы все еще ориентируем?
Мы возьмем
все вершины
левой доли
не покрытые в просочетании.
И запустим из них
DFS.
Вот эти.
Так и запустим.
Вот эти вершины я обведу в знак того,
чтобы из них DFS запускали,
а эти просто закажем в знак того,
чтобы из них не запускали,
но DFS до них дошел.
Вот, примерно, вот так вот это.
Вот.
Вот, примерно, вот так вот это
произойдет.
Видите, да?
Значит, смотрите, тогда
в левой доле есть
вершины, которые
DFS обошел, мы их назовем
L+.
А есть вершины,
в нашем случае одна, но их может быть
и больше, когда DFS не отошел.
L+. Видите, да?
Абсолютно
аналогичным образом мы скажем,
что до кого DFS дошел
в правой доле мы будем называть
L+.
С Мирко, что ли?
Да.
С Вики, с чего он?
Ну, когда
когда у вас есть
алгоритм, который работает
за ОАД,
если у вас уже есть максимальное
просочетание, то зачем
придумывать еще?
Да. И это будет называться
L+. Ну да, литературы может быть
действительной. Там все максимальные конспекты,
что угодно.
Вот.
Так вот.
Так вот.
Мистическое утверждение.
Минимальное вершинное покрытие
нот,
то есть
покрытие
ну, не совсем то есть,
понятно.
То есть,
покрытие
размера
собственно P от G
меньше быть не может,
а вот покрытие размера P от G
это
я утверждаю, что это L-
объединенное
R+.
Все.
То есть, как бы, если мы поверим
в этот мистический факт,
то вот тогда, то есть, получается, что
если у вас есть максимальное просочетание,
то минимальное вершинное покрытие вы найдете
практически за O от E одним DFS.
Ну, то есть, серии DFS, которые суммарно
работают за O от E.
Ну, а максимальное независимое
вы найдете, естественно, как L+,
объединенная серия.
А мы
закрасили вершинки, которые насыщены
просочетанием?
Нет. Мы закрасили вершинки,
на которых вы дотянулись DFS.
ДФС,
которые мы запустили
из всех вершин левой доли,
не покрытой просочетанием.
Потому что она покрыта
просочетанием, и мы так ее
не дотянулись.
Вот такой вот красота.
Проказательство, конечно,
сложнее.
Но тут, конечно, полезно его иногда
иметь в виду,
потому что я зачастую
не помню, кого там
надо брать, но я помню, из каких
соображений это берется, и результате,
исходя из этого, достаточно быстро вспоминаю,
что тут надо писать.
Доказательство тут, в общем-то, логичное.
Что надо доказать?
Во-первых, неплохо
было бы доказать, что это
реально вершинное
покрытие.
Но это самое
простое.
Потому что предположим, что
это не вершинное покрытие.
Тогда у нас получается,
есть две вершины.
Одна,
есть две вершины.
Одна из L+,
а другая
из R-.
И они соединены ребром.
Внимание и вопрос.
Каким ребром?
Ну, у нас два варианта.
Либо они соединены
вот таким ребром.
То есть, вот отсюда-сюда.
Либо вот таким.
Вот этим ребром
это идиотизм.
Потому что
из вершины,
помеченной DFS-ом,
ведет ребро вершину,
не помеченную DFS-ом,
что забреет.
Значит, такого не бывает.
Так, ребро
из вершины,
не помеченной DFS-ом,
ведет ребро
вершину, помеченную DFS-ом.
Может ли
такое быть?
В общем случае, может.
Ну, потому что малый как DFS-ом устроен,
помните, да?
Потому что мы из не самых удачных вершин запустили.
Само по себе это может быть.
Но здесь есть маленькая оговорочка.
Мы в эту вершину...
А как мы в эту вершину вообще попали?
Вот заметим, что мы в вершину могли попасть только два раза,
двумя способами. Либо мы из нее запустили DFS,
либо пришли по какому-то ребру, правда?
Но так как она покрыта по рассочетаниям,
и мы DFS из нее не запускали,
значит мы должны были в нее прийти.
А прийти мы в нее могли только
через это ребро.
Но так как в эту вершину мы не ходили,
через это ребро мы не приходили,
противоречие.
Значит, ура!
Мы доказали...
Давайте внимательно, что мы доказали?
Что нет ребер
между L+, и R-.
Да.
Или что то же самое, мы доказали,
что L- и R+, в объединении,
дают покрывающее множество.
Но минимальное ли оно?
Вообще, вегна ли, что
оно реально имеет размер PNG?
Как это доказать?
Это очень просто.
Мы докажем, что в этих множествах
каждая вершина
лежит в просочетании.
И более того,
на каждому ребру просочетания
принадлежит ровно одна из этих вершин.
Я утверждаю, что ровно это нам достаточно доказать.
Понятно, что я сказал?
Ну, смотрите.
Это покрывающее множество.
Я хочу просто показать,
что все эти вершины
лежат в просочетании,
и более того, на каждом ребре просочетания
лежит ровно одна такая вершина.
То есть это и будет означать,
что в этом множестве ровно PNG-вершины.
Логично, да?
Логично, да.
Ну, давайте думать.
Ну, во-первых, конечно же...
Ну, давайте так.
Ну, хотя все тут надо...
Ну, во-первых, давайте подумаем.
Могут ли эти вершины не лежать в просочетании?
Ну, A-минус, очевидно, не может.
Потому что
из всех вершин левой доли
не лежащая, мы DFS тупо запускали.
Помните, да?
Хорошо, а F+.
А почему?
Допустим, вершина
не лежит,
но мы как-то
дошли ребром
до R+, ну, до этой вершины
и не вышли.
Ну, само по себе DFS...
Нет, тут не с DFS
противоречие.
То есть DFS-а-то...
Тут противоречие в другом.
Смотрите.
Предположим, вершина лежит в R+.
И предположим, что она
в просочетании не лежит.
Тогда получается, что мы
до нее дошли
из какой-то вершины левой доли
не покрытой просочетанием.
Как называется
путь, по которому мы это сделали?
Совершенно верно.
Это называется удлиняющая цепь,
и это тогда давало бы нам информацию
о том, что просочетание не максимально,
вот мы, кстати, впервые этим воспользовались.
Обратите внимание.
Так что, получили противоречие.
Следовательно, R+, либо просочетание
не максимально, либо
из каждой вершины R+,
просочетание ребра торки.
Ну, все, что нам остается, это
показать, что не существует
вот ребра из просочетания,
которая соединяет
вершину из R+,
с вершиной
из L-.
Ну, опять ребра, ведущая из
вершины, посещенной ДФС, вершины,
не посещенной ДФС, опять предъятина.
Таким образом, мы показали,
что все эти
вершины лежат на ноте,
что, действительно, это
покрывающее множество,
все эти вершины лежат в просочетании,
и на каждом ребре просочетания,
ну, максимально имеется в виду,
лежит из этих вершин
ровно одна.
Что означает,
что это действительно...
А еще мы доказали, что это вершинное покрытие.
Значит, это и означает, что мы нашли
вершинное покрытие минимально
возможного размера.
Ну, в смысле, меньше деньги.
Ну, и автоматически там максимально
исходить. Так что вот, собственно,
приятно
прямо за ОАДЕЙ нашли.
Коротко можно еще раз прибежать сюда?
Вот там, где мы
говорили,
вот такая скороткая получка.
А ведь просочетание,
сколько угодно.
А это не важно. Я сказал, когда я говорю ОАДЕЙ,
я не веду следующее. Если вам дал вот дольные гафы
просочетания в нем, то вот это вот
вы находите за ОАДЕЙ.
То есть, по сравнению с подпросочетанием,
вы делаете ОАДЕЙ дополнительно.
Это все, что я управляю.
Так, ну, значит,
давайте, значит,
алгоритм. Значит, берем максимальное
просочетание, ориентируем его вправо,
все остальные... Вон, обратно.
Просочетание ориентируем влево, остальное
все ориентируем слева-направо.
Вот.
Берем все вершины, не покрытые просочетанием,
влево и доль, и
запускаем из них DFS.
Обоснащаем вершины в левой и правой
долях, покрытые,
то есть, до которых DFS дошел,
за L+, L+.
Остальные вершины L- и L+.
И теперь я утверждаю, что
если мы возьмем множество L-
объединенных с R+,
то это будет в точности
вершинное покрытие размера 5.
Доказательства.
Во-первых, это
вершинное покрытие.
Почему?
Пусть это не так, тогда
найдется ребро, которое соединяет
L+, R- или наоборот.
Но L+, R-
оно соединять не может, потому что
не может из вершины
обойденной DFS
торчать в вершину не обойденной DFS.
А в другую сторону
быть не может, потому что
мы в эту вершину могли попасть
только по этому ребру.
DFS на прямую не запускался
по определению, но попасть в эту
вершину мы можем прийти
только по этому ребру, других ребров
у нас сюда не входит.
Поэтому это
минимальное покрытие.
Почему оно минимальное?
Потому что
я утверждаю, что
все эти вершины принадлежат
просочетанию
максимальному нашему.
Причем более того
в каждом ребре
ровно одна из вершин
лежит в этом ножестве.
Из этого и следует.
Если мы это докажем,
то на этом доказательство закончится,
потому что из этого и будет следует,
что их ровно пердежа.
Этот момент понятен?
Да.
У нас их две.
Теперь надо оказать,
что каждый из них имеет отношение
к просочетанию.
Почему имеет отношение к просочетанию?
Вершины L- имеют
отношение к просочетанию
просто потому что все вершины
левой доли, которые не имеют отношения
к просочетанию, из них DFS запускался.
Поэтому это точно.
Здесь все хитрее.
Здесь уже все увязывается в то,
что если у вас нашлась в правой доле
вершина не покрытая просочетанием,
до которой дотянулся DFS,
то это значит, что в процессе
этого DFS
вы запустили DFS из какой-то
вершины левой доли
и дошли до вершины
не покрытой просочетанием
и дошли до какой-то вершины правой доли
не покрытой просочетанием.
Притиморичит факту,
что просочетание максимально.
Потому что это просто
удлиняющая цепь явно.
Следовательно, да, эти вершины
имеют отношение к просочетанию.
Остается только показать,
что ни на одном ребре
просочетания нет
двух вершин из этого проста.
Но это как раз просто.
Тогда у нас справа есть
вершина, которую DFS прошел,
и из нее справа налево ведет ребро
вершину, которую DFS не прошел.
Притиморичить уже со смыслами DFS.
Все.
