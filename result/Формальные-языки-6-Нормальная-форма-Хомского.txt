Редактор субтитров А.Синецкая Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Корректор А.Кулакова
Понимаете, почему?
Ну да, из нём-то равно что-то.
Вы просто, знаете, представьте себе ёлку, на которую вы
хотите гирляндами обвесить, ой, это, гирляндами, игрушками
обвесить, да?
Ну, по сути, ваша цель – нарядить ёлку в конце концов.
Как вы вешаете гирлянды и это вообще не играет роли.
То есть вы могли сначала, я не знаю, шарики туда положить,
потом гирлянды повесить.
Либо наоборот, сначала гирлянды повесить, потом шарики положить.
Ну, тут, к сожалению, а может, к счастью, ничего не меняется.
Ну вот, давайте теперь воспользуемся этой идеей и что скажем?
Во-первых, если у нас v принадлежит lg2, то что это значит?
То когда-то мы, если мы прошлись по длинному правилу, давайте
я на примере, я на каком-то вот таком примере сделаю.
Вот, у нас это за один переход было осуществлено.
Ну тогда что мы с вами можем сделать?
И, допустим, дальше мы выводили какое-то слово w.
Точнее, давайте формально.
D, w, B, C, w, E, F.
То каким образом мы его еще могли вывести?
Ну да, ну могли бы, это у нас, если что, в g2.
Тогда аналогичная картинка в g3 выглядела бы вот так.
Мы из A за один шаг вывели бы D, B, C, E, F.
Потом бы раскрыли эти D, C, F.
И потом бы вывели то же самое слово.
Ну тут можно это к какой-нибудь индукции по длине дерева вывода сделать.
Да, на самом деле в обратную сторону тоже доказательства аналогичны.
Мы просто говорим, что давайте мы будем сразу раскрывать не терминалы,
которые будут выводить в одну букву.
То есть в порядке bfs раскрывать.
То есть это у нас, это факт такой.
А если мы говорим w, я напишу, что это аналогично, только раскрываем в порядке bfs.
В первую очередь D, W, D и подобное.
Понятно, что произошло?
Нормально?
А то мы все загрустили так уже.
Итак, у нас теперь ушли смешанные правила.
У нас теперь есть длинные правила, вот такие вот.
Давайте это.
Что мы сделаем?
Мы сделаем вот такую замену.
То есть разобьем последовательность многих символов на последовательность из двух символов.
Давайте сейчас мы это добьем и на перыбчик свалим.
Итак, у нас с вами что?
Ан, мы заменяем на, из b выводят b1, a1.
Так, я кажется баг запустил.
Да, да, да.
Надо буквы не стоим поменять.
Так, до какого там добем минус первого.
Ну, теперь давайте покажем, что это все верно.
Опять же, for-fact тот же самый, это у нас пусть g4 громочка будет.
Ну, если у нас v принадлежит l от g3, да, тогда если у нас из s выявилось какое-то
правило b, из него за один переход был an, и потом выводилось v, то какая последовательность
у нас здесь будет, в g4, так, тут я контекст забыл, да, пусть у нас p и p тут, что мы
должны сделать?
Мы хотим дерево вывода в g4 построить.
Ну, надо b заменять, phi, b1, psi, потом один раз заменяем phi, дальше у нас будет
phi.
Ну и дальше из этого мы можем вывести то же самое слово w, это в одну сторону, а
в обратную сторону.
Что мы сделаем?
Ну, допустим, у нас из s выводился w.
Какие два случая у нас могут быть?
Да, значит, смотрите, первая история какая, давайте b и t не встречаются, тогда что
мы делаем?
Ну, да, все то же самое, второе случая, b и t встречается, встречается какое-то
bk и t, тогда что происходит, если у нас bk и t встречается?
Тогда у нас bk и t встретиться могло, так, это значит, что у нас в дереве вывода
встречается bk и t, его мы каким-то макаром должны были получить, ну а каким макаром
мы его можем получить?
Только через bk минус 1, а что из него выводится, из него выводится bk плюс 1, ну либо конец
могло, ну и тогда мы понимаем, что тогда сразу встречается b, b1 и так далее bn, bn
минус 1.
Ну, а дальше делаем в обратную сторону, здесь тот переход, который у нас уже был.
То есть, вот это вот действие мы, повторяем, протидаем вот сюда.
Угу, понятно?
Ну, хорошо, давайте перерыв тогда сделаем.
Значит, у нас остались только такие правила, кого следующим убивать будем?
Правила из A выходят эпсилон, но тут немножко более нетривиальное свойство, которое нам
нужно проявить, нам нужно убить все эпсилон порождающие символы.
Смотрите, давайте определение дадим, символ E называется эпсилон порождающим,
если из E выводится эпсилон.
Давайте я напишу где-нибудь.
Где у нас цепочки?
Вот тут кажется.
Какое правило у нас пойдет под откос?
Если из E выводится E.
Угу.
Как искать эпсилон порождающую, это та еще история, но давайте теперь подумаем,
что мы будем делать.
Мы будем делать такую замену.
А первое, что мы будем дербанить правила из A вследует BC.
То есть, если у нас из A вследует BC и C эпсилон порождающую, то мы добавляем правила из A вследует B.
А если есть правила из A вследует BC, из B выводит E, добавляем правила A вследует C.
Контрольный вопрос, который я хочу задать.
А если у нас символы в одном правиле, символы B и C эпсилон порождающие, то сколько правил мы добавим?
Ну мы добавим два правила с вами.
Ну то есть, если у нас из A вследует BC и B и C эпсилон порождающие, то у нас добавится как правила как A вследует B, так и A вследует C.
И удалим все правила из A вследует E.
Вот.
Утверждение, которое мы с вами сейчас... это у нас будет уже с вами грамматика G5.
И нам надо будет показать с вами, что L от G4 равно L от G5.
Не, не, мы не заменяем.
Не-не-не, у нас пока есть еще и одиночные правила, ну потом это одиночные будем избавляться.
Так, ну что, давайте попытаемся доказать.
Эту всю вещь, то есть у нас добавляются правила и убираются одиночные правила.
Ага, получаем грамматику G5.
Итак, тут такое неформальное доказательство.
Смотрите, если вы принадлежите 4,
4, то выделим под деревья максимальной мощности, из которых выводится эпсилон.
Я сейчас нарисую картинку, то есть у вас есть, допустим, из S,
там вы... может на новой доске нарисовать, на большой?
Мне кажется, картинку нужно на большой доске рисовать.
Ну нет, это по сути, у нас есть не терминал какой-то, да,
из него что-то подвыводится, это вот по сути все под дерево.
Не-не-не, мы берем слово, мы берем дерево вывода для слова W.
Вот смотрите, сейчас я покажу.
Вот у нас есть с вами S,
есть с вами W, вот оно в конце где-то.
И мы смотрим на вот такое большое дерево вывода.
Это вот, это считайте, елка вот у нас такая.
И, допустим, у нас находится здесь какой-то не терминал A,
и из него могло вывестись какое-то под слово.
Вот эта вот штучка, это под дерево.
Ага, понятно?
Давайте рассмотрим все под деревья максимальной мощности,
которые выводит Эпсилон.
Допустим, у нас из него B,
и у него под деревом какое-то вот такое вот,
и тут выводится пустое слово.
Угу.
Вопрос, который я хочу вам задать.
Как мы получили в этой истории из W следует Эпсилон?
Как мы получили не терминалы B в этом дереве?
Могла ли быть у нас вот такая картинка,
когда из C только выводилось B?
Почему?
Ну, мы это делаем.
Мы смотрим в грамматике G4 дерево вывода.
Да.
Но давайте поймем, почему нельзя.
Я пишу, что все деревья под деревья максимальной мощности,
которые выводят слово Эпсилон.
Вот смотрите, вот это дерево из B выводит Эпсилон.
Оно теперь становится не максимальной мощностью,
потому что мы можем подняться на одну вершинку вверх
и получить более большое пространство.
И с C выводит Эпсилон.
Но B это не терминал какой-то,
который появился в дереве вывода,
и он был эксилонопорождающий.
То есть из него вывелось в дереве разбору пустое слово.
Мог ли быть родителем в дереве вывода,
для того чтобы выводить это слово?
Мог ли быть родителем в дереве вывода,
для вершины B вершина C по правилу C следует B?
То есть у нас из B выводится Эпсилон,
а из C выводится B.
Ответ нет, потому что тогда
у нас из C выводился B-эпсилон.
Понятно?
Хорошо.
Если такой картинки быть не может,
тогда это.
Тогда каким еще образом мог появиться не терминал B
в этом дереве вывода?
Осталось не так много вариантов.
Вот смотрите, пусть у нас
родитель вершины B это вершина C.
Но что еще с ней могло быть?
Какого вида правила у нас есть в G4?
Да, смотрите, у нас могла быть такая картинка.
C выводит BD,
или C выводит Db.
Ну и дальше тут вот крона у нас с вами.
Пустое слово.
Здесь крона, пустое слово.
Угу.
Тогда скажите, что нам надо сделать
для того, чтобы получить LADG5?
Какое дерево разбора в LADG5?
Можем ли мы теперь его предоставить с вами?
Хорошо.
Пример.
Вы в огороде когда-нибудь работали?
В саду?
Да.
В саду.
В саду.
В саду.
В саду.
В саду.
Что осеньи делают?
С деревьями.
Да, подрезают под деревью,
чтобы дерево не пускало лишние ветки,
а во-вторых, еще и обрабатывают.
Но давайте сделаем то же самое.
У нас же, по сути, говорится следующее,
что если у нас в грамматике G4 есть вот такие вещи,
то в грамматике G5 у нас есть обрубленные,
подрезанные вот такие вот под деревья.
Здесь есть такое,
а здесь есть такое.
Где у нас нету вот этого B?
Вот.
Ну вы, по сути, можете тут пенек оставить какой-то,
засечку, что вот тут нет.
Понятно, что произошло?
Еще раз.
Смотрите.
Рассмотрим в B4 эти под деревья,
которые не плодоносят.
То есть, которые порождают эпсилум.
Что мы хотим, когда мы обрабатываем яблони,
которые цветет?
Обрубить под корень те ветки,
которые не плодоносят.
Абстракция здесь ровно такая же.
Мы хотим обрубить ветки, которые не плодоносят.
А как понять, что ветка не плодоносят?
То, что выше ее плодоносят.
Если у нас есть правило,
из C выводит B,
то мы обрубаем не там,
потому что можно обрубить выше,
и дерево будет плодоносить,
не будет плодоносить.
Поэтому у нас случай такой,
как ни терминал B,
который порождает эпсилум,
мог появиться.
Либо в таком случае.
А какие правила у нас есть?
У нас есть правило,
что если из C следует BD
и B эпсилум порождающий,
то у нас есть дополнительное правило
в грамматике G5,
которое говорит,
что из C мы можем вывести D.
Заменяем его,
а по сути это эмуляция обрубленного
куска дерева.
Таким образом мы строим
вывод в грамматике G5.
Так, и G4 в G5.
Понятен переход теперь?
Через это,
через стодоносческие эти
абсорбации.
Обратная ситуация,
давайте протезы сделаем
нашему дереву.
Пусть V лежит в G5.
Посмотрим все те места,
которые обстригалось дерево.
То есть представим себе,
что V
лежит в G5.
Рассмотрим правила.
Из C выводится D.
В дереве S
выводится V.
При этом
C
не было в G4.
Тогда что мы делаем?
Да?
Программируем.
Программируем.
Правило C
следует D,
не было в G4.
Ну тогда какое у нас правило было с вами,
если его не было в G4?
Ну да, C выводится,
скорее всего было правило C выводится
BD.
Или Db.
А при этом B выводила
ε. Ну давайте теперь
подстроим как раз
у нас было дерево
и по сути мы с вами пристроим
как порождалась
ε, из этого не терминала B.
Такое, протезир, это как называется?
Искусственное отращивание.
Мне бы оно не помешало,
но я как бы это привык
ходить лысым,
поэтому мне норм.
То есть видите, специально
подрубки мы оставили здесь,
в которых если что мы можем отрастить.
Так, с этим разобрались?
С этим переходом.
Хорошо, прикол, я вас где-то обманул.
Давайте поймем, где я вас обманул.
Да, а что если
из этого выводилась ε,
тогда доказательства вот ровно в этом случае
ломаются.
Да, потому что мы сразу все дерево
обрубаем.
Под корень.
Вот, то есть если у нас
есть хотя бы один символ,
то это работает.
И мы его тоже убрали, поэтому нам нужно
обработать, то есть смотрите, в чем прикол.
Сразу сделайте себе
пометку.
lg5
равно lg4
без ε.
Без пустого слова.
Как его вернем?
Да, с вводит ε, но смотрите, мы сделаем
чуть-чуть другой лайфхак.
Да, вот.
В общем,
sreps он в правилах выкинута, а дальше
мы бы обрубали, но ничего не случилось.
Поэтому, лечится
так, смотрите, в заводе
в новый не терминал s' делаем его стартовым.
А, где стерка?
То есть мы делаем s'.
Добавляем правила, из s' следует s.
Если s выводит ε,
то добавляем
из s' выводит ε.
Да, то есть делаем новое
стартовое состояние, новый стартовый не терминал.
Получаем
грамматику g6.
Вопрос, какого зайца мы еще прибили по ходу дела?
Идите и ищите
в определении нормально Фармахомского.
Там есть очень тонкий момент, который
мы сейчас как раз прибили с вами.
Ну и что?
Ну мы теперь переобозначим грамматику.
Да, второе, из a следует
bc, смотрите.
Что в скобках написано?
Смотрите, что b и c не являются стартовыми.
То есть мы с вами,
когда вводим s',
вот, вот видите,
вводим s',
и s' нигде в правой части не
находится.
Да?
Ну все.
Типа
получаем
такой вот переход.
А хорошо, а теперь у нас остались
так, остались правила такого
вида.
Что делать будем?
А?
Да, надо предпоследних избавляться.
На самом деле
я вам сейчас открою страшную
тайну. Избавляться от них ровно так же,
как от эпсилом переходов в автомате.
Да, да, да.
Мы будем искать путь
замыкания по a и b, и потом
встретим первый переход, который
не идет в то же самое.
Ну, транзитивное
замыкание. То есть если у нас есть
в последовательности b, следует b1, b2,
и так далее bn, и так далее,
переход cd и va, то мы их заменяем
на такое правило.
И после этого мы с вами можем удалить
одиночные правила.
Тут можно сказать,
что любое правило вида
cd, va можно рассматривать как цель
из нуля и более одиночных переходов,
а вы можете написать себе,
что доказательство
ровно аналогично тому, как удаляют
эпсилом переходов в автомате.
Там ничего
с такого
фундаментального не будет нового.
А, это значит, что, смотри,
у нас может быть такое, что
из bn может быть
правило вида cd,
а из bn может быть правило va.
Ну, соответственно, либо то, либо то, в зависимости
от ситуации.
Ну что, товарищ,
мы победили с вами?
Вроде бы.
Да, ну тут спрашивается, почему
новых слов не появилось,
но опять же доказательство это будет аналогично
тому, как мы удаляем одиночные переходы
в автомат.
Так, ну получилась у нас нормальная форма
холмского, вроде бы.
То есть у нас убилось последнее правило,
из a следует bc, ну и все.
Ура, мы с вами доказали
переход
приведение к
нормальной форме холмского.
Какие тонкие моменты у нас с вами остаются
в этом алгоритме? Давайте я уточню.
Нам нужно показать некоторые сложности
алгоритмов.
Как это именно реализовывать?
Ну мы же практику тоже хотим понять.
Вопрос, как искать
непорождающие символы?
Ну, dfs, да, нам нужно
на самом деле найти все порождающие символы.
Как найти все порождающие символы?
Ну там такой аналог dfs.
Я тут
написал вкратце,
значит смотрите, закидываем множество порождающих символов
в множество тех порождающих символов,
все терминалы, для которых есть сразу
вывод, что справа идет конец слова.
Сразу он выводит слово, значит он автоматом
порождающий.
А потом, по сути,
для этой штуки нужно закидывать bfs,
то есть вы берете все множество
не терминалов,
которые есть. Смотрите,
из тех множеств не терминалов,
которые у вас сейчас есть на текущий момент, пытайтесь
собрать правую часть правила.
Если у вас правая часть правила
собирается целиком,
это там комбинация.
То есть,
давайте я напишу.
То есть, представим себе, что
у нас есть правило из a,
следует b, c, d,
и в сети есть, допустим,
b, c и d,
ну тогда мы a можем тоже
в это множество добавить.
Да, просто надо
этот bfs аккуратненько
реализовать.
Да?
Я думаю, вы понимаете,
как bfs писать.
Или надо подробнее.
Нет,
если есть вопрос,
задавайте.
То есть, сначала закидываем
все правила, в которых мы можем
закинуть все не терминалы,
то есть, которые сразу
являются порождающими за один шаг,
а потом мы собираем их
в множество и понимаем,
допустим, у нас сначала оказалось b в множестве,
потом через несколько литераций оказалось c в множестве,
потом через несколько литераций d оказалось в множестве,
так как сыграет правило,
из a следует bcd и это.
И мы получаем a.
Тогда a является порождающим.
Так, давайте дальше.
Удаление недостижимых символов.
Каким алгоритмом можно сделать?
Как найти все недостижимые символы?
Dfs от стартовой вершины.
Ну, bfs.
Найдем все недостижимые символы.
Ну, тут надо понять,
насколько эта рация остановится.
Ну, тут можно как раз, по сути,
построить граф
по не терминалам.
По сути,
если у вас из a есть правило bcd,
то вы ребра
так строите. Вы строите из a
b,
ребров c, ребров d.
И смотрите, в какие вершины
вы не попали в этом графе.
Вам нужно найти компоненту слабой связности
от стартового состояния.
Так, все знают
что такое компонент слабой связности?
Да, да, да.
Хорошо.
Эпсилон порождающий, как искать?
Ну, да.
А у нас еще есть алгоритм нахождения порождающих символов.
Да, давайте просто
допустим тот же самый алгоритм,
как нахождение порождающих символов,
только учитываем, что это именно
эпсилон порождающий символ.
Да, ровно так же.
Так, удаление
одиночных правил
это алгоритм транзитивного замыкания графа.
Вот у него сложность вот такая вот.
Количество не терминалов, то есть количество правил
повножено на сумму количества длин
лавовых частей.
Это сложность алгоритма всего приведения к нормальной форме Хомского.
Тут учитаны все асимпточки.
Ну, потому что DFS они достаточно простые.
Да, а вот перемножение как раз
составляется на нахождение транзитивного замыкания.
По-моему, я где-то тут квадрат забыл.
Да, тут квадрат. Тут третья степень должна получиться.
По-моему,
надо посмотреть.
По-моему,
количество вершин на количество ребер
количество ребер там
скорее всего у левой скобки
квадрат там стоит. То есть сложность алгоритма
количество P
плюс количество N в квадрате
на количество всех переходов.
Сумму длин всех правых частей правил.
Кто хочет
на практический поток, может потихонечку
начать его реализовывать.
Полез.
Ну, смотрите, давайте под конец я сегодня разбавлю вас.
Я хочу, сегодня мы успеем по крайней мере
одного проявления рассказать про него.
Первое, самое тупое проявление, которое
в нем состоит, это, наконец-таки, мы можем построить
с вами первый синтоксический парсер.
То есть алгоритм,
который по слову проверит
принадлежность его грамматики или нет.
Значит, смотрите, задача парсинга
состоит в том, что
по грамматике G
и слову V нам нужно ответить на два вопроса.
Первый вопрос, лежит ли слово
в языке, задаваемой грамматикой?
И второй, если ответ на предыдущий вопрос
положительно, то построить дерево разбора
дерева вывода для этой грамматики.
А теперь тупая идея.
Значит,
давайте, может быть, порассуждаем
доказательства.
Смотрите, вот у нас есть
правило,
из A выводится BC.
Да?
Если мы, допустим, у нас
есть A, и оно выводит
какое-то под слово
отвитого до житого символа,
не включая.
Тогда что мы можем с вами
сделать?
Как проверить, выводит ли символ A
под слово
отвитого символа до житого символа?
В счет того, что у нас есть
правило вида A, из A выводит BC.
А?
Перебрать среднюю границу, смотрите.
Вон там слово отвитого до житого символа.
Но смотрите, тогда нам нужно перебрать границу
КТ, что
вот это выводится из
B,
а вот это выводится из C.
Как такой тип алгоритмов называется?
А? Не-не-не,
это жёстко.
Нет.
Аналог задачи, задача
о количестве нахождения,
о быстром перемножении матриц,
которые у вас есть
в последствии с матриц в ряд,
вы хотите их быстро перемножить?
А?
Динамика.
Динамика почему?
Да, динамика по подотрезкам.
То есть на самом деле
нам нужно посчитать такую динамику.
Из A
следует под слово
отвитого до житого.
И будем хранить это в динамике.
Будут ошеляться перебор в динамике.
Но вы идёте по всем правилам грамматики,
которые выводят из A в B,
перебирайте все
определители и проверяйте,
выводится ли из B
по словам
ЖКТ,
АСС,
ой, и КТ.
Выводится
К
ЖТ.
Динамика
по длине слова
и динамике.
Да, даже больше ещё.
Вот,
я тут слово написал,
тут смотрите, динамика
по длине слова,
раз,
одна буква на переход, думал как-нибудь заменить.
Второе,
перебирается старт,
перебирается
правила грамматики и перебирается
средняя позиция. То есть, это не квадрата длины слова,
это куба длины слова.
То есть, грамматика
имеет
симптотику O длины слова в кубе
умножить на, опять же,
сумму правых частей правил.
Ну, давайте скажем,
что это просто количество правил
в грамматике.
Четвёртая степень, товарищи.
Ну, тут давайте я пропущу,
кто хочет может посмотреть,
индукция по длине слова,
я думаю, вы уже задолбались
от меня слушать слово индукции.
Вопрос, вы доказывали
динамику по водорезкам,
как работает?
Хоть раз в жизни своей.
Было такое?
Мне нравится такой ответ.
Ну, если что, я думаю, корректность алгоритм
вы можете показать.
Кратко объяснить.
Ну, идём индукции по длине слова.
Да, в одну сторону.
Если у нас из A вводится BG,
значит, у нас существует
разбор за одно правило.
Делаем индукционный переход,
победили.
По обратную сторону.
А, тут тех поехал.
A и G true,
значит, для некоторого
midposition у нас работал
вот этот вот этот.
14 строка обновления динамики.
Тоже переписываем,
получаем индукционный переход.
Это вкратце.
А симпточка от N в кубе на P.
И что у нас получается
от N в кубе на P?
Ну, дофига, в общем.
Долго.
Мы ещё в курсе...
А?
А, да, да, да.
Я ошибся.
Сорри.
О, длины слова в кубе на P.
Спасибо за опечатку.
Вот она, симпточка.
Мы будем рассматривать
более быстро алгоритмы
и для большого класса языков,
который используется также
в компиляторах, а симпточку
можно свести до...
Не поверите.
О, длины слова.
Ну, это долгий тернистый путь.
Вот.
Так, товарищи, у меня тут есть
ещё лемно-разрастание, но мне кажется,
что нам, я думаю, что лучше сегодня
чуть-чуть пораньше закончить
и спрашивать некоторые вопросы.
Но, смотрите,
практическое применение лемно-разрастания
это построение парсеров,
а теоретическое применение это будет
лемно-разрастание, с которым, я думаю,
мы начнём как раз в следующий раз.
Нашу пару.
Вот она.
Буковок чуть-чуть побольше появилось.
Да, да, да.
Ну, и идея, на самом деле,
ровно та же. Давайте,
раз уж пошло.
Короче,
нужно найти вот такую ерунду.
Вот и всё.
Находим такую ерунду,
сами понимаем, что
мы можем вот эту ерунду вставлять кучу раз
и получать разрастание.
Ну, формально мы это в следующий раз
с вами покажем.
Всё, на этом сегодня всё.
Спасибо.
