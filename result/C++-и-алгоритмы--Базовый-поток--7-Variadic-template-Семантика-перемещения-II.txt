Так, давайте начнем. Продолжим разговор прошлой лекции. Будем говорить про умные указатели,
ну и дальше построим некоторый мост к тому, что будем обсуждать в качестве новой темы сегодня.
Прежде всего хочется сказать, что на прошлой лекции мы сделали несколько ошибок, когда писали UniquePTR,
а вы все промолчали. А потом будете дизлайки ставить после экзамена. Что тут нужно исправить?
Мы писали UniquePTR, что нужно изменить? Во-первых, мы с вами обсуждали, что конструктор перемещения
и перемещающее присваивание должны быть noexcept. Пока по непонятным причинам, но вскоре мы поймем,
зачем это нужно. В общем, им всегда нужно приписывать noexcept. Это первое.
Второе, когда мы писали перемещающее присваивание, мы забыли в качестве первой строки сделать deletePTR.
Естественно, что когда вы присваиваете какой-то другой объект, старому объекту, то у старого объекта
нужно сначала удалить ресурс. Вот у вас был старый объект, он указывал на какой-то ресурс R.
И вы решили присвоить... есть какой-то другой ресурс, не знаю, x.
И вы решили... Adr, Vis. Если вы решили Adr присвоить Vis, ну точнее переместить Vis, то понятное дело,
что сначала нужно старый ресурс удалить и только потом забрать чужой ресурс.
Ну и надо разделать noexcept. OK.
Тогда давайте продолжим и вспомним то, на чем остановились в прошлый раз.
В прошлый раз мы остановились на проблеме циклических ссылок. Напомню.
Допустим, вы решили написать класс двухсвязанного списка и при этом использовать умные указатели sharedPTR.
SharedPTR — это умные указатели, которые используют семантику разделяемого владения,
то есть на один и тот же ресурс могут указывать сразу несколько умных указателей.
Тогда с помощью подсчета ссылок они следят, сколько в данный момент указателей указывает
на тот или иной объект, и если в какой-то момент число умных указателей
на данный объект обнурилось, мы удаляем сам объект.
Мы можем написать класс связанного списка, для этого мы пишем ноду.
То есть говорим, что есть указатель на следующий элемент, есть указатель на предыдущий элемент,
точнее значение, которое мы храним внутри узла.
У нас возникает следующая проблема.
Один из sharedPTR указывает на один элемент, и этот же элемент списка указывает на предыдущий.
Получается такая замкнутая система, которая указывает сама на себя.
То есть один узел указывает на второй узел, а второй указывает на первый узел.
В этом случае понятное дело, что, во-первых, не вызовется деструктор для первого узла.
Почему? Потому что на него все еще есть какие-то действующие ссылки.
И понятное дело, что не вызовется деструктура второго узла, потому что первый узел держит второй,
а второй узел держит первый.
Поэтому у нас возникает, грубо говоря, утечка памяти.
Причем такая утечка памяти, которая никак не фиксится.
Это проблема циклических ссылок.
Если sharedPTR, грубо говоря, указывает сам на себя, то возникает проблема.
Как эта проблема решается?
Решается проблема с помощью третьего умного указателя.
Это weakPTR.
Как мы говорили в прошлый раз, weakPTR – это такой умный указатель, который не учитывается при подсчете сильных ссылок.
То есть weakPTR имеет право указывать туда же, куда указывает sharedPTR,
но при этом он не является полноправным владельцем этого ресурса.
То есть он этим ресурсом не владеет, соответственно, при подсчете ссылок учитываться не должен.
Соответственно, как исправить пример связанным списком?
Очень просто.
Один из указателей, например, который смотрит вперед, мы делаем sharedPTR,
а тот указатель, который смотрит назад, мы делаем weakPTR.
То есть слабым указателем, который не учитывается при подсчете ссылок.
Тогда все нормально.
Вот этим узлом владеет предыдущий, а предыдущим следующий не владеет.
Поэтому если, скажем, у нас удалились все указатели на начало и конец,
то на этот узел указывает ноль указателей, на этот узел указывает один указатель.
В тот момент, когда у первого узла счетчик замудрился, мы вызываем для него деструктор.
А когда мы вызываем деструктор для первого узла, у нас вызывается деструктор для sharedPTR.
Ну а sharedPTR просто-напросто убирает счетчик и говорит, тут ноль.
Ну и, соответственно, и так далее. По рекурсии у нас все элементы списка удалятся.
Понятно? То есть циклических ссылок теперь нет.
Давайте теперь по-другому поговорим про weakPTR, что это такое.
Как я сказал, weakPTR на самом деле не владеет тем ресурсом, на который он указывает.
И, строго говоря, weakPTR нельзя считать указателем.
Потому что что мы на самом деле ожидаем от указателя?
От указателя мы ожидаем, что его можно, наверное, разаменовать,
и в некоторых ситуациях можно обратиться по стрелочке.
То есть можно сделать стрелочки и обратиться к чему-то.
Вот weakPTR не такой.
weakPTR не дает вам вообще, говоря ничего, не дает вам обратиться к ресурсу.
weakPTR вообще, говоря ничего, не знает про ресурс.
Вначале что-то знает, но вам об этом не говорит.
weakPTR не служит для того, чтобы, первое, узнать, протухли ресурс или нет.
То есть weakPTR смотрит на память и говорит вам, вот этот ресурс, он как бы еще жив или уже нет.
И, во-вторых, он может вам дать право пользоваться этим ресурсом, вернув вам sharedPtr.
То есть, грубо говоря, есть два важных метода для работы свикптр.
Это expired, ну, собственно, дословно, протух элемент, пропал элемент,
который возвращается в untrue или false.
То есть false, если элемент уже протух, а в какой момент элемент протух?
Ну, например, вот такой.
Значит, вот у вас есть какой-то ресурс r.
Есть sharedPtr, который указывает на него, есть wikPtr, который указывает на него.
Если вот на этот ресурс нет ни одного sharedPtr, то есть все sharedPtr уже умерли,
то есть все сильные ссылки на этот ресурс уже как бы пропали,
то в этот момент wikPtr возвращает вам false.
Ну, не wikPtr, а, собственно, метод expired.
Expired возвращает вам false.
А если сильная ссылка жива, хоть какая-то,
то он возвращает вам true.
В чем отличие expired от не expired?
Ну, и в случае, если у вас expired, собственно, равно false,
то есть если объект жив, то вы можете попросить у него вернуть вам новый sharedPtr на этот объект
с помощью метода log.
Ну, то есть как это выглядит?
Снова у вас есть ресурс r, на него указывает какой-то sharedPtr,
на него указывает какой-то wikPtr.
Ну, давайте s1.
Если вы понимаете, что данный ресурс еще жив,
и вы хотите к нему как-то обратиться через wikPtr,
вы можете у wikPtr позвать метод log,
и этот метод log вернет вам новый sharedPtr,
который указывает на тот же самый ресурс.
И уже с этим sharedPtr вы можете делать, что хотите.
Можете обращаться там по стрелочке, можете его разуменовывать и так далее.
Понятно? То есть wikPtr напрямую не дает вам права пользоваться ресурсом.
Он лишь вам может выдать такое право,
если вы его попросите.
А что если вы позовете log у протухшего указателя?
Как вы думаете, что произойдет?
Ну, какое бы поведение вы бы ожидали?
Что?
Ce?
Да, ну nullPtr.
Соответственно, если вы просите log у уже протухшего указателя,
то он возвращает вам nullPtr.
Ну, грубо говоря, sharedPtr на nullPtr.
Нормально?
То есть он возвращает вам умный указатель на нулевой указатель.
Значнее, умный указатель, который ведет в никуда.
Вот.
Такой wikPtr.
Теперь главный вопрос.
Ну, соответственно,
а как wikPtr все-таки понимает, жив объект или нет?
Ну, смотрите, в чем проблема?
Вот у вас есть ресурс снова.
У вас есть sharedPtr, который указывает на этот ресурс.
Есть wikPtr, который указывает на этот ресурс.
Вот, допустим, sharedPtr умер.
Что делает sharedPtr?
Что происходит, когда все sharedPtr умирают?
Ресурс удаляется, да. То есть мы ресурс удалили.
Но у нас есть живой еще wikPtr.
А как wikPtr поймет, жив ли ресурс или нет?
Это решает другую проблему. Да.
Ну, да. Наверное, хотелось бы, чтобы wikPtr просто выставился в ноль. Вы про это.
А как вот этот sharedPtr при удалении сможет wikPtr что-то выставить?
Тем более, что у нас wikPtr потенциально может быть очень большое количество.
Вот этот sharedPtr уже не знает про существование всех wikPtr.
Поэтому он у них всех не может зановить указатель.
Поэтому это не решение.
Что у нас еще хранится, помимо указателя на сам ресурс?
В sharedPtr.
Счетчик. Счетчик сильных ссылок. Каунтер.
Ну и действительно, соответственно, решение заключается в том, чтобы wikPtr,
то есть wikPtr, на самом деле, помимо того, что он указывает на ресурс,
он еще указывает на счетчик.
И вот по этому счетчику, по значению этого счетчика, wikPtr как раз и может понять,
собственно, жив объект или нет. Как?
Если счетчик не нулевой, если счетчик...
Здесь количество сильных ссылок на этот объект еще не ноль,
то значит объект не протух.
А если счетчик стал равным нулю, то объект протух и им пользоваться нельзя.
Нормально или есть какие-то подводные камни?
Отлично. Все поняли?
Смотрите, wikPtr, на самом деле, в данной конструкции wikPtr никогда не сможет увидеть нулевой счетчик.
Почему? Потому что в тот момент, когда у меня умирает последний шар от Ptr,
в том алгоритме, который мы обсуждали в прошлый раз,
он удаляет не только сам ресурс, но и удаляет счетчик.
Поэтому wikPtr в этот момент будет пользоваться не то что протухшим объектом,
но даже протухшим счетчиком.
Беда.
Как решить эту проблему?
Отлично. Давайте хранить еще один счетчик. Нормально.
Действительно, давайте в одном месте, я так изображу.
Strong и wik.
Действительно, решение такое, давайте помимо сильного счетчика,
давайте дополнительно хранить еще счетчик слабых ссылок.
То есть у нас будет отдельно strong counter и отдельно wik counter.
Их, естественно, лучше объединить в одну структуру, чтобы не было 3 разных указателя.
То есть грубо говоря, мы заводим структ.
Он обычно называется контрольный блок,
можно назвать просто блок,
в котором мы будем хранить sizeT strong и sizeT wik.
Без подчеркиваемых.
Все, и внутри shardptr вы храните просто-напросто указатель на блок.
И у блока можете спросить число сильных ссылок strong или число слабых ссылок wik.
То есть счетчик strong, счетчик сильных ссылок хранит вам количество shardptr,
которое указывает на данный объект,
а wik хранит количество слабых ссылок, которые хранит данный объект,
которые указывают на этот объект.
Окей, ну хорошо, завели еще один счетчик.
То есть тут один, тут один.
Что происходит, когда я удаляю shardptr?
Ну, количество сильных ссылок у меня зануляется.
Что происходит дальше?
Да, так у меня число сильных ссылок занудилось,
это значит, что все владельцы данного ресурса уже как бы пропали.
Поэтому я со спокойной совестью могу вызвать delete ресурс, то есть deleteptr.
А что я должен сделать со счетчиком?
Должен я удалять счетчик?
Нет, почему?
Потому что счетчик, вот здесь мы видим,
что помимо strong count, то есть strong count 0 равен 0,
но при этом есть wik counter,
который говорит, что кто-то все еще на этот счетчик указывает.
То есть есть какой-то wikptr,
который пользуется этим счетчиком,
поэтому этот счетчик удалять рано.
Окей, а кто должен удалять счетчик?
Ну, в данном случае wikptr, да.
В данном случае, когда у меня удалится wikptr,
он занулит wik counter,
и он увидит, что число слабых ссылок и,
самое главное, сильных ссылок равно 0,
поэтому я спокойно могу удалить счетчик.
Счетчик, окей?
Поэтому общий алгоритм, ну давайте пропишем
как-то в каком-то псевдокоде,
выглядит примерно так.
Условно, давайте внутри shardptr.
Условно я опишу, что если
strong
если число сильных ссылок равно 0,
то я делаю deleteptr.
Ну, ptr указывает на ресурс.
Вот.
Ну и что дальше?
Достаточно этого или еще что-то надо сделать?
Да, во-первых,
понятное дело, надо еще сделать
минус-минус блок
strong, то есть перед тем, как проверять
на ноль, нужно еще сделать
минус-минус счетчика.
Так, что еще нужно сделать?
Ну, точнее, здесь еще
можно, например, внутри,
лучше добавить, что если
дополнительно, то есть понятное дело, что
если число сильных ссылок обнулилось,
то мы удаляем ресурс.
Но плюс нам еще может понадобиться удалить счетчик,
в каком случае? Если дополнительные числа
слабых ссылок тоже равно 0, согласны?
То есть если блок
weak равно равно 0
дополнительно,
то я должен еще сделать delete
блок.
Все понятно?
Ну, и внутри WIC-PTR
там
логика только
со слабыми счетчиками.
Что мы делаем в WIC-PTR?
Ну, понятное дело, мы делаем минус-минус
от блок
WIC, то есть уменьшаем
количество слабых ссылок.
И что делаем?
Вот, все понимают,
что если сумма сильных и слабых ссылок
равно 0, то мы удаляем счетчик.
Не достаточно проверить только слабые ссылки.
Понятное дело, что нужно проверить вообще все ссылки.
Давайте сразу напишу
strong
plus weak
равно равно 0,
то мы делаем delete
блок.
Все.
Заметьте, в WIC-PTR не должно быть
логики управления ресурсом, то есть
WIC за ресурс вообще не отвечает.
То есть в WIC-PTR мы не имеем права написать.
Потому что WIC-PTR это слабый указатель,
он не владеет ресурсом.
Ну вот, собственно,
примерно так.
Разбрались?
Ну и последний пункт
по умным указателям
это функции
std
makeunique
и std
makeshard
Что это за функция?
Ну смотрите, когда мы ввели умные указатели,
мы избавили себя от необходимости написать delete.
Но тем не менее у нас
все еще есть необходимость писать new.
Ну для того, чтобы создать умный указатель.
То есть как выглядит создание умного указателя?
Мы пишем std
unique
ptr
p
int
и вот этот, собственно, умный указатель.
То есть new int.
То есть от необходимости писать delete мы избавились,
но все еще необходимо писать new.
Ну, во-первых, это асимметрично.
То есть вроде как мы
с самого детства, точнее с первого семестра,
привыкли, что на каждое new нужно писать delete.
А тут как бы есть new,
но при этом delete нет.
Это первый момент.
Второй момент, если вы используете,
если вы сами внутри своей программы используете ручное управление памятью,
то все еще возникают
сложные проблемы.
Ну, мы в прошлый раз, например, обсуждали, что если вы внезапно,
то есть не внезапно, а если в какой-нибудь момент вы сохраните
какой-нибудь указатель,
какой-нибудь сырой указатель на выделенную память,
то вы можете создать unique ptr.
Давайте тут, бла-бла-бла, ptr1
от p
и потом можете там забыть или как-то
на p может пропасть, может утечь какая-то косвенность,
то есть p вы можете куда-то скопировать
и так далее, и забыть, что вы этот
p на самом деле обернули в какой-то умный указатель
и даже спустя какое-то время обернуть его
второй раз.
Беда.
Если вы один тот же указатель обернули в два умных указателя,
ну, в два разных умных указателя,
то проблема.
У вас возникает двойное удаление.
Один раз при уничтожении одного умного указателя,
второй раз при уничтожении второго умного указателя.
Это первая проблема.
Вторая возможная проблема
на самом деле, она в современных прессах уже пофикшена,
но вообще говоря, если вы используете c++14 или ранее,
то есть следующая
беда.
Представь себе, что у вас есть функция, которая принимает два умных указателя.
Ну и я просто-напросто делаю следующую вещь.
Я туда передаю std unicptr от int new int.
Вот, это первый аргумент. И в качестве второго аргумента передаю то же самое.
Unicptr от int, ну и какое-то другое new int.
В чем здесь может быть проблема?
Проблема довольно интересная и довольно неожиданная.
Смотрите. Дело в том, что DOSI++17, DOSI++11, DOSI++14 и более ранние версии, они,
вообще говоря, в данном примере они не задавали строго порядок вычисления
операндов и порядок вычисления операндов внутри операндов.
То есть, грубо говоря, что у вас могло произойти?
Чисто теоретически у вас может произойти следующее.
Сначала у вас вызывается операция new int, которая находится в первом аргументе.
Ну или во втором аргументе, неважно.
Вот допустим, произошел new int в первом аргументе.
А потом, то есть компилятор вообще раньше не гарантировал, что вот это вот выражение,
которое стоит здесь, оно будет вычисляться полностью.
Он может частично выполнить new int, то есть выделить память,
а потом перейти и выделить память для вот этого new int.
Ну, например, компилятор так соптимизировал, ему так удобнее.
То есть ему гораздо выгоднее, например, вызвать два раза подряд new,
чем сначала вызвать new, потом конструктор ptr, потом снова new и ptr.
То есть он мог сначала вызвать первый new, потом второй new,
и только во вторую очередь вызвать конструктор этого new ptr и конструктор этого new ptr.
В чем может быть проблема вот в таком сценарии?
Ну, например, самое простое, что может произойти, это вот вы вызвали тут new,
а для второго new у вас, допустим, памяти не хватило.
И, на самом деле, когда происходит какая-то нештатная ситуация,
она как бы не сразу приводит к завершению программы,
вы, в принципе, можете эту ситуацию обработать.
То есть если вы понимаете, что вам памяти не хватает,
вы, грубо говоря, можете, мы об этом будем говорить уже в следующий раз,
вы можете обработать эту ошибку и продолжить работать дальше.
Но вот какая проблема.
Допустим, вот эта штука отработала нормально, а вот здесь пошло что-то не так.
Ну, у вас не хватило памяти.
Даже если вы эту ошибку обработали, что у вас произошло?
У вас произошла утечка памяти. Почему?
Потому что вот этот new, вот этот указатель, вы никуда не сохранили.
Он у вас создался, подставился вместо вызвана, при этом сам unique ptr вызвал не был.
А так он вызван не был, то понятное дело, что для него и деструктор вызван не будет.
Понятно?
То есть у вас один ресурс выделился, второй не смог выделиться,
и первый провис, то есть первый утек, ну совсем.
Опять же, повторюсь, что в 17 стандарте это уже не ошибка,
потому что там уже есть более строгая гарантия,
что у вас каждый оперант вычисляется, грубо говоря, атомарно.
То есть без вычислений одного из оперантов следующие не вычисляются.
На тем не менее такая проблема была.
Так вот, чтобы победить эту проблему, были в язык введены следующие функции makeUnique и makeSharif.
Значит, как они работают?
Давайте еще раз повторим.
Вот, допустим, у вас есть std unique ptr на какую-нибудь структуру A.
На какую-нибудь структуру A указатель p.
Значит, вы создаете объект, ну примерно вот таким способом A, X, Z.
Ну что здесь происходит?
Вы выделяете в памяти объект A с помощью параметра конструктора X, Y, Z.
То есть вы передаете в конструктор A параметры X, Y, Z и создаете новый объект в куче.
И создаете на него умный указатель.
Как выглядит тот же самый код, но с использованием makeUnique?
Очень просто. Вы делаете следующие вещи.
Aftp равно std makeUnique, тут треугольные скобки, makeUnique от A.
И передаете в параметры этой функции X, Y, Z.
То есть что такое makeUnique?
makeUnique – это шаблонная функция, которая в качестве шаблонного параметра
принимает тип, на который нужно создать uniquePTR.
То есть давайте с самого начала.
makeUnique – это функция, которая порождает новые умные указатели.
То есть makeUnique возвращает uniquePTR.
В качестве шаблонного параметра она принимает тип,
с которым нужно создать uniquePTR.
В данном случае makeUnique от A вернет вам std uniquePTR от A.
А что она принимает в качестве параметров?
Она принимает параметры параметров.
А в качестве параметров внезапно она принимает параметры конструктора,
которые нужно будет передать в A.
То есть вот тут параметры конструктора A.
Грубо говоря, эта вторая строка дословно повторяет то же самое, что здесь.
Но при этом она лишна недостатка, в котором мы описали до этого.
В той строке вы не пишете вручную new.
То есть вы вызываете просто некоторую функцию makeUnique,
которая вам возвращает нужный uniquePTR.
То есть new вы вручную не пишете.
И из этого же следует решение второй проблемы.
Так как вы не пишете new, то все выделение происходит внутри функции makeUnique.
И эта функция makeUnique, если там внутри что-то идет не так,
она сама может почистить всю нужную память и продолжить нормальную работу.
Вот такие дела.
Ну и, собственно, аналогично есть функция std makeShared,
который работает... принцип работы которой такой же.
Она принимает нужный вам тип и принимает аргументы конструктора x, y, z.
Правда, тут при этом есть небольшая тонкость,
что получается в том, что makeShared на самом деле действует немного иначе.
Ну давайте об этом тоже поговорим, чтобы была полная картина.
Что происходит, когда вы создаете sharedPTR от какого-нибудь new int?
Ну что у вас происходит?
У вас вот этот указатель, то есть у вас есть некоторый int,
вот этот указатель сохраняется в поле PTR,
и при этом выделяется блок, собственно, счетчики,
на которые указывает поле блок.
И вот эти два ресурса, то есть то, что вы выделили,
и счетчик, и счетчики, они лежат абсолютно в разных частях памяти.
Понимаете ли вы, к чему это может привести, в чем потенциальная проблема?
Ну потенциальная проблема на самом деле в неэффективности.
То есть обращение к разным участкам памяти,
то есть так называемые прыжки по памяти, они довольно неэффективны.
Ну то есть, грубо говоря, что нужно делать вашему компьютеру?
То есть когда вы обращаетесь к одному участку памяти,
он, понятное дело, он загружает не только ту ячейку памяти, которую вы просили,
то есть не только 4 байта, то есть как бы он не дурак,
он как бы берет сразу большой кусок и загружает там в кэш.
И дальше при работе с этим кэшом все происходит гораздо более эффективнее,
потому что вам не нужно заново лезть в оперативную память.
И это происходит, если у вас все переменные расположены в одной и той же области памяти.
Например, это стековые переменные, или, например, если это динамический массив.
То есть в динамический массив вы можете сразу загрузить несколько ячей к памяти
и работать с ними подряд.
Это гораздо эффективнее, чем просто прыгать по массиву.
Можете в этом убедиться, там поставятся соответствующие эксперименты.
Если вы обращаетесь к разным участкам памяти,
которые расположены потенциально на большом расстоянии друг от друга,
то у вас происходит следующая вещь.
Когда вы обращаетесь к ресурсу, вы загружаете какой-то кусок памяти в кэш.
Когда вы обращаетесь к другой, то есть к блоку,
вам снова нужно взять и этот кусок памяти загрузить в кэш.
Понятно дело, что это все работает за единицу,
но вообще говоря это работает сильно дольше,
чем если бы вы взяли и все единым блоком занесли в кэш и с ним работали.
Ну и такая чисто техническая деталь, надеюсь, понятна.
И поэтому MakeSharad, он это учитывает
и делает на самом деле умнее.
Вот у MakeSharad, когда вы пишете просто sharedptr от new что-то там,
то есть у конструктора нет ни единого шанса выделить все единым блоком.
Потому что вы этот int выделили где-то в одном месте,
и он не может просто так взять и блок приписать сюда.
Ну по понятным причинам.
Потому что вы выделяете память с помощью new,
у вас операционная система что даст, то даст.
А вы этим никак не управляете.
Тем не менее MakeSharad может это сделать.
Что делает MakeSharad?
MakeSharad просто-напросто берет и сразу выделяет единым куском
нужное количество памяти для хранения ресурса
и для хранения блока.
То есть он сразу выделяет столько bytes, сколько им нужно
для хранения и ресурса, и блока,
и дальше в первой части хранит ресурс,
а в второй части хранит блок со счетчиками.
Это получается более эффективно по времени использования.
У этого тоже есть, собственно, свой минус.
И он связан с тем, что
при условии, что если у вас есть еще и WeakPtr,
то вот представьте, что у вас есть и SharePtr,
который указывает сюда,
и WeakPtr, который указывает сюда.
Когда у вас удаляется SharePtr,
он, естественно, может удалить ресурс.
Он может вызвать деструктуру ресурса.
Но при этом вот весь большой кусок памяти
он удалить не может. Почему?
Потому что весь большой кусок памяти
он выделял единым блоком,
грубо говоря, с помощью new.
И поэтому удалить его тоже можно только
с помощью единой операции delete.
И поэтому пока у вас жива WeakPtr,
вот этот вот участок памяти,
он так и будет висеть у вас в памяти до тех пор,
пока все WeakPtr не удалятся.
В этом подходе такой проблемы нет.
Вы можете сразу удалить там и память,
и ресурс, и все будет нормально.
Так что тут есть такой вот трейд-оп
между тем, что у вас все работает быстрее,
если вы используете такой подход.
Но с другой стороны у вас работает
как бы, возможно, потенциально неэффективно
по памяти, потому что у вас вот этот ресурс
может висеть совместно с этим блоком,
пока все WeakPtr не удалятся.
Ну, это же такие-таки
технические детали. В общем, если что-то понятно
хорошо, если нет, то ну...
Ну и ладно.
Надеюсь, все понятно, да?
Все нормально?
Окей.
Ну, видимо, на этом
с умными указателями все.
Единственное надо было сделать дисклеймер,
про который я забыл. Вот на самом деле
писать всякие
деревья, всякие списки
на умных указателях, это
честно говоря, не очень хорошая идея.
Ну, точнее как. Это нормальная идея,
но следует помнить вот о чем.
Ну, давайте так.
Давайте представим себе, что вы написали
односвязанный список.
Односвязанный список на умных указателях.
Чем хорошо
используется списка
на умных указателях?
Ну, вам не нужно писать деструктор, согласны?
Ну, потому что когда у вас
будет вызван деструктор, у вас автоматически вызовется
деструктор у умного указателя, который
там владеет, собственно, началом списка.
И дальше рекурсивно у вас вызовется
деструктор для всех умных указателей.
И весь список автоматически
удалится.
Тут, возможно, проблема какая?
В чем проблема вот такого
рекурсивного удаления?
Ну нет, такого мы не можем сделать.
У нас как бы удаление в деструкторе запустится
только. Ну, по идее.
Чему обычно равен размер списка?
Ну, необычно, но вот потенциально.
Ну, долго...
Если у вас большой список, у вас как бы удаление долго
это как бы априори.
То есть, тут вы физику не обманете.
Тут проблема другая.
Вот, допустим, у вас список на миллион элементов.
В чем проблема такой рекурсии?
Стэк оверфлоу.
Ну, грубо говоря, у вас размер стэка ограничен.
Там, ну,
если у вас большой список,
то размер стэка ограничен.
Короче, точно не миллион.
То есть, точно миллион рекурсивных вызовов
деструктора он не выдержит.
Поэтому вот такое вот рекурсивное удаление
может привести к стэку оверфлоу и беда.
Поэтому даже если вы
держите умные указатели
на элементы списка,
то деструктор для списка, к сожалению,
все еще нужно писать вручную.
Ну, для того, чтобы избежать вот такого рекурсивного вызова.
То есть, вы просто-напросто вручную прописываете цикл,
в котором в цикле проходите по всем элементам
и, грубо говоря, очищаете эти самые умные указатели.
Понятно?
Поэтому
будьте осторожны.
Есть такая проблема.
Хорошо.
Теперь давайте перейдем к
теме сегодняшних
лекций, то есть,
о чем я хотел сегодня поговорить.
И, в общем, эти темы, они тесно связаны
с тем, что есть на этом слайде.
Смотрите, давайте обратим внимание
вот сюда.
Вот, когда я написал такую штуку,
у вас должно было
взыграть,
ну, если не любопытство, то хотя бы
программатизм. Вы могли сказать,
у нас задание
есть в качестве одной из частей
написать Make Unique и Make Sharad.
И у вас мог возник вопрос какой?
Что?
У нас должен быть
возник вопрос, а как?
Как реализовать функцию
Make Unique?
Смотрите, это довольно странная функция.
Потому что...
Давайте попробуем
написать.
Я пишу Make Unique.
Вроде как утверждается,
что она шаблонная.
template
class
t. Она шаблонная.
Она должна делать
return,
track.
Здесь моя Make Unique птеро t.
Вродеsee, с этим проблем нет.
А что она принимает?
Я сказал что она принимает параметры
конструктора t,
то есть в данном случае параметры конструктора A.
А откуда Make Unique
знает какие параметры у конструктора A?
Ну, потенциально у A
какие могут быть параметры? У A
может быть 0 параметров.
У А может вообще много конструкторов.
У А может быть metric с yyim параметром,
с одним параметром, с двумя параметрами, с тремя.
Может быть, copy-конструктор, может быть, move-конструктор.
И все эти опции makeunique,
вообще говоря, должен поддерживать.
То есть, вообще говоря, makeunique
должен уметь принимать
произвольное количество аргументов.
Вас это не шокирует?
Нет?
Все нормально.
Как написать функцию,
которая принимает произвольное количество аргументов?
Хоть пять, хоть десять, хоть сто.
Понятное дело, что вручную
из двух функций мы писать не будем.
И вот как мы это будем делать,
сейчас об этом поговорим.
Значит,
шаблоны с переменным
числом аргументов
или variadic-templates.
Ну, проблемы я уже обрисовал.
Мы хотим написать функцию,
которая работает примерно так же,
как makeunique или std.printf.
Вот printf еще один пример функции,
уже из языка C,
который может принимать
произвольное количество аргументов.
То есть вы пишете какой-то формат строку,
то есть в каком формате вам нужно вводить данные,
и дальше через запятую указываете те данные,
которые нужно вводить на экран.
И при этом printf может принимать произвольное количество аргументов.
Вот как она работает?
Ну, пока непонятно.
Makeunique, то же самое.
Вот как раз тот пример, про который я говорил.
У A может быть потенциально много конструкторов.
В данном случае у меня все параметры конструктора
здесь они дефолтные.
То есть я потенциально вот этот конструктор
могу вызывать с нулем числом аргументов,
с одним аргументом, с двумя, с тремя.
И при этом каждый из makeunique при этом работает.
Как это работает?
Ну, пока непонятно.
Один слайд,
чисто для истории,
это экскурс
в язык C, мы этим пользоваться не будем.
В языке C
функции с произвольным числом аргументов
пишутся следующим образом.
То есть произвольное число аргументов
указывается с помощью специального оператора
многоточий или эллипсис.
То есть он выступает в качестве
последнего параметра функции
и носит некоторый особый смысл.
То есть это троеточие означает, что вот туда
вы можете загнать все что угодно
и произвольное количество аргументов.
Как всем-всем пользоваться? На самом деле не очень удобно.
Делается это так.
Вы заводите специальную переменную,
которая имеет тип va list.
То есть в вариаде arguments list.
Список произвольного числа аргументов.
Дальше вы пишете
специальную функцию va start,
которая грубо говоря
инициализирует этот список.
То есть она использует какую-то магию,
и все аргументы, которые передали,
она берет и запихивает в некоторый список.
При этом вы должны заранее знать размер этого списка,
что уже как бы наталкивает на мысль,
что это не особо удобно.
То есть вы должны заранее указывать,
какое количество аргументов вы туда передали.
Или как-то ваши функции должны быть поднимать.
Вы туда не передаете количество аргументов,
но при этом printf понимает, сколько аргументов нужно и принять
с помощью вот этих вот...
с помощью вот этой последовательности.
То есть тут вы говорите,
что printf должен вывести на экран три значения.
То есть целое значение,
значение с плавающей точкой и строку.
Поэтому функция printf ожидает от вас три аргумента.
Идем далее.
Ну и дальше, например, в цикле, если вы пишете функцию print int,
которая печатает на экран int,
то здесь есть следующая вещь.
Ну, собственно, в цикле вызываете va-arq,
ну va-arq возвращает вам очередной аргумент функции.
То есть вот вы инициализировали список,
и с помощью va-arq вы получаете очередной элемент вашего списка.
При этом вы должны явно указывать,
опять же довольно странно,
вы в качестве параметра функции указываете еще и тип.
В общем, это совсем что-то дикое.
Короче, вы должны прям четко знать,
какой тип вам пришел.
В данном случае мы откуда-то знаем,
что нам приходит только int.
Поэтому мы тут пишем int.
Ну и дальше вводим на экран.
Ну и дальше по завершению работы мы должны не забыть написать va-end.
То есть мы закончили работу со списком,
заканчиваем работу.
Ну и то же самое с sum-doubles,
то есть если вы хотите посчитать сумму чисел с плавающей точкой,
ну примерно такой же ситексис тоже сначала.
va-list, va-start, va-end, va-arq и так далее.
Мало того, что это работает долго,
так это еще не очень удобно.
Ну опять же, по причине того,
что вам нужно явно знать количество аргументов,
вы должны явно знать типы аргументов,
которые вам передали,
чтобы их можно было использовать в функции va-arq.
Мы воспользуемся другим способом,
который актуален
непосредственно для C++,
но вот каким мы поговорим после перерыва.
Как в C++ мы пишем функции, которые принимают
произвольное количество аргументов?
Для этого в C++ есть специальный
синтаксис шаблонов.
То есть функции с переменным числом
аргументов пишутся с помощью шаблонов.
И вот каким образом.
Для того, чтобы указать,
что вы хотите принять произвольное количество
аргументов,
вы в качестве шаблонного параметра
должны принять специальный тип,
ну как тип, даже пакет типов,
который вы объявляете с помощью
класс и дальше многоточие.
То есть если вы в качестве шаблонного параметра
объявляете класс, многоточие
и дальше пишете имя
пакета типов, обычно его называют
args, то есть аргументы,
то вы говорите, что в данном args
будут сохранены
типы аргументов,
которые вы передали в эту функцию.
И дальше вы пишете следующую вещь.
Соответственно вы пишете обычную функцию,
то есть print, дальше что она принимает,
в качестве первого аргумента она принимает
ссылку на поток,
то есть куда нужно выводить результат.
И дальше вы пишете следующую вещь,
чтобы объявить аргументы,
точнее пакет аргументов,
которые будет принимать функции,
то есть вы должны написать args многоточие,
арг, который вы объявили в template.
Ну и дальше как это вы называете?
Называете пакет аргументов.
Понятно?
То есть первый момент это класс многоточия,
второй момент при объявлении
параметра функции вы пишете args
и приписываете туда многоточие.
Или не args, а любое имя, которое вы дали
пакету параметров.
Ну и то же самое, если вы хотите
написать функцию для суммы,
у вас сумма может
принимать произвольное количество аргументов,
вы пишете класс многоточия args,
и принимаете тоже args многоточия args.
Здесь мы это не обсуждали,
но я тут специально писал авто.
Авто можно писать еще и у типа
возвращаемого значения функции.
Это будет означать,
короче, функция сама в выведе,
что ты возвращаешь.
Если пишешь шаблонную функцию сам,
то вообще говоря непонятно,
что она возвращает.
Если вы передали все int,
то результирующий тип тоже непонятен,
поэтому мы и говорим,
что компилятор сам решает,
что тебе надо вернуть.
В данных примерах args с большой буквы
это пакет параметров типов,
а args с маленькой буквы
это пакет параметров функций.
То есть у нас есть два пакета.
Первый пакет — это все типы,
которые принимает у меня функция,
и второй пакет — это аргументы,
которые имеют соответствующий
параметр параметров функций.
Второй пакет — это аргументы,
которые имеют соответствующие типы.
Ну и если вдруг мы как-то смогли
написать эти функции принты сам,
то их спокойно можно будет вызывать
вот таким образом,
с произволом количеством аргументов.
То есть первый вызов вам будет
выводить на экран все переданные аргументы,
а вторая функция будет вам суммировать
все то, что вы туда внутрь передали.
Синтактиз понятен?
Объявление функций? Хорошо.
Несколько правил.
Несколько правил
использования пакета параметров.
Значит, пакеты параметров
можно использовать не только
в качестве шаблонных функций,
но и в качестве шаблонных классов.
То есть в принципе вы можете написать
классы, на которые тоже принимает
произволенное количество параметров.
И делается это абсолютно точно так же.
То есть у вас может быть класс,
который в качестве шаблонного
аргумента принимает один тип
и плюс какое-то произвольное количество
При этом пакет параметров, то есть параметры с произвольным количеством аргументов,
могут идти в шаблонных классах только в последнюю очередь, то есть только в самом конце.
То есть нельзя написать вот так, а потом написать какой-то еще класс T.
То есть если универсальный класс многоточит, то это может идти только последним параметрам.
То есть только в конце.
Ну и как это работает? Соответственно, если вы инстанцируете MyClass с помощью просто int,
то что у вас происходит? У вас в качестве tpt выводится, естественно, int,
а в качестве args выводится пустой пакет параметров.
То есть пустой пакет параметров тоже допустим.
Ну и если вы передали int, char и float, то у вас в качестве t выводится тип int,
а в качестве args выводится список из char и float.
То есть пакет параметров шаблона содержит char и float.
Именно в таком порядке, что бы это ни значило.
Дальше. Шаблоны функций вы можете...
Шаблоны функций мы уже обсудили.
Тут, в отличие от шаблонных классов, вы можете писать пакеты параметров в произвольном порядке.
То есть вы можете сначала написать класс многоточия args, а потом класс t.
Можете написать наоборот, как мы показали до этого.
Но в данном случае это неважно. Почему? Потому что функции, как правило, умеют выводить собственные типы.
Ну а для вывода типа это не особо важно.
Ну и также вы можете поменять местами args и t.
Ну собственно, пакет параметров, который идет...
Ну вы можете написать пакет параметров либо в конце, либо в начале.
Дело в том, что если вы напишете вот так, то компилятор-то вам позволяет это сделать.
Но вот вызвать у вас это не получится.
По следующей странной причине.
Дело в том, что пакеты параметров, они очень жадные.
Вот. Если компилятор в какой-то момент встретил пакет параметров,
то вот этот пакет параметров будет выбирать себе все, что попадется ему на пути.
И никому он ничего не оставит.
То есть, грубо говоря, вы тут, наверное, планировали следующее поведение.
Если вы хотите, чтобы у вас функция принимала...
То есть у вас функция в качестве последнего аргумента была t и x.
То есть t и x это последний аргумент.
А все то, что идет спереди, было бы внутри args.
Вот так не получится.
Все происходит ровно наоборот.
Сначала все в себя вбирает args.
И только потом все то, что остается, он назначает в x.
Но так args жадный, он ничего не оставляет.
Ну примеры.
То есть если вы написали как положено.
Сначала написали t, а потом args многоточаем.
И здесь то же самое t, а потом args многоточим.
То есть все нормально.
Если вы вызываете просто function от 0 и 0.0, то у вас в качестве типа t выводится int.
В качестве args выводится пакет...
или список, к которому содержится всего лишь один тип double.
Если вы вызываете function...
То есть если вы явно просите, какие типы вам нужны, int, int, int,
то у вас тоже все нормально.
В качестве типа t выводится int.
список из двух int. Все нормально работает.
Если вы меняете местами t и args, что у вас происходит?
Вывод типов по-прежнему работает нормально.
Почему? Потому что компилятор может по этому вызову понять, что вы имели в виду.
Он понимает, что 0 отвечает за tx, поэтому t это int,
а все оставшиеся он отдает в аргумент args.
Поэтому все нормально.
Но если вы в таком случае попытаетесь вызвать function с помощью явного указания параметров,
в качестве явного указания шаблонных параметров, то тут возникнет беда,
которая как раз завязана на том, что шаблоны с переменочным аргументом
вбирают в себя все жадно и ничего не оставляют дальше.
Что вас произведет? Вы написали тут int, int, int.
Компилятор видит, что в качестве первых шаблонных параметров вы указали args.
И поэтому компилятор честно говорит, что int – мое, int – мое, int – мое,
t – ой, ничего не осталось, ну все, беда.
То есть вот args впитал в себя int, int, int, а в качестве t ничего не осталось.
Ну вот ошибка в компиляции. Понятно?
Тоже самое может произойти, если вы поменяли местами args и t внутри аргументов.
В этом случае вы не можете вызвать функцион вот так.
Ну снова почему? Потому что компилятор пытается вывести
первый шаблонный параметр args. То есть он увидит 0.
То есть он поймет, что первый шаблонный параметр внутри этого пакета должен быть int.
Дальше смотрит 0.0.
Вторым аргументом внутри этого пакета должен быть double.
Поэтому вот создаю int double.
Дальше ничего не осталось. Ну все, я заканчиваю работу с пакетом.
А дальше приходит t и говорит, что еще есть я, а ему и ничего не осталось.
Все.
Но при этом в данном случае можно вызвать функцион int, int.
Почему? Потому что внутри этого списка,
внутри объявления шаблонов параметра все нормально.
То есть тут более-менее понятно, что первый int это t, а последний это args.
Ну и последний случай, самый печальный.
Эту функцию вы вообще никак вызвать не можете.
То есть ни первым способом, ни вторым способом.
Ну понятно. В первом случае у вас вот здесь все уйдет в args.
В втором случае у вас и здесь все уйдет в args.
Поэтому все-таки правильным способом использования шаблонных параметров
является написание списка пакета параметров в конце.
Окей?
Все примеры тут понятны?
Хорошо.
Ну и наконец ключевой вопрос.
Мы поняли, как объявлять шаблоны с переменом числом аргументов.
А как с ними работать?
То есть как написать функцию, которая бы работала с переменом числом аргументов?
Вот сейчас мы это обсудим.
Первое, про что нужно поговорить, это про оператор sizeof.
Помните, когда мы использовали сишный синтаксис?
Тут мы должны были отдельным аргументом как-то сообщать,
ну не компилятору, а как-то сообщать функции, сколько аргументов мы передали.
В C++ стиле этого не нужно делать, потому что у нас есть специальный оператор sizeof.
Sizeof с многоточием.
Sizeof с многоточием можно применять только к пакетам параметров.
То есть только к пакетам, которые объявлены с помощью класса и многоточия,
или которые объявлены с помощью вот такой штуки.
Так, здесь это вам рано, давайте просто args напишем.
Окей?
То есть если вы sizeof примените к args большой буквы, ну или args с маленькой буквы,
неважно к пакету параметров типов или к параметру функции,
sizeof с многоточием возвращает вам количество элементов в этом пакете.
Именно что количество элементов, а не размер в байках?
Ну классический sizeof, я думаю вы помните,
sizeof от x возвращает вам размер выражения.
Ну, точнее размера результатов выражения или размер переменной в байтах.
Или размер типа в байтах.
Sizeof с многоточием возвращает вам размер не в байтах, а именно что в штуках.
в количестве, в единицах, в объектах, в общем, что угодно.
Понятно?
Поэтому если вы вызываете в данном случае функцию 1, 2, 3,
то sizeOfArcБольшой вернет вам 3, и sizeOfArcМаленькойБуквой
вернет вам тоже 3. То есть это первое правило, что количество аргументов
вы всегда можете определить с помощью sizeOf с многоточием.
Дальше.
Первый способ написания функции с переменом числом аргументов.
Начнем со следующих слов.
Допустим, вы написали какую-то функцию с переменом числом аргументов.
Допустим, у вас уже есть какая-то функция с переменом числом аргументов.
Вы ее можете использовать внутри своей функции.
Например, допустим, у меня есть функция print,
которая может принимать произвольное число аргументов.
При этом я хочу написать функцию printTitle,
которая помимо того, что печатает сами аргументы,
еще в самом начале печатает какой-то заголовок.
То есть, грубо говоря, это числа, и дальше печатает числа,
и вот там мой массив, и дальше печатает массив.
Как я это реализую?
Я принимаю поток, в который я буду все это выводить.
Дальше я принимаю сам заголовок,
который я буду выводить перед тем, как выводить все остальное.
Ну и дальше принимаю, собственно, все остальные аргументы.
Ну и как моя функция работает? Я изначально вывожу title,
то есть изначально вывожу заголовок, что сейчас будет выведено,
ну и дальше все остальные аргументы,
передаю функцию print. Как я это делаю?
Как мне взять пакет параметров и передать другую функцию?
Очень просто. Я пишу args, и после этого пишу многоточие.
Многоточие означает распаковать пакет.
Ну и пакет распакуется следующим образом.
Сначала пишется первый параметр, через запятую второй параметр,
через запятую третий параметр и так далее.
То есть распаковка пакета происходит с помощью многоточия.
То есть просто написать print os args нельзя.
Вот так писать нельзя.
Потому что args это пакет, пакет, вообще говоря,
в дизаке C++ нет такого типа пакет,
и просто так передать пакет другую функцию вы не можете.
Вы можете его передать и распаковать.
Более того, к пакету вы можете применять
некоторый шаблон, некоторые паттерны или некоторую функцию,
которая будет применена ко всем элементам пакета сразу.
Следующий пример.
Допустим, вы хотите написать функцию, которая суммирует квадраты чисел.
Допустим, у вас есть функция sum, уже написанная,
которая принимает произвольное количество аргументов
и суммирует их все, возвращает вам ответ.
А теперь мы хотим написать функцию sum squares,
которая возвращает вам сумму квадратов чисел.
Как это можно сделать?
Снова мы принимаем произвольное количество аргументов
и дальше пишем следующую интересную вещь.
Пишем sum args умножить на args и дальше многоточие.
Потому что пакет раскрывается целиком.
Мы не хотим отдельно распаковать первый пакет,
а потом вот эту распаковку умножить на второй пакет.
Мы как бы тут пишем шаблон.
Мы говорим, что к каждому аргументу нужно применить,
взять аргумент, умножить его на другой аргумент.
И вот эту всю конструкцию нужно распаковать.
Грубо говоря, здесь написан шаблон,
написан некоторый шаблон, и после него пишется многоточие.
И даже этот шаблон применяется к каждому аргументу.
Собственно, здесь вы написали, что к каждому аргументу
нужно применить умножение его самим собой.
И поэтому у вас эта штука как бы распакуется в args 0 умножить на args 0,
args 1 умножить на args 1 и так далее.
У вас вопрос?
Ещё раз, можешь что-то поставить?
Боюсь, что это не сработает, потому что непонятно,
что имеется в виду.
Вопрос такой, что если сделать вот так?
args многоточие, или умножить на args многоточие.
На самом деле непонятно, что вы имеете в виду,
потому что распаковка пакета, грубо говоря, означает,
что вы пишете args 0, args 1, грубо говоря, через запятую.
На самом деле это не так, потому что запятая это оператор.
Вообще говоря, примерно n-1.
Дальше всё, что распаковали через запятую, умножайте на другую вещь,
которая распакована через запятую.
Грубо говоря, непонятно, что вы имеете в виду.
Поэтому так не получится.
Всё понятно?
То есть применение простое. Вы либо просто распаковываете пакет
и передаёте его в другую функцию, либо говорите,
что каждому элементу нужно применить какую-то операцию,
какое-то действие, и дальше снова через многоточие распаковываете.
Нет, это происходит во время распаковки.
То есть вы пишете, что нужно применить, что нужно сделать с каждым аргументом.
Здесь вы пишете, что каждый аргумент нужно умножить на само себя,
а дальше пишете многоточие.
И теперь у вас происходит следующая вещь.
Берётся первый аргумент, умножается на сам себя,
берётся второй аргумент, умножается на сам себя и так далее.
Всё это перечитает через запятую и передаётся в другую функцию.
Ещё примеры, как эту распаковку можно использовать.
Например, если у вас есть функция print,
которая принимает произвольное количество аргументов,
печатает их на экран, вы можете написать свою функцию printAddresses,
которая просто принимает аргументы
и печатает их адреса на экран.
И вот тут мы знакомимся с ещё одной возможностью.
Это применение паттерна к типам.
Понятное дело, что паттерн,
тот, который был написан здесь,
можно применять не только к аргументам,
но ещё можно что-то навешивать на типы.
Понятное дело, что у вас может быть не только int,
но, скажем, int&, ссылка на int,
константная ссылка на int, правая ссылка на int и так далее.
Примерно то же самое можно делать и с пакетом параметров типов.
Что здесь дословно написано?
Вы говорите, что каждому аргументу типу
нужно применить const&&.
И дальше вы через запятую это всё распаковываете.
И у вас получается, что у вас есть const arc1&,
const arc2& и так далее.
Понятно?
То есть вы каждый аргумент пакета
принимаете по константной ссылке.
Понятно, почему здесь нужно использовать
константную ссылку.
Потому что мы хотим напечатать адреса.
Если это констант, то мы будем печатать локальные адреса.
То есть мы сначала всё скопируем и потом будем писать локальные адреса.
Мы этого не хотим. Скорее всего мы хотим напечатать
именно адреса тех объектов, которые нам передали.
Вот с этим const arc&& понятно?
То есть мы просто говорим, что мы каждый аргумент этого пакета
хотим принимать по константной ссылке.
Так или иначе, все объекты умеют проводиться в константной ссылке.
Временные, невременные.
В общем, конст ссылки – это, грубо говоря,
некоторый универсальный способ принимать всё, что угодно.
Но если что-то идёт не так,
то можно задать другой вопрос.
Что если я делаю вот так? Что если я пишу не конст, а просто arc ссылка?
То есть я говорю, что я просто все элементы принимаю по ссылке, а не по константной ссылке.
Тогда сюда можно передавать только lvalue.
Ну и тогда будет просто ошибка компиляции.
То есть если у вас ожидается, что тут будет передаваться lvalue,
а вы передаете не lvalue, то ошибка компиляции.
Всё как в обычных функциях.
Ну и дальше я говорю, что каждому аргументу
мне нужно взять адрес,
ну и дальше я это всё распаковываю.
То есть у меня получается, что я беру адрес первого аргумента, второго аргумента,
ну и последнего аргумента.
Ну и последний ещё один интересный пример.
Значит, пакеты вы можете на самом деле распаковывать
в произвольных местах, в произвольном количестве.
Здесь какой пример?
Здесь пример...
То есть я хочу напечатать так называемые частичные суммы,
то есть сумму без первого аргумента,
сумму без второго аргумента, сумму без третьего аргумента и так далее.
Понятно, да? То есть если у меня есть 1, 2, 3, 4,
то у меня функция должна вернуть 9,
что дальше? 8, дальше 7, ну и 6.
То есть это сумма всех элементов без единицы,
сумма всех элементов без двойки, сумма всех элементов без тройки,
сумма всех элементов без четвёрки.
Как я это делаю?
Следующим образом. Первое, что я делаю, я говорю, что
в качестве первого аппаранда у меня выступает
сумма всех элементов.
Понятно? То есть в качестве первого параметра я говорю,
что я считаю сумму всех аргументов.
То есть я и распаковываю это всё, я внутри скобок,
то есть внутри аргументов. То есть у меня тут есть
сумм от всего, что передали.
А дальше я пишу минус аркс и многоточие.
Ну, дословно, что это означает?
Это означает, что мне нужно взять вот это значение s,
ну на самом деле всё внизу написано,
мне нужно взять значение s, которое было посчитано здесь,
из него вычесть аргумент
и повторить этого для каждого аргумента.
Это непонятно. Скорее всего, нет.
Скорее всего, это будет оптимизирован. То есть так как это всё разрешается
на этапе компиляции, скорее всего он на этапе компиляции там
почитает и всё подставит и так далее. Но возможно и нет.
Но так или иначе к какому результату это приводит?
Из общей суммы вычитается аркс 0,
потом из общей суммы вычитается аркс 1,
и так далее, потом аркс n-1.
Вот этот пример понятен? То есть здесь я распаковал пакет,
посчитал сумму и только потом распаковал весь паттерн
целиком, который содержит аркс.
То есть, грубо говоря, на самом деле
многоточие относится к вот этому аркс.
К этому арксу оно не имеет никакого отношения. Почему?
Потому что первый аркс уже распакован, то есть многоточие
относится только к не распакованному аргументу. Хорошо?
Значит, это первый способ использования шаблона с переменочным
аргументов. То есть вы можете распаковывать пакеты и передать их
в другую функцию. При этом вы можете распаковывать как вам угодно.
Вы можете применить ко всем одну и ту же операцию и передать дальше.
Ну и можете конструировать какие-то более сложные вещи, как, например, вот во втором примере здесь.
Второй метод уже более разумный, то есть метод откусывания.
Смотрите, метод откусывания заключается в следующем.
Вообще говоря, сложность в написании шаблона с переменочным аргументом заключается в том,
что мы не можем, как в языке Python, как устроены функции с переменочным аргументом.
Там есть специальный аргумент, объявляется со звездочкой.
И этот аргумент, по-моему, представляет себя tuple.
Ну, грубо говоря, неизменяемый массив.
И вы к этому массиву можете спокойно обращаться к нулевому элементу, к первому элементу, к второму элементу.
То есть вы можете спокойно индексироваться.
В языке C++ так нельзя делать.
То есть вы не можете просто взять и написать args в скобочках 0.
Просто так взять и обратиться к элементу вы не можете.
Вы можете это сделать просто, потому что это вот такая зашита на этапе компиляции внутренняя структура.
На что вы можете сделать? Вы можете откусывать элементы по одному.
Как это работает? Смотрите.
Снова возвращаемся к исходной задаче.
Я хочу написать функцию print, которая печатает произвольные аргументы.
Делаю я это следующим образом.
Значит, я пишу рекурсию.
Значит, сначала я пишу функцию, которая работает в случае, когда мне передали один аргумент.
Это так называемый конец рекурсии.
Ну понятно, что когда мне передали один аргумент, мне понятно, что делать.
Если мне передали один аргумент, мне понятно, что нужно просто взять и вывести
на экран это один аргумент. Всё нормально.
И плюс я пишу перекрузку для в случае, когда мне передали более одного аргумента.
То есть я пишу, что в случае, если мне передали один аргумент и плюс ещё что-то,
нужно вызывать вот эту функцию.
Она будет выигрывать перегрузку по понятным причинам.
Потому что если вы вызвали функцию print от двух аргументов,
то будет вызываться вот эта функция, потому что она подходит лучше всего.
То есть компилятору дешевле ничего не подставлять в ARX,
чем подставлять в ARX пустой список.
Мы говорили, что точное соответствие всегда подходит лучше.
Точнее, соответствие с наименеешим числом постановок подходит лучше.
А здесь что вы пишете? Вы пишете, что если вам передали один аргумент и плюс еще что-то,
то мы работаем следующим образом.
Мы выводим head, ну точнее мы выводим первый аргумент на экран.
И потом рекурсивно вызываем функцию print от оставшейся части.
И в этом собственно заключается метод откусывания.
То есть мы откусили первый аргумент, с ним что-то сделали, а остальные передали дальше.
Рекурсивно.
Понятно, что произошло?
То есть когда я вызываю print от os и 0.1.2, что происходит?
Сначала у меня вызывается функция print, у которой head равен 0,
а в ARX записано 1 и 2.
Выводите 0 и дальше просите print от 1 и 2.
В head у вас записывается единица, в ARX у вас записывается двойка.
Дальше вызываете print рекурсивно от двойки.
И все, рекурсия заканчивается, потому что вы вызываете вот эту функцию.
Первая функция ничего рекурсивно не вызывает, все отлично.
Понятно?
Что?
Stackoverflow?
Ну тут очень сложно добиться stackoverflow по следующей причине.
Вообще говоря, число аргументов функции ограничено.
По-моему 256.
По-моему около максимального количества аргументов,
которые можно принимать функции в языке C++, это что-то типа 256.
Больше чем 256 аргументов функции вы передать не можете.
Поэтому тут рекурсия максимум 256 шагов.
Но это как бы не очень много.
Но проблема действительно есть.
Рекурсивно вызвано, мы ее поборем в использовании 3.
Все будет нормально.
Так, этот пример понятен.
Ну и то же самое метод кусывания для функции суммы.
Если мы хотим просуммировать все аргументы, то то же самое.
Мы пишем конец рекурсии.
Что делать, если в сумму нам передали один аргумент?
Если нам в сумму передали один аргумент, то мы просто его возвращаем.
Сумма из одного слагаемого.
Вы на первом курсе проходили.
Это, собственно, слагаемая.
Если мы в сумму передаем произвольное количество аргументов,
то мы говорим, что у нас как минимум есть один аргумент и плюс еще что-то.
В этом случае что мы делаем?
Как выглядит рекурсивное вычление суммы от многих аргументов?
Нужно вычлить сумму от меньшего количества аргументов и плюс первый аргумент.
Понятно?
Тоже понятно, как работает.
Хорошо.
И наконец, третий способ использования, который завезли в 17 стандарте,
это так называемый Fold Expressions.
Ну снова, да, как тут правильно отметили,
вообще говоря, то, что мы здесь делали, мы здесь делали рекурсивно.
Рекурсия это не всегда хорошо, это не всегда эффективно.
Просто потому что на это тратится стек, на это тратятся лишние вызовы.
Эти функции, вообще говоря, рекурсивно не инлайнятся.
В общем, все плохо.
Так вот, в 17 стандарте решили завести такую возможность как Fold Expressions.
Fold Expressions — это такой, некоторый специальный синтаксис распаковки параметров.
Дайте сначала общий синтаксис, а потом к примерам.
Допустим, вы хотите применить бинарную операцию подряд ко всем элементам.
Допустим, как мы здесь хотели, мы хотели сложить все элементы.
Для этого вы пишете следующую вещь.
Вы пишете скобки, пишете пакет параметров, нужную вам операцию,
и потом многоточие.
Эта штука автоматически раскрывается вот в такую вещь.
Как называется? В правоассоциативную бинарную операцию.
То есть сначала считается результат операции для последних двух аргументов,
потом для предпоследнего с результатом,
потом результат перед последним аргументом и так далее.
Понятно.
То есть это дословно то, во что раскрывается эта штука.
Если вы хотите левоассоциативную операцию,
которая сначала работает с левыми аргументами,
то вы пишете то же самое, но многоточие слева. То есть, грубо говоря, вы пишете многоточие, плюс аркс, скобка закрылась.
И вот это дословно переводится в аркс 0, плюс аркс 1, плюс и так далее.
Ну при этом скобки расставляются вот таким образом.
Ну и последние две штуки. Это та же самая распаковка с бинарной операцией, но с некоторым инициализатором.
Ну, например, вы хотите просуммировать все аргументы, но при этом сделать так, что сначала идет 1, а потом аркс 0, плюс аркс 1, плюс и так далее.
То есть задать некоторое начальное значение.
Ну и это делается тоже точно так же. То есть вы пишете pack, потом операция, потом многоточие, потом снова операция и init. То есть то, с чем нужно проинцидизировать.
То есть это будет правоассоциативная операция. То же самое, если вы хотите левоассоциативную операцию, то вы пишете вот таким способом.
Ну, это общий синтакт, сейчас будут примеры. Пока понятно, да?
Ну вот примеры, собственно. Как можно написать функцию... давайте сначала сам. Тут проще.
Сначала функцию суммы. Ну, как я уже писал до этого, мы используем fold expression, то есть распаковку параметров в выражении свертки.
То есть мы пишем обязательно скобки, то есть скобки обязательно это часть синтаксиса. Вы пишете скобки, дальше вы пишете пакет параметров, дальше пишете плюс и многоточие.
И это дословно означает, что нужно все элементы сложить друг с другом. Окей?
Значит, как можно писать принт? То же самое, но только нужно использовать в данном случае последний. Последний fold expression.
Ну почему? Потому что... что мы здесь делаем? По сути мы здесь используем операцию побитого сдвига влево для всех аргументов.
Но при этом мы используем операцию побитого сдвига влево, и при этом изначально слева у нас должен обязательно стоять поток.
Ну потому что если мы будем просто ко всем аргументам принимать операцию побитого сдвига, то они все просто побитого сдвинутся, и непонятно что и всё.
Понятное дело, что когда вы вводите на экран, у вас сначала стоит поток, а только потом эти самые операторы побитого сдвига.
Чтобы этого добиться, вы сначала пишете скобки, часть синтаксиса,
потом пишете os, то есть оператор удаф поток, дальше побитву издвиг, многоточие, побитву издвиг и дальше аргументы.
Вот такой синтаксис.
То есть это пример к четвертому, это пример к первому пункту.
Понятно?
При этом, естественно, выражение к свертке, как и при любой другой распаковке параметров, вы можете использовать некоторый шаблон.
Например, как можно в последнем примере вывести не просто сумму всех чител, а сумму квадратов чител?
Что нужно написать?
Да, просто аркс умножить на аркс. Аркс умножить на аркс, ну естественно все в скобках, плюс и многоточие.
И это все будет работать как вы хотите. Вы сначала написали пакет параметров, ну или что нужно делать с пакетом параметров,
а дальше написали fold expression, то есть выражение свертки, какую операцию нужно ко всем ним применить.
В смысле, в последних пунктах?
Да.
Два пакета можно...
Грубо говоря, вы хотите так. Допустим, у вас есть два пакета, arcs1 и arcs2, и вы хотите их, допустим, сложить друг с другом.
Это можно сделать, но не совсем так. Здесь это можно сделать так.
Во-первых, короче, это проще всего сделать в следующем образом. arcs1 распаковать, плюс многоточие, плюс arcs2 распаковать.
Ой, не распаковать, тут ерунда. Вот так понятно, что происходит?
То есть вот это у вас init. То есть он сначала распаковывается и вычисляется.
А потом вы всю эту конструкцию применяете arcs2. То есть вот этот многоточий относится к вот этому arcs2.
Потому что первый arcs1, он уже распакован. То есть нельзя два пакета распаковать одновременно.
Вы должны сначала распаковать один пакет, потом распаковать другой пакет.
То есть в каждом момент времени вы должны понимать, к какому пакету параметру у вас относится каждое многоточие.
Вот так можно.
Да, еще вопросы?
Хорошо.
Так, ну и отлично 5 минут есть. У меня есть несколько бонусных проблем, которые...
В общем, на этом все. Все, что я хотел рассказать про шаблонность перемен и числому аргументов я рассказал.
Сейчас несколько проблем, которые, возможно, были незаметны или которые потенциально могут встретиться.
То есть первая проблема... Вообще говоря, я обманул, и вот этот принт работает не очень правильно.
Ну, здесь уже есть ответ. В общем, он выводит все без пробелов.
Смотрите, до этого, когда я использовал этот откусывание, я мог явно тут прописать пробел.
То есть я вожу аргумент, вожу пробел.
Когда я использую выражение свертки, у меня теряется возможность вывести пробел.
Потому что у меня все побитые сдвига последовательно применяются ко всем параметрам.
Проблему эту можно решить вот таким хитрым способом.
Свертка с операцией запятая внезапно.
Ну, если кто-то не знал, то запятая это бинарная операция.
Операция запятая работает так. Она просто последовательно выполняет все, что ей дали.
Если вы хотите вывести все через пробел, то решение выглядит следующим образом.
Ну, вы пишете просто os.
Тут уже написано все.
Значит, вы просто пишете, что нужно применить карк с вот такой паттерн.
То есть каждому аргументу нужно сделать следующую вещь.
Нужно сначала вывести пробел, а потом сам аргумент.
Потом я пишу запятую и многоточие.
И все это оборачиваю скобки.
И теперь это fold expression с бинарной операцией запятая.
Понятно?
То есть грубо говоря, у меня происходит следующая вещь.
Os, короче, вывод пробела, вывод аркс 0, запятая.
Вывод os, пробел, вывод аркс 1, запятая.
Ну и так далее. Понятно?
То есть вот это вот все применяется к каждому аргументу через запятую.
Все ясно?
Понятно, как это работает?
То есть я просто выполнил выражение свертки для операции запятая.
И через запятую указал, что мне нужно сделать для каждого параметра.
В данном случае для каждого параметра нужно вывести его совместно с пробелом.
Так, ну и вторая проблема.
Наверняка у вас должен был возникнуть такой вопрос.
Ну, смотрите, шаблоны с переменом числом аргументов это все-таки шаблоны.
А шаблоны могут принимать все, что угодно.
А что, если я хочу написать функцию, которая может принимать только int?
Ну, естественное желание, я хочу написать функцию sumInt,
которая суммирует только int.
И в этом я хочу написать функцию, которая принимает произвольное количество int.
А не произвольное количество элементов произвольного типа.
Но тут у меня нет для вас радостной новости.
Базовым синтаксом C++ это сделать нельзя.
Можно только с помощью некоторого хака,
на который, боюсь, у нас времени не хватит в этом семестре.
Но, если что, можете пользоваться вот такой конструкцией.
Если совсем коротко, то вы все еще принимаете...
Вы в ряде к templates, то есть шаблоны с переменом числом аргументов,
по-прежнему передаете его sumInt.
И при этом дополнительно используете следующую конструкцию std-enable-ift.
Std-enable-ift, судя по названию, говорит просто о том,
что вот эту штуку нужно разрешить только в случае,
если выполнено что-то.
И вот это что-то, это вот это.
Только в случае, если у вас все аргументы,
все типы аргументов совпадают с int.
Ну и тут дальше fold expression.
То есть я применяю операцию i ко всем этим выражениям.
То есть и первый аргумент у меня int, и второй аргумент у меня int,
и третий аргумент, и так далее.
И вот только в этом случае у меня вот эта сумма заработает.
Если я передаю не все int,
то эта штука не работает.
Ну или более мягкий вариант.
Вы все-таки принимаете все что угодно,
но при этом при суммировании делаете static-cast к int.
То есть приводите к int то, что вам передали.
Это не порождает вам ошибку компиляции,
а просто-напросто приводит к int то, что вы передали.
Вот такие дела.
Ну и теперь мы на самом деле более-менее понимаем,
что нужно писать в make-unique.
Давайте вернемся к изначальной задаче.
Мы все-таки хотели написать make-unique.
Теперь понятно, что мы делаем.
Мы теперь пишем template class-t.
make-unique у нас возвращает,
давайте наш unique-ptr, который мы писали,
unique-ptr от t.
make-unique.
И что он должен принимать?
Ну он должен принимать произвольное количество аргументов.
Так мы заранее не знаем,
какое количество аргументов нужно передать конструктор t,
поэтому мы принимаем сразу произвольное количество.
То есть мы пишем class-maga.args.
И здесь...
ну давайте напишем пока так.
args-maga.args.
И дальше здесь пишем return.
Вот, да, уже слышу, что кто-то понимает проблему.
ptr-t.
Ну и здесь уже сразу пишем new-t args-maga.
В общем, понятно, да, идея?
Мы пишем шаблонную функцию make-unique,
которая в качестве первого шаблона параметра понимает t,
то есть тип умного указателя, который нужно вернуть.
Дальше мы принимаем произвольное количество аргументов,
и все эти аргументы мы будем передавать в конструктор.
Здесь мы эти аргументы принимаем,
здесь мы эти аргументы с помощью распаковки
передаем в конструктор t.
Но при этом возникает проблема,
которую уже заметили,
что тут мы все аргументы принимаем по значению.
То есть потенциально копируем.
Было бы неплохо здесь написать какую-нибудь ссылку,
например, const args-ampersand.
Но тогда все аргументы будем принимать по константной ссылке,
и с этим на самом деле тоже есть проблемы,
которые мы сейчас осознаем в начале следующей лекции,
и к которым будем решать всю следующую часть.
Сегодня мы продолжим семантическое перемещение,
надеюсь, с ней закончим.
Рассмотрим некоторые более продвинутые сценарии.
Вот вообще, наверное, вот эта часть,
она наиболее сложная в курсе,
если вообще в принципе можно считать ее сложной.
Но как сложной?
Тут главное осознать проблему.
Вот если осознание проблемы придет,
то я думаю, все будет нормально.
Давайте как раз таки с проблемой и начнем.
Смотрите.
Давайте издалека.
Вот есть язык Python,
те, кто с ним знакомы,
и вы знаете, что это язык Python,
и вы знаете, что это язык Python.
Есть язык Python,
те, кто с ним знакомы,
наверняка знакомы с таким понятием,
как декоратор.
Декоратор – это просто некоторая функция,
которая оборачивает другую функцию.
Функция занимается своим делом,
и при этом есть декоратор,
который навешивает на нее какой-то дополнительный функционал.
Например, логирует все ее действия,
то есть увозит на экран,
что эта функция запустилась, эта функция кончила работу,
или вычисляет время, сколько работала там та или иная функция,
или что-то еще.
Представим себе, что
в C++ мы хотим сделать то же самое.
То есть мы хотим написать некоторую функцию,
которая бы принимала другую функцию,
принимала аргументы этой функции,
вызывала эту функцию
с этим аргументом,
и при этом дополнительно вычисляла время работы
нужной нам функции.
То есть я хочу написать функцию RunningTime,
которая принимает функцию
и ее аргумент.
Пока давайте для простоты считать,
что все функции принимают только один аргумент.
Как распространить это на много аргументов,
мы уже поговорили, достаточно сказать многоточие.
Но для простоты давайте пока считать, что только один аргумент.
Есть функция,
я принимаю ее с помощью шаблонов аргументов,
чтобы, во-первых, не заморачиваться с типом функции,
потому что функция мне может прийти какая угодно.
Она может возвращать что угодно,
она может принимать что угодно и так далее.
Ну и плюс в качестве вот этой функции
мне может прийти не просто функция,
а на самом деле некоторая структура,
у которой перегружены круглые скобки.
Ее, естественно, я тоже могу вызвать.
Ну и плюс в качестве шаблонов аргументов я принимаю арк.
Естественно, тоже произвольный,
потому что непонятно, что мне функцию могут передать.
Ну и что я делаю?
В начале работы я просто вызываю
стандартную функцию stackLog.
StackLog просто берет
текущую отметку времени,
грубо говоря.
То есть я выключаю таймер,
дальше вызываю эту функцию
с передним аргументом,
и дальше таймер выключаю, точнее нажимаю еще раз на таймер,
и вычисляю, сколько времени прошло от начала до конца.
И возвращаю там некоторые значения.
Грубо говоря,
сколько моя функция отработала процессорного времени.
То есть как работает running time понятно,
что я от нее хочу.
Я хочу, чтобы она принимала функцию,
принимала аргумент,
вызывала эту функцию с нужным аргументом,
и при этом возвращала в качестве ответа,
сколько у меня отработала эта функция.
Довольно полезная функция,
если вы пишете какие-то свои бейчмарки,
хотите измерять время работы тех или иных отдельных
кусков функций.
Если у вас есть функция function,
которая принимает int,
я вызываю функцию от пяти, она нормально работает.
Я вызываю running time от функции от пяти,
и внешний running time не возвращает,
сколько времени отработала моя функция.
Все работает, понятно.
Пятерка сохраняется в арг, арг передается внутрь функции,
все нормально.
В чем проблема?
Кто понимает, в чем может быть проблема?
Это функция, она копируется.
Это функция, она копируется,
это одна из проблем.
Мы можем победить, если тут написать на, допустим, амперсант.
Это ничего страшного.
Если у нас функция
передается просто по указателю на функцию,
то указатели, в принципе, копируются дешево.
Это не самая главная проблема.
Тут есть
другая,
более интересная.
Хорошо.
На следующий слайд переходим.
Давайте рассмотрим другую функцию.
Другая функция function тоже возвращает void,
но при этом возвращает int по ссылке.
Возвращает int по ссылке
и внутри себя делает plus-plus-value.
Вполне себе допустимый код.
Если я в функцию что-то передал по ссылке,
то эта функция может это значение изменить.
Логично.
Хорошо.
У меня есть переменная int x,
я вызываю function от x.
Если я вызываю function от x, то, естественно, я ожидаю,
что x у меня увеличится на единицу.
Потому что function ровно это и делает.
А теперь я вызываю running time
от функции от x.
Смотрите еще раз.
Какой у меня контракт? Что я ожидаю от функции running time?
От функции running time я ожидаю,
что она возьмет function, возьмет аргумент,
вызовет функцию function с передным аргументом
и просто дополнительно
вернет время работы.
Но если я запущу running time от function от x,
у меня x останется равным единице.
То есть произошло не то, чего я хотел.
Почему?
Да, смотрите,
потому что вот этот арк
он у меня свяжется,
ну, точнее, не свяжется,
неправильно сказал.
Вот этот арк, вот в этот арк
скопируется содержимое x.
То есть арк
будет копией x.
И когда я буду вызывать вот здесь func от arg,
у меня функция function
будет работать с вот этим
аргом, но не с x.
Понятно?
То есть я буду функцию function
передавать ссылку, но ссылку
на исходный x,
а на локальный арк.
И будет заменяться именно локальный арк.
То есть после того, как у меня отработает функция function,
у меня локальный арк станет равным на двойке,
ну а x он вообще ни сном ни духом.
Потому что он просто скопировался туда.
Понятно?
Проблема.
Ну хорошо.
Как побороть эту проблему?
Я предлагаю тут написать амперсант.
Ну у нас может что передаться?
Ну да, да.
Давайте сначала разберемся с этим.
Вот я предлагаю написать
арк амперсант, чтобы решить эту проблему.
Но тогда казалось бы,
все нормально тоже.
Вот есть function, она принимает
in по ссылке,
у меня есть x, я вызываю function от x,
x становится равным единицам.
Вызываю running time от function от x,
x становится равным двойке. Почему?
Потому что в arg сохраняется
ссылка на x, и когда я изменяю arg,
я на самом деле изменяю x.
Потому что arg это ссылка на x.
Ну вот как правильно сказал оператор,
возвращаемся к исходному function,
который принимает не ссылку,
а принимает просто int.
Вызываю function от 5,
все отлично работает.
Пробую вызвать running time от function от 5,
ошибка компиляции.
Почему?
Потому что ссылка имеет право
связываться только с cell value.
Помним, что такое L-value и R-value.
L-value ссылки имеет право связываться только с L-value.
Опять, это литерал.
Литерал это по R-value.
Ну все, беда.
Короче, проблема ясна.
Есть function running time,
я хочу, чтобы она принимала функцию, принимала аргумент.
И хочу, чтобы все побочные
эффекты у меня были доступны.
Если function принимает ссылку,
я хочу, чтобы туда передавалась ссылка.
Если function принимает не ссылку,
хочу, чтобы туда передавалась копия.
Но у меня не получается.
У меня банально на самом первом уровне
возникает проблема.
Я не знаю, что мне передать вот сюда.
В чем дело?
Дело в том, что
этот аргумент
не умеет подстраиваться
от фактических аргументов функции.
Хотелось бы, чтобы этот аргумент вел себя так.
Если бы я передал L-value объект,
у меня бы арк связался с L-value объектом.
Была бы L-value ссылка на этот объект.
Если бы я передал туда R-value,
то я бы хотел, чтобы у меня была
R-value ссылка на этот объект.
Я бы хотел, чтобы этот арк
как-то адаптировался под то,
что я туда подаю.
Если я туда передаю L-value,
я хочу L-value ссылку.
Если я туда передаю R-value объект,
то я хочу, чтобы там была R-value ссылка.
В качестве решения можно предложить
вот эту функцию RunningTime
перегрузить.
Ну хорошо, давайте напишем перегрузку.
Одна перегрузка будет
принимать L-value,
вторая перегрузка будет принимать R-value.
Решение?
Частично да, вообще говоря, решение.
Но тут возникает дублирование кода.
Понятное дело, что функция RunningTime
очень маленькая.
А что если вам нужны большие функции?
Вот большие функции, которые имеют
очень большую семантику,
тогда вы дублируете код.
Вы можете мне ответить.
Сам собой это делаю.
Кто-то из вас может мне сказать,
ну смотрите, мы же ровно то же самое делали,
когда писали перемещающие конструкторы.
Мы же перемещающий конструктор перегружали.
Вы помните, мы писали отдельно
конструктор копирования для L-value ссылки
и писали перемещение в случае,
когда мне передается R-value объект,
то есть R-value ссылка.
Но там не было дублирования кода.
Мы как бы зашивались на это поведение.
Мы как бы сказали, что в случае L-value
мы действуем одним образом, то есть мы копируем,
в случае R-value мы перемещаем.
Здесь другая ситуация.
Здесь мы хотим делать
практически то же самое,
но только с изменением R-value ссылки на L-value ссылку.
Это другое. Понятно?
Как решается эта проблема?
Решается эта проблема с помощью
так называемых forwarding ссылок
или пробрасывающих ссылок,
ну или в русскоязычной литературе более часто
встречается универсальная ссылка.
Сейчас мы познакомимся с универсальными ссылками,
которые ведут себя ровно так, как я хочу.
То есть если я передал L-value объект,
то это L-value ссылка,
если передал туда R-value объект,
то это R-value ссылка.
Как она выглядит?
Нет. Сначала поговорим
про немного извлеченную тему,
про сворачивание ссылок.
Это короткий пункт.
Идея такая.
В процессе
подстановки шаблонных параметров,
это все про шаблоны функций,
если у вас есть шаблоны функций,
то в процессе подстановки шаблонов
у вас могут возникнуть конструкции вида
ссылка на ссылку,
правая ссылка на ссылку,
левая ссылка на правую ссылку и так далее.
Как это может получиться?
Очень просто.
Вы написали функцию f,
2-ой аргумент принимается с помощью t-двойной амперсант.
Но если вы вызываете эту функцию
например, вот так, f от int амперсант.
Понятное дело, что в процессе
подстановки у вас получается следующая вещь.
int от амперсант,
и на это все навешивается амперсант,
а потом еще int амперсант,
и на это все навешивается 2 амперсанда.
В языке C++
не существует ссылок
на ссылки, это помним.
Не существуют правые ссылки
на левую ссылку, не существуют
правые ссылки на левую ссылку и так далее.
Но компилятору можно.
Компилятор сам себе разрешает
создавать ссылки на ссылку.
Точнее не так, он разрешает себе писать подобные вещи.
Но при этом эта вещь
ведет себя не как ссылка на ссылку,
а ведет себя
по-другому.
Ведет себя следующим образом,
по правилу сворачивания ссылок.
Правило здесь такое,
если вы создали левую ссылку на левую ссылку,
то у вас общий тип,
в итоге получается это просто обычная ссылка.
Если вы создаете правую ссылку
на обычную ссылку, то у вас тоже обычная ссылка.
Если вы создаете обычную ссылку на правую ссылку,
то тоже обычная ссылка.
И только если вы создаете правую ссылку на правую ссылку,
то у вас в итоге получается правая ссылка.
То есть это все можно уменьшить
до мини от амперсанда и 2 амперсанда.
То есть из амперсанда выживает только на меньшее из них.
То есть на меньшее количество амперсантов.
Еще раз вы в своем коде так писать не можете.
Еще раз, вы в своем коде так писать не можете, вы не имеете права написать вот так.
Так писать нельзя. Вот такой имеет право написать только компилятор, когда подставляет ваши шаблонные параметры.
Понятно? То есть что здесь на самом деле происходит?
Здесь у вас в качестве типа T подставляется int&&, потому что вы явно попросили об этом.
Но при этом тип X это int&& и тип Y это тоже int&& по правилу сворачивания ссылок.
Если вы передаете int&&, то в качестве T у вас естественно вводится int&&, потому что вы явно об этом попросили.
Но при этом тип X это int&&, а тип Y это int&&, потому что вы 2&& навесили на 2&&.
Все понятно?
Ну, это вот такая техническая деталь, про которую сейчас поговорили.
Окей. Теперь непосредственно про универсальные ссылки.
Смотрите, что такое универсальная ссылка?
Универсальная ссылка – это ссылка одного из двух видов.
Либо T2&, либо afto2&.
Вот, смотрите, когда я пишу обычную функцию fint2&, вот это называется R-value ссылка.
Ссылка на int.
Когда я пишу это все в шаблонном контексте, то есть если у меня T – это шаблонный параметр функции,
значит важно, что T – это шаблонный параметр функции.
Вот если T – это шаблонный параметр функции, и я написал T2&, то это считается не R-value ссылкой,
а это считается универсальной ссылкой, называется универсальной ссылкой.
Тоже самое касается afto.
Написали T2& и больше ничего.
Да, важный момент, что кроме T2& и кроме afto2& ничего не должно быть написано.
То есть никакого const не волатайл, не указатель, ничего.
Если T2&, ну, понятное дело, с точностью до замены там T на U.
Понятно, что если вы шаблонный параметр назвали по-другому, то это тоже работает.
Тут имеется в виду, что если вы написали шаблонный параметр,
2& без всяких const и так далее, то это универсальная ссылка.
Если вы написали afto без const, без указателей, без ничего другого,
просто 2&, то это тоже универсальная ссылка.
Важно понимать, что универсальной ссылкой R-value ссылкой не является.
Мы сейчас посмотрим, почему.
Мы посмотрим, как ведут себя универсальные ссылки.
А пока примеры того, что на самом деле универсальными ссылками не являются.
Как я сказал, универсальные ссылки это только ссылки вида T2& или afto2&.
Что универсальными ссылками не являются.
Если вы навесили на T или на шаблонный параметр const,
то это уже не универсальная ссылка.
Это R-value ссылка на константный T.
То же самое, если вы на afto навесили const или volatile,
то это считается не универсальной ссылкой,
а это считается правой ссылкой на const afto,
на const того, что будет выведено.
Кроме того, это более тонкий момент.
Если я тут написал, вот у меня есть класс stack,
и у него есть шаблонный параметр T.
Если я написал push T2&value,
несмотря на то, что я тут написал T2&value,
это не универсальная ссылка.
Почему?
Потому что T это не шаблонный параметр функции push.
T это шаблонный параметр класса stack.
Понятно разница?
То есть у вас T-шкой параметризован не push,
а сам stack целиком.
Если угодно, вот тут нет контекста вывода типа.
То есть тут типа T не выводится.
То есть тут T нельзя вывести.
Когда вы создаете stack,
вы уже создаете stack и подставляете явно нужный тип.
А вот здесь у вас типа T
является шаблонным параметром самого функции,
поэтому все нормально.
Ну и тут с afto понятно.
А если вы написали бы метод push вот таким образом,
то есть если вы написали шаблонный метод,
то есть вы на сам push навесили бы класс u,
то тогда бы это считалось универсальной ссылкой.
Почему?
Потому что u это шаблонный параметр самой функции push.
Понятна разница между этим и этим?
Между первым и вторым.
T это шаблонный параметр всей структуры.
Это не шаблонный параметр самой функции push.
Поэтому это не универсальная ссылка.
Во втором случае u к stack вообще никак не относится.
u относится только к функции push.
Поэтому u, двойной амперсант,
это универсальная ссылка.
С определениями понятно,
что такое универсальная ссылка,
а что такое не универсальная ссылка?
А универсальная ссылка работает медленнее?
В каком смысле медленнее?
Почему нам мешает,
когда всегда брали универсальную ссылку?
Я покажу, что нам мешает.
Дело в том, что универсальные ссылки,
они очень агрессивные.
Из-за того, что они универсальны,
из названия в принципе следует,
что они могут взять в себя все что угодно.
Иногда нам этого не хочется,
и я покажу, почему.
Это первый момент.
А второй момент,
если вы каждый раз будете навешивать универсальную ссылку,
то, да, это во-первых,
увеличивает время компиляции,
потому что мы знаем,
что шаблонные функции инстанцируются лениво.
То есть вам тогда на каждый чих,
на каждый вызов функции,
нужно создавать свою шаблонную функцию.
Но этого мы не очень хотим.
Тут есть некоторые проблемы,
о которых мы в самом конце поговорим.
А теперь они понятны, да?
Хорошо.
Теперь, наконец,
про назначение универсальных ссылок.
Как они работают? Почему они называются универсальными?
Дело в том,
что правила вывода для универсальных ссылок
немного отличаются от правила вывода
для остальных ссылок,
про которые мы говорили на лекции по шаблонам.
Первый пункт он сохраняется.
Помните,
если у меня в качестве параметра шаблонного
стоит амперсант, то есть ссылка,
то CV-квалификаторы они не отбрасываются.
Это мы говорили об этом.
А вот дальше начинаются
интересные особенности.
Если вы в качестве
аргумента универсальной ссылки
подсунете lvalue значение,
то тип T
выведется как lvalue ссылка.
То есть если я в данную функцию
function
подставлю x,
то тип T у меня будет иметь тип int амперсант.
Давайте более такой пример.
У меня есть const int x
равно нулю.
Я передал функцию function x.
Тогда у меня в качестве типа T
будет выведен
const
int амперсант.
Почему const int амперсант?
Почему const int понятно?
Константность не отбрасывается.
Почему ссылка?
Я в качестве параметра функцию
передал lvalue.
Поэтому тип T у меня выводится
как lvalue ссылка.
lvalue ссылка на const int.
И третье правило.
Если в качестве аргумента я передаю
rvalue, то есть все то, что не является lvalue,
у меня тип T выводится по обычным правилам.
Просто как обычный тип.
Скажем, если я сюда function
передам просто 0,
то в качестве типа T
у меня будет const int и все.
И теперь смотрите,
почему это называется универсальной ссылкой.
По следующей причине.
Тут все эти примеры написаны.
Значит, есть const int cx.
Я передаю функцию function cx.
В качестве типа T у меня выводится
const int амперсант.
И тогда какой у меня будет тип у аргумента?
Какой будет тип у арга?
По правилу сворачивания ссылок.
То есть у меня получается по сути тип у арга
это const int амперсант,
на который я навесил двойной амперсант.
Но у меня работает правило сворачивания ссылок,
при котором я двойную ссылку игнорирую.
Поэтому общий тип у арга будет const int амперсант.
То есть lvalue ссылка на константный int.
А если я передам 0,
то в качестве типа T у меня
выводится int.
А тип у арга будет T двойной амперсант.
То есть int двойной амперсант.
То есть что мы сделали?
Что мы получили?
Если я передаю функцию function lvalue объект,
lvalue значения,
то у меня тип аргумента, вот этого,
arg, выводится как ссылка
на то, что я передал.
lvalue ссылка на то, что я передал.
Если я передаю rvalue значения,
то у меня тип arg выводится
как rvalue ссылка на то, что я передал.
И это, кажется,
равно то, чего я хотел до этого.
Я хотел, чтобы арг был либо левой ссылкой на левый объект,
либо правой ссылкой на rvalue объект.
И вот в этом смысл универсальности ссылок.
Почему они универсальны?
Потому что в зависимости от того, что вы туда передали,
это либо lvalue ссылка, либо rvalue ссылка.
Все ясно.
Давайте по примерам пройдемся.
Попробуем поиграть.
Вот у меня есть функция function
с универсальной ссылкой.
У меня есть x, обычный int.
У меня есть cx, константный int.
У меня есть ссылка на int
и есть константная правая ссылка на int.
Если я вызываю function от x,
то что у меня выводится в качестве t?
То есть тут два вопроса.
Что у меня выводится в качестве t?
И какой тип имеет аргумент arg?
Какой тип у меня выводится?
Что подставляется в качестве t?
int&
По какому правилу?
По правилу 2.
Если я функцию передаю lvalue объект,
у меня тип t выводится как lvalue ссылка
на то, что я передал, то есть int&
А тип аргумента какой?
int&
Это универсальная ссылка.
Тут можно не обращаться к сворачиванию ссылок.
Тут можно сразу сказать,
что это та ссылка, которая нужна.
Вот ответ короткий.
Потому что это универсальная ссылка.
Если я передаю cx,
ну, cx обсуждали.
Тут тип const int&
Ну и тип тоже const int&
Теперь я передаю rx.
То есть t это int.
У вас есть время подумать.
Ну ладно.
Ладно, нет у вас времени больше.
Намек понятен?
Переменная это всегда lvalue.
Если вот за эти две лекции
нужно было что-то запомнить,
вот это одно, это вот.
Переменная это всегда lvalue.
Всегда, нет исключений.
Неважно, кого типа эта переменная.
Ссылка, правая ссылка,
константа, неконстанта.
Все, переменная это всегда lvalue. Почему?
Потому что за каждой переменной всегда лежит некоторая область памяти.
Даже по определению.
Переменная это именовная область памяти.
А мы говорили, что если у чего-то есть
какая-то область памяти,
то это lvalue.
Поэтому тут
какой тип у t?
У t int&
Потому что это lvalue.
Ну и ссылка, понятное дело, левая.
Итак, crx.
crx это
lvalue, ссылка на constant.
Что у меня вводится в качестве t?
constant int&
Почему?
Потому что crx это lvalue.
И это ссылка на
и она из себя представляет
константный объект.
Поэтому тут вводится constant int&
Ну и тип аргумента
это тоже
const int&
Отлично.
Вызываю function от нуля.
Давайте еще раз.
Если я вызываю function от нуля, то в качестве t выводится у меня int.
Потому что 0 это rvalue.
Да, ну и тип аргумента.
Да, int двойной &.
То есть rvalue ссылка на то, что мне передали.
Так, теперь.
Function от stdmove от x.
Инт или int&?
Инт или int&?
Инт или int&?
Инт или int&?
Инт или int&?
А кто считает, что int&?
Поясните, почему int&?
Ну
у нас будет
писаваться
все равно переменные.
Но просто rvalue переменные.
Перменные
это переменные, но
у stdmove какое?
У stdmove
как раз ровное это и назначение.
Притвориться rvalue.
То есть x это lvalue, да.
Но stdmove говорит, что то, что стоит в скобках,
должно притвориться rvalue.
Поэтому да, действительно, функцию мы на самом деле передаем rvalue.
Ну точнее, мы передаем не rvalue,
но мы передаем назначение, которое притворяется rvalue.
У нас даже название было для этого xvalue.
xvalue это часть rvalue.
OK.
То есть это rvalue.
Выводится тип int.
Ну и соответственно,
тип аргумента
int%
Я делаю stdmove от cx.
cx я напомню,
это константная ссылка.
Что у меня вводится в качестве t?
const int
Ну и в качестве типа ссылки
у меня вводится const int 0%.
Ну почему? Тоже понятно.
Что такое cx?
cx представляет себе lvalue,
по которому лежит константный объект.
Когда я делаю stdmove от cx,
у меня в качестве результата возвращается
как бы rvalue на константу.
Поэтому константность сохраняется.
То есть у меня есть константный объект,
и у меня есть константный объект,
и у меня есть константный объект,
и у меня есть константный объект,
поэтому константность сохраняется,
у меня передается const int,
то есть t вводится как const int,
потому что константность не игнорируется,
и плюс, так как я передаю rvalue,
ну как бы rvalue,
то есть stdmove говорит перетворить rvalue,
у меня вводится тип t без ссылки.
Ну и суммарно идти, у меня получается
просто const int 0%.
Ну и последние три примера,
что если я прям явно указываю,
что мне делать,
то есть если я пишу function int% x,
то я делаю тут везде,
t равно int% в первом случае,
t равно int% в втором случае,
и t равно просто int в последнем случае.
А какие типы аргументов?
Давайте в первом случае.
Да, тип аргумента просто int%
по правилу сворачивания ссылок.
int% или int% просто обычная ссылка,
давайте одну нарисуем.
int%
да, превратится в int%,
потому что я двойную ссылку навешиваю на двойную ссылку.
Если я пишу просто int,
то есть на просто int навешивается
двойная ссылка, все нормально.
Все, окей?
Понятно?
Ну вот.
Ну и теперь понятно,
к чему я все клонил,
и теперь понятно, что нужно принимать вот здесь.
Да, понятно.
Я принимаю
арг-двойной амперсант,
и теперь почти все ок.
Вот как раз первую половину, кажется, мы потратили
на решение части проблемы.
Да, если я передаю
универсальную ссылку, то что у меня получается?
Если я внутрь функцион
передаю ноль,
то у меня тип арг
это int-двойной амперсант,
то есть просто ссылка на этот ноль.
И я спокойно вычисляю раингтами от функцион 0.
То есть ноль передается по правой ссылке,
и вызывается обычный функцион, который работает с синтомом.
Все нормально.
Все корректно работает.
Если я же передаю x,
то вот тоже все хорошо,
потому что раингтайм функцион x принимает
x по ссылке,
то есть внутри арга у меня создается ссылка на x,
и внутри вот этой функции
раингтайм я работаю с исходным x.
Да?
Поэтому я когда внутри функцион передаю,
ну вот тут внутри, там блабла,
у меня там есть
вызов функ от арг.
Вот этот арг
на самом деле является ссылкой на x,
когда я вызываю ее вот так.
Поэтому внутри раингтайм
я работаю с исходным x,
и если какие-то изменения у меня затрагивают x,
то эти изменения я увижу и во внешнем коде,
то есть ровно то, чего я хотел.
Понятно?
То есть я написал одну функцию,
которая умеет подстраиваться
под нужные виды value.
Если я передал lvalue, то это lvalue ссылка.
И не нужно никого дублирования кода.
Универсальная ссылка, она примет в себя
все, что нужно.
Про вторую часть проблемы
поговорим после перерыва.
Овечная новая проблема.
Вот она.
Вспомним, как мы реализовывали
функцию раингтайм,
ну и добавив в нее универсальную ссылку.
Вот у меня функция
раингтайм,
я принимаю ARK по универсальной ссылке,
то есть теперь
если я передаю lvalue,
то я на самом деле принимаю lvalue
на исходный объект,
то есть я как бы внутри этой функции
я работаю именно с тем объектом,
который мне передали в эту функцию.
Ну и дальше я вызываю функт от ARK,
и здесь уже можно
Уже можно вот в этот момент понять, что что-то все-таки пойдет не так, что-то может пойти не так.
Давайте на конкретном примере. Смотрите.
У меня есть function l. function l говорит о том, что эта функция у меня принимает int по l-value ссылки.
Все нормально. Если я function l передаю x, то это работает.
Если я передаю ранний time function l от x, то это тоже работает и при этом работает корректно.
Мы это гарантировали с помощью универсальной ссылки.
Вот какой момент. Смотрите. Function l от 0 я, естественно, вызвать не могу.
Ну понятно почему. 0 не имеет права связываться с временными объектами, коим является 0.
Поэтому тут ошибка амбиляции.
Но внезапно, если я вызову ранний time от function l и 0, у меня все заработает.
То есть я как будто бы смог вызвать function l от 0.
Как так получилось? Самое главное, почему получилось?
Да, отлично. Потому что 0 стало переменной.
Потому что, смотрите какая картина.
Я в ARC могу передавать как l-value, так и r-value.
Точнее, в саму функцию ранних time.
Но на выходе, после того как я это сохранил в ARC, в чем у меня стал ARC?
L-value, то есть переменной или l-value.
Понятно? И когда я вызываю func от ARC, я функцию func всегда вызываю от l-value.
Всегда. Понятно?
Даже несмотря на то, что я в ARC сохранил ссылку на l-value или r-value,
сам ARC является l-value.
Поэтому когда я его передаю в функцию func, вот здесь, я передаю всегда l-value.
Даже если изначально у меня объект был r-value.
Беда.
Еще более тяжелая проблема.
Еще более тяжелая проблема начинается тогда, когда я создаю функцию,
которая принимает на самом деле r-value ссылку.
Смотрите, в чем прикол.
Я создаю функцию function r, которая принимает in двойной персант.
Если я вызываю function r от x, то ошибка эмпиляции.
Оно и понятно. Function r говорит о том, что я могу принимать только r-value объекта.
Если вызываю running time от function r и x, то тоже ошибка эмпиляции.
Тоже все нормально.
Потому что ARC это l-value, я не могу function r передать l-value.
Но есть существенная беда. Я могу вызвать function r от 0.
Могу? Могу. То есть in двойная ссылка связывается с 0.
Но когда я вызываю running time от function r и 0, я не могу так сделать.
Ошибка эмпиляции. Почему? Потому что 0 сохраняется в ARC.
И дальше этот ARC передается func от ARC.
А func у меня имеет право принимать только r-value ссылки.
Понятно?
ARC сам по себе является либо l-value ссылкой, либо r-value ссылкой.
Его тип является либо l-value ссылкой, либо r-value ссылкой.
Но сам ARC как объект является l-value.
Поэтому вот сюда, вот внутри func, я никогда не передаю r-value на самом деле.
И это проблема. Понятно?
Понятно, что у нас получилось? Какой кошмар мы устроили.
Ну вот, собственно, здесь это все показано.
Ну, в общем, суммаризация, что какие-то проблемы.
То есть наблюдается некоторая асимметричность.
Все-таки, наверное, хотелось бы, что во всех тех случаях, когда я могу вызвать функцию function,
она вызывалась. Во всех тех случаях, когда я не могу вызвать функцию function,
она не вызывалась. То есть создавалась ошибка эмпиляции.
Здесь у меня не так. Здесь в первом случае у меня на самом деле ce, а по факту ok.
Во втором случае у меня на самом деле ok, а по факту ce.
То есть running time работает, опять же, не так, как я хотел.
Я бы хотел, чтобы running time в принципе меня не замечался в программе.
То есть running time просто некоторая обертка, которая просто берет function,
которая берет аргумент и просто один аргумент передает другой, и все.
Беда.
Как решать эту проблему?
Давайте так, вот на таком чисто бытовом уровне.
Как решить эту проблему?
Вот как решить проблему с r-value?
Мы уже сказали, что вот здесь, внутрь функции func, я всегда передаю l-value.
Но иногда я бы хотел передавать r-value. Как мне передавать r-value?
Как мне из arg сделать r-value?
std move, отлично.
Следующая вещь. Хотелось бы иногда вызывать func от arg,
а хотелось бы иногда вызывать func от std move от arg.
std move от arg.
Понятно?
То есть в зависимости от того, что мне на самом деле передали,
я хочу еще на самом деле вызывать либо func от arg, либо func от std move от arg.
Дело в том, что внутри running time, arg всегда l-value.
Да, это правда.
Идея решения такая.
Если я в аргумент arg на самом деле передал l-value,
то нужно вызывать func от arg.
Все нормально.
Потому что я функцию передавал l-value, значит я хотел вызвать функцию function
от l-value, и поэтому нужно вызывать func от arg.
Потому что arg это само по себе l-value.
Если я в арг передал l-value,
то это означает, что я хотел бы, чтобы у меня функцию func пришло l-value.
И чтобы так случилось, мне нужно вызвать func от std move от arg.
То есть код должен выглядеть примерно как-то так.
Если в арг передали l-value, это не синтаксис, это вот я так написал,
если в арг передали l-value, то нужно вызвать f от arg.
А иначе нужно вызвать std move от arg.
Ну это вот то, чего мы хотим. Согласны?
Теперь еще один вопрос вам.
А можем ли мы как-то внутри функции func,
ну вот вообще в принципе вот по аргументам, по типам,
можем ли как-то понять, а что передали в арг?
То есть грубо говоря, вот у меня есть некоторые условия.
В арг передали l-value.
Могу ли я как-то понять, что мне передали в арг?
l-value или r-value?
Ну идея. Как бы я мог это понять?
Внутри функции у меня есть арг на руках.
Вот я вижу арг. Ну арг, хорошо.
Я же не знаю, на что на самом деле он ссылается.
Точнее, я же не...
Я знаю, что арг это l-value.
Но что туда передали?
Изначально l-value объект или l-value объект?
Что?
На арг.
Отлично. Прекрасно, гениально.
Нужно посмотреть на арг.
Всем понятно, почему на арг?
Чем является арг, если я передал l-value или передал r-value?
Чем является арг?
Да, в первом случае он является типом сосылка,
во втором случае он является просто типом без ссылки.
Но это только работа у универсальной ссылки.
Давайте напомним.
Универсальные ссылки при передаче l-value тип T
вводится как l-value ссылка. При передаче r-value тип
вводится как несылочный.
То есть на самом деле вот этот if в арг передали l-value.
То есть я могу принять решение на основании того,
чем является арг. Если арг является ссылкой,
то я не делаю std move.
Если арг является несылкой, то это значит,
что мне в аргумент изначально передавали r-value,
а я должен сделать std move.
Понятно?
Ну и собственно ответ. Универсальные ссылки
действительно по-разному вводят шаплонный аргумент arc.
Шаплонный параметр arc.
То есть он либо ссылочный, либо несылочный.
И вот на этом основании я могу принять решение,
что мне вызывать.
Ну и наконец волшебная функция std forward.
Вот эта сама std forward функция,
она делает все за вас.
Значит, std forward – это такая специальная функция,
которая выполняет условный move.
То есть std move – это std move и все.
То есть притворить r-value ссылкой.
А std forward говорит о том,
что std forward делает std move,
если реально объект связан с r-value значением
и не делает std move, если реально там
этот объект связан наоборот с l-value.
Понятно, да?
То есть std forward как раз таки выполняет вот этот вот условный move.
То есть внутри std forward грубо говоря написано что-то наподобие такого.
То есть он смотрит на тип арга,
и дальше делает std move от ARC или не std move от ARC,
в зависимости от того, является ли ARC l-value ссылкой или нет.
Да, ну здесь вот написано, что std forward от ARC.
Вот заметьте, что std forward,
дополнительно чтобы он понимал,
нужно ли ему делать или не нужно делать std move,
ему нужно дополнительно в треугольных скопках всегда передавать ARC.
Вот в этом отличие от std move.
Дело в том, что std move мы ничего не передаем в треугольных скопках.
std move мы говорим просто в круглые скопки и дальше прокинь дальше.
Все.
То есть std move всегда делает l-value ссылку.
А std forward, ну чтобы понять, что делать с ARC,
ему нужно дополнительно передать в треугольных скопках, собственно,
о чем этот ARC является, l-value ссылкой или не l-value ссылкой.
Ну и дальше он делает следующую вещь.
Ну понятно дело, что это не код на C++,
то есть там проверка выглядит чуть более сложная,
но в целом идея такая, он проверяет,
если ARC это левая ссылка, то возвращается просто ARC.
Тут, наверное, надо написать return.
Return ARC.
Иначе return std move от ARC.
Ну и теперь вот этот код,
который мы пытались написать с помощью Fof,
можно написать просто так.
Значит, принимаем ARC по универсальной ссылке
и дальше вызываем func от std forward от ARC.
Еще раз обращаю внимание, что std forward нужно вызывать
с треугольными скопками,
передавая туда ARC, то есть изначальный тип аргумента,
и, собственно, аргумент, который нужно либо move, либо не move.
Все, и теперь мы все проблемы решили.
Все, вот это корректное решение того,
как можно написать потенциально функцию running time.
Но опять же, не вдаваясь детали,
что функцию, на самом деле, вот эту функцию func
тоже желательно принимать по универсальной ссылке,
но это мы опустим.
Еще раз.
Есть функция running time,
которая принимает первым аргументом функцию,
вторым аргументом принимает универсальную ссылку.
Почему она принимает универсальную ссылку?
Потому что я хочу, чтобы у меня ARC
был либо lvalue с ссылкой,
либо lvalue с ссылкой,
зависит от того, что я передал.
Я принимаю отсчет времени,
то есть запускаю таймер,
и дальше функцию func передаю std forward от ARC и ARC.
Что делает std forward?
Условный move.
Если я хотел функцию func передать lvalue,
то std forward передаст lvalue.
Если я хотел rvalue, то std forward
сделает мне std move от того, что я туда передал.
Окей?
Все.
Ну и в конце,
еще раз нажимаю на таймер
и на этом завершаю работу
и возвращаю то, сколько времени
у меня работала функция.
И теперь не важно, какая у меня функция,
что принимает lvalue, rvalue просто по значению
и так далее, все у меня работает так, как надо.
То есть вызов function от x
абсолютно неотличим
от вызова running time
от function от x.
Понятно?
То есть вот эти вещи,
они абсолютно эквивалентны,
но опять же с точностью до того,
как время считает.
То есть сделали буквально
некоторый декоратор,
аналог Питоновского.
Все хорошо.
Ну вот,
на этом
основная суть.
Да, ну естественно,
можно обобщить на произвольное число аргументов,
то есть естественно,
мы хотим считать времени не только функции,
которые принимают один аргумент,
но потенциально произвольное количество аргументов.
Одного, двух, ну как обобщить?
Очень просто.
Принимаем произвольное количество аргументов
и каждый из них форвардим.
Ну это, я думаю,
не успели забыть, да, как это работает.
std forward от args
многоточие означает, что каждому аргументу
нужно применить std forward.
Все.
И теперь вы можете использовать функцию running time
для подсчета времени работы функции,
которая принимает вообще сколько угодно аргументов.
Хоть один, хоть два, хоть ноль.
Хоть десять.
Вот.
Ну и теперь просто простые примеры применения
из стандартной библиотеки,
где вы можете встретить функцию,
которая ведет себя как running time.
Ну running time это все-таки хороший пример,
но все-таки искусственный немного,
но есть более полезные применения этой всей техники
и как этим пользоваться.
Ну, во-первых, вернемся к std makeunique и makeshared.
Вот теперь я утверждаю,
что вы можете спокойно написать
функции makeunique и makeshared.
Как это сделать?
Давайте так. Что нужно
принимать в функции makeunique?
Умную ссылку.
Одну?
Да, то есть нужно
принимать
вариабельный шаблон, то есть шаблоны с переменом
числом аргументов, и при этом все это
по универсальной ссылке.
Потому что меня конструктор может ожидать
как rvalue, так и lvalue.
А дальше что я делаю?
Внутри создавать std forward.
Да, ну дальше я делаю newt и передаю
args многоточие, так?
Нет, да, std forward.
То есть я хочу
сохранить вид value.
То есть я хочу, чтобы те аргументы, которые
мне передали по lvalue, остались lvalue,
и все то, что мне передали по rvalue,
я хочу, чтобы осталось rvalue.
То есть я хочу...
Я бы это не сказал, но наверное стоило бы.
Вот forward, что значит forward?
Ну forward означает...
forward...
В этой части матика называется
perfect forwarding, то есть прямая передача.
Или идеальная передача.
Вот здесь я в то же самое.
Я хочу идеально взять аргументы
и идеально их передать в том же виде
внутрь какой-то другой функции.
Потому что чтобы обеспечить эту идеальную
передачу, я должен вызвать
std forward.
std forward.
Вот args.
Ну и в скобках передать еще
сами аргументы args, ну и многоточие.
Ну потому что их произвольное количество.
То есть универсальная ссылка
plus std forward
позволяет обеспечить идеальную прямую
передачу. То есть perfect forwarding.
Это надо написать.
Perfect.
Forwarding.
OK.
Еще один пример из стандартной библиотеки.
Вы наверняка
пользовались всякими
векторами, вектор, дек и так далее.
Вот у вектора, помимо метода pushback,
ну и собственно
для строк вы тоже написали нам свой pushback
и так далее.
У вектора есть дополнительный метод emplaceback.
Как он работает?
Ну вообще
в чем проблема pushback? Почему нам нужно
дополнительный emplaceback? Ну смотрите,
допустим, у меня есть
некоторый тяжелый объект.
Что значит тяжелый? Это значит, что его долго копировать,
его долго перемещать.
Вызывать его конструктор
очень дорого.
Что если я хочу
создать объект heavy object,
то есть тяжелый объект, ну и запихнуть его
в конец вектора?
Что происходит здесь?
А здесь происходит следующая вещь.
Создаю тяжелый объект,
ну без создания
мне не обойтись, тут как бы все нормально.
Я создаю тяжелый объект, а даже
что делает pushback?
Ну pushback его копирует, да, в нужное
место, ну вообще говоря, он его может и
мувнуть. То есть pushback
может понять, что мы передали времени
и значение, его мувнуть. Но так или иначе,
тут происходят две вещи. Создание
либо копии, либо move, то есть
два действия.
Ну по факту, что я хочу сделать?
По факту я хочу взять массив и просто
в последнюю ячейку записать
нужный объект. То есть прямо в
нужной ячейке создать нужный мне объект.
И вот ровно это и делает emplaceback.
Emplaceback
принимает не сам объект,
в отличие от pushback. Вот pushback принимает
объект, и дальше уже с ним что-то делает,
либо копирует, либо перемещает. А вот
emplaceback принимает параметры конструктора.
Вот он принимает параметры
конструктора и в нужном месте,
в нужной ячейке создает нужный
мне объект.
И вот emplaceback, в отличие от pushback,
просто-напросто вызывает один конструктор,
просто-напросто создание. Без копирования,
без перемещений. И поэтому потенциали
использования emplaceback, оно гораздо
более эффективно, чем pushback.
Особенно в случае каких-то тяжелых объектов.
Понятно?
Ну и emplaceback
на самом деле работает примерно так же,
как и, собственно,
как и sdmake-unique и sdmake-shared.
Мы принимаем параметры конструктора,
и дальше их forward-им в нужный конструктор.
То есть делаем sdforward
от этих аргументов и создаем в нужном месте
объект.
Окей?
Окей.
Да, ну и здесь вот,
здесь у меня представлена упрощенная реализация emplace,
как бы это могло работать, ну например, в случае
нашего стека, который мы писали.
Ну опять же emplace принимает произвольное количество аргументов,
ну и дальше мы их все
передаем в конструктор T.
Сразу скажу, что это
не совсем то, как работает настоящий emplace
или emplaceback.
Дело в том, что тут вызывается присваивание.
А мы бы хотели в нужном месте создать объект.
Но вот об этом, я надеюсь, мы
в какой-то момент поговорим, но, в общем,
если прям хочется углубиться в это,
то вот, почитайте про placement new.
Ну, если что, в третьем задании
вы познакомитесь с placement new,
все будет нормально.
Идея понятна.
Принимаем параметры конструктора и передаем их
в нужный конструктор при создании.
Вот.
Так.
Время есть, отлично.
И вот теперь про проблемы с
универсальными ссылками,
то есть, каким проблемам они могут привести.
Смотрите.
Можно было сказать
следующую вещь. Ну, хорошо.
Есть универсальные ссылки, давайте всегда
использовать универсальные ссылки
и только их, потому что они
могут адаптироваться под вид-value,
и так далее.
Тут могут возникли проблемы, если вы используете
шаблонный конструктор с универсальными
ссылками. Смотрите в чем проблема.
О, допустим, у меня есть
дефолтный конструктор, у меня есть конструктор
копирования, и я дополнительно
написал универсальный конструктор
который принимает что угодно, и с этим что угодно
что-то делает.
Ну и дальше, ну, собственно, понятно.
У меня есть конструктор копирования,
наверное, я могу копировать объект.
Ну хорошо. Я создаю объект А
и вызываю конструктор копирования от A, создаю объект B.
Вместо того, чтобы увидеть на экране копии,
я вижу, что что-то пошло не так.
Почему-то вот здесь вывозил не конструктор копирования,
а вывался этот шаблонный конструктор, который принимает универсальную ссылку?
Вопрос, почему так вышло?
Почему не был вызван конструктор копирования, а был вызван такой универсальный конструктор?
Да, да, отлично. Смотрите. Дальше на следующем кладете.
Что такое a? Давайте так, поработаем компилятором. Что делает компилятор?
Компилятор пытается понять, какой конструктор вы имели в виду.
Ну хорошо, он смотрит сюда и видит. У меня есть a, и a я могу передать по константной ссылке.
Что мне нужно сделать, чтобы a передать по константной ссылке?
Мне нужно сделать приведение типа. У меня a не констант, и я должен его привести к константе.
Логично. Я могу не констант, а приводить к константам.
А теперь компилятор смотрит вот сюда и думает, чтобы передать сюда a, что мне нужно сделать?
a это lvalue, поэтому в качестве типа t выводится ссылка. А ссылка на что?
A у меня не константный объект, поэтому вводится не константный a.
И компилятор понимает, что у него есть выбор. Передать сюда объект по константной ссылке,
или передать сюда a просто по ссылке. Естественно он выбирает второй вариант.
Почему? По принципу точного соответствия.
Вот этот конструктор обеспечивает точное соответствие.
То есть я передал не константный a, и я могу сюда передать ссылку на не константный a.
Ну и все. Конструктор копирования заблокирован.
Ну в таких случаях. Если бы мы передали константный объект, то естественно
вызвался бы конструктор копирования нужный.
Но как часто вы копируете константные объекты?
Как часто вы еще код пишете?
Хотелось бы чаще, ну ладно.
Ну и как решить эту проблему? Решение несколько.
Решение. Это… Если вам очень сильно хочется и очень сильно нужен конструктор от универсальной ссылки,
то вам придется прописать конструкторы на все случаи жизни.
То есть вам нужно написать конструктор копирования, который принимает константный a.
Вам нужно писать конструктор копирования, который принимает не константный a.
Вам нужно написать конструктор перемещения.
И плюс написать конструктор, который принимаетupid self url ссылке.
Все эти случаи нужно прописать, чтобы их внезапно не забрал себе вот этот самый универсальный конструктор.
Либо вы можете написать еще раз какую-то там магическую функцию, которая, давайте так, в общих чертах обрисуем, что она делает.
EnableIFT говорит нам о том, что эта функция должна быть включена только в случае, если неверно, что тип A не совпадает с типом std.dk.i.t.
В общем, грубо говоря, здесь написано, что эта функция должна принимать участие в перегрузке только если после того, как вы убрали все ссылки, все константы с типа T, у вас получится A.
Ну понятно, что если после того, как вы очистили тип T от ссылок и от константов, у вас получилась A, то значит, что этот конструктор вызывать не нужно.
Но это магия, она вряд ли пригодится. В общем, общее замечание – не используйте универсальный конструктор и все.
Они нужны, но они нужны крайне редко, в нашем курсе они вам точно не нужны.
Ну и последний пункт. Он такой более развлекательный.
Он тоже напрямую не относится к символике перемещения, но он скорее больше поучительный про то, что конструктор перемещения на самом деле очень сложно вызвать.
Давайте посмотрим налево. Что я хочу сделать? Что я хочу показать? Я хочу провести несколько экспериментов и посмотреть, в каких случаях у меня вызывается move конструктор,
в каких случаях у меня вызывается copy конструктор и вообще вызываются они или нет на самом деле.
У меня есть обычный класс A, который просто-напросто логирует все то, что он делает.
То есть когда он создается, он говорит, что я создался с помощью default конструктора, если он создался с помощью копирования, он говорит, что был вызван copy конструктор,
если он там был перемещен, то он говорит, что move конструктор, ну и так далее. В общем, он просто говорит, какие действия он выполняет.
Дальше у меня есть функция f и есть функция g, о них позже поговорим. Давайте просто перейдем по порядку примером.
Давайте по порядку. Давайте C++14 пока включим.
Ну по порядку. Секция номер ноль. Что я делаю? Я создаю объект A, дальше копирую объект A в B и дальше присваиваю объект B в A.
То есть что я ожидаю увидеть? Я ожидаю, что объект A создаться с помощью default конструктора, объект B создаться с помощью copy конструктора,
а дальше третьей строкой у меня что будет? Ну копирующее присваивание. Ну ровно это, кажется, я и вижу. Вот экзампл ноль справа.
Сначала вызвать default конструктор, потом copy конструктор, потом copy assignment. Ну ничего удивительного нет.
Дальше переходим к первой секции. Я создаю объект A и создаю объект B с помощью std move от A.
А потом присваиваю объект A и std move от B. Что я ожидаю увидеть? Я ожидаю увидеть одно создание с помощью default конструктора и дальше два move.
Ну собственно это и происходит. Снова ничего удивительного.
Ну std move от A и std move от B как раз говорит нужно притвориться временным и поэтому как бы здесь объект B, в 47 строке объект B думает, что справа стоит rvalue,
поэтому вызывается конструктор перемещения. А в 48 строке объект A думает, что справа стоит rvalue и вызывается перемещающее присваивание.
Ну это обсуждали в прошлый раз, тоже ничего удивительного. Все хорошо.
А вот теперь должны начаться удивительные вещи. Номер два. Смотрите, давайте поработаем старым компилятором, ну не знаю, компилятором образца 14, 11 или еще более старого образца.
И попробуем чисто пенантично, формально посмотреть, что тут на самом деле должно происходить. А что тут должно происходить?
Я создаю объект A с помощью rvalue значения A. То есть я справа создаю временный объект и говорю, что с помощью него нужно создать объект, который стоит слева.
То есть казалось бы, если следовать строгой букве языка C++, то что тут происходит? Сначала создается временный объект, то есть вызывается default конструктор.
А потом этот временный объект должен переместиться в A. Согласны? Ожидаемое поведение? Ну и здесь тоже на самом деле.
Тут уже не конструктор, тут уже присваивание. Я справа создаю временный объект, и временный объект присваиваю в A.
То есть у меня должен вызываться один default конструктор, и плюс этот вот временный объект, который создался, должен переместиться в A.
То есть я должен увидеть два дефолт-конструирования и два move-конструирования.
Что я вижу на самом деле?
А я вижу, что один move пропал внезапно.
Причем пропал move именно отсюда, с 53-й строки.
То есть в 53-й строке у меня вызвался только один дефолтный конструктор.
Никакого move не произошло.
Ну, допустим.
Что вы скажете на это?
Тут надо посмотреть на определение функции f.
Функция f простая. Функция просто возвращает a.
Но она создает a в return и сразу же его возвращает.
Функт 3.
Что я ожидал увидеть? Снова.
Я справа вызываю функцию f.
У меня функция f должна создать этот объект,
а потом переместить его в a.
Наверное, так должно работать.
Ну и на 60-й строке тоже самое.
f создает новый объект, и дальше я его перемещаю с помощью присваивания в a.
Смотрим, что на самом деле... Снова.
Куда-то пропал один move.
И move пропал в 59-й строке.
То есть f у меня создал объект,
но как будто бы его никуда не переместил.
Странно.
Идем дальше.
Смотрим на определение функции g.
Функция g работает примерно точно так же, как и функция f,
но при этом она внутри себя создает объект a.
А потом этот объект возвращает.
То есть она внутри себя создает объект, и потом его возвращает.
То есть тут уже как бы не отвертеться.
Так или иначе у нас этот объект должен создаться внутри.
У меня есть такая инструкция.
Поэтому тут как будто бы я ожидаю следующего поведения.
Я ожидаю, что у меня функция g внутри себя создаст объект
с помощью default-конструктора.
Потом этот объект вернет в точку вызова с помощью move-конструктора.
И дальше вот этот временный объект, который получился,
снова move-нется в нужное место a.
Ну и в 66-й строке то же самое.
Смотрим.
Ну тут вообще совсем непонятно.
В строке номер 65 вызывается только один default-конструктор.
То есть вот тут у вас должны заказаться сомнения.
Ну смотрите, в 65-й строке, в принципе, кажется,
и априори не может создаться один объект.
Почему?
Потому что как минимум я создаю вот этот объект.
Видно, да?
Я его объявляю.
И плюс я создаю вот этот объект.
Более того, функцию g я вызываю два раза.
Поэтому функция g должна была создать мне два объекта.
А выходит, как будто бы не создает ни одного.
Ладно.
Ну и наконец, ну давайте, да, пятый пример.
Пятый пример, ну, так.
Определение функции h.
h просто принимает внутри себя аргумент a.
Вот.
То есть я создаю параметр a.
То есть с помощью дефолтного конструктора.
Я передаю h от a.
Я ожидаю, что у него будет вызван копирующий конструктор.
Я вызываю h от sdmove от a.
У меня должен вызваться move-конструктор.
Тут, на самом деле, все нормально.
Да, так и происходит.
Все.
Если h принимает, то есть если я h передаю a, то a может только скопироваться.
Если я делаю sdmove от a, то a притворяется временным
и вызывается конструктор перемещения.
Все нормально.
И вот, наконец, финальный пример.
Что если я в h передам a с круглыми скопками?
Ну, снова, что я ожидаю?
h принимает a.
Значит, вот здесь должен создаться временный объект a.
А потом переместится в h.
Что произойдет здесь?
f.
Напомню, f возвращает просто a.
То есть делает return и создает a на месте.
То есть я ожидаю, что f мне создаст в нужном месте a.
И потом этот a переместится в h.
Ну, и с g тоже самое.
g внутри себя создает объект a.
Потом его возвращает наружу.
И вот то, что свернулось наружу, должно перейти в h.
Вообще безобразие.
Смотрите.
Только три дефолтных конструктора.
Хотя при этом, смотрите, я создал a вот тут.
У меня f должен был создать a, g должен был создать a.
И плюс a в качестве своего аргумента тоже принимает a.
То есть там тоже должен был создаться a.
Но куда-то это все делось.
И вот дело как раз так называемым copy-elision.
Ладно, тут не буду переключаться, в общем, скажу словами.
На слайдах можете посмотреть.
Значит, copy-elision.
Copy-elision это оптимизация компилятора, которая избавляется
от временных объектов.
Ну и действительно, смотрите, везде в коде, где я писал
default-plus-move и так далее, везде я как бы подразумевал,
что у меня есть некоторый временный объект, который
нужно куда-то переместить.
И вот компилятор на самом деле в этом смысле не дурак.
Компилятор понимает, что вот вы тут, давайте вот
тут, например, вот вы тут создаете временный объект,
а потом его сразу перемещаете в a.
Ну это неэффективно, согласны?
То есть, наверное, было бы логично сразу взять этот
объект и создать в нужном месте.
И вот ровно это и происходит.
Ровно это и заключается, ровно в этом и заключается
копия-elision.
То есть, эллиминация копирования, уничтожение копирования.
И ровно это происходит везде.
То есть, смотрите, f.
f должен создать временный объект и потом переместить
его в a.
Компилятор не дурак.
Компилятор понимает, что вот то, что создает f, на
самом деле нужно только для того, чтобы проинцидизировать
a.
Поэтому вот то, что создает f, сразу же, сразу конструируется
в том месте, где находится a.
Для функции g это вообще удивительно.
Смотрите, казалось бы, внутри функции g я создаю a.
То есть, я вот эту a-шку создаю внутри g.
Но компилятор понимает, что вот этот a, на самом деле,
нужен по итогу только для того, чтобы проинцидизировать
вот этот a.
И поэтому вот этот a, на самом деле, сразу же создается
в нужном месте.
Понятно?
То есть, вот этот a, на самом деле, то есть, вот тут создается
не тот a, который внутри g, а создается именно тот
a, который находится вот здесь, в пункте 4.
Вот это все называется копия иллюзии, и это все оптимизация
компилятора.
Эту оптимизацию компилятора можно отключить с помощью
опции minus f no elite constructors.
Вот, и теперь мы, давайте посмотрим сразу интересные
примеры.
Вот пример 4.
Вот в примере 4 теперь мы видим все то, что ожидали
увидеть.
Default constructor, потом move constructor, потом еще раз move constructor
и так далее.
Вот все то, что убрал нам компилятор, мы просили
не убирать.
Ну вот, пожалуйста.
Ну и последний пример тоже интересный, тут тоже много
чего.
Помните, в шестом примере у нас было всего лишь три
вызова конструктора.
То есть, три создания объекта.
А здесь мы создали объект, переместили, создали объект,
переместили, создали объект и два раза переместили.
Ну, почему два раза переместили?
Потому что как работает g?
g сначала создает объект, потом его возвращает в место
вызова с помощью cd move, а потом из этого места вызова
он еще move-ается в то, куда его попросили переместиться.
Понятно?
Вот, поэтому копия иллюзии, это такая хитрая штука.
С одной стороны, она позволяет очень сильно сэкономить
на копированиях и на перемещениях.
С одной стороны.
С другой стороны, она может вызывать некоторые недоумения
в случае, если вы все-таки ожидаете увидеть что-то
на экране.
Ну, тут я как бы делал так, чтобы у меня конструктор
водили что-то на экран, но в принципе вы могли закладываться
на поведение, что у вас move-конструктор дополнительно
что-то делает полезное.
И вот в этом смысле компилятор это все убирает.
И об этом важно помнить.
И это как бы было расширение компилятора в обход стандарта
языка.
В обход стандарта языка.
Но в 17 стандарте копия elision официально, в общем,
в общем, его легализовали в C++.
Давайте посмотрим.
Давайте посмотрим на то же самое, но только внутри
C++17.
Снова я делаю все то же самое, но в C++17 и при этом говорю
компилятору, пожалуйста, не убирай конструкторы.
То есть не убирай конструкторы, которые ты можешь убрать.
Что у меня происходит?
Снова все нормально.
И снова мы видим, что почти везде нужные конструкторы
убрались.
Давайте сравним.
В C++14, ну, экзампл 6, в C++14 я явно попросил компилятор
не убирать конструкторы, он ничего не убрал.
В C++17 я явно попросил компилятор не убирать конструкторы,
и он все равно что-то убрал.
Это как раз говорит о том, что в 17 стандарте вот это
поведение, убирание конструкторов, которые не нужны, стало
обязательным.
Обязательно, но не во всех случаях.
Об этом на слайдах поговорим.
Давайте пока вопросы.
Пока все понятно.
То есть на самом деле в современных плюсах вызвать
конструктор перемещения не так-то просто.
То есть на самом деле компилятор может все соптимизировать
так, что и без всякого перемещения у вас все будет...
Ну ладно, в принципе, на этом все, если что, закончим
в следующий раз.
А пока пожарная тревога.
