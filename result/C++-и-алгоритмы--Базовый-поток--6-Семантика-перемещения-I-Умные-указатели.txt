Сегодня мы пройдем две такие базовые темы, которые вам нужны будут для решения второго задания.
Собственно, мы, наверное, сегодня закончим всю базовую часть, которая относится к второму заданию.
Вот двумя довольно важными и, на мой взгляд, интересными темами.
И первое, с чего мы начнем, мы начнем разговор про семантику перемещения.
Семантика перемещения – это то, без чего, вообще говоря, не обходятся современные плюсы.
Ну и, на самом деле, то, что зачастую делает ваши программы более эффективными, чем они, возможно, были до этого.
Но во всем по порядку.
Чтобы начать разговор о семантике перемещения, необходимо вернуться довольно сильно назад,
возможно, даже на одну из первых лекций по языку вашего первого семестра.
И необходимо поговорить про выражение и вообще про структуру программы на C++.
Наверняка, когда вы только начинаете обсуждать язык C++, вы говорили про какие-то конструкции,
про то, какие операторы в языке существуют, как строится программа на языке C++.
И вы говорили, что программа на языке C++ стоит из стейфментов,
и большинство из стейфментов представляют собой так называемое выражение или экспрешены.
То есть, вообще говоря, что такое выражение?
В общем, у меня просто некоторая последовательность символов,
которая задает некоторые вычисления.
Ну или формально это последовательность некоторых операций, операндов,
ну и, собственно, вот эта вот последовательность операций-операндов
задает некоторые вычисления.
То есть, это та вещь, которая, собственно, производит некоторые математические вычисления
или какие-то другие штуки, которые представляют собой непосредственно исполняемый код,
то есть, то, что делает программа.
Ну и соответственно, результат любого выражения на языке C++ представляет собой
в результате выполнения выражения мы получаем либо некоторое возвращаемое
значение, например, результат выражения х плюс у
результат выражения х плюс у возвращает вам результат сложения
результат вызова какой-то функции口т аргумента возвращает результат этой функции
результат выполнения выражения может вам приходить в виде некоторого побочного эффекта
например если вы делаете плюс плюс х или х плюс плюс кач
попочного эффекта вы дополнительно получать еще увеличенный х
Если вы вызываете какую-то функцию, например, функцию printf,
эта функция печатает что-то на экран, то есть это побочный эффект.
Любое выражение задает некоторое вычление, и результаты этого вычления
мы получаем либо в виде возвращаемого значения, либо в виде некоторого побочного эффекта.
Причем возвращаемое значение у вас есть всегда, побочный эффект не всегда,
как, например, у результата сложения.
И о чем вы, наверное, не говорили, так это про то, что каждое выражение,
оно обязательно характеризуется двумя вещами.
Вот у любого выражения всегда есть две характеристики.
Первое — это тип возвращаемого значения, то есть, как я сказал,
выражение всегда что-то возвращает.
А второе — это некоторая такая штука, про которую вы точно не говорили,
это категория значения.
И вот, собственно, с разговора про категории значения мы и начнем сегодняшнюю лекцию.
Ну, давайте для начала просто пройдемся по примерам и просто поймем,
потому что мы с вами на одном языке разговариваем.
Ну, допустим, у вас есть переменная типа int, это x, и другая переменная типа int — это y.
Вот результат выражения x плюс y, то есть x плюс y — это некоторое выражение,
и его возвращаемый тип — это int, да, все согласны.
Вот, побочного эффекта у этой операции нет, ну, то есть, кроме того,
что оно возвращает вам результат сложения, ничего не происходит.
Вот, ну и есть, ну и также у этого выражения есть некоторая характеристь,
которая называется категорией значения, при нем мы пока ничего не знаем.
Окей, есть выражение плюс плюс x, он возвращает вам тоже int.
И при этом увеличивает x на единицу. Тоже самое с x плюс плюс.
Тоже возвращает int и увеличивает x на единицу.
И здесь уже, наверное, должно стать понятно, потому что, с одной стороны,
мы понимаем, что плюс плюс x и x плюс плюс — это, вобще говоря, разные операции, да.
Ну, то есть, во-первых, мы понимаем, что они возвращают разные вещи.
То есть, первая штука возвращает вам измененный x, вторая штука возвращает вам x старый.
Но при этом, что еще мы знаем про плюс плюс x и x плюс плюс, в чем их разница?
Что еще раз?
Ну да, вы уже говорили про l-value и l-value, но если грубо говоря, то результату плюс плюс x можно что-то присвоить, в частности.
А результату x плюс плюс ничего присвоить нельзя, то есть вы не можете написать x, вы не можете написать x плюс плюс, допустим, равно единице.
А написать плюс плюс x равно единице можете, то есть это ce, а это ok.
То есть в этом смысле они уже различаются.
Собственно, забегая заранее вперед, скажу, что как раз эта разница заключается в так называемой категории значений.
Ну окей, давайте пойдем дальше. New int.
New int – это тоже выражение, которое возвращает вам некоторый указатель.
Ну и в качестве побочного эффекта происходит некоторое выделение ресурса.
То есть у операционной системы запрашивается некоторая область памяти в оперативной памяти и так далее.
Ну и delete p – это тоже выражение, данное выражение возвращает void, ну и соответственно в качестве побочного эффекта у вас ресурс возвращается операционной системе.
Ну такие примеры.
Ну и теперь давайте поговорим про категории значений. Что же это вообще говоря такое?
Категория значения, значит самый главный вопрос, на который отвечает категория значения – это материален ли тот объект, который вам вернулся или нет.
То есть возвращаемся к вопросу о plus plus x, x plus plus.
Вот когда вы возвращаете результат, допустим, сложение, давайте сначала поговорим про x plus y.
Когда возвращается результат значения x plus y, то этот результат, грубо говоря, нематериален, то есть вы его не можете пощупать.
Вам возвращается результат и все.
Если я вас спрошу, чему равен результат выражения 2 plus 3?
5. А где это 5? Можно его пощупать? Нет, нельзя.
Не знаю, вопрос. Что является средством общения?
Телефон. Какой телефон? Ну непонятно.
А если я спрошу, что сейчас лежит на столе? Вот телефон, вот он.
Это объект материален, то есть я могу конкретно указать на него.
И в этом разница.
То есть есть результаты, которые нематериальные.
Мы просто грубо говоря их произносим, и все.
А есть результаты матери wszystkie, то есть конкретные объекты.
Если я спрошу, кто присутствует сейчас на лекции?
Я скажу, человек.
evп MDB
И они просто студенты. Или какой-то студент.
Если я скажу, что студент присутствует на лекции, то это правда.
Если я скажу, что этот конкретный студент присутствует на лекции, то это он сидит здесь.
Я могу его пощупать, я могу с ним что-то сделать, я могу его изменять.
В этом разница. Понятно?
то есть есть материальные объекты, у которых есть реальное представление в памяти,
которое присутствует реально в виде объектов, а есть просто так называемые временные значения,
которые буквально здесь появляются и сразу же исчезают.
И вот эту разницу создает как раз категория значений.
Давайте снова вернемся к примеру.
Понятное дело, что во всех выражениях, кроме одного, объекты здесь не материальные,
в частности x и y. Здесь и сейчас создается результат,
когда aparecerал результат, но при этом он нигде не сохраняется, который нигде не присутствует явно,
то есть результат подставляется в данном конкретном месте и все,
после этого он сразу исчезает.
x++ тоже. Вам возвращается старое значение, но при этом оно нигде в явном виде в памяти
не присутствует. В том месте, где лежит x, там уже лежит не старое значение, а новое,
поэтому у старого значения нет никакого явного представления в памяти.
newInT baseline — результат возвращается в виде указателя, то есть указатель просто возвращается,
и он нигде не хранится на самом деле.
в принципе, не полный тип, он нигде храниться не может.
Единственное выражение в данных примерах, которое
обладает свойством материальности,
то есть результат выражения представляет в себе реальный объект памяти,
это plus plus x. Понятно?
То есть plus plus x возвращает int, и мы можем конкретно сказать,
какой int. Вот int, который лежит
по месту в памяти x.
Данный конкретный x.
Все понятно?
И вот такие категории значений, которые представляют из себя
реально материальные объекты в памяти,
называются L-value.
Л-value это категория значений, которая обладает идентичностью.
Ну и дополнительно она еще обладает тем свойством,
что она неперемещаема, но об этом позже поговорим.
Пока для нас главное, что L-value это категория значений,
которая обладает идентичностью.
Вот. Как отличить L-value от...
Не L-value. Ну, очень просто.
Если у результатов выражения вы можете взять адрес,
то есть вы можете спросить где это вот...
Вот вам вернулся результат, вы можете спросить где он,
где он расположен. Тогда это L-value.
Если у результатов выражения вы не можете спросить адрес, то это не L-value.
Это не критерия, на самом деле, не свойство, но и может пользоваться как критерия.
Вот, значит. Что относится к L-value?
что обладает идентичностью, что обладает некоторым материальным представлением.
Во-первых, переменная.
Первый пункт на самом деле самый важный.
Переменная это всегда lvalue.
Всегда, нет никаких исключений.
Переменная это всегда lvalue.
Если вы в коде встречаете переменную, то сразу говорите,
что выражение, которое представляет себе переменную, возвращает вам lvalue.
Дальше.
Если у вас функция или операция возвращает ссылку,
например, вы написали вот такую функцию.
Бла-бла.
И вот если в качестве возвращаемого значения вы указываете int амперсант,
double амперсант или что угодно амперсант,
то результат этого выражения – это lvalue.
И тут стоит отдельно поговорить о том,
что на самом деле такого типа возвращаемого значения как ссылка
на самом деле формально.
Потому что когда вы что-то возвращаете из функции,
вы на самом деле что говорите в конкретном случае?
Вы говорите, что вы возвращаете int, что результат выражения f,
то есть когда вы будете писать просто f,
что результат этого выражения будет int,
и при этом категория значения – это lvalue.
Вот как раз эта ссылка говорит не о том, что вы возвращаете ссылку как тип,
а говорит о том, что вы возвращаете int, и при этом этот int является lvalue.
Понятно?
То есть тип ссылки может называть только переменные,
которые вы объявляете вот таким образом.
Если у вас есть некоторая функция,
которая возвращает, допустим, int амперсант,
то правильно говорить, что функция f возвращает int
с категорией значения lvalue.
Для краткости обычно принято говорить, что f возвращает ссылку.
В формальной точке зрения это не совсем корректно.
Понятно, что я хотел сказать?
То есть когда вы из функции или из операции
делаете что-то по ссылке с амперсантом,
то это означает, что вы возвращаете объект, то есть lvalue.
Тоже самое касается любых операций, которые вы перегружаете
или которые есть в языке.
Сейчас если plus-plus-x, то понятно, что возвращает ссылку.
Что еще возвращает ссылку?
Всякие присваивающие версии – x плюс равно, x делить равно и так далее.
Все, они возвращают ссылку, они возвращают lvalue.
Третий пример lvalue – это строковые литералы.
На первой лекции я, кажется, пытался что-то сказать,
поэтому даже в камеру говорил.
Сейчас говорю, что строковые литералы – это lvalue.
К строковым литералам можно относиться так,
что это просто некоторое специальное имя переменной,
которое представляет себе ссылку куда.
Куда идет ссылка строковых литералов?
На первой лекции говорили.
Где хранятся строковые литералы, строки?
В таблице строковых литералов.
То есть когда вы пишете ABC,
можно считать, что это некоторая специфичная переменная,
которая просто представляет на себя область памяти,
которая расположена в таблице строковых литералов.
Соответственно, все эти примеры, первые три,
x плюс плюс x, ABC – это все выражение, которое представляет себе lvalue.
x плюс плюс один не является lvalue.
Это понятно, потому что возвращается временный объект,
у которого нельзя спросить адрес,
только здесь появился и сразу же исчез.
Пока все понятно.
Почему lvalue называются именно lvalue?
Это пошло еще из древнего, даже еще, по-моему,
до языка C, когда говорили,
что lvalue выражениям назывались те выражения,
которые можно ставить в левой части операции присваивания.
Сейчас это не так, но просто откуда пошло само название l?
L отвечает за left, то есть левое значение.
Но сейчас, вообще говоря, это неправда.
Можете привести пример, когда что-то является lvalue,
но при этом не может стоять в левой части присваивания.
Что еще раз?
Ну, строковый литерал в левой части операции присваивания.
То есть нельзя написать ABC равно что-то.
Ну или константы, на самом деле.
Если вы объявили const int x,
мы говорили, что переменная это всегда lvalue,
но при этом в левой части присваивания x стоять не может.
Все понятно?
Окей.
Здесь я, видимо, оставлял место для того, чтобы что-то присваивать.
Короче говоря, чтобы понимать такое lvalue,
lvalue это те значения, у которых есть место жительства,
у которых есть постоянный дом.
То есть если вы пишете x, то x на самом деле отвечает
на какое-то конкретное место в памяти.
Вот у вас есть memory.
Если вы пишете что-то наподобие такого,
вот представьте, что вы взяли адрес x,
увеличили адрес x на единицу,
и потом его разоминовали.
Вот результат этого выражения это lvalue или не lvalue?
Давайте так. Разберем вот это выражение.
Что возвращает это выражение?
Это характеризуется двумя свойствами.
Первый — это тип. Какой тип имеет результат такого выражения?
Ну какой тип?
Если x — это int,
тогда результат этого разоминования действительно int.
Тип — это int. Вы взяли адрес int, прибавили к нему единицу,
то есть взяли следующий по адресу int,
и разоминовали это значение, получили результат int.
Вот у результата разоминования у него есть какое-то место в памяти?
Да, вот он, адрес x плюс 1.
Грубо говоря, у вас есть улица, в которой стоят всякие дома.
В домах эти хранятся всякие значения.
Вы сказали, что вот есть дом пятерки, находится по адресу x.
А теперь мы взяли адрес x на единицу вперед,
то есть вот здесь.
Здесь непонятно, что хранится, но при этом мы можем сказать,
что тот результат, который вернулся,
у него есть конкретное место в памяти.
И мы вот это конкретное место в памяти и возвращаем.
Понятно?
То есть lvalue — это те объекты, у которых есть реальное представление в памяти,
у которых есть адрес и тому подобное.
Естественно, у результата разоминования какого-то адреса есть адрес,
потому что мы этот адрес разоминовали.
Давайте примеры посмотрим.
Пробуем разобраться, какие выражения здесь являются lvalue и не являются lvalue.
Что у меня тут есть?
У меня тут есть переменная x,
у меня тут есть ссылка на x, которая называется rx,
есть константная ссылка на x, crx,
есть константная ссылка tmp, которая связана с некоторым временным значением 11.
Есть функция f, которая возвращает int,
есть функция g, которая возвращает lvalue int, то есть int по ссылке.
Ну и давайте по порядку.
Если я пишу просто x, что это lvalue или не lvalue?
Да, это lvalue, во-первых, возвращается int,
во-вторых, тут lvalue.
Если я пишу 5,
5 — это, понятное дело, int,
это lvalue или не lvalue?
Не lvalue, да, 5 — это просто временное значение,
у него нет никакого представления в памяти,
то есть, грубо говоря, пятерка будет просто захардкожена в ассемблерный код.
Это давайте писать не lvalue.
Адрес x.
Не lvalue.
Потому что адрес x нигде не хранится.
То есть, вопросы просили, где находится x,
вот вам на бумажке вернули, вы бумажку потом сожгли.
rx. lvalue. Почему это lvalue?
Потому что переменная всегда lvalue.
CRX.
Абсолютно то же самое. CRX — переменная,
переменная всегда lvalue. Tmp — тоже переменная, всегда lvalue.
Результат вызова f.
Не lvalue, потому что мы возвращаем
результат по значению, то есть, просто int.
Поэтому это не lvalue.
f плюс f, понятно, тоже не lvalue.
Во-первых, сами результаты f — это не lvalue,
тоже это просто некоторое временное значение.
Так, если я просто напишу g.
g — это функция.
Я ее не вызываю, я просто написал g.
Я же могу так сделать.
Что, это lvalue или не lvalue?
Давайте уверенно кто-нибудь скажите да, или кто-то скажет нет.
Нет, не lvalue, окей.
Давайте кто-нибудь скажет уверенно да.
G — это lvalue.
G — это некоторый идентификатор, это имя, то есть, имя функции.
Имя функции на самом деле можно считать тоже переменой,
потому что у функции тоже есть некоторое место в памяти.
Это когда вы обращаете к имени функции, вы на самом деле обращаетесь
в то место в памяти, где расположена эта функция.
Поэтому имена функции, ровно как и переменные, это тоже lvalue.
Вы же можете взять адрес функции?
Вы знаете такое понятие, как адрес функции?
У функции можно взять адрес?
Можно, поэтому это lvalue по критерию.
Адрес f, понятное дело, тоже не является lvalue, это обсудили до этого.
Результат вызова функции g.
lvalue, потому что он возвращает, грубо говоря,
int%
Когда мы возвращаем с имперсанду, мы говорим, что мы хотим вернуть lvalue,
то есть, какой-то объект. Поэтому результат вызова lvalue.
Plus-plus-x обсуждали это lvalue,
x-plus-plus — не lvalue.
Адрес x-plus-1 — это некоторый адрес,
и мы как раз по этому адресу и берем некоторый объект.
Соответственно, объект, который возвращается,
действительно имеет некоторые места в памяти, его можно как-то изменять и так далее.
Строковый литерал lvalue.
Что? Ой, да.
Здесь все правильно.
Строковый литерал тоже lvalue, а результат g-plus-g?
Не lvalue.
Несмотря на то, что у вас операнды lvalue,
результат операции будет не lvalue.
Ну и действительно все так.
На досуге можете посмотреть, если что-то осталось непонятно.
Хорошо.
Ну и теперь я все это время говорил lvalue и не lvalue.
На самом деле не lvalue — это rvalue.
Не lvalue.
Ну да, все так.
Что такое rvalue?
Можно считать неформально, что rvalue — это все то, что не относится к lvalue.
Rvalue — это временные объекты,
у которых нет определенного места в памяти.
Строго говоря, это неправда, потому что rvalue в свою очередь разделяется
на так называемый prvalue и xvalue.
Но давайте пока считать, что мы работаем только с prvalue,
то есть так называемые чистые временные значения,
про xvalue мы поговорим отдельно, когда до этого дойдет время.
Пока давайте считать, что rvalue — это временные значения,
у которых нет места в памяти.
Ну и соответственно, как тут написано,
что rvalue относится все, что не относится к lvalue,
а именно это всякие литералы, типа 5, 0, u и так далее.
Ну кроме, естественно, строковых литералов.
Результат функции операции,
которая возвращает просто значения без амперсандов,
то есть когда вы пишете this,
он на самом деле возвращает адрес объекта,
и this не хранится в памяти, он просто вычисляется
непосредственно в процессе или просто подставляется на этапе компиляции.
То есть это rvalue.
Ну вот всякие енамы, то есть результаты енамов,
то есть когда вы сохраняете константы в енамы и их используете,
это на самом деле не rvalue.
То есть, грубо говоря, когда вы пишете енам, не знаю там что, a, b,
то есть а и b не считаются переменными.
А и b это просто некоторые значения, которые подставляются на этапе компиляции.
Соответственно, являются rvalue.
Значение енамов это не lvalue, потому что не переменные.
Ну и параметры шаблона, не являющиеся типом, это тоже не lvalue,
потому что не переменные.
Ну что это означает? Это означает, что когда вы пишете
template, ну давайте там, когда вы писали array,
class t int n, там size t,
class array.
Вот когда вы внутри array обращаетесь к n,
вот это n это не переменное, соответственно, это не lvalue.
Это просто некоторые значения, которые подставляются на этапе компиляции.
То есть, можно считать, что компилятор вам на этапе компиляции вместо этого n
подставит конкретное значение, и это будет просто считаться
грубо говоря, литералом.
То есть вот адрес вот этого n взять нельзя,
ровно как взять адрес значения енама тоже нельзя.
Понятно?
Все, дальше можем идти.
Хорошо.
Ну вот, соответственно, коротко поговорили
про какое-то какое-ли значение, сказали, что такое lvalue,
что такое lvalue, ну и теперь самое время перейти
к видам ссылок.
Значит, поговорим про lvalue ссылки.
Ну на самом деле про них разговор короткий, вы их все прекрасно знаете.
Когда вы объявляете переменную с таким синтезисом,
то есть пишете тип, а потом мерсант,
вы объявляете ссылку.
Что такое ссылка? Ссылкой это на самом деле просто-напросто
некоторый псевдоним объектов памяти.
Почему ссылки, которые вам уже давно знакомы,
я называю lvalue ссылками?
Потому что lvalue ссылки имеют право связываться
только со значениями lvalue выражений.
Ну и действительно, чтобы создать псевдоним
какого-то объекта в памяти, вам нужно этот объект в памяти получить.
Понятно? А в каком случае мы получаем некоторый объект в памяти?
Только в результате вычислений некоторого lvalue выражения.
Согласны?
То есть x, x это переменная, переменная всегда lvalue,
поэтому я могу создать на нее ссылку.
То есть rx, то есть у меня есть где-то в памяти домик,
который называется x, в нем находится 5.
6 равно x по ссылке.
Это означает, что я у этого адреса
звожу некоторое альтернативное имя.
Вот.
Есть имя переменной первомайской 32.
А есть двойка. Согласны, что это одинаковые названия одного и того же.
У меня есть один адрес,
и я могу его назвать несколькими разными способами.
В данном случае могу сказать x, могу сказать rx.
Вот.
Соответственно, могу создавать константные ссылки.
Понятно дело, это тоже самая ссылка.
То есть я тоже ссылаюсь на ту же самую область памяти, что и x,
но при этом по этой ссылке я не могу этот объект изменить.
Я могу связывать ссылку с результатом функции,
то есть с результатом выражения, который выращает lvalue.
В данном случае f возвращает некоторый конкретный объект,
и я на этот объект создаю ссылку.
Все нормально.
При этом я не могу создать ссылку на lvalue.
То есть я не могу создавать ссылке на rvalue, в частности на 0.
Потому что 0 нет никакого представления в памяти,
поэтому ссылаться мне не на что.
Поэтому lvalue ссылки тут создать нельзя.
Аналогичный результат, например, x++ я не смог создать ссылку тоже.
Потому что у этого объекта нет никакого представления в памяти,
ссылаться мне не на что.
Для LVLU ссылок это временные объекты.
Единственное исключение для временных объектов это константные левые ссылки.
Константные левые ссылки я могу связывать с временными объектами.
Как это работает? Это некоторая магия, которая продлевает жизнь временного объекта.
Грубо говоря, для этого объекта создается некоторое временное убежище,
в котором сохраняется 11, и на этот временный шалаш и ссылается эта ссылка.
Когда вы ставите константную ссылку на временный объект,
для этого временного объекта создается некоторое временное хранилище, на которое мы ссылаемся.
Как только эта константная ссылка на это временное хранилище умирает,
то и этот шалаш тоже умирает.
Константные левые ссылки имеют право продлевать жизнь временных объектов.
Я думаю, со всем этим мы знакомы, просто как бы повторили.
С этим все понятно.
А вот теперь поговорим про R-value ссылки.
Соответственно, если у нас есть категория значений L-value, есть категория значений R-value,
и есть L-value ссылки, то, наверное, должны быть R-value ссылки.
И это действительно так. В языке C++, начиная с 11 стандарта, появились R-value ссылки.
R-value ссылки обладают той же самой семантикой, что и обычные ссылки,
поэтому, в отличие от L-value ссылок, они имеют право связываться только с R-value объектами.
То есть L-value ссылки связываются только с L-value объектами,
R-value ссылки имеют право связываться только с результатом R-value выражений.
Что это означает?
Это означает то, что вы, например, можете создать R-value ссылку на временное значение 11.
И работать это будет ровно так, как я рассказал про константные ссылки.
И когда это сделано, для этого значения 11 создаться некоторое временное убежище,
создается некоторое время место в памяти, на которое будет ссылаться RRy.
Есть некоторое временное значение 11, и когда вы создаете на него правую ссылку,
для него создается некоторое временное хранилище, на которое это ссылкой ссылается.
И это хранилище живет до тех пор, пока на него ссылается эта ссылка.
И здесь пример, что по этой ссылке вы можете это временное значение как-то изменять.
В этой области памяти вы сохранили 11, потом можете спокойно изменить значение 11 на 12.
Далее R-value ссылку можно связать с результатом R-value выражения.
У вас есть функция f, которая возвращает R-value int, и вы на него можете тоже сослаться.
Ссылаться можно на результат x++, но при этом нельзя сослаться на невременные значения.
То есть нельзя сослаться на невременный объект с помощью временной ссылки.
Вот так сослаться нельзя, и вот так сослаться тоже нельзя.
И здесь вопрос. Рассмотрим последний пример. Я создаю R-value ссылку ref на RRY.
RRY представляет из себя правую ссылку. Как вы думаете, последняя строка сработает или нет?
Кто считает, что нет?
Я вас запомнил. А кто считает, что да?
А почему нет?
А кто считал, что да? Ещё раз.
Почему да?
Супер. Что такое RRY?
RRY – это переменная. Возвращаемся в самое начало. Есть одно незыблемое правило.
Переменная – это всегда L-value. Не важно, какого типа это переменная.
Переменная – это всегда априори L-value.
Ну а раз RRY – это переменная, можно в неё создать левую ссылку?
Ну да, можно.
То есть как это работает? Вы в этой строке, в самой первой строке, создали правую ссылку на 11.
Что это означает? Это означает, что сначала компилятор выделяет некоторую память на стеке,
в которую будет сохранено вот это временное значение. В частности, 11.
Всё. То есть у этого объекта, точнее не у этого объекта, а вот RRY, он ссылается на некоторую область памяти.
Любая переменная всегда ссылается на некоторую область памяти.
И когда вы создаёте ссылку на RRY, на самом деле RRF, вот этому RRF, уже понятно, куда ссылаться.
То есть RRY указывает на эту область памяти. Ну значит RRF тоже будет указывать вот на эту область памяти. Всё нормально.
Понятно?
То есть правые ссылки, они продлевают время жизни объектов, давая им некоторое убежище,
давая им некоторое специальное выделенное место в памяти на стеке.
Всё понятно?
Хорошо.
Да, соответственно, ответ здесь.
Ну и смотрите, может возникнуть такой вопрос.
Если мы посмотрим на предыдущие примеры, то что мы по сути делали?
Мы писали int &&rx, писали 11. int &&rx равно f.
И что мы говорили? Мы говорили, что мы временные значения присваиваем R-value ссылкам,
и эти R-value ссылки создают некоторую область памяти, в которой эти значения хранятся.
И тут может возникнуть естественный вопрос. А чем это отличается от объявлений обычно переменной?
Согласитесь, что когда вы просто объявляете переменную int x,
по большому счёту происходит то же самое.
Заводится некоторая область памяти, которая называется x, и в нём сохраняется 11.
И вы тоже самое 11 можете в этой области памяти изменять и так далее.
Возникает естественный вопрос, для чего тогда вообще нужны R-value ссылки?
Ответ такой. В этом контексте, во всех примерах, R-value ссылки не особо не нужны.
И они так не используются.
А используются они для решения другой проблемы.
Давайте к ней перейдём.
На самом деле оказывается, что по типу ссылки L-value или R-value можно делать перегрузку.
Понятно эта фраза?
По типу ссылки можно делать перегрузку.
То есть в зависимости от того, что вы передали, у вас может быть вызана одна функция или другая функция.
Давайте какой-нибудь жизненный пример.
Практические жизни, практические стандартные библиотеки выглядят так.
Представьте себе, что мы хотим написать функцию addressOf.
Хотим написать функцию addressOf, которая возвращает адрес некоторого объекта.
Сразу скажу, что здесь неправильная реализация.
В стандартной библиотеке есть специальная функция std addressOf,
которая возвращает адрес объекта x.
Вы можете спросить, зачем нам нужна функция addressOf, если можно просто взять амперсанд от x.
Ответ такой.
Амперсанд может быть перегружен.
Амперсанд можно перегружать.
Если вы для своего класса перегрузили операцию амперсанды,
то уже амперсанд для вашего объекта не будет возвращать вам адрес.
Единственный способ получить адрес, это вызвать функцию addressOf.
Он выполняет некоторую магию на низком уровне, которая возвращает вам адрес.
Мы сейчас не будем в это углубляться.
Давайте просто рассмотрим примитивную реализацию адресов.
Вы хотите просто завести функцию addressOf,
которая принимает некоторый объект и возвращает его адрес.
Мы принимаем константный объект и возвращаем указатель на константу.
Вот таким образом.
Я утверждаю, что у этой реализации есть большая проблема.
Какая? Давайте по порядку.
У меня есть переменная x, и у меня есть динамический массив array.
Что я делаю?
Когда я прошу addressOf x, все работает нормально.
То есть я передаю x, и у этого x возвращается адрес этого x.
Когда я делаю plus-plus-x, то же самое.
Plus-plus-x возвращает мне lvalue, то есть ссылку на x, то есть сам объект x.
И я опять же у этого x беру адрес.
То же все нормально.
Если я беру адрес от array 5, то тоже все нормально.
Всем очевидно, что array от 5 возвращает вам lvalue.
Потому что array от 5 дословно переводится как array plus 5.
То есть разыменование array plus 5.
То есть мы взяли объект, который расположен по адресу array plus 5.
У этого объекта, естественно, есть адрес, и это array plus 5.
А вот теперь вопрос в последней строке.
Как вы думаете, что случится в последней строке?
Корректно она отработает или что-то пойдет не так?
А что пойдет не так?
Будет ли ошибка компиляции здесь?
Будет ли тут ошибка компиляции?
На каком этапе возникнут проблемы?
Сначала вы написали вот такой код.
И думаете, ну сейчас отправлю в тестирующую систему.
Нажимаете собрать программу.
Вот у вас происходит компиляция.
В момент компиляции все будет окей.
Теперь вы решили запускать вашу программу.
Что пойдет не так? Или все будет нормально?
В данном конкретном случае все будет нормально на самом деле.
Ну как это работает? Давайте по порядку.
Вы взяли адресов 10.
Это 10 сохранилось в константную ссылку value.
Константные ссылки могут связываться со временными объектами.
Это мы говорили.
Здесь внутри этой функции создается некоторый шалаш,
в котором сохранится значение 10.
Дальше. Вы берете адрес этого шалаша.
Не знаю, там улица Пушкина, дом Кулатушкина.
Вы берете этот адрес.
И этот адрес вам возвращается.
И вы его здесь, представь себе, куда-то сохранили.
Что вы можете делать с этим адресом?
Что из себя представляет вот этот адрес, который вам вернулся?
Что вы можете сделать с этим адресом?
Что из себя представляет вот этот адрес, который вам вернулся?
Можно ли его разыменовать и получить 10?
Был у вас вообще разговор когда-нибудь про провисшие ссылки,
про провисшие указатели, вот это вот все?
Кто-то говорит было, кто-то говорит не было.
Ну окей, в общем, это классическая проблема провисшего указателя
или провисшей ссылки.
Давайте не будем подробно на этом остановиться.
В общем, главная мораль всего этого,
нельзя возвращать ссылки на локальные объекты.
И нельзя возвращать адрес локальных объектов. Почему?
Потому что когда вы выходите из этой функции,
когда вычисление этой функции завершается,
что происходит?
Все переменные внутри этой функции уничтожаются.
Когда вы выходите из этой функции,
то эти объекты, в частности объект Value, они будут уничтожены.
Стэк просто затрет это все.
Указатель стэка сместится ниже,
и этими объектами уже нельзя пользоваться,
потому что они, грубо говоря, не принадлежат вашей программе.
И поэтому, когда вы попытаетесь воспользоваться вот здесь
результатом выражения адресов,
адрес, куда будет вести результат этого выражения,
он будет уже вести в некоторую область памяти,
и в лучшем случае вы получите
какой-нибудь StackBufferOverflow ошибку,
которая говорит о том, что вы лезете в память,
которая вам в данном момент не принадлежит.
А в худшем случае получите undefinedBehaviour.
Возникла проблема.
Возникла проблема с тем, что мы предполагаем,
что адресов off будет работать всегда корректно,
и у всех этих адресов вроде как завершается корректно,
но при этом этим результатом пользоваться нельзя.
Наверное, хотелось бы нам запретить использовать адрес off
от временных объектов. Согласитесь, это логично.
Согласитесь, нелогично брать адрес у временных объектов.
И нам хочется вот такое запретить.
Как такое запретить?
На самом деле очень просто.
Все поняли, в чем проблема с адресом off.
В той реализации адресов, которые мы написали,
мы можем брать адреса временных объектов.
Точнее, мы берем не адрес временного объекта здесь,
а мы берем адрес локального объекта,
который по выходу из функции будет уничтожен.
То есть никакой пользы адресов здесь нам не принесет.
Еще одна проблема более сложная.
Смотрите, у меня есть класс A.
И у него в качестве поля выступает
константная ссылка на int.
Просто некоторый класс A, который сохраняет ссылку
на какую-то внешнюю переменную.
Естественно, мне как любой другой ссылочной боли
нужно инициализировать в конструкторе, а именно
в списке инициализации. Что я делаю?
Я в конструкторе принимаю константную ссылку на объект,
на который мне нужно сохранить ссылку, и в списке инициализации
Интерфейс этого класса такой. Я могу в любой момент
получить ссылку на объект, и в любой момент могу получить указатель
на объект. Вот такой простой класс.
То есть я сохраняю ссылку на объект, и в любой момент
могу с помощью getref получить на него ссылку,
и getptr получить на него указатель.
Ну и как это работает? Если я создаю
этот объект A с помощью XA, то все нормально.
У меня внутри вот этого класса A сохраняется
ссылка на X. Все отлично.
Если я передаю туда array от 5, то тоже все нормально.
У меня туда сохраняется ссылка на 5-й элемент array,
5-й элемент массива. А что произойдет,
если я передам туда 0?
Что произойдет, если я вызову
если я вызову c.getref?
Что пойдет не так?
Ну опять, практически то же самое.
Смотрите, что у меня тут происходит по порядку.
Value
создает некоторое временное убежище для 0.
Потому что константные ссылки могут
связываться со временными объектами.
Соответственно, будет константная ссылка связываться со временным объектом,
предоставляя ему некоторую временную ячейку памяти.
Дальше у меня
у меня выполняется cref в скобочках value.
То есть я создаю ссылку cref на value.
В частности, я пишу cref.
И этот cref указывает на то же место, что и 0.
А что происходит дальше на третьем шаге?
Ну что происходит, когда у меня завершается конструктор?
У меня уничтожается value, согласны?
Value – это локальная переменная конструктора.
После того, как я вышел из конструктора, у меня уничтожается value.
А так как внутри value хранилась вот эта переменная,
вот этот объект 0, то
все это целиком тоже уничтожается.
И куда мне теперь ссылается cref?
Cref теперь у меня ссылается на удаленную область памяти.
То есть cref теперь у меня ссылается на область памяти,
которая моей программе сейчас не принадлежит.
Окей?
Поэтому в лучшем случае вы получите, вот здесь при попытке вызова getref,
вы получите какую-нибудь ошибку типа stack-buffer overflow,
а в худшем случае компилятор это просто пропустит,
и вы будете постоянно работать с областью памяти, которая вам не принадлежит.
А это undefined behavior, то есть в вашей программе может произойти что угодно.
То есть непредсказуемое поведение,
которое очень сложно отлавливать.
Понятна проблема?
Короче говоря, главная проблема,
давайте с этим слайдером разберемся.
Здесь главная проблема состоит в том,
что
здесь наш конструктор,
ровно как и адресов,
не умеет отличать временные объекты от невременных объектов.
То есть когда мы передаём невременные объекты,
у нас всё ок.
временный объект, у нас резко начинает все ломаться. И в этом проблема. И вот здесь нам как раз
таки поможет разделение, то есть нам поможет, собственно, короче, нам надо как-то научиться,
научить наши функции, ну в частности конструктор того класса A и функцию адресов, нужно как-то
их научить отличать l-value объекта от r-value объекта. А какой механизм в языке C++, который мы
недавно изучили, какой механизм позволяет нам отличать l-value объекты от r-value объектов?
r-value ссылки. То есть у нас есть l-value ссылки, есть r-value ссылки. И вот l-value и r-value ссылки,
они умеют отличать временные объекты от невременных объектов. Окей? И вот как раз таки решение
состоит в этом. Давайте сделаем следующую вещь. Давайте помимо обычной функции адресов,
которые мы до этого написали, напишем перегрузку. Напишем перегрузку, которая будет принимать объекты
по r-value ссылке. То есть напишем const t и t, ну и объявим ее удаленной. Для чего? Ну потому что
мы понимаем, что не имеет смысла вызывать адресов для временных объектов. Окей? И теперь внезапно
все будет работать так, как мы хотим. А как мы хотим? Мы хотим, чтобы когда мы просили адресов от
x, нам возвращался адрес x. Мы хотим, чтобы когда мы просили адресов от r и от 5, нам возвращался
адрес пятого элемента массива. И мы хотим, чтобы когда мы вызываем адресов временного объекта,
мы хотим, чтобы в этот момент у нас ошибка возникала на этапе компиляции, а не потенциальная
ошибка на этапе выполнения. Ошибка на этапе компиляции — это благо, понятно? Потому что
ошибка на этапе компиляции вам не дает написать некорректный код. И в данном случае ровно этого мы
и добились. Когда мы вызываем адресов от 10, что происходит? У нас происходит выбор перегрузки.
То есть компилятор видит, что есть функция адресов, которая может принимать константную левую ссылку. И
в принципе туда десятку можно засунуть. Но при этом в тот же момент у меня существует функция,
которая принимает правую ссылку. И правая ссылка для временных объектов, естественно, подходит лучше,
чем левая. Понятно? И поэтому именно вот эта функция в последней строке будет выигрывать перегрузку.
Всё понятно? То есть мы перегрузили нашу функцию адресов по типу ссылки. То есть теперь все lvalue
объекты будут идти в первую версию адресов, все временные объекты будут идти во вторую версию
адресов. Круто? Ну и то же самое для класса A. То есть мы теперь хотим, чтобы класс A работал,
в смысле конструктор для класса A работал только для lvalue объектов, то есть только для lvalue int'ов.
А для не lvalue int'ов мы хотим, чтобы он не работал, чтобы возникал ошибка комбиляции. Добиваемся мы
этого ровно тем же самым. Значит, невременные объекты будут попадать в первую версию функции или
конструктора, а временные объекты будут попадать во вторую версию конструктора. Но сейчас, когда вы
будете вызывать AC от нуля, что будет происходить? Комбилятор будет выбирать между двумя
перегрузками, то есть он будет думать, куда мне послать вот этот ноль? Функцию const int'& или
функцию const int'&. Понятное дело, что и та, и та подходят, но лучше подходит конструктор,
который принимает двойной % потому что ноль это rvalue. rvalue для двойной ссылки подходит лучше. Понятно?
То есть тут есть, грубо говоря, точное соответствие, если хотите. Все понятно? Отлично. Вот, то есть мы
разобрались с категориями значений lvalue, rvalue, разобрались тем, что существуют lvalue ссылки,
которые связываются только с lvalue, разобрались, что есть rvalue ссылки, которые связываются только
с rvalue и наконец-то поняли, для чего они нужны. Для чего нужны lvalue, для чего нужно отличие
lvalue ссылок от rvalue ссылок. По ним можно делать перегрузку. В зависимости от этого у нас будет
вызываться та или иная версия функции, в зависимости от того, что вы передали, временный объект или не
временный объект. Вот, да, соответственно по виду ссылки можно перегружать функции,
результат lvalue выражения будет вызывать версию слева ссылки, а результат rvalue выражения будет вызывать
функцию с правой. Ну и давайте короткие упражнения, короткие примеры, давайте для каждой строки
пробуем указать, какая версия функции будет вызываться, первая или вторая. Давайте f от x. Ну первое,
понятное дело, x это lvalue, поэтому будет вызываться функция f, которая принимает обычную левую ссылку. f от 0.
Вторая, да, потому что 0 вообще никак не может быть связан с lvalue ссылкой, ну с обычной,
без константы, поэтому, естественно, 0 идет во вторую версию. Так, f от g. Вторая, да, результат
выполнения g это rvalue, поэтому результат выполнения g пойдет во вторую версию функции f. Так, ну и
последние две строки? Первая и вторая соответственно, да, отлично, все понятно, окей, ну да.
Так, ну смотрите, мы сделали разницу, я рассказал, в чем разница между lvalue и rvalue, мы поняли,
что существуют левые ссылки и правые ссылки, мы поняли, что по виду ссылки можно перегружать,
и, на самом деле, вот особо, не знаю, под левым слушателем может показаться, что, ну окей, вот то,
что мы сделали, ну как бы, ну это какое-то слабое применение, да, не особо убеждает, что это на
самом деле действительно что-то стоящее, ну вряд ли там кто-то будет активно использовать функцию
адресов, вряд ли кто-то активно будет, не знаю, сохранить какое-то ссылочное поле в класс, и так далее.
Вот сейчас мы перейдем к настоящему применению lvalue и rvalue ссылок, для чего они на самом деле нужны,
для чего они вам нужны конкретно, вот. И это, на самом деле, конструкторы перемещения и
перемещающие присваивания. То, про что мы говорили на лекции про конструкторы, но говорили, что поговорим
когда-нибудь, и вот сейчас это когда-нибудь. Значит, смотрите, давайте просто вспомним, что у нас есть,
что мы писали класс stack, ну для класса stack мы говорили, что существует правило трех, которое нам
говорит, что если мы управляем как-то ресурсами, ну или там в принципе нам потребовалось написать
деструктор или копирование, то нам необходимо написать сразу все три метода. То есть это деструктор,
конструктор копирования и копирующее присваивание. Но, соответственно, здесь напоминание, как мы это все
реализовывали. То есть принимаем другой stack, значит копируем, создаваем новый буфер, копируем его сайсы,
копируем содержимое одного буфера в другой буфер. Значит, в присваивании все то же самое, но только
перед этим проверяем на самом присваивании и удаляем старый буфер. То есть тут это все рассматриваем,
никаких проблем нет. Вот я утверждаю, что вот этих копирующих версий нам недостаточно, чтобы написать
эффективные программы. Почему? Смотрите, допустим, я создаю stack, у меня есть некоторый stack, я его как-то
заполняю. Ну вот здесь вот, не знаю, stack.push, единицы, ну и так далее. В общем, как-то работаю со stack.
Ну и теперь в какой-то момент у меня возникла потребность создать копию stack. Вот здесь я
создаю копию stack, то есть создаю lcopy и говорю, что этот lcopy должен являться копией stack. За сколько
это все работает? За линию? Можем ли как-то сделать это быстрее? Ну вряд ли. То есть если вам нужно
скопировать один stack в другой, то, наверное, вам все-таки нужно скопировать все содержимое. А копировать
все содержимое — это все-таки линейное время. Поэтому тут все нормально. Мы соглашаемся на то, что мы
копируем все-таки за линейное время. Потому что иного способа скопировать один объект в другой у нас нет.
Ну скопировать один массив в другой у нас нет. Согласны? Хорошо. А теперь представьте другой пример
использования. Что если я говорю, что я хочу скопировать stack из некоторого временного объекта?
Ну, стараюсь скажу, что здесь на самом деле все будет окей, здесь все будет работать достаточно быстро по причинам,
которые мы будем обсуждать, видимо, в следующий раз. Но в старых плюсах вот это все работало долго. И работало
долго почему? Смотрите, что здесь происходит в этой строке. Я создаю некоторый временный stack в правой
части. В правой части я создаю stack из ста элементов. Согласны? Здесь stack размера 100. Это какой-то
временный stack. И теперь я создаю rcopy с помощью копирования того временного stack. То есть что я
делаю? Тоже создаю тут свой буфер. И по элементу накопирую временный stack сюда. И что происходит потом?
Я уничтожаю временный stack. Не кажется ли вам, что тут есть немного совсем неэффективности?
Вряд ли вы когда списываете... Вряд ли когда кто-то списывает задание, он пишет сначала полностью
задание, а потом у себя же берет и вот списывает в другую тетрадь. Вряд ли происходит так на
практике. Чтобы что-то списать, чтобы скопировать что-то временное, то есть если у вас есть что-то
ненужное, то вряд ли вам нужно полностью это все копировать. Согласны? Здесь происходит нечто странное.
Вы хотите создать stack и при этом создаете временный stack. Потом из этого временного stack копируете,
а потом вот этот вот временный stack, который вы создали только для того, чтобы оттуда что-то
скопировать, его уничтожаете. Какой-то бред. То же самое касается присваивания. То есть если вы
копируете один stack в другой, то быстрее чем за линию априори это сделать нельзя.
Ну по понятным причинам. То есть если у вас есть объект, который нельзя портить и вы хотите его
скопировать, то нужно скопировать. А представьте себе, что вы хотите присвоить временный stack
себе. Что здесь происходит в последней строке? Снова то же самое. Вы создаете временный stack,
у вас есть какой-то другой stack rcopy. Что происходит? Вы уничтожаете свой stack,
потом берете и копируете временный stack к себе и уничтожаете временный stack.
Ну вопрос, а нафига мы создавали временный stack? Неужели нельзя просто взять и вот все
то содержимое временного stack забрать себе? Согласитесь, это было бы эффективней.
Проблема понятна? Понятно почему вот эти строки на самом деле работают, грубо говоря,
за 2n, а не за один проход. Потому что вот в этих помеченных строках мы сначала создаем временный
stack, потом из временного stack копируем. То есть сначала создаем stack, а потом из него же копируем.
Это странно. Но это именно то, что происходит у нас в программах в данный момент. Вот вы писали
стрингу, вы писали свой класс строки, и вот ровно это у вас и происходит, когда вы пишете примерно
вот такой код. Ерунда. Соответственно, здесь мы приходим к следующему выводу, что вот эти
конструкторы копирования, которые мы написали и копирующие присваивания, они работают неэффективно
в случае, если мы присваиваем или копируем из временных объектов. Согласны? Поэтому возникает
естественная идея. А давайте просто возьмем и напишем специальные версии конструктора и
присваивания, которые принимают временный stack. Ну как мы это делаем? Мы просто говорим, что в качестве
аргумента конструктора мы будем принимать stack по правой ссылке, и в качестве аргумента присваивания
тоже будем принимать stack по правой ссылке. Соответственно, в этом случае мы должны делать что-то
иное. Теперь вопрос в зал. А что мы должны сделать со временным stack, чтобы это было эффективно?
А что такое переместить?
Нет, здесь у нас нет возможности обойтись без временного. Если мы приняли, смотрите, у нас есть
аргумент, и мы знаем, что в нем априори лежит временный объект. То есть мы не можем обойтись
без создания временного объекта. То есть здесь мы предполагаем, что в этом конструкторе и перемещении
нам дали временный объект. Что значит временный объект? Это значит, что этот объект никому не будет
нужен больше. Что в этом случае мы должны сделать? Сделать его нужным. Давайте так. Экологичное
потребление или recycling и так далее. Если у вас есть что-то, что уже не нужно, что уже точно никому не
понадобится. Естественно, вы хотите его как-то переиспользовать, использовать повторно. Говорят,
что это скоро уже всем пригодится. Понятно, да? Если у вас есть что-то не нужное, никому оно не
нужно. Вот есть что-то, оно не вам, не вам, не вам, не вам не нужно. И я хочу это все скопировать себе.
Что мне нужно сделать, если оно никому не нужно? Просто забрать себе, естественно. Сцарапнуть,
то есть как угодно называйте. Смотрите, содержимое вот этого стека, оно никому не будет нужно. Об этом
говорит R-value ссылка. Если я попал в этот конструктор, то это означает, что я связался
с временным объектом. Что такое временный объект? Временный объект, который создался здесь и сейчас,
и больше никому не будет нужен. Ровно как и здесь. Смотрите, я здесь создал стек от 100 и здесь стек
от 100. И помимо вот этой строки, помимо вот этого выражения, он нигде больше использоваться не
будет. Поэтому я могу спокойно взять и забрать его содержимое. Понятно? А что значит забрать
содержимое стека? Смотрите, у меня есть other, у меня есть мой стек. Что значит забрать
содержимое стека? Давайте так. Что хранит стек? Давайте по порядку. Стек хранит внутри себя
условно указатель на буфер и хранит size. То есть то есть. У меня есть временный стек other,
в котором хранится указатель на буфер и в котором хранится size, допустим, 100. И вот у меня есть
мой стек, который пока ничем не заполнен. Научите меня забирать содержимое другого объекта. Что
мне нужно сделать? Отлично. Смотрите, если вот этот стек other никому не будет нужен, то значит
вот этот буфер тоже не будет никому нужен. Давайте я вопрос заберу себе. Возьму и буду указывать,
вот на этот буфер. То есть я не буду создавать свой, а просто заберу чужой, окей? Так, а с size
что мне сделать? Ну а с size я просто копирую. То есть это просто 4 байта. Окей? Все. Ну почти все.
Еще нужно вот этот вот указатель сказать, что нужно все-таки поуважительный савер, нужно ему
сказать, что мы все-таки у него что-то забрали и сказать, что у него no ptr. То есть не просто без
предупреждений. Нужно еще other предупредить, что у тебя мы что-то забрали, окей? Об этом мы поговорим сейчас.
Вот, то есть ровно то, про что я сказал, написано здесь. Как должен выглядеть конструктор, такой
конструктор называется конструктором перемещения. Почему перемещение? Потому что мы все содержимое
другого стека или другого объекта перемещаем себе. Здесь происходит ровно то, что я написал. Мы просто
берем и забираем буфер другого объекта. То есть мы просто забираем, точнее мы указываем на буфер
другого объекта. Вот это был чужой и теперь мы ссылаемся на чужой. Вот. И копируем size. Понятно? За
сколько это все работает теперь? За единицу. То есть теперь мы не копируем содержимое временного
объекта себе, а мы просто забираем все то, что было у него. Это ему больше не пригодится. Все, теперь
это наше. Ну и дальше мы зануляем буфер и зануляем size. Теперь вопрос. Смотрите, помните, когда мы
говорили про деструкторы, мы говорили, что когда мы деструктурируем объект, нам не обязательно его
занулять. Ну потому что он больше никому не пригодится. Да? Смотрите, казалось бы other тоже больше
никому не пригодится. Зачем тогда ему занулять буфер, занулять size? Вообще нужно это делать или
нет? Еще раз. Да, смотрите, действительно. Вот это делать, вот здесь это делать необходимо. То есть все
таки, если вы что-то забрали у другого объекта, то вы обязаны этот другой объект привести в
какое-то нормальное состояние. Ну почему? Потому что когда у вас выполнится вот эта строка, что вас
произойдет? Вот допустим, вы эти строки не написали. Что у вас тогда произойдет? Давайте нарисуем.
У вас есть other. Он указывает на какой-то буфер. У вас есть ваш stack, rcopy называется,
который ссылается на ту же самый буфер. Ну и смотрите, если вы у other, то есть если вы у other
не изменили буфер, то есть если вы не сделали его указывающим в nullptr, то у вас произойдет неприятность.
То есть вы как бы тот старый буфер забрали, но при уничтожении вот этого временного объекта,
когда other будет уничтожаться, это же временный объект, он вот создался и потом после этого
выражения будет уничтожен. Вот когда у вас other будет уничтожаться, для него будет вызван
деструктор. И вот этот буфер будет просто-напросто удален. Понятно? И вот чтобы этого не произошло,
мы дополнительно делаем следующую вещь. Мы говорим, что other теперь указывает в null.
И теперь, когда будет удаляться other, other будет удалять нулевой указатель. Удаление нулевого
указателя ни к чему плохого не приводит. Поэтому все необходимые действия здесь описаны.
Общая философия. Чтобы корректно отработал деструктор, у вас объект должен находиться
в так называемом согласованном состоянии, ну в хорошем состоянии. Если у вас stack другой
указывает на нулевой указатель, а его size равен 10, то это не согласованное состояние явно.
Поэтому так. Ну это общая рекомендация. Ну и плюс на самом деле... Ладно, не буду об этом говорить.
В общем, достаточно вам этого объяснения. Все, хорошо. То есть после того, как вы что-то забрали у
другого объекта, вы этот другой объект должны оставить в хорошем состоянии. Это общая мораль.
Ну и операция пресваивания выглядит точно таким же образом. Вы удаляете старый буфер и просто-напросто
не копируете, а забираете буфер у временного объекта. Все. Ну а потом другой объект оставляете в
правильном состоянии. С нулевым размером и с нулевым буфером. Все понятно, что произошло.
И этот конструктор перемещения и перемещающий пресваивания теперь работают за вот единицы. То
есть теперь, когда вы присваиваете или перемещаете из временного объекта, у вас теперь все вот эти
конструкторы работают за единицу, а не за линию, как раньше. Ровно здесь это написано. Все ясно.
Ну и соответственно, вот эти методы, которые мы написали, они называются соответственно
перемещающим конструктором и перемещающим пресваиванием. То есть это конструктор перемещения,
конструктор перемещения, а это перемещающее пресваивание. Это тоже особенные конструкторы,
то есть мы говорили, помните, про конструктор копирования, про конструктор по умолчанию,
у них там были специальные правила. Вот у этих конструкторов и у этой операции тоже есть
особенное поведение. Правило такое, если вы в своей программе, точнее в своем классе,
не написали копирование и деструктора, то конструктор перемещения и перемещающего
пресваивания создается за вас. То есть если вы не написали конструктора копирования,
а копирующего пресваивания и деструктора, то вот эти вот две функции компилятор напишет за вас.
Что компилятор будет в них делать? А компилятор просто-напросто возьмет и переместит каждое поле
по отдельности. Ну давайте так, будем говорить, просто-напросто возьмет и, неправильно, хорошо,
неправильно говорить, скопирует, он просто возьмет и переместит все остальное. Давайте пример.
Пример такой. Вот у вас есть класс A, там как-то реализован, и у вас есть класс B, у которого в
качестве поля выступает int x и A. И, допустим, вы в этом классе B не написали ни деструктора,
ни копирования, ничего. Тогда, когда у вас будет объект B перемещаться, то есть компилятор за
вас создаст конструктор перемещения, который будет работать следующим образом. Здесь пока не понятно,
что написано. Короче, он просто-напросто возьмет и скопирует other x, то есть все поля примитивных
типов он скопирует, а поля небазовых типов он просто-напросто переместит. Давайте я пока напишу
вот так. other.a. Стрелочка вот это означает, что в содержимое поля A я перемещу в A. То есть тут,
грубо говоря, будет вызван конструктор перемещения для A. Понятно объяснил? То есть, короче говоря,
для каждого поля будет вызвано конструктор перемещения. Ну, если это примитивные типы,
то для перемитивных типов, естественно, перемещение нет. Не понятно, как байты переместить.
Для примитивного типа перемещение работает просто как копирование, вот. А если у вас в качестве поля
выступает какой-то класс, то для него будет вызван конструктор перемещения. Это так работает
дефолдное перемещение, которое будет за вас написано компилятором. coronaPy ti.f. sometimes.
Для перемещающего присваивания то же самое.
Если вы не хотите писать самостоятельно вот эти вот самые конструкторы перемещения или оператор или перемещающий присваивания,
то вы можете написать равно default.
Ну, собственно, как и раньше.
И еще одно важное правило.
Когда вы будете реализовывать свой перемещающий конструктор или свое перемещающее присваивание,
не забудьте здесь дополнительно указать такое специальное слово noexcept.
Для чего оно нужно, мы поговорим позже.
В общем, поверьте, оно тут нужно.
Глобально ничего плохого не произойдет, если вы его не напишете, если вы его забудете.
Глобально все будет нормально.
Ошибками пляться не будет, все будет работать и так далее.
Но о том, какие проблемы могут возникнуть, мы поговорим позже.
Все, договорились?
Отлично.
Ну и теперь самое время расширить правила трех до правила пяти.
Помните, мы говорили, когда обсуждали конструкторы,
у нас было правило пяти?
Что если вам нужно реализовать
конструктор копирования, копирующего присваивания или деструктор,
хотя бы одно из этого,
то на самом деле нужно реализовывать все три.
Теперь мы изучили перемещающий конструктор и перемещающее присваивание.
И теперь мы это правило расширяем до правила пяти.
Если вам нужно реализовать конструктор копирования
или конструктор перемещения
или копирующий присваивание, или перемещающий присваивания,
то есть если вам нужно реализовать
какое-нибудь копирование,
какое-нибудь перемещение или деструктор, то нужно реализовывать все вот эти вот 5 штук,
все вот эти вот 5 сущностей. Ну и снова понятно, почему. Для чего нам нужно было правило трех,
чтобы мы корректно работали с памятью. Здесь то же самое, если у вас есть какая-то работа с
памятью, то перемещение тоже должно работать как-то, мы должны забрать другой указатель и так далее.
Понятно? Вот, поэтому те, кто писали string, можете потренироваться и для своей строки,
то есть в задании для строки вам нужно было написать только копирование и деструктор. Соответственно,
можете потренироваться, написать для своей строки перемещение и операцию перемещения.
Вот, ну чтобы соблюсти правила пяти, чтобы все корректно работало.
Так, ну и еще один пункт, который касается перемещения, это функция std move. Ну давайте сразу
начнем с проблемы. Функция swap внезапно. Казалось бы, что есть более священная, чем swap. Вроде как
все писали swap, для всех он работал. Кто писал swap? Поднимите руки. Все писали swap. У всех он работал,
все хорошо. Так вот, я утверждаю, что вы swap писали неправильно. Прям совсем неправильно.
Давайте пока посмотрим на то, как вы скорее всего реализовывали swap. Ну вы принимали один объект
по ссылке, второй объект по ссылке, ну понятно почему по ссылке, потому что должны поменять свои
значения. Ну и дальше с помощью третьей переменной записывали x во временную переменную, записывали
y в x, а потом в y сохраняли вот это временное значение. И вот, ну короче, в чем тут проблема,
без стакана не разобраться. Благо, у меня стаканы есть. Так, мне нужен доброволец.
Кто-нибудь. Отлично. Пить не надо.
Достаточно. Так, это x, это y. Сделайте swap.
Так. Нет. Это x, это y. В y все нормально. Вот, отлично. Браво, все.
Это то, как должен работать нормальный swap. Я утверждаю, что вот этот swap работает вообще не так. Вот вообще.
Как работает вот этот swap? Сейчас, в общем, я сам это сделаю. Почти смертельно. Что происходит
в первой строке? tmp равно x. Что здесь происходит? Создается переменная tmp. И x сюда перемещается,
то есть переливается x, правда? Нет, x сюда копируется. Вот что произошло. Это x, это y, это tmp.
Что происходит дальше? Содержимое y записывается в x. Снова произошло копирование. Содержимое x удалилось,
и туда скопировалось содержимое y. То есть я уже произвел две операции создания новых объектов.
Ну и в конце, содержимое tmp вот этого перемещается наконец в x. Копируется, да. Вот так отработал
ваш swap. Сколько лишних действий, сколько выпитого произошло? Проблема ясна? Вряд ли это то,
чего мы хотели. То, чего мы хотели, продемонстрировали нам пять минут назад. Вопрос. Ну и на самом деле,
понятное дело, что это все для базовых типов, то есть если это все инты, например, то ничего
страшного не происходит. То есть копирование интов довольно быстро происходит. А что если в качестве
a и b у нас выступают какие-нибудь массивы или, например, стэки? Стэк размера 100 миллионов,
и второй стэк размера 100 миллионов. И я должен их поменять местами. Что у меня происходит? У меня x,
первый стэк, копируется в tmp. То есть все 100 миллионов объектов копируются в tmp. Происходит
копирование. Дальше. Во-первых, вызывается содержимое x удаляется, и все содержимое y копируется
в x. Второе копирование. Дальше берется содержимое tmp и тоже целиком копируется в y. То есть три
копирования и два удаления ресурсов. Если вы думаете, что вот этот swap работает за единицу,
то нет. Вот этот swap работает за линию. За линию от размеров стэков. Понятно? Ну а естественное
желание это иметь стэк, который бы работал за единицу. Как решить эту проблему? Да, swap.
То есть чего на самом деле тут нужно? Чего на самом деле нам тут хочется? Нам тут хочется не копирование,
от чего? Перемещение. Да, мы хотим не создавать новый объект, а мы хотим перемещать один объект
в другой. Мы хотим x переместить в tmp, y переместить в x и потом tmp переместить в y. Понятно? Вот.
Да, соответственно, вот тут идея. Нужно не копировать, а перемещать. Смотрите, какая проблема. Дело в том,
что на текущий момент мы вряд ли можем заставить компилятор тут что-то перемещать. Почему? Потому
что мы знаем, что тут во всех выражениях x, y и tmp это переменные. А переменные это всегда lvalue.
Если мы работаем с lvalue, то у нас всегда вызывается конструктор копирования или
копирующая операция присваивания. Согласны? То есть конструктор перемещения и перемещающая
присваивания у нас работает только со временными объектами. Проблема понятна? То есть теперь, чтобы
решить этот проблем, нам нужно научиться как-то, ну не знаю, обманывать компилятор. То есть нам нужно
говорить компилятору, что вот эти не временные объекты нужно воспринимать как временные.
Ну понятно, что если я тут заставлю компилятор думать, что x на самом деле временный,
у меня тут возникнет перемещение. Если я тут заставлю компилятор думать, что y временный,
то тут будет вызвано перемещение. Ну и то же самое здесь. Если я заставлю компилятор думать,
что tmp временный, у меня будет вызвано перемещение. Понятна идея? И вот, чтобы это сделать,
есть специальная функция std-move. std-move от x или от любой другой переменной, от любой другой сущности
работает следующим образом. std-move от x заставляет этот объект временно притвориться временным.
Понятно? То есть, грубо говоря, std-move это преобразование из lvalue в rvalue,
временное преобразование, не навсегда. Это преобразование осуществляется с помощью std-move.
Важно понимать, что std-move, вообще говоря, никак не меняет объект. То есть, если я скажу,
что вот эта штука временная, от этого она менее материально не станет. std-move для объекта просто
говорит, что в данном контексте, в данном выражении, считай этот объект временным и все. std-move
вообще никак не меняет объекта, вот вообще. То есть, можно считать, что это просто некоторое,
ну вот, просто притвориться чем-то вот в данном конкретном контексте. Ok? То есть, std-move позволяет
невременным объектам притворяться временными. Вот. И вот, собственно, то, про что мы говорили в начале.
Помните, мы говорили, что rvalue, там на самом деле это prvalue, xvalue. Так вот, xvalue это как раз
результат std-move. Давайте подробно. У нас был rvalue. Это все то, что не является lvalue. И вот,
rvalue разделяется на prvalue. Это то, про что мы говорили все это время до этого. То есть, prvalue
это вот реальные временные объекты. Прям вот чистые временные объекты. Ну, как раз те слова
pure, pure rvalue. А есть xvalue? Вот xvalue можно считать, вот xvalue называются, ну, опять же грубо,
те объекты, которые притворяются временными. Вот если объект не является временным, но им
притворяется, это xvalue. И вот результат std-move является, ну, является как раз xvalue. Ok? Вот.
Значит, ну, опять же, как я уже сказал, std-move на самом деле ничего не делает. Он просто-напросто
выполняет некоторое преобразование, ну, просто преобразование из lvalue в ссылке в... из lvalue в
ссылке в rvalue в ссылку. Ну, давайте пройдемся по примерам. Значит, у меня есть x, в котором сейчас
лежит 11. Когда я вызываю std-move от x, ничего не происходит. То есть, x просто куда-то там в
окно крикнул, что я временный, и все. С x ничего не произошло. То есть, просто тут x притворился
временным, теперь он снова нормальный. Ok? Здесь. Я пытаюсь создать ссылку rx на результат std-move от x.
Вот здесь у меня ничего не получится. Почему? Потому что std-move от x говорит, что x в данном контексте
притворяется временным, а я не могу создать левую ссылку на... на временный объект. Константную ссылку
получится. Да. То есть, если бы тут был constant, то все было нормально. constant rx равно std-move от x. Вот.
Значит, ну, вторая строка работает тоже нормально. В общем, здесь просто в y скопируется x. Вот. Теперь
я могу... да, более того, с помощью std-move я могу создавать правые ссылки на невременные объекты. То
есть, смотрите, допустим, я хочу создать правую ссылку. Ну, непонятно зачем, но, допустим, хочу. Хочу, чтобы
у меня rx, правая ссылка, ссылалась на x. Просто так написать rx равно x мне нельзя. Но я могу
написать rx равно std-move от x. Что делает std-move от x? std-move от x говорит, что x должен притвориться
временным. В данном случае x притворяется временным, и теперь rx ссылается на временный объект x.
Okay? Вот. Ну, rx теперь это полноценная, ну, прям нормальная полноценная ссылка на x. То есть,
если я изменяю rx, то у меня x сам тоже изменится. То есть, это просто некоторый способ, то есть,
некоторый способ связать правые ссылки с невременными объектами. Это std-move. Понятно?
Нет, он ссылается именно на то место, где расположен x. Ну, смотрите, std-move от x, ну, как это работает?
Смотрите, вот тут написано. std-move от x это, на самом деле, просто, это просто некоторое
преобразование. То есть, std-move от x возвращает вам правую ссылку на x, ну, грубо говоря. Ну, а так как
это ссылка, то ссылка, она ссылается опять же на какую-то область памяти. Поэтому здесь все нормально.
Здесь константная ссылка, ссылается на область памяти, где находится x. Да, нет, если вы делаете
плюс-плюс x, то rx тоже изменится, естественно. То есть, здесь вот этот rx и вот этот вот rrx, они
ссылаются именно на x. Именно то место, где расположен x. Ну, давайте два слайда осталось, потом перерыв
и все сделаем. Все понятно здесь? Да. В последнем примере, да, да. Да, все так. Ну, вы объявили ее как правую,
но работает как левая. То есть, на самом деле, вот эта вот ссылочка, она лишь говорит о том, с какими
объектами можно связывать rrx. В данном случае вы сказали, что ссылку rrx можно связывать только
со временными объектами. Ну, а x притворился временным. Ну, поэтому я смог таким образом обойти
это требование. То есть, я смог связать правую ссылку rrx с невременным объектом. То есть, на самом
деле, везде вместо std move вы могли спокойно писать что-то наподобие такого. Ну, там, давайте в c style,
int двойной амперсант x. То есть, это поработало точно так же, как std move. Ну, или вы могли написать
static cast от int двойной амперсант скобках x. То есть, вы могли это делать вручную. То есть, вы могли
вручную просто привести x к правой ссылке. Ну, недостаток понятия. Вам нужно самостоятельно указывать
тут тип. std move позволяет вам тип не указывать, а просто передавать ему аргумент. Возможно, в следующий раз мы
поговорим, как std move реализован внутри. Но в общем и целом, можно считать, что это просто
static cast или просто преобразование в правой ссылке. И все, больше ничего. Ну, и теперь со стеком.
Ну, и как работает std move со стеком? Ну, ровно точно так же. Если я пишу stack x равно y, то тут
происходит копирование. Ну, как и раньше. Если я пишу y равно x, то тут происходит тоже копирующее
присваивание. Ну, тоже никаких вопросов нет. Что произойдет, если я позову std move от y? Что произойдет
с y? Что произойдет? Ну, ничего с y не произойдет. std move ничего не делает. Сам по себе std move,
он с объектом ничего не делает. Он его никак не изменяет. Поэтому, если вы вызвали std move от y,
компилятор это просто строку проигнорирует. То есть, она ничего не делает. Но все становится по
другому, если вы используете std move вот в таком контексте. Ну, например, в таком контексте.
Вы пишете stack z равно std move от y. И вот в этот момент происходит магия. Смотрите,
какой конструктор у меня тут вызывается? Ну, есть два варианта. То есть, я хочу создать stack z
с помощью stack y. Я могу вызвать конструктор копирования или конструктор перемещения. Вот здесь
вызывается конструктор перемещения. Почему? Потому что y претворился временным. А мы договорились,
что если я какой-то объект создаю с помощью временного значения, то у меня вызывается
конструктор перемещения. И вот здесь ровно это и происходит. То есть, у меня содержимое y
перемещается в z. И вот как раз-таки ответ на ваш вопрос. Вы спрашивали, зачем нужно еще и size
занулять? Вот если бы я size не занулял, то у меня получился stack y, в котором бы буфер был нулевой,
а size был бы не нулевой. Понятно? Понятно, что этим y я, в принципе, теоретически могу дальше
воспользоваться. Ну а тут у меня как бы в плохом состоянии stack находится. Вот. То есть, что у меня
тут произошло? Давайте снова порисуем. Значит, у меня есть stack x, у которого есть свой буфер. Давайте
вот так будем держать. Есть stack y, у которого есть свой буфер. И есть stack z, который я создаю вот
в этой строке. Когда я вызываю z равно stdmove от y, что происходит? Содержимое y перемещается в z.
То есть z, на самом деле, просто берет и крадет содержимое y к себе, а y остается ни с чем. То есть
y теперь указывает никуда. Вот что произошло. Понятно? То есть stdmove позволяет забрать
содержимое другого stack, ну или другого объекта себе. Ну и дальше в следующей строке y равно stdmove
от x. Что происходит? У меня теперь y забирает содержимое x. Вот так. А x остается ни с чем.
Вот. Важно понимать, что вот эту всю магию с тем, что у кого-то что-то украли и так далее,
это все делает не stdmove. stdmove ничего не делает. Всю вот эту магию сделал мне конструктор
перемещения и перемещающее присваивание. Понятно? То есть вот эту логику с забиранием,
с отъемом вот этих вот самых указателей. Вот эта логика, она у меня реализована в конструктор
перемещения и перемещающем присваивание. Понятно? Вот. То есть теперь после выполнения
этого кода у меня, ну во-первых, понятное дело, что я не создавал ни одного нового буфера. Вот здесь,
при манипуляции x, y и z, я не создал ни одного нового буфера. То есть никакого new и delete у меня
вызван не было. Я просто перемещал между ними вот эти самые указатели. x теперь пустой,
ну потому что я у x в последней строке забрал содержимое и сохранил его в y. Понятно? Вот.
Да, ну и собственно пустым x сделал не stdmove, а перемещающий оператор присваивания. Все понятно?
Все. Ну и наконец, как правильно написать swap? Правильный swap выглядит следующим образом.
Чтобы поменять местами x и y, нужно сделать следующую вещь. Нужно x переместить во временное
значение. А как x переместить во временное значение? Нужно у tmp вызвать конструктор перемещения.
А как у tmp вызвать конструктор перемещения? Нужно, чтобы x претворился временным. Чтобы x
претворился временным, мы делаем stdmove от x. Понятно? Все. Т.е. tmp равно stdmove от x. Вот. Дальше.
В следующей строке мы перемещаем содержимое y, ну то есть просто перемещаем содержимое y в x.
Делаем это с помощью стдmove. x равно stdmove от y. Ну и в конце мы перемещаем содержимое временного
хранилища в y. y равно stdmove от tmp. И так как у меня все перемещения, ну то есть мы говорили,
что перемещающие конструкторы и перемещающие присваивания работают за единицу, теперь у меня
каждый из этих трех строк работает за единицу всегда. Неважно, какого размера у меня объекты. Все,
что я делаю, это просто меняю указатели местами. И все. И вот теперь у меня есть прекрасный сваб,
который работает за три перемещения и всегда работает за единицу. Так, значит, на второй части мы
поговорим про, ну мы продолжим говорить про c++, но с некоторой другой точки зрения мы поговорим,
наверное, больше про стандартную библиотеку, ну и бонусом разберем одну из задач вашего задания
текущего. Поговорим мы про умные указатели. Ну смотрите, в первом задании вы писали, должны были
писать, по крайней мере, класс строки. Вот что он из себя представлял? Он представлял динамическую
строку, которая хранила свои данные в динамической области памяти и могла по мере необходимости
расширяться при запросе, могла уменьшать свой размер и так далее. Ну вообще в принципе представлял
из себя удобный интерфейс для работы со строками. То есть можно было конкатинировать строки и так далее,
и в принципе можно было не париться о работе с памятью, о том, какие внутри алгоритмы использованы. То
есть в конструкторе она там память выделяет и в деструкторе все освобождает, все отлично. И
собственно вопрос вам, как уйдем мы реализуем с помощью вот такого подхода, когда мы выделяем все в
конструкторе, а уничтожаем в деструкторе. Да, рай. Ресурс acquisition из initialization. То есть захват
ресурса, есть initialization. Ну и вообще говоря, современный T++, он изобилует такими большим
количеством классов, которые реализуют семантику рай, но в частности вам не нужно писать там свои
динамические массивы, потому что у вас есть класс std-вектор, который, кстати, во втором задании уже
использовать можно. То есть я надеюсь, вы на семинарах поговорили о том, как они устроены, как они
работают и так далее. Ну у нас будет отдельный лекции по этому, но в принципе уже можно начинать
пользоваться. Но при этом смотрите, у нас есть std-string, у нас есть std-vector, и они реализуют так
называемые динамические массивы. То есть мы в динамической области памяти выделяем массивы и
дальше с ними как- то работаем. Но на практике мы же не всегда работаем именно с массивами,
согласитесь, что иногда нам необходимо выделять объект, так скажем, по одному. То есть вряд ли
вы будете использовать std-вектор, чтобы выделять объект там по одной штучке, то есть взяли один
объект, один объект, один объект и так далее. Но в частности если вы реализуете связанный список.
Связанный список вы реализуете так вы выделяете при необходимости новый узел, ну и дальше этот узел
провязываете с остальными и так далее. То есть, при необходимости вы делаете new node и так далее, и так далее.
Понятное дело, что писать new в своем коде это не раи безопасно. То есть, это не безопасно с точки зрения
утечек памяти, с точки зрения того, что вам нужно постоянно там думать, где написать delete.
Ну и более того, вы не всегда на самом деле можете написать delete самостоятельно. Классический пример такой.
Давайте у вас есть какая-нибудь структура
node, которая представляет из себя
узел односвязанного списка, в котором хранится, допустим, интовое поле value и
указатель на следующий узел nodeNext.
Ну и допустим, вы пишете свою функцию, которая называется allocateNode.
Int x пусть будет. Ну и все, что эта функция делает, она просто инкапсюлирует внутри себя
вызов newNode.
То есть allocateNode внутри себя создает новую вершину и возвращает вам
новый узел.
Смотрите, функция allocateNode, она выделила некоторые новые ресурсы с помощью new.
Ну и теперь вопрос, а кто ответственный за то, чтобы вызвать delete соответствующий?
То есть, согласитесь, что allocateNode в этом смысле, она очень не безопасна. Но дело в том, что она подразумевает, что
пользователь, он достаточно самостоятельный, достаточно ответственный для того, чтобы самостоятельно вызвать delete.
То есть, мы как бы вызвали new, а дальше отдали внешнему коду на откуп node. Дальше ты делаешь с этим
указателем все, что угодно, главное не забыть потом вызвать delete. Но это как-то какое-то слишком сильное требование к пользователю, чтобы он там не забыл
почистить ресурсы, которые выделены, тем более не он.
То есть, пользователь как бы читает свой код, он не видит ни одного new, поэтому, наверное, он думает, что не нужно вызывать delete и так далее.
То есть, в данном случае это классический пример функции, которая сама вызывает new, но при этом сама вызвать delete не может.
Понятно?
Ну и, в принципе, наверное, как-то работать с new и delete, то есть, постоянно для каждого new
думать, как вызвать delete и так далее, это не очень удобно. И вот для таких целей
существуют так называемые умные указатели. И давайте мы, собственно, попробуем,
ну, во-первых, посмотрим, какие указатели, какие умные указатели есть в стандартной библиотеке C++, а во-вторых, попробуем написать их
некоторых аналоги самостоятельно. Ну, давайте сделаем что-то наподобие такого.
Напишем
некоторый класс
smart-ptr.
Вот, который внутри себя в приватной области будет хранить единственное поле,
которое представляет из себя указатель.
Значит, ну давайте так, цель. Я хочу написать класс, который будет являться оберткой над
обычным сырым указателем, который будет, собственно, захватывать ресурсы в конструкторе и освобождать его в деструкторе.
Соответственно, что я делаю? Ну, давайте напишу какой-нибудь конструктор. Допустим, конструктор
explicit
smart-ptr, который будет принимать
обычный указатель. Ну, то есть я передаю в этот умный указатель, собственно, выделенный уже заранее указатель,
и сохраняю его в себе в поле.
Ну и дальше в деструкторе
smart-ptr. Я этот ресурс освобождаю. То есть я просто беру и
делаю delete-ptr.
Ну, используя, например, например, такой int-main и дальше smart-ptr.
Давайте add-note.
ptr-new-note.
Там, не знаю, ну пусть так.
Ну, казалось бы, все нормально, да?
То есть вот я написал класс smart-ptr.
Что происходит в конструкторе? В конструкторе я просто-напросто беру указатель, который мне передали,
сохраняю его в поле, а дальше, собственно, вот здесь смотрите в мейне, несмотря на то, что я написал там new, мне не нужно самостоятельно думать о том, что вызвать delete.
Почему? Потому что delete у меня будет вызвано автоматически в деструкторе smart-ptr.
Окей?
Согласны?
Ну окей, ну хорошо, смотрите, я написал такой замечательный класс ptr, который умеет создаваться и умеет удаляться, и больше ничего не умеет.
Ну как-то странно, как-то странно. То есть если мы говорим про умный указатель, мы, наверное,
в самом названии умный указатель, содержится слово указатель. Наверное, мы хотим вот этим классом или объектами этого класса пользоваться как и обычными указателями.
А что мы обычно хотим от указателей?
Умение их разыменовывать. Да, отлично. Давайте попробуем реализовать операцию разыменования. То есть благо мы проходили
перегрузку операций. Вопрос. Что возвращает разыменование указателя?
Вот если у меня есть указатель на объект типа t, я разыменовываю указатель. Что мне возвращается?
t, а если более точно?
Ну ссылка на t или lvalue на t, да? То есть я тут должен вернуть t&, и дальше я перегружаю
оператор звездочка, оператор разыменования. Значит, оператор звездочка это унарная операция, поэтому я туда ничего не передаю.
Вопрос. Эта операция константная или неконстантная?
Неконстантная. Почему неконстантная?
Да, ну смотри, то, что мы разыменовываем, меняем. А сам указатель-то от этого меняется или нет?
Да, ну то есть весь прикол в том, что сам указатель-то от этого не меняется. То есть согласитесь, что если бы тут написали
const smartptr, то мы бы все равно хотели разыменовывать сам ptr.
Странно как-то не разыменовывать константный указатель.
Да?
То есть смотрите, если бы я тут написал,
то есть у меня,
короче, когда я пишу тут const, у меня константом становится сам указатель.
То есть я сам указатель менять не могу, но то, что лежит под указателем, я менять могу.
Понятно? Если бы я не хотел менять сам объект, я бы написал smartptr от const node.
Ну, при разыменовании указателя, сам указатель, естественно, не меняется, поэтому этот метод является константным.
Ну и все, что он делает, это возвращает разыменованный ptr.
Вот, отлично. Ну давайте проверим, что
проверим, что все работает, например.
Да, тут кавлик, конечно.
Ну ладно, и тут мы можем, например, проверить что-то типа, я не знаю, какой-нибудь ассерт.
ptr.value равно равно единице. Вот как-то так.
Вот, окей. То есть разыменование написали.
Что дальше? Что еще мы ожидаем от указателя? Что еще входит в интерфейс указателя?
Ну, смотрите, вот я тут использовал ptr.value, а еще я могу, наверное, использовать ptr.next.
Какой есть альтернативный синтаксис, чтобы делать вот такую штуку?
Да, то есть, наверное, хотелось бы уметь
делать что-то такое.
Обращаться через стрелочку.
То есть не разыменовывать и потом ставить точку, а именно обращаться через стрелочку.
Давайте попробуем перегрузить операцию стрелочкой. Благо ее тоже можно перегружать.
Оператор
стрелки. Она тоже константная, потому что операция стрелочка, она, естественно, сам указатель не меняет.
И вот тут возникает вопрос, а что должно вернуть операция стрелочки? Вообще, в принципе, как она работает?
И вот ответ такой. Операция стрелочкой это особенная операция, которая работает следующим образом.
Если операция стрелочка
применяется к обычному указателю, ну, не знаю, допустим, у вас есть pointer, и это обычный указатель. Вот если вы к нему
принимаете стрелочку, то компилятор дословно это все переводит в следующий код.
pointer.x
То есть, если компилятор вот здесь,
слева, слева стрелочки, видит обычный указатель, он просто это все переводит вот в такой код. То есть, он разыменует указатель и берет x.
А что происходит, если компилятор в качестве pointer, вот в качестве вот этого pointer? Давайте так, класс.
class pointer.
Если он в качестве левого операнда, в качестве операнда, который стоит слева от стрелочки, он встречает объект какого-то класса. Вот тут происходит магия.
Компилятор подставляет следующий код.
Он пишет
class pointer.
точка, оператор, стрелочка. То есть, он вызывает операцию стрелочкой, которая определена внутри вашего класса, и
у результата вызывает стрелочку.
То есть, компилятор, если вы применяете стрелочку к вашему классу, то он вызывает операцию стрелочка до тех пор рекурсивно.
То есть, в этом смысле он настойчивый. Он
рекурсивно вызывает стрелочку до тех пор, пока вы не вернете обычный указатель.
То есть, компилятор не умеет работать ни с чем другим, кроме как с обычными указателями, и он от вас настойчиво просит обычный указатель.
Вот если у вас операция стрелочка возвращает необычный указатель, то есть, если у вас операция стрелочка возвращает снова какой-то класс,
то компилятор продолжает. Он снова пишет точка,
оператор, стрелочка... ну и так далее.
И если, в какой-то момент, ну elephants вызывают двух операций стрелочек...
ваш метод вернул обычный указатель, то тут все нормально. Как handmade с обычными указателями, компилятор знает.
Понятно?
то есть стрелочка, то есть операция стрелочка применяется рекурсивно до тех пор, пока вы не вернете нормальный указатель.
Если вы нормальный указатель так и не вернете, то у вас на самом деле будет ошибка компиляции.
Компилятор умеет такие штуки проверять на этапе компиляции, то есть если вы тут напишете
smart ptr от, что тут, t,
и потом напишете return list, тут возникает ошибка компиляции. Почему? Потому что у вас тут бесконечные рекурсии.
Компилятор бесконечно будет вызывать операцию стрелочкой и, ну, собственно,
ну, короче, компилятор вам скажет, что вы делаете рекурсию, в общем, вы не правы.
Поэтому правильный способ реализовывать операцию стрелочкой, это просто вернуть обычный указатель, то есть t звездочка.
Соответственно, вы возвращаете ptr.
Понятно?
Как это работает? Когда вы вызываете ptr стрелочка value,
вот эта штука разворачивается в следующую вещь.
Компилятор понимает, что слева от стрелочки стоит объект класса, поэтому он через точку вызывает оператора стрелочка.
И дальше к этому всему применяет обычную стрелочку. Это работает именно так, дословно.
То есть сначала он вызывает операцию стрелочка через точку, дальше вот эта ваша операция стрелочка возвращает обычный указатель.
Ну, а как применить стрелочку к обычному указателю, компилятор уже спокойно знает и все нормально. Понятно?
Поэтому операция стрелочка реализовывается таким образом. В качестве ответа к операции стрелочек вы должны вернуть некоторый объект,
к которому снова можно применить операцию стрелочек.
В самом простом случае, вы возвращаете просто обычный указатель.
Вот и все.
Ну вот.
В принципе этих двух операций достаточно, чтобы поддержать 99 процентов функционала всех указателей.
Теперь вопрос следующий.
Что вам еще не нравится вот в этом классе? Смотрите, снова. Я написал класс умного указателя,
который в конструкторе принимает некоторый указатель,
то есть указатель на выделенную память, в деструкторе ее освобождают, то есть не нужно самостоятельно вызывать delete.
Вот я могу вызвать стрелочку, могу
разыминовывать этот указатель и все работает корректно. Что не так?
Арифметики. Ну на самом деле арифметику с умными указателями, наверное, это такой момент, при котором хорошо, что нет арифметики.
Согласитесь, странно, что вы
выделили память. Не знаю, давайте какой-нибудь. ptr равно newint.
А потом делаете plus plus ptr. Ну это странно.
Если выделили какую-то память динамическую, то вы ее, то вы вряд ли выполняете с ней арифметику.
Потому что непонятно потом,
как делать delete ptr. Потому что вы уже ссылаетесь не на тот объект, который выделяли. Согласны?
Поэтому то, что арифметики нет, это нормально.
Хороший вопрос. Действительно, если мы,
смотрите, если мы здесь, допустим, попытаемся вызвать new не от одной ноды, а попытаемся выделить сразу массив нод, то
этот умный указатель работать не будет. Но у меня есть контраргумент.
Смотрите, если вам нужен динамический массив, зачем вы используете умный указатель? У вас же есть вектор.
Это первый ответ. А второй ответ, если вы используете арифметику с умными указателями, то у вас же есть арифметик.
Это первый ответ. А второй ответ, мы эту проблему поборем чуть позже.
Вообще да. Но, короче говоря, умные указатели, как правило, используются только с одним объектом. То есть, когда вы выделяете только один объект.
Поэтому все нормально. Если вам нужен динамический массив, то используйте вектор или строку динамическую.
Давайте буквально, на прошлый, только сегодня обсуждали, в чем проблема этого класса.
Нет.
Правило пяти.
Смотрите, у меня этот класс, он заведомо работает с ресурсами.
Мало того, что он работает с ресурсами, так мы еще и деструкторы реализовали.
И у вас должен сразу работать триггер. Если мы реализовали деструктор, то значит нам дает еще кучу всего реализовывать. То есть деструктор это только начало
пути большого.
Что еще нужно реализовать?
Два копирования, два перемещения.
Короче, два копирования, два перемещения.
Хорошо, давайте попробуем написать копирование.
Smart PTR от const smart ptr по ссылке other.
А как должен работать копирование для умных указателей?
Вот смотрите.
Вот у меня есть PTR.
Я хочу создать копию.
Прямо как-то вот так.
Что должно произойти?
Давайте.
Правда ли, что когда вы пишете вот так, вы ожидаете, что создастся
какой-то новый указатель, который будет указывать на
такой же объект.
Ожидаете ли вы такого поведения? Да.
То есть при копировании одного, то есть когда вы пишете, то есть если отсвечите, то есть если у вас есть
int ptr равно чему-то и
вы пишете
равно ptr, вы ожидаете, что у вас этот указатель будет указывать на некоторые новые объекты?
Ну то есть
вы ожидаете какого-то такого поведения?
А с умными указателя вы ожидаете такого? Но это как странно, несимметрично.
То есть наверное хочется чтобы...
То есть вы ожидаете, что у вас будет вот так?
А кому нравится такое поведение? То есть когда вы создаете копию указателя, вы указываете на тот же самый объект.
Ну то возникает сразу куча проблем.
А кто из них должен удалять? Ну хорошо, двойное удаление. Понятное дело, что когда мы будем писать своему наказателю, мы не будем двойного удаления допускать.
Но возникает вопрос, а...
Хорошо, если нет двойного удаления, то кто обязан удалять этот объект x? Он или он?
Вот непонятно.
То есть с копированием в умных указателях на самом деле все сложно. То есть если у вас есть какой-то ресурс, то
владение несколькими указателями одним и тем же ресурсом приводит к проблемам.
Какой самый простой способ решить любую проблему?
Забить.
Давайте просто-напросто возьмем и запретим копирование.
Давайте скажем, что если у меня умный указатель, то я просто запрещаю копирование. Копировать умные указатели нельзя.
Ну и соответственно
операцию копирования тоже нужно запретить.
Берем равно delete. Все, я реализовал копирование.
Просто запретив его.
Окей, а что с перемещением? Нужно ли мне запрещать перемещение?
Да, а вот с перемещением все нормально. То есть как вы ожидаете,
вот что вы ожидаете от перемещения? То есть что если я тут напишу, например, std
std move от ptr, что вы ожидаете?
Вы ожидаете, что копия будет ссылаться на тот же самый объект, что и ptr, а ptr теперь
ничем владеть не будет.
То есть с помощью перемещения я просто передал
владение ресурсом от ptr к его копии.
То есть с перемещением действительно все нормально.
Ну давайте как-нибудь реализуем.
Вот ptr у меня теперь должен быть тем же самым, что и
addr ptr. Что еще я должен сделать?
Да, у addr ptr
должен его занулить. Но опять же понятно, почему занулить, чтобы не было двойного удаления, чтобы не было такого, что у меня два указателя
указывают на одну и ту же область памяти.
Отлично.
Ну и примерно то же самое.
Я делаю в операторе присваивания smart ptr addr.
Проверяю, присваиваю я самому себе или нет.
Если это не так, то что-то делаю, иначе сразу возвращаю.
Ну и что тут происходит?
Ну то же самое. ptr равно addr ptr. То есть я забираю ресурс у другого объекта,
а о другом объекту говорю, что ты остаешься ни с чем.
Все или что-то еще?
Все устраивает?
Все подвох ищут, да?
Нет, все нормально. Вот все, тут все ок.
Вот, вот таким образом мы реализовали умный указатель, который нельзя копировать, но можно спокойно перемещать.
И вот такие указатели, аналогом такого указателя, который мы сейчас написали, является
стандартный класс std.unique.ptr.
Умные указатели, все умные указатели стандартной библиотеки расположены в
расположен в заголовочном файле memory.
Вот здесь расположены все умные указатели.
Ну вот и все. Ну короче говоря, я утверждаю, что
только что мы сделали одну задачу из задания.
В качестве одной из задач из задания вам нужно писать свой
умный указатель, который является аналогом unique.ptr. Ну, мы реализовали его не полностью, там нужно еще кое-какие методы писать, но
я не думаю, что будут большие проблемы.
Все ли понятно?
То есть unique.ptr
unique.ptr это умный указатель, который есть стандартный университет, который реализует семантику
уникального владения.
То есть каждым ресурсом, на который указывает unique.ptr, может отводеть только один объект и никто иной.
За счет чего это достигается? Это достигается за счет того, что я запрещаю копирование и
разрешаю перемещение. При перемещении у меня владение передается другому объекту, то есть никакого двойного владения не происходит. Понятно?
Вот. Какие есть еще интересные методы у unique.ptr? Ну и вообще у любого другого умного указателя. Классические методы это get.
Get просто берет и возвращает
указатель, ну да, просто возвращает сырой указатель.
То есть с помощью функции get, с помощью методы get, вы можете получить указатель, который лежит
внутри умного указателя. Вот этот самый ptr.
Есть еще полезные методы. Наверное, полезный метод release.
Он тоже возвращает
сырой указатель и перестает им владеть.
То есть если вы хотите сказать, что вот этим ресурсом все, больше не надо владеть, короче,
unique.ptr, ты больше не ответственно за него, теперь отдавай это на откупне. Тогда вы просто вызываете release.
Вот после того, как вызвали release, вам вернулся тот самый указатель, на который
ссылался вот этот unique.ptr, и дальше unique.ptr ссылается на null.ptr, окей?
Ну, когда вы делаете перемещение, вы перемещаете его в другой умный указатель. Когда вы делаете release, вы забираете его себе.
То есть, грубо говоря,
если у вас есть
std
unique.ptr, давайте p, и вы пишете new inc,
ну, допустим, от единицы,
то когда вы делаете
std
move от p, вы вот этот указатель
переносите в новый умный указатель.
То есть, вы говорите, что теперь этим указателем владеет
новый умный указатель. А когда вы делаете release,
давайте так напишем int, звездочка,
x пусть будет равно copy.release,
а когда вы делаете release, вы говорите, что копий теперь не владеет этим указателем,
а указателем, то есть теперь вот этим указателем управляете вы, а не какой другой умный указатель, понятно?
То есть, в release вы просто отлучаете
указатель от владения этим ресурсом.
Ну и есть еще метод
reset,
который принимает другой указатель, и который, давайте adder,
меняет владение на adder.
Если вы хотите, что ваш умный указатель теперь указывал не на x, а, скажем, на какой-то другой ресурс y, то вы звайте reset.
Да, при этом
старый
ресурс удаляется.
То есть, reset вы просто меняете один ресурс на другой.
Ну все, и теперь у вас
pipeline выглядит как-то так. std.unique.ptr от
node.ptr, и вы сюда передаете new
node. Как-то заполняете. Все, и дальше пользуетесь этим указателем через ptr, через ptr-стрелочка,
и так далее.
Все, ну и после того, как вам ptr больше там не нужно, после того, как вы вышли из функции main или из какой-то другой функции, то
ptr автоматически освободится. Вот, более того, помните, когда мы писали allocate node, теперь мы решаем эту проблему.
allocate node in x. Теперь мы можем сделать следующую вещь.
return std.unique.ptr от node.
new node x.
Все, и теперь вы спокойно можете возвращать умный указатель из любой функции,
и можете не беспокоиться о том, что там как-то
в общем, можете не беспокоиться над тем, что для этого объекта не будет вызван delete.
Для этого объекта в любом случае будет вызван delete. То есть, как бы вы не написали, вы можете написать тут
after ptr равно allocate node 5 и спокойно пользоваться этим ptr-ом как обычной переменной,
не задумываясь о том, что нужно там для него вызвать delete, что-то освободить и так далее.
Сейчас несколько глубже погрузимся в Unique Ptr,
и затем, я надеюсь, успеем перейти к другому умному указателю. Смотрите,
Unique Ptr на самом деле более универсален, чем там может показаться на первый взгляд.
Дело в том, что Unique Ptr может работать не только с памятью,
но и вообще с любым другим ресурсом, с которым нужно что-то делать в конце.
Давайте классический пример. Когда вы открываете файл,
его нужно обязательно закрыть, потому что количество открытых файлов в операционной системе ограничено.
Так вот, на самом деле Unique Ptr можно настроить по-своему, то есть, вы можете сделать так, чтобы Unique Ptr делал в конце,
в деструкторе делал то, что вы хотите, и для этого
у Unique Ptr есть специальный параметр, который называется Deleter. На самом деле, вот здесь в качестве второго параметра у него выступает еще один тип,
который называется Deleter.
У этого типа Deleter
должны быть перегружены круглые скобки. То есть, у этого типа, который вы сюда передаете,
у этого чего-то нужно уметь брать круглые скобки. Давайте по порядку, что я имею ввиду.
Допустим, у вас есть...
Давайте сразу в терминах Unique Ptr буду писать, Unique Ptr, и
в общем,
ну, классический способ,
классический способ работать с файлами, там языки C, C++, это использовать так называемые функции,
давайте файл назовем, использовать функции fopen и fclose.
std
fopen, ну, и вы сюда передаете какой-нибудь файл, там a.txt,
ну, и дальше там вы открываете от файлночтения read.
Понятное дело, что для файла, ну, да, при этом fopen, вот этот fopen возвращает
возвращает специальный тип, который называется файл-звездочка. То есть, файл это тип файла, а звездочка это указатель на файл. То есть,
fopen возвращает вам указатель на файл.
Ну, понятное дело, что для файла не имеет смысла вызывать delete.
Если вы сделаете delete от указатель на файл, то,
во-первых, будет ошибка, потому что вы удаляете там то, что не было выделено в памяти,
хотя нет, скорее всего выделено в памяти, но не судит. Главное, что delete не приведет к закрытию файла.
Чтобы закрыть файл, вам нужно вызвать специальную функцию fclose.
Ну, и передать сюда указатель на файл. Так вот, как мне заставить UniquePtr сделать так, чтобы он при
вызове деструктора вызывал не delete, а вызывал stdf close.
Значит, делайте это следующим образом.
Вы пишете специальную функцию,
ну, например, называете ее delete file.
Это один из способов,
который принимает
указатель на файл.
И даже вы в этой функции пишете, что нужно сделать. Ну, в данном случае нужно вызвать stdf close
от файла.
И что нужно сделать дальше? А дальше нужно STD UniquePtr сказать, что нужно использовать нестандартный удалитель,
то есть нужно использовать необычный delete, а
нужно использовать нечто иное.
Ну, в частности, в качестве нечто иного должна выступать функция delete file.
Вопрос. Какой тип имеет
delete file?
Вот когда вы передаете функцию в другую функцию, что вы на самом деле передаете?
Выбираете указатель на функцию, поэтому тут нужно указать тип указатель на функцию, то есть который возвращает void и
принимает
указатель на файл.
Все, и теперь что происходит? Когда вы открываете файл, здесь FOPEN, у вас возвращается указатель на файл, и вы передаете его в умный указатель.
И дальше вторым аргументом еще передаете дополнительную функцию, которую нужно вызвать вместо обычного delete.
И в данном случае это функция delete file.
Вообще говоря, это не очень удобно, согласитесь, ну то есть тут нужно, то есть, во-первых, вам нужно написать отдельную функцию, ну то есть это ладно, как бы
отдельная функция, это пойдет.
Так вам дополнительно нужно вот здесь прописывать полный тип функции, что на самом деле не всегда довольно удобно.
То есть это еще нужно помнить, как написать указатель на функцию и так далее.
Поэтому классическим подходом здесь является
использование следующего синтаксиса. Давайте я возьму и напишу отдельную структуру fileDeleter.
Специальный класс FileDeleter, и у которого возьму и перегружу операцию круглые скобки.
Вот, к вопросу о том, зачем нам нужно вообще перегружать круглые скобки. Вот пример.
Ну и здесь делаю то же самое.
std
close
И теперь что я делаю? Теперь я просто беру
и в качестве второго шаблонного параметра придаю вот этот тип FileDeleter. И все.
Как это работает?
Работает следующим образом.
Вот здесь есть класс Deleter. Ну давайте так, как это работает грубо.
Тут у UniquePtr в качестве второго параметра выступает Deleter.
Что делает UniquePtr? UniquePtr берет и в деструкторе создает объект типа Deleter.
И дальше у этого объекта Deleter
и дальше у этого объекта Deleter
вызывает операцию круглые скобки.
Понятно?
Вот и вся магия.
У вас может возникнуть вопрос.
Ну смотрите, я же могу еще UniquePtr вызывать и без этого Deleter.
Тогда мне будет вызываться Delet.
Как это работает?
А работает следующим образом.
В стандарт-библиотеке вместо класса Deleter стоит класс под названием DefaultDelete.
И вот этот класс DefaultDelete у себя в круглых скобках,
то есть он где-то определен тоже в стандарт-библиотеке,
и он у себя в круглых скобках просто-напросто берет и вызывает Delet.
То есть круглые скобки для обычного Deleter,
то есть для std DefaultDelete,
вызывают просто Delet.
Тут, на самом деле, еще T.
Поэтому стандартный способ,
то есть если вы хотите владеть ресурсом,
который отличен от памяти,
то есть если вы хотите управлять не памятью,
а, скажем, какими-то другими ресурсами,
ну сейчас эти файлами, Mutex,
для Mutex есть другие вещи, в общем,
для которых нет никакой обертки,
то вы вполне можете использовать Unique PTR,
но для этого вы должны позаботиться о том,
чтобы вас сюда передался как корректный Deleter.
Давайте еще пару вопросов судим.
Тут был вопрос про то, смотрите, Unique PTR,
а что если у меня есть Unique PTR,
и я хочу, чтобы он ссылался не просто на один объект,
как я писал до этого,
а на целый массив?
Ну, допустим, меня не устраивает вектор,
я хочу указатель, который просто указывает
на выделенный кусок памяти в качестве массива.
Вот таким образом.
Понятное дело, что это будет работать плохо,
точнее это не будет работать,
тут будет UndefinedBehaviour, почему?
Потому что здесь DefaultDelete
вызывает обычный delete без квадратных скобок.
Понятно?
То есть нельзя применять обычный delete
к указателю,
который был выделен с помощью
new с квадратными скобками.
То есть тут обязательно нужно вызвать delete
с квадратными скобками.
Как заставить это работать?
Ну, вы можете сказать, что
тут нужно просто прописать свой
кастомный deletor,
то есть написать класс deletor,
передать его, который будет вызывать delete
с квадратными скобками.
Но на самом деле все сделано за вас.
Все, что нужно сделать, чтобы это заработало,
вам нужно тут вместо int прописать int
квадратные скобки и все.
То есть int квадратные скобки
это такой специальный тип,
который называется UnboundedArray
или неограниченный массив.
И как он работает?
У default delete
есть специализация
на случай, когда у вас в качестве t
выступает как раз-таки массив.
И этот самый default delete, если у вас в качестве t
выступает массив, он вызывает delete
с квадратными скобками. И все прекрасно работает.
Понятно?
То есть мораль
состоит в том, что если вам все-таки
кровь из носу зачем-то нужно
создать UniquePtr на массив,
тогда вы в качестве параметра обязаны
указать тип и квадратные скобки.
И дальше вызываете new с помощью квадратных скобок.
Если вам нужен обычный выказатель
без массива,
то пишите вот так.
Понятно?
Окей.
Ну ладно, еще один пример.
Давайте.
Указать.
Давайте
без файлов, давайте
сделаем так.
Давайте я напишу функцию deliter,
которая будет принимать int
указатель
и будет внутри себя делать
deletePtr.
Так, здесь будет обычная
штука, здесь будет
то же самое, но только буду сюда
передавать void
ptr2
new int.
И сделаю следующую вещь.
Сделаю stdout
sizeof ptr
ptr
и sizeof
ptr2.
Давайте уберем.
Вот. И делаем химик.
То есть смотрите, я создал uniquePtr
и здесь в качестве deliter
использую обычный deliter.
То есть class deliter.
Давайте пропишем.
struct
delete
class
Здесь я сделаю
то, что делали до этого.
Операторы круглые скобки
принимают указатель на int
const
и делаю delete
от ptr.
И здесь я
принимаю delete class, а здесь в качестве
row параметра, да, я еще должен передать deliter.
Здесь я хочу показать разницу между
этими двумя способами и продемонстрировать
еще одну проблему, которую мы касались ранее,
но вы были еще
маленькие, чтобы ее понять.
Смотрите, значит,
я написал custom deliter
и передал его в виде класса.
Вот.
А здесь я написал тоже custom deliter, но передал его
в виде функции.
Вопрос.
Отличаются ли как-то размеры
ptr и ptr2?
Кажется странно, то есть у меня есть как бы два класса,
но они вроде как одинаковые.
Да, то есть и
первый хранительный указатель, и второй хранительный указатель.
Могут ли они
как-то отличаться по размеру?
Ну, давайте посмотрим.
Пу-пу-пу.
27.
Один умный указатель весит 8 байт, а другой умный указатель весит 16 байт. Почему так? Как вы думаете?
Всё, на самом деле, довольно просто. Дело в том, что ответ кроется здесь. Смотрите,
вот представьте, что должно произойти, в случае, если у меня тут в качестве дилитера выступает
указатель на функцию. Могу ли я просто так взять и создать указатель на функцию? Нет, не могу. Но
смотрите, в чём дело. Когда я использую обычный класс, я объект этого класса могу создать сразу в
деструкторе и сразу же его вызвать. То есть, мне нет необходимости хранить объект этого класса.
Понятно? То есть, я могу здесь же его создать и сразу же его вызвать. Понятно? Понятно? Нет. А что
происходит, когда я передаю указатель на функцию? Смотрите, я обязан этот указатель на функцию где-то
сохранить. Согласны? Если я его передаю в конструктор, то я же не могу просто так взять и по указатель
на функцию понять, что она делает. Вот здесь, по типу класса, я сразу понимаю, что должны делать
объект этого класса, потому что это всё находится внутри метода. Когда я передаю указатель на
функцию, по указатель на функцию у меня нет никакого шанса понять, что делает эта функция. Но я понимаю,
что эта функция возвращает void и принимает int указатель. Всё. Чтобы понять, что она делает,
я должен передать ей второй аргумент. То есть, я должен передать саму функцию. А где хранится эта
функция? Понятно дело, что эта функция или этот указатель на функцию должен храниться непосредственно
в поле этого класса. То есть, я должен дополнительно в конструкторе, вот здесь,
то есть, я должен уникptr, то есть, я должен тут сохранить сам указатель и более того,
должен сохранить сам deliter. То есть, я должен сохранить в поле ptr и ещё должен в отдельное поле deliter
сохранить переданный deliter. Понятно? То есть, когда я передаю указатель на функцию, я обязан самому
эту функцию, точнее, сам вот этот указатель, сам адрес этой функции, должен ещё дополнительно хранить.
Если я использую обычный класс, то я объект класса хранить не должен. То есть, я могу просто создать
его внутри деструктора и сразу его вызвать. Всё. И поэтому в первом случае, когда я передаю класс,
у меня сам указатель весит 8 байт, ну, собственно, сколько весит обычный указатель. А в втором случае
у меня объект указателя весит 16 байт, потому что 8 байт у меня отводится под сам ресурс и
ещё 8 байт я храню функцию, которая меня что-то удаляет. И вот в этом, собственно, и заключается
преимущество использования вот таких вот классов, которые перегружают круглые скобки.
Окей? Всё понятно? Ну вот. Ну ладно, это такой, в общем, офтоп про правильно использование. В общем,
правильнее, если вам нужен кастомный deliter, то пишите свой класс, а не функцию. Ну и свой deliter
вам в задании, кажется, не надо будет реализовывать, поэтому можете расслабиться. Вот. Хорошо. Есть ещё
вопросы по уникальному указателю, по UniquePTR? Хорошо. Ну и теперь давайте перейдём к, ну попробуем
кратко хотя бы обсудить другой указатель, который называется sharedPTR. Значит, смотрите,
у нас был UniquePTR. UniquePTR — это умный указатель, который реализует семантику уникального
владения. Ну, от слова Unique. То есть, грубо говоря, вот это слово Unique, оно отвечает на вопрос,
что нужно делать в перекопировании. Давайте вспомним. Вот у меня есть умный указатель PTR,
и он указывает на некоторый ресурс. Я создаю копию этого указателя, и умный указатель,
точнее, уникальный указатель UniquePTR, мне вот это дело запрещает. А давайте теперь вернёмся к
изначальной идее, которая у нас была. Мы вроде как говорили о том, что когда мы копируем один
указатель в другой, у нас должен создаться другой умный указатель copy, который ссылается на тот же
самый ресурс. Да. Но мы говорили, что у нас есть проблема, которая состоит в том, что если у меня
несколько указателей, несколько умных указателей указывают на один и тот же ресурс, то возможно
проблема двойного удаления. То есть непонятно, кто должен удалить этот ресурс, вот этот PTR или вот этот
copy. Но теперь всё-таки давайте не будем закрывать глаза на эту проблему, а пробуем её решить. Вот эту
проблему решает класс SharedPTR, устройство которого мы сейчас обсудим и которое вам тоже нужно будет
реализовать в задании. Сейчас мы поговорим просто про алгоритм, про то, как там всё устроено. Ну,
смотрите, вопрос. Вот, допустим, в какой-то момент у меня вызывается деструктор для PTR. Должен ли я
удалять этот ресурс? Вот, да, смотрите, на данной картинке. Если у меня удаляется PTR, то есть я вызвал
деструктор для PTR, то в данном случае delete я вызывать не должен. Почему? Потому что на него
кто-то другой указывает. То есть если кто-то другой на него указывает, то значит этот ресурс кому-то
ещё нужен. Раз он кому-то ещё нужен, то удалять его рано. Окей, а теперь я удаляю copy. Нужно ли удалять
этот ресурс? Да, после удаления, то есть мы видим, что после удаления вот этого указателя на этот
ресурс больше никто не указывает. А раз на него больше никто не указывает, я могу спокойно вот эту
штуку взять и удалить. Остаётся, собственно, глобальный вопрос. Как внутри деструктора понять,
сколько объектов, точнее сколько указателей указывает на данный ресурс? Отлично. Давайте это обсудим.
Shared PTR. Значит, предлагается следующая вещь. Предлагается завести некоторое статическое поле static
size t к nt, которое будет хранить... что будет хранить? Количество указателей, которые указывают на объект,
ну по идее. Смотрите, в чём проблема. Дело в том, что со статик не прокатят. И вот почему. Допустим,
я объявляю Shared PTR, туда что-то передаю, создаю новый ресурс. То есть у меня есть PTR, который указывает
на некоторый ресурс. Так как я этот ресурс создал, то предполагается, что в конструкторе я сделаю
плюс-плюс к nt. В конструкторе. Такая идея. Ну хорошо, сделал плюс-плюс к nt, и у меня в статическом поле теперь хранится
единица. Хорошо? Как скажете. А теперь я создаю другой Shared PTR. B, который указывает на другой ресурс.
Ответьте ему, напишите, что вы думаете по этому поводу. Отлично. Ответьте за меня, пожалуйста. Так,
возвращаемся сюда. Я создал объект A. При создании объекта, я увеличиваю счётчик на единицу. Создаю
другой объект B, ну совсем другой. То есть тут свой, тут один new, тут другой new. Что у меня происходит при
создании второго объекта? knt увеличивается на 1. 2. А теперь что происходит дальше? Ну вот,
смотри, допустим, я написал это всё внутри одной функции. Что происходит дальше? У меня вызывается
деструктор для B. Так, хорошо, вызывается деструктор для B, и что я должен сделать со счётчиком? Уменьшаю
на единицу. Один. Потом меня вызывается деструктор для A. Счётчик уменьшается на нуля, и в этот
момент я удаляю объект. А с этим объектом что делать? Ну то есть, я так понимаю, ваша идея звучала
следующим. Деструктор должен выглядеть так. Вы делаете –- knt, и if knt равно равно нулю, вот в
этот момент вы должны сделать delete ptr. Кажется, я показал, что это не работает. Да, потому что если
вы храните статическое поле, то вот этот knt, он хранит общее количество умных указателей в мире.
Но при этом для каждого конкретного объекта вы не можете отслеживать. То есть мы же хотим
всё-таки для каждого объекта понять, что вот на этот объект указывает один, на этот объект
указывает один. Если вы храните общее количество объектов с shardptr, то у вас удалится только один
ресурс. То есть, когда у вас все shardptr закончится, у вас удалится только один последний ресурс, и всё.
А вот эти остальные, они останутся. Поэтому вы со статическим полем не угадали. Ну хорошо,
давайте не статическое поле. Ну, можно так, давайте попробуем вот так. Давайте попробуем избавиться от
статичности. Давайте я заведу обычное поле knt. Ну, которое будет хранить не общее количество shardptr,
а, скажем, внутри каждого shardptr будет хранить свой счётчик. Давайте так попробуем. Будет ли тут проблема?
Именно. Ну, смотрите, что происходит. Вот, допустим, у меня есть A. Изначально, когда я создавал A,
у меня счётчик A стал равным единице. Дальше я создал B с помощью копирования от A. Ну, смотрите,
если я копирую B от A, то, наверное, я понимаю, что раз тут единица, то я должен поставить двойку.
Ну и плюс я у A тоже могу поставить двойку. Согласны? Окей. А теперь я создаю C. Как я создаю C?
Ну, допустим, я создаю C от B. Что у меня происходит? Ну, я вижу, что в B хранится двойка, поэтому тут
хранится тройка, и у B тоже могу обновить двойку на тройку. А кто будет исправлять счётчик для A?
Ну, более того, если у меня на один ресурс указывает много-много E, F, G, H, если у меня на один объект
указывает много умных указателей, то при добавлении нового умного указателя мне нужно у всех них
увеличить счётчик на единицу. То есть мне нужно как-то по объекту уметь понимать, уметь находить
вообще все умные указатели, которые на него указывают. Но, кажется, это не решаемая проблема.
Возможно, решаемая, но кажется, что это слишком сложно. Согласны? Понятна проблема. Понятно,
почему вот так тоже нельзя. Беда. Ну, а оказывается, что правильное решение уже прозвучало. Повторите.
Ну, например. Да, давайте делать следующую вещь. Давайте внутри sharedPTR хранить... ну, давайте упрости.
Давайте будем хранить указатель на данные PTR и дополнительно будем хранить указатель на счётчик.
То есть давайте делать так. Для каждого объекта будем создавать свой счётчик. И будем хранить не
только указатель на сам объект, но ещё указатель на его счётчик. То есть смотрите, что я предлагаю.
Есть sharedPTR х, который создается с помощью newInt. Значит, внутри a мы храним указатель на сам
int, то есть на сам ресурс. И плюс дополнительно храним указатель на счётчик. Окей? Теперь, если я захочу
создать копию, копию это умный указатель, то что я должен сделать? Да, во-первых, этот указатель copy тоже хранит
внутри себя два указателя. Указатель на данные и плюс указатель на счётчик. То есть я беру и указываю на те
же самые данные. И плюс здесь указываю на тот же самый счётчик. То есть теперь у меня все объекты
ссылаются на один и тот же счётчик для каждого объекта. Да, ну и плюс, понятное дело, я тут должен увеличить на два.
И всё, и все проблемы решены. Когда я копирую a в копе, копе сохраняет указатель на этот счётчик и плюс этот счётчик
я увеличиваю на единицу. И теперь изменение этого счётчика видят вообще все объекты. Понятно?
А вот так делать нельзя. Сейчас мы это обсудим, да, но давайте пока просто, чтобы все понимали, что происходит.
Значит, если у меня a, b и c, a, b, c, d указывают на один и тот же ресурс, то картинка выглядит следующим образом.
Во-первых, они все указывают на один и тот же ресурс, а во-вторых, у них внутри хранится указатель на один и тот же счётчик.
То есть они дополнительно ещё хранят указатели вот сюда. И все они видят одно и то же значение.
Окей? То есть теперь давайте напишем хотя бы деструктор. Как должен работать деструктор? Ну, очень просто.
Ну, тут у меня называется кнт поле, давайте так его будем обозначать. Я делаю минус-минус разыминованный кнт.
Чтобы удалить указатель, я должен сказать, что всё, я пошёл пока уменьшить счётчик.
А дальше что я делаю? Да, смотрите, если счётчик не обнулился, то в принципе всё. Я заканчиваю работу и ничего не делаю.
То есть вот эти ресурсы должен удалить за меня кто-то другой. А если счётчик обнулился, то есть если кнт стал равен нулю, то в этот момент я должен выполнить некоторую работу.
Ну, в частности, я должен сделать delete от ptr и более того, я должен сделать delete от кнт. То есть я должен удалить не только ресурс, но и счётчик. Понятно?
Ну, вот, собственно, примерный алгоритм того, как должен работать shared ptr. То есть помимо того, что мы выделяем ресурс для самого объекта, мы ещё должны...
Да, ещё надо не забыть, что в конструкторе shared ptr, если мы создаёмся от нового указателя, то нужно ещё дополнительно выделить память под указатель.
Счётчик, точнее. Понятно?
Так.
Да, да. Да, то есть вопрос из зала был ещё вот такой. Ну, смотрите, мы же, ну, понятное дело, что можем делать так.
То есть ещё раз, shared ptr a, допустим, new int. Ну, и понятное дело, что, скажем, кошерным способом создавать новый указатель на тот же объект является вот такой.
Ну, а вы можете возить вопрос. Ну, смотрите, ну, я же могу сделать вот так. shared ptr c, ну, нет, b, и передать сюда, например, a точкой get.
Ну, get возвращает указатель, который лежит. То есть вот этот самый указатель вот на этот ресурс. Что в этот момент произойдёт?
Ну, вот так, короче, делать нельзя. Если вы сделали вот так, то есть если вы создали shared ptr на сурой указатель, который уже лежит в каком-то умном указателе, то вы как бы сам дурак.
В общем, вот так делать нельзя. Единственный способ, с помощью которого может создавать shared ptr, это вот так. new что-то что-то.
Ну, или где-то сделать, ну, короче, давайте так, давайте договоримся вот так. Что-то нужно делать вот так, а передавать сюда уже какой-то другой указатель нельзя.
То есть вы создаете shared ptr только от нового указателя, либо от какого-то уже существующего shared ptr.
У unique ptr, кстати, тоже такая проблема есть. Мы этого не обсуждали, но вообще говоря, вам никто не запрещает сделать, например, вот так.
After p равно new int и сделать вот так. std unique ptr от int ptr от p и std unique ptr от int ptr2 от p.
То есть в принципе никто вам так не запрещает сделать, но проблемы вы видите.
У вас и вот этот unique ptr, и вот этот unique ptr указывают на один тот же ресурс. Ну и тут уже как бы двойной delete неизбежен, поэтому вот так делать нельзя.
То есть умные указатели, то есть мораль в чем? Умные указатели вы можете создавать только от выражения new, либо от других умных указателей.
Все остальное вот в таком духе приводит к undefined behavior. То есть вот так пользоваться умным указателям нельзя.
Так, ну и осталось 5 минут, ну давайте еще один момент связанный с shared ptr обсудим.
Все остальное обсудите на семинарах, ну и там в задании кажется довольно подробно.
Все остальное описано. У shared ptr есть одна проблема.
И вот какая.
Представьте себе, что у вас есть объект a, и у него в качестве поля есть shared ptr.
Ну а здесь допустим хранится какое-то значение int.
Ну допустим вы пишете, не знаю, двусвязанный список.
Ну давайте так, ну неважно вообще какой список, ну просто у вас есть умный указатель и int.
Есть другой объект a, в котором тоже есть shared ptr и int.
Ну и представьте себе, я сделал следующую вещь.
Здесь я вот этот shared ptr указываю сюда, а вот этот shared ptr указываю сюда.
Ну вы можете спросить, как такое может вообще произойти?
Ну на самом деле очень просто.
Если вы пишете двусвязанный список,
у вас же тут есть next,
у вас тут есть prev,
тоже next,
есть prev,
ну и тут value.
Если вы пишете двусвязанный список, допустим на умных указателях,
у вас может возникнуть соблазн и написать его на shared ptr.
Ну и что делаете?
Вы next указываете сюда, а prev указываете вот сюда.
И у вас возникает вот такой вот цикл.
Один узел указывает на другой узел, а второй узел указывает на первый.
В чем тут проблема?
Ну давайте вот на этой картинке.
Что тут не так?
Ну да, смотрите.
Вот допустим я храню...
Во-первых, понятное дело, что вот такая вот картинка,
она никогда не удалится.
Почему?
Потому что количество указателей, которые указывают на этот объект,
равно единице.
Количество указателей, которые указывают на этот объект,
тоже равно единице.
То есть у вас получается...
То есть у вас получились такие циклические ссылки.
То есть один объект ссылается на другой,
но при этом внешних указателей на них нет.
То есть такая самостоятельная структура,
которая будет вечно висеть в памяти.
Понятно?
Так вот, чтобы решать такие проблемы,
в стандартной библиотеке C++ есть,
помимо shared ptr,
есть еще и слабый указатель,
Vicptr.
Vicptr, это умный указатель,
который
не учитывается
при подсчете ссылок.
Короче говоря,
если вы реализуете...
Давайте тут нарисую
досвязный список.
Ну, у вас тут есть указатель head,
то есть голова списка.
Есть tail, хвост списка.
И тут у вас есть указатель на next.
Вот если вы заведете shared ptr в обратную сторону,
то у вас возникнет вот такая проблема
циклических ссылок.
Так вот, чтобы такой проблемы не возникало,
предлагается вот здесь
вместо shared ptr использовать Vicptr.
Vicptr, как тут написано,
они не учитываются при подсчете ссылок.
То есть вот на этот объект указывает
две ссылки,
вот на этот объект указывает
одна ссылка,
вот на этот объект одна ссылка,
на этот объект указывает две ссылки.
Вот эти ссылки не учитываются.
Теперь все работает нормально.
Теперь когда у вас будет вызван
деструктор для списка,
Удалите вот этот указатель и удалите вот этот указатель.
Когда удалится вот этот указатель, число ссылок на этот объект
станет равно мяде.
При että число ссылок на этот объект стало равным нулю,
что для него будет вызовано?
Деструктор.
Для него вызвали деструктор.
Так как для него вызван деструктор, то число ссылок на» этот объект
станет равным нулю.
Ну и так далее.
Все.
И никакой проблемы.
проблемы. Понятно? Вот. Тут есть еще одна проблема
связанная с wik.ptr. Дело в том, что если у вас есть
какой-то ресурс, и представь себе, что на этот объект
есть сильная ссылка shard, и еще есть wik-ссылка.
Вот здесь есть проблема, которая заключается в том, что если вдруг вот эта сильная ссылка умерла,
то она за собой дополнительно удаляет как ресурс, так и счетчик.
И теперь, когда вы попытаетесь использовать вот этот wik.ptr,
вы будете ссылаться на уже удаленные выказатели и на удаленные счетчики.
И в этом проблема. Но эту проблему, видимо, обсудите на семинарах,
или на следующей лекции начнем с этого и перейдем к следующей теме.
На сегодня все. Спасибо.
