давайте начнем так сегодня я думаю наверное всю лекцию будем доказывать кодировая ну в общем
теория мукели давайте так вы помните я сформулировал теория мукели нет и формулировал
да да да кажется сформулировался таки да значит у нас получается число деревьев
без учета без учета изоморфизма
ну то есть мы считаем что изоморфные деревья но различные изоморфные деревья они то они мы считаем
их различными второй подход когда мы склеиваем все изоморфные деревья считаем их одинаковыми да
тогда там совсем другое число получается вот число без учета изоморфизмов на n вершинах
равно n степени n-2 доказательства собственно через кодирование прюфера идет я вот давайте
я тогда я просто в конце лекции я просто примеры дал кодирование кодирование алгоритм я только
так на словах описал давайте я запишу этот алгоритм алгоритм кодирование прюфера
да осмотреть
отрицаем на каждом шагу на каждом шагу ищем лист с наименьшим номером
и усекаем его давайте так коротко напишем в код пишем номер вершины вот на таких вершинах
все-таки нужно написать 1 1 2 n код пишем номер вершины с которой лист был соединен
вершины с которой этот лист был соединен ребят если вы не заметили но я правда только вчера
вечером это сделал я ну я как я говорил вам я веду я веду уже сейчас пишу программу ссылки
все делаю заранее да все загружаюсь ссылки делай заранее чтобы потом не делать очень много
работы получается когда нет досок у тебя так ты быстро по доскам смотри я бы так бы программу
составлял быстро по доскам смотрел доски там я писал все слова которые произношу на них вот и
по доскам там понятно что я там прочел что я там очень быстро все составлялся когда вот так досок
нет непосредственно отдельно выписано содержание лекции нет приходится это просматривать получается
долго поэтому я решил сразу делать просто вот по ходу по ходу чтения и я выложил новую версию
который буду обновлять постоянно то есть новую лекцию прочитаю добавляю ссылку добавляю тот
материал который прочитал так далее обновляю там у себя текущую версию нужно еще наверное
троечный список начинать составлять чтобы это было больше времени как говорится на дискуссию
простой непростой вопрос и так далее может кто-то забыл потому что сходу смотришь этот троечный
список иногда потом на экзамене вспоминаешь наверное нужно было еще это добавить как нужно
заранее просто продумывать это так код пишет номер который этот усеченный лес был соединен
а критерии остановки
осталось одно ребром
одно ребро его никуда не пишу она никуда не пишется
так это алгоритм кодирования алгоритм декодирования
почему я должен я хочу написать вот так полностью потому что мы должны свойства этих алгоритмов
доказывать для этого нужно ну вот четко обозначить что это за алгоритмы на каждом шаге так начало
есть код длины код длины
n-2 а 1 2 составляем две последовательности а внизу приписываем числа от 1 до n
вот алгоритм шаг алгоритма ищем наименьшее ищем наименьшее число внизу который отсутствует
вверху который отсутствует вверху
запих потом записываем записываем
пару первая позиция кода
а во второе слое во второе найденное число
и вычеркиваем найденное первую позицию пары первую позицию куда и вычеркиваем
обе обе соединенные но обе обе оба числа пары вот так
сверху и снизу соответственно первую позицию пары снизу вторую позицию пары
ну что ж
критерии остановки собственно шаг такой вот у нас есть две последовательности вычеркиваем и
ищем наименьшее номер числа внизу который отсутствует вверху вычеркиваем соединяем
их в ребром вычеркиваем критерии остановки не осталось ни одного числа в коде вверху
числа вверху не осталось ни одного числа вверху
последние два числа которые остались соединяем в ребро и заканчиваем
последние два из числа два оставшихся числа
внизу числа
пишем в пару соединяем пару и заканчиваем соединяем пару
ну ребят на самом деле чисто формально что нужно проверить код прюфера по сути это
любая последовательность из чисел любая последовательность такая что для любого
и от единички до н-2 находится между единичкой n есть код прюфера да может служить кодом прюфера
потому что декодировать можно любую последовательность так смотрите но в принципе
что нужно проверить нужно проверить что тот последовательность ребер который смотрите ну во
первых да какие вещи нам надо доказать вот если коротко давайте просто пока перечислим что надо
доказать может служить кодом прюфера
но надо доказать первое что процедура декодирования обязательно декодирует именно дерево
это важно декодирование создает дерево а то вдруг есть такой код который мы декодируем
от дерева не получится что это дает смотрите у нас есть множество давайте коротко сейчас я поясню
вот есть деревья деревья вот коды прюфера нам нужно показать что любой код можно их декодируется
именно в дерево потом что что ли у них что нет двух разных деревьев которые декодируется
кодироваться были кодировались бы в один и тот же код прюфера это даст доказать докажет
инъективность отображение дерева код прюфера так а есть идти и третье да вот это это инъективность
так первое второе значит нет давайте так нет двух кодов
которые декодируется в одно и то же дерево двух разных кодов это функциональность как раз правда
двух разных кодов кодирующихся в одно и то же декодирующихся в одно и то же дерево
ну хорошо не декодирующие в котором соответствует одно и то же дерево давайте так может быть не по
алгоритму а может быть по какому-то другому нет ну в принципе тут подекодировали декодирующихся
именно то есть разные коды взяли декодировали а получилось одно и то же вот может почему
такого не бывает давайте докажем декодирующиеся в одно и то же дерево
ну и третье нет двух деревьев которые которым бы соответствовал один код прюфера нет двух
деревьев двух разных деревьев в котором бы соответствовал один код прюфера
это я это как раз доказывает сюрреактивность это доказывает функциональность это доказывает
ну смотрите то что мы описали процедура кодирования это вот отображать строить
отображение значится деревьев новостей кодов вот эти две штуки доказывают соответственно
функциональность сюрреактивность канадичек процедуру декодирование которое ну это же
обратное отображение на самом деле это чисто говоря вот как раз вот первое утверждение это как
раз часть доказательства того что это обратное отображение ну то есть декодируется именно
дерево и второе что надо доказать но вот это вот и не хочу чисто формально проделывать что
смотрите если мы возьмем код построим дерево мы доказали что докажем сейчас что что построится
именно дерево а потом это дерево мы закодируем то получится тот же самый код нужно это же
проверить правда ну что это обратное отображение то есть мы действительно получаем некое дерево
у которого код вот такой в этом же с процедурой декодисуть процедуры заканчивается заключается
правильно так ребят вот эту вот часть я не хочу проявить потому что это непосредственно но
видите алгоритм декодирования если разобраться он как раз строит именно именно это то есть он
строит что мы делаем на каждом из шагов а ребят мы ищем лист с наименьшим номером вот здесь вот
перечисленные вершинки нашего дерева мы ищем а вот здесь просто те те вершинки с которым листы
были соединены на каком-то шаге вот первая первая позиция это то номер вершины с которой был
соединен первый отсеченный лист правильно ребят соответственно мы должны найти здесь вершинку с
номером с наименьшим номером которые здесь нету ну лист не никуда не запишется правильно в коде
поэтому ищем вершинку которая здесь нет с наименьшим номером и соединяем ее своего условно с
вот этой получается вот то тот тот то самое усеченное ребро на первом шаге потом на следующем
шаге на и так далее понимаете да ребят то есть действительно вот эту часть не хочется просто
описывать довольно муторно писать что это действительно обратное отображение а это доказывает как раз
сюрррективность индиективность мы вот отдельно проверим при активность доказывается при помощи
катапроцедуры декодирования получается есть между когда деревьями а значит у них одинаковое
количество элементов а кодов можем посчитать их два инских и хен степени на минус 2 вот в этом
доказательство заключается то есть нам нужно установить три вот эти вещи давайте по очереди
так что и стиралки тут нет что ли но и че ее мое
вот нет первой не сюрррективность первой корректность просто доказывает
второй но второй у нас что разные коды это инъективность вот это вот сюрррективность
а вот это
то та процедура которую мы описали что на корректно корректно в том смысле что она
создает дело обязательно а сюрррективность все правильно третья сюрррективность да да это
сюрррективность корректность декодирования да ой ой парадон парадон господи извините это
не активность да не активность ребят поэтому собственно извините прошу прощения что я так
много путаюсь вот это как раз последствия праздников в том смысле что на самом деле
вот вот эти майские не майские а вот мартовские праздники февральские это кошмар для преподавателей
знаете почему потому что это еще середина семестра и переносить сгорают занятия их нужно
переносить их нужно компенсировать это переработка полнительная вот у меня была
такая компенсационное занятие сейчас на этой неделе я сейчас видите совсем уставший я могу
поправляйте меня пожалуйста это функциональность к майским праздникам таких претензий нет потому
что там некуда переносить там уже все там уже сессия она просто сгорает а компенсировать нет уже
пространство для маневра времени нету все вот то просто корректность называется это
сюррективность доказывается при как я сказал при помощи тотальность процедура кодирования ну
каждому дереву соответствует код процедура кодирование описывает а сюррективность
доказывается при помощи вот как раз проверки корректности декодирование декодирование
строит по коду дерево и собственно нужно еще дополнительно проверить что это действительно
обратное отображение понятно вот то есть корректность это часть доказательства сюррективности
вот ну давайте докажем один вот эта часть я не знаю даже на какой источник сослаться потому
что во всех книжках эти эти вещи не доказаны сразу говорю я обычно ссылаюсь к нас что-то
потому что я бы больше нигде них ни в каких книжках это не нашел вот обобщим доказываем
утверждение сейчас будет вот что доказываем утверждение в такой форме которая там сформулировано
это трудно доказать вот чуть обобщая легко уже получается смотрите данные последовательности
последовательности значит а 1 а 2 а к-2 б 1 б 2 б к-2 б к-1 б к теперь условия давайте
записывать ограничения где а это для любого и от единицы до к-2 а это находится в пределах
между единичкой нет этот вот какой-то наш параметр вот сло вершин у дерева а к у нас
бегает в пределах от единички до дат единички до нет нет нет нет нет нет нет нет нет единички
тройки получается. Ну, чтобы-то минус два было хотя бы единица. Вот. А тройки до...
Что выходит? n-4, да? Ой, до n. Чтобы самое длинное было n-2. Так? Вот. Дальше. Запишем это вот так.
Внизу последовательность упорядочена по возрастанию. Причем они попарно различны.
И еще одно слово. Догадайтесь какое. Понимаете, к чему я это пишу? Смотрите, это вот то, что
получается на каком-то промежуточном шаге в процессе декодирования. То есть последовательность
не обязательно подряд идущих чисел, но упорядоченных по возрастанию внизу. Число чиселок внизу на два,
больше, чем число чиселок вверху. Все эти чиселки вот в таких пределах заключены. Что еще нужно потребовать?
Это здесь предполагается, это есть. Что числа вверху все лежа, все находятся среди чисел внизу.
Все числа, все числа а1, ак-2 лежат среди b1, bk.
Ну а bt это же не подряд числа. Смотрите, на каждом промежуточном шаге вначале это верность.
Здесь числа от 1 до n, тут все числа аi среди нижних чисел присутствуют. Когда мы начинаем
вычеркивать, то же самое остается. Все числа вверху будут среди чисел внизу, поэтому нужно
это зафиксировать отдельно. Даны вот такие последовательности с такими условиями. Я, наверное,
это стирать сейчас не буду, нужно потом будет ссылаться, я не хочу это переписывать. Нужно
доказать, что процедура декодирования по этим двум последовательностям создаст дерево.
Что процедура декодирования по запущенной на этих двух последовательностях запущенная.
Это промежуточный итог шагов этого алгоритма. На самом деле так проще. Я рассуждение вам
поясню. Процедура запущена на этих последовательных стихах. Создать дерево.
Смотрите, проще по доказательству пояснить, почему это действительно нужно именно так обобщать.
Проблема в необходимости вообще не возникает вот в каком месте. Логично на самом деле доказывать
подобное отвратение индукция ПН. Но если вы просто чисто логически сделаете первый шаг,
алгоритма, создадите одно ребро и вычеркните последовательности, то получится уже корявая
последовательность. Если вы сформулируете утверждение для последовательств вверху какое-то,
а снизу подряд идущие просто, то этого нарушится на следующем шаге. И предположение индукции
применить к этому уже не получится. Поэтому лучше сразу сформулировать для промежуточного
итога работы, тогда там предположение индукции применимо. Так в длинной последовательности на
каждом шаге уменьшаются. И это число вершин дереве. В данном случае вот эта процедура
декодирования по этим последовательностям создаст дерево на вершинах с номерами Б1,
Б2 и так далее до БК. Если запустить декодирование по вот этим двум последовательностям,
то будет создано дерево на вот этих вершинках внизу перичисленных. Смотрите, индукция ПК
БАЗа каравна единица, каравна тройки, самая маленькая тройка. Да, ну нет, конечно,
перебор некий нужно сделать. Но внизу А1, вверху Б1, Б2, Б3. При том, что Б1, Б2, Б3 в пределах от 1 ДН,
а А1 тоже в пределах от 1 ДН. И А1 встречается среди Б1, Б2, Б3. Совпадает с одним из,
совпадает с одним из Б1, Б2, Б3. Вот, смотрите, но случай один. Ребят, давайте. Случай один,
а один совпадает с Б1. Тогда процедура декодирования найдет Б2, это самая маленькая,
которая отсутствует вверху, и соединит А1, Б2. Тогда декодируется такое, тогда декодируется такое.
Следующие ребра. Значит, А1, Б2 и Б1, Б3. Ну, как бы он вот соединит вот эти два в ребра,
их вычеркнет, остальные из оставшихся двух создаст ребро. А1 равно Б1. И у нас декодируется
такая цепочка. Б2, Б1, Б3. Дерево. Второе. А1 равно Б2. В таком случае самая маленькая внизу,
которая отсутствует вверху, это Б1. И ребро будет первое, А1, Б1, а второе, Б2, Б3. Так.
Декодируем А1, Б1 и Б2, Б3. А1 это Б2. Ну и получается Б1, вот такая цепочка.
Б1, Б2, Б3. Тоже дерево. Так. Ну и третий случай А1 равно Б3.
Тогда декодируется А1, Б1 и Б2, Б3. А1 это Б3.
Ну то есть вот такая цепочка в итоге получается. Б1, Б3, Б2. В любом случае,
во всех трех случаях, получилось декодировать именно дерево. Окей.
Ну не знаю, на самом деле можно было просто написать, остальные случаи рассматриваются
аналогично, как любят писать. А вот без ограничений общности мне трудно тут представить, чтобы это
как-то без ограничений общности было. Просто так же рассматривается. На самом деле я показал все
три случая, чтобы вы наглядно представили, как это все работает. Хорошо. На букве нам так
сказать уровень. Смотрите. Дальше. Переход. Пусть утверждение доказано для K.
Рассмотрим любые две последовательности. Значит, А1, АК минус 1. Я так понимаю,
Б1, БК минус 1, БК. БК плюс 1. Ну с такими условиями, что для любого Я, от единички до К
минус 1, АИТ и до Н. От единички до Н. Так, что там еще? Что К не превосходит Н и больше
либо равно, чем два, наверное. Скоро тут К минус 1. Вот. Ну и Б и Т упорядочены по возрастанию.
Ну и еще А1. А1, АК минус 1. Все содержатся среди
B1, BK плюс 1. Ну смотрите, что мы сделаем.
Ну и делаем стандартный шаг алгоритма. Ищем внизу число, которое отсутствует вверху,
наименьшее. Ну пускай это БЖТ. Пусть БЖТ, наименьшее число, число внизу, отсутствующее сверху.
Тогда мы нарисуем А1, ребро А1 БЖТ и вычеркнем. Вот тут БЖТ, вот тоже вычеркиваем. Смотрите,
вот эти новые получившиеся последствия, они не единичку короче. Что было куда укорачивать,
как говорится, от трех. На единичку короче, они удовлетворяются тем же условиям. Опять же,
все А1, А2, АК минус 1, они все в нужных пределах лежат. Это упорядочно по возрастанию.
Низняя последовательность. И все верхние чиселки лежат среди нижних чиселок. Значит,
мы можем к этому предположение индукции применить. И тогда оно говорит, что мы построим дерево.
Правильно? Предположение индукции. Строить дерево. На вершинах
Б1 меньше БЖ минус 1, меньше БЖ плюс 1. На к вершинах.
Предположение индукции. По декодированию построено последствия ребер, которые складываются
в дереве. На вот таком наборе вершин. Хорошо, теперь смотрите. Возвращаем вот этот лист удаленный.
Вернее, я сразу сповернул. Нужно доказать, что это еще лист. Но это лист. Почему? Потому что
А1 среди вот этих штук есть. Обожитого нет. То есть мы, возвращая вот это ребро,
от существующей в дереве вершины проводим ребро в той вершине, которая доселе в этом
дереве не присутствовала. Поняли? Поэтому это снова дерево. Поняли? То есть смотрите,
А1 среди вот этих штук есть. По условию. Обожитого нет. Мы так искали. Его нет среди этих. Поэтому
когда мы добавим вот это ребро, мы соединим вот эту вершинку А1, которая уже была в дереве,
с вершинкой, которая в дереве отсутствует. Получается лист новый. Просто мы к дереву
добавили, нарастили лист. Получилось снова дерево. Понятно? Вот. Ну вот, собственно,
предположение индукции доказано. Просто долго записывать. Извините. Вот это все. А вот теперь вы
наглядно представляете, как эта процедура работает. Смотрите. Да. Вот последовательность.
Смотрите. Если мы начнем декодировать с начала, то мы конечно строим некую последовательность ребер,
но тут нужно смотреть на самом деле с другого конца, как говорится. Если вот вы раскрутите до
начала все и возьмете, с последнего двигаться будете к первому, с последнего к первому,
то вы по очереди будете наращивать лист-лист-лист. Получается новый каждый раз дерево.
А если вот с начала до конца, то не обязательно вот они так прям станут. Понимаете в чем дело? То есть
нужно... Секрет заключается в том, что вот этот вывод декодирования нужно обернуть задом наперед,
и тогда вы подряд, добавляя каждый раз ребро, вы будете каждый раз получать дерево. Вот. Все
понятно сейчас, нет? Вот. На этом следующее доказательство, собственно, основывается. Вот.
Вот здесь давайте. Очень легко после вот этого доказывается то, что двум разным кодом не
бывает двух разных кодов, в котором соответственно одно дерево. Смотрите, как это доказывать. Второе. Пусть
есть два разных кода. Разных кодов. Прюферы, которые декодируются в одно и то же дерево.
Ну что тогда? Тогда, во-первых, длины кодов одинаковые. Догадаетесь почему? Да, длина кода это
количество вершин в дереве минус два. Это, ну как задается, количество вершин в дереве, раз им
соответствует одно и то же дерево, то у них длины одинаковые. Так, давайте кодов одинаковые длины.
Одинаковые. В смысле, одинаковые по определению заморфаны вообще-то. Ну, еще раз. Изоморфные. Нет,
просто в одно и то же. Не в изоморфные, в одно и то же. Ну, а если они различны, то разные деревья. Мы
считаем это разные. Вот кодирование Пруфера это различает вообще-то. Кодирование Пруфера дает
разные коды двум изоморфным, но различным деревьям. Поэтому здесь именно имеется
в виду одно и то же. Именно прям вот одно и то же. Не изоморфные они там. Вот. У этих кодов одна
и то же длина. Одинаковая длина. Так как она равна числу вершин дерева минус 2. Одно и то
же дерево на N вершинах давайте. На N вершинах. Ну, смотрите. Вот пусть первый код. Есть второй код.
Они разные. Ну, пусть T. Наименьшее. На меньшее число. От
одного до N минус два. Такое что? Любовь I от единички до T. 1 равно I T равно B T. Ну,
короче говоря, это так называемые совпадающие префиксы вот этих кодов. Ну, они разные. Значит,
до T позиции они совпадают, а вот дальше идут разные. Идет самая первая позиция,
на которой цифры стоят разные. Правильно? То есть у нас давайте. Наименьшее такое, что не равно,
наоборот. А, да, равно. А T плюс 1 не равно B T плюс 1. Ну, что мы будем делать? Смотрите,
ребята. Ну, давайте запустим процедуру декодирования и докрутим ее до этого шага.
Она построит последовательность одинаковых ребер, потому что начало одинаковое. Ну, по идее,
мы должны, у нас в принципе есть предположение, что у нас строится одно и то же, да? Ну, вроде так.
Так, ну, хорошо. То есть в чем идея? Я хочу вычеркнуть вот это начало. Просто совпадающий
начало убираем и предполагаем, что они прям стартуют с различных двух позиций. Почему тогда все плохо?
Ну, по нашему предположению же все это декодируется в одно и то же, да? Так? Значит,
процедура декодирования, значит, процедура декодирования на первых T шагах,
T шагах. А, извините, T наверное все-таки вот так нужно. Наименьшее. Ну, наименьшее. Ну,
то есть до этого все одинаковое, начиная с этого момента идут различия. Это тот момент,
с которого начинается, после которого начинаются различия. Вот так. На T шагах создаст одни и те же
ребра, да? На кодах A n-2 и B 1 B n-2 создаст одни и те же ребра.
Где, где, где? Почему наименьшее лишнее? Еще раз, почему? Я не понимаю вас.
Их может быть много. Нам нужно одно выбрать. Ну, как же, если последствия разные, то в каких-то
мы позициях различия будут, но может быть несколько позиций. Выберем самое маленькое по номеру.
Так, теперь я вас не понимаю.
Таких T может быть много. Нам нужно выбрать одно. Выберем самое маленькое. Если вы не самое маленькое,
то мы не можем утверждать, что до T все одинаковое, просто не сможем. Ну, а нет, от единички до T. Ну,
и что? Нулевой позиции у нас нет, понимаете? Почему от нуля? Потому что может начинаться
различие с самой первой позиции. А, сейчас. Нет, именно наименьшее. Вот, на T плюс первая разность,
разная, разная. А на предыдущих? Вот, первое.
Вот, второе T, вот третье T. Я выбираю самое маленькое. Для любого и от одного до T. T в данном случае три.
От один, два, три совпадает. Тогда один, два, три совпадает, на четвертый не совпадает, на пятый
совпадает, на шестой не совпадает. Можем, если самое маленькое возьмем. Вот, T равно 3, вот T
на четырём. Пожалуйста. Ой, T равно 3. До трёх совпадающие позиции, на третий разные. Всё. Ну, и что?
Зачем на второй случай? Я не понимаю, не можем взять? Да, и что? Так, я не понимаю. Так, смотрите.
Вот одинаковые префиксы. Совпадающие префиксы максимальной длины, которые нам нужны. Всё. Нам
нужен максимальный префикс. А вот это вот мы как бы возьмём в оставшиеся закинем. Всё, больше
ничего нам не надо. Нам нужен префикс, самый длинный совпадающий общий префикс. Всё. Так.
Для T плюс 1, смотрите, мы создаём одинаковые ребра. А дальше вот что пошло. Дальше у нас процедура
декодирования. Ребят, обратите внимание. Процедура декодирования от T плюс 1 у нас пойдёт здесь от A N
минус 2. А вот здесь B T плюс 1 B N минус 2. Вот тут разные числа уже сразу идут. Но внизу, когда мы
процедуру декодирования, поскольку мы вычёркивали одно и то же, мы же одинаковые ребра строили. И
ещё префиксы-то пошли одинаковые. Поэтому мы вычёркивали одно и то же снизу-сверху. Внизу будут
одни и те же последовательности. Значит, вот уже на T плюс первом шаге алгоритм создаст разные ребра.
Потому что здесь вершинка и здесь вершинка разные. Может она соединит их с одним и тем же,
с одной и той же вершинкой, но второй конец ребра будет другой. Не всегда. Но зависит от того,
что вверху, что внизу, как говорится. Мы же ищем самое маленькое внизу, которое отсутствует вверху.
А вдруг оно одно и то же, а самое маленькое здесь и здесь. Ну и фиг их знает. Ну если переставить,
просто вот если два кода, в них циферки просто переставлены местами, то уже возникает такая
ситуация, что внизу и вверху отсутствует одно и то же. То есть разные ребра построены будут,
а значит разные деревья. Ну извините. Тогда надо вот так. Рассмотрим такое наименьшее.
Вот. Рассмотрим наименьшее. Удовлетворяющее тем, что существует два кода, для которых есть два кода.
Которые декодируются. Два разных кода декодируются в одно и то же.
Так. Ну в таком случае мы как бы сократили. Получился код поменьше, который декодируется
тоже в одно и то же. Противоречие с тем, что мы это наименьшее. Вот. Понятно, ребят? Здесь есть тонкость,
конечно. Тут опять видимо придется приписывать Б1Бкаты внизу. Да, ребят? То есть потому что иначе
вообще-то немножко не работает наше рассуждение, если здесь подряд одно ОДН. А вот тут же у нас
уже не подряд от ОДН, а какие-то возрастающие последствия. То есть нужно доказать, что для
двухпоследовательности они декодируются. Вверху разные, но внизу одно и то же. Да, более сильное.
Внизу одно и то же. И Н самая маленькая, возможно. Сейчас понятно, ребят? Вот. Ну, теперь давайте как
доказать, что нет двух деревьев, у которых один код приюфер. Пусть есть два различных деревья,
различных деревьев с одним кодом приюфера. Ну, как бы, тогда смотрите. Тогда получается,
что процедура кодирования нехорошая. То есть она кодирует в один и тот же код два разных
дерева. Ну, давайте проведем с этими деревьями. Пусть эти деревья... эти деревья. Т1 это 2. Ну,
смотрите, у них одинаковое количество вершин. Почему? Потому что, да, длина кода это количество
вершин у дерева минус два. Они на одном и том же... они имеют одинаковое количество вершин.
Вот. Кодируем их. Кодируем Т1, Т2. Получим последствия ребер.
Смотрите, Е1 для Т1. Это Е1, Е2, так далее. Еn-2. Это то, что... ну, и давайте Еn-1. Это
ребро, которое... ну, как бы... То есть, смотрите, мы сначала вычеркнем ребро Е1, потом ребро Е2,
потом, так далее. При кодировании то, что происходит. Понимаете? Мы режем ребра. Так. Ну,
вот записываем, какие ребра режем. Вот это ребро в конце, я так обозначу, оно не пишется в код.
Оно последнее осталось, и оно в код не записывается. Для Т2. Е1 штрих, Е2 штрих, Еn-2 штрих,
и последнее Еn-2, Еn-1 штрих, в код не записывается. При этом, понимаете, вот при такой
нарезке ребер у нас код одинаковый получился и там, и там. Но, смотрите, это же все ребра деревьев.
И вот это все ребра деревьев. Так. Ну, в код не пишется просто, я обозначил. При кодировании оно
не записывается, оно последнее осталось. Так, смотрите. Эти разные деревья, значит, есть разные
ребра. Что такое разный граф? Это граф, у которых есть в одном графе, есть ребро между двумя вершинами,
а в другом, а между этими вершинами, ребра нет. Вот просто критерии проверки. Что значит разный
граф? Конкретно две вершины на одном и том же множестве вершин, а это одного ДН. Значит, смотрите,
значит, вот эти разные ребра где-то здесь проявятся, то есть есть опять позиция, в которых расхождение
произойдет. То есть опять выберем наименьшее Т, для которого все одинаковые ребра идут, а вот над
этом месте разное. Т наименьшее от 1 до n-2, n-1 наименьшее. Такое, что для любого
и от единички до t-1, e1, e и t равно e и t штрих, но e t, соответственно, штрих не равно e t. То есть
все до этого совпадают, а на этой позиции разные. Вот все эти префиксы, весь этот префикс одинаковый,
а вот здесь разная. Помните, как мы вам доказали, что процедура кодирования такая, что вот это все,
все вот это вместе, все вот эти ребра с позиции до конца вместе образуют дерево.
Ну нет, если мы вот эти ребра начальные соединим, то они в дерево не обязательно
соединяться. Понимаете, мы можем изолированные ребра какие-нибудь получить, что-нибудь такое,
а вот с какого-то момента и до конца это дерево. Потому что так процедура работает,
мы каждый раз режем лист, понимаете, и то, что остается, является деревом, а там все оставшиеся
ребра. Получается, что мы, обратите внимание, ребят, вот этот префикс одинаково убираем,
у нас получается, если t конечно не ноль, а t не равно единицы. Нет, не на каждом шаге получается
дерево, на каждом шаге мы отрижаем лист. Если их сложить, вот эти дерево, если вот с какого-то
с любого момента начать и до конца взять, то получится именно дерево. Я вот это утверждаю,
а не сначала. Начальные вы можете префикс взять, сложить, там получится лес, вообще говоря,
но не дерево. На этом же доказательство корректности-то основывалось у нас,
что именно с начала с какого-то момента и до самого конца, если взять, то именно дерево
получится. А потом, если отмотать чуть-чуть назад, то мы добавим к этому дерево лист. Поняли?
Вот. Ну, то есть, если t не равно единицы, то мы получили противоречие с наименьшитью n, да?
Ну, то есть, смотрите, пусть есть два дерева, n наименьшее будем считать. Так-так-так-так-так,
я опять не написал, что n наименьшее. И наименьшим числом вершин. Да, именно, сейчас вот этот
случай я забыл рассмотреть, если t равно единицы здесь. То есть, начало различия начинается с самого
начала. Нет, в данном случае я корректно написал t-1. То есть, если t равно единицы,
то от единицы до t-1, короче, пустое множество. Для любого i из пустого множества, короче,
вот так. Тут выйдет, если t равно единице, то здесь будет квантор для любого i из пустого
множества. А он, как вы знаете, верен всегда. Но при этом с первой позиции у нас разница.
Вот, значит, смотреть. Наименьшее среди пар деревьев с таким свойством, ну, то есть,
у которого один код, одинаковым кодом. Видите, извините, я предполагал, что вчерашняя переработка
и моя усталость, кажется, сегодня, что я не смогу нормально, буду путаться и буду забывать
говорить важные вещи. Но спасибо, что поправляете. Ну, что тогда? Тогда у нас получается вот что.
Вот здесь давайте посмотрим, если t равно единице.
То е первое равно не равно е первое штрих. Сразу разница пошла. Ну, давайте тогда докажем в таком
случае, что мы и код на первой позиции разный получим. Почему? А нож на первой позиции, смотрите,
смотрите, пусть е1 это у1, в1, е2 это у1 штрих, в1 штрих. Ну, что у нас будет? Где вот это лист?
И вот это лист. Смотрите, если у1 не равно у1 штрих, то уже беда. Да неважно какие у нас там
листы. Мы же пишем вот эти номера вот этих вершин. Правильно? Они разные. Они разные. Поэтому
в код запишутся разные цифры. Запишутся разные цифры на первую позицию.
Спасибо.
Противоречие.
Ну, значит,
у1 равно у2, а листы как раз разные. Ну, опять тогда плохо получается, потому что мы же выбираем
лист с наименьшим номером. Но как бы получается, что в одном дереве у нас есть два разных ребра,
одно идёт, они идут из одного и уже у1, но в разные листы. Да, одно меньше другого.
Ну, то есть получается, что второй лист, наверное, не с наименьшим номером, да, у нас вышел.
Да.
Сейчас подумаем.
Тогда мы получается... О чём уходит тогда? Тогда уходит, что мы можем срезать эти два листа,
да, сократить количество вершин в дереве, а им будут соответствовать одни коды, да. Ну, как бы да.
Получается, если, значит, но тогда срезая листы в1 и в1 штрих,
получается два более маленьких дерева с одинаковыми кодами, противоречие.
Два более коротких дерева, более, два дерева, различных дерева. Почему они различны? Ну,
потому что там набор вершин даже разный. Ну, потому что там в1 штрих, здесь мы убрали в1,
здесь убрали в1 штрих, это разные вершины, там набор вершин разный. Два различных дерева на
n вершинах, на n-1 вершинах с одинаковым кодом. Опять противоречие. Вот здесь давайте вернёмся,
да, правильное замечание, я забыл рассмотреть случаи, когда у нас, значит, ну t равно 0, то есть
различия пошли в самом начале декодирования. То есть у нас в начале декодирования, в начале
декодирования два кода, у них уже 1 не равно b1, что тогда? Ну, тогда, смотрите, если мы,
ну мы ищем внизу наименьшие, вверху наименьшие, с таким свойством, что они,
но тут похоже что-то нужно сделать, правильно, да, как вы думаете? То есть нужно, ну предположим,
что они будут соединены в первый код и второй будут соединены с разными вершинами, что тогда?
Тогда мы коды, как бы, ну, как бы, смотрите, мы срезали коды, ну, давайте, как раз в 5 минут
закончим с этими доказательствами и это как раз, ну, по сути, это как раз теория Манафеева,
лекцию. Как вы видите, довольно тяжелая теория Манафеева. То есть,
ну вот это вот доказательства про декодирование, я просто забыл тут рассмотреть случаи, когда вот
эта разница пошла с самого начала, самая первая позиция различна. Смотрите, вот тут разные числа
стоят. Соответственно, оно должно декодироваться в одно и то же дерево, поэтому, ну, как бы,
смотрите, но ищем здесь, да и меньшие, которые отсутствуют вверху, пускай там, не знаю,
как это обозначить, а первое к первое, а здесь первое ко второе. Так, в таком случае, смотрите,
мы вот здесь срежем ко первое, здесь удалим ко первое внизу, а здесь удалим ко второе внизу. Так,
тогда у нас длины кодов последовательно сократятся, но внизу уже вот в первой
последовательности, во второй последовательности будут разные последовательности, может разные
числа вычеркнули, так, и мы сократим длины последовательности на единичку, противоречит
предположении на имельшести, правильно? Нет-нет-нет, оно декодируется в одно, то есть,
да, верно, да, так, так, так, так, так, так, так, то есть, мы, получается,
так, вот здесь я сейчас немножко, извините, наверное, нужно продумать, все-таки нормально
доказать на следующий раз, прошу прощения, давайте закончим, подумать надо здесь, вот это
вопрос интересный, сейчас, скорее всего, что-то очень простое, но я то, что очень устал, я не мог
особразить, вот, да, да, да, именно, именно, именно, в этом я понял, да, в чем проблема,
нужно подумать, почему так не бывает.
