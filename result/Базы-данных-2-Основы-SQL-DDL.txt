Более практическая тема. Будем знакомиться с основами SQL на более или менее конкретных примерах.
Посмотрим некоторые особенности того подможества команд, которые мы сегодня успеем затронуть.
Но давайте, наверное, хотелось бы начать. Вот с чего был на прошлой лекции вопрос по делению.
Давайте немножко вернемся на корреляционным операциям и начнем с повторения того,
что было с повторением деления. Более детального, что и разбора. Во-первых, немножко про нотацию.
Более или менее строго, если подходить к вопросу нотации реалиционной алгебры,
то она представлена на экране. Символьная запись более-менее общепринятая. Запоминать
по большому счету не нужно. Просто зачем приведена на экране табличка? Затем,
чтобы следующая формула была понятна. Формула формального определения деления.
Оно выражается через операции проекции, выборки и ряд теоретиков множественных операций.
Вот формальное деление можно определить следующим образом. Здесь у нас три теоретика множественной
операции и несколько проекций с ограничениями. Какого-то более или менее простого алгоритма
наверное предложить здесь не удастся. В конце того набора слайдов про деление,
который сейчас пойдет, там будет более простая формулировка того, что происходит при делении,
на что нужно обратить внимание. Но вот формально, полноценно это записывается,
операция деления. Определяется следующим образом, как показано на слайде. И соответственно,
теоретика множественных операций здесь три основных. Это построение декартового произведения,
исключение уже существующих кортежей из этого произведения и исключение из кортежей,
имеющихся потенциальными ответами того, что у нас получилось в первых двух действиях в скобках.
Так, хорошо, деление. Определение такое, посмотрим на конкретном примере. Допустим,
у нас есть два отношения поставщики и товары. Нужно найти всех поставщиков цена товаров,
у которых больше тысячи рублей. Поставщики, товары. Товары соответственно у нас два
соответствуют условия, это кирпич и цемент. Применим операцию деления. Собственно, что мы
будем делать? Мы будем делать следующее. Сначала мы для ответа исключим лишние данные из наших
отношений. Сделаем проекцию по поставщикам и по товарам, потому что нам нужны только
правильные идентификаторы поставщиков. Построим проекцию, которая нам необходима для первого
нашего действия. По формуле, там где у нас внутренняя скобка с цифрой 1 над знаком декартового
произведения, соответственно мы строим левый оперант этого произведения. Построим проекцию
по поставщикам, причем R1-R2. То есть мы исключаем, здесь происходит операция вычитания,
мы исключаем лишних поставщиков из отношений R1 по соответственно тем поставщикам, которые вошли в
отношение R2. Построим декартового произведения теперь. То есть совершим первое действие в наших
скобках. Вот результат мы видим на экране. Произведем вычитание, то есть совершим второе действие по
порядку. Что у нас получается? Соответственно вот результат виден тоже на экране. Вычитаем из
меньше таблицы большую. Вычитание у нас происходит, как вы должны уже знать, по совпадающим только
элементам. Соответственно тот факт, что у нас поставщики таблица более емкая, отношение более
емкое, ничего нам не говорит. Мы из первого отношения вычитаем только то, что у нас совпадает со
вторым. Получаем результат, соответственно, хлопнутая, уменьшенная таблица, измененные отношения
слева от знака вычитания множества. Ну, вычитание отношений, если вернее. Теперь мы строим проекцию,
чтобы нам получить правый оперант для третьего действия. У нас получается всего четыре поставщика
в данном случае. И мы соответственно этих четырех поставщиков, их идентификаторы вычитаем из
левого операнда, из проекции, которую мы построили в самом начале, поскольку у нас соответственно
таким образом получится правильный ответ. То есть мы вычитаем из всех потенциальных ответов
неправильные ответы и получаем исключить оставшийся один правильный ответ. Ну, грамостка получается,
на словах, наверное, не очень удобно это воспринимать. Оставляю это вам для изучения уже, может быть,
по слайдам более как-то постепенно, если кому будет интересно в своем темпе, что называется.
А то, на что собственно сущностно надо обратить внимание еще, это то, что деление в религационной
алгебре похоже на арифметическое деление. При построении декартового произведения частного
и делителя мы должны получить подмножество отношений делимого. То есть у нас результат
должен быть всегда, при его декартовом произведении с делителем, всегда должен давать подмножество
делимого м Ki подмножества исходного множества. Не обязательно мы построим,
обратив деление, совершив обратную опирацию, то есть она несимметрична в данном случае. Не
обязательно мы построим исходное множество, множество А вот как проведено на слайде. Но
мы точно получим подмножество этого множества. А если мы этого не получаем, соответственно мы
что-то пределение сделали неправильно. Надо пересмотреть наши шаги.
Также деление можно описать следующим образом, но, мне кажется, это то, вот
следующее это описание, оно не работает без того, чтобы я привел на предыдущих
слайдах, а предыдущие слайды, с другой стороны, не работают без вот такого
пояснения, более простого, наверное, потому что как-то вот выглядит это все
очень формально, но смысл довольно простой. У нас есть два отношения и
атрибуты, конечно, должны быть определены на одном и том же домене.
Результатом деления A на B будет отношение с заголовком из атрибута X и
телом, в котором входят кортежи
X из домена X, такие, что существует кортеж XY, который
принадлежит отношению A для всех кортежей Y из домена Y, из отношения B.
Тоже, пожалуй, грабостка, но смотрите, то есть, по сути дела, мы
пытаемся поделить совокупности наших строк, которые подходят нам
исходя из того, какой у нас делитель. Мы пытаемся на эти совокупности
срок поделить делимое и получить частное, которое будет содержать те
атрибуты, которые у нас были, собственно говоря, в исходном отношении, ну, по крайней
мере, под множество тех атрибутов. На этом я, пожалуй, оставлю вас с операции
релиционного деления. Может быть, на слух, повторюсь, это воспринимается не
очень удобно, но если вы хотите немножко так проникнуться, то просто посмотрите
пошагово на слайды, посмотрите, что, где происходит от одного действия к другому.
Но, как я уже сказал, деление операции производной, она хоть и выделяется среди
теоретикам, среди релиционных, но, по сути дела, она выразима через более простые.
Ну, и из того, что С на В принадлежит А в целом, понятен смысл.
Да, то есть, поэтому, раз сдаем, мы поставим точку с релиционной, наверное,
с операциями релиционной. Одну секунду, вопрос в чате.
Про квиз будет написано отдельно, ребята.
Так, а что дальше читать про позу Гресс-Кьюэль?
Смотрите, то есть, сейчас мы с вами переходим от теоретической, исключительно теоретической
такой части, к части практически, полностью практической, извините за
тавтологию, мы уже будем работать конкретно не просто даже с языком, но и
с конкретным его приложением, с конкретной его реализацией в СБД-Позгресс.
И поэтому, конечно, нужно определиться, на что нам операция, на что обращать
внимание. Ну, здесь, наверное, я думаю, вам уже на семинарах все это сказали,
даже предоставили какую-то, может быть, более детальную подборку литературы,
в зависимости от семинаристов. Я обращаю у вас ваше внимание только на
самые что ли такие важные источники, которые просто нужно иметь в виду,
только на
только на самые что ли такие важные источники, которые просто нужно иметь в
виду может быть для кого-то да может быть
может быть кто-то не успел записать на семинаре условно говоря вот повторяю на
лекции это в первую очередь конечно же документация документация хорошая
подробная исчерпывающая я более того есть официальная документация на русском
языке подготовленная пост-гресс профессионал компании это наши российские вендоры
поставляют на основе пост-гресса решения коммерческие соответственно
занимаются поддержкой большой вклад компания вносят в open source составляющие
пост-гресса и отдельные люди которые за ней стоят вставатели и топ менеджеры они
в принципе сами довольно давно в этом участвуют в поддержании open source ветки
пост-гресса что называется вносит туда какие-то дополнительные функции и
улучшают всячески помимо собственно до коммерческого решения и в общем это все
ну заслуживает доверия это прямой прямой адекватный грамотный перевод того что
написано на пост-гресс. ком да вот разделе documentation но единственное чуть-чуть чуть-чуть
запаздывает переводные версии во всяком случае в свободном доступе вот как вы видите сейчас
пост-гресс ql на официальном сайте есть версия 16 2 документации на сайте пост-гресс
профессионал документация только версии 16 точка 1 точка 1 даже вот так по-моему но тем не менее
там какие-то совсем для нас с вами очевидно незначительные изменения поэтому можно смело
пользоваться русскоязычной версией хорошо на сайте пост-гресс еще рекомендую вам раздел
образования там полезная информация ссылки всякие самое главное наверное что там есть это
во-первых демо база с по-моему чуть ли там не на гигабайт если ее скачать разархивировать то
есть там прямо можно посмотреть поиграться с каким-то реальными более менее запросами и
там есть несколько книг в открытом доступе разной степени сложности наверное что ли вовлеченности
у материала они тем не менее все равно не повторяет документацию то есть это такое надо
множество смыслов по сравнению с документацией что ли или нет под множество наверное да а
документация на гораздо более черпающие книги тем не менее неплохие даже хорошие даже отличный
в некоторых местах и ну все я просто не читал возможно они полностью от а да и отличный вот
допросят меня авторы если услышат тем не менее рекомендую для ознакомления по каким-то может
быть вопросом которые документация выглядит не вполне однозначно ну конечно интернет поисковые
движки места где люди обмениваются информацией по проблемам вопросом типа stack overflow конечно
же никто не отменял для общего развития также вот интервью вам рекомендую последний с иваном
панченко но довольно любопытный наверное если вы захотите чуть больше погрузиться в атмосферу что
ли разработки субботы окей поехали дальше собственно то о чем мы с вами поговорим сегодня
предметный плотно мы в принципе затронули это еще на прошлой лекции ну совсем кратенько совсем
чуть-чуть structure query language да sequel sql рассмотрим общую информацию и рассмотрим потом собственно
множество его команд ну какие успеем сегодня немного истории ну просто повторяю вот слайд
перед вами оставляю на обозрение мы видели в прошлый раз еще раз единственно заостряю
ваше внимание на последнем буллите что цитаты из статьи дональда чемберлина такой небольшая
совсем его даже заметка про суть по сути дела про историю раннюю историю SQL SQL SQL я буду
называть SQL сразу оговоришь да простят меня те кто любит говорить SQL и как вы видите да изначально
наберем намерение был довольно благородным и заслуживающим всяких участников всяческого
почрения разработчики хотели создать язык понятный для простого пользователя наверное сейчас
сказать что он что и запрос что язык SQL прям понятие для любого простого пользователя ну
это проблематично есть много нетрибиальных средств язык стал гораздо гипче и выразительнее
потому что тогда первоначальной статье он описывался буквально парой страниц основные
синтаксические конструкции сейчас стандарты многотысячные многотысячные страничные и
язык стал более гибким проявились процедурные расширения в зависимости от одного вентера
к другому и конечно появились возможности писать очень нетрибиальные запросы которых довольно
сложно разобраться да и в принципе такие запросы довольно сложно сходу не изучив язык
сложно сформулировать чуть-чуть буквально истории на слайде приведены даты ну такие отчасти
наверное ключевые для ранней опять же истории SQL потом это уже пошло то ли называется более
менее подокатанный но здесь может быть вот фамилия рейман фамилия имя рейман бойс это тот
собой бойс который потом у нас появится форме бойса кода к сожалению рейман бойс умер 75 как
раз по моему году и ну вот его память так сказать увековечен в том числе для всех изучающих курс
баз данных видео от формы бойса конда нормальной формы бойса кода но о которой мы с вами поговорим
попозже стандартизация SQL язык у нас стандартизирован первый стандарт 86 и 87 года к тому
времени уже SQL стал широко достаточно широко используем в среде разработки и как суббота как
так и разработки конкретных баз данных для конкретных приложений и предметных областей
доработка с 86 года проходит в среднем раз в пять лет и сейчас действующая редакция она с июля
2023 что называется вступила в силу это версия стандарта SQL 2023 а может на сам язык посмотрим
да хорошо давайте посмотрим стандарты по годам выхода тогда у нас на слайде приведены вот
последний стандарт SQL 2023 2023 тоже здесь у нас приведены ну такие может быть две основные
реперные точки там еще есть всякие разные минорные для кого-то минорные может быть
кто-то наоборот рассынет их как очень существенные изменения но пожалуй что наверное первое бросается
в глаза это полноценная поддержка джейсон и новый раздел про протеграф queries есть определенные
проблемы у стандартов потому что не все вендеры полноценно их поддерживают и нужно конечно
обращаться к документации при переносе тех или иных программ команд из-за одной соба да в другую
и также то есть и стандарт поддержит каждый вендор не в полной мере поддерживает во первых
стандарт нет стопроцентной поддержки а с другой стороны даже в той части в которой поддерживается
есть бывает различия по синтаксу по синтаксису и по логике поэтому смотрите документацию
ребята группа операторов сql принято делить на четыре группы изначально вообще и часто даже
сейчас можно говорить можно встретить что выделяют только первые две группы вот прям таких
корневых что ли корневые группы две основные группы операторов этот detail и dml и ну собственно
четыре по четыре команды в каждой группе четыре основные команды dcl и tcl мы тоже с вами затронем
но мы их затронем уже попозже уже наверное даже после проектирования базы данных будем смотреть
поэтому пока мы откладываем это что называется долгий ящик может быть не очень но отложим
сегодня у нас в первую очередь дель посмотрим что успеем из dml но сразу предупреждаю предупреждаю
что dml мы в полной мере сегодня не успеем захватить основные типы данных сql также на слайде приведены
здесь собственно что можно пояснить это вот тогда самые самые такие знаете базовые что ли вещи
которые будут вот такие какие они есть скорее всего без изменения там наименований в частности в
каждой современной революционной собеде если вы откроете документацию посгрыса опять же то там
увидите что дан типов данных ощутимо больше особенности их соответственно тоже ну покажет
конечно свои особенности возможности использования в тех или иных командах поэтому конечно тоже опять
же здесь смотрите документацию для более детального изучения каких-то специфических
специфических типов данных в той или иной субботы а лексическая структура сql во первых сразу да
сразу оговорюсь что здесь тоже вам рекомендую обращаться к документации в первую очередь
четвертый раздел документации посгрыса там три таких объемных главы они правда написаны знаете
не может быть не очень не очень последовательно в некотором роде но дают довольно полное
представление о том что и как можно формулировать в языке но правда у нас есть определенные
проблемы проблемы заключаются в том что синтаксис сql не очень строго определяет какие компоненты
идентифицируют команды какие их операнды или параметры ну то есть в принципе у нас это вот как
бы да если выделять конкретную конкретную проблему а вообще смысл в том что у нас
даже не то что смысл а связано еще проблемность лексической структуры сql с тем что это язык
декларативный и плюс есть определенные не строгие наверное правила в отношении формулирования
тех или иных команд и здесь может быть не очень очевидно как сложно сформулировать какие-то
общие правила не очень очевидно как использовать ту или иную команду поэтому тоже здесь уже
наверное в третий или в четвертый раз я вам рекомендую обращаться в документанты документации
обязательно если есть какие-то сомнения или команда повелась и будет так как нужно потому
что по всем тем даже командам которые мы сейчас затронем или которые вы затрагиваете до семинарах
и по которым вы наверное уже обращались документации вы наверное видели что в документации официально
есть просто огромнейшие статьи с которой предваряются сначала формальным описанием абстрактным
формальным описанием на псевдокоде команд операторов ключевых слов в этих командах и
соответственно у каждой команды есть довольно большая вариативность и гибкость и соответственно
довольно такие объемные правила ее использовали так вот компонентом команды что может быть ключевое
слово идентификатор идентификатор в кавычках оператор строка или константа специальный символ
как это все выглядит ну вот примерно иксически правильные сql программы
соответственно ключевые слова
ключевые слова крейт и показано отдельно выделено на слайде отдельные компоненты вот пример
ключевых слов крейт тейбл это ключевые слова идентификатор в кавычках lectures имейте
виду вот что у нас по умолчанию язык кейс инсенситив да то есть мы можем писать в принципе
ну практически да там кемал кейсом можем писать каждую букву как нам заблагорассудиться с точки
зрения регистра потому что во внутреннем таком первоначальном представлении все это будет
приводиться к нижнему регистру и соответственно будет будут проводиться операции сопоставления но
если мы идентификатор ставим в кавычках то мы говорим фактически нашей базе данных что у
нас идентификатор должен быть обязательно именно такой если мы к нему будем обращаться
обязательно такой как мы его прописали в кавычках но и обращаться мы будем к нему тоже используя его
наименовать строку на являющиеся его на именование тоже заключая в кавычке поэтому определить
определив идентификатор в кавычках вот например так как показано на слайде мы всегда его должны
будем именно так задавать во всех наших запросах и никак иначе идентификатор в кавычках ну если
дата для общего развития позволяет нам использовать в том числе и ключевые как не забавно слова здесь
не будет наложение между ключевыми словами из по словами используемыми без кавычек ключевыми
словами заключенными в кавычке это будет отдельно просто литерал где-то в некоем пространстве
хранящим хранящийся пространстве памяти хранящийся у базы данных и она будет к нему относиться по
особому не будет наложение ну конечно наверное вряд ли вам потребуется все-таки в общем случае
ключевые слова использовать в качестве идентификаторов так специальный символ вот в примере он приведен
в виде звездочки в данном случае select from students ну я думаю вы уже знаете что эта команда у
нас выведет все строки из таблицы students students соответственно идентификатор уже обычный без
кавычек он будет опять же casing sensitive а константы константы тоже приведены на слайде вот они
выделены в команде insert insert into трататата values и два две величины вносятся для константа вносится
в таблицу язык поддерживает комментарии однострочные комментарии многосрочные комментарии однострочные
комментарии у нас с двумя дефисами обозначается и после двух дефисов все что идет до конца строки
соответственно является комментарии комментарии ему многосрочные комментарии использует си подобный
синтаксис давайте с вами попробуем начать обзорное знакомство с основными группами команд с ql ddl и
dml начнем соответственно с data definition language и с его четырех основных команд сразу оговорюсь
вот вот по поводу чего у нас есть наверное определенная проблема в изложении может быть
потому что у нас здесь есть в сql есть некоторые вещи которые нельзя объяснить не объяснив другие
вещи которые должны быть объяснены после первых вещей вот вот такая немножко да запутанная
конструкция но по сути дела просто напросто имеется в виду что вот мы сегодня с вами затронем
тернарную логику и ключи но по большому счету тернарная логика относится не только к дд л операциям
и ключи тоже не ограничиваются дд л командами их значение и особенности и поэтому и с тернарной
логикой и о тернарной логике мы еще с вами будем говорить на следующей лекции а с ключ о ключах
мы будем говорить при рассмотрении вопросов проектирования базы данных и нормальных формах
сейчас мы с вами поговорим о дд л команде create и в частности команде крейт тейбл почему в
частности потому что если вы зайдете в документацию посмотрите нас раздел справочное руководство то
увидите что с крейт есть еще наверное и команд начинающихся с команды крейт есть наверное ну штук
15 20 мне кажется и создавать можем далеко не только таблицы но такие исчерпывающие подробности
выходят наверное все-таки за рамки нашего по крайней мере сегодняшнего разговора поэтому
мы ограничимся только созданием таблиц а посмотрим на ограничение на ограничение в виде проверки
целостности и также на ограничение в виде ключей крейт тейбл базовый синтакс из создания таблиц
здесь на слайде я привел ну признаюсь это просто цитата из официального руководства да но стата
неполная на самом деле если вы посмотрите то соответственно увидите что вот этот псевдокод
проведенный на рисунке на слайде он соответствующий страницы указанный внизу слайда он занимает
гораздо больше места гораздо более объемная объемная команда крейт тейбл и ну мы касаться
всего повторюсь вот к сожалению время нам не позволяет там много всяких интересностей посмотрим
на какие-то базовые вещи ну я понимаю что с одной стороны у кого-то уже прошли семинары
первые может быть даже вторые и вы уже прям матерые создатели таблиц но тем не менее мы
будем идти последовательно поэтому если для кого-то это конечно будет повторением до уже пройденного
призываю тем не менее еще раз прослушать какие-то может быть особенности мы затронем которые бы
не затрагивали на семинарах что главное наверное нам в создании таблицы на сегодняшний момент
нужно понимать и усвоить это то что у нас определение таблицы обязательно должно состоять из трех ну
обязательно должно включать в себя следующие три компонента вот так вот скажи это имя столбца
тип данных и ограничение таблицы принципе мы можем создать команду мы можем команду
create table исполнить с именем таблицы это обязательный да как видите имя таблицы не в скобках не в каких
просто указано мы можем команду create table имя таблицы некое исполнить без задания конкретных
атрибутов, отношений или конкретных доменов на этих атрибутах определенных, для этих
атрибутов определенных. И это будет нормально, у нас наш Postgres не выдаст никакой ошибки,
просто потом мы сможем дополнительными командами AlterTable, в частности, добавлять новые и новые столбцы.
Итак, что мы должны иметь в виду при создании таблицы. Реальная команда
по созданию таблицы выглядит так, как показано на слайде. Имя столбца у нас задается первым,
потом через пробел дополнительные идентификаторы, ключевые слова. В данном случае у нас
для каждого столбца есть определитель типа данных, на некоторые столбцы установлены
определенные ограничения, которые при добавлении записи в таблицу будут проверяться,
вернее записи при добавлении будут проверяться на предметы этих ограничений. Будет ли успешная
операция по добавлению либо соответственно наша база данных, наш систем управления базой данных
будет выдавать ту или иную ошибку да еще наверное знаете оговорить сразу что у
нас довольно есть обширные правила по ну это предыдущим немножко наверно
слайдом тут тем не менее есть обширные правила по формулированию
идентификаторов тому что у нас считается операндом
операторам прошу прощения по порядку по старшинству действия операторов
все это опять же есть в официальном руководстве
отсылаю вас к нему ну там наверно такие тривиальные вещи все-таки описаны из
серии да что там не знаю нельзя с со знака астрикс начинать имя идентификатора
ну так принципе латинские буквы числа нижние подчеркивания допустимые более
чем наверное достаточно для того чтобы сформулировать такой идентификатор который
нам хочется да там по идентификатором также есть у нас ограничение на длину мы
его можем изменить в заголовочном файле позгресса ну если вдруг кому-то
интересно опять же все это подробно у нас в документации описано поэтому еще
раз предлагаю за подробностями туда обратиться давайте подробнее поговорим
про ограничение в таблицах так одну секунду вопрос
хорошо значит вопрос что такое прайм реки хорошо значит не у всех не у всех прошли
соответствующие лекции семинары прошу прощения значит это будет вдвое полезно
смотрите прайм реки это особый вид ограничения ограничения по первичному ключу мы сейчас
об этом специально поговорим но глобально да что-то почему мы выделяем это в виде
отдельных отдельного словосочетания ключевого потому что ключи имеют серьезные значения для
религационной модели по сути дела посредством первичных и внешних ключей мы создаем
функциональные зависимости между нашими таблицами между нашими отношениями таким
образом у нас совокупность разрозненных таблиц существующих в некоем там где-то
до нашим воображаемом табличном пространстве она становится у нас неким подобием что ли
графа как не забавно но это уже может быть отсылки предыдущей лекции взаимообратимости
моделей данных и представлений короче говоря у нас благодаря первичным и внешним ключам о
которых мы поговорим буквально через несколько слайдов можно формулировать функциональные
зависимости между отношениями между таблицами и таким образом дополнительно создается условия
на целостность данных более сложные условия для целостности целостности данных позволяют нам в
базе хранить неповторяющуюся не избыточную информацию и позволяют по вот этим вот с взаимным
ссылкам искать соответственно нужный нам кусочек этой информации разделенные на отдельные
таблицы разделенные по причине необходимости поддержания нормальной формы ладно это наверное
для вас это прозвучит сейчас очень общего просто будет понятнее когда мы с вами дойдем до нормальных
форм и поймем почему нельзя хранить данные в одной таблице но вот например как в одной таблице
файлы excel ну это очень не оптимально сразу да можно говорить и кто пытался создавать большие
таблицы наверное может представить почему это происходит там потому что данные не по всем полям
всегда у нас есть или потому что например нужно бывает к уже имеющимся данным добавить новые но
если добавлять новые атрибуты вот в это единичное отношение у нас получается черти что у нас
получается по трем записям условно три новых атрибута добавлено но для предыдущей тысячи это
не имеет никакого отношения то есть здесь тоже возникают вот такие вопросы если вы к цели это
еще приемлемо то когда мы говорим о промышленных объемах данных там с этим встают вопросы встают
большие вопросы о том как это оптимизировать ну оптимизировать понятно как использовать
революционную модель ну ладно ребят извините это я забегаю вперед такие общие вещи на общее
понимание но правильные это ограничение для обозначения функциональной зависимости между
отношениями если вот кратко резюми хорошо что такое ограничение в таблицах вообще для чего они
нужны служат средством поддержания целостности данных гарантирует что при внесении данных
таблицу не будут нарушена взаимосвязи между ними обеспечивают ссылочную целостность между таблицами
вот это вот конкретно за счет внешних ключей но внешние ключи они тесно связаны с первичными
ключами сейчас мы об этом тоже поговорим и ограничение определяются после типа данных либо
отдельным утверждением при определении таблицы это про синтаксис про синтаксис сейчас тоже мы
скажем основные ограничения в SQL первое это нот нал соответствующий столбец не принимает
значение нал ну вот по нот нал примеры с кодом на слайде нет но в принципе здесь довольно
просто себе это представить мне кажется просто вот например до левый нижний уголу где где у нас
показан в зеленом таком квадратики с текст команды слово унит просто заменить на нот нал и вот это
будет то же самое ограничение то есть синтаксически как вы помните из предыдущих слайдов у нас
должны разделяться пробелинами символами части команды и вот продукт но продукт нам барда
integer но тнал будет означать что когда мы создали создали таблицу products у нас есть в ней три
атрибута продан номер продукта имя продукта и цена и вот имя номер продукта у нас является
атрибутом на домене целочисленных чисел целых чисел и ограничение нот нал будет означать что
когда мы добавляем новую запись мы обязательно в этой новой записи должны будем сказать что
продукт ноу продукт нам барда должен принять какое-то значение мы не сможем избежать мы не
сможем ставить только два значения в два атрибута нейм и прайс мы должны обязательно всегда в продукт
нам бар вставлять какое-то целочисленное значение иначе у нас всегда будет возникать ошибка ну или
юник в данном случае как показано на слайде означает что просто у нас на продукт нам бар да как
накладывается другое ограничение что оно должно быть это значение для во всей таблице во всей
нашей этой колонке продукт нам бар уникальная мы могли бы два ограничения вместе наложить без
запятых просто через пробел нот нал и юник и у нас тогда было бы двойное ограничение чтобы всегда
должны заполнять продукт нам бар каким-то значением он должен быть уникальным и вот такое обозначение
нот нал юник оно как не забавно можно его считать до некоторого до некоторого до некоторого порядка
псевдонимом для вернее определением для ограничения праймеры ки а праймеры ки считать
псевдонимом правда есть это да правда это справедливо только в определенном в первом
приближении потому что на праймеры ки добавляются еще дополнительные внутренние операции базы
данных по создать по индексации по созданию всяческих статистических по отслеживаю всяческих
статистических данных поэтому прямого соответствия нет но тем не менее праймеры ки у нас по сути дела
на сущностном уровне задает те же ограничения нот нал и уник одновременно вопрос в чате
уник ас дает уникальность кортежей или вида ас вернее да или вида ас или каждого из столбцов а и
ц отдельно а уникальность кортежей уникальность кортежи должно быть так прошу прощения да то есть
у нас всегда ас должно быть уникальным для всей нашей таблицы хорошо нот нал юник в принципе довольно
просто мне кажется здесь нет каких-то специалистов нет каких-то вот особых подводных камней уж точно
на уровне каких-то вот простеньких бас из нескольких таблиц все ну прямо линейно выглядит и
прозрачно что касается прайма реки вот собственно да немножко я предварил то о чем написано на
этом слайде если вы обратите внимание внизу да вот в квадрате с черной каймой и в квадрате
с на с таком оранжевым фоном они сопоставлены в двухсторонней стрелочке то есть уник нот нал
примерно то же самое что прайма реки но повторюсь это не совсем так если смотреть
на внутренности базы данных и то что она делает с прайм реки то есть там есть дополнительные
всякие оптимизационные механизмы и операции поэтому конечно прайма реки вы не замените на еник
нот нал но по сути дела прайма реки означает что у нас таблицы средний который мы создаем по
вот коду оранжевом квадратики у нас на продукт намбер накладываются те же ограничения что
накладывают юник и нот нал одновременно так замечательно спасибо за пояснение потому
что прошлый раз вроде говорили что курсор не виден спасибо виден курсор замечательно тогда
что еще что есть что здесь сказать да опять же вот синтактический обратите внимание как на
прошлом слайде слайде так и на этом у нас есть варианты мы можем синтактически определять
ограничения при определении колонки при определении столбца можем в конце таблицы
конце определение таблицы привести ограничения и более того будет еще один вариант ну даже
наверное, полтора, что ли, варианта того, как можно сформулировать ограничения чуть попозже.
Так, хорошо, fornky – это еще одно ограничение, которое у нас сдает столбец или группу столбцов
таблиц, значения которых должны совпадать со значениями столбцов первичного ключа другой
таблицы, указанной в этом ограничении. То есть это вот та самая функциональная зависимость,
о которой я говорил. Ну, про функциональность пока можете просто отложить себе в голове. Это
словно потом, чтобы когда мы дойдем до соответствующей темы какие-то вопросы,
уточняющие задательную смысл. Вот еще у нас есть primary key, таблица с primary key с первичным
ключом, есть таблица с вторичным ключом, с fornky. У нас вот пример задания, опять же,
синтаксис, разница за подробным описанием синтаксиса, уж не обессудьте, я вас еще раз
отправлю в документацию, потому что там прям вот как в естественном языке практически вариантов
очень много. И смотрите, у нас есть primary key, мы задали fornky через ограничение references
product number, то есть у нас во второй таблице нашей вот create orders, таблице orders, на столбце
product number задается ссылка, задается внешний ключ в виде ссылки на таблицу products и конкретно
на столбце product number. Что это значит? Это значит, что у нас в таблице orders никогда, ни при каких
обстоятельствах не должно быть в столбце product number числа, которая не появляется у нас в столбце
product number в таблице products. У нас соответственно таблица products будет главной по отношению к
таблице orders, таблица orders будет подчиненной и она всегда должна подчиняться в том плане, что
использовать только то подможество значений, которое уже существует в таблице products, никак иначе,
иначе у нас не запишется просто запись в нашу базу данных при добавлении, у нас возникнет опять же
ошибка. Можно ссылаться опять же на группу столбцов целевого отношения, вот здесь еще пример
синтаксиса задания ограничения, for ain key, прошу прощения, for ain key задается на столбце BC и
ставится ссылка на некое иное отношение, иную таблицу на ее уже главные столбцы по отношению к
T1, столбцы C1 и C2, то есть в our table C1, C2 значения, которые туда попали, только эти значения мы
сможем использовать в таблице T1 в столбцах BC. Имеется ввиду, что для каждой пары BC должна
существовать пара C1, C2 из другой таблицы? Да. В смысле прямо в одном столбце? Смотрите, там
надо смотреть, но в принципе да, в принципе да, там получается, что у нас primary key, ну даже не
надо смотреть, у нас получается, что primary key в таблице our table будет C1, C2, мы можем ссылаться,
только for ain key у нас должен ссылаться обязательно на primary key, то есть соответственно C1, C2 если у
нас будет primary key, то как вы только что увидели, это у нас ограничение unique not null на эти же два
столбца C1, C2, соответственно C1, C2 будет кортежем, который должен быть уникальным в рамках вот двух
столбцов одновременно в главной таблице. Как пара? Как пара? Так, да.
Да, следующее ограничение check. Задает произвольное условие назначения одного или нескольких столбцов в одной
строке таблицы и что это значит? Что мы можем поставить логическое условие при определении
таблицы и когда мы будем носить запись, у нас запись будет проверяться отдельные ее атрибут,
отдельное значение атрибута, будет проверяться в соответствующем правиле для столбца таблицы,
если проверка не будет пройдена, соответственно запись у нас в таблицу не попадет. Что важно иметь
в виду, что в ограничении check у нас задается выражение, возвращающее логический результат,
по которому определяется будет ли успешна операция добавления или изменения для конкретных строк.
И операция у нас будет выполнена успешно только если у нас при проверке check логическими результатами
будет true или unknown. Если у нас будет false, операция добавления ничего не поменяет в базе данных,
у нас возникнет ошибка. Пример с ограничением check. Записывается довольно просто, по сути дела,
как используя логический оператор, довольно простая понятная запись. В данном случае оператор
больше, то есть при добавлении записи у нас цена должна быть обязательно больше нуля. Также можно
еще отнести к операциям ограничения команда default, но как бы с одной стороны это не то,
что по большому счету это не ограничение, это просто задание значений по умолчанию,
когда мы не будем вносить запись в таблицу. Соответственно, если мы ничего не вносим и у нас
нет default, то у нас появляется значение null. Если у нас default, то мы можем по default установить
какое-то значение, когда мы не вносим запись на слайд, где это значение даты,
с текущей даты. В данном случае даже не просто даты, а в данном случае функция now у нас вернет
дату с timestamp, но мы ее сокращаем в примере до выражения вот год-год-год,
default месяц-месяц, default день-день. Это следующая группа операторов, это будет оператор insert,
insert. Простите уж мой английский, может быть. Но смысл в том, что мы просто не все значения
будем выносить из полей. Да, если это будет допустимо, сможем вынести не все, да.
Ну, не совсем, но мы там до insert дойдем, когда я все это покажу. А к ограничениям принято... Так,
да, default мы с вами уже проговорили. Задается значением без переменных, выражением без
переменных, не допускается под запросы. Ну, то есть, в принципе, в идеале это, конечно,
какая-нибудь вообще константа. Ну, условно в идеале, да, для простоты, что называется. А так,
конечно, есть определенный простор. Вот можно функцию default поставить какую-то, которая будет
вычислять некое значение и вставлять в поле при отсутствии соответственно значения при вставке.
Так, хорошо. Синтаксис, наконец, ограничений. Любопытная штука. Вот почему. Потому что мы
можем не просто писать ограничения для столбца или ограничения для таблицы, как на второй картинке,
вот на вот этой, да. Мы можем еще и явным образом присвоить ими ограничению. И почему это полезно?
Потому что в этом случае у нас более осознанно, более человекочитаемые, удобные для восприятия,
будут сообщения об ошибке, если вдруг что-то у нас пойдет не так и будет связано с каким-то
конкретным ограничением. Соответственно, у нас сообщение об ошибке будет, что, условно,
не просто ошибка там в такой-то, не знаю, записи, да, на таком-то этапе, а ошибка в связи с таким-то
ограничением. И более информативно. Но, в принципе, что еще можно сказать, что у нас, прошу прощения,
у нас ограничения на столбце не полностью эквивалентны ограничению на таблице. То есть,
вернее, наоборот, у нас ограничение на таблице не всегда можно переформулировать на ограничение
на столбце, поэтому есть определенная небольшая синтоксическая разница. Она может быть заметна
при определенных операциях, вот так вот несколько туманно, скажу я, но смысл просто в том, что вот это
вот, да, не во всех случаях эквивалентно, ну, понятно, что здесь разные условия, но, в принципе,
вот эта вот запись не эквивалентна была бы записи, когда бы чек у нас просто стояла внизу,
отдельно в конце таблицы. Такое не всегда эквивалентно. Ну, просто имейте это в виду,
держите в голове, если вдруг у вас появится ошибка, с которой вы не сможете справиться,
хотя, казалось бы, ваши базы данных довольно просты и очевидны. Так, ладно, давайте будем двигаться
дальше. У нас с вами по нашему, да, вот нашей дорожной карте это ключи. Про ключи мы с вами сказали,
что есть праймерики, есть форейнки, да, праймерики мы задаем для текущего отношения. Это эквивалентно
заданию ограничения not null и unique. Форейнки мы задаем для текущего отношения путем ссылки
на некое главное отношение, где есть праймерики и что мы еще можем сказать о ключах. Немного
теоретической информации сейчас будет, она нам понадобится при больше даже, наверное,
может быть, проектировании в некотором смысле, но раз уж мы затронули ключи, давайте мы поговорим
чуть-чуть подробнее о них и разберем их виды. Во-первых, начинается все с потенциального ключа,
то есть в релиционной модели данных это подмножество атрибутов отношения, удовлетворяющие определенным
требованиям, их всего два, это уникальность и несократимость или минимальность. То есть
потенциальный ключ это обязательно, то есть подмножество атрибутов, наверное, с этого начнем,
это один или, ну пустое подмножество не будем брать, это один или там все атрибуты отношения и,
соответственно, для простоты один атрибут отношения это таблица и уникальность, то есть на этом
столбце у нас все наши данные должны быть уникальны, не должны быть повторяющиеся, то самое
ограничение уник. И второе ограничение минимальности, что в составе потенциального ключа отсутствует
меньшее подмножество атрибутов, удовлетворяющие условия уникальности. Иными словами, это значит,
что когда у нас потенциальный ключ состоит из более чем одного атрибута и мы не можем из этого
вот набора атрибутов убрать какой-то атрибут без потери свойства уникальности, то это значит,
мы достигли минимально возможного набора уникальных атрибутов. Ну, о чем будет речь,
о том, что у нас может быть, как знаете, вот для примера представьте себе таблицу истинности
логическую, да, и вот, например, с тремя переменными, у нас, соответственно, там будет 8 строк. И в начале
с левой стороны этой таблицы мы запишем назначение A, B, C, и там будет 4 истинных,
4 ложных, значит, строки подряд у B будет по две строки чередующихся, и у C через одну строку будет
чередоваться истинно-ложно, истинно-ложно. У нас таким образом здесь получается, что мы сформировали,
ну, помимо там того, что мы потом будем какую-то логическую функцию по этой таблице развертывать,
мы сформировали вот в этих трех столбцах, три расписали по трем атрибутам их значение таким
образом, что у нас каждая строка оказалась уникальным набором, они не повторяются нигде. У нас вот
этот кортеж из трех значений в этой таблице истинности из трех логических переменных, у нас
каждая повторяющая строка получается трехстрочным, трех-трехэлементным кортежем, который уникален
по отношению к другим. При этом, когда мы будем дальше справа чертить новые колонки, там какие-то
логические функции уже развертывать, расписывать по участвующие в выражении, у нас может случиться так,
что мы не сможем их добавить в наши вот эти три первых атрибута, потому что если мы их добавим,
возможно у нас тогда потеряется уникальность. Но с другой стороны, мы их, если уберем, уникальность
из трех этих атрибутов у нас останется, и вот он наш потенциальный ключ, который можно использовать.
Сейчас вопрос. Я не могу сейчас сходу сообразить, из этого следует, что они все равномощны или нет?
Равномощны? Ну, в плане, что во всех потенциальных ключах одинаковое количество элементов.
А, ну, конечно, конечно, да, во всех. Не, ну, имеется в виду, смотрите, у нас получается как, да, под множество
атрибутов. Нет, они не равномощны. У нас потенциальный ключ для отношения может быть... Вы знаете, хороший
вопрос, хороший, нет, я не могу, наверное, сходу вам ответить про равномощность, но у нас, по идее,
получается, что потенциальных ключей может быть несколько. Это да. Они могут быть... Очевидно,
в одном отношении может быть такое, что... Ну, очевидно, вот на пальцах, интуитивно, очевидно,
что называется, в одном отношении может быть потенциальный ключ, состоящий из двух атрибутов и из одного,
например. Ну, такой совсем простой случай возьмем. А равномощны по отношению к кому тогда? К другим отношениям?
Но, очевидно, нет. Внутри одного отношения все потенциальные ключи равномощны.
Мне кажется, тоже нет, я вам не смогу, наверное, математическую...
Один ключ, который уникальный везде, и два ключа, которые каждый из них повторяются,
но при этом множество их пар не повторяются.
Да-да-да, совершенно верно. Наверное, здесь нужна таблица для пояснения.
Да, уж, наверное, извините, что таблицы не щад, к сожалению, но получается, что у нас нет ограничений на равномощность.
Мы можем, да, потенциальные ключи в одном отношении, а не...
Как можно таблицу, как раз, пример?
Не обязательно равномощна... Так, это у нас, соответственно, вопрос в чате.
Потенциальный ключ уникально? Вроде да, вроде да.
Вроде кажется, что да, на первый взгляд.
Кажется, что да.
То есть, мы можем взять по первому атрибуту, по первому самому столбцу, можем взять по трем столбцам одновременно,
а при этом по первому, второму и по второму, третьему мы взять, например, не можем, потому что у нас будет пересечение в среднем кортеже.
2-1-1-2 порядок нам, поскольку не важен, вроде бы.
Окей, ну, соответственно, да, получается, вот если обратить внимание на таблицу в чате, у нас не обязательно равномощна, совершенно верно, пример приведен корректный.
Хорошо, так, потенциальный ключ может быть простым или составным, соответственно, да, две атрибуты или несколько атрибутов в него могут входить.
Далее, что еще нужно знать? Ну, дальше уже идут, на самом деле, такие вариации на тему того, каким потенциальный ключ еще может быть.
А потенциальный ключ дальше можно разделить на первичный ключ и альтернативный ключ.
Что такое первичный ключ? Это тот потенциальный, который мы выбрали для своего отношения в качестве основного,
то есть который мы, таблицы прям наши пометили как праймы реки, альтернативный ключ это все остальные потенциальные ключи, которые в первичный наш ключ не вошли.
Естественный ключ, суррогатный ключ, любопытная штука, потому что можно, для простоты, часто, очень часто, если едва ли в каких-то промышленных вещах не всегда создают первичный ключ не на основе
каких-то реальных данных, занесенных в таблицу, а на основе некоего технического поля типа ID,
которое там еще и генерируется автоинкрементом каким-нибудь и таким образом у нас, или вообще, может быть, каким-то рандомным способом генерируется строка симбольная в суррогатном ключе.
И таким образом мы просто отдаем обязанность следить за тем, чтобы ключ был уникальным и не сократимым на откуп функционалу СУБД.
И мы не думаем, правильно ли мы сделали, чтобы выбрали в качестве нашего первичного ключа имя и фамилию студентов в таблице students тех, кто не просто учится в МВТ
сейчас, в текущем семестре, а учился на протяжении 10 лет. Очевидно, такой первичный ключ будет некорректным, вероятность совпадения фамилии будет очень велика.
А если мы добавим туда какое-нибудь автоинкрементное поле, суррогатный ключ, пожалуйста, гарантированно уникальные значения.
Так, здесь еще можно сказать, что есть определенные недостатки. Неинформативность, поскольку техническое поле, мы ничего из него с одной стороны не можем понять, с другой стороны уязвимость для генераторов, вернее уязвимость генераторов в том плане, что по этому полю, если мы к нему доступ как-то получим, мы можем понять вообще движение в таблице, какие происходят, сколько в нее добавляется, сколько там удаляется, наверное, нет.
Если у нас там какой-нибудь автоинкремент, да, но сколько добавляется, например, данных, что вообще, сколько данных записей вообще в таблице есть или как минимум было за все периоды ее существования и так далее.
И, наверное, действительно такой вот серьезный недостаток, но он не связан с техническим аспектом, он связан с аспектом человеческим исключительно.
Суррогатный ключ можно использовать вместо нормализации и таким образом положить не громоздки избыточные, семантически избыточные таблицы, в которых содержится избыточные данные, вместо того, чтобы их правильно разделять и эффективно с ними взаимодействовать.
Так, внешний ключ. Мы с вами посмотрели, что это, да, как это определяется, а что это по существу. Это, ну, определение, в принципе, тоже я вам примерно проговаривал в менее формальном изложении, но, по сути дела, внешний ключ, это вот, да, то он может содержать некое подможество значений, которые принимает у нас первичный ключ,
на который ссылается внешний. Вот это, наверное, самое главное свойство. Определение, опять же, на слайде есть. Если хотите, вы можете прочитать это еще раз уже по слайдам самостоятельно.
Мы еще вернемся к рассмотрению ключей в следующих лекциях, при проектированиях, при проектировании базы данных. Там, правда, будет, там не будет уже каких-то новых подробностей, но мы просто будем еще о ключах говорить.
Хорошо. Тернарная логика, тернарная логика, вспоминаем мы о ней благодаря нашей логической проверке целостности, благодаря ограничению check.
Как мы с вами говорили, check, если у нас true или unknown значение при логической проверке, то запись у нас пройдет, а если у нас false, то запись не пройдет.
Встает вопрос, что такое true, unknown и false? Казалось бы, в двоичной логике у нас было всего два значения.
Да, ребята, вопрос. На слайде написано, что для внешнего ключа нужен потенциальный, раньше говорили, что нужен первичный, а первичный у нас в любом случае является видовым понятием по отношению к потенциальному.
Потенциальный – это род, первичный – это тот потенциальный, который мы выбрали, поэтому здесь нет прямого противоречия. Здесь есть, возможно, некоторая некорректность, соглашусь с вами, но прямого противоречия нет, потому что мы и там, и там говорим о сущностях, обладающих одинаковыми свойствами с точки зрения минимальности и уникальности.
И первичные и потенциальные ключи должны быть минимальными и уникальными, а это нам принципиально важно для внешнего ключа, поэтому корректнее говорить о первичных ключах, потому что внешне мы формулируем для уже выбранного. Я исправлю, несу корректуру, когда буду выгружать слайд.
Спасибо. Хорошо. Фернарная логика. То есть у нас есть проблема. Мы не всегда в ячейке таблицы можем занести какие-то реальные значения. Что нам тогда делать? Тогда у нас появляется специальный маркер Now. Now у нас не является ни числом, ни символом.
Это просто специальный филер такой, который СУБД вставляет в нашу базу данных, когда она не знает, что вставить, потому что у нас в принципе не должно быть пустых полей, не должно быть пустых атрибутов.
И есть проблема. Что нам делать с нал? Если по сути дела это не ложное значение, не истинное значение, а это значение, о котором мы не можем ничего определенного сказать. Решение, тернарная логика, троичная логика, тройственная логика.
Я использую термин тернарная. Вы больны использовать любой иной употребимый термин. Насколько я понимаю они взаимозаменяемы.
Нужно отличать сам маркер нал, который у нас реально фигурирует в данных, в нашей таблице, от логического значения unknown. Логическое значение unknown у нас нигде не фигурирует.
Это может быть результатом действия какого-то оператора, который производит логическое сравнение, например. Чего-то с нал, или может быть даже чего-то с unknown. Но unknown у нас такого типа самого по себе нет.
True or null. Сейчас вы все увидите. Таблицы истинности приведены на экране.
Таким образом у нас true or null должно быть равно чему чему чему чему.
Должно быть равно true по вот этой вот клеточке получается.
Здесь, наверное, это просто нужно запомнить. Смириться и начать жить в парадигме тройственной логики, троичной логики, тернарной логики.
Здесь, наверное, нет какой-то особой может быть сложности. Просто нужна практика, чтобы все это осело.
Единственное, хотелось бы сказать, что есть также в документации описание функции оператора в сравнении.
Оно, честно говоря, даже, наверное, может быть в некотором роде более удобное. Оно просто довольно обширное. Оно объемное, но может быть более удобное для восприятия.
Здесь я вам привожу более, может быть, общие какие-то описания того, как логические функции будут действовать в поле тернарной логики.
Там более практико-ориентированные. Поэтому рекомендую обратиться тоже, посмотреть, как и что работает.
SQL предоставляет несколько стандартных предикатов, позволяющих провести логическое сравнение.
Как эти предикаты действуют, опять же, тоже на слайде приведено.
Здесь, в принципе, что можно сказать? Обратите внимание, эти предикаты, в отличие от только что просмотренных таблиц истинности, не выдают нам значение unknown.
У них всегда значение или false, или true. Почему это может быть важно? А вот, собственно говоря, почему.
Все сравнения с маркером null приводят к значению unknown, за исключением специальных предикатов.
Значение or не является сравнением, да?
С логической точки зрения у нас будет true. True или unknown будет true.
То есть логические операторы – это не сравнение?
Нет, нет, нет. Это логические функции.
Они сообщают результат в виде истинности и ложности, ну или в данном случае unknown, по отношению к тому, какие операторы в них загружены.
Сравнение у нас подразумевает, что у нас есть какое-то, как бы это обозначить, чтобы не быть более или менее корректным.
Сравнение у нас подразумевает какую-то шкалу, что ли, мерную. С логическими функциями никакой мерной шкалы нет, есть просто правила.
Поэтому у нас, как бы так сказать, тоже плохое описание.
В общем or – это не сравнение, ребята, это логическая функция.
Давайте вот так вот на этом завершим, чтобы не впадать в какую-то тавтологию.
Сейчас постараемся закончить все-таки стернарной логикой быстренько.
Основное правило, еще раз, с маркером null все сравнения приводят к значению unknown, тем не менее.
И что это значит?
Что null равно 5, что у нас мы получим? Unknown. 5 равно null? Unknown.
null меньше или равно 5 – unknown.
Ну и далее, что у нас получается еще?
Если мы берем какое-то значение из некоего атрибута и начинаем сравнивать его с 5,
то есть проходим по строчкам таблицы, берем оттуда по одному атрибуту значения, сравниваем с 5,
и у нас в этой конкретной строчке конкретной таблице получается значение null, мы получаем unknown.
Причем у нас, опять же, если мы сравниваем две таблицы по какому-то атрибуту,
и у одной таблицы в этом атрибуте или у обеих таблиц в этих атрибутах сразу появляется значение null,
то тоже значение unknown.
null равно null тоже у нас не определено.
Что нужно помнить еще о тернарной логике при запросах?
Ключевые слова in, where и having строго требуют значения true, поэтому not false для них недостаточно.
А not false – это что у нас такое? Это у нас true или unknown, как мы понимаем.
Поэтому у нас со значением unknown они не работают,
но, как было показано ранее, для проверки по команде check действует более слабое условие.
Для сравнения значения с null нужно использовать специальный предикат,
можно также использовать is not distinct from или is not distinct from с типом null.
При наличии сомнений, опять же, обращаться к документации, подумать вообще,
вспомнить о том, что мы работаем с тернарной логикой,
и что у нас есть null умножить на ноль в Эйбейте.
Так, ошибка должна быть.
Так, что еще можно использовать?
Нужно помнить тернарные логики при запросах.
Соответственно, помните, у нас тернарная логика,
у нас специфические вещи происходят, если у нас появляется null,
при этом мы можем, опять же, еще использовать два интересных предиката,
это is unknown и is not unknown,
когда мы хотим сравнить прям результат,
именно логический результат с неким, является ли он unknown или нет.
Там любопытный момент, любопытные обстоятельства,
я уже, наверное, видимо, на следующей лекции вам покажу.
Так, сейчас просто быстро закроем DDL,
чтобы у нас уже со следующего раза был точно data manipulation language.
Две основные команды, это alter, вернее, не две, а там три получается команды,
у нас остается alter table,
опять же, у нас команда alter является,
слово ключевой alter является началом многих других команд,
документации, как и с create,
вы увидите, что с alter есть еще варианты,
не только table, но и других сущностей,
можно другие сущности менять, не только таблицы,
но для базового понимания, вот пример приведен с alter table,
syntax is приведен на рисунке на слайде,
он тоже урезанный,
там гораздо-гораздо больше возможностей по действиям,
по крайней мере,
и в принципе, на самом деле alter table,
команда довольно простая с точки зрения логики того,
что она делает, того, как она формулируется,
поэтому здесь на самом деле нет каких-то подводных команд,
мы делаем таблицу с людьми,
с персоналом, например,
и хотим дальше изменить, например, ограничения,
мы можем менять в таблице колонки добавлять,
ограничения менять, удалять,
можем много-много вариантов всевозможных,
документации вы найдете исчерпывающий перечень ребят,
вот на примере мы добавляем ограничения в виде первичного ключа,
и удаляем потом ограничения в виде первичного ключа,
дальше у нас truncate и drop,
две простые команды на самом деле,
буквально по два слова о каждой,
truncate позволяет быстро удалять все строки из таблиц,
похоже на команду delete из datamanipulationlanguage,
но действует быстрее, так как не всканируют таблицы
и сразу высвобождает дисковое пространство,
не нужно выполнять операцию vacuum,
про операцию vacuum мы с вами еще поговорим,
потому что как не забавно,
оказывается, что когда мы изменяем данные,
не всегда получается в результате освобождения дискового пространства,
не всегда получается физическое удаление,
иногда нужно запускать отдельно команду vacuum,
и у нас удаляются по сути дела только ссылочные информации из нашей базы
на удаленные команды delete строки,
в общем случае,
и сама таблица, важно иметь в виду,
что сама таблица после исполнения команды truncate остается,
то есть остается у нас по сути заголовок отношения,
там будет ноль строк, но отношение останется,
droptable команда базовый syntax is опять же на экране,
droptable удаляет таблицу,
droptable можно не только удалять таблицу,
можно удалять еще данные,
но удаляет таблицу из базы данных полностью,
удаляет таблицу может ее владелец,
ну ладно, про роли мы не будем сейчас с вами останавливаться на этом,
но важно, наверное, как резюме понимать,
что truncate удаляет тело таблицы оставляясь за заголовок отношения,
drop удаляет отношение целиком со всеми его данными задержащимися,
миссия в нем.
