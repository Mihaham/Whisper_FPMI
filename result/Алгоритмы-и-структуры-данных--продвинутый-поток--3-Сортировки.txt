Вот именно таким образом концепция блокирующих потоков и частости алгоритм Диница помогает нам
писать алгоритм хопков такарпоза, екорния и зве, а теремодулика позволяет вам даже находить
почти правильный ответ. Вот таким образом могла бы закончиться лекция, если бы мы с вами были на
втором курсе. В общем-то в среду примерно то же самое было. Кстати, честно, очень удивлен,
со среды тут ничего не поменялось. Но мы с вами пока не на втором курсе, или более точное утверждение
пока не дошли до потоков. У нас в общем-то был прецедент, когда мы до потоков дошли в конце
первого курса, но этим мы пока заниматься не будем. Впрочем, на самом деле, терему можно оставить
как интересную задачу, которую вы на самом деле можете сами придумать. В общем-то не сильно
сложно, но тем более, что основное решение тут так на уровне картинок уже спалено на самом деле.
В общем, ничего сильно сложного там нет. Ну а мы сегодня будем говорить о, ну тут тоже спалено,
о чем. Вот в общем-то. Пока еще стираюсь, скажем так, да, как вы помните у вас сегодня дедлайн по
такому первому небольшому заданию. Да, так что сразу готовьтесь, будет второе. Ну объем примерно
такой же. Да, объем примерно такой же, но сроки примерно такие же. Нет, это тоже будет задание по
математике. Нет, это будет очень важно, потому что там будет пара-тройка, там в том числе будет
еще пара-тройка задач по амортизационному анализу. Он нам потребуется, потому что вот мы сейчас
обсудим сортировки, а потом будем обсуждать всякие кучи. А в этих кучах, особенно вот,
начиная просто даже с косой кучи, а амортизационный анализ нам, ой, как понадобится. Поэтому
мне уже и так начинает быть соблазна. А может вам дедлай их на неделю дать? Ну там, если всего три
задачи там, например, может быть. Впрочем, посмотрим. Не будем загадывать. И так, значит,
сортировочки. Ну, частично мы уже начали говорить о сортировочках. Да, так, ну да, честно скажем,
да, как вы уже поняли, презентация всегда с тех времен, когда у нас порядок был чуть-чуть
не такой. Ну вот, но не думаю, что вас это сильно смутит. Вот, но отсюда же и берется,
вот там, собственно, определение симптотик. В общем, не будем тут останавливаться. В общем,
мы тут уже ходили. Вот, но, собственно, пришло время узнать, а что же такое сортировка? Действительно,
постановка задачи. Ну, тут, на самом деле, постановки задачи нужно быть очень внимательными,
в зависимости от этого мы будем там решать задачу за самые разные симптотики, в чем выяснится,
что они могут появляться принципиально разными. То есть, такая самая абстрактная, одновременно
самая жесткая такая. То есть, дано N камней. Вот у нас, мы их вот так называем. Вот, и у нас
есть чашечные весы. Более того, мы не можем там взвесить камни в том плане, что не можем сказать,
что этот камень весит 5 храма, а этот 7. Все, что мы можем, то есть, все, что мы можем, это положить
камни, допустим, на чашечные весы, и они нам скажут, что вот этот камень тяжелее. Еще более того,
это все, что они нам скажут. То есть, мы там не будем понимать, что это тяжелее прям вот сильно,
потому что там эти прям весы перекосились, а тут качались-качались, и вроде вот чуть-чуть вот-вот-вот
вот это вот. Нет, такого у нас нет. То есть, с точки зрения программирования, удобно даже мыслить,
что это не весы, это черный ящик. То есть, знаете, там это, знаете, выделилось такие две полочки.
Ну вот, вы там кладете камешки, там черный ящик, там это помирал лампочками, там вот это, и сказал,
там тяжелее вот этот, и там стрелочка такая мигает. Вот, примерно так. Ну и возвращаю там камешки.
Вот, с помощью таких весов, так сказать, надо камешки упоря-до-чить. Ну, то есть,
формально говоря, предложить вот перестановку такую, что вот каждый следующий камень весит
там меньше, наоборот, больше предыдущего. И вот у нас возникает задача. Даже задача не столько,
как это сделать, но хочется понять, а за какое минимальное количество действий это можно сделать.
Причем тут сразу оговорка. А в каком смысле минимальное количество действий? Потому что
иногда можно отсортировать камни за ОАТН. Ну, в каком плане? В том, что давайте пробежимся по массиву.
Если выяснится, что он уже отсортирован, значит, мы его за ОАТН и сортировали. В этом случае,
получается, мы потратим там ОАТН действий. Или даже Н-1 сравнений. Потому что в качестве действий
мы здесь даже будем думать, а какое количество сравнений мы вообще можем сделать. Вот,
внимание, нот. Ну вот, спрашивается. Ну, конечно же, там такие базовые случаи, когда нас не
интересует. То есть, конечно же, нас интересует, чтобы у нас был какой-то алгоритм. То есть,
он там при каждых нот любые н ко мне отсортируют, но нам хочется, чтобы в лучшем случае он сделал
сколько-то действий, в среднем случае столько, а в худшем столько. И нам хочется, чтобы худшее
время было как можно меньше. То есть, как мы уже обсуждали, то есть ТОН это у нас максимум по
всем входам размера Н. Так что такая нот, постановка задачи. Ну вот, внимание, вопрос. Как же ее
решать? Как ее решать? Ну, почему его? Нет, ну, на самом деле возникает, как бы, ну, один из вариантов,
по крайней мере, абстрактно это решить. То есть, можно выражать алгоритм в виде там программы на
языке C++ или там у кого-то, может быть, когда-то было блок схемы порисовать. Вот кто-нибудь рисовал
когда-нибудь в школе блок схемы? Ого, вот, неплохо. Вот. Ну да, можно еще что-нибудь. Но, в принципе,
бывает еще, на самом деле, дерево решений в данном случае нам пойдет. То есть, что это такое? Он говорит,
так вот у нас, допустим, есть три камешка. Допустим, есть три камешка. И тогда сортировать мы их
будем так. То есть, мы возьмем камень номер ноль. То есть, помните, ноль, один, два. Это как бы номера
камешков, которые на них там написаны несмываемым маркером и, собственно, не стираются. Вот. И так
берем нулевой камешек и сравниваем с первым камешком. И тогда у нас два варианта. Либо нулевой
камешек окажется легче, либо первый. Ну, если нулевой, то мы идем по стрелочке влево. Если
первый, то идем по стрелочке вправо. Дальше мы видим, что мы сравниваем первый и второй. Например,
вот слева сравниваем первый и второй. Если вы видите, что первый меньше второго, то мы готовы вернуть
ответ. То есть, ноль, один, два. Ну, если оказалось, что нет, первый оказывается тяжелее не только нулевого,
но и второго, то мы в этом случае сравниваем нулевой и второй. И в зависимости от результата
выдаем ответ. Аналогичным образом устроено дерево и справа. Ну, то есть, видите, да, у меня, конечно,
дерево решение есть такой недостаток, что, конечно, для каждого n придется рисовать свое дерево. Но,
с другой стороны, заметим, что в некотором смысле дерево решение будет иметь отношение практически
к любому алгоритму. Ну, потому что, по большому счету, любой алгоритм, даже если вы там на C++
напишете, он все равно будет вынужден их как-то сравнивать. То есть, вызывать вот какие-то вот
подобного рода ифы. То есть, конечно же, сложная нота. Но, правда, в отличие от дерева решения,
мы здесь действительно сравниваем только сравнение. То есть, что нас теперь интересует? То есть,
нас интересует как бы для n камешков построить дерево так, чтобы его высота была как можно меньше.
Понимаете, да? И, по большому счету, на самом деле, любой алгоритм, который вы напишете на C++,
он может выдать вам соответствует такое же вот дерево решений. Потому что, по большому счету,
потому что, например, вы там можете просто на всех тестах по большому счету смотреть,
собственно, какие камни он вам предложит подестировать и, собственно, записывать что-то там.
Получается, ваш алгоритм что-то делал. Но, правда, единственная только разница в том, что здесь мы
смотрим только на сравнение, а при программе на C++ мы там еще что-то дополнительное в сравнении
с сравнениями делаем. То есть, может так случиться, что вы делаете O от N в сравнении, скажем,
но зато действие делаете N квадрат, потому что вы там любите копировать массив туда-обратно. Ну,
как-то, конечно же, что нужно сделать, чтобы сортировать два камня? Надо взять пассив,
значит, это скопировать его динамическую память, значит, удалить здесь, чтобы запустить рекурсию
на O от N, там найти эти два камня, сортировать, потом, собственно, скопировать их обратно. Ну,
может, у вас алгоритм устроен так, я не знаю. Ну, конечно, это сомнительно, конечно, что это будет
оптимально, тем не менее. И так, значит, еще раз, что у нас такое? Да, то есть, действительно,
в терминах дерева решений, как вы уже сказали, у нас вопрос, какова минимальная высота там по
ребрам, ну или там по вершинам, ну, ну там плюс-минус один, не важно, какая минимальная
реберная высота у нас будет, и мы ее обозначим за вот H оптимальное. Вот. Ну, конечно же, H
оптимальное у нас меньше либо равно T от N, соответственно, как мы уже сказали, но остается только,
но, как всегда, у нас будет в алгоритмах, нас устраивает, то есть нас, в принципе, устраивает
асимпатически точный ответ. Вот. То есть, очень хочется, то есть, в идеале очень хочется доказать,
что там, как всегда, H опт от N равен, скажем, О от чего-нибудь, а также Омега от чего-нибудь,
то есть в переводе коврят это от чего-нибудь. Ну, хочется найти для H опт и для T. Но для этого нам
нужны какие-то верхние оценки и нужны какие-то нижние. Ну, давайте посмотрим. Вот. Ну, давайте
начнем с верхних. Ну, какие у нас там, просто если мы начнем придумывать какие-то сортировки,
то там возникнут какие-то разные варианты. Ну, сейчас мы пробежимся по некоторым алгоритмам,
потому что, собственно, их воспомнить и точно знать, что они есть, надо. Чего? Где? Возможно. Ну,
вот. Так вот. Ну, значит, как же? Ну, вот. Ну, как у нас устроен selection sort? Ну, если очень вкратце,
то мы просто в каждый момент времени из там не отсортированных элементов выбираем минимальный
и дописываем его ответ. Вот. Ну, конкретно здесь, на самом деле, приведена реализация,
которая позволяет вам не пользоваться дополнительной по мячу. Вот. Ну, то есть вот,
на самом деле, примерно так. Вот. Примерно так у нас картинка может выглядеть. Вот. То есть,
видите, да? Кошмар. Тут чисел кешей даже я едва вижу, конечно, но, тем не менее. Вот. Но суть,
думаю, вы понимаете. То есть, да. То есть, в каждом момент времени у нас есть отсортированная часть,
уже первые несколько минимумов и все остальное. На каждом шаре мы во всем остальном находим вот
минимум, в данном случае, 45 и записываем сюда, сдвигаем границу. Все. Вот. Это, значит, такую
сортировку мы будем называть сортировкой выбора. Вот. Понимаете, да? Вот. Сортировка выбора. Да. Ну,
то есть, ничего сложного тут нет, но просто вот нужно знать, что вот такая сортировка есть. Вот.
Вот. Так что, если вопросов нет, то, как сказал бы классик, слюшайте другую сортировку. Вот.
Другая сортировка, это сортировка вставками. То есть, здесь уже немножко другое. То есть,
если раньше мы, то есть, в принципе, вот примерно то же самое, но если здесь мы на каждом шаге
искали минимум и дописывали его в конец, то здесь мы идем другим путем. Мы на каждом шаге пытаемся
вот взять вот этот очередной элемент и вставить его сюда. Как мы это делаем? Ну, просто идем справа
налево, там как-то жат, жат, жат. Просто ищем, в какую позицию вставить. Вот. То есть, делать мы это
будем, вот, то есть, если писать на языке прям С, прям вот совсем С, можно даже сказать олдскульный
Си совсем, то выглядеть это будет примерно следующим образом. Вот. Так что вот такая радость.
Ну, тут, так, тут понятно, что происходит. Ну, думаю, никаких проблем нет. Но, смотрите, казалось бы,
вот у нас есть две сортировки. Обе, очевидно, работают за квадрат. Вот. Но тем не менее у каждой есть,
там могут быть свои какие-то преимущества. Вот давайте проанализируем. Вот у инсершн сорта,
например, оказывается, что в лучшем случае, на самом деле, она работает за от. То есть, если нам
очень повезет, например, если массив у поря до чем уже, то она сработает, то она за линию быстро
это поймет. Вот. Правда, есть, конечно, небольшой минус. Небольшой минус будет заключается в том,
что если массив отсектирован по убыванию, то она, наоборот, будет это понимать очень долго. В
принципе, вообще можно сказать, что инсершн сорт будет работать, ну, в таком виде, в котором
мы написали, за количество, просто в точности от количества инверсии в массиве. Плюс н. Ну,
потому что свапов, потому что там свапов и движений будет ровно столько, сколько массивы инверсии.
Так, надо ли говорить, что такое инверсия? Да, нет, наверное. Ну, вот. Так, ну, все понимают,
что это не та инверсия, да? Нет, то есть мы тут не про диаметрическое преобразование там,
про как-нибудь там, это Z превращается в один, делить на Z, вот это все, боже упаси. Вот. Нет,
то в данном случае, я говорю, давайте на всякий случай поясним, может быть, для кого-то из телезрителей,
что в данном случае мы называем инверсией пару элементов в массиве, не обязательно рядом стоящих,
но таких, что элемент, который слева больше, чем элемент, который справа. То есть это называется
инверсия и в принципе легко показать, что вот insertion sort работает за o от n плюс количество
инверсий в таком массиве. Например, вот сортировка вставками в таком виде работает именно так. Ну,
конечно, у нее есть и другие варианты. Что же это за варианты? Ну, вот тут смотрите,
как интересно. Вот есть вариант, действительно, что мы можем, что на самом деле, если мы не хотим
прям за o от n искать, куда вставлять очередной элемент, мы это можем сделать за логарифом,
используя бинарный поиск. Ну, как бы понятно, n квадрат это нам, конечно, не справит глобально,
но у нас есть какие части? Есть части сравнения, то есть там сравнения, то есть
поиск, куда вставить, и есть собственно вставка. И в принципе часть сравнения можно реализовать
уже за n лог n. То есть в принципе обратите внимание, то есть у нас есть вообще алгоритм,
который умеет выполнять сравнение не более чем o от n лог n раз. Ну, при этом, правда,
при сваивании он все еще делает квадрат. Ну, правда, тут действительно разные вещи,
потому что если у нас задача скопировать там какой-то кусок памяти, то компьютеры часто используют
какие-то там низкоуровневые средства. На самом деле, это можно сделать достаточно быстро,
поэтому константа здесь, то есть, конечно, n квадратов никуда не денетесь, но константа может
оказаться прям, называется очень и очень маленькой. Ну да, ну при желании, конечно, если вы хотите
вставлять массив так, то вы, конечно, можете там дикартовый дерево какой-нибудь реализовать. Вот,
но до этого мы пока не дожили. Тем более дикартовый дерево нас интересует, потому что дикартовый
вероятностная структура данных. Да, ну вероятностный. Ну, вот ожидание времени работ любой операции
логарифом, вот так. Поэтому хотите надежности, пишите avl, ну или красно-черный. Вот, вам понравится.
Вот, а ну вы напишите, в общем-то. Нет, ну там ничего такого страшного нету, но вот тем не менее,
если это сортировки ставками, вот такая оптимизация есть. Вот, но вот, кстати, если так
посравнивать, прежде чем идти, давайте посмотрим на selection sort с этой же точки зрения. Давайте
посмотрим. Вот у нас insertion sort действительно есть лучший, в случае есть худший. Вот у сортировки
выбором, на самом деле, конечно, все сильно хуже, потому что заметим, что мы и в худшем, и в лучшем
случае работаем за n², то есть логаритм всегда работает за θ от n² без вариантов. Вот, то есть
видим, что в сравнении там будет n², копируем, вот в этом смысле, конечно, insertion sort сильно
лучше. Ну, какие еще варианты есть? Ну, конечно, знаменитый bubble sort. Да, возможно, для многих это
была первая сортировка, которую вы вообще реализовали. А потом сейчас проверим. Ну-ка,
вот кто, у кого первая сортируемая сортировка в жизни была именно эта? Так, хорошо. А у кого
это был insertion sort? Так, а у кого был selection sort? Так, то есть, а у кого был quick sort? Ну, мало ли.
А у кого merge sort? А кто вообще хотя бы раз в жизни хоть какую-то сортировку кроме std sort описал? А
какую вы писали? По-моему, тут не все руки подняли. Чего? А прям с него и начали, да? Да,
здравствуйте, дети. Это оператор if, это оператор for, а теперь пишем team sort. Дам так, что ли?
Ну, значит, действительно, у нас есть такой вот bubble sort. Значит, что он делает? Вот,
ну, в принципе, можно сказать, что это там, то есть где-то у нас действительно частный случай
сортировки выбором, а где-то и нет. Вот, тоже в некотором смысле, то есть на самом деле тоже мы
в некотором смысле будем искать массив, то есть искать элемент, правда, искать на этот раз будем
не минимум, а максимум, хотя можно, в принципе, и минимум. Вот, но фишка здесь такая более хитрая.
То есть мы будем здесь идти слева направо, просто пробираться по массиву слева направо и говорить,
так, если я вижу там, что элемент больше предыдущего, значит, я их свапаю. Значит, меняю местами. Ну,
то есть смысл оказывается тот же, потому что за каждую операцию, за каждый такой проход мы
гарантируем, что там очередной максимум, собственно, встал на свое место, это точно. Но это,
конечно, лучшая selection сорта чем? Тем, что продвинулись к своим правильным отметкам не только
максимум на каждой итерации, но еще может быть какие-то элементы. Вот, но тут вот можно сказать,
примерно так это будет выглядеть. То есть видите, да, то есть в исходном массиве окажется,
что у нас вот элемент, сначала у нас тут элемент 20 там доплывет, аж до сюда, то есть проплывет
31719, но 25 он уже не превзойдет, поэтому дальше пойдет 25, но он сразу наткнется на 35, но 35,
при этом свапает там 9 и так далее. Вот, ну то есть видно, да, сразу, что на каждый, то есть мы не
только нашли, что 35 максимум, но еще там какие-то элементы протолкнулись, поэтому в рандомном
случае это может действительно помочь. То есть худший случай, конечно, никуда не делся, то есть
если массив отсортирован изначально по убыванию, то, ну, конечно, вы от честного квадрата никуда не
денетесь. Нет, нет, нет, нет, нет, нет, вот обратите внимание, если раньше мы свапали только прям
точно, то есть как бы мы идем справа налево и так инверсия, свап, инверсия, свап, инверсия, нет,
все остановились, вот, то здесь это не так, то есть только, ну, то есть здесь это явно не так,
потому что вот обратите внимание, здесь вот 20, 25, там 25, 35 мы сравнивали и ничего, поэтому здесь
могут быть лишние, там какие-то лишние операции, гарантировать, что здесь будет сделано n лог n
сравнений, увы, нельзя, но количество свапов, которые выполняем, да, все еще количество инверсии,
это да, это правда, вот, это правда, это правда, вот, итак, но что же у нас получается, вот, пока,
если так подвести итоги, то есть мы в общем-то, ну, то есть мы рассмотрели три алгоритма и все эти
сортировки работают за квадрат, то есть получается t от n это o от n квадрат, да, но обратите внимание,
является, но точно ли это, непонятно, ну, то есть как, скажем, классик, но это пока не точно, вот,
вот, ну, более того, но какие, но что у нас, ну, вот, ну, что у нас еще может быть, то еще мы попутно
выяснили, что дерево решения, в принципе, может быть вполне себе высоты n лог n, в чем даже и selection
сорта, а может in section, как же никто еще эту очепятку не находил, как интересно, ну, хорошо, да,
действительно in section, давайте это сразу себе зафиксируем, in section, ну, вот, ну, вот, ну, насколько
эта штука точна, но тут действительно возникает вопрос, а можно ли придумать сортировку быстрее,
чем за n квадрат, давай, нет, почему, нет, смотрите, у нас, нет, высота не logarithm, а n лог n,
почему, потому что, потому что мы гарантируем, что, там, в любой, в любом случае мы сделаем не
более, чем n лог n сравнений, то есть, поэтому пока именно n лог n, вот, так, ну, в принципе, классический
вариант, конечно, сортировки за n лог n, это наш, это, конечно, его величество мерш-сорт, вот, ну,
в общем, алгоритм действительно достаточно простой, он базируется на том, что, если у вас есть два
отсортированных массива, то вы можете получить из них один отсортированный массив за линейное
время с помощью, ну, простого прохода двумя указателями, так, думается, там, думается, нет, смысла
прям принципиально это описывать, вот, в таком виде, но, впрочем, тут есть разные варианты, на самом
деле, можно написать вообще, там, мерш-сорт без рекурсии, вот, ну, в принципе, да, разбить на два
степенька, ну, например, можно так разбить на два степенька под массивов, но два степенька меньше,
но как можно ближе к нему, и чтобы каждый массив был где-то по одному, два элемента, каждый
сортируем там, как угодно, ну, как сортировать массив из двух элементов, ну, тут, да, не особы
варианты есть, да, вот, ну, а дальше там уже развлекаю, там можно уже развлекаться как угодно. Вот,
чтобы было совсем удобно, можно там добить массив до степени, там, по размеру, до степени
двойки и потом уже действительно сортировать, чем это будет удобно, что вы на каждом шаге будете
знать, что вы сортируете массивы. Сначала длины 1, потом длины 2, потом длины 4, потом длины 8 и так
далее. Вот по идее так конечно можно, но чаще конечно, то есть удобнее конечно запускать рекурсию.
Удобно конечно запускать рекурсию, действительно получается достаточно красиво, то есть делить
можно на не совсем там ровные массивы, за этим особо не следить. Вот здесь краткое
описание В-шторта, но окей, не думаю, что это прям принципиально. Вот, ну давайте смотреть.
Вот, ну давайте так, то здесь аккуратно скажем, что само по себе слияние двух массив работает
длин N и M, работает за тетто N плюс M, думаю, это факса мне не вызывает. Вот, ну количество сравнений как
повезет, ну в лучшем случае там меньше, чем минимум из двух массивов, но не обойдемся,
ну в худшем случае там получается N минус M плюс 1, но здесь несложно убедиться. Вот,
но отсюда возникает вопрос, за сколько работает сам мерч-сорт? Так, ну здесь мы, ладно, мы уже
там, ну здесь мы уже с этой шутки говорили, что мы уже там легко показать, что мерч-сорт работает
за ОАТН, но чуть сложнее действительно убедиться, что на самом деле нет, конечно. Вот, но на самом
деле я видел, что классическое доказательство по индукции говорит, что у нас это ОАТН логен,
собственно потому что эту рекурренту мы умеем так решать и аккуратно доказать, но это мы уже
обсуждали. Так, но отсюда, но что можно отсюда вывести? Какое следствие можно сделать? Можно
сделать вывод, что теперь ТАТН оценивается сверху как N логен, а теперь вот уже возникает вопрос,
а нельзя ли оценить как-то снизу? Да, ну можно гарантировать, что ТАТН равно ОМЕГАТН, почему?
Да, даже нужно сравнить хоть с кем-нибудь хотя бы один раз. А зачем? А вдруг у нас будет
такой мистический алгоритм, который в принципе по сравнивая все остальные элементы, на самом деле
сразу скажет, куда вот этому элементу вставляться надо, но на самом деле да, то есть здесь нужна какая-то
вот определенная аккуратность всегда нужна, потому что само по себе, что мы должны же мы
просмотреть элементы, это сам по себе не аргумент, то есть как бы аргументом это становится действительно,
когда вы просто когда мы говорим, что допустим у нас есть алгоритм, допустим у нас есть алгоритм,
который там в каком-то случае не взял какой-нибудь вот этот наш красненький элемент и его ни с кем не
сравнивал, тогда утверждается, что этому алгоритму можно подсунуть два разных теста, на которые он
выдаст один и тот же ответ. То есть получается так, пусть у нас возник какой-то тест, на котором алгоритм
не взял себе, не взял красный элемент ни разу, но убедительно сказал, куда его вставлять. Тогда
утверждается такое, а давайте попробуем скормить этому алгоритму тот же тест, но там этот красненький
элемент будет весить сильно больше или сильно меньше. Тогда этот алгоритм выдаст ровно то же
самое, потому что он детерминированный, но вот, но получает, но ответ, но ответ он явно выдаст уже,
выдаст ответ тот же самый, но тест изменился. То есть следовательно, где-то все-таки алгоритм
про ВА шелся. Может, но мы изучаем детерминированный алгоритм. Да, вот в этом смысле жесткость моделя нам
помогает, мы изучаем детерминированный алгоритм. Да, потому что отдельная будет песня, когда,
оказывается, алгоритм какой-нибудь не детерминированный действительно. Вот, но это уже отдельная песня. Да, то есть
таким образом можем видеть, что каждый элемент должен сравниться хоть с кем-то, и в принципе из
этого следует, что там скажем, что t от n это, даже можно сказать h, вот это оптимальная, не менее чем n
пополам. Да, пока даже не n-1, а n пополам. То есть как бы, чтобы довести его хотя бы до n-1,
нам придется с вами, конечно, поговорить, там придется еще как-то что-то поговорить о
тему того, что если нарисовать там, да, мы не знаем таких понятий, но если нарисовать крав в сравнении,
то как бы компонента связанности должна быть одна. Да, пока это все заклинание, конечно, да,
мы не знаем, что это такое, все это такое, да, якобы. Но тем не менее. Но, впрочем, это достаточно жесткие
оценки, потому что, на самом деле, то, что мы доказали не столько, что аж hello там, что высота
дерева должна быть, как минимум там, n-1, а на самом деле можно заметить, что, я, что даже,
то есть как бы когда мы говорим высота дерева, мы говорим максимальная высота, то есть максимальная
глубина листа, а на самом деле с того, что доказали, следует, что даже минимальная глубина листа должна
быть хотя бы этом и минус один вот это да но чем нот но тем не менее да хорошо оценка за линию
есть но у нас пока есть зазор оценка сверху n log n оценка снизу n как бы этот зазор схлопнуть
ну на самом деле да вот схлопнуть его можно вот таким простым естественным образом
вот да тут написан какой-то текст но на самом деле просто давайте сразу поймем сразу просто
увидим что там на самом деле написано она писана там следующие у нас есть двоичное
дерево что такое двоичное дерево то есть это подвешенное дерево так причем такое что у
каждой вершины каждая вершина либо лист либо у нее ровно два ребенка спрашивает а сколько у
такого дерева вот выделять простой плюс должно быть листьев но так их должно быть не меньше чем
почему потому что у нас n различных по большому счету ответов на задачу правда но помните помните
у нас что такое ответ у нас помните да ответ это у нас там это последовательность то есть это
вот перестановка камешка то есть получается листов должно быть не менее чем n но правда
видимо в дереве решений вряд ли будет больше потому что вряд ли вы найдете два листа с
одинаковой перестановкой вот так теперь внимание вопрос какова может быть высота дерева
минимальная высота дерева если листьев н фортрел да но у нас дерево строго бинарное
да так-то конечно высота бывает один это да как видите такая вот классическая борода такая вот
вот но действительно но если у нас есть если у нас действительно у каждой вершины два ребенка то
высота конечно не менее чем логарифом n факториала или корень из н факториала а чей не логариф
логарифа вот почему да может и может корень логарифа мало ли или логарифом корня
так на это но на этом уровне не больше чем два степени вершины чо у нас может на каждом
уровне быть малое количество вершины что так ну и так и
да да ну в принципе да действительно да можно и так спасибо да то есть действительно можно то
есть можно сказать так что действительно заметим что если у нас будет дерево высоты аж то тогда
утверждается что в дереве будет не более чем два в степени аж плюс один минус один там вот такая
цифра будет дад аж плюс один минус один просто не более вершины прям точная оценка вот но
соответственно вот ну соответственно если вы хотите чтобы высота дерева была аж то тогда получается
там должно быть хотя бы n листов то получается n должно быть меньше либо равно этой штуке но отсюда
собственно следует что аж это там порядка не там что аж это не менее чем логарифом n но даже
в нашем случае n а n факториал да да да да да да да да да вот она так возвращаемся на место вот
здесь по разному доказывать можно потому что у меня придiye было доказательство что давайте думать
вот сколько у меня сейчас под деревья листов если я сейчас n факториал листов тогда давайте
я сейчас пойду в какой-нибудь под дерево с наибольшим количеством листов тогда у меня их будет
там не менее чем n факториал пополам потом я там тут тоже спущусь куда-нибудь выберу где тут
побольше листов и будет менять факториал на 4 и так далее вот отсюда логариф тоже можно вычислить
но это уже там на ваше усмотрение можно и так таким образом получается что высота любого дерева
решений и может быть меньше чем двоичный логарифом от n факториала но с другой стороны легко
показать что логарифом двоичный n факториала это омега от n логан но собственно сейчас вы на
доске видите такой максимально простой метод как это сделать но ну скажи так конечно с оговорочкой
конечно там с оговорочкой что там дает пополам может быть нечетным поэтому там надо чуть-чуть
подробно писать но общую суть я думаю вы видите вот понятна
вот так что такая вот у нас и вот имеется красота так ну что есть ли тут какие-то вопросы
вот тогда что есть только что в сухом остатке имеем мы имеем ну скажем так в принципе
решенную задачу по поводу того что такое а шопт то есть мы доказали что оптимальное время
работы сортировки по камере в таком виде в котором она у нас тут есть это n логан мы доказали что
меньше не бывает а ровно n логан вот есть мэш сорт да это конечно не единственный алгоритм но
это но это у нас конечно не единственный алгоритм но собственно по камере он асимпатически
оптимальный вот что есть ли тут какие-то вопросы вот ну на самом деле ладно прежде
чем вот пока мы там не ушли куда-то дальше вот дабы уж примерно увидели куда ну конечно
хочется на всякий случай то есть остановиться на еще одной задачи связанной с мэш сортом
просто сейчас мы ее быстренько тоже поговорим потому что не хочется чтобы она там уходила
от нас папа но это как раз по поводу количества инверсий вот ну при ферда соцсетия вот бывает
такая задача дан массив найдите количество инверсий или что тоже то есть более точная
формулировка там мы говорим что вот у нас есть массив допустим там элементы индексируется ну
допустим с единицей там на самом деле можно с нуля это неважно 5 4 2 8 6 11 3 2 5 и мы говорим что там скажем
инверсии называются вот два элемента такие что более левой больше более права внимание вопрос
а сколько таких инверсий массиве нет это оценка сверху нам точное число просит да тут уже другая
постановка дан массив то есть понятно в худшем да в худшем случае сэзон по два это да в лучшем
случае 0 да но нам дан конкретный массив и нам конкретно просят так скажите это 57 вот или там
ну или 179 ну или сколько там их реально что рнд процент 4 чего да да да да да и с некоторой
вероятностью нам повезет да да как бы вероятность конечно потому что нам повезет крайне мало но
зато алгоритм завод единицы работает да да да да да да да да ну поэтому для этого нужно
звать какого-то фенвика там из америки вызывать да ну да ну конечно да можно а лучше а лучше
insertion sort а лучше вставками напишем ну по сути да потому что нет на самом деле тут действительно
иногда вот это вот иногда это действительно очень помогает на самом деле при решении задачи
на сортировку после действительно серьезно да что действительно удобно что то есть в принципе
верно то есть на самом деле в принципе верно что либо массив отсортирован либо найдутся ну
например два в чем даже просто два стоящих рядом элемента которые образуют инверсии и по идее их
можно находить и соответственно свапать вот понимаете да вот нет принципе некоторые задачи
на самом деле это даже помогает там соответственно помогает решать то есть когда там но то есть
обычно это но это это там будет какой-нибудь такой метод но так я сейчас слёту задачи не вспомни
жалко что там но действительно часто вот мета метод герой некоторые задачи как как опсимально
расположить элементы чтоб там какой какой-то функционал был хороший да как устроен метод
метод говорит что так отлично говорим что предположим что допустим у нас там рядом
стоит петь и васе для которых там верно вот это тогда их можно посвапать их уже не станет
вот доказательно хуже не станет вот но и тогда кажется что действительно если вы так свапые там
окажется что мы там свапаем свапаем выясняется что просто результате оптимальный ответ это
просто надо их отсортировать по соответствующему там параметрам но то есть ну пусть бы да мы
умеем для двух элементов сравнивать типа кто больше кто меньше давайте по этому параметру их
сравнивать вот ну в общем-то а что далеко ходить вот есть же вот это классическая задача такая
значит да так и называется хирус квест значит да давайте вот расскажу эту задачу потому что
очень популярная тут вот на как говорится даже на финалах чемпионата мира подсовывается оказывается
поэтому вот поэтому как бы такой баян знать надо вот давайте смотреть вот задача такая значит
будьте здоровы значит ситуация значит нам нужно дочь мы играем в какую-то компьютерную игру где
нам нужно победить м монстр вот но что значит вот но что значит победить вот ну в принципе то и
значит есть один маленький нюанс у нас есть хп то есть очки жизни вот изначально у нас этих
хп целых аж вот у нас есть изначально аж хп но проблема то что когда вы деретесь с монстром
вы хп теряете обычно да потому что не только вы его бьете но и он вас вот и принципе известно
что каждый товарищ допустим у вас тратит а и т хп но то есть если вы деретесь с сытым монстром вы
как бы в процессе там он вас бьет на а это то есть это означает что если у вас изначально аж был
ладно не а д ладно давайте д от слова дамаг так если я правильно понимаю значение этого слова
ну я просто не особо гаммер поэтому как бы могу что-то вот но насколько я знаю это называется
дамаг от слова damage вот соответственно по камере я себе так это понимаю вот и так то есть он вам
наносит какой-то дамаг если этот дамаг не меньше чем аж то это означает что в процессе битвы вы
торжественно погибаете но что такое погибаете когда если дрите больше либо равно аж то как бы
вы погибаете ну что такое погибайте ну и когда у вас там это там экран появляется каком-то
цветом там написано потрачено вот это вот все вот соответственно нет ладно и другая игра не
важно вот но но может так случая но вот но если аж у вас больше то вы побеждаете и не просто
побеждаете а получаете награду в виде аи того единиц хп то есть это означает что в случае
победы у вас хп как бы превращается в аж минус д и плюс аи условно и теперь вот вам вам дано
n таких монстров вот вам дано n таких монстров и возникает естественный внимание вопрос может
ли этих м монстров победить то есть потому что все что потому что вы в принципе вам нужно
конечно сразиться со всеми но у вас есть такая свобода вы имеете право выбирать в каком порядке
вы с ними драться будете вот спрашивается как же но как же понять можно ли это сделать если да
только вот такая задача поднимите руки кто сталкивался с подобного рода задачей неплохо
в чем он заключается
ну да ну да ну давайте ну да то есть ну можно называть да видим по разуму можно
звать но то есть действительно давайте то есть обычно метод звучит так то есть предположим
что ответ что есть вот какой-то ответ вот у меня есть там какие-то какой-то порядок монстров
которые дает нам победу да тогда вот хочется находить какие-то говорить что допустим вот
эти каких-либо двух соседей можно поменять местами и хуже не станет ну хуже не станет что как бы
если это была победа то если мы их поменяем местами то победа останется победой но первое
что тут возникает смотрите заметим что есть монстры которые в итоге нас прокачивают ну
то есть у которых вот это вот то есть монстры типа хорошие монстры когда аи ты минус дитая больше
нуля а есть монстры которые нас убивают у которых это меньше нуля но есть там равенство но это пока
локально да так вот выскакать первое утверждение что предположим что у меня здесь идет такой
убивающий монстр а потом дальше идет наоборот оживляющий монстр тогда я утверждаю что этих
монстров можно поменять местами то есть взять сначала оживляющего потом убивающего и хуже не
станет то есть как бы то есть как бы победный алгоритм останется победным алгоритм как я это
буду делать нет как я это буду доказывать ну можно расписать но на самом деле все что нам
надо расписать это то что вот этот гарантировать что если мы их поменяем местами то я смогу
убить сначала этого монстра потом это сетам не погибнув процесс да да совершенно верно да то
есть с одной стороны зависит этого монстра мы спокойно убьем потому что как бы если тут у
меня на этот момент хп как бы у меня больше нуля то как бы здесь у меня хп было еще больше поэтому
мы его убьем без проблем но другой стороны да но с другой стороны вопрос а убьем ли мы этого
монстра да тоже убьем потому что тогда мы его при будем начинать убивать при хп большим получается
чем вот эта позиция так есть понятно чем я говорю вот точно понятно хорошо а то как бы не говорите
потом что это господи там это понимает происходящие только 5 человек то есть там вот это там что-то
сразу это очень это какой-то очень высокий уровень господи я всего лишь 57 место в серосе и настолько
умные и там вот вот чтобы этого не было да или лучше сразу как идут или нот или наоборот
пусть если что-то непонятно лучше сразу прям взять преподаватель и трясти его вот так вот не вот
так вот так вот за шкирку пока не расколется да там про не расскажет вам просто вообще все что он
знает ну собственно вообще он за этим сюда и пришел в общем-то на самом деле ну все он конечно вам
не расскажет к сожалению ну просто но поверьте он это сделать только чисто в силу того что у
нас ограниченное количество времени вот если у нас было бесконечное время я бы конечно рассказал
все вот так вот значит соответственно но вот значит соответственно и так хорошо но тогда значит
вы говорим то есть получается тогда следующее что мы в опсимальном решении можем свапать то есть
у нас идет убивающий монстр а потом возраздающий монстр то мы имеем право их посвапать их уже не
сделав несколько таких свапов мы тогда приходим к тому что у нас есть решение что сначала идут
вот но там возраздающие монстры потом ну потом может быть идут несколько вот этих вот нейтральных
монстров и потом идут убивающие монстр вот то есть мы доказали я просто сейчас проговариваю
до формальную сторону вопроса то есть формально мы сейчас доказали следующее мы доказали что
если существует как бы способ победить то существует способ победить вот такого
вида понимаете да и тогда к чему это нас приводит это те но это те у которых как бы бонус
бонус которые вам дают меньше до мака вот таких я назвал как бы убивающий вот так так как еще раз
так вот себе а тут вот возникает мысль да почему-то хочется действительно здесь по
возрастанию дома то есть вот теперь вот этих строить по разрастанию до мака так ну давайте
думать вот предположим что у нас в оптимальном ответе здесь встретилось два товарища но у
которых сначала идет человек там с одним домом там допустим дитая потом идет представить там
товарищ с меньшим домом вот тут мы начинали с там аж три возникает вопрос верно ли что если пусть
у нас оказалось что дитая больше дыжит вот возникает вопрос можно ли верно ли что их
можно посвапать и хуже не станет но давайте проверять потому что у нас тут дитая дыжитая
ажитое что мы знаем мы знаем что аж 3-д это больше нуля то есть вот я так обещал знаем да ну вот
и также мы еще знаем что а штрих минус д и плюс а и минус дж тоже больше нуля но по чем это да
по чем это ревиально так да но еще мы даем самое главное что мы знаем на самом деле дает даже не
интересно то что мы знаем аи-тое больше дитая и там соответственно д ажи-тое больше дж так но
давайте смотреть хотим ну хотим мы на самом деле нам нужно показать что а штрих что наоборот если
мы их поставим вот так то есть тут будет дж-тое тут будет дитая да то есть мы наоборот хотим что
чтобы а и минус дж-тое больше нуля и еще мы хотим чтобы а штрих минус дж плюс ажи минус д и оказалось
больше нуля но так ли это так ну действительно заметим что так как даже имеет то есть так как
у нас аж 3 минус д и больше нуля то заменив д и на что-то меньше получим что-то больше ну а здесь
действительно еще проще аж 3 минус д и больше нуля когда мы прибавляем мы тут что-то положительное
так что действительно тогда отсюда следует что надо то есть если есть кто-то есть у нас
идет больше там боя там меньше дамаг за большим дамагом то их можно посвапать но тогда если
выполнить все свапы то получается что мы должны значит получайте всех товарищей отсортировать
по возрастанию дамака ну ладно по неубыванию но вот ну легко там по нот то есть отсюда то есть
получается мы доказали что если су оптимальный ответ существует то существует ответ в котором
сначала идут все оживляющие монстры все в порядке возрастания дамака вот потом все нейтральные
а потом в каком-то порядке все убывающие остается только понять как сортировать убывающих что-то
так не а нейтрально их тоже их по убыванию дамака сортировать или как или по или по
возрастанию или да ой все ли так нету нейтрально все равно конечно да дай не тогда с нейтральными
у нас все по барабану да вопрос как бы вот у нас есть вот эти убивающие монстры
да да ладно сейчас так парадить хорошо что мы хотим доказать давайте формулиров то есть
вы утверждаете что надо доказать что мы должны сортировать по убыванию дамака да ну давайте
попробуем так еще раз так вот давайте сделаем то же самое внимание внимание и так хорошо вот
у нас есть два товарища и выяснилось что допустим у этого у нас тут д это да и значит этого дж аж и
мы знаем что д и больше чем а и дж больше чем аж и чем еще знаем и неожиданно мы еще знаем что
д и оказалось меньше чем меньше меньше да чем дж значит мы хотим из этого сделать вывод что
их можно посвапать то есть мы хотим из этого вывести каким-то мистическим образом что оно
еще мы знаем что до аж минус д и больше нуля и что самое главное мы знаем что аж минус д и плюс
а и минус дж больше нуля и очень хочется из этого вывести что ну даже там аж минус дж больше нуля но
это ладно даже неважно важно что аж минус дж плюс ажи минус а и больше нуля но по большому
счету нам надо вот это вывести ну потому что понятно да нет это более сильные утверждения
хотя а нет неправда нет это не одно и то же да потому что тут зависит от да сейчас не мне
все это я зря стер извините извините извините извините аж минус дж больше нуля так ну хорошо
ладно аж минус дж это на самом деле похоже на правду почему но по большому счету смотрите
видите что мы тут здесь как-то куда-то опускаемся да стартуем с более низкой позиции чем аж вот
это да поэтому первая да а второе но там второе скажи так по крайней мере не очевидно
сейчас ну погодите давайте вот тут давайте тут внимательно подумаем может на самом деле очевидно
вот ну тут на самом деле как повезет дальше в принципе вот это неравенство оно отличается
конечно вот от этого только буквально тем что тут аито а тут ожито но действительно вполне может
оказаться что аито и сильно больше чем ожито и может быть значит оно даст на самом деле и
там как-то выручает хотя нет может но да может так оказаться что аито значительно больше ожито
даже при том что дж больше чем да и так но с другой стороны давайте нам тут предлагают
другое хорошо предлагается что допустим выяснилось допустим выяснилось тоже самое но неожиданно
теперь нам предлагается делать это по убыванию аито то есть неожиданно выяснилось что аито
так по убывания и ты да давайте да то есть предположим выяснилось что аито меньше чем ожито
и тогда получается так и тогда в этом случае хочется свапать так ну давай смотреть что из
этого тогда следует так но аж минус дж больше нуля дам уже выяснили что это правда так теперь
нам хочется аж минус дж плюс ожи минус аи больше нуля так но здесь это действительно хорошо потому
что это не нравится отличается этим токаритом но вот подставляя вместо аи ожи получается хорошо то
есть отсюда следует что получается как это не странно то есть надо оказывается сортировать по
убыванию ажички можно было кстати убедиться в этим другу и убедиться в этом и немножко другим
способом на самом деле надо было бы можно было вот давайте если вот нарисовать вот эту вот красивую
картинку да то можно смотрите вот мы тут стартовали с какого-то уровня аж и вот тут старта а тут
финишировали на каком-то уровне там аж один да ответить такая ведь на самом деле мы теперь
можем развернуть эту картинку и предполагать что наоборот а это дамаг а д это как бы
радость то есть профит и тогда то есть получится то же самое у нас тут требование что действительно
там то есть карбашки не должны нас падать больше нуля и получается что действительно симметричная
то есть картинка получается такая симметричная вот то есть вот еще такое можно увидеть да просто
вот такая вот есть красивая задача она иллюстрирует такой достаточно классический подход ну и здесь
конечно можно еще проговорить да что у таких задач конкретно есть преимущество что да если вы
там подумали что-то про сортировку то можно такую сортировку писать том там особенно в последние
минуты контеста там действительно подгонять компараторы типа написал компаратор там послал
так вася и хорошо давайте тут это вместо дешечку поставить ой ва 15 неплохо а давайте так давайте
подсунь вот это ой что рантай мэрор 37 а это вообще не компаратор господи ну знаете там бывает
проблема что если выяснили что компаратор он как бы там дает какой-то зацикл типа вася меньше петти
петти меньше там коле коле меньше вася и проблема вот то что то там теоретически может быть рантай
вот как же теоретически да но вот ну в общем случае конечно я бы то есть ну то есть я бы
рекомендовал конечно стараться прежде чем такое писать доказывать но потому что так угадать
иногда бывает очень сложно а доказательства том числе и способ придумать правильное ответство
ответственно пуши так что помню на какой-то на какой-то опенка писали несколько лет назад вот
было забавно да что там тоже надо было сортировать но иногда бы до следу казалось
какой-то не тривиальный компаратор там кто-то пихал не запихал то есть я там сидел думал и
висеть мне доказалось кто-то кто-то кто-то и студент восхищенно спрашивал тогда почему ты
пишешь вот это ну просто нет вот у меня просто доказательства не сходилось а тут сошлось ну
такая вот классическая но это не эта задача там конечно посильнее задача была вот я ее уже не
помню но и неважно нет ну да но нам нужно что вот в этом если мы сюда стартуем не сдает его
с дежитого то как бы то то на этом монстре мы не поднимем то есть мы пытаемся доказать что
если их поменять местами то как бы мы не погибли ну то есть мы здесь то есть надо по-хорошему
доказывать что мы и в других местах не поднимем но это и так очевидно потому что как бы
те кто был дальше у них и не меняя то был до этого ничего не меняется а те кто после
тоже ничего не меняется что того что мы их по сваппаем стартовая позиция для Ash Birds
уже не меняется формально вы должны были это сказать потому что по сути мы доказали
следов defense и то где мы доказали следующие мы доказали что если существует оптимальные
оптимальное какое хорошее решение то существует хорошее решение в котором значит сначала идут
возраздающие монстры отсортировали отсортированные по дамаку потом идут монстры значит у которых
дамак равен в этом премии и потом идут убивающие монстры и отсортированные по убыванию премии то
есть отсюда следует решение задачи то есть сортируем монстров там вот за инлоген вот по
вышеуказанному компаратору а потом что самое обязательно делаем надо пробежаться по массиву и
убедиться что мы не умерли то есть если мы убедились что не умерли значит мы выводим
ответ если нет значит мы с чистой совестью выводим там ноу солюшн ну потому для того вот именно
поэтому что у нас логика такая чтобы доказали что если существует хоть какое-то решение то
существует решение вот вот такого вида но если это что не значит ну да но
а как нет смысла как что бы доказали ну как бы мы доказали что если работе есть
нет я не знаю если сложно понять чем бага потому что тут как бы то есть просто как
казалось одного от логики есть такое что допустим мы доказали что если а то б да тогда если выяснилось
что небе то это автоматически влетелся с собой не а да нет чего и что но если она если бы уже
не вернулся значит но да нет просто но да нет в какой нет в какой нет пародии не нет нет тут
тут сейчас хочется разобраться с этой логически заковыкли потому что без нее там сложно будет нет
просто при при чем тот самый то нет если бы ну да то есть не данном случае как бы мы вывели что
если существует какое-то решение то вот это тоже решение так что поэтому если отсюда что если это
не решение значит то было тоже не решение да тут вот да так что такая логичность так но да так
что да что у вас там от логи было кстати ну ничего себе ничего не было 16 ну как это господи вы
же познакомились это из штриха до штрихов шейфера даже у нас стоит да вот они да вот они операции
мы мечты да ой но ничего вот будет когда вы будете сексиом все выводить вот это шикарно бы это
сам билет о это вам понравится я надеюсь вот но хорошо ладно так ну ладно как-то не дам мало
кто помнит но начали мы вообще задача поиски количество инверсий в массиве нет но это нет
просто это надо обсудить но потом как бы мы стали обсуждать про свапы я вспомнил про эту задачу но
это очень хорошо что мы ее о trick да это вот подход действительно важный так что надо будет вам
что-нибудь такое дать вот но ладно давайте возвращаемся то есть возвращаемся из
ответвления да это что-то из цикла давайте вот давайте пр übrig flattering дальше давайте на
этом здании посмотрим вот это окно давайте так смотрим в окно ой там вотunder ажи ой
смотрите separate этого окна там замечательный садик давайте посетим этот садик так вот
Возвращаемся из садика, смотрим в окно, точнее на окно, да, как-то так немножко получилось, но здорово стоит как-то интереснее, чем это тупо, это вот идти вот таким вот образом по там вот фиксированной вот дорожке вот этой вот нарисованной, вот, соответственно.
Ну вот, значит, смотрите, как найти все это количество таких инвекций? Вот, ну, найти их можно, но на самом деле, можно, конечно, там всегда привезти какого-нибудь друга, которого зовут Фервик, или деревоотресков еще какой-нибудь, или АВЛ, ну, просто деревоотресков, ну, просто деревоотресков, ну, просто деревоотресков, ну, просто деревоотресков, ну, просто деревоотресков, ну, просто деревоотресков, ну, просто деревоотресков, ну, просто деревоотресков, ну, просто деревоотресков, ну, просто деревоотресков, ну, просто деревоотресков, ну, просто деревоотресков, ну, просто деревоотресков, ну, просто деревоотресков, ну, просто деревоотресков, ну, просто деревоотресков, ну, просто деревоотресков, ну
просто деревоотреска там еще сжатия координат какой-то придется писать там, ну, в общем,
но вот, но мы все это не знаем, что это такое, поэтому как бы просто в данном случае есть более простой мета,
На самом деле мы отсортируем этот массив с сортировкой
слияния.
Вот.
Но просто в чем у него будет заключаться фишка.
Дело в том, что разобьем массив на две части.
Ну, допустим, вот на такие.
Тогда у нас, смотрите, есть три типа инверсий.
Есть инверсии, которые находятся целиком с этой
стороны.
Ну, то есть вот 5.2, например.
Есть инверсии, которые находятся целиком справа.
Ну, тогда, скажем, 11.3.
А есть инверсии, в которых один элемент находится
здесь, а второй здесь.
Так что вот такая вот красота получается.
Вот.
Что же получается?
Получается примерно следующее.
То есть, ну, то идея такая, что давайте первый и второй
тип мы найдем рекурсивно.
А для третьего типа все очень просто.
На самом деле, просто для каждого элемента слева
нужно понять, скажем, сколько существует, сколько в правом
массиве элементов меньше его.
Как же это сделать?
Да очень просто.
Вот.
Они у нас в рекурсии уже отсортированы.
Отсортированы здесь, отсортированы здесь.
И тогда, оказываю, нот.
И тогда вот идея оказывается очень простой.
Мы начинаем сливать эти два массива.
И вот видим, например, так, тут двоечки.
Ну, давайте скажем, что сначала у нас будет более
левая двоечка.
И идем на четверочку.
Так.
Но что мы теперь видим?
То есть видим у нас четверочка больше двоечки, поэтому
записываем двоечку, записываем троечку и остановились на
пятерочку.
Но тогда из того, что указатель сейчас указывает на пятерочку,
вот мы только сейчас двигаем четверочку, мы понимаем,
что у нас в правом массиве было ровно два элемента
меньше четверочки.
Поэтому к ответу мы в этом месте два и прибавляем.
Понимаете, да?
Вот.
Поэтому прибавляем, делаем там плюс два к ответу, а
тут мы сделали плюс ноль к ответу и, значит, сдвигаем,
так, пять-пять.
Но в пятерке, смотрите, тоже мы видим, пять меньше
либо равно пяти, поэтому здесь тоже плюс два к ответу,
два этих элемента меньше.
Так, ну здесь сдвигаем.
так здесь этот указатель сдвигается там пишем 5 пишем 6 там смотрим 11 8 меньше 11 поэтому здесь
к ответу плюс 4 вот и получается что инверсии третьего типа у нас 8 штук то есть получается
видите то есть мы просто взяли мерш-сорт и там асимпатически бесплатно на него навесили маленькое
дополнительное действие и нашли количество инверсий за n log m но то есть вот тоже это еще
один такой вот классический достаточно нет который тоже хотелось бы конечно знать так
ну что если тут какие-то вопросы что где в двойке плюс на четвертой плюс два нет это эти плюс двойки
они не под двойкой а над пятеркой почему над пятеркой потому что в тот момент когда мы двигали
указатель второй указатель указывал на вот эту пятерку это означает что слева от него были два
элемента которые меньше вот то есть нет это вот это плюс два это над пятеркой к вот этим элементам
это имеет отношение так ну хорошо если тут так ну что есть ли еще вопросы так ну что ж тогда так
дозикает вопрос так что у нас дальше так дальше у нас куча так нет пока нет а ну ладно нет ладно куда
куча это да да ну куча это тоже метод но просто скажем так просто как думаете имеет смысл сделать
нет вот нету я проидываю что до формально до конца первой пары осталось ну там 7 минут но
в принципе мы тут вольны можем сделать можем сделать перерыв там чуть раньше а можем сделать
перерыв чуть позже так разные варианты хорошо кто-то тоже взял перерыв чуть раньше так кто-то
тоже взял перерыв чуть позже да но я не знаю нет визуально ручить больше да чуть но больше ладно
куча так куча хорошо ну ничего страшного господи все равно отдохнем так значит смотрите так казалось
бы причем тут сортировка но действительно у нас иногда высекает такое желание что то есть у нас
вот возникало желание например в инсекшен сорте в селекшен сорте доставать минимум да
очень но точно как хотелось минимум или максимум и возникала конечно мысль а нельзя ли как-то
организовать данные организовать данные да таким образом чтобы доставать этот максимум было
чуть чуть побыстрее очень сильно они как это у нас водится за линию вот как же это у нас это сделать
сделать очень просто ну как просто вот и методы разные но базовый метод так такой это величество
двоичная куча так а ну-ка давайте сразу тест поднимите руки кто хотя бы раз в жизни реализовывал
это как своими руками нет не смысл там использовал приоритет и у вас мысли вот писал своими руками
да а понятно примерно примерно половина господи си плюс плюс возвращает число вот я не знаю вот
я в ваши годы знаете я на паскале писал а там и стояли нету там кусор надо писать самостоятельно
там вот это надо было писать самостоятельно вот ой кошмар так что мне приходилось это все сидеть и
писать то есть я не знаю да потом дома паниковали где я нет ну да ладно расскажу эту байку потому что
тоже потому что как я люблю эту байку ситуация была такая то есть приспев на дам да я участвовал
в такие стародавние времена когда паскаль был разрешен а некоторые туристы звать там
звать умели это там выигрывать три международа подряд на паскале на самом деле это буквально
вот но вот нет то есть это но это как бы реально кинать короткий тогда выигрывал да вот значит
соответственно вот и вот и вот и поэтому часто преимущество на олимпиаде давали задачи в которых
там и стоять все плюс плюс и преимущество не дает вот то есть ну то сейчас сейчас уже постепенно на
это забили но вот но все времена вот было так но раз жизни на московских сборах значит далее
там что-то какой-то лекцию на ст и потом собственно какой-то контест на нее вот но у меня была
проблема да я не как бы не владею все плюс плюсом поэтому я там выбрал какую-то одну задачу ну там
и радствую весь контест порешал но вот она не решила она не дарит там не дарешалась поэтому
после контеста я еще там чтобы некоторое время сидел там что-то дебаггл дебаггл что-то смотрели
какие-то тесты очень до дебаггл приезжаю домой дома все в панике потому что дело в том что
просто текущие результаты каждых контестов они как бы были опубликованы и дома за ними следили
поэтому что видят дома начинается контест начинаем минуты с 10 там все начинают активно
задавать задача а меня нету и так до конца контеста и нету вечера в нужное время ребенок
не явился что случилось но вот да ответ называется далее стоит дали контест на
истрель да вот да сейчас да сейчас такая ситуация невозможно в принципе но часто да ну сейчас
вообще все еще хуже на международной 5 по информатике уже запретили даже джаву да то все там теперь
единственно разрешенный язык c++ все ладно так и быть можно си все то есть но там они это просто
шерем то по каким-то там подно там они по техническим уже причинам сделали они по популярности языка но
вот соответственно так что все так что как бы хотите побеждать в школьных олимпиадах знаете
c++ вот хотите побеждать в судейских олимпиадах ну ладно так и быть можете учить джаву вот ну ладно
формально как я уже говорил можно учить и плюс плюс джаву и питон гарантируется что на двух
третях из этих языков любую задачу сдать можно да мы помним вот да ладно все байку рассказал
ладно беремся но так вот но просто это приводило к тому что вот подобные в роды вещи приходилось
писать сами но в общем-то это не сильно сложно делается и так что вообще такое двоичная куча так
что пока вот кто не воспомнил собственно тут уже наверное воспомнил пока тут рассказывал там
какой-то байку что что такое двоичная куча это когда мы располагаем наши n элементов в каком-то
вот такого рода виде но например вот если мы говорим о куче на максимум вот в данном случае
изображать куча на максимум да то есть мы рисуем двоичное дерево максимально упиханное по глубине
выражаясь олимпиадным языком то есть максимально право ты идеально то есть сделали вот во-первых
минимальное число количество уровней это раз во-вторых мы хотим чтобы на предыдущем уровне все
было заполнено а листы тут заполняли слева направо то есть заполняли короче так-так-так-пам и так
далее но при этом мы не просто хотим заполнять так алименты мы еще очень хотим чтобы каждый
элемент был больше своих детей ну и соответственно меньше родителей то есть вот такая структура данных
вот очень что-то уметь организовывать элементы так то есть понятно это не совсем сортировка то
есть как бы неверно что элементы из stronger вот так число вып 건�소리 будет
сортиров н потому что там должен ли быть этого или этот элемент больше этого да должен ли
быть этот элемент больше этого да должен ли этот элемент быть больше этого яlaughs
то есть они тут но вот вот девятка пожалуйста вполне себе меньше десятки и что это не волнует и
и нас тоже вот значит чем нам нравится такая куча но тем что очень удобно хранить ну как
ее хранить ну конечно опытные люди конечно скажут ну все нормально на указателях что почему бы
в общем-то и нет и в общем-то многие кучи мы будем действительно хранить на указателях ну или там
на каких-нибудь их заменителях там естественно вот это все но на самом деле конкретно в данном
случае в этом нет необходимости как жалко что на этой доске нельзя маркером писать нет уже
просто нет ну как сказать да но проблема да проблема в том что стереть нельзя да писать
можно стереть нельзя да вот но в данном случае фишка в том что куча что такое вот что в данном
случае элементы можно запихнуть массив так что на них очень удобно смотреть а именно давайте
их просто пихать так что это будет первый то есть давайте у нас если мы сделаем вот это все в
один индексации да то у нас тогда это будет 1 2 3 4 5 и 6 7 8 9 10 так ладно раз тут нельзя давайте
сейчас это так ладно проверим может дайте как ведь ты нарисуешь что-то на доске потом выяснится
что ты-то уже давно сделал нет не сделал хорошо вот значит будем рисовать на доске там 11 9 там
соответственно 10 5 6 8 а тоже в какой-то момент презентации заканчивается потому что это обнаружилось
что без презентации рассказывать будет медленнее и как следствие понятие вот вот вот допустим куча
у нас может выглядеть примерно вот таким вот образом но вот оказывается давайте попробуем
нарисовать индексы вот утверждается надо просто положить эти элементы в массив с индексами вот
такими как это называется в этом в этом месте удобно быть пасколистом и как бы но ты как
раз радоваться что очень удобно что элемента надо с единиц сохранить а не с нуля вот но на
самом деле ладно языке си конечно у вас тоже есть там простые технологии как сделать массив в
котором индексация будет с 57 до 179 делали когда-нибудь нет знаете как нет то идея очень
простая если вы вот смотрите вот паскали если там можно завести там допустим массив там пишется
так там а рэй там 57 пум пум 179 там там ов там лонгинт но лонгинт это аналог и на все плюс плюс
допустим да то есть это означает что вы к этому массиву обращаетесь при чейка минус 57 по 179
обратите по 56 будет вам рантай да значит смотрите как сделать то же самое всях сейчас это делается
предельно просто смотрите значит все всях делается так значит пишем значит инт значит
уйти от там 179 минус 57 плюс 1 вот это мы завели массив вот такого размера да а теперь пишете
звездочка а равно что уже догадались что я сейчас напишу ниже я почекаю а минус 57 все но зато
теперь вы да вы теперь в паре валидно можете писать а там я не знаю 103 и обращаться будет ровно
да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да
oyuад есть обратишься не по если тmac будет не о 57 нетger но он там в знак вы дотам складывается адекват pastry и проблема не ну как сказать нашу так что поэтому все плюс плюсе бывает пишут а минус 2 ela и все нормально а ещё пишут минус 2 а это тоже работа такт лад은 до это я конечно да это я коншу это полю сgmentки м机 호ар microbiota Youth having a financial
это в полю шутки мещерина который должен должен вам то все рассказывать но это я так проанонсировал
так пройдите не расслышать ребят потише пожалуйста там был вопрос я не слышать
да ну как это с плюс плюс как бы как бы вы сами пишите полностью свой ядерный реактор и только
вы отвечаете за то что он не рванет вот но в принципе да вот как бы такие возможности есть
но ладно все это это конечно да не немножко дай так как бы будет у вас все гиси плюс плюс как бы
в какой-то момент будете обсуждать указатели или вы уже начали их обсуждать но вот начнете их
обсуждать собственно там понятно мещерин вам все это подробно расскажет естественно
ну вот это вы тоже подробно все вернемся к делу ладно значит вы говорили о массиве из один
индексации значит смотрите но значит что какой у нас почему мы хотим хранить именно так а потому
что очень удобно оказывается что это элемент у этого элемента оказывается дети в точности 2 и и
2 и плюс один очень удобно а родитель и пополам 2 круглёный вниз естественно то есть это очень
то никаких указателей не надо для каждого элемента вы тупо знаете где у него там родители ребенок
там вот это вот все бла бла бла вот так ну и заодно мы еще знаем где у нас максимум есть у нас
куча на максимум максимум в корне это мы точно знаем так но возникает вопрос зачем нам ну как
всегда когда у нас возникает структура данных то сказать два вопроса как ее построить и зачем
оно вообще нам понадобилось то есть зачем нам нужна эта сферическая куча вакууме
значит сферическая куча вакууме у нас получается такая ну вот значит сферическая куча вакууме
получается такая ну пока но вот так ну здесь ладно тут это я уже сказал она пойдем дальше
так но в принципе оказывается куча оказывается там обладать таким свойством что если меняется
один из элементов то конечно свойство нарушается но его очень легко поправить потому что есть у
нас исправился там какой-то один элемент где-то в середине то если он увеличился то можно вызвать
функцию севта в которой будет его подымать и а если он уменьшился то наоборот всегда как это
будет выглядеть вот но например но например вот функция всегда вот она да то есть оказывается
что действительно допустим у нас какой-то элемент вот где-то середине кучи взял и уменьшился но
это вопрос насколько потому что если он впервые здесь 9 уменьшился на 8 с половиной то ничего делать
не надо правда потому что этот элемент все еще остался но так или иначе остался меньше родителя
но он все еще остался больше детей поэтому еще делать не надо но что делать но что делать если он
оказался меньше своих детей но тогда идея простая то есть давайте вот тут что-нибудь там скажем что
допустим у нас тут оказался вместо девятки появилась допустим появился петачок и у меня
есть дети четверочка и восьмерчик и вот оказалось что я меньше какого-то ребенка чем не делать
но надо выбрать максимального ребеночка да допустим если нет шестерчика то все равно выберу
восьмерчику и по сваппаю тогда смотрите что то есть видите тогда этот элемент все еще остается
единственным у которого могут быть проблемы ну что восьмерчика очевидно все еще меньше родителя
но правда у петачка теперь есть дети которые тоже могут казаться больше например это могут
дети вполне себе быть там 7 и 4 кстати до упорядоченность не обязательно но делаем
тоже самое тут у нас петачка отправляем вниз семерчику повышаем но и здесь наконец и в
какой-то момент обнаружу что что либо детей нет либо все дети меньше там может быть что остался
только один ребенок он меньше и в этом случае тогда мы говорим что ура все в порядке то что у нас
потому что это был единственный элемент каждый момент времени с которой могли быть проблемы и
проблем больше нет вот то есть вот такая вот операция сифт да он работает она за какое время
ну за высоту дерева за высоту кучи высота кучи логарифом так чтобы это хорошо отлично то есть
оказывается и построив кучу любой элемент можно за логарифом уменьшить но давайте сразу скажем
что а можно и увеличить то есть наоборот но тогда просто если мы там например жила была девяточка
вместо нее стало 13 а был у нее родитель 10 то ну здесь делаем тоже самое но вверх да то есть
как бы теперь тут пишем 10 тут 13 смотрим тут родителя там тут родитель 12 ну значит тут
13 тут 12 то есть свапаем ну и так далее понятно так понятно или на подробнее расписывать вот это
операция сифта я просто тут опасаюсь немножко что как бы операция сифта тут немножко позже
идет но пока мы видим что по коду на самом деле тут ничего сложного нет вот да ну здесь вот
аккуратненько да то есть там но то есть код можно писать вот таким вот внезапно рекурсивным
образом да можно реку до данного случая сказал даже нужно не рекурсии но просто знаете иногда
рекурсивная логика помогает потому что логика здесь такая смотрим на детей находим максимально
максимум из элементов и того left и right но здесь написано плюс один плюс два потому что здесь
все-таки в ноль индексации куча вот но выясняется что если оказывается этот наибольший элемент не
мы только что надо сделать надо посвапаться с этим ребенком и делать и собственно пропить
вниз уже его ну то есть можно в принципе так тоже мысли понимаете да вот то есть конечно же это
не оптимально вот но здесь еще кажется вот так а вот кто стал с такой книжкой и с книжкой как
книжка елена владимирна андреевы программируй мне так просто программируй мне так сложно
да часто но нет ну собственно нет величая кишка просто по-моему в ней просто подсмотрят эти вот
такая иллюстрация почему вот так писать не надо смотрите ситуация представьте себе представьте
себе значит вы живете в городе в котором все соединены домашние телефоны вот и но вот и вы
значит и у вас есть какая-то цепочка то есть скажем вот у вас есть телефон друга и вы знаете
что друга есть телефон следующего друга и так далее но до какого-то момента то есть у какого-то
очередного товарища следующего телефона нет вот ну вы знали как-то откуда-то знали что там
с небес по факсу вам прислали информацию что вот такая ситуация имеет место быть и вам захотелось
узнать а какова длина этой цепочки значит как это сделать значит метод цикла вайл вы берете
бумажку берете карандаш звоните своему другу слушай а вот я следующие есть есть так хорошо
значит мы там значит пишем единичку а может подсказать номер этого следующего могу но могу
значит вы записывайте номер на бумажке значит спасибо но спасибо давай пока кладите трубочку
значит набирайте этот номер вот но вот алио привет слушай а ты там последний списки он нет
она так вы быстренько во первую стирайте единичку пишете двоечку есть рейте старый номер ага
слушайте а этого санат следующий будет слушать у тебя но да да да и следующего ну пожалуйста и
так далее ну так прогуливаетесь по списку и вы знаете с помощью одной бумажки собственно
спокойненько выясняете длину списка а если вы записывали не стирали старые
номера вы еще и там список номеров получили но это уже мелче но так при
списке за от единицы бумажки в принципе и ноты собственно вы все сделаете теперь
рекурсивный вариант да а леа лася я слушать а у тебя следующие списки есть есть
а сколько у тебя там а сейчас значит он берет мобильник и начинает звонить то
есть да вы да вы конечно действие конкретно вы конечно действие совершили
меньше но на телефонной станции мог случиться врал если я больше не на
списка больше чего-нибудь соответственно то есть да то есть
обрететесь как бы получается из-за того что вам тут захотелось тот поиграть в
рекурсию на самом деле называть вас там по там пол вы там отвлекли полгорода от
важных дел что вы видите полгорода не просто отвлекли именно висит то есть
одно дело ватник на секундочку да а другое дело тут вот полгорода чем самое
страшное что у каждого заметьте что если так вы еще делали за от единицы
бумажки то-то у каждого теперь бумажка есть и каждый будет что-то записывать об
том возвращаться как бы и вам что-то сообщать вот потому что а действительно
вообще просто замечательная иллюстрация мне вот очень понравилось
в чем действительно она хорошо или строить что помните когда вызываете рекурсию на
это тоже тратится память потому что вот этот стэк функции которые у вас
работают он тоже где-то хранится вот поэтому при прочих равных конечно при
выборе рекурсии или не рекурсии лучше конечно выбирать не рекурсии то есть в
данном случае лучше конечно вот это написать вайл вот но это вот просто
действительно очень красивая такая штучка так что вот так что не знаю вот
так что такая вот замечательная штука вот но но так или иначе севда он вот
устроен именно таким образом на хит соответственно а а картинки все-таки
были а я и а кошмар ну а не ну картинки красивые ладно мы уже все обсудили но
тут оказывается просто есть маленькая приятная вещь зачем она значит что
севда он оказывается нам неожиданно помогает следующим образом говорится вот
у нас эту кучу надо как-то построить вот даны n элементов хочется из них
хотя бы кучу построить как это сделать а оказывается неожиданным образом давайте
просто запишем все элементы в массив тупо с первого по-энной и для всех
элементов сцен пополам минус один значит по один тупо вызовем севда он
это утверждение что во первых будет ну там ну ладно простое утверждение в
результате получится корректная двоичная куча вот это понятно почему ну в принципе
логично да потому что я утверждаю что после севда он а ты на самом деле у вас как бы
получится по камере под дерево с корнем в этой вершине будет корректной двоичной
кучи ну понятно почему да потому что непосредственно перед этим запуском у
вас было значит и та вершина на которой висели две корректные кучи значит получается это куча
с у которой единственный неправильный ответ коррект значит вызываем севда он равнуемся
понимаете да вот вот но значит есть такое теперь вместили но но оказывается еще более там уже
менее очевидное утверждение оказывается это работает за линию то есть вам могло показаться
что там кучу можно построить только за н лога но нет оказывается построить кучу можно за линию
но давайте разбираться а почему так нет это нам принципиально потому что у нас вообще если
мы просто рандомные элементы положили у нас куча вообще некорректная то есть как бы нам нужно
именно в этом порядке классе в дауне для того чтобы гарантировать что после сева севда он из этого
элемента по дереве с коргем в этом элементе у нас теперь корректная куча имеет место быть вот так
что это важно но давайте думать так спрашивается почему же у нас это работает за линию давайте
думать так на часа треть у нас е что у нас имеет место быть так у нас есть какая-то куча там
пэм пэм пэм пэм не буду даже круглежки рисовать так то давайте я тут еще порисую чуть-чуть да вот
как это да вот ну и тут сколько-то элемент но давайте вот так но давайте так давайте
сейчас для простоты можем давайте предположим что у нас тут на самом деле там вот на нижнем
уровне заполнено все вот но поехали значит смотрите тут у нас один элемент тут два тут
четыре и так далее и так далее и на нижнем уровне их оказывается два в степени аж ну пусть
меня аж будет от нуля до там чего-нибудь так но и теперь давайте думать ну и паря нот но понятно
что n равно в данном случае получается это вот в идеальном случае такое идеальном случае высоты
аж n равно два в степени аж плюс один минус один понимаете да но можно в принципе да но еще можно
сказать что это разно тета от 2 степени аж в общем-то не принципиально так вот теперь давайте думать
значит мы запускаем севдауны за сколько сколько они работают но заметим здесь мы делаем вот два
степень аж мы делаем но даже 0 действий мы даже не запускаемся до условно но на следующем
уровне тут мы делаем одно действие тут мы делаем два действия три действия и так далее и здесь
аж действие да то есть получается время работы можно оценить как два в степени аж минус один на
один плюс два в степени аж минус два на два плюс там два степени аж минус 3 умножить на три плюс
и так далее плюс один там два в степени ноль умножить на аж или что то же самое просто сумма
по всем и от единицы до аж два в степени аж минус и умножить на и да правильно но то есть это
мы же как раз то есть получается при дам ты идем получается мы вот в этом вот порядке идем
ну все ну посмотрите вот с элементов нижнего уровня запуск оценит смысла да и так теперь
остается только оценить а чему равна вот эта сумма так но это важная математика как бы ее тоже
полезно уметь хорошо схлопывать ну правильно я конечно начнем с того что давайте вынесем два
степени аж один аж и поделить на два степени вот спрашивает и чему равно и поделить на два
степени может бесконечности какой-нибудь или ашу да интегрирование так что у вас сейчас на
так что у всех по-разному да ну понятно но нет но на самом деле смотрите нет сложить и оценить
пока им это доказать что этот ряд сходится какой-то константе можно гораздо более
простым образом давайте просто смотрите мы не я просто выпишу элементы и смотрите каким образом
значит одна вторая встречается один раз да значит дальше у нас 2 2 1 четвертая давайте
поэтому я напишу 1 четвертая ладно не так 1 четвертая и 1 четвертая тут получается 1 восьмая 1
восьмая 1 восьмая тут получается 1 16 1 16 1 16 1 16 ну и так далее то тогда смотрите да у нас
какой но смотрите в этом этот столбец у нас очевидно меньше либо равен единице да вот
этот столбец меньше либо равен 1 второй вот этот меньше либо равен 1 четвертый этот меньше
либо равен 1 восьмой и так далее но вот это вот сумма верхних оценок даже если она бесконечная
она не бесконечная, но она не превосходит 2. То есть вывод, что эта сумма не больше 2.
Чего взяли? Так что вот такая радость. Вот эту сумму есть просто более простой
способ убедиться, что это констант. Так что вот оказывается, что построить кучу можно за линию.
Что еще с ней можно делать? Можно брать элемент и его изменять, то есть увеличивать или увеличить.
Это мы умеем делать за логарифом, но, наверное, самое интересное, что мы умеем делать, это добавлять
элемент. За какое время мы можем добавить элемент в такую кучу? Просто за логарифом,
как сказал бы генерал Иволгин. Кто знает генерала Иволгина? Который Михалыч? Нет,
который особенности национальной охоты. Ну, который это за справедливость или за красоту,
за логарифом. Как добавить элемент в кучу? Надо просто в соответствующее место его поставить
и после этого вызвать сифтап, вот вам и логариф. Так, ну что еще можно из кучи сделать? Так,
ну ладно, давайте тут уже, наверное, написано. Так что, если что, куча строится вот так. Не
перепутать. Можно делать то же самое с сифтапами, но там, очевидно, логарифа от Н не получится.
Да, ой, вот то же самое доказательство, но ладно. Да, как это называется, тоже привет от моего
великого предшественника, если что. Так что, если там будете работать в Яндекс.Такси,
где-нибудь вы строите встречу с такого человека, как Степан Мацкевич. Так вот, он был моим
предшественником на посту лектора по алгоритму в продвинутом потоке. Так что,
будете работать, встретитесь обязательно. Вот, нет, Яндекс.Такси не путайте, немножко другое.
Ну, я не знаю, может, у меня, конечно, устаревшие сведения. Когда мы вместе с ним работали,
на самом деле, когда-то он работал в компании Абби. Потом из Абби он перешел в Яндекс.Такси,
но больше я пока ничего не знаю. Но, вроде, до момента прошлого года он там был. Так что,
собственно, если пересечетесь, увидите, передавайте привет. Ну, а что нет, пойдете там
стажироваться куда-нибудь. Я вас знаю, сейчас пойдете куда-нибудь летом стажироваться,
чтобы отдыхать нормально. Ну, а почему бы нет. Так вот, ну, да. Ладно, так, ну, тут мы уже сказали,
как добавить. Да, тут все просто. Но, оказывается, что из кучи можно извлечь максимум. Как это
сделать. Да, очень просто. Значит, надо посвапать этот максимум с последним листом. Последним,
в смысле, максимальным и удалить этот лист. Тогда все, что вам останется, это сделать
севдауну кофе. То есть, в принципе, заодно можно этот максимум и достать. Ну, в общем-то,
классическая операция. Так, ну, тут вроде не сильно сложно. То есть, вот таким вот нехитрым
образом это делается. Значит, еще раз, смотрите, вот давайте по коду. Так, ну, во-первых, проверяем,
что он есть. Ну, ладно, конечно, мещере вам по рукам надается такую проверку, но мы сейчас в теорию
исключений там лазить не будем. Вот. Значит, как достать максимум. Так, ну, во-первых, понятно,
где он находится. В корне, да. Мы его сохраняем. Значит, после этого, значит, идея такая. Значит,
мы копируем туда последний элемент из этого массива. Пусть он называется last. Кстати,
но это не случайно, потому что мало кто знает, но в векторе есть метод back. Знаете, да? То есть,
более того, там в векторе иногда можно писать даже v.back хресь-хресь равно 5. Вот. Ну, это просто
такая техническая мелочь. Может, не все сталкиваются. Потому что иногда, когда видишь там, когда там
начинают вот это все писать там v.size-1, там вот это вот равно 5. Знаете, просто хочется крикнуть.
Не, ну, если размер доль, то и это, это, конечно, там отправит вас.
Можно и так, да. А, звездочка, да.
Да.
Да.
Да.
Да.
Да.
Да.
Да.
Да.
Да.
Да.
Да.
Да.
Да.
Да.
Да.
Да.
Можно. Ой, ой, ой, да. Ой, ой, ой, ой...
Минусы можно еще убрать, значит, 4 минуса.
E.
E.
Не, ну это так, конечно, да, странное различие, но в любом случае да, но лучше как бы для этого изобрели
back, лучше пользуйтесь back. Вот, ладно, ну значит, а ты что мы делаем? То есть копируем последний
элемент в корень, удаляем этот последний элемент, что он нам просто не нужен, да, то есть в данном
случае вот этой четверку типа мы, то есть копируем вот сюда четверку, да, и удаляем. Вот, и все что нам
остается, что если куча после этого не оказалась пустой, а она могла оказаться пустой, потому что вдруг она была
перед этим из одного элемента, то мы вызываем сивдаун из корки.
У нас могло только оказаться, что элементы хранятся разрежены, то есть какое-то место оказалось пустым,
когда мы делали сивдаун. Нет. Если максимальный элемент, допустим, третий элемент больше,
а второй, и мы его делаем сивдаун. Нет, так, во-первых, смотрите, во-первых, разреженного
сива нет в том плане, что все элементы хранятся подряд, и мы удаляем только самый последний
элемент. Это раз. Ну и что? Нет, просто смотрите, после того, как вы удалили этот элемент с копировки сюда,
то у вас единственное, то есть у вас свойства кучи все сохраняются, кроме корня, поэтому как бы один
сивдаун из корня решает проблему. Он мог пойти влево, мог пойти вправо, но суть, но как бы логично,
вот в данном случае он пойдет 11-9, он же пойдет в сторону максимального элемента, и здесь, тогда,
сюда мы повесим 11, который будет больше всего там этого элемента, следовательно,
всего под дерево, ну и все в порядке. Так что никаких проблем. Нет. Так что получается вот
такая из двоичной кучи, можно вот такую штуку сделать. В принципе, на самом деле, подобного
рода технологии позволяет, на самом деле, удалять из кучи элементов, за логарифом элемент,
не обязательно из корня, но из произвольного места. Ну там одна из технологий называется просто так,
нет, конечно, это предположение, что вы для каждого элемента, вы в каждый момент времени знаете,
где он в куче лежит. И это проблема, что в СТЛе вы такого не реализуете. Вот преимущество Паскаля,
кстати. Потому что если вы будете использовать priority queue в СТЛе, то там это будет просто
черный ящик, который умеет делать, соответственно, что он умеет делать. Пуш,
как там это называется? Пуш. То есть пуш какой-то элемент, а также выполнять операцию топ, там фронт
и поп. Фронт будет показывать вам максимальный элемент, поп будет его удалять. Все. То есть как бы
проблема черного ящика. То есть если вы положили туда 57, то где она там находится, что он там
делает, вам не ведомо. Более того, если вы начнете спрашивать, говорить, он вам в конце концов
мисапелляционно, бабушка заявит. А кто вам сказал, что у нас тут именно вот это? Может,
мы там азель дерева хреним на самом деле? И вообще это на самом деле сет это такой на самом деле.
Просто мы вам не весь функционат показываем. Что вы думаете, что если там написана очередь,
то как бы там нету дека что ли? Вот это вот все. То есть минус черного ящика швы. Под капотом
бывает непонятно, что. С другой стороны, чаще всего бывает понятно, что. То есть вам примерно
рассказывают, как из этого вы делаете вывод, как-то удобно использовать, а как нет. Но чаще
всего вот, но действительно как черный ящик, как абстрактных этих данных, действительно у нас
операции вот такие. Но чаще их называют, конечно, по-другому, но вообще как бы вот, да. Очередь
с приоритетом, это вот такое. То есть добавить очередь, элемент с каким-то приоритетом. Значит
get next, это вот соответственно вернуть элемент с максимальным приоритетом или соответственно,
вот. Но иногда бывает вот элемент типа топ, но он не всегда обязателен. Вот. Ну в общем ладно,
названия, значения особого не имеют. Суть, я думаю, вы и так поняли. Вот. Ну я просто к
чему это. То есть, но так теоретически, но да, но смотрите, но чаще на самом деле, вот на самом
деле, если вот рассматривать язык Кормана на самом деле и так далее, то там на самом деле будет
подразумеваться, что вы к добавленному элементу на самом деле там доступ какой-то имеете. Ну воображать
себе это можно, видимо, в плане, что, знаете как, то есть черный ящик вам предоставляет итератор
на элемент. Ну что-то типа итератора. Вот. Ну может не итератор, может там как-то по-другому его
назвать, потому что, ну вот. И тогда просто идея такая, что в каждый момент времени этот итератор
указывает на элементы, по этому итератору можно сделать какие-то операции. Удалить этот элемент.
И тогда вы его удаляете вне зависимости от того, является ли он максимум или не является.
Чего? Изменить. Более того, забегая вперед, у нас в будущем на самом деле будет, вот есть
классическая куча, в которых есть операции, там значит, вставить туда, то есть вставить
элемент и удалить минимум. Ну или просмотреть, да? Ну или там не минимум, а максимум бывает, да? Вот.
Ну вот. Но нам будет, во-первых, у нас там продвинутые кучи будут, во-первых, они будут сливаемые,
то есть будет задача, даны две кучи, слий, пожалуйста, их в одну. Желательно быстро. Вот. И самое важное,
у нас будет операция дикриски. Ну это в куче на минимум, на минимум, будет операция, тыкни,
вот возьми вот этот элемент по итератору и, пожалуйста, уменьши его. Потому что оказывается,
что просто можно или вот зачем нужна куча фибоначи, да? Она нам оказывается нужна для того,
что она умеет это уменьшение делать не за логарифом, а за единицу. Вот. Ну вот. За единицу.
Вот это за единицу. Вот. Так что вот соответственно. Так. Ну как бы да. Занятие у нас сегодня по
сортировкам, да? Но на самом деле при чем тут сортировки? Но на самом деле да. Есть такая красивая
вещь, называется hip sort. И устроен он предельно вот. Ну и hip sort устроен предельно простым
образом. Так. У вас есть черный ящик, который умеет за логарифом добавлять в себя элемент и
удалять. Или даже вот проще, да. Ну вот тогда идея такая. Давайте в черному ящику скорбим все
элементы, а потом просто все их достанем. И вот вам отсортировать, пожалуйста. Можно это сделать
оптимальнее по константе, потому что построить саму себе кучу вы можете за линию. То есть у черного
ящика есть такой лоток, в который типа запихивает сюда все элементы и он их кушает за линию. Вот.
Ну общее время. Но доставать все равно придется за логарифом и получается он логан. То есть думает
ладно, может наверное и доставание как-то можно оптимизировать. Но нет, доставание нельзя
оптимизировать, что мы доказали, что быстрее чем за логан мы сортировку не напишем. По крайней
мере, как мы это будем называть в модели сравнений. В модели сравнений. Ну потому что сами видите.
Вот. Так что вот. Но тем не менее получается еще один N-логанчик. Причем более того кучу вообще
можно еще и действительно удобно хранить в начале массива и доставать из нее максимум. И получается,
что преимущество по сравнению с мечсортом у него есть важное, а именно что вы хипсорт можете
реализовать так, чтобы он сортировал элементы за от единицы дополнительной памяти. Это важно. То
есть у мечсорта есть такой недостаток, чтобы смержить два массива, нужно эти массивы куда-то скопировать.
Я вам даже больше скажу, мы его сегодня будем обсуждать. Ну или максимум в следующий раз.
Да, но как вы сами убедитесь, скажем так, мозг придется повзрывать. То есть это не самый,
то есть это будет так. То есть нельзя сказать, у нас уже была очередь из шести стэков,
поэтому нельзя сказать, что мы тут пока рассматриваем только тривиальные алгоритмы.
Ну я не знаю, может для вас очередь из шести стэков тривиальный алгоритм, конечно, но что-то мне
подсказывает, что все-таки нет. Вот. Так. Ну ладно, давайте прежде чем, прежде чем мы куда-нибудь еще
пойдем, значит мы рассмотрим еще одну сортировочку, которая работает за, казалось бы, работает за
вот единицы дополнительной памяти, но на самом деле нет. Да, потому что на самом деле, конечно,
нельзя обойти вниманием кусор. Но правда, тут мы его быстро можем упомянуть, потому что кусор
мы в прошлый раз уже обсуждали. Вот. Вот. Ну суть, то есть понятно. На самом деле так, у него есть
мета такая версия, то есть мета версия такая, что мы просто, то есть мы должны просто разделить
массив на две части так, чтобы слева были элементы меньше, чем вправой. То есть разделили массивы,
и потом после этого рекурсивно по сортируем, что слева и что справа. Вот. То есть как это сделать?
Ну классический метод, конечно, ну вот примерно код, который я в прошлый раз писал, помните, да? Вот.
Да, каждый раз вот на Паскале приходилось писать вот что-то подобное. А если надо два массива
сортировать, то приходилось, ну два массива разных типов, то приходилось два раза писать.
Вот шаблонов в Паскале тоже нету. Вот. Но ничего страшного. Вот. Ну и так далее и тому подобное.
Вот. Так что такая вот нот. То есть в данном случае такая красота. В чем действительно, что интересно,
видите, обратите внимание, то есть партия, то есть на самом деле функция partition реализована так,
что она работает за от единицы дополнительной памяти, видите, да? Вот. Но при этом фишка,
но вот. Но при этом, конечно, важный момент, есть ноты. При этом кажется, что после этого и quicksort
работает за от единицы дополнительной памяти, но это не так. Потому что, да, в данном случае
дополнительной памятью является stack recursion, поэтому дополнительной памяти получается логарифом.
Вот. То есть в этом смысле, то есть с точки зрения допамяти, конечно, пока у нас сортировка кучей
чемпионская. А если вспомнить, что она еще и не рекурсивная. А, ну поэтому она и чемпионская. Да,
но в Qsort на самом деле тут разные вещи можно обсуждать. Можно еще обсудить на самом деле,
что, потому что как мы это делаем? Мы выбираем какой-то элемент, который называется pivot. Это
прям официальное название в науке. Или pivot. Или pivot. No, I would say pivot. Possibly it's incorrect.
Dear Google Translate. I'm not sure. Oh, let's try. Okay. Так, ребят, так, тишина. Так, тишина,
тишина. Сейчас попробуем. Так, вот он. Серьезно? Ну ладно. Ладно. Pivot. Yeah, pivot. Okay. Let it be pivot, sorry.
I was incorrect. I was wrong. Okay. Pivot. Okay. Так вот. Ну, значит, теперь вот возникает вопрос. Да,
что это pivot? Значит, как его выбирать? Потому что я тут его выбрал вот таким вот нехитрым способом.
Да, ну как сказать, если массив отсортирован, то это очень плохо. А если массив там как-то рандомно
пошаффлен, то в принципе нормально будет. Но, конечно, чаще его выбирают на практике по-другому.
То есть классическая вариация в паскале была, пишите там a t plus r, там n пополам, короче, в данном
случае. Да, но контр-тест всегда есть. Ну скажи так, под любой конкретный алгоритм выбора
pivot'a, можно подогнать контр-пример, в котором этот pivot будет максимальным. Вот. Так что в этом
смысле такое. Ну вот. И теперь смотрим. Вот. Ну в принципе, это, конечно, мечта. Ну, как можно... То есть
если partition всегда работает пополам, то это работает за n log n и, в общем-то, нам нормально. Так. Ну,
так. Ну, это будет вам слайд для любителей мотоанализа, фо, для тягвера, с мото ожиданиями. Вот. Но в
принципе, проговорить тут хочется следующее, что pivot можно выбирать как. Ну, на самом деле,
технологии разные. Бывают последние, первые, середины. Ну, конечно, хорошо работает случайно. Хотя,
как бы, на код почте, скорее всего, у вас и это завалит. Ну вот. Да. Ну, это там, на следующих
слайдах просто. Да. Вот. Нет. Вот это между другое. Можно, как бы, давайте возьмем вот эти три
элемента и выберем из них медианных. Вот. Или можно медианно. В общем, разное что-то можно делать.
Ну, думаю, завалить можно. Потому что если он будет какой-нибудь предпоследний элемент,
то почему бы нет? Нет, у рандом сложен, но просто проблема в том, что рандом он псевдорандом. Это
тоже. Ну, надо смотреть, потому что, да. Нет, тут надо к амтеху обращаться, потому что было
ощущение, что они просто едва ли не такое смогли как-то свалить. Нет, там была задача, которая без
рандома не делается никак, а любой рандом как бы и валится на челленджах. Ну или почти любой. Да,
это была шикарная задача просто вот. Так что какой-то амтехраунд, там один из последних,
гляньте, несколько лет назад это было, но я прям получил удовольствие. Вот кого нет. Ну, в те времена
они были не пайныли, поэтому можете искать по амтеху. Да, шикарная там какая-то, но там какая-то
шикарная задача, которая вот действительно не решается. Вот. Так что тут такое. Ну дальше у нас
катая порядковая статистика, но здесь в общем-то просто описывается этот алгоритм. Ой, я даже
правильно вспомнил все фамилии. Окей. Вот. Так, ну в общем. Да. Нет, ну по-хорошему мы должны были
это обсудить в этом месте, но я, соответственно, мы вынуждены были обсудить в тот прошлый раз,
потому чтобы как бы с Домашкой не затягивать. Вот, поэтому сейчас мы этого делать не будем. Так,
ну что ж, немножко затянулась первая пара. Так, ну да, мы могли закончить на 8 минут раньше,
в итоге закончим на 45 минут позже. Так, ну ладно, ничего страшного. Зато, зато как-то хорошо
презентажечка закончилась. Нет, ну не волнуйтесь, у меня еще есть как бы, да. Как бы, да. Тимсорт от нас
никуда не денется. Называется там какой-нибудь сли-слияние за 1 до памяти тоже, но это мы все
будем делать после перерыва. Ну давайте так сразу поанонсируем. Давайте ладно, в том числе можно
для наших телезрителей тоже, да, что... Хотя, не знаю, когда видео для телезрителей, это может
быть уже не актуально, конечно, скорее всего, но там будет все зависеть от того, когда вы эту лекцию
смотрите. Но, в принципе, да, то есть как бы, да, зазывать на ICPC будем всех, даже не в зависимости
от того, там, участвуйте вы активно сейчас в тренировках, допустим, или нет. Вот, соответственно,
вот это действительно вопрос. Но зазывать будем активно всех, но как вы же активно говорили,
да, что как бы, чем больше вас придет на ICPC, тем больше нас поедет на четверть финал, на полуфинал.
Но на финал, к сожалению, нет, но все-таки. Ну как бы, нет, там квота немножко по-другому устроена
просто. Там просто на квале работает так. То есть там ситуация такая, что, ну мы сейчас выкидываем,
ну понятно, что никуда не проходят команды, которые не решили ни одной задачи, но как бы, да, вот,
но как бы, мы надеемся, таких не будет. Нет, дальше там, нет, там просто обычного правила, устроенное
примерно так, то есть там есть как бы три квоты, такая красная, там обычно красная, синие, зеленая.
Что такое красная квота? Красная квота. Чемпион, там победитель квала от каждого ВУЗа заведомо
проходит. Вот. Далее. Берем синие. Значит, берем, значит, от каждого ВУЗа берем команды, занявшие
от второго по четвертое место, ну там, ну или если там меньше команд от ВУЗа пришло, ну сколько есть.
Их упорядочиваем в отдельную таблицу, и топ сколько-то из них, по-моему, там 30 или что-то в этом
роде, там точные цифры, надо смотреть в другом месте, тоже там проходят дальше. Значит, после этого тупо
всех остальных, мы, значит, все остальные после этого сортируются, да, то есть берем всех остальных,
кто еще по предыдущим квотам не прошел, значит, сортируем их и, значит, отсекаем по количеству мест
на четверть финале. Ну, скажем так, понятно, что, ну вот, ну то есть так, просто от физтеха понятно,
что там, скорее всего, там топ-4 команд, наверное, займут какие-то достаточно высокие места,
скорее всего, да, поэтому как бы в этом, по этому случае, глобально, это вы либо попадаете в топ-4,
либо, соответственно, просто садитесь и, то есть либо там проходите по вот этой квоте, там по отсечке,
вот, то есть, пример, там так это работает просто. Ну, в среднем, ну, сложно сказать в среднем,
но скажем так, последний раз было 15. Вот, слушайте, это менее может быть,
актуальным вопросом. Я могу сказать, что было в прошлом году, прошло 15 команд,
и надо было из 13 задач решить 12. Нет, ну, нет, ребят, ну, нет, это нормально, потому что квал,
это более простой контест, но там буквально, там, извините, там, ну, там просто, ну, чтобы вы
понимали, там буквально будут, там а плюс бэшные задачи, там буквально могут быть. Чего?
Нет, так, ну, где их найти? Так, ну, может быть, мы их, может, не выкладывали, но,
смотрю, так, если у вас там есть желание, там, ну, больше того, скажешь так, обычно это настолько
простые контесты, что мы их давать не будем, но если есть у вас большое желание, то, как бы,
я могу просто пошарить, можете написать, если хотите, или там, так что, если, ну, если там,
как бы, очень захочется. Ну, тот момент такой, для этого надо еще команды и там сформировать,
вот, вот, ну, соответственно, ладно, это уже другой вопрос. Хорошо, вот это, ну, вот это уже такое,
но, на самом деле, то есть, это, как бы, не, ну, как бы, квал, это в этом смысле, это не самая
интересная тренировочная контест, я вас уверяю, потому что, ну, как бы, понятно, скорее всего,
там, то есть, как бы, вопрос будет, за сколько вы закроете там первые 8-9 задач, на самом деле,
вопрос будет, то есть, что вы закроете там за полтора часа, за час или все-таки там 40 минут
уложите, да, буквально, то есть, нет, интересные задачи там будут, да, но просто их будет сильно
меньше, вот, соответственно. То есть, понятно, что потом вы придете начать в, где уже, как бы,
как бы, уже, все-таки, хоть на сколько-то отобранные люди, да, но, то есть, ну, как бы,
это специально делается для того, чтобы там многие там какие-то вузы, которые там с не
такими сильными участками могли уже там кому-то говорить о том, что ура, мы попали в четвертьфинал,
то есть мы вот это кого-то победили даже. Нет, это на самом деле серьезная вещь, потому что на самом
деле действительно помогает. Ровно с этой целью там был проведен ребрейтинг, что как бы официально
нет понятия, там Питерский полуфинал, есть понятие, там это финал региона Северной Евразии.
То есть это реально финал, за него можно реально медальки получить, соответственно, да. В прошлом
году там пять команд фистеха медальки получила, между прочим. Нет, это реально правда, чисто там
двенадцать. В топ-12 прям пять команд попали сами в шоке, на самом деле, но в принципе нормально.
Так что, соответственно, но это просто как бы сильно по офисе не звучит. Понятно,
что с точки зрения прохода на финал, конечно, ничего не поменялось. Проходит только одна
команда фистеха и как бы и увы. В данном случае появился ты не чемпион, тебе не повезло. Ну или ты
выше школы экономики, да. Да, но с другой стороны, да, если ты не ффтайл, то тебе тоже не повезло.
Ну как не повезло, в данном случае сложно говорить о везении, на самом деле, конечно.
Соответственно, вот. Так что тут такие моменты, но просто такие репы. Поэтому нет понятия,
то нет. Да, кстати, более того, вы скорее всего не услышите понятия московский фейтерфинал,
вы услышите понятия Moscow Regional Contest. Regional Contest, yeah. Да, вот. Так что, соответственно,
ну а квалификация, кстати, тоже как-то паустно называется, я не помню как. Хотя,
оно, то есть, хотя по факту как бы даст. Так, ну вот. Значит, соответственно. Так, ладно.
Так. И так идем дальше. Как вы это, слющайте другую сортировку. Да, вы думали,
что мы обсудили все сортировки. Сейчас будет одно из самых весь вот. Вот она,
вот она, сортировка до нашей мечты. Вот она, да. Это знаменитая сортировка Тима Петокса.
Чем знаете, она действительно, то есть, она как-то, интересно чем на самом деле, да. Она
интересна тем, что, то есть, математически она практически ничего нового не придумала. Хотя,
в итоге, одна из сложнейших математических задач, по крайней мере, первого семестра у вас,
она индуцирует. Значит, сразу скажу, у вас будет задача доказать, что она работает за НЛоген.
Да, причем это, причем задача на самом деле достаточно актуальная. Почему? Ну,
актуальная в каком плане? Потому что дело в том, что Тим Сорт, вот этот товарищ Тим Петерс,
ну, по его, так сказать, статье, ну, хотя это официальной статьей это не является, вот,
насколько я понимаю, то есть, все-таки явно видишь, что он кодер. То есть, он придумал пару каких-то
лайфхаков. Ну, на тему чего, языка чего он придумал. То есть, логика такая, что реальные данные,
то есть, когда вы там в реальной жизни сортируете, они очень часто будут почти сортированы. Ну,
потому что вы их там набрали как-то из блоков там от сортированных или что-нибудь еще в этом роде. И
очень хочется придумать сортировку, которая как бы в худшем случае как бы работает все еще за НЛоген,
но в идеале, но на таких данных работает все-таки быстрее. То есть, если они почти отсортированы,
то она как-то этим пользуется. Ну, допустим, вот представим себе, что у нас, например,
массив состоит из пяти отсортированных блоков. Некоторые из блоков еще и по убыванию отсортированы.
То есть, ранее обсужденные сортировки, в общем-то, от этого быстрее сильно работать не будут. Вот,
соответственно. Хочется изобрести сортировку, которая бы этим пользовалась как-то. То есть,
мотивация была такая, и он из этого, собственно, что-то сделал. Но это что-то, то есть, он сделал
какие-то лайфхаки, которые мы сейчас будем обсуждать, но доказательства особо не предоставил.
Для него доказательством было то, что мы заметим, что там, если там раны, там все были по единице,
то это сделается вот так-так-так-так, и конкретно в этом случае будет за НЛоген. В общем,
очевидно, что это худший случай, но и так далее. И прочие безобразия, за которые, как бы понятно,
что там, по крайней мере, называется лично я буду ругаться очень долго, если там такое решение будет
предложено. Вот, собственно, ну и, соответственно, там проверяющая теска тоже. Вот, поэтому там
математического формализма особо нет, и нам захочется его добавить. Но, тем не менее,
давайте смотреть. То есть, практический смысл, конечно, очевиден. То есть, практический смысл,
на самом деле, как в кусорте. Вот, кстати, я забыл важный момент указать, что зачем нужен, казалось бы,
кусорта. Зачем нужен кусорт, если там он работает в худшем случае за квадрат, его можно обвалить,
а всякие merge-сорты с хипами работают жили за бетон. Идея очень проста. Просто тестирование
показывает, что его константа значительно лучше, чем у merge-хипа. Вот, ну, можете сами протестировать,
но там речь идет, там просто едва линия. Ну, там просто едва линия в полтора раза. Вот,
то есть, на каких-то рандомных тестах будет так. Поэтому, действительно, поэтому это называется
quick-sort. Ну, вот. Ну, собственно, как я уже говорил в прошлый раз, давайте еще раз упомянем. Да,
то есть, как бы в STALE есть функция intro-sort. То есть, это еще один вариант такой. То есть,
запускаем quick-sort, но как бы будем решать проблему, что все плохо. Очень просто. Если окажется,
там если, то есть, там, если при этом окажется, что там глубина рекурсии там окажется слишком
большой, то на какой-то глубине мы просто говорим, что дальше в рекурсию не идем, а вместо этого
досактировываем хипом. Ну, или, там, если, там, длина массивчика меньше 16, то сактируем,
там, чем-нибудь. Ну, потому что оказывается, что по константе, там, 16 элементов можно вставками
сактируется быстрее, чем любой хип. Вот. Это вот важный тактический момент. Итак, ну, вот,
значит, это был quick-sort. Значит, упоминал, теперь давайте упомянем, значит, начнем понимать,
что же предлагает в итоге Tim Peters. Ну, основная идея такая. Значит, основная идея будет заключаться
в том, что мы будем разбивать массив на то, что мы будем называть раны. Вот. Это, ну, раны,
это будет такой под массив, отсортированный по убыванию и возрастанию. Вот. Значит,
то есть, идея, ну, вот, то есть, сначала мы, там, прибежишь и разобьем, и потом эти раны будем
в каком-то, там, каким-то экзотическим образом сливать. Но как моя нот? Это, как бы, основная
идея. Но первая идея нот. Но, в принципе, идея, конечно, с разными моментами. Первый из этих
моментов даже уже спален. А именно, мы введем число минран. Спрашивайте, что такое минран? Это
некоторая, значит, мистическая константа, которую, там, Tim Peters вот взял, значит, как-то абстрактно.
Вот. Ну, вот, да. То есть, видимо, из его экспериментов, видимо, вот возникло ощущение,
что вот имеет смысл взять вот так. То есть, это число от 32 там до 65 где-то.
То есть, выбираем, ну, вот он так предлагает. Вот. Ну, как сказать, это называется, да, я проводил
практически эксперименты, у меня вот что-то вот так вот как-то получилось. Не, ну, как сказать,
ну, как бы, ну, в этом коде сделано так. Берем n, берем 5 старших битов, по сути. Или там, ну,
5, ладно, 6. И прибавляем единицу, если среди оставшихся бит есть хотя бы один ненулевой,
по чему, то я не знаю почему. Да, ну, вот. Как бы, почему-то ему показалось, что так хорошо. Вот. Как
называется, да. Как называется, да. И написал Тим вот это, и увидел он, что это, ну, вот вроде как-то
работает. Вот. Значит, какая-то вот такая константа. Нет, просто зачем она нужна? Что же это такое?
Ну, идея будет у нас заключаться в том, что мы теперь будем строить раны. Вот. То есть, есть
максимально отсортированный нод. То есть, ну, идея в том, что мы просто идем слева направо и жадно
набираем отсортированные массивы. То есть, идем-идем слева направо, до тех пор, пока он отсортирован
там по возрастанию или по убыванию. То есть, как только он перестал быть отсортирован, значит,
в этом месте мы ран останавливаем и набираем следующий. Прям тупо жадно за линию. Ну, тупо,
но с оговоркой. Если ран не дошел до длины минран, то мы его добавляем прям жадно с помощью вставок.
Ну, смотрите, первая идея. Да. Ну, то есть, без минрана это просто. То есть, задача,
то есть, да, массив, надо его жадно разбить на отсортированные под массивы. То есть, идем слева
направо, пока префикс отсортирован. Как только перестал, значит, останавливались, начиная с
этого момента набираем еще ран. Вот. Вот. Ну, вот это работает за линию. Вот. Ну, как бы следующие
части по-любому будут работать за n лог n, да. Поэтому в будущее хочется оптимизировать за счет
того, что это n можно как-то увеличить. Видимо, предлагается сделать следующее. Давайте сделаем так,
чтобы у нас ранов было не слишком много. Или раны были не слишком маленькие. Вот скажем,
что раны должны быть не меньше, чем вот. Вот это константа. Вот. То есть, как мы это делаем? Ну,
просто набираем отсортированный массив. Так, останавливаемся. Стоп. Так, если он слишком мало,
ну, значит, мы жадно добираем до минрана. Просто каждый элемент делаем просто с вставки.
Ну, например, так, да. Ну, это уже детали там. Можно сначала сделать с вставками, потом развернуть,
если хочется. Так что это неважно. Нет, ну, а как набираете? Вы же по первым двум элементам
определяете, он возрастающий или убывающий? Да. Ну, не особо. Это уже мелкая техническая деталь.
Очень просто. Ну, как всегда, вот у тебя идет элемент 2, 5, 8, 1, 16. Следующий элемент так. 13.
Так, таки. 13 меньше 16. Так, свапаем. 13 меньше 11. Нет, останавливаемся. Ну, да. Ну,
как сортировки с ставками буквально? Нет, даже не нужен бинпоиск. Скажем так, видите,
когда речь идет о такой константе, окажем, может оказаться, что бинпоиск даже менее
выгоден, чем просто в тупой проход. Вот. Да, просто туп в этом месте обрезаем. Да.
Нет, если меньше минрана, то да, делаем эти... Нет, если больше минрана, то все,
ран в этом месте заканчивается. Нет, минран, да. Ну, просто если вы набирали жадный,
и у вас эта жадность вот докуда-то дошла, его длина оказалась больше, чем минран,
значит ран в этом месте останавливается. Набираем следующий. Нет, я это имел в виду. Мы идем,
идем, идем. До тех пор пока отсортировано. А потом, когда мы остановились, смотрим,
так, если получилось больше минрана, окей. Если меньше, то докидываем. А ну, скажешь так, ладно,
но скажешь так, один мелкий ран в конце, это не страшно. Вот. Ну, в конце, ну, совсем в конце
концов лишнее ОТМ-действие, типа, отсортируем то, что было до этого, и потом сольем с этим.
Ну, минран, да, ну, как угодно, да. Но обычно, то есть в этом месте просто не заморачивается,
просто у вас там будет, скажешь так, один совсем мелкий ран может быть, это не страшно. Вот.
Итак, идем дальше. А вот тут, да, начинается, да, как-то, видите, вот, да, есть разница от
общего описания. Ну, как я уже говорил, да, почему-то такие разные стили, да, обычно это так,
то есть просто какая-то часть презентации осталась вот действительно, вот, собственно, от великого
предшественника. Вот. Но обычно, если вы видите вот этот стиль, это значит, видимо, писал уже я.
Потому что тут надо прям формально описывать, потому что, честно скажем, да, Тим Петерс тут
тоже, как же, видимо, не сильно формально трудился в этом плане. Значит, сливать раны, но, собственно,
это будет практически, скажем так, это будет, как бы у нас будет три части алгоритма, и это,
собственно, будет вот вторая часть, единственная часть, в которой будет работать не за линию.
И она будет работать так. Значит, мы эти раны будем хранить как-то в стеке. Ну, не в смысле сразу
пихнем в стек, а, значит, вот как. То есть у нас есть раны. Вот, допустим, их N штук. Допустим, да.
Значит, смотрите, мы их будем, ну, основная идея такая, мы эти раны будем добавлять в стек,
ну, не в смысле, конечно, прям все под массивы прям копировать в стек, естественно, да, понятно,
что там информацию под массиве будем пихать в стек. Но при этом поддерживать, поддерживать там вот,
вот тут я даже скажу так, такого рода инвариант. Такого рода. Почему такого, почему я говорю,
такого рода, а не прям вот ровно такой? А вот потому что, ну, потому что, скажем так,
такой предлагает симпетр, что доказательства он не предлагает. Поэтому, как бы, тут возникает
вопрос либо доказать именно такого вида, либо все-таки чуть-чуть подматифицировать,
чтобы доказательство сходилось. Потому что там, честно скажу, я не допроверял, к сожалению,
значит, информацию совсем, но там ходили случаи, что в какой-то интерпретации того,
что написал симпетр, просто взяли, просто предложили контртест. Так что там вот аккурат.
Вот какой-то интерпретации. Нет, ну как лажу. Нет, скажем так, у него была идея,
но как бы он ее формально не довел, поэтому как бы. Вот, то есть на самом деле, да, то есть,
ну смотрите, просто, ну какая, сейчас я вам скажу наметку идеи, которая тут предлагается. Вот давайте
значит инвариант поддерживается такой, вот у вас хранятся в стеке несколько раундов. Вот давайте
так это все уберем. Безобразие. Ой, все-таки да, испаряется потихоньку мещерин. А онлайн?
А, в смысле, ну? А, ну да, да, да, нет. А, ну да, логич. Нет, то это логич,
то да, он там, собственно, тоже там на свадьбу поехал, это да. Не, на свадьбу, ну да. Таня Бабичевой.
Ну, если кто был там, кто был в олимпиадных школах, там знаете, такое. Ну, по крайней мере,
до недавнего времени она была там. Нет, Татьяна Бабичева. Так, ну, значит, кто это,
значит, кто это такая? Так, ну, кстати, кто был в олимпиадных школах МФТИ? В любом отделении.
Чего-то мало, нас становится мало. А, ну, как нас, господи, я уже там не работаю, господи.
Ладно, не важно. Нет, не путается ЛКШ. Нет, просто нет. Ну, просто нет. Она просто Таня Бабичева
долгое время там была методистом отделения математики. Правда, последнее время, но в какой-то
момент она уже давно там на самом деле живет во Франции, поэтому часто она там делала работу в
основном удаленно. Собственно, на месте все там картинировал я и мещерин, но сейчас он,
собственно, полновластный методист, отделение математики. Так что, да. Это называется. О
связи чисто математике-программирования. Это называется, да. Как кон removal shearing. Да,
или ось게ин. Там олимпиянник по математике, значит, методист. Значит, по математике преподает
C++. heels Almost. Филипп Рухович, олимпиадник по алгоритмам. Препродадут алгоритм… методист
деление математики кандидат физмат наук внимание вопрос точно ли мы ничего не
перепутали нету я когда вот ну ладно почем впрочем возможно в какой-то момент
илья защитится и собственная шутка перестанет работать но соответственно так
но она но она и так уже слишком сложная да ну ладно так неважно нет ну да просто
я кандидата я кандидат физмат наук мне при этом у меня работа по чистой математике как бы
соответственно так что нет нет у нас нет на самом деле нет в этом месте шутка и заканчивается
потому что как бы и там результат математически но получен он с помощью компьютера да потому
что да причем то есть для этого мне пришлось там реализовывать кучу вычислительной геометрии
на самом деле не нравится просто не занимаетесь этим не занимаетесь конкретно внешкими бильярдами
проблем вот нет если кому интересно понятно вы там легко можете нагуглить а ну как минимум
можно нагуглить мою кандидатскую диссертацию в общем-то там ну скажем так можно нагуглить
какие-то мои статьи но на самом деле если вы прочитаете кандидатскую то вы собственно там
вы прочитаете практически все что там можно найти в том статьях и даже больше на самом
деле вот но это уже такой но это просто если кому интересно вот так что нет это был вопрос
такая тайна бабичева вот такая связь но вот ладно неважно вот
значит и так так на чем мы там остановились так мы остановились вот на чем значит мы остановились
на том что у нас таких стиксы грз и происходит дальше следующее то есть дальше у нас происходит
то что то есть у нас есть стэк и так у нас есть стэк ранов вот
вот то есть ну тут какие-то вот раны они имеют какие-то длины вот рассмотрим какие-нибудь
подряд идущие вот тут тогда аккуратно потому что там тетим петер предлагал вариант что мы
храним только инвариант только для трех верхних стэков и на самом деле это потом проблемы потому
что непонятно будет почему там в будущем это будет соблюдаться там всякие проблемы начнется с
этим ну и мы-то показалось видимо типа очевидным но знаете как бывает знаете как бывает в этом
пишет какой-нибудь контролью работы пити очевидно а потом возвращается вам оценка 2 и подпись но неверно
ну вот ну да а тут вы пишите но неверно вот вот так вот здесь у нас идут три подряд идущих рана
иксы грз так да но важный момент да вот видите как полезно все формально просчитывать да в данном
случае наоборот я читал что быть вы верно следующее во первых должно быть верно пишем что игрок
больше z но в смысле ну хорошо да но это тот как раз интуитивно понятно что имеется в виду
что имеется длины и во вторых еще должно быть верно что модуль x должен быть больше чем сумма
этих вот стоящих на нем сверху длина да почему я но вот вот но я эти условия пишу для того чтобы
потому что вот эти условия потому что для вот двух верхних ранов должно быть выполнено что этот
меньше это и конечно же еще формально конечно надо добавить что для двух нижних тоже этот знак больше
выполнится то есть по сути но первые условия говорит о том что она говорит что как бы раны идут в порядке
строгого убывания ну как мы сейчас посмотрим значит это смотрите идем вот так значит сортированно
но для любых трех подряд идущих верно что тут еще более интересно все работает еще работает то
что каждый следующий больше чем сумма предыдущих ну как почему в два
но на самом деле да то есть как бы да то есть можно на самом деле перейти к третьей
фазе то есть идея будет в том что мы будем добавлять раны в стэк и каким вот и если этот
инвариант нарушается то каким-то образом будем значит сливать раны да имейте в виду конечно что в
каждый момент времени набор этих ранов представляет собой там префикс от сортированного массива и
в любой момент мы можем взять какие-нибудь два рана и их смерчить и тогда в стэк добавить
вместо вот скажем вот этих двух ранов один единый на игре плюс но да но просто вы по ранам будете
идти слева направо поэтому по факту это будет префикс
но для этого как бы для того чтобы они стали единым массивом придется их слить и тогда и тогда вы
можете убрать эти раны из стэка вместо этого добавить единый ран на x плюс и как да но как
конкретно это делать это действительно большой вопрос вот но тут идея такая то есть у нас как
бы алгоритма три фазы первая фаза формирование ранов самих по себе вот этим жадником которые
мы обсуждали с минраном да вот это первое второе второе вы добавляете эти раны в стэк попутно
каким-то образом дебил там попутно делая какие-то слияния между ранами добиваясь того чтобы у них
были выполнены вот эти варианты и третья фаза будет очень простой вы пробегаетесь сверху вниз и
в каждое время берете там два верхних рана сливаете их пихайте это и все вот да ну да сначала
формируем стэк потом его как бы досливаем вот так что вот у нас так что алгоритм устроим так
о
чего как
ой боже боже вы это не не не не не не пугайте тима петерса ну может и похоже я не знаю но я не знаю там
мысли в том таких терминах но он такого не предлагал нет господи с раз переливайка может
еще это декортичку еще написать но значит это вот основную канву это была основная канва
а есть еще не симпатические оптимизации ну первая из них вот тот самый минран вот он да
значит до нашего царя 32 до 65 65 даже не включить нет ну конечно но потому что минран это константа
да да жирная но константа да обратите внимание да то есть это не логарифумы чего нельзя
ну наверно можно но как я сказал тут тим петер сказал это называется да потому что она пошла по
хорошему точно ответ на этот вопрос вы пишите и начинаете там на каких-то тестах тестировать это
называется и может быть у вас выяснится что-то другое тем более тут все проблема том на чем вы
будете тестировать потому что у него он наверно на свои там на данных со своей работы тестировал
или еще откуда-то вы будете тестировать на своей потому что например может выясниться что если
тестировать на там данных всего работает там оптимально иметь константы такие если вы
потестируете на каких-то олимпиадных задачах то получится другое но там правда половине
случаев правда данные будут буквально рандомные поэтому да поэтому было но поэтому может быть
там чем сорт вообще не поможет выяснилось что интросорт на самом деле быстрее всего работает
но тем не менее поэтому нет вот тут всегда все зависит от того на каких данных работаете на
самом деле как бы на реальной практике это всегда это часто приводит к тому что стл начинают
переписывать но потому что у стл всегда недостаток такой что бы какой-нибудь вектор он умеет там
какие-то вот эти эти вещи а вот эти эти он не умеет а бывает что там конкретно ваши задачи вот я уже
раз говорить про вот еще моего преподать в моего получается тоже великого предшественника в
данном случае еще и моего преподавателя это вот предмета вот он рассказывал следующее что там что
именно на работе но там так дорога но вот он работал тоже просто там в чем то связано с
автомобилями в яндексе но я не помню ты конкретно индекса такси возможно тоже самые яндекс
там к себе хотя нет тогда на этот overwhelmed не было вот хотя видимо может разрабатывалось а
А, или он навига... А, он, наверное, это яндекс на виду, там, видимо, какой-то отражение к навигации имел.
Ну ладно, не важно.
Вот.
Но рассказывал он примерно следующее, что там им потребовалось просто перерелизовать свой вектор.
Ну, суть оказалась в том, что там какие... Что им нужны были от вектора какие-то там, может быть, чуть-чуть другие примочки,
но при этом, как примочки, которые есть в Истреле, были там менее принципиальны.
Поэтому в результате они там просто взяли и рецидовали свой.
То есть вот... То есть это может быть оправданно.
То есть, в принципе, это нормально на самом деле.
Подгонять, взять какую-то свою реализацию или свои настройки под конкретные ваши нужды.
Понятно. Есть, конечно, понятный универсальный алгоритм, который гарантирует вам асимпатическую оптимальность всегда,
но одно дело асимпатическая оптимальность и другое дело конкретика.
То есть вам же не надо, чтобы алгоритм работал за недолго, а вам, чтобы он работал не 5 секун, а 3, условно.
И как бы часто оказывается, что там не асимпатические оптимизации важны.
в общем там на практике вообще в принципе это там все по-разному иногда бывает что там чуть позже мы это тоже на самом деле с этим столкнемся суть бывает такая что иногда бывает такая что вы там делаете клипа от операции но при этом у вас еще какие-то запросы базе данных то куда-то там базе данных а это там запрос куда там едва ли не через интернет куда-то надо лазить и вам оказывается принципиально вы делаете вот реально и операции там запросов базе данных или вы делаете 5 операций
запросы базе данных то есть оказывается что то есть это там то есть оказывается то есть это просто преимущество такое что вы там можете на самом деле у себя локально делать там это туатен с tensionу на самом деле
можно быть можно выглiendo даже едва ли не многое сделать но при этом сделать 5 запросов базе данных это будет работать быстрее то есть на реальной практике то есть еще такое то есть вот такие вот штуки которые на олимпиаде как бы встретится крайне редко
редко. Вот. Вот. Ну, впрочем, мы с этим сталкиваемся. Значит, смотрите. Теперь, значит, против сорня.
Итак, значит, у нас есть такое. Так, ну, что еще можно делать при ране? Ну, здесь предлагается
такое интересное, интересная неосимпатическая оптимизация на тему, смотрите, для того,
чтобы слить раны обычно, то есть, там, смёржить какие-то сфоксированные массивы, обычно они оба
копируются, правда? А теперь фишка. Если они лежат рядом, то есть, вот как бы у вас есть,
допустим, вам нужно слить, как это часто бывает, в том числе и в мершсорте, данные два массива,
и они лежат рядом. Хочется вот этот упорядоченный и этот упорядоченный. Хочется сделать из них
единый упорядоченный, да? Ну, в идеале. Нет, ну, нет, смотрите, совсем за единицу не получится.
Ну, с лёдом, по крайней мере. Да, у нас будет алгоритм, но, честно скажу, нам придётся повзрывать
мозг, чтобы это сделать. То есть, там есть вообще хорошие неосимпатические оптимизации и даже,
о чудо, корневуха. Да, вы когда-нибудь писали алгоритмы ЗООАТ с помощью корневухи? Вот сейчас,
вот мы сегодня с таким столкнёмся, ну или в следующий раз, не знаю. Вот, так что тут мясо будет,
то ещё. Вот, так вот, но здесь предлагается, по крайней мере, для надежды, есть более такая простая
оптимизация, которую можно, вот идея такая. Дело в том, что копировать можно не оба массива,
а только один из них, например, левый. То есть, идея заключает в том, что вы тупо копируете этот
элемент, а потом, собственно, понятно, сливаете два указателя и ставите тут указатель и начинаете
прям перезаписывать прям поверх этого. Залезет, но нам это будет неважно, потому что дело вот в чём,
что в каждом интернете будет проходить следующее. То есть, у вас два варианта есть. Либо очередной
элемент будет отсюда, и тогда вы просто берёте этот элемент, копируете сюда, и тогда, соответственно,
сдвигаете этот указатель и сдвигаете этот указатель. Но тогда заметим, что если в будущем
когда-то этот указатель зайдёт сюда, нам уже по барабану. Ну и, соответственно, второй вариант,
это, на самом деле, если мы тут вот решили там действительно пум-пум написать, и тогда вот этот
указатель сдвинуть, а этот дойти. Оказывается, на самом деле, всё в порядке. Почему всё в порядке?
Потому что дело в том, что легко заметить, что всё на самом деле всё в порядке, если зелёный
указатель никогда не догонит вот этот красный. А он его не догонит, потому что он не удалён ровно
вот это расстояние, а они как бы либо синхронно двигаются, либо он к нему приближается за счёт этого
элемента. Поэтому оказывается, что можно на самом деле сделать, то есть копировать лишние элементы
можно только вот из левого массива. Или можно из правого делать, на самом деле это не принципиально,
то есть получается можно сделать за от меньшего массива. Ну типа того. Вот такая вот интересная
неосимпатическая оптимизация, впрочем, она нам тоже пригодится, кстати. Ну мы всегда сливаем
соседние раны, да. Ну естественно, когда мы говорим, что. Потому что если у нас два массива лежат в
рандомном месте, и нам нужно сохранить ответ в ещё более рандомное место, то как бы понятно,
что эта оптимизация бессмысленна. Ну правда, если там уже третье место тоже совсем рандомное,
то и копировать никого никуда не надо. Вот. Так что такой технический момент есть. А, ну вот,
что ещё? А, ну что ещё есть? Да, есть мистическая, конечно, оптимизация, голубь. Вот. Так что,
соответственно, да. То есть, малый, может, кто-то в музыкальной школе с таким словом сталкивался.
Вы поднимите руки, кто в музыкальной школе учился, кстати. Интересно. А, ну, я тоже, кстати, да. Вот так,
хорошо. Кто в музыкальной школе сталкивался со своим вот таким магическим словом голубь?
Окей. Ну, малый. Ну, там пьесы обычно какие-то так называются. Вот. Не важно. Что такое голубь
в данном случае? Потому что может обнаружиться случайно, что мы тут что-то думали, что вы
очень много раз подряд двигаете один и тот же указатель. Просто в чём идея? Идея заключается в том,
что копировать элементы по одному, это бывает медленнее, чем если вы копируете, значит,
несколько элементов подряд, прям как-то скопом, с помощью каких-нибудь там мем цп айф. Ну, вот,
вот этих вот, или других там низкоуровневых операций. Поэтому может оказаться существенным,
что, ну, теперь, то есть, оказывается, если вы понимаете, что, например, там надо дальше туда
скопировать просто следующие там 256 элементов, то есть, то есть идея, что, наверное, давайте поймём,
что 256 и копировать будем единым скопом с помощью там этого там мем цп или там мем мува или вот это
вот всё. Ну, вот, поэтому Тим Петерс говорит, вот Тим Петерс, оказывается, что если вы уже
семь раз подряд двигаете один и тот же указатель, а давайте-ка, вот, помните, у нас уже была такая
идея, помните, когда мы вот в инсершн сорте, да, что оказывалось, оказывалось, что как бы давайте
бинпольском найдём, сколько там надо копировать и как бы всё это возьмём и скопируем. Ну, то есть,
понятно, что есть тут трейдов, то есть, каждый раз, то есть, как бы, если вас много раз будете
копировать по одному элементу, то этот бинпольск вам скорее жизнь испортит. Да, и потом скопируем
единым образом. То есть, понятно, что трейдов, то есть, как бы, слишком быстро такое решение принимать
нельзя. Да, понятно, то есть, как бы, там легче уже три элемента скопировать, чем бинпольск и запускать,
но вот теперь, видимо, с 7, видимо, бинпольск и скопирование начинает обыгрывать тупые проверки.
Нет, это, конечно, не асимпатическая оптимизация, боже упаси, хотя, я вам даже больше скажу,
формально, ещё надо говорить нот. А, ну ладно. Да, но вообще-то, но на самом деле, как бы, нет,
формально, кстати, это может вообще даже испортить симпатику, потому что, если вы делаете бинпольск по
всему массиву, то на самом деле у вас получится N лог N. То есть, там, да, N поделить на 7 лог N,
но, тем не менее, это всё равно N лог N, это всё равно не линия. Поэтому, конечно, нот, поэтому, конечно же,
здесь имеется в виду его величество адаптивный бинпоиск. Что это такое? Ну вот, в данном случае,
в данном случае имеется в виду следующее. В данном случае имеется в виду, в чём в этом месте начать?
Ну, смотрите, расскажу так идею. Смотрите, идея будет такая, то есть, называется бинпоиск с подсказкой.
Просто, смотрите, рассмотрим вот самую-самую классическую задачу на бинпоиск. Данный
сортированный массив, скажите, пожалуйста, где в нём находится элемент равный х? Ну, понятно,
где он находится? Ну, естественно, там вы делаете, запускаете бинпоиск и ищете. А теперь фишка. А теперь
подсказка, а теперь вы решите функции там, дать вам подсказку. Подсказка даёт вам число поз и говорит,
он где-то там. Нет, ну, но тут надо, но тут идея в том, что можно теперь тогда сделать не за логари,
бинпоиск, не за логарифом от поза, а за логарифом от расстояния от поза до правильного ответа. Ну,
во-первых, давайте посмотрим, не в позовой ли позиции находится этот х. Допустим, ну, если оказалось,
что в позовой позиции, вот вы за 1 вам и нашли. Да, ну, как бы подсказка сработала. То есть вам
правильно подсказали. Вот. Так вот. А теперь если нет, то предположим, что х оказался больше,
то есть тут элемент какой-то меньше х, его надо искать здесь. Тогда, казалось бы, надо искать,
можно сделать бинпоиск на всём этом суффиксе, но мы будем ситрее. Значит, идея такая, мы проверим,
будем проверять поз плюс первый элемент, поз плюс второй элемент, поз плюс четвертый элемент,
поз плюс восьмой элемент. Нет, потому что по степеням двойки. И будем так идти до тех пор,
пока очередной элемент поз плюс два в степеника плюс один не окажется больше х, а какой-то
элемент поз плюс два в степеника окажется меньше х. И теперь вот останется на вот этом подмассиве
этот х уже реальным бинпоиском найти. Тогда обратите внимание, то есть ка тут оказывается
такое, что получается расстояние дист, то есть получается такое, анс минус поз лежит на отрезке
от, значит, два в степеника, два в степеника плюс один. Вот, ну что-то такое. То есть получается,
то есть получается, что ка это тета от логарифма двоичного, там соответственно анс минус поз.
Ладно, плюс один ещё. Напишем, чтобы тут с ноликами проблем не было. Вот, но обратите внимание,
мы за этот логарифм в общем-то и работаем, потому что мы за о от ка нашли само ка, а потом ещё за о от
ка здесь бинпоиском нашли сам х. Вот, это называется адаптивный бинпоиск. Вот, вот это называется
адаптивный бинпоиск, он же бинпоиск под сказкой. Так что вот такая красота. То есть получается,
что в худшем случае это будет тот же самый логар, если подсказка вообще левая оказалась. Вот,
но если она оказалась, но чем более она не левая, тем быстрее вы нашли. Ну, откуда-то вот,
с Немес по факсу прислали. В тем сорте, видимо, подсказка будет в самом начале. Да, подсказка будет
в самом начале, потому что у вас идея, то есть идея, вот вы хотите понять, сколько элементов,
вот сколько элементов на префексе этого массива будет там меньше вот этого. Допустим, их будет вот
допустим тоже анс элементов. Вы вообще хотите это сделать с логарифмом, но не логарифм N глобально,
а логарифм именно анс. А потом имеется в виду, ну скажем так, ну на самом деле да,
то есть сначала пойти по возрастанию, потом по убыванию, это да, но правда это уже идентично
обычному бинпоиску. Я боюсь, такие задачи, скорее всего, можно доказать,
быстрее, чем залог N вы, наверное, не найдете. Бинпоиск сам залог K, за K, а K само,
но скажи так, можно и так и так. Удобнее, конечно,
пробежаться второй раз по степенями по убыванию, хотя это на ваше усмотрение.
Если вы напишете функцию go от степени двойки, которая как бы либо прибавит степень двойки,
либо не прибавит в зависимости от вот этого сравнения, то конечно вам будет удобно сначала
идти, идем пока, до тех пор, пока пошли, а потом пробегаемся фориком обратно. Нет, ну можно,
нет, по этим можно сделать так, а можно, как бы вы можете просто дойти фориком сюда, потом прийти
сюда, а вот на этом под массиве вызвать эстаделл овербаунд. То есть в конце концов надо сфорить,
что вы стояли, бинпоиск за вас уже реализовали. Нет, ну как он работает так же, как обычный бинпоиск,
в общем-то, если вы как бы сформулируем так, если бы вам дали не вектор, а два итератора или не
массив, а два указателя, то скорее всего бинпоиск вы написали бы ровно так, как там написано.
Нет, просто не очень понятно, как его можно оптимизировать, если честно, потому что там,
по-моему, там просто на шаблонах написано просто ровно то же самое. А что там можно оптимизировать?
Там, возможно, более правильно прибавлять итератора, разве что не более того. Так что
там что такое хорошо? Так что что такое хорошо в данном случае еще вопрос? Вот, значит соответственно,
так вот позволяется, что вот этот анс можно идти за лог анса, и это иногда помогает. То есть это
идея называется адаптивный бинпоиск. Вот так что тоже иногда полезно знать, пригождается.
Вот, значит, что у нас еще? Ну, соответственно, Галоп предлагает, что просто начинается какой-то
момент, а давайте просто бинпоиском этот анс найдем, каким-нибудь адаптивным и, соответственно,
количество сравнений мы будем уменьшать. Да, часто бывает, что действительно, кстати,
да, вот важный момент еще действительно иногда бывает уменьшить количество сравнений, потому что
обычно задача не асимпатически оптимизировать. Что вам нужно оптимизировать? Вам нужно посмотреть,
так думайте, у вас алгоритм за n log n? Вы не можете улучшить асимптотику. Но можете попытаться
оптимизировать, то есть сделать по константе меньше. Что нужно, чтобы сделать по константе
меньше? Надо посмотреть, что вы конкретно делаете n log n раз и эту конкретную и сделать за меньшую
константу. Это стандартная идея не асимпатических оптимизаций. Первая такая идея, выясняется. Что
что если у вас там операции с остатком и вы n лог n раз берете процентик,
то вам нужно просто попытаться от этого избавиться.
Ну, классическая идея, да, то есть классическая оптимизация,
думаю, многие из вас сталкивались с таким, что если у вас, например,
надо по какому-нибудь простому модулю только складывать и вычитать,
то можно вообще обойтись без процентиков.
То есть можно писать там функции, которые там прибавляют и вычитают,
он с помощью одного прибавления и вычитания и, возможно, ИФА.
Вот, и это, оказывается, работает значительно быстрее,
потому что, как известно, чисто аппоратно, значит, умножение и деление в компьютере
работает дольше, чем сложение и вычитание ИФА.
И получается вот такая красивая несимпатическая оптимизация.
Ну, я думаю, это стандартная, я думаю, многие из вас применяли такую оптимизацию.
Ну, поднимите руки, кто применял. Ну, практически все, да.
Так что, кто не применял, берите на вооружение.
То есть это помогает, причем даже промочит сильно.
Ну вот, в принципе, слабая идея тоже.
То есть надо посмотреть, что вы делаете конкретно N log N раз и попытаться оптимизировать.
Вот в Фурьяке мы с таким столкнемся, что когда мы делаем N log N раз в какие-то три умножения,
то, оказывается, можно делать не три умножения, а два,
и тем самым едва ли не в полтора раза оптимизировать, собственно, алгоритм.
Вот.
Но в данном случае считать, что, скорее всего, сравнения будут весить не меньше, чем копирование элемента.
Ну, есть такое, то есть, конечно, да, то есть заметим, что мы, конечно, изучаем алгоритмы.
Да, можно там маркирочек?
Да. Ага, все, спасибо, Ахрана.
Вот, значит, когда мы берем, то есть в данном случае заметим, что мы сейчас изучаем алгоритмы,
которые работают в принципе в модели тех самых камешков.
Ну, потому что, как вот, потому что, ну, собственно, вы стояли, в общем-то, сортировка тоже предполагает,
что дали какие-то элементы какого-то шаблонного типа, да,
и вторым параметром вы подаёте так называемый компаратор.
Что такое компаратор? Это тот самый черный ящик.
То есть это тот самый черный ящик, который, собственно, берет два элемента и говорит,
верно ли, что первый меньше второго, да или нет.
По большому счету, то есть самое.
Ну, там вы его можете не задавать, просто по умолчанию он тогда создает свой стандартный
компаратор, который будет вызывать оператор меньше.
Вот. Ну, там подробности сейчас расписывать не буду, тоже вы,
то есть вы с этим обязательно столкнетесь, в чем, скорее всего, вполне вероятно,
что какую-нибудь сортировку может вы там даже на C++ напишете, а может, впрочем, и нет, я не знаю.
Вот. Итак, пойдемте дальше.
Вот. А, да, слайды закончены. Да, но рассказ только начинается, да.
Давайте. Вот. Так вот теперь пришло время. Нет, знаете, мы будем мыслить по-другому.
Давайте еще раз. У нас было три фазы, да? Нет, я просто, знаете, в этом плаге я люблю так,
что я люблю, как бы, отстегнуть самое простое, то есть, может быть, даже на уровне кодинга,
да, потому что, то есть, просто для того, чтобы потом об этом не думать, то есть я,
как бы мысленно скидываю из себя всякие мелочи для того, чтобы потом сосредоточиться на
главное, то есть, в принципе, я даже иногда там какие-нибудь задачи. Точнее всего там как-нибудь
сложные задачи, хотя бы на сколько-то сложные, я должен написать там несколько мелочей и,
как бы, самоинтеллектуальное. То есть часто бывает, что я вот понимаю, что мне это надо
интеллектуальное додумать, но прежде чем додумать, то есть я знаю, как оно должно выглядеть,
что это должна быть какая-то функция или какая-то структура вот с таким интерфейсом, и прежде чем
чем приступать к реализации я пишу весь остальной код который это и использует.
То есть тоже применяю те самые черные ящики, внутри черного ящика. Когда я буду писать черные
ящики, я буду думать только о том как это реализовать, а в ней черного ящика будут думать только о том
как его использовать и возможно какой интерфейс мне нужен. То есть я стараюсь чтобы эти задачи
максимально не пересекались. Здесь мы поступим так, что у нас есть три фазы. Первая построение
ранов, второе запихивание в стэк проверяем вариант, и третья фаза финальное слияние,
то есть когда мы просто на каждый шаг берем два верхних и сливаем, потом берем два верхних и слияем
и так далее и так далее и так далее. То есть на финальной фазе, когда мы уже просто этот стэк
полностью сворачиваем, мы уже об инверианте не заботимся, мы просто идем сверху вниз. Так вот,
то первая фаза очевидна, она работает за линию. А теперь давайте подумаем, за сколько работает
третья фаза. Ну для этого можно задуматься вот о чем. Скажите пожалуйста, а сколько времени вообще
это? А какого высота стэка вообще может быть? Ну да, логарифом. Самым простым образом можно
убедиться в этом. Почему? Потому что на самом деле из вот этих вот условий на самом деле следует,
что модуль Z меньше чем модуль X пополам. Ну достаточно очевидно мне кажется. Тогда это
означает, что высота стэка не более чем два лога. Это уже оценка. На самом деле это два лога,
это еще не точная оценка. Нет, ну смотрите, дело в том, что если у нас сказать, что эти раны идут
там первый, второй, третий и так далее, пятый, то на самом деле оценка снизу на длины этих ранов
получается что-то типа числа Фибоначи. Потому что F и плюс второе больше либо равно F и плюс
F и плюс один. Ну и при этом значит F первое больше либо равно единице. Ну в принципе на самом
деле из этого можно вывести, что там на самом деле F и Т просто будет больше либо равно чем
константа Фи в степени и умножить может быть на какую-то там неадекватную константу С. Вот.
Где Фи, что такое Фи? Правильно, Фи это решение квадратного уравнения, там Фи квадрат равно Фи плюс один.
Вот. Откуда я это взял? Нет, если вы не знаете, это вообще не АЧФ, действительно, совершенно верно.
Ну вот, пока, ну скажем так, может быть в будущем мы с этим, а ну да, в куче Фибоначи нам придется
с этим столкнуться. Ну типа того, да. Нет, что, а у вас уже было на УКТЧ? Будет. Ну я надеюсь, ну я думаю,
в худшем случае это будет у вас в четвертом семестре в диффурах. Нет, вот там вот действительно,
ну я, ну там так, а ну мы это уже в прошлый раз, по-моему, обсуждали, там говорилось,
что, допустим, у вас дана рекуррента вот эта вот Фи плюс два равно Фи, там плюс Фи плюс один.
Впрочем, это хочется вывести формулу, чему равно ФН. А дальше вы говорите, ну что, очевидно же,
ФН равно там какая-то константа на значит один плюс корень из пяти пополам в степени Н плюс
какая-то константа на один минус корень из пяти пополам в степени Н. Ну там конкретно С1, С2 подгоняете
с первых двух членов, а это оказывается по индукции. Да, что это такое, ну это просто, да, спрашивается,
откуда, ну то есть так, доказать это действительно очень легко по индукции, откуда я это взял. Ну
потому что, ну на самом деле, технология в данном случае говорит, а давайте, ну технология просто
говорит, давайте найдем какой-нибудь такой мистическая лямда, такая, что лямда в степени И
удовлетворяет вот этой рекурренте. Вот давайте попробуем такие лямды найти. Ну тогда это просто
лямды должны удовлетворять вот этому уравнению, вот прям в точности, да, и вот это вот это тупо корень
этого уравнения. Вот, но тогда, оказывается, но тогда из этого следует на самом деле такое, что,
во-первых, как бы, там это в степени, удовлетворяет рекурренте, это в
степени, удовлетворяет рекурренте, да, а осталось, осталось только сделать аккуратный вывод,
что на самом деле, на самом деле любая, то есть это означает, что, во-первых, любая рекуррента
такого вида удовлетворяет рекурренте, то есть любая формула, а во-вторых, легко, но отсюда,
на самом деле, легко вывести, что, на самом деле, всё что угодно, что удовлетворяет рекурренте,
имеет вот такой вид. Вот. Ну там просто можно,
действительно, это будет уже там уже достаточно легко показать. Но там просто потому, что там все
следующие члены, каждый следующий зависит от предыдущих, а как бы у вас как бы получается так.
Есть какая-то рекуррента, удовлетворяющая вот этим условиям и начальным условиям. Есть вот эта
формула, которая удовлетворяет этой рекурренте и начальным условиям. Следовательно, они совпадают.
Ну, в принципе, я думаю, после не позже, чем первый семестр линейной алгебры, на самом деле,
как бы это будет для вас стандартная логика. Потому что для вас не будет пугающим словосочетанием,
что все возможные решения этой рекурренты образуют линейное пространство с рангом 2.
Да, именно. Господи, да, базис. Вот. Так что да, но это не волнуйтесь, это как бы я проодонсировал
вам курс линала. Но я не знаю, может конкретно у вас сейчас будет больше геометрии, чем линала,
но ладно, не позже, чем первый год, вы это все равно так или иначе изучите. Это просто как-то это
база. Так вот, но это уже, впрочем, мы опять немножко как бы решили погулять и посмотреть в красивое
окошечко. Да, хотя как бы, ладно, это красивое окошечко нам еще встретится, как бы число фибоначи,
как говорится, всегда-то броит где-то рядом, то есть у нас как бы куча фибоначи, а не куча тарьяна,
и это не просто так. Хотя как бы ее могли назвать там кучей тарьяна, на самом деле, но вот.
Ну вот, но как бы соответственно. Вот, итак, но в принципе, смотрите, что мы можем,
какой мы вывод можем сделать. Раз высота логорифом, то в принципе отсюда автоматически следует,
что это все сливается за N-луган. Да, с другой стороны, какой-нибудь Тим Петер, у Тим Петер
сообщает, он считает, что это все слияние делается за линию. Почему? Ну очевидно же,
что если тут, допустим, какие-нибудь там один, один, два, четыре, восемь, шестнадцать,
тридцать два, то очевидно, что это как бы там все степени двойки схлопываются и получается линия.
Ну нет, он как бы и человек, он может и неплохой, но математик он не очень. Нет, или в этом месте
он не заморочился. Давайте так скажем формально, потому что теоретики может выяснить, что на самом
деле он может включить формализм, но в этом месте он не посчитал. А вот давайте думать.
Вот теперь давайте, вот уважаемые знатоки, внимание, вопрос. Верно ли, что тут работает за линию? Нет?
Мы все добавили в стэк? Нет, я имею в виду, что мы все добавили в стэк, как бы все инвариант
сохранился. То есть инвариант уже есть, и мы теперь вот сливаем сверху вниз. Вот возникает вопрос,
не верно ли, случайно, что это работает за линию? Ну в принципе да. Ну да, то есть обратить
внимание, что если брать вот это сверху, давайте вот снизу верх их нумеровать, давайте это будет
х1, х2, х3, х4, х5 и так далее, то давайте посмотрим, сколько раз, как бы если мы будем суммировать
все слияния, сколько раз каждый из этих элементов будет сливаться? Получится да, х1 будет сливаться
один раз, х2 будет сливаться получается два раза, там тут три, четыре, ну и так далее. Получается,
мы должны просуммировать, что мы должны просуммировать, то есть хит умножить на и,
и равно там один до какой-то высоты h. Понимаете, да? С другой стороны мы можем заметить, то есть
ну здесь мы не можем так оценить, что каждое следующее в два раза меньше предыдущего,
но на самом деле получится так, сумма по всем и равно от 1 до h и процент 2 равно 1,
х и умножить на и, ну давайте разделим эту сумму на суммы с нечетным индексом и суммы с
нечетным индексом. Вот и процент 2 равно равно нулю, нет пока, ну по-разному, да, тут разная,
но просто вот, нет, кто-то, просто как бы разные идеи, просто первая идея, которую я услышал из
зала, это вот сказали, то есть давайте, что как бы действительно та же самая идея, что тут 1,
2, 3 и так далее, вот я разворачиваю эту идею. Честно скажу, первое, что мне пришло в голову,
это доказать по индукции, как мы это делали там, собственно, две недели назад, вот, а вот можно,
ну вот, то есть тут вот, смотрите, что это такое, ну давайте так, я рассмотрю вот эту вот половину,
потому что половина рассматривается аналогично, то есть это на самом деле равно, сумме по всем от и
равно 1, там ж давайте, равно 1 до h пополам, х2 жt умножить на 2 ж, по большому счету, да, или что
то же самое, давайте двойку вынесем сразу, ж равно 1 h пополам, х2 ж умножить на ж, но теперь замечаем,
что х, что мы знаем, что х2 ж плюс первое, оно меньше либо равно х2 ж пополам, да, да, спасибо,
значит х2 ж пополам, то есть это в принципе означает, что это меньше либо равно, чем 2 на сумму по всем
ж от 1 до h пополам, что-то типа там, значит х2 умножить на что, то есть значит х2 умножить на 1
делить на 2 в степени ж минус 1, вот так вот, и сверху умножить еще и на ж, да, ну вот, ну типа мы знаем,
то есть х2 мы в принципе сразу выносим сюда, да, то есть давайте я так сразу напишу, ну можно это,
я так напишу сразу, это равно 4 х2 на сумму там по ж от 1 до h пополам, ж поделить на 2 в степени ж,
это равно там тета от х2, все, почему, потому что вот эта сумма, она не превосходит, мы уже выяснили,
что она не превосходит 2, то есть она просто не будет, то есть получается эта сумма тета от х2,
то есть это в общем-то тоже будет тета от х1, как легко убедиться, да, и тогда суммарно получается,
что это финальное слияние выполнилось даже не за n лог n, а за линию, вот, то есть можно доказать и
таким образом, можно доказать по индукции используя это, можно доказать что-нибудь по индукции,
ну да, можно доказать по индукции что-нибудь про Фибоначчи, но это уже технические детали.
Чего-чего-чего, еще раз, нет, ну да, время как бы у нас остается линией, мы никуда не денемся,
по памяти-то да, но сейчас это не принципиально, мы сейчас время оцениваем, вот, так что получается,
смотрите, что первая и третья фазы они получаются асимптотически не особо интересны, то есть,
конечно, да, хотя, конечно, это важный на самом деле факт того, что высота стека у нас никогда не
будет больше логарифма, ну ладно, вопрос только по какому основанию логарифма, там скорее всего
логарифм будет не по основанию 2, а по основанию вот этому вот, ну не совсем, это не называется число
Фибоначчи, это называется золотое сечение на самом деле, ну нет, ну как сказать, нет, сложно называть
номером числа Фибоначчи заведомо иррациональное число, так что нет, скажем так, это, ну скажем так,
вот фи, константа фи, вот это, это официальное название золотое сечение, то есть оно там еще где-то
там соответственно появляется, то есть полезно помнить, что там эта штука еще равна примерно,
значит, там 1.618, бла-бла-бла, вот, то есть, но она там встречается, то есть, возможно, если кто-то,
то есть, в принципе, есть тернарный поиск на самом деле с золотым сечением, вот это все, но так что
соответственно. Ну, наверное, да, нет, такого я слету не скажу, но как бы, нет, ну знаете, здесь я вам
просто, если вы там откроете википедию золотое сечение, вы там просто целый список увидите,
скорее всего, значит, что в математике значит это мистическое число, нет, оно воспето даже,
собственно, даже в книге Дэна Брауна код де Винчи, хотя, казалось бы, там речь идет, казалось бы,
даже едва ли не про Мону Лизу, на самом деле, про Мону Лизу там другое искусство, и выяснялось,
что там фи может возникать просто везде, просто со ссылкой два линии к витруэнскому человеку,
ну ладно, тут я уже совсем искусство копать не буду, собственно, как сказал бы классическая
монашка из этого мира, тоже это не мой конек, соответственно, да, а вы с ней не сталкивались,
да, нет, знаете, просто, нет, у меня просто были уроки МХК, ну, да, о господи, ну, как вам сказать,
ну, да, перерыв, наверное, где-то должен быть, так, вот я не, но, на самом деле, не хотелось бы сейчас
перерыв делать, нет, там вообще, ну, там, на самом деле, надо прокапываться, потому что, знаете,
в какой-то момент один из вариантов ВАЗИК, это может уже идти, идти, идти, в какой-то момент я вас
просто отпущу 15 минут пораньше, на самом деле, значит, нет, почему, но потому что, как бы,
мы с вами темсорти еще недообсудили, вот, а в темсорти, а в темсорти начинается самое интересное,
потому что в темсорти начинается, потому что есть вот эта финальная вторая фаза, и вот теперь надо
очень внимательно, вот давайте возвращаем теперь слайд, тут действительно написано,
что-то интеллектуальное во что надо вчитаться, ну, вот с этого места, тут-то мы все поняли,
а вот тут надо прям думать, вот, тут прям вот начинается действительно что-то такое красивое,
умное, вот, и теперь вот хочется, ну, вот, и это прям самое такое, то есть, конечно, в принципе,
кажется, что раз высота стека логорифум, на самом деле, то, казалось бы, там каждый, то есть,
каждый ранд будет, казалось бы, сливаться, но это, конечно же, не так, нет, ну, смотрите,
ну, казалось бы, поддержка инварианта, да, как выглядит поддержка инварианта, мы добавляем
новый ранд стек и проверяем, верно ли, что для верхней тройки, значит, инвариант выполнен,
если, ну, если выполнен, то окей, если не выполнен, то здесь важный момент такой,
берем, значит, тогда вот у нас есть тройка x и z, для нее инвариант не выполнен, берем y,
смотрим, а кто меньше, x или z, ну, варианты разные бывают, да, ну, как бы, ну, изначально,
да, но тогда что делать, если, значит, тогда, если x меньше, ну, то есть, самое простое,
если z меньше, тогда сливаем y и z, и тогда, значит, они слились, у нас появляется тут y плюс z,
но вот интересный вопрос, выполнил это теперь инвариант для, например, вот этой тройки, да,
но мы делаем это вайликом, это было бы самое простое, но маленькая подлянка, а что делать,
если x оказался меньше, тогда наш великий, наш тимпетр предлагает сливать не y и z, а y с x,
тогда, но тогда, смотрите, подлянка заключается в том, он вообще, он в этом месте, видимо,
предлагал не заморачиваться и просто говорить, давайте эту проверяем верхнюю тройку и не паримся,
но как бы у меня, лично у меня нет гарантии, что такого не бывает, что скажем, вот для этого не
бывает такого, что вот для этой тройки все в порядке, а для этой тройки нет, ну да, в общем-то легко
придумать, да, поэтому как бы в данном случае, вот как видно, лично моя интерпретация такая,
то есть давайте я сначала проверю вот эту тройку рекурсивно, а потом вот эту, ну то есть мысленно
я скажу так, то есть я как бы выкину x, y, z хором из стека, после этого как бы рекурсивно добавлю туда
x плюс y, там что-то тут поблаблашется, а потом в эту блаблаблашку я еще добавлю рекурсивно z.
Нет, ну как сказать, ну по-разному можно делать, там нет, ну как сказать, нет, конечно же рекурсивно
удалим, потом еще раз удалим и так далее, но просто фишка в том, что вот с x и z мы сделали так,
мы как бы в этом процессе одно слияние сделали, поэтому как бы рекурсия бесконечной не будет,
то есть как бы этим двум рекурсивным вызовом на самом деле перед этим соответствует просто одно слияние.
Если у нас получается x будет больше, чем z,
то мы сливаем, то мы достаем y и z, и как бы рекурсивно добавляем слитые y плюс z, а иначе мы
достаем x, y, z, добавляем x, y, но рекурсивно или можно как-то валиками мысли, то есть воображая
себе, что мы как-то умеем быстро как бы удалять. И теперь, собственно, у вас в домашнем задании будет
задача доказать, что это работает за n log n, значит это или почти это, но я имею в виду, что конкретные
условия может быть где-то вот тут, можно пошамай, то есть скажем, если вы, то есть вы должны будете в
домашнем задании явно прописать условия, но как бы если вы тут напишете больше либо равно, то очевидно я не обиджусь.
Ну, в смысле я, в смысле ассистент тоже не обидится. Нет презентации, пожалуйста выложу, это не проблема,
тем более, что по-моему есть вероятность, что я это уже сделал, потому что я вам там какую-то большую презентацию
другого года выложил, так что возможно там это все уже есть. Так что вот такая вот красота,
вот, но значит наметки как-то как-то конечно делать, то есть к сожалению высота логарифом вам ничего не
даст, потому что каждый конкретный ран может сливаться сколько угодно раз и при этом высоте не терять.
Ну потому что вдруг там какой-то найдется ран, который будет кучу раз сливаться со всеми раными,
которые тут выше будут набираться, вот поэтому этот вам придется мыслить действительно в
терминах амортизационного анализа. Вот, ну то есть там разные конкретики, то есть скорее всего тут
как раз вот очень удобно будет мыслить в терминах, а давайте-ка положим на каждый ран монетки.
Ну вот это вообще интересно, то есть может быть, ну скажем так, нет, подляночка,
смотри, если ты забудешь об этом условии, да, нет, ну как сказать, нет, один из тупых вариантов будет,
нет, ну такой может быть, нет, но есть, конечно, вариант, да, сливать тупо игр plus z, потому что
тогда как бы если x был меньше, то давайте сливать, то тогда все равно следующим шагом вы,
видимо, сольете y, y, z с x, получается хоррор, но на самом деле да, с точки зрения доказательства так
проще, конечно, но как бы у нас фишка в том, что мы имеем то, что нам заповедовал великий темпетокс,
как бы да, потому что в принципе да, то есть в принципе на самом деле да, так можно и более,
но ты и может быть это один из способов как-то тогда это на халяву там убедиться, что все в
порядке, вот, но опять же, но как бы фишка в том, что в любом случае вам в том или в той или иной
интерпретации, хотя философский вопрос, в какой интерпретации вам это будет проще делать,
вам придется как-то формально убедиться, но вот один из классических способов это класть какие-то
монетки, причем там на каждый ранг класть монеток там по количеству монеток, по количеству элементов
ранее умноженные, ну, например, на высоту, ну просто фишка в том, что как бы получается, если x,
например, вы сливаете там y с z, потому что z больше y, то как бы у вас получается высвобождается
монеток, то есть у вас высвобождается там типа там o от z монеток и получается, что как бы у вас
есть чем этот мерч оплачивать, но обратите внимание, да, то есть тут интересно, что монетки вам придется
класть так, чтобы суммарное число монеток все-таки у вас было n лог n, но потому что сами понимаете,
если у вас получится доказать, что это все работает за o от n, значит у вас что-то пошло не так,
потому что мы с вами доказали, что как бы у нас все кроме этого работает за линию, нет, может вы,
конечно, доказываете, что мы пробрались где-то в других местах, но как-то сомнительно, там слишком
простые вещи, потому что вот это вот действительно самое сложное, но соответственно, просто
готовьтесь, именно такое вот у вас в домашнем задании и будет. Нет, ну как вам сказать,
нет, я сказал, что скорее, наверное, все-таки, ну ладно, нет, смотрите, как сказать, в принципе,
ничего не стоит сделать две, но просто фишка будет в том, насколько нам эта амортизация в следующий
раз глобально понадобится, хотя я подозревал, до кучи фибоначий мы в следующий раз, наверное,
не доживем, но да, тут как показывает практика, то скорее всего мы до этого мержа рискуем сегодня
еще не дожить, так что ладно, две, хорошо, две, ладно, нет смысла, ну то есть в любом случае,
конечно, если вы, конечно, с этими задачами по раду, по занимаетесь уже раньше, то как бы
в данном случае какой смысл вообще в этом дедлайне? Почему я не говорю, что дедлайн,
скажем, когда-нибудь через месяц, через два, через три? Ну, просто, честно скажу,
периодически практикуют какие-нибудь практически задачи дедлайн, ну короче,
когда будет Зачет, всё. В данном случае дедлайн ставится раньше, потому что я хочу,
чтоб перед тем, как мы будем что-то изучать, вы уже с этим поработали. То есть сейчас вот Venet,
я вот максимально быстро ставил дедлайн по рекурентам то есть по этим точкам для того,
чтобы как бы это это вошло вам уже в подкорку уже на этот то есть и мы как бы уже дальше
мыслили именно в этих терминах вот это вот что я хотел вот собственно вот с амортизованным
анализом тоже самое потому что у нас значительная часть алгоритмов будет этого требовать поэтому как
бы нужно чтобы с этим поработали но практически в общем-то смысл смысл домашних заданий в общем-то
по большому счету именно вот так ну ладно ну что господа ну что перерыв или уйдем порой
нот или освободимся пораньше так ладно хорошо так ладно кто-то сомневается значит поехали так
кто за то чтобы устроить перерыв так то за то чтобы звать сейчас тупо продолжить уйти пораньше
ну да перед перерыв было чуть больше да ладно значит перерыв так передача мы сейчас делали
сейчас мы пожалуй до сложно алгоритмы сейчас нужно обсуждать не будем что времени осталось вот там
полчаса вот так что давайте стабильнее но вот поэтому конечно про просто там простые вещи
да обсудим видим в следующий раз будем обсуждать уже сложные значит соответственно и так вот но
во первых такие значит но мы обсуждали что сортировки бывают действительно бывает быстро и
медленная они там бывают там с лишней памятью лишней памятью но есть еще одна один еще интервей
периодически важный параметру сортировок это называется стабильность но этот параметр
возникает когда условно вам не все равно когда вам не совсем все равно в каком порядке
идут равный элемент но обычно если вы слетируете просто инты то да если они равны то в общем-то
как их переставлять в общем там действительно принципиально ничего не поменяется вот но
например если мы хотим сортировать числа по старшему разряду то нам бывает принципиально на
самом деле в каком порядке потом сами числа идут вот иногда но поэтому значит у нас вводится
определение что сортировка называется стабильной если при то есть если равные элементы идут ровно
в том порядке в котором они были так ребят что там заржать претерпите полчаса пожалуйста а то
просто не overly в тропы忙а Commonwealth интересно что там происходит вотeting вот
но еще конечно начнет то есть табельно есть еще понятие локальный сINGSparents специальное
определение называть сортировку локальные если она не требует дополнительной памяти ну уточним
требует под единицы дополнительной памяти совсем без там дополнительной памяти не получится то что
как бы понятно, что дополнительная память является даже там какой-нибудь это переменная ифорики,
это как бы уже 4 байта дополнительной памяти, но мы говорим, что конечно, чтобы эта память была
константной. Вот, ну в нашем случае, по крайней мере, вот оказался хипсорт локальный, мэкшсорт,
по крайней мере, без дополнительных взрывов мозга, локальный не является. Вот, ну хотя да, в следующий
раз мы изучим конкретный взрыв мозга, как сделать локальный, но да. Вот, но значит тут возникают
действительно достаточно интересные моменты, значит возникают они так, то есть предположим,
что иногда мы знаем точно, что мы сортируем, потому что фишка говорили, что мы, да мы, казалось бы,
доказали, что у нас там быстрее, чем сзен локальный сортировать нельзя, но тем не менее, вот,
например, у нас появляется задача, в которой отсортировать n элементов можно за линейное время,
но если мы точно знаем, что у нас есть n целых неотрицательных чисел, меньше к, тогда оказывается
само по себе их отсортировать, в общем-то, не сильно сложно, в чем, боже упаси, на самом деле в
этом месте даже писать там какую-то страшную merge sort, потому что вместо этого вы можете просто
для каждого числа от 0 до k-1 тупо посчитать за линию, сколько раз оно встретилось, а потом все
элементы тупо выписали, все. То есть, если точка, ну, формально говоря, не за o от n, а за o от n
плюс k, здесь вот появляется такой параметр, да, то есть если o от n, то подразумеваете, а почему
мы всегда числа не сортируем вообще за линию, потому что если числа до миллиарда, то это будет
работать не за o от n, а за o от n плюс миллиард, соответственно. Но, тем не менее, полезно помнить,
что несколько маленькие, то есть, если вы сортируете там числа до 10, то, конечно же,
лучше их сортировать вот таким вот способом. Вот он и просто пишется, и быстрее работает,
и вообще. Ну вот, реализовать это можно примерно вот таким вот образом. Да, конечно же, ни в коем
случае не забывайте удалять созданные массивы в конце. Видите, да, есть new, есть delete, но остальной
код я не думаю, что для вас дает сильно большие проблемы. Или дает? Нет, ну ладно, я думаю,
это как бы и да. Вот, но единственная, конечно, оговорка, что да, не надо было, конечно,
форик писать вот так, потому что на самом деле вот эти две строчки не надо так писать. Я бы
просто посоветовал уж конкретно эти две, вместо этих конкретных двух строчек на самом деле писать
одну конкретную. Нет, как бы, если у вас задача обнулить сишный массив, да, то заклинание пишется
так. Memset, значит, вот с, ноль, и в данном случае, ну, как вы гадаете, можно написать sizeof с,
если хотите прям весь массив. А если там у вас какой-нибудь мульти-тест и вам нужно обнулить не
весь массив, а только там от k условно, то можно было вместо этого sizeof написать sizeof от int умножить
на к. Да, потому что это какая-то аппаратная функция. Ну, если field, то это шаблонная функция,
которая, скорее всего, будет буквально пробегаться вот этим форумом. А это какая-то
олдскульная сишная, которая говорит, вот вам массив, в смысле, вот начало массива, вот сколько
байт. Вот каждый из следующих байт, скажем, вот столько байт, начиная с этого, должны быть равны вот
этому вот. Нет, топ-рек, я бы в C++, нет, просто я так скажу, в C++ я боюсь, нету таких низкоуровневых
функций тут в этом тело. То есть, так-то, с точки зрения шаблонов в СТЛ, да, есть field, это да. Вот,
но как бы если хочешь, но как бы да, но в данном случае это вот конкретно. Вот,
поэтому memset это вещь полезная. Вот, так что вот, как бы, по-хорошему, конечно,
за нуля стоит вот таким, то есть, лучше не таким фориком, а вот к честным memset.
Вот, идем дальше. Но, на самом деле, теперь, конечно, такая сортировка простая работает только в
случае, если нам буквально надо отсортировать числа от нуля до k-1. А теперь представим себе,
что нужно отсортировать, вот как мы говорили, массив по старшему разряду, например, или по
младшему, или просто у вас есть какой-то там point, допустим, да, ну там point или любая другая структура
данных, в которой есть какое-то поле от нуля до k-1, по которому хочется отсортировать. Вот,
но оказывается полезно, значит, то есть, тогда просто так вот так фориком не напишете, то есть,
там как бы недостаточно знать, сколько у нас элементов, то есть, сколько у нас элементов каждого
типа нужно знать сами элементы. Но, на самом деле, конечно, первая идея, которая приходит, давайте
вместо этих массивов сделаем вектор-векторов. Вот, но это не самое красивое, что можно сделать,
потому что вектор это все-таки такая вещь, которую иногда по возможности стоит избирать,
потому что все-таки вектор, как бы, считывая там все эти реаллокации, это все-таки по константе
получается все-таки жирно. То есть, амортизировано нормально, но по константе немножко жирновато,
поэтому желательно этого избегать. Но, на самом деле, есть, конечно, технологии, как это сделать,
даже стабильную сортировку таких элементов, просто в статическом виде. Ну, статическом в том
плане, что у вас все массивы статические. Вот, ну, там можно и в вектор, но в вектор вы
просто с самого начала делаете массив, один вектор размера k, другой вектор размера n и все,
в общем-то. И получается примерно следующее. То есть, давайте для каждой, ну, во-первых,
да, все-таки мы не обойдемся от того, что давайте для каждого элемента посчитаем,
сколько раз он встречается. Но этот массив легко превратить в, например, массив того,
где будут начинаться, то есть, когда мы массив отсортируем, где будут начинаться элементы,
равные вот этому. Ну, это легко просто фориком пробежать, правда? Ну, вот. Ну,
а после этого будем идти по массиву A слева направо и, соответственно, записывать в соответствующие
вот CIT, в CIT записывать очередной элемент и CIT увеличивать. Так, это понятно, что я говорю?
Да, это два прохода, да. Чего? В один. Ну, в один такой не очень понятно,
как когда у тебя произвольное количество групп не очень понятно, как в один. Вот. Да,
тут вот код может выглядеть вот таким вот образом. Вот. То есть, как бы, смотрите,
если мы храним именно начало групп, то придется тут вот такой какой-то код написать. Тут что-то
похожее на swap, но вот этот плюсик не дает возможности сказать, что это swap. Да, это не swap.
Вот. Ну и дальше получается, то есть, если кто-то писал когда-то суфф массив, то как бы вот это
заклинание вам должно показаться знакомым. Ну как, кто хотя бы раз в жизни писал суффиксный массив?
Так, ну тоже многие. Окей. Ну, в принципе, да. Возможно, это, кстати, первый раз в жизни,
когда вообще с такими сортировками в принципе столкнулись. Вот. Ну, мы с ними вот сталкиваемся
специально заранее в соответствующем месте. Вот. Ну, еще мы здесь сталкиваемся с тем, что если вы
хотите скопировать массив, то, кстати, тоже есть еще одна низкоуровневая функция, которая сделает
это быстро. Вот. Обратите внимание. Мем цпай. Ну, как бы, думаю, в немоника как бы понятно, да. Вот.
То есть, конечно, тут немножко не реально забавно, действительно, какие тут параметры вы вставляете.
То есть, очень важно, что сначала вы передаете указатель, куда копировать, а потом уже пишете,
откуда копировать и сколько копировать. То есть, сначала там dist. То есть, это указатель там,
если вы откроете прям там какой-нибудь cpp-референс. Ну, вот. Ну, значит, ошибка.
Да, вот и прикол, да. Так что. То есть, типа, вем цпай надо куда копирдат. То есть, здесь как бы
получается, действительно, аж о шрибочка. Ну, по сути, да. Да, я должен. Ну, а кто сказал, что как-то,
а кто сказал, что она правильная? Нет, я сейчас, возможно, просто немножко перестал пользоваться
презентациями, поэтому сейчас не помню. А так у меня в половине случаев любимый забавный. Все
понятно? Найдите ошибку. Вот. Так что, может, она там где-то еще тут ошибка притаилась. То есть,
я потом просто в какой-то момент обнаружил, что как бы показывая презентации, это как бы просто
темп задирается просто до небес и это идет в ущерб принимабельности. Поэтому я так презентации
сейчас вот. Сейчас я их использую, потому что я знаю, что ладно, эта тема еще будет там, собственно,
достаточно понятно, известная, поэтому это можно промолтать быстро. А там, скажем, по каким-нибудь,
то есть, скажем, по потокам, скажем, я уже презентации особо не показываю. Ну, и почти не
показываю. Хотя, то есть, они у меня есть, я их когда-то там писал, но как бы, возможно, лучше
без презентации просто будет медленнее и спокойнее. Поэтому тут вот еще такой момент есть. Вот. Ну,
тогда. Так вот. Что еще есть? Ну, да. То есть, ну, в принципе, есть такая. Ну, вот, ну, в принципе,
да, тут указывается у нас, как эта сортировка выглядит. Вот. Но идея, на самом деле, очень простая,
видите? То есть, как бы, вот, допустим, мы хотим отсортировать вот эти элементы. То есть,
сначала мы считаем, сколько каждого элемента от 0 до 5 встречается. Вот мы видим, да, что у нас
там вот два или две троечки, а там одна единичка и так далее. Потом мы прибегаемся в форикам и
выясняем, что там, где они будут начаться. То есть, там группа троечек будет начинаться,
например, с единички. Видите, да? Ну, правда, почему-то равно, как и. Ну, вот. Ну, да,
группа двоечек тоже. Потому что группа двоечек начинается там, где заканчивается группа единичка.
Группа единичек заканчивается в 0 плюс 1. Поэтому тут один один, тут три, тут четыре. Ну, а дальше
мы там уже прибегаемся и записываем, что в б-шке будет. Чего? Ну, пробежали, ну, пробежались как бы
фориком. Это фактически префиксные суммы такие сдвинутые. Ну, потому что где начинаются троечки?
Троечки начинаются ровно там, где заканчивается все предыдущее, правда? Поэтому мы в третий
элемент C2 пишем 0 плюс 1 плюс 0. Понятно, да? Или непонятно? Все понятно. Вот. Так что получается так.
Так что вот такая красота получается. Ну, в принципе, более популярная, конечно, в том же
суфмассе, конечно, вы скорее найдете вот такую реализацию. Она отличается тем, что мы ищем не
начало групп, а концы групп. Ну, потому что давайте найдем, где группы заканчиваются, и потом будем
идти тупо с конца. Так что, как видите, тут все то же самое. Даже вот мим цепая бага та же. Вот.
Соответственно, а так в общем-то суть абсолютно вот. То есть единственное, тут ТМПшки не надо,
просто как бы вы пробегаетесь и насчитываете префиксные суммы по большому счету. Так что вот,
в общем-то и все. Вот. То есть это более популярная такая реализация карманной сортировки. Тут
скорее удобнее писать скорее. Ну, смотри, давай сравним. То есть как бы суть одна, суть одна,
но тут просто какая-то гадость с ТМПшками, с лишними переприсваиваниями. Вот. А здесь ТМПшек нет.
То есть это может так, ну, я не знаю, кому как. То есть первая, возможно, интуитивно более
понятна на уровне идеи. Но здесь оказывается, что здесь просто чуть проще писать. Поэтому обычно
пишут так. Хотя, на самом деле, по большому счету примерно то же самое. Ну, идейная, в общем, разница.
Там, собственно, никакой нет. Слева направо или справа налево. То есть, наверное, если бы вы
были из каких-нибудь арабских стран, может для вас это было бы интуитивно понятнее. Ну,
это так я не знаю. Ну, я не знаю. В порядке это. Вот. Вот. Это в любом случае у нас сортировка под
счетом или там карманная какая-нибудь. Мы это будем называть карманной сортировкой. Вот. Ну,
у нас есть еще по-разрядной сортировка. Ну, просто идея такая, что если мы хотим отсортировать
какие-нибудь числа, но чисел уже больше, чем 10, 20, 40, там, 10 в пятый или хотя бы N,
то мы их так уже не отсортируем. Вот. Но, с другой стороны, если мы сортируем целые числа или,
кстати, строки, то их можно разложить на разряды. Ну, понятно. Строки можно сортировать. Ну,
строки так и сортируются. Помните, у нас же есть там лексиграфический порядок. Там по первой
букве прорыва первых, по второй и так далее. Ну, по большому счету, на самом деле, если предполагать,
что вам дали числа у всех, там числа, допустим, до 10 в 9, то можно предполагать, что у всех чисел
по 10 разрядов. Правда? Можно такое предполагать? Ну, вот. То есть у вас получается по 10 разрядов,
и, в принципе, их можно интерпретировать как строчки длины 10, которые вы хотите
лексикографически отсортировать. Вот. И, в принципе, какие тут технологии есть? Ну,
технологии бывают разные. Потому что, на самом деле, тут технологии делятся на ЛСД и МСД. Ну,
в чем разница? То есть разница в том, с какой цифрой мы стартуем? С менее значимых или с более
значимых? Вот. То есть, в общем-то, вот и вся разница. Ну, классический вариант, на самом деле,
с которым вы сталкиваетесь в том же суфмассиве, это, собственно, это вариант least significant
digit. Что это значит? То есть, идея вот такая такая. Давайте отсортируем числа сначала по младшему
разряду, потом по второму по младшести, потом по следующему и так далее. Но фишка в том,
что мы каждую сортировку делаем, ну, во-первых, мы делаем за линию, а, во-вторых, мы делаем
устойчиво. Вот. Или стабильно. Да. Но, на самом деле, ладно. Если это называется, бывает и так,
и так, на самом деле. То есть, можно стабильно, можно устойчиво. На английском звучит stable. В общем-то,
слова примерно одинаковые. То есть, как бы просто слово стабильно, это большая калькас английского,
на самом деле, чем устойчивая. Вот. То есть, вот такая классика. То есть, вот такая классика.
То есть, это такая надежная железобетонная сортировка, которая будет работать в точности
за какой симпточкой. Она будет работать за, получается, количество разрядов на вот n
плюс k. Вот. Ну, и потребует еще от n плюс k до памяти. Вот. То есть, вот такая вот красота.
В принципе, да. И более того, это нас может даже заставить задуматься. Потому что, смотрите,
у нас, смотрите, какие у нас есть вообще параметры в такой сортировке. То есть, у нас есть обычно
параметр n и параметр c. То есть, мы сортируем целые неотрицательные числа, не превосходящие c.
Вот. Что у нас тогда появляется? У нас появляется какое-то, мы говорим, что c – это число в
базычной системе счисления. Ну, то есть, системе счисления с основанием base. И точная симпточка
оказывается от, значит, n плюс base на логарифм, причем тут важно, по основанию base c. Видите,
так как тут переменная, то мне важно, по какому основанию. Да? Ну, обычно base – это какая-то
константа, там типа два или десять. Да, поэтому тогда получается просто n лог c. То есть,
формально говоря, радик-сорт работает за n лог c. Быстрее ли это, чем n лог n? Ну,
тестируйте. То есть, понятно, что на практике просто ради, там, в СТД-сорт обычно, там, как бы это не
пихают, но теоретически, может, и поможет. Но, на самом деле, у вас может возникнуть интеллектуальный
вопрос. А какое base можно вообще подсудить? Ну, потому что, в принципе, заметим, что base,
особенно если base какой-нибудь степень двойки подсудить, да, то вычленить подходящий разряд
достаточно легко. Потому что, на самом деле, тут в этой сортировке не учтено, что вы там,
когда сортируете по пятому разряду, то из этого числа пятый разряд неплохо бы выковырить. Но,
если у вас base – это степень двойки, то с помощью битвах операций вы это делаете более-менее на
халяву, правда? Ну, там, допустим, если у вас base равно, допустим, ну, я не знаю, 8, да, и вы хотите,
ну вот, и вы хотите там выковырить пятый разряд. Ну, если мы идем справа-налево, начиная с единицы,
да, то пятый разряд, тогда выковырить очень просто. То есть, это будет, значит, там x х 12,
получается. Почему 12? Потому что 3, ну, 8 – это 2 в 3, да, поэтому 3 умножить на 4, да. То есть,
получается 12 and 7. Все. Вот вы и выковырили нужный разряд за пару битвах операций. Вот,
да, вот такая магия. То есть, в общем случае, это будет выглядеть там x х base,
значит, умножить на, значит, номер этого разряда. Ну да.
Ну, лучше написать, конечно, вот это, после этого сказать, что base равно там 1 х x log base. Конечно.
Да, лучше так тогда. Да, тогда мы пишем здесь log base. Ладно, если нумеровать разряды с нуля,
даже не надо писать. Так, и end получается, ну, что-то типа base – 1. Да. То есть, в общем случае,
это вот так пишется. Нет, ладно, вру. Вот так. Да, лишние скобочки надо добавлять. Ну,
у вас, может, конечно, выяснилось, что там приоритет операции будет в вашу пользу, но я вот.
Чего? А вы не подсовываете туда отрицательное число. Вот это будет положительно и адекватно. Вот.
Но просто нет. Ну, смотрите, в общем случае, когда у вас эти n и c действительно идут на
бесконечность, ну, там мы, видимо, в следующий раз в этом подробнее поговорим, но часто суть в том,
что обычно c у нас охраничена аппаратно. Потому что, как бы числа и, то есть, числа, с которыми вы
можете работать за вот единицы, они заданы аппаратно. То есть, если у вас там какой-нибудь
там 64-битный компилятор, то значит за вот единицы вы работаете с числами на 64 бита. Вот. Но,
как бы, в общем случае, математика может думать, а как бы компьютеры будут развиваться, и битность,
на самом деле, может тоже увеличиваться. И тогда симптотика, соответственно, может тоже как-то
улучшаться. Просто в зависимости от этого, от n и c, можно думать, а какой base вообще подогнать?
Чего? Ешка? Ну, это все равно и получится. Ну, по факту, если в base подставить e, получится n на
линум c, и чего? Да, но в принципе, заметим, что можно немножко оптимизировать, на самом деле,
эту штуку, сказав, что если base примерно n, ну, там подходящей степень двойки, то тогда это будет
работать за n log base c. То есть log n там где-то c или что-то же самое n log c поделить на log n. То есть,
на самом деле, обычную по разряду сортировку классическую можно оптимизировать в log n раз.
Просто выбрав правильную базу. Ну, честно, я не пробовал, но в принципе, должно быть вот,
ну как бы сортировайте миллион чисел, должно быть вот в 20 раз быстрее. Вот, так что в принципе да.
Ну да, так что в принципе да, так что в принципе числа до 10 в 9, в принципе реально сортировать
более-менее за линию, да. Ну да, нет, ну совсем сублинейное не получится, конечно. Вот, не,
но там на самом деле чемпионаты на самом деле веселые, потому что в принципе, если вы сортируете
какие-то инты, помещающиеся в регистр, то там и возникает этот вот чемпионат, про который я
говорил, что именно такие сортировки, именно в таком виде и написано 2015 год, у нас новая статья,
мы умеем сортировать n таких чисел от n log log n. Это оптимизация предыдущего алгоритма,
который работал за n log log n, log log log n. Нет, там не log звездочка была, там просто log log n,
это вот собственно реально там статья 2015 года есть. То есть там это вот серьезный чемпионат,
но вот именно здесь вот мы можем сделать важную оговорку, то есть это сортировка именно интов,
влезающих в регистр. То есть как бы понятно, что там камешей, это сортировка, там абстрактные
камешки с компараторами, естественно, за такое время не отсортируют. Вот, то есть она пользуется
именно тем, что это инты и она с ними работает. Вот, поэтому n log log n, не путайте. Вот. Какие еще
варианты есть? Есть варианты, но теоретически есть вариант наоборот. А давайте пойдем слева на
правый, давайте сначала отсортируем товарищей по старшему биту, а потом поделим все на отрезке
по одинаковым, будем уже внутри себя сортировать. Такой подход называется мост с огнейшкин диджет.
Вот, ну в принципе тут, тут на самом деле дальше по-разному можно делать. Потому что если делать
это совсем в тупую, запускаясь рекурсивно, то по всем точкам, конечно, можно буквально чуть-чуть
озрести очень сильно. Хотя, нет, на самом деле можно, но давайте подумаем. Там будет написана какая-то
симптомика, давайте попробуем как бы это сами угадать. Вот представьте себе, что мы будем
сортировать неожиданным образом. Мы вот дан подотрезок, мы его сортируем по нашему разряду,
потом берем подотрезки, значит вот так вот, такие подотрезки с одинаковыми этими разрядами и
запускаем сортировку рекурсивно, но уже по следующему разряду.
Ну практически да, это N log N. Но это если будет так фантастически вести. Но на самом деле, хотя на
самом деле, если как бы разрядов два, тут будут битные числа, то я утверждаю, что это в любом
случае будет N log N. Почему? Потому что на каждом уровне суммарно вы все равно будете работать за
OATN. Ну да, логарифм уровней за каждым суммарно за OATN, потому что двойка – это констант. Но
проблема в том, что если у вас вылезет бейс, то с бейсом у вас будут проблемы. Почему? Потому что
на каждом уровне будет сколько-то рекурсивных запусков, и из каждого из них бейс вылезет.
Ну это если бейс от константа. Бейс же это не константа, мы с Шаманем. Но теперь давайте думаем.
Нет, ну там просто, ну смотрите, давайте думать. То есть у нас в каждом массиве будет длина этого
массива плюс бейс, правда? Ну теперь давайте, ну вот, то есть сумма, давайте так, то есть сумма по всем
левелам от одного до сколько там log bz получается. Нет, не log bz. Что получается? Да, log bz получается.
Ну вот, и в каждом левеле получается, значит, i равно 1, там col i t, я это напишу. Ладно, col level t.
Получается, значит, n i t, значит, n, вот так напишу, level i t плюс бейс. Ну потому что, смотрите,
на первом уровне у нас всего один отрезок длины n, это равно n 1 1. Да, там вот тут он подразбивается на
подотрезке, там, соответственно, n 2 1, n 2 2 и n 2 3. Тут он тоже подразбивается, я вот это вот имею
в виду, да, n 3 1. Сейчас вот, да, да, да, сейчас все это будет и так далее. Вот,
ну теперь давайте думать, чего равна сумма. Мы можем отдельно суммировать бейс, ну как бы
бейс, теперь вопрос, сколько раз встретится бейс? Нет, бейс встретится, нет, бейс встретится в
точности по количеству отрезков, но там, смотрите, там есть, конечно, разные подлянки, потому что очень
хочется сказать, что суммарное число отрезков здесь n, но это, к сожалению, не так. Там есть одна
подлянка, что дело в том, что отрезок может целиком перейти в следующий уровень, потому что может
так случиться, что очередной разряд там тоже совпал. Ну вот, тогда у нас получается, что, ну,
смотрите, сплитов вот этих различных подотрезков, различных вот именно как диапазонов, их будет
действительно n. Ну ладно, о от n, потому что, как бы, каждый вот этот сплит это разделение отрезка на
два. Разделение таких может быть, может быть, не более чем n-1. Ну, например, потому что каждый
сплит, он задается позицией разделения, такая позиция может быть только один раз. То есть, если мы
тут разделили отрезок, то больше у нас не будет отрезков, которые будут сплитоваться здесь. Ну,
типа того, видимо, да. Нет, ну, может, там можно как-то точнее, но, как бы, в итоге это не
происходит. Значит, по бэйзу, то есть бэйз может встречаться в худшем случае, получается что-то
типа n на те самые логбэйз с. Вот. Ну, а суммарная длина отрезков у нас получается n логбэйз с. Ну,
потому что на каждом уровне суммарная длина отрезков так или иначе n. То есть, получается,
видите, вот эта вот проблема с бэйзом и прокидыванием вот этой штуки, она на самом деле основная.
Ну, ее можно решать так. Вот. Ну, чисто теоретически, на самом деле, можно ее решать так. Нет,
можно сейчас. Ну, на самом деле, можно решить так. Конечно, на самом деле, от этого лишнего бэйза
можно избавиться вот от таких вот этих проталкиваний. Если вы прежде чем запускать сортировку подсчетом,
ну хотя, насколько это поможет. Ну да, то есть, как бы, если вы будете запускать сортировку,
прежде чем сортировку подсчетом запускать, давайте выясним, они равны ли тут все разряды.
Тогда от бэйза мы избавимся. Ну, правда. А чем это нам поможет?
Если мы будем брать вот таким образом, мы знаем, сколько у нас получается отрезков. Мы можем на каждом лево оценить,
как получается, ну, во-первых, n, n, потому что мы по всем полемся за количество элементов. Нет, ну,
там же нужно. Плюс бэйз в степени i. Так, нет, ну, просто чем-то нам поможет.
Точнее будет синтоника. Мы же не знаем количество отрезков на каждом уровне.
Не знаем. Ну, и что это? Ага, так, то есть, вы хотите сказать, что да, то есть, ага, то есть, ну, нет, ну, понимаете,
просто тут тогда зависит от вопроса, просто, ну, поедете, просто начинается какого-то, просто, как бы,
количество отрезков будет расти, как там, ну, да, какой-то, как сколько там. Ну, b в степени i, да, там может где-то выплыть лог b и z.
Так, ну, там начиная с какого-то момента, это все равно будет n, и там уже это, по-моему.
Просто b и z, мне кажется, бэйз в степени i можно реально всегда достичь.
Типа, если просто каждый раз делить, как, ну, в каждом отрезке, как можно больше его делить.
Так, ну, я не знаю, просто да, ну, я не знаю, ладно, сейчас давайте, времени мало, я боюсь сейчас нас, нас скоро просто выгонять начну.
Поэтому, ладно, можно там все это додумать, но можно так, а можно на самом деле действительно от лишних b и z избавиться,
сказав, что давайте просто прежде чем запускать по разрядную сортировку, давайте проверим, а нужна ли она на этом, на этом уровне.
Так, и сами по себе эти проверки на самом деле вот сюда прекрасно уложатся.
Вот, и бэйз тогда, но тогда бэйз у нас будет не лог, вот не столько раз у нас будет, а сколько получается.
Ну вот, просто нет, на лог бэйз, нет, он будет, тогда на самом деле бэйз, там на самом деле убьется как ни странно вот эта штука.
Потому что как бы только над, то есть как бы говорим, если у нас, то есть бэйз сводится, когда будет сплит, сплитов у нас м.
Так что это называется, можно допилить вот так.
Ну, на самом деле как бы чаще всего, конечно, ну, если бэйз константа вообще есть, конечно, другие способы, например, есть такой замечательный способ, как бор.
Ну, думаю, сталкивается такой структуры данных, да, то есть там, где стандартная сортировка строками, это называется, добавим строки в бор и запустим DFS.
Да, ой, мы не знаем, что такое DFS.
Нет.
Да, и что такое бор, мы не знаем.
Да, ну ладно.
Нет, я вам даже больше, это самое страшное, что, кстати, мы реально рискуем в этом семестре так и не узнать, что такое DFS.
Вот.
Нет, а что такое бор, это как бы его второкурс, сейчас еще не знаю.
Но это так.
А, ну ладно, ну хорошо.
Ну мало, и может вы его BFS написали.
Нет, компоненты связанности ищутся BFS.
Ну ладно, не важно.
Не важно.
Ну это ладно, понятно, что это, конечно, шутки, да.
Видите, тут как бы асимптутика, видимо, совсем мощная, так же соответственно.
Вот.
Ну еще, конечно, отметим, что чисто теоретически на самом деле можно еще делать там, если у нас побитика, можно вообще бинарный quicksort делать, кстати.
Ну так, то есть если вам очень хочется локальности там наплевать на стабильность, то можно забабахивать бинарный quicksort вот с таким пайвотом.
Ну это как бы тоже самое, как бы разбивать на те, у кого нолик, и те, у кого и денечка.
Ну то есть уже обсужденная в прошлый раз задача в украинском плане, короче, выплывает.
Вот.
Так же соответственно, можно так сделать, там получится вот даже вот так вот такая картинка.
Ну да.
Да.
Там писаться это будет примерно вот таким вот образом.
Может быть, там даже есть ошибка в коде, кстати.
Ну конечно, приятно, потому что третий раз уже его видим.
Знаете как-то, как всегда, закон учебы, если вы в какой-то момент пострадали и что-то подписали, то после этого это становится легко приятно.
Ну вот.
То есть по-разному.
То есть это классика такая.
Вот как-то раз, ну я просто занимаюсь волейболом, я вот как-то раз пришел на интенсив по нападающему удару.
Значит он, нет, интересно, не сам интенсив, а интересно, проходил он при этом в подвале какой-то школы, и зал так выглядит немножко побито.
Ну не скажу обшарпанно, но скажу побито.
Немножко типичный паркет там какой-то, стены немножко побиты и так далее.
Знаете, вот высекает просто такая картинка.
Обычно, знаете, представьте, человек только что выиграл чемпионат мира и спрашивает, скажите, пожалуйста, насколько это легко было, как вы к этому пришли?
И там человек начинает воображать, знаете, и у него так в голове сразу вот этот вот зал.
Значит темнота, может какая-то резерва, просто мрач, и он просто сидит и просто колотит мяч в стенку.
Значит именно в таком зале.
Да, вот именно в таких залах победы куются.
Ну вот, ну и обычно с дикартьячкой происходит примерно так же.
Ну не в смысле, что вы дикартьячкой там пишете именно в таких залах, естественно, да.
До начала бывает именно так.
Нет, у меня так было, знаете, еще с чем.
На самом деле у меня было, знаете, в конце этого семестра у вас скорее всего будет анализ функций.
В чем более того, даже не анализ функций, а анализ кривых видов, там х равно х от и и как равно и как от.
И вам придется анализировать, куда они там, где растут, где они там, куда загибаются и так далее.
Вот я помню, что первый раз я помню, я помню, когда с кем выходил дело, это был просто взрыв мозга.
Второй раз уже неожиданно оказалось нормально.
Вот, так что в этом плане просто да.
То есть что-то, если что-то страшное, надо просто на это идти и попробовать там один раз сделать.
То есть потом будет все легче и легче.
То есть как бы не, не бойтесь того самого первого гвоздя, который надо вбить в голову.
Давайте, ну сразу скажу, наверное, последний анекдот на сегодня.
Да, хорошо сказал, да.
Как будто да.
Чем мы тут занимаемся?
Да, анекдот отравим в телевизор, смотрим там вот это все.
Вот.
Да, да, да, КВН поминаем.
Вот.
Ну вот такой анекдот.
Просто такой, классический такой анекдот.
Значит, как известно, значит, легенды гласят, что каждому студенту в начале учебы приходит черт и говорит,
поздравляю, ты попал в ад.
И у тебя есть выбор.
Как говорится, в какой ад ты попадешь?
В обычный ад или в студенческий?
А можно попробовать?
Ну давай, давай попробуем обычный ад.
Окей, значит, черт уходит, значит, черт ушел и стал, значит, каждый день приходит черт и забивает студенту в голову гвоздь.
Вот вперед забивает.
Ну, соответственно, хорошо.
Значит, есть там первую неделю прожил, вторую неделю прожил, третью неделю.
Но при этом смотрят, что есть вот люди, которым почему-то явно гвозди в голову не забивали, они такие веселые, хорошие.
Вот слушай, я тоже хочу быть веселым.
Да все просто, они выбрали студенческий ад.
А давай я тоже попробую.
Ну давай.
Говорит черт.
И уходит.
Месяц проходит.
Два месяца проходит.
Действительно счастье.
Хорошо.
Действительно голова не болит.
Ну вот, наконец, зима приближается.
Зима где-то, значит, где-то там под Новый год приходит, значит, стук дверь, значит, отказывается.
Открывает, на пороге стоит черт.
С коробкой гвоздей.
Ну что студент?
Сессия.
Вот.
Так что на самом деле, да.
Вы можете считать, что это анекдот вас не касается.
Да.
Часто скажем, чаще всего происходит действительно именно так.
То есть, конечно, вы можете выбирать действительно баланс.
Но как бы активно призываю.
Крайне желательно, конечно, забивать гвозди как можно раньше.
Потому что, собственно, тогда вы, ну как бы сказать, и сессия будет легче.
Ну и гвоздей вы забьете немножко больше.
А в общем-то, как бы как это ни грустно, но в общем-то, вы сюда пришли именно за тем, чтобы забивать побольше гвоздей.
Вот.
Так что, ну вот.
Ну в некотором, ну в иносказательном каком-то виде вот последние 3 часа 45 минут мы примерно этим занимались.
Да, конечно, мы старались максимально обвеселять себе жизнь, но факт остается факт.
Так что в следующий раз мы будем забивать еще более серьезные гвозди.
Ну вот.
Ну пока.
Ну вот на сегодня все.
