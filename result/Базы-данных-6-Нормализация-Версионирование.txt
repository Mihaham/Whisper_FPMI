Очередная лекция. У нас сегодня такая, наверное, окончательная лекция, связанная с какой-то глубокой
применимой теорией, корреляционным базам данных, по крайней мере. Сейчас ее закончим, наконец-то
таки. Следующий уже у нас будет такая больше по углубленному синтаксису SQL и расширенным
возможностям. Ладно, такой анонс, который должен был бы быть в конце. Хорошо, мы с вами остановились
на нормализации, посмотрели основные нормальные формы. Вообще, что такое нормализация? Что такое
нормальные формы? Посмотрели, какие они бывают. В принципе, перечень увидели и остановились на
первых двух. Сегодня мы продолжим с нормализацией и закончим ее, собственно говоря. Посмотрим,
что такое версионирование и посмотрим на TCL, Transaction Control Language, а также,
что такое ACID и какие есть проблемы, связанные с изолированностью. Давайте начнем с нормализации
и, собственно говоря, закончим ее. Как вы помните из прошлой лекции, нормализация у нас определяется,
вернее сказать, тесно связана с понятием функциональной зависимости. И функциональная
зависимость, в принципе, довольно простая концепция, пришла к нам из математики.
Соответственно, здесь интуитивно нам все должно быть понятно, но здесь небольшая трудность,
заключающаяся в том, что у нас вместо одного одной переменной, по сути дела множество переменных
с одной и с другой стороны по отношению к знаку функциональной зависимости. Самое главное,
что нужно понимать, это если у нас кортежи совпадают по некоему атрибуту или некой
совокупности атрибутов, входящих в X, то, соответственно, значение их атрибутов, входящих
в множество Y, также должны совпадать. Ну или верно обратное, не существует двух различных
кортежей, которые в атрибуте X имеют совпадающее значение, в атрибуте Y имеют разные значения.
Левая часть на слайде это X-детерминат, правая это Y-зависимая часть. На прошлой лекции мы с вами
не разбирали усно, но давайте проговорим тоже, в принципе, в слайдах есть. Давайте проговорим
еще так же сейчас, чтобы, может быть, было всем очевидно и понятно, что такое теория Макитта,
потому что она, в принципе, позволяет более или менее простым, наверное, образом декомпозировать
вторую, по крайней мере, нормальную форму. По теориям Хитта у нас есть возможность декомпозировать
множество из, некое отношение, состоящее из трех множеств атрибутов, ABC это причем множество,
то есть под A и B и C может быть совокупность, не обязательно это один атрибут, может быть
совокупность атрибутов. Мы можем декомпозировать отношение R, если у нас есть функциональная
зависимость AB, на проекции AB и AC. И вот у нас будет следующий пример, поставщик город-продукт по
отношению к таблице, ну ниже в данном случае, применим, что A это поставщик, B город, C продукт.
Тогда, по теории Хитта, у нас AB поставщик город и AC поставщик продукт, можно декомпозировать это
отношение. Здесь видно же у нас, что между поставщиком и городом наличит функциональная
зависимость, у нас соответственно одинаковые значения атрибута поставщик, это ромашка и
подорожник, и у нас соответственно одинаковое значение для атрибута город, соответствующих
кортежей Москва и Краснодара. Срого говоря, нам не обязательно было бы для констатации
функциональной зависимости находить повторяющиеся значения. По большому счету, для функциональной
зависимости нам было бы достаточно, если бы поставщик и город, эти два атрибута, были бы
каждая из них уникальна. Там был бы тогда вопрос о возможности формирования составного первичного
ключа, ну как бы это оставим за скобками. Смысл в том, что если у нас не было бы противоречащего
определению функциональной зависимости условий, то есть, если бы у нас не было такого, что у нас
ромашка, это город Москва, и в строке 4 ромашка это город, не знаю, там, Екатеринбург, если бы у нас
такого не было, нам было бы этого достаточно. Если бы у нас была бы такая запись в таблице,
мы бы наоборот не смогли констатировать наличие функциональной зависимости, потому что это
бы противоречило, чему правильно определение. Ну или, соответственно, у нас можно
посмотреть на атрибут продукты город и обратить внимание, что для конфет у нас,
казалось бы, ситуация похожа на функциональную зависимость. То есть, когда у нас продукты,
это детерминат, а город-зависимая часть, имеется в виду, что конфеты у нас влекут Москву. Но если мы
посмотрим на шоколад, то при функциональной зависимости, ну предполагаемый продукт от
продукта к городу, а город зависит от продукта, у нас не соблюдается определение, потому что у нас
для атрибута продукт при значениях шоколад не все значения совпадают, потому что в одном из
случаев будет, соответственно, Санкт-Петербург. Ну, очевидно, что здесь имеют место избыточность,
как мы от этого избавимся по теореме Хита. Ну, все довольно просто, как описано выше. Для данного
случая все, в принципе, элементарно. Да, теорема, в принципе, да, есть доказательства ее, то есть,
есть доказательства у дейта, есть, нет, у дейта, ну такое, она описательная. Есть у Кузнецова
доказательства, прям формальная, хорошая. А все, что нам нужно запомнить из теоремы Хита, это,
в общем-то, вот, вот эта вот строка, что если у нас R, A, B, C, ну вот этот абзац получается, да, если R,
A, B, C, и если есть зависимость между A и B, ну, может быть, между A и C могла бы быть зависимость,
между B и C. Ну, вы понимаете, да, мы здесь просто для, мы не ограничены в вариантах. Смысл в том,
что есть три группы атрибутов, между двумя из группами есть функциональная зависимость. Тогда
мы можем отношение декомпозировать на два, декомпозировать без потерь на два вот таким вот образом.
A, B, A, C. Ну, в зависимости от того, да, какие у нас здесь бы буквы, какие у нас переменные бы стояли
вот в этой части, в этом, в этой функциональной зависимости, у нас бы здесь соответственно менялись.
Не знаю, B, C было бы, здесь бы тогда было бы B, A, и B, C, условно говоря. Вот, собственно,
все. Это просто вот способ, который нам позволяет декомпозировать наше отношение таким простым,
да, что ли, с образом, когда мы просто берем листок бумаги, записываем атрибуты или группы
атрибутов, делим их на три, находим функциональную зависимость и разбиваем соответственно на два.
Ну, повторюсь, это в первую очередь для второй нормальной формы, пожалуй, что актуально. Для
третьей, там не совсем теорема хита, ну, как бы не теорема хита даже, можно сказать, используется.
Поэтому, ну, вот здесь просто формальная, да, формальная теорема, позволяющая нам проводить
какие-то операции по типу, не знаю, теории множества, математической логики. Здесь
содержания нам, содержания какого-то по большому счету нет, просто игра с символами,
которая нам позволяет, когда мы эти символы интерпретируем, проецируем на какую-то предметную
область, прощать наши логические построения. Ну, собственно, вот на примере, да, здесь, обратите
внимание, мы просто взяли посылку теоремы, ее следствие, ну, посылка там, да, еще R, A, B, C,
и если A, то B, ну, вернее, если B функционально зависит от A, то тогда вот у нас R разбивается
на какую проекцию. И все просто вот формально расписали нам, расписали наш таблицу на поставщик
города, поставщик продукта. Еще раз, между поставщиком и городом у нас функциональная
зависимость, вот она явно представлена, потому что Ромашка-Москва, Ромашка-Москва, Подорожник-Краснодар,
Подорожник-Краснодар, то есть у нас нет нарушения здесь на совпадающих атрибутах у детермината и у
зависимой части. И мы могли бы взять другую функциональную зависимость, мы не здесь, ну,
мы здесь ограничены только содержательной областью, семантикой наших данных и наложенными
ограничениями, какие они у нас есть в базе данных. То есть, может быть, здесь это демонстрационная
таблица на три атрибута, понятно, у нас может быть таблица на 20 атрибутов, тогда там будет
сложнее. Нужно будет смотреть, что нам выгоднее, что образует более разумную семантику при
разбиении. В примере, вот, да, мы декомпозируем над поставщик-город, поставщик-продукт,
по теории Михита, и, в принципе, нам этого достаточно, то есть, в общем-то, довольно формально идем.
Ну, я не буду, наверное, останавливаться дальше на теории Михита. Единственно, ну, просто я даже
не знаю, что здесь содержательно еще можно было бы сказать, кроме того, что попробуйте взять,
попробуйте сгенерировать какую-нибудь базу, какое-нибудь отношение, да, и пора декомпозировать
его по хиту. Буквально там пару, парочку, троечку раз, если вы этого не делали еще на семинарах,
или, может быть, не допоняли чего-то, по теории Михита все будет довольно прозрачно и понятно.
А еще, наверное, есть, о чем хотелось бы сказать, мы на прошлой лекции немножко
порассуждали, задали вопрос на тему того, что у нас вторая нормальная форма говорит о том,
что у нас должен быть атрибут не ключевой, не минимально функционально зависим от первичного
ключа. Не является ли в данном случае, не было ли там пересечений между свойством несокрасимости
первичного ключа и вот этим вот требованием ко второй нормальной форме. Пересечений, я не было,
по одной простой причине. У нас несократимость первичного ключа говорит о том, что мы не можем
первичный ключ умножить там, ну не знаю, с трех, например, если он у нас составной, мы не можем,
ну мы выбрали его таким, у нас единственная возможность только его сформировать. Мы не
можем с трех атрибутов уменьшить до двух атрибутов. А вторая нормальная форма у нас говорит о том,
что если у нас есть некое отношение, в котором не ключевой атрибут будет зависеть не от всех трех
атрибутов первичного ключа, только от двух или от одного, то мы можем это отношение разбить на два.
И в исходном отношении у нас все равно первичный ключ будет несократимым из трех атрибутов. В
декомпозиции у нас может быть два отношения с другими первичными ключами, где количество первичных
ключей для каждого этого декомпозированного отношения, по сути, для проекции изначального
отношения. Может быть первичный ключ у нас в декомпозиции из двух атрибутов или из одного
атрибута или вообще из одного атрибута для каждого декомпозированного отношения. То есть вот
примерно такой ответ на тот вопрос, если его автор присутствует на лекции, то соответственно
ответ такой, если он помнит еще свой вопрос. Ну хорошо, функциональность, так, функциональная
зависимость аремы хита, ну вот то, что мы получили из тех формул, которые были на слайде, из тех
выкладок даже скорее. Вот пример. У нас все здесь получается по теории аремы хита, по-моему,
даже нормализовано до второй формы, если я не ошибаюсь. Так, ну хорошо, давайте посмотрим дальше,
что у нас есть. Еще две формы нормальных. Это третья нормальная форма и нормальная форма
бойса кода. Сразу оговорюсь, вот о чем. Мы с вами идем от простого к сложному, но на самом деле
здесь от элементарных до форм более сложных, но здесь есть некоторые нюансы. Нюанс номер один.
На самом деле мы стремимся к третьей, как минимум, нормальной форме, и предыдущие нормальные формы
это вспомогательные этапы, которые нам, ну, возможно, нужны будут, ну, очевидно,
нужны будут на пути для понимания, для формализации наших рассуждений, но вряд ли мы начнем с них,
когда нам придется декомпозировать таблицу из 20-30 атрибутов, ну, например, если не больше,
когда нам придется декомпозировать ее на какие-то составляющие отношения. Мы начнем не с того,
что попытаемся атомизировать данные, хотя, наверное, при определенных условиях это тоже
будет необходимо, ну, в зависимости от того, сможем ли мы вообще вычленить эти ненормализованные
данные или нет, но при нормализации мы, скорее всего, будем идти от понимания того, где у нас есть
функциональная зависимость, а где нет, и, ну, это так получается, да, немножко, немножко
контуитивно тому, о чем мы с вами говорим на последних двух лекциях. Мы идем от первой нормальной
вверх, на самом деле мы, скорее всего, будем спускаться вниз, проходя шаги, ну, если уж не с
третьей до первой, то, по крайней мере, не линейно будем идти. Также, что хотелось бы сказать еще,
подчеркнуть дополнительно, на самом деле у нас есть, вот какой момент, все эти нормальные формы,
по большому счету, способ, ну, по крайней мере, вот те, которые мы сейчас рассматриваем, не даваясь
более какие-то сложные вещи после бойса кода, они, по большому счету, призваны формализовать некое
такое, да, некий такой common sense, что ли, некий здравый смысл того, как данные должны выглядеть.
Поэтому, с одной стороны, у нас вот на форуме бойса кода будет пример, где декомпозиция привела к
некоторые дополнительные сложности в оперировании данными, а с другой стороны, это я к тому говорю,
что у нас нет прямой связи между тем, что мы нормализуем, и у нас будет идеальная база данных.
Нет, это как на практике неверно, потому что может повлечь дополнительные расходы просто на
транзакции, так и в теории неверно, потому что, ну, может повлечь тот или иной вариант декомпозиции,
те или иные потенциальные проблемы с аномалией, с обновлениями, как ни странно. То есть, здесь у
нас, еще раз, нормальные формы, все эти, они, получается, не всегда сильно связаны друг с другом,
что если мы там декомпозировали до третьей, нормализовали, вернее, до третьей нормальной
формы, то у нас прям вот, да, нормальная форма бойса кода, мы прям, молодцы, мы можем гарантировать,
что наша база данных замечательная, не противоречивая и все такое прочее.
Проблема возникает в том, что нормальные формы не отвечают за нашу симантику данных,
не отвечают за наше моделирование, за те сущности, которые мы выделяем, и поэтому к ним надо
относиться, ну, и ими надо пользоваться, надо уметь ими пользоваться точно, но, тем не менее,
относиться к ним с пониманием о том, что неверная формализация предметной области не сможет быть
исправлена нормализацией на этапе проектирования вот такого логического или даже, может быть,
физического, поэтому вот, пользуйтесь, но пользуйтесь с умом, что называется. Ладно,
long story short, простите за мой английский. Что такое третья форма? Отношение находится в
третьей нормальной форме тогда и только тогда, когда оно находится во второй нормальной форме,
и ни один не ключевой атрибут не является транзитивно зависимым от его первичного ключа.
Ну, и в скобках уточнения, что мы в данном случае полагаем, чтобы не было пересечений
с бойсом кодом, полагаем, что в наличии в нашем отношении только одного первичного ключа.
Ну, потенциального, да, здесь сказано, не прошу прощения, это не совсем верно,
первичного мы имеем в виду, потому что потенциальных может быть сильно больше,
ну, вернее, да, здесь я говорю, но потенциального к тому же является первичным ключом, да.
Неформальное определение отношения находится в третьей нормальной форме тогда и только тогда,
когда каждый картридж состоит из значений первичного ключа и множества взаимно независимых атрибутов.
Ну, наверное, неформально, наверное, попроще будет, то есть у нас каждый атрибут должен зависеть,
получается, только от первичного ключа, и первичный ключ у нас должен быть еще и таким вот атомарным,
скажем, да, подразумевается, что имеет только один атрибут в своем составе.
Но, тем не менее, давайте мы раскроем понятие транзитивной зависимости,
коль скоро мы все же его употребили в более формальном определении, но здесь все довольно просто,
как и в той области, откуда к нам пришло понятие функциональной зависимости,
определение тривиально, то есть если у нас есть последовательная зависимость атрибутов,
x, y, y, z, то мы можем говорить, что у нас x связан с y некой транзитивной зависимостью,
ну, не некой, а просто транзитивной функциональной зависимостью. Ну, можно уточнять,
да, что x не должен функционально зависеть ни от атрибута y, ни от атрибута z, чтобы у нас
не закольцовывалось все, но это уже, как бы, частности, с которыми мы, наверное, сейчас,
пожалуй, не будем взаимодействовать. Давайте посмотрим лучше, например, вот у нас есть третья
нормальная форма. Да, вопрос в чате. Может ли быть такое, что несколько атрибутов связано
с зависимостью с несколькими другими, как в этом определении, и в этой форме это учитывается?
Не совсем, честно говоря, я понял вопрос, но похоже, что может быть, если я его понял правильно,
то, в принципе, может быть несколько атрибутов, связанных с несколькими другими, и в этом
определении, ну, наверное, да, вы имеете в виду, что больше трех транзитивных, больше как бы
двух зависимости образует транзитивную, если вы имеете, ну, то есть, да, больше просто физически
количество стрелочек должно быть вот здесь. Там будет x, y, y, z, z там, не знаю, дальше пойдем,
да, зациклим z, a, z, a, a, b и так далее, и тогда у нас там y будет связан транзитивно с b. Такое
теоретически может быть, да, но здесь, пожалуй, вот о чем стоит сказать, что если у вас такая
зависимость, то, очевидно, вам не нужно будет разбивать ее, исходя из y и b транзитивно зависит
от y. Вам нужно будет декомпозировать ее поэтапно и смотреть, что получается. Опять же, не забывая
о семантике данных, чтобы получались какие-то рациональные отношения декомпозиционные,
а не, там, непонятно что, чтобы там сохранялись еще какие-то вот, ну, сейчас мы посмотрим,
что должно сохраняться. Хорошо, так, пример, поставщик, город, деталь, поставщик, у нас
еще и, допустим, первичный ключ. Ромашка, Ландыш, Василек, Роза, Архидея. Так, первичный ключ,
первичный ли это ключ у нас? Вот, казалось бы, Ромашка, Москва, Архидея, Москва. Нет ли здесь
противоречия? Противоречия нет, потому что у нас на разные, на разные значения детерминатов может
быть, тем не менее, одинаковое значение зависимости. На это функциональная зависимость ограничений
не налагает. А вот зато у нас, если бы была Ромашка в первой строке и Ромашка в пятой строке,
ну, у нас здесь Москва, окей, это нормально. Вот если бы была Ромашка в первой строке и Ромашка
в четвертой строке, вот тогда бы у нас не было функциональной зависимости и, ну, мы должны были бы
заключить, что мы сделали что-то не так. Не надо было либо первичный ключ делать естественным,
либо не надо было, либо надо было как-то базу данных иначе проектировать, чтобы у нас не попадалось в,
ну, не попадалось разных значений противоречивых в один картеж. Ну хорошо, это такое отступление
просто. Еще раз про функциональную зависимость, такая ремарка на полях, потому что понятие важное
для нормализации проектирования имеет существенное значение. Хорошо, поставщик, первичный ключ,
город, деталь. Какие функциональные зависимости? Поставщик и город есть, да, есть на каждую
независимую, на каждое уникальное значение детерминанта у нас также, да, некоторые,
любое в принципе нам значение зависимости в данном случае неважно. Главное у нас детерминанты
уникальные, зависимые части в этом отношении могут быть произвольные, хоть везде здесь могла бы
стоять Москва. А город, деталь, подходит ли или нет? Так, в детерминанте два повторяющихся
атрибута, Москва и Москва, для них должны быть одинаковые значения атрибутов в зависимости
части. Правильно, правильно, саморезы, саморезы. Опять же, но обратно это не работает. Вот город,
деталь, нет функциональной зависимости, почему? Потому что саморезы у нас есть, а им соответствует
в одном из трех случаев значение атрибута город значение краснодар. Ну и соответственно город
поставщики, поставщик тоже мы уже это проговорили, потому что Москва-Ромашка окей, а Москва-Архидея
уже не окей, функциональная зависимость по определению нарушается. А попробуем избавиться
от функциональной зависимости как и для второй нормальной формы с помощью теоремы хита. Вот
x, y, z, x, z, тогда r, это у нас что? Если x, z, то это x, y, проекция на x, z, прошу прощения,
на x, y. Получается поставщик-деталь, поставщик-город. Так делать не стоит, по крайней мере в общем
случае, потому что у нас так, да, мы теряем в данном случае при такой декомпозиции, мы теряем
одну из наших начальных функциональных зависимостей, мы теряем город-деталь,
вторую в череде наших транзитивных зависимостей, и мы по сути дела ее уже из нашей схемы не
восстановим. Мы ее можем восстанавливать только в некотором смысле искусственным путем,
только налагает дополнительные ограничения, какие-то проверки на наши отношения. Поэтому
в реальных БДД это может быть проблемой при добавлении данных, и так делать нельзя,
нам нужно как-то эту зависимость сохранить, по крайней мере, повторюсь, нельзя в общем случае,
исходя из теории, так делать нельзя, потому что деталь-город у нас независимый, и на этих
двух, на этом упрощенном примере этого не видно, да, нужно было бы что-то такое более или менее
реальное представлять себе, где бы у нас реально возникали проблемы с обновлениями,
здесь у нас с аномалиями. Мы хотим избавиться, мы хотим избавиться, это абсолютно точно,
мы хотим избавиться от транзитивной зависимости поставщик деталь, просто по хиту у нас получается,
что когда мы избавились по хиту, мы потеряли зависимость-город-деталь, и если в данном
случае у нас декомпозировано исходное отношение на два отношения, и они всего из двух атрибутов
состоят, каждый из, один из двух атрибутов при этом еще и первичным ключом является, то здесь,
конечно, у нас будут минимальные проблемы с нашим добавлением, мы можем всегда, не знаю,
ну единственно, да, там будут, возможно, если мы ромашку захотим поменять, ну мы затрем значение
города, да, для деталей мы если затрем саморезы, ну тоже, да, здесь не видно, но поверьте мне на слово,
если не верите мне, рекомендую вам прочитать Кристофера Дейта, у него прям две-три получается
главы про зависимость, ограничения и проектирование там до, ну до бойса кода там,
часть главы, еще часть главы, да, следующих более серьезных форм, в общем, поскольку мы потеряли
город деталь, повторюсь, мы здесь, конечно, вот, на таком простом примере, может быть, этого не
видим, но здесь возможны проблемы с обновлениями, то есть, если бы у нас были бы еще деталь там,
часть детали, не знаю, цвет, вкус, запах и цвет, город, там улица, дом, не знаю, количество человек,
может быть, или номер склада, у нас могли бы возникнуть проблемы при попытке добавления данных,
при, да, мы, так, мы хотим избавиться от зависимости среди неключевых признаков, но поставщик ключевой,
зачем от такой зависимости избавляться, а поставщик ключевой, ключевой вот в этом отношении. Смотрите,
еще один интересный момент, функциональная зависимость вообще никак не связана с ключами,
и это просто определение третьей нормальной формы нам говорит, что нам говорит о том, что если у
нас есть, так, промотал уже, да, что если у нас есть отношения, там, первичные, потенциальные ключи,
то тогда нам нужно понимать, что, то тогда мы уже здесь на третьей нормальной форме говорим,
что вот есть ключевые и неключевые атрибуты, и у нас от, неключевые атрибуты не должны быть,
неключевые атрибуты не должны быть взаимно зависимы. И, да, автор вопроса все понял,
ну, автор вопроса молодец. Еще раз, смотрите, у нас, да, есть в определениях и второй на самом
деле нормальные формы, да, там, когда перекрытие потенциальных ключей, первичных ключей идет,
там тоже про ключи, в принципе, говорится, но еще раз, в вакууме таком, что ли, функциональная
зависимость не про ключи, вообще не про ключи, функциональная зависимость, это просто про
совпадение значений атрибутов слева и справа, все. Поэтому тот факт, что у нас, мы хотим там
какие-то, где-то у нас ключевая, ключевой атрибут стоит в детерминате, где-то он появляется в
зависимой части, но теоретически, да. Окей, это нам не мешает рассуждать на тему того, что вот так вот
делать нельзя, а вот так уже можно, вот так кстати можно, вот так нельзя, потому что, и опять же,
мы здесь на самом деле, если приспотреться, мы здесь даже вот так вот просто на сколько можем
говорить, что мы сохранили избыточность данных. В каком плане у нас, если мы нормализуем это правильно,
ну как бы более рационально, сохраняя вот этот город деталь зависимости, то у нас здесь будет
меньше срок, так на минуточку. Мы избыточность убрали, которая у нас возникала, если бы у нас
поставщик и деталь ставились бы в зависимость. Поэтому еще раз, у нас в данном случае хит не
очень хорошо работает в общем случае, потому что город деталь не позволяет сохранить. Мы этот
город деталь зависимости нам пришлось бы сохранять иными способами, не внутри отношения,
не декомпозировав отношения на два и наведя между ними там функциональные зависимости какие-то
за счет ключей, а нам бы пришлось дополнительно как-то говорить, что какие-то ограничения вешать
на проверку, на добавление данных, триггеры бы какие-то ставить. Вот об этом идет речь,
что когда мы вот эту зависимость удаляем, мы ее формируем уже, вот здесь вот формируем не за счет
отдельного отношения, а нам придется вот эти отношения как-то связывать какими-то функциями,
какими-то триггерами, какими-то ограничениями, налагаемыми на реализуемые на этапе добавления
данных, на этапе операции insert или update или delete. И это не совсем правильно, поэтому мы здесь идем,
нам желательно провести декомпозицию так, чтобы сохранить промежуточные функциональные
зависимости в разных отношениях ях, и поэтому предлагается декомпозировать здесь в обратном
порядке, начиная справа налево, то есть имеется в виду, что поставщик это левый, деталь это право,
мы идем справа налево город деталь и город поставщик. Таким образом, если мы можем так сделать,
а мы можем так сделать в данном случае, то мы сохраняем зависимости и получаем два отношения,
которые еще и не страдают от избыточности, ну мы здесь как бы визуально видим, что мы
сократили даже число наших записей с 10 до 9 в нашей базе данных. Ну это скорее хорошо,
не обязательно, мы к этому не стремимся, но это, пожалуй, хорошо. Прошу прощения. Так,
если что-то непонятно, если что-то непонятно из этого, то я рекомендую таки к Дейту обратиться,
а если не к Дейту, то к Кузнецову, если не к Дейту, не к Кузнецову, если вы хотите получить вопрос о
лекции, можете задать его и мы попробуем еще раз проговорить об этом в следующий раз, потому что
тема интересная, ну такая она насущная, прям здесь есть интересная теория подлежащая,
которую можно, конечно, покрутить по интересным образом. Ну давайте пойдем дальше, нормальная форма
бойса кода, нормальная форма бойса кода используется, это более сильный вариант третьей нормальной формы,
и по большому счету в некотором смысле обобщение его на случай, когда у нас потенциальные ключи
являются составными, и они еще и перекрываются. На практике совокупность таких условий встречается
нечасто, поэтому часто ограничивается, ну, второй или третий нормальными формами в зависимости от
условий. Определение на слайде, то есть, опять же, формальная и менее формальная, давайте менее
формальная, наверное, хотя, ну, давайте формально тоже проговорим, потому что здесь терминология
немножко отличается от предыдущей лекции. Отношения находятся в нормальной форме бойса кода тогда,
и только тогда, когда каждая его нетривиальная и неприводимая слева функциональной зависимости
видит в качестве своего деттерминанта некоторый потенциальный ключ. Тривиальная
функциональная зависимость речь идет о том, что если у нас есть множество атрибутов, входящие в
первичный ключ, и если у нас какой-то атрибут отдельный или под множество, множество атрибутов
первичного ключа образует между собой функциональную зависимость, то есть между всем множеством,
например, и одним из атрибутов, или между всем можем множеством, мы его под множеством,
то такая зависимость называется тривиальная. Понятно, множество внутри себя замыкается,
то есть каждое под множество является включенным в некое свое над множеством. Как-то так,
наверное, если вспоминать более или менее терминологию теории множеств. А неприводимость
слева тоже самое, что минимальная функциональная зависимость. То есть слева, где терминанти,
у нас должны стоять атрибуты, какое-то количество атрибутов, которые мы не можем сократить,
мы не можем выдернуть из этой совокупности, из этого множества атрибутов, какой-то один,
не потеряв зависимости. Неформальное определение, оно следующее, переменные отношения находятся
в BCNF, BCNF тогда уж, а тогда и только тогда, когда детерминанты всех ее функциональных
зависимости являются потенциальными ключами. Причем, обратите в дебаде, еще у нас, что интересно,
что любопытно, BCNF определяется без привязки к нормальным формам нижестоящим. Здесь в этом,
наверное, проявляется определенная проблема, которую мы сейчас проиллюстрируем примером
на слайде. Давайте возьмем, например, отношение студент-предмет-преподаватель. Пусть у него
будут следующие ограничения предметной области, это не ограничение базы данных, это просто,
как бы, по сути, как эти существа, а в реальности, как эти сущности взаимодействуют. Они
взаимодействуют так, что каждый студент изучает определенный предмет только у одного преподавателя,
и каждый преподаватель ведет только один предмет, но каждый предмет ведут несколько преподавателей.
Слитно должно быть, прошу прощения за опечатки. А что из указанного условия следует? Вот так вот
абстрактно, даже не погружаясь в какие-то конкретные данные, мы понимаем, что студенты-предмет
забыкаются на конкретного преподавателя. Понятно, наверное, что студент Иванов,
наверное, теоретически может изучать студент Иванов предмет, не знаю, математическую логику
преподавателя Сидрова и преподавателя Смирнова, они, например, в течение семестра друг друга
заменили, но ладно, не будем такие крайние случаи рассмотреть. Для примера просто возьмем, что у нас
один преподаватель всегда ведет один предмет, поэтому студент с предметом можно считать это
детерминатом для преподавателя. Мы полагаем, что один и тот же предмет, изучаемый одним и тем же
студентом, обязательно влекут одного преподавателя в рамках конкретного семестра. А наоборот,
преподаватель ведет только один предмет. Кстати, если вы вспомните, у нас чуть раньше было на
начальных слайдах оговорка, что функциональная зависимость – это зависимость многие к одному,
причем многие это относятся к детерминату, а к одному это относятся к зависимости части. То есть
студент-предмет, многие студенты и предметы, многие, вернее, совокупность студентов-предметов,
они стыкуются с одним преподавателем, например, преподавателем Матлогита. И из второго условия
в сущности вытекает, что множество преподавателей у нас стыкуются с одним предметом, потому что
преподаватель ведет только один предмет, но у каждого несколько преподавателей. Соответственно,
многие на стороне преподавателей, а предмет остается в единственном числе. И, в принципе,
тоже опять же оговорка, пометка на полях, что функциональная зависимость – это связь
многие к одному, и при этом у нас детерминат, казалось бы, интуитивно на уровне какого-то
словопотребления, такого общего. То есть детерминат, то, что определяет, по идее,
наверное, он должен был быть один, ну и зависимая часть тогда одна, но на самом деле нет. На самом
деле нет. Детерминатов как раз такие может быть много. И вот с точки зрения наложения зависимости
на физическую модель путем формирования первичных и внешних ключей, вот те атрибуты,
на которых наложено ограничение внешнего ключа, они на самом деле будут детерминатами, а те
атрибуты, до которых наложено ограничение первичного ключа, будут зависимой частью,
хотя на самом деле, когда мы добавляем данные, когда мы пишем код, скорее всего, логично,
ну более интуитивно для нас будет подход, когда мы сначала говорим, ага, вот это будет
первичным ключом, этот атрибут, а на него будут ссылаться какие-то внешние ключи. Но тем не менее,
вот по определению возникает наоборот, получается наоборот. Так, BCNF, пример Иванов в математика
так, математика здесь должно быть да, предмет ДCan Cмирнов, профессор Кузнецов,
Д Can Cмирнов, профессор Кузнецов, имеющиеся потенциальные ключи Иванов, математика,
и студент-преподаватель. Потенциально ли это ключ? Иванов, математика, уникальное значение,
Иванов физика, уникальное значение, ну для Иванова физика имеется ввиду, для Ивановой,
для предмета физика у нас не повторяется больше Ивановы физика нигде, поэтому соответственно,
здесь вот этот кортеж он уникален, так то есть в принципе что еще да студент
преподаватель тоже получается что Иванов доцент Иванов профессор Кузнецов тоже
является уникальными значениями в рамках таблицы
совокупно да вот сложный составной ключ студент преподаватель студент
предмет у нас нигде значения их не повторяются
да здесь даже не нужно сравнивать с третьей колонкой нигде прошу прощения
здесь вот я вначале немножко оговорился по сути дела студент предмет уникальный
уникальный уникальный уникальный студент преподаватель тоже самое так и что
у нас тогда в чем возникает проблема ой прошу прощения
нам нужно чтобы все все наши детерминаты являлись потенциальными ключами и при
этом так когда являются потенциальными ключами да у нас здесь есть зависимость
функциональная между да студент предмет преподаватель преподаватели
предмет стоит смотрите студент предмет
оępляет преподавателя и вместе с тем у нас есть потенциальный ключ студент
преподаватель в котором мы можем взять преподавателя и указать функциональную
функциональную зависимость для атрибута предмет, но доцент спритов, доцент спритов, математика,
математика, кузнецов, кузнецов, физика, физика, то есть вот у нас первичный ключ,
студент, преподаватель, у нас привычный ключ, они пересекаются по атрибуту студент, и у нас есть
функциональные зависимости, но во втором случае у нас не обязательно функциональная, вторая
функциональная зависимость у нас не обязательно от второго функционального составного тревичного
ключа, достаточно только одного компонента, а мы это тогда декомпозируем, чтобы у нас по условию
все детерминаты всех функциональных зависимости являлись потенциальными ключами, и у нас мы
декомпозировали, преподаватель студент у нас тоже декомпозировал, у нас все детерминаты здесь
являются потенциальными ключами, но есть определенная проблема, все еще существует проблема вот какого
рода, что у нас исходная функциональная зависимость студент предмет, детерминат, что преподаватель
зависит от студента и предмета, не может быть выведено из той единственной функциональной
зависимости, которая сохранилась, преподаватель предмет. Что имеется в виду? Имеется в виду,
что у нас на самом деле в левом декомпозированном отношении функциональной зависимости как
не забавно и нет, у нас отношение преподавателя студент, исходное отношение разделилось таким
образом, что мы не сохранили все функциональные зависимости, но при этом мы наше исходное
отношение, которое не находилось в форме бойса, нормальной форме бойса кода, нормализовали,
вот то о чем я говорил, что у нас должна быть еще какая-то семантика подлежащая, на которую нам
стоит обращать внимание, и в данном случае такая нормализация, как приведена на рисунке,
она возможна, но получим ли мы здесь какой-то существенный прирост в производительности или
непротиворечивости, ну сложно, наверное, сказать, потому что преподаватель студент у нас вообще
получается стаблица «многие ко многим», которая будет у нас и слева, и справа очевидно иметь
ограничение внешнего ключа, и преподавателю к преподавателю в левой таблице будет вести
к преподавателю правой таблице, атрибут студента левой таблице — это estar wnекаем таблице студентов,
где уже студент, уже у нас будут уникальными сущностями.
E sister
Почему изначальная таблица не в нормальной форме бойс-кода, потому что переменные отношения находятся в нормальной форме бойс-кода тогда и только тогда, когда детерминаты всех фоноксиональной зависимости являются потенциальными ключами.
У нас здесь детерминаты фоноксиональной зависимости от 2 мы вывели.
Студент-предмет и преподаватель. Являются ли они у нас фоноксиональными ключами? Прошу прощения, потенциальными ключами.
Студент-предмет является ли у нас преподавателем? Преподаватель у нас не является первичным ключом, не является детерминатом и не является первичным ключом.
Вот здесь у нас преподаватель стал детерминатом по отношению к предмету и также первичным ключом.
А здесь правда у нас не сохранилась детермината и первичного ключа.
Знаете, любопытный получился пример, потому что он не то чтобы получился, это пример на самом деле из Кристофера Дейта, из его введения в базы данных.
Пример, иллюстрирующий неорганичность нормализации по отношению к реальной семантике данных.
Семантика у нас есть, она не в форме бойса кода изначальная таблица, потому что у нас в данном случае у функциональной зависимости преподаватель предмет не является детерминатом.
Функциональная зависимость преподавателя предмет есть, детермината, преподаватель предмет всех является потенциальным ключами.
Прошу прощения, преподаватель не является потенциальным ключом в данном случае.
Заговариваюсь, извините, ребят, не является потенциальным ключом, хотя зависимость есть, не является потенциальным ключом, потому что значения повторяются.
Вот здесь у нас значения не повторяются, здесь значения повторяются.
При этом функциональная зависимость преподавателя предмет есть, студент предмет, преподаватель тоже функциональная зависимость есть.
Нам это нужно разбить.
Преподаватель предмет мы разбиваем, у нас получается преподаватель-студент мы разбиваем.
Мы разбиваем, но по сути дела у нас здесь каждый кортеж является первичным ключом.
У нас здесь не то чтобы нарушается что-то, не то чтобы нарушается принцип чего-то, у нас по сути дела нет третьего атрибута, который был бы зависимой частью.
У нас вот это первичный ключ, вот это первичный ключ, вот это первичный ключ, вот это первичный ключ.
Просто вот здесь отсутствует функциональная зависимость по отношению к неключевому какому-то атрибуту.
В таком случае, это особенность отношения, потому что оно у нас такое маленькое, компактное получилось из трех атрибутов, демонстрационное.
Но мы тем не менее его нормализовали, мы убрали то, о чем шла речь, чтобы у нас не было детерминатов, не являющихся ключами.
Но при этом у нас появилась другая проблема, связанная с тем, что вот эта таблица многие ко многим.
И вот здесь из студента будет идти другая зависимость уже в другую сторону, должна идти, чтобы все это было тоже нормализовано, чтобы мы не добавляли сюда что-то произвольное.
Так что пример вот такой, пример с изъяном запланированный.
Для более, может быть, подробного описания, опять же, вас подсылаю к Кристоферу Дейту, где у него там целая глава на это отведена.
Но, в принципе, здесь, наверное, важно усвоить, что здесь нет четкого простого алгоритма для нормализации.
Как со второй нормальной формой или хотя бы с третьей нормальной формой, когда мы просто идем справа налево и декомпозируем.
Но, грубо говоря, в примере у нас получилось по стрелочкам. Вот какие у нас стрелочки были.
Мы две стрелочки, мы там выбрали два отношения, чтобы функциональную зависимость в них соблюсти, которая не была транзитивной.
Здесь нет какого-то четкого критерия.
Ну, опять же, Кристофер Дейт превыходит, честно говоря, алгоритм, но он такой сильно теоретический.
Я со своей стороны просто скажу, что для формы бойса кода, ну, практических ситуаций не так часто возникают для применения.
Поэтому знать нужно, применять стоит, если вы опознали ситуацию, подходящую под этот случай.
Но не факт, что это будет часто.
Поэтому еще раз напомню, что нам нужно было избавиться, и мы избавились от детермината функциональной зависимости в исходном отношении, который не являлся первичным ключом.
Ну, потенциальным ключом, во всяком случае.
Потому что вот преподаватели у нас в данном случае не уникальные записи, не соответствуют требованию уникальности первичного ключа.
Хорошо, все, распрощались с нормализацией. По бойсу кода у нас в любом случае не будет никаких вопросов, ничего.
На семинарах мы, по-моему, тоже это не должны проходить и не проходили.
Поэтому это такой теоретический плюсик в копилку ваших теоретических знаний, по крайней мере, и, возможно, практических тоже.
Хорошо, версионирование. Давайте быстро посмотрим, на слайдах будет подробнее.
Ну, что это такое? Версионирование, в общем случае, это просто способ хранить историческую информацию о измененных значениях в базе данных.
Можно говорить о том, что есть и версионирование на уровне физическом, ну, окей, на уровне функционирования СУБД,
а есть версионирование на уровне логическом, логикосемантическом, даже скажем так, встроенное за счет внутренних средств СУБД или расширений.
Понятно, утилиты какие-то, в позгрессе, например, ну и не только в позгрессе.
Вот там, если вы погрузитесь, там, на самом деле, есть у каждой строки, на диске физически есть версия, хранятся версии строк.
Это не совсем про версионирование в том смысле, что можно это извлечь и прочитать, но, тем не менее, позгресс хранит версии строк,
и в момент совершения транзакции там может быть несколько этих версий строк, хранящихся одновременно, ну как бы и так далее.
Ручное, ну понятно, мы здесь строим какие-то конструкции, чтобы в нашей схеме данных, чтобы мы могли при изменении данных
в наших каких-то технических таблицах ввести учет этому.
Ручное версионирование используется такая концепция, как Slowly Changing Dimensions, медленно меняющиеся измерения,
а, в свою очередь, почему мы сейчас вдруг вот такую терминологию, внезапно к ней пришли и ее используем, очень просто.
Это речь о том, что концепцию эту придумал Ральф Кимбл, ну, в частности, можно посмотреть и подробнее прочитать.
Ральф Кимбл и Маржи Роз.
Вообще, Ральф Кимбл это один из двух ключевых ученых и публицистов, специализирующихся на построении хранилищ данных.
Второй это Уильям Эйнман, ну а об этом мы с вами поговорим на отдельной лекции.
Смысл в чем? В том, что в хранилище данных, условно, то есть хранилище данных, что такое?
Это место на диске, или большой диск, или большое количество серверов с большими дисками, куда сливаются данные из разных источников.
И подчас не всегда они нормализованы, и сама структура этих хранилищ данных не всегда предполагает или требует нормализации.
Вот Ральф Кимбл как раз сторонник идеи, что нормализация, такая глубокая хранилища данных, она мне нужна.
Он предлагает иную схему построения, которая называется звезда, звездочка или снежинка,
где таблица у нас делится на таблице фактов и таблице данных, таблице измерений, прошу прощения.
А таблица фактов, это просто условно говоря, вот у вас чек пробивается до касси и идут данные в таблицу фактов.
А в таблице фактов у вас там есть кассир, магазин, номер кассового устройства, товар.
И вот эти данные, кассир, магазин, товар, они у вас являются внешними ключами по отношению к каким-то таблицам измерений.
У вас есть таблица отдельная на измерение товаров, на измерение кассиров, на измерение магазинов.
То есть измерение в данном случае в русском языке, здесь такая амонемия получается, измерение я измерить и измерение в смысле пространства какого-то.
В данном случае речь, когда мы говорим про медленно меняющееся измерение, про некие пространства в семантическом плане,
в некой области наших данных, по сути дела это отношение, медленно меняющееся отношение для лучшего понимания, можно сказать так.
Хорошо, так, ну здесь еще немножко подробностей про...
Да, так, и это просто для примера, да, sales effects, таблица фактов, и вот date dimension, product dimension, это вот прямо из книги, цитата,
в виде рисунка дата warehouse look 2013 года издания.
Медленно меняющиеся измерения несколько типов выделяют, у Kimball их вообще шесть, но последние два они производные от предыдущих,
поэтому мы поговорим о четырех быстренько, пяти вернее, с нуля начинают, там получается семь у Kimball.
Тип 0 это вообще, по большому счету, не SCD, это просто оригинальная таблица, тип 1 это перезапись, когда мы постоянно меняем данные в некой исходной таблице,
и тип 2 это новые строки, тип 3 новые атрибуты, тип 4 новые отношения. Как это все выглядит?
Ну, все довольно просто, тип 0, тип 1, понятно, там не о чем говорить, не будем приводить примеры.
В данном случае у нас в каждую запись добавляется новая запись при каждом изменении,
и здесь еще и атрибуты добавлены, конечно, но они такие технические, что ли, которые хранят время просто в записи, когда у нас что-то меняется.
Вот Николай перешел из позиции 21 в департаменте 2, на позицию 23 в департаменте 3.
И, вернее, наоборот, нет, прошу прощения, он перешел с одной позиции на другую, там или работал где-то, может быть, даже параллельно.
У нас здесь есть время, начало-время-окончание, и вот здесь время еще не закончено, он продолжает работать в департаменте 3 на позиции 23.
Вот мы вот так храним по Николаю каждое движение внутри нашей корпоративной структуры в таблице типа SCD2.
В полях технических обычно не пишется null, то есть мы здесь пишем не null, а просто филер такой добавляем для того, чтобы упрощать запросы,
чтобы писать в первом случае where day dt between valid from dttm и valid to dttm вместо вот такого более сложного запроса еще и с несколькими условиями.
Так, достоинство неудобства хранит не полную и ограниченную историю версии, хранит полный и не ограниченный удобный и простой доступ к данным необходимого периода,
и с другой стороны провоцирует избыточность или заведение дополнительных наблиз для хранения изменений атрибута.
SCD типа 3, где мы прям отдельно храним в виде отдельного атрибута значение предыдущей нашей некой переменной.
У нас в принципе что здесь имеет место быть, то есть мы здесь прям идем не от дат, не от новых строк с точки зрения времени, мы идем с точки зрения изменения качественной характеристики,
добавляем для этих качественных характеристик отдельные поля, причем в данном случае это упрощенный пример такой.
По большому счету мы бы могли целиком добавить предыдущее значение некоего кортежа в левую часть таблицы, дописав точно те же самые колонки,
ну за исключением первичного ключа там айдишника, и у нас была бы строка, где вот не просто привез current state 01, а у нас была бы еще строка, где было бы update DTTM дополнительно и было бы старое время.
Ну пример такой да условно немножко в данном случае в педагогических так сказать целях.
Достоинство небольшой объем данных, простой быстрый доступ к истории, но ограниченная история, потому что мы храним только, ну как бы вот по методологии этой нас никто конечно не ограничивает, но по методологии мы храним только последнюю версию,
последнюю и предпоследнюю версию и не глубже. SCD тип 4 здесь тоже все довольно просто, у нас просто отдельная таблица с историей.
Ну собственно все в отдельную таблицу мы заводим все что захотим, ну подробности изменений заводим любые какие посчитаем нужным.
Недостатки здесь разделение сущности на разные таблицы, это с одной стороны и недостаток некоторые, что нам придется более сложные запросы какие-то составлять,
с другой стороны это может быть наоборот достоинство, потому что логически у нас хорошо все это разделено и у нас не возникает никаких проблем при добавлении данных,
мы их по разным таблицам распихиваем, у которых разные ограничения, разные условия и в этом смысле все достаточно удобно кажется.
Так, TCL, ACID и изолированность, вот мы и добрались до очередной группы нашего SQL, SQL SQL Transaction Control Language, основные команды Комит и Албек,
и у нас здесь возникает вопрос, а что такое вообще транзакция?
Транзакция это группа последовательных операций с базой данных, которая представляет собой логическую единицу работы с данными,
гарантированно переводящая базу данных из одного непротиворечивого состояния в другое.
То есть у нас смысл в том, что при выполнении транзакции должны сохраняться все те ограничения, все те зависимости, которые у нас предусмотрены нашей схемой,
и при этом наша транзакция должна работать независимо от каких-то сбоев в плане физического оборудования в том числе,
и также она должна выполняться по принципу все или ничего.
Транзакции реляционных с систем управления баз данных обязательно имеют четыре ключевых свойства, это аббревиатура ACID,
и важно подчеркнуть, что речь идет именно о реляционных с UBD, потому что для иных типов с UBD там могут быть иные варианты их существования,
как бы в реальном мире проведения транзакций.
Но об этом мы с вами поговорим, я надеюсь успеем затронуть NoSQL базы данных в общих чертах, поговорим.
Здесь небольшое отступление сразу сделаю, есть более общая концепция, из которой можно как бы вывести ACID,
свойства, это теорема Брюера или CAP, CAP теорема, она говорит, ну такая по большому счету империческое наблюдение,
это из серии, что можно долго, дорого и качественно, вот мы можем из этих трех вариантов максимизировать только два и никогда не три,
вот здесь то же самое, только качество согласованность данных, доступность данных и устойчивость к разделению,
мы можем максимизировать только два из них, но никак не три, ну как бы физически это наше ограничение,
в той реальности, в которой мы живем, только два можем на данный момент, может быть что-то придумают дальше,
более интересное, какие-нибудь квантовые базы данных, ну ладно, не будем фантазировать на эту тему,
смысл в том, что максимизация параметров consistency и availability, то есть согласованности и доступности данных,
порождает ACID свойства транзакций для реализационных систем управления баз данных,
и соответственно, как вы понимаете, у нас более низкая устойчивость к разделению в наших РСОБД.
А что такое ACID? Это Atomic Consistent Isolated Endurable, атомарные согласованные, изолированные, долговечные,
устойчивые должны быть транзакции, то есть выполняться по принципу все или ничего Atomic Consistent,
каждая успешная транзакция фиксирует только допустимые результаты, то есть соблюдает все ограничения наших данных,
изолированные, то есть параллельные транзакции не влияют на результаты друг друга,
durable, долговечные, устойчивые, то есть вне зависимости от сбоев, результаты успешных транзакций сохраняются в системе.
Так, ну здесь просто более подробное описание Isolated Consistent Endurable, ничего сложного на самом деле нет,
там можете посмотреть просто слайды, все это довольно явно вытекает из того, о чем мы говорили,
из того, о чем сказано на начальном слайде по поводу ACID.
По поводу основных команд TCL, это Commit Rollback SF Safe Point.
По умолчанию, кстати, у нас наше insert, например, update, delete команды, они уже, ну и там еще ряд команд SQL,
которые мы проходили, они уже у нас содержат команду Commit после себя, то есть происходит autocommit всегда после их выполнения.
Мы же можем произвольно задать условия для выполнения коммитов, в них сделать Rollback и Safe Point для того,
чтобы в случае, когда мы сомневаемся в отношении какого-то каких-то данных их внесения,
когда мы сомневаемся в отношении устойчивости нашей системы, мы могли всегда откатиться либо на Safe Point,
либо на начало операции, ну сейчас посмотрим, что это такое.
Всегда начинается с Begin Transaction, наши TCL команды, уровень изоляции определяется, что это такое сейчас тоже скажем.
Дальше Read-Write Only, понятно, писатели читают только уровень ограничения.
Defrable, ну давайте пока без Defrable, если хотите, можете в документации почитать подробнее.
В принципе Safe Point, мы можем еще задать имя Safe Point для того, чтобы конкретно указывать,
куда конкретно к какому Safe Point из нескольких нам откатываться.
А вот пример, Begin Transaction Isolated Level Read Committed, добавляем данные в таблицу, делаем Safe Point, My Safe Point,
добавляем в единичку, добавляем двойку, добавляем тройку.
Когда у нас срабатывает Rollback to Safe Point, после добавления двойки мы откатываемся вот в этом блоке,
мы откатываемся на Safe Point, у нас двойка не сохраняется, у нас тогда и конечная команда нашей транзакции будет добавить тройку,
и мы на выходе получим таблицу Table1 со значениями 1 и 3.
В данном примере, конечно, здесь нет никакой логики, для чего это нужно,
но это бывает нужно для того, чтобы лишний раз удостовериться, что у нас не упадет наша транзакция с ошибкой,
либо если упадет, то тогда хотя бы часть данных будет внесена либо изменена,
на которую мы рассчитываем и надеемся, на их изменения.
Есть проблемы поддержки изолированности.
Проблема поддержки изолированности – потерянное обновление, грязное чтение, неповторяющееся чтение и чтение фантомов.
И для этих проблем существует уровень изолированности, корреспонтирующий им.
Потерянное обновление – это когда у нас…
Ну да, проблемы изолированности вообще что означают?
Что у нас в параллели выполняются какое-то количество транзакций,
и они начинают влиять на данные, которые используются друг другом.
То есть одна использует те же самые данные, что и вторая.
Ну а в масштабе это может быть десятки, там сотни транзакций.
И потерянное обновление, например, у нас неопределенный результат получается,
когда у нас две транзакции обращаются к одной и той же таблице, к одному и тому же атрибуту этой таблицы.
Итоговая сумма на вашем счете при внесении пополнения и поступления перевода будет неопределена.
Ну как бы в плохой ситуации. В реальности, конечно, у нас банковские базы данных умеют этим бороться.
Грязное чтение. Когда у нас получается, что последствия одной транзакции влияют на другую.
И неповторяющееся чтение, ну да, то есть грязное чтение, когда у нас,
когда происходит чтение изменяемых в процессе чтения данных,
уже непонятно может получиться, что данные, которые прочитает база, они будут либо старые,
либо, наоборот, новые. Например, если у нас еще иерлбек произошел, то будут новые, которые тем не менее не были внесены.
Это тоже проблема. Неповторяющееся чтение, когда у нас между двумя последовательными обращениями к базе данных происходит какая-то транзакция.
Ну, например, причем это не просто разные селект-запросы, а это, например, один вложен в другой, то есть это под запрос.
И здесь у нас может получиться так, что данные будут, да, инконсистентные, не связанные, не соответствующие друг другу.
И таким образом возникнет проблема, связанная с тем, что мы просто получим какой-то невразумительный результат на итоге,
ну или вот как в примере, да, что с карты списывается большая сумма, чем мы ожидали.
Хотя мы там могли либо там удалить данные из корзины, либо, наоборот, там данные какие-то поменять, если бы речь идет о каком-то онлайн-магазине.
Или чтение фантомов, когда у нас происходит тоже, ну, по сути дела, похожая ситуация,
что мы не учитываем какое-то обновление данных, которое происходит в процессе нашей работы с базами данных.
Изменяются данные в том или ином отношении, в той или иной таблице, а наш результат выполнения наших запросов не соответствует реальному содержанию нашей базы данных.
Соответственно, есть уровни изолированности транзакций, uncommitted, committed, repeatable, repeatable, serializable.
Все эти уровни, они на самом деле типические, и от менее изолированного к более изолированному располагаются.
Смотрите, уровни изолированности обеспечивают решение проблемы потерянного обновления, грязного, неповторяющегося фантомного чтения.
И вот чем выше уровень, тем больше проблем решается.
По умолчанию, кстати, в Postgres return committed установлено, поэтому здесь ну, это тоже нулевой уровень для Postgres.
Есть проблемы, связанные с увеличением уровня изоляции, когда мы делаем наши транзакции, совершаем.
Проблема очень простая заключается в том, что чем выше уровень изоляции транзакции, тем проблемнее будет другим командам, конкурирующим запросам,
прочитать, изменить, удалить, внести данные, то отношение в тот кортеж, который сейчас у нас находится, который сейчас у нас обрабатывается транзакцией с высоким уровнем изолированности.
То есть чем выше уровень изолированности, тем ниже уровень параллелизма.
Все, на этом сегодня заканчиваем.
В следующий раз у нас будет большая, по содержанию, лекция, связанная с
расширенными возможностями SQL и расширениями процедурными SQL.
Все это наконец охватим и, в принципе, наверное, по большому счету, можно сказать, завершим основной инструментарий
SQL языка для СУБД и, в частности, для СУБД Postgres.
