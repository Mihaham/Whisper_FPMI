Вот, нет, практически буквально, да, я могу, да, но целочку пришлю, там можно даже прям сразу следить,
но начнем мы с такой разминочки. Значит, смотрите, как-то, ну вот, в прошлом году у нас была такая
штука, была такая штука, как метод четырех русских, помните? Вот, как бы главная задача,
которую мы решали, это у нас была задача ЛЦА. Была задача ЛЦА? Ну, естественно, так вот. Ну вот,
значит, мы это попытаемся прообретить, потому что, значит, как это у нас было? Ну, как вы помните,
задача ЛЦА у нас, по идее, там, на практические олимпиадные практики, значит, у нас как решается?
Она решается либо там предподсчет за N log N двоичных подъемов, и после этого вы за логарифом
там, собственно, двоичные подъемы ищете, помните, да? Ну, вы помните, конечно. Вот, либо там за N log N
насчитываете, там, что-то запускайте ДФС, там насчитываете на нем спортстейбл за N log N,
и, соответственно, там после этого за OAT единицы на все запросы отвечаете. Вот. Ну, выяснилось,
что понятно, есть более чемпионский алгоритм, который там за OAT N предподсчет, за OAT единицы,
там Far-Colton-Berger, там и так далее. Вот. Но, значит, к чему у нас N? Вот. Но вот теперь тут возникает
такой вопрос. К сожалению, этот алгоритм двоичные подъема искать не научился. Ну, двоичные подъемы
все-таки не для научиться искать быстрее, потому что их по определению N log N. Ну, вот возникает такая
интересная задачка, которую у нас вот, с которой мы начнем, такая полуразминочная, называется level
ancestor quiz. Вот. Ну, вот, значит, задачка, соответственно, такая. Значит, дано, как всегда,
подвешенное дерево. Будьте здоровы. Абсолютно несбалансированные, если сбалансировать. Да.
Произвольное подвешенное дерево, как всегда, N вершин. Эбребер. Эбр равно N минус один. Вот. И
теперь у вас будет задачка. Значит, в запросе вам дают Q, там, ладно, не Q, вам дают вершину V и
число L. Натурально. Значит, задача будет очень проста. Возьмите вершину V и пойдите на L шагов вверх.
Вот. Вот там жутко интересно, куда мы попадем. Вот вершина. Да. То есть мы хотим, короче говоря,
найти предка вершины V, находящимся от вершины V, на расстоянии ровно L. Ну, или корень, там,
если такой вершины. Ну, или там, минус один, в общем, все что угодно. Это уже деталь. Ну, вот,
давайте смотреть, как мы умеем решать эту задачу. Да. Ну, тут, ну, вот. Ну, да, нам хочется онлайн.
Да, есть, конечно, там, хотя мы дай, что-то мы вот, да. Да, есть, конечно, теоретически там,
вот, алгоритм Торьяна, который использует SNM. Ну, вот, ближе к SNM, я думаю, может быть,
его даже имеет смысл вспомнить. Вот. Но, как бы, если мы хотим это все в онлайне, то у нас есть
алгоритм, который работает, ну, да, то есть использование двоичных подъемов. Вот как бы вы,
кстати, сказали, за какую асимптотику он работает. Ну, вот, ну, можно так сказать. Ну, вот, можно
сказать, что он работает за N log N предподсчета. И после этого на каждый запрос на log N. Ну, в принципе,
да. Ну, имеем в виду, что N log N плюс Q log N по факту, да, потому что амортизация сегодня нам
понадобится. Вот, поэтому, да. Значит, смотрите. Но, естественно, очень хотелось бы это каким-то
образом ускорить. Вот. Как же это сделать? Ну, собственно, непосредственно двоичные подъемы
нам так просто не помогут. То есть нам потребуется делать немножко, ну, вот такую альтернативную,
то есть пару альтернативных концепций. Вот. Да, вот сегодня мы будем говорить про всякие
древесные декомпозиции. Да. Как говорится, да. Если бы я спрашивал, да, какая будет первая выбор,
скорее всего, не угадали. Выбирали бы из двух вариантов. Да. А правильная, а правильная,
бывают третий и четвертый. Так вот, третий. И так. Нет, очень просто сейчас будет. Значит,
смотрите. Longest path decomposition. Лестничная это четвертая. Ну, на самом деле, по-хорошему лестничная
это, конечно, не совсем декомпозиция, но сейчас мы это увидим. Значит, что? Значит, что это такое?
Значит, смотрите. И система очень простая. Мы берем вершину, корень, и находим. Вот. И находим
самый длинный путь в этом дереве. От корня куда-нибудь. Ну, или что-то уже самый-самый
глубокий лист. Ну, на самом деле, да. На самом деле, да. Вот, смотрите. Нет, смотрите. То-то и оно,
что строится-то она будет быстро. Ну, потому что дальше это будет так. Ну, то есть, чтобы завершить
определение декомпозиции, достаточно сказать просто пару слов в духе. Выкинем вот эти вершины,
у нас осталось какие-то вот эти вот подвешенные деревья, в каждом из них запускаемся рекурсивно.
Ну, разбить дерево. Разбить множество вершин на пути. Каким-то способом. Нет,
пока не предъявлено. Нет, смотри. Да, хотелось бы. Заметим следующее. Заметим, что, ну, смотри. На
самом деле, я утверждаю, что это делается очень просто следующим образом. Запустим ДФС и за ОАТ
насчитаем такую, боже, космическую штуку, как размер под дерево каждой вершины. А да, она же
глубина. А, ну и размер посчитаем, глубину посчитаем. Да, оговорился, прошу прощения. Да, значит,
посчитаем, соответственно, глубину. То есть нас интересует. Ну, во-первых, конечно, нам
поможет на самом деле насчитать и глубину самой вершины, просто расстояние до корня. Но нам
действительно не помешало бы найти, на какой глубине, например, находится самый глубокий лист,
а самое главное, откуда он взялся. Вот. Ну, потому что у каждой вершины есть под деревья. Ну,
в каком под деревья находится самый глубокий лист. Нет, вообще нет. Давайте я сейчас. Ну,
давайте так, смотрите. Вот смотрите, если насчитать. Давайте так. Не, а как это тебе поможет? Не,
тебе надо, тут другая задача. Да, во-первых, хотим сразу втырить для всех вершин. Да, то есть,
во-первых, если мы глубины насчитаем, это будет вот так, 4, 5, 6, 7, 8, 9, 10. А вот то, что нам нужно,
это вот в этой вершине будет равно 10. И в этой 10, и в этой 10, а в этой 1, и в этой 1, а в этой 2. Нет,
это глубина ее. То есть, по дереве этой вершины самый глубокий лист имеет глубину 10. Ну, можно и
так, по-моему, суть одна. Вот, 2, 3, 4, 5, 6, 7, тут вот, тут 8. А это абсолютная глубина. Нет,
это абсолютная. Можно относительную, как сказать, это уже все. Вы уже во втором
семестре замена базиса для вас должна быть беспроблемной операцией. Ну вот, значит,
смотрите. Хорошо, если вы такое насчитали, то теперь декомпозиция делается очень просто. То
есть, на самом деле, вы для каждого под дерево делаете такую декомпозицию, то есть, храните
соответствующие пути. А потом, если вы в вершине знаете, что вы тут насчитали, что тут декомпозиция
в этом под дереве, допустим, вот такая. Тут она вот такая, а тут она вот, ну, тут без вариантов,
в общем-то. Нет, ну, это глубина. Ну, это не важно, просто смотрите. Просто это означает
следующее. Вот, допустим. А нам быстро, нам суммарно ж за ОАТ надо, потому что все, что я сейчас
говорю, мы делаем в предподсчете. Можно, ну, там все можно насчитать, это да, безусловно. Смотри,
тут все просто. Значит, когда, когда вот теперь мы видим вершину, у нее в под деревьях, под деревья
уже разбиты на пути. Вот, то есть, я утверждаю, что теперь все, что нам нужно, это опять можно
даже в тупую еще раз перебрать всех детей, выяснить, где у нас эта самая глубокая вершина
находится. И тогда я утверждаю, что вот если она находится вот в этом под деревью, то тогда от этой
вершины до этой самой глубокой вершины, ну или до одной из них, обязательно идет вот этот вот путь
из декомпозиции обязательно. Ну, я вот, смотри, вот, предположим, что вот у нас есть. Жило было под
деревом. То есть, жил будут несколько под деревьях. И мы думаем, где тут самое, в каком из них находится
самая глубокая вершина. Допустим, да, честно пройдемся выясним. Вот, допустим, в этом. Вот
самое глубокое. Тогда я утверждаю, так как мы этот вот под дерево, равно как все остальные, уже декомпозировали
на пути, вот, но не то чтобы мы их возвращаем, но сейчас вы увидите, в каком смысле, то я утверждаю,
что от этой вершины до этой там обязательно есть путь. Ну или до какой-то другой вершины той же
глубины. Ну вот, от корня этого под дерево до вот этой самой глубокой вершины. Ну, самая глубокая
вершина для этого под дерева, она и самая глубокая для этого тоже автоматически. Но тогда идея такая,
тогда я утверждаю, чтобы завершить декомпозицию, вам просто к этому пути нужно по push front вот эту
вершину. Все. Ну да, пусть путь, вот нам, для вас, что будет очень важно, это что путь, это вот должен быть в
явном виде список вершин. Это важно, это вот очень. Вот это очень важно, но соответственно, да,
когда, как делать push front? Ну, вектор мы push front делать за вот единицы не умеем, но у нас есть дек,
да, с оператором квадратной скобки. Ну да, можно reverse, да, да, да, а можно сразу дек,
и не заморачиваться. Но, впрочем, не суть важна. Вот это уже простые детали, то есть это не суть.
То есть чем такая longest pass decomposition при-я-на? Она приятна тем, что вы все это построили за,
вот, что вот этот предпочет он действительно делается за n. Ну, по крайней мере, сама эта
декомпозиция легко строится за n, не правда ли?
А вот у нас в каждой вершине, то есть когда мы хотим перейти в предко, мы уже добавляем путь, когда мы прошли через всех предков.
Через всех потомков. Ну да. Ну да, да, ну естественно, самое главное, понятно, что мы, конечно, не...
Ну, зачем? Нет, зачем? Просто у нас, ну там звучит будет так, у вас есть глобально какой-то вектор векторов,
в который вы будете записывать пути. Вот, ну там, и вы будете там, и для каждой вершины вы пройдены,
вы будете хранить информацию, в каком пути он, в каком из этих векторов он находится и на какой позиции.
Прямо туда. Вот, с одной стороны, ну а ты и в самом векторе, векторе храним эти пути.
Ну, желательно снизу вверх, наверное, максимально удобно будет.
Тогда, значит, смотрите, что вы делаете, значит, что вы теперь делаете.
Значит, rdfs будет устроен очень просто. Если у вас какая-то вершина в подделье одна, то все, что вы делаете,
это тупо создаете новый путь. Ну, в этом векторе векторов вы создаете новый путь из себя любимый.
Да, напоминаю, это декомпозиция, то есть как бы каждая вершина принадлежит какому-то пути, возможно длины 1.
В смысле длины 0. В смысле...
Получается так, что у нас вершина может следовать нескольких путях.
Нет, это декомпозиция. Как бы, да, может быть так, что из вершины тут вот самых глубоких несколько,
но мы выбираем... Да, но ведь в декомпозиции мы же это декомпозировали тут у этого корня один путь.
Поэтому в этот путь просто прибавили вершина, а все остальные пути вот тут уже есть.
Да нет. Нет, почему жонглировать?
Нет, смотрите, нет, у вас был вектор, вы запустились рекурсивно, у вас есть вектор векторов со всеми путями, которые тут нашли.
Да, и вершины все поддерживают. Мы все поддерживаем, мы все...
Вот, поэтому вам как бы остается просто найти теперь куда пушфронтать, в смысле пушбекать.
Вот, собственно, по пушбекали записали, ну и на этом все с вами были.
По крайней мере, на уровне предподсчета.
Вот, значит, чем теперь... Ну вот, ну и заодно, конечно, глубины тоже предподсчитали.
Все это сделали за вот это. Это приятно.
Это все весело и красиво, пока мы не задумались на тему того, а как же искать?
Ответ на интересующий нас запрос, ради чего мы все это вообще делаем.
Ну, во-первых, мегаумную мы уже ввели на самом деле. Мы же для каждой вершины храним, где они находятся.
Ну, скажем так, если очень хочется, можно перенумеровать, конечно, вершины так, чтобы там, скажем, на корневом пути лежали вершины 0, 1, 2, 3 и так далее.
И на каждом пути подотряки.
Нет, а ну это уже у вас сейчас есть, потому что у вас есть тот самый вектор векторов.
То есть вектор векторов, где вот для каждой вершины сказано, где она лежит.
Вот.
Да, у вершины сказано, в каком пути и в каком месте она лежит.
Я бы сказал, что у нас типа вектор векторов, где по первому индексу, ну, где мы по номеру пути, условно, получим, собственно, массив с путем.
Совершенно верно.
А еще у нас для каждой вершины, то есть еще есть два массива, где для каждой вершины сказано, в каком из этих векторов она лежит и на какой позиции.
Поэтому как бы это не проблема.
Поэтому к чему это нас, значит, к чему это нас приводит?
Приводит нас к это следующее. Вот нам пришел запрос ВЛ.
Тогда крайне логично мыслить так.
Так, вот у нас есть вершина В, и она живет на каком-то там пути.
Мы можем даже найти на каком и какая у него длина, и где вершина В на этом пути находится.
Пока вроде логично, да?
Что же мы делаем?
Что же мы делаем?
Ну, тогда проверяем.
Возможно, нам повезет.
И если мы поднимемся на высоту Л, то мы за пределы этого пути не выйдем.
Мы это можем выяснить, так ли это за О от единицы, и если нам повезло, то просто за ту же самую О от единицы и выдать ответ.
Вот.
Но это если нам повезло.
А могло не повезти, как всегда, да?
То есть поймал, что у нас не очень много переходов между путями?
Ну, вот, да.
Опишем технологию, но, в принципе, она уже интуитивна.
То есть мы поднимаемся до корня, там вычитаем из Л то, что надо, проходим все, так сказать, по, как говорится, непутевому ребру.
Нет, ну как его называть?
Такое связующее между путями.
Ну да, хорошо, связующее.
Да, связующее лучше, конечно, да.
Да, это как-то непутевый чую.
Еще она обыдна.
Как бы в Хавилайте, может, оно тяжелым бы было.
А что такое Хавилай?
Ну ладно.
Я так понимаю, сколько мы уже здесь сидели.
Да.
Обсудим.
Обсудим.
Ой, обсудим.
Значит, смотрите.
Теперь, что интересно.
Значит, хорошо, мы дошли до сюда, перешли.
Значит, тут тоже какой-то путь есть.
Но про этот путь можно сказать маленькую приятную вещь.
А хотя бы такой же длинный?
Нет.
Короче, он хотя бы, он больше.
Он строго больше, чем вот этот.
Аж на один.
Да, он строго больше.
Почему?
Потому что, ну, заметим, что у этой вершины действительно есть вершина.
То есть, как минимум, вот на глубине вот этой вот...
То есть, есть вот потомок на расстоянии от нее.
Вот этот вот лист или шоу, это плюс один, правда?
Ну вот он, на лицо.
А это означает, что тогда вот этот путь тоже должен идти куда-то вот на хотя бы такую же или большую глубину.
Вот.
То есть, это означает, что вот длина вот этого пути, каждого следующего пути, строго больше.
Хотя бы на один больше, чем длина предыдущего.
Но тогда, значит, оно вот...
Но тогда отсюда, в принципе, уже, возможно, даже где-то встречавшимся нам образом, я заявляю, что тогда вот ровно...
Если мы в таком виде будем искать ответ на запрос, мы получим корень ассептотику.
Корень из Н.
Ну, это технологии конкретно пошли в ХЛД.
Нет.
Ну, во-первых, ХЛД будет логарифом путей.
Ну, вот такая уже.
А во-вторых, значит, от корень здесь берется...
Ну, давайте кратенько напомним, из какой? Из откуда?
Ну, потому что предположим, что мы тут прогулялись по К путям.
Это К пути не пересекаются.
А сколько в них вершин?
В первом пути хотя бы одна вершина.
Во втором хотя бы две.
В третьем хотя бы три.
И так далее.
Значит, в Ка там хотя бы К.
В совокупности получается тета от К квадрат.
Причем это тета, то есть нечто там...
Ну, К на К плюс один поделить...
В общем, не интересно.
И это не должно превосходить N.
Так что все.
То есть, как всегда.
Да.
Как говорится, корнячка многолика.
Вот она тут, собственно, тоже так это подмигнула.
Так что вот такая вот получилась красота.
То есть, как всегда, чем этот алгоритм лучше?
Тем, что у него припочет.
А ответ за корень.
Ну, корень все-таки...
Корень больше, чем алгоритм.
Ну, конечно.
Ну, просто так не превратится.
Просто так не превратится.
Ладно, есть ли тут какие-то вопросы?
Ну да, пока вроде все просто.
Вот.
И так.
Ладно, декомпозиция номер четыре.
Нет, ну в суд.
Ну хорошо, да.
Вообще, все-таки мы будем торопиться.
Потому что, как я уже сказал, это все в конспекции.
И мои тишники уже законспектировали это.
Понятно, но я решил, что надо это.
Ну да.
Я либо осознаю, либо сижу и умираю.
Так.
Так, ну окей.
Значит, раунд следующий.
Ледер декомпозиции.
Ну потому что просто так, вот действительно, как-то этот корень так не оптимизируешь.
Вот.
Значит, идея
заключается в следующем.
Ну, на самом деле, ледер декомпозицион
ну не очень понятно, оказывается, почему она называется
именно декомпозицион.
Потому что, по-хорошему говоря, это не декомпозицион.
Потому что теперь каждый путь,
каждая вершина может содержаться
в нескольких путях.
Ну мы, конечно, выберем самый главный,
но там, ну вот, условно.
Но она может попадать в разные.
Идея, на самом деле, в следующем.
Значит, идея
в следующем.
Значит, смотрите.
Значит, у нас, допустим, вот у нас есть путь
для мы пять.
Да?
Как это вот хочется назвать даже не ледер декомпозицион,
а дабл декомпозицион.
Дабл декомпозицион.
Не.
Дабл, потому что
мы этот путь удвоим.
Хранить мы будем сейчас.
То есть делаем абсолютно то же самое.
Находим тот же самый, вот это вот самые длинные пути.
Вот все хорошо.
Но каждый путь,
для каждого пути
мы храним не только сам этот путь,
но и идем,
но и его предков
на ту же длину.
О, прикольно.
Такая зеркалочка.
Нет, но это не зеркалочка, это вот подъем.
То есть, типа, у меня есть путь длины L.
Ну ладно, тогда, наверное...
Чего?
Вершина.
Да, тоже на L предков.
На L предков.
На L родителей.
Прямо в тупую ходим и поднимаемся.
L это если на пути L.
Да, вот в лонгеспесе L.
Основная часть, есть вот эти вот пути.
Прямо вот храним.
Ну, заметим, что
к нашему предподсчету, в общем-то,
не сильно много от этого добавится, правда?
И он все еще будет
за O от N.
А как мы будем добавлять
все эти зелененькие?
А в тупую?
Построили вот этот лонгеспас.
Ну, тихо.
Как всегда.
Только почему-то с задней парты.
А, ну вот, да.
Вот.
Ну, просто
логика такая. Вот мы построили
лонгеспес декомпозицион. Вот он, да?
Ну, тогда идея такая.
Давайте теперь прогуляемся по этим путям.
Да, вот эти, да, вот эти
путь мы храним, так как вы тут
пушбекаете, скорее всего вы их еще и так справа
налево храните, да?
Так вот. И тогда теперь просто
для каждого из этих путей вы тут просто
приписываете нужное количество
родителей.
Которые взяли из тупого
ну, нет. Зачем?
В том же самом предподсчете,
скорее всего, вы будете знать
то есть у каждой вершины вы можете
получить ее предка. В смысле, родители
одного.
Но это да, но заранее можно это
предпочитать, особенно потому что
тут еще вопрос, а как вам, собственно, это дерево
задано?
Помните, одно из классических
вариантов задания дерева, это для каждой вершины
пишем родителя. То есть это потом вы уже
отдельно пишете там для вершины там
типа вектор-вектор, который список смежности
там, в смысле список детей, это все уже.
Но это уже все там мелочи.
Это уже такие очевидные ноты.
Это, как говорится, очевидные мелочи
жизни.
Вот так вот.
Ну, вот примерно вот так вот.
Но заметим, что если мы хранили
ОАТН информации,
а стали хранить в два раза больше,
то информацией стала
ОАТН.
То есть, смотрите, я так
напишу.
Я вот тут напишу, тут
будет вот такой более
жирный ОАТН.
Можно еще
даже без ОАТН, а после 2Н.
Не, ну 2Н это не асимптотика.
Асимптотика это Н.
Но он будет более жирный, мы его нарисуем более жирным,
в знак того, что там стала более жирная
константа.
Вот, в два раза более жирная.
Да, я, по-моему, тут даже маханул немножко.
Тут не в два, но ладно.
Вот.
Значит, смотрите, что теперь будет.
Сейчас будет
весело.
Так что теперь давайте
попробуем по
ледер декомпозицион
восстановить путь.
Восстановить ответ.
То есть, теперь логика простая.
Теперь, конечно, подыматься имеет смысл не только по
ледеру, но и, конечно, по ледеру.
Видите, да?
Но
возникает такая интересная
мысль.
Вот.
Значит, теперь тогда возникает такая.
Вот хорошо. Допустим, если повезло,
то есть там теперь уже с большей вероятностью повезет
за ОАТ единицы.
Вот.
Но все еще может
не повезти.
Мы у нас пока все-таки держимся чуть-чуть подальше
вероятностах алгоритмов, как вы помните.
Ну да.
У нас на самом деле был такой
методический спорт, потому что
собственно, называется я и
собственно, Илья Степанов как-то действительно хотят
отнести вероятность алгоритма, в том числе
их иши на третий семестр.
Потому что
чтобы нормально их анализировать, все-таки имеет
смысл, чтобы вы все-таки познакомились с тервером.
Ну вот.
Нет.
Альтернативный вариант это был
помучить вас прямо сейчас,
только при этом тогда пришлось бы этот сервер вводить.
Ну, может быть, в меньшей степени,
но и так далее. Но зачем на это тратить время,
если, собственно, вам это потом все равно
сделают, причем
качественно и фундаментально.
Вот. И поэтому...
Да?
А куда делся Эрлих?
Ну, да.
Ну, да.
Ну, да.
Не, ну да, Эрлих,
это хорошо, да.
Ну, да.
Не, ну как сказать, парень?
Ну, окей, ну ладно, не будем сейчас на это.
Ну, в конце концов, не будет. Ну, значит, в конце концов,
может быть, может быть, тогда вернется Шабанов.
Вот у нас Шабанов читал, вот это, это круто было.
А, новый? Ну, окей.
Ну ладно, это уже детали, все.
Не важно. Так вот. А теперь мы перейдем к следующему.
Значит, смотрите, хорошо, вот мы перешли.
Итак, вот мы...
Хорошо, вот на этом пути
этот путь прошли, Элли еще
не покрылся, и мы переходим
как сказать, к родителю. Да, ну это ребро
не обязательно черное, может оно и синее, кстати.
Тут как повезет.
Эти ребра тоже могут быть синими, например.
Да, теперь я утверждаю, да, что
если теперь вы перешли... В общем, короче, если вы
взяли вот этот путь из ледерди композицион и пошли
к родителю его начало,
то у этого родителя,
пусть, внимание, синий путь,
вот в лонгесте, хотя бы
в два раза больше, чем вот этот.
Да, именно синий.
Именно синий у него, хотя бы
ну, у него, он тут спускается.
Смотрите, почему.
Ну, хотя, ладно, тут проблема,
что он может быть синим, он может пускаться вот так.
На самом деле очевидно.
Вот просто из этой картинки.
Смотрите, какая идея.
Вот здесь было, и было здесь
L-вершин.
А, подождите.
Получается, этот большой путь получили уже
после того, как посчитали все мелкие.
И при этом, то есть этот путь,
он уже содержал тут зеленую часть.
Ну, вот, нет, не совсем.
Нет, вот этот путь L, потом мы поднялись еще
вот тут на L.
Когда мы зеленый добавляли?
Это случилось уже...
Мы же сказали, что начальство писали
L.
Да, мы посчитали L.
Нет, мы посчитали L.
А потом
допихали в конец,
превратив его в ледер, вот эти вот еще
его родителей.
Но это не декомпозиция.
Нет, этот путь не вы...
Нет, нет, нет.
Это синяя часть пока L, все нормально.
Я утверждаю, что через вот
эту уже вершину
может быть синий путь длины хотя бы 2L.
А элементарно?
Потому что глубина его под дерево
в относительных величинах
хотя бы 2L. Почему 2L?
Потому что вот из него можно пойти
в потомка на длину 2L.
Нет, какая коллизия? Да, согласен.
Да, правильно.
Нет, совершенно верно.
Да, вполне может быть так, что
на самом деле вот этот вот мы тут
по зеленому...
Нет, нет, смотри, нет. Почему?
Смотри, у каждой вершины
путь это как минимум
глубина его под дерево, правда?
Ну, глубина, да. Даже плюс один
считая самую вершину. Ну, понятно.
Но утверждение
у этой вершины
есть потомок на глубине
2L. Вот конкретно этой.
Ну, смотри.
Жил был путь длины L.
Жила была вот эта вершина.
Из нее мы тут поднялись
на длину L, плюс-минус 1
по ее
синему пути.
Вот я вот эту беру самую глубокую.
Потом поднялись еще
на L. И пришли вот
в эту вершину. То есть из этой
вершины мы поднялись аж на 2L.
Ну, получается, переходим
в ту, которая у нас уже
зеленый.
В вершину предок крайне
зеленый. Ну, да.
Вот. Ну, нет, у этой...
А, ну, да.
Ну, да.
В начале
у кота синий, то ничего бы не изменилось.
Не, не, не. Но было бы
2L минус 1, как раньше, чтобы в нее тоже
поднимались.
В общем, я понял.
Я понял. Я лучше потом это объясню.
Ну, ладно. Там уже видимо
какой-то локальный формализм.
Это до уточнения слов будет.
Ну, вот. Ну, ладно.
Хорошо. Нет, просто...
Хорошо. У этой вершины
есть глубина 2L.
Через нее будет проходить путь, может
через эту же вершину и через вот эту
часть бывшего зеленого пути.
Но у нее будет синий путь длины хотя бы
2L. То есть при
переходе от синего пути к следующему
синему пути у нас эта длина возрастает
хотя бы в два раза.
И тогда мистическим образом
корень и зен
превращается
превращается
в элегантный
логарифум.
Ну, как элегантный?
Хотя нет. Красивая идея, конечно.
Вот.
Ну, вот. Вот уже красиво.
То есть мы уже...
двоичные подъемы
смажировали.
Вот. То есть мы уже теперь
предпочет за ОАТН, память ОАТН
работает с залога.
Но я их не случайно вспоминаю.
Значит, потому что...
Вот. Потому что...
Вот.
Потому что они нам
все-таки пригодятся.
Значит, смотрите.
А теперь возникает вопрос.
Значит, сейчас мы... сейчас мы
найдем еще... сейчас у нас будет еще один.
Сейчас уже без лишних декомпозиций.
Но сейчас у нас будет
снова появится вариант за N лог N
и от единиц.
Так, вот это вот стирать можно?
Это мы себе уже
вообразили.
Вот.
Вообразили. Да.
Сейчас будет тут...
Но это тоже будет.
Так.
Так.
Эх, сервис. Как это называется?
Вот. Да. Как-то...
Вообще, конечно, вообще радостно, что на самом деле
наконец-то мы на самом деле учимся в том формате,
в котором учились все ваши великие
предшественники до 2019
включительно.
Ну, я вам больше скажу даже
вот алгоритмические предметы и так далее
вообще и на первом, и на втором курсе,
и вообще на многих курсах
преподаются именно здесь.
Нет.
Разница очень простая.
Подавляющее большинство преподавателей являются
действующими разработчиками компании Яндекс,
например, Тамаби и прочих компаний,
из этих мест работы
сюда ездить гораздо ближе,
чем в Долгопробной.
А школьник тут...
У меня все проблемы.
Почему я не понял?
Понятно, что когда я говорю конец синего пяти,
вот этот.
Я думаю, что мы, когда доходим до конца зеленого,
что мы бегаем в тот путь,
который как бы связан
с концом синего.
А, нет, нет, нет. Этот путь синей здесь
закончился.
Ладно.
Ну вот, нет.
Ну вот.
Нет, вот, да, просто преподаватель, да, обычно
он обещает, поэтому как-то на Тиберяйскую ехать
и проще. Ну там, в Сатратно
вообще ехать вообще там, в Сабе вообще
идеально. Ну вот. Ну там Яндекс
чуть дальше, но тоже близко, но, соответственно.
Вот.
Что такое?
Что значит тут работает кто-то из прибытий?
Тут везде
1С висит.
Нет.
Нет. Ну сформулируем так.
Да, в принципе, это, как бы, помимо
вот этого закуточка, где мы тут
находимся, да, это по идее офис компании 1С, да.
Вот.
Ну а как-то это здесь находится учебная зона,
ну здесь, в частности, вот, физтех
собственно проводит свои пары.
Ну и, ну там еще какие-то
дополнительные образования тут проводятся, там, по-моему,
какие-то крышки.
Я вам даже больше скажу, в 2020
вообще конкретно тут был
СЕРС. Прям вот буквально
просто вот в этих местах. То есть, возможно,
на ваших, вот
на этих парках стояли компьютеры и, собственно,
как видите, там активно боролись за право поступить сюда
без экзаменов.
И приезжать сюда уже раз в неделю, да.
Вот.
Так что,
ну вот. Так что, да, вот.
Так что такое многофункционально. Да и вообще у нас периодически
бывает, что у нас еще занятия отменяют, потому что
как-то здесь еще любят проводить финал
открытой Олимпиады, на самом деле.
Ну это одна, это раз одна из площадок, но тем не менее.
Вот. Ну просто обычно
к этой Олимпиаде, там, по крайней мере, организационных
из тех тоже имеет отношение, поэтому.
Вот.
Так вот.
И так, значит, что мы сейчас хотим?
Давайте вернемся к делу.
Нет, пока
никаких новых декомпозиций не будет.
Но мы, ну вот, мы попробуем
насчитать вот такие вот декомпозиции.
И двоичные подъемы.
Да. Тогда это, конечно,
то есть давайте так
напишу. То есть допустим так
LD, вот, не
путать HLD. Вот.
Плюс. Так.
Как у нас двоичные подъемы?
LD это ледер. BL.
А где, где здесь? Да, LD это ледер, да.
Где нам ледер, если...
А, потому что ледер включает в себя логист пас так удобно.
А где авторы
здесь увидели лестники?
Типа, поднялся еще вверх.
Круто. Ну где-то
увидели, я не знаю.
Вот, вот дерево.
Ну я не знаю.
Они думали, думали,
как назвать, то уже назвали
логиспас. Ну у них
вазик такая ассоциация. Потому что, знаете, тогда
это вообще есть глобальный вопрос первого семестра.
Почему красно-черное дерево не, там, я не знаю,
не жовто-блокритное, например, я не знаю.
Ну, ладно.
Когда его придумали,
да, ладно.
Да, ладно.
Да, у них, да, у них
под рукой были только красные-черные.
Эх.
Так вот.
Ну да, мало ли.
Как там, да, мои, да, мои родители,
да, мои родители химики, грустно рассказывает
Торин Иванович Корочев.
Ну, нет, ну. Нет, ну просто
больше не понял.
Нет, ну там, чьи-то чеки, это Торин Иванович
Корочев. А почему вы Торин? Ну, у меня родители химики
по таблице Менделеева выбирали.
А, то есть вы могли стать азотом или алюминием, да?
Ну вот, мужик грустно вздохнул.
Вот. Ну, не важно.
Так, так вот.
Значит, что, если мы насчитаем
и ледер декомпозицион, вот.
А, даже для понятности, я ее даже
ледер декомпозицион.
Байнери лифтс.
Байнери лифтс.
Байнери лифтс.
Да.
Ты уверен, что ты готов?
Ты хоть на русском поедешь?
Да, да.
Have you prepared for my English?
My perfect Russian English.
English.
Да. Ой.
Так вот.
Значит,
ну вот. Ну, тут предпочет пока будет
за НЛОГН, да?
Ну,
ну, значит, зато
я утверждаю, что прямо сейчас
на ваших глазах,
значит,
прямо сейчас на ваших глазах
я научусь искать, значит,
подыматься за от единиц.
Пока вы на земле стоите,
а не взлетели.
Ну, я взлетать не собирался.
Значит, смотрите.
Значит, смотрите.
Значит, смотрите.
Значит, смотрите.
Ну, идея очень простая.
Оно у нас даже где-то
фигурировало.
Мало кто знает,
вот, что если у нас есть
мистическое число L,
то существует
такая степень двойки,
которая не
превосходит L.
И при этом она такая
последняя.
А еще
ее можно для каждого L
от одного Dn предподсчитать.
Ладно, еще более интересный факт, который
скорее всего мы тоже столкнемся на будущих занятиях.
На самом деле
подобную штуку можно насчитывать за от единицы
собственно не только от одного Dn,
а для всех бинарных чисел, которые
у нас вообще влезают в нашу память.
Вот.
Ну, логариф
вот там
это не совсем, но это логариф
укругленный вниз, но...
Чего?
Каким образом?
Да.
А нужно насчитать самый старший
единичный бит числа.
Но там
просто проблема будет в том, что
быстро его насчитывать хорошо, но просто
только помните, от 32 в данном случае
это не от единицы.
То есть это будет
насчитываться там за O от W, где W
это вот с
какими битными числами мы работаем.
Но вот утверждается, что можно сделать это
за O от единицы, не завися от W.
Вот
утверждается, что
некоторые современные процессы делают, кстати.
Вот, интересно.
Да, то про это умеют.
Ну, потому что, да, там есть просто статья
на тему того, как построить, там,
произвали не на уровне, там, каких-то этих, там,
каких-то схем просто построить, это тот самый
старший бит, да.
Значит, смотрите.
Ну, короче говоря, в общем, так или иначе,
в нашем случае это вообще не проблема.
Вот мы, соответственно, максимальную степень,
такой два степеника можем дойти. Так вот.
Идея такая.
И так вот нам из вершины
нужно подняться,
из вершины W нужно подняться на высоту L.
Так вот, предлагается сделать
следующий. Давайте вот на эту степень двойки
поднимемся. Мы это можем сделать
за один двоичный подъем.
Логично, да?
А второй подъем мы сделаем
из ледер декомпозициона.
А можно даже и логи
с паса, в общем-то.
Хотя нет, именно из ледера, конечно.
Потому что идея такая.
Зачем нам это вообще делать?
Чтобы за вот единицы было.
Я утверждаю, что у нас тут, если мы пойдем
из этой вершины по ледер декомпозициону,
мы сделаем один шаг.
А, мы же можем, нам же не нужно
бегать по путям, когда мы
делаем вот этот подъемчик, да?
То есть теперь из этой вершины надо подняться
на вот нечто меньшее, чем
два степеника.
Меньше. Да, строго меньше.
Окей, запрос есть.
Согласен. Строго меньше.
Но заметим, что у этой вершины
глубина под дерево хотя бы два степеника.
Вот. Так что получается,
то есть вывод, то есть в соответствующем
пути, значит, подняться
по самому пути хотя бы на
два степеника вы сможете. А значит
вы просто за вот единицы поднимаетесь не на два
степеника, а на столько вам надо.
Ну, смотрите.
В логе спест декомпозицион
у этой вершины
путь идет вниз хотя бы на два
степеника.
Да.
Да, но тогда, если мы рассмотрим
в ледер декомпозицион этот путь,
тогда у нас есть путь длины хотя бы два
степеника, и там у него сверху
приписано тоже хотя бы два степеника, правда?
То есть это значит, что на ледер декомпозиционе
по ее пути в ледере
можно подняться аж на два степеника.
А то и будет. Все достаточно. Да, а нам надо
на меньше.
Так что вот таким вот не очень
хитрым образом.
Вот.
Ну, точнее так, немножко накрученым образом.
Да, но мы научились подниматься
наконец впервые в истории за вот единицы.
Да. Нет, реально.
Вот именно подниматься вот мы за вот единицы.
Да, научились. Ура.
Но вот теперь
давайте думать. Остается теперь вот
маленький нот. Остается теперь
вопрос. Как n лог n теперь
превратить в от.
Значит, что можно
тут делать?
Да, это вот первая
идея. Во-первых, я
утверждаю, что можно
искать бинподъемы
не для
всех вершин.
Значит,
я утверждаю,
что нам...
В онлайн?
В онлайн.
В онлайн, да.
Что такое онлайн решение?
Значит, на запросы мы должны отмечать онлайн.
Все построить мы можем сразу.
Я понимаю.
Ну да, в оффлай да, в оффлай да.
В всякий случай ответим, что в оффлайне мы могли бы запустить
DFS, хранить вот путь до каждой вершины
просто в стеке, и когда мы приходим в вершину,
тогда просто на все ее запросы успешно
отвечать.
То есть там...
Чтобы получить новый запрос, тебе надо
отбить на старый, нет?
Нет, это называется онлайн.
То есть это онлайн? Да. То есть как бы вам дали
запрос, вы должны на него прямо сейчас ответить,
следующий не дам. То есть как бы
ждать, пока полная маршрутка не наберется,
значит, мы не можем.
Мы можем читать бинподъемы длиной больше, чем
на наибольший путь вниз?
Нет, ну нет.
Да, нет.
Мы сделаем...
Смотрите, нет, ребят,
тут еще круче.
Мы сделаем такую неожиданную оптимизацию.
Мы будем считать
бинподъемы только
для листов.
Да, вот тут мощность начинается.
Да.
Ну что ты, господи, я уже...
Уверен?
По первым комментариям выскакал
в тень кофе, не рассказывай.
А, какая-то девочка
на всеросе?
Какая-то длинная цепочка, да.
Ну окей, ну смотри, да.
А тогда... Нет, просто да, это
вроде в программу... Ну хотя нет,
на самом деле, не совсем.
На самом деле, насколько я понял,
я тут как раз пообщался с преподавателем,
который там подобные вещи рассказывает,
ну просто приятно с теской пообщаться, правда.
Ну вот, насколько я понял, там у него,
по-моему, алгоритм в этом месте
и заканчивается.
В принципе, для олимпиадных
целей дальнейший упихон уже не нужен.
Ну вот.
Ну я не знаю там...
Ну я не знаю, просто там, по-моему,
можно ли действительно там создать задачу, в которой
вот действительно N log N заходить не будет,
а O от N будет.
Сейчас вы увидите,
почему. Ну вот, действительно.
Но на самом деле, ладно, Тихон, в принципе, правильно
сказал, что на самом деле, заметим, что
для каждой...
Ну, во-первых, что для каждой вершины
можно сохранить какой-нибудь
лист из ее поддерева.
Вот просто первой попавшейся какой-нибудь.
Тупо рандомный.
Ну, можно даже не рандомный,
мы и так в принципе там
самый глубокий лист уже даже находили,
поэтому там даже это не сильно страшно.
Мы все еще насчитываем LD.
LD мы не трогаем, но LD у нас
из олинию насчитывается.
А бинподъемы мы будем насчитывать
только... То есть, например, для каждой вершины
мы храним лист
из ее поддерева, да?
Да, какой-то. И храним
и бинподъемы храним только из него.
Из него храним все бинподъемы.
Из него это из кого? Из этого листа.
Из листа, хорошо. То есть, это
нам даст... То есть, это
все еще сохранит нам
от единицы.
Стоп, секунду, почему...
Мы же для всех листов насчитываем
бинподъемы или нет? Для всех.
А почему тогда это будет лошадь?
Ответ. А не почему.
Все в порядке.
Не пугайтесь, пожалуйста.
Значит, все... Нет, просто это
чуть-чуть оптимизирует константу.
Потому что вы бинподъемы теперь
и для всех вершин будете искать, а только для листов.
Правда, скорее всего, листов
может быть тоже ОАТН.
Я вам... А, ну я...
Ну вот, может быть, ОАТН.
Более того, там чаще всего
их хотя бы Н пополам-то, наверное, добует.
Ну, например, если у вас
в каждой вершине обязательно либо лист,
либо развилка, то тогда листов хотя бы
Н пополам. Ну и там вот
вот, ладно, всякие эти уже мелочи.
Ну да, если бинарные,
ну не важно.
Пока Н лог Н. Хотя, но пока
интерес в следующем.
Потому что на самом деле
возникает еще вопрос,
а как мы насчитаем двоичные подъемы?
Нет. Нет, отвечать...
Нет, отвечать... Смотрите,
эта идея очень простая.
Вы хотим подняться из вершины В
на высоту L.
Я знаю, мы знаем,
что у вершины В
есть лист В штрих.
Лист, да, который
находящийся... Ну вот.
Тогда идея такая... Да, любой.
Первый попал. Но мы его сохранили уже, да?
Поэтому мы на него...
Поэтому идея такая, вместо того, чтобы подниматься на высоту L
из вершины В, мы должны подняться
из этого листа на высоту
L плюс, ну там, какое расстояние
между ними.
То есть, по сути, это называется,
мы немножко тут это, вылили воду из чайника
и свели задачу к подъему из листов.
Ну да, мы буквально, буквально, да.
Так оригинальный анекдот же
о том же самом, разве нет?
Ну вот.
Ну, то есть, как бы, да, Федя, да,
типа зада... Ну, там же оригинальный анекдот,
как бы звучал. То есть,
задача. У вас есть в кухне
вода, газ и чайник. Задача
вскипятить чайник. Значит, решение
и задача у физика и математика одинаковые.
Берем чайник, ну вот,
собственно, наливаем воду, включаем газ,
ставим. Ну вот, все нормально.
Теперь, задача номер два.
Значит, чайник наполнен, газ
зажжен, вскипятить воду.
Да? Решение физика.
Ставим чайник на газ и, в общем-то, все.
Решение математикам.
Гасим газ, выливаем воду из чайника,
задача свидетакт предыдущий.
Ну вот.
Да, то есть, вот классический
анекдот так звучит.
Вот. Соответственно.
Ну, то есть, да, видимо,
это, возможно, тот самый математик,
который, если у вас в коридоре
пожар, вы выскакиваете, видите огнетушитель,
понимаете, что решение существует и идете спать дальше.
Да, те
же самые математики.
Ну, нет, не путайте
в пожарную сигнализацию. Там ситуация, когда вы реально
понимаете, что пожар.
Ну, там каре воняет, там огонь в окне.
Да, вы видите.
Нет, ну да.
Главное, там огнетушитель висит.
Хотя нет, хотя нет.
Если там до него пути нет, тогда вы начинаете думать
и, возможно, спасетесь.
Ну да, хорошо.
Так вот.
Ладно, идем дальше.
Так что подымаемся только из листа.
Все хорошо.
Подымаемся только из листов.
Правда, возникает маленький вопрос.
Как насчитать двоичные подъемы из листов?
Ну да,
то есть на самом деле,
то есть,
да, то есть заметим, что раньше мы двоичные подъемы
насчитывали,
используя двоичные подъемы для предков.
Но сейчас в этом нет необходимости.
Потому что мы сначала мы поднимаемся
и берем лист, поднимаемся на высоту 1.
Это мы за вот единицы сделали.
Теперь, как подняться
на высоту 2?
Ну ладно, то есть еще на 1.
Теперь, как отсюда подняться, еще вот скатнуть на 2 вперед?
По ледер декомпозициону.
Потому что в ледер декомпозиционе мы можем подняться на 2,
потому что глубина его под дерево хотя бы 2.
Ну вот.
То есть тот же самый ледер декомпозицион.
Очень удобно.
Вот.
То есть поэтому вот ледер декомпозицион дает такую возможность.
Вот.
Но теперь возникает вопрос. К сожалению,
листов у нас...
Ну с одной стороны да, но с другой стороны тут проблема в том,
что скорее всего нам понадобится каждый лист.
Ну там достаточно
легко придумать.
Потому что, смотрите, если у вас там дерево будет
выглядеть как-то вот так,
то как бы это все равно не поможет.
Вот.
Но теперь возникает такая идея.
Значит...
В таком дереве листов мало.
Но это пополам.
Вот в таком.
Ну это если оно тут двоичное,
потому что если оно там будет...
Потому что понятно, что есть какой-нибудь классический пример в духе там...
А тогда там не нужен каждый лист.
Не совсем.
Не нужен. То-то оно что нужно.
Смотрите. Для каждой вершины
вот этой.
Да. То есть там понятно дальше.
То есть конкретные случаи
там могут как-то подгоняться.
Как это?
Свидетели, да.
Свидетели секты фингер 3 даже этим
начинают там это изобретать свои деревья.
Ну да.
Ну и помните, я вам зачитывал тогда, когда вы сплей дерева
обсуждали. То есть зачем оно было надо.
То есть там просто что было куча деревьев
под конкретные случаи. И вот тут
сплей дерево на самом деле одним махом покрыло всех.
То есть главное только это
стать свидетелем это...
Да.
Свидетелем амультизации.
Вот. И главное стать
и в общем-то нас устроить. Так вот.
Любой запрос за сплей.
Ну да.
Ну а что? Удобно.
Так. Нет. Ну душу не надо.
Зачем?
Как это называется? Зачем душа, когда
и спл...
Так вот.
Так вот.
Значит как делать n log n?
Очень просто. В чем
заключается метод четырех русских?
Нет.
Сейчас мы не будем...
Да, раньше мы отвечали на этот запрос в духе
зафиксируем k, который выберем
позже.
Сейчас мы пойдем с другой стороны.
Мы думаем, так вот
нам надо n log n сократить
за уатн. Как это сделать?
Очень просто. Откуда у нас n
сократится?
Количество листов.
А давайте сделаем так,
чтобы количество листов было
n поделить на log n.
Вот все очень просто.
Вот заметим, что если в дереве у вас
уже там количество листов не происходит
n поделить на log n, вот вам повезло
как-то, да, то в принципе вы уже
победили.
То есть на самом деле, вот да, тут на самом деле
правильно написать не n log n,
а
l sts.
Чего?
Что за...
Ладно, да, это неправильно. Это не тот лист, да.
У меня вообще более выдуманная идея,
потому что давайте листы какие-нибудь
превратим в 1,
слиним, на комтеромик, посмотри.
Нет, все еще круче.
Нет, значится... Смотрите,
что будет.
Значит, я...
Давайте я вот для понятности...
Значит, веду такое. Значит, пусть у меня
будет констант c,
которая будет
log 2 n.
Ну, допустим, да.
Ну, да, она же...
А, boobin, точно вспомнил.
Давайте boobin.
Выгните boobin.
Вот он.
Значит,
значит, смотрите тут,
какая ситуация будет.
Ну, тут мы сразу
спалили, к чему нам нужен boobin.
Ну, в случае чего, как бы там...
Если бы тем же методом искали, делали это rmq,
то у нас кончилось бы тем, что в конце у нас boobin,
мы бы этот boobin пополам поделили.
Ну, скажем так,
а давайте это...
Не будем угадывать концовку, а просто посмотрим
спокойный фильм.
Потому что
да, мы имеем в виду, что мы можем его умножить
на два, поделить на два, там поделить
на 57, пожалуйста.
Но, значит, смотрите,
boobin. Значит, что
мы с этим boobin будем делать?
Вот, значит, смотрите,
идея будет следующая.
Идея будет такая.
А давайте попробуем.
Ну, основная идея будет такая.
Давайте возьмем наше дерево.
Вот.
Значит, у нас есть
вот какое-то дерево.
Значит, сейчас я скажу вот такую приблизительную
идею. Это как бы не формальная идея,
а в какую сторону думать.
А думать в следующую. Мы
понаходим тут всякие вершины,
у которых
размер под дерево
будет приблизительно c.
Размер?
Да, размер под дерево. Вот, смотрите, вот допустим,
мы тут...
Ну да, вот будем...
Ну, пример, да.
Ну, там что-то типа там
более формально от boobin поделить
на два, да, там, скажем,
двух booblof, например.
Но тем не менее,
я сейчас говорю идею, а потом мы сейчас будем думать,
как ее допиливать.
Сейчас будем придумывать, смотрите.
Вот допустим, мы нашли
то есть, нашли вот действительно
такие деревья.
Вот. То есть,
вот по, допустим, находили
такие вот деревья.
Вот. То есть, допустим,
вот примерно boobin. Вот.
Ну да, вот здесь нам не очень повезло,
но если мы вот... То есть, если нам
удастся сделать так,
что у нас как бы получается
любой путь из корня
будет упираться в какой-то вот такой,
так сказать, металлист размера boobin,
вот.
Металлист,
металлист размера boobin.
Можно
под деревья собираем? То есть,
просто откуда-то от листов собираемся? Да.
Но пока не понятно, но смотрите.
Я хочу понять, пока что
не сказали. Значит, пока я не сказал,
мечта, значит, еще раз.
Мечта, значит, я хочу,
чтобы у меня
модифицировать немножко дерева,
так, чтобы у меня
дерева, то есть, как бы просто
вот,
то есть, на дереве появились вот такие метавершины,
то есть, как бы,
но да, то есть, на самом деле, то есть, я хочу, чтобы у меня
вот было дерево, а я бы хотел, чтобы оно вот было
как бы дерево, дерево, дерево, все хорошо, хорошо,
только везде теперь
только все
листы это вот такие типа жирные,
типа жирные
и мы имеем ввиду что на самом деле
в них есть поддерево, причем не просто
поддерево, а
высотой не будет нет хуже размера да размера не более бубен ну да да но да нет нам нет нам
важен сейчас размер вот вот сейчас вот размер это принципиально
да примерно будем ну в идеале это вот допустим в идеале допустим вот там скажем от бубен
пополам до там допустим два бубен вот вот от бубен пополам до двух бубнов тогда смотрите
какая какая у нас идея тогда возникает тогда у нас все но вот тогда у нас как как и часто
бывает методик четырех русских запроса разделятся на две нот на два типа на собственно на большие
запросы и маленькие в нашем случае это будет что вот у нас есть вот тут в какой-нибудь вершине вот
допустим тут есть какое-то под дерево да и мы можем сказать ведь смотрите ведь для каждой из
этих вершин мы можем предпочитать кто корень ее мета вершины правда с одной стороны но тогда
получается если мы точно будем знать что наш этот значит наш этот предок он будет точно он или
выше то тогда понятно что мы просто там вычитаем соответствующую там расстояние и тогда сводим
задачу к тому чтобы вот просто из мета вершины подняться вот в этом дереве зачем мы это сделали
а сделали мы это затем что заметим что количество листов таком дереве стало менее но стало меньше
в бубен раз правда но потому что каждому мета вершине соответствует хотя бы бубен листов значит
листов не более чем это бубен то есть он поделить налога поэтому на конкретно этом дереве вот
сажатыми вот этими вершинами все работает за отто то есть помните идея была та же то есть
фар холтон бендере мы делали то же самое да то есть помните мы там разделили разделили массив
на отрезки длины по логарифму ну ладно логарифму пополам хорошо вот значит на каждом из них
посчитали минимум и на этих минимумах посчитали спар стейбл за н логен вот только там логен
превратился в n поделить налоген умножить налоген поэтому собственно получилось вот маленькая
закавыка которая у нас тогда оставалось это то что запрос может оказаться внутри вот этой вот
сжатой мелочи да маленькая но не вот единица то есть мы конечно то есть нет принципе смотрите
мы можем уже прямо сейчас спрогрессировать мы можем как бы сказать что давайте внутри этого
дерева будем решать задачу с уже имеющий имевшийся ранее у нас технологии нет почему нет но такие
будет но у нас два варианта вот если мы выберем да вот эту технологию там предподсчет за n и
подсчет за логен вот это ледер декомпозицион туда у нас конечно тогда получится предподсчет за
n и значит на запрос мы будем отвечать да за лог лог а элементарь элементарно смотри каждый
каждый лист но у нас у нас любой лист лежит в металлисте но сначала да да нет вопрос как бы
первое что можем сделать это понять что как бы вот если мы поднимемся до корня мета вершины это
больше чем нам надо или меньше чем нам надо это мы можем заранее предпочитать у каждой вершины
корень ее мета вершины и после за вот единицы понять нет в чем вот но если у нас уж если у нас
корни мета вершины зафиксированы дамы еще пока вообще не сказали как это делать ну где-то да так
что где-то да то есть если у нас это уже есть это ближний дфс сработает хотя скорее всего ну мы
пока не знаем как там вот надо думать так что аккуратненько аккуратненько значит поехали
ну вот значит думаем соответственно дальше смотрите какая теперь ситуация возникает хорошо
но теперь вот это вопрос хорошо предположим что мы выяснили что у нас нам надо подниматься из
листа и мы знаем что надо подниматься не до этого корня куда-то ниже ступой вариант это там я не
знаю но то есть тупой вариант это вот воспользоваться ледер декомпозицион и так как у нас
размер тут по дерево видите он не только он в районе бубна то есть на это не превосходит
бубна до на константу то тогда там получится но то получается лог лога вот уже неплохо но
да теперь вспоминаем что у нас говорил в этом месте метод четырех русских да то есть он говорил
так смотрите раз у нас тут есть они деревья настолько маленькие что их в принципе мало то
скорее всего на самом деле среди этих деревьев будут будет встречаться куча одинаковых
поэтому идея такая а давайте переберем все деревья вот вообще все деревья высоты не более
чем логарифа чего колея все вершины количество да размера да переберем все деревья размера не
более чем логарифом и ура а вот давайте посчитать вот давай вот для этого нет смотрите нет не
совсем тут какая ситуация произвольная значит да есть формула к или там n в степени минус 2 но
это но это типа данные н вершин построить и на них различные деревья чем деревья будем считать
различными если там тупо разные наборы и нам плевать на изоморфизм но вот мы пока этого не
знаем да пока да то есть на самом деле да действительно по моему чем насколько чем меня
в конспекте этот момент как-то немножко до права лучше но на солнышке ну так если вам сейчас
интересно подумать на эту тему на солнышке будет так то есть у нас будет так что там то есть вот
это то есть нас будет интересовать что листы могут быть маленькие но самое главное о чем нам
надо думать это то чтобы их родитель чтобы у родителя у каждого у каждого родителя вот подобные
вершины было там достаточно большое число векшин в подделье вот что нас будет интересовать вот так
что такая идея вот значит значится значится значится нет вот именно сейчас мы переходим
к этому для этого нам надо было посчитать а сколько у нас деревьев ну и хотя бы как-то
адекватно оценить сколько у нас деревьев если нам в некотором смысле там если на изоморфные
деревья мы хотим считать одинаковыми значит смотрите значит я предлагаю начать предлагайте
сделать следующее и вот опять мы воспользуемся идеи которые мы уже использовали собственно когда
сводили л цакоромку то есть помните как мы то есть замену помните что мы там делали мы запускаем
и запи и каждую вершину каждый раз когда мы видим вершину мы записываем ее глубину в чем видим
в чем когда просто как видим так и записываем неважно мы пришли в нее сверху или снизу помните
да а вот а нет у нас был такой вот давайте я напомню вот смотрите вот я вот в данном случае он
будет такой значит вот мы идем до фесом и пишем глубины которые мы видим и получается 0 идем
сюда 1 идем сюда 2 возвращаемся сюда 1 идем сюда 2 возвращаемся до 1 возвращаемся сюда 2 3 2 3 2 1 0 1 2 3 2 1 0 вот
но в данном случае его просто привести вот ну и можно там и для каждой вершины в принципе и
можно даже еще и для каждой вершины сохранить а где мы в ней были вообще ну можно можно одно
вхождение даже сделать неважно важно другое значит размер этого веселого массива 2 и минус 1
если точнее но вот но судя симпатически суть 1 да потому что 1 1 вот это в том дальше каждый
раз проходимся по ребру записываем вершину реберен минус 1 да но это мелочь значит понятно
что до размера размер отн значит там тетатен даже и что теперь давайте смотреть что нам это дает дает
нам это следующее ну а первых заметим что этот конкретно то есть помните то есть на самом деле
помним мы сильно пользовались тем что каждое следующее число отличается от предыдущего на
1 или минус 1 то есть его можно так и написать то есть 1 1 минус 1 там 1 минус 1 1 1 минус 1 1
минус 1 минус 1 минус 1 1 1 1 1 минус 1 минус 1 минус 1 но я боюсь это не цшка а зачем нам
глубина нам нам так вот в этом месте выясняется что мы можем даже так не заморачиваться потому
что нас уже устроит то что если нас интересует сколько у нас существует деревьев деревьев размера
сз то я отражаю что если у нас размер сз то количество деревьев внимание не превосходит
ну получается 2 в степени 2 сз
но вот да именно да да нет так-то такой я такую фигу в кармане я естественно в виду имел вот
я нет это бубнение не от слова будем вот значит то есть получить вот это вот
ну как он сказать нет если каждый ребро заменить на вот такие вот ребра да вот вот такие вот да
то это получится в этом графе элеров обход в принципе но по большому еще так весьма да это
весьма забавно и так даже элеров цикл ну так вот получается деревьев не сильно много но
правда желательно чтобы размер был видимо не логариф но у нас тут всегда это не проблема то
есть как бы то есть бубен всегда можно поделить там я не знаю на 4 но мы уже помнили о том что
на 4 поделить да вот да но просто идея будет такая но если привод таком бубне да даже я бы сказал
и а вот при таком бубне их даже корень из они обсказал их корень из он что позволяет нам для
как просто значит мы перебираем все возможные коды и для каждого из них ну во-первых проверяем
валидный валидный леон а для валидного ну мы там аккуратненько как-нибудь предпред подсчитываем
ответы для всех вершин прям вот да и их мало поэтому давайте для каждого из них ну просто
как мы это будем делать значит получается значит это не более значит мы это будем
делать 2 в степени 2 на сз и умножить это на ну скажем так смотрите да но дерево размера
сз мы хотим для каждого из них и каждого для каждой вершины в нем и каждого л ну там
неповысходящего естественно сз пред подсчитать соответствующий подъем как это можно сделать ну
да например за квадрат получается там сз в квадрате но симпатически ничего не поменяет да да вот это
вот но это уже такие мелкие детали значит основная суть какая то есть как это всегда если у нас там
2 на сз будет не превосходить там логен пополам то вот эта штука это вот мы уже с этим сталкивались и
мы радуемся вот но тогда получается как-то будет работать то есть все что нам останется это значит
пред подсчитать во первых для каждого кода пред подсчитать ответы а во вторых для каждой мета
вершины заранее пред подсчитать ее код ну и как-то сопоставить вершины в этом под деревья там
соответственно тому чему они там соответствует в коду вот то есть ну то есть после этого тогда
останется собственно за от единицы то есть за от единицы внутри каждого поддерева ответ хранить
значит первое при еще при пред подсчете мы в каждом из этих под деревьев запускаем
вычисляем его код вот этот вот ну в общем-то это практически все что мы делаем ну вот этот
код вычисляем не под код а код код его вот этого dfs обхода поэтому потому что в будущем это
позволит нам если нам выяснить что в этом под деревья надо из этой вершины подняться там на
высоту вот в общем не досюда то вы от поговорите так это вершина имеет вот такой код и мы ну вот
поэтому мы отправимся в дерево с таким кодом для которым у нас уже все пред подсчитано но все
что вам останется это только для каждой вершины конкретно этого поддерева посчитать что вот там
скажем там какой-то общей нумерации какая-то какой оно там номер имеет вот то есть это такая то
да то есть это будет почему за где за логарифом в боре
нет тут ну да нет тут еще будет подозреваться да что как бы какая это как бы вот это эту штуку
мы храним как маску поэтому храним за вот где поэтому мы обращаемся в таблицу за вот единиц
но на самом деле нет тоже как всегда до размер маски у нас логан поделить так четыре поэтому
все нормально но мы как всегда живем в классической модели в которой скорее всего логан то есть скорее
всего там n все-таки меньше либо равно два в степени w то есть да был и все-таки хотя бы логан
поэтому я имею в виду другой я имею в виду что у нас n достаточно маленькая для того чтобы
само число n могло храниться как и битвы и число да напоминаю помните в каком мире мы вообще живем
да то есть нет это как бы это да это не ответ математик вот это успел это ответ там
есть за уставшего от жизни человек вот ой о господи тихон работает пятеречке господи это
совмещается с фистехом как это ну да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да
ну да есть что да и да по trashless такое мы скорее скорее скорее всего это называется тоже
алгоритм и дальше какие-то фамилии 8 люди сейчас не скажу какие вот нет ну понятно есть авторы там
понятно что там какой-то какой-нибудь там вредный френдан тут где-то явно spring хотя а может и не
не знаю кто как чего начитать значит но вот и так значит получается если мы
поверили что мы нашли вот эти как вот правильно сказали микро деревья вот
откуда-то вот поверили
да но при чем-то вообще всех вообще всех
нет сэзэ это не логарифа квадрат сэзэ это логариф даже так ну сайз
а ну хорошо хорошо ну хорошо давайте на 8 поделим если уж так хочется нет
то смотрите ладно сэзэ значит давайте так сэзэ это в худшем случае два бубна то
есть логан на 4 здесь надо вызвать еще на два то есть получается логан пополам
корень добили
да да но корень и зен умножить на чего ну там примерно там два
да нет утверждения да мистическое утверждение корень из-за на логарифом
там в абсолютно любой там степени это вот ну вот так что соответственно но это
вот мистический факт который вы можете доказать там с позициону например правила
вот фамилия такая ну вот нет ну смысле отчего нет вот так нет вам нужно
конечно там будет это бесконечность бесконечность производные вот это вот да
вот давай на маленькие запросы ну смотрите в предподсчете мы для каждого для каждого
для всех возможных микро диреми в котором мы перебираем кодами предпочитали все возможные
ответ под чип предпочитали и сохранили мы даже добились того что это сделано за вот
вот та переча что мы еще сделали за вот для каждого микро
дерево которое тут у нас реально в дереве встретилась вот есть вот микро деревья
вот этого типа да когда просто все возможные да но каждый из этих микро деревьев оно имеет
какой-то конкретный тип и тогда и диетара для каждого из них мы тоже запускаем dfs сохраняем
во первых его код ну и но и но и там сохраняем еще но вот но и сохраняем что там скажем допустим
если мы вот конкретно по коду мы можем восстановить как бы просто как общую
структуру дерева да но как бы какие номера эти вершины имели в каких-то там других деревьях
мы не можем но это не важно потому что мы как бы понятно по каждому коду мы можем вести
какой-то каноническую нумерацию вершин типа вот идем в процессе dfs и при а что это вершина
а это вершина, b это вершина, c это вершина, d это вершина, e там в общем вот в таком фаре, в порядке входа, да, вот, и поэтому тогда вы можете заранее за отn для каждого дерева, то есть предпочитать,
во-первых, найти его код, а во-вторых, установить соответствие между конкретными этими вершинами и собственно вот этими вершинами.
Что это вам позволит сделать? Тогда, когда вы, если выяснится, что у вас есть запрос, который не выходит за пределы какого-то вот этого микро дерева, то тогда получается вы просто, у вас уже есть его код,
вы его за вот единицу просто достаете, для соответствующей вершины вы уже, вы тоже из таблички достаете кто она собственно в канонической номерации,
и потом уже из третьей таблички, собственно из этой вершины заданного вам l, достаете ответ.
Ну то есть по сути вот обращение к трем табличкам, да за подробительным, но трем, за вот единицу, вот и вся технология, вот такой вот, вот такой вот маленький красивый технология.
Нет, мы разбираемся со всем остальным, да, ну да, ну значит вот так, ну вот, так, а вот теперь, на самом деле, да, я тут даже, даже, потому что на самом деле, да, не так, да, не так, на самом деле, это просто уже очень хочется сказать,
что основная еще проблема заключается в том, что на самом деле такие вот прямо в таком виде, как я нарисовал, на самом деле эти штуки не всегда и существуют.
Ну вот, потому что утверждает, что нельзя выделить вот такие вот метавершины так, чтобы вот все там действительно какие-то вот листовые поддеревья действительно сжимались вот именно так.
Потому что есть действительно такой классический пример, именуемый среди мирного населения ежик.
Вот он, он же солнышко там, он же звездочка там.
Что?
Нет, кактус это вообще не дерево.
Да, как это?
Нет, это хорошо, кактус это не дерево.
Точнее так, дерево это кактус, любое дерево это кактус, ну и любой кактус это дерево.
Да, поразительно.
Как это называется, да, если вам человек что-то сказал, либо он сошел с ума, либо он програнист.
Да, эти множества иногда пересекаются, конечно.
Так вот, в чем тут проблема?
Проблема тут в том, что мы можем, к сожалению, если мы, то есть у нас заметим, что мы выделяем, мы пытаемся здесь выделить вот эти микродеревья следующего, то есть как мы их пытаемся?
Ну, в общем случае, вот у нас есть дерево, там какое-то вот это, да, и мы говорим, что вот это корень микродерева, там вот это корень микродерева,
мы выделяем несколько корней так, чтобы каждый лист был потомком какого-то вот, какой-то выделенной вершины, и при этом эти выделенные вершины желательно никто из них ничьим там предком потомком не являлся.
Хотелось бы, да?
Что-что?
Ну сейчас подумаем, что с этим делать.
Ну просто нет, если мы разрешим пересекаться, то тогда мы не сможем доказать, что их Н поделить налогом.
Помните, как мы доказывали, что, то есть у нас цель была, чтобы этих мета-вершин было не более чем Н поделить налогом.
Ну пересекаться, в смысле, одна вложена в другую, да.
Ну, можно и так, но сейчас увидим просто проблемы.
Вот, помещенные и так далее, но это вот выделяем, но это не всегда может быть, потому что конкретно вот в дереве типа ежик мы можем выделить помещенные вершины будет либо под дерево размера 1, что слишком мало, либо под дерево размера N, что слишком много.
То есть, к сожалению, у нас тут нету неприрывности.
Вот.
Что делать?
Вот.
Ну нет, нет, на самом деле идея такая.
Значит, смотрите.
Так, давайте-ка.
Так, ну ладно, с этими кодами разобрались.
Ну сейчас мы как раз об этих кодах думать уже не должны.
Да, то есть мы уже поняли, что если в некотором смысле все хорошо, то мы в некотором смысле все умеем.
Да.
Звучит, конечно, так.
Ладно.
Ну, конечно, да.
Так, значит, это все.
Значит, смотрите.
Значит, идея у меня будет примерно так.
Так.
Вот.
Вот.
Значит, это все.
Значит, смотрите.
Значит, идея у меня будет примерно такая.
Я не знаю сейчас, к чему у меня будет.
Ну то есть, Бубен у меня явно будет равен к шелагарифам, деленной какую-то константу.
Вопрос, конечно, сейчас будем подгонять на какую.
Вроде больше 8 там получиться не должно было.
Вот.
Ну вот нам уже не хватило 4.
Что?
Что-то неточное сделали?
Ну, потому что мы решили, что у нас будут деревья от Бубен в полам до 2 Бубен.
А это, на самом деле, была же прикидка наша старая.
Ну, может.
Да.
Ну, хорошо.
Значит, смотрите.
Как вы на самом деле будем делать?
Значит, давайте попробую ввести жирное определение такое.
Значит, вершина, допустим, В интересная.
Просто надо было называть Бубновая.
Ну ладно.
Так.
Не.
Значит, интересная.
Если СЗ от В, значит, меньше, ну, допустим, там меньше Бубна.
А Бубен, в свою очередь, меньше либо равно СЗ от родителя В.
Вот такая идея.
То есть, идея в том, что у нас сейчас будет прикидка, что у нас будет с Бубновой металлистия размера 1.
Ну, типа того, да.
Ну, тут сейчас будут проблемы просто небольшие.
Значит, смотрите.
То есть, действительно, просто нет, идея просто тут заключается в том, что мы хотим пометить, объявить корнями метавершин именно интересные вершины.
Ну, во-первых, чем приятно такая технология?
Она приятна тем, что понятно, что из помещенных вершин ни одна вершина не будет являться предком другой.
Да, удобно.
Но, но есть одна маленькая проблема.
Нам требуется, чтобы в микровершине было не только, чтобы там было не очень много вершин, но и не очень мало вершин.
А интересными, вот, например, в нашем ежике, например, интересными являются все листы.
Вот все листы.
Это многовато.
Но у меня будет идея такая.
Ну, заметим, значит, идея будет примерно следующая.
Значит, я сделаю так.
Значит, у меня тут будет дерево.
Значит, смотрите, я буду, значит, эти вершинки, значит, некоторые вершинки, значит, у меня тут будут вот эти вот интересные вершины.
Это вот они интересные.
Вот я ее даже обведу.
Вот у меня тут есть какие-нибудь интересные вершины.
Вот.
Ну, и можно заметить, что каждый лист будет лежать, ну, давайте вот так сделаем.
Каждый лист будет лежать, будет являться потомком какой-то интересной вершины.
Да.
Вот. Ну, кстати, да, заметим, что сам потом, сам, конечно, лист тоже может оказаться вполне вот, например, интересной вершиной.
Собственно, почему бы и нет.
Тут вот, кстати, вот.
Да, вот тут может быть такая интересная, действительно, ситуация.
Часто вот.
Это вот, смотрите.
Для длинный путь какой-то, к нему было сверху, рядом сделать один.
Ну, да, по барабану, может быть, прям вот так.
Вот.
Ну, а теперь, значит, да, но приятно, что, конечно, в под деревьях у них не более чем Бубен.
Ну, даже меньше, чем Бубен вершин.
Значит, смотрите.
Ну, теперь у меня идея такая.
Значит, теперь у меня сейчас между микро-вершинами и большим миром будет промежуточное звено.
Промежуточное звено будут родители мета-вершин.
Вот.
Вот рассмотрим родители мета-вершин.
Вот.
Понимаете, да?
Значит, идея будет такая.
Значит, идея будет следующим.
То есть, смотрите.
Ну, вот.
Значит, у меня будет практически где-то три варианта, на самом деле, промежуточное звено.
Либо, когда мы поднимаемся из вот этого микродерева, а микродерево у нас будет висеть на интересных вершинах,
то, значит, либо этот подъем у нас происходит не выше корня, и тогда мы там все из табличек достаем, да?
Значит, а если надо подниматься выше, то мы, значит, поднимаемся до родителя.
То есть, ну, еще один шаг делаем, да?
А потом после этого у нас остаются только вот деревья, вот это вот дерево, в котором все, что ниже родителей, отсечено.
Ну, когда у нас запрос выше, то нам просто теперь от родителя, то есть, от родителей интересной вершины нужно куда-то подняться.
Куда-то.
Да, куда-то.
Значит, вот теперь, значит, как нам это делать?
Теперь идея такая.
Значит, как работать?
То есть, итак, то есть, мы свели задачу, когда у нас, то есть, свели задачу к следующей.
То есть, у нас есть дерево.
В котором мы, по сути, отпилили все поддеревья интересных вершин.
Вот видите, да?
Взяли и отпилили.
Понимаете, да?
Ну, теперь, что это нам дает?
Теперь утверждение.
Я утверждаю, что в оставшемся дереве каждый лист, который мы отпилили, мы отпилили.
Я утверждаю, что в оставшемся дереве каждый лист является, то есть, каждый лист.
Нет, он не интересная вершина, но в его бывшем поддеревья обязательно, обязательно было хотя бы, хотя бы бубен вершин.
Логично, да?
Да.
То есть, теперь, ну вот, то есть, точнее так.
Ну, точнее так.
Каждый лист, утверждение такое, важное утверждение.
В оставшемся дереве каждый лист – это бывший родитель интересной вершины.
Еще раз.
Отверждение.
Каждый лист.
Вот мы отпилили, вот мы пометили все интересные вершины и отпилили.
Каждый лист – это родитель…
Вот в оставшемся дереве каждый лист – это родитель какого-то бывшего депутата Государственной Думы.
Вот.
Бывшего поддерева.
При чем тут?
Нет, интересно, кишка 12 стульев.
Да.
Вот.
А также, соответственно, то есть, получается, в оставшемся поддеревья, то есть, на каждом листе что-то висело.
И не просто что-то, а бубен вершин висело.
Ну ладно, считай, может быть, ее саму.
Помните?
Ну вот.
Нет, просто не может быть так, что у нас остался лист и на нем висело что-то мало.
Потому что если бы на нем было мало, то либо его, либо его в составе чего-то мы бы его отпилили, правда?
То есть, поэтому на каждом этом родителе, то есть, каждый лист в оставшемся дереве – это родитель.
То есть, заметим, неверно обратное.
То есть, из картинки следует, что не любой бывший родитель мета-вершины, то есть, интересные вершины, является в оставшемся дереве листом.
То есть, видите, всякое может быть.
Но самое главное, что каждый лист, он им являлся.
И что самое главное, зачем мы все это делаем?
Так как на каждом листе раньше независимо, значит, соответственно, независимо висело хотя бы логарифом вершин, то есть, хотя бы бубен, то тогда получается в новом дереве количество детей – это не более, чем n поделить на бубен.
Вот.
Так что на этом дереве теперь запускаем n лога n от единицы.
И, в общем-то, вот на этом все с вами были.
Вот.
Так вот.
Так что вот такая нот.
Так что вот, в общем-то, и все.
То есть, вот еще и нот.
Еще одно применение метода четырехрусских.
То есть, как всегда, что-то нот.
То есть, как всегда, то есть, какие-нибудь, если деревья очень маленького, там малого размера, можно обязательно предподсчитать.
Вот.
И, собственно, мы это успешно делаем.
То есть, вот, собственно, та же технология.
Переподсчитаем.
Так. Ну, давайте. Вопросы какие-нибудь есть тут?
Да, вы меня позаписали.
Ну, вот.
Так. Вопрос есть. Давай.
Значит, когда мы делаем предподсчет всех этих маленьких деревьев, мы жестко кладем то, что они будут размером бубен.
Нет. Они будут размером меньше, чем бубен.
То есть, теперь обратите внимание.
Технология изменилась.
То есть, потом как теперь нам, как мы поднимемся поставлять, как получать ответ?
Идея очень простая.
Значит, вы просто будете считать деревья размера не только бубен, но всех размеров от одного до бубна.
А нам теперь подгонять не надо, да?
Ну, давайте подумаем.
Есть вариант тупо забить, короче, и просто в поди дописать там PSP ровненькое.
Нам все равно не придется в той части обращаться.
Ну, чисто теоретически, кстати, да.
То есть, вы можете посчитать все размера бубен и просто каждому коду, если он маленького размера, там приписать там 10101010.
Оно же нам вот не влияет.
Ну, если вы все посчитаете, то у вас ассептатически будет то же самое, просто там в константу раз возрастет.
Ну, вот. А можно, да, действительно посчитать только конкретного размера бубен, а если код там слишком маленький, то припишем 10110.
Ну, это типа вот.
Почему такого дерева не может быть?
Почему такого дерева не может быть?
Какого дерева не может быть?
Такого, который мы лишним сделали.
Нет, это приписывание лишнего.
Приписывание.
Но ты попадешь в валидное дерево.
Да, меня это устраивает, и что?
Ты перепишешь ему.
Почему он неразрывный?
Нормально.
То есть, это часть, которую мы хотим.
Там не будет бумки.
Можно, на самом деле, написать ему лишних леденец, потому что тогда...
А нельзя лишних леденец?
Да, лишних леденец.
Короче, если читать что-то на сольдеревых цешках...
То есть, плюс один.
Нет, погоди. Я, честно говоря, не понимаю, почему вы не хотите, почему коду такая проблема лишний 10110 приписать?
Сейчас. У нас есть маленькое дерево, и у него есть код, который мы получили приписав 10110.
А есть другое дерево, у которого реально такой код, который мы написали.
Еще.
А дальше код нашего маленького дерева.
И у них ответы будут лежать в одной ячейке.
У них ответы лежат в одной ячейке?
Да.
А там же все забьется?
Нет.
В смысле, еще раз, у нас у двух разных деревьев должны поместить ответы в одну ячейку.
Да.
Нет, у каких двух?
Вот у этих двух бетовершин, да.
Может быть, ответ у них лежит в одной ячейке?
Да.
Нет, у двух разных по форме деревьев.
Нет.
Нет.
Подумай над тем, как выглядит ваша кодочка с рельевым путем.
Для общей трассы, как выглядит вот эта маленькая дерева?
Она заканчивается на ноль и начинается на ноль.
Стой.
У нас куча ежек.
У нас интересные вершины маленькие.
А мы залоги дописываем.
Не, какая разница?
Ну во-первых, ну приписали, что...
Эн-лог.
Нет, при чем тут эн-лог?
Нет, во-первых, мы Бубен подогнали так, что перебор всех деревьев...
Нет, слушай, а что мы приписывали?
Мы для каждой из этих припис...
Нет, ну я надеюсь, ты код не залогарифумен приписываешь.
ОК.
А за сколько?
Я тебе считаю длину, обрезаю массу, приписываю...
Да.
Ну как бы, да, естественно.
Как бы, да.
То есть это все за...
То есть понятно, что, знаете, масса...
То есть как бы такое битвое число в духе 1,0,1,0,1,0, вот само битвое число,
оно там заранее либо предподсчитывается, либо вычисляется за 1,1.
Потому что это геометрическая прогрессия степени 2.
Возможно, у нее даже какая-то красивая формула есть.
Вот.
Шоу про...
Можно оставить на 0.
Нет, ну можно ничего не приписывать и предпочитать просто все мелкие размеры вообще все.
Тоже вариант.
Я утверждаю, что если оставить там нули, то не будет никаких количеств.
То есть не какие-то два дерева разные по форме, они будут в одну ячейку.
Ааа.
Это очень простое, потому что на самом деле количество нулей должно быть равно количеству единиц.
Вот, если у нас, по-моему, развернули...
Ну количество нулей, оно...
То есть потом, когда предпочитывать будешь, ты эти нули должен будешь, как это, предпочитай, как-то тоже предобработать.
У тебя же каждая ноль соответствует либо единицы, либо минусы единицы, да?
Нет.
Ну вот, поэтому как бы...
Поэтому получится, возможно, даже не валидное дерево где-то.
Поэтому вот приписывать к масочке, чтобы было валидное дерево, я бы рекомендовал именно 1.0.1.0.1.0, типа чтобы вот туда...
Ну потому что, то есть это будет символизировать, что если дерево оказалось мелкое, то я тут просто вот нарисовал тут лишних.
Вот таких вот этих.
Вот я-то откуда это 1.0.1.0.1.
Но для них ты ничего не будешь предпочитывать.
Для этих лишних.
Да почему можно и предпочитать?
Потому что...
Стой, ты для них будешь предпочитывать перки, я правильно тебя понял?
Да.
Тогда у тебя есть ежик, у которого N интересных вершин.
Ну.
К каждой интересной вершине ты взял это микродерево.
Да.
Например, 1 и дописал еще до Бубна, то есть до логарифма.
Да.
И для каждого предпочитал перки.
Это конечно все одинаково.
Ну во-первых, да, ну и что?
Ну во-первых, ведь дерево-то у меня все равно осталось размера Бубен.
Да, деревья всего 20.
А это просто будешь считать тип дерева, ты будешь дописывать по маску, окей?
Да, конечно.
Нет, так-то понятно, что мы уменьшаем.
А вот мы предпочитываем еще дополнительные таблицы перевода относительных вершин в абсолютные, да?
Ну тип того.
Ну или наоборот.
Ну да, обязательно.
Ну конечно.
Так что вот такая вот красота.
Получилось?
Ну как?
Ну как сказать, по-моему, да.
Кто-то пытался, как говорится, энлогендные варианты не оборвал.
Ну логично.
Так что да, честно, не пробовал.
То есть я не знаю.
То есть может быть есть мечта, когда-нибудь, когда компьютер будет обрабатывать деревья размера 10-18, может быть этот алгоритм начнет обгонять энлогендный.
Но это уже совсем другая история.
Да, совершенно верно.
Ну собственно это как и всегда.
Так, ну ладно, пока, я думаю, пришло время перерыва.
Сейчас 15.45.
Значит через 10 минут продолжим.
