Товарищи, нам предстоит грандиозный выбор. Есть STD Any, есть STD Function.
Что из них? Function больше интересно, да, как работает?
Bind. А Any вы писали на...
Короче, давайте считать, что не все здесь писали Function.
Поэтому сюда. Нет, не сюда. Так, давай не будем. Нам сюда.
Значит, смотрите. Сеттинг следующий. Мы хотим STD Function.
Работать он должен примерно точно так же, как STD Function. Просто пихаем туда лямду, и она работает.
Ну, тут от какого-то функционального объекта конструируют, от лямды, и там что-то происходит.
Я не помню, я это вписал в четыре ночи в какой-то момент в начале семестра.
Давайте разберемся, что я хотел сказать. Cold ones изначально равно false.
Возможно. Нет, я хочу просто, чтобы лямда, когда ее первый раз вызвали, написала hello,
а второй нет. Вот F, и мы тут эту F фу передаем, она туда копируется и пишет что-то.
Ну, короче, неважно. Нужно написать Function. Какая семантика? Кладем внутрь лямду,
и она внутри живет вместе со своим захватом. То есть Function это не только указатель на функцию,
это еще и какое-то состояние. И то, и другое.
Причем сюда можно не только лямды класть, можно еще класть объекты какие-то,
которые умеет оператор круглые скобки, но и все поля, которые у этих объектов есть,
они как бы тоже внутри должны жить. То есть это полноценный контейнер для любого типа.
И вот это ровно то, что называется TypeRager. Мы сюда можем положить объект любого типа,
коль скоро у него есть оператор круглой скобки. И этот оператор круглой скобки каким-то
волшебным образом мы запомним и будем уметь его звать даже не зная типа объекта.
То есть вот эта функция Fу, она понятия не имеет, какой на самом деле тип внутри F лежит.
Но она все равно может его позвать. Вот это такой некоторый аналог,
некоторое скрещивание статического и динамического полиморфизма. Что-то есть от обоих.
И называется это TypeRager. А теперь надо это написать, потому что здесь вот так вот,
а надо свою. Но тут, конечно, большой вопрос, как мы это будем писать.
Нет, это не то, что я имел в виду. Давайте, наверное, все-таки я буду писать,
потому что сложно сейчас как-то это распараллелить на всех будет.
Ну первое, давайте интерфейс публичный повторим. Тут есть один шаблонный параметр,
должен быть какой-то конструктор чего-то и оператор круглые скобки. Шаблонный параметр.
Конструктор. Ну, наверное, и дефолтный будет, и еще какой-то, пока непонятно какой.
Оператор круглые скобки. Что? АТ? Ну, пока давай так оставим.
Оператор круглые скобки, тоже пока непонятно от чего. Вплевать, что-то будет лежать, наверное.
Ну, еще я... Ну, это прекрасная идея, но сейчас разберемся.
Ну, это не интересно, если так. Да, про то, что мы передаем в конструктор,
Т или не Т. Ну, какие мнения есть? Вот похожа на правду вот такая конструкция?
Разный тип, да. Вот просто смотря на то, как используется std.function...
Сейчас разберемся. Вот как function используется. Вот здесь указан тип функции, функциональный тип.
Просто void.int. Это значит какая-то функция, принимающая int.
А в конструктор мы кладем объект типа functional object. То есть вот этот тип и тип аргумента конструктора, они отличаются.
Ну, внезапно оказывается, что мы хотим вот так. Причем здесь какой-то вообще там по универсальной ссылке принимаем f.
Дальше. Мы хотим оператора круглые скобки. Какой хотим оператора круглые скобки?
Ну, ровно такой же, какой указан вот здесь, да? Вот это сигнатура для нашего оператора круглые скобки.
Внимание, вопрос. Как сделать сигнатуру вот этой фигни такой, как написано вот здесь?
Нет, в ряде. Сейчас. Что же ты имеешь ввиду?
Как? Ты хочешь вот так сделать или что?
Что? Что? Что ты хочешь сделать?
Ну, это как-то очень глупо, потому что у нас вот в этом типе уже закодирована вся информация о том, какая должна быть сигнатура. Прямо сказанная.
Возвращать void, принимать на вход int. Нет, мы не хотим статик касты. Мы хотим, чтобы тут сигнатура была у оператора круглые скобки ровно как написано вот здесь.
Ну, раз уж у нас есть конструктор tf, наверное, мы напишем поле, типа. А, сейчас у нас конструктор шаблонный, а tf – сигнатура, да?
Про конструктор пока вообще не думаем. Тут ничего не понятно. Единственное, что поняли, сюда приходит произвольный объект, и его как-то надо сохранить, как непонятно.
Ну, вот просто руками вот так вот сделать, и оно, конечно, сработает.
Да, в стандартном std function используется не такой синтаксис, а прямо пишется сигнатура функции. То есть вот это тоже тип, да? Это тип ссылки на функцию.
Когда-нибудь задумывались в таких вещах? Нет? Нет, ну functional pointer выглядит вот так. Вот такой дурацкий синтаксис, да?
Вот эта звездочка в круглых скобках значит, что это указатель на функцию, слева от нее пишется возвращаемое значение, справа в круглых скобках – аргументы.
Да, еще можно название внутри, но я предпочитаю всегда юзинги заводить, чтобы о таких бредовых вещах не думать. А есть function ref, она выглядит вот так.
Вот это тоже вполне валидный тип в языке C++, это ссылка на функцию. Более того, если навесить звездочку, то будет то, что вы ожидаете. Funcraft превратится в funcptr.
Ну давай посмотрим. Только, а как мы разменим? Не, ну нельзя.
Очень сомневаюсь, что что-то получится, но вдруг. Ну не работает, нельзя.
Ну вот, е-мое, каждый год что-то новое узнаю. Это еще один тип, да? Совсем другой.
Вот это не то же самое, что вот это, а это как бы, то есть это как бы тоже указатель, а нет, да, это указатель, а это фигня, это ссылка.
Нет, сейчас. И так можно, да? Слушайте, ну давайте тогда не будем это плохом.
То есть, короче, C++ язык считает, что функция, это в принципе то же самое, что объекты, да? То есть это даже не function reference, я, получается, наврал.
Я всегда его function reference называл, но, да, видимо, C++ считает, что точно так же, как у вас есть int, обычный int, есть int, а бывает указатель на int.
Бывает ссылка на int и бывает R-value ссылка на int. Оказывается, C++ считает, что то же самое, что с функциями происходит, да? Есть тип функции, есть указатель на функцию, есть ссылка на функцию, R-value ссылка на функцию.
Что нет, вот, я написал.
Фанк, вот это вот что такое? Ну это тип, это тип функция. У этого типа не думаю, что есть значение. Как это использовать, да никак. Нет, а, окей, значение этого типа это функция.
Ну, то есть сейчас я, короче, вас, кажется, начну учить супер плохому.
Нет, sizeof, я думаю, не скомпилируется, потому что это нерегулярный тип, но можно написать вот так.
Что это значит? Это значит, где-то в другой единице трансляции есть функция foo. Я могу ее в той же написать, в принципе, да? Нет, не могу. Могу.
Ну, функция foo. А да, чтобы подтвердить мой point, я просто вот так сделаю.
Если мы кликнем, то нас приведет сюда. Вы видите, компилятор считает, что это мы вызвали вот эту функцию. Ну, то есть этот тип работает как любой другой тип.
Вы можете объявить функцию при помощи этого типа. Просто взять и объявить. Вот она, foo, объявлена. Это функция.
У меня есть предположение, что sizeof.funk не скомпилируется, а sizeof.funk.vr.funk.ref и funk.vr.ref скомпилируются.
Да, правильно. Так нельзя. Так implementation defined, кажется. Ну, тут вот 8 получилось.
Sizeof.ref, он не компилируется, конечно же, потому что это все равно, что применить sizeof к тому, на что reference. Ну, как функции нельзя.
Чудеса происходят в языке C++, но тем не менее. Исторически так сложилось, что вот этот синтаксис используется как abuse, чтобы указать функции тип ее оператора круглой скобки.
Вот, ну если, ой, вот это же вас на плохие мысли должно было вытолкнуть, да?
Что значит using? Вот у нас класс T, тип функции. Ну, значит мы можем объявить функцию. Я не уверен, что это сработает, если что-нибудь такое написать.
Нет, если это работает, ну не должно, короче.
Ну, такие приколы не пройдут. Все, забыли пошлости. Давайте, ну просто взять нужные и достать из вот этого T, что там внутри запаковано с помощью этого синтакса смешного. Как это сделать?
Распаковать такой тип сложный.
Зачем? Мы можем написать, ну, если мы хотим прям закрыть от юлера все это, мы можем сначала написать, типа template class signature с class function.
И затем уже сматчить его непосредственно к class tag.
Нет, сейчас у нас всего час, поэтому мы не будем пытаться совсем красиво делать. Специализацию, все, вот простой ответ. Вам нужно распаковать сложный тип, делайте специализацию.
Рет. Аркс. Да, наверное, все-таки сегодня все время я буду писать код, а вы будете мне подсказывать и мы будем обсуждать.
Потому что надо успеть побыстрее, чтобы я финальные слова еще сказал про всю эту бодягу.
Рет. Аркс. OK, теперь мы знаем, какой рет, какой аркс.
Можем написать рет, оператор, круглые скобки, аркс.
Вот, это важный вопрос. Нужен ли здесь perfect forwarding? Я утверждаю, что не нужен.
Почему я так утверждаю? Потому что если мы начнем пытаться for perfect forwarding делать вот в этом месте, то, вернее, как универсальные ссылки начнем пытаться делать, вот такое вот.
Так будет не очень.
Так будет не очень. Вот почему так не очень?
Потому что не шаблонный.
Ну да, он как бы самый не шаблонный, но и это в принципе бессмысленно, потому что уже в этом t, вот уже в этой сигнатуре, вам могли, да, уже могли присылать зашитые ссылки.
Там бул и тут флот с двумя. Во что это превратится после навешивания еще одной рвали ссылки?
Ну да, да, зачем? Ну это первый может просадить, если у вас там... Ну вы понимаете, да, что маленький тип, их быстрее не по ссылке гонять, а по значению.
То есть, ну...
Да, крупные типы нужно оставить такие ссылки, какие указал пользователь, вот здесь, а не свои какие-то навешивать.
Поэтому нет, здесь не нужно навешивать еще ссылки, а вот ну использовать std forward в рамках этого реализации,
которую у нас пока нету, ну наверное понадобится все-таки.
Почему вопрос? Я не понял.
Я все еще не понял, что ты говоришь.
Вот в треугольных скобочках у function...
В треугольных скобочках...
Можем.
Просто у нас это не работает.
Окей, давайте научимся выводить.
Смотрите, вот здесь сейчас работает, код компилируется в принципе, да, ну запускать бессмысленно, я думаю.
А вот здесь ругаются, что no viable constructor or deduction guide.
Но вы уже умные и должны знать, чего не хватает, да?
Вот это и вот это.
Никак не связано, да?
Как связать?
Нет.
Дедакшн гайд надо написать.
Кто может надиктовать дедакшн гайд?
Или мне написать?
Ну я почти уверен, что нет.
Потому что пишем, мы всегда в дедакшн гайде всегда пишем аргументы этого конструктора.
Давай сначала так напишем.
Что такое дедакшн гайд?
Если нам позвали конструктор от вот такого выражения, то какой должен быть вот этот шаблонный аргумент T?
Главного шаблона.
А что ты разворачивать собрался?
О, STD and book result.
Нет, это не то.
Это все не то.
Смотрите, есть вот такой тип functional object.
Вот его передали в конструктор.
И мы хотим вот автоматом определить вот это.
Где вот это вот написано у этого типа?
Да.
Сигнатура оператора круглые скобочки.
Поняли, что происходит, да?
Поэтому напишем здесь ровно так.
Ну или не напишем.
Написали? Получилось?
Вот кто сказал про дес избавиться, да, вы абсолютно правы.
Сейчас это будет pointer на мембера.
А там уже будет тайн трейд, который управляет.
Ну надо.
Если у нас перегрузка оператора круглой скобочки,
то дедакшн гайд работать не должен.
Все.
Как и в стандартной библиотеке.
Ну как ты выведешь, какой из операторов круглой скобочки ты хочешь?
Ну давайте напишем.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Ну давайте напишем по-быстрому эту вспомогательную фигню.
Мы хотим имя pointer на мембер, да?
Ну это будет какой-то непонятный...
Имея вот такую штуку.
Что я пишу, боже мой.
Имея такую штуку, хотим получить сигнатуру.
Да.
Только что tend to member, можно сразу...
Ну можно даже без присоединяется, что-то здесь сделать.
Нет.
А, не пообща, да.
Присоединяйся.
Двоеточие, двоеточие, звездочка, да.
Класс T, класс Red, класс...
ARKS, да?
Опа.
T, двоеточие, двоеточие, звездочка.
А это все в скобке?
Да, это все в скобке, Red.
И вот здесь...
Ты понимаешь, что происходит?
Кроме вот одного человека, который меня диктовывает правильно.
Хорошо.
И вот здесь...
Так тьюзинги же нельзя специализировать вроде.
Можно все-таки, да.
У меня...
Нет.
У меня какая-то странная квантовая запутанность тьюзингов в голове.
Я то считаю и полностью уверен, что их можно специализировать,
то считаю полностью уверен, что нельзя.
Вот...
Да.
Ну...
По-моему, все-таки...
Что-то у меня не так шло. Я не знаю, как так вышло.
Надо этот вопрос решить раз и навсегда.
Но теперь мы научились утаскивать сигнатуру.
Что?
Да.
Если есть вопрос, что за фигня происходит, задайте его, пожалуйста.
Да.
Тип...
Вот это...
Что?
Нет.
Нет.
Ну сейчас поймем, почему.
Что-что?
Ну как бы...
Мы хотим узнать сигнатуру для оператора круглой скобки
в нашем functional object.
Нет.
Нам в качестве this
сам вот этот function выступает.
Вот тут тоже есть this.
Вот.
Он и будет this.
В том смысле, что в std function
можно передать ссылку на метод,
а потом первым аргументом,
когда вы эту функцию вызываете,
вы должны передать указатель.
Это отдельный конструктор будет.
Вот этот конструктор
просто от объекта,
у которого есть оператор круглой скобки.
От лямбды там от прочего.
Это отдельный конструктор, а отдельный специалист.
Все, да, я понял.
Кстати, у нас здесь уже сигната
была выточена чуть-чуть дальше.
Да.
Я не понимаю, как выточить
звездочку.
Вот. Это правильный вопрос.
Значит, в языке
C++...
Тут просто образовательная сейчас
будет очень сильно.
Давайте вспомним, какие операторы
из C++?
Я думаю, много звездных.
Оператор, стрелочка, звездочка.
Да, оператор, стрелочка, звездочка
и оператор, точка, звездочка.
Да. Так, в языке C++
если сделать структуру...
и сделать в нее, например, вот так.
Внезапно, внезапно
можно в runtime значение
сохранить в каком-то смысле
сдвиг поля относительно
начала структуры.
Вот.
Называется это pointer to member.
То есть это
некоторый тип, описывающий
какое из полей структуры мы выбрали.
Выглядит заполнение
вот так.
То есть мы выбрали первое поле
структуры. Могли второе,
могли третье.
Можем перезаписать.
Да, ну при этом
все эти поля, они все интового типа
и поэтому это работает.
А дальше вот этот вот волшебный указатель
ptr, который как бы
помнит
какое из полей
нас интересует, мы можем его
использовать, чтобы на конкретном объекте
point
обратиться к
конкретному полю
и заполнить его или прочитать.
Прикол, да?
Кто не знал об этом?
А зачем?
Ну, в языке C++
таких вопросов обычно не задают.
Ну можно.
Почему?
Вдруг тебе реально хочется, чтобы
вот один и тот же кусок кода отработал
два раза.
Кстати, это отличный
пример, который даже я в какой-то момент
накодил, правда на ревью у меня конечно
косо посмотреть.
Потом я накодил лучше, но в принципе так
можно.
Просто нормальный код писать я не знаю.
Ну да.
Можно сделать мапу
из стринга в точку
point.
Вот.
Ой, да.
Потом еще хранить где-то эти строки.
Давайте не будем.
А, в смысле конфиг у тебя не
из этого прочитано, а откуда-то там
из...
Я все равно должен написать отдельную
руку.
Окей, я пишу это с мыслью...
Короче, неважно, так...
В проде так не пишите, все.
Пример следующий, вот есть конфиг
его хотим из файла инициализировать.
Мы знаем, что в файле вот написано
там field1, field2, field3.
Но это JSON какой-то, да?
Там просто строки написаны.
Соответственно, нам нужно понять как-то
по строке файла, какой из полей мы хотим
заполнить.
Но мы возьмем и сделаем мапчик
из строк в конфиг
2.2.
Вот так вот.
Инициализируем этот мапчик тем,
что
field1
попадает в
i
f
Нет.
Никуда мы не превращаемся.
Вот, а еще, еще мы сюда в какой-то момент
flatmap бахнем и допишем
constexpr. И тогда
мы вот вообще там...
Не даже теперь потеряли.
Но пока не можем так.
Пока что не работает.
Понятно суть, да? Зачем это может быть
нужно?
Ну вот, такая штука, по-моему, я что-то такое
описал в какой-то момент, но потом удалил
и правильно сделал.
В редких.
Да.
Во-во-во.
Да, это отличный пример.
Если чуть подробнее рассказать, то давайте
вот так.
Вот в ренджах
добавили новую функцию сортировки.
То есть просто вот такая функция есть.
Где она полностью выписана?
Нигде.
Ну, ты видела, как я только что вписал, да?
Вот.
std.range.sort
Сортирует, но вот тут есть buff,
ей добавили proj, такой аргумент.
И вот в этот аргумент можно
скормить вот такой
указатель. И тогда
ты сможешь конфиги или там точки
отсортировать по иксу.
Да, но
это мне неудобно, чем проекция.
Да. Вот тут нормальное
применение. И у нас нормальное
применение, потому что мы только что это
применили. И вот точно так же,
как я говорил, что
вообще-то
вообще-то вот это
вполне нормальный тип, функ, да?
Давайте запомним его.
Вообще-то вот здесь можно написать любой
тип. То есть конфиг, два двуточья, звездочка
и перед этим что угодно.
Где?
Вот тут стринг.
Нет, ну всегда надо что-то писать
перед вот этим вот конструкцией.
Вот здесь?
А, нет, туда пока не смотрим.
Потому что тут прикол.
Ну, раз туда что угодно можно
написать, почему бы туда не написать тип
функции?
Функция, это что же в каком-то смысле
член класса, структура и прочего?
Тоже member.
А это указатель на любой member.
Но будет указатель на функцию, являющуюся
мембером.
Member функцию к
мембер полю?
Так это ж одно и то же нет.
Потому что вот я тип функции указал и вот.
Ну, если это
расписать подробнее, то вот мы посмотрим
какая сигнатура у функ была void
int bool, да?
Явно расписывая, будет вот так.
Да, ты что-то другое, кажется,
имел ввиду. Вот это
один и тот же класс, да?
А, про это готов
поверить, там странные правила.
Ну вот, что это значит?
Мы умеем хранить указатель
на конкретную функцию,
вернее, конкретный метод в
поле, в классе.
Ага.
Вот здесь ровно это происходит.
Мы говорим, что
decltype f2.
оператор круглой скобки, это что такое?
Это указатель вообще-то
на member.
Оператор круглой скобки это member вот этого f.
Мы берем ссылку
на самом деле, а не указатель, да?
Тут опять вот эти вот все оговорки
про то, что здесь не только звездочка,
наверное, может быть, скорее всего.
Вот это вот, это
ссылка на member.
Нет, указатель, нет, все, вру.
Тут только указатель, тут только указатель.
Это указатель на...
Ну вот, наверное, да,
наверное, все-таки тут просто ничего компилироваться не будет.
Вот, нет, вот так, именно так.
Вот, это указатель на
member, мы берем его
тип и запихиваем в нашу
шаблон волшебный.
Вот этот шаблон распаковывает
по общему паттерну, как оно
выглядит, ред,
класс у которого этот
member и аргументы.
Потому что мы тут оператор круглой скобки
смотрим, это всегда
member функция,
то есть метод. Ну и
распаковав, мы обратно запаковываем,
но уже без
вот этой вот фигни, просто как обычную
функцию. Прикол,
да?
Вот то,
что вот эта вот часть, она
как бы, она и отвечает за
this, да?
Ну кто-то
в смысле, ну кто-то говорил,
что вот так надо написать,
что типа давайте явно передавать this.
Или может
я не понял просто, что мне говорит.
Специализацию
и без указательств.
Специализацию, да, function.
Просто звездочку
без std.
This.
Что?
Ну короче,
как функция, которая первым аргументом
this принимает. Ну можно
написать функцию, которая первым аргументом this принимает.
А, нет.
Нет, нет, нет.
Это не то же самое.
Вот как раз в том-то и сложность, что ты не можешь
получить функцию, которая как бы
имеет такую же сигнатуру, но явный аргумент,
кроме как вот через вот такой вспомогательный
шаблон.
Ну как бы
полный тип да,
но нам this не нужен.
Ну вообще тип
метода в классе,
вот он.
Полный тип метода в классе.
Здесь неявный аргумент, это this,
который обозначен через вот этот забавный синтаксис,
то есть у какого класса
это member.
А так в целом это просто функция
с вот такими аргументами, вот таким результатом.
Что?
Почему
в скобочках в правом рейтере
Так, ты проснулся, кажется.
Вот,
сюда возвращаемся.
Это то же самое.
Вот это указатель
на member такого типа.
Нет, есть общий синтаксис
указатель на member.
Вот это указатель на member string.
Да?
Я говорю, давай вместо стринга сюда
поставим тип функции.
Вспоминаю, этот метод выглядит как void от int bool.
String заменили на void от int bool.
И на самом деле
получили
method.
Вот так надо назвать это.
Я заговариваюсь.
И мы получили то, что называется
указатель на метод.
Вот эти два типа одинаковые.
Да?
То есть это указатель на поле
в кавычках,
которая на самом деле является функцией.
Суммарно, это указатель
на конкретный метод в классе.
Если этого класса несколько методов
foobar,
то ты в переменную вот такого
типа сможешь положить
То есть указатель на member походит
в часть типа метода.
Чей member входит в часть типа метода, да.
Фу, можно вот так.
Можно вот так.
Да, в типе
указателя на функцию member
зашита
у какого класса member
какого типа member.
А для функции тип означает
возвращаемое значение и аргументы.
В общем, что-то образовательно
сегодня получилось, но я надеюсь, вы поняли
идею с этим.
Возможно, это надо перечитать,
пересмотреть несколько раз.
И один раз самостоятельно закодить
какой-то из домашек, а может и не надо.
Ну вот, такой есть.
Это жестко,
но оно нужно.
Напоминаю, с чего мы все начали.
Мы хотели, чтобы вот этот код компилировался.
Хотим вывести тип
для функции,
в которую положили какую-то лямду.
Ну, давайте проверим,
что моя гипотеза верна.
Только для этого понадобится
вытащить
наружу.
Давайте проверим, что
у вот этой вот f,
ее тип получился
ровно такой, какой мы ожидаем.
Какой мы ожидаем у этой лямды?
Вот в этом месте, чтобы вывелся тип.
Void attempt.
Не поверите, статик ассорт прошел.
Он же не просто сломался,
да? Все нормально.
То есть мы правильно выдрали
из вот этой вот сложной конструкции
сигнатуру оператора круглой скобки.
Теперь, наконец-то, пора
имплементировать эту шнягу.
Вы рады?
Да, такое бывает.
Давайте думать.
Нам нужно сохранить две вещи.
Сам объект
и как вызвать оператора
круглой скобки?
Каким образом это надо сохранить?
Какие у вас будут предложения?
Ну, нам нужно найти,
как мы можем взять,
написать какой-нибудь интерфейс
или
просто написать
указательную...
Интерфейс. Мне нравится предложение.
Давайте подумаем.
Необходимую семантику.
Мы...
Ну, вот...
Здесь у нас будет какой-нибудь
интерфейс. Мы сейчас не точим,
какое именно. И тогда мы можем
написать какой-нибудь класс
с шаблонным параметром
видефункция, который конструируется
в шаблонных полях. И нас следует
вот этот интерфейс.
Это правильное решение.
Поднимите руку, если вы поняли.
Ну, вот.
Кажется, не все
поняли.
Да, зачем интерфейс не ясно?
А это легко замотивировать.
Мы собрались хранить произвольную F.
Все, что мы об этой F знаем, а мы пока
ничего не знаем, давайте потребуем
кое-что от нее.
Мы потребуем, чтобы она
инвокабл была.
Вот ARKS.
Чтобы это был
такой тип, функциональный,
который можно вызвать.
Здесь ошибки были.
Сейчас.
Мы требовали, чтобы ее можно было вызвать
от ARKS, а потом выводим
эти самые
ARKS и так же гляньте.
Спасибо.
Видимо, просто нет концепта с ретерном.
Ну,
ладно. Сойдет.
То есть мы что-то требуем, но это
требование будет потом проверяться.
В самом конце.
Вот этот дедакшн гайд не привязан
к этому конструктору.
Дедакшн гайды запускаются еще
до того, как какие-то конструкторы где-то
искать.
Очень нормально.
Да не должно работать, блин. Я такой код
примерно писал, он работал.
Наверное, там бага был, но его пофиксить должны были.
Либо не знаю.
Увидим.
Что мы хотим сделать на самом деле?
Мы хотим вот этот вот объект типа F
сохранить в поле.
Все, что мы хотим.
Можем ли мы это сделать? Почему красно
обугается?
Вот тип этот F
известен только в рамках конструктора.
В рамках самого шаблона класса
неизвестно, какой F мы храним.
Вот его стереть надо, да?
Стодайни это прекрасная идея,
только мы руками хотим написать.
Прекрасно. Давайте сделаем
шаблонный стордж.
Это поможет в принципе.
Ну, не важно.
Стордж.
Стордж будет хранить F.
Прямо брать и хранить.
Прекрасно.
Ну, а как мы сам стордж будем
хранить, да? То есть ну...
Взять и создать стордж.
Это как бы много
ума не надо.
Т...
Наверное, лучше DK, да?
DK и T.
Да, про всякие рему в референции
и DK вам же рассказывали всем уже.
Я вот на это не обращаю внимания.
Все убирает, чтобы было нормально.
Ну да.
Такие вещи будем
игнорировать.
Ну, считать, что все вы уже знаете.
Вот можем сделать стордж от F, да?
Как его сохранить теперь?
Ну, давайте вводить звездочку, что ли.
Только уж не вводим звездочку, а скорее
какой-нибудь тип
или морфон, который вам будет
наследоваться, или мы считаем, что это зло?
Ну, нет, мы не считаем, что это зло.
Это отличная идея, но как-то зачем?
Пока идем по пути наименьшего
сопротивления.
Вопрос теперь. Как у этого
сторджа вызвать оператора круглый
скоб?
Мы же уже забыли, что там лежит внутри.
Ну, вот в этот стордж мы
запендюрили какую-то F.
Типа F.
О,
это отличная идея.
Значит,
это первая идея.
Ну, вопрос-то понятен в целом.
Сейчас
обсудим.
Сейчас обсудим.
Сейчас обсудим, да.
А,
ну, я считаю, что
Дэвид сам разберет.
Нет.
Вот два человека уже все
поняли.
Так, давайте на шаг назад.
Вы поняли
вопрос. Как вызвать оператора
круглой скобки? Поняли, зачем его вызвать?
Поняли, что лежит в этом, в этой его
звездочке? Просто F, который нам
прислали изначально.
Ну, и тут вопрос. А как вызвать?
А ответ на этот вопрос
может быть простой, может быть хороший.
Простой ответ
это вот действительно, как посоветовали.
А давайте полиморф на иерархию бахнем.
Давайте не поводить
звездочки хранить. Это ж плохо.
Нам джави учат. Не надо по объекту хранить.
Делайте интерфейсы. Мы сделаем
интерфейс, а и стордж
виртуальный метод будет.
Только пока не понятно какой.
Ну ладно, нас учат виртуальный
диструктор нужен.
Сейчас.
Там
сейчас все будет.
Стордж, нужно
оверрайдить.
Сейчас. Ой.
Что-то я.
Так, да.
Ну вот, там про диструктор
у кого-то были сомнения.
Вот теперь все нормально будет, да?
Потому что тут очевидно, что
своей звездочкой мы как-то ошибемся
и как вообще диструктора вызвать.
Теперь мы будем вот айс стордж.
Та же можно в юник
поинтер запихнуть.
Ну вот,
поинтер запихнуть.
Тогда все вообще довольны будут.
Да.
Только айс тордж
тоже должен быть шаблоном.
Да, тут мы наталкиваемся на проблему.
Хочется написать ред, оператор,
круглые
скобки, аркс.
А, давайте кол.
Наверное можно написать.
Шаблон не дружеский.
А, нет.
Прекрасно дружит.
Ну, поняли, что я хочу написать?
Ред и аркс хочу.
Которые вот здесь, а их здесь нету.
Шаблон засунуть.
То есть мы на момент...
Айс стордж сможет добавить туда.
Давайте просто все
впендюрем в шаблон.
И ставим.
Теперь у нас
и айс стордж приматеризован
всеми разными сигнатурами,
которые нам могут сюда припихнуть.
И сам стордж приматеризован
разными сигнатурами.
Теперь мы можем с чистой совестью
заверрадить наш метод
col
и позвать
f круглые скобочки.
Ну, тут разумные мысли, конечно,
говорят. Абсолютно.
Знаете, так-то
знаете, так тяжело,
когда привык уже писать
вместо std ea stl,
что да, не нужна.
Я прям контролирую
свои руки, потому что я очень хочу
вот так вот написать.
Но нет.
Мы пишем по-нормальному.
Ea stl.
Это замена стандартной
библиотеки от Ea, которая работает
одинаково на всех платформах.
Потому что очень некруто, когда
у тебя, казалось бы, одинаковая
дистрибуция какой-нибудь libc++
на PlayStation и инвенде работает
полностью по-разному.
Тут этот код не компилируется,
тут тот. Тут сортировки
алгоритм такой, тут секой.
И там, оказывается, перв просел.
А тут при таком паттерне
использования перв проседает, но уже
по-другому. Вот от таких проблем
многие в геймдеве просто берут
и выкидывают всю стандартную библиотеку
и используют
кастомную, самописную.
Да, в Unreal Engine
вообще не стандартная
библиотека.
Почему не хватает одного указателя
на storage? Ну, пока тут был только...
Ну, сейчас, на сам storage нельзя.
Storage же шаблонный был.
Мы же не знаем, какой тип
storage у нас.
Не знаем, не знаем.
И изначально я написал void звездочку.
Потому что, ну, раз тип
не знаем, запихнем void звездочку.
Но тогда мы не знаем
никак деструктор позвать, никак оператор
круглые скобки.
Ну, просто нет способа. Вот тут там
подсказали, что можно указатели на функции
начать сохранять. Это один путь.
Он тоже абсолютно валидный.
И даже, я бы сказал, более хороший.
Но мы выбрали пока более простой путь.
Завести интерфейс
и именно в нем
орудовать.
То есть теперь у нас есть интерфейс
в виртуальной иерархии. Там и деструктор,
и оператор вызова есть.
Вот они для конкретного
f реализованы.
То есть вот этот тут конкретный storage
он параметризован шаблонным параметром,
который говорит, что за
объект к нам пришел изначально.
Но в поле мы
сохраняем его
по указателю
на iStorage.
И в этом указателе уже
мы не помним,
какой был тип f.
Но мы все еще можем
виртуальные методы вызвать.
Соответственно, в деструкторе UnicPtr нам автоматом
вызовут виртуальный деструктор, и мы нормально
удалим вот этот объект f, каким бы он хитрым ни был.
А в операторе круглые скобки
мы можем сделать return
storage call
std forward.arx
И я утверждаю, что это в принципе все.
Ну кроме одного подвоха.
Давайте я вот здесь, чтобы подвоха
не возникло, поставлю
const ссылку.
Так.
Хорошо, не const ссылку.
Тогда точно никакого подвоха.
Код про все эти указатели
на поля и функциональные
типы, наверное, надо
вынести
отсюда нафиг.
Пусть в новом файле будет.
А.
Какую ссылку на метод, куда пихнуть?
Так, давай конкретный тест
писать.
Вот это уберем только
и вот
это уберем.
Конкретный тест.
Мы...
Ok, std vector int
vec
Мы хотим...
По-моему,
void,
std vector ссылки.
Void, std vector int
ссылка.
Yes.
Задает int.
Funcrow or
Percent, std vector
std vector int
Причем нужно конкретно ids передать.
vec.
Вот это имеет смысл.
Не, не, не. Или это без vec.
А потом function
от vec запятает.
Ну, function от vec запятает.
Ты такое хочешь?
Для этого свой, конечно же,
кастомный конструктор придется написать.
Но
я вообще не понимаю, зачем тебе
для этого function?
Ну, окей.
Сейчас я не туда смотрю. Это какая-то
помойка.
Ну, кастомный конструктор
да, придется написать. Тут будет куча
кода. Сейчас вот тут класс
red, класс
u, класс
args.
Причем не, не, не. Все, я вру.
Только u будет, да?
Мы хотим принять
red
вот такую шнягу.
Заметьте, где
пишется имя аргумента, когда вы
передаете указатель
на member function
как аргумент в другую функцию.
А при этом, если я сделаю type desk,
то все нормально становится.
Да, поэтому...
Ну, тут по-другому не особо это.
Короче, вот мы передали pointer
to member и хотим
что-то сохранить, да?
Кстати, вот это вот я бы даже
выпилил, наверное, отсюда. Там же
вывод работает. Все должно само.
Ну, знаете,
что я сделал?
Я вот так сделаю просто.
Этот pointer
to member сюда захвачу.
Да, да,
да, да, да.
Окей.
Да, все.
Да.
self pointer to member
straight,
forward.
Нет, там
был запрос, что именно
вот такая вот шняга.
Я такого... Это есть
стандартная библиотека или нет? Я не в курсе.
Вот так и return.
Ну, то есть вот.
Ну, такое можно сделать, но зачем?
Давайте проверим, что оно работает
все-таки напоследок.
Не работает, да?
Кто может понять, что не так
пошло?
Copy constructor,
off constructor.
Ой, там же еще нужно писать перегрузки на тему того, что это может быть
const, может быть
2 сутки, тогда.
Про это сейчас поговорим.
Но тут я не уверен, в чем проблема,
тут, возможно, в этом, да, или в чем?
Couldn't infer template argument
U.
U не смог вывести.
Да, вы шутите.
Возможно, проблема в
чем-то таком
дурацком. Нет, нет.
Нет, тут пока даже до дедакшн гайда,
ну, тут я указал явный тип,
дедакшн гайд не нужен.
Сейчас, может, я просто
наткнулся на most vexing pars,
нет, не угадал.
Почему?
Ну,
давайте посмотрим.
Может, там
будут проблемы,
да, указатель на member
наследуется от другого
типа, от Bayza.
Указатель на member
наследуется от Bayza.
От класса, в котором
наследуется.
Ну, да, будут проблемы, ну, какие,
я боюсь представить.
Нет, ну, в целом, вот где это мы сейчас?
Тут есть pair value,
pair value.
Блин, а у меня здесь не стоит
расширение, да?
Черт, которое.
Может, посмотрим с size,
потому что там понятно.
А, мы прямо внутри вектора, все нормально.
Да, вот тут показывают,
мы внутри вектора, это не из родителей пришло.
Ну, я не знаю.
Может, для size попробуем?
Может, на size?
Ну, давай.
Я не готовился такие вещи смотреть.
Это, конечно, забавно.
Сейчас
size только void должен...
А, ну, что-то фигня, да, сразу пошла.
Но это плохо, кстати, что у нас
компилировался код, который
я тут void написал,
а там был size t.
Давайте запустим наконец-то.
Прекратим все это безобразие.
And sign long.
Ah, constantly accept.
Ну, вот мы, короче, наткнулись на проблемы
с constantly accept.
Предлагаю пока под ковер, окей?
Вот это вот момент,
хотя или сейчас пришло уже время,
у нас 15 минут остается, да?
Давайте тогда сначала
из пушки альтернативное
решение вот этому, которое вам уже, видимо,
дома придется. А, или мы на следующем
паре продолжим
наши развлечения, мы будем писать
из стд n, но
через указатели на функции.
Ну, с той же целью, что и здесь.
Вот есть конструктор,
фу, есть
деструктор, есть какая-то функция,
которую мы стерли.
Вот на самом деле, как бы,
вот этот вот контейнер структуры
данных function, она стирает
не только операторы круглые скобки, но и
как бы две стираемых функции имеет.
Деструктор тоже.
Any это контейнер, который стирает
только одну функцию, только деструктор.
Но, в принципе,
имеет смысл
писать структуры какие-то
хранилища функцион...
функций, которые умеют стирать и какие-то
другие
функции.
Если кто-то из вас задумается
о том, как работает, например,
Rust, то что-то общее
нащупывается здесь. Если
взять
Trade и посмотреть
какие там методы упомянуты
и написать вот такой класс,
который кроме вот этой вот одной функции
call будет стирать все методы
упомянутые в Trade,
то мы, по сути, сделаем Rust на C++.
Ну, я замотивировал
у вас идеи использовать указатели на функции,
потому что вот здесь
не разгуляешься с этими виртуальными,
а с указателями на функциями
там как-то более пластично все,
а еще она работает быстрее.
В некоторых ситуациях в зависимости от того, насколько
прямо рукой вы напишете. А оговорки все
дальше будут.
Да, давайте все дальше это на следующую
пару оставим, а сейчас про консты
и экзепты.
И не только, на самом деле.
Давайте
подумаем про свойства, которые получились
из нашего класса. Нет, сначала мы запустим,
убедимся, что мы написали, а оно работает.
Тут надо вернуть, тут ничего не выводится.
DKT
Что пошло не так?
Я забыл
move, наверное.
Нет.
Пусть будет forward. Тут конечно
непонятно.
Помогите запустить код.
Почитайте ошибки вместе со мной.
Идейно здесь все хорошо. По факту
начало что-то крашиться.
Не компилироваться, в смысле.
Да я в storage не могу запихнуть F.
Ну, кстати, да, скорее всего оно
функциональный, хотя нет.
Нет, это для...
Так, структура,
в ней поле типа F.
Надо снять референс.
Надо.
А даже
вот так надо.
Окей.
Ничего не получилось.
Ничего не получилось.
По ходу, да.
F
все.
Тогда
можно иди.
Кажется, так надо,
чтобы у нас ничего не сломалось.
Сейчас это вообще нужно указывать
F.
Ну да, правильно.
То, что надо вот так.
Нет, стоп.
Кто помнит, как
его сделать полиморфным?
Кто не помнит, да?
Но он пытается вызвать
деструктор никак,
но не полиморфный, короче.
Давайте.
Это конструктор.
Нет оператора присваивания,
ни муба, ни копирования, ничего,
нету, все.
Деструктор.
Делит.
Так, что не так?
Потому что
наследник вызывает
еще деструктора
и не теряет.
Какая-то интерфейс.
Это классический ход
у Qwitch
с трактами.
Но зачем Qwitch делать,
чтобы
все работает
должно?
Обожаю C++.
В прошлом году тот же код писался и работал
с первого раза, а тут началось.
Что?
Я подозреваю,
что от того, что я вот здесь пишу,
вероятно не virtual.
Должно, но я
не верю.
Ладно.
Я вот так даже сделал.
Да, родительский.
Я просто поражен тем,
что происходит, если мы словили баг компилятора,
то это...
Это прекрасно.
Ну так заработает, я не знаю.
Ну я не знаю,
я, честно, такой же код в прошлый раз.
А можно сделать
это out-of-line
дефиницию Qwitch-деструктора.
Ну, смотри,
написать равно 0 и дальше прямо под ним...
А дальше все такие пальмы обычно...
Да нет, прямо под ним можно просто
i-storage и до i-storage
и сказать, что ничего не делает.
Можно попробовать.
Здесь 0,
затем...
У меня так не работает, да?
Нет, ну я предлагаю out-of-line
вот дефинировать, просто прям
дефинировать. Ну как его можно делать?
Ладно.
Что, чтобы так?
Да, и тут
его просто
не только virtual, наверное, выбрать.
И здесь не равно 0.
Я фигурую с помычки.
Вместо 1 0.
Ну, мы внутри
другого класса, напоминаю, находимся,
от этого, возможно, у нас все ломается.
Тут как?
Ну, короче, ничего не выйдет, все.
Мы как-то заставили работать.
Тут все ужасно, да.
Так, что произошло?
Все зарешилось.
Почему все зарешилось?
О, смотрите, hello, hello.
Что-то написало.
Я предполагаю, что это значит, что
все работает.
То есть что мы...
HelloFromStruct и hello
1 раз про этот.
А helloFromStruct, вот он
здесь.
А вот здесь мы 2 раза вызываем f,
да?
Но там вот этот вот костылек, который
запоминает, что там нас 1 раз вызвали
или 2.
Все работает, ура.
То есть типа function, сверх легко
написать в минимальном виде.
Но нас не устраивает.
Раз по перву,
а два, такой смешной
вопрос.
Если вот этот
оператор const, внимание,
важный вопрос решается,
важнейший.
Если оператор круглой скобки был const
object,
хотим ли мы...
Ну, и
наоборот, если он был не
const, вот такой, да,
хотим ли мы позволять
запускать
по const ссылке?
Вот даже если
так написать, то уже у нас
вот этот оператор круглой скобки, он не
const.
Ну,
какая-то
несогласованность вы чувствуете?
Вот здесь оператор может быть const,
а может быть не const. И это часть
сигнатуры. А вот здесь
у нас он всегда просто вот такой.
Либо const,
либо не const.
Фигня, да?
Это, наверное, pointer to number type
или
что у const
владеется тип класса, наверное,
t, а const...
Ну, сейчас правильный ответ-то скажу.
Я просто хочу
void.int
хочу вас
обрадовать, что это баг в стандартной
библиотеке.
Вернее, в ее дизайне.
Так.
Bad.
Bad инициализируем
functional object.
И
сделаем
const ссылку.
Very bad.
Так, внимание, так не работает.
Что?
Да.
Вот, все так работает.
Видите нарушение
const-корректности?
Примерно поэтому, да.
Нет, вот эта вот фигня хранит состояние
в себе.
Вот точно так же,
как functional object. Вот он внутри себя
какое-то состояние мог хранить.
И вот эта функция, она не const, она могла
модифицировать это состояние.
Ну окей, нам с неба свалилась
вот эта вот ссылка, very bad.
const ссылка, да.
И мы вызываем в нее оператора круглой
скобки, который const.
Вот он const же, да.
Но мы верим, значит, что он не будет модифицировать
состояние, а он его модифицирует.
Полное нарушение
const-корректности.
Правильный fix.
Явно в сигнатуру
прописывать const или не const.
Вот стандартная
улучшен не умеет так.
Просто не догадались.
Да, может быть возникнет
вопрос, да, что вот это такое?
Ну вы же знаете, как мы в конце
методов можем писать const
или ampersand, или twampersand,
или volatile.
Все же это знают.
Что?
Да, но это abus.
Потому что оказывается
в системе типов языка C++
вот это вот const можно дописать
к любому типу функции.
То есть нельзя написать глобальную функцию,
которая const.
Но вот это слово const справа дописать
можно к любому типу функции.
Я говорю, как к любому типу?
Потому что int const есть, да?
Да, вот
раз есть int,
есть int const.
Но у нас есть вот
void от int тогда, да?
Почему не должно быть void от int const?
Ну как бы на самом деле нет.
Потому что вот это вот это не то же самое,
что и...
Ну вот так можно.
Примите это как данность.
И хак заключается в том, чтобы
повторять в операторе круглая скобка
нашего вот этого вот
функциона,
повторять
все, что написали вот здесь.
То есть должны быть отдельные специализации
для const, для noexcept,
для volatile
noexcept,
const, ну вы поняли, да?
Вопрос, как это написать нормально,
на него пока ответа не дается.
Но идейно...
Аркс при чем тут?
Это не типа, это квалифаеры
в конце
метода.
На нашем методе оператор круглая
скобочка, мы в конец можем написать const.
Что это значит? This, константный.
Можем написать noexcept.
Это значит, что метод не кидает
исключения.
Вот давайте добьем.
Вы поняли, о чем речь идет, правда, товарищи?
Может быть
может быть
функция noexcept.
Да.
Вот const и volatile относятся
к типу this.
Вот volatile const, это this.
Ну, ему не нравится
что-то, да, тут?
А, потому что сначала надо вот это вот,
а потом noexcept. То есть вот это
относится к типу this.
А вот это относится ко всему
функции.
И вот это говорит, что this должен быть
const, вернее будет const, это
говорит, что this будет volatile, а это говорит,
что я не буду кидать исключения.
Вот все эти три штуки и все возможные их
комбинации, их невозможно
знать наперед. Невозможно
угадать, какую пользователь хочет поведение.
Чтобы эта функция можно
была константная или там
не константная, но exeptная или нет.
Наперед неизвестно. Поэтому, поэтому
хороший, правильный дизайн
функционального контейнера
вот такой, что он умеет парсить
вот эти вот const и noexcept, которые
ему передали внутрь
и ставить их на свой
оператор круглые скобки.
Вот.
Значит, где такой хороший контейнер
найти?
Function2.
Вот, если вам с конкарнсом было интересно,
почему нам он так нравится и почему мы его
используем, это одна из причин.
Вот, можете почитать, там круто.
Про
про-про-про-про-про
последний пункт.
Смешную вещь.
Давайте запихнем в
этот
UniquePtr.
Мы неправильно, мы вообще ее не описывали.
Я про STD Function.
Смотрите, что нам скажут.
Нельзя
инициализировать STD Function.
Почему?
Мы пытались копировать
UniquePtr.
Сейчас бы правильную ошибку
еще словить.
Почему IGNORED?
Не говорят нам
даже, да?
Но видите, как нас ненавидит STD Function?
Она даже не объясняет, что не так пошло.
Короче,
если открыть
preference, то мы узнаем гораздо быстрее.
STD Function
Any Copy
Constructible Callable Target.
STD Function
требует, чтобы вашу лямду можно было
не копировать.
Потому что фигово
написано.
Но на самом деле утверждается, что невозможно
написать идеальный Function.
Это просто бредовый дизайн в целом.
Вот вы не знаете
ничего про свой тип F, который
сюда впихивается.
Про вот эту вот лямду или функциональный объект.
Вы не знаете какой там оператор круглой
скобки.
Не знаете.
Так с чего бы вы могли знать, какой он будет
копированный или некопируемый.
Все эти данные вам неизвестны.
На момент создания
самого STD Function.
Вот. И это и есть
правильный ответ. Нужен
Move Only Function
отдельно. И отдельно
Copyable Function.
Это единственный
способ разрешить эту проблему.
И вот тогда будет хорошо.
Но
Как видите, проблему обнаружили
только спустя сколько лет
STD Function
в 11 C++ добавили.
А Move Only Function
в 23.
Типа 12 лет понадобилось, чтобы обнаружить,
что наложали и сделали штуку, которая
в некоторых случаях работает.
Но как только что-то нетривиальное происходит,
сразу выкидывается на помойку и заменяется
какой-нибудь библиотекой сторонней
или своей костыльной имплементацией.
Вот. Move Only Function
как можно догадаться
из названия, лямбда, передающаяся
туда, не обязана копироваться.
И тогда сама вот эта
функция будет только муваться.
И есть
STD Copyable
Function.
Которую в 26-ые плюсы одобрили,
но еще на ЦП референс не добавили.
Вот.
Ну Copyable Function это аналог STD Function,
но который правильно консткорректность
учитывает, да, потому что
вот так можно короче делать,
оно правильно работает. В этом
Move Only Function это тоже учли.
Вот. И вот это вот,
мне кажется, квинтэссенция вообще разговоров
о том, как должны выглядеть
вот эти обертки над функциональными
объектами, стирающие типы. Вот это вот
хороший дизайн, к нему вопросов
нет. К STD Function есть,
а то, что мы написали, это вот просто
жалкое подобие STD Function, которое
а, медленное, b, ну вот все вот эти
проблемы в нем есть.
Так что в следующий раз будем либо
эти проблемы решать, либо ускорять,
либо еще что-нибудь,
может STDE не напишем.
В общем, посмотрим. На сегодня
все.
