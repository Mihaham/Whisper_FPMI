Крошечной пути из одной вершины до всех остальных закончен, перейдем к следующей.
Крошечной пути между всеми парами рушен.
Продолжаем на этой крошечной пути, но задача у нас теперь немного поменяет.
В самом деле, сильно поменяет.
В смысле, что у нас получается рисовать не в крошечной пути,
а в крошечной пути из конкретной вершины до всех остальных.
Она теперь будет интересировать следующую задачу.
Вот нам дан граф, и нам нужно посчитать крошечное расстояние между любой паровершин.
Между всеми паровершин нам нужно все узнать.
Это неважно, либо проще состояние, либо именно пути сами.
Что и друго говоря, значит, теперь надо отнастанно додать схема расстояния по всему расстоянию.
А матрица расстояния, здесь на единический жильник, будет пройдется крошечное расстояние между крошечными вершинами.
Вот, соответственно, пример.
Вот где нужна структура графа, то есть здесь.
Я хочу быть морейкой крошечной вершины 1 и 3.
То есть, крошечная вершина 1 и вершина 3.
И идет вот так, 1 и 2.
Да, крошечная вершина 1 и 3.
Ну, собственно, это ребро 2.
Ну, и наоборот, да, если крошечная вершина 1 и вершина 3,
идет пути размера 3.
Вот такой.
Раз, два, и один.
Понятно.
То есть, вообще говоря, матрица не обязательно симметрична,
потому что миограмма будет ориентирована.
Да, и понятно дело, что путь из стройки в единицу
и из нити стройки, это два раза путь.
Ну, потом, давайте, понятно, да?
Вот. Ну, тут будем предполагать,
тут будем предполагать, чтобы путь
ребра касательно веса.
То есть, не будем делать отдельного
расположения жима
для того, что у нас ребра,
для этого не обязательно.
Ну, давайте, посмотрим.
На что в этом случае можно было петь.
Ну, смотрите, давайте начнем с самого простого способа.
Это, что не любит путь.
А, ничего не любит путь.
То есть, вдруг, говоря, мы на прошлом планете,
мы на прошлом планете и так заправим два алгоритма,
алгоритм DX и алгоритм Фордобелла,
который умеет строить крошечные пути
и за мной вершина до всех кстан.
Давайте просто возьмем эти алгоритмы, чтобы мы примерили
вот эту задачу, по алгоритму поиска
крошечных состояний,
и мы будем делать пей для любой пары.
Ну, давайте, я один пик, чтобы его
пополнять.
Сейчас.
Здесь такая схватка.
То есть, мы рассматриваем два спута.
Первый, когда у нас ребра могут быть отрицательные,
и в случае, когда у нас ребра
отрицательная, а не отрицательная.
Ну, соответственно, у нас есть в случае,
когда у нас, конечно, нет каких-то порядковых,
то есть, разумеется, как
у нас есть в случае, когда у нас
ребра отрицательные,
то есть, конечно, нет каких-то порядковых,
то есть, конечно, нет каких-то порядковых,
то есть, конечно, нет каких-то порядковых,
то есть, конечно, нет каких-то порядковых,
то есть, конечно, нет каких-то порядковых,
то есть, конечно, нет каких-то порядковых,
то есть, конечно, нет каких-то порядковых,
то есть, конечно, нет каких-то порядковых,
Какой план?
Давайте запустим от каждой вершины
и, соответственно, просто нам запустим от каждой вершины.
Понятно дело, что в этом случае
мы найдем следующий путь
под любой вершиной до любой другой вершины.
Затом, когда у нас ребра будут отрицательные,
а нужно листья квадрата отрицать?
Наслаждай квадрат, да?
Потому что, если у тебя до сих пор был
В умножить на Е, а вот, соответственно,
если нет порядка отрицательных, соответственно,
вы квадрат. А если, например,
у тебя будет один, то в долгом случае
это чекс.
А на дельфине, что оно стоит?
Если есть перцатный цикл в поле.
Да, найдешь на перцатом циклу.
В принципе, если перцатый цикл ребра,
то цикло. Здесь, понимаете,
на вот перцатом циклу у меня есть перцатый
жутко-девачий.
Перцатый на ребре, например, не имеет смысла
пронолыть. Ну и, по этому случаю,
если у меня короткий ребр, понятно, это одна,
а цветочный, соответственно, будет четвертый цикл.
То есть, может, у меня летает
два короткого грамма.
Продолжу с абсолютно так же.
Третий, четвертый, четвертый.
Третий, четвертый, четвертый, четвертый.
Ну, а дельфина. Если у меня игрок на трешке,
то...
В?
Б?
Вот.
Если у меня игрок на трешке,
мы используем реализацию
на пиратике. Соответственно, реализацию
на пиратике это YOLOV.
Если я проясню это YOLOV,
соответственно, если мы дельфины еще дополнительные
частями завершили, то YOLOV2.
Ну а в случае, если у нас короткий,
сколько?
В? Почему?
Если
не написано, то что?
Да, мы реализуем
дельфин на массиве.
Дельфин на массиве это
YOLOV2,
ну и еще YOLOV2.
Соответственно, если YOLOV2,
значит...
И вот только с этого мы и начинаем.
С этого вот оказания.
То есть мы уже умеем решать,
здесь мы умеем решать YOLOV2,
здесь мы умеем решать YOLOV4,
здесь мы умеем YOLOV2, здесь YOLOV2.
Ну что ж, давайте посмотрим
суть этого и
четвертее, если
можно улучшить.
Давайте
начнем собираться.
Начнем с алгоритма
Лойда Уоршула.
Начнем с алгоритма Лойда Уоршула.
Значит,
идем к следующему подтверждению.
Алгоритм Лойда Уоршула
это динамический алгоритм.
Будем решать динамическое
программирование,
постепенно решая все более
большие подзадачи.
Какие у нас будут подзадачи?
Пусть D, A,
в сыгре это кратчевое
предстояние от укса до игрока
вдоль пути, в котором в каждом
предпочтении можно использовать
вершину с номерами шикта.
Что такое декабристый?
Декабристый — это кратчевое
предстояние от укса до игрока,
в котором в качестве промежуточного
включения я могу сложить только
вершину с номерами 0, 1, 2, 3,
и так далее, кажется, нет.
То есть не весь граф, а вот только
первый вершин.
Если для Чмура D2 — 4 и 1,
а для D2 значи هедичный
прочежende хрути,
то dictionary
может penisaleх tysчilik tracks
иדainted для хрути largest number
и aging.
Поэтому, соответственно, равно бесконечности.
Теперь давайте я порешу использовать
а не только вершину 0 и 1, но еще и вершину 2.
В этом случае у меня появляется эта вершина.
Я еще раз упомяну, но я порешу использовать вершину.
То есть появляется вершина 0 и 1.
Даже я теперь продолжаю добавить еще одну вершину.
То есть я продолжаю использовать вершину 0, а вершину 1.
То есть теперь пришла вершина 0 и 1.
Ну и поняли, что можно устроить более простой путь.
Вот такой, в программе.
Все понятно, да?
Ну и только на все, что мы делали в программе.
Делали в программе в том, что у меня есть какие-то подзадачи.
И вот на основе этих подзадач я должен научиться решать
какие-то большие задачи.
В частности, я должен вспомнить шматок CD2,
я должен вспомнить шматок CD3,
я должен вспомнить шматок CD4, и так далее.
Давайте разбираться, как мы будем делать.
Ну, мы будем разбираться на яхту.
Первый простой вопрос.
Собственно, чему равно...
Как называется?
База динамитов.
В общем, все мы узнаем.
Когда я так что-то делаю, я не могу условно людей решать.
Смором, я как-то матки сделаю.
Да, можно сфотографить смартфон, согласен?
Почему? Потому что...
Если это бронежитечные вершины,
то это значит, что любой путь,
любой эксирик, путь,
который я динамитовал,
это просто абсцентрация.
Приброй.
Приброй.
Пульти, которые прячут эту вершину, ничего не входит.
Понятно?
Начальник матрицы.
Идем дальше.
А эту переходу
в следующем видео.
Вот тут у меня идентифицированная матрица.
1,5,0,0,0.
Я как-то все поспорю в течение
1,5,0,0,0.
Ну и где?
Вопрос, который написан на слайд.
Чему работают эти значения?
Ежели не известны,
то большинство пультики с эксириками,
которые проходят по всему дюжинам,
не пропустят эту вершину как?
Вот допустим, вот мне один это известный,
когда они просят вот эту штуку для мне зверя,
то есть вот тут на M&G
вершины на M&G не встречаются.
Почему тогда M&G?
Ну нет,
там минимум,
там минимум,
там минимум,
там минимум,
там минимум,
👍
its power...
Согласны?
Потому что вот это пультино
то он точно сразу налетает в секрет. В этом случае мы точно знаем, как найти следующее.
Ну и второе круче. Обратно. Ну, если я перелезу к нему, то сразу...
А. В этом случае А. И в случае В обратно.
Что если у меня вершина K гарантированно принадлежит этой пути? То есть мне откуда-то известно,
что хранящиеся языксовые, которые проходят по всем вершинам самерами с 1,
обязательно проходят через вершину K. Почему тогда раздают предыдущий путь вот такой?
Да, смотрите, давайте...
Это не верно, что путь...
Есть вершина X, есть вершина Y. И есть ответ на путь.
Я просто на вершину Y на пути встречаю смыта.
Что мне нужно сделать?
Вот это? То есть в этом состоянии понимаешь, что это обстоятельство? Согласен?
А что я могу делать в этом состоянии?
Понятно? То есть вот тут гарантированно не встречается вершина K.
Но мне не смысл делать вот этот путь.
Плюс...
Да, пусть будет так...
Ну вот.
То есть у меня либо этот путь проходит через вершину K, либо он не проходит через вершину K.
То есть в первом случае я получаю вот эту ситуацию, а в втором есть вот эту ситуацию.
Да.
Так вот, как раз в этом суть. Если он не проходит, то соответственно вот этот путь.
Если он проходит через вот этот путь.
Но мы действительно не знаем, а проходит он или нет. Что делать?
Ну просто взять вершину K. Согласен?
То есть чему равен?
Мы не видим людей, которые не влечи.
Мы рассматриваем не имеющий путь, который не проходит через K.
И не имеющий путь, который проходит через K.
И среди них рассматриваем минимальный путь.
Все.
Ну вот.
То есть минимальный путь, который не проходит через K.
И минимальный путь, который проходит через K.
Все.
Вот формула пересета.
Вот собственно формула пересета в эксплуате на K.
Ну по сути все.
Осталось просто забраться.
Вот он и я.
Значит у нас есть примерный массив.
Ну по нулевой поэксплуатации мы соответственно
в первой поэксплуатации мы сохраним вот этот верхний индекс.
По второй поэксплуатации мы сохранимся с начала.
То есть изначально у нас нулевая поэксплуатация.
Просто складывается, работает все предыдущим.
Ну и дальше просто тянутся туда.
Пока мы перебираем все возможные массы.
Все поляки тростания.
Мы даже просто заполняем все элементы.
Как в первой массе.
Перебираем как в первой массе.
И соответственно сделаем.
То есть это ассирик, минимум ассирик.
И декат амиссатор, и декат аминь.
Все.
Окей?
Отличное замечание.
Так.
Вот это, например, сложность вот этой реализации.
Сложность, это в Америке, не таково.
Понятное дело.
Вот районный цикл.
И на каждый районный цикл мы делаем плотную единицу интеграции.
Ну и парик.
Важно замечать.
Я просто понимаю, что меняется положение цикла вот так.
Нельзя.
Потому что для каждого цикла мы почищаем всю материю.
Мы почищаем всю материю целиком.
То есть нельзя.
Для каждого цикла мы почищаем всю материю.
Значение материи цикла.
Ну и декат аминь.
То есть у меня просчет материи цикла.
Просто у меня все элементы материи цикла уже обучены.
Окей?
И цикл обменяем, и цикл обменяем.
То есть отличное замечание получалось в первый раз.
Так.
Так, версия 2.0.
Ну смотрите, опять говоря, зачем нам хранить все в охордном адресе?
Ну смотрите, мне на каждый раз нужна текущая материя, которая есть в шаге.
Да.
То есть предыдущая материя и текущая, которая есть в шаге.
Да, на самом деле хранить 2 материи в шаге.
Ну 2 материи в шаге.
Ну нет, 2 материи в пусто.
Материю с предыдущим шагом.
Декат.
И материю с предыдущим шагом.
Каппус 1.
Вот.
Собственно.
Вот, значит хранить материю.
Сидел полуто в ревью.
Вот, изначально мы фиксилизируем материю со всего сфермера.
Вот, и да.
На кафе локал выключил ревью с 1.
Свапаем старую материю.
То есть теперь у нас новая материя, которая прожила новую, стала старой.
С новой материей мы теперь перезаписываем 2.
Ну вот.
То есть теперь мы храним 2 материи.
Теперь храним всего 2 материи.
И есть возможность уменьшить, может запарить, уменьшить полугодатную.
Нормально?
Да.
Ну а может на самом деле еще сильнее улучшиться.
На самом деле можно даже 2 материи.
На экране есть всего лишь 1 материю.
Я же не переносил.
Вот.
Смотрите.
Тут в экране, где я делал тигер,
вот этот тигит.
Это означает, что в данной игре
не приносит каких-то дополнительных
поделений памяти.
В том смысле, что если у вас есть
на руках матрица весов,
то вы можете просто матрицу весов обновлять.
То есть работа угрея inplace.
Понятно?
То есть это inplace-магерей.
Но если на самом деле можно сочинить материю,
посчитать, вот это вывлечение
все по материи.
Понятно?
То есть можно не разделять.
Старую материю, вторую материю обрать.
Диэс и игреки подсчитывают минимум без Диэс и игреки.
Диэс да, плюс Диэс и игреки.
Вот. Отличный опор.
Почему опор?
То есть, вроде, как вы сказали знаки,
вот так вы увидите.
Давайте перепишем.
Отсчитываем.
Вот, есть материя к ДК плюс один.
И ее элементы циклеры.
Ну, подсчитываем.
Подсчитываем.
К ДК циклеры.
И...
К ДК скат.
Плюс ДК.
Позже.
Вот.
То есть у нас получается такая формула.
Но если мы подсчитываем матрицу ДК плюс один,
на основе матрицы ДК плюс один,
то вы понимаете, что мы, вроде как, заглядываем в будущее.
Вот. И выстекает интересный вопрос.
А не приведет ли это к чему-то плохому?
В общем, ответ заключается в том, что нет, не приведет.
Давайте рассуждать, почему.
Ну, смотрите.
Смотрите.
В чем может быть проблема?
Проблема может быть здесь.
То есть, что? Вот представьте.
Не ДК.
А ДК плюс один.
ДК плюс один.
Проблема.
У меня все нормально расстояние.
У меня было 30 к.
Почему?
Нет, это минимальное расстояние в 30 к.
Тем качеством, что я могу использовать вот эту вершину.
0 и 1, 2, так и так.
То есть это не прямо минимальное расстояние.
Потому что на минимальном пути
могут содержаться вершины.
Что? Вот, смотрите, естественно, что тут на фейсбук подают, а что там, опять-таки, из вершины x, но это вершина k,
то, что работает во всех вершинах, оно должно быть между правым и фейсбуком k.
Вопрос. А может быть, у тебя есть вершина k? Почему?
Что?
Завершили.
Ну, тут другое прикол в том, что если у нас есть вершина k, то это значит, что работает.
Почему у нас такой путь оказался лучше, чем общий путь вот такой?
Значит, это отрицатель концепции. Согласны?
А когда у нас есть отрицатель концепции, то задачу в принципе некорректно поставлено.
Поэтому понятно, что я не сказал, что у нас есть отрицатель концепции, но мы предполагаем, что отрицатель концепции нет, окей?
То есть отрицатель не вероятно есть, но отрицатель концепции нет.
Так как у нас нет отрицатель концепции, то такого в принципе не может быть.
Потому что иначе это было бы отрицатель концепции.
Все. Дальше пять минут ухмель.
Вот это конкурсик.
Держи на камеру.
Мой отрицатель концепции.
Вот так.
То есть на самом деле, вот тут я никогда не загадываю будущее.
Вот тут, в качестве первого слога, я всегда использую перечну, которая почитана на предыдущем шаге. Понятно?
Ну и то же самое можно создать и, как вы понимаете, в другом вопросе.
Понятно?
То есть на самом деле, даже если вы состояние новой матрицы,
числяя это по состоянию этой матрицы, то ничего плохого не произойдет,
потому что состояние новой матрицы в точке xk точно совпадает с состоянием старой матрицы в точке xk. Понятно?
Нормально?
Все понятно.
Полностью корректируем.
Так, ну как можно, собственно, вот и проще.
Пояснение.
Ну и давайте наконец-то обсудим, что делается с отрицательными циклами.
Мы тут сделали естественное предположение, что цикла в отрицательном весе нет,
поэтому, соответственно, все веса, все расстояния и так далее вычисляют скорейки.
Но понятное дело, что на практике это не всегда так.
Попадают циклы, в которых есть отрицательные циклы, и вообще говоря, непонятно, что делать.
Давайте хотя бы как минимум научимся определять, есть ли у нас в графе цикла отрицательный вес или нет,
но, собственно, достижим ли отрицательный цикл из вершины и недостижим, это уже обсудительный семинар.
В общем, давайте попробуем понять, как в алгоритме Порда-Белмана.
В алгоритме Порда-Белмана же тоже плохо работает, в случае, у нас есть отрицательные циклы.
При этом Порда-Белмана позволяет детектировать эти самые отрицательные циклы.
Но, собственно, вопрос, а может алгоритм Флойда тоже сам понимать, что он нашел отрицательные цифры?
И с таким образом сообщить, что на самом деле то, что он нашел, это некорректно.
Ну, вопрос вам на самом деле.
Понимаете ли вы, как в алгоритме Флойда, допустим, он обработал алгоритм Флойда,
вот как глядя на матрицу понять, а вот в моем графе, что где отрицательные циклы?
Что осталось, если dx здесь?
Отлично.
Да, Флойда, у нас обработал герметит. Давайте посмотрим, находим dx.
Что такое dx? По смыслу.
Да, по смыслу dx это просто состояние x вершины x вершины x.
Молчанию изначально он равен нулю.
А что происходит, если у меня x лежит на отрицательном цикле?
Да, в этом случае у меня найдется отрицательный путь из x и x,
который будет лучше, чем оставаться на месте.
Если мне лучше не оставаться на месте, а двигаться по какому-то пути к себе,
то это означает, что у меня есть отрицательный цикл.
Поэтому, собственно, председания отрицательного цикла сводятся просто потому, что мы и в конце.
Если диагонально встретим ассоциативное отрицательное значение,
то в индексовом ферме у нас есть отрицательный цикл.
Все, понятно?
Существует колодак флойд и лошадь тоже умеет определять и анализировать
наличие или отсутствие цикла отрицательного веса.
Ну и давайте заполним эту таблицу.
У нас теперь появится колдак флойда.
Флойда.
Значит, за сколько он работает?
Ну, наверное, работает в зимой и лет.
Прижимаем таблицу.
То есть мы просто на ассоциативном отрицательном циклу проходим по количеству трассы равномерно.
И мы даже исполняем матрису равномерного квадрата.
Ну, естественно.
Поучили руку.
Поучили руку.
Руку.
Смотри, нужно было улучшить.
Ну, как?
Флойд ничего не улучшил.
А лошадь?
Флойд?
А симпозицию-то улучшил.
Учились девятьдесят подвесно.
Да?
Получил куба, можно, но в случае нет церкви.
Нужно вопрос.
Да.
А почему не включили отрицательного цикла?
Конечно.
Стоп.
Нет, я тебе говорю, что он работает некорректно,
потому что, смотрите, при задаче определения, короче, путей,
в случае налития отрицательного цикла с этого места, они корректно ставят.
Поэтому, что найдет цикл, что найдет Флойда после своей работы, в принципе, непонятно.
Потому что с такого понятия, некорректнейший путь, в случае наличия цикла отрицательного места, нет.
Но что можно вычислять, это то, что Флойд находит какие-то пути.
Вот какие-то пути он находит.
Соответственно, если мы находим в пути, решим, на самом, себя, отрицательного места,
то цикл отрицательного места есть и значит, что мы не можем в целом доверять этому циклу.
На самом деле, это не всем правда.
Потому что, если у нас в графе есть цикл отрицательного места, ну, то есть,
представьте это при стволу. У меня есть цикл отрицательного места.
Понятное дело, что если у меня есть путь, который проходит через этот цикл,
то соответственно, расстояние отрицата эрита у меня на этих корректных.
Но представьте, что у меня есть путь. Точнее, что у меня есть диагональный Z.
Любой путь между 0 и z никогда не задевается от отрицательных сил.
Вот на данный случай я могу гарантировать, что путь между 0 и z не на этом тарелке.
Но вот, собственно, она и есть.
Слева может быть пара их сил, между которыми можно отрицать отрицательные силы.
По-моему, задача должна быть такая.
Ну, на себя как-то так.
Вот.
Еще вопрос.
Нормально?
Ну да, собственно.
Продолжительный путь такой, что, вообще говоря, путь почти везде у нас.
Ну, как бы я не укушил азотовку, да?
По-моему, где угодно.
То есть, единственное место, где мы все это делали,
доверяясь классическому интервейсу, это вот здесь.
Но скоро мы это исправим.
Ну, точнее, не здесь, а вот здесь.
Значит, поговорим про...
Смотрите, вообще говоря, мы рисовали эту таблицу.
Вот эту.
Что мы видим?
В принципе, что DXR, вообще говоря, не так плохо.
Потому что, смотри, всего у меня пара вершин сколько-то.
Всего у меня вершин порядка от квадрата.
И, соответственно, по сути, что вот эта формула означает?
Формула означает, что в среднем, на каждую пару вершин,
чтобы найти кратчейший путь между пары вершин,
я трачу примерно логаритм времени.
Логаритм 30 вершин.
Но кажется, что это не так много, учитывая, что у меня путь.
Что на пути может быть равна, собственно...
Ну, как я говорю, на пути может быть равна r.
И, вообще говоря, хотелось бы, наверное...
Хотелось бы добиться того, чтобы DXR был настолько же эффективен,
и в случае, когда у меня есть вершины отрицательного веса.
Что проблема в том, что DXR к таким графам не применит.
Да?
А очень бы хотелось.
Поэтому идея следующая.
Ну, смотрите, давайте...
Если у нас в графе 10 отрицательные ребра,
так, может быть, просто взять и от этих отрицательных ребров разбавиться.
Как?
Что?
Вот, да.
Это, соответственно, первая идея.
Действительно.
Смотрите, у меня есть граф.
Я возьму этот отрицательный ребр.
Давайте я просто возьму этот граф
и преобразую его, соответственно, в граф,
в котором этих отрицательных ребров не будет.
И, собственно, самая первая идея,
это давайте просто, действительно,
просто прибавим ко всем ребрам какое-то определенное значение.
Да?
Ну, такого, которое гарантированно все ребра выведет.
Ну, я думаю, что это будет очень интересно.
Ну, я думаю, что это будет очень интересно.
Ну, такого, которое гарантированно все ребра выведет,
все ребра выведет, да, не отрицательно, я думаю, что это будет очень интересно.
Но этот путь справа.
Почему?
Ну, давайте просто будем справляться.
Вот у меня есть граф 5, пишем вот это.
Вот.
Есть, значит, путь, который проходит на ребра 2.1,
есть путь, который проходит на ребра 2.3.
Давайте, для избава, вот, брать этот отрицательный ребр
и ко всем ребрам, таковый унесемся.
Что у меня получится?
Три, два, ноль и четыре.
И хопа.
Теперь в этом графе у меня конечно же путь.
Хотя на самом деле в условном графе.
Понятно.
В чем проблема?
Проблема в том, что вы добавляете одно и то же значение, как с самым ребром,
это преобразование неэнвариантно относительно реберной длины пути.
То есть, почему вот этот путь стал длиннее, чем вот этот?
А может, тут тупые ребра больше, согласны?
Вот на этом пяти тупые ребра больше, поэтому, соответственно,
в этом пути я добавил больше, чем у них длинные пути.
Для каждой пары машин, чтобы понять, насколько они четыре,
я добавлю с одной машинкой другой,
мне нужно найти кратчайшие пути.
А я хочу решить заходить кратчайших путей
с помощью лейпу, который немного привлекает.
А может быть, просто предвестить,
у меня есть с того ребра два,
может, я же на лучшей степени справлюсь.
То есть, как-то не свежий, не зря, как-то сфейли.
Ну, смотрите, идея в том,
что я хочу, чтобы у меня сумма,
то есть, отчет, длина каждой части осталась в пункте,
ну, это немного утопит.
Понимаете, почему?
Потому что, если у меня есть вот такой граф,
то в таком графе я чисто теперь не смогу сохранить длинные путей.
Потому что какие-то пути могут быть отрицательные.
Если я избавлю отрицательных ребр,
то тогда мнение у нас сохранит длину пути.
Понятно?
Поэтому давайте поступим по-другому.
Давайте сделаем так.
Мы будем сохранять длинные путей.
Но намажем на самом деле длинные путей.
Намажем сохранить их относительные взаимосвязи.
То есть, мы хотим, что если путь раньше был самым длинным,
то он бы остался самым длинным.
Если путь раньше был самым коротким,
то мы хотим, чтобы он остался самым коротким и так далее.
Понятно?
Короче говоря, нам бы было хорошо от того,
если бы все пути от СЗД,
все пути, проходящие все вопросы от СЗД,
если бы все они изменились на одну,
то нам было бы много, согласны?
Вот.
А тут столько физиков.
А знаете, почему из физики прибыть кое-что?
Потенциал.
Вот.
То есть, когда дарите то пути,
по которому мы двигались,
а зависит только, собственно,
от того положения, что это такое или не то.
Медпотенциал.
Где как раз такие физики?
Медпотенциал.
Так, собственно, обсудим ее.
Значит, идея такая.
Давайте просто обсудим,
что это такое медпотенциал.
Функция, что представляет
гипшины и киточечники.
То есть, просто произвольная функция.
Произвольная функция D.
То есть, каждой гипшине
поставим соответственно гипшину D.
И отбить.
И отбить.
И отбить.
Пока давайте не будем там
абсолютно произвольной функции.
Пока не важно.
То есть, пока просто обсудим
каким свойствам тогда будет
обладан наш грант.
И соответственно,
соответственно,
специальными функциями потенциала,
откуда-то взят,
произвольные,
обретеним новый весовик.
Скажем, что
новый вес гипра
вот здесь, да или нет,
это есть вес самого гипра
плюс пятый.
Плюс рамка потенциала.
Окей?
Просто вели какую-то функцию потенциала
и обновили веса ребра по такой функции.
Обновили веса ребра по такой функции.
Нормально?
Теперь давайте обсудим свойства.
Первое свойство.
Возьмем произвольный путь
из В.
Здесь гипшина В.
Разморим произвольный путь.
Вот вот абсолютно произвольный путь
из гипшины В, гипшины В.
На какую величину он отменится?
Зависит ли величина,
как он отменится этот путь?
От конкретной ключи.
Зависит ли он от конкретной ключи?
Нет, почему?
Там нужно смотреть.
Давайте просто обновим какой-нибудь путь
из гипшины В, гипшины В.
И собственно просто суммируем.
И секрет.
Вообще не секрет.
40 гипшины В.
Давайте так.
В.
В.
То есть этот путь состоит из гипшин В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
Все промежутки так отращаются.
Ну и так далее. И оставите только фиод v1, то есть старая вершина, да, это вершина v, и конечная вершина, это вершина v.
То есть новый пеноплучить, новый пеноплучить, между любыми v и v.
Новый пеноплучить.
Эта старая
плюс, а v не успели.
И это, наверное, абсолютно для произволнования согласия.
То есть, похоже, мы добились того, что мы хотели.
Мы не открыли какую-то функцию панциала.
Ну, понятно, что у нас длинные пути изменились.
Но при этом, допустим, как у паники машины, то в каком пути я не прошел, у меня все эти пути изменились сразу на всю эту вершину.
Собственно, чистую вершину пенопла.
Изменение этой пути зависит только от значения данечной точки.
От самой первой пути, и так далее, это вообще никак не зависит.
То есть, не важно, как содержит этот пеноплучитель, как содержит этот пеноплучитель, и так далее.
Но соответственно, вопрос, как изменится либо эффект, либо эффект v2?
Да, смотрите, вот здесь у меня все пути изменились на вторую эту вершину, то есть прочерчный путь остался прочерчным путем.
Очевидно?
Очевидно.
Ну и последний вопрос, как мы с этим изменились вес любого цикла?
Изменились, да.
То есть, когда стартовая точка совпадает с конечной точкой, то и вес цикла у меня не меняется.
Все, то есть, вот пересвозка потенциала.
Первый.
Любой путь изменивается, разумеется, по личному фиксируемому, фиануэльному из первого пути.
Корочляющий путь, именно там путь, вообще не меняется.
То есть, если какой-то путь был корочащим из содом графика, то он и в конечном графике тоже останется таким.
И плюс, веса циклов не меняется.
То есть, если у меня в графике не было цикла по отрицательному весу, то и новый график не будет.
И наоборот.
Ну, наоборот, там сложнее.
То есть, если у меня был вес цикла по отрицательному весу, то ладно.
Они находятся на поcentric innovation.
Но были только aha .
mandible, пол Burger King.
И к proporteenth crazy.
Таким образом, то есть, вот...!
Вот!
Ну если любую тему вы注意 144억 с достопримечательными результатами был карман.
То есть, з?
Sorry, с 46 SPEAKERS.
Да у меняIELY меняЛ bekан thick wood,
Понятно, да?
Все. То есть я могу всегда дать поиск в высоком грамме,
а дать поиск в каком-нибудь другом. Отлично.
Но осталось делать за малым.
Придумать такую функцию в социалах,
которая сделает все наибрёбка не отрицательной.
Всего лишь.
Я надеюсь, как вы понимаете, это всегда возможно.
Когда возможно?
Когда невозможно придумать потенциал,
который сделает все наибрёбка не отрицательной.
Ну, очевидно.
Тогда это прямо нельзя.
Ну, в смысле?
Ну, вот тут был пример.
Если у меня граб стоит в рябрах,
то тут я спокойно могу делать все наибрёбка не отрицательной.
Если рябров нет, то притекаю.
А, я перевратил его вес.
Ну, нет.
Короче, потенциал нельзя придумать,
если у меня есть припал отрицательного веса.
По третьему свойству. Согласна?
Так у меня веса отрицательных циклов сохраняются,
то, соответственно, если мы обратно назначаем
дебилы циклов отрицательных весов,
то у меня невозможно будет потенциал,
который сделает все наибрёбка не отрицательной.
Иначе, когда эти дебилы не отрицательны,
то у меня есть припал отрицательных весов.
Нет, вот эти поиски некорректно понятны.
То есть мы говорим про корректность перехода.
Перехода у граба с не отрицательными рёбрами,
а с отрицательными рёбрами граба с не отрицательными рёбрами.
А мы располагаем, что ревизируем чей-то.
Ну, вообще производуемся.
Так, если не ревизируем,
то вес цилинг может положительный,
а это припрыгается.
Понятно.
Там у меня есть дебилы циклов.
Я не понял, что у меня есть дебилы циклов.
Нет, смотри.
Там разные потенциалы,
естественно, они будут продолжены в цепи.
Проблем нет.
Да ладно.
Если у меня есть циклы,
то если у меня есть циклы,
то можно перейти.
Не понял.
Спасибо.
Пять.
Потом встал вот такой граб.
И...
Семь.
Ну ладно.
Если там цикла расчёта.
Добавим на шею.
А зачем нам добавлять пресс?
Если мы хотим оставить рёбра,
не отрицательные.
Да, как раз вопрос в том,
чтобы подобрать потенциалы,
кто бы, соответственно,
в серёге расчёта не отрицалил.
Очевидно, что это не всегда возможно.
В следующем случае очевидно,
что если в грабе есть цикла отрицательного места,
то такой потенциал на грабе невозможно.
Но есть наше мнение.
Если цикла отрицательного места нет,
то это сделать всегда возможно.
Вот сейчас мы имеем вид.
Теперь мы поняли всё.
Пусть в грабе лежат циклы отрицательного места,
потому что цикла у нас не есть.
Если мы хотим Mafia 오�отку constituent ...
... cab 질문 ...
combine.
어 дㄷqы
ain't Too.
Тогда, если мы можем подключить к каналу вот такую штуку,
расстояние контекции с водой, ну, вершина лица,
то тогда вы представьте, что в таком случае у меня
дистанционный крыльк стал у меня этой цепью.
Понятно?
Почему это так?
Ну не понял.
У нас алгоритмы.
Не-не, понятно.
А может быть вода в последний зал.
Есть два вида.
Известных в нём нет, а дистанционных вообще нет.
Что я делаю?
Добавляю дистанцию, из неё пробожу всевозможную
эту репроферцию.
Если можно.
Говорю, пусть у меня консал, пусть у меня консал
обстоятельный курт курт.
ты отыкся на грошей, когда я еду до этой товарной вершины, до вот таких лица
тогда, вот ты считаешь, если я возьму вот такие лица
ну, давай, давай, давай
а если я возьму вот такие лица
то они у меня отыкся
доказано
ну, просто нам скупапка денег распишем
w и цигель
это w и цигель
плюс фиатрикс, минус фиатрикс
в свою очередь, скупапка денег, фиатрикс
это равно w и цигель
плюс
что вот сейчас здесь говорили
икс, минус
о, это твой икс
и вот я считаю, что это икс икс
обязательно пользуй правильно дня
почему?
так, смотри сюда
что это такое?
это крошечный пыль
он крошечный
это стропа, где 12
из этого зазоя
вылит
икс
который проходит
в олигу
согласны?
то есть вот у меня есть
вершинка, а я со стой
есть вершина икс
и вот эта длина пути вот такого
я сначала иду до вершины икс
со стой икс
а потом двигаюсь и прикручиваю
согласны?
а вот это вот такое
а икс прекращаешь в пути
из-за стой выпиток
что можно сказать про соотношение
вот этому пути
вот этому пути
и кача
да
в качах пути обязательно меньше
браться, чем
согласны?
почему 0?
нет
если у меня есть отрицательные ребра
то...
пример
что вот тут у меня они все
почему тут 0?
почему тут 0?
ну совсем
почему тут 0?
когда
когда первый пункт романулю
романулю
нет?
так понятно, почему вот эта штука
обязательно
не меньше, чем вот это
вот это путь
который как-то
путит вот этой звездой до иклика
сначала кратчающий могустем до икса
а потом из икса выпит
а вот это именно кратчающий путь
понятное дело, что кратчающий путь
не может быть никак больше, чем вот такой путь
понятно?
поэтому тут больше и правда
доказали
то есть в любой парке
а вот
сходим на циклорецетную вес
но проверять, что мы можем наединить
стояние
да, стояние может быть корректным
что в принципе это вот
что рожда корректно определена
ну и фишка соответственно
но нам же сказано, что это стояние
если это будет...
доказательств нам не нужно сказать
доказательств мы просто из головы берем что-то
доказательств
мы же уже сразу определили
что?
что мы нашли?
не-не-не, смотрите
мы используем пока только кратчайшее
стояние
от S из 2 до остальных вершин
а задача найти расстояние между всеми вот этим вершинами
да-да-да
чтобы найти кратчайшее стояние между всеми вершинами
нам придется найти расстояние от этой вершины до всех остальных
это правда
но это все равно будет эффективно
так, теория-то понятна?
ничего нет
понятно все?
окей
соответственно, план алгоритмы такой
план S
нет, неправда
берем граф
заводим
вершину S из 2
на самом деле вершину можно не заводить
в этом семинар
заводим вершину S из 3
проводим
ребра длины 0
во всех остальных вершинах
забудкаем алгоритм морда Велмана
и находим кратчайшее стояние
под S из 3
во всех остальных вершинах
если мы
будем искать
кратчайшее стояние
до вершины С
мы будем искать кратчайшее стояние
до вершины С
нет, вот как раз этот прикол
прикол в том, что мы изнасиленно
запускаем цифру Велмана
из вершины С
и ищем пути вот этой вершины
до всех остальных
и в этот момент мы можем проверить цифру от всякого места
понятно?
все, вот так работает
вот работает
завоем
идем дальше
дальше, третий пункт
ну а в третьем пункте
мы говорим, что
первых все равно
просто эти найденные пути
и
и
х
правильно
и в х
плюс
5
ну и четвертый пункт
гениальная
смотрите, у нас есть граф
в графе нет цикла по отрицательному весу
поэтому мы можем по нему применить
алгоритм D Extra
нормально?
да
то есть просто
от каждой вершины запустила алгоритм D Extra
и найти прочедшие пути
спускаем
D Extra
все
соответственно
зависит от вида
либо на пирамиде
либо на север
ве
ве
либо
ве
плюс ве
ну вот это D Extra
плюс 4 белла
ну и соответственно
мы получаем
2 квадрата ве
ве
плюс
ве
плюс
ве
плюс
ве
плюс
ве
плюс
ве
плюс
да
плюс
соответственно
нам было 2 квадрата ве
и тут тоже получаем
2 квадрата ве
ну
ну правда понятно
нам бы менять пирамиду D Extra
нам так и следует
но
а тут соответственно
получаем 2 квадрата ве
и тоже существует все квадраты ве
вот
какие дела
ну соответственно вот пора
вот мы рассмотрели
алгоритмы Форда Беллона
алгоритмы D Extra
алгоритмы Флойда, алгоритмы Фротства
весь итог
по сути показан вот там
что мы делаем
есть нам данный граф
отбирает наберемую
то
используем алгоритмы Форда Беллона
по сути
посуду в плоти
если мы в трех играх на прицепе
то просто запускаем фейер
если же граф плотный
то соответственно
не ва
в любом случае вы не используете Флойда
как видите
а Флойда хорошо работает только для плотных графов
и на разрешенном графу
его исполнение не стоит
ну и там
в зависимости от того
есть ли у вас специальный игрок
или нет
то соответственно может быть слой
не дружок
остались две вопросы
окей
тогда давайте
у меня были какие-то вопросы
по прошлому тесту
так
да
был такой вопрос
о которой
был один намек
давайте его разберем
вот первый вопрос
основной быстрее игра
а вот
вот
веяние под граф
некоторое минимальное окно на дереву
и вопрос заключался в том
что мы рассматриваем
рёбра
которые пересекают разрез
то есть здесь тут
длина а, длина б
то есть это был вопрос
может ли ребро
наибольшего веса
быть безопасным
какой ответ
да
сейчас всем понятно, что да
посмотрите
лемма безопасно припишется
а лемма
что
если рассматривать вот такой разрез
то ребро минимального веса
гарантированно является безопасным
но эта лемма утверждает
что
и только ребра минимального веса
безопасным
понятно, что тут могут быть какие-то другие безопасные рёбы
ну, банальный пример
вот у меня есть
вот такой граф
и тут вот такие рёбы
3x1, 2x2
возьму вот такой подграф
возьму пустой подграф
и рассматриваю вот такой разрез
его пересекают только
понятно, что
ребро 2 является безопасным
согласен
это минимальная мощность. Таким образом, мы получаем, что ребро подсумаемого веса
тоже является безопасным. Т.е. ребро подсумаемого веса, если пересекать кромлет, тоже может быть без оттахов.
Просто лемма, я не знаю, просто лемма делает повышение прорыва и минимального веса.
Но в теории, ребро подсумаемого веса тоже могут быть оттахованы, тоже могут быть без оттахованы.
Дальше.
А-а-а.
Я тогда, вот такая ситуация.
Дальше.
Что?
Вот, хороший вопрос.
А-а-а.
Вот, короче, по этому надо, на самом деле, однозначно сказать, является ли это точка сошинения или нет, нельзя.
Потому что у нас для корни сошинения есть два притерии.
Первый притерий для корня, второй притерий для не корни.
Вот, если любой притерий является корнем, тогда будет точка сошинения.
Если любой является корнем, то тогда ничего сказать нельзя. Понятно?
Нормально?
Вот, поэтому, по этой информации, не достаточно информации о том, что вы говорите, является ли это точка сошинения или нет.
Потому что тут мы должны полностью понять, а вообще говоря, являлось ли это корнем, по поводу дерева, по поводу глубину или нет.
Ну вот.
Ну и, в принципе, все.
В общем, с темой характерической пути.
Мы на канале уже закончили.
Следующий у нас будет еще один большой пункт.
А, просто, следующий раз мы начнем прямо в потоке.
Ну, какая самая тема.
Ну все, давайте перерыв.
