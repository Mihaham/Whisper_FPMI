Помним, что до этого мы делали. У нас пошел раздел про синтаксис, определение ложность, в прошлый раз мы определили истинность формулы при помощи синтаксиса.
Ну, понятно, что если мы можем синтаксически определять истинность, то теперь нас будет интересовать, можем ли мы синтаксически проверять наложность.
Причем проверка на ложность и на истинность равносильна в том смысле, что А от автологии, я буду писать так, равносильно, что не А противоречие.
Еще чуть раньше мы проговорили, что любая булевая формула, функция может быть приведена к КНФ, например. Даже СКНФ научились это все строить.
КНФ, как мы помним, определяется в несколько этапов. Первый этап это литерал, это переменная либо ее отрицание, дальше у нас есть дизюнкт, это конъюнция дизюнтей литералов и дальше идет само КНФ, конъюнция дизюнтых.
Помнится, мы рассматривали, что КНФ и дизюнт могут иметь мощность 1, то есть конъюнция только одного дизюнта и дизюнт только с одной переменной.
Но ведь натуральные числа у нас, как мы помним, стартуют с нуля, поэтому хочется уже задуматься о том, что такое дизюнт от нуля переменных.
Назовем его пустым. Какие предположения, чем будет у нас вообще пустой дизюнт?
Ну нулем, наверное.
Действительно, пустой дизюнт- это ложь. Почему так?
Идейно, когда мы используем дизюнцию, то свойство дизюнтства такое, что если что-то 0, если что-то 1, то и все 1.
И каждый раз, когда мы добавляем через дизюнцию, мы стараемся расширить количество выполняющих наборов.
И если бы изначально начинались единицы, то понятно, что любое дальше добавление, оно не сможет добавить новых выполняющих наборов в силу того, что уже у нас есть единица.
А значит, стартую с нуля, то есть тождественной ложи, добавляю новой переменной, мы расширяем.
По аналогичной логике, пустой конюнт будет тождественной истиной, потому что конюнтцы, наоборот, у нас стремятся сократить количество выполняющих наборов, сузить.
Обозначать будем его, как обозначали тождественную ложь.
В частности, тогда вот, например, я решил обозначать тождественную ложь, тождественной истиной, но при помощи перевернутой T и просто T, чтобы дальше вот, когда мы начали говорить по пустой дизюнте, с этим перекрикалось.
Оказывается, что если мы сможем получить КНФ, то есть КНФ у нас, дайте, D1, конюнтцы D2, конюнтцы Dn.
Как мы помним, из Axiom и Modus ponens я смогу из этого всего вывести просто D1, тогда ли Dn.
Если я теперь могу вывести каждый дизюнт, то что я могу сделать с любым из них?
Ну, например, я могу любые два дизюнта как-то объединить произвольными операциями с пропозициональных формул.
Но если произвольными, то импликацию мне пока незачем получать, потому что, да, я вот тайду идеи над КНФ.
Если я пойду объединять их по конюнтце, я просто вернусь к тому, что у меня было изначально.
Но у меня остается только одна операция – дизюнтце. То есть я расширю в некотором смысле дизюнт.
Был D1, D2, получили D1 или D2.
Но понятно же, что можно упрощать дизюнт.
И как раз правило метода резолюции говорит о том, что у нас был раз дизюнт, был два дизюнт, мы можем как-то их простить, объединяя по дизюнтце.
И оно звучит так. У нас есть D1 или X.
Дизюнты мы считаем… Ну ладно, он все равно будет работать. В самом общем случае будем смотреть D2 или не X.
То есть у нас есть какая-то переменная дизюнтце с дизюнтом и другой дизюнт, но уже дизюнтце с отрицанием этой переменной.
Тогда отсюда выведется D1 или D2.
Ну и как раз как нам вывести пустой дизюнт? Пустой дизюнт значит 0 переменных.
Если здесь должно быть 0 переменных, то D1 у нас 0 и D2 тоже 0.
А значит выводится это единственным образом из переменной и отрицания.
Хорошо.
Дальше. Так как мы поняли, что под капотом всего этого происходят правильные преобразования в смысле прошлого раза аксиом и правилов вывода, то то, что мы получили работает корректно в предположении исходных посылок.
А значит мы можем спокойно дописывать новые полученные дизюнты, а мы действительно получаем дизюнты, потому что это дизюнт, это дизюнт, а дизюнтцы дизюнтов это дизюнт.
То мы можем спокойно дописать это в новую формулу.
То есть у нас было какой-то КНФ.
D1, так далее.
Dn-1 или
x и
Dn-2
или
не x.
И мы дальше при помощи метода резолюций
перевели к эквивалентному
КНФ штрих давайте.
D1, так далее.
D
вот это еще раз писать. Я просто Dn-2
или не x
и
новый выведенный дизюнт.
Тогда что бы это означать, что мы вывели пустой дизюнт?
То мы сделали конъюнцию с пустым дизюнтом.
А пустой дизюнт это ложь.
То есть мы сделали конъюнцию с ложью.
Значит вся формула это ложь.
Вот.
И глобально мы делаем что?
Мы берем формулу, приводим ее к КНФ
и дальше пытаемся вывести пустой дизюнт.
Если его вывели, то мы знаем, что формула ложна.
Соответственно при помощи этого же можно проверять на
истинность.
Просто проводя метод резолюции для отрицания формулы.
И как понятно, что
для этого метода должны появиться две теоремы.
Как и за числением высказываний.
У нас есть метод резолюции.
Не буду сокращать mp, чтобы не было путаницы с modus ponens.
У нас в одну сторону есть теорема корректности.
Что для любой фии, принадлежащем к
не выполнимым формулам, то есть противоречием
выполняется, что выводится пустой дизюнт.
То есть любая плохая формула мы действительно ее распознаем.
И теорема в полноте, что действительно мы всех таких плохих формул сможем.
Давайте я назову это SAT.
SAT это от английского Satisify.
Удовлетворять и я не помню сейчас.
Может быть скажу Satisify.
Не помню я все.
Выполнимые формулы выполнено, что не выведется пустой дизюнт.
Я вру.
Это наоборот как раз.
Это корректности, что мы ничего плохого не вывели.
Это полноте, что мы вывели все.
Еще не проснулся.
Так.
Давайте теперь поговорим, что KNF.
Давайте рассмотрим такую штуку, как NKNF.
Будем говорить, что NKNF.
Это KNF такая, что для любого дизюнта, принадлежащего в KNF, выполнено, что в этом дизюнте не больше N переменных.
Или их, не больше N литералов.
И отдельно рассмотрим 3 KNF.
Почему будем такое внимание уделять 3 KNF?
Рассмотрим еще раз метод резолюции.
У нас есть A или не X.
Есть B или X.
И из этого мы можем вывести B или A.
Давайте посмотрим на соотношение мощностное.
Наверное, по-хорошему нужно сразу сказать, что такое.
Мощность D.
Мощность D, где D изюнт.
Вот такое количество литералов.
Тогда рассмотрим, что у нас изначально было A или не X.
То есть равняется мощности A плюс 1.
Аналогично, что B или X.
Мощность B плюс 1.
И на выходе мы из этого всего получаем.
Мощность A или B равная сумме мощностей.
Изюнкта файли.
Получается, если мы рассмотрим эти 4 KNF.
То в худшем случае у нас везде по 4.
То есть тогда A у нас это 3.
B у нас это 3.
А значит это все добро мы приводим к 3 плюс 3 равняется 6.
И мы из 4 KNF перешли в 6 KNF.
Но звучит уже немножко страшно.
Если мы сделаем и рассмотрим просто N KNF, то N минус 1 плюс N минус 1 равняется 2N минус 2.
Мы почти что в два раза начинаем увеличивать количество переменных.
А это действительно очень плохо и в 8 точке мы вылежаем вообще в 2N.
Поэтому давайте рассмотрим что происходит в 3 KNF.
Почему мы именно на нее заострили внимание.
3 KNF это мы из 3 переходим в 2 на 3 минус 2.
Равняется 4.
То есть уже на тройке мы почти что не изменили размер дезюмптов.
Но только вот в особых случаях мы начали кушать по 4.
Логично, что захочется использовать 2 KNF.
Потому что тогда мы вообще не выйдем за пределы двуместных дезюмптов.
Но с 2 KNF проблема к приведению к нему.
А 3 KNF мы можем легко привести к этой форме произвольную булеу функцию.
Точнее не булеу функцию, а пропозициональную форму.
Как это сделать?
Да даже можно произвольную булеу функцию.
3 KNF.
Построение.
Давайте расскажем как строить.
У нас есть некоторая пропозициональная формула.
На входе. Давайте я скажу, что изначально будет что-то типа P, следует A или M.
Ну собственно, почему бы и нет.
Первое, что мы делаем.
Не забываем скобки, иначе это не пропозициональная формула.
Если это не пропозициональная формула, то у нас начинаются беды с синтаксисом.
Изначально мы требовали всегда скобки.
Первый шаг, строим дерево разбора.
В силу того, что мы добавляли скобки, у нас есть единственность разбора,
поэтому мы можем построить только одно дерево, и оно будет хорошим.
Давайте отметим, что у нас будет листьями, что будет вершинами, узлами дерева.
Листья дерева – это переменные, узлы дерева – это знаки логических операций.
Дальше здесь.
Супер.
Теперь мы начинаем рекурсивно от листьев к корню заменять каждый узел на 3КНФ.
А именно.
Что мы будем делать?
Перемены, очевидно, они сами 3КНФ, поэтому листья прямо сразу все хорошо.
Есть юнция, есть юнция 3КНФ, 3КНФ, оставим ее.
Преследует что-то.
Значит, нам надо импликацию поменять на 3КНФ.
Как мы это делаем?
Делаем…
Давайте.
Мю ню и мю следует ню.
Таблицы истинности.
Тыц-тыц-тыц-тыц-тыц.
И делаем конъюнцы.
Конъюнцы у нас фиксированы нули.
То есть это…
Да.
Значит, это не мю или ню.
Супер.
Начинаем заменять этот узел.
Получаем, что не п, а ню.
Получаем, что не п, или а, или м.
А теперь у нас появилось конъюнцы с ку.
То есть получили ку и не п, или а, или м.
Пришли ку или не п, или ку и а, или ку и м.
Все, получили 3КНФ.
Но…
Давайте вопрос на понимание.
Чем плох такой алгоритм?
На самом деле здесь очень просто понять, что он плохой и не подходит на самом деле.
Давайте просто рассмотрим 3 раза дизюнцию.
Тогда по нему нам потребуется каждый раз объединить по дизюнции.
И мы получим не 3КНФ, а 4КНФ.
А значит, его надо как-то модифицировать.
А именно.
Нам придется расширить множество переменных.
Путем…
Давайте я выделю этот узел.
Путем заведения дополнительной переменной на каждый узел.
То есть я заведу сюда…
В, W, У.
Давайте все-таки сюда R, потому что root.
Теперь, если мы будем смотреть на каждый узел…
Ой, на каждую развилку сам по себе.
У нас, по сути, плюс-минус бинарное дерево.
А значит, у нас родители 2 его ребенка дают сумме 3 переменных.
Как раз сразу уже понимаем, есть какая-то связь с 3КНФ.
Теперь осталось лишь понять, как связать родители 2 его ребенка с некоторой булевой функцией.
И тогда дальше мы будем абсолютно аналогично, как в прошлый раз, но только модифицированным проходить.
Ну, что значит, что мы заменили узел на вершину?
Значит, что значение переменной должно быть таким же, как и значение на этом узле.
А что за булева функция у нас отвечает за такой же как?
Это экваленция. То есть у нас теперь V должна быть эквивалентно A или M.
Тогда теперь нам нужно будет уже приводить вот это выражение к 3КНФ.
Понятно, что если мы просто построим наш обычный SKNF, она и будет как раз 3КНФ.
Поэтому сделать это можно.
Тогда мы получим какую-то переменную V, которая будет эквалентно 3КНФ.
Но что же делать дальше?
Дальше, на самом деле, когда мы рассмотрим, вот у нас был узел V.
V отвечает, получается, за значение.
Теперь нам нужно будет для дубль V рассмотреть.
Мы знаем, что значение на ребенке это V.
А значит, теперь мы будем для V строить то же самое, но
V должно отвечать за P следует V.
И глобально, когда у нас есть произвольный узел, есть какие-то две переменные, отвечающие за два ребенка, есть операция,
то переменная, отвечающая за операцию, должна быть эквивалентна
Левый узел, операция, правый ребенок.
Так, каждый раз у нас будет по три переменных, поэтому будет получаться 3КНФ.
Тогда, суммарно, мы просто возьмем конюнцы всего этого.
Это будет означать, что V отвечает за такое, и это V.
Сейчас, это W отвечает за такой узел, и V отвечает за такой узел,
и что там у нас будет? И R отвечает за такой узел.
И в конце еще нам нужно будет что добавить.
Так мы сказали, что вот у нас теперь каждый узел за него что-то отвечает.
И нам нужно добавить, что формула сама по себе верна, что это именно эта формула.
Значит, мы должны еще добавить R.
То есть мы сделаем вот здесь вот будет какой-то 3КНФ.
Конюнцы с вот этим 3КНФ.
Ну и конюнцы с R.
Первые три вот эти 3КНФ будут на самом деле просто своего рода кодированием формулы.
А дальше нам нужно добавить 3КНФ исходной формулы.
И мы добавляем 3КНФ.
И мы добавляем 3КНФ.
И мы добавляем 3КНФ.
А дальше нам нужно добавить 3КНФ исходной формулы.
А это есть R.
Все.
Так мы смогли перевести произвольную формулу 3КНФ.
Можно про это немножко поподробнее?
Потому что у нас же в этих вот конюнтах там сохраняются значения V, W и U.
Можно еще раз поподробнее сказать, просто не совсем понимая про что.
У нас в этих вот 3КНФ, которые остались, у нас сохраняются V, W и U.
Они же не должны там оставаться.
Почему не должны?
Мы построили, ну на самом деле действительно, мы построили 3КНФ не исходной формулы, а формулы эквалентной Е.
То есть сами по себе V, W и R, они расширят количество переменных, но не изменят значения.
В... сейчас.
Не изменят значения в рамках исходных переменных.
То есть значения переменных R, W и V и всех произвольных наших новых формул.
Наших новых фиктивных переменных, оно однозначно определяет со значениями исходных.
И глобально они сами по себе смысла не несут.
Ну то есть мы это можем сделать только в том случае, если нам нужно с 3КНФ что-то делать дальше.
Да.
Ну допустим, прерези там верна не верна.
Да-да-да.
Окей.
То есть глобально мы сейчас захотели что?
Мы захотели перейти к 3КНФ в силу того, что так мы будем не сильно разрастаться в методе резолюций.
Поэтому мы готовы пожертвовать, ладно, давайте нам чуть побольше переменных, но зато мы будем меньше...
Меньше разрастаться в методе резолюций, потому что сам по себе разрастание переменных оно не так страшно,
как то, что нам придется метод резолюции запускать много-много-много-много-много раз
и ждать пока мы начнем уменьшать количество этих, уменьшать размеры дизюнктов.
Чем больше исходные у нас дизюнкты, тем дольше у нас будет тратиться времени на то, чтобы начать уменьшать их размер.
Вначале у нас просто начнет колоссальным образом расти количество дизюнктов с большим числом переменных,
ну что и логично, и из-за этого мы никакой полезной информации для себя,
а для нас полезной это вводимость пустого, поэтому чем меньше дизюнкт, тем нам более интересно его вывести.
И так у нас будет неэффективно строить изначально просто КНФ, НР-ной формулы.
НР-ной, ну в смысле, что от N переменных зависит.
Удивительно, но на этом теория все.
Еще могли бы мы сегодня поговорить про языки первопорядка, как в прошлом году, но их не будет.
Наверное, в общем, после этой контрольной появятся впервые задания,
по которым будет явно сказано, что вы можете не решать программу руками, а написать программу.
То есть можно действительно руками пытаться проводить методы изолюции, можно проводить это все, написав программу.
По опыту скажу, что руками я не знаю сколько потребуется,
потому что когда я решал, я писал программу, и у меня программа отрабатывала на 5000 с половиной резолюций.
Ну и понятно, что раз это программа, то как она работает.
Вот мы запускаем полный перебор на всякие различные резолюции 2, 3, 4.
Если кто-то хочет оптимизировать, пожалуйста, welcome.
Стоит ли оно того?
Я, наверное, скажу, что не особо стоит оно того.
Наша задача просто вывести, поэтому прогоним мы 5000 раз. В чем проблема?
Посидим не полминуты, а минуту.
И на самом деле, вот сейчас что мы начали думать?
Мы начали думать о выполнимости 3КНФ.
Наша задача про выполнимость 3КНФ.
Ну или на самом деле невыполнимость.
Есть такая задача, как 3SAT.
Это задача про выполнимость 3КНФ.
Это, если вы слышали, есть такой понятие, как NP полная задача.
Ну не знаю, у вас на алгоритмах было ли уже динамическое программирование.
Если не было, то, может быть, вы раньше сталкивались.
Есть такая штука, как задача о рюкзаке, который решается DPS.
Задача о рюкзаке очень нехорошая.
В том смысле, что мы не умеем ее оптимально искать.
То есть не умеем искать за пленом.
Наверное, для людей, любящих оптимизацию, это не просто значит, что мы не можем искать за линию.
Мы не можем написать и за квадрат, и за куб, и за четвертую, и за десятую, и за тысячную степень от N.
Мы можем только за экспоненту.
А за экспоненту понятно, что алгоритм очень неоптимальный.
Вот задача о нахождении выполняющего набора, задача о выполнимости 3KNF, она также является NP трудной.
То есть ни за какой пленом мы это решить не можем.
Это только экспонента.
Так что глобально к чему я веду?
Что не нужно рассчитывать, что ваш алгоритм будет работать за какое-то там количество циклов фаров.
Какого вы написали, в общем случае, его недостаточно.
Поэтому можно пытаться оптимизировать, но с нужной ли?
Хороший вопрос.
Идеи на асимптотику вы не улучшите.
Поэтому можете прям глупым перебором делать 1, 2, 3, 4, 5 итераций.
Вот так вот прогонять, пока у вас не выведется пустой дизюнкт.
Ну и помните, что пустой дизюнкт получается не из дизюнктов размера 6 и 6, а из дизюнктов только размера 2 и 2.
Так что стараемся сначала поновыводить дизюнктов размера 2, потом из двоек поновыводить...
Каких у нас?
Сейчас, сейчас, сейчас.
Из двоек поновыводить единиц.
Что-то я, кстати, натупил тогда.
Пустой дизюнкт из одноместных получается.
Поэтому сначала получаем двойки.
Из двоек выводим единички, и потом уже из единичек выводим пустой дизюнкт.
Из таких вот действительно более-менее разумных оптимизаций это...
Мы можем сразу, когда получаем пустой дизюнкт, мы можем сразу проверять на выводимость...
Получать одноместный дизюнкт.
Когда получаем одноместный дизюнкт, можем сразу проверять на выводимость пустого.
Потому что выводимость пустого — это наличие некоторой переменной и отрицания.
Просто можно завести что-то типа мопы и проверять, что если есть...
Ну, там сделать типа два флага, пары какой-нибудь там, переменные и отрицания.
И проверять, что если в паре противоположные значения.
Если есть, то можно останавливать программу и вводить.
Можно делать менее оптимально.
Для любителей красивого оформления весь этот метод можно прям явно запограммировать в лотех.
То есть берете дизюнкты, заводите, придумайте им какие-то названия переменных упоротые.
И 1, и 2, и 3, и 500, и 700.
Там какие-нибудь на узлы, когда нам понадобится вводить эффективные переменные.
Можно придумать следующий вариант названия, что это будет переменная там типа f, эффективная.
И с индексами левого, правого сына.
Тогда у нас будет единственность названия всех этих переменных.
Ну дальше мы имеем названия странные.
Значки какие у нас есть?
У нас по сути конъюнция, дизюнция, отрицание в лотехе.
Это нод, ведж, и...
Я не помню уже дизюнцию.
Еще как-то там дизюнция, штопор у нас это vdash.
И просто каждый раз берем, храним ужасный txt файл, в котором сырым лотеховским форматом просто каждый раз новую дизюнцию записываю в конец.
Наверное тут что-то типа питона потрясающе подойдет, когда надо быстро написать какую-то вещь.
Не особо парясь про оптимальность кода.
Я бы даже может быть показал идей на код свой как я делал.
Но наверное не буду.
Не буду спойлурить.
Глобально когда я решал задачу, идея была такая, что у нас есть изначально какое-то условие.
Нам нужно сгенерировать сначала саму формулу.
Там нигде не сказано про оптимальность формулы.
Поэтому если понять ее логику, то мы просто берем сначала, генерируем какую-то вещь.
У меня было это связано с ксорами.
Поэтому у меня был там что-то ксор пяти переменных.
Зная ксор пяти переменных, мы можем руками построить пять кнф.
Ну тогда берем, строим пять кнф.
Объединяем все эти пять кнф в одну большую пять кнф.
А дальше, если у нас есть n-кнф, и мы хотим ее перевести к три кнф, то на самом деле нам не нужно каждую операцию переводить.
У нас просто есть вот n1, давайте, l1, так далее, ln-2, ln-1, ln.
Мы можем упростить себе жизнь, заменив вот так вот на n, на новую эффективную.
Тыц-тыц-тыц-тыц-тыц.
Так мы доведем до n-2, получим какую-то эффективную л-штрих, а это уже три кнф и оставить.
А все предыдущие, ну просто допишем в конец.
И глобально нам просто нужно вот подправить слишком широкие дезюмпты.
Все.
Как работать с дезюмптами-конюнктами?
Ну это вообще очень просто.
Нам значки вот эти не нужны.
Нам просто нужно название этих переменных, поэтому можно хранить следующим образом.
У нас будет один лист, это типа кнф, лист дезюмптов, а сам дезюмпт это просто лист литералов.
Как-то так.
Ну и еще из идей на того, что я делал, что я заводил отдельно массивы там под...
Дезюмпты одноместные, под двуместные, трехместные, четырехместные.
Всего рода сортировка по ним.
И прогонял там комбинации 3 плюс 2, 2 плюс 3, 3 плюс 3, там 2 плюс 2, 1 плюс 1.
И спустя там наверное 5 или 6 таких вот комбинаций-итераций у меня все прошло.
Давайте, если есть вопросы по теории, задавайте и пойдем решать задачу.
Можете, пожалуйста, еще раз объяснить про три кнф, почему вот эта новая форма соответствует изначально?
Изначально.
Хорошо.
Начнем с первого, что если у меня есть вот n дезюмптов, то из этого по правилам вывода я могу спокойно вывести по отдельности каждый дезюмпт.
Это вроде понятно.
Хорошо. Если у меня выводится d1, т.д. или dn, то я могу вывести объединение dn и dm.
Произвольные два дезюмпта, я могу вывести их дезюмпт сюда.
Хорошо.
Так, давай так сделаем.
Вот это правило мы чуть модифицируем.
Понятно, что если у меня есть d1 или x, я могу вывести формулу d1 или nx.
В частности, я могу вывести коммутативность, значит я могу записать ниней x или d.
Здесь ниней x или d2.
Я могу вывести формулу, что ни a или b из этого выводится из a следует b.
Из этих двух штук я могу вывести не x, а d1. Из x следует d2.
Хорошо.
Тогда...
Ну так, съема про...
Сейчас давайте скажу.
Или даже не так.
Ну ладно, давай так пока.
Если у меня есть такие две штуки, то я могу сказать, что из не x или x следует d1 или d2.
Хорошо.
Вот если у меня есть две такие, то я могу вывести такую.
Вот это, это съема 11.
Значит я его могу вывести.
И тогда по modus ponens я могу вывести d1 или d2.
А теперь внимание, то есть...
Окей, хорошо, вот я получил, что вот эта штучка корректна как-то.
А теперь внимание, изначально что мы сделали?
Мы сказали, что если выводится вот такой вот d1 dn, значит выводится то.
То есть мы в рамках того, что если формула верна, то верны и все остальные.
А значит, если мы допишем вот эти все штуки, то что получится?
Если исходная формула была верна, то все дописанные тоже верны.
Значит, и новая формула тоже будет верна.
Если исходная формула была неверна, то конъюнцию с произвольной штукой это все равно неверная формула.
Значит, если исходная была неверна, то и новая тоже неверна.
И таким образом, что они эквалентны.
эквивалентно. А в обратную сторону? Почему? Я понял, почему если исходная верна, то новая верна.
Потому что если исходная не верна, то вторая не верна. Это контрпозиция факта того, что если вторая верна, то первая верна.
Вообще, вот это хорошее свойство в доказательствах используется, что если мы хотим эквалент из двух фактов показать, мы можем неявно говорить, что если один верен, то второй верен, и второй верен, то первый верен.
Мы можем также рассматривать, что если первый верен, то второй верен, и что если первый не верен, то и второй не верен. В этом плане контрпозиция очень хорошая штука в доказательствах.
Хорошо. Еще вопросы по теории? Ну если нет, то давайте смотреть задачи.
Первая задача вот такая вот. Там вроде бы возможно добавить, там вроде должно еще одну задачу добавить. Ее как добавит, я выложу ее решение.
Хорошо. Задача формулируется так, что у нас есть изначально множество дезюнтов, то есть есть некоторые КНФ, даже три КНФ.
Мы рассматриваем множество циты, где это множество дезюнтов, вводимых за и расприменение метода резолюции.
Монологичное определение этого множества, что если мы запишем метод резолюции при помощи дерева, то глубина дерева должна не превосходить и.
И нужно проверить следующие дезюнтов. Укажите минимальные. Такое, что дезюнт лежит в цитах. Если такое нет, напишите минус один.
Я бы советовал начать, либо с попытки вывести пустой дезюнт, либо с попытки вывести выполняющий набор.
Как это делать? Давайте начнем сначала просто применять метод резолюции, не особо парясь на классификацию данного.
Вот, например, сразу просто смотрим, когда есть два двухместных дезюнта. Если можем применить метод резолюции, обязательно применяем.
Дальше. Важно, что нужно отметить, какой вариант метод резолюции не стоит применять.
Ну или другая там комбинация x и y, когда один истинно другой ложь, это без разницы.
Почему не стоит применять метод резолюции к нему? Глобально без разницы. Вот я сейчас почему проведу резолюцию по x или по y.
Потому что если произведу это без ограничения общности по x, я получу d1 или d2 или y или не y. Я получу y или не y. То есть если дезюнт это торжественная истина.
А смысл каждой новой резольвенты, резольвенты это результат, получаемый после применения метода резолюции, то каждая резольвента она добавляется в конъюнцию к исходной формулы.
А добавление единицы к конъюнции не несет никакого смысла. Поэтому вот это мы не делаем.
А что мы можем сделать? Мы можем сделать какую-нибудь еще такую шнягу. Давайте я вот это с этим. Почему я хочу применить вот эти два дезюнта?
Потому что у них есть общие переменные. А значит в резольвенте она схлопнется до одной. То есть у нас был q или s, а не q или r или s.
Если q или q пропадают, то остается s или r или s. А это то же самое, что s или r.
Но на самом деле для того, чтобы как-то жить красиво, будем поддерживать алфавитный порядок и будем писать все-таки раз.
Хорошо. Что я еще могу сделать? Я могу по аналогии применить ко второму и последнему q или s. q или r или s.
Это qr. Вот смотрите у меня снова появились два двух местных. Начинаю творить с ними чудо.
П или q? Ну дайте прям так запишу. А это p или r? Что еще у меня есть? Что-нибудь интересное.
Вот у меня есть p или r и теперь есть p или не r или не s. Сейчас вы поймете зачем это делаю. p или не r или не s.
Я могу вывести p или не s. Но у меня же есть p или s и есть p или не s. Я могу наконец-то вывести одноместный дизюнк.
Как только мы получили одноместный дизюнк, самое разумное будет сделать, что понизить местность дизюнка в содержащие не p.
Мы просто можем, используя метод резолюции, поубирать вхождения не p из них. Я могу п или не q или не r.
Возвращаем по методу резолюции не q или не r. У меня есть q или r и как мы понимаем, что поменять метод резолюции к ним особо пользы не принесет. Ну ладно.
У меня есть q или не q и есть r. Давайте применять к этому.
Это не q или r или s, не q или s.
А теперь у меня есть q или s. Раз получили s, два получили p. Что мы теперь будем делать? Снова получили литерал. Начинаем понижать местность всех дизюнков с отрицанием его.
Ну как мы это будем делать? У нас есть q или не... Ой сейчас, ладно, нет, у нас есть p или не r.
У нас есть q или r. Уводим q или r. Дальше еще что-нибудь с не с у нас есть.
У нас что-то больше ничего нету. Ну ладно. У нас есть q или не r и q или r. q или не r. Если у нас что-нибудь полезное для этой штуки.
Пум-пум-пум-пум-пум. Сейчас скажу.
Ну вот, можно заметить, что уже сейчас я смотрю и особо не могу придумать что-то хорошего. Правда ли что? Ну кроме... Сейчас подумаю полезно ли это вообще.
q и не r, q и не q и не s, q и не r. То есть, что сказать, что s, q, r, q, r выявилось. Если что-нибудь у меня на...
Ну вот, мы видим, что как-то особой пользы от того, что я сейчас начинаю выводить двуместные дизюнкты не получилось.
Значит, придется нам как-то вывести трехместный. Ну какой нам трехместный будет полезен? По-хорошему, нам будет полезен...
Какой-то...
Какой-то какой-то сейчас...
Да никакого уже особого хорошего нет. Это тестовое задание. Дальше думать здесь, наверное, не надо. Если смогли вывести, то супер. Глобальная задача просто попытаться вывести двуместных дизюнтов.
Зачем их нужно пытаться выводить? Затем, что теперь у нас есть ограничение по управляющему набору. То есть, у нас есть s, у нас есть p и у нас есть формула, связывающая койлер.
Значит, мы можем просто теперь попробовать подобрать какие-то наборы. А именно, если у нас есть p, то у нас выполнен автоматический набор этот и вот этот. s даст нам выполнимость вот этого набора, вот этого набора.
И все. Теперь этот набор у нас будет не койлер, а этот набор даст нам койлер.
Но если у нас есть тут такие две штуки, то мы можем подобрать выполняющий набор? Действительно, можем. Возьмем q и r неравные между собой. Например, q равны нулю, r равны единице.
Тогда оба два оставшихся дизюнта выполнятся. И значит, мы получим того, что исходное кнф будет выполнимо. А тогда по терям и корректности мы не сможем вывести пустой дизюнт. То есть, получили минус один.
Более того, зачем мы это делали? Вот смотрите. Например, мы можем уже проверить, среди этих формул, выводятся они или нет.
Ну, понятно, что если p верно, то вот это вот все оно как-нибудь там выведется. А вот здесь у нас что? s это...
Сейчас скажу.
С это у нас один, значит это ноль. Это можно забить. А значит, от нас хотят, что теперь выводится формула q или не r.
Но q или не r, она будет верна, если эти оба равны единицам. Если эти оба равны единицам, как мы помним, наша исходная формула была не верна.
А значит, из нее вывести такой дизюнт нельзя.
Сейчас, сейчас, сейчас. Или я туплю. Я туплю.
Нельзя вывести, если исходная была верна, а заключение было неверно. Тогда это делается несколько иначе. Делается ноль-один. Вот.
Такое мы вывести не сможем. Исходная формула наша истина, а мы вывели дизюнт, который будет ложен.
Поэтому это тоже минус один. И теперь наша задача просто в том, чтобы понять, за сколько можно вывести первые три.
Ну, давайте смотреть. PLS, как мы помним, мы сразу получили за один. Поэтому прямо сразу пишем за один. Чего его париться?
Ну, PLR методом пристального взгляда можно понять, что за один мы не выведем.
Выводили ли мы PLR? Выводили. И выводили мы его за два.
Так как мы помним, что за один методом пристального взгляда мы доказали, что не выведем, смогли за два, значит пишем два.
Теперь P. Ну, как нам P? П у нас есть вариант вывести за сколько? За...
Можем ли мы вывести? Мы можем вывести здесь за четыре. Четыре уже очень плохое число. Обычно будет один, два, три.
Но кто знает, может в этом году поменять и сделать четыре. Пытаемся просто, если у нас четыре, придумать, можно ли вывести это за три.
То есть, недостаток этого дерева в чем? Что у нас на каждом пути у нас только один треугольничек, только один вывод.
Можем ли мы сделать так, что это будет вида жух, дерево жух, жух, жух, жух. Да, как-то сбалансировать его.
Ну, давайте смотреть. P мы можем вывести по P или не R, или так.
P или R мы можем вывести за две. Можем ли мы вывести P или не R?
Можем. Как это сделать? Вот у нас вещь хорошая, я ее сохраняю. Копировать, ставить.
Теперь мы хотим получить P или не R. Понятно, что чтобы получить P или не R мы хотим задействовать как тут эту штуку.
Чтобы вывести нам теперь что нужно? Нам нужно либо не R и S, либо P и не S.
Ой, либо не R и S, либо P и S. Но P и S мы можем вывести за два.
Сейчас, сейчас, сейчас. P или S мы можем за один вывести, вот. Поэтому хорошо все.
П или не R или не S, P или S, которые выводятся из P или не Q, Q или S, Q или S, P или S, жух P или не R, жух P.
Ну видно, что глубина дерева три. То есть три полосочки у нас. Поэтому можем за три.
Можем ли за два? Звучит как что-то Unreal. Мы только ко второму смогли получить.
Штуки, которые двуместные изюмты, в котором один литерал будет ходить, одна переменная будет ходить как сама и как отрицание.
В общем, как-то так.
Насчет этого номера будем помечать его красным цветом. Почему красным цветом?
Потому что для теста номера за 0.8 баллов он требует слишком много времени.
И поэтому к нему советую переходить после остальных. Остальные будут проще.
Можете еще раз, пожалуйста, объяснить четвертый пункт, почему нельзя вывести?
Четвертый пункт? Смотри. Мы нашли, что формула, если мы вывели P и S, мы можем какие-то изюмты сразу вычиснуть в осмотрение, потому что они теперь верны всегда.
И у нас осталось в итоге два изюмта, которые мы еще упростили. Это не Q или не R и Q или R.
Тогда теперь они будут, например, выполняться на наборах 0.1 и 1.0.
Любой новый изюмт каким свойством обладает, что если исходная верна, то и выведенный изюмт тоже будет верен.
Поэтому если исходная формула была верна, а выведенный не верен, значит мы такой изюмт вывести не можем.
Вот давай смотреть так. У меня есть вот здесь вот P1, значит у меня P равняется 1, значит этот верен, этот верен, этот верен.
Но не тождественный лож, понятно, что мы его не сможем вывести, потому что нашли выполняющий набор.
Теперь S у меня единица, поэтому я могу на этот забить. Я получил, что на самом деле из этой штуки выводится Q или не R.
Но это же будет ложно, когда Q равняется 0, а R единица.
А исходная формула будет верной, значит мы не сможем вывести к дизюмту.
В общем, да. Дальше, вероятно, нам будет задача вот такая.
Это адекватная теста задачи на подумать.
У каждой попозициональной формулы есть эквалентный ядрик NAF.
Ну да, это верно, потому что мы сами рассказали же алгоритм, как строить.
Если применить правила резолюции к двум дизюмтам, то обязательно получится дизюмт из не более большего числа литералов,
чем более длинным из исходным.
Ну, мы помним наши правила про соотношение мощностей.
У нас получаемый дизюмт это мощность A плюс мощность B,
где то же самое, что D1 плюс D2 минус 2.
И у нас спрашивают, что если применить правила резолюции к двум дизюмтам,
то обязательно получится дизюмт из не большего числа литералов, чем более длинным из исходным.
Ну, это уже звучит очень странно, что сумма, которая почти 2, не должна превосходить максимум.
Возьмем что-то похожее, типа 4, 4.
Получим сумме D1, D2.
4, 4. Получим сумме 8, минус 2, 6.
Здесь будет 4. Ну, конечно же, это неверно.
Такую штуку мы будем получать из двух, что из двух мы получим 2.
Для всех больших, как мы помним, мы можем нагенерировать что-то большее.
Но можем получить и меньше, потому что из трех и трех мы действительно можем получить 3.
Вот здесь оценка.
Да, на самом деле здесь не равно, потому что могут совпадать.
А мы смотрим на различные, нас интересует количество литералов различных.
Чуть модифицируем наше определение.
Поэтому 3 сделается, да, тут будет 3, не больше.
Вот. Если phi является тавтологией, то не phi, можно проверить методом резолюции.
Но если phi – тавтология, то не phi, это противоречие.
А если не phi – противоречие, то мы по теореме о полноте выведем обязательно пустой тезюм.
Значит, сможем действительно провернуть.
Это стандартное зачеркивание.
Если из КНФ можно методом резолюции вывести ровно один литерал с каждой переменной, то у этой КНФ ровно один наполняющий набор.
Сейчас еще раз почитаю. Если из КНФ можно методом резолюции вывести ровно один литерал с каждой переменной, то у...
Давайте, какие предположения?
Это хороший уже вопрос.
Вроде верно.
Да, это действительно верно.
Потому что, чтобы получить пустой тезюм...
Ну, то есть, опять же, вспомним оценку, что это мощность D1 плюс мощность D2 минус 2 должна равняться 0.
Ну, то есть, D1 плюс D2 равняется 2.
Причем мы знаем оценку на каждый из них, что D1 у нас будет равен единице.
Почему будет хотя бы единица?
Потому что если какой-то из них ноль, то мы, значит, уже раньше вывели.
И смотреть на это нам не имеет смысла вводить еще раз с пустого тезюма что-то новое.
Но это кажется, что может быть неправда, если мы вывели, допустим, пусть и все переменные,
мы можем еще какое-нибудь противоречие получить после этого.
Ну, смотри, вот я как раз сейчас и говорю про это, что чтобы получить противоречие нам нужно два дезюмта, которые будут одноместными.
А как нам...
Дезюмты?
Да.
Ну, я всегда обозначаю D это дезюмт.
Вот. Мы знаем такую оценку, потому что если оно будет равняться нулю, то мы уже вывели это пустой дезюмт, и не имеет смысла теперь смотреть.
Значит, они хотя бы единицы.
Если они хотя бы единицы, то здесь единственное решение имеет такое уравнение, что D1 равняется D2 равняется единице.
Откуда взялась эта сумма 2?
Ну, еще раз, у нас была оценка, что у нас был дезюмт 1, дезюмт 2, по методу резолюции мы получаем не больше, чем вот такая штука.
Да.
Хотим мы получить пустой дезюмт, то есть вот эта штука должна равняться нулю.
Мы смотрим сейчас на максимум, поэтому забираем на знак меньше равно.
Дальше мы знаем ограничение, что...
что каждая из дайотов это хотя бы единица, только переносим вправо, значит получаем, что сумма этих должна быть 2.
Откуда мы получаем, что это все должно быть в равенстве с единицей?
А раз это в равенстве с единицей, то каждая из дезюмтов это какая-то переменная.
Причем у нас было правило в методе резолюции, что мы можем провести резолюцию тогда и только тогда, когда в одном дезюмте есть переменная, а во втором есть ее отрицание.
Вообще у нас же неравенство есть, что у нас из D1 до D2 появится что-то, что не больше, чем вот модуль D1 плюс модуль D2.
Ну хорошо, давай, если формально рассмотрим.
Это не важно, суть не в этом.
Должно быть вот так.
Вот так.
Сейчас AD с волной это что?
Это новый дезюмт получаемый D1 или D2.
Вот так.
Даже не так, ну короче, это метод резолюции получаемый.
Вот.
И поэтому, ну окей, 0 поставим выше, больше равно ну.
D1 или D2 станет не превосходить двойки.
Ну не превосходите каждый больше 1, опять же решение только одно, это единственное.
Почему мы можем написать, что 0 больше правильного, чем вот это?
Мы же нашли другую сторону неравенства.
Какую?
Ну, что модуль D с волной больше равен 0.
Если модуль D больше равен 0, то мы можем получить модуль D, который будет 1.
А модуль D равный 1 нам не нужен.
Нам нужно именно, чтобы модуль D был не больше 0, равен 0.
То есть.
Равен 0 это то же самое, что не больше 0.
А больше 0 мы получаем.
Хорошо, модуль D с волной равен 0.
Но из этого следует, мне нравится как раз другую сторону, что 0 не больше, чем модуль D1,
пришло модуль D2-2.
Нас интересует получение.
Ну хорошо, допустим, ты получишь из этого что-то большее.
Это будет после дезюмта? Нет.
Нам нужно именно, чтобы достигалось это.
Нам все, что больше, нас не интересует.
Но, в принципе, это просто оценка.
Значит, она же может быть сильно больше, чем 0.
Может.
Да.
А теперь мы говорим, в каких случаях она достигается?
Достижение этой оценки возможно только в том случае, когда оба этих D1 и D2 равняются 1.
Ну хорошо, ты можешь, давай прям совсем, как ты хочешь, 0.
Все, что больше, нас не интересует.
Зачем нам это?
Мы хотим, когда достижение.
Ну почему у нас противорей?
Сейчас.
На самом деле, это неважно.
Мы же можем просто, когда угодно, вывести P и вывести не P.
Ну вот я и говорю, что чтобы вывести пустой дезюмп, нам понадобится переменная и ее отрицание.
Да.
Никак по-другому мы не можем.
Вот мы формально обосновали.
А у нас здесь сказано, что ровно один литерал с каждой письменой.
А, на первом один сказано?
Да.
А, все, сори, окей.
То есть глобально нам просто не хватит литералов, чтобы вывести противоречие.
Значит, есть хотя бы один выполняющий набор.
Вот.
И теперь...
Пауэром.
Давайте я еще раз проверю, какие задачи удаются.
Поверка на выполнимость.
Ну да.
Вот 33.
Проверка на выполнимость.
То есть просто делаем метод резолюции.
Как правило, это все заканчивается просто...
...выводом пустого дезюмпа, этот номер.
Ну что делаем?
У нас выписываем дезюмпты.
И здесь вообще самый простой способ как это решать.
Я все-таки предпочитаю не дерево здесь, а вот такую штуку.
Что-то типа а-ля явный вывод.
34рс не п или р или с.
5рс не п или не р или с.
6рс не п или не с.
7рс не п или не с.
Ну и начинаем творить чудо.
8рс не р или с.
не r или s выведется q или не r, дальше 9 p или r, q или не r выводится p или q.
Не нужно пока искать какой-то смысл, как я ищу последующие, просто
абсолютно тупо, влом, перебираю всевозможные варианты, возможно что-то хорошее
выведется. Все очень просто.
Не r или s выводится p или s.
Прикольное. Все прикольное закончилось, начинаю применять
двуместный, трехместный, чтобы получить двуместный.
11 жух, p или s, не p или r или s, выводится r или s.
Супер. 12 не r или s, r или s вывел s.
У меня теперь 13, q или не s, s вывел q.
Шестерку могу теперь убрать.
Не q или r или не s, с s вывожу не q или r.
15 не q или r, q вывожу r.
О, 5. Это у меня что, p или не q или не r, r вывожу p или не q.
17, p или не q, q вывожу p. Теперь смотрю, могу ли я вывести
противоречие всего этого добра. То есть я получил что?
Такое нехорошо. Давайте, вот так вот, жух, p получил, r получил, вот так вот.
Это можно, как только получили четыре переменных, проверяем просто на выполнимость
каждой дизюнт. p или r, плюсик, q или s, плюсик, плюсик, плюсик, плюсик, плюсик, минусик.
Все, получили минусик, значит из него просто начинаем вводить пустой дизюнт.
Все, 18 не p, там что? Не q, не s. Не p или не q или не s. У меня есть p вывел не q или не s.
19 не q или не s, есть q вывел не s. 20 не s, s вывел пустой дизюнт. Все.
Глобально начинаем просто хаотично вводить все что можно, до тех пор пока не вывели все четыре
переменных. Как только вывели все четыре переменных, проверили, что каждый из исходных
дизюнтов выполняется. Если выполняется, значит вывели выполняющий набор, его записали в ответ.
Если не выполняется, значит найдется какой-то дизюнт, в котором будет отрицание этого литерала.
Ну тогда просто берем по методу резолюции нужное количество раз, убираем все до пустого.
Вот эта задача халявная, ее делаем, лутаем один балл. 29, ну задача средняя,
может быть простой, может быть сложной, в зависимости от того, что дадут. Она желтенькая.
30 точно красная, для теста задачи слишком много гемора. И осталась задача 32.
Так, еще раз посмотреть, что там за задача. 30. РК-состояние значит выполнимость. Да.
Про вводимость говорили в прошлый раз, можете еще раз посмотреть, свяжите память.
Теперь от нас хотят формулу. На самом деле странно, что дают задачу про логику первого порядка,
не проходя логику первого порядка глобально. А пишите формулу выполнимость, которая коллективна,
потому что у каждой исходной формулы есть хотя бы два выполняющих набора. То есть нужно
написать преобразование, которое каждую формулу phi превращает в psi. Так что если есть и в phi два
различных набора, то psi выполнимо. Если у phi есть один выполняющий набор или phi не выполнимо, то phi выполнимо.
А теперь, я извиняюсь, сейчас один момент и зайду. Я вас удивлю, а именно вот то, что я
сейчас давал, мы это рассматривать не будем. И объясню почему. Потому что реальная задача будет
несколько иначе сформулирована, чем то, что вы видели до этого. 7 и 5 на резолюции. Так запускаю демонстрацию экрана.
Да, возвращаю сюда. Вот на этом забиваем. И в реальности задача будет выглядеть так. Вот как-то так. Думаю,
объем уже должен был удивить. Итак, задача будет такая, как очень любят давать что-то
связанное с графами. У вас изначально будет задан граф матрицей смертностями, то есть набор
переменных ПОВ. И вашей задачей нужно будет сгенерировать формулу из этого всего под данным
переменным. Не так, что вот это чудо какое-то приведите к преобразованию, а так что изначально
даны переменные и на основе их нужно построить. У нас здесь какие переменные, что есть? Матрица
смертности, то есть мы как-то закодировали ребра. И есть РУ. Переменные, которые обозначают
принадлежность вот ядру. В прошлом году было, по-моему, задача что-то там про клику.
Или в позапросто. Как решать задачу? Сначала мы начинаем просто записывать на языке кванторов
обычные формулы, как на мотоне эту штуку. Ну давайте думать. Ну нам нужно что? Нам нужно
ядро. То есть множество. Берем записку. Требуется установить, что существует ядро. Существует ка.
Прямо вот заберем записку. Существует такое ка, что между любыми, что между вершинами из ка
нету ребер. Это первое существо. Для любых в1 и в2, но я не хочу долбиться с индексами,
поэтому для любых в1, ой, в и в из в выполняется, что в и в не принадлежит е. То есть нету ребра
между в и w. У вас рассказывали про то, что такой граф? Ну не знаю, у нас просто не рассказывали.
Граф это пара из множества v и e, где e это некоторое под множество v2. То есть на самом деле граф
это некоторое множество и дальше под множество v2. Это множество, это множество вершин, а под множество
квадрата это множество ребер. Все. Причем это даже знаете, это своего рода ориентированный граф,
не ориентированный. Это c из v2. Просто множество двух сочетаний, но как мы понимаем, определение
два сочетания это двумястное под множество. Ладно, ставим. Хорошо. Этому потребуется, что нет ребра.
А любая вершина, а это союз объединяющий. То есть ставим конъюнцию. И любая вершина из vsk для
любой у принадлежащей vsk соединена с ребром, с одной из вершин v. То есть существует вершина vsk такая,
что uv принадлежит, смотрим внимательно, неориентированный граф, поэтому достаточно написать uv. Если бы был
граф ориентирован, то uv и vu разные, разные ребра, они по-разному идут. Поэтому если будет ориентированный,
смотрим обязательно на то, какое именно ребро нам нужно. Хорошо. И все. Вот мы записали, по сути,
условия. Сейчас. Любая вершина из этого. Сейчас еще раз давайте. Вот. С одной вершиной. Здесь еще
важное условие, что если бы было с хотя бы одной, то вот это условие видно, а тут с одной. Значит,
нужно существует и единственное. Теперь давайте, как мы будем это все раскрывать. Для этого нужно
углубиться в семантику кванторов. Оставим до следующего раза, пока просто поверим на слово,
что существует эта дизъюнция по каким-то там йод. Для любого это конъюнция. Ну то есть действительно,
что если существует, значит где-то один раз должна быть выполнена и все верно. Это дизъюнция.
А для любого, значит, должна быть выполнена всегда. Это конъюнция. Вот. Ну, существует k,
можем забить. У нас здесь не просят. Значит, теперь нам нужно будет упрощать как-то для любого vk,
и вот это. Существует k. На что нам нужно будет, во-первых, убрать принадлежит к. Для любых v,
для любых v2 переходим к принадлежащим v. Заданное множество v это сам граф. Выполняется,
что если они принадлежат к, то это верно. Мы же говорим, что принадлежит к, а принадлежит к у нас
это переменная ru. Если rv и rw, то тогда между ними нет ребра. Наличие ребра отвечает переменной uw.
То есть нет ребра uw. Хорошо. Супер. Следующим этапом надо как-то отойти от разницы множества.
Что значит, что u принадлежит v без k? Это значит, что u принадлежит v и при этом u не лежит в k.
И для любой u принадлежащим v, что выполняется, что из того, что не ru, то есть если она не лежит,
то существует единственная v из k. Такая, что у нас в верхней коричневой строчке не должно быть не uww.
Должно быть. Спасибо. Да, все верно. Хорошо. И теперь самое сложное, что есть в этой задаче,
это вот это вот кванторсуществование. Что значит кванторсуществование? Кванторсуществование.
Вообще, по-хорошему, кванторсуществование, что если он существует, единственное x такое,
что, знаете, phi от x. Defi какая-то формула. Хотя на самом деле мы даже не знаем, что такое формула.
Эта штука раскрывается как то, что существует x и для любого y выполняется, что phi от x и
из того, что x не равняется y, следует, что не phi от y. Но есть одно но. Вот эта вот штучка не равно.
Что такое не равно? Ну, можно сказать, что это отрицание x равняется y. Но мы все равно сохраняем
вопрос, а что такое равно? У нас нигде в номере не задано равенство. То есть мы не можем им пользоваться.
Значит, мы должны как-то это равенство выразить через то, что нам даны. В частности, нам сказано,
что... что... граф без петель... сейчас скажу...
Сейчас я подумаю и скажу вам...
Что если есть... у нас есть штука. Ну, давайте. Это существует ребро. Хорошо. Это... что если...
Сейчас я подумаю и скажу. Это через петлю надо сделать.
Вот я придумал. Как нам сделать неравенство? Неравенство мы можем сделать следующим образом.
Существует x. Это они принадлежат какому-то множеству. То есть существует x принадлежит множеству.
Давайте я его назову m. Для любого y принадлежит m. Выполняется вот это все. Как нам избавиться от равенства?
Давайте ему просто сразу скажем откуда y. Для любого y без x. У нас же x уже... мы знаем,
что это такое. Ну, все. Значит, мы можем это сделать. Тогда выполняется, что fiat x и не fiat y.
Супер. Тогда давайте вот при помощи этого продолжим упрощать вот это v и так далее.
Пока квантеры не снимаем. Сейчас позже будет понятно зачем мы все еще тянем с собой.
Вот эту штуку нам нужно будет заменить. А именно существует единственный. Мы заменяем как на...
Существует v принадлежащий v. Что для любого w принадлежащего v без v выполняется...
выполняется что? Выполняется, что если не ro у нережит множество k, то должно выполниться, что
r, v должно лежать в множестве k.
Что если r, v режет r, v, k и r, v... Ну да, то есть мы сказали, что они оба неравны, при этом лежат в нем.
То должно быть выполнено первое, что есть ребро между p, u, v и нет ребра между p, u, w.
На самом деле можно даже упростить до следующего момента.
Вот так вот. Вот давайте еще раз проверим, что для любого u, для любого v существует v такое, что не оно.
Но, что если u это k, эти тоже k, то тогда будет существовать ребро между u и v, но не будет существовать между u и w.
Все хорошо. А теперь мы просто начинаем вот этот вот квантор существования заменять на конъюнцию и дизюнцию.
Как мы его заменяем? Здесь нужно сказать немножко поточнее.
Существует... Можете, пожалуйста, еще раз пояснить последнее, что у вас получилось, что мы должны садусти?
А, сейчас я иду. Это вот чуть поподробнее, что это такое. Последнее, что у нас получилось.
Первые условия мы просто сохранили. Здесь все понятно.
Это просто условие на то, что между двумя вершинами, если они обе из k, то между ними нет вершин.
Ой, нету ребра. А вот нижнее самое. А нижнее. А теперь нижнее.
Первое, что мы говорим, что для любой вершины v найдется такая вершина v, что для любой вершины v неравной вершине...
Дайте, я просто буду продолжать. Для любой вершины u существует вершина v, да простите, да простят мой немецкий,
что для любой вершины v неравной вершине v выполняется, что если ru это не из множества k,
то эти две из множества k, помните вот эти вот, принадлежит где у нас, вот, то дальше выполняется это условие,
которое мы записали уже теперь чисто через переменные r и p. Глобально же, вот это что такое?
Это что для любой лежащей, а для любой лежащей ничего не понятно. Значит, мы просто возьмем, скажем, что вот если так, то то,
а дальше, ну, все что угодно условие не запрещает. Поэтому это превращается в импликацию. Все.
А теперь мы просто пользуемся вот этим вот свойством, что существует x принадлежит a, это то же самое, что для любого x есть a.
Ой, дизюнция по x принадлежащим a. Для любого x принадлежащего a, это есть конъюнция по всем x из a.
Это важно помнить. И важно помнить что? Что вот эти вот все дизюнции, конъюнции, которые мы в конце будем раскрывать,
большие формулы, должны обладать следующим свойством, что можно их проводить только по заданным множествам.
У нас заданном множество только одно g, это v и e. То есть мы можем брать конъюнции только по g, только по v, только по e.
Раз. И два, у нас было, было по-моему, будет еще требование, что это полинамиальное число. То есть можно
проводить сколь угодно конечное число вот таких вот конъюнций-дизюнций по заданным множествам.
Уходить в экспоненту то есть перебирать по всем под множеством. Вот самое реальное, где можно
нарушить Полином, это начать перебирать все под множество. Это нельзя делать. Нельзя делать
x под множество. По всем множеству x под множеством множественного v.
Это экспонента. Почему экспонента? Потому что всего под множеством это два степени v.
Видим сразу экспонент. Только явно по одному множеству итерируемся. Сколько угодно
раз. Никто вас не запрещает. Все. Последний этап. Этап замены. У нас везде допустимое
множество. В, В, В. Здесь тоже В. И причем мы итерируемся только по ним, как по
элементам. Не по множеству. Заменяем. Конъюнция это что? Конъюнция это дезюнция.
Конъюнция по В принадлежащим В большому. Когда через запятую понятно, что это для
любого В, для любого В выполняется что из РВ и РВ следует не ПВВ. Глобально вот еще раз,
если заметить закономерность в этих формулах. У нас в посылке идут ограничения на принадлежность
нашему множеству, а дальше идут просто та формула. Раньше мы писали через существует К,
теперь мы говорим что ну занесем принадлежность К в посылку в импликации. Точно так же здесь.
Это первая формула. Дальше нам нужна конъюнция. И вторая у нас была вот. И вторая это что?
Это большие конъюнции. То же самое что мы писали когда большие суммы, большие произведения,
пересечения, объединения, дизью. Вот это вот все. Точно так же когда писали еще больше XOR.
Точно так же это здесь. И у из В существует конъюнция ПВ. И теперь сама формула.
Не РУ. На самом деле можно прям так дальше писать не захламляя скопками. Не РВ. Следует что ПУВ и не ПУВ.
Все. Получили такую вот формулу. Эта формула будет ответом на задачу. На этом все. Если есть вопросы,
задавайте. Решение прошлых лет постараюсь выложить побыстрее. Но не гарантирую,
скорее всего будет понедельник. Ну а раз нет вопросов, задаю. Всем спасибо. Всем пока.
