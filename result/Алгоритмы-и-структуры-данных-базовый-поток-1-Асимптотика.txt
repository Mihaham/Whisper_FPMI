Сегодня мы будем говорить с вами о таком математическом аппарате алгоритмов, то есть
то, что нам будет необходимо в этом случае для того, чтобы работать с алгоритмами, чтобы понять,
что такое симптотики, как с ними правильно действовать, чтобы вы никогда не сталкивались
с проблемами в случае их. Самое главное, что такое алгоритм? Почему здесь написана эта база?
Не потому что вы базовый поток, не только поэтому, потому что на самом деле алгоритмы вам понадобятся
почти везде. Если посмотреть прагматично на эту точку зрения, если вы захотите пойти
стажироваться, вы скорее всего начнете с этого момента, с этого старта и даже типа на джуна,
на джуна плюс вам необходима будет алгоритмическая секция. В зе алгоритмической секции вы никуда не
пройдете почти, это сложно. То есть не только язык играет, а ваше еще мышление, поэтому это
очень важно. И вообще, что такое алгоритм? Есть предположение? Да, последовательность операции,
то есть 5 плюс 2 это алгоритм? Последовательность действий. 5 плюс 2 это алгоритм? Решает какую-то
задачу. Хорошо, так. Чтобы получить 7, нужно сделать 5 плюс 2. Это алгоритм получения 7. Хорошо,
на самом деле я не буду душнить в этом плане, я не буду вас спрашивать типа на экзамене,
что же такое алгоритм, какой-то конкретной вещи. Один из достаточно серьезных ученых сказал,
что очень много психологических проблем было получено в момент, когда искали разницу между
алгоритмом и программой. Запомните этот момент, потому что для вас это может быть плюс-минус одно
и то же, и это по факту может быть одно и то же. Но алгоритм это просто действительно какая-то
последовательность действий, приводящих к конкретному результату, который мы хотели бы. Можете сказать это
примерно так. Никто никогда в жизни вас особо не спросит, что такое алгоритм, а спросит какой-то
конкретный алгоритм, алгоритм сортировки. Вот тут будет важно уже. Ну и давайте с вами поговорим дальше.
Смотрите, я говорю, алгоритм работает за 0,5 секунды. Много ли информации вы из этого получаете?
Хорошая информация, отлично. А что не так с этим всем? С чем? Ну в смысле, ну не знаю, вот раз запустил 0,5 секунды.
Давайте еще раз. То есть, когда я говорю время, вам не нравится, что это время работы алгоритма,
правильно? Что вам понравится? Количество операций. Каких? Радных. Базовых? Возвращаемся к базе, я понял.
Хорошо. На самом деле, здесь мы придем ко всему этому. Сам по себе фраза алгоритм работает за какое-то
время, конкретное, очень редко несет информацию. Почему? Потому что это связано, что у вас разное
железо. Ну не знаю, кто-то там на компьютере 90-х годов сидит, кто-то там на 2020-м типа, а кто-то вот
сейчас, не знаю, с квантовыми компьютерами развлекается. Всех по-разному бывает. Поэтому здесь время
работы алгоритма никогда не будет означать конкретное время. Мы не будем говорить о времени, хотя в контестах
у вас всегда будет ограничение. Одна секунда, полторы секунды, 0,8 секунды и так далее. Здесь мы с вами
научимся говорить о, что же там происходит и как это примерно посчитать. Но, так как маме время не нравится,
мы будем говорить про асимптотики. Асимптотики нам помогут говорить о том, за сколько алгоритм работает в
зависимости от какого-то параметра. То есть здесь, когда мы будем с вами говорить об этом, мы скажем,
что вот у нас есть массив из n элементов, на нем алгоритм работает за n квадрат. Понятно это уже?
Понятно. Почему? Потому что если я возьму 10 элементов, мы скажем 100 операций. Если мы возьмем 100
элементов, то будет уже 10 в четвертые операции и так далее. То есть в этом плане вам будет это
достаточно полезно. Для этого нам нужно окунуться в матан. Такой вот базовый математический аппарат,
который используется в алгоритмах. Нам помогут следующее обозначение. Кто знает,
как прочитать все буквы? А? Т, Т, О, Омега. Все верно. Сейчас будем останавливаться на
каждый из них. И первое у нас будет о-обозначение. Смотрите, что такое о-большое? Вы часто могли
сталкиваться с тем, что вам говорят, алгоритм работает за о от n. Что это означает? Смотрите,
если я говорю, что у меня есть какие-то функции f и g из натуральных чисел в не отрицательные
действительные числа. У меня есть некоторые такие функции. Эти функции обозначают время работы,
а они зависят от n. Ну то есть грубо говоря, давайте представим, что у нас есть n элементов,
опять же, в массиве или просто число n. И вот от n время работы алгоритма, то есть количество действий,
будет зависеть каким-то образом. Мы не знаем точно каким, но вот может быть по-разному. Ну не знаю там,
2 умножить на n, может быть такое, да может быть. Нет никакой проблем. Так вот, мы будем говорить,
что о-большое от g от n, то есть от любой такой функции, это множество функций f от n. Такое,
что существует некоторая константа c больше 0, существует n0 из натуральных чисел, что для
любого n больше либо равного n0 мы говорим, что функция, она же у нас не отрицательная,
поэтому она больше либо равна 0, больше 0, и она меньше, чем c умножить на g от n. То есть смотрите,
о-большое означает, что если я вот это g от n возьму и умножу на какой-то конкретный элементик,
ну на какое-то конкретное число, и я знаю, что оно существует и взял именно его, тогда в этом
случае я сверху ограничу свою функцию. Вроде пока понятно. Хорошо, а давайте с вами посмотрим на это
все. Вот у нас есть некоторые примеры, что с ними делать. Вот кто мне скажет, вот если я пишу равно,
я что-нибудь нарушаю из математической логики, вот что-нибудь такое, а справа множество, это правда,
то есть по-хорошему я должен писать принадлежит, но это лень. Привыкайте к тому, что программисты
ленивые люди, они не будут писать что-то лишнее, поэтому будем писать равно или не равно. Все,
все достаточно просто. Давайте с вами разберем какие-нибудь простые примеры. И первая там 1,
вторая квадрат, минус n, и как это связано с u от n квадрат. Смотрите, в этом случае достаточно
просто что сделать. Достаточно просто брать и делать все по определению. То есть вот у меня есть
1, вторая n квадрат, минус n. Я должен найти такое c, что эта функция будет меньше, чем c на n квадрат.
Согласны? Ну чисто из определения о большого. Хорошо, вот у меня есть такая вот вещь. Достаточно
найти это c. То, что это больше нуля, это очевидно, я надеюсь, правда, начиная с какого-то нулевого.
Отлично. То, что здесь мы скажем, что c должно быть больше, чем 1, вторая, минус 1 делить на n.
Ну и из этого мы, исходя, можем сказать, что пусть c равно, например, не знаю, единичка.
Еще раз. Ну, например, можно взять единицу. Всегда это будет? Да всегда. Таким образом мы
ограничим это. Конечно, можно выбрать точно. Никто не спорит. Но это не обязательно. Нам нужно
доказать, что просто существует такое c, чтобы это было. Если мы с вами это нарисуем на графике,
то это становится ну просто очевидно. Вот у нас есть 1, вторая n квадрат, минус n. Она будет как-то
вот так идти на самом деле. Заметьте, она будет вот так по точечкам идти. Ну а n квадрат вот так.
Все, вот оно, решение этой задачи. Поэтому давайте ваше предположение. Верно ли второе? Кто за
то, что да? Кто за то, что нет? Чудесно. Хорошо. По поводу третьего. Это правда или нет? Давайте.
Правда? Неправда. Хорошо. Ладно, а последнее? Ой, нет, давайте n равно u от n квадрат. Это правда?
А кто считает, что это неправда? Ага, хорошо. Ну и последнее. Кто считает, что это неправда?
Хорошо, принято. Смотрите, давайте рассмотрим вот этот предпоследний хотя бы вариант. Мы говорим,
что у нас есть n и n квадрат. Мне нужно просто сделать вот так. Это всегда прецетом, например,
единички. Мы возьмем и c будет больше одного на n, начиная с какого n. Ну и ноль возьмем единичку.
То есть смотрите, o большое, оно ограничивает как бы сверху, это правда, но я могу бесконечно
уходить там до n в степени n. Я могу сказать, что функция o большое от n в степени n. Хорошо это
или плохо? Плохо. Мы ничего не понимаем. Ну, типа, очень странно, что у меня алгоритм работает
за u от n, за n точнее шагов, а мы говорим, что он работает за u от n в степени n. Так вот,
всегда, когда пытаются писать o большое, ищут ту грань, которая является еще самой близкой и
необходимой для нашего какого-то множества. Естественно, если я напишу, что это u от n квадрат,
а не u от n, ничего не изменится. Это действительно будет все еще правда. Поэтому с этим аккуратно.
Если я вдруг вам говорю, что алгоритм работает за u от n в степени n, вы должны сказать,
это правда, но есть получше. Вот. Все достаточно легко в этом плане. Есть вопросы к o большому? Да.
А когда n будет больше, чем n квадрат? Н не умеет быть больше n квадрата.
Хорошо. Так лучше? Да. Начиная с какого-то момента, вы должны к этому прийти. Ну да, смотрите,
давайте еще раз, я вернусь назад. Видите, вот здесь я выбрал 0. Видите, синий отмечен. Вот именно
с этого момента наша функция c от g от n становится выше. То есть до этого она могла быть ниже,
и в этом нет никакой проблемы. Нас интересует момент асимпатический. Асимпатический означает
на бесконечности. То есть начиная с какого-то момента и бесконечно, это становится правдой.
Что мы выиграем? Мы выиграем в том, что мы не считаем конкретное количество действия,
говорим за сколько это работает. Смотрите, объясню. Когда мы будем говорить, что алгоритм работает,
к примеру, за o от n, мы еще дойдем до некоторых условностей, которые мы будем использовать при
почете, за сколько работают алгоритмы. Это отдельная вещь. Но в том суть, что это нам поможет оценить
и как-то сравнивать между собой алгоритмы. Вот и все. Бывают алгоритмы, у которых вот эта константа,
грубо говоря, вот эта вот константа очень огромная, прям гигантская. И тогда алгоритмы
бесполезны. Это правда. Ну, то есть легче использовать другой. Но если мы рассмотрим это где-то на
бесконечность, ну, то есть, не знаю, вы работаете там с пятабайтами, Дана, то там уже этот алгоритм будет
выигрывать. Давайте еще раз объясню. У нас есть функция f и g. Она идет из натуральных чисел в
неотрицательные числа. Вот эта функция, грубо говоря, подсчитывает количество действий вашего
алгоритма. То есть, у меня есть какой-то вход, который зависит от n. Это может быть длина массива
n элементов. Это может быть само число n, как из примеров. И что тогда в этом случае происходит?
Вот эта функция будет показывать мне количество действий. А так как она показывает количество
действий, то я осознаю, если у меня каждое действие работает там за какой-то 1, одну условную единичку,
то я осознаю, что на бесконечности это будет как n квадрат вести себя. Понятно? Есть ли еще какие-то
вопросы пока к этому кусочку? Нет? Тогда переходим. Вот как бы ответ, на всякий случай. Если будете
потом просматривать, запомните. Омегабольшое обозначение. Смотрите, омегабольшое это то же
самое, что о-большое, но снизу. То есть, о-большое, оно ограничивает сверху, омегабольшое ограничивает
снизу. Вот здесь вы можете видеть такую вот функцию. То есть, мы говорим о том, что у нас существует
некоторая константа, что у нас вот так вот все происходит. С точки зрения математического аппарата,
мы будем говорить, что это действительные числа. С точки зрения алгоритмов, да, они будут переходить
в какие-то числа. Но важный момент, у нас могут возникать вот такие вот коэффициентики. В среднем
случае бывает такое, что когда мы будем оценивать с вами средний случай, там будут какие-то коэффициенты,
и там будут недействительные числа. Понятно? Смотрите, омегабольшое показывает нам,
ниже чего не упадет эта функция. То есть, грубо говоря, мы скажем, что оно не может идти меньше,
чем за о от н квадрат. Это означает, что линейно мы никогда этого не сделаем. И это нас устраивает.
То есть, мы хотим увидеть тот предел снизу, который нам показывает, что мы вообще можем. Вот и все.
Еще какие-нибудь вопросы есть? То есть, по определению, это то же самое, только наоборот.
Окей? Да, это существование ко всему. Теперь, что касается омегабольшого. Давайте с вами
рассмотрим здесь примеры. Верно ли, первое, кто считает, что да? Раз. А? С можно? Нет. Существует
С большее нуля. Иначе мы тогда любые функции писали. Это правда или неправда? Да, давайте. Кто
считает, что правда? Ага. А кто считает, что не правда? Ага. Все как на меме. Сначала было радостно,
потом становится грустнее. Давайте с вами разберем этот пример. Давайте я вот здесь где-нибудь нарисую.
Мы говорим, что в какой-то момент c от n квадрат, что она должна сделать? Она
должна быть меньше, чем 1 вторая n квадрат минус n. Ну скажем, что c меньше, чем 1 вторая минус 1 на n.
Ну при n, к примеру, равным 2, давайте 3. 0 возьмем 3. У меня c должно быть меньше,
чем 1 вторая минус 1 третья. Ну это сколько? 1 шестая. Ну давайте возьмем 1 десятую. Все.
Вот оно, что нам помогает. То есть смотрите, здесь мы можем говорить, что мы вот так вот снизу
ограничиваем. Поэтому первое это правда. А вот правда ли второе? Правда ли, что 1 вторая n квадрат
минус n это омега большое от n? Давайте. Кто да? У нас сегодня соцопроцеп просто, я настроение в целом.
Так, хорошо. А кто считает, что не правда? Нет таких людей. Вы не забывайте, что иногда большинство
умеет ошибаться. А кто считает, что последнее это правда? А не правда? Хорошо. Сейчас вы на друг друга
смотрите и кто поднимет, кто не поднимет. Действительно, первое, второе действительно правда,
а третье не правда. Вот. Это достаточно простые вещи. А теперь перейдем к еще более интересной
вещью. Т это обозначение. Т это обозначение это то же самое, что омега и о большое вместе взятое.
То есть мы можем выбрать константу c1 и c2 для одной функции g, что она зажмет нашу функцию f.
Пересечение? Да, это оно и есть. Все правда. То есть смотрите, что такое это большое? Мы просто
выбираем некоторые константы c1 и c2, умножаем на нашу функцию g и говорим, что если мы возьмем
константу c1, то она будет подпирать нашу функцию снизу. Если мы возьмем нашу константу c2, то она
будет подпирать нашу функцию сверху. И мы таким образом выбираем конкретные функции, которые к
этому относятся. Т это самые прелестные функции. Они сложнее всего находятся, но они самые чудесные.
Почему? Потому что в этом случае мы точно можем сказать, как асимпатически ведет себя функция. То
есть да, может быть у нас могут быть некоторые проблемы с коэффициентами, но в то же время
асимпатически мы явно указываем, как ведет себя та или иная функция, то есть то или иное количество
действий. Классно? Классно. А что? Нет, почему? Это целое множество. Давайте посмотрим с вами на
первый пример. Правда это или нет? Да. Отлично. Тогда вы не такая девочка, как здесь. У вас все-таки
есть праздник. Вот. Окей. Правда ли последняя? Да. А правда ли второе? Смотрите, не второе,
не последнее, не правда. А нет, последняя правда, извините. Там n-куб. То есть в этом случае мы говорим
о следующем, что действительности мы можем зажать. Давайте распишем на всякий случай тету,
чтобы вы еще раз поняли, как это сделать. Вот у нас есть некоторая функция, одна вторая,
n-квадрат минус n. И мы говорим, что она с одной стороны больше, чем c1, n-квадрат,
а с другой стороны меньше, чем c2, n-квадрат. Тогда в этом случае опять же разделим на n-квадрат и скажем,
что c1 меньше, чем 1 вторая, а минус 1 делить на n и больше, чем c2. Согласны, что если я c2 возьму
1 вторая, то всегда все хорошо. То есть это я могу сразу сделать. Ну а это мы уже с вами разбирали.
И вот так мы получаем эту вещь. То, что это правда. Окей? Все просто. Как-то у нас очень быстро идет.
Есть у меня ощущение, что мы можем очень быстро закончить сегодняшнюю лекцию. Неужели у вас нет вопросов?
И вы сейчас спокойно мне будете рассказывать, как и что сделать. Что еще раз?
Презы по алгосам будут немного в другом месте, но да, я конечно их скину. Вот. У вас доступ к ним будет,
если захотите. Ок. Теперь связь. Взаимосвязь теты, о большой и омега. По факту можно сказать,
что если у нас функция лежит во множестве тета большое, то она лежит и в о большом, и в омеге
большом. По факту их пересечение равно. Все просто. Вот. Ну здесь я сделал как следствие,
что тета лежит и в о множестве тета. Оно является под множеством о большого и под множеством
омег большое. Вот. А здесь, кстати, почему-то здесь не отобразилась фигурная скобочка. Извините.
Странно. У меня она была. Но ничего страшного. То есть здесь мы просто с вами говорим о том,
что эти вещи друг друга заменяют. И если вы нашли тету, то вы сразу знаете и о большое.
И омега большая. И это хорошо. Но найти тету категорически сложно. Бывает. Бывает очень просто.
Всегда по-разному, в зависимости от алгоритма. Бывают такие алгоритмы, которые не имеют какой-то
конкретный тет. Не может быть такого. Например, кто из вас знаком, что такое быстрая сортировка?
Есть такие. За сколько в худшем случае она работает? Нет. В худшем случае она работает за
n квадрат. Именно из-за этого у нас начинаются вопросы. Поэтому здесь не всегда можно сказать,
что у нас алгоритм работает за столько. И мы к этому тоже перейдем. Как нам смотреть,
за сколько работает тот или иной алгоритм? Вопрос следующий. Смотрите, у вас есть логарифмы.
Очень часто в алгоритмах пишут от логарифма N. Почему я могу так писать? Потому что да,
я могу привести к любому основанию, который у нас есть. Я могу взять основание вот здесь,
вот A, и получить его из C. Или наоборот. Просто снизу заметьте, что логарифм A по основанию C это
всегда константа. Какая-никакая, но константа. А это означает следующее, что если я домножу на
константу, то все хорошо. А это уже без разницы, потому что в C2 и в C1 добавлю эту константу.
Ладно, ничего страшного. То есть константа здесь для нас не играет большой роли. Именно поэтому
всегда в алгоритмах я буду писать что-то вроде алгоритм работает за O от логарифма N. Вот это будет
выглядеть именно вот так. Что еще раз? Какой X2? Ну, это ничем не отличается, просто заметьте,
что я основание не пишу. Вот типа у X2 хотя бы степень пишу. Если бы я не писал степень,
это было бы уже что-то интересное. В данном случае я объясняю лишь это, потому что бывают алгоритмы,
которые пополам делят типа бинарного поиска. Пополам делят, пополам. Там двоичный логарифм,
но я буду всегда все равно писать логарифм АТ. ОК или есть вопрос и непонимание? Какой? Вот это?
Вот это? Еще? Хорошо. Вы говорите, да, если я спишу. А это сложно? Оно долго? А что сложного? Ну,
это недолго. Если ты понимаешь, как это выглядит, ты напишешь. Ну, это за минуту мне. Вот. Большая
ноль от пресечений того и другого? Да, да, да. Вот. Тета под множество О и тета под множество
Омеги большое, да. Что не нравится? Задумайтесь об этом. ОК. Мы реально очень быстро идем. У меня
всего там 25 слайдов. Что-то такое. Вот. А? Блин. Ладно. Ну ничего. Сейчас я назову какие-нибудь
слова по типу мат ожиданий, вам не понравится, поэтому все будет просто. Ничего страшного.
Смотрите. При использовании некоторые модели мы будем проектировать, ну типа,
говорите на... Друзья, давайте это чуть-чуть сбавим тон. Спасибо. При исследовании алгоритмов мы
будем использовать какую-то конкретную модель, с которой будем работать. Что под этим подразумевается?
Под этим подразумевается следующее. На практике мы что будем писать? Мы будем писать какую-то программу
на конкретном языке программирования на каком-то конкретном компьютере. Если здесь есть какие-нибудь
кто-нибудь из любителей, не знаю, чего-то более старого, скажем, как его, оператор ВМ, вот назовем
вас как-нибудь так, если вы хотите, а не разработчик. Что это означает на теории,
к чему мы вообще придем? То есть если на практике мы используем именно это, то что будет дальше?
Что у нас будет вместо программы? Как вы думаете? Алгоритм. Хорошо. Что у нас будет вместо языка
программирования? Смотрите, мы будем писать действительности на псевдокоде. Псевдокод это
какая-то помесь питона с плюсами. Будем считать это таким вот образом. Если кому-то очень в кайф
школьно-алгоритмический, вот этот вот, восхитительный на русском языке, я откажусь от этого, но вы там
можете сами попробовать. Я, пожалуй, не буду. А что вместо компьютера? Как вы думаете? А? Бумага?
Нет, нет. Вот что я могу представить тебе? А? Я, конечно, хорошо, но нет, не машина. На самом деле,
некоторая модель вычислений. Модель вычислений того, что у нас произойдет. То есть вместо компьютера
мы будем представлять некоторую абстракцию сами по себе. Мы не будем использовать чего-то конкретного.
И у нашей модели вычисления, что она вообще должна позволять, что она определяет? То есть что
определяет вот та или иная модель вычисления? Она определяет допустимые операции и сложность
каждой из этих операций. То есть любая модель это делает. В нашем курсе мы будем использовать
RAM-модель. Random Access Memory. А? Ладно. Хорошо. RAM-модель это модель, сейчас мы ее посмотрим тут
на картиночке. Ее можно представить вот так. У нас есть некоторые такой вот, грубо говоря,
регистры. Вот их от нуля доим минус один. У нас есть программа, которая общается с нашим процессором.
У него там есть регистры, они как-то внутри там ходят. Вот это все происходит там. Почему она называется
Random Access Memory? Потому что мы в любое место можем взять и заглянуть и вот туда записать. Мы не влияем
на то, как компьютер выбирает то или иное пространство, грубо говоря. То есть мы здесь просто берем и
используем, что типа окей, запишем туда. Потом окей, запишем туда. И мы ничего не будем с ним делать.
То есть как он хочет, так он и делает. Давайте я задам, у нас все равно времени много. Задам вам
интересный вопрос. Много из вас знают о том, что такое битная система. Сколько бит на вашей
системе? Вот у вас винда там 32 бит, 64 бит. Да? Нет? Да? Нет? Да? Ну интересно, что вы этим никогда
не интересовали. Смотрите, существуют некоторые системы, ну точнее все, они имеют какую-то
разрядность. И вот эта разрядность означает, вот видите W там написано. Это как раз таки машинное
слово, с которым идет. То есть какое есть у нас машинное слово. Все равно у нас сегодня такая более
развлекательная, надеюсь, лекция. А это машинное слово сколько-то имеет размер. Вообще среди
регистров там есть от нуля до M-1. И вот есть такая вещь, что я могу сказать, что если у меня 32-битная
система, а у вас почти наверное 64-битная система, то количество оперативной памяти в ней не более
4 гигабайт. Как вы думаете, почему это связано? 2 в 32, правильно. Да. А почему это правда? Почему
2 в 32? Что происходит? Размер адреса. Вопрос в размере адреса. То есть размер адреса не более 32
битов. Но мы не можем больше, чем машинное слово, иметь размер адреса. Иначе как он будет обращаться?
То есть вот эти вот вещи будут друг другу как-то сообщаться. Нам необходимо это сделать. Как это
сделать? Ну, посредством адресов. Адрес не может иметь значение больше, чем 2 в 32. Потому что у меня
слово машинное, оно имеет 32 бита. Там везде 0 или 1, 0 или 1. Количество вариантов 2 в 32. Надеюсь,
вы это считать умеете. Это означает, что столько у нас есть памяти. Поэтому сейчас у нас 64-битная
система. Там уже 2 в 64. Я думаю, оперативной памяти на всех хватит. Машинное слово это сколько
ячейку у нас есть. То есть процессор, там есть некоторые регистры. Вот они расположены по
машинному слову, грубо говоря. Вот максимум хранят. Вот. Имеют какие-то, ну, регистры имеют
какие-то адреса. И вот максимум, что там можно придумать этим всем, это 2 в 32. Больше нельзя. Да.
Да, да. Кроме того, вы столкнетесь с выравнивыми в плюсах однажды, когда будете со структурками
общаться. Но мы будем считать на алгоритмах, что мы получаем информацию за это от единицы. Вот. И это
сейчас я скажу. Что мы считаем в рамках этой модели? Мы считаем в рамках этой модели, что любые
простейшие арифитические операции, плюс, умножить, делить, взять и остатка, это, ну и минус, это,
стоит это от единицы времени. Что такое это от единицы? Ну какую-то константу. Ну по факту одно
какое-то действие мы считаем, что это одна единичка времени. Вот. Кроме того, записать и считать одно
конкретное число тоже будет стоить это от единицы в этой, в условиях этой модели. Я больше к этому не
вернусь. Сейчас такая просто вот лекция обо всем, что нас ожидает, но оно выглядит вот именно таким.
Понятно, что происходит в этой модели? Да. Не всегда. И что такое большое число?
Десять шестой небольшой число. У тебя очень сильные вычислительные мощности. Знаете,
типа, как это, как это назвать? У тебя сейчас телефон лучше считает и лучше все делает,
чем то, что отправил человек на Луну. Но ты не воспринимаешь это и думаешь, что типа это все
равно не очень. Но с помощью этого люди отправили человека на Луну. Просто вот огромная стопка с
перфокарт и вычислительной машинкой. А дальше они там всю миссию построили Аполлон. Вот. Можно
такое? Ну можно. Поэтому здесь как бы нельзя говорить большое. Скорее так. Число. Вот. Но
для интов мы будем считать, что это быстро, все равно все работает. Они считаются вычисления здесь
достаточно быстро. Так вот. Да. Это одинаковое по стоимости операции. Да. Ну здесь это будет
одинаково. Как бы с точки зрения программы, когда вы ее закинете на контест, ну там разница может
быть в милли-милли-милли секунды. Типа очень маленькая. Это не тот случай, когда это будет
действительно много-много стоить. Вот. Много-много стоит. На самом деле арифметические операции
гораздо больше стоят, чем бинарные операции. Ой, бинарные, господи, побитые операции. Сдвиги,
вот такого характера. Это очень быстрая операция, потому что они работают напрямую с битами. Да.
Нет. Давайте еще раз. Тетто. Это множество функций. Вот в данном случае это от единички. Что
подразумевается? Тетто от единицы. Ну по факту это то же самое, что тетто от n в степени 0. Мы
говорим, что это множество функций. Я сейчас кратко напишу. Это множество функций от n. Таких,
что там существует для любого и так далее. Что c на n, c1 на n0 меньше, чем f от n, меньше,
чем c2 на n0. То есть какое-то константное количество времени. Вот это тетто от единички. Еще раз.
Тетто показывает множество функций f, а не вот этих. То есть они по отношению к этому числу ищут
множество функций. Вот я только что тебе написал. N в степени 0 чему равно? Единица. Ну если это не
0 в степени 0, хорошо, но типа мы не считаем таких случаев. Вот это единица. Я говорю, что моя функция f,
по факту, что это означает? Если у меня есть какая-то функция f, то она, вот у меня 1 это c2,
вот это c1. Я говорю, что моя функция, которая вот там вот f от n, она вот где-то вот тут вот колебается.
Понятно? Так стало понятнее? Тетто от единицы это множество функций. Безусловно.
Это множество функций, для которых вот выполнено вот это. Кроме того, существует вот единица. Это тоже
самое, только сверху ограничение. То есть оно не выйдет выше какой-то константа. Вот. Да.
Еще раз. Это работает, потому что мы работаем.
Ну нет, смотрите, мы можем взять любые числа, любые числа, которые работают в нашей типа машинном
слове, типа которых хватает. Вот мы возьмем этих, возьмем. И дальше типа тетто от единицы будет
показывать, что мы за какое-то константное время их сложим, поделим, умножим. Все. То есть это не
такое, что мы точно берем 5 и 7, вот для них оно работает за тетто от единицы, а для 3 и 11 может не так.
Да, конечно. Да. Но я более того скажу, если я возьму три числа и сложу их, то первое сложение будет
тетто от единицы, второе сложение тетто от единицы. Если я складываю 2 тетто от единицы, я получу тетто от единицы.
Просто с более широкими рамками. Но мне не интересуют рамки, меня интересуют и симпатически. Поэтому
это тоже самое будет. Вот если я Н раз повторяю, то это уже тетто от Н. Потому что от Н зависит.
Еще вопросы есть? Нет. Ну хорошо, тогда это последний слайд, который я для вас сегодня подготовил. Это
времена и сложности алгоритма. То, с чем мы будем говорить больше всего. Пусть у нас есть множество
входов. Что такое множество входов? Ну вот я могу взять числа от 1 до 10 в 9. Вот это множество входов,
к примеру, когда подается одно число. Может быть такое? Может быть. И как-то на нем алгоритм работает.
Пусть у меня есть какой-то конкретный input. Вот здесь неправильно немножко написано, здесь не
тинпут принадлежит и от Н, а input принадлежит и от Н. У меня есть множество и от Н. Что такое
тинпут? Тинпут это количество действий, сколько я сделал. Поэтому оно не лежит во... Вы на меня
смотрите, мне страшно, что вы меня не понимаете. Давайте еще раз. Я чуть-чуть перепишу, потому что
я ошибся, видимо. Вот у меня есть множество входов. Это сколько я могу вообще делать всего? У меня есть
некоторый input, который из этого множество входов. Ну не знаю, я выбрал число 5. Это input. У меня на input
ну в одной задаче может подаваться что? Число от 1 до 10, 9 одно число. Могу я так делать? Могу. Вот в
этом случае какой-нибудь input, ну 5, 7, 10, 11. Это просто элементы этого множества. А t от input
это что? t от input это на самом деле будет время работы, количество действий нашего алгоритма. Да.
Множество входов. Давайте еще раз. В задаче сказано, принимается на вход одно число. От 0 до 10 в
9. Множество входов. Все числа от 0 до 10, 9. Вот. Если два числа от 0 до 10, 9, то это пересечение
Декартовым. Ой, пересечение, господи, умножение. Вот. И что мы тогда можем выделить в этом случае?
В этом случае мы можем сказать, что лучшее время это просто минимум по всем input. Да.
Еще раз. Если n чисел и 10 в 9, ну да. Ну 10, 9 от 0 до 10, 9 в n, ну типа это умножение просто множество.
Вот. Это не 10, 9 в 9n. Нет. Число так и останется 10, 9. Вот. А в лучшем случае, но это минимум по
всем input'ам. То есть мы берем по всем input'ам, проходимся и говорим, что вот тут меньше всего
количества действий. Может быть такое? Может. Вот. Что такое в худшем случае? В худшем случае это
максимум. Вот. Когда я спросил, за сколько на их худшем случае работает быстрая сортировка,
она работает за n квадрат. У нее есть такой худший вариант, когда все плохо. Мы его разберем. А? А там
невозможно за ноль. Подумай почему. В лучшем с некоторыми добавлениями за o от n, так за n log n.
Это в худшем случае. А что происходит в среднем? Вот смотрите, у меня здесь стоит значок суммы,
потом p, а потом t. Что такое p? Вероятность. То есть смотрите, насколько вероятен тот или
иной вход. Правильно. Это правда. Вот. Но я не буду таких слов говорить. Ничего не знаю. Это вероятность
какого-то входа на время этого входа. Пока что мы будем определять среднее время как-то так. Что
под этим подразумевается? Почему вероятность умножается на вход, на время этого входа и так
далее. Бывает такое, что, к примеру, в задачах на графах вам скажут, у вас будет граф почти плотный.
Почти плотный означает, что количество ребер примерно n квадрат в этом графе. Ну, асимпатически.
А отсюда разреженный граф. Это где у нас n ребер в графе. То есть разреженный. Мало ребер.
Sorry. То есть разреженный. Это еще раз. Мало ребер. Плотно. Это много ребер. Может быть такое может.
И тогда в этом случае у вас по факту распределение вот этих input оно смещено. Оно смещено в одну
или другую сторону. Или вам сказано, что вам даны все числа от 0 до 10 девятый на вход, но число,
не знаю там типа, число выпадает чаще с вероятностью количества цифр в нем. Оно более вероятно,
если в нем меньше цифр. Может быть такая задача. Ну, может. Это странная задача, но может быть. И здесь
вопрос в input. Чаще всего мы будем говорить, что у нас все равновероятно. То есть нам
равновероятно выдали типа массив из 10 чисел, к примеру. И эти числа, они между собой могли бы стоять
равновероятно в разных сторонах. Вот. Мы будем рассматривать именно равную вероятность. Чаще всего.
Потому что у нас в ход мы не будем какой-то такой особенный делать. Но знать такое надо. Окей. Вопрос.
N это количество вершин. Sorry, если не сказал, да. Вот. Таким образом это происходит. А теперь давайте
с вами поговорим о самом главном. В чем практическое применение всего, что тут увидели? Для чего это надо?
Так как вы чаще всего будете с О большим встречаться, мы поговорим больше про О большое. И что вообще с
ним происходит. Сейчас. Смотрите. Представим, что вам сказано. Вот вы сидите на контесте, вам говорят
в таком титоге, вы волнуетесь, не понимаете, что происходит, куда что писать. У вас стресс, первая сессия
и все. Ну вот вам написано задача. Ограничение 1 секунда. Какой-то конкретный задач. И вы смотрите,
что, не знаю, N, от которого зависит весь алгоритм здесь, он может быть от нуля до там 10 в 9. К примеру.
Хорошо. Что же делать? Что же делать? Как же быть? Что мне вообще нужно сделать? Предположим,
что это сортировка. Это количество элементов в нашем массиве. Вы знаете, ну блин, напишу пузырек.
Пузырек топ. Мне надо. Пузырек работает за O от N квадрат. Количество элементов в массиве. Пока я
просто говорю рандомные фразы, просто примите, что существует какой-то алгоритм сортировки за N
квадрат. Может быть всем известный пузырек. А существует другая сортировка. Например,
что мы только QuickSort мучаем? MergeSort. И MergeSort работает всегда за O от N логи. А теперь давайте
смотреть. У нас всего одна секунда. Надо нужно прикинуть количество действий. Мы знаем,
что там константы плюс-минус небольшие, поэтому можно на них подзабить. Ну так, относительно,
если будет где-то большая константа, я вам обязательно скажу, но такого пока нет. А вот
здесь вот N квадрат. Что это? Это 10 в 12 действий. Много или мало? Как вы думаете, для плюсов?
Много. Плюсы примерно 10 восьмое действие могут выполнить за одну секунду. 10 восьмое,
где-то 10 в 9 в лучших случаях. Ну так, плюс-минус. Но ориентироваться лучше на 10 восьмое,
потому что у вас константа, можете сыграть еще что-то. А здесь 10 в 12. Кто мне скажет,
как дольше, чем одна секунда это будет работать? Это работает 10 в четвертый секунд,
что кажется не очень адекватным. Если кто-то хочет, может взять калькулятор, посмотреть,
сколько это времени. Не очень приятно, я сразу скажу. Ну, три часика, я бы сказал.
Вот. То есть, как бы весь контест потратим на вашу сортировку, чтобы она сделать. Или мы можем
рассмотреть другой алгоритм, который работает за N log N. Что в этом случае? Это 10 в 6 на логарифм,
но даже двоечный возьмем 10 в 6. Что нам дает эта шестерка? Эта шестерка, вы с логарифмами знакомы,
я надеюсь? Да, отлично. Мало ли, все бывает. Это означает следующее, что эта шестерка я могу
вынести сюда, а 2 на логарифм 10 по основанию 2, но это не больше 4, потому что 10 меньше 16. Вот.
Поэтому я скажу, что это 6 умножить на 4 умножить на 10 в 6. То есть, это будет 2 и 4 на 10 в седьмой
действии. И этого мне хватает на одну секунду. То есть, здесь количество действий чудесное. Оно
мне дает все, что мне необходимо. И тогда, после того, как вы в голове это быстро сделали, вот это
вы должны уметь в голове прокручивать. А тогда в этом случае вы сделаете итоговый контест. Если
вы не умеете прокручивать, вы не сделаете. Да. Ну смотри, с точки зрения константы нам не сильно
важно, но на самом деле в мерсорте будет основание 2. Ну даже если я возьму здесь 3,
ну что сильно, что-то изменится. Ну нет, у нас максимум вот эта константа будет меняться,
и то она будет уменьшаться, если взять другое основание. Вот. Ну все. Понятно вам, как вот это
вот происходит? Я надеюсь, что вы будете аккуратно использовать те или иные алгоритмы, иначе это будет
очень сложно и грустно. Вот. А чего еще вам такого рассказать вообще про алгоритмы? Смотрите,
с точки зрения анализа у нас будет еще так называемый амортизационный анализ. Это будет
позже, это будет интереснее. Там мы будем в среднем случае что-то искать. Пока до среднего случая
мы будем с вами смотреть, наверное, в только в квиксорте когда-то, в быстрой сортировке,
как только дойдем. А как у нас вообще будут построены все лекции? Во-первых, я призываю вас
приходить очень. Мне очень нравится, когда вы здесь, но если вам очень не нравится, что я могу сделать?
Вот. Если что, можете всегда давать какую-нибудь обратную связь, могу вам что-нибудь порассказывать.
Я не обижаюсь, я человек спокойный к критике, просто можете рассказывать, что вам нравится,
что вам не нравится. Вот. Это раз. Во-вторых, нас ожидает на следующем, мы будем говорить с
вами про рекурренты и немножко про бинарный поиск по ответу. Потом мы начинаем уже сортировки.
И у нас будет много лекций про сортировки, целых четыре. Как вы думаете, какие? Так. Ну, смотрите,
у нас будет на самом деле квадратичные сортировки, их три штучки. У нас будет три штучки
логарифмические. Каждую логарифмическую я буду рассматривать отдельно, которая за НЛоган работает.
Это быстро, это мерч, это хип-сорт. Вот. А после этого мы будем переходить к интересным темам,
уже прям вот интересным-интересным. И в какой-то момент под конец у вас будет,
ой, мне так нравится, это называется сплей дерево, но я не знаю, всем оно не нравится больше в какой-то
момент. Так что можете спросить у кого-то постарше, кто слушал про сплей дерево, поняли они его или нет.
Но это как пример. На самом деле весь курс алгоритмов в этом семестре он не затронет какие-то
вещи, связанные с графами. Они будут позже, потому что вы будете писать структуру данных позже. Пока что
весь курс алгоритмов будет завязан на чем-то, связанном с массивами и как-то с этим работать. Вот.
Есть ли у вас какие-то вопросы?
Для алгоритма размеры N. Под N подразумевается вход, тот самый вход N. Ну, то есть, к примеру,
это может быть число, когда вы проверяете его на простоту, там зависит от самого числа,
сколько оно весит, а может быть количество массивов. Подразумевается здесь вот это N,
которое неопонятно. Я не могу сказать, что это обязательно массив, я не могу сказать обязательно,
что это число. Вот. Нет, конечно. Только, а здесь у меня будет вопрос к вам, когда мы это
пройдем. Почему некоторые алгоритмы сортировки, которые работают за квадрат, работают лучше в
некоторых условиях, чем алгоритмы за N. Мы не учим просто так. Еще раз. Нет, нет, нет, не только. Я
более того скажу, спасибо, чуть-чуть фальстат. Я более того скажу, что вот есть внутренние STD-сорт
и так далее, которые вы будете использовать уже в следующих семестрах. Ну, это внутренние алгоритмы
уже написаны. И там до 100 элементов будет считаться пузырек, а все, что свыше 100, уже будет считаться с
помощью N log N, быстрой сортировки. Подумайте почему. Ладно, все, не буду вас задерживать. Пока-пока.
