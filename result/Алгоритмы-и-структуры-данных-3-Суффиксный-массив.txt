Leave the room
мы сегодня говорим про суеткостный массив, поднимите, пожалуйста, лапки тел,
у кого была населена суеткостная массив, чтобы я понимал, что сейчас происходит.
так, ну что ж, давайте смотреть пусть у нас есть строчка.
наша задача отсортировать все суффиксы этой строки.
пустой суффикс, наверное, мы не будем рассматривать.
все такие суффиксы, все вот такие строчки, рассмотрим.
и мне нужно их отсортировать в лексикратическом порядке.
ну понятно, поскольку все эти строчки разные длины, значит они все попарно различны,
значит на них однозначно поделен порядок строгого возрастания.
вот такое, значит, определение.
суффиксным массивом вот этой строки, строки с, называется перестановка
п0, п1, и так далее, по n-1, такая, что суффиксы, начинающие с позиции п0,
меньше суффиксы, начинающие с позиции п1, и так далее, меньше суффиксы, начинающие с позиции pn-1.
ну давайте я напишу вот так вот сначала.
если я использую диапресс с верхним индексом g, это, собственно, суффикс начинающий с g-той позиции.
простое определение, просто строгая суффикс.
вот, наша мечта найти такую перестановку.
да, такие все у нас мечты, конечно.
давайте сразу же определим еще все, что нам надо, давайте еще определим массив lcp.
ну не столько определения, сколько обозначения, ну определение.
значит вместе с вот этой перестановкой я хочу насчитать массив lcp.
я вот так и буду называть lcp, ну во-первых, почему называется lcp?
потому что london без common prefix на lcp.
двух строк, но это буквально длина их наибольшего общего префикса.
двух строк, но это длина их наибольшего общего префикса.
если есть с кем две строчки вот такая и вот такая, то как посчитать их lcp?
ну давайте просто вот встанем указательным сначала строк, будем идти направо, пока не найдем первое различие.
Вот эти два символа равны, то есть первые символы равны идем дальше, следующие символы равны, следующие, и так далее, и так далее, вплоть до какого-то первого различия.
Вот если я вижу, что здесь символы отличаются, значит LCP вот он, а вот он LCP.
Не включается.
Да, ну конечно, если они различны, то они в LCP не входят.
Вот, ну и давайте посчитаем LCP вот на этом массиве строк.
Чтобы значение LCP IT, это собственно длина лонг-строман-плефикса, да, то есть длина наибольшего общего префикса, для строк, внимание, SPI и SPI плюс один.
То есть вот в том порядке, в котором они располагаются в суфиксном массиве, в этом порядке между парами соседей я считаю LCP.
То есть вот давайте я сюда вернусь, да, на картинку.
Вот есть у меня сортировка всех суфиксов, я посчитаю LCP вот этой пары, LCP вот этой пары, и так далее LCP вот этой пары, то есть между всеми соседями.
Да, не между всеми парами вообще, или не между парами, скажем, ну там, S0 и S1, а именно вот в этом порядке SP0 и SPI, SP1 и SP2 и так далее.
Именно в этом порядке, как они располагаются, между всеми соседями я нахожу LCP.
Вот, значит зачем это может быть нужно?
Ну, смотрите, простое утверждение.
Простое утверждение.
Пусть P какое-нибудь LTE равно I, P регистерта равно G, в чем L меньше, чем R.
И если у нас LTE не умещено, тогда утверждается, наибольший общий префикс суфиксов, начинающихся в I и в G позиции, есть минимальный среди LCP кадр по всем K от L до R-1.
Такое формальное утверждение, картинка.
Давайте я сейчас суфиксный массив представлю как, опять-таки картинку, как набор строк.
Вот у меня сначала там идет SP0, потом какой-то SP1, SP2 и так далее вплоть до конца.
Оно не обязательно самое длинное, в общем, какое-то, да, очередная строка SP-1.
Я хочу найти наибольший общий префикс двух каких-то суфиксов ITE и GTE.
Ну, давайте скажем, это будет ITE, это будет SITE, где-то там будет SGTE.
Я сначала нахожу, где они у меня в перестановке, где они у меня в суфиксном массиве.
То есть я нахожу такое L, что SPL это SITE, то есть вот этот суфикс SPL это как раз SITE.
То же самое SPL это SGTE.
А я нахожу, где они у меня находятся в моем суфмассе.
А дальше, чтобы найти их LCP, у меня же нет LCP этих двух суфиксов, у меня есть LCP только между соседними.
У меня есть LCP вот этих двух, вот этих двух, вот этих двух и так далее.
Так вот я утверждаю, что чтобы найти LCP вот этих двух товарищей,
мне нужно найти минимальное среди вот этих LCP, которые у меня на этом отрезке лежат.
То есть я рассматриваю все LCP на этом отрезке, беру с них минимальное ответ.
Вот.
Ну, доказательств здесь очень простое.
Так что давайте раньше доказывать как два неравенства.
В одну сторону очевидно, понятно, что LCP SITE и SGTE точно больше либо равно, чем этот минимум.
Ну, по картинке понятно, потому что давайте я этот как-нибудь минимум отначу за X.
Что значит, что минимум равен X?
Это значит, что вот на этом промежутке все соседние строки имеют хотя бы первые X одинаковых символов.
То есть везде LCP соседей хотя бы X.
Значит, если я рассматриваю первый X символу вот в этой строке, то во второй они будут точно такими же X символами.
Потому что у них LCP хотя бы X.
То же самое между второй строкой и прийти.
Здесь LCP хотя бы X, потому что X за минимум.
Значит, первые X такие же, как вот здесь везде.
Ну и так далее, вплоть до конца, первые X символы в последней строке такие же, как в первой.
Поэтому LCP SITE и SGTE будет по крайней мере X.
X это минимальность или эффект СТ.
Вот.
Ну теперь давайте обратно покажем, что не может быть больше.
Покажем, что LCP SITE и SGTE не может быть больше, чем X.
Вот.
От противного.
Пусть больше.
Пусть это LCP.
Хотя бы X плюс один.
То есть на этой картинке вот эта строка и эта строка имеют хотя бы X плюс один общий символ.
Но при этом где-то на промежутке между ними есть две сосредние строчки, у которых LCP равен только X.
Но не X плюс один и не больше.
Вот.
Ну тогда давайте рассмотримся с тем, что это суффиксный массив.
Я утверждаю, что если у меня есть две какие-то строчки, которые начинаются на одинаковые X плюс один символов,
то все между ними тоже обязаны начинаться на те же самые X плюс один символов.
Почему? Ну давайте я перерисую картинку.
Вот есть у меня X плюс один символ.
Я перерисую картинку.
Вот есть у меня и ты суффикс.
Есть и ты суффикс.
Вот есть строка между ними какая-то, ну в диапазоне между ними в суффмассе.
Вот я утверждаю, что если эти две строки имеют какой-то общий трефис до X плюс один,
то он же будет наследоваться и здесь.
Ну почему?
Пусть первые X плюс один символов здесь отличаются от первых X плюс один символов здесь.
То есть когда что-то не совпадает, потом идет что-то другое.
Но давайте рассмотрим это первое несовпадение.
Так, здесь символ одинаковый, здесь C, здесь C.
Пусть здесь какой-нибудь другой символ.
Ну если этот символ был бы, например, меньше, чем C, то есть, например, если здесь A, B,
то понятное дело у меня некорректный суффикс на массив,
потому что тогда этот суффикс явно меньше, чем вот этот.
Значит, это должно быть выше, значит, чем этот.
Ну а мы с вами знаем, что суффмасса парагнала однозначно.
Я сказал, что у меня все строки попарно различны, поэтому перестановка единственна.
Значит, этот не может быть здесь, он обязан быть здесь.
Потому что здесь больше.
Вот, он должен быть выше.
Но аналогично симметричной ситуации, если здесь символ больше, чем C, скажем, D,
то он должен быть обязательно ниже, чем сжитая.
Ну потому что при сравнении у меня есть какой-то общий префикс,
а первое отличие в первом отличающем индексе, здесь символ больше, чем здесь.
Поэтому строка обязательно должна быть ниже.
Противорячься, значит, символ на этой позиции обязан совпадать с C,
то есть если у этих двух строк есть общий префикс, то он же наследуется во все строки между ними.
Ну поэтому такого быть не может.
Согласны?
А индексы I и J они снизу должны быть?
То есть это возвращайные?
Да, да.
Но еще раз, верхний индекс, это не после перестановки,
верхний индекс, значит, суффикс начинается с этой позиции.
А, все я понял.
То есть я нашел, где они находятся в моем суфмассе,
то есть вот в каком-то месте у меня находится икле суфикс, в каком-то месте житых суфикс.
Я беру минимум на треске между ними.
Но чтобы взять минимум на треске между ними, мне нужно знать, что это за индекс в суфмассе.
Поэтому мне нужна вот эта перестановка P.
Вот, вроде показали.
Вроде показали.
Получается, вывод какой из этого?
Что если нам надо, мы можем посчитать LCP любых двух суффиксов,
например, за единицу, если мы заранее на массив LCP построим спаррстейбл.
А если считать, что наша строка меняться не будет,
если строка меняться не будет,
то мы можем посчитать массив LCP,
мы можем построить на нем спаррстейбл, на минимум,
и дальше для подсчета LCP двух суффиксов просто искать минимум на адрес.
А спаррстейбл делать за единицу.
Давайте напишем, что вывод.
А с помощью спаррстейбл
можем находить LCP двух суффиксов, LCP вольных,
LCP WG2, за единицу на допрос.
Ну, это все предположено, что мы все построим, смотри.
Зачем нам может понадобиться находить наибольший общий префикс двух суффиксов?
Ну, например, чтобы решать задачу о проверке равности двух подстрок.
Задача.
Есть большая строка S,
к ней поступают запросы, задаваемые индексами L1, L1, L2, L2.
Нам надо проверить, равны ли эти строки,
ну, в общем, равны ли эти подстроки просто как строки.
Проверка подстрока равности.
Вот.
Раньше мы имели это только хэшами делать,
да, мы там считали все хэши всех префиксов,
и потом хэши подстроки мы можем вычислить за единицу,
ну, если как бы сравнить хэши подстрок,
если хэши равны, то мы видим, что они равны, если не равны, то не равны.
А теперь мы можем детерминированно с помощью суффмасса это делать без ошибок.
Ну, очень просто, потому что если есть как бы две подстроки, давайте найдем LCP вот таких двух суффиксов,
да, ну и проверим, что все вот этот символы не совпадают.
Вот, значит, как это сделать чуть точнее.
Ну, во-первых, если у них различные длины, давайте осторожно скажем, что они не равны,
return null какой-нибудь, чтобы подстройки не равны.
Иначе они имеют одинаковую длину, давайте найдем LCP соответствующих двух суффиксов,
да, вот суффиксы начинаются с L1 и суффиксы начинаются с L2.
И если их LCP хотя бы длина этой строки, да, которая одинаковая, то значит они равны.
Давайте так напишу, я мастер тренажных операторов.
Return LCP SL1 SL2 больше или равно, чем длина строки?
Вопрос yes, а значит no.
Круто.
Да, спасибо.
Согласны?
Не читаем?
Ну, ничего, справитесь.
Я вас вижу.
Я вас вижу.
Если я смеюсь, то вы точно сможете.
Вот, ну вроде все.
Вот, значит у нас есть хотя бы какая-то мотивация, зачем нам надо искать UFMAS,
соответственно не у массива LCP.
Ну, давайте теперь перейдем, собственно, к алгоритму, который находит суффиксные массивы.
У нас же где начинается строка L1, он не обязательно попадает с позиции L2.
Да, ну смотрите, когда я пишу S с верхним каким-то индексом, это просто суффикс начинается с позиции L1.
Это суффикс начинается с позиции L2.
Вот если я умею считать такой LCP, если мы больше равно, то мы знаем ответ.
Но как мы считаем такой LCP?
Чтобы посчитать LCP двух суффиксов, я на самом деле делаю вот это.
Я сначала нахожу, где они лежат в суффмассе.
Вот как здесь, да, я сделал.
Вот у меня есть вот это и этажи.
Считайте это и этажи.
Я сначала нахожу, где они лежат в суффмассе.
Как-то, но это несложно сделать упражнение.
Я нахожу, где они лежат в суффмассе.
И дальше на этом отрезке нахожу минимум.
Вот.
Ну, то есть как бы я считаю, что у меня уже есть процедура, вот я ее здесь описал,
у меня уже есть процедура, находящая LCP двух произвольных суффиксов.
Если у меня суффиксы заданы просто своими началами,
в каких индексах они начинаются,
то вот тут я описывал, что мне нужно сначала найти,
где они лежат в суффмассе, взять минимум на отрезке.
Есть такая процедура, я ее здесь просто использую.
Так, хорошо.
Ну, что будем делать?
Первое действие такое.
Давайте припишем к нашей строке символ, который меньше всех символов алфавита.
Ну, якобы у нас сегодняшний день.
Рисую решетку.
Предполагаю, что у меня строка содержит только, скажем, маленькие латинские буквы,
тогда приписывание решетки это как раз символ, который меньше всех символов строки.
Вот.
Давайте теперь считать, я забываю, что у меня была исходная строка S,
вот теперь это S.
Я считаю, что строка S заканчивается символом решетки,
который меньше всех остальных символов.
И давайте сразу скажем, что мы нашу строку зациклим.
Вот.
То есть, если меня, скажем, попросят посчитать, ну, точнее вывести,
под строку, начинающую здесь имеющую какую-то супербольшую длину,
то под строка устроено так.
Я сначала печатаю вот эти символы, потом, если надо,
телепортируюсь в начало и продолжаю печатать в начало.
То есть, я ее зациклю, да, и символ, следующий, за последним, это нулевой.
Вот.
План такой.
И дальше мы еще будем сейчас работать не только с суффиксами,
а будем работать со всеми подстроками.
Ну, соответственно, с циклическими подстроками.
Будем работать с циклическими подстроками вот этой новой строки S.
С циклическими подстроками строки S.
Тут циклические в том плане, что строка есть зациклена,
и вот это вот, да, вот то, что я здесь нарисовал, вот такая вот строка.
Вот такая.
Это подстрока считается.
Хоть она и не подстрока исходной строки, может быть,
но вот именно, что зацикленность.
Если все зациклит, то это подстрока.
Вот.
Значит, почему это нам ничего сильно не ломает?
Ну, смотрите, потому что, если, например, у меня получится посортировать
все циклические сдвиги, скажем, такой строки,
то я однозначно могу восстановить суффиксный массив.
Давайте примерку нарисуем.
Вот есть, скажем, строка ABATSABA.
Как для нее выглядит?
Давайте нарисуем сортировку всех циклических ее сдвигов.
Ну, раз решетка самый маленький символ,
то, понятное дело, начинается все будет с нее,
а минимальная строка, минимальная циклическая сдвигательность строки
начинается с решетки.
Значит, решетка ABATSABA.
Так.
Знаешь, какая строка будет следующей?
Ну, видимо, вот эта, потому что А-решетка,
это самая выгодная,
А-решетка ABATSABA.
Дальше, видимо, ABATSABA-решетка.
ABATSABA-решетка.
BA-решетка ABATSABA.
ABATSABA-решетка ABATSABA.
Да, спасибо, забыл.
Тогда не пометь.
Ладно, тогда не буду все писать.
ABATSABA-решетка.
ABATSABA-решетка.
Правильно, да?
Ну и дальше что-то.
Вот.
Тогда, смотрите, понятно, что если я обрублю все эти строки
на символе перед решеткой,
здесь будет A, здесь будет AB,
здесь будет ABATSABA,
здесь ABATSABA, тут ABATSABA.
То есть обрубаю на символах до решетки,
я утверждаю, что это будет как раз
сестровка суффиксов.
Это чей?
Ну понятно, потому что у меня конец строки
теперь ассоциируется с решеткой.
А мне именно что нужно,
что конец строки ведет себя как символ
меньше всех остальных, потому что
если есть, скажем, две строки,
такие, что одна является префиксом другой,
и здесь продолжение.
То это меньше это эликсиграфически,
потому что одна префикс другой.
Но если бы я написал, например,
до решетки в конец обеих строк,
то они сравнивали бы так же.
Ну потому что конец строки
сравнивается с символом.
Поэтому дописывание решетки
и сортировка циклических сдвигов
по факту мне автоматически дает
сортировку суффиксов.
Потому что решетка ведет себя как конец строки.
Это понятно?
Все.
Значит мы теперь будем сортировать
по строке, потом даем
до циклических сдвигов.
Значит что мы будем делать?
Давайте мы будем сортировать
подстроки, я уже сказал, что мы будем
работать с подстроками, а не суффиксами.
Давайте будем сортировать подстроки
длины сначала один, потом два,
потом четыре, восемь и так далее.
То есть семян в гройке пойдем.
Будем сортировать подстроки
длины 2 в катах.
и на каждом шаге, при каждом ка, мы будем хранить сортировку, ну, точнее, вот именно
перестановку всех подстрок такой длины, в каком порядке надо переставить все подстроки
такой длины, чтобы они шли в порядке возрастания.
Что мы там делали с зацикливанием?
Я сказал, что у меня все зациклено, у меня строки зациклены теперь.
И когда я здесь говорю подстрока, я имею ввиду зацикленные подстрока.
То есть вот то, что я здесь рисовал, это тоже будет подстрока.
И когда я говорю подстроки длины 2 в ката, их сколько? Их ровно m.
Потому что можно в любой позиции начаться, прочитать 2 в ката силов,
возможно, вернувшись в начало.
Поэтому на каждом шаге у меня подстрок всегда ровно m.
Так вот, как я буду сортировать?
Я буду хранить, получается, перестановку, в каком порядке нужно все вот эти подстроки проставить.
А также я буду хранить их разбиение в разы хевалентности.
Также храним разбиение на классы хевалентности.
Классы просто говорят, равны подстройке или нет.
А если не равны, то... ну то есть класс хевалентности это будет просто номер какое-то, какое-то число.
То есть я сейчас хочу пронумеровать все подстройки вот такой длины.
Я сейчас хочу пронумеровать все подстройки длинной 2 в ката.
Так что одинаковым подстрочкам соответствуют одинаковые номера.
А если подстрочки разные, то у них и номера разные.
И при этом их соотношение такое же, как на эти строки.
То есть если одна строка меньше другой, она под строка меньше другой.
То и номер первое меньше номера второе.
Буду хранить такую еще, как бы номерацию...
То есть я каждой подстроке поставлю соответственно номер класса.
И классы соотносятся так же, как строки, если строка меньше, то класс меньше, если строки равны, то класс равен.
Меньше лексиграфический?
Да, конечно, строки всегда сравниваются лексиграфически.
А, ладно, какой вопрос.
По-другому ты по-другому не умеешь.
Вот, такой план.
Давайте обозначение, как мы будем делать.
Смотрите, я уже сказал, что под строк длины 2 в каторе всегда ровно n, в частности, за счет того, что я зацикливал,
у меня всегда ровно n под строк.
Давайте, у меня будет так же, как всегда, значит, p0, p1 и так далее.
Это начальный индекс строки под строки длины 2 в каторе,
которая стоит на этом месте в порядке сортировки.
То есть у меня каждая подстрока длины 2 в каторе будет ассоциирована с индексом своего начала.
Вот, есть вся строка, есть какая-то подстрока.
Она связана с индексом, с каким-то индексом, где она начинается, какая-то позиция начала.
И pi – это такой индекс g, что вот эта строка будет it в порядке сортировки всех подстрок длины 2 в каторе.
То есть pi – это номер начального индекса строки на этом месте, на этом месте в порядке сортировки.
Вот, а ci – это будет класс эквивалентности, давайте лучше номер класса эквивалентности.
Опять-таки под строки длины 2 в каторе начинаешься в позиции i.
В индексе i.
Так, надо примерно рисовать.
Попробуем сделать.
A, B, C, AB, BC решетки.
Давайте такое сделаем и давайте рассматривать подстроки длины 2.
Что я хочу? Я хочу рассмотреть все подстроки длины 2.
Вот это, вот это, вот это, вот это, и еще вот это. Решетка A, такая зацикленная, она тоже есть.
Почему t и t не равна i?
Потому что, смотрите, pi – это, нам надо быть на i-том месте в порядке сортировки.
Например, давайте возьмем i равно 0.
P0 – это та строка, та фотострока, которая будет самой маленькой в порядке сортировки.
А у нас, ну вот, у меня есть большая строка, я рассматриваю все ее, вот такие обложки, двум, два в кадре.
Вопрос, кто из них самая маленькая? Это Бог его знает, ну какая-то.
А именно, п0-ая.
Вот. То есть, p it-ая, это какая строка будет it-ой после снастировки?
Вот какая будет p0-ой? Точнее, что такое p0?
Это самая маленькая из-под строк. Я не знаю, где она, но вот в каком клиндексе p0 она начинается.
Вот я ровно в этой хане. То есть, по факту p it то же самое, что суфмасс, только для постройки на два вкаток.
Это кто будет на it-ом месте после снастировки? Ровно то же самое.
А мы пока обозначили, но не посчитали, да?
Да, да, конечно. Я пока обозначил, понимаю, что это несколько, как это по-русски, громовское определение.
Вот я сейчас хочу на примере нарисовать, что здесь будет.
Вот, давайте до этой строчки.
Так, давайте что такое p0, скажите, пожалуйста.
Решетка A.
Решетка A, да.
Мне нужно ее занумировать все сначала.
Вот, и тогда это будет 7, правильно?
Потому что эта вот решетка A, это самая маленькая из постройок для n2, она начинается к 7-му символе.
Вот я его здесь храню, p0 равно 7.
И идем дальше. Что такое p1?
Ну дальше, вы видите, у меня есть две одинаковые по строчке AB.
Они равны, они как бы следующие по минимальности.
Ну я могу их в любом порядке записывать здесь.
Могу написать 0, могу написать 3.
Давайте здесь 0, здесь 3.
Потому что вот эти вот две подстроки AB, AB, они идут в следующем порядке стротировки.
Значит, ну скажем, на первом месте идет 0, а потом 3.
Понятно?
Так, что будет p4?
AB мы обработали.
AB.
Еще раз?
AB.
AB, да, согласен.
AB будет, то есть, 4, да?
П3, наверное.
Ой, да, виноват, виноват.
П3 будет как раз 4, правильно?
Вот.
AB мы обработали, остались BC.
Два раза, смотрите, BC встречается два раза, поэтому 1 и пятерка сейчас будут, да, в каком-то порядке.
Ну, например, в таком.
Разве не нужно p1 и p2 поменять местами, потому что в итоге стротировки может быть, кажется, p2 выше.
Ну, в плане, короче.
Нет, p1 и p2, еще раз, я рассматривал подстройки для n2.
Вот сейчас они одинаковы абсолютно, я не могу их никак перестать.
Ну, типа, я их могу, ну, здесь порядок неопределен, на самом деле.
Ну, вот, допустим.
Просто по этому определению они могут быть в таком или другом порядке.
И это неважно, на самом деле.
Так, что дальше?
П5 я нашел, значит, я обработал BC.
Осталось CA и C-решетка, правильно?
Сначала, видимо, C-решетка, то есть строка начинается с шестого символа.
Потом идет CA, эта строка начинается со второго символа.
Не обманываю?
Ну вроде.
Хорошо, теперь давайте C-шки посчитаем.
Давайте посчитаем C-шки.
Начинаем с C7.
C7 будет ноль, потому что строка начинается с седьмого символа.
Это вот эта вот строка, да, решетка А.
Она самая маленькая.
Я ей назначаю нулевой классикой валентность.
Она там будет одна, потому что нет других строк равных решетка А.
Дальше идет две одинаковые строчки АВ.
Да, вот я просто иду по моей перестановке.
Сначала была вот эта решетка А, теперь две одинаковые строчки АВ.
Вот она и вот она.
Я говорю, что нулевая и третья строка,
то есть те, которые начинаются с нулевого и третьего символа,
они обе будут в первом классике валентности.
Потому что они равны, они лежат в новом классе валентности,
отличном от предыдущего.
Я им назначаю очередное целое число.
Один.
Так, дальше идет ББР.
Это отдельный класс, в котором нет никого больше.
Поэтому я говорю, что C4 это два.
Строка начинается в четвертом символе
и лежит во втором классе валентности.
Она там одна.
Дальше, если я не ошибаюсь, у нее два раза было БС.
Дальше следующие две строчки это БС.
Вот она и вот она.
Поэтому подстроки начинаются в позиции 1 и в позиции 5.
Лежат в следующем классе валентности.
Номер 3.
Вот.
Ну и там осталось что?
Осталась цель шодка ЦА.
Давайте напишу просто, что это должно быть.
С6 это 4.
С2 это 5.
Вот.
Понятно?
Супер.
И теперь я вот эту вещь хочу хранить для каждой степени двойки.
Будем это делать сейчас.
Так.
Так, начало очень простое.
Карда 0.
Как обработать все подстроки длины 2 в 0, то есть 1?
Посортировать символы, да?
Потому что подстроки длины 1 это просто символы.
Мне нужно посортировать символы.
Ну если я считаю, что все элементы моей строки это какие-то чары,
то я могу посортировать просто сортировкой подсчетом.
Ну если у меня там всего 256 значений.
256 возможных значений для всех элементов строки,
я могу завести 256 корзинок, сложить их там туда, как надо, и посортить.
Вот.
Но на самом деле не нужно просто сортировка подсчетом.
Так.
Но я хочу ее вспомнить,
потому что мне в дальнейшем нужна будет не абы какая сортировка подсчетом, а стабильная.
Давайте быстренько вспомним, как работает стабильная сортировка подсчетом.
Напоминаю, пусть есть у меня там какие-то числа.
Ну в нашем случае это будет, видимо, символы строки.
Вот.
Как их посортить?
То есть я сначала завожу массив.
Сколько раз встречается каждый символ.
Вот здесь видим, что там, 256 заведу его размер.
Потому что все элементы это чары, например.
Вот.
Дополнен нулями.
Дальше прохожусь по массиву.
Увеличиваю количество вхождений каждого символа.
Так, давайте все-таки будут резки.
Потому что символы строки, да.
Увеличиваю количество вхождений каждого символа.
Это было у нас в первом смеси.
По крайней мере, должно было быть.
Я на всякий случай напомню.
Значит, дальше.
Дальше я насчитываю клетчатные суммы на этом массиве.
Вот.
И теперь KNTI хранит место, куда нужно положить самую правую ишку.
Да.
Потому что после этого KNT0 это количество нулей.
KNT1 это количество нулей и единиц.
KNT2 это количество нулей и единиц и двоих суммарно.
И так далее.
Поэтому KNTI хранит самую правую позицию.
Куда нужно поставить самую правую ишку.
Ну, потому что их количество точно совпадает с...
Вот.
Приду по массиву.
Точнее по строке справа-налево.
И кладу на то место, которое ей приписывается.
Ой.
Так.
Сейчас будет выиграть глаз, но...
Напишем.
Во.
Во, видите?
А вы меня осуждали уже тогда.
Вот.
Ну, тут все...
Что происходит?
Мы идем по строке справа-налево.
Видим символ SE.
Это очередная буква нашей строки.
KNT от SE показывает,
на какое место этот символ надо было бы поставить.
Ну, потому что после этого
KNT SE это указатель,
куда надо поставить самый правый символ SE.
Это, поскольку я иду справа-налево,
самый правый из посчитанных,
я уменьшаю его на один, чтобы перейти в ноль индексацию,
и как раз на это место
ставлю элемент, который
сейчас был item,
который я только что прочитал.
Ну и сразу я уменьшил KNT,
поэтому если я в следующий раз увижу тот же самый символ,
он встанет на правильное место.
На то, которое на один левее.
Вот.
Это стабильная сортировка подсчетом.
Теперь давайте SE еще посчитаем.
И считаем SE.
Ну, как-нибудь сделаем, наверное, да.
То есть, что мы сделали? По факту мы отсортировали
все вот эти вот однобуквенные строки,
то есть все символы. Теперь мне нужно еще разбить
на классы эквивалентности. Давайте я один раз
напишу этот код.
Давайте напишу один раз этот код.
Давайте заведу кое-какую перемену x,
которая равна номеру
текущего класса.
Минус один хочу сделать.
Нет. Бог с ним.
Дальше.
Я иду по
всем элементам
нашей перестановки.
PE это
очередная строка в порядке
сортировки.
У меня P0, P1, P2 и так далее.
Это как раз отсортированные символы. P0 самый маленький,
P1 побольше, P2 побольше и так далее.
Значит,
я сделаю следующее.
Если
И равно 0,
а давайте прям... Нет.
Теорема.
Ну ладно.
Если И равно 0
или
SPIT
равно SPI
минус первое,
тогда я говорю, что просто
SPIT
это x.
Иначе я сначала
увеличу x, потом положу SPIT
равно x.
Вот.
Кажется так.
Значит, ну какой смысл?
Я иду в порядке...
В общем, я иду по элементам моей перестановки.
Сравниваю
текущую строчку,
которая начинается в позиции SPI
с предыдущей. То есть я сравниваю символ
стоящий на SPIT месте с символом,
стоящим на SPI минус первом месте.
То есть у меня вот этот предыдущий, этот следующий.
Если они мне равны, или это вообще
впервые, когда я зашел в этот цикл,
тогда мне нужно сказать, что это
x-й класс. То есть, грубо говоря, смирюсь, у меня
все подстроки разбиты по классам.
Сначала несколько строк 0-го класса,
потом несколько строк 1-го класса и так далее.
Так вот, я сначала иду
по 1 классу, и если я только начал
или если мой класс такой же, как у предыдущей
строки, то есть, ну по факту,
если просто строки одинаковые, то мой класс
это x, тот, который был раньше.
А иначе, когда я перемещаюсь
между классами, когда я
попадаю в строчку отлично от предыдущей,
тогда мне нужно
сначала x увеличить, я перехожу к новому классу
и у него, ну, опять
кладу x
в качестве номера.
Тогда, соответственно, все вот эти строчки будут
нулевые, эти первые, ну и так далее.
Норм?
Хорошо.
Ну, как?
Ну, как? Потому что, как работает
подсчет? Подсчет работает, если
у вас значение маленькое. А здесь у вас
значение, извините,
26 в n-й.
У вас работает сочировка
подсчетом, если у вас значение элементов маленькие.
Вот у нас это работает, потому что
как бы значение это символы.
Так.
Все, значит, мы посчитали базу.
Теперь давайте
научимся переходить
от ката во шага к k плюс первому.
То есть, зная, что у меня
в P и в C
лежат правильные характеристики для
подсрока длины 2 в катой,
давайте научимся переходить
к подсрокам длины 2 в степени k плюс 1.
Вот. Это дело
очень естественно, потому что все подстроки
длины 2 в степени k плюс 1
разбиваются на две равные, ну, как бы
на две равные по длине строки длины 2 в
катой. Если я рассмотрю
строчку длины 2 в ка плюс 1,
поделю пополам, то у меня как раз
получится две подстроки длины 2 в катой.
И, смотрите,
мы же не даром храним
эти классы эквивалентности, мы еще и с вами
знаем, как их быстро сравнивать.
То есть, за счет того, что мы храним номера
класса эквивалентности для всех подстрок
длины 2 в катой, мы умеем за единицу
сравнить любые две подстроки длины
2 в катой.
Лексиграфически, конечно, потому что я как раз, я храню
таким образом номера
класса эквивалентности, чтобы
сравнение подстрок
было такое же, как сравнение классов,
номеров классов. Вот.
Ну, и значит, что мне надо сделать?
Да, мне теперь надо посортить вот такие вот подстроки.
Вот такие подстроки я могу представить,
как, на самом деле, пара номеров
класса эквивалентности двух половинок.
Вот, если у меня есть вот такая строка
длины 2 в степени
ка плюс 1, пусть это
какой-нибудь i, это какой-нибудь g.
Вот первые индексы в этой подстроке.
Тогда, на самом деле,
меня просит просто посортировать массив вот таких
вот пар.
У меня подстрока длины 2 в степени ка плюс 1
распадается на две подстроки.
Я знаю, что номер класса эквивалентности первой половинки
это ci, номер вот, давайте
я даже не g напишу здесь, а i плюс 2 вкатой.
Чтобы не плодить переменные.
Вот.
i плюс 2 вкатой.
Значит, вторая половинка начинается в позиции
i плюс 2 вкатой, я знаю номер ее класса эквивалентности.
Да.
Да, конечно.
Ну, то есть, когда я рисую такую картинку,
она имеется в виду, что если вот эти символы
упали за пределы строки,
то они вот там вот торчат.
Но, как раз,
мне только зацикленность и позволяет так
делать, потому что, ну, я иначе даже не могу
рассматривать все такие подстроки.
Ну, скажем, а что если я начнусь в позиции, где вот здесь
конец строки? Нельзя так делать.
Именно поэтому я зациклил, чтобы у меня никогда
не было конца строки.
Вот. То есть, теперь сортировка
подстрока длины 2 в степени ка плюс 1
на следующей длины,
это по факту просто сортировка таких пар.
Ну, потому что ровно так и происходит сравнение
двух подстрок. Вот есть, скажем, одна подстрока
большой длины и другая.
Как они сравниваются?
Ну, они сравниваются слева-направо лексиграфически.
Вот давайте рассмотрим, скажем,
вот этой строке соответствует
такая пара, этой строке, соответственно,
какая-то другая.
Сж,
сж плюс 2 вкатый.
Вот. Ну, смотрите, если вот эти
две подстрочки различные,
то мы это поймем, посмотрев на ци и на цж,
тогда ци и цж будут различны и будут сравниваться
точно так же, как подстроки, потому что
это строки меньшей длины, для них
номера классов ведут себя так же,
как сами строки.
Вот. Значит, они будут сравниваться так же, как ци и цж.
Если они равны,
то сравнение больших строк
будет просто, ну, результат сравнения
будет такой же, как на вот этих правых половинках.
Потому что если левые половинки равны, я просто смотрю
на правые. Ну, а правые половинки
ведут себя как вот эти числа и
соотносятся так же, как эти числа.
Потому что все зациклено.
И все индексы,
вываливающиеся за n-1,
они просто по модулю n берутся,
тогда все очень шикарно.
Вот. Все.
Поэтому мы свели задачу
сортировки подстрок такой длины
к сортировке
массива пар.
Ну, а пары мы сортировать умеем, это опять-таки
подстрок такой длины.
Ну, а пары мы сортировать умеем, это опять-таки
сортировка подсчета.
Значит, давайте я это напишу.
Свели задачу
сортировки
подстрок
длины
2 в степени k плюс 1
к задаче
сортировки
массива пар.
Вида
ну, вот этого.
Ci
Ci плюс 2 в каты.
Не пишу по модулю n, потому что все индексы
всегда по модулю n все равно.
Раз мы зациклили, то все равно
процент n не явно подразумевается.
Мы живем в Zn, скажем.
Все автоматически по модулю n.
Да, различных пар может быть этот квадрат.
Но, смотрите,
значения вот этих штук
они всегда не больше, чем n, согласны?
Потому что подстрок
меньше длины максимум n,
значит, номера классовых пары
это всегда целые числа от 0 до
ну, до n минус 1, ну, до n пусть будет.
Не, до n минус 1 хочу.
А номер классов всегда число от 0 до n минус 1.
В первом семестре мы сортировали
такие массивы,
массив таких пар. Я сначала
стабильно сортирую по второй компоненте,
потом стабильно по первой.
Ну и поскольку значения маленькие,
то сортировка подсчетом выполняется быстро
за от n.
И за счет того, что у меня вторая
сортировка по первым аргументам стабильна,
это будет корректная сортировка.
Еще раз, что возможно?
n плюс k, где k максимальное значение.
Здесь будет n плюс n как раз.
Ага, хорошо.
Так, мы свели
задачу сортировки массива пар вида.
Значит, все числа
все числа
целые от 0 до n минус 1,
как я вот здесь написал.
Ну, поэтому сортировка
такого массива пар работает,
например, до двумя сортировками.
Сначала по вторым компоненту, потом по первым.
Вот это работает.
Для этого
сортируем
подсчетом
сначала
по
вторым компонентом пар
потом
потом стабильно по первым.
Вот.
Тем самым мы можем массив пар
посортировать за all at n.
Согласны?
Потому что я делаю две сортировки
подсчетом, каждый работает за линейное время.
Вот.
Ну, более-менее все.
Значит, можно заметить одну тонкость,
что на самом деле
первую сортировку можно не производить
в каком-то смысле, потому что
что такого? Давайте посмотрим на вторые компоненты.
Вторые компоненты
это на самом деле просто
в каком-то порядке номера всех классов.
Номера классов всех
правых половинок, всех подстрок.
Но извините, у меня с прошлого шага была перестановка P,
которая мне как раз сортировала все
мои подстроки длинной 2 вкатой.
Теперь меня опять просит
посортировать все мои подстроки длинной 2 вкатой.
Поэтому на самом деле
я могу первый шаг пропустить
и просто сказать что-то типа
P i t
Сейчас.
Да, то есть кто будет
на этом месте? Если раньше было вот это,
то теперь, да, если раньше было вот это,
то теперь вот это. Минус равно
длинной 2 вкатой должно быть.
Потому что, еще раз,
это такое замечание, которое не обязательно.
Вот я говорю, что первый шаг, который
сортировка по вторым компонентам пары,
можно явно не выполнять,
потому что, что такое вот вторые компоненты?
Это по факту просто правые половинки
всех подстрок длинной 2 в степенька
плюс 1. Но они и так у меня уже посоршены
в массиве P. А P это у меня как раз
перестановка, в каком порядке
прежние поединки идут все по сроке длинной 2 вкатой.
Например, P 0
это начало самой маленькой
строки длины 2 вкатой.
А вот P 0
это самая маленькая строка длины 2 вкатой.
Теперь кто тогда должен
стоять на нулевом месте если я сортирую
по вторым компонентам?
Ну, видимо вот эта вот строка, которая здесь начинается.
Потому что, если P 0 это самую маленькую
строку длины 2 вкатой,
то самую маленькую теперь с точки
зрения сортировки по вторым компонентам
Это вот эта вот строка, у которой p0 это вторая половина в точности.
Поэтому p0 мне нужно сдвинуть влево на 2 вкатый.
То же самое с остальными.
Если я знаю, что p1 это вторая по величине строка длины 2 вкатый,
то вторая по величине строка длины 2 степенека плюс 1 после сортировки по второму компоненту,
это вот эта вот p1 минус 2 вкатый.
Поэтому первый шаг можно сделать просто вот таким вот присвоением для всех i.
Первая сортировка.
Давайте я пишу так, p' i t, ну, конечно, да, p i t минус 2 вкатый, конечно, все по модулю, по модулю.
Ну вот я, я поэтому не писал процент, я писал мод.
Ау?
Ну, да, да, да, ну, хорошо.
Ну, вот, я, я поэтому не писал процент, я написал мод.
Ау?
Ну, да, да, да, ну, хорошо.
Вот.
Согласны?
Ну все, а здесь ну как бы тут хочешь не хочешь, тут придется стабильно сортировать,
но мы уже умеем стабильно сортировать за линию.
Вот, там вот какая-то еще логика сортировки.
Все.
То есть мы получается, смотрите, мы с вами за линию научились переходить от 2 вкатой
к 2 степенека плюс 1.
Да.
Ну, да, поэтому n log n.
То есть я научился вот перестраивать p' по p.
Я не проговорил, но точно так же тривиально пересчитывается c' по c.
Ну, потому что, как бы, если у меня сортировка, то сравнивать
две подстроки, то есть как бы...
Ну, короче, класс эквивалентности тоже легко получить.
А если у меня есть правильный порядок сортировки всех подстрок
длины 2 в степени k плюс 1,
то как посчитать класс эквивалентности?
Ну, опять, пройтись по ним сверху вниз,
проверить на равенство, если равны, то в одном классе,
если не равны, то заводим новый класс.
Поэтому, как бы, c' тоже тривиально пересчитывается,
тривиально находится.
Вот.
Ну и так будем делать, пока мы всю строчку не покроем.
То есть давайте увеличивать.
Я начинаю с 2 в нулевой,
перехожу к 2 в первой,
2 во второй и так далее,
пока не дойду до такого числа,
которое больше и равно n.
Ну, понятно, что мне нужно на это примерно
логарифмическое количество итераций.
Все.
Я вот говорю, что на этом шаге мы победили.
Потому что на этом шаге мы посортировали
все подстроки длины
некоторой,
причем она хотя бы n.
Вот.
То есть теперь у меня посортированы
все подстроки длины 2 вкатой,
для какого-то очень большого k, что 2 вкатый хотя бы n.
Знаешь, что у меня все такие подстроки
расположены в порядке возрастания.
Ну, тогда если я просто обрублю на первых n символах,
то я посортировал все циклические суффиксы.
Ну, потому что, как бы,
если у вас есть порядок сортировки
длинных строк, то после обрубания на
каком-то месте у всех этих строк,
у них порядок, конечно, не изменится.
Я просто это отбрасываю,
порядок между ними не меняется.
Вот.
Значит, у меня есть порядок
сортировки всех циклических,
всех просто циклических сдвигов.
А значит, у меня есть порядок сортировки всех суффиксов.
Я нахожу где, там, решетка, в каждой строке.
Обрубаю еще и перед решеткой.
И у меня получается сортировка всех суффиксов.
исходной строки. Кажется, все. Итога 8.n лога m.
Ну, если мы сигмы читаем постоянно.
Ну да, да, да. Что тут будет? Плюс сигма отдельно или как?
Плюс сигма на лога m тогда?
Поч.
А плюс сигма я утверждаю, потому что у меня на каждом шаге,
то есть у меня только первый раз символы были от нуля до сигмы,
а потом, точнее, номера классов от нуля до сигмы,
нет, именно символы, а потом классов всегда вплоть до n максимум может быть.
Тут, начиная со второго шага, сигмы уже нигде нету,
потому что у меня все эти штуки, это числа от нуля до нуля с одного.
То есть я могу написать здесь плюс сигму, но я не хочу.
Вопрос?
Ну ладно.
У вас был? Нет?
Мы можем просто первый раз подсортировать.
А, ну да, можно и на лога n. Да, это правда, да.
Вместо сигмы можно и на лога n вначале подсортировать, это правда.
Так, еще вопросы?
Да.
Ну супер.
Суфмасс построили.
Так, ну теперь за оставшееся время нам надо построить массив LCP.
Напоминаю, что кроме суфмасса для решения, например, задачи про проверку равенства подстрок,
надо писать еще массив LCP.
Давайте переходим к нему.
Подсчет.
Массив LCP.
Так.
Напоминаю.
Массив LCP считают LCP-шки соседних суффиксов в порядке вот этой вот сортировки после суфмасса.
Давайте я нарисую в каком-нибудь порядке все мои суффиксы.
Ну, точнее, в порядке суфмасса нарисую все суффиксы.
Такой, такой, такой, такой.
Вот это суффиксный массив всех моих суффиксов.
Я хочу посчитать LCP здесь, здесь, здесь, здесь, здесь, здесь, здесь и здесь.
Только такие LCP-шки мне нужны.
Вот.
Что я буду делать?
Первое, что я сделаю, нулевое, что я сделаю, это посчитаю массив PoS.
PoS это на самом деле будет просто первое, что я сделаю.
Второе, что я сделаю, это посчитаю массив PoS.
PoS это на самом деле будет просто перестановка обратная к P.
Перестановка обратная к P.
Которая как раз мне позволяет по I понять, где I входит в суффмассе.
Вот.
Значит, она обратная в том смысле, что, ну, как бы, у меня вот здесь, да, у меня эта строка начинается с символа P0.
Эта строка начинается с символа P1, это P2 и так далее, вплоть до Pn-1.
Так, что-то у меня верхние индексы внезапно стали.
Вот.
А если я хочу понять, а где лежит суффикс S с верхним индексом I?
То есть, где находится суффикс, начинается с этой позиции.
Ну, я вот по P это понять не могу, я это определю по PoS.
А PoS мне как раз, PoS.
Да, да, конечно. PoS от какой-то позиции скажет, где соответствующая строка находится, соответствующий суффикс лежит.
Вот.
Хорошо.
Значит, тогда, в частности, я знаю PoS0.
Это место в суффмассе, где лежит вся строка на самом деле.
Потому что это S с верхним индексом 0, это просто вся строка.
Да.
Ой.
Уф.
Нет, не думаю.
Что, правда, что ли?
Нет, потому что мы решетку приписали, которая меньше всех.
Ого.
Ого.
Ну, логично, да, потому что С я когда делаю, у меня ровно такая там лыка.
Ну, похоже на то.
Нифига.
Да, действительно, похоже, что PoS просто равно С.
Ну, это какое-то откровение.
Вот, давайте забудем про это.
Ну, типа, это не надо.
Так вот, давайте найдем PoS0, то есть, где в моем суффмассе лежит вся строка.
Ну, вот она, видимо, да, самая длинная.
Вот это вот будет PoS0.
Давайте мы первое, что сделаем, это в тупую, наивнейшем алгоритмом, посчитаем LCP этой строки и следующий за ней.
Ну, то есть, просто вот возьмем эту строчку и эту строчку, и будем идти слева-направо по ним обеим,
считать, сколько у них первых символов одинаковые, ну, вплоть до первого отличия.
Вот, если они не равны, то, значит, вот эти символы одинаковые, это LCP, а дальше уже LCP не продолжается.
Если есть решетка, то нет одинаковых суффиксов.
Да, у меня тоже.
Вот.
Понятно, да?
Сначала наивным образом посчитаем LCP вот здесь.
Я пока одно значение LCP посчитал.
А дальше работает следующая магия.
Смотрите, вот пусть мы посчитали LCP каких-то двух суффиксов.
Скажем, S ИТОГО и S ЖИТОГО.
Пусть я знаю их LCP.
Давайте я скажу, что первые L символов у них одинаковые.
Тогда давайте отбросим первый символ из обеих строк.
Получатся какие-то новые строки.
Давайте найдем, где они входят в наш SUFMAS.
То есть, вот куда-то входили S ИТОГО и S ЖИТОГО.
Ну, точнее, они были соседними в моем SUFMAS.
Давайте отбросим первые символы от них.
Посмотрим, где теперь эти строки в SUFMAS.
Ну, сложно с индексами.
Ну, вот, короче, эта строка будет вот этой.
Это какой-то вот этой.
Просто после отбрасывания первого символа.
Ну, а, все просто, да?
Это просто S и плюс один, это S Ж и плюс один.
Да, тут все просто.
Вот.
Значит, замечание первое.
Если L больше либо равно единице,
тогда они сохранят свой относительный порядок.
То есть, если раньше этот суффикс был меньше этого,
то этот будет меньше этого.
Но это очень просто, потому что, когда я отбрасываю,
то есть, у них есть какой-то общий префикс, да?
Не тривиальный.
И первые позиции, где они различаются,
здесь символ меньше, чем здесь.
Тут скажем B, тут C.
L это длина их наибольшего общего префикса.
L это их LCP.
Если отбрасываю первый символ,
ну, точнее не так.
Вот у меня есть их общий какой-то LCP L.
Значит, первый символ, где они отличаются,
вот здесь символ меньше, чем здесь.
Тогда после отбрасывания первого символа,
поскольку L хотя бы единица,
то значит, это все останется,
и B и C останутся на месте.
Поэтому эти две строчки сначала будут
с тишение L минус одного символа по-прежнему совпадать,
а первое различие у них будет в позициях B и C.
Вот.
Значит, они сохранят свой относительный порядок.
Это будет раньше этого,
потому что у них общий префикс,
а первые позиции, где они отличаются,
это меньше, чем это.
Ну, в предположении, что все строки существуют.
Сейчас, если L равно длине строки...
Ну, как бы у нас не явно там везде решетка,
у нас нет конца строки,
у нас решетка вместо конца строки всегда.
Поэтому мы можем всегда сравнивать,
считая, что строки бесконечны.
Вот.
Поэтому можно сказать,
что LCP вот этой строки
и следующей за ней
имеет длину хотя бы L минус один.
Потому что если между этими строчками
LCP и L минус один,
то мы знаем, как сидит в себе LCP.
LCP между двумя суффиксами
это минимум на отрезке LCP вот в этом массиве.
Ну, значит, здесь все значения хотя бы L минус один,
поэтому это тоже хотя бы L минус один.
То есть, потенциально,
после отбрасывания первого символа,
эти строки могли разъехаться,
между ними могли встроиться еще много разных других суффиксов,
но все они должны обязательно
сохранять вот эти первые L минус один символов.
Поэтому LCP вот этой вот строки
со следующей в суффмассе
будет хотя бы L минус один по длине.
Потому что, возможно, кто-то сюда вклинился.
Ну, то есть, представьте себе,
что была какая-то строка,
которая, ну, скажем,
вот такая,
а здесь слева у нее другой какой-то символ.
То есть, она была где-то там,
нельзя, там был Y,
и вот это вот все.
Тогда, когда я удаляю по одному символу,
эта строка вот сюда вот вклеивается.
Ну, вообще говоря, типа,
я не знаю, вклеивается или нет,
но здесь, например,
вот эта строка,
я не знаю, вклеивается или нет,
но тут точно не равен больше или бравно.
То есть, возможно, кто-то там появился,
возможно, нет, Бог его знает.
Даже не хочу думать об этом.
Вот, да, это главное.
Поэтому, смотрите, что можно сделать.
Можно делать так.
Вот я насчитал LCP
в этой точке между одной строкой и следующей.
Давайте отбросим по одному,
ну, как бы, по первому символу обеих этих строк.
Поймем теперь,
то есть, это была S0, давайте теперь поймем,
где входит S1. Вот оно.
И тогда я понимаю, что
LCP в этой точке будет хотя бы L-1.
Вот эти вот символы равны вот этим вот L-1 символу.
Потом, если надо,
у меня же все-таки только нижняя оценка,
это не точное значение, давайте я дальше
пойду по обеим этим строчкам,
попровираю, если символы равны, я буду L наращивать.
То есть, у меня есть только
нижняя граница на LCP.
Давайте ее увеличивать, если надо.
Если эти символы равны, я ее увеличиваю.
Да, это именно для соседей,
для соседей в суфмассе.
Так.
Ну и поэтому,
я знаю, что граница L-1,
давайте потом
увеличивать, если надо,
и тем самым мы посчитаем правило значения LCP
между вот этой строчкой и этой.
Потом опять отбросим у них первые символы,
поймем, где оно входит суфмассе,
знаем, что ответ хотя бы L-1, ну и так далее.
И смотрите, за счет того,
что у меня L, вот эта вот общая глобальная L,
каждый раз
при переходе к следующей строчке
уменьшается всего на 1 максимум,
от L к L-1,
то вот эти вот наращивания,
цикл while пока символы равны L увеличивать,
все эти наращивания будут
суммарно работать за O от N, потому что L
уменьшается всего на один раз при переходе
к следующему E.
Поэтому суммарно все вот эти наивные переходы
будут работать за линию.
Вот.
Так, ну давайте это напишем.
Давайте это напишем.
Потому что мы начали со всей строки,
по одному символу будем от нее
откусывать, понятно, что рано или поздно
мы все суффиксы переберем.
Ну и когда я отбросил один символ,
я посчитал для строки S1,
отбросил два символа, посчитал для строки S2,
и так далее. Так я все суффиксы переберу,
для них и для всех посчитаю L,
со следующим в суфмассе.
Вот.
Давайте напишем.
Значит, вначале L равно 0.
Перебираем все суффиксы,
ну точнее, перебираем начало суффикса.
Вот пусть суффикс начинается в позиции E,
то есть S с верхним индексом E.
То есть вот я нахожу где-то,
где лежит SE,
где лежит следующий, ну то есть
какой там будет следующий, я буду считать
сейчас вот это вот LCP.
LCP между суффиксом SE и следующим
в порядке суфмасса.
Вот.
Вот.
Давайте сначала определим
G
как
позицию E.
Так, это мне удобно,
вообще нет, сейчас, один момент.
Давайте так вот сначала сделаю.
Сначала сделаю такую обработку.
Если я дошел до суффикса, который самый
последний в моем суфмассе,
то для него LCP считать не надо.
Да, то есть, ну как бы, мне надо было
посчитать LCP его с тем, кто ниже,
а ниже никого нет.
Поэтому давайте я сброшу L,
то есть, ну то есть формально L это LCP,
а LCP это LCP,
то есть LCP это LCP,
то есть LCP это LCP,
то есть LCP это LCP,
то есть LCP это LCP,
то есть формально L это LCP,
последней строки в суффмассе
с пустой строкой,
которая нету в суффмассе,
поэтому я могу изнулить и делать contin, переходим.
На это мы обработали случай, когда там одной строк нет.
Тогда можно просто сказать,
что L равно нулю.
Вот. Ну а дальше надо делать примерно следующее.
Давайте мы скажем, что G это
P с индексом
позит плюс один, видимо.
Что это значит?
Это значит, что мы нашли,
сначала мы взяли pos i,
это мы узнали, где в суффмассе находится
строка s i, вот это вот.
Потом увеличили индекс на один и взяли P.
То есть здесь лежит строка, начинающая
с сжитой позиции.
s g, да?
Потому что вот здесь лежит pos i,
это pos i плюс один,
P от pos i плюс один, это номер строки,
который тут лежит.
То есть мы как раз вот сейчас будем искать LCP
между s it и s gt.
Так, мы знаем, что ответ это хотя бы L.
Или хотя бы L минус один.
Давайте хотя бы L минус один.
То есть по сравнению с предыдущим шагом
у меня L может упасть на единичку.
Поэтому я ее безопасно
уменьшаю на единичку.
Ну так, чтобы она отрицательной не была.
Ну и дальше просто наивно наращиваю.
Пока, скажем, s i плюс L,
плохо, да?
Пока i плюс L существует
у нас в строке,
или это не надо?
Короче, пока символы существуют
и равны, я увеличиваю L.
Сейчас.
Да, похоже на правду.
Сейчас, сейчас, сейчас.
Да, согласен.
Да, окей.
Вроде можно действительно безопасно удалить.
Ну короче пока равны, увеличиваем.
Да?
Ну и все, и говорим, что
теперь Lcp, видимо,
pos it,
pos it
это L.
Потому что pos i это как раз позиция,
где it строка,
где it суфикс находится в суфмасе.
И вот ровно сюда, в Lcp,
ровно с этим номером, я же вот это Lcp считаю.
Вот я ее здесь храню,
Lcp pos it это L, который я только что считал.
Кажется, все.
Что?
А вот я L сразу обновляю, ну вот здесь.
Так.
Вопросы.
Смотрите, я это не выделяю
в отдельный шаг, оно мне автоматически,
ну как бы, смотрите, когда i равно 0,
i равно 0, L пока равно 0,
ну там, если это
проверка не срабатывает,
давайте, что происходит при i равно 0?
Я нахожу, где в суфмасе находится
s0, вот это вот
g, это как раз следующее за ней
в суфмасе.
Потому что pos i это где она лежит, pos i plus 1
следующее, p от этой позиции,
это, это как раз
sgt. Ну и дальше,
собственно, у меня вот этот первый шаг, который я там
нарисовал, он у меня в этом же цикле сразу
производится. Я нахожу
префикс у этих двух строк длины l
и кладу его туда.
Так, еще вопросы.
Почему это все за линию? Потому что давайте
посмотрим на переменную l, как она
себя ведет.
Ну как бы понятно,
основная сложность здесь только в вайле,
все остальное работает, очевидно, за линию, for и
тривиальной операции.
Сложность происходит
только из-за вайла. Каждый трансцикл
вайл увеличивает l хотя бы на единицу,
ну точнее ровно на единицу.
Но при этом l, когда, как
меняется l, оно только уменьшается на один
максимум n раз,
но еще вот здесь оно может дропнуться до нуля.
Если я правильно понимаю, на самом деле
это, можно вообще не писать, оно и так будет нулевое,
потому что если я дошел до последней строчки,
то там и так скорее все будет lcp 0
со следующей, но это не точно. В любом случае
что происходит с l? Оно n раз уменьшается
на единицу, и возможно
один раз еще сбрасывается до нуля.
То есть, у меня есть переменная,
которая много раз может
увеличиваться на единицу, но всего
максимум n раз уменьшается на один, и всего максимум
один раз сбрасывается до нуля.
Тогда obrigado делу, что увеличится на, может, максимум 3n раз кажется.
То есть, мы сначала увеличили,
потом на n уменьшили, опять увеличили,
потом сбросили и увеличили. Ну потому что
всегда просто l не больше, чем n.
Значит, она не может на sul
очень много, если она суммарно уменьшилась
максимум 2 n раз, тут n,
тут еще n, то значит, ты увеличишься, она могла максимум
3n раз.
Значит, суммарная линия.
Да?
Ну хорошо.
Ну еще раз, смотрите, вот здесь n падает максимум
на n суммарно, n уменьшается максимум на n.
Здесь, повторю, вот эту строчку, ее вроде можно
не писать, но даже если так, эта процедура уменьшает
n, l максимум на n, изначально она 0, и оно всегда не больше
чем n.
Но если я 2n вычел, то сколько я могу прибавить к 0, чтобы
получить максимум n?
Ну 3n.
Все равно линия.
Все?
Попросов нет?
Ну давайте тогда закончим, опять пораньше получилось,
что-то странное.
Ну ладно.
