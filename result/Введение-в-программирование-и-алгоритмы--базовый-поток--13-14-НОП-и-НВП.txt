У нас осталось с вами две темы, которые и будут финальными, по сути, в курсе алгоритмов,
посвященные все также динамике. То есть динамика это у нас, если глобально смотреть,
последняя тема была. Да, действительно, у нас сейчас последняя лекция, поэтому давайте уж все
включите камеры. Если кто-нибудь мне ответит и попадет со мной на экзамен, я хотя бы вспомню
этого человека и скажу, да, это ты мне ответил на этот вопрос правильно, хорошо так и быть,
мы как-нибудь сдадим это вместе. Поэтому думайте об этом, зачем нужно было включать камеры все это
время. Смотрите, у нас осталось два вида задач. Наибольшая общая подпоследовательность,
либо наединейшая, в зависимости от того, как это переводят, и наибольшая возрастающая
подпоследовательность. По-английски, НОП это ЛКС, Latest Common Subsequence. Вначале мы
поработаем с ней, потом уже с наибольшей возрастающей подпоследовательностью. Все эти
задачи решаются именно конкретно самым оптимальным решением. Будет здесь та самая динамическое
программирование, которое есть. Для того, чтобы с этим всем работать, давайте ведем простейшие
понятия. Начнем мы с наибольшей общей подпоследовательности. Предположим, что у нас с вами есть какие-то две
последовательности. У нас есть последовательность x равная, я буду записывать, как там x1 маленькая и
так далее. И у нас есть последовательность y равная y1 и так далее. Что это означает в общем
видео? Представьте, что у меня есть последовательности, если не из цитров, а просто из букв, там, например,
a-a-c-t-a и так далее. А здесь у меня есть a-c-t-g-a и так далее. Вот у меня есть две какие-то последовательности.
И мне среди них нужно найти наибольшую общую подпоследовательность z. z равная z1 и так далее.
Что такое наибольшая общая подпоследовательность? Наибольшая общая подпоследовательность это те
самые элементы, которые мы можем выбрать в x и в y, они являются одинаковыми и друг друг за дружкой.
То есть, к примеру, здесь мы можем сказать, что наибольшая общая подпоследовательность, в общем
видео, если смотреть, то это вот a-a, потом у нас есть c, который идет, и последний т, т, и а, а. То есть,
наибольшая общая подпоследовательность у них это a-c-t-a, не обязательно идущая подряд. То есть,
мы выбираем какие-то конкретно буквы и говорим, что они присутствуют и там, и там в такой-то
последовательности, если мы там выкинем какие-то из них. Это метод достаточно полезный в той же
информатике, например. Это одно из применений, к примеру. И там такое возможно. Вот. И все это
решается с помощью динамического программирования. Как вам было сказано на прошлой лекции и на поза
прошлой лекции, главное, что нужно показать, что у нас есть какие-то оптимальные задачи. Вообще
всегда во всех задачах с динамическим программированием. Именно поэтому нам необходимо с вами
доказать, будет некоторую теорему о наибольшей общей подпоследовательности. Но перед этим давайте
кое-что введем. Мы скажем, что и ты, префикс, префикс, например, икса, равный x и t, мы будем
обозначать. Это просто последовательность равная x1 и так далее x2. С префиксами вы будете не раз
встречаться, но просто префиксы это некоторая последовательность с самого начала и до какого-то
момента. Вот это мы будем называть итым префиксом. И обозначать просто так. Префиксы и элементы
обязательно друг за другом идут. Да, все верно. То есть если мы возьмем, к примеру, вот для этого
примера x3, то это у нас будет aac. Ну вот что такое третий префикс. Мы так это назовем просто для
себя, чтобы нам было удобно с этим работать. Теперь давайте введем следующую теорему. Теорема,
она прям так называют. Теорема об оптимальности, оптимальность, структура. Наибольшей общей
под последовательностью. Вот что эта теорема нам говорит. Она состоит из следующего. Ну для начала
мы делаем предположение. Пусть у нас там, пусть у нас есть последовательность. А там скобку надо
закрыть, видимо, да? А скобку, видимо, надо закрыть. Да, это правда. Пусть у нас есть последовательности
x равны x1 и так далее, xm и y равны y1 и так далее, yn. То есть эти последовательности могут быть
разные по размеру. И пусть z равны, к примеру, z1 и так далее, zk. Вот это наибольшая общая
под последовательность x и y. Тогда, тогда мы можем сказать следующее. Первое. Просто из
чего все будет строиться? Как раз именно из оптимальности. Нам нужно понимать вот оптимально
ли что мы будем вообще строить. И вот здесь мы это и докажем. Это достаточно простая теорема,
не очень сложная. Первое. Если x, ну, к примеру, xm и yn. Точно, не так, не и. А xm равно yn.
Вот, то zk равняется, xm равняется yn и zk-1. То есть префикс z без последнего элемента это
наибольшая общая под последовательность последовательности xk-1. Чтобы различать,
мы же здесь имеем ввиду, что z большая, правильно? Да, да, здесь z большая. Давайте
я напишу. zk-1 это префикс вот здесь. Давайте вот так напишем. Так лучше. xm-1 здесь тоже x
большое и yn-1. Это первое утверждение. Второе утверждение. Если xm не равно ym,
то из zk не равно xm вытекает, вытекает что? z является
наибольшей общей под последовательностью. А чего, как вы думаете? Давайте я кого-нибудь
спрошу. Давайте. Айда, скажи, пожалуйста, вот чего является z наибольшей общей под последовательностью?
Наверное, y, y, z является… Не может быть просто y. Наибольшей
предпоследовательности из двух складывается. Давайте кого-нибудь еще спрошу. Вот Леонид.
Возможно, минус два. Минус два что? М-2 и Н-2? Нет. Н-1 и Н-1. Н-1 и Н-1 так нет.
Префикса xm-1 и как? Префикса xm-1 и y. Действительно. Смотрите, нам важно обратить внимание именно на
вот эту штуку. Мы говорим, что если это вот так, то все логично. И третье утверждение,
которое у меня есть, что если у меня xm… Извините, а вот во втором утверждении вы написали,
если xm не равно yn, здесь префиксы или элементы? Здесь маленькие. Смотрите,
вот здесь, когда я пишу nop чего-то, здесь большие. Это последовательности. А это маленькие. То есть
префиксы мы не сравниваем. Мы сравним только элементы. Понятно? Вот. Да, спасибо. Здесь у нас
если xm не равно yn, то из zk не равно yn вытекает… что? z является… является nop… ой-ой… nop.
А nop чего? Скажи мне, пожалуйста, Ирина. Наверное, x и ym-1.
x и ym-1. Понятно ли утверждения, которые здесь написаны, в принципе? Надеюсь, что понятно.
В первом утверждении после zk равно же, да? Да, вот это равно. И вот это равно.
Можно другой вопрос? Можно. У нас обратные утверждения, они же не верны.
В обратном утверждении не факт, что верны. Ну а как-то можно вывести обратное утверждение,
которое точно верно? А зачем? Я хочу и в мелких подзадачи строить большое, а не из большой мелки.
Можно еще спросить? А вот от того, что zk, например, во втором или в третьем условии не равно xm,
но это ведь не означает, что оно равно ym? Не означает. То есть из неравенства утекает, да?
Да. Ну то есть у меня последовательность может быть… ну вот, смотрите, давайте вернемся к этой
последовательности, которая у меня здесь была. Вот у меня последние два числа здесь равны.
А представьте, если бы у меня здесь было вот не а в конце, а b. Ну вот b я захотел сюда поставить.
Тогда бы у меня их общая последовательность была бы a c t. Вот для y оно равно последнему у z?
Ой, тут t, извините. Тогда в этом случае здесь бы написал t еще. Оно бы равно было.
Ну потому что общая их подпоследовательность – это там a c t. Здесь, если что бы, в всякий случай справлю.
Ну t последняя равно y последней, но не равно x. Да. Ну вот. То есть ничего мы можем конкретно здесь не
сказать. Да, я понял. Поэтому рассматриваем два таких вот отдельных случая отдельно друг от друга.
Вот. Таким образом мы можем из этого будем сделать некоторый вывод об оптимальности. Но
для начала давайте докажем вообще эту теорему. Давайте рассмотрим первое утверждение. Первое
утверждение нам говорит о том, что если у нас в конце элементы равны и они равны z,
к этому то z k-1 это наибольшая общая подпоследовательность от x m-1 и y m-1. Давайте с вами
будем доказывать. И первое, что нам нужно, давайте так. Если бы у нас выполнялось соотношение z,
к примеру, k-1 не равнялось x m. Ну то есть не выполнялось вот это тройное равенство,
которое у нас было. То к последовательности z, то, давайте я буду запись, то к z можно было бы,
было бы добавить, добавить, а x n, x m равна x y n. Ну то есть мы можем добавить этот
последний элемент, который у нас есть в конце. А если y меньше, а если n меньше чем m, то есть
у нас идут две одинаковые последовательности, одна из которых заканчивается на один, а другая
на один-один. Еще раз, m и n. M это окончание x, а n это окончание y. Смотрите у нас есть
последовательность x m, которая состоит из допустим 10 единиц, и последовательность y n,
которая состоит из 9 единиц. Еще раз, у нас есть отдельное число m. Сколько у нас чисел в x,
сколько у нас последовательность в x, сколько у нас элементов в x, а есть n, сколько у нас
элементов в y, это разные числа могут быть. Ну да, у нас не вытекает из того, что мы не можем
доказать, что мы можем прибавить z-катой, просто потому что у нас m может быть больше, ты ну...
Я говорю следующее, у меня z-катой не равен xm. Я пока не понял утверждение, которое вы хотите
сказать мне. Давайте z-катой не равно xm, z-катой маленький, это маленькие буковки здесь. А здесь z
большой, я не знаю, как вам их отделить. Давайте z большой буду писать без штучки, просто вот так.
Это будет двойка. Это мы сейчас рассматриваем первый случай? Да, это первый случай. А почему z-катой не равно xm?
Что еще раз? Почему тогда z-катой не равно xm? Мы предполагаем, пусть это не так. Мы противно
видим. Пусть z-катой не равно xm. Но мы знаем, что xm равно ym, у нас это есть,
к примеру. И тогда мы можем взять... Что ж такое? У меня опять начинает подлогивать.
Тогда я мог бы к своей последовательности z добавить элемент xm равно ym. То есть последний
элемент в последовательности x и y, правильно? Мог бы добавить z. Но тогда бы у меня не было
такого, что z... Но тогда z не наибольшая общая подпоследовательность x и y. Понятно,
почему я сделал такой выбор? Потому что если мы не добавили последние элементы, которые равные,
они точно могут войти в наибольшее общее подпоследование. Они в конце, мы никак не нарушим
порядок, мы ничего с этим не сделаем. Но тогда, если в z они не входили, тогда она не может
являться наибольшей общей подпоследовательностью. Потому что мы можем безболезненно добавить эти
элементы и сказать, вот она наибольшая общая подпоследовательность. Это первый момент,
который нужно понимать. Понятно? Или нет? Но это вроде бы логично так все получилось.
Окей. Это правда. Таким образом, z кt равно xm равно ym. То есть мы это первое утверждение,
вот эту первую штуку доказать. Теперь нам необходимо сделать следующее.
Префикс. Мы говорим, что префикс z к-1. Это общее какая-то подпоследовательность,
просто пока общее. А подпоследовательность x и xm-1 и yn-1.
Нужно показать, что эта общая подпоследовательность является наибольшей, то есть исходя из того,
что у нас наибольшая, там наибольшая тоже. Окей, тогда давайте с вами говорить следующее.
Давайте предположим, что существует общая подпоследовательность
xm-1 и yn-1. Предположим, что существует какая-то другая. И ее длина больше
к-1. Извините, вы пишете префикс z к-1 наибольшую общую подпоследовательность именно или?
Префикс. Общее просто. Смотрите, мы с вами доказали, что если у нас есть последние
элементы равные, то тогда z является наибольшей общей подпоследовательностью. Этот элемент
входит в них. Понятно? Да, но выбирайте последний элемент и говорите, что без последнего это наибольшее.
Сейчас мы должны сказать, что если у нас была наибольшая общая подпоследовательность,
мы хотим выбрать последний элемент и сказать, что если мы даже уберем этот последний элемент,
это будет наибольшей общей подпоследовательностью для префиксов xm-1 и префикс ym-1. То есть
без последних элементов у нас z без последнего элемента будет являться наибольшей общей
подпоследовательностью равно. Из меньшей задачи мы говорим, что если у нас есть большая задача,
то она опирается на маленькую, на меньшую, которая действительно входит в нее же. Иначе мы не можем
перекрывающую задачу сделать внутри. Понятно? Да, спасибо. Если мы предполагаем, что существует
общая подпоследовательность в последовательности xm-1 и yn-1 и ее длина будет больше чем k-1,
то тогда в этом случае что мы можем сказать? То добавив в нее xm равное y
и мы получим получим общую
подпоследовательность
x и y больше
чем k. А это противоречит тому, что z — наибольшая общая подпоследовательность x и y.
Почему это противоречит? Потому что у меня в z находится всего k-элементов. Если там всего
k-элементов и она наибольшая общая подпоследовательность, то там не существует
общей последовательности, в которой больше чем k. Иначе тогда z не являлась наибольшей. Именно
в этом вся проблема. То есть мы просто два раза отталкиваемся от противного. И таким образом мы
с вами получаем, что у нас с вами есть, если у нас есть с вами последние два равных элемента,
и они равны z внутри, то они равны z внутри, и z от k-1 является наибольшей общей подпоследовательностью
от xm-1 и ym-1. То есть мы можем откатиться назад, убрав последние элементы, и они входят все равно
в нашу наибольшую общую подпоследовательность. То есть мелкие задачи действительно являются
большой подзадачей. Элементом большой. Понятно? Это первый момент, который мы с вами доказали.
Это очень круто, потому что так мы доказали оптимальность с точки зрения того, что большая
подзадача включает в себя маленький. Чудеса. Теперь давайте перейдем к
второму пункту. Второй пункт звучал следующим образом, что если xm не равно ym, то из zk не
равно xm, вытекая, что z является наибольшей общей подпоследовательностью xm-1 и y. Ну это все
достаточно тоже тривиально и просто, доказывается также примерно противно. То есть смотрите,
если давайте zk не равно xm, то z общая, ну точнее даже не противно. Общая подпоследовательность,
общая подпоследовательность, последовательности xm-1 и просто y. Ну понятно почему. Если в последнем
zk не лежит xm, то zk равно какому-то из предыдущих элементов. А если оно равно какому-то из предыдущих
элементов, то как бы ok. Так-то мы и быть, значит он там где-то раньше был. Это наибольшая общая
подпоследовательность. Поэтому мы говорим о том, что z является общей подпоследовательностью.
И здесь опять мы говорим, что если бы, если бы существовала общая, общая подпоследовательность,
подпоследовательность w, последовательности, последовательности xm-1 и y. Длина,
которая превышала бы k, то w являлась общей подпоследовательностью.
Общей подпоследовательностью последовательности x. По факту m, ну то есть все x и y. Ну то есть если
бы мы добавили элемент неравный ничему, неравный там почему-то последнему, то если мы добавим туда
элемент, общая подпоследовательность так и останется такой же. Правда? Правда. То есть она может
максимум увеличиться. Уменьшиться никак не может. Вот. А это означает, что это противоречит,
что противоречит, что противоречит, что противоречит, что противоречит, что противоречит z наибольшая
общая подпоследовательность. То есть смотрите, как это работает, еще раз. Если мы предполагаем,
что у нас есть последовательность w, которая является общей подпоследовательностью, вот xm-1 и y,
и у нее размер больше, чем k, то есть больше, чем у z, то давайте в x мы добавим еще один элемент,
xm. Если мы добавим туда еще один элемент, общая подпоследовательность так и останется общей
подпоследовательностью даже с добавленным элементом. Но если у нее размер был больше,
чем k, тогда z не могла являться наибольшей общей подпоследовательностью, потому что есть еще
последовательности, у которых больше размеров, что противоречит по самому условию теории. Вот.
То есть здесь простые такие рассуждения, которые нас приводят к необходимости,
к тому, что у нас все хорошо. Ну, третий случай аналогичен второму.
Таким образом, мы с вами доказали вот такую вот теорему об оптимальности. Что нам дает такая
теорема об оптимальности? Мы из этой теоремы видим следующее, что у нас наидлиннейшая общая
подпоследовательность, двухпоследовательность, содержит в себе наибольшую общую подпоследовательность
их префиксов. То есть исходя из того, что у нас есть наибольшая общая подпоследовательность,
мы можем найти наибольшую общую подпоследовательность префиксов. Вот. То есть задача
НОП сама по себе обладает оптимальной такой структурой внутри. То есть мы взяли и разбили
большую задачу на мелкие. То есть внутри большой задачи сохранять вот эти вот мелкие подзадачки.
Именно благодаря этому мы можем с вами говорить, что да, мы можем решать эту задачу с помощью
динамики, потому что нам необходимо как раз таки сама вот это вот, нам необходимо сама вот это
вот оптимальность. Это пока понятно все? Нет вопросов? Ни у кого? Отлично. А тогда давайте с
вами рассуждать и попробуем рекуррентно задать, а чему же равно наибольшая общая подпоследовательность.
Мы сейчас будем искать ее просто вообще в принципе, как ее можно найти, длину именно. Мы
захотим длину пока наибольшей общей подпоследовательности. Если мы с вами хотим
длину наибольшей общей подпоследовательности, то мы можем задать это с помощью рекуррента. Мы с
вами с помощью теории, мы уже увидели, что если у нас равные элементы, то они входят в нашу
последовательность. Если у нас элементы разные, то они не входят. И причем не входят типа от
префиксов, то есть у нас Z является наибольшей общей подпоследовательностью. Кто-нибудь может
на основе этого вывести рекуррентное соотношение? Давайте вот я кого-нибудь спрошу. И вот Владислав
Чшанский. Есть ли идеи, как вот из этой теории мы можем сделать рекурренту?
Пока нет. Хорошо, давайте я кого-нибудь еще спрошу. Вот, например, давайте вот Олега
Чурина я спрошу. Олег, есть ли идеи, как это можно сделать? На основе вот этой теории мы об оптимальности.
Я не слышу. Микрофон выключи.
Допустим, у нас есть НЛП для каких-то двух подпоследовательностей. Одну из них увеличим на единицу.
И будем рассматривать различные случаи. Или нет, лучше обе последовательности увеличить на единицу.
Такое не всегда возможно. Мы можем просто сделать таблетку Nm для всех префиксов x и y. И для каждой
клеточки смотреть, равны последние элементы этих префиксов? Если равны, мы уменьшаем обе
координаты клеточки на 1, берем оттуда число и ставим в нашу клетку это число вечно на 1.
В этом случае мы рассматриваем два варианта. Сравним клетку, в которой мы уменьшили префикс x и берем оттуда
число и смотрим на клетку с уменьшенным префиксом y. Естественно, берем максимум из двух чисел.
Да, отлично. Давайте с вами, с помощью того, что у нас есть, мы построим для какого-то примера.
Пусть у меня x равно, с числами работать легче, поэтому давайте с числами сделаем. Сделаем табличку
на числа. Пусть у меня x равно 1, 1, 8, 5, 3, к примеру, и y равно 0, 1, 5, 9, 7. Вот, к примеру, такие две последние.
Я думаю, вы видите здесь, что как бы наибольшая общая подпоследность является 1 и 5. Ну как бы, это их наибольшая
общая подпоследность. Так мы можем здесь действовать. Давайте сделаем табличку. У нас здесь по 5 действий.
Она может быть не обязательно квадратная, но в нашем случае у нас сейчас будет квадратная табличка.
Давайте с вами сделаем некоторую такую вот таблицу. У нас здесь будет
она не получилась сильно квадратной, конечно, но что поделать. Смотрите, первую строку и первый столбец
мы оставляем пустыми. То есть, представим, что у нас пустая строка. Вот. То есть, здесь как бы пусто.
Если у нас пустая строка, то наибольшая общая подпоследность какую длину имеет? 0, правда? Вот.
Это мы сейчас скоро и заполним. Это будет как раз-таки то самое начало для рекурсивной штуки.
Давайте здесь поставим 1, 1, 8, там, 5 и 3. Ну, чуть-чуть кривенько, конечно, у меня вышло здесь, но ладно.
А здесь 0, 1, 5, 9 и 7. Вот. И сейчас ее расчерчем. Так, так, так, так. Ну и давайте, чтобы здесь вот было
примерно вот так. То есть, вот этот вот кусок просто забейте. Сейчас я сотру. Давайте я перечерчу, чтобы
у вас было все хорошо. Вот. Здесь у меня там 7. И мы доделываем эту таблицу до ума. Вот. И давайте
заполнять эту таблицу. Когда у нас пустые подстроки, любая из подстрок пустая, у нас как бы ничего нет.
Вот. А дальше, а дальше, исходя из нашей теории об оптимальности, мы говорим, что если у нас есть
общая подстрока, то в этом случае мы как бы можем сказать, что если у нас элементы не равны на конце
наших подстрок, то есть, к примеру, что мы предполагаем, какая подзадача? Подзадача следующая.
Представим вот в этой клеточке. Вот в этой клеточке. У нас есть строчка 1,1 и 0,1. И вот в зависимости от этого
мы можем сделать какие-то решения на основе предыдущих. Вот. Но если у нас 0 и 1, то в этом
случае у нас с вами наибольшая общая подстрока равна нулю. Я думаю, вы все это понимаете. Если
у меня открыто только 0, то есть представим, что у меня открыто только 0, тогда в этом случае здесь
настолько все нулевое. Почему? Потому что нигде из элементов у нас нет нулевого. А вот если у нас
есть элементы 1 и 1, то в этом случае, согласно нашей теореме сказанным, если у нас есть равные
элементы, то префикс zk-1 является наибольшей общей подпоследовательностью от префиксов xm-1 и
yn-1. То есть в случае равенства мы говорим, что мы просто добавляем один элемент в нашу общую
подпоследовательность. То есть исходя из того, что здесь было 0, мы здесь ставим единицу. Потому
что мы взяли и добавили один элемент в нашу общую подпоследовательность. 1 и 1. Здесь же у нас
дальше тоже равные элементы. 1 и 1. Когда у нас равные элементы, давайте идти согласно нашей теореме.
Согласно нашей теореме, у нас наибольшая общая подпоследовательность, все также вот отсюда
будет идти. Будет единичка. Когда у нас элементы неравны, то есть когда у нас неравные элементы,
там xm, к примеру, и так далее, мы уже не опираемся на первый пункт. А значит, тогда мы можем взять либо
так, что мы уберем последовательность из ык, последний элемент, либо из ыкса. То есть мы можем
взять либо оттуда, либо оттуда подпоследовательность. Так давайте возьмем максимальную. Мы же ищем
максимальную общую подпоследовательность, ну и большую. Поэтому давайте возьмем максимум. В случае,
когда у нас элементы будут неравны, то мы ищем максимум из этих двух. И ничего не прибавляем,
потому что мы не можем добавить элементов. Поэтому в этом случае здесь тоже будет единичка. Дальше 1 и
5 они тоже неравны, и 1 и 3 тоже неравны. Давайте мне вот Грабунов и Вак продиктуют, как будет
выглядеть следующая строка, и исходя из чего. Можете еще раз объяснить способ? Смотрите,
когда у нас элементы равны, то есть смотрите, мы можем сказать, что вот эта единица, сейчас,
давайте зеленую возьму, вот эта единица, она равна вот этой единице, вот этой единице, правда? Да.
Тогда согласно нашей теории, которую мы только что доказали, если у нас xm равно yn, то zkt равно
xm равно yn, а z от k-1 является наибольшей общей подпоследовательностью xm-1 и yn-1. То есть мы
можем взять наше решение, которое было раньше, на основе xn-1 и xm-1. То есть мы берем просто и
убираем кусочек. То есть в этом случае мы говорим о том, что если мы убираем единичку и единичку,
которые у нас стоят вот в этих столбцах, вот в этих столбцах, галочки я поставил такие, то мы
можем рассмотреть наибольшую общую подпоследовательность, вот здесь, которую мы уже почитали, она равна нулю, и
добавить к ней элемент 1. Отлично. Теперь же, когда у нас элементы не равны, когда у нас xm не равно y, то из
zk не равно xm вытекает, что z является nop xm-1 и y. И если они не равны, то у нас zk не равно xy-1.
Оно является наибольшей общей подпоследовательностью для вот этих вот префиксов. То есть в случае
неравенства наших элементов мы можем взять наибольшую общую подпоследовательность, либо
выкинув один элемент из y, либо выкинув один из элементов из x. Понятно? А если мы выкидываем один
элемент оттуда или оттуда, то в этом случае мы просто рассматриваем эти элементы отдельно.
То есть если у нас элементы не равны, то мы можем рассмотреть результат, который был вот здесь,
либо вот здесь. Ну вот 1 и 8 неравны, к примеру. И взять из них максимальный. Мы же наибольшей
общей подпоследовательностью. Да, понятно. Понятно, теперь стало отлично. Тогда продиктуй
мне следующую строку. Ну нолик вы уже записали, значит там будет единичка, потом будет опять
единичка. Опять единичка. Еще единичка. Еще единичка. Так, ну сейчас они равны,
ну значит двойка. Потому что мы идем из такой диагональной клетки, делаем плюс один, поэтому
здесь два. А тут? Двойка. Двойка. Давайте следующую строчку мне продиктует София,
например. София Павловна. 9, 0, 1, 1, 1, 2, 2. Да, то есть у нас здесь нет элементов равных. И для
семерки давайте вот мне тоже кто-нибудь продиктует по-быстрому. Давайте вот Александр Погутин.
Так, значит для семерки у нас будет 0, 1, 1, 1, 1, 1, 2, 2. 2, 2. И смотрите,
наша наибольшая длина будет как раз-таки лежать вот здесь, вот в конце. Понятно? То есть у нас
получилась вот такая вот таблица. А по факту рекуррента будет выглядеть следующим образом.
Если мы назовем эту табличку DP, ну динамическое программирование там DP, либо там LKS еще ставят
здесь. Ну здесь все зависит от того, как вы хотите сами писать. Вот, то в этом случае нам
достаточно с вами написать просто рекурренту, как мы заполняем вообще все в принципе. А заполнять
все очень просто. Пишется, что DP получается IT, JIT. Так как мы делаем таблицу на 1 больше,
мы специально говорим, что у нас есть пустые строки, грубо говоря, чтобы мы просто могли
нормальная динамика идти. То 0 у нас будет в случае I равно 0 или J равно 0. Вот. После этого
мы говорим о том, что если у нас элементы равные, то у нас это будет DP и минус 1,
J минус 1, если у нас X и T равно Y JT. Плюс единицы еще. Ой да, плюс единичка, спасибо большое. Извините.
Плюс единицы. Вот. И максимуму, если они не равны, то есть максимум из DP и минус 1,
J. Взбитая DP, получается у нас I, J минус 1. В случае, если у нас X и T, не равно Y JT. Это понятно?
Теперь стало всё понятно. Сверху, когда у нас максимум идёт с левой части, а не сверху,
просто вроде бы все это же. Ну, с левой части, вот у нас тут пример. Если сверху, то можно
другой. Сверху? Ну, давайте здесь придумаем. К примеру, у нас будет так, что у нас сверху было
вот здесь. Вот, сейчас покажу. Давайте возьму чёрный. Вот здесь было сверху. Видно? Вот это вот,
когда было 0 и единичка, мы брали сверху. Когда у нас вот здесь двойка была, мы тоже брали сверху.
Видно? Ну, то есть оно происходит в зависимости от ситуации. Вот. И всё это благодаря этой теоремы
об оптимальности. Вопросы в общем… Пожалуйста, скажите, что такое вот LCS и DP, как расшифровывается?
Это по факту табличка. LCS – это largest common subsections, то есть это наибольшая общая
подпоследовательность. DP – это просто чаще всего в динамике. Все массивы обозначаются DP.
Поясняю, что это динамическая программировка. Такой предпочёт. Вот. Поэтому здесь, как вы хотите.
Ясно? Вот. Как восстанавливается ответ в данной задаче? Ответ восстанавливается здесь достаточно
просто. В данной задаче нам необходимо просто смотреть. Если у нас элементы не равны, то нужно
понять, с какой ячейки мы пришли. То есть если у меня вот 7 и 3 не равны, то я мог прийти сверху или слева.
Но нам без разницы, откуда. Мы могли и оттуда, и оттуда прийти. Поэтому нам нужно просто восстановить
путь. Давайте пойдём сверху, к примеру. Давайте вот я сейчас возьму какой-нибудь вот такой вот
жёлтый. Мы будем восстанавливать путь. Опять двойка 9 и 3 не равны мог прийти откуда угодно. А вот
здесь двойка я точно пришёл слева. Потому что я максимум выбирал, а 5 и 3 не равны. А вот здесь,
вот в этой ячейке у меня 5 и 5 равны. А если они равны, то я приходил явно по диагональке. Тогда
в мою последовательность Z я запишу 5. Конец. Я записываю сюда 5 и иду вот в эту ячейку. Здесь
у меня 1 и 8. Они не равны. Значит, я пришёл либо сверху, либо слева. В зависимости от того,
где максимум, туда и иду. Вот сюда, к примеру, иду. Максимум единичка, потому что слева. А здесь у
меня 1 и 1 равны. Поэтому в свою последовательность Z я запишу ещё единичку. И всё, что мне в конце,
а потом я пришёл, так как они у меня были равны, я пришёл вот отсюда. Здесь у меня 0,
ну можно уже остановиться. Либо можно дойти вот до сюда, к примеру, до самого начала. Обычно
до самого начала. То есть в Z у меня 5 и 1. Так как я считал с конца до начала, то у меня должно
получиться, мне необходимо это повернуть. Поэтому общая подпоследовательность это 1 и 5. Понятно,
как это работает? У меня вопрос. В ситуации, вот у нас есть квадратик 1, 1, 1, 2. Вот маленький,
где мы переход делали, пятёрку когда записывали. Возможно, есть ситуация, когда у нас будет
квадратик 0, 1, 1, 1. Тогда ведь не совсем понятно, куда идти. Почему? Мы сравнивали элементы х и у.
Если они равны по буквенам, то есть х и ты равно у житому, то мы пришли точно по диагональке.
То есть ситуация, когда будет 0, 1, 1, 1. Возможно. Но в этой ситуации мы всё равно пришли по
диагональке. Возможно ли? Странно было бы. Можно ли находить так, что, например, когда у нас
была вот самая последняя двойка. Два слева, два сверху. Поэтому вы сказали, что мы пришли точно не
из диагонали и идём либо вверх, либо вниз. А мы можем ли сделать вывод из-за того, что вот эта
вот, которая по диагонали, она такая же? Ну тоже двойка. Поэтому мы точно не из диагонали. Ну типа
сравнивать 3 и 3 клетки и от этого исходить. Можно от этого, но у вас есть х и ты, х и ты. Давайте
просто по динамике по тому, как мы заполняли таблицу. То есть можно по ней сравнивать сразу же и всё
понятно будет. Потому что по диагонали может быть элементом на единичку меньше. Я сейчас в
принципе в голове, наверное, придумаю. Нет, такого быть не может. Но сама суть в чём смысл? Как бы
доказать одну тяремку, мы смогли всё решить. Построение будет работать вот именно таким вот
образом. Я думаю, что вы сможете написать этот код этой задачи самостоятельно, правда? Без того,
что вам нужен там псевдокод. Заполнить табличку вы сможете. Если нужно восстановить, восстановить вы
тоже сможете. Просто идя задом наперёд и потом развернув этот массивчик. Ясно? Если нам надо
посчитать, почему не за две линии это сделать? В смысле за две линии? Ну фактически мы эту таблицу
строим, как фиксируем какой-то элемент и потом проходимся по x. Потом приходим на следующий
элемент. У нас посчитано, какое максимальное количество уже, максимальная последовательность у нас
есть с этим элементом предыдущим. Но зачем, если мы встречаем следующий элемент, в последовательстве
у, просто увеличиваем предыдущее значение на единицу. Почему? Потому что мы встретили этот
элемент в последовательности x. В зависимости от того, в каком месте ты его встретил. Пойми,
что если я добавлю в x еще здесь конец 0, то этот 0 как бы мне не сыграет роли большой. Ну и в
действительности, я думаю, вы понимаете, что этот алгоритм работает за у от н квадрата.
Вот. Я думаю, это понятно. Таким образом, вот решение задачи nop. Есть вопрос еще к этому всему?
Видимо, нет. Хорошо. Теперь перейдем к задаче nvp. Как вы думаете,
что такое nvp? Наибольшая возрастающая последовательность. Наибольшая возрастающая
подпоследовательность. Задача. Нвп. Ну по-английски это largest increase subsequent.
Вот. В чем заключается задача наибольшей возрастающей подпоследовательности?
Смотрите. Наибольшая возрастающая подпоследовательность строится по одной
последовательности. То есть представьте следующее. У меня есть массив чиселок.
Ну там какой-нибудь. Давайте сейчас напишем. 1-5-8-7-3-4. Что такое наибольшая возрастающая
подпоследовательность? Наибольшая возрастающая подпоследовательность. Такая подпоследовательность,
что в ней будут возрастать все элементы и идти строго друг за другом согласно тому,
как было в последовательности. В данном случае, если мы будем рассматривать эту
подпоследовательность, что будет наибольшей возрастающей? Как вы думаете? 1-3-4. Еще есть
варианты минус 5 3 4 к примеру еще наверное больше нет наверное больше то есть элементы не
должны подряд идти обязательно не должны эта задача связанная с тем чтобы выбрать просто
элементы которые идут возрастающие ну не угодно еще раз каким образом устроили построил последователь
под последовательности мы выбираем любой из элементов вот к примеру единицу и все что идет
после него можно построить здесь 1 8 под последовательность к примеру то есть мы
выбираем любые элементы но суть в следующем что это давайте тогда формально напишу чтобы
вы знали вы могли на это ответить спокойно а не больше возрастающая под последовательность строки
строки икс длины n это последовательность это последовательность икс и минус 1 так далее икс
давайте здесь не тогда ли а просто меньше сразу кажем икс и минус один меньше икс и минус два
икс и 2 меньше и так далее меньше чем икс от иката какой-то символы символ икс причем
причем и 1 меньше и 2 меньше и так далее меньше и и и один ну там меньше либо равен 0 если мы
с нуля считаем 0 меньше либо равен там и житое меньше либо меньше чем если с нуля ну как стоять
что еще раз а нет не обязательно да понял я подумал что длины если н тогда индекс максимальный
но потому что нет причем смотрите причем к тире а наибольшей из возможных наибольшие из возможных
я думаю это вам понятно ну теперь стало понятно совсем уже окончательно что это если мы ввели
формальное определение наибольшего возрастающая под последов revelation мы просто выбираем какие-то
элементы идущие друг за д coating и не обязательно друг за другом но в правильный последовательности
как наши последовательности вот и они возрастают вот это возрастающая под последовательность
вопросuros а обязательно они должны строго возрастать или задачи может как-то различаться
Ну, если вы хотите вести не строго возрастающую подпосредственность, так тоже можно, в принципе.
Вы сейчас увидите, как мы будем это строить, тогда возможно.
Но вообще, именно возрастающая подпосредственность, она не зря называется наибольшая возрастающая, увеличивающаяся.
То есть она строго возрастающая?
Да.
Ну, все, хорошо, спасибо.
Вот, если как-то вы захотите модифицировать, пожалуйста.
Смотрите, здесь никакой дикой корректности нам не необходимо.
То есть мы понимаем, что если у нас была подпоследовательность какая-то,
и мы добавим туда элемент больше, чем все предыдущие,
то мы получим еще одну возрастающую подпосредственность.
И таким образом мы можем с вами там перебирать различные варианты.
Как строится наибольшая возрастающая подпосредственность?
Давайте построим массив D такой, что D и T – это длина
наибольшей возрастающей подпоследовательности оканчивающейся в элементе,
с индексом и массив.
Вот, ну как мы будем строить этот массив? Что это означает?
Массив D и T. Вот давайте с вами опять вернемся к той же последовательности,
которая у меня была 1-5-8, давайте сюда перепишу, 1-5-8, что там еще? 7-3-4, 7-3-4.
Вот этот массив х, я хочу построить массив D. Смотрите, какая наибольшая возрастающая
подпоследовательность оканчивается на единичку, если нам известна только лишь она?
1. У нее размер 1, то есть сам этот элемент. У минус 5, то есть мы будем открывать элементы поочередно,
грубо говоря. Если мы открываем минус 5, то, Кирилл Сергеевич, скажите, какая последовательность
с длиной максимальной? 1. А вот если мы откроем восьмерку, что еще раз? Если мы открываем восьмерку,
то что там будет, Владислав? Или кто там сказал 2? 2 будет. Это либо 1-8, либо минус 5-8, любая споседа.
Если мы открываем еще семерку, то здесь какой ответ будет? Тоже 2. На трех это будет тоже 2. А вот на
четырех это уже будет 3. Смотрите, а где будет лежать ответ, где у нас лежит максимальная
подпоследовательность? В наибольшем элементе. Наибольшем элементе? А, ну или нет, нет, нет.
Так. Ну, в последнем элементе. Нет, нет, нет, непонятно где. Надо отсортировать. Надо просто
найти максимум длины, но при желании, если очень не хочется это делать, хочется сделать так,
чтобы это вошло в остальную программу, которую мы уже сделали. Мы можем добавить лишний элемент
в последовательность, которая больше всех остальных, если мы, например, знаем ограничение,
чтобы иметь в конце. Нам просто надо тут посмотреть, где наибольшая длина в нашей последовательности
получилось. Ну, то есть, грубо говоря, да, действительно, по факту нам нужно найти максимум.
Если бы я в эту последовательность добавил здесь, к примеру, 0, то у меня в конце был бы ответ,
но я думаю, вы все понимаете, что 2. Ну, минус 5 и 0. И он не лежит в конце. И вот это та задача,
где необходимо найти ответ именно просто как максимум по всей этой последовательности.
А сколько это будет работы поиска максимума? Можно, конечно, соптимизировать так, что мы
будем искать одновременно с этим всем все остальное. Но суть в том, что мы все равно будем искать это,
как массив заполняется. Ну, мы сначала заполнен там D от нуля, потом D от единички и так далее.
То есть, у нас как будет проверяться? Мы будем работать следующим образом. Рассмотрим какой-то
из элементов. Например, давайте вот эту тройку. Мы не знаем еще какое число там поставить. Ну,
как мы будем искать? А давайте посмотрим все предыдущие наши элементы, все предыдущие,
и увидим там, где элемент у нас меньше чем 3, мы можем в конец добавить тройку. Правильно? Ну,
поставим. И тогда давайте поставим туда и сделаем плюс один от этого всего и получим
наши результаты. То есть, мы будем сравнивать 3 со всеми элементами до и увеличивать на единицу
относительно того, что у нас есть. Однако, если элемент оказался там меньше. Однако,
нам нужно все равно найти там максимум. Поэтому здесь надо там написать будет немножко по другому.
Вот. Давайте здесь все же напишем псевдокод к этому всему, как это правильно считается,
но здесь все достаточно, наверное, просто. А можно вопрос наперед? А тут разве не
будет сложности от n квадрат? Будет. Первоначально мы сейчас рассматриваем построение за n квадрат.
Хорошо. Если мы сегодня не успеем построение за n логен, с вами рассмотрят это на семинаре.
Ясно? Да, хорошо. Мы к этому как раз и придем сейчас. Вот. Пусть у меня там массив есть,
не знаю, какой-нибудь а. Давайте сделаю снова странички. Массив а, размер n. Я хочу найти длину
максимальную, которая у меня в принципе есть в этом массиве. Тогда мне достаточно сделать
следующее. Написать здесь. Ну, у меня есть еще массив d. D, который там тоже в начале есть,
и у него тоже размеры. Я просто делаю следующее for и равное нулю то там n-1. Я говорю, что d и t
равно 1. После этого я говорю for, g равное нулю, получается до и-1 элемента. То есть рассматриваю
абсолютно все предыдущие элементы. И в случае, если у меня а gt меньше, чем а и t, то есть если у
меня вот это вот есть то, что я могу а и t добавить в конец, и d от g плюс 1, то есть тот элемент,
который меньше, если я добавлю туда элемент еще один, у него будет на один больше в этой
последовательности. То есть dg плюс 1 последовательность будет такая, будет больше,
чем то, что у меня сейчас находится в моем элементе и, то в этом случае, то в этом случае я говорю
следующее, что у меня d и t равно dg t плюс 1. Я здесь так писал, давайте без скобочек.
Я же писал без скобочек. Вот. И тогда максимальная длина равна максимуму из d.
А вот еще раз, что в каких массивах у нас хранится?
Массив a является первым массивом. Ну то есть массив заданных чиселок. Массив d – это тот
массив d, в котором мы будем хранить то, что нам необходимо. Ну то есть вот это вот длину нашей
последовательности, возрастающей наибольшую. Понятно? Вот. Как восстанавливается ответ? То есть
восстановление ответа тоже будет на вас, потому что его вам необходимо будет восстанавливать. А
как можно восстанавливать ответ? А очень просто в этой задаче можно восстановить ответ. А давайте
сделаем следующее. Пусть у нас есть, помимо массива d, есть еще массив предыдущих. Где у нас
будет приходить индекс, откуда мы пришли? Просто вот откуда мы приходили. И если у нас здесь стоит
единичка, то мы ниоткуда не пришли. Это само число является этой подпоследовательностью. Правильно?
Правильно. Для восьмерки мы пришли к восьмерке от единички, судя по тому алгоритму, который я
написал, потому что мы начинаем с нуля. Если мы начинали с конца в начало, то было бы там единичка.
То есть здесь ноль. Индекс откуда мы пришли. В семерку мы также пришли с нуля. В тройку мы
пришли с нуля. А вот в четверку мы пришли с раз, два, три, четыре, пять. И с четвертого элемента.
В нолик мы пришли также с единички. И вот как мы будем ходить? Мы выводим само число, когда мы
нашли максимальную длину. Мы выводим само число. Мы с единицами пришли в ноль.
Да, с минус 5, извините. Все правильно. Отлично, здесь будет один. Вот, мы находим максимальное число.
Максимальное число. А это три. Вот она максимальная подпоследовательность. Тогда мы записываем с вами
4. И идем к предыдущему. Предыдущий находится на четвертом индексе. Но четвертый индекс не
сложно обратиться. За 1 мы можем. Это 3. А дальше у него предыдущий индекс это ноль. Таким образом,
возрастающий подпоследовательность равна 0, 3, 4. То есть опять наоборот. То есть мы опять идем с
конца в начало. Понятно, как восстанавливается ответ? Ой, 0, 3, 4. 1, 3, 4. Извините. Нолевой индекс
от единичка. Ясно? Вопросы к этому построению есть? А можете еще раз вернуть в реализацию?
Конечно, могу. Реализация вот такая. Не очень сложная. Ну и как вы понимаете,
этот алгоритм работает за о от n квадрата. Потому что мы на каждом элементе просмотрим все
предыдущие. То есть первый там просмотрит 0 элементов, второй 1, третий там 2 и так далее.
Это будет арифметическая прогрессия. Будет там n на n плюс 1 пополам. О от n квадрата. Ясно?
Окей. И давайте я сейчас кратко расскажу, потому что там вопросов должно быть гораздо больше. Но
постараюсь объяснить все, что есть. Существует решение за n логы. То есть быстрее. Вот у вас
есть задача. Просто НВП и быстрое построение НВП. Быстрое построение это n логы. Построение за
о от n лог. Давайте мы изменим наш массив d. Пусть у меня в d и там, сейчас так, пусть. Пусть
d и t. Ну там от 0 до n. Давайте на всякий случай напишу и равное 0 и так далее n. Это число,
на которое. Только я минус 1 наверное. Нет. Сейчас вы поймете, что такое d, поймете почему так.
Это число, на которое оканчивается. Окончивается. Окончивается возрастающая последовательность,
не наибольшая, просто возрастающая последовательность длины.
Понятно? Изначально мы сделаем d и t. Д0 равно минус бесконечности, а d1 равно, так далее,
равно dn t равно бесконечности. Смотрите, два важных свойства этой динамики. Два
свойства. Первая. Я думаю вы понимаете, что d и минус первая. А, если несколько значений,
смотрите, вот у нас было такое, что у нас есть возрастающая подпоследовательность, может,
а, ну здесь было несколько возрастающих подпоследовательств, но заканчивается они
на четверку. А представим, что у меня было бы здесь несколько вариантов. Было бы 4 и 3. Если у
нас несколько вариантов, то мы в d и t ставим наименьше. Это важно. Если несколько возрастающих
последовательств длины, то выбираем наименьший конец. Это важное еще одно
свойство. Точнее, важные условия динамики. Первое свойство, это то, что d и минус первое меньше
либо равно d i t. Почему так? Ну, это все достаточно просто, потому что у нас на i минус первой позиции
там у нас стоит какое-то число, к примеру, на которое оканчивается возрастающая последовательность.
Если у нас есть большая возрастающая последовательность, то именно с первым числе,
ну представьте следующее. У меня есть последовательность 1, 3, 5. Она длины 3 и заканчивается
на пятерку. А у меня есть там последствия 1,8. Но в d и t я буду хранить наименьшее число. И как
минимум есть вот эта тройка, которая меньше и стоит на i минус первом месте. Поэтому d и минус первое
меньше либо равно d i t. Потому что если мы рассмотрим последовательность длины 3, то в ней
последовательность длины 2 и там вот это последнее число меньше, чем последнее число из последовательности
длины 3. То есть благодаря вот этому мы можем балансировать. Может быть есть число еще меньше,
но учитывая, что мы все время обновляем туда и кладем наименьшее число в конце, которое стоит,
то у нас все хорошо. То есть как минимум вот этого число 3 есть. Это первый момент. Второй
момент, который необходим здесь. Это то, что каждый элемент i и t обновляет максимум
1,1 d i t. То есть при обработке каждого i и t мы обновим максимум один из элементов d i t. Почему так?
Потому что в случае, когда если бы он обновлял два элемента, то у нас бы последовательность,
ну предположим он обновлял там второй и четвертый. Но если бы он обновлял четвертый, то у нас до этого
была бы последовательность возрастающая, которая бы хранилась из этих четырех элементов элементики.
И там второй был бы меньше, чем сам этот аидый. Понятно, что я имею в виду или нет?
Задумайтесь над этими свойствами. Ясны ли они вам?
Люди просто отключаются и понимают. Можете, пожалуйста, еще раз пояснить второе?
Второе. Каждый элемент i и t обновляет только один d i t. Представьте следующее. Вот у меня была
последовательность там 1,3,5. И вот я добавил 4. Смотрите, у меня появились новые последовательности.
1,4, 3,4, 1,3,4. Ну и все вроде. Вот я добавил 4. То есть как бы добавили несколько последовательностей
возрастающих, ну еще сам 4. Все остальные были раньше. Но так как я четверку вот здесь ставлю
в конец, то существует возрастающая подпоследовательность из как минимум двух
элементов. То есть было 3. Ну то есть до этого была возрастающая подпоследовательность 1,3,5
из трех элементов. Теперь я добавил 4. У меня появился 1,3,4. 4 не может обновить последовательности
длины 2. Почему? Потому что если есть последовательность длины 3, то в ней хранится
элемент меньше, гораздо меньше, ну не гораздо, просто меньше, чем это четверка. В этой последовательности
длины 2. А так как у нас в деитом хранится наименьшее число, на которое оканчивается
возрастающая подпоследовательность, то четверка никуда больше встать не могла. А на максимум могла
поменять одно число такое. Так стало понятным? Да, спасибо. Ага, отлично. Меньше либо равно уже. Что еще
раз? Ну в последовательности из двух элементов хранится меньше либо равно. Просто сказали меньше,
строго. Ну если мы рассматриваем возрастающую подпоследовательность, то меньше. А теперь смотрите,
если у меня di-1 меньше либо равно деитово, какой здесь массив? Отсортированный. А если аито
обновляет максимум один элемент, то что в этом случае? В этом случае мы можем делать бен поиск,
правильно, за счет этого и делается логерезмическая сложность. Каким образом мы просто находим место,
куда нам вставить этот элемент аито в нашей последовательности? Давайте на примере это сделаем,
а реализацию тогда уже оставим на семинар. Давайте сделаем какой-нибудь пример. Пример
следующий. Я сейчас не знаю какие числа из головы возьму. Вот давайте мне кто-нибудь их
продиктует, чтобы не сказали, что все куплено, все понятно. Дарья решать некогда, давай. Придумай
мне просто пять любых чисел, чтобы там были какие-нибудь возрастающие подпоследовательности внутри.
Минус 7. Минус 7. Ноль. Ноль. Четыре. Четыре. Пять. Один. Пять. Один. Ну хорошо, получим так.
Давайте с вами поэлементно добавлять в наши деиты элементики. На любом шаге у нас будет,
давайте вот так отделю, на любом шаге у нас будет минус бесконечность и пять бесконечностей. Раз,
два, три, четыре, пять. Вот здесь вот у нас будет нулевой индекс. Первый, второй, третий,
четвертый, пятый. Зачем нужна минус бесконечность? Чтобы нулевой индекс что-то могли ставить. Просто
на самом деле. Ну то есть бинпоиск работал бы корректно. Вот. Дальше у нас появляется первый
шаг, когда мы добавляем минус 7. Минус 7 должно заменить что-то. И мы ставим ее на первое место.
То есть минус 7 самая минимальная последовательность. Там длины какой-то. Поэтому у нас будет
минус бесконечность, минус 7, бесконечность, бесконечность, бесконечность, бесконечность.
Дальше у нас появляется второй шаг. На втором шаге у нас добавляется ноль. Ноль не является
меньше минус 7. Поэтому первое мы не обозначим. Давайте я добавлю сюда вот не четыре, а минус пять.
Чтобы мы как-то что-то добавили. Вот давайте не минус пять, а минус восемь. Чтобы у нас было
обновление, вы увидели как точно это работает. То случайно может перепутать. Вот. Дальше у нас
будет минус бесконечность, минус 7. И есть последовательность длины 2. Это ноль. И ноль как раз
таки, если мы бинарным поиском найдем, его место будет вот здесь. Вот здесь у него будет место.
Поэтому давайте я буду красным рисовать то место, куда мы добавляем. У нас будет минус 7, здесь
появился ноль. Все остальное осталось без изменений. Бесконечность, бесконечность, бесконечность.
Теперь третий шаг. На третьем шаге мы добавляем с вами четверку. Четверка может быть там,
встать на третье место. Почему? Мы просто бин поиском ставим. У нас будет вот здесь вот четыре,
а здесь элементы не изменятся. То есть у нас будет минус бесконечность, минус 7, ноль, бесконечность,
бесконечность. Теперь рассмотрим четвертый шаг, когда мы добавляем минус восемь. Вот когда мы
добавляем минус восемь, мы ищем бин поиском его место. А где находится его место? Вот давайте
я кого-нибудь спрошу, спрошу, спрошу. Вот Вячеслава Панкова, например. Минус восемь.
Смотрите, минус восемь будет вот здесь. Здесь будет минус бесконечность, здесь ноль,
здесь четыре, бесконечность и бесконечность. И теперь у нас есть единичка. Пятый шаг. У нас
будет минус бесконечность. Куда встанет единичка? Давайте я спрошу еще кого-нибудь. Вот давайте
я Елизавету спрошу. Там, где четверка стояла? Там, где стояла единичка, там, где четверка,
неправда. Бин поиск, как работает? А, ну да, все правильно. А все правильно, бин поиск не так
и работает. То есть он первое число, которое больше у него, заменяет. Поэтому у нас будет с вами
минус восемь, ноль, потом здесь будет один, а здесь будет бесконечность, бесконечность.
Таким образом, мы с вами построили. Что является наибольшей длиной, возрастающей под последовательностью?
Является то первое число, где у нас в конце не стоит бесконечность. Мы разве правильно воткнули
минус восемь? Да. Она же стоит после нуля. Ну, факт. Так, и что? У нас же будет ноль,
минус восемь, один, это не возрастающая последовательность. Ноль, минус восемь, один. Так, а что не так с минус восемь?
Ну, мы когда вставляем ее на место минус семь, мы еще должны проверять, что оно не меньше. Не меньше
чего? Ну того, что там было стояло. Ну, минус семь больше, чем минус восемь. Так, сейчас же,
у нас должна получиться возрастающая последовательность. Ноль, минус восемь, один. Это не
возрастающая последовательность. Еще раз, здесь в этой таблице хранится непоследовательность.
Какой пример сделал? Хранится лишь только то, на что оканчивается возрастающая последовательность
длины и, и там в конце стоит наименьшее число. Поэтому на третьем месте в конце стоит единичкой.
И наибольшая возрастающая последовательность имеет длину три. В конце у него стоит единица. А вот
откуда мы пришли в эту единицу? Вам необходимо самостоятельно разбираться,
к примеру. Вот на этом вот мы с вами закончим. Это вы узнаете на семинарах. То есть смотрите,
главное, что вы можете понять из этой таблицы то, что у вас наибольшая длина возрастающей
последовательности равна трем. Если она равна трем, то все хорошо. Ясно? Вот.
А если у нас нестрого возрастающая, у нас же все то же самое? Не строго возрастающая,
здесь уже необходимо подумать. Сейчас я так быстро не могу почему-то ответить на это. Вообще не
должно сильно что-то менять. Ну хотя сейчас. Тогда немножко нужно переделать бинпоиск. Чуть-чуть. То
есть нужно заменять всегда число первое больше. Потому что у вас может получить там 1,1. Если бы
у вас были одинаковые элементы, то этот бинпоиск, который здесь должен быть, он бы заменял число,
которое необходимо. Которое такое же. То есть единицу на единицу, к примеру. То есть там
зависимости от равенства меняется. Ну то есть зависимости от равенства, что вы захотите делать.
Но это вам не нужно особо пока что. Мы рассматриваем именно возрастающую последовательность. Есть ли
вопросы к этому всему? Если нет, то смотрите. Благодаря бинпоиску и месту куда вставить,
этот алгоритм работает за о от n лог n. Почему за n лог n? Потому что мы для каждого числа ищем
его место бинпоиска. У нас там ровно n плюс один элемент. Вот мы берем бинпоиск,
это работает за логарифом. Ищем его первое место, туда вставляем и так далее. Вот нужно
это вам будет реализовать позже. Если у вас нет вопросов, то вы можете быть свободны. Если у
вас вопросы есть, то вы можете их задать всем остальным. До свидания.
