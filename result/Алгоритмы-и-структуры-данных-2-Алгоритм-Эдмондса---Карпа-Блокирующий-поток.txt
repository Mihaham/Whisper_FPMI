Итак, в прошлый раз мы изучили в подробностях, что такое
поток.
Вот мы изучили, что такое поток и зачем он нужен.
Точнее, какие задачи с помощью потока можно решать.
Но парадокс заключается в том, что мы при этом практически
не придумали никакого конкретного алгоритма, который этот
поток эффективно ищет.
Ну, по крайней мере, в общем случае.
То есть, у нас пока максимальное достижение, которое у нас
есть, это метод Форда Фолкерсона.
Что нам говорит метод Форда Фолкерсона?
Он нам говорит, что давайте-ка в остаточной сети, мы себе
воображаем, что у нас есть остаточная сеть, которая
в точке зрения практики означает, что мы имеем право
пускать дополнительный поток по ненасыщенным
ребрам, а также отменять поток, так сказать, по уже
имеющейся.
Не будем сейчас воспроизводить определение обратной сети,
думаю, все и так его помнят.
И оказалось следующее, что метод заключается в том,
что мы будем проверять, есть ли в остаточной сети
путь от СДТ по ненасыщенным ребрам, и если есть, то давайте
пускать по нему поток.
Максимально, который возможно, чтобы хотя бы одно из этих
ребер насытилось.
Говорим мы.
Вот, но мы практически ничего не сказали о том, как конкретно
мы это будем делать.
Некоторые задачи этого хватает, задача о поиске
просочетания, в общем-то, это уже дает алгоритм, который
ищет максимальное просочетание за ВЭ, в принципе, вот само
по себе.
То есть алгоритм Куна это просто такая, называется
круто модифицированная реализация просто методов
Форда Фолкерсона на самом деле.
Да, теорему эту мы доказали.
Вот, да, то есть мы доказали, что, да, я сказал метод Форда
Фолкерсона не путать с теоремой, да, теорема обосновывает
то, что этот метод найдет правильный ответ.
То есть если вы таким образом, то есть будете применять
этот метод и этот вайл у вас завершится, то соответственно
найденный вами поток будет максимальный.
Теорема, конечно, мощнее, она доказала не только
это, она еще доказала то, что этот максимальный
поток равен минимальному разрезу и мы в прошлый раз
тоже убедились, что на самом деле понимание этого
позволяет решать еще на самом деле некоторое количество
задач, в том числе чисто математических.
То есть на самом деле я должен сейчас огласить еще одну
задачу, я не буду сейчас рассказывать, как ее решать,
потому что очень интересно, что вы ее вот именно решили,
то есть это на самом деле такое упражнение, на то,
что мы в прошлый раз по Леймхоллу обсуждали.
Значит, теорема, значит, задача звучит так, она же
теорема, то есть она периодически применяется.
Представьте себе, что у вас есть двудольный граф,
значит у вас есть двудольный граф без кратных ребер,
без кратных ребер, но при этом степень каждой вершины,
каждой вершины равна D, а может быть даже, кстати,
можно подумать и с кратными реберами, не важно, вот это
называется D регулярный граф, это, кстати, стандартная
терминология, D регулярный граф, вот, предположишь,
что вот, ну, правда, двудольный, в нашем случае двудольный,
потому что при теперь D регулярный граф не обязан
быть двудольным, очевидно.
Вот, задачка, докажите, что в двудольном D регулярном
графе найдется совершенное просочетание.
Где D хотя бы… Ну, где хотя бы один разумеется.
В плане вообще любого D хотя бы нет.
Ну, просто любое, что там одно ребро из каждой вершины
торчит, что две, что три, да, ну, в качестве, естественно,
в качестве простого следствия, что ребра этого графа можно
разбить на D совершенных просочетаниях.
Ну, логично, да, это прямое следствие, да.
Ну, можно применять именно лемму Холла, но вот, ну,
тут по-разному, понятно, там, в разные способы можно
решать, можно применить, можно попробовать применить
собственно лемму Холла, можно ее не применить, а применить
то, что вы применяли для доказательства леммы
Холла.
И там в стойке зрения на курсе может быть самое интересное
доказательство.
Можно, нет, можно хоть там про просочетания там
доказывать, что там рассмотрим любое несовершенное просочетание
и докажем, что удлиняющая цепь есть.
В принципе, такие доказательства тоже есть.
Вот, но это, впрочем, уже будет на ваше усмотрение.
То есть, в принципе, то есть я утверждаю, то есть, на
самом деле, в принципе, если вы, вот эти вот, это интересный
способ просто разобраться именно с доказательством
самой леммы Холла, которую мы обсуждали в прошлый раз.
Это из домашней задачи, Веря.
Ну, кстати, да, в домашке она тоже может оказаться.
Вполне.
Вот.
Да, а да, да, как говорится, да, а домашка существует.
Ну, как, ладно, пока не существует, но...
У нас нет никаких доступов, да, да.
Да.
Нет, ну, как сказать.
Ладно, пожалуйста.
Ну, на текущий момент, скажем так, понятия не существует
ближе к истинке.
То есть, как бы, нет, вы же знаете, у вас нет никаких
доступов, это означает, что контест готов, там
он уже там ждет задачи, но просто я вам еще не выдал
логин и пароль.
А так, по мотивам Ильи Мещерина, задача составляется
в день перед экзаменом.
О!
Не?
Не, ну, это безопасно, кстати, для экзамена.
Для экзамена создаются, во-первых, передачи.
О-о-о!
Задачи создаются после комиссии.
Ну, вот это, да, вот это самое страшное, когда, да, вопросы
на экзамен создаются после экзамена, да, и выставление
оценки, да.
Ну, впрочем, ладно.
Так вот, это вот была задача, этому-то упомянули, то есть,
как бы, если вы хотите разобраться, доказательством леммы Холла,
то есть, как бы, можно идеально понять, что вы там действительно
все поняли, если в ровно тем же методом вы решили
эту задачу.
То есть, в общем-то, если вы там метод поняли, то
ничего сложного нет, просто вот то же самое.
Вот.
Так что это еще один пример того, что действительно
терема Форда Фолкерсона, особенно в части про минимальный
разрез, дает, дает, действительно, там, можно ли так выяснить,
серьезно, там хороший импакт, прям, именно даже в экологически
чистой математике, казалось бы.
Ну вот, казалось бы, что-то программисты там какие-то
и так далее, а вот, пожалуйста, то есть, иногда приходит,
да, что-то там все, да, математики думают, программисты запустим
ДФС там или там, вот, примерим терем Форда Фолкерсона.
Вот.
Ну и сегодня мы, ну вот, но, с другой стороны, да,
с другой стороны, мы знаем, что метод Форда Фолкерсона
сам по себе предлагает нам что делать.
Ну предлагает, давайте запустим, там, давайте будем искать
этот путь, ну, например, к ДФС, ДФС у нас работает
за Е, вот, и, ну вот, но сколько раз он будет запускаться,
непонятно.
Ну, здесь, на самом деле, есть разные моменты, вот,
сегодня, то есть, на самом деле, это потому что есть
понятие целочисленные сети, вот, то есть, это заголовок,
который у нас в какой-то момент появится, вот, то
есть, целочисленные сети, то есть, это, то есть, такая
классическая ситуация, то есть, там, кто-то может
даже иногда не заподозрить, что бывают иные, но вот,
то есть, это такая ситуация, когда у вас, ну, вот, когда
у вас все пропускные способности целые, то есть, это не обязательно,
то есть, в принципе, в определении сети, в общем-то, никто вам
не обещал, что там, как их называют, емкости должны
быть, не, то есть, должны быть целыми, ну, которые
capacity, да, оно же пропускные способности, вот, они не
обязаны быть, но, тем не менее, то есть, более того,
в принципе, конечно, по-хорошему никто не обязан говорить,
что там какой-нибудь максимальный поток, он обязательно там
целочисленный, но, с другой стороны, метод Форда Фолкерсона
гарантирует, что максимальный целочисленный поток вполне
себе найдется.
И более того, в целочисленных сетях, в принципе, вот, асимптотика
О от Е модулев становится вполне себе валидной.
Вот, в целочисленных сетях можно сказать, что метод
Форда Фолкерсона даже тупо с ДФС сработает вот за
сток.
Вот, но, правда, в нецелочисленных сетях такого вы написать
не можете.
Почему?
Потому что вполне вероятно, что за один ДФС вы будете
меньше одной единицы потока проталкивать, и это не очень
хорошо.
То-то и прикол, что нет, то-то и прикол, что нет.
Вот, более того, на самом деле, может оказаться, в
принципе, даже есть достаточно не сильно сложный пример,
на самом деле, не будем сейчас тоже в него копать, что
на самом деле в правильно построенной нецелочисленной
сети, естественно, иррациональной, на самом деле тупой метод
Форда Фолкерсона может не завершиться никогда.
Никогда?
Прямо никогда.
Более того, поток даже не будет сходиться к правильному.
Который метод Фолкерсона находится?
Да.
Ну, отдельная песня, конечно, там, это именно с каким-то
адекватно написанным ДФСом такое происходит, или вам
просто фатально не везет, но факт остается фактом.
Ну вот, а нам бы, конечно, у нас чаще всего, конечно,
такое не устраивает.
Иногда, конечно, устраивает, то есть там в задача, скажем
так, в конкретной задаче нас может это устроить,
что в задаче о просочетаниях мы из этого получаем ВЭИ
и, в принципе, уже радуемся.
То есть уже неплохо.
Да, сегодня у нас, конечно, будет алгоритм, который
будет искать просочетания лучше, но тем не менее.
Но в общем случае нас, конечно, такое устроить не может.
Поэтому, значит, поэтому мы будем изучать какие-то
более продвинутые алгоритмы.
Ну в идеале там как бы первую цель, все хочется сказать,
что а нельзя ли найти какой-то алгоритм, у которого симпатика
не будет зависеть от, собственно, размера потока.
Ну не говоря уж о том, что поток бывает там, собственно,
это иррациональный какой-нибудь.
Вот.
Ну на самом деле первая идея просто окажется, на самом
деле лежит от нас в шаговой доступности.
Вот мы сейчас обсуждали, что метод, что как бы путь
в остаточной сети можно искать ДФС.
Вот.
А теперь я искаю этот вопрос.
Так, ну хорошо, если не ДФС, то как искать?
Ну вот.
Ну вот там такой-то приходит, да, какой-нибудь русский
БФС.
Ну вот.
Ну как бы, знаете, это классический, ну классический, там Михаил
Николаевич еще рассказывал, собственно, ситуация, когда
там в японской компании действительно обсуждали
проблему, что как бы открывать дверь, чтобы люди не касались
руками там ручки, потому что она как бы грязная,
поэтому не хочется.
То есть там педальку как, то есть что-то там, то есть
надо думать там что-то как-то.
То есть там то ли сафеточки, то ли что, а потом приходит
русский.
А потом, ой, извините, опоздал.
А что обсуждаем?
Слушайте, а вот как открывать дверь, если на руку?
Вот сразу ногой.
Чего?
Вот.
Вот.
Вот.
Вот чего.
Ну вот.
Нет, или а как такой?
Ну он им там всем-то быстренько педальки там нарисовал
какой-то на эту тему.
Ну вот.
Соответственно.
Скрутить просто за щелку и на пыль, и на пыль.
Не, ну не, ну спокойно, спокойно.
Ладно, не будем указывать там подробностей, вы можете
там найти соответствующее видео Михаила Николаевича
соответственно, поэтому да.
Вот.
Ну, кстати, на всякий случай, так, подивите, кто понимает,
каком Михаил Николаевич, я говорю.
Не, если бы Задорнов.
Вы не знали поколения просто,어�и kiss?
Ну да, не знаю, у меня, да.
Нет.
Я не знаю...
Ну я знал, что это как бы Задорнов, backups-ино, то
отли finite поколения, но не знал, что настолько.
Я не знал, что он Михаил Николаевич.
Нет, он Михаил Николаевич.
Да, да.
Но конечно да он да, да и может, он иногда известен.
Но может он и иногда известен как дядя Миша
но ладно, сейчас еще он известенuni hàngа задosc spiritually
конечно.
Ладно.
Нет, это все за зад buffs там там ещё.
В данном случае то же самое. Как искать поток, если не DFS? BFS.
То есть давайте на каждом шаге находить путь из SFT, который состоит из минимального числа ребер.
Ну как это ни странно, этот алгоритм не редко будет облиться именной.
Это называется алгоритм Эдмонса Карпа.
То есть что такое алгоритм Эдмонса Карпа?
Эдмонса Карпа. Применяем метод ворда Фолкерсона.
То есть вот так, смотрите, я так это пишу.
Алгоритм Эдмонса Карпа.
То есть просто в нашем случае просто FF с BFS. Все.
6 букв.
Вот. Ну то есть понятно, что ладно, там свои статьи Эдмонс Карп, наверное, таких букв нет.
Ну ладно, эти буквы использовали, вот этот не факт.
Ну вот.
Но, значит, основной интерес здесь заключается не в этом.
Основной интерес заключается в том, за какое симптомико это работает.
Значит, мистическим образом оказывается верна теорема, что алгоритм Эдмонса Карпа работает за O от VE квадрат.
VE квадрат?
Да.
Ну то есть на самом деле, нужно писать как бы строго минимум из VE квадрат и E модуль F.
Ну, мы докажем, что теорема работает за VE квадрат.
Отсюда автоматически следует, что, то есть можно доказать другую теорему о том, что там этот FF с BFS работает не более, чем за ZE на модуле тоже.
Ну это если в целочисленных сетях, отсюда следует, что он работает за минимум из того и того.
Это да.
Вот.
Ну, тем не менее.
Ну в данном случае, действительно, тут, но с другой стороны, в нецелочисленных сетях там оценка ZE, как мы уже обсудили, не работает, там вылетает с трубу просто, чисто смыслово.
А эта оценка за VE квадрат работает.
То есть это будет наш первый алгоритм, в котором время работы не будет зависеть от, собственно, пропускных способностей.
Просто от слова «никак».
Значит, итак, смотрите.
Каранот.
Но нам нужно в этом каким-то образом убедиться.
Значит, будем начинать убеждаться.
Значит, ну, ключевое утверждение.
Так, ну, собственно, первая идея, на самом деле, заключается в том, в том, что?
Какая нота?
Что мы ищем BFS.
То есть когда мы запускаем BFS, мы ищем расстояние от S, от истока до всех остальных.
Правда?
Вот.
И что же у нас получается?
Ну, а получается следующее.
Ну, в процессе мы знаем.
Ну, мы в прошлый раз уже доказывали какое-то интересное утверждение на тему того, что если, допустим, из истока какая-то вершина недоступна, то, видимо, она не будет доступна уже никогда.
Был такой, да?
Ну, мы доказывали не совсем это.
Мы доказывали доступность из этой вершины стока.
Ну, как вы догадываетесь, там, собственно, из истока доступность из истока – это то же самое.
Ну, типа того, да.
Там практически, да.
Вот.
Вот.
Но, оказывается, это можно усилить.
Потому что, начнем просто давайте с леммы 1.
В процессе, то есть для любой вершины В, верно, что там расстояние, то есть вот так, в процессе Эдмонса Карпа, в процессе ЭК,
расстояние в остаточности, в смысле там G, там F кур, вот так я напишу,
значит, расстояние от S до V не уменьшается.
Ну да, отсюда следует и про бесконечность достиженности.
Ну, в плане того, что мы доказали в частных случаях.
Ну, в принципе, да.
То есть это, конечно, усиленная версия.
Нет, на самом деле, не совсем так.
Ну, если считать бесконечность расстоянием…
Нет, ну в этом смысле…
Мы в прошлый раз, правда, доказали для произвольного Форда Фолкерсона,
а на самом деле, верно ли, что она не уменьшается,
если мы вместо BFS-а тут DFS напишем, это будет вопрос.
Ну, я имею в виду, что…
То есть тут важнее…
Тут мы сейчас будем очень сильно пользоваться тем,
что мы пользуемся, что мы как бы ищем пути именно BFS-ом.
Ну да.
То есть если мы там ищем как-то рандомно, то, ну, так,
надо, конечно, подумать, но следует, конечно, что это неправда.
Вот.
Вот так вот.
Значит, тут держать, что расстояние не уменьшается.
Расстояние имеется в виду именно в плане…
То есть именно в плане ненасыщенных рыб.
То есть, ну, здесь, конечно, да, тут есть, конечно, вот…
Да, надо сделать формальные оговоренности,
что здесь я считаю существующими в этом расстоянии только ненасыщенные рыбы.
То есть рыбропростной способности ноль.
Там я не считаю.
Так вот.
Значит, как же это доказать?
А вот как. Смотрите.
Значит, вот ситуация.
Итак, мы сделали сколько-то там итераций.
У нас есть расстояние от S до V равное чему-то.
Что это означает?
Вот.
Значит, давайте рассмотрим одну итерацию Эдмонса Карпа.
Что?
Дист от S до V?
Да.
Ну, дистка в плане количества рёбер.
То есть невзвешенное расстояние.
Ну, то есть в частности это будет…
Ну, на самом деле да.
На самом деле да.
Вот.
Значит, смотрите.
Диспозиция следующая.
Значит, запустим DFS в текущей версии остаточной сети.
Сейчас, когда я буду рисовать рёбры, я буду подразумевать,
что они ненасыщенные.
Значит, запустим S.
Она лежит в слое BFS-а №0.
Помните, у нас в BFS-е есть слои.
Вот.
Значит, есть несколько вершиночек в слое №1.
Есть вершины в слое №2.
Вот.
И вот как-то так.
Там есть, собственно, в слое №3.
Там есть…
Ну, там всякое может быть, в общем-то.
Там есть слой №4 какой-нибудь.
Ну и так далее.
Там есть…
Давайте там.
Сколько-то, сколько-то.
И вот бабах!
Нашёлся ещё и слой, в котором находится вершина T.
Ну, в принципе, там ещё могут быть слои.
На самом деле дальше неважно.
Ну, суть более-менее та же.
Вот как-то так.
Вот.
То есть, в принципе, как могут выглядеть ребра тогда
с точки зрения этих слоёв?
Они могут вести из слоя в слой.
Они могут вести из слоя в следующий слой.
Они могут вести, в принципе, из слоя в тот же слой.
Они могут вести из слоя в сколь угодно предыдущий слой.
Но у нас никогда не может быть так, чтобы ребро шло вперёд
и перескакивало хотя бы через один слой.
Это такого не бывает.
Вот.
Вот.
И где-то у нас тут находится вершина V.
Ну, допустим, я не знаю, вот здесь.
Вот расстояние у нас сейчас до неё, ну, допустим, 5.
Ну, не принципиально.
Так вот.
Итак, значит, мы нашли какой-то...
Ну, вот и так представим себе, что мы нашли какой-то
путь до T.
Обратите внимание.
Этот путь, он, в принципе, через вершину V проходить
не обязан.
Правда?
Вот я даже рассмотрю случаи, когда он не проходит через
вершину V.
Ну, вот давайте так.
Какой путь мы возьмём?
Ну, допустим, там какой-нибудь вот такой.
Вот такой вот мы путь нашли.
Любой кратчайший путь из-за T.
Да.
Именно кратчайший путь из-за T.
Да.
То есть мы его насытили.
То есть что это означает?
Это означает, что поменялось в сети от того, что мы по
этому пути пропустили поток.
Ну, как минимум одно ребро исчезло.
Может быть и несколько.
Ну, хотя бы одно точно исчезло.
Но самое главное, что теперь железо.
Но с другой стороны, какие-то ребра появились.
Очень просто.
Появились вот эти.
Да.
От того, что мы пропустили по ребру поток, значит,
обратное ребро, если оно было насыщенным, оно перестало
быть насыщенным.
Это важно.
Да.
То есть оно могло в принципе существовать ранее.
Вот.
Но если его не существовало, то есть я гарантированно
существует.
Но для нас важно даже не это.
Для нас важно…
То есть эти ребра могли появиться.
Могли там…
То есть какие-то ребра вот из этих ребр исчезли,
а какие-то появились.
А теперь давайте думать.
Значит, как поменялось расстояние от S до V?
Я утверждаю, что давайте попробуем теперь найти
расстояние от S до V, но при этом внимание, но слои
временно оставим те же.
Вот рассмотрим просто те же слои и подумаем, как
может выглядеть путь от S до V теперь.
Он может проходить как по старым ребрам, которые…
Так и по новым.
Но осталось верно важное свойство, что каждое ребро
в этом графе увеличивает номер слоя все еще не более
чем на один.
Сейчас я возможно что-то путаю.
В этом графе уже очевидно, что не уменьшилось.
Чеба мы добавили так ребра из предыдущих слоев.
Да, вот то-то и важно, что…
В этом графе уже очевидно, что не уменьшилось.
Чеба мы добавили так ребра из предыдущих слоев.
Да, вот то-то и важно, что…
В этом графе уже очевидно, что не уменьшилось.
Чеба мы добавили так ребра из предыдущих слоев.
Да, вот то-то и важно, что…
В этом графе уже очевидно, что не уменьшилось.
Чеба мы добавили так ребра из предыдущих слоев.
Да, вот то-то и важно, что…
В этом графе уже очевидно, что не уменьшилось.
Чеба мы добавили так ребра из предыдущих слоев.
Да, вот то-то и важно, что…
В этом графе уже очевидно, что не уменьшилось.
Чеба мы добавили так ребра из предыдущих слоев.
Да, вот то-то и важно, что…
В этом графе уже очевидно, что не уменьшилось.
Чеба мы добавили так ребра из предыдущих слоев.
Да, вот то-то и важно, что…
В этом графе уже очевидно, что не уменьшилось.
Чеба мы добавили так ребра из предыдущих слоев.
Да, вот то-то и важно, что…
В этом графе уже очевидно, что не уменьшилось.
Чеба мы добавили так ребра из предыдущих слоев.
Да, вот то-то и важно, что…
here
Koen 머리
В общем то и всё.
у нас была итерация
слои мы нарисовали на момент перед этой итерацией
а потом показали, что после этой итерации
значит вершина В окажется в слое не меньше чем таком
да, крADEurry
крАтчайший путь мы выбрались он а в этот момент
тогда мы просто шли по слоям подряд
да
Хотя, на самом деле, можно подумать, а что поменялось
бы, если бы пропускали бы поток не БФС, а ДФС?
Да, то есть, обратите внимание, теоретический путь мог
проходить, скажем, вот через это ребро, и тогда появилось
бы обратное ребро, которое бы скакало вперед по слоям,
и это рассуждение не работает.
То есть, видите, вот ровно в этом месте мы вот жестко
воспользовались тем, что у нас БФС.
Ну, в принципе, это и логично, почему этот алгоритм стал
работать отдельно.
Как-то вообще, да.
Вот.
Так чего у нас это приводится?
Здорово.
Вершина не уменьшается.
Ну, самопсимый даже не… Ну, то есть, хочется, конечно,
что… Да, то есть, по крайней мере, из этого следует,
что алгоритм заведомо завершится, потому что, ну, расстояние
до вершины не уменьшается, бесконечно возрастать
они не могут.
Правда, есть маленькая оговорка.
А кто…
Оно не уменьшается.
Да.
То есть, есть проблема, что может быть там вершина,
у вершины может быть зафиксировано расстояние, и мы это будем
навеки вечно и страдать.
Ну, не страдать, но висеть.
Вот.
Но, с другой стороны, значит, дальше рассуждение звучит
так.
За этим, что у нас на каждой итерации есть хотя бы один
крестик.
Ну, крестик, что такое?
Крестик – это насыщенное ребро.
Вот.
Теперь в честь этого зеленого крестика я даже лему напишу
еще зеленым цветом.
Ой, а где ж мне ее написать-то, а?
Ну ладно, придется внизу.
Значит, лемма два.
Любое ребро, любое ребро может быть насыщенно в процессе
Данса Карпа, ну, в процессе Данса Карпа имеется в виду,
да, тут как бы, да, тут, не более, чего, пяти, десяти,
пятидесями.
Вот.
А, да, потому что в процессе, да, вот оно, вот мы знаем,
что, то есть мы, то есть идея такая, да, что мы, каждый
БФС насыщает хотя бы одно ребро.
Но с другой стороны, да, чтобы в следующий раз это
ребро, а теперь давайте подумаем, что, допустим, БФС насытил
ребро.
Что должно произойти, чтобы это ребро насытить еще
раз?
А ведь должно произойти не тривяльно, что-то не
тривяльно, потому что расстояние до этой вершины, в тот момент,
когда мы это ребро насыщали, было равно D, допустим, да,
а у этой вершины D плюс один.
Тогда чтобы насытить это ребро еще раз, нужно отменить
по нему поток.
То есть это означает, что нам придется пустить поток,
неважно насыщающий или не насыщающий, когда расстояние
здесь, ну здесь будет расстояние больше либо равно, чем D плюс
один, но здесь должно быть в этот момент расстояние
на один больше.
То есть как бы вот в этой интеллектуальной гонке,
типа убеги подальше от истока, вот эта вершина должна
обогнать эту.
То есть здесь будет как минимум D плюс два.
Но после этого эта вершина снова должна обогнать эту,
и получается D плюс два, тут получается D плюс три.
То есть получается, что к следующему насыщению окажется,
что это ребро должно у нас оказывается, то есть тут
оба расстояния должны увеличиться хотя бы на два.
И тогда отсюда автоматически следует, что ребро может
быть насыщено не более чем, ну да, модуль V пополам раз.
То есть вот такая диспозиция.
Так, ну давайте подумаем, что тогда из этих лем следует.
Но в принципе, да, на самом деле, действительно, отсюда
уже теория мы следует, то есть насколько работает
алгорита.
Почему?
Потому что отсюда, в принципе, раз каждое ребро насыщается
не более чем V пополам раз, то суммарное число насыщений
не более чем VE, даже не VE, но тут оговорка не VE пополам,
а VE.
Ну в зависимости от того, что такое VE, но заметим,
что в качестве вот этого ребра может выступить и
обратное ребро вполне себе.
Ну а симпатически понятно, это ничего не решает.
То есть понятно, что получается у нас суммарное число насыщений
будет не более чем O от VE.
Вот, но тогда насыщений будет не более чем O от VE,
алгоритм у нас работает за VE квадрат, но тогда получается,
потому что каждый BFS работает за E, то есть VE умножить
на E.
Все.
То есть можно было сказать, что алгоритм Мэнуса как
поработает за O от VE BFS, то есть если вы научитесь
сказать BFS быстрее, чем за E, то в общем-то у вас алгоритм
получится быстрее.
Ну да, маловероятно, но вдруг там вы этот кратчайший
путь, скажем так, если вы этот кратчайший путь на
каждом шаге будете искать быстрее, чем за E, то тогда
и, ну потому что бывают там, могут быть там теоретически
какие-то конкретные задачи, в которых там вы кратчайший
путь находите конкретно быстрее.
И тогда это будет, тогда вы поток найдете за VE умножить
на, сколько за сколько вы там реально ищете.
Вот.
То есть в принципе вот уже такой получается первый
алгоритм.
То есть вот алгоритм Мэнуса как поработает за VE квадрат,
ну в принципе часто его может и хватить.
Так, есть ли тут какие-то вопросы.
Так.
Так, вот, но тогда, вот, но теперь вот вытекает вопрос,
тогда как же, как бы это оптимизировать.
То есть действительно, можно действительно в тупую
искать, то есть тупо запускаем BFS заново и так далее, но
на самом деле следующая идея, которая у вас может
возникнуть.
Следующая идея, которая может возникнуть такая,
можно ли сделать как-то так, чтобы BFS опускать поменьше.
Вот, ну просто идея такая, что ж у тебя, как-то вот
мы запустили тут в принципе слои, да понятно, что после
первой итерации слои могут поменяться, но в принципе
эти слои уже неплохое приближение к реальной ситуации с точки
зрения BFS.
И вытекает вопрос, а может не убирать эти слои, а как-то
на самом деле тут еще какие-то пути поискать.
Там, собственно, еще какие-то пути, еще, то есть искать-искать-искать
до тех пор, пока вот, собственно, из расстояния от SdT на самом
деле будет тем же самым.
То есть в принципе понятно, что если у вас в результате
этого проталкивания расстояния от SdT не поменялось, то в
принципе искать пути в дальнейшем, пока оно не увеличится,
можно ровно в тех же слоях, правда?
Вот, то есть пока оно, по крайней мере, не поменяется,
то и слои искать не надо, а это в принципе нам будет
давать какую-нибудь информацию в духе, что как бы реально
можно каким-то образом использовать только ребра, которые вот
так вот идут, именно только вот из этого слоя в следующий.
То есть вот такая идея возникает и из этой идеи вырастает,
ну вот здесь вот на самом деле такое, то есть все обычно тут ссылаются на
единица, видимо, как на первого проходца, но мы будем различать алгоритм единица
и то, что мы сейчас будем называть концепция блокирующих потоков.
Вот, значит, идея такая, давайте это мы убираем.
Вот, ой, ух ты, оно все-таки, оно все-таки стирается.
Ладно, значит, смотрите, итак, значит, у нас будет понятие такое
концепция блокирующих потоков.
То есть это как метод Форда Фолкерсона, то есть сейчас мы как бы изобретем какой-то
мета алгоритм поиска потока, но это еще не алгоритм, потому что там в каком-то месте
мы не будем фиксировать, как конкретно мы что-то будем делать.
Что же у нас тут происходит?
Вот эту сеть я, да, то есть идея, ну, на самом деле, что тут нужно сказать, на самом
деле, основные два понятия в концепции блокирующих потоков это, собственно,
блокирующий поток и слоистая сеть.
Значит, что такое слоистая сеть?
Ну, давайте можем, я, пожалуй, даже напишу формальное определение, то есть,
действительно там, ну, вот, то есть давайте так, слоистая сеть, это там, допустим, сеть,
там g равно v, e, c, s, t, где для любого ребра e верно, что расстояние в этом графе g от
между вершинами s и e точка start, плюс один равно расстояние от s и e точка finish.
То есть другими словами, сеть называется слоистая, если у нее там все ребра идут из
слоев следующие, если запустить bfs, ну, или расстояние, ну, или расстояние, или оба эти
же расстояния равны плюсбесконечности. Вот. Да, ну, в принципе, да, можно, конечно,
прямо в определении слоистой сети приписать, что у нас там плюсбесконечности нету, но нет,
но не совсем так. То есть на самом деле, как мы сейчас не определяли, но мы можем так сказать,
что из любой сети можно сделать слоистую сеть, просто запустив bfs и удалив лишние ребра. Ну,
по крайней мере мысленно, то есть сейчас будет больше там, там более точно на самом деле употреблять
слово игнорировать. Ну, потому что понятно, да, то есть удалять мы же не будем там физически
просто там приходить к той же тетеньке и говорить, так вот эту трубу вот эту эту взорвать. Не, не будем.
Мы, ну, тетенька у нас как всегда, тетенька у нас ничего знать не будет, тетенька понимает,
только там запросы типа вот там сколько, сколько посылать в граммах все. Не храмах, а храмах.
Вот, ну, как бы это, вот, соответственно, вот, ну, хорошо, можно в литрах, ладно, не важно, вот,
вот, значит, вот, но это вот одно понятие, значит, идея у нас будет такая, значит,
идея будет в том, что мы запустим, будем запускать BFS, временно забывать про ребра,
которые ведут не из слоя в следующий, то есть оставим слоистую сеть, а в этой сети мы будем
искать блокирующий поток. Значит, определение такое, пусть, чего, ну, в смысле, ну, с точки
зрения этого определения, да, ну, понятно, что, ну, как бы вы помните, в определении сети есть сток,
да, просто поэтому я его написал. Значит, пусть G это сеть, а E, ну, вот, а F поток в ней, поток
в ней, так, ну, вот, тогда F блокирующий, если, ой, как бы тут аккуратно сформулировать,
много может быть формулировок, но оставляемся на следующей. Если, ну, в принципе, там одно
заперег было такое, если в сети G не существует пути, пути из S в T по ненасыщенным ребрам,
но тут, конечно, да, такое определение, конечно, введет, то есть требует уточнений. Потому что
важный момент, что, обратите внимание, я здесь написал букву G, а не G с индексом F. Что я имею
в виду? То есть я имею в виду, что нельзя улучшить поток, то есть найти какой-то увеличивающий путь,
который не предлагает отменять уже существующие потоки. Типичный пример,
то есть только классический пример такой. Смотрите, жили-были, вот я даже просто в единичной сети сейчас,
то есть типичный пример разности такой, смотрите. Вот пусть у нас есть вот такая сеть, да, ну,
и мы запустили вот такой поток. Видите, да? Тогда, вот смотрите, это типичный пример блокирующего
потока, но не максимального, то есть с леду кажется, что если пути из S в T не существуют по ненасыщенным,
значит он по терминфорда Фолкерсона максимальный. Вот тут как бы есть важная оговорка, что, то есть
мы тут говорим, что поток блокирующий, что мы замечаем так, что просто наложить поверх этого потока еще
какой-то поток мы не можем. То есть в остаточной сети, то есть как выглядит остаточная сеть, да,
остаточная сеть выглядит так, то есть там вот тоже те же единичные ребра, вот, ну, вот это ребро торчит
вот сюда, вот это вот сюда, это сюда и вот это сюда, то есть в принципе путь-то в общем-то есть,
видите, зигзак такой, да, но заменяя нот, но он предлагает по факту отменить поток по вот этому
ребру. Диск по G, ну да, то есть просто какая-то сеть, да, ну в процессе, конечно, там в качестве этой
же может быть подставлено все что угодно, вообще это определение не завязано ни на каком алгоритме,
просто рассмотримся, рассмотрим сеть, она является слоистой, если у нее верны вот такие
свойства, все, по большому счету. Вот, итак, значит вот такие два базовых, то есть две базовых идеи,
то есть у нас есть понятие блокирующий поток, то есть это такой поток, который нельзя улучшить,
ничего не отменяя, то есть как бы такой жадный, да, то есть помните мы в прошлый раз обсуждали,
что поток, как можно сказать, можно сказать жадно, просто находим путь, проталкиваем поток,
находим путь, проталкиваем поток, тогда то, что получится в конце, пока мы не додумались до того,
что да, там отмены потока поребываемой остаточной сети, тогда то, что у нас получилось, это получилось бы
как раз блокирующий поток, вот, то есть как бы, то есть ничего не отменять, что что-то, то есть хотите
улучшить, что-то отменять придется. Вот, так вот, итак, в чем заключается, значит в чем теперь
заключается концепция? Ну вот, ну теперь можно сформулировать, в чем у нас будет заключаться
концепция блокирующих потоков. Заключается она будет в следующем, то есть сама по себе концепция,
смотрите, значит концепция, значит блокирующих потоков, вот, получается следующее, значит будем
говорить, значит пока, значит while, говорим мы, есть там, так сказать, путь из S в T в остаточной сети,
ну, естественно, имеется в виду по ненасыщенным ребрам, мы будем говорить следующее,
значит я это сфагулирую так, строим остаточную сеть, запускаем BFS,
запускаем BFS, ну вот, запускаем BFS, строим, запитай, строим остаточную сеть, что я здесь имею в
виду, то есть я имею в виду, что мы время, запускаем BFS и временно игнорируем ребра,
которые не удовлетворяют этому свойству, как называется, да, Дмитрий Филиппович сошел с ума,
ну, Алексей, естественно, тоже Дмитриевич, ну, ладично, да, потому что с ума сошел. Так,
ладно, сложный прикол, не обращай внимания, ладно. Какой-то образ должен быть, что это,
как-то знаете, кстати, хороший начало условия значим, у Филиппа Дмитриевича
перевернулись мозги, и он стал Дмитрий Филиппович, ну вот, да, вот, соответственно,
у Филиппа Дмитриевича появились мозги и сын, нормально, понятно, что эти процессы где-то
связаны, да, наверное, да, это да, ладно, значит, так вот, запускаем BFS, строим слоистую сеть,
то есть временно забываем про вот эти вот расстояния, то есть про ребра, которые не удовлетворяют
этому свойству, то есть оставляем только вот эти вот, то есть вот эти вот типа, временно забываем,
и второй пункт, строим в этой сети, в этой слоистой сети, блокирующий поток,
то есть вот такая вот нехитрая штука в исходной сети, да, то есть еще раз, смотрите, что мы
делаем, мы запускаем BFS, в явном виде строим вот эти слои, ну не в смысле, конечно, вектор-верт,
но можно и вектор-векторов, но в принципе достаточно просто дисты построить, и дальше мы просто
временно будем игнорировать все ребра, которые не удовлетворяют вот этому свойству, что? Что,
дисты? Нет, смотрите, нет, алгоритм будет, что и так, мы временно забудем про ребра, не удовлетворяющие
этому свойству, да, и вот в оставшейся вот этой сети найдем какой-то блокирующий поток, вот,
сейчас давай, я бы расскажу, давайте не все одновременно, вот, значит, строим BFS, нашли в этой
слоистой сети блокирующий поток, восстановили в правах все предыдущие ребра, и запустили BFS
заново, уже с учетом там всех вот этих обратных ребр, которые появились, да, и там тех ребр,
которые тут называют палей в неравной борьбе с потоком, вот, получилось новые слои, то есть и
новая, соответственно, слоистая сеть, в этой слоистой сети мы тоже там пустили блокирующий поток,
он уже мог отменять, в принципе, старые ребра, кстати, вполне себе, и так далее, и будем так
делать до тех пор, пока от S до T вообще расстояние не бесконечность, да, то есть мы более, ну да,
но на самом деле, да, то есть вы просто запускаете BFS, если, то есть вы просто там, то есть фактически
часто в этом песне пишут while BFS, то есть BFS возвращает true, если расстояние до T оказалось
меньше бесконечности и false иначе, ну как все, да почему, это не вполне себе пересекаются, то есть
каждый новый поток на самом деле может отменить старый вполне себе, потому что, то есть, да, то
есть в слоистой сети, конечно, да, то есть мы ищем блокирующий поток, да, то есть понятно, что мы
вряд ли будем там отменять поток по каким-то ребрам, если мы его уже пустили. Сейчас, извините, мы запускаем BFS в G или в GF?
В GF. Да, давайте я тут уточню, что мы запускаем его в остаточной сети и строим слоистую сеть, вот, то есть да.
Связь в слове ненасыщенным. А потому что мы усиливаем требования к этому пути,
потому что GF, как я уже сказал еще раз, да, чтобы GF, как бы, есть два типа, два типа, на самом деле,
ненасыщенных ребер. Первый тип ребер это ребра, по которым мы пустили, ребра исходной сети,
по которым мы пустили меньше, чем могли бы, а второй тип это обратные ребра, то есть это для
отмены. Так вот, мы себе запрещаем, то есть мы говорим, поток блокирующий, если мы себе запрещаем пользоваться
отменой. То есть мы там допускаем, что там пять единиц потока в, там, называется, при восьми полосах
можно увеличить до семи единиц, но как бы запрещаем себе уменьшать их до трех. Вот так. Вот, значит,
так строим их. Итак, строим мы такие в слоистой сети вот такой блокирующий поток. Зачем-то строим?
Прошу прощения. Да, в остаточной сети по ненасыщенным ребрам, естественно. Ну, точнее,
в остаточной сети нет там потока, на самом деле, поэтому в остаточной сети есть просто ребра с
ненулевой пропускной способностью. Вот так. Да, именно. То есть вот так будет работать концепция. То
есть она, то есть, конечно, это концепция, то есть это метод, то есть это не алгоритм. Почему? Потому
что вот в этом пункте мы ничего не говорим о том, а как конкретно мы, собственно, найдем этот
блокирующий поток. Логично, да? Да. Не слышу. А этот метод, он уже позволяет оценить эту точку? Да, ну,
конечно, не позволяет, но полностью не позволяет, потому что мы не знаем, как ищем блокирующий
поток, но кое-какую информацию он уже даст. Мы можем уже сказать, там как-то ограничить сверху
количество итераций, которые мы сделаем. Нет, на самом деле никак алгоритм на высоках не является
алгоритм из этой концепции. Ну, да, но тогда у нас просто вместо последнего пункта строить блокирующий
поток будет найти путь. Ну, на самом деле, да, но разница будет в том, что мы этот путь, то есть путь
ищем чисто в слоистой сети. В общем-то, разницы никакой. Нет, в принципе, там может быть интересное
свойство, что, в общем-то, пока, скажем так, если вы хотите найти все пути длины 57, ну, если вы знаете,
что расстояние от СДТ 57, вы хотите искать пути длины 57, то вы можете один раз запустить BFS и искать,
то ли эти пути только в слоистой сети одной. То есть, да, там расстояния будут меняться, но, на самом
деле, вас-то не колышет. Ну, разве что так. Но алгоритм на высоках, по-любому, будет подразумевать,
что вы как бы BFS запускаете каждый раз заново. Нет, у нас, нет, каждый конкретный путь блокирующим
потоком не является. То есть, как бы суммарно эти пути дадут вам блокирующий поток, как только вы
выясните, что как бы в этих слоях вы и путь от СДТ не найдете. Я имею в виду, что вот просто переписав
этот алгоритм, заменив последний пункт, на найти кратчайший путь, ну, короче, найти кратчайший путь,
и вы насытитесь. Мы получаем алгоритм N на высоках? На самом деле, да. Ну, на самом, то есть,
на самом деле, да, правда, как бы, да, забавно, что получается алгоритм концепции блокирующий
потоков без использования блокирующего потока. Вот. Но у нас вытекает важная, можно даже сказать,
теорема, хотя, конечно, то есть, она не особо сложная. Так, ой, давайте-ка я это вот сейчас
быстренько все сотру. Вот, это мы стерли, это мы стерли, это мы стерли. И получать следующее,
смотрите, оказывается, значит, мистическая теорема звучит так. То есть, концепция блокирующих
потоков, то есть, точнее, в концепции блокирующих потоков выполняется не более чем в, ну, допустим,
ладно, итерацией while. В зависимости от конкретных нот, в зависимости от того, что... Не свисти!
Денег не будет, примета такая. Вот. Значит, если вы итерация нот, то есть, в зависимости от того,
что считать выполнен итерацией, можно еще даже в и-1 написать. Хотя, на самом деле, более важным
фактом даже является не эта теорема, а в том, что нот, потому что, на самом деле, из нее следует
даже более важной, то есть, она следует из более важной теоремы, которая говорит о том, что каждая
итерация в этой концепции строго увеличивает расстояние, ладно, не расстояние, а дист в
остаточной сети между s и t. Вот. То есть, блокирует строго, увеличивает, строго увеличивает. Ну,
идея, действительно, очень простая. То есть, как это доказать? Очень просто. Вот, мы построили
слоистую сеть и запустили тут какой-то блокирующий поток, да? То есть, даже не один путь нашли, а там
несколько путей нашли, то есть, тут вот я, давайте, еще тут нарисовали вот какую-то красотульчику. Нет,
сюда мы не нарисовали, нет, сюда мы не пойдем, вот мы сюда вот, то есть, вот сюда вот пошли,
может быть, еще куда мы там, вот сюда мы вот тут сходили еще, ну и так далее. И вот как-то,
допустим, мы нашли блокирующий поток конкретно в этой слоистой сети, но тогда оказывается
следующее, что может ли просто в остаточной сети находиться путь от s до t. Вполне может,
но заметим, что когда мы только в слоистой сети пропускаем такие пути, то у нас появляются только
ребра из слоев предыдущей, как и ранее, правда? Тогда получается следующее, то есть, получается,
что каждое ребро, ненасыщенное при проходе по нему, увеличивает слой не более чем на один,
и это означает, что расстояние от s до t не уменьшилось. Но при этом для того, чтобы существовал путь от s
до t прям ровно такой, нужно прям вот ровно вот столько ребр, каждый из которых идет вот сюда. Но
если бы такие ребра существовали, это означает, что у нас поток не блокирующий. Собственно,
в общем-то, и все. В общем-то, обе теории мы доказали. То есть, вот получается, что у нас
концепция, которая гарантирует нам не более чем в поисках блокирующего потока, мы на самом деле
найдем и максимальный поток. То есть, добьемся того, что у нас расстояние от s до t будет
бесконечным, даже в остаточной сети уже, во всех глубоких смыслах. Вот.
Так. Но остается только вот такой естественный вопрос. Значит, естественный вопрос. Как же
этот блокирующий поток искать? Ну, тут разные методы есть. Ну как, есть вариант совсем в тупую.
Давайте внутри этой слоистой сети запускать DFS. Да, просто запускаем тот же DFS, просто он
бегает по слоистой сети. Но по большому счету, да. Ничего нового, то есть, действительно,
ничего нового по сравнению с 11 карпом действительно не будет. Да, в данном случае, то есть, это просто
будет такая модифицированная, немножко усложненная реализация. Но, да, еще более того, помимо DFS,
мы еще и DFS зачем-то ввели. Но, оказывается, смысл в этом есть. Потому что, когда вы ищете такой,
таким DFS слоистой сети путь, то, оказывается, верно маленькое приятное свойство. Если вы запустили DFS
и выяснили, что вот, скажем, через это ребро вам дойти до t не удалось, то, оказывается, маленький
приятный факт. В процессе работы с этой слоистой сетью, пути через это ребро уже не найдется никогда.
Парни, кроме тех, что мы уже нашли. Повторите, пожалуйста. Ну, смотрите,
предположим, что мы построили слоистую сеть. И теперь в этой слоистой сети ищем пути от SDT
каким-то DFS. Но теперь идея такая. Предположим, что мы DFS пошел, ну, там он сколько-то, там один путь
нашел, два пути нашел, три пути нашел, четыре пути нашел, по всем чет пускай. Пути, кстати,
вполне могут пересекаться по вершинам и даже по ребрам. Понимаете, да? Конечно. Ну, найденные
пути, про которые мы пропускаем потоки, могут пересекаться по ребрам вполне. Потому что пропустые
способности у нас разные, помните, да? То есть, да, была бы у нас когда-нибудь единичная сеть,
тогда да. То есть, мы поддерживаем текущую веточину, сколько мы пропустили, и да. Да, да, да. Нет,
то не совсем, ну, не, ну, это как все это, в любой сети мы поддерживаем, что у нас есть пропустная
способность, а есть сколько воды по ней сейчас реально течет. Я имею ввиду прямо во время DFS.
Ну, вот. Нет, во время DFS, нет, а что во время DFS? Во время DFS мы все, что говорим, так, это ребро
ненасыщенно, ненасыщенно. Так, расстояние там номер слоя увеличивается, увеличивается. Поехали.
Ну, естественно, там понятно, что в эту вершину мы ходили, что это не ходили, значит пошли. Но при
этом один путь нашли, пропустили по нему поток, потом сняли все юзиды, запустили DFS еще раз. Да,
это будет Edmunds Carp. Вот. Нет, ну, погодите, пока мы ничего нового не придумали по сравнению с этим
Edmunds, с этим Edmunds Carp, сведенным DFS. Но у этого DFS есть маленькое приятное свойство. Предположим,
что мы там запустили DFS 179 раз или даже 2007. Вот. И на 2008 раз неожиданно обнаружили, что когда DFS
идет вот, скажем, по этому ребру, он возвращается с фолзом. То есть не нашел он там никакого пути.
Тогда утверждение такое, очевидно, что этого пути через это ребро он не найдет никогда. Логично,
да? Просто потому что заметим, что в слоистой сети у нас новых ребр не появляется. Ну, с точки
зрения слоистой сети не отменяем, да. То есть у нас как бы появляются, то есть там в общей сети у нас
конечно какие-то обратные ребра появляются. Это да. И там пропускные способности, и в остаточной сети у них
меняются. Но это не ребра слоистой сети. Поэтому получается, что слоистая сеть, как бы, то есть как бы
ребра, тока, если она насыщается, то оно только исчезло. И все.
А какие? Правильно. Ну, смотри, потому что это будет притворительное определение блокирующего
потока. Смотри, ситуация. Вот мы построили вот такую слоистую сеть. Это означает, что расстояние от
СДТ вот такое вот. Значит, мы нашли какой-то блокирующий поток. То есть добились того,
что в слоистой сети от СДТ дойти нельзя. Что? Сейчас мы, так, давайте тут как бы сейчас параллельно
обсуждаем два разных вопроса из двух частей занятия. Поэтому тут вот сейчас вот Станислав
задал вопрос отсюда. Вот. Поэтому сейчас вот мы возвращаемся к этой теории временно. Вот. Значит,
еще раз. Значит, мы нашли в этой слоистой сети блокирующий поток. Что это означает? То есть заметим,
что слоистая сеть обладает таким свойством, что даже в исходной остаточной сети есть ребра,
которые идут вот из слоя в следующий. Есть и те, которые идут из слоя в себя, есть которые идут
назад. Но перескакивающих через слой нет. Заметим, что если бы в слоистой сети пустили какой-то там
поток, то как бы ребр, которые идут из слоя куда-то вперед далеко, так и не появилось. Это означает,
что получается затут блокирующего потока не уменьшило расстояние от СДТ. Да, не уменьшилось.
Да, возникает вопрос, а почему оно не осталось тем же? Очень просто. Как может выглядеть тогда путь
от СДТ именно до там такой длины? Он может выглядеть только так, что мы тупо на каждом шаге идем из слоя
в следующий. Итак, предположим, такой путь нашелся. Но тогда возникает ощущение, что поток в слоистой
сети, так как этот путь целиком лежит в слоистой сети. И это противоречит определению блокирующего
потока. У нас же блокирующий поток, но я имею в виду следующую ситуацию. У нас есть слои 1, 2, 3, 4.
У нас есть путь 1, 2, 3. У нас есть путь с другим вершином 2, 3, 4. И есть обратное ребро из 3 в 2,
который их соединяет. Ну понятно. То есть, переводя говоря, вот такой зигзагообразный путь. И что? И что с ним?
Тогда, соответственно, так как у нас есть путь из СДТ, он не будет блокирующим в слоистой сети.
Ну в плане, у нас определение блокирующего потока, что не существует пути из СДТ по ненасыщенным
ребрам. И у нас действительно вот, у нас существует путь из СДТ, просто он идет в какой-то момент назад.
То есть у нас может существовать такой путь, но при этом не в слоистой сети.
Да. Ну конечно.
Тогда получается, что поток не будет блокирующим.
Почему? Как раз наоборот, в слоистой сети он блокирующий, потому что этого пути нет в слоистой сети.
То есть блокирующий поток, он имеет в виду блокирующий относительно вот этой слоистой сети,
а не относительно глобальной сети.
Ну в плане, мы удалили не только ребра. То есть когда мы насыщаем ребра, мы все равно не добавляем в слоистую сеть.
Да. Ну то есть в слоистой... Ну типа да. То есть мы считаем, что в слоистой сети исходно есть только вот эти ребра.
Да, мы оставили только вот такие ребра, но когда мы их насыщаем, мы обратные не добавляем.
Нет, ну как сказать, обратные ребра – это вообще понятие из остаточной сети.
Ну да.
Вот. Заметим, что концепция блокирующих потоков вообще не... То есть понятие блокирующий поток вообще не подразумевает существование понятия обратное ребро и слоистая сеть.
Фото или...
Нет, ну обратное ребро и даже остаточная сеть тоже.
То есть остаточная сеть, оно...
Вот.
То есть слоистая сеть. Да.
Соответственно, да. То есть это ребро в слоистой сети не появляется.
То есть обратное ребро это как бы напоминает. В реальной жизни обратного ребра не существует.
Ну да.
Да.
Да.
То есть парадокс в том, что как бы каждый из этих ребров в слоистой сети может быть на самом деле обратным ребром и не существовать в реальности.
Но как бы...
Но тем не менее.
То есть мы как бы на очередной итерации из того, что было, построили слоистую сеть и временно игнорием все то, что туда не попало.
Да. То есть когда блокирует, то есть когда мы говорим блокирующий поток, мы говорим, что он блокирующий именно относительно именно слоистой сети, а не чего-то.
Еще.
Вот.
Так, ну что, к этому моменту возникли ли еще какие-то вопросы?
Да нет, наверное.
Все, все понятно.
Ну вот, все понятно.
Ну, значит, возвращаемся еще к этому замечанию.
Что если мы тут ищем эти пути в слоистой сети ДФСами и неожиданно в какой-то момент выяснили, что если мы там по какому-то ребру прошли ДФСом и вернулись, не найдя пути ДТ,
тогда оказывается, что по этому пути смысла больше ходить нет.
Тогда возникает такая интересная идея.
Ну, мы же уже научились как-то игнорировать, игнорить какие-то ребра, да?
Ну, как это можно сделать?
Давайте в порядке бреда.
Допустим, мы построим рядом с этим сетью такую другую сеть, в которую включим только те ребра, которые нам надо, да?
А еще и в качестве дополнения, давайте когда мы будем, ребрыш мы, наверное, в каком-то списке смежности храним.
Так вот, давайте это будет именно список.
Ну, в том плане, то есть как что-то, из которого можно ребро просто взять и за 1 выпилить.
А я потом скажу, конечно, не нужно будет забирать вперед реально такое, писать, боже упаси, но в первом преоближении вообразить себе такое можно.
То есть идея такая, давайте будем запускать ДФС и говорить, что если он там прошел по ребру и что-то нашел, ну понятно, значит мы по нему что-то протолкнули.
А если мы прошли по ребру и ничего не нашли, то мы это ребро из сети выпиливаем, то есть мы его тоже игнорим, потому что оно нам больше не понадобится.
То есть это очень удобно, потому что каждый новый ДФС тогда получается по этому ребру ходить не будет, правда?
И вообще такой ДФС, тогда получается каждый такой ДФС будет работать за какое время?
Он будет работать О за О от количества удаленных ребер.
Получается, да?
Ну ДФС в принципе будет работать за О от что-то типа В плюс количество удаленных ребер, правда?
То есть количество просмотренных ребер, прошу прощения, да?
Да, а по большому счету это сводится к тому, что это будет количество удаленных ребер и плюс количество просмотренных, но не удаленных ребер, их будет ровно L, где L это текущее расстояние от СДТ.
Ну ДФС у вас как будет работать?
Как только он нашел путь от СДТ, он быстренько выбросился из всей рекульсии, пропихнув поток.
Ну окей.
Вот.
Ну там, да, по-хорошему надо.
То есть ладно, в худшем случае можно Плюс В написать, чтобы учитывать там какие-нибудь там пометки Юзи, хотя на самом деле в таком ДФС даже Юзит по вершинам даже не особо и нужен, как это не парадоксально.
Вот.
То есть вот такая красота.
А?
Что-что?
Это расстояние от СДТ, то есть мы должны потратить это время, чтобы по найденному пути протолкнуть реально поток.
Это те ребра, которые мы не удалили и по ним прошли.
Вот так.
То есть ДФС их тоже смотрел.
Да-да-да.
Вот такая, вот красота.
Вот.
Ну тогда, ну возникает вопрос.
Вот уже на уровне такой идеи.
Давайте подумаем.
За какую симпатику работают будет суммарно, суммарно все ДФСы, собственно, при поиске
одного такого блокирующего потока.
Ну а давайте смотреть.
Ну давайте так.
Сумма всех ДФС.
Ну поехали.
Значит О от Е, потому что каждое ребро будет удалено не более чем один раз.
Что логично, да?
Да.
И плюс получается L, то есть сколько вообще таких ДФСов вообще может быть?
Но заметим, что каждая итерация, она убивает хотя бы одно ребро по факту.
Ну потому что оно стало насыщенным.
Ну там отдельная песня, что как бы ДФС может смотреть так.
Я вижу ребро.
Оно насыщенное.
Ой, так насыщенное.
Давайте его убьем быстренько.
Ну может и так, да.
О боже, да.
Ну понятно.
Ну да, слушай, оригинальная идея.
Ну понятно, да, да, да.
Вот.
Да.
Ну соответственно ДФСов было.
Но тогда получается.
Но из этого следует, что ДФСов у нас сколько было?
ДФСов было не более чем Е.
То есть ну получается, что тоже пишем Е.
То есть удаление ребер это мало вообще.
Но как бы из содержательных операций Л, Е.
Ну и в общем случае можно это оценить как О от В, Е.
Но итерации самого.
То есть получается каждая итерация блокирующего
потока таким, входовое слово, таким методом работает
за В, Е.
А так как итерацию у нас не более чем В, то и того
мы получаем алгоритм, который работает за О от В квадрат
Е.
Вот, ура, неожиданно победили.
Повторите, пожалуйста, почему у нас такая синтотика
одного ДФСа?
Значит еще?
Нет, один, вот это?
Да.
Ну потому что, смотри, мы научились удалять ребра.
То есть мы говорим, что если ДФС прошел по ребру
и пути Т, по нему там в рекурсии не нашел, то есть вернулся
с фолтом, то мы это ребро удаляем.
А нельзя удалять вершину сразу?
Вершину нельзя, потому что из этой вершины можно
пойти по соседним ребрам.
То есть может быть там по другим ребрам.
Если вы имеете ту вершину, в которую мы по этому ребру
пошли, ну в принципе можно, но нет смысла.
Потому что такой ДФС, если там из этой вершины
пути нет, значит видимо ДФС уже ходил там по всем
ребрам и все их удалил.
Поэтому если вы в следующий раз придете в эту вершину,
вы за О от единицы из нее выброситесь.
Поэтому ничего глобального тут нет.
Вот, поэтому оказывается можно удалить, поэтому удаляем
ребра.
Видимо сейчас у нас скоро будет перерыв после того,
как мы вот обсудим вот это.
И после перерыва, видимо, мы все-таки включим экран
и немножко походим.
Ну то есть я немножко покажу, как можно удобно вообще
строить сеть.
И на самом деле, как на самом деле этот ДФС будет
запускаться.
То есть он будет очень удобно, никаких реальных
удалений и восстановлений в правах ребер там естественно
не будет.
Итак, алгоритм, ну вот, ну дальше у нас получилось,
что это работает с ZVE, это алгоритм B2E.
Так, тут вот важный момент.
Этот алгоритм называется алгоритм Диница.
Значит внимание, не Диницы, а Диница.
Именно этот?
Да.
Да, именно, то есть именно, то есть алгоритм концепции
блокирующего потока с именно таким способом нахождения
блокирующего потока, он называется алгоритм Диница.
То есть это все называется алгоритм Диница.
Вот.
Потому что Диниц, это он, такой вот, как вы уже знаете,
советский, а позже израильский ученый Ефим Диниц.
Вот, он учился с моим дедушкой на одном курсе.
О, классно.
Вот.
Так же соответственно.
Так что, пожалуйста, не называйте его Диницей.
Вот.
Может быть на соседнем, но, короче, они вместе ездили
на военные зоны.
Здорово.
Ну вот.
Ну вот.
Классно.
Вот.
Вот.
Так же соответственно.
Да.
Ну, как вы помните, да, кто-то уже вспомнит, что мы, конечно,
с этим товарищем уже сталкивались.
Да, потому что он один из четырех русских.
Очевидно, да.
Так что, ну вот, но вот у него, конечно, серьезный вклад.
Ну, потому что обычно, то есть часто, когда, ну вот,
мы это будем называть вот, то есть в принципе заметим,
что есть и другие алгоритмы, основанные на блокирующих
потоках, и более эффективные.
То есть более-то у нас в том или ином виде в курсе такие
даже будут.
Вот.
Но, да, поэтому, но часто, конечно, говорят, что давайте
запустим Диница, но вот там блокирующий поток будет
по-другому искать.
Ну так говорят, потому что, ну, потому что можно сказать,
Диниц автор этой концепции.
То есть, может, он ее, он ее так не назвал, название
мое.
Вот.
Но, как бы, вот у него такой первый алгоритм на вот
таких путях.
Вот.
Ну, в принципе, да.
То есть это еще такой самый первый алгоритм.
Вот, то есть, как видите, то есть, идей тут, в общем-то,
не сильно много.
То есть вот, то есть, придумали концепцию и говорим, что
давайте-ка вот, то есть, в общем-то, внутри этих слоев
давайте там искать пути, искать пути еще с оптимизациями
в духе, что там, как бы, ребро не сработало, значит,
давайте его удалять.
А почему?
Ну, потому что каждое ребро ты удалишь не более чем
один раз.
Ну, значит, суммарное удаление будет E.
Да?
Тогда, значит, тут получится тогда суммарно E плюс L на
количество DFS.
А сколько у нас DFS?
А DFS у нас E.
Почему?
Потому что каждый DFS убивает хотя бы одно ребро.
Ну, когда ты нашел путь от S до T, ты ж запустил по
нему поток так, чтобы хотя бы одно ребро насытилось.
Ну, вот.
Поэтому получается E.
Ну, вот отсюда и оценка такая.
Ну, оказалось, что на этом, то есть, оценки на этом
не заканчиваются.
Потому что это такая самая общая оценка, то есть самый
общий случай.
То есть, как мы, видимо, там, как мы чуть позже убедимся,
то есть, на самом деле, там оценки бывают и по мощнее
E.
На самом деле.
Вот.
Так.
Ну, а зачем мы, конечно, с того, давайте все-таки придется
немножко поговорить о том, как это чуть-чуть покодить,
но это мы сделаем после переговора.
Вот.
Так, поехали.
Ну, вот.
Именно таким образом, используя уже ранее разработанную
эксплуатуру, и мы можем реализовать функцию присваивания
на отрезки.
Да.
Да.
Да.
Ну, да.
Вот так.
Вот так, примерно, мы могли бы там завершить какое-то
из занятий в прошлом году.
Ну, вот.
Ну, мы, да, мы этого не сделали, потому что мы не стали прям
сильно подробно копать дерево отрезков, предполагаю,
что это все и так все знают.
У нас есть массив rubber, и можно на отрезке присваивать
и пропускные способности.
О боже.
Нет.
Нет, это просто код, который я писал вчера на уроке
в 57-й.
Так.
Как бы, вот вы уже и догадались, что мы там обсуждали.
Вот.
А какой?
Десятый.
А 57-й вы используете, что с 189-й?
Чего использую?
С 189-й.
О, господи.
Что-нибудь.
Нет.
Ну, как сказать?
Ну, там, ну, скажи так, я не знаю таких умных слов,
я знаю только там, что в каждом кабинете есть телевизор.
Ну, вот.
К телевизору можно подключиться, поэтому, вот, примерно таким
же образом.
Поэтому нормально.
Вот.
Значит, поехали.
Оля, боже мой, фоза.
Все.
Тоже мне.
Вот.
Пробежали.
Итак.
Что нам нужно, чтобы построить сеть?
Нам нужно ребро.
Так.
Ну, ребро, давай, ну, вот.
Ну, в ребре у нас будет.
Ну, в ребре у нас будет.
То есть, вершины.
Ну, я сейчас не буду там прописывать все шаблоны,
но типа прописывать буду.
Значит, t-vertex, там, допустим, start и finish.
А также, что у нас еще?
t-flow.
Ну, у нас будет такой еще тип t-flow, который говорит,
в каких единицах мы измеряем потоки.
Вот.
Значит, t-flow у нас будет, собственно, ну, capacity, очевидно.
И, соответственно, flow.
То есть, в принципе, такая структурка.
То есть, мы ее.
Ну, тут вот интерес.
То есть, мы, конечно, там.
То есть, ну, она такая, конечно, чисто пабликовая.
Но, впрочем, там, сильно пользователю мы ее показывать.
Ну, там часто пользователей показывать там особо не
будет.
Впрочем.
Посмотрим.
Чего-чего?
Ну, теоретически, да.
Нет, ну, как сказать, нет.
То есть, ходите, пожалуйста.
Я могу сейчас как бы шаблон написать.
Пожалуйста.
Пожалуйста.
Ой, Господи.
Да?
То есть, вы пишете на шаблонах без слова type name?
Интересно.
Класс.
Ага, класс.
Или int, но не type name.
Ну, допустим.
Ну, класс так себе, что type name чаще всего это unsigned int,
на самом деле.
Возможно.
Как бы, не могу достоверно ответить ни да ни нет.
То есть, это вас отсылаю к соседнему курсу.
Вот.
Да.
Ну, да.
Вот.
А, ну, да.
Вас, да.
Да.
Ну, конечно, так сказать, да.
Ну, да.
Этого курса у вас уже нету.
А алгоритмы есть.
Но в этом нет смысла.
Теперь поехали.
Значит, как мы будем орудовать с сетью?
Ну, сейчас попробуем все-таки немножко ООП-шности ввести.
Класс.
Network.
Ну, хочется...
Значит, что хочется от сети?
Хочется, по идее, все как-то более-менее спрятать.
То есть, чтобы...
Ну, чтобы...
Нет.
То есть, как вы помните, у нас по-хорошему нельзя.
Так что пользователи дали там какие-то три вектора
и делали с ними, что хочешь.
Нам такого нельзя, потому что у нас сеть имеет какое-то
строгое определение, которое мы должны следовать.
Но, с другой стороны, мы должны предоставлять пользователю
возможность что-то с этим делать.
Так.
Ну, давайте смотреть.
Так.
Что мы должны хранить?
Так.
Ну, значит, соответственно, t-vertex у нас соответственно...
Ну, количество вершин, видимо, у нас будет t-vertex.
Потому что, ладно, будем считать, что у нас вершины
от 0 до n-1 все-таки.
Можно вопрос?
А?
Я правильно понимаю, что вы планируете на этой паре
подписать код и на последней паре подоказывать какие-то
оценки?
Ну, как получите?
Я не знаю, будем ли вы подписать код прямо полтора часа.
А что?
Ну, я бы, например, вспомнил.
Ну, скажем так, мы еще...
Ну, формально говоря, код вызван тем, что мы еще
единица недообсудили.
Поэтому сейчас.
А так, на самом деле, от перестановки мест сложаемых
суммы не меняется.
Меняется только то, что мы тут немножко переключились.
Как бы редкость.
Так.
Ну, обычно, значит, смотрите.
Ну, вообще, да.
То есть обычно, конечно, это называют s и t, но тут вот
интересно, потому что, на самом деле, официально
английские названия это source и sink.
А n это не вершина.
N это количество вершин.
Ну, формально мы, конечно, тут должны написать что-нибудь
вот такого рода.
Ну, а сколько она должна?
Потому что мы считаем, что вершины все-таки у нас будут
от 0 до n-1, а не там какие-нибудь там, Вася, Петя, Гамма, Дельта.
Соответственно.
Да.
Чего?
Не слышу.
Ну, потому что мы в t-vertex можем подсовывать size t, можем
подсовывать unsigned int, можем подсовывать что-нибудь еще
в этом роде.
Сейчас я использую t-vertex.
Ну, вот.
То есть вот так.
Ну, тут, да, есть, конечно, такая некоторая мелочь.
Я, в принципе, t-vertex использую для того, чтобы было понятно,
где вершина, где ребро, чтобы в int не берет.
Ну, вот.
Ну, соответственно.
Значит, что у нас еще?
У нас будет список ребер.
Но при этом список смежности у нас тоже будет.
То есть на этот раз вектор size t, поправочка, вектор,
вектор size t, так сказать, граф.
Это будут немножко разные вещи.
То есть обычно мы, когда мы пишем список смежности,
обычно у нас вектор, векторов ребер происходит, правда?
Ну, там, то есть я должен был написать обычно вектор,
вектор edge, и внутри вот этой структуры edge писать
просто все, что мне, там, в моей душе заблагорассудится.
Вот.
Но при этом обратите внимание, что вектор not.
Но мы на этот раз пойдем немножко по-другому.
То есть мы будем хранить список ребер, полный список
ребер, и граф, по графу будем так берить.
Ну, вот.
А в каждой вершине мы будем хранить список, то есть вот
этот номер индексов ребер, которые торчат из нее.
Значит, чем это вызвано?
Ну, во-первых, да, так, начнем.
В сети мы будем сразу создавать t-vertex, так сказать, nst.
Так.
Что?
Вопрос какие-то уже возникает в начале?
Ну, я не знаю.
Ну, в плане, зачем нам хранить номер ребра или просто
так вот?
Ну, типа.
Ну, скажем так, сейчас увидите.
Потому что, значит, смотрите, нет, да, вот просто что
мы тут хотим?
Потому что дело, значит, идея заключает в следующем.
То есть дело в том, что у нас в данном случае сеть
это не просто граф.
Потому что дело в том, что это сеть будет одновременно
и остаточной сетью в некотором плане.
Вот так вот.
То есть такая вот идея.
Вот.
И нам, когда мы будем пускать по ребру поток, мы должны
проследить, что по обратному ребру пустили минус такой
поток.
Ну, вот для нот.
Поэтому получается, что нот.
Поэтому нам придется это как-то удобно реализовать.
Поэтому вот, например, мы создавать сеть будем следующим
образом.
То есть в конструкторе мы будем требовать, чтобы
нам задали количество вершин, а также sst.
Ну, тут можно еще какой-нибудь безопасный ассерт написать.
Там 0 меньше либо равно.
Там ns меньше, n and then 0 меньше либо равно, t меньше,
and then t меньше, n.
Да, это не питон, поэтому, боже, вас упасти писать
вот так.
Ну, вот тут вы уже взрослые люди, вам не надо рассказывать,
что это плохо.
И почему?
Ну, вы уже экзамен на эту тему сдали.
Ну, супер.
Ваня.
Да, питония нормально работает.
Вот.
И остальные ребры мы будем хотеть добавлять к ребру.
Теперь у нас будет функция добавить к ребру.
Как добавить ребро?
Да очень просто.
Ну, чтобы добавить ребро, что нам нужно указать?
t vertex start, t vertex finish и t vertex capacity.
Ну вот, ну мы будем добавлять два ребра.
Внимое и обратное.
Ну, здесь вот по-разному на самом деле.
Потому что по умолчанию, конечно, у обратного ребра
пропускная способность 0.
Вот, понимаете, да?
То есть как это будет работать?
Работать это будет вот так.
То есть вот у нас будет такой приватный метод edge,
add edge local.
Который говорит о том, что добавьте ко мне, пожалуйста,
ребро отсюда, вот сюда.
С вот такой capacity.
Вот.
Ну, значит, смотрите.
Ну, здесь идея очень простая.
Graph at start.pushback edges.size.
Вот.
Значит, и соответственно, ну,
и останется edges.pushback.
И соответственно, мы тут запускаем edge.
Значит, что нам там надо?
Вот видим, да, start.
Соответственно, finish, capacity.
И, так сказать,
ну, я так, я так, конечно, порабочий крестьянский напишу.
Вот.
Да, я понимаю, что там вам мещерин, видимо, за такое по рукам бил,
но тем не менее.
Нет.
Я вот это имею в виду.
Нет, это, ну, это, пожалуйста.
Нет.
Почему?
Почему у меня есть конструктор?
У меня есть конструктор по умолчанию,
потому что это что-то тупая структура без всяких методов.
Так что у меня, наоборот, по умолчанию тут есть все.
Нет, ну, в смысле, она по-любому сейчас даст какое-то ребро
и пихнет его сюда, куда ждет деваться.
Так, ну ладно, это, в общем-то, это на самом деле не так важно.
Ладно.
Выпишите, пишите, да.
Так, ну теперь вот вычекает вопрос.
Теперь нам, чтобы работать с этой сетью, нам что нам нужно?
Нам надо как-то желательно просматривать ребра
и желательно уметь пускать по ним,
соответственно, какой-то поток.
Как же нам это сделать?
Ну ладно, что-то у меня такое настроение,
хочется писать уже на настоящемся плюс-плюсе,
а не как это делается на этих ваших олимпиадах.
Поэтому нам, видимо, придется ввести итератор.
Классно.
Но начнем мы с простого.
Значит, смотрите.
Ну, во-первых, давайте так.
Начнем с того, что у нас есть, будет локальный метод push,
который будет говорить нам о том, в каком ребре
какой поток пустить.
Филипп Дмитриевич, а вот раньше мы писали как бы код на пофиг,
сейчас мы пишем код красивый.
Это связано с тем, что как-то эта тема
больше приближена к практике, чем остальные,
или просто на вас вдохновение напало?
Да, просто напало вдохновение.
Да, на меня напало вдохновение.
Я вспомнил, мол, вот эти, вспомнил,
былые времена, когда алгоритмы C++,
это был один и тот же курс, поэтому мне надо было,
поэтому я там что-то и про C++ рассказывал,
и про то, как хорошо кодить.
А если серьезно, насколько эта тема
на практике применена?
Ну есть, подожди, ну так же, как и все остальные,
то есть в каких-то областях она душта.
Вот так.
То есть, по идее, подробности не скажу,
но слету скажем, что как минимум в задачах
про какие-нибудь водопроводы или, скажем,
про транспортные сети, на самом деле
это счастье все нет-нет, а может и возникнуть.
Как будто трубопровода это как-то конечная вещь.
Нет, ну как сказать.
И по сантехнике такие достают новые.
Нет, техника это обычный человек,
который не решает, как конкретно вода
по всей Москве будет гонять.
Он приходит и чинит конкретную трубу.
И что? А как это связано с сантехником?
Ну вот.
Так вот, смотрите.
Так, тихо, тихо.
Тихо.
Значит, смотрите.
Значит, идея у нас будет такая.
Значит, push flow будет говорить такое.
Значит, будет такое.
Значит, дано ребро, я хочу по нему пустить поток.
Казалось бы, что для этого надо сделать?
Просто берем edges,
и мы будем пустить поток.
Просто берем edges от edge number.
Точка flow, плюс равно flow.
Но этого недостаточно.
Потому что, значит, когда мы реализуем сеть,
у нас должно быть обратное ребро.
То есть, помните, мы их комбинируем,
как бы преимущество из двух наших определений.
То есть, как бы, рядом с каждым ребром
есть какое-то обратное,
но это не матрица смежности.
Но для этого нужно найти обратное ребро.
Вот видите, мы их добавляли рядом с одним ребром,
добавляли обратное.
Потому что, оказывается,
что найти обратное ребро
теперь очень легко.
Как это сделать?
Просто оказывается,
где находится обратное ребро
к ребру номер edge number?
Да.
Оказывается, что это edge number XOR1.
Вот такой вот стандартный напарник получается.
Это, оказывается, действительно очень удобно.
Мы неслучайно добавляли ребра и минопарами.
Такая технология очень удобна.
Если вы программировали на языке Паскаль,
где никаких векторов нет,
то даже там, на самом деле,
такая технология могла работать.
Другой вопрос,
как в Паскале реализовывать нормально список смежности.
Я думаю, нет смысла сейчас это рассказывать,
но, в принципе, технология есть
и, в общем-то, не сильно убойная.
А, нет.
Это как, когда мы писем...
Мы когда оптимизируем память,
мы же пишем все в один вектор
и просто храним в начало.
Ну, да.
Ну, а, ну, если и хочется
избавиться от векторов и на статике писать,
то да.
Во-первых, быстрее работает, во-вторых...
Ну, странно.
Нет, оно реально быстрее работает,
с другой стороны, да, с другой...
А, ну нет,
то есть у вас еще и ребра там находятся
и лежат подряд,
потому что так-то скачки по памяти,
если вы их в рандомном порядке добавляли,
никто не отменял.
Ну, окей.
Хорошо, хорошо, хорошо.
Вот, ладно.
Да, вот.
Так вот, значит,
пропустить, но это пока, видите,
мы будем стараться пользоваться только им.
Ну, пользователю мы вообще
этот метод показывать не будем,
но в принципе заметим, что... Да, я же хотел сказать.
Да, вот такого способа для... Да.
То есть, заметим, что, ну, если вы там в паблике бы писали,
допустим, на олимпиаде какую-нибудь будете писать,
ну, то есть сразу скажу там,
если задача будет неревьюшной, то, в общем-то, естественно,
я вот этого вот прям требовать не буду, естественно.
Вот.
Но там, скажем, на какой-нибудь олимпиаде, если у вас есть задача
пробежать там,
посмотреть все ребра, только не в остаточной сети, а в обычной,
то вы это теперь сделаете очень легко, то есть вам нужно в этом списке, в векторе edges
пробежаться по всем ребрам с четными индексами. А если хотите просмотреть все обратные, то снесет.
Или, например, у вас будет, например, у вас такая еще подлянка, вот у вас будет первая задача в DZ,
но там будет поток в неориентированной сети. Что такое неориентированная сеть? Это когда выяснится,
что у вас трубы двусторонние, то есть вам там, то есть у вас будет сказано пропускная способность 5,
это означает, что у вас 5 может гонять как в одну сторону, так и в другую. То есть, в принципе,
самый тупой способ, конечно, сказать, что давайте скажем, что неориентированные ребро,
это такие два ориентированных. Вот. Но тогда вы в этом случае, тогда по одному такому ребру
создадите, получается, четыре ребра вот внутри сети. Но на самом деле необходимости в этом нет.
Да, чего? Ой, я что-то нажал. Да, ну плюсик, понятно, да. Ну вот, на самом деле в неориентированной
сети на самом деле разница будет только в том, что вы создадите, то есть когда вы будете
добавлять ребро, вы просто сразу добавляете ребро и добавляете к нему обратное, но с такой же
капаситей. Ну к чему это приводит? Это, кажется, приводит к тому, что вода может течь как в одну
сторону, так и в другую, и у вас это будет автоматически помечаться. А то как-то у вас
будет странно, что там немножко, что пропускная способность 5 выяснится, что в одну сторону течет
четыре единицы потока, а в другую три. Ну вот. То есть, что это такое? То есть, с точки зрения одной
и физики, логично, на самом деле просто в ту сторону будет течь там одна единица. А то как это?
А то как-то четыре-три, то это как бы то ли шизофрения, то ли коррупция опять. Ну как-то странно.
Чего, шизофрения или коррупция? Кошмар начинается. Ну физически можно, но не очень-то и нужно.
Ну как сказать, математически у всех в голове мы можем делать все что угодно, но в реальности не очень
хочется. Итак, ну как всегда, как пользователю предоставить удобный интерфейс? Ну, удобный
интерфейс представляется, естественно, каким-то мистическим итератором. Ну тут придется, ну видимо,
чтобы по-разному просматривать ребра, придется, конечно, значит, создавать разные. Ну а самый важный,
обычно мы просматриваем ребра только торчащие из одной вершины, поэтому, смотрите, сейчас будет
небольшой слом, но допустим, допустим, edge-итератор это будет у меня такой супер класс. Так, ну во-первых,
давайте, ладно, сразу я в нем пропишу еще, что у него будут друзья. Ладно, у него не будет друзей.
Ладно, у него, ладно, а вот, ну вот, нет, нет, почему, что у network будет класс итератор,
который является его внутренним классом. Это нормально, да. Там надо писать тут еще какие-то
паблики, там, приваты, вот это все. Ну, да, ну, я сейчас template, ну, что? А, ну, тогда и сеть
нужна template, на что? По этой логике. Вот, давайте тогда, ой, ну, давай, ну, все, ладно, как хотите,
пожалуйста, пожалуйста, по заявкам трудящихся, да, в разумных пределах, как бы, все шаблоны,
пожалуйста. Вот. Так, ну, вот тут придется, потому что это типа edge-итератор нет, если
итератор, тогда двух этих, хотя, а, стоп, да, да, да, а, впрочем, согласен, да. Ну, хорошо.
Нет, ну, reverse это, ой-ой-ой-ой, так, вот сейчас слом будет заключаться в том, что вот эти,
что я сейчас все эти общепринятые C++ концепции итератов просто пошлю лесом, а вместо этого,
значит, я напишу итератор, значит, а вместо этого я напишу так, чтобы этим итератором,
значит, можно было, чтобы перебирать ребра в сети, можно было примерно следующим образом.
Нет, смотрите, сейчас я просто покажу.
Смотрите, я буду писать так. А вот так. Вот, то есть на самом деле есть еще вот такие итераторы,
то есть, в принципе, если вы изучали язык джава, то сталкивались с итераторами вот, то там итератор
выглядит примерно так. Да, я не особо кодил на джаве, но, короче, мало кто помнит, но когда-то
давным-давно я работал в компании Яндекс, и в Яндексе на самом деле итераторы по логам
поиска на самом деле работают вот таким вот образом. Ну, как питоновские, ну, я не знаю,
кто первичен, как бы я их впервые увидел в джаве и в таких вещах, поэтому, да, поэтому не будем
тут сейчас копать, просто что вот у нас вот такие итераторы. Да. Нет, то смотрите, begin это как бы
он будет указывать на первое ребро, то есть valid это означает, указывает ли он еще на какое-то
ребро или он закончился. Ну вот, next. Почему есть? Ну, как бы и функция next означает, что перейди к
следующему ребру. Что не так? Ну, проверить, верно ли, ну, короче говоря, это эквалентно-то на языке
верно ли, что it не равен endo. Ну вот, ну просто у нас тут будет valid, то есть как бы мы, то есть next
это значит перейди к следующему, если следующего не существует, значит итератор в этом месте перестал
быть valid. Что, что? Не слышу. Нет, нет, почему? Подожди, подожди, подожди, давай вспоминать, как
фор устроен в C++? Он делает в эту первую команду, потом делает в проверку вторую. Да, ты более того,
цикло, то есть тело цикла может, тело цикла фора может ни разу не запуститься, если выяснится,
что после вот первой операции вторая вывернула fov. Когда у тебя перезначен по C++? Да? Ну, я не знаю,
просто давным-давно мещерами тролл, что да, у тебя там по алгоритму люди получали десятки, а потом не
могли ответить на вот подобного, там на какие-то вопросы типа, чем постфикс C++ отвечает, а префикс
снова-то вы так далее, ай-яй-яй-яй-яй-яй. Ну вот, значит, видимо теперь можно его троллить в ответ, да.
Ну да, ну нет, у меня мещерин тоже имена не называл. Так что ладно, но я правда боюсь,
если ваши голоса по камере опознают, то как бы, соответственно. Ну мало ли, что-то. Да окей, ладно,
неважно, то есть хочется вот так, но теперь высказать вопрос, что мне же хочется не просто
итератор. Ну хорошо, то есть основные методы мы поняли, да, что этот итератор говорит. Вот,
ну так, ну а первых ладно, то есть конструктор у нас будет, давайте надежный сделаем конструктор,
там так, explicit, так это важно, explicit. Ой, так интересно, а как достать тип-то Vertex из
Network? Ну ладно, ну ладно, ладно, будем. Ну прям надо, да.
Хорошо, значит, смотрите, это был Vertex, значит Vertex от V, от V и индекс от, от чего? До индекса
у меня будет от нуля, вот. Ну я это делал, потому что я подразумеваю, что я буду, то есть все,
что я тут буду делать, это запускать этот метод, то есть получать этот итератор буду только из
Begin, то есть иначе, иначе я его создавать, ну, интересно, так, ну да, ну то есть вот основное
использование, конечно, будет у меня, то есть там вот этот Edge итератор Begin от Vertex V, const,
хотя нет, неправильно его делать константным, почему? Потому что в результате этот итератор
может поменять сеть, то есть как бы если вы хотите взять итератор, который гарантирует,
что он ничего не меняется, значит вам нужно сделать итератор, по которому вы поток пускать
не будете, это будет const Edge итератор. Сейчас кто нужен? Для того, а, ну, сейчас увидите,
для чего, потому что мы же должны по этому итератору, значит, лазить в сеть и там выдавать
информацию о ребре. Сейчас вы увидите это. Зачем мы итератор вообще изобретаем? Для того,
чтобы безопасно лазить, давать пользователю лазить в сеть и что-то по нему читать,
но менять только то, что мы ему разрешим. Это, в общем-то, зачем мы это все вообще пишем,
а не как на нормальной олимпиаде. Вот, то есть понятно, что на олимпиаде мы бы там давно уже
задачу сдали, да. Вот. Да, но вопрос, как мы читаем, в режиме read или в каком режиме? Потому
что, смотрите, у итератора будет несколько методов. Так, ну, начнем с того, что метод valid,
начнем там. Там будет у него константный метод, который мы будем говорить, что он равен return
index меньше, чем... Ой, мы же должны слазить в сеть. Но ничего страшного. Значит, мы будем хранить
внутри итератора сеть. Но не просто сеть, а мою сеть. И не просто сеть, а, конечно же, ссылку на нее,
боже, естественно. А то, да, в сети храним итератор, в итераторе сеть. А что? А что не так? Нет, а что?
Нет, ну, как сказать? Сейчас, погодите. А что когда, ну, вот. А что? Нет, ну, просто, если вы swap
контейнеров, это позволяет, это ссорится просто к тому ситуации, что вы просто там сеть переприсвоили.
Внимание, вопрос. Когда вы присвоили сеть, то есть, фактически, когда вы присвоили сеть, все равно считаете,
что вы как бы стерли старую сеть, написали новую. Наверное, логично в этом месте ожидать от итератора,
что он больше не... Ну, я бы сказал так, что если, скажем так, если вы сеть стерли, ну, сформулирован
так, наверное, если ваш дом снесли и построили заново, наверное, все равно сложно считать,
что вы в нем живете, что у вас там квартира была, да, или нет. Ну, я бы сказал, что сформулирован так,
итератор нужен для того, чтобы бегать по конкретным ребрам, конкретной сети. Если вы, как бы знаете,
если вы бегали по квартирам и в этот момент дом снесли, то, наверное, вам бесполезно бегать по
квартирам дальше, правда? Если у вас было ДД, и вы храните указательную вершину, и вы вот это ДД изменили так-то,
то у вас указательная вершина должна оставаться ванильной, а итератор это, по сути, как указательная вершина ДД.
Ну, тогда я подразумеваю, что у вас это все происходит внутри одной большой структуры данных ДД,
в которой есть там висят какие-то вершины, в которых вы там куда-то там указываете и так далее.
Ну, в ДД допустим, да, но в сети я бы такое не подразумевал.
Ну, вот такое, да, лучше. Лучше не надо, ладно, короче. Ну, понятно, но тут уже ладно,
ну, подобные вещи, мне кажется, в зависимости от контекста.
Ну ладно.
Ну ладно.
У меня в соседу комиссия.
Комиссия?
Уже?
Кто прежде первой передачи был?
Ну да.
Кажется, что
Мичарин говорил, что
в октябре она будет в концерте.
А где-то там...
В концерте?
Вроде в концерте.
Типа люди, которые
попали на комиссию,
говорили, что им через месяц это делать.
А как?
Значит, смотрите.
Так, ну вот в принципе
вот эти пара операций
позволяет, по крайней мере,
по титаратору бирать.
Так, единственное только что,
нужно конечно...
Да, эту сеть
еще придется передать.
И конечно
ее тут еще и записывать.
Ой.
А нет, здесь конечно
network.
Так, ну и конечно же
в бигине придется написать
звездочка zis.
Так, нокань.
Так, нокань. Давай.
Нет, это я тут...
Это я, пардон.
Правильно вот так писать.
Ну вот.
Ну а пока это
просто сферический итератор вакууме.
То есть
все, что вы с этим итератором можете
запустить этот цикл
и понять, сколько ребер
торчит из вершины.
Чтобы это избежать,
поэтому нам придется вести...
Поэтому мы введем какие-нибудь методы.
Чтобы читать
информацию про ребро.
А.
Чего хотим?
Не-не-не, видите, мы не по списку
ребер берем, мы по графу берем.
То есть
мы, то есть как бы цель итератора
прибежаться по ребрам, торчащим из одной конкретной
вершины.
Ну, цель по крайней мере конкретно этого
итератора. Вы можете таким же образом
писать другой итератор.
Да.
Да.
Да, здесь согласен.
Так вот.
Но для этого давайте
читать. Ну, в принципе, по-хорошему
можно просто
по ребру давать всю информацию, которая дается.
Например, t vertex
давайте get
get start.
То есть стандартный такой getter.
Так.
Как бы это написать? Ну ладно, так как
мы ко всем полям там будем лазить,
то видимо имеет смысл сделать
какой-нибудь веселый метод.
Edge and percent
my edge.
А, причем их два даже.
А, иск и пастить.
Ну, помните, да, что как бы часто
бывает при подобного рода доступах
как бы да, константные методы должны
возвращать константную ссылку, а не константные
не константные.
Да.
Это, ага, правильно.
Сейчас, сейчас
все будет спокойно.
My network.graph
от vertex
индекс.
Вот, мясо, да.
О, боже, да.
Ну, да, да, да, да.
Вот это называется чем промышленное программирование
отличается от олимпиадного.
Заметьте, что мы еще ничего не сказали
про алгоритм.
Да, это мы еще только сеть пишем, да.
Где?
Где?
Ну, мы поверили, что в это шитераторе вроде шаблон
написать не надо.
Нет.
Нет.
Давайте не настолько, ладно.
Когда-то надо останавливаться.
Так вот.
Так вот. А.
Но самое главное, что мы не сказали,
в my edge тогда надо нижнее подчеркивание
писать еще, да.
В методе тоже надо писать нижнее подчеркивание.
В приват, потому что он
приватный.
А у нас было.
Так.
Да.
Ну, ладно, отвечу так.
Это
договоренность конкретного кодстайла.
Я пользуюсь вот таким.
Да, вам
банил там.
Там, знаете, там прикол
в яндексе, например,
в этом месте даже вон
кодстайл вещь такая, что
я вот люблю писать название функции вот с
такими вот буквками, да.
Да, но тут
фишка в том, что это
так пишут в яндексе.
Углей пишут маленькими буквами
через нижнее подчеркивание.
А у вас, случайно, нет табы?
Табы.
Нет,
в яндексе тоже, конечно, там надо настроить
себе среду так, чтоб таб по умолчанию
писал там 4 пробела, да.
Это безусловно.
Он вам нормально покомитить не даст,
если у вас там реальные табы стоят.
Вот.
Ну, это ладно. Итак, get start.
Ну, я сейчас, конечно, не самый оптимальный
способ пишу, но
как всегда, когда мы пишем промышленность,
мы обычно за супер-мегаэффективностью
не гонимся.
Хотя, конечно, хотелось бы.
Так.
Ну, вы можете получить, ну, начало
ребра обычно неинтересно, но вот конец ребра
уже интересно.
Что?
Да.
Ладно.
Так, теперь смотрите.
Аналогичным образом можно написать
get capacity.
Вот.
Это get capacity,
get flow.
Или, конечно же,
ну или вот мой любимый метод.
Get residual
capacity.
Что такое residual capacity?
Это остаточная пропускная способность.
Вот, кстати, да,
кстати, остаточная сеть по-английски называется
residual network.
Вот так она называется.
Ну, там
будете там читать статьи на английском языке,
будет так.
Но здесь, конечно, мы пишем тогда
ну, как бы, тут вот
два варианта, то есть по-хорошему
надо написать get capacity
минус get flow.
Вот так.
Чего?
Да.
Да.
Как говорится, ой,
ой, как хорошо, что мы не собираемся
проигрывать, да.
Вот.
Так можно просмотреть сеть.
Но единственное, что мы в этом месте
эту итературу разрешаем делать, это
пустить поток.
То есть push
flow по ребру.
Значит,
вот хотим мы пустить поток f.
И мы заявляем,
что my network
там
и вызываем, собственно,
там придется метод push
o, значит, вызвать
у вот этого вот index.
Так.
Ну, как же этот index взять?
Ну, правильно его, на самом деле, так как
мы его уже тут взяли, видите, у нас тут даже копипаста
произошла, поэтому придется, видимо,
написать так.
Значит, size
get
get
допустим так,
local index
in edge list.
И вернем
вот это вот безобразие.
Вот.
Ну а здесь после этого
тогда мы уже можем
уже наконец нормально
вместо того, чтобы писать эту градость, будем
писать вот эту
градость.
Так.
Соответственно, вот такая вот
диспозиция.
Вот такая вот диспозиция.
Вот такая вот диспозиция.
Вот.
Вот.
Вот такая вот диспозиция.
Так.
Ну и здесь
соответственно вот.
Вот.
Ладно, придется оговориться, что это запуск
потока, конечно, так сказать, небезопасный,
потому что
когда мы тут пускаем поток, мы
никаким образом не проверяем, что
что мы этот поток
можем пропустить.
При желании можем, конечно, тут написать
условно ассект
на тему того, что f
меньше get
residual.
Ну это если хочется
написать безопасно. Ну понятно, что
вы там, понятно, что
да.
Чего? А, меньше либо равно, конечно.
Да.
Вот.
Вот.
Ну можно еще, ладно, по-хорошему может
еще стоит сделать.
Вот так.
Потому что выяснилось, что мы можем
теоретически тогда, если бы я этого
не написал, то можно было бы взломать эту сеть
так, что давайте пустим там
мега отрицательный поток и все
будет, и типа с точки зрения этого
ребра все в порядке, но правда с точки зрения соседнего
будут проблемы.
Поэтому мы будем говорить, что мы
разрешаем себе пускать поток только
не отрицательный и только по вот этому
ребру.
А так при очень
очень очень очень большом
желании
можно на самом деле было бы написать
там что-нибудь типа
возьми мне обратное ребро.
Ну вот. Ну там в принципе
как-то при большом желании можно
написать те же самые методы для обратного
ребра.
То есть там backward
capacity, там backward flow
условно, там backward residual capacity
вот это вот все.
Но впрочем мы не будем
это, обычно нам этого не надо.
Так что вот так вот сетью
мы будем работать.
Такой интератор позволяет нам просматривать
сеть, но все что он нам позволяет делать
с ней это пускать поток
по какому-то ребру.
Вот. А оно еще конечно
не помешает нам пару красивых методов.
Is saturated.
То есть насыщенное
ли ребро.
Будем говорить что это
там допустим get
residual
capacity
равно равно
flow
ноль.
Вот.
Приятно?
Вот.
Вот теперь да.
Ну вот.
Значит вот теперь.
Значит это мы себе вообразили
как мы хотим этой сетью пользоваться.
Теперь пришло на время написать алгоритм.
Ну например
Диница.
Как мы его будем писать?
Вот. Но алгоритм
ну часто алгоритм нам придется конечно
писать
в эко нот. Ну как нам придется
его писать? Ну как-то видимо в определенном классе.
Вот.
То есть мы будем перейзовать
его по ссылке сеть.
Вот.
Вот также
помимо сети мы тут будем хранить у себя еще
какие-то там информацию.
Ну например расстояние те самые.
Ну вот. Ну и там можно в принципе
хранить.
Да ладно, ладно, ладно.
Значит придется хранить
там расстояние. Ну придется
еще хранить конечно там
какое-нибудь давайте свое локальное NST.
Ну чисто так для удобства.
Вот.
И также
кое-что еще понадобится, но это мы узнаем
в процессе. Просто я хочу, значит для чего
я это все делаю. То есть я
хочу чтобы у меня алгоритм работал так.
То есть во-первых у меня
так.
Так. Ну и здесь вот так.
Так. Ну вот такие тут стандартные вещи
мы пишем.
Ну вот NST я здесь даже не инициализирую.
Просто я хочу как бы загрузить
в себя сеть
и нажать кнопочку
run.
Вот.
Понятно, да?
Вот.
Значит поехали. И теперь у меня задача. Вот у меня есть сеть.
Я хочу в ней запустить алгоритм
единица.
Ну как у нас
Вот.
Так. Ну давайте смотреть.
Ну начнем. Значит поехали.
N равно
видимо network
точка
get vertices
number.
Так.
Да. Возможно я какие-то
я забуду какие-то методы реализовать.
Но там понятно это в общем не сложно.
Значит теперь поехали.
Теперь будем говорить while.
Ну теперь значит
действительно что мы делаем там?
While BFS
Так. Ну и здесь
все просто.
Вот. И тут мы
будем как-то запускать DFS.
Какая-то реализация
и там будет DFS.
Ну а первое давайте.
Нам надо как-то сделать BFS.
Так. Ну у нас будет такой приватный
естественно метод BFS.
Который будет говорить так.
DST точка assign
естественно
чего?
Там N и там ну допустим
Это я BFS пишу.
О.
Это я в BFS пишу.
Да.
Я забыл об этом написать.
Но как было давайте.
Ну пишем.
Ну давайте так.
Inf я буду помечать.
Допустим.
Ну N и буду помечать.
Очень удобно.
Значит поехали.
Так.
Так. Что нам там надо?
Так. Картинка называется
как у нас пишется DFS?
Там BFS.
У нас есть очередь.
А мы с вами в прошлом году писали BFS?
Писали.
Да редкий случай что BFS мы писали.
Да потому что.
Вот.
Так. T vertex.
Там допустим Q.
Но я могу конечно писать vertex QA.
Но это как-то вот немножко да.
Как бы информативности не добавит.
Q точка push
соответственно от S.
И конечно DST от
S равно
нулю.
Так.
Значит теперь пишем
while
значит пока они
Q точка empty.
Что мы делаем?
Значит тогда пишем T vertex.
Значит V
у меня равно Q точка
front
front
Q точка pop.
Поехали. А вот теперь
network
точка begin
от V.
Ну в смысле
ой
как соблазнительно
но
потому что
не люблю.
Нет просто я люблю в этом смысле
как бы явда
лучше чем неявная.
То есть авто это конечно классно но вот
как бы
скажем так я просто немножко
довер в этом плане.
Вот так скажем.
То есть в конце концов знаете это там
то есть все эти ауты
ну в конце концов ауты совсем в массовом проявлении вообще
появились помню даже уже может быть
не в 11 стандарте а вообще в 14
если не в 17
а теперь представьте что у меня там
ICPC карьера в 14 году закончилась.
Ну просто
пятый сезон у меня был в 14 году.
Примерно в это время появлялись всякие
итераторы.
Нет
сами по себе итераторы были
в 11 году и даже раньше.
Так что
вот вопрос были ли ауты.
Ну ладно можно пользоваться я говорю на ваше усмотрение.
Просто я люблю вот так.
Так то есть как это вот так
значит it.valid
пишем мы
it.next.
А вот теперь пришло время понять
значит перебираем.
Значит если
it.is
saturated
ой что-то у меня
так что он не знает
такого класса
так
то есть если не
если ребро не насыщено
то как всегда
пишем int там
nv равно it.getfinish
if dst
от v плюс один меньше
чем dst
от nv
то что мы делаем
ну как всегда
dst от nv равно
dst от v плюс один
q.push от nv
ora
ну и в конце return
dst
от t
равно равно
там точнее
не равно
правильно
ну вот вроде
я нод bfs
и написал
если обратите внимание
я бегаю только по ненасыщенным
ребрам и это в явном виде
написал. Видите?
вот
понятно?
хорошо
вот
это
это был bfs
сейчас будет
это был bfs
то есть bfs мы запустить можем
расстояние посчитать можем
ну теперь пришло время поговорить о том
как же мы будем писать
dfs
вот
вот алгоритм динеца подразумевал
что мы будем как-то
игнорировать плохие ребра
то есть там
допустим
игнорировать каким-то образом плохие ребра
и что-то еще с ними
что-то делать
но как конкретно нод
и если ребро стало плохим
там dfs не сработало
то его надо удалять
а потом как-то восстанавливать в правах
и это неопредельно тупая
как устроен dfs? dfs обычно
занимается тем, что перебирает
в заданном порядке все ребра
но в алгоритме
dfs обычно устроен так
что он перебирает ребра в том же
порядке, но если
ребро сработало, то есть по нему был
найден какой-то путь доте, то он
на этом и закончится
тогда получается, что удалены
dfs
и только первые несколько ребра
тогда это естественная идея
а давайте не будем удалять
ребра, а просто будем хранить
начиная с какого момента dfs должен
перебирать ребра
приводит нас это
к следующей ситуации
то есть мы заводим
еще один вектор
вектор
вот этот вот
а вы не сильно обидитесь
если я напишу
как там using пишется
в каком порядке?
это мой внутренний тип
network iterator
просто логично
у меня тут будет писать чуть-чуть покороче
и будет у меня
целый вектор этих network
итераторов
вот так это у нас будет работать
это вот
то есть итераторы такие
и теперь
dfs у меня будет работать так
я буду инициализировать эти
итераторы
и дальше
while dfs
dfs у меня будет запускаться
из стока
и с потоком равен
равным
чему
чему он должен быть равен
да нет
ладно std
limits
teflow
max
Ну да, ну просто у меня будет идея такая, я буду, значит я буду пропирать, я буду делать так, то есть я буду приходить в вершину и думать, что вот сколько я по текущему пути потока могу еще пустить, могу пустить.
Вот, понятно, да?
Вот, то есть изначально, пока я в истоке, я могу пустить просто вот плюс бесконечность.
А потом, когда я пройду, приберу веса 7, способности 7, то я понимаю, что я могу пустить не больше чем 7 единиц потока.
Вот, то есть у меня ДФС будет заниматься тем, что если он еще и трушность работает, то соответственно он будет еще чем-то там пропихивать.
Вот, значит вайл ДФС, а в общем-то больше ничего не делать и не будет.
Вот, вот так мы его будем писать.
Вот, а ну вот и все.
Осталось только написать функции Need Iterator и собственно ДФС.
Воид и Need Iterators.
Да, это снова у нас такой внутренний метод, который будет говорить, ну значит, скажет он следующее.
Ну, давайте скажем так, Iterator is clear.
То есть зачистим Iterator.
Да, вот тут без emplaceback в общем-то не обойдешься.
Вот, то есть вот так мы будем инициализировать Iterator.
То есть я не знаю, я боюсь, конечно, какие-нибудь продвинутые...
Отдельная песня, что я боюсь, конечно, что такое не скомпилиться, потому что vector обычно требует, чтобы у того, что он хранит, был конструктор по умолчанию.
Ну вот, не требует?
Точно.
Мы же можем его через emplace создавать.
Ну и то, правда, ладно.
Ну вот да, чем я, собственно, тут и занимаюсь.
А теперь пришло время DFS. То есть фишка у меня будет... То есть как будет теперь работать DFS?
Так, ну можно Bool, а можно...
Но на самом деле DFS у меня будет возвращать не Bool, а tflow.
Он будет возвращать, сколько потока я пустил из этой векшины.
Вот.
Так, DFS.
Значит, я нахожусь в векшине V и хочу и могу пустить поток F.
Абсолютно неважно.
То есть tflow может быть, например, беззнаковым даблом.
Ладно, знаковым Bool.
Да, тип, к сожалению, должен быть знаковым.
Так вот.
Итак, DFS.
Ребята смотрят, что там будет.
Да, да, да, да.
Значит, pi... Ну вот, поехали.
Значит, дальше мы будем говорить tflow ans. Он будет говорить, сколько мы пустили.
Ну пишем равно нулю, естественно.
Значит, и поехали.
Поехали.
Значит, пишем for.
Значит, да, тут я, конечно, сделаю так, как я советовал никогда не делать,
но мы сейчас воспользуемся тем, что эта функция vector заведомый,
что там BFS, DFS и vector этот заведомый не трогают.
Поэтому делать будем так.
Так, network, iterator, ссылка it.
А вот так мы сделаем, for.
Network, iterator, it равно iterators от v.
Ну просто чтобы покороче.
It.valid, it.next.
У вас там должен быть нижнеопечатливая часть.
Что?
После network, iterator, должен быть нижнеопечатливая часть.
А, чего?
Нет, it.
Почему здесь не обязательно?
А, здесь, да.
Хорошо.
Так.
Так вот идем дальше.
То есть так вот iterators, обратите внимание, видите?
То есть я не создаю новый интератор, а беру по ссылке тот, что есть.
Это позволяет мне стартовать с того момента, с которым мы остановились в прошлый раз.
Вот, понимаете, да?
Значит, ну здесь, так скажем, если это ребро насыщено, saturated, то continue.
То выбрасываемся сразу.
Ну не выбрасываемся, идем дальше.
Идем дальше.
Если оказалось, что dst от, значит, it.getstart plus 1 не равно dst от it.getfinish, то тоже continue.
В противном случае по этому вот можно вполне себе берить.
Ну дальше я напишу так.
tflow nf равно std mean между f и it.getresidualcapacity.
А, я еще совсем забыл сказать.
Надо в самом начале сразу сказать, что если v равно t, то выбрасываемся с криком f.
Вот, понятно?
Вот.
Почему рекурсивно?
А, ans пока даже не нужен.
То есть теперь говорим, если dfs, значит, от it.getfinish запитая nf, то, то что мы делаем?
То, что мы делаем?
Мы не забываем, по этому ребру мы пускаем f for nf.
Нет, то даже не nf, а в данном случае так, tflow, вот так, результат равен dfs, вот так мы напишем.
То есть сколько tfs там удалось пустить?
Сейчас, а это вот что, смотрите.
Дело в том, что у нас в алгоритме подразумевалось, что мы построим остаточную сеть.
То есть мы выкинем все ребра, которые не ведут из слоя в следующий.
Но фишка вот этой реализации заключается в том, что мы даже в явном виде не обязаны этого делать.
То есть мы просто, да, то есть как бы dst, это информация, то есть верно лишь, что это ребро из слоистой сети.
Вот, это очень важно.
Ну да, чего?
Это означает, что мы по этому ребру пускаем поток размера res.
Там, то есть не знаю, там, наверное, только, да, он называется, да, у нас не push, а push flow, вот.
Так, но если dfs так и не сработал, то риториально.
Вот так может выглядеть зенит.
Чего?
Неверсально.
Чего универсально?
Непреразборчиво.
Да.
Ну, вообще так, не совсем написали.
То есть мы не уникали.
Непреразборчиво.
Ну, давайте.
Попробуйте.
Ну, это уже, я думаю, понятно.
Да, но вообще так не совсем написали
то есть если вы хотите чтобы у вас была функция
которая там допустим взяла сеть запустила в ней поток и там вернула что-нибудь о нем
то тогда эту функцию можно завести
завести так
тфлоу
рандинец
от network
network
значит говорим создаем вот этот network этот
так да но тут template естественно
не хочу писать
если можно существует ли какие средства которые позволят не копипастить шаблон
чего а
они писать шаблон ну да
так но поехали значит создаем динец
algorithm
пишем мы algo
от network
The vertex the flow algo
algo точка ран и
после этого return return network точка
точка что
о
интересно как размер поток по английски то будет а
вот fly souls да сайс flow или там volume flow
площадь потока чего
а
черт меня интернета нет ладно но
но
ну ладно пусть сайс будет а ну можно еще конечно я знаете чуть-чуть написать ассет
network точка из коррект flow
но
же дело в том что когда вы пускаете но это так это чисто самопроверка
но тут просто видите
то есть понимаете да просто там отдельная песня заключается в том что вы же
когда вы просто пускать поток при бру вас нет гарантии что то что там течет это вообще корректный поток в принципе правда
поэтому может быть имеет смысл в сети написать вот какую-нибудь вот такую самопроверочку
но обратите внимание то есть выбрасывать если она не корректно это выбрасываться надо не в сети а здесь
вот и get flow сайс
вот но как бы понятно что ладно эти методы мы сейчас дописывать не будем думаю написать эти методы
думаю для вас труда особо не составит
или составит
вот как-то составит ли вам труда пробежаться по торчащим ребрам из вершины s и просуммировать все f к
которые там текут
думаю не составит ну и коррект flow тоже ну понятно что все что вам нужно проверить это то что верно лишь что в каждой вершине
там
суммарное то что вытек там
да суммарное то что вытекает равно нулю
да обратите внимание что если в нас что-то втекает то там будут то вытекать из нас будут минусики
что
не слышу ничего
ну вот давайте вот так что вот такая вот диспозиция
то есть вот принципе я вот подразумевается что обычно вот будет то есть это все будет запускаться вот примерно таким образом
то есть более того некоторые алгоритмы а у нас будет несколько алгоритмов потока
то есть возможно на самом деле денется это я вот просто от балды вот если у меня задачи просто написать алгоритм денется
на самом деле я конечно там возможно в каком-нибудь ревью там в домашнем задании вам потребуется ну может не потребуется пока не знаю
то есть потребуется даже усилить потому что на самом деле у денется есть две части
одна часть называется концепция блокирующих потоков а
другая часть называется как собственно поиск блокирующего потока
то есть заметьте что вот этот вот bfs он в общем-то никак отличаться
받고 ни в одном алгоритме концепцию блокирующих а ti и так не будет то есть скорее всего
вопрос будет тома вопрос будет вот в этой части как вы будете конкретно искать
поэтому там возможно у вас будет там то есть чуть позже когда-нибудь еще по коде там будет концепция блокирующих
будет класс концепции блокирующего потоков с виртуальным бетоном
которые будет в наследних Islam будет денется который будет supposed и реализовывать его так будет алгоритм там мол hit
как у Марма Хишвария, который будет использовать по-другому, и там для совсем продвинутых будет
еще Корзанов, который будет реализовываться по-третьему. Ну или там, если кто-то захочет
какой-нибудь чемпионский алгоритм реализовать, то будет еще какой-нибудь там Рао Орлен или кто-то
там еще в этом роде. Вот. Но пока же хочется заметить следующий. Так вот, сейчас по Диницу есть какие-то
вопросы. Вот. Значит, смотрите. Но на самом деле, прежде чем мы пойдем на перерыв, я вот про алгоритм
Диница должен сказать еще одну маленькую вещь. Смотрите. То есть на самом деле, почему я тут вот
переменную ans писал? На самом деле алгоритм Диница есть улучшенная реализация. То есть вот это я
вот просто рассказал вам, как я вот писал теоретически, так я вот и написал. Но на самом
деле блокирующий поток можно пускать более продвинутым образом. Вот смотрите. Вот мы говорим,
что если мы там по ребру дошли до Т, все, ура, давайте пускать. Но на самом деле в этом необходимости
нет. То есть фишка тут другом. Вот. То есть на самом деле идея может заключаться в следующем. То есть
просто идея такая, что допустим, вы пришли в вершину и могли пустить из нее h, но f единиц
потока. Да? Но выяснилось, что когда вы пошли, то есть там h там 179 единиц потока. А потом пришли,
выяснилось, что рекурсия смогла пустить только 57. Но при этом тогда мы начинаем думать, а почему
бы нам не попробовать еще раз? Просто с этого же места. То есть все равно следующий ДФС до этой
вершины дойдет и едва ли не стажи только уже там 122 единицы потока оставит, правда? Вот. Поэтому
возникает, поэтому на самом деле, конечно, улучшенный единиц будет выглядеть так. То есть мы тут будем
возвращать ans. Вот. И в любом случае там. И говорить следующее. То есть у меня говорит так. Вот,
меня запустили nf. Так вот. Ну nf это ладно. Это мы значит сколько мы тут могли запустить. И вот это
вот собственно res. И там быстренько пишем ans плюс равно res, f минус равно res. В любом случае. Да? То
есть это типа сколько нам еще пустить осталось. Вот. Значит после этого теперь надо подумать,
когда мы понимаем, что у нас все закончилось. Вот. Ну будем говорить так. Значит оказывается
следующее. То есть если f закончился, то есть если больше нам пускать нечего, то придется прямо
сейчас вернуть ans. Не дожидаясь того, как у нас ans. То есть не дожидаясь того, как у нас
итератор переключится на следующий. Понятно, да? Но это если ноль. Вот. То есть это будет
предназначать следующее. Что мы сейчас прошли, мы сейчас как бы находимся в рекурсии на каком-то
пути. По этому пути можно протолкнуть там, как мы знаем, f единиц потока. Ну теоретически. И наша
задача из этих f теперь протолкнуть как можно больше. Обратите внимание. И поэтому я говорю,
что я попытался по либу протолкнуть вот сколько смог. Но теперь получается, что я могу протолкнуть
не более чем, соответственно, nf. Понимаете, да? Вот. Не более чем nf. То есть теперь у меня задача
такая. Ну вот. Но теперь у меня утверждение такое, что мне хочется утверждать, что теперь давайте
думать, в каком случае мне по этому ребру dfs придется идти еще раз. Но тогда я утверждаю,
что только в случае, если оказывается, что пропускная способность этого ребра, она больше
чем f. То есть мы просто можем по этому ребру еще что-то протолкнуть, но только если придем по
другому пути со свежим потоком. Понимаете, да? Собственно, ровно поэтому мы и говорим,
что f равно 0 значит return. Давайте сделаем. Ну это уже оптимизация. Ну вот. Можно так написать,
можно так и можно их не писать. Ну то есть конечно, чтобы лишних действий не делать. Потому что в принципе
пустить по ребру 0 единиц потока, а это святое дело. Так что не важно. Да. Ну да. Вот. Так что вот
получается такая красота. Оптимизация заключается вот в чем. Сейчас я вам это все попробую на доске
тут нарисовать. Значит смотрите. То есть работать оптимизация будет так. Допустим у вас вот сеть
выглядит вот следующим образом. То есть допустим 10, 10, 15, там 10. И тут куча вот этих вот штучек по
одному. Тогда стандартный единиц предлагает следующее. Первый DFS пройдет вот по этому пути,
пропустит 1 единиц потока. Потом пройдет по этому пути и вызовет 1 единиц потока. Потом пройдет по
этой и вызовет 1 единиц потока. И так далее, и так далее. Вот. Понятно? Вот. То есть проблема будет в том,
что он каждую единиц потока будет проталкивать за проход вот здесь. Что хочет сделать наш улучшенный
единиц? Он будет делать так. Он будет делать так. Он значит дойдет до сюда и скажет так, отлично, я из
этой вершины хочу пустить 10 единиц потока. И говорит, так, запускаем DFS через вот это ребро.
И возвращает что, ой, а я оказывается могу вернуть целую 1 единицу потока. И он говорит,
окей, осталось 9. Так. Хорошо, идем дальше. Так. Значит, теперь идем по этому ребру. Получилось
еще 1 единица потока. Отлично. Вычитаем, осталось 8. Потом 7, 6, 5. То есть он получается,
вот эти 5 прям не выходя из этой вершины пропихнет. То есть это не дает, само по себе это не дает
официальная оптимизация. То есть там нет гарантии, что в квадрате куда-то денется, конечно,
но достаточно часто это работает. То есть более того у Купилевича почему-то есть мистическая
задача, типа найдите поток, в который обычный единиц валится, а эта реализация мистическим
образом превращает безнадежный ТЛ в какой-то очень-очень-очень там уверенный окей. Ну да,
но там вот я не знаю, то есть почему-то, то есть я не знаю, то ли у Купилевича нет тестов,
которые валят конкретно там денется вот с этим, то ли. Ну то есть я не знаю, честно говоря,
у меня нет доказательства того, что этот алгоритм работает низовый квадрат Е. То есть вот эта
вот оптимизация может давать что-то лучше хоть где-нибудь. Вот. Ну вот, вообще суть такая. Так
что вот есть такая вот красивая оптимизация. Вот. Ну здесь, конечно, да, возможно, то есть
действительно по-хорошему надо либо очень аккуратно доказать, что мы здесь ничего не
пропустили, да. Ну вот, либо, может быть, для надежности еще какие-нибудь проверки написать,
или на самом деле, то есть разные варианты. Есть вариант, что в форике вот itnext здесь не писать,
а next писать вот только, только здесь писать next, когда прям надо. То есть вот здесь писать,
здесь и так далее. Ну, можно так. Но на самом деле, но я, вот, но я, вот, вот, вот, вот, вот,
хочется утверждать, что такое фор работает. Да, давайте прежде чем уйти на перерыв,
проверим меня на вшивость. Значит, давайте проверять. Ну вот, то есть, ну вот, давайте
проверять. Итак, значит, мы пришли в вершину с каким-то потоком и хотим его пихнуть. Как может
ли быть такое, что мы проскочили, то есть фор как бы пошел дальше, итератор как бы выполнил next,
а через это, ну вот, а это ребро еще не насыщено. То есть это ребро еще не насыщено, и через него
еще можно что-то пустить. Вот давайте думать. Как такое теоретически может быть? Так, ну поехали.
Ну давайте, ну какие у нас бывают случаи? Если f меньше, чем вот эта пропускная способность,
то да, мы пропустили, ну вот, то тогда получилось, что значит мы пустили поток через эту вершину,
и у нас два варианта. И у нас два варианта. Либо мы пустили весь этот f, и в этом случае мы
выбросились прямо здесь, и итератор не пронекстался, да? Либо f оказался не равен нулю, и это означает,
по крайней мере, по предположению индукции, что мы действительно через это ребро пропустили
весь поток, который могли. Ну вот, и он оказался меньше f, а раз он оказался, то есть мы могли
пропустить больше, но не пропустили, это означает, что больше не получится. Вот, поэтому получается,
если f меньше этой остаточной пропускной способности, то мы сделали все, что могли.
Так, что же дальше? Второй случай, когда, наоборот, f больше либо равен, чем вот эта остаточная
пропускная способность. Что тогда могло произойти? Тогда мы пропустили сколько-то потока, но тогда
мы, получается, пропустили поток по максимуму, то есть тогда мы запускали DFS от остаточной
пропускной способности этого ребра. И тогда два варианта. Либо мы пропустили весь nf, и это ребро
насыщенное, и мы его все равно должны выкинуть. Либо мы его ненасытили, но тогда это означает,
что через это ребро просто нельзя протолкнуть больше, чем мы смогли. Следовательно, то есть
тогда, получается, в любом случае итератор может спокойно next-иться и не париться. Вот такое у
меня доказательство. Вот. Может на экзамене выясниться, что я вас обманул? Как всегда. А может и нет.
Ну скажем так, если я в это поверю, то да. Если нет, то нет. Ну как всегда. То есть тут вопрос,
помирили я ваш обман. В свой? Ну что такое свой? Как вы это, в свои обманы двухмесячной давности я
могу уже не поверить, потому что я уже пойму, что это обман. Ну типа. Вот. Ладненько. Так, ну что ж,
думаю, пришло время как раз перерывчика. Может быть, потому что дальше там, то есть дальше,
по крайней мере, то есть описывается такая история. Потому что, да, вот Динец действительно придумал
вот такое счастье. Вот. А потом, но потом на какой-то там, видимо, на какой-то там конференции
собственно Академии наук СССР, значит появился, называется некий ученый с фамилией Корзаров. Вот.
Он соответственно там что-то вышел к доске, значит, помахал руками и сказал, что на самом деле
блокирующий поток упихивается за В квадрат. Каким-то мистическим, ну не то чтобы помахал руками,
то есть как бы все вроде поняли, проникли, сказали да, ура, у нас впервые в жизни появился алгоритм,
который ищет поток за В квадрат. Ура. Ну В квадрат плюс Ве, формально говоря, но понятно,
когда кратные ребра, мы уже неоднократно обсуждали, понятно, что за О от Е на самом деле
ликвидируется легко. Вот. Поэтому получается, поэтому как бы без ограничений обществе можно считать,
что кратных ребер в сети нет. Вот. Но правда, к сожалению, конкретной статьи как заново на эту
тему нет. Все, что на эту тему есть, это почему-то примерно описание того, что было на этих докладах,
причем почему-то подался в том Тарьяна. Я сильно сомневаюсь, что Тарьян в это время, конечно,
присутствовал в аудитории, но каким-то образом то ли ему через третьи руки передали, то ли,
может он там все-таки был, мало ли, может международная конференция была, мало ли,
я не знаю, и он мистическим образом посетил СССР. Нет, ну то есть это отдельная песня,
потому что как вы уже догадываетесь, тут происходит так, что тоже так, то есть эта
теория развивалась параллельно по обе стороны Железного Занавеса, получается, да, немножко.
Потому что вот форкфоркс, то есть он с одной стороны, но Динец вроде в этом месте был с другой стороны.
Вот. Ну там очень веселая песня, но вот, но соответственно такое. То есть поэтому получается
с зановым такая проблема. То есть с одной стороны алгоритм какой-то мутный, с другой стороны не
душе опубликованный. Вот. Поэтому с третьей стороны, поэтому есть там более простой вариант. Есть статья
Малхотра Кумара Махишвари. Это три индийские фамилии. Значит Малхотра Кумар Махишвари.
Вот. Значит у них статья на две странички. Ну вот такие два листа, значит две страницы А4,
в каждой написаны две колонки. Ну в которой полторы из них на самом деле это там стандартные для
статей такие несодержательные вещи вида. Ну там вида обзор, что вот есть задача потоков, там была
там введена на тогда-то там теориям, и вот у нас есть такие продвижения. Вот Динец ввел
такой, там ввел блокирующий метод блокирующих потоков. Вот. То есть потом там был Корзанов,
там бла-бла-бла-бла-бла-бла-бла. Но это примерно почти на странице. Ну еще там там приличная часть
колонки, еще там потом ссылки на литературу. А полстранички при этом описание того, что вот у
нас есть на нас этот более простой, называется метод, как пихать поток закуп. И они его описывают.
Вот. Нет. Я сейчас не хочу рассказывать, что они там написали. Ну правда, тем более что статью,
в общем-то, достаточно легко найти в Google. Там просто Google. То есть по-моему эти статья даже
там не особо секретные. То есть вам там даже не надо ни в какие там эти скайхабы лазить, чтобы
ее достать. Соответственно. Вот. Но тем не менее, ну вот так вот. Там если просто вбросить идеи,
то в общем-то там додумывается. То есть оказывается не сильно сложно. Вот. То есть тут вот такие приколы
были. Вот. Так. Ну это такое может быть отчасти лирическое отступление, отчасти и так из истории,
из истории решения этой задачи. Вот. То есть там понятно, что там код, конечно, получается сильно
более радостной особенностью его адекватно писать. Вот. Но тем не менее. Ну как сказать,
если писать по олимпиадному, будет проще, конечно. То есть если там нервнушаться копипастой,
там нервнушаться пабликами и так далее, то конечно все будет просто. Вот. То-то будет попроще.
То есть тоже, конечно, не самый простой DFS. То есть вместо этого там побольше кода придется писать,
но зато работать будет за желе, за бетонный куб. Ну честно скажу, у нас курсия, видимо,
даже в следующий раз будет более простой по написанию метод, как пихать потоки за куб.
Ну даже не пихать, а просто они будут не пихаться, а уверенно работать. То есть, знаете,
нет, просто пихать это как-то, да, это, ну да, то есть это спрашивается, да, как вот у Акунина,
знаете, вот там была такая, там была концепция, как, скажем, как изжить коррупцию в отдельном
взятом городе. Маленьком, каком-нибудь там, локальном, как минимум в городе ужать. Ну,
помимо всего прочего там описывалось то, что ну какая основная проблема? Почему у нас все
всех… почему у нас такая коррупция, все все боятся? Ну да, что, ну как минимум потому,
что там люди shoe не могут нормально заплатить налоги, правда там под겠어? Почему они не могут
нормально заплатить налоги? Потому что там ну, по крайней мере, на момент 19 века налогов
там таких черт ногу сломит, там там собственно ничего не понятно поэтому, поэтому в результате
единственным, просто даже не легче, а просто единственным нормальным способом получается
прийти к нужным людям так называемым вот нужным людям и как бы и заплатить им соответствующую
таксу и собственно все работает но только минус заключается в том что как бы все вас тогда
не какая то есть там то есть вас тогда никакая полиция не защищает в случае чего вы сами
собственно гребете и в результате вас эти нужные люди контролируют но там в общем показывает как
и как порешать эту проблему туда потому что там как порешать проблему ну просто потребовать давайте
просто каждый человек просто платит там называется просто фиксированный налог там предлагалось 10
процентов почему именно 10 ну потому что там вот эти церковь тестировали не никакими там
пуганьями никаких там смертных грехов и там супер какого-то бесконечного ада вот больше
десятой части вы его народа не возьмете вот понимаете вот больше десяти мы вот не получится
да вот да но вот но просто вот но там вот действительно фишка такая что как бы вы
говорите что всех ваших доходов вы часто платите 10 но но как бы после этого вы прям жестко
там то есть тогда просто тогда ваша спина автоматически вып preset уже там
действительно там от полиция укода уже начинает и защиты требовать вот соответственно ну там
а heading notice ну там отдельные песня как сделать так что намчу полиция честная было но там все
там этой ссыклышу там но там как бы задача то есть по принципе угниет с головы но и выздоровливать
с головы по этому как бы вот дорогой губернаторе сего бы хотите так explode но на часы три тогда
вот или помощника в себе набирайте по принципу смотри вот мы тут с тобой сидим не для того чтобы
карманы напить, заработать, дашь, и деньги там куда-то в офшоры, чтобы дело сделать. И пусть они
там тоже себе поэтому, тоже по этой же логике людей набирают. Ну и там вот как-то вот постепенно
по нот, то есть постепенно такое пошло. В результате оказалось, что нужные люди по этой логике сами
перевелись, просто в них нет необходимости, они там действительно кто слинял из области, кто там
просто начал, условно там, легальный бизнес просто открыл, собственно, нормальный и все. Ну вот и
собственно уже там все нормально. Так чему я это вообще все вспомнил? Так, коррупция очевидна.
Налейте поток денег, который влечет из 222. Чего? Налейте поток денег, который влечет из 222. Нет,
ну нет, это нет. Чему-то там это уцепилось, да ладно. Ну ладно, неважно, просто в общем,
ладно, в этом смысле рекомендую, собственно, окунина почитать, то есть там про это сложно
сказать, насколько это применимо к реальной жизни, но как-то вот очень интересно на самом деле.
Ой, ну это там что-то серия книг «Пелагия и белый бульдог». Ну там был именно белый бульдог,
там просто про Пелагию несколько детективов есть, но вот, по-моему, именно в белом бульдоге
описывается там в том числе это, но там везде это вот очень рекомендую. Вот, значит, соответственно,
значит, так, ну вот, значит, соответственно, так, ладно, тогда, значит, мы тут дообсуждали,
тогда вот эта диньца там реализации прочую радость, поэтому, пожалуй, сделаем так. Я,
пожалуй, выключу тогда эту штуку. Ой, нет, ну я вам в смысле недоступна, нет, ну я могу
и презентацию показать, конечно, но как бы, но как всегда, это презентация, я говорю, то есть я могу
показать презентацию, но просто это будет более быстрый темп, как показывает практика этого,
не нужно. Вот, то есть как бы лучше, как бы лучше меньше, но понятнее, как бы, чем вот, потому что,
в принципе, вот так, вот, но на самом деле это преимущество, конечно, и диньцев частостей
концепции блокирующих потоков, все заключается в том, что вот, несмотря, что ассинтотика
v2e это общая оценка, то есть гарантируется в любом случае будет v2e, но оказывается,
что во многих конкретных случаях на самом деле алгоритм диньца работает быстрее.
Вот, но для разминочки мы, для разминочки вот мышления в этом направлении мы поговорим
о единичных сетях, ведь, кстати, очень часто действительно нам для задач нужно построить сеть,
в которой все пропусковые способности равны единице, это называется единичная сеть.
Спрашивается, что да, но пока я тут сейчас стираю и пишу там слова единичная сеть,
вот возникает вопрос, чем она вот так отличается? Она отличается, как минимум, тем, что каждое
ребро либо насыщенно, либо нулевое, правда? И более того, то есть можно считать, что когда
выпустили поток по какому-то ребру, получается, что ребро типа исчезло, а обратное появилось,
строго так и никак иначе. Логично, да? Ну, теперь вот давайте подумаем, первая вот такая задача,
значит вот пишем, значит единичные сети. А теперь возникает такой естественный вопрос,
давайте подумаем, за какую симптомику работает алгоритм диньца в единичной сети?
Казалось бы, можно сказать в квадрате, и это будет правдой. Но, да, вопрос, поэтому стоит учесть
вопрос, можно ли оценить как-то точнее? Оказывается, можно, потому что первая идея какая? Ну,
как бы у алгоритма диньца есть две части, часть, которая идет из концепции блокирующих потоков,
и часть, которая ищет блокирующий поток. Можно ли оценить блокирующий поиск, сам поиск
блокирующего потока лучше, чем за ВЕ? Наверно, и даже не наверно, а просто это правда. Причина
очень проста, ведь дело в том, что смотрите, откуда у нас брался ВЕ? Вот именно ВЕ, потому что ведь
удаляемые ребра, то есть суммарно ребра удаляются за от Е, правда? А ВЕ у нас бралось откуда? Бралось
из-за того, что мы еще проталкиваем по пути какой-то поток, но убиваем при этом не все ребра, а может
быть только одно из них. Понимаете, да? Оттуда бралось ВЕ. Но в единичной сети мы замечаем более
крутую вещь. Да, в единичной сети, когда вы проталкиваете по одному потоку, вы убиваете все ребра.
Ну, смотри, предположим, что у тебя очередной ДФС, значит, этого 1, нашел путь от С до Т,
но все они пропустили способности один. Тогда, когда ты пропустил по нему поток, ты убил все ребра.
Вот не одно какое-то, а все. Все на пути? Все на пути. А, ну тогда да. Вот. То есть,
тогда отсюда получается, что алгоритм Динница ищет блокирующий поток за не за ВЕ, а на этот раз
просто за от Е. Внезапно, да? То есть, получается, что в принципе уже можно сказать, что алгоритм Динница
в единичных сетях уже сам по себе работает за ВЕ. Вот. Ну, отсюда следующий по рассочетанию ищется за ВЕ.
Даже если запускать алгоритм Динница. Но это еще не единственное место, где можно упихать оценку.
А теперь возникает такой вопрос. А сколько итераций вот концепции блокирующих потоков будет сделано?
Да, казалось бы, мы знаем, что В. Но есть наша первая мистическая теремма. В нод при поиске
потока с помощью КБП. Я даже не на Динница буду ссылаться. Она просто на любой алгоритм,
который работает с концепцией блокирующих потоков. В единичной сети будет выполнена,
выполнена не более чем от корни из Е, итерация. Чего? Нет, именно итерация. Я имею ввиду,
что цикловайл. Это больше психологически, конечно, я так пишу. Понятно, что формально
могу написать будет выполнена от корни из Е итерации. Формально бы я написал не более чем два корни
из Е итерации, на самом деле, я бы хотел сказать. Просто не хотелось пока палить. Нет, я, в принципе,
один из вариантов рассказа, я в этом месте вообще не палю ответ, а применяю нод, а применяю вот тут
стандартную логику. Значит, поэтому сейчас внимание, стандартная логика. Значит, логика заключается так,
такая, смотрите. Итак, представим себе единичную сеть. Представим себе, что мы выполнили К. итерации.
Вот, выполнили К. итерации 1. Тогда давайте вообразим себе остаточную сеть. Вот, можем себе
вообразить там остаточную сеть. Что мы можем сказать про остаточную сеть после К. итерации 1?
Да, но в данном случае даже проще. Расстояние от С до Т не меньше К. Я бы сказал, даже больше
К, но нам достаточно будет не меньше. А теперь представьте себе. А теперь представьте себе,
как выглядит, как выглядит вообще поток, вот как будет максимально, то есть нам нужно найти в
этой остаточной сети максимальный поток, правда? Ну, потому что в принципе можно сразу сказать,
что на самом деле асимптотика алгоритма не будет превосходить Z умножить на K плюс оставшийся
вот этот вот поток. Потому что заметим, что каждая итерация алгоритма 1, хоть одну единицу потока,
то протолкнет, правда? Правда? А теперь возникает вопрос. Ну вот, ну количество итерации получается
не превосходит размера максимального потока вот в этой вот остаточной сети после K. итерации,
да? А теперь давайте представим, как может выглядеть этот поток. Теперь заметим, что этот поток можно
декомпозировать. Да, то есть это вот мы забыли упомянуть, но давайте немножко отвлечемся. На самом
деле даже не в единичной сети, а в преувольной сети вот есть такая теория, что поток можно
декомпозировать на пути и циклы. Ну, потому что если у вас там из SFT течет поток размера 57,
какого-нибудь, да, то можно на самом деле этот поток, то есть конкретные вот эти эвки декомпозировать
на конкретные пути, по каждому из которых течет сколько-то потока и суммарно течет 57,
и плюс еще там какие-то циклы. Пути могут, ну в единичных сетях нет, но в обычных они могут
пересекаться по ребрам, потому что главное, ну главное, чтобы суммарно как бы эти пути ввезли
не больше пропускной способности. Как доказывать? Ну вот, а элементарно. Итак, вот пусть у нас есть
сеть, в которой течет поток размера какого-нибудь F. Так, но если этот F больше нуля, то, наверное,
из вершины S вытекает хоть по одному ребру какая-то вода, правда? Да вот, из S. Ну, а смотрите,
мы пришли вот в эту вершину. Так, ну раз в эту вершину втекает F сколько-то единиц потока,
то, наверное, найдется ребро, называется, по которому хоть сколько-то вытекает, правда? Мы же
помним, у нас в потоке сколько втекает, сколько вытекает, да? Это нет, для любых. Мы здесь пока
пользуемся только тем, что все F-ки тут больше нуля. Ну вот, и тогда, значит, повторяя эту операцию,
у нас существует два варианта. Либо мы таким образом дойдем до вершины T, тогда что мы сделаем?
Тогда мы вот рассмотрим все вот эти F-ки, выберем из них минимум и объявим, что у нас есть, то есть
вот этот минимум пусть будет там, допустим, F-мин какой-нибудь, да? Тогда у нас оказывается,
что мы нашли путь, по которому течет F-мин единиц потока. F-мин может быть и не целочисленным.
Чего не получится? Нет, сейчас, нет, нет, смотри. Нет, мы выделили, но и как бы вычли эти F-мины,
и тогда получается, что хотя бы по одному ребру поток пропал. Вот. Вот, а это второй случай,
потому что это могло дойти до вершины T вот таким жадным образом, потому что мы типа нашли первое
попавшееся ребро, идем. А второй случай, совершенно верно, мог возникнуть, что мы тут шли, шли, шли,
и вместо того, чтобы прийти в вершину T, неожиданно зациклились. Чего? Так, я забыл сказать,
договариваюсь, мы временно забыли о блокирующих потоках и доказываем общую теорию о том о
декомпозиции потока, которая никак не связана с какими-то блокирующими потоками. Так что мы ни
по каким слоям мы не идем. Ну, то есть так, блокирующий поток в слоистой сети можно
декомпозировать на пути, но в общем случае поток декомпозируется на циклы, на пути и циклы. Да,
потому что если произошел зацикл, то вы просто вычленяете вот этот цикл, что говорит, что по
этому циклу течет вот какая-то еще вот F-, ну другая уже, и вычленяете так, чтобы тоже по одному из
этих ребер поток пропал. Чего? Нет, в смысле, допустим, вот выяснилось, что мы тут шли по ребрам,
по которым течет хоть что-то, и неожиданно шли за цикл. Это означает, что мы можем сказать,
что, допустим, вот рассмотрим минимум F по этому циклу и выяснилось, что он равен 3, допустим.
Тогда можно сказать следующее, что давайте по этому циклу течет 3 единицы потока. Ну,
то есть там течет еще больше, но они там куда-то деваются, а эти 3 единицы по сути вот циркулируют.
Тогда мы говорим, что у нас есть вот этот цикл, по нему течет 3 единицы потока, и все F-ки здесь
уменьшаем на 3. В смысле? А нам по барабану пересекается или нет? Более того, почти
наверное, с кем-нибудь он пересекается. Чего? Сейчас, ну дойдем. Нет, на самом деле,
дойдет, ну там по ситуации. Просто смотрите, я просто как алгоритм работаю, что мы тут шли из
S жадно и наткнулись либо на путь, либо на цикл. Но заметим, что через, ну вот, то есть через не
более чем E итерации получается, что у нас S закончит, что из S-а уже будет вытекать 0 единиц
потока, правда? Вот, понимаете, да? Но как мы помним, но как мы помним, 0 единиц потока это не
значит, что вода нигде не течет, правда? Но предположим, что поток стал величиной 0, но у нас выяснилось,
что есть какое-то ребро, по которому что-то течет. Ну так ничего страшного, раз вот сюда что-то
втекает, значит отсюда что-то вытекает. Раз сюда что-то втекает, значит отсюда что-то вытекает и
так далее. В общем, заметим, если мы наткнемся, скажем, на вершину T, то так как поток размера 0,
у нас то получается, что раз в T что-то втекает, значит из T что-то вытекает, правда? И с S тоже
тут где-то. Поэтому идем, идем, идем, и получается рано или поздно на зацикл наткнемся. Поэтому там
оставшийся поток величины 0 мы декомпозируем уже чисто на циклы. Отсюда следует вот важная
серия, что любой поток можно декомпозировать на 0.
Здесь уменьшает размер потока, вычитание потока по циклу не меняет величину потока.
Вот, это общая теория о том, что пути, что потоки можно декомпозировать на пути и циклы. Понятно?
Вот, а теперь как это все выглядит в единичной сети? В единичной сети поток тоже можно декомпозировать,
но у этой декомпозиции потока будут важные свойства. Свойства будут заключаться в том,
что пути, ну понятно циклы можно просто выкинуть, потому что максимальность потока от этого не
поменяется. Но с другой стороны заметим, что пути этого потока будут реберно не пересекающимися.
В единичной сети он будет целый, по каждой путь будет единичный. Ну максимальный поток,
но в остаточной сети после каэтерации. Берем максимальный поток, берем декомпозицию. То есть
он декомпозируется на какое-то количество путей и величина этого потока это и есть количество этих
путей, правда? Но смотрите какая ситуация. Ребер-то у нас в графе всего зе, а каждый путь жрет хотя бы
ка-ребер, правда? А то и ка плюс один. И пути реберно не пересекающиеся. Отсюда следует,
что максимальный размер этого оставшегося потока не превосходит модуле делить, ну ладно уж напишу,
даже на ка плюс один. Это вот мы сделали каэтерации блокирующих потоков и смотрим на остаточную сеть и
смотрим, а сколько там максимально потока можно еще пустить. Да, можно даже его fost k написать. Во-первых,
это не fae, это была общая симптотика. То есть симптотика будет, потому что каждая итерация
работает за е, как мы выяснили, а итерации самих вот первая ка плюс сколько у нас потока осталось,
потому что каждая итерация одну единицу потока это притолкнет. Поэтому теперь оцениваем сколько у
нас этих f осталось. Оказывается их осталось не более чем е поделить на ка плюс один. Логично, да?
Чего? Потому что мы сказали, мы сделали каэтерации и хотим посмотреть,
что там будет дальше. Да, оказалось, да, то есть оказалось, что мы сделали каэтерации,
после этого нам осталось сделать не более чем е поделить на ка плюс один итерации. То есть получается,
может доказали теорему о том, что асимптотика у нас будет не более чем е умножить на ка плюс,
там е поделить на ка плюс один. Остается только выбрать, то есть остается только выбрать ка так,
чтобы эта оценка была как можно лучше. Ну как выбрать ка, чтобы это асимптотически было как
можно лучше? Мы этим уже занимались. Ну надо чтобы они, ну понятно, что ка должно быть приблизительно
корень из е. Тогда подставляем и тут получается, что этих итераций будет не более чем, то есть на самом
деле я тут мог бы даже уточнить, их будет не более чем два корня из е. Еще раз ка это кто? Количество
итераций, которые мы решили сделать. Ну да, проговаривались только что. Мы же проговаривались,
мы говорили, что после каэтерации блокирующего потока у нас осталась какая-то остаточная сеть
единичная, в которой расстояние от s до t, расстояние от s до t, собственно больше ка. То есть если этот
максимальный поток в этой сети и декомпозировать на пути, то каждый из этих путей будет длины не
менее чем ка плюс один и при этом пути не пересекаются по ребрам, потому что сеть единичная. Вот отсюда и
радость. Внимание, мы очень сильно пользуемся тем, что сеть единичная естественно.
Мы говорим, что мы можем этот максимальный поток декомпозировать таким образом. Я не очень понимаю,
почему мы связываем то, что мы можем декомпозировать, как мы этот факт используем. Есть
какой-то максимальный поток в остаточной сети, декомпозируем его. Он состоит из вот такого
количества ребер на не пересекающихся путей, в каждом из которых хотя бы ка плюс одно ребро,
а всего ребер е. Отсюда автоматически следует, что у тебя там допустим 100 500 ребер и из них мы
выбрали несколько путей, не пересекающихся ребер на путей, по 57 ребер каждая. Но тогда получается,
что количество самих путей не более чем 100 500 поделить на 57. Максимальный поток в остаточной
сети после ка итераций. Такая у нас оценка, что из-за того, что каждую итерацию мы добавляем как минимум.
Да, количество дальнейших итераций мы оцениваем как размер оставшегося потока.
Так, ребят, давайте, если еще не понятно, давайте лучше еще тут разберемся, потому что дальше будет
эта идея в более сложном виде. Потому что мы сказали, что для любого ка верно, что алгоритм
то есть количество итерации будет ка не более чем ка плюс е поделить на ка плюс 1. А теперь говорим,
а давайте теперь скажем, что ка это корень из е. Мы могли сказать, что ка равно 57 и доказать,
что итерация будет не более чем 57 плюс е поделить на 58. Могли сказать, что их 179 и получится не
более чем 179 плюс е поделить на 180. А мы говорим, а давайте ка будет корень из е. И тогда мы сделаем
не более чем, получается, корень из е плюс е поделить на корень из е итераций. Получается вот
два корня из е. Что такое не хватит? Вот в данном случае, что такое не хватит?
После ка итерации выяснилось, что максимальный поток в остаточной сети не превосходит вот этого.
Смотрите, остаточная сеть это тоже сеть. В ней есть максимальный поток. Более того,
максимальный поток в исходной сети равен потоку, который мы за эти ка итерации протолкнули,
плюс размер максимального потока в остаточной сети. Плюс максимальный поток в остаточной сети.
Вот. Это я просто время работы написал. Ну, кстати, да. Но это нам не принципиально,
потому что внутри итерации мы уже сказали, что каждая итерация работает. Почему я тут
домножаю на е? Потому что каждая итерация работает за о от е. И что? Но это не важно,
мы же исключаем только в рамках этой итерации, в следующей итерации они могут снова сожрать.
В какой-то следующий даптаннот. Поэтому как бы это не глобально. Я не знаю доказательства
с такой логикой. Это вообще тут ни при чем. Нет, это здесь ни при чем вообще. Потому
что, напоминаю, это понятие убить ребро работает только внутри одной итерации. Как только начинается
другая итерация, все ребра на мне просто резко простудились, стали на место и как бы мы все
начинаем заново. Нет, в смысле? Хорошо. Если бы у нас на ката итерации какой-то потенциал уменьшался
на ката. Вот такое доказательство. Нет, ну извините. Очень жаль, что доказательство не попало под
понятным подлюбимый вами шаблон, но как бы от этого доказательства. Выполним корень изе итерации
концепции блокирующих поток. Тогда оказывается, что максимальный поток в остаточной сети после
этого не превосходит тоже корень изе. Следовательно, общее число итерации будет не более чем корень изе
плюс корень изе, то есть два корень изе. То есть два корня изе, все. Вот схема вот такая. Не тривиальная
для въезда, может быть немножко, но это самый простой юрид. То есть количество итерации вот
такое, а время работы получается зе на вот столько. Вот еще раз, потому что, во-первых, у нас остаточная
сеть все еще единичная. Во-вторых, но расстояние от s до t в ней не менее чем k плюс 1. Вот. Тогда,
если мы этот максимальный поток в остаточной сети декомпозируем, потому что наличие любого из
остаточной сети не будет в короткой сети просто потому что это... Нет, просто что такое декомпозиция? Давайте так
попробуем. Что такое декомпозиция? Декомпозиция это означает, что нам дали набор путей и циклов таких,
что мы можем взять эту сеть, обнулить там все потоки, а потом после этого по одному эти пути
запустить. В общем, заметим, что эти пути это на уровне дать инструкцию бабушкам, давайте пускайте
вот эту воду. То есть никаких обратных ребер нету, там ничего нету. Да, по обычной пути там несколько
путей, несколько циклов могут проходить по одному и тому же ребру, это нормально, потоки по ним
суммируются. Единичные не могут, да, потому что. Вот. Давай.
В остаточной сети увеличивается расстояние от СДТ? В остаточной сети от... Ну, конечно, после каждой
итерации расстояние от СДТ увеличивается. Но мы, ну скажем так, отсылаю как бы предыдущие лекции.
Нет, ну мы доказали, что на каждой, мы доказывали, что на каждой итерации, после каждой итерации
расстояние от СДТ строго увеличивается. Из этого, да, просто у нас была едва ли не так сформулированная
серияма. Давай. Почему максимальный поток в обычной сети будет представляться в виде максимального потока в остаточной сети?
Нет, он будет представляться в виде сумм, объедения суммы потока, который мы пустили до этого, плюс поток в
остаточной сети. Мы лично мы посчитали это самоочевидным фактом.
Ну просто вот в этом обычном фордафолкерсоне делаем, у нас всякие рёбра, нососнашение сети меняется каждый раз.
Да, меняется. Мы сказали, что в мире корректно складывается поток в обычной сети в остаточной сети, но мы не сказали, почему любой поток,
почему любой поток, почему если мы найдём поток максимальный в остаточной сети, он будет максимальный и в...
Ну можно это интерпретировать так. Допустим, ты сделал этого фордафолкерсона, там есть 179 итераций. Рассмотрим то, чтобы остаточную сеть на момент после 57 итераций.
Почему у нас вообще возник нет? Почему у нас максимальный поток в остаточной сети? В сумме с нашей потоком будет равен максимальный поток.
Ну потому что у нас критерии максимального потока до этого было только один.
Ну что, в остаточной сети там ничего не останется? Ну по большому счёту, смотри, если ты в остаточной сети вот этой сейчас, ты уже в сети пустил вот этот поток.
А теперь ты прибавляешь к нему ещё вот этот максимальный поток, который в этой остаточной сети можно пустить.
Ну значит, сеть поменяется.
Поменяется. Но эта остаточная сеть будет остаточной сетью, можно сказать, относительно этой остаточной сети тоже.
Ну потому что...
Мы сложим два потока, у нас не будет пути изначальной вершины.
Ну вот, смотри, я пытаюсь...
У нас там два потока могут накладываться, и из-за этого какие-то ребра прямые могут всё-таки пыть.
Нет, ну во-первых, они будут суммироваться, причём без... Ну да, они будут как-то суммироваться.
А во-вторых, потому что это нужно понимать, как я как раз тебе говорил, Сонгри,
предположим, что у тебя был метод Форда Фолкерсона, и ты в нём сделал 179 итераций.
Сейчас вот просто картинка такая, рассмотрим, что было после 57-й итерации.
После 57-й итерации, значит, у тебя была какая-то остаточная сеть.
Да?
Но теперь тогда заметим, что оставшиеся 122 итерации,
значит, можно интерпретировать, как вот тебе дана вот эта сеть,
G57, мы её назовём, и в остаточной сети относительно G57 ты искал максимальный поток.
Ты делал буквально то же самое.
С ограничением там всё будет нормально? Ну, наверное, всё.
Нет, ну в смысле, с ограничением-то всё будет нормально, потому что у нас в остаточной сети с ограничением всё будет нормально.
Ну вот всё, поэтому получается, что ты дальше после 57-й итерации делал,
можно говорить, что ты за 122 итерации нашёл максимальный поток в 57-й сети, по факту.
То есть это просто одно и то же буквально.
Ну вот, ну и здесь то же самое, на самом деле, что в том плане, что если у тебя есть максимальный поток,
то этот поток, то что ты пустил, может декомпозировать на пути, да?
И как бы пустить. У тебя останется вот эта остаточная сеть, ты тоже можешь сказать, что прикинемся, что мы делаем метод Форда Фолкерсона,
и вот эти там, и декомпозируем это на пути, эти пути будем пихать, пихать, пихать.
Так что получится так.
Я просто в любом случае проверяю, что какие-то очевидные утверждения, нежели которые нельзя туда заседать, взглянуть.
Нет, ну доказать можно всё, но я не знаю там.
Нет, ну так, это...
Ну нет, вот тут как всё-таки доказать-то можно, да, можно, конечно, как бы так, можно это всё там сесть и действительно там написать очень формальные утверждения, очень формальные доказательства,
но от смысла это нас уведёт очень далеко.
То есть как бы, да, тут просто, да, тут лучше-то...
Можно вопрос?
А?
У нас же все должны быть не для технических, главное, чтобы все во всему способности были бы сравнены, верно?
Ну по большому счёту, да.
Ну на самом деле это решается очень просто, это то же самое, как сказать, что у нас не сто литров, а один деколитр.
Так, неправильно, как там это...
Ладно, не тысяча литров, а один килолитр, вот.
Килолитр.
Ну да, я знаю, что такого нет, но...
А кубический метров это?
Ну там нет, литр это кубический дециметр, да, ну да, значит, тысяча, ну хорошо, да.
То есть это как бы перевод единицы, то есть по сути как бы...
То есть это по сути, там, то есть в данном случае заменить 7 на 1, то же самое сказать, что там, я не знаю, там, 179 сантиметров, это на самом деле там 57 метров, одно и то же.
Это аля А2, А2, А2, А2.
Ну, ну типа того, да.
И время работы в текилейне Е как не из Е?
Ну да, так что в итоге можно, да, то есть более точно, то есть как бы требование заявлять, что время работы алгоритма Дениса в любой единичной сети это Е как не из Е.
Так, а времени у нас... Ой-ой-ой, так, ой-ой-ой.
Сейчас, сейчас скажем про парсочи, ой, про парсочи тут сейчас вообще смешно будет.
Потому что сейчас вы видите, да.
Сейчас, я просто должен телефон...
Чего?
Нет, там...
Нет, сейчас я скажу, просто там можно еще, да, потому что...
Потому что если...
То есть, смотрите, если мы сейчас говорим о парсочетаниях, то тогда оказывается, что параноид, что на самом деле, если вы будете искать парсочетания с помощью вот уже имевшейся у нас сети и алгоритмы Дениса, то я утверждаю, что парсочетания...
Ну, мы уже доказали, что парсочетание Денисом находится за Е как не из Е.
В принципе, уже неплохо, да.
Но на самом деле можно сказать точнее.
Я утверждаю, что это парсочетание будет найдено не за Е как не из Е, а за Е как не из В.
Спрашивается, почему я это утверждаю?
Доказательства абсолютно то же самое, только К, в качестве К я подставлю...
Ну, во-первых, я в качестве К подставлю...
Вот давайте красненьким скажем.
Ну, то есть понятно, что в качестве К я подставлю, во-первых, корень из В, а почему я подставлю корень из В?
А подставлю я следующее, потому что дело в том, что размер оставшегося потока я могу оценить не как Е поделить на К плюс 1,
а как В поделить на К плюс 1.
Потому что я утверждаю, что там сеть устроена чуть-чуть более экзотическим образом.
Дело в том, что...
Так, ребят, смотрите внимательно.
Сейчас я опять скажу идею, на которую мы будем базироваться потом.
То есть идея такая.
То есть дело в том, что у нас сеть устроена так, что в каждую вершину либо входит одна единица потока,
ну, по крайней мере, изначально, либо выходит только одна единица.
Ну, в смысле, не поток, а вот, то есть выпустить можно.
И более того, если вы через вершину пропустили по какому-то пути поток,
то это свойство сохранилось.
Понимаете, да?
То есть если я вот там, скажем, найду какой-то вот этот путь,
то тогда в эту вершину все еще будет входить ровно одно ребро пропускной способности 1.
Что за свойство?
Вот я и говорю свойство.
Свойство о том, что в эту вершину входило только одно ребро пропускной способности 1.
Какое?
В вершину левой доли.
Так, ну, вспоминаем.
Как мы ищем про сочетание?
Мы строим вот такую сеть, помните, да?
Тогда в эти вершины входит всего по одному ребру пропускной способности 1.
А из этих вершин выходит ровно по одному ребру пропускной способности 1.
Утверждение, когда мы там будем запустить какого-нибудь единица,
или что угодно, любой поток пустим, не обязательно максимальный,
то я утверждаю, что для каждой из этих вершин это свойство останется на месте.
То есть в эти вершины у вас все еще будет входить ровно,
по одному ребру пропускной способности 1, может быть,
ну, просто может это не вот это ребро, а какое-нибудь другое,
и из этих вершин будет выходить ровно по одному ребру пропускной способности 1.
Вот такое утверждение.
И вы можете на другой стороне?
Да, просто оно куда-то сюда может вести.
Доказательство очень простое.
Потому что, допустим, вы там нашли какой-то новый путь,
значит, из SFT по единичкам, да?
Вот.
И тогда, и решили прям выпустить поток.
Тогда, значит, вы вот эти ребра убились,
а вот эти ребра появились.
Получается, у каждой вершины количество исходящих ребер,
количество, ну, в нашем случае граф единичный, да?
Поэтому количество исходящих ребер и входящих ребер,
ни у одной из этих вершин не поменялось.
Кроме SFT.
Ну, кроме SFT, разумеется.
Понятно, да?
То есть вот такое интересное свойство.
Ну и в общем, на самом деле, его можно обобщить.
То есть в общем случае просто верно,
что как бы сумма пропускных способностей входящих ребер
никогда не меняется.
Равно как и сумма исходящих пропускных способностей.
То есть просто не меняется.
И мы этим будем пользоваться.
Но в единичной сети этим воспользоваться проще всего.
То есть так как у нас в каждую вершину
входит не более чем одна единица потока,
либо выходит не более чем одна единица потока,
то я тогда могу утверждать следующее.
Что рассмотрим вот эту вот остаточную сеть.
Я утверждаю, что пути в ней
не будут превосходить.
То есть эти пути не будут пересекаться не только по ребрам,
но и по вершинам.
Потому что через каждую промежуточную вершину
может пройти не более чем одна единица этого потока.
Что не так?
Что не так?
Есть опять же прикол в том,
в какой конкретной остаточной сети это происходит.
Потому что в разных остаточных сетях.
Ну смотри, значит, еще раз.
Сейчас я скажу подробнее.
Давайте сначала лучше.
Берем вот эту сеть.
Делаем там K итерации потока.
У нас остается какая-то остаточная сеть.
В ней есть максимальный поток.
Мы его декомпозируем.
На какие-то пути циклы.
Циклы можно выкинуть, неважно.
Но я утверждаю, что
два этих пути не могут пройти
через одну вершину.
Потому что входит в них
ровно одно ребро с единичкой.
Либо это входит, либо какое-то это.
Главное, что оно в каждом интервью одно.
Но у нас же есть обратные ребра.
И они могут делать так, что стало больше, чем одно.
Но тот и прикол.
Что могут-то делать.
Но дело в том, что при проталкивании
каждой единицы потока у вас в каждой
промежуточной вершины исчезает
одно входящее ребро единичка.
И появляется одно входящее ребро.
И происходящее тоже.
Исчезает одно исходящее.
И появляется одно исходящее.
Поэтому получается, что если у вас
входило ровно одно ребро,
то и будет входить ровно одно ребро.
И ничего вы с этим не сделаете.
В этом и смысл.
Там сеть, конечно, не такая красивая.
Особенно если слоистая нарисовать,
там будет что-то сильно сложнее.
Но вот это свойство останется.
То есть мораль очень простая.
Что через эту вершину, оказывается,
не может проходить больше одной единицы потока.
То есть она там может 1000 раз отменяться,
но все равно не более чем один.
И это более общий случай.
На самом деле это интересный случай.
То есть если у вас в вершину
входит суммарно ребер
на 57 единиц потока,
то на самом деле даже в общем случае
оказывается, что в общем-то
какой бы поток ни пустили,
а все равно в остаточной сети в эту вершину
будут ходить ребра на суммарно 57 единиц потока.
То есть пропускной способности.
Это будет другой набор ребер,
с другой может быть суммой.
То есть с другой суммой в смысле
по конкретным слагаемым.
Но сумма эта все равно будет равна 57.
Здесь тоже может выйти,
что в эту вершину входит 57 ребер.
А выходит одно.
Я утверждаю, что всегда в эту вершину
будет входить 57 ребер, а выходить одно.
Для правой доли в эту вершину
может входить сколько угодно ребер.
Выходить может одно,
заходить может сколько угодно,
может 57.
Но если сюда заходило изначально 57 ребер,
то и будет всегда заходить
ровно 57 ребер.
В остаточной сети.
Пропускная способность.
Это официальный термин.
Нет, дословный перевод,
емкость конечно,
но в русскоязычной традиции
теории потоков
это называется пропускная способность.
Чего?
Вряд ли.
Пропускная способность как-то точнее.
Логично, что труба
может пропустить в единицу времени
5 единиц потока.
Все, логично.
Потому что она физически вот такая.
И вообще логично.
Есть пропускная способность канала.
Панамский канал может пропустить
57 кораблей в сутки.
Я точную цифру не знаю,
я от балды сказал.
Итак, мы пришли к тому,
что у нас оказывается пути
в декомпозиции не пересекаются.
По вершинам не пересекаются.
А это означает,
но на этот раз
заметим, что придется нам
написать не k плюс 1 здесь,
а все-таки k.
Потому что каждая вершина,
если пути длины не менее,
чем k плюс 1,
то он проходит по не менее,
чем все-таки k.
Промежуточным вершинам.
Поэтому получается,
что мы теперь можем оценивать здесь.
Тут получается v, тут получается k.
Но, тем не менее,
если вы хотите поделить на k,
найдите k так, чтобы симптомика
получилась как можно лучше.
Берем k равно корень из v
и получаем
мистическую теорему.
И теорема называется так.
В общем, мистическая теорема.
Алгоритм Хобкрофта-Карпа
Хобкрофта-Карпа
Обе эти фамилии вы наверное уже слышали.
У вас формалки уже были?
Так вот, один из...
Нет?
Билекция была.
По-хорошему говоря,
скорее всего,
там какие-то учебники по этим курсам
на самом деле идут завтра
Ахо Хобкрофта-Ульбана.
Нет, Ахо тот же.
Вроде тот же Альфред.
Да, который алгоритм Аха-Карайсер.
Вот.
Ну Карп, ну да.
Алгоритм
Хобкрофта-Карпа
работает
за o от
e корней из v.
Вот.
Истинно так.
То есть, на самом деле, да.
Забавно.
Что, казалось бы, в чем заключается...
Эдманскарп заключается в том, что
берем метод форта функциона,
используем BFS.
В чем заключается алгоритм Хобкрофта-Карпа?
Ищем про сочетание с помощью потока,
просто поток делаем единицам.
Видимо заслуга авторов
целой статьи, видимо, отдельной.
Вы не знаете, Карп с Карасиком
писали что-нибудь вместе?
Не с Карасиком,
а с Карасик, во-первых.
Во-вторых, какие отношения
связывали, действительно,
от этих двух ученых области алгоритмов,
я не знаю.
Каких?
Рыбалка.
Но я не знаю.
В английском языке я не уверен,
что там слово Карасик имеет отношение
к рыбалке.
Где написано?
В библиотеке алгоритмов своих.
Ну, написано.
Ахо Карп?
Я понял.
Вы еще и на Карп коломбурите.
Ладно.
Ладно.
Кошмар.
Ну ладно.
Так вот, алгоритм Хобкрофта-Карпа
в любом случае у нас говорит,
что их заслуга в том, что они просто доказали,
что, оказывается, единица тут просто очень быстро
работает.
Да.
Но я имею в виду, я обещаю,
почему это называется алгоритм
Хобкрофта-Карпа,
а не просто давайте про сочетание единицам
найдем.
То есть, в общем-то, и все.
Я не помню.
Мне кажется, там тоже какая-то короткая статья,
в которой просто провели вот это рассуждение.
То есть, может быть, там была большая статья,
где они там на самом деле доказали еще
что-то.
Но как бы вот это круто, потому что
формально получается, что, как минимум, на тот момент,
видимо, было найдено алгоритм поиска
про сочетание с более быстрой симпатикой,
чем доселе было известно.
Вот.
То есть, реализация алгоритма
Хобкрофта-Карпа
это
Дэд Хобкрофта-Крафт
ретурна единиц.
Ну, по сути, да.
Нет, построим стандартную сеть,
натравим на нее единица.
Все. Ну, и выкопаем
про сочетание в соответствии с потоком.
Но это еще не все, что тут
можно сказать про сочетание. Сколько у нас там
времени-то осталось? Ой, а времени у нас немного,
придется теоремы Корзанова в следующий раз
обсуждать. А пока мы запомним
вообще совсем прикольные теоремы,
которая, возможно, была доказана буквально там несколько лет
назад.
Вот.
Да, как-то можно
пошутить на эту тему.
Можно, да, можно пошутить на эту тему.
Да, мы не знаем, кто, да.
То есть, ладно, да, можно, наверное, фамилию
не называть конкретного автора.
Итак, теорема Умника.
Да.
Да, сейчас мы докажем
теорему, которую Алексей Данилюк
рассказал в своей дипломной работе.
Так. Как там?
Сейчас только я ее вспомню.
Нет.
Нет, теорема...
Нет, история, на самом деле, такая.
То есть, он ее доказал, а потом дал
в Петрозаводск. Так что уж
извините, я спалю задачку.
Из какого-то там Петрозаводска
18-го года.
Вот.
Но там была замечательная
задача.
Дан двудольный граф.
Миллион вершин, два миллиона
ребер. Найти
почти максимальное
просочетание.
Значит, надо найти почти максимальное
просочетание. Что такое почти? Значит,
вам нужно вывести какое-то просочетание.
Ответ будет
признан правильным, если
просочетание будет корректным.
И размер этого просочетания будет не менее
95 процентов от максимального.
Вау!
Господи!
Конечно, прям вот
в Петрозаводске.
Давайте быстро пишем
софтхип. Да.
Конечно.
Да-да.
Нет.
Но, по сути,
алгоритм заключался в том, что вы просто
должны максимально упихать
алгоритм Диница, пытаясь пропихнуть
туда максимальное количество.
Но могли бы так работать. Давайте впихать туда
столько итерации Диница, сколько сможете.
А как чекер?
Откуда он знал?
Ну, чекер, видимо, на каждый тест
тупо знал правильный ответ.
Нет, ну,
смотрите, ограничение полигона,
потому что это его личное дело.
Вам же никто не мешает там...
Нет, ну, почему на ночь? На самом деле алгоритм
Хопка, как будет работать, в общем-то,
ну, наверное, за минуту сработает.
На любом тесте. Поэтому
если вы взяли тесты, вы можете сгенерировать
на них ответы, записать их, а потом,
соответственно...
И там, допустим,
как-то их зашить.
Понятно, что будет там, что считался ответ
участника, считался, из АНСа
считался ответ правильный, и
померяем, что 95 процентов. То есть это
как бы делается. Да, то есть это, конечно,
не совсем по схеме
полигона получается, классической схеме,
но, тем не менее, так можно сделать.
То есть схема
полигона в этом плане, знаете,
в Яндексе как-то сказали на эту тему, что
я как-то думал, что
в Аркадию нельзя покомитить
без какого-то ревью,
потому что я же маленький какой-нибудь новенький
разработчик, я же не могу,
у меня там какая-то мелкая ошибка,
но мне же надо ревью пройти.
На этом мне ответили так,
слушайте, все-таки клетки
существуют для зверей,
а для людей существуют надписи.
Вот клетки существуют для зверей,
а для людей надписи.
То есть подразумевается,
что
условно говоря,
есть вероятность, что для какой-то безопасности,
чтобы люди не натворили всяких телов,
их можно посадить в клетку
и выпускать их
только под расстрел,
под пулеметом, чтобы они ходили
только по задному алгоритму, да,
это будет в каком-то смысле безопасно,
но неэффективно.
Поэтому, конечно,
более правильно,
чтобы люди...
существует там какой-то ревью,
существует там какой-то мерой,
но это все-таки надписи.
То есть как бы желательно,
чтобы человек в общем случае делал,
но если задача в том,
чтобы подправить одну запятую,
то ради этого беспокоить других людей,
это как-то туповато.
Там была такая ситуация,
мне надо было мелочи покомитить.
Можно мелочь без ревью закомитить
и уронить все?
Нет, это тоже решалось,
потому что при любом комите
автоматически запускались тесты.
Поэтому это привело мне к классической ситуации,
когда я там что-то покомитил,
но случайно оно не компилилось,
хотя я вроде у себя запускаю,
но в результате мне там пришли тесты,
что оно ничего не компилилось.
Я уже понимаю, что нет,
но тут мне на моем рабочем столе
звонит телефон.
Впервые в жизни он звонит,
то есть я как бы не знал,
как туда добавить.
Я знал, что есть телефон,
он мне звонит, я говорю,
беру трубку, говорю, алло,
и из трубки мрачный голос,
ты сломал Аркадию.
Да, я уже знаю,
когда сможешь починить?
В течение минут максимум 10.
Нет, Аркадия это оставляет
библиотека Яндекса,
на которой написан поиск.
То есть вы сломали
Аркадию на 10 лет?
Нет, ну скажем так,
я его не сломал,
потому что в эсвоении есть
разработческая ветка,
когда все текущий разрабатывается,
это одно дело,
а другое дело есть ветка,
которая не работает,
она не работает,
а другое дело есть ветка,
которая идет просто в продакшен,
которая реально работает.
С другой стороны,
так как я находился в какой-то
исследовательской группе,
которая пыталась что-то чуть улучшить,
то я в продакшен закоммитить не мог.
Мне тупо незачем было это делать.
Я не отвечал за то,
чтобы Яндекс работал или нет.
Не, ну какой Агент Кугла,
Кому это надо?
Вот.
Не, ну и потом,
я же все равно...
Можно устроить эти
стандартные приколы,
что там какая-то система
вдруг неожиданно упала,
все там в панике ищут ошибку,
а потом выяснилось, что тут человек уволился,
и в одном из его комитов оказалось,
что в каком-то файле было
просто добавлено где-то две строчки.
Или даже одна строчка там.
Define true-false комментарий.
Счастливой отладки, сволочи.
Ну да.
Это, конечно, стандартная история,
но тем не менее.
Давай.
Что?
Вот.
Вот сейчас я...
Вот я тут пока не просто так рассказываю,
я это все стираю для того, чтобы
как раз и рассказать о теореме Дугилюка,
и Сегина этом закончит.
Теорема умника, что он
сразу почти набирает почти все,
а потом чуть-чуть забирает?
Ну по факту да.
То есть на самом деле мы сейчас докажем,
с точки зрения практики, что для того,
чтобы набрать от максимального до 95%
на самом деле достаточно
всего 19
итераций единиц.
Почему 19?
Потому что 95%
это 19,20.
В смысле это константы?
Для любого?
Нет.
Так, тихо, тихо, тихо.
Что там вот обсуждения?
Господи, я уже достаточно долго
с каким-то гулом имею дело.
10 в шестой вершине, 10 в степени 10,
в степени 6, все равно должно было быть 19.
Чего?
Нет.
Итак, внимание,
Теорема Дугилюка.
Вот.
Не знаю, наверное.
Может выяснится, что на самом деле
он ее откуда-нибудь взял, конечно.
Нет, я имею в виду,
чтобы в дипломе было такое утверждение,
но на самом деле, знаете, это из цикла,
в такой формулировке никогда
не формул.
Там в науке иногда такое бывает,
что есть какое-нибудь там
простое утверждение, допустим,
то есть оно в явном виде никем
не доказывалось, но
как-то занимающиеся этими задачами
как-то все о нем знают.
Но знаете, что-то из цикла,
если вы читали эту книжку про модистов
рассеянных наук, например, у Левшина есть
такой пример, что он там нашел какую-то там
теорему и там даже искал
в какой-то там суперэнциклопедии,
в которой есть все, что знает математика,
и не нашел.
И он так и думал,
что, возможно, теорема моя,
но
пока я не нашел ее просто
как олимпиадную задачку
для старшеклассников.
Просто это кто-то дал в качестве задачи.
Тут вот такой еще момент есть.
То есть
формально говоря, конечно, если...
То есть ответ такой, что формально говоря, конечно,
если никто это не формулировал,
то можно себе это написать и сказать,
но другой вопрос, что если вы статью
ради этого не напишете.
Потому что статью могут забанить по принципу,
что там не написано ничего,
то есть там написаны какие-то простые вещи,
которые научное сообщество
вообще хорошо и так прекрасно знает.
На самом деле у меня были балансы
на эту тему, потому что, я помню, мою статью
по внешним бильярдам пытались завернуть,
потому что видный специалист в области так и написал,
что в статье ничего нет
и просто типа сообщество
не знает.
Правда, там редактор
журнала удалось убедить в том,
что
автор
в данном случае, как минимум,
кидает неадекватные аргументы,
но там он просто попытался это подкрепить тем,
что на самом деле
похожего рода вещи были
в виде 1, 2, 3,
и там удалось тыкнуть, что там, скажем,
3, просто там не было ничего
про этот случай в этой статье, идите лесом,
вот просто факт не было.
Называется в этой статье как бы доказаны
похожие результаты, но не такие,
ну и так далее.
Но там вот такие вот приколы еще в науке могут быть.
Нет, ну а что делать, слушайте,
ну как бы без этого никак,
потому что везде, где вы сталкиваетесь с человеческим фактором,
что-нибудь подобное да произойдет.
Потому что если вы хотите вот
опубликовать какую-то, то есть как бы если вы хотите
заставить за собой результат, вам нужно опубликовать статью.
Ну заставить за собой, самый простой способ
ее в архиве естественно опубликовать, да.
А у вас есть мат-практика?
Да, не обязательно. Не у всех.
Ну понятно, у кого-то есть. Ну понятно,
наверное, что такое архив вы скорее всего знаете.
Ну или скоро узнаете. Ну не важно, вы можете считать,
что, ну короче, это эквивалент на тому,
что вы просто там на GitHub свою статью вывесили и все.
По большому счету.
По большому счету, да, в принципе это уже можно считать,
что вы как бы заставили за собой результат,
потому что это будет информация, что вот в этот момент
результат у вас уже был, ну чтоб там не было споров.
Ну а чтобы он официально был
защитно научен, вы должны
написать статью и чтобы ее приняли в журнале.
Но как устроен прием
в журнале? Ваша статья
берется, ну понятно, редактор смотрит
ее на первичную адекватность вообще,
чтобы там, условно говоря,
в журнал по математике не прислали рецепт борща
там какой-нибудь.
Ну вот, там условно.
Ну или
что-нибудь такое.
Ну или что-нибудь такое науча
учебская, да? Вот.
Но тогда, если там содержатся какие-то результаты,
которые вроде выглядят разумными и так далее,
то как бы это отправляется на ревью
как минимум одному, значит,
солидному математику-специалисту в этой области.
Ну либо одному, либо там
может быть там паре-тройки. Они пишут отзывы.
То есть как бы если отзывы все положительные,
что да, это крутая статья, результаты новые
и так далее, ура, то значит
значит тогда принимаем к печати, пишем.
Но как бы могут прислать, что нет,
результаты не новые, потому что вот раз, два, три,
в самом деле это уже давно было.
Вот. Или там что-нибудь еще в этом...
Или просто там результаты...
Или там можно просто думать, что результаты слабые,
потому что, ну просто, ну тупо на уши.
Там сообщество и так все...
Там сообщество, какими меня это все
и так прекрасно знает, это неинтересно.
И так далее. Ну вот. То есть вот такие вот тут.
Ну, то есть...
А в этом месте понятно, что как бы там
может возникнуть, что этот отзывающий,
если он работает в этой области, то как бы у вас
может возникнуть естественная конкуренция на самом деле.
И дальше все зависит уже там вот
разного рода чистоплотности
и так далее. Так что, увы, ну как бы
везде, где человеческий фактор, подобные вещи могут
возникнуть. Это нормально. То есть
нужно просто к этому быть готовым и как-то адекватно
просто адекватно на это реагировать.
Понятно, что в целом в общем-то там математическое
сообщество обычно как раз это штука
честная, потому что вот у нас математическое доказательство
это как бы штука честная.
Ну да, ну тут
никуда не денешься, тут как бы там
словоблудием обычно называть никого
и закидаешь. Нет, там есть конечно
разные приколы в духе.
В одной теореме там был прикол, что там
было по теореме доказано
опубликовано три доказательства, в общем
два опубликованы даже в одном и том же журнале.
Второе опубликовалось формулировкой.
Вы знаете, я читал это
доказательство и ничего не понял.
А потом я подогнал с редакторами журнал, выяснилось,
что ревьющие тоже ничего не поняли.
Поэтому я попросил разрешения, а можно
я напишу свое, как мне кажется, сильно
более понятное. И написал.
Они поняли?
Ну они поняли. Нет, ну видимо они поняли.
Более того, я его читал, но я не могу сказать,
что до конца дочитал, но там реально понятно,
что происходит. Там первое я не читал, сказать
не могу.
Так что нет, в принципе, то есть статья
не обязательно может быть, то есть статья может быть
это про известный результат, но по-новому доказанный.
То есть тут вот...
Ну дальше уже. Так, ладно.
Так что ладно, так вот. Не будем зависать.
Итак, теорема Данилюка. Все.
Вот.
Итак, теорема Данилюка. Будем.
Так, будем искать
парасочетания, там
максимальное парасочетание.
Там МАКС, ПАР, СОЧ, Е.
В двудольном графе.
С помощью...
Ну я...
Ладно, я...
Ладно, Данилюк почти наверно
писал динец, я буду писать КБП.
Тогда
после каэтерации
размер
размер
имеющегося парасочетания, размер
уже найденного парасочетания
найденного
парасочетания
пар, соч, е
будет
не менее
чем
К поделить на
К плюс один
на размер
максимального парасочетания.
Точка.
Вот.
Вот такой вот красота.
Вот.
Вот.
Спрашивается, почему?
Нет, в принципе, может даже интересно было бы дать вам задачу
и на самом деле посмотреть,
за сколько вы это придумаете.
Потому что в принципе, используя предыдущую логику,
на самом деле это достаточно легко придумать.
Потому что начало стандартное.
То есть
рассмотрим, выполним каэтерации
блокирующего потока
и посмотрим
на, так сказать, остаточную сеть.
Нам жутко интересно,
сколько мы будем
еще проталкивать.
Но заметим, что
оставшийся поток, максимальный поток
в остаточной сети после каэтерации,
вот.
Но там будет какой-то поток.
Его величина
будет равна, насколько еще
можно увеличить парасочетание. Правда?
Но теперь заметим, что
этот поток
можно разбить, как всегда, на пути.
Правда?
Можно?
Вот.
Но заметим, что каждый путь
с точки зрения... То есть на самом деле,
если в остаточной сети нарисовать каждый из этих путей
в декомпозиции, то это будет
то, что мы называем удлиняющая цепь.
Правда?
То есть там, потому что вот...
То есть каждый путь в этой единичной сети
по факту, если вот внимательно
посмотреть, то это будет просто удлиняющая цепь вот
такого вида. То есть зеленый это типа
максимальное будет парасочетание, там
типа новое парасочетание, а
это старое, да?
Вот, понимаете, да?
Но теперь заметим,
что длина этой цепочки...
А, ну еще
считая вообще, что у нас еще есть
вот это и вот это
еще, да?
То есть длина этой цепочки
на самом деле после
K-итерации, она
как минимум...
То есть ее длина
более чем 2K
плюс 3, правда?
Ну, потому что у нас как бы
двудольный граф такой, что у нас
изначально расстояние от SdT3
после первой итерации, видимо, будет 5,
потом 7, потом 9 и так далее.
Ну, потому что не может у нас быть
там четное расстояние от SdT.
Ну, у нас так граф устроен, да?
С цепочкой ходит ребро из S
и ребро из T. Да, ну
2K плюс 3, считая вот это ребро и вот это.
Но что это
означает? Это означает, что у нас тут
вот этих вот ребер,
но тогда вот этих вот ребер у нас,
пум-пум-пум-пум-пум, вот этих
зелененьких, их у нас получается
K плюс 1,
а вот этих вот
пум-пум-пум-пум, их получается
K.
То есть отсюда следует маленькая приятная вещь,
что каждый,
то есть если мы берем эту декомпозицию
оставшегося потока,
то каждая единица,
то есть каждая единица
увеличения потока соответствует K
ребер в текущем просочетании.
Понимаете, да?
То есть это означает,
что если вы протолкнули
сейчас уже вот это
курс индексом K,
понимаете, да,
то
далее вы протолкнете
не более чем
курс индексом K
поделить на K.
То есть если вы
выполнили
K итерацию единица
и протолкнули поток
курка,
то я утверждаю, что размер вот этого
данного потока в остаточной сети
того самого
теперь будет не превосходить
того, что вы нашли,
поделить на K.
Но нет, это то, что вы нашли раньше,
а это то, что вы можете
найти потом.
То есть еще раз,
потому что логика та же,
мы делаем K итерация единица
находим просочетание вот такого размера
и остаточную сеть находим.
Рассмотрим максимальный поток
в остаточной сети.
Этот максимальный поток
мы декомпозируем на рёберно
не пересекающиеся пути
да и вершина не пересекающиеся тоже.
Но заметим,
что каждый путь
он имеет длину как минимум 2K
плюс 3,
но при этом устроен он вот таким
образом, потому что помните,
что вправо вы идёте по ребрам не из просочетания,
влево вы идёте по ребрам
из просочетания.
Поэтому каждый путь выглядит
вот так и получается внутри
каждого из этих путей
вы найдёте как минимум K
ребер из уже найденного просочетания.
Причём более того, для каждого
пути
из декомпозиции эти K будут свои.
Следовательно,
так как всего у вас этих красных ребер из просочетания
K,
то цепочек в этой декомпозиции
не более чем K поделить на K.
То есть таким образом
получается, что у вас итоговый
размер просочетания не может быть
то есть вот этот анс
не может быть больше, чем K
плюс K поделить на K.
Остаётся только теперь проделать
очень хитрые математические манипуляции
и откуда вывести, что
действительно
K больше либо равно,
чем K поделить на K плюс 1
анс. Всё.
То есть оказывается, да, почти всё просочетание
на самом деле вы там находите за первые
сколько-то итераций. То есть, скажем, за первые 19 итераций
вы на самом деле
уже прекрасно находите
уже не менее чем
95%.
Всё-таки это работает
на 10 в степени 10 в шестой вершины?
Ну, в смысле, да.
Это рассуждение никак не зависело от того, сколько
у нас вершин.
Вы сказали, что не работает.
Ну, не знаю. Вы сказали, что не работает.
Значит, мы, видимо, друг друга как-то не поняли.
То есть, когда константа 95% и 19,
их связь не имеет никакого отношения
к тому, сколько вершин к графику.
Хоть 10 в шестой, хоть 10 в степени 10 в шестой.
Нет.
Нет, миллион, это, конечно, 2 в 20,
но в данном случае это случайность.
Миллион был выбран, видимо, Данилюком,
потому что дальше оказывалось, что да,
надо было это написать, но дальше потом
это надо было как-то упихивать всеми правдами и неправдами.
Потому что, как я понял, на контесте
это вроде там, может, что-то более-менее
попридумывали, но упихать никому не удалось.
Хотя может, конечно, люди
не знали, что конкретно надо. Может, там люди
сидели и упихивали, я не знаю.
Но они константу не знали.
Нет, не важно.
По идее так, если ты додумался,
если ты поверил, что Динец, видимо,
достаточно быстро сработает,
то ты просто пишешь Динец,
и отсекаешься патерейлю.
Ну да. А зачем
эту задачу вообще дали?
Данилюк хотел проверить,
считает ли кто там
очень трудный? Нет.
Но с формулированным так.
Во-первых, эта идея не выглядит так,
что ее нельзя придумать на Олимпиаде.
Но я думаю так,
опытные олимпиадники на самом деле могут
в этом месте задуматься.
Потому что все же знают,
что если там жадно искать про сочетание,
просто жадно поискать про сочетание,
то вы как бы не менее, чем половина
от ответа найдете.
А теперь вы искать вопрос.
То есть и Динец более этого будет это делать?
Блокирующий поток – это тот же самый жадник
по большому счету, да?
Тогда вы искать вопрос.
А этот Динец, может он и в будущем будет достаточно быстро искать?
И в принципе там можно,
если вы там как-то думали в сторону потока,
то как бы на этой темы вы можете задуматься
и, собственно, вот это тоже быстренько доказать.
Это раз.
А во-вторых, на Олимпиаде
могут дать на самом деле задачу
заведомо сложную.
Потому что, во-первых, знание есть знание,
во-вторых, иногда цель
дать задачу в контест на самом деле
даже не для того, чтобы ее решили,
а для того, чтобы ее порешали,
а потом на этом фоне рассказать что-то новое.
Это не сложная задача, а задача на кукаре.
Да, но это не кукаре,
это доказательный кукаре.
В плане любого кукаре,
доказательный кукаре.
Но не скажи.
Как повезет, как повезет.
Нет, тут два варианта.
Можешь в это поверить, а можешь на самом деле подумать
и доказать.
Потому что
я не знаю.
По-любому кукаре все равно доказывает.
Поэтому я и говорю. У меня ощущение,
что если бы я поставил вам цель
придумать это как задачу,
то, скорее всего, многие из вас бы это придумали.
Доказательство вот этого мы придумали,
но знаешь, что этот факт
есть.
Там нужно не придумать доказательство, а сформулировать такой факт.
Ну да.
Ну да, да, да.
Ну да.
А.
Я не очень понял, почему именно
круга делить на х, а не
два круга делить на х.
Да, но
дело в том, что путь после ка-итерации
мы можем оценивать не ка плюс один, а
два ка плюс три.
Да.
И из-за этого у нас оказывается, что
внутри этого пути там оказывается
реберспросочетание.
А можно вопрос?
А почему эта теорема,
которая можно найти в упражнении,
не любит использовать своя дипломная работа?
Видимо.
Потому что
не любой там какой-то
достаточно простой факт
значит А. известен,
Б. опубликован.
Ну ладно.
Потому что ровно за счет этого
катематика тоже работает.
Потому что на самом деле там
bou culmyaishennsii т.д. могут там опубликовать
статьи, где есть достаточно простые факты.
Но и часто бывает что там статьи
начинаются с каких-то простых фактов
чего будут факты простые?
Потому что в эту сторону толком никто не исследовал.
Поэтому там начинается с каких-то
простых фактов, но на основе их там
на самом деле удается заметить что-то более
глубокое. И тогда появляется уже хорошая
статья.
То-есть это обычно примерно так работает.
Ну, скажем так, мне нет, то есть мне нет, но я, как всегда,
кредитча не гарантирую, но как бы, то есть я даже не знаю,
то есть я не знаю, существует ли алгоритм, который умеет там
искать про сочетание быстрее, чем ZE-корней-ИЗВ, может этот алгоритм
до сих пор чемпионский, то есть достоверно известно,
вы в качестве упражнения можете понять, там можно ли придумать
тесты, на которых этот алгоритм будет реально ZE-корней-ИЗВ
работать, вот, ну вот, я подскажу, да, можно, то есть так и поэтому
точнее вы это алгоритм не оцените, ну вот, но может быть то есть
выходит, да, давай.
Почему факт того, что у нас, в нашей цепи M больше ребра
чем 2K плюс 3 ребра, мы как-то можем судить об итоговом
количестве ребер, которая встретится, ну, об итоговом максимально
про сочетание?
Ну, потому что, смотри, размер итогового про сочетания
это Qrk плюс, значит, размер этого максимального потока,
который мы найдем потом, да, сколько мы еще пихнем?
Да, в следующих итерациях.
В следующих итерациях.
В следующих итерациях.
Вот, но как бы этот максимальный поток мы декомпозируем
на пути.
А вот это красное, это идеал?
Какой идеал?
В следующей итерациях.
Нет, нет, смотри, красное это то, что мы нашли сейчас.
Да.
Ну, а на основе этих красных ребер будут еще какие-то
удлиняющие цепи, которые нам поток увеличит.
А поток может быть увеличен только с помощью некоторого
непересекающегося набора таких цепей.
Вот можете, пожалуйста, эти рассуждения строго проделать?
Что такое строго, тогда я уже спрошу.
Ну, просто еще раз.
Хорошо.
Можете начать их проделывать еще раз?
Давайте, пробегаемся.
Значит, еще раз говорим.
Итак, у нас мы ищем максимальный поток в остаточной сети,
которая имеет место после каэта 1.
Этот поток мы можем декомпозировать на пути.
Эти пути будут вершинно не пересекаться, потому что у нас сеть единичная.
И как?
Ну вот.
И в принципе размер этого потока будет равен количеству удлиняющих цепей,
которые мы найдем.
Вот эти композиции, конечно.
Нет, максимальный поток в остаточной сети это максимальное количество
непересекающихся вот этих удлиняющих цепей,
которые можно найти в этой остаточной сети.
Вот.
Остаточную сеть мы смотрим на момент после каэта 1.
Значит, рассмотрим каждую из этих удлиняющих цепей.
Я утверждаю, что внутри каждой из этих удлиняющих цепей находится не менее чем k
ребер из уже найденного на первых k итерациях по рассочетанию.
Что такое удлиняющая сеть?
Ну, стандартная отсылка к алгоритму Куна, как вам его объясняли во всяких лкш и прочем.
В смысле, под удлиняющий цепь имеете в виду то, на что декомпозировался потом поток?
Ну да, но по факту это удлиняющая цепь.
Я имею в виду следующее, как рассказывают обычно про сочетание.
Обычно, когда вам рассказывают Куна, вам никто словами «поток», «фортфонткерсон» и так далее не ругается.
То есть, вместо этого говорят, что есть понятие удлиняющие цепи.
Пусть у вас есть про сочетание, да?
Тогда есть понятие удлиняющая цепь.
Это вот такая цепь, которая ведет нас из вершины левой доли, не покрытой про сочетанием, в вершину правой доли, не покрытой про сочетанием.
При этом каждое нечетное ребро, по индексу вот это нечетное ребро, не из про сочетания, а каждое четное ребро из про сочетания.
Это называется удлиняющая цепь.
Почему она называется удлиняющая цепь?
Потому что если вытянуть, можно вытянуть из про сочетания вот эти красные ребра и добавить вот эти зеленые, и про сочетание увеличится.
И вот это вот такая цепь, которая ведет нас из вершины левой доли, не покрытой про сочетания, не покрытой про сочетания, не покрытой про сочетания, не покрытой про сочетания, не покрытой про сочетания, не покрытой про сочетания, не покрытой про сочетания, не покрытой про сочетания, не покрытой про сочетания, не покрытой про сочетания, не покрытой про сочетания, не покрытой про сочетания, не покрытой про сочетания, не покрытой про сочетания, не покрытой про сочетания, не покрытой про сочетания, не покрытой про сочетания, не покрытой про сочетания, не
покрытой про сочетания, не покрытой про сочетания, не покрытой про сочетания, не покрытой про сочетания, не
гуаточной сети это на самом деле удлиняющая цепь.
Который прицепили вот такое ребро и вот такое ребро.
Ну да, ну сейчас, погоди, погоди, успокой, давай сейчас, смотри, жил был S, надо дойти до T, как мы дойдем?
Мы придем в какую-то вершину, теперь надо из нее, но заметим, что если раз мы пришли в эту вершину,
то эта вершина не покрыта паросочетанием, потому что если бы она была покрыта паросочетанием, то мы бы по этому ребру не прошли, да?
Хорошо, но путь какой-то есть, значит мы проходим по какому-то ребру в правую долю, у нас два варианта, либо мы из этой вершины торчит ровно одно ребро, либо оно торчит в T, тогда вот мы цепочку и нашли, это тоже удлиняющая цепь в принципе, да?
Либо это ребро паросочетания, которое ведет нас еще в какую-то вершину.
А почему удлиняющая цепь?
Сейчас, пока у нас есть путь от S до T, я просто показываю, что был запрос доказать, что любой теперь путь от S до T в остатке T будет выглядеть именно как удлиняющий цепь, который прицепили вот эти два ребра.
Да, да, нет, с этим...
А, хорошо, вот, то есть получается, да, что мы нашли какой-то набор, то есть получается максимально вот этот ans, он равен Qrk, плюс количество удлиняющих цепей в нашем наборе, который мы только что построили.
То есть не количество вообще удлиняющих цепей, которые тут в принципе можно найти, да?
Да, да, да, да.
А количество именно, собственно, тех удлиняющих цепей, которые у нас сейчас есть.
И этот набор удлиняющих цепей попарно не пересекающийся.
Да.
Но теперь интересно следующее, что в длина любого пути от S до T после K-итерации на не менее чем 2K плюс 3.
А, да, да.
То есть значит удлиняющий цепи хотя бы 2K плюс один ребр.
Все, окей, то есть получается K мы декомпозируем, мы не можем декомпозировать что-то длины меньше, чем K.
Да, то есть пути будут не менее чем, то есть каждый путь будет содержать не менее, чем K ребер уже найденного по сочетанию.
Да, окей, кажется.
Вот.
Ну вот.
Оно отсюда автоматически исследует что.
Просто тут такая небольшая путаница, что вот когда мы строим, когда мы делаем итерации, мы смотрим одни пути, а потом когда декомпозируем, это могут быть другие пути.
Да, но это да, в этом и сложилось, действительно, понимание этого метода.
То есть один раз это поняв, дальше мы там эти теории Корзанова, возможно, сами не докажете.
Ну вот.
Давай.
Почему там плюс QK делить на K, а не E делить на K?
Потому что мы на этот раз каждому пути, то есть раньше мы...
Ну потому что раньше, потому что когда мы писали E делить на K, мы говорили, что каждому пути в этой декомпозиции можно сопоставить там K своих ребер,
K своих ребер, да, которые, в своих смыслах, не пересекаются с другими, поэтому E делить на K.
А тут мы сопоставляем ребра из уже найденного по сочетания.
Почему каждый ребро в сочетании соответствует отдельному...
Но каждая не обязательно, я знаю только то, что каждая удлиняющая цепь соответствует хотя бы K ребер в сочетании.
Да, могут быть ребра, которые не попали, естественно, Боже упаси.
Поэтому так.
