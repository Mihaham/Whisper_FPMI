Мы с вами прошли бинарное дерево поиска. В его стандартном виде, который нас плюс-минус устраивает,
но как бы не очень. Об этом мы поговорим позже. Сегодня мы поговорим о другой структуре данных,
которая называется, именно на этой лекции, о другой структуре данных, которая называется пирамида.
В англоязычных источниках это всегда хиппи. Но вот русские переводят данную структуру еще
иногда как куча, что не является корректным по отношению к данной структуре в принципе. Потому
что куча родилась из всяких языков джава и так далее, где сборщик мусора, и вот там вот тоже его
назвали хиппи такие. Ну это просто куча, так как там просто мусор как бы он собирает. По факту давайте
называть это, ну академически достаточно понятно, это пирамида. Вот поэтому это и будет у нас потом
пирамидальная сортировка, которая у вас есть в задании. Что касается самой пирамида. Пирамида
это некоторый объект массив, который может рассматриваться
как, выключите пожалуйста микрофон, это вы когда что-то кликаете или что-то делаете, то вас слышно.
Вот, который может рассматриваться как почти полное, почти полное, бинарное дерево. Вот, то есть все наши
страдания с бинарным деревом не напрасны, потому что пирамида очень красиво представляется с точки
зрения бинарного дерева. У нее есть главное свойство, как у бинарного дерева поиска было главное
свойство, что все что левее у него ключ меньше, а все что правее у него ключ больше, у пирамида есть
другое свойство, что каждый родитель больше, чем его дети в любом поддереве, в любом месте. То есть
у него следующее свойство, давайте запишем это, свойство пирамиды. Любой узел, для любого узла давайте так, для любого
узла. Верно. Что? Родитель, если мы представляем это как массив, ну давайте так, слишком слабое
ограничение. Все, сори. А для любого узла верно что? Верно следующее, что у нас значение родителя оно
больше либо равно, то есть мы строим пирамиду сейчас по неубуванию, больше либо равно, чем значение
левого ребенка и значение родителя больше либо равно, чем значение правого ребенка. Мы потом перепишем
немного это свойство после некоторых операций, после того мы вообще как поймем как выглядит это
дерево. Надеюсь все записать. Если мы представляем пирамиду, давайте с вами нарисуем какую-нибудь
пирамиду и скажем что это вообще такое. Выглядит она примерно следующее, если я буду брать вершины
и буду ее строить. К примеру, ну давайте возьмем такую вот пирамиду. 8, тут 7, здесь 1, здесь 2, здесь
4, ну а здесь там 9 и 3. Первое, что нужно заметить по этой пирамиде, то что это почти полное бинарное
дерево. Если это почти полное бинарное дерево, то нам нужно в этом случае понимать, что все слои у
этого дерева заполнены полностью, кроме быть может последнего, то есть если у нас нету где-то
вершин в этом бинарном дереве для того чтобы она была полная, нету только некоторых листов,
причем именно слева направо. Это связано с тем, что мы будем строить наше бинарное дерево,
ой нашу пирамиду по факту, из массива и будем использовать по факту массив, но представлять
его в виде вот такой вот структуру данных как бинарное дерево. Если мы хотим записать массиве,
мы будем говорить о том, что у нас индексация. Индексация здесь будет с единички. Мы будем
рассматривать, что первый самый главный элемент у него индекс будет равен единице. У его детей тогда
будет индексы в два раза больше, это будет 2i и 2i плюс 1. Мы сейчас это с вами и запишем. То есть
что мы хотим с вами сделать, чтобы мы могли представить данную структуру в виде массива,
и могли очень легко обращаться ко всем детям и родителям в этой структуре, чтобы это было
удобно для нас. Так как у нас массив работает, ну индексация от единички, то в этом случае мы
как раз-таки можем очень быстро находить всех родителей и всех детей относительно какой-то вершины,
а не работая с указателями, как это было в бинарном дереве поиска. Мы хотим сделать следующее,
чтобы у нас родитель, давайте напишем это прям как функции такие некоторые. Что ж такое? У нас
родитель, то есть от некоторого индекса мы хотим найти индекс родителя. У нас будет функция левого
ребенка от и и некоторая функция правого ребенка. Вообще как пирамида представляется в нашем массиве?
Она представляется следующим видом, на примере это будет гораздо легче показать. Первоначально
записывается само число, которое стоит сверху. Дальше мы идем по факту слева направо. То есть мы
делаем обход следующим образом. Мы по каждому слою идем слева направо, для того чтобы хранить его
в массиве. Тогда в этом случае мы получим с вами вот такую конструкцию в нашем массиве. 8, 7, 9,
3, 2, 4 и 1. Здесь необходимо понять как обращаться по индексам. Если я первоначально говорил,
что мы будем индексировать здесь начиная с единички. Поэтому здесь у нас будет первый индекс,
2, 3, 4, 5, 6, 7, 8, 9, 10. Смотрите, кто является сыновьями для нашего числа 16? Даша Решетникова,
скажи пожалуйста, как ты считаешь? Сыновьями 14 и 10. 14 и 10. И у них индексы какие в нашем массиве?
2 и 3. 2 и 3. По факту здесь если соединить, то это будет выглядеть вот таким вот образом. Если
мы с вами соединим индексы для 14, то у нас будет еще 8 и 7. Для 10 у нас будет 10 и 3. Кто видит
взаимосвязь индексов и наших отношений с точки зрения детей? Вы уже говорили,
что если индекс родителей и, то индексы детей 2 и и 2 и плюс 1. Да, действительно, это именно так.
То есть смотрите, правый ребенок у нас будет равен, 10 это является правым ребенком, и это у нас
будет функция по факту возвращать 2 умножить на и плюс 1. Левый ребенок это у нас будет возвращать
2 умножить на и. А что будет являться родителем для нашего какого-то ребенка? То есть смотрите,
для 10 мы, к примеру, хотим построить отношения. Кто является родителем для этой десятки?
И пополам. Да, то есть здесь достаточно взять обычное целочисленное деление.
В этом вся суть отношения здесь. Мы можем сказать, что у нас есть массив, и по нему мы
можем построить наше дерево, которое нам необходимо. И благодаря этому у нас как раз таки все с вами и
получится. Если вы будете индексировать ваше дерево, то есть иногда его индексируют с нуля,
тогда в этом случае отношения родитель-ребенок и родитель-правый ребенок-левый ребенок немного
другие. Там я напишу сейчас только в этом случае. Дальше типа как перестроить все остальные конструкции,
думаю вы догадаетесь. В этом случае у вас будет что родитель это и-1 пополам, а левый ребенок это
2 на и плюс 1, а правый ребенок будет 2 на и плюс 2. Вот, если индексация у нас с нуля. Вот, если у нас
индексация с единички, то так. То есть нашим корнем дерева является вот этот вот максимальный
элемент. Смотрите, самое классное, что у нас дает эта пирамида, что у нас наверху находится максимальный
элемент от всех, потому что он больше своих детей, а его дети больше, чем их дети и так далее. То есть
с точки зрения вот такой вот рекурсивного рассмотрения у нас 16 больше, чем 14 и больше,
чем 10. 14 больше, чем 8 и больше, чем 7. Ну и так далее. То есть здесь мы понимаем, что на вершине этой
пирамиды стоит самый-самый большой элемент. Естественно эту пирамиду можно перестроить по
минимуму, здесь просто необходимо вести будет другое отношение этих элементов. Вот. Смотрите,
чему будет равна высота в данной пирамиде. Так как мы заполняем по факту здесь все слои,
кроме быть может последнего, то у нас высота, высота, высота h нашего, нашей пирамиды,
она равна тетти от логарифмы. Потому что мы заполняем абсолютно все слои, которые у нас есть,
кроме быть может последнего. То есть мы максимально берем степени двойки. Вот. Поэтому мы всегда
увеличиваем два раза и так далее и получаем, что у нас будет высота пирамиды, это логарифм. Это
свойство нам очень-очень понадобится. Теперь давайте с вами кое-что разберем следующее. Такой
подзаголовок. Давайте так, есть ли вопросы к пирамиде, как она выглядит в принципе, на всякий случай?
Видимо нет. Окей, тогда... Секунду вернуть к определению пирамиды. Да. Спасибо. Вот, подзаголовок
следующий. У меня высота получилась еще раз. Что еще раз? Почему именно так высоту записали?
Неявная формула. Почему? Что подразумевается подъявной формулой? Ну можно взять ограничение,
просто сверху дал логарифм, сверху ограничил, там плюс один сделал.
Ну так же у нас низы сверху ограничивают. Если мы просто округлим вверх, то этого будет
достаточно и все. Вот она будет высота пирамиды. У нас самое большое количество элементов будет,
если будет полная пирамида, то есть полное бинарное дерево. Это по факту сколько? Это степень
двойки минус один, правильно? Верно. Тогда мы должны округлить вверх и плюс единичку добавить,
у нас будет высота. Вот. Окей. Поддержка, свойства, пирамиды. Смотрите.
Когда еще раз мы добавили единицу, вы сказали, что когда мы считаем высоту,
то нужно добавить еще единицу. Посчитайте количество элементов,
сколько у нас в двоичном дереве и сколько у нас будет высота. Просто количество элементов,
степень двойки возьмите, типа по максимуму забейте пирамиду.
Это я поняла. А когда мы именно единицу добавляем?
Еще раз. Попробуйте, посчитайте. Вы поймете. Это вопрос такой. Там сейчас важная симпатическая
сторона, но по факту там будет всегда. Вот. Одержка, свойств нашей пирамиды.
Что касается поддержания, свойств пирамиды. Давайте перепишем наше свойство немного
следующим образом. Для любого узла с индексом И, мы говорим следующее.
Для любого узла с индексом И, мы говорим следующее. Что А от И, А это массив наш,
будет меньше либо равен, чем А от Parent и Parent от Ника. Вот. То есть немножко переформулировали
наше свойство. Чтобы у нас не было два неравенства, мы сделали одно. Вот. Оно достаточно
понятное. Откуда оно выходит тоже понятно. Вот. Это то свойство, которое нам необходимо
поддерживать. Представьте следующее. У нас в пирамиде могут меняться элементы. Каким-то
образом. Пусть у меня будет следующее. Вот у меня была та пирамида, но она немножко другого вида
сейчас будет. 16 там. И, к примеру, на место 14 будет здесь 4, здесь будет 10, здесь будет 7, 14,
2, 8, 1, здесь 9, там и 3. Вот. А для поддержания свойств пирамиды эта четверка должна пойти куда?
Ниже или выше? Как вы считаете? Ниже. Ниже. Ниже. Потому что ее действие меньше. Но для того,
чтобы эта пирамида сохраняла свое свойство, должен на ее место встать какой из детей? Левый
или правый? Ну можно и левый. Самый большой. Ну типа если мы поставим левый элемент, то мы
должны будем второй раз это же свойство применить. Ну а если правый элемент ставим, то один раз
если мы поменяем, то есть 4,7, то пирамида уже... А нет, наоборот, левый должен встать в место
самый большой элемент. Да. То есть смотрите, должен встанавливаться на это место самый большой
элемент. Если мы будем вставить любой из элементов, то возможно нам необходимо повторять
операцию, а по факту мы просто поменяем и поставим опять самый большой. Поэтому в этом плане нам
необходимо сделать следующее. Нам необходимо, это называется просеиванием вниз, нам необходимо
просеять вниз элемент 4, который у нас с вами не на своем месте. Здесь мы получим вот так, вот так.
Так как 4 просеялось вниз и поменялось местами с 14, то 4 окажется вот здесь. Здесь окажется 7,
то есть оно останется на своем месте. 1, здесь 8, здесь 2. То есть мы должны выбрать максимум из
правого и левого по дереву от четверки, ну корней. Мы должны выбрать максимум из правого и левого
ребенка, да. Вот. И с ним поменять местами. Потому что в таком случае мы сохраним наше свойство для
всего нашего дерева, для всей нашей пирамиды. Так как у нас будет самый большой элемент наверху,
то он будет явно больше и другого сына тоже, помимо самого родителя, который был родителем. Сейчас
мы с вами это поменяли. И теперь нам необходимо взять и еще раз просеять этот элемент. То есть,
смотрите, я в начале просею вот эту четверку, потом у меня четверка оказалась здесь. Мне необходимо
проверить, а может ли она спуститься еще ниже, потому что мало ли, свойство наше не выполняется.
Тогда в этом случае, ну мы видим, что оно не выполняется, потому что 4 меньше 8. Нам необходимо
взять и просеять элемент еще ниже. И получить следующую пирамиду. 16, 14, 10. Здесь 4 поменяется
местами с восьмеркой. Здесь будет 2, здесь будет 4, здесь 7 и 1, здесь 9 и 3. Вот. То есть,
вот после таких итераций, как только 4 у меня дошло до низа, мы можем остановиться. Либо мы можем
остановиться, если у нас все сыновья меньше, чем это само, само, сам этот элемент в нашем дереве,
нашей этой пирамиде. Поэтому важно здесь научиться как раз-таки просеивать вниз. И вот то,
что мы сейчас сделали, это и называется просеиванием вниз. Вот. Давайте с вами запишем код этого
просеивания. Есть ли вопрос, как оно вообще в принципе выглядит? И почему мы его должны делать?
Есть вопрос, когда мы его делаем? Когда вводим число новое или когда? Там функция change есть,
типа поменять значение. Смотрите, мы с вами его делаем в случае либо изменения элемента,
либо по факту изменения элемента. Да. Потому что добавление мы будем делать немного по-другому.
Понятно? Вот. Мы именно просеиваем вниз. В случае, если у нас как-то изменилось наше число в нашей
пирамиде, нам необходимо его просеять вниз. У нас нарушилось правило, нарушилось свойство
самой пирамиды. Поэтому нам необходимо взять его и поменять места. Вот. Ну грубо говоря,
типа для того, чтобы представить, что такое просеивание вниз, представьте следующее. Вот был
какой-нибудь очень богатый человек, вот там Илон Маск был. Вот. Он написал что-то в Твиттере,
можно ли я продам 10% своих акций? Акции рухнули. И вот все, вот как бы денег у него стало меньше.
И с точки зрения рейтинга там Forbes, например, он должен был бы просеяться вниз, но у него все
еще много денег. Вот как бы оно иногда надо, но иногда и не надо. Нам необходимо будет проверить,
сохранено ли свойство. Если не сохранено, то мы должны просеять вниз. То есть рейтинг немножко
там упадет, к примеру, с точки зрения количества его денег, которое там оценивается миллиардами.
Вот. А если там кто-то банкротился, ну или что-нибудь такое, то есть здесь с точки зрения того,
что у нас видо изменилось что-то в самой пирамиде. Если оно уменьшилось, именно уменьшилось,
то нам необходимо будет просеивать вниз. Вот. Давайте с вами напишем этот код. Просеивание вниз,
функция называется shift, shift down, то есть просеять вниз. Мы сюда с вами передаем наш массив A,
в котором построена наша пирамида и в котором есть все наши элементы. Индекс того самого
видоизмененного элемента, который мог уменьшиться, к примеру. И быть может,
ну точнее не быть может, если вы будете реализовывать, нам необходим еще вообще
размер массива сам по себе. Вот. То есть, ну я думаю, вы поняли, где что. Окей. А как мы это делаем?
Мы говорим, что у этого элемента есть левый ребенок и правый ребенок. Давайте его посчитаем.
Левый равен, ну мы будем, я буду здесь использовать функцию в зависимости от того,
как вы будете реализовывать. Лев чайл там от и. Правый ребенок у нас равен правый ребенок.
Правый ребенок действительно, левый это 2 и, правый это 2 и плюс 1. Действительность и так.
Правый ребенок тоже у нас задан. Теперь нам необходимо сказать, пусть у нас самый
большой элемент первоначально равен и. Нам необходимо найти элементы равные.
Дальше я сравниваю, если у нас левая граница меньше либо равна, чем size, это очень важно,
и а от левт больше, чем а от и, то есть больше, чем наш элемент, то в этом случае я говорю,
что наибольший элемент, точнее наибольший индекс, где хранится, индекс, где хранится
наибольший элемент, а равен левому ребенку. Важный вопрос, скажите мне,
если я поменяю эти два условия местами, будет ли работать корректно моя программа?
Нет. Сергей Александрович, а можно вопрос,
может быть не от и, а от largest? Ой, да, ну здесь без разницы, конечно,
но да, чтобы у нас был одинаковый формат. Возможно выход за пределы массива.
Да, а благодаря чему вот здесь не будет выхода, как мы и написали?
Потому что вначале проявляется левт меньше либо равна.
Короткая логика.
Короткая логика, благодаря короткой логике вот здесь вот мы можем так писать,
иначе нам нужно было бы делать вложенные ифы. Это важно понимать.
Вот, окей, да, действительно здесь largest лучше писать, наибольший элемент.
Дальше нам необходимо еще проверить с правым элементом, что если у нас правый,
меньше либо равен, чем size, а от правого элемента больше.
Еще меньше равно, потому что нумерация соединится, да?
Да, если бы у нас была нумерация с нуля, то было бы просто меньше.
Спасибо.
Вот, и здесь больше, чем наш наибольший элемент. Мы не знаем какой там индекс,
может быть и, может быть, и left. Ну, то есть это поиск просто индекса максимального элемента,
максимальный индекс. Вот, то в этом случае мы говорим, что наибольший равен правому.
После этого мы по факту с вами определили, где находится наибольший элемент. Это либо
наш родитель, либо один из детей. Если это у нас с вами не является родителем, то есть,
точнее давайте так, если это родитель, то мы должны остановить наше просеивание вниз.
Ну, то есть если у нас наибольший элемент является родителем, мы свойства пирамиды
удовлетворили, мы его сделали. Все круто классно, поэтому давайте с вами скажем следующее,
что да, действительно у нас наибольший элемент, тогда если и, то мы останавливаемся. А вот,
если он не равен и, то в этом случае мы должны поменять местами наше аи т и а наибольшее,
после чего мы должны еще раз просеять наш элемент вниз, то есть написать своп, ой своп,
сивдалм, извините, сивдалм, вот а. Теперь смотрите, так как мы поменяли местами аи т и а л, то есть
наибольший элемент, то теперь у нас вот этот вот и-то элемент, который был, он теперь находится
в массиве под индексом наибольшего, поэтому мы должны сивдалм, даун, а, наибольший и все так же сайз.
Вопрос, а мы разве не должны писать, что левт и райт строго меньше сайза?
Еще раз, если у нас индексация с единицы, мы же индексацию с единицы с вами сначала приняли,
то в этом случае у нас именно меньше либо равно, если у нас индексация с нуля, вы приняли так,
что там будет меньше. Именно поэтому я пишу левт чайлд и райт чайлд, потому что все зависит от
реализации, то как вы хотите. В данном случае я подразумеваю следующее, что это 2 умножить на и и
2 умножить на и плюс 1. Вот, вы можете реализовать и так, и так, здесь уже ваше право, как вам удобно.
Это понятно? Если вопросы к просеиванию... Можете, пожалуйста, еще раз повторить с момента,
еще раз, нам необходимо просеять наши элементы, просеять наш элемент, вот эту четверку. Эту четверку
мы должны поставить на место 14, а 14 на место четверки. Тогда мы должны взять и поменять их
местами. Я их меняю местами. Да, спасибо. После чего я должен еще раз просеять свою четверку.
Да, спасибо, поняла. А что значит в зависимости от того, как мы реализуем, если массивы с нуля
нумеруются? Вы можете просто не трогать нулевой элемент. Спасибо, понимаю. Просто выделить там
n плюс 1 память, например. В этом нет никакой проблемы. А вот еще такой вопрос. Разве перед вторым
ифом не нужно else описать? Зачем? У нас первый иф может выполниться, а потом... А потом второй
выполнится, да. Но представьте следующее, что у меня вот здесь вот был бы не 14, а 7,14. Я пришел в
левого ребенка. Хорошо, спасибо. А мне нужно все наибольшее. Мне нужно найти наибольшее среди трех
чисел. Поэтому здесь так. Еще вопросы? Если мы будем реализовывать ifLargest равно равно и. Нельзя
взять просто ifLargest равно равно и, тогда return, ну, потом swap it, aLargest, shift down, aLargest size.
В том принципиальная разница. Ну, вы добавили один return. С return не будет работать программа быстрее.
А какая разница-то? Вот вы в конце напишете здесь return, например. Я так понимаю, вы наоборот
хотите return записать if и тут написать ifLargest равно if. Ну да. А какая разница? У вас все равно
сравнение произойдет. Еще вопросы? Нету. Получается нигде вот индекс элементов
там просто вот, если конкретно говорить о задаче, там было еще, что мы сохраняли номер,
под которым он ввелся. Это вам нужно понять, как реализовать. Это нужно вам понять,
как реализовать просто. Окей. Давайте оценим время работы нашего ifDown. Смотрите, когда я
делаю просеивание вниз, я могу рекуррентно кое-что обнаружить. Представьте следующее. У меня вот
есть элемент, и вот здесь вот у меня тоже есть элементы, и я вот делаю просеивание вниз вот
этого вот, вот этой вот штуки. Так как я делаю просеивание вниз, у меня здесь тоже может быть
что-то, к примеру, и так далее. Вопрос. Как связано время работы с временем работы,
если я просеял влево? Кто-нибудь представляет или нет? На каждом шагу вы будете сравнивать
элемент с двумя оставшимися, ну с его двумя детьми. Время работы не будет, два log n, то есть log n в итоге.
Смотрите, вот я хочу рекурсивно это сделать чуть-чуть по-другому. Смотрите, когда я делаю
просеивание вниз, само просеивание вниз работает за это от единицы, правильно? Ну потому что у меня
в нем ничего не делается, что-то кроме рекурсии, быть может, правильно? Все остальное за вот единички
работает. Здесь не поиска, нет ничего. Это вот как раз таки оценка. А вот в какое дерево оно может
пойти? Сколько там может быть элементов? Я утверждаю, что в этом другом дереве не больше,
чем 2n делить на три элемента. Почему это так? Ну то есть у меня первоначально было n элементов,
стало это 2n на 3. Потому что один кусок нашей пирамиды может быть полный, а другой не полный,
вот как, к примеру, здесь. У нас слева находятся вот листья, у нас вот этими являются, а здесь
всего лишь один элемент, у него нет детей. Если мы продолжим эту аналогию, так как у нас заполняется
все по слоям, то мы можем здесь вести еще два ребенка, а вот у этих тоже есть подвое детей,
а вот у этих нету, к примеру. И так далее. То есть так или иначе мы будем говорить о том,
что в каждом вот в левом по дереве меньше либо равно, чем 2n делить на три элемента.
Меньше либо равно. Здесь тоже меньше либо равно, чем 2n делить на три. Вообще здесь меньше,
чем n пополам. То есть можно написать как n пополам. Вот. Почему так? Потому что у нас,
если у нас здесь есть дети, вот такие, то в левом по дереве у нас тоже обязательно есть дети.
А вот для правого, если там, к примеру, нет детей, в левом может быть, а может и не быть. И вот этот
вот слой, если мы просто возьмем и оценим, то суммарно здесь будет не больше 2n на три элемента.
То есть мы все время уменьшаемся на две трети. Вот каждый шаг у нас уменьшает на две трети. А это
по факту основание логарифма. И тогда в этом случае у нас работа равна о большое от логарифма.
Так как мы постоянно уменьшаем количество на три вторых в полтора раза, то мы можем говорить о том,
что у нас работает севердаун за логарифм. Вот и все. Можете повторить, пожалуйста,
откуда две трети взялось? Взялось две трети. Смотрите, предположим, у нас было здесь n элементов.
Вот здесь вот. Вот мы верхний делаем севердаун, и здесь у нас n элементов. Худший случай, это когда
он пойдет в левое под дерево, оно будет полное, полное как бинарное такое под дерево. Видите,
у него все листы есть, все заполнено по максимуму. А в правом не будет ничего.
Тогда у нас будет как здесь выглядеть. Вот здесь вот. Вот эти два слоя будут одинаковы по количеству
элементов. И единственный слой, на котором у нас будут различия, это нижний слой. Правильно?
Смотрите, так уж получается, что вот здесь вот количество листов на один больше,
чем количество элементов здесь. Просто в силу дерева бинарного. И тогда получается,
если мы возьмем и скажем, что это n, это тоже n, это тоже n. Но я так утрированно сейчас взял.
Там надо просто плюс-минус единички сделать еще, на самом деле. Вот. Если здесь мы возьмем
n-3-минус единицы, к примеру. Тогда в этом случае здесь у нас ограничение 2n-3. Все.
А почему не можем сказать, что мы просто в худшем случае пройдем всю высоту дерева
и этого грифа тоже самое? Можно так. Я просто решил по-другому. В худшем случае,
действительно, мы пройдем всю высоту дерева. Высота дерева у нас, у грифа. Мы это тоже уже
сказали. Вот. Это то, что касается этого момента. Смотрите. Есть ли еще вопросы к сейвдауну?
Да, можно вопрос еще? Получается, откуда взялось... Ну, вот вы сейчас объясняли про две третьи. Тут же
про одну треть понятно, а две третьи почему? Ну, 1 треть сверху, 1 треть снизу, 1 треть справа. А тогда
почему справа меньше либо равняется, чем n пополам, а не n на 3? Потому что у нас может быть
такой случай, что здесь заполнено абсолютно все. Тогда в этом случае эти два поддерева равны.
Так, хорошо. Давайте двигаться дальше. Теперь, что касается другого момента. Представьте,
что нам необходимо. Мы изменили элемент, но он стал больше. То есть мы его не уменьшили,
а увеличили. Ну, кто-то там, не знаю, купил золотые акции типа Apple, вот они подорожали,
iPhone 13 вышел. Все рады, все довольны. Поэтому там увеличивается стоимость. Ну, или кто там
лотерею, например. В этом случае нам необходимо сделать так называемое просеивание вверх. Давайте
с вами это тоже нарисуем и поймем, как это делать. Это делать еще легче. Вот у меня было 16, а здесь
там 14, здесь 10, здесь там 8, 7, здесь 2, 4. И вот здесь вот я сделаю 15. Не один, а 15 стал.
К примеру, здесь 9 и 3. Мне необходимо этот элемент просеять вниз. То есть он увеличил свое состояние,
он увеличился. Тогда мне необходимо просеять его вверх. То есть мне нужно просто сравнить его
с родителем. Если вдруг его родитель меньше, то поставить его на свое место. Почему это работает
корректно тоже? Потому что если здесь, так как мы изменили всего один элемент, мы говорим о том,
что по факту почти во всей пирамиде сохранено наше свойство. А если оно сохранено, то даже
если у него есть какой-то еще ребенок, то родитель больше этого другого ребенка, но меньше,
чем этот. Значит, если мы поставим элемент больший, то свойство все равно сохраняется.
То, что мы хотим получить из этого, мы получаем следующее. 16, 14 после первой
итерации просеивания вверх. 16, 14, здесь 8, здесь у нас уже будет 15, здесь 2, 4, а 7 мы просеяли,
то есть они поменялись местами. Здесь там 9 и 3. Теперь нам необходимо 15 еще раз просеять вверх,
потому что не факт, что оно встало на свое место. И действительно 14 будет меньше 15. Поэтому мы
должны его взять и просеять еще раз вверх. Поэтому в этом случае мы с вами получим 16,
15, 10, тут 9, тут 3, тут 8, тут 14, тут 7, здесь 4 и 2. Очень важные свойства пирамиды. Не забывайте,
главное, что вот если оно заполняется, то оно заполняется слева направо. Вот таким вот образом
мы с вами взяли и получили. Сифтап работает еще легче, он пишется еще круче.
А если бы мы не 15 двигали, а 18, например? 18 где? Ну как вот, вместо 15 мы бы двигали
18. Тогда бы оно поменялось с корнем. И все. Да. А вот оно и сохранилось.
Конечно, потому что корень, смотрите еще раз, корень, представьте, здесь было бы 18. Давайте
я сейчас нарисую. Здесь было 15. А я вот сделаю 18. Ну вот я напишу зелененьким, чтобы вы не путались.
А 18 больше 16. Но так как я менял всего один элемент, я знаю, что вот эта десятка меньше 16,
тоже правильно? Если она меньше 16, то она меньше и 18. Поэтому если я поменяю местами,
у меня ничего не произойдет. Понятно, спасибо. Как работает вообще сифтап? Сифтап.
Просеивание вверх. Мы также передаем А, индекс И, который мы просеиваем. И здесь нам,
в принципе, размер массива уже не нужен. Почему не нужен? А потому что, ну, а зачем он нам нужен
здесь, в принципе? Мы же идем вверх, а вверх — это в начало массива. И мы говорим следующее,
что у меня родитель равен родителю. После чего, если у меня И больше либо равно одному,
и А от Parent меньше, чем А от И, то есть не выполняется это свойство, что родитель должен
быть больше либо равен, то в этом случае мы просто запускаем сифтап. Мы делаем свап.
После чего мы делаем еще один сифтап. То есть мы еще раз просеиваем сифтап от А и Parent.
Все. Это весь сифтап. Ой-ой. Случайно я нарисовал эту линию. А эта реализация на нулевой индексации
или на единичной? На единичной и на нулевой. Если на единичной, то когда мы дошли до самого
вверх, мы все равно будем проверять. Это правда. В этом случае — да. Хорошо. Больше единицы. Нет
смысла проверять вверх. Для нулевой будет больше либо равно? Можно вопрос задать? Да. Не
легче сделать вайлом, то есть вместо рекурсивной функции вайлу? Можно сделать вайлом, пожалуйста.
А что будет быстрее работать? И то, и то за логен? Оно все работает за логен,
просто рекурсия не забивает стек. Можно сделать вайлом, пожалуйста. Просто так выглядит понятнее
с точки зрения того, что если у нас есть, мы еще можем просеять вверх, мы просеиваем вверх.
В случае того, когда мы поменяли местами наш элемент, мы просеиваем вверх. Вот это все просеивание
вверх. Работает оно тоже естественно за УАТАЖ. Можно еще вопрос? Да. А если бы в изначальном
дереве, там где 8 стояло 9, а там где 15-8, то получается, если бы поменяли 8 и 7 сначала местами,
получилось бы, что слева стоит 9, а справа 8. И от этого не ломается все? Сейчас еще раз. Если
бы изначально на месте восьмерки стояло 9, а там где 15 стояло 8. Так у меня бы 8 не просеялось бы выше
14. 14-то больше. Ничего бы не просеялось. 8 бы встало на место семерки и все. А это разве
не будет неправильно, что слева стоит 9 больше 8? Это не дерево. Это не бинарное дерево поиска.
Еще раз, давайте так. Это пирамида. У пирамиды главное, что родитель больше его детей. И все.
Просто больше. Неважно, где какое больше, справа или слева. Здесь без разницы. Понятно? То есть не
соединяйте пока пирамиду и бинарное дерево поиска. Вы потом это будете сделать, видимо, в следующем
семестре. Поймете, что это вообще такое будет. Сифтап работает таким вот образом. Тоже
достаточно понятная структура. Есть ли к ней какие-то вопросы? Видимо, нет. Хорошо. Теперь,
что касается построения пирамиды. Как вы думаете, за сколько можно построить пирамиду? Давайте,
ваше предположение. За линию. За ООТН, по-моему. За ООТН, так. На Энлоген, наверное. Так,
смотрите. Ну, за КУПА это что-то странное, учитывая, что у нас есть сифтапы просто, которые мы можем
поднимать элементы. И все. Откуда КУПА возьмется, я не понял. Что касается построения пирамиды.
В действительности, у нее есть построение за ООТН. Мы с вами это докажем сейчас. Первоначально,
по виду, будет казаться, что это не за ООТН, а за Энлоген. Мы с вами это докажем. Смотрите,
давайте сделайте себе подзаголовок. Построение пирамиды. Что касается этого момента. Код здесь
достаточно простой. Смотрите. Начиная с Н пополам, если я возьму свой массив. Вот у меня был массив.
16, 14, 10, 8, 7, 9, 3, 2, 4 и 1. Здесь немножко слиплись. 4 и 1. Я утверждаю следующее.
Н пополам элементов. Начиная с Н пополам. То есть у меня здесь сколько? 1, 2, 3, 4, 5, 6, 7, 8,
9, 10. Начиная с шестого элемента. Все является листьями. Начиная вот отсюда.
То есть вы взяли ближайшую сумму арифметической прогрессии с шагом 1. Что еще раз? Вы взяли
ближайшую сумму арифметической прогрессии, где А1 равно 1 и разность равно 1. На ближайшую
сумму это 6 и вычлые из 10 и 6. Я понял. Там не арифметическая прогрессия. Там в степени
двойки. Это именно так и делается. Это правда. В действительности это именно так и происходит.
Это утверждение корректно, что у нас Н пополам последних элементов. Начиная с Н пополам плюс 1.
Последних элементов являются листьями. Исходя из этого, можно кое-что получить. Мы с вами
давайте построим пирамиду. Исходя из этого утверждения. Строение пирамиды. На основе
уже какого-то массива, не отсортированного с точки зрения пирамиды. Ничего. По массиву А размером
там size. Мы говорим следующее, что for и равное от size пополам. Может кто-то из вас помнит такое.
То есть просто по минус единички мы все время вычитаем shift down. А и size. Там, наверное, просто и size пополам.
Вы просто и присваиваете. Тогда в этом случае мы с вами получаем построенную пирамиду.
Почему? Давайте сначала ответим почему. Для того, чтобы доказать корректность, мы скажем следующее.
У нас сохраняется следующий инвариант. Мы говорим, что инвариант нашего алгоритма следующий. В начале
каждой итерации цикла for. Узлы и плюс один и плюс два и так далее до
size. Являются корнями не возрастающей пирамиды.
Вот почему этот вариант сохраняется. Инвариант сохраняется следующим образом.
Первоначально мы говорим о том, что все начиная с size пополам плюс один у нас все является листьями.
Лист сам по себе, то есть одна вершинка является невозрастающей пирамидой. Ну из одного элемента.
Логично. Когда мы с вами запускаем сивдаун, на каждом шаге мы запускаем сивдаун этого цикла,
то есть мы начинаем просеивание. Грубо говоря, мы добавляем один элемент, он может быть больше,
может быть меньше, но мы берем и просеиваем, потому что это корень. Если это корень,
то мы можем просеять только вниз. А когда мы начинаем просеивать вниз, добавляя всего один
элемент в нашу пирамиду, мы восстанавливаем наше свойство, свойство пирамиды, то есть мы его
поддерживаем. Благодаря этому мы говорим о том, что у нас этот вариант сохраняется. Если он
сохраняется, то в конце, когда мы закончим наш цикл, у нас пирамида будет для все, все индексы
будут являться корнями невозрастающей пирамиды, в том числе для индекса равного один, для нашего
корня. Таким образом мы говорим о том, что мы получили пирамиду. Вот и все. Понятна логика
рассуждений? За линию работает, почему сейчас разберемся. Вы сейчас говорили, что у нас пирамида
по неубыванию или по невозрастанию? По неубыванию.
Сейчас. Мы отсекаем скажем половину. По невозрастанию, извините, по невозрастанию.
То есть вниз у нас идут элементы меньше. Еще раз, да, какой вопрос был?
Или не было вопросов? Что касается простой оценки данного алгоритма, простая оценка, давайте.
Простая оценка данного алгоритма следующая. Мы говорим о том, что севдаун работает за логарифт,
мы делаем n пополам раз, тогда работает алгоритм за o от n лога. Это неправда. Почему? По следующей причине.
Смотрите. Ведем с вами понятие высоты узла. Что такое высота узла? Высота узла. В пирамиде.
Это число ребер. Число ребер. В самом, самом длинном, простом пути,
нисходящим пути, давайте, нисходящим, нисходящим пути от узла в каком-то из листях.
Вот, то есть мы говорим о том, что это просто количество ребер до какого-то узла нисходящего.
Тогда из этого мы можем сказать следующее, так как мы знаем такой вот факт. У нас высота равна по
факту. А, так как мы говорим о том, что это число ребер, то это будет вот так. Логарифт двоичный от n.
Так как это число ребер. Вот. Смотрите, высоту просто периодически объявляют как число ребер или
количество вершин, в зависимости от этого плюс-минус единичка. Я думаю, вы это знаете. Вот. Ну,
то есть здесь все зависит от того, каково было определение первоначально. Вот. Высота у нас такая.
Утверждение следующее. Утверждение на любом, на любом уровне, на высоте.
Аш содержится не более
n на 2h плюс один элементов.
Это степень аж плюс один? Да, это степень аж плюс один. Два в степени аж плюс один.
Почему это утверждение верно? Это утверждение верно в силу просто построения дерева. Так как у
нас есть максимальный, ну, мы говорим о том, что у нас есть там максимальный,
прошу прощения, у нас есть, мы заполняем когда дерево, мы получаем почти полное бинарное дерево,
заполняем его слева направо. Если мы его заполняем слева направо, то у нас высота как бы отличается
у всех элементов на плюс-минус единичку. Вот. То есть там у некоторых там высота,
к примеру, на одном уровне, а один у других ноль. Ну, например. Вот. И в зависимости от этого мы
можем что-то считать. Но так как от каждого листа мы строим с вами какую-то одну новую вершину,
то в этом случае мы говорим о том, что на некоторой высоте, на некоторой высоте находится вот такое
количество узлов. Давайте еще раз. Почему так? Вот, для примера, для листьев. Для листьев мы говорили
не более n пополам узлов. Мы это получили с вами. Если мы подставим h равной нулю, мы получим с
вами n пополам узлов. Для каждого из листьев вверх идет, для двух листьев есть одна вершина сверху.
То есть мы уменьшаем еще в два раза это количество. Поэтому у нас получается n делить на 4.
Для каждого из этих полученных вершин мы говорим о том, что там еще в два раза уменьшается,
потому что для каждых двух вершин вверх идет одна вершина, один узел, и у него высота увеличивается
на единицу. Там уже будет n на 8, потому что n на 4 разделить на 2 и так далее. То есть рассуждения
здесь именно такие. Поэтому мы говорим о том, что у нас на любом уровне на высоте h содержится
не более чем n делить на 2 h плюс 1 узлов. Тогда, в этом случае давайте посчитаем количество наших
действий. Сколько у нас будет работать там сифтап? Ну вот все вот это вот вместе. Мы знаем, что сифтап
работает за o от h. Ой, сифтап, извините, сифтап работает за o от h. Поэтому, суммарное время,
суммарное время t равно сумме от h равного нуля до нашей максимальной высоты, это логарифм двоечный,
от n, n делить на 2 h плюс 1. И работа самого сифтап, сифтдауна от h. А почему у нас сумма
идет по n и логарифм тоже от n? Это h. А, хорошо. h. Это, а здесь логарифм от n. Ну высота от нуля до
логарифма. Хорошо? Вот здесь вот у меня тоже h. Вот, я могу внести в o вот эту вот всю сумму. Тогда
я получу с вами o. Вот, давайте одну двоечку я вынесу за сумму. Я получу n пополам, потому что n не
входит в сумму мою в принципе. Логарифм там всегда определен по факту. Вот. Сумма от h делить на 2 в
степени h. От h равного нуля до логарифма. Вот. В силу разложения рядов я могу вам сказать следующее,
что может быть кто-то из вас знает, что x делить на 2 в степени x в бесконечности от x равного нуля,
то по факту будет 2. Сумма бесконечного ряда. Вот. Если более подробно, то это считается как 1
вторая. Там есть по факту формула для этого всего. 1 вторая на 1 минус 1 вторая в квадрате.
Вот. Поэтому здесь мы говорим о том, что это o от n пополам умножить на 2.
Именно поэтому такое построение работает за o от n.
Так как мы асимпатически смотрим, вот этот логарифм, логарифм от n, он у нас стремится
к бесконечности. Поэтому мы сумму ограничиваем бесконечностью сверху. Понятно? Давайте тут
каши написано. Сумма здесь. Логарифм двоичный от n. Вот. Таким образом мы получили, что мы
построим нашу пирамиду за o от n. Есть ли к этому вопроса? Откуда n пополам отдельную
сумму? Смотрите, у нас было в сумме n. n делится 2h плюс 1. То есть количество узлов на такой
высоте. Правильно? n я выношу за сумму. Вот. И двоечку одну выношу за сумму. Все. Вопросы?
Здесь мы будем поднимать элемент. Получается, за n лог n работает? Да. Ну, там, если не ошибаюсь,
то да, по-моему, да. Можно вопрос? То есть вы вынесли n и заменили на h? Нет. Где я заменил на h?
Что я заменил на h? Это n тоже? Или это все-таки h? Еще раз, вот это o от h. Я внес под o. Я внес h умножить на эту
сумму. Значит, я h могу под сумму внести по факту. Поэтому o от h у меня оставил под суммой. Ну, o от h это
выполнение нашего издауна. Вот. Поэтому я внес. Высоту заглавной писать? Ну, давайте я здесь исправлю,
для того чтобы, да, вы не запутались. h. h. h. h. Здесь у меня h. Большое. Ну, то есть те, у кого маленькое,
и вы поняли, где что находится. Смотрите. Здесь у меня тоже h. Вот здесь вот у меня h. Все. Ну,
вот здесь вот у меня h. Понятно стало, почему за o от n? Спасибо. Вот. Извините, пожалуйста,
можно вопрос про сифтап? Да. Он же за o от log n работает, а не за n log n? За log n, да. За log n,
спасибо. N log n имелось в виду построение сифтапов. А, спасибо большое. Извините, у вас там написано
высота узла в пирамиде. Это число ребер в самом длинном простом нисходящем пути от узла какого-то
из листьев. Да. А почему, можете объяснить, почему формула тогда высоты h log n? Ну, h равно log n.
Ну, давайте нарисуем. Я думал, это будет понятно. Ну, высота вот этого узла чему равно? Одному,
правильно? Здесь n имеется в виду количество узлов, которые находятся под этим узлом?
Да, если мы считаем, что этот узел у корень. А, все. Так, стало понятно. Еще вопросы есть?
Как сделать быстрее, чем построение за линию? Быстрее, чем построение за линию нет. Но оно
не понадобится, потому что нам необходимо кое-что сделать еще. В приоритетной очереди не
заходит за линию. Я перепроверю. А, ладно. Что касается, давайте теперь последнее,
что нам осталось взять от пирамиды. Я перепроверю насчет приоритетной очереди,
что касается пирамиды. Последнее, что нам осталось, это алгоритм сортировки.
Давайте сделаем следующее. У меня с вами была пирамида. Здесь вот было 16, там 14. Предположим,
она у меня построена. 10, здесь 8, здесь 7, здесь 1, здесь 2, здесь 4, здесь 9, здесь 3. У меня есть
вот такая пирамида. Я хочу отсортировать этот массив данных. У меня же это как массив,
представляется. Давайте я запишу еще массив. 16, 14, 10, 8, 7, 9, 3, 2, 4 и 1. Для того,
чтобы отсортировать массив, у меня сверху лежит элемент наибольший. Я хочу отсортировать по минимуму.
Давайте я с вами сделаю просто следующее. Поменяю местами 6 и самый последний элемент,
который находится внизу. 16 точнее. Я вот сюда поставлю 16. Сюда поставлю 16, сюда 1 и сделаю
То есть я вначале получу с вами 1. Дальше у меня все останется на своих местах будет 1,
14, 10, 8, 7, 9, 3, 2, 4. А здесь 16 и я, грубо говоря, уменьшаю размер своего дерева. Вот
этой пирамиды уменьшаю. То есть я нарушаю вот эту связь. У меня здесь будет просто 16,
как чиселка валяться. Мне нужно еще и сайс уменьшать. 1 я выбрал как самый последний элемент.
У меня вот здесь 0 может быть. Просто еще раз. Я, грубо говоря, уменьшаю свою пирамиду на 1,
вот этот элемент больше не входит в пирамиду. Оставлю наверх пирамиды просто любой элемент,
лучше маленький, ну просто минимальный, потому что я в конец 16 запихал, я просто своп сделал
между собой элементы. Когда я его сделал между собой этот своп, то в этом случае я говорю о том,
что у меня на 1 элемент, то есть, грубо говоря, верхний, он уменьшился, точно уменьшился. А значит,
для того чтобы поставить его на свое место, мне нужно будет делать всего лишь сивдаун. Один же
элемент уменьшился, один. Для поддержания свойства пирамиды мне будет достаточно делать сивдаун.
Понятно? Таким образом, мы с вами получим 16 в конце, потом мы уменьшим единицу и поставим
ее на свое место. Единица встанет 14, 8 сюда, единица встанет вот сюда. Вот. И дальше,
мы когда так сделали, наверху окажется 14, и в конец я помещу 14. И вот эту единицу,
грубо говоря, опять запихаю наверх. Ну просто так вышло, что единица здесь у меня, вот именно
здесь она будет. Так уж получилось. И так далее. То есть, я в конец буду записывать все элементы
меньше. И вот у меня будет 14, 16, 10, потом у меня будет следующий элемент, самый наибольший будет
9 в оставшейся пирамиде, потом 8, потом 7 и так далее. Благодаря этому мы с вами и получим нашу
сортировку. То есть, что касается сортировки, она выглядит тоже очень-очень просто.
Как мне будет посмотреть, как будет выглядеть пирамида в конце?
Никак. Как один элемент единицы?
Как один элемент единицы, да. То есть, это все, что там будет. Ну, то есть, это не пирамида по факту.
А, все понятно. То есть, мы нарушаем связи. Как только мы здесь убрали
элемент, мы тоже его нарушили, связь здесь. Да, какой вопрос?
Тут не будет работать сортировка слияния, если мы возьмем как массив 2, 8, 14, 16, 4, 8, 14, 16.
Получается 1, 7, 14, 16, 9, 10, 16 и 3, 10, 16. Если мы просто будем сортировку слияния применять.
2, 8, 14, 16. Потом 4, 8, 14, 16. Мы сделали
сортировку слиянием, получили массив. 3, 8, 2 раза повторяется, 14 повторяется, 2 раза.
Ну, а никак нельзя реализовать в плане тут слияния?
Я, к сожалению, такого не знаю. Понял, спасибо.
Что касается самого алгоритма сортировки, типа именно HipSort.
Просто HipSort, HipSort, который передается наш массив A и размер.
Вот, что делается? Делается следующее, что у нас строится пирамида BuildHip,
у нас BuildHip работает, то есть от A и size. После чего мы делаем следующее,
4 и равное сразу down to A2. Мы делаем swap от A1 и A2.
Уменьшаем размер нашего массива, то есть размер нашей пирамиды по факту.
И shift down от A1. Все. То есть мы каждый раз просто меняем элементы с последним,
забываем про последний, уменьшаем размер нашей пирамиды и делаем shift down.
Конец. Ой, ну у нас shift down там еще size передавался, извините.
Ну, это за сколько работает? Это же дольше, чем за nLogin.
Почему?
Нет.
За сколько работает Build? Давайте оценим с вами. Build работает за O от n, да?
Да.
Shift down работает на O от логарика n.
Блин, красиво.
А вот for здесь, ну это O от n, грубо говоря. То есть O от n умножить на log n.
Получается, сортировка работает за O от n log n. Вот так вот работает пирамидальная сортовка.
Можно еще раз, как мы выбираем следующее. Вот мы выбрали какой-то, ну, в примере с графом,
в примере с деревом мы выбрали единичку. Затем, когда мы поменяли, сделали shift down,
как мы выбираем следующее?
Следующий тоже самый последний элемент в нашей пирамиде.
Получается 7. Ой, 4.
Нет, нет, не 4. Мы сначала единицу должны про shift down. Так уж получится здесь,
что когда мы единицу будем shift down, она перейдет сначала сюда, 14 встанет на верхнее место.
Потом пятерка встанет, а единица сюда встанет, а четверка сюда.
То есть мы опять единицу кидаем наверху.
Так уж получилось, но это не всегда так работает. Если бы здесь была единица, а пятерка, например.
А то она где-нибудь застряла и нам пришлось бы другую.
Пятерка бы осталась вот здесь. Ну представьте здесь пятерку. Давайте с вами,
ну да, я надеюсь вы можете представить, здесь пятерка, которая у меня была вот здесь.
Не единица, а пятерка. Тогда пятерка бы просеялась вот до сюда.
И тогда бы мы действительно четверку меняли бы.
А на что бы место она встала? Пятерку.
Восьмерку, а восьмерка вот сюда, а 14 вот сюда.
Давайте с вами распишем. Хорошо, давайте распишем, после этого у нас будет перерыв.
16. 4. 10. 9. 3.
Ой, ой, ой, не правильно, напишу.
14 8 7 здесь у меня был бы 5 здесь у меня 2 и 4 когда я первый раз поменял местами 5 и 16 и забыл
про то что вообще это существует у нас какое-то новое ребро вот это вот последнего элемента я
бы получил следующую картину у меня была бы здесь пятерка здесь было бы 14 здесь было бы
10 здесь 9 здесь 3 здесь 8 здесь 7 здесь 2 здесь 4 а здесь вот обособлено стоит 16 которая не
входит в нашу пирамиду больше массив она входит в старый но вот в сайсы но больше не входит ну так
это просто обособленная такая вершина пирамида все что зеленая теперь я пятерку делаю всегда
а когда я делаю не всегда он давайте я один раз это распишу прям по полным полностью я получу
следующее здесь вот я нарисую я вначале получу 14 5 10 14 потому что это самый большой из детей вот
здесь 8 здесь 7 здесь 2 здесь 4 здесь 9 здесь 3 после чего я делаю всегда он пятерки еще раз
самый большой 8 из детей поэтому у меня будет 14 8 5 7 2 4 здесь 10 здесь 9 есть 3 ну и вот это 16
все также путешествует то есть где-то она там аморфно существует мы больше не трогаем все мы
просили даунили теперь мы повторяем наш алгоритм нашего типа наши пирамидальные сортировки мы
опять меняем 4 и 14 самый последний элемент самым первым тогда у меня уже после этого будет сейчас
я один раз это тоже нарисую тогда у меня будет 4 8 10 9 3 5 2 7 и вот где-то в вакууме существует
14 и 16 они никак не связаны уже с моей пирамии но они стоят в самом конце причем в начале 16 потом
14 сам в конце 16 и предпоследний 14 правильно да да да да да ну в силу нашего массива потому
что пирамида в начале была из n элементов потом n-1 элемент а мы в самый конец запихиваем максимальный
элемент вот и так далее и теперь мы здесь берем и опускаем опять делаем всегда он для 4 мы его опять
опускаем он опустится вот сюда вот вот вот вот сюда он 4 опустится семерочку а нет извините тут
10 будет больше поэтому всегда он идет вот сюда вот и так далее то есть понятно сама суть алгоритма
как он выглядит не делать его он просто каждый раз искать максимально среди кучей удалять его
а что а что встанет на его вершинку ну какой-нибудь большой маленькое число какое
и что чтобы мы не как чтобы мы туда больше никогда не приходили чтобы мы что чтобы мы
туда больше никогда не приходили так у вас не сохраняется тогда условия пирамиды я не пойму
просто смысл ну то есть если вы ставите очень маленькое число наверх тогда пирамида нет вот
и все еще вопросы так работает пирамидальная сортировка небольшое уточнение по поводу пирамида
у вас есть такая задача как как приоритетная очередь давайте я немножко просто поговорю
именно про приоритетную очередь скажу вообще что это такое приоритетная очередь представьте
следующее я не знаю может кто-нибудь из вас когда-нибудь ходил в мпц может быть нет вот там
такие талончики выбиваются вот и когда вам выбиваются всякие талончики у вас есть место в
очередь вот представьте что аппарат сошел с ума и выдает какие-нибудь рандомные не знаю там числа
вот просто ну вот вы там вам повезло у вас там первый не повезло там 99 и так далее а что
такое приоритетная очередь приоритетная очередь это когда у вас есть грубо говоря пирамида
который есть ключ по которому вы строите эту пирамиду то есть я как человек стою в очереди
но меня ограничивают мой приоритет в виде вот этого ключа видит талончик который мне вот
далее в мпц не знаю например вот или где-нибудь еще а просто с точки зрения вообще структуру
данных приоритетная очередь это та же самая пирамида построенная по ключам все что вас просят
задача про приоритетную очередь я это как раз таки просто построить пирамида sort steering
там добавление элемента и удаление элемента к примеру или там изменение
элементы в случае изменение приоритет он может изменяться вверх или вниз если он изменяется
вверх то элемент стал вышен а к необходимо делать там fluent а если он изменяется вне
севдаун то есть в зависимости от изменения приоритета вот это вот приоритет ну мало ли
вот подошла ко мне женщина тетенька как раз это лончик вас неверный 899 номер там 17 вот исправила
вот идите по идите под номером 17 тогда в этом случае я грубо говоря понижаюсь в очереди или
вовísimo вот вместо того как я строю пирамиду по максиму или по минимуму если по и Kim then
повышают то есть в зависимости от вот этих вот вещей вам необходимо построить embaixo приоритет
мне очередь приоритетная очередь она просто заключена в этих ключа и все вы старает Studio
пирамиду по этим ключа этого достаточно это и есть приоритетная очередь и она работает.
По факту так. Есть ли вопросы к тому, что такое приоритетная очередь? Понятно ли я объяснил словами?
В этом задании мне очень понятно, почему при команде 1, то есть вывести максимум, выводится 2-9.
Давайте так, я скажу семинаристам, они с вами объяснятся, как это именно конкретно работает.
Хорошо? Можете спросить, я это сделаю. Можно это определение приоритетного очереди,
просто я отошел поесть и не успел. Но это плохо. Извиняюсь.
Смотрите, если что, Миша, это спойлер, там выводится не 2-9 на одну единичку,
там на несколько единичек так выводится. На каждую единичку одно число.
Про приоритетную очередь. Приоритетная очередь, это просто когда у нас есть некий ключ,
который является нашим приоритетом. И по этим ключам строится пирамида. Все.
Спасибо.
Остальное, что у нас есть в структуре, мы никак не используем, они просто есть у нас некий приоритет.
Окей, давайте тогда перейдем к новой теме. И мы возвращаемся к нашим бинарным деревьям поиска.
И сейчас у нас будет первое бинарное дерево поиска.
И мы возвращаемся к сбалансированным. Мы уже говорим о сбалансированных.
Сбалансированные бинарные деревья поиска.
И первое дерево, с которым мы сегодня познакомимся, второе мы скорее всего не успеем,
это АВЛ-дерево.
Для того, чтобы говорить о сбалансированности, здесь необходимо кое-что понимать,
что сбалансированность иногда говорится по-разному, что подразумевается под сбалансированностью.
На всякий случай, АВЛ-дерево названо по фамилиям ученых, которые его открыли,
программистов. Это были советские ученые, поэтому можно писать это на русском. АВЛ это тоже будет
корректно. То есть никакого внутри такого смысла, почему АВЛ нет. Что касается АВЛ-дерево?
А здесь подразумевается сбалансированность в следующем смысле.
АВЛ-дерево сбалансировано в следующем смысле.
В следующем смысле. Для любого узла дерева,
высота его правого под дерево отличается от высоты
левого под дерево не более чем на единицу. То есть смотрите, у нас же в бинарных деревьях
как у нас есть левое и правое под дерево, и нам необходимо так, чтобы они были примерно одинаковые.
Сбалансированность в таком смысле нам позволит следующее, что высота нашего дерева будет не
более чем логарифм. То есть мы сможем делать все эти операции, которые мы делали с вами с
бинарными деревьями за логарифм, благодаря сбалансированности в случае АВЛ-дерево.
Для того, чтобы доказать вообще, что у нас АВЛ-деревья такие хорошие, такие классные,
давайте введем некоторые еще понятия. А вот если у нас одно из деревьев пустое,
то его высота минус один? Ну, из одной из под деревьев.
Вот смотрите, в этом смысле, наверное, я был неправ, когда вводил вам с точки зрения высот.
По сути, своя, да? Вот, если мы будем брать тот смысл, который есть, который предполагается
здесь. Поэтому давайте договоримся, ну, прошу прощения, что я так сделал. Высота,
это количество вершин для АВЛ-дерево. Кстати, в контесте задача про высоту
подразумевает именно путь. Да, здесь смотрите, количество,
высота в АВЛ-дереве. Давайте договоримся. Количество вершин на простом пути,
простом и нисходящем пути. А разве не количество вершин?
Смотрите, я именно поэтому здесь делаю уточнение для вас, что мы будем говорить здесь в АВЛ-дереве
немножко по-другому. Прошу прощения за то, что так сделал.
По факту, с точки зрения реализации, будет без разницы, если вы будете просто
минус 1, грубо говоря. В этом не будет ничего страшного. Просто вы будете предполагать,
что в пустых деревьях там минус 1, например, высота. Ну и так далее. Нисходящего пути.
Поэтому, чтобы внести какую-то конкретику, здесь сделаем такую высоту. Я подумаю,
что с этим делать. Я вам скажу на следующей лекции, как правило, мы ведем все хорошо.
Если что, мы что-то поменяем. Но в контесте не будет ничего меняться. Вы можете там просто
минус 1 сделать с высоты. А на простом нисходящем пути от узла к листу.
Тут максимальное количество вышло. Это то, что касается АВЛ-дерева. Для того,
чтобы у нас АВЛ-дерево было корректно, докажем вообще, что оно будет плюс-минус корректно.
В таком случае, когда мы говорим о сбалансированности наших деревьев.
Давайте ведем некоторые понятия. Высота в узле, мы уже с вами говорили,
что это высота его под деревом. Мы говорим о том, что высота в нашем любом узле,
это высота, которая у него достигается. Если его взять корнем, то вниз идти до листов выбрать
максимальный, это будет и высота. Что касается еще некоторых определений. Еще одно определение,
которое нам понадобится. Это так называемый баланс-фактор. Мы его назовем b-фактор,
б-фактор. Он сам по себе равен от какого-то узла х, он равен высоте его правого под дерево,
к примеру, минус высота его левого под деревом. Понятно? Мы ведем вот этот фактор. Если он,
грубо говоря, меньше единицы по модулю, то в этом случае мы говорим о том, что у нас этот фактор
выполнен для wl-деревы. В этом случае у нас wl-дерево является сбалансированным в том смысле,
в котором оно предполагается. Мы вводим такую величину. У нас есть такой вот фактор дерева.
Wl-дерево — это как раз то, что нам необходимо. Теперь такая штука, что утверждение,
утверждение. Минимальная число вершин в wl-дереве. Глубины, глубины, то есть высоты, давайте,
высоты h являются n от h равное число фибоначи от n плюс 2 минус 1.
Здесь все достаточно просто. А здесь фибоначи задается с 0 единицей или единицей единицы?
Здесь единицы. То есть смотрите, если мы берем, это доказывается по индукции. Есть база индукции,
давайте сейчас сделаем это доказательством. База индукции. Если у меня n равно единичке,
то в этом случае у меня оно равно как раз таки f от 3 минус 1. Это с точки зрения базы индукции.
Если мы говорим о переходе, то мы говорим, что n к плюс 1 равно, если мы говорим с высоты
и точки зрения добавления вершины. У меня было какое-нибудь дерево, давайте его нарисуем,
вот такое дерево. У меня вот здесь вот, и вот здесь вот, там есть какие-то у него поддеревья.
Здесь вот высота у меня будет k плюс 1. Если я говорю, что у меня это avl дерево с минимальным
числом вершин, то в одном из поддеревьев я могу сказать, что у него в одном будет k,
но это логично, потому что я добавил одну вершину, иначе бы не было. А если это минимальное
количество вершин, то мы постараемся сделать здесь по минимуму, так как это avl дерево,
то у нас разница должна быть не более единицы, поэтому k минус 1. То есть n от k плюс 1 равно
n от k плюс n от k минус 1 и плюс 1, это сама вершина, у нас добавляет. То есть если мы берем
количество вершин, а здесь уже высоты, мы как бы знаем. Тогда в этом случае мы говорим, что это
1 плюс фибоначевое число от k плюс 2 плюс фибоначевое число от k плюс 1. Ну то есть я добавил подводчик.
Тогда я получаю, что у меня это равно, ну здесь сумма двух чисел фибоначи, тогда это получается,
а естественно я забыл, да, я забыл по минус единицы, я же предположение индукции сделал,
что у меня фибоначи минус 1. Тогда я получаю здесь, что у меня это f от k плюс 3 минус 1.
Вот. Что касается, то есть мы когда посчитали количество элементов, все круто и классно. Что
это означает вообще для нас? Это означает следующее, что если мы ограничиваем число вершин числом
фибоначи, число фибоначи считается как, как бы это сказать, ну я думаю может кто-то из вас
видел формулу числа фибоначи, это 1 плюс корень из 5 делить там на корень на 2, там вот это в степени n,
минус там 1 минус корень из 5 в степени n делить на корень на 2. Вот. Исходя из этого мы можем
сказать, что высота нашего дерева, высота нашего дерева, она будет аж там от n, она будет флагорифмическая,
так как мы ограничим, ограничим наши вещи. Вот. То есть там если посчитать в действительности,
ну как это считается? Давайте так. Это считается просто следующим образом, что ну там n больше
либо равно, чем n от h, h, да мы договорились, что h у нас большая буква, больше либо равно,
чем n от h, там равное число этому фибоначи от h плюс там 2 минус 1. Вот. От h плюс 1.
Число фибоначи, так как у нас там оно есть, оно, грубо говоря, там 1 плюс корень из 5 на 2 в степени n,
минус там 1 минус корень из 5 в степени n, а тут n это h. Тогда если взять здесь,
то мы получим, что у нас h это будет от некоторого флагорифма от h. Если мы возьмем и ограничим,
то здесь будет вот из этого мы с вами получим, что у нас там флагорифм, n больше либо равен,
чем h, плюс 2, к примеру. Вот. А если мы возьмем и добавим еще одну вершину, то мы с вами
получим неравенство, которое ограничит сверху, и там получится как раз таки логарифм. Или непонятно,
что происходит. Что еще раз написать? Ну вот вы сказали, если мы прибавляем еще одну вершину.
Мы прибавили одну вершину. А где это мы прибавили? В смысле? Что подразумевается под прибавили? Я,
наверное, не совсем поняла вас. Вы имеете в виду при переход индукции, что ли? Где k плюс 1, вот это?
Смотрите, если мы прибавили вершину, то да, вот здесь. Смотрите, мы ограничили h вот здесь,
вот исходя из этой формы. Вот она, ограничение. То есть h меньше либо равно, чем логарифм.
Логарифм от n минус 2. Ну, значит, h это o большое от логарифма. Правда?
Да. Все. Мы получили вот это. Вот. То есть мы доказали то, что в нашем овл-дереве,
вот с таким вот свойством, будет наше дерево иметь всегда логарифмическую высоту. А если оно имеет
логарифмическую высоту, все очень хорошо. Потому что тогда наши операции, работающие за оатаж,
работают за от логарифма. Правильно? Стал понять, зачем мы вообще это делаем?
Или не понятно? Понятно. Можно вопрос по определению? На предыдущем слайде было написано то,
что простой нисходящий путь. Что значит простой путь? Простой в том, что мы через одну вершину
не проходим несколько раз. Ага. Спасибо. Вот. Смотрите, как достигается балансировка
как раз-таки в нашем дереве. Здесь все будет как раз-таки зависеть от нашего вот этого вот
баланс-фактора. Какие возможны случаи? Представьте следующее. Вот у меня есть некоторые дерева.
Вот здесь вот у меня вершина, не знаю, там П, к примеру. У него есть два подделия каких-то. Там А и
Б. Правильно? Вот. В случае, если я добавлю сюда вот вершинку какую-то, ну вот обычным инсертом,
мне необходимо сказать, что у меня изменится как-то баланс-фактор. Правильно? Сбалансировка как-то по
другому вся произойдет. Правильно? Ребята. Да. То есть, смотрите, у нас здесь высота может
измениться. Если она изменится, то нам необходимо перебалансировать дерево, потому что правая его
часть стала слишком тяжелой в отличие от левой. Значит, там необходимо что-то передвинуть. Вот. И
тогда в этом случае существует так называемый поворот. Прошу прощения. Вот. Стоит так называемый
поворот. Стоит левый и правый поворот. Представьте следующую картину. Вот. Сейчас я тут
нарисую чуть более подробно. Пусть у меня есть некоторая вершина. Вот здесь вот, не знаю там,
как раз таки П. Вот здесь вот у него есть поддерево А. У П есть слева Y. Нет, давайте Q. Скажем,
что это Q. У них лежат там X и Y. Здесь у меня там B поддерево. Здесь у меня там поддерево C.
Вот. Я хочу сказать следующее, что у меня вот здесь вот пусть у меня разбалансировка происходит,
так как мы добавляем одну вершину или там удаляем одну вершину. Мы поговорим об этом чуть попозже.
У меня происходит на плюс-минус единицу. То есть у меня будет баланс-фактор отличаться от единицы
по модулю. Не сильно. Вот. То есть это будет два. Если я скажу, что у меня в левом поддереве будет,
грубо говоря, высота там h-3. Вот. Вот в этом дереве, к примеру, тоже h-3 или h-2.
Плохо видно. Прошу прощения. Сейчас. h-2 либо h-3. Вот. А в этом дереве h-2. Вот. Высота тогда
вот этого поддерева и его правого равна h-1. Ну, потому что у меня здесь h-2. Добавил еще одну
вершину. Получил h-1. Вот. Тогда баланс-фактор. Вот этот вот для вершины p баланс-фактор.
Чему равен? Скажи, пожалуйста, Владислав. Вот как ты думаешь? Вершины p? Да. Получается
минус два. Почему минус два? Мы вычитаем из какого? Какого? А, значит, два. Из правого. Мы говорим
о том, что мы вычитаем из правого левого. Ну, кто-то говорит из левого правого. Здесь как бы
без разницы. Вот. В этом случае у нас баланс-фактор равен два. А вот для баланс-фактора у, когда вот
мы добавили, у него, ну, точнее у q, у q баланс-фактор так и остался плюс-минус один. Правильно? Когда мы
добавили там какую-нибудь вершину, например. Если мы добавили и у нас получилось вот то,
что у нас с правым там по дереве, все так хорошо. То есть у нас здесь баланс-фактор равен два,
а и баланс-фактор от q равен либо 0, либо 1. Один из этих случаев. Смотрите, дерево у нас не
сбалансировано. И оно имеет такой перевес на правую сторону. Что было бы классно сделать? Как
вы думаете? Ну, вот давайте я кого-нибудь спрошу. Вот София Труфана. Вот как ты думаешь,
что можно сделать здесь такого, не сильно меняя само дерево, чтобы у нас что-то получилось?
Сделать корнем y или q, она называется q. Да, то есть смотрите, действительно,
да, спасибо большое. Это правильно. То есть если мы возьмем здесь и сделаем,
к примеру, корнем q, то у нас с вами все получится. То есть мы возьмем и перебалансируем это дерево.
То есть мы его переведем в дерево такое, что у меня здесь будет q с y. А вот теперь вопрос,
где должен стоять q? Давайте я спрошу, спрошу Антон. Антон меня не слышит, поэтому я прошу пан.
Антон, хорошо? Я или Антон? Ну, q в левой части. В левой части, вот здесь у меня будет стоять q. А теперь
вопрос, что будет с новьями у п? А. А еще? Ну, все. Все. А теперь вопрос. Смотрите,
помните, мы с вами опускали на нашу, грубо говоря... Разве не b? Разве b не должно прийти от q?
А, оно же должно к чему-то крепиться, находится как раз между q и p. Да, то есть смотрите, помните,
мы с вами опускали на числовую прямую. Вот здесь, вот если мы опустим, у нас здесь будет a,
здесь будет p, здесь будет b, здесь будет q, а здесь будет c. То есть, грубо говоря,
мы можем сказать a меньше p, меньше b, меньше q, меньше c. Поэтому здесь, когда мы делаем,
мы в q не можем сделать левого сцена. Мы делаем в p правого сцена, вот здесь. Вот мы делаем здесь
b при такой балансировке. И у q мы оставляем в этом случае c. Можно еще раз мы какую балансировку
делаем, чтобы чего добиться? Чтобы добиться того, чтобы у нас фактор от корня был единичка.
А здесь разве не было такого же? Смотрите, у нас для b не было. Теперь давайте с вами посчитаем,
вообще, что у нас произошло. Для a у нас была высота h-3, для b у нас была высота либо h-2,
либо h-3. То есть, в худшем случае у нас в p лежит высота либо h-1, либо h-2. Мы в p добавили.
В c у нас высота h-2. Видите, мы вернули наш баланс-фактор к исходному, к вот этой вот
самой плюс-минус единичке или нулю. Таким вот поворотом. То есть, нам необходимо перецепить
вот это вот под дерево b и взять и повернуть все это дерево. Это называется левый поворот.
Давайте я сделаю вот здесь оголовок. Вот, то есть, здесь у нас не сломаются условия того,
что... Это же димбинарное дерево поиска? Да. А от этого не станет то, что мы перекинули b,
а оно ведь должно быть... Но оно там не стояло. Еще раз, b оно стояло справа к у. Правильно? То есть,
оно было все больше это под дерево. Нет, все меньше. Ой, все меньше, да. Извините. Да, все меньше.
Если оно находится слева к у, то оно все равно все меньше. Все правильно. Есть ли еще вопросы к
тому, как мы взяли и развернулись здесь? Да, почему мы именно b меняем? Чего еще раз? Почему мы
именно b меняем? По дереву b? А что мы еще можем поменять? Вот смотрите, мы спроецировали это на
вот такую вот ось. У нас а меньше, п меньше, q меньше, c меньше. q мы подцепить не можем,
потому что у него уже сын b. Правильно? У q левый сын это p. Так, но b-то должно стоять между p и q?
Ну, значит, где оно должно стоять? В правом сыне p. То есть, оно больше, чем p, но меньше,
чем q. Еще есть вопросы? Нет. Хорошо. Мы получили с вами левую такую вот операцию. Теперь правая
операция. В каком случае, что происходит? Представьте следующее. Это по факту, если бы у нас вот
здесь стояла бы наша вершина q, у него были a, было b, а здесь было бы c. И вот оно бы разбалансировалось
другую сторону. Вот этот вот фактор балансировки от p был бы равен минус 2 уже, а фактор балансировки q
был бы равен 0 или минус 1. То есть, a и b по факту с теми же высотами. Почти что да.
Понятно, что я говорю или нет? Да что ж такое-то у меня сегодня со Стивусом. Смотрите, в этом случае,
когда у нас вот есть такая вот штука, то есть, если здесь минус 2, то у нас аналогично тому,
что у нас с вами уже и было. То есть, мы говорим, что вот здесь вот высота у нас там, к примеру,
h минус 3, вот здесь вот там у b это h минус 2 или h минус 3, к примеру, а вот здесь вот высота там h
минус 2. Случай аналогичный, только нам теперь надо q сделать нашим верхним, нашим корнем. Тогда
в этом случае мы должны взять и переделать это следующим образом. Здесь у нас будет q,
здесь у нас останется a, здесь у нас уже будет p, вот здесь у нас будет b, а здесь будет нашу цепь.
Прям точно симметричное это получается. Да, это абсолютно симметричное действие. Левый поворот и
правый поворот. Понятно? Мы применяем поворот после добавления какого-то листа нового. Мы
применяем повороты в случае балансировки. Балансировка может быть при удалении или при
добавлении элементов. Мы сейчас рассматриваем в случае, что вообще возможно получить, то есть,
что такое разбалансированность в нашем случае. Так как мы меняем один элемент, у нас вот этот
фактор может увеличиться, уменьшиться на единичку. Если он равен минус 1, 0, 1, нас вполне это устраивает.
Вл дерева это и нужно. Если он равен минус 2 или 2, то в этом случае нам необходимо перебалансировать
дерево. И вот здесь вот я беру и разворачиваю это уже наоборот. Ясно? То есть это называется
правый поворот. Где-то это называется малый правый поворот, где-то это просто правый поворот.
Потому что сейчас у нас появится большой. Представьте следующую картину. Здесь у нас станет уже чуть-чуть
побольше. Следующую картину. Пусть у меня фактор от P равен 2. Фактор
от Q равен минус 1. То есть смотрите, мы с вами рассмотрели здесь случай, что произойдет,
если у нас здесь изменится фактор вот именно таким вот образом. Правильно? Но мы не рассмотрели,
а что будет если минус 1? То есть оно вставится вот в этот кусок под дерево, который левее. Вот
этот вот в B. В этом случае нам необходимо рассмотреть еще кое-какой вариант. То есть у нас в случае,
когда 2, здесь минус 1. Давайте нарисуем сначала это дерево. Здесь рисовать очень полезно,
тогда становится абсолютно все понятно. Вот у меня есть P, пусть у него какой-то ключ X. Вот у
меня есть Q, у него ключ какой-нибудь Y. И вот я рассмотрю еще вот этот теперь кусок отдельно.
Пусть у меня тут Z, но не знаю там PQL, например. У него есть первое под дерево. У P вот здесь вот
тоже есть какое-то под дерево. У Z здесь есть какое-то под дерево C. Сейчас я их все назову D,
A и B. Всего этого есть какие-то под деревья. Вот я говорю о том, что если у меня фактор равен
минус 1, так как я вычитал из правого левого, то в левом у меня произошло вот этот вот дисбаланс.
Что ж такое-то? Сегодня оно слишком чувствительное.
Так, момент. Что я хочу видеть в этом случае? Я хочу видеть в этом случае
Следующее. Пусть у меня вот здесь вот высота h-3. Так как у меня фактор равен 2, то у меня вот
здесь вот будет h-3. Что ж такое-то? Прошу прощения. То вот здесь вот слева у меня будет высота h-3,
а справа у меня будет высота этого всего. Какая? H-1. Если здесь высота h-1, давайте дальше
раскидывать. Если у меня вот здесь вот D и B и C. Так как у меня фактор равен минус 1,
вот здесь вот высота у меня какая? H-2. Нет. H-3. Смотрите, у нас в принципе это плюс-минус
балансированное дерево. Если здесь высота h-3, то высота вот этих всех h-1. Мы это уже сказали.
Если высота этого h-1, мы говорим, что у меня фактор q равен минус единичке. Отличаться они не
могут друг от друга сильно. Иначе бы у меня здесь не было баланса фактора 2. Правильно?
Высуждайте. Мы знаем, что фактор q это минус 1. Как мы получили, что h-3 высота D. Но мы знаем,
что с q это h-1 высота. Без q здесь высота h-2 в каком-то из-под деревьев. Так как у меня баланс
фактор. Вот здесь вот h-1. Надо понять как из них больше. Вот это у меня будет h-2. Потому что без q.
Надо просто понять. Так как у меня баланс фактор говорит о том, что там минус, то есть получается,
что вправо мне хватает относительно левого. Так как высота h-1, то влево у нас высота h-2. А так
как вправо на 1 меньше, то h-3. Стало понятно? На 1 больше. Влево на 1 больше. А вправо на 1
меньше. Мы с вами это получили. Все чудно. Чудно, круто, классно. Что-то реально сегодня что-то
не то. Так, ладно. Вот это мы с вами получили. Все, что нам нужно... Сейчас момент я переподключу.
Что-то я не могу уже писать дальше. Все, вроде бы сейчас стало получше. Ну и все,
что нам нужно еще знать про высоту деревьев B и C, они точно меньше либо равны тем h-3.
Ну что-то из них равно h-3. Правильно? Да что же это такое?
Так, хорошо. Мы с вами это получили. Нет, это кошмар какой-то. Я не понимаю,
что происходит с моментом. А если какой-то из них h-3, а второе либо h-3, либо h-2?
Здесь нам не важен фактор Z. То есть мы знаем, что там AVL деревьев.
Да, тогда вот уточнение для определения сбалансированного AVL дерева. Нам нужно,
чтобы для каждого под дерево выполнялось такое или как-то в целом для дерева.
Для карты, да? То есть получается,
если какой-то из B и C имеет высоту h-3, то, например, одна из них имеет h-3, это обязательно,
а вторая может быть вообще любой. H-4, h-3 или h-2. Одна из трех.
Да, но тогда ведь если будет h-, например… Мы считаем, что это сбалансированная уже часть.
Ага. Ну, она должна, когда… Ее высота должна отвечаться… А, нет, мы уже всё, я понял.
Вот, окей. Тогда в этом случае… Смотрите, вы понимаете, что в этом случае нам левый поворот
не спасает нас? Вот, ну никак. Или не понимаете? Смотрите, если мы возьмём и развернём здесь налево,
ну вот был у нас левый поворот, правда? У нас был с вами левый поворот, вот этот вот.
В этом левом повороте, что мы делали? Мы просто вот эту вершину Q перетаскивали наверх. Если в
этом случае я перетащу вершину Q наверх, то в этом случае у меня будет слева высота h-2,
здесь будет h-1, но будет ли это… Ну, типа получится ли у нас, что здесь у нас будет всё корректно?
Не получится. Почему? Потому что когда мы вот эти вот вершины L, вот эту вот вершину L соединим
с P, здесь станет высота у P h-1, а справа у Q вот эта вот D, вот эта вот D, которая вот здесь вот,
у которой высота h-3. Тогда у нас с вами получается, что нету никакой сбалансированности, и у нас
опять бы фактор сталавин 2. Для того, чтобы этого избежать, можно сделать достаточно простую вещь.
Давайте с вами сделаем так, что мы вначале повернем направо, а потом повернем налево. То есть мы
возьмем, развернем вот это вот L сюда, а потом то, что будет здесь, развернем сюда налево.
Тогда в этом случае… Смотрите, что у меня произойдет тогда в этом случае. Вот это h-1
сотру, напишу ниже. Тогда в этом случае я с вами получу что… Прошу прощения сейчас, момент.
Тогда в этом случае я с вами получу следующее. После первого поворота, я здесь нарисую поменьше
эти штучки. У меня будет вершина P, у нее будет уже сын L, а у сына L будет здесь B,
ой, давайте так, у меня будет здесь Q, у Q будет вот здесь вот D, да, все правильно,
вот здесь вот у меня будет B, я совершаю правый поворот пока мало. Здесь у меня… Не могу я
вставить, поэтому я вставляю его Q, у меня вот здесь вот будет C, а здесь будет A.
Я совершил правый поворот для вот этого левого поддерева.
Тогда в этом случае я говорю о том, что… Тогда в этом случае я говорю о том, что у меня высота
вот этого левого куска относительно L, вот этого, стала равна… Давайте сейчас черный возьму,
вот у этого кусочка. Высота стала равна чему? H-2. Высота вот этого кусочка у меня либо H-3,
либо H-2, да? А тогда вопрос, этот случай похож на вот этот? Он и является по факту вот этим
левым поворотом. То есть вот здесь вот у меня слева H-3, либо H-2. Тогда я беру и здесь поворачиваю
налево, налево, потому что вот этого все еще H-3. А вот здесь вот у этого большого куска, у левого,
все также осталось H-1. Я его как бы повернул, но ничего сильно не изменилось, высота-то осталась
одна и та же у дерева. Я просто перебалансировал его. Тогда в этом случае я с вами и получаю как раз
то, что мне необходимо. И здесь я начинаю делать левый поворот. Тогда я получу следующее. Так как я
делаю левый поворот, то у меня вот эта вершина L станет вот здесь. У нее здесь все также будет
вершина P. У вершины P будет вот здесь под дерево A. Здесь будет под дерево B. Здесь у нас станет Q
с под деревом C и с под деревом D. И тогда я с вами получил сбалансированный такой кусочек.
Фактор P минус 1, да, получится? Плюс один. Вот правый минус слева. Смотрите,
справа у нас будет высота H-2, а слева высота будет какая? Тоже H-2.
Либо H-1. Поэтому будет либо 0, либо минус 1 у нас бы фактор. Понятно, как это получилось. То есть
мы просто развернули сначала один кусочек, потом еще один кусочек. Есть ли вопрос, как это вышло?
Можно еще раз коротко посмотреть, пожалуйста? Еще раз. Нам сначала нужно перебалансировать кусок
следующий. Нам необходимо перебалансировать, давайте возьму розовый. Вот этот вот кусочек нам
нужно перебалансировать для того, чтобы свести к левому повороту, который у нас и должен быть
здесь. Для того, чтобы его перебалансировать, мы повернем его направо. Если мы повернем его
направо, мы получим именно тот случай, который нам подходит для левого поворота. После этого я
беру и делаю левый поворот. Понятно? Кратко это звучит так. Есть ли вопросы?
Друзья? Нет? Нет. Хорошо. У нас с вами осталась еще одна штука. Эта вот вещь называется на самом деле
большой левый поворот. Сейчас напишу. Остался большой правый? Остался большой правый. Все
правильно. Он симметричный. Называется большой левый поворот. Смотрите, конкретно его делать
особо... отдельно я имею в виду. Делать его смысла нету. Конкретно его. Почему? Потому что
он складывается из двух поворотов по факту. Из левого поворота? Да что ж такое-то?
Не нужно. Папе с доски. Плохо делается. Вот все. Вроде все стало нормально. А нет, не стало.
Вот теперь все хорошо. Вот это то, что касается вот этого поворота. Теперь нам остался один
последний поворот, который нам необходим. Он называется большим правым поворотом. И он
аналогичен тому ровно, что мы с вами делали. Мы просто говорим, что в этом случае у нас б-фактор
от p равен минус 2, а б-фактор от q у нас равен 1. То есть это по факту те самые случаи,
которые мы с вами недорассмотрели в нашем варианте, который был до этого. То есть смотрите,
вот здесь вот, когда мы с вами рассматривали правый поворот, у нас был б-фактор минус 2.
Но б-фактор q был 0 или минус 1. Теперь нам необходимо его переделать в то, чтобы у нас был
б-фактор как раз таки 1. То есть это возможный случай, когда мы добавили вершину, например,
или там удалили. Возможный случай. Тогда нам необходимо взять что-то переделать. Для этого мы
с вами как раз таки и описываем наш правый поворот. Большой правый поворот. Он делается
симметрично. То есть у нас здесь есть вершина p, здесь у нас есть под дерево d, здесь у нас там
есть вершина q, у нее вот здесь вот вершина z. Нет, вершина l. У него здесь b, здесь c, здесь a. Я
его хочу развернуть так, чтобы у меня было. Да что ж такое? У меня здесь было. А у нас
вроде бы фактор p должен быть минус 2. Так, а почему? А, да, да, извиняюсь. Фактор p, да,
действительно, да, минус 2. Да, все правильно. То есть случай аналогичный, симметричный,
потому что у нас с вами было. Вот, тогда в этом случае мы... Так, сейчас, момент. У меня тут
с этим стилусом проблемы. Тогда в этом случае нам необходимо взять и просто...
Сейчас давайте я кое-что сделаю. Нет, ему прям явно не нравится то, что я делаю. Так,
постараюсь, чтобы написать. Тогда в этом случае мы хотим повелчить здесь вершину l,
здесь мы хотим с вами получить одну вершину, а здесь там вторую вершину. Вот здесь вот у меня
будет p, вот здесь вот у меня будет q, здесь у меня будет под дерево a, вот здесь под дерево b,
вот здесь под дерево c, и здесь под дерево d. Это называется большой правый поворот. То есть
он симметричен тому случаю, который был. То есть он сложится из... Из каких поворотов? Из поворота
левого, а потом сюда правого, да? Вот, то есть он складывается из таких вот вещей. Это
называется большой правый поворот. Big right rotate, извините. То есть он складывается из левого
поворота, плюс правого поворота. Таким вот образом мы с вами получаем вот такие вот штуки,
которые нам и понадобятся в задании. То есть таким вот образом мы можем сбалансировать наше
овель дерево. Что касается того, как это пишется. Если у вас вопрос по тому, как это переписать,
то смотрите, здесь просто происходит переподвешивание некоторые, которые нам
необходимы. Вот, и в общем виде, грубо говоря, если взять здесь и реализовать тот же rotate.
Right, например, правый поворот, куда я передаю вершину p, указатель на эту вершину. То есть это
правый поворот вокруг. Если мы смотрим этот правый поворот, то он будет выглядеть следующим
образом. Что мы делаем? Мы говорим, что у нас вершина q, это есть левый цин. Да что ж такое-то?
Сейчас если он сейчас не заработает нормально, буду писать словами. Вот, мы говорим о том,
что у нас q, это есть левый цин в нашем правом повороте. И теперь нам необходимо просто
переподвесить наши какие-то вершинки. Тогда в этом случае мы говорим о том, что нам нужно сказать,
что левый цин теперь у p, это есть правое под дерево q. Давайте если я точку иначе писать,
то будем точкой. P left равно q, right. А правым сыном у q является теперь p. И все, что нужно
сейчас еще дополнительно сделать, это... Нет, оно, видимо, не хочет работать самое большее.
Я что-нибудь с этим придумал к следующей лекции. И все, что мне нужно к этому всему добавить,
это то, что я должен скорректировать высоты. Высоты у своих под деревьев. Но для того,
чтобы их скорректировать, мне необходимо написать какую-нибудь функцию по типу
fix высоты. Что такое fix высоты? Он просто берет и говорит, что высота теперь моего нового
дерева в высоте, так как мы меняем только p и q, в них высота изменяется и равна на высоте
левого и правого под дерево плюс один. То есть для того, чтобы это у нас работало,
мы с вами сделаем там функцию fix от вершины какой-нибудь, от любой ноды, например,
x. Что оно делает? Оно возвращает следующее, что... Кто что говорить пытается? Понял. Понял,
кто это был? Ладно. Тут, видимо, штуки запали. Да, конец не очень получается. Когда мы с вами будем...
Давайте я просто напишу текст. Мне кажется, вам так легче будет на самом деле. Давайте текст черный.
Здесь вот я напишу. Я хочу с вами реализовать вершины, реализовать некий rotate. Для этого я
буду просто говорить, что у меня rotate, right rotate, правый поворот. Вот некоторые вершины q. Это
указатель на нашу ноду. Мы говорим о том, что он у нас равен следующему, что мы говорим,
что q это левый его сын. То есть q это у меня p.left. Это левый сын. Мы, видимо, передаем p все-таки.
Ой, да, спасибо. Левый ее сын. Тогда в этом случае мы переподвешиваем наше дерево согласно тому,
как у нас работает правый поворот. Мы сейчас к нему вернемся. Мы говорим, что q у нас равно...
ой... p.left, левый сын теперь у p, равен q.right. То есть мы переподвешиваем то самое дерево.
После этого мы делаем, что q.right равно... теперь нашему p. То есть теперь p стал правым сыном нашего q.
Вот. Помимо этого, если у нас есть дерево, реализованное в виде структуры, то нам необходимо
еще и корень, в случае чего, менять. Здесь немножко сложнее. Здесь нужно просто вам будет подумать,
как это именно сделать. Вот. Чудесно. Мы с вами это получили. После чего нам необходимо просто
пофиксить нашу длину. То есть вызвать там функцию fix высоты у узла p и fix высоты у узла q. Вот.
И когда мы это сделали, это в принципе все. Что такое fix высоты? Давайте сначала разберемся,
все ли понятно с правым поворотом. Если мы откроем вот здесь вот правый поворот. Вот он у
меня был. Смотрите, я должен переподвесить b. Чуть-чуть мышкой порисую. Я должен переподвесить
вот это вот b, которое у меня есть, а вот из q в p. В левого сына p. Вот я это ровно и делаю. Это все,
что там делается. И то, что правый сын q теперь стал p. Я просто беру все и переподвешиваю. Вот оно все
переподвесилось. Что такое fix высоты? То есть так как мы переподвесили деревья, нам необходимо
взять и перепиксировать высоту. Для того, чтобы это произошло, нам необходимо сделать просто
следующее fix q. Что у нас делает вот эта вот штука, что просто берет и возвращает высоту нового
по дереву? Так как у нас a, b и c никак не менялись в нашем коде, то в этом случае у нас высота
меняется просто следующим образом, что это... Давайте сделаем так. Высота правого...
Пусть у нас есть высота правого, она равна q.right.h. То есть у нас в поле появилась высота. У каждого
объекта, каждой ноды есть еще и высота. Под высотой ноды мы говорили о том, что такая высота
узла. Вот высота узла это просто вот этот вот нисходящий путь, сколько в нем вершины. А высота
left равна q.left. Высота. Вот, когда мы с вами это получили, мы говорим о том, что у нас q, высота,
равна... Чему? Равна максимальному значению из этих двух высот плюс один.
H left плюс один. Единственное, что надо понимать, что если мы вызываем вот так вот высоту,
и это не функция, к примеру, если бы это была функция, то все нормально. А здесь у нас возможен
на самом деле. Поэтому лучше всего это обернуть следующим образом, что у нас здесь будет высота
вызываться как функция. Вот значение. И эта функция внутри проверяет. Если это nullptr,
то возвращает ноль. Иначе просто высоту, которая у нас хранится в ноде самой. Понятно? Вот. Все.
Мы с вами взяли, пофиксили всю высоту, все сделали. Это все, что нужно здесь сделать.
Что касается левого поворота. Я думаю, для вас не секрет, как будет выглядеть левый поворот.
Можно вопрос? Да. Еще раз, а почему изменили h right и h left? Кого изменили? Ну, там до этого было
q.right. Мы изменили, потому что может быть правый или левый сын, он может быть нулевой nullptr.
Да, и получается... От nullptr нельзя ничего взять. А если мы делаем как функцию, то эта
функция проверит в себе внутри. Если это nullptr вернет ноль, иначе высоту. Да, спасибо.
Что касается правого поворота. Правый поворот от вершины какой-нибудь p,
он будет выглядеть аналогичный просто с точностью до перестановок. То есть мы говорим о том,
что если у нас правый поворот, то что у нас q, это будет p.right.
То, что у нас будет p.right, правый сын теперь у нас будет q.left, q.left равно p. Ну и дальше
пофиксить высоту. Почему мы фиксируем высоту и у нас все хорошо с вами получается? Да все потому,
что когда мы это с вами делаем, мы говорим о следующем, что у нас а, b и c, которые у нас были
в левых и правых поворотах, они сами по себе уже внутри несут правильную информацию относительно
высоты. А если не несут правильную информацию о высоте, то нам нужно обновить только f и q. Этого
достаточно. Что касается вообще всей балансировки. Смотрите, большой правый поворот и большой левый
поворот особого смысла описывать отдельно нет. Для того, чтобы его сделать, можно просто сделать
следующее. Давайте сейчас напишем. Напишем, как выглядит вообще функция балансировки. И потом
я в конце скажу, когда это вообще балансировка выглядит. Когда она вызывается. Если мы с вами
вызываем балансировку относительно какой-то вершинки, пусть будет p, как у нас и было,
то в этом случае мы говорим, что если у нас этот б-фактор от p будет равен 2. И если у нас наш
б-фактор от правого под дерево, то есть смотрите, большой правый поворот происходит в каком случае,
когда у нас там отрицательная штука появляется в б-факторе. То есть если у меня б-фактор от
p-right будет меньше нуля, то в этом случае я говорю, что у меня p-right
ровно. То есть его правый должен стать корнем. И вообще по-хорошему right rotate и left rotate должны
возвращать как раз таки саму. Мы сейчас это допишем чуть-чуть попозже. Сначала допишу здесь. Просто
здесь нельзя просто переключаться между текстом в зоны. Он равен right rotate от чего? От p-right. То
есть мы делаем большой правый поворот. Ой, левый поворот, sorry. После чего, это левый поворот,
да. После чего, если у нас не было бы этого б-фактора, то есть нам не нужен был бы большой левый поворот,
обычный левый поворот, то в этом случае мы говорим, что мы берем и возвращаем здесь,
к примеру. Right rotate возвращает p. То есть мы p изменили, он вернет p.
Он возвращает наш корень. Хорошо, давайте так. А почему нельзя сделать функцию void,
но передавать туда не указатель, а ссылку? Можно. Можно. Смотрите, здесь ваша реализация,
как вы хотите сделать. Но все, что здесь нужно понять, что здесь в случае чего,
я просто сейчас объясняю, как выглядит балансировка наша. В этом случае мы делаем
rotate left от p. И в п получается, записываем rotate left. В этой реализации. В п записываем
rotate left. Да, в принципе, можем. Можем сделать так, что это будет возвращать просто наш корень.
Вот, то есть смотрите, с точки зрения балансировки, балансировка действительно работает так,
что мы будем здесь хранить различные структуры такие. Что касается большого левого поворота,
большой левый поворот будет происходить, ой, большой правый поворот, извините, большой правый
поворот будет происходить аналогично, только просто у нас поменяется местами ратейт. Райт ратейт и
левт ратейт. Это то, что касается овл дерева, в принципе. То есть смотрите, это происходит так.
И последнее, что, так как, ну, я думаю, вы сможете дописать симметричный случай,
это не очень сложно. Вот. Что касается вообще самой задачи постановки балансировки? В каком
случае нам нужна балансировка? Это последнее, что я делаю и типа отпускаю вас, все, я понимаю,
что вам уже сложно. Когда мы с вами взяли и вставили элемент, вот мы взяли и вставили куда-то
элемент. Вот так, не знаю там. Вот у меня было такое бинарное дерево. Я вставил вот этот вот
элемент. Мне нужно перебалансировать все его, всех его родителей. То есть для того, чтобы у меня был
новый баланс, ну, то есть перебалансировать свое дерево, я должен взять и сбалансировать его
родители, родители этого родителя и родители этого родителя. Короче, предков. Да. Всех предков
необходимо взять и перебалансировать. Благодаря этому у нас обновится высота,
во-первых, потому что мы, благодаря тому, что там есть различные ротейты и так далее, если они
будут происходить, то мы будем обновлять высоту. Вот. И высоты тоже мы можем обновить при инсерте,
к примеру, даже. Вот. И так далее. То есть нам необходимо обновить все у предков. Теперь вопрос,
что происходит при удалении вершин? При удалении вершин, если мы удаляем лист или дерево,
ой, лист или вершину, которая у нас там переподвешивается, ну, то есть у него один ребенок,
я думаю, вы понимаете, что в этом случае нам необходимо просто запустить балансировку тоже
от всех предков. Вот. Просто запускаем балансировку от всех предков, все получается. Что происходит,
когда у нас это не лист и ни один у него ребенок? Тогда в этом случае нам нужно удалять здесь
вершину, когда мы с вами, помните, ищем здесь там минимальный элемент. Если это лист, то мы
просто должны перебалансировать вот здесь вот все. Ну, то есть нам бы фактор должен быть другой,
потому что у нас иначе высоты могут быть другие. То есть здесь необходимо также пойти по всем
предкам, когда мы первоначально, грубо говоря, удаляем эту вершину. То есть мы ее отцепляем,
а потом мы берем и вставляем ее вот сюда, то есть перецепляем эту вершину сюда.
С точки зрения высот у вас ничего не изменилось, потому что вы просто вставили эту вершину. Если вы
вставили, вам необходимо только лишь в этой вершине взять и обновить высоту. Но перебалансировки
здесь никакой не может быть. Все, что нужно сделать из перебалансировок, это только опять пройтись
вот по этим родителям в случае, когда вы взяли и удалили отсюда этот кусочек. Понятно?
То есть все равно у нас будет вся идея в том, что мы идем по предкам, а по факту удаляем мы всегда
узел именно тот, у которого либо один ребенок, либо вообще нет детей. Ясно?
Нет, надо еще раз. Что именно непонятно?
Про удаление. Почему по факту всегда перебираем всех предков? Потому что мы
изменили здесь, вот здесь мы изменили нас высоту, мы убрали одну вершину. Правильно?
Да. Если мы убрали одну вершину, у нас изменилась высота,
значит, что здесь у нас везде могло поменяться высота под дерево. Правильно?
Да. Могла. Поэтому нам необходимо взять и перебалансировать абсолютно всех предков.
Хорошо. То есть вам необходимо дописать в реализации не то чтобы много,
вам необходимо просто ротейты написать. В принципе, на этом наследие заканчивается,
большое спасибо, что вы пришли. Буду ждать вас снова через неделю.
