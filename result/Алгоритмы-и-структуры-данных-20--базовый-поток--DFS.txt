Всё, отлично, окей, что же, давайте сегодня будем
с вами продолжать все те темы, которые у нас были,
мы продолжаем с вами графы, я это напомню, и сегодня
мы с вами будем говорить про обход графа в глубину.
На прошлой лекции мы с вами говорили про обход графа
в ширину, сейчас мы будем говорить обход графа в
глубину, зачем это нужно, как вообще с этим можно
что-то делать, и в зависимости от этого мы будем уже что-то
использовать как-то, использовать те алгоритмы на графах,
которые у нас есть, ой-ой, ой-ой, почему он это делает,
интересно, ну ладно.
Что такое обход графа, в принципе, чисто так напомню,
что задача любого обхода графа, будь то в ширину
или в глубину, которая есть сейчас, заключается в обходе
всех вершин и ребер в некотором порядке с учетом структуры
графа, с учетом структуры, которая занимается что-то
связанными, что-то несвязанными, как-то с этим нужно считаться.
Идея обхода графа в глубину, то есть DFS, она примерно
следующая, что берем стартовую вершину S и будем двигаться
в глубину в произвольном направлении, до тех пор
пока можем, если не можем, вернемся и откатимся на
шаг назад и пойдем в какую-нибудь другую сторону, то есть мы
не будем волнами ходить, как это было в BFS, мы будем
конкретно по одному пути идти, пока можем, как только
не можем, вернемся обратно, в этом пока что сама суть
DFS.
Какие две причины могут помешать тому, чтобы DFS продолжился?
Первое, из очередной какой-то вершины нет ребер, какие-то
новые вершины, и это будет означать, что у нас просто
нет ребер, то есть вершина сама по себе тупиковая, то
есть мы пришли в какую-то вершину и из нее нет ничего.
И второе, это когда все ребра ведут уже в просмотренные
вершины, то есть у меня был какой-нибудь вот такой
граф, давайте я сейчас придумаю, как тут же сделать, вот
например, вот так и вот так, и предположим, что я уже
посетил вот эту вершину, вот эту вершину, а теперь
я прихожу вот в эту вершину, из нее все посещены.
То есть две вот такие вот причины, которые могут
означать, что у нас граф сейчас, мы уже не можем
дальше двигаться, то есть вот это вот те причины, по
которым мы не можем с вами что-то продолжать.
Как выглядит алгоритм DFS?
Ну, он достаточно прост.
Берем какую-то вершину, проходим из нее по ребру
в произвольном направлении, если мы еще не посещали
какую-то конкретно вершину, если у нас из очередной
вершины некуда идти, то возвращаемся к предыдущему
шагу и продолжаем обход по какому-то новому пути,
который нам необходим.
И если по итогу мы возвращаемся в стартовую вершину и из
нее идти некуда, тогда в этом случае мы просто заканчиваем
наш DFS.
А как мы можем это все делать?
Здесь нам в действительности понадобятся различные
вещи, связанные с цветами, и еще мы ведем такое понятие,
как таймин и таймамп.
Для того, чтобы осуществлять вот этот просмотр вершины
посещена или не посещена, мы ведем цвета.
Это белый, серый, черный.
Белый будет означать, что у нас вершина данная не
была посещена.
Серый будет означать, что из вершины осуществляется
обход в глубину, но он еще не закончен, то есть мы
можем вернуться к этой вершине и пойти по какому-то
другому пути, например, а черный означает, что вершина
была обнаружена, то есть мы уже все через нее прошли
и никаких доступных путей нет, и теперь эта черная
вершина просто существует, то есть ничего мы сделать
с этим не можем.
Кроме того, мы ведем таймин и таймаут.
Таймин – это момент первого обнаружения вершины, то
есть когда мы первый раз в нее зашли и из белого
покрасили в серый.
Таймаут – когда мы оттуда вышли, то есть когда мы вышли
из той или иной вершинки.
Давайте подумаем, как это сделать.
Поэтому легче всего сделать весь наш ДФС в виде рекурсии,
потому что с помощью рекурсии мы обратно сможем откатываться
к предыдущим вершинкам и возвращаться куда-то.
Какова суть?
Ну смотрите, у нас будет какой-то массив color, массив
таймин, массив таймаут и время на данный момент.
Вначале нулевое.
И дальше мы с вами просто делаем ДФС визит.
Что это означает?
Смотрите, как только я прихожу в какую-то новую
вершину, вот в эту вершину, например, где я галочку
сейчас поставил.
Что я должен сделать?
Я должен вначале сказать, что я начал с нее делать
обход в глубину, поэтому я из белого крашу ее в серый.
Потом я говорю, что время входа в данную вершину равно
плюс плюс тайм.
То есть время, которое сейчас, и сделать плюс один для
того, чтобы к следующей вершине уже подготовиться.
После этого я должен посмотреть всех ее соседей и у каждого
из соседей запустить рекурсивно ДФС.
Почему я у каждого должен рекурсивно запустить?
Ну потому что у одного с помощью этого ДФС я пройдусь
тут, у другого так, у третьего, ну не знаю, может он так-так
связан.
Вот.
Я опять же буду с помощью этого посещать абсолютно
все вершины.
После этого, когда я закончил посещать все вершины из
моих соседей, то есть вот эти все вершинки, которые
сейчас обвел, я могу сказать, что, ага, все обнаружено,
все сделано, я не могу больше найти никакого пути, поэтому
покрашу данную вершину уже прям в черный.
Вот делаю черный, ну и тайм-аут я тоже делаю в плюс плюс
тайм.
Понятно ли вам сутьевая часть обхода графа в глубину?
Можете написать в чатик плюсик и минусик.
Плюсик, плюсик, вижу.
А для чего нам вообще серый цвет тут нужен?
А для чего нам нужен будет серый цвет?
Серый цвет нам понадобится чуть подальше, он будет
необходим для циклов.
Вот.
Хорошо.
Можно, в общем виде можно сделать так, что да, первоначально
можно красить в белый и в черный.
Окей.
Вижу только плюсики, ни одного минуса не вижу, хотя
плюсов всего четыре.
Если какие-то у вас вопросы, давайте так.
Нету вопросов.
Хорошо, тогда у меня вопрос к вам, какое время работы?
Вот у нас есть В и Ж.
Пишите, пожалуйста, в чат ваше предположение времени
работы.
Ой, В и Е, прошу прощения, Ж.
Какое время работы у этого ДФСа будет?
В плюс Е.
Илья нам так говорит.
Почему В плюс Е, Илья?
Можно голосом ответить.
Или не хочется.
Возможно, не хочется.
Ладно, в действительности да, В плюс Е, но это только
в случае, если мы используем списки смежности.
Что нам нужно сделать?
Нам для каждой вершины нужно пройтись по соседам.
Если я хожу по всем соседям моей вершинки, то я просматриваю
всю строчку, которая у меня есть.
Всего строчек В, и в каждой строчке будет суммарно
всего Е таких переходов, потому что у меня есть Е
соседей.
Каждая вершина обходится один раз, но в действительности
мы сначала в неё входим, потом выходим, но по сути
своя да.
Но если мы говорим про матрицы смежности, то в этом
случае будет В квадрат, потому что вы должны пройтись
по всем вершинам, абсолютно для каждой вершины понять,
кто является её соседом.
Вот и всё.
Как-то так.
Теперь, в общем-то, можно придать какой-то конкретный
смысл цветам в DFS, которые нам необходимы.
Белая вершина будет означать, что из неё, из данной вершины
белой, не был запущен ещё ни один DFS-визит.
Серая вершина означает, что вызов DFS-визит был,
но он ещё не завершился.
Чёрная означает, что он завершился.
А серые вершины сами по себе всегда образуют путь.
Это вот такое вот интересное наблюдение, то есть если
вы возьмёте серые вершины друг за дружкой, они получат
вам путь в вашем графе.
Почему так?
Ну потому что это действительно путь, который сейчас на данный
момент проложен.
Вот.
И от этого мы исходим.
А в действительности, если нам необходимо будет
посетить абсолютно все вершины, а не только лишь
достижимые из данной, которые вот мы сделаем, то дополнительно
пишется просто цикл, что мы проходимся абсолютно
по всем вершинам.
В каждой вершине запускаем DFS-визит в случае, если у
меня цвет белый.
Ну грубо говоря.
Вот.
Я иду по всем вершинам, вот у меня есть вершина
там нулевая какая-то.
Я прохожусь по всем вершинам, которые достигаемые из
этой вершины.
А вот какую-то одну я не набрал.
Ну там, не знаю, пятую.
Вот это все у меня покрасится в серый.
А вот это будет еще белое.
Для того, чтобы пройти ее до конца, мне необходимо
всегда взять и сделать здесь DFS-визит.
В этом случае мы пройдемся абсолютно по всему графу
и перекрасим его.
Что нам вообще здесь DFS позволяет?
Ну первое, что есть, это тестительность и классификация
ребер при обходе графа глубину.
Это полезное знание, которое вам подскажет, как вообще
вглубит ваш граф.
Мы будем использовать эти факты в дальнейшем, когда
будем рассматривать, например, мосты и точки сочленения.
Пока что вам нужно их просто привыкнуть, что мы их будем
им называть так.
Первое, что нужно понимать, что если у нас есть какой-то
граф неориентированный, то деревом в этом графе мы
называем граф без циклов.
Деревом в ориентированном же графе называется граф
без циклов, в котором у всех вершин полустепень
захода равна единице, кроме одной, у которой полустепень
захода равна нулю.
Ну то есть, грубо говоря, дерево – это вот такое вот
чудо, вот это дерево в ориентированном графе.
Полузаход у всех единичка, кроме корня, к корню никто
не заходит.
И если вдруг вы оставите только лишь посещенные ребра,
то есть только те, по которым мы ходили, и ориентируем
их в том порядке, в котором нам необходимо, то DFS-визит
образует дерево обхода.
Если вдруг вам будет несколько DFS-визитов, то в этом случае
у вас будет не дерево обхода, а уже лес обхода.
Но мы будем рассматривать одно конкретное дерево
и по нему говорить о каких-то вещах.
И что вообще там происходит у нас само по себе.
Как-то так.
Какие существуют ребра, классификация некоторых
ребер.
Рёбра бывают ребрами деревьев, обратными ребрами, прямыми
ребрами и перекрёстными ребрами.
Что означает каждый из них?
Первое, ребро дерева – это ребро, которое принадлежит
к какому-то обходу дерева.
То есть если мы запустили DFS, прошлись по нему, то у
нас получается ребро дерева.
Обратное ребро – это ребро, ведущее из потомка в предка
в некотором дереве обхода, которое у вас есть.
Прямое же ребро – это ребро, ведущее из предка в потомка,
не являющийся его сыном.
Ну и перекрёстное ребро – это когда соединяются любые
вершины, которые вообще никак не связаны с понятием
предок и потом.
Представим следующую картину.
Вот я делаю здесь, ну давайте, я хожу по вершинкам, красненьким
буду выделять.
Вот у меня есть нулевая вершина, от неё я пошёл потом
во вторую, потом я пошёл в первую, третью и четвёртую
вершины.
То есть я вначале сходил по вот этому, потом сюда,
потом сюда, потом сюда.
Скажите мне, то, что я выделил сейчас красным, чем является?
Каким ребром?
Ребро дерева.
А?
Ребро дерева.
Ребро дерева.
То есть это то, как я ходил с вами в ДФС.
Теперь, ой, сейчас, было красно, встало не красно, нужно
как-нибудь готово.
Хорошо, давайте теперь выделим зелёное.
Вот это обратное из 3 в 0.
Это какое ребро?
Вы сами сказали.
Какое?
Обратное.
Понял, хорошо.
Да, это действительно обратное ребро.
Окей, давайте следующий вопрос.
Предположим, вот это 4,2.
Это какое ребро?
Из 4,2.
Прямое?
Прямое ребро.
Прямое... Ещё кто? Какое сказал? Перекрёстное. Перекрёстное. Ещё... Или всё.
А что мы вообще называем в данном контексте тогда предками и потомками?
Хороший вопрос. Вот давайте тогда с этим разбираться. Не зря здесь просто так этот пример.
Давайте смотреть. Вот это корень. 0 это корень. У корня есть потомок 1, потомок 1.
Ну, первого поколения, грубо говоря. У потомка первого поколения есть потомок 2, потомок 2.
Вот. Который относится к единичке.
Вот. А является ли 4 потомком или предком двойки?
Нет. Нет. Потому что заход один только.
Да, то есть смотрите, оно не входит в это понимание. Для 4 является предком 1, а для 1 является предком 0.
Вот. А у двойки не является 4 потомком.
Поэтому здесь это действительно перекрёстное ребро.
Потому что у нас нет никакого отношения предок потомок. Мы никак с этим не работаем.
Окей. Ну и последнее ребро, которое у нас здесь осталось.
Ну давайте каким цветом-то выделить это всё. Давайте пусть будет синеньким.
Вот это вот 0,4. Это какое ребро?
А, друзья.
Давайте я вас верю. 0,4 это прямое.
Прямое ребро. Потому что у нас есть предок, есть потомок. Просто они не связаны с пониманием сына.
Да. А у меня тут немножко цвета отличаются, но суть всё равно остаётся такая же.
Давайте я где-нибудь здесь на всякий случай нарисую, что прямое вот это синенькое.
Дальше у меня здесь красненькое. Это у меня ребро такое.
А что у меня тут зелёное? Это обратное.
Это обратное. Ну и последнее это у нас фиолетовое.
Вот. Как-то так.
Такая вот классификация ребер.
Это классификация ребра.
Как определить вообще тип ребра во время ДФС? Как вы думаете?
Вот с помощью всего того, что мы с вами говорили, а что у нас есть?
Свет и у нас есть время входа, время выхода.
Как нам определить, что это вообще такое?
Если оба серые, то можно понять это либо обратное, либо прямое, либо ребро дерево там, по времени.
Если о серых, то по времени понять. Как это понять?
Ну если у одного, если ребро идёт из меньшего времени в большее время, то это...
И разница больше единицы, то это прямое. Если равна единице, то это ребро дерева. Если меньше нуля, то это обратное.
Ну, почти, но окей. Да, в действительности, похоже на правду, есть просто некоторые нюансы.
В действительности ребро дерева это всегда какое ребро? А в какую вершину всё это будет вести? Цвета.
Ну то есть я нахожусь в какой-то вершинке серый, и вот я иду в новую вершину. В какого цвета эта вершина?
Белая.
Может ли хоть одно ребро вести тоже в белую вершину?
Вроде бы нет, потому что обратные ребра, прямые ребра и перекрёстные ребра, они уже связаны между собой, и там они уже были посещены.
Поэтому ребро дерева это в белую вершину.
Что такое обратное ребро? В какую вершину смотрим мы здесь?
В серую.
В серую. Можем ли мы смотреть в чёрную?
Нет.
Нет. Почему?
Потому что обход не завершился.
Потому что обход в действительности не завершился. То есть мы смотрим на какого-то нашего предка.
И осталось прямое и перекрёстное ребро. Вот прямое и перекрёстное ребро, каждый из них смотрит в чёрную вершину и в чёрную вершину.
И вот здесь нам на помощь приходит время тайм-ин и тайм-аут.
Чем отличается прямое ребро и перекрёстное ребро?
В прямом ребре как связано? Ну пусть у меня ребро ВУ.
Оно должно быть прямым, например.
Как связано тайм-ин В и тайм-ин У?
Вот как это связано между собой?
Время входа в вершину В и время входа в вершину У.
Что такое прямое ребро? На всякий случай, когда у нас вот такая вот концепция есть.
Вот это ребро.
Вот здесь у нас получается В, вот здесь У.
Так чего?
Какое это ребро?
Ну тайм-ин меньше УВ, если прямое.
Тайм-ин меньше УВ. А у перекрёстного как это будет связано?
Ну видимо наоборот, тайм-ин УВ больше.
Почему?
Иначе это прямое.
А вдруг не по тайм-ину? Мы должны сравнивать.
Давайте чуть более подробно. Почему так?
В действительности дата у таймина В будет меньше, здесь у таймина В будет больше.
Правда так, никто не спорит.
Что же здесь происходит? Почему так?
Ну смотрите, что такое прямое ребро? Прямое ребро это когда мы дошли до потомка какого-то, с которым мы будем опять же связаны.
Значит мы не могли прийти в этого потомка раньше, чем мы находимся в родителе.
Поэтому тайм-время входа в родителя гораздо меньше, ну не гораздо, а просто меньше, чем время входа в потомка.
Если мы говорим с вами про перекрёстное ребро, то мы уже должны были обойти вершину У и всё, что с ней связано, и только потом прийти к вершине В.
Поэтому естественно время входа в вершину У будет меньше.
Вот, как-то так это выглядит. Я надеюсь, что вы это представляете.
Естественно, классификация ребер есть ещё и в неориентированных графах, но в неориентированных графах я утверждаю, что есть только древесные и обратные ребра, других нет.
Понятно ли это почему?
Да, вы молчите, мне страшно.
Ну, потому что у нас не может быть чёрной вершины, в которую мы ведём, потому что мы должны были её, как бы, из этой вершины обойти.
Да, у нас не может быть конкретно чёрной вершинки.
По той причине, что мы в действительности бы оказались в этой вершине, будь у нас неориентированный граф, потому что оно связано в две стороны.
Именно так.
Окей, теперь нужно немножко поговорить про корректность данных алгоритмов, корректность ДФСа, что вообще с ним происходит.
Давайте докажем несколько утверждений.
Окей, теперь нужно немножко поговорить про корректность данных алгоритмов, корректность ДФСа, что вообще с ним происходит.
Давайте докажем несколько утверждений.
Первое утверждение о ДФС.
Ни в один момент времени не может быть ребра из чёрной вершины в белую.
Почему?
Если мы сказали, что вершина чёрная, значит мы обошли всех её соседей.
Да.
А если у нас, к примеру, есть такая вершина, ну, предположим, что-нибудь обратное, и у нас есть из чёрной в белую, тогда рассмотрим момент, когда вершина В стала чёрной,
а этому предшествовал как раз таки цикл по всем соседям нашей вершины В.
В этом цикле встречалась белая вершина У, и значит она была просто пропущена этим циклом.
Поэтому у нас противоречие с нашим алгоритмом.
Возможно ли все остальные варианты, то есть из серой в белую, из белой в белую и так далее?
Вот вам нужно об этом подумать.
Как сказать, что это можно? Привести пример на каждый из этих вариантов.
И существует так называемая лемма о белых путях, которая звучит так.
Вершина У будет посещена в процессе DFS-визита тогда и только тогда,
в процессе вызова от вершины В, тогда и только тогда, когда в момент вызова DFS-визита в вершине В
существует путь из В в У, состоящий только из белых вершин.
Вершин.
Согласны ли вы с данной темой? Понятно ли, что здесь сказано?
Давайте еще раз, напишите плюсики, если понятно, что написано в теории.
Надеюсь, вы напишете их все-таки побольше, чем четыре штучки.
Вас тут все-таки двадцать.
Один плюсик вижу, все остальные понимаете ли вы, что происходит?
Два вижу, три, четыре нет.
Илья, что именно непонятно?
Какой момент смущает?
Илья?
Илья не хочет отвечать, ему просто не нравится. Окей.
В общем-то, что у нас касается этого момента?
В действительности здесь Лемма о белых путях говорит нам следующее.
Говорит нам о том, что у нас есть вершина В, откуда мы запускаем, есть какая-то вершина У.
И вот этот вот путь существует в эту вершину только в случае, если на пути к этой вершине У у нас будут встречаться только лишь белые вершинки.
В другом случае у нас не будет никакого пути, то есть мы мало ли запускали еще где-то ДФС, там уже все было сделано.
Данная теорема доказывается. Доказывается достаточно просто.
Рассмотрим сначала в одну сторону. Вершина У будет посещена в процессе вызова ДФС визит.
Тогда в момент вызова ДФС визит существует путь из В в У, состоящий из белых вершин.
Но это логично. Если мы вызываем ДФС визит от вершины В, тогда в этом случае просто посещая чисто эти белые вершины, которые есть в пути, в которые нам говорится о том, что есть.
Мы доберемся до вершины У, значит у нас существует путь из В в У по белым вершинам.
Это логично. Если мы посещаем нашу вершинку, то означает, что был такой путь по белым вершинам.
Как-то же мы пришли, значит все хорошо.
Теперь в обратную сторону.
Нам нужно доказать, что если у нас существует путь из В в У, состоящий из белых вершин, то вершина У будет обязательно посещена в процессе вызова ДФС визит.
Как это доказывается? Доказывается следующим образом.
Давайте рассмотрим какой-нибудь белый путь из В в У.
Из В, потом до вершины В1, В2 и так далее, до У.
В момент завершения ДФС визит, вершина В черная. То есть в момент, когда мы завершаем наш ДФС, она черная.
А на рассматриваемом пути сами по себе нет серых вершин, потому что все рекурсивные вызовы завершились.
То есть не может быть такого, чтобы у нас из черной было в серую в данный момент времени, потому что мы всю рекурсию закончили.
Значит не одна вершина, она либо белая, либо черная.
Вот. По утверждению один, на этом пути нет черно-белых переходов.
Значит есть только черно-черный.
Значит все вершины на этом пути стали черными. То есть они были посещены.
Поэтому вершина У тоже была посещена.
Понятен ли механизм рассуждения здесь?
Друзья, если вы будете молчать, это будет только хуже.
Один плюсик вижу.
От Степана.
Есть ли еще что-то?
Или нет?
Еще один вижу. Еще один вижу. Отлично.
Хорошо.
Окей. Поехали дальше.
Дальше. Вот у нас DFS есть.
Какие вообще есть применения у DFS само по себе?
Смотрите.
У нас существуют компоненты связности и достижимые вершины.
Излемы вообще о белых путях следуют, что при запуске DFS Visit мы можем посетить только вершины,
в режимы из В. То есть все вершины мы посетить прям не сможем,
но все возможные вершины, до которых мы можем добраться, они же все являются белыми в самом начале,
то до всех вершин мы с помощью этого DFS дойдем.
И это чудесно.
А как это можно сделать?
Ну смотрите. Вы просто запускаете DFS Visit и смотрите.
Ага, вот до этих вершин дошел, вот до этих нет.
Что означает, что вы не дошли до вершины?
Означает, что нет такого пути из В в У.
И это может говорить о компонентах связности.
Компоненты связности, вот если мы говорим будем про инертированный граф,
то компонент связности инертированного графа это максимальный по включению связанный под граф.
Ну то есть компонент связности это максимум того, что мы можем свяжать.
И запуск DFS Visit в любой точке В на полностью белом графе найдет эту компоненту связности,
который принадлежит В, именно в неориентированном графе.
Почему? Ну потому что в этом случае мы просто посетим все вершины, доступные из нашей вершинки В.
И все будет хорошо.
И вот здесь можно будет проверить еще иоцикличность с помощью DFS.
Я утверждаю, что в графе G есть цикл тогда и только тогда, когда при обходе в глубину была найдена серая вершина.
То есть грубо говоря, вот мы зашли в наш вот этот вот восхитительный граф.
И в какой-то момент мы встретили вот из серой вершины в серую вершину.
И говорим, ага, это значит, что у нас есть цикл.
И будем отталкиваться именно от этого.
Как это доказывается?
Ну смотрите, доказательства в левую сторону, что у нас при обходе была найдена серая вершина, значит графия из цикла достаточно простая.
А серые вершины – это у нас индикатор обратных ребер.
Обратное ребро ведет в предка в обходе дерева.
То есть у нас в дереве обхода есть цикл.
Но если у нас в дереве обхода есть цикл, то у нас и в графе тоже есть цикл.
Прямо заметьте, дерево обхода само по себе – это цикличный граф.
Но в том случае, когда мы добавляем все остальные ребра, он может не быть цикличным графом.
Поэтому с серыми вершинами достаточно все просто.
То есть грубо говоря, по белым мы прошлись в одну сторону, серые из серого означают, что есть обратное ребро.
Значит мы по этому обратному ребру можем вернуться к нашему предку и заново пройтись по этому же пути и опять вернуться.
Поэтому здесь цикл есть.
Посмотрим по обратную сторону.
У нас есть цикл.
Нужно сказать, что при обходе графа в глубину мы найдем серую из серой вершины.
Давайте рассмотрим какой-нибудь цикл.
В0, В1 и так далее. Вн равный В0.
То есть последняя вершинка – это В0. То есть мы зациклились между собой.
Пусть без ограничения общности В0 – это первая вершина в этом цикле, которая была посещена во время обхода.
То есть первая вершина, в которую мы вошли в данном конкретном цикле.
Тогда по лемме о белых путях в процессе посещения В0 была посещена вершина ИВН-1.
Но это же связанный цикл.
Значит посетить эту вершину ВН-1 можно.
А так как из этой вершины вело ревро в серую вершину В0, то в этом случае мы получаем наш цикл.
То есть мы пришли из серой вершины в серую, значит у нас все плохо.
То есть цикл есть, и с циклом мы получили, что мы получим все-таки в случае, когда мы придем из серой вершины в серую.
Есть ли тут вопросы с проверкой на цикличность?
Нет, да, да, нет.
Вы чего-то сегодня очень общительные, я понял. В онлайне вы не любите общаться, видимо.
Хорошо.
Ладно, ой.
Ну как это описать, всю эту проверку на цикличность?
Ну давайте просто напишем нашу функцию hasCycleDFS.
Ну и что мы делаем? Мы говорим, что colorV у нас равен gray в самом начале.
Все так же они были в начале, все white и так далее.
Но мы не делаем никаких таймынов, тайм-аутов, они здесь бесполезны.
И как мы делаем?
Как мы делаем?
Мы говорим, что color и все white.
Для всех вершин из нашего графа мы проходимся по ним.
И если у нас цвет white, тогда в этом случае я запускаю это DFS.
Дальше это DFS делает серую вершину, проходится по всем соседям.
Вот все соседи, которые есть.
Если вдруг мы встречаем серую вершину согласно той теории, которую мы только что доказали, то мы возвращаем true.
То есть у нас есть цикл.
Иначе, если мы находим белую вершину, то опять запускаем цикл.
То есть это все тот же самый DFS.
Просто вот именно чисто с белыми, серыми, черными вершинками.
Ну и дальше мы просто идем по этому нашему циклу.
И смотрим, что у нас там происходит.
Дальше у нас здесь colorV равен black и return false.
Прямо заметьте, вот в этом if-e для того, чтобы завершить все рекурсии корректно.
У меня if-cycle DFS, тогда в этом случае true.
То есть он по умолчанию возвращает false.
Но если вдруг он нашел цикл, то он вернет, что он нашел цикл в предыдущий.
И так далее ко всем предыдущим нашим рекурсивным вызовам.
Вот.
Какие есть задания еще, что может понадобиться?
Может быть понадобится восстановление цикла.
Тогда это можно сделать с помощью parent.
То есть откуда я пришел в какую-то точку.
А как это сделать?
Ну смотрите, вот у нас есть этот цикл.
Вот.
И я, к примеру, знаю, что я пришел с нулевой, первой, второй, третьей, четвертой вершины, пятой.
Я знаю, что для нуля у меня parent получается минус один, для единицы ноль, для двойки единицы, для тройки двойка, для четверки тройка, для пятерки четверка, четвертая вершина.
Четвертая вершина, если что.
Четверка, а дальше я попадаю опять, ой, опять в ту вершину, которая уже была посещена.
Тогда давайте я раскручу данный стэк обратно, к примеру, по посещению.
Тогда у меня получится пять, четыре, три, два, один и все.
То есть я должен дойти до той вершины, на которую я указывал.
Дальше я могу развернуть, могу не разворачивать этот цикл, как вам удобнее, но вообще лучше развернуть, особенно если у вас ориентированный граф.
То есть получится цикл один, два, три, четыре, пять.
Можно делать таким вот образом.
Проблема цикличности еще в неориентированных графах.
Почему в неориентированных графах здесь возникает проблема?
Как вы думаете?
Что вам не нравится?
Или нравится?
Может быть цикл из двух вершин?
Цикл из двух вершин, да.
То есть в неориентированном графе в действительности, когда у вас связаны вершинки между собой просто одним ребром, вы можете ходить в одну сторону, в другую сторону.
И вот у вас появляется цикл.
Здесь нужно чуть-чуть аккуратнее это все смотреть и не использовать какие-нибудь определенные ребра.
Вот.
Чтобы вот этого не происходило, то есть мы должны в действительности отдельно рассматривать случаи, когда у нас сосед родитель деревья обходу.
В этом случае нужно удалять эти вершины, эти, грубо говоря, ребра.
Какие есть еще проблемы?
Здесь.
Ну смотрите, в случае кратных ребер у нас будет беда с пунктом два.
Потому что родитель может вести в другое ребро.
Что нам с этим делать?
Как вы думаете?
Беда.
Так, вы точно понимали, что я сейчас рассказываю?
Да, нет, не знаю.
Я не понимаю, ну как бы я второй пункт понимаю, а в чем суть третьего замечания нет?
Можете пояснить?
Представим, что у меня есть кратные ребра.
Вот.
И что означает, что в родителе может вести другое ребро?
Ну представьте, что у меня вот раз ребро, а это ребро другое, вот это первое, вот это второе.
Второе ребро другое, для него мне смотреть сложно отдельно.
Отдельно.
То есть это же для меня новое, полностью новое ребро.
Согласны?
Да.
Вот, из-за этого.
А правда, мы не увидим со старым ребром, что там уже серая вершина и какая там будет вершина.
И не надо идти туда.
Ну, здесь, смотрите, здесь есть нюанс.
То есть с одной стороны это правда.
С другой стороны, а что делать, к примеру, может ли быть такое, что у нас просто есть из серой в серую вершину?
Ну если у нас есть кратные ребра, то это же сразу цикличный граф.
Ну оно и без кратных ребер сразу цикличное.
Мы считаем цикличные ребра за цикл?
Кратные ребра за цикл.
Кратные ребра за цикл.
Вот это хороший вопрос, ровно так же, как мы считаем, что неориентированный граф всегда цикличный или нет.
Цикличный ли вот это?
С одной стороны, да.
С другой стороны, нет.
Вот.
В общем-то в действительности с этим всем у нас есть суть примерно следующая, что если вы увидите хоть одно в действительности повторяющееся ребро, то в этом случае вы гарантированно получите цикл.
То есть, если вы хотя бы вот такой случай можете отдельно обработать с одним конкретным, то в случае, когда у вас есть вот так ребро и есть вот так, то в этом случае вы ничего сделать не сможете.
У вас точно есть цикл.
То есть, мы будем считать именно таким вот образом, что если у нас просто одно ребро, то цикла еще не будет.
Но если у нас есть 2 кратных ребра, то цикл уже будет.
Будет.
Смотрите, мы очень быстро сами прошлись по DFS-у.
Меня это немножко смущает, но, возможно, это потому,
что это всё в онлайне.
Вот.
И я не вижу ваших лиц, и от этого непонятно, точно
ли вы понимаете, что происходит.
Понимаете ли вы, что сейчас было?
Да.
Всё понятно.
Напишите алгоритм DFS-а просто вот так.
Правильно?
Ну, не вот так там, но, по крайней мере, понятно,
что делать.
Понятно, что делать.
Посидеть придётся немного.
Лучше всего позадавайте какие-нибудь вопросы на этот
счёт.
Но последнее, что на сегодня вообще в действительности
хотел бы вам сказать, это про сильную и слабую связанность
вообще в графах.
Что это такое, как это происходит?
Мы как-то поднимали с вами вопрос на прошлой лекции.
Мы будем это делать ещё на следующих лекциях.
Но вообще неориентированный граф связанный, ну, когда
мы можем из любой вершины попасть в любую другую.
Ориентированный граф же подразделяется на слабосвязанный
и сильно связанный.
Слабосвязанный граф – это если мы его, все ребра, которые
ориентированы, сделаем неориентированными ребрами
и посмотрим, будет ли связан граф.
В этом случае граф будет называться слабосвязанным.
То есть если у него в действительности после того, как мы заменили
все ориентированные ребра на неориентированные, связанность
есть.
Ориентированный же граф сильно связан, если из любой
другой вершины, из любой вершины в любую другую можно
добраться.
С помощью этого можно в действительности находить
компоненты сильной связанности.
Можно находить это с помощью DFS.
Фэса. Этот алгоритм мы рассмотрим уже в следующий раз. Вот, мы очень быстро с вами идем, тогда я,
наверное, следующую лекцию чуть больше поднагружу, чтобы все было понятно. Хорошо? Как-то у нас
действительно очень быстро получилось. Есть ли у вас вопросы? Ладненько, тогда давайте считать,
что фактически это все на сегодня. Мы с вами поговорили про DFS, посмотрели, что это такое,
как с этим работать, как с этим жить. В принципе, следующие уже лекции будут посложнее,
побольше по качеству. Назову это так. У нас будут уже алгоритмы с типологическими сортировками,
скорее всего, но я еще точно об этом попозже вам скажу. Хорошо? Все тогда, хорошего всем вечера!
