итак мы обсуждаем мистическую мягкую кучу ну в прошлый раз она выяснила что она не такая уж и
мистическая данная надеюсь она станет сегодня еще менее мистической ну не но она очень жесткая
она никогда и не была в общем-то нет она очень вот она очень добрая да она же даже и как раз
можно назвать жесткой структуру данных которые даже не требует которая даже не требует чтобы там
ответ который выводит был правильный ну как можно такую структуру данных называть жесткой
реально вот то есть ну давайте вспомним как бы это ашо но то что мы вообще хотим то есть мы хотим
мистический черный ящик который ведет себя как абсолютно но как то есть как некая куча ну то
есть обладает операциями там ставить элемент там что там будет здорово там получать минимум
достать минимум
вот а ну слить две кучи естественно
так все или что-то у нас еще было а мы хотели удалять а ну в принципе не глобально можно удалять
так сказать удалять по итератору ну да как мы помним как да как мы сейчас помним удалять это
вообще это вообще бесплатно практически так ну давайте смотреть что там оно вот и мечта у
нас была какая мечта у нас была в том что мы заведем мистический параметр epsilon там от нуля
до одной второй где-то вот и получалось что insert вставка у нас будет работать за логарифом
один делить на epsilon а все остальное за единицу вот такое вот мы себе неожиданно заявили так вот
но правда вытекает ощущение что чем чем больше epsilon тем как бы меньше insert более того если
epsilon 1 2 или 1 третья то это выглядит вообще как тоже вот единицы вот но казалось бы да у
нас уже было ощущение что куча в которой все операции делаются за вот единицы невозможно в
принципе вот но собственно да так и есть потому что до нас никто не сказал что экстракт мин будет
доставать именно минимум но логично вот то есть что у нас вместо этого будет сделаться но напомним
вариант то есть напомню что мы считаем что вот у нас есть каждый элемент x и у каждого элемента
есть псевдоним вот даже нет мы даже по-другому называем вот есть ключик вот элементы называются
обычно ключами а есть так называемый ck вот так вот как мы помним у нас идея в том что каждому
ключу что внутри кучи у каждого ключа есть псевдоним это какой-то элемент который не меньше
ключа смол если повезет он будет совпадать с ключом но если нет то нет и идея будет в том что
вот что значит куча для того чтобы ей было как-то удобнее она будет доставать минимальный элемент
именно по вот этому параметру они по какому-то ключу вот но что нам обеспечивает что это хоть
насколько работает адекватно обеспечивает маленький там приятный вариант что если в
кучу или все ее вот эти там мелдосоставляющие суммарно было добавлено не более чем n элементов то
есть условно было не более чем n инсертов то тогда нам гарантируется что испорченных элементов у
нас не сильно много то есть у нас не сильно много то есть не сильно много это не более чем
epsilon n элементов с ck строго больше чем наш ключ не размер кучи 100 элементов да и у нас
абсолютно верно да совершенно верно да то есть помните именно да то есть важный момент
действительно именно n инсертов но ты именно n инсертов то даже то есть там сколько сколько
из них было уже с кучей удалено тем или иным способом нас не интересует совершенно верно
вот да но заметьте то есть замечаем что вот такой вот возникает trade-off в том плане что чем
больше epsilon тем как быстрее работает куча но тем соответственно и больше испорченных элементов
то есть условно там более широкими москами она эти элементы как-то портит а как вообще куча
порчит элемент но вряд ли как бы было у нас камешек веса 57 да она его себе скушала а потом
там пожевала пожевала потом как-то кто выплевывал и сказала о конфетка нет ну совсем наоборот вот
как-то вряд ли то что достаточно испортила то что дали историку хэллоу ворлд она об том она
возвращает там я не знаю там вася ты козел там вряд ли вот но таки как она их портит
но как но она но на самом деле как бы да и портит это мы и так условно говорим она портит а за
ли внутри себя она ничего не портит она просто но она просто начинает замечать что некоторые
элементы для нее на одно лицо вот то есть это означает следующее что то есть реально
для того чтобы у нее была поменьше асимптотика она старается сохранить чуть-чуть поменьше
элементов вот но значит у каждого элемента то есть вот есть элемент ck вот и но на самом
деле с ним связано связан целый лист элемент то есть лист конкретных элементов там вот сколько
то там их будет там ну ка в это допустим ну про их бы то гарантирую что у всех этих элементов
вот псевдоним вот такой вот то есть так вот охитно просто говорим что это у нас это все у
нас на одно лицо вот соответственно ну это вот ну и как-то значит но идея будет тогда
простая соответственно чем больше epsilon тем тогда там чаще она все элементы будет запихивать
собственно в один господи как-то называть то нормально а то у меня в голове опять только
слово автозак собственно крутится вот автобус да то же самое лимузин ух ты не лучше автобус тогда
но вот ладно автобус так автобус чушь шикарно ладно так кошмар что мы тут обсуждаем вообще так
но вот так же соответственно тем но тем более активно значит товарищи будут собственно
оказываться в каких-то автобусах вот соответственно но теперь давайте вспоминать как же мы это пытались
делать но первая идея который у нас возникало это то что но первая идея то есть мы конечно
работаем на базе бенмельной кучи но ситры бенмельной кучи то есть мы тут неожиданно решили что у нас
массивов не будет давайте ну глядя на автобус это сложно предположить но на самом деле помним это
лист причем не в питонов самом смысле вполне себе в си штам то есть для чего это сделано это сделано
для того чтобы два автобуса можно было легким движением руки превратить в один соответственно
вот мы помним вот но как же хранится сама куча бенмельной кучи казалось бы викшины может быть
детей сколько угодно вот но мы выкручиваемся там простым естественным скопках нет образом то
есть мы говорим что у каждой вершины на самом деле есть два указателя указатель next и указатель
child вот они вот такая красота то есть вот такие note то есть такие вот next и на каждой вершинке
кроме самой последней там висят ну на самом деле вот под деревья детей то есть вот как-то так это
примерно и выглядит причем что он вот причем заметим что это типа одни эти нот то есть что
что мы тут еще что у нас тут еще есть то есть это все одни и те же вершины то есть это как бы
вообще одна и та же вершина просто у нее вот в данном случае пятеро детей как мы это работаем
но работаем по принципу что но вот работаем что это у нас типа самый ранговый ребенок но вот это
чуть ранг поменьше и так далее до важный момент у каждой вершины то есть у каждой вершины такие
у каждого экземпляра вершины есть ранг ну в идеальной бенмельной куче то есть если бы там вот
не заморачивались то обычно если у нас тут ранг допустим 8 то это означает что у нас нет лучше
где у нас был ранг 9 это означает что у нас тут под деревья 2 в 9 различных ключей вот помните
да это в идеале вот но но вот но сейчас конечно такой вариант пропадает потому что из-за как вы
особенности удаления от которых мы поговорим чуть позже вот но пока же мы говорим так что у нас
действительно у каждой вершинки есть ранг причем более того соблюдается инвариант что у любой
вершины любая вершина указывает на next и на child и они обязаны быть одинакового ранга строго
меньшего чем наш но насколько меньше непонятно то есть может быть на там на 1 может быть на 2
может быть на 3 там самые разные случаи бывают вот но главное что чайл да на чайл днx у нас
смотрят в одну сторону вот и так но вот но соответственно где же хранятся сами ключи но
сами ключи хранятся тут ну тут все очень просто тут у нас значит ссылки на автобусик вот он
и с каждой вершины вот вот конкретно вот то есть вот такой так как выглядит у нас
бенемиальное дерево и рангом этого бенемиального дерева мы считаем соответственно ранг корневой
вершины вот но естественно но естественно у нас не все элементы хранятся в одном дереве вот так
что он вот они у нас хранятся в целый последствии ну как положено бенемиальная куча бенемиальная
куча это набор бенемиальных деревьев попарно различных рангов желательно еще и отсортированных
помните да вот ну давайте вспомним чем у нас отличие но то есть чем у нас правда этот вот
но этот набор деревьев отличается от обычной бенемиальной кучи ну они не совсем не совсем
бенемиально хотя до при до момента с автобусами можно считать что это просто оригинальная
реализация бенемиальной кучи на самом деле вот ну тут есть еще но вот ну хорошо да еще
вот у нас есть действительно какой-то вот такой список и какая-то но вот но в каждом списке и
что в каждом элементе этого односвязанного списка есть конечно же указатель на корень своего
дерева может быть даже укрыт даже его ранг еще можно написать так но в нем есть конечно то что
обычно в кучах так просто не хранят да то есть мы тут неожиданно решили завести из каждой вершинки
указатель суффикс мин вот то есть важный момент то есть ну конечно в обычной бенемиальной кучи мы
просто хранили указатель где находится минимум просто где из них там вот находится минимум вот
но здесь мы идем более крутым способом мы заявляем что давайте то есть давайте для каждого элемента
хранить где вот среди тех кто идет дальше находится минимум вот кто из дальше далее
идущих минимален вот это оказывается нам дает некоторое удобство какое удобство это нам дает
ну вот выясняется что в принципе такая фишка дает нам возможность то есть дает нам
возможность сливать действительно за быстро но да и нот ну каким образом ну то есть слил нот
ну идея оказывалась давайте тоже вспомним очень простая вот да ничего страшного что
это сейчас все воспоминаю или можно сейчас не воспоминать и просто сразу дальше идти
вот давайте ну давайте да но тогда и вот я попрошу из под стола вылезти а то знаете как-то
я не до а то мне тоже очень честно хочется называется тоже так из под стола вещать но
честно говоря я не уверен что лекция будет эффективно вот так вот значит но давайте
значит давайте смотреть как значит и что нам дает суффикс мим вот зачем он нам нужен вот
оказывается он позволяет делать мэлт казалось бы тоже самое слияние но гораздо эффективнее почему
но потому что давайте вот если кратенько так вспомнить то есть оказывается то есть ну
действительно у каждой кучи есть вот максимальный ранг под дерево ну допустим там тут 57 у соседнего
дерева 179 ну допустим такое да ну сложно я понимаю до сложности такой представить реальной жизни но
все-таки вот и тогда получается что тогда утверждается что мы слить эти две кучи можем
за от 57 но 58 хорошо хорошо 58 плюс количество объединений деревьев почему так но в этом да вот
мы в прошлый раз действительно обсуждали действительно тут возникают моменты но потому
что тут действительно такая вот допустим у нас есть тут лист какой-нибудь такой вот какой-то
вот такой там допустим то допустим вот тутran 57 допустим да то трап побольше то есть тут это
не значит что тут где-то больше элементов где-то меньше тут их может быть вот т.е. нас интересует
именно транс последнего на сам сп lavoro все какие-то вот такие вот такие и тут вот
неожиданно там еще вот такие вот такие и тут вот рамка 179 условно вот
но тогда утверждается следующее да то есть за от 50 то есть когда мы будем идти тут двумя
указателями честно сливать столбиком вот то к чему нас это приведет это нас приведет к
тому что соответственно здесь у нас будет то есть здесь мы там за 50 там от 58 соответственно
тут что-то сольем сольем сольем сольем сольем вот и максимум что у нас тут вы максимум что от
этого произойдет то есть у нас тут будет значит уже какой-то список и здесь еще какой-то может
быть элемент ранга 58 может остаться случайно но например если тут 2 2 50 седьмых было например
или там еще по какой причине вот но что будет происходить дальше но заметим что дальше максимум
что может произойти это вот несколько идущих подряд вот там каких вот 58 59 60 и так далее но
с которыми вот это то есть вот это дерево будет по одному сливаться но будет происходить тогда
но тогда то есть сколько-то действующего произведет но каждое это действие будет
превращать два дерева в одно то есть 58 50 седьмых там 59 но все-таки 9 60 60 и так до тех пор пока
тут рамки идут подряд вот то есть вот поэтому я и говорю что реально то есть время работа реально
время работы melda оно не превосходит значит единицы плюс минимального ранга ну минимального ранга
максимально там как минимального максимума рангов в кучах вот так соответственно это нот
и плюс еще количество так сказать объединение деревьев вот вот ну в этом месте мы там начинали
вводить какие-то монетки но можно в принципе сейчас уже сказать что то есть заметим чем у нас
приятно да у нас приятно тем что как мы уже знаем никогда там никакие операции там ранг корни особо
не поменяют то есть при себе ну в том плане что если у вершины есть какой-то ранг он уже навсегда
вот и мы не чувствуем но ты но то есть давно в нем конечно уже два в 57 вершин может и не быть
случайно но как бы тем не менее называется она вот она такого ранга будет вот и тогда
чему это нас приведет это нас придет с одной стороны но но с другой стороны заметим что
сколько у нас вообще создается деревьев различных да вообще да но на самом деле да
заметим что у нас на самом деле деревья создаются прям с нуля но только в то только в тот момент
когда у нас появился insert да потому что как у нас делается insert мы создаем дерево ранга
ноль из этого элемента там создаем ну там создаем даже такую пара там кучу из одного элемента
с этим одним деревом а потом ее сливаем со всем остальным только в этом месте у нас
создается куча новое дерево да и но новая кучу тоже не важно сейчас вот после этого деревья
могут там то есть сами по себе деревья могут только сливаться но может еще быть так что
внутри какого-нибудь дерева еще произойдет какой-нибудь безобразие там да может так
случится что дерево когда-нибудь вообще и исчезнет кстати ну потому что если выяснить что из него
там достали там допустим все элементы но хотя нет до этого мы доводить не будем вот на самом деле
вот но тогда получается что но из этого следует важный момент то есть как бы есть у нас всего
они могут только сливаться то тогда вы вынуждены заключить что слияние деревьев вот таких вот
одинакового ранга будет суммарно в жизни не более чем n да и то не точная оценка их будет
n-1 и то не более вот и что ж тогда происходит но вот тогда но тогда получается что с точки
зрения амортизации на самом деле мы вот эти сами вот эту вот часть слиятельную можем не учитывать
ну в прошлый раз мы это объяснили себе так что когда когда дерево создается мы кладем на него
специальную там какую-нибудь отдельную там серобурмалиновую монетку которая занимается тем
что которая отвечает за слияние то есть когда нужно слить два дерева то есть на каждом из них
лежит по монетке мы тратим одну из них на то чтобы слить а вторую собственно кладем на свежее
испеченное дерево логично да так было дело так воспоминается вот хорошо вот и так так на
ситуацию но то есть мы себе это так можно так объяснять можно просто объяснять что их там
суммарно то есть в принципе там там как старт статьи там там там больше скажешь скорее что ну
тут понятно что слияние будет не более чем n поэтому да вот ну то есть нет то есть пока
вот эту часть действительно амортизировано можно не учитывать вот но здесь все оказывается
гораздо хитрее потому что то да потому что но он говорит что мэлт действительно теперь работа
вот эта часть равно работает за от единицы почему но потому что тут мы начинаем ссылаться ну потому
что есть же сведения о том что у нас если у нас там т от н равно там допустим там от единицы плюс
там я не знаю логмин из там т от н и т от н минус м да то из этого следует что т от н там
т от н равно от н вот чего чего следует
так хорошо да давайте т от м плюс т от н минус м плюс
там логарифом двоичный минимум а прям из н и м минус м да ну хорошо так так ну вот ну вот есть такое
сведение оно очень известно его можно идти в литературе смотри там где-нибудь копайте там пятую
страницу вон какой-нибудь там статьи вот этой вот но вот ну или ну или в любом уважающем себе
в этом курсе есть такое домашнее задание естественно но соответственно там ну вы чем
как угодно я ну кстати же не напишешь как бы ну как бы но в овощу этого вузе не учили что ли
шоу надо шоу в науке делаете поэтому там приходится ссылаться на статьи вот но вот и
какая-то другой вопрос по-хорошему но есть такое утверждение да возможно его даже можно доказать
но возникает просто пить шоу ничего но вот нет ну нет на самом деле сейчас нет уране действительно
не больше чем логарифа сейчас сейчас вот давайте разъяснить потому что да действительно да тут
действительно не очевидно действительно как это вообще вот с этим связано чем более того даже
есть более простой вопрос на самом деле как это почему-то вот было почему-то интуитивное
ощущение что транги не происходит логарифма спрашивать так кто сказал если раньше бенемиальные
кучи мы могли такое заявить потому что у нас как-то там оказывалось что в дереве ранга x 2 в степени
x элементов ровно было но здесь как мы помним что-то так и такого уже нет потому что там оно потому
что какие там чисто теоретически может уже там произойти на самом деле все что угодно
да вот да да да да нам приходится действительно тут немножко выкручиваться и мы это делаем так
что мы говорим что до ключей у меня может быть два степени x нет но память о них в моем сердце
то есть говорим мы что то есть там что каждый declare то есть каждый вершины
ранга x соответствует вот там можно сказать капсум пишем два степени x элемент как
это соответствие передается но очень просто ну во первых мы говорим что у нас жила была одно
вершина т. unrestr�� есть одна вершина Ранга 0 то вы говорим что она сама себе соответствует и
хорошо, а дальше мы говорим, что когда мы объединяем два дерева одинаковых рангов,
как мы их, кстати, объединяем, да, то есть объединяем очень просто, у нас
создается новая вершинка, да, у нее там, но вот эти два дерева, к ней вешаются как child
and next в зависимости от того, кто меньше, кто больше, и тогда это вершине начинает
соответствовать объединение того, что соответствовал этому дереву и этому дереву,
вот рамка тут становится на единичку больше, поэтому вот то, что нам надо,
вот, то есть оказывается очень удобно, то есть на самом деле у нас есть два не пересекающихся
дерева, а пересекающихся деревьев у нас особо нету, ну тут как всегда, да, что пересекающих
деревьев не будет, деревья пересекаются, значит одно под дерево другого, вот, но если деревья не
пересекаются, то оказывается, что им соответствует принципиально разное множество элементов,
вот, вот так как элементов у нас всего-то n, то получается, что, ну, то получается действительно,
что рамка у нас, то есть рамка у нас логарифмический и ему все еще соответствует 2 в 57 элементов,
но просто как бы это уже не явно прям живущие 2 в 57 элементов, а там какая-то там память о них,
да, да, да, ну, условно, да, прийти, да, просто дело в том, что, да, часть элементов мы уже там
убили, ну, в смысле достали, то есть, знаете, вот такие 4 я помню, вот в этом году мы говорим,
что-то про автобус и автозак, а в прошлом году мы говорили в этом месте про кладбище, ну,
то есть условно, что два города объединяются и как бы их кладбище тоже как бы переходит на
единый баллад, но что-то вот такое у нас там получалось, ладно, вот такое,
ну, вот поэтому, да, поэтому рамки логарифмические, ну, значит, рамки у нас логарифмические и более того
мы можем сделать вот действительно из этого важный вывод, то есть откуда это вообще берется,
почему тут такой логарифм, потому что мы понимаем, что если у нас в дереве находится там m ключей,
или светлых образов их, вот, то тогда мы гарантируем, что у нас тут количество деревьев,
на самом деле, то есть тогда максимальный ранг не более чем логарифма m, ну, значит,
их самих деревьев не больше, чем логарифм, логично, да, вот.
Ну, это вот здесь мы говорим следующее, что мы себе воображаем все молды, да, их можно себе,
ну, глобально за всю жизнь можно вообразить себе так, у нас есть m куч, ну, допустим,
мы заранее как-то предсказали, какие элементы мы там куда хотим вставлять, то есть по факту это
может сказать, как мы на самом деле можем создать заранее все эти элементы, там сделать из них куча,
а потом их в каком-то порядке сливать, вот, то есть если взять это дерево вот слияние и смотреть,
за какое время суммарно это все слияние происходит, то можно оценивать это слияние сверху вот таким
вот образом, вот таким вот образом оно делается и получается нот, и можно его получается действительно
оценивать сверху вот как-то вот так, но вот и отсюда вывести, что эти слияния суммарно оказывается
работают за линию, вот, то есть вот такое вот удобство получилось, то есть вот так выясняется,
что нот Meld работает за единицу, вот как в этом давайте подчеркиваем, как в этом помог нам
именно суффикс-мин, но суффикс-мин нам помог действительно тем, что если мы тут вот слияние
тут остановилось, то в принципе то, что получилось, можно подцепить вот к оставшемуся хвосту и,
в общем-то, больше ничего не делать, ну вот такие хвост вообще не менять, но при этом на вот этой
голове, то есть вот то, что у нас только что получилось, там суффикс-мин спокойно насчитывается,
понимаете, да, вот, то есть вот оказывается очень, ну, то есть оказывается, то есть на самом деле,
то есть все это может быть было для того, чтобы у нас там успешно поддерживался дед-мин, вот,
понятно, да, как этот, нет, этот список это и есть куча, ну да, то есть, то есть можно сказать,
что, то есть вообще можно сказать, что куча, это, то есть само общее классик куча вообще может
храниться едва ли не указатель, просто только на эту голову и все, ну, почти конечно, вот.
Как следующее определяется, короче? Следующий, ну, как бы это односвязанный список в каждом
элементе, то есть одно дело куча, вот, в которой хранится указатель сюда, вот, в этом, в этой
вершинке хранится указатель на следующую, то есть в ней хранится указатель на следующую,
значит, указатель на свое дерево и указатель на суффикс-мин.
Ну да, в смысле, нет, не совсем-то, ну, не да и нет.
Потому что это не элементы кучи, это представители деревьев вот так, то есть
это представители деревьев, то есть элементы лежат в деревьях, даже еще хуже,
точнее, еще хуже элементы лежат в автобусах, автобусы лежат в деревьях, деревья лежат,
то есть как там как там у каждого там каждое дерево лежит в некотором смысле вот в таком
ящике точнее вот то есть вот так то есть тут это до элементов вы это просто так не добираетесь вот
кто не защищен ну да ну можно и так сказать вот так вот тихо тихо тихо значит смотрите
значит что у нас тогда значит что у нас теперь происходит значит что но то что у нас теперь
соответственно происходит вот начиная вот это у нас был мэлт но теперь давайте вспоминать
значит ну как у нас устроено удаление вот как у нас устроено удаление и экстракт мин ну удаление
устроено по итератору вообще устроено предельно просто надо просто достать элемент из автобуса
просто берем и достаем и ничего страшного все то есть типа вот но единственная проблема что
некоторые автобусы бывают пустыми но как бы ничего страшного то есть как бы мы не будем
торопиться уничтожать пустой автобус вот но вот с экстракт мином все сложнее потому что что
нужно сделать экстракт мини но нужно просто вот по суффикс мину пойти значит найти этот
дерево с минимальным псевдонимом в корне у этого элемента значит надо пойти в автобус и достать
первые попавшиеся элементы его собственно и его но ты его из кучи ударить но в общем-то тоже
все просто делается за от единицы вон тут всеми указателями все уверенно но магия начинается
когда выясняется что в этом автобусе больше никого нет что мы тогда делаем и тогда начинается
самая магическая операция этого всего вот потому что что пытается но потому что сифт в панике
значит абсолютной панике пытается значит там понятно что автобус пустой пытается залезть
себе по дерево и выкопать оттуда что-то ну давайте вспомним как он конкретно это делает вот давайте
вспоминать
вот но делает он так то есть условно говоря си этом давайте это какой-то сифт отвершины в
что у нас получается жена вот то есть то есть ну легенда такая мы пришли в вершину в и
говорим слушает тут проблема твой автобус пустой то есть следователь дать тебя то есть тебя как
вершины в общем-то желательно чтобы не существовало вот но как но то есть такой вершины быть не
должно то есть надо как-то автобус уничтожить но из но у тебя в под деревья кто-то есть поэтому
надо что-то достать что делает по умолчанию вершина в по умолчанию вершина в говорить так
значит вот у меня есть next так вот так вот у меня есть next вот давайте я рекурсивно что-то
достану из него то есть что это означает то есть принципе значит после рекурсивного запуска
значит это будет означать что там у нас есть какое-то относительно какой-то корректное
дерево то есть в котором уже там действительно этот этот так сказать автобус ликвидирован по
цепочке вот и тут образована вот и тут образовался какой-то вершин вот но мы тогда можем честно
вот ты образовался у тебя тут нормальный автобус до но отличные задачи тогда мы идем по цепу значит
тогда я к тебе присоединяюсь просто как бы то есть нас достанут а то есть как бы будет абсолютно
тот же автобус то есть тут автобус какой-то вот давайте я к нему просто присоединить казалось бы
мы так хотим сделать мы так делать не будет но вот но мы так будем делать аккуратно что может
так оказаться может так оказаться что у нас в общем-то но вот что вот это вот это вот вершина
этот псевдоним окажется больше ребенка такого у нас не бывает что же мы в
таком случае сделаем но тут мы замечаем что в общем-то это деревья
одинакового ранга
вот а потому что на самом деле есть мистический вариант заключающийся в том
что на самом деле как бы рамка этого дерева не поменяется то есть обратите
внимание сифт то есть смотрите важный момент сифт он это немножко о
перераспределении вершин внутри дерева но сам по себе сифт не удаляет никаких
вершин то есть максимум что может сделать сифт это в идеальном мире
все что может сделать это удалить пустой автобус это все что он может делать
но вот но это уже техническая деталь но сейчас есть об идеологии сейчас мы об этом поговорим но
просто идейно важно понимать следующее что сифт он просто перераспределяет вершины то есть
перер derive с автобусами но как бы память и вершина остается то есть более того то
есть на самом деле сифт вызваны от вершины на самом деле никак не изменяет 0
нужно здесь соответствует вот эти два степени рамка тв каких-то вот ключей да ну то
то самая та самая память да вот то есть так вот это память никак не нарушается то есть не из этой
памяти не там никто не исчезает и туда никто не добавляется то есть но вот и как следствие то
есть когда вы запускаете сифт от в то есть рамка ее не меняется от слова никак вот то есть там
то есть это вот на самом деле важный момент вот то есть примерно вот поэтому оставляется остается
и дворян шоу чайлд и некста одинаковые ранги и мы в этом месте прежде чем подключать подключаться
к этому автобусу по ним и думаем что если чайлд оказался меньше чем next то на самом деле эти
деревья можно и по свапать спокойненько и подключиться уже к бывшему чайлу вот понятно
да правда есть маленькая оговорочка но оговорочка оговорчика из разряда что чтобы не было
бесконечной рекурсии да потому что если сифт всегда вызывается от венекста то у нас получается
бесконечная рекурсия в какой-то момент мы должны остановиться а в какой но очевидно да но не нет
не совсем так но хотя да то есть действительно венекста может тупо не существовать да может
быть такая ситуация что но вот то есть но по сути когда мы дошли до конца цепочки да мы дошли
до конца цепочки но тогда в этом месте мы говорим что этот элемент мы удалили но у него в подделье
больше никого нет тогда мы собственно в этом месте мы говорили что если тут вот пусто то мы
вообще эту вершину объявляем плюс бесконечности но не меня ее ранга обратите внимание до важный
момент это вершина как мы вот в общем случае уже обладать рангом 0 не обязана то есть может быть
и там из нее уже просто достали просто достали все что можно то есть она там соответственно
называется имеет какой-нибудь там ранг 7 и то есть ранг 7 но из нее там все до как бы там то есть
это там сто сто два до там но все 128 элементов из нее уже достали убили там закопали там надпись
написали и так далее вот вот и пришел ее черед вот мы тут тоже надпись написали вот чем сделали
мы это для чего для того чтобы по крайней мере перейти тут в какую-то рекурсию то есть вернуться
из рекурсии и шоб у нас тут то есть в этом месте у нас есть возможность немножко сон вот то есть
этих детей чуть-чуть посвапать то есть можно их нот нот их можно посвапать а потом в будущем на
самом деле этого ребеночка в принципе можно и удалить потому что у нас в принципе есть такая
превышение в какой-то момент образовалось у нас есть ребенок на плюс бесконечность и там условно
там какая-то еще вершина то мы обнаруживаем что можно в принципе плюс бесконечность убить это
убить и вместо этого на самом деле аккуратненько вот слева и справа на самом деле подвесить вот это
вот вот помните было дело да то есть можно вот сделать вот так но более того тут но более
того на самом деле забегая вперед тоже приближаюсь практически то есть можно вообще оказаться что в
какой-то момент у вершины окажутся два ребенка плюс бесконечность можем потому что да мы да в
обычной биномиальной кучи конечно не может но мы здесь можем включить да но мы тут об этом начинаем
включить миссию включать мистику потому что как бы потому что пока мы не включили мистику это
просто такая оригинальная реализация биномиальные кучи вот да но правда единственное но от единственного
оговорочка что почему это вот давайте думать почему этот экстракт мин вообще работает за единиц
казалось бы там если нам не повезет с деревом то есть он там дерево будет ранга какого-нибудь то
вообще говоря у нас тут может там при но то на самом деле мы тут можем гулять на самом деле сколько
угодно почему у нас экстракт мин работает за единиц
вот но на самом деле да тогда то есть вспоминаем то есть у нас еще более эпической идеи что на
самом деле экстракт мины мы на самом деле оплачиваем будущими то есть это они были оплачены
в инсортах то есть на самом деле по большому счету там нужно доказать то есть ну глобально
надо доказать да что у нас есть у нас было встать сделано и инсортов да то суммарно все сработает
за там лог 1 делить на эпсилон плюс количество вызовов конкретных операций ну мы там мелды из
них мы уже правда смогли выкинуть условно вот но вот это но вот но сами себе эрейзер тоже пшенин
какие потенциалы некие варианты в общем-то там пустота автобусов не влияет у нас чего ну где-то
но где-то не вопитать это вообще не интересен да вот но теперь думаем да почему у нас аналога но
аналога на самом деле здесь у нас очень простой потому что каждый раз когда вы вызываете сифт у
нас как говорится там там в нашей куче уничтожается один автобус логично да вот но
соответственно но то автобус от нас его n а ну да важный момент когда мы создаем элемент мы
создаем не только новую вершину и новые кучу но еще и новый автобус вот так что раз автобус но
так как у нас их всего уничтожается не более чем это получается хорошо вот нам очень хочется
как чтобы это работало залогарифом один делить на эпсилам поэтому мы начинаем но поэтому мы
начинаем уничтожать автобусы чуть-чуть быстрее очень сильно каким образом нет ну где-то сливая
их но каким конкретно образом но идея очень простая что давайте попробую тут разные варианты
есть значит отрите но вот один вот у нас будет вариант такой значит сифт от в значит он
условно говорит ну я сейчас пишу условную фону я не буду сейчас писать прям полностью вот там
но условно говорим так значит вызываем сифт от в next значит так сказать вот так это
relax connect ну relax connect это ну релаксом в данном случае оказывается вот этот вот swap next
вот хотя впрочем но хотя коннект может говорить еще рано потому что ну хотя но там как на коннект
совсем автобуса здесь еще не происходит до этого но вот хотя нет релакс коннект здесь происходит
потому что значит удачи казалось бы все мы все сделали обычный сифт на этом бы закончился но
у нас куча необычная поэтому у нас неожиданно возникает мистическое условие то есть оно говорит
там ну то есть вот ну пока давайте так и вспомним вот у нас есть if mystical condition то есть и вот то
есть если от этой вершины выполнено мистическое условие то значит что мы делаем значит мы там
условно говорим еще раз вызываем сифт от вы next вот но вот и дальше но вот и дальше пишем
я так так что релакс коннект юнайт но потому что что делает потому что что делает релакс
коннект он говорит так но во первых значит если чайл доказался меньше next swap это во
первых а во вторых он говорит так но а во вторых пожалуйста что авто там ссылка на автобус от
вершины в даже теперь копируем из ссылки на автобус от вы next поэтому я это называю релакс
коннект понятно да но это делать предположение что вершины в автобус уже не существующие у нас не
интересует понимаете да вот так вот здесь вы действует по-другому то есть если выполнено
мистическое условие то мы говорим так так у вершины в есть какой-то автобус да и вот у этих
решим так вот давайте вызовем сифт в предположении что для нее вот ей мы сообщаем что этого автобуса
нет его уже опять быстро удалили на самом деле мы его никуда не удалили ну и да и звэй идет
поэтому мы ее не теряем то есть из вн x она как бы тоже идет но мы ее игнорируем мы собственно и
в основном систифте ее игнорируем потому что на самом деле это ссылка скорее всего не валидно
потому что мы этот автобус уже когда-то убили то есть не умы скорее всего вызвали непосредственно
перед запуском сифта собственно искорне вот значит вот такая радость получается вот да
без пареньки вот значит соответственно мы тут вызываем еще значит соответственно какой-то
локальный сифт и что мы после этого и вот и после этого мы говорим так отлично у нас тут есть автобус
и у нас есть автобус тогда идея такая то есть давайте так вот этот вот автобус но тут тут уже
ссылки есть на какой-то автобус давайте к этому автобусу подцепим наш ну почему бы нам его не
подцепить да и после этого торжественно но вот и в ноте но и тогда ссылочку отсюда тоже на
это же объединенные автобусы отправят то есть вот такая мистическая идея понятно да вот
мы хотим нас кокто оперативно то есть как-то вот хлопать то есть то есть заметим прочить эту
сифту нас это такая нелинейное то есть как бы обычный с
чтобы у нас не инвалидировались все слухи, которые бежат по дереву, не прицепить наш автобус в конец.
Да, да, да, конечно, конечно. Нет, безусловно, безусловно. Вот. Так что да, вот такая она.
Так что в этом смысле да, вот такая красота получается.
А вот мы что хотим для рангов Child и Next, чтобы у Childа было больше?
Нет, смотрите, не путайте ранги с секеями.
Значит ранги у Childа и Next должны быть одинаковые и строго меньше, чем у V.
Вот. Ну вот, про ключи мы хотим, ну как бы тут у этих секей тут и секей тут они должны быть одинаковы,
а у Childа секей должен быть больше, потому что это куча.
Ну это куча на минимум, то есть мы хотим, чтобы дети были больше родителей. Тут по классике.
Но скажем так, мы сливаем автобус, который у нас сейчас в вершине V, с тем, что мы еще достанем.
У нас же они так равны.
Не, а вот тут и прикол. Сейчас перед вот этим mystical condition они как бы равны, даже не равны, один и тот же автобус, да.
Но просто фишка в этом смысле говорит такая, потому что что вообще говорит SIFT?
SIFT приходит в вершину V и говорит, слушай, твой автобус больше не существует.
Ну вот, пожалуйста, забудь о ссылках на него.
Вот пусть ты и все твои next забудут о ссылках на этот автобус и выкупают нам новый.
Вы говорите OK, и вы это делаете.
Вот первый SIFT это вы next и вы говорите, так, хорошо, я нашел автобус.
Что говорит второй SIFT? Второй SIFT вы своему next говорите, слушай, а забудь ты об этом автобусе.
То есть он как бы делает вид, что этого автобуса не существует, что он типа там не существует больше.
Там выкапывает из себя что-то новое.
Ну если там, конечно, не плюс бесконечность.
Но, говорим мы неожиданно, но сама вершина V об этом автобусе не забывает.
Вот. То есть она об этом автобусе не забывает, но просто фишка нот.
То есть она просто нот, то есть на самом деле она при этом подключается к автобусу next,
но при этом в этот автобус она допихивает в конец еще свой старый автобус.
Она допихивается в конец к next или уже после?
Она удалит свой автобус у next и, возможно, придется после этого сводить.
Да, и, разумеется, именно после свапа она будет подключаться.
Но и здесь, да, вот в Relax Connect тоже подразумевается, что мы сначала, то есть прежде чем подключиться,
мы должны аккуратно выяснить, к кому мы подключаемся.
Ну вот, ну типа того, да.
Главное, это не слишком часто делать.
Потому что давайте себе вообразим...
Ну прежде чем я оглашу, собственно, к чему равно mystical condition,
вот давайте подумаем, что тут может быть.
Потому что я могу в принципе сказать, что если...
Вот давайте просто делаем...
Вот что будет, если я буду делать это всегда?
Ну вот насколько быстро?
Вот давайте, скажите, вот я вызвал сифт от V.
Сифт от V.
Как вы думаете, чем этот сифт закончится, если у меня mystical condition будет работать всегда?
Ну типа того, да.
А когда мы объединяем пустой список с уже существующим?
Нет, есть разница.
Дело в том, что когда мы первый вот сифт вызывали, да,
то есть как бы сифт просто нам сообщает, что дорогая вершина V.
Там с глубоким сожалению сообщаем вам, что ссылка на ваш автобус больше не валидна.
Поэтому как бы при вот этом Relax Connect вам просто не с чем объединять.
То есть вы просто подключаетесь.
Вот.
Поэтому Relax Connect Unite, это как бы это вы ему навесил лапшу на уши,
что как бы вам не с чем объединять, а вам на самом деле...
А на самом деле вы тут себе это сохранили там, называется автобусик.
А потом как бы все собрали, ну да, вот.
Ну вот тут вы достаете из кармана, собственно, автобус и подцепляете его.
Лимузин мне круче звучит.
Ну ничего, лимузин, я не знаю.
Ну тут...
Не, ну ладно, да, ладно.
Ладно, если у вас в кармане будет лимузин, то окей, конечно, да.
Вот, ну неважно.
Так что вот такая вот разница.
Нет, ну давайте, да, вот может показаться действительно, что если у нас mystical condition,
выполняется всегда.
Ну вот.
Ну он называется прям, да.
Хочется вообще сказать, что едва ли не там...
Что едва ли не вершина В у нас...
То есть вообще там этот сифт приведет к тому, что у вас будет вообще одна вершина с полным автобусом.
Там с автобусом на два в степени.
Да, но есть подозрение, что да, это...
Все-таки это не совсем так.
Мы как-то вызываем сифт, но мы не вызываем сифт от Childe никогда.
Нет, ну...
Нет, ну почему, нет, ну...
Не, оно не совсем так.
Ну нет, от Childe мы его, ну когда-нибудь мы его можем и вызвать, на самом деле.
Вот.
Но...
Нет, ну то есть, да.
Ну для...
Да, ну в принципе нет.
Ну когда-нибудь мы его посвапаем, особенно когда это станет плюс бесконечностью, да.
Вот.
Но в принципе, да.
Заметьте, что он все-таки не все так быстро.
То есть тогда, если mystical condition true, то мы сифт вызываем просто два раза.
Вот.
То есть действительно просто два раза у нас действительно сколько-то автобусов значит объединяется.
В ложном вызове сифта мы тоже можем сделать ложный вызов сифта?
Конечно.
Это...
Это вот прям вот рекурсия работает как написано, да.
Да, тот и прикол, что да-да-да-да-да.
Каждый рекурсивный сифт тоже вызывает внутри себя какие-то сифты.
Так.
Да, действительно.
Вот слета нам не очень понятно действительно сколько элементов у нас тут может быть.
Чему вообще такой быстрый сифт вообще может привести?
Но давайте подумаем.
А если бы сифт у нас действительно без mystical condition работал?
Да.
Просто вот такие mystical condition true.
Давайте подумаем.
А за какую асимптотику это бы работало?
Не больше, чем за равным.
Чего?
Не больше, чем за равным.
То есть не больше, чем была по next?
Ну, не совсем.
Если бы mystical condition true у нас бы как бы дерево было.
Так что можно...
Так что в принципе мы вынуждены заключить, что он может изо два в степени работать.
Ну-ка давайте внимательно подумаем.
Чего?
Ну да.
ну-ка давайте вот гиматино ну-ка в гиматино подумаем
не а точно а точно это точно нет но я не знаю а точно почему
мы убьем именно все нет то хорошо мы удалим один да у нас там удалится один
сикей да ну понятно что нет ну как бы если у нас мистикл
кондицион был ифт фолс да то конечно да мы бы удалили просто один сикей один
автобус там это уже выясняли но вот но есть и мистикл кондицион равно true то
как больше не знать что он будет там и из себя тут выкачивать прям все он же
бесконечности выкачивать он там один раз вызовет сифт и все нет а впрочем знаете
что ладно я думаю на самом деле есть уникальный способ как это в этом всем
спокойно там спокойно разобраться как это давайте это преимулируем но давайте я
нарисую какой-нибудь вот эти вот сейчас нужен трейдов дерево должно быть
достаточно большое чтобы было все видно но достаточно маленькое чтобы тут это не
окопались до вечера поэтому я выбираю ранг 4 вот ну мне так кажется что нормально
будет да так ну поехали значит изначально что у нас есть сейчас я пока рисую идеальное
дерево там так у меня в корне находится сикей там 5 с каким-нибудь рангом 4 так
а в общем давайте я так значит сейчас как мне-то это тут скажет так дерево немножко перекошено
надо рисовать вот вот я думаю вот так примерно его надо рисовать ладно пусть тут будет пятачок
будет пятачок будет пятачок ранг его 4 так вот вот так
значит что у нас тут тянут так что у нас теперь значит ну здесь у нас достаточно так но здесь у
нас все просто так здесь у нас будет какой-нибудь элемент 19 допустим так что у нас тут еще здесь
у нас будет элемент какой-нибудь там 8 допустим так вот тут надо рисовать так значит 8 давайте
рисовать вот так так на хиты тут 8 пока еще и так тут у нас соответственно 15 так что у нас теперь
еще есть так теперь у нас надо вот сюда наверное отправить элемент 10 вот чтобы он был 10 и тут
он будет 10 так значит давайте так так тут у нас будет элемент ну допустим 12 тут у нас будет
допустим 13 13 и 14 так может больше не рисовать так так хотя ладно четвертое дерево уже не
поместится поэтому придется больше ничего не рисовать давайте хотя бы вот на нем этот сифт
поэмулируем значит давайте смотреть так значит она читала да что мы не нарисовали мы нарисовали
автобусы так но пока пока у нас все хорошо как бы как бы у нас в автобусе пока в каждом
автобусе лежит один элемент так вот здесь вот здесь вот у нас один элемент 19 вот здесь у
нас лежит один элемент 8 дам вот здесь у нас лежит элемент 15 ну и так далее и тому подобное
да значит вот тут 10. так тут 13 и тут так так ну что что-то я забыл 12 но да все правильно
да в дереве ранга 3 должно быть в идеальном дереве должно быть 8 автобусов да это называется
автопарк ранга 3 да 8 автобусов 8 комфортабельных автобус вот комфортабельных автобусов с
индивидуальными местами там вот ой да точно не то что только личного водителя не хватает
да так но поехали смотрите и тут мы говорим значит ну просто так сифт мы не вызываем мы
сифт вызываем только в экстракт мини сначала нам приходит экстракт мины говорит так вот и
говорит так минимум не сказали что минимум у вас в этом дереве где у вас так ну давайте так есть
корень есть автобус так в нем есть элемент так элемент поздравляю ты минимум значит мы
отправляем эту пятерочку и достаем ее и так ура автобус пустой так окей вот говорит о ребят а
тут еще экстракт мин минимум же все еще у вас так ну давайте пойдем в автобус и он пустой так что
в этом месте происходит внимание до вызовов сифта перед вызовом сифта происходит следующее значит
этот автобус исчезает вот то есть эти все ссылки теперь не валит но то есть и так ладно ссылки
может быть там то есть ссылки ведут куда то значит сифт теперь от этой вершины говорит так он
интуитивно на самом деле то есть интуитивно на самом деле вот в сифт отве можно написать строчку
там в там бас равно там нул птр то есть понятно строчка ни на что не повлияет можно написать
можно нет но как бы вот интуитивно можно так делать нет же мы здесь то есть мы как бы
обратить внимание вот то есть как бы это то есть вн как бы от этого от нашего автобуса
отключится но не мы вот и получается так значит мы запускаемся значит отлично мы теперь значит
этот указатель теперь у нас отправляется в крестик вот а мы говорим так идем в next и
что мы делаем так идем в next так но у него тоже датчет этот указатель отправляем крестик значит
значит крестик крестик крестик крестик ну пока в общем ничего интересного тут крестик и тут
крестик но вот значит тут мы говорим что ой а у нас оказывается next больше нету значит что мы
в этом месте делали мы в этом месте обычно заявляли что у нас тут плюс бесконечность какая-нибудь
вот и теперь остается только детей вот но теперь говорим что у нас оказывается ребенок меньше
поэтому мы что теперь делаем мы теперь сваппаем то есть мы просто берем и сваппаем вот значит тут
19 тут это вот бесконечность с крестиком вот но собственно бесконечности в общем крестик навсегда
останется крестиком а вот тут 19 останется 19 так и после этого так после этого что мы говорим так
после этого казалось бы мы должны были просто а теперь смотрите какая фишка то есть мы теперь
говорим что у раз значит мы подключаемся сюда да мы тоже объявляем себе 19 кстати что приятно
вот да да погоди но вот и но вот и но ты в принципе да по-хорошему говоря мы в этом
месте еще и ребенку удаляли помните да но хотя обычно в это хотя обычно мы ребенку удалять
будем только вот на самом деле в конце да то есть ну просто да сейчас вы увидите почему то есть
вот где-то вот тут в конце мы скажем там есть чайлд иф инф вот так ну давайте вот можно так
написать в принципе вот но в наша нота но то есть это просто просто будет не очень удобно
потому что если мы сейчас его удалим то как бы придется вот этот вот второй сифт типа вызывать
от пустой вершины это не очень хорошо итак что же у нас происходит тогда происходит у нас теперь
следующее так если это допустим истекал кондицион тру тогда мы вызываемся сифт отсюда то есть
что делает сифт сифт неожиданно отказывается от ссылки на этот автобусик и пытается значит
это он прям вот крестик но обнаруживает что детей у него нет поэтому у нас тут плюс бесконечность
вот значит соответственно после этого что мы тогда делаем мы тогда получается возвращаемся
так и говорим и у нас на самом деле происходит печальная ситуация которая кстати в будущем
в коде мы должны учесть у нас две плюс бесконечности
но вот нет ну не совсем нет ну нет ну не совсем так нет на самом деле как бы нет
вот из этой вершины автобус уже не 19 чего а также как здесь потому что вот именно в этом
заключается условность этого кода потому что обратите внимание вот мы чтобы сам начать тоже
первое что делаем сифт венек я что-то не пишу но вот а по хорошему то должен сказать что если этот
венек существует вот тогда соответственно то есть я что-то не расписывал свой я тут не расписывал
что если венек не существует то давайте там пишем себя плюс бесконечность да вот и здесь то
же самое то есть идея в том что если по результату срелакс коннект включает себя еще проверку такую
что если выяснилось что там плюс бесконечность то значит мы ничего не делаем точнее мы уничтожаем
этих детей вот чего уничтожаем детей что не так господи нашу вы еще не привыкли к этому вот
вот но обратите внимание что получилось получилось маленькая приятная вещь получилась вещь что этот
автобус пока по камере пока еще не убился ведь он еще жив но давайте посмотрим что будет что
будет дальше значит выше нам сказали так в общем короче вот 19 вот собственно даже элемент так
мы говорим так но с 19 у нас тут что-то не то потому что заметим что во первых мы заметим что 19 мы
вынуждены посвапать с восьмеркой так ну свапать я буду сейчас вот более просто вот таким красивым
образом вот таким вот вот вот 19 с двумя жмуриками крестиками так вот соответственно и вот так но
говорит так молодец послабал а теперь иди сюда
да да да да да да правильно мы должны делать релакс коннект и мы это сделаем вот вот так
так ой да сколько всего мы сделаем должны вот и теперь с числой совестью делаем сифт
который неожиданно ну который неожиданно говорит нам шо этого сифта больше нету этой
ссылки больше нету этой ссылки больше нету но хотя давайте разбираться да тут у нас крестик
мы отправляемся сюда этого нету этого нету но значит тут у нас образуется плюс бесконечность
до восьмерочка превращается в плюс бесконечность да вот так ну что у нас здесь происходит но на
самом деле дамы тут у нас тут тоже происходит какой-то свапчик то есть ну очень ладно если вкратце
на самом деле заметить что мы мы уже что-то раньше как бы то есть это все эмулировали на
самом деле думаю вы уже догадывает еще можно это просто промотать и сказать что тут будет
просто 15 с двумя жмуриками вот вот ну потому что просто то же самое правда вот так значит
что но вот так и вот мы наконец но вот идти и теперь что у нас тогда происходит хорошо да
вот хорошо здесь 19 здесь 15 свапать никого не надо но тогда идея теперь простая значит
мы берем вот эту восьмерочку pushback мы ее к 15 вот сюда и конечно же не забыла но вот и тогда
ссылочку рисуем сюда да и конечно же не забываем прописать что тут 15 то есть обратите внимание
кстати ровно в этот в это оказывается ровно в этот момент элемент 8 испортился потому что до
этого момента как бы у него псевдоним был адекватный но вот в этот момент он и быть перестал вот так ну
к чему это с принципе а да то есть я могу по эмулировать дальше что будет происходить значит
но вот значит что но что у нас тут дальше но на самом деле да то есть дальше происходит
следующий да возвращаемся в корень да приходится обоже это свапать и там что-то мы еще из листа
достанем но в принципе я думаю уже этого достаточно убедиться в том что пока ими
тотального уничтожения не происходит видно да вот но тотально но давайте так действительно мы
да мы видим что тотального уничтожения не происходит вот но те но те но те но тем не
менее конечно на какие-то объединения происходит куча конечно очень сильно подредится то есть там
вот под деревья ранга один вообще сожмутся бедные вот ну вот но там уже что-то еще произойдет но
внимание вопрос давайте вот это вот идея давайте пока подумаем идея на будущее вот мы не спрашиваем
как бы сколько у нас элементов попорчено до но мы спрашиваем а какова асимптуйчика
вот за какое суммарное время работают все такие сифты
вот плюс от чего
но на самом деле да то есть обратите внимание что если мы делаем два рекурсивных вызова то то есть
каждый сифт может сделать следующее он может либо объявить вершину плюс бесконечности что
происходит ну не более чем н раз правда но не она от н раз либо значит либо объединить два автобусов
но вот но правда ладно теоретически но теоретически он правда еще но или он еще
может объединить автобус плюс бесконечности то есть но это то же самое что примерно удалить
бесконечность но тогда вот не но тогда возникает оказывается неожиданное мистическое ощущение
что оказывается у нас тогда все такие сифты суммарно работают за линию
но вот чувствуете нет если мы есть у нас мистикл кондицион от прям тру
то есть это потому что оказывается что мы любое действие то есть оплачиваем соответственно то
есть получается объединением автобусов или уничтожением плюс бесконечности или создание
нет просто идти-то на этом у нас просто будет базируется идея то есть конечно ну вот то есть
тут вот но на самом деле спрашивается как можно то есть это как бы дает асимпотику от единицы но
зато слишком жирное объединение да видите то есть конечно объединять можно еще жирнее тетические
то есть но потому что нет можно было бы как бы наглеть и то есть как бы совсем идеали если бы
там вызывали сифт просто вот пока пока нам плюс бесконечность не выдали тогда это тоже бы
оказывается суммарно золоть единицы бы работала но но это как бы совсем идей то есть мы с ума сошли
это там все нам сказали автобуса больше нет мы запаниковали уничтожили весь парк вот как это
да потому что логика такая что такое уничтожить автобус сделать так чтобы автобуса не было так
мы сказали так уничтожить автобус он нам уничтожил подогнал другой так автобус есть есть уничтожить
автобус ну вот и так далее ну вот да вот но мы так с ума сходить не хотим вот так о время 10.30
поэтому видимо как конкретно мы хотим сходить с ума мы пойдем поймем после переговора и так
значит соответственно мы убедились что оказывается да есть у нас сифт там мистическое условие работает
всегда то тогда действительно у нас тогда вообще все операции начнут неожиданно работать за единицу
и наоборот если она не будет работать никогда то получится абсолютно классе но то получится
абсолютно классический логариф вот тоже неплохо так и где же баланс
но баланс на самом деле вот где то есть на самом деле вот но идея возникает такое что
от хочется то есть делать развилку допустим не каждый шаг а где-нибудь например каждые 5 шагов
или каждый 10 шагов но например потому что как это выглядит да что потому что как бы
вообразить себе эти собственно вызовы этого условий то есть у нас как бы мы тут шли рекурсивно
шли шли шли шли но вот но здесь мы не просто пошли а еще и неожиданно вызвались второй раз
вот но и здесь мы тоже там шли шли шли может быть остановились одну прям шли шли неожиданно
разошлись тут шли шли и вот поразворачивались вот так вот я утверждаю что то есть я утверждаю
следующее что вот если вот вот вообразить себе вот такое дерево да тогда я утверждаю что если
длина каждой вот этой цепочки до развилки не превосходит мистической константе r то тогда тогда
у нас в инсорт можно заявить что он работает за отр вот ну то есть в переводе говоря то есть там
то есть все там эти сифты и так далее работают суммарно за отр ну плюс что-то там еще
вот такая вот у меня неожиданная идея
нет это конечно можно да но это рекурсивные запуски напоминают
получается так да вот у нас с вами получилось так но вот а тут я нота если цепочка тут была
не больше чем то тогда утверждается что все это будет работать за но за соответственно
спрашивается почему но основная идея действительно высекает какая что каждый раз когда вы делаете
ответвление это означает что вот этот лист который вы тут получите в результате этого
рекурсивного запуска он будет слить с соседом ну хочется сказать следующее что вот да вообрази
себе дерево рекурсивных вызовов сфта предположим что вот у нас получился какой-то
вот дерево и выяснилось что у нас у каждой цепочки цену цепочки между развилками длина не
превосходит я утверждаю что тогда сон вот что тогда суммарное время суммарное время
работы именно время работы да мы сейчас как бы не обсуждаем там какие-то эпселности и так далее
оно будет от рн но от рн там плюс калитам сколько раз вызвали там лишние операции
того вот что мне почему-то хочется утверждать
почему же я такое утверждаю
вот так нету это нету эрот у нас нету там будет со скорей лога 1 динамитная
все он там связанным с ним скорее но давайте тут почему же так утверждаю
но да и что ну тут
но да ну сформулирован так да согласен количество да то есть
каждое разветление соответствует фактически там объединению двух автобусов
но да но действительно заметил да что там побольше да то есть да то есть но тут важно
еще добавить что разветвление все в те может не быть вообще теоретически но у нас как бы
заметим следующее что да то есть то есть что у нас действительно фактически все ветки
ниже разветвления там первого разветвления они на самом деле работают за от р умножено
количество разветвлений а их у нас немного потому что каждый разветвление уничтожает
один автобус вот а самое верхнее вот эта штука она уничтожает автобус потому что нам потому что
у нас сифт это фактически приказ называется уничтож корневой автобус ну просто просто
по сути сифта да то есть получается до каждой эти там эроперации уничтожают получается
идеи на уничтожают это получается как-то вот уничтожают автобус в том или ином виде вот
понятно да вот ну и ну или но вот ну потому что дать но там конечно так а ворка мужствами
обсуждали что возможно здесь никакой автобус уничтожен не будет потому что вы подошла
выяснится что тут больше ничего нет но во первых это вот тогда это скорее всего мы выясним там
за за едва ли не за от единицы это во первых а во вторых что самое главное мы тогда тогда уничтожим
вершину в этом месте а уничтожить там сделаем плюс бесконечность а это тоже делается там не
более чем н раз так что это так не так интересно вот то есть тогда получается видите то есть
можно вот получается как-то вот подгонять то есть получается чем больше мы сделаем и тем больше у
нас как дольше у нас будет работать условно insert но возможно это нам как-то с вами поможет тут
немножко поможет сделать сиять на автобусы немножко лучше ну в том плане что нам очень
хочется чтобы что нам хочется напомним нам очень хочется чтобы у нас не очень много товарищей
сидела в каких-то неадекватных автобусах в данном случае у нас адекватный автобус это
когда то есть автобус можно уже считать не адекватном если в нем есть кто-то кроме тебя
вот да то есть фактически дай-то такая линия до личная машина имени меня такое да но
но как сказать нет ну не согнет лимузин он как бы еще и длинный на самом деле да
то есть не забыть лимузин это ощущение мне скорее такое что несколько людей туда все-таки посадили
потому что вы того но та потом этих людей все-таки по одному доставали вы там остались один но это
все равно неадекватная ситуация вот значит но на самом деле так вот но одна из идей действительно
как тут что посокращать возникает такая то есть значит в мистикал кондиционе значит значит ну
во первых там и вводим мистическую константу r которая будет равна 2 плюс 2 логарифма 1 делить
вот то есть вот такая вот еще возникает идея вот и в мистикал кондиционе
так вот мистикал кондиционе на самом деле первое что высенька значит но вот ну там понятно что
во-первых но пусть это мистикал кондицион это функция да значит иф там ранка тв оказался
меньше или даже меньше либо равно р ретторн фоллс
ранг но у вас на ли нали ранка как-то по-другому обозначается
а безобразие как кошмар как все меняется вот да вот мы ваши времена мы уже матрица обращали
но не вы умеете обращать матрицу но не значит такое рамка да ладно
ну хорошо хорошо ладно так в ловом слухе ладно не суть важная суть значит ранка тв меньше
либо равно эрот хорошо да вот но значит первая идея которая возникает мы начинаем то есть мы тут
начинаем развлекаться с автобусами начинаем развлекаться с автобусами только если у нас
ранг достаточно большой то есть пока ранг мне то есть пока ранг не небольшой мы вообще ничего не
делаем понятно да и в принципе логично да то есть тогда это приводит тому что если куча будет
работать так что у нас все деревья почему-то будут оказываться мелкого ранга то есть там ранка не
происходит там ранга р то понятно что все честная биномиальная куча обеспечит вам нужную асим
точку правда вот так но какие же нам еще нужны условия какие же нот ноты какие же нам еще нужны
условия вот ну тут мне уже приходится расчехлить по галочку
ну да но то есть а в сейфте вот это вызывать до по модулю ну в принципе
мы можем на автобус положить эр-монет и оплатить ими те сейфты на которых мы не вызывали
мистикл condition если мы не будем вызывать мистикл condition раз а потом вызовем то
эффект будет такой вот что мы оплачиваем монетками тогда нету да тут как-то не совсем нету
фейсвене то есть бы да я тетич не могла быть такая идея но видимо тогда просто тогда вот
возникает сложность как тогда считать действительно кого мы там с кем мы что сделали потому что дальше
на самом потому что тут условия на самом деле абсолютно мистическая просто сейчас я вот сейчас
я его просто воспроизведу если бы не не там вот еще круче значит барабанная дробь
так сейчас не было мысли при нет по идее могу общеткать и кан эту шпаргалку истинный кран
в общем да нет могу вам просто сразу сказать если там есть у кого там комп случайно значит
смотрите шпаргалка берется очень просто значит открываете википедию значит страничка софт хип
там ссылка ссылка чизэля там пдфов тогда вы просто скачиваете статью вот и все так вот так
вот условия написано следующее значит дальше тут будет написано такое ритор значит ритор
ранг значит внимание до сюда ранг от в процент 2 равно равно 1 или или да тут прям кот носях
написан значит либо ранг от вы чайл да меньше чем мы минус один то есть то есть тут он начинает
сливаться весьма неожиданно то есть он говорит так то что было аккуратненько да чтобы сливать
прям не всегда он говорит так значит давайте так сливаемся если ранг ребенка прям уже если
ранку мини это не как мой минус один а прям еще меньше значит по любому сливаем а если у меня
пока дерево идеально то я сливаю то как бы сливается условно каждый второй вот то есть как бы
то есть если но точнее так если ранг нечетный то он сливается всегда вот ну при условии конечно
вот понятно да вот но вот но соответственно если он чётные ну тогда смотрим если у него как бы
если у него ребенок ранг минус 1 то мы слияние то мы как бы внезапно развил с развилками не
балуемся вот
да именно то есть вот такая вот значит вот такая вот неожиданная заява
смотрите это но вот это гарантирует но нет смотрите нет это но это это гарантирует что
действительно нет это гарантирует то что у тебя получается на достаточно больших на больших
высотах развилка будет либо в тебе либо в ребенке вот а то но вот то есть как бы длина
р возникает только вот из этого на самом деле вот да дальше что-то считается немножко магии хотя
вот начинаешь думать что может быть выяснится что действительно если бы там какую-нибудь вот
переменную рекурсивную передавали может этого бы хватало просто доказательства сложнее бы вот
тут пока ничего не гарантируем но значит смотрите значит смотрите мистическая утверждение сейчас
начинается прямо сейчас будут прям мистические утверждения так это мы себе вообразили это мы
убираем убираем вот видимо такое ключевое у нас утверждение говорит следующее значит
мистическое утверждение значит размер вот этого вот листа на который указывает вершина в
он оказывается не превосходит максимума из значит один и два степени вот ранка тв пополам
минус р пополам где ранка тв пополам округлено куда-то нет а я четная ладно я наврал тот округление
там вот вот так вот а вот теперь обязана уточнил уточнил уточнил вот здесь тоже округление вверх
красота благо дать вот почему-то почему-то заява такая ну в принципе да логично если
ранка не превосходит в то в общем-то логично да потому что у нас на этот лист никто не посягает
вот ладно правда есть маленькая оговорчика потому что кто-то так скажет что естественно
тут надо уточнять что имеется в виду потому что дело в том что как бы на этот лист указывает
вершина ранга в но в принципе никто не сказал что не указывают вершины на этот лист не
указывают вершины большего ранга правда поэтому естественно тут имеется в виду максимальный
ранг вершины на который этот лист указывает ничего да конечно ну то есть я как бы в бедняльной
куче бы сказали что у нас нет вот этих вот экземпляров на самом деле есть только одна
вершина нужного ранга и вот типа вот то есть или соответственно тоже то есть получается каждый
лист имеет какой-то рак да если мы себе такой вообразим то кстати можем еще и понять что ранг
листа на самом деле никогда не уменьшается вот соответственно и так но теперь давайте да как же
нот как же такое доказывать но я не знаю сам мистический для меня просто как это увидеть как-то
доказывать ну понятно видимо сейчас индукцию надо какую-то писать правда ну база очевидно
если ранг вот такой то как бы без вариантов да то есть если ранг не происходит это ну вариантов нет
но предположим что ранг не происходит тогда заметим что у нас размер листа по любому не
более чем один потому что мы тут вообще никаких развилок не делаем но это классика знаете как-то
как у астера было один водитель автобуса израсходовал сэкономил за месяц 89 литров бензина
а второй вообще никуда не ездил и никого не возил поэтому сэкономил бензина в 30 раз больше
угадать угадайте сколько израсходовал первый если там им выдают одинаково кончим понятно вот
вот значит так значит соответственно если у нас эрто развилок никаких нет поэтому в общем-то
размер листа не более чем один и тогда вот это все выполнено более того при ранге на самом деле
видим что вот эта штука и единицы это одно и то же отлично говорим и так значит что тогда и так
давайте то есть переходить тогда пусть у нас ранг значит пусть у нас там ранга тв равно допустим
как так но давайте рассмотрим свойепт но какие у нас бывает случая бывает случаи когда
к нен känод допустим когда но давайте предположим что ка у нас допустим делится на два но бывают
informs destinations делится на два и когда к мне делятся на два такто тогда давайте думать то есть как
как этот лист сформировался в вершине k, то есть помним,
у нас каждый лист у нас формируется в тефте немножко
с нуля, правда?
Ну можно себе такое вообразить, правда?
Вот.
То есть давайте себе вообразим, как же он формировался?
То есть мы тут вызвались, значит, вызвались из next,
причем вызвались из next, мы видимо в тот момент,
то есть вызвались из next, причем понимаем, что
ранг от, значит, white child, видимо, меньше либо равен k-2.
Логично, да?
Вот.
Но тогда что мы получаем?
Тогда получается, мы вызвались рекурсивно от него,
получили лист вот такого размера.
Понимаете, да?
То есть получили лист размера 2 в степени, получается,
получается, k попало там, получается,
там не происходящее там 2 в степени k-2 пополам,
минус r пополам, это вот первый лист.
Мы его себе записали и вызвали второй сифт, правда?
Понятно, да?
Вот.
Но тогда получается, что второй сифт тоже выдал нам
лист не более чем такой, поэтому получается, надо
это домножить на 2.
То есть получается, значит, в нашем листе не более
чем вот столько элементов.
Но на самом деле умножить на 2, это то же самое, как
здесь прибавить единичку.
Ну, прибавить единичку, это то же самое, как убить
вот эту двоечку.
Получается в точности 2 в степени k пополам, минус r
пополам, кайфец, да?
Вот, понятно?
Вот.
Так же получается, да, если k делилось на 2, то
действительно никаких проблем нет.
Вот.
Но давайте попробуем еще второй аккуратненький
нот.
И теперь получается второй аккуратненький переход,
если у нас k не делится на 2.
Что у нас тогда получается?
Так.
Ну, нот, тогда у нас действительно возникают проблемы.
Потому что shift тогда будет вызван заведомо-заведомо,
и на этот ранг у нас никаких вот таких ограничений
нет, правда?
Вот.
Но, правда, есть маленькая нот.
Поэтому получая нот.
Но здесь тогда получается, тогда размер у нас не
происходит 2 на 2 в степени, но на этот раз k минус
1 пополам, минус r пополам.
Ну, k минус 1 пополам уже делится на 2, да?
Вот.
Да.
Но, с другой стороны, что это такое у нас получается?
Это равно, на самом деле, 2 в степени k плюс 1 пополам.
Значит, минус r пополам.
Но k плюс 1 пополам это в точности 2 в степени.
То есть, k плюс 1 пополам это в точности k пополам
округленный вех, потому что на этот раз мы пользуемся
тем, что k нечетно.
Понимаете, да?
Так.
Ну, что мы тогда?
Ну, вот.
Но тогда получается, что, ой, утверждение доказано.
Вогезапно, да?
Чего?
Можете повторить, пожалуйста, для нечетного k?
Значит, очень просто.
Ну, для нечетного k мы вызвали 2 сифта.
В худшем случае.
То есть, вызвали 2 сифта.
Каждый сифт дал нам размер не более чем вот такой.
Но округление вверх мы здесь аккуратненько снимаем,
потому что k минус 1 – это четное число.
Но, соответственно, умножить на 2 – это то же самое,
что прибавить здесь 1.
Поэтому здесь просто получается k плюс 1 пополам.
Но теперь заметим, что k плюс 1 пополам – это в точности
пополам, округленные вверх.
Все.
То есть, вот такая вот, на самом деле, аккуратненькая
оценка.
А?
А у нас условие так написано.
Нет, то есть, я здесь рассматривал только случаи, когда
у нас, как бы, наш список образовался с помощью
mystical condition.
То есть, через объединение.
Потому что, если mystical condition не было, то тогда этот
лист взялся из меньшего ранга и, как следствие,
обладает меньшим размером.
У child и next ранги одинаковые.
Вот.
Так что тут неглобально.
Вот.
Так что можно child, можно next.
Так что вот такая получается радость.
То есть, вот тут предлагается такая вот, предлагается
вот такая вот не очень хитрая роспись.
Вот.
Но теперь возникает тогда вопрос.
Хорошо.
То есть, размер листа каждой вершины, там ранга больше
чем r, он получается не более, чем вот такой.
Но тогда, теперь, тогда это дает нам возможность
попробовать каким-то образом оценить, а сколько у нас
вообще испорченных ключей.
Ну, заметим.
Ну, заметим, что испорченные.
Ну, в принципе, можно считать это простоты.
Просто сказать, что, то есть, видимо, можно считать,
что испорченными являются все ключи, которые вот все
вот в эти листы попали.
Понятно, да?
Вот.
Ну, давайте смотреть.
Но теперь, но тогда получается, значит, внимание.
Значит, сейчас просто немножко алгебры.
Значит, суммируем.
Так, значит, получается, суммируем ранги.
То есть, суммируем k равно r плюс один.
До, до чего мы суммируем?
Ну, ранги у нас не более чем.
Ну, давайте я вот напишу r, который у меня будет лог
2n округленные вниз.
Ну, просто для удобства.
Так.
Тогда получается, размер листа в каждой такой вершине
у нас какой?
Какой-то.
Значит, не более чем 2 в степени вот это вот k пополам
минус r пополам.
Ну, теперь выескать вопрос.
А сколько у нас может быть вершин ранга?
Ранга k.
Сколько у нас вообще в принципе в куче может быть вершин
ранга k?
Да, n делить на 2 в степени k, потому что напоминаю,
как бы, как бы 2 в степени, 2 в степени k вершин или светлый
образ их никто не отменял.
Уж светлый образ точно.
Вот.
2 в степени k получается.
Так.
Так.
Ну, давайте вот это вот суммируем.
Но на самом деле это не более чем, но на самом деле
вот это округление можно по идее сразу убить, правда?
Ну, а симпатически его можно убить, потому что можно
считать, что это там не более чем k пополам плюс 1.
Это умножить нам не более, жить не более чем в 2 раза,
правда?
Ну, давайте я так вот для простоты напишу.
Поэтому я пишу так.
2n и сумма по всем k от r плюс 1 до вот этого вот r, допустим,
большого, 2 в степени k пополам, минус r пополам, еще и
минус k.
Ну, поделить на 2 степень k, это вычесть k внутри степени,
правда?
Так.
То есть, в переводе говоря, это нод, то есть давайте я
так и напишу.
2n, сумма по всем k нод, то есть 2n делить на 2 в степени
r пополам, и тут мы суммируем по k от, значит, r плюс 1
до r, 2 в степени, минус k пополам.
Так.
Так, ну, что мы здесь заметим?
Ну, здесь заметим маленькую приятную вещь, что вот эта
вот сумма, если я тут даже r заменю нод, так, ну, то
есть на самом деле она не превосходит.
2n на 2 в степени пополам умножить на 2, значит, 2 в степени
минус r пополам, плюс 2 в степени, так вот, да, тут
минус r пополам, минус r плюс 1 пополам.
Так.
Так, вот давайте внимательно посмотрим и подумаем, откуда
я это взял.
Вот действительно, откуда я это взял.
Нет, ну, заметь так, это на самом деле геометрическая
прогрессия.
Только, к сожалению, ну, мы знаем, что если бы у нас
была геометрическая прогрессия с шаром 1,2, то есть у нас
есть прогрессия вида a плюс a пополам плюс a на 4,
плюс a на 8, плюс и так далее, мы знаем, что это меньше
либо равно 2a.
Логично, да?
Но здесь у нас, правда, здесь у нас шаг, правда, не
одна вторая, а один делик на корень из двух.
Ну, потому что у нас показатели степени, видите, они уменьшаются
не на один, на каждом шаге, на одну вторую.
Ну, тогда у меня идея такая, а давайте я просто выпишу первые
два слагаемых и скажу, что тогда, то есть разобью эту
прогрессию на, как бы, на, как бы, каждое второе
слагаемое и каждое второе слагаемое.
И тогда я просто выписал вот это и вот это.
Вот все.
Чего?
А, да, да, да, хорошо.
Давайте так сделаем.
Так, значит, как-то это надо тогда.
Минус r плюс 1 пополам.
И тут r плюс 2.
Спасибо.
Вот, хорошо, хорошо, хорошо.
Так, к чему надо?
Ну вот.
Ну и к чему нас это приводит?
Ну, на самом деле, если прям подогнать, то получается,
то есть n поделить на 2.
Ну, давайте я тут 2 в степенеер пополам сюда вынесу.
У меня тут образуется 2 в степенеер.
Вот тогда образуется 2 умножить на 2 умножить на,
значит, в скобочках 2 в степени 1 вторая,
минус, конечно, плюс 2 в степени минус даже 1.
Вот.
Чего?
Ну, в смысле, вот отсюда?
Что-что?
А, вот здесь?
Ну, я просто сказал, что тут 2 в степени минус r пополам.
Вот из этих слагаемых я просто сразу сюда вынесу.
Вот.
Так что получается вот такая вот штука.
Вот эта скобка не будет.
Ну, давайте так.
Ну, кстати, да.
Самое тупое, что, в общем, короче, это не происходит.
8n делить на 2 в степенеер.
Ну, давайте самое тупое, да.
Равно n делить на 2 в степени r минус 3.
Да, нет, я просто испугался, что у автора точнее оценка,
потому что понял, что нет.
Просто у автора, на самом деле, ровно такая.
То есть он говорит, то есть он теперь говорит, заметим,
что вот при вот таком mystical condition'е испорченных элементов,
то есть элементах во всех, значит, автобусах там каких-то
какого-то неадекватного ранга, значит, оказывается,
не более чем n поделить на 2 в степени r минус 3.
Но вам остается только аккуратненько подставить там в качестве
r вот это и убедиться, что уж epsilon n там и не пахнет.
Ну, даже давайте в этом убедимся.
Может быть, потому что, на самом деле, по-моему,
тут, возможно, даже с запасом немножко поработали.
Смотрите, тут какая красота получилась.
Вот, значит, давайте, то есть n делить на 2 в степени
минус 1 плюс 2 округленные вверх логарифом 1 делить на epsilon.
Ну, оцениваем сверху это как убираем вот это округление.
Значит, это 2n поделить на 2 в степени 2 логарифма двоичных
1 делить на epsilon.
Это равно к чему?
Это равно к чему?
Это 2n поделить на 1 делить на epsilon и еще и в квадрате.
То есть это, на самом деле, равно 2 epsilon квадрат n.
Но это меньше либо равно epsilon n, потому что epsilon не
превосходит 1 и 2.
Но так вот, да, есть ощущение, что все там, что как бы, то есть запасец есть.
Вот.
Так что, ну, что я вам могу сказать?
Мы, походу, победили.
И это при том, что, более того, мы совсем, более того, автор
настаивал на еще одной важной детали, которую мы сегодня проигнорировали.
Значит, автор настаивает на важные детали.
Когда мы делаем вот экстракт-мин, он говорит, вы сифт просто так не запускайте.
Там требовалось условие, что прежде чем запускать сифт,
проверьте, сколько детей у корня.
Если детей меньше, чем его ран пополам, а убить-ка вы всех,
то есть тогда лучше создайте, тогда, говорит, давайте из этих детей
создайте кучу и вмешьте ее.
Мы даже в прошлый раз с вами обсуждали, что, в общем-то, это тоже нам погоды не сделает.
В тот момент, когда мы заказывали, что у нас все расстояние между развилками будет больше, чем Р.
Ну, там, ну, догадайтесь, такое утверждение такое, что если у вершины ран больше, чем Р,
то как бы развилка будет либо непосредственно в самой вершине, либо в ее ребенке.
Да, то есть сам Р у нас возникнет, то есть у нас как бы длина Р только хвосты.
Да, да, ну, то есть, то есть, возможно, это и сыкло, что, то есть, скорее всего, то есть, там, то есть, то есть, есть подозрение,
что как угодно можно, может быть, даже на самом деле, если бы мы там, вот, как вы вот предлагали там, вот, действительно,
если глубина рекурсии делится на Р, то давайте развилку делать, то есть, скорее, возможно, так тоже сработает,
но просто это бы, ну, вот, ну, и желательно, вот, может быть, вот такую отсечку еще делать.
Вот, ну, то есть, нет, то есть, фактически, да, то есть, нам там, то есть, такое, ну, возможно, там автор просто выбрал конкретную,
собственно, потому что ее там проще доказывать, не знаю, ну, то есть, тут не знаю, тут как бы вещь такая,
то есть, как бы тут многим людям сложно сказать, значит, каким образом автор к этому пришел, то есть, я вам даже больше скажу,
там есть, то есть, на самом деле, глобально есть такой прикол, я вам сейчас скажу, что действительно структура считается в науке сложной,
да, то есть, мы вроде даже не сильно застрелились, но она сложная, вот, то есть, там, то есть, более того,
то есть, настолько сложной, что более того, там есть работы на тему того, называется soft hip более легкий вариант,
то есть, более того, в прошлом году даже провелся эксперимент, то есть, просто на экзамене мне, называется,
кто-то просто взял и просто кто-то расписал эту более простую версию, вот, так что было тоже очень интересно,
вот, так что да, но если возвращаться к условию от автора, значит, автор требовал почему-то, что вот действительно надо,
то есть, в севте обязательно надо следить за тем, что, как бы, если слишком мало детей, то, то есть, как бы, если слишком мало,
то есть, если слишком мало детей у корня, то давайте расформировали дерево, потому что, вот, вот почему-то,
а теперь, да, теперь, внимание, вопрос, потому что, честно говоря, вот, по доказанию ранее, я не очень понимаю,
а зачем он это сделал, а? Нет, нет, в тупую пройтись, ну, потому что сифт-то, по-любому, будет работать за не менее,
чем от всего этого списка, правда, пока я беру от next-го списка точно, поэтому идея такая, давайте в тупую пройдемся,
ну и, как бы, по-любому, либо расформировали и потратим столько времени, либо запустим сифт и все равно потратим столько времени,
то есть, это как бы бесплатно получается. Вот, но получается, что, но получается, вот такая вот радость,
то есть, это и сыкло, что, но, то есть, в принципе, да, то есть, тогда надо чуть-чуть усложнить доказательства того,
что мы вот единицы пошпотим мы доказывали только предположение что у нас деревья создаются
только в инсекте а тут выясняется что нет дерева может быть расформирована другой вопрос там
конечно доказательства тоже простое там поте был доказательство что отпилили вершину повесили
монетку да и тогда получается что когда вы распорядите дерево у вас там ранг пополам монет
как раз уже есть вот но соответственно там уже вроде как никаких проблем нет ну или ну или возможно
собственно в процессе в процессе доказательства может они найдутся
после честного я пока не очень понимаю где мы проворились если вообще проворились
вот так ну и смотрите идея такая самый первый ну как бы у нас самая верхняя цепочка до первой
развилки да она работает за отр но и она занимается тем что она как бы значит у тому удали там
удаляет лист да теперь заметив каждый развилка до ближайших она получается работает как бы
за отр до ближайших развилок да берет два листа и объединяет верхний уменьшает количество листов
но уменьшение листов у нас суммарно может быть не более чем n-1 поэтому получается победили
ну ладно там мелко оговор какая же дашу там не всегда конечно листы то есть иногда там как бы
этот этот цепочка может вас привести к тому что тут плюс бесконечность но очевидно она вас если
это и произойдет то это произойдет за от единиц и в этом месте там ну там можно как угодно можно
там либо это считать там тоже какими-то допсиктивным автобусом либо лучше считать что просто это
просто этого севта не было ну то есть типа потому что ну потому что как бы ну знаете
так вот как деревья отрезков да вы там сделали два рекурсивных вызова но один из них это там
все равно выбросился за от единицы потому что вы там вышли либо полностью вышли в аут либо попали
внутрь отрезка да ну вот мы здесь примерно то же самое или нет так по нет ну нет я не спрашивал
знаете лишь такой дерево отрезков как бы да но просто так понятно ли какая у меня тут ассоциация
возникла или нет может вы дерево отрезков по-другому как-то пишите не знаю ну ладно так вот так то что
есть ли еще вопросы по так есть ли еще вопросы по софт хиппу да нет наверное
да он нужен чтобы сказать миностов и как бы и рандомного студента из топ-10 процентов да вот
ну как повезет
ну ну в нашем случае да ну значит может этом эпсилон уменьшить будет адекватно нет но это
шаман ладно так ну что так нет я почему спрашиваешь еще плюс как бы дальше я хочу переходить
к чему-то еще поэтому как бы как бы да это будущее чего-то еще вообще с этим связано не будет
все вот вообще да все забыли выкинули убили все все чего задачи вряд ли нет написать это не
сложно что-то есть код так что и более того как убить код там не сильно сложно на самом деле то
есть в общем-то да то есть там то есть какой-то техникой побаловаться конечно придется то есть
там мерзкие там немножко списочки но в общем-то код неубойный то есть как бы больше убойность тут
в общем-то в доказательстве происходящего то есть почему почему это как это все работает но как
выясняется то есть самое то есть как бы как это ни странно то есть это не то есть там доказать то
есть там алгоритм использовав строящий миностов бы за быстро оказался не менее убойным если честно
но по камере по камере его мне пока понять не удалось но но ничего все все придет так что так
что возможно так что дай бог тут вот так что домой следующем семестре мы это алгоритм рассмотрим
вот нет вспоминать его не придется вам придется на тока интерфейс то есть слава богу это алгоритм
не использует глубокую внутренность софт хипа вот так штат так ну ладно как я думаю так так
ну что что мы будем делать дальше что мы вчера а что мы будем делать дальше-то вообще
вот к сожалению я боюсь по опыту прошлого года вы же не констатировать что есть причина не делать
почти не волнуйся это не означает что не будет нет я просто но нет я просто объяснил ситуацию почему
вот это просто причина причина одна просто как бы на основном потоке сейчас футилей никто не
проходит нет и что нет ну нет проблема нет просто проблема оказалась такая что дело дело в том
что дело в том что там между семестрами между потоками можно перевестись в чем более
того есть прецедент когда из остановок продвинутый переводится в принципе
чего это смех вызывает
да нет ну не знаю вот но на самом деле нет ну как сказать на самом деле так и так в общем-то не
так чтобы глобально происходит но как бы происходит но просто есть риск такой что если они сейчас будут
проходить деревья мы будем проходить и фф это переведшись оттуда человек рискует фф так и не
узнать поэтому в этом смысле синхронизация не волнуйтесь это значит то есть это будет как бы
фф будет во всей его великой массе так что просто это просто скорее всего это будет не в первом
семестре или пока имели не сейчас потому что если мы сейчас быстренько значит обсудим все
деревья то в общем-то никто нам дальше в общем вот там там обсуждать и фф не помешает вот хотя
конечно потерпеть стоит но с другой стороны тут есть на самом деле чем заняться сейчас в этом
убедитесь так ну что ж ладно так сейчас мы будем ой так ну в принципе так так ну ладно
но в принципе так на самом деле они за эту крыша с прошлого лада с прошлого перерез прошлой
переменной прошло крыша мало времени но с другой стороны у нас переключение блока я хочу врубать
ноут поэтому думаю там перерывчик хотя бы на 10 минут сделать смысл имеет сейчас будет
сложно сконцентрируетесь да сейчас будет конечно сложно это сказать но сконцентрируется все равно
стоит а то будет обидно на экзамене рассказать софтип но завалится на вл дереве почему чего ура
у меня мечта я всегда мечтал поступить на фистех и завалиться на вл дереве это примерно когда там
я не знаю прийти в казино со 100 долларов там все там все стирать потер со 100 долларами дойти
до там дойти до миллиона и проиграть его с комбинацией пара двоек ну мечта такая я вот не знаю почему
фистех казино да да да и в нашем интеллектуальном казино а мало кто знает но это так да так а можете
свет свет выключить я думаю так проще быть вот так так но вот как всегда мы будем тут испорно
использовать презентацию когда во-первых она есть вот когда она есть а во-вторых соответственно
там есть какие-то базовые вещи которые можно быстрее обсудить нет просовки не презентации но
в софт просовки есть статья нет ну мне вот практика оказалось следующее что я вот какое-то
время действительно на лекторе делал презентации но оказывалось что для сложных вещей она не очень
по одной простой причине что она сильно ускоряет темп как бы я буду рассказывать быстрее но как бы
вам будет сильно сложнее понять то есть как бы то есть вы там будете переспрашивать о и можно ли
еще на предыдущий слайд и там вот задавать вопросы то есть как показывает практика если бы делали
все то же самое медленное на доске как бы эффект будет тот же вот а вот для каких-нибудь простых
вещей, ну или там каких-то базовых, это в принципе вот презентация помогает, поэтому я ее иногда и
использую. Вот, ну в общем есть разные версии. Если вам не нравится лекция с презентацией,
в предыдущих поколениях можно найти версии тех же самых лекций, но без презентации. Вот вообще
без презентации я все прям с нуля рисовал. Вот. А сейчас вот не хочу. Вот. Вот. Итак. Так,
ну соответственно сразу. Да. Чем мы вообще будем заниматься? Да. Что такое суть? Это, значит,
ошибка. Потому что на самом деле суть это как есть, только во множественном числе. Но на самом деле
это такой древнерусский аналог английского are. А есть в данном случае как английский is. Вот. Да.
Так что вот так. Вот так мы пришли к тому, что старые русские слова объясняются через английский.
Да. Вот. Но суть в том, чем мы сейчас будем заниматься. Да. То есть мы сейчас будем попробуем
залезть в СТЛ и понять как там может быть устроен сет и что с ним можно делать. Вот. То есть мы
сейчас не будем говорить о графах. То есть мы будем хранить, то есть элементы в каких-то корневых
деревьях. Преимущественно двоичных, хотя не всегда сразу предупреждаю. Вот. Но соответственно
у нас будет понятно, что такое корневое дерево. Ну здесь. Вот. Да. Ну думаю, все понимают. По-хорошему,
чтобы обычное дерево сделать корневым, нам нужно просто объявить корень и, в общем-то, дальше
родители и дети появляются автоматически. Вот. Ну на всякий случай. Я как-будто когда-то лекцию читал,
там у кого-то это вызвало вопросы, но думаю, это не у вас. Хотя кто-то сказал, я открыл википедию,
там вообще по-другому написано. Вот. Так вот. Нет, нет, нет, нет. Нет, если бы, если бы в этом было
дело, да. Если бы. Вот. Итак. Значит, в нашем рабочем определении мы будем считать, что корневое
дерево это у нас, что это такое. Это у нас есть просто вершина. Значит в каждую вершину, кроме корня,
входит ровно одно ребро, но из каждой вершины исходит произвольное число ребер. То есть,
собственно, детей пока по умолчанию сколько угодно. И, значит, в каждую нот. Ну и, соответственно,
важный момент, что в каждую вершину из корня существует простой путь. Вот. В принципе, то есть,
в принципе, работает вот с таким определением, оказывается, удобно. Ну да. То есть, мы сейчас
некоторое время поработаем с общими определениями, потому что нам нужно ввести пару понятий,
которые в науке активно используются. Вот. Поэтому увы. Ну, значит, какие тут еще понятия? Ну, понятно,
есть понятие ребенок и родитель. Также есть понятие предок и потомок. Значит, сразу тут
обращаем внимание. То есть, там принципиально мы различаем понятие ребенок и потомок. То есть,
как бы, чем отличается? То есть, ребенок это, если ты непосредственно ввестишь на ребре у вершины
у потомок, это если ты ребенок, ребенок-ребенка, ребенок-ребенок-ребенка и так далее. Более того,
также еще замечаем, что, то есть, более того, еще замечаем, что у нас каждая вершина является
своим потомком и своим предком. Вот. Обратите внимание. Сразу здесь скажем, что вершина у предок
если в совпадает с у, ну либо у предок родителя. Вот. Можно еще так определять. Вот. Значит,
у нас будет понятие глубина вершины. Это расстояние от вершины водокорня. Вот. И есть высота
дерева. То есть, высота дерева- это максимальная глубина среди всех его потомков корня. Вот. Так.
Ну, тут вроде, так, тут вроде все понятно, да? Так есть тут что-то контр-интуитивное,
что надо прокомментировать? Нет, пока вроде все понятно, да. Вот. Ну, в принципе, вот. Какое-нибудь
типичное дерево может выглядеть примерно таким образом. Вот. Вот. Ну, то есть, да. Оно еще
удовлетворяет там какому-то свойству кучи еще. Ну, еще. Или можно интерпретировать эти числа как
индексы, их как-то хранить. Но, правда, в отличие от кучи мы не можем просто по вершине понять,
где у нее дети. То есть, это придется в явном виде хранить. Вот. Но если мы рассмотрим такое дерево
с такой нумерацией вершин, то сатэнот, то вопрос, как его обойти? Вот. Ну, как бы, да, мы не знаем,
что такое пояс-глубину, как всегда. Но вообразить себе рекурсивный обход дерева мы можем. Вот. Ну,
собственно, у произвольного дерева есть, собственно, два классических обхода. Это,
давайте, преордер и постордер. Ну, здесь можно просто. Ну, имеется, то есть, вообразить себе,
можно, рекурсивную функцию вида, что как мне обойти по дереву? Так, преордер. Значит, записываем
саму вершину, а потом запускаемся рекурсивно от всех ее детей по очереди. Вот. То есть,
в результате вершины выписываются вот в порядке. Получается мы один, значит, потом два. Значит,
тут пять, там, девять, десять. Возвращаемся сюда, типа, шесть. Значит, там потом три, там, четыре,
семь, один, с двенадцать ночем, как написано. Понятно, да? Это называется преордер. Можно сделать
постордер. Что такое постордер? Это когда, наоборот, вы сначала дети, потом я. Вот. Ну,
в принципе, да, я думаю, вы много где встречали подобного рода обходы. То есть, в принципе,
да. Наверное, когда вы там для всяких мостов и точек сочинений считали всякие таймыны,
то на самом деле вы просто буквально делали преордер-обход, на самом деле. А когда считали
тайм-ауты, вы делали постордер-обходы, кстати. Вот. Там БВДАБ. Вот. Но мы это сейчас не будем
называть таймынами, будем скорее обходами называть. Вот. Но есть еще, конечно, такое
и нордер-обход. Потому что важный подвид дерева, конечно, такого корневого дерева, это для нас будет
бинарное дерево. Но у него есть, конечно, принципиальное отличие. Смотрите. То есть,
казалось бы, что такое бинарное дерево? Хочется сказать, что бинарное дерево – это просто такое
дерево, у вершины которое, такое, что детей у каждой вершины не более чем два. Но это не совсем так.
То есть детей, потому что мы тут не просто будем обозначать детей как left и right, а более это вот
часто, как вы говорите, нам будет принципиально, что если у вершины одно дерево, нам будет
принципиально это left или это right. Логично, да? Вот. Поэтому здесь, конечно, формально говоря,
бинарное дерево – это не совсем вот корневое дерево в том смысле, в котором мы ранее обсуждали.
Вот. Но у такого бинарного дерева, помимо преордер и постордера, есть инордер-обход. Он нам
предлагает сначала обойти левое под дерево, потом обойти себя, потом правое под дерево.
Вот. То есть, например, вот здесь у нас двоичное дерево, например, вот оно, вот под дерево вершины
2, и получается тогда 9, 5, 10, 2, 6. Ну и здесь пока все просто. Вот. Значит, ну и тут, соответственно,
можно сразу попробовать найти ошибку. Чего? Так, раз, еще. Вот, да. Да, тут еще звездочки нету,
так что будьте аккуратны. Ай-ай-ай, подкол. Да. Вот. Вот. Но суть, тем не менее, остается. Значит,
суть остается. То есть, если у вас есть такое двоичное дерево с поправленными там, понятно,
каким образом, багами, то, соответственно, мы действительно обходим простым образом. То есть,
в преордере сначала print, потом от left, а потом от right. В постордере сначала от left,
потом от right, а потом от print, и в in-order print. То есть, по сути, просто куда между двумя
ордерами, куда вставить print в этот стройный ряд двухрекурсивных запуск. Вот. Так что это,
соответственно, просто такие вот понятия, просто которыми мы будем пользоваться. Пока вот это,
как бы, по большому счету, там такая немножко терминология. Да. Да. Как его еще можно обходить?
Ну, в принципе, существуют и другие обходы. Да, вот типа обход с помощью поисков ширину
классического. Вот. То есть, ну, просто, то есть, просто выпьем. Ну, то есть, по большому счету,
тут просто скорее, чтобы показать, что другие обходы тоже есть. Тут, в общем-то, ничего такого нет.
Но приходит время работать. Мы сейчас будем, конечно, не просто с корневыми деревьями. То есть,
мы сейчас не будем заниматься всякими там всякими безобразиями, там всякими там ЛСАшки
какие-то искать или там ХЛДшки и прочее. Вот это вся гадость. Вот. То есть, пока мы займемся
деревьями поиска. Вот. Значит, что это такое? Значит, как вы уже поняли, мы не хотим. Понятно,
просто деревья в вакууме нас не интересуют. Нам, наверное, они для чего-то нужны. Мы будем хранить
какие-то элементы и их искать. Как это будет? Вот, значит, у нас каждый решим наслабжена каким-то
элементом. Мы его будем называть ключ, как всегда. Значит, вот вакуум. И будем говорить, что тогда
у нас наше двоичное дерево Т, точнее, бинарное. Ну вот. Оно дерево поиска по этому ключу,
если выполнены вот такие условия. То есть, обратите внимание, только для любой вершины.
Ну вот. То есть, оказывается так. Рассмотрим любую вершину В, прям абсолютно любую. И в ней,
оказывается, верно, что в левом под дереве ее все ключи меньше либо равны своего ключа,
а в правом под дереве все ключи больше либо равны. Вот. То есть, в принципе, есть второе такое
эквивалентное определение. Будем говорить, что Т является деревом поиска, если инордор обход
выведет ключи просто в порядке возрастания. Ну, в смысле, не убывание. Вот. Ну, в принципе, да,
легко по нот. Ну, в принципе, да, можно в качестве упражнения показать, что это одно и то же.
Летающий колпачок. Вот. Ну, в принципе, такое относительно типичное двоичное дерево поиска
может выглядеть вот таким вот образом. Вот. То есть, обратите внимание, видите, нам принципиально,
где кто висит. То есть, нам принципиально скажем, что 13 это именно правый ребенок семерочки,
а не левый, потому что 13 больше чем 7. Но, с другой стороны, 9 меньше 13, поэтому и 9 это левый ребенок
13. Вот. Видите, да? То есть, в принципе, вот такое дерево. Вот. Ну, кстати, вот возникает интересный вопрос.
А сколько всего деревьев вообще, а сколько всего двоичных деревьев поиска на элементах вообще
можете построить? Если они различные, то. Ну, от одного даем. Так. Так, да, и что ж получается?
Ну, да, вопрос, сколько может быть различных деревьев. Да, потому что, в принципе, да,
если это воспринимать как задача по программированию, то можно написать рекурренту. Там просто так и написать.
Давайте так. Как-то dp от n равно сумма по всем k равно от 1 до n. Получается dp от k-1. То есть, в левое под дерево
отправляем k-1 вершину, а в правое под дерево n-k. Ну, можно и так. А побыстрее можно? Вот не за квадрат.
Каким образом? А это что за самое fft такое? Массивно развернутый. Чего массивно? Нет, это просто
только массив на массив получится сам же массив. То есть, нет, в принципе, нет, можно написать. Ладно,
давайте так. Можно написать, конечно, что это такая есть производящая функция, конечно, dp от t. И
получится там что-то типа dp от t. Получается равно чему? dp от t в квадрате, видимо, умножить на t и
плюс один. Нет. Все нормально. Все правильно. Нет, ну как сказать, когда вы производящие функции,
эти, да. Так, ну вот. А теперь осталось только выяснить чему равно dp от t, да. А это вы по
производящей функции узнали, да? Ага, ну да. Да, кто-то может вспомнить, что по некоторым случайному в
скобках нет совпадению. Почему-то количество правильных скобочных последовательностей с n пар
скобок вычитается почему-то ровно по той же динамике. Внезапно, да? Вот. Не, ну, да, погодите.
Ой, нет, с dp у нас там шоу, это отдельное шоу будет еще в свое время. Ну, что там? Как это? Ну,
как меня, как это? Хиршберг, тотал, цес, там, я не знаю, что-то еще там веселое будет. Да,
вот. Да, но на самом деле, если говорите, то есть да, то есть в принципе это очень похоже на
скобочные последствия, в общем-то совпадение даже кажется еще менее случайным. Если заметить,
что между двоичными деревьями и скобочными последствиями можно поставить вообще взаимно
однозначные соответствия не сильно сложного вида. Смотрите. Ну, давайте тут вот так будет
как-нибудь. То есть идея такая. То есть идея такая. Значит, можно сказать так. Значит, я сразу для
код, для код каждой вершине будет соответствовать пара скобочек. Но поставлена она будет таким
образом, что левая под дерево пойдет внутрь этой пары скобочек, а правая под дерево вовне. Вот. То
есть вот здесь теперь мы идем вот, получается вот так. Так, ну одна вершина, это по-любому вот
просто две скобочки, но здесь у нас соответственно получается пум-пум. Там пум-пум и пум-пум. То есть
обратите внимание, то есть вот такое дерево рисуется получается вот так, а вот такое дерево
рисуется вот таким вот. Казалось бы, просто казалось бы, чуть-чуть повернули, а вот
насколько принципиально, разный смысл.
Так, как мы строим? Нет, объекцию ставим так, ну просто, как построить по
дереву скобочные последствия? Значит, берем корень, ставим скобочки, но
внутрь, значит, делаем то, что получилось излево по дереву рекурсивно, и справа
ставим то, что справа. Ну, если так в тупую за квадрат делать, то получается вот так.
Вот. Так что вот такая радость.
Вот. Ну вот, но в принципе, заметим, что механизм приятен тем, что он, в общем-то,
действительно дает взаимную однозначность, потому что, в принципе, в правильных скобочных
последствиях тоже понятно, что самая первая открывающая скобка будет у нас
соответствовать корню, а закрывающая ей определяется однозначно. И дальше мы тут
восстанавливаем однозначно. То есть отсюда и следующее, на самом деле, да. То есть двоичные
деревья поиска, наверное, на элементах оказывается ровно столько же, сколько правильных
скобочных последовательностей. Вот, но там отдельная песня, значит, сколько у нас
правильных скобочных последствий, а самое главное как-то доказывать.
Вот, но, кажется, но есть подозрение, что это у вас должно быть в курсе дискрана.
Ну, там не очень, там не очень сложно, там метод отражения, там все дела. Можете там в
Дикипедии, кстати, почитать, там замечательный метод, красивый такой очень. Вот. Дорогие будем
сейчас на этом останавливаться. Вот. Значит, что у нас тут происходит? Тут происходит следующее.
Значит, чем приятны такие деревья? Такие деревья приятны тем, что искать элемент в нём как-то
становится очень естественно. То есть, допустим, мы хотим выяснить, есть ли у нас сейчас в дереве
какой-нибудь элемент х. Как нам-то сделать? Ну, мы говорим, так, давайте пойдём в корень. Так, корень у
нас, так, он больше, ой, он больше х. Так, значит, наверное, х, если есть у нас в дереве, то,
наверное, только в левом под деревом, в правом быть не может, там ещё больше, правда? Значит, идём в левое
под деревом. Так, в левом под деревом, там вершинка какая у нас, ой, она меньше х, значит, надо её в правое
под дерево идти. Ну, и так далее, аккуратным спуском это делаем. Так, это надо расписывать подробнее,
это понятно. Не слышу. Окей, да, все уже, да, все боятся сказать, что понятно, да. Нет, ну,
на всякий случай скажу так, это, как бы, такие базовые простые понятия, да, то есть, если, если тут
непонятно, лучше сразу переспрашивать, а то, потому что, как вы догадываетесь, дальше будет
сложнее. Вот. Значит, теперь, как делать вставку? Ну, пока мы говорим, а просто, хотя бы, самой
простой версии, которую хочется делать, то вставку делать очень просто. Мы просто идём, ищем этот
элемент, и как только натыкаемся, пытаемся пройти куда-то дальше и понимаем, что дальше хода нет,
мы просто в этом место новый элемент и вешаем. В принципе, в общем-то, уже неплохо, да, то есть,
мы получаем структуру данных, которую, вроде, можно адекватно добавлять и адекватно искать.
Все это делается за от высоты дерева. Вот. Пока, вроде, просто, да. Пока, вроде, просто. Есть даже
код. Ну, собственно, где по коду вы еще раз понимаете, действительно, с какой книжки я это взял.
Вот. Ну, Кормана я уже анонсировал. Вот. Так что я, ну, так что, очень рекомендую. Вот. Так что, то есть,
видим, действительно, поиск у нас вообще, видим, очень, действительно, очень тривиально устроен.
Можно вообще, вон, с пять строчек, вот, красиво, кстати, реализовать. Да, единственное, я только вот
оговорка сразу предупреждаю, что в Кормане там немножко, то есть, это, конечно, не сишный код,
это такой более джавайный код такой. Ну, джавайный в том плане, что каждый х, это,
вот, как бы, вершина, и здесь подразумевается, что вы работаете с ней по ссылкам. Вот. То есть,
работаете по ссылкам, и, как бы, поэтому получается, вот это присваивание х равно х left,
это как будто вы, типа, ссылку присвоили или указали. Вот. Чего? Вот. Ну, с инсертом тут,
конечно, чуть посложнее, но, в общем-то, суть тоже, ну, там суть тоже не сильно. Вроде как страшная.
Вот. Ну, то есть, понятно, какой-то там случай придется разобрать, что вы там вставляете в
пустое там дерево или там что-то еще в этом вроде. Ладно. Вот. Что нам еще приятно? Ну,
приятно, конечно, еще то, что можно достаточно легко в таком дереве искать минимум и максимум.
То есть, как найти минимум? Просто тупо идем влево пока можем. Ну, и максимум тоже самое, но вправо.
Так. Ну, теперь, да, есть, действительно, тут еще маленькая оговорочка. Да, то есть,
это такая техническая функция, которая пригодится нам в будущем. Функция, вот, функция будет
называться замени вершину У на вершину В. Ну, там просто идея заключается в том, что есть у нас в
дереве Т вершина У, которая где-то там висит. Мне вот очень-очень-очень хочется, что вместо
на месте этой вершины У висела вершина В. Вот. И эта функция просто буквально это и делает.
Пока ни в чем. Нет, это не ключ, это вершина. Нет, это вершина, в том числе, кстати,
со всеми поддеревьями, если что. Значит, вот, нет, У это вершина. Значит, П это родитель, да.
Мы проверяем, если ты левый, то мы заменяем, если ты правый, то мы тоже заменяем. Да, но вопрос,
кого мы заменяем. То есть, если У левый, то, как бы, то есть, У это левый ребенок своего родителя,
то мы слева к нему подвешиваем В. Ну вот, нет, это там в будущем нам понадобится, пока, то есть,
скажем так, просто, как бы. Чего? Ну, это понятно, да, но, как бы, это не язык Си, да, это язык,
в котором это не проблема. Ну, то есть, какой-то там алгол, какой-то там лохматой версии. Вот,
ну, по-моему, ну, или пока там, ну, модно у них там у всех тех тарьянов там, с скорманами там
писать на каких-то подобного рода алголах. Вот. Я математик, я не хочу думать о каких-то
технических вещах, я хочу, я хочу думать об идее, да. Вот, итак, ну, значит, удаление,
вот теперь у нас задача удалить вершину из дерева. Но тут выясняет, что удалить-то ее не так просто.
Точнее, у нас есть три уровня, такие три случая, как всегда, случай easy, случай medium и случай hard.
Случай easy, если нам повезло и мы должны удалить лист, ну, тогда мы ее, соответственно, берем и
удаляем. Вот, но нам фантастически повезло, но если выяснилось, что у вершины есть дети,
ну, точнее, ребенок, в смысле один, то тоже никаких проблем нет. То есть, как удалить,
то есть, если у вершины есть только, скажем, там, левый ребенок, как тогда ее удалить? Да,
очень просто, возьмите это левое ребенка и напрямую подвести к родителю. Так, это понятно,
что происходит? Вот, или надо порисовать? Вот, хорошо. Так, ну, что еще? Ну, и давайте еще
минимальный нот. Ну, в принципе, да, и уровень hard, если оба ребенка есть. Ну, это вот самый
сложный случай, но тоже решаемый, потому что идея такая, а давайте возьмем, у вершины У пойдем
в правое под дерево, найдем там самый левый элемент, то есть, минимальный. То есть, заметим,
что это как бы следующий элемент по порядку. Ну, тогда идея такая, давайте этот самый левый,
просто его на месте удаляем, его У подвесим. Вот, а, собственно, а вместо него самого там подвесим
его, вот это правое под дерево. Так, да, тут уже без картинки сложно. Чего? Да, пожалуйста.
Да, значит, смотрите, то есть, да, тут, то есть, тут идея такая, то есть, вы хотите тут попилить,
попилить, шли-шли-шли-шли, и вот вам хотите удалить вершину В, и у нее там есть оба под дерево,
тогда идея такая, давайте мы тут идем сюда, вот, допустим, так, это у нас вершина В, а это у нас
неожиданная вершина У, у которой слева ничего нет, справа висит какое-то под дерево. Тогда, значит,
предлагается так, предлагается, значит, эту вершину отсюда убрать, если, ну, вот, и подвесить
вместо, на место ее подвесить, собственно, вот это под дерево. Значит, а вместо вершины В здесь
подвесить вершину У. Вот так. То есть, вот так вот технологично мы работаем. Вот, также вот такая красота.
Вот, вот, вот, кстати, учитывая вот, вот, вот, вот здесь нам как раз эта функция трансплант и нужна. Да, у нас нет
утечек памяти, у нас пылесос, гарбат-коллектор. Вот, так что вот даже, даже, даже, ну, вот, то есть,
если правильно написать функцию трансплант, даже код оказался не сильно сложным, обратите внимание.
Вот. И так. Да, тут все понятно. Но какая проблема у такой реализации возникает? Проблема возникает в том,
что высота дерева вполне может оказаться и, там, сопоставимый с количеством элементов. Да,
потому что вот такое дерево называется бамбу-ча. Вот. Вот. Так. А, ну, это с вами обсуждали. Да, вот это вот
пей фанта, будь бамбу-ча. Ну, услышали, да? Да ладно, нет. Нет, у вас там, нет, вы там внизу встали где-то, когда вам
было там, Рудика, там, три-пять, там, по телевизору могла быть реклама такая. Дайте пей фанта, будь бамбу-ча.
Вот это все. Ну, да, там приехал, там, привет, ко мне приехал мой брата, и брат спрашивает,
что такое бамбу-ча? Там отвечает, бамбу-ча, это что-то там нежное, солнечное, там, вот, и там,
показывает эту фанту красивую, там, с пузырьками, да. Так что, ну, может, это, то есть, но-то, вообще,
были добрые времена, вот, когда реклама была такая хорошая по телевизору, да, какая-то добрая,
вот, поэтому вот, поэтому это будем называть, это будет называться левая бамбу-ча. Вот. Да,
как вы догадываетесь, бывает и правая бамбу-ча. Вот. Бамбу-ча на максимум. Ну, нет, не-не-не, это,
нет, у нас нет понятия бамбу-ча на максимум, потому что у нас сейчас, как бы, мы не кучи обсуждаем,
это дерево поиска. Да, оно очень похоже на кучу на максимум, да, да, она может быть и кучей на
максимум, это да, но двоичная куча это немножко другое, да. Вот. Но на самом деле бамбу-ча это то,
что хотелось бы избегать, потому что, как бы, хочется все-таки каких-то красивых деревьев,
вот, то есть хочется как-то все-таки, чтобы высота дерева была поменьше. Ну, меньше логарифма,
наверное, не получится, да, или получится. Нет, действительно, а может быть, можно сделать действительно
какое-то крутое дерево, в котором высота прям еще меньше, там корень из логарифма, или логарифм из корня.
Да, но двоичная, конечно, не получится. Да, причина очень простая. Заметим, что в одном из под деревьев
будет хотя бы, хотя бы n пополам детей, то есть это потомков. Значит, у него тоже будет ребенок,
который будет хотя бы n поделить на 4, ну и так далее. В общем, короче, путь, в общем, хотя бы
логарифм, высота быть должна. Но, но хочется, а можно ли как-то вот сделать так, чтобы высота была,
ну, идеально логарифм, конечно, да, совсем уж прям идеальное дерево, или двоичная куча, конечно,
мы вряд ли сможем так поддерживать со всеми вставками, но хотелось бы, наверное, чтобы, как бы,
все равно какая-то сбалансированность была, чтобы высота была как-то поменьше. Ну, с другой стороны,
что нам нужно для того, чтобы высота была поменьше? Ну, наверное, нужно, чтобы у нас там одно под дерево
не перевешивало другое. Ну, дальше, на самом деле, начинаются вариации, потому что, о, в предыдущей
лекции, да, ну ладно, вот, потому что, значит, что нам хочется? В общем, если в конце концов,
хочется действительно, чтобы у нас был какой-то баланс между то ли размерами, то ли чем-то еще.
В общем, да, хочется, то есть, может быть, ввести в дерево еще какой-то мистический вариант,
чтобы, соответственно, высота дерева сохранялась, была адекватной, но мы при
этом не сильно страдали. Так, ну, вот, сколько, так, с какими способами это можно делать? Так,
ну, мы с вами изучим сов дерево. Если бы такое существовало, конечно, да. Нет, ну, нет, я бы просто
анонсирую. Шутки шутками, но факт остается фактом. Нас с вами ждет пять сбалансированных деревьев.
Ну, потому что АВЛ красночерная, значит, то есть, плей Дикартова и, конечно, его величество Б дерево.
Нет, Б, С дерево. Ну, да, да, да. И новинка этого года Х дерево. Да, да, да.
Нет, хотя, да, хотя какая-то структура данных, хотя какие-то x-rays существуют. Правда, это не структура данных,
а рентген какой-то. Ладно, значит, смотрите. Итак, начнем с, так, давайте начнем с тупничка. Ну,
первая, прям первая историческая идея. Так, вот говорим. Вот говорим. Так, хорошо. Что такое сбалансированность?
Так, давайте так, чтобы у каждой вершины высоты под деревья были одинаковы. Чего? Прям нельзя, да?
А, типа дерево из двух вершин. Чего дерево из двух вершин? Чего высота один, высота ноль, а подру...
Так, ладно, совсем идеально поровну нельзя. А давайте сделаем так, чтобы высоты двух под деревьев
отличались в ту или иную сторону не более чем на один. Так, ну, вроде как, кажется, очень интересно.
Давайте попробуем. К чему нас это приведет? Значит, у нас есть адальция. Ну, вот, значит, получается 68-й год и так далее.
Значит, вот такая вариация. Да, так что AVL, как легко догадаться, это две фамилии. Да, вот, да. Итак, ну,
начнем с маленькой простой теории. Маленькая простая теория говорит, что высота этого AVL-терева
логарифом. Правда, логарифом, видимо, не по оставанию два, а по оставанию уже полюбившегося нам
мистического числа. Вот. Вот. Ну, доказательства понятно тут. Достаточно просто доказать по индукции,
что в дереве высоты H у нас вершин будет просто не меньше, чем H-те число Fibonacci. Вот. То есть,
думаю, действительно нет смысла расписывать. Собственно, мы уже и не такое с вами расписывали.
Ну, вот. Причем не только мы с вами, но и вы еще и сами тоже. Ну, вот. Так что тут, соответственно,
да, можно формулу взять, можно самим доказать. Но теперь возникает вопрос хорошо. Как это вот?
Хорошо. Классно. То есть, если мы умеем поддерживать вариант, что разность высот не превосходит один в
ту или иную сторону, то тогда получается, что высота будет логарифом. Значит, если мы сейчас научимся
делать все операции за ОАТАШ и при этом поддерживать высоты, то тогда мы победили. Логично, да? Вот. Как
же мы это будем делать? А вот таким вот образом. Ну, то есть, идея будет такая. Вот как мы будем
делать вставку. Очень просто. То есть, вставку мы будем делать предельно, тупо вот прям вот так же
идем-идем-идем, навешиваем. А потом возвращаемся рекурсивно. В рекурсии в каждой вершине говорим,
ой, если у меня слева и справа высоты стали отличаться на два, то давайте я сделаю мистический поворот.
Вот. Какой я делаю? Вот. Я попытаюсь локально решить. То есть, вершина при этом будет смотреть
только в детей и внуков. Как-то вот. И попробую как-то решить вопрос. Но правда,
она будет... Значит, какие повороты она попробует сделать? Ну, у нас будет четыре варианта. Вот.
Малая левая, малая правая, большая левая, большая правая. Вот. То есть, вот такие примерно повороты
мы попытаемся делать. То есть, как это будет выглядеть? Ну, то есть, нам придется рассматривать
случаи. Значит, самый простой случай. Вот, предположим, что у нас в какой-то вершине оказалось,
что у нас у правой вершины высота на два, у правого поддерева высота на два больше, чем у левого.
Предположим, что такое произошло. Что мы тогда делаем? Ну, тогда мы делаем малый поворот. А именно,
ну, просто объявляем этого правого ребенка родителям. Значит, родитель становится левым
ребенком. Вот. Какие проблемы? Как говорится, то чего? Родитель становится ребенком. Ну,
как бы, ничего страшного, он же меньше. А, ну да. Вот. И переподвешиваем под деревья. Ну, видим,
что с точки зрения инварианта двоичного дерева поиска ничего не поменялось. Видно, да? Вот. Так
же, вот такое. Ну, в принципе, да, тут немножко кое-что не хватает, поэтому давайте, ой, а давайте,
так, неужели свет придется включить все-таки? Или это видно? Это видно? Что тут на доске? Что
тут на доске происходит? Да? Ай. Так. Программисты. Так.
И так. Что у нас тут происходит? Значит, вот давайте проанализируем. Что же у нас такое? Вот и так,
давайте попробуем. Вот пусть у нас есть вершина А, есть вершина В. Вот выяснилось, что у нее есть,
я под деревья буду немножко по-другому рисовать. Буду их назвать А, Б, Г. Значит, такой поворот,
значит нас интересует, когда здесь образовалась неожиданно высота H, и тут высота H плюс 2.
Вот. Но, предположим, ну вот, но поворот, но это еще не все. Ну, казалось бы, да, вот,
к чему нас приведет, если мы тут вот повесим В, повесим А, тут повесим Гамма. Ну и тут,
соответственно, какие высоты будут у вот этих под деревьев? Будут ли они теперь отличаться
не более чем на один? На самом деле не факт. Ну то есть нас интересует случай, вот как сказано,
если у нас тут будет заведомо H плюс 3, а тут что-то от H плюс 3 до H плюс 4.
Ну ладно, давайте тогда тут будет H плюс 1, а тут от H плюс 2. Вот. Тогда,
когда мы делаем поворот, что мы видим? Значит, так, тут у нас получается H, тут у нас H плюс 1,
значит, тут получается H плюс 2. Здесь у нас получается, вот, значит, получается от H до H
плюс 1. И видите, получается, могут быть проблемы. То есть, если оказалось, что действительно у Гаммы,
значит, оказывается высота строго меньше, чем у Беты, то этот поворот нам не помогает.
Скажем так, это называется потому, что мы рассмотрели такой случай. Да. То есть,
он не соответствует этому, вот почему. Да. То есть, чтобы этот случай работал,
нам нужно гарантировать, что вот это под дерево имеет высоту не меньше, чем вот это. То есть,
на самом деле, вот здесь должно быть H, H плюс 1. Вот. А здесь вот H плюс 1 должен быть прям без всяких
вопросов и интервало. Вот. Тогда становится адекватно. То есть, тут как бы получается H,
и тут вот H, H плюс 1. Тут получается, значит, высота H плюс 1, H плюс 2. Вот. Здесь получается
H плюс 1, и это нас устраивает. Вот. Причем, кстати, на будущее нам еще важно заметить,
что как бы получается, тут высота получается H плюс 3, а тут высота стала в результате этого
поворота от H плюс 2 до H плюс 3. То есть, это нам просто для доказательства чуть-чуть потребуется.
Вот. Это у нас такой случай малого левого поворота. Ну, малый правый, это тоже, это просто вот
практически картинка в другую сторону, если там произошел аналогичный случай. Вот. Понятно, да?
Но возникает вопрос. А что делать, если у нас все-таки вот этот вот BAT почему-то перевешивает H?
Что происходит в этом случае? Ну, это не интересно. Вот. Получается немножко красоты.
Ну, давайте посмотрим. Вот, допустим, вот действительно, как мы изначально нарисовали,
то есть вот у нас жил был альфа с высотой H, жил был B с высотой H плюс 2. Почему? Потому что у него
был C с высотой H плюс 1. А тут у нас под деревья, значит, с высотой, значит, у нас бета с высотой H,
то есть H минус 1 H. И тут гамма с высотой H минус 1 H. И тут у нас получается дельта с какой высотой?
Ну, соответственно, H. Вот прям жесткий случай мы рассматриваем. Да, почему мы рассматриваем
жесткий случай? Потому что, естественно, больших поворотов мы хотим избегать в пользу малых,
потому что, ну, малые повороты, они меньше. Ну, тупо, меньше переподвешивать. Ну, а как вы уже
там забегая вперед, если вы там писали когда-нибудь дикартячки? Ладно, тупой вопрос. Давайте немножко
физкультурки. Поднимите руки, кто когда-нибудь писал дикартовое дерево? Вот. Так, молодцы. А кто
когда-нибудь писал дикартовое дерево по неявному ключу? Вот. А кто когда-нибудь писал персистентное
дикартовое дерево? А уже не физкультурка, да? Да, отлично. Вот. Так, хорошо. А кто когда-нибудь писал
дерево отрезков? А сливаемое дерево отрезков? О, а что это такое, да? Так, а кто когда-нибудь писал
фенвика? Австречного фенвика? А персистентного фенвика? Откуда ты знаешь? Ух ты. О, ты знаешь,
сложного персистентного фенвика? Персистентный фенвик, это же дерево отрезков. Нет, персистентный фенвик,
пока для верфистины фенвика это словосочетание, которое я просто сгенерировал только что. То есть,
наверное, ему можно придумать какой-то адекватный смысл с формулированным так. Так что это просто
это. Так что это. Хорошо. Ладно, немножко разомнулись. Хорошо. Итак, значит, что же делать, если у нас тут
с... Так вот, я просто к чему вспомню дикартовое дерево? Потому что в дикарту постоянно вы помните,
что когда надо что-то куда-то переподвешивать, надо что-то везде пересчитывать, да? Потому что в
каком-нибудь там будущем дикартовом дереве вы хотите пересчитывать там сумму на отрезке, да,
вот это вот все безобразие. Вот. Там сумму на отрезке, там еще какой-то минимум, там еще какая-то
гадость. То есть, постоянно. То есть, вот поэтому. То есть, это все жирно, поэтому хочется больших
поворотов делать как можно меньше. Так. Ну и тут у нас высота, видимо, аж плюс три. Чего? Тут у нас аж,
тут аж плюс два. Нет. В данном случае мы рассматриваем именно строго случай, когда тут аж. Нет,
потому что если бы тут тоже был аж плюс один, это сюда бы тоже попадало. Потому что тут аж плюс
один, тут аж плюс один тоже был бы кайф. То есть, как бы при равных аж плюс один, аж плюс один мы из
малого и большого поворота выбираем малый. Так вот. Куда ж мы еще переподвешиваем? Ну тут у нас
прям невиданный скачок. Как бы, как бы в корень под дерево неожиданно скачет внук. Вот. Вот родитель
ждал своей очереди, а тут бабах, его внук обскакал. Нет, потому что внук просто очень жирный. Так. Вот.
Ну да, как говорится. А про каким принципам в вашем королевстве? Так. Вот значит тут у нас аж,
тут у нас аж минус один аж, тут аж минус один аж, и тут у нас аж. О, красота, красота. Да,
что приятно. Да, тут у нас высота железобетона же аж плюс один, кстати, да. То есть, что приятно,
она в результате этого даже уменьшилась. Откуда плюс два? А, да, да, да, да, да, да, да, да, да. Так,
но все равно, видите, было аж плюс три, стало аж плюс два. Но правда аж плюс три было при
неадекватном балансе. Вот. Ну, поэтому здесь надо аккуратнее. Ну вот, то есть вот предлагается
такие вращения делать. То есть, ну вот, ну большое правое, ну понятно тут без комментариев. То есть,
в результате вставка получается вот такой, значит алгоритм. Вроде не сильно сложный, да. То есть,
проходим по пути поиска, то есть проходим по пути поиска, пока не находим место, куда надо
вставить ключ. Его вставляем. После этого возвращаемся из рекурсии и в каждой вершине
проверяем, что если разность высот под деревьев равна два, просто выполняем нужное вращение.
Казалось бы, вот кайфец. Да, вот многие действительно считают, что никаких вопросов тут не возникает. Но,
к сожалению, лично у меня возникает. Нет, почему залог? Ну потому что у нас высота дерева была
корректная. Помните, у нас корректный инвариант, значит, адекватно. Тут она там, то есть мы тут
работали за от тоже высоты дерева. То есть, она может там изменилась на сколько-то, но то все равно
инвариант в итоге соблюлся, поэтому все равно в порядке. Мы все равно работали от старой высоты,
поэтому все в порядке. Ну да. Ну тут надо да. Нет, ну как сказать? Нет, ну тут надо уточнять
вопрос. Нет, вращение можно повернуть, потому что просто никто нам не мешает взять и сделать вращение.
Да, именно. Потому что на самом деле действительно тут вытекает четкий вопрос, который меня лично
возит до экзамена. А кто сказал, что у вас не возникнет ситуация, когда разность высот равна 3 или 4 или 57?
И что? Только проблема в том, что вы еще какие-то поддеревья меняете, то есть вы еще какие-то
повороты делаете. Может у этих поворотов тоже высоты как-то поменяются. Инвариант такой,
наше поддерево починено и мы не трогали, а все что выше нашего мы не трогали. Да, ну может оно починено с какой-то
принципиально другой высотой.
А может же быть, что у тебя в начале была дерева, вот в вершинке А высота H плюс 3, осталась вершинка C, а вот H плюс 2, а у брата А была H плюс 4.
У нас в текущей высоте корня вращаемого дерева, она изменится не больше чем на 1, изменится не больше чем на 1,
потому что мы показали, изменится не больше чем на 1, уменьшится не больше чем на 1.
Ну, по сравнению с тем струбичей, да, но тут уже правда, но как бы обойдите внимание, то есть для этого пришлось все-таки еще пару
нитривиальных действий сделать. Как минимум нарисовать эти H. Значит, смотрите, то есть доказательство будет звучать, то есть действительно,
аккуратное доказательство будет звучать так, что, то есть надо просто по индукции попробовать доказать, что после вставки,
значит, утверждение такое, когда вы делаете, то есть после вставки, значит, таким вот образом высота дерева не уменьшается,
это важно, и увеличивается не более чем на 1. Нет, именно после, ну, в результате, то есть жила была дерево высоты H.
Я вот считаю, что после того, как мы вставим туда вершину и проверим вот это вот все, то высота дерева будет от H до H плюс 1.
Вот, вот мы сейчас попробуем это доказать по индукции. Значит, как мы это будем делать? Ну, значит, смотрите, когда мы приходим в корень,
мы думаем, куда вставлять, влево или вправо? Ну, давайте без ограничений обществе предположим, что мы вставляем вправое под дерево, да?
Тогда мы замечаем, что высота этого вправо под дерево, она по предположению индукции не уменьшается и увеличивается не более чем на 1, да?
Но заметим, что если разность высот между детьми корня при этом осталась не более чем 1 в ту или иную сторону,
то тогда мы вынуждены заключать, что и у корня высота тогда получается не уменьшится и увеличится не более чем на 1, то что надо, правда?
Так понятно, что я говорю? Так, непонятно. Ну ладно. Значит, хорошо, давайте то же самое, но нарисуем.
Ну и смотрите, итак, то есть по идее как бы эта штука реализуется рекурсивно, то есть в том плане, что вы приходите в вершину,
вы хотите добавить в нее какой-то х, да? И вот у нее есть левое под дерево и правое под дерево.
И вы говорите, так, давайте, тут была высота какая-то h, тут была какая-то высота, ну, допустим, от h-1 до h-1, да?
Понятно, да? Вот, но заметим следующее, что, значит, здесь после того, как вы вставили вместо h, у вас теперь высота стала от h до h-1.
Но теперь заметим следующее, что если разность высот оказалась все еще не более чем 1 в ту или иную сторону, то тогда оказывается, что действительно,
то тогда мы просто должны все, что мы должны сделать, теперь пересчитать высоту вот этой вершины, которая, очевидно, либо не поменялась, либо увеличилась на 1, согласны?
Что? Нет, это я сказал в предположении, что тут разности высот адекватны. То есть тогда никаких проблем нет, все доказано.
Это пока все, что я утверждаю. Вот, но может оказаться проблема, если с высотами возникли проблемы.
Это могло быть только в том случае, если тут была высота h-1, там, тут была высота меньше, то есть тут h-1, а тут была высота h, которая торжественно превратилась в жесткий h-1.
Вот. То есть вот такая вот красота. В этом случае тогда здесь высота становится по камере локально h+, то есть было h+, стало h+.
И теперь все, что нам надо, это доказать, что в результате поворота, который мы сделаем, высота все еще будет либо h+, 1, либо h+, 2. То есть если это мы сделаем, мы победили.
Мы по индукции предположили, что справа. Да, да, по индукции, по, ну, например, количеству вершин. Ну, нет, по высоте тут не аккуратно.
Ну, хотя, ну, 8, ну, лучше по количеству вершин, так совсем надежно. Вот.
Вот. Нет, понятно, это я, конечно, ловлю флешбек из кучи фибоначчи там, конечно, но все-таки. Вот. Значит, ну давайте разбираться.
То есть как бы перед поворотом, ну, тут у нас правда получился сдвиг, то есть тут у нас правда исходно сдвиг, то есть исходно высота была h+, 3.
Но как бы это не суть важна. То есть как бы нам сейчас надо просто убедиться, что после поворота высота будет либо h+, 3, либо h+, 2.
Но мы в этом оба раза уже убедились. Видно, да? То есть просто вот даже картинку перерисовывать не надо.
Вот. То есть мы уже в этом аккуратненько убедились, и это как раз и дает нам возможность заявить, что все в порядке.
То есть вот видим, чтобы аккуратно доказать, что с высотой все в порядке, нужно еще вот пару нетривиальных действий проделать с точки зрения формальной математики.
Чего? Последний шаг, что мы сказали? Ну последний шаг сказали так. Предположим, что надо делать поворот.
Тут h+, 1, тут h+, 2. Ну давайте сдвинем еще h так, чтобы это было h+, 2 и h+, 3.
Ну это просто для того, чтобы у нас тут картинки совпали.
И заметьте, что мы сделаем либо вот этот поворот, и тогда у нас высота будет какая-то такая, либо вот этот поворот, и тогда у нас высота будет ровно h+, 2.
Так что вот такая красота.
Вот. Так что вот так у нас работает вставка.
Вот как вы думаете, как же у нас работает удаление?
Как оно тут может работать, действительно, как вы думаете?
Чего? Ну, да, но идея действительно такая, да.
Вот. Ну то есть по факту делаем вот как-то удаление, которое мы раньше обсуждали, но при этом там, видите, в одном месте там происходит не удаление, а просто замена.
И все, что вам останется, но в какой-то момент реально какую-то вершину придется удалить, и под дерево ее, точнее то, что на месте ее будет уменьшиться ровно на 1.
Но на самом деле вот именно, то есть как вы помните, то есть как бы, то есть там в худшем случае удаление будет так, то есть идем-идем-идем-идем-идем, хотим удалить эту вершину, но у нее два под дерево.
Поэтому мы тут идем-идем-идем-идем-идем-идем, и вот это удаляем, это переподвешиваем.
Вот. И начиная уже с этого момента, конечно же тут проходим, то есть делаем все это отступаем, то есть идем рекурсивно, и приходим и доходим до корни.
Вот, понятно, да? Вот, ну делая абсолютно те же самые вращения.
Ну вам только в качестве упражнений останется только показать, что тут действительно будет все адекватно.
Вот, понятно?
Ну то есть там условно, что сначала там, ну там доказать, что там, что если у вас удаление произошло где-то в под дерево, то как бы там, то в итоге высота как бы либо останется той же, либо уменьшится на 1 в результате всех поворотов.
То есть получается вот такая вот надежная штука.
Почему она работает за логарифом?
Почему она работает за логарифом? Потому что, ну ключевой ответ такой, потому что мы работаем от высоты, которой она была перед вставкой или удалением.
Вот, это во-первых, а во-вторых, значит перед непосредственно удалением соблюдался инвариант.
А у нас в самом начале была теория о том, что если у двоичного дерева соблюдается вот этот инвариант, что разности высот адекватные, то это от логарифма.
Ну не логарифом, но от логарифма.
Вот такая вот красота.
Вот, ну на самом деле, как мы с вами, видимо, в следующий раз убедимся, на самом деле с точки зрения всех олимпиадных задач этого достаточно.
То есть вам не нужно знать, что такое дикартовое дерево, на самом деле нужно знать только это.
Вот.
И вот в следующий раз мы, видимо, и подробно обсудим, как это делать.
То есть на самом деле сплит и бёж прекрасно поддерживает и АВЛ, и красно-чёрное дерево, и, конечно, в первую очередь Б-дерево, с которым мы и начнём.
Это так, забегая вперёд. То есть на самом деле, как бы там, как бы с точки зрения теории, красно-чёрное, то есть дикартовое дерево не нужно.
И вот сплей ещё куда не шло, он там нужен в одном месте. А чтобы линкат адекватный был.
Да.
Да, потому что если вы линкат напишите с АВЛ, то, соответственно, будет логарифм в квадрате.
А если напишите со сплеем, то почему-то будет логарифм.
Нет, ну не то чтобы почему-то, мы с вами даже ещё и распишем почему, собственно.
Ну вот, но там красиво.
Вот.
Но это, видимо, в будущем. Пока же, вот такое у нас, пока же первое историческое дерево было вот такое.
Ну, в принципе, идея на его может и хватить.
Вот.
Значит, идея на всё логарифм, казалось бы, что ещё надо.
А всё?
Презентация закончилась? Ничего страшного.
Ничего страшного.
У меня ещё есть.
У меня ещё три есть, да.
О.
Да.
Значит, потому что, смотрите, какие у нас проблемы возникли.
Почему мы рассматриваем ещё какие-то деревья?
Нет, формально говоря, на самом деле, в стандарте плюс-плюс, если его открыть, скорее всего, вряд ли будет возражать.
Против того, чтобы вы подсунули в качестве СТД-сета, там, скажем, АВЛ-дерево.
Прямо в явном виде написано, а ну-ка.
Ага, ну вот да.
Но, правда, чаще, почему-то считается, что реализуют скорее красночёрта.
Вот.
Но есть причины, на самом деле, почему.
Чем вообще, давайте подумаем.
Давайте подумаем, какой может быть недостаток в АВЛ-дереве вообще в принципе.
Ну, первая причина, конечно, память.
Потому что в каждой вершине вы в явном виде должны хранить высоту.
Но, да, но, тем не менее, сколько-то байт на это потребуется.
То есть, если предположить, что у вас там эта высота влезет в байт.
Допустим, даже.
То это всё равно означает, что на Н-элементов потребуется Н-байт лишней информации.
Нет, ну скажем так, если вы храните деревья, то да, без указателей никак.
Но помимо этих указателей, остальную память тоже хочет оптимизировать.
Вот.
Как бы, такие вот ещё балансики.
Нет, тут ещё такие балансики.
Но, на самом деле, есть ещё причины.
Потому что тут ещё вопрос, что нам приходится делать логарифом вот этих вот вращений.
Проблема, конечно, не в том, что нам там лень что-то кодить или в чём разбираться.
Потому что эту проблему, конечно, Красночёрное Дерево не решит, забегая вперёд.
Но проблема будет в том, что этих поворотов программа будет выполнять слишком много.
То есть как бы это формально логарифом, но какой-то жирный нельзя сделать.
То есть поворот – это перестраение дерева, перестраение каких-то итераторов.
Особенно, если вы знаете, вот отдельная песня, как в STL реализуется вот этот итератор плюс-плюс в сете.
Или итератор минус-минус.
Ну вот, то есть там приходится... Вот видите, тут тоже трейдол.
Потому что чисто теоретически, если нам плевать на константу по времени и по памяти, то есть вообще очень тупой вариант.
А давайте для каждого элемента тупо хранить указатели на следующие и предыдущие.
А если ещё и в каждой вершине вы храните ссылку на самый левый и самый правый в поддереве,
то, в принципе, тогда при всяких переподвешиваниях и рекалькулейтах вы это всё будете переконнекчивать без проблем.
То есть теоретически спокойно делается, но практически это жирно очень.
То есть, помните, после STL он в этом месте начинает очень жёстко трейдофить.
То есть как бы он говорит, что мы жертвуем тем, что плюс-плюс будет работать за О от единицы прям жёсткие.
Если вы пробираетесь от beginning до end, то он будет работать за О от единицы в среднем, в амортизированном смысле.
Но каждый конкретный плюс-плюс может работать за, дай бог, что благорифу.
Я бы очень хотел в это верить.
Но в этом месте решили, что лишние указатели с предподсчётом лучше не хранить – это мелочь.
Чем может помочь красно-чёрное деревья?
Красно-чёрное деревья могут помочь тем, что мы не храним никаких высот в дереве.
А вместо этого, помимо стандартных лево-право-указателей, право-указателей и, видимо, указателей на родителя,
мы будем хранить цвет.
То есть каждая вершина у нас будет одного из двух цветов.
Волею авторов эти цвета будут красный и чёрный.
Остаётся загадкой, почему они не зелёные и серо-бурмалиновые, но они выбрали так.
И так смотрите.
Но, конечно же, будут инварианты.
Инвариант будет жёсткий.
Но не самые жёсткие.
Каждая вершина у нас бывает красной или чёрной.
Корень всегда чёрный.
Так же каждый лист.
Сразу говорим оговоречко, что вершина с ключом листом не является.
То есть у нас листами могут быть только фиктивные нулечки.
Это нам только для идеи нам нужно, в коде мы это вряд ли будем использовать, но подразумевать такое будем.
Понятно, что все эти нулечки создавать не обязательно,
на самом деле достаточно создать максимум одну такую вершину, да и то не обязательно.
Ну и то, хотя иногда удобно её создать, чтобы было удобно смотреть, а какой цвет у моего ребёнка.
И чтобы там не разбирать в случае, а он есть вообще? Нету, тогда чёрный.
Ну а какие ещё инварианты будут?
Все такие нулечки чёрные заведомо, корень чёрный.
Значит ещё идёт, что в некотором смысле у нас нету двух идущих подряд красных узла.
Ну в том плане, что если узел красный, то гарантируется, что оба его ребёнка чёрные.
То есть как бы у чёрного ребёнка может быть какое угодно, но у красных ребёнки только чёрные.
Вот, так что вот так вот.
И конечно самый весёлый инвариант, внимание, для любого пути,
значит если вы рассмотрите абсолютно любой путь от корня до нулечка, до нулечки,
то количество чёрных вершин, которые вы там найдёте, будет абсолютно одно и то же для всех нулечек.
Это от корня или от корня?
От корня.
Ну правда, от того, что это верно от корня, следует, что если вы корень замените на любую вершину в дереве,
это тоже будет верно, если вы будете рассматривать нулечки в её потопках.
Да, это одно и то же.
Ну то есть для каждой вершины это будет другое число, но оно будет одно и то же.
Ну я имею в виду в том плане, что вот смотрите, вот в этом красно-чёрном дереве,
например, вот мы идём от корня, видим раз, допустим два, три, четыре, вот пойдём сюда,
что будет раз, два, три, четыре, там пойдём куда-нибудь вот сюда, что будет раз, два, три, четыре.
Да, именно чёрных, это важно.
То есть как бы видите, то есть по чёрному у нас всё жёстко, а вот красные иногда влезают.
Но видите, они влезают аккуратно.
Они влезают аккуратно в том плане, что как бы на пути не может быть две подряд красные вершины.
Так, ну понятно, да, это красный такой цвет, да, вот, соответственно.
Вот, но тем не менее все чёрные высоты у нас одинаковые.
Как бы это нам гарантирует, что высота всего дерева у нас логарифмическая.
Хотя вот видите, что сбалансированность в смысле АВЛ-а у нас, конечно, уже никак не гарантируется.
Потому что как бы при одинаковых чёрных высотах, видите, мы там одно дерево можем оставить как есть, а во второе понавешивать кучу красных.
То есть высоты могут прям у под деревьев аж в два раза отличаться.
Вот.
Вот, но есть пара не очень сложных леммочек, которые нам гарантируют, что если у нас дерево состоит из N вершин,
по крайней мере внутренних, не считая нулечек, то тогда у нас получается, что высота не превосходит двух логарифмов.
Чёрная высота, black height.
Вот.
Вот.
И так, то есть вот такая вот красота. То есть по дереве, к чёрному узлу Х, как можно легко проделать по индукции,
содержится как минимум вот столько чёрных вершин.
Ну просто потому что у него что у него есть? У него как бы либо есть два чёрных сына, либо один чёрный сын и там два чёрных внука,
либо четыре чёрных внука.
То есть две, три или четыре вершины, чёрные вершины, то есть разобьёмся по тему черного.
и там два черных внука, либо четыре черных внука, то есть две,
три или четыре черные вершины, то есть там черных, так сказать,
потомка, каждый из которых является вершиной с черной высотой на единичку меньше.
Отсюда, в общем-то, и по индукции.
И это только черных, обратите внимание.
Вот. Вот, но дальше тут.
Полеем черную, тоже отсюда понятно, что тут высота, да, логарифум умножить на два,
то есть по высоте тоже мы не то чтобы прям обгоняем АВЛ,
потому что УВЛ логарифум по основанию ФИ, а как бы логарифум по основанию ФИ,
это явно, он отличается от логарифум по основанию два меньше, чем в два раза.
Ну почему? Потому что там, понятно, логарифум двойки по основанию ФИ явно меньше двух,
потому что ФИ в квадрате это сколько там? Ну там 256, и это только нижняя оценка.
Вот. Так что-то получается, что опять, если мы каким-то образом поддерживаем этот инвариант,
то тогда высота у нас логарифмическая, все хорошо. Осталось только выяснить,
как его поддерживать. Точнее, как делать ставки и удаления. Ну, как поиски делать,
очевидно, да, вот как делать ставки и удаления. Так, ну на чем с халявочки?
Значит, ну да, тут все очень просто. Добавим в дерево, как в обычную вставку,
то есть делаем честно-честно-честно-честно. Когда вставляем вершину, внимание, делаем ее красной.
То есть когда мы новую вершину вставляем, мы как бы вставляем ее как красной. Если у
нее родитель при этом оказался черный, то вообще никаких проблем нету. Просто сразу. Неплохо, правда?
Так, или вопрос? Так, понятно, что происходит. Ну, то есть, ну то есть вот да, то есть да,
слово как обычно. Это понятно, да? Ну, типа да. Ну, на место листа. Да, но как бы имеется в виду так,
то есть по факту, что просто если мы понимаем, что его нужно вставить вот куда-то, скажем,
сюда, то мы просто вешаем сюда новую красную вершину, которую будет два этих черных листа.
Вот мысленно мы вот так делаем. Вот, понятно? Вот. То есть опять же, то есть можно по факту,
то есть мы тянула их черные, они у нас скорее мы их мысленно имеем в виду. Вот. Так, ну вот.
Но какие у нас проблемы могут? Как вы сказали, если мы сделали новую красную вершину, то есть
черными высотами никаких проблем нет. Проблема может быть только, если у нее родитель красный.
То есть поэтому и говорим, если родитель черный, то проблем нет сразу. Вот. То есть типичная такая
ситуация. Вот. Соответственно. А если у нас, ну вот, но что делать, если родитель красный? То есть мы
красные, родитель красный. Непорядок. Это надо исправлять. Но если мы просто покрасим родителя
в черный, то тогда у нас проблема с высотами. То есть, к сожалению, нельзя просто так взять и
покрасить родителя в красный. Можно было с тем же успехом сказать, а давайте мы будем черные сразу.
Но нельзя просто так взять и стать черным. Вот. То есть, к сожалению, тут. Ну да, да, в этой теме
всегда так, да. Вот. Но ничего. Но ничего. Значит, у нас будет специальная функция вставка пофиксить,
которая будет заниматься перекраской вершин и, возможно, какими-то поворотами. Значит, и так.
Ситуация. Предположим, значит, инвариант. Значит, инвариант. У нас дерево, ну у нас дерево, в принципе,
хорошее. Там все в нем хорошо, только кроме одного. Есть красная вершина, у которой есть красный
родитель. Но это только один раз происходит? Да-да-да, только один раз. Все, да. Вот. Так что это вот
типа считаем, что это единственная проблема. Так вот, значит, мы тогда это решаем проблему так. Да, ну
вот, это вот мы нарисовали. Вот такая проблема, допустим. Ну, в принципе, из этой картинки виден и
первый случай. Предположим, что нам фантастически повезло. Ой. Да, тут вот. Да, тут написан какой-то текст.
Вот. Значит, смотрите. И предположим, что нам фантастически повезло, что не только мы родитель
красный, но и дядя красный. Вот. То есть у нас такая хорошая индейская семья. Да. Но тогда, но тогда
мы говорим, нет, ну дед-то, понятно, черный, но это временно. Тогда мы говорим, тогда мы говорим так,
значит, что дорогие родитель и дядя, поздравляем, вы теперь черные. Так, ну у нас же проблема с черными
высотами. Ничего. Дедушка, теперь ты красный. Так, ну у меня же и родитель красный. Теперь это твои проблемы.
Вот. И да. И мы в данном случае, можно сказать, рекурсивно продолжаем решать проблему уже с этой
вершины. Да, но тут сразу оговорка, что если оказалось, что если у нас дед оказался корнем,
значит мы тупо его, вот к его-то мы уже можем покрасить черный. Да, обратите внимание. То есть
инвариант черной высоты не нарушается от перекраски корня в любую сторону. Поэтому, если в какой-то
момент проблемной вершиной стал корень, то мы просто корень перекрашиваем в черный цвет и
заканчиваем работу. Вот. Но если дедушка все-таки еще не совсем корень, то значит, он становится
красненьким и мы уже продолжаем. Но обратите внимание, вот что нам будет важно. Мы не сделали
ни одного поворота. Мы просто перекрасили вершины. Да. Перекрасили деда, перекрасили папу,
перекрасили дядю. В общем, хорошо. В общем, кто из нас ездит в лагерь, это называется. Вот. Но
проблема в том, что дед так обрадовался, что, возможно, пойдет перекрашивать дальше. Будет
пройти. То есть он так идет, идет, идет по поколениям. Значит, перекрашивает, перекрашивает,
перекрашивает. В какой-то момент может вышло очередного дедушки. Там родитель черный. Тогда
больше ничего делать не надо. Причем тут Кукук Слан не перекрашивает. Кукук Слан, он как бы,
он убивает черные вершины. Мы здесь никого не убиваем. В софт хипе, ну как бы. Ну да.
Нет. Смотрите, мы нет по-доброму. Мы нет. В софт хипе мы тоже никого не убиваем. Мы
убиваем вершинки, но когда-то выясняем, что ключиков в них уже никого нет. Потому что мы
специально, мы даже заранее храним все ключики не в самих вершинках, а в специально подогнанных
автобусах. И как бы уничтожаем вершинку, когда поняли, что автобус пустой. То есть все аккуратней,
то есть как бы все по технике безопасности. Ну по сути, нет, ну на самом деле это да,
автобус был просто трамваем на самом деле, мы их просто подцепили на самом деле, можно так
выяснить еще. Вот. Итак, идем дальше. Случай два. Предположим, неожиданно выяснилось,
неожиданно выяснилось, что все-таки там дядя все-таки черный. Нет, ну не важно. Ну вот,
на самом деле типичный случай для нас был бы вот такой. Но на самом деле, значит сразу оговоримся,
мы, то есть нам тут сейчас начнется тогда принципиально, ну вот, а мы нашему родителю кто? Мы
нашему родителю левый ребенок или правый? Ну не столько важно сами мы левый или правый,
а сколько такие же мы родителю, как родитель деду. То есть образуют ли родители дедушка со мной
зиг-заг или зиг-зиг? Да, это я, конечно, тоже там взял терминологию следующего дерева, но тем
не менее. Вот. Но это обычно вот это называется зиг-заг, это зиг-зиг. Вот. Так, но первое,
с чего мы начнем, это сведем случай зиг-зага к случаю зиг-зига за один простой поворот.
Да, мы никаких проблем мы не решили, но просто вот теперь мы как бы, мы от родителей висим с той
же стороны, что и родители на дедушке. Понятно, да? Да, то есть заметим, я тут рисую под деревья,
они все черные. Почему я тут в явном виде не рисую вершину? Потому что обратите внимание,
сюда мы здесь мы обрабатываем случаи, когда вот эта дельта является нулечкой. То есть, да, то есть
как бы мы подразумеваем, что как бы эта нулечка существует. То есть мы как бы имеем в виду,
что мы не имеем права с этой нулечкой ничего делать, то есть там отпиливать от нее детей и там вот это
все, потому что может у нее детей и нету. То есть да, то есть как бы нам удобно считать, что дядя у нас
есть. То есть да, он нулечка, но возможно, но тем не менее, но главное он есть. Вот, так вот, это был
случай 2b, который сводится 2a. Ну да, в презентации написан текст, но как бы, вот лучше сразу картинку
смотреть. Так вот, что мы теперь делаем? А теперь мы делаем маленькую мистическую вещь. Ну, мы
делаем, после вот этого возможно малого поворота, мы делаем еще вот этот малый поворот.
Ну, мы бейце по сути повернули, обратите внимание. И немножко перекраски, то есть бывший родитель
теперь, но он остается нашим родителем в общем-то, но он теперь становится черным, а дядя становится
красным. Дедушка, ну как бы, ну дедушка стал сыном родителя, ну нормально, вот. Вот, и да, а теперь
немножко магии. Теперь заметим, что это все, потому что больше у нас никаких проблем нет, потому что
было у нас, жили мы вот в поддереве с черной вершиной и остались в поддереве с черной вершиной. Были у нас
проблемы только в этом поддереве и только вот с этими вершинами, и они ликвидировались. Ну и само
собой никаких проблем с черными высотами, естественно, не испортилось, потому что была
черная вершина и под деревья, альфа, бета, зама, дельта, и они в общем-то и остались, просто мы пути
к ним немножко переписали. Потому что мы рассматриваем случаи, что дельта не красная. То есть
это вот, то есть, случай два, это случай, когда дельта черная. Вот, но альфа, бета, гамма понятно,
почему черная, потому что да. Чего? Да. Вот. Но тогда, смотрите, то есть, вот и на этом получается
все. То есть, в чем преимущество приятное? То есть, ну да, код выглядит вот, получается,
примерно вот таким же образом. Да, ну реального кода в два раза больше, потому что вам придется
второй случай рассмотреть. Ну там, по сторонам на этот раз, да. Ну или там, на самом деле,
может быть, еще теоретически там, как бы, можно попробовать там реализовать код так, чтобы избежать
копипасты. Ну там, написать какую-нибудь функцию, которая будет там, скажем, то есть, написать
функцию, которая будет по нулю выдавать левт, там по единице выдавать райт, и там иногда,
там, можно там подсовывать инверс на ту функцию, чтобы она там мыслила наоборот. Но это, в общем,
пока мелочи. Это видите, код не сильно сложный, но обратите внимание, ой, но это уже технические
дела. Но пока, вот прежде чем мы пойдем дальше. Вот. Но здесь у нас просто идея возникает в
следующем. Просто почему это круто? То есть, обратите внимание, то есть, раньше в ВВЛе мы делали
вставку, и там мог быть логарифом вращений, в том числе и больших. Здесь, обратите внимание,
мы сделали вставку за всего лишь максимум, если не повезет, два поворота. То есть, два поворота и
какие-то локальные перекраски. Но это, как бы, по констанции, это, я думаю, это несравнимо, правда.
Ну да, но лог перекрашивания и лог поворотов это, как бы, сильно разные логи, не правда ли. Вот.
Поэтому, видите, то есть, тут, как раз, эти константы по памяти чуть лучше, так что получается хорошо.
Ну, правда, да, там можно, правда, думать, а нельзя ли обойтись без хранения родителей. Но,
чаще всего, обычно и в ВВЛе, и в красночерном, они нужны в одинаковых местах. Избавляемся мы
от них по принципу, давайте, когда идем в рекурсию, просто выписываем весь рекурсивный путь.
Ну вот, и тогда нам в явном виде родителей хранить вроде как и не надо. Не там, не там. Вот. Так что
вот такая вставочка. Но, конечно, за эту красоту, ну, то есть, вот за красоту, что у нас мало поворотов,
приходится, конечно, расплачиваться интеллектуальным образом. Поэтому сейчас,
видимо, последнее, что мы сегодня сделаем. Так, но не надейтесь, что мы сейчас за две минуты
сделаем, сразу предупреждаю. Но как бы, вот. Но это как последнее усилие. Это его величество удаления.
Потому что, к сожалению, да, в отличие от ВВЛки, это не тот же самый случай. Почему? Ну, в ВВЛке как-то,
да, у нас все одинаково получалось. То есть, мы там то ли удалили, то ли вставили. Ну, а потом
проходимся, возвращаемся рекурсивно по пути, в который мы туда шли, и просто делаем какие-то
локальные поворотики. Все одно и то же. То есть, как бы, дизбаланс решается одинаково. А тут
заметим, что мы будем делать удаление. Но когда мы тут делаем удаление из обычного бинарного
дерева, то тут будет принципиально другая проблема. То есть, раньше у нас была просто проблема,
что у нас у красной вершины красный родитель надо пофиксить. А тут теперь другая проблема.
Тут на этот раз у нас возникает проблема с черными высотами. Ну, точнее так, если вершину,
которую мы удалили, мы удалили красную вершину, то никаких проблем нет. Чего? Чего как кого смержить?
Не, погодите. Обычное деление у нас не подразумевало мёржить детей. Оно нас
подразумевало подменить вершину. То есть, перекопируйте туда ключик, по сути. А ту вершину
удалить. Поэтому, когда мы удаляем вершину, то есть, как бы, мы считаем, что там у неё не более
чем одного ребёнка. Вот. Так вот, если мы её выпилили, если она была красной, то с черными
высотами никаких проблем нет. Да, но нет, мы не с листом. Там не так. Ещё раз. Мы, значит,
доходим до этой вершины, хотим её удалить. Но выяснять, что у неё двое детей. Тогда мы эту вершину
как вершину не удаляем. Мы идём там вот это, в правое ребёнка находим там минимальный элемент и
копируем ключик из него сюда. А потом удаляем вот эту вершину. Вот. А это идентично по случаю,
когда мы удалили чёрные элементы, это проблема. Да, то есть, обратите внимание, я сказал,
копирую ключик, то есть, я тут никакие цвета, я тут ничего не делаю. Вот. Так что нас вот
интересует удалённая именно вершина. Но это проблема. Вот. То есть, действительно, если она
чёрная, то у нас, оказывается, есть какая-то вот проблема, то есть, с балансом проблема. То есть,
можно как бы объявить даже инвариант теперь проблемы. Что у нас с высотами всё хорошо по
модулю одной вершины, у которой глубина, чёрная глубина, полностью корректная, по всем путям из
неё идущим, но на единичку меньше, чем надо. То есть, по сути, существует вершина, что пути от
корня до листа через неё на единичку меньше, чем от корня не через неё. Понятен вариант, да? Вот.
И вы этот вариант должны как-то покрыть. Ну вот. А больше проблем нет. То есть, там условно корень
чёрный, там у красных, у красной вершины всегда там чёрные дети. То есть, это всё нормально. Значит,
поехали. Как делается delete fixup? Ну, тут вот. Ну, как всегда. У нас есть проблемный узел X.
Вот. Получается условие одинаковой чёрной высоты и, соответственно, нарушен только в X. Ну, в общем,
как мы уже сказали. Вот. И тут у нас случаев будет аж на 4. Итак, вот у нас проблемная вершина X.
Она у нас, да. Сразу заметил, что она чёрная. Потому что, если выяснилось, что проблемная вершина
красная, то мы её просто красим чёрной и говорим окей. Пологично, да? Вот. Потому что, поэтому
проблемный узел X у нас всегда чёрный. Так, ну давайте смотреть. Предположим, что нам повезло. И
оказалось, что наш брат красный. Спрашивает, что тогда делать? Ну, правда, не то чтобы мы победили
от этого. То есть, на самом деле, мы делаем просто поворот, небольшую перекраску. Вот. Ну, и на самом
деле ничего не поменялось. Потому что вершина X по-прежнему осталась проблемной, потому что мы
в её под деревень ничего не сделали, обратите внимание. То есть, разница ли в том, что мы
просто сказали, что у меня брат красный, быстро сводим к случаю, когда у меня брат чёрный. Да,
но обратите внимание, что тут ни одной вершины, кроме этой, очевидно, красной быть не может,
потому что все остальные вершины это либо её дети, либо её родители. Это значит, что брат нулечко,
и он чёрный. Поэтому вот мы сводим к ситуации. То есть, второй случай, когда, как говорится,
я чёрный, мой брат чёрный. Давайте устроим вечеринку. Вот. Значит, соответственно, и так поехали.
И так, значит, начинаются случаи. Случай, который я назвал два чече. Вот, случай два чече.
Так, да, давайте, давайте. Значит, вращаем, так, вращаем АВ, вот, и делаем перекраску,
чтобы Б чёрный, А красный. Ну да, то есть, да, брат теперь С. Но с высотами, как видите,
никаких проблем. С чёрными высотами проблем никаких. Ну, то есть, проблемы те же,
что и были раньше. Вот. Так, сейчас понятно? Всё? Мы это сделали для того, чтобы свести,
чтобы свести случай к другому случаю. То есть, как бы теперь мы переходим к случаю, что мой брат чёрный.
Вот. Ну вот, и так возвращаемся к чече. Так, так, что у нас в чече? Ну, в чече говорит,
что давайте не только мой брат чёрный, но у него дети чёрные. Вот. А родитель непринципиально кто?
Потому что, значит, какая у нас идея? Ну, вот, идея такая. Давайте покрасим А, скажем,
что теперь этот непонятно, кто теперь точно чёрный, а Б всё-таки красный. Вот. Соответственно. Ну,
теперь заметим маленькую приятную вещь, что в принципе, ну, вот, теперь давайте какие тут
случаи могут быть? Ну, тут два случая. Если А была красной, то у него была чёрная высота BH,
ну, по модулю этого безобразия, и она в итоге стала BH. И тогда, получается,
если она была красная, то надо просто её покрасить чёрной и больше ничего делать не надо. Мы победили
вот прямо сейчас. Вот. Понятно, да? Да, нет, наверное. Да. Ну, то есть, смотрите, если она была красной,
тогда тут чёрная высота была BH. И была только проблема Х, что тут вот плохо, да? Ну, тогда,
но тут чёрная высота BH. Но если мы перекрашиваем эту вершину в красный цвет, тут по-любому высота
BH минус один, правда? Вот. Но есть, ну, вот, тогда тут BH минус один и тут BH минус один. Тогда,
если эту вершину перекрашиваем в чёрный, то высота снова становится BH. То есть, вот эта вершина,
как была раньше BH, так и осталась BH, только теперь вершина Х перестала быть проблемной.
Вот. То есть, вот такая вот радость. То есть, получается, если вот вершина А красная,
то мы прямо сейчас решили вопрос. Если же она была чёрной, то тогда, то есть, если она и была
чёрной, то тогда у нас тут BH, но был BH плюс один. То есть, получается, проблемной вершиной стала
вершина А. И мы переходим дальше. Вот. Вот. То есть, получается, перекинулись на немножко выше.
То есть, это если у нас вершина А была чёрной. Ну, поехали дальше. Случай два КЧ.
Это ближний к нам племянник красный, дальний чёрный. Вот. Да, что мы тут делаем? Так,
ну, тут мы делаем, конечно, немножко мяса. Вот. Значит, что мы тут делаем? Ну, на самом деле,
опять же, как бы, то есть, мы тут немножко это перекидываемся случаями, потому что в случае два КЧ мы
сводим к задаче два звёздочка К. Это будет последний случай. То есть, мы добиваемся случая,
когда у нас красным является дальний племянник. Вот. Видно, да? Вот. То есть, как бы, если красным
оказался именно ближний племянник, да, то, но дальний нет, то, значит, делаем немножко поворотов.
То есть, делали чуть-чуть поворотов, чуть-чуть перекраски. Видите, тут тоже перекраска есть,
да? И свели ситуацию, когда у нас, и свели ситуацию, когда у нас дальний племянник красный.
А ближний непринципиально? Что? А ближний непринципиально. А здесь же у нас, здесь же у нас,
ну здесь мы железно знаем, но вообще нам в этом случае непринципиально будет. Вот,
как это будет работать, смотрите. Ну, мы просто не будем его трогать. То есть, смотрите,
итак, ситуация два звёздочка К. Что же мы в ней делаем? Да, мы не знаем, кто у нас
ближний племянник, и мы не знаем, кто у нас родитель. Значит, смотрите, идея такая. Значит,
опять делаем поворот на АВ и делаем перекраску, в которой А становится чёрной,
а В становится, внимание, тем, чем был корень до этого. Да, то есть, ну, С мы не трогаем вообще,
да? Ну, то есть, под дерево С оно вот как было, так и остаётся, да, то есть, мы с ним ничего не
делаем. Ну вот, а вот этот цвет, то есть, цвет А становится цветом В. Вот, и при этом Д мы тоже
перекрасываем в чёрный. Ну, тогда я вот, и тогда, как легко убедиться по высотам, получается всё в
порядке. То есть, была высота ВH плюс там, только там, чёрная ли это, и остаётся ВH плюс чёрная ли это.
Вот. Так что вот такая красота. Вот, и получается, что проблем, смотрите, проблем никаких нет,
а раз у нас, ну, вот, то есть, уже проблемы все порешены, значит, получается два звёзд
это финальный случай, больше ничего делать не надо. Победа. Вот. Осталось только выяснить,
ну, то есть, получается, вот такие четыре случая мы рассмотрели, осталось только выяснить,
за какую асимптотику эти случаи вообще работают. А то, может быть, это бесконечная асимптотика,
что-то они друг другу как-то едва ли не зацикленным образом сводятся. Ну, вот. Ну,
и здесь давайте разбираться. Давайте посмотрим, за сколько это работает. Ну, тогда мы, давайте,
слева справа налево. Случай два звёздочка К работает за от единицей, то есть, вообще, за один поворот.
Видите, да? Случай два КЧ тоже работает за от единицей, правда, уже за два поворота. Ну,
потому что один поворот плюс случай два звёздочка К, понимаете, да? Так, а что у нас здесь? Так,
случай два ЧЧ. Так, вот, случай два ЧЧ, он нас перекидывает на вершину с большей чёрной высотой.
Так, но какая, но какая, какой у неё реализуется случай? Вот какой-то. Так, а единичка? Ну, вот,
с другой стороны, да, теперь мы видим, что, вот, так, но видим, что, что у нас делает единичка. Вот. Ну,
вот, если у нас происходит единичка, то здесь кажется, что здесь мы просто сводимся к какому-то
случаю, причём даже непонятно какому. То есть, брат, то есть, мы гарантируем только, что брат чёрный,
а кто у нас дети, а чёрт его знает. То есть, получается, на, казалось бы, на случаях один и два ЧЧ возникает
какой-то зацикл. Что же делать? Тем более, это вот такой зацикл, видите, что в случае один глубина,
как бы, но, то есть, то есть, глубина даже ещё как-то изменяется. Ну, хотя, действительно, хотя ладно, по
ассим-тотике вроде проблем быть не должно. То есть, конечно, мы не можем утверждать, что проблемная
вершина всё время идёт как бы корню, корню, корню, но пока мы можем сказать, что в случае один у
проблемной вершины высота не уменьшается, а в случае два ЧЧ у проблемной вершины получается
высота чёрная строга увеличивается. То есть, получается, пока мы работаем внутри случаев два ЧЧ и один,
то получается, что, значит, действительно, то есть, у нас два ЧЧ увеличивает высоту, один оставляет её
неизменной, остальные случаи уже просто за вот единицы завершают работу. То есть, следует,
это получается, что да, удаление за логарифом достигнуто. Но у нас есть более серьёзная мечта.
Мы мечтаем сказать, что у нас тут количество поворотов будет от единичной.
Ну, хотелось бы так сказать, правда. Ну вот, но с другой стороны, в чём действительно заметим,
что в случае два ЧЧ, заметим, что в случае два ЧЧ сам по себе, конечно, поворотов не инициирует,
он делает только перекраску, правда. А вот случай, а вот случай, соответственно, один, он у нас поворот
таки делает. Вот. Но с другой стороны, давайте думать, а что он сделает? То есть, какой он
на случай сделает? То есть, он на случай сводит к случаю два ЧЧ, но с важной оговоркой. Он нам
делает не просто случай два ЧЧ, а случай два ЧЧ, который в редакции, когда вершина окрасная.
Видите, есть маленькая оговорочка. Случай два ЧЧ с красным родителем, это случай, когда мы прямо
сейчас за ноль поворотов завершим работу. То есть, вывод очень простой. То есть, получается, если мы
попали в первый случай, то получается, мы победили за нот. Ну, точнее так, мы победили, то есть, мы
пойдем либо в случае два ЧЧ и победим в хорошей редакции, победим за, получается, дополнительно ноль
поворотов. Либо пойдем в один из этих двух случаев и победим за не более чем два поворота, правда. То
есть, получается, из этого мы делаем вывод, что в случае один мы делаем не более чем три поворота.
Вот, остается в случае два ЧЧ. А что в случае два ЧЧ? А в случае два ЧЧ вообще никаких поворотов
нету. То есть, просто другая проблема. И получается, мы либо будем идти в два ЧЧ, два ЧЧ, два ЧЧ,
два ЧЧ, либо перескочим в другие случаи и сделаем не более чем три поворота. Да, то есть,
официально заявлено, что там будет не более четырех поворотов, но на самом деле получается три. То
есть, получается нот. То есть, по факту получается, что ключевым являются случаи два ЧЧ в черной
редакции. То есть, именно в этом нот. То есть, когда тут все прям черные, да, вот совсем прям вот
толпень черных, да, мы тут начинаем их прореживать, там вот всяких правых детей чуть-чуть красными,
значит, покрашивать. А потом в какой-то момент мы натремся на более содержательные случаи, но там
мы уже локально за три поворота порешаем вопрос. Два звездочка К. Значит, давайте два звездочка К.
Ну, тут все просто. Поворачиваем А, Б. Это раз. Да. Особенно если вы меня напомните,
просто эта презентация может оказаться у вас там, собственно, в группе ВКонтакте.
Вот. Так что если вы там это сейчас в паньке перерисовываете, то как бы это не санат.
Хотя нет, это полезно на самом деле, потому что когда вы что-то такое перерисовываете,
записываете, значит у вас там в памяти откладывается, готовится к экзамену,
будет сильно проще. Потом. Да, та самая амортизация. Вот. Ну, как бы, да, знаете, потом выяснилось,
что зато я к экзамену не буду готовиться. Почему? Потому что на самом деле я ходил на лекции,
в каждой лекции по чуть-чуть готовился к экзамену. Да. Вот. Так что вот такая красота. Так что вот это
вот красно-черное дерево. Да, кот у него, конечно, вот это. Это половина. Вот. Вот. Ну вот. Да. Ну,
то есть на самом деле, да, можно, конечно, думать, но я что-то уже усомнился. Это вот. Как бы, да,
а то не знаю. Да, автор презентации утверждает, что в ВЛ деревьях на самом деле не надо хранить
высоту, надо хранить лишь поддерживать именно разность. Высота 1, 0 или минус 1. Ну, вот,
похоже, да. Вот, видимо, автору презентации тоже показалось похоже на правду. Я вот что-то
уже сомневаюсь. Ну, да, вот что-то не знаю. Ну, то есть, хотя может и правда, я не знаю.
Господи, спросить бы этого автора. Ну, для этого это сложно. Кто? Ну, скажем так, я. Там шесть лет
назад. Там такая маленькая деталь. Ну, там так. Нет, на самом деле, если говорить об авторских
правах, то есть, как я сказал, то есть, на самом деле, как бы текст вот в таком виде, это почти
наверное писал я. Если там вот какие-то слайды. Да, но это вот, да, но это, честно, там какой-то
принскрин из Кормана. Ну, не из Кормана, а там, по-моему, там где-то в техе набил просто код. Там
используют такой же шаблончик, как у них. Вот. Да, вот картинки. Ну, да, вот картинки. Картинки,
картинки. Ну, вот. Но, в принципе, если вы видите там. Ну, вот. Но если там брать какие-нибудь другие,
там, то есть, вот, вот. Какие-то вот такого рода, например, слайдики. Вот такого. Да, то есть,
скорее всего, вот, видите, они целые на самом деле. Да. То есть, честно скажу, то есть, я их брал,
на самом деле, из презентации моего великого предшественника. Вот. Которого зовут Степан
Мацкевич. Если вы будете работать в Яндекс.Таксии, скорее всего, вы с ним пересечетесь. Вот. Ну, вот.
Ну, впрочем, ну, я не знаю. По крайней мере, на мой взгляд, ну, в общем, честно скажу, я с ним,
правда, уже давно не, давно, к сожалению, не пересекался. Поэтому, где он сейчас, я не знаю. Вот.
Но после. Так что вот. Вот. Так что это была АВЛ-дерево. Так, это была красно-черная. Думаю,
там, в дальнейшем и деревьями займемся в следующий раз. Все, на сегодня все.
