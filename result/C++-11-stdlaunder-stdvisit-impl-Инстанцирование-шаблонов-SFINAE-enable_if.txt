Включаем запись. Сегодня мы закончим обсуждать проблемы, связанные с вариантом. И перейдем к
следующей и предпоследней теме. К шаблонному метапрограммированию. В прошлый раз мы остановились
на том, что мы почти поняли, как реализован STD variant. Ну, вообще, как STD variant реализован,
мы даже, можно сказать, поняли до конца. Но у нас остались некоторые моменты, о которых мы не
подумали, из-за которых все может сломаться. Ну, там какой-нибудь оператор присваивания варианта,
какой-нибудь там всякие конвертирующие конструкторы. Это вы сами догадаетесь,
как написать, я думаю. Как, кстати, 14-й параграф называется? 14-я глава. Она называлась, если мне не
изменяет память, unions и type erasure. Ну, в каком-то смысле type erasure and unions. Значит type erasure мы
обсуждали, когда говорили про any, а потом про shared ptr, а потом про function. А потом мы сказали,
что у нас есть unions, а есть вариант, который на самом деле велится type safe unions. Штука,
которая умеет хранить разные типы в runtime и безопасно, скажем так, подменять один другим.
Вот, значит, у нас, ну, напомню, что у нас в прошлый раз был вот такой класс вариант. Мы
тут обсуждали, как правильно реализовать его конструктор с помощью вот такой конструкции,
как правильно, значит, сделать наследование отчего, чтобы все это работало без ub,
как сделать destructor мы обсудили, обсудили функцию get, даже успели еще что-то обсудить. Вот,
но в конце я вам сделал такой спойлер и тизер на этот раз. И на самом деле я тогда вам сказал
неправду, сейчас я буду исправляться. На самом деле вот то, что я говорил последние пять минут,
последний раз было не совсем правильной формулировкой. У нас есть одна проблема,
о которой невозможно догадаться, если о ней не знать, и проблема начинается тогда, когда мы
пытаемся на указатель, под которым лежал один тип, положить другой тип, и при этом продолжаем
обращаться по старому указателю. Ну да. Вот, это некоторая абсолютно неочевидная вещь,
и такое даже казалось бы, ну это в голову не могло прийти, что тут может быть какая-то
проблема, если об этом специально не поговорить, то даже и не подумать, что здесь какие-то проблемы
могут быть. На самом деле такое вызывает УБ, и вот в связи с чем. Я вам приготовил один пример,
который называется Divertualize. Давайте посмотрим вот на такой код. Вот, чтобы проиллюстрировать
проблему. Это будет пункт 14-8, я под это не поленюсь отдельный пункт завести. Я даже не знаю,
как назвать эту проблему. Ну давайте я просто... Давайте я назову ее Launder Problem или Laundry Problem.
Я пока не буду объяснять, что значит это слово, вот. Скоро мы поймем. Давайте посмотрим вот такой
пример. Этот пример на самом деле довольно экзотический, и его довольно трудно придумать.
Вот в прошлом году на лекциях мы пример такой не нашли. Я только потом его нашел там кое-где,
и в общем показал. Но вот в этот раз мы можем сразу увидеть этот пример. Вот он
заготовлен. Что здесь происходит? Давайте вдумаемся. Вот вычитается функция H. Мы создаем объект A,
говорим, что N это результат вызова F, а потом говорим, что M это снова результат вызова F,
и возвращаем N плюс M. Чему будет равно N плюс M? И тут надо посмотреть, что делает функция F.
Функция F, она возвращает, ну, казалось бы, 1. Нет, виноват, это у B функция F возвращает 1.
Функция F у A возвращает 2. Но перед этим она делает вот это. В этой строчке хочется умереть просто.
Вот. Это она создаёт объект типа B по данному. Да-да-да-да. Вот мы зашли в функцию F,
а функция F берет и по адресу Viz кладет другой объект и возвращает 2. После этого мы снова
вызываем A.F. А зачем? Что зачем? Лазь по своему адресу другой объект. Значит,
ещё раз. Это пример, иллюстрирующий, когда у B наблюдается. Мы обсуждаем проблему того,
что если мы по одному и тому же адресу, под один и тот же pointer кладем объекты разных типов,
то в какой-то момент компилятор может не заметить этого, продолжать считать, что там предыдущий тип.
Если ты делаешь STD variant, то ты именно этим и занимаешься. Ты кладёшь по одному и тому
же адресу разные типы. Можешь положить toBase и toDerived. Допустим, у тебя STD variant из разных штук.
В какой-то момент ты возьмёшь и положишь по тому же адресу новый тип, а указатель будешь
использовать старый, чтобы к нему обращаться. Что будет компилятор думать в этот момент?
Компилятор тоже захочет умереть, но на самом деле будет думать про старый тип.
Компилятор имеет право считать, что тип не поменялся от того, что мы так сделали.
То есть переменная a была типа a, и мы вызвали у него какой-то метод. Компилятор имеет право считать,
что от такого тип того, что подали, не изменился. Если бы это было pointer,
то компилятор бы имел право считать то же самое. Странно бы, если бы компилятор считал
наче, а это же переменная, у неё статический тип a. С чего бы ему стать равным b? Как это могло
случиться? Если бы я вам показал этот код до того, как показал определение функций,
вы бы даже не догадались, что тут может пойти не так. Казалось бы, понятно,
что a.f одно и то же будет возвращать, если на том никаких статических переменных не используют.
И компиляторы тоже так думали до некоторых пор. Еще до C++17, когда появился variant и прочие приколы,
так и было. И компилятор действительно это умеет оптимизировать. А в чем смысл оптимизации?
Ну файл называется devirtualize. Это один из сценариев, когда можно оптимизировать.
Почему здесь можно оптимизировать? Конечно, это виртуальная функция, но мы не хотим прыгать
по pointer, чтобы её вызвать. В чем смысл этой оптимизации? Чтобы вызвать виртуальную функцию,
нам нужно сделать два прыжка, нужно сходить в таблицу виртуальных функций, посмотреть,
какую именно версию функции вызвать и пойти её исполнять. Вопрос, нафига, если и так видно,
что мы объявили A, никакого B в помине не было, вызвали у него F, а потом еще раз вызвали у него F.
Зачем компилятору ходить здесь, генерировать походы в таблицу виртуальных функций? Ну вот,
я сейчас это скомпилирую с g++11 и выведется 4. Ну вывелось 4, то есть, что он сделал?
Ну два раза вызвал функцию. А второй вызов функции A.F не будет у B, потому что мы положили туда B.
Да, вот я сейчас вызвал эту штуку и вывелось 4. Так, мне казалось,
что должно вывести 3. Сейчас, а если я оптимизацию включу? Все равно 4 выводится.
Это даже минус O2 не влияет на это. Это даже без минус O2 выводится 4. Даже оптимизатор включать не надо.
Типа девиртуализация происходит. Да, ну давайте посмотрим. Можно открыть Godbolt и в него это
запихнуть. Давайте посмотрим hard-divirtualize-cpp и сейчас я, значит, в Godbolt посмотрю,
что происходит. Где посмотрите? Если до сих пор не знаешь, что такое Godbolt, очень жаль. Мы не раз
пользовались, но вот сейчас ты увидишь, что это такое, и я надеюсь, запомнишь, потому что очень
полезная штука. Это типа жирный бог? Нет, это не bold как жирный, а bold как... Я, кстати, не знаю,
что. На самом деле Godbolt это фамилия разработчика просто. Его звали Godbolt, того, кто это придумал.
Вот, смотрите. Мы просто смотрим, в какой Assembler это превратилось. Что из себя представляет функция
h? Тут не то чтобы что-то понятно сильно, мы не то чтобы специпы Assembler, но, короче говоря, видно,
вот, что он делает вызов a2.2.f и второй раз делает вызов a2.2.f, то есть он, вот он здесь вот,
я даже не уверен, делает ли он хоть раз проход по Vtable. Ну, короче, видно, что оба раза вызывается
a2.2.f. Видно, что он не идет в b. Вот. То же самое было бы, если бы это был pointer. Ну, я бы сказал,
а звездочка а равно new a, а потом сказал, значит, а стрелочка f и еще раз а стрелочка f. Вот.
Он, значит...
А вот, возможно, кстати, нет. Вот здесь уже, видите, что-то другое появилось. Вот когда
я делаю, когда я заменяю это на pointer, как будто бы он делает что-то более сложное, то есть он не
прям напрямую вызывает call, известный адрес, а он вызывает call, адрес, который он куда-то
до этого записал. А откуда он взял этот адрес? Он взял, значит, по каким-то там адресам на какие-то
числа, положил в rdx, это вот его регистр, где он потом, откуда он потом будет вызывать какое-то число,
и, значит, стал вызывать функцию по адресу, который он только что записал. И во второй раз он делает
то же самое. То есть, возможно, если я заменяю это на pointer, дело меняется. Это новый компилятор же,
да? Ну, на Godbolt я сейчас смотрю GCC 13, у меня GCC 12. Вот. Ну, давайте проверим, а, значит, вот если
я возьму здесь, сделаю, что а это у меня теперь pointer, вы видите, да, что я делаю, new a. Понятно,
что будет утечка памяти, но нас уже такие мелочи не волнуют сейчас. Вот. Мы переросли, так сказать.
И я теперь компилирую, и получается 3. То есть, он справился, если был pointer. Вот. Ну, без оптимизации
он тоже, очевидно, справится. Вот. Ну, если это был не pointer, то он считает, что под этим именем
ничего не поменялось, хотя он имеет право считать и в том, и в другом случае так. Вот. Ну, можно это
тестить на разных компиляторах, я не буду. Короче, смысл в том, что он имеет право так делать. Это
единственный случай, когда это возможно. Когда такая ситуация возможна. Другой случай, когда такое
возможно, это когда вы взяли, и у вас был, это я уже не буду пример показывать, потому что довольно
трудно подогнать так, чтобы это проявилось, но другой пример, когда у вас константный тип.
Представьте, что у вас есть const int, и вы его выводите, а потом, ну, допустим, у вас по pointer
лежит const int, и вы выводите его. Вы же не можете const int ничего присвоить. Поэтому компилятор,
он как бы имеет право считать, так раньше было проектировано изначально, что компилятор имеет право
считать, что под const int ничего не поменяется, если у вас был указатель на const int. Он же указатель
на const int, поэтому под ним ничего не может новое появиться, и он как бы имеет право соптимизировать
и считать, что там, в общем-то, все как раньше и есть. На что, если вы placement new на него натравили?
Присвоить const int вы ничего не можете, но вот placement new по адресу, по которому лежит const int,
сделать туда новый const int, вы можете, и как будто бы от этого const int поменяется, но компилятор
имеет право считать, что под const int ничего не поменялось. Причем я замечу, что вот это даже не...
Тут нет ошибки в том, что я делаю new, placement new, не сделав предварительно деструктор. Потому что
деструктор тривиальный. Есть такое правило в стандарте, что если деструктор тривиальный не
выполнять никаких действий, то ничего страшного, если его не вызвали, это не ошибка. Время жизни все
равно корректно считается завершенным. Если я просто placement new сделал на это место нового объекта,
тот объект корректно завершил время жизни. УB в другом, в том, что я новый тип положил,
а компилятор думает, что там старый тип продолжает лежать. Вот, короче, это проблема,
которую люди осознали только в C++17. Я вам сейчас покажу один великолепный документ. Сегодня у нас
такая прям вот, я не знаю, это к концу года несколько развлекательных историй, чтобы вы
окончательно поняли, что такое C++. Я вам покажу сейчас замечательный документ, вот такой вот,
который написан Николаем Джосаттисом. Это один из членов комитета по стандартизации, насколько я
помню. И один из авторов книги большой, толстый про шаблоны C++, на который я еще собираюсь
ссылаться сегодня. Так вот, смотрите, что предлагается сделать. Предлагается ввести в
стандарт следующую функцию std-londer. Кто помнит, как переводится слово londer? Ну, стирка белья,
laundry room бывает, значит, londer это стирать белья. А еще londer можно делать, значит, есть второе
значение, можно деньги отмывать, londer money. Вот здесь скорее второе значение. Что такое londer?
Давайте я вам сейчас открою даже страницу на cpp-референс про нее. Сейчас. И даже, знаете,
что, даже я вам, наверное, вот так сделаю. Я вам вот эту статью тоже сейчас покажу.
Ну, сначала cpp-референс посмотрим. Значит, std-londer это такая замечательная функция,
определенная в header.new. Начиная с 17, она появилась. И она,
ну, короче, она возвращает тот же самый pointer, который в нее передали. Что это такое? Берется
pointer и возвращается он же самый без изменений. Ну, видимо, это pointer на другой объекте. Нет,
тот же самый берется, значит, возвращается тот же самый, который и передали. Есть некоторые вопросы.
Но при этом, что это значит? Типа, это такой, мы не можем с вами реализовать эту функцию сами.
Функция londer — это штука, которая реализована. В общем, мы даже не сможем увидеть ее реализацию.
Ну, мы сможем, наверное, увидеть ее реализацию в некоторых компиляторах. Она там просто ничего
не делает, просто return то же самое написано в одну строчку. Ну, просто не все компиляторы еще умеют
ее поддерживать нормально. В некоторых компиляторах, скажем так, она и не нужна, потому что они не умеют
оптимизировать. Вот, например, си лэнг. Ладно, не буду зря гнать на си лэнг. В общем, не все компиляторы умеют
делать вот эту оптимизацию девиртуализации. Не все версии, по крайней мере, компиляторов. И не все
версии компиляторов умеют делать те оптимизации, которые я сейчас говорил. И если компиляторы и так не умели
делать эту оптимизацию, то в них и функция londer, в принципе, может быть тривиальна и просто возвращать
тот же самый pointer. Но в тех компиляторах, которые умеют делать эту оптимизацию, эта функция должна
быть написана на каком-то низкоуровневом специальном коде. То есть там она написана не на си плюс плюс,
скорее всего, а либо на ассемблере, либо на внутреннем представлении компилятора. И она делает
примерно следующее. Она запрещает компилятору предполагать, что этот pointer, что он что-то
знает про этот pointer в дальнейшем. Да это логично. То есть эта функция, она делает какую-то магию,
и вот тут даже я не в состоянии вам сказать, что она делает. Это как move, только гораздо хуже.
Она делает нечто, что понимает только компилятор. То есть какие-то внутри компилятора меняет
флажочки относительно этого pointer, что компилятор отныне не будет предполагать,
что он что-то про этот p знает, и оптимизации перестанут работать. Формально, значит,
если у нас есть pointer, объект x размещенный по адресу a, x находится в пределах его времени жизни,
тип x такой же как t, без си квалификаторов и в общем, бла-бла-бла, тогда лондор вернет
указатель типа t звездочка, который указывает на x, а иначе ub. Как этим пользоваться? Ну смотрите,
я вот сейчас возьму и напишу. Так, давайте я вернусь к старому примеру. Вот у меня есть такая штука,
а у меня выводится 4. А теперь я напишу следующее. std londor от адреса a стрелочка f и вот теперь у
меня выведется 3. А почему она с c++11 компилировалась, если она с 17? Это,
еще раз, это версия компилятора, а не языка c++11, да. Можно же было сделать просто
адреса a равно std londor от адреса a и потом вызвать? Адресу ничего нельзя присваивать. Ну да,
вот типа адреса нельзя, но как бы сейчас, ну вот что-то такое. Ну можно было бы, если бы у меня
были pointer, то я мог бы сказать, что pointer на a теперь это std londor от старого pointer, да, и дальше
этим pointer пользоваться, это было бы корректно. А дальше я бы мог его сменять сколько угодно в
плане? Нет, каждый раз, когда ты подменил под ним то, что лежит, ты потенциально обрел ub,
если только не сделал londor перед этим. А, то есть это типа на каждое изменение типа свой londor?
Да, londor это барьер, который запрещает компилятору предполагать в дальнейшем, что он что-то знает,
у него к моменту этого места могли быть какие-то предположения. То есть, короче,
обнуляет знания? Да, это как раз почему-то называется londor, это, ну идеологически это как отмывание денег
работает, действительно такая была мотивировка, что типа мы как будто, что такое отмывание денег,
это когда мы получили деньги, но мы забываем, откуда они пришли и как они у нас оказались,
вот londor это штука, которая говорит компилятору, если ты даже что-то знал раньше про то, откуда это
взялось, забудь об этом, считай, что как будто вот оно вот взялось просто из ниоткуда и пользуйся
им, как будто ты ничего о нем заранее не знаешь, вот что такое londor. А в чем прикол, почему londor
нон дискардом сейчас сделали с двадцатых плюсов? Нам же кажется, хотелось бы иногда сделать просто
londor от адреса и после этого продолжить работу с переменной. Думаю, что потому что если londor
вызываешь и ничего не присваиваешь, если дискардишь результат londor, то это ни на что не влияет, то есть
ты как бы сделал londor от A и вот про это компилятор ничего не предполагает, но про сам A-то он по-прежнему
предполагает. Ты же, еще раз, вот A после такой операции сам по себе, имя A, оно продолжает
нести в себе какую-то информацию для компилятора. Если я дальше снова напишу k равно A.f, то компилятор
опять может считать, что там 2. А, все понятно. У меня это в виду, что вот ты londor сделал и вот результат londor
он как бы чист. Ты отмыл то, что… Я понял, спасибо. Вот. Сейчас будет несколько анекдотов. Ну, во-первых,
давайте еще раз посчитаем вот эту статью. Я, в принципе, все, что вам надо знать, рассказал
про londor. Вот. Нет, вру, не все. Сейчас мы с вами еще вы цитату из стандарта прочитаем, вот, и вы оцените
по достоинству, я надеюсь. Но сначала я все-таки хочу еще раз вот на эту статью посмотреть. Здесь
написано, какую проблему должен решать londor. Смотрите, что, какой пример здесь приводился. Вот
у меня есть структура, в которой есть поле constant и поле double. И мы говорим, вот, создали
новый объект x, а потом сделали вот так. И спрашиваем, чему равно n, вот это поле, которое constant.
И внезапно это уб. Почему? Да, по той же причине, потому что это было константное поле в структуре x.
Компилятор имел право считать, что это же константное поле, оно не поменялось. Вот,
когда, когда люди писали стандарт про то, что такое lifetime объекта, откуда вообще пришла эта
проблема. Был написан стандарт как-то. Вот люди формально начали, ну вот, определять, что такое
object lifetime. Они написали вот это. И что-то еще там написали. И разработчики компиляторов такие,
о, класс. Они прочитали стандарт, поняли, что, так это же значит, что мы можем соптимизировать.
Соптимизировали. И только спустя долгие годы, после того, как они это соптимизировали,
чуваки стандарта осознали фейл, который они допустили, когда вот так сформулировали все эти
определения. Потому что, например, это приводит к тому, что вплоть до c++14 хранить в векторе
константная типа было уб. Смотрите. Вот вы хотите, вы заметили, что мы никогда не создавали вектор из
констентов, например. Или из конст чего угодно. Ладно, из констентов. Представьте, что у вас есть
вектор, в котором лежит структура, в которой есть поле типа конст. Стоп, мы же создавали. Ну,
до c++14, ну, в c++17 уже перестало быть уб. До c++14. Ну, какой-нибудь big integer типа там лежит конст,
там, не знаю, int, base. И мы его кладем в вектор. Оно статическое было. Мы униклали вектор. Ну,
может, и создавали. Ну, я вам говорю, что вот если бы вы до c++14, включительно, по-моему,
создали бы вектор из объектов некоторого типа, в которых было поле типа конст, то, сделав из
этого вектора popback, а потом pushback чего-то другого, вы бы обрели именно эту проблему. Потому что вы
по тому же самому поинтеру положили нечто, что компилятор вообще-то имел право предполагать,
что не поменяя... Ну, потому что как? Там лежал какой-то x. Вот. И в нем было константное поле.
Компилятор имеет право предполагать, что оно... Вы сделали popback, потом pushback. Pushback,
на это место с другим значением. И вот вам убе. И эта проблема реально существовала в c++
вплоть до 14 стандарта. И вот только в 2000, это статья о 2017 года, 14 января,
чел наконец-то сформулировал... Ну, он не первый, кто это написал. Это он уже саммари, так сказать,
написал проблем, которые были известны к тому моменту. Только в 2016 году люди осознали,
что у них из стандарта это следует. То есть у них написан стандарт, в стандарте черт ногу сломает,
и там написано вот это. А разработчики компиляторов, конечно же, рады оптимизировать. И только в 2016
году люди поняли, что из стандарта формально следует возможность вот такого убе, если векторе
хранить вот такой тип. До сих пор, кстати, я не знаю, есть ли пример действительно, что что-то
сломалось. Но вот тут Джасатис пишет, насколько это вообще реально такое убе, насколько его
реально встретить на практике. Непонятно, насколько, но есть ивристика. Я просто попросил
некоего своего знакомого посчитать, сколько в кодовой базе гугла использование placement new,
которое игнорирует возвращаемое значение. Ну вот написали new, ptr, tr чего-то, и ничему это не
присвоили. Это означает, что потенциально создали убе, если вы тем самым, ну когда вы присвоили
результат placement new чему-то, вы дальше начали это использовать, и это уже не убе. Но если вы создали
placement new и проигнорировали возвращаемое значение, это значит вы по старому койнтеру продолжаете
обращаться к объекту, хотя он уже заново создан в нем, а значит потенциальное место,
где может возникнуть убе. Так вот из 800 использований placement new, которые были в кодовой базе гугла
на тот момент найдены, примерно 40% не используют возвращаемое значение, значит примерно там
320 потенциальных возможных убе было найдено в кодовой базе гугла в 2019 году вот из-за этого.
Вот такая история. А в 2017 году стандарты изменили, я вам сейчас покажу, ну это уже
стандарт 2020 года, нам сейчас покажу замечательное место в нем. Вот здесь есть такой раздел basics,
вы когда-нибудь читали этот раздел? Очень познавательный. В нем есть раздел memory and objects,
и в нем есть раздел lifetime, и вот в этом пункте basic, базовые определения в стандарте,
точка lifetime, есть пункт легендарный шестой, вот этот, в котором написано,
а нет, вру, восьмой, вот нам какой пункт нужен, вот этот вот. Вот этот замечательный пункт,
в котором написано, я не поленюсь это прочитать целиком, если после того, как время жизни одного
объекта закончилось, и перед тем, как хранилище под этот объект занято, переиспользовано или
освобождено, новый объект создан на том же storage, который занимался прежде чем оригинальным объектом,
указатель, который указан оригинальным объектом, ссылка, которая ссылалась на оригинальный объект,
или просто имя оригинального объекта, то что было в нашем примере, просто имя оригинального объекта,
автоматически начнет обозначать новый объект, и как только время жизненного объекта начато,
может быть использовано для обращения к новому объекту, если оригинальный объект
transparently replaceable по отношению к новому объекту, а если не transparently replaceable,
то это УБ, и вот это понятие transparently replaceable было введено в C++17, и вот что оно означает,
объект у один transparently replaceable прозрачно подменяем на другой, если, во-первых, у них
совпадает storage полностью, во-вторых, они одинакового типа, игнорируя верхний кост и
волатайл квалификаторы, в-третьих, это не константный объект, в-четвертых, еще техническое какое-то условие,
что они не potentially overlapping sub-object, это отдельно надо считать, что это такое, и либо они оба полные
объекты, либо они direct sub-object, в общем, вот нас на самом деле вот эти три пункта интересуют, то есть
здесь написано, что вы можете вот так вот непрозрачно подменять один объект на другой по тому же
адресу, если вы одновременно того же самого типа, и еще не константный, и еще не potentially overlapping,
и еще не вот это вот все, и вот здесь приведен пример, то есть я взял, в операторе присваивания
сделал, например, destructor C, а потом new-vis C от other, это нормально, я могу так сделать по своему
адресу подменить объект на тот же тип, если он не константный, если он константный, то не могу,
и вот здесь написано, что если эти условия не соблюдены, то указатель на новый объект может
быть получен из указателя, который представляет себе адрес его storage через stdlonder, и вот написано,
что stdlonder pointer optimization barrier, а значит здесь, черт, я потерял, ну в общем вы поняли, вот здесь приведен
пример с константом, вот у меня была структура x, в ней был int n, у меня был указатель на константный x,
я положил туда тройку, я обратился, значит, по этому указателю достал n, а потом я взял и сделал
новый const x по этому адресу этого поинтера через const cast и положил туда новый объект x, и обратился
теперь снова по этому поинтеру достал n, вот это ub, потому что я подменил константный объект другим
константным объектом через placement new, но вот если я через stdlonder обратился, то это ok.
Обратите внимание, что вот это уже теперь не ub, начиная с c++17, потому что параграф вот этот
вот object lifetime, который я вам показывал, с c++17 был изменен, и здесь условия были усилены,
то есть раньше, в общем, вот иметь структуру с константным полем это тоже было плохо, сейчас такое
можно. Вот, и последнее, что я скажу, это такой мем, что вообще-то, ну тут дальше объясняется,
почему, значит, как london может помочь решить проблему, вот в том числе с с вектором, потом
с классом optional, в котором мы тоже можем иметь дело с константным, ну вот тут менять объекты,
которые там лежат через placement new, но дальше самое смешное, что, к сожалению, в контейнерах,
которых используется Allocator, london всё равно не помогает до конца решить проблему, и вот почему,
потому что, ну имеется в виду в тех контейнерах, в которых элементами являются константы или
ссылки, и вот почему, потому что на самом деле у Allocator, когда мы делаем обращение к Allocator,
в Allocator есть внутренний тип pointer, но он не обязан совпадать с сишным pointer, может существовать
Allocator, у которого тип pointer это некоторый fancy pointer, который там не сишный pointer, а ещё какая-то
обёртка над ним, и если в контейнер вектор подложить Allocator, у которого pointer это не сишный
pointer, а какой-то специальный fancy pointer, я не говорю smart pointer, ну какой-то вот навороченный pointer,
какая-то обёртка над сишным pointer, то std london, ну shared ptr я не уверен, что можно, ну в общем,
то вот london от такого не поможет, потому что здесь написано, потому что тип вот этого elements может
быть не просто сырой pointer, std allocator trades app pointer может быть классом, и тогда std london не сработает
от него, и тогда это всё равно будет ub. Короче, если у вас в контейнерах есть константные элементы
или элементы ссылки, или элементы вот такие вот с виртуальными, значит, вот эти вот проблемы,
то жалко нас видимо, да, то могут быть разные тонкости, скажем так. А когда в 2017 году добавляли в
стандарт вот это, там был тоже такой смешной момент, ну вы можете нагуглить, значит, лекцию про то,
что такое std london, там говорилось следующее, там кто-то из членов комитета, возможно, кстати,
нет, по-моему, кто-то другой, там была фраза в ответ на вопрос, что такое std london, объясните,
пожалуйста, он сказал, if you are not one of five people on the planet who already knows what it is,
you don't want to know what it is and don't need it, типа, ну вы поняли. Короче, мы добавили в стандарт одну
функцию, если вы к настоящему моменту не один из пяти человек на планете, которые уже знают,
зачем она нужна, то, пожалуйста, не пытайтесь понять, зачем она нужна, просто у нас проблемы
нет при стандарте, лучше не вникайте. Вот примерно так это было. Вот, вам в std variant,
вероятно, предстоит использовать эту функцию, когда вы будете обращаться к хранилищу, сменив тип
в нем. То есть, я правильно понимаю, что если мы заводим вектор из константов и какой-то
интересный аллокатор ему даем, то потенциально это все еще УБ? Ну, если этот аллокатор таков,
что в нем pointer type не стандартный pointer, то это потенциально УБ, да. Я не знаю, на самом деле,
сделали они, может, они в 2020 еще придумали на этот счет, но я, честно говоря, уже не знаю,
я, в общем, значит, на хабре я вам хочу показать одну статью, я вам ее, вероятно, скину, ну,
вы можете и так запомнить, значит, одна статья, которая в 2021 году появилась, здесь чувак просто
разобрался, что делает Лондор на самом деле. То есть, он просто залез под капот компилятора и
выяснил, что именно там делается. Это увлекательное чтение, я думаю, вам на ночь хватит,
если вы решите в этом разобраться. Тут он начинает с примеров с вот этими виртуальными
таблицами, рассказывает про то, как они устроены, эти виртуальные таблицы, показывает, значит,
разные примеры, когда это может, когда компилятор может это оптимизировать. Кстати, один из примеров,
когда компилятор может оптимизировать виртуальные таблицы, это когда у вас final написано. Это очень
интересно. На мой взгляд, это одна из интересных вещей, которые можно этой статьи подчеркнуть.
Вот казалось бы, зачем слово final в методе или в классе, что нельзя от него больше ничего наследовать,
а потому что это дает возможность компилятору оптимизировать виртуализацию. Он понимает,
что уже глубже не будет ничего, а значит, можно не ходить по таблице виртуальных функций,
если у меня тип такой. Вот. Тем не менее, если вы потом подмените тип, то у вас начнутся
проблемы, и вот здесь, значит, рассказано, что же именно происходит, и заканчивается все тем,
как в LLVM, значит, ну, то есть вот LLVM, это проект по разработке силенга, я напоминаю,
родственных ему компиляторов. И вот здесь, на внутреннем языке представления этого LLVM,
объясняется, как компилятор делает эту оптимизацию, и что именно запрещает ему делать лондор. Вот. Вот
что делает операция лондор, здесь, значит, написано. Я не буду с вами разбирать эту статью,
но, я не знаю, можно там, если вы на устной части экзамена захотите, там у вас будет спорная
ситуация, и вы захотите там отел 10, и, короче, не знаю, в какой-нибудь там, выпендрится где-нибудь,
если вы хотите какой-нибудь плюс балл к чему-нибудь, можно будет чуть-чуть из этого пообсуждать,
вот, но на любителя. Ты можешь прислать вот, не только эту статью, но еще статью с описанием,
типа, в чем проблема? Конечно, конечно, я пришлю эти все ссылки вам в чат. Вот, в общем, все,
я закончил говорить про лондор на этом. История, на мой взгляд, весьма показательная, она показывает,
в том числе, то, как люди иногда находят ошибки в стандарте спустя много лет, понимают, что они
косякнули, вводят нечто, и дальше, в общем, начинается веселье. Можно вопрос? Да, конечно.
Пара вопросов. Получается, лондор нам нужен для тех объектов, которые не transparently replaceable.
Да. Те, которые transparently replaceable, с ними все хорошо и так. Да, да, да. Хорошо, а вот еще можно
как-то в настройках компилятора, ну, опции какой-нибудь в компиляции попросить, типа, вот,
пожалуйста, вообще не делай никогда эту оптимизацию, чтобы, ну, просто не париться насчет этой проблемы.
Ну, вот смотри, я вот, например, в G++ сейчас без оптимизации компилировал, но он все равно считал,
что там лежит старый тип. Ну, просто обращение. А если прям честно, минусу ноль прописать? Давайте
проверим. Ну, мне кажется, что это не поможет. Нет, ну, я о том, что, как бы, вот если обнаружили
такой косяк, как бы, из-за оптимизации, то, казалось бы, ну, логично. Не то, что оптимизация. То есть,
смотри, понимаешь, вот это даже не то, чтобы оптимизация. Вот я сказал АА, а дальше А.Ф. Ну,
и также понятно, что там не Б лежит. Чего проверять-то? Если б я вам не рассказал эту историю,
вот представьте, только когда мы начинали говорить про виртуальные функции в первом смене,
я бы вам дал такой код и сказал, как бы вы, будучи компилятором, выполняли, вы бы сказали, ну как,
зачем? Очевидно, не надо ходить в таблицу виртуальных функций. Вы даже про плейснью не знали
тогда. Разработчики компилятора тоже такие, очевидно, нечего даже здесь… Это даже не считается
оптимизацией, может быть, у них. И спустя 10 лет они поняли вдруг, что вообще-то есть вот такой
пример, когда это работает неправильно. Ну, короче, не знаю. Как отключить? Не знаю. Надо
разбираться, какие компиляторы вообще умеют это оптимизировать, какие нет. Силенка вроде
что-то умеет, но за подробностями идите в эту статью. Значит, окей, это с лондером история. И
последняя история с функцией SD-Visit. Ну, здесь, наверное, ну, если хотите, может сказать, это пункт 14.9.
Что за история с функцией SD-Visit? Ну, как ее реализовать, в общем-то, вот история какая, вопрос.
Значит, у нас есть функция SD-Visit, и мы хотим, точнее, у нас нет функции SD-Visit, мы хотим,
чтобы она была как раз. Так она нам зачем нужна еще раз? Вот пример с Visit. Ну вот,
мы хотим, чтобы у нас... А, которая, ну, всегда типа исполняет. Да, берет вариант, берет SD-Variant
и выполняет что-то из вот этого. Вот. В очередной раз смотрим на этот пример. Значит, у нас вот
есть три разных обработчика на случай, если то 5 и 10, и есть вариант, в котором exitInt. И вот мы
вызываем функцию Visit, и сейчас будет, значит, int написано. Нет. Не будет написано, а почему? А, да,
о, я вспомнил почему. Я этот пример написал тоже, тоже заготовил неспроста. Значит, у меня случился
статик Assert. На самом деле, обратите внимание, что именно здесь не так. Static Assertion failed. Кстати,
возможно, если я C++ 20 сделаю, то у меня даже будет другая ошибка. Нет, также она выглядит. Ну ладно.
Смотрите-ка, Static Assertion failed. As the Visit requires the Visitor to have the same return type for all
alternatives of a variant. Ага. Вы меня спрашивали, а что, если я буду из разных Visit возвращать разные
типы? Помните, было такое? Я сказал, что, ну, это все равно не сработает. Ну, то есть я там сказал,
что можно было бы найти общий тип, которому они приводятся, и возвращать его из Visit. Но, короче,
по некоторым причинам, вот, как выяснилось, все равно в стандартной библиотеке сделано не так.
Просто стандартная библиотека не разрешает вызывать Visit, когда у разных функций разные
типы, что будет возвращено. У меня здесь возвращается int, char и double в каждом случае. И вот,
если типы не одинаковые, то Visit просто падает, там Static Assert стоит. Я не могу из Visit вернуть
разные вещи. Пока Visit все void, например, ну, хорошо. А Visit с разными типами не могу вернуть. Ну,
это, в общем-то, логично. Как написано в ответе на Stack Overflow про это, вы не можете обмануть C++
все-таки сделать вам динамическую типизацию. А нельзя возвращать Union из этих типов? Ну,
можно возвращать вариант, если на то пошло. Зачем Union? Union, конечно, можно. Статический тип,
главное, один и тот же надо возвращать. Вот, короче, Visit, если он возвращает разные типы для
разных принимаемых типов, так не покатит, у вас будет CE. Вот, ну и, в общем-то, по сути, кроме как
вот обеспечить этот Static Assert, Visit тривиален. Ну, вам, по сути, чтобы реализовать Visit,
вам нужно просто правильно чекнуть, что все типы одинаковые возможны, а дальше просто сделать
вызов. Но как сделать? У вас дан вам функтор и дан вариант. Как реализовать Visit? Вы просто берете
и этот функтор вызываете от этого варианта. Как вы это делаете? Конечно же, с помощью STD Invoke,
потому что, напоминаю, функтором может быть, в том числе, и указатель на член или какой-нибудь
Bind Expression или какой-нибудь поле, я не знаю. Вот. Вот. Еще раз Invoke, что вы сделали? Сейчас я открою
CP Perference, соответствующую страницу. Значит, мне нужна страничка про Visit.
Так вот, SD Visit. У него есть две версии. Одна с явно указанным возвращаемым типом, другая с типом,
который автоматически выводится. Но вот этот тип, он выводится при условии, что он одинаковый у всех
возможных вызовов. Что делает эта функция? Она вызывает Visitor, то есть вот этот вот Vis. Как
если бы мы написали следующее выражение. Invoke от STD Forward от Visitor и от STD Get. Ну, давайте для
начала разберем пример, когда у нас один всего вариант. Если у нас просто Visitor, можно передавать
несколько вариантов, и в этом главный мем. Но вот если у нас есть просто один вариант, то мы по сути
что делаем? Мы делаем Invoke STD Forward от Visitor и STD Get от соответствующего индекса варианта,
который в нем сейчас лежит. От этого вариант.
Что такое индексы? Мы же их нигде не передавали.
Experian Farce Index.
Да, значит сейчас нам нужно что сделать? Нам нужно, какая здесь есть проблема? Ну, во-первых,
что такое Invoke? Invoke это вот эта штука, которую мы уже обсуждали. Ну, это по сути вот такое
вот выражение STD Invoke. Помните его? Которое вызывает функцию вроде, да? Да, ну мы вызываем
его не круглыми скобочками, а через вот это, через STD Invoke, чтобы корректно обрабатывать
в случае указатель и на члены, указатель и на методы. Вот. Второй вопрос. Да, второй момент. Мы,
конечно же, принимаем и Visitor, и варианты по универсальным ссылкам, и forward, и то, и другое. То
есть мы forward-им Visitor, forward-им вариант, чтобы не потерять категорию значения, если что. Вот.
И главный вопрос, это как узнать, от какого типа Visitor вызвать?
Там дидакшен не сработает? Нам надо понять, какой тип в варианте именно от этого типа вызвать Visitor.
Вот, а как это сделать?
Мы не можем сделать просто вот здесь вот, мы не можем написать index, ну у варианта есть метод
index, который говорит, какой по номеру тип в нем сейчас лежит. Index. Ну он просто говорит,
какой по счету тип в нем сейчас активен. Но мы не можем это как шаблонный параметр в get передать,
конечно же, потому что это не compile-time число, а в get нужно compile-time. Вот. Как же нам быть?
Это загвоздка. Я так понимаю, мы преддаем сразу все, но если специализация, где он true и false,
и на false мы ничего не делаем, что-то такое. Вот. На самом деле реализовать это можно примерно так,
кажется. Нам нужно взять вот эти типы и их сделать шаблонными параметрами, а дальше просто перебирать
Ну, нам нужно как бы несколько уровней перегрузки сделать. Мы напишем некоторую вспомогательную функцию Visitor.impl,
Visitor.impl, которая будет принимать дополнительным пакетом шаблонных параметров вот этот вот список
типов и вариантов. И дальше мы будем смотреть тип, который сейчас лежит в варианте, то есть индекс
вот этого типа в пакете типов. Это то же самое, что первый тип нашего пакета. Если да, то каст к нему
и вызвать от него, а иначе пойти дальше и сделать визит от этого же варианта, но уже с пакетом с
откушенной головой. Понятная идея или не очень понятная? Ну, вроде бы да. Ну, я не хочу
это сам писать, потому что тогда всё будет неинтересно. Вы сами, в общем, это напишете, я думаю,
кто будет варианты писать, конечно. Значит, как это можно сделать? Мы берем вариант, вот этот пакет
типов мы дополнительными параметрами передаём в аргумент. Мы по сути делаем такой if, мы такое
делаем как бы форик по этому списку типов. Вот. И мы говорим, правда ли, что тип того, что сейчас
лежит в варианте, уже не constexpr. Правда ли, что тип того, что сейчас лежит в варианте, то же самое,
что голова нашего пакета. Если да, то каст к этому и вызваться от этого, а иначе вызваться
рекурсивно эту же функцию от того же пакета типов, но без первого элемента. Итак, пройдем все
элементы, пока не найдем тип, который совпадает с типом того, что сейчас лежит в варианте. И от него
вызываемся. Вот. Но при этом нам надо еще написать static-assert на то, что результаты вызова визит от
всех этих типов будут одинаковыми. А как нам это сделать? Ну, это кажется как раз просто. Сделать
это может через fold expression сделать. Нам надо написать, что static-assert, ну, можно написать
метафункцию allSame, типа все результаты, decal-type от наш визитер, от головы пакета и так далее. Все
это одинаковый тип. Вот такой static-assert. А дальше просто идти и вызывать. Ну как, нормально? Ну,
вроде понятно. Ну вот. Я так понимаю, я так понимаю, раз вы это не хотите писать, значит есть
какие-то подводные камни. Ну, да вроде нет. Везде нигде нет подводных камней, пока не начнешь это
писать. Не, я просто боюсь, что если я начну это писать, то я ошибусь где-нибудь, у меня потратится
много времени. Я вот почему не хочу. То есть типа не то, что там есть подводные камни, а то, что
может с первого раза неправильно написать и дальше ошибки компиляции ловить. Ну, в принципе кажется,
короче да, я не чувствую себе храбрости написать это правильно с первого раза, поэтому я не хочу
сейчас это сделать. Вот так. Но вообще это кажется пишется не особо сложно. Ну и потом, если я это
напишу, то вам-то о чем думать тогда надо будет. Вам же все-таки надо же самим порешать что-нибудь,
пока вы эту задачу пишете. На самом деле в варианте будет еще одна проблемка,
которую я не сказал в реализации варианта. Ну, в общем, когда начнете писать, увидите,
в чате обсудим. Идейно вроде все понятно, но там будут некоторые тонкости. Вот, в целом все про
вариант, про юнионы, про type erasure. Дайте лайн по варианту. Я думаю, что никогда. Ну, то есть,
я думаю, что вот варианты и следующая, то есть вот эти как бы вариант и следующая,
последняя задача называется type list. Скорее всего, они бонусные. А по ПТР? По ПТР, ну давайте,
когда вы хотели? 20 мая? Ну, давайте будет 20. Ну, плюс 21 день вроде типа. Ну, давайте 20. Вот,
вариант и type list, последняя задача будет без дилайна. Ну, в смысле, их можно без штрафа сдавать
вплоть до дня перед экзаменом. Вот, ну просто их мало кто будет сдавать, я думаю. А ревьювятся они
как будут тогда, если сдать их в день перед экзаменом? Так нет, нормально, если их никто не
сдает, то они ревьюются нормально. Да, мы подумаем там, либо просто быстренько посмотрим там,
и как-нибудь. Ну, в прошлом году несколько человек всего сдавало, и они все быстро устно сдали там
с первого максимум со второго раза. Сейчас, разве вы не написали код estate variant почти полностью?
Нет. Ну, я написал основные идеи, но когда ты начнешь реализовывать, ты поймешь, что там еще есть
проблемки, скажем так. Вот. Ну, например, проблемка будет, скажем, когда тебе надо будет уметь
создавать вариант. Я его буду инициализировать con char звездочкой, а тебе нужно будет snd string
получить, и это вызовет некоторую проблемку. Сейчас уже с кодом даже не вспомню какую. Ну, в общем,
увидите. Короче, в чате обсудим. Я думаю, что условия я выложу уже, блин, боюсь говорить сегодня,
потому что сегодня, мне кажется, я не успею. Ну, давайте завтра постараюсь выложить условия
варианта. Вот. Все, в общем-то. Конец темы 14. Идем дальше. Перерыв, я думаю, пока не будем
делать, у нас еще не прошло сколько надо времени. Следующая тема называется шаблонное метапрограммирование
свиная и концепты. Значит, ну, давайте я напишу просто метапрог cpp.
Вот. Я думаю, многие из вас ждали этого, потому что шепот перешептования об этом я слышал довольно
давно. Ну, приближаясь к завершению нашего путешествия по современному программиру на c++,
нам надо бы наконец закрыть долги, связанные с тем, что мы постоянно не умели реализовывать разные
метафункции. Мы с вами многие уже метафункции использовали. Сначала мы использовали метафункции,
когда каким-то чудом итератор трейдс сами определяли, какого вида наш итератор. Потом мы
использовали метафункцию, значит, там, правда ли аллокатор обладает методом констракта таких-то
аргументов. И аллокатор трейдс опять-таки как-то сами это определяли. Потом мы пользовались
метафункцией из constructable, из no-throw move constructable. Потом мы пользовались метафункциями из base-off.
Один тип является наследником другого. Мы пользовались метафункцией uses аллокатор. Мы
пользовались функцией из callable. Ну, короче, очень многими. Вот в этом, в этой главе мы все их
научимся реализовывать. Но не прям все, мы их реализуем целиком, потому что некоторые из них
очень технически долго реализовывать. Но мы идейно научимся реализовывать их всем. И начнем мы с
такого пунктика. Я бы сказал, он немножечко выбивается, он немножечко особнячком стоит,
то есть он немного не в тему именно метапрограммирования. Но мы о нем не сказали,
когда говорили про шаблоны в первом семестре. И надо сказать о нем в этом семестре. Это будет
короткий пункт. И под него я тоже заготовил кусочек кода. Пункт про инстанцирование. Вот мы с
вами говорили, что... Давайте я назову его ленивое инстанцирование и explicit
instantiation. Мы с вами говорили, что компилятор инстанцирует шаблоны лениво. Прошлый раз даже я
там запутался сам. Помните, у нас была история с function, да, почему у нас в копе конструктор. Я это
в чате написал, на видео не сказал. Помните, была проблема с function, почему move only объекты в
function class нельзя. Потому что инстанцируется копе конструктор, а почему он инстанцируется? На
самом деле копе конструктор не инстанцируется, инстанцируется статическая функция, которая
заведует, сохраняет указатель на эту копию. И поскольку ее надо инстанцировать, приходится
инстанцировать копе конструктор. Но вообще компилятор инстанцирует шаблоны лениво. Вот давайте
посмотрим на вот этот вот код. И я не знаю, скомпилируем его. Вот я сейчас это открою,
закрою, наоборот. Пример, взятый из книжки к Ванварду Джасати со шаблоном. Вы все стерли,
только что нет. Нет, я на другой вкладке это сделал. Вот, я сейчас компилирую вот этот файл и
обнаруживаю, что он прекрасно компилируется. Вот. Ну, почему он компилируется? Здесь вообще у нас
есть какие-то проблемы, почему это не должно компилироваться, вот пока я не использовал ни
один из этих классов. Но вообще есть, да, вот смотрите, например, здесь инстанцируется вот
этот вот класс Danger с шаблонным параметром минус один. Но он объявляется в теле функции,
которая сама в свою очередь находится внутри шаблонного класса, а шаблонные аргументы я
еще никакие не подставил, поэтому компилятор просто не смотрит даже на это. Он не инстанцировал вот это
тело. Вот. С другой стороны, если бы я вот здесь вот попытался сделать такое поле, то, вероятно,
это бы уже было ошибкой, потому что объявление полей он все-таки смотрит. То есть несмотря на то,
что я не подставил t и n, компилятор все-таки просматривает объявления функций и полей на
корректность объявления. В плане, ну, мы же вообще трики нигде не заводим, зачем? Да, но компилятор
уже видит, что это будет ошибкой, независимо от того, какие t и n мы подставим. Тут он тоже,
по идее, мог бы увидеть, что это будет ошибкой всегда, но просто определение функций он ленится
инстанцировать, а объявление не ленится. Ну, это какая-то очень странная граница, почему что-то он
проверяет всегда, что-то может запустить. Причем, насколько я знаю, методы класса он может не
компилировать вообще, пока они не вызываются, даже если у нас этот класс создается реально. То есть
здесь какая-то очень странная граница. Давайте попробуем заиспользовать этот класс. Вот я
инстанцировал сейчас трики с шаблонными параметрами int и 1. Вот. Что от этого поменяется?
Вот кажется, что от этого... На самом деле, вот этот пример, да, вот этот пример вместе с
комментариями взят из книжки шаблона C++ на читавторов Wonderwood-Jasattis. Я еще раз повторю.
Такая толстенная книжка. Пример довольно-таки получительный. В стандарте про многие вещи из этих
написано, что это unspecified. Должен ли компилятор инстанцировать что-либо? Вот, например,
дойдет ли он сейчас до сюда? Упадет ли это? Я вот сейчас класс инстанцировал с параметром
шаблонными. И окей, поле он обнаружил ошибкой еще до того, как я вообще инстанцировал. Ну вот,
я сейчас инстанцировал объявление класса. Извиняюсь, инстанцировал определение класса.
Инстанцируются ли определения функций? Честно говоря, я не знаю и, по-моему, это unspecified. То
есть компилятор имеет право не заметить этого, пока я функцию не вызвал. Давайте проверим 2++11.
Так, я сохранил. Ну да, вот он даже, несмотря на то, что я уже подставил сюда аргументы, он все равно
вот это не инстанцировал, потому что error не вызвалось. Ну вот, если я вызову t.error, то,
конечно же, он инстанцирует, ну он начнет компилировать определение функций, теперь уже упадет.
Вот. Что еще? Ну вот, если я теперь инстанцирую сразу вот с таким параметром, что будет? В каких
местах возникнут ошибки? Strike nested. Strike nested. Наверное, возникнут, потому что это объявление
поля внутри структуры, которую как бы мы инстанцировали, мы подставили. В n-класс не будет,
по идее, если не было... Вот здесь вот, вероятно, возникнет, потому что это объявление функции,
правда, вот это объявление функции, и объявление функции он подставит, а вот определение функции
он, вероятно, не подставит, поэтому, например, вот здесь ошибки не будет. Вот здесь, я думаю,
ошибка будет и здесь. Если бы мы поменяли местами align и anonymous, у нас же не было бы ошибки в юнию 1?
Я думаю, что была бы все равно. Давайте, во-первых, проверим, какие ошибки будут сейчас.
А вот и нет. Вот мы и не отгадали, значит. Он, оказывается, и вот это не инстанцировал,
и вот это не инстанцировал. Жесть. Спасибо великому и ужасному Implementation Defined.
Стоп, почему он union не инстанцировал? Ну, видимо, потому что Implementation Defined.
Ну, типа union это же прямо поле класса трики. Ладно, структура nested, она вроде нигде не
используется, но... Сфига ли это поле? Ну, это безымянный union, и в нем, по идее, есть поле вот
это и поле вот это, и они оба являются полями нашего класса, как бы лежащими на одном и том же
адресе просто. Ну да, ну и типа еще... И первое поле у нас первое, ну danger первое, поэтому, по идее,
должно default на его конструкции. Да, и вот это странно, потому что здесь даже комментарий написан,
что, по идее, это... Илья, подожди, а я, может, что-то не понял, но мы же имя этому union не дали,
и не завели переменную этого типа локально. Я, может, что-то путаю. Не, не, значит, еще раз, у нас был
пример такой, мы с std string тоже самое видели, у нас безымянный union, это значит, что мы вносим все
его члены в объемлющую область видимости, то есть, как бы, у этого класса полями являются
anonymous и line, но у них одинаковые адреса. Безымянный union, это штука, которая просто заставляет
положить вот это и вот это на одинаковые адреса, то есть, у нас как бы два поля share один и тот же
адрес памяти, но они оба являются как бы полями класса. Правда ли, что он саптимайзил, увидел,
что мы нигде не используем ни anonymous, ни line и выкинул их нафиг? Я, честно говоря, удивлен,
потому что, казалось бы, мы точно, я точно сохранил это. А, так подождите, нет, все правильно,
все правильно, required from, вот отсюда, из 25 строки, это где у нас произошло? Вот отсюда,
все правильно, в union ошибка возникла. У нас возникла первая ошибка из-за объявления функции вот
этой. Вторая ошибка из union, потому что поле union он таки инстанцировал, и он сказал, вот,
в инстанцировании класса такого из строки вот такой, union, 2.2.unnamed, unnamed это имя union,
required from class, required from here, ошибка возникла из-за union. Попробуйте поменять местами online
anonymous. Я думаю, что это не поможет, ну, хорошо, давай попробуем. Тоже самое. Ну, неважно,
в каком порядке, это очень странно было, если он инстанцировал первое поле, но не второе,
он оба их инстанцировал. Вот, а вот это он таки не инстанцировал. Но понятно при этом,
что если мы напишем, допустим, там, tricky int-1.2.2.nested, то он уже инстанцирует структуру и тогда
будет еще и ошибка в ней. Так, что? Что происходит? Каждый день. Нет, сейчас, подождите, мне кажется,
что это очень странно. Что? Typical плюсы.
У меня есть подозрение, что, может быть, это из-за того, что он уже эту ошибку обнаружил здесь и не
стал говорить о ней второй раз. Да, наверное, вот в чем дело, наверное, он просто обнаружил эту ошибку
здесь, не стал ее повторять. Вот. Но мы еще не получили ошибку вот здесь. Что здесь за ошибка?
Здесь мы пытаемся присвоить аргументу по умолчанию число 3, но это тип такой,
которому не принадлежит присвоить int. Мы приняли тип и пытаемся ему присвоить число. Мы просто
безымянный аргумент завели. Можно заводить безымянный аргумент со значением по умолчанию,
зачем? Ну да, синтез позволяет. Это как если бы я написал так, просто не придал ему значение.
Что? Зачем? Нам это скоро пригодится, кстати. Мы же нигде не можем. Правда, в шаблонах. Например,
чтобы сгенерировать ошибку как раз. Это может быть нужно. Ну, короче, вот это не вызвало ошибку,
и вот это не вызвало ошибку, и вот это не вызвало ошибку, потому что тела функции не инстанцировались,
и даже аргументы по умолчанию не инстанцируются, не произведена проверка, что вот это вот ему не
потребовалось подставлять аргумент по умолчанию, поэтому он не выдал ошибку.
Если бы я попытался сказать трики blah blah blah t, а потом сказал t.nobodyhere и не передал
аргументов, то он бы, конечно же, выдал ошибку, потому что теперь-то ему надо подставить аргумент
по умолчанию, а я не передал его, а значит, он будет пытаться присвоить этому типу тройку
и будет CE. Ну, понятно, что он логично будет, если я попытаюсь вызвать сейчас, что там,
in class и так далее. Короче, тела не инстанцируются, когда я объявляю, когда я использую класс,
инстанцируются его все объявления в нем, но определение метов еще пока не инстанцируется,
а когда я уже использую функции из него, то инстанцируется определение этих функций.
Вот. Еще один интересный вопрос, что будет, если я скажу вот так.
Ну, по идее, то же самое. Вот, смотрите.
Хотя, кстати, у нас до этого был пример, когда у нас в классе еще общего определения не было,
вот именно, если я делаю указательно на тип, это не заставляет компилятор генерировать
определение этого типа. Например, поля класса знать не нужно для этого. Вот, чтобы создать объект
типа T, компилятору нужно узнать все про его поля, например. Вот это неизбежно нужно подставить сюда,
потому что здесь нужно выяснить сайзов этих полей, например. Но если я делаю pointer,
то компилятору не нужно этого делать. Потому что pointer на T, он не зависит от того,
что на самом деле содержит в себе T. Вот если бы я написал вот это равно new tricky,
бла-бла-бла, то опять нужно. Но если я просто завожу pointer, ну ладно, компилятору на самом деле
не нужно ничего инстанцировать, и это компилируется вообще без ошибок. То же самое,
если бы я ссылку завел. Если я завожу указатель или ссылку на тип, то это, что называется,
не требует от типа быть complete type. Complete type – это тот, у которого определение есть,
и оно корректно. Но заводить указатель или ссылку на тип вообще не нужно. Для этого вообще не
нужно, чтобы тип обладал определением. Сейчас, а как мы можем создать ссылку? Мы же сразу должны
унициализировать чем-то. Я, например, могу написать функцию, которая принимает ссылку на вот это.
А, хорошо. И тут что-то делать, но к полям не обращаться. Я не знаю, эту ссылку передать куда-то
еще. Вот это все прекрасно будет компилироваться, потому что я не создал объект типа трики. Ни разу
нет в коде места, где компиляторе реально нужно знать, что такое трики под ним, что лежит. Это
просто ссылка, которая как указатель используется. Вот этот факт, он один раз, даже не один, нам
пригодится вскоре. Сайзов ссылки ему тоже не нужен. Сайзов ссылки – ссылка представляется,
как указатель, неважно какой это тип. Размер указателя типа не зависит. Если я спрошу сайзов
от T вот здесь, то, конечно же, он подставит все трики и все упадет. Просто сайзов от T – это не
сайзов от ссылки, это сайзов от самого типа. Я напоминаю, сайзов от ссылки означает сайзов
от самого типа. И поэтому такой вызов его заставит инстанцировать поля. А без этого и не нужно.
Вот. Есть такая замечательная штука в C++, которая называется явное инстанцирование – explicit
instantiation. Наверняка вы ни разу этим не пользовались, но если может кто-то пользовался,
круто. 99% инстанцирований, которые вы делаете, они не явные implicit. Они происходят,
когда вы начинаете использовать класс, и тогда компилятор вынужден подставить то,
что вы сказали. Вот. Но на самом деле есть способ. Сейчас. Я попробую открыть страничку
референс соответствующую. Да. Вот. На самом деле есть способ сказать компилятору явно – проинстанцируй
сейчас, пожалуйста, вот это. Это называется explicit instantiation. Вот как это пишется. Вот пример.
Вот, допустим, я хочу, а вот чтобы в этом месте кода компилятор явно сделал подстановку и
сгенерировал соответствующий класс с подставленным T. Вот. Я могу так написать. И это проявит все
ошибки компиляции, которые случились бы, если бы я вот заиспользовал этот класс явно. Ну,
давайте, например, я напишу вот здесь вот. Только, по-моему, в локальном скопе нельзя делать.
template class tricky inzip t-1. Вот. Все. Я явно запросил инстанцирование. Вот мы сказали required
from here. Here – это 36-я строчка. 36-я строчка – это вот эта строчка. Он все еще nested не заводил,
если мы хотим еще nested нам отдельно прописывать, да? Да. Если я хочу nested инстанцировать,
я могу и так написать. Это же то же самое, что создать типа переменную такого типа,
только не называть. Нет, это совсем не то же самое. Я не создаю никакую переменную. Я заставляю
компилятор сделать подстановку. Мы просто называем типа, из-за этого он обязан все подставить, да? Да.
Он в этот момент функции все тоже инстанцирует? Нет, конечно. Он делает ровно то, что я его
попросил. Вот сейчас он сделал только инстанцирование класса tricky. Это как если бы я написал вот так.
Но методы его он еще не инстанцировал. Чтобы заставить его еще и метод инстанцировать,
я могу явно попросить инстанцировать метод. Например, я говорю template class такой-то,
а я могу сказать template void tricky int-1, 2.2.int class. А это вот вообще закомментирую.
И это закомментирую. Теперь я его заставил инстанцировать не просто класс, а конкретный
метод этого класса. Вот. И я увидел, что... так, no member function in class. Вот бы можно было еще
заставить его поинстанцировать вообще все. Ну вот, он проинстанцировал in class и,
собственно, напоролся на те ошибки, которые там были. Вопрос. Зачем это может быть нужно?
Это бывает нужно редко. Но зачем может быть нужно explicit instantiation? Кроме как... Во-первых,
первое для чего. Чтобы проверить, что вы правильно написали код с данными подставленными типами.
Потому что, когда вы просто написали шаблонный код, вы, значит, еще не факт, что...
корректно его написали. Компилятор это не проверяет, пока вы не воспользовались. Вы можете таким вот
методом заставить... таким вот способом заставить компилятор для данных конкретных типов сгенерировать
вам определение, чтобы убедиться, что с этими типами все нормально. Вторая причина интересная.
Что на самом деле ведь происходит, когда вы так пишете? Вы заставляете компилятор сгенерировать
конкретный экземпляр этого класса. Вот представьте, у меня этот класс. Он в... ну вот, я пишу
некоторых хедер. Шаблонный класс я определяю в хедере, в Вашнике. И здесь у меня... А мы типа
это вынесем в другой этап компиляции и можно будет не компилировать каждый раз заново? С помощью
явного инстанцирования можно добиться того, что вам не придется определение в хедере писать
для некоторых типов. То есть обычно, когда вы инстанцируете, когда вы пишете шаблонные классы,
вы в хедере пишете определение методов.
Правильно? Потому что вы не можете... вы не можете их писать в cpp-шнике, линкер их не слинкует.
Вам надо, чтобы уже на этапе компиляции были все определения видны. Ну иначе линкер не найдет
соответствующее определение в хедере под тот метод, который вы определили в cpp-шнике. Потому что
в хедере был шаблонный код, а в cpp-шнике вы написали конкретный. Ну или вы тем более в cpp-шнике
написали шаблонный, и в хедере был шаблонный. Линкер не слинкует. Шаблоны — это сущность
времени компиляции. Линкеры не умеют с шаблонами работать. Что вам позволяет делать явное
инстанцирование? Вы можете написать в хедере вот такую штуку, и тогда у вас прям в хедере будет
нешаблонное уже определение. Вы в этот класс подставили конкретные типы, и компилятор
сгенерировал вам здесь определение класса, пока еще без определения методов, шаблон с подставленными
типами. Это дает вам возможность для данных типов определение писать в cpp-шнике, определение методов,
потому что их линкер уже сможет слинковать. Потому что в хедере таким образом появятся конкретные
определения с конкретными типами, конкретные объявления с конкретными типами. А в cpp-шнике у вас
будет определение с этими типами, и линкер слинкует тогда. Он слинкует только вот эти
подставленные шаблоны, да? Конечно, для этих типов конкретных вы сможете слинковать. И на самом
деле вы можете таким образом добиться того, что ваш класс разрешено использовать только с
такими типами. Например, вы написали шаблон в хедере без определений, а дальше перечислили
несколько типов, для которых написали явное инстанцирование. Например, template-void-tricky
от int, template-void-tricky от double, еще там 10 типов. Но это игра копипасты же.
Сейчас, ну еще раз, а любой шаблонный код это копипаста. Компилятор все равно генерирует
конкретные экземпляры, когда вы типа подставляете. Но когда вы написали явное инстанцирование,
и допустим header пользователю менять нельзя, тем самым вы разрешили пользователю определять
методы только для вот этих типов. Вы сказали, мой класс, он шаблонный, но он только для таких
типов работает. И если юзер хочет, он определит для каких типов ему надо, а для других будет
нельзя, потому что в хедере этого не определено, явного инстанцирования нету, и все, уже в cpp-шнике
ты ничего не сделаешь с этим. Вот такие дела. Это что касается чуть более подробно о правилах
инстанцирования шаблонов. Ну а теперь переходим к самому приятному или не знаю какому. Возвращаемся
к метапрограммированию. Теперь, когда мы поговорили про инстанцирование,
самое время начать что-то писать на шаблонах. И пункт 15.2 будет
базовые примитивы для шаблонного метапрограммирования. Что вообще такое шаблонное
метапрограммирование? Ну мы уже так скользь его касались, у нас были функции, а теперь будут
метафункции. Что такое метафункции? Это штуки, это на самом деле структуры, они по типам возвращают
либо значения, либо другие типы. Вот. Самая простая метафункция, это, наверное, такая.
Она называется Type Identity.
В ней написано using type равно t. Это тождественная метафункция.
Они все есть в STL. Начиная с C++20 есть.
Ну какие мы с вами знаем метафункции? Мы, например, знаем функцию Remove Const. Она берет тип,
снимает с него конст. Там написано Remove Const t type. Это то же самое, что и ты, только без конст.
А, ну нам вот эта фигня интересна, когда мы хотим от какого-то выражения узнать, какой он тип,
и вместо decal type можно вот это писать, да? Нет, это не совсем. Decal type — это штука,
которая по значению дает тип, а это штука, которая по типу возвращает его сам. Ну мы со
временем поймем, зачем это может быть нужно. Мы просто хотим, чтобы у нас все операции были,
так сказать, унифицированные, что ли. То есть у нас есть вот, у нас будут какие-нибудь вещи,
которые ожидают класс с using type внутри него. И это может быть, например, Remove Const от чего-то,
и мы в нем залезаем type и посмотрим, какой type. Может быть, typeIdentity. Вот, ну можно сказать,
что еще typeName, typeNameT, как обычно, using typeIdentityT — это то же самое, что typeName,
typeIdentity, а T — 2.2.type. А это тождественная метафункция. Какие еще бывают метафункции?
Ну, например, можно придумать метафункцию conditional. Значит, что такое conditional?
Да, это условно. Ну, давайте напомню. Темплей typeName, не typeName, а bool.
B — typeNameT, typeNameF, struct conditional. И здесь написано using type равно f. А еще и специализация,
в которой написано template уже от двух штук. И здесь написано conditional от true,
t, f. И здесь написано using type равно t. А у нас есть это, как называется? Тернарный оператор constexpr.
Не понимаю вопроса. Что значит это? В плане, сейчас, можно ли написать type равно f, если b,
типа, иначе? Ну, t, если b, иначе f. Как ты предлагаешь это написать? Ну, там,
через тернарный оператор условно. А более конкретно? B? Ладно, окей. Ты понял
проблему, да? Или не понял? Ну, типа, разные типы у тернарных. Да, не разные типы. Это оператор
бывает над expression, а это типы. Ну, в любом случае, возвращаем значение. Нет, нет, это не читается
просто. Проблема глубже гораздо. Это нечитаемая запись. Это не expression. T — это не expression.
Ну, да. Ну, вот. Какой оператор может быть? Я же не могу написать t плюс f, например. Это тебя более...
Ну, хорошо, int плюс f. Оператора плюс... Ну, да, наверное. Точно та же проблема. Я не могу использовать
оператор над типами. В этом и смысл существования метафункций. Conditional — это и есть тернарный
оператор, но над типами, это тернарный метаоператор, это и есть он над типами. Потому что мы не
можем использовать оператор над типами, у нас должен быть метаоператор. Conditional — это он и
есть. Conditional — это и есть аналог тернарного оператора для типа. Ну, по идее, да. Но мы не можем,
конечно же, использовать обычный тернарный оператор, потому что в этом смысл Conditional заменить нам
тернарный оператор для типа. Вот. А что такое Conditional-T? Conditional-T — это вот такая штука.
removeConst, addConst, addRvelUreference, removeRvelUreference и так далее.
Это все функции такие, преобразователи типов.
Бывают метафункции, которые как бы возвращают значения по типу.
Ну, например, template, typeName.
Ну, банальное самое, это isSame, да, то есть проверка равны ли два типа.
Давайте что-нибудь более интересное напишем. Ну, например, template, typeName.
Что написать можно?
Ну, я не знаю, typeName, typeStruct.
Это не очень интересно, но мы это писали в первом семестре.
Стракт из pointer и здесь будет static const bool value.
Равно false.
Вот.
И дальше мы делаем специализацию для т-звездочек и говорим здесь true.
И делаем, значит, опять template, typeName t.
Но на этот раз уже const bool.
Ну, на самом деле constexpr, правильно сказать,
constant времени компиляции bool из pointer v от t равно isPointer от t 2.2.value.
Вот.
Но я не буду перечислять другие.
Мы поняли, что вот это вот такие базовые штуки, которыми мы в принципе и так уже владеем.
Давайте я просто открою список этих штук на cp-reference.
Он находится в файле type-trade, все эти штуки.
Сейчас вы увидите этот списочек.
На самом деле, мы, кажется, его тоже уже открывали.
Ну, то есть вот такие замечательные метафункции.
Is void, is null pointer, is integral, is floating point, is array, is enum, is union class, bla-bla-bla-bla-bla.
Все это интуитивно понятно.
Is pointer, is a value reference, is member object pointer, is member function pointer, is fundamental, is arithmetic, is scalar.
Своиства, связанные с конструированием, можно ли конструировать, нельзя ли.
Значит, is same, is base of, is convertible и так далее.
Впрочем, вам, наверное, должно быть непонятно, как реализована, по крайней мере, часть из них.
На самом деле, большинство.
Вот скажем, как реализована is constructible, мы пока не понимаем.
Такое void-t.
Где?
Там было.
Ну, нам вебуку будет видно.
А, это, скорее всего...
Очень полезно.
Я, к сожалению, забыл пример, когда это нужно.
Такой пример есть, но...
А в чем реально смысл просто будет писать?
Не сейчас, нет. Там есть пример, когда это нужно, я, к сожалению, не помню.
Вот. Я хотел бы обратить внимание, прежде чем перейти к нетривиальным примерам, на парочку важных вещей отсюда.
Для начала вот такой. Мы будем им часто пользоваться.
Struct integral constant.
Что это такое?
Это такой тип...
Играла константы.
Нет.
Это...
Размечтался.
Мы сейчас его реализуем.
Значит, что такое integral constant?
Template type name t, запятая t, v.
Struct integral constant.
И здесь написано static constant t value равно v.
Вот, по сути, что такое integral constant.
Ну, можно сказать, это константа времени компиляции.
Вот. Что такое...
А можно чуть подробнее, в чем смысл? Это вообще непонятно.
Зачем это может быть нужно?
Ну, самый простой пример, для чего это может быть нужно, это для того, чтобы говорить.
Вот, например, isPointer.
Это не static constant bool value равно false.
А просто...
integral constant bool false.
Я говорю, isPointer.
Это не что иное, как integral constant bool false.
И эту строчку просто стираем.
Я не хочу каждый раз писать static constant bool value равно чему-то.
Я хочу писать integral constant с такими-то параметрами.
И это и будет static constant bool value равно false.
Но на самом деле есть еще лучшее.
Есть тип bool constant.
А template type...
Значит, template bool...
Не знаю, bool.
Struct bool constant.
Это integral constant с типом bool и значением bool.
И на самом деле, вот здесь, вместо того, чтобы писать integral constant, я просто пишу bool constant.
От false.
А здесь я просто пишу bool constant от true.
Понимаете теперь, зачем это?
Вопрос, а почему integral constant это именно integral?
Почему другой тип не может быть?
Потому что...
Числовыми параметрами шаблонов могут быть только integral типы до C++20, впрочем.
А то сейчас это может быть не integral constant.
Начиная с C++20...
Я, кстати, не уверен.
Но начиная с C++20, стало можно делать параметрами шаблонов и не только целочисленные типы.
И не только bool.
Но...
К минимум, туда даблы можно, по-моему, запихать.
Да, да.
Да и некоторые классы теперь стало можно.
Чуть позже обсудим, у нас время еще останется, мы обсудим.
Но вот до C++20 integral constant было именно integral constant.
Именно вот такая константа, такого типа.
Вот.
Она не обязательно бывает bool.
Можно, например, придумать метафункцию, которая возвращает int constant.
Например, rank.
Знаете, такая функция rank.
Что такое rank?
Да-да-да.
Максимальное количество линей независимого константа.
Что такое rank?
Да-да-да.
Максимальное количество линей независимых строк.
Нет.
Rank – это другое, ты не понимаешь.
Это количество измерения массива.
Есть такая метафункция rank.
Она говорит, какова размерность массива.
Сколько звездочек, короче?
Ну, типа.
Вот, есть функция rank.
Ну, это понятно.
Да.
Ну, рекурсивно.
Просто мы снимаем одно измерение, и вот вся реализация.
Что такое rank?
Это просто integral constant size t – ноль.
Специализация для массивов – это integral constant.
Size t – такой же rank, как у t, без скобочек уже, и плюс один.
Вот и все.
Вот зачем нужны integral constant.
Отсюда становится понятно, зачем нужен type identity.
Например, для чего?
Да для того же, чтобы мне не писать вот это, а писать этот type identity от f просто.
Чтобы мне не повторять каждый раз using type равно, а говорить, что это type identity от такого-то параметра.
Ну, это типа мы вместо, ну, как бы мы в логику вносим, в логику наследования.
Да.
Ну, у меня просто теперь, я не хочу повторять каждый раз вот этот using, я не хочу повторять каждый раз статик cons что-то там value.
На самом деле здесь cons text поправильнее писать, но пока cons будем писать.
Я просто буду говорить, что это type identity от f, и все понимают, что это имеется в виду, что вот, значит, он просто такая метафункция т.
Вот еще одна прекрасная метафункция, даже две.
Это conjunction и disjunction.
Значит, что такое конъюнция?
Template.
Значит.
Type name.
Сейчас скажу.
Значит, как я хочу пользоваться конъюнцией?
Я хочу, чтобы конъюнция, это была такая штука, которая мне позволяет сделать и по всем типам.
Вот я скажу, type name многоточие types.
Struct conjunction.
И здесь будет.
Все-таки я напишу static const bool value равно.
Types.
Ну, тут может быть, конечно.
Вот так мне надо написать, скорее всего.
Как-то так.
Ну, то есть, например, я говорю conjunction is pointer, запятая из, не знаю, что-то там.
Значит.
Из class, из default constructible, из что-то-нибудь еще.
Из trivial or copyable.
И я все это запихаю в conjunction.
По сути, у нас как бы украли все операторы.
еще из trivially copyable. я все это запихаю в conjunction. но по сути у нас как бы украли все операторы.
я хочу метафункцию, которая принимает типы и делает и по ним по всем, но эти типы они сами
метафункции. то есть я делаю такую функцию второго порядка. из этих метафункций собираю
другую функцию. вот давайте я покажу вам это опять-таки на cpp-reference. вот такая замечательная вещь
conjunction. вот что она делает. берет и ну можно ее вот так реализовать. то есть она берет что
делает. говорит это conditional на самом деле. если value true, то conjunction остальных, а иначе
просто вот это value. но можно сделать и через fold expression, начиная с... я вас обманул. то как я
написал, это плохая реализация. здесь сказано почему. да, ну она правильная, но плохая.
смотрите, вот я написал через fold expression, и это хуже, потому что в таком fold expression
не инстанцируется все. и да, инстанцируется все. он развернет и инстанцирует все. а правильная
реализация conjunction вот такая. тогда она не будет инстанцировать вот это. ну в смысле
она не будет подставлять туда все остальные, если поймет, что ответ уже известен.
она не будет разворачивать все уровни. вот так. не будет разворачивать все conjunction от всего подряд.
да, это я, конечно, облажался, забыл. вот fold expression. это очень коротко, но так
лучше не реализовывать. значит это not lazy. да, ну и последние две штуки. это true type и false
type. вы, возможно, их встречали в своей жизни. что такое true type? это просто bool constant с
параметром true. это уже не шаблон. true type это просто bool constant с параметром true.
а false type это просто bool constant с параметром false. и на самом деле это даже не структура,
это просто using. я просто скажу, что using false type это в точности то же самое,
что bool constant с параметром false. а true type это bool constant с параметром true.
вот. и вместо того, чтобы писать bool constant с параметром false, мы просто будем писать false type.
еще короче, еще проще. вместо того, чтобы писать bool constant с параметром true,
мы будем просто писать true type. по ощущениям мы сейчас делаем миллиард движений, чтобы писать
на два симпла меньше. не два. на два умножить на количество метафункций, которые нам предстоит
реализовать. это называется базовые примитивы для шаблонного метапрограммирования. дальше,
всякий раз, когда вы захотите написать какую-то структуру, которая является метафункцией,
возвращающей true, вы просто пишете это false type и все. такое много раз мы встречали. вот.
пожалуй, это все. ну, аналогично conjunction, есть еще disjunction и negation.
а последнее? negation. отрицание.
вот. ну а теперь мы перейдем к самой замечательной части сегодняшнего вечера 15.3,
которая называется SFINAE и enable if. до сих пор все метафункции, которые мы реализовали,
они были тривиальными в каком-то смысле. все, что там происходило, это мы делали некоторые операции
над какими-то константами, либо мы делали шаблонную рекурсию, уводя дальше, вызывая метафункции от
меньшего числа аргумента. мы пока не делали ничего выходящего за рамки простых вот этих
вот двух вещей. мы либо шаблонную рекурсию делали, специализацию шаблонную, либо просто делали вот так.
все меняется, и к нам приходят новые совершенно неизведанные и огромные невероятные возможности
шаблонного метапрограммирования, если мы внимательно вчитаемся в стандарт и обнаружим
там одно маленькое правило инстанцирования шаблонов, которое я до сих пор не упоминал.
вот я, честно говоря, даже не знаю, опять-таки люди, когда писали стандарт в первый раз, они
осознавали последствия того, к чему приведет этот пункт. я не уверен, но, может, кстати, да,
но маленький такой пунктик есть в правилах инстанцирования шаблонов. так называемое
что это такое? представим себе,
то у меня есть две функции шаблонных, и одна из них,
одна, значит, вот устроена так, она принимает, ну, допустим, Т, а возвращает,
Т, двоеточие, двоеточие, не знаю, value type, только type name надо написать,
ну, не знаю, return,
х, влевое, а вторая функция, она, она даже не шаблонная, она просто возвращает int,
а называются они одинаково.
значит, смотрите,
допустим, я решил вызвать f от вектора, std vector int v равно 1, 2, 3, 4, 5,
имф можно не писать, и так понятно, что int, правда, вектор надо все-таки заинклубить,
вот, и решил вызваться от v, какая версия предпочтительней? ну, конечно же,
вот эта, потому что она от одного аргумента, а вторая вообще от произвольного числа аргумента,
конечно же, лучше выбрать f, хорошо, какой тип она будет возвращать?
t, двоеточие, двоеточие, value type, что такое t? это v, от int тоже получается,
чего? от int тоже, да, подождите, сначала от вектора, значит, какой тип она будет
возвращать? t, value type, value type там int, значит int, и х, нулевое надо вернуть, ну, 1 должно
вернуться, давайте выведем то, что она возвращает, 2 плюс плюс 11, метапрог, надеюсь,
я нигде не совершил больше ошибок компиляции, нет, где-то все-таки совершил, а где в 23 строке
я неправильно реализовал conditional, ну, конечно же, conditional должно быть от трех аргументов,
bool b, я просто удалю это, короче, вы поняли, что она была за ошибка, вот, значит, компилируем,
так что ли, constexpr написал, нет, все равно, там, конечно, просто t не нужно, а, t не нужно,
конечно, нет, constexpr bool, я же шаблон объявляю, мне не нужно t, наконец-то, вернулся 1, а теперь
давайте попробуем вызваться от int, ну, пойдем, наверное, логически c должно быть, да нет, нет,
мы не упали как так и вот это как раз и есть тот так как сказать маленькая маленькая зернышка или
я даже не знаю что маленькая семечка языка из которой произрастет огромное дерево облонного
метапрограммирования это правило говорящие о том как компилятор должен вести себя если
в ней не получилось инстанцировать объявление некоторые функции пусть у нас есть перегрузка
функций и компилятор понимает что предпочтительнее вот некоторые из них выбирает ее тогда он
пытается подставить т в ее объявление и вот тут у него может не получиться потому что при данном
ты объявление некорректно именно объявление вот это супер важно именно объявление не определение
а объявление вот если компилятор при перегрузке функций выбирает некоторую функцию и понимает
что при данном ты ее объявление некорректно именно объявление то он не падает покуда у него
есть другие версии он просто выбирает более предпочтительную из оставшихся а если бы я
сделал вот здесь вот так вот значит x нулевое и вернул его да да результат просто 0 давайте я
просто верну 0 верну result значит вот я даже не обратился квадратными скобками к вектору я
просто сказал значит авто возвращаемый тип и вот так сделал вот сейчас я упаду
потому что int is not a class struct or union type не получается обратиться к t ну нету там
короче это придумал это придумал комитет по стандартизации вот если если во время
инстанцирования объявления при перегрузке функции компилятор понимает что объявление
некорректно он не падает покуда у него есть другие версии функции но если он инстанцировал
объявление и объявление корректно то он начинает инстанцировать определение и вот тогда он уже
падает если там ошибка при данном т раз и мы чтобы инстанцировать определение с аута не нужно
ну типа получить result ну возможно вы правы и возможно здесь он бы упал в любом случае но
тут у меня объявление это само по себе корректно в любом случае то есть вот это правило не сработает
то есть гляда на объявление компилятор не понимает что что-то не так и ты сюда
явно не годится компилятор подставляет в объявление и либо он понимает что ты сюда
не годится либо не понимает и начинает инстанцировать определение вот тогда уже все если он source
там наткнется на проблему он не пойдет другой функции но если он глядя на объявление сразу
понимает что дchet эту версию не подходит хоть она и предпочтительно по правилам перегрузки он
не выбирает ее выбирает оставшуюся а есть какие-то экзистенциальные проблемы в том чтобы еще и
определение скомпилировать и проверить или это просто решили не делать я думаю что забыли слушайте
я не знаю чем рука значит что что мне ну мало ли может просто есть конкретные проблемы почему
нельзя это сделать не знаю что курил комитет когда это придумал я все это я на эти вопросы
не умею я к сожалению не один из них я бы с удовольствием вместе с ними это
попридумывал так или иначе это правило существует в языке c++ еще до исторических времен еще когда
вы не родились оно существовало еще значит c++ 98 оно существовало в самом начале когда
только шаблоны появились оно уже было кажется это правило ну или в 2003 вот или я так ненавязчиво
признался что он хочет попробовать эту дурь вот отсюда сразу следует интересное следствие можно
таким нехитрым способом используя этот ах да это называется с финайя замечательная аббревиатура я
вам говорил что моя любимая тема в курсе тому семантика одна из двух вот это вторая из двух
значит это называется substitution fail и резнотен эррор расшифровывается так ну на самом деле я
даже не знаю что из этого наиболее любимая сейчас мы с вами увидим много всего интересного
я говорю заочно поэтому не настолько к сожалению да к сожалению да к сожалению вот я я уже
говорил что очень жаль что у нас так вот вышло особенно еще эти выходные не получается увидеть
ваши восторженные лица глядящие на это все божественное изобретение тем не менее давайте
теперь придумаем нехитрый из этого вытекающий способ как научиться диспатчить между ну скажем
ну скажем
функция вот
то я могу написать функцию которая принимает int возвращает double и другую которая принимает
возвращает вектор и типа чтобы он выбрал правильную давайте такой я вам задам вопрос вот представьте
что я хочу устроить диспатч следующий я хочу выводить один если моя мой те это коллабл то
есть круглые скобочки применимы к нему и 0 иначе что надо написать ну что что-то типа стд
conditional круглые скобочки какие круглые скобочки и к с точки круглые скобочки значит я хочу чтобы
если у объекта типа t есть оператор круглые скобочки ну допустим без аргументов или от
int то я могу то я попаду сюда а иначе нет как мне этого добиться давайте кто-нибудь это легко мне
надо написать некоторые такой возвращаемый тип чтобы если у их есть круглые скобочки он был
корректен а если нет тот был бы и на и был и нет подожди на был и мы еще и пока декол тайт какой
небо хочу в лоб да смотрите декол тайт а от чего
но видимо а ты в самой дупой реализации круглые скобочки да но если я так напишу у меня получится
возвращаемый тип такой же как у их с круглой скобочки а я хочу чтобы настоящий это возвращаемый
тип все-таки был им что же мне сделать я теперь conditional обернуть ваш ну вот это обернуть
conditional conditional декол тайп от икс запитая инд запитая инд что ли или чего нет подождите
первый аргумент в кондиционе должен быть буль кондициону а бульта какой там будет
одно еще какой-нибудь функцию завести которая проверяет совпадение может быть этот интеграл
что-то там вот этого типа так короче все гораздо проще не надо никаких метафункций у нас есть
оператор запитая помните меня спрашивали в октябре или в сентябре запитая смотрите я делаю очень просто
что ну или вот так спасибо большое ну смотрите я сказал возвращаемый тип этой штуки такой же как
вот такое выражение икс круглые скобочки запитая 0 какой тип этого выражения и конечно потому что
тип этого выражения это тип второй его части что оператор запитая но только это выражение
некорректно если у икс нет круглых скобочек какой у нас вот поэтому теперь давайте я заведу
например стд фанкшн стд фанкшн int f равно вот такому
значит у меня есть функция f так нет f плохо g и я вызываюсь от g а потом вызываюсь от
им та стд фанкшн наверное у меня не за инклуженно сейчас за инклудим
вот теперь если я вызываюсь от g я попадаю сюда ну короче просто просто сами смотрите сейчас будет
все как надо поняли как это работает это называется кома трик трюк с запятой
с помощью оператора запитая я добиваюсь того что у меня возвращаемым типе присутствует некомпилируемые
выражения если мне не нужно чтобы они компилировались но возвращаемый тип настоящий
все-таки такой как мне нужно в итоге потому что запитая она дает такой тип как и правая часть
понятно
понравилось вам но это какой-то хак языка типа да вообще свина это хак языка только я не
могу понять это хорошо или плохо это великолепно значит для использования кажется что это хорошо но
возможно есть некоторые нюансы ну нюансов много сейчас мы их обсудим на самом деле вот до
изобретения c плюс плюс 20 до концептов именно большая часть тайп трейтов которые оперируют
возможностями наличие операции примерно так и были устроены ну то есть они устроены на том что
компилятор от диспанча то в ошибку компиляции то нет он просто за счет свиноге оно отваливается
и вы от нас остается только нужная версия это такое прям в лоб свинайя свиноге а я хочу написать
значит сейчас некоторый гаджет если можно так вырезаться который бы это вот это вот добро
сделал менее коринжевым для использования то есть если вам придется каждый раз самим вот
такую штуку изобретать ну то есть вот с этим декл-тайпом это как-то совсем есть значит готовый
опять-таки шаблончик примитив который позволяет вам во всех большинстве таких ситуаций
ну скажем так
нормально
нормальный код писать называется enable if значит enable if такая штука которая позволяет вам то
выключить то включить версию функций в зависимости от какого-то компл-тайм условия
ну например там этот мы правда еще не умеем с вами реализовывать метафункции в духе из
класс из колоб из инвокабл и так далее но давайте например я вам напишу то же
самое через enable if вот давайте я заведу какую функцию на h у меня будет такая функция
template type name t void h и я хочу чтобы она вызывалась только для вещей которая инвокабл а вторая
чтобы вызывалась только лишь для ну а вторая для всех остальных да ну и к тому же мне здесь
неудобно что мне приходится писать вот здесь вот переменное число аргументов я хочу чтобы
у меня тоже был здесь один аргумент просто вот это бы вызывалась только для инвокабла вот это
только для ней инвокабл что мне делать значит давайте я использую штуку под названием enable if
значит как это пишется значит стд ну пишется это вот так type name равно стд enable if t от
стд инвокабл
от v
без аргументов
а ну аргумент t а больше аргументов не нужно кажется вот так а так это у меня угловая скобка
закрылась от t это угловая скобка это инвокабл это угловая скобка от моего шаблона и
вроде все вот значит
я пока не уверен что это сработает сейчас сейчас я проверю дать не сработала потому что потому что
а потому что это вой а мне надоим
давайте и сделаем а так теперь у меня нету этого значит а потому что я написал инвокабл
надо из инвокабл хорошо давайте напишем из инвокабл из инвокабл напоминаю это метафункция
пока мы не знаем как она реализована мы предполагаем что нужные нам type traits то есть
проверка свойств уже реализованы они сами тоже реализовали нет типа почти ну почти кстати да
мы на самом деле почти и реализовали но можно сказать что мы ее вскоре реализуем нормально ну по
сути да вот но в общем есть метафункция которая примерно так и работает которая проверяет инвокабл
или нет и дальше есть метафункции наиболы в которая вот так вот устроена значит давайте
еще раз третий раз попробую скомпилировать вот это к сожалению работает потому что потому что
непонятно что выбрать непонятно значит действительно ну и это от одного ты и это от одного ты а
мне получается обе подходят вызов неоднозначен давайте я сначала объясню как быть как работать
а потом мы поймем как исправить проблему с ней назначить вызова что такое наиболы наиболы это
такая структура в которой первым параметром передается буль шаблонным а вторым по у нее
еще есть не обязательно и второй параметр но про него пока забудем значит что эта штука делает
она просто в себе
да я ее просто реализую сейчас я вам сейчас покажу как она устроена значит что такое наиболы
это такая штука template буль б type name t равно void и она
стракт enable if устроена так а вот так она устроена но у нее есть специализация на
случай если буль был true значит template type name t enable if true t по моему аргумент по умолчанию можно
уже не писать и тогда она является наследницей type identity от ты
скорее всего ничего не понятно пока как это работает смотрите структура enable if это либо
пустая структура либо структура в которой написано using type равно t вот и весь трюк
если вы enable if мы передаем первым аргументом то есть по сути единственным обязательным
аргументом true то мы попадаем версию в которой написано using type равно t но
т по умолчанию void если мы передаем false то в ней первым аргументом то в ней ничего не
написано это просто пустая структура а дальше у нас есть как обычно using template буль б type name
t равно void кстати может быть даже вот здесь не надо писать так а достаточно только вот
здесь аргумент по умолчанию передать using enable if t равно type name enable if от bt 2.2.type
смотрите что происходит если мы в эту функцию передадим тип который не инвокабл то вы
enable if первым аргументом подставится false это значит что enable if это будет структура с
пустым телом а значит enable if t попробует залезть в type которого там нет ну это похоже на наш
первый пример где было value type которого нет enable if t это штука которая такая enable if с
такими параметрами 2.2.type но там нет 2.2.type там потому что false мы в пустой структуре поэтому
вот этот тип не корректен но это шаблонный аргумент по умолчанию обратить внимание у меня
написано type name не дано имя шаблонного аргумента и написано равно вот это вот хрень это шаблонный
аргумент без имени который имеет вот такое значение по умолчанию соответственно когда
я вызываю эту функцию от же не компилируем если нужен да когда я вызываю функцию от чего-то
инвокабл то это работает потому что enable if t по умолчанию автоматически представляется и там
true ну и хорошо там есть какой-то тип по умолчанию который будет равен void ну и бог с ним но если
я вызовусь от единицы это уже не скомпилируется потому что там нету этого типа вот от int вызваться
нельзя можно только от инвокабл вызваться потому что no type named type и структ enable if false
void
а теперь как я могу сделать перегрузку то есть теперь я таким образом добился функции которая
работает только для инвокабл типов а для ней инвокабл она просто выдает ошибку компиляции но
это пока я не очень многого добился что я мог бы так просто напрямую вызывать ик здесь круглыми
скобочками и оно бы падала если бы это был не вокабл чего интересного но я могу добиться
перегрузки я могу сказать вот здесь вот я давайте эту строчку скопи пащу и здесь напишу вот так
type name равно стэмин т не стд инвокабл в от казалось бы я могу так написать на самом деле так еще
не будет работать сейчас скажу как надо чтобы работал почему не будет вот здесь есть очень
тонкий момент что все еще не понятно что лучше перегрузки а тонкий момент заключается в том что
я переопределяю функцию с таким же набором шаблонных аргументов
сейчас так что ну да у меня была функция с одним шаблонным аргументом обязательным и другим
шаблонным аргументом являющимся типом имеющим такое значение по умолчанию я пытаюсь
переопределить функцию с таким же набором
аргументов но
с другим значит значением аргумента по умолчанию
ну так нельзя ну типа как бы шаблонные сигнатуры не отличаются я пытаюсь сказать нельзя как-нибудь
закостылить это добавить там еще один фейковый тейп на им правильно так мы сейчас и сделаем мы
только костыль заключается вот в чем просто надо написать не так ура а надо написать вот так
что
теперь у меня разные шаблонные сигнатуры но это вообще ну что смотрите а
я написал но во первых давайте проверим что это работает а может я вас обманул да
теперь это работает и в одном случае один другом 0 красиво правда
американская мечта смотрите
ну вопер попробуйте это распарсить вообще почему корректно то что-то написано
здесь написано первый аргумент t а второй аргумент это enable if t с шаблонными параметрами
вот такими которые по умолчанию равен true а что такое enable if t вот с такими шаблонными
параметрами стук только эта структура нет enable if t это using enable if это структура в которой
либо есть тип type либо ничего нет а enable if t это либо буль либо некорректный тип
если я вызываюсь от g я вызываюсь от инвокабл тогда компилятор вот это вот превращает в ну
для компилятора это превращается в стимплей type name t запятая буль равно true потому что
enable if t от true запятая буль это в точности буль я правильно понимаю как бы завел шаблонный
аргумент буль по умолчанию который равен true но я мог бы ему имя дать если хотите но это не
нужно потому что я не использую его а зачем нам нужно что он равен час я просто придал
этому аргументу какое-то значение по умолчанию вот зачем ему вообще какое-то значение по умолчанию
придавать понятно но чтобы функции не писать да да чтобы чтобы мне не приходилось его передавать
явно туда а я правильно понимаю что мы можем тогда на самом деле не только тру написать и false
и даже в этой строчке оно не упадет но потенциально сломается дальше потому что статическое поле
какое стати чего у нас у enable if разве не статик поле у enable if вообще нет поле у него только
using есть using type равно t либо ничего сейчас тогда я перестал понимать как мы туда присвоили true
и вот этот тип если инвокабл это true то вот этот тип это в точке это он равен буль а
если инвокабл это false то это просто некорректный тип и эта перегрузка отваливается но эта версия
функции отваливается компилятор пытается подставить и понять что написано ну он пытается
расшифровать вот эту вот карказиабру чтобы понять какой тип второй у второго шаблонного
аргумента и он видит что в этом случае у второго шаблонного аргумента написано
bool равно true и компилятор говорит окей а у этого написано ничего отваливается просто объявление
и компилятор такой ну забьем тогда на это и у меня стоит только одна версия функции ладно
окей понятно раньше у него было в одном случае написано type name t type name равно что-то там а в
другом случае type name type name равно что-то другое и это не работало компилятор не может различить
две версии лишь по значениям аргумент умолчанию но тут другая ситуация тут первый аргумент
одинаковый а вот второй аргумент либо буль либо вообще некорректный тип и тогда мы просто
забиваем на эту перегрузку поэтому это работает вот так работает перегрузка с помощью enable if
значит если вы хотите в своем коде сделать какую-нибудь функцию работающий только при
условии что ваш ты это какой-то специальный тип то вы можете использовать вот такое вот
заклинание значит enable if с помощью этого же вы можете включать выключать то есть вы можете
делать перегрузку по признаку у ваш ваш тип как бы такой или другой давайте я вам покажу
страничку носить переференс посвященную на и был и фунт
в принципе там похожие примеры приведены ну давайте мы на них глянем вот
ну вот да здесь написано распространенная ошибка это вот объявить два два шаблона
функции которые отличаются только значением шаблонного аргумента по умолчанию так работать не
будет а вот так будет это именно то что мы и сделали вот ну какие еще здесь есть примеры
ну вот да например предположим вам хочется
значит вот вы делаете констракт от некоторого типа который тривили
default constructible значит смотрите как здесь написано я хочу сделать перегрузку вот
если тип тривили default constructible то я просто ничего не делаю вывожу мой тип тривиально
конструируемый я не вызываю плейс нитю а если нет ревел и вход констракт его я вызываю
плейс нитю по этому адресу но из тривили дефолта ничего делать не надо конструктор не надо тратить
время вот например или если он еще конструируемым вот а ну это уже другой пример вот что я пишу
я пишу возвращаемый тип просто вот такой я уже не использую вот этот трюк с шаблонным аргументом
вторым я просто возвращаемым тип пишу вот такое enable if из тривили default constructible t value
какой будет тип у этого у этого будет тип void потому что аргумент по умолчанию у enable if void
вот и соответственно тип этого будет либо void либо некорректный тип в противоположности
этому у этого будет либо некорректный тип либо void то есть из этих функций ровно одна будет с
корректным объявлением туда он и пойдет и это будет работать здесь вместо того правда ли это из
тривили дефолт констракт и ну вот на самом деле мы с вами почти все прайну я в общем
почти сказал то что хотел и наша ближайшая цель это научиться реализовывать вот эти все
тайп трейд и ну не прям вообще все но идеи на научиться реализовывать тайп трейд и в которых
корректность зависит от того есть ли что-то у данного типа особенно вот вот мне сегодня сейчас
надо будет уже пораньше закончить мы кстати без перерыва сегодня наверное минут через 5-10 мы
закончим на сегодня вот как компилятор соблюдает правила что он не должен рассматривать как
кандидат перегрузки данную функцию как соблю а как компилятор все остальные правила соблюдает так
и это почему тебя остальные правила не не задавали не вызывали такого вопроса ну в плане это не
особо сложно или но это просто еще одно правило выбора версии при перегрузке что тебя смущает это
них сложнее чем все то что мы обсуждали раньше для компилятора но просто какой-то трюк но при этом
его кажется поддержать ну словно настолько же легко и как бы но типа в общем я не понимаю вопроса но
ну пилятор поддерживает это несложно я разберу два примера сейчас интересно вот я хочу показать вам
мы вот эти вот штуки мы видимо начнем следующий раз реализации их наш цель научиться реализовывать
проверка наличия методов классе а также вот изнофрому в констракте был но на самом деле мы
это почти уже понимаем как реализовать там только есть некоторые нюансы которые надо
обсудить то есть все делается через вот этот декл-тайп с запятой в принципе идея уже должна
быть вам понятно вот я хочу отдельно на некоторые из этих посмотреть type traits и вот тот type traits
который мне кажется интересным это из класс а посмотрите пожалуйста
как реализовать из класс как проверить что тип является классом
в плане не структурой
нет в плане либо классом либо структурой но не интон например
так стоп какое произведение класса инт это не класс здравствуйте
нет инт это не класс класса но в целом самое время узнать да да да да да но сейчас блин миша
у тебя такие экзистенциальные вопросы то почему синтаксис и фа такой я не знаю нет ладно это
нормально в конце года у людей возникают вопросы там уровня что такое переменная иногда это
нормально но в питоне все этот класс типа а у нас плюсы нет инт это не класс а что некласс
окей прочитай это не класс базовые типы это не класса да значит смотрите как
устроено определение из класс из класс это вот такая структура которая наследник декл-тайп
от detail тест шаблонным параметром тет нал птр что это такое
тест это такая функция которая принимает либо вот это либо ничего
либо переменный 4 аргумент что это такое это указатель на член типа инт
смотрите как мы различаем класс от некласса если наш тип это класс то вот эта версия
предпочтительней но она в любом случае предпочтительней просто если тип это не
класс то это некорректный тип только у классов можно брать указатели на члены
вы понимаете уровень кринжа я не знаю уровень мы делаем перегрузку мы делаем функцию которая
принимает либо инт 2.2006 звездочка либо что угодно каких угодно типов
и пытаемся пытаемся вызвать эту версию от налp tr с шаблонным параметром t конечно же
предпочтительная эта версия в любом случае потому что принять один аргумент всегда лучше чем
принять переменный количество любых типов но только если ты это не класс то это некорректный
тип и мы отваливаемся по сфеное и попадаем в эту версию понимаете у меня есть два вопроса в целом
давай зачем у нас шаблон перед тестом который от многоточего
разве потому что потому что мы вызываем здесь явным указанием шаблонных аргументов если бы
здесь я не сделал шаблоном то это было бы ошибкой функция не шаблонная мне нужно чтобы ты я указал
явно и он попал либо сюда либо сюда но обе функции должны быть шаблонные для этого окей ладно все
понял а еще мы вызываем из union потому что у нас видимо указатель на да потому что указатель на
член можно вызвать и у union это проблема как это работает на самом деле различить класс вот
отличить класс от юниона средствами стандартного c++ мы не можем никак отличить класс от юниона это
компайлер intrinsic только компилятор может отличить то есть мы можем своими руками написать только
type trade из класс о union основу класс or struct or union вот различить класс от юниона никак написать
нельзя на c++ это компайлер компилятор в hard кожан как-то разница между то есть из union в hard
кожан в компилятор как-то мы не можем отличить но отличить класс или union от всего остального мы
можем вот таким трюком понятно я не понимаю указатель на какой член вы берете неважно на
какой раз это и дело что на никакой мы просто мы просто здесь написали некоторый тип который
является корректным типом тогда и только тогда когда t это класс или union и эта версия таким
образом предпочтительно vehicle type от этого будет стд integral constant bool ну то есть это будет это
будет true type если мы в эту версию попали эти здесь разрешается перегрузка какой тип был бы если
бы эта функция вызвалась если бы т был классом или юнионом то выбралась бы эта версия и тип
возвращаемого значения был бы integral constant вот с таким значением то есть true type таким
образом из класс это был бы наследник true type то есть в нем было бы статик using type статик он
если выбралась эта версия то мы получили false type под декл-type декл-type от этого становится
false type и значит мы наследуемся от false type таким образом и у нас таким образом есть статик
у нас был val и равно false нормально идейно понятно но смущает запись т2.2.2 звездочки ну ладно я
так блин а вы все это время видели cpp референс блин а я то показывал это на примере господи я
думал вы видите я это вимск и пастом ладно ну ладно ладно не важно последнее самое что
покажу это вот такой еще мне очень нравится пример ну из function тоже в принципе понятно
ну может быть на нее мы потом посмотрим вот еще мне нравится type-trade из polymorphic отгадайте
как реализовать из polymorphic просто отгадайте как отличить polymorphic от неполиморфного проверить
работает ли на нем dynamic cast конечно смотрите за что помнить бы что такое polymorphic это тип
который у которого есть хотя бы одна виртуальная функция так сейчас вообще не видите как экран да
никакой именно так это тоже неплохо значит давайте последний стяжение значит вот
из polymorphic ну это скопи пастил cpp референс опять смотрите detail detect из polymorphic t от
нал птр а что здесь написано а тут две функции detect из polymorphic от вот такого вот и от чего
угодно другого чего значит по умолчанию конечно же эта функция такая она без тела обратите
внимание вот это функции это объявление функций обычных функций это функция у которой возвращаемый
тип true type название detect из polymorphic и принимаемый тип вот такой принимаемый тип decal type от
dynamic cast к const volatile void звездочки от статика ct звездочки от нал ptr мы ее вызвали с явным указанием
шаблон руменко t и компилятор видя что это функция одного аргумента пытается выбрать ее понимая что
она предпочтительней чтобы не идти сюда и он пытается распарсить какой же это тип то decal type
от вот этого вот вот всего нал ptr статика ct звездочки ok а вот дальше dynamic cast const volatile void
звездочки зачем нужно const volatile чтобы если случайно табл с const или с volatile мы не отловалились
по причине нарушения квалификаторов вот но dynamic cast сработает от т звездочки к void звездочки
только если это было полиморфным типом и значит это корректное выражение лишь когда t это
полиморфный тип и decal type от него ну это какой-то тип это const volatile void звездочки неважно какой
он важно что это корректный тип и он предпочтительнее чем функция переменного количества аргумента а если
бы dynamic cast был некорректным не компилируем выражение потому что не полиморфный компилятор бы
ничего не оставалось как пойти сюда но у этой функции возвращаемый тип true type а у этой функции
возвращаемый тип false type функции нереализованные они не имеют тела но мы их и не вызываем поэтому
потому что мы на самом деле не вызываем их мы только тип смотрим что они возвращают и из полиморфика
наследник decal type от вот этого вот выражения которые либо false type либо true type смотря каким был
t а dynamic cast компилируется вообще к чему угодно что ли нет ну лига базе ну и квад звездочки тоже
можно dynamic cast ну вот непонятно почему квад звездочки вообще можно ну по стандарту можно что кажется
квад звездочки просто можно все да но динамик кастом можно только я ну это опять касты то есть
динамик каст квад звездочки просто закастылин компилятором отдельно да ну да но он компилируется
только если это был полиморфный тип понятно просто странно что для полиморфов все равно можно
квад звездочки это как-то не очень понятно вот так вот такие вот такие вот приколы ну давайте
на этом закончим потому что мне на самом деле надо бежать уже сегодня вот и значит все пока что
следующий раз мы быстренько поговорим о том как реализовать из констракт и был с конверти был
из ноуфро му в констракте было прочее а еще нам предстоит реализовать такую интересную штуку как
из бейзов вот а после этого мы уже поговорим про концепты и про современное метапрограммирование
новомодные все плюс плюс 20 вот
