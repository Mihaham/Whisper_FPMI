Мы начинаем. И как обычно, мы начинаем с повторения того, что мы успели сделать за последние месяцы.
Чего же мы добились? Напомню, что первую задачу, которую мы решали, это была задача репликации ячейки памяти.
И мы придумали для нее алгоритм с хворовым, с фазовым, который вы сейчас уже...
Кто-то из вас уже написал, кто-то напишет в ближайшие дни.
И потом мы довольно быстро выяснили, что этот алгоритм плохо обобщается на более сложной операции,
потому что в нем есть два несогласованных порядка.
Порядок доставки команд на каждую реплику и логический порядок на временных метках,
которые этот алгоритм сам выстраивает.
И чтобы эту проблему побороть, мы придумали примитив, который назывался Atomic Broadcast.
Atomic Broadcast позволял узлам отправлять свои сообщения сразу всем,
и этот примитив гарантировал, что это будет неправильно.
И мы этот примитив использовали для того, чтобы реплицировать произвольный автомат.
Мы сказали, что пусть у нас есть некоторые черные ящики,
пусть он умеет принимать и применять к себе какие-то команды,
мы поставим этот черный ящик, когда стоит машина, на каждой реплике.
И когда клиент будет приходить нам с операцией, мы его операцией,
его операцией мы будем использовать.
То есть мы будем использовать этот примитив для того,
чтобы у нас не было никаких проблем.
И когда клиент будет приходить нам с операцией,
мы его операцию будем Broadcast через этот самый Atomic Broadcast
и применять на каждой реплике эти команды в порядке их доставки,
в порядке вызова обработчиков Atomic Broadcast.
То есть первое достижение наше – это сведение задачи репликации автомата
к задаче построения Atomic Broadcast.
То есть после этого перехода мы уже про линейризацию
непосредственно не говорим.
Если мы умеем строить Atomic Broadcast,
то мы умеем линейризуемо реплицировать произвольное состояние,
которое умещается, конечно, в одну машину.
Да, мы там упустили какие-то детали, да, мы сказали,
что нам нужна семантика экзеклюанса для клиента,
то есть сам клиент должен участвовать в реализации нашей стрит-машины.
Кроме того, нам нужно подумать о транзакциях,
потому что может быть состояние у нас большое
и в одну машину не помещается.
Это все отдельные нюансы, которые мы обсудим в будущем,
или которые вы сами придумаете, как делать.
А пока мы фокусируем свое усилие на Atomic Broadcast.
Ну и в позапрошлый раз мы даже на этом не остановились.
Мы сказали, что задача все еще слишком сложная,
и можно свести ее, в свою очередь, к задаче Consensus.
Задача, где узлы должны договориться об общем выборе.
В отличие от Atomic Broadcast, эта задача более удобная для решения,
потому что здесь какие-то сообщения бесконечно отправляются и доставляются,
а здесь мы должны всего лишь один раз выбрать общее значение,
алгоритм завершается, вот и все.
Ну и в прошлый раз мы обсудили то, что эти задачи на самом деле
эквивалентные по сложности,
и вот решая Broadcast, мы вынуждены решать Consensus,
поэтому в прошлый раз мы обсуждали,
какие же ограничения задачи Consensus заложены,
потому что они влияют на эти сведения выше.
Мы выяснили два ограничения.
Во-первых, более-менее очевидное ограничение,
что никакой алгоритм Consensus не может переживать слишком большое количество сбоев.
Ну вот такая оценка у нас уже была для алгоритма репликации регистра
на второй лекции, и такая же оценка будет справедлива
для любого решения задачи Consensus.
Напомню чуть точнее, это означало, что если алгоритм Consensus
хочет гарантировать agreement, то есть safety свойства,
что он всегда, если выбирает значение, то выбирает общее значение,
выбирает одно и то же значение на всех узлах,
то алгоритм обязан не завершаться, когда сбоев слишком много.
Ну или в случае partition в меньшей части.
То есть в любом разбиении множества узлов в меньшей части partition
алгоритм должен зависать.
Иначе он нарушит agreement в случае этого самого partition,
а в свою очередь так по каскаду на уровне broadcast мы нарушим total order,
а на уровне RSM у нас разойдутся реплики.
Так что у нас есть такое ограничение на termination.
Первое ограничение на termination, которое у нас было,
когда сбоев слишком много, алгоритм блокируется.
Второе ограничение было более замысловатым,
и у него было имя FLP-ти аремы.
Напомню было о том, что в асинхронной системе с отказами узлов
и с детерминированным алгоритмом мы не можем гарантировать
завершение алгоритма consensus в любом исполнении.
То есть существует исполнение, в котором алгоритм не завершается,
ну или иначе существует lifelog.
И этот lifelog мотивировал для нас переход к более сложной модели,
в смысле переход от асинхронной модели к частичной синхронной,
потому что в асинхронной мы можем гарантировать только safety свойства,
то есть agreement, но нам необходимо предположение о времени,
чтобы гарантировать liveness свойства consensus, то есть termination.
И на этом мы в прошлый раз разговор о consensus закончили.
Мы выяснили, что задача не очень хорошо решается,
но, как я уже вам показывал во время одной лекции, нам все-таки
необходимо consensus решать, потому что мы собираемся строить RSM,
но и люди уже строят свои промышленные системы с помощью этих RSM.
Я говорил вам про Yandex DB, где все RSM буквально,
ну или приводил пример, кажется, систему ZooKeeper,
которая является таким изолированным RSM,
с помощью которого вы можете строить другие распределенные системы.
В другом курсе мы еще про ZooKeeper подробно поговорим,
пока достаточно такого вот поверхностного приближения.
Так что consensus мы решать, конечно же, будем, несмотря на есть ограничения,
но нам по пути решения нужно учитывать, как вот и эта теорема,
как они себя проявят в нашем алгоритме.
В прошлый раз мы вроде бы уже это немного обсудили,
мы сказали, что вот достичь, учесть вот такую теорему довольно легко.
Если алгоритм должен блокироваться в меньшей части partition,
то он, видимо, просто кворумы собирает и блокируется,
когда сбоев слишком много или когда большинство узлов недостижимы.
А с FLP, ну видимо, мы должны в каждом алгоритме consensus,
который у нас будет, искать LifeLog.
Вот если он найдется, то значит мы не нарушаем FLP теорему,
что довольно разумно.
Наша задача на сегодня решить задачу consensus.
Не то чтобы мы ее решим, в смысле не мы ее решим,
ее уже решили другие люди, и решение это не очень простое, не очень очевидное,
и наша задача сегодня с ним разобраться.
Мы рассмотрим, наверное, как сказать,
я не уверен, что это вот именно первое на свете решение задачи consensus,
но это кажется первым алгоритмом, который ее вот так в изоляции решает во синхронной модели.
И у этого алгоритма есть собственно имя, разумеется, это имя Paxos.
Так мы его включим сейчас в проектор.
Сейчас ты все увидишь.
Наша задача сегодня разобраться с алгоритмом Paxos,
но прежде чем переходить к алгоритму, к его изложению и к доказательству его корректности,
мы обсудим историю его появления, потому что это настолько странная, удивительная история,
что невозможно ее обойти стороной.
И вот тут мы очень быстро включим проектор, смотри, просто увеличив яркость, это же волшебство.
Но чтобы нам это не мешало, нужно стереть.
На самом деле алгоритм Paxos решает не задачу consensus, он решает сразу atomic broadcast.
И берет он начало в 1990 году, когда Лэмпорт, Лэстли Лэмпорт,
человек с аватарки нашего чата, написал статью под названием part-time parliament.
Тут написано правда 98-й, но мы сейчас раскроем эти детали.
Итак, вообще не так уж много статей с такой затейливой, любопытной судьбой на свете есть.
У нас будет в конце семестра, где-то ближе к декабрю блокчейны, и статья про биткоин,
и вот она тоже довольно особенно, довольно странная, не вписывается в контекст всех остальных академических статей.
Но Лэстли Лэмпорта ей далеко, скажем прямо.
Лэстли Лэмпорт пишет статью про парламент, про греческий парламент.
Он пишет, что вот недавно археологи обнаружили на руинах острого пакса следы древней цивилизации,
и вот Лэмпорт как археолог изучает жизнь этих самых древних греков.
Лэстли Лэмпорт пишет, что когда-то давно островом Паксос управлял Совет священников,
но со временем Паксос превратился в крупный центр торговли,
и в связи с этим потребовалась какая-то организация политической формы управления,
и вот этот теократический режим сменился парламентом, которому посвящена вся статья.
Парламент регулировал торговые отношения между жителями острова.
Парламент должен был принимать законы, то есть его функция была в том, чтобы составлять свод законов.
Законы были такие, например, что устанавливался налог на оливки.
Или были какие-то более сложные законы, например, закон, который запрещал продавать чёрных козлов.
В общем, странные были законы, ну или разрешал продавать коричневых.
Парламент этого греческого острова занимался тем, что принимал такие вот законы.
И ясно, что если вы меняете цену на оливки или налоги на оливки,
или то запрещаете, то разрешаете продавать каких-то козлов, то вам нужно эти законы
применить в некотором порядке, чтобы понять, в каком состоянии книг законов сейчас.
Что можно было бы сделать? Можно было бы нанять секретаря,
который занимался бы тем, что фиксировал порядок этих законов,
принять этих законов, но здесь они называются указами, decrease.
Но беда была в том, что все жители острова были очень заняты своей основной деятельностью,
а именно торговлей, и никто не хотел избираться секретарём и посвящать всю свою жизнь парламенту.
Поэтому и без секретаря, который бы выписывал все законы в некотором порядке,
работу парламента довольно сложно организовать.
Поэтому каждый участник этого парламента, они назывались выборщики,
должен был вести свои собственные записи, в каком порядке все эти указы, законы принимаются.
Вот тут приводится выдержка из записей какого-то выборщика вот с таким вот именем.
То есть 155-й закон, который был принят, вот выглядел таким образом.
Но, конечно, жизни выборщиков была непроста. Во-первых, они могли уходить и приходить,
поэтому парламент вот так и назывался, статья так и назывался.
Во-вторых, тут уже очень странные обстоятельства вмешиваются.
Лэм пишет, что сама комната, вот зал для заседаний парламента был довольно плохо устроен,
там была плохая акустика, поэтому выборщики не могли общаться друг с другом,
точнее они не могли общаться сразу со всеми другими выборщиками,
не могли забраться на какой-то трибун и там выступать.
Вместо этого у них были гонцы.
Вот можно было найти гонца, дать ему какое-то сообщение, и он его понёс другому выборщику.
Но, правда, Лэм пишет, что вот выборщик мог покинуть зал заседаний,
и уехать куда-то на 6 месяцев, потом вернуться.
Или он никогда не вернулся, потому что мало ли что в древности могло произойти с ним.
Да, конечно же, выборщик мог покидать парламент в любое время, но он там оставлял все свои записи.
Если он возвращался, то его записи оставались на месте.
У каждого выборщика были собственные песочные часы, с помощью которого он мог отслеживать хоть времени.
Ну, в общем, наверное, понятно, что в чему.
Да и сам Лэм не скрывает, он говорит, что задача функционирования этого парламента
имеет удивительное сходство с техными задачами, которые возникают
в области отказоустойчивых распределённых систем, что неудивительно.
Легко здесь всё сопоставить. Что такое книга законов?
Книга законов – это то состояние, которое мы хотим надёжно поддерживать.
Что такое свод законов?
Порядок записей принимаемых указов, пронумерованный вот такими числами.
Это буквально порядок, который выстраивает Atomic Broadcast между репликами.
Кто такие выборщики? Ну, это, видимо, сами реплики, которые должны в этом порядке договориться.
У каждого выборщика есть свой жёсткий диск, то есть вот эта табличка, на которой он делает записи,
есть собственные часы, ну и выборщики между собой не могут общаться напрямую,
они могут только посылать вот такие вот странные сообщения через гонцов.
Но то, что гонец может уехать на 6 месяцев, это означает то, что, видимо,
модель, в которой мы работаем, асинхронная, то есть мы не делаем предположение
о скорости доставки сообщений.
Можно подумать, как вообще так получилось, что такая статья была написана?
Довольно странно, не характерно для статей академических.
Дело в том, что Лэмпард вот так уже делал.
Он вот эту статью написал в 90-м году, а в, кажется, начале или середине 80-х
написал статью, которая называлась «Задача византийских генералов».
И там тоже была какая-то квазисторическая история, такой сеттинг.
Была византийская армия, она осаждала вражеский город,
и эта армия была поделена на какие-то подразделения.
И каждым подразделением руководил собственный генерал.
И вот генералы должны были договориться друг с другом об атаке или об отступлении.
И должны были договориться об одном действии, потому что если атакуют не все,
то наступление провалится, и армия погибнет.
Беда была в том, что среди генералов были предатели, которые могли саботировать протокол
и действовать независимо от остальных.
И задача состояла в том, чтобы все честные генералы договорились либо об атаке,
либо об отступлении, независимо от того, что делают предатели.
Легко понять, что это задача бинарного консенсуса, про который мы говорили в прошлый раз,
и это задача про византийскую модель отказов, когда у нас узлы могут протокол нарушать.
Но почему византийская модель отказов?
Потому что Лэмпорт написал статью про византийских генералов.
Термин прижился, и мы им пользуемся до сих пор, как можно заметить.
Что же было с греками?
С греками получилось чуть интереснее.
И удивительным образом, вся эта история описана самим Лэмпортом,
потому что у Лэмпорта есть сайт, и в нем каждой статьей есть еще и заметки самого Лэмпорта
про то, как он эти статьи писал.
В общем, тоже не каждый так делает, наверное.
Так вот, Лэмпорт написал эту статью и в 90-м году отправил ее на конференцию TOX.
Это такая очень крупная конференция по теоретическому компьютеру science.
На что ему там ответили?
Что статья умеренно интересная, но кажется, она не очень полезна.
А греков оттуда вообще лучше убрать.
Ну, тут смотрите, какая история.
Убрать греков, кажется, для Лэмпорта был вообще один вариант.
Он написал, что он был раздражен, что никто не оценил его чувство юмора
и отказался что-либо в статье переделывать.
Тут нужен некоторый экскурс в Wesley Lamport, потому что человек совершенно неординарный
со своим особенным чувством юмора.
Например, это лекция Wesley Lamport про язык TLA, про который мы будем еще говорить.
Вот он там рассказывает о том, кто он такой.
Ну и тут видео интересное.
Он то в одном образе, то в другом образе.
Вот есть такой образ.
В общем, греков изъятия статьи было совершенно невозможно.
Кроме того, Лэмпорта не просто про греков написал.
Он сделал чуть интереснее.
Во-первых, он в свою статью встроил еще некоторые имена.
Вот это некоторые имя некоторого выборщика.
Но имена здесь есть интересные.
Давайте я покажу какое-нибудь из них.
Можно найти.
Вот так.
Смотрите, имя некоторого сырного инспектора.
Что-то напоминает.
Кто-то не поленился и на stack exchange, посвященном теорическому компьютеру science,
создал вопрос, а кто все эти люди?
Вот явно, что в статье есть какие-то имена, и нужно разобраться.
И кто-то не поленился, выписал все имена и нашел всех этих людей.
Это оказались коллеги Лэмпорта.
Тут есть ту, которая статью про фейл-детектора написала.
Нэнси Рич, это одна из авторов FLP.
Ну в общем, да экстра, понятно.
В общем, там были эти странные греки.
Ну и даже это еще не все.
Сейчас я найду.
Статья изобилует определенными мемами.
Сейчас мне нужно аккуратно найти еще один.
Ох, секундочку.
Ну вот, смотрите.
Тут в статье есть разные термины.
Вот есть греческие термины.
Ну как они...
Что значит греческие термины?
Это термины, написанные греческими буквами.
Я не уверен, что это греческое слово.
Я очень уверен, что это как бы нет.
Ну вот, возьмите мю-эм.
Вот это что за буква?
Вот это ма уже получалось.
Ну вот, и так можно продолжить.
Вот это ма.
А вот это ма.
Ну вот, это ма.
Это ма.
Ну, это ма.
Ну вот, это ма.
Это ма.
Ну вот, и так можно продолжить.
Ну вот это что за буква?
О, отлично. У нас есть О.
Ну короче, вот нужно это слово прочесть.
Да, это majority set.
Ну и дальше лэмпорт.
Он описывает протокол, который был у древних греков.
Поэтому там и термины, соответственно,
довольно раритетные.
Короче,
лэмпорт совершенно точно был
ненаверен стать что-то исправлять.
Эти грек.
Вот, по поводу того, что алгоритм кажется
не очень важен.
Я вам рассказывал про систему Google Spanner.
Мы про нее говорили в контексте
True Time.
Ну и я говорил, что это просто такая большая
геораспределенная база данных.
Кажется, задачи вполне полезные.
Вот, и это, наверное, самая большая база данных,
которая в мире существует.
И если вы там поищете слово Paxos,
то окажется, что алгоритм использует Paxos
для репликации внутри каждого шарда.
То есть это такой кирпичик,
на котором все системы держатся.
Вот, поэтому
можно сказать, что ревьюры в 90-м году
были не совсем правы.
Ну и
отдельно порекомендую.
Есть книжка, которую написал тоже Google,
сайт Real Business Engineering. И там есть целая глава,
посвященная тому,
как управлять системами,
строить системы, которые основаны
на консенсусе. Мы про это поговорим еще.
Вот там как раз тоже используется Paxos
как основной пример алгоритма консенсуса.
Ну что ж.
На конференции
Лэмпорта не оценили.
Лэмпорта горчился, но он еще и
коллегам свою статью показывал.
Отправил,
в частности, Нэнти Лич другим своим товарищам.
Им статья понравилась, конечно же.
А потом он их отдельно спросил, а вот понимаете ли
вы, коллеги, как написать базу данных,
которая бы не теряла
согласованности при любом количестве отказов
и при этом бы функционировала,
обслуживала пользователей, когда отказов меньше
половины.
И, к сожалению, он пишет, что никто
из моих коллег не увидел никакой связи между моим вопросом
и статьей про Paxos,
что тоже Лэмпорта горчила.
Ну, как горчила.
Но он уперся и не стал ничего
менять. И статью не опубликовали в 1990 году.
Хотя Лэмпорта пишет, что
какие-то коллеги все-таки понимали ее ценность,
понимали о чем она на самом деле.
Но так вот продвинулась история
до 1998 года.
И все-таки в 1998
году статья все-таки попала.
Конференцию
была опубликована
спустя 8 лет.
И Лэмпорт попросил
по этому поводу вставить в статью
вот такое небольшое замечание, что
эта статья
была найдена где-то в пыльном углу
кабинета
редакторов этой конференции.
И наконец-то ее
сочли достойно
до републикации.
Но, к сожалению, автор сейчас находится
где-то на раскопках
Древней Греции и сейчас не доступен,
поэтому мы опубликуем статью с его согласия.
Статью все-таки опубликовали
к счастью до Лэмпорта, но
это ничего сильно не поменяло,
потому что сам Лэмпорт пишет,
что никто особо не обратил
на нее внимания.
И он жалуется, что люди
запоминали больше частью Древних Греков
и то, как он выступает на конференциях
в костюме Индиана Джонса, а почему-то не алгоритмом
Факса, который там был изложен.
Вот Лэмпорт огорчался,
и он
пишет, что
ему было
обидно,
потому что алгоритм очень простой.
И в какой-то момент он
пишет, что он был на какой-то конференции
и объяснил кому-то из своих коллег
усно этот алгоритм
без этой статьи.
И в конце концов не выдержал, пришел домой
и за вечер написал такое
маленькое короткое изложение,
уже не всего протокола Атомик Бродкаста,
который был в статье про Греков,
а вот решение задачи консенсов
в изоляции.
И получилась статья на 13 страниц,
в которой, как он пишет, не было формулы
сложнее, чем N1 и больше, чем N2.
В общем, абсолютно справедливое
замечание. И эта статья
называется Paxus, my simple,
Paxus с простыми словами.
У нее тоже довольно интересный
абстракт. Тут написано, что
алгоритм Paxus, если он изложен на английском,
очень прост, на самом деле.
И Лэмпорт пишет, что
статья первая оказалась
слишком греческой
для многих читателей, поэтому
он переписал на английском.
И он пишет алгоритм очень прост, и практически
неизбежно следует из каких-то свойств
самой задачи консенсов.
То есть ничего проще быть не может на свете.
Но вот не все с ним согласны.
Чуть позже у нас будет другой алгоритм консенсуса,
вернее, другой алгоритм, который занимается
Atomic Broadcast, ну или
чуть точнее реплицирует
LogCommand для RSM.
Он называется
Raft. И статья, посвященная алгоритму
Raft, у нее тоже любопытное название, называется
В поисках понятного алгоритма консенсуса.
Это такая шпилька в сторону
Paxus, потому что авторы пишут, что
то, что они придумали,
это результат, который
не делает ничего нового. Мы получили
результат эквивалентный
алгоритму Paxus.
Вот не каждый так статьи начинают.
Но
почему эта статья была написана?
Потому что,
как пишут авторы этой статьи,
алгоритм Paxus довольно труден для понимания,
несмотря на многие попытки все-таки сделать его
доступным.
И после того, как
авторы этого алгоритма Raft
испытали трудности с Paxus
сами, они написали свою статью.
Правы они или нет, мы узнаем чуть
позже. У вас будет возможность
самостоятельно оценить утверждение,
потому что мы и то, и другое напишем.
Но вообще-то алгоритм Paxus занимает
вот столько места. Это его псевдокод.
Вот 20 строчек.
Не то чтобы он сложен,
понять его несложно.
Что именно
имеют в виду авторы Raft?
Видимо, немного другое. Они говорят о том, что
Paxus, наверное, не интуитивен.
И вот сегодня, я надеюсь, вам это
предемонстрирую.
Его, к сожалению, трудно объяснить актоинкрементально,
как мы делали с регистром. Мы там брали
три реплики, давайте напишем на все,
соберем кворум, прочитаем со всех,
соберем кворум, пересеклось, здорово.
Потом ошибка нашлась, поправим.
Другая проблема, и поправим.
Актоинкрементально можно выстроить, делая простые шаги.
С Paxus такого не получится.
Почему не получится, мы сегодня, наверное,
увидим, ну или в следующий раз точно
увидим. А вот Raft претендует
на то, чтобы...
Raft претендует на понятность,
на то, что он интуитивен.
Там есть какая-то декомпозиция,
где части,
по утверждению авторов
Raft независимы друг от друга.
Я попытаюсь вас убедить, что это не так,
но это потребует некоторое время.
С одной стороны, есть такая сложность
Paxus, то есть
в нем нет какой-то простой интуиции.
А другая сложность, она действительно
в статье про Paxus,
потому что она наполовину про греков,
а вторая половина
сложности этой статьи в том,
что там, где
Лэмпард пишет не по-гречески, а по-английски,
он почему-то начинает
суперформально рассуждать.
То есть он пишет...
Он доказывает простые вещи, очень фантастические.
Он доказывает простые вещи, очень формально.
И читать это...
Ты застреваешь, когда читаешь.
Почему он так делал?
Потому что
у него был свой собственный интерес,
он занимался формальной спецификацией, верификацией
и разрабатывал язык, который называется
телеплюс для того, чтобы формально описывать
как работают алгоритмы.
Мы про это тоже поговорим.
В общем, Лэмпард, с одной стороны, был суперформально,
с другой стороны, писал какие-то мемы про греков.
И из-за этого
статью читать трудно, конечно же.
Но это такая сложность преодолимая.
И...
Что я могу порекомендовать?
На самом деле я вам статью рекомендую, но не сразу.
Если вы изучаете распределенные системы
и вы хотите погрузиться в задачу консенсуса,
то начинать статьи, конечно,
не стоит.
Стоит начинать с RAFTA.
Есть статья на 18 страниц
про RAFTA, относительно
небольшая.
И кроме того, в RAFTA
вместе с этой статьей написано PHD.
PHD
она уже занимает 250 страниц,
260 почти что.
И в ней, помимо изложения алгоритма,
есть буквально все детали
устройства RSM в продакшене.
Буквально учебник.
И там есть отдельная глава, скажем,
про...
Почему я не могу перейти?
Про протокол клиента. То есть как сделать
exactly once в RSM.
Про переконфигурация.
Мы говорим про задачах,
где зафиксированы 5 узлов
или 3 узла. И их состав не меняется,
даже если они умирают.
В реальности, конечно, нужно
заменять сбоенные узлы на новые.
Нужно как-то переконфигурировать состав кластера.
Это меняет кворумы.
И нужно делать это аккуратно.
В PHD описывается и эта проблема,
и многие другие.
Так вот,
если вы прочтете статью про RAFTA
и посмотрите на это PHD,
а потом вернетесь в 90-й год
и будете читать статью Лэмпорта,
то окажется, что
Лэмпорт многие вещи там
описал.
Опять как-то совершенно шутливо через каких-то сынных инспекторов
и солнечные часы.
То есть он тогда все это понимал,
но оценить из того времени
это было невозможно.
И Лэмпорт особо не стремился
к тому, чтобы его оценили.
Ну вот.
Короче,
сложная история.
Да, еще две забавные детали.
С одной стороны,
это статья формальная,
а статья про UPAXUS Made Simple
она, наоборот,
очень простая и написана
буквально по-английски,
бытовым языком.
Чем это обернулось?
Довольно странная история, в свою очередь.
Лэмпорт пишет, что в 2015 году,
ну вот, короче, проще показать.
На статике overflow появился вопрос.
Человек читает статью Лэмпорта
про UPAXUS Made Simple и говорит, там есть какая-то ошибка вроде.
Ну и приходит другой человек,
который разбирается в этом инженере Amazon
и помогает
автор вопроса разобраться,
что на самом деле просто в статье Лэмпорта
UPAXUS Made Simple есть
предложение, написанное на английском языке,
которое можно интерпретировать
неоднозначно.
И вот в одной интерпретации мы получаем, что алгоритм
не правильный, а другой правильный.
Ну, разумеется, ошибки у Лэмпорта нет,
просто вот такое,
два способа прочесть одно и то же.
Поэтому что про это говорит Лэмпорт?
Во-первых, я не собираюсь эту ошибку исправлять в статье,
ну кто знает почему.
Нет, понятно почему. Он говорит, что вот просто
не читайте эту статью.
Вот ровно поэтому я ошибку там исправлять не буду.
Вот читайте статью про парламент, там все четко,
там ошибки нет, там неоднозначности нет.
В общем, статья со сложной судьбой,
вряд ли кто-то ее сможет повторить когда-либо.
Но мы
сегодня хотим
с этой статьей разобраться. Ну, вернее,
в статье описывается протокол работы парламента.
Протокол работы парламента
из следующей лекции наша.
Сегодня мы хотим разобраться в протоколе,
именно
которую описывает Лэмпорт в этой статье,
которая решает задачу консенсуса
в изоляции.
Это протокол, который называется Single Decree Paxos,
то есть Paxos одного указа.
То есть задача о том, чтобы договориться
о очередном указе, решить задачу консенсуса.
Ну и можно наконец
переходить
к нашему основному содержанию.
Ой, забыл еще одну шутку.
Ну как же так? Там
слишком много всего. В общем,
статья называется Paxos Made Simple,
и это положило
в целую очередь мемов, потому что статьи
стали называть так и дальше.
То есть у нас будет
лекция по статье, которая называется Paxos
Made Live.
И
была статья, которая называется
Paxos Made Moderately Complex.
Ну,
в общем, целая история
с этим Paxos.
Но, возможно,
это не самая полезная вещь для нас.
Мы хотим все-таки строить
алгоритмы. Мы хотим решать задачу консенсуса.
Напомню, что
задача консенсуса состоит в следующем.
У нас есть
n узлов, у каждого узла есть
свой собственный вход,
и каждый узел должен реализовать
процедуру
Propose,
который подается на вход этот input,
и который
выбирает некоторое общее значение.
Мы хотим свойства
валидить, то есть выбирается одно из
предложенных значений, выдумывать их
нельзя.
Если два узла делают выбор,
то они делают одинаковый выбор,
и алгоритм,
по возможности, должен завершаться.
Мы выяснили эту задачу.
Эта свойство не всегда достигается.
Мы сегодня говорим про
конкретный алгоритм, который решает эту задачу.
Он называется Single Decree Paxos.
И не так-то просто его рассказать.
Я уже говорил, что у него нет
начала и конца, его можно рассказать только
целиком.
Вот я сейчас это собираюсь сделать,
а потом мы будем его изучать.
Но прежде, чем я
нарисую картинки, как он работает,
как он устроен, нужна какая-то интуиция
все же.
В задаче консенсуса у нас есть
отдельные узлы, у них есть значение.
В алгоритме Single Decree Paxos
на этих узлах выделяются роли.
Именно две роли.
Роль Proposer
и роль Acceptor.
Каждый узел в алгоритме Paxos
является и пропозером, и аксептором.
Proposer предлагает значение,
а в Paxos есть и пропозер,
и аксептор.
Proposer предлагает значение.
То есть это активная часть алгоритма,
именно пропозер выполняет процедуру
Propose, у него есть входное значение.
Аксептор голосует
за значение
или чуть точнее за предложение,
которое выдвигают пропозер.
Аксептор
может голосовать за одно
предложение,
он не обязан сохранять
свою выбранную вещь,
он может его поменять.
Сами предложения это не просто значение,
это пары.
То есть если пропозер предлагает какое-то
предложение, то он берет значение
и добавляет к нему
то, что называется Proposal
или Bellet Number.
Пропозеры выбирают для своих
предложений разные n,
глобально разные.
Эти n должны быть упорядочены,
но они не обязаны
выбираться монотонно.
Каждый пропозер будет выбирать их
монотонно, то есть каждый пропозер
будет набирать свои предложения
растущими n.
Но некую монотонность
не глобально не требует.
Если пропозер
выбирает н,
но некой монотонности глобально не требуется.
Главное, чтобы
для разных пропозеров, для разных
предложений эти n были уникальными.
Ну и
можно, наверное, сразу считать, что вот эти
n будут выглядеть так.
Это некоторое число k
и ID
данного пропозера,
чтобы они могли различаться.
Вообще говоря, алгоритм, который мы строим,
не требует, чтобы
пропозеры и аксепторы были
разными и теми же узлами.
Вот в нашем алгоритме пропозеров
может быть сколько угодно, значение может быть
сколько угодно, а аксептора будет
зафиксированное число. 3, 5 и так далее.
Вот именно от аксептора
будет зависеть отказа устойчивости.
В задаче консенсуса,
если мы смотрим на нее в изоляции,
пропозер и аксептор это просто каждый отдельный узел,
но если мы переносимся на уровень
выше, на уровень Atomic Broadcast,
на уровень RSM, а там уже это разделение может быть
полезным по
всем причинам.
И как
коммуникация между этими
ролями устроена?
Во-первых, пропозеры
общаются только с аксепторами.
Они не общаются друг с другом, и аксепторы вообще ни с кем
с ними не общаются, они пассивные.
Они только отвечают на команды пропозеров.
Что могли бы делать пропозеры?
Пропозеры предлагают свои значения,
делают предложения такие аксепторам.
Но пропозеров несколько,
они конкурируют друг с другом.
Так что вот
непонятно, как же аксепторам
скоординироваться, как им сделать общий выбор,
как им проголосовать за одно и то же предложение.
Для этого
пропозер,
это очень такое неформальное
объяснение, но все же я им
воспользуюсь, пропозер как будто
бы берет на аксепторы блокировки.
Вот если он хочет предложить
что-то всем, то он сначала
лочит каждого аксептора
так условно очень,
и когда он собирает локи
с них, то после этого он говорит
вот принимайте мое предложение.
Но что может случиться?
Понятно, что только один аксептор
может собрать слишком много локов,
кворум из локов, так что вот
два аксептора не смогут так сделать вместе.
Но с другой стороны, даже если мы примем
такую интуицию, то уже непонятно, что такое
распределенная блокировка, потому что
что такое мьютекс локальный мы понимаем,
а что такое мьютекс, у которого может умереть
владелец пропозера, мы уже не понимаем.
Ну, точнее, должны не понимать.
Это некоторая проблема.
Поэтому это конечно
не буквально блокировки, это такие
блокировки, которые можно отбирать
у других.
Вот чуть позже мы увидим,
что в распределенных
системах не локи используются,
а используется понятие
лизы.
Если вы читали статью про GFS, там это слово было,
и мы спустя некоторое время
про это подробно поговорим.
Ну, а пока можно считать, что мы берем такие,
что пропозеры берут некоторые блокировки,
но если пропозер умирает,
или даже если не умирает, другой пропозер
может эту блокировку перехватить у него.
Ничего это не объясняет, но
по крайней мере это поможет мне сейчас
картинку рисовать.
Я сейчас
нарисую одного пропозера
и
пусть трех аксепторов.
И опишу, как коммуникация между ними устроена.
Вот буквально я сейчас нарисую
алгоритм пропоуз.
Вот его.
То есть пропозер
реализует свой пропоуз
со значением v.
Как он устроен?
Он устроен в две фазы. Сначала нужно
захватить внимание аксептора,
взять на них блокировку условную,
а потом сделать предложение.
Первым делом
пропозер выбирает
некоторое n,
а затем пропор.
Вот выбрал.
После чего
начинает свою первую фазу.
Отправляет на аксепторы
специальное сообщение, которое называется prepare.
С единственным аргументом вот эта самая n.
Вот эти сообщения реагируют аксепторы.
У каждого аксептора есть состояние.
Во-первых, каждый аксептор хранит
значение np.
np — это максимальный n,
который этот аксептор
получал от пропозеров.
Просто максимальный n, который он видел.
И если аксептор
получает prepare с n
меньше, чем np,
который у него уже есть,
то аксептор говорит, что
prepare отвергается, потому что
n слишком маленький.
Он может ответить явно,
может вообще ничего не отвечать.
Но лучше ответить явно, что отказываем.
Если же
аксептор видит, что этот n
больше, чем его np,
то аксептор
обновляет свое np
и отвечает
пропозеру
сообщением
promise.
Почему promise, во-первых?
Потому что мы, обновляя np,
обещаем, что мы
аксептор, обещаем пропозеру,
потому что мы больше не будем принимать
сообщения от команды
от других пропозеров
с номерами меньше, чем этот n.
Поэтому promise.
А, во-вторых, мы к этому
promise прикладываем
пару nava.
Это вторая часть состояния аксептора.
Это текущий,
отданный аксептором голос.
Его vote.
У каждого аксептора
есть какой-то голос,
есть предложение,
за которое он уже проголосовал.
Аксептор может поменять свой выбор в будущем,
но пока он такой.
Голос аксептора
сам по себе пока ничего не означает.
Это просто такое-то локальное решение.
И мы отправляем этот голос
отданный.
Мы, а первый,
отправляем пропозеру
наш текущий голос.
Что делает пропозер
с этими голосами, с этими ответами?
Он дожидается, пока соберет кворум.
Это фаза 1.
Фаза prepare.
Когда набрался кворум,
пропозер смотрит на значение, которое он получил
в промесах, на вот эти голоса.
Задача пропозера
сейчас выбрать значение,
которое он
будет предлагать аксепторам.
Вот на этой фазе
никаких значений, никаких v,
пропозер никак не использовал свое собственное v.
Он собрал
кворум preparов, он как будто бы
взял блокировку на большинстве аксепторов
и теперь выбирает v,
который он предложит.
Если пропозер получил
хотя бы от одного аксептора
не пустой голос,
то есть голос, у которого уже есть
какой-то nav,
то в качестве
значения, которое будет предлагаться,
давайте его v со звездочкой обозначим,
будет
выбрано va с максимальным
na.
Если же пропозер
получил промесы
и во всех этих промесах
пустой голос,
то есть аксепторы, которые ему ответили,
то пропозер выберет
в качестве этого v со звездочкой
свое собственное v.
Ну а дальше, выбрав
это самое v,
мы предлагаем его аксепторам.
Мы отправляем команду,
которая называется,
ну можно по-разному ее называть,
можно сказать, что она называется
propose
n
v со звездочкой.
Ну или иногда ее называют
accept v со звездочкой.
Где бы это написать теперь?
Ну мы собираем
quorum promis.
Мы собираем quorum promis.
Вот это был ответ.
Ну что,
мы собираем
quorum promis.
Ну что,
мы собираем
quorum promis.
Ну что,
мы собираем
quorum promis.
Еще раз, аксептор отправляет
аксептор, смотрит на полученное n.
Если это n меньше, чем np,
то promis не отправляет.
Если n больше, чем np,
то отправляет
пропозеру сообщение promis
и к нему
прикладывает свой голос.
А пропозер дожидается
на фазе 1, когда он соберет
quorum promis.
То есть каждый аксептор
может либо
умереть и вообще не ответить,
может ответить, что отказывает
этому prepare.
Это все в quorum не учитывается,
разумеется.
Мы выбрали значение,
которое мы будем предлагать,
и предлагаем его. Посылаем команду propose
или accept.
Я буду называть это так-то так.
И что делает аксептор?
Точно так же. Он получает этот propose
nv со звездочкой,
смотрит на n
и на свое np.
И если его
np не меньше,
чем n,
то аксептор обновляет свой голос.
То есть вот здесь
он говорит, что
na va
теперь
nv со звездочкой.
Ну и обновляет
на самом деле np тоже,
если он видел, что n больше,
чем его nt.
И отвечает
proposору
сообщением
accepted.
Это вторая фаза.
Вот мы предлагаем
аксептору
наше предложение,
он за него голосует,
если наше n его устраивает.
Если наше n
больше того,
что он уже видел.
Что?
Ну это разные значения.
Это разные значения.
Ну na va
это голос,
это предложение,
за которое мы проголосовали.
У аксептора есть
две переменные,
np это максимальное значение,
которое он получал
в любом сообщении,
что в prepare, что в propose.
Na va это голос,
который он отдал.
Вот на второй фазе
алгоритма Pax.
Ну конечно же может,
чего же не может.
Мы можем
не собрать quorum как здесь,
так и здесь, по одним и тем же причинам.
Либо у нас слишком много отказов
quorum не собирается,
ну это понятно, мы просто блокируемся, ждем.
Либо
нам прислали слишком много отказов.
И мы понимаем, что quorum собраться
уже не может никак.
В этом случае мы,
вне зависимости от того, какая фаза
то есть первая или вторая,
ретраемся и выбираем себе новое значение n побольше,
чем было раньше, потому что
видимо то, что было раньше оказалось слишком маленьким.
Ну можно
для начала считать, что так.
Совсем случайно делать не нужно.
Но начать можно со случайного.
Наверное легко догадаться, что если
ты acceptor, ты отвечаешь отказом,
ты мог бы предложить свое np,
которое больше чем n.
И proposer явно не должен
выбирать свое новое n меньше, чем
np, которое уже есть в acceptor.
Это было бы бесполезно.
Ну что, таков
алгоритм.
Я пока совершенно не объяснил, что это значит,
в чем здесь смысл,
но по крайней мере процедура должна быть ясна.
Вот алгоритм propos написан, нарисован.
Остаются ли в нем какие-то сомнения?
Ну за последний раз сомнения
наверное масса.
Понятно ли, как он работает?
Что он делает на каждом шаге?
Да, n уникальные.
Ну достичь этого несложно, еще раз.
У тебя n это кортеж
из некоторого числа и
твоего уникального идентификатора.
Ну просто выбирая
число монотонно, каждый раз увеличивая n.
Уникальный идентификатор даст тебе
глобальную уникальность,
ну и все эти кортежи, они упорядочены просто
лексикографически.
Ну мы на каждой итерации,
у нас же алгоритм с итерациями, у нас фаза может
провалиться, и мы элитровируемся.
Ну вот мы на каждой итерации вот этих двух фаз
выбираем себе значение n
и с ним входим к acceptor.
А вы говорили,
как выбирает acceptor,
как он голосует,
за что он голосует?
Да, вы говорили.
Ну еще раз, acceptor
получает пропоз, смотрит на n,
сравнивает его с np. Если np
больше, чем n, мы отказываем этому
пропозу. Если n больше, чем
np, то мы обновляем
свою пару n в a, отдаем голос за эту пропозу.
Ну мы меняем свое решение,
потому что вот n у этого
пропозла побольше,
чем мы видели.
Обращаю внимание, вот этот
отданный здесь голос, он в смысле
консенсуса ничего не значит пока.
Это просто какой-то acceptor
проголосовал, это не выбор
термин консенсуса, это не значит, что узел,
на котором живет acceptor, сделал какой-то выбор
в смысле пропозы, нет.
Да, ну и если,
конец, нужно завершить
это все, если пропозер
прошел успешно через первую фазу и
через вторую, собрал оба кворума,
то он свой пропоз завершает
и выбирает вот это самое его со звездочкой.
Ну что, таков алгоритм?
Допускаю, что
он, возможно, пока не интуитивен,
но если
его нарисовать, в смысле как
он работает, то все станет очень просто.
Поэтому давайте
рисовать.
Как я буду рисовать?
Ну я рисую картинки
обычно вот так вот,
таймлайны и стрелочки между ними,
сейчас будет иначе.
Пропозеров я вообще
рисовать не буду, они лишние, я буду
рисовать только acceptor.
Вот будет acceptor, и у него будет
вот такой вот таймлайн, и на нем
будут два события, два типа событий.
Во-первых, acceptor может получить
от пропозера,
они будут разноцветными,
вот цвет это будет пропозер,
синий пропозер, красный пропозер, зеленый пропозер,
других не будет.
Он может получить
сообщение prepare, это выглядит так,
prepare 3.
Это означает, что
жил был acceptor A,
и вот ему
пришел prepare,
с номером n
с n равным 3.
Я сказал, что n это на самом деле не просто
числа, это какие-то пары, ну или
элементы какого-то
порядочного множества,
но я могу их на носке выбирать глобально
уникальными, поэтому буду просто числа рисовать.
Вот prepare 3,
и acceptor
ответил на него
промессом.
А если n оказалось маленьким, то я буду
этот p зачеркивать,
acceptor его отверг.
Ну, помимо prepare,
acceptor может получать
и команды propose
или accept.
Ну вот propose это больше по смыслу подходит,
а accept такая директива,
прими значения.
Вот я буду рисовать здесь буквы a, потому что
p склеиваются.
Accept
7 значения
x.
Это что означает?
Что этому acceptor
чуть позже,
вот где-то здесь
прилетела команда
accept
с n7 и с значением
x. Ну и она тоже была принята.
Если не
была почему-то, то я тоже буду зачеркивать.
Ну вот такой способ
просто рисовать исполнение.
Ну а теперь
рисуем исполнение.
Чтобы понять,
как он работает.
Случай 1.
У нас 3 acceptor.
У нас всегда будет 3.
И что
происходит? Сначала появляется
синий proposer.
Он выбирает
себе n равное n единица
и посылает
prepare вот сюда
и вот сюда.
Собрал quorum.
Получил отец промессы.
После этого он
прошел
через первую фазу своего алгоритма
и
видимо от этих acceptor получил
пустые голоса, потому что они еще не успели
ни за что проголосовать.
И предлагает теперь свое значение.
Допустим, вот этот самый x, который здесь был.
accept 1x
accept 1x
Accept 1x
Оба acceptor проголосовали
за принято x, он их устраивает.
И
для синего proposer
завершается.
Нет, не обязательно.
Вот тут, видишь, нарисовано даже, что не обязательно.
Accept
Цвета это proposer сейчас.
Вот синий proposer, красный proposer.
Проголосовать за пустой
невозможно, просто по построению алгоритма.
Мы голосуем, когда мы получаем nv.
Вот мы получили nv,
смотрим на это n, если оно больше, чем np,
то мы обновляем свой голос.
Мы acceptor.
Что?
Равно?
У нас устраивает.
У нас не устраивает, когда оно меньше.
Вот, что происходит дальше?
Дальше появляется красный proposer,
он говорит p2, p2.
Какой-то вопрос, наверное, есть, можно его задать.
Acceptor хранит, во-первых,
максимально n, который он видел,
это называется np.
Да, я соболезную, что я говорю np и nava,
но у этого еще есть понятие
голос, это какой-то
номер бюллетенера.
Вот в следующий раз
за этими странными обозначениями
будет очень конкретная интуиция.
Мы просто должны к ней сами прийти.
Вот в этом алгоритме никакой интуиции
нет пока.
Никакого физического смысла
в этих понятиях не наблюдается.
Ну вот, а nava
это просто голос,
который Acceptor успел
отдать кому-то на второй фазе.
Если его устроила n,
которая прилетела в этот proposer,
то мы за него голосуем.
У нас это устраивает,
но здесь же на картинке я так специально
сказал, мы от третьего Acceptor
получили Accept,
но еще не видели ни одного препарата.
Нас это устраивает, потому что np
меньше, чем вот это n
в Accept.
Еще раз,
алгоритм устроен так,
получаем Accept, сравниваем n и np,
если n не меньше, чем np,
нас устраивает. Все, никаких дополнительных правил.
Так что не нужно сначала
на те же реплики доставлять обязательно в том же...
Нет, не требуется ничего такого.
Вот, кстати,
то, что этот вопрос вызывает некоторые
трудности, это нормально, потому что
проблема у лэмпорта была, в смысле,
проблема у людей, кто читает статью Paxos Made Simple,
была ровно в этом.
То есть, действительно, Accept мог
прийти на реплик, на Acceptor,
который не видел до этого препара,
и ошибка была в том, чтобы
не обновлять здесь np.
Это всегда.
Что на этой фазе, что на этой фазе.
Если мы увидели n
в Accept или n в Prepay,
или больше, чем наш np, мы его всегда обновляем.
Ну вот, значит, что происходит здесь?
Здесь
этот P2
приводит конкретный промисс,
который возвращает что?
Ну, видимо,
ноль ничего,
то есть,
третий Acceptor ни за что не голосовал.
А второй Acceptor
вернет значение пару
1x.
Ну, то есть,
он...
Этот Acceptor
принял уже эту пару,
1x, и эта пара,
и
красный пропозер узнает
про этот голос,
получив промисс от второго Acceptor.
Ну, а дальше,
красный пропозер собрал
quorum на первой фазе.
Он смотрит, получил ли он хотя бы
одно непустое значение v.
Получил.
А значит, он в качестве своего предложения
выбирает v с максимальным na.
Это x
и предлагает теперь
a2x, a2x.
И Acceptor
снова голосует уже за 2.
Уже за предложение 2x.
Ну, то есть, здесь второй Acceptor
проголосовал два.
Он сначала проголосовал за 1x, потом за 2x.
Ну, и то, что здесь произошло,
очень естественно.
Вот здесь, вот в этот момент,
синий пропозер уже завершился.
Он выбрал значение x.
По правилам консенсуса,
если кто-то один выбрал что-то, то другие должны
выбрать то же самое.
И вот в промесе с помощью
вот этого ответа,
то есть, когда мы прикладываем
свой отданный голос к ответу,
с помощью этой информации
красный пропозер смог понять,
что есть уже значение x
и повторно его
предложить.
И таким образом он выберет тот же самый x.
То есть, здесь, в этом случае
промес
помогал красному пропозеру,
потому что в промесе был
отданный этим
аксептором голос.
И через него мы узнавали о том, что какое значение
уже выбрано.
Мы, конечно, не понимали, что оно выбрано, но
за счет этого мы не предлагали
чего-то другого.
Ну, может
получиться, конечно, иначе.
Скажем, может быть, этот аксептор,
синий пропозер не успеет
сделать свой выбор.
А когда сможет
это сделать, когда будет это делать,
это уже будет слишком поздно.
Нет, все правильно.
И вот это
предложение будет отвергнуто.
Такое может быть.
Ну, то есть,
вот здесь вот второй красный пропозер
узнает про x
через второго аксептора.
Но он в случае
вот этот один и один штрих
не различает между собой.
То есть,
красный пропозер не понимает, выбран
x глобально или не выбран.
Правда ли,
что у нас
те пропозеры,
которые...
То есть, у нас зашел пропоз,
правда ли,
что у нас могут быть другие
аксепторы,
на которые пришел как раз
аксепт?
Сейчас, не нужно в одном предложении
говорить и пропоз, и аксепт.
Потому что это синоним, и нужно как-то
согласованно.
Пропоуз, аксепт — это синоним.
Я бы хотел говорить пропоуз.
Но если я буду рисовать здесь P и здесь P,
меня не поймут.
Давай это заново,
потому что я ничего не понял.
Вот у нас prepare на первом случае.
Он у нас на первый и второй аксептор.
Пошел prepare.
Дальше у нас аксептор.
Дальше у нас аксептор.
Правда ли, что она может
пойти на второй и третий аксептор?
А ты думаешь,
я рисую просто
произвольные картинки,
да, не думаю об этом никак.
Для этого и нарисовано,
чтобы исключить твой вопрос.
Но не получилось.
Мой план провалился.
Может.
Может как угодно быть.
И еще раз.
Аксептор, когда он получает prepare,
когда он получает accept,
он не думает про то, что с ним было раньше.
Он просто смотрит на NP
и сравнивает его с N.
Если не меньше, то хорошо.
Если меньше, то плохо. Отказываем.
Это все, что он делает. Очень простой алгоритм.
То есть здесь
в исполнении штрих
P2 перенял это значение X
и свое не предлагает.
Но
этот красный пропозер
эти два сценария не отличает друг от друга.
Правда ничего страшного не случится,
потому что аксептор,
пропозер синего цвета,
он хоть свою вторую фазу и провалил,
но он притрается,
снова соберет
с P3 P3
снова получит ответы
от аксепторов.
Этот X увидит свой же, который
записал красный,
ну и еще раз его предложит.
Так что здесь ничего страшного не произойдет.
В любой,
где не собрался кворум.
То есть если ты вот здесь
получил, например, два отказа из трех,
ты понимаешь, что ничего уже не светит тебе
и нужно пробовать заново с большим N.
Ну либо здесь.
Это первый случай,
который демонстрирует нам
одно назначение
сообщения promise.
И есть другой случай.
Итак,
все начинается
так же. У нас есть синий пропозер,
у него есть, допустим, значение X
и он говорит
prepare 1, prepare 1
на первых двух аксепторах.
И он успевает записать
свое значение
X
под вот этим
ballot number
на первого аксептора.
Но тут
приходит красный пропозер со значением Y
и говорит P2P2.
После этого, когда вот этот
accept от синего пропозера
долетает до второго аксептора,
он этим
аксептором
отвергается, потому что
она слишком маленькая.
Ну а что получил
здесь красный пропозер в ответ
на свои prepare?
Он получил ничего и ничего, поэтому
он предлагает свое значение,
а у него это было Y.
И он говорит A2Y,
A2Y
и выбирает значение Y.
Но у него был.
Задача консенс.
У каждого есть свое значение.
Ну ничего плохого не произошло.
Так я к чему эти рисунки
тарисую? Не просто так, а для того,
чтобы объяснить, в чем смысл
фазы prepare,
в чем интуиция, вернее.
Вот здесь сработал другой момент.
Смотрите, что могло
пойти не так.
То есть почему нельзя, скажем,
оставить этот алгоритм в вторую фазу?
Это, конечно, странное вам предложение.
Но все же.
Вот у нас здесь есть два конкурента.
Есть синий и красный.
У одного X, у другого Y.
И они пишут его на аксепторы.
И вот будет скверно,
если сначала большинство аксепторов
проголосуют, ну интуитивно,
большинство аксепторов проголосуют за X,
а потом они проголосуют за Y.
Поэтому здесь
вмешивается второй механизм
алгоритма Paxos, а именно,
что мы обновляем NP
и обещаем, собственно,
отвергать старые предложения.
Смотрите,
вот есть...
Я понимаю, что у меня цвета
разные, значит.
Здесь они означают разных пропозеров,
а здесь разные фазы.
Пусть у нас
есть красный пропозер,
и он на большинство
пришел с припэром 2
и получил подтверждение.
Путверждение Promise,
то есть аксеп,
большинство аксепторов пообещало ему
старые пропозалы игнорировать.
Вот за счет обновления
этого NP и правила,
что N должно быть больше NP,
это мешает синему
пропозеру прийти
и записать на quorum свои аксепты,
свои предложения.
Но потому что мы пересечемся, и в пересечении будет хотя бы один узел,
который уже точно
предложение отвергнет.
То есть мы здесь
не можем собрать у синего аксептора
quorum
с его 1x.
Вот этот узел в пересечении
скажет нет,
отказано.
Так что аксептор
в фазе припэр выполняет
как бы он две задачи
решает. С одной стороны,
замечая своим голосом,
он помогает другому аксептору
понять, что значение уже
выбрано, как было в примере 1 без
штриха.
А с другой стороны, он помогает
заблокировать конкурирующего пропозора
со старым N,
если значение еще не выбрано.
То есть если значение выбрано,
то работает вот эта
пара.
А если значение не выбрано, то работает
правило, что N меньше, N
больше чем NP, не меньше чем NP.
Каждый аксептор
не понимает, какой сценарий
сейчас реализуется, поэтому он делает
сразу две эти вещи.
Вот такая
грубая интуиция.
Она все еще ничего не объясняет,
никакого строгого смысла в ней нет,
строгого содержания, но
хотя бы интуитивно почувствовать, зачем
она нужна можно.
Через неделю все сложится,
если вы будете внимательны,
все встанет на свои места, и почему
пропозор и аксептор это разные люди,
и что значит эти N, V и так далее.
Но пока
не имеем дело с тем, что есть.
Ну что,
сценарий понятно, да?
Тогда следующий вопрос.
А что значит
в этом алгоритме понятие выбора?
Я, конечно, сказал, что
каждый пропозор, проходя через две фазы,
выбор совершает, то есть пропозор у него завершается.
Но вот можем ли мы каким-то образом,
в конце концов каждый пропозор может
умереть?
Так вот,
и он не сможет
понять, что он прошел через две фазы.
Можем ли мы
по глобальному
состоянию мира понять, что значение
выбрано? По состоянию аксепторов
или по действиям аксепторов?
Каждый пропозор понимает,
было он значение или нет.
А вот можем ли мы,
смотря на такие картинки,
это понимать, не думая про отдельных пропозоров,
думая про то, что делают аксепторы?
То есть, что такое
выбор? Вот я могу сказать двумя способами.
Я могу сказать, что вот выбор,
алгоритм консенсуса сделал,
консенсус сделал выбор,
вообще, помните, в прошлый раз у нас было состояние,
была Эфела Питиарема,
и там были конфигурации.
И мы их делили на два типа,
бивалентные и унивалентные.
И унивалентность означала, что выбор зафиксирован уже,
что как бы дело дальше не пошло,
все равно все выберут одно и то же.
Вот могу ли я сказать, что если,
скажем, на большинстве аксепторов
сейчас в VA лежит одно и то же
значение,
то алгоритм консенсуса,
это VA непременно,
то выбрано может быть только самое VA.
Ну это довольно естественно,
что вот на большинстве лежит,
вот если это на большинстве лежит,
значит уж точно выбрано Х.
Нет, ну на одном лежит один Х,
а выбрано Y
в этом исполнении.
Но я говорю не на одном,
а на большинстве.
Вот если на каком-то кворуме лежит Х
или лежит Y,
то можно ли считать,
что ничего другого,
кроме этого Х или этого Y,
проползы вернуть не могут?
Вот такой вот вопрос.
Да нет.
Ну вот у меня здесь
лежит где-то один Х.
На одном аксепторе лежит
голос один, запятая Х.
Я прихожу с
prepare2, prepare2, прихожу,
но вот на первую реплику вижу Х.
Значит ли это, что Х обязательно
уже будет выбран? Ну нет, не значит.
Он лежит только на одном узле.
Этот узел, не знаю, умереть может.
Но я спрашиваю уже
не про один узел,
ты пытаешься сделать
какое-то более сильное утверждение.
А я говорю, что мне
достаточно, конечно, одного узла,
мне необходим целый кворум.
Еще раз вопрос.
Верно ли, что если
одно и то же значение
в виде va лежит на большинстве
аксепторов, то никакой прополз
не может вернуть ничего другому, кроме va?
Ответ нет.
И рисуем контрпример.
А понятно ли, почему...
Нет, если интуиция вас обманывает,
то непонятно, конечно, почему.
Но если вы знаете ответ, что нет,
то в чем проблема?
Итак,
у нас будут 4, кажется,
аксептора.
Сначала появляется синий.
Говорит
p1, p1,
prepare1, prepare1.
Получает промежность с пустыми ответами,
с пустыми голосами.
Предлагает свой x.
a1x.
Тут появляется красный пропозер.
Говорит prepare2,
prepare2.
После этого,
здесь, понятно, отвергается
p1x.
Кворум у нас 3 аксептора,
и кворум это 2 из 3.
У нас по-прежнему 3 аксептора.
Ну как-то не знаю,
как с конкарнсия.
Для того, чтобы построить контрпример,
обычно достаточно 3.
Поэтому 3 всегда и рисуем.
В продакшене не достаточно.
достаточно. То есть, если вы используете зукипер, то его, скажем, диплоит на 5 машин или на 7 машин.
Но если эти машины далеко, то, наверное, все-таки 3 ставят, физически далеко.
Ладно, у нас нечетная и 3. Вот пришел P2, он перебил синего пропозора
и предложил свое собственное значение. У него это был Y.
Вообще понятно, к чему я клоню, а то я сейчас нарисую контрпример и вы все увидите.
А вот пока интуиция есть, к чему я хочу прийти?
Зациклить алгоритм нужно. Флп говорит, что лайфлог есть.
Но мы же не про лайфлог сейчас говорим. Мы сейчас говорим про то, что понятие выбора определено пока нами неправильно.
Что просто иметь одно и то же значение на кворуме недостаточно для выбора.
Видимо, я хочу иметь одно и то же значение на кворуме, но, видимо, хочу я его иметь с разными болот-наборами.
И это каким-то образом алгоритм собьет с толку.
Точнее нас собьет с толку, алгоритм переживет все что угодно.
Итак, А2 и что происходит дальше?
Он близок к тому, чтобы записать Y с 2 и выбрать, но приходит P3 P3.
Что P3 получает от аксепторов?
Он с одной стороны здесь получает X, а здесь получает ничего.
Так что зеленый выбирает в качестве его значения X и говорит А3X.
Я не буду уже красного рисовать, как у него отвергаются аксепты, это и так понятно.
А что происходит в конце концов?
Смотрите, я уже получил то, что хотел.
Момент времени и сейчас на первом возле лежит X, на третьем аксепторе тоже лежит X.
Момент времени состоит в том, что кроме X выбрано уже быть ничего не может.
Но очевидно может. Что для этого нужно сделать?
Нужно прийти prepare99 сюда и prepare99 сюда.
И тогда этот prepare что увидит? 1X, да?
А этот prepare 2Y увидит.
И мы в качестве V со звездочкой выберем Vat с максимальным n-атом.
То есть мы выберем Y и запишем его.
A99Y, A99Y.
Ну и все, вот здесь пропауз уже, это первый пропауз, который завершился успешно, и он выбрал Y.
Хотя на большинстве лежало X.
Так что такого условия недостаточно для того, чтобы считать, что выбор сделан.
Это неинтересный ответ.
Я же говорю про то, если пропауз еще не завершился, понять, что выбор уже предрешен.
А если пропауз завершился, а выбор еще может поменяться, то это просто неправильно к этому консенсу, его нужно выкинуть.
Так как же мне сказать, когда выбор сделан?
Как же правильно сказать, что выбор сделан?
Сказать, что значение лежит на большинстве аксепторов недостаточно.
Я хочу сказать, что значение... На самом деле понятие выбрано, Lamport это называется словом chosen.
Выбрано может быть не значение, а предложение N, V.
И оно выбрано не то, чтобы когда оно лежит на большинстве аксепторов, я даже этого не требую.
Я скажу, что значение предложения выбрано, когда большинству аксепторов ответили на такое предложение accepted.
Я вот не требую, чтобы в один момент времени все эти предложения лежали на кворуме даже.
Просто чтобы все ответили. Ну, чтобы кворум ответил.
Ну и это уже нужно доказывать.
Мы сейчас доказываем свойство agreement у задачи в алгоритме single-dequip access.
Свойство validity является очевидным.
Алгоритм очевидно выбирает только то, что было кем-то предложено, как он иначе может сделать.
Мы доказываем сейчас agreement.
Мы говорим, пусть предложение N, V выбрано в некотором раунде N.
Раундом я называю все сообщения с одним N.
И пусть у меня есть N штрих не меньше, чем N.
Я хочу показать, что тогда, если в раунде N штрих вообще появляется в сети сообщения...
Давайте я буду прополз рисовать.
Propose N штрих V штрих.
То из этого следует, что V штрих равно V.
Вот это я хочу доказать.
Ясно?
Совсем недавно обсудили.
Chosen означает...
Мы определили, что для понятия выбора недостаточно сказать, что X лежит на большинстве аксепторов.
Предложение выбрано, когда большинство аксепторов за него проголосовали.
Утверждение понятно?
Оно звучит так, как будто бы, что если предложение N, V выбрано, то для всех будущих предложений V может быть только таким же.
На самом деле это не про время утверждения, потому что... Смотрите, как может быть.
Снова три аксептора.
И мы говорим P1 P1.
Потом мы говорим A1X.
Потом мы говорим P2 P2.
A2X A2X.
А потом мы говорим A1X.
И если смачить эту картинку, это исполнение с теоремой, то о чем она говорит?
Что если в раунде 1 предложение 1X было выбрано, то в любом раунде не меньше чем 1, например в раунде 2, может быть предложено только то же самое значение X.
Хотя хронологически тут немного в другом порядке все произошло.
Да, и здесь видите, предложение 1X является выбранным, но нет момента времени, когда оно лежит на большинстве аксепторов.
Этого не требуется.
Что тоже интуиция алгоритма не добавляет, конечно.
Почитай статью.
Итак, база-то очевидна, правда? Мы индукцию хотим сейчас устроить.
База N равно N штрих.
Что значит Nv chosen?
Это значит, что алгоритм-пропозер с этим предложением прошел через две фазы.
В частности, через вторую фазу, и там он говорил пропоз явно с этим самым V.
Так что нас интересует уже шаг индукции, и мы смотрим на ситуацию, когда у нас есть N штрих больше, чем N.
И с одной стороны Nv chosen, с другой стороны есть пропоз N штрих V штрих.
Давайте это нарисуем.
Что значит, что Nv chosen в раунде N?
Это означает, что пропозер, который предлагал это предложение, прошел через вторую фазу.
То есть он отправил команду Propose на узлы, на аксептора и собрал quorum.
Вот можно его нарисовать, этот quorum.
Что означает, что какой-то пропозер в раунде N штрих предлагает пару N штрих V штрих?
Видимо, для этого он должен был собрать quorum promise с фазы prepare.
Ну а теперь посмотрим на узел, который находился в пересечении.
Он такой обязательно должен быть, какой-нибудь особенный A.
Вот нарисуем его таймлайн.
Он с одной стороны получил сообщение prepare N штрих, и ответил на него promise.
А с другой он получил Propose Nv и принял это предложение.
Вот где он получил Propose на этом таймлайне?
Мог ли он получить его где-то вот здесь, правее этого момента?
Довольно простой вопрос.
Кажется, не мог, потому что каждый аксептор обновляет свое N monotone,
и здесь у него Np равно, по крайней мере, N штрих дальше.
Если он получил бы Propose позже, то мы знаем, что N штрих больше, чем N,
а его Np теперь не меньше, чем N штрих, поэтому это сообщный отверг.
Поэтому Propose Nv он мог получить только до.
Ну а теперь думаем.
Что нам интересно узнать?
Какова наша цель? Узнать, что в раунде N штрих предложит вот этот штрихованный пропозор.
Чему будет равно v штрих? Мы хотим показать, что оно будет равно v.
Ну вот, смотрим на эту картинку.
Вот здесь, раз аксептор получает Propose Nv и принимает предложение, то, видимо, это N его устраивает.
То есть мы знаем, что теперь после этого шага уж точно Np не меньше, чем N.
Вот на всем суффиксе этого таймлайна.
И мы знаем, что prepare N штрих был успешен.
Что мы можем из этого заключить?
Ну что, во-первых, N штрих был не меньше, чем Np к этому моменту.
Ну а с этим promise, какое значение аксептор A со звездочкой отправил штрихованному пропозору?
Почему это так получается?
Чему было равно Na? Каково было Na у этого ответа?
Она была не меньше, чем N.
Да?
Ну а теперь по предположению индукции мы знаем, что раз нам ответили, что Np было даже меньше, чем N штрих и не меньше, чем N.
По предположению индукции все пропозы, которые в этом интервале выдвигались, имели v штрих равных v.
Поэтому мы знаем про ответ, про отданный аксепторам голос, что здесь вот Na оно не меньше, чем N, и что va это v.
В этом мы уверены.
Ну а теперь штрихованный пропозор, получая такие promise, смотрит на Na и выбирает из них максимальное.
Ну раз какое-то va уже не меньше, чем N, то и максимальное не меньше, чем N.
Ну а для всех таких Na, если они не меньше, чем N, то у них по предположению индукции va равно v.
Так что штрихованный пропозор, собрав такой quorum, обязан в качестве своего v со звездочкой выбрать вот это самое v, но его он и предложит.
Это все.
Пара несложных шангов.
Правда, абсолютно ничего сложного не произошло.
Но Лэмпард не врет, тут сложнее Na больше, чем N, ничего нет во всем алгоритме и в теореме.
Еще раз понятно, что мы сделали.
Мы нашли акцептора, через который каждый пропозор с большим N узнает про ранее выбранное значение.
То есть все очень простое.
Ну и все, мы показали, что алгоритм single decreed access не нарушает агримент.
Алгоритм single decreed access обеспечивает safety свойства.
Если значение выбрано, то оно уже не поменяется.
Ничего плохого не произойдет.
С другой стороны, эта теорема не обещает, что значение вообще в принципе будет выбрано когда-либо.
Она обещает только, что оно не изменится, если оно выбрано.
А вот гарантировать, что оно будет выбрано, в принципе невозможно.
Потому что, как мы помним, у нас есть FLP-теорема, и она говорит, что в любом алгоритме консенсуса есть LifeLog.
То есть любого алгоритма консенсуса может бесконечно долгое значение не выбирать.
Ну и давайте подумаем, а где же в нашем алгоритме есть LifeLog?
Если его нет, то нужно волноваться.
Но вроде бы мы доказали, что он корректен, что он обеспечивает safety свойства.
LifeLog обязан быть.
У LifeLog есть специальные названия.
Не у каждого LifeLogа есть названия, вот у этого есть.
LifeLog называется дуэль пропозеров.
Ну и давайте нарисуем LifeLog. Вроде несложно.
Я начинаю одинаковое.
Что происходит дальше?
Ну и синий приходит сюда, сюда и проигрывает.
Получает большинство отказов, и, видимо, он ретравится.
И что он делает дальше?
Ну, в общем-то, он проигрывает.
Ну, в общем-то, он проигрывает.
Ну, в общем-то, он проигрывает.
Он себе новое n выбирает.
Да зачем?
Это нам не помогает LifeLog строить.
До accept'ра можно вообще не рисовать, они все равно провалятся все.
Смотрите, вот здесь accept, синий пропозер пытается сюда записать значение,
получается сюда и сюда, не получается.
Ретравится, выбирает себе новое n, например, равным 3, и пишет p3, p3.
Ну и он получается перебил красного, который пытается сюда и сюда сделать accept'ы свои.
Допустим, сюда получается, сюда не получается.
Вот так что он ретравится и говорит p4, p4.
Вот, но они так друг другу мешают пройти через вторую фазу.
Что? За счет алгоритма.
То есть алгоритм так написан.
Я спрашивал, все ли понятно, смотрел на себя специально, не знаю почему.
Видимо, предчувствовал что-то.
Я говорил, что алгоритм может не собрать quorum, либо здесь, либо здесь.
Ну в смысле не то, что не собрать quorum, не дождаться, а в смысле получить слишком много отказов,
чтобы quorum гарантированно не мог собраться.
В этом случае что нам делать?
Нам нужно ретравиться.
Выбираем себе новое n, пробуем все заново.
Ну и ретравия у нас обязаны быть, потому что есть FLP-тиарема,
и FLP-тиарема говорит, что алгоритм должен иметь возможность не завершиться.
Вот в вашем алгоритме репликации регистра такой возможности нет не завершиться.
Если достаточно узлов живые, то просто вы делаете первую фазу, потом вторую фазу.
Циклов нет.
Вот здесь цикл обязан быть, и вот этот цикл нас с ретравиями в лайфлоге и приводит.
Но что здесь важно?
Почему мне лично более близок Paxos, нежели Raft?
Хотя Raft утверждает, что он проще.
Мне кажется, что Paxos проще.
Потому что Paxos идеально изолирует друг от друга safety, то есть свойство agreement,
и liveness, то есть завершение алгоритма.
Я в прошлый раз говорил, что решая задачу консенсуса можно...
Задача консенсуса не решается во синхронной модели,
дальше можно в модель добавлять время,
давайте в наш алгоритм встраивать какие-то таймауты.
А можно не встраивать в задачу консенсуса таймауты,
можно построить детектор сбоев
и в него встраивать таймауты,
а алгоритм консенсуса это строить поверха такого детектора сбоев,
опираясь на какие-то его свойства.
И дальше уже сам алгоритм консенсуса про время не думает.
Вот Paxos не думает про время.
Ваша задача из этого лайфлока выйти в разумной реализации, эту симметрию нарушить каким-то образом.
Но делайте, что хотите, говорит нам лэмпард, потому что если вы не нарушаете этот алгоритм,
то вы сейфти консенсуса нарушить не можете никак.
То есть пока вы не меняете вот эту структуру, вам ничего не угрожает, вы можете использовать время как угодно.
Но как вы его можете использовать? Разными способами.
Например, вы можете, собственно, поэтому у вас есть первая задача, где есть ссылка про ритрай.
У вас есть два пропоузера, они ритрайятся, но они делают это синхронно абсолютно, и поэтому друг другу постоянно мешают.
Вот можно эту синхронность нарушить, ритраясь аккуратно, а именно используя экспонент шелбыков.
Напомню, в чем смысл. Во-первых, когда вы ритраетесь, вы увеличиваете экспоненциальное время,
паузу между попытками своими, а во-вторых, вы эту паузу еще рандомизируете.
Зачем вы экспоненциально наращиваете паузу?
Затем, что вы не знаете, сколько потребуется вашему соседу, чтобы свой алгоритм завершить.
Но вообще, статья по экспонент шелбыков была просто про распределенную систему и клиентов.
И смысл там был такой, что если у вас система загружена и вдруг ей становится плохо,
то если все клиенты уйдут и потом разом притраются в одно и то же время,
то будет такая огромная нагрузка волнообразная, она снова все убьет.
Поэтому нужно клиентов во времени размазать.
Но при этом желательно, чтобы они принимали локальные решения, а глобально все было распределено.
Но вот это достигалось рандомизации и растущими делами.
Зачем в обоих случаях, что здесь, что в такой абстрактной системе с клиентами,
увеличивать экспоненциально время ритрая?
Потому что мы не знаем, какое время займет у нашего соседа, у нашего конкурента завершить свои две фазы,
и мы не знаем, сколько времени потребуется системе, чтобы восстановиться.
Мы увеличиваем и увеличиваем паузы между ритраями, чтобы этого было достаточно.
Рано или поздно этого будет достаточно.
В данном случае мы экспоненциально увеличиваем время ожидания для того,
чтобы наш конкурент за это время все-таки успел сделать обе свои фазы,
и мы с ним перестали бы толкаться.
А рандомизируем мы для того, чтобы, если вдруг это происходит совсем синхронно,
чтобы все-таки эта симметрия нарушилась.
Но пока мы не делаем ничего, что ломает нам вот эти рассуждения, мы в безопасности.
Мы можем использовать время, и пакс устроен так, что его сломать очень трудно этими предположениями о времени.
Ну а если вспомнить совсем аккуратно то, что я в прошлый раз рассказывал,
то я говорил, что если мы сводим задачу к консенсусу к построению детектора сбоев,
и в нем уже используем часы, то можно доказать, что есть самый слабый детектор сбоев — это выбор лидера.
То есть детектор, который всем узлам, каждому узлу системы говорит, что вот сейчас есть некоторый лидер.
Этот детектор может ошибаться, этот детектор может говорить разные ответы разным узлам,
может направлять их в мертвые узлы. Но если он eventually будет говорить правду,
если eventually все узлы сойдутся в предположении, кто сейчас лидер,
то этого будет достаточно для решения задачи консенсуса.
Ну и вот понятно, что достаточно. Если эти пропозоры между собой определятся,
кто из них главный и кто сейчас проходит через две фазы, то алгоритм сможет завершиться.
Ну это пока не нужно воспринимать это так, что нужно так на практике и делать,
потому что на практике вы не решаете изолированную задачу консенсуса,
на практике вы строите Atomic Broadcast. Но в следующий раз мы увидим, что такие рассуждения полезны,
и начнем мы более-менее с того, что скажем, что вот действительно возьмем просто серию консенсусов,
и они будут нам строить total order. А потом увидим, что вот есть какие-то общие элементы.
Так что пока для нас важно, что алгоритм Paxos safety обеспечивает абсолютно надежно,
и предположения времени его сломать, кажется, нигде не могут, пока он проходит через две эти фазы.
Ну еще пара маленьких замечаний. Во-первых, рестарты. Что нужно делать с рестартами? Как их переживать?
Ну подумайте в домашней работе, это совершенно тривиальный вопрос.
Еще один маленький вопрос. Вы приходите в систему, где есть аксепторы,
как вам узнать, какое значение сейчас выбрано? Вопрос довольно праздный, кажется, но на самом деле,
если вы пишете multi-Paxos, реплицируете RSM с помощью Paxos и делаете в нем отказы устойчивость,
переживаете смерть узлов, то такая задача там очень естественным образом возникает.
Как понять, что значение уже выбрано? Можете ли вы просто прочесть значение с хлорома
и понять, что вот выбрано оно?
Сейчас, ну подожди, я говорю про чтение. Можем ли мы просто опросить аксепторов и узнать, что значение уже выбрано?
Теорема про проползы. Она про algorithm Paxos. Я не спрашиваю про algorithm Paxos, я спрашиваю,
можем ли мы прочесть с аксепторов их голоса и узнать, что какое-то значение сейчас выбрано?
Просто глядя на любое большинство.
Если мы соберем ответы с большинства аксепторов и они окажутся одинаковыми,
в смысле одна и та же пара nv, то, безусловно, мы знаем, что значение выбрано.
А вот в общем случае мы не знаем, что значение выбрано, потому что можно получить разные n.
К чему я клонюсь? Если вы хотите узнать, что значение выбрано, то это всегда можно сделать,
предложив что-то самому. Это самый простой способ прочесть значение из аксепторов.
Совсем тупое замечание, algorithm Paxos, очевидно, собирает хорумы из большинства узлов,
поэтому не переживает сбои половины или более, тоже все сходится с прошлой теоремой.
Правда, можно поступать чуть более свободным образом. В нашей теореме мы использовали только тот факт,
что пересекается вторая фаза и первая фаза. Так что, вообще говоря, хорумы можно выбирать разные.
Где-то больше, где-то меньше. В чем смысл пока непонятен, но здесь он и не будет понятен.
Может быть, в следующий раз поговорим об этом.
Понятно ли, почему он говорит не понятен? В смысле не интуитивен.
Что мешает ему быть интуитивным?
Но мешает ему то, что, по-честному, у фазы 1 и фазы 2 нет самостоятельного смысла.
Они друг с друга, друг без друга не живут.
Вот нет самостоятельного смысла у фазы prepare. То есть, да, он говорит, что блокировки,
блокировки нужны для того, чтобы сделать фазу propose. А фаза propose работает только вместе с фазой prepare.
И только поэтому корректность достигается. То есть, фаза prepare, блокировки виртуальные защищают нас
от сценария, когда два пропозера конкурируют и старый хочет записать еще старое значение,
а новый уже взял блокировки, то есть выполнил prepare к хоруме и перехватил инициативу.
То есть, смысл этих фаз рождается в конкуренции между ними, и поэтому очень сложно друг о друга
оторвать и что-то инкрементальное сделать. Поэтому конструкция непонятна.
Но в следующий раз мы это починим, потому что мы увидим, выстраивая эти паксосы в серию,
что если их так выстроить и немножко подумать, то все эти NA, VA и NP можно будет заменить
на какие-то понятные уже человеческие слова, и в них будет уже физический смысл.
Ну а об этом мы поговорим через неделю. На сегодня все.
