Давайте по порядку к базе данных придем. Итак, мы говорим про задачу про алгоритм ABD,
в котором нам нужно было реплицировать ячеек памяти, ну или целый диапазон ячеек
памяти. И вы должны были эту задачу решить, ну по крайней мере, используя логические часы.
Чтобы решить задачу используя логические часы, никакого ума не надо, это позорное решение.
Если вы им ограничились, то никуда не годится, нужно продолжать. Это был первый пункт, чтобы
просто освоиться с фреймворком, чтобы скопировать этот кусок, еще один, вставить его. Ну и по
возможности, все это организовались в две функции, конечно. Если у вас RPC call повторяется в
программе больше, чем два раза, то вы ошиблись где-то, что где-то вы пошли не туда. Кроме того,
еще один простой критерий, как понять, что вы пошли не туда. У вас в структуре write timestamp
по-прежнему одно поле. Вот если у вас там одно поле, то как бы задумайтесь, зачем вообще структура
нужна для того, чтобы объявить один 64-битный int. Вот, убедитесь, что все упорядочивание в вашем коде
выполняется, то есть у вас есть только write timestamp с оператором меньше, или какими-то другими
операторами сравнения, и вы сравниваете только эти timestamps, потому что в конце концов весь
ordering в алгоритме, то есть упорядочивание всех операций, выполняется только по timestamp. Если вы
где-то сравниваете timestamp, а потом еще что-нибудь, то задумайтесь, что вы делаете что-то странное,
потому что сравнение должно быть только на timestamp. Если вы делаете так, то изменитесь срочно и
перепишите свой код, чтобы там остался только один простой оператор меньше. Это понятно, Вить, да?
Ты опоздал. Ничего не поделать уже. Что? Сравнивать только write timestamp и упорядочивание записи не
должно как-то расплываться, размазываться по коду. В структуре write timestamp одного поля
64-гитного мало, потому что вы так не сможете гарантировать разумным образом его уникальность.
Вам нужно еще что-то. Для уникальности у вас генератор гуидов есть, у вас есть ID-узла, и там
можно с разной степенью аккуратности все это сделать. Понятно. На всякий случай, конечно,
неправильно держать локальный счетчик и брать ID-узла, потому что если узел перезагрузится,
у него будет тот же самый ID. Ну, в общем, лучше... Что? Смотри, дело не в том, что нельзя использовать.
Ты можешь получить корректное решение, сравнивая еще и value. Но это же просто нарушает декомпозицию.
У тебя упорядочивание операции через timestamp происходит. Логика алгоритма такова, что там
выбирается timestamp ровно для упорядочивания. Если тебе их мало, то, видимо, ты как-то свою
ментальную модель в коде не выразил. Для алгоритма сами значения это просто какие-то байты,
они не используются при упорядочивании. При упорядочивании используются timestamp.
Ты не знаешь, можешь hash от значения брать в timestamp. Мне кажется, что хорошо, когда в программе
все упорядочивание заключено в одном таком объекте, и ты смотришь на оператор сравнения и понимаешь.
И в коде сравниваются только поля timestamp. Вот о чем была моя мысль.
Ну а теперь про интересное решение, про true time. Не то, чтобы оно очень драматически все усложняет,
но все же там есть, на чем можно попасться. Итак, у вас есть сервис true time, у которого есть,
в первую очередь, один единственный вызов now, который возвращает вам интервал earliest-latest.
Такое, что время вызова этой функции попадает в этот интервал. Это единственная гарантия,
которая у нас есть. Гарантия, что этот интервал какой-то очень маленький или как-то он там,
не знаю, монотонный, у правой и левой границы, вот таких гарантий сервис не дает. Пользоваться
ими не нужно. Смысл этого сервиса в том, что вызов now – это локальное действие, оно не требует
коммуникации по сети. И задача этого true time позволяет помогать узлам выбирать глобально
монотонные timestamp. У нас геораспределенная система, узлы находятся друг от друга далеко,
и вместо того, чтобы строить логические часы, которые требуют лишнего раунда коммуникации,
мы собираемся выбрать временные метки так, чтобы с одной стороны, если у нас есть две записи,
которые во времени не пересекаются, то timestamp первой записи был меньше, чем timestamp второй
записи, потому что мы упорядочивали в линейнализации эти записи по timestamp.
А с другой стороны, во-первых, мы их монотонно должны выбрать, а во-вторых, мы должны сделать это по
возможности не устраивая лишней коммуникации, потому что она дорогая, а true time у нас локальный.
True time использует коммуникацию, но там узлы коммуницируют с тайм-мастерами внутри DC
асинхронно относительно вызовов now. Но еще через спутники GPS, в конце концов, со всеми другими
общаются, то есть можно сказать, что коммуникация между ними есть, она просто наполовину в космосе
происходит, ну и относительно вызова now асинхронно, поэтому мы за нее в своих запросах не платим.
Мы пользуемся только тем, что нам вот дают такой интервал. Ну и задача выбрать эти timestamp
монотонно. Вроде бы в такой постановке мы должны думать, вот если у нас есть две операции, то у этой
должно быть timestamp больше, чем у этой. Вот смысл... Это так, если мы говорим про логические часы,
и мы должны думать про вот две эти операции разом, но с физическими часами, с физическими временными
метками, мы можем думать об этом проще. То есть мы можем не думать про две операции. Чтобы
гарантировать вот такое вот свойство, нам достаточно гарантировать следующее, что если у нас есть запись,
то наша задача выбрать временную метку для этой записи просто внутри интервала этой записи.
Мы не знаем, когда операция началась, этим вообще не мы управляем. Ну конечно мы управляем,
когда она закончится. И вот если мы выберем свою временную метку физическую в интервале этой операции,
самой этой операции, то очевидно мы получим такую монотонность. Так что используя true time для выбора
монотонных меток, мы можем не думать про разные операции, мы можем думать только про себя.
Соображение понятно? Ну вот, а дальше как это сделать? Ну вот у нас есть true time. Если вы решили задачу,
то вы знаете, что делать. Если вы не решили задачу, то есть у вас какие-то гипотезы. Как выбрать
временную метку? Ну вот вы вызвали now. Вот у вас операция началась. В момент времени, давайте так,
вот здесь напишем. Операция в момент времени t1 началась. И вот здесь вы спросили,
t service true time. Спросили now. И вот получили какой-то интервал. Можно его нарисовать.
Можно ли в качестве... Да, и нам теперь нужно выбрать временную метку. Ну предлагается как-то
выбрать наверное из этого интервала, значит зачем мы этот now позвали. Вот можно ли в качестве
временной метки выбрать левую границу интервала? Ну кажется, что даже по рисунку нельзя, потому что
она оказалась слева от t1, а на t1 мы не влияем. Вот так что левая граница интервала не годится.
Совсем не чувствуешь задачи. t1-то мы не знаем. Откуда мы его знаем? У нас есть свои неточные часы.
Если у нас были точные, мы бы и true time не использовали. Я про другое сейчас говорю. Во-первых, нет, во-вторых,
середина тоже не годится. По рисунку годится, но если отрезок сильно смещен влево, то и середина
может оказаться за границами интервала меньше t1. Вот в интервале от e до l есть только одна точка,
которая гарантированно попадает в интервал операции. То есть мы знаем, что во-первых, время вызова true time
не меньше, чем t1, неизвестная нам, и мы знаем, что видимо true time принадлежит вот этот неизвестный t,
принадлежит этому отрезку. А это означает, что l не меньше, чем true time. Время true time.
Мы говорим, что, например, наше оно не уходит за...
Что?
Ну, наше, помните, мы говорили, мы обращаемся к true time, он смотрит какой сейчас реальный пробежиток времени,
и пока он возвращается, прошло какое-то время.
Но он нам дает какой-то интервал. Сейчас мы не говорим, как true time устроен, нам сейчас это неважно.
Мы пользуемся просто гарантией, что время вызова true time принадлежит этому интервалу.
Но если ты хочешь, можешь считать, что у нас вызов true time, это сам некоторый отрезок,
и вот он пересекается с отрезком от еда l.
Но это все как бы усложняет немножко неравенство, но не добавляет ничего содержательного.
Поэтому мы считаем, что он мгновенно работает.
Но если считать, что он мгновенно работает, то мы знаем, что правая граница не меньше, чем tt по гарантиям true time,
и мы знаем, что это время вызова true time нау не меньше, чем t1.
Так что l не точно не меньше, чем t1.
И вот это единственный разумный кандидат на выборы timestamp.
Вот мы взяли это l, но с ним вторая беда.
Беда в том, что это l может быть далеко в будущем, в прошлом оно быть уже не может, в будущем оно может быть.
Ну и нам нужно как-то убедиться, что мы не управляем левой границей интервала,
правой границей мы управляем.
То есть это наше решение, когда операцию завершить.
Так что мы можем подождать, пока l точно не наступит.
Вот spanner это называется правило commit weight.
Если вы пробовали читать статью про spanner, то commit weight, потому что мы ждем.
Вместо того, чтобы общаться и выбирать временную ветку, мы ждем, пока она не наступит.
Как дождаться этого?
Вот попытка первая это написать slip от l до l-e.
Что?
Нау, если бы нам было известно, задача была бы решена уже сразу.
Как плохо, что задачи не решаешь.
Нау мы не знаем, у нас есть только диапазон такой.
Вот мы взяли l и хотим его дождаться.
Вот так делать можно, но этого недостаточно, потому что вы не знаете,
а вдруг ваши часы торопятся и вы проспите меньше, чем l-e.
То есть часы торопятся в симуляции, поэтому проспите меньше.
Поэтому нужно как-то убедиться.
Как проверить вообще, что l наступило?
Это вопрос какой-то.
Или ты просто проводишь рукой?
Хорошо.
Как убедиться, что l наступило?
У нас снова есть true time для этого.
Спросим еще раз true time, если он скажет, что что?
Как понять, что l наступило по его ответу?
Если e больше, если новый e больше нашего l.
Вот спросили true time, вот e больше, чем l, значит все, l наступило.
Но в true time есть просто метод, который называется after,
и он не возвращает future, что немного не согласовано.
И самому этому true time не хватает метода, который возвращает future,
но тогда смысл задачи пропадает, если его добавить.
Вы спите, это лучшее, что вы можете сделать,
и проверяете верно ли, что ваше временнометко оказалось в прошлом.
Если оказалось, то вы добились...
Дальше можно...
После этого, видимо, можно операцию завершать.
Вообще этот разговор задумывался для тех, которые решили задачу.
Вот.
Ты не помнишь, что after.
True time принимает временную метку.
В смысле, временную метку.
В смысле, временной метку, точку временной,
если и говорит, она в прошлом или в будущем.
Как? Вызывая true time, сравнивая эту точку с левой границы интервала.
Если левая граница от интервала больше.
То есть это просто...
Просто шорткат такой для этой проверки.
Ты можешь ее сам написать, можешь автор позвать.
Да.
А может так получиться, что у нас две машины получили один и тот же интервал?
Ну, конечно, может.
Проблема-то она...
Мы так же решаем какие...
Да. Здесь от логических и от true time ничего не зависит.
Проблема одна и та же. Ты должен гарантировать,
что временные метки получились уникальными.
А как она помогает вообще?
Она просто помогает узнать, верно ли,
что точка времени наступила и все.
В смысле автор просто зовет now и сравнивает
аргумент с этой границей.
Тебе помогает узнать,
время наступило, точка или нет.
Не slip, конечно, а true time помогает узнать.
Возвращая тебе новый E.
Возвращая тебе новый E.
Получается, что
внутри автора
вызывает true time now
и сравнивает...
Да.
Так он сейчас не было никакого утверждения,
что он делает что-то сложнее.
Там же функция реализована в одну строчку,
которая вызывает now как раз.
Возвращается, что он сразу же
как-то интервалов,
который наступает нам,
передавать...
Откуда мы его можем знать?
Мне кажется, что разумно вот так делать.
Это вот очень достаточно.
Что?
Тут уже можно разные юристики придумать.
В текущей симуляции тебе без разницы,
потому что там все настолько вывернуто,
что
там все равно полный фарш получается.
Я вот сейчас доделал задачу
и немножко в симуляторе что-то дорабатываю.
Я, надеюсь, доделаю бенчмарки,
чтобы можно было
запустить симуляцию
с нормальными таймингами
и с разумным true time,
чтобы там это работало быстрее.
Чтобы можно было увидеть, что работает быстрее.
Да.
А, ну это просто баг был, да.
Да.
Там была проблема в том, что ты написал цикл
со slipform, а время не идет, все равно.
Но если ты напоролся, то ты об этом знаешь.
Если не напоролся, то 100 д.
Не молчи.
Ты напоролся, никому не сказала об этом.
А человек из шада сказал,
и я могу исправить через 5 минут.
Ну нет, сейчас.
Я, кстати, не понимаю.
Это такой вопрос, который нужно всегда себе задавать.
Какова семантика slip 0?
Скажем.
Может быть, по-разному для тех,
где написано, может быть, if delay равен 0,
то просто выйти, а может быть,
какое-нибудь приключение сделать.
Ну, в общем, это, конечно, не фича.
В симуляторе время идет только, когда ты блокируешься.
В частности, на фьюче из таймсервиса.
Так что, если ты
вызываешь slipform от чего-то
отрицательного, положительного,
то время должно идти.
Если время не идет, то у тебя просто симуляция
зацикливается.
Время может медленно идти,
но если оно совсем не идет,
то вот это плохо, потому что
симуляция не завершается.
Ладно.
Да.
Ну, смотри, тебе Google говорит,
что у них здесь
восемь лет назад
было не больше
шести миллисекунд.
Вот это L-E.
А сейчас они там научились
синхронизировать.
Но у них статья была Google Sundail в прошлом году о том,
что они научились синхронизировать
часы с точностью до какие-то
нанесекунд, что это выглядит вообще
как безумие какое-то.
Roundtrip через Атлантику,
например, он занимает
десятки миллисекунд.
То есть ты ускоряешься там
на порядок минимум.
В этом и смысл,
что они быстрее, чем логические часы.
У тебя есть реплика в Африке, есть в Антарктиде,
и есть где-то
в Гренландии, ну и просто
между ними долго проводам сообщением лететь.
А ты можешь в этих трех точках,
далеко друг от друга, там все равно нет ДЦ,
но если представить их там, то
эти три машины в трех ДЦ могут
получать монотонные временные метки,
не коммуницируя друг с другом,
просто поспав там несколько миллисекунд,
или, может быть, меньше уже на миллисе.
Я просто забыл, что есть такое ограничение.
Нет, этого ограничения нет,
но чем меньше этот интервал,
тем лучше.
И смысл в том, чтобы
гарантировать, что настоящее время
там лежит, но гарантировать этого конечно невозможно.
Я не знаю, как Google под этими словами имеет в виду.
Они делают интервал настолько широким,
настолько узким, где они еще могут
давать какую-то разумную гарантию.
Где они сами верят,
что время действительно лежит.
Но они, кажется, верят в это очень сильно
и могут этот интервал ужать.
Это имеет все смысл
только в том, когда у тебя
ширина этого интервала меньше,
чем скорость передачи сообщения по сети.
Если не становится сопоставимым,
то в этом всем теряется смысл.
То есть если у тебя машины в одном ДЦ
в этом смысла никакого вообще нет.
Потому что там тайминги и так уже меньше
миллисекунды. То есть по сети сходить
быстро.
Так вот, как теперь выглядит
алгоритм? Мы вызываем
нау, получаем правую границу,
а потом спим, да?
А потом пишем на квором.
Делали кто-нибудь не так,
но потому что это не эффективный способ.
Можно параллельно спать.
Вот этот следующий шаг,
который нужно было сделать.
В самом деле,
вы выбираете временную метку,
чтобы писать на квором под ней.
И вот интуитивно вы делаете так,
выбираете временную метку, ждете, пока она в прошлом,
потом пишете под ней.
Никто не мешает делать это параллельно.
Вот вы выбрали временную метку
и сразу под ней пишете.
Да, нет?
В смысле нет?
Вот мы выбрали, вызвали нау, мы знаем,
что временная метка L.
Но она, правда, еще в будущее может быть.
То есть эта L еще не наступила.
Но мы могли бы дожидаться
параллельно с тем, чтобы собирать квором.
Потому что, смотрите,
ну, конечно,
у нас есть параллельно,
но, конечно, мы должны
завершить операцию аккуратно.
То есть мы должны завершить ее,
когда L окажется в прошлом
и когда квором соберется для записи.
То есть мы выбираем максимум
из двух, фактически.
В коде вы не ждете параллельно.
Вы собираете квором, потом вы дожидаетесь,
пока еще L пройдет.
В другом порядке, но по смыслу это параллельно.
И вот этого достаточно,
потому что если две записи будут
упорядочены,
а что с записью и чтением?
Вот у вас есть запись,
вот у вас есть чтение,
и чтение, оно смотрит на квором.
Но у вас здесь квором собрался,
и у чтения собирался квором,
и снова пересеклось.
То есть здесь у нас работает
ожидание для монотонности,
а здесь работают кворомы
для монотонности.
Но вы дождались и того, и другого, поэтому у вас все хорошо.
Есть один нюанс там,
но как бы на него наступить
интересно самому.
Это неправильно так делать.
То есть если вы так сделаете,
то у вас работать не будет.
Несмотря на то, что я вроде бы объяснил,
что должно.
Можно написать
и попробовать посмотреть,
что получится.
Я уж не буду все секреты раскрывать.
Но кажется, что
спаннер и квором собирает
и выбирает временную метку параллельно.
Потому что если можно еще сэкономить,
то почему бы еще и не сэкономить?
Ну что?
Мы освоили это?
По-моему, для того, что я не рассказал,
что делать с...
Почему не работать?
Не будет работать?
Все остальное понятно?
Это я предлагаю тебе
все-таки самому увидеть.
В смысле,
будут падать
стимуляции с нарушением реализуемости?
Должны?
А...
Вот на лекции у тебя были
шутки более уместные.
Нужно взять true time,
нужно выбрать правую границу
в качестве временной метки
и нужно написать решение, где ты
ждешь параллельно.
То есть ты начинаешь писать на квором
и вместе с этим, не дожидаясь,
пока временная метка уже в прошлом,
ты сразу начинаешь писать на квором.
Потом дожидаешься, что еще временная метка оказалась в прошлом.
То есть ты параллельно ждешь, что она окажется в прошлом
и пишешь на квором.
В этом решении что-то будет
не работать, хотя вроде бы
рассуждение...
Звучит разумно.
Давай ты что-нибудь напишешь и сам увидишь.
Должен же ты чему-то научиться.
Ладно.
Значит, это true time.
Вторая часть задачи,
которая мне кажется любопытной,
полезной, состоит в том, чтобы
оптимизировать...
оптимизировать код реаплики, которая хранит
собственно данные на диске.
Наверное,
вы заметили, что я из
кода решения относительно, например,
фреймворка удалил mutex, чтобы было
интереснее немножко.
Может быть, вы это заметили, а может быть вы поняли,
что у вас просто без него не работает.
Вот.
Вам нужно... Вы приходите
в хранилище... Вы, координатор, приходите в
хранилище с операцией апдейта
значения, у вас есть ключ
в значении временная метка, и вы хотите
атомарно проверить, что если текущая
временная метка не меньше,
меньше, чем ваша,
если временная метка
ключа в данном узбе
меньше, чем ваша метка, то значение
перезаписать. Если вы просто
напишете чтение, проверка
запись, то вы получите не атомарную операцию,
про это было весь весенний семестр, это работать
не будет. Поэтому вы берете mutex.
Ну и получаете что-то дикое, на самом деле,
потому что, ну представьте, вот вы пишете
промышленную систему, и у вас там, как бы,
она обрабатывает кучу запись, и вы приходите,
берете один mutex, и все
у него упирается. Хотя, как бы,
сама база данных, она, как бы, сама по себе
линиализуемая, атомарная, и там внутри какая-то конкурентность есть,
она могла обработать.
Ну, можно было бы mutex.rv mutex заменить,
которого вы выйдете, нет, стоило бы его написать.
Ну, это, наверное, не сильно вас все равно
обрадовало, потому что все равно один mutex.
Ну, если вы
хоть о чем-то подумали, то, наверное,
можно было бы просто шардировать его.
Ну, то есть, у вас есть разные ключи,
вы берете там массивы 128 mutex,
и считаете хэш от ключа,
и берете там какой-то свой. Ну, лучше, чем ничего,
чем один mutex.
Но в целом ситуация странная,
потому что вы навешиваете
эту блокировку,
и у вас получается, что все записи
происходят последовательно.
Можно как-то попытаться это оптимизировать.
И давайте мы
сначала посмотрим
на экран немножко, а потом вернемся
на доску.
Что я предлагаю?
Я предлагаю немного доработать
интерфейс базы.
Никакого касса там не будет,
потому что интерфейс базы
не произвольный, не то чтобы я его выбираю.
Я его выбираю
я, но исходя из того,
как этот интерфейс можно реализовать
в промышленной системе.
Я говорю, что мы в качестве
такой
дефолтной реализации этого интерфейса
базы данных предполагаем levelDB.
Это lsm, написанное Google,
помимо мотивом своей системы Bigtable,
которая поверх GFS работала.
Ну и смотрим
на то, что она умеет.
Она умеет
путы, гетты, дыриты,
она умеет атомарно сделать несколько мутаций.
Вы можете их сложить
в такой write-batch.
И вот атомарно его применить.
Еще
у вас есть
замечание,
как бы у нас оно не касается.
По умолчанию все эти путы, дыриты, они
асинхронные, но для наших целей
асинхронность не подходит, поэтому у нас все по умолчанию просто синхронные.
Ну а кроме того,
еще есть итераторы
и снапшоты.
Ну, с итераторами я бы так сказал,
глупо итерироваться,
опасно итерироваться по словарю,
которую вы меняете, непонятно, что вы получите.
Поэтому есть снапшоты, вы можете взять
и снапшот это снимок
состояния, то есть вы фиксируете текущее
состояние всего вашего хранилища, там лежит
100 гигабайт ключей значений, вы берете
и фиксируете это состояние,
а дальше по нему можете итерироваться.
Итерироваться и можете делать
сик, то есть прыгнуть
в нужное место к нужному ключу
сразу.
Предлагается
такой интерфейс
использовать у нас, то есть сделать функцию
makeSnapshot, которая строит вам снапшот,
а у снапшота можно
читать или строить по нему итератор,
а дальше с помощью этих итераторов
итерироваться по снапшоту,
при этом рассчитывая, что этот снапшот
не может меняться,
даже если с базой данных
после этого работают какие-то другие
пута и делиты.
То есть состояние базы может
меняться, а снапшот остается
в неизменном состоянии.
Ну и тут два вопроса.
Первый вопрос, как этим воспользоваться,
чтобы сделать
реализацию без бьютокса?
А второй вопрос,
как эта функция makeSnapshot работает?
Потому что она, кажется, берет снапшот
сталь гигабайт данных
и может быть не совсем понятно,
как это могло бы быть устроено.
Я предложил
на первый вопрос ответить самим,
нам,
написав код.
Второй вопрос
я собираюсь объяснить, но
он касается...
он с первым тоже помогает вам,
но и это полезно само по себе.
Итак, мы хотим разобраться,
как в LSM можно сделать снапшоты,
насколько это дорогая операция.
Я вам буквально предлагаю
на каждый запрос создавать по снапшоту.
Это не выглядит
как чего-то очень дешевое, потому что
за снапшотом 100 гигабайт данных
непонятно, как можно было бы эффективно.
Но тем не менее, мы собираемся
это сделать.
На каждую нашу операцию,
которую мы выполняем с нашей системой,
мы хотим строить...
на какие-то операции мы хотим
строить снапшоты.
Итак, давайте
быстро вспомним, как
работал
LevelDB.
Это был
LSM.
Мы сказали, что
в нем есть операция put
по ключу записать значение,
есть операция
delete,
удаление ключа есть, операция
get, поиск по ключу.
Но есть еще вот эти
итерации снапшот.
Мы сначала
решили такую задачу. Сказали,
что пусть у нас есть...
Пусть у нас набор данных
иммутабельный,
пусть у нас есть
киты, которые должны выполняться
быстро,
но и мы должны хранить данные надежно
на диске.
Вот эту задачу мы решили с помощью
SSTable,
сортированного файла.
Мы побили его на блоке,
запомнили для каждого
блока
его граничные ключи,
и построили разреженный индекс
в памяти,
в памяти, разумеется, который по
вот этому первому ключу ставит
в соответствие offset файле.
И когда мы быстро
должны были что-то найти в этом сортированном
файле, мы искали блок подходящий,
его читали, и в нем находили уже
нужный ключ.
Дальше мы сказали, что давайте все-таки у нас данные
будут мутабельные, мы хотим
делать много путов и хотим
по-прежнему durability.
Но при этом нас совсем не беспокоит
время гета.
Тогда нужно организовать данные
по-другому, нужно сделать append-only-log.
Приходит новый пут,
и мы его помещаем просто в конец лога.
Делаем append файл.
Вот.
А когда мы делаем get, мы этот лог сканируем
сначала и просто ищем последний
пут в этом логе для данного ключа.
Это неэффективно, поэтому мы
говорим, что давайте это ускорим,
сделав maintainable.
То есть контейнер
в оперативной памяти, который просто
дублирует содержимое лога.
Когда мы кладем что-то в лог,
мы
сначала кладем
запись в...
Когда мы кладем что-то в lsm,
мы кладем это в лог,
а после этого кладем
в memtable.
Получается вот такая вот конструкция.
Диск RAM.
На диске лежит лог.
Все путы попадают в него.
А после этого попадают в memtable.
Когда мы что-то ищем,
то мы идем, конечно, сразу в memtable.
Ну и все бы это работало, если бы
memtable, если бы память была бесконечная,
но memtable заполняется,
и мы воспользуемся первым
представлением данных,
мы сбрасываем memtable на диск
в виде этого сортированного файла
sst.
И после этого можем
дропнуть весь лог.
Ну потом memtable
снова заполняет память,
мы дампим его
еще раз,
а потом сливаем вот эти маленькие
memtable в memtable
в sstable побольше.
У нас получается такой каскад
этих sstables.
Ну и мы ищем сначала в memtable,
а потом если не нашлось, то мы где-то здесь.
Вот такая была конструкция.
А теперь мы хотим
путы get понятны,
делать delete тоже понятны,
мы говорили, что это пут просто с некоторым
специальным ключом томстованным,
который говорит, что запись удалена.
Мы не можем ничего удалить, потому что
у нас много данных в умутабельном состоянии,
мы не можем из сортированного файла ничего из середины стереть.
Так что мы просто делаем новую запись, которая
пропихивается через весь этот каскад
и за собой все стирает.
А теперь мы хотим
к этой конструкции добавить снэпшот.
Мы хотим захватить состояние
структуры данных в какой-то момент времени.
И это выглядит довольно дорогой операцией.
Дорогой, если не думать.
А если подумать, то мы сразу увидим,
что задача-то фактически уже решена.
Потому что
снэпшот это некоторое имутабельное состояние
текущее.
А у нас в LSM и так
большинство данных хранится в имутабельном состоянии
в виде sstables.
Это нам очень подходит для снэпшотов.
Делать даже ничего не нужно.
Но есть вот этот memtable
и вот он часто меняется.
Как заснапшить снэпшот с memtable?
Ну не то чтобы мы хотели бы взять его
скопировать в памяти, потому что
память у вас может быть много.
Память у вас может быть очень много.
Оперативной.
И вы там не будете
копировать десятки, сотни гигабайт.
Мы хотим операцию снэпшот,
которая очень дешево.
Поэтому что мы сделаем?
Ну может кто-то знает или кто-то понимает, что
нужно делать.
Ну вот тут какие-то номера берутся. Не совсем понятно как их использовать.
Ну вот предлагайте делать следующее.
Давайте
мы все путы пронумеруем.
Вот каждый пут в memtable
и вообще в это хранилище, он будет получать некоторые
последовательные номер.
Всяма на одной машине живет.
Сделать так несложно. У нас будет
sequenceNumber.
Вот для всего LSM есть
некоторые текущие sequenceNumber.
Когда мы делаем пут какой-то, мы берем
увеличим его на единицу.
Наш пут с текущим значением ассоциирован.
Если мы делаем
сразу серию апдейтов,
то там тоже можно учесть.
И
внутри memtable
ну да,
он вроде бы хранит пару ключей значения.
Но под капотом
он хранит не совсем те же самые ключи
значения. Ну значения он те же хранит,
а ключи у него другие.
Когда мы делаем пут
вот ключа K по значению
V,
то мы трансформируем его в такой вот
волнистый пут,
где в качестве ключа будет пара
ключ и текущий
sequenceNumber.
И вот этот memtable
будет упорядочен по вот такому составному ключу.
Как это нам помогает?
Задача уже решена, в общем-то.
В таком подходе
взять снэпшот всего хранилища.
Это значит просто
прочесть текущий sequenceNumber.
Вот просто снэпшот
это чтение sequenceNumber.
Фиксируем его, запомнили все.
Как сделать чтение?
Вот мы приходим
и собираемся читать по ключу.
Как нам быть?
Сейчас.
Во-первых,
в levelDB
операция чтения получает параметры.
И там указан либо снэпшот, либо
используя текущий снэпшот.
То есть операция чтения
всегда с некоторым sequenceNumber, либо
из снэпшота, который мы запомнили раньше,
либо мы просто выбираем текущую версию.
То есть у нас всегда это
некоторый get
с волной от ключа k
и некоторого значения s.
Читаем все,
в смысле 100 гигабайт из памяти оперативный.
100 гигабайт ключей читаем или что?
Так а не факт, что он такой есть
в базе.
У нас этот s апдейтится
на каждый пут. Мы может быть
сделали 100 путов с какими-то другими ключами,
а теперь мы ищем с тем же ключом.
В смысле?
Ну вот, да. Мы пользуемся тем, что у нас контейнер
упорядочен и упорядочен по вот этой паре ks.
И когда мы ищем
по ключу k что-то в текущем снэпшоте
с sequenceNumber s,
мы просто в ментейбле
ищем ключ,
максимальный ключ,
который меньше, чем наш ks.
Ключ, у которого первая компонента k,
а вторая компонента
максимальная, не больше,
чем s.
И вот мы теперь...
И разумеется, так можно и итерироваться по снэпшоту.
То есть у нас с ментейбл меняются,
там появляются новые
те же самые ключи с большими
sequenceNumber,
но со старыми остаются,
и мы можем при итерации просто их скипать.
То есть сам контейнер
не умеет скипать, он умеет просто проходить
по всему, что есть, но вы в итераторе просто
смотрите, почему вы идете, если вы видите большой
sequenceNumber, то вы его выпускаете и даете пользователю.
Если маленький
sequenceNumber не больше, чем ваш номер
снэпшота, то вы даете пользователю
запись.
А с сестейблом еще проще, потому что там
просто все имитабельно.
Ну и то же самое.
Взятие снэпшота это супер дешевая
операция. Это просто взятие...
Мы запоминаем sequenceNumber.
Ну под капотом LevelDB
хранит так, да.
Это внутреннее представление, ты нигде
к этому всему, ты с этим напрямую нигде не работаешь.
То есть у тебя есть просто put, get,
delete в API, и ты про вот эти
sequenceNumber ничего не знаешь.
LevelDB сам все это нумирует.
Ты не можешь подставить какое-то свое
значение.
Да нет, конечно.
У тебя же ключи маленькие,
они...
Ждем.
Эх, упала.
Она могла ехать вниз.
Но нет.
Мы же теперь не можем спокойно
мержить.
Нет, в смысле, мержить-то
мы можем,
но аккуратно нужно знать
какие снэпшоты в хранилище есть.
Давайте я вот LevelDB немножко покажу,
чтобы мы видели,
что я вам нигде не наврал.
Ну вот,
когда мы что-то читаем,
то смотрите, мы берем readOptions,
и если в
options есть снэпшот,
то мы...
Вообще, что такое снэпшот?
Давайте
посмотрим сначала.
Snapshot — это структурка,
которая...
Ну, есть интерфейс снэпшот, у которого кажется
у LevelDB есть интерфейсная часть,
и сейчас
вернусь сюда.
Вот, есть интерфейс снэпшот,
в котором ничего нет.
То есть пользователь с ним напрямую
не работает.
Он может его только получить,
но он не может это сделать.
Он может его только получить,
вызвав
соответствующую функцию.
Ну и может его потом...
Может сказать, что он больше не нужен.
Но этот снэпшот, он для пользователя не прозрачен.
Его можно передать в Get,
и тогда
в Get он
скастется к снэпшот импл,
а в снэпшот импл у нас...
лежит этот самый sequence number.
То есть вот снэпшот —
когда вы делаете снэпшот, вы буквально
получаете один sequence number.
Вот.
Так что эта операция очень деш...
очень дешевая, и можно
звать ее, ну,
скорой годно часто.
Можно хоть там на каждую маленькую...
на каждое маленькое чтение делать.
То есть можно каждое
чтение или каждую... короче,
каждую операцию на уровне вашей системы
ее выполнять надо каким-то снэпшотом,
строить его заново, потому что это
не требует никакого
чтения сканирования данных вообще.
Это всего лишь запоминание одного числа.
Ну и когда вы
говорите,
например,
когда вы говорите
write, то вы
sequence number глобально обновляете.
Вот вы где-то его читаете здесь,
а потом пишете
новый.
Когда вы читаете данное,
то вы берете этот sequence number
либо из снэпшота,
либо если вы снэпшот не передали,
то вы берете
просто текущий последний.
Ну а дальше
вы читаете
что-то из memtable.
И для того чтобы искать
уже в memtable вы строите вот такой
вот lookup key,
где у вас есть
ключ пользователя и снэпшот.
Это даже sequence number уже
а не снэпшот.
И этот ключ
он
он
сейчас сбился.
Он кажется определенно здесь.
Вот пользовательский ключ,
sequence number и из него составляется
внутренний ключ, который...
Вот описание формата.
И вот по нему внутри логически
все сортируется.
Да в общем-то идея
лежит на поверхности, на самом деле,
если вы хоть немного подумать,
потому что вы строите снэпшот,
это означает, что у вас есть старая версия данных
и новая есть, которую вы обновляете.
Поэтому это не могут быть одни и те же данные.
Вы должны как-то их дубировать.
Но делать это прямо
в момент взятия снэпшота
нельзя, потому что это бесконечно дорого.
Так что вы должны эту работу как-то амортизировать.
Вот вы и так ее делаете.
Вы строите мультиверсионное хранилище.
Правда в этом хранилище все эти версии
от вас скрыты,
а у вас задача сделать хранилище,
где у вас версии собственные
снаружи, и вы сами
управляете.
В этом оставшаяся
часть домашней состоит.
Как
поверх такого интерфейса
с итераторами и ключами
можно сделать
свое хранилище
с версиями.
То, что вы придумаете в нем
и можете написать, в этом Mutex
и не будет в этом решении.
Но в то же время возникнет другая задача.
Это все слишком абстрактно, потому что мы еще не придумали.
Давайте
вы это сделаете, а чтобы вам было
интересно, я могу вам что-нибудь за это пообещать.
Нет, но уважение само собой за такое.
Но уважение
в карман не положишь.
Балла тоже не положишь в карман, но все-таки приятнее,
чем просто уважение.
Так что
тут можно
поторговаться немножко.
Но мне очень хочется, чтобы кто-то попробовал, потому что
все остальное вроде бы в этой задаче мы понимаем,
как делать, а здесь
такая деталь, которая нам...
Мне это еще важно, потому что в будущем нам это понадобится.
У нас будут транзакции, а там все это
будет необходимо. Так что если мы сейчас сделаем,
то в будущем
это нам упростит, добавит
понимание в соответствующей теме.
Ну и просто, ты поставил киврию хранища, где ты Mutex берешь
глобально, ну что ты, что сделаешь?
Ты не должен быть удовлетворен этим.
Во-первых, она берет Mutex
только на запись, во-вторых, она может
бачить работу, точнее предполагается,
что в нее
на дней баченку выполняют.
Так что нет, конечно,
не берет она Mutex один.
То есть она берет, но аккуратно.
Ну или там может быть использована идея
flat-компания, когда ты берешь один Mutex
и под ним делаешь сразу много работы.
Это опять же очень
может быть разумно.
Ну и понимаешь же, тут
Mutex на запись это одно,
а ты берешь Mutex не на запись,
ты берешь Mutex на чтение плюс
запись, ну как будто у тебя
больше scope получается, и там уже меньше
оптимизации доступно тебе.
Так что ты делаешь хуже, ты баченку вообще
исключаешь из своего решения.
Так что Mutex, Mutex в розе.
Вот тут правильный Mutex.
Кого надо Mutex?
Кого надо Mutex?
Кого надо Mutex?
А вот сверх он уже
не такой хороший.
Ну что?
Прошло 3 часа, да?
С момента старта пары.
4 минуты осталось.
Если у вас нет вопросов,
то мы можем на этом сегодня остановиться.
