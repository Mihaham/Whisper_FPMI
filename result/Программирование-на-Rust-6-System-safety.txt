Начинаем нашу лекцию про System Safety. В этой лекции мы изучим систему типов RAST. Мы изучим то,
как RAST нам гарантирует safety, как он разрешает либо запрещает нашу программу. Также мы чуть-чуть
посмотрим на примеры того, как он unsafe нам может сломать программу, если мы им неправильно
пользуемся. Это конкретный наш план. Сначала мы узнаем, что такое lifetime. Потом узнаем,
как RAST все это время от нас прятал lifetime. В том числе, как он прятал lifetime в наших функциях,
в closures. Потом будет самая веселая часть лекции, subtyping и variance. В этой части лекции мы узнаем,
собственно, каким образом RAST гарантирует безопасность программы. Затем у нас будет
drop checker, ну и conclusion. На этот раз conclusion это будет не просто один слайд, а мы прямо обсудим,
как это все устроено. Еще раз посмотрим сверху. Попробуем на этот вопрос еще раз ответить,
чтобы как-то подытожить лекцию. Если что, таких лекций я в интернете по крайней мере не знаю. Так
что действительно мне пришлось ее делать с нуля полного. Большая часть основывался на RAST и на
Mecon, но если у вас будут вопросы, то говорите, это очень важно. Lifetime. Что вы знаете о lifetime за
время, которое вы писали что-то в домашнем? Например, когда ссылки надо куда-то там
прообразывать? Получается lifetime, и у вас решались по большей части, что компилятор попросил, кто и написал.
В каком-то смысле это хорошо, потому что я так и планировал. В каком-то смысле плохо, потому что мы
не разобрались с такой достаточно фундаментальной частью языка, которая иногда в нем возникает,
и вам приходилось мучиться. Это, наверное, то, что я не показал на первых лекциях, это какая-то
моя ошибка. Давайте для начала в общих чертах поговорим про RAST. У каждого языка есть какие свои
цели, которые он преследует. Если вы пишете на плюсах, плюсы это язык, который в первую очередь про
зеркал Abstr, про то, что был быстрый код и все такое. У RAST есть три конкретные цели. Эти цели
определяют то, каким он является, какие у него сильные и слабые стороны. Три конкретные – это
Performance, Reliability и Productivity. Performance – это как раз про скорость, про то, чтобы быть таким же
быстрым, как C, C++. Reliability – это то же самое, по сути, что и Safety – дать вашей программе возможность
быть безопасной. Не стрелять по памяти, не вызывать какой-то unsafety, не ломать вам прот,
не вызывать defined behavior, чтобы потом было больно добажить и вылавливать случай, на котором вы
собственно сломались. Ну и Productivity. Наверное, Productivity – это, наверное, та вещь, которую вы
пока что не заметили, пока вы изучали RAST. На самом деле, это RAST – это такой язык, на котором очень
быстро можно писать код, очень быстро писать приложение. Не так быстро, как на Python, но вообще
язык очень продуктивный по сравнению с теми же плюсами. Вы можете переиспользовать какие-то крейты,
буквально там написать манифесты, после этого – оп-оп, все компилируется, там быстренько собирается,
и вы пользуетесь какими-то уже продвинутыми фичами. Можете заимпортить целые вебсяки,
чтобы прикрутить. Ну это то, что вы поймете, наверное, в тот момент, когда вы перестанете уже
бороться с боровым чекером и увидите остальное преимущество языка. Ну как я говорил, мы тут
собираемся обсуждать преимущественно систему типа RAST и то, как она будет соединена конкретно с
performance и safety. Есть разные ошибки в memory-safety, это не полный их список, но вот это те, которые
мы будем преимущественно расследовать на этой лекции, как от них избавляться. Например, double free,
null pointer, dereference, aliasing и прочее. Первое очень легко фиксится даже в плюсах, вы просто
пользуетесь EDOM и RAE, у вас все хорошо получается. Ну то есть довольно сложно сделать не exactly one
free, когда у вас хорошо написан код, и вы пользуетесь RAE, то есть тот код, который вы здесь используете.
Поэтому в какой-то смысле это проблема решена, в том числе уже в плюсах, не все, все нужно это руками
все еще менеджить. Кстати, совсем недавно была такая новость, вышел язык, называется hair,
как вы читаете, hair, что-то такое, четыре буквы, h-a-r-y, вот. Этот язык такой с виду, это про abrasion
c, в котором есть defer, как раз, и обработка ошибок как растя с результатом. Это показывает какие-то
такие интересные направления в индустрии, что люди хотят избавиться, по крайней мере, от этих двух
ошибок так точно, то есть нормально обрабатывать эти ошибки, во-вторых, хотят поправить с точки
зрения double play. Вот, ну можете почитать, если вам интересно. Вообще язык, мне кажется, так как у него
фичей, в принципе, нет, наверное, мертворожден. Вот. Потом есть, ну, такие проблемы, как null pointer
вы можете, в принципе, проверять просто не null или ваш указатель. Да, это будет дополнительное
какое-то boilerplate, но вы можете это сделать.
Ну, в принципе, да, если ты записываешь, наверное, это не УБ, но если читаешь, то точно УБ.
Интересно. Вот. Ну, еще можно просто не создавать всякие null pointer, то есть гарантировать внутри
своего кода, что у вас не будет null pointer, в чем бы и нет. Ну, что делать с остальными ошибками? У нас
так много других ошибок в memory-safety, и все они, всем вам подвержены те же самые плюсы и си. Так. Как вы
знаете, конфиляторы хотят оптимизировать код. Ну и, в общем, мы хотим как-то удобно писать код,
и с другой стороны компиляторы хотят его оптимизировать. Так. Вернусь, Селен. Я потом скину
ссылку на него, если это... В общем, новости кину. Так. Вот. Почему нам важен алисинг? Потому что мы
хотим оптимизировать код и быть, с другой стороны, как-то несложно, чтобы наш язык был. Мы не
писали на ассемблере, и в том числе он был быстрым, потому что компиляторы как-то хотят оптимизировать,
а мы хотим писать читабельнику. И одна из проблем, которая тут может возникнуть, это алисинг. Вы с ним
уже однозначно знакомы с курса Minimacos, Restrict указателей и все такое. Мы рассказывали про эту
проблему и про то, как она мешает оптимизировать компилятор. В том числе мы сейчас посмотрим на
один из примеров. Ну, так как мы в расе хотим быть быстрыми, давайте мы подумаем о том, почему для
нас вообще важно понятие алисинга. Давайте рассмотрим вот такую вот функцию. Эта функция принимает
на вход какой-то U32 и output mute U32. Мы проверяем, что у нас там за input, и соответственно с тем,
какой у нас input, у нас получается какой-то определенный output. Здесь можно обратить внимание на то,
что если у нас input больше чем десятка, то в таком случае у нас output обязательно единочка. Ну как,
двойка. Мы хотим, естественно, этот код оптимизировать примерно вот так вот. Это то, что примерно хочет
сделать компилятор, когда он смотрит на такой код. Компилятор хочет сделать такой код. Если больше
десятки, сразу же двойка. Иначе мы проверим только тогда пятерку. Достаточно лишней инструкции
исполнять нам не хочется. Если мы сделаем эту оптимизацию в других языках, в частности,
раз уж мы так постоянно сравним с плюсами C++, то этот код не будет безопасным, потому что если вы
передадите две одинаковые ссылки, то в таком случае код будет просто некорректен, потому что вы
будете менять output, который меняется через input. Наоборот input меняется через output.
Соответственно у нас результат второго if, а в случае, если у нас две ссылки одинаковые, будет
другой. То есть если мы больше десяти, мы станем единичка, и после этого больше пяти не выполнится.
Вспомнили про алисинг?
Это не вспомнил или как?
Я, конечно, говорю про пересекающийся регион памяти сейчас.
А почему это в Rust будет безопасно сделать?
Да, если у нас там mute-borrow, то соответственно мы уже input просто не сможем создать. Или если мы
создали input, мы уже не сможем создать output, поэтому у нас одновременно две ссылки на один регион памяти
в рамках Rust существовать не может. Поэтому мы можем сделать такую оптимизацию в рамках компилятора.
Вот как я говорил на одной из прошлых лекций, у нас компилятор Rust, он повсюду вставлял те
рестрикты, в итоге ломал LVM. Сейчас LVM чуть-чуть починилось, и там включено в зависимости от того,
с каким вы компилятором компилируетесь Rust. Потом в конечном итоге, может быть, навсегда включат,
но это зависит от того, какой у нас будет прогресс в LVM. Вот это все правило, которое мы все это время
обсуждали, называется на самом деле AXM, aliasing-sormitability, то есть либо мы имеем aliasing,
несколько ссылок, shared ссылочек, те, которые не мутабельные, либо одну мутабельную ссылочку.
Этого вы можете часто встретить в статьях AXM, в том числе в госсеселях, которые, я надеюсь,
мы на следующей лекции успеем пройти. Алисинг, анализ, в общем, анализ aliasing очень важен,
он дает возможность сделать некоторые важные оптимизации. Некоторые из них я тут скопировал
Rastonomecon, чисто для примера. Например, что мы можем, например, убирать всякие записи,
если мы после этого не делаем никаких частей, не гарантированно. А так бы мы уже не могли так
сделать, потому что у нас есть aliasing, поэтому могут возникнуть проблемы. Так,
наконец мы сейчас закончим общее обсуждение Rasta. Несмотря на то, что мы все это время знали об AXM,
мы не знали, как это все работает, как Rast проверял наш код на окрестности. На самом деле,
вот давайте такой вот есть известный факт, каждая система типов, в том числе система типов Rasta,
которая есть, она гарантирует, в общем, разрешает какое-то множество программ и запрещает какое-то
множество программ. Мы, естественно, хотим, чтобы у нас в идеале запретились все неправильные
программы, разрешились все правильные. Правильные с точки зрения того, что мы хотим системы типов.
В плюсах, например, у нас нет memory-safety, поэтому в принципе memory-unsafe программы там валидные.
Вот в Rast такие программы уже не будут валидными, они просто не скомпилируются, потому что система
типов вам не позволит. Вот давайте сейчас выясним, как это работает. Две самые главные
проблемы среди тех из списка, которые мы рассматриваем. Это invalid memory-access и use-after-free.
Кстати, еще были data-race в том списке. Если что, мы про них поговорим на следующей лекции. Мы
memory-safety разберем на этой, а потом на следующей прям красиво посмотрим на то, как вывозится из
memory-safety в однопоточном случае и memory-safety в многопоточном, буквально введением двух трейтов.
Давайте разберемся с тем, как вы сделали так, чтобы у нас не было доступа к неправильной памяти и
чтобы у нас не было use-after-free. То есть, я имею в виду, вы здесь используете память, которая не
интеллигирована, например, в втором случае, когда у вас уже, понятное дело, например, вектор удалился
и вы им пользуетесь дальше. Как вы думаете, как же Rast это определяет?
Конечно, раз уж у нас лекция в большей части про lifetime и ответ lifetime. Rast это делает через lifetime.
Неформально. Там есть прям формальное определение через логику, но для этого нужно почитать статью,
которая формально доказывает, что Rast безопасен. Есть такая, показывала в первом лекции. Lifetime
это какой-то именованный регион кода. В чем-то произвольный регион кода. Настолько произвольный,
что в нем могут быть дырки или он может, например, если у вас if, то внутри у вас может одного
бронча примерно существовать, а внутри другого уже нет. Сейчас посмотрим на конкретные примеры,
как это работает. Фундаментальная идея такая. Давайте мы каждому объекту скажем, он живет
внутри вот такого вот lifetime. Если он живет внутри такого lifetime, то соответственно все ссылки не
могут его переживать. Соответственно у ссылки будет какой-то lifetime, то есть мы будем привязаны
к кому-то региону кода и за этот регион кода мы выйти не сможем. Примерно такая идея. Это такое
с высокого полета. Примерно понятно? Давайте посмотрим, как, во-первых, объявляется lifetime.
Они объявляются через вот такой вот штрюшочек. Структура персона у нас есть. Есть first name, last name и они
обозначены lifetime. В структурах мы вынуждены это делать для того, чтобы мы явно показывали,
что структура зависит от этого lifetime. Сейчас будет чуть понятнее, когда мы начнем дальше обсуждать,
что значит зависит от lifetime. Вот, ну тут понятно. Так, важное замечание. Lifetimes,
они в общем-то не являются типами, но они являются частью типа. То есть, например,
I32 является типом, но тем не менее, например, ссылка с lifetime A на I32 и ссылка с lifetime static,
вы видели, наверное, когда-то static lifetime. I32 это, на самом деле, два разных типа. Просто банально.
Вот. Раст с помощью, как мы дальше выясним, некоторых макинаций делает так, чтобы у нас дальше
программа была безопасна. Как-то так. Я думаю, будет понятнее где-то ближе к середине лекции,
пока что так. Чуть туманно. В общем, lifetime – это регион кода и мы привязались к региону кода.
Плюс ко всему, это часть типа, которую мы тоже проверяем. В локальных скопах вам
никогда практически не приходится писать lifetime. Ну, вам же внутри функции конкретно не приходилось
писать, какой lifetime там у ссылки на str, например. Ну, потому что inference работает хорошо у Rasta,
в том числе lifetime выводы. Давайте посмотрим вот на такой примерчик. У нас есть x равный нулю y,
ссылка на x и z, ссылка на y. Как выглядит тут lifetime? Здесь lifetime очень простой. Это просто скоп.
Смотрите, lifetime a – это какой-то скоп, внутри него я объявляю x, равный нулю. Потом у меня внутри
появляется еще один новый lifetime. Пустой комментарий. Так. Вот. Еще один новый lifetime.
Внутри объявляется ссылка с lifetime b на x. И внутри c, где z – это ссылка с lifetime c на ссылку с lifetime b на i32.
Итак. Проблема в чем? В том, что вот этот вот lifetime… Ну, смотрите. Понятно, что происходит с x конкретно.
Он валиден только в течение этих трех строчек кода. Поэтому появился вот такой lifetime с трех
строчек кода. Потом есть y. Y у нас валиден на протяжении этих двух строчек кода. Поэтому мы указываем ему,
вот я валиден на протяжении b. Я не могу пережить b. Так. Потом есть c. Ну и тут то же самое. У нас
ссылка на c на ссылку с lifetime b. По сути, это означает, что мы валидны на протяжении lifetime c. То есть мы
здесь будем валидны только на протяжении одной строчки. Вот так вот примерно с регионами кода работает.
Очень важно сейчас понять, что произошло здесь. Да, мы ставим lifetime объектов, на которые мы… Ну,
lifetime и ссылок не должны перемешать lifetime объектов. Мы ставим, получается, меньше из lifetime ссылки
объектов. То есть здесь в теории можно и a поставить. Тоже корректно. Потому что мы можем
содержать ссылку как минимум на протяжении lifetime a. Так. Сейчас ты утверждаешь, что в объявлении y мы можем указать lifetime a.
Ну, конкретно в данном случае у нас будет именно lifetime b, но вообще, да, можем и a указать. Потому что
ссылка валидна на протяжении lifetime a. Но это ж правда, у нас объект не будет стёрт всё это время.
Поэтому мы будем валидны на протяжении всего a. И эту ссылку мы можем держать на протяжении региона кода a.
После этого момента мы уже будем не правы, если мы будем продолжать держать эту ссылку, иначе у нас
объект удалился, а ссылка осталась. Как-то плохо.
То есть по умочению до совершения нового lifetime мы можем чуть-чуть помочь и респректировать?
Ну, вообще, так. На самом деле, вот эти вот lifetime a, если что, это некорректный расход.
В локальных скопах они как бы существуют, но ты их не видишь. Их раз, на самом деле, вывозит сам компилятор.
Ну, конкретно, что значит вот эта вот штука? Я валиден на протяжении lifetime такого-то.
Здесь можно и a написать, как я уже сказал. Потому что наша ссылка валидна на протяжении всего lifetime a.
На протяжении lifetime b мы тем более валидны, потому что он меньше. Как-то так. А тебя понятно?
Окей, давайте второй пример. Он чуть-чуть, капелька сложнее. У нас будет какой-то x, z.
Z, кстати, не интеллизируется. Потом встанет y, и как бы представить значение y.
Ничего такого сложного не происходит. Просто вместо того, чтобы сделать let z равняется y снизу,
я let z объявил чуть повыше, не интеллизируем. Чуть пониже сделал так.
Оно рассахарится примерно вот в такую штуку. То же самое с x. Потом мне создается z,
который валидна на протяжении lifetime b. Обратите внимание, что Rust будет видеть,
что эта перемена не интеллизирована, и он не даст ей воспользоваться, например, где-то вот тут,
посередине. Он будет трекить это. А вообще эта ссылка до тех пор, в тот момент, когда она
не интеллизирована, она валидна на протяжении всего lifetime b, и даже lifetime a, потому что у нас
эта ссылка на x будет в конечном итоге.
Так, ну потом дальше мы создаем новый lifetime. Внутри у нас есть y, у которого lifetime b. Мы присваиваем
значение вот такой ссылочки на x. Да, кстати, он получается чуть-чуть приврал. Мы не на протяжении
lifetime b будем валидны. Сейчас скажу. Будем просто валидны на протяжении того, на протяжении чего.
А, все-все-все, все правильно. Я вам не соврал. Можете ничего не стараться изговорить. Все правильно.
Просто про свое значение y, на самом деле, там будет копирование. Я просто совмещал, что позабуду.
Ну, примерно как-то так. Если у нас есть ссылка с lifetime a на какой-то тип t, это означает, что ссылку
можно держать на протяжении lifetime a. Она валидна в регионе кода a. Как-то так.
Лайфтайм c? Ну, потому что, смотри, у тебя как раз… Да, это хороший вопрос. Если ты здесь напишешь c,
то в таком случае у тебя у y будет тип ссылка с lifetime c на y32. Ты будешь попытаться присвоить к ссылке
на b на y32. Если бы это было возможно, тогда бы ты к ссылку, которая имеет меньше потенциально lifetime,
смог бы присвоить к ссылке, которая имеет больше lifetime. И, соответственно, ты потенциально мог бы
сделать unsafety. Потому что ты бы был… Вот меньше lifetime, вот больше lifetime. Ты взял ссылку отсюда,
присвоил сюда. Соответственно, будет какой-то регион кода, в котором ты не валиден просто.
Ну, вообще, это не придется никогда самостоятельно выводить. Да, они выведутся, например, в компиляторе
как-то так. Как-то так все просто. Давайте попробуем найти вот эту ошибку. Для начала давайте посмотрим
на верхний пример. Какая тут ошибка? Да, мы возвращаем ссылку, например, из локального сколка.
Вот. И здесь мы отлично уже видим, что происходит. У нас есть b какой-то внутри. И мы пытаемся
из b вернуть ссылку с lifetime as, а у нас s живет на протяжении lifetime b. И, соответственно, получается,
что когда мы пытаемся вернуть ссылку на s, мы просто не можем расширить опять же эту ссылку,
как в прошлом примере. Она может иметь максимум lifetime b, потому что объект имеет lifetime b.
Так, все ли понятно? Вот это вот означает, что ты generic по lifetime a. Это означает, что ты принимаешь
ссылку с lifetime a на u32 и возвращаешь ссылку на какой-то объект, который имеет такой же lifetime,
типа str. Ну, конкретно в данном случае они не обязаны жить одновременно. Мы чуть позже
обсудим, но вообще тебе ничего не мешало в данном случае вернуть строку статичную,
какой-нибудь, hello world. Тогда бы здесь был статик lifetime и, понятное дело, статик lifetime живет
не меньше, чем lifetime a. И тогда бы было конкретно вернуть, ну, корректно вернуть эту ссылку.
Вот. Ну, конкретно в данном случае это означает, что мы как минимум должны жить не меньше,
чем a. Здесь мы живем не меньше, чем a какой-то lifetime, и здесь мы живем не меньше, чем a тоже.
Так, давайте четвертый пример еще посмотрим. Как вы думаете, как компилятор найдет ошибку?
Ну, вообще, с этим примером мы знакомы еще с первой лекции. Пытаемся запушить вектор тогда,
когда у нас есть на него ссылка. Смотрите, опять мы обессахурием, у нас получается lifetime a,
в котором валиден вектор, lifetime b, в котором появляется ссылка. Вот это вот напоминаю,
помните, мы дерево смотрели, на самом деле, вот эти вот квадратные скобочки просто синаптический сахар.
Поэтому оно быстро выглядит так. Потом у нас есть lifetime c. И вот проблема в том, что компилятор уже
в данном случае видит, что на протяжении lifetime b у нас есть ссылка с lifetime b, shared. Здесь внутри,
в lifetime c, ну, короче, внутри этого региона кода мы пытаемся создать вторую ссылку. Это некорректно.
Поэтому REST это запрещает. Чтобы создать эту ссылку, нам нужно выйти из этого региона кода
и создать ее еще раз.
А выйти мы не можем, потому что мы все предъявляем.
Да.
Как-то пока что просто, да?
Сейчас видите, у нас не важен мутабельный раз.
Да, здесь не мутабельная ссылка. Но когда ты делаешь дейтапу, то тогда тебе приходится
брать мутабельную ссылку на вектор, ты его мутируешь.
Сейчас покажите, где у нас, например, ссылка?
Вот смотри, x это первая ссылочка, видишь, вот дейта. Потом, когда ты делаешь push,
то ты должен взять, ну, помнишь мют селф ссылочка? Вот ты должен взять
мутабельную ссылку на дейта. Это вот обессахаренный вид того, как на самом деле работает
дейтапуш. Вот так вот. Вот тебе появляется тут вторая ссылочка, которую ты пытаешь
создать. И это невозможно в этом lifetime. В этом lifetime ты можешь создать только еще
широкие ссылки.
Сейчас, получается, пентаятор видит, что он пытается делать мутабельность
ссылку на дейта, но при этом он как-то по x знает, что он сделан из не мутабельной
ссылки на дейта.
Так, повтори, пожалуйста.
Смотри, мы в ассоциированной функции index передаем не мутабельность ссылки на дейта,
а результат сохраняем как под именем x, а последняя страница как будто бы эта ссылка
куда-то ушла.
Ссылка никуда не ушла, она же живет на протяжении b, она вся валидна на протяжении b.
А, вот эта ссылка, которая...
А, вот эта вот b дейта?
Да, я...
Нет, ты ее передал, а она сразу же умерла здесь.
Все, ну ты ее как бы создал и вернул.
Сейчас, а как тогда компендатор понимает, что x все еще сделан из дейта?
Ну, это выглядит как какой-то просто corner case, который нужно разобрать во время
создания самого нового скоба lifetime.
Ну, смотрите, мы уже можем обратить внимание после всех этих примеров.
Так выглядит, будто LED это у нас...
Это у нас штука, которая объявляет новую власть в видимости.
Собственно, нам важна только первая строчка.
В этом смысле.
Вот первые строчки я знаю, например, у меня создается x с lifetime таким-то ссылочком.
После этого я, например, знаю, что все, у меня больше много будет дальше
только шире ссылки на протяжении lifetime.
Вот, что-то еще хотел сказать.
А, вот.
А, я, кстати, тебе соврал.
Она не умерла, конечно же, ссылка.
Ты заборвил дейту.
Но при этом у тебя появилась x.
Это какая-то другая штука, отдельная.
Но она имеет тот же lifetime.
Из-за этого получается, что ты не можешь создать еще одну ссылку mute на дейту.
Потому что это ссылается как бы на это.
А не с одним lifetime, соответственно, ты заборвил дейту.
Тут самое важное, что нужно обратить внимание, это на то, что
мы на самом деле ничего не знаем о том, что мы конкретно вектором пользуемся.
Нам по барабану.
Вот это тебе вопрос, да.
Из кода не понятно, что мы...
И дальше по коду не особо понятно, что мы вектором пользуемся.
Ну, то есть дальше будет еще один пример, мы это еще отработаем.
Но тут суть в том, что конкретно b здесь повторяется, конечно же.
Так, важно, никто не теряется.
Очень важно.
Вот lifetime может быть более, чем scope.
Здесь я обессахарит при всем своем желании не смогу.
Ну, смотрите, у меня вот здесь вот создается какая-то ссылка на x.
Внутри, если сам condition выполняется, вот здесь вот x у меня используется.
А вот здесь вот и не используется.
И конкретно регион кода будет выглядеть так,
что я валиден на протяжении от x до конца ifa,
не так, я буду валиден в строчке, где x объявляется, естественно, это 100%.
И буду валиден вот в этого части ifa.
А вот здесь вот меня не будет.
То есть lifetime выглядит, сворачивает просто.
Это регион кода, это не просто scope, как мы до этого посмотрели, примерно.
Это регион кода, в течение которого мы валидны.
Как-то так.
Но более того, мы еще можем иметь дырки.
То есть, смотрите, вот у нас полный линейный код.
У нас тут x опять ссылочка, мы там выводим этот x.
После этого мы сделаем data push и опять все что-то присваиваем.
Это все тип один и тот же.
Мы же let mute x сделали, да?
Это все один и тот же тип.
Ну, как-то так.
Я ее здесь вот мутирую.
Это вся та же самая ссылка.
Но здесь вот мы не валидны.
Это валидно сделать push, потому что я делаю после этого новый x.
За счет этого компилятор может сделать дырку.
Мы понимаем, что мы дальше не пользуемся старым значением.
Мы просто его убираем.
И вот здесь мы делаем дырку.
Мы понимаем, что мы дальше не пользуемся старым значением.
Мы просто его убираем.
Вот, да, это как раз то, что я хотел сказать.
Let создает новую область видимости.
То есть внутри локальных скопов, когда вы пишете let,
у вас создается какая-то область видимости, какой-то lifetime.
Какой-то регион кода становится местом,
который может жить и использоваться валидно.
К сожалению, бров чекер – это не идеальная вещь.
Он умеет запрещать код.
Умеет, может, будет запрещать код, который, кажется, должен был бы скомпилироваться.
Это один из примеров, который, возможно, конкретно данный пример,
когда-то перестанет, ну, начнет компилироваться,
но сейчас он пока что не компилируется.
Как вы думаете, что здесь происходит?
Не, ну, когда что-то происходит, понятно.
Мы пытаемся достать значение из макро,
если не получается, то вставляем дефолтное,
возвращаем дефолт, ну, ссылку на него.
Так, давай, более четко покажем, нигде проблемы.
Ну, ты так уманно сказал, но ты мне уже наскорчал.
Ты что, у нас сошло, ну, делайте нигде проблемы.
И чтобы сканировать объект, требуется ссылка.
Не, нужна просто обычная ссылка на объект, чтобы сканировать.
Ну, тут, если что, ошибка не в KeyClaw.
Если что, вы, если что, никогда не пишите getDefault.
Если что, в мэпе, хэшмэпе можно написать entry,
а после этого orDefault написать, или orInsert.
Это все будет работать прекрасно.
Или orInsertWidth, по-моему, еще есть.
Ну, в общем, есть целый API, который вместо этой функции можно использовать.
Ну, что-то такое.
Сейчас, где проблема?
Ты очень близок к проблеме, но компилятор нам все-таки,
ну, то есть это тоже проблемная строчка будет,
но компилятор все-таки на другой покажет.
Он покажет наверх.
Что произойдет? Вот, смотрите, у нас здесь getMute.
У нас здесь мутабельная ссылочка.
Создается на какой-то ключ, получается, на ссылку на MuteV.
Если у нас это какое-то значение, то есть у нас действительно есть
такой ключ, в том случае мы просто вернем значение.
Здесь компилятор спорить не будет.
Просто взяли, вернули ссылочку.
А вот здесь вот дело в том, что наша ссылка на MuteV
полидна в течение всего матча в данный момент.
В течение всего. И, соответственно, когда вы попробуете сделать
mapInsert, то, соответственно, здесь вот будет MuteСсылка.
И здесь вот будет MuteСсылка.
А если бы мы MuteInsert закомментировали, то по-прежнему?
Ну, по идее он должен сказать, что он, мол, пытается getMute сделать еще раз.
Ну, это вещь, которую, скорее всего, когда-то починят
и сделают так, чтобы там умнее был BorrowChecker, скидывал ссылки
в разных кусках матча.
Но пока что он продолжает lifetime объекта, который попадает
отсюда на протяжении всего матча.
Вот. Прямо вот так вот будет выглядеть ошибка к регуляции.
Вот как я и сказал, здесь вот getMute есть, у нас firstMutableBorrow
мэпа и потом secondMutableBorrow.
Так.
Еще вы могли заметить, что REST от нас не требует
писать постоянно lifetime повсюду.
Мы иногда просто писали ссылку на что-то, и оно прекрасно работает.
Причем именно в сигнат рейф-функции.
Это называется lifetime elision.
Давайте мы изучим, как это работает.
В-первых, у нас есть понятие как input и output.
lifetime позиции. Давайте чуть конкретнее посмотрим.
Для всяких функций
input — это то, что, соответственно, написано вот здесь,
output — это то, что написано вот тут.
И эти lifetime позиции...
Конкретно покажите мне в данном случае, где lifetime позиция.
На принципе на слайде написано.
Где ampersand, там и lifetime.
Соответственно, здесь одна input позиция,
две output позиции.
Это такая формалистика чуть-чуть. Понятно, что здесь нет.
Для имплов, соответственно, все типы,
которые вы вводите, в дженерике пишете,
это все input.
Конкретно в данном случае у нас здесь, заметьте,
два lifetimes убрана.
А здесь вот только один.
Потому что для каждого объявления здесь вот есть input.
А, надо уже давать отдельную дженерику структуры
и отдельную дженерику рейфа.
И поэтому для каждого своего рейфа.
Так, ну давайте, это, на самом деле,
сфекция, так что давайте активненько работать.
Это вот простача часть реально.
Смотрите, для начала, для всех lifetime в input позициях,
вот как работает правило вывода lifetime,
каждая input позиция становится уникальна
в lifetime. Ну смотрите, у нас в принте одна есть input позиция,
и мы ее заполнили каким-то lifetime.
То есть мы написали вот такое вот, а компилятор, на самом деле,
не явно написал такое.
Здесь debug. Здесь у нас тоже одна input позиция только.
То есть несмотря на то, что у level нет никаких lifetimes,
компилятор посчитал, что это, в общем,
здесь lifetimes нет, все правильно.
Он только там, где нужно lifetime считает.
То же самое, например, если у нас две строчки,
то в таком случае он сделает два отдельных lifetimes.
Ну и, наконец,
третий пример.
Если у нас здесь уже один из lifetimes написан,
то в таком случае мы не считаем, что это lifetime position,
и мы скипаем его.
Ну что-то такое, просто где не написан lifetime, там компилятор,
а здесь input position.
Потом, если у нас есть точно одна input позиция,
то в таком случае мы
присваиваем всем output позициям
вот этот input lifetime.
Смотрите, у нас есть substring.
Здесь у нас только одна input позиция.
Соответственно, я написал здесь astr, и здесь тоже сделал astr
позиция всех. Если бы здесь было 10 строк, то все бы имели lifetime
штриха.
А вот это вот не сработает, потому что у нас две input
позиции. Соответственно, a, b, там компилятор не знает, что
вернется lifetime a или lifetime b, и говорит, не отказываюсь
выводить сам напиши. То есть, эти правила сделаны
для того, чтобы в большинстве случаев правильно
выводить, какие lifetimes вы хотите.
В принципе, правила очень простые, но их хватает
в большинстве ситуаций.
Потом, если у нас есть несколько input позиции,
ну одна из них self, то в таком случае
мы для всех output позиций пишем
именно lifetime self.
Логично предположить, что если мы входим
в какую-то функцию,
в таком случае мы, скорее всего, хотим что-то отself
вернуть. Поэтому компилятор поставит за нас ручками
lifetime на self позицию.
Например, в getnewt он просто
self
и в output позицию.
Также и в ARX у нас получается вот здесь
две input позиции.
Каждый из них мы дали свой собственный lifetime,
но так как у нас есть self, то мы поставили автоматически
все outputы.
Теми, какие у self.
Как так?
В противном случае это ошибка выводить lifetime.
Например, если у нас нет lifetime слева
и справа что-то есть, то когда компилятор не понимает,
какой ты вообще lifetime собираешься выводить?
Я таких не знаю.
Если это отдельно настоящая строка,
скорее всего это будет static.
А если это статическая функция
какой-то ерунды, то в таком случае непонятно,
какой именно lifetime там будет.
Compairs.
Еще, например,
итераторы тоже зависят.
Мы видели в примере с вектором, когда мы берем ссылочку
на вектор.
У нас была ссылка на вектор,
и с тем же lifetime мы делали обычную
shared отсылку.
Это все потому, что мы ссылались с lifetime на вектор.
То же самое итераторы делают.
Они имеют какой-то lifetime.
И по умолчанию, раз тот вас требует
их написать, но вы можете написать нижнее
подчеркивание и ему сказать,
выведите за меня по правилам lifetime и legion.
То есть он будет это считать, просто позиция какая-то,
как обычно выведу.
Это дженерик выведет сам.
Кстати, обратите внимание, тут же трешочек есть
перед underscope,
чтобы RAST понимал, что выводите именно lifetime.
Теперь давайте поговорим про некоторые
сложности с тем, как работать
с системой типа RAST.
Естественно, какие-то программы
будут поднимать неправильно.
Возможно написать программу, которая будет компилироваться,
но при этом семантически не будет верны.
Например, вот у нас есть byteEther,
который имеет какой-то остаток,
то есть slice внутри.
То, что мы делаем, это либо если остаток пустой,
то возвращаем нам, иначе мы берем ссылочку
на первый byte, reminder это все, что после первого byte
достаточно просто.
И даже будет в каком-то смысле работать.
То есть вот я сделал byteEther,
вот сделал reminder на какую-то
статическую строчку из единички,
это какая-то byteWrite строка.
Вот я вызвал next, и оно сработало.
Второй раз now оно сработало. Прекрасно.
Теперь давайте второй раз сделаем next.
Ну, конечно, не догадайтесь, что произойдет.
Ладно, догадайтесь, но вы не знаете, наверное, почему.
Потому что из-за того, что мы вызвали next два раза,
у нас не скомпилируется в данный момент программа.
Вот с такой вот ошибкой.
Что же пошло не так?
Раз нас измучил, да, просто написали какой-то
простейший итератор, и он просто заблокировал нам программу.
Как неправильно.
Как вы думаете, что произошло?
На самом деле мы знаем ответ.
В том блоке...
Волт подпозиционного проставил, у нас теперь...
Так, давай, полностью разведи.
Получается, он приводит lifetime
и проставил lifetime self
волт подпозицион.
Получается, мы дважды вызвали next.
Он нам вернул две ссылки
с одинаковым lifetime.
Это правда, вернулось две мутабельные ссылки
с одинаковым lifetime.
Две мутабельные ссылки.
Да, да, да.
Да, да, ну, в общем, ты абсолютно прав,
ты абсолютно правильно сказал ответ.
Да, сейчас вот
еще раз будет на слайдах, еще раз проговорим, давайте.
Давайте попробуем воспользоваться правилами lifetime
и legion, чтобы понять, что здесь конкретно происходит.
Выпишем для начала.
Прям с именами, чтобы было понятно.
Смотрите, ну, вместо A и B
я написал там remainder, чтобы было чуть понятнее.
Вот. У нас есть lifetime
remainder. Потом я беру
by theta с remainder. И смотрите,
по правилам lifetime и legion у нас одна input позиция,
здесь одна output позиция. Он берет
штрих A, вот сюда штрих A, штрих A.
Ну, я назвал, конечно, не штриха, а rself.
Ссылка на self. И смотрите, у нас возвращается
ссылка
rself на u8.
Это означает, что мы, если попробуем
второй раз вызвать next, в таком случае мы второй раз
попробуем заборвить mute self.
Это точно такой же пример, как у нас был
до этого с вектором, когда мы делали index
и, соответственно, мы заборвали по lifetime вектор.
То же самое мы сейчас по lifetime заборвали наш self.
Второй раз.
Так, так, что?
Да, это один и тот же lifetime
будет.
Ну, прям получится, смотри, у тебя в этом коде
у тебя будет by theta, у тебя, соответственно, там
откроется скоп какой-то, да, штриха, и потом
ты будешь дважды возвращать next от
next.
И потом ты будешь дважды возвращать next от
штриха bytes, ну там, ссылка
штриха mute bytes.
Да.
Да, абсолютно правильно. Нужно написать
remainder, потому что у нас byte вступает с remainder.
Мы бороем remainder, а не self. Мы не
iterator бороем, мы бороем то, что под iterator.
Вот. Ну, это как раз то, что мы
уже обсудили здесь написано на слайде.
В общем, раз считает, что наш
опшен возвращает ссылку на byte
iter, но на самом деле мы возвращаем ссылку на remainder.
Мы хотим это починить, конечно. Ну, потому что мы
только что нарушили xsm, причем нам раз-то верно показал,
что мы его нарушили. Вот давайте мы допишем
remainder, просто явно, и все заработает.
Теперь мы сможем запустить next дважды.
И мы будем с точки зрения rasta дважды
боровить remainder под ним. Ну, то есть там
будет shared boro и он, естественно, будет работать, потому что shared
boro может несколько раз делать. Все
логично.
А почему раз компилировал первые случаи
Итак, это кажется, это
потерялось. Да, это
это потерявшиеся какие-то слайды.
У меня есть подозрения, знаете, вот здесь вот
first case, я знаю, что тут должно быть. Здесь должно быть
про mysell, такую штучку. Давайте я посмотрю,
точно ли мы ничего не пропустили.
Наверное, даже проще вот сюда.
Такс.
Может быть, это просто... Ладно, давайте пока что
забьем. Если там не будет, то тогда
если что скажем. Вот, это слайды,
которые фафали не туда, куда должны были.
Достаточно сложно в техе на самом деле
регулировать порядок слайдов, чтобы они
копируются и так далее, потому что это...
Примерно понятно ли после этого, что такое
locktime? Мы пока что не претендуем на самое крутое
понимание того, как это работает после этой части лекции.
Мы должны просто понять, что у нас есть какие-то регионы кода,
в течение которых нас валидны переменные,
и мы делаем ссылочку, то на самом деле мы боруем объект,
который под ссылкой, внутри этого lifetime,
и проверяем с помощью BorrowChecker,
что мы на самом деле делаем либо много шер и ссылку, либо
одну мьюту. Это все.
Ну и естественно, заботимся о том, чтобы у нас
не переживали ссылки объекта.
Вот. Дошли до такой вот штуки
higherRankTradeBounds.
Давайте попробуем reimplementить
фильтр option. Фильтр
такая штука, которая принимает на вход какую-то функцию,
если она правда возвращает труд,
в таком случае мы возвращаем some value,
и при условии, что у нас value, конечно же, есть в option,
либо none. Вот. Смотрите на этот код,
понятен ли вы?
Не помнишь fntrade?
Да, помню.
Ну, было на лекции у нас, кажется, прошлый, наверное.
Да, на прошлый closures была первая часть лекции.
Вот. Это fntrade.
Вспомнил, да.
Вот. Принимаем на вход какую-то функцию, которую можно
вызвать, по крайней мере, один раз, но это неважно.
Не будем мы потом задумываться. Мы про lifetime тут думаем,
что у нас lifetime. Это, конечно, скомпилируется,
но давайте попробуем явно написать lifetime.
У нас получается какой-то option at,
а потом мы думаем, а как же нам написать lifetime
для fn1?
Какие у вас есть идеи?
Не важно. Можете мне говорить самое глупое решение,
даже если оно неправильное, мы его разберем.
Сейчас, погоди.
Оно простаивает lifetime b.
Ну, кажется, что вообще, ну, сука,
которую мы туда пигдаем, оно должно быть как-то подвесно
к lifetime option.
Сейчас, сейчас, сейчас, стоп. А хотя-то чем?
В каком-то направлении ты думаешь.
Да, нам, наверное, пофиг на lifetime.
Ну ладно, я ожидал услышать какое-нибудь такое глупое решение.
Давайте, зафигачим сверху фильтр lifetime
и запишем его сверху.
Ладно, давайте посмотрим дальше, что будет.
Вот. Как нам вообще это все написать?
В общем, первая же идея, которая приходит в голову,
наверное, неопытному пользователю Rust,
это написать сверху, вот здесь,
стрейшочек a, ну, fnfilter,
стрейшочек af, да, и после этого fnonce,
стрейшочек at, вроде бы.
Да, оно не согласуется с тем, что внутри.
Ну, давайте мы это попробуем один раз проделать,
раз мы начали.
Вот, у нас есть ссылочка a.
Да, и теперь получается, что мы возвращаем,
что у нас value из себя представляет
какую-то переменную с lifetime b,
потому что мы взяли self,
заметьте, мы self взяли по значению,
потом мы сделали let some value self,
здесь lifetime b в течение которого value валидно.
Потом у нас есть if, ссылочка на b,
value корректно, тогда вернет some value.
Вот, раз на этот код пожалуется,
в первую очередь, он скажет, что
у нас тенни живет достаточно долго,
что у нас value не способно прожить
на протяжении a.
Давайте я вам объясню, что значит
тенни может прожить на протяжении a.
Дело в том, что когда вы пишете lifetime
в генериках функции, то вы говорите про какие-то внешние
по отношению к вам lifetime.
А здесь происходит какой-то внутренний.
Вы не можете сослаться на внутренний lifetime, да?
То есть когда вы пишете
штрих a, то в таком случае это для input
аргументов, это про какие-то внешние lifetime,
которые у вас вызывают речь.
Вот, и здесь происходит какая-то
такая локальная история,
бы сказал Иван Генрихович.
Вот, ну давайте мы попробуем
компилятор зафигачить штрих a, он же так нам советует.
Оставили штрешочек a на t.
Все, как ты просишь, компилятор. Блин.
Вот, и получается такая история, что мы пишем
штрешочек a, и нам теперь утверждают,
что у нас lifetime,
ну в общем наша ссылочка, которая валидна
на протяжении b, как мы выяснили,
да, она живет меньше, чем a, а a это какой-то внешний lifetime.
А раз уж он внешний, то он живет, по крайней мере, на протяжении всей функции.
А у нас на протяжении всей функции
локальная переменная, конечно, не живет.
Ну, всей функции, в этом плане, переживает
функцию, прям ее вызвать.
Вот блин, да?
Ну, в общем, запомните.
Мы ему дали внешний lifetime, а он
что-то заведомо меньше. Да, да.
Именно так. Более маленький lifetime.
Вот. Соответственно, мы
ну вот, запомните, что
в агроментах функций мы говорим про какие-то внешние lifetime.
То есть, мы говорим про те lifetime, которые нам передают наши пользователи.
Вот. А
ну, а мы тут внутри хотим что-то локальное написать.
Ну, и в данном случае
ну, если бы мы написали а, то в таком случае
а должно было бы быть локальным lifetime.
Ну, к сожалению, это не так. Как же это решается?
Кстати, да, тут еще есть ремарочка
при том, как решать.
Раст, ну, вот мы начинаем потихонечку заглядывать за кулисы.
Раст четко требует от вас, чтобы вы написали
сигнатуру функции.
И input аргумента, и output аргумента, что там, конечно, выведет за вас.
Ну, вот.
Какие-то ограничения на lifetime, какие-то ограничения
на имплементацию трейтов объектами вы пишете функции.
И сигнатура функции должна четко задавать, как эта функция работает.
То есть, какие...
Например, если вы принимаете на вход статическую
строку, которые живет на протяжении a только,
и возвращаете строчку на протяжении a,
то она не может жить меньше. Она должна жить
как минимум как та строчка, которую вы передали.
То есть, идея
вся эта за Rast будет в том, чтобы
правильно, ну, не только что-то в локальном скопу сделать,
но и в том, чтобы понять, как у нас
работают сигнатура функции.
Если у нас сигнатура функции согласуется с тем кодом,
который вызывает,
то в таком случае у нас обязательно должно получиться save
приложение. Это формально доказывается,
но мы это не будем делать. Конечно, лекции у нас более-менее практичные.
Там прям кок, использовали язык,
доказывали все.
Это тоже такая ремарочка, что у нас
комьюнити тоже стремится
сделать так, чтобы у нас был такой readable code, но на самом деле
это не просто идиом, а это даже в каком-то смысле
это ограничение Rasta, потому что он вас заставляет
создавать понятные функции,
что и как они возвращают, и что и как они делают.
Иначе у вас просто разломается программа.
То, что ты не можешь возвращать авто, связано с тем, что есть
Type Inference такая штука. Там есть система типов
Hindley-Millner, как-то так называется,
и Rasta просто для того, чтобы выводить аргументы
в локальных скопах было удобно, требует от функций, чтобы
они точно указывали, что они возвращают.
И тогда тебе становится очень легко выводить.
Ну и авто, плюс не говорить ничего о сигнатуре функции,
просто потому что это плохо как-то
писать авто, и приходится человеку заглядывать внутрь функции.
Ну как же мы обсуждали на лекции?
Impel FM.
Вот так.
Это как решается эта проблема. Смотрите, у нас есть специальный
синтекс, который называется High-Rank Trade Bond.
Мы пишем, что наша функция
должна быть валидна для любого лайфтайма A.
Естественно, у нас там может быть
произвольным образом двигаться лайфтайма
внутрь скопа, но мы должны быть валидны для любого из них.
Поэтому мы пишем, что для любого лайфтайма A
функция ссылка
на tab будет коррект.
И это скомпилируется.
И это то, как это нужно написать.
Если вы хотите, конечно, указать лайфтайм.
В большую часть времени,
как я сказал, вот это вот пример, если вы не будете явно писать лайфтайм,
компилятор будет за вас HRTB
ставить.
То есть он будет
явно за вас выводить,
что там for, lifetime, и там такие же правила lifetime и legion,
как и у обычных функций.
Например, здесь одна input-позиция, он просто поймет, что ей нужно
зафигачить лайфтайм A и допишет сам за вас HRTB.
Эта штука очень редкая.
Это прям редкий покемон.
В стандартной библиотеке встречается только лишь трижды,
чтобы вы понимали.
Даже в этом вот случае, несмотря на то, что я показал такой пример,
где можно воспользоваться HRBT, в нем, на самом деле, HRBT не нужно,
потому что компилятор умеет выводить его за вас.
Это скорее нужно тогда, когда у вас функция будет принимать
несколько аргументов. Тогда компилятор с помощью lifetime и legion
не сможет вывести, скажет вам, напиши лайфтаймы,
а чтобы написать лайфтайм, вам уже может понадобиться HRBT.
Вот.
Понятно ли, что такое HRTB,
и зачем это нам нужно?
А в этих бандах можно писать не только лайфтаймы?
Нет, только лайфтаймы.
Это прям настолько захардкоженный синтакс,
в каком-то смысле, что если ты попробуешь написать тип,
то раз ошибку парсинга вообще выдаст.
То есть он даже не поймет,
что значит фор, открывающий кавычка,
без штышка.
Ну это все равно какой-то очень специальный и редкий синтакс,
поэтому, наверное, это все равно та вещь,
которая пользуется только профи.
Поэтому можно забить, возможно, о них.
Вот. Вопроски есть?
Так, у нас есть еще такая общая ошибка,
которую я с вами тоже хочу обсудить.
С ней сталкивалось в личке...
Я даже специально у людей порой спрашивал,
не считаешь ли ты, когда он мне спрашивает вопрос,
что T это только владеющий тип.
И мне обычно отвечали, да, я так считаю.
Давайте мы это рассмотрим.
Представьте, что у нас есть какой-то трейд,
мы написали в него три импла.
Для T, для ссылки на T, для muteT.
Когда вы пишете T, то в таком случае
вы на самом деле мачите вообще любой тип.
Это может быть любой T, например, это может быть I32,
это может быть ссылка на I32, это тоже какой-то тип T,
отдельный, другой тип, он тоже сюда подходит,
T32 тоже будет ходить сюда.
А вот если вы напишете ссылочку на тип T,
то в таком случае раз будет мачить только ссылочные типы.
То есть ссылка на I32, ссылка на ссылку muteT32
и подобное.
То есть когда вы дженерик по какому-то типу T,
то в таком случае вы, если не налагаете никаких ограничений,
то в таком случае вам подходит вообще любой T.
Ну и поэтому не удивляйтесь, например,
импульс для T и для ссылки на T какой-то фигни,
и она не скомпилируется, потому что она скажет,
что они друг с другом конфликтируют.
Потому что в T входит ссылка на T как под множество.
А можно ли писать более сложные мачи?
В каком смысле?
Ну, после фора писать ссылка на ссылку muteT?
Блин, не знаю. Наверное, можно.
Но я не буду гарантировать, нужно проверить.
Наверное, это примерно никому не нужно.
В принципе, можешь попробовать написать ссылку на ссылку на mute,
и я поставлю вероятность больше 50%, что оно должно сработать.
Это такая вот вещь получается.
Ну, соответственно, в T входит ссылка на T
и ссылка на muteT как два множества.
И они пересекаются, соответственно.
Потому что одно начинает с ссылки, другое начинает с ссылки на mute.
И в том числе в T входит какие-то типы,
которые не входят ни туда ни туда, например, 32,
потому что он не ссылочный.
Ну, соответственно, это как раз то, что я сказал.
Супер множество от ссылки на T на muteT
и то, что этим не пересекающееся множество.
Ну, если ты начинаешь ссылки, то уже точно может быть.
Ссылки на muteT 32 может быть.
А, ссылки на muteT 32?
Нет, такое не может быть, потому что это именно ссылка на T ожидаешь.
Это подойдет только сюда.
Ну, я бы даже сказал, мне больше нравится об этом думать,
как о pattern matching.
Ну, даже не так. Мы добавили ссылку перед T,
и вот теперь все T пробегаем.
И все T, которыми пробегаем, по сути, это вот множество.
Просто что перед ним теперь ссылка стоит.
Запомните, что T это не обязательно владеющий тип.
Это может быть ссылочный тип тоже.
Еще есть такая штука Unbounded lifetime.
Это lifetime, который больше всех.
Этот lifetime валиден на протяжении всей программы.
Он не налагает никаких ограничений на ваш тип.
Если у вас статик ссылка, то в таком случае
ее можно никогда не инвалидировать.
То есть, если до этого у нас была ссылка на A,
то в таком случае это означало, что мы на протяжении региона кода A валидны.
А если у вас статик, то вы валидны на протяжении всей программы
и делаете с этой ссылкой что хотите.
Никаких ограничений нет.
Вот частный случай, что у нас есть статическая какая-то строчка.
И оно все работает.
Еще, нам важно понять, что значит
T''A и ссылка с lifetime'ом A на T.
И чем они отличаются?
Скажите, вам в домашней программе приходилось писать
bound в духе T''A или self'A?
Кажется, в боре надо было.
Да, в боре точно нужно было такое делать.
Что это означает?
Это означает, что self должен жить на протяжении, по крайней мере, A.
Должен быть валиден, по крайней мере, A.
Более даже правильно сказать, академично,
это что все lifetime параметры T переживают A.
Что такое lifetime параметры?
Например, это всякие, если у вас там структура,
которая зависит от T'A, T'B.
Кажется, там дальше как раз должен быть примерчик.
Так что посмотрим сейчас.
Давайте поймем, что это значит.
Вот у меня есть какой-то trait, который требует lifetime'A.
И, соответственно, пишем where self'A.
Все, что делает этот trait, просто налагает ограничения.
И структура CRF, которая содержит какую-то ссылочку.
Смотрите, если я напишу, что мы generic по lifetime'у A,
соответственно, импрометирую этот trait для этой ссылочки,
то все будет правильно.
Мы же валидны на протяжении A, так?
Наша ссылка может проживать A.
Это правда.
А вот если мы потребуем lifetime static,
то наша ссылка способна только на протяжении A жить.
А мы хотим на протяжении всей программы.
Потому что наш тип живет только на протяжении A.
Так, да?
Что-что?
Не меньше, скорее.
Может, я подолбался?
Outlive, ну все правильно.
Переживает.
Может быть, self-static, но тогда все будет хорошо.
Impl'A require lifetime'A for Fstatic.
Это корректно. Потому что вы проживаете любой lifetime.
Переживаете все. Вы проживаете Вселенную.
Переживаете программу.
Так.
А что если с vect'A, например, сделать?
Мы написали require lifetime от vect'A.
То же самое, но только смотрите.
Наш vect'A ссылка A на I32.
Естественно, мы переживаем A наш vect'A.
Но мы не можем пережить static. Почему?
Потому что если наш vect'A будет жить больше, чем A,
то в таком случае у него будут внутри невалидные ссылки потенциально.
Это запрещает система типа Rasta.
Поэтому на самом деле
вот этот vect'A, который мы написали,
у T есть какие-то lifetime параметры, получается.
Которые мы не видим, но мы их тянем вместе с собой.
Более конкретно. Давайте посмотрим.
Вот есть Holder. У Holder'а есть какие-то две ссылочки.
Одна на str, другая на u, с lifetime'A.
Потом сами t и u есть.
И дело в том, что у t и u
тоже могут быть какие-то ограничения.
Например, t может быть ссылкой t на I32.
Ну, ссылка с lifetime'ом t.
Соответственно, наш Holder, который мы создадим,
раз за нас увидит lifetime'ы,
и поймешь, что Holder не может переживать
ни одну из этих ссылок.
Он выберет наименее строгую.
Ну, наиболее строгую, точнее.
Как-то так. Поэтому, когда мы пишем тип,
мы на самом деле тащим с ним lifetime'ы параметры.
Потому что мы не должны переживать этот тип.
Как вы думаете, что значит t статик?
Да, мы хотим, чтобы t жил всю программу.
Можете писать, сказать какие-нибудь примеры?
Так, а еще что-нибудь?
Глобальная переменная тоже подходит,
по сути, статические строчки.
Что-нибудь чуть-чуть менее тривиально.
На самом деле, вы с этим постоянно сталкиваетесь
со всякими t статиками.
Ну, давайте я ответ подскажу.
Например, во-первых, это означает,
что t не имеет никаких ограничений
по lifetime'ам.
То есть, это не значит то, что у него
не должно быть никаких штриха внутри.
Они могут быть, но эти штриха должны быть статик.
То есть, в итоге вывестись как статик.
Иначе мы будем жить меньше, чем статик.
То есть, по нашему определению получается,
что t можно валидно хранить
на протяжении всей программы.
То есть, нет никаких параметров,
оно верно в любом скопе.
Обратите внимание, у нас валидная t статик
это и i32, и vextring, и range, и size.
Это все правильно.
Потому что их можно хранить на протяжении всей программы.
То есть, например, i32, какие проблемы хранить
всю программу, это же не ссылка,
которая ограничена тем, на кого она ссылается.
У нас i32 — это прям владеющий тип, который имеет...
Ну, в общем, владеет данными.
Так что, по сути, t статик — это все владеющие типы.
В том числе всякие статические.
Какие-то такие вот дела.
Но при этом, несмотря на то, что t статик,
вы не обязаны это дропать
именно в конце программы.
Это означает просто, что нет никаких ограничений этого типа.
Вот.
Их можно и создавать, и удалять специально спокойно.
Ну и более конкретно.
Ta — это множество типов,
которые ограничены lifetime a.
Ну то есть, как минимум, переживают a.
Такое вот.
Ну и множество всех ta включает,
в том числе, ссылки с lifetime a.
Ну почему?
Потому что ссылка с lifetime a живет,
естественно, по крайней мере a.
Все логично звучит.
Ну и в том числе, например, в ta входит
статик ссылок.
Это тоже входит множество,
потому что она живет, по крайней мере, a.
Вот. Мы дошли до самой сложной части, Алексей.
Так.
Давайте перейдем к сабтайпингу.
Вы, когда смотрите на такое слово,
у вас есть представление, что это значит?
Хорошо, плюсовое значение.
Наследование.
Так.
Наследование.
И немножечко про мир виртуальных функций
и как варианты подрешаемых типов.
Да. Особенно слово «кавариантно»
сейчас мы будем смотреть на это.
Так. Вообще у нас в расе, как вы уже знаете,
нет наследования данных.
У нас есть наследование интерфейсов,
наследование поведения.
Вот. Даже несмотря на то, что его нет,
у нас есть понятие сабтайпинга.
Вот сейчас нам нужно запомнить очень практичное
и хорошее определение сабтайпинга.
Если мы его не запомним, то нам придется погрузиться
в теорию категорий. Я вам не советую.
Давайте мы запомним простое житейское определение,
чтобы в 100% случаях сработать на этой лекции
и в жизни потом же.
Сабтайпинг – это концепт, который означает,
что один объект как минимум настолько же полезен,
как и другой. At least as user.
То есть если у вас A под тип B,
то в таком случае A как минимум настолько же полезен,
насколько и B. Логично, да?
У нас есть животное, там есть кот, есть собака.
Здесь N потерялся.
Cat and dog – это подтипы animal.
Animal – это их супертип.
Понимаете, мы как бы наследуемся от animal,
у нас есть больше каких-то методов,
но мы по крайней мере настолько же полезны,
насколько полезен trait animal.
Мы умеем как минимум столько же. Мы умеем snuggle
и возможно умеем что-то еще.
Подобный код сработает потому,
что в расте сабтайпинг есть.
У нас есть динамический указатель на какой-то animal,
класс мы.
Динамический толстый указатель
на тип, который является animal,
то есть имплементирует animal.
У нас есть какой-то код, мы для него имплементировали
нужные трейты и после этого попробовали
вызваться от кота и это даже скомпилировать,
потому что кота можно использовать как животное.
Он же является животным,
поэтому все приведет раст и все получится.
Более того, у нас до этого
это было на плюсы похоже,
а теперь мы уже будем спускаться в то,
как это на самом деле работает в расте.
В расте у нас на самом деле lifetime тоже поддерживает сабтайпинг.
И более того, у нас сабтайпинг в расте
существует практически только для lifetime.
То есть то, что вы до этого видели,
это скорее исключение из правил.
На самом деле сабтайпинг, когда видите в расте,
это почти 100% речь про lifetime.
Давайте посмотрим такой примерчик.
У нас есть функция, которая принимает две строчки
и возвращает из них кратчешу.
У нас есть а, которая является статической строчкой,
и b, которая является какой-то динамической строчкой,
в которой мы создаем рамтайп.
Вызываем short статутом.
Во-первых, почему это компилируется?
Как вы думаете?
Погромче скажи, пожалуйста.
Ну да, правильные lifetime,
но вообще хотелось бы сказать,
здесь ссылка на static стринг,
здесь какая-то ссылка на какой-то a стринг.
Здесь мы засовываем, получается,
статик и засовываем a стринг.
И казалось бы, почему это работает?
Потому что статик приводится к a.
Логично, статик переживает a,
соответственно, какая проблема?
Мы скажем, что a живет, вообще не беда.
Да, и это очень важное замечание.
Статик – это под тип a.
И обратите внимание, статик больше lifetime,
но он под тип, он визуально выглядит так,
что статик содержит в себе всех,
и все для него под типы.
Но на самом деле прямо наоборот,
статик под тип всех lifetime.
Это самый частный случай.
Давайте мы теперь посмотрим
такой примерчик.
Мы можем потребовать lifetime,
чтобы он не строго переживал другой lifetime.
Давайте сначала посмотрим на сигнатуру foo
и поймем, что значит штрих b
до иточия штриха.
B – это какой-то lifetime не меньше.
Да, а в теории, в плане саптайпинга,
то есть b как минимум настолько же полезно,
насколько и a.
Это определение очень эффективно и хорошее.
У нас есть два lifetime,
и мы говорим, что b должен быть настолько же,
как и a, полезно, возможно, больше.
В данном случае это бесполезно,
но просто такой немножко искусственный пример
для того, чтобы показать вам,
как они друг с другом соотносятся в расте.
Ну и вот примерчик.
У нас тут создается строчка,
вторая строчка. У обеих разные lifetime,
мы их засовываем в foo.
Вот b в данном случае уже будет статик lifetime.
Не как в первом случае.
То есть напрямую подставится,
не будет ничего приводиться.
Ну смотри, у нас one – это best,
а 2 – это aster.
Смотри, вот этот 1 имеет lifetime a.
Ну пусть b – это будет lifetime a.
И вот смотри, вот он больше,
вот мы его засовываем сюда и вот сюда.
Соответственно, получается, b под тип a больше.
Все правильно. Соответственно, будет два разных lifetime строк,
когда ты будешь подставлять.
Это бы тоже работало,
просто тогда был lifetime, который вот этот более широкий,
он привел бы его в более момент.
Ну компилятор,
как я говорил, берет, смотрит сигнатуру функций,
все ли подходит. Он такой смотрит.
Ага, вот здесь у меня статик,
здесь вот штрих a.
И такой смотрит, подходит ли это под ограничение.
Ну вроде подходит, статик у меня по тип a, все хорошо.
Плюс смотрит на сигнатуру функций, действительно я возвращаю
штрих aster. Действительно, штрих aster возвращаю,
потому что у нас one как минимум уже столько же, сколько я.
Я, кстати, попрошу заметить, когда вы начнете этим пользоваться,
то вот эта вот возвращаемая строчка
будет жить только на протяжении вот этого вот скопа.
Потому что мы возвращаем штрих a,
и соответственно у нас lifetime будет такой же,
внимание.
Что-то такое вот.
Да, это было все,
что нужно было сказать про subtapping на самом деле.
Сейчас будет самое интересное, bearings. Потому что на самом деле,
когда мы говорим, что один lifetime под тип другого,
мы сейчас вычислим, как они на самом деле работают
относится друг к другу.
Вот, давайте попробуем поотвечать на некоторые вопросы, чтобы
приобрести понимание.
Такой вопрос. Статический lifetime под тип?
lifetime a?
Ну, ссылка на статический t.
Да, это так.
Это действительно под тип.
Да, ну как минимум настолько же полезно.
Неформально определение советуем пользоваться, очень хорошая штука.
Увидел когда-то на стримах Rast of Rast, и стало очень понятно.
Ну, там есть такой очень шаристый человек,
который в том числе написал книжку, одну.
Rast of Rastassians, очень советую.
Теперь, ссылка a, t.
Это под тип на ссылку a, u,
где t это под тип u.
Ну, мы же можем, ну да, это под тип действительно.
Мы можем же t привести к u, это же под тип.
Так, логично.
Окей, теперь у нас статик mute t.
Это под тип, ссылки a, mute t.
Тоже да, да, действительно, как минимум настолько же полезно.
А вот это, ссылка a, mute t.
Это под тип на a, mute u, где t это под тип u.
Ты проиграл.
Я вас всех обману, это не под тип.
И мы сейчас поймем почему.
Потому что это формальная математика.
Смотри, на самом деле программу мы можем сломать,
если мы такое разрешим.
И сейчас мы это увидим. Как?
Это может выглядеть не интуитивно,
но давайте такой, ну, для начала простой пример,
потом у нас будет в коде еще.
Предположим, что мы берем в какой-то функции ссылку
на mute vec astring.
Эта вот функция принимает на вход такую вот.
И мы засовываем туда mute static string.
В качестве аргумента.
Функция эта внутри будет думать, что
статик, оно же как минимум настолько же полезно.
Если бы мы разрешили это быть под типом,
то в таком случае мы бы могли
засунуть внутрь ссылку astring,
а не ссылку на static string.
Смотрите.
Наверное, живой более лучший пример.
Тут прикол в том,
что если мы такое разрешим,
то в таком случае мы сломаем нам программу.
Смотрите, вот этот как раз пример
инвариантности.
Вот так называемая инвариантность, мы сейчас разберем, что такое.
Когда вы будете просматривать лекцию,
еще раз, возможно, или слайды, то вы тут видите
инвариантности, и вы воскликнете, что я это понимаю теперь.
А не то, что в тот момент на лекции.
У нас есть вектор, который действительно
принимает какой-то вектор, ссылки на astr,
es, astr. И засовываем туда
вектор push.
Вот такой вот сработает первый вариант.
У нас есть ссылочка,
какая-то строчка, которая живет в какой-то lifetime.
Мы создаем вектор,
и потом пытаемся засунуть все это.
И это дело сработает.
Если вы думаете, что как бы непонятно,
как раз на это все посмотрят.
В данном случае a, который мы пытаемся засунуть,
оно вот здесь вот находится.
Потом, раз посмотреть на то,
какой вектор имеет lifetime.
Тут я, наверное, зря, конечно, не написал прям какой-нибудь
конкретный тип, хотя бы комментарий.
Что же тут произойдет?
Он просто посмотрит, что astr и astr совпадают,
и, соответственно, он выведет, что у этого вектора lifetime
век ссылка на astr,
а это вот lifetime ссылочки.
Как-то так это будет работать.
А во втором случае это уже не скомпилируется.
Смотрите, я создаю вектор со статической строчкой.
Этот вектор будет иметь тип век ссылки
на static str.
Потом я создаю какую-то строчку s,
тоже с каким-то ограниченным lifetime,
если бы мы могли использовать под тип,
смотрите, вот у меня a выводится,
он как бы раз смотрит на a,
ажка моя, и скопа вон там.
Если бы мы разрешили использовать под тип,
то в таком случае в качестве a мы бы просто static lifetime
сузили до a, ну какая разница, static же переживает,
и могли бы запушить сюда.
И это бы действительно скомпилировалось,
и соответственно, когда мы бы сюда вот вышли,
в таком случае у нас код просто бы сломался,
потому что у нас здесь у строка,
которая уже очистилась находится.
Да, это ровно то же самое здесь написано,
просто это пример.
Вот, соответственно, получается, что когда
речь про ссылку на mute,
t, то t, ну, в общем, нельзя приводить
к под типу, ну, к под типу нельзя, в более общем,
потому что иначе вот как в таком примере
это бы могло сломаться, и у нас бы внутри
была неволидная ссылочка.
На самом деле у этого феномена всего есть название,
называется variance,
и у каждого типа есть какой-то свой variance.
Ну, то есть это какая-то характеристика
типа.
Она определяет то, как похожие типы, скажем так,
друг к другу взаимодействуют, то есть под типы там
и супертипы относительно друг к другу.
Есть три разных типа вариантности.
Вариантность, инвариантность и контравариантность.
Теперь вот следим за слайдами, очень важно.
Нужно понять.
Вот.
У нас тип кавариантный тогда, когда мы можем использовать
под тип на его месте. Это самый общий тип вариантности.
Смотрите, у нас есть, например, ссылочка.
Обычная ссылочка a, t.
Мы получаемся кавариантный по a, потому что мы можем
использовать в качестве a под тип какой-то.
Можем использовать статик.
А t мы можем использовать какой-то под тип.
Если что, то, что я дальше вам
показываю, ссылка a, t.
Эти все вещи, кавариантность, инвариантность
и контравариантность, они на самом деле были выведены умными
дядьками, которые посмотрели, в каких случаях
дать максимум и при этом не сломать.
Поэтому то, что там, например, вот это кавариантное,
это как бы выведено просто
на риске бумаги, грубо говоря.
Что оно так должно быть, что оно никогда не ломает
и вот как-то так.
Ну и пример кавариантности, например.
В качестве кота я могу
засунуть и домашнего кота, который по типу обычных котов,
и просто кота, несмотря на то, что я принимаю кота,
потому что домашнего кота я могу привести к обычному коту,
использовать его по типу.
Это то, чтобы разрешить использовать
на месте супертипа его подтип.
То есть использовать
более общий тип на месте менее общий.
Ну точнее наоборот, менее общий тип на месте менее общий.
То есть, соответственно, animal у нас не сработает,
потому что animal не cat.
Typ invariantian, если он обязан
точный тип предоставить.
Без саптайфинга все типы
должны были быть invariantian.
И в первых версиях
все типы были invariantian.
Представить было, естественно, очень тяжело кота,
потому что lifetime не приводились.
Ну, в общем, один из главных примеров
в вариантности — это как раз ссылка mute на t.
Мы получаемся к вариантной посылке,
но мы действительно можем засунуть какую-то ссылку,
которая живет больше.
Но как мы выяснили, есть пример,
если мы разрешаем к вариантность по t,
в таком случае у нас получается засунуть, например,
менее долгоживущую строчку.
Поэтому было решено сделать invariant t.
Поэтому мы должны засунуть точно тип,
который нужен, то есть именно astro,
не меньше, не больше, именно его.
Если бы мы засунули больше, еще бы было нормально,
но меньше уже тем более плохо.
Так как есть случаи, в которых мы ломаемся,
нам приходится от системы типов расто приходить к консессу
того, что мы иногда можем сломаться,
если сделаем не invariantian, и все.
В том есть контравариантность.
Самая редкая штука в табличке.
Контравариантность – это наоборот.
Если ковариантность была про то, чтобы использовать
по типу на месте типа, то контравариантность наоборот,
а то чтобы использовать супертипы на месте типа.
То есть это в обратную сторону двигается.
У вас есть последовательность типов, т.е. текущий тип.
Если вот эта ковариантность,
вот эта вот контравариантность.
А invariantness – это точно тип, который нужен.
То есть, грубо говоря, два луча, смотрящие в разные стороны.
Ну и смотрите, единственный
источник контравариантности в языке –
это аргументы входные функций.
У нас есть функция at,
возвращающая u,
и мы ковариантны по t в данном случае.
Контравариантны по t, да.
Вот можно увидеть такой вот пример.
Вот сейчас, если честно, я и сам себе ломал мозг,
когда я пытался понять контравариантность.
И сейчас я тоже, наверное, чувствую, что я так сходу не скажу, наверное.
Ну, смотри, давай так.
Если у нас есть функция, которая возвращает цвет кожного покрова животного,
тогда, поскольку код является животным,
то функция, которая работает с животными,
является функцией, которая работает с котами.
Да, поэтому получается подтип.
Ну и соответственно, у меня есть один из примеров.
Вот этот более конкретный пример.
У нас есть контравариантность, которая принимает строго статик строки,
но мы можем засунуть именно ту функцию,
которую у нас просят,
которая принимает какие-то лайфтаймы меньше, не статические.
И при этом это тоже будет корректно,
потому что если мы работаем с любым лайфтаймом из этих,
то мы и статическим работаем.
Логично, да?
Да, соответственно, получается, что несмотря на то,
что у нас там статик стр, это подтип стр,
у нас функция от астр, это подтип статик,
функция от астр.
Вот в этом есть.
Должна быть обернута функция, если что.
Вот это единственный источник контравариантности в языке.
Больше нигде его нет.
Естественно, если вы напишете fnt в t,
то в таком случае вы получите инвариантность.
Потому что в одном случае контравариантный,
в другом инвариантный.
Соответственно, инвариантность всегда можно,
потому что это тот же тип, который вы просите.
Есть целая такая табличка.
Как я говорил, выводили у меня дядю.
Есть базовые такие типы в языке,
которые имеют заданные вариантности.
Эта табличка мне показывается скорее для того,
чтобы вы с ней ознакомились.
Когда она не нужна будет.
Это надо к экзамену учить?
Экзамена не будет.
Так вы такое не говорили.
Зачем ты пугаешь людей просто так?
Да я тебя пугаю, не беспокойся.
Если эта табличка придется работать только в одном случае,
когда вы будете писать unsafe code,
тогда вам придется действительно смотреть табличку
и гарантировать то, что ваши типы действительно
правильно работают с lifetime.
Мы еще посмотрим, например, того, как это с unsafe code работает.
Но для начала давайте посмотрим какие-нибудь другие примеры.
Например, контрольный вопрос.
Какая вариантность этого типа?
Вариантность вычисляется от каждого входного аргумента.
Я дам подсказку. У нас три входных аргумента.
A, B и C.
А может кажется...
Можно, можно.
Если что, ссылка на 1.3.
А второй lifetime где был?
Внутри этажки.
Трейд у нас просто тоже от lifetime code зависит.
По внешнему lifetime, которые все очень интенсивные варианты.
На самом деле это очень просто.
По пугам это просто понять, почему табличка такая уже.
Для этого нужны примеры какие-то.
Я не советую.
Если хочешь, можешь посмотреть статье,
которая доказывает формальный моделер аста.
Так вообще лучше просто пользоваться табличкой.
Я даже сам проверил.
Я себя, скажем так, проверил.
Ну ладно.
Да, потому что у нас ссылка.
Здесь ссылка A на T.
T какой-то там не важно.
По A мы кавариантны. Ура.
Потом у нас T.
Заранее запоминаем.
Здесь все представляет из себя T.
Поэтому T мы кавариантны.
Заранее говорю.
Если бы внутри нашлась где-то контовариантность,
кавариантность дает инвариантность.
Просто мы налагаем друг друга, пересекаем.
По трейду, где lifetime B, что у нас там получается?
А нет, наврал.
Соответственно, да, мы инвариантны по B.
Потому что мы кавариантны по всему этому.
Соответственно, как минимум кавариантны по этим типам.
Мы по B инвариантны по табличке.
Это кавариантность и инвариантность.
Инвариантность это как бы конкретная часть этого луча.
Потом у нас есть еще C.
C мы конечно кавариантны.
Потому что кавариантность на кавариантность.
Как-то так.
Сложная штука.
Так.
Припоминаете ли вы, что на самом деле Dintrade это type и reg?
Да.
Ну, в общем, естественно, если это type и reg,
а у нас lifetime это часть типа,
то в таком случае, если бы мы стерли lifetime, было бы очень плохо.
Поэтому на самом деле, именно поэтому вот в этой табличке
вообще Dintrade имеет еще какой-то lifetime.
Плюс A.
Он всегда есть, вы его почти никогда не видите.
Поэтому конкретно в данном случае вы будете иметь,
представим, что у нас есть какая-то функция,
которая создает внутри строчку.
Потом, при условии, что эта строчка реализует какой-то trade,
мы создаем box.
У этого box на самом деле внутри будет плюс A lifetime.
Этот lifetime A будет на протяжении нашей функции.
У нас есть вернуть мне функции. О, ошибка, да?
Потому это будет не скомпилировать.
Нужно было, наверное, справиться с функцией написать.
Поэтому у нас никуда не деваться lifetime,
и когда вы создаете Dintrade,
то у вас там на самом деле еще живет lifetime внутри.
Так. Как думаете, чего этот код не компилируется?
У нас будет много примеров на лекции,
потому что мы так ничего не понимаем.
Понятно.
Ну, кажется, потому что из-за...
Сейчас у нас первый аргумент
и был в фигурке.
Это мутабельная ссылка
на немутабельную статическую строчку.
Поскольку мы вариантные,
кажется, второй аргумент
тогда тоже должен был быть,
ссылка на статическую строчку,
но тут у нас lifetime будет поменьше.
Я чуть-чуть запутался в том, что ты говоришь,
что это правда.
Ну, смотри.
У нас тут ссылка на mute.t.
Как мы помним, в результате мы по t-инвариантно.
Хоть мы здесь получается у нас любой t,
там мы вариантны по t,
и, соответственно, не получится привести друг к другу t-шки,
в случае чего.
И, соответственно, t-шка у нас какая должна быть?
Такой должен быть ссылка на a,
то, что bark имеет.
Такой должен быть у t.
Соответственно, t представляет ссылку a на str.
Вот вы пытаетесь засунуть ссылку a на str,
потому что вы привели это все дело.
Вот у вас ссылка на a-str,
потом mute, ссылка a-str,
и появляется mute-ссылка на a-str.
И, соответственно, вы пытаетесь statics присунуть.
И дело в том, что
статическая строка, так как мы инвариантны
по нашему аргументу t,
мы не можем привести нашу статическую ссылку к a,
даже несмотря на то, что вроде бы она живет больше.
Просто она запрещает нам.
Система типов нас ограничивает, чтобы мы в том числе
не делали ошибки в других местах.
Могли бы.
Так, примерно понятно.
Ну, это как раз desugared.
Зря, наверное, не попало в следующий раз.
Вот как раз ссылка на a-str,
и тут как раз хорошо видно, что у нас происходит.
Мы засовываем какую-то строчку,
и там мы не можем статическую строчку
в разном случае.
Так, как вы думаете, насколько нам
это часто нужно?
Мы все это начали изучать,
теперь давайте подумаем.
Ну,
зависит от того, насколько ты сложный код пишешь.
Как я говорил, это полезно знать
в любой момент времени,
чтобы понимать, как код компилируется.
Но на самом деле это действительно существенно
только тогда, когда вы пишете unsafe код.
В unsafe коде вы можете прямо напортачить.
Вот давайте поймем, как мы можем напортачить,
если мы начинаем писать unsafe.
Мы в принципе unsafe не знаем, но я не думаю,
что у нас возникают проблемы здесь.
У нас какая-то тэшка,
потом внутри мы пытаемся сделать set,
написать такую функцию.
Просто для нашего удобства я написал здесь
сигнатуру функции write,
которая сидит по второму write.
То, что она делает, она пишет по указателю.
Естественно, она ничего не проверяет,
она просто пишет по указателю.
Она просто привозит ее к указателю,
а потом записывает ее new value.
Казалось бы, что может пойти не так.
Просто записали в тэ.
Нам даже дали владеющий тип,
казалось бы, не владеющий, какой-то тип.
Как раз здесь один из приколов возникает,
что это не обязательно владеющий.
Вот смотрите, у нас тэшка,
мы пытаемся записать.
Как вы думаете, что может пойти не так?
Если что, там дальше надо слать следующий пример.
Хотя, наверное, давайте сразу примеры начнем.
Что здесь пойдет не так?
Здесь, на самом деле, прям явная ошибка.
Похоже, мы смогли успешно записать ссылку
и не подумать о том, что она могла не дожить.
Жить меньше, чем mySell.
Да, наш mySell имеет ограничение статик.
То есть, он содержит ссылку на какую-то статическую переменную.
Нам, конечно же, это не по кайфу,
когда мы начинаем писать фу что-то.
Потому что мы пытаемся записать уже какую-то ссылку
с лайфтаймом a на i3d2.
Соответственно, когда мы выйдем отсюда,
вот здесь все будет хорошо, а когда мы выйдем уже из фу,
то, соответственно, у нас ссылка будет на невалидный регион памяти.
То есть шутка в том, что она внутри ссылы,
а ссылка на i3d2.
И мы ничего не проверим.
Поэтому нужно указать, что t в лайфтаймом трэшке
должен быть под типом лайфтайма server.
Ну, что-то такое, да.
Нужно написать, но вообще тебе нужно сделать тип invariant.
Смотри.
У тебя проблема в том, что mysell – это ссылка на i3d2.
С самого начала здесь ты создаешь счастливый mysell
на статик какой-то i3d2.
Это статическая ссылка.
Тут просто запись указателя.
Потом мы берем такие value,
которые равен 13.
У нас mysell на i3d2.
Когда мы делаем set, мы записываем ссылку
на этот...
Да, когда мы отсюда выходим,
у нас ссылка очищается.
Ну, не очищается ссылка, а становится невалидной.
То есть это один из возможных выводов программы.
В первый раз у нас все было хорошо, 13.
Действительно все было валидно, а во второй раз у нас какой-то мусор.
Вот мы получили memory unsafety
просто за бесплатно, потому что у нас на самом деле что-то...
Мы бы попользовались unsafety.
На самом деле мы еще, когда будем рассматривать unsafety,
там такие еще приколы будут.
Будет стрелять в самых неожиданных местах,
потому что вы какие-то пререквизиты unsafety не выполняете.
Как раз вспоминаем первую лекцию, где был пример с mem.copy.
Кажется, Илина Сторвальс говорила, что этот весь код
нужно тестировать, и вы сами виноваты, что у вас функция
не предупреждает о пересечениях и все такое.
А другие сказали, ну вы виноваты, это из покон веков
существует ограничение mem.copy, и сами виноваты программисты,
что такое написали. Ну вот Rust говорит, что вы
должны писать хороший интерфейс, а все плюс-плюс говорят,
ну вы сами виноваты, вот пользуйтесь нормально, пишите нормальный код.
Что в ссылку там пишете? Как-то так.
Если я unsaved не пишу, то от чего меня Rust защищается?
Если не пишешь unsaved, у тебя никогда не будет mem.ariant-safety.
Не будет такого никогда. В худшем случае просто программа
запаникует сразу же, как только что-то сломается.
А в случае плюсов, ты бы мог получить произвольные
инварианты, могли бы произвольно сбиться, все что угодно,
зависит от оптимизации компилятора и всего такого,
как в итоге код работает.
Давайте посмотрим, что произошло еще раз.
Мы какую-то I32
сохранили в статике 32
с помощью unsaved, и мы никаких проверок не сделали.
По умолчанию компилятор не даст нам сделать, потому что
когда мы пытаемся...
Если бы мы писали в сейв, в таком случае нам бы пришлось
сделать. Да, и это инвариантность.
MySaleT это получение к вариантной вещам.
То есть можно в качестве T использовать какие-то подтипа.
Вот у нас получилось засунуть подтип, но при этом
unsaved был использован неправильно, и мы сломались на уровне
того, что мы сломали AXM, то есть
Lessing Sormitability, просто неправильно в lifetime поставили.
В итоге это закончилось тем, что у нас в MySale есть слишком маленькая
строчка теперь.
Вот как раз то, что было про MuteSelf, почему этот код не компилируется?
Потому что у нас MuteSelf это инвариантная штука.
Давайте мы чуть более конкретно посмотрим, потому что
здесь нужно обессахарить, чтобы понять, что происходит.
Обессахаренно оно выглядит так, конечно.
У нас, во-первых, два input параметра.
У нас Myself представляет из себя
Myself at, at это ссылка на I32.
Поэтому оно обессахаренно выглядит примерно вот так.
У нас будет ссылка с слотами A, Mute, Myself.
И кажется, да, вот здесь должна быть
B.
Тоже на записи, чтобы было видно, вот в этом месте B.
Вот как-то так.
Из-за того, что мы инвариантные, нам раз не позволят записать это значение,
потому что просто не вызовется, не сможет он привести A
здесь будет статику, здесь будет A, и соответственно
он A к статику привести не может и пожалуется.
SunSafe, да, пожалуйста, мы используем просто ссылку на Self,
она кавариантно смогли привести, внутри Unsafe, и все сломалось.
А вот, например, такой код не скомпилируется.
Это просто Sell. То же самое на Sell.
Что произошло? Просто Sell инвариантино.
Как это сделано?
Как это сделано? Ну, это хороший вопрос. Там в компиляторе прописан
такой тип Macros, называется
Length равняется UnsafeSell,
ну, это называется UnsafeSell написано. UnsafeSell у нас
по T инвариантен. Sell внутри использует UnsafeSell.
Соответственно, получается инвариантность Sell.
И он не пропустит еще раньше.
Sell у нас инвариантен, никакого варианта.
Вот такая ошибочка получится.
Он скажет нам, смотрите, у нас здесь lifetime1,
а эта ссылка на притяжение lifetime1 не живет.
Все вроде бы понятно, когда начинаешь
разбираться.
Вот этот вот код почему в целом компилируется?
Ну,
мы считаем, что там есть функция.
Ну, я тоже это уже проговорил,
на самом деле.
Что?
Неважно, может считать, что пустая функция.
Просто чтобы lifetime продлить.
Потому что иначе у нас lifetime sell будет такой вот.
А мы хотим, чтобы он прожил на протяжении всего.
Поэтому мы дропы делаем, чтобы он дожил до сего.
Просто явно пишем здесь lifetime.
Давайте я слух еще расскажу.
У нас ссылка на Sell ковариант, ну просто ссылка на что-то ковариантно.
Поэтому получается, что потомка вариантная и вот этот код с компилируется.
Ну, смотри.
У нас ссылка на Sell. Ссылка АТ ковариантная и по А, и по Т.
Здесь у нас какой-то lifetime А, но Sell это myself.
Мы ковариантные потому и потом. Соответственно мы ковариантные.
Все.
Мы ковариантные по Т.
Так.
Мы ковариантные по Т. То есть мы все можем
что-то передать любой партизим?
Получается да.
Как раз по ссылке мы смотрим только. Просто если я без сахаритета,
тогда получится ссылка на А и 32 и естественно ты не сможешь просто так
и 32 как бы
записать что-то вместо и 32.
Ты будешь вариантным только по lifetime.
Потому что и 32 это уже какой-то конкретный Т.
Вариантным ты именно по lifetime будешь в этом случае.
А статик это по типу?
Да, статик по типу всего.
Давай там где-то.
Давай прикинем, что здесь нет мюта.
У нас Т это ссылка на статик.
Соответственно вместо А здесь убедит статик,
и здесь убедит статик.
По отношению к этому коду.
Здесь у нас
Myself имеет тип ссылка на статик и 32.
Соответственно Т это ссылка на статик и 32.
Соответственно вместо ссылки на А и 32
нужно написать ссылку на статик и 32.
И в качестве value тоже.
Сейчас в качестве value будет ссылка на статик.
Там дальше ты передаешь ссылку с меньшим lifetime.
С меньшим lifetime,
потому что здесь вот
тут должен быть вариант.
Тут будут контраварианты в какой-то стороне?
Не, контравариантности точно нет.
Скорее всего причина просто это выписать вот здесь вот и внимательно посмотреть.
Я думаю, что это чисто так.
Можете это в качестве упражнения проделать.
Я думаю, это совсем несложно.
Скорее всего в ассоциированной функции вывелся не статический lifetime,
но мы туда в качестве по типу передали myself статическим lifetime.
И все варианты все отработали.
Вот это больше на правду похоже.
Нужно прямо написать.
Я просто в голове у меня не получается обессахарить все и проверить.
Дроб чекер.
Это самую тяжелую главу. Мы можем с собой гордиться.
Если вы даже примерно что-то поняли, то это вообще замечательно.
Через какое-то время будете шарящими в одной из тем,
которые практически никто не шарит из ростовиков.
Дроб чекер.
У нас есть такая штука, что
как все плюс-плюс, у нас есть какой-то порядок объявлений.
И в обратном порядке мы удаляем переменные.
Структурное программирование это называется.
Поэтому в том порядке, в котором мы создаем переменные, мы их и удаляем.
Но бывают ситуации, когда мы не понимаем, в каком порядке их нужно удалять.
Вот, например, вектор и вектор.
У нас в расе сказано, что
первый элемент тюпла должен умереть первым, второй элемент тюпла — вторым.
Но при этом в глазах брови чекера левый вектор
будет ли строго переживать правый?
Если один же, с самого начала, один дропается,
а потом второй. Кто кого переживает?
Вообще в глазах брови чекера есть такое понятие?
Какой лайфтайм каждого будет?
У кого больше? У первого или у второго?
Но пока непонятно, должны ли они вообще зависеть как-то друг от друга?
Да.
Шутка в том, что они никак друг от друга не зависят.
В глазах брови чекера они имеют один и тот же лайфтайм.
Потому что это все один тип, все внутри.
Для него это все один тип.
Вообще у нас вообще это беспокоит. В каком порядке переменная должна умирать?
Давайте вот на такой код посмотрим.
Он скомпилируется?
Это не для планирования, когда трейд клоун все портит.
Ну, чтобы он компилировался на каким-то магическим образом,
необходимо дропать инспектора раньше, чтобы сука там никого не переживала.
Вообще, кстати, структура все дропается именно в том порядке, в котором объявлены.
То есть в каком объявлены структуры сначала экспектора, потом дни.
Конкретно данный код скомпилируется.
Этот код скомпилируется.
Но что с ним добавим дроп?
То есть все, что отличается в этом коде,
это то, что для инспектора какой-то дроп выдал.
И все.
Что?
Да, это и есть вопрос.
Что-то есть надежда, что ничего не поменяется, если что-то дропится в правильном порядке,
и поэтому что-то появится в аналитическом бизнесе.
Ну, вообще правда в том, что
это достаточно сложно анализировать, что там в каком порядке должно дропаться.
Может, там есть какой-то порядок, что сначала третье поле, потом пятое, потом первое.
В плюсах все проще.
Ну, такое дело в плюсах. В плюсах небезопасный язык.
Если у тебя неправильный порядок дропа, ты можешь случайно отстрелить ногу.
Просто из-за того, что у тебя деструктор пораньше.
Ну, смотри, конкретно здесь у нас такая ситуация. У нас инспектор владеет кое-что ссылкой.
Мы хотим, чтобы эта ссылка пережила.
Дело в том, что эта ссылка живет вместе с нами в ворлде.
Умеет такой же лайфтайм, как мы.
Проблема в том, что этот код не скомпилируется.
Если бы мы не скомпилировались первыми, в таком случае инспектор
попробовал бы к уже денициализированной памяти обратиться.
А то есть не гарантируется, как это по итогу будет дропаться, да?
Нет. Тебе гарантируют. Тебе говорят порядок такой же, как вебилейная структура в тюпах.
Такой же порядок, как с левой направо первого.
У тебя переменная скопия в реверсном порядке.
При этом дроп-чекер такой?
Да, дроп-чекер тебе скажет. Нет, я это не скомпилирую.
Сейчас я тебе скажу.
Еще одна причина, почему у нас не стоит использовать.
То есть тогда мы что-то фиксируем, а потом начинаем обмазывать это все.
Ну слушай, зафиксировали, но тут такая проблема.
Это, кстати, фиксировали, потому что много кода на это рассчитывали когда-то.
И поэтому сказали, ну сломайте много код, давайте не будем ничего менять.
Да, в конкретном данном случае у нас сначала дропнется инспектор, потом дни.
Ну подождите.
Это проблема называется Sound Generic Drop.
Потому что единственное, кто должен заботиться вообще об этой проблеме,
это те, у кого есть какие-то Generic Lifetime.
Ну вообще есть Lifetime.
Ну это просто ее название исходит из того, что если у вас есть,
как в инспекторе ссылка на какую-нибудь U8,
то у вас появляется и Lifetime.
И, соответственно, за счет этого Lifetime'а
появляется зависимость в каком порядке у вас дропнется порядок.
А так вообще, по линии у которых нет никаких Generic'ов,
никаких Lifetime-зависимости, какая разница?
Они просто в каком-то...
Там без разницы в каком порядке все дропнется.
Вот.
Давайте придумаем самое глупое правило для того,
чтобы у нас получился Sound Drop.
То есть мы хотим, чтобы у нас дроп гарантированно...
В общем, дроп был так, что у нас не было бы Memory and Safety.
Иначе бы мы могли в дропе написать в неправильном порядке поля,
и у нас бы все сломалось.
Ворлд и инспектор поломать, местами поменять и все.
Мы хотим, чтобы Lifetime-параметры в дроповом объекте были не меньше,
чем в темпараметрах Selfie.
А ты не сможешь в дропе указать эти параметры?
Нет, потому что она в дропе же есть, как у Selfie?
Ну, у Selfie, да, есть.
Мы хотим, чтобы он был не больше, чем то, к чему мы обращаемся.
А к чему ты обращаешься?
Ну, как в инспекторе было.
Ты понимаешь, как примеры с двумя векторами, ты не знаешь.
Ты можешь, конечно, положиться на то, в каком порядке они ломаются,
но, блин, дропаются.
Там проблема в том, что в таком случае у тебя бы компилированность кода
зависела бы от порядка полей.
Что-то плохое, да?
У тебя бы Lifetime-ы начали зависеть от этого.
Я вроде как раз хочу, чтобы у меня Lifetime были вот какие-то...
Чтобы они были достаточно долгими, значит они не могут как минимум как-то заломить...
как перекликаться с Lifetime в объект, который дропает.
Было бы прикольно, если бы ты в чате потом написал.
Я не знаю.
Просто вот как ты показывал вот эти...
Как это мне называлось?
Сейчас.
Ты там ранее до лекции показал крышку.
Что-то по поводу того, что Lifetime-параметры дженерика должны быть не меньше,
чем Lifetime-объекты.
Ты, наверное, хотел сказать, что Lifetime-параметры...
Ну да, у нас Lifetime-ы ссылок должны быть не больше, чем Lifetime-объекты,
но сам по себе Lifetime-объекты не должны быть больше,
чем любой из Lifetime-ов.
Да, я об этом вот.
Я хотел бы так, чтобы вот это тут бы не помешало.
Ну вообще самое простое решение данной проблемы это просто сказать,
давайте мы потребуем, чтобы наш объект, который имплементирует дроп,
строго переживал все Lifetime-ы, которые он имеет.
То есть, например, если у нас ссылка на U8,
в таком случае мы хотим строго пережить нашу ссылку.
Ну точнее...
Ссылка нас переживает.
Да, строго чтобы пережила.
Причем строго, чтобы не было одинаковых Lifetime-ов.
До этого у нас все это время...
Это важное отличие как раз от того, что я пытался описать.
У нас там могло быть совпадение, а тут нет.
Да, до этого мы всегда работали с таким вот...
Ну вот, это самое простое решение.
До этого мы лишь вот на такое вот смотрели,
что если A было под типом B, в таком случае никто не мешал A и B совпадать.
Сейчас у нас в дроп-чекере появилась такая проблемка с дропом,
что если у нас дроп будет в неправильном порядке дропать,
ну в каком-то, который вы не ожидаете,
в таком случае у вас может быть доступ к неинтересированной памяти.
Поэтому наш дроп требует того, чтобы мы все переживали свои зависимости.
Можете обратиться.
Куда?
Ну, туда.
Давай следующий случай.
Сейчас.
А у нас получается, что одно поле славится на другое поле.
Да.
Ну вообще ссылку на самого себя безобщенно сделать вообще не получится.
Во-первых, потому что было бы не безопасно, вы бы смогли, например,
мовнуть объект и все сломать.
Плюс тут даже не в общем дело в том, что вы на бокс указываете.
Бокс на кучу.
Если бы там был просто УБ-8, то вы бы не смогли взять ссылку.
Опять же, мов сделали, и у вас плайма у вас ссылка.
Это тут понятно?
Вратите внимание, что мы никогда не...
Здесь мы никакие поля в инспекторе, от которых мы действительно зависим lifetime объекта,
мы не трогаем.
Но при этом все равно наш код не компилируется.
То есть мы не трогаем наш штрих У-8, но при этом все равно РАСТ не дает.
Он строго требует, чтобы мы переживали все lifetime параметры.
Ну ладно.
Ну и вот еще один есть такой примерчик.
Даже несмотря на то, что мы не трогаем данные внутри, все равно не компилируется.
Но здесь конкретно уже тай тип.
Кажется, он выводится как ссылка.
Да.
И тем самым не безосыграняется, поскольку у вас как-то...
Да, да.
Он обессахарится в какую-то ссылку.
Плюс ко всему, на первой лекции я вам такую вот показываю.
Возможно, вы помните.
Я вам тогда сказал, на самом деле Вектор в РАСТе выглядит не так.
Чуть иначе.
Тут такое дело.
Из-за дроп-чекера он будет считать, что мы никакими значениями t не владеем.
У нас есть какой-то указатель, мы указатели.
А владеть не владеем никакими.
Значит, не дропаем никакие.
Значит, мы не зависим от lifetime в t.
Потому что у нас просто указатели.
А чтобы у нас это все работало через указатель,
опять же unsaved, мы тут с какой-то проблемой сталкиваемся,
нам нужно добавить такую штуку, которая называется PhantomData.
PhantomData притворяется, что оно содержит тип, который у него есть.
На самом деле, это ZST тип, вот такой компиляторный.
Вылез вот так вот.
На самом деле, не костыли, но еще иногда нужно даже не unsaved,
в том числе в меню frunk задачи.
Какая правильная читать.
Как мы выяснили на немецком.
Так.
Не увеличивается, потому что ZST, PhantomData.
Он только притворяется, что он содержит t.
То есть компилятору кажется, ага,
ну теперь ты, наверное, где-то тут векторе t содержишь,
но на самом деле это не так.
Да, ну вот это ограничение системов типа RAST.
Как я говорил, у нас какое-то число правильных программ теперь запрещается.
Ну, так же, как и запрещается какое-то огромное множество программ,
которые неправильные.
И вот в том числе программы, которые были правильными,
в общем, ну вот мы их запретили только что.
Из-за, например, DropChecker.
Это такое логическое ограничение системы типов.
Это все чего-то стоит, скажем так.
Не бесплатно.
Вот спина E в RAST и нет.
Прекрасно.
Вот это, не знаю, это выглядит как не лучше.
Не знаю, вот сейчас это самая непонятная лекция из всех на самом деле.
После этого ничего сложного не будет.
Это ничего не сложного не будет, вы все поймете.
Это все связано с тем, что вам приходится писать unsafe code.
Вот опять указатель какой-то возникает.
И если бы не было указателей, то вам бы не пришлось, например, PhantomData здесь вводить.
В следующий раз мы поговорим сейчас про concurrency.
В следующий раз мы спросим про параллельность unsafe и concurrency.
Ну там как пойдет.
То есть вы бы пришли и все две параллельности по попросу брать.
Посмотрим.
Так, ну тут понятно, да.
PhantomData это такое, притворяющееся, что владеет типом.
Теперь дошли до конкурса.
Конклужин.
Конклужин, кстати, сколько он занимает?
О, целых 14 слайдов.
Самое важное.
Так.
Смотрите, давайте мы подытожим все то, что мы узнали.
Кстати, по дроп-чекеру у вас уже нет вопросов?
Такой вынужденный костыль, связанный с тем, что у нас есть дропы,
с тем, что у нас есть лайфтаймы, которые могут быть одинаковыми.
Нам приходится требовать того, чтобы мы переживали все наши зависимости,
строго переживали.
Возможно, были равны и по типу бегали.
Во-первых, ключевая идея системы типа фраз-то это проверять lifetime объект.
Мы изводим такое понятие как lifetime, это какая-то часть кода расовского.
И мы трекаем, что мы действительно, например, ссылки наши не переживают.
Есть lifetime.
Лайфтаймы – это вложенные вещи.
Я, опять же, оставлю это без пруфа.
Но скажу, что, во-первых, формальные пруфы нам не нужны,
но скажу, что нам нужно только лишь трекать локальный lifetime.
Нам этого хватает.
То есть мы где-то внутри функции посоздавались какие-то объекты.
Ну и все, в принципе.
И дальше нам нужно только generic definition всякие.
То, как у нас объявляются структуры,
енамы, функции, имплы.
Это для нас самое важное.
Мы за ними просто следим, что у нас точно объекты, которые попадают,
они удовлетворяют всем свойствам,
и соответственно у нас получается сейфти в сумме.
Каким-то несложным образом.
У каждого generic definition могут быть разные lifetime и разные генеричные типы.
Например, у нас может быть такой, что у нас есть штрих A и T.
Они имеют какие-то разные lifetimes.
Когда у нас 2D generic.
Потом.
По умолчанию у нас, конечно, нет lifetime параметров,
когда мы создаем структуру, в которой U32, потом вектор и так далее.
У нас по умолчанию нет никаких lifetime параметров.
Они обычно появляются именно в ссылках.
И означает, что я не могу там пережить этот lifetime.
В основном, эта идея распространяется на ссылке.
Subtaping существует для ссылок.
Variants, соответственно, тоже преимущественно для ссылок.
Хотя не только для них.
Ну или могут попасться в quantum data.
Это все было про то, где у нас встречаются вообще lifetime.
То есть у нас общая идея просто трекаем lifetimes.
И lifetimes встречаются в всяких generic definitions.
Когда вы пишете вот такую примерно штуку.
Это какая-то произвольная функция, которая выдумалась головой.
Вот вы, например, написали.
У вас есть lifetime A, T и U.
Написали T и T.
Интератор, в который переходит T.
Обязательный итератор с айтомом U.
А этот U, в свою очередь, клоун.
И живет как минимум A.
Тем самым вы задали множество значений, которые подходят к этой функции.
То, что разделает, он проверяет.
Что типы, которые мы ввели, корректны.
Мы это делаем, конечно же, в соответствии с variants.
Если у нас есть какие-то ссылки.
И они не точно такие, как требует функция.
Мы можем их привести.
Но в соответствии с их variants.
Для того, чтобы все было безопасно.
Это тоже вещь, которая выводится в формальной теории.
В принципе, все, что я сказал, это может быть доказано.
Что этого хватает для того, чтобы получить memory-safe приложение.
Конечно, там есть всякие еще нюансы.
Про которые, например, мы еще скажем.
В принципе, этого всего хватает.
Когда, например, просто такая ремарочка.
Например, импл блоки. Они у вас могут пересекаться.
Помните, наверное, что вы там можете написать.
Что у вас один импл блок, где T это default.
Потом второй импл блок, где у вас T это клоун.
Может быть такой у вас.
По-моему, это вторая лекция или третья.
Они могут пересекаться.
Может быть какое-то наименование, которое одинаково.
Просто-напросто.
Ну, функция, которая с одинаковым именем.
Как раз проверяет это пересечение.
Он просто смотрит, ага.
Мог ли эти имплы пересекаться?
Пересекаются ли множество значений, которые принимают?
Мы как раз здесь делали какое-то множество значений.
И мы пытаемся...
Ну, раз проверяет, он проверяет.
Пересекается ли множество значений хотя бы на одном каком-то типе.
Поэтому он может это без инстанциализации как в плюсах.
Ответить на этот вопрос.
Вот.
Так же, как мы выяснили.
Если у нас есть деструкторы, то, к сожалению, нам не хватает просто быть под типом по lifetime.
Нам хочется строго переживать все параметры нашего типа.
Ну, иначе у нас получится memory safety в дропе.
Так.
Ну, и вот это вот очень важный момент.
Мы писали какие-то lifetimes.
Например, написали вот такую функцию опять же.
Если у нас будут разные ашки,
то это не значит, что у нас в бинарном коде, который компилируется с компилятором,
будут разные инстанции функции example.
Абсолютно одинаковые.
На самом деле Rust, когда проверил семантику вашего языка, он lifetime стирает.
Они дальше не важны.
То есть, он проверил, что ваша программа корректна, там нет aliasing,
нет use after free и все такое за счет lifetime.
После этого просто убрал, выкинул их.
Остается это важно.
Ну, это, в общем, не важно.
И для генерации кода достаточно того, что осталось.
То есть типов уже непосредственных.
Это исключительно семантика языка.
Да.
Ну и последний еще момент, который я оставлю только лишь маленькой ремарочкой.
Несмотря на то, что там есть небольшая глава, например, в Станом и Коне про это,
там ничего сложного, в принципе, нет.
Например, вы не можете в Rust спокойно приводить типа друг к другу.
У вас, например, в плюсах вы можете void к int привести,
а у вас void там к nint, нифига.
И вот вы получили membrane safety.
Просто потому что вы что-то не проверили, сделали неправильный tab-question.
Ну, это не очень удачный пример.
Ну, это банальный пример.
Просто как бы, наверное, стоит привести какой-нибудь такой полный тип.
Прям структуру какую-нибудь.
А хотя бы шорты int этого уже было.
Ну, суть ясна, я думаю, да.
В Rust.
Не совсем, просто потому что звездочка слишком особая фигня,
которая используется слишком часто.
Ладно, наверное...
Все нормально как раз.
То есть это я красто привык,
что звездочку как части по плюсах нет.
Это про это?
Ну, я про...
Нет, здесь звездочка, конечно, тоже здесь нет.
Проблема в том, что void звездочка, это вот как раз местные они.
Ну, сихные они, так сказать.
А, ты все понял о чем-то.
Был бы два пола.
Да, void это просто они, да.
Здесь можно было бы шорт написать, вместо void, да и получилось бы...
Точно скалявал бы, да.
Или, например, если бы у нас здесь был, не знаю, int32,
а здесь int64t.
Не безопасно приводить их друг к другу.
Rust позволяет только некоторые типы коэрсии.
Это можно прочитать.
Насколько я помню, у меня даже должно быть.
Некоторые приведения типов,
например, u32q64,
можно спокойно привести.
Там не будет никаких проблем.
Тип месяца и так далее.
Там несложный список.
Я думаю, вы легко разберетесь.
Обсуждать его, я думаю, мало смысла.
Просто что Rust не дает вам еще
переинтерпретировать байты
просто так, по-другому.
Иначе тоже могли бы взять,
переинтерпретировать тип по-другому,
и у Rust все опять бы сломалось.
Его хрупкая система типов
может сломаться в любой момент,
особенно когда вы пользуете unsafe.
Ну ладно, она не ломается просто так,
только если вы unsafe пользуетесь.
Ну вообще, знаете.
Кажется, это все.
Да, это все.
Понятно ли в общих чертах,
устроенном mrsafety.
Просто lifetime.
И все.
И variance.
А еще дроп-чекеры и typecatch.
Кажется, все одно.
