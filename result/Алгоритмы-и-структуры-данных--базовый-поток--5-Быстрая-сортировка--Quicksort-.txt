Окей, быстрая сортировка. Что это такое? Почему она называется быстрая? Откуда взялась вот эта
то самая быстрота? И все считают, что, блин, она такая классная, такая хорошая, или же, наоборот,
есть какие-то проблемы. А в чем вообще смысл быстрой сортировки? Ну, на самом деле идеи достаточно
просты. У каждой сортировок достаточно простые идеи, как, я думаю, вы все поняли. Вот вы уже
смотрели сортировки, которые там были. Быстрая сортировка не исключение. У нее просто идея следующего
характера. Если merge sort сначала разбивал все до мелких кусочков, потом их соединял, то quick
sort предлагает делать следующее. Давайте возьмем какой-то из элементов, скажем, что он будет нашим
опорным в данный момент. Опорный, от которого мы как раз-таки сейчас отталкиваемся. И просто поместим
его так и поменяем наш массив так, что слева от опорного элемента будут лежать все элементы,
которые меньше него, а справа от опорного все больше либо равные. Как-то мы должны это сделать. И
вот если мы как-то это сделаем, то повторим эту операцию для левой и правой куска и еще раз там
отсортируем таким образом. И таким образом наши опорные элементы выстроятся в необходимую нам
последовательность. Суть примерно такая. Ну, это логично взять что-то посерединке и сказать, ну типа,
давайте мы свопаем все вокруг. Вот как бы он хотя бы на своем месте. А вот там уже дальше мы разберемся.
Здесь ровно такой же смысл, который у нас есть. На всякий случай напомню вам, что такое сортировка и
зачем мы ее делаем. Задачу сортировки, наверное, вы уже видите третью лекцию подряд. Вот это то,
что касается самой быстрой сортировки. Что касается самого алгоритма, алгоритм достаточно простой.
Мы все еще выбираем тот самый опорный элемент и делаем так, что все элементы левее меньше,
все элементы правее не меньше. То, что могут быть равные, например. Ну или как-то их там распределяем.
Может быть слева у нас будет не больше, а справа больше. Здесь на ваше усмотрение. И повторяем этот
алгоритм для всех остальных частей. Почему мы осознаем, что эта сортировка должна быть хоть
сколько-то быстрой? А потому что мы разбиваем наш массив на два таких кусочка и в голове предполагаем,
что типа, блин, а в этом случае-то логично, что у нас может получиться так, что у нас два кусочка этих
равных, значит мы уменьшили размеры массивов вдвое. Получили тот самый алгоритм и такие, ну все,
мы получили что-то за НЛГ. Это грубое объяснение того, почему ее так назвали первоначально. Более
качественное мы сейчас с вами будем рассматривать. Вообще, если рассмотреть быструю сортировку,
у нее всего лишь вот такая реализация. А вот. И в этой реализации самое главное это partition.
Partition, который непонятен, что он там вообще делает и как он правильно разбивает здесь. Что же
здесь происходит? То есть, еще раз, мы берем тот самый pivot. Pivot — это опорный элемент. У него
такие, так называют его, это так перевод работает. И он выбирается с помощью того самого partition.
Partition как-то переставляет элементы, а дальше мы запускаем нашу быструю сортировку от двух
кусочков слева и справа. Согласны? Есть какие-то пока в этот момент вопросы? Нет. А теперь вопрос
у меня к вам. А вот для partition, в вашем представлении, как это можно делать?
Существует несколько видов разбиений того, как это можно делать. А то, что сейчас рассказала
Дель, плюс-минус похоже на одно из разбиений. Там на самом деле реализации много разных. А вас там
истерика у еще одних. Как это работает? Ладно. В общем-то, когда мы с вами говорим про разбиения,
выделяет несколько разбиений между собой. Это разбиение ламуто, разбиение хара и разбиение
на три части. Его никто конкретно не придумал. Во всяком случае, я честно не видел. Что касается
разбиения ламуто, это одно из разбиений, которое было придумано в момент примерно этой сортировки,
когда ее придумали. И она использует там всего лишь один указатель. Указатель не в плане того,
как вы представляете это в плюсах, не звездочку. А указатель в плане индексов. Разбиение хара
же использует два таких указателя. И в этом случае мы можем сказать о следующем, что вообще
быструю сортировку называют сортировкой хара. У него все началось. Так что с ней как-то нужно будет
взаимодействовать. Ну и разбиение на три части, одно из самых хардкорных, которое есть, и вам придется
с ним попробовать встретиться. Иначе у вас будет грустно все в контесте. Но начнем с разбиения
ламуто. Разбиение ламуто достаточно простое. Возьмем опорный элемент, самый левый или самый
правый элемент. Все просто. Так как у нас массив, мы не знаем ни о его структуре ничего,
все элементы между собой как-то рандомизировано имеют вот тот самый знак отношения. Кто-то меньше,
кто-то больше. И поэтому неважно, что возьмем мы первый или последний, или серединку, или третий,
или пятый, или восьмой. Не суть важна. Здесь именно такой же смысл. Поэтому давайте возьмем
первый, так как данные приходят к нам специально разные. Возьмем его и сделаем примерно следующее.
Вот здесь я буду уже рисовать на доске, поэтому уж, извините, в презентацию попозже вам все это
добавлю. Если мы говорим с вами о разбиении хара, то работает примерно по следующему образу. Вот у нас
есть нулевой какой-то элемент, и мы начинаем с ним работу. Для этого нам нужно будет несколько
один указатель, который будет показывать, а куда нам встать тем или иным элементом. Я сейчас
покажу промежуточный шаг, и от него вы поймете, что у нас происходит дальше. Смотрите, я хочу
разделить массив так. Вот предположим, что вот эта часть еще не обработанная.
Не обработанная. Вот. А вот это уже обработанная. И в этой обработанной части мы скажем, что вот эти
все элементы, вот здесь вот давайте я напишу какое-нибудь значение вал, вот здесь вот меньше
этого значения вал, а здесь больше этого значения вал. Я не рассматриваю больше либо равно, но можно
их сюда там отнести, это не суть важная. И тогда в этом случае скажите мне, куда должен стать мой
пивод? Между чем? Ну по вот этой линии, правда? Ну я говорю, я предполагаю, что это не важно для
меня. Вот, можно сделать так. Вы можете сюда равно отнести. Не суть важная. А по-хорошему, если я буду
говорить, что мне необходимо вставить элемент топорный, то я его должен вставить в ту самую
водораздельную линию. Как я это могу сделать? Очень просто, смотрите. Возьму элемент, который
лежит левее вот этой линии. Согласны ли вы с тем, что вот этот элемент, ну х? Что х меньше,
чем это значение? А если я поменяю х и value, то что в этом случае произойдет? А? Ничего не
нарушится, потому что value станет здесь, х станет здесь, все элементы от вот этого кусочка теперь
будут лежать здесь, и они будут меньше, а все элементы здесь больше. Окей? Это понятно пока?
Хорошо. Это первое, что нужно будет делать в самом конце, когда мы обработаем весь массив. И мы
сегодня позовем каких-нибудь шесть смелых людей побыть тем самым массивом. Вот. И попробуем с вами
эту самую сортировку. Так вот, предположим, что у нас есть уже вот такой вот обработанный кусочек,
и есть вот какая-то необработанная его часть. Что в этом случае я делаю? Я смотрю на следующий
элемент. Какой-нибудь у? Если у больше, то мне что-то нужно тут делать? Нет. То есть я могу
просто дальше взять и продолжить эту линию, и у меня не нарушится вот это состояние. Согласны?
А потом возьму z, и z будет меньше. То в этом случае z куда я должен поместить? Куда-то влево. Правда?
А теперь давайте вот с той же хитростью, которую мы поставили вот это вот сюда, мы сделаем просто это
вот сюда. Вот здесь вот t какой-нибудь. И я поменяю этот t с z. Скажите мне, вот я эту линию сдвинул,
получается. И когда я z сюда помещу, а t сюда, у меня будет продолжаться то самое состояние, которое мне
было необходимо? Все поняли, что я сейчас сделал или нет? А какая разница? Мне же главное,
чтобы pivot был там, где слева от него все меньше, справа от него все больше. Мы не знаем отношения
между этими в левой части, какие там элементы между собой. Мне не суть важна. Да? Value только в самом
конце, когда мы закончим со всем этим. То есть смотрите, с точки зрения реализации, что мы должны
делать? Мы должны делать следующее. Мы смотрим на элементы, если встречаем больше, то просто забиваем,
а вот если встречаем меньше, то в этом случае эти элементы меньше. Мы должны взять и поместить вот
ровно на край справа от той стороны, где мы говорим, что у нас вот это разделение на большее,
меньшее value. И просто меняем их местами. Согласны ли вы, что в самом начале, когда у меня все не
обработано, я могу сказать, что я просто нахожусь вот здесь? У меня просто нету. У меня нулевая
часть меньше, а нулевая часть больше. Я ничего не обработал, поэтому я нахожусь здесь. А дальше
начинаете. Понятно, что я сейчас сделал. А теперь давайте. Мне нужно семь добровольцев, а из вас шесть
будет сортировкой, а один тем самым партишнам. Кто хочет попробовать? Отлично. Выходите, выходите. Не
бойтесь. Вы даже в камеру упадете. Давайте вот куда-нибудь сюда. Раз, два, три. А что? Нет, я на вас буду
показывать. Да нет. Все, отлично, отлично, отлично. Нужен еще один, и ты будешь той самой сортировкой.
Только давайте, чтобы было хоть как-то интересно, давай вот тебя вот сюда поставим. А теперь смотрите,
а вы вот как-нибудь свопнитесь с ними, а то вы... Вот так уже хоть немного лучше. Отлично. Вот
теперь смотри, а ты тот самый партишн, который должен выполнять всю эту функцию. Ты должен взять себе
опорный элемент. Правильно. Как тебя зовут, скажи? Саша. Отлично. Вот Саша, опорный элемент. Давай
по росту. Ну типа по росту адекватнее всего здесь будет. Как это делать? Отлично. И мы начинаем идти. В самом
начале мы находимся, ну грубо говоря, вот здесь. Правда? А вот. И мы смотрим, у нас появляется,
как тебе? Катя, Катя, у нас элемент поменьше. Вот. И что мы в этом случае должны сделать? А в
общем случае? Что в общем случае? Если мы встречаем элемент меньше. Правильно, но граница разделов
находится вот здесь. Ну и справа от нее она. То есть она должна свопнуться сама с собой. Давайте не надо.
Остановитесь. Вот. Поэтому она остается на месте. Как тебя зовут, подскажешь? Никита. Что с Никитой делать?
Больше. Отлично. А теперь мы встречаем элемент. Да, смотрите, у нас границы находятся уже здесь. Вот в
этом моменте. А если мы находимся в этом моменте, то мы должны поставить элемент направо. Согласны?
Поэтому мы должны поменять местами. Видите, как чудесно. А дальше мы пойдем дальше. А дальше вас сложно.
Ну есть предположение, что вы больше. Давайте так. Хорошо. Вот. Окей. Мы как-то выстроились.
В самом начале уже так. И вот таким вот образом работает partition. Мы можем попробовать их засвопать
еще раз. Кто-то хочет попробовать представлять людей. Такая. Ладно. Хорошо. Но в действительности как бы
мы будем делать так. И смотрите, когда у нас оканчивается сортировка, мы понимаем, что у нас
раздел находится вот в этой части. Правда? Вот мы один и два раза его сдвинули, потому что у нас
было два элемента меньше. И тогда в этом случае, куда должен стать? С кем? С Сашей. Сашей.
Меняйтесь. Символично. И вот тогда мы получаем следующее, что у нас есть элемент в середине,
а здесь и слева от него все элементы меньше, справа от него все элементы больше. Так получилось
первая сортировка. Дальше, что мы должны сделать? Мы должны сделать аналогично для этой части и для
этой части. Давай. Пивот остается в левой части нашего кусочка. То есть здесь... Можно еще раз?
Саш. Господи, сложно. Ладно. Саша и Никита. Отлично. Вот. Они становятся пивотом в каждой части,
так как ты, грубо говоря, такой компилятор, который преобразует все, ты идешь в рекурсии. И ты идешь
и там, и там. Поэтому ты скорее начнешь отсюда, потом приступишь к той части. Вот. Что здесь?
Катя. Чуть-чуть, да, предположим. И у нас получается сортированный сам по себе кусочек.
Его уже не трогают, он уже стоит на месте. У него же все элементы справа больше,
слева меньше, а значит он на месте. Вот. Его не трогаем. И у нас есть вот этот кусочек.
Но здесь пивот побольше, предположим, да? Ну вот теперь мы предположим обратную часть,
типа не как в начале. Предположим, что пивот больше. Правильно.
Должны посвопать между собой вас. Вообще вы сами должны посвопаться просто. Вот. Ну типа на одном
месте. Ну вот так, да? Правильно. Да. А раздел у нас находится в самом конце,
поэтому ты должен стать в конец. Да. Вот нет, смотрите. Ты должен поменяться с ним местами,
а ты должен остаться на месте. Вот в чем суть. То есть смотрите, важно осознавать,
как между собой становятся элементики. Это не просто типа, ну как бы мы взяли, сдвинули,
и все получилось. Нет. Сдвигайтесь слишком долго, это не интересно. Ну и как-то так.
Ну предположим, что вы уже тоже отсортированы, и мы получим отсортированный массив сам по себе.
Понятно ли, что сейчас было? А вы поняли? Наверное. Надеюсь, что да. Короче, давайте,
все, можете присесть. Спасибо вам большое. В действительности, да, похлопайте им.
Действительно. Я подумаю в следующий раз, как вам про Хифу рассказать так,
чтобы это было еще забавнее. Вот. В общем-то, в действительности разбиение Ла-Муто работает
именно таким вот образом, что вы просто берете и двигаете элементы между собой,
свопаете их, как получается. Его реализация достаточно простая. Как вы видите, здесь у нас есть
pivot value и pivot ptr. Pivot value – это то, что находится в пивоте. Pivot ptr – это то, что у нас,
где у нас является… Сейчас, момент. Давайте еще раз. Pivot value – это то,
что находится у нас, то самое значение, которое есть. Вот тут я вал писал. А pivot ptr – это указатель
на него. И давайте сейчас посмотрим еще раз на чем-нибудь это. Потому что это важно понять и осознать.
И тогда вам будет гораздо проще жить. И вы скажете, что вы знаете сортировку быструю. Потому что,
поверьте мне, разбиение Ла-Муто – одно из самых простых, которое есть, и его понять проще. А когда
мы перейдем к разбиению Хара, если вы попросите написать quicksort, не знаю, почти любого разработчика,
то если он давно уже встречался с алгоритмами, он понимает, как это работает. Прекрасно понимает.
Прекрасно это знает. Но написать его без багов – это чудесно. Нужно постараться. На самом деле,
это не всегда тривиально. Из-за того, что здесь как раз с индексами бывает разное. Вот здесь вот мы
с вами говорим, что это value, pivot value. И сюда указывает pivot point. Почему оно указывает именно сюда?
А он указывает именно сюда, потому что у нас пока предположение, что все элементы предположим,
что большее. Но у нас все не обработано. Вот. Поэтому мы не можем с вами точно сказать.
Если вы решаете контест или что-то обсуждаете, можете выйти и там обсудить.
У нас есть этот pivot point. И дальше мы начинаем обработку тех самых элементов. Мы смотрим на
первый элемент. И если вдруг этот элемент, то есть вот видите, я иду от left plus 1 до right.
Я начинаю идти вот с этого элемента. И я смотрю, что если этот элемент меньше,
меня не интересует больше или ровно, меня интересует меньше. Если он меньше, тогда я
увеличиваю свой pivot point, что у меня должен pivot встать вот на это уже место.
И swap элемент, который я сейчас свижу, с тем элементом, который у меня должен идти. Так как
здесь элемент сам по себе повторяется, где я сейчас нахожусь, с тем, который меньше,
то он swap-ится сам собой. Вот то, когда крутилась Катя или Саша, я уже не помню. Кто-то из вас. Вот
это и означает именно swap сам собой. Это мы должны уметь обеспечить. А дальше мы смотрим элементы.
Предположим, ну давайте, давайте на чиселках. Мне кажется, так будет проще. 5, ну тут 3. Теперь
мы смотрим на 7. Если мы видим 7, мы просто ничего не делаем. Вот у нас этот if есть,
мы сравнили и ничего не сделали. Всё, хорошо. И pivot point никак не меняется. А дальше я найду
2, к примеру. Что в этом случае будет происходить? В этом случае я смотрю на нее, она меньше,
чем мой pivot, а значит, я должен ее поменять местами. И с чем я меняю местами? А с тем,
что находится справа от моего pivot point. Я сначала увеличиваю pivot point, показываю его на 7 и делаю
swap семерки и двойки. И получаю здесь 2 и 7. Вот, и pivot point уже указывает вот сюда. И у нас вот
такой раздел между собой. После этого я могу еще рассмотреть какие-нибудь элементы. Например,
там 8, я его просто пропущу. 9, я его тоже просто пропущу. Ну и, например, 0 и там ну и все. Давайте
сделаем так, просто проще будет. 7 я уже не смотрю, потому что я уже там был на этом месте. 8 я
пропускаю, потому что оно больше. 9 я пропускаю, потому что оно больше. Когда встречаю 0, я опять
увеличиваю pivot point вот сюда и меняю 7 с нулем. И получаю 0, 7. То есть, смотрите, этот элемент
встает именно в конец этого кусочка. Вы не просто так меняетесь, не просто сдвигаетесь, а именно меняете
элементики. Остальное нам не важно. И теперь я получаю, что у меня вот раздел pivot point указывает
сюда, то есть это дом, где должен стоять pivot. Справа от этого раздела все меньше, слева, ой,
справа все больше, слева все меньше. И теперь все, что мне осталось, это 5 и 0 поменять местами.
Поэтому в этом случае я получу вот такой вот массивчик. И получу здесь 0, 3, 2, 5, 8, 9, 7. Эти куски
не отсортированы, я не отрицаю. Но для того, чтобы их отсортировать, мне достаточно здесь и здесь
запустить еще quick sort, что и делает сам по себе быстрая сортировка. Понятно, что произошло. Дальше,
когда я начну сортировать эти кусочки, я тоже каждый из элементов, каждый из пивотов, то есть 8 и 0
подставлю на свои места. 0 останется здесь, 8 станет вот сюда и будет 9, 8, 7. Вот и так далее.
Итак, я получу все мне необходимое. Нет, ой, pivot.ptr. Он возвращает индекс, потому что он
необходим, чтобы мы запустили другие quick sort. Сейчас понятно, что было, как произошло. В общем-то,
а мы с вами все это получили, все это сделали. Вопрос, а за сколько это работает? Почему быстрая? Мы
говорим, что да, она скорее всего работает за логарифт. Но согласны ли вы с тем, что тут можно
привести контрпример, где она работает за квадрат? Да. Если у нас pivot будет всегда каждый раз именно
меньше или больше. В этом случае что мы делаем? Мы все время проходимся по массиву и согласны,
что у нас вот этот водораздел, он всегда стоит на месте. А значит, мы уменьшаемся всего на чуть-чуть.
То есть у нас один quick sort просто вызываться не будет, потому что там ничего не будет.
Там он будет сразу возвращаться. А другой quick sort будет вызываться сколько раз? Ну вот n. И для того,
чтобы сравнить каждый раз элементики, он сколько раз должен пройтись? Н раз по всему массиву, по всей
своей части. Поэтому это будет вот n квадрат. Так почему же quick sort называется быстрый? Как
вы думаете? Можно. А какая разница? А вдруг ты перемешаешь так, что будет опять n квадрат?
Ну вероятность всегда одинаковая. Где? А как? Не бывает. А как ты хочешь сделать? Самый лучший
случай для quick sort это случай, когда у нас будет здесь половина элементов и здесь половина
элемента. Ты максимально их разделишь. Это будет логарифм. Это будет n лог квадрата? Ой,
n лог два n. Вот это уже правда. И давайте это покажем. Вам, возможно, в мёртв сорте не показывали
константы. Вообще, в принципе, да, константы это не самое быстрое, что может произойти. И в общем-то,
как доказывается время работы? Не поверите, но здесь у вас тоже будет вопрос на домашнюю
работу. Скажу так. Вам нужно будет самим подумать, как это доказывается. Почему? По очень простой причине.
Потому что я вам частично это рассказывал. Я дойду до одного момента, а дальше вы сами должны будете
подумать. Смотрите. А предположим, что у нас пивот п, а пивот оказался на месте п. Тогда вот он
оказался на этом месте. Тогда здесь находится п-1 элемент. Правильно? А здесь находится n-p элементов.
У нас есть такое разбиение. Согласны ли вы, что у нас все случаи равновероятные между собой? Поэтому
вот это p могло оказаться, что в начале, что в конце, что где-то ещё. Это первое, что нужно понять. Второе.
Если у меня количество действий для массива из n элементов, это a от n, то здесь, когда он станет
на место p, здесь у меня количество действий будет a от p-1, здесь a от n-p. Согласны? Вот. Значит,
но кроме того, когда я выбираю пивот, я ещё начинаю все элементы сравнивать с ним. Правильно?
Поэтому у меня есть ещё n-1 действие. То есть я сначала n-1 действие делаю, потом ставлю пивот
в нужное мне место. Я вот этот поп не считаю. Ну типа не суть важна на самом деле. А потом я
начинаю вызывать рекурсивно тут и тут. Правда? Вот. Поэтому здесь мы можем сказать, что у нас a от n
равно n-1. Это то количество действий, которое мы выполняем, когда мы проходимся по всему массиву.
n-1 сравнение. А плюс 1 делить на n, потому что у нас равно вероятно, он может стать на место от 0
там до n-1. А дальше я говорю, что это сумма от i единички до n, а от i-1. Ну вот это. Вот это самое.
Почему сумма? Ну потому что я вероятно считаю. Я говорю, что вероятность умножить на количество
действий. Я получу среднее количество действий. Согласны? Да. Вот. Я это получаю. Плюс у меня есть
сумма вот этого n-p. Я тоже считаю его для всех i. Согласны ли вы с тем, что a от i-1 и a от n-i
принимают не те же значения? Понимаете это или нет? Ну то есть, если там i равно 1,
если i равно 1, то у нас будет a0 и a от n-1. А если у нас n равно, а нет, для 1 плохо. Давайте
что-нибудь другое. Давайте скажем для... хотя, почему для 1 плохо? Да нет, для 1 неплохо. Вот. Для
единички это будет то же самое, что у нас будет... я просто считать не умею. Это будет a0 и a от n. Если
я поменяю n и 0 местами, то получу то же самое. Если у меня i равно... правильно. Это правда. Ладно,
я где-то залагал. Хорошо. Здесь нужно их вычеркнуть просто. Все, я понял. Сорян, немного неправильно
писал, что я имел в виду. Нам нужно вычеркнуть будет от единички от нуля. Там количество действий
0. Вот. А дальше рассмотреть, ну не знаю, давайте для i равно 2. Это уже должно точно быть похоже.
Вот a от единички и a от n-2. А дальше я могу сказать, что у меня есть i равно n-2. Я получу
здесь n-1, который я бы получил в другом случае. С одной стороны, правда? А с другой стороны я
получу, если сюда поставлю, a2. А? Где? Да, это правда. Для того, чтобы сопоставить,
это правда. Давайте a от n... Господи, я все, я запутался. Тут будет a от n-2. В общем случае,
на самом деле, вот если мы рассматриваем вот ту часть и вот ту часть, мы получаем вот такую
вот штуку. А значит, мы можем слопать эти суммы. То есть это двойная сумма. А где я беру a ты от i
равного 0 до n-1? Окей? Смотрите, мы с вами говорим, что в разбиении ломуто можно взять и упростить то,
что у нас есть с вами. И как-то с этим вообще жить, работать. И нужно как-то это взять и оценить.
Есть какие-то предположения, как это можно сделать, когда мы вот пришли к такому виду?
Нет. Ну, смотрите, нам нужна рекуррента. Мы умеем решать рекурренты, правда? Вопрос
следующий. Как можно вот упростить вот это a n-2? Видите, оно зависит от суммы аитых. Это не классно.
Ну, типа это не оценить нормально, правда? Правильно. Это правда. Смотрите, у нас есть a n-2 и есть a n-1.
Сумма у них плюс-минус одинаковая, кроме последнего элементика. Значит, мы можем
вот a n-1 на n-1, а a n-2 на n и вычесть друг из друга. И тогда у нас останется только a n-2
и зависимость его от a n-1. Если все привести, то мы получим вот это выражение a n равно n плюс
1 делить на n, n на a от n-1 плюс 2 n-2 делить на n. Согласны? Ну, что так можно сделать? Проверьте,
что у нас действительно результат именно такой. Можете проверить. Дома посидеть,
потыкаться. Хорошо? Но это несложно, это просто механическая операция неинтересная. Так вот,
а в действительности, если решать эту рекурренту с помощью какого-нибудь разложения в ряды,
то можно получить, что это 1 четвертое n плюс 1 на логарифм двоечный n. Это очень маленькая
константа на самом деле, то есть оно максимально близко к этому. Но на экзамене и в принципе дальше
вам необходимо будет взять и это a n-2 доказать, что оно хотя бы n лог n. Помните, мы с вами решали
рекуррент. А? Это как-то неуверенно. Вам очень не понравилось, видимо. Так вот, в действительности
ваша задача будет применить те знания, которые мы с вами делали вот к этой рекурренте и посмотреть,
что она действительно будет n лог n. Оценить ее сверху. И в действительности в среднем
случае мы с вами получим, что у нас будет как раз таки n лог n и значит эта сортировка работает
достаточно быстро и хорошо. Она работает в среднем за n лог n. В лучшем случае мы с вами уже показали,
что у нас n квадрат. Да? А? Больше n квадрат? Каким образом ты хочешь здесь n квадрат? Больше.
Ну смотрите, если у меня есть разбиение, я точно знаю, что на каждом шаге у меня делается уаттен
действия, да? Дальше у меня всегда идет разбитие на две части этого массива, то есть меньше пивота,
больше пивота. Больше пивота. Ну там больше либо равно, не суть важна. Если я буду вызывать quick
sort для этих частей, то тут сколько будет действий? Но также уатт какой-то там х и n-х. Это с одной
стороны, но с другой стороны. А то, что мы с вами будем делать, мы говорим, что у нас в этом случае мы
спускаемся сколько раз? В два таких ответвления. Так вот, когда мы дойдем до конца, что самое
большое здесь может получиться? Если мы с вами будем строить вот это дерево, то у нас будет здесь
n х n-х, потом еще, еще и так далее. Как максимум удлинить эту штуку? То есть мы точно знаем,
что на каждом из этих будет уаттен, правильно? Какая максимальная длина у дерева? То есть вот такой
вот бамбук. Максимальная длина у нас n. Вот n квадрат. Это то, что касается разбиения ламутом. Я
сейчас кратко расскажу вам про разбиение хара. У меня нет доказательств, я вам не даю доказательства о
том, что сколько оно работает. Оно в среднем работает чуть даже лучше, но вам необходимо
математическое ожидание. Вот. А я не хочу вам его вводить, вам ведут это на Тиарвере на втором году.
Нет, не сегодня. Поэтому давайте, давайте так. А что касается разбиения хара? Разбиение хара
действует достаточно просто. А у нас, давайте я смотрю, я буду показывать. Элементы. И мы говорим,
что у нас вот здесь вот есть какой-то элемент пивота. Я хочу все также сделать, что тут меньше,
что тут больше. Да? Что мне с этим делать вообще? Как мне с этим жить? Ну, смотрите,
здесь все очень просто. Давайте подмыслим другой логик. Предположим, что мы идем вот здесь вот по
элементам, и здесь идем по элементам другого края. И мы встречаем вот здесь вот элемент y,
который больше x, а здесь элемент z, который меньше. Какой самый логичный шаг? Поменять их местами.
Вот. Меняем их местами и получаем, что у нас опять сохраняется необходимый нам баланс.
Получается, что здесь будет z, вот здесь вот будет y, а здесь x. И я пойду дальше. Я буду так
постоянно их менять местами. Согласны, что это выглядит непонятно. А теперь ваша задача на подумать
большая. Я всегда заставляю вас думать. Надеюсь, что вы подумаете. Вопрос в следующем. Если у нас
есть здесь элемент, представьте, что я дойду вот до сюда, а здесь я все время меняю элементы.
То есть у меня количество элементов, не знаю, меньше. Предположим, что у меня массив из десяти
элементов. Всего два элемента меньше пивота, а семь элементов больше x. В какой момент пивот туда
перейдет? Так. Значит, начнут свопаться сам. То есть сам пивот начнет свопаться. То есть не думайте
только, что мы идем вот только сбоку. Это самое первое представление этого. Дальше, в момент,
когда мы перейдем к x, никогда не бывает четкого разделения пополам. Не бывает черного и белого.
Я думаю, вы знаете, бывает серое. Всегда об этом учат. Нельзя четко судить о чем-то одном. Вот здесь
ровно такая же суть. И на самом деле реализация выглядит ровно так же. Смотрите, я говорю, что пока
и меньше, либо равно же. Что мы делаем? Мы с вами берем и говорим, что если у нас аи меньше пивота,
то я ищу элемент, который больше, либо равен. Если у нас элемент мы ищем больше, то я ищу момент,
когда у нас будет, мы найдем, меньше элемент, меньше, либо равный. Почему ставить больше и меньше? А
потому, что вот тот самый пивот сам надо менять еще будет. Окей? Я это делаю до того момента,
пока и меньше же. То есть пока эти указатели не столкнутся. Согласны? Все. Вот смысл сортировки.
И вот это чаще всего воспринимают как быструю сортировку. Это и есть быстрая сортировка Хаара.
Сортировка Хаара, по факту. Это то самое разбиение Хаара. Вам понятна ее суть? Да. А дальше,
смотрите, видите, он while аито меньше пивота. В какой момент у нас становится? В моменте,
когда найдет сам пивот. И поменяет его. Вот. И пойдет куда-нибудь. Все. А? Перекидываться.
На примере нужно посмотреть. Согласны? Ну давайте попробуем. Что у нас там?
Давайте сделаем так. 9, 9, не знаю там. Нарисуем. 1, 2, 3, 4, 5, 6, 7, 8, 9. Ну давайте 9 элементов возьмем.
А вот здесь серединка у меня. Давайте я здесь возьму там не знаю 2. Нет, 3. Вот. Покажу,
что у меня один здесь, два здесь. И что-то дальше буду делать здесь. Здесь будет 8, 7, 6, 5, 4. Логично.
Давайте смотреть, что будет происходить. Я иду отсюда, я иду отсюда. Здесь мы находим первый больше,
правильно? Меняю его с первым меньше. Получаю 2, 9. У меня указатель вот сюда. Я иду дальше. Я встречаю
3 и 8. Да? Правильно или неправильно? Или нет? И как? И как жить? Согласны с тем,
что сделал или нет. 8 и 3. Следующий. Ну после двойки ставил какой? А? Валь. Так Вайл,
в какой момент становится? Еще раз, Вайл, в какой момент становится? Почему? Подождите. Вайл что
делает? Ну 3 меньше 3, правда или нет? Так Вайл выполнится. 3 меньше 3. Так, Вайл выполнится.
Ну получается пока как-то так, правда? А? Ну мы поменяли. Нет. Нет, нет, нет.
Согласны с тем, что я там сделал? Ну я правильно сделал или нет? А? Я еще не дошел до нее. А дальше
я смотрю единичка и семерка. Да? Что делать? Меняем их.
Получилось что-то хорошее? Чего не хватает? Не хватает вот этого? Согласны? Это вам нужно подумать,
как это сделать. Это специально и было для того, чтобы типа все понятно? Все понятно. Получили. Да?
Чего? Где с двойки? А потому что все остальные элементы больше, они находятся правее. Все правильно.
Ну они больше, я прохожу их Вайлом просто. Задумайтесь. Да, в начале да. А потом тройку с восьмеркой.
А потом почему? Единичку с семеркой. Видите, какие вопросы порождает сортировка? Я говорю,
именно поэтому быструю сортировку никто быстро не пишет. Это ее типа проклятие такое. Задумайтесь
на тем, что можно здесь делать и что возвращается здесь пивотом. Куда становится, что происходит.
Это один из примеров. Но важный момент. Вы должны понимать, что из-за О от Н квадрат эта
сортировка тоже умеет работать. Почему? Потому что она также может перекинуть их. Ну если вы
правильно напишете, вот подумайте, что с ним сделать. Из-за того, что вас сегодня задержал,
я вам напишу этот код. Но не сразу. К выходным, хорошо? Вот. А вопрос следующим, что в какой-то
момент вам могут предоставить такой массив, что у вас будет пивот стоять вот здесь и опять вот здесь
будет полностью остаток. И вы опять получите этот вызов рекурсии. Понимаете? И в этом будет вся
проблема, что быстрая сортировка периодически работает за Н квадрат. Но она настолько быстрая
с ее константой, что именно ее все используют. Окей? Ну смотрите, мы с партийшном что должны получить?
Вот. Окей. Это то, что касается этого момента. Что это еще разбиение на три части? Честно скажу
об этом чуть-чуть, потому что это скорее такой материал на самоизучение. Я попрошу семинаристов
с вами разобрать это. Хорошо? Отдельно. Суть с разбиением на три части следующая. Нам необходимо,
вот мы также будем смотреть пивот, но мы будем смотреть пивот слева, к примеру. И что мы будем
пытаться делать? Мы будем делать здесь элементы. Будем делать равные пивоту. Здесь элементы будем
меньше пивоту. Здесь необработана его часть. Мы будем идти все так же справа и слева. И здесь
будут элементы равные пивоту, а здесь большие пивоту. Для чего я это делаю? Я это делаю
для следующего, чтобы были здесь меньше пивота, равные пивота, больше пивота. Я хочу получить вот
такой массив. Почему это важно? Потому что если у меня одинаковые элементы, то зачем мне их много
раз между собой свопать? Согласны? Вот. Ну и все. Вот у вас раз, вот у вас два, вот у вас три. И тогда
все будет хорошо. Это делается именно в такой стезе, что здесь у нас будет указатель, здесь
будет указатель, здесь будет указатель, здесь будет указатель. Вы можете почитать здесь побольше.
Если вам нужно, в следующий раз я проведу это так типа на 20 минут, разберу это, если вы захотите
это. Только напишите мне об этом, я вам побольше скажу. Вот здесь будет реализация. Ну и последнее,
на самом деле, что еще хотел я с вами сказать. Возможно ли сортировки быстрее? Быстрее,
чем НЛГН? На самом деле нет. Что это так называемый барьер Омега НЛГН? И он связан как раз
таки с тем, что любая сортировка завязана на сравнение. Но без сравнения очень сложно
придумать сортировку, кроме как быть может подсчетом. Потому что подсчетом она просто
берет конкретные числа, там нет сравнений. Так вот здесь вот барьер заключается в следующем,
что если мы рассмотрим дерево, все возможных вариантов. Причем дерево будет, к примеру,
следующее, что оно будет показывать аито, аито меньше, чем ожито или нет. Если да, то он перейдет
сюда, если нет, то сюда. И будет сравнивать все элементы попарно. Абсолютно все. Скажите,
сколько снизу будет элементов? Сколько всего возможных вариантов сортировки массива? N
факториал, количество перестановок. Вот максимум все переставляем. То есть снизу у нас N факториал.
Это дерево будет полное, потому что оно больше-меньше, больше-меньше. Все элементы
можно сравнить, правда? Да или нет? Мы смотрим какую-то рандомную пару аито-ожито. Мы должны
по всем парам пройтись. Какой-то механизм себе в голове придумали. Сначала а0а1, потом а0а2,
а0а3 и так далее. Вот все элементы возможные просматриваем. И в зависимости от этого свопы
зависит, правда? Вот. А это у нас N факториал. Если дерево полное, скажите мне, какая высота
дерева? Ну вот как дерево связано с количеством листов? Как вы думаете, сколько листов у полного
дерева снизу? 2 в степень h. Ну там минус 1, но не суть важна. 2 в степень h. Чудесно. Вот. Вот у
нас будет 2 в степень h. И мы должны сказать, что у нас N факториал меньше, чем 2 в степень h.
Меньше либо равно, да? Значит h, он будет меньше, ой, больше либо равен, чем логарифм. Ну сейчас,
давайте по-другому скажем. Тут логарифм N факториал меньше либо равен, чем h, логарифм 2.
Согласны? Вот так вот. h больше либо равно, ну вот этот логарифм можно выкинуть, не важно,
но логарифм N факториал. Так вот, по формуле стирлинга, вот это N логен.
У вас аж высота этого дерева вот такая, значит вы можете сделать количество действий не более,
не менее, чем это количество. Потому что вы должны получить все возможные варианты массива. Потому
что я могу подобрать любые варианты, чтобы у нас была нужная нам перестановка. Согласны? Так
что вот такое вот решение. Это все, что я хотел вам сегодня рассказать. Если у вас будут какие-то
вопросы, говорите. Я прошу прощения, что сегодня было так разорвано, непонятно, я опоздал. Тори,
никто не знал, что в Москве я буду ехать два часа, а не час. Но всем большое спасибо. Я
жду вас в следующий раз. Пишите, звоните, так сказать. Если у вас есть какие-то проблемы с,
не знаю, с чем угодно связанным с курсом, подходите, говорите или пишите мне об этом.
Все, хорошего всем вечера.
