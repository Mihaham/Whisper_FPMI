Так, вот у нас тут был файл overloading, и вот мы даже успели
обсудить, как определять плюс, плюс равно и плюс-плюс,
и даже поговорили о том, почему плюс должен быть
членом, не членом класса.
Да, вот здесь, вот буквально недавно человек только
что в чате основы задавал вопрос, почему, если сделать
бинарный оператор членом класса и сделать ему два
аргумента, то компилятор скажет СЕ, ожидалось два
аргумента, а вы сделали три, ну потому что у всех
членов класса неявный аргумент viss, поэтому если вы реализовываете
бинарный плюс в виде члена класса, то аргумент должен
быть один, кроме viss, но как мы уже обсуждали, бинарный
плюс лучше делать не членом.
Вот, следующее, что мы обсудим, это сравнение, вот, например,
как реализовывать сравнение, как вообще правильно реализовывать
сравнение, какой оператор надо реализовать, а какие
через него выразить.
Ну вот, да, принято, принято так, не знаю, как-то общая
конвенция программирована на плюсах, что обычно оператор
меньше пишут явно, а остальные выражают через него.
То есть, только он не big integer, он будет bool, оператор
меньше.
Вот, и какие у него аргументы?
Ну опять, я по константной ссылке принимаю два big integer,
и ну тут что-то делаю, да, ну, допустим, возвращаю,
не знаю, ну, то есть, что-то возвращаю, вот, его надо
реализовать.
Теперь, как тогда будет выглядеть оператор больше?
Вот я, допустим, реализовал оператор меньше, как будет
выглядеть оператор, ну понятно, как будет выглядеть оператор
больше или равно.
Да, ну, return, что не a меньше b.
Вот, а как будет выглядеть оператор больше?
b меньше?
да сейчас скажу супер не очевидную вещь чтобы проверить что а больше б надо
проверить что б меньше а как вам такое по статистике примерно половина людей
когда делает посылки делать не так они делают не а больше бы и а там равно бы
то есть короче они делают равно у них выражается через не меньше и не больше
сейчас нет равно у них выражается через не меньше не больше да значит больше
выражается через не меньше или равно вот ну короче нет циклов там нет ну
короче либо либо равно выражается очень неоптимально либо больше выражается
очень неоптимально, но вот больше можно уж точно выразить крайне оптимально таким
образом. Когда вам нужно сравнить на больше, вам не нужно на самом деле два
вызова функций делать, вам одного достаточно. Да, это правда, никогда не надо делать два
вызова функций, правда есть проблема как равно, да, как выразить равно. Да, если вы, ну
можно выразить равно как не меньше и не больше. Не, ну как, можно, это не очень
хорошо, да, значит, вот вернуть, что вот так, да, можно было бы написать так, но
это не очень хорошо, почему, ну это неэффективно, вам придется два раза, если
у вас меньше работает линейное время, то есть чтобы проверить, что меньше, вам
нужно пробежаться по строке или по вектору, вот, то чтобы написать равно, вам, чтобы
выполнить такое равно, вам потребуется два прохода по этой строке или вектору,
соответственно, это невыгодно, поэтому равенство разумно реализовывать
отдельно, чтобы было побыстрее, в итоге оператор меньше и оператор равно равно,
это вот по сути два оператора, которые имеют смысл написать руками, все остальные выражаются
через них, а, ну, кстати, вот для строк там есть такой тест замечательный, вот, как правильно
сравнить две строки на равенство, вот, для строк там еще интереснее ситуация, если вы сравниваете
строки на меньше и сравните строки на равенство, там логика разная, ну, сравнить строки на меньше,
можно как, ну, можно strcmp сделать там, а как проверить две строки на равенство, что надо сделать,
сначала проверить равны ли длины, а потом уже проверять по символю, вот, да,
да, ну, просто если у вас длины строк равны, то тот факт, что сами строки не равны, вы можете уже
за вот единицы установить, не доходя до конца никакой из них, ну, это оптимизация, да, конечно,
не доходя до начала, да, вот, в прошлые годы очень многие люди тоже, ну, мало того, что они выражали
равно через меньше, и это само по себе означает, что проверка на равенство очень долго будет
работать, так они еще и равенство проверяли вот этим вот пробегом, для строк выражать равно
через меньше плохо еще по вот этой причине, что у вас равно, оно может в очень многих случаях
отрабатывать за вот единицы, а если вы будете выражать его через меньше, то вы всегда будете
вынуждены за, ну, не за две, но там за хотя бы одну, то есть вы будете идти по символам, вот, короче,
в контесте есть тест, который берет две строки длины одна 500 тысяч, другая миллион и, значит,
там, условно, миллион раз проверяет, равны ли они, чуть-чуть видоизменяя каждую из них по
одному символу, вот, если у вас равно реализовано неправильно, то вы ТЛ получите, я предупредил,
хорошо, уже есть такой тест, год назад не было, но с каждым годом, читая реализации все новых и
новых людей, мы понимаем, что все больше и больше тестов стоит добавить, вот, так, глядишь,
скоро будет полные тесты вообще на всю СТЛ, так, скоро, это, глядишь, спустя 10 лет у нас строка
превратится в настоящую СТЛ строку по требованиям, ну, хорошо, что, что, что? Это правда, да, ну,
когда-нибудь, да, в C++43, минималистичная строка, надо вам скинуть картиночку про C++43,
ладно, это были операторы сравнения, вот, на самом деле, когда вы пишете операторы сравнения первый
раз, это может показаться интересным занятием, тут действительно есть красивое, что написать,
когда вы пишете операторы сравнения во второй раз, но это уже не такое интересное занятие,
когда вы пишете операторы сравнения в десятый раз, вы понимаете, что все ваши операторы сравнения,
которые вы писали когда-либо до этого, это сплошная копипаста, то есть нетривиальная там
только меньше, и то почти всегда оно сводится к сравнению полей, а все остальное это полная
копипаста, потому что операторы больше, больше или равно, меньше, меньше или равно, ну, меньше или
равно, всегда, ну, да, то есть они работают одинаково, по сути, все, что они делают, это выражается
через меньше, либо сравнивают поля, вот, к 2020 году дяденьки в комитете поняли, что, наверное,
пришла пора, в общем, хватит это терпеть, и, кажется, можно уже научить компилятор генерировать
операторы сравнения за нас, начиная с и плюс плюс двадцать, сейчас эксклюзивчик, в прошлых
лекциях прошлых лет этого не было, начиная с и плюс плюс двадцать компилятор умеет генерировать
операторы сравнения за нас, вот, правда, довольно трудно объяснить, как он это делает, ну, в смысле,
да, вы можете, начиная с и плюс плюс двадцать, попросить компилятор сгенерировать за вас все
операторы сравнения, нет, вообще все, смотрите, как это делается, да, можно писать delete на этот
конкретный, тогда его не будет, я думаю, сейчас я вам покажу файл с замечательным названием spaceship,
космический корабль, представьте, что есть какая-то структура s, ну, давайте я какие-нибудь ей поля добавлю,
и я хочу научиться сравнивать эти структуры на меньше, ну, просто сравнение определить,
ну, я мог бы, конечно, определить кучу операторов и все написать, как обычно,
тривиально, но я могу попросить компилятор за меня сгенерировать, ну, я могу попросить
какой-то конкретный сгенерировать, я могу его даже не членом сгенерировать, только мне тогда его
френдом придется объявить, значит, френд, бул, ну да, ну, ну, хорошо, не знаю, ну, давайте класс,
ну, просто тут френд принципиально, френд, бул, оператор меньше, равно default, вот, что это значит,
а как он работать-то будет, ну, а он будет лексикографически сравнивать поля, ну, то есть,
как работает меньше, ну, как бы вы генерировали меньше по умолчанию, просто сравниваются первые
поля, если они равны, то сравниваются вторые, ну, и так далее, лексикографическое сравнение полей,
вот, давайте я проверю, что это работает, значит, s1 у меня будет вот такая структура, и не знаю,
1.3, вот, и я проверю, что, ну, что, ну, давайте это будет a, это будет b, что a меньше b, вот,
должно быть true, но тут мне надо уточнить, что я c++20 компилирую, нет, так не работает,
потому что два аргумента должно быть, конечно, это же внешняя функция,
чего, я не дал им названий, это типа, так, все равно не работает,
ну, на этот раз у меня нету агрегатной инициализации, господи, ладно, давайте так,
да, я вас обманул, значит, нельзя отдельно оператор меньше сгенерировать, можно только сразу все,
ну, можно отдельно сгенерировать равно равно, и можно сгенерировать все, давайте я сразу тогда
покажу, как генерировать все, значит, чтобы сгенерировать сразу все сравнения, надо задефолтить
так называемый оператор spaceship, почему файл называется spaceship, потому что этот оператор выглядит как
spaceship, его почему-то стали называть космическим кораблем на жаргоне, ну, типа, как-то и прижилось,
оператор spaceship, но вот он выглядит так, можно сказать оператор равносильности, на самом деле это
оператор spaceship, вы что, не видите, это же космический корабль вылитый, так вот,
тут другая проблема, дело в том, что у этого оператора возвращаемый тип не буль, а возвращаемый
тип, что вообще такое spaceship, ну, это довольно сложно объяснить, на самом деле, я еще сам не до
конца понимаю, как это работает, ну, ничего удивительного, c++20 пока еще мало кто понимает,
как и c++11 мало кто понимал в 2013 году, c++20 в 2022 мало кто понимает, на самом деле этот оператор,
вот просто вот это заклинание, то, что я написал оператор spaceship от двух аргументов и равно
default, он приводит к тому, что генерируются автоматически все сравнения, вот, только единственное,
у этого оператора должен быть возвращаемый тип не буль, а некоторые специально возвращаемый тип,
который из стандартной библиотеки берется, ну, давайте я пока напишу авто, вот, он должен сам
догадаться, какой он, и все, смотрите, работает, вот, но, формально говоря, авто мы с вами еще не
проходили, поэтому я вам назову этот тип конкретно, этот тип называется std weak ordering,
но сейчас у меня будет ce со словами нет такого типа weak ordering, а, нет, все нормально, и так есть,
ну, значит, он сам добавился, а, в иостреме, наверное, он есть, просто вообще по-хорошему,
чтобы weak ordering, чтобы вот этот тип, ну, чтобы вот эти штуки со сравнениями заработали,
чтобы вот эти стд странные ордеринги включились, нужно заинклудить заголочный файл compare,
это начинает c++20 только, да, ну, слушайте, это костыли компилятора, то есть, ну,
они реализовали это так, чтобы было максимально коротко, можно написать это, и, типа, все будет
работать, будет работать, да, кстати, заметьте, что вы, кстати, заметили, что это segfault не в
run time, а в compile time, да, пока компилятор компилировал, у него segfault случился,
да, да, здесь написано, please submit the full back report, we've preprocessed sources appropriate,
ну, типа, компилятор еще не до конца умеет это компилировать, поэтому я там чуть-чуть ошибся,
возвращаемый тип сделал bool вместо авто, и пока компилятор компилировал с таким возвращаемым
типом, этот оператор у него, у самого компилятора случился segfault, и он написал мне, что, давай-ка,
ты засубмитишь это в bug tracker gcc, мы может исправим, то есть, он предложил мне субмитить bug
report в gcc, ну да, ну да, у компилятора обработчик, скорее всего, поставлен на этот сигнал,
и они, да, видимо, перехватили, вот, ты можешь меньше, нет, если ты, да, если ты хочешь написать
не тривиальная меньше, а не лексикографическая, то ты можешь, а как раз-таки, вот, сейчас должно
сработать, вот, сейчас я попробую определить оператор меньше самостоятельно, а этот задефолченный,
тогда этот задефолченный должен правильно выразить все через меньше, давайте проверим,
значит, ну, давайте, допустим, я буду проверять, что вторые поля разные,
вот, сейчас я сделал в своем меньше сравнение по второму полю, то есть, у меня сейчас b должен
быть меньше, чем a, ну да, а a, соответственно, больше, чем b, то есть, да, если вы хотите, если вы
хотите написать свое сравнение, и чтобы довредили компилятор за вас остальные, то вы делаете вот
так, вы реализовываете свое меньше и пишете вот этот spaceship равно default, и он сам выражает
остальные через меньше, что, а, фу ты, сейчас, a больше b, это неправда,
да, потому что, не-не-не, это не то, так, давайте сообразим, у меня должно быть a больше b или не
должно быть, должно быть, правда, потому что у меня сравнение по вторым, поэтому a должно быть больше b,
да, он остальные операторы сгенерировал, только, кажется, он сгенерировал их не через это меньше
выразив, а через какое-то свое, через дефолтное, да,
так,
так, ладно, давайте я тогда вот что сделаю, нет, я просто хочу открыть cpp-reference, только не хочу,
значит, в браузере это показывать, значит, да, вот теперь я вам покажу, да, ну, вот тут есть длинная
статья, как, значит, этим всем пользоваться, если кому это нравится, вы можете в это вникнуть
глубоко, да, значит, дефолтный оператор, вот этот, он делает лексикографическое сравнение полей, вот,
и дальше
можно сделать дефолтным отдельно оператор равно, вот про это я тоже сказал, вот, а можно
сделать
нет, это как-то можно сделать, но я не помню, как, так просто, значит, не сработало, может быть,
если бы мы их членами сделали, то это бы сработало, но я не уверен
что именно, нет, в компейре лежит стд типа, который должен возвращать оператор, вот этот spaceship,
давайте, ну, у тебя просто может старая версия компилятора или библиотеки, ну, c++, нет,
подожди, версия компилятора может быть старой, ты флаг c++ 20 ставишь, но он еще не до конца
поддерживается, потому что ты ставишь флаг c++ 20, еще не значит, что у тебя будет c++ 20 полностью
реализован, ну ладно, я, да, что-то я забыл, как реализовывать остальные через свое дефолтное
меньшее, один раз в жизни всего это делал и забыл, вот, ну, ничего страшного, давайте, вот что лучше
обсудим, вот сам этот оператор spaceship, что он все-таки возвращает-то, что это за штука стд
weak ordering и что вообще будет, если я вот так вот сделаю, вот, вот, результат этого оператора,
его можно с ним что-то делать, явно вызывать этот оператор-то можно, вот, ну, вот, возвращаемый
тип этой штуки, это так, это объект типа std weak ordering и этот объект, ну, я могу написать std weak
ordering vo равно вот это, а дальше я могу что-нибудь про него спросить, вот это очень странный объект,
он позволяет сравнивать себя с нулем, из полезных действий, что с ним можно делать с этим объектом,
сравнивать с нулем, если он больше нуля, это значит, что значит a-b соответственно больше нуля,
если он равен нулю, значит они равны, если он больше нуля, ну, да, так,
пум-пум-пум-пум, вот, std weak ordering, значит, что?
Кто возвращает? Вот, вот я могу вот эту штуку, вот результат этой штуки сравнить с нулем,
я могу спросить, правда ли он равен нулю, правда ли он меньше нуля? Где?
Ну, это оператор каста к partial ordering, у класса weak ordering есть приведение к partial ordering,
это другое, это приведение оператора weak ordering к partial ordering, вот, а сам weak ordering,
он значит, ну, вот, тут написано, что какие он поддерживает действия, ну, у него, во-первых,
можно члены вот эти вот спросить, то есть, у него есть член less, член equivalent, член greater,
ну, можно спросить, является ли этот объект сейчас меньше, равен или больше, то есть,
я могу спросить, правда ли, ну, давайте std seout vo less, да, ну, давайте я это вот закомментирую,
что-то мне не удался опыт с оператором меньше, вот, я спрашиваю сейчас vo less, правда ли,
и он, а, правильно, потому что less это член класса, а не, вот, я могу спросить, правда ли,
что vo это одно из этого, вот, у типа weak ordering есть такие три возможных значения, я могу спросить,
правда ли, что vo равен вот этому, да, ну, господи ты боже мой, а, наверное, потому что равенство
позже, чем вот так, наверное, да, вот, да, то есть, у меня меньше, ну, я аналогично могу спросить,
это vo это какое значение, less, greater или equal, вот, но я могу vo сравнивать с нулем, что самое
странное, я могу спросить, правда ли, vo меньше нуля, и вот это вообще какая-то магия, то есть vo
меньше нуля это означает, что результат сравнения был меньше, но проблема в том, что я могу сравнивать
ток с нулем, если я попробую сравнить с единицей, то это ce, то есть компилятор разрешает сравнивать
лишь с единственным нулём, ну, только с литералом ноль, нет, вот здесь написано,
то есть вот если я сравниваю объект типа вот этот ordering с чем угодно кроме литерала ноль,
это ub, тут написано, поведение программы, которая пытается сравнить weak ordering с
любым чем угодно кроме как ноль, это ub, вот, не знаю, я не могу здесь сказать, как оно работает на
самом деле, вот, за что купил, зато и продаю, вот, я знаю об этом только то, что здесь написано пока что,
а какой, да, конечно, почему нет, можете написать сами и вам придется тогда возвращать, ну, да,
кстати, кстати, может быть это и ответ на вопрос, как сделать нестандартное сравнение, вы можете
сами написать свой космический корабль, блин, как звучит-то, смотрите, вот уже, вот уже всего
лишь конец октября, а мы уже научились реализовывать космический корабль, видите, как, как, как, как
великий язык c++, чего на фистехе вас научили, все, можете рассказывать всем, что вас космический
корабль научили сегодня реализовывать, вот, ну, короче, да, можно написать свой космический
корабль и в нем определить, что когда возвращается less, когда equal, когда greator, соответственно,
остальные тогда вырезать через него, вот, и, ну, и вроде все должно заработать, наверное, слушайте,
я больше не буду ничего про это говорить, вот, то есть, у вас в c++, у вас следующая задача,
уже будет включен c++20 в контесте и можно будет туда сдавать вот с этим, ну, вот, короче,
с космическим кораблем, да, то есть, в стринге мы вас еще попросим реализовать операторы
самостоятельно, хоть раз в жизни это надо сделать, а дальше в biginteger поэкспериментируйте сами с
этим космическим кораблем, можете там реализовать и заслать c++20 в контест, да.
Чего по одному оператору? А, нет, в смысле, что я реализовал меньше и чтобы он сгенерировал
остальные, нет, не сработало у меня, но он сгенерировал, но они не так работают, как я ожидал,
ну, это как-то можно сделать, но я забыл как, ну, как минимум, я могу определить spaceship сам и тогда
он будет, ну, понятно, остальные сгенерируются из него, ну, то есть, да, я могу spaceship определить
сам и остальные сгенерируются тогда из него. Ну, хорошо, давайте, а, в смысле, что вам придется
много кода писать? Ну, проверьте. Давайте, я не буду сейчас реализовывать. Последнее,
что я хотел бы обсудить, это что такое weak ordering, чем он отличает, какие еще ордеринги
бывают? Вот есть weak ordering, а какие еще есть? Ну, мы уже видели, есть, есть, ну, логично,
что есть strong ordering, а еще partial ordering. Самый слабый это partial ordering, и вы, наверное,
даже знаете из мат-логики, что это такое. Да, значит, partial ordering это такой порядок,
который позволяет, который допускает несравнимые величины, то есть, два объекта могут быть один
меньше другого, один больше другого, эквивалентны или несравнимы. Вот, нет, транзитивность у всех
ожидается, транзитивность, транзитивность у всех есть. Ну как, частичный порядок без транзитивности,
вы что? Нет, ну, default-ный частичный порядок он без транзитивности, если вы напишите свой
порядок, который без транзитивности, то нет, ну, вы можете, но тогда в использовании в алгоритмах это
будет убе, а так-то да, про транзитивность ничего не сказано. Вот, ну, вот weak ordering он отменяет,
вот он убирает вот это вот, то есть, у weak ordering недопустимо несравнимые значения. И weak
ordering это частный случай partial ordering, поэтому его можно не явно сконвертировать к partial
ordering. Вот, а strong ordering, как вы думаете, что такое strong ordering по сравнению с weak ordering?
Вот смотрите, у вас есть, сейчас опять будет немножко математики, вот у вас в логике были
такие, а у вас их еще не было, наверное, но есть эксиомы равенства, да, что там сравнение, ну,
там равенство должно быть там симметричным, рефлексивным, транзитивным, вот, но чтобы это было
прямо настоящее равенство, на самом деле есть еще одна вещь, которая, вот обычно, когда вы хотите
настоящее равенство, а не просто эквивалентность, вы добавляете еще одно требование, а именно,
скажем так, устойчивость к вызовам функций. Вот здесь, вот в этом, вот здесь есть требование такое,
которое отсутствует у substitute ability, подстановочность. Вот у weak ordering его нет,
weak ordering это такой порядок, что из a равно b не обязательно следует, что f от a равно f от b,
где f это константная функция произвольная. Вот strong ordering, он подразумевает, что если у вас
равны значения, то равны результаты f от них. Если они равны, то равны, да, причем f должна быть,
ну да, f должна быть константной по отношению, то есть здесь написано f от a,
equivalent to f от b, где f обозначает произвольная функция, которая лишь читает важные для
сравнения состояния, которые доступны через константные члены, значит, публичные класса.
Вот. Видимо никак, но если ты же не соблюдаешь, то оба.
Ну, я думаю, компилятор это никак не умеет проверять, честно говоря, я не знаю, тоже не знаю.
Ну, скорее всего, можно реализовать, но, например, сортировку без транзитивности лучше не вызывать.
А, вы про транзитивность, нет, транзитивность-то понятно, что компилятор не проверяет, просто у
вас UBS, если вы не соблюдаете. Как он проверяет, что ordering это strong ordering? Фиг знает, может быть,
и никак. Ну, непонятно, как это можно проверить, что типа вызовы любых функций.
Ну, это, наверное, нужно как минимум для читаемости кода, то есть понятно, что вы, когда говорите,
что ваш оператор strong ordering возвращает, ну, допустим, вы реализовали свой spaceship и написали,
что он возвращает strong ordering, то читатель вашего кода понимает, что есть, ну, что вот, что вот это
свойство вы обещали выполнять. Вот. Мог ли он сгенерировать strong ordering? Думаю, мог бы.
А, что тут произошло? А. Нет, это как раз можно.
В обратную сторону можно. Ну да, работает. Ну, то есть, возможно, это просто для читателя кода скорее.
Вот. Ну, как вы могли заметить, я не эксперт в, значит, spaceship-операторе. Вот. Это такое было
ознакомительное путешествие, вот, которое заняло у нас пол-пары, вот, даже больше. Ну, в общем, да,
пользуйтесь. Ну, чтобы не реализовывать свои операторы меньше, да, можно где-нибудь повыпендриваться,
реализовать spaceship будет. Вот. А вот если мы реализовали, допустим, spaceship, ну а хотим, чтобы у нас вот равно было соптимизировано.
Да. Да. Да. Причем, более того, кажется, что если вы реализовали свой spaceship, это даже, вот, я боюсь соврать,
я опять же не помню подробностей, но там есть такой момент, что, по-моему, если вы реализовали
свой spaceship, это еще автоматически не означает, что равно-равно будет работать. И если вы хотите,
чтобы равно-равно работало, вам нужно равно-default для него явно написать. И это как раз сделано потому,
что равно-равно через spaceship, вообще говоря, неэффективно. И если вы реализовали spaceship,
вы могли забыть, что равно-равно у вас теперь будет неэффективно, потому что оно будет меньше
использоваться. Вот. Ну и не равно тоже самое. Вот. Именно сравнения, они через spaceship
автоматически выражаются. Ну, я забыл условия, при которых равно-равно не генерируется. То есть
там есть какое-то условие, которое фиг найдешь здесь в этом cpp-reference даже, когда равно-равно
не генерируется, потому что считает, что оно будет неэффективным, и если вы хотите его сгенерировать,
то надо явно написать. Вот. Ладно, все. Хватит про это разговаривать. Мне надоело. Давайте
что-нибудь другое поперегружаем. Короче, в BigInteger можете использовать эту штуку. Кому
понравилось, используйте. Вот. Не знаю, надо ли вас заставлять ее использовать. Ну, наверное,
на Code Review попросим сделать spaceship все-таки вместо меньше обычного, а то как-то скучно. Так,
давайте дальше пойдем к перегрузке. Мы с вами поперегружали сравнения, поперегружали
арифметические операторы. Ну, понятно, что можно еще перегружать побитые операторы. Кстати,
о побитых операторах. Можно перегружать ввод-вывод в поток из потока. Это как бы побитые операторы,
но они для потоков работают иначе. Как вот перегрузить ввод из потока или вывод в поток?
Вот это интересный момент. Ну, давайте, например, вывод в поток попробую перегрузить. Вот для вывода
в поток должен быть не членом класса, потому что у него левый оперант это поток. Вы не можете
сделать вывод в поток членом своего класса. Вам нужно обязательно сделать его внешней функцией.
Так, а что должен возвращать вывод в поток? А зачем френд его делать? Вот для стринга не надо
френд ни там ни там, потому что у вас все, все что он делает, оно доступно публично. Так и надо,
для стринга вообще френды не нужны. Вот для big integer для ввода в поток вам может понадобиться
френд как раз. Это, пожалуй, единственный случай, где вам может понадобиться френд в big integer,
это ввод из потока. А потому что тебе нужно модифицировать приватные поля, когда ты вводишь из
потока. Ну или прописать для этого другие публичные методы, но не очень понятно. Ты же по цифре вводишь.
Ты же по цифре вводишь. Как ты? Ну ты конвертируешь сначала в стринга потом, но это неэффективно. Вот.
Вот для ввода из потока разумно использовать френд иногда. Что возвращать надо? Что возвращать
должен оператор вывода в поток или ввода из потока? Он должен возвращать. Опять же,
мы должны уметь писать вот такие вещи. Сиаут, что-то, а потом что-то еще. И это партия слева
направо. То есть вот так. Это значит, что возвращаемым типом должен быть снова поток. Но мы же не хотим
копировать поток, поэтому будем возвращать ссылку на поток. Сиаут это поток и тип у него stdostream.
Ну на самом деле stdostream это не его точный тип. Это, скажем так, базовый класс для него. Тип
настоящего сиаута. Он чуть другой. Но нам это неважно. Мы возвращаем ссылку на просто поток
вывода. Так сказать, абстрактный. Так вот, оператор влево-влево, ну или меньше-менше, или как хотите,
сдвиг влево. У него левый оперант. Это что? Опять ссылка на поток. Причем не константная. Заметьте.
Потому что, почему не константная? Потому что мы поток не хотим копировать, опять же. А еще поток
меняется от того, что мы у него что-то вывели. У него состояние меняется. Ну и, значит,
какой-то big integer. Где это написано?
Ну ладно, хорошо. Ну ostream сам по себе, он, это не настоящий тип, это using. По-настоящему
называется basic ostream с параметром char. Также как и string. Да-да-да. Вы же знаете, что string на
самом деле не string, а basic string с параметром char. Да, ну также и ostream. Ну да, хорошо, значит,
у сиаута точный тип ostream. Ну понятно дальше, как реализовывать. Реализовываем там, что надо,
и возвращаем ссылку на вот этот out. Вот, то же самое с вводом. И вот для ввода, как я уже сказал,
вам может понадобиться слово friend. Потому что членом вы его сделать не можете, но вам может
быть нужно к приватным полям обращаться в нем. Хорошо. А какие еще операторы стоит обсудить?
Стоит обсудить операторы. Какие мы еще знаем операторы? Арифметические сравнения по битвы,
increment, decrement. Еще какие операторы? Битвы из двиг. Ну, обсудили. Отлично. А давайте обсудим,
нет, квадратные скобочки обсудим попозже. Сначала давайте обсудим. А оператор new delete
тоже попозже обсудим. Но давайте оператор звездочку обсудим, действительно. Вот оператор звездочка,
правда, вам не нужно реализовывать в ближайшее время. Но оператор звездочка, у него разная семантика,
смотря это унарная или бинарная звездочка. Бинарная звездочка работает как умножение,
а унарная звездочка это разыменование. Вот, поэтому вы можете для своего класса переопределить оператор
унарная звездочка, то есть разыменование вашего класса, типа можно будет разыменовывать. Но
для биг интеджеров, для стрингов это не надо, а вот для некоторых других вещей, например, для
итераторов, когда вы будете реализовывать итераторы, но это уже тоже не сейчас, вот там нужно
переоблить унарную звездочку как раз. Вот за счет чего итератор ведет все как указатель, потому
что в нем разыменование переопределено. Но хуже того, вы можете переопределить даже стрелочку,
а еще вы можете переопределить унарный амперсант. Ну, взятие адреса вы можете переопределить для
своего объекта. Отличный вопрос. Вот, на самом деле, если вы переопределили взятие адреса от
своего объекта, то чтобы после этого вам взять адрес, то вам, возможно, понадобится вот эта
функция. СТД адресов. Эта функция, которая даже если у вас перепределен унарный амперсант,
возвращает вам правильный адрес все равно. Ну, то есть, она как бы кастует вас к звездочке там,
ну, то есть, что она делает? Ну, тут сложно прочитать, что она делает. Она кастует
вас к ссылке на чар и интерпрет кастом, снимает константность, берет адрес от того,
что получилось, а потом кастует это обратно к указателю на Т. Ну, то есть, функция адресов,
это как взять адрес, если у вас переопределен унарный амперсант? Ну, это применить
интерпрет каст к чару, потом сделать конст каст, потом сделать адрес, а потом взять обратно
интерпрет каст к Т звездочке. Нет, это просто, ну как, интерпрет каст, а потом интерпрет каст
обратно. Вот и все. Ну, вот даже, видите, у меня сразу на СТ-коверфло выпадает интересный ответ. Да,
хорошо. Ладно, на самом деле, кажется, в этом пункте все, что я хотел сказать про перегрузку
операторов, я рассказал. Вот, и что я не сказал, это общие слова, какие операторы нельзя перегружать и
что нельзя добиться перегрузкой. Про остальные операторы мы сейчас поговорим в следующих пунктах,
но вот какие операторы нельзя перегружать. Нельзя перегружать точку, нельзя перегружать,
значит, двойное двоеточие, правда, это не совсем оператор, нельзя перегружать стернарный оператор,
нельзя перегружать. Что еще нельзя перегружать? Можно. Можно перегрузить запятую. Можно
перегрузить, можно перегрузить логические операторы и запятую. Зачем перегружать запятую? Отличный
вопрос. Ну, например, если вы хотите, чтобы у вас скалярное произведение векторов работало вот так,
скобочка х запятая b. Да, жаль, что векторное так не будет работать. Но, кстати, о квадратных
скобках. C плюс плюс 23 собираются, насколько я помню, добавить квадратные скобки от многих
аргументов и тогда можно будет, в принципе, не знаю, насчет векторного произведения, но,
ну, в общем, возможно, через несколько лет мы увидим и такое в плюсах. Что еще раз? Да,
запятая это не оператор в том случае. Я же говорил еще раз. Скобки дополнительное
ставь. Скобки дополнительно ставь. Двойные скобки придется тебе написать. Вот,
можно перегрузить двойной амперсант, двойную вертикальную палку. Можно, значит, логические
операторы. Да, можно конъюнцию, изъюнцию определить логическую, запятую, это все можно
переопределить. Вот, что еще важно, нельзя переопределить, нельзя поменять приоритет
операторов перегрузкой и нельзя добавить, тихо, нельзя поменять приоритет операторов и нельзя
добавить свои новые операторы. Вот этого нельзя сделать, перегрузкой операторов. А так почти все
операторы переопределить можно. Даже new и delete, но это мы потом обсудим. Вот, все, давайте дальше.
Дальше следующий пункт, очень важный, на самом деле, возможно, его стоило бы даже раньше
рассказать. Он называется константные методы. Я с вами еще не обсуждал константность методов,
да, да, да, да, да, вам уже их нужно было использовать, да, мы их до сих пор не
обсудили. Значит, параграф три шесть, константные методы и перегрузка квадратных скобок. Смотрите,
вот у вас, начну издалека, вы можете про какую-то функцию сказать, что она не меняет свой аргумент.
Ну, то есть, вот вы принимаете что-то в функцию по константной ссылке. Инты не принято принимать
по константной ссылке. Ну, давайте стринг буду опять принимать по константной ссылке. Вот, и тогда
вы не сможете сюда отдать обычный стринг. Извиняюсь, как раз сможете. Вы функцию, которая принимает не
константный стринг, не можете отдать константный стринг. Вот, но вы даже можете сделать перегрузку,
сделать f, которая принимает константный стринг, f, которая принимает не константный стринг,
ну, по ссылке. И это будут две разных функции, в зависимости от того, какой стринг вы отдали,
вы попадете либо в одну, либо в другую. Вот, возникает вопрос, что делать, если вам нужно вести себя по
разному, в зависимости от того, константным или не константным является сам объект вашего класса,
от которого вы вызываете метод. Ведь смотрите, какая ситуация. Вот, если вы пишете, ну, вот,
если вы берете строку и обращаетесь к ней квадратными скобками, какой должен быть тип у этого выражения?
А тип этого выражения должен быть разным, смотря строка была константная или нет. Если сама строка
константная, то вам должно быть нельзя менять str0, а если строка не константная, то можно. И
как этого добиться? Для этого нужна константность относительно this, то есть вам нужен константный
метод, то есть, ну как, вам нужно уметь различать, в какую функцию пойти, смотря константным или
не константным является текущий объект класса. Вот, и как же это делается? Вот, пусть у вас есть
какая-то структура S, ну, стринг, скажем, это как бы прототип стринг. Вы пишете, оператор квадратной
скобочки, какой должен быть возвращаемый тип у оператора квадратной скобочки в каждом из двух
случаев? Да, в одном случае CharmPercent, а в другом случае ConsCharmPercent. Принимать, да, а вот
возвращать сейчас это отличный, это очень классный вопрос, сейчас мы его обсудим, потому что до прошлого
года я думал, что можно, а в прошлом году мы нашли контртест, который, короче, работает неправильно,
если так делать, и он теперь и есть в тестирующей системе этот тест. Сейчас все расскажу, подождите,
давайте сначала простой пример, значит, вот у вас CharmPercent, оператор квадратной скобочки, sizeT
вот, вот такая сигнатура обычных квадратных скобочек для строк, правильно? Вот, но эти квадратные
скобочки работают только если строка не константная, если строка константная, то такие квадратные
скобочки не должны вызываться у нее, потому что они возвращают CharmPercent, это бы означало,
что если бы вы вызоветесь у константной строки квадратной скобочки, у вас бы вернулась
неконстантная ссылка на Char и вы, получается, смогли бы изменить символ неконстантной строки,
это плохо, но это действительно не скомпилируется, если вы у константной строки вызовете такой метод,
потому что ему не хватает так называемого конст квалифаера, говорящего, что метод константный
относительно самого объекта, и этот конст квалифаер пишется справа от сигнатуры, вот тут,
вот здесь нужно писать конст, ну и возвращать он будет конст CharmPercent. Сейчас я про это расскажу,
но сначала давайте поймем, почему нужно именно конст CharmPercent, а не просто Char,
сейчас покажу, но сначала давайте поймем базовый принцип, что означает слово конст справа от
сигнатуры метода, это означает, что данный метод принимает вис по константной ссылке, ну то есть
в нем вис является указателем на константный объект, его таким образом можно вызывать
от константных объектов данных, вот, и это работает абсолютно аналогично тому, как если бы у вас
была вот здесь вот константная ссылка, то есть вы можете вот этот оператор вызывать как, вот если
у меня не было этого оператора, этот оператор мог бы работать как от константных вис, так и от
константных объектов, так и от неконстантных, но от константных можно вызывать только этот
оператор, вот этот нельзя, то есть неявный каст из неконстантных объектов константный автоматически
делается, и если у вас есть только такой метод, то он будет правильно работать и для неконстантных
объектов, ну я не про квадратные скобки конкретно сейчас говорю, а про произвольный метод, он будет
вызываться и от неконстантных объектов, просто будет происходить неявный каст висов конст, но если
вам нужно разное поведение для константных и для константных объектов, вам нужно два этих метода
определить одновременно, в случае константной строки вы пойдете в первый, в случае неконстантной
во второй, почему нельзя вернуть просто чар отсюда? Казалось бы, нельзя же присваивать, а может
кто-нибудь из вас догадается, вот если так реализовать? Да, смотрите, представьте, что у меня есть такая ситуация,
я говорю, а, ой какое а, str0, нет, вот посмотрите на такой код,
вот если строка корректно реализована, то c должно вывести с z,
нет, сейчас, вот смотрите,
ты про где, какой момент, сейчас, сейчас, да, это неправда, это еще не работающий пример,
а работающий пример вот какой, вот теперь работающий пример, ну смотрите, я завел обычную строку,
потом эту строку по константной ссылке куда-то отдал, и у меня теперь константная ссылка на строку,
которая на самом деле изменяющаяся, сама строка, я потом завел константную ссылку на ее первый
элемент, я не мог, сейчас, подожди, я не мог завести обычную, потому что это уже не скомпилировалось,
я завел вот такую, но если бы эта штука возвращала просто чар, а не консчар амперсант, то создалась бы
копия начального элемента строки, и вот этот консчар амперсант привязался бы к первому
элементу без, значит, ну он бы не был ссылкой на настоящий элемент, и когда я потом поменял бы
настоящий первый элемент строки, у меня это не повлияло бы на c, а должно было повлиять, да,
да, это пример, объясняющий, почему здесь надо возвращать именно консчар амперсант, а не просто
чар, это значит, это значит, видимо, я там как раз вот вот этого вот не сделал, да, значит,
я все-таки этот тест не доработал. Какой у тебя вопрос? Нет, если строка реалацируется,
то все ссылки и указатели на ее элементы становятся неволидными, если я сделал,
завел константную ссылку, нет, если я завел константную ссылку на строку, то это нормально,
если я завел ссылку на элемент строки, после чего реалацировал память в строке, ну то есть
сделал str. ну вот если я сделал вот так, например, то все дальнейшее обращение к c это уб,
любое обращение к c это уб, потому что после пушбека, вообще говоря, могла реалацироваться
память и ссылка будет бита, она будет указывать на элемент, который уже не принадлежит нам.
Нет, ну присваивание по элементу, да, да, да, вот присваивание элемента нормально,
а если мы меняем размер, то если мы popback делаем, то это тоже нормально,
оно не ломает ничего, потому что строка не реалацируется в меньшую сторону, а вот если мы
в большую сторону меняем, или если мы делаем shrink to fit, то все это уб становится. Так,
окей, соответственно, вот сейчас мы пришли к той проблеме, о которой я говорил когда-то давно,
но возможно вы забыли, что это большая головная боль, вам нужно про все методы, которые допустимо
вызывать над константными объектами, писать конст, не забывать, иначе у вас будет огромная,
просто не ошибок компиляции, что кто-нибудь там куда-нибудь константность забыл передать,
и вы короче, все, вам придется искать, где вы конст забыли. Короче, нужно обязательно писать
конст для каждого метода, который вызывается допустимо от константной строки, например,
если вы спрашиваете у строки size, capacity, это все константные методы должны быть,
то есть просто методы getter, которые возвращают вам какие-то числа, они должны быть константными
обязательно. Нет, никто ни от кого не сгенерируется. Вы про квадратные скобки конкретно или про что?
Квадратных скобок должно быть две разных, потому что у вас разный возвращаемый тип должен быть,
у тех и у других. Если вы реализуете только константные, то от неконстантных вы тоже
сможете вызывать их, но только тип возвращаемый будет не такой, как вам надо. Если ты функцию что-то
принимаешь по константной ссылке, ты неконстантную туда можешь отдать? Неправда, можешь. Если
функция принимает константную ссылку на объект, конечно же можно отдать туда любой объект,
в том числе неконстантный. То же самое с константным методом. Ты можешь его вызвать у любого объекта,
в том числе у неконстантного. Но конкретно в данном случае тебе надо, чтобы константный и
неконстантный метод вели себя по-разному. Тут есть еще одна проблема в строках конкретно.
У нас в строках, давайте я опять напишу, что у нас есть три поля. Вопрос, если я вот так напишу,
ну индекс, да. Это скомпилируется или нет? Значит, на самом деле, когда вы находитесь в
константном методе, у вас все поля автоматически считаются константными. То есть из константного
метода, например, я не имею права делать вот так. Константный метод, ну понятно, но формально я об
этом не сказал. Константный метод запрещает вам вызывать неконстантные операции над полями. Если
вы в теле константного метода, то над полями запрещено делать неконстантные операции.
Этот человек настолько крутой, что ты случайно К5 одной рукой не укладывал на плоскости? А то я
слышал легенду про одного человека, который мог. И ты свопаешь символы. Так вот об этом и речь,
что на самом деле СЗ-то я не могу инкриментировать. Тем не менее, если я сейчас попытаюсь
модифицировать R-индекс, у меня получится. Да, в этом и вопрос. Об этом я и говорю сейчас. Я имею
право из константного метода строки вот так сделать. Компилятор мне ничего не скажет,
потому что конст навешивается справа, а не слева на поля. И даже я могу вернуть неконстантную
ссылку на чар отсюда. Компилятор мне тоже ничего не скажет. Потому что у меня полем является указатель.
Константность указателя означает, что сам указатель менять нельзя, а не то, что под ним менять нельзя.
Вот поэтому очень важно реализовать отдельно и константные, и неконстантные квадратные скобки,
чтобы они корректно возвращали тип. Потому что иначе у вас получится, что вы можете возвращать,
то есть можно в принципе, это такая ошибка, которую можно было бы допустить и ничего не заподозрить,
вы могли бы реализовать квадратные скобки просто вот так. Одни только квадратные скобки. Вы могли
написать конст и вернуть неконстантную ссылку. Это бы скомпилировалось и работало бы и для
константных, и для неконстантных строк, только вы могли бы менять константные строки с такими
квадратными скобками. Но это ошибка, которую люди делают. Люди так пишут иногда, потому что они
думают, что ну хорошо, я реализую квадратные скобки, и они возвращают ссылку на чар. И чёт
компилятор ругается, задолбал ругаться, конст надо дописать, ладно, дописал конст. В итоге у вас
получилось вот это, и вы даже не поняли, что на самом деле вы совсем нарушили логику. То есть
здесь нужно понимать, какая логика правильная. Вот, ну ладно, ну бог с ним с указателем. Давайте
представим, что у меня полем, уже забыли про строки, представь, что у меня полем является ссылка на
Инд. Вопрос, могу ли я сделать здесь вот так? К сожалению, могу. Потому что, когда создатель
придумывал язык C++ и только придумывал ссылки, он решил, что ну как бы конст, он справа навешивается,
в том числе и на ссылку. То есть вот этот конст, он контринтуитивно работает, тут ломается интуиция,
что ссылка неотличима от исходного, от исходной переменной. Казалось бы, конст навешанный на ссылку
должен работать вот так. Он должен делать ссылку на константный Инд, то есть то, что мы называем
константной ссылкой. Но нет, конст, навешанный на ссылку, даёт вам вот такое, что на самом деле
эквивалентно вот такому. То есть это как бы вы не можете перепривязать ссылку, но вы и так не можете
перепривязать ссылку. Константность для ссылок в методах класса ничего не добавляет. Да, ну да, то есть
ссылка же хранится как указатель по факту в полях класса, поэтому константность, навешанная на неё,
не дает вам, не запрещает вам менять то, что разуменовано. Вот, это контринтуитивно,
нетривиально, я согласен, ну вот как есть. И последнее, что надо сказать про конст методы.
Это были бы не плюсы, если бы не существовало способа обойти слово конст в константном методе,
иногда вам может быть нужно из константного метода всё-таки поменять поля. Нет, конечно,
вы можете использовать конст каст и реинтерпрет каст, но есть, нет, реинтерпрет каст вам не поможет.
Конечно же, вы можете конст кастом, но это как-то не поджентльменские, как-то не камельфой. Есть более
элегантный способ поменять поле из константного метода. Ну адрес вернёт вам весь константную
ссылку, указатель на константу. Короче, джентльменский способ поменять поле из константного метода. Нет,
джентльменский способ это специальное слово mutable. Вы можете объявить поле с mutable с префиксом,
это ключевое слово, которое говорит, что это поле никогда не константно, даже когда вы в
константном методе находитесь. Вот. Оно мутирующее, да. Вот. И на самом деле это бывает нужно, но опять же,
не надо все поля делать mutable, это не выход. Если компилятор ругается типа, что вы меняете
константное поле, то написать mutable это не выход. Правильно понять, где вы конст забыли.
Mutable означает, что даже если объект константный, это поле, в нём менять можно. Вот. Для чего,
может быть, нужно mutable. Есть два примера. Первый пример такой. Для дебага. Ну, зачастую,
чтобы что-то подебажить, вам нужно mutable написать. Можно потише, я уже кричу как-то громко слишком.
И второй пример. Бывает, зачастую, вот это на самом деле даже более жизненный пример, бывает,
что вам нужно... Вот тут такая философия небольшая, что константность с точки зрения пользователей и
константность с точки зрения реализации, это на самом деле разные понятия. У вас могут быть методы,
которые для пользователя ничего не меняют, но по факту меняют, но пользователь не должен об
этом подозревать. Да, например, это может быть какой-нибудь кэш. Ну, например, вы делаете запрос,
не знаю, к хэштаблице. Вот. Ну, вы, наверное, знаете, что такое хэштаблица. И вы делаете find в
хэштаблице. От этого хэштаблица должна меняться или нет? Ну, с точки зрения пользователя нет. Когда вы
в какой-нибудь структуре делаете find, ну или, я не знаю, банально, вот вы там просто в любом хранилище
делаете поиск элемента. Верни мне значение по ключу. Казалось бы, меняться ничего не должно. Ну,
оно либо не нашлось, либо нашлось, но структура может как-то использовать тот факт, что вы это
запросили и да, и где-то соптимизировать, где-то что-то сохранить поближе, чтобы в следующий раз
запрос к этому был быстрее. Кэширование значений. Есть такая структура данных lru-cache. Может быть,
вы про нее когда-нибудь слышали? lru-cache. Кто слышал такое название? Нормально. А кто реализовал
когда-нибудь? Рекомендую, если будете собес куда-нибудь проходить в какой-нибудь Google,
обязательно потренируйтесь. Это топ популярных задач на собеседование по алгосам. Реализуйте
lru-cache. Ну, короче, структура данных, которая просто хранит типа 100 последних использованных штук там,
и если вы просите значение, то она там его вычисляет, а если оно было недавно запрошено,
то она его быстро вам отдает. Казалось бы, что когда вы спрашиваете, найди значение,
вы ничего не меняете, но на самом деле внутри структура как-то меняется. Есть еще такая структура
данных, возможно, вам даже уже успели про нее рассказать, называется сплей дерева. Кто знает,
что такое сплей дерева? Вы понимаете, что сплей дерева, вот оно примерно так и устроено на самом
деле. Когда вы в сплей дереве делаете find, там именно это происходит. Сплей дерева, ну, если вам
Филипп не рассказывал насчет этого, я думаю, скоро расскажет. Что такое сплей дерева? Это структура
данных, которой каждый запрос find приводит к тому, что этот элемент переходит в корень.
С точки зрения пользователей, я просто использовал дерево, ничего не поменялось, а с точки зрения
реализации дерево перестроилось от того, что я find сделал. Вот, поэтому константный метод find
с точки зрения пользователей реально меняет поля. Вот это то, для чего может быть нужен mutable.
Ну, поэтому, ну, как бы да, но как бы нет. Так, кажется, у нас закончилась пара и давайте,
возможно, мы на этом действительно остановимся пока и продолжим вечером.
Нам надо сейчас быстренько закончить третью главу за эту пару. Пунктов у нас еще много, но они,
правда, маленькие. Значит, мы с вами обсудили константные методы. А, и микрофон. Или так,
о чем? Зачем микрофон? Я могу вот просто рядом его положить вот здесь вот и будет и так слышно,
правда? Правда же? Все. Что полностью? Ну, в смысле, он правда? Так вот, следующий пункт — это
статические методы. Ну, статические поля и методы. Вот, что такое статические поля и методы. Смотрите,
вы можете в какой-нибудь своей структуре захотеть сделать поле, которое является не полем объекта,
а полем самой структуры. Вот оно находится в области видимости S, но не принадлежит никакому
объекту, а общий для всех объектов этого класса. Тогда я называю его статическим. Не знаю. Вот. Ну,
вот так. Например, я могу считать, сколько у меня создано объектов этой структуры. При этом у меня
будет, это не глобальная переменная, а переменная с областью видимости этот класс. Вот. Ну и, допустим,
когда у меня конструктор вызывается, я такое делаю плюс-плюс-каунт. А когда деструктор вызывается,
я делаю минус-минус-каунт. Это не по кодстайлу так писать, как я сейчас пишу, но я... ладно,
можно вот так сделать, чтобы на экраны вмещалось. Вот. Все. Ну, то есть теперь поле count будет
показывать, сколько у меня существует в данный момент объектов этой структуры. То есть понятно,
вот это поле, оно не принадлежит никакому объекту, оно общее для всех объектов структуры. Я обращаться
к нему могу вот таким образом. То есть мне не нужно через точку вызывать его объекта, я через
двоеточие-двоеточие вызываю его, оно внутри область видимости находится прям. Это отличный
вопрос. Ничем. Вот сейчас, если я это скомпилирую, то будет ошибка, скорее всего. Да. Вот. Но это
ошибка линковщика, а не компилятора. Потому что для статических полей работает та же история,
что и для... Ну, короче, статические поля, они не как обычные переменные, для них просто объявление,
это еще не определение. Вот здесь у меня считается, что мое статическое поле не определено. Я обращаюсь
к переменной, которая не определена. Помните, мы говорили, что переменные могут быть объявлены и
определены, и вот значит, если переменная объявлена, то она определена, кроме как,
если экстерна написана. Ну вот статик поля класса тоже считается... Тоже требует
определения. Если у него нет вентилятора, значит, оно не определено. Вот. Но по некоторым причинам,
если я вот так напишу... Сейчас тоже будет ошибка, скорее всего. Да. Значит, по причинам,
о которых, наверное, мы вам расскажем позже, а статические поля, которые не являются константными,
нельзя инициализировать прямо внутри класса. Но это связано с особенностями сборки. Вот.
Почему? Ну нет, скорее... Ну что значит элемент класса? Она не относится к объекту класса.
Эта переменная не относится к объекту, она относится ко всему классу в целом, а не к объекту.
Что? Это очень странное причина. Это очень странное какое-то объяснение. Хорошо,
а почему тогда статические локальные переменные могу так инициализировать? Нет, это какое-то
очень странное объяснение. Компилятор... Когда создается объект класса, ничего с статическими
переменами не происходит. Почему на самом деле нельзя статические переменные внутри класса
инициализировать? Потому что... Ну, определение класса может быть заинклужено несколько раз в разные
места. Вот. И если у вас так получится, что... Сейчас, я пытаюсь вспомнить проблему,
которая возникает, если мы пытаемся внутри класса инициализировать. Я забыл пример,
но она связана с тем, что определение класса вы можете заинклудить в разные места,
и оно может быть много раз заинклужено. Вот. И если у вас переменная не константная,
то это может привести к проблемам. Разное значение должна иметь в зависимости от того,
куда вы ее заинклудили, что это в таком стиле. Вот. Не помню, к сожалению,
конкретный пример. Вот. Почему это нельзя делать? Не знаю, надо погуглить, вспомнить. Ну,
если она константная, то можно. Ну, потому что для константа там однозначно, что... Что?
Нет, смысла очень даже есть. Например, когда вы реализовываете big integer, вы можете сделать
статик constant base. По такому основанию храните числа. Почему? Тогда в каждом объекте big integer
у вас бы хранилось это число дополнительно. Зачем? У вас одна переменная хранится в статической
памяти на всю программу. То, что она статическая, значит, она хранится в статической памяти.
Ну да, не сможете. Ну и что? Ну, если хотите с разными основаниями, то да, надо как-то по-другому
делать. Если вам нужны какие-то данные в классе, которые общие для всего класса, вот. Ну,
или, например, в стринге, в std-стринге есть такая статическая константа npos называется. Это то,
что возвращает функция find, если не нашла под строку. Это статическая константа. Ну,
она равна, я не помню чему, но она равна, она называется std-string-npos. Ну вот, она эта
статическая константа, но не хранить же ее в каждом объекте копию. Она одна на весь класс
стринг, вот, и хранится в статической памяти. Так, что? Где только? Что только?
Вот, например, статическую константу double, можно сделать? Вот, с даблами проблема. Вот,
если я пытаюсь что-то даблом сделать, то это тоже будет, по-моему, ошибка. Да. Значит,
к сожалению, тут, да, тоже есть странные ограничения. Дело в том, что... Ну, это связано с тем, где он
пытается хранить, значит, там есть особая область памяти, в которой кладет статические константы,
и, типа, то ли mp он туда может класть, а даблы нет. Короче, я, честно, не помню этих объяснений,
почему можно, почему нельзя, в одном случае, почему в другом. Вот, это все менялось от стандарта к
стандарту еще дополнительно. Ну, тоже, к сожалению, не могу вам сказать, почему, надо... Настолько
overflow читать ответ, я забыл. Вот, но если мы хотим статик конст дабл, то нужно вне класса опять
инфлидировать. Либо писать конст экспорт. Вот, если я напишу конст экспорт, начиная c++11, стало можно.
Ну, давайте не будем про конст экспорт пока. Ну, короче, пока у нас только int могут быть
статическими константами, а если я хочу дабл, то мне нужно ее определить вне класса.
Ну, давайте я просто скажу, что так решил комитет по стандартизации и уйду от ответа,
почему конкретно. Вот, может быть, Федя вам расскажет, почему, потому что я не помню там
глубинных причин, из-за чего так сделано. Вот, я сейчас пишу конст, значит, что я должен написать?
Я должен написать... Ну, как вообще инициализировать, как вообще написать определение вне класса? Вот,
если я напишу статик int count, как мне сделать определение вне класса? Мне нужно написать int
type, потом название переменной и значение. Вот это я определил константу вне класса. О, работает.
Локально можно без int. Что? Локально там без int получается. Что значит локально без int? Ничего не понял. Что?
Вот это объявление. Сейчас. Это я обращаюсь к переменной, это expression, а это объявление.
Ну и определение тем самым. Понимаете? Что объявлять локально? Вообще,
что угодно, когда в объявлении tip надо писать. Это вообще общее правило в плюсах. Нельзя ничего
объявить, не сказав tip. Объявить в мейне s count нельзя, потому что count он в s находится. Как
ты в мейне объявишь s count? Ты предлагаешь вот так написать? Нет, это какой-то бред. Ты не можешь,
мне кажется, так сделать. Ты можешь в мейне объявлять только локальные переменные, объявлять
переменные, которые из области видимости класса внутри другой функции не связаны с этим классом,
нельзя. Это очень странная штука. Ну короче, ты не можешь здесь сделать qualified ID. Ошибка в том,
что в мейне ты можешь только без префикса вот такого объявлять переменные. Вот, соответственно,
если у меня есть double static const double, то я могу здесь написать, наверное, вот так. Ну да,
только теперь ее нельзя инкрементировать и декрементировать. То есть я повторяю tip,
также как раньше, и пишу вот это definition, а в классе было только declaration. То есть, короче,
правило следующее. Если у вас константный int, ну или константный целочисленный tip,
то его можно и объявить, и определить в классе. А если у вас статическое что угодно другое,
то придется вам определение вне класса выносить. Почему так? Я, к сожалению, не могу сказать в
деталях, но так решил комитет по стандартизации. На это есть какие-то причины глубинные,
связанные с тем, как это в памяти хранится или как там это при сборке устроено. Ну ладно,
это статические поля. А еще есть статические методы. Что такое статические? Да. Ну давай.
Ну это вы пишете в cpp-шниках обычно, да. Ну то есть, да. Это как и с функциями.
Вы объявляете в заголовочном файле, а определяете в cpp-файле.
Скорее всего, да. Нет, ну вы можете, нет, у вас просто требование к имени файла будет
.h, но вы туда можете и header и cpp-шник по один файл пендюривать, потому что мы будем
просто инклудить его разово и все. Это же имеет значение только когда у вас действительно
проект сложный и один файл инклудится в разные места, а когда у вас просто один
инклуд и он подряд идет строчку, то это же неважно. Ну давай вопрос. Если у вас поликлассы,
это константа или ссылка, то да. Ну это 10 с статическими. Хорошо, ладно. Так,
теперь статические методы. Что такое статические методы? Ну это методы, которые относятся как бы
тоже ко всему классу, а не к конкретным объектам. Например, какой можно привести пример статического
метода? Давайте подумаем. Ну, например, например, например. Ну, например, да. Ну, скажем, вот вы
реализуете, я не знаю, какой-нибудь класс типа тот же big integer, например, и вам надо сделать,
не знаю, ну вы реализуете класс даты и времени, и вам надо какой-нибудь вспомогательный метод
там просчитать расстояние между двумя датами, не знаю, или там преобразовать из одного формата в
другой. То есть вы хотите, чтобы этот метод он принимал аргумент, но не относился к объекту вашего
класса. То есть это метод, по смыслу, относящийся к вашему классу, но не относящийся ни к какому из
объектов конкретно. Вот, давайте я приведу классический пример нетривиального использования
статических методов. Это штука, которая называется singleton. Смотрите, у вас есть такой, ну это такой
паттерн проектирования, я бы сказал. Что такое singleton? Иногда вам бывает нужно гарантировать,
что для, в каждый момент времени существует не более одного экземпляра данного класса. Ну,
у вас, допустим, есть какое-то, не знаю, перманентное подключение к какому-нибудь сайту или какой-нибудь
базе данных, к чему-нибудь. И вам надо, чтобы оно существовало всегда в единственном экземпляре.
Нельзя было создать новое, как бы, просто объявив его. Чтобы у вас оно либо не существовало, либо
существовало, но новый объект создать было нельзя, если оно уже есть. Это реализуется с помощью штуки
под названием singleton. Как реализуется singleton? Ну, то есть, задача какая? Представим,
что мне нужно, чтобы мой класс допускал лишь единственный экземпляр себя. Не более чем
единственный в каждый момент времени. Тогда я делаю ему приватный конструктор. Вот. И делаю публичный
метод, который называется getObject. Ну, getInstance, да. Но он будет статический. Сейчас давайте подумаем,
ссылку мне надо возвращать или значение. Что мне надо сделать?
Значит, у меня здесь где-то должно быть запомнено, существует он или нет. Что мне надо сделать? Ну,
давайте static не боль. Да, мне нужно какую-нибудь хранить, возможно, даже не ссылку, а указатель,
потому что ссылка, она же, если у нее нет аналога на lptr. Я говорю static singleton, звездочка,
да, это приватным надо, это правда. Публичное вот здесь. Статический указатель, который по умолчанию
равен nullptr. Вот, когда мне говорят конструктор, я, ну, в конструкторе я могу ничего не делать,
но вот когда мне говорят getInstance, я смотрю ptr, это nullptr? Если нет, то я возвращаю, значит, то,
что под ним, ну, то есть я возвращаю ссылку, чтобы копию не делать. Копию, конечно, делать не хочу,
потому что тогда, получается, второй объект создастся. А иначе, я говорю ptr равно new singleton,
неважно от чего, и return звездочка ptr. Кажется, я повторил логику, два раза написал return звездочка ptr,
правильно было написать так. Нет, я же не константную ссылку на singleton возвращаю.
Статик singleton что? Где ты хочешь написать? Здесь? Нет, почему? А кто сказал,
что singleton под этим указателем константный? Ну, это правда, да, мне класса надо.
Поэтому мне нужно писать singleton звездочка, какая разница?
Declaration это не мешает сделать, singleton звездочка singleton
2.2.ptr равно null ptr. Сейчас проверим, что это компилируется. Ну, да, это компилируется.
Да, то что у меня это приватное поле, это не мешает мне сделать его объявление вне класса,
ну определение вне класса ну потому что я как иначе его определить но оно
приватное да обращаться к нему из функции нельзя но дать ему определение
вне класса конечно же можно иначе бы это было просто нереально
нет кто френд глобальная область френд я в глобальной области же это пишу
чего
так понятно ли понятно ли история с синглтоном пример использования статических метод
кому непонятно спросите что-нибудь задача нужно создать класс который допускает лишь
один свой экземпляр в любой момент времени чтобы его можно было чтобы он существовал
единственный экземпляр и в программе чтобы нельзя было создать второй зачем ну например
у вас соединение с базой данных какой-нибудь или соединение с каким сайтом или что-нибудь
что угодно еще что должно в единственном экземпляре существовать вот либо оно уже
создано и тогда вы должны его получить либо его нет тогда вы должны его создать но вы не
должны создать второе вот такой вот паттерн сингл тон решает эту проблему это правда да это
правда диструктор кстати должен быть публичным что ко чему конструктор приватный чтобы я не
мог извне написать объявить новый сингл тон единственный способ который могу получить объект
сингл тона это вот сделать вот это и вызвать гет инсталс
если бы она была не статичной то это чтобы ее вызвать мне нужен был бы объект сингл тон
мне нужно вот сингл тон получить объект как мне его получить
дилет на дефолтный конструктор тогда я бы не мог его и здесь тоже вызвать
он приватный я могу вызвать его из метода но не могу вызвать его извне
ну кстати на самом деле если здесь диструктор сделать приватный ничего плохого не будет
оно и так скомпилируется давайте проверим так диструктор ни в какой момент не вызывается
вот сейчас компилируется давайте проверим тут что-то у меня а вот это тут потому что им я
так ну все нормально приватный диструктор ничего страшного дело в том что диструктор
не вызывается ни в какой момент а когда он дилет никто не делает же вот ну мне можно было бы
написать какую-нибудь функцию которая типа ну еще можно писать тоже статическую функцию типа
ну то есть уничтожь если он есть и там дело дилет ну и там диструктор соответственно вызываться вот
но извне я все равно не могу но я могу вызвать вручную попытаться тогда конечно будет ци потому
что он приватный но так не надо вообще делать вот ну для обычных объектов и для обычных классов
если вы сделаете приватный диструктор то это приведет к тому что вы не сможете на стэке
эти объекты создавать с или сингл тон а вот это вот с оно не начинает уничтожаться с это же
ссылка если я здесь написал вот так то да то будет проблема вот часто опять не скомпилируется
по какой точке причиней то не скомпилируется сейчас это не скомпилируется потому что
что приватный диструктор но на самом деле еще вопрос а если конструктор копирования
я же тут копирование вызываю я не уверен что конструктор копирования генерируются
если приватный конструктор и приватный диструктор я бы хотел чтобы не генерировался но к сожалению
нет конструктор копирования все равно сгенерируется то есть для сингл тона надо еще
конструктор копирования запретить чтобы было все корректно а то получится что ссылку-то я
получил но зато могу с копированием создать значит вот копирование тоже запрещаю
какие же вы умные все перемещение не генерируется если запрещено копирование какое перемещение
потому что так решил комитет ну вообще ошибки компиляции всегда генерируется к
именно компиляторам да это логично потому что когда вы создаете что-то на стэке компилятор должен
ну это транслируется в код что вначале вы вызываете конструктора когда область не заканчивается
диструктов это означает что вы как будто пытаетесь вызвать диструктор из не метода вот это си так
понятно ли есть ли вопросы про статические поля и методы и мы идем дальше да где вот здесь ну потому
что я копирую сингл тон у меня это возвращает ссылку на объект а я создаю новый объект из того
что справа то есть я второй сингл тон теперь создаю получается это противоречит идее что он
должен быть единственным поэтому я запретил копирование а тут мне нужно ссылку ставить
непонятно но я только что вот здесь запретил копирование до этого не работала потому что
диструктор приватный если бы диструктор был публичный и я бы не запретил копирование то вот
таким хаком я мог создать второй сингл тон и это нарушило бы идею того что сингл тон должен
быть единственным сингл тон значит одиночка я запрещаю вот так писать сингл тон с равно
другой сингл тон перемещение выброси с головы зе нет ни раз до февраля не спрашивайте меня что такое
перемещение до февраля до второго семестра не спрашивайте меня что такое перемещение я не
хочу чтобы умерли уже сейчас так нам еще нужно пережить эту зиму так все идем дальше следующий
пункт это функторы сейчас математики должны в чате снова значит войти в чат пункт 3.8 называется
функциональные объекты и перегрузка круглых скобочек
вот смотрите иногда вы хотите чтобы ваш класс допускал вызов себя как пульте
ну например у вас есть
сет стд сет из каких-нибудь объектов
да ну давайте я буду его называть
мне не нравится что у меня давайте я назову объект мой тайп я не знаю у меня нет фантазии
начнем быть структура май тайп вот и да нет мне даже не нужно свою структуру заводить у меня
другая проблема я хочу сет завести из обычных объектов но сравнивать их необычно вот допустим
я хочу завести сет и стрингов ну что такое сет вы уже знаете наверное это красно-черное
дерево вы же знаете что красно-черное дерево а блин ну ффт вам пригодится когда вы будете
не не надо надо надо чтобы жизнь медом не казалось люди люди до вас реализовывали
ффт и вы реализуете ничего не не умрете что на 5 и за сколько оно работать будет
но это же все равно медленнее чем анлоген ну там константа же будет вырастать сильно
так вот допустим я хочу создать сет из каких-то объектов ну если я хочу создать
это своих объектов то мне для них нужно определить сравнение это понятно что сет
он вызывает операторы сравнения когда деревья разворачивает бинарное себе вот если я хочу
создать сет из известного мне типа но с нестандартным сравнением мне нужен другой подход мне нужно
определить функцию сравнения которая бы передавалась в сет вторым параметром но
что значит определить функцию сравнения мне вот сюда нужно вторым параметром сет записать так
называемый компаратор тип компаратора вот ну конечно сейчас очень умные люди опять все которые
все легче смотрели наперед могут сказать что сейчас миллион до функцию сделаем или там декл
тайп сделаем ну давайте сначала как это делалось как как деды делали а они делали так они писали
ну не настолько старые деды а деды вроде меня как делали они реализовывали свой класс который
назывался компаратор да смотрите я могу реализовать свой класс компаратора и сюда его
отдать что на самом деле делает сет когда вызывает сравнение он не вызывает оператор
меньше напрямую у объектов он вызывает функцию компеер которая по умолчанию уже вызывает
оператор меньше просто по умолчанию если вы не передали в сет вторым параметром объект
ну компаратор то и типа того компаратора по умолчанию оказывается так называемый
стд less от того типа который вы дали в моем случае стд less от стд string less меньше это less
а не lesser вот давайте я вам сейчас реализую less вот как less реализована less реализована
следующим образом там есть стандарт ну там есть конструктор по умолчанию наверное там есть вот
что самое главное что там есть это булевский оператор круглые скобочки как он такое и он
принимает два объекта ну он принимает два объекта моего типа ну давайте я не буду шаблоны
писать скажу что он принимает значит первую и вторую и сам он обязательно константно иначе
не скомпилируется а да да да да вот тут конст должно быть везде констри только конст буль не
надо писать константно по константному значению возвращать ничего не надо был сам по себе не
статическими метод бывают они буль это тип возвращаемый оператор круглые скобочки статик
хотел это спросить в смысле не написать ли здесь статик а что ты хочешь написать где ты хочешь
написать для всех чего это функция бул это возвращаемое значение ее это же не переменная
и что делает этот оператор а он просто возвращает вот это
потому что создается объект less он не статически нет у объекта через точку вызывается круглые
скобочки я могу пользоваться этим классом так я могу спросить less от там abc abcd
ну вот давайте я проверю что это правда
сет не заинклужен сейчас но здесь проблем причина вот в чем у вас сам класс less он
может какие-то параметры содержать себе но объект класс less вы можете конструктор
less вообще говоря что-то отдать ну например я могу захотеть проверить там не знаю ну например
такое сравнение устроить там какая строка дальше по редакционному расстоянию от данной строки
расстояние левинштейн то есть я могу теоретически конструктор less что-то требовать отдать то есть
чтобы данный объект less в полях что-то содержал и в операторе сравнивать зависимости того какое
у меня состояние less сейчас то есть less это не один класс на все вообще сравнения строк у
него могут быть разные параметры причем я их могу еще менять по ходу дела если мне зачем-то
захотелось вот я могу этот компаратор отдать сюда в конструктор то есть я могу сказать что у
меня сет с первым параметром string и со вторым параметром less и этот сет в конструктор ему
отдать вот это less и теперь я могу ну он кажется копию принимать будет то есть если я поменяю
сам less он будет он не повлияет на этот самый на
слишком светло стало чего
в смысле не дает нет ты можешь делать статический оператор круглые скобы а в смысле вообще оператор
круглые скобы с сетом не скомпилиться конечно сет ожидает что это член кло что это через точку
ну сет использует less вот так он берет ваш объект и круглые скобки ему вызывает ну вот я
сейчас могу попробовать скомпилировать и получить один у вас в стандартной библиотеке есть стандартные
компараторы которые называется стд less от любого типа и стд грейтер от любого типа и все что они
содержат это оператор круглые скобочки вот такой от двух аргументов константный соответствующего
типа двух аргументов в стд less возвращается а меньше б в стд грейтер возвращается а больше
б то есть как например мне сделать сет упорядоченный по убыванию где в скобках
это я объект less передал в конструктор сета
ну наверное можешь но вызывать его будет кринжова вроде как принципиально нет
запрета но вот смотрите конструктор сета что в нем есть я могу сделать сет без параметров
ну вот я вызвал этот конструктор по сути сет от объекта компаратора
вот и этот конструктор ну то есть сет внутри себя сохранил вот этот объект и будет использовать
его для сравнения строк теперь если у меня в этом объекте были какие-то поля и я в сравнении как
то использовал эти поля например я сравниваю просто какая строка меньше другой а какая строка дальше
чем другая по редакционному расстоянию от фиксированной строки данной то это будет
в сете использовать но как например мне сделать сет который упорядочен по убыванию не по
возрастанию мне нужно здесь просто передать стд грейтер от стд стринг вторым параметром
понятно как это работает то есть вот эти классы лесс грейтер они на самом деле уже
реализованного стл я правда постоянно забываю в каком файле в утилите по моему по моему в утилите
что нет не обязательно у грейтер есть конструктор по умолчанию там же нет полей в каком классе
ничего не понял что ты можешь не что что ну да это работает как ты можешь определить круглые
скобочки от многих от разных наборов параметров твой объект вот этот лесс он теперь помимо того
что он может иметь поля обычные методы и так далее у него еще и он еще сам как функция может выступать
вот этот вот объект лесс он одновременно и объект и функция это называть функциональный объект
потому что грейтер и так по умолчанию сконструируется объект класса грейтер имеет
конструктор по умолчанию он сам сконструируется туда не надо давать никаких параметров вот если
ты хотел кастомный объект своего кастомного компаратора то тебе надо было бы его отдать
конструктор сета какие круглые скобочки кого не отдавать если я здесь отдам вот свой лесс
то все нормально но если мой лесс требует сам каких-то параметров для своего конструирования
то это уже не сработает все понятно как обычно и что
я именно в этому проблема когда у меня у компаратора нет дефолтного конструктора
я обязан отдать какой-то компаратор сет когда создаю сет потому что сет не знает из чего
создать компаратор об этом и вопрос если у меня у компаратора есть дефолтный конструктор то я
могу не говорить сету какой именно компаратор создать потому что он сам создать дефолтный
думаю что нет думаю что сет хранит именно объект компаратора себе куда
какой объект ну еще один мы только что это обсудили потому что сет если может создать
компаратор сам он создает его по умолчанию если не может то надо создать и передать явно вот
например сейчас он не сможет создать объекта паратора сам потому что компаратор от имп надо
создавать дефолтного конструктора нет понятно можно определить несколько круглых скобочек от
разных наборов параметров можно сделать перегрузку круглых скобочек да у вас может
быть круглые скобочки причем круглые скобочки такой оператор что у него нет ограничений
на число аргументов можете хоть от 10 аргументов круглые скобочки сделать вот такие объекты у
которых есть оператор круглые скобочки называется функциональными объектами вот соответственно
классы называется функторами ну или объект называется то есть функтор и все плюс плюс это вот такие
объекты у которых которые сами ведут себя как функции у них могут быть поля и методы обычные но
но их можно как функции вызывать и например если вы хотите сделать сортировку вот такой же пример
делать с de-server вы можете в качестве компаратора отдать объект этого класса
то есть вы можете его во-первых сет ну сортировку можете указать на функцию просто
дать но вот satisfied у вас просто указать на функцию тут будут проблемы с ним потому specifically
нужно типа звать и вот поэтому придумали такое можно определить класс с которыми
есть круглые скобочки отдавать круглые скобочки туда а с это он соответственно использует
компаратор вот это вот вызывает их через круглые скобочки по умолчанию там
стд л с отыл который вот так реализовала от вашего типа который так
реализован можно и по-другому если вы здесь забудете конст то все не будет
работать конечно же потому что компаратор констант а не отработает
да компаратор кажется не должен быть константным так что конст я здесь
возможно и лишним написал компаратор не обязан не обязан не меняться если
сейчас последняя проверка нет все работает дача
мютабл только к полям можно дописывать
слово мютабл относится к полям а не к методам
так еще вопросы
какой оператор круглые скобы ну можешь ну хорошо
нет конст имеет смысл только для членов класса ну это бессмысленно какой ко это
будет означать конст что нет конст имеет смысл только для членов класса у тебя
нет объекта класса которому быть константным если это внешняя функция то
к чему этот конст относится да
это называется функтор да да да да мне тоже очень нравится теории категории попакивать
не знаю у меня вот теории категории поддает немного знаете там есть вот эти вот категории
функтор и стрелки там стрелки над стрелками так ну ладно это был пункт профункциональный
хорошо идем дальше нам еще три пункта надо обсудить надо поторапливаться так следующий
пункт следующий пункт это пользовательские приведения типов смотрите я могу определить
для своих классов оператор приведения типа к какому-нибудь другому типу например вот у
меня есть структура s в ней есть поле x да значит 3.9 user defined type conversions у меня есть структура
с поле x и я могу это поле ну я могу захотеть чтобы моя структура умела к им кастоваться
вот для big integer вы именно этого хотите будете кстати вы будете хотеть чтобы big integer можно
было скаставать кинт ну логично правда если он превосходит это будет уб но для маленьких чтобы
он оставался кинт вам надо будет как этого добиться как мы добьемся таких удивительных
результатов надо в классе в таком случае написать оператор приведения типа оператор приведения
типа это единственный оператор на ряду единственный метод наряду с конструктором и инструктором у
которого не пишется возвращаемый тип потому что он понятно какой из того что это оператор
я просто пишу оператор и но пишу конст потому что мой объект не должен поменяться от того что
я кинт его привел ну и говорю return x вот это я написал как мой класс s привести к типу
можно написать не конст тогда не константные объекты типа я с нельзя будет кастовать кинф
ой наоборот константные если они написут также как и с обычным если здесь напишу конст то это
не скомпилируется потому что ну по многим причинам да ну в общем да потому что я не
инициализировал константу вот но так и компилируется пожалуйста я научился приводить объекта своего
типа к инт здесь причем я возвращаю новый инт то есть я копию делаю не ссылку на инт а копию нет
но я теоретически мог бы наверное и ссылку возвращать нет почему ссылка же не константная
константным объекте а да это правда у меня константа вы правы правы не ссылка константный
поле константную ссылку только я могу возвращать не необычную ну тут куча проблем меня теперь
нужный ой господи все короче плохо ну короче я могу ссылки приводить да ну так редко делают
обычно приводят к обычным просто что вы хотите сказать ты там кто-то там что-то говорил нет
где да потому что я пытаюсь ссылку при привязать к рвл вот так можно какую ссылку к чему привязать
ну потому что потому что нет унициализатора у поля потому что тут написано нико но это
можно мне просто кучу багов компиляции будет править можно определять операторе касток ссылка
но я сейчас определил оператор касток инт просто давайте если вы очень хотите я определю оператор
касток интерперсанду вот будет оператор им с амперсандом который тоже возвращает x я вот так
сделаю и сейчас это даже работает теперь смотрите я говорю x равно двум и прошу вывести
с точка x сейчас должно быть два потому что я получил ну я с кастовал к ссылке на инт вернув
его вернув ему само поле с и теперь я с этим он том работаю как результатом того каста но меня
его я меняю вот этот x да потому что я констам написал ну потому что потому что вот тебе
перечислено было почему хочешь почитай тут написано почему это не работал ну потому что я
в одном месте написал констант в другом забыл потому что у меня был неопределен конструктор по
умолчанию из-за того что поле сделал ссылкой потому что у меня константное поле было не
вот тебе три причины почему это не конкурировалось так ну понятно про каст к ссылкам понятно ли
просто как каст работает ну каст к ссылке это кстати отличный вопрос для зачета да надо будет
его включить да я в конце первого семестра устрою вам зачет обязательно потому что я уже понял что
если не устраивать зачет в конце семестра то люди забывают половину ну это будет до письменная
работа какая-то такая надо будет там ответить на вопросики вида объявил что я сейчас объявил
инт звездочка конс звездочка звездочка конс нет ну конечно вопрос будет посложнее чем там так
понятно ли как работает каст к инту как определить каст то есть вы здесь вы можете делать какие-то
вычисления ну для биг интеджера вам нужно будет здесь написать что-то и вернуть вот тот инк
который получился и вашу биг интеджер да ну да вы можете написать кастовать к константу но это
довольно странно потому что по константному значению ничего никогда не принято возвращать вот
константные ссылки кастовать имеет смысл иногда к константу без ссылки это странно такого никогда
не нужно делать почти да да сейчас у нас с вами написано неявное приведение типов то есть
да тот оператор который я сейчас реализовал он неявный то есть я могу например взять и
сложить с с каким-нибудь другим интом и это тоже скомпилируется потому что у
s есть неявный каст кинт и это значит что компилятор его рассмотрит для кандидатуры
на значит ну с псен том он сложить не может но он может прикастовать с конту и сложить
инцентом это будет корректно и он сложен вот а это как раз вот помните когда мы с вами обсуждали
перегрузку функции я вам говорил что есть три уровня плохости так скажем преобразований значит
сначала промоушены потом стандартные конвершины потом юзер дефайн конвершины вот это юзер
как раз ну то есть если у меня есть ну вот если я сейчас определю какую-нибудь функцию от int
ну точнее как ну то есть сейчас я не хочу пример придумать если у меня сейчас была
какая-то перегрузка функций и у меня у компиляторов стал бы выбор что для вызова одной версии перегрузки
ему нужно стандартное приведение сделать а для выбора другой ему нужно вы сделать не стандартный
каст то есть мной определенный от с кинт то каст от с кинт он бы рассматривал последнюю
очередь после стандартных но перед много перед элик называется эликсис конвершен перед
кар кастом в многоточие вот а есть способ запретить этому касту быть не явным это на
самом деле очень полезный очень нужный очень важный но кейс когда вы определяете приведение
типов как правило вы не хотите чтобы оно не явно работала для этого есть ключевое слово
explicit собственно об этом и speech файл называется ключевое слово explicit оно применяется к
операторам приведения типов и запрещает им быть не явными то есть теперь чтобы у вас работал
этот каст его нужно явно вызывать вот да возникает резонный вопрос а какой это каст в
терминах плюсов статик конечно вот этот каст который я сейчас определил он просто добавляется
в список допустимых кастов который статик каст рассматривает по сути статик каст это и есть
посмотри какие есть определенные известные тебе корректную функции преобразования одного типа
в другой и выбери из них подходящую статик каст это и есть вот этот оператор он добавляет
статик каст в рассматриваемые варианты что можно к чему привести вашу конверсию еще то есть
теперь чтобы мне это сложить синтом мне нужно будет явно написать статик каст а к значит
кенту вот но но он конвершен фор аргумент ван фор масту инт но если я напишу статик каст а теск инт
это сработает
что сейчас работает без статика сты не работает то что не явный каст
вот то же самое я не могу сказать вот так теперь потому что это тоже считается не явным каст
вот мне нужно значит либо вот так делать вот это уже не считается не явным каст
либо явно писать справа статик каст кенту ну или инт от с вот дальше я могу
ну тут дальше обычно возникает следующий вопрос хорошо а как определить ну как определить каст от
своего типа кенту понятно а если мне нужно каст от какой-нибудь стандартного типа к своему то
как это делается классного проз Ginarearenaru правильно на самом деле каст от стандартного稱о
типа к вашему это просто конструктор вашего типа одного аргумента и нужно какой-то опература
�� на самом деле каст от стандартным типов к вашему таком impossible и статик каст его
тоже будет рассматривать когда вы пишете конструктор своего типа от одного аргумента это вы
по сути и определяете каст с этого типа к вашему и стать corrupted каст тоже с умеет его
рассматривать но для этого для этих для этой ситуации также как и для оператора приведения
типа может быть нужно чтобы этот оператор чтобы это преобразование не рассматривать не было
не явным классический пример представьте что у вас есть конструктор стринг от ind вот но нет
конструктора стринг от чар и вы решили где-то в коде написать с плюс а в кавычках где с это строка
если у вас есть оператор сложения строк и есть оператор конструктора стринг от ind но нет
оператора сложения с чаром отдельного и нет конструктора отдельного от чар то к чему это
приведет это приведет к тому что они явно скастуются в ind ну там произойдет цепочка
преобразования сначала promotion из чара в ind а потом user defined conversion из ind в стринг и у вас
получится что вот это не явно превратится в строку размера 97 заполненную нулями потому что еще
раз у меня есть оператор сложения строк но я забыл определить конструк отдельно оператор сложения
с чарами и забыл определить отдельно конструктор от чара а есть только конструктор от int который
делает строку такой длины заполненную дефолтными значениями тогда вот такое выражение приведет
к тому что у меня эта строка сложится со строкой длины как интовое значение а заполненные нулями вот
чтобы такой фигни не происходило по код стайлу рекомендуется все конструкторы которые от одного
аргумент писать explicit ну если только по какой-то причине вы осознанно не хотите осознанно не
хотите чтобы он не явно в выражениях оставался не явные касты зло то есть конструкторы от одного
аргумента тоже могут быть помечены словом explicit и это два единственных случая когда слово explicit
может быть использована explicit можно помечать либо конструктор одного аргумента либо оператор
каста потому что конструктора двух аргументов не явно ты никак не вызовешь да
да вот конструктор отсеста строки давайте посмотрим вот мы сейчас
просто давайте посмотрим на конструкторы стандартной строки и увидим какие из них
explicit какие нет теперь вы когда смотрите в cvp референс будете понимать что означает это слово
ну вот строка по умолчанию так explicit строка от локатора это мы пока не будем обсуждать значит
explicit так бла бла бла бла бла бла вот где-то еще explicit стоит ну вот explicit да значит есть еще
explicit конструктор от string view like не будем пока обсуждать говорить что это такое ну короче да
остальные конструкторы не explicit вот но если вы например возьмете тот же вектор то вы в нем
увидите конструкторы которые помечены explicit например вот этот конструктор вектор от просто
числа число и по умолчанию значение это вл еще локатор пока не говорим не а локатор пока не
существует в нашем мире значит вот он explicit для чего но чтобы если у вас будет какой-то
оператор действие сложение там не знаю вот вы реализовали какой-то функцию на двух векторов
и в нее передали не знаю оператор сложения двух векторов и в нее передали вектор им не знали
писали в плюс число если бы этот конструктор не был explicit то этого привело к тому что тот
бы не явно скастовался вектор и ну понятно то есть конструктор вектора нового момента тоже
explicit ну и тоже самое с сетом и так далее хорошо да это будет да то же самое по моему кстати каст
мне кажется это равносильность и style касту но я не уверен по моему дает равносильность
и style каста все-таки да это равносильность скорее это скорее равносильность и style касту не
надо так писать лучше писать статик каст да это си стайл касты есть он попробует сначала статик
потом интерпрет и так далее си стайл каст конечно тоже сработает да что если вы сделаете
explicit конструктор от чара то вы не сможете писать explicit равно а вам придется писать
отдельно оператор прибавления чара ну так оно и в общем-то и сделано в стандартной строке
у вас конструктор от чара отдельно и конструктор и оператор прибавления чара отдельно сколько
да но ну можно но но это философский вопрос что из этого лучше с одной стороны вы код экономите
с другой стороны у вас неожиданные конверсии могут происходить так это еще не все ну давайте
блин мы опаздываем ну давайте ладно ну ладно задерживаемся ничего страшного давайте да
да не однозначность будет скорее всего ну будет ambiguous call да вы хотите вызвать
оператор каста или конструктор да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да
да да да да да да да да да да да да да да Carpegnaq
no
да
да
да
да
да
который
так
чтобы можно создать аутента?
Думаю нет.
Потому что цепочки конверс...
А, тогда можно, да.
Если вы в конструктор B переда...
Ну да, у вас произойдёт одна неявная конверсия просто.
Если вы в конструктор B передаёте int,
он увидит, что нет конструктора от int,
но int можно неявно скастовать k.
Если int можно неявно скастовать k,
это одна user-defined-конверсия,
он её имеет право неявно произвести.
Получится.
А если ещё на...
Если ещё на один уровень, две неявно...
Цепочку из двух неявных конверсий он уже не произведёт.
Он может цепочку только из одной стандартной конверсии,
одной user-defined-конверсии сделать неявно.
Но две подряд user-defined-конверсии он уже не будет делать неявно.
Так, народ, мы опаздываем.
Давайте дальше.
Ещё...
Мне нужно ещё две вещи рассказать вам.
Смотрите.
Ну, это хорошо, что вы задаете много вопросов,
только мы не успеваем ничего из-за этого.
Можно определять...
Ну, тихо.
Кому надоело, можете пойти домой,
я всё равно это расскажу.
Значит, можете...
Вы можете для своих типов определить
кастомные литеральные суффиксы.
Помните, что такое литеральные суффиксы?
Для Big Integer это вам тоже надо будет сделать.
Ну, смотрите.
Вы можете написать...
Да-да-да, например, там.
Вот вы пишете 16U,
типа это говорит, что вы имеете в виду 16 unsigned.
Вот начиная с C++11 можно вот так делать.
Так, нет, не так, а вот так, по-моему.
Сейчас. Или я забыл.
Господи, ну как же он там называется-то?
А он, кстати, там кто-то писал.
А у нас там C++11.
А, потому что у меня...
Нет, подождите, сейчас.
Это должно быть в строках определено.
Оператор конверсии к...
Ну, литеральный суффикс.
Для...
Вот он.
Да, вот, я могу так писать,
только не по...
А, потому что мне нужно добавить
using namespace string literals.
Замечательно.
Отлично.
Вот я дописал это.
И после этого
у меня работает такая штука.
Что-что?
Нет, в маленькой...
Глобально плохо, если я делаю
using namespace string literals.
Но я говорил, маленький namespace
в маленькой функции можно.
В рамках одной маленькой функции можно
маленький namespace.
Тихо, тихо, так.
Значит, смотрите,
я могу определить свой оператор
конверсии, свой оператор
преобразования
литералов в мой класс.
Я могу написать.
Как это пишется?
Это начиная с символов
с плюс одиннадцать только работает.
Я пишу.
Допустим, я написал свои строки.
Дальше я пишу string,
оператор, вот очень интересно,
кавычки, s.
Вот.
В скобочках от чего?
Да.
Нет, это внешний оператор.
Вот, оператор, кавычки, s.
И он вот от таких двух параметров.
Но я могу, соответственно,
для своего класса какой-нибудь другой
оператор.
Например, я могу написать вот так.
Оператор, кавычки, b,
от консчар-звездочки
до, ну,
от консчар-звездочки
до, ну, там, не знаю,
digits.
И реализовать здесь,
преобразовать, то есть,
если вы пишете в кавычках
последовательность цифр
и приписываете к ней справа b и e,
это будет означать, что
этот последовательность цифр
трактуется как big integer.
То есть, у вас big integer
сам собой создается.
Вы не вызываете big integer.
Вы как бы говорите,
это литерал типа big integer.
Без кавычек?
Нет.
Нельзя, оператор.
А, да.
Можно, можно реализовать оператор
от консчар-звездочки,
а можно от unsigned long-long.
Вот интересно,
что только от unsigned long-long.
Не от int, не от long-long,
а от unsigned long-long.
Потому что у этого
должен быть самый,
это должен быть длинный,
численный, безлаковый литерал.
Вы можете написать
оператор кавычки b и e
от unsigned long-long digits.
И тогда можно будет
написать им 125.
Тогда, если вы напишете
125 b и e,
это будет означать,
что вы явно сказали это,
ну, только вот так
надо будет писать, кажется.
Это будет означать,
что вы действительно явно,
ну, явно создали big integer,
как бы такой литерал
со значением big integer.
Это такое R-value.
Литерал типа big integer.
А если не целочисленный?
Не целочисленный
нельзя уже, по-моему.
Только от unsigned long-long
и консчар-звездочек.
Да, да.
А если не целочисленный?
seaweed powder
gines
osedlightly
Да вроде нет здесь
без кавычек, безparablea,
без почеркиваevnii
Не знаю
А нет, все нормально.
А, нет.
Литерал операторов с аффиксом not preceded.
Ага.
A reserved for future standardization.
Классно.
Ну да.
Значит, так можно делать, но по-стандартному не рекомендуется.
Да, знак подчеркивания лучше писать.
Да, типа, если вы свои пользовательские, то их со знаком подчеркивания лучше,
потому что без знака подчеркивания они под стандартные, возможно,
и дальнейшие нужды зарезервируют.
Так, окей.
Значит, это вы можете делать свои операторы, свои литеральные суффиксы.
И еще один момент я забыл сказать про explicit.
Смотрите, когда вы будете писать big integer.
Еще один момент, связанный с кастом неявным.
Вам нужно будет в big integer определить как оператор касток int, так и оператор касток bool.
Чтобы big integer можно было в if'ах использовать неявно, как вы int используете.
То есть if, там, какой-нибудь bi, что-то там.
И что если он ноль, то это false, иначе true.
Вот вопрос, надо ли писать explicit в этой ситуации, этому оператору bool?
Казалось бы, if, be, ну, казалось бы, это неявная конверсия.
Нет, это неправда.
Когда вы пишете if, а в скобочках какой-то int, эта конверсия не считается неявной.
Эта конверсия считается так называемой contextual conversion.
И это кастыль, добавленный в стандарте C++11, специально для того, чтобы это не мешало вам создавать explicit.
То есть если вы напишите explicit, вы бы тогда, получается, не смогли бы fah использовать.
Если вы не напишите explicit, то у вас в выражениях он неявно будет bool-к оставаться, и это неприятно.
Вот чтобы не возникало такой проблемы, для конверсий, которые под if'ами и под for'ами, ну, вот в ситуации, где ожидается bool,
применяется понятие contextual conversion, и это не неявная конверсия, она не запрещается словом explicit.
Поэтому оператор CastakBool все равно надо делать explicit.
Вот, такие дела.
Да, слушайте, ну, блин, конечно, не успели мы с вами третью главу закончить, мне еще надо вам два пункта раскрывать,
но я вам рассказал все, что нужно для реализации BigInteger, поэтому, в принципе, ничего.
В следующей понедельник у нас опять будут две пары с вами.
По-моему, да, ну, может, они добавили еще от чего-то, но я не помню.
Ну, вот от этих двух точно можно, да.
Вот, ну, вот в BigInteger я постараюсь BigInteger условия выложить, ой, не знаю, завтра,
чтобы вы уже могли начать реализовывать все, что вам надо, я рассказал для него.
Там будет BigInteger Irrational, вам нужно будет реализовать длинные числа, а также рациональные числа произвольной, ну, бесконечной точности.
Вот, а потом, спойлер, у вас в конце семестра будет задание Matrix, матрицы.
Вот, а потом, спойлер, у вас в конце семестра будет задание Matrix, матрицы.
Мы будем, когда мы с вами будем проходить шаблоны, у вас будет задача реализовать матрицы над произвольным полем.
Вот, и этот BigInteger вам потом предстоит переиспользовать, ну, точнее, Irrational предстоит переиспользовать в задачи матрицы,
потому что, ну, потому что это будет то поле, над одним из которых вам, у вас должны будут работать матрицы.
У нас с вами будет задача реализовать поле рациональных чисел, вот, в этой неделе.
И, когда вы будете реализовать матрицы, вам нужно будет их поддержать как над полем рациональных чисел, так и над конечным полем.
Над полем, ну, над полем остатков по простому модулю.
Вот, и у вас будет реализация матриц, которая корректно вычисляет там обратную матрицу, определитель, вот это все.
Это будет уже, наверное, в начале декабря задача.
Вот, это такое на будущее, чтобы вам, вот все, что вы тут с Филиппом сейчас изучали, оно, в принципе, вам...
