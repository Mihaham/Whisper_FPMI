Тема нашей сегодняшней лекции — это работа с устройствами.
Понятно, что создание ни одной операционной системы
или прошивки без работы с аппаратурой не обходится,
поэтому сегодня мы говорим о вводе-выводе и работе с аппаратурой.
План у нас сегодня следующий.
Мы сначала поговорим о видах ввода-вывода,
которые применяются в аппаратуре на низком уровне,
и поясним, во что они могут вылиться в операционной системе
в процессе реализации стека драйверов.
Потом поговорим о том, как именно операционная система
или прошивка узнает, какое оборудование на вашей платформе доступно.
То есть поговорим о языках описания аппаратуры,
таких как Device 3, таких как ACPI.
И потом перейдем к некоторым примерам устройств,
в том числе тех устройств, которые вам понадобятся в практической части.
Любая операционная система не обходится без таймера
для генерации прерываний для организации планировщика,
поэтому мы сегодня поговорим о таймерах, которые доступны на x86,
и переведем некоторую параллель с тем, что вам придется делать в практической части.
Итак, если говорить о видах ввода-вывода, то в целом их существует три.
Соответственно, классический вариант ввода-вывода через порты,
вы его все знаете по инструкциям in и out в x86.
Наверное, наиболее яркий пример.
Он не единственный, но практически единственный с тем,
где вы можете столкнуться.
Я имею в виду пример x86 как порт map.to.
Второй вариант – это через память.
И, соответственно, вот вывод через память бывает как memory map.to,
то есть вот вывод по инициативе центрального процессора,
когда вы обращаетесь к устройству, доступному через обычную оперативную память.
И вот вывод по инициативе периферийного устройства,
проходящий в обход центрального процессора,
ну, по крайней мере, условно проходящий.
То есть когда вывод инициирует само периферийное устройство,
доступное на вашей платформе.
Вот эти вот способы ввода-вывода – это то, как именно программное обеспечение
взаимодействует на низком уровне с аппаратурой.
На деле же, когда вы работаете с устройством,
чаще всего вы работаете, ну, не обязательно работаете,
только с этими способами ввода-вывода.
Но у вас существует некоторая иерархия драйверов,
то есть некоторый stack драйверов,
который обеспечивает ввод-вывод уже на каком-то логическом уровне.
Соответственно, как пример, если вы работаете с устройствами PCI,
то у вас, например, есть конфигурационное адресное пространство PCI,
и вы просто говорите, прочитайте мне, грубо говоря, нулевой, например,
нулевые 32 бита, чтобы узнать, какое у данного устройства производитель или идентификатор.
Соответственно, то, что чтение из PCI у вас, например, будет реализовано
через порты, этим занимается уже, соответственно, ниже лежащий драйвер,
который работает уже с этими портами, то есть драйвер, например,
его PCI family доступный в вашей операционной системе.
Таким же образом, если вы, например, занимаетесь каким-либо сетевым вводом-выводом
или вводом-выводом через USB, то чаще всего у вас есть некоторый слой абстракций,
который вам в рамках вашей операционной системы
предоставляет доступ как к реальным, так и к виртуальным устройствам.
Поэтому вам стоит понимать, что в классическом современном мире драйверов
драйвер это не обязательно какая-то программная единица,
которая работает с физическим устройством.
Вполне возможно, что драйвер просто является промежуточным звеном
в слое абстрагирования аппаратуры.
Или hardware abstraction layer, ну, соответственно, HAL,
как вы, наверное, знакомы из курса операционных систем.
Соответственно, если же вернуться все-таки к низкому уровню,
а это именно то, собственно, что нам интересно в большей степени,
потому что именно на нем строится вся эта конструкция,
то portmap.to как один из видов водовывода характеризуется следующим образом.
Во-первых, это некоторый набор инструкций.
Набор инструкций in, out, если брать x86, несколько других,
если брать специализированные контроллеры, но, скорее всего,
вы их все равно не встретите.
И, в общем-то, сам portmap.to становится менее популярным
по одним простым причине, что практически во всем мире
сейчас используется ввод-вывод через память, так как бы, собственно, проще.
Ранее исторически просто сложилось, что можно было там
на специальные пины процессора повесить устройство,
которое занимается декодированием некоторого адресного пространства.
То есть, если говорить про x86, то, грубо говоря,
у вас там есть некоторое адресное пространство,
там называемое EOSPACE, и, соответственно, у этого адресного пространства
есть 64 килобайта адресуемой памяти.
Соответственно, каждая, грубо говоря, память, допустим, там 1 байт,
может адресоваться как некоторый порт, ну, соответственно, 8-битный.
При этом, если у вас там, грубо говоря, 2 байта,
то у вас может адресоваться это как 2-байтовый порт.
Таким образом, механизм портов на x86 – это просто способ адресации
некоторого пространства, называемого EOSPACE,
и для этого используются вот эти специальные инструкции.
Соответственно, в чем плюс вот этого способа адресации?
Это то, что в большинстве случаев он реализуется через некоторый хал,
то есть через некоторый слой абстракций,
просто потому что нельзя использовать инструкции in и out
без специальных привилегий, которые доступны вам либо в режиме ядра,
либо посредством манипуляции специальных флагов.
И как результат, обычно операционная система это как-то абстрагирует,
чтобы хоть как-то обеспечить разграничение доступа к устройствам на x86.
Hardware abstraction layer буквально произносил,
соответственно, некоторый слой абстракций аппаратуры,
который присутствует в операционной системе.
И соответственно, бонусом вот этого способа водовывода
появляется простое эмулирование.
То есть, если вы пишете гипервизор,
то вам очень легко эмулировать порты водовывода,
потому что они используют специальные инструкции.
На эти специальные инструкции можно поставить vm-exit,
то есть вызов гипервизора.
То есть, вам не нужно никаких...
Учение аппаратура за вас все сделает.
Порты водовывода бывают как фиксированные, так и конфигурируемые.
То есть, в случае с фиксированными портами
вам информацию о них предоставляет разработчик процессора,
в частности, Intel публикует на каждый чипсет
некоторый список фиксированных портов,
к которым можно обращаться, и соответственно,
у них определено поведение.
Так и, собственно, конфигурируемые, которые
может вам настроить разработчик вашего биоса
и определить именно те устройства, которые будут подключены к конкретным портам.
Соответственно, разработчик материнской платы имеет с возможности
подключить к процессору в рамках адресного пространства портов
разные устройства, и вам они будут доступны.
Соответственно, в некоторых случаях эта информация документируется,
в некоторых случаях она не документируется,
но основные устройства, которые вам нужны,
вы сможете получить из языков описания аппаратуры,
о которых мы поговорим чуть позднее.
Третьей особенностью порт Map.to является возможность
их эмуляции на уровне System Management Mode.
Соответственно, это полезно, в первую очередь,
для совместимости с устаревшими операционными системами,
то есть если вспомнить, условно, какие-нибудь ДОСовские времена,
которые достаточно затянулись, то, например, вывод на экран
осуществлялся через специальные порты ввода-вывода
для того, чтобы старые операционные системы, которые не поддерживали UFI,
например, Windows 7, полноценную UFI не поддерживали,
потому что не поддерживали вывод на экран в UFI режиме,
могли вполне нормально запускаться на современных прошивках,
то в биосе действительно настраивались специальные обработчики,
которые отлавливали запись в эти порты ввода-вывода
и выполняли необходимые процедуры,
фактически добавляли некоторый слой совместимости
по вызову уже реально существующего драйвера
и отображения какой-то информации на экран похожим образом.
Нет, System Management Mode, никакого гипервизора.
Смотрите, через гипервизор вам стоит задача
поддержки каких-то операционных систем.
Соответственно, если вы делитесь разработчиками QMA
с акселератором KVM, то вам нужно добавить, например,
эмуляцию устройства RTC в ваше собственное...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
