значит
канал вот дальше
Доказательство, то же самое, что и Endless Pace, поговорим вообще про разные власти, связанные с памятью.
Ну и вот есть истина для телевизорных инструментов анализа.
Слушайте задачу, это изучение того и ваше, а не полного, в одном классе.
Ну и в некотором смысле любая задача в одном классе была в любой суть этого класса.
То есть можно ее терпенно сформулировать в любой другую задачу в этом классе.
Вот мы и много говорим про F-полную задачу, а точно говорим про PSP-полную задачу.
Ну определение точно такое же.
Значит, там B является PSP-полной, если B сама лежит в PSP,
и для любого A из PSP верно, что A сводится к B, причем сводимость та же самая.
Да, значит, иногда может показаться, что раз у нас тут память, то и сводимость должна быть полинамеральной по памяти.
Но это не интересно, было бы, потому что полинамерально по памяти там все друг другу сводится.
Точно так же, как внутри P, все друг другу сводится полинамерально по времени.
На этом вообще нас тут интересует вопрос, равны ли P и PSP?
Даже этот вопрос открыт, не только равны ли P и NP, не только равны ли P и полинамеральная иерархия, но и даже равно ли P и PSP?
Это тоже открытый вопрос.
Ну и соответственно, чтобы его изучать, можно изучать полные задачи в большем классе,
но они как бы будут полны относительно сводимости из меньшего класса.
То есть в данном случае относительно полинамеральной сводимости, обычной по карпу.
Так, хорошо.
Ну а дальше может быть такой генерический PSP-исполненный язык.
Генерический PSP-исполненный язык.
Ну можно его называть Space TM SAT.
Ну и он очень похож на генерический NP полный язык.
То есть тут мы более-менее спрашиваем.
Спрашиваем именно про тройку, уже нет никакого Y, потому что в определении PSP-ис нет никакого Y.
Значит, а тут тройка из M входа X.
Значит, и S лунарной записи.
Ну, тут, в общем, неважно, можно как я сейчас напишу, можно просто там S записывать.
Значит, тройка из M, X и S единиц.
А, да нет, даже можно, прям так и нужно.
Значит, что M от X.
M от X равно единице.
И использует не больше, чем S ячеек памяти.
Да, тут нужно именно в лунарной записи, чтобы сам этот язык лежал в PSP-ис.
Ну, почему он лежит в PSP-ис?
Ну, потому что нужно учиться вот это вот проверять.
А как мы это будем проверять?
Ну, более-менее запускаем универсальную машину тюринга M от X.
И выделяем ей место S.
Если она вышла за пределы отведенного места, то тогда мы говорим нет.
Если она остановилась и выдала единицу, тогда мы говорим нет.
Если она остановилась и выдала ноль...
Ой, подождите, если единицу говорим да, не выходя за пределы.
Значит, если ноль, то говорим нет.
Но еще может быть ситуация, когда она зациклится.
Да, то есть тут...
Да, я сейчас запишу, значит, почему он принадлежит PSP-ис.
Значит, ну, получается, что запускаем M от X на памяти S.
Теперь получается, если вышла за пределы S, то, соответственно, вернем ноль.
Если остановилась, то тогда вернем ее ответ.
Если остановилась и выдала единицу, тогда нужно единицу.
Если остановилась и выдала ноль, вернем ее ответ.
Но еще есть третий вариант, что она зациклилась.
Тогда, конечно, тоже нужно выдавать...
Конечно, если она зациклилась, то тоже нужно возвращать ноль.
Но возникает вопрос, а как проверять зацикливание?
Потому что мы не можем, например, записывать все возможные конфигурации, которые были.
Что значит зациклилась? Значит, повторилась конфигурация.
Но мы не можем, например, записывать все возможные конфигурации, их хранить и каждую новую сравнивать с теми, которые уже были.
Для этого нужно будет слишком много шагов, слишком много, точнее, памяти, чтобы их все хранить.
Вместо этого мы будем их не хранить, а только считать, то есть будем считать шаги.
И тогда дело в том, что на фиксированной зоне может быть только ограниченное число, причем экспоненты ограниченное, число конфигураций.
Потому что на съезд ячеев в каждой из них может быть любой из символов алфавита, это экспоненциальное количество,
ну и умножить на еще немножко, умножить на состояние, это константа на число положений возможных указателей, это еще какой-то логарифм.
Да, в общем, самое главное, что есть экспоненциальное число слов, которые можно написать.
Вот, значит, есть экспоненциальное число слов.
Ну, значит, есть экспоненциальное число слов, как следствие, есть экспоненциальное число конфигураций.
И получается, что можно максимум экспоненциальное число шагов сделать, прежде чем остановиться.
Иначе, по принципу Дерехле, там какая-то конфигурация повторится, и дальше будет происходить движение по кругу.
Поэтому достаточно просто считать шаги и контролировать, что их число не превысит экспоненту, а для этого нужно еще порядка S ячеек.
Соответственно, контролируем зацикливание, просто считая шаги машины и проверяя,
что их не больше, не больше, чем конфигурации.
Вот, ну и для этого нужно еще порядка S памяти.
Это потребует то большое от S памяти, ну и таким образом общая память будет линейна, ну и, как следствие, пальномиальна.
Так, хорошо, это первая часть, ну а вторая часть, почему PSPACE трудная, это более-менее очевидно.
Значит, PSPACE трудная, получается, что если A лежит в PSPACE, и распознается машиной M на памяти какой-то S,
ну, S от N я, давайте, напишу, где н длина х, тогда получается, что сводимость будет просто, что х превращается в тройку
из M, х и единица, повторенная S от длины х, а раз.
Ну и тогда как раз х лежит в A, тогда это только тогда, когда M от х равно единице,
когда M от х работает на такой памяти, а это ровно то же, что вот про эту тройку написано в определении, соответственно, SPACE TEM SAT.
Поэтому любой A сводится к нашему генерическому.
Так, ну чего, понятно?
Ну это как обычно, значит, если вообще в классе какой-то полный язык есть, то тогда в том числе такой будет полным.
И соответственно, как раз вот трудность более-менее всегда одинаково делается, а вот принадлежит тому же классу не всегда верна вообще.
Именно с этим связаны примеры, когда полных языков вообще нет.
Так, ну дальше вот это вот формально верно, но как с этим работать, совершенно непонятно.
И можно переформулировать, значит, можно переформулировать в задачу достижимости графа, достижимости вершин в графе.
Мы в прошлый раз говорили про конфигурационный граф, про пути в нем, про то, что можно решать на какой-то совсем маленькой памяти.
Вот, и это соответственно можно обобщить.
Задачу поставить так.
Так, ну тут, например, есть какое-то описание.
Ну давайте это как-то phi обозначим, описание, значит, s и t.
В графе g-phi есть, в or-графе можно писать, значит, в ориентированном графе g-phi есть путь из s в t.
Что имеется в виду? Что имеется в виду, что размер этого графа 2 в степени n вершин.
То есть в графе g-phi есть 2 в степени n вершин.
В графе g-phi есть 2 в степени n вершин, а ребра задаются как раз вот описанием phi.
g-phi это строка длины полинома от n.
Ну дальше, значит, по phi и паре из двух вершин у и в, значит, можно проверить за полиномиальное время.
Верно ли, верно ли, что пара у и в лежит в е.
То есть phi это какое-то такое очень сжатое, значит, саксинкс это сжатое, то есть очень плотно заархивированная информация про граф.
У совместного графа есть какое-то короткое описание, но при этом оно, хотя и короткое, может быть таким довольно неочевидным.
Ну, грубо говоря, очевидно, когда я говорю, что там вершину и и g соединяю с и плюс 1 g, и и g плюс 1 и что-нибудь еще.
Да, это тоже будет очень короткое описание, но в таком графе там не будет особой проблемы понять, есть путь или нет.
В общем случае, phi какое-то такое неочевидное описание, так что не сразу можно понять что-то про этот граф, но при этом короткое.
Вот. Ну и тогда получается, что, соответственно, такая штука лежит в PSPACE, оно лично тому, как мы в прошлый раз с Терем Саевича доказывали.
Значит, тут лежит PSPACE. Опять же получается рекурсивный алгоритм, рекурсивный алгоритм.
Да, то есть тут можно писать там reach от x, y, от x, y и k. Значит, это есть ли путь, есть ли путь из x в y длины не больше, чем 2 в степени k.
Соответственно, если k равно 0, это означает, что x равно y, или есть ребро, или x, y лежит в е.
Значит, и соответственно вот это вот, ну первое можно просто непосредственно проверить, а второе можно проверить исходя из phi.
То есть вот это вот проверяется исходя из phi. Вот. Ну а дальше, соответственно, рекурсия reach от x, y, k плюс 1.
Это будет disjunction по всем z, значит того, что reach от x, z, k и reach от z, y, k.
Вот. Ну и соответственно, глубина рекурсии будет как логарифм длины максимального пути.
Логарифм максимальной длины пути. Максимальная длина пути не больше, чем число вершин в графе, то есть не больше, чем 2 в степени n.
То есть будет n этапов рекурсии, на каждом этапе добавляется перебор вот этого z.
А z это еще n, потому что z это индекс вершин в графе.
Ну и всего порядка n в квадрате памяти нужно будет, чтобы этот рекурсивный алгоритм весь провернуть.
Вот. Поэтому какие бы ни были детали того, как именно phi задает граф, если это можно вычислить за полиномиальное время,
то, соответственно, в принципе даже можно здесь потребовать, чтобы на полиномиальной памяти только это определялось.
Да, все равно это полиномиальная память, она еще добавится к этому всему.
И будет в итоге тоже полиномиальная память.
Но как правило, это какие-то описания простые, типа phi там описывает машину тюринга или какую-нибудь схему логическую,
или еще что-нибудь такое. Вот. Про схему мы еще поговорим через пару лекций.
Так, хорошо. Значит, это вот он так лежит в PSPACE, потому что можно рекурсивный алгоритм сделать.
Ну, а PSPACE-трудность...
Значит, PSPACE-трудность происходит из того, что можно считать, что граф конфигурационный,
g-phi это конфигурационный граф машины m на входе x.
Ну, а со само phi это просто сама машина m вместе со входом x.
Вот. Ну и понятно, что если у нас есть x, то мы его как бы подставляем вот в это описание.
Ну и получается, что тут как бы в phi еще нужно добавить описание алгоритма.
Ну, можно считать, что phi это такой самораспаковывающийся архив для графа.
У нас, соответственно, в phi есть и программа, которая нужна, чтобы любой...
И он как бы такой локально самораспаковывающийся, то есть можно по тексту архива,
не обязательно прям весь файл генерировать, можно как конкретный кусок файла.
То есть это как бы такой самораспаковывающийся архив с параметром.
То есть в него можно попросить, что написано там в файле с такого-то байта по такой-то байту.
И он вернет только вот эту часть архива, не генерируя все вместе.
Как бы такой локально самораспаковывающийся архив. Вот что такое это phi.
Получается, что вообще результат очень длинный, но можно любой кусочек,
может любой кусочек сгенерировать по вот этой программе и запросить, что это за кусочек.
Вот.
Ну вот, соответственно, phi это вот инструкция, что делать с описанием машины и входа,
что нужно... там же еще ув на вход подается, ув это две конфигурации.
И инструкция заключается в том, что нужно по этим двум конфигурациям
и команда машины M, и входу X понять, есть ли переход из первой конфигурации во вторую.
Вот это вот то, что нам нужно понимать.
Ну и понятно, что это довольно стандартными методами делается.
Так, ну ничего, понятно.
Так, хорошо.
Хорошо, значит, вот это...
Но тем не менее, это такая еще довольно общая задача.
И можно сказать, что вот здесь мы просто формально записали,
значит, здесь мы формально записали, как бы, что мы вообще делаем в PSPACE.
Соответственно, здесь мы это чуть-чуть отошли от записи чисто через машины,
но все равно, что нам нужно...
А, нам же еще что нужно?
Нам еще S и T нужно.
Вот это я забыл.
Да, но это понятно, если это начальная конфигурация,
значит, S это начальная конфигурация,
а T это принимающая конфигурация.
Ну и чтобы это была только одна принимающая конфигурация,
можно добавить какую-то виртуальную принимающую конфигурацию
и ребро из каждой обычной принимающей, где просто T не принимающая,
вот в эту виртуальную.
Да, и соответственно, получается вопрос,
можно добраться из начальной позиции в принимающую,
действуя каждый раз в соответствии с программой.
Но это и есть вопрос о том, вернет ли программа единицу.
То же самое, что у нас там было.
Ну вот, значит, все-таки это еще недалеко отошло.
И дальше, как мы уже говорили,
в НП полных задачах была выделенная задача у выполнимости,
значит, ко НП полных была выделена задача у тавтологичности,
на уровнях полиновальной иерархии были тоже выделенные задачи
с чередованием кванторов.
Вот здесь тоже есть аналогичная задача,
называется TQBF.
TQBF, расшифрованная,
TQBF расшифровывается как totally quantified Boolean formula,
то есть Boolean formula, в которой поставлены кванторы по всем переменам.
Соответственно, язык формулируется как множество таких phi,
что там существует x1 для любого x2,
существует x3 и так далее.
И здесь, соответственно, phi от x1, x2, x3,
и так далее.
Здесь, в отличие от полиновальной иерархии,
где нам явно нужно было указывать, что x это не отдельные переменные,
какие-то целые блоки переменных,
здесь, в принципе, может быть так, что x и y отдельные переменные,
потому что здесь не ограничено количество кванторов.
Если у нас подряд одни и те же кванторы стоят, мы их можем искусно разбавить
другими кванторами, так чтобы они чередовались строго по одной переменной.
Ну ладно, здесь тогда сделаем перерыв.
Значит, вот эта задача, TQBF.
Значит, ну во-первых,
как обычно,
доказывая, что она PSPACE полная, нужно вначале
доказать, что она лежит в PSPACE.
Ну и это, в общем, делается точно так же
рекурсивно.
Значит, то есть рекурсия получается, что
x1 равно 0.
Потом считаем то, что
начинается со второго квантора.
Ну и, соответственно, потом x1 равно 1.
Ну и берем disjunction.
А тут, соответственно, получаем, что x2 равно 0.
И, соответственно, считаем, что существует x3 там
для любого x4 и так далее.
То, что осталось x2 равно 1.
И беремся, соответственно, конъюнкцию.
Ну и так далее. Значит, соответственно, так вот идем, идем, идем, идем.
И как раз глубина получается такая же, как тут число переменных.
Ну а переменных в формуле не больше, чем ее длина.
То есть вот получается как раз
полиномиальная глубина рекурсии.
Ну а тут на каждом уровне мы просто один бит храним,
поэтому всего полиномиальное число битов для рекурсии.
Ну и в самом конце нужно будет просто вычислить функцию phi
и вычислить х. Ну и это тоже
какая-то несложная операция.
Просто по таблицистинности просто делать.
Тоже будет порядка полиномиальной памяти.
Ну ничего, понятно.
Вообще это типичная ситуация, что язык лежит в PSPACE,
если он вычисляется каким-то рекурсивным образом.
Ну и дальше
PSPACE полнота.
Ну PSPACE трудность получается.
PSPACE трудность получается
аналогично, в общем, по похожим образом
на то, что у нас было
сейчас, по похожим образом на то, что у нас было в Теремисевиче в прошлый раз.
Вот, но еще там
один компонент нужен.
Во-первых, тут общая идея, что там все свойства можем выражать
вот я буду пользоваться теми же обозначениями
с достижимостью. То есть там reach
reach от x и y1
значит reach от x и y1
можно записать
записать формулой
ну, от какого-то константного
от константного числа переменных.
То есть у нас вот там
конфигурация описывает с каким-то числом переменных
а, сейчас, не, подожди, не от константного все-таки.
Нет, это я глупости написал. Нет, не от константного, но от пальномиального.
Да, или даже от линейного.
От пальномиального, но важно, что тут как бы уже никаких кванторов не будет.
Просто значение x-ов фиксировано, значение y-ов фиксировано и просто
какая-то вот между ними связь.
Вот, хорошо. Значит, дальше
в принципе получается
да, вот это вот disjunction можно заменить на квантуру существования
да, это стандартная операция
reach
от x и y и k плюс 1
да, значит, можно написать так, это тогда будет равносильно
к тому, что существует z
такое, что reach
от x и z, k
и reach
от z, y, k
Вот, так тоже можно писать, но если это
не инструкция по вычислению, если это прямо формула
то при такой записи возникает проблема, что
у нас как бы вот эта вот формула два раза повторяется
и соответственно длина возрастает вдвое и еще плюс немножко
Да, значит, соответственно тут получается проблема
что длина
возрастает вдвое
А, знаете, что вот здесь было важно, что, конечно, формула
от полинарных числа переменных, но еще и сама формула полинарной длины
И вот здесь уже нужна специфика того, что это именно изменение
в машине тюринга небольшое
Да, значит, тут важно, что сама формула
тоже полинарной длины
Да, и тоже, конечно, не любая функция выражается формулой полинарной длины
от n-переменных, но в данном случае выражается
потому что это как раз
достижимость в графе, значит, одно ребро в графе
и это, более того, не просто ребро в графе, а это шаг машины тюринга
Шаг машины тюринга заключается в том, что
почти везде ничего не меняется, и это очень
простая формула, что вот этот бит не изменяется, этот бит не изменяется
и так далее
И только там, где стоит указатель, там что-то меняется
и вот там-то как раз можно прямую просто таблицу ясности записать
В небольшой окрестности меняется по задней таблице
а все остальное не меняется
Но, конечно, какой именно окрест меняется тоже не фиксировано
но это тоже по полинарничеству вариантов
В зависимости от того, где стоит указатель
Если тут указатель, то тут меняется остальное на месте, если тут, то тут
И там тоже полинарничество вариантов, и в каждом полинарничество равенств
и еще небольшое для константа
переменных уже просто произвольная функция
Но все вместе это будет по полинарной длине формулы
Так
Так, ну хорошо, что же делать?
Что же делать вот здесь вот?
Ну, там некоторый трюк, который, может быть
некоторые из вас помнят из курса логики
А именно, когда мы там проходили
очень короткие формулы, которые выражают какое-нибудь свойство
там такой же трюк использовался
Так, и трюк выглядит следующим образом
Так, значит, я продолжаю равносильность
Существует Z для любого U, для любого V
Значит, если
х равно U и
наоборот, ну, то есть, неважно, да, но логичнее
наоборот, U равно х и V равно Z
или U равно Z и V равно
Y, то тогда
reach от U, V, K
Вот, вот такая вот формула
То есть, для любой пары, если эта пара, это вот эта пара
или эта пара, это вот эта пара, то тогда
соответственно от первого элемента пары
до второго можно добраться за K
шагов
Вот, и вот тут уже мы получаем преимущество
в том, что мы только один раз recursive формулу записываем
Да, и вместо того, чтобы увеличивать в двое длину как происходило здесь
мы ее увеличиваем на константу значит, на вот это вот
значит, на вот эту вот константу формула увеличивается
Но тогда если мы этот полинимационное число раз сделаем...
если мы этот полинимационное число раз удвоили, то у нас получится эксп Reynolds длина
А если мы вылечили полинимационное число раз на константу, то получится полинимиальная длина
Ну вот. Ну и еще, соответственно, чтобы получилось так, как здесь написано, нужно еще привести к предваренно нормальной форме.
То есть, если вот этому уже заменена форма с кванторами, то кванторы отсюда надо вынести сюда.
Вот. Соответственно, вынесу все кванторы в начало.
Значит, получим постановку, постановку TQBF.
Вот. Поэтому это сводится, да, свели вопрос удостижимости, значит, к вопросу, соответственно, вот этой формуле с кванторами.
Так, хорошо. Как еще можно посмотреть на вот такую цепочку с переменой кванторов? Да, может быть, поэтому вам расскажут какие-нибудь вопросы есть.
Конечно. Ну, можем, можем, да. То есть, тут получается вот эти кванторы, да, это не по отдельным переменам, а по группам переменам, которые описывают вершину в графе.
Ну, соответственно, можем перебирать, да, значит, на главную форму написать.
А если мы требуем, чтобы были отдельные переменные, то мы еще добавляем фиктивные кванторы по фиктивным переменным, которые вставляются между настоящими кванторами по отдельным переменным этих описаний.
Вот. Хорошо. Значит, на самом деле вот такие вот чередования существуют, для любого существуют и так далее, у нас уже были в полинаминальной иерархии.
Вот. Соответственно, как и там, значит, можно интерпретировать вот эти вот цепочки со сменами кванторов через игры.
Можно интерпретировать цепочки кванторов, цепочки кванторов как игры.
То есть тут, соответственно, получается, что игрок 1, игрок 1 выбирает x1, потом 2 выбирает x2, потом снова 1 выбирает x3, значит, 2 выбирает x4, и так далее.
А в итоге фи говорит, кто выиграл. Фи сообщает, кто выиграл.
Ну, может, тут игрока 2 лучше было назвать игроком 0, тогда фи прям говорит конкретно, кто выиграл, а так фи говорит только четность того, кто выиграл.
Ну и тогда вот такая вот формула с кванторами означает, что у первого игрока есть выигрышная стратегия.
Значит, тогда и только тогда, когда у игрока 1 есть выигрышная стратегия.
То есть у него есть такой хороший первый ход, что как бы потом не сходил второй, он сможет сходить снова так хорошо, что как бы не сходил потом второй, и так далее, в результате все-таки выиграет первый.
То есть можно сказать так, в итоге такой вот цепочке переходов, можно сказать, что любую задачу SPACE-SPACE можно интерпретировать как вопрос о том, у какой из сторон есть выигрышная стратегия.
Вот в такой игре, в какой-то игре, которая длится, тем не менее, полиномиальное число ходов.
Значит, вот это здесь важно, значит, что игра длится полиномиальное число ходов.
Потому что могут быть, в принципе, игры, которые дольше длятся.
Значит, сразу уникает вопрос про какие-нибудь игры, которые, ну, на самом деле, не длится полиномиальное число ходов.
И соответственно, чтобы вообще ставить вопрос о сложности игры, нужно сначала эту игру обобщить на
Доску произвольного размера. Но, скажем, шашки очень легко обобщаются на Доску двойного размера.
Ну, там нужно сказать, насколько горизонтальный, там, ставить шашки и так далее.
Ну, вообще, можно это сделать, вот hu Rachel,
насколько горизонтальей там ставить шашки, и так далее, но вообще можно это
сделать. ГО еще проще обобщается, но для ГО там нужно, наоборот,
нужен квадрат с нечетной стороной, а в остальном там ставится камня, но там в ГО
есть тонкие правила со снятием камней, если кто не знает, в ГО
нужно ставить камни разного цвета и так окружать какие-то территории.
И еще там есть хитрые правила, что в некоторых ситуациях там какие-то камни
снимаются, которые уже поставлены, и, соответственно, тогда, вот если бы ничего не
снималось, тогда ясно было бы, что ходов не больше, чем клеток, а если они снимаются,
то там нужно аккуратно смотреть, будут они длиться сверхполиномерно-долго, или,
все-таки, полиномиально. Шахматы мне еще сложнее, потому что шахматы мне неочевидно,
какой набор фигуры должен быть на доске N на N. И кроме того, там есть еще всякие
специальные правила. Не, в принципе, и шашками тоже возникает некоторый вопрос,
сколько это будет длиться реально, может, на самом деле, долго длиться.
Например, в шахматах можно поставить какое-нибудь условие, типа там правил 50 ходов.
Есть в обычных шахматах правило 50 ходов, что если на протяжении 50 ходов ни одна
фигура не съедена, то игра заканчивается ничьей. Ну и тогда, соответственно, на
доске N на N должно быть какое-то число, порядка N или порядка N в квадрате, что если
такое число не было взять и фигур, то тогда игра заканчивается ничью. Вот с таким
правилом очевидно будет полимерное число ходов, потому что всего фигур
полимерное число должно быть, либо порядка N, либо порядка N в квадрате.
Ну шахматы скорее порядка N, там должен быть ряд испешек и какие-то фигуры.
Соответственно, фигур порядка N, и, соответственно, если больше чем N в квадрате
ходов не может быть без взятий, то всего ходов будет не больше, чем N в кубе.
Тогда это подпадет вот сюда вот. А есть, например, такого правила не делать, а делать только
правила, там еще есть такой правил о троекратном повторении позиции. А это, значит,
ситуация, троекратное повторение позиции означает, что если три раза одна и та же
позиция на доске появилась, то тогда тоже ничья. Но вот это правило уже не дает
ограничений на полимеральное число ходов, потому что позиция-то разное как экспоненциальное число,
и даже если каждый из них повторяется три раза, то все равно общее число ходов может быть экспоненциальным.
Ну вот, соответственно, если как-то игра обобщена и получилось, что она точно идет в полимерное время,
то тогда она точно будет в PSPACE, и, соответственно, можно будет ставить вопрос о том, будет ли она полна в этом классе.
Ну и вот я хочу рассказать про одну конкретную игру, которая будет полна, и это называется игра в города.
Игра в города, вы, наверное, знаете, как, в принципе, играют в города.
Значит, там нужно называть города или там какие-нибудь другие слова так, чтобы каждый следующий город начинался на ту букву, на которую заканчивается предыдущий.
Повторяться нельзя, и, соответственно, кто не может ничего придумать, тот проигрывает.
Ну обычно это воспринимается как такая игра на эрудицию, там кто больше городов знает, но в принципе тут может быть и такое математическое измерение,
потому что есть такие буквы, на которые городов заканчивается много, а начинается мало, и, соответственно, вот можно пытаться все время придумывать города, которые на эти буквы заканчиваются с целью, чтобы у противника исчерпались слова.
Но с другой стороны, противник тоже может так делать, и тогда получается вопрос, у кого быстрее исчерпаются слова.
Да, и если кто-то из игроков больше знает, то, соответственно, этот игрок выиграет, но если две программы, у которых один и тот же список возможных городов, то это же такая комбинаторная игра получается.
Да, что вот, нужно как-то вынудить, но суметь самому назвать последнее последающее слово так, чтобы у противника вариантов не было.
Ну а мы рассмотрим чуть-чуть более общий вариант. Это называется обобщенная игра в города.
Значит, тут вместо того, что как-то буквы отвечают за то, что можно после чего называть, здесь будем считать, что есть просто некоторые графы.
Значит, G-ориентированный граф с выделенной начальной вершиной.
И, соответственно, в эту вершину ставится фишка.
Вершину ставится фишка.
Ну и, соответственно, получается, что два игрока по очереди двигают ее вдоль ребер.
Так что, соответственно, нельзя повторять вершина.
Значит, так что нельзя ее заводить туда, где она уже была.
Значит, так что вершины не повторяются.
Значит, кто не может сделать ход, проигрывает.
Значит, игрок, который не может сделать ход, проигрывает.
Ну вот, вопрос, значит, кто выигрывает при правильной игре, да, у кого есть выигрышная стратегия.
Значит, почему это именно обобщенный граф города? Ну, потому что, значит, на городах там тоже есть какой-то граф,
когда мы соединяем город X с городом Y, если город X заканчивается на ту же букву, на которой начинается Y.
Но тогда, значит, в таком случае непроизвольный граф получится.
Посмотрите, если после этого можно назвать вот этот, после этого вот этот и после этого вот этот,
тогда вот этот тоже можно назвать.
Да, потому что это означает, что здесь и здесь последняя буква такая же, как здесь и здесь первая.
Вот, это совершенно непроизвольное свойство графа.
Вот, значит, поэтому вот для графа с таким свойством я на самом деле не знаю там,
что получается, будет ли это. По-прежнему PSP полная задача.
А вот для призвольных графа сейчас расскажу, как строится, как строится свадимость.
Да, но прежде чем строить свадимость, нужно еще поговорить про вид формулы.
Да, вот у нас в NP был вопрос не просто про выполнимость формулы, а про выполнимость 3KNF.
Но, например, про тавтологичность 3KNF вопрос бессмысленный ставить.
Да, потому что 3KNF будет тавтологией, только если там в каждой скобке есть какая-то переменная и ее отрицание.
Да, а так обычно, если там написано P или Q или R и что-то еще, то есть мы возьмем там PQR равный нулю,
то что бы там еще ни было, это уже будет не истина.
Я считаю, что про тавтологичность 3KNF бессмысленный вопрос ставить, он тривиальный, а никакой не KNP полный.
А на уровне полинамеральной иерархии, на самом деле, важен какой там последний квантор.
Да, зато для тавтологичности можно вопрос про 3DNF ставить.
Да, для 3DNF она наоборот будет KNP полной.
Ну вот, а вообще в полинамеральной иерархии там есть цепочка кванторов,
и важно какой квантор последний, не первый из цепочки.
То есть если последний квантор это существование, тогда можно считать, что phi в 3KNF.
Если последний квантор всеобщенности, тогда нет, нельзя считать.
Ну а здесь у нас кванторов сколько угодно,
так что мы вполне можем считать, что у нас последний квантор существования.
А здесь phi еще привести к виду 3KNF.
Ну, будут у нас там какие-то еще лишние кванторы.
Потому что процедура самая обычная.
Мы говорим, что формула равна единице.
Если там существуют такие значения под формул,
что во-первых, значения под формул согласованы со всеми значениями переменных,
и во-вторых, вся формула будет равна единице.
Соответственно, это вот можно сделать.
Поэтому можно считать, что у нас phi в 3KNF.
Но вроде это на семинарах должно было обсуждаться,
по крайней мере на моей группе обсуждалось, и в листочке было.
Если так, если не было и со слуху непонятно, то подумайте,
почему мы вообще пишем про 3KNF, почему можем заменять,
и почему это сработает для tQBF тоже.
Будем считать, что у нас phi в 3KNF.
Фи в 3KNF, а иксы это отдельные переменные.
Иксы это отдельные переменные.
И тогда получается вот такая вот картина.
Вот есть исходная точка.
Стрелка из ниоткуда, это начальная вершина.
И дальше возникает вот такая вот развилка на такой ромбик.
Но соответственно, тут как бы выбираем x1 у нас будет 0 или единицей.
А дальше происходит как бы передача хода.
То есть тут вот первый игрок, в зависимости от того,
куда он подвинет фишку, сюда или сюда, он выбирает либо 0, либо единицу.
Потом у второго игрока нет выбора, он возвращает вот сюда вот.
И потом первый сдвигает вот сюда.
Вот здесь уже второй выбирает.
Второй игрок выбирает x2.
Соответственно, он тоже выбирает либо 0, либо единицу.
И потом это все куда-то возвращается.
И снова придется ход.
Теперь, соответственно, первый игрок выбирает x3.
Тут тоже либо 0, либо единица.
Соответственно, возвращается, придается ход и так далее.
Итак, получается такая гирлянда.
Гирлянда из ромбиков для всех переменных.
Так что, проходя по ней, мы выбираем значение всех переменных.
Так, и дальше мы приходим в конец.
В общем, мы делаем так, чтобы была такая выделенная вершина.
Значит, в ней ходит игрок 2.
У нас наша формула phi.
Но это будет knf, то есть конъюнция отдельных скобок.
Значит, конъюнция отдельных скобок.
И соответственно, здесь вот второй выбирает c1, c2, c3 и так далее.
Так, а c1, например, будет...
Так, x1, x2, x3 там написано.
Значит, например, x1 или не x2, или x3.
Так, и мы будем считать, что вот эта левая вершина 0 означает,
что перемена равна 0, единичка означает, что она равна единице.
И тогда стрелку мы пишем наоборот.
То есть c1 у нас x1, а мы соответственно в 0 отправляем стрелку.
x2 у нас с отрицанием, там мы в единицу отправляем стрелку.
Соответственно, x3 само по себе, поэтому мы тоже в 0 отправляем стрелку.
Ну и так же со всеми другими.
Вот, все, вот и дает, что вот такая конструкция графа.
Так, и теперь почему выигрышная стратегия в такой игре соответствует
правильному выбору значений переменных формуля.
Значит, ну смотрите, пусть там вот для формулы, пусть у игрока 1 была выигрышная стратегия.
Тогда у него есть, значит, тогда у него есть хороший выбор значений x1.
Значит, например, x1 равно 0.
Ну тогда он, например, сходил вот так вот.
Соответственно, потом второй вернулся сюда.
Значит, первый пошел вот сюда.
Теперь второй ходит.
Ну а второй, например, тоже в 0 пошел.
Значит, тогда после этого первый возвращается, второй передает ход.
Теперь снова первый ходит.
Ну а тут он, например, единицу пошел.
Ну и так далее.
Значит, так все идет.
Потом, смотрите, вот здесь второй выбирает.
А, ну понятно, что здесь вот этот ход второго
первый интерпретирует как выбор значений x2 равно 0 вот в той игре на формуле.
И после этого там есть хороший ход x3, и он его же повторяет вот здесь вот.
Ну и так далее.
Потом игрок 2 выбирает одну из этих скобок.
Ну у нас в итоге все эти скобки должны быть истинными.
Соответственно, вот, например, выбрал c1.
Ну у нас здесь x1 равно 0.
Значит, x1 равно 0.
А x2 равно тоже 0.
Ну и тогда получается, что второй сходил вот сюда, а первый может сходить вот сюда.
А после этого у второго уже нет варианта,
потому что вот это уже было пройдено как бы на основном пути.
И поэтому первый выиграл.
То есть получается, что если вот та скобка истина,
то из вот этих трех вершин, куда идет стрелка, раз, два и три.
Хотя бы одна не будет посещена, пока мы шли вот по этой гирляндии.
И поэтому первый сможет сходить в нее, а после этого второму уже некуда ходить.
Поэтому первый выиграл.
Первый выиграл, если все вот эти скобки оказались истинными,
тогда первый выиграл вот в этой игре.
Потому что, смотрите, тут идея такая, что вот эта стрелка,
как раз в то значение, которое делает, но которое не делает истинную скобку.
Соответственно, если мы вот здесь прошли, там здесь прошли, вот здесь прошли,
то получится, что у нас х1 равно 0, х2 равно 1, х3 равно 0.
А тогда вот эта скобка была бы ложной.
Раз она истинна, значит одна из этих не посещена.
Ну а в другую сторону, наоборот, что если у второго есть выигрышная стратегия,
то уже он ее здесь будет повторять.
То есть интерпретировать первый ход первого как выбор значения х1,
на него отвечать выигрышным значениям х2,
потом интерпретировать следующий как значение х3 и так далее.
И в результате получится, что конъюнция ложная.
И тогда вот здесь у второй может выбрать скобку, которая ложна.
Ну а ложная, она это означает, что, соответственно, у нее
не как здесь написано, наоборот скажем, вот эта посещена,
вот эта посещена и вот эта посещена,
и тогда уже, наоборот, у первых здесь будет не будет входов.
И тогда первый проиграет.
То есть получается, что выигрышная стратегия первого в той игре
перекладывается на выигрышную стратегию в этой игре,
а выигрышная стратегия второго в той игре тоже перекладывается на выигрышную в этой игре.
Вот. Но поэтому, соответственно, какой здесь ответ, такой и там ответ, поэтому получилась сводимость.
Ну и, конечно, нужна замечание, что это сводимость пальномиальная.
Ну, конечно, тут граф будет пальномиального размера, порядка числа переменных плюс числа скобок.
Вот, строится вот так вот, понятным образом.
Ну а сама игра будет в PSPACE, просто потому что любая игра с пальномиальным ограничением начало ходов будет вот в PSPACE.
Так.
Да, в общем, это более-менее всё. Сейчас будет звонок через полминуты.
