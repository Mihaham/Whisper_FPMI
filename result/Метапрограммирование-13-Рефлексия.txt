Ну что? Всем привет, товарищи. Сегодня будет жесть. Заранее предупреждаю. Я второй год подряд думаю
наконец-то на вот именно эту лекцию, принести там какую-нибудь мантию, такой вот капюшон,
свечи расставить здесь, потому что ближе к концу мы будем настоящим колдовством заниматься.
Но в целом, что? Тут сложное разделение, не готов ответить на этот вопрос, давай после пары. В целом
наша цель сегодня это отрефлексировать над своим поведением, а еще над структурами,
янамами и прочими штуками. Ну и первая вообще такая самая простая шняга, которую можно сделать.
Ну да, никого не смущает, что мы рефлексии собрались заниматься, хотя ее нет в C++. Сейчас речь
не о пропузелах, которые есть, о том, что давайте добавим нормальную рефлексию, о том, что уже
сегодня вы можете взять, добавить в свои продакшн и очень разгневать этим всех. Потому что это
write only code, как ты выразился. Понять, что происходит невозможно. Отличная идея. Ну окей, в общем,
на вашей совести использовать это не использовать, добавлять, не добавлять, мое дело только рассказать.
Первая такая темка, это имена просто отрефлексировать. Что мы хотим? Есть там структура,
янам, функция что-то там в коде написанная, и мы хотим в constexpr получить строку, в которой написано
имя этой сущности. То есть тип, функция, поле, элемент янама, сам янам, ну это тоже тип. Ну в принципе,
все научимся сегодня. Есть несколько подходов, все из них плохие, так и дальше будет.
Конечно же, можно при процессорзвязать, всегда можно. Ну что предлагается? Взять какой-то define
сделать, вместо того, чтобы писать просто класс, писать через define класс, там как-то подсовывать
имя, через решетку его получать. Решетку знаете, да? Она токен какой-то, который пришел как аргумент
в функциональный макрос, превращает в строку, строковый литерал именно. То есть вот прям вот в
compile-time получили ровно то, что хотели. Но это скучно. Почему? Ну что, да, можно по-другому это как-то
подкостылять. Ну там написано вариации, тут масса разных. Можно свободную функцию, можно переменную
извести. Столько всего придумало человечество в этом плане, но хорошо все равно никогда не выходит.
Хорошо вышло у жуликов. Жулиничать можно так. Да, нас тут game development. Здесь вы видите код не
совсем на C++. В этом залог как бы успеха. Это вот Uclass, это вроде как и макрос, и когда у вас там
какая-нибудь IDE вам отображает код ваш, этот макрос определен и превращается в ничего, но на
самом деле, когда вы билдите ваш проект с вот такими вот штуками, запускается некоторый
препроцессор кода. И этот препроцессор с помощью какого-нибудь кланга, как библиотеки парсит весь
ваш код, находит все классы помеченные вот такой штукой и генерирует для них какой-то код,
в котором, например, может быть написано имя в том числе. Да, и генерируется код в некоторый
файлик дод generated.h. Ну, соответственно, предполагаем, что это вот все в файлике myobject лежит.
Вы его инклюдите руками, и у вас там какие-то макросы появляются уже настоящие, которые
разворачиваются в, например, имя этого класса. Ну, это реальный пример, если что, из вот Unreal
Engine, там ссылочка есть, она не уехала, не уехала. Это работает не только в Unreal Engine, очень много
таких разных фреймворков для написания всяких приложений, игр и так далее, где такие техники
используются, пишут свой препроцессор, и все довольны. В принципе, это, наверное, даже самый
лучший подход. Если вам все-таки нужна рефлексия в C++ в современном мире, делайте вот так. Оно надежное,
работает, легко поддерживаемое, легко читаемое. Да, порог вхождения увеличивает, потому что,
если вы неподготовленный разум, придете писать код на Unreal Engine с знанием плюсов, то вот это вот
заставит вас задуматься, что происходит, что за generated, что тут какие-то непонятные макросы.
Ну, не сильно сложно, поэтому можно терпеть. Код ген, да. Он сам вообще запускается,
но и мы можем сами. Ну, там очень сложный пайпланет того, как билдится игра на Unreal Engine.
Но первым делом там действительно запускается код ген, и он генерирует вот этот файл. В нем там
куча всего пообъявлена. Например, macros generatedBuddy. Вот вы этот файл include'ите и generatedBuddy
вписываете, и вы довольны. Вам сюда вкидывают всякие методы типа getName или getClassName.
Ну, как бы мы расширили язык C++ своими собственными костылями, потому что комитет никак не может
договориться, как это в язык строить. Ну да, в принципе это обычное дело. Какой-то сеньор в Epic
Games сидит, мейнтейнет тулзу на C-шарпе написанную. Как он решил, оно работает, так оно и работает.
Ну, то есть вообще этот предпроцессор я могу просто как-то не писав код на Unreal Engine,
я могу свой проект забрать как процессор. Их предпроцессор от Unreal Engine? Не знаю,
можешь попробовать, но скорее всего там из-за какого-нибудь legacy он достаточно плотно в костылен.
Но это пишется достаточно легко, я даже думаю какую-нибудь задачу такую штуку дать. То есть у нас
тоже есть свой предпроцессор в нашей компании, прекрасно работает, всякую рефлексию он не
генерирует, он там для других целей. В общем делается много где, давайте пойдем дальше. Кошерный
вариант. Кроме Аркадия, видели ли вы когда-нибудь вот такой macros pretty function? Нет. Догадайтесь,
что он делает? Пару имен функций. Нет, macros он ничего не возвращает, macros он заменяется на что-то.
Заменяется на пару, имя функции и указательная функция. Ну то слишком много умнейшая при процессоре
из ACC, просто на имя функции, строковый литерал. Вот этот macros заменится на плюс-минус то, что
написано вот здесь, но в кавычках. То есть возьмем какую-нибудь структуру foo и попробуем вот этот
хелпер запустить. Что нам выведут? Как вы думаете? Ну что такое авто зарезолвит? Ну в целом да. То есть
конечно правильный ответ здесь до черт его знает, это нестандартная фичар, ширине компилятора,
оно поддерживается всеми мажорными компиляторами и даже минорными скорее всего, но как бы никто
вам не гарантирует ничего про то, как это по факту работает, но по факту почти на всех компиляторах
оно работает вот так. То есть вам обязательно напишут, что там за t получилось. Вот, да я прав-то
сказал зачем-то, не прав-то речь, про t. Да, вот оно действительно написало, что t это foo. Ну что,
поняли как получать имена всего вообще на свете? Ну подсказка еще. Нужно вам имя класса. Запускайте
такой хелпер, берете под строку от равно до закрывающей квадратной скобки победа. Нужно вам
название элемента янама, ну хорошо, название элемента янама это как бы не тип, сюда его передать
нельзя, ну какие проблемы, на авто b заменим и все будет работать. А это может в Compile Time работать?
Это и работает в Compile Time. То есть в Compile Time я могу запарсить и достать вот эту фуфу. Ну конечно,
тебе это и будет требоваться в домашке. Ну надо, тут для краткости опущено. Ну конставала даже надо,
потому что еще раз, вот это macros, macros он заменяется текстово на что-то, на вот эту строку он
заменяется. Вот прям вот написав вот такую вот штуку здесь, вы как будто бы написали прямо в коде
return, кавычка, вот такая строка, кавычка. Почему бы этой функции, которая просто ретернет строковой
литерал, не быть конставал? Никаких проблем. То есть это действительно в Compile Time позволяет
рефлексировать любые имена. То есть общий план такой, просто вот берем вот под строку из этого
претифанкшена и мы победили. Но вот нюансы. Во-первых, при разных сущностях, то есть элементах
янама, типах, еще чем-то, вы будете получать разные строки и вам по-разному нужно под строку
убрать. То есть там за хардкодить offset не получится. И разные компиляторы в разном формате эту
строку выводят. А что ты будешь вайнить? МСВЦ решил, что надо в треугольных скобках выводить.
Все равно. Ну как бы, я думаю, все вы справитесь посмотреть на формат, в котором выводит конкретный
компилятор. Тут, я не помню, клан коллега СС. Ну что-нибудь такое, да. То есть вы справитесь,
имея десяток таких примеров, как выглядит тип при подстановке сюда, взять и общий алгоритм
найти, который всегда работает. Просто эту работу надо будет проделать много раз. Для разных
компиляторов, разных систем может быть даже. Ну короче, много проблем, но это делается. И мы
получим кусочек библиотеки Magic Yanom, в которую это все уже за вас реализовано. Долго, сложно,
муторно и печально. А почему не добавить этот стандарт, чтобы фиктированная была реализация?
Нет, не просто поэтому. Аркадий, твоя версия? Давай без шуток, нужна серьезная версия.
На самом деле, стандарту очень тяжело обратную совместимость ломать. Если в стандарт добавить
вот такую штуку и четко специфицировать, что выводится. Да нет, даже не в этом проблема.
И что? Какие проблемы? Два нижних подчеркивания, СТД подчеркивание, pretty function. Все, все проблемы
решены. Тем более... Ну не с шаблоном, просто макрос. Речь идет о макрос. Стандарты хотят с
рефлексией добавить, чтобы вот такой фигней не заниматься, рефлексия будет, все будут счастливы.
Пока вот так. Почему макрос не стандартизировать? Потому что, возможно, он даже стандартизирован,
но он спецификает, к чему он приводится. Почему нельзя строгий формат зафиксировать,
к которому функции выводится? Потому что, во-первых, невозможно определиться, какой конкретно формат
использовать. Во-вторых, не обратная совместимость, а совместимость в будущее. Это как forward
compatibility. Когда мы новые фичи в язык будем добавлять, вот этот формат придется как-то
эволюционировать. И там внезапно могут возникнуть какие-то неоднозначности, что типа можно вот так
интерпретировать, а можно всяко из-за появления новых фичей. Ну и придется старые менять. И вот
этого хотят всеми силами избежать. Ну типа по тем же причинам, что там мы смотрели копию, алгоритм,
из RNG, когда про неблоиды говорили. Вот по тем же причинам, что старый алгоритм нельзя поменять,
нельзя будет поменять спецификацию того, что выводит про эти функции, потому что код уже написан.
И те же самые проблемы с рефлексией. Не будет возможности там эту рефлексию как-то менять,
если что-то в языке поменяется. И из-за этого большие вопросы и проблемы. То есть, внося изменения
сегодня, мы должны понимать, что через 10 лет нам нужна будет с ними обратная совместимость.
Если мы неаккуратно что-то такое добавим, могут быть проблемы. Но по факту, мне кажется,
никто просто не пытался принести бумагу, которая предлагает стандартизацию вот этого. Может быть,
если вы ее принесете и хорошо обоснуете, почему вот проблемы, которые я описал, не будет, то ваше
предложение примут и все будет круто. Ну тоже начнутся споры, что этот зоопарк целый будет, все
офигеют, как это мой учитель, ну короче, ты не победишь бюрократию, комитет стандартизации.
И тем более, когда вот-вот будет готова рефлексия, согласно некоторым мнениям, еще чуть-чуть надо
подождать, зачем нам втаскивать такую фигню. Все, мы достаточно. Рефлексию планируют 26 запихнуть.
Очень хотят. И шансы пока есть. Там выделили минимальный набор вещей, очень четко обоснованных,
почему они сделаны так. И даже с ними уже мы таких дров можем наломать. Правда,
мне половину курса выкинуть надо будет. И посвятить его рефлексии новой, если ее таки втащат. Ну ладно,
давайте дальше ехать. Кажется, все, да? Библиотека, в которой все это уже за вас написано. Теперь про
янамы. То есть, янамы у всего научились, конечно, выводить, но у янамов есть еще некоторое количество
информации. Название самого янама и название элементов янама хочется. Это мы уже умеем. А вот
количество элементов и получать как-то элемент по номеру или элемент янама по строке этого мы не умеем.
То есть, что я подразумеваю под номером. У вас написано в самом янаме список его полей. И они
в каком-то порядке. Но значения у них могут быть абсолютно разные. Да, это вы узнаете. И хочется и
номер в значение перегонять и обратно, и в строку, и обратно, и чтобы вот это все просто мапилось
друг в друга как угодно. Ну, давайте изобретать. Первое изобретение это, конечно же, препроцессорные
преступления. Это вполне работает. Тоже у многих там в проде крутятся такие приколы. Но тут беда в том,
что людей не заставить вот так весь код писать. Поэтому начинается, что на кодовую базу типа
гугловской пять раз переизобретен такой макрос по-разному, и там пять раз по-разному где-то
использован, где-то не использован. Ну, в общем, можно, но не нужно.
Мне кажется, тут нужно не забыть упомянуть, как парстить этот эллипсис.
Как вот это вот использовать? Ну, кто знает, как вот этот вот эллипсис превратить в список
еномерантов? ВАААРКС. Так, если мы ВААРКС напишем, то он нам через запятую все,
что сюда вписано, напишет. Что еще надо? А, если ты... Да, ты абсолютно прав, что я тут лукавлю и
опускаю кучу деталей, потому что нам вообще на этот список через запятую написанных каких-то строк
нужно навесить, замапить какую-то функцию, которая превратит их в строки. Ну, можно. Это делается,
как я сейчас рассказывать. Не буду, будет отдельная лекция про макросы, там подобные идеи будут
рассказаны. Можно проще сделать, можно это все просто как-то сконкатенировать и запихнуть в
строковой литерал и не париться. Ну, короче, делается. Давайте дальше. Unreal Engine, как всегда,
не подводит. У них простая, понятная система. Вот за это их бесконечное уважение им. Потому что вы
опять какой-то ю и нам пишете, но это не будем обсуждать, что такое. В плане. Это чтобы у тебя
вот эту вот штуку можно было в блюпринтах использовать. Ну, ладно. Вот такие они добавили
сюда макросы, которые, конечно же, при компиляции флесового кода разворачиваются в ничего, но там
когда вот помните, я говорил, файл include, который что-то там генерирует, вот там где-то будет какая-то
функция toString, которая вот эти вот имена как-то все выдаст вам. Зачем отдельно display name какой-то,
если можно просто вот это вот имя вытащить? Ну, вот тут про блюпринты как раз. У них там есть
редактор, который из кубиков позволяет код писать. Вы работали с таким когда-нибудь в школе? Кубики
такие соединяешь и типа код. Алгоритмы всякие. Нет? Ну, ладно. Короче, давайте просто считать,
что это какой-то туллинг, какие-то инструменты с какими-то интерфейсами пользовательскими,
и вот там необходимо показывать ваши янамы. Причем показывать не другим программистам,
а художникам и дизайнерам. Им хочется для ваших, ну, когда они должны выбрать из какого-то набора
вариантов какой-то конкретный вариант, это же у вас код и янам, вот им хочется нормальные имена
иметь, и вот если вы имеете суперпроцессор, вы даже такие фокусы можете утворять. Очень приятно.
Ну, это все неинтересно. А, ну, еще одно жульничество. Можем просто соглашение принять, что у нас
всегда каунт будет в конце янама, и если янам подряд элементы у него значения имеют, то мы можем
всегда найти их количество, а если они подряд, то и как бы и номера, и в общем проблема решена.
То есть, ну, большое количество кейсов вот даже так можно покрыть, но опять же,
такому соглашению никто не будет в большой кодовой базе следовать, будет забываться,
переизобретаться, ну и беда. А теперь давайте, как бы, хорошее решение. Ну, хаки, конечно,
но оно универсальное и не использует никаких припроцессоров. Так, есть helper, есть янам.
Вот мы вывели фуа, да, и, ну, как я уже говорил выше, можно авто поставить сюда и будет нам
выводиться, что там вот это t это фуа. Ага, теперь вопрос, а вот если мы при статике кастим 10 к фу,
это не является элементом янама, строго говоря, да, здесь элементы 0, 1, 2, а мы при статике касте или
10 и пытаемся вывести, что будет? Ну, если бы вы писали компилятор, что бы вы здесь вывели? Ну, именно так.
Ну что, поняли, как понять, сколько в янаме элементов, какие у них номера и так далее?
Если мы вместо 10 и 1 напишем, то нам выведут b.
Вот оба варианта правильные, да, мы просто будем перебирать, можно бинпоискам и до какого-то момента,
ну, да, оговорка, янамы бывают sparse, когда здесь не подряд идут значения, а там вообще рандомные
В таком случае никакой бинпоиск не сработает. Ну, в целом, да, ну давайте линейный поиск, будем подряд идти от чего-то до чего-то и искать, что тут есть.
Вопрос, от чего до чего? От 0 до f max. В смысле от 0 до f max. Сколько это времени займет по факту?
Умная жесть. Нет, ну по факту это займет там несколько секунд вроде как, да, ну секунду, две, три может быть.
А тем более, что плюсы в Compile Time это интерпретируются, а не компилируются, так что там еще нужно на 10.
Короче, это будет занимать крайне и крайне долго. Ну, нормального ответа здесь нету.
Я предлагаю минус 500 до плюс 500 и, наверное, хватит. Ну, для всех адекватных случаев должно.
Если кому-то не хватает, то предлагается руками указать лимиты, а если кто-то сделал настолько sparse и янам, что там вообще минус миллион, плюс миллион, то вообще не надо с такими людьми общаться.
Еще одна функция, HelperBase и функция Helper, можно будет указать перегрузки для данной.
Что, перегрузки?
Не перегрузки, можно вынести клаш, чтобы делать спецификации для данных типов.
Да, можно сделать trade. Внимание, у нас была тема trade, и вот про что она была, про то, чтобы выносить решение о типах куда-нибудь вне текущего контекста.
Вот нам в текущем контексте нужно понять, от чего до чего бегать или вообще какие значения проверять.
Ну, давайте по дефолту что-то адекватное будем делать. Если кому-то дефолта не хватает, через trade попросим их самих указать для их и нам, сколько и где им надо бегать.
Битфилд, битвей ставится, если где-то там что-то.
Ну, что-нибудь придумать. Я, если честно, не думал в эту сторону.
Указать рандомный генератор чисел.
Отличная идея. Нет, короче, можно это все добить.
То есть наш план такой, вернее ваш план на домашнюю, пройтись от нуля до 500 или 100-500, проверять, что вот этот вот helper выдает нормальное что-то, а не просто прикасченное число для ишки прикасченных к фу, и в принципе все узнали, и порядок, и количество.
Наверное еще будет момент, что у нас в контексте контакт-сверхпульса ограничены числа операций.
Ну, поэтому там подогнано так, чтобы у вас все влезло, если вы напишите хорошее решение.
Внимание! В этой задаче, ну, в задаче по мотивам вот этой вот темы очень легко упереться в всякие лимиты, и в TL, и в лимиты рекурсии в compile-time, чтобы этого не происходило.
Поэтому надо писать максимально аккуратный, простой код, ну, то есть в моем решении рекурсии вообще нет, то есть вот мы до сих пор многие всякие шаблонные вычисления делали рекурсии, но, оказывается, можно не только рекурсии.
Ну, вот сейчас...
Fold expression.
И да, все.
Ну, короче, в конце чуть-чуть попишем код, я вам покажу трюк, по-моему, я уже показывал его мимолетом, но вдруг вы забыли, вот он тут пригодится, чтобы не упереться в лимиты рекурсии.
Ну, и итоговый код, если его хорошо написать, он простой, понятный и быстрый, там буквально 100 строчек.
Вот, так что если вы начали что-то суперсложное оградить, всегда задавайтесь вопросом.
Что-то пошло не так, наверное, может, где-то я не додумал или перепридумал, вот, но это вообще по жизни хороший совет.
Вот, про compile time циклы будет в конце, да, наверное, я обычно тут прерывался на это, но не хочу сейчас прерываться.
Сейчас, а с куку у нас времени, мы вроде бодро идем, но надо следить.
40 минут прошло.
Так. Писать сейчас. Ладно, давайте сейчас напишем.
Ну, потому что техника простая, и лучше ее прямо сейчас показать.
Да, да, да, да, да, просто сейчас, спойлеры, спойлеры, спойлеры, вот так, все, ничего не видели.
А, ну и правильно, ну и хорошо, а...
Нет, потому что не так с контрастом.
Да, да, да, ничего видно не должно быть, все плохо, сейчас.
Опа, опа, смотрите, как хорошо и видно все стало, но тут у меня какая-то фигня написана уже.
Ну, это неправильно написано, потому что там так четко.
Ну, в целом, я хочу сделать так.
Сколько там элементов? 5, да, ведь? Да, 5.
Хочу так написать, но не могу. Почему?
Так, давайте придумывать что-то более простое и понятное, чем...
Это же понятно, как во многих языках, применяя язык, проходит не в языке, а в стольных гигераторах.
Есть STD Apply.
STD Apply даст вам индекс?
Да.
Можно, давайте напишем свой STD Apply лучше, чем использовать который...
Ну да, это все правда.
Ну вот, два человека знают, поэтому давайте, наверное, просто писать.
Ну, первая мысль, давайте сделаем лямбду, у которой есть шаблонным аргументом вот это самое i.
И как бы теперь мы хотим эту лямбду запустить много раз для каждого i в такой штуке, как STD Index Sequence.
Ну и...
Давайте как раз вот это вот я скопипасчу.
То есть про Index Sequence все знают или надо рассказать чуть-чуть?
Ну это такой волшебный класс. Почему у меня кланкдэ не работает?
Что такое?
Не получается, да?
Получилось.
Это по сути то же самое, что Integer Sequence, а Integer Sequence это тупейшая штука.
Вот у нее есть шаблонный тип T и пак значений типа T.
И все.
Ну и еще size.
Ну да, можно size.
Ну и еще size.
Ну да, можно size получить, это количество элементов.
То есть это на самом деле compile time, последовательность чисел.
Ну не только чисел, но чисел.
Type tuple, по сути.
Ну наш type tuple.
Ну как бы да, но type tuple хранит в себе типы, а вот эта штука хранит в себе числа.
Идейно оно используется, чтобы какие-то последовательности индексов и прочего-прочего хранить.
Эта штука вам очень поможет в домашке про инамы.
Да, я не тот шаблон написал.
Вот make index sequence есть.
То есть я показал index sequence, это просто Integer Sequence на size t.
Потому что у нас индекс это size t.
А есть шаблон make index sequence.
Которое создаст нам, ну то есть сейчас вот тут tuple size это 5.
И вот этот тип make index sequence, он будет, давайте даже напишем.
Вот эта шняга должна быть same as index sequence.
index sequence 0, 1, 2, 3, 4 и все.
Потому что у нас 5 элементов.
Не make, просто index sequence.
Работает.
То есть вот это число это 5.
И шаблон make index sequence генерирует нам index sequence, в котором написаны числа от 0 до 4.
Ну то есть до 5 не включая.
Теперь мы хотим как бы взять и замапить вот эту лямду по шаблонному параметру внезапно.
На вот эту последовательность.
А как это сделать?
Идеи предложения.
Сейчас.
Ну для начала мы наверное хотим.
Какой брейк нет.
Я не пробовал и даже не слышал, что так можно.
А ну.
Брейк можно, хитро можно.
Нет никакого брейка не нужно.
Вот это хорошая идея.
Взять и распаковать пак.
Потому что как мы помним, когда у нас в шаблоне есть пак аргументов.
Как вот здесь.
Мы не можем его никак наружу шаблона вытащить.
Это не является какой-то первоклассной сущностью в языке.
Единственный способ достать вот этот вот пак и дальше с ним как-то работать.
Это использовать другой шаблон.
Какие-нибудь частичные специализации, вот это все.
То есть когда мы там function писали, мы то же самое делали.
Распаковывали шняги через.
Нет, давай проще.
Ты хочешь свой оператор запятая написать сейчас, да?
Сейчас все будет.
Внимание на экран.
Чтобы применить fold expression нужно сначала иметь пак как пак.
Потому что если мы вот просто такую вот штуку написали.
Там index sequence.
Это какой-то тип, а не пак.
Мы с ним ничего сделать дальше не можем.
Поэтому, смешнейший трюк.
Я запихиваю вот эту лямду.
Где мы пытаемся получить...
Где мы хотим и запихиваем в другую лямду.
Которая принимает пак.
Сразу запускаю эту лямду от make index sequence.
А здесь через вывод типа аргумента.
Ну ketad.
Нет.
Type argument deduction.
Вывод типа по аргументам.
Я здесь напишу как аргумент index sequence.
В котором вписан вот этот пак.
И мне type deduction увидит.
О, передали вот такой тип.
Он, мы убедились, выглядит как index sequence от 0.1.2.3.4.
Соответственно в этот пак у меня попадет 0.1.2.3.4.
Да, кажется надо так писать, чтобы у меня сейчас скомпилировалось вообще что-то.
Отлично.
Теперь у нас есть пак, и тут уже много раз сказали.
А давайте делать fold expression.
Есть тут люди, которые не знают про fold expression.
Ага, супер.
Fold expression это очень смешная вещь.
Вот есть у нас пак целых чисел.
Внезапно можно написать вот так C++.
Не важно.
Какая будет сумма чисел от 0 до 4?
12? 10?
Ну, у меня всегда было плохо с рифметикой.
Внимание.
Ну да, это инженерный подход.
Внимание.
Произошла математика.
Вот это была как бы последовательность.
Я написал типа последовательность, плюс и так далее.
И оно сложило все, что было в последовательности.
И так можно делать с любым оператором.
И любым паком.
То есть пак не обязательно должен состоять из чисел.
Оператор должен быть бинарный.
С минусом не знаю, плюс умножить работает.
Сдвиг влево, сдвиг вправо, по-моему, тоже работает.
оператор запятая
внезапно
по моему да наверное и минус тоже скорее всего все работает
оператор присваивания работает чтобы он вообще была
да тут еще про ассоциативность может быть проблему
потому что ну где скобки расставлять у нас некоммунативная операция там да звук влево например вот так вы сделаете у вас будет
ассоциативность кажется вот так расставлена
поправьте меня потому что я наизусть не помню
вот так будет расставлена да
понимаете в чем разница да
можно же по-другому написать
можно написать
0 плюс 1 плюс 2
плюс 3 еще скобки и
вообще говоря если плюс это у нас не нормальный арифметический плюс а какая-то непонятная штука
нам может быть некоммунативно не ассоциативно и нам важно в каком порядке скобки расставлять то что сейчас здесь написано расставят в первом порядке
но никто не заставляет писать так можно написать наоборот
3 точа плюс пак и скобки будут наоборот расставлены
да
к тому что вот сюда внутрь можно вписать на самом деле что угодно
можно написать вот так и понять что все это время я вам говорил что смотрите у меня работает когда на самом деле нифига у меня не работает потому что
там еще выше ошибки компиляции
что почему
где красным подчеркнуто
почему проходит этот ассерт а потому что он в какой-то лямбде непонятно не описывается
сейчас
вот вот здесь я забыл фигурные скобки там уже объект собрались сюда передать чтобы оно по объекту распаковала и о
вот теперь без двойки с десяткой о работает
умножаем каждый элемент на два
работает и на самом деле пак у вас может быть может состоять из типов и вы можете складывать например сайзов и типов
или создавать новые экземпляры объектов их складывать это очень гибкая система то есть
в общем случае это называется fold expressions
fold expressions на cpp-reference достаточно подробно написано во всех деталях
но в принципе его читать в большинстве случаев и не надо просто интуитивно понятно у вас есть пак и у вас есть бинарный оператор
можете между всеми элементами
выражения какого-то
в котором участвует название пака взять и расставить этот бинарный оператор
то есть если вы уже привыкли
распаковывать паки как аргументы для чего-то дальше
например там
other template из три точа да мы как бы распаковали пак через запятую
то если вы к этому привыкли и вас не смущают всякие трюки типа
foo std forward
тес тес
три точа то и вот это не должно смущать потому что здесь же тоже какое-то произвольное
выражение написано целых два пака упомянуто внимание и написано три точки оно как бы распаковывается через запятую и передает эти аргументы
тут смысл такой же любое выражение написали написали бинарный оператор и три точки и оно распаковывается
да тут выражение 2 умножить на элемент из из
распаковывается по паку то есть
в итоге вот я сказал что будет
вот так будет вот так будет вот так будет вот так и вот так то есть буквально распаковка я
поменял выражение с просто из на два умножить на из и теперь у меня ну действительно два умножить и элементы будут
с этим примером должно быть прям понятно
зачем
все надо в скобке окружать да это внимание fold expression и всегда выглядит как
три точки
бинарный оператор
блямба ну доллар может быть чем угодно здесь да плюс минус умножить и
какое-то выражение экспор и выражение должно зависеть от пака пак
вот общий вид еще
что
с форвардом нет с форвардом это не
fold expression
это важно
ну когда вы пишете
где-то вы могли видеть разве слайси в спане там не было мест где нужно зафорвардить какой-то пак или в
фанкшен мы по моему должны были видеть ну-ка
4 да
просто мне кажется мы это уже с вами видели и у вас не возникало а вот вот вот мы такой код с вами написали
это не fold expression это просто говорит компилятору я хочу
передать этой функции аргументы
которые написаны в этом в этих паках
то есть ну как бы есть оператор запятая это вообще отдельная бодяга пока не думайте про него а есть вот этот синтаксис который еще до fold expression
был
просто распаковка пака
то есть вот это превратится в вызов там функции фу или инициализации вот этой
переменной фу вызов ее конструктора
от
аргументов которые лежат вот в этом паке args
ну вернее обработанных через вот эти вот вот это expression
никак ну распаковка unfolding наверное
да да да ну то есть вот это вот это не fold expression это вы просто как бы распаковали пак
это было еще со времен царя гороха то есть одиннадцатых плюсов и это ну главное как используются паки да
когда у нас есть пак мы его должны там либо передать в какой-то другой шаблон и для этого мы тоже три точки пишем да
мы просто так пак не можем передать нужно обязательно три точки а ну вот еще пример да тоже три точки написали и пак как бы через запятую
расписался
не через оператор запятую просто через запятую как выражение
то есть ну это все одного рода вещи
распаковки разная да
я почему-то считал что с этим вы уже должны были сталкиваться и не раз
окей да ну в общем это старая этого
это всегда было
теперь fold expression они из 17 плюсов появились
они именно что не просто через запятую пишут и передают как аргументы в другой шаблон или функцию
они именно что оператор применяют плюс например
да
рекурсии можно добиться желаемого нами результата
конечно тот что я сейчас расскажу потому что рекурсия это отн инстанциации разных шаблонов
а как мы знаем инстанциация шаблона это ну то в чем измеряется собственно перв компайл тайм штук
а это пока никак не работает я так и не рассказал главные фишки fold expression
да
а да ты права давай чтобы она соответствовала напишем вот так ну
из умножить на из
давайте сумма квадратов от 0 до 4
н
на н плюс 1 на н плюс 2 на 6
ну действительно работает квадрата то есть во что это на самом деле распаковывается теперь каждый раз будет здесь написано
соответствующий номер умножить на самого себя
да все паки должны быть одного размера иначе будет проблема
отличная идея периативная ну в общем как нам fold expression помогут
я про оператор запятую что-то говорю есть такой что делает оператор запятая
вызывает правое и затем вызывает левое
не наоборот
вычисляет левое потом вычисляет правое
оператор запятая кома оператор
ну
когда вы его перегрузите он этого не делает но дефолтный говорит что сначала вычисляется левый оператор
есть такой магический оператор запятая вы можете например написать
0 запятая 1 что это делает вычисляет 0 потом вычисляет 1 и
возвращает по моему правое да
последнее вычисленное
последнее вычисленное то есть значение вот этого вот выражения давайте стать
кассирт напишем потому что все эти вещи настолько легко забываются что просто страшно да действительно правая
да если ты что-то перегрузишь то там что-то не гарантирует давайте про перегрузку не думать это уже
адванс штука я и сегодня не объясню я скажу просто что мы будем через оператор запятая
да да does not contain any expanded pack параметр оп оп
и тогда у нас должно прерваться как раз на литературе
нет фронтайме прерваться да
это не поможет тебе когда ты компел тайме цикл делаешь
но вот это вот ответ да но то как сделать цикл в компел тайме
можно вот этот и столько еще переименовать в просто и чтобы это как будто индекс был и мы в шоколаде
понимаете что происходит
парсить да читаемости мы не думать да да тут вот подсказка есть
мы
сделали выражение в этом выражении написано лямбда которая сразу запускается и внутри этой лямбда
мы
используем пак как будто это одно число
вот это все выражение некоторое
причем это выражение с паком внутри неразвернутым поэтому само по себе это выражение не скомпилируется нужно распаковать
распаковку мы делаем посредством fold expression причем fold expression на операторе запятая
то есть у нас через запятую
повторится вот этот expression
с разными индексами
черт
через запятую будет написано это лямбда с нулем потом это лямбда с единицей это лямбда с двойкой и так далее и
оператор запятая нам гарантирует что сначала то что до запятой написано вычислиться потом то что после запятой
таким образом в общем и целом мы просто пройдемся по паку в нужном порядке и
и
вставим в программу вот такие строчки кода по сути с разными значениями и
такой цикл в компайл тайме
в рон тайме это работает так будто ты руками раскопи пастил вот эту строчку
то есть вот эту строчку взяли раскопи пастиля с индексами от 0 до 4
в компайл тайме это работает очень быстро потому что тут одна инстанциация шаблона одна
вывод вывод шаблонных аргументов по
тому с каким аргументом запущена функция вывод шаблонных параметров по тому аргументу с которым запущена функция мы запустили с
инстанцем вот этого класса index sequence в типе которого закодирована
последовательность от 0 до 4 а дальше мы с помощью вот этого вот выведения шаблонных параметров
вывели вот этот пак в котором тоже выведется что написано от 0 до 4 а
потом мы этот пак
зафолдили с оператором запятая и
некоторым выражением которое просто лямбду запускает
то есть вот этот хак с лямбдой которая сразу запускается он нужен чисто чтобы сюда любую строчку смочь написать
он раскопи пастчивает эту лямбду это выражение подставляя в него вместо
вот этого значка разные индексы
fold expression вот это делает
первый шаг fold expression берет вот это вот
все выражение и
превращает его в следующий вид
заменяем на 0 и
копипастим раз два три четыре
нумеруем раз два три четыре
вот все что делает fold expression
преобразует то что написано вот здесь
вот вот вот это вот вот в это вот
понятие шаг да
спитой в конце не должно быть да
теперь дальше компилятор просто по обычным правилам начинает вычислять это выражение
каким образом ну это
какие-то вызовы лямбд которые написаны через запятую но соответственно он увидит ну надо сначала вычислить это
вычисляет результат как бы void но он его выкидывает потом вычисляет это потом вычисляет это ну и все
просто оператор запитает так работает
будь здоров
ну да fold expression как бы копипаст это стшки
как и все в шаблонах
это правильная интуиция на то как работают шаблоны вы когда подставляете в шаблон какой-то аргумент
вы копипастите стшку шаблона и заменяете все вхождения этого аргумента на то что подставили
развертки паков работают точно также берем стшку раскопи пастчиваем что-то заменяем
нет
ну это по крайней мере быстрее чем
то есть это не порождает сущности языка
вот главный поинт потому что когда ты инстанцируешь класс какой-нибудь ты порождаешь сущность языка и
компилятор ее должен сохранить запомнить и дальше за ней следить потому что вдруг еще кто-то захочет к ней доступ получить
вдруг она на резолюцию имен как-то повлияет да это гораздо больше импакт чем копипаста какого-то
кода внутри функции какой-то стшки которая вот просто кусочек кода
вот такая мотивировка но по факту это работает быстрее я когда-то когда-то давно замерял
нет давай не будем возвращаться это уже все умеете делать
что ну ты
да ты идешь рекурсии инстанцируя классы или бы функции
нет
да ты ты просто уже к этому привык к этому еще не привык и то и другое полная хрень с точки зрения читаемости
невозможно читать никакому стажеру жену никому
это
сейчас что-то предлагаешь сделать
а вот это
выражение
вот если мы в шаблонный параметр
куда
ладно я перестал понимать что ты хочешь поэтому давай пойдем дальше как сделать это простым понятным читаем в какой-то мере
давайте первую строчку
зафигарим в define
это раз и вот этот тут остаточек кода
то есть в принципе все кроме вот этой строчки которая в цаус что-то выводит
как я назвал вот так ну это все зафигарим в for template end
а
сейчас посмотрим внимательно что мы сделали ничего сложного на самом деле
вот так
так вот так вот так вот так
ну только что был какой-то код
дословно что я сделал все кроме вот этой вот строчки
все что выше выдрал в macros for template
все что ниже этой строчки выдрал в macros and for template
в этих там for template сделал аргумент у первого и это ну
индекс как в цикле и
а у последнего ну количество
а
что вы думаете об этом
ну если вы владеете макросной магией достаточно хорошо вы можете сделать чтобы вот здесь оба аргумента были если вам так хочется но я не буду
то есть ну уже уже понятно более-менее что происходит как-то в целом можно еще обернуть в
прекрасные фигурные скобки у вас вообще практически цикл
ничего стирать не надо пусть так будет
да
ну
это работает и это более-менее можно понять что делает поэтому меня такое в принципе устраивает и
ну в домашней вам во всяком случае придется что-то подобное использовать потому что на сколько я помню по лимитам не влезает рекурсия
да
а
хорошая идея
давай за пять минут и попробуй написать
нет она не может быть констивал
она может быть только void
какой-то аплай мы должны в шаблоне указать
некоторые каунт
мы должны
принять
колбэк
зачем вот это было нужно
но затем чтобы ты мог пройтись по теплу
компайл тайме
в домашке это тебе понадобится да и в принципе по жизни неплохо к уметь делать
да да ты как бы в компайл тайме проходишься
не вран тайме а в компайл тайме заранее раскопи пастчиваешь столько раз сколько нужно вот такую строчку
это вполне полезный навык ну вот тут предложили прокачать давайте прокачаем
в принципе мы будем делать то же самое
возьмем две вот этих штуки
сделаем вот так вот так вот так
каунт так
почему нас нас обижают а понятно почему и мы сделаем у
колбэка точка
template
оператор круглые скобки
с параметром и
не смущает вас это выражение
мы хотим выбрать вызвать оператор круглые скобки колбэка
явно но шаблонный указав явно и а так как и вот эта вот штука это шаблонная функция и вот эта вот штука это
некоторое шаблонное что-то на зависимый тип зависимая в зависимое выражение
компилятор компилятор если мы вот здесь ключевое слово template не напишем он подумает что мы захотели сравнить вот это выражение
вот это выражение
полученный буль потом сравнить вот это ну короче вы поняли да
традиционно
традиционно когда такое происходит мы вписываем какое-то дурацкое слово куда-то
ну
кто не синий ки темплей ну не синий ки не синий ки ну и вы скот просто сдался уже от нас не может терпеть это
давайте
да
так мы без аргументов вызываем
как что как
нам главное указать шаблонный аргумент вот этот вот
как через инвок
ну как ты в инвоке укажешь какой шаблонный аргумент явно указать при вызове
ну короче не работает
да указатель на функцию не сможем сюда и незадуманно указатель на функции смотри сюда
задумано передавать шаблонные лямбда
сейчас надо использование написать
вообще почему я сам этого не придумал очень странно
а давайте тоже скопи пастим
какой передать
сейчас вот это вот просто надо подвинуть вот сюда подвинем куда-нибудь
да
тоже работа без макросов кстати это это гениально
все заинлайнится
сейчас это у нас что-то не то запустилось
что мы компилим вообще что запускаем
билдмейн
билдмейн
а
ой нет это не смотрите туда все скомпилировалось да только что нам вывелось а
тюпл а да я же вывожу тюпл гет и в тюпле написано что 0 42 420
а хай ну вот и тот и тот подход и с макросами и с
все правильно нам вывелось я что-то туплю просто
и здесь и здесь сработала и вывела нам то что в тюпле находится
компайл тайм циклы
конечно же есть пропузл стандарт сделать template for
который будет делать это очень просто и понятно как вот вот так вот
стэкспора
хотелось бы чтобы просто вот так было и не приходилось себе пудрить мозги к сожалению до сих пор не могут
ни о чем договориться поэтому пока так пишем все давайте на этой
конечно контекстное использование ключевых слов это наше все потому что новые ключевые слова добавлять то вы что аксистить нельзя
я
ну да ну вы шутите там предлагали какие-то типа
такие штуки да
типа universal template argument
ну по моему тоже шутку было но да все давайте на этом
паузу сделаем и
перерыв у нас до 31 минуты
покушать
что-нибудь попить
итак
рефлексия под типов кого-то из вас могут сразу возникнуть вопросы к тому что
да но plane old data у этого нет строгого определения
в стандарте есть там три или копия был что-то там что-то вот мы не будем заморачиваться потому что все равно не на одну не на один
стандартный концепт то что мы сейчас будем изобретать не маппиться мы так интуитивно ну это типа структурки
где там есть поля и все типа и больше ничего нет
давайте уточним немножко на самом деле это не юнион не пользовательские нет пользовательских конструкторов
диструкторов никаких виртуальных методов копирования каких-нибудь операторов присваивания
конечно же нет наследования все поля публичные не имеет значения по умолчанию и либо скалярные либо тоже под типы
плюс-минус
да они нам не помешают
как все короче структурки как все
блин методы в структурах это такая типа
ничего полезного ничего вредного ну есть и есть
окей что мы хотим
мы хотим все в принципе уметь понимать
да вот примерчики
ну понятно просто структурки и все мы хотим понимать количество полей типа полей и
внимание самое сложное это уметь получать ссылку на
поле по номеру поля причем в компайл тайме типа
ну в компайл тайме
гет а запятая два и вам возвращают ссылку на флот
нет просто ссылку на флот вы пишите гет и в треугольных скобках а
запятая два номер
возвращает ссылку на флот
нигде никаких указателей на меморер классов нет
да я фигню говорю гет а
два и в круглых скобках какой-то конкретный инстинкт с этой структурки и
потом вам возвращают обычные ссылку на
флот ссылку флот амперсант то есть по
инстанцию и
номер у поля получить ссылку на это поле где тип ссылки но соответствует типу поля очевидно чтобы это была нормальная ссылка на это поле
не хотим указывать сами тип вообще ничего не хотим указывать
рефлексия по номеру же можно типа определить
наверное
ну теоретически да практически сейчас будем изворачивать
именно мы уже умеем
ну то есть
имена конкретных полей мы умеем получать по-моему да тут надо догадаться догадаетесь как получить имя поля
через ошибки
переграфы на
просто вот в этот
будет только им структура нужно передать что-то что относится к конкретному полю
да поинтер ту мембр указательна член выпиливает
поинтер ту мембр указательна член выпиливает
поинтер ту мембр
указательному полю
да поинтер ту мембр указательна член вы передаете его в хелпер вот тот спрете фанкшн и
ну это указатель на член класса вам скажут на какой член он указывает
по номеру через вот это как бы ну
если ты уже знаешь какой конкретно поле хочешь то ты можешь взять указатель на него как на мембр класс
и запихать в хелпер сприти фанкшн который в самом начале был это тебе ну строку даст
по номеру вот вот это все требуется чтобы по номеру потом
и тип и имя поля тоже даст
по номеру что угодно по номеру это золото играть того что будет дальше
пока мы по номеру ничего не умеем но я утверждаю что как только что одно научимся дальше все будем уметь
то есть вот ну просто конкретного поля имя мы можем
превратить в строку зачем правда не очень понятно но вдруг у вас уже есть список а ну да собственно
если ссылку сможем то есть ссылку на мембр или указатель на мембр сможем вот у вас есть
список указателей на мембр и ну закидайте их в хелпер и вот у вас будет список строк имен разных полей по индексу почему угодно
да во-первых указатель на мембр можно передавать как не типовой шаблонный аргумент во-вторых вам его распечатают во всей подробности
можем это посмотреть если у вас сомнения быстро быстро камеру не поворачивай это будет супер быстрое отвлечение без
без всего
что мы делаем
автове авто хелпер
а
третий фанкшн
мне тут есть а он уже есть так
здравствуй
хелпер от там какая-то структура была есть какая-то фу-фу-фу двадвое точа
запускаем
ну вывели то что казалось бы мы и ожидали фу двадвое точа а ну отсюда вы можете вытащить вот это вот а как строку
вопрос только теперь научиться список вот этих вот сущностей находить до список всех указателей на все поля
вот этого мы не умеем и сейчас как раз этим будем заниматься
возможно ли если у нас есть просто
ссылка то есть как это
ссылка на член класса
не вот таки он передать а просто круто
он определит по ней что это член класса
я не понимаю вот я написал кинт альберсант икс равно и
нет не работает типа то есть вот это вот особая конструкция которая позволяет создавать поинтер тумэмбер
да мы же подробно разжевывали что такое поинтер тумэмбер можешь пересмотреть этот момент и
поиграться самому ты меня слушая ничего не запомнишь это точно всегда так работает тебе нужно самому поиграться с этим и
потом уже что-то осядет ну или пересмотреть ту лекцию где мы писали function там про это как раз говорили
окей давайте пытаться
начнем с количества полей
есть структура и
вот мы создали ее экземпляр
пока все понятно а
вот так теперь создали экземпляр
но и вот так и
и на каком-то моменте нас ожидает облом да
понятно как найти количество полей опять бен поиск туда-сюда ну или перебор
фигурные скобочки а ты попробуй это закодить фигурными скобочками у тебя к сожалению ничего не выйдет
все немножко хитрее но то есть идея да подбираем максимальный набор
размер пака когда у нас компилируется вот такое выражение это и будет количество полей можно бен поиском можно линейным поиском
а да типа аргументов нам неизвестная поэтому
предлагают как бы скобочки но это тоже не сработает потому что
скобочки это такая специальная костыльная конструкция в языке а
вам там это все функции какие-то надо будет завернуть ну и общем сломается
а
максимальный сайзов мы же если перебрыгнули получим
да то есть requires expression и которые тебе позволяют
позволяют проверять будет сие или не будет это база основа
так
что передавать будем вместо фигурных скобочек
ну вот фигурные скобочки вы за сами написать можете а
заставить шаблоны вам писать нужное количество фигурных скобочек кажется не получится
то есть фолды фолд будет по выражению какому
запятая скобочки
все это уже будет ошибка потому что ты уже делаешь не агрегатную инициализацию фигурными скобочками а
создаешь пак потому что ты через оператор запятая пропускаешь считается
запятая фигурные скобочки скобка закрывается три точки это одно выражение
запятая фигурная скобка фигурные скобочки полностью
это не будет работать у тебя нету выражения
окей
а
давай там мы собрались инициализировать а что ты пишешь а
да и считаем что у нас есть пак из в нашем контексте который там 0 1 2 и так далее да что мы пишем
дальше
из фигурной скобочки
запятая фигурные скобочки
в ракмин на следующий символ переходим в стрелку вправо до литочек
ну это оператор запятая
нет это не будет фолд экспрешен для оператора запятая
андрей помолчи пожалуйста
это оператор запятая все равно да окей оператор запятая это уже некоторая функция по сути в семантике языка а
фигурные скобочки работают как агрегатно инициализация который можно инициализировать любой тип только если ты их прямо в том контексте где ты хочешь и на слизировать и написал
в ином контексте фигурные скобочки вот эти работают как список инициализации стд initialized list то есть вот здесь у
тебя возвращаемое значение вот этого выражения из фигурная скобка запятая фигурная скобка
только оператор, его возвращаемый тип будет std-initializer-list.
А от std-initializer-lista не любой тип инициализируется.
Вообще никакая вроде.
Это brace-initializer скорее всего будет,
для которого не удастся вывести тип, который инициализируется.
Да, скорее всего вообще выдадут ошибку, потому что
тут типа надо вывести тип, и мы не смогли, и ну вот, да.
Это даже не initializer-list.
Короче, ничего не работает.
К сожалению, к сожалению так.
То есть вот такие вещи, как brace-initializer-list,
то есть инициализация через фигурные скобочки,
она в языке захардкожена,
и передавать ее в какие-то функции нельзя.
Это не first class object опять в языке,
как и паки.
Параметры паки тоже какие-то непонятные, костыльные,
и не являются объектами языка, с которыми можно работать нормально.
Но выкрутиться можно.
Нам всего-то нужен тип,
который можно прикастить к любому другому типу.
Согласны?
Ну так напишем.
Вот тип, который можно прикастить к любому другому типу.
Да, это юбик констрактор.
Юбик от слова ubiquitous.
Ubiquitous.
Если кто-то умеет хорошо произносить на английском слово ubiquitous,
пожалуйста, подайте голос.
У меня не получается.
Короче, юбик.
Ну и все, на этом технология заканчивается.
Ну догадайтесь, зачем здесь вот это вот?
Зачем какой-то есть шаблонный?
Ну пак, чтобы можно было вернуться.
Да, да.
То есть пишем вот такой простой, понятный код.
Если вы за 30 секунд не можете понять, что здесь написано, вы отчислены.
Итак, это некоторый шаблон функции.
Констэкспро функции.
Должна быть констэвал, но ушла одна.
CountFieldsImpl.
Она принимает индекс sequence с паком ишек.
Ну, догадайтесь, почему.
Мы только что таким же занимались в коде.
Мы собрались использовать вывод аргументов шаблонных,
то есть вывод вот этого вот из аргументов функции.
Точно такая же техника.
Вот этому индекс секунсу мы там какой-то makeIndexSequence от пяти вкинем,
и он там развернется, и вот будет у нас пак от нуля до четырех.
Окей.
Есть какой-то шаблон T, но он там...
Шаблонный аргумент T заранее задан.
Такая же структура, которая нас интересует.
Есть некий constraint.
ConstraintConstructableFrom.
Говорят, что T должен быть конструируем от ub-конструктор,
где впихнут пак и, и написано три точки.
То есть вот это вот выражение распакуется столько раз, сколько у нас чисел в этом паке,
и Require, по сути, нас завалит ровно в тот момент, когда стало слишком много чисел в этом паке,
и уже перестала работать вот эта технология, что T пытаемся конструировать от ub-ков.
Ага.
Сейчас, сейчас.
В какой момент не понял?
Мы конструируем, то есть у нас получается набор ub-конструкторов.
Да.
Дальше что?
Дальше мы проверяем, что?
Is ConstructableFrom T и вот этот пак ub-ков.
Что T конструируется от ub-конструктора?
Да.
Пака.
Вот этот пак развернется.
И тут мы будем проверять, что T конструируется от ub-конструктор 0, ub-конструктор 1, ub-конструктор 2
и так далее до количества чисел в этом паке.
На самом деле не совсем, да?
Ну совсем.
Все там 0, 0 и еще раз 0.
Это так.
А, ну я сюда нули, я до сюда пока не зашел.
Окей.
Ну вот верно подметили, что строчкой ниже в этот пак запихиваются все нули.
То есть тут просто будет N нулей.
Значит у нас здесь будет N раз перечислен ub-конструктор от нуля.
Ну и мы проверяем вот от N таких ub-конструкторов, которые я напоминаю кастятся к любому типу,
ну ли от N штук таких ub-конструкторов сконструировать наш T, который структурка.
Если можно, то мы пока не нашли предел верхний, после которого мы фейлимся.
Ну и в момент, когда нашли и уже дальше идти нельзя, они конструируются.
Ну мы другую перегрузку сейчас сделаем.
Но вот в этой перегрузке мы как бы еще не нашли максимальное количество ub-ков,
которые можно запихать в структуру.
Мы сейчас не по номеру поле ищем, а мы ищем size.
Мы ищем количество полей. Вот. Вот эта технология.
Хотим автоматизировать вот это вот.
Идея тупая. Все, кто отлетели, вернитесь, пожалуйста, раз уж мы повторяем еще раз.
Мы собрались закодить вот в той функции последовательные попытки.
Сделали так. Работает. Окей, запомнили. Ноль.
Сделали так. С одним аргументом сработало. Запомнили. Один.
Сделали так. Запомнили два. Попробовали с тремя, уже не получилось.
Все, значит нужно вернуть два. Количество полей в структуре два.
Вот эта вот рекурсивная функция, использующая ub-ки, которые кастятся к любому типу.
То есть, любое поле можно инициализировать от ub-ка.
Потому что оно кастится.
Вот ровно здесь, в этой рекурсии, это как рекурсия, оно само себя запускает.
Ровно в момент requires мы проверяем, получилось ли.
То есть, смотрим. Предположим, у нас сейчас первая итерация.
То есть, здесь пак из одного нуля. Мы посмотрим, конструируется t.
Конструируется ли t из одного ubic-констрактора от нуля.
Ну, типа того, но сейчас будет загвоздка. То есть, вот эту строчку проверяем, по сути.
Только вместо единицы здесь будет ubic-констрактор ноль.
Вот этот ubic-констрактор, если мы скастим t, чем он контурируется в поле?
Да ничем. Потому что здесь нет реализации.
Да, это нормально, что здесь нет, она и не должна быть.
Да. Мы же не собрались в рон тайме звать.
В рон тайме установим ошибку, а в комплантане сейчас мы перейдем.
Да.
А дальше идет рекурсия. То есть, если у нас уже соединить с паком размера 1 получилось, надо дальше идти.
Ну, идем. Запускаем сами себя от t и индекс sequence от ноль и оставшихся is, которые тоже нули.
Ну, короче, дописали еще 1 ноль.
Что не так?
Не я.
Ну, вот, допустим.
А constructable from? Он в сигурдной скобочке, можно считать, а вы чекутое в сигурдной скобочке, да?
Constructable from? Ну, считаем, что да.
Добавилась база рекурсии. То есть, здесь мы просто рекурсивно идем вперед, вперед, вперед.
И в какой момент мы остановимся, в принципе, да?
Когда вот этот requires провалится, мы больше вот эту перегрузку запустить не сможем.
То есть, вот когда requires провалился, мы нашли то количество аргументов, то количество юбиков, при котором не получается сконструировать.
В этот момент запустится другая перегрузка.
Но так как мы нашли количество аргументов, при котором мы фейлимся, если мы посмотрим сюда, то полей два, а фейлимся мы при трех юбиках, то надо единичку вычесть и вернуть результат.
И мы нашли количество полей.
В общем случае для любой плюс-минус нормальной пацанской структуры.
А если у нас была пустая структура?
Это абсолютно правильное замечание.
Да, ну тут рекомендация обернуть вот так вот и чтобы index sequence вот этот вот дефолтный там автоматом, да?
То есть, это был импл, тут index sequence нужен, а тут красивая обертка без всего, чтобы вот было пацанской структуры.
И вот так вот используем.
Вот, пустая структурка.
Что выведется?
Это как раз загвоздка с constructable from.
Почему минус один?
Нет.
Ну, это как раз так.
Почему минус один?
Почему минус один?
Нет.
От нуля...
Так, окей, скомпилируются ли просто А-фигурные скобки?
Да.
Да, очевидно.
Скомпилируется ли А от одного юбика?
Нет.
Вычитаем один, получаем опять.
С чего ты решил, что это не скомпилируется?
Какие у А есть конструкторы?
Да, там изображен копик конструктора.
Да, копик конструктора есть у А.
Не забываем про это, да?
То есть, сейчас, на самом деле, у нас есть баг как раз.
Вот были ли вопросы к тому constructable from?
Подходит вообще?
Он точно фигурные скобки будет делать?
Нет, он делает что-то более хитрое и сложное.
Он просто диковал по столе...
Ну, что-то такое, да.
Короче, выведется нам здесь единица из-за копия конструктора.
Ну, вот так вот.
Нет, мы можем философски порассуждать, что структура является собственным полем.
А можем...
В смысле, если у нас нет полей, то сама структура является собственным полем?
Нет, это баг.
У нее ноль полей, надо вывести ноль.
А мы выводим... вот такой код выводит один.
А нужно вывести ноль.
Полей нету, их ноль.
Мы рефлексии занимаемся.
Мы не говорим про то, сколько байтов она занимает.
Кстати, это можно починить.
Сайзов?
Нет, сайзов будет длинный.
Поэтому же сравнить сайзов с наследом, у нас сейчас 100 долларов.
Эрик Нибблер в твиттере буквально вчера предлагал сравнивать типы посредством запихивания их обоих в одну структурку,
как полей, обоих помеченных как No Unique Address.
И если типы одинаковые, то они не схлопнутся.
Если типы разные, то они схлопнутся.
Во, не надо так.
Тут фикс гораздо более простой.
Вместо ConstructibleFrom, который копиконструктор умеет запускать,
сделать свой Aggregate ConstructibleFrom с фигурными скобками.
Вот здесь уже копиконструктора не будет запущено почему-то.
Не знаю почему.
Не будет.
Это фикс.
Он работает.
Проверено, что он работает.
Если мы посчитаем правила агрегатной инцелизации, то там...
Это точно будет пролифицировано как агрегатная инцелизация,
она не вызывает копирование.
То есть там просто копирование не вызывается.
Потому что такие правила в языке.
Магия.
Оно работает, поверьте.
Почему оно ломалось, понятно?
Копиконструктор.
Кто виноват?
ConstructibleFrom.
Оно для одного юбика говорит, что да,
потому что ConstructibleFrom вызвал копиконструктор.
Решение.
Вместо ConstructibleFrom руками написать requires и вот эту вот штуку.
А тут кофе-конструктор не сработает?
Да.
Не знаю.
А что это варксы?
Варксы юбики на самом деле приходят.
А они тут не вызывают конструктор?
Мы агрегатную инцелизацию
через фигурные скобочки делаем.
Дефолтные сконструированные...
То есть мы используем более какой концепт
вместо ConstructibleFrom?
Да.
Выискаем, что он конструкт,
что тот делает что-то более умное.
Он проверяет, можно ли сконструировать
как-нибудь.
А тут только агрегатно сконструировать.
Это более узкий концепт.
Почему предыдущий ход на любой структуре?
Почему ломаться?
Он просто всегда
для пустых структур...
Он не умеет выдавать ответы
меньше единицы.
Вот этот код не умеет выдавать ответы
меньше единицы.
Всегда хотя бы единицу
выдаст, в том числе для пустых структур.
Нам это не нравится, заменяем на агрегатную
инициализацию.
Копи-конструктор довольны,
идем дальше.
Вот финальный код, он работает
довольно все счастливо.
Окей,
справка историческая про то,
как раньше мучались люди.
Не помню почему,
почему-то короче.
Есть техника взять
и оценить количество полей сверху
как размер структуры.
У нас каждое поле хотя бы один байт,
и можно идти наоборот сверху вниз.
По-моему мучились, потому что
агрегатная инициализация
как-то не так работала, и там что-то
с этим связано. Не важно.
Да, уменьшаем, то есть идем
сверху вниз, и через финай
там типа
возможность конструирования как-то смотрим.
Ну, не знаю.
Это все когда-то было, сейчас уже
нет. Если у вас на работе нет
Т++14, то
переквалифицируйтесь в растеры,
как можно скорее.
Нет, сейчас.
А, это как раз в C++14 так было, что ли?
А в 17 поправили.
Ну ладно.
Агрегатная инициализация в каждом стандарте фиксили,
по-своему, из разных приколов.
Ну ладно.
Это не сильно большая сложность, блин.
Ну то есть с no unique address будет работать
никак. То есть вот из-за вот этого
снивания сверх как сайзов,
no unique address все поломает.
Ну,
что-то в 17
плюсах с агрегатной инициализацией
поменяли. Не помню,
не знаю. Давай ехать дальше.
Ну просто имейте в виду, что
многое, что здесь рассказывается, оно там
зависит от стандарта, и я на всякий случай
все-таки вставляю слайды, с какого до какого
это работает.
Вот, замечание.
Вот здесь не работает.
То есть no unique address говорит, что
давайте под это поле не выделять ни
одного байта, и вот
будет беда.
Да.
Как?
Бинпоиск.
Если вам понадобится в домашке,
надеюсь, вы сами справитесь.
Но no unique address по-моему что-то ломает с бинпоиском.
Но не уверен.
А, сейчас, это
вот к этому.
Вот это можно соптимизировать до
log n,
потому что вы знаете уже левую-правую
границу, начинайте бинпоиск делать, если
no unique address нет, все хорошо.
Но, как сделать бинпоиск,
если вы даже верхней границы не знаете,
но уверены, что монотонна функция?
Да.
Прыгайте вверх, умножая на 2,
тут в какой-то момент перестал
работать, опа, вот это и предыдущая,
между ними уже обычный бинпоиск.
Ну, просто смотри,
если ты будешь вот так вот расти вверх,
умножая на 2,
а потом между границами бинпоиска,
то это будет работать с no unique address
и проблем не будет.
Зачем
усложнять жизнь людям,
если можно ее не усложнять,
это как бы девиз разработчиков
библиотека должен быть.
Мы здесь страдаем,
а чтобы вы там
жили в свете.
Все, давайте,
надо следить за временем,
очень мало времени,
перерыв уже был,
остался час, надеюсь за этот час
мы сейчас успеем самое убойное,
типы полей.
Сейчас будет хорошо.
Итак, 2014 год,
первое решение,
как узнать список
типов полей?
В идеале, что мы хотим?
Ну буквально список типов получить.
Есть поля у вашей структуры,
у нас есть списки типов,
хотим список типов в порядке
объявления полей,
типов этих полей.
Ну,
вот мы сконструировали
нашу штуку от nubic конструкторов,
количество полей уже знаем,
запомнили, больше не спрашиваем,
количество полей известно.
Запихнем, пусть это n,
запихнем nubic конструкторов
в нашу структуру,
в инициализацию.
Внутри этого оператора
мы будем знать тип,
правда?
Да, можно
что-то написать сюда.
Но вот беда,
вытащить наружу этот тип
мы вообще не понимаем как,
потому что где мы здесь по стеку вызовов?
Находимся внутри
конструктора нашей структуры,
а потом
внутри как бы оператора
каста, вот этого.
И через этот конструктор структуры вытащить
наружу какую-то информацию,
но мы не можем.
Тайп дедакшн будет работать в классах?
В классах?
Тайп дедакшн? Да.
Да.
А мы тоже откуда не вытащим?
Ну, не вытащим,
все равно да.
Если вы задумаетесь,
вытащить нельзя.
Именно тип, именно в компайл тайме.
Ну,
как бы это
не останавливает очень многих людей.
Встречались ли вы когда-нибудь
с системами ID-шников типов?
Тайп ID?
Тайп ID, да, есть такое в стандарте,
но оно вам выдает не ID-шник типы,
а какую-то информацию о типе.
Вообще говоря, можно
забабахать систему,
которая произвольные типы
перегоняет в
индексы какие-то.
В Unreal Engine, кстати, она есть.
Шаблон просто Randall Jackson.
Чего? Randall Jackson?
Не-не-не.
Ну...
Тихо, тихо,
замолчи, тихо.
Не говори.
Тайп ID
это внутри
Ну да, еще...
Короче, какой-то ID-шник
присвоить каждому типу в вашем коде.
Это делать
с многими разными интересными
способами, там всякие
костыли, можно просто для всех встроенных
типов ID-шники заранее расписать.
И в принципе это работает.
Вообще в общем случае эта проблема
не решается.
Да, а есть смешная
техника, что генерировать функции
на каждый тип
и их адреса записывать как ID-шники.
Это вполне может
сработать.
Видели ли мы такое?
По-моему, видели.
Мы, может быть, так сравнивали при
обезвечивании типов, мы сравнивали функции.
Да.
Во-во-во. Вот ровно то же самое.
Можно взять указатель на функцию, прикастить
звездочку, звездочку превратить
в input.rt, и вот у вас будет ID-шник
типа. До какой
степени это работает, как только у вас есть
shared libraries.
Вы про shared библиотеки знаете
что-нибудь, наверное.
С ними это уже не работает.
Тут разные люди, разные хаки
придумывали, но там всегда проблемы,
что если вы даже базовые типы
захардкодите, с пользовательскими
типами, янамами, указателями,
проблемы, их можно
закостылять, еще там CV-квалификаторы
не забываем.
Люди придумали гениальную вещь,
это вот из какого-то доклада, не помню
какого в репозитории ссылка есть.
Предлагают
там хранить
в первой или там в последних
с каких-то битах
номер
встроенного типа.
Там прямо для unsigned
char свой номер захардкодили,
для intа свой номер захардкодили,
для shrta тоже захардкодили.
Храним эти номера в нижних с каких-то битах.
А верхних битах
берем по три бита
и начинаем в них хранить CV-квалификаторы
и является ли указателем.
Гениально, да?
А по-моему unsigned
тоже они предлагают так хранить.
Да, но
у тебя тут целых раз, два, три,
ну короче много, больше не понадобится.
В ГЦЦ еще как визит
реализован.
До 11 работает.
А дальше?
Ну все, зачем тебе больше?
Зачем вам визитить
Зачем вам визитить
варианты, в которых больше 11 элементов?
Ну реально.
Зачем вам теплы, в которых
больше, чем там 16 элементов?
Не бывает так.
Ну вот, такие хаки
придумали люди, презентовали.
Можете это пересерчить, если интересно,
но я лютый хейтер вот этой
штуки, потому что пытался с этим
работать и как-то делать, и ничего не получается.
Всегда какие-то костыли,
крайние случаи вылезают,
рекомендуют янамо в
андерлайинг-тайпы превращать, но отличная
рефлексия, мы забыли, какой тип янамо был.
Абсолютно не помогает.
А идишники для типов это
беда.
Есть другой подход,
реактивный.
Ну я не ожидаю,
что вы знаете, в каком смысле здесь это слово
употреблено, это же из GUI,
а GUI, как правило, никто не занимается,
потому что это лютая дичь.
Занимается кто-нибудь GUI здесь?
Реактивная.
Напомним ли ты про Асю?
А, не, ну ладно, в таком
смысле тоже.
Короче, реактивная GUI.
По-моему из GUI все-таки пошла, нет.
Ну ладно.
Реактивная GUI,
никто ничему не говорит.
Ну и ладно.
Давайте просто посмотрим.
Тип знаем.
Можем сюда в какой-то вызов функции вписать,
и у этой функции будет этот тип.
И она что-то сделать с ним сможет,
что ей нужно.
Ну если нам нужно просто вывести там
какое-нибудь имя типа,
прекрасно сможем в циаут вывести
внутри этой функции.
Просто indirection добавили.
Callback, да.
И в целом всякие подходы
с callback-ами и реагированием
на что-то, он как раз называется
реактивным программированием.
Можете об этом почитать, я рекомендую.
Оно весьма интересно и забавно,
но на практике что-то как-то у меня
все не срастается, чтобы нормально оно
архитектурно
подошло. Ну ладно.
Ну вот вопрос
только, как все это протащить?
Мы же в юбике, а он
в конструкторе каком-то.
Да, как теперь?
Шаблонные параметры юбика.
Ну как бы да, нужно добавить шаблонные параметры
юбика и накапливать в них список
вот этих вот имен,
список этих типов,
типов членов.
И надо
делать рекурсию.
Мы будем в вот этой функции смешной
запускать tmp
от там нескольких юбиков,
а внутри юбика
запускать обратно функцию.
И
так делать
по количеству этих
полей. Мы его уже знаем.
Заранее там
думаем, договариваемся, что вот так вот
проходим, накапливая, накапливая эти
типы, все больше и больше
стек наращивая,
собирая все типы
полей, и в самом последнем
уровне мы можем взять
и бахнуть callback.
Ну, его нужно будет
протащить, да.
То есть
внезапно здесь мы
если там вернемся,
то попадем обратно
в юбик, да. Представляете
в голове вот этот стек огромный.
Мы вошли сюда,
потом вошли
в юбик, потом из юбика сюда,
туда-сюда, туда-сюда, так по количеству
полей раз
и накопили вот это вот все,
и вот как бы
ну, наружу точно никакой возможности
что-то вернуть решительно нет.
Но мы можем запустить callback,
точно так же, как мы, кстати, только что делали.
Вот этот синтаксис смешной,
template-оператор,
types.
Окей,
вот эта идея понятна, правда?
Она тупая, бесполезная,
сложно понять, что
написано, но она работает, потому что мы
теперь можем
взять и вызвать вот этот вот forage field
mystract с лямбдой,
который принимает пак типов,
и нам в этот пак типов
собственно засунут все
типы, которые были у мемберов,
у полей.
И это будет работать. Окей?
Все.
С этим, кажется,
разобрались,
я надеюсь.
Ну, тут какие-то плюсы,
минусы есть.
То, что она через callback и
линейный количественный инстанциации,
это, конечно, супер плохо.
Где я соврал?
Я только что соврал.
Смотрим сюда.
Ты так думаешь?
Ну, это близко
к правде.
В самом деле экспоненциальное тут написано.
Вообще-то.
Ну,
потому что мы сейчас ветвимся каждый раз.
Мы начинаем с одного юбика,
запускаем
один раз forage in-depth.
А он запускает уже двух юбиков.
А дальше каждый из этих двух юбиков
запускает трех.
И их суммарно шесть.
Дальше каждый из этих вот шести
запускает для четырех.
Итого их там
четыре на шесть.
Ну, вы поняли, да?
Экспоненциальное количество инстанциации,
вот так не надо это писать.
Не поняли?
Кажется, оно даже сверхэкспоненциальное,
потому что по описанию выкрутили факториал.
Ну, неважно.
Ну, факториал и факториал.
Для меня факториал от экспонента не отличается.
Ну, поняли, да?
Почему это происходит?
Так делать не надо, надо где-то обрубить
вот эту рекурсию.
Ну, то есть где-то здесь какой-то ИИФ написать
и выйти наружу.
Даже если вы выйдете наружу, у вас кажется
все равно квадратично будет, или что-то такое.
И там, ну, беда.
Ничего не выйдет,
чтобы сделать это нормальным.
Но зато это работает со всеми типами
и вроде никаких супер лютых
хаков нету, которые ограничивают
нас как-то.
Вот, а теперь давайте
все сосредоточимся.
Давайте откроем окошко немного.
Воздух нам понадобится.
Кульминационный
момент курса просто.
Апогей, как сказал Арсений
Станиславович.
Так.
Сосредоточились.
Поехали.
Сразу
говорю, что макросов здесь нигде
не используется и не будут
использоваться.
Код.
Всегда ли он верен?
Вот эта статика с сёртом
всегда
не сработает, но в плане, что
окей, всё будет.
Ну, так, подумайте.
Если вы догадались, то лучше
всё-таки молчите, чтобы остальные
тоже как-то напряглись.
Ну, что-то
возможно.
Если подумать
просто про нормальный язык C++,
то вообще-то constexpr это значит
имутабельно.
Любая constexpr функция, она как бы чистая
вообще-то. Как у вас constexpr
функция может
возвращать
что-то разное, там даже разных
типов или
ну, это же бред.
Или вот так вот даже, да?
Просто constexpr функции, они же
обязаны, ну, во-первых,
типы у них, ну, возвращаемый тип у
функции есть, ну, всё, как он может меняться.
Во-вторых, значения constexpr функции,
они всегда чистые.
У вас нету никакого рандома в compile time.
У вас нету никакого global
стоита, который вы могли бы менять
и там перещелкивать что-то. Ну, не должно быть.
Просто математическая функция,
дали ноль, всегда на вход одно и то же должно получить.
Ну, вот так-то
уж вообще должно работать.
Просто какую-то переменную объявили.
Вот такого типа и вот такого. Ну, смотришь
на код. Ну, две переменных одного типа.
Вот, ну, должны быть одного.
Но, оказывается, нет.
Да,
в современных компиляторах
уже не очень актуально.
Ну, и действительно сказано было
лямды. Лямды.
Вот
some type и do something.
Раньше были они. Вот их реализация.
Не типовой шаблонный
параметр, который
инициализирован по умолчанию
лямдой.
Каким смешным свойством
обладают лямды?
Каждое объявление новый тип.
Это верно. А каким
смешным свойством обладают значения по умолчанию?
Что для функций,
что для шаблонов?
Они каждый раз
вычисляются в том месте,
где вы попытались
использовать шаблон или функцию,
не упомянув этот аргумент.
Для функции это тоже верно.
Если вы какое-то выражение написали
в дефолтный аргумент функции,
то у вас это выражение каждый раз
заново будет вычисляться в
точке вызова функции.
Нет. Насколько я знаю, по стандарту
такого быть не может.
Да. Компилятор обязан.
Каждый раз,
когда вы инстанцируете вот этот шаблон
или вот этот,
заново вычислять выражение, написанное здесь,
в контексте
точки инстанциации.
А почему так сделано?
А лямбда каждый раз новая.
А чтобы какой-нибудь сурс локейшн сюда можно было вписать?
А, то есть здесь сделано...
По-моему, можно или нет?
Не получилось.
Ну ладно.
Для функции это точно сделано
с этой целью.
В функциях можно в дефолтный аргумент вписать сурс локейшн,
и это будет работать так,
как вам кажется.
Ну, кто не понимает, о чем я, неважно.
Две главные мысли.
Во-первых, дефолтные аргументы подставляются в точке,
где вы написали код.
А вторая, это что лямбды каждый раз они
разные типы имеют.
Ну и вот этот вот сам-тайп,
вот этот сам-тайп,
это каждый раз будут разные
специализации шаблона сам-тайп,
потому что лямбды разные.
Вот на этой строчке одна лямба будет сгенерирована,
и здесь тоже самое,
на этой строчке одна лямба,
на этой другая лямба.
Ну и вот, ну да, тут тоже самое.
Вот эта лямба берется и там
возвращается.
Ну, лямбды сравнивать нельзя,
ну, как указатель на функции можно,
поэтому...
Да,
до двадцатых плюсов
нельзя было впихивать лямбды
как не типовые шаблонные аргументы.
В двадцатых плюсах очень сильно
были требования к не типовым
шаблонным аргументам. Раньше это могли быть
только типы инты. Все.
Теперь там и структуры,
в домашней у вас уже были структуры, да,
и флоты, и лямбды,
и чётко всё можно.
И это, конечно, здорово.
Но что это нам
позволит натворить?
Так, опять вспоминаю,
мы здесь знаем тип.
Нам его нужно как-то вытащить.
Давайте брать и вытаскивать.
Сейчас познакомимся с...
Лучшие вещи в этом мире.
Можно сказать
и лучшие вещи в этом мире,
а можно сказать, так сказать,
официальным именем по бумагам.
Это дефект...
Дефект репорта?
Как по-русски репорт.
Сообщение о дефекте,
отчёт о дефекте, номер 2118,
стейтфул мета...
Смещённые формулировки
текста,
с самого описания языка
в стандарте.
Вот он правильно сказал,
но слишком нудно уже.
Даже то, что я сказал, уже слишком нудно.
Короче, это баг в стандарте языка.
Вы знаете, в законодательстве
у нас РФ есть куча текста
со сложными формулировками.
Иногда так получается,
что эти формулировки можно
интерпретировать по-разному.
В этот момент созываются люди
ответственные за это,
чтобы передать формулировку,
чтобы точнее передать то,
что мы хотели передать.
В комитете стандартизации C++
происходит то же самое.
Есть некоторая неоднозначность,
вернее, откровенный баг
в бюрократической формулировке стандарта.
Давайте на него смотреть.
Очень внимательно смотрим.
Это шаблон структуры.
Он принимает
шаблонный аргумент
«инт».
А внутри этого шаблона
структуры есть
декларация функции
френда.
Именно декларация.
Объявлена функция лобхол,
но не определена.
И она не шаблонная,
но в своих аргументах
упоминает
шаблонный аргумент этой структуры.
То есть это всё
зависимая штука,
а вот просто штука зависимая от n.
Если задуматься,
что будет происходить,
когда мы будем инстанциации
тег от n создавать,
инстанцировать тег от n.
Что будет происходить?
Для каждого n
эта функция лобхол будет своя.
И все они будут
перегрузками друг друга, грубо говоря.
Это пока только декларация.
Если мы
попытаемся вызвать её,
технически такие штуки
через как-то ADL находятся,
но у нас будет ошибка компиляции,
потому что определения пока нет.
Действительно, откуда ему взяться?
Давайте сделаем шаблон
другой структуры,
абсолютно никак не связанной с тег n,
принимающей
опять же int n и
class t,
шаблонные аргументы.
Эта структура внутри себя
будет на этот раз
определять функцию
лобхол
с ровно такой сигнатурой,
какая была здесь.
И возвращать из этой функции
тэск конструированная.
Внимание, вопрос.
Что произойдет теперь,
если мы пытаемся вызвать лобхол
от тега от 0?
Все равно проблема, да.
А потому что мы ни разу не инстанцировали
вот этот шаблон.
Но вот это вот определение
функции лобхол, оно же зависит
от шаблонных параметров.
Поэтому пока шаблон не инстанцировали,
никаких определений
и функций нет.
Теперь что будет?
Что будет происходить?
Мы инстанцировали лобхол
от 0 int.
Но оно скомпилируется?
Да оно просто возьмет, скомпилируется
и более того, возвращаемый тип
лобхола какой будет?
Int.
Понимаете, то есть
вот так написали одну строчку.
Error.
А если перед этим дописали вторую строчку,
то уже не Error.
Ну да.
Давайте в Requires это завернем хотя бы.
Requires вот эта штука
до того, как мы написали
лобхол unused
выдаст вам типа false.
Requires после выдаст true.
И более того, декл-тайп от него
выдаст вам int.
Двойное определение одной и той же
функции.
Давай ты с хитрыми догадками
как это продвигать в будущее светлое
попозже.
Да!
Вы понимаете, вот что глобально произошло?
Мы сделали слот
внутри компилятора.
Этот слот изначально пустой.
Мы можем написать
строчку и в момент компиляции
этой строчки
компилятор запишет в этот
слот int.
А также
мы можем
читать этот слот.
Как такой слот
для инвентаря в Майнкрафте.
Можем прочитать вот так и получить,
что там лежит int.
Но еще можем через Requires проверить
и нам скажут, что там ничего не лежит.
Если мы до вот этой
строчки попытаемся это сделать.
Внимание!
Эти строчки могут быть разнесены на любое
расстояние и написаны в любом
месте в коде.
Единственный вопрос это в каком порядке их
скомпилирует компилятор.
Почему
мы можем читать этот слот?
Потому что как только мы инстанцировали
вот этот класс Loop.Hole
у нас появилось определение
функции Loop.Hole.
И это определение
говорит, что вот этот авто
тип
вообще Т должен был быть.
Причем в зависимости от того
с каким T мы вот здесь инстанцируем
класс Loop.Hole
будет разный результат.
А если мы напишем Loop.Hole
1.int?
Это заполнит другой слот.
Каждый int это свой отдельный слот.
Вот этот int, который здесь
и здесь, это номер слота.
Может присвоить только один раз?
Один раз присвоить и все.
Вот это вот номер слота.
Слот 0 и слот 1 это
два разных слота.
Ты можешь прочитать слот 0, а можешь прочитать
слот 1. Они независимо существуют.
Мы не просто один слот
сделали, мы научились делать сколько угодно
много слотов в компиляторе,
в которые можно в любой момент времени
записать тип, а можно в любой момент
времени прочитать.
Да, один раз в write-only
в write-once
такой read-only-memory
которую один раз записали
и дальше только читают.
Да, это не проблема, потому что
слотов-то у нас сколько?
Это счетное число.
Сколько int существует?
Можно еще сюда параметров
допихать, 2 int, например.
А лучше наверное
сделать все-таки type
параметр и накладывать
вообще сколько угодно.
То есть
сколько угодно bit
информации, которые можно только один раз
записать. Этого в принципе достаточно уже,
чтобы что угодно примерно хранить.
Как мы это будем использовать?
Да, тут
важное подчеркивание.
А, ну собственно, как Андрей предложил,
давайте ко всей этой конструкции
добавим class.
То есть такой же tag и loophole.
Только loophole set
тут уже переименовался.
Добавим
шаблонный аргумент class.
Зачем?
Что будет классом, что будет int?
Номер поля.
Да, type структуры, номер
поля. Внутри
loophole
ubica.
Мы сделаем loophole set,
type структуры, номер
поля
и type поля.
Ну да.
А в
отдельной структурке loophole
get мы просто возьмем и посмотрим
декл-тайп loophole
и вот мы получили
type поля.
Где угодно.
Вообще в любом месте.
Главное
инстанцировать один раз
все эти loophole ubica.
Requires?
Ты спрашиваешь,
можно ли вот это вот loophole tag
в requires написать?
Будет, наверное.
Надо поэкспериментировать. Тут...
Окей, смотрите. Вот так точно работает.
Любые чуть-чуть отступания
влево-вправо могут не работать,
потому что это, блин...
Что это по факту такое?
Это недосмотр
в бюрократической формулировке
слов стандарта
C++. Никто тупо не подумал,
что такое вообще можно написать,
используя инструменты,
которые дает стандарт.
То есть есть там undefined behavior в стандарте
написано. Вот поведение неопределенное.
Есть unspecified behavior
написано. Типа каждый компилятор
и платформы имеют право делать что угодно.
А есть вот такие
кейсы, когда в самом стандарте
вообще ничего не написано про то,
что должно происходить
в этой ситуации.
Короче...
Но нам нужно следить, что у нас
индекс для каждой нужной...
Почему? Нет, ты просто...
Ты знаешь количество полей?
Ты знаешь, в каком порядке ты юбики пихаешь в конструктор?
Да.
Я обязан в том же порядке про инстанцию.
Да это неважно, слоты независимые.
Ну да, я про это и говорю,
что нам нужно поэкспериментировать.
У нас тег зависит от T и номера.
Мы можем почитать вот эту запись,
и в этом тут действует синхронизация.
Окей. Давайте напишем
обертку, которая сначала запускает
конструктор T
от этих юбиков,
потом делает вот эти геты и возвращает
вам type list.
Всё.
Просто вот это вот пользователи давайте наружу.
Чего?
Ну типа число, структура и номер поля.
Я говорю, вот этот тег
нужно смотреть на него как на слот.
Слот в компиляторе, в который можно
записать тип. Вот это вот авто
на самом деле является нашим слотом.
Ну и слоты параметризованы типом
и номером. Для каждого
типа и для каждого номера свой слот.
Есть метафункция,
метапроцедура даже,
а не функция, которая делает
set. Ей нужно
дать на вход тип и номер,
в какой слот и что
установить. Вот и всё.
Можно застрелиться, пытаясь понять,
что на этот счёт думает стандарт.
Я вам крайне рекомендую
становиться как-то
бюрократами.
Слишком сложно.
Работает во всех компиляторах,
кроме MSWC.
Насколько я понимаю,
это вроде гарантированно
должно работать. Если не работает,
это баг компилятор.
Очень сложно. В Clang и GCC точно
работает. В MSWC, скорее всего,
со свежих-свежих версий тоже
работает, потому что они там активно
фиксили какие-то баги,
относящиеся к расхождению в имплементации
шаблонов между GCC Clang
и MSWC.
Но нафиг вам MSWC использовать,
когда Clang под Windows умеют компилировать.
Ну, камон.
Почему мы сюда пикаем
T?
Было бы странно,
если для каждой структуры
ты использовал одни и те же слоты.
А для одной структуры
использовал, всё, слоты записаны.
Для следующей структуры
ты просто не сможешь запись сделать,
у тебя ошибка будет.
Мы при конструировании объекта вызываем
сет.
Мы всё ещё конструируем объект
от N штук лупхол
юбиков.
В этот момент
каждый из лупхол юбиков прикастится
к нужному типу аргумента.
В третий аргумент
так влетит поле,
и это будет
номер, мы запишем его,
а в T у нас что будет?
T это структура.
Структура,
у которой мы пытаемся понять типы полей.
И это номер поля
или номер юбика,
который мы пихнули в Т-фигурные скобки.
Type это то,
к чему юбик смог прикаститься.
Он смог прикаститься
к такому типу, значит это тип аргумента.
Мы устанавливаем в слот T и
значение Type.
А здесь мы читаем из слота
T, N,
какой там тип записан.
Магия.
Ну вот,
вот полный импл, чтобы
никого вообще не смущало ничего.
Мы прямо руками пишем
«бери делай»,
по количеству
нужному, и на выход
возвращаем тюпл, например.
Можно через TypeTupel или TypeList
какой-нибудь, как хотите.
Окей.
Никого нет сомнений, что это работает.
Ну и не должно быть, потому что я вас очень
экспрессивно убеждаю в том, что это работает.
Да.
Вот мнение
дедов по этому поводу,
что это дефект,
это надо и
исправлять, где-то
с 2015 года известно,
и вот я сказал, что это колдунство,
это официальная терминология.
Не шутки.
Ну, в общем, понятно.
Люди не понимают, как это работает,
поэтому хотят избавиться, чтобы им
стыдно не было, когда они это видят в кодбазе.
Ну да. Нет, это
непонятно, должно ли это на всех
компиляторах одинаково работать. Вдруг там какие-то
тонкие отличия? Ещё, ну, когда вы с этим
просто будете играться, если захотите,
будет домашка на рефлексиве
структур, но вот это всё
писать в ней – это опциональное.
Потому что сейчас будет ещё один способ, который
простой и понятный, но
неприятный.
Ну да.
Ну, Arcane Arts хотят запретить.
Ну, если запретят,
вот тогда пусть и приходят, а пока
что танцуем.
Всем рекомендую хоть раз попробовать с этим поиграться,
это просто убойная штука.
Ну,
в принципе, плюс у этого огромный.
Это просто работает.
Со всеми типами, со всеми структурами.
Никаких ограничений нет.
Но это могут пофиксить, что как бы
минус, но
скорее всего не пофиксить. Всё нормально.
Всё. Последнее
решение, последний
способ.
Четвёртое, которое почти хорошее,
но...
Ну, сейчас увидите.
Знаком ли вам такой синтаксис?
Знаком, да?
Да, это да.
Декомпозируем структуру на её поля.
Ну, мы знаем число полей.
Число полей мы знаем.
Нам только нужно написать structure binding,
в котором вот здесь будет
столько, через
запятую букв написано, сколько у нас полей.
Ну, и тогда
если их число
равно числу полей, то каждое
вот это вот выражение
будет как бы ссылаться
на или быть алиасом
для конкретного поля.
Важное замечание,
смешное. Не знаю, сталкивались ли вы с этим
когда-нибудь. Вот эти вот
выражения a, b, c,
они не являются переменными.
Здесь одна переменная, и у неё нет названия.
То есть это
просто некоторые, как ярлыки, которые
как бы если вы их пишете, то это
то же самое, что написать value точкой
какой-то поля.
Поэтому, в частности, если вы возвращаете
из функции вот это a,
у вас не сработает named return
value optimization.
Сталкиваюсь с таким?
Нет?
Ладно, пусть на записи останется, кто-нибудь
когда-нибудь обдумает это.
Просто вместо
вместо выражения a в каждой
точке использования как бы подставляется
value точка поля.
Это не ссылка.
Ссылка здесь одна, она ссылается на value
и у неё нет имени.
Адрес a?
Можно, ты получишь адрес
того, что вот здесь лежит.
То есть получишь адрес внутри value.
И потому что здесь ссылка.
Почему так сделано было?
Какие-то были причины на то, чтобы
это было не объявлением переменной,
а какая-то странная сущность,
которая выражение как бы алиас,
но как бы не переменная.
Имейте это в виду.
Ещё в лямбды нельзя захватывать
вот эти вот ABC.
Если это делать
стипа лайком,
то их можно, конечно.
План наш какой.
Вот мы получили эти ABC, давайте
их типы просто возьмём и вернём.
Вопрос только.
Телефон надо в кармане держать.
На чеку.
Всё.
Декл-тайп взяли,
вернули, всё круто.
Вопрос, как подобрать количество
вот этих вот буковок?
Никак.
Вообще никак.
Просто вот берёте, пишите так.
Руками.
Чё?
Как?
Букво.
А0.
А1. А2.
Ну всё.
Мы возвращаемся к тому
решение фиксить лейнумом,
где мы пишем макросы
на столько...
Да, да. Вы можете сделать по-разному.
Можете раскопипастить сами,
можете скрипт на питоне написать,
который вам там 50 раз это повторит
и в принципе сойдёт.
Где бы вы видели структуру,
в которой больше там 50 полей?
Я видел структуру.
Ну, запустишь скрипт на питоне
наподобие.
Ну, мы конфиги в текстовых файлах
храним они в структурах,
поэтому...
Короче, вот, прекрасно.
Можно сделать макрос, с помощью которого это генерить,
но это отдельное искусство,
вы можете только сами с этим разобраться,
попробовать, сейчас я это рассказывать не буду.
Да, про тай...
Знаете, что это такое?
Да.
Короче, в тюпл оно связывает.
Тут возвращается авто,
но это авто превратится в тюпл
из ссылок на вот эти вот штуки.
Правда ведь? Ссылок.
Да.
Да, потому что и в constexpr
вырезает ветку false,
когда вот здесь написано true.
Нет, тут все нормально будет,
это гарантировано.
Ну,
неважно.
Можно еще
через перегрузки,
чтобы не делать fov.
Ну, то есть там просто
перегрузки, где внутри
тега...
Теги мы уже видели, правда?
Диспатчинг по тегам.
Ретерн что?
Нет, мы хотим тюпл
из всех полей.
Мы будем знать тогда их типы,
и более того, это будет тюпл
ссылок на поля.
А тогда мы будем знать еще и как бы
ссылки на них.
Ну, и мы в принципе полностью победили.
Вот.
Ну, и делаем, делаем так
62 раза.
Потому что, как известно
из опыта,
в тюпле есть
больше 64
тюплы не бывают.
Как известно из опыта GCC,
варианта больше 11
альтернатив не бывают.
В скале не бывает тюплов больше 32
элементов. Ну, и там еще по списку...
Короче, все так делают.
И...
Ваш любимый язык, каким бы он вам
хорошим не казался, он тоже где-то глубоко
внутри имеет вот такой захардкоженный лимит
на размер тюпла, варианта или еще чего-то.
Ну, 100%.
А у C-sharp долгое время максимальный размер
тюпла был
7.
Просто 7.
Ну, бывает нужно. В этом случае
они предлагают
восьмым аргументом
в тюпл засунуть другой тюпл.
У него можно точка rest написать
и там опять дальше точка first,
точка second, точка и так далее.
Вот так.
Прекрасно.
...
А почему
мы обязаны все
пассить? Мы не можем
как-нибудь шаблонный параметр?
Я говорю, невозможно
вот эту вот штуку заставить,
в зависимости от чего-то шаблонного,
генерировать код,
где разное количество этих
ашек-бэшек написано.
Есть пропозл, который говорит, давайте
сделаем, чтобы можно было сказать,
я хочу здесь написать
только а, а дальше три точки, и чтобы а
это был пак.
Пак нужного размера, и чтобы я его мог
дальше использовать где-то. Пропозл есть.
Вмерджит его хорошо,
если через 10 лет, потому что там слишком много
проблем возникает, в том числе
в компиляторах. Потому что компиляторы
вот вообще не готовы к тому, чтобы
были паки
вне шаблонного контекста. А там вот именно такая
идея. Короче, сейчас никак
нельзя. Только раскопипастить
за хардкоженное количество раз
или макросами
нагенерить.
Вот. Это
работает, в принципе, для всего.
На удивление.
Вообще для всего.
Даже не совсем под типы, вы всякие строки
векторам можете пихать, и всякие
UID-шники. Вот есть библиотека
Boost по ФР.
Вот там это реализовано.
И там вот прям зарадоскопипастчина этот код
прекрасный. И все довольны,
и многие этим пользуются.
Вот.
То есть единственная
проблема, это что
вот у нас такой девиз, что вот этого
хватит для любых задач. А потом кто-нибудь придет
на Капгенят и уже не хватит.
И вот будет беда.
Ну, если в стандарте чуть-чуть подкрутит,
поменяю, то уже будет совсем круто,
и можно будет там вот эти лупхоллы
забить-забыть
и жить радостно. Но пока страдаем.
Да, ссылки
бесплатно получаем. Заметили?
Помните, у нас там еще была задача?
Получить ссылку на поле по номеру.
Тай
создает
из
через запятую перечисленных
аргументов
тюпл ссылок.
То есть сейчас
вот на этой строчке a
а и b не ссылки.
А тут вернутся ссылки.
А и b
это будут, вот здесь это будет
выражение
вот у
как бы, давай представим,
что у этой переменной, которая здесь
одна, есть имя х.
И вот здесь будет написано
х точка названия
первого поля.
Там а. Тоже нет.
А конфликт.
У. Первое поле у него будет у.
То есть здесь будет написано х точка у.
Х это ссылка.
Значит х точка у это тоже
как бы l-value ссылка.
Да?
Нет.
Это будет указатель
на конкретный флот или там конкретный
int.
Это будет
что?
Ну
блин, по-другому.
Ну точно такими же техниками.
Все одновременно не получится. Нужно
чуть-чуть кода пописать.
Ну тут
как узнать?
Не знаю, слушай. Вот именно в этой технике
я что-то не припомню.
Придумайте.
В домашнике это впрочем и не требуется,
но если хочется, то сами
я думаю, что-нибудь придумайте.
В конце концов, мое любимое решение с лупхолом,
а там все и так понятно
или непонятно.
Там может быть суть типа
хранить вот этот указатель
на мембр, нет?
Или нет?
Сейчас.
Слушай, ну вообще с указателем на мембр
что-то не работает, кажется.
Вообще никак.
По ходу нельзя, кстати.
Ничего мы можем сохранить с лупхолем?
Нет, а
в смысле, ты в лупхоле, у тебя
сохранить ты его
можешь. Откуда ты его вот здесь
достанешь?
Тебя же присвоят к какому-то мембру
только после того, как ты из этой функции вернешься.
Поэтому
слушай, наверное, все-таки нельзя.
Я вам так с горяча соврал, что можно,
все можно.
А на самом деле не зря, наверное,
ни в домашней, ни в презенташней не упомянуты
указатели на мембр.
А что? Что не так?
Достать в compile-time
список указателей
на мембр.
Там же требуется fully qualified name.
Вот кажется, что да.
Там по дефолту
единственный способ достать
это написать их имя.
Без рефлексии, короче, нельзя,
которая нормальная, языковая.
Все, окей. Давайте самое
последнее. Как ссылку
на поле по индексу достать, если вы выбрали
все-таки другой какой-то путь?
Ну, вот тут хороших
ответов нет. Вот если вы вот так
вот пишете через
вот эту тост, все окей.
И он делает tuple-ссылок.
Еще классно.
В иной ситуации придется
костылять и молиться
на undefined-behavior.
Мы будем костылять
через косты,
reinterpret-косты, к тюплам.
Берем наш instant-структуру
reinterpret-casting к
тюплу.
И
мы можем сделать get-e.
Прекрасно.
Ну, вот мы там
вот у нас get.
Получили количество полей.
И получили tuple, в котором
написаны подряд типы полей.
Ну, а теперь reinterpret-casting
к этому тюплу наша
экземпляр t и get-e.
И как бы технически
это работает.
Но еще более технически. Это лубе.
И как бы компилятор может очень
ну, беситься на нас.
Можно где-нибудь понавесить
volatile и, скорее всего, он перестанет беситься.
И все будет работать по факту.
Ну, все
как-то странно. У вас нету объекта типа
tuple. Какого черта вы конструируете объект
типа tuple там, где его нету?
Ну, или пытаетесь получить доступ к объекту
типа tuple, когда
его там нету? Да, tuple здесь
STD tuple обычно имеется в виду. Не там
метапрошный.
Ну,
не надо так делать.
Да, еще
действительно
с лейаутами может быть
проблема, потому что никто не гарантирует, что
лейяут у структур он такой же, как
у tuple. Стандарт, по-моему,
лейяут у tuple вообще никак нет.
Не констраинят. Поэтому
надо сделать свой
как бы tuple или
еще. Ну, да. В принципе, свой
tuple во всяком случае надо сделать. Свой
tuple, у которого гарантированный лейяут будет
такой же, как у структур. То есть, стандарт,
лейяут, type.
А дальше
можно попытаться следующие хаки
сделать. Как бы
взяли мы наш этот tuple прекрасный
и взяли
сейчас, что это у нас такое?
Да, это тип вот этого
поля,
которое нас интересует.
И дальше мы
reinterpret cast к указателям
на байтике, указатель на начало
tupla
и указатель
на...
Ну, это конечно же
не совсем тут правда.
Вот этот tpl, это должен быть
скорее
decal val какой-то. То есть, пока
или свой tuple новый создать.
То есть,
почему я об этом говорю? Вот здесь
технически мы возьмем ссылку
на невалидный объект
и это уже будет tube. Но если tpl
это просто какой-то экземпляр, вообще любой
экземпляр, вот этого типа
tuple, то все окей.
И вот у нас указатель на начало
tupla и на то место, где
начинается нас
интересующее поле.
Давайте их вычтем,
получим offset относительно начала
структуры нашего поля.
И тогда
мы возьмем указатель
уже на структуру
нашу,
прикастим к байтам,
подвинем на offset и это как бы будет указатель
в то место, где на самом деле в памяти
лежит вот этот самый объект.
И тогда мы сможем
сделать reinterpret cast
и вроде как ub избежали, но вроде как
и нет. Не
факт, что это ub.
Кажется, тут
еще вауны просто довести. Возможно,
да, это одно из тех мест,
где нужно навесить лаундер и вроде как
все хорошо. По факту,
даже если вы так оставите,
все будет нормально. Но для
пущей уверенности можно навесить
сюда лаундер, потому что компилятор может
быть не уверен, что там
действительно объект, который вас интересует,
лежит под этим указателем на байтике
и что-то не так сомптимизировать.
Но в целом вот такой способ
есть.
Если вы хотите познать плюсы во всем
их величии, вычитайте, пожалуйста,
из стандарта является ли это вот ub.
На любой лекции у нас
есть домашнее задание.
Перепроверить по стандарту слова лектора.
Потому что нельзя доверять
мне. Все.
На этом
все по
рассказам.
Сколько у нас времени?
У нас осталось 10 минут.
Мы можем...
Нет, мы не успеем
написать с нуля.
Может, успеем.
Давайте в скоростном режиме
напишем счетчик в констэкспре.
Сейчас очень
быстро нужно будет.
Я могу продиктовать.
Не надо диктовать.
Мне мой код из репозитория.
Аркадий.
В смысле? Там у тебя код из репозитория есть?
Репозитория это есть.
Вот это все нафиг выкидываем.
Вот это все нафиг выкидываем.
Это все игрушки.
Нет, перебрал.
Вот это.
Да.
Давайте делать
смешной метод counter.
Он возвращается с st.
Функцию.
Не метод, функцию.
Констэвал функцию.
Конечно,
должна быть шаблонной.
Но пока не понятно какой.
Главное, что я хочу от этой функции,
чтобы она была констэвал,
но при каждом запуске
возвращала значение на единицу больше.
При каждом констанцировании?
Нет.
При каждом
написании вот такой строчки кода.
Сейчас так не получится,
может быть мы, допустим, шаблон
кого-нибудь методика вызываем,
она будет каждый раз
констанцироваться мной.
Что будет?
Нет, во-первых,
ну ты в правильную сторону мыслишь,
но я не очень понимаю, что ты говоришь.
При каждой констанцировании
каунтора должен
появляться вот это следующее число.
Да, ну как бы да.
Технически,
наблюдаемое поведение,
которое я хочу, чтобы вот здесь, вот у всех трех
массивов был разный размер.
Вот и все. По дефолту,
вот вы вот здесь написали вызов каунтора,
вот здесь и вот здесь.
По дефолту, это все вызов одного
и того же, оно инстанцируется один раз,
и один раз зафиксирует
то, что будет возвращать.
Обязательно нужно
иметь лямбду вот здесь вот,
чтобы подаветь как бы
каширование специализации.
И заставить эту штуку каждый
раз новую специализацию
нам инстанцировать.
А дальше вопрос,
а что мы в этой новой, свежей
специализации будем делать?
Ну короче,
идея. Вот у нас есть слоты.
Занумированные числами.
Да?
Давайте просто будем идти слева направо
и смотреть, пока слот занят, увеличиваем
счетчик. Как только нашли свободный слот,
О, это наше значение. И его
тоже сетним.
А мы чекаем через requires?
Да.
А on instance?
Что? Нет, мы пишем
requires loophole.
Ну как проверить?
Вот.
Вот этот requires
проверяет
да,
проверяет
для какой-то определенной n
есть ли у нас уже текущее значение
какое-то.
Ну...
Да, где
точка с запятой?
Ну проблема в чем? Ну нам надо от нуля идти
и вверх.
Ну сейчас можно было бы
пэвэпендриваться как-то и без рекурсии
это сделать. Я предлагаю не надо.
Я предлагаю
просто еще один дефолтный аргумент добавить
cst n.
Мы будем с этим n работать
и смотреть.
Потому что
в десятый раз напоминаю,
что к сожалению, как только мы начали
использовать
аргументы constival или
constexpr функций, мы уже
откладываемся на поздний этап компиляции.
Вот есть этап компиляции,
где инстанцируются шаблоны, есть этап компиляции,
где делаются constexpr вычисления.
И вот они как бы связаны,
но как бы разные, поэтому мы
не можем сделать вот так.
В общем, на самом деле там
вот Дуборд писал, что это бай дизайн так.
Да, это так и задумано, что
когда у тебя вычисляется эта функция,
разные ее вычисления
не должны приводить к инстанциации
новых шаблонов, поэтому нельзя
запихать в шаблонный аргумент,
аргумент это и constival функция.
Специально так сделали.
Но
мы сейчас по сути такого же самого эффекта и добьемся.
На каждом запуске будет
разная инстанциация генерироваться, и все
нормально будет. То есть они конечно
пытаются воевать с нами, но это бесполезно.
Комьюнити C++
такого придумывает.
Окей, ну
давайте. Проверили, что на текущем
n-ке компилируется
loophole n, то есть сет
произошел. Да?
Если сет произошел,
то мы пока не нашли свободный слот,
и надо идти дальше. Что пишем?
Вот так вот.
Зачем ту же лямду?
Хотим новую.
Смотрите, слоты
сейчас
пробелы будут обозначать пустые
слоты, да?
Ладно, не будут.
Если он занят,
если он занят,
то мы вызываем n-1. Если не занят, пишем.
Вот это нулевой слот.
На первом запуске мы что увидим?
Нулевой слот свободен.
А что значит нулевой слот свободен?
Сета пока не произошло, да?
Вот это проверяет, что
loophole компилируется,
то есть что он занят.
Иначе мы пойдем в ветку else.
Давайте поменяем.
Поменяем местами.
Вот так вот.
Здесь надо set сделать, да?
Как мы делаем?
loophole
n
Вот так вот.
Вот он наш loophole,
и вот мы просто смотрим.
Был set, не было, идем дальше.
Прекрасно.
Ну, даже коротко получилось.
Что значит нашу?
Как ты ее используешь?
Ну зачем ты ее используешь?
Ну ладно, я не знаю.
Честно, я сейчас не
в настолько пиковом состоянии,
чтобы понять в голове, что произойдет.
Кажется, это на самом деле умная идея.
То есть внимание.
У нас нету ошибок компиляции.
И так нету ошибок компиляции.
И так нету ошибок.
Да-да-да.
Наверное, это хорошая идея.
Размеры массивов.
С одинаковым.
Этим разное.
Но вот и весь каунтер.
Одна функция, фактически.
Вот эти инициации, они происходят
на второй стане.
Какие?
Loophole N
Loophole N
оно, да,
оно инстанцирует
вот этот шаблон
только если мы
в if пошли.
Тут как бы то, про что я говорил,
почему нельзя аргументы
в конставал или констэкспор функции
использовать в шаблонах, это
странный вопрос.
Вообще это можно сделать в компиляторах,
чтобы это работало. Но почему-то не хотят
делать, потому что это совсем мозг взорвет людям.
Мы считаем, что у нас
констэкспор, конставал функции работают как
обычные функции.
Точно так. У обычных функций вы не можете
аргументы их пихать в аргументы шаблона?
Не можете. И здесь точно такую же
семантику сохранили.
Чтобы не взрывать людям мозги.
У нас будет такая проблема,
что если мы разрешим
считать аргументы
конставал функций
константными выражениями,
то у нас может быть такая проблема,
что у нас возвращаемый тип этой функции
зависит от значения аргумента.
Да, может.
Это немножко страшно.
Это зависимые типы.
И мы их не хотим.
Потому что мы мазохисты
и не хотим ничего хорошего.
Мы хотим страдать.
То есть у нас инстанциация
происходит, когда ИВ выполняется?
Да, инстанциация loophole-end
происходит только тогда, когда мы
в этот ИВ вошли. Почему-то это работает так.
Почему?
А что не так?
Ну, вообще, ИВ констэкспор, он так и задуман.
У тебя полностью выкидывается ветка,
которая не сработала. Она даже не компилируется,
шаблоны не инстанцируются. То есть по дефолту...
Столько стимуэйтит-энтити.
Окей.
Это замечание, о котором я не в курсе.
Если ты уберешь стимуэйт,
это констэкспор функции, то, кажется, ИВ констэкспор будет инстанцировать тебе ветки.
Да.
Он не должен заранее знать, сколько там
вот все эти...
Нет. Нет, нет.
Смотри.
ИВ констэкспор выполняется не в момент
исполнения функции, вообще говоря,
а в момент
инстанциации шаблона функции.
То есть вот этот шаблон каунтора,
в момент, когда он инстанцируется,
выполняется ИВ констэкспор и выбирает,
что оставить в этой функции.
Либо эту ветку, либо эту ветку.
Вот так вот.
Вот.
И дальше уже ту ветку,
которую мы оставили, мы пойдем тоже
компилировать, и в этот момент инстанцируем
лупхол.
Ну а здесь просто пойдем дальше
по рекурсии и будем инстанцировать уже
другой каунтор.
Ну и как-то так.
А в рантайме, в рантайме, это
в кавычках в рантайме.
То есть после того, как шаблон уже весь
полностью инстанцировался,
эта специализация у нас
уже есть, запуск ее,
несмотря на то, что это конставал штука,
как бы в рантайме запуск,
он будет просто состоять из того, чтобы
насквозь пролететь, сквозь
три слоя запуска каунтора
и в итоге
влететь в return n.
И все. То есть там больше никакого кода
не будет.
И в констекспро вырезаются в момент
инстанциации шаблонов.
Ну вот что-то в этом есть
извращенное, а если вы вспомните,
что вся эта штука в принципе вычисляется
в момент, когда мы собрались
инстанцировать шаблоны cd array,
чтобы понять для него второй не типовой
аргумент, то вот уже как-то мозг начинает
кипеть немножко.
Ладно.
На этом мы закончим.
В заключение могу лишь
сказать, что с помощью этого можно сделать
некоторое подобие боров чекера.
Размечая регионы,
где там переменные жива или мертва
через холл сета и геза.
То есть...
Мапу типов тоже
кучу можно сделать.
Попробуйте, вы офигеете
от того, какая жизнь интересная.
Всё. На этом совсем-совсем
всё. Всем спасибо.
Все свободны.
