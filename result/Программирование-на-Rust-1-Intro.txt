Значит так, я всех вас поздравляю, пришли на курс по самому замечательному современному
языку, который я сейчас вам докажу, что гораздо
лучше C++, который его превосходит на голову и который стоит
изучать. Он в будущем будет активно использоваться
во всех компаниях, но я в этом уверен, я попробую
вас в этом убедить. Если вы не уверены, то в общем
для вас первая половина лекции. Давайте начнем.
Для начала вообще о чем курс. Мы будем изучать здесь
основы всякого синтаксиса, коллекции, ну там знаете
битремэп, хэшмэп и подобные штуки. Потом будем изучать
что такое трейты, ну это уже особенность Раста, которая
похожа на концепты в плюсах, ну и на интерфейс. Мы будем
сравнивать это. Потом будут всякие найтли фичи, например
trade specialization. Будет параллел в карт-компьютинг, ну это
для тех, кто не знает курс TPMS. Ну мало ли тут есть
второкурсники. Кстати есть тут второкурсники сейчас
прямо на лекции. Вот есть целый один второкурсник,
кажется. Два. Отлично. К нам зашли те, кто чисто
заинтересован в том, чтобы изучать язык. Потом метапрограммирование.
Опять же, кто не знает, метапрограммирование это код генерации.
Раста, она оформлена не только как, знаете, там template
metaprogramming, как оно в плюсах, но также есть макросы. А макросы
умеют даже, например, ходить в сеть, в базы данных и
все такое. То есть это такая очень продвинутая штука
код на Расте, которая генерирует код на Расте прямо внутри.
Изучим всякий туллинг. Ну, например, там будут анализаторы
вроде Мири, которые проверяют unsaved код на defined behavior и
подобные вещи. Ну и во время курса вы еще будете пользоваться
очень часто Clippy и FMT. И тем самым вы узнаете, как писать
идиоматичный код на Расте. В крайней мере, я надеюсь на то,
что пока вы будете писать код и если вас форсить к тому,
чтобы вы использовали FMT и Clippy, то в таком случае
у вас должно получиться так, что вы в себя берете
все концепции Раста, как на нем писать код идиоматично.
Ну, по крайней мере, в шаде получилось, на мой взгляд.
Ну и System Safety. System Safety — это про систему типов. Это то,
что, собственно, делает Раст безопасным. Мы сейчас
обсудим, что такое вообще безопасность и в чем особенность
Раста. Так, и пререквизиты. Нам понадобится знание
плюсов. Без них мы никуда не денемся. Мы будем очень
часто с плюсами сравниваться. Этот курс рассчитан на
тех, кто знает C++ уже. Потом нам понадобится понимание
конкарантия, потому что иначе будет примерно пара лекций
по параллелиям с распределенным вечеслением и на них вы будете
плавать, если не будете проходить. Не пройдете достаточно
хорошо этот курс. Понадобится знание окоса. Окос нам
будет вообще беспрерывно помогать, по сути. То есть
нам нужно понимать, как внутри устроены, как лежат
типы в памяти, как устроена наша операционная система.
И, в частности, на последние лекции мы вообще будем
рассуждать, как ускорять код на Расте. В том числе
специфичным, например, для Линукса, Link Time Optimization,
подобные вещи. Ну и, конечно же, если вы, наверное, занимаетесь
фронтендом и подобными вещами, то, наверное, вам Раст не
так интересен, поэтому очень важно, чтобы вас интересовала
кент-разработка. Ну что, все готовы? Есть какие-нибудь
вопросы по организации курса? Хорошо, я постараюсь
говорить громче, так нормально. Я их сюда не написал, но
вообще у нас домашки будут. Пока что вы репозиторий
не видите. Он появится сегодня-завтра примерно. И еще примерно
в течение месяца, то есть до первого дедлайна гарантированно
уже будет настроена ACI, в которую быстро, как на курсе
Рома Липовского, точно так же отправлять задачки.
В плане, ну вообще, что они представляют? Сколько времени
занимает сделать ДЗ, я так понимаю? Это Depends. Если делать
на U3, то очень просто. А если на U10, то будет крайне
сложно. Там домашки будут занимать, наверное, часов
20-30 неделю, а на U3 вы сделаете все буквально за первый
месяц и все. И первый месяц он будет для вас очень
простым. То есть там задач буквально 10-12. Я не буквально
по самому основному языку. Ну, в среднем я бы сказал,
если все делать, наверное, часов 20 в неделю нужно будет
на курсе. Это если прям вообще все делать на U10. Еще какие-нибудь
вопросы? Ну что, давайте мы сначала поговорим о том,
зачем RAST был придуман, как он появился. У нас с самого
начала были машинные коды. Когда появились первые
компьютеры, были перфокарты, и на перфокартах убивали
собственно код, который исполнялся на компьютере.
Преимущество было в том, что мы, конечно, исполняли
ровно тот код, который забили. И более того, вы перфокарту
вставили, и больше ничего компьютеру не надо. Код
исполняет, который вы убили оттуда внутрь. Но очень
легко сделать ошибку. То есть вы просто банально
неправильную инструкцию убили, и теперь вот вы сидите
и не знаете, где же ваша ошибка. Такой код очень сложно
читать по тем же причинам и сложно дебажить. Его практически
невозможно переиспользовать. И для того, чтобы сделать
сложную программу, ну, сложную программу вообще в целом
невозможно сделать на перфокартах. Это, представьте, вот такую
штуку. Огромное количество карточек. Вот. Ну и, собственно,
даже на простую программу уходил много времени. И
код менялся от машины к машине. Потом люди, конечно,
поняли, что перфокарты не очень. Давайте прямо на
компьютерах писать. Вот появился ассемблер, появился ассемблер
на инструкции на английском. Вот. Те же самые преимущества.
Мы напрямую исполняем код, который мы написали. Мы
не требуем никакого ронтайма вокруг. И теперь уже невозможно
написать код, которого просто нет. Потому что у нас транслятор
ассемблера, он просто проверяет, если он не понимает, что
за инструкцию он ее запрещает. Поэтому мы, обращая внимание,
мы избавились от какого-то класса ошибок за счет того,
что у нас язык так устроен. Вот. Но нам все еще сложно
дебажить, сложно писать сложную логику, сложно переиспользовать
такой код. И, опять же, ну, много времени нужно, чтобы
написать его. Потом появился си. Си, язык это, си, язык
прекрасный. Он до сих пор используется активно,
как вы прекрасно знаете. И, в отличие от ассемблера,
он уже дает некоторый уровень абстракции. Потому что
мы уже не пишем непосредственно под машину. Мы пишем логику
самого кода. Иногда нам, конечно, приходится спускаться
на уровень ассемблера, когда мы, например, пишем всякие
драйвера или подобные вещи. Но большую часть времени,
в общем-то, надо... В общем, забудьте последние слова.
Так. Ну, этот язык немножко сложен, потому что, на
самом деле, он требует того, чтобы мы вручную управляли
памятью. И, соответственно, мы получаем всякие секволты,
буферы ворфлоуст, там есть нул-указатели, датарейсы,
в конце концов, undefined behaviors, которым вы наверняка сталкивались.
Он не очень продуктивен, потому что все-таки, по сравнению
с какими-то современными языками, например, C-sharp,
как-то синтаксического сахара не хватает. Хочется иногда
написать кумит лямб, дуалямб никаких нет. И вот тоже
один из серьезных недостатков — нет общей системы сборки.
То есть вы захотите, например, сделать какой-то... Скомпилировать
сложный код из многих файлов, большую систему. И дело в том,
что в случае C у вас нет никакого общего решения.
У вас там есть CMake, скажем, Bazel, Ninja, на Ninja основывается
Mesa, ну, такие вот системы сборки. Но общего решения
нет. Каждой компанией оно свое обычно. Давайте мы
вспомним, что такое undefined behavior, чтобы начать бояться
снова. Смотрите, вот есть такая въязвимость
CVE, она была в Gleap C. Она как устроена? В общем-то, в Gleap C
был такой баг, из-за которого была уязвимость в OpenSSL. Srandom
— это такая функция, которая ставит seed для генератора
случайных чисел. И в чем уязвимость заключается?
У нас там был какой-то код, который, когда не мог
читать из defrandom случайные биты, он пытался их сгенерировать.
То есть, перед этим вызываю вот такой вот код, который вы видите на слайде.
Вот скажите, что тут не так в этом коде? Кто-нибудь видит его?
Так, кто-нибудь еще? Так, хорошо, Андрей, что?
— Ну, вот тут у нас происходит чтение внинициализируя переменные.
— Да, у нас тут есть внинициализированная переменная на стеке.
Вот, и дело в том, что, так как это undefined behavior, компилятор
думает, ну, в общем-то, раз undefined behavior, значит, этот код недостижим,
такого быть не может, и вообще, в общем-то, мы можем делать с этим кодом все, что захотим.
И однажды он такой взял и просто удалил вот это вот все.
Ну, и получилась уязвимость, потому что мы могли банально на стеке сделать нужный нам мусор.
И, соответственно, у нас было зерно, которое мы уже заранее знали.
Вот. Потом у нас есть memory unsafety.
Memory unsafety — это когда вы допускаете доступ, как сказать, читаете из памяти,
которую вам читать нельзя, в общем-то.
Проблема в том, что у вас процесс имеет доступ ко всей памяти процесса.
И когда вы так читаете, у вас сайд-эффекты просто непредсказуемы.
Вот, например, какая беда вот в этом коде?
Можно по громче, пожалуйста.
На самом деле, тут все очень просто.
Что еще раз?
Какие-то проблемы с реаллокацией?
Нет.
Ну, память на стеке же выделена.
Да, память на стеке.
Ну, да, у нас...
Берем указатель на стековой памяти, возможно, могут изникнуть какие-то проблемы.
Гитлайн кажется реалоцирует.
Да, кажется, гитлайн реалоцирует.
И дело в том, что эта память на стеке пытается реалоцировать память на стеке.
И, в общем-то, это очень плохо, если вы вдруг решили записать больше чем 4024 бита вайта.
Ну, и слойте, соответственно, memory and safety.
Доступ к... Ну, сначала вы попробуете очистить память, которая вообще-то не была реалоцирована.
Ну, и потом уже дальше сайд-эффекты вообще непредсказуемы.
Есть еще такая замечательная история про мем-копию.
Я думаю, вы все помните вот такую вот функцию.
Особенно, если вы проходили курс-окос.
В общем-то, у мем-копии есть такая особенность.
Она требует, чтобы в области памяти, из которой вы копируете и в которой вы копируете, не пересекались.
Это контракт.
Но однажды пришли такие разработчики из Intel.
Просто вот у них процессоры такие вот новые были.
Они решили, что теперь мы будем копироваться с левого направа, с правого налевого.
Потому что так быстрее на наших процессорах работает.
Ну, в принципе, все логично, оно должно работать.
Потому что они не пересекаются.
Но однажды, после того, как они закомитили это, чуть-чуть попозже, осенью,
в одной из бета-сборок Fedora Linux, юзер запускает такой флэш-плеер,
а он вместо того, чтобы издавать звук, выдаёт треск.
И когда это ресерчили, выяснили, что в общем-то там была проблема в том,
что пересекались в области памяти.
Ну, а кто виноват вот в том, что вот это произошло вообще?
Есть две разные точки зрения.
Вот разработчики Gleap C и, собственно, Linux оторвались.
Один говорит, что виноваты те, кто пишет такое ужасное ПО,
а второй говорит, что вы можете говорить всё, что угодно про это.
Но, в общем-то, если им копия сам не предупреждает про это,
а нет никакого покрытия тестами, то вы сами виноваты.
Даже самое хорошее программное обеспечение может иметь баги.
Вот.
Забегай наперёд.
Rust это про второе, а C++ скорее про первое.
Вот.
Наконец-то давайте вот мы C немножко посмотрели на C,
теперь посмотрим на C++.
C++ такой язык, который не требует runtime.
Конечно, со звёздочкой немножко runtime есть.
Там нужно всякие exception-ы ловить, stack unwinding,
такие вот вещи.
Ну, можно сказать, что, в общем-то, runtime нет.
Ну, например, garbage collector такие вещи.
Ну, ещё одна программа, которая работает сейчас.
Вот.
Не нужен никакой runtime.
Не...
Поддерживает, ну, даёт большой толстый уровень абстракции.
У вас там есть всякие лямбды, темплейты, классы,
то есть прям такое OOP.
И у вас очень-очень толстый слой между вашим железом
и между вашей программой.
То есть вы, по сути, пишете уже код абсолютно отдельно
от вашего железа.
На C++ вы, конечно, можете очень легко спуститься
до нужного уровня.
Ну, вообще, это выска уровня у языка.
Недостаток в том, что никуда не ушли недостатки C
про seek fault, entified behavior, memory and safety и так далее.
Ещё, как мне кажется, такой ужасный минус,
это то, что там просто...
Ну, стандарт плюсов, оно так исторически получилось.
Они долго пытались поддерживать
всё то, что есть в C,
и в конце концов просто
получилось так, что стандарт и CMS.
Там очень много ошибок, и мы будем их обсуждать,
когда мы будем смотреть на то, как устроен Rust.
Ну, и точно так же нет общей системы сборки.
Давайте опять посмотрим на плюсовое OOP.
Кто-нибудь знает, что за проблема вот тут
в этом вот коде?
Так, ну давайте я тогда подскажу.
Ну, у нас createStreams,
это какая-то функция, которая возвращает вектор строк.
И, в общем-то, это временный объект
в случае этого фора.
Вот мы возвращаем временный объект,
потом у нас add 0,
то есть мы берём строк на нулевом индексе.
Но дело в том, что по стандарту плюсов
у нас так работает
диструк...
диструк...
диструк...
диструк...
удаление временных объектов,
что в тот момент, когда мы сделаем
add 0, то в таком случае у нас
уже будет вектор диалацирован,
потому что временный объект всё уже закончил
с временем жизни, мы пришли типа к другому.
И в итоге у нас это
будет сцентрироваться по памяти,
которая не инициализирована.
Это undefinedBehaviour.
К моменту вызову функции add,
результат выключённой createStreams
уже будет иничтожен?
Сейчас к моменту вызову add функции?
А, add.
После add, когда ты зайдёшь в цикл,
у тебя будет уже чар
взятый из функции
и строки, которая уже удалена.
Но, естественно, когда ты пойдёшь к следующей,
ты вообще уже по неинциализированной памяти будешь ходить.
Ну да, мы хотим, чтобы вы не показали,
и он как-то, я вот так понимаю.
Так.
Ну, смотрите.
Есть такой отмен, который в профункторе буквально пару часов назад
появился.
Эта вот штука
в общем-то был пропозал, который должен был починить эту штуку
в 23 стажете плюсов,
но его, в общем-то,
зарежектили, и теперь до 26
плюсов как минимум это не починится.
И, в общем-то, если вы хотите дальше
работать с языком, который
беспрерывно что-то реджекти,
то можете продолжать.
Ну, это не совсем правда, потому что есть ещё
дефек-репорты, так что если совсем повезёт,
этот патч привезёт
к дефек-репорту, примерно.
Если очень сильно повезёт, только.
Ну, стандарт
очень плохо развивается.
В плюсах это факт.
Он уже как-то забораживается.
Так, а теперь давайте посмотрим
на другой класс языков, который развивался параллельно.
Это всякие языки, у которых есть
garbage collection. Java, C-Sharp,
подобное.
У них runtime в принципе достаточно
быстрее, потому что там just-in-time
компиляция, она начинает быстро там
по горячим путям оптимизировать всё,
то есть видеть какие функции чаще вызываются
и лайнит их автоматически.
Это, конечно, зачастую всё ещё
медленнее, чем языки
вроде плюсов
или C, потому что всё-таки
вы это делаете в runtime,
а не просто в compile-time.
И, в общем-то,
зачастую не так быстро.
У них достаточно много
абстракций зачастую.
Вы можете запускать код
везде, где есть runtime, то есть вам не нужно
дождаться, пока перенесут компилятор.
Если у вас есть runtime, то вы уже запускаете свой код
спокойно.
Например, там есть Java JIT,
Java Virtual Machine.
В C-Sharp
CLR, по-моему,
так называется.
Эти языки безопаснее, чем C
или C++, потому что они уже не позволяют
не дают
Memorian Safety.
Но, тем не менее, всякие штуки вроде
Data Races у вас никуда не ушли.
То есть, например, в Java
выкидываются Exception, если вы пытаетесь
к одной переменности наскольких поток
обратиться, и при этом
вы никак не синхронизируетесь.
Или, например, к структуре данных,
которая предположительно
должна была быть однопоточной.
Давайте ещё посмотрим на минусы.
В общем-то, Garbage Collection
достаточно дорого.
Вы не можете заранее предсказать, какой у вас
есть тв-хет по памяти
Garbage Collection.
Потом вы не знаете, в какой момент у вас
может ГЦ вызваться.
Это тоже нужно учитывать.
И, в общем-то,
из-за этого использовать
серверных приложений достаточно бывает
дорого. Например, на сервере вы не хотите,
чтобы у вас на несколько секунд
он просто завис, потому что у вас
запустился ГЦ.
В частности, мы сейчас рассмотрим такие истории.
Смотрите, это дискорд.
Он переписывал часть своего кода с ГО на РАСТ.
ГО тоже современный язык,
простой, хороший.
Он с ГЦ.
Они переписали всё на РАСТ.
Почему переписали? Потому что вы можете
заметить такие спайки.
РАСТ примерно в 2 минуты.
Это вызывался
Garbage Collection, и из-за этого у них был
такой неравномерный
latency. На latency это время
от прихода запроса до ответа.
А он постоянно
прыгал. То есть был то небольшой,
то потом резко увеличивался.
Из-за паузы ГЦ.
Им это не нравилось, они переписали всё
на РАСТ, который
без ГЦ и работает примерно
как плюсы здесь.
А графики не запостились вас?
Графики не запостились вас?
Графики не запостились вас?
Не запустили, там есть ссылочка,
можно посмотреть. Прямо можно быть открыть
презентацию.
То же самое
писали в линкетине.
Что у них были
большие паузы по 5 секунд
целых в их приложениях на Джава.
Вы тоже можете почитать статью здесь
по ссылочке.
Ну и давайте дальше
посмотрим. У нас
всякие языки вроде Джава,
например, не позволяют
делать всякие мануальные оптимизации.
Мне, кстати говоря,
вот один из фактов,
я не эксперт Джава, но знаю один из фактов,
например, что их генерики
работают так, что они
в самом начале компилируются код, а уже потом
подставляется тип. В то время, как
например, в том же C++, который вы уже
знаете, ну и в РАСТ в частности,
в самом начале подставляется тип,
а потом уже копируется. Соответственно
раз сколько там нужно для каждого
типа класса,
а потом уже он оптимизируется
и, соответственно, специфичные для типа
оптимизации появляются,
что гораздо быстрее.
Ну и соответственно
мануальная оптимизация, как я написал на слайде,
у нас ГЦ
оптимизирует в последние случаи
всякие использования памяти и, соответственно,
ну всякие вещи
связанные с когерентностью кэшей, например,
не можем оптимизировать.
Beta Interoperability
Кто-нибудь знает, что это значит?
Да, это про то, как
взаимодействуют коды
на разных языках.
Ну и, конечно, они не очень
хорошо подходят для системного программирования.
Системное программирование, конечно,
на самом деле
подходит, например, ГО считается даже системным языком,
но все-таки
то, что у них есть ГЦ,
оптимизирует области,
в которых их можно использовать.
Ты имел в виду Beta Interoperability
между разными рамтаймами?
Ну да,
если у тебя язык без ГЦ
и язык с ГЦ, если ты вызываешь
без ГЦ и с ГЦ, то в таком случае все хорошо.
В обратную сторону уже плохо,
например, если два ГЦ, там вообще очень плохо.
Нет, потому что, например, там
прокамы, написанные на разных языках
по JVM, скорее всего, как-то могут нормально взаимодействовать.
Ну это да,
там Kotlin и Java хорошо взаимодействуют.
Так, ну давайте
поймем, что такое системное программирование.
Это вообще процесс написания программ,
которые взаимодействуют в первую очередь
с другими программами и не пользовательными.
Ну в качестве примеров это операционные системы,
прошивки,
базы данных, виртуальные машины,
браузеры.
Браузеры вообще отдельная тема, это по сути тоже
операционная система в каком-то роде,
потому что они тоже исполняют программы,
на себе.
Ну и не очень сложные.
Обычно мы от
программ систем
ожидаем то, что они будут быстро исполняться и стабильно.
То есть мы
может быть хотим, чтобы чуть-чуть медленнее, но при этом
стабильно, а не как у нас только что было с ГЦ,
там раз в пять секунд у нас spike.
Потом, если у нас
случается какой-то баг, ну, например, мы там
BD накосячили, у нас просто
вся BD стерлась, потому что мы там где-то что-то
неправильно написали.
Поэтому у нас высокая чувствительность к всяким багам.
Ну и high security, это чтобы, например, пользовательские данные
не утикали,
всякие пароли за счет того,
чтобы неправильно написали какую-то часть кода.
Вот.
Почему мы все еще используем C для системного
программирования? Вообще Assembler он
как-то строго лучше,
AC строго лучше, чем Assembler,
а Assembler строго лучше, чем машины АКД.
Но сказать, что C++
строго лучше C это как-то
не очень правильно, потому что все-таки
C++ слишком сложный язык.
И неспроста он
не используется в ядре Linux,
например.
Его очень сложно контролировать.
И, ну,
например, мы не можем,
а не буду, наверное, на этом этап
пока что примеры проводить.
Так.
И вот появляется вопрос, а быть ли когда-нибудь язык,
который строго лучше C?
Ну, то есть просто вот решает какую-то проблему,
никаких новых не добавляет.
Вот у нас появляется Rust
на арене.
Он не требует никакого рентайма.
Ну, снова же, со звездочкой там есть что-то вроде
Exception, это паника.
И там нужен рентайм вокруг.
Мы там линкуем
свою Gleap C, по сути, программу,
поэтому у нас достаточно большая программа
на Rust, но, тем не менее,
рентайма мы получаем не требуем.
Он представляет достаточно толстый
слой абстракции.
Там очень много всяких вещей, вроде
closures,
есть структура,
генерики,
итераторы. На системе типов
вообще можно всякие прекрасные вещи делать,
как мы потом увидим.
Самое главное, то, что обещает Rust,
то, что в сейв подножии Rust у вас никогда
не будет memory unsafety и undefined behavior.
Это прекрасно,
потому что мы можем доверять своей программе.
У нас компилятор
будет на этапе компиляции
выкидывать какую-то часть ошибок.
Плюс у нас там
современный стандарт,
в котором практически нет никаких
серьезных бирок,
как в плюсах. Мы это увидим.
Плюс есть целая система
сборки и dependency
management. Это Cargo.
Мы с ним тоже познакомимся.
Кстати говоря,
тут есть две прекрасные статьи от Microsoft
и Chromium, которые говорят, что
эти две ошибки,
два класса ошибок, memory unsafety
undefined behavior, это 70% багов
вообще в ПО.
70%.
У Rust, конечно, есть недостатки.
Его очень сложно изучать,
поэтому нужно быть к этому готовым.
Особенно в начале.
Потом он
компилируемый, поэтому
так же, как на Python,
он очень легко прототипирует,
сделать скриптик на него не получится.
И если у вас очень много оптимизации,
как вы потом увидите, вам придется
очень часто использовать unsave.
Это такое другое подношество Rust,
где вы можете, грубо говоря, только разуменовывать
указатели.
Но это уже добавляет
одновременно всю мощь C и все проблемы C,
поэтому мы будем это максимально избегать.
То есть это для решения
наследия какого-то?
Что еще?
Это для решения проблем наследия.
Зачем нам использовать
контент C?
Я имею в виду, когда мы там будем
энтеристики всякие использовать,
там уже просто нужно будет
самому заботиться о том, чтобы память была
выровнена как нужно.
Раст это не будет проверять, он просто
использует, а это на тебе будет все.
И поэтому он unsave использует.
Ну, требует unsave.
Теперь давайте мы посмотрим
на код простенького
вектора на C, чтобы понять, как у нас
общий раст устроен.
Я думаю, что для вас
маловато, да?
Так нормально?
Еще больше?
Мы сейчас посмотрим
ошибки в C, и потом посмотрим,
а что бы мог сделать компилятор,
чтобы эти ошибки предотвратить.
Так.
Давайте поищем баги.
Какие баги сейчас видите?
Так. Какой баг видишь?
Да, правильно. Здесь мы возвращаем
память на стеке указатель.
Ну, понятное дело, мы возвращаем такой
висящий указатель.
Ну и соответственно...
Что вот здесь вот есть
в этой функции?
Ну, во-первых,
я бы, конечно...
Вообще я взял код
из Стэнфорда, скажем так.
У них тут, на самом деле, есть еще один баг.
Вектор у нас все-таки не байтовый,
а интовый.
И здесь нужно лоцировать
sizeOfInt на newCapacity.
Так мы и просто newCapacity.byte
выделили.
А у нас это обязательно нужно?
Да.
А у нас это обязательно нужно?
Обязательно.
В плане вот здесь вот?
Нет, просто если функция
передастся 0.2, то у нас все будет...
Ну да, это тоже point, то что у нас может
нуловый быть вектор.
Мы даты не очищаем старую.
Так, что еще раз не очищаем?
Старую дату не очищаем.
Да, вот здесь, вот в этой строчке мы не очищаем старую дату.
У нас, соответственно, получается память,
которую мы не очистили. Это по ухо тоже.
Кажется, тут все.
Так.
И вот в этих вот двух функциях, что вы видите?
Так, давайте,
назовите номер строчки ошибку.
38, 39, swap.
Так, хорошо, да.
39, освобождение.
Да, тут double-free.
В общем-то,
сначала нужно освободить
буфер вектора, а потом уже сам вектор.
Ну, и тут еще один баг есть.
Нулевой.
Ну да, когда мы
берем указатель
вот здесь вот на
векдейта, а потом пушим,
то в таком случае у нас здесь может возникнуть
реаллокация. Конкретно в данном примере она даже обязательно
возникнет.
Ну, вообще так делать плохо. Сначала пушить вектор,
а потом надеяться на то, что указатели
не инвалидировались.
Да-да, здесь тоже есть double-free.
New и push.
За счет чего?
А, ну да-да, тут плюс один еще.
Stanford, скажем так, очень
постарался баги посадить.
Так. Ну, в общем, самое
главное, мы нашли 4
типа ошибок.
Давайте мы по ним пройдемся.
Вот у нас был такой вот код.
И мы в нем нашли такой вот баг, что мы возвращали
указатель с такой переменной.
Не было ли это классно, если бы вектор
не обратил внимание, что вообще-то мы
на что даем указатель, что уже
выходит за свой скоп?
То есть это компилятор
бы казалось бы легко мог словить, да?
Потом у нас был
double-free ошибка. Например, вот здесь.
Не было ли классно, если бы он не обратил внимание,
что вообще-то пытаемся освободить память,
которую мы уже освободили внутри?
Еще есть интератор
Invalidation.
И здесь компилятор мог бы
чуть-чуть поменял код, потому что
у него просто техи не получилось, сделал так, чтобы формат
тоже в желтом был, но неважно.
В общем-то, здесь тоже компилятор мог бы
обратить внимание на то, что мы с самого начала
изменили вектор, а потом мы
пытаемся вывести элемент.
В общем-то, все эти
типа ошибок умеет компилятор вылавлять.
Ну, и еще один. Memory leak есть.
Здесь компилятор тоже мог бы
обратить внимание на то, что мы
затираем указатель на ту память,
которую мы еще не освободили.
Последний указатель.
В общем-то, Rust, он как раз эти проблемы
решает, и это доказано теоретически.
Это доказал
вот такой вот человек, его зовут
Ralph Junk, если я его правильно
прочитал. Есть целых
три награды у его
PHD, кажется,
или просто статьи,
которые как раз
занимались тем, что доказывал
безопасность Rust. Если быть
более конкретным, то он сделал такую модель, которая называется
Rust Belt. Это такая теоретическая
модель Rust, упрощенная несколько,
но она имеет все корневые концепции,
поэтому она полная.
В общем-то, он доказал, что Safe Rust
действительно безопасен, что он не позволяет
делать вещи вроде Undefined
Behavior, Memory Unsafety.
Он
сформулировал основные
условия для того, чтобы
считать TI безопасной абстракции.
И доказал Soundness. Soundness
это означает то, что
тип является Sound, если
он не дает
убей или Memory Unsafety при
любом обращении с ним.
Он доказал
с помощью Coq и Iris,
что основные
вещи, которые используются в Rust,
мы, конечно, с ними еще познакомимся,
Cell, Ref, Cell,
Threadspawn и прочее, они безопасны.
Среди них
те, кто с курсом
Concurrency знаком, уже должны знать
про Mutex, Rwlock, Threadspawn.
Еще можно
догадаться, что такое Arc, это у нас
Atomic Pointer.
Smart Pointer.
И вообще история Rust такова, что
в Mozilla компании
был такой человек, звали его
Graydon Haar. И он в какой-то
момент, изучая другие языки
программирования, понял, что
tooling к ним.
Что вообще-то все эти
проверки прямо на этапе
runtime и на этапе компиляции
сделал достаточно хороший язык.
И он в течение 4-х лет перелил
этот язык. И потом в какой-то момент
показал его внутри Mozilla.
Людям он понравился,
команда начала расти, они начали
его делать.
Потом Rust улучшал систему типов
внутри, но там появлялись
очень сильные type system
в этот момент.
Приявился Cargo, который пакетный менеджер.
Кстати говоря, NPM,
то, что пакетный менеджер, кажется,
это JavaScript.
Это пакетный менеджер.
Те, кто его делает,
Foundation, сказали, что Rust
это такой язык, который
boring to deploy. В общем, скучный
для того, чтобы его вообще деплоить.
И это хорошо, потому что вы же не хотите
приключений себе на попу, если вы
что-то деплоите в прод.
После этого, с 2014 до
сегодняшнего дня Rust рос.
Если вам интересно, можете посмотреть, кстати,
в ссылочке,
там, если это рассказать чуть подробнее,
но, кажется, что основные
포인ты я уже сказал.
Да, это
они уже отделились, там уже
Rust Foundation, это отдельная вещь, но
основной
разработчик языка это Mozilla.
Ну, и кто использует на данный момент
Rust? Не нишевый ли это все еще язык?
Ну, во-первых, Google, они
прямо сейчас активно пушат Rust
в ядро Linux. Я напоминаю, что там сейчас
основной языком был только C.
То есть появляется Rust спустя много-много
лет.
Потом Google делает
os-фуксию и разрешает
использовать Rust на Android.
А Meta,
который бывший Facebook, у них есть
своя система контроля версии
Mononoke,
DM Blockchain
и, собственно, они пилят
metaverse на Rust.
Поэтому, если вы хотите
пойти в мета пилить metaverse,
то вам нужно будет знать Rust.
Один из самых
активных, наверное, пользователей Rust
среди больших компаний, потому что
больше всего новостей, это Amazon.
Они захайлили всех тех,
кто разрабатывает библиотеку Tokio.
Ну, это такой синхронный фреймворк.
Если вы знаете, в плюсах есть ASIO,
это что-то подобное, но это даже круче
на самом деле Tokio.
Потом Firecracker,
это такая система виртуализации.
Bottle Rocket, это
Linux-based контейнер такой.
Ну, и Nitro,
это Compute Environments.
Такие вот вещи.
Ну, и Microsoft тоже потихоньку адоптит.
Они, например, на Windows
переписали небольшую компоненту на Rust
и были восхищены.
Все, что оранжевое, если что, это ссылочки.
Это все можно протыкать и прямо прочитать.
Потом у нас есть
прямо враппер
вокруг WinAPI.
Растовский.
Растовский враппер вокруг WinAPI.
Вот.
Ну, давайте поговорим про плохую сторону.
Почему все-таки компании иногда
не используют Rust?
Ну, во-первых, иногда в компаниях
бывает очень много написанного кода
уже на Rust.
Не на Rust, а на другом языке.
Например, там в Гугле, если у вас написаны
его на струче кода на плюсах,
то вы вряд ли захотите что-то взять и переписать.
Это очень много усилий.
Потом
нужно будет поддерживать внутренние
инструменты на Rust.
То есть,
например, там, если вы работали
в Яндексе, там вот в Аркадии есть
свои инструментарии, там Rust
не поддерживается.
Также, если вы в большой компании,
то вы хотите иметь свой собственный комитет
для того, чтобы поддерживать
всякие RFC,
которые пытаются пройти в язык,
которые вам интересны.
Или, наоборот, блокировать
сприкейтинг, чего-то. Если у вас, например,
в компании много чего написано,
и вы считаете использованием какой-то фичи,
и вы хотите, чтобы его не выпиливали.
Ну, и
язык, на самом деле, достаточно новый.
Поэтому найти на него разработчиков
очень сложно.
Ну, сколько им получается лет? 10 лет сейчас.
Раз-два.
Ну, это с учетом еще того, что
он четыре из них года был
исключительно проектом
Gradonahar.
Ну, и плюс еще
разработчики на Rust такие люди, которые
очень много денег хотят,
очень умные ребята, поэтому
представьте себе, вы так хотите
за бесплатно кандидаты найти, он приходит,
он, конечно, крутой, но целый
вагон денег просит, поэтому
их сложно найти.
Вот.
Ну, и в основном
те, кто использует
всё-таки Rust, это всякие не особо крупные
компании на данный момент, стартапы,
ну, и, конечно, есть большие компании вроде бы
вроде Amazon,
которые там адоптят Rust, но
преимущественно всё-таки сейчас небольшие компании
его используют. Я считаю, что
в будущем Rust будут
использоваться гораздо больше.
Потому что новые проекты сейчас активно пишутся
именно на Rust. Вы можете смотреть новости
и обратить на это внимание.
Вот.
Ну, кстати говоря, я могу еще сказать такой, ну,
я как работник Яндекса, я могу
вам сказать, например, информацию
про то, как у нас
вообще настроение про Rust.
У нас есть такие две категории людей.
Та категория, которая пофигует
на Rust, она всегда будет.
И те, кому интересно.
И вот те, кому интересно, вот я слышал такой интересный
пони, что мы сейчас можем просто пропустить
момент, не добавляя
Rust в Arcadia, то есть внутреннюю
монорепозиторию Яндекса.
Как это когда-то произошло с
питоном вторым в Яндексе. Ну, то есть
третьим, точнее. Мы сидели долго
на втором питоне, а потом только перешли на третий.
И это было уже очень поздно как-то.
Ну, и можем упустить момент.
Вот.
Есть какие-то вопросы по той части?
Прежде чем мы перейдем непосредственно к самому Rust.
Ты упомянул, что у Rust
есть стандарт?
Это правда?
Ты имеешь ввиду стандарт, который прям PDF-ка такая?
Ну, типа да.
Спецификация есть.
Спецификация есть, конечно, да.
Спецификация есть, конечно, да.
Ну,
Скажем так, я никогда не видел
никакой прям PDF-ки,
как при сахтокопе стандарта.
Скорее всего, и нет.
Но очень легко можно найти
описание того,
что мы требуем и от каких функций.
Вообще, по факту, сейчас есть
только одна имплементация Rust,
Rust-C. Она работает на LLVM.
Ну, если вы знаете,
это кодогенерация такая, да.
Предназначена для того, чтобы делать
на нем языки.
Вот. Сейчас, конечно, делать так, чтобы еще можно было
на GCC писать.
Ну, то есть, писать Rust-код
и конкурировать его через GCC.
Но пока что этот проект достаточно сырой.
Потому что эталонная имплементация Rust
только одна.
Вот так вот.
Эталонная, это, скорее всего, должна быть одна.
Профессионной имплементации, кроме эталонной,
пока нет.
Ну, есть такая частичная GCC, наверное,
но пока что больше ничего нет.
Еще что-нибудь?
Так. Ну, давайте для начала напишем
Hello World.
Когда без этого?
Так.
Смотрите, у нас все, как и во всех языках,
начинается с функции Main.
Сколько у нас времени? Прошел только часик?
Отлично.
Вот у нас есть такой прекрасный Main.
Sprint-len
Hello World.
Sprint-len, вот что значит
восклицательный знак? Это вообще значит, что это
macros. Что такое macros, пока что
можете не задумываться. Можете воспринимать это
просто как обыкновенную функцию.
На самом деле, там, конечно, происходит код
генерация, то есть там по факту
лочится stdin
и потом в него пишется
что-то. То есть вам прежде чем что-то записать в
stdin, нужно гарантировать то, что вы единственный
писатель, иначе у вас там будет
крокодиабра,
если вы в несколько потоках будете
писать.
Пока что можете просто воспринимать это как функцию.
Ну и
это просто способ
задекларить функцию.
Вот. Вот так вот
компилируется. Можно компилировать
непосредственно с помощью RSC-компилятора.
То есть это точно так же, если вы
напишете, например, GCC
или Clang++,
G++, Clang++
и скомпилируется, соответственно, код.
Вот. Ну и запускается.
Ну, на самом деле, это не едиматично,
лучше пользоваться Cargo. Ну, мы чуть-чуть
на него посмотрим попозже.
Еще можно вот так вот написать
Main. Ну это уже такое
просто, просто чисто фановый слайд.
Ну, тут, по сути, написано то же самое,
что и в прошлом слайде. То есть
тут написано,
что вы
за хардкожен Hello World и вызывается
системный вызов.
Вот так вот.
Вот. Такие вот есть типы в расте
базовых переменных.
Думаю, что тут
в принципе все понятно, там и 16,
и 64,
и 16.
И особенно в сравнении
с плюсами это, во-первых, то, что у нас
есть 128-битные числовые типы в стандарте.
То есть мы можем прямо их использовать.
Во-вторых, у нас
и size, и usize, но это как
sizeT и
sizeT в плюсах.
Они, соответственно, зависит от
платформы. Это размер указателей.
Так. Чтобы объявить
переменную, нам нужно использовать
led, ключевое слово.
Забегая наперед, скажу, что на самом деле это
led, это pattern matching.
То есть на самом деле его можно посмотреть даже более глубоко,
чем просто на ключевое слово для
создания переменной.
Видим чуть попозже.
Это забегай наперед просто.
Пока что можете воспринимать led просто как способ объявить
переменную.
Вот. Смотрите.
В первой строчке
я объявил переменную idx,
который тип usize.
То есть, видите, я пишу не как в плюсах
там sizeT idx,
а пишу led idx usize
через двоеточие.
Тип не обязательно писать.
Там есть type inference.
Мы на него еще посмотрим. И вы его тем более
еще очень часто будете видеть в домашке, он очень прекрасен.
Сейчас
объясню, что это.
Потом есть всякие литералы.
Просто вот качество примеров.
Тут мы можем писать шестнадцатеричное число,
восьмеричное
и двоичное число.
Да, нижнее
подчеркивание. В плюсах, кажется, кавычки используется.
Еще переменные
по дефолту не мутабельные.
Чтобы сделать все мутабельные,
нужно дописать let mute.
Это то же самое,
грубо говоря, то же самое, на самом деле.
Чуть-чуть отличается,
что const в плюсах.
То есть вы получаете, грубо говоря,
вы являетесь переменной константами.
А потом
если вы захотите сделать не константной,
то вам нужно написать mute.
Дело в том, что зачастую, когда вы пишете код,
вам не нужно мутировать переменные.
Особенно если вы пишете в каком-нибудь функциональном стиле.
Раз такое позволяет.
А можно на лету
делать переменные?
На лету?
А не в рэнтайме?
Приходишь в unsafe, обещаешь,
и код опять пишешь.
В смысле, ну как cast
к неконстантному типу?
Ну, я не очень понимаю, зачем это нужно.
Вообще,
если я примерно правильно понял
твой вопрос, то на самом деле в расе такое
делать намеренно это ub.
То есть это обязательно
будет использоваться unsafe, и это получится ub.
То есть так лучше не делать.
И кажется, это никогда не надо.
И на секундочку. То, что type inference,
вот вы помните, в расе есть ключевое слово
авто.
Авто просто, оно берет такое
и вот вы пишете, авто х
сравняется с чего-то там.
С++ есть типа авто, да?
Ну, в общем-то, он
просто берет и смотрит на правую часть,
присваивает значение левой, да?
А в расе, на самом деле,
type inference он хитрее.
Он смотрит на то, как вы используете
переменную даже дальше. То есть вы можете
написать, например, вот как я объявил,
представьте, что я и dx, вот этот вот usize,
сейчас
покажу, наверное, будет видно.
Ладно, потом дальше будет видно
на слайдах.
Представьте, что я здесь не написал двоеточие usize,
просто ui и dx равняется 92. Это тоже
валидно.
Раст по умолчанию будет считать, что это тип i32.
Если бы это были какие-то более сложные
типы, то он бы с самого начала посмотрел,
а как вы дальше пользуетесь этим типом в коде.
Например, если это вектор,
вы объявили вектор весь
template значения.
Ну, знаете, у вас век может быть из i32,
а может быть из чего-то еще.
Вот раз будет смотреть,
а что вы пушите вектор?
Он поймет и выведет тип.
И если, например, будет несколько возможных типов,
то он скажет, что
не могу вывести,
укажи явно.
Это на самом деле удобно.
То есть я вам советую даже большую часть времени
не писать типы явно.
Это будет
и красивее, и более того,
раз у вас будет делать большую часть работы.
Смотрите, вот у нас есть
еще bool, который может
иметь два значения, true и false.
В отличие от плюсов, где мы могли бы написать
bool x равняется 12,
это бы даже работало,
в расти такое нельзя сделать.
Он скажет, что вы попробовали
присвоить целочисленное значение, что очень
плохо.
Плюс ко всему bool у нас занимает
всегда один байт в памяти.
Это будет важнее.
То есть несмотря на то, что у нас только true и false значения,
мы будем занимать не один бит, а один байт целый.
То есть как мы это
ожидаем на самом деле.
Так, ну базовая рифметика тут есть
на типах, плюс, минус, умножить, равно,
делить.
Есть деление и деление с остатком,
которое по умолчанию округляет
до нуля. В плюсах, насколько вы знаете,
если вы будете отрицательное число
делить, либо делить на
отрицательное число, то у вас будут всякие
непредсказуемые результаты, а в расти все
прекрасно с этим.
Обратите внимание на то,
как я, кстати, объявляю переменные.
Let x, y, например,
в скобочках. Я сразу же
несколько переменных объявляю.
Значит,
это тоже очень удобно.
Скобочки, знаешь, в плюсах
можно автопейер.
То есть если хочется разбить
пару, например, то там
через авто это можно сделать. Примерно
то же самое, но только в расти это на самом деле
еще лучше устроено. Там можно, например,
есть переменных так объявлять.
А, как питоник?
Да, да.
По-моему, x, y за 5 и там
присваивается.
Да, здесь просто на самом деле вот этот вот
тюпл. То есть может такой тюпл еще знаем?
Пока что опять же можете посмотреть это
просто как на какую-то фигню в скобочках, а потом мы
поймем, что это на самом деле тюпл, а потом еще и
поймем, что это pattern matching.
Так.
Ну, есть всякие побитые операции.
Очень важный момент у нас нет.
Операции плюс-плюс-инкремент.
Вы знаете, у нас есть префиксные и постфиксные
плюсах-инкременты, из-за них может случайно
случиться головная боль. В плюсах
если вы хотите добавить или отнять,
в плюсах пишется плюс равно один, минус равно один.
В питоне, например,
он бы сделал точно так же.
На самом деле это никакой головной боли не
дает, это просто удобно.
В том смысле, что
не нужно думать
какой он там
префиксный или постфиксный, нужно использовать
инкременты, как перегружать свои классы
и так далее.
Так. Ну, и всякие есть функции
прекрасные. Вот, например, у нас есть
на числе минус 92
и 32 функция ABS. Ну, соответственно
она вернет просто 92.
Через точечку позвали на числе
что-то. Count once это pop-knt,
если вы знаете такую инструкцию
на компьютере. То есть число единичек считает.
Там скобочки используются
потому что
минус? Да, да, да.
Скобочки потому что
минус, так бы было не обязательно.
Если без скобочек, то тогда
получится минус 92, потому что
сначала точка применится, потом минус.
У нас каждый
человек объект, у них есть
эти методы?
Ну да, там можно имплементировать
в будущем, поговорим про трейты,
и можно будет имплементировать трейты
для чисел. То есть там
интерфейсы для чисел.
Ну, можно будет протыгать потом на ссылочку
на презентации, там будет полный список
операторов всяких.
Что еще раз?
Возведение степени
Быстрая возведение степени
Так, потом у нас нет
неявного кастотипов.
То есть, например
ну, можете пока посмотреть, пока я водичку
Ну, как видите, у нас X это U16
переменная, а Y это
U32. И
дело в том, что когда мы пытаемся Q32
U16 применить, то, казалось бы, оно
должно было бы и работать, как в плюсах,
но в первый раз такое не позволяет.
Он просит явно с помощью S
сконвертировать.
То есть как-то можно увидеть
чуть-чуть ниже.
Ну, просто чтоб все было явно.
Там могут быть всякие непредсказуемые
последствия из-за этого. Например, вот здесь
было бы еще нормально, а когда
пытаешься скастовать более большой
тип, более маленький, там врезаются
байты, и получается плохо.
Мы можем этого не ожидать.
На самом деле, это то, что иногда раздражает
людей в расте, вот эта вот
слишком большая явность.
Да, кстати, у меня здесь
на самом деле
появляется X, а потом используется Y, который
не объявлен. Ну, здесь
это должен быть X. И здесь
это должно быть...
Да-да, кажется.
Да-да-да.
Да, сейчас. Я просто, наверное,
пропустил строчку. Здесь должно быть
let y у 32 равняется
xs у 32, где-то.
И после этого, если вы хотите
Z из Y сделать, тогда вам нужно S у 16
написать. Плюс есть такая штука
называется Inta.
Она пытается ваш текущий тип
привести к тому типу,
который слева.
То есть это опять же TypeInference.
Он раз попытается понять, к какому типу
вы пытаетесь привести.
И, например, если вы написали let y
равняется xInta и не используете
этот тип, то раз бы не понял,
почему вы пытаетесь привести. А если вы после этого
попробуете к Y, например, присвоить значение
к кому-нибудь y32, то тогда
Rast поймет, ага, ну, значит он после этого
пользуется как y32 этим.
Соответственно, этот Inta должен
перевести y в y32.
В чем отличие?
То есть Inta просто
отдельно не угадываем к какому типу.
Ну, Inta это на самом деле метод трейта.
Это такая штука,
чуть более продвинутая.
И не обязательно пока что пользоваться
на уровне числовых типов. Я думаю, что
даже, наверное, лучше дождаться третьей лекции, чтобы
понять, что это. Это я заранее написал.
То есть, честно, лучше использовать
as, а с более большими
объектами.
Ну, нет, на самом деле
Inta пытается
закастить один тип к другому.
Вот, ну, мы имплементируем как бы
ну, представьте в плюсах, что у вас появилась функция
Inta, которая принимает
на вход, ну, функция класса,
которая берет
ваш текущий объект, класса,
и превращает его в какой-то другой,
возвращает его. Вот Inta
это то самое.
А s это такой
явный оператор кастинга
просто. Он только с примитивными
работает всякими кастами.
И там всякие есть способы
обрезать лидинг зирус.
Еще вот, важный такой момент,
то, что кастинг нетрандитивен.
То есть, у вас может такое
случиться, что если вы сначала
в u1 переведете, а потом в u2,
то это не то же самое, что вы сразу
в u2 переведете.
Это будет явно видно,
то есть, числами типов нет, но
когда у вас будут более сложные типы, тогда уже
может быть совсем неправдой.
Ну, мы это увидим
что-то попозже.
Нет, там будут трейд-объекты,
там сложнее будут s, там на них
тоже работает.
В общем, пока что просто запомните
то, что кастинг это нетрандитивная
вещь.
Примеры будут чуть-чуть попозже.
Почему?
Сейчас, вы еще раз сказали,
что s работает с примитивными
типами.
Примитивные типы
кастуют только всякие числовые типы,
еще всякие трейты, такие вот вещи.
Он не способен
кастовать один клад с другому, например.
Для этого нужно писать
trade-into.
Я, наверное, вас
пугаю, конечно. Trade-into, да?
Никто ничего не понял, наверное.
Все испугались.
Да, ну, вообще, не берите пока что в голову,
это не то, что обязательно понимать на этой лекции.
Если вы не поняли, значит, все хорошо.
Так, еще вот такая вот необычность есть.
Вот мы берем.
Тут, кстати, говорит, ошибка
есть у меня.
Если что, функция maxValue, она
deprecated. Используйте функцию,
то есть двоеточие, там просто max.
Это я опечатался конкретно на этом слайде.
Ладно, потом будет видно.
Тоже будет уже нормальная max.
Deprecated функция, в общем.
Если вы, как субпроводитель,
добавите единичку, ну, тогда у вас, по идее,
в плюсах бы получился
minValue, да?
То есть там минус сколько, там, 2 миллиарда.
Вот. А в расе
вы получите, в случае дебаг-сборки,
по умолчанию, как вы можете заметить,
вот пакет manager.cargo,
да и, в принципе, расе, они компилируют
в дебаг-сборке.
И они,
ну, в общем-то, паникуют,
если такое происходит. Вот в релизе
вы получите, ну, правильное значение,
которое вы ожидаете, скажем так.
Чтобы этого не было, нужно использовать
всякие там saturating cut,
там unwrapped, at и подобное.
Вот, вот здесь нормально уже написано.
Вот, не запоминайте,
в общем-то, вот в эти вот maxValue,
запомните вот это вот.
Это не deprecated, правильно
писать вот так вот.
Ну, смотрите, в wrapping cut мы получаем
один конкретно.
Если мы делаем saturating cut,
то мы, ну, в wrapping это
просто, по сути, мы переходим
даже как и в плюсах все работает.
Saturating это как бы
с английского правильно
перевести, наполняющий, да,
насыщающий, вот так вот.
Он добавляет до тех пор, пока у вас не получится
max.
Потом есть overflowing cut,
если у вас overflow получился, тогда он вернет
вам, ну, то есть он возвращает по факту tuple
из двух элементов.
Один результат суммы, а второй
это boo,
переполнились ли вы.
Ну, как вы видите, этот tuple,
как в питоне, вот,
я его раскрыл.
Ну и assert это такой macros, который паникует,
если внутри него что-то false.
С ошибкой.
В wrapping cut
это просто как в плюсах
начинает все работать, то есть, ну, там идет
вокруг. То есть мы перейдем в
min значение и дальше.
Я надеюсь нормально.
Так.
Ну и, соответственно,
получим в случае с overflowing cut,
то же самое, что с rating cut, но еще
получим результат overflowing
у нас или нет.
А дальше, смотрите, у нас есть такая штука,
называется match.
Вот, мы пытаемся
добавить единичку.
Если у нас,
ну, checked at, это такая штука,
которая на самом деле возвращает
option. Что такое option?
Тоже увидим чуть-чуть попозже на слайдах.
Match, он, ну,
option это такой genum,
который имеет сам значение,
ну, сам value, либо
noun. Сам value,
если у нас вернулся сам y,
какой-то там y, то в таком случае,
ну, у нас такое не может произойти, есть такой
macros unreachable, который паникует,
если вдруг мы до него дошли.
В курсе липовского, кстати, вы могли это видеть.
Каких-то строчков.
Ну, и если
noun, то тогда мы выводим
overflow.
Так.
Match, он похож на switch,
но он на самом деле другой.
Это крутой pattern matching,
который, ну, pattern matching мы сейчас
разберем.
Довольно просто сложно, когда
только начинаешь изучать раст,
очень много концепций, которые друг за друга держатся,
в том числе trait, и вот я не знал,
как это подать.
Вот.
И теперь давайте посмотрим на float.
У нас есть
f32,
и, в общем-то,
у нас по умолчанию кажется
f64 при выводе.
Да, у нас кажется
f64 по дефолту для float,
поэтому x будет f64,
туда мы присваиваем.
Вот.
Так. Ну, и очень важно
писать точку, потому что иначе мы просто получаем
целочистое значение.
Ну, и всякие macros,
non, infinity,
infinity.
Ну, и точно так же есть всякие
sales, sin, round, square root
у float.
Почему там добавляется STD
2.0? До этого мы вроде не добавляли.
Вот это
зависит от того,
заимпорчено это или нет.
То есть у нас
какая-то вещь, какую-то
часть библиотеки раст импортирует
в STD prelude. Это, знаете, грубо говоря,
include prelude.
И prelude это какой-то
набор вещей,
которые используются практически в каждый раз в
программе, и поэтому их не нужно
отдельно импортить.
Можно prelude убрать, но чаще всего это не
делают.
Ну, и конкретно вот эти вещи, они не
заимпорчены, поэтому мы прописываем
полностью.
Так.
У нас
есть Boolean.
Тут все просто. Кажется true.
Не true, скажем так.
И true или не true.
Вот. С этой части
есть вопрос?
Кажется, все супер просто.
А lazy это значит
как?
Ну, то есть если там
n, то видишь, то слева уже 0,
то можно не проверять.
Второе, и то же самое с form, если
левая часть уже 1.
Так. Наконец мы дошли до tuples.
Tuple такая вещь, которая пишется
в скобочках.
Да. Ну, вообще конкретно
это называется compound type.
С нет.
Ну, то есть я
можно, наверное, проверить.
Если сделать struct, например,
там, не знаю.
Сделаем какой-нибудь struct i, ну, структурку
и внутри структурки можем попробовать
создать f32 и 32
и привести его к tuple.
Но кажется, что это не должно работать.
Я никогда так не делал.
Ну, скорее всего, вас так не прикастует,
потому что там непонятно,
что внутри структуры находится.
Вот.
Да, даже, наверное, не прикастует без unsafe.
Вот.
Слева вы
на PR можете видеть, как мы пишем
через запятую типы, а справа, ну, собственно,
значение. Ну, и точно так же
например, деструктуризацию
пары сделать.
У нас есть пара, да, и слева у нас есть
x, y в скобочках.
И соответственно, у нас получится в x и y значение
0, а в y и 92.
Это то же самое, что снизу.
То есть latX
это PR0, ну, PR0
и PR1 это y.
Только есть
тут такой нюансик. Дело в том, что здесь
используется такая штука, называется
shadowing.
Думаю, кажется, на следующих слайдах будет.
Да, там будет про shadowing.
В общем-то,
в двух словах, это когда вы
переменную
затеняете, ну, то есть вы объявляете
одну, потом другую с таким же именем,
первая не диалацируется.
Она просто, по сравнению со
второй,
ну, как сказать,
так.
В общем,
она просто скрывает
другую переменную и используется последняя
из них дальше в коде.
Нельзя как-то обратиться к той?
Ну, сейчас будут примеры.
Обратиться к той выше нельзя?
Нет, такого же. То есть мы
память в добратье
устраиваем?
Там раз будет сам дропать значения,
если, ну, например, в данном случае x и y,
старые нам
не понадобятся, и раз их,
если мы компилируем с оптимизацией, даже дропнет.
Ну, я покажу, там есть примеры, где я
даже проверил это в Godbolt,
что это работает как нужно.
Так.
Потом у нас есть void result.
Смотрите, у нас есть такой
тип, называется unit.
В плюсах. А unit это просто
пустой тюпл, то есть сковочки.
И println
и всякие такие вещи они получают и
возвращают union.
Ну, точнее не union,
unit.
Еще, когда вы объявляете
всякие вещи, связанные
с перечислением тюпла,
то вы можете, например, писать запятую в самом конце.
Вот смотрите, здесь вот battle,
здесь есть запятая.
Ее можно и не писать.
То есть это просто уже на ваше
усмотрение. Но чаще всего удобно.
Так, теперь давайте поговорим
про следование чуть побольше.
println возвращает
unit.
И как бы это аналог void?
Ну да, это аналог void, но только void
в плюсах это вообще просто
отсутствие значения. А здесь это целый тип.
Нет, здесь unit.
Все заменяет.
То есть даже функции, которые не возвращают значение,
на самом деле возвращают unit.
Да.
Вот.
А что выведет этот код, как вы думаете?
Вот у нас здесь
shadow, как вы можете видеть. У нас есть
x равняется 10, а дальше мы там в цикле
если x равен 10, то тогда выводим
if.
Обратите внимание, здесь
в println я написал как будто это f строки
в плюсах. Ну то есть я там
в фигуристых скобочках написал if.
Если что, этот синтакс сейчас появился
буквально пару недель в 1.58.1
расте. То есть самым последним.
Поэтому вот
современность.
Конечно.
Так.
Ну да, он уже
1.58.1 раст будет.
Так.
Ну и вот смотрите.
И дальше x равняется 12.
Казалось бы, это x
заменил на 12.
Ну и как вы думаете, что выведет этот код?
5 раз
выведет
от 0 до
4.
Так, мне кажется, здесь
да
сильно. Ладно, ладно.
А, я понял. Я забыл.
Давайте на этот код посмотрим.
Чтобы вам было видно, я сделал так, чтобы это...
А, ну у меня еще и output
тут неправильный, короче, будет.
Потому что я полностью все обезматил.
Здесь должно быть вместо 10 и 12.
Да, здесь должно быть 12.
Я просто менял несколько раз там положение
принта и такое вот.
Ну, в общем-то, здесь должно быть конкретно в данном случае
0,12, 1,12,
2,12. Ну то есть вы, по сути, правильно
ответили на этот вот вопрос.
То есть, как вы видите, x никуда не девается.
Просто у нас в новом скопе другая переменная.
Вот.
А в ступле можно несколько?
То есть там может быть
быстрее объекты внутри, типа или только два?
Сколько угодно.
Ну, не прямо сколько угодно, до 32.
В ступле объектов
объявите на какое-то имя xxx,
ладно?
В плане let xxx
равняется там, не знаю. Нет, это же
то же самое будет, что let x равняется,
let x равняется, let x равняется.
А плане не сломается? Просто вот
будет значение последнее
под x?
Не расскажу, что вы...
вам нельзя так делать.
А у нас есть объединение
какой-то тюпл?
Ну, вот если мы хотим
в тюпл, давайте третье значение.
То есть, что
мы хотим? У нас есть тюпл.
А, ну, это уже
какая-то вещь с метапрограммированием
уже, по сути.
То есть, мы хотим, чтобы нам
на вход какая-то функция приходила.
То есть, тюпл это не изменяет объекты?
Нет, тюпл это такой тип, у которого
фиксирована длина, все такое.
Если вы хотите сделать новый тюпл новой длины,
то вам нужна уже какая-то функция, которая будет принимать
на вход тюплы разных длин
с разными типами и как-то их
между собой суммировать.
А на другие значения
тюпл можно менять?
Так, ну, если вы объявите мутабельный тюпл,
то да.
То есть, вы напишете, например,
тюпл что-то там и можете написать,
например, тюпл 7 равняется что-то там.
А если его при этом
инициировать
не мутабельными значениями?
То есть, есть два не мутабельных
мута?
То есть, как это должно быть?
Как это должно произойти?
Как должно, я не знаю.
Ну, я просто не знаю, как
такой тюпл даже объявить,
чтобы он был не весь мутабельный.
Нет, в смысле, ну, вот завели там
x и y
какими-то значениями,
а потом объявляется
мутабельный тюпл, который
вот конструируется
из этих времен.
Там муфсимантика в расти есть,
по умолчанию. Там будет передача владения,
x и y будут
не
муфнуться, в общем-то, в этот
тюпл. И, соответственно, у нас будет
нормальный мутабельный тюпл.
Так, ну, это
просто для вашей информации.
Посмотрите, я вектор объявляю
два вектора.
Один 0.1.2.3, другой 4.5.6.7.
Как видите, тут шедуинг.
И потом возвращаю нулевой элемент вектора.
Если вы зайдете на Godbolt, то вы можете
обратить внимание то, что, по умолчанию,
без оптимизации у вас
вектор.
Ну, в общем-то, у вас будет
создаваться, честно, два вектора,
потом возвращаться значение второго.
Ну, то есть точно так же, как у вас
написан здесь вот код.
Если вы сделаете оптимизацию, то в таком
случае вы уже увидите то, что вектор у вас
просто возвращает ноль сразу же.
Ну, то есть у вас буквально там rad 0 просто.
А, 4, извините.
Четверка.
Так.
Потом у нас есть...
Ну, это я уже сказал про юнит.
Он выглядит вот так вот. И у него есть еще
другой способ объявления. Это с фигурными
скобочками. Это то же самое.
Это такой малоизвестный, кстати, факт,
что в Rast это одно и то же.
А еще, если вы хотите сделать
tuple из одного элемента, то вам нужно обязательно
написать запятую после первого элемента.
Иначе Rast подумает, что это просто
значение, которое вы нафига-то взяли в
скобочке. Чтобы ему сказать, что это
tuple, нужно запятую явно написать.
Ну, tuple в памяти
это просто структура
из подряд отущих полей.
Ну, то есть, вот, например, у вас семерка
это int какой-то,
где вот так вот в памяти располагается.
А если у вас 7.263
tuple из двух элементов, тогда у вас, честно, будут
два вот таких вот элемента
подряд записаны.
Так. И вообще, tuple это
zero cost abstraction. То есть, вы можете не стесняться
использовать tuple сколько вам
душа угодно. Они не будут влиять на вашу
производительность. Здесь есть такой небольшой
proof. Он использует указатели,
но не вдавайте с подробностей,
я просто скажу вам, что здесь происходит.
Здесь просто берется tuple
и я беру на него указатель.
Как на
i32.
Точнее, на сам tuple
и на нулевой его элемент.
В принципе, это было видно еще из прошлого слайда.
То, что это один тот же
указатель.
В Python вот видно, что если вы сделаете
tuple и элемент tuple, то они имеют
разные ID-шники.
Это даже разные
типы.
И там происходит боксинг, так называемый в Python.
То есть, это не zero cost abstraction.
Да, это просто на уровне системы
типов. То есть, оно существует только для вас
или для компилятора.
Да, это очень близко к массивам,
только здесь разные типы у tuple могут быть.
То есть, каждый элемент может быть разным.
А он всегда копирует?
То есть, tuple равно
что-то не легальное,
а он не скопирует?
Tuple равно. Смотри.
Во-первых, зависит от ситуации,
что ты там делаешь конкретно.
Во-вторых, да.
Вообще, зачастую RAS, если ты берешь значение,
присваивавшую какой-то другопеременный,
там происходит move.
Move в RAS это просто мен копия.
Ну и на уровне
системы типов,
то есть, где компилятор еще живет,
он помещает переменную неинцелизированной.
Ну, мы это увидим
чуть-чуть попозже в лекции. У нас
будет разговор про ужасный borrow-checker,
который будет нам мешать первое время
писать код, а потом помогать.
А вы можете к этим элементам киву через квадратные
скулочки обращать? Нет, только через точку.
А в некоторых наоборот? Да.
В некоторых массивах наоборот.
Здесь, кажется, у меня получилось
2 слайда.
Потом у нас есть всякие массивы.
Я здесь явно прописал
тип массива. Смотрите, у нас
тип массива это U8
и размеры 3.
Я явно написал 1, 2, 3.
Потом у нас есть
собственно,
я им пользуюсь. У нас есть XS,
у которого я проверяю, что первое элемент действительно 1.
А еще у типов точно также есть всякие функции.
Ну, например, land.
Я узнал, что land это 3.
Потом у нас
можно объявлять точно так же работает
вывод типов, только единственное,
если вы так вот делаете
в коде, то тогда, наверное, лучше написать
какой вы тип
первый хотите.
Смотрите, особенность в том, что
первый раз мы когда объявляли справа
в правой части XS, у нас была
1, 2, 3 через запятую, а здесь
мы объявили 1024 0.
То есть мы через точку запятую
написали значение, а потом сколько раз.
Как, например, на векторе
у нас есть один из конструкторов плюса.
А если бы вы написали просто 0,
а не 0 в U8,
тогда бы раз сказал,
зависит от того, конечно,
как пользоваться им.
Вообще раз бы сказал, что я не понимаю, какой здесь тип.
Если мы перешли точку 0, как мне не так,
то с права ставим 1,
и у нас в крайней части 0,0.
А, это нет, это не произойдет так.
Это будет два разных типа.
То есть с левого будет тип U8-10,
а с правого будет U8-3.
Ему это не понравится.
Да.
В плане,
мы убрали полностью эту часть.
Да, точка запятой.
Ну, то есть сразу же после 3 квадратных скобчика
точка запятой.
То есть не инициализировали, просто сказали.
Но если мы попробуем воспользоваться, то раз скажет,
вы пользуетесь не инициализированной переменной.
И не искомпилирует это.
Сейчас вроде не говорилось, мы можем вообще
не инициализировать переменное?
Да, можем не инициализировать переменное.
Там дальше будет еще такой
сладик с дропфлекс забавный.
Примерно.
Ну, то есть это чуть-чуть подальше будет.
Инициализировать переменную можно, но для ее
использования Rast обязательно проверит,
что вы ее потом инициализируете.
Так.
На самом деле есть еще в Rast ссылочки.
Это на самом деле просто
pointer на уровне
рентайма программы.
Он не может быть нулом,
потому что он обязательно
проинциализирован, он указывает на какой-то объект.
Он гарантирует то, что объект жив.
То есть если у вас есть ссылочка,
тогда объект обязательно живой.
Это одна из важных гарантий Rast.
У нас есть
обычная ссылочка и мутабельная
ссылочка. Точнее, не сама ссылочка
мутабельная, а ссылочка на мутабельный элемент.
Вот так вот. В отличие от плюсов,
мы читаем слева-направо,
а не справа-налево, как у нас в случае с указателем.
По-моему, мне кажется, следующее
пример.
Ну, значит, чуть-чуть будет подальше пример
как читать типы такие.
Ну, вот видите, у нас тут есть x,
i32 с значением 98.
Здесь мы создаем
R это какая-то ссылка на мутабельный
i32. То есть вот мы читаем
ссылку на мутабельный i32.
А это как сишный указатель?
Это как сишный указатель.
Но дело в том, что Rast на этапе компиляции
с помощью системы типов своей мощной
проверяет то, что вы правильно пользуетесь.
И не пропускает, если вы пользуетесь неправильно.
Там есть такие. Есть Vox,
есть RC, есть Arc.
С Arc мы пока что не будем
на них смотреть, но на Vox
мы сегодня посмотрим и RC
на следующей лекции.
92. Тут, кстати, наверное,
лучше было написать mute x,
а не
mute 92.
В плане вот это вот мют.
Мы же хотим сказать, что это
будет смутабельная ссылка.
То есть чтобы типы сошлись.
Получается, вот там был пример,
когда мы возвращаем ссылку на
ременную стеки.
То, что мы возвращали,
ты говоришь пример с Vector,
когда мы возвращали ссылку.
Мы не будем подробно
сегодня разговаривать про ссылки,
потому что там чуть-чуть сложная история
с lifetime.
Есть такая штука как lifetime.
Там вкратце будет
обратить внимание, что lifetime
это ссылочки, вот этот вот скоп.
Мы пытаемся дальше запушить.
То есть продлевать ссылки
нельзя просто, потому что
они не длеваются?
Ну да, их продлеть не получится.
Так, и смотрите,
у нас в плюсах
ссылочки это не first class object,
как говорится.
Ну, в общем-то, если захотим
запушить на Vector, то нам придется
сделать примерно так. У нас есть
reference writer, который из себя представляет
ссылку в какой-то элемент. Ну, такая умная
то же самое, что имперсандик обычный,
но умнее.
А в Rastia можете
спокойно сделать Vector, как вы видите,
и запушить в него просто X,
ссылку на X, и тогда тип Vector
будет VECO от ссылки
на I32. И это легально.
Правда, тогда Rast
естественно должен дать гарантии safety
и будет проверять, что у вас
действительно ссылки эти живут не меньше,
чем Vector.
Но об этом будем говорить чуть попозже.
Вот, кстати, как раз пример про то, как
все это делать, читать.
Указатели у нас еще есть в Rastia.
Они бесполезны
без unsafe, потому что мы их не можем
разыменовывать. То есть вы можете
их суммировать, умножать, что хотите
делать, но если вы захотите по ним пройти
куда-нибудь на память, то в таком
случае вам нужно будет
воспользоваться unsafe. И Rastia
не скажет, ну в общем-то вы сами себя
малейшего сборотина, если вы
прошли куда-то, где память не
нациализирована, не ваша, или что-нибудь такое.
Они могут быть нулами,
ну как можно увидеть, в принципе, на слайде
у нас есть примеры.
То есть в целом указатели не редко ходят?
Да, они
ну, конечно, зависит от того, что вы
конкретно пишете, но вообще очень редко.
Чем более вниз спускаетесь,
тем чаще вам нужно будет unsafe,
но чаще всего он не нужен вообще.
И в частности
у нас примерно в 10 или 11
домашних вообще не будет никакого
unsafe.
Даже будет forbidden, то есть если вы будете писать
слово unsafe, то в таком случае UCI
будет рубить вам код.
Так.
Дальше.
Ну вот смотрите, как это все дело читать.
У нас
в плюсах как читалось? У нас
есть константный указатель
на константный win32t.
А в разности мы будем читать
слева-направо.
То есть у нас не мутабельный,
мют нет, указатель на константный
i32.
Ну то есть не вот это вот арабская магия,
что мы справа-налево читаем, а слева-направо.
А что сейчас?
Ну да.
Ну да.
Да, можно сделать массив массив,
вектор векторов, там чего хочешь.
То есть там
тип просто будет,
внутри тип элемента будет другой
массив.
Так.
Ну кажется
с этим все понятно, да?
С этим слайдом. Нам не особо стоит сейчас
на нем затерживаться, потому что unsafe нам не особо нужен.
И указатель у нас
не будет.
Так.
Ну да.
Это правда.
Так.
У нас в сети будет домашечка,
в которой ему нужно будет написать bst,
причем написать bst без
unsafe.
Ну то есть это будет прикольная штука.
А bst это кто?
BAN research 3, ну то есть какое-нибудь
овейль дерева напишем.
Потому что это на самом деле на расте очень-очень
больно, но это полезно.
Потому что один раз напишете и после этого станете
гуру овнэшипа,
который мы сейчас разберем.
А сколько у нас сегодня домашек будет?
Домашек будет 13, но это далеко не первая домашка.
Не далеко не первая,
она в первой половине, но в конце первой половины.
Перед убийством.
Да, в шаде
тоже такое было.
Там была задачка на bst, причем даже проще.
Там нужно было написать наивное bst,
и тем не менее у людей очень
много плакали в чате,
что сложная задачка.
Так, так, так.
Ну в общем-то у нас есть BOX.
BOX это штука, которая алоцирует память.
Она работает
примерно точно так же, как
Unique Pointer,
только она не может быть null.
Вот конкретно мы здесь объявляем
BOX типа E32,
то есть соответственно алоцируем 92
где-то на куче и возвращаем указатель.
Ну это умный такой указатель.
Объект целый.
Так, ну давайте
пообъявляем всякие функции.
Ну есть самая дефолтная функция,
которая просто пустая,
то есть она ничего не возвращает,
она ничего не делает.
И как вы можете обратить внимание,
как я вам говорил, у нас
ничего не возвращать, это аналог,
возвращать unit, точнее.
То есть объявление функции 1, функции 2
абсолютно эквивалентны.
Это одинаковая функция.
Потом чтобы вернуть E32,
ну вот мы пишем такую
стрелочку, да,
и пишем тип возвращаемого значения.
Да, можно просто без return,
но у нас есть такое понятие как
expressions and statements в расте.
Expressions это выражение,
то есть это какое-то значение, например.
Сейчас мы, ну там кажется
чуть дальше будет, да?
Да, там будет.
Мы обсудим это. Здесь мы просто
возвращаем 0 без return. В следующей строчке
мы возвращаем x, ну можем написать
return тоже самое.
Принимаем на вход x и возвращаем
x.
Потом у нас какая-то другая
есть функция, в которой мы принимаем уже
два значения через запятую.
Обратите внимание, что mute у
у нас, то есть это мутабельная переменная,
которую можно обменять функцией.
Например, x, если бы я точно так же x
что-то присвоил, то Rast бы сказал, что
переменные не мутабельные нельзя.
Честно при этом,
ну то, кто передал y,
не заметит это.
Ну,
у нас, кстати, в Rast все с этим
делом прекрасно, то есть
конкретно U64 это такой
тип, который копируем, то есть если вы
передаете U64,
то он просто скопируется функцией.
Естественно, этот человек не заметит
этого.
А если кто-то
с более сложной какой-то структурой
придет, ну то есть с более сложной объявления,
то у нас там есть понятие
ссылки, то есть мы будем принимать по ссылке точно
так же, по мутабельной ссылке
и по значению.
А если
U64 меньше?
Ну, то же самое
будет копироваться, U128
будет копироваться.
Там зависит от того, имплеметировать
ли тип трейты, клоуны,
копии, мы чуть-чуть попозже про них поговорим.
Пока что у вас все прекрасно, у вас простая
домашка будет, на этот раз у вас все будет копироваться.
То есть вы
не заметите разницу с плюсами.
А потом уже будет
ну, будете натыкаться на всяких приколах.
А вот когда вам передает функция
объект надCMove, что он
по ссылке передавался?
Не, для того, чтобы
если вы хотите передать по ссылке,
то нам нужно быть явно, например, написать
вызывая функцию, там нужно будет написать
например фанк3 и там нужно будет
фанк4
А там нужно будет явно написать &x
если бы это было по ссылке. То есть мы будем
прям видеть, вызывая функцию,
что вот мы ее по ссылке передали.
Это значение.
как вернуть?
унит вернуть?
ну можно вот например вот здесь
если бы здесь был унит
тогда можно было здесь тоже скобочки просто написать
или return скобочки
то есть точно такое же значение
да, это просто объявление
по сути
пустой структуры
ничего не вернуть
ничего не вернуть нельзя
в расе всегда возвращается унит
вы этого даже не замечаете
в случае первой функции
унит вы не видите, а он есть
что с точки запятой здесь?
что с точки запятой здесь?
это хороший вопрос
вот здесь вот
expression sustainments
это вот сейчас со следующего слайда
вот return вот конкретно вот здесь вот здесь
это на самом деле правильно
вы в расе можете и то и то сделать
он разрешает
именно в return в смысле?
да, да, да
если вы здесь что-то не напишете
то он на вас пожалуется
давайте теперь
поймем, что такое expression sustainments
дело в том, что у нас в расе
всякая строчка является
значением, каким-то выражением
например какая-то функция, которая даже
ничего не возвращает, это на самом деле
штука, которая возвращает кругло скобочки
даже ив, по умолчанию, возвращает
что-то из своего скопа
если вы напишете точку
запятой в самом конце, то это будет означать
что он возвращает значение вот этой строчки
вот, например, конкретно в данном случае
у икса будет значение
y плюс 534
сейчас, а тогда
если вот функция
мы не написали return
но возвращаем значение и поставим точку запятой
в профильку
по масштабу предыдущий слайд
вот func
6
если мы поставим точку запятой в конце
тогда функция начнет возвращать
унит
потому что точка запятой означает, что вот эта фигня
стала унитом
то есть это стала стейк
то есть у нас случится ошибка из того, что мы написали
что мы возвращаем u32
да, он скажет mismatch types
типа у нас ожидался u32
вернулся унит
так
кажется, на этот слайд мы посмотрели
очень прекрасную офичату
что можно написать vx, сравняется if
и там
по выбору слева или справа
какое-то значение
1 или 2
нет, y плюс 534
у меньше 42 не правда
соответственно, мы пойдем в вторую ветку
и иксу будет присваиваться значение y плюс 534
а если одна из частей
не expression, то он ошибку выдаст?
что еще?
если одна из частей не expression, то он ошибку выдаст?
например, если ты напишешь точку запятой
то он скажет, вот здесь
возвращаешь u32, вот здесь возвращаешь unit
что-то не то
то есть так нельзя
да, то есть вам важно то, что
у вас в скопе
фигуристых скопков
я думаю, что x обязательно в этом итоге
должен получиться
одного и того же типа, вне зависимости
того, куда мы пойдем
он должен иметь конкретный тип
можно
в этом ифе, кстати, можно сверху
произвольную логику, например, написать
то есть, что хотите
хоть в BD обращайтесь за этим иксом
а if в ифе?
да, это тоже можно
главное, чтобы у вас возвращалось значение
нужное
то есть, вот если вместо
345 напишем if
то он автоматически
у него будет значение
то есть, вот если вместо
345 напишем if
то он автоматически
да, если вы напишете
if true, return 1
else 2, то в таком случае
у вас там вернется единичка
из этого ифа, и соответственно
из этого всего скопа вернется тоже единичка
а вот чтобы иметь значение
я могу по одному строчку
да, можно написать в одну строчку
но при этом
без скопок нельзя
да, фигурные скопочки обязательно
так
мы дошли до того, что теперь нам нужно объявлять структурки
что-то более сложное
есть какая-то
такая примерная структурка у нас
у которой есть два поля
operCount, которая у size и date
которая i32
опять же, обратите внимание на то, что я здесь тоже написал запятую
вот, то есть, это запятая
ее можете не писать, а можете писать
по желанию, раз вам разрешают делать так и так
ну, чаще всего удобно
и очень-очень важно
вы не можете рассчитывать
на то, как у вас Rust в памяти
типы расположен
даже вот такой банальный пример
у вас есть структура A, где X это экземпл
и структура B, где Y это экземпл
и дело в том, что Rust вам не гарантирует
то, что в памяти эти два типа будут
одинаково располагаться
то есть, там могут произвольно быть перемешанные
поля и что угодно
и даже более того, тут если я напишу
X тоже, то есть даже названия совпадут
все равно Rust
по барабану будет оптимизировать так
ему больше нравится
это на самом деле то, что мы даем меньше
гарантий
оно нам позволяет больше оптимизировать
кода. Соответственно, Rust
потенциально гораздо быстрее, чем plus
например
все же тоже не гарантирует
да, можно сейчас посмотрим
тут
такой прекрасный вопрос про скорость Rust
Rust
на практике оказывается
чуть-чуть медленнее, чем plus
обычно, но это
мне кажется все равно временно, потому что
Rust за счет своих сильных гарантий
позволяет оптимизировать гораздо сильнее
например, на окосе вы могли слышать
про такое понятие, как aliasing
и вот эти все ссылки
которые мы только что рассмотрели, они одновременно
дают гарантию, что у вас
будет сколько-либо немутабельных ссылок
либо одна мутабельная
если вам дали две мутабельные ссылки
то в таком случае вы
можете быть уверены в том, что они указывают
на два разных объекта
и соответственно вы можете
оптимизировать соответствующий код
напомните, пожалуйста
я забыл как там это называется
когда указатель
гарантирует то, что он ни с кем не пересекается
еще раз скажи
да, restrict
по сути Rust в свое время
я даже включил эту фигню
когда он начал во все указатели
фигачить restrict в LVM
и за счет этого
код
конечно стал быстрее, но дело в том, что выплыл
еще одновременно огромная куча багов
в LVM
и пришлось это
то отключать, то включать
то есть они говорят пофиксили в LVM
отключают Rust, опять находятся новые ошибки
отключают
просто
потому что на самом деле все
такие вещи
не включаются и соответственно
они
плохо протестированы
я кстати думаю, что
я думаю сейчас
дойдем до Borrow Checker и наверное
отдохнем чуть-чуть
но это быстро
есть семинар
типа две лекции
по приколу можно взять
давайте добавим некоторые методы
как раз был вопрос про то
можно ли добавлять методы
для этого есть ключевое слово impo
implementation
давайте имплементируем экзампл
давайте добавим функцию new
которая является конструктором
она является ассоциированной
мы сейчас увидим, как ассоциированная функция работает
ну плюсов если что это статик функции
статик функции
плюс ко всему
то, что я назвал ее new
это очень широко распространенное
соглашение в Rust
то, что у вас конструктор
самый обычный, дефолтный
должен быть, должен называться new
пустую структуру, например
потом вы можете увидеть такое вот
с большой буквы self
если что, это означает
что вы сюда должны подставить
текущий тип
конкретно текущий тип это то, что написано там в импл
вот написано example, значит self
это просто алиас на слово example
то есть здесь на самом деле
возвращается example
можно написать example?
да, можно
а что еще раз работать?
ну типа если там в example мы объявили еще какую-то структуру
типа вот сейчас мы
объясним конструктор
структуры
в плане мы структуру структуры объявили?
ну там же тоже будет
example возвращаться
или ты имеешь в виду какие-то темплейты?
нет, в плане структуры мы еще одну структуру объявили
и тот конструктор
а не структура описывает
там же импл поддельная
так
сейчас вы говорите
self это просто алиас
на тип example
который у нас сейчас есть и все
то есть вы можете его спокойно использовать внутри
блока импл
это достаточно удобно
еще его можно использовать
кстати говоря слово self ключевое
в блоке struct
то есть struct example я бы мог написать
опер count
если вы напишите правда просто self
то у вас бесконечного размера структуры
потому что у вас там будет
example сам себя вкладываться бесконечно
еще что можно
можно тоже использовать слово self
то есть в объявлении структурки
с большой буквы
ну смотри
например пусть я опер count сказал
что это box от example
а теперь я могу
example написать просто self
это тоже удобно бывает
как-то у нас поле в границе
массив самого себя
сейчас поле хранится
ну вот например был
с боксом
я привел
в пример именно бокс
потому что у нас есть одна проблемка здесь
если мы
напишем просто self опер count
тогда у нас структура будет бесконечного размера
она будет сложена
то есть у нас это раскроется в даты
и в общем-то
так нельзя делать но Растов
даже не предупредит
они скомпилируются
еще вы можете обратить внимание
на ключевое слово pub
то есть публичное
пока что во всех домашних везде
вы будете писать именно это слово
оно означает то что оно
публичное его видят все
все функции
все структуры внутри
этого модуля
что такое модуль мы пока что не знаем
пока что вы можете просто писать pub
и воспринимать его как public
в c++
просто
подробности по тому как это работает
и всякие там super
namespace этому все рассмотрим на лекции
покарга
не берите пока что в голову просто пишите pub
вот мой вам совет
потом есть
у нас функция push какая-то
и она внезапно на этот раз принимает
мутабельную ссылочку на self
это означает что она не ассоциирована
то есть например если у нас будет
какая-то
какой-то тип
ну какая-то переменная которая имеет тип
example то в таком случае
вызывая на ней push
вы сможете через точку
вызвать на ней push и вы сможете
мутировать эту переменную
вот
ассоциированность объединяется на вечер
все в качестве перелома
да
здесь еще
помимо этого вот
example если что у нас
upper count plus 1 data push
все такое
еще кстати забыл сказать
вот здесь смотрите есть
self.uppercount это для того чтобы обратиться
к своим полям вообще-то я вспомнил
это на Python уже похоже
в Python мы тоже самое делаем
еще да
да все правильно здесь
снизу и сверху включаются
сейчас self
вот self с большой буквы это просто текущий тип
а self с маленькой буквы
это текущий
короче грубо говоря переменная я сам
да
а раз додумал бы сейчас
self это зарезервированное слово
да это зарезервированное слово
так ну и вот еще помимо mute self
есть просто self
то есть это
смотрите да это у нас был просто метод
а теперь вот по сути const метод в плюсах
ну то есть вы же знаете например что
векторик когда вы называете length
или size
то в таком случае у вас в пишется const
при фигурными скобочками чтобы показать что
это не мутирует вектор точно так же
просто ссылочка на self это что-то что не может мутировать
если бы я здесь попробовал что-то
запушить то я бы провалился
потому что раз обратил бы внимание
я пытаюсь мутировать текущий объект
хотя он у меня есть только в redone режиме
так
потом есть it self
ну здесь
вот еще можно помимо того по значению
принимать
на самом деле это не совсем как в плюсах
работает вы ожидаете например того что
вы скопируете
элемент да ну например
если у вас есть в плюсах есть функция
которая принимает на вход STD вектор
то получание передаивая вектор
у вас он скопируется
но
в расте вы
по получению мовните туда то есть
сделайте то же самое что и стд мов
передадите владение
нет нет
self это такое особенное ключевое слово
ну да
ну в плюсах вы не пишете self
например вообще у вас там статик
если только написать чтобы ассоциированные функции
сделать в получении она функция класс
как бы вот
а здесь
в плане статичная
ну мы сейчас увидим
как она используется
вы сейчас сказали что
во всех функциях по получению
вы не копируете
нет все у нас
все по молчанию
в питоне же
ссылки
там тоже
я не помню как это работает
маленькие объекты копируются
огромные листы они там по ссылке
идут ну в общем
в питоне вообще не очевидно
а в расте наоборот все очень строго и классно
мы это посмотрим потом
а сейчас
сейчас
self маленькая
подробно
это просто указатель на себя
давай я перейду к примерам и мы как раз увидим
что это значит
на предыдущем слайде
там же
вверху был комментарий что у нас
ассоциированный, смотри, self здесь нет с маленькой буквы
а ассоциированный
то есть она не является функцией класса
давай все таки к примерам перейдем
если мы добавляем self, то это уже не эстетическая функция
да, это функция класса
вот смотрите здесь я
объявляю x это example
какой-то мутир
x который мутабельный
я его объявляю как operCount
0 и data это какой-то
новый вектор
еще насколько вы помните я
создавал функцию new, которая была ассоциирована
как видите я могу ее вызвать вот так
через
два двоеточия
и потом есть еще
xpush10
это то что вы можете
заметить за self
если бы здесь я не написал
mute, то в таком случае я бы не мог сделать
xpush потому что мне бы пришлось передать
мутабельную ссылку
раз не даст такое сделать
потому что
примерно не мутабельная, мы пытаемся мутировать через push
тогда
вот вторая и третья строчка
это гарантия на порядок
учтения
на порядок индициализации
кажется что там есть
там есть сейчас
гарантия на то что они обязательно
нативизируются в том порядке в котором есть
но там сейчас пока что это все дело плавает
давай я не знаю
закину тебе там rfc наверное
как-нибудь в личку
это
как работает
очень много раст кода
по умолчанию раст не давал никаких гарантий
и он их все еще и не дает
но по факту он их всегда
индициализирует в одном и том же порядке
в котором они написаны
и так как
очень много раст кода на это полагается
в итоге появился rfc
давайте мы это стабилизируем
пусть они всегда в таком порядке
честно говоря
я следил за тем какой он сейчас
статус у него
то есть возможно его уже приняли
и сейчас они уже в каком-то порядке
в определенном
гарантированно индициализируются
но лучше на это не полагать
вообще что-то мы задаем кто-то
раст или нет
думал о том что он создан на стеке
у нас есть вообще такие понятия
да у нас есть понятия есть так и куча
то есть вот эти две структуры у нас там
да смотри
example сам находится
на стеке
все поля вектора
будут тоже на стеке внутри example
а буфер вектора
будет находиться уже на куче
там внутри будет какой-то указатель
который будет показывать на кучу
в получении у нас все
в расте как в плюсах все на стеке
там достаточно явно
все работает с кучей
ну и тут
upper count который бы сработал и без mute
над x
еще в ассерте
так все ли
с этим понятно
можно перегружать метод
кстати вот тоже хороший вопрос
можно ли перегружать метод вообще перегружать
методы нельзя в расте то есть вы делаете
это специально сделано чтобы вы
не делали там 50 реконструктора
и потом плакали у вас например
в векторе если вы хотите создать пустой
вектор то у вас век new
если вы хотите создать вектор с преалацированной памяти
то вы пишите век vifcapacity
то есть там бы вместо new было написано
vifcapacity в скобчиках написали с каким capacity
то есть все чтобы было красивенько и явно
ну такой язык очень
то есть за счет того что какой конструктор
это идеальная функция
не ну new
раз на самом деле ничего не знает про то что
это конструктор это просто такое соглашение
что new мы называем какие-то конструкторы
которые возвращают self
сейчас а если
в экземпле
мы же можем
заводить в экземпле переменные
или ты имеешь ввиду переменные
в скобке которые вот где выше
вот тут вот
нет не можем
это просто такой блок который означает
что здесь вот имплементация экземпля
оно относится к экземплям
а еще вот про мутабельность
ну вот у нас сейчас был
с мутабельностью
ну то есть мы бушили
в настоящем снаряжении
сейчас
ну в общем мы
структуру
которая объявили
не мутабельной можем
изменить ее поле
не мутабельной изменить ее поле
нет не можем, не ну вообще по факту
если вы пользуетесь unsafe то можете
то есть вы можете
unsafe вообще вся гарантия
не выбирай
это такое я вам могу скинуть
чатик в этом мем скрабом которому выдают
пулемет
он может сделать все что угодно
в своем случае, ну лучше не делайте
да да мы не можем мутабель
делать
сейчас подожди точка
рет
там есть
в расте
два трейта есть там
индекс и индекс мьют
не разбирайтесь
то есть одно вызывает в одном случае
другое в другом
так
давайте мы теперь дженерики напишем
в отличие от плюсов нам не нужно писать
просто слово template мы просто пишем
такие астракты example и
в кавычках такие вот
и пишем прежде что мы
дженерик по т
теперь
если мы будем дописывать
в импл какие-то
какие-то типы
мы дописываем фигурный скобчик
te в импл и в example
кажется что это как-то перебор
писать в двух местах
на самом деле ответ наперед просто у нас там могут быть
всякие дженерики у нас
могут быть имплы трейтов для
структуры и там уже
специализация это вообще
другая тема там
забудь про нее пока что
вообще это
сделано для того чтобы в импл вы написали все
аргументы по которым вы дженерика
после этого их расфасовали
и все
так
импл и экземпл да да да
такое может быть запросто
то есть особенно если у вас там какой-то
трейд имплементироваться у вас там будет
импл те у допустим у вас там
экземпл те
у может быть
такое разразенное типа
импл это просто почему вы дженерик
после этого расставляете
если вы не понимаете что такое трейд
то забудьте пока что
пока что примите как данность
вот
здесь вот так вот принимаем
на вход экс как т
точно так же его пушим то есть вообще
ничего не изменилось
вню
просто создаем вектор
ну вот через self
да это ключевое слово
ну вот это вот
тут правда чуть-чуть отличаются цвета
но это же не моя беда
беда
латехного мента
который не умеет подсвечивать
ну в общем это два ключевых слова
и здесь кстати говоря self будет просто
экземпл те
то есть self это экземпл те
да то есть
self равно экземпл те
то есть это алис на
вот это вот название
а вот это
сейчас где
а тип
век это какой-то стандартный вектор
или это какой-то
он находится в стандартной библиотеке
он импортирован по умолчанию
это обычный вектор как в плюсах
а мы в него не придаем тип его элемента
просто у нас же сейчас
он его выводит автоматически
раса умеет выводить
да, то какой тип век
да, здесь будет тип век те
просто раз он понимает
вот, видит так, ага, значит у нас
дейта это век те, значит когда мы создаем
век нью, значит это век те нью
вот и все
ну и дальше кажется
это мы
посмотрим еще
то есть у нас импл без
структуры не может быть
да, у нас не может быть
простого импла, мы можем
ориентировать только структур
либо трейд для структуры
а можно как-то в одном месте сделать
типа если я хочу
ну то есть
у меня есть структура
у нее должны быть функции
но
ну как бы
не хочется это в отдельное место переносить
то есть сейчас, я так понимаю, нужно писать
сначала объявление структуры
потом объявление импла
а как-то один в одном
вообще, кстати, можно и наоборот
насколько я помню, Rast
он просто не плюсы в этом смысле
ему пару барабанов в каком порядке объявлять
переменные
в любом случае должны быть два текста
структура и импл
можно, кстати, без импла
если вам просто нужна структура, можно без импла
я в чем вопрос?
нужно структура с функцией
ну как обычно классно писать
нет, тут в Rast
в OOP такого OOP нет
то есть тут вот так все устроено
на самом деле это даже прекрасно
что тут такого нет
потому что это немножко упрощает жизнь
еще вопрос
мы сейчас инфинитируем
экземпл с шаблоном
generic, а для него структура
с этой структуры должна объявлять
generic
в плане структуры должны объявлять generic
у нас
импл T и экземпл D
значит, должен быть
соответствующая структура
ну да, экземпл T
должна быть
которая такое объявление имеет
а мы можем
мы можем структуру без шаблона
инфинитировать
структуру без шаблона
инфинитировать с шаблоном
то есть структуру хранить
я не очень понял концепт вопроса
а что значит имплементация с шаблоном
без шаблона
методы
можно написать
pub, fn, u, T
и там внутри уже использовать тип T
но он будет присутствовать
только внутри этой функции new
только внутри new
а тут у нас же по сути
то же самое
не, не то же самое, здесь T, у нас все
то есть T виден везде
и у нас generic все функции
то есть и new generic, и push generic
спецификация generic есть вообще?
а что значит спецификация?
то есть я хочу имплементировать
другого для inta
имплементировать generic
для inta?
функция push у меня для inta
а, специализацию ты имеешь в виду какую-то?
нет, такого нет
нет
ты конечно можешь сделать
здесь push
да, ты можешь делать так
на самом деле можешь
ты можешь написать импл T
в R и там нужно будет использовать
трейтер для того чтобы отсечь все
кроме I32, например
а потом в push написать
то есть написать еще один импл, где T
в R, T, I32
но это нет в программе
ну да, там выйдет блок в R
на следующей лекции поговорим об этом
такие примерно вещи
можно делать
то есть что-то типа перегрузки
для разных типов по-разному
писать имплементации
например, для вектора, если у вас тип имеет
нулевой размер, то на самом деле вектор
это просто счетчик
то есть на самом деле там нет никакого буфера
ну зачем действительно, если у вас тип
нулевого размера, хранить вам буфер
давайте этим воспользуемся
добром, что мы сделали
у нас есть экземпл I32
заметьте, я вот
написал тип вот так вот I32
и указал
опер каунт, дейта
чему равно
можно написать еще слева тип
let mute x, двоеточие экземпл I32
равняется экземплу I32
ну раз тут и так все выйдет
то есть не нужно этого делать
потом есть
Y, который у нас объявляется
ну у нас есть new
у нас есть такой синтаксис
два двоеточия и скобочки
он называется turbofish
это на самом деле некоторые достижения
Rasta, потому что в отличие от плюсов
за счет этого вам не нужно
вы легко отличаете между собой типы
и сами функции
это позволяет несколько раз
не парсить файлы
и дальше давайте мы посмотрим
ну вот
без двоеточий не скомпилируется
ну или в плане ты имеешь в виду Y
где, если я двоеточие уберу
где-нибудь вот тут
без этого не скомпилируется
то есть ты как бы экземпл, потом говоришь
я имею в виду экземпл, который вот такие от
генерики, а после этого вызываешь на нем new
сейчас, а вот это два объявления Z
они полностью эквивалентные
да, они
полностью эквивалентные, кстати говоря
в этом только вчера, если честно
я просто чисто случайно написал два двоеточия здесь
я выяснил, что конкретно в этом вот случае
но не в этом, вот в этом случае
вы можете типы эти два одинаковые
ну короче, просто выяснять, что
это две одинаковые вещи
ну точно так же
пушим, смотрим на аутеркан, все работает
здесь у нас такой
генерик тип, где можно кроме E32
еще что-нибудь запустить
потом, ну давайте
собственно посмотрим
на E, while, for и подобные вещи
у нас есть
примерно X
мутабельная, которая равняется двум
потом если X равняется двум, вот мы что-то делаем
их мы в принципе уже видели
я кстати не обратил ваше внимание, но вообще
в эфи, как вы могли заметить, мы скобчики
не пишем, это особенность
раз-та, то есть в плюсах
например, вам нужно это делать, раз-те не мы
while то же самое
то есть на условии не нужно ставить скобочки
ну тогда
компилятор скажет, что-то у вас код ставил, хромает
варнинг выдаст
то есть скомпилирует, но скажет
уберите, пожалуйста, скобочки, желательно
не надо
это
на самом деле особенная функция, которая называется
накросы, их можно пока что
воспринимать просто как функции
на самом деле они кодогенерацию производят
не давать подробностей
потом у нас есть луп
то есть у нас был while, а есть
раз-те луп, у которого нет условий, который
просто крутится
он крутится до тех пор, пока
не произойдет return, break
или вообще
никогда не возвращается
ну смотрите
сейчас, ну да, это while true, но
только на самом деле чуть хитрее, потому что
ну сейчас объясню, там
оптимизация компилятора есть
в общем
как вы видите, конкретно луп
ну break здесь происходит, мы из него
выходим, все нормально, то есть вроде бы понятно, что
этот код делает, можете обратить внимание
на то, что точку запятой нам тоже не обязательно ставить
точно так же, как и в return в случае break
и мы еще в раз-те умеем
возвращаться, брейкаться с значением
это прям то, аналога чего, нет вообще
в плюсах, мы можем возвращаться
с значением, конкретно вот эта вот штука вернет
20, то есть мы какой-то создаем
каунтер, а потом result присваиваем значение
loop и loop
в свою очередь там какой-то каунтер крутит
до 10 и возвращает
каунтер на 2
видите, break, каунтер на 2
и вот получается, что
loop это точно так же expression, который
вернет какое-то значение
так, всем понятно?
все еще можно было loop
но на самом деле
это не одинаковые вещи
сейчас еще чуть-чуть дальше буквально
return у нас с функцией возвращается
а break у нас с цикла
или if
из if он не возвращает
то есть if это просто if
что значит брейкнуться из if
то есть здесь будет
возвращаться внешний loop
а еще мы еще одна вещь
что-то типа gota
но это на самом деле не gota
оно существует только для циклов
мы можем выходить из внешних циклов
мы заходим в какой-то цикл
наш loop там внутри какой-то
от 0 до 10 еще один for
мы заходим
внутренний цикл
и потом возвращаемся, смотрите
break outer, то есть возвращаемся в outer loop
вот, соответственно мы выйдем вот сюда
ну и наш код выйдет
entered the outer loop, entered the inner loop
и потом exited the outer loop
вот это вот
3 outer
ну это просто специальный синтаксис
для таких именованных
да, ну там
конечно в рамках разумного
не помню точно какие там уже
буковки можно писать конкретно
да, кстати
тоже в прикольный момент
Rasta вообще поддерживает для названия всяких переменных
всего такого полностью UTF-8
так что вы можете
какое-то время назад, кстати, была шутка
совсем недавно
вы могли использовать, эмоджи нельзя
запрещено вообще
но они сделали компилятор, специально там
запушили такую фичу, что если вы в качестве
идентификатора используете смайлик
крабика, эмоджи
то в таком случае раньше
Rasta писал нельзя использовать эмоджи, а теперь он пишет
ferris нельзя использовать как идентификатор
ferris это если что
москот языка, это то что вы видите
в чате курса у нас эти крабики
которые танцуют в кружке
ну то есть вы можете написать там
не знаю, я люблю 1s
на русском
и вот прекрасно быть
я 1s программист
так
ну и наконец for loop
смотрите, у нас есть такой прикольный
синтаксис range
вот у нас и здесь будет
итерироваться от 0 до 10
то есть здесь вот невключительная
не включительная итерация
этот синтаксис специально он создает
range какого-то типа
то есть он там сам выведет
i32, size или что-нибудь еще
конкретно в данном случае здесь будет
i32
если вы допишите еще равно
то в таком случае у вас будет
включительно, то есть второй цикл выведет
все от 0 до 10 включительно
еще вы можете например
захардкодить какие-нибудь
массивы
от 1 до 4
и выводить
то есть также можно например итерироваться
по вектору, еще сейчас увидим slice
и подобным еще
так
потом есть for loop
значит так
for loop
это по векторам собственно example
как это можно сделать
ну вот мы создаем вектор это
1,2,3,4 и вот мы здесь итерируемся
по нему, по ссылке
а потом дальше мы
итерируемся по вектору еще раз
он выведет то же самое, но разница в том
что вот в этом вот случае
мы moving вектор в интерцикла
мы сейчас разберемся
что такое boring
я просто заранее говорю, что можно написать ссылку
mute ссылку
или просто вот
писать по значению
то есть это все нормальная вещь
так и очень прекрасная такая фича
rasta, которую вы наверняка полюбите
в расте есть янамы
янам
ну вот смотрите у нас есть first, second, third
и так далее, какой-то янамчик
ну и второй янамчик
которому мы даже смотрите объявили
даже template, то есть мы можем конечно
не объявлять их, можем объявлять
и в скобочках написали
что из себя представляет
вариант этого янума
то есть это по сути уже будут какие-то типы
вот и снизу я создаю x, который
my-yenam-first
и y, который
my-yenam-first
я просто написал явно, что
чтобы иметь тип my-yenam
значение конкретно my-yenam-first
ну и z это соответственно
создание другого янама, который
из себя представляет какое-то чиселка
и дальше
ту самую структуру q-example, которая у нас
template-ная, мы
инициализируем и пихаем внутрь янам
в плане
ну на самом деле
раст по получению не дает циферки
по получению раст не дает никаких циферок
на это все, можно конечно написать
first равняется один секунд, равняется два
third равняется три, то есть конкретное значение
но раст по получению
просто мы у янам делаем
это все
потому что на самом деле это не структура
это штука, которая
может принимать одно из возможных
значений
то есть в конкретном данном случае это либо
tuple-i32, либо tuple-u64
example-t
янам примет значение
ну и там он умеет
внутри определять, какой он
какой-то значение
ну и там он умеет
определять значение
ну и там он умеет
он умеет внутри определять
какое он сейчас именно значение имеет
ну какой вариант у него
это одновременно юнион и янам
мы сейчас сравним
после i32
это тоже tuple будет
дело в том, что это специальный синтакт
так работает
если что
если бы мы хотели что
если вы захотите
обратиться к первому элементу
то напишите
допустим у вас
z это one more yinam zwei
если вы захотите обратиться к первому элементу
то напишите z.0
ну и точно так же
если бы это был ein
я имею ввиду, что
ein это tuple или нет?
ein это tuple
к нулевому элементу нужно обращаться
но чаще всего этим как tuple
мне конечно не пользуется
сейчас увидим как это делается
наконец-то мы дошли до того, чтобы
я вас испугал опшеном когда-то
в начале лекции, вот он как выглядит
очень-очень простая структурка, но при этом столько мощи дает
они предназначены
для error handling
преимущественно
например, если вы в векторе хотите
взять какой-то элемент
по индексу
если у вас индекс выходит за рамки
то вы хотите наверно
вернуть что-то нормальное
то есть сказать, что нет значения
или если есть само значение
вот опшен говорит, что у вас либо
какое-то значение, либо ничего
если вы знакомы с функциональными языками
то там вы могли знать про maybe
maybe как раз там
ну и есть еще
result, result это
просто наперед показывают, есть такая штука
которая может либо иметь значение
либо типа ошибки
например, если вы читаете
из какого-нибудь файлика
то вы можете вернуть, например, либо
прочитанные байты, либо
код ошибки
то есть вы просто посмотрите, что из этого
получили, ok или error
а то, что вот как раз
включается про runtime было
то, что мы можем все
заменить, все exceptions
result
в плане не сейчас
в начале лекции говорили, что это не runtime
за исключением того, что
когда мы используем банки
мы вокруг них
добавляем runtime
ну да, там же stack unwinding это точно
так же как в плюсах, мы идем в ноль
то есть ну
до самого конца, до мейна
и там мейн сам нужно обернуть
для того, чтобы словить этот unwinding
вывести пользователи сообщения и уже
выйти с ошибки
соответственно можно все банки заменить на обработку
результатов
ну да, да, ну как раз для того предназначено
чтобы грамотно обрабатывать ошибки
то есть если нам выпала
ошибка, чтобы мы могли, например, ее красиво
проигнорировать, либо если ошибка
там еще что-то сделать
это будет очень хорошо видно, наверное, дальше
и плюс когда вы будете решать домашнее задание
как это работает
так
match это, наверное
это единственный способ
за счет которого вы можете выяснить
о какой же все-таки сейчас текущее значение
у янама
например, если вы захотите узнать
first ли значение у янама, то вы можете
в будущем сможете воспользоваться еще if
сейчас узнаем как это
либо match
вот
как это работает, смотрите
мы матчем X
он, если он
на янам first, то мы вводим first
если second, то там
выводим числа от 0 до 4 и еще
second сообщение
и потом, смотрите, есть такой специальный значок
который мы уже встречали, underscope
нижнее подчеркивание
он матчит вообще все
то есть раз, то он буквально
просто берет такой и проверяет
каждое значение по отдельности
но матч только с янамами работает
или с произвольными типами?
с произвольными типами, даже с sentami работает
сейчас посмотрим
а он останавливается, когда
находится в падении?
да, находится в падении, там не нужно как в плюсах
switch a break писать
он уже все знает раз
то есть вот нижнее подчеркивание
это только
если он выше всего
да, читайте, это placeholder
для дефолтного значения, то есть все остальное
тогда правда же, что мы можем
все что угодно, вот так вот читать
будут матчи, если у нас x
не маги нам
что бы мы могли больше передать
а если это не так
ну раз, это проверит на уровне
системы типов и скажет, что нет
вы что-то не то матчите, более того
матч, он проверяет то
что вы действительно поматчили всевозможные
значения, то есть
если у вас там будет second, third
fourth и так далее, то
если вы удалите вот это вот дефолтное значение
то в таком случае вам расскажут
а вы еще два значения как-то не заматчили
и у вас в коде
может быть, не знаю, уб или что-нибудь такое
если другое
код просто first
в данном случае просто first
ну можно поиграться там, написать second
например, или что-то еще такое
то есть
раз одновременно
проверяет, что
все что мы указали
мы указали
вместо Maya Nam quest
что она тоже часть того
типа, что имеется
ну он просто знает, где матч, что он матчит
Maya Nam
то есть, соответственно, он ожидает
увидеть всевозможные варианты Maya Nam
давайте чуть-чуть подробнее
про Underscope поговорим
он называется еще
забыл как раз такое слово, замечательный
Weald Card, он матчит все
вот смотрите, вы конечно не знаете
что такое Collect еще
ну вообще эта вот штука
ну вот от 0 до 10
есть range, потом вы его захотите
заколлектить, Rust может это делать хоть даже в hashset
вы что хотите вообще
то есть там
главное указать им
во что он будет коллектить
формально
то есть, забегая наперед
говорю, что там нужен тоже trade
другой он называется fromiter
для того, чтобы Collect работал
в общем-то нам нужно указать
что мы конкретно в вектор хотим собрать
все эти значения
и обратить внимание, я указал что вектор
но не указал какой тип
и раз такой понимает, ага
он мне дал Underscope, значит мне нужно самому
что-то с этим сделать
и он после того, как я сделал
век push 42.u64
он понял, ага, значит он хочет вектор u64
и сам вывел тип
а если бы мы не указали
эти скопки
да, он бы сказал
что-то такого типа нет
укажите, пожалуйста, там template
да, еще
если вы будете
Unused variable делать
тогда Rust
нижнее подчеркивание x
оно говорит о том, что x не используется
и при этом
Rust скажет вам, что
без Underscope он выдаст warning
а с Underscope варнига не будет
все нормально, не используется x
и ладно
то есть это способ пометить переменную, что я ее дальше не использую
хоть она и объявлена
полезно иногда функция бывает
еще он может несколько
одновременно match
объектов match
ну вот, смотрите, я написал такой tuple
по факту он конечно все еще один объект match
то есть он match один tuple
который имеет тип tuple из
one more enum и запятая my enum
да
но для нас
выглядит так, будто мы матчим два элемента
и вот то, что называется pattern matching
смотрите
я написал в скобочках
что-то там amx
и смотрите, дело в том, что
я здесь вот знаю
что вот это вот x
я внутри этого скобка
буду иметь эту переменную
он поматчит то, что
находится внутри x, а точнее
двойку, то есть я буду здесь иметь 2
так, я думаю
так, да, давайте попробую еще раз
ну и мы даем
вот такой вот pattern, что типа я
ожидаю увидеть что-то вида one more enum
amx, my enum first
такой вот tuple ожидаю увидеть
если этот tuple подходит
то такой раз так, а ну значит я вот этим вот переменным
внутри, конкретно вот эта переменная
называется x, и я присвою значение
двойке, например, ну вот у нас
просто пример сверху с двойкой
и он соответственно здесь вот будет x
ну лучше было бы, если бы я здесь написал
не фоллоу, а какой-нибудь там, в главной скобочке x
тогда бы этот код выводил двойку
в том, что нам доступно значение 2
внутри матча
внутри вот этого
ну то есть там
не нужно нам опять после этого
то есть как бы обобщение
можно сделать обобщение
с чем мы сравнивались
да, ну это просто
то, с чем мы сравниваем, вот это вот это типа
паттерн называется слева
паттерн такой вот, мы ожидаем его увидеть
если мы его видим
он пропускает его
и запускает
и там внутри
вот нет, кстати говоря, вот здесь вот
x будет как раз шедуинг внутри
сейчас подождите
какой предыдущий пример?
там, где у нас матч был
вот это
вот тут и шедуста
внутри
так в плане, он нигде не используется
а если бы использовался
например там в цикле
нет, конкретно его здесь нельзя было бы
использовать, потому что
матч, на самом деле, вот здесь вот
тоже передача владения x
то есть мы еще
пока не знаем, что такое владение
но
x передает владение
поэтому, на самом деле, он не будет доступен
он будет жить где-то
внутри матча
а если бы написали ссылку на x, то по-моему
работали бы
так
и вот
возвращаясь к этому примеру, дальше вы увидите
я могу точно также андерскопом
давайте о чем-нибудь поигнори
если бы у меня на первом месте был 2i
что-то там, то вот это вот что-то там
я просто игнорирую что там
и второй аргумент тоже игнорирую
а это просто название какое-то
это я сам бинжу такое название
говорю, вот у меня такой паттерн
я его уже даю увидеть
если он соответствует, тогда вот этим вот переменным
пред свой нужное значение
и зайди с ними вот сюда
как-то так
а чтобы мы его использовали потом
когда он
ну это
это просто нам очень удобно
мы можем деструктуризовать и просто посмотреть
что внутри сидит
здесь вот 2
здесь вот 2
здесь вот если бы x был
2 и что-то там
то в таком случае здесь было бы значение
2 и что-то там, а вот это мы бы игнорировали
вот это я бы мог написать
здесь b и c, тогда бы они тоже были бы доступны
я бы получил b и c
в случае x
а этот был шэдинг
ну да, здесь будет шэдинг
а хотя стойте
здесь мув тоже
здесь мы же муваем тюп
поэтому вот это вот уже
другой x в общем-то
он по часть того x, а ну другой
так
примерно так
мы можем мачить числа
кроме намов
вот например единичка
и еще можем сразу несколько значений написать
например
через or и такие вот
если это или это
тогда вот это
еще можем мачить рейнджи
вот такие вот
ну что-то так
здесь есть вопрос?
значит так, здесь мы мачим
пару
значит
здесь
и как вы можете заметить у нас есть if
еще после этого, то есть мы можем написать
вроде бы два одинаковых
две одинаковых вот здесь значения
но если мы можем еще дополнительно
здесь вот какое-то условие написать
пойдем мы или нет
ух, ну это на самом деле достаточно
тривиально, но такое
типа ручная какая-то работа
написать все строгие правила
как перебрать
он просто проверяет, что при всех возможных значениях
как-то можно
и кстати говоря, если вы например напишете
помачите числой, например вы напишете
матчи 13 и остальные не напишете
то он скажет, что от типа до 13
и от 13 до максимума
от минимума 13 до максимума
у вас рейнджи
как бы нет
их матча и соответственно вы учтите это
то есть раз даже пишет вам
какие вы не учли случай
да, тейфы кстати называются guard
понятно
синий вопрос, но как быстро компилируется?
раз, на самом деле
достаточно медленно компилируется
то есть не вечность конечно
он там на какую-то константу медленнее плюсов
какую-то константу раз
раз, но он
не настолько медленный
в больших проектах сейчас есть проблема
с раз, потому что
у него нет стабильного аби
в больших проектах понятно
но на маленьких вы даже
не заметите разницы
быстро компилируете
на больших, но там да
а вот получается x и y это не типы
да, переменные
то есть условно переменные
ну да
тут можно было бы написать
new x например
а если бы у нас был тип x
строк x
где-то сверху
был бы шедуинг
то есть тогда был бы в другом
сколке какой-то другой x
а в чем разница?
в третьем случае мы написали x
и нижнее подчеркивание
а мы просто хотим это проигнорировать
ну то есть нам неинтересен y
зачем нам его просто так рассказать
давайте его берем
кстати, если вы напишите y
то вам расскажут, а вы как-то не используете y
давайте вы его поместите вот этим
нижним подчеркиванием
если поместите, то станет хорошо
но еще лучше просто сразу нижним подчеркиванием написать
ну я игнорирую типы значения
там наверное копируют просто
что копируют?
а нет
так
он просто подряд матчит
да
то что он подряд идет
то на что вы можете полагаться
матч это тоже
expression, то есть вы можете вот так
поматчить boolean
boolean, кстати, почему у меня boolean
это 13, это отдельный вопрос
давайте прикинемся
что я написал
нормально
если 13, то вернем 0
дальше если
смотрите
13 если foo
foo это какая-то получается функция
которая возвращает bool
если она true, то выполнется это
если false, то тогда выполнется второе
если мы не 13, то мы пойдем в третью
третью метку
и соответственно у нас x будет
соответствующий значение 0, 1 или 2
конкретно в данном случае
функция foo не определена
я тут ее просто оставил за рамками слайдов
но если foo это просто какая-то структурка
которая возвращает true
функция которая возвращает true, то тогда у нас будет 0
x
так
вот тут такие вот приколы есть
можно игнорировать часть tuple
ну вот у нас есть
какой-то triple
из трех типов
вот мы можем
если у нас первый тип 0
а остальное мы просто как-то назвали
то в таком случае мы говорим
то что первое 0, y какой-то там y и z
а какое-то там z
потом мы можем просто игнорировать
если 1 а все остальное
нам по барабану
то мы просто забываем
вот
ну и все остальные значения
как-то матчем
тут понятно?
вот просто запомните
объявление структурки
потому что даже чуть длиннее
код чем слайд
x это какой-то tuple из двух элементов
и y это
ну какое-то число
мы можем деструктуризовать структурки
то есть даже паттерн матчем
по структуркам
вот мы матчем
если x это 1, b
и какой-то там y, то мы можем вывести
например вот x это что-то
ну x это 1, b это что-то
и y это что-то
ну и потом тоже самое
можем сделать
ну в обратном порядке
так тоже можно
если y это 2, x это какой-то там i
то в таком случае
сделать какой-то еще
и можем проигнорировать сейчас значения
вообще
там у y 2
x и ну у нас же x вроде
tuple
у нас же x tuple
ну да tuple
ну у нас tuple может быть i
и 0 и 2
и 1 будет
то есть это прям уже t будет, а не 2 отдельных
сейчас
b это просто паттерн матчем
я говорю, что давайте 2 элемент tuple в x
будет называться b
я вот хочу его дальше вывести
то есть мы можем запринять
вообще любой объект
кстати хороший вопрос
запринять мы можем
не совсем любой объект
а тот, который имплементирует соответствующие
трейты, ну я не буду
наверное подробно останавливаться
например, какие-то простые типа
tuple, ну типа tuple
вы можете вот так вот выводить
а если вектора tuple, то вы можете вот так вот
их выводить
две точки вопроса
означают, что типа debug вывод
и тогда там будет
форматироваться все красивенько
бывает полезно
и кстати сейчас мы дойдем
до вопроса, который мне уже даже
спросили в личке
про то
как
биндить
к значениям
названия
то есть смотрите
вот мы матчем какой-то age
и мы хотим, вот смотрите
если ноль, то мы там что-то выводим
а что если у нас от 1 до 12
мы хотим с ним что-то внутри сделать
если мы просто ставим 1.12
то у нас внутри никакого числа не будет
ну что нам с ним сделать
если мы хотим
допустим его на 2 умножить и вывести
соответственно мы используем
такую штуку, которая тоже является частью
паттерн матчинга, это n и такой
значок собаки
который соответственно означает, что
мы биндим
к этому значению, который
вот сюда вот подходит
название n
как-то так
это наверное такой достаточно
экзотический синтаксис, поэтому
если вы его не особо понимаете
наверное тоже можете пока что забить
потом у нас есть биндинг
как раз
что мы можем в лупе что-то делать
с массивом
смотрите, вот s, то у меня какой-то массив
потом ut это slice
что такое slice, это
под массив
под массив может быть в том числе всем массивом
то есть это какое-то непрерывное
от одного индекса до другого
под массив массива
он не копируется
это просто два указателя
и даже не грубо говоря, это так и есть
это просто два указателя
по которому можете индексироваться соответственно
вот смотрите
в цикле я делаю так, я матчу t
смотрите, и дальше паттерн матчем
такой хитрый, если я беру head
а tail называю все остальное
типа вот мы две фичи
сразу же использовали
типа я вывожу head
дальше at присваиваю значение tail
то есть таким образом у меня
на первой итерации вместо 1,2,3,4 slice станет
2,3,4
и точно так же второй раз матчу
вывожу двойку, 3,4 становится tail
как slice делается
с других элементов
как slice делает
например 2,3
2,3 элемента
не весь
а сразу укороченный
как брать укороченный slice сверху
смотри
вот как раз эти две точки означают range
просто это бесконечный range
от минуса бесконечности до плюс бесконечности
если например напишешь 1,2
то в таком случае получишь range
от одного включительного, от двух не включительного
если напишешь 1,2 просто
тогда там плюс бесконечности будет
вообще тут имперсант важен
это мы попозже поговорим
когда будем говорить про dynamic size types
пока что не берите у голов
просто пишите так
вот
мы можем даже для инамов писать всякие имплы
прикольные
у нас есть инам какой-то
потом мы делаем для него функцию unwrap
если у нас self это ax
то возвращает x
а если b, то в таком случае мы паникуем
в частности это то
как именно работает unwrap
в инами option
которые мы уже видели
вам придется очень часто пользоваться unwrap
и expect
иногда нам нужно
в одном варианте
что-то сделать
я как раз взял option
я хочу
в случае если это сам
вывести сам, а иначе ничего не сделать
ну собственно
это можно сделать немножко попроще
с этим понятно
что мы делаем
мне такое чувство, что все потерялись
с pattern match
наверное очень сложная тема
а что такое сам?
сам это
то что у нас option был
просто там еще
можно писать option
но компилятор
оно в прелюд
в прелюд написано, что можно просто писать сам
там написано use option
это инструктура
это yinam option
я показывал yinam option t
где сам t и yinam
а это оно и есть
он догадывается, что это не с option
да
ну и мы сказали
просто в прелюде
оно так есть
сам это получается t
сам
option alaminate tip
option i32
2.option i32
так
ну что ж
давайте попробуем
написать это получше
iflet это pattern match
iflet дальше я матчу
если сам i равняется option
если справа
кажется, что
у нас как раз сам что-то там
то в таком случае получим i
внутри
по сути
это специальная конструкция iflet
которая предназначена
как раз для такого прекрасного матча
а вне ifa
какой вариант не пройдет?
вне ifa такой матч не пройдет
let some и optional
он кажется не имеет никакого смысла
можно просто
андроид сделать во-первых
во-вторых он не прокатит
потому что iflet это специальная конструкция
у нас была с этого option
не было написано
option sum от чего-то
но даже там не понятно
что такое sum
там sum t
там sum t был
optional
или как
sum это один из вариантов enum
у него есть значение
внутри t
конкретно в случае t
равняется i30
вот так
а там одно равно?
да
да
типа присваивания
то же самое можно сделать
вообще абсолютно то же самое
у нас sum 0
и пока
оно не больше 9
мы просто итерируемся
и присваиваем значение optional
sum i плюс 1
и все
если вы увидите у нас pattern matching
мы получаем sum 3i
мы матчим i
если оно больше 9
и выходим
и если нет
то в таком случае optional делаем sum i плюс 1
и снова матч
можно наоборот
let optional равно sum i?
нет
то есть у нас не везде одно равно
если 3 равняется 7
то вы 2 равно купишь
то есть это просто прямое присваивание?
это можно даже воспринимать
как присваивание
то есть мы делаем sum i равняется optional
просто этот sum i это типа pattern
он пытается посмотреть
ага, похожи они или нет
типа как их сопоставить
такс
мы дошли до того
чем же отличается yinam и yinim
в расте и в плюсах
у нас yinam
так
yinam c++
давайте я вычитаю, чтобы порядке получилось
так
у нас во-первых для того чтобы выяснить
какой у нас вариант yinam у нас есть такая штука
называется дискриминант
это какое-то число бит
которое показывает какой на данный момент
вариант yinam есть
например если у вас option из двух вариантов
то у вас где-то есть один битик
который означает
какой сейчас вариант yinam
0 или 1
если у вас допустим 30 вариантов у yinam
то у вас где-то будет 5 битиков
причем эти битики
они могут распределены совершенно произвольно
то есть
я сейчас вам покажу пример
где раст раскидывает в неиспользуемые биты переменных
булов всяких
биты для того чтобы экономить память
так
это в принципе я все сказал
это одновременно по сути union yinam c++
потому что у нас yinam имеет размер
точно такой
какой имеет максимальное поле
у yinam
ну и соответственно максимальной
поодинкой всех элементов
вот давайте такой пример посмотрим
какой-то тест где first табул, second, third, fourth
смотрим такие
assert тест 1 байт
проходит
у нас тест
yinam тест имеет размер 1 байт
одно значение этого yinam
почему так получается
нам же казалось бы нужно еще где-то 2 битика
для того чтобы
вшифровать какой у нас вариант yinam
он их использует где-то
где они используются булом биты
как я говорил у нас
бул имеет 1 байт размер
но используется в нем только 1 бит
потому что он имеет значение только либо true либо false
ну и соответственно остальные 7 бит
он использует себе пользу
если бы здесь был кстати u32
то в таком случае здесь бы был
размер
8 байт
потому что u32 он может любое значение
принять он соответственно не может
в u32 никакие биты переиспользовать
ему нужно добавить какие-то
свои поля внутри для дискриминанта
он добавит в данном случае
1 байт и еще паддинг
3 байт
а если бы там была структурка
у которой внутри был
структурка у которой внутри был
это тоже самое было бы
он понимает
потом у нас есть
size of option box i32
option box это уже полный аналог
получается unique pointer
c++
потому что box если у нас это просто
что-то алоцированное на куче не null
то в таком случае если мы навесим еще option
то у нас будет либо sum box
либо null
интересно потерялись ли люди на этом моменте
и нам и оказались
в этом очень-очень сложном
1 указатель и 1 бит
еще раз повторяю
нам нужен 1 указатель
для 1 бит
да
но смотри здесь есть одна хитрость
мы же знаем что box
внутри box это просто 1 указатель
но дело в том что этот указатель
может быть null и такой раз
почему бы мне для 0 не использовать
как единственный бит
если какое-то значение значит это box если 0 значит это null
все просто
вот он такой оптимизация
что может быть
да
это будет 0 size
разные объекты один и тот же адрес
но вообще нет
если только unsafe не пользоваться
и не начинать там указатели
что-то не подсказывает
что такая ссылка
будет иметь мало значения
вообще скорее всего это просто
так как эту ссылку нельзя будет использовать
ведь вы не можете никакого взять поле у структуры
в таком случае у вас просто
этот указатель
какое бы значение не имел
он не будет иметь смысл
поэтому в принципе можно
не знаю какой конкретный ответ
на этот вопрос если честно
так что
ответ на этот вопрос если честно
скорее всего это не имеет значения
как оно имплементировано
смотрите
буквально вчера тоже проверил
если вы возьмете
одно поле из двух булов
а потом возьмете 254
поля еще добавите
соответственно в сумме 255 да
в таком случае у вас получится
в таком случае у вас получится размер все те же 2 вайта
потому что
казалось бы нам нужно
нам нужно 7 получается
нет 8 бит
для того чтобы все это зашифровать
все варианты инамы
и один из битов переедет
в другой бул
то есть он прямо будет имачить
и вы это должны будете видеть
только если вы добавите еще одно поле
то уже будет 3
почему не знаю
с каких-то достаточно больших значений
эффективнее
просто иметь отдельное поле дискриминента
вот у нас есть
вектор
как все плюсы призначены
у нас есть поинтер
на консте length и capacity
он стоит примерно точно так же
здесь есть еще такой комментарий
это вот чтобы вам
просто жизни не казалось простой
я вам заранее скажу что на самом деле
в случае раз
нужно учитывать что у вас еще в типе
написано и поэтому там будет phantom date
чтобы это все учесть
наш указатель
это указатель 1
да
почему не constant
это указатель
constant a
да там mut
указатель нам mut
все правильно
это ошибка
так
кстати говоря
я здесь явно прописал
до этого не прописал
istedimium-sizeof
по умолчанию
не импортировано
нужно импортировать вот так вот
либо просто прописывать полностью
mem-sizeof
даже интересно как оно сюда попало
значит размер вектора
ну это просто
усайс на 3
очевидно почему
потому что у нас там по сути есть 3 усайза
это один указатель, два усайза
kp-stillenv
ну создаем вектор
можем создать вектор с помощью
макроса, если вы через запятую напишете
у вас будет 3 элемента здесь
если вы напишете элемент точкой запятой
и число, то у вас будет какое число
знаков элемента
в принципе понятно
потом у нас есть вот
вот слайсы
это к вопросу о том, как они правильно
пользоваться, вот можно всякие вот такие вот штуки делать
например до 2
то есть это получается
что первый слайс будет 2, 3, 4, а второй будет
просто 2
первый слайс если что берется от a
а второй слайс берется
от слайса того
и получается соответственно
просто 2
так ну смотри
если мы возьмем от 1 до 4
то мы возьмем элементы 1, 2, 3, 2, 3, 4
второй слайс
мы возьмем элементы все до 2
0, 1, 2
может быть я тоже опечатался
не, не
так сейчас подождите
да, я наверное продолбался
здесь тоже должна быть троечка
2, 3
ну тут если что индексация идет
от другого слайса, то есть вы кого-то
создаете дополнительно
мы же взяли
2, 3, 4
слайс 1, 2, 3, 4
потом мы от 1 добавим
все элементы
до 2 невключительно
то есть 0, 1
да
вот там
это индексы указаны
где мы берем
да, это типа range
то есть то же самое синтаксис
что в порах у нас был
что когда мы матчили
от x до y
если вы первое не пишете там минус бесконечности
если второе не пишете там плюс бесконечности
если не то не то не пишете у вас просто бесконечный range
что сейчас
отрицательные
вы не можете индексировать массивы
отрицательными, но вообще range можно
от 1 до 3 сделать
да, кстати очень важный момент
индексировать все массивы
вектора и так далее
можно только усайзом
то есть если вы попробуете
с помощью i32 это сделать
у вас будут проблемы
раз вам это запретить делать
так, теперь да
время паниковать
у нас есть такой макрос
который начинает паниковать
он работает
как я уже говорил как экзепшн
просто stack unwinder до самого конца
и говорит нам сообщение об ошибке вместе
с stack trace
так можно
без точки запятой
на самом деле там логично
вы наверное еще пока не писали на расте
то есть пришли на первые лекции
это не зависит от if не if
можно вне ifa
выше где x равняется 42
просто написать панику и все равно все заработает
это просто возвращение
юниона будет
ну можно
если после паники
что-то еще написать
хоть и раз будет понимать что после паники
код не будет исполняться
он скажет что вообще-то
у вас здесь вернулось уже значение
то есть у вас expression, а дальше идет statement
что-то не то
в этом случае это правильное утверждение
у нас есть несколько макросов
которые паникуют, вы их увидите в задачке
ассерт и ассерт и икол
первые три
это все одно и то же
с разными названиями
предназначенные для разных вещей
чтобы было понятнее тому
кто словил ошибку
ассерт это просто вещь
которая проверяет
true или что-то внутри
ассерт и икол проверяет через запятую
если они не равны
то он прям вам выведет в консольке
у вас сработался артикл
там паника
почему было равно левое значение
и правое значение
а подожди
у32 к булу
нет, так нет
я просто подумал в обратную сторону
хотя нет
см тоже не конвертируется
вообще не конвертируется
см
так
лучшее средство для дебага
принт лм
у нас
есть всякие вещи
которые позволяют нам удобно принтить
как я уже говорил
есть в фигурных скобочках x
можно писать только название переменных
в фигурных скобочках
можно написать x и y внутри
это сейчас
раз еще недостаточно развился
этот синтекс
даже сам к себе недавно появился
буквально пару недель назад
возможности x и y писать пока нет
потом
значение x
что там классное
здесь можно через запятую написать
что вы хотите
в фигурных скобочках написать
что бы истиномить в фигурных скобочках
если бы у вас было 3 фигурных скобочки
то раз бы ожидал
что у вас здесь было бы 3 переменных
не больше не меньше
ну да
быть прям проверять compile time
то есть там macros так работает
он проверяет
потом
есть всякие форматирования
про них подробнее я не буду рассказывать
посмотрите документации если интересно
вот можно написать например
0042
или например
сделать вот такое форматирование типа value
а value это x
можно выводить вектор
например debash
или другим способом
форматировать его
в том числе можно выводить tuple
как видите они форматируются красиво
а второй принц
там x почему
через запятую
его вместо скобок
сейчас подожди какой x через запятую
там где
the value of x есть
второй принц
запятая x
воспример это как print function
точно так же примерно работает
раз x это пример
объявленная высшего
что с форматом в итоге
да тут кстати есть
прям macros формат
восклистательный знак
и собственно принтерлайн
внутри пользуется работает абсолютно точно так же
только не выводит
это означает дабак вывод
а если еще дописать вот такой вот sharp
то это означает что красивенько мне выведет
третья принц
просто вектор
он скажет что
вектор не имплементирует вывод
потому что дабак вывод
разработчики понимают что такое дабак вывод
примерно вот так вот вектор нужно дабажно выводить
что значит просто вывести вектор
через запятую через пробел
через что
это нужно руками сделать
да у нас еще целый
барау чекер впереди
ну что будем
будем барау чекер добивать
так ну
сейчас
135 слайдов
то есть еще 20 слайдов
справитесь с
домашней бизнесом
так а сейчас
погодите две секундочки
ну все давайте хотя бы
барау чекер добить
у нас есть вот
вот фанкшн
мы когда пытаемся
написать T32
то раз говорят что
тип не соответствует
что мы хотели вернуть T32
вернули июнь
ну а как тогда работает такой вот код
тут написали
он же не возвращает
T32 как же он работает
но есть такой специальный тип
не населенный переводится
вот этот тип отличается тем
что он никогда не сконструируется
это Rust прекрасно знает
и поэтому если что-то возвращает
инхабитат
то он никогда не сконструируется
поэтому если что-то возвращает
то он знает что
дальше код не пойдет
и соответствующая оптимизация применяет
кстати говоря
как раз про loop будет
то что я говорил про loop
то что у нас
был while и loop
чем они отличаются
Rust знает про то
что while выполняется пока условие
даже если вы напишите while true
Rust все равно не будет оптимизировать
как будто он бесконечно
исполняется
а если вы напишете loop
и внутри не будет никаких брейков
всего такого
то Rust будет об этом прекрасно знать
и соответственно он сможет сделать
соответствующей оптимизации
что эта функция никогда не возвращается
то есть отличаются эти штуки
информация о потоке управления
это примерно то же самое
у нас может быть простая структура
а inhabited type это то же самое
что просто и нам
его нельзя сконструировать
потому что у него нет никаких значений
можно мемчик посмотреть
я надеюсь
что вам первая лекция понравилась
и что вы
на ней не погибли
хотя у меня есть чувство
что примерно на матче все посыпались
это ключевая механика
того как работает
безопасность Rust
там есть понятие того
что у первеных есть владение
я думаю что лучше перенести
тогда всем спасибо
всем пока
