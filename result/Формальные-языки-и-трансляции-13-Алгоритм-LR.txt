Собственно говоря, сегодня я ставлю себе цель усадить
на сам алгоритм.
И потом станет понятно вообще, зачем я что-то
тут доказывал.
Давайте вспомним пару определений.
Так, были на семинарах шифридус-автомат?
Давайте так.
Шифридус-автомат.
Прекрасно.
Что там у нас?
Эпсилон, альфа-а и эпсилон-эпсилон-эс.
Напоминаем, что вообще происходит.
Автомат, конечно, разбирает свою грамматику.
Это что-то, что можно доказать, в принципе, вашим инструментариям
довольно быстро и просто.
Дальше говорим, что вывод в ровном станке в том правосторонний.
Это тоже сейчас не буду заоценивать внимание.
Проблема этого автомата была в недетерминированности.
Делает шифридидидюс.
Поэтому мы с вами решили, что давайте у нас будет не
просто одно дерево вывода, а это будет настолько хорошее
дерево вывода, что оно будет определяться своим
префиксом, который мы прочитали, и к буквам, которые мы
подсмотрели.
Ну, это ровно было при лекограмматике.
Для чего это было нужно?
Автомат есть свое видение мира.
Вот он считает, что сейчас находится в ситуации, а,
стрелка, бета1.бета2, то есть автомат ждет, пока дочитается
текущее правило, текущее под дерево.
Рисуем картинку.
А, бета1.бета2, что он его дочитает, он поднимется
наверх, дочитает вот это правило, поднимется, дочитает
вот это правило.
И мы с вами попытались доказать, что эти ситуации ведут себя
достаточно согласованным образом.
Коя какая-то мы еще вернемся.
Значит, напоминаем, что LRK-ситуация – это объект из правила
с отмеченной позиции какого-то слова, из кавбукф или меньше.
Слышишь, что такое допустимость?
Допустимость означает, что такая ситуация, в целом,
возможна для алгоритма.
То есть он действительно может дойти до момента, когда
у него в стейке будет что-то похожее на правчесть этого
правила и то, что было до этого.
Ну вот здесь нарисовано дерево, осталось его просто
выписать.
Значит, ситуация допустима для префикса гамма, я потом
буду дописывать, чему он равен, когда мне это будет
нужно.
Если существует вывод, из S3 со звездочкой выводится,
значит тут единичку допишу, альфа1аw, поскольку будет
правосторонний, а это сам правый интерьер, раскрываем
его за один шаг, альфа1бета1бета2w.
Точка стоит вот здесь, вот вам гамма.
То есть ситуация допустима, если вот это существует.
Если посмотрим на работу такого автомата, то он разбирает
вывод в обратную сторону, то есть он вначале собирает
себе stack, потом сворачивает его, в конце он свернет
в S, и S снимет, кажется, что он завершился.
То есть вывод, который мы тут строим, разбирается
в обратную сторону, восстанавливается в обратную сторону.
Значит остается вопрос, как построить вот эти допустимые
ситуации?
Давайте начинать строить.
Значит я сейчас, наверное, расскажу конструкцию и
сразу попутно докажу теря мокрекности.
Так, где мне это все записать?
Давайте вот здесь.
Вывод хочу оставить, давайте тогда вот тут.
Начнем строить с V, K, G от Epsilon.
Что вообще может происходить на пустом стейке?
Ну, поскольку у нас грамотика пополненная, то бишь в ней
есть правило S-3 в S, и с S потом все выводится, то одна
ситуация, очевидно, всегда будет допустима.
Что такое?
То, что такая ситуация допустима всегда, это
вот этот вопрос.
Ну, существует вывод, который выводит из S-3 в S-3 за 2 шагов,
S-3 раскрывается в S, префикс пустой.
Почему?
До S-3 пустое слово, в правиле до точки пустое слово.
Это V, K, G от Epsilon.
Да нет?
Прекрасно.
Теперь давайте посмотрим.
Пусть у нас есть в общем случае какое-то такое правило.
А, стрелка, альфа, точка, так, что-то у нас B, бета, какое-то
U.
Поскольку эта штука допустима, напишем для нее вывод, S-3
выводится звездой.
Так, мне тут не нравится обозначение.
Поставлю B1, B2, ну, чтобы альфа была вне.
Альфа 1, A, W за 1 шаг, альфа 1, бета 1, B, бета 2, U.
Точка стоит вот здесь, стоит вот здесь.
Вот у нас префикс.
Пока говорим, что он пустой, в будущем я скажу, что на
самом деле это работа для любого V, K от любого префикс.
Что хочется здесь сделать интуитивно?
Хочется вот этот вот B как-то раскрыть, чтобы протащить
вывод дальше.
Это опять предпочет.
Формально.
Говорим, что у нас есть какое-то правило B, V это маленькое.
Давайте это право тут применим.
Оно уже сходит допущенность, да, вывод был, вывод остался.
Записываем второй вывод.
Или давайте я дальше напишу его в таком виде, S-3 выводится
звездой, альфа 1, бета 1, B, вот, и дальше W.
Смотрите, бета 2 возможно из этих терминалов.
Что мы хотим сделать?
Мы хотим открыть букву B.
Открыть букву B нельзя, пока она не самая правая.
Стало бы, давайте вот здесь выведем какое-нибудь слово.
Это можно делать, потому что у нас все терминалы везде
порождающие, какие-то тегетериальные вещи я буду опускать.
Здесь мы дождемся, пока она все раскроется, а букву
B мы не открываем.
Вот он написал.
Вот эта звездочка означает, что мы дошли сюда и дождались,
пока B будет самоправой.
Открываем его.
Альфа 1, бета 1, это W.
Префикс поменяться не должен.
Значит, точка стоит все еще тут.
Вот у нас префикс.
Только тут не альфа, тут гамма.
С точки зрения вот этого правила, надо было разбить
правила вот здесь, чтобы префикс остался вот этой
вот гаммой.
Вот я тут написал.
В сути не этого правила, чтобы префикс не поменялся,
мы же тоже самое WKG строим.
Мы поставим точку в начале.
Стало быть наша ситуация имеет вид.
B, стрелка, точка, это.
А что находится после запятой?
После запятой находятся те кабу, в которые возникают
в словах, в выводах, сразу после интервала, который
мы открываем.
Либо после его правила.
Было U.
Было U.
Вот он U.
Что стало?
Давайте посмотрим.
Вот этот вывод здесь написан.
После B вот это W.
W откуда взялся?
Если вам говорили, что вот этот вывод отсюда.
Вот отсюда взялся.
Это понятно?
Ну прекрасно.
Стало быть мы пишем здесь W.
Это First.
B это 2U.
А теперь финальное утверждение.
Как построить WKG от Epsilon?
Для этого нужно взять вот такую ситуацию.
После чего?
Пока ситуация добавляется новой, нужно брать каждую
ситуацию такого вида, если точка перед большой
буквой.
И смотрят все правила, которые превращают эту
букву в что-то.
Так, и добавлять.
Так, я тут написал.
Да, вот.
Добавлять ситуации вида B, стрелка, точка, это запитает
W, согласовывая W как First от остатков правил и остатков
условий.
Давайте тогда вот здесь вот этот факт докажем,
что это будет ровно WKG.
WKG от Epsilon, только оно.
Да?
С первой строчкой.
S4 выводит α1, а W не должно быть α1, а 1.
Смотрите, у вас U это первая K-буква W.
Здесь, да, у меня кризия обозначений.
Дайте я напишу, вы маленькая.
Вы маленькая равно First.
Смотрите, у вас U это может быть сколько угодно большим.
Вас только K-буква интересует.
Увидели?
Прекрасно.
Да, давайте здесь.
Я вот тут поставлю место, тут буду заниматься теоремой,
а там буду заниматься практикой.
Вот.
Меня можно здесь подслеживать.
Теорема здесь расписана в конспекте.
Так, напоминание сказал.
Так, ну давайте смотреть.
Значит, в одну сторону.
Если у нас вот такая ситуация, вот была допустима.
А, стрелка, β1, точка, B, β2U.
Допустима для...
Давайте сразу, в общем случае, для какого-то префикса с гаммой.
Из того, что я написал, в принципе, сразу следует,
что вот эта ситуация B, стрелка, точка, это, В,
где В взят как ферст, отчего β2U допустима тоже для WKG от гамма.
Но это в целом либо необходимость, либо достаточно.
Сейчас я на сходу не скажу.
Вот мы говорим, что наш алгоритм, то, что он добавляет WKG,
оно все будет допустим.
А сейчас понять, а что если есть какие-то допустимые
ситуации, которые у вас сюда не попали?
Смотрим подсказку.
Значит, пусть.
Да, я сейчас начинаю доказывать.
Что?
А, смотрите.
Как построить WKG?
Если я возьму вот такую ситуацию и буду всякий раз,
когда имею ситуацию вот такого вида в алгоритме,
то есть перебираю все ситуации, пока множество меняется.
Для каждой такой ситуации, вот она тут написана,
добавляю такую ситуацию.
И далее, пока множество ситуации меняется, мы всякий раз
ищем такие, добавляем такие.
Утверждается, что если я дойду до момента, когда
новостей не появляются, то это будет WKG и только они.
Что мы пока доказали?
Алгоритм корректен.
То есть, если он что-то добавил в WKG при помощи замыкания,
ну а прежде всего это замыкание.
Значит, он там действительно должно быть.
Это вы видели?
Ага.
Значит, осталось понять, а если мы имеем что-нибудь,
что мы тут должны добавить?
Верно ли, что мы это найдем?
Давайте посмотрим.
Так.
Сейчас я сформулирую какое-то утверждение, потом посмотрю,
какая тут должна быть индукция по какому параметру,
и скажу, что эта индукция была сверху.
Значит, смотрим, пусть у нас ситуация.
Пусть.
А, стрелка, β1, точка, β2, у лежит WKG от ε.
Пусть такая ситуация допустима.
Посмотрим, какой у нее есть вывод.
Так.
Давайте разбирать два случая.
Два случая.
Бета 1.
Я здесь говорю, что корректность, все, что добавляю, все хорошее.
Теперь я беру призвольную ситуацию какую-то.
Хочу сказать, что она у меня появится.
Что?
Это призвольная ситуация.
Так.
Что?
Смотрите, пока здесь от ε мы построим для ε,
потом мы скажем, что как построить для какой-то другой строки.
Нужно принести все точки и снова замкнуть.
Вот этот факт, он настолько крутой,
что замыкание совершает корректность в принципе для любого префикса.
Поэтому тут пишу не ε, а сразу пишу γ,
потому что это просто вера для любого префикса.
Вот, пока здесь мы написали здесь ε,
значит, что это мы до ε доказываем,
потом мы это скопируем и докажем для γ.
Такс.
Вот, ну.
Отложу.
Что будет получаться?
Давайте напишем для нее вывод.
Что у нас тут?
С штрих выводит α1Аw.
За многое мы это скопируем и докажем для γ.
За много шагов.
И за один шаг выводит α1β1.
Так, ну что у нас тут есть парни интересных фактов.
Например,
вот это пустое слово.
Это тоже пустое слово.
Но пока еще вы окажете это, если он строится.
Вот.
Надо понять, что мы эту ситуацию предсказали.
Все ситуации возникают как предсказания друг друга.
Ну, давайте посмотрим предыдущий шаг.
Вот здесь.
Как эта буква А получилась?
Вот.
Утверждается, что был какой-то шаг до нее,
значит, по длине вывода будет.
На самом деле, вот этот вывод, силу пустоты всяких строк,
имеет вид
просто Аw
и тут просто β2у.
Все по слову слову уже доказываем.
Так, ну что тут сказать?
Смотрим, здесь последний шаг.
s' выводит.
Ну пусть здесь за n шагов, значит,
как я сказал, индукция по длине вывода.
За n-1 шаг.
Здесь будет не терминал.
Почему не терминал?
Потому что если бы тут был терминал, он бы здесь в рефексе остался.
Мы предполагаем, что мы вывели центральный начальник.
Ну, так как у нас есть контекст свободы,
вот этот терминальный буквы тут в начале никуда бы не делось.
Ну что там у нас?
У какой-нибудь.
За один шаг оно выведет А.
В маленькое, у маленькое.
И потом из А выведется то, что нам нужно.
А у нас было у здесь.
У меня у было вот тут точно.
Это как бы в одну сторону теоремы.
Я у буду писать, давайте так договоримся,
что я буду писать у всегда, когда он стоит после запятой.
Вот на этом сойдемся.
У это всегда второй аргумент ситуации.
Значит здесь, да.
Я прошу, да.
Спасибо, что вы мне указали.
Я здесь просто пишу, потому что здесь везде только первые буквы важны.
Конечно w осталось.
Что нужно сделать?
Следующий шаг.
Как эта буква А появилась?
Было какое-то правило B куда-то и буква А стояла в начале.
Мы говорим, что эта ситуация допустима.
Так, ну где-то это сейчас напишу.
Так, где вы мне написать?
Вот это мне, наверное, не нужно.
Тут такая будет TMP доска.
Так, что у нас там получается?
С штрих за n-1 шаг.
B w штрих за 1 шаг.
A w штрих.
Вот так вот.
И потом β2.
Что-нибудь вот такое.
Основная суть.
Берем предыдущее правило.
Или же тут ситуация была допустима.
Стрелка.
Там была буква А в начале.
Поскольку у нас буква B здесь была в начале буква А,
буква А находилась в начале этого правила.
Здесь точка.
И там что-то было.
Потом это что-то как-то раскроется вот здесь в слово,
пока B не станет самой правой.
Так, и здесь.
Что у нас там было?
Обозначим как w.
Лежала w к а g от epsilon.
Более того, не просто лежала,
еще и было туда добавлено в предыдущих шагах.
Так, давайте проявим всякую согласованность.
Здесь,
первый k-букф это u.
Откуда вот эти вот k-букф взялись?
Они взялись из правой части правила
вот здесь, вот эта вот гамма,
которая открыла свое слово.
И то, что было вот тут.
Откуда взялись вот эти k-букф u?
Какая-то часть букв открылась
на этапе до буквы B.
Потом буквы B раскрылись по какому-то правилу.
Вот у нас a, потом гамма.
Потом гамма раскрылась, так чтобы
буква a была самой правой.
Здесь еще одно слово появилось.
Вот это ровно то и знаете,
что у нас w, u,
это first
от гамма v.
Довольно простая индукция.
Да, нет?
Почему у вас в один шаг B что-то превращается в a?
Смотрите, я здесь за один шаг
раскрываю...
Да, я понял, о чем вы говорите.
Здесь на самом деле с гаммы и потом нужно еще
за много шагов эту гамму убрать.
Вот.
Потом a стала самой правой
и потом a уже раскрылась как β2.
Вот так вот.
Да, я это сказал, но не написал.
Что на самом деле,
здесь у нас гамма, но мы ждем,
пока не выводится буква.
Отсюда и ферст вылез,
что вот этот вот ферст гамма w,
это все префисы выводимых слов.
Вот они выводимые слова.
Вот здесь какое-то слово вывелось.
Стало быть, как бы трудно находиться,
попали в ферст.
Мы построили WKG от Epson.
Алгоритм работает в линейное время.
То же самое, что вы делаете.
Вы говорите, что старые ситуации вы обрабатываете
и не трогайте больше.
Добавили новые.
Это те, кто будут его писать,
те потом будут об этом думать.
Это как реализовывать?
Взяли ситуацию в очередь,
добавили новые ситуации.
В этой ситуации больше не смотрите.
Ну и все.
Теперь,
как строить другие WKG?
Здесь я, наверное,
вот это сотру,
а то, что ниже оставлю,
оно мне пригодится.
Хотим сказать WKG
от каких-то х.
Какие ситуации точно лежат?
Давайте посмотрим на WKG
от х поменьше.
Тут все х – это как терминал,
так и сигма и он.
Я пока напишу такое слово,
потом объясню, что оно значит.
Посмотрим на все ситуации WKG
х1, х1-1.
Давайте напишем
на нашу промежутщую доске,
какое тут возникает.
Что у нас может быть?
s'α1aw
α1 так
β
Немножко сотру.
Мы всегда были проблема
с топологией доски.
бета 2 и здесь w. Точка стоит вот тут. Значит вот это x1, xn. Давайте предположим, что у нас
вот здесь ситуация имела такой вид. Бета 1, точка xn, бета 2. Вот взяли, предположили. То есть пусть у меня
точка стоит перед xn большим. Что это означает? Что я могу взять тот же самый вывод. Абсолютно тот
же самый. Все то же самое. И подниму точку дальше. Я напишу вот этот xn и скажу, что вот это, это то
же самое, что а1, бета 1, xn, точка, бета 2, w. Эта ситуация будет допустима. Это очевидный факт,
что если у вас был вот такой вывод, и этот вывод поразался ситуацией с xn, вот она прямо стояла
после точки. Значит вот такая ситуация. А, стрелка, бета 1, xn, точка, бета 2, w. w такое же абсолютно.
Вывод вообще не поменялся. Допустима для префекции x1, xn. То же самое называется go to. go to от
какого тоже ситуации? Отночает. Просматриваем список ситуаций. Если видим ситуацию с точкой
перед xn, протаскиваем точку через xn, добавляем ситуации внутрь go to. Добавили ситуации,
после этого что-то замкнули. То, что мы поняли здесь, вот здесь. Что замыкает, это хорошая
операция. То есть если я возьму и принесу точку в этой ситуации, согласую w и бета 2, u, то это все
будет допустимо. Теперь сильное утверждение. Оказывается, ничего другого допустимого нет.
Сейчас этим мы разберемся. Как работает go to, понятно? Да? Не важно, что такое. x' призвали строки.
Еще раз, go to, это как бы скан верли. Протащили точку, замкнули. Ну, скан и предик на самом деле.
Так, да, нет? Прекрасно. Так, а сейчас вот будет теперь посложнее. Да? Смотрите, в теории вы говорите,
что можно построить для всех строк. Там строк бесконечно много, поэтому w и k житы тоже бесконечно
много. Это в теории. Вот такой вот факт, тут что, по xn тому. Он верен. На врачке что происходит?
На врачке происходит примерно то, что я сказал в прошлый раз. Смотрим на ситуацию. Что такое ситуация?
На самом деле, это не строка. Вот подливы вы понимаете, что строку вы в ходе не напишете. Это карта
шестерех элементов. Какое-то правило, то есть число правила. Правило номер пять, правило номер шесть,
номер семь. Точка в позиции. Это ограничивается размером этого правила. И слово, которое
ограничивается нам в сигме в степени k. Вот что-нибудь такое. Несмотря на k плюс один,
тут еще какие-то константы. Конечно, нам много в зависимости от грамматики. То есть, если вам дали
грамматику, ситуации, то есть грамматику число k, конечно, много. Дальше. Поскольку ситуации, конечно,
много, множество ситуаций тоже, конечно, много. То есть рассматриваем два в степени множества ситуаций.
Стало быть, различных v, k, g будет, конечно, много. Экспоненциально много, но конечно много.
А отсюда следует принципу Дерехлея или что-то вроде этого, что для каких-то префекций ситуации будут
совпадать. Вот это там силы слабости леоралгоритма, что он считает какие-то префекции на стреке одинаковыми.
Отвечаем на ваш вопрос дальше. Вы посмотрели вкажет эпсилон. Вы видите везде, где стоят точки, говорите,
что значит можно получить при помощи go2 новые префиксы какие-то. Пошли здесь по b, здесь еще как-то
прошли. То есть везде точки сдвинули. Это будут какие-то новые ситуации, новых префиксов. А дальше
простой bfs. Протащили все точки, замкнули. Смотрим на новые множество ситуации. Можно ли там
точить точки? Примерно было на семинаре, поэтому я сейчас оставлю себе право, возможно, показать его. Давайте покажу
вот так вот пару шагов на одной простой грамматике. Что? Да-да-да, вы смотрите все достижимые префиксы просто.
Вот утверждается, что таким алгоритмом, поскольку у вас все зациклится, вы построите все v для всех
префиксов. Ну, давайте пример. s'v, s, s, a, s, b. Я рекомендовал этот пример всем семинаристам,
может, не все его построили. v1 же от 0, от эпсилон. s'.s, запятая эпсилон. Дальше предсказываем s.sa,
sb. Так, здесь эпсилон. И потом эта ситуация само себя предсказывает. Поэтому вот эта вот буква еще тут
появится. Но я надеюсь, что вы это семинарию уже сделали. s. тут тоже эпсилон, а. Ну вот мы построили сами vk.g от 0.
От эпсилон. Как мы дальше делаем? Смотрите, вот можно p.s перейти. Значит, мы говорим, у нас будет v1.z от s.
Если мы сейчас позволим его не строить, сказав, что
тут надо продвинуть точку здесь и придвинуть точку
вот здесь, и давай туда в этой ситуации.
Замыкать тут чьи-то будет нечего, потому что когда
он придвинет точку, у вас не будет встать новый
буквес.
Когда у вас будет точка вот тут, вы скажете, что
у нас есть еще в, сейчас вот, в, 1g, атес а.
Тут точка будет встать вот здесь, там еще что-то предсказывается.
И вот это значит, что вот здесь, в этом примере, я
рекомендую вообще дома проделать семь ситуаций,
семь, множество ситуаций, вернее, семь состояний.
То есть на практике вы там как-то исчерпали все, а
сегодня конечно страшнейшее, но это же все предподсчет,
какая разница.
Так, это на доске оставлю.
Так, давайте, наверное, а ну вот, здесь уберу.
Еще раз вопрос.
Смотрите, на стеке не только правой части правил лежат,
в этом проблема.
Допустим, вот здесь, если вы посмотрите, то у вас
кажется, я точно не помню, это всего 10 часов утра
рассказывал, вроде как вот такие вот два стека,
они эквивалентны.
Я сейчас не буду доказывать всякие факты о том, что
эти два стека эквивалентны, то у них там суффиксы совпадают,
потому что это нам не нужно.
Это такое наблюдение.
Возможно, это не правда, проверьте здесь, когда будете
строить, что у вас какие-то ножи совпадают, и вы будете
замечать, как это все выглядит.
Вот, это семярский материал.
Еще какие-то вопросы.
Давайте посмотрим, вот такое докажем, что если А-стрелка
бета-1, бета-2 у допустимо, то есть лежит vk x1 xn.
Значит, как выглядит алгоритм?
На первом шаге протаскиваем все точки, на каждом следующем
шаге делаем замыкание.
То есть, когда я говорю индукция по шагам алгоритма, я имею
в виду, что вначале мы продвинули все точки, потом замкнули
все ситуации, потом замкнули замыкание всех ситуаций,
и вот так вот ходили вот такими слоями.
То есть, предыдущий шаг алгоритма означает, что у нас вывод
просто на один короче.
Так, вот это получилось, давайте поставим для него
вывод.
Посмотрим.
Нужно позвать вывод, в какой момент она сюда попала,
бывают два случая.
Она сюда попала с двигом точки, это мы там разобрали.
Ну, давайте посмотрим, она сюда попала при помощи
с двига точки.
Значает, что точка стояла, вот тут стоит xn, вернее.
Я вот тут не буду писать.
Ситуация имеет вид, а стрелка бета 1, xn, точка бета 2, запятая
u.
То есть, если она сюда попала при помощи с двига точки,
а не при помощи замыкания, то очевидно, точка была
тут, стала вот тут.
Была допустимая ситуация.
Значит, все вот того, что алгоритм для предыдущего
плейфикса отработал нормально, допустимая ситуация такого
вида, а стрелка бета 1, точка xn, бета 2, u, она была допустима,
была добавлена.
Начинаем какой-то вывод, с штрих, что у нас там со
звездой.
Альфа, a, w, альфа, бета 1, xn, бета 2, w.
Ну и там first от u совпадает с first от w.
Значит, мы говорим, что вот эта ситуация была допустима,
значит, для него был вывод, она была добавлена.
Поэтому вот эта новая ситуация тоже допустима.
То есть мы добавили что-то, что должны были добавить.
Вот.
Значит, второй шаг.
Пусть она была добавлена как замыкание, значит, здесь
как go to, значит, как замыкание.
А теперь обращаемся к тому, что он сказал в начале
семинара, в начале лекции.
Если какая-то ситуация была допустима, замыкание
не меняет допустимость для любого префекса гамма.
В нашем случае гамма – это вот наш х и инексан.
Вот такая вот корректность.
Давайте теперь поймем, что мы исчерпаем все в нашей
допустимой ситуации.
Здесь пока можно задать какие-то вопросы, но здесь
совсем тривиальная индукция.
Но все-таки не задайте вопросы, чтобы было понятнее.
Сейчас я позволю себе списывать.
Я напоминаю, конспектом можно будет пользоваться,
потому что сход это сложно установить.
Теперь уже пишем ту самую ситуацию, бета1.beta2.
Что-то хочу доказать.
Ага, и правильно построено v, k, g, x1, xn-1.
Предполагаем, что на первой шаге мы сделали все правильно.
И предполагаем, что вот эта ситуация допустима, то
есть ее нужно добавить.
Вот эта ситуация допустима, что вообще тут может возникнуть.
Так, значит, она допустима.
Так, для, значит, тут у нас, да?
Я хочу сказать одну из двух вещей.
Что она либо пуст, либо не пуст.
Вот если у меня вот здесь пусто, то она получена
при помощи замыкания.
А если она не пуст, то получена при помощи двигаточки.
Давайте предположим.
Допустима для x1, xn.
Вот, я немножко тут замкнула, здесь.
Давайте проверять.
Значит, первая.
Бета1 не пуст.
Давайте посмотрим, что тут возникнет.
С штрих.
Значит, допустим начать с вывода.
Альфа1, А, W.
Много шагов.
Тут один шаг.
Альфа1.
Значит, А раскрываем, как бета1.
Бета2, W.
Вот это равно x1, xn, так?
Бета1 не пуст.
Значит, что у нас с бета1 последнее?
Xn, это последнее бета1.
Давайте напишем, что бета1.
Это бета-штрих на xn.
Ну, бета-штрих уже может быть пустой.
Значит, здесь тогда я говорю, что вот это, просто как
строка, равно А1, бета-штрих, xn, бета2, W.
Тогда...
Значит, и точка стоит вот тут.
То бишь вот тут.
Я говорил правило вот здесь.
Давайте тогда мы поставим точку вот здесь.
И рассмотрим ситуацию.
А, стрелка, бета-штрих, точка, xn, бета2, W.
Спасибо вам за комментарий.
Вот ровно это и нужно сделать.
Значит, теперь мы говорим, что вот эта ситуация допустима
для этого префикса.
Почему?
Берем тот же самый вывод и говорим, что меньше в нем один шаг.
Тогда сфотографируйте.
Там, наверное, xn или W?
Нет, именно U.
Сейчас, дайте я проверю.
Да, U это то, что находится после буквы A.
Вот.
U находится вот здесь.
Вот он.
Вот эти вот буквы.
W.
Так, ну и...
Поскольку эта ситуация тут допустима,
на первом же своем шаге,
при построении WKG от x1xn,
эту ситуацию заберет.
Отлично.
Значит, второй шаг.
Бета, один, пуст.
Так, а вот немножко сложным будет.
Значит, я сейчас буду говорить по одной строке,
и после этого ждает согласие,
что все согласны, что это действительно верно.
Давайте вот это вот уберу.
Если кто-то это конспектирует,
я это все когда-то сам законспектировал,
поэтому...
Потом можете этим пользоваться.
Проблема Валерия именно в том,
что здесь очень много разных букв,
которые обозначают разные вещи.
Значит, α...
Там что у вас α1, да?
Вот это x1xn есть.
То есть мы говорим,
что пусть у меня так получилось,
что мы перейдем до этого шага.
Значит, берем
s'
со звездой.
α, а, w.
Значит, правый.
Это правый вывод.
Что означает, что это правый вывод?
Что когда-то сам правый не терминал.
И α это x1xn.
Значит, тут α1.
Хочется сказать,
что xn ты
на каком-то шаге появился.
Но это почему-то правда.
То есть
рассмотрим.
Первый или последний
надо проверить.
Последний.
А, ну, с другой стороны,
да, поскольку мы сейчас а раскрываем,
здесь в выводе
как это вообще
может быть устроено?
Там из штрих вылезает какую-то альфу.
Ну, чтобы не было альфы, давайте так.
Гамма тоже заняты все.
Какой там дельта 1?
Какое-то вычисление
не терминалов и не терминальных букв.
Потом вот этот не терминал
как-то раскрылся
и стало еще больше букв.
И потом вот так вот раскрывалась,
потом буква вылезла.
Хочу сказать, что у меня был какой-то шаг,
на котором появился xn.
Последний шаг,
где
в строке
появился
xn.
Я надеюсь, что я объяснил,
почему такой шаг есть.
Здесь это
в любом случае немножко опущу,
не совсем такие строгие вещи.
Вот.
Но то, что у нас, если перечислять
вот такие строки,
в какой-то момент xn появится в последний раз.
Вот xn просто тут есть.
Если на предыдущем шаге,
он на предыдущем шаге уже был.
Посмотрим еще один предыдущий шаг.
Вот найдем первый момент, когда он появился.
И запишем этот вывод.
Самый поздний.
Я хочу получить ситуацию,
где у меня xn стоял вот тут
и свести к этому случаю.
А потом замкнуть все до конца.
Вот что сделать, да?
Вот непосредственно предыдущий.
Смотрите, что у вас могло возникнуть.
У вас тут могло возникнуть x1, xn и какой-то b.
И b вывел a.
А b мог и на c появиться.
Было x1, xn, c.
Потом c перешло в b, b перешло в...
Вот я хочу вот это все промотать назад.
Это на самом деле
произошло в алгоритме.
В теории это нельзя, потому что это какая-то странная индукция.
В теории мы говорим, насмотрим последний шаг,
где он возник. То есть последнее правило,
породившее его.
Утверждаю, что для этого важно,
чтобы вывод был правым.
Вот что...
Ровно xn, да.
Вот ровно здесь.
Чтобы префикс рос.
Вот для чего нужен правый вывод.
Давайте пока так скажем.
Найдем место вывода, где xn появился.
Сейчас, чтобы обозначить,
мне было коллизии.
Прямо все отсюда спешу.
Так, s'
вводится звездой.
α'
b, y.
А новый вводит.
α'
γ, xn
Δ, y.
И оно выводит как-то со звездочкой.
Че у нас тут?
α,
а, w.
Значит,
α'
γ,
x1,
xn-1.
Так.
Че тут написано?
Да-да-да-да.
Я тут n написал просто очень криво.
Смотрите. Было правило b.
Что с ним случилось?
Вот он вывел свой xn.
Попутно вывел что-то назад и что-то вперед.
Возможно, xn появился не само.
Кто-то еще с ним вместе появился.
Вот я говорю, что у меня было правило.
Я сейчас запишу.
Где бы это дописать?
Тот факт хороший, вот этот факт плохой.
Значит, b-стрелочка.
Че у нас там?
γ,
xn,
δ.
Так, я сейчас закончу стереом 5-10, потом сделаю перерыв
и потом как раз за пол-лекции
расскажу, почему алгоритм работает,
и как вообще нужно в простак уходить.
Вот мы как-то получили этот xn.
А потом
в этот кусок вывода.
Давайте его напишу здесь.
α,
γ,
xn,
δ,
у со звездой выводит α,
а, w.
Здесь напишу только
правее
xn.
То есть,
что тут нужно говорить?
Нужно говорить, что я пускал вместо xn?
Вот.
Потом из пуска
δ, у,
возможно в δ, у были не терминалы.
Весь этот вывод,
xn вообще не трогает.
Потому что если бы
xn как-то раскрылся,
то мы говорим, что xn появился в правиле
после него, поскольку это последняя встреча
xn в правилах.
Значит, вот здесь у меня xn не появлялся на этом месте.
Вот Борис правильно сказал,
что нам важен xn на позиции,
в начале слова.
Этот вывод пилим на две части.
Мы находим момент, где появился xn,
где его сгенирировали,
а дальше,
кусок, который после него дошел до
α, а, w,
так что xn никак не трогался после этого.
Вот ровно это правило,
в этой ситуации нам не нужна.
Давайте генирировать, какая ситуация из него
будет следовать.
B стрелка, γ,
xn,
δ, v,
допустимо.
Так, для чего?
Для
v, k, g, xn, xn-1.
Тут еще нужно аккуратно
проверить,
как вот этот v
маленький связан с q.
Мы просто тогда здесь скажем,
что вот
где стоят точки?
Одна точка стоит
α' вот тут,
а,
и потом a открывается
куда?
α, β,
w точка стоит вот тут,
в начале правила.
Вот этот v маленький
так, здесь w.
Так, я сейчас, возможно, тут
не скажу, как они согласуются,
или...
Так, значит, возьмем вот этот вывод
и вот здесь.
Значит, i, b открылся вот так,
точка стоит вот здесь,
а,
б открылся вот так,
точка стоит вот тут.
Что после него находится?
После него находится вот этот вот y.
Что?
Нет, вы видите, что v равно y?
Я хочу сказать, что... Очевидно, что v равно first от y,
это да. Я хочу сказать, как вот этот v
связан вот здесь.
Давайте пока это опущу, может, после перерыва скажу.
Ну, а дальше мы просто должны сказать,
что после вот этого xn,
вот эта ситуация,
где точка стоит после,
она допустима вот здесь,
но она не просто допустима,
она еще и будет добавлена на первом же шаге.
А потом
нужно зависеть от момента, когда появляется a.
Давайте тогда сейчас сделаем перерыв на 5 минут.
Я сейчас тут сложу все обозначения
и к концу перерыва все это сделаю.
Причем поскольку будет a, w, вот здесь,
а y это что-то, состоящее
из маленьких букв,
поскольку вот тут b
раскрывался сюда.
Вот b раскрылся. Значит, стало быть,
y это строка из маленьких букв тут.
Поскольку delta y
приводит a, w,
это означает, что здесь
применяется правило вида, вот правый интерьер,
открывается что-нибудь. Более того,
то есть di открывается как di плюс 1 и tti.
И tti тоже из маленьких букв состоят.
Отсюда следует, что у нас
действительно вот этот v
это first
от y, и оно согласовано с u,
потому что y в будущем
вот здесь
di плюс 1
Да.
u это будет first от всех t
и еще в конце на y.
То есть мы говорим, что вот delta
это такая строка, в которой сидим в большом не терминале
и маленькие буквы.
В будущем это не открывается в другой не терминал,
в третий-четвертый не терминал, вот так оно открывалось.
И здесь согласовано
u, который находится вот тут,
и v,
который находится вот здесь как first от delta y.
Надеюсь, объяснил.
Что? Смотрите, у вас здесь
у, не у, у.
Это строка из маленьких букв, из терминальных букв,
поскольку у нас b открывалась.
w это тоже строка из маленьких букв, поскольку a открывалась.
И мы знаем с вами, что вот этот вывод
не трогать ничего
от x и на дальше, вот здесь сюда.
Стало быть, из delta y вводится a w.
В дельта вначале стоит не терминал
какой-нибудь, и все, что с ним
происходит, это он открывается в другой не терминал,
а с ним после него буквы идут.
Другого спроса никакого нет.
Что?
Здесь строка a.
Я помню, о чем вы говорите.
Внутри дельта мы говорим,
что здесь какой-то не терминал, который каждый раз открывается.
Здесь все-таки в тетах может быть не терминал.
Спасибо.
Ключевой момент в том, что
a возникает как открывание
первого же не терминала вот здесь.
Вот.
Теперь с конспектом.
Все, я правильно сказал.
Так.
Проверяем.
Вот.
И что тогда надо здесь увидеть?
Надо видеть тогда, что ситуация
с a,
точка, вот здесь возвращаемся,
точка beta2 будет добавлена
после m плюс одного замыкания,
где m от количества выводов такого вида.
То есть я говорю, что я нашел
вывод тра пылс и ксен.
Сказал, что правда для него была добавлена,
поскольку оно было два на первом же шаге.
После этого сказал, что здесь
все выводы начинаются с большой буквы,
не с маленькой.
Значит, они будут другое предсказать.
Здесь какие-то m шагов,
и вот за m таких предсказаний,
таких замыканий я получу из вот этой ситуации
вот эту ситуацию.
Вот здесь.
Вот это есть вопросы?
Да нет?
Надеюсь, понятно.
Ну и теперь давайте сам алгоритм уже
разберем чуть-чуть.
Да?
Смотрите.
Я говорю, что пусть такая ситуация допустима.
Если beta1 был не пуст,
то я просто точку туда придвину и все.
То есть beta1 пуст.
Эта ситуация появилась как какое-то замыкание.
Я говорю тогда, я должен отследить момент
с замыканием чего она была.
Это на практике, в теории.
В теории отследил момент, когда у меня
ксен появился.
Вот этот тут ксен.
Вот он появился.
После этого, сколько он появился,
после происходило,
это префис не трогало.
Еще что-то происходило, тут был какой-то не терминал,
еще что-нибудь.
Оно выводилось, выводилось, выводилось.
Первый не терминал в ажот открывался.
ДИ в ДИ плюс 1 ТТИ.
Я говорю, что если таких шагов
было М, то через М замыкание
я получу из
вот этой ситуации.
Вот здесь видите, точка при дельте стоит.
И вы поняли, что в дельте находится первый сил
не терминальный, который открывается.
Если у меня таких замыканий,
по правилам, которые в этом выводе участвуют,
я получу вот это вот правило,
А, сцелка точка B2.
Значит, здесь
поймите идею, что нужно просто
посмотреть, как эта штука была предсказаться.
А формальности вы все
при конспектном посмотрите перед экзаменом
и когда будет это дело писать.
Это сейчас на вид вот так вот здесь сложно
понять именно строго.
Поймите интуитивно.
Так, теперь давайте
посмотрим.
Значит, итак.
Управляющий лир таблицы называется парой с двух функций.
Функция действия и функция перехода.
Чего у нас тут?
Значит, мы хотим запустить МП-автомат принос свертка.
Делать вот действия
перехода.
Отвечаем на вопрос, что делать?
Начнем примерно вот состояние.
Так, дальше
вот состояние. Вот посчитали мы все ВК
уже от какого-то префикса.
Сказали, что их конечно много.
Давайте их занумируем и скажем, что
вот это состояние,
то есть у нас штука большая, состояние
анализатора.
Штука большая и
строка, я напишу звездочка K,
это строки длины K и меньше.
Множество из четырех элементов.
Первая, значит, shift,
вторая, reduce по этому правилу,
отказ и принятие.
И второе,
это функция перехода.
Из кул в
n объединить сигма,
переходим в кул.
Функции перехода мы сами уже построили.
Ну как мы построили?
Из состояния какого-то
по маленькой буквы переходим в go to от этой буквы.
То есть, если здесь
ВК для
x1, xn-1,
а тут у меня xn,
то тут у меня ВК от x1, xn.
Считайте, что это какой-то такой вот
mp-автомат здесь.
Уже обычный, то есть он ходит по состояниям.
Вот он, переход.
Состояние по букве переходим в состояние.
Давайте поговорим о функции действий.
Да, да, да.
Функция перехода, функция действия.
Функция перехода, куда идти,
шифт, редюс, отказ, принятие.
Давайте вспомним, откуда
вообще такие ситуации возникали.
Эти вот множества замкнутые.
ВК какие-то.
Еще раз,
построили все ВК.
Занумировали их.
Их конечно много, мы поняли, почему их конечно много.
Это состояние
анализатора.
Так? Все.
Теперь я говорю,
переход и состояние
какого-то по букве.
Это go to из этого состояния по этой букве.
Go to это предлетие m5-10.
Функция действия.
Как мы говорили, состояние это то,
где по мнению анализатора мы находимся.
В каком правиле?
Что мы знаем?
Из s, вот он,
a, beta1, beta2.
Давайте поймем две вещи.
Первое. Если вдруг мы какое-то дерево дочитали,
не надо делать никакие переносы.
Если вдруг точка находится в конце,
сверху поднимаемся наверх.
Если вдруг здесь где-то, вот эта точка находится тут,
и мы тут раскрыли, где-то точка находится в конце
пониже по дереву, надо все равно подниматься наверх.
То есть,
правило, нельзя переносить букву
не из текущего под дерево.
Пишу здесь.
А, стрелка,
бета, точка,
у.
То есть, мне пришло на вход.
Q и у.
Что делать?
Вот идем по ситуациям.
И видим такую ситуацию.
А, стрелка, бета, запятая у.
Что надо делать? Есть какие-то идеи?
Вот у вас.
Вы знаете, что вы какую-то ситуацию
дочитали до конца?
Да?
Смотрите, автомат переноса свертка.
Автомат переноса сверта
переносит на стэк при правильном исполнении
только в случае, когда текущие правила
еще не дочитаны. Если текущие правила
дочитаны, он сворачивает, он не переносит.
Почему? Потому что тут у него стоит правая часть
какого-то правила, он поставит сюда
букву, то он эту бету не свернет.
Стэк устроен так, что нельзя обратиться к стэку,
пока вы это не снимете.
Потому что правильность
автомата переноса сверта нужно было понять во время семинара.
Правец исполнения
подозревает, что переносит только
букву, которая нужна текущему правилу.
Буква из текущего под дерево.
Ну, что у нас здесь получается?
Мы хотим сделать свертку.
Это редьюз. Вот он.
И это
вот этого правила.
И мы согласуем, что то, что мы видим в слове,
вот каретка,
как мы видим в слове,
это ровно то, что
в стучении анализатора
должно там находиться. Вот оно у в конце.
Значит, это редьюз.
Дальше.
А, стрелка, бета 1,
точка А, маленькая, бета 2,
запятая В.
Давайте с вами поработаем. Что бы вы хотели тут делать?
Вот этого нет, вот это вот.
Да.
Здесь есть А маленькая, но
надо проверить, что у нас...
Шифт. А теперь давайте условия писать.
Здесь мы видим У.
Вот нам в слове пришло У.
А здесь мы видим, что вот после точки
находится А, бета 2, да еще и В.
Поэтому мы говорим, что
У равно first
от А,
бета 2 и В маленького.
Так, а теперь глаза сюда.
Сейчас будет магия.
Давайте с вами дальше
работаем.
Смотрите, вот я вам сказал три случая.
Точка в конце,
точка перед маленькой буквы,
где еще точку вы можете поставить?
Перед терминалом. О!
А,
стрелка,
бета 1, точка В,
бета 2 В.
И пусть она все согласована.
У равен
first, В,
бета 2, В.
Что бы вы хотели делать?
Шифт или редюс?
Смотрите, я сказал, что нужно делать шифт,
тогда, когда вы читаете
вот эту подель, вы дочитали до конца,
точка тут поставилась, редюс, поднялись наверх.
Тут?
Я согласован, это значит,
что мы все согласованы.
Что будете съедать?
Вы хотите
посмотреть, что там в В было?
Давайте я напишу шифт, пока не пишите
ничего.
Вы предполагаете, что
В, вот он В, в дереве,
открывается как-то где-то внизу,
еще где-нибудь как-то,
и в конце точка будет перед маленькой буквы,
то есть вы спутитесь по дереву вниз.
Нет, нет, нет.
Вы не можете.
У вас шифт не двигает точку сквозь В.
Шифт двигает букву маленькую на стэк.
Понимаете, что здесь
это просто способ понять, что делать.
Ставить букву на стэк или не ставить.
Автомат переносит свертку, никто не отменял,
он все еще работает так, как он работает.
Ставим букву на стэк, сворачиваем правую часть.
Просто здесь подсказывает автомат переносит свертку,
что это шифт или редюс.
То есть у автомата есть мнение о мире,
что вот я сейчас читаю правила А,
то есть я буду сворачивать.
Тут есть мнение, что я сейчас читаю вот это правило,
никакое другое.
Делаю шифт здесь.
Хочется сделать шифт.
Почему?
Я читаю сейчас правила B1, точка B2.
У B это висит какое-то дерево внизу.
Вот оно.
Какое-то дерево висит.
Где-то там есть точка перед маленькой буквы,
мы ее и шифтим на самом деле.
Понятно дело, что поскольку у нас замыкание так устроено,
что здесь находится что?
Согласованы все слова,
то есть если мы здесь замкнули,
то вот эта часть согласована вот здесь.
Вот там везде ферсы совпадают.
Я не буду сейчас додаваться подробностей.
Это будет шифт, кроме одного случая.
Нарисую пример.
Из S выводится вот A.
Из A выводится
β1,
B, β2,
тут находится В.
А что, если у нас
над β висит пустое дерево,
пустое слово?
Тут висит 100 терминалов, с которыми висит пустое слово внизу.
У каждого.
Тогда
ваш вот этот ферст реализуется вот здесь.
Это буквы,
которые будете шить, находятся вот здесь.
Что вы взяли?
Вы шифтили буквы, которые находятся в тягущем по дереве.
И вот это все сломалось.
А что надо делать в таком случае?
Надо делать редьюз.
Поэтому мы говорим,
что мы делаем не по ферсту.
То есть давайте явно запретим такие конструкции.
То есть мы говорим,
такое правило голосуется
за перенос,
только если
из B не вводится пустое слово.
Возможно из B вводится там, не знаю,
B выводится
β штрих альфа.
А отсюда вводится β2 штриха
альфа альфа штрих.
И там еще что-нибудь и все.
Но в конце самый правый терминал
открывается в пустое слово.
Запрещаем такие выводы.
То есть мы говорим, делай ферст, делай шифт,
только если в выводе вот этого.
Что такое ферст?
Выводим все слова и проверяем их префиксы.
Делай шифт, если ты выводишь все слова
только такими выводами,
в которых у вас нету такого
случая, что первый самый не терминал
в пустое слово превратился.
А как называются такие выводы,
которые ферст и запрещают
первому терминалу превращаться в пустое слово?
Если кто-то понимает все,
еф.
Вот если у вас еф
уровной, еф,
а б, бета2в,
это означает,
что у вас здесь б, пустое слово не откроется.
Это означает, что у вас здесь будет маленькая
буква. Та самая буква,
которая будет в слове, и вы ровно и нас таки положите.
Поэтому
вы когда пишете в теории, вы пишете, что
это правило,
только если у вас не ферст, а еф
совпали, тогда это шифт.
Если еф не совпал, то это
правило ничего не дает.
На практике что делать? На практике
такого правила не рассматривайте вообще.
Почему? Мы с вами поняли, что если у нас есть такое правило
и все не терминалы у нас порождающие,
это правило в стиле замыкания приведет вас
к одному из двух случаев.
Ну, собственно говоря,
где оно было написано?
Либо такому, либо такому.
Поэтому когда вы пишете аллер, вы смотрите,
вот это редюс, это шифт.
А вот это
выбрасывается.
Увидели?
Поэтому везде в теории у меня написан еф, а не ферст.
Сейчас еще раз. На практике
в этой ситуации
сигнализируйте. Потому что
если оно у вас есть,
и все не терминалы у вас порождающие, то у вас
нету бесценных символов в грамматике.
Ну, если вы применяете
грамматику для...
Ну, я сейчас говорю, если вы применяете
лр-грамматику с предыдущей силой, то вы странный,
так не надо делать.
Смотрите, значит,
тогда я говорю, в теории
эта ситуация голосует за шифт
только в одном случае. А теперь давайте посмотрим,
а почему у меня бывает такое,
что если у меня редюс, то редюс
по одному правилу, еще шифтов рядом нет.
А если шифт, то никаких редюсов нет.
Давайте подумаем, в каком случае
будет шифт и редюс одновременно. Вот эти ситуации
у вас конфликтовали. Это означает,
что у вас для у верно, что у тут совпал,
а еще уровень first
от a,
бета, 2, в.
В таком случае
для вот этого самого у будет конфликт.
Вот это редюс, а это шифт.
Или у вас будет а, стрелка,
бета с точкой у, и там
а1, бета, 1, у. То есть какие-то ситуации.
Напишу, в каком случае.
Кто конфликтует?
Идем сюда.
Я уже вижу себя в зале и понимаю,
на что намек.
А, стрелка,
бета. Поскольку шифты не конфликтуют,
а не как бы шифты, конфликтуют редюсы.
Вот такая ситуация.
И а, штрих,
бета, 1,
точка, бета, 2,
в,
уровно, е,
от бета, 2, в.
Ну, сейчас
казалось, что теперь у меня каждая ситуация
вместо что-то голосовать.
Пусть так получилось, что вот это голосуют за редюс,
а вот это голосуют за шифт.
Либо за другой редюс.
То есть вот это разные ситуации какие-то.
И у совпало
с е, в, бета, 2, в.
Понятно, почему такие ситуации конфликтуют?
Потому что вот эта ситуация,
либо точка в конце, тогда это
просто две разные ситуации.
Либо точка перед маленькой буквой, тогда это шифт против редюса.
Либо точка перед большой буквой,
но поскольку у нас е, нормально устроено,
вот этот у, они попали вместе,
вот он, е от q, у.
Вот этот вот у совпадет вот здесь,
и это будет шифт.
Вопрос-то, почему такие ситуации конфликтовать
не буду? Есть какие-то идеи?
Теперь 5, 9.
То, что мы доказывали.
Увидели?
Ну, давайте так, сайте чек.
Первый ряд вы увидели?
Вы не увидели? Вы теперь 5, 9 не помните,
или вы это не понимаете?
Ну, саму телему еще вам вспомните.
Так, второй ряд.
Вы понимаете, что происходит?
Да.
5, 9 перечитайте потом,
вы здесь что происходит, понимаете?
Почему это две конфликтует?
Ну, еще раз.
Почему эти две конфликтует, понятно?
Ну, потому что это reduce,
это shift.
Георгий, ты понял?
Это что теперь?
Теперь 5, 9 говорили, что
есть такая ситуация, а такой ситуации не будет.
Вот все, ровно она,
ничего другого там не было.
А почему
9, 9 перечитают, вот тут объяснил,
потому что вот эти ситуации конфликтует.
Вот их тут написал в общем случае,
и будет ровно информировка телепедия,
магия.
Так, теперь давайте побуду алгоритма.
Ради чего вообще все это строилось?
Мне сегодня сказали символисты,
что жаловаться не могут алгоритм,
потому что нет алгоритма.
Вот сейчас появится алгоритм,
а у него будет жаловаться.
Так.
Давайте посмотрим.
Есть stack.
Давайте
говорим, что у нас состояние 0.
Это
v, k, j от эпсилон.
Что будем делать?
Вот наше слово.
Корректно находится вот тут.
Шаг номер 1.
Смотрим k букв, либо меньше букв,
если в конце слова.
Сейчас учтите, что у вас доллары в конце всегда есть,
нельзя сказать меньше букв.
Говорим, состояние 0,
k таких букв, идем в функцию f.
Пришли в функцию f,
смотрим f от q, u.
Это что?
Здесь не смотрим на ситуации.
Мы заранее в предпочтении уже написали,
что f от q, u это либо ruse, либо shift.
Теперь запомните один факт.
О природе ситуации можно забыть.
У вас lr разбор.
Это q как некоторое множество,
и u как слово.
Потому что lr
это lr на стероидах.
Устроен так, что он забудет про то,
что тут ситуации.
Он перестанет как-то по-хитрому
и получит снова q и u.
И никаких ситуаций тут не будет.
Поэтому запомним, что на это предпочту это.
Мы в этой функции явно написали,
что f от q, u, 1, u, 1 это shift.
f от q, 2, u, 2 это ruse.
И забыли про то, как устроены q.
Это уже не ситуация, просто числа.
Смотрим сюда.
f от q это что?
Если это shift,
берем эту букву.
Нужно прийти не только, чтобы одна буква совпала,
а все буквы совпали.
k-буква совпала, делаем shift.
Пишу a.
На стеке появилась маленькая буква.
Иду в функцию g.
Где он тут написан?
Не написан.
Вот написан.
Из 0 по a иди в 1.
Иду в 1.
Что ты там сделал?
f shift это буква на стеке.
По буквам можно перейти.
Пишем reduce.
b2, c3.
Пусть мне говорят взять reduce
по вот такому правилу.
Я стираю все буквы, еще и всю историю.
Вот оно.
Увидели?
И говорю.
Резавтра вот reduce это вот эта буква.
Она поется на стеке.
И состояние 0
по букве a.
Я пойду в состояние
4.
Резавтра работает shift.
Это появление на стеке маленькой буквы.
Я пойду взять переход.
Резавтра работает reduce, это переход по большой буквы.
Я пойду взять переход.
И так вот действует.
Смотрите.
Что это автомат переноса свертка?
Берет правую часть, пишет левую часть.
Смотрим сюда.
У нас в правой части между ними еще числа находятся.
Мы храним на стеке еще и состояние.
Кто будет это писать?
Смотрите тут.
Это пары.
Это написали, что это стек из 0a1b.
Вот так не надо делать.
Это стек пар.
Сняли 6 символов.
Что?
Ну тут разбивается.
Так.
Ну еще раз.
Вам просто нужно хранить вот эти вот пары.
С3, b2, a1.
Вы строите всю историю.
Смотрите правую часть правила.
Поскольку это reduce и все согласовано,
она будет на стеке находиться.
Что?
Еще раз.
Смотрите.
Я говорю, что я сделал shift.
Поставил букву.
Появление буквы на стеке,
это повод взять переход.
Я говорю, вот был в 0.
По букве a перешел в 1.
Увидели?
Да.
Вот эту букву, которую я получил,
пишу на состоянии.
Когда делаю reduce, я стираю всю историю.
Пишу результат reduce.
То есть большую букву у нас.
Вы не видите abc.
Вы видите, что надо делать reduce по этому правилу.
А алгоритм гарантирует, что на стеке будет abc.
Два n букв.
Да, да, да.
Но по этой стеке буква a.
Буква a по линии на стеке, это по взять переход.
Делаем переход из 0 в акт по 4.
Когда мы видим
reduce по правилу
s-s.$,
если мы его свернем,
вывод окончен.
А теперь давайте сейчас вот две строки.
В одну строку крест, в другую строку полнота.
Так, понимаете, как это работает?
Смотрите.
Если вы стерли учетное число символов,
число торчит на стеке.
Поставили большую букву.
Из этого числа по двух взяли переход.
Не из этого числа.
Из вот этого числа.
Сейчас покажу почему.
Такая вот мини-лемма.
Да.
Как у нас вообще работает?
Смотрите, вы смотрите на зерещи.
Первое. Вот.
Харедка находится вот тут.
Что видно в слове? Вот это видно.
В каком стадии мы находимся?
Вот в этом находимся.
В 3,
под такой строке,
найдет reduce.
Мы заранее, вот здесь,
на этапе предподсчета,
написали, что из состояния 3
по строке u
делаем reduce по правилу i.
Ну вот я этот reduce и делаю.
Я не проверяю,
чтобы на стеке находиться то, что нужно,
потому что теория это гарантирует. Вопрос.
А если у вас
ничего не сделать?
Не shift, не reduce?
У вас в каждой ячейке
есть одно из четырех значений.
Shift, если shift, reduce, reduce.
Приняйте, если это свертка по правилу
3 с точку,
если вы свернули сюда, вот кончился.
Это приняйте. Вы не делаете все до конца.
Если ничего из этих трех, то отказ.
Вы говорите, что это невозможно.
А зачем нам вообще
что-то кроме цикров
состояния на стеке?
Мы же его не используем. Мы же его кушаем, а потом отбрасываем.
Хорошее наблюдение.
Кажется, что он не нужен, да.
А, ну, на самом деле он нужен в теории,
потому что поставили сюда что-то, а потом
что-то перешли.
Но да, можно не хранить.
Называется stack состоянии.
Но это, понимаете, для реализации. Я рассказываю теорию,
как ее кнут написал, так и рассказываю.
Но блин, очень классно.
Так, члемма.
По ходу работал гритм,
но вот он собирает выводы.
Если мы их будем собирать, давайте скажем, что вот x.
Альфа
это наш stack.
Вот это stack.
X это то, что нам осталось прочитать.
И п выводит w на каждом шаге.
Ну, члемма.
Если мы набрали какой-то вывод p при помощи действия алгоритма,
то можем этот вывод использовать,
чтобы вывести из stack
остатка
все слово.
Понятно, что написано.
Берем stack, приклеиваем к нему то, что мы не прочитали,
и при помощи именно этого вывода
можно вывести w.
Это будет совсем тривиальный факт.
Давайте посмотрим. Это верно на любом шаге индукции.
У нас p пустой,
альфа пустой,
x и w равны.
Верно.
Если мы взяли shift,
то мы взяли букву отсюда,
принесли ее на stack.
При приклеивании все равно будет альфа и х,
оно не поменялось.
Тоже верно.
Следующий факт.
Если был reduce,
вот был альфа и х.
Что сделал reduce?
Ну, это так вот.
Альфа штрих бета и х.
Он взял бета, поменял его на а.
Stack стал альфа штрих а х.
Так?
Что? Смотрите, я сказал,
что мы здесь собираем вывод по номерам.
Вот пока работает алгоритм, мы этот вывод набираем.
Вот этот вывод хотим применить.
При помощи этого вывода,
именно этого, не какого-то другого,
а именно этого вывода.
Еще раз.
Был альфа штрих бета,
стал альфа штрих а.
Очевидно, что за один шаг
получаю из а бета.
Почему получаю?
Потому что у меня reduce был ровно по этому правилу.
Вот он здесь и написан.
При добавлении того шага вывода
из этой строки выводится w.
Понятно?
Илья?
Еще раз.
На нулевом шаге все верно.
Что?
На нулевом шаге все верно.
Stack пустой, слово полное.
Ничего не происходило.
Можно просто?
На каждом шаге алгоритма.
Если взять текущий stack,
вот этот stack,
клей к нему остаток слова.
То есть у нас каретка тут находится.
То, что мы еще не шифтили, склеили.
Возьмем вывод, который мы построили до этого шага.
Вот мы делали что-то в алгоритме.
Каждый reduce добавляет в вывод новое правило.
Берем этот вывод.
Применяем этот вывод.
Можно вывести w. W это исходное слово.
Поняли? Прекрасно.
На нулевом шаге это верно?
Да. Если мы делали shift, это верно?
Буква отсюда-сюда прискочила.
Ничего не поменялось.
Вывод не поменялся. Просто буква была тут, стала тут.
Но они же склеены все равно.
А на reduce вот оно, что происходит.
Был beta, стал a.
В обратную сторону был a, стал beta.
Вот он вывод.
Я отсюда пришел сюда, а здесь по индукции дальше довел.
Увидели?
Увидели?
Прекрасно.
Отсюда следует, что если у нас алгоритм взял принятие,
то у него последний шаг вывода был s' vs.
Что у нас происходит в конце?
Стэк у нас просто s.
Слово у нас значительно до конца.
При помощи wdp вводится дубль o.
А алгоритм корректен.
А алгоритм сказал, что есть вывод, то есть вывод реально есть.
В обратную сторону.
Пустил, алгоритм дал отказ.
То есть вот у меня был какой-то стэк.
Была какая-то цепочка.
Давайте так. Вот слово.
Это мы прочитали, это мы подледели.
Так получилось, что алгоритм говорит,
отказ, ничего не хочу делать.
Что это означает?
Что в этой ситуации нельзя делать ни шит, ни редьюз.
Давайте подумаем,
что это может означать.
Ага.
Если бы что-то можно было сделать,
была бы допустима такая ситуация.
Мне нужно минуту записать все правильные, гениальные мысли.
Давайте посмотрим.
Поскольку у тебя ничего сделать,
у нас нет допустимых ситуаций.
У нас нет такой ситуации.
А, стрелка.
Либо бета с точкой у.
Либо а, стрелка.
Я буду пользоваться аннотацией, которая через е,
она мне удобнее сейчас будет.
Бета 1, точка бета 2.
Запятая в.
Так что вот эти к букв
согласованы либо с у, либо с бета 2 в.
Вот нет такого.
Что это означает?
Это означает, что я не могу вывести никакое слово,
у которого есть к букв таких,
и не важно, что находится после.
То есть, если я беру слово,
которое я прочитал
и которое я подсмотрел вместе, суммарно,
то не существует такого никакого суффикса,
который можно было доклеить сюда, чтобы оно вывелось.
Почему?
Если бы существовало,
то есть, если бы было...
Давайте тут обозначим.
Тут у.
Если существует такое слово,
w' us,
которое можно вывести,
то оно означает, что либо вот это и так,
либо это будет допустимо. По определению,
вы вот есть, ситуация допустима.
Я сейчас позволю себе не писать вот это все
через согласование слов.
Понимаете, почему ситуация будет допустима? Да, нет?
Вы, да, вы, да, вы?
Вы?
Нет, еще раз.
Такое суффикс, это слово Вадима.
Пишем вот это слово.
s'
w' us.
Так?
Ну, мы знаем, что на шаге назад
это все было верно.
Ну, что там получается?
Из s' выводится...
Так.
В прошлой слаге отказа им какой-то
вывод существовал.
Затом alpha a w,
alpha beta 1,
beta 2 w.
Значит, по соку...
Так, мы это посворачивали.
Так, давайте посмотрю.
Вывод этого слова.
Да.
Это мы вот рассмотрели.
Тогда мы говорим, что для стека
alpha, beta 1, beta 2
допустима хотя бы одна из таких двух ситуаций.
Там либо точка к цели, либо точка не в конце.
Но может быть, допустима еще ситуация,
когда здесь нету ефа.
Вот.
А тебе даже
этого даже сейчас не нужно.
Допустима либо это, либо это.
Ну, вот вывод слова.
Возьмем это слово в последнюю встречу этой ситуации.
Допустим. Всего принятия LRK
я буду откатываться в этом выводе
до момента...
Слово начало разбираться.
Значит, тут вывод происходил. Мы смотрим вывод, который
сгнился на шаге, до которого мы взяли отказ.
Ну, вот он тут.
alpha a w, alpha beta 2 w.
Вот оно все работал.
Я утверждаю, что если бы был вывод,
он бы был именно такой.
Сейчас давайте это по-нормальнее скажу.
Если тут какой-то другой вывод,
который получает такой же стэк,
то это нарушение LRK определения.
Вот.
Да, то есть у нас
полноточие тоже подзаклинило.
Вообще факт, который здесь
я либо сейчас, либо потом
еще что-то сделаю,
звучит так.
Что если у меня алгоритм дал отказ,
это означает, что не существует такого суффикса,
что w штрих, который мы уже прочитали
вкупе с k буквами,
которые мы добавили,
еще вообще, не важно что,
оно вообще выводимо.
Как это надо доказывать?
Это надо доказывать тем,
что если бы был вывод, мы бы его записали,
он бы уйден на какую-то допустимую ситуацию.
Допустимая ситуация была бы здесь
и бы уйден на какое-то действие.
Если сейчас я с этим не разберусь,
то я это потом оформлю,
возможно добавлю в конспект, но в конспекте кажется это было.
Вон, это остается один момент.
Момент остается в том,
почему алгоритм вообще работает.
Мы доказали две вещи, первое,
если алгоритм доработал до конца вывод-квампасарbecause он правильный,
это да.
То, что сейчас пытался доказать,
я сейчас попробую с Вами разобраться.
Если он доработал до конца и дал отказ,
это правдая отка, действительно отказ.
Остался один случай.
Что если алгоритм не работает до конца?
То есть он бесконечно долго крутится,
крутится, не читая слова. Но мы это делаем, что от
чтений шифтов линейное количество. Стало быть,
у него очень много редьюсов. Так, значит, здесь нужна
теория. Сколько до конца лекции остается? Пять минут.
Значит, здесь нужна теория, которая гласит, что mp-автомат,
который детерминирован, что означает? Что у него
из двух любых ребер всегда может быть одно. Смотрите
определение у меня в конспекте, я это там дописал. Детерминированный
mp-автомат может конечность много раз. То есть мы имеем
какое-то число для автомата, число c. Так, что если автомат
двигается больше, чем c раз, не меняя своего стека,
то есть вот мы дали отсечку. Если автомат c раз прошел
так, что стек не ушел меньше, чем c, то может быть бесчечно
долго. А дальше следите, это сейчас подсказка доказательности
линейного слр на экзамене, если оно у вас попадется.
На курсах его конечность не доказывает, потому что
это сложный факт. Но вы говорите, что у вас бывают
три типа шагов. Первый, это шифты, их линейно. Второе,
отследим редюсы, которые укорачивают стек в последний раз.
То есть мы смотрим, когда редюс в последний раз стал
стек длины 5, потом длины 4, длины 3, длины 2. Их тоже
линейно. И между ними есть не больше, чем c редюсов,
которые могли подняться и купить обратно до 5. Вот этот
факт, это глава 2 книги А. Хульмана, там это расписано.
Я сегодня пытался доказать, но, видимо, у меня не успею.
А дальше, что вы должны сделать? Описывайте, что на самом
деле подглядывание k символов для автомата переноса
свертка описывается mp-автоматом. Вот подумайте,
как это сделать. То есть нам нужен автомат, который
ориентируется на k-бух вперед, при том, что обычный
автомат не имеет ориентируется на k-бух вперед.
Потом вы говорите, что он детерминирован в силу того,
что у вас как раз таки тут. Либо shift, либо reduce.
Детерминирование автомата интуитивно. Если у вас есть
два ребра, то у них либо слова разные, либо, потому
что снимается стека разная. То есть я всегда знаю,
у меня снимается стека a или стека b. Поэтому два
ребра, у которых есть аа, и просто а снимается с
стека, они конфликтуют. Вот не понятно, первый либо
или второй. Это так, вот идея для чего буду доказывать.
Потом открываем лаву 2. Теорема кажется 2.10. О том,
что для каждой дмп автомата существует такая константа.
Такая, что нельзя оставить стеку на какой-то позиции.
И ходить больше, чем с rs, число не зависит от цвета слова,
только от грамматики зависит. И потом доказываем, что
у нас здесь есть n шагов шифтов, n reducers, которые уменьшают
стек, и между ними еще cn reducers, которые стек не уменьшают.
Что-то такое.
Так, давайте тогда вот момент вот с этим, я оставлю это,
распишу, пришлю в чат. Вот, это какой-то факт, на котором
сейчас нужно обначить много букв. Я сейчас помню, что
в конспекте этого не написано. Тогда на этом, наверное,
всех отпущу. Если есть вопрос, следите спрашивать.
