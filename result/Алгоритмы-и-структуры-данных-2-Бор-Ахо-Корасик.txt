Дальше мы будем добавлять f2. Это еще какой-то другой путь, начинающийся из корня.
Его конец мы тоже обозначим терминальной вершиной.
Может быть, например, такое, что очередное слово частично совпадает с каким-то уже построенным путем, где-то в каком-то месте начинает цветвиться.
Например, s3 у меня. Ну и какой-нибудь s4 может быть вообще префиксом уже добавленного слова.
То есть может быть такое, что у вас одна терминаль является предком другой терминальной.
Это в случае, если одно слово является префиксом другого слова.
Вот.
Соответственно, давайте напишем какой-нибудь мини-код, который добавляет набор слов в бор.
То есть по факту строит бор по набору слов. Обстроение бора.
Так. Ну давайте я скажу, что по умолчанию при создании вершины у меня tu заполняется минусоденицами, как знак того, что нет перехода ни по одной из букв.
А терм по умолчанию false. То есть вершина по умолчанию не терминальная.
Вот. Значит как у меня строится бор?
Ну вот давайте я буду считать, что у меня уже вершина номер ноль в боре лежит.
Да, и это будет корень. Корень нашего бора.
Тогда добавление слова выглядит так.
Давайте я напишу какой-нибудь там void, add, строчку. Как я добавляю строчку в бор?
Надо просто поддерживать текущую вершину, где мы находимся. Изначально это будет корень.
Дальше буду спускаться по этому бору, параллельно лететь по строке, и каждый раз нам нужно пройти по очередной букве нашего слова.
Я буду сейчас в цикле идти, скажем, по всем i от нуля до размера s-1.
Давайте я вот так напишу lem-s-1.
И сейчас мне как бы хочется из вершины v прочитать букву s-i.
Да, и если она уже есть, то мне нужно просто по ней спуститься, а если нет, то нужно ее завести.
Вот это можно обработать, например, так, что если...
Ну и давайте где-то у меня там был какой-нибудь...
Вектор нодов.
А, это, собственно, описание бора как просто набор вершин.
Набор вершин бора, t, v, t, это вершина, отвечающая от значения v.
Итак, значит, если t, v, tu от там s-i минус a равно минус 1,
то это как раз значит, что из вершины v нельзя прочитать букву s-i.
То есть t, v это вершина, у нее есть поле tu, которое для каждого символа хранит номер вершины, куда мы попадаем, если читаем такую букву.
А это минус 1 означает, что такого перехода нет.
Значит, нам надо его создать.
Ну, например, можно сделать вот так вот это.
Равно там t точка size и в t pushback новый вершин.
Тем самым я, получается, обработал такой случай, когда из v не было перехода по нужной букве, а теперь я его создаю и, соответственно, заодно создаю новый вершин.
То есть я в мой вектор pushback новую вершину и говорю, что теперь вот это t, v, в ней переход по букве s-i ведет ровно сюда, вот в эту новую добавленную вершину, потому что у нее был такой номер.
Вот. Ну и все, дальше просто делаю переход.
Спускаюсь как раз по этой стрелочке, то есть мне надо было взять и пройти из вершины v по букве s-i, вот я сейчас по ней прохожу.
Так, это вот этот форм был.
Вот, и в конце надо не забыть пометить ее терминальней, потому что она соответствует одному из слов.
Конец.
Вроде все очень просто.
Да, то есть просто идем сверху вниз по бору, слева направо по строке.
Если буквы, которые мне нужно прочитать, еще нету в списке исходящих ребер, то ее нужно создать, надо создать вот такой переход.
Но потом, если мы его создали или если он был раньше, то я просто спускаюсь по этой букве с помощью этой строки.
Ну и в конце, когда я всю строчку прочитал, надо последнюю посещенную вершину пометить терминальней.
То есть я вот так вот спускаюсь по бору, читая буквы по одной и вершину, в которой я закончил, пометить терминальней.
Вот вроде все.
Понятно все?
Тут вроде все совсем просто.
Так, хорошо.
Хорошо.
Да, еще раз подчеркну, что терминальные вершины, это в точности те, которые соответствуют одному из этих слов, которые в самом начале мне дали.
То есть у меня есть некий набор слов, я их буду называть словарными иногда, словарные слова.
Которые мне дали в самом начале.
Вот, да, ну в словаре в каком-то они лежат, в каком-то множестве.
И вот в точности словарные слова будут соответствовать терминальным вершинам.
Так, хорошо.
Давайте еще обсудим, как можно по-другому хранить множество переходов.
Ну понятно, что если у меня размер алфавита какой-то маленький, то весьма удобно просто с помощью массива хранить, да, для каждой буквы мы знаем переход какой-то быт.
Вот.
Вопрос, что делать если размер алфавита большой?
Вопрос, что делать если размер алфавита большой?
Ну понятно, да, можно хранить мапы или можно хранить хэштаблицу.
Ну собственно, как бы у нас есть всякие структуры данных, которые можно пользоваться.
Ну давайте их по сравнению.
Как хранить множество переходов ту.
Как хранить множество переходов.
Так, да, ну давайте.
Три способа у нас есть, массив, мап и хэштаблица.
Вот.
Ну и давайте скажем еще, что из вершины будет выстировано кастрелок.
Тогда давайте померяем, сколько ему нужно памяти на хранение этого всего и за сколько это будет работать.
Давайте с памяти начнем.
Сколько памяти нужно массива, если я знаю, что из вершины выходит кастрелок, то я буду хранить массив.
Давайте начнем.
Сколько памяти нужно массива, если я знаю, что из вершины выходит кастрелок, а алфавит размера сигма.
Сколько памяти нужно хранить в вершине, чтобы с помощью массива уметь переходить.
Ну сигма, да, просто.
Потому что мне нужно для каждой буквы знать, куда ведет переход.
Ну а если нет, то там какое-то значение типа минус один.
В мапе это, видимо, вот ка.
Я не буду писать, о, я просто буду писать ка.
Хаш таблицы тоже ка, потому что, кажется, если у нас есть ка или мяких хаш таблицы, то она имеет, например, типа 2к.
Вроде у нас какая-то такая договоренность была, примерно.
Вот.
Поэтому здесь с точки зрения памяти все более-менее, ну, пропорционально число переходов.
Вот.
А что еще нужно делать?
Значит, вот, видимо, нужен там проверка существования или создание нового перехода.
То есть вот здесь, да, я сначала проверяю, есть ли такой переход.
Если его нет, я его создаю.
И в конце концов в любом случае перехожу по этому переходу.
Значит, ну вот мне нужно, давайте я просто сделаю запрос.
Потому что это все по факту, как бы, запрос к конкретной букве.
Есть такая буква в нашем массиве или нет.
В массиве работает все за единицу, понятное дело, да, просто вот.
Все эти операции, это обращение к какому-то элементу массива работает за единицу.
Дальше в мапе это все будет за лог к.
И добавление, и проверка наличия, и получение значения.
Это все работает за лог к.
Ну а хаш таблица в среднем учетная единица, да, получается.
Ну, давайте, я пишу, в среднем учетная единица.
Да, один со звездочкой.
Вот.
Ну, поэтому как бы, и видимо хаш таблица прям идеальная всего работает.
Потому что она жрет оптимальное количество памяти.
Не требуется хранить весь алфавит.
Ну и в среднем на запрос отвечает за единицу учетную.
Это более-менее как бы оптимальное всего, что есть.
Но с другой стороны, конечно, хаш таблицу писать сложнее, чем, скажем, использовать массив.
Поэтому, наверное, разумно, если у вас алфавит маленький,
наверное, проще всего с помощью массива это делать.
Вот.
Поэтому, ну, я бы сказал, что, в общем, что-то из этого надо обычно выбирать.
Потому что если у вас обычно большой размер массива,
то, ну, и вам надо использовать либо мап.
Ну, конечно, на самом деле тоже бывает полезно.
Да, что если со временем все достаточно хорошо
и можно вместо единицы здесь использовать логарифм,
то почему бы не использовать логарифм?
Да, вопрос?
Ну, хаш таблица это прям наша хаш таблица,
которую мы в первом семестре обсуждали там.
Ну, или, правильно, какой-то аннордеритмап, не знаю.
Аннордеритмап вроде фигов работает просто.
Ну, прям рукописная фишта таблицы, да.
Вот.
Ну, давайте несколько задач посмотрим про числа.
Значит, первое.
Давайте научимся реализовывать функционал дерево поиска,
если все элементы это числа.
То есть реализовать дерево поиска,
если элементы это числа из отрезка от нуля до, скажем,
2 в кадре минус 1.
Ну, целая.
То есть вставлять, удалить, проверять таблича.
Если мы знаем, что все элементы это числа.
Вот.
Ну, можно, например, просто все числа представить
и сбитыми строками скобить.
Да, и сканули в единиц.
И добавлять их в БОР, как вот такие бинарные строки.
Тогда добавление, это просто вот такая процедура.
На добавление строки в БОР.
Удаление, ну, это там надо опять пройтись по вот этим вот K символам.
И последнюю вершину сделать опять не терминальный.
А проверка наличия это, ну, как бы пройти по БОРу,
потому что мы дошли до какой-то вершины,
и проверка наличия терминальности.
Вот, то есть тут на самом деле решение очень простое.
Сохраним числа.
Как бинарные строки, длинные камеры.
Складываем БОР.
Согласны?
Вот.
Ну, единственное может быть тонкость, что как в идеале удалять.
Да, потому что если мы, скажем, просто пройдем весь путь строки
и просто снимем здесь сложок терминальности,
то есть скажем, что там было true, а станет false.
Вот.
Тогда, если, например, нам сначала добавили кучу чисел,
потом удалили кучу чисел,
то у нас будет большой БОР, где ничего слежать, но нет.
А вот, например, будет такой БОР большой,
где все вершины не терминальны.
Но можно тогда, на самом деле, когда вас просят удалить что-то,
не просто помечать вот эту вот вершину не терминальной,
но еще и пройти все вот эти вот вершины вплоть до первого ветвления
и все вот эти вершины удалить.
Ну, просто чтобы освободить память.
Вот.
И тогда суммарное место, которое занимает ваш БОР,
будет пропорциональное к количеству чисел в нем,
а не...
Ну, то есть тут не будет каких-то вот таких вот пустых веток,
которые ведут в никуда,
да, и как раз тогда память будет пропорциональная тому,
чему надо, к количеству элементов в сайте, в множестве.
Вот.
Второе.
Ну, например, если то же самое,
то мы, например, можем довольно эффективно числа сортировать.
Отсортировать.
Целые числа.
Ну, опять-таки в диапазоне от нуля до два-встепенька.
Вот.
Опять давайте прочитаем все числа, сложим их в БОР,
а дальше мы будем говорить о том,
что мы будем говорить о том,
что мы будем говорить о том,
что мы будем говорить о том,
если мы сложим их в БОР,
а дальше будем, типа,
жадным алгоритмом их все выводить.
Потому что вот есть какой-то большой БОР
большой бинарный БОР.
Вот.
Как найти самое маленькое число?
Ну, понятно надо налево просто идти всегда,
когда возможно.
И если у вас есть развитвление в точке,
то есть можно пойти и по нулю, и по единице,
то понятно наименьше из них имеет ноль
и оно где-то слева лежит, да,
значит надо идти налево.
Здесь вариантов нет.
минимальный из них лежит понятное дело слева.
Но вот дошли до сюда, вы знаете какое самое маленькое число.
Потом, ну как бы, ваши рекурсы возвращаются до первой точки ветвления.
Второе число, соответственно, лежит вот здесь, ну и здесь опять идете по самой левой ветке.
Вот, тем самым простой по факту DFS вам сразу выводит все листья в порядке
вот, в порядке следования слева направо, значит в порядке возрастания.
Просто давайте напишу, что это просто DFS.
Он сразу все числа отсортировает. Согласны?
Хорошо.
Вот, ну это там вкопилку алгоритмов сортировки.
Он, конечно, далеко не самый полезный, но тоже нормально.
Например, с помощью этого же можно строки сортировать, да?
Представьте, что у вас не числа, а строки даны,
и вам надо кучу строк отсортировать.
Вы их также сложите в БОР, потом пройдете DFS в лексикографическом порядке,
то есть предпочитая маленькие буквы большим.
И точно так же, каждый раз, когда дошли до листа,
то вы, получается, вывели, ну не до листа, а до терминальной вершины.
Вы выводите очередное слово в порядке возрастания.
Вот, такая структура данных нехитрая.
Так, есть вопросы?
Ну, это получается за nk.
Вроде бы, потому что добавление такой строки в БОР работает за от ее длины, то есть за от k.
Ну и потом, чтобы все это вывести, нам надо запустить DFS.
Он работает за линейное время размерографа, то есть опять-таки за nk.
Ну то есть, если k маленько, то это хороший алгоритм какой-то.
Но если k большой, то это будет n на 30, что не особенно лучше обычных сортировок за n log n.
Все, ну и теперь с помощью такой штуки, с помощью БОРа мы можем переходить к алгоритму Ахкарасик,
который позволяет решать две следующие задачи.
Значит, задача.
Есть набор словарных слов.
S1, S2 и так далее, SN.
И есть некий текст T.
Ну и надо найти суммарное количество вхождений всех словарных слов в текст.
Суммарное количество вхождений всех словарных слов в текст.
Вот.
Это почти задача о нахождении всех словарных слов в текст.
Только теперь у вас много строк, вам нужно, ну вот, суммарно по всем строчкам вывести все их вхождения в T.
А, если раньше на прошлом деле мы это решали там, например, через префикс или через Z функцию, склеивая две строчки,
то здесь это будет уже не очень эффективно, потому что если вы для каждой строки отдельно
построите такую строчку, для нее бахнете префикс функции, то вы не можете на этой строчке bloat.
То есть здесь это будет уже не очень эффективно,
потому что если вы для каждой строки отдельно.
ely
Построите такую строчку, для нее бахнете префикс функцию
или z функцию,
То...
Ну это долго будет, короче
То есть представьте, что у вас много таких строк
Много маленьких строк, вот таких вот
И один большой текст t
И если вы каждый раз, для каждой маленькой s и t
Будете вот так вот их склеивать
То, ну будет долго, понятно
Потому что если у вас много маленьких строк
То...
И все это работает за линию от t
то это будет, короче
Неприятно
Вот
получше сделаем. Ну и вторая задача здесь же рядышком, почти такая же, нужно найти не суммарное
количество вхождений, а прям вывести все вхождения. Напишу найти все вхождения. То есть прям вывести,
что S1 встречается здесь, здесь, здесь и здесь, S2 здесь, здесь, здесь и здесь и так далее. То есть
прям список всех вхождений с описанием того, какое словарное слово входит и где входит,
то есть прям полная информация о том, где все они, где все они встречаются. Полная информация в
вхождениях. Вот. Ну начало здесь весьма прозаичное, давайте построим бор на наших словарных словах.
Дальше договоренность. Я буду говорить, что слово есть в боре, если его можно прочитать,
начиная с корня. Давайте пример какой-нибудь я нарисую, тупой. Вот если у меня, например,
есть такая ветка, начинающаяся с корня, то я говорю, что epsilon есть в боре, a есть в боре,
ab, abc, abca все есть в боре. Даже если они не терминальные. То есть есть в боре, значит просто
читается из корня. Есть такой путь начинающий с корня по такой последности букв. Давайте я
прям в калычке это возьму. Слово есть в боре, если его можно прочитать из корня. Я мог бы говорить,
слово можно прочитать из корня, но это более громовская конструкция, чем просто что он есть.
Вот я буду так сокращать, буду говорить, что есть, если его можно прочитать. Так, хорошо,
ну вот теперь давайте какой-нибудь пример построим. Пример бора на наборе словарных слов.
Так, или не буду я его делать. Нет, ну видимо надо. Вот так не хочется, конечно.
Ну вот так давайте сделаем. Вот пусть у меня есть четыре таких словарных слова. Давайте
построим на них сначала бор. Как он выглядит? Есть сначала длинное abcaba. Так, дальше abada. Смотрите,
начало есть уже, aba уже есть. Надо только здесь разветвиться и дописать в конце da, cabc и bada. Еще
одна отдельная такая вот веточка будет. Построили бор по исходному набору слов. Дальше опять
договоренность. Я буду всюду теперь дальше отождествлять вершину и ту строчку, которая ведет в нее
из корня. Например, вот если вот это у меня v, то я буду говорить, что v это то же самое, что aba.
У меня вершина бора однозначно соответствует некоторой строке, которая получается, ну,
чтением от корня до нее. Я буду дальше всюду перемешивать понятия вершина и строка. Ну,
потому что как бы по строке однозначно определяется вершина и наоборот. Если есть какая-то вершина,
можно от корня дойти до нее и записать то, что здесь написано, они будут друг другу соответствовать.
А поэтому v всюду дальше у меня будет взаимозаменяться со строкой aba.
Так, все, ну и теперь я могу ввести наконец определение. Link для v это максимальный
собственный суффикс. Строки v, которые есть в боре. То есть вот есть какая-то строка v,
напоминаю v это вообще говоря вершина, но понятно она однозначно соответствует какой-то строке.
Вот есть строка v. Я хочу найти самый длинный ее суффикс, отличный от нее самой, собственно,
значит отличный от всей строки, самый длинный суффикс, который можно было бы прочитать из корня.
То есть вот скажем вот это вот, если эту строчку можно прочитать из корня, то я говорю, что это link
ее. Например, вот здесь вот давайте на строке aba-tsaba, давайте вот на эту вершину посмотрим,
какой у нее самый длинный суффикс, который можно прочитать в боре. Вот смотрим на aba-tsaba.
Вся aba-tsaba своей линкой не является, потому что мне нужен собственный суффикс,
значит хотя бы первый символ мне нужно отбросить. Ba-tsaba такой строки прочитать нельзя,
да, разве что вот bada здесь есть, поэтому b тоже придется отбросить. A-tsaba кажется тоже нет,
tsaba нету, есть только aba, нет и сейчас вот она aba есть, поэтому суффсылка отсюда будет вести вот
сюда, link будет вести вот сюда. Согласны? Потому что я рассматриваю вот для этой вершины, я рассматриваю
какая строка ей соответствует, это строка aba-tsaba, я перебираю все ее суффиксы в порядке убывания длины
и оставляю максимальный, который можно было прочитать из корня. Ну вот здесь aba является ее
суффиксом и также можно ее прочитать из корня, вот она aba, поэтому стрелка ведет вот так. Дальше,
например, для строки abada, для вот этой вот строки, для этой вершины мы можем, мы видим, да, что это
строка abada, вот она, и можно, например, оставить вот такой ее суффикс, потому что есть такая строка,
значит суффсылка отсюда будет вести вот сюда. Ну просто оставляю максимальный суффикс,
который можно прочитать из корня, и так делаю для всех вершин, например, для вот этой вот sa,
для строки ca у меня суффсылка будет вести в a, потому что вот это максимальный суффикс,
который можно прочитать, для строки ca-b можно оставить суффикс ab, ну и так далее, короче,
для каждой вершины я определяю линк вот просто по такому правилу вот это первое
второе что мне будет нужно это go для каждой вершины и для каждого символа
алфавита на ц это какой-то элемент сигмы ц это элемент сигмы это максимальный
суффикс строки в плюс ц который опять таки есть в боря
вот то есть что будет если я возьму строчку в припишу с них к ней вправо в конец буковку
ц какой теперь у этой строки максимальный суффикс который есть в боря причем уже не
обязательно собственно здесь слово собственно я не пишу возможно он совпадает со всей строкой
в плюс ц да но в общем случае это что-то вот такое какой самый длинный суффикс такой строки можно
прочитать из корня так ну давайте тоже какой-нибудь пример я нарисую если здесь
что-то содержательное ну например вот отсюда смотрите а нет тут такое уже тоже есть а да вот
например смотрите отсюда если я буду из этой вершины пытаться приписывать букву ц то я попаду
видимо вот сюда вот потому что смотрите вот у меня есть такое длинное слово аба цаб и я пытаюсь
дописать в конец букву ц ну понятно просто дописать вниз ц нельзя потому что нет такого
перехода но я могу дописать эту букву отбросить первые три буквы и у меня получится ц и аб и ц
и я попаду вот сюда поэтому у меня будет вот такая вот стрелка гоу по букве ц логично
вот но вроде более длинных суфиков суффиксов таких нету ба ца нету а ца нету значит да действительно
вот это самый длинный суффикс который получается после дописывания буквы ц вот ну и опять-таки
я хочу эту же штуку насчитать для всех вершин и для всех символов для каждой вы для каждого ц
знать куда я куда я перейду какой останется самый длинный суффикс если я дописываю одну
буковку вот такие такие вещи соответственно алгоритмах карасик он насчитывает и линки и
вот эти гоу все что делать алгоритм это их просто вычисляет давайте давайте поймем как он это делает
он находит линк от в для всех в и гоу в ц для всех в и для всех символов алфейта ц
так значит как он это будет делать вот у меня есть построенный бор я буду по нему идти чем-то
в стиле бфс а я буду обрабатывать вершины порядка увеличения глубины сначала обработаю
корень потом обработаю все вершины на глубине 1 все вершины глубине 2 3 и так далее то есть по
факту просто запущу бфс в этом графе тем самым буду перебирать вершины порядка увеличения
расстояния от корня теперь пусть для вершины в я уже посчитал все что нужно я посчитал для
нее но точнее не так я посчитал линк и гоу для всех вершин на глубины не больше чем глубина в
в частности для в вот пусть здесь у меня все пощита дальше из в выходят какие-то ребра я хочу
понять ну например я хочу понять какие у этих вершин будут линки потому что это какие-то
вершины бора в них еще не посчитано ответ я хочу понять какие линк будут для этих вершин но давайте
скажем что здесь будет какая-нибудь буква ц давайте конкретный переход один рассмотрим у меня
вот есть конкретный переход по букве ц он ведет меня вершину у я хочу понять чему равно линк от у
значит смотрите у меня была строка в я к ней приписал один символ ц у меня получилась строка
у хочу понять чему равно линк от у вот значит мне нужно оставить максимальный
собственно суфик здесь на который можно было бы прочитать искорно я утверждаю что линк считается
следующим образом значит это либо 0 если вы равно 0 напоминаю 0 это у меня всегда номер корня
вот а иначе это go от от линк от в по ц
вот значит почему это верно но в случае если вы равно 0 то линк равно 0 очевиден потому что
если вы это корень то у это просто один символ и что такое линк от строки из одного символа это
максимальный собственно суфик с которым можно прочитать из корня но извините если у состоит из
одного символа то единственный ее суфик собственно этот пустая строка которая соответствует
сочности корня поэтому этот случай тривиально вот теперь откуда берется вот это вот безобразие
так давайте соображать то есть во первых что такое линк от в линк от в уже оставляет от
какой-то максимальный собственно суффикс на какой-то суффикс то есть вот было большой
в я от нее оставил некий суффикс линк prettier дальше я приписываю вот к этой стрurança уже
буковку ц и оставляя от вновь получ影 falsely robbery самый длинные суффикс да потому что
такое go этоожалуйста самое длинное суффикс а после приписыванияProfessor и вот як вот ты
ст face Dassault Liu и оставляю самый длинный суффикс который есть в боре то естьzw Moroccan
Ну и я утверждаю, что это в точности то, что нам нужно,
потому что я сначала дописываю букву C, а потом оставляю
самый длинный собственный суффикс, но я вот сначала
оставил в принципе самый длинный собственный суффикс,
который был вот здесь, а потом вспомню, что еще
C нужно добавить, значит мне нужно отсюда еще по
переходу GO сделать, пройтись по переходу GO, чтобы оставить
самый длинный вот в точности у такой строки собственный
суффикс.
Смотрите, давайте вот это утверждение докажем,
с первым случаем понятное дело мы это разобрали.
Во первых давайте сначала с корректности это все разберемся.
Почему в обще я выделяю отдельно, выношу этот случай,
если вы равно нулю.
Потому что если вы равно нулю, то я не имею права запрашивать
линк от нуля.
Потому что нуль это пустая строка, линк от нуля формально
это максимальный собственный суффикс пустой строки, такой
что бла бла бла.
Но у пустой строки собственных соб 셋ов не существует.
Поэтому линк для корни не определен вообще говоря,
право его запрашивать. То есть я мог бы его, наверное, как-нибудь правильно определить,
чтобы это правильно работало, но я не буду этого делать.
линк от нуля я не буду трогать, потому что не определен формально. Вот. Но линк от v
это всегда вершина, глубины меньше, чем v. Потому что глубина соответствует длине,
просто строки, да, глубина, это просто длина строки. Линк от v это какой-то
собственный суффикс, то есть ее длина еще меньше. Значит, для нее, ну то есть линк от v
где-то определено, вот она где-то здесь лежит, а линк от v. И поскольку ее глубина
меньше, чем глубина v, ну даже достаточно меньше либо равна, то для нее тоже уже
определено go, потому что для всех вершин на глубине не больше, чем v, мы
знаем вот эти go, да, по предположению, что у меня здесь все посчитано, поэтому
линк от v посчитано и go для нее тоже посчитано. Поэтому эти все значения у меня
уже посчитаны в боре, уже есть.
Вот, а теперь содержательно, почему вот так картиночка работает. Смотрите, то есть я
утверждаю, что если взять сначала линку от v, потом к ней переписать c и перейти по
go, то получится в точности самый длинный собственный суффикс u. Почему так? Ну, во-первых,
понятно, что мы получаем какой-то суффикс u, причем точно собственный, да, потому что
если мы в самом начале взяли собственный, собственный суффикс v, то по крайней мере
один символ из начала я отбросил, значит точно у меня уже собственный суффикс u
получается. То есть это получается какой-то собственный суффикс, какой-то
собственный суффикс u. Вот, пусть он внезапно не максимальный, то есть пусть есть
настоящий максимальный собственный суффикс, который получился длиннее, а вот такой.
Тогда, извините, тогда понятное дело, что вот это вот, да, все кроме последнего символа C, это
собственный суффикс v. Ну потому что, собственно, следует как минимум один символ
из начала я удалил, поэтому это точно собственный суффикс v. Значит линк имеет
или такое же длину линка из v, либо такую же длину, либо даже еще больше. То есть линк
какой-то вот такой и линк от v какой-то такой, потому что
вот это какой-то собственный суффикс v, а линк от v это максимальный собственный
суффикс, поэтому он имеет длину больше равной, чем
такую.
То есть он либо такой, либо такой какой-то, да?
Вот.
Ну и дальше получается, что я вот к строке такого
вида приписываю C и оставляю максимальный собственный
суффикс.
Но понятное дело, что какую бы я такую строчку не взял
и дописал бы к ней C, вот это вот, раз это есть в Боре,
да, то есть я предлагаю, что это настоящий ответ,
то есть это есть в Боре, то, ну уж точно, вот это вот
строчку хотя бы вот такой длины я увижу в качестве
го вот здесь.
Ну и все, значит, мы доказали в обе стороны, что, ну то
есть, что настоящий собственный суффикс имеет длину хотя
бы то, что выдает эта формула, и наоборот настоящий
собственный суффикс имеет длину, ну вот не больше
чем то, что мы выдали, потому что вот из этой конструкции,
когда я беру линк, после нее дописываю C и беру
го, то у меня получится хотя бы вот это вот, значит
они в точности равны.
Все, поэтому мы получили формулу пересчета линк
для всех вот дочерних вершин, вершины В.
И это более-менее все, то есть самое содержательное
здесь вот эта вот формула, дальше все пойдет как по
маслу.
Итак, значит, как будет работать наш собственный алгоритм?
Давайте напишем какой-то кусок кода.
Сначала давайте, вот я тут говорю, да, вот у меня
здесь в начале, ответы, то есть все линки и все го посчитаны
для какого-то начала нашего бора, то есть для всех вершин
на какой-то глубине не больше чем к.
Давайте я сначала с корнем разберусь.
Да.
Может быть, что посчитаны для некоторых вершин на глубине
к, а для некоторых не очень?
Не-не, вот у меня именно будет, что если я обрабатываю
вершину В, то есть нахожу ответы для ее детей, то
для всех вершин на глубине меньше либо равно, чем глубина
В, у меня все обработано.
На самом деле так же БФС работает, то есть как работает
БФС?
Что если мы из очереди достаем вершину на расстоянии
D, то все вершины на расстоянии D в нее уже положены и остаются
только вершины на расстоянии D плюс 1.
Поэтому здесь даже не строго неравенство.
Итак, значит, разбираемся с корнем.
Что такое линк от корня?
Ну, как я уже сказал, оно формально не определено.
Это максимальный субфикс пустой строки, который
бла-бла-бла.
Такого нету.
Ну, давайте поставим там минус 1, потому что оно не
определено.
Нет такой вершины.
Дальше.
Что делать с гоу?
Ну, давайте перебирать все символы из алфавита.
Что такое гоу ноль С?
Тут есть два варианта.
Если из нуля есть переход по букве С, то есть если
2 неравно минус 1, то его нужно просто скопировать
в гоу.
Потому что что такое гоу?
Это максимальный субфикс, который появляется после
дописывания буквы С.
Но если все это слово, если всю эту букву можно представить
из корня, то она же будет гоу.
Ну и так будет всегда.
Если из вершины торчит какая-то буква, то гоу в С будет
просто совпадать с 2, ну там, как я это обозначал,
то это будет 2ВСТ.
Давайте это переобозначу, будет просто 2ВСТ.
То есть если переход вниз есть, то гоу это то же самое,
что 2.
Гоу содержателен только в случае, если перехода
нету.
Если перехода вниз, по такой букве нету.
Иначе он просто совпадает с этим 2.
Итак, значит, если 2 нулевое СТ неравно минус 1, тогда
гоу нулевое СТ это просто то же самое 2.
А иначе, в случае, если нет такого перехода, то у
меня что было?
У меня, получается, была пустая строка, я к ней дописываю
букву С, которую нельзя из нее прочитать, и мне нужно
оставить максимальный субфикс, который есть в
боре.
Что это тогда такое?
Скажите, пожалуйста.
Стоит слово корень, все правильно.
Потому что у меня была пустая строка, я к ней приписал
С, то есть просто С, причем саму С из корни прочитать
нельзя, значит, всю строчку оставить нельзя, не надо
хотя бы что-то удалить.
Вот я ее удаляю, остается пустая строка, пустую строчку
уже можно из корни прочитать, останется корень.
Все, корень обработали.
Дальше, дальше заводим очередь вершин, так же, как в BFS-е,
куда будем сваливать уже обработанные вершины, для
которых найдены и линк, и го, как видим, для корня
уже найдена и линк, и го, поэтому в Ку я могу смело запушить
ноль.
Ку пуш ноль.
Далее, пока очередь не пустая, я достаю из нее вершину
В, и сейчас буду, вот, сейчас прихожу ровно к этой картинке.
Для всех вершин на глубины не больше, чем В, у меня все
посчитано, я хочу посчитать ответ для всех детей В и
добавить их в очередь.
Так, ну давайте, видимо, вот это сотру.
Что такое дети В?
Мне нужно пройтись по всем буквам алфавита, если
у меня есть переход по этой букве, причем переход
в терминах ту, да, то есть если есть вот такая стрелка,
то мне нужно для вершины У что-то посчитать.
Я перебираю все символы алфавита, пусть У это то,
куда я попадаю при переходе по этой букве, если никуда
не попадаю, то есть если такого перехода нет, то
я это игнорирую, делаю continue просто, ну потому что такого
ребра нет, нет такой вершины, я ее пропускаю.
Иначе, это именно вот такая картинка, да, и мне нужно
для У посчитать линк и го, линк у меня уже написано,
для линк все написано, поэтому если В равно нулю, а давайте
даже так напишу, давайте тернарный оператор бахну,
я же программист, правильно.
Все вообще офигенно, да, не-не-не, у меня все супер
проще, я-то могу себе позволить, да, правда написал же, ну
просто то написал, видите, тернарный оператор, вот,
что, я научился, да, вот, все с линкой все хорошо, теперь
с го, с го чуть похитрее, потому что для вершины У
мне нужно теперь еще перебрать все буковки, да, потому что
мне нужно для У и для всех символов алфавита насчитать
го для нее, то есть мне нужно как бы по факту еще сейчас
сделать вложенный цикл, перебирающий все, ну все символы алфавита,
пусть это будет Д.
Ну а сейчас я буду считать го у Д.
Опять два случая, если такой переход есть даже в ту,
то есть как вот здесь, просто если из У есть стрелка по
букве Д, если из У есть стрелка по букве Д, тогда го совпадает
с этой стрелкой, го у ДТ равно ту у ДТ, потому что если
из вершины У есть стрелка по букве Д, то собственно
она же и есть максимальный суффикс вот этой строки
у плюс Д, которая читается из корни, надо просто дойти
до у, потом дочитать в, это будет та самая полная
строка, поэтому го просто совпадает с ту.
А иначе, картинка такая, давайте сюда вернусь, вот
есть у, а вот есть у, и дальше я хочу дописать букву Д,
которой отсюда нету, то есть здесь нет стрелки по
букве Д, но я хочу тем не менее понять, чему равно
го у Д.
То есть у меня была строка у, я хочу к ней дописать
букву Д и понять, какой максимальный суффикс такой
строки есть в боре, при этом этот суффикс точно будет
собственный, потому что вся строка точно в боре
не лежит, у плюс Д в боре не лежит, потому что нет
стрелки, я сейчас нахожусь в случае else, значит я могу
брать не просто суффикс, а собственный суффикс, а
мне нужен максимальный собственный суффикс вот
этой вот строки, которая есть в боре, но извините,
вот в точности то, что мы уже сделали, мы приписали
к строке букву, и пытаемся найти для нее линк.
Линк, это максимальный собственный суффикс, который
есть в боре.
Вот здесь мы это только что делали.
Мы приписывали к в букву ц и брали максимальный
собственный суффикс такой строки, которой есть в
боре.
Тоже самое, у нас есть у, я приписал один символ,
теперь мне нужно взять опять максимальный
собственный суффикс, который есть в боре, я вот только
что это сделал.
То есть теперь мне нужно в этой формуле всюду v поменять
на u, c на d, а вот это вот поменять на go u d.
Короче, у меня здесь будет следующее.
Так, давайте вы пока не будете переписывать эту строчку,
я сейчас еще ее напишу сначала, потом мы ее с вами пофиксим.
Значит опять два случая, да, либо ноль, если, или я не буду это делать.
Короче, я не буду, этот случай не достигается, потому что u заведомо не ноль,
потому что u это имеет длину хотя бы один, потому что я хотя бы один раз по символу прошел,
поэтому u, она не пустая, значит для нее точно можно определить линку.
Значит этот случай можно игнорировать и просто написать эту формулу.
Сейчас скажу.
Так, правда же? Да, вроде правда. Почему посчитано? Ну, смотрите,
потому что линк от u имеет глубину не больше, чем v, да, потому что ну depth от u,
давайте напишу так, depth от u, это depth от v плюс 1, depth от линк от u, соответственно, будет меньше,
чем эта глубина, то есть меньше равна, чем depth от v. Ну, а для всех вершин на глубины меньше
равного, чем depth от v, я уже go знаю, потому что так работает BFS. Если я обрабатываю вершину v,
вот если здесь у меня из очереди извлеклась v, то для всех вершин на глубины не больше,
чем она, я знаю go, значит я знаю вот это. Вот.
For закончился, не забываю в конце написать, что u обработано, то есть ее добавить в очередь,
ну и на этом вроде ахкарасик закончился.
Вот. Значит еще раз обзор того, что произошло. Я поддерживаю то свойство, что у меня в каждом
момент времени, когда я из очереди достаю вершину v, для всех вершин на глубины не больше, чем глубина v,
все найдено, то есть и go, и линки для них для всех найдены. Сначала обрабатываю корень, добавляю его
в очередь, купуш 0. Теперь достаю его из корня, понятно дело выполняется мой вариант, да, что ну там
так bfs работает, что когда я достаю вершину из очереди, то все вершины на глубины меньше
обраны, чем она, уже полностью посчитаны. Теперь я хочу, зная, что у меня ответы вот здесь,
вот везде посчитаны, посчитать ответ для всех детей вершины v. Для этого я перебираю, собственно,
ребенка, ну пропускаю, если это фиктивный ребенок, то есть если это переход по несуществующей букве,
я его просто скипаю. Дальше линк, сначала насчитываю линк для этого ребенка, ну линк мы
вот здесь с вами по полную форму написали, доказали, а здесь я просто ее зафиксировал. Дальше,
теперь мне нужно для u найти не только линк, но и все go. Вот давайте я для всех d из алфавита буду
искать go u d. Вот, что такое go u d? Это мне нужно приписать к u какую-то букву d и найти максимальный
суффикс этой стреки, которая читается из корня. Есть два случая, если из u просто была стрелка по
букве d в нашем боре изначально, то go, собственно, ведет сюда. Всегда, если из вершины просто читается
буква вниз, то go то же самое, что tu, потому что можно просто всю строчку эту оставить u
плюс d. Это какая-то вершина бора, она читается из корня, поэтому я просто ее оставляю банально.
Интереснее ситуация, если такого перехода нету, как вот здесь, такого перехода нету. В этом случае
работает предыдущая логика. У меня была некая строка, я приписал букву, и мне нужно оставить
максимальный, собственно, суффикс такой строчке, которая считается из корня. Собственный, ну потому
что всю строчку оставить нельзя. Мы только что поняли, что вся строка в боре и не лежит,
поэтому нужен собственный суффикс. Ну а это мы точно разбирали. У меня была строка,
я предписал на ней символ, мне нужно найти максимальный собственный суффикс для нее. Ну здесь,
мы это только что доказывали. Причем это случає не достигается, поскольку у у не 0. U это уже
корень, потому что это сын какой-то вершины. Нужно просто вот это написать с
переводом v в u и c в d. Ну, здесь вроде написано. Вот. Дальше соображаем, что это
корректно, потому что эта вершина имеет глубину не больше, чем глубина v, значит
для нее все go уже посчитаны, поэтому так можно сделать. Там уже все посчитано
правильно. В конце не забываем, что теперь мы для вершины u нашли все ответы,
добавляем ее в очередь, ну и дальше потом из нее наш BFS будет дальше всю эту
информацию проталкивать. Вроде все.
Бросаем.
Круто.
Так. Хорошо. Хорошо. Все. Собственно, мы нашли все линки и все go. Ахкарафик
делал вот в точности вот это. Находит все линки и все go до всех вершин. Дальше.
Перед тем, как возвращаться к исходной задаче и находить все вхождения, все
словарных слов в текст, давайте я сначала сделаю две динамики на вот этом
нашем боре. Значит первое. Пусть dp 1 от вершины v. Это будет количество
терминальных вершин. Давайте просто dp не буду не буду обозначать, просто будет
dp от v. Это количество терминальных вершин среди списка v, линк от v, линк от
линк от v и так далее. Ну вплоть до того момента, пока эта линка
определена. У меня каждый раз линк сокращает текущую длину, я вот беру
линк, линк, линк, рано или поздно дойду до корня, ну и у корня уже линк не
определена. Вот сколько средних терминальных. Как считать такую динамику?
Ну очень просто. Понятно, что если, например, вот я рассмотрю дерево суффиксных
ссылок, вот этих вот линков, да, кстати я ни разу не написал, но линк это
называется по-русски суффиксная ссылка, суффиксная ссылка. Так вот, если я
рассмотрю множество суффиксных ссылок, как они себя ведут, понятно, что это будет
дерево. Будет корень, вершина номер ноль, ну и как-то в нее там кто-то ведет, кто-то
ведет в них, кто-то ведет в них, ну и так далее. Ну понятно, что это дерево, потому что при
взятии линк у меня глубина уменьшается, поэтому это точно ациклический граф. Ну
и они все сводятся к корню, потому что пустая строка всегда является
собственным суффиксом, который есть в боре, поэтому если я многократно беру вот этот самый
максимальный собственный суффикс, то рано или поздно дойду до пустой строки. Поэтому вот
это вот, да, набор суффиксных ссылок у меня именно, что сводится снизу вверх к корню. Вот. И дальше
теперь для каждой вершины В, что мне нужно? Мне нужно всего лишь понять, сколько из вот этих вот
вершин терминальных. Ну это простая динамика по дереву. Да, я знаю там, является корень терминальный
или нет, я знаю, в чём ровно ДП от нуля. Дальше могу посчитать ДП для этих вершин, ДП для этих
вершин, ДП для этих вершин, ДП для этой вершины. А это простой там ДФС, БФС, как угодно делается.
Это простая динамика по дереву. Согласны? Хорошо. Давай зачем-то надо, чуть-чуть позже скажу.
Это первое, что нужно делать. Второе, это давайте я назову Compressed. Ненавижу длинное
название беременных. Compressed от В. Это ближайшая сувсылка в терминальную вершину. Давайте так и напишу.
Ближайшая. Криво, криво, это не по-русски будет. Давайте так, первая вершина из списка
Link от В, Link от Link от В и так далее. Являющийся терминальный. Не учитываем, да. Вот, тоже вроде
понятное определение. Вот у нас есть В. Ну понятно, если она там терминальная, не терминальная, мы ее учтем,
если надо. А дальше, вот давайте, мы будем несколько раз брать Link. Link, Link, Link. То есть Link от В,
Link от В, Link от В и так далее. Вот давайте дождемся, когда будет впервые терминальная вершина. И вот на нее
будет указывать наша сжатая компресс, сжатая суффиксная ссылка. Хорошо. Тоже вроде насчитывается
тупой динамикой по дереву. Если вот так вот идти по нему сверху вниз, то что такое компресс для
вершины В? Это мы смотрим на Link от В. Если она терминальная, то на нее и надо ссылаться. Да,
но это просто ближайшая, просто первая терминальная. Если же она не терминальная, то мне нужно, видимо,
взять просто компресс от Link от В. Вот есть В, вот есть Link от В. Дальше, из нее ведет какой-то компресс,
уже посчитанное. Ну значит, мне нужно просто его сюда перекопировать, потому что вот на этом пути
первая терминальная это вот эта. Значит, мне нужно опять из В показывать ровно сюда. Тоже вроде тупая
линейная динамика по дереву. Что? Да, да. Нет. Будем считать? Нет, считать также сверху вниз. То есть я
иду сверху вниз по дереву. Вот считаете, что я для всех вершин это посчитал, в частности для Link
от В. Теперь как пишать для В? Ну если для Link от В уже все посчитано, то это либо просто Link от В,
если она терминальная, либо компресс от Link от В, если она не терминальная. Поэтому сверху вниз скорее.
Ну либо снизу вверх, тогда рекурсия нужна неприятно. Вот, хорошо. Такие две штуки ввели. Все, теперь
давайте вооружившись с этим делом, давайте решать обе наши задачи. Напоминаю, задача первого
в том, чтобы вывести общее количество вхождений, словарных слов текст. Второе, это вывести сами
вхождения. Напечатать, где какая строка встречается. Хорошо. Значит, давайте я наш текст представлю,
как последний символов и буду его читать в нашем боре с помощью Go. Следующим образом,
я начинаю сначала в пустой строке, то есть в корне, а дальше на каждом шаге просто применяю
Go к предыдущей вершине по очередному символу. Это будет Go от предыдущей вершины по новому
символу строки tj. То есть я встал в корень, потом с помощью Go прочитал t1, попал в какой-то v1,
потом с помощью Go прочитал t2, попал в v2, t3, v3 и так далее и так далее. То есть, ну как бы,
каждый символ читаю, перехожу по Go от этого символа. Тогда замечание первое, ну короче, факт,
vj это максимальный суффикс строки t1 и так далее tj, который есть в боре. То есть вот, скажем,
я читаю мою строчку слева направо, в какой-то момент дочитал дожитого символа. Тогда я
утверждаю, что vj будет отвечать самому длинному суффиксу текущей прочитанной строки,
который есть в боре. Ну просто Go работает. Я по одному дописываю справа символы,
оставляя каждый раз максимальный суффикс, который можно. Но если я каждый раз оставлял
максимальный, то, понятно дело, в конце остается тоже максимальный. Вот более формально,
очевидно, что vj это какой-то суффикс такой строки. Потому что я каждый раз
дописывал по символу. То есть я вот дописал символы, оставил суффикс. Дописал символ,
оставил суффикс, оставил символ, оставил суффикс и так далее. Понятно,
что в конце vj это какой-то суффикс этой строки. Почему он максимальный? Потому что если,
скажем, вот это настоящий максимальный суффикс строки, который есть в боре, то,
скажем, дойдя вот досюда, у меня все вот эти вот строчки тоже читались бы в боре, и я бы их
точно не сокращал. При проходе по Go я бы вот эти символы точно не отрезал. Ну значит,
у меня тогда, соответственно, вот это вот было бы найдено в качестве выжитого.
Противоречие. Значит, действительно, выжита максимальный суффикс, как бы
максимальный суффикс этой строки, который считается в боре. И теперь я
что буду делать? Смотрите, при, в момент времени, когда я прочитал очередной
символ tg, когда я определил максимальный суффикс, который
считается в боре, вот давайте сейчас учтем все вхождения всех словарных слов,
которые только что появились. Вот я дописал в конце tg, какие вхождения
появились. Ну, понятно, только какие-то такие. Это только суффиксы. Потому что
когда дописывается символ, все другие вхождения, его не содержащие уже раньше
были, появились только те, которые только что закончились. Очевидно, что других
подстрок новых не появилось, только те, которые здесь закончились. Ну, а, и причем
все они, это понятное дело, конечно, какие-то строки в боре, потому что
словарные слова, их точно можно прочитать из корни. А это самое длинное слово бора,
которое, которое является суффиксом. Значит, смотрите, мне нужно у вот этой
строки понять, сколько ее суффиксов являются терминальными вершинами. А это
в точность dp. Потому что вот есть какой-то самый длинный суффикс, который, который
читается в боре. Мне нужно найти все его суффиксы, которые являются терминальными
вершинами. Ну, смотрите, я каждый раз, что такое там link от v, link от link от v и так далее. Это я
удаляю минимальное количество символов в начале так, чтобы оставшаяся строка была строкой из бора.
Значит, link от v это скажем, ну, вот эта вот строка. Дальше я беру link от link от v, это
следующее по длине строка и так далее. То есть многократное применение линки, это по факту
перебор вообще всех суффиксов текущей строки, которые читаются из корни. Но и среди них мне
нужно найти количество терминальных, потому что это в точности те строчки, которые только что
получили вхождение. Итого можем написать следующее. В момент прочтения символа тж,
новое вхождение, получают словарные слова,
достижимые из vj многократными прыжками после ссылки.
Ну и тогда все. Первая задача получается решается так. Мне нужно каждый раз, когда я считал символ
и пересчитал текущий максимальный суффикс vj, мне нужно будет к ответу просто прибавить dp от vj.
Потому что dp от вершины это в точности число терминальных вот среди вот этого вот списка.
А здесь как раз вот все терминальные это то, что мне нужно. Все терминальные в этом списке это в
точности те слова, которые только что получили вхождение, которые только что завершились. Все
вот эти слова у меня как раз существуются. Получается первая задача решается так. Я строю
бор, запускаю, говорит, махкарасик. Дальше для строки t, ну как бы иду по ней слева направо,
поддерживаю в vj текущий максимальный суффикс, который читается из бора, и просто к ответу
добавляю dp для текущей вершины. Вот это была первая задача без штриха. Задача. Вот. Чтобы
решить вторую задачу, мне нужно просто ну по сжатым ссылкам пропрыгать. Потому что что такое
сжатые ссылки? Это в точности перечисление, то есть многократное применение сжатой суффиксной
ссылки. Это в точности перечисление всех суффиксов, которые являются терминальными вершинами.
Ну вот благо как раз я с помощью компресс, с помощью вот этих вот сжатых суффиксных ссылок умею
упрыгать только по терминальным. То есть из всего вот этого списка я знаю какая ближайшая терминальная.
То есть у меня есть много стрелок, и вот выше-выше они идут. Я знаю где терминальные. Вот это вот первая
терминальная. Вот это вторая, третья и так далее. Для задачи штрих. Ну мне нужно просто как бы
просмотреть. В, компресс от В, компресс от компресс от В, ну и так далее. Вот. И поскольку они перебирают
не вообще все вот эти вот, да, не все вершины из этого списка, а только терминальные, то вот время
работы этого цикла в точности равно количеству вхождений, которые мы только что получили. Ну и
понятно, что если нам их нужно все вывести, да, вот у меня задача вот эта штрихованная как раз просит
вывести список всех вхождений всех словарных слов. Я как раз, получается у меня каждый прыжок по
суффсылке, сжатый вот такой, он получает очередное вхождение очередного словарного слова в нашу
строчку. Да, потому что он как раз прыгает по терминальным суффсылкам. Каждое компресс, да,
многократное применение компресс, это очередное вхождение словарного слова в текст. Ну раз их
мне нужно напечатать, то я просто по ним пробегаю и печатаю. Вот. Вроде все. Так, вопросы есть? Ну ладно.
Давайте тогда со симптотикой разберемся. Да. Ну вот именно, поэтому я написал здесь просмотреть,
то есть если она терминальная, то ее надо учесть. Если не терминальная, то не надо учитывать. А дальше
просто список всех компрессов. Да, ну то есть вот тут отдельно еще и фаятс, и в, является ли она
терминальной. Если является, надо вывести, иначе не надо. А дальше вот список компрессов, это в
точности все терминальные. Поэтому вот с ней надо отдельно еще и флот, да. Вот. Давайте со симптотикой
разберемся. В первой задаче скажите, пожалуйста, за сколько работает алгоритмах Карасик по симптотике.
Как-то я его пропустил. Еще раз, учитывая. Ну даже учитывая, да. Вот. Там действительно может показаться
сигма квадрат, потому что два ложных символа С и Д. Но на самом деле это просто В на сигма квадрат.
Просто В на сигма. Где В это число вершин. Число вершин Бора. Ну да, число вершин Бора. Почему? То есть там
формально было два вложенных цикла, да. По С из сигма и по D из сигма. Вот. Но на самом деле вот здесь
я выхожу, я делаю континью в момент, если у это не вершина. То есть на самом деле вот это вот это
просто цикл по всем вершинам. А дальше для каждой вершины цикл по D. Поэтому симптотика будет
В на сигма. То есть вот это вложенное здесь получается только если это соответствует
некоторой вершине. Ну значит вот как раз такая симптотика. Сигма квадрата там нет. Вот. Ну это
ахкарасик, да. Построение ахкарасик. Давайте напишем, что это ахкарасик. Плюс динамика. Ну там динамика вообще
тривиальная за O от В считается, потому что это просто там ДПшка по дереву. Поэтому я ее здесь не
пишу. Ну а дальше я видимо за линейное время удлины текста могу посчитать все вот эти вот. Ну да, то есть
я просто к канцу добавляю все вот эти ДПшки. Поэтому дальше будет просто линия удлины текста Т.
Я текст читаю слева направо, пробегаю по его символам с помощью Go и к ответу добавляю ДП
от текущей вершины. Вот. Ну а здесь в задаче, где нужно вывести все вхождения, это будет то же
самое В на сигма плюс Т. Но еще плюс ans, где ans это собственно величина ответа. То есть количество
всех вхождений. Ну потому что суммарное время работы вот этого цикла, когда я многократно беру
компресс от компресс от компресс, время работы этого цикла в точности равно числу вхождений,
которые только что получились. То есть время работы вот этого цикла равно просто ДП от ВЖ. Сколько
слов только что получили вхождение. Вот. Ну и если мне нужно как бы каждый из них напечатать,
а мне по условию именно что нужно было создать список всех вхождений, кто где входит, значит вот
это вот работает с точностью за величину ответа. Сколько вхождений за столько это и работает. Ну и
понятно, что быстрее нельзя, потому что если мне это нужно напечатать, то время работы хотя бы
будет ans. Вот оно здесь и получается. Вот. Что, вопрос есть? Ну ладно. Давайте тогда закончим
чуть пораньше сегодня. Вроде все.
