Ну что, поехали? В прошлый раз, позапрошлый раз мы начали византийскую модель.
Мы сказали, что мы не хотим доверять конкретным узлам, что они могут отступать от протокола,
поэтому мы должны каким-то образом, какими-то инструментами, криптографиями,
какими-то особенными кворами от них защищаться. В прошлый раз мы построили
некоторый алгоритм, который уже решает довольно эффективно
некоторую, мы надеемся, полезную задачу – упорядочивание транзакций.
Мы с вами строили ordering service, который получает транзакции от пользователей
и строит на них какой-то глобальный порядок. Видимо, для того, чтобы реплицировать
по помощи этого порядка некоторое состояние. Но я вот загадочно умолчал в прошлый раз,
какое состояние мы будем реплицировать, потому что это важно, но в прошлый раз
мы смогли без этого обойтись. Вот сегодня мы без этого обойтись не сможем уже,
и я наконец скажу, что же мы собираемся реплицировать. Ну ладно, в прошлый раз
я сказал, кажется, что мы собираемся реплицировать компьютер,
что было довольно странно. В конечном итоге это так, но начнем
с другого. Сегодня мы хотим реплицировать деньги,
мы хотим реплицировать электронные монеты.
Это довольно странно звучит, что у нас будут монеты, деньги электронные, цифровые,
потому что сложно себе представить, чтобы набор байтиков, какой-то синтетически
сгенерированный на вашем диске, имел какую-то стоимость. Но, с другой стороны, он будет иметь
небольшую абсолютную стоимость, чем какая-нибудь бумажная купюра, которая у вас в бумажнике, может быть,
до сих пор лежит. Все это вопрос соглашения.
Просто мы считаем, что какая-то купюра или какой-то набор байт
обозначает некоторую стоимость. Вот пока соблюдены некоторые правила,
пока сама инфраструктура обслуживания этих купюр, этих кусочков,
этих блобиков с данными будет надежной, пока мы их будем доверять,
мы можем действительно использовать эти цифровые монеты
или эти бумажные купюры как эквивалент стоимости.
Сегодня мы поговорим о том, как это можно сделать.
И нужно понять, как мы собираемся эти монеты представлять для начала.
Давайте скажем, что можно себе мыслить вот эти все монеты
как совокупность счетов. Вот есть разные участники, у них есть счет,
там лежит какая-то сумма. Такое моментальное состояние.
Мы вместо этого сегодня будем говорить не про моментальное состояние,
мы будем говорить про движение этих самых монет. Мы будем наши деньги описывать в движении,
а именно с помощью транзакций, которые перемещают деньги.
У нас будет два типа транзакций. На всякий случай мы сейчас говорим про какие-то абстрактные
электронные деньги, какие-то абстрактные цифровые монеты, не про биткоин.
Когда это начнется, это будет оговорено явно.
А пока мы просто фантазируем, как бы мы могли электронные деньги себе представить.
Мы представляем их в виде набора транзакций.
Первый тип транзакций, который у нас будет,
это транзакция, которая перемещает деньги от одного участника к другому.
У нас есть Алиса, у нас есть транзакция, которую она выпускает,
и в этой транзакции она переводит деньги Бобу.
Какое-то количество монет.
Это спент-транзакция.
И понятно, что эти монеты должны откуда-то браться, поэтому нам нужен второй тип транзакции,
когда монеты берутся из воздуха, просто печатаются, чеканятся.
Вот транзакция, которая чеканет монеты.
Понятно, что эти транзакции выпускают участники Алиса.
А вот эти транзакции выпускают кто?
Центральный банк, давайте скажем так.
Будет странно, если Алиса сможет печатать себе деньги.
Еще будет странно, если Боб может выпустить такую транзакцию,
которая берет в Алис эти цемонеты и посылает ему.
Поэтому, разумеется, нам нужна криптография, и мы каждую транзакцию
составляем в свою подпись.
Алиса подписывает свою транзакцию, что действительно это она переводит деньги Бобу.
Если Боб получил деньги, то, видимо, он их собирается потратить.
Для того чтобы потратить, он должен выпустить свою транзакцию,
которая каким-то образом склеится вот с этой.
Это будет выглядеть так у нас.
Пусть у нас есть транзакция первая, которая переводит Бобу цемонет.
Она подписана Алисой.
И есть транзакция, которую выпускает сам Боб,
потому что он хочет свои монеты, которые он получил от Алиса, потратить.
Купить себе новую Феррари.
Для этого он должен сослаться на транзакцию Алисы,
и вот они должны каким-то образом склеиться.
Тут есть разные вопросы.
Давайте по поводу рексики договоримся.
Вот у нас есть такой блок в этой картинке.
Мы будем называть его выходом.
Вот выход адресует получателя этих самых монет.
У нас есть вход.
Вход адресует некоторую транзакцию, из которой мы собираемся забрать деньги.
Мы сразу ограничим себя.
Мы скажем, что если мы транзакцией цепляемся к выходу другой транзакции,
то мы тратим все ее монеты.
Именно поэтому я рисую монетки на выходе.
Как нам адресовать эту транзакцию, которой мы цепляемся?
Что мне нужно написать в input?
Я напишу следующее.
Я вот здесь напишу хэш транзакции, к выходу которой я цепляюсь.
Я утверждаю, что нам этого будет достаточно, чтобы однозначно адресовать
ту транзакцию, деньги которой мы собираемся потратить.
Это пока не очевидно.
Почему так можно делать, мы узнаем гораздо позже.
Но мы будем делать так.
Мы выпускаем такую транзакцию.
Разумеется, третья сторона, которая наблюдает за всем этим процессом,
банк, который обслуживает все эти транзакции,
он должен иметь возможность проверить, что действительно Боб имеет право
потратить этот выход.
Что вот эту транзакцию выпустил именно Боб.
Для этого у нас есть цифровые подписи.
Скажем, банк, который эти транзакции обслуживает,
он в этом месте выполняет верификацию.
У него есть штрихованная транзакция, подписанная Бобом.
Эта транзакция переводит сэмонет Бобу.
Поэтому, если мы знаем открытый ключ Боба, то мы банк.
То мы можем проверить, что действительно эти транзакции могут склеиться.
Ну, процедура верификации.
Я уже сказал, что если мы цепляемся к другой транзакции,
мы тратим весь ее выход.
С этим связано очень понятное ограничение.
Что если мы, скажем, получили две монеты,
и хотим потратить одну из этих монет только,
то, кажется, нам это делать неудобно в такой схеме.
Поэтому мы скажем, что у транзакций может быть много выходов.
И если мы хотим взять одну монету из наших двух
и потратить вторую оставить себе,
то для этого у нас есть вот такая конструкция.
Есть транзакция Алиса,
из которой мы получаем две монеты.
И мы выпускаем свою транзакцию.
Один выход мы отправляем в магазин,
а второй выход мы отправляем себе.
Ну вот, сдача.
Получили сдачу одну монету.
В общем случае мы скажем, что транзакции выглядят как вот такие вот спруты.
У них может быть много выходов.
И много входов.
Ну и что разумно потребовать относительно соотношения вот этих ЦИ и ЦАО?
Чтобы сумма на входах,
количество монет, которые мы получаем на вход,
было бы не меньше, чем количество монет, которые мы отправляем на выход.
Почему не равно?
Ну вот увидим чуть позже, но не равно будет больше.
Если странно, то вообще-то что равно пока.
Ну уж точно не меньше.
Потому что это было бы подозрительно.
Итак, значит, мы ограничились.
Мы сказали, что можно потратить выход транзакции только целиком.
Но можно получать сдачу.
Ну и как-то можно более гибко распределять монеты.
То есть можно собирать их из разных выходов.
И тоже тратить довольно по-разному.
Вот это ограничение, что мы тратим выход транзакции целиком.
Заодно нам решает проблема, которая осталась с прошлого раза.
А именно exactly once.
Мы в прошлый раз придумывали в PBFT, что же может делать византийский праймари.
Мы сказали, что он может выкидывать транзакции.
Мы с этим боролись с тайм-аутами.
Мы сказали, что он может назначать разные команды.
Разным командам один и тот же порядковый номер.
Мы с этим поборолись с разными фазами prepare, с собиранием сертификатов.
И у нас была проблема с тем, что праймари может дублировать транзакции.
Даже если он их будет дублировать, то понятно, что одна из транзакций потратит выход целиком.
И вторая транзакция потратить его не сможет.
Но правда, в этом-то и проблема, что непонятно, кто из них первый, а кто из них вторая транзакция.
Вся эта конструкция, она действительно будет работать, но не решает проблемы, которые называются double spend.
А именно вот Боб, получив две монеты от Алисы, может потратить еще дважды.
Он может выпустить две транзакции, которые эту монету тратит.
И каждый из них пройдет верификацию, потому что действительно обе эти транзакции выпустил Боб.
Они обе могут приконнектиться к одному и тому же выходу.
Значит, Боб в этом смысле может этот выход использовать, может эти монеты потратить.
Но вот для того, чтобы такие проблемы решить, нам нужно транзакцию порядочить.
Нам нужно вести на ней глобальный порядок, тогда правила валидации модифицируются и примут свой разумный вид.
Транзакция штрихованная может потратить выход этой нештрихованной транзакции,
если мы проверяем цифровую подпись и она сходится, то есть действительно деньги адресуются нам.
Плюс не было до этого в нашем глобальном порядке другой транзакции, которая уже успела бы потратить вот такой вот выход.
Так что к нашим транзакциям нужно, все наши транзакции нужно упорядочить.
И для этого нам потребуется сущность, которая называется, поскольку мы уже говорим про криптовалюта,
она называется в этом контексте Ledger.
Все транзакции, которые выпускаются пользователями в этом Ledger получат свои порядковые номера.
Как-то будут цепляться друг за друга, то есть вся наша электронная, все наши электронные деньги образуют вот такой вот граф из таких вот спрутиков,
которые цепляются друг за друга, но при этом на них есть сквозной порядок для того, чтобы мы могли валидировать эти транзакции,
проверять, что выход еще действительно не потрачен.
Ну вот, общее устройство это конструкция. Вот так выглядят электронные деньги, электронные монеты.
Давайте теперь подумаем, чего же нам не хватает в этой конструкции. Нам не хватает инфраструктуры, которая бы все это обслуживала.
Во-первых, нам не хватает инфраструктуры для поддержки вот этого самого Ledger, для лого-транзакций.
Кто-то должен его хранить, кто-то должен получать транзакции, упорядочивать их, верифицировать их.
Во-вторых, нам нужна организация, нужен участник, который сможет печатать монеты, чеканить монеты.
Это нужно делать аккуратно, потому что вы понимаете, что если вдруг центральный банк напечатает грузовик денег завтра,
то деньги станут дешевле. Поэтому этот процесс должен быть какой-то очень понятный, очень контролируемый.
То есть, во-первых, поддержка этого самого Ledger, бухгалтерской книги, во-вторых, чеканка монет.
В-третьих, что еще нам нужно для того, чтобы вся эта конструкция работала?
Ну, я сказал, что это часть Ledger, то есть мы упорядочиваем транзакции, и с помощью этого порядка мы верифицируем.
И что ты имеешь в виду?
Помимо банка, который будет поддерживать этот транзакций, помимо центрального банка, который будет печатать деньги,
нам еще нужен удостоверяющий центр, который сможет сопоставлять вот этого самого Боба,
который записан в адресатах, и его публичный ключ.
Вот Боб, а это identity здесь.
Итого, мы должны решить три задачи, чтобы эта схема действительно заработала.
Но можно было бы сказать, что пусть три эти задачи решаются банком.
Он будет и монет, мы ему доверяем, он будет печатать чеканец монеты, он будет упорядочивать транзакции, их верифицировать.
И чтобы с ним работать, нужно к нему будет ногами прийти, показать паспорт, показать публичный ключ,
и он выпишет сертификат, что, действительно, эта транзакция, в смысле этот публичный ключ, связан с нами.
Но это не то, чего мы хотим. Если мы не хотим доверять банку, или мы не хотим доверять разным организациям,
если мы распределим между ними эти обязанности. Мы хотим доверять алгоритмам, хотим доверять криптографии.
И вот эту централизацию мы хотим исключить.
Вот тут мы переходим к Биткоину. Давайте я вам покажу статью.
Мне очень ярко видно, но лучше, наверное, не получится сейчас.
Статья была написана в 2008 году, и поинт этой статье, что давайте никому не доверять.
Давайте всю эту конструкцию организуем децентрализованно.
Эта статья довольно любопытная, потому что... Ну я по ходу дела объясню, почему.
Ну вот для нас, для людей, которые слушают курс про распределенную систему, она любопытна тем,
что мы собираемся решать довольно понятную нам задачу.
Мы хотим что-то децентрализованно-распределенно упорядочивать, мы этим давно занимаемся.
И в Биткоине возникает та же самая задача. Ну, еще пара дополнительных задач.
Но все же, основная, наверное, все же здесь. Точнее, они совмещены все, ладно, я буду аккуратнее говорить.
Так вот, эта статья решает известную задачу.
Но при этом эта статья полностью вырвана из контекста всей теории, которую мы тут уже три месяца обсуждаем.
В ней нет ни слова про консенсус, в ней нет ни слова про какие-то FLP, про все, что мы говорили, про кворумы.
Здесь абсолютно альтернативная лексика, абсолютно альтернативный мир.
Эта статья родилась не в Академии, она родилась в сообществе криптоанархистов, ну и как их называть.
В общем, у них там абсолютно своя атмосфера, своя лексика, свои задачи, свой взгляд на мир.
И поэтому, если вы будете читать статью, то в ней ничего этого не будет.
Но наша цель сегодня не просто объяснить, как Биткоин работает, ну, разумеется, само собой,
а еще и в том, чтобы вот этот Биткоин и все, что мы дальше будем придумывать, как-то погрузить в ту теорию,
в ту лексику, в те задачи, которые мы с вами уже давно рассматриваем.
В самой статье этого ничего нет, но это не значит, что в Биткоине на самом деле этого нет.
Как раз вот параллелей будет очень много, и параллелей будет очень много с прошлым алгоритмом,
то есть будут решаться одни и те же задачи примерно разным способом, но декомпозиция будет, я бы сказал, что схожая.
Идеи будут похожие.
Ну и еще один любопытный момент про это статью.
Ну, смотрите, сколько места оно занимает.
Вот, кончается какой-то программой маленькой на языке C.
Ну, в общем, так, если вы, наверное, представляете, академические статьи не пишут.
Это такой очень короткий дизайн-док или, не знаю, черновик дизайн-дока.
Как будто бы торопился, очень коротко, емко все написал.
Тут все, что нужно, описано. Все остальные детали можно додумать.
Вот супер-емко, но при этом вы понимаете, чем эта статья закончилась для современного мира.
Какой эффект она на него произвела.
В общем, удивительная, совершенно удивительная статья.
Почитайте она, действительно, пять страничек. Можно это за час освоить.
Не то чтобы написано было супер-понятно, я бы сказал, в некоторых местах можно было написать аккуратнее.
Но все же, она описывает только главные идеи, максимально сжато.
Ну, а мы сейчас разберем их, наверное, немного подробнее.
Итак, мы с вами теперь переходим, наконец, к Биткоину.
Итак, главная идея. Мы хотим избавиться от любой централизации.
От удостоверяющего центра, от централизованного печатного станка, от банка, который упорядочивает транзакции.
Мы хотим все хранить открыто, децентрализованно.
Но давайте поговорим сначала про открытость.
Мы собираемся этот грузбук, этот лог транзакций хранить так, чтобы он был доступен всем участникам Биткоина,
всем участникам сети, ну, вообще всем людям, которые могут, они могут прийти и все проверить.
Это довольно странно, потому что, ну, почему мы доверяем банку?
Потому что, видимо, мы хотим сохранить приватность, мы хотим, чтобы наши транзакции не были доступны третьим лицам.
Если мы собираемся этот грузбук хранить в открытом виде, то нам нужно эту проблему решать.
Биткоин решает ее очень эрегантно.
А именно, он избавляется в том числе сразу от удостоверяющего центра следующим способом.
Ну, скажем, что identity в Биткоине просто тождественно публичному ключу, открытому ключу.
Когда вы адресуете ваши монеты кому-то, вы посылаете их не Бобу, вы посылаете участнику с заданным публичным ключом.
Адрес, которому вы адресуете получателя, это все же не публичный ключ, а это хэш от публичного ключа.
Каким-то образом еще модифицировано, не очень важно.
Вот это адрес.
Ну, это такой очень специальный адрес, вы по нему не можете отправить сообщение,
только деньги можете отправить по нему. Вот эти деньги потом можно будет получить.
Ну, а дальше мы собираемся теперь лог этих транзакций.
Да, вот это называется псевдонимность.
Это не анонимность, потому что наблюдатель, который смотрит на блокчейн,
он может склеить в один подграф все транзакции, которые связаны, в принципе, с одним человеком.
Но если вы переиспользуете один и тот же адрес, то все ваши действия склеиваются.
Это немного неприятный эффект, и можно с этим разными забавными способами бороться.
Это псевдонимность.
И вот автор статьи со то, что на ком-то это тоже псевдоним, совсем не понятно, кто это,
что это за человек, жив ли он, это неизвестно.
Итак, в наших транзакциях будут теперь вместо получателей хэшированные публичные ключи.
И мы собираемся граф этих транзакций, граф этих спрутиков, лог, в который мы уложили этот граф,
хранить в открытом виде распределенно и децентрализованно.
Вот у нас будет большая-большая сеть.
И каждый узел в этой сети будет поддерживать копию этого самого логотранзакции.
Что важно, в чем принципиальное отличие биткоина от того же PBFT,
да почти от всех протоколов, которые мы рассмотрели в этом курсе,
в том, что в эту сеть можно свободно заходить, к ней можно свободно присоединяться.
У нее нет никакой жесткой конфигурации.
Разумеется, мы ее раньше могли переконфигурацию выполнять в том же RAFT или Multipax,
но в каждый момент времени конфигурация там все же фиксировалась и через консенсус менялась.
Вот здесь алгоритм называется permissionless.
Вы можете свободно стать участником этой сети, участвовать в консенсусе,
никого в этом не предупреждая.
Ни о чем договариваться с другими вам не нужно.
И вот именно из этого свойства будут вытекать все различия, которые у нас сегодня появятся.
Вот именно эта деталь, именно это свойство поменяет нам весь алгоритм.
Как мы сам леджер, как мы сам логотранзакции будем представлять физически?
Мы будем представлять его в виде блокчейна.
Он состоит из, вы догадываетесь, блоков.
Каждый блок – это набор транзакций.
Первый блок.
Начинается с некоторого блока B0.
Почему мы говорим именно про блоки, а не про цепочку транзакций?
Пока можно считать, что это такая оптимизация.
Так же, как в RSM, не нужно коммитить команды в лог по одной, нужно их объединять в пачке,
потому что их просто очень много, и снижать накладные расходы на отдельную транзакцию.
Вот так же и здесь можно собирать транзакции в блоки и блоками уже их добавлять.
То есть мы снижаем накладные расходы на обслуживание отдельной транзакции.
Откуда появляются эти блоки?
Вот их формируют узлы сети.
Вот у нас есть пользователи, давайте мы разноцветных пользователей сделаем.
Вот у нас есть пользователи, давайте мы разноцветных пользователей сделаем.
У нас есть пользователям, и они отправляют в сеть свои транзакции.
Узлы сети их распространяют через гостепротокол.
Вот это еще одно различие, которое сразу является средствами того, что у нас система децентрализованная
и конфигурация нефиксированная.
Мы не можем отправить сообщение всем, потому что всех непонятно сколько,
и это число постоянно меняется.
Поэтому мы общаемся через гостепротокол.
Суть его такова.
Вы не знаете всех участников сети, но вы знаете каких-то участников сети.
Условно такую некоторую окрестность вашу, не то чтобы географическая окрестность.
И каждый раунд вы выбираете случайный узел из числа тех, которые вы знаете,
и обмениваете с ним информацией.
Говорите, что у меня появились такие транзакции,
он вам тоже сообщает о каких-то своих изменениях.
Вот если у вас есть такой протокол, то можно аккуратно и сложно показать,
что для того, чтобы распространить какие-то сведения в сети, вам достаточно, например, алгорифма итерации.
Если они появляются на одном узле, то за разумное время они распространяются по всем.
Эти узлы принимают транзакции от пользователей,
раздают их через гостеп и формируют блоки.
Где-то на этом узле рождается очередной блок.
И узел, накопив этот блок, хочет его добавить в блокчейн.
Но, разумеется, в этой сети, желающих добавить очередной блок, блокчейн довольно много.
Поэтому мы должны придумать, как именно мы будем выбирать того узла, который сможет свой блок добавить.
Кто должен это сделать?
Как мы раньше это делали? Раньше мы выбирали для этого лидера.
И он получал все транзакции, упорядочивал их, но, может быть, группировал в пачке для эффективности
и назначал им порядковые номера.
Здесь у нас лидера не будет, но это довольно сложно было бы сделать,
потому что не понятно, сколько всего узлов, и каждый из них может пропасть или оказаться предателем.
Поэтому мы разыгрываем право добавить в блокчейн очередной блок в распределенную лотерею.
Как эта лотерея устроена?
Это, наверное, самое известное новшество Биткоина.
Но придумана эта идея совсем не там, придумана она в другом контексте.
Представим, что мы пишем почтовый сервер.
Давайте это здесь нарисуем.
И есть какие-то пользователи, которые сюда отправляют свои письма.
Почтовый сервер.
Вот пользователи бывают честными, и отлично мы их письма должны принимать.
А бывают спамеры.
И они хотят положить в этот почтовый сервер миллион писем.
Вообще говоря, понятно, что мы хотим их запретить.
Но как это сделать?
Есть идеи.
Просто запретить одному полюсу, положить в почтовый ящик миллион писем нельзя.
Потому что, в конце концов, если узел спамер, то он может наплатить несколько виртуальных сущностей.
И это как будто будет миллион участников, которые отправили по одному письму.
Ну, возможно, ты не хочешь читать чужие письма.
Нет, не можешь, наверное.
Хочешь какое-то машинное обучение здесь запустить?
Нет, это не тот курс.
Так вот, смотрите, мы не можем просто настоять rate limit,
потому что rate limit, как правило, привязан каким-то участником к identity.
А эти identity можно создавать виртуальные.
Так что мы хотим поступить другим способом.
Мы хотим, чтобы каждый отправитель вместе со своим письмом
приложил некоторое доказательство криптографическое этого факта,
что это отправка письма, он за нее заплатил, короче говоря.
Так что, если даже у нас будет спамер с миллионами виртуальных сущностей,
с миллиона таких марионеток, то ему все равно будет дорого отправить миллион письм,
потому что виртуальной сущности у него много, а физические ресурсы ограничены все же.
Как же будет выглядеть доказательство?
Почтовый сервер выбирает, фиксирует с самого начала хэш-функцию h
и некоторый параметр d, сложность.
И говорит, что если ты, допустим, Алиса частная, хочешь отправить мне письмо,
положить письмо в почтовый ящик, то, пожалуйста, возьми свое сообщение
и найди такое, это называется нонс, что хэш от конкатинации твоего сообщения и нонс
даст хэш, который будет выглядеть так. Он будет начинаться с D0.
Вот там, 16-речная запись.
Понятная идея?
Нонс, как он переводится или что?
Вот нонс, смысл его, как называется вся конструкция, называется proof of work.
Смотрите, в чем смысл. Хэш-функция криптографическая, что это значит?
По ней можно думать так, что вы подаёте ей вход,
и внутри хэш-функции сидит такой маленький гоблин,
и он подбрасывает несколько раз монетку.
И она 256 раз подбрасывает, и получает 256 случайных битов.
И запоминает, что вот этому входу соответствует такой выход.
Это такая идеальная криптографическая хэш-функция.
Люди пытаются строить хэш-функции, которые на такие идеальные похожи.
То есть они обладают таким эффектом лавинным, что вы меняете один бит на входе,
и на выходе переворачивается половина бит.
Если хэш-функция ведет себя таким образом, то найти этот самый нонс,
который бы дал Дэн Урей на выходе, никаким разумным способом нельзя.
Нет никакой стратегии лучше, чем просто перебирать все подряд значения.
Так что если Алиса хочет отправить письмо, то она должна выбрать,
возьмет нонс, не знаю, ноль, и потом будет его инкремитировать до тех пор,
пока хэш не станет вот такого вида.
Ну и Дэ подбирается таким...
Да, никакой лучшей стратегии для того, чтобы подобрать такой нонс
для данного сообщения данной хэш-функции и для данного значения параметра D, нет.
Поэтому если Алиса вместе со своим письмом приложила этот самый нонс,
то таким образом она доказывает почтовому серверу,
что она действительно потратила некоторые усилия, потратила процессорное время,
потратила электричество для того, чтобы письмо отправить.
D выбирается таким образом, чтобы Алисе было нехлопотно отправить одно письмо.
Она секунду вычисляет хэш-функцию у себя на процессоре, и письмо отправится.
Но если вы спаммер, который хочет отправить с одного компьютера миллион писем,
то вам потребуется уже миллион секунд потратить,
потому что сообщения отличаются адресатами, видимо,
поэтому они меняют хэш. Нужен для каждого свой нонс.
И никаким образом подобрать много разных нонсов для разных M нельзя уже,
кроме как сделать много-много вычислений.
Идея понятна?
Одной...
А зачем?
Если ты спаммер, ты хочешь отправить не одно сообщение человеку миллион раз,
а, наверное, миллион сообщений похожих, разным людям,
у них адресаты разные, заголовки разные.
Здесь мы понимаем, что в этом сообщении, конечно, и заголовки лежат.
То есть кто получит этого?
Мне из головы выпало, к сожалению.
Ну, что-то такое, да, не очень хорошо переводится, насколько я помню.
Итак, у нас есть такая идея, как она относится к распределенной лотереи.
Смотрите, когда мы добавляем новый блок, мы же добавляем в какую-то позицию блокчейна.
Мы должны... Во-первых, этот блок состоит из каких-то транзакций,
во-вторых, он следует за каким-то другим блоком.
Вот если мы блок нарисуем,
то в нем есть транзакция и есть заголовок.
Вот заголовок образован чем?
Во-первых, в нем лежит такой кумулятивный хэш всех транзакций.
Ну, как он считается, это тоже отдельная история, его нужно считать аккуратно,
с помощью дерева-меркла.
Кроме того, в этом блоке есть то, что называется хэш-поинтер.
Это хэш предыдущего блока.
То есть так мы ссылаемся на блок, за которым мы хотим прицепить наш.
Ну и, собственно, нонс.
И мы, если мы хотим выиграть в распределенную лотерею, мы покупаем беретик.
Мы придумываем нонс.
И считаем хэш от хэш-поинтера, сконкатинированного с хэшом
кумулятивного всех транзакций блоки, сконкатинированным с нонсом.
Давайте даже рисуем побольше.
Вот, и вот этот хэш должен принять известный нам уже вид.
Он должен начинаться с D0.
Вот, поиск этого, вот такая задача найти нонс для данного блока,
для данного набора транзакций и для данного хэш-поинтера,
в биткоине называется пазлом.
А поиск решения этого нонса, то есть перебор разных значений случайных,
называется майнинга.
Ну а узел, который занимается этим всем, называется майнером.
То есть он копает землю в надежде найти вот этот золотой самородок,
который позволит ему поместить свой блок в блокчейн.
Идея понятна?
Вот этот процесс полностью децентрализованный.
Этим занимается каждый отдельный узел сети.
Сколько этих узлов непонятно.
Каждый из них независимо от других перебирает свои нонс.
Ну и рано или поздно кто-то из них должен выиграть.
Давайте подумаем, на что это похоже.
Я вот говорю, что все, что с ним будет возникать,
должно быть похоже на то, что мы уже видели в курсе.
Будет очень странно, если бы мы придумали что-то...
Когда появился биткоин, это действительно выглядело
как что-то совершенно принципиально новое,
но все же тут можно привести очень прямые параллели.
Вот еще раз напомню, какую задачу мы решали.
Мы решали задачу упорядочивания этих блоков.
Кто назначит следующий?
Раньше этим занимался лидер.
Вот в RAF-те мы выбирали лидера каким-то способом.
В мультипаксе вообще бы как можно было выбирать.
В PBFT нужно уже было выбирать аккуратнее.
Почему?
Потому что выбор лидера это та еврестика,
которая обеспечивает нам свойства Лайонес.
То есть что каждая транзакция рано или поздно попадет
в наш журнал лог-транзакций.
Но мы не знаем, каким узлам можно доверять и каким нет.
Если узел в чем-то подозревается,
то не факт, что он византийский,
может быть просто он залип на сборке мусора.
Поэтому мы с одной стороны должны каждому дать шанс
и в то же время гарантировать,
что каждая транзакция попадет в блокчейн,
то есть рано или поздно лидером станет честный узел.
Вот для этого мы придумали в прошлый раз новую идею,
которой у нас до этого не было.
Называлась ротация праймари.
У нас была конфигурация из четырех узлов,
чтобы перевести один византийский сбой.
И мы праймари назначали по кругу.
Сначала это был просто первый узел,
если мы его подозревали в чем-то,
то мы меняли, переводили систему через эпоху
и праймари становился второй узел и так по кругу.
Вот видите ли вы аналогию с этим протоколом,
с этой лотереей?
Ну вот мы точно также не пытаемся здесь выбрать
этот узел, который будет единолично назначить порядок.
Мы не знаем, кто этот честный,
поэтому мы просто пробуем всех.
Но раньше мы могли перебирать всех по кругу,
потому что у нас была жесткая конфигурация.
Теперь у нас система permissionless,
в нее можно просто приходить в любой момент.
Поэтому мы пробуем случайные узлы.
Но смысл точно такой же, что рано или поздно,
если у нас есть транзакции от честного пользователя
и честных майнеров,
и честных майнеров довольно много,
то в какой-то момент честный майнер выиграет в эту лотерею
и транзакция попадет в лог.
Но вот в BFT мы меняли эпоху и перевыбирали праймари,
когда мы старого праймари в чем-то подозревали коллективно,
а здесь мы назначаем нового праймари,
то есть новый узел, который формирует и добавляет новый блок,
просто на каждом раунде.
Это происходит просто на каждом очередном блоке,
где выбирается свой праймари, так условно назовем.
Получилось?
Тут нет уже никаких эпох в том-то и дело.
Это в BFT они были, потому что у нас была эпоха,
которой руководил некоторый праймари,
в которой этот праймари назначал порядковые номера транзакции.
Но у нас эпоха вырвелась в один блок.
В каждой эпохе условной выбирается новый лидер,
и он добавляет один новый блок.
Так что об этом можно просто уже не думать.
Но идея точно такая же.
Мы точно таким же образом достигаем лавенес.
Мы пробуем разные узлы.
Но теперь мы делаем это децентрализованно
с помощью такой распределенной лотереи.
Каждый узел, независимо от других,
ищет вот этот самый нонс.
Да, если мы майнер нашли вот этот нонс,
достали выигрыш на лотерейный беретик,
то это криптографическое доказательство того,
что мы проделали некоторую работу,
что мы выиграли лотерею,
и мы госпом раздаем его другим узлам.
И когда другой узел получает от нас блок,
получает по сети блок,
то вот именно он в этот момент
добавляет в его блокчейн
и верифицирует транзакции.
Он может проверить подпись,
и он может проверить,
что эта транзакция цепляется
к еще не потраченному выходу.
То есть эта верификация,
она теперь выполняет,
она теперь выполняется
на каждом узле нашей сети,
когда тот получает блок от счастливого майнера.
Я бы сказал, что разумеется это проблема,
потому что лотерея распределенная,
и ты знаешь, что иногда призовой фон
делится между победителями.
В биткоине не так будет,
но проблема есть.
Действительно в лотереи могут выиграть два узла,
потому что не то чтобы они один и тот же нонс нашли,
а просто у них были разные блоки,
разные наборы транзакций,
они по-разному хэшировались.
Так сложился случай.
Они нашли два блока
с двумя нонсами,
и теперь оба претендуют на то,
чтобы свой блок добавить в блокчейн.
Это проблема, но, возможно,
есть проблема более масштабная,
а может быть и нет,
но мы пока об этом не подумали почему-то.
У нас же разные узлы,
все узлы в сети, их могут быть
тысячи, десятки, сотни тысяч,
они формируют,
они получают пользователей одни и те же транзакции,
формируют из них блоки,
но в принципе эти блоки могут повторяться,
одни и те же транзакции в одном и том же порядке.
Почему же так не получится,
что разные майнеры будут майнить
этот самый нонс для
одного и того же хэшпоинтера
и одного и того же набора транзакций
и просто одновременно его находить?
Пока это не ясно,
из того, что я изложил, пока невозможно ответить на этот вопрос,
пока такое может быть.
Да, действительно, разные майнеры
окажутся чуть позже,
что разные майнеры решают все-таки разные пазлы.
То есть даже если у них одинаковые транзакции,
все равно пазлы у них будут разными.
Ну, смотри,
если разные майнеры будут решать
на тот же пазл,
то у них будут...
в сети будет появляться много...
Ладно, окей,
я понимаю, о чем ты говоришь, что раз блок одинаковый
будет полностью, наверное, и разница в них кто его нашел.
В общем,
это некоторая деталь, которую мы обсудим чуть позже,
но просто запомните, что
мы должны к этому вернуться.
Прямо у нас есть определенная лотерея,
и в нее выиграли двое,
два майнера,
и они нашли два разных блока.
Давайте они будут разноцветными.
Что?
Пока пазлы не разные.
Но мы считаем, что они разные,
потому что они будут разные.
Ну, пока вот пусть
два разных майнера для двух разных блоков,
у них были разные наборы транзакций,
допустим, нашли два продолжения.
Вот.
Вот карта этих двух блоков, в принципе,
имеет право прицепиться к блокчейну.
Вот то, что получилось,
называется форком.
У нас блокчейн
начал ветвиться,
и, видимо, он больше не блокчейн,
а блок 3 на самом деле.
Ну как, это будет, конечно, подозрительно,
если наш грозбух будет деревом,
не совсем понятно, как мы там собираемся
валидировать транзакции.
Все-таки выделим некоторые блокчейн.
Но пока вот это дерево получилось.
И вот этот форк нужно как-то разрешить.
Как мы собираемся его разрешать?
У нас конкуренция есть.
Вот мы, кажется, конкуренцию всегда
исправляли примерно одним способом.
Мы заставляли узлы сети голосовать.
Квор мы там собирали разные.
Но вот теперь собрать квор мы не можем,
потому что непонятно, сколько всего узлов.
Вот раньше каждый узел голосовал
своим identity. У нас теперь число узлов
переменное, но и хуже того,
виртуальные узлы могут добавлять,
византийские узлы могут
делать виртуальных участников,
так что identity уже не является
голосом, не может быть голосом.
Так что нужно голосовать
как-то аккуратнее.
И тут нужно на самом деле увидеть
одну очень крутую идею,
которая в блокчейне появилась, в биткоине
появилась, которая
очень сильно все меняет и
в будущем нам пригодится даже
в контексте систем, где конфигурация
фиксирована. Вот смотрите
на этот самый нонс, который решение пазла.
Это криптографическое
доказательство того, что какой-то
узел проделал работу, нашел блок.
Что этот нонс доказывает?
Что вот есть
блок B
и вот этот блок
он следует
за некоторым блоком
B'.
Ну, потому что
в заголовке
вот этого блока был
хэшпоинтер, то есть хэш предшествующего блока.
То есть мы с помощью нонса
доказываем, то есть мы вообще говорим
здесь не про индексы, мы про индексы уже
в этой реакции вообще не говорим, мы говорим про цепочки.
Это очень важно.
Это сейчас станет важно.
Мы не просто занимаем какое-то место в блокчейне.
Мы цепляемся к какому-то конкретному блоку
и нонс доказывает другим.
Но
как формируется хэш вот этого
блока B'?
Он считается от его заголовка.
А в заголовке
блока B' есть хэшпоинтер,
то есть хэш предшествующего блока.
И в итоге, когда мы находим нонс,
то он доказывает
остальным участникам сети,
что не просто этот блок
следует за этим блоком,
а на самом деле
гораздо больше, что этот блок
цепляется к конкретной ветке блоков,
которая сходится
в конце концов к блоку B'
который называется дженезит блок.
То есть да, это дерево,
но нонс говорит, что наш блок
прицепился к конкретной ветке.
Это очень мощное свойство.
И мы сейчас собираемся им воспользоваться.
Мы собираемся...
Вот у нас возник форк.
Мы хотим, чтобы участники проголосовали
за одно из продолжений.
Либо за эту ветку, либо за эту ветку.
Как они будут голосовать?
Они будут голосовать тем же самым майнингом.
Они просто будут майнить очередной блок.
Но когда они майнят блок, они выбирают
за кем этот блок пристроится.
За этим блоком или за этим.
И таким образом,
решая новый пазл,
они вкладывают в свое процессорное время
в то, чтобы
утвердить либо одну ветку, либо другую ветку.
То есть с одной стороны
они по-прежнему решают, они просто
пытаются выгнать лотерею, чтобы добавить блок самим.
А с другой стороны, они вот
этой лотереей заодно
укрепляют одну из двух веток.
Ну и смотрите, что выходит.
Вот у нас есть такая ситуация.
У нас есть сеть
и есть красный
майнер, который нашел блок
B'.
И есть синий майнер,
который нашел блок B''.
Когда майнеры нашли эти блоки, они начинают их
распространять.
И каждый
майнер,
который в этой сети находился,
получив один из блоков,
он понимает, что
ему
правила универсальные, которые
используются в блокчейне, называются
LaunchesChainWin.
Каждый майнер
майнит
блок B''.
И каждый
майнер, который
майнит
продолжение самой длинной цепочки
в блок 3.
Вот какой-то майнер здесь неудачливый,
он майнил продолжение вот этой цепочки.
Ему из сети прилетает, допустим,
красный блок. Он говорит, что
все, я проиграл эту лотерею,
попробую заново, попробую выиграть в новый.
Бросает свой блок и начинает майнить
за красной веткой.
Вот эти узлы, получив синий блок,
начинают майнить за синей веткой.
Ну и если вдруг
при Gossipе сеть поделилась
не совсем пополам,
а в какой-то пропорции, там большая часть,
меньшая часть, то получится, что часть
сети будет майнить
красную ветку,
меньшая часть будет майнить синюю ветку.
Ну и тут всякое может случиться,
но, скорее всего,
вот эта большая часть
найдет
новый блок
B3',
который следует
за блоком B', который следует
за этой цепочкой.
И уже в одиночестве
победитель, то есть
тут майнер, который нашел блок B3',
распространит его по сети,
и вся сеть будет следовать за этой цепочкой.
То есть, майнинг это с одной стороны
распределенная лотерея, а с другой стороны
это голосование, голосование
процессорными мощностями.
Тут дело, еще раз
обращаю внимание в том, что мы не просто
хотим занять какой-то индекс в этом логе,
а мы хотим прицепиться
к цепочке, поэтому сам майнинг является
голосованием.
Но голосование здесь не в терминах
Identity, не в терминах Quorum'ов,
а голосование
голосуем мы процессорами,
посвящая их решению
пазла для одной или другой ветки.
Понятная идея?
Ты получаешь блок, во-первых,
ты его валидируешь. То есть, ты проверяешь,
что действительно автор
этого блока нашел решение пазла,
и ты проверяешь теперь, у тебя есть
цепочка,
которой цепляется этот блок, и ты
можешь провалидировать каждую транзакцию
в этом блоке, проверить, что действительно
мачится цифровые подписи, и проверить,
что
транзакции тратят только не потраченные
ранее выходы.
Что это имеешь в виду? Ну, ты вот отправляешь
вот этот блок с транзакциями.
Просто вот B3'
не прицепится к B2'
То есть, когда оно дойдет...
Так, смотри, B3'
Когда ты майнишь блок, когда ты ищешь решение пазла,
вот еще раз, ты не просто
в контексте одного блока думаешь.
Чтобы майнить блок, ты должен выбрать,
к какому блоку ты цепляешься.
Вот ты выбираешь эту ветку,
голосуешь за нее, а дальше
ты голосуешь за нее,
начиная решать пазл для вот этого
хэшпоинтера.
Так что,
когда ты находишь B3'
то это значит, что он следует за вот B'.
Он цепляется
вот к этому, но он доказывает именно
это.
Ну, они не то чтобы полностью
выбросили его из своего
состояния. Они, конечно, помнят про
то, что вот есть fork, есть один
и другой. Но, когда они
выбирают, за кого майнить, они, ну, допустим,
майнет первый полученный блок.
Но держат память оба, потому что они не знают
заранее, чем fork разрешится.
B2' ассиротеет.
То есть, он...
За ним никто не будет следовать, и он просто повиснет
в этом дереве, такой маленький отрасток.
Но он все-таки теряет то, что он
пользовал того, что он ему посчитал.
Ну, пока никакой пользы для него и не было,
он просто радовался, что он выиграл в лутерею.
Это такая непонятно, в чем именно польза
для него была.
Но, да, он думал, что он победил в лутерею.
На самом деле, у него выигрыш отняли.
Ну, как обычно, у нас всегда есть
некоторая оценка снизу, сколько отказов мы можем
пережить. Вот у нас была
византийская модель, где узлы взрывались,
и мы говорили, что чтобы решить консенсус,
мы можем пережить менее половины
отказов. Если мы решаем консенсус,
то мы переживаем менее половины отказов.
Когда мы пришли в византийскую модель
и системы с жесткой конфигурацией,
то мы доказывали оценку
n больше 3f. Чтобы пережить
f отказов, нужно, по крайней мере, 3f
плюс один узел.
Сейчас все эти оценки
можно выбросить, потому что
они в терминах кворумов этих конфигураций.
Сейчас никаких конфигураций нет,
у нас перемышленная система,
и следствие нашего выбора,
что система полностью децентрализована,
и состав не фиксирован,
помимо замены Rotating Primary
на Allutereo, это еще и отказ
от кворумов, а значит отказ
от всех этих теорий. Но смысл
остался такой же. По-прежнему большинство
выбирает, что происходит, но большинство теперь
формулируется не в терминах identity,
а в терминах процессионных мощностей.
Вот если
в руках
честных узлов, которые соблюдают
протокол, находятся большинство
процессоров,
не в количестве, конечно, не в штуках,
а в хэш-рейте,
то есть сколько хэша они могут в секунду считать.
Но вот эти честные
узлы следуют протоколу, и скорее всего
их ветка будет выигрывать.
Но бывает всякое.
И если у тебя
вместо
таких вот оценок
ты говоришь,
что у тебя есть
так условно называется это
атака 51%.
Если вдруг византийские
участники получили контроль
над 51%,
над
больше чем половиной
процессорных мощностей,
то они могут направить блокчейн
в любую сторону.
То есть они сказали, что такое блокчейн.
Вот теперь блокчейн
это просто максимальная
цепочка.
Именно ее майнят честные
майнеры.
Так вот, если у тебя есть блокчейн,
но при этом какая-то максимальная
цепочка, построенная, наверное, честными узлами
пока, и тут появляется,
скажем, инопланетянин, у которого есть
какой-то очень мощный компьютер,
и просто большинство процессоров переходят
в какие-то в руки
узлоумышленника,
то он может взять
твою самую большую, самую длинную
цепочку.
Вот, допустим, мы нашли этот блок,
вот этот блок,
вот этот блок,
дальше
эта история как-то продолжилась.
Так вот, если есть византийские
узлы с большим
количеством процессоров,
то они могут сказать, что
они могут начать майнить вот эту
старую цепочку,
и если действительно у них
вот столько вычислительных мощностей,
то eventually они
видимо перемайнят вот эту цепочку.
И она станет блокчейном.
Ну, смотри,
мы делаем электронные деньги для
того, чтобы ты мог купить на них Ferrari себе.
А вот теперь представь человек, который продает
Ferrari.
Он вот здесь
получил от тебя биткоины,
отдал тебе Ferrari.
А потом эта цепочка была признана
откатившейся. И теперь
Ferrari у него нет, и биткоинов, которые он получил,
тоже нет, потому что они не вошли
в самую длинную цепь.
Поэтому это неприятная ситуация.
Понятно, что
протокол не может алгоритмически
пережить византийский отказ большого
количества узлов, но большой доли сети,
в смысле процессоров.
Но тут есть одно любопытное
отличие, которое выделяет
биткоин среди прошлых алгоритмов.
Действительно, никакой алгоритм не может
от такой проблемы
защититься с помощью
своих механик.
Вот таких алгоритмических идей, графических.
Но есть одна особенность.
А именно
мы делаем деньги, мы реплицируем
деньги.
И это важно по разным причинам.
В частности, это важно для самого протокола,
потому что...
Немного откачусь.
У нас проблема с тем, что у нас в таком протоколе,
протокол называется Nakamoto Consensus,
условно, что в нем даже комита нет.
То есть мы не понимаем, какая транзакция
зафиксирована. Никакая.
Потому что всегда можно перемайнить с почку.
Это еще одно
неприятное следствие того, что мы отказались
от жесткой конфигурации. У нас изменилось
правило выбора лидера.
То есть мы сделали лотерею. У нас изменилось голосование.
Теперь мы голосуем личностями, процессором.
И мы потеряли комит.
Дизайн-спейс у нас такой. Мы поменяли
условия на входе, поменяли
решение.
Но все это в целом работает
правда непонятно
по какой причине. Точнее, по какой причине
тысячи и десятки тысяч узлов
согласно этот протокол
поддерживать. Потому что
поддержание протокола стоит довольно дорого
для всей этой сети. Потому что каждый
участник, каждый майнер
грузит процессор свой.
Их должно быть довольно много
честных майнеров, чтобы убедить нечестных.
Так вот, пока непонятно
какова мотивация
отдельного майнера. Почему он
решает нонс и проигрывает в лотерею и продолжает
и продолжает это делать.
Вот тут
становится важно, что мы реплицируем
не произвольное состояние, а мы реплицируем
именно деньги. Потому что биткоин
от этих самых денег, от монет неотделим.
Почему они будут
отвергать их?
Подожди, они отвергать их не будут, потому что
блоки валидные. То есть форки могут
быть в биткоине.
Это нормально. Блок валиден,
если нонс
действительно дает право прицепиться
к цепочке. И если каждая
транзакция внутри этого блока тоже валидна.
То есть там цифровая подпись исходится, и
транзакции тратят неподрочные выходы.
Проблемов в этом нет.
То есть честный узел будет
накапливать форк, и если в
какой-то момент этот форк перегонит ту ветку,
которую minor-miner,
то он перекручится на самую длинную ветку.
Но по умолчанию minor-miner
манит самую длинную,
что у него есть.
Ты должен понять, когда ты расстанешься
со своей Ferrari, да?
Я поговорю об этом чуть позже,
пока я не могу ответить на этот вопрос.
Можно, конечно.
То есть ты можешь
со своими приятелями выделиться
в такую группировку и манить свой альтернативный блокчейн,
который начинается с B2B0.
Ну да, ты можешь так делать.
Ты имеешь на это полное право.
Еще и другие люди
имеют полное право игнорировать твой блокчейн,
потому что он будет по некоторым причинам
проигрывать главному.
Злоумышленник может делать double spend.
Злоумышленник может
игнорировать
новые чужие транзакции, просто не помещая
их в свой блокчейн, в свою ветку.
Давайте вернемся к моей мысли о том,
что блокчейн неотделим от денег,
потому что нужно чем-то майнеров
мотивировать, чтобы они продолжали
искать решения пазла, тратить процессорное время,
тратить электричество.
Мы реплицируем деньги,
майнеров нужно
чем-то отблагодарить.
Ну вот давайте мы будем благодарить
теми самыми деньгами, которые мы в этом блокчейне
реализуются.
Смотрите, в чем смысл.
Вот вся эта конструкция,
она поддерживает сама себя.
У вас есть вот такие вот
электронные монеты, цифровые монеты,
биткоины,
но при этом непонятно, почему люди
готовы к этой конструкции.
Но при этом непонятно, почему люди
готовы использовать их как
средства,
как валюта, как деньги.
Почему они готовы расставаться
с Феррари за эти монеты.
Но они так будут готовы делать,
только если они будут уверены, что вот
вся эта инфраструктура работает надежно.
Что транзакции,
если положили в этот распределенный
ledger децентрализованный,
она туда не откатится.
И транзакции падают в блокчейн за разумное время
и из него не пропадают.
Если этого не будет, если транзакции начнут
откатываться, то конечно же
этой валюте никто доверять не будет.
Она потеряет всю свою стоимость.
Поэтому стоимость всех этих биткоинов
она дерется на том, что у нас есть
стабильный децентрализованный
лог.
А стабильный децентрализованный лог
зависит от того, насколько много
в нашей сети честных майнеров, которые решают
получать базу.
Так вот, если мы будем
платить майнерам этими самыми
биткоинами, то они
будут заинтересованы, чтобы биткоины, которые они получают
в качестве премии за свою работу,
были стабильными. Для этого они должны
хорошо поддерживать консенсус.
Понятно? Вот такой вот цикл
получается. Так вот, а как же
эти майнеры будут получать
премию за свою работу в этих самых
биткоинах?
Для этого мы скажем,
что в каждом блоке есть специальная
транзакция. Вот эта ноль,
она называется Coinbase.
Она выглядит так.
У этой транзакции нет входа,
и она переводит
некоторое количество монет
самому майнеру.
То есть, майнер, когда он строит блок,
он получает какие-то транзакции
из сети, но в качестве первой
транзакции он
строит транзакцию,
которая печатает биткоины
и отдает ему.
И вот именно этой транзакции
будут отличаться блоки
и пазлы всех майнеров в сети.
Поэтому они решают разные пазлы.
И вот тут-то мы решаем,
кажется, последнюю проблему
с централизацией, которая у нас была.
Вот помните, где у нас была централизация?
Мы должны были поддерживать
и верифицировать
лог, но для этого у нас
есть такой протокол консенсса.
Мы должны были
связывать identity и публичные открытые ключи.
Мы от этой проблемы вообще избавились,
сказав, что identity и открытые ключи
одно и то же.
И у нас осталась
последняя задача, которая решалась
централизованная, это
брать денег.
Чеканка монет.
И вот мы, станок, который чеканит эти монеты,
встраиваем сейчас в сам блокчейн.
Каждый блок порождает
новые монеты и отдаёт
их майнеру.
И именно вот эта награда
мотивирует майнера
работать честно,
поддерживать лог стабильным,
потому что без этого его награда обесценится.
И вот то,
что мы реплицируем деньги здесь,
становится важно,
ещё и потому, что, смотрите,
вот если так
1,51%, когда у
византийских узлов
слишком много процессорных мощностей,
и, казалось бы, они могут
делать double span, то есть положить
в красные блоки транзакцию,
где они покупают что-то,
а потом идёт катить перемайни в другой блокчейн,
то есть потратить в ней те же монеты дважды.
Так вот,
алгоритмически мы этого защититься не можем.
Но тут работает другой фактор.
Смотрите,
византийские узлы, чтобы
получить...
Как византийским узлам контролировать вот такую долю
числительных ресурсов?
Им нужно иметь много процессоров.
Не просто много процессоров,
им нужно иметь много быстрых процессоров.
Ну, потому что от количества
процессоров, в принципе,
от того, насколько большой у них хэшрейт,
в их руках зависит объём выигрыша,
который они получают.
То есть
чем больше хэшрейт, тем больше выигрыш,
тем больше биткоинов.
Но чем стали заниматься люди?
Участники сети, они с одной стороны
частные, а с другой стороны нерациональные.
Они хотят свою выигрышу максимизировать.
Но они заметили, что можно перебирать хэши на процессоре
на ноутбуке, а можно
на видеокарточке перебирать что-то.
Или можно в конце концов
построить просто специальный процессор,
который будет делать
уметь только одно.
Быстро считать SHA-256 от SHA-256,
это хэш-функция в биткоине.
То есть мы строим специальное оборудование,
которое предназначено только для того, чтобы майнить.
И если мы хотим
часто выигрывать,
то мы покупаем очень много такого оборудования.
У нас такие огромные криптофермы
получаются
из этих процессоров.
И действительно тогда
мы можем заполучить в свои руки
очень много, ну большую долю
хэш-рейта, больше половины.
И можем делать дабл спенд.
Но нам это теперь не выгодно делать,
потому что если мы сделаем дабл спенд,
то это скопирует сам биткоин,
и он просто потеряет свою стоимость на рынке.
Но кто теперь
отдаст до него феррари, когда могут,
фрага ты отдашь, а биткоины тоже могут отнять.
Поэтому если
ты потратил очень много денег
на вот такое специальное оборудование,
тебе уже не выгодно делать такую атаку.
Потому что все твои инвестиции,
они пропадут.
Так что алгоритмически мы не защищаемся от такой проблемы,
но вот тут уже другие факторы работают.
Нам уже экономически не выгодно.
Идея понятна?
Окей.
Отличный вопрос.
Я, кажется, уже говорил сегодня,
что если ты печатаешь деньги грузовиками
на станке, то они обесцениваются.
Поэтому здесь мы тоже должны
каким-то образом
контролировать эмиссию,
чтобы биткоин сохранял свою стоимость.
Так что мы
договариваемся,
что...
Ну не мы договариваемся, в биткоине заложен
такой фундаментальный параметр.
Десять минут
фундаментальная константа.
Десять минут плюс
стартовый выигрыш в 50
биткоинов,
плюс
уполовинивание выигрыша, но
уполовинивание пока не важно.
В общем, на старте системы фиксируется, что
фиксируется размер
выигрыша, который приносит
каждый блок.
Если ты назначил себе выигрыш больше, то твой блок просто
повалидируется честными
узлами.
То есть ты написал, что ты получаешь миллион
биткоинов в Coinbase транзакции,
нашел нонс для этого блока,
отправил этот блок всем, ну а все сказали, что
он нам не нравится.
Он не похож на разумный.
Ну и
тут есть еще такие соображения, что
не соображения пока.
В биткоине
каждый блок генерируется
не то чтобы с конкретно
сфиксированной частотой, но в
среднем с частотой раз в 10 минут.
Это
позволяет контролировать эмиссию, то есть скорость
появления монет.
Если вдруг
в сети удвоится количество
участников, то это не значит, что денег
будет запускаться в единицу времени в два раза больше,
потому что в два раза больше
блока будет находиться.
Вот мы такого
допустить не хотим. Мы говорим, что
блоки должны появляться в среднем раз в 10
минут.
Ну а для этого у нас есть
настройка, а именно параметр
D, сложность пазла.
Вот D это
не константа уже, D это
величина, которая регулируется,
децентрализована, настраивается отдельными
вот D должно быть
D это некоторый глобальный
параметр, но он как бы у каждого
узла свое понимание текущего D.
И это
общее понимание
складывающееся из локальных
мнений относительно D
должно быть таким, чтобы
несмотря на меняющийся hash rate
всей сети,
D должен быть таким, чтобы блок
появлялся бы каждый раз в 10 минут
и приносил бы фиксированный выигрыш
Майнеру через Coinbase транзакцию.
Каким образом устроена
регулировка этого D может возникнуть
вопрос? Как Майнеры его настраивают?
Они настраивают его
каждые
пересматривают значение D каждые
две недели, каждые там
2016 блоков или что-то похожее
могу собрать.
Раз в две недели Майнер смотрит
на
в какой-то позиции лого
в какой-то длине цепочки, он смотрит
на блокчейн и смотрит
как на хвостике этого блокчейна
появлялись блоки. Нужно ли увеличить
сложность D? Может быть, боти стали
превратиться слишком часто.
Вот тогда D увеличивается. Если стали
слишком редко, D уменьшается.
Вот эту корректировку D
каждый узел в сети делает
локально, но эта процедура, хоть она
локальна, но она детерминирована, поэтому
все узлы меняют D одинаково.
В смысле синхронно относительно
индекса высоты каждого блока.
Так что какие-то византийские узлы
могут, скажем, это дело игнорировать.
То есть они могут
не увеличить себе D и искать блоки быстрее,
находить их чаще, и у них будет блокчейн
длиннее. Но
честные узлы, просто привалидации будут
эти блоки отвергать, потому что они считают,
что в текущей позиции, в текущей высоте
D должен быть больше.
Если ты подключишься к Биткоину
и будешь майнить на ноутбуке,
ты никогда не заработаешь денег.
Просто потому, что
люди уже понастроили специальных
процессоров, и
вычислительная мощность сети Биткоина
сейчас 150, кажется, 160
экзохэшей в секунду.
Ты соперничать не сможешь
с ними.
Если бы они не были,
они бы не были.
Это интересный вопрос.
Я не знаю, сколько у нас времени осталось
лекции, но давно закончилось,
наверное, но еще не закончилось.
Мы сделаем прерыв, потом продолжим.
Это такое одно большое занятие.
Так вот, вернемся.
Я говорил про то, что
Биткоин неразрывно связан
с деньгами, с тем, что он реплицирует
печатный станок и вот всю эту систему
с транзакциями, потому что в этом
то, что он реплицирует всю эту систему с транзакциями,
потому что, во-первых, нужно матиировать
майнеров, продолжать работу, поддерживать стабильный лог.
Для этого мы платим им Биткоинами
через Coinbase-транзакции.
Во-вторых, мы
регулируем
скорость эмиссии,
скорость работы печатного станка,
подстраивая это так, чтобы каждый бот
появлялся в среднем раз в 10 минут.
Понятно, что он может появляться быстрее,
может появиться через 3-5 минут,
но просто потому, что пазл так работает,
потому что кто-то в лутере выиграл раньше.
На большом интервале это будет
в среднем раз в 10 минут.
И еще одно замечание,
которое касается
вот этого неравенства.
Эмиссия Биткоина, в принципе, ограничена,
то есть рано или поздно
новые Биткоины перестанут появляться,
потому что каждый
несколько лет
выигрыш
за нахождение очередного блока,
победу за выигрыш
в лутере уполовинивается.
Изначально он был равен 50 Биткоинам,
сейчас это 6.25.
В какой-то момент выигрыш станет
неотличим от нуря,
и мотивация у майнеров
пропадет.
Майнить блоки ради этой coinbase транзакции.
Что же заставит их
продолжать работу?
Просто вот это
это правило,
оно зашито,
зашито
с старта Биткоина,
зашито в протокол.
Рано или поздно Биткоины перестанут
печататься.
Что же заставит майнеров
все же продолжать майнинг,
заставит их тратить электричество?
Чтобы продать
тот же Биткоин
нужно, чтобы системы работали.
Ну а тем, у кого
Биткоинов не очень много,
они могут бросить их.
Дело в этом,
выигрыш
не должен уменьшаться,
природа этого выигрыша
изменится.
Когда мы говорили по транзакции,
мы сказали, что сумма на входе
должна быть не меньше, чем сумма на выходе.
Это понятно, потому что мы деньги
из воздуха тогда берем.
Но она может быть больше.
То есть мы потратили какое-то количество монет,
точнее мы у себя
забрали какое-то количество монет,
а передали магазином
или себе на сдачу меньше,
чем у нас было.
У нас какие-то излишки образовались, куда они пошли?
Вот эта дельта, эта разница
между суммой входов
и суммой выходов,
она отправляется майнеру в качестве
комиссии, которую мы платим майнеру
за то, чтобы он включил наш транзакцию в блок.
И тут
просто происходит аукцион.
Вот вы, не знаю,
бедняк, у которого есть транзакция,
который хочет одну
миллиардную биткоин
перевести.
И у вас нет денег на комиссию, зато есть другие люди,
которые переводят там, не знаю, миллион долларов,
и у них комиссия какая-то существенная.
Так вот, майнер вашу транзакцию переводит просто.
Просто потому, что ему не выгодно
включать вашу, потому что размер блока ограничен,
он не может быть слишком большим.
Потому что этот блок нужно распространить
по сети еще довольно эффективно.
Размер блока в биткоине это
порядка мегабайт, полуторамегабайт.
И вот майнер, который получает транзакцию
от пользователей, он смотрит на их комиссии
и понимает, какие транзакции ему в первую очередь
выгодно поместить в блок, который он майнит.
Если вы предложите ему
большую комиссию, то
скорее всего, он согласится.
Вот когда майнер перестанет получать выигрыш
из coinbase транзакции,
природа этого выигрыша
изменится.
Он станет формироваться преимущественно из комиссии.
Она не откуда берется, она помещается просто в блок.
Это транзакция, которая занимает
это первая транзакция в блоке,
эта транзакция
не имеет входа,
она просто печатает деньги из воздуха.
Там есть только выход.
И вот майнер,
который формирует блок, он вправе в блок
поместить одну такую транзакцию
по протоколу
и выплатить выигрыш себе.
Выигрыш определяется детерминированно, исходя из длины цепочки.
Но это один способ
сжечь деньги.
Если ты хочешь деньги уничтожить,
ты можешь отправить их на
несуществующий адрес.
Я бы сказал, другая проблема есть,
но не то, что
тебе скорее должно беспокоить то,
что если ты вдруг лишишься
своего секретного ключа,
которым ты подписываешь
свои транзакции,
то все биткоины, которые тебя отправили,
они станут недоступны для тебя,
ну и не для кого, для всех станут недоступны.
Таких историй много,
но я думаю, что
это не то,
что ты искал,
ну таких историй много,
да,
это та самая история.
То есть ты уже не сможешь прийти в банк с паспортом,
потому что нет никакого банка,
мы решили от него отказаться,
и паспорт у тебя тоже никто не спрашивал на входе,
поэтому у тебя есть только твой секретный ключ,
только им ты можешь доказать, если ты его лишился,
то все.
Но сейчас выигрыш есть,
и комиссии тоже есть.
Ну как бы это рынок,
то есть если вдруг ты начнешь требовать больших комиссий,
то понятно, что есть другой
майнер, и он может
все устроить.
Вопрос?
Да, вот,
давайте вернемся к комиту,
я обещал и забыл про это.
Мне нужно было про 10 минут рассказать.
Вот блоки
появляются не слишком часто,
потому что если они будут появляться слишком часто,
непредсказуемо, или они станут очень большими,
то это просто повысит
вероятность форка, но система будет часто в нестабильном состоянии.
Вот
параметры подобраны и подогнаны таким
образом, чтобы все-таки блокчейн
не стабилизировался, и там форка в длиной
больше одного-двух не бывает особо.
Поэтому,
ну а в принципе
гарантировать, что если,
гарантировать, что транзакция в этом блоке
навечно принадлежит блокчейну,
то есть самые длинные цепочки в этом дереве
нельзя, невозможно. Всегда
можно перемайнить.
Поэтому
используют такое виприческое правило.
Но, кстати,
немного похоже на рафт. Смотрите,
вот каждый блок,
когда он появляется
с каким-то нонсом, то он,
то есть с одной стороны
мы знаем, что какой-то майнер выиграл
лутерею, а с другой
стороны мы знаем, что большая часть
сети, большая часть сети
проголосовала за продолжение этой цепочки.
Вот каждый блок, который накрывает,
мы закоммитили транзакцию,
а вот она здесь,
ну не закоммитили, мы
поместили в блокчейн транзакцию
и каждый блок,
который сверху ее накрывает,
он ее как бы придавливает.
Это вот голос большей части сети
за вот эту ветку,
в том числе за ветку
с блоком с этой транзакцией.
Поэтому действует так, если
твою транзакцию накрыла
6 блоков, то ты считаешь, что
перемайниться эта ветка, скорее всего, не сможет.
Ты этому веришь.
Но есть разные способы
это ускорять.
Можно задействовать банк, который
возьмет на себе риски.
Понимаешь, да,
примерно, чем я клоню к тому, что
если твою транзакцию накрыла
еще один блок, то это
такой шашок в сторону комита.
Вот банк может посмотреть и сказать
магазину условному, что да, я верю,
что транзакция не откатится.
Сделка состоится сразу, а банк
возьмет на себе риски в случае, если транзакция
не откатится.
Тут можно разные эвристики,
идеи использовать.
Очень сложная инфраструктура вообще биткоина.
Это не про алгоритмы, но не только про алгоритмы.
Это про очень много разных вещей про экономику,
про криптографию,
про самые разные области.
Алгоритмически мы не можем гарантировать
комит. В биткоине, в блокчейнах
это называется, там все называется
альтернативным образом, там у нас не логи
аледжеры,
не команда, не логи,
а транзакции блокчейна
и не комит, а свойство
финалити, оно называется.
Вот этого нет. Если мы
используем протоколы типа
BFT, то есть. Если мы используем
протоколы, где у нас
число участников не фиксировано,
то комита у нас больше нет,
финалити у нас нет.
Так здесь нет никаких часов.
Сейчас, подожди, что ты имеешь в виду?
Майнинг он на часы не завязан никак.
Мы просто майним самую длинную ветку.
Ну да, в блоках есть
временная метка. Она
не обязана быть точной.
Честно говоря,
я вот здесь детали не знаю, но легко
предположить, что верификация
может проверять, что временная метка какая-то разумная.
Ну, по крайней мере, они монотонные.
Понятно.
Да, в блок добавляется
временная метка.
Это важно,
потому что правило пересчета D
зависит очевидно от этих временных меток.
А правило
коррекции D должно быть детерминировано,
работать одинаково на всех частных узлах.
Вопросы кончились?
Давайте тогда какой-то итог
подведем.
Кажется, мы решили
задачу репликации лого
принципиально другим способом.
Выглядит все очень
непохоже, но я бы сказал, что
во-первых, похоже, я сейчас объясню
повторю еще раз, почему я так считаю,
а во-вторых, в чем причина всех этих
различий? Причина кажется ровно в одном месте.
В этот момент, она появилась в этот момент,
возникла эта причина, когда мы
решили, что число узлов
в нашей сети будет нефиксированным
и к этой сети можно свободно
присоединяться.
Именно поэтому, то есть мы по смыслу
также ротировали лидера,
ротировали узел, который
продолжает цепочку, продолжает наш
лог. Но в PBFT
мы ротировали его относительно жесткой
конфигурации, просто увеличивали индекс,
брали по модулю. Сейчас
мы вместо этого используем децентрализованную лутерею.
Но задача,
то есть цели этого механизма
ровно такие же.
Раньше мы обеспечивали,
мы голосовали
кворумами, голосовали
своими уникальными идентификаторами,
которые формировали
всю систему. Сейчас у нас
снова состав узлов переменный,
идентификаторам верить нельзя, потому что
византийские узлы могут порождать
виртуальные идентификаторы,
виртуальных
майнеров,
виртуальных майнеров не могут порождать
в этом идее. В том, что виртуальный участник
с идентификатором может быть, а виртуального
процессора быть не может. Процессор должен быть
настоящий в конце концов. Поэтому мы
голосуем не идентификаторами, мы голосуем
процессорами. Но смысл примерно такой же
мы снова требуем большинства.
Дальше.
Какие еще сходства?
Снова есть какая-то нижняя граница.
Только какую долю византийских отказов
мы можем пережить?
У нас была треть, половина
для византийских треть. Сейчас у нас
снова половина, но уже опять в процессорах.
Правда, теперь
нас эта граница не так беспокоит,
потому что если вдруг появятся
византийские узлы,
появится византийский
участник с огромными
вычислительными мощностями, то он все равно не сможет
сделать дабл спенд, потому что вот просто
экономические соображения его остановят.
И мне кажется,
самая мощная идея,
это все про сходства,
а про различия,
мне кажется, что очень мощная идея,
которая у нас здесь возникла, это
хэшпоинтеры.
Мы отказались от индексов,
мы теперь не рассматриваем позиции в логе
независимого, мы майним именно цепочки.
И когда мы находим нонс,
то есть вот этот proof of work, который лежит
в основе всего этого
алгоритма, он с одной стороны, да,
реализует выбор лидера, а с другой стороны,
он с помощью вот
кумулятивности этих хэшпоинтеров,
которые вкладываются один в другой,
позволяют нам и голосование
устраивать.
И вот если вы помните,
в следующий раз я об этом расскажу
на последнем занятии,
как можно биткоин объединить с PBFT.
Идея главная там такая,
помните, как было в PBFT,
мы получали транзакцию
с порядковым номером от Primary,
а потом обменивались
и пытались понять, что на большинстве
частных реплик транзакция
эта транзакция,
а потом мы еще раз обменивались
и пытались понять, что большинство частных реплик знают,
что на большинстве частных реплик это транзакция.
Ну, это знание
как бы кумулятивно накапливается с каждым раундом.
И для каждого слота это было все независимо.
А здесь
это знание накапливается через блокчейн.
Через вот эти нонс, через хэшпоинтеры.
В смысле, вот эта вся конструкция, она накапливает это знание, и если это
аккуратно склеить с корумбными сетификатами, то можно получить очень
быстрый фиксированный PBFT. Ну это вот в следующий раз.
Там будет фиксированная конфигурация, но мы, используя вот эту идею,
которую в принципе можно от биткоина-то оторвать, можем ускорить тот протокол.
В блокчейнах есть два мира. Один мир permissionless, где сеть не фиксирована,
число участников не фиксирована, и второй мир это, где у нас конфигурация жёсткая.
Ну и вот в одном случае используется Quorum, и в другом случае используется...
Да, в чём ещё отличие, точнее параллель. У нас был бродкаст, где мы общались со всеми.
Сейчас у нас Gossip. Ну короче, вот все различия и все сходства, они есть,
потому что задача одна и та же, а все различия в одних и тех же подзадачах,
они возникают потому, что у нас число участников динамическое.
Ну вот эта идея, её можно в обратную сторону перенести с хэшпоинтерами.
Использовать её и в статической конфигурации.
Ну и чтобы эту часть занятия завершить, давайте я поговорю про два забавных нюанса.
Вот смотрите, мы вроде бы избежали...
Да, и последнее различие я забыл. Самое главное, мы решились коммитом.
Именно из-за динамичности.
Теперь про децентрализацию немного. Вот с одной стороны, мы от банков избавились.
То есть нам банки не нужны для того, чтобы скрывать этот лог для приватности,
или для того, чтобы упорядочивать официальные транзакции, можем делать распределённо.
Нам не нужен банк, чтобы он печатал деньги заданным рейтом.
И нам не нужен банк для того, чтобы связывать идентити и открытые ключи.
Вроде бы мы никому не доверяем.
Но вот есть место, где мы всё-таки доверяем кому-то.
То есть невозможно запустить систему децентрализованную византийскую совсем без доверия.
Где-то на старте мы должны кому-то доверять.
Вот где здесь доверие сосредоточено во всей этой конструкции?
Нет, во-первых, один человек не имеет смысла формировать.
Нужно объединяться в целые группы, а во-вторых, когда транзакция...
Сейчас, подожди. Один человек, это немного про другую речь.
Вот я говорил, что система Bitcoin поддерживает сам себя.
У нас у валюты будет стоимость, когда под ней будет надёжный реплицированный лог.
А эта надежность реплицированного лога достигается честной работы майнеров.
А майнеры продолжают работать, потому что они майнят валюту, получают в этих монетах выигрыш,
поэтому они заинтересованы, чтобы целость сохранялась.
Вот получается такая система, она поддерживает сама себя.
Но на старте, конечно, этого ничего нет.
На старте у нас есть один условный Сатоша неизвестный,
который майнит в одиночку на своём компьютере, получает весь выигрыш.
Ну, я покажу после первого сам Блокчейн, с чего он начинался.
Это один человек, он майнит на своей одной машине.
И, конечно же, легко злоумышленнику прийти и перемайнить всё.
Но с другой стороны, какой в этом прок, потому что Bitcoin пока ничего не стоит.
Он стоит ноль, потому что им пользуется один человек.
Так что и атаки делать бесполезно на эту криптовалюкту.
Ну, если просто вы не злобный какой-то очень.
Так что вот если система набрала ход, то да, она сама поддерживает себя и довольно устойчиво.
На старте, конечно, она неустойчива, но с другой стороны, она никому не интересна.
Но это про другое речь, это не про доверие всё же.
Так где bootstrap-то?
Ну вот нам нужно бы ноль знать.
Вот бы ноль — это некоторый произвол.
Вот нам автор блокчейна говорит, что хэш первого, хэш нулевого блока — вот он.
Вообще вот представьте себе, что вы приходите в систему, и вам нужно узнать блокчейн.
Как вы поймёте, какой блокчейн нужно майнить?
Да.
А как мы вообще приходим в систему?
Ну это гость, и ты должен иметь некоторых сидов всегда.
То есть чтобы войти в систему, тебе нужно знать какие-то узлы, которые системе принадлежат.
Да, ну ещё я бы сказал, что GitHub — это тоже источник централизации,
потому что я вам в чате кидал ссылку Yellow Paper Эфириума.
Такая вот формальная спецификация, там много деталей.
У Биткоина, кажется, такой нет спецификации.
Ну то есть это как в Пайтоне.
Стандарт Пайтона — это вот имплементация виртуальной машины CPython.
Это вот то, как язык себе должен вести следовательно за реализацией.
Кажется, точно так же есть клиент Биткоина, и это такая точка истины.
Как должен работать протокол, в конце концов.
Так что мы доверяемся здесь ещё группе людей.
Люди сходятся в том, что репозитория на GitHub — это действительно Биткоин.
Именно этот репозиторий — это протокол Биткоина.
Ну вот видишь, ты как бы порождаешь разделение какое-то.
Люди договорились, что всё-таки Биткоин на GitHub — это вот правильный Биткоин.
Так что значит потеряют? Они его и не хранят.
Это просто в скрижалях выписано, что вот хэш нырёвого блока такой.
Если блокчейн начинается с другого блока, то это не блокчейн.
Блокчейн не Биткоина, возможно, что-то другого.
Ну вот об этом, то есть вопрос, как пойти в систему.
Подожди, как пойти в систему? Вот это написано где-то.
Как пойти в систему? Ну, ты должен знать участник, который уже находится в системе.
Это может быть написано в интернете где угодно.
Может быть какой-нибудь DNS-адрес, который мачится в какие-то СИДы.
В любом случае тебя могут обмануть.
Это никогда не кончится, можно часами говорить.
Ну база в смысле блокчейна — это вот джанезис-блок и в него все верят.
В этом джанезис-блоке в тексте транзакции есть цитата из газетной заметки.
Ты знаешь, что в этом блоке, прямо у этого хэша, должна быть заметка газетной газеты за такое число.
Поэтому если ты веришь, что газета тебе не обманывает, я архив не обманываю тебе.
Ты можешь еще проверить. Мы доверяем вот еще этому.
Но вот только на старте больше никому не доверяем.
По поводу твоего вопроса, ты приходишь в систему и ты общаешься с разными узлами.
И кто-то из них может давать тебе честные блокчейны, кто-то может набрать.
Ну во-первых, тут любопытное замечание. В этой системе нет снапшотов.
Вот у нас логи растут, они растут, кажется, неограниченно.
Раньше мы снапшоты делали.
Но раньше мы делали снапшоты просто независимо на каждом узле
и верили другому узлу, к которому присылается снапшот.
В прошлый раз в PFT мы перестали так делать, в смысле верить, к которому присылается снапшот.
Нам нужно было приложить к нему сертификат, что вот в каждом узле мы делали снипшоты.
Когда мы делали снапшот, нам нужно было приложить к нему сертификат,
что вот в этой позиции лога большинство честных узлов сделали снапшот с этим кэшом.
Вот тут это больше не работает, потому что сколько узлов непонятно,
и такой сертификат не собрать уже.
Поэтому блокчейн копится вот с самого начала.
Но правда он копится относительно медленно, то есть он сейчас занимает сколько?
300 гигабайт, кажется, можно с этим жить.
Но тем не менее, мы должны провалидировать сам блокчейн.
Разумеется, если блокчейн сходится не в B0, значит это неправильный блокчейн.
А дальше мы получаем от разных узлов, там есть честные, там есть византийские, разные блокчейны, они сходятся к B0.
Мы можем провалидировать эти блокчейны, они все честные, в смысле транзакции нонсосходятся,
транзакции не тратят потраченные выходы, сложность адаптирует сразу.
Короче, мы можем проверить эти блокчейны по отдельности, они все валидные, но они разные.
У них разная длина, разная сложность, мы должны между ними как-то выбрать.
Такая проблема действительно у тебя может быть. Как же ты поступишь?
Самый длинный.
Самый длинный. Я сел за свой компьютер и начал генерировать блоки.
Я выбрал D очень маленькое, поэтому я генерирую очень быстро, напишу там какие-то сомнительные временные метки внутри.
У меня очень длинный блокчейн, он может быть даже длиннее, чем настоящий.
А может быть еще очень короткий блокчейн, он короче настоящего, но он сложный.
Там D больше, а настоящего ты все равно не знаешь.
То есть ты не можешь сказать, что он короче настоящего, нет никакого настоящего, есть просто три варианта у тебя.
Как ты это переживешь?
Так нет, джанейз блок у всех одинаковый.
Вообще кажется даже в клиента встраивают чекпоинты, то есть какой-то там 100 тысячный блок был с таким хэшом.
Но это отступление от принципов биткоина, потому что ты доверяешься какому-то одному источнику.
Смотрите, как можно отделить. Представим, что есть очень короткий блокчейн, но очень сложный.
Почему мы его оттечем? Он короче настоящего и сложнее настоящего.
Почему мы его оттечем? Потому что он не будет расти раз десять минут.
А из тех, кто будет расти, мы просто оставим тот, который самый сложный.
Вот и все.
То есть слишком сложный честный он не растет.
А из тех, кто растет, видимо, самый сложный, это тот, кто над кем трудится большая часть сети.
Если ты живешь в изоляции где-то и не можешь узнать ни одного честного узла, то в принципе тебя могут умолнуть,
ты будешь майнить, что ты не то.
Но если ты не совсем изолирован от окружающего мира, то скорее всего ты попадешь в какие-то честные узлы
и сможешь из них достать правильный блокчейн, присоединиться к нему.
Ну да, это фундаментальная константа.
Среди них самый сложный выбирать будем.
Потому что мы знаем, что в него вложены максимальные усилия, максимальные процессорные мощности.
Ну что, давайте сделаем перерыв, если вопросов у нас пока не осталось.
Вопросы пока закончились, потому что я рассказал.
И после перерыва продолжим.
Ну что, давайте начинать, на чем мы остановились.
Тут можно на самом деле про биткоин и про блокчейн и миллиард вещей обсудить.
Они все касаются распределенности.
И про распределенность мы договоримся в следующий раз.
Но какие-то вещи касаются, а вот есть некоторые вещи, про которые просто невозможно не рассказать.
Например, как биткоин использует криптографию.
Вообще примеров миллион.
Ну вот мы уже видели про криптографические хэш-функции, про адреса.
Кстати, да, мы не поговорили, почему мы готовы адресовать транзакции хэшами.
Пока вы можете об этом подумать, если что.
Ну зачем я спрашиваю вас.
Вот есть еще один забавный криптографический инструмент, который в биткоине используется, который описан прямо в исходной статье.
Итак, у нас есть большой блокчейн.
Он хранится на всех узлах сети.
И вот узел, узлы валидируют, получают новые блоки, встраивают, их блокчейн валидируют, транзакции валидируют, нонсы валидируют, сложность, награду, который получил Майнер.
Они хранят довольно много данных.
А теперь представим, что вы торгуете бургерами, и вы не хотите поддерживать всю эту информацию у себя и валидировать.
Вот можно ли вам как-то сэкономить?
Вот ожидается, что можно, потому что можно, если вы просто магазин, вы можете у себя хранить.
Но вам нужно, конечно, понимать, когда транзакция, которая приводит вам деньги, закомитилась.
То есть она попала в блокчейн, и ее накрыло достаточным количеством других блоков.
Но с другой стороны, вы не хотите все эти транзакции из всего блокчейна хранить у себя.
Для этого вы можете сделать следующее. Вы можете хранить из этого блокчейна или блокдерева только заголовки.
Ну, потому что хэш считается по заголовку.
То есть кумулятивный хэш транзакций считается по всем транзакциям.
В заголовке остается этот хэш, но вот его достаточно, чтобы проверить нонсы.
Магазину достаточно хранить цепочку из заголовков блоков.
Как же теперь вы покупать или докажете магазину, что ваша транзакция вошла в блокчейн и лежит там уже час?
Если у магазина есть только заголовок соответствующего блока.
Но вы говорите, что вы принадлежите к такому-то блоку, ваша транзакция попала в такой-то блок,
и вы должны приложить сертификат, который докажет криптографически, что действительно эта транзакция в этом блоке встречается.
Для этого важно, как считается хэш кумулятивный для заголовка.
Он считается с помощью дерева Меркла. То есть мы берем все транзакции, считаем их хэши.
Потом мы организуем все эти хэши, делаем их листьями бинального дерева.
И пересчитываем, агрегируем хэши в изученных узлах.
Комбинируем левого и правого потомка.
И вот корень этого дерева, корневой хэш, это то, что лежит в заголовке блока.
Если у вас в заголовке блока лежит хэш, построенный таким образом,
то чтобы доказать, что ваша транзакция принадлежит блокчейну, вам не обязательно предъявлять все транзакции в этом блоке.
Вы можете построить сертификат алгоритмического числа транзакции размера,
а именно вы можете предложить свою транзакцию, по которой можно посчитать хэш.
И посчитать и предложить хэши соседей на пути от вашей транзакции до корня дерева.
То есть вы прикладываете свою транзакцию, раз хэш и два хэш.
И вот эта информация доказывает магазину, что действительно ваша транзакция содержится в блоке
вот с таким вот корневым хэшом.
Давайте теперь просто покажу, чтобы мы видели.
Вот блокчейн-эксплорер.
И вот, пожалуйста, прямо сейчас майнятся какие-то блоки, подают какие-то транзакции.
Вот видно, что частота появления блоков, это не то чтобы раз в 10 минут, но как поведет.
Вот тут раз в 2 минуты блок появился.
Через 2 минуты блок появился, просто потому что так лотерея сложилась.
Высота сейчас, то есть количество блоков, вот 700 тысяч.
Ну и давайте посмотрим на какой-то блок.
Вот, в нем есть coinbase-транзакция.
Победитель получил с одной стороны 6 с 25 битковинов,
просто потому что так приписывает протокол, потому что сейчас станок так настроен.
И вот суммарная комиссия, которую майнер получил от всех транзакций, которые в этот блок вошли.
Сам блок довольно небольшого размера получился.
Вот нонс, который этот блок верифицирует.
Корень, дерево меркло, это кумулятивный хэш всех транзакций.
Транзакций, как видно, немного.
Вот видите, размер блока это какие-то единицы мегабайт.
Количество транзакций тысячи.
Каждый блок появляется раз в 10 минут.
Rate с мехотворной.
То есть это не сравнить с банком, насколько он может в секунду транзакции обрабатывать.
Ну представьте себе, любое число разумное, которое приходит в голову,
а тут раз в 10 минут обработано было тысячи транзакций.
Не похоже на систему, которая претендует на замену наличным деньгам.
Давайте посмотрим на...
Где-то у меня был открыт, наверное.
Вот нулевой блок, вот канонический хэш, вот мы ему должны верить.
Вот первый выигрыш, который был получен.
Там была всего лишь одна транзакция, то есть некому было деньги еще переводить.
Блок состоял только из coinbase-транзакции.
И Саташа получил 50 биткоинов.
И смотрите, вот самое начало истории биткоина.
Тут все транзакции, мне кажется, все блоки пока довольно неинтересно устроены,
только coinbase-транзакция.
И где-то должен появиться первый блок, в котором совершена
первый трансфер биткоинов настоящий.
Честно не знаю, может быть, сходу не скажу.
Ну смотрите, видите, человек выключил компьютер.
Вот этот блокчейн не слишком устойчивый, понятно, к атакам.
Да, здесь, наверное, первый перевод.
Исторический момент.
Давайте посмотрим, где-то должна быть статистика сети.
Вот смотрите, когда-то манил один человек на одном компьютере, на одном процессоре.
Сейчас у нас в секунду считается 160 экзохэшей.
Это 10-18, кажется.
Откуда так много?
Ну потому что это уже не процессор, потому что это специальные компьютеры,
которые специальные железки, которые предназначены только для того, чтобы эффективно вычислять хэши.
Так что вы на этом рынке, в этом мире уже не можете тягаться.
Ваши вычислительные возможности, ваш компьютер, ваш ноутбук – это просто бесконечно малая капля в этом море.
И если вы хотите вдруг войти в систему и повысить ее надежность, то от вас пользы никакой.
И выигрыш у вас тоже никакого не будет.
Может быть на бесконечности вы выиграете, но в жизни никогда вы не выиграете ничего.
Вы не заработаете ни одного биткоина.
Поэтому как же быть?
Вы вроде бы участвуете в лутереи, но билетиков столько много,
и у ваших конкурентов столько много билетов накапывается, что вы не можете их обыграть.
Что делать, если ты не можешь выиграть в лутерею и прожить на это всю жизнь?
Ты идешь на работу, то есть ты продаешь свое время другому человеку.
Как это происходит?
Как это происходит в биткоине?
Ты маленький компьютер, ты участник с маленьким компьютером,
и ты не можешь сам в одиночку ничего найти.
Но ты можешь передать свои вычислительные мощности работодателю,
он может их саккумулировать,
и он уже обладает совокупностью процессоров, уже сможет что-то выиграть.
Так появляются пулы.
У пула есть оператор.
Это участник, который формирует блок, который нужно будет майнить,
нонс для которого нужно будет искать.
И оператор пула назначает coinbase-транзакцию в этом блоке, который переводит деньги ему.
Если этот пул выиграет 6.25 биткоина, то оператор пула эти деньги получит.
И оператор пула предлагает всем участникам этого пула майнить этот блок.
Если какой-то участник найдет нонс для этого блока, то понятно, что он забрать выигрыш себе не может.
Потому что coinbase-транзакция не ему адресована.
В блоке есть coinbase-транзакция, которая направляет выигрыш кому-то.
Кто-то это оператор пула.
Так что если ты даже найдешь решение пулы, то ты найдешь его для работодателя своего.
Но почему ты так делаешь?
Потому что ты вообще не веришь, что ты найдешь решение пузла.
Но все же ты хочешь, чтобы за твою работу, пусть даже бесполезную,
то есть ты носишь маленький вклад в это вычисление,
ты хочешь, чтобы тебе за него заплатили.
Так что ты надеешься, что оператор будет тебе просто выплачивать некоторые фиксированные зарплаты.
Если оператор этого делать не будет, то ты просто уйдешь,
просто потому что зачем тебе такой работодатель?
Так что проблема у тебя нет.
Проблема у работодателя, у оператора пула,
а как именно распределить награду за участие в вычислениях.
Вот ты оператор пула, у тебя там, не знаю, 150 машин, 150 участников.
Они что-то делают, и возможно кто-то из них находит решение пузла.
Но вот остальным тоже нужно заплатить, потому что они тоже могли выиграть.
Ты уже не знаешь, кто из них будет полезен.
А возможно они ничего не делают.
Возможно они ничего не делают, да. Возможно они просто пьют кофе целый день.
Но может пропорциональное число просчитанных хешей?
Да как ты узнаешь, сколько хешей перебрал участник пула?
Ну если рапорта не сочетается.
Ну если рапорта не сочетается.
Так вот, если вы не умеете доказывать оператору пула, что вы полезны,
то его заплатить не будет.
Ну если мы строим систему бездоверия, то непонятно.
Вот, можно как доказать оператору пула, что вы сделали что-то полезное.
Но вы не сможете найти хеш, который начинается, скажем, с 19 нулей.
Но может быть вы найдете хеш, который начинается с 18 нулей.
Это значит, что вы довольно полезны, весьма полезны.
А может быть вы найдете хеш, который начинается с трех нулей,
потому что вы на калькуляторе маните.
Есть в интернете статья, где человек манит на бумаге.
Просто рассчитывает, перебирает и читает SHA-256.
Ну вот, у каждого свои возможности.
Так вот, вы можете вычислить, то есть вы можете найти хеш,
который начинается с какого-то количества нулей.
И чем больше этих нулей, тем, видимо, больше ваш вклад в работу пула.
Тем более вы полезны.
Ну и вот на основе, вы можете провести раунд, ничего не найти.
То есть кто-то нашел блок с 19 нурями в начале хеша,
а вы нашли блок с 15 нурями.
Ну вот вы этот хеш предъявите оператору и скажете, что вот я постарался.
Ну прямо скажем, ты хотя бы один ноль получишь раз в 16 блоков.
Ну раз после 16 попыток.
Почему чем больше нулей, тем лучше?
Ну это единственный способ измерить твою чистотительную мощность.
Либо тебе повезло, но тебе не будет вести так бесконечно.
Если ты хочешь рассчитывать на какую-то зарплату предсказуемую,
ты в среднем будешь находить какое-то количество нулей.
Не разумно, чтобы все же перебирали?
Не разумно, но их можно рандомизировать.
Но действительно, тут блок одинаковый, коем-бейс транзакция одинаковая,
но они могут выбирать просто случайные схиты для того,
от которых они отчитывают нонсы.
Зачем дериться своим выигрышем, не очень понимаю.
Ладно, загадка.
В таком случае можно просто обманывать того, кто делает пул.
Кто-то один считает, и они распределяют это.
Это усредняет их зарплату.
Ты уже не рассчитываешь на везение, что ты выигрыш 7,9,
а ты всегда получаешь 4, как и блок.
И это может быть выгоднее, если ты слабый, например.
Я не думаю, что выигрыш за один нонс выплачивается многократно,
зарплата за один нонс найденной.
Это было бы странно.
Ну смотри, это просто способ оценить хэш-рейт участника.
Тут не речь о том, насколько ты был близок к тому, чтобы найти блок.
Это способ оценить распределение ресурсов внутри пула.
Наверное, но мне кажется, это не очень полезный вопрос.
Давай, движемся дальше.
К чему я клоню?
К тому, почему вообще есть биткоин?
Почему его придумали?
Почему есть PBFT, а есть биткоин?
Потому что биткоин на бумаге, на стадии задумки,
должен быть гораздо более децентрализован
чем PBFT на несколько десяток реплик.
Мы вполне себе можем решать византийский консенсус.
Мы в прошлый раз это сделали.
Взять PBFT, который строил сервис упорядочивающей транзакции.
И в качестве транзакции взять вот эти самые транзакции,
которые печатают монетой, которые переводят эти монеты другим участникам.
И вот получить те же самые деньги.
Видимо, мы хотим использовать другой подход,
потому что он нам обещает, что мы сможем масштабироваться
и доверять не 50 репликам, а десяткам тысяч репликов,
или сотен тысяч узлов.
То есть по задумке децентрализация здесь неограничена.
И вот каждый участник, вы можете войти в систему и сделать ее надежнее.
Но вот мир таков, люди таковых, что они хотят максимизировать свою прибыль,
поэтому они начинают выдумывать специальное устройство,
а не майнить на процессорах, было бы идеально.
Они начинают строить фермы, переехать в страны, где электричество подешевле.
И в итоге децентрализация возникает.
Она возникает в форме пулов.
И вот, смотрите, распределение найденных блоков по пулам.
Вот увидите, что можно пулы перечислять по пальцам двух рук точно.
И вот это примерно количество участников,
от которых зависит надежность функционирования всей криптовалюты.
Если бы мы использовали PBFT, мы могли бы даже сделать более децентрализованно.
В смысле, мы могли бы вот еще больше набрать участников,
которые независимы друг от друга, чтобы они поддерживали реплики системы.
То есть по задумке, да, биткоин должен быть очень децентрализован.
На практике он очень децентрализован.
Просто потому что иначе участникам не выгодно майнить, не выгодно перебирать хаши.
С пулами есть еще одна интересная история.
Давайте про нее поговорим.
Сегодня, если вот мне очень нравится то, что биткоин определяет много энергии,
ну, возможно, да, ты решишь пул.
Опять же, так можно кому-то навредить, если у тебя довольно много ресурсов вычислительных.
Можно сделать по-другому.
Можно сказать, давайте мы будем майнить честно на процессорах.
И каждый будет майнить дома, и все будут получать выигрыши, и система будет децентрализована.
Ну, просто это возможно только в мире, там, где единорогие радуги.
В нашем мире невозможно.
Просто потому что участники, они нечестные, они рациональные.
Но когда дело касается денег, они становятся рациональными, а нечестными.
На этом вся экономическая теория построена.
И вот сейчас давайте мы поговорим про эти оценки, потому что на самом деле они не очень точны.
То есть можно придумать правила поведения, которые будут, ну так, честным,
но которые позволят максимизировать, увеличить долю выигрыш, которую мы получаем.
Вот пусть мы пул, пусть у нас довольно много процессоров.
Называется selfish mining, альтернативная стратегия майнинга.
Эгоистичный майнинг.
Пусть мы пул, достаточно большой пул, у нас доля альфа всех процессоров.
У нас все-таки не половина, чтобы мы могли творить что угодно.
Но достаточно много, чтобы мы регулярно находили блоки.
Если у нас доля альфа, то мы будем находить каждые единицы на альфа-блок в среднем.
Ну и получать долю альфа всего выигрыша, который системе порождается.
Можем ли мы повысить долю выигрыша, не повышая долю, не повышая свой hash rate?
Вот оказывается, что можем.
Давайте подумаем, как этого можно было добиться.
Как можно повысить эффективные альфы?
Нет, подожди, транзакции нам не важны, нам важны блоки.
Мы предполагаем, мы про комиссии не думаем.
Мы говорим про блоки, про награду за найденный блок.
Вот как можно получить больше выигрыша за найденные блоки, при этом больше, чем альфа,
обладая долей альфы вычислительных ресурсов?
Нет, ну подожди, hash получается непредсказуемым для нас.
Мы не можем каким-то образом влиять на proof of work, то есть на майнинг.
Hash довольно случайный.
Если мы будем честно его перебирать, а мы не можем перебирать более честно или менее честно.
У нас нет лучшей стратегии, чем просто пробовать разные.
На этом мы влиять не можем.
Но мы меньше одной-второй.
Мы, конечно, можем их отклонять, но а что толк?
Смотрите, мы можем находить, то есть мы майним долю альфы всех блоков.
Это неизбежно. Мы не можем больше.
Мы не можем математику обманывать, криптографию обманывать.
Но при этом мы хотим получать выигрыш больше.
Сложность мы не можем регулировать.
Нет, мы можем сложность убирать неправильно, но тогда она будет отклоняться другими узлами, честными их большинство.
Мы можем, тогда мы.
Не понимаете, да, идея? Ну ладно, тогда придется рассказать.
Блокчейн, он же дерево на самом деле.
И он иногда ветвится.
И в случае форка только одна ветка побеждает.
А другая ветка, она вот отросла немножко, а потом она забывается.
И блок найден, ресурсы на него потрачены, а комиссия за него не получена.
Ну просто потому что она не входит в блокчейн.
Транзакция, coinbase-транзакция, которая находится в этом блоке, она выводилась в блокчейна.
Поэтому если мы такой эгоистичный пул, который хочет повысить долю выигрыша,
то он не может находить больше блоков сам.
Но он может стараться делать так, чтобы чужие блоки постоянно вываливались из блокчейна.
И чем больше мы скинем из блокчейна чужих блоков, тем больше доля будет нашего выигрыша.
Количество блоков будет такое же найденных, а доля выигрыша будет больше, чем альфа.
Итак, давайте я изображу стратегию, которая позволит этого добиться.
Итак, у нас есть блокчейн.
Мы обозначим такое состояние за ноль.
Вот был какой-то блокчейн, он заканчивался каким-то блоком.
Что происходит дальше?
Мы будем сейчас рисовать граф переходов между состояниями.
Они будут с какими-то вероятностями, и потом мы посчитаем распределение по ним.
Ну, в общем, ясно будет.
Значит, это блок, нулевое состояние, вот нейтральное.
Что может тут случиться?
Ну, мы злоумышленники будем красными.
Ну, не злоумышленники, мы эгоистичные майнеры будем красными.
И есть честные майнеры.
Вот с вероятностью альфа, мы эгоистичные майнеры, наш пул найдет продолжение первым.
С вероятностью 1 минус альфа мы попадем сюда, сделаем петлю.
1 минус альфа.
А вот с вероятностью альфа мы получим блокчейн, который выглядит вот так вот.
То есть мы первыми нашли продолжение.
Но я рисую его пунктиром, потому что мы, эгоистичные майнеры, этот блок скрываем.
Мы не публикуем его.
Честный майнер, найдя блок, распространяет его по сети.
Он добавляется в историю и все продолжают майнить относительно него.
Вот это состояние 1.
У нас есть такой предварительный выигрыш.
Он еще не зафиксирован.
Вообще-то мы здесь рискуем, когда мы не публикуем блок.
Потому что раньше мы могли опубликовать его.
Если бы мы были честными, мы бы опубликовали его и получили свои монеты.
Сейчас мы его скрываем.
И если вдруг, пока мы его скрываем, у честных майнеров появится свой блок,
то они его сразу опубликуют, и тогда, возможно, мы проиграем.
Ну, по крайней мере, гонка начнется.
Мы можем выложить свой блок, мы эгоистичные майнеры, они будут соревноваться,
возможно, мы проиграем.
Но мы надеемся не на это.
То есть мы здесь подвергаемся риску дополнительному.
Мы откладываем свой возможный выигрыш, мы рискуем им,
потому что мы надеемся, что если у нас альфа все же не слишком маленькая,
то, возможно, мы продолжим майнить уже эту ветку, про которую другие не знают.
И перейдем в состояние 2.
Где наша преимущество достигнет 2 блоков.
Ну и может быть 3, и так далее.
Понятно, что наше преимущество может достигать бесконечности
с какой-то смехотворной вероятностью.
То есть номер состояния – это количество блоков,
которые у нас в нашей секретной цепочке накопилось.
Как мы собираемся этим преимуществом распоряжаться?
Я напомню, что наша цель – максимизировать свой выигрыш.
Для этого мы должны стараться выбрасывать чужие блоки честных узлов из блокчейна.
Ну вот, например, смотрим на состояние 3.
В этом состоянии какой-то узел честный мог найти блок,
который продолжает эту цепочку, потому что про эту цепочку он ничего не знает.
Она скрыта эгоистичными майнерами.
И тогда мы откатимся в состояние 2, но только это состояние будет выглядеть уже иначе.
Что нам делать на месте эгоистичных майнеров?
В этом состоянии будет выглядеть уже иначе.
Что нам делать на месте эгоистичных майнеров?
Ну, смотрите, если мы дошли до состояния 2, то мы точно знаем,
ну, 2 или больше, то мы точно знаем, что мы свой выигрыш зафиксируем.
Потому что если мы докатились до такого состояния,
если мы из 2 переходим в 1, то мы уже на самом деле не переходим из 2 в 1.
Если мы дошли до 2, и вдруг честный пул...
То есть пока мы в таком состоянии, вот в таком или в таком,
нам выгодно свои блоки прятать, держать в секрете,
потому что мы надеемся, что мы будем ждать, пока честный пул потратит свои ресурсы
на то, чтобы найти продолжение вот этой ветки.
И когда он вплотную к нам приблизится, когда разница станет в 1 блок,
то мы после этого опубликуем всю нашу цепочку.
То есть если в состоянии 2 честный пул находит блок,
то мы переходим в состояние 0 штрих, где...
Сейчас, нет, я вру по-моему.
Давайте аккуратно.
Да, и состояние 2 нужно переходить только в 0,
потому что мы просто фиксируем выигрыш.
Но проблема в состоянии 1, когда мы еще преимущества не достигли.
То есть если мы накопили преимущества в 2 блока,
то когда этот честный пул найдет продолжение 2,
тогда, когда наши цепочки почти сравняются, мы опубликуем свою приватную ветку,
и она победит, и вот эти 2 блока откатываются.
То есть мы стремимся сначала попасть в такое состояние, где у нас преимущество большое,
пытаемся его максимизировать, и таким образом мы максимизируем в конечном итоге
количество блоков, которые мы отбросим с блокчейна у честного пула.
То есть если мы попали сюда, то мы уже ничем не рискуем.
Но мы рискуем здесь.
Когда у нас уже есть выигрыш, который мы не фиксируем.
Вот если мы пришли в состояние 1, то есть мы опередили честный пул,
а потом получилось так, что следующим ходом,
следующим событием стал майнинг честным пулом очередного блока,
то мы переходим вот в такое состояние.
То есть тут уже ни у кого нет преимущества, это состояние 0',
и тут возникает гонка.
И какими сходами она может разрешиться?
Что?
Ну, смотри, еще раз принцип сам.
Если ты оторвался с приватной веткой,
если ты пул из эгоистичных майнеров вырвался вперед на два блока,
скрывая свою ветку, то ты знаешь, что ты уже точно получишь выигрыш за каждый свой блок.
Потому что когда преимущество твое достигнет единицы,
то ты опубликуешь свою приватную ветку
и тем самым отбросишь ветку, которую нашли честные майнеры.
То есть если ты попал сюда, то все, ты свой выигрыш получишь.
Но чтобы добраться сюда, ты должен пройти через это состояние.
Оно довольно хрупкое. Раньше ты просто находил блок и публиковал его
и получал свою долю альфы в выигрыше.
А сейчас ты его откладываешь в надежде получить больше.
Но если из состояния 1 следующим событием будет не твой красный блок в твоем пуле,
а блок честного майнера, то ты в этом месте можешь проиграть.
То есть переход по 1 минус альфа пройдет сюда.
Тут 1 минус альфа, мы видим, откатываемся вот сюда.
Потому что мы публикуем свою ветку.
Так вот, из состояния 0 штрих, куда мы можем попасть?
Ну, только в ноль, но разными способами.
Вопрос в том, кто найдет следующий блок.
Либо он найдет красный, с вероятностью альфа,
либо его найдет, кто? Честный пул.
Но честный пул может найти его двумя способами.
Он может прицепить честный блок своему блоку,
а может быть честные участники выберут красный блок,
потому что эти два блока соревновались между собой в сети.
И у вас будет нулевой выигрыш.
Это 1 минус альфа.
Но мы ведем еще один параметр гамма, который про то, кто побеждает в случае гонки.
Если мы скажем, что гамма 1 вторая, то это значит, что в случае конкуренции
честного и эгоистичного пула, эгоистичный пул выигрывает с вероятностью гамма.
Так вот, с вероятностью 1 минус альфа умножить на гамма,
честная цепочка продолжится вот здесь вот.
Честные узлы найдут следующий блок, но продолжат эту цепочку.
И с вероятностью 1 минус альфа на 1 минус гамма,
честные узлы продолжат свою цепочку.
Гамма это параметр, это вероятность того, что в случае, когда в сети появляются два блока,
то есть вот у нас было такое состояние, эгоистичные узлы нашли блок, держат его в секрете,
надеясь максимизировать свой отрыв.
Но у них не получилось этого добиться, потому что честный майнер нашел блок.
И он сразу его публиковал, потому что он честный.
Тогда мы, чтобы не потерять найденный блок, публикуем его, и они между собой гоняются.
То есть они раздаются госипом по сети, и каждый узел начинает майнить ту цепочку,
которую он получил первый.
Так вот, гамма это вероятность того, что в будущем при гонке этих блоков
следующий блок найденный будет цепляться за нашу красную цепочку, а не за черную.
Что? Да.
Вот такова стратегия, и что про нее можно доказать?
Давайте мы посмотрим на...
Что?
Да.
С самого начала. Если мы сразу публикуем найденный блок, то мы выигрываем долю альфы.
Вот эта стратегия утверждается способна долю выигрыша повысить.
Потому что в случае, если мы достигли преимущества в два блока и скрываем это,
то мы дождемся пока честные узлы найдут продолжение этой цепочки, вот такой вот.
Опубликуем свою приватную цепочку, и она откатит тот блок, который нашли честные узлы.
То есть они потратили ресурсы, но потратили их напрасно. Они не получили за это выигрыш.
Почему это выгодно?
Ну, еще раз, потому что выигрыш зависит...
Почему это выгодно? Ну, потому что выигрыш ты получаешь за блоки в блокчейне, в максимальной цепочке в дереве.
И вот в этой цепочке максимально твоих блоков становится больше, потому что чужих блоков становится меньше.
Все, отлично.
Зачем мы рассматриваем ситуацию, где только один блок?
Почему только один? Мы не честные?
Ну, смотри, ответ, наверное, такой, потому что сложная.
Еще мне кажется, что вероятности закинуться в 0,4 сильно больше, чем 1,4, потому что они уже манили, они уже искали этот блок.
Нет.
Сейчас.
То есть они уже давно подбирают хеш.
Мне кажется, что так рассуждать не стоит. Если ты подбросил монетку какое-то количество раз, то, видимо, участвующие бросания на следующие не влияют.
Нет?
То есть у нас много монеток?
Ну вот, кажется, я не наврал в диаграмме, да?
Похоже.
Вот, и там начинается все это решать, строить систему, решают ее.
И приходит к такому выводу. Ну вот, графики в зависимости от гаммы и вот здесь вот альфа.
Графики разные для разных гамм.
И на этой оси доля выигрыша, которую мы можем заработать.
Тут не очень здорово видно, наверное. Надеюсь, достаточно видно.
Но вот почему вообще разные гаммы можно рассматривать?
Казалось бы, если у нас соревнования, то выиграет либо один, либо другой.
Но, то есть можно брать одну вторую смело.
Но с другой стороны, можно сказать так, что если у нас узлы эгоистичные,
и в случае им этот сценарий неприятен, когда появляется гонка между двумя блоками.
Но вот их же довольно много, их доля целых альфа.
Так вот, они получая блоки от честных узлов, могут их придерживать.
Ну, то есть чуть замедлять их распространение в сети.
Поэтому, в принципе, гамма может склоняться в нашу пользу.
Но если мы берем гамма одна вторая, то мы получаем, что...
Ну вот здесь график в зависимости гаммы, альфы от...
Мы берем разные гаммы и смотрим, при каком альфа вот эта стратегия начнет давать выигрыш относительно честного майнинга.
И вот если мы берем гамма одна вторая, консервативная, то мы получаем, что
пул размером 1 четверть уже может зарабатывать больше, если он ведет себя эгоистично, а не честно.
Это странный вопрос.
Насколько больше? Ну вот если у тебя график, то вот он.
Ну, это, в смысле, точка перехода такой.
Ну вот, смотри, зеленый график это гамма одна вторая.
И вот у тебя зависимость размера пула, то есть доля вычислительных ресурсов в пуле.
И зависимость доли выигрыша от доли ресурсов в пуле.
Ну вот, если ты, если ты эгоистичный пул, и ты почти половина, то ты забираешь себе весь выигрыш.
Так что если есть эгоистичный пул, то очень разумно к нему присоединяться,
потому что он выигрывает больше, чем его положено.
Этот пул будет расти.
Так вот, верно ли, что вот эта стратегия угрожает биткоину?
Нет один же соображение, что и раньше.
Потому что когда разыжка большой, то все боятся храна своих денег.
Ну и то есть не только он выигрывает себя нечестно.
Ну вообще-то он не то чтобы нечестно себя ведет.
Он ведет себя всего лишь...
Это не византийское поведение, это эгоистичное поведение.
Он максимизирует свою прибыль.
Но, конечно, это бросает некоторую тень на валюту.
Но, смотри, если у тебя есть дабл спендинг,
то ты можешь довольно легко это обнаружить.
А здесь никакого дабл спенда нет.
Ну это такое, ты разведчика посылаешь на виду шпиона.
Я про другое.
Как можно, просто наблюдая за блокчейном, следить, что в нем завелся эгоистичный пул.
Если эту атаку можно проводить секретно, никому не раскрывая свои деятельности,
то, наверное, мы можем пострадать от этого.
У нас просто возрастает число откатов, то есть число этих орфанов, переводится,
число вот таких вот сиротских блоков, которые свершиваются с блокчейна.
Вот если их доля возросла, значит в сети завелся эгоистичный пул.
То есть это атаку трудно провести секретно.
Она задевает наблюдаемый блокчейн.
Ну просто смотреть на гостеп, это более сложно и более децентрализовано,
чем просто посмотреть на блокчейн, как он себя ведет на структуру его.
Если там появляются вот эти висящие сироты, то их стало больше сильно,
то, видимо, кто-то не раскрывает свои блоки, кто-то действует эгоистично.
Что?
Мы отказаться не можем принимать его блоки, мы можем отказаться Bitcoin применять,
принимать, если он магазин.
То есть тут вопрос в том, насколько мы доверяем такой валюте,
где участники нарушают протокол.
Ну кажется, что был какой-то блокчейн, в котором люди так делали,
но это обнаружилось, потому что такой способ есть.
В Биткоине такого никто не делал.
То есть это скорее теоретическая угроза, которая не реализуется.
Но опять же, примерно те же самые соображения, что что делать,
если у кого-то завелось половина вычислительных ресурсов.
Вот мы видели картинку с пулами, и так уже пулов больших много,
поэтому они уже могли бы, как-то координированно, делать что-то плохое.
Но они так не делают, потому что это невыгодно.
Невыгодно так делать.
Алгоритм сам этого не защищает.
Окей.
Идем дальше.
Давайте еще раз скажу забавную, не историю,
забавную деталь, про которую времени нет, потому что это криптография.
Но Биткоин тоже об этом не заботился,
а вообще говоря, нас, как пользователи, это могло бы волновать.
Мы говорили про анонимность, про то, что мы тоже оставляем личности участников
и открытые ключи.
Но в то же время, если мы так делаем,
то наблюдатели могут связывать наши транзакции.
Совет универсальный, заводите себе больше кошельков,
в смысле больше открытых ключей, больше вот этих виртуальных личностей,
но в какой-то момент вы все равно будете собирать деньги,
и все это будет связываться.
Так вот, можно делать прачечные,
где вот устраиваются такие блоки обмена деньгами,
где все перемешивается, и вот на выходе,
непонятно, как входы связаны с выходами.
Но это такая прачечная, которая построена на доверии.
То есть ты строишь сервис и говоришь, что я принимаю транзакции,
принимаю Биткоина, потом я их могу отдавать наружу,
и вот смешаю все входы и выходы.
А на самом деле криптография умеет строить криптографические прачечные
очень красивым образом.
Можно это называть, ну вы, наверное, знаете,
доказательства с нулевым разглашением.
Знаете про это?
Как доказать, что вы умеете считать количество листьев на деревьях?
Не умеете доказывать это?
Как же вы живете?
Ну, представьте, что у вас есть суперсила,
вы умеете считать число листьев на деревьях.
Но это довольно сложно доказать, потому что вы...
Нет, можно поступить, конечно, на как сказать число,
а потом человек возьмет и пересчитает листья,
это займет у него некоторое время.
Так вот, можно доказать, что вы так умеете делать,
а число не раскрывать?
Что?
Смотрите, вы делаете так, вы отворачиваетесь,
а проверяющий отрывает листик от дерева или не отрывает,
и говорит, сколько сейчас стало больше или столько же?
И вот такой тест, в котором вы, если вы не умеете,
это все одно второе, а если вы умеете, то вы и не ошибаетесь.
Так вот, есть такая область математики,
которая этим занимается, такие доказательства исследует.
Можно делать их неинтерактивными,
которые не требуют коммуникации того, кто доказывает,
того, кто проверяет доказательства.
То есть, вы можете опубликовать, вы можете проверить,
при этом не раскрыв содержимое.
Так вот, в биткоине...
Это называется ZeroCoin, ZeroCash, наверное, сейчас не помню.
Короче, идея такая, что вы можете делать специальные транзакции,
можно расширить так протокол всей этой системы,
что есть, добавив к нему транзакции,
в которых вы отправляете деньги не Бобу,
а кладете их в ящичек.
И у вас в блокчейне появляются такие вот ящики с планетами.
То есть, транзакция имеет выходом эти ящики.
А потом вы можете опубликовать транзакцию,
где вы доказываете, что вы берете одну из монет из этих ящиков.
А из какого вы не говорите?
То есть, можно убедиться, можно доказать проверяющему,
что действительно монета взята из одного из этих ящиков,
и что вы не брали из одного ящика дважды.
Но при этом не рассчитывается какого.
Это суперкрасиво.
Но это не имеет отношения к распределенности,
поэтому мы про это не говорим.
Но если вам интересно, то вы почитаете про это.
Про распределенность.
Опять, прямого отношения это не имеет,
но мне кажется, что это важно.
Вот смотрите.
Вернемся вот к этому рисунку.
У нас есть транзакция Алисы, транзакция Боба,
и они склеиваются вот здесь.
И для того, чтобы провалидировать, что эта склейка имеет место,
нужно с одной стороны проверить подпись,
с другой стороны проверить, что Боб не тратит выход повторно.
Так вот, на самом деле вот эта процедура валидации,
она не зашлита жестко в протокол блокчейна.
Не то чтобы узел сети, который получает блок,
смотрит на транзакцию, считает там фиксировано,
проверяет свою подпись и говорит да нет.
На самом деле вот здесь происходит нечто более гибкое.
Потому что процедура валидации может быть составлена самой Алисой.
Потому что процедура валидации это на самом деле некоторая программа.
Вот когда вы пишете транзакцию в биткоине,
то вы пишете не то чтобы голыми руками,
но вы на самом деле пишете программу.
Давайте мы опустим проект.
Когда у вас есть транзакция с входом и выходом,
на самом деле это два скрипта.
Скрипта для некоторой виртуальной стековой машины.
Вот знаете ли вы, что такое стековая виртуальная машина?
Как работает Python, например?
Есть регистровая машина, есть стековая машина.
То есть вы эмулируете компьютер, но только он устроен попроще.
Например, как вы вычисляете риффетическое выражение в польской аннотации?
Знаете, когда вы строите дерево разбора,
обходите его пластиковым обходом, получаете польскую аннотацию,
и у вас написано 1, 2+.
Вот считается оно так, вы единицу кладете на стек,
вы кладете на стек, когда видите плюс,
то вы снимаете со стека два верхних элемента,
складываете их, кладете обратный результат.
Это немного другой способ построить байт-кор для виртуальной машины.
Он с одной стороны компактнее, с другой стороны немного более...
Ну короче, есть свои плюсы и минусы по сравнению с регистровыми машинами.
Так вот, биткоин на самом деле стековая виртуальная машина,
и каждый узел, когда он выполняет валидацию блоков,
валидацию транзакций, он делает следующее.
Он берет скрипт, то есть программу вот на этом,
программу из инструкции байт-кода,
вот можно их здесь перечислить,
берет программу транзакции, которая цепляется,
то есть программа, которая получает монеты,
берет программу, которая отправляет монеты,
конкатинирует их, то есть вот это output, это input.
И выполняет эту программу.
И если программа завершается успешно, то это значит, что транзакция валидируется.
Она корректна.
Вот если мы говорим просто про перевод денег, то он устроен так.
Вот когда мы отправляем деньги кому-то, то мы отправляем их по адресу.
Адрес – это хэш открытого ключа.
И вот в транзакции в input, в output транзакции Алисы
был написан хэш открытого ключа Боба.
И Боб, чтобы потратить эти монеты,
получить эти монеты, он должен предоставить свой открытый ключ.
И при проверке нужно сделать две вещи.
Во-первых, его похэшировать, проверить, что хэш совпадает с этим.
А во-вторых, что действительно это Боб,
и он обладает секретным ключом данного открытого ключа.
Вот для этого берется такая программа.
Алисы пишет проверку, Боб пишет входные данные для этой проверки.
Мы это конкатинируем и запускаем программу на этом stack-овом компьютере.
Первая инструкция – мы кладем подпись на stack.
Вторая инструкция – из input транзакции Боба
мы кладем публичный ключ на stack.
После этого первая инструкция в output транзакции Алисы – это дубликация.
То есть мы дублируем вершину stack.
После этого следующая инструкция – мы считаем хэш.
Снимаем аргумент с вершины stack и кладем результат на вершину stack.
После этого следующая инструкция, так условно здесь написано,
мы должны проверить верно лишь, что на вершине stack лежит такое же значение, что и у нас.
Проверяем, совпало, хорошо, снимаем с вершины stack этот хэш.
На stack-е остается только открытый ключ и подпись.
И дальше последняя инструкция проверяет, что действительно подпись соответствует открытому ключу.
Принцип понятен?
То есть правило валидации транзакции отправитель составляет сам.
Почему это может быть полезно?
Потому что транзакции бывают сложнее, чем просто перевести деньги от Алисы к Бобу.
Так вот безусловно.
Потому что в транзакциях можно составлять какие-то более сложные проверки.
Но что интересно, вот смотрите, вы начинаете, вот теперь можно сказать,
что вы реплицируете компьютер уже, виртуальную машину.
То есть каждый узел в сети блокчейна, он на самом деле получает блоки,
склеивает транзакции и исполняет программы.
Тут можно поэтому по-разному на блокчейн смотреть.
Можно смотреть на него как на совокупность транзакций, которые двигают деньги.
Можно думать про вот сам блокчейн биткоина, как про, ну почти что гид,
потому что мы ссылаемся с хэшами.
Можно думать про вот такой компьютер.
Но вот смотрите, если вы начинаете распределенно выполнять на вот этих компьютерах какие-то программы,
то у вас могут подстригать неприятности.
Ну, во-первых, программы, конечно, должны быть детерминированными.
А во-вторых, в них желательно не писать бесконечных циклов.
То есть хорошо, чтобы эти программы останавливались,
потому что если блок будет корректным, а при валидации мы напишем бесконечный цикл,
то дело закончится плохо.
Поэтому в блокчейне, в биткоине этот язык, скрипт не содержит циклов.
Он не терян полный, вы не можете писать все, что угодно.
То есть любая программа, она гарантированно завершается.
Это приятное свойство.
Но вот есть Ethereum, альтернативный блокчейн, и вот там уже вы можете писать произвольные программы.
Нет, ну если делать не думая, то, конечно, опасно.
В смысле, если делать блокчейн не думая.
Конечно же, если ты делаешь Ethereum, ты подумаешь о том, что там ты можешь...
Блокчейн – это гораздо более сложная штука,
и в нем фактически репозитория для программ.
Ты можешь методы вызывать.
То есть такие условные акторы, контракты, ты можешь дергать их методы.
И, конечно же, там ты можешь писать уже более сложную логику.
Там у тебя есть выразительный язык.
Там ты пишешь уже какие-то программы с какими-то циклами.
То есть это вполне себе полный язык.
Он, конечно, переводится в некоторый байт-код.
То есть ты front-end можешь поменять.
Да, и виртуальная машина Ethereum называется EVM.
Догадываетесь, что довольно забавно само по себе.
Так вот, почему же Ethereum?
Ну, потому, что у тебя есть виртуальная машина.
И это Ethereum называется EVM.
Догадываетесь, что довольно забавно само по себе.
Так вот, почему же Ethereum не боится, что вы напишете там бесконечный цикл?
Чтобы вы можете.
И вы этот бесконечный цикл реплицируете на тысячи машин.
И исполните его там.
Ну, примерно.
Вот, действительно, ты можешь написать функцию, вызов которой не завершается.
Но, с другой стороны, у проверяющего нет мотивации.
Исполнить такой код бесконечно долго.
Когда ты публикуешь транзакцию,
то в биткоине есть комиссия, чтобы эта транзакция попала в блок.
А здесь комиссия устроена немного иначе.
Ты говори, ну, точнее, не так.
В виртуальной машине каждая инструкция в твоей программе,
ну, не в этом языке, а в тот, в который эта программа скомпилируется,
каждая инструкция имеет цену.
Она называется топливо.
Сколько это единиц топлива?
Кто-то уже пытался майнить на этом языке?
Ethereum это второй после биткоина блокчейн.
Ну, ты рассылаешь все программы, они все начинают майнить.
Подожди, майнить, майнинг это про другое.
Вот yellow paper показывает спецификация.
То есть тут все описано, и вот тут есть стоимость инструкции.
Так вот, когда вы публикуете транзакцию,
то есть какую-то программу, которая будет исполняется на разных репликах,
вы говорите, что я готов, вы назначаете цену за единицу топлива.
И вот вы покупаете топливо для своей программы за какие-то деньги.
Вы покупаете у майнера, который найдет ноанс для блоков,
в которых придет транзакция топлива по этой цене.
И когда кто-то получает блок с этой транзакцией,
он запускает вашу программу, и она исполняется до тех пор,
пока у отправителя этой транзакции есть на балансе эфир,
чтобы покупать топливо для исполнения этой программы.
То есть программа может быть бесконечной, но рано или поздно
деньги кончатся, за исполнение будет платить нечем, и исполнение завершится.
Понятная идея?
То есть это такой аналог комиссии, то есть выигрыш,
то есть деньги, которые потрачены на исполнение программы,
они уходят майнеру, который нашел блок с этой транзакцией.
Так что мы здесь себя ничем не ограничиваем, мы не ограничиваем
instruction set, но мы вот с помощью такого довольно странного механизма
ограничиваем время исполнения программы.
Да, ну их же много.
Ты надеешься, что ты получаешь транзакцию от пользователя,
ты добавляешь ее в блок, потому что ты надеешься, что именно ты
в блок добавляешь блокчейн, тогда ты получишь плату
топлива для исполнения этой программы.
Ну а все остальные это просто реплики, они должны повторять все это.
Так вот, какая же польза от того, что мы
реплицируем именно компьютер, от того, что мы можем писать
более сложные программы, в эфире они называются smart contracts.
Ну давайте я покажу пример задачи, где
нужно делать уже более сложные правила валидации.
И все это в контексте биткоина.
Итак, мы посмотрим на задачу, которая с распределенностью уже связана напрямую,
и в которой используется возможность писать более сложные правила валидации.
Прежде чем мы к этому перейдем,
маленький вопрос по мотивам того, что было ранее.
Как сделать random в таком языке?
Вот транзакция, когда она отправляется, она не знает, в какой блок она попадет,
потому что это очень невозможно предсказать, потому что это зависит от nonce,
от других транзакций, которые в этот блок тоже войдут.
Так вот, в качестве источника случайности для программы внутри блока можно использовать
как раз хэш этого самого блока.
Потому что все должно быть детерминировано, потому что исполняется на разных компьютерах.
Итак, задача следующая.
У нас есть Алиса и Боб.
У Алисы, у Боба есть биткоины.
В количестве B штук.
У Алисы есть некоторые альткоины из альтернативного блокчейна.
И Алиса с Бобом хотят обменяться деньгами.
Алиса хочет получить биткоины, Боб хочет получить альткоины.
Задача называется atomic swap.
Итак, вот есть Алиса, у нее альткоинов, у него есть Боб, у него B биткоинов.
Алиса живет на одном блокчейне, Боб живет на другом блокчейне.
Давайте думать, как обменяться деньгами.
Это некоторые альтернативные блокчейны.
Само собой.
Алиса готова получить биткоины, у нее уже есть открытый ключ.
Боб тоже готов получить альткоины, они об этом позаботились заранее.
В чем проблема? В том, что Алиса и Боб могут обманывать друг друга.
Они могут, во-первых, просто отказать, потому что у нас распределенная система.
Они могут потерять кошелек, пароль кошелька, ну либо кто-то может вести себя нечестно.
Поэтому мы хотим придумать такой протокол, который был бы устойчив, разумеется, к отказам,
к исчезновению одной из сторон.
И он был бы устойчив к византийскому поведению одной из сторон.
То есть если кто-то нарушает протокол, то он не может получить больше денег,
чем при честном поведении.
Вот есть Алиса, и она выпускает транзакцию,
которая переводит Бобу в альткоине свои а монет.
Что вы скажете про такое начало?
Да, это правда, Бобу можно уходить.
Бобу можно забирать деньги и покидать эту сделку, больше ему ничего не нужно.
Видимо, это решение плохое. Нужно сделать так, чтобы Боб, пока он не опубликует свою транзакцию,
потратить транзакцию Алисы не смог.
Для этого нужно здесь, в выходе этой транзакции Т1, написать какие-то более сложные правила валидации.
Мы сделаем так. Пусть Алиса сгенирирует себе секрет.
Просто с помощью генератора случайных чисел получит некоторый секрет.
Бобу она не говорит секрет.
И в своей транзакции, которую она кладет на блокчейн альткоина, она проверяет следующее.
Она говорит, что эту транзакцию можно потратить только если вы Боб и плюс вы знаете секрет.
Каким образом можно проверить, что Боб знает секрет?
Каким образом можно написать такое правило?
Вы говорите, что во-первых, у транзакции должна быть подпись Боба,
а во-вторых, в транзакции должен фигулировать сам секрет, а вы здесь напишите хэш от секрета.
Это называется хэшлог.
То есть Боб должен приложить свою подпись, открытый ключ, как и раньше, плюс приложить секрет,
и эта программа возьмет этот секрет, хэширует его и сравнит с тем значением, которое было написано здесь.
Алиса может опубликовать такую транзакцию с хэшом от секрета,
а Боб, поскольку он не может обращать криптографические хэш-функции,
просто ждет от Алисы чего-то, пока он этот секрет раскроет.
Боб просто потратить деньги не может, но правда он все еще может просто уйти и заблокировать деньги Алисы, что неприятно.
Но, по крайней мере, забрать ее деньги он сейчас не сможет.
Что он делает, чтобы все-таки получить от Алисы рано или поздно секрет?
Он публикует свою транзакцию.
Которая как будет устроена?
Эта транзакция адресует Б Биткоина в Алисе, но только если у нее есть секрет.
Только если она его опубликует.
Это один и тот же хэш от одного и того же секрета.
То есть Боб готов отдать свои биткоины, только если Алиса опубликует свои секреты,
если она его опубликует, то мы на месте Боба можем этим секретом воспользоваться,
чтобы забрать свои деньги и свои альткоины на том блокчейне.
Если Алиса захочет получить свои биткоины теперь,
но Боб не может получить эти деньги, эти альткоинов, потому что у него нет секрет.
Но у секрета есть у Алисы, поэтому она может выпустить транзакцию,
где здесь будет написано S.
Ну и дальше эти деньги потратить куда-нибудь.
Вот, Боб узнает про этот секрет, он же в блокчейне лежит в открытом доступе,
и этим секретом воспользуется, чтобы забрать свои деньги.
Никто другой не может, потому что еще цифровая подпись Боба проверяется.
Ну вот давайте подумаем, что может пойти не так в этом протоколе.
Нет, ну подделывать подпись мы к счастью не можем, ломать фотографию мы не можем.
Ну во-первых, Алиса, тут как бы симметричное действие,
Алиса может дождаться транзакции от Боба и ничего не сделать, не опубликовать секрет.
У Боба заблокируются деньги.
Или даже на предыдущем шаге Боб просто не опубликует свою транзакцию, это два,
и тогда у Алисы заблокируются деньги, и то и другое неприятно.
Поэтому должен быть какой-то запасной план, если другая сторона откажет,
но не будет делать то, что он должен.
Ну нам нужен тайм-аут.
То есть мы выплачиваем деньги Бобу, если у него есть секрет,
или же мы возвращаем деньги себе, но просто по некоторому тайм-ауту.
Видимо, Боба беспокоит то же самое, что Алиса бросит выполнить протокол,
не опубликует свою транзакцию с секретом, поэтому здесь тоже должен быть тайм-аут,
который вернет деньги Бобу.
Как сделать тайм-аут, мы сейчас поговорим, но вот даже в такой схеме пока есть проблема.
Если, допустим, тайм-аут у нас есть.
Какой вопрос?
Я не понял, честно говоря.
Боб не опубликует никакой секрет, секрет есть только у Алисы,
она управляет всем этим протоколом.
Если она бросит этот протокол, не опубликует свой секрет,
не потратит деньги Боба, то Боб не сможет получить деньги от Алисы.
Давай обойдемся без секретов больше, секретов достаточно.
В чем уязвимость такой схемы?
Пока мы не говорим, как сделать тайм-ауты, но вот если мы их умеем делать,
то все равно Алиса может навредить Бобу.
Да, Алиса, которая приближается к тайм-ауту, вот этот вот,
Алиса в этот момент публикует свою транзакцию,
забирает деньги у Боба, публикует секрет,
но просто не дает Бобу этим воспользоваться,
потому что здесь протухает такой же тайм-аут,
и деньги возвращаются Алисе.
То есть она и свои забирает, и у Боба подрезала деньги.
Поэтому что нужно сделать?
Вот, нужно взять разные тайм-ауты, ну и не знаю, сказать, что это.
Мне кажется, не наоборот.
Если Алиса публикует транзакцию с секретом,
то она дает Бобу запас времени для того, чтобы этим секретом воспользоваться.
Если Алиса не публикует секрет, деньги вернутся Бобу.
Окей, протокол почти готов, но мы не поговорили, как сделать тайм-ауты.
Ну вообще говоря, в Биткоине нельзя сделать тайм-ауты в таком виде,
то есть написать, что эту транзакцию можно потратить не раньше, чем какое-то время.
Но в Биткоине есть тайм-локи.
То есть вы можете в транзакции добавить ограничения, что эта транзакция не может попасть в блокчейн,
если высота блока меньше, чем что-то.
Или если тайм-стэм блока меньше, чем что-то.
То есть тайм-аут в виде либо высоты блока, то есть позиции порядкового номера,
либо в смысле временной метки.
То есть тайм-аут, он на самом деле на транзакции, которые тратят деньги.
Они отправляют.
Ну и это правило, оно валидируется на узлах точно так же, как и все остальные транзакции.
То есть помимо выполнения скрипта, узел, который получил блок с такой транзакцией,
проверяет, что сравнивает тайм-лог транзакции и высоту или временную метку блока.
То есть чтобы Алиса получила свои деньги обратно, ей нужна еще одна транзакция,
у которой будет тайм-лог.
Но Боб же про нее ничего не знает.
Это же транзакция Алиса.
Как он будет уверен, что она не... какой тайм-аут она себе установила?
Понятен вопрос?
Нет.
Окей, честно признался.
Но вот тайм-аут он логически здесь.
То есть ты не можешь потратить этот выход раньше, чем что-то.
Но так вот получилось, что в биткоине тайм-лог, он на транзакции, которые вот здесь.
То есть эта транзакция не может попасть в блокчейн раньше, чем.
Но Боб про эту транзакцию ничего не знает, потому что она транзакция, которую Алиса выпускает.
Ну по крайней мере, в нашем протоколе он ничего не знает.
То есть мы... границу на... короче, тайм-аут настраивается вот на эти транзакции.
Поэтому Боб, если он соглашается на такую сделку, должен быть уверен, что Алиса не может выпустить транзакцию,
которая потратит выход раньше, чем через там... 24 часа.
Поэтому альтернативный способ потратить этот выход такой.
Транзакция отправляет аальткоинов либо Бобу, если он предоставит секрет, либо Алисе,
если транзакция Алисы подписана еще и Бобу.
И когда Алиса участвует в этом протоколе, она готовит эту транзакцию, готовит эту транзакцию
и отправляет эту транзакцию Бобу. И Боб тоже ее подписывает.
И Боб теперь уверен, что альткоин потратится либо по публикации секрета,
либо спустя 24 часа деньги вернутся Алисе. Но он, наверное, согласен на эти 24 часа Алисе.
И он знает, что Алиса не может никак жульничать, потому что любая транзакция,
которая тратит деньги альтернативным способом, а не переводит их Бобу,
должна содержать подпись Боба. Ну и симметрично все.
Ну что, сложилось? А теперь вопрос, что это похоже?
Я сегодня на лекции рассказывал, что все, что мы делаем в Биткои, не похоже.
Не похоже, но параллелится с PBFT. Гворумы в процессорах, в голосах, вращающийся лидер
через лотерею или через модуль, нижняя оценка, правила комита, снапшоты.
В общем, параллелей очень много. Называем случайные слова. Не совсем.
В смысле совсем нет, вообще не то. Это двухфазный комит.
Вот кто-то приходил на лекцию про двухфазный комит и знает про двухфазный комит.
Напомню, в чем там была суть. Мы делали двухфазные блокировки распределенной системе.
Распределенная система означала, что у нас есть большая-большая логическая таблица,
мы делим ее на кусочки, и за каждый кусочек отвечает свой шарт.
И когда мы делаем двухфазные блокировки, то мы должны взять локи на каждом шарде.
Но поскольку клиент может отказывать, мы открываем сессию, берем локи в рамках сессии,
если сессия протухает, то транзакция откатывается на шарде.
И в итоге каждый шарт мог независимо транзакцию либо применить, либо откатить ее.
И нам нужно было сделать автоматный комит, чтобы все шарды согласились, что транзакция применяется.
Для этого у нас был протокол, как назывался, двухфазный комит.
И там был координатор, он на первой фазе
отправлял на все шарды команду Prepare, говорил, пожалуйста, примите решение,
вы с транзакцией согласны или нет. Вот если вы ее хотите откатить, то скажите об этом.
А если готовы накатить ее, то, пожалуйста, не отменяйте больше своего решения.
И если мы получали одобрение от каждого шарда, мой координатор,
то после этого мы отправляли им команду commit.
А если получали хотя бы один отказ, то мы всем отправляли аборт.
Ну и нужно было делать аккуратно, а именно учитывать возможность отказа
или рестарта шардов и координатора. Вот когда мы говорили про спандер,
у нас шард не мог отказать, потому что он отказаустойчивый, это RSM.
Но он мог перезагрузиться, то есть поменять лидера, тогда у него сгорало состояние.
Поэтому на фазе Prepare мы что-то сохраняли надежно через RSM, через реплицированный лог.
Потом сам координатор мог отказать, поэтому мы делали координатором одного из шардов.
И когда он получал решение каждого шарда, он тоже его сохранил на диске, чтобы не забыть.
Здесь то же самое. Вот у нас есть два участника, у них есть координатор.
Это Алиса. Что такое Prepare?
У нас есть два шарда, очевидно, два блокчейна.
Что такое Prepare? Это фиксация своих намерений. Я согласен перевести деньги.
Это публикация блокчейн транзакций вот такой вот.
Если она не опубликована, то истекает тайм-аут, транзакция отменяется по тайм-ауту.
Но если два участника опубликовали свои транзакции, то есть до этого дошло,
то протокол вошел в такую стадию, где все, транзакция может совершиться.
И просто на все воля координатора Алисы.
Если она принимает решение закомититься, то есть опубликует транзакцию секретом, то все, протокол докатывается.
Если она вдруг решает откатить транзакцию, то она не публикует секрет, и транзакция по тайм-ауту откатывается.
Ну, это почти то же самое. В некоторых местах все-таки немного по-другому.
Но суть абсолютно такая же.
У нас есть некоторая предварительная работа. Мы посылаем транзакции, подписываем.
Может быть, там уже не сошлось что-то.
Но если сошлось, и мы опубликовали две транзакции в двух блокчейнах,
то после этого мы можем сделать вот этот комит, опубликовать такую транзакцию.
Конечно же, никто в мире блокчейнов не называет это двухфазным комитом,
потому что они про эту теорию ничего не знают и игнорируют ее.
Но смысл опять такой же.
И этот протокол можно обобщить, на самом деле, не на двух участников, а на большие цепочки.
И доказать строго, что выход из протокола в любом месте не может повышать,
не может никому навредить и не может принести вам больше выигрыш.
Ну вот, двухфазный комит.
А теперь очень забавный нюанс.
По поводу технического воплощения этого протокола.
Смотрите, мы требуем от разных блокчейнов, чтобы они умели две вещи.
Чтобы они умели хэшлоки и таймлоки.
Вот кажется, что и то и другое настолько разумно и естественно,
что было бы странно строить блокчейн, которого бы этого не умел.
То есть это такое ограничение, можно было бы ожидать, что любой блокчейн такие механизмы имеет.
Но просто хотя бы для интероперабельности между разными блокчейнами.
То есть любой блокчейн не фиксирует семантику транзакций, не фиксирует правила валидации,
он позволяет вам писать какие-то свои программы и дает вам такие базовые примитивы.
Ну этот тайм-аут вам нужен для отказа устойчивости, понятно.
Хэшлоки вам нужны просто потому, что это такой очевидный криптографический инструмент хэш-функции.
Но у нас здесь есть еще одно забавное ограничение, которое может быть неочевидным, без которого все ломается.
Вот представьте себе, что у вас хэш-функции в блокчейнах разные.
Что это поломает? В принципе же что, у Алисы есть секрет.
Она публикует вот такую транзакцию, а Боб не может публиковать такую же транзакцию, потому что хэш-функция у него другая.
Но в конце концов, он же секрет это и не знал.
Может ли ему Алиса просто отправить хэш 2 с?
Нет.
Почему не может?
Мы не можем подтвердить, что это реальный хэш.
Ну вот да, Боб все держится здесь на таком предположении, что если секрет будет публикован в этом блокчейне,
то поскольку хэш-функция одна и та же, хэш один и тот же, то и Боб сможет применить, написать такую же транзакцию, чтобы тратить этот выход.
Если хэш-функции будут разными, то как Алису убедить Боба?
То есть она таким способом уже не может убедить Боба, что публикация секрета для этого хэша даст возможность Бобу потратить этот выход для другого хэша.
Так что мы еще от этого зависим.
Ну вот, протокол готов.
Вот видите, мы здесь можем...
Ну вот в таких случаях приходится писать более сложные правила валидации транзакций,
и Ethereum дает вам возможность писать совершенно произвольные.
Ну что ж, я немного утомился.
Есть у нас вопросы?
Так нет, криптографические инструменты там вполне себе есть.
Ты просто не можешь циклы писать, может быть тебе не нужно циклы писать.
Биткоин говорит, что ты обойдешься без циклов.
В эфире там все сложно, там можно странные вещи делать.
Там есть вот эти смарт-контракты, то есть такие грубо говоря сервисы, в которые ты приходишь и дергаешь методы.
И там можно писать все что угодно, огромное количество разных приложений, условно говоря.
Там есть, кажется, такое безумное, называется король эфира, что ли.
Знаете про него?
Вот там есть такой виртуальный трон, на который можно залезть, заплатить деньги.
Если ты хочешь их вернуть, нужно чтобы кто-то сел выше тебя, то есть заплатил больше,
и тебе разница вернется, но ты перестанешь уже быть главным на этом.
Ты уже не на троне.
А если никто не захочет, то у тебя проблемы некоторые.
Потому что можешь.
Это просто пример того, что можно написать абсолютно любую логику, можно что-то полезное делать, конечно же.
Ну и много полезного.
Я к тому, что язык позволяет делать, а в биткоине ты так делать не можешь, но, наверное, обойдешься.
Если ты хочешь какие-то правила валидации разумно писать, то у тебя есть инструменты для этого.
Там половина инструкшн с этой про криптографию.
Если эфириум — это такой компьютер настоящий, то это скорее калькулятор.
То есть ты на нем можешь гораздо меньше делать.
Но инструкшн с этой калькулятором криптографический, потому что, понятно, мы не можем...
Вам бы там много раз говорили, у нас клиенты тоже византийские, не составляют странные транзакции,
делают странные вещи, и только криптографией можно от них защититься.
Что еще?
Ну давайте, у нас осталось, не знаю, сколько у нас осталось.
Сколько у меня сил осталось?
Подумаем, что в следующий раз можно сделать.
Вот можно, я хочу поговорить про алгоритм Hot Stuff,
про то, как можно идеи из биткоина и PBFT объединить в некоторый более оптимальный алгоритм.
Потому что PBFT совершает очень много раундов,
и, очевидно, их можно было бы как-то схлопнуть, сделать меньше фаз на пути к комиту.
И для этого можно использовать хэшпоинтеры.
Я могу что-то рассказать про альтернативные блокчейны.
Но там, конечно, деталей уже настолько много и настолько сложно, что мы запутаемся.
Может быть, не запутаемся, не знаю.
Есть история, про которую совсем не рассказал сегодня, это альтернатива Proof of Work,
потому что очевидно, что Proof of Work — это не самое оптимальное, ну, в смысле.
Кажется, на самом деле, что это самое лучшее, что можно придумать,
потому что никакая альтернатива, она пока сильно не...
Нашлось никакой хорошей альтернативы.
Вот Ethereum, он до сих пор не может перейти на альтернативный протокол.
Но проблема Proof of Work в том, что мы тратим огромное количество электрической энергии.
Мы употребляем... Bitcoin употребляет его целая страна,
оставляет огромный экологический след.
Поэтому хочется использовать протокол, который также будет децентрализован,
но которому не требуется просто жечь электричества.
И тут, с одной стороны, есть разные альтернативные идеи.
Ну, например, предлагает блок тот, у кого много денег,
потому что он иначе рискует.
Он не хочет подвергать свои активы риску.
Он поэтому не может скомплементировать сам блокчейн, саму криптовалюту.
Есть способы, где вы доказываете, что вы не потратили не процессорное время,
а вы просто храните распределенно какие-то большие файлы, кусочки больших файлов.
Ну, короче, можно самые разные сертификаты придумывать,
но проблема примерно одинаковая.
Что можно каким-то образом все это объюзить,
ну и как в Биткоине, в конце концов, построить специальное оборудование
или что-то сделать специально, что повысит частоту вашего выигрыша.
Вот кажется, что никакой отличной идеи, которая бы решила эту проблему,
до сих пор не найдена.
То есть человечество, эгоистичные люди, которые хотят максимизировать выигрыши,
все равно сведут все к централизации.
То есть такие наивные соображения, что вы не можете поменять хэш-функцию в Биткоине.
То есть вы можете поменять хэш-функцию в Биткоине,
но в Биткоине вы не можете уже, потому что никто не даст,
потому что слишком большие деньги вложены в оборудование.
Вы можете сделать новый altcoin, но тогда просто там построить другое оборудование,
которое будет другую хэш-функцию быстро считать.
И вот то есть никакого такого наивного способа победить это нет.
Люди с этим борются, ну и оптимального решения пока не найдено,
ну и эфириум пытается найти оптимальное решение, в смысле перейти на другое, может быть я про него расскажу.
Но в следующий раз я точно расскажу про алгоритм hotstuff, который как раз из биткоина берет идеи,
но при этом он все еще работает в статической конфигурации, потому что, ну как мы видим,
на бумаге биткоин не централизованная система, на практике довольно централизованная,
поэтому может быть не стоит так цепляться за децентрализованность, за permissionless свойства,
а можно просто сделать более оптимальный алгоритм, который будет работать на сотнях узлов,
и этого будет достаточно. Ну так или иначе два мира, все равно они будут жить параллельно,
вот может быть мы какую-то инточку между ними проведем.
Ну что, если вопросы есть, то давайте я на них попытаюсь ответить.
А, вот что мы не... ну раз уж я здесь, просто это нарисовано на доске, я вспомнил,
почему мы адресуем транзакции хэшами? Последние умственные усилия на сегодня.
Почему это работает? Что? Нет, в смысле, почему так можно делать?
Ну ты не знай, я делаю примерно одно и то же, я получаю деньги от Арисы
и трачу их на гамбургер, делаю это каждый день. У меня какие-то транзакции одинаковые,
у них одинаковые хэши, это все не работает. Почему я могу адресовать транзакцию хэшом?
А почему он разный? Что? Что? Не понял тебя. Почему здесь форки?
Форки это репликация, а транзакция, я говорю про граф транзакций,
он с репликацией слабо связан, ну по крайней мере в первом приближении.
Сейчас в блоке. Ты понял мой вопрос, да? Отлично.
Она хорошо перемешивает, просто если мы хэшируем одно и то же, то мы хорошо не перемешиваем,
мы получим одно и то же. Ну еще раз, у нас транзакции по смыслу похожи.
Что? Не понимаю о чем ты. Таймстэмп где есть? Таймстэмп в блоке есть, у нас транзакции.
Ну еще раз, вот есть граф транзакций, и он просто выложен в блокчейн.
Я говорю сейчас про транзакции, вот этот рисунок он блокчейна не учитывал никак.
Я сказал, что мы рисуем транзакции хэшами. Не совсем понятно, почему не бывает двух транзакций,
которые просто похожи друг на друга, и у них будут одинаковые хэши.
Я еще раз говорю, каждый день я в одно и то же время покупаю себе BigMac.
В одном и том же месте деньги берут из одного и того же источника.
Это не совсем правда, тут уже начали говорить, как на самом деле, но просто не договорили.
Где различия-то берутся?
Ну смотри, чтобы потратить деньги, любые, нужно, чтобы они где-то появились, родились.
И если мы отправляем деньги кому-то, то мы можем проследить историю этих монет до самого-самого корня.
И разумеется, каждая монета тратится один раз.
В смысле, мы не можем один и тот же выход дважды потратить.
Так вот, уникальность берется откуда? Отсюда.
Потому что вот эти транзакции, они довольно специальные, вот они уникальные.
Если они не уникальные, то тогда можно легко построить...
Вот представьте, что у вас есть две транзакции, которые...
Алиса дважды выиграла 6,25 биткоинов, сгенерировала два блока.
Потом она дважды перевела деньги Боба. Две одинаковые транзакции, составляются на две одинаковые транзакции.
Хэши везде совпадают.
Хэши не совпадают, потому что эти транзакции все же будут уникальными, несмотря на то, что они приводят одни и те же деньги одному и тому же участнику,
потому что в них будет написан, я уже не помню каким способом, то ли хэш, то ли высота блока.
И не бывает двух транзакций, которые чеконят монеты, с одинаковой высотой в блокчейне.
Ну, в дереве могут быть, а в блокчейне не могут быть.
Поэтому дальше там все рандомизируется.
Ну, понятно, что может быть какая-то корридия супер-редкая, но это уже мелочь.
Так что страшного-то?
Ну, будет корридия. Почему это может привести?
Появляем, мы присылаемся на транзакцию, происходит коллизия, мы присылаемся на транзакцию, которая была значительно раньше.
Но мы же не можем чужие деньги потратить.
Ну, что плохого может произойти?
Не знаю, можно подумать.
Ну, вообще-то мы коллизию искусственно строить вообще не можем, кэш-функции.
Но вопрос про то, что будет ли коллизия все-таки произойдет против нашей воли?
Мы в это не очень верим, но вдруг так случилось.
Ну, я не знаю на самом деле ответа, потому что я не представляю, что будет, если хэш все-таки совпадет,
если есть две транзакции, в одной лежит на выходе миллиард долларов, я не могу их забрать, потому что не понятно, что будет в этом случае.
То есть понятно, что я не смогу прицепиться к чужой транзакции, потому что там валидация не пройдет.
Но если вдруг есть две транзакции, одна не валидируется, а другая валидируется,
то есть я не знаю есть ли детерминированные правила, которые говорят, что, окей, одна тратится.
Ладно, нужно разобраться.
Ну что, на сегодня тогда все. Спасибо вам.
