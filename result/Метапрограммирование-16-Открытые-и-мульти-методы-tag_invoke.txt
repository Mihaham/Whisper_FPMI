Я две строчки буквально пропишу про домашки, да, немножко информации про домашки. Во-первых,
многие из вас... Пальцы оледенели, писать не могу. Вместо вот такого, которое я показывал на парах,
и вот здесь всякие вспомогательные хелперы, некоторые из вас вот так вот делали. Ну,
почему некоторые? Каждый второй. Так вот, вот это и вот это принципиально разные конструкции,
которые не имеют ничего общего. Вот вам так кажется, что это какое-то лишнее, зачем здесь имя,
нам оно не нужно, напишем просто namespace. Вот это очень похожие по тексту конструкции,
которые значат тем не менее абсолютно разные вещи. Вот это, это просто обычный namespace. Зачем мы
его пишем? По сравнению с... Какая-то вот метафункция у нас есть, да, но мы ее реализовать
просто так в одну строчку не можем, поэтому делаем какой-то метафунк-хелпер. Ну, там в
тайп-листах такое было, даже в слайсе, везде. Ну, повсюду нужны какие-то хелперы. Ну, как-то в
нешаблонном программировании такие хелперы из хедеров убирают, в cpp-шник запрятывают или в
приват какой-нибудь, в оп, всякие детали инклементации. Когда у нас метапрога, мы вот лучше этого
ничего придумать не можем. Зачем вообще что-то придумывать и не оставить просто вот так вот хелпера?
А тем, что я теперь... Ну, вот, предположим, это хедер какой-то был, его кто-то заинклюдил из
ваших пользователей, начал писать метафунк и нет сеггестшенов, потому что ну а зачем? Черт,
давайте я сейчас быстро все это скопипасчу в какую-нибудь...
Секундочку.
Вот здесь будем писать.
Все закроем.
Вот, вот я так пишу WDEшки свои, и мне первым высвечивают метафунк. Я нажимаю Enter и я доволен.
А если я сделаю вот так, то мне высвечивают и то и другое, и более того, в зависимости от ситуации
имен, может так получиться, что первым хелпер покажут. Вы нажмете Enter и будете недовольны.
Конфликт имен тоже можно, между разными. Вот там L, H, I.
Нет. Ну, в смысле, это большая проблема, потому что это замедляет написание кода. Вот так я там
какую-то букву P написал и просто так отсортировалось по алфавиту, что первым хелпер идет. Ну и это
неудобно просто. Если эта библиотека используется типа во всей кодовой базе, все типа разработчики
там 100 человек используют, то каждый из них потратит там каждый день по несколько секунд на
то, чтобы, ой, не то написал, стереть, обратно написать. Если все это перемножите, то приличное
время не потрачено впустую. Кто вам мешал написать здесь детейл и не тратить это время за зря. Вот,
а теперь к тому, что, в принципе, вот такая конструкция делает. Она делает очень смешную вещь.
Ну, для классов ничего, а вот для функций она помещает их статиком, автоматом. То есть,
ну, вот такая конструкция, это то же самое, что и вот такая конструкция. Вот эти foo и bar,
они обе static. То есть, ну, вот такая конструкция с минимальным namespace, это просто способ пометить
кучу функций разом как static. Вот это единственное, зачем языке эта конструкция нужна. Ну, если вы
там на Sharpe на джаве писали, то вы видели там постоянные вот эти вот public static int foo, public
static int bar, public. Ну, каждый раз public static писать. Вот мы типа оптимизируем, да? Нас public
dot один раз написал, все довольны, очень удобно. Это немножко сарказм, если что. Так же и здесь
сделали, что типа ой, static много раз писать так лень, давайте просто массово пометим.
Ну, кажется, оно еще и спасает от конфликта имен, действительно. То есть, если вы хотели
чисто конфликта имена сбежать, вот тут такой код, он не конфликтует, кажется, что. Вроде бы да.
Потому что там есть как бы реальное имя на namespace, какое-то фактически, оно просто генерируется.
Ну вот, да-да-да, генерируется-то, генерируется. То есть, когда вы так пишете это как анонимная
функция, она же лямбда, у вас как бы генерируется какое-то имя. Но когда вы позвать такую функцию,
захотите, где есть конфликт, у вас все равно будет амбигиус, как мы видим. И то, и другое
подходит. То есть, как бы это разные функции, но именно они у них одинаковые, и мы не можем вызвать
ни одну из них. Ну вот непонятно, зачем, в общем, так делать. А в header это еще и вредно. Кто нам
напомнит, почему в header не стоит статические функции писать? Потому что они размножатся. Да, static
значит, в каждом cpp-шнике своя функция отдельна. Вот это вот, фу, она будет новая, своя, разная,
скопипасченный ассемблерный код в каждый cpp-шник, в который вы заинклюидите этот header.
Ну и если вы через namespace анонимный пометили все как static, то у вас все функции в вашем header,
вот эти вспомогательные, они будут копипаститься в каждый translation unit, раздувая размер вашего
бинаря. Зачем? Ну то есть, вот эта вот конструкция в header никогда не нужна. Это вот железно,
абсолютно никогда. А в cpp-шнике я предчитаю ее тоже не использовать. Лучше явно напишите,
что статик. Сейчас, Ром, мне кажется, то, что написал с фу внутри bar, это ambiguous call
внутри данного namespace, но это же не совсем ODR. Нет, ODR здесь нету. Ну вот мы можем от ODR как
раз спастись, если фу это, не знаю. Да, да. Кто-нибудь понимает, кроме Аркадия, о чем речь? Что такое ODR?
В чем проблема? One-definition rule. Помним, да? Вот в плюсах всегда есть какие-то хитрые способы нарушить
это one-definition rule. Сделать несколько definition в одной и той же функции и сделать уб. То есть,
ну вы зовете функцию и не знаете, какая из них позовется. Ну, вот это вот, анонимные namespace,
они от нарушения ODR спасают, потому что вот это фу и вот это фу, это автоматом разные имена,
разные функции. Ну, namespace вот этого анонимного, какое-то имя сгенерируется, типа вот что-нибудь такое,
и как бы ODR нет. Но я не знаю, в какой ситуации вам захочется именно так спасаться от каких-то
нарушений ODR, а не просто написать нормальный код. Я что-то помню, что Ниблер тоже недавно говорил,
что у них опять execution tests сломались из-за ODR, они оборачивали все анонимные namespaces. Ну вот,
если ты конкретный кейс нам скинешь почитать, будет здорово, но мне пока оно ни разу не пригодилось.
Вот, поэтому я не могу сказать про это больше, чем, ну то есть то, что это эквивалент нам везде пометить
как статик, кажется верно, помимо вот этих вот проблем с ODR, ну давайте просто забьем на все это.
Не пишите в хедрах анонимные namespaces, вот мораль. В домашке все, пожалуйста, это уберите. Это первое,
что хотел сказать про домашку, а что второе? А, про итератор в... Да, вот есть итератор у вас
в слайсе, прекрасный итератор, у него есть там указатель и страйд, вы пишете.
Оператор равенства, ну, например, вот такой. PTR равно ODR, PTR. Нормально? Нормально, потому что
какая разница, какой страйд? Вот такая легатура. Где это у себя сделать? Ну,
во-первых, надо поставить шрифт Fira код. А, ну в JavaScript. Там тройное равно и двойное
отличаются. А ну вот, ну бывает, в плюсах, конечно, не нужно. Так, и сделали вот такую штуку,
и тут мы такие пометили авто. Давайте пытаться найти здесь какую-то проблему или доказать,
что ее нет. Где может очевидно быть проблема? Консты, конечно, да. А в другом месте проблема,
связанная все-таки с нашим курсом. Чего? Вот да, я некоторым из вас написал уже там в комментариях,
equality preservation. Ну, на самом деле проблема в том, как вы пишете код. Вот вы поставили авто,
не задумываясь, скорее всего. Вот из тех десяти или пяти человек, которые поставили авто,
я очень сомневаюсь, что кто-то сел и так внимательно задумался. Так, это у нас указатели, значит,
тут выведется. Так, семантические требования выполнены, все корректно. Это не строн-кордеринг,
это строн-кордеринг. Ну, во-первых, давайте поставим явно строн-кордеринг, чтобы было очевидно,
что происходит. А во-вторых, почему ты так считаешь? Вот давайте для этого...
Сейчас. Кто-нибудь помнит, как концепт называется или где эти семантические требования были написаны?
Что-то я забыл. Наверное, в нем, да. Наверное, в нем. И тут нам интересно...
Ну, короче, сейчас я не найду, видимо, да. Так вот, о чем я подумал в первый раз,
когда наткнулся на это авто, сразу подозрения. Ну, подозрения правильные, но вот вывод я сделал
неправильный. Что, мол, можно сделать слайсы с разным страйдом на один и тот же контейнер и
потом сравнить их итераторы. То есть а-ля... Вот это будет с одним страйдом, там типа, неважно.
Страйд будет один, это будет структура для наглядности. Это будет итератор два, но у него будет
другой страйд. И вот мы такие, о, правда, работает. А теперь такие. Потому что мы только ПТР сравниваем.
Ну, мы скажем, что это динамик страйд был, то есть это динамический слайс. Вот про это речь.
Плюс-плюс определен. Неопределена вот эта операция. То есть, ну, вообще, я только что продемонстрировал
нарушение quality preservation. Согласны? Вот мы одинаковые операции проделали и опа,
equality нарушился. Не знаю. По идее, для этого и сделано. Ну, то есть, по идее, ровно для таких
оптимизаций оно и сделано. Делаются ли они на практике сейчас, надо Assembler копать, я не смотрел.
Но здесь нету никаких нарушений, потому что вы сами написали UBS с точки зрения своего кода.
Для стандартного спана, если у вас два разных спана было, и вы из них получили два итератора,
сравнивать их некорректно. Можно сравнивать итераторы только на один и тот же span,
порожденный из одного и того же инстанса. А вот такие два разных итератора с разным страйдом могли
получиться только из разных слайсов. Это к вопросу, как написать этот код, так чтобы он был правильный.
Давайте вот так напишем, чтобы было совсем наглядно, что вот было два разных слайса,
которых здесь, конечно, нет. Скип возвращает другой тип. Да, скип возвращает не другой тип,
а новый инстанс. Вот в этом главное. Это один инстанс, это другой инстанс. Вот в стандарте решили,
чтобы в такие игры дурацкие не играть, мы просто скажем, что сравнивать итераторы на разные
инстансы спана это undefinedBehaviour. Нет, почему ты такое решил? Если мы говорим, что в нашем коде
валидно сравнивать итераторы на разные слайсы, то здесь действительно должен быть weakorder.
Я забыл, как он называется. weakordering. Если мы говорим, что мы считаем вот эту строчку
корректной, то есть можно сравнивать из разных слайсов, то надо поставить weakordering,
действительно. Но weakordering, с ним неприятно работать, это меньше возможности оптимизации
компилятору. Поэтому хочется все-таки strictordering. Но этого тоже можно добиться. И вот в стандарте нам
говорят, как этого добиться. Просто сказать, что такая строчка сравнивания итераторов на разные
слайсы, это автоматому B. Ну, можно написать какие-нибудь иператоры сравнения шаблонные.
Некоторые из вас так делали. Так вот, я предлагаю нам тоже сказать просто, что на разные слайсы
итераторы запрещено сравнивать. Ассерт тут уже не нужен, мне кажется, потому что это ну такой,
ну можно бахнуть. Можно бахнуть, ассерт, что other stride равно равно stride. Но это все равно вам не
поможет спастись от того, что это были разные. Вот такое иногда делают, кстати, в некоторых итераторах,
некоторые так пишут код, ну нет, давайте, ну ассерт можно. Отлично. Нет, короче, вариантов много,
мораль какая. Вот ровно на такие вопросы вы как там дизайнер кода должны отвечать. Вот в вашей
системе определено поведение вот такой строчки? Если определено, то вы должны продумать вот такой
момент. Если не определено, то как бы все нормально и так. Ну вот это вот тонкие моменты. Ну можно
писать авто и не думать, но просто авто пишешь и ты не задумываешься. Я предлагаю вам авто не писать,
а писать все-таки явно, и тогда сразу задумайтесь. Так, у меня строн-кордер. Здравствуйте. Извините,
извиняю, нет, садись. Отвлек меня. Что я говорил, не пишите авто, пишите явно. Как только вы явно
написали строн-кордеринг, вы сразу задумайтесь, подождите, quality preservation, а я тут два поля имею,
а сравниваю только по одному. А не нарушу ли я как-нибудь quality preservation? Вот об этом надо как бы
задуматься и сделать, чтобы у вас все нормально было. Окей, на этом все по комментариям, по слайсу.
Это по всех контейнерах стандарта? По-моему так. Ну да.
Нет, смотри. Только узнать от кого-нибудь или прочитать где-нибудь в твиттере, например. Ну такие
вещи. Понимаешь? C++ это язык, который лучше всего учить, читая твиттер членов комитета стандартизации,
на удивление. По набросам в твиттере? Ну да, по набросам в твиттере, это прекрасно работает,
они там статьи кидают. Да, это тоже. Вот, ну вот тут есть ссылка, что cp17 forward iterator domain of
lalala same underlined sequence. Ну если мы там std concept откроем. Ну тут, конечно, надо смотреть.
Ну то есть вот прям, явно вам написано, нельзя сравнивать итераторы на разные контейнеры.
Предлагаю вам придерживаться такого же правила. Тогда у вас все ордеры будут strong и проблем не
будет. Это опять моменты, как в Библии, их нужно правильно интерпретировать. Я боюсь, что будет,
если это интерпретировать не так, как я сейчас интерпретировал. Мне кажется, все-таки задумано
так. Ну вот да, как бы раскол церкви c++ сейчас происходит. Да, наверное, ты все-таки не хочешь
сравнивать итераторы из разных этих, тем более, что, вспомним, что на меньше-больше можно сравнивать
только указатели, которые в одном, в один блок локации указывают. Помните, я вам такое говорил,
хоть кто-нибудь? Ну вот, соответственно, если у вас есть один вектор и другой, вы сравните итераторы
из этих векторов, то это указатели в разные локации, и у вас в Б, во всяком случае. Поэтому лучше
соблюдать это. Ну вот ты сказал, что иногда потенциально, может быть, хочется нарушить это, и вот вопрос как-то
сделать так, чтобы пользоваться, чтобы было понятно, что я это нарушаю. Давай сначала ты придумаешь
кейс, которым ты хочешь нарушить, прям адекватный, ненадуманный, адекватный, и тогда мы поговорим,
а сейчас будем говорить еще немного про полиморфизм. Вот тут две таких маленьких подтемы,
здесь мы их быстро пролетим и после этого продолжим обсуждать домашки, потому что они меня
гораздо сильнее сейчас волнуют, чем новые темы. Вот, значит, ну про... не будешь работать, да?
Про мультиметоды надо сначала поговорить, перед тем, как вот к страшному слову Tag and Walk переходить.
Это каждый раз происходит, я же заранее воткнул, чтобы оно потупило само. Оно не потупило.
Как это понимать? О, работает. Вот такая смешная картинка, вот тут изображены какие-то разные
типы пересечений, кружочка и квадратика, условно говоря. На это можно сделать свитч, правда? Ну,
вот вы поняли, какой у вас из видов пересечений, и дальше вам там площадь надо посчитать,
какой-нибудь многоугольник построить, который имеет форму пересечения, неважно. Ну, вот свитчи
хорошо бы заменять на полиморфизм. Мы же все обожаем заменять свитчи на полиморфизм. И полиморфизм,
ну статический, мы умеем делать в таком случае, но сейчас увидим как. Но вот кружочек и квадратика
окей, а если у нас там целая иерархия, там кружочки, квадратики, какие-то полигончики,
вот куча разных вариантов, каждый с каждым надо пересекать, еще там по-разному возможно. В общем,
напрашивается какая-то такая конструкция, что у вас много перегрузок, кружок с кружком,
кружок с квадратом, квадрат с кружком и так далее. Ну и в них написан разный код пересечения разных
фигур. Ну, аналогично для разных случаев пересечения можно сделать. На самом деле просто картинка
первая не очень удачная, но она уже тут три года, поэтому с уважением к ней относитесь. Ну, понятная
идея. Это multiple dispatch полиморфизм. Вот в обычных виртуальных методах у нас только один аргумент
влияет на то, какой метод будет вызван, определяет вот этот полиморфизм. Тот, на котором мы точку
делаем, объект точка метод, то, что перед точкой определяет, у кого вызовется метод. Тут же мы
определяем по нескольким аргументам, у кого вызовется метод. Ну вот а что, если мы хотим
динамический полиморфизм в таком месте, казалось бы, что может быть проще. Вот есть перегрузки,
хочется динамически диспетчеризироваться. Ну, нативных инструментах в плюсах, как вы можете
припомнить, для этого нету. Свечи это не полиморфизм. Все полиморфизм. Свечи ифе полиморфизм.
Ну, свечи окей, свечи сработают, только здесь вместо свеча иф написан, потому что, ну,
почему мы будем делать свечи? Нам по интерфейсу shape приходит какая-то фигура, надо пересекать.
Это еще одна тема по домашкам, которую хочу поднять на самом деле. Кто-то так каждый год делает.
Вспомните, как вы решали домашку про маппер. Есть ли у вас там тройкетч?
Признавайтесь, есть ли у кого тройкетч? У кого найду, того заставлю переделывать.
Ну, потом, в общем, про домашку. Ну, нормальная тема. Ну, вы же понимаете, что руками отписать влом?
Да нет, ну ты что, нет. Надо сделать список типов, надо написать шаблон, генерирующий вот такой вот
каскады FOV и там список функций тоже в компайлтайме. Можно не только типы в списках таких компайлтаймовых
можем хранить. Указательно, функции тоже можем. Ну и как-то так вот это все делается. То есть
приправляем метапрога и получается. С вашего позволения я не буду сейчас тратить время на
то, чтобы это проделать, потому что более-менее понятно, как это делается, правда? Что? Зачем?
Потому что вот сюда много дописывать буков сложно и неудобно. Хочется написать вот еще
одну функцию вот такую, вписать ее куда-нибудь в список, что мы поддержали новый класс и чтобы
все работало. Ну, предлагается просто сделать список типов, в котором все вот эти вот circle,
rectangle, там полигон, вот список типов, где все это есть. Например, в принципе и через маппер можно.
Во-первых, да, во-вторых, чтобы руками вот эти ифы не писать. Говорю, нам приходит по интерфейсу два
непонятных экземпляра. Надо динамик касты проделать и понять какие-то экземпляры и в зависимости
от этого вызвать разную функцию. Ну или разную перегрузку одной и той же функции. Ну маппер у
вас был single dispatch, там один объект был. Ну да, конечно же так писать не надо, надо написать маппер,
который типа в рядик и там сразу все делает. Если хотите, можете сами проделать. Идея, я надеюсь,
понятна. На практике такое вряд ли кто-то будет писать, вот, потому что тут есть проблема с
симптотикой небольшая. Вот если так задуматься, то вообще-то, вообще-то ифы это тоже такой цикл. Да,
он в compile-time, но как бы асимптотика все равно есть. Можно сказать, что вот единица, потому что
мы в compile-time фиксируем количество сущностей. Но на деле, ну вот комбинаторику вы помните,
да? Понимаете, что тут n в степени m? Я уже не помню просто, я доверяю себе прошлогодним или
пазопрошлым. Вот сколько аргументов у метода? Количество аргументов, арность, да. Количество
аргументов, по которому мы хотим диспетчеризироваться. Ну и n это количество вот этих
разных наследников интерфейса, по которым хотим. Ну вот еще там списки типов надо сортировать,
как бы это сделать можно, там ambiguous call можно обработать. Что я имею ввиду под ambiguous call?
Ну вообще говоря, эта иерархия, она может быть неплоской. Тут вот от полигона square может
наследоваться. И вероятно, вы хотите уметь делать какие-то методы, мультиметоды, которые берут
ректанглы полигон, а еще отдельный берет там square, еще что-то, какого-нибудь наследника
ректангла. Ну вот как бы да, вот это вот надо написать, чтобы вот проблем тут не было. Ну,
надеюсь, кто-то понял, это несущественно. Вот, ну и еще отсутствующая перегрузка бывает. Бывает
такой кейс, что у вас для какой-то пары не определена ваша операция. Ну это тоже можно
поддержать. Единственное, что вот долго, мы по сути за линию такую в кавычках проходимся,
но линия это на самом деле n в степени n. Жесть, надо лучше. Ну сейчас будет очень знакомая тема,
тем, кто любит ОП. Да много чего можно. Тут, наверное, можно. Я уже не в том возрасте,
чтобы когда вот вижу задачу и мне говорят, можно за такую симпатику, у меня мгновенно в голове
был решение. Ну хорошо, если топологическую сортировку сделать, то тогда можно. Да, вот как
бы топологически отсортировать, потом идти по первому и там все делается за более-менее нормально,
но можно лучше, можно проще без вот этих всех генераций каких-то ифов. Ну вот это не самый
лучший вариант. Ну да, это легендарный метод «нормально делай, нормально будет». Если тебе
нужно найти перегрузку, возьми ее и найди, что тут сложного. Окей, еще один способ, как ее найти
все-таки. Виртуальные вызовы есть, они диспетчеризируются по this, по одному аргументу.
Ну давайте сначала по первому аргументу диспетчеризуемся, потом по второму. То есть,
ну вот тут какой-то код, сейчас надо его понять. Нам прислали other в intersection area,
а мы у other и вызываем intersection area this. Ничего не напоминает? Что? Визитора, вот. Вот это
правильный ответ. Ну как бы мы двойную диспетчеризацию делаем, нас вызывают непонятно чего. Что? Да,
вас прям используют, но это вот хорошо. Ну да, кто-то снаружи зовет у какого-то шейпа метод
intersection area. Мы попадаем в конкретный шейп уже, по первому аргументу, в circle, сюда попадаем,
а теперь мы наоборот делаем. Вот нам прислали неизвестного шейпа, а мы у него зовем intersection
area. Но вот себя мы уже знаем. Кто мы? Мы circle. Вот this у него будет тип как раз circle. И вызовется
вот эта перегрузка. Ну или точнее. Давайте лучше вот через это. Пусть мы позвали на двух шейпах
intersection area. Первый был rectangle, второй circle. Первый вызов. Можно. Будьте осторожны. Ну вот если
мы на rectangle и circle зовем, мы сначала придем сюда, потому что первый аргумент был на самом деле
rectangle, а вот это вот придет на самом деле вот сюда. Потому что тут первый аргумент на самом деле circle
и из двух этих или трех этих перегрузок мы вызовем самую конкретизированную. А вот здесь у this уже тип
известен статически. Поэтому этот rectangle будет эта перегрузка вызвана. Простая тупая идея. Работает,
можно делать. Можно совсем хорошо. Может начать казаться, что это плохо на самом деле, но эту идею
можно добить до нормального чего-то. Внимание, костыль из книжки двадцатилетней давности. Давайте
добавим интерфейс с вот таким вызовом get class index и в каждого наследника будем вписывать вот
этот macros, чтобы автоматом подпихнуть туда, во-первых, статическую переменную, а во-вторых,
по виртуальному вызову уметь получать эту ссылку на эту статическую переменную. Поняли,
что произошло? Нет, нет, именно просто ссылку. Вот он изначально минус один, мы просто ссылку
возвращаем. Заполнять этот индекс будет кто-то извне. Нет, нет, нет, через friend injection можно
сделать много чего, здесь его не будет. Пока что мы просто завели по одной переменной в каждом
классе иерархии. Мы готовимся к номерации, но пока просто вот. Кстати, почему так, а не статическое
поле? Кто может сказать? Зачем писать метод статический, внутри которого? Да ничего не сложно в
современных плюсах. Ну ладно, ты, наверное, прав, да. Тут, скорее всего, такая причина была. У меня
другое предположение есть. Вот эта штука tradsafe-ная, по-моему, автомат. Что-то там
инициализация, первый вызов к этой штуке, он tradsafe-ный, потому что вот эта вот инициализация,
она там под mutex-ом делается. В общем, статические переменные внутри методов, они инициализируются
под mutex-ом, только инициализируются. Не доступ к ним потом, доступ к ним потом, он просто,
ну переменная и переменная. Собственно, вот singleton-maersa, слышали про него? Да. Ну вот это ровно по той же
причине там пишется. Вот именно так. Потому что там инициализация, она под локом происходит.
Чего вызывается? А когда это вообще имеет влияние какое-то? Не знаю. Я предпочитаю просто вот
такую штуку не использовать. Вот статические переменные внутри этого и там такие вещи,
это все бор темный для меня пока что. Но всегда есть способ лучше это написать. Ну вот Александровску
в своей книге предлагает нам так сделать. Давайте так сделаем, неважно. Полетим дальше. Ну вот какой-то
derived от base, в базе есть этот интерфейс. Мы за уберрайдели вот этим макросом забавным. Ура!
Александровску в своей книге сказал, что надо через макросы. Сейчас мы можем гораздо лучше,
гораздо проще на самом деле. Ну вот весь мультиметод. Мы будем делать вектор указателей на функции.
Ну пока это не мультиметод, это просто метод. Так написано в книжке, это просто изложение
материала книжки. Я говорю, вы если будете на практике что-то подобное делать, вы 100% сделаете
сильно лучше. Но это ну такая основная идея, тупая. Вектор указателей на функции, нам прилетает
новый указатель на функцию и класс, для которого вызывать эту функцию. Пока не мультиметод. Ну
берем idшник ему, если его нет, выдаем новый, просто по размеру этого массива и запихиваем в туда,
где idшник, функцию, которую нам дали. Понятная идея. Тупая идея. Ну понятно, что нам обобщается
насколько угодно много таких классов. Сделайте вектор векторов и все работает. Вот и вообще такая
штука называется открытые методы. Несколько напоминать должны extension-методы, которые уже
многократно упоминались. Вот я и не знаю, extension-методы бывают виртуальными в котляных с-шарпах,
а прочем. Все виртуальное. Ну значит, бывают. Ну в общем, это вот такая некоторая попытка сделать
extension-методы в плюсах с виртуальностью и прочим-прочим. Ну runtime-полиморфизм, вот там еще есть
какой-то expression-problem, который был когда-то и всех волновал где-то в начале нулевых, в конце
девяностых. Но нам это не интересно, нам интересна вот эта вот табличка, что мы в ОП этом группировали
сяк-визитер и сяк, а теперь в открытых методах можем сгруппировать сяк. Потому что просто, блин,
какой-то порядок слайдов странный, ну ладно. Потому что просто берем и вектор векторов делаем,
ну по каждому индексу класса мы понимаем куда лезть. Естественно, тут вообще никакой группировки
нету и дописывать можно в каком угодно месте, что угодно. Да, ну конечно же это все немножко
фига тень, тут вот ID-шники типов какие-то вычислять, ну с много поточностью тоже проблемы,
конечно же, будут. Нам ни тепло, ни холодно от того, что там минус единичка потока безопасно,
это инициализировалось, нам интересно именно вот выдачу индекса. Хотелось бы вообще,
чтобы эти индексы выдавались автоматом. Можно добавить в то, что ранится до мейна. В плане.
Ну вот что-нибудь такое можно сделать. Можно через это и хэш таблички. Ну сейчас увидим,
короче. В общем, ID типов не делайте. Раньше это было модно, потому что ничего лучше не придумали,
теперь не делайте. А векторы могут очень сильно вырасти. Если вы вектор-векторочков делаете,
или трехмерный вектор, вектор-вектор-вектор, то будет очень много пустой памяти. Нужно
Sparse что-то писать, какую-нибудь Sparse матрицу, и тогда будет нормально. Вот помните момент был
с ректенглом, который наследовал полигон. Вот тут такое не особо работать будет. Ну если задуматься,
там просто вот непонятно, что должно происходить, и оно вот просто так не заработает, нужно что-то
еще дополнительно предпринимать. Ну и тут как бы все это фиксится, что вот телекаты принимают
бейс. Даже не помню, что я хотел сказать, и неважно. Через TTI можно пофиксить легко и через... Короче,
вот так надо писать. Вот это решает все проблемы. Никаких векторов, unordered мапа, хэш мапа, круто.
В идеале не STDшную используете, потому что вы же знаете, что STDшная unordered мапа очень медленная.
Вот, хорошо. TypeID. TypeID нам никто использовать не запретит, даже если RTTI выключен, потому
что мы вроде научились его устанавливать обратно. Через адрес метода что-то вот такое мы делали,
помните? Адрес статической функции в классе. Не помните ничего. Ладно. Короче, TypeIDшники можно
даже без RTTI себе восстановить при помощи несложных манипуляций. Ну и, конечно, указатели на функции
это не очень удобно, лучше хранить прям нормальные функции со стейтом. Вот, ну и в каком-то таком виде
совсем легко просто понятно получается. Но если вам нужно несколько типов здесь, возьмите да
поксорите хэши TypeID. Или, ну, ксорить лучше не надо, лучше как-то их комбинировать адекватно, да.
Чего? Ну, что-нибудь такое. Ну вот, можно бахнуть тензор, да, как-то у меня не в том порядке немножко,
что вот вектор векторов и вот он прекрасный мультиметод рабочий. Зачем? Только не очень понятно,
но такое есть. Ещё можно смешной трюк вывернуть. Можно взять и сделать симметричную диспетчеризацию.
То есть, тут у вас два аргумента и вы можете сказать, что для пары AB и BA всегда будет одинаковый
метод вызван. Ну то есть, если вы пересекаете фигуры, это симметричная операция, правда? Ну и наш
полиморфизм замечательно это должен учитывать и выдавать одинаковые результаты. И, ну, там,
как-то это делается. Я думаю, вы и сами догадаетесь, что там AB пару заменять на BA. Несложно. Давайте
вот про финального босса нашего курса попробуем поговорить. Я понятия не имею, получится ли. Каждый
год я предпринимаю попытку. Да. Ну STD Visit уже автоматом тебе делает мультиметод на
вариантах. В STD Visit можно запихнуть не один вариант, а несколько. До 11 штук. И
Аркадий знает. Ну больше 11 не нужно. 11 нормальное число. Вот. И, то есть, соответственно, передаешь
функцию, которая принимает там три аргумента, причем все комбинации этих трех аргументов,
и передаешь три варианта. И оно тебе дикартовое произведение всех вариантов перебирает.
Нет? Ну, давайте это напишем. Быстро, просто и понятно. Include ли вариант? Вариант из
Bula. Это V1, он будет от false. Chara и langa. Зовем STD Visit. Сюда мы прокидываем функцию не простую,
а золотую. First after second. И пихаем туда V1 и V2. Что? Visit не просто умный, Visit невероятно
умный. Но мне надоело сюда вписывать код. Давайте в Godbolt впишем, там быстрее запускать. Да нет.
Так, ну чего он меня не запускает? Output компилятора, Output это. Где Output программа?
Executor, вот. Вот, не поверите. Buzbulam и Charm позвал перегрузку. Понятно ли, что произошло? Вот этот
объект lambda, он содержит шаблонный оператор круглой скобки, который можно вызвать с любыми
двумя аргументами, которые ему прикинут. Мы запустили Visit от этой lambda и V1 в V2. Что сделает
Visit? Он в этом объекте вызовет ту перегрузку оператора круглой скобки, в которой аргументы
соответствуют тому, что лежит на самом деле в этих вариантах. А у нас в этих вариантах на
самом деле лежит Bool и Char. Вот здесь же я написал Bool и Char. Соответственно вызовется перегрузка с
Bool и Char, ну шаблон к любому подойдет. И вот первая авто это Bool, вторая авто это Char. Тоже вполне
себе мультиметоды статические на вариантах. Да, это можно объюзить всякими интересными образами.
Ну не получилось. Я хотел, чтобы у меня просто какой-то код скомпилировался,
я кликнул на Visit и мы посмотрели. Что тут у нас? S-Variant, S-Variant, тыры-пыры. Да, все понятно. Да
не, мне тоже ничего не понятно, это нормально. Я хочу найти комментарий про 11 штук. А, ну вот.
Вот если N больше типа 11, то ну все. Не, ну это глупо реально, зачем больше 11 аргументов писать?
Не уверен. Возможно, возможно. Я неправильно этот код интерпретировал, когда... Ну да, вероятно,
я неправильно интерпретировал, что оно не работает после 11. Возможно, оно тут просто менее
эффективную имплементацию использует. Вот. Ну видимо, ну черт ногу сломит в этом коде,
я не хочу код либо cdc++ читать и вам не советую. Поэтому давайте про теганвук поговорим.
Не очень хорошим, потому что там 100% оно пишется не красиво, не элегантно, а с тупыми хаками.
Да, то есть это, ну, боль и страдание. Ну как бы никто у вас, вам не запрещается самостоятельно
поупражняться во всяком вот таком прикольном, если вам это нравится. В «Аркаде» я не объект
написал. Кому-то это прикольно, я уже расчаровался в жизни, мне не прикольно писать и не объекты.
Сейчас мы узнаем как раз, что такое не объект. Потому что тема наша последняя, это теганвук.
В прошлых сериях мы узнали что-то про неблоида и цпо, да? И у них там были какие-то проблемы,
вот мы что-то их порешали, но не все. Давайте вспомним, что такое неблоид. Кто-нибудь? Нет?
Вот давай один. Ну в целом да. Такая шняга, которую мы вместо функции используем. Вместо
функции делаем объект. У объекта круглые скобки оператора, дальше уже что угодно. Зачем? Чтобы
подавить случайный ADL. А цпо это что такое? Это вот не то же самое, что неблоид, а накрутка поверх
него. Что мы там накручим? Ну да. Да, то есть мы так и берем неблоид, это объект, он ADL подавил,
а дальше мы внутри все равно используем ADL, чтобы сделать кастомизация. Чтобы можно было для
конкретных ваших классов переопределить, что эта глобальная функция будет делать.
Вот, то есть такая прикольная техника, но там была вот проблема такая, да? Что как только мы
сделали цпошку std ranges swap, имя swap у нас глобально зарезервировано. Вы не можете больше ни в какой
своей библиотеке сделать цпошку swap, потому что тогда ADL будет находить не ту функцию swap,
о которой вы думаете. Поняли о чем я, да? Вспомнили, что там такая проблема есть и надо ее решить.
Давайте ее решим. Для этого нам нужно опять вспомнить про вот такую смешную штуку. Вот есть optional,
и у него есть такой конструктор, а есть такой конструктор. Вот этот конструктор понятное дело
пустой делает optional, а вот этот вот конструирует прямо внутри optional уже какой-то лежащий объект.
Вот вопрос, что если у нас объект без аргументов, и мы хотим сделать optional,
к которому же есть этот объект, но без аргументов, как вызвать вот эту штуку без аргументов вместо вот этой?
Можно такое сделать? Нет, треугольные скобки для конструкторов явно указывать нельзя,
потому что это будет конфликтовать с синтаксисом указания вот этого. Вот, поэтому мы пишем тут
вместо каких-то треугольных скобочек, которые вот с этим конфликтуют, такой подхак,
steady in place t, и тогда если мы зовем вот так, то у нас вызовется вторая штука. Если без, то первая.
Видели уже такой хак, правда? Даже делали. И вот это вот, на самом деле, вот эта фундаментальная причина,
почему его вообще в стандарт несли, потому что бывает, что мы хотим и то, и другое иметь вызывать,
и не иметь каких-то конфликтов. Воспользуемся этой идеей. Очень плохо воспользуемся. Вот у нас
какой-то customization point object swap. Здесь мы раньше вызывали неквалифицированно swap, чтобы ADL нам
пошел и нашел то, что нужно, какую-то кастомизацию. Теперь мы не будем вызывать здесь просто swap,
вот это вот неквалифицированное имя. Теперь неквалифицированное имя, которое мы вызываем,
будет имя tag invoke. Вот это имя теперь зарезервировано глобально и никто его не может использовать в своих
целях никаких. Зато мы всегда его используем, чтобы сделать ADL, при этом дифференцируем разные
цепошки. Вот для какой из цепошек мы сейчас делаем ADL? Посредством тега, где в качестве тега
служит сам объект цпошки. Запутались? Очевидно. Интуитивное решение. Интуитивное и понятное. Вот
это это тег, вот точно такой же, как был на прошлом слайде. Ну вот это тег, тут специальный какой-то
класс завели. Ну и здесь мы хотим для каждой цепошки свой тег завести. Ну есть swap, begin, end,
это все разные цепошки, но мы хотим не резервировать глобальные имена, когда вот здесь дергаем через
DL что-то. Поэтому мы зарезервируем одно имя, а для разных цепошек будем использовать разные теги.
Ну и почему бы в качестве тега не использовать сам этот объект и сам его тип? Это же какая-то
анонимная структура, вот у нее уникальный тип, вот ее используем в качестве тега. Все. Вот это
тег на бок. Всем понятно? Аркадий, тебе понятно, что понятно? Ты уже все это сам написал. Поговорите со мной
остальные. Вы понимаете, как это решает проблему namespace? У нас у каждой этот тег в своем namespace
лежит, поэтому теперь мы по тегу однозначно понимаем, что мы собрались вызывать, и больше
нет вот этой резервации имен глобальной. Теперь имя одно зарезервировано. Какие вы видите
сразу недостатки в этой замечательной бильберде? Заклинание это один раз написали.
Ну да, если вы напишете некорректный тег-н-волк какой-нибудь у себя, то вы можете дров наломать
очень сильно. Это, конечно, печально. Как? Ну тег-н-волк, который принимает в ряде к пак чего угодно.
В смысле? Ты же никогда не пишешь тег-н-волк ничего? Ты пишешь френ-декларацию? Ну да, ладно, нет. Ну ты не
всегда пишешь френ-декларацию. Ты по идее должен всегда писать тег-декларацию. Ну френ-декларацию.
На практике иногда получается так. Ладно, другая проблема. Помнишь, когда мы из свопа делали точку
кастомизации, мы делали френ-да внутри какого-то класса. Тут на самом деле опущен еще дефолт. И вот этот
тег-н-волк ничего не находит, использует просто std-swap. А вот если он находит, то его заигрываем. И как мы
раньше делали? Мы звали своп неквалифицированно от двух аргументов. И ADL нам находил френ-декларацию в
том же namespace, что и аргументы. Вот тут тешки какие-то. Вот в их namespace будет найдена какая-нибудь
реализация свопа, которая кастомизирует поведение. Сейчас мы сядем это писать. Но тут есть даже без
написания. Ну ладно, я вижу, что тебе непонятно. Сейчас мы вернемся к этому. Здесь есть очень
очевидная проблема. Вот самой фундаментальной идеей, что раньше у нас было много зарезервированных имен,
и для каждого из них свое множество перегрузок. Теперь у нас одно зарезервированное имя и одно
большое множество перегрузок. Это все равно большая проблема, потому что там практика показала,
что библиотека или библиотеки, которые вот на это полагаются, они заметно дольше компилируются,
чем если бы там просто стоял вызов какого-нибудь метода. Поняли, о чем я? Нормально. Эрик Нибблер писал,
все нормально. Вот был overload set для begin, overload set для swap, overload set для end. Нам нужно было
только там искать, локально. Это было быстро. Теперь оно все в кучу слито в один overload set
для имени tag and walk. Теперь всю ее нужно обыскивать в поисках того, что подойдет под вот этот тег.
Это медленней. Вот такая техника может замедлить скорость компиляции вполне себе заметно. Вот,
есть ли у меня еще слайды? А так у меня есть же слайды. Так вот, как мы этот тег и вог будем
реализовывать. Вот какая-то фу, и мы захотели кастомизировать swap для фу. Написать кастомный
механизм свопа с другим фу. Мы напишем friendly definition прямо внутри фу, который принимает тип
свопа. Ну, вот это заклинание какое-то, да? Если внимательно наверх посмотреть, станет понятно.
Вот этот своп, это вот это вот, это объект. Вот этот объект, он пустой внутри. Это структура
без всего. Констекспоры, все дела. Вот эту структуру, своп, прям ее экземпляр, глобальный объект,
мы запихиваем вот в этот шаблон, берем ее тип и убираем констант и амперсант. Ну и получаем
просто, по сути, тип вот этой структуры анонимной. То есть структура-то анонимная,
но тип у нее есть. Вот это заклинание получает по цепошке ее тип. И вот ровно этот тип мы сюда
на вход принимаем. Поэтому тип вот этого звездочка здесь, он подойдет сюда. Вот эта вот перегрузка,
она нам теги совпадают. Ну и дальше просто принимаем наши аргументы свопа и делаем своп.
То есть вот ответ на твой вопрос, как мы это реализуем, а вот так. Вот код кастомизации,
вот код вызова. А Дэйль увидит, что у тебя здесь фу написано в сснд и найдет через вот
эту вот friend-definition в сопряженном наимспейсе. Некрасиво. Сюда иногда набрасываются делать
макросы, чтобы вот эту первую строчку friend-void-tag-and-voke-tag-test-swap автоматом генерирует. Но не знаю.
Да. Некоторые набрасываются и говорят, что это все вообще полная дичь. Надо это выкинуть к чертовой
бабушке и заменить на инструмент уровня языка. Добавить в плюсы новое ключевое слово, как,
например, static-virtual. А вот так вот. В глобальном наимспейсе пишете static-virtual и у вас вот это
компилятор генерирует за вас. А вот здесь пишете static-overwrite и у вас с автоматом теги,
теганвук, вся эта фигня генерируется. Опять же, здесь не нужен макрос, здесь можно сделать базу,
которая в шаблонном аргументе принимает тип и объект тега, и она будет подмешивать в ремна.
Можно. Много, можно по-разному извращаться. Но я считаю, что это все тлен, это полный тлен.
Ну, давайте так, вы помните еще, зачем все вот это мы придумываем, зачем эти точки кастомизации,
какие-то там звуки. Ну, как бы кажется, что да, а на самом деле нет, потому что есть execution,
замечательный пропузл, про то, что давайте в C++ наконец-то добавим, вот как на курсе у Липовского
рассказано, вот так и добавим. Но там столкнулись с проблемой. Мы хотим перфа, не хотим виртуальных
вызовов, не хотим никаких локаций на куче, поэтому мы не можем делать как Липовский,
потому что плюсы вообще-то еще на микроконтроллерах должны работать. А Рому интересуют исключительно
распределенные системы. Ну, на микроконтроллерах нету кучи, если вы не знали. Просто локаций на куче нету.
Кто? Виртуальный диспатчинг? Его можно сделать, но сами разработчики, которые пишут под микроконтроллеры,
боятся его как огня, потому что он непредсказуемый перформанс дает. Там типа кашмисы, вот это все,
оно сразу очень убивает. В общем, микроконтроллер – это то, что называется задача реального времени.
Вот у вас должна быть строгая гарантия, что ваша программа либо в ближайшие пять микросекунд даст
ответ, либо она скрашется и сигнализирует, что произошел сбой. Ну, где это используется,
угадайте. Что? Ну, в Huawei 5G действительно, но там не такая большая проблема. Вот роутер это,
роутер они не особо. Вот самолет, когда у вас летит, и там микроконтроллер, и вот он должен
либо прямо сейчас отработать, пять миллисекунд бюджет, больше нельзя, либо сообщить, что я сломался,
давайте на фолбэк на запасную систему или пусть пилот сам. Вот такого происходить как раз не
должно. Понимаете, о чем я? Не просто гарантия корректности, а гарантия времени отклика.
Нельзя зависнуть, нельзя долго слишком рассчитывать. Если вы марсоход какой-то
спускаете на Марс, то, что вы лишние несколько миллисекунд подумаете, может привести к тому,
что вы промахнетесь просто в тайминге, не в тот момент включили ускоритель, не туда полетели.
Все расчеты к чертовой бабушке. То есть они не могут себе позволить лейтензий так называемый,
задержку между приходом входа в микроконтроллер и откликом. В играх то же самое, кстати, не так
критично, но все равно, если у вас фризит игра периодически, то есть вы играете у вас как бы 60
фпс, но каждую секунду такой фриз типа. Сборщик мусора Джавы решил пособирать мусор, поэтому у вас
майнкрафт как бы 60 фпс, но фризит. Это неприемлемо. Вы сразу закройте такую игру и... Нет,
она обычно не раз в час происходит, а раз в секунду или несколько. Это уже типа не позволить... Ну вот,
вот прекрасная, прекрасная вещь. Вот такого как бы в играх недопустимо, а в микроконтроллерах,
на самолетах, марсоходах и прочем, вообще никаким образом, вот совершенно. Поэтому
не используются некоторые вещи, которые имеют непредсказуемую временную характеристику. Например,
куча. Вот на кучу вы что-то решили запустить, алоцировать, и вы не знаете, сколько времени это
займет. Возможно, у вас в вашем трейдлокальном кэше уже есть блок памяти подходящий, вы возьмете
это быстро. Возможно, вам придется идти в кэш на весь процесс того, что уже замаплено,
и доставать оттуда кусочек, то есть в локатор идти. Возможно, в локаторе тоже не хватает места,
и вам придется идти в операционную систему, мапить новый регион. Это непредсказуемое время работы,
поэтому никакой кучи на микроконтроллерах быть не может. Более того, у нас в играх тоже куча
отпиливается постоянно. Типа за кадр, а локации происходить вообще не должно за кадр игры,
в идеале. На практике, конечно, так не получается, но стараемся. Избегается от разными способами,
всякие кастомные локаторы аккуратненько сделаны и прочее-прочее, предлокация. На микроконтроллерах
заранее выбирают размеры буферов. То есть такая предлокация, но не на запуске, а в компайл-тайме.
Мы выбрали, что вот у нас килобайт памяти есть на микроконтроллере, вот от сих до сих будут лежать
вершины связанного списка, которые нам нужны для бизнес-задачи. Если их больше, крашимся и
репортим ошибку. Все, никакая куча не нужна, никаких локаторов хитрых, вы просто разметили
память и знаете, что где лежит. Вот, я, надеюсь, достаточно замотивировал, что такая штука,
как low latency, это вообще-то важно, и нам это нужно поддерживать. Поэтому наши прекрасные
библиотеки, вроде STD ranges и STD execution, они должны работать без виртуальных вызовов и без локаций
на куче. Виртуальные вызовы по той же причине могут быть там непредсказуемые по времени,
потому что непонятно, куда идет instruction pointer. Там может быть непрогрета кэш инструкция и тоже
там задержка, все плохо. Вот, поэтому весь ranges, если вы приглядитесь, он вообще-то работает без
динамических локаций. И то же самое в STD execution. И чтобы этого добиться, нам нужен очень мощный
статический полиморфизм. И вот для этого придумано все это, чтобы поддерживать статический полиморфизм,
независимо от того, что нам пригнали, в каком виде пригнали и так далее. Вот begin and swap в ranges есть,
но это как-то по-детски. А вот в execution там куча этих customization point object. Там есть сэнды всякие,
есть set value, set error, schedule. Так нет, еще connect. Нет, ну предполагается же, что некоторые люди все-таки
будут писать код, который инфраструктурный. И там куча, в общем, этих customization point,
которые нужны, чтобы очень аккуратно выбрать, как для вашего класса существующего сделать
какую-то синхронную операцию. Вот такая вещь. То есть они на самом деле хотели трейты, как в расте,
по сути. Только статические трейты из раста. Но у них их не было, поэтому они изобрели вот это.
Она работает примерно так же, если приглядеться. Ну и вообще Tag and Walk можно, не обязательно в
самом классе, вы его можете определить где угодно. То есть если у вас уже есть legacy class foo,
который трогать нельзя ни в коем случае, вы можете для него через Tag and Walk кастомизировать
поведение спокойно. Вот эта всякая расширяемость, что можно и сюда вписать, можно отдельно написать,
можно и так, и сяко, по пятому, по десятому. Вот за счет нее к такому механизму и привязались,
что можно как годно делать, и будет работать, и все довольны. Если правильно писать, то все будет
правильно находить. Да, ну вот проблема, чтобы это объяснить, нам понадобился примерно курс. Ну
тут конечно не вся информация курса посвящена этому. Тут много тонких деталей, которые нужно
понимать, и вот беды в общем. Давайте немножко приколов, которые можно через Tag and Walk сделать,
дополнительных. Ну смотрите какая штука. Вот это враппер какой-то поверх чего-то, что T, и у этого T
тоже как бы есть size. И вы хотите автоматически, чтобы ваш враппер начинал соблюдать контракт,
который соблюдает T. Ну и вы пишите Tag and Walk и пробрасываете size от враппера к size от T.
Прикольно, удобно. Это можно даже автоматизировать каким-нибудь macros или CRTP или еще чем-то таким.
Можно дальше пойти. Сейчас нужно сосредоточиться, вот это вот финальное усилие перед перерывом. Вот
тут мы просто size, cpo-шка size, пробросили ее к тому, что мы внутри хранили. Внутри была value,
мы к нему пробросили cpo-шку size. ОК? ОК. А тут шаблонный Tag and Walk, который принимает
любую cpo-шку и любую cpo-шку пробрасывает к value. Не инстанцируется. Нет, подожди, ADL это именно идет.
Вот ADL в том месте, вот в этом месте, где мы ADL-ем вызываем Tag and Walk, для вот этого класса враппер
вот эта штука найдется, вот этот шаблон функции. И он инстанцируется для той cpo-шки, с которой мы
вызвали все это дело. И любая cpo-шка, которую вы вызовете с враппером, она будет проброшена к
тому, что внутри лежит. Забавно, не правда ли? Но это как будто бы вы отнаследовали какой-то класс и
автоматом зауверрайдили все его методы, но при этом как бы скрыли его. Ладно, в ОП, наверное,
такого эффекта космически очень легко добиться. А здесь, ну, по-моему, это смешно. Мы просто
форвардим все cpo-шки, все вызовы к нам, к тому, кто внутри нас лежит. Ну, вообще, надо вот так
написать, да. Все еще неправильно, конечно. Тут не хватает очень много чего. Тут нужно написать еще
дополнительные аргументы, форварды написать, декл-тайп от авто. Вот, ну, вот это тут появилось
по сравнению с прошлым слайдом, тег инвокабл. Вот это сделано здесь чисто для того, чтобы у нас...
Ну, не только. Короче, вы же помните, что у нас набирается множество перегрузок, если сигнатуры...
Да, множество перегрузок набирается, в нем есть функции, есть шаблоны функций. Шаблоны функций
инстанцируются. Если инстанциация declaration функции произошла успешно, то все, эта функция
подходит, и мы ее дальше несем, и начинаем их перебирать, кто подойдет. Так вот, если вот этого
не написать, может так выйти, что вот эта функция нам, в принципе, подходит. Потому что здесь, что, никаких
проблем скомпилировать вот эту вот строчку первую, то есть декларацию, ее скомпилировать для любого
типа, проблемы нет. Вот. Ну и выбор перегрузки может выбрать вот эту вот функцию и сказать,
она мне подходит. Но на самом деле вот эта строчка не скомпилируется. И вот чтобы, так как бы на шаг
раньше еще на выборе перегрузки запретить вызывать вот эту функцию, если у нас на самом деле не
компилируется вызов этого тега для нашего value, вот такую штуку хорошо бы написать. Во-первых,
во-вторых, раньше ошибку получаешь, в некоторых случаях это кажется может повлиять на семантику,
не обязательно. Не обязательно повлиять на семантику, потому что у тебя будет, ну, допустим, у нас у
T, T не tag-invocable, тогда у нас wrapper от T будет tag-invocable, если мы пишем код буквально if constexpr
tag-invocable, тогда tag-invocable. Вот, да. Тогда мы будем получать CE вместо корректного выведения. Вот, да,
замечательный пример. Понял ли ты его? Ну, tag-invocable проверяет, что вот такая строчка компилируется.
Теперь представь, ты где-то в стороне в коде написал вот такую штуку, у тебя есть, и ты в коде
где-то написал в шаблонной функции if constexpr tag-invocable wrapper от T какого-то, тогда делай одно,
иначе делай другое. Так получилось, что тебе такой код понадобилось написать. Этот код всегда
true тебе даст. Вот тут tag-invocable всегда будет true для вот этого wrapper, независимо от того,
какую CPO укажешь. Это странно. Ну, потому что здесь ничто не запретит вот эту декларацию вызвать,
а вот то, что в теле где-то что-то не скомпилируется, как бы requires это не умеют проверять.
Я подобные проблемы встречал в примере, когда мы пишем какой-то шаблонный код, в котором мы
хотим сравнивать объекты. Ну, хотим, если они допускают сравнение, и мы пишем что-то в духе if
constexpr equality comparable, мы их сравним, если нет, мы делаем какой-то fallback. Вот, и если ты в такой
шаблонный код передашь std vector, то у тебя он будет всегда пытаться сравнить, потому что в std vector
написано requires. Если ты передашь туда std vector от чего-то, что ты не умеешь сравнивать, ты
будешь получать шип вместо fallback. Хороший пример. Стало понятнее или стоит написать это? Да или
нет? Понятно. Окей, то есть вот это вот запрещает нам на этапе выбора перегрузки вызывать вот эту
штуку, если на самом деле тело не скомпилируется. Почему это надо? Чтобы if constexpr tag-and-vowel для
всего врапера работал корректно и не врал. Мы такое уже, кажется, видели несколько раз, просто надо
в голове это связать. У вектора вот оператор копирования, например, он тоже такой, у него не хватает
requires. То есть если ты сделаешь if constexpr std copyable vector, это всегда true, даже если это вектор
unique pointers. Немножко странно, что is copyable для вектора unique pointers возвращает true. Как этот
вектор unique pointers будешь копировать. А в том-то и дело, что никак. Is copyable тебе вернет true,
но при этом, при попытке скопировать вектор, у тебя вылетит ошибка компиляции. Чтобы вот этой
лажа не происходило, нужно requires писать аккуратно. Вот. Раньше нужно было писать этот свиная,
теперь забыли про него. Кстати, кто в домашней пишет свиная? Вы здесь? Что-то люди... Да,
потому что я и тут распинаюсь, объясняю, как теперь легко и приятно писать код.
Сколько они как болтовая свиная пишут? Они enable if пишут или они тестеры пишут? Одна перекрузка проверяет...
Нет, ну дами аргумент равно enable if, классический этот свиная.
Черт. Вот еще почему-то оператор spaceship не все использовали, я не знаю. Вот это вот как бы кололись,
мыши плакали, кровью стекали, но как-то сжать не переставали. Шесть операторов сравнения. Ну зачем?
Не надо так. Вот все так. Это кажется все у нас. Ребят, не шептаться. Важные вещи говорю. Перерыв.
Чуть-чуть поговорю еще про вот эту муть невнятную, да, и дальше мы перейдем к вопросу домашек. Так вот
про муть невнятную. Тыгнвук можно сделать так в коде, чтобы он у вас был как некая библиотека. Во-первых,
во-первых, вот разные цпо делать и внутри них дергать одно и то же имя. Так как бы можно делать,
но на самом деле нужно ли? Вот авторы пропузла, которые вот это все втаскивает, предлагают делать не
так. Они предлагают сделать ровно одну цпошку, которая сама называется тегнвук, одну единственную,
и через нее дальше все пропускать. То есть вот этот код вам приблизительно уже должен быть знаком,
что вот тип, вот функциональный объект цпо, внутри этого типа в операторе круглые скобки мы принимаем
другую цпо и аргументы и тупо через одл вызываем вот это вот. Ну то есть можно было по-другому
сделать. Они решили так. Про inline namespace. Вот такая малюсенькая деталь, ничто наважная,
но вот Аркадий нам подсказывает, что просто вот так написать в нашем каком-то namespace MPC,
ну представьте, что это STD. Просто так в нем написать такой объект плохо, потому что,
коль скоро в этом namespace будет класс с friend, с таким же названием, нам скажут 3D definition.
Почему это так работает? Ну бог его знает. Ну как бы да, а вот если написать так,
то оно внезапно все работает и понимает, что вот эта цпошка ее надо звать, а вот эта вот
кастомизация. Ну вот, то есть по сути вся механика Tag & Walk, она вот эти строчки. Вот просто вот это,
ну еще вот тут всякие дополнительные вспомогательные, tag-tag, который я вам показывал,
сейчас увидим как он используется. Tag & Walk был концепт, но он тоже простой, что можно позвать
Tag & Walk от аргументов. Ну и в принципе все, какие-то резалты, еще что-то, не важно. Давайте посмотрим
на адекватное более-менее применение всего этого. Делается структура with the, ну вернее еще одна цпошка.
Внутри этой цпошки делается, как обычно, оператор круглой скобки и зовется уже Tag & Walk из namespace.
Вот зачем, непонятно. Можно было прямо сюда вписать ADL, но решили для безопасности сделать,
чтобы этот ADL, видимо для безопасности, всегда из одного и того же контекста происходил,
где еще к тому же вписали вот эту штуку. Возможно лучше. Черт ногу сломит. Вот это вот,
насколько я понимаю, это архаизма, его здесь уже не должно быть, мы вот говорили. Мы про это же
говорили и вроде как пришли к выводу, что не нужно уже. В общем, неважно. То есть дизайн такой. В
коде, который был у меня на слайдах, было вот так. Суть это не меняет. Можно вот так. И значит
заведена какая-то цпошка для ширины фигуры, для высоты фигуры. Она принимает только одну фигуру,
и та и другая, и возвращает float, но еще площадь заведена. Причем тут забавно, в каждой вот этой
вот цепошке еще некоторый type rest signature написан. Догадайтесь, в чем суть? Абсолютно не очевидно.
Вот если сравнить сигнатуру вот этого оператора круглые скобки и вот этой штуки, в чем связь?
Да, Юрка, не знаешь. Кто-нибудь еще скажите что-нибудь. Ну типа того. Ну как бы эта цепошка,
она создана, предназначена для того, чтобы взываться на одном объекте. Вот эта вот ширина,
она принимает ровно один объект. Этот объект, он в каком-то смысле this. И вот эта сигнатура,
она повторяет сигнатуру оператора круглой скобки, но заменив вот этот вот текущий объект на
некоторый тип this, который, ну, пустая структурка, ничего не делающая. Зачем это нужно? Увидим чуть
ниже. Ну вот как-то так получается, что у нас есть width, height, area, ну, прекрасно есть. А еще
scale by некоторый. Вот здесь, здесь не написано. Ну ладно. Давайте квадрат посмотрим. В квадрате
прекрасно сделаны friend definition и tag invoke, который будет height, в ответ на оба этих запроса возвращает
просто size. Ну и area там считает и scale by некоторый. Scale by к нему сейчас попозже вернемся.
Интересно, здесь вот что. Здесь есть концепт shape, который комбинирует в себе несколько
CPO. Это вам должно какой-то концепт напомнить? Cenery нет. Ну, range. В концепте range было написано
примерно то же самое. Copyable и там begin end определенно, где begin end это тоже CPO. Ну и здесь
также. Окей. И это, и это все неважно. Дальше есть некоторый волшебный any shape. И вот это вот
один из таких сочных моментов того, что позволяет делать технология теганвоков и CPO. Ну нет и нет,
чего бухтеть. Теперь есть. Мы писали с вами type erasure контейнеры. И тогда я немножко так
анонсировал, что можно обобщенный type erasure контейнер написать. Собственно, это он. Вы указываете
этому type erasure контейнеру список CPO, и он все их стирает в Vtable. Вот это ближайший аналог,
который мы можем в плюсах получить к трейтам из растов этих ваших. Потому что концепт shape,
который где он, это статический трейд. Вот если вы функцию принимаете по концепту что-то,
то функция автоматом шаблон, происходит мономерфизация, статический трейд. А вот
этот вот any object или any shape из него получающийся, это как раз динамический трейд. Потому что если
вы принимаете по any object функцию, то у вас там type erasure происходит, Vtable и динамическая
диспетчеризация. Единственная интересная деталь, которую здесь еще можно осветить,
это вот этот прекрасный метод scale by. Не знаю, наверное это будет забава для тех из вас,
кто еще не отлетел. Метод scale by должен вернуть такой же тип, как и текущий тип. Вот как бы
реализация scale by для square, и он принимает на вход square и некоторое ratio. И на выход
должен дать square. Так вот вопрос смешной. А как вот этому прекрасному any object понять,
какую сигнатуру делать? Потому что до сих пор мы как бы делали type erasure, когда сигнатура была
какая-то простая более-менее. А тут она как бы зависимая. У вас даже возвращаемый тип зависит
от того, на чем вы вызываете. Ну и вот здесь начинаются как раз вот эти приколы с this,
что надо как-то исхищлиться. Ну вообще у any object в итоге у самого должен быть метод any
shape, scale by. В этом смысл. Вот эти CPO-шки стерли, и у object у самого появилась возможность вызывать
CPO-шки. Но при этом, если вы вызовете у any object scale by, что вам должны вернуть? Ну вот scale
by у квадрата возвращает квадрат, у круга возвращает круг. Ну и вот единственный выбор — это действительно,
что должны вернуть any shape. И тут происходят некоторые трюки, что мы говорим, что у scale by
там два параметра. Именно первый из них, а не второй. Мы стираем у него type, и это будет произвольный
как бы аргумент this, а второй ну просто float. А возвращаемое значение внезапно оно будет any
object. То есть мы как бы стираем одну CPO-шку, но с другой сигнатурой, сделав каст по дороге. И вот так
тоже можно. Я искренне надеюсь, что хоть один человек, ну Аркадий точно понял, да? Ну еще хотя
бы один человек это понял. Если кому-то интересно в это углубиться, в то как написать трейты из
раста в плюсах без как бы зеркал и дыма, по-честному, можете углубиться самостоятельно в это,
соответственно для этого у нас есть any object. Вот это вот статья, которую я вам уже показывал. Здесь
подробно объясняют все проблемы реализацию, вот эти вот все трюки со scale by. Ровно отсюда код
взят, но с нуля написан. И да, если вы захотите пройти такой же путь, как Аркадий, можете
самостоятельно, а на этом я пожалуй завершу вот эту вот бодягу. Я искренне надеюсь, что этот стандарт
не добавят, а вместо этого сделают языковую поддержку, чтобы было без вот этой черной магии
и там ADL и прочего, и это можно было объяснить первокурснику хоть как-то. Вот и да, на этой
замечательной ноте я предлагаю закончить запись и перейти к вопросу домашних.
Реализация есть. Можно прям полностью посмотреть на итог.
Ну, короче, вот у них есть тот самый any object, вот ему передается коллекция цепошек и дальше
пошли там какие-то типа 300 строк. Вроде как не очень сложно, но там еще много инклюдов и да.
У меня тоже где-то в 300 строк.
Звучит крайне увлекательно, никому не рекомендую.
Не знаю, потому что в прошлом году, вот год назад мы сидели и вот оставшийся там час вот это все
аккуратно трепетно писали, вот ну в итоге отлетели опять все кроме одного или двух человек. Я считаю,
что на этот раз мы не будем на это тратить время, потому что выхлоп нулевой, если кому-то интересно,
вы можете самостоятельно почитать. Большинству из вас, скорее всего, это вот точно не понадобится
никогда. Стандарт пусть завезут, вот такой уже готовый инструмент и все. В репозитории, по-моему,
тоже есть. Я не уверен, работает ли она, по-моему, все-таки мы добили, оно работало в прошлом году.
Вот все, давайте. Такие вопросы, Аркадий, не задавай. Ну сломалось, ну бывает. Вот все,
для онлайн зрителей пока, а мы с вами продолжаем.
