Редкие случаи, начинаем с 9.00, может уже 9.01, но не
важно.
Что у нас с прошлого раза осталось?
В прошлый раз мы обсуждали дерево Фенрика.
Сегодня нам даже не особо пригодится то, что такое
дерево Фенрика, в смысле как оно внутри устроено.
Начнем мы с задачи, с точки зрения которой Фенрика
можно рассматривать как черный ящик.
То есть представим себе, что у нас есть какой-то
массив, как всегда, массив А, и есть черный ящик, который
хранит в себе этот массив и умеет делать запросы.
Допустим, прибавить число D в позиции поз и найти сумму
на отрезке.
В принципе, здесь может быть дерево Фенрика, здесь
может быть дерево отрезков с операциями снизу, что
угодно.
И вот у нас возникает такая естественная задача,
после всяких операций с прибавлением на отрезке,
то есть после всяких массовых операций возникает естественная
задача.
А если я хочу в этот суровый список добавить операцию,
прибавить на подотрески?
Ну, кто-то, конечно, да, понятно, что всякими нашими деревьями
в огромных количествах это делается, как и просто
деревом отрезков с проталкиваемыми операциями.
Но оказывается, что необходимости писать эту какую-то страшную
рекурсивную для кого-то может быть гадость, на самом
деле нет.
Потому что есть очень красивый прием, который позволит
вам делать это и деревом отрезков снизу, и даже деревом
Фенрика.
Но как же это будет делаться?
Ну, для этого мы когда-то, чтобы это понять, немножко
придется разомнуться и кое-что воспомнить.
Вот давайте начнем с того, что у нас с вами есть.
Вот представим себе, что у нас есть операция только
сумм.
Вот давайте вспомним.
У нас есть вот такая задача, статик РСКУ, да, то есть
что это такое?
Это означает, что у вас есть дан массив, он не меняется,
вам все, что нужно, это уметь находить сумму на подотреске.
Как это делать?
Да, у нас есть действительно мистический метод, префиксные
суммы.
То есть, так сказать, по массиву А мы можем построить,
там так сказать, массив ПА.
Это будет называться у нас там префиксные суммы.
То есть, ну, просто буквально сумму на префиксах насчитаем,
и тогда мы скажем, что сумма на любом подотреске это
сумма на префиксе минус сумма на префиксе.
На всякий случай скажу, что сейчас у нас никакой
абстракции нет, сейчас мы работаем именно с числами
и сложением.
Ну или если вы хотите абстракции, то мы работаем, то есть
мы работаем с ассоциативными, коммутативными, обратимыми
операциями.
Ну, может так кому-то больше нравится, я не знаю.
Но давайте еще пометим, что по префиксным функциям
можно однозначно восстановить и сам массив А.
Так мы это будем называть, ну, как бы, будем называть
разности соседних.
Хотя иногда у меня будет, я думаю, там прорываться
словосочетание типа частичные разности.
Ну, как типа, это частичная сумма, это частичные разности.
Логично.
Вот.
Так что, в принципе, такие взаимообратные операции.
Вот.
И так статическое РСК делается просто, но попробуем усилить
задачу.
Ну, так усилить и, правда, одновременно ослабить.
Вот представим себе теперь, что у нас есть такая задача,
что тоже дан массив А и хочется на этот раз сделать две
операции.
Во-первых, операцию Get, то есть редкий случай, надо
не сумму на отрезке найти, а получить конкретный
элемент.
Но при этом хочется прибавлять на отрезки.
Нет, вот тут я, пожалуй, красненьким воспользуюсь.
Так, вот смотрите, то есть теперь наоборот, не сумма
на отрезке изменения в точке, а наоборот значение в точке
и изменение на подотреске.
Ну, давайте какая-то вопрос, как же это сделать.
А ну-ка, давайте на уровне соцопроса, а кто, в принципе,
просто знает, как это сделать?
Ага.
Так.
Практически все.
Так, а кто знает, как это сделать без использования
каких-нибудь там деревьев, отрезков прибавляй там
страшных, с прибавлением на отрезки имеется в
виду.
Так, ну хорошо, давайте, каким же способом это сделать?
Ну вот.
Ну да.
Словом, сканлайн тут лучше не ругаться.
Нет, ну сканлайн подразумевает все-таки, что мы тут делаем
один проход, какой-то офлайновый запрос, давайте лучше не
надо.
А вот разности соседних тут действительно очень
сильно выручают.
Давайте посмотрим.
То есть действительно есть у нас, допустим, есть массив
А, в котором есть числа, допустим, 5, 7, 2, 4, 8, 0.
Там, я не знаю, 9, 3.
Нет, побольше надо.
Там давайте что-нибудь еще добавим туда.
6, 2, 5, 4, 8.
Вот.
И действительно, если мы хотим взять какой-нибудь
вот такой там, какой-нибудь вот такой вот подотрезок
и сказать, давайте прибавим к нему, к каждому этому элементу
прибавим, ну я не знаю, 57.
Ну что еще, действительно.
Вот.
Тогда, чтобы правильно модифицировать массив А, мы
действительно должны прибавить, там сделать везде плюс
57, плюс 57, плюс 57, плюс 57 и плюс 57.
Но, а теперь что делать, если мы вместо этого возьмем
вот массив ДА, который будет префиксными разностями.
Вот.
То есть давайте я тут даже, чтобы было понятнее,
я в явном виде могу даже нарисовать.
Минус 1, 4, минус 3, 2.
Нет, не совсем точно.
Так, нет, давайте так сделаем.
Так, вот так вот.
Значит, минус, значит, тут будет минус 1, тут будет
4, тут будет минус 3, тут будет 2, тут будет минус 5, тут
будет 2, тут будет 4, тут будет минус 8, тут 9, тут будет
минус 6.
Как от этого прибавления изменится массив?
Вот изменится массив частично, там вот этих вот разностей
соседних.
Но оказывается, что изменится он ровно в двух точках.
Потому что вот эта разность увеличится на 57 и вот эта
разность, следующая за окончанием отрезка, уменьшится
на 57.
Ну как легко убедиться, больше никакая разность не
изменится никак.
Видно, да?
Да.
Вот тут мы, кстати, воспользовались коммутативностью, обратите
внимание.
Что можно взять два числа.
И оказывается, что если к одному из них прибавить
57 и к другому прибавить 57, то у них разность не поменяется.
Вот.
То есть мало того, что обратимость, так еще и коммутативность
тут нам потребовалась.
Вот.
Но тогда это означает, что никаких там суперэкзотических
массовых операций нам писать не надо.
Да?
Ни в коем образом.
Но вот вместо этого нужно написать, взять просто
хранив вместо массива А массив разности соседних
и храним на нем можем хранить абсолютно обычное дерево
Фенвика.
Ну правда, да, говоримся, что как сделать вот операцию
GetPos.
Но GetPos, то есть на самом деле каждый элемент в массиве
А это просто сумма на префиксе в массиве А.
Думают, понятно, да?
Да.
Вот.
Так что получается, что изобретать ничего не надо,
то есть надо писать абсолютно того же Фенвика и просто
чуть-чуть пошаманить с разностью соседних.
Вот.
Ну а если там прибавить на подотрески, требуется
что-то.
Но это, правда, надо писать от ELR, конечно, X какой-нибудь,
чтобы красиво было.
Это получается так.
Очень удобно.
То есть в принципе тоже вот такой вот стандартный
метод есть.
Вот.
Ну а теперь возникает естественный момент.
А что же делать, если мы хотим и сумму на подотреске,
и прибавлять на подотрески?
Ну первая идея действительно тоже понятна.
Наверное, хотелось бы, конечно, работать не с массивом
А, а с массивом dA.
Он как-то очень удобно меняется.
Но ведь сумма как-то странно меняется.
Ну давайте посмотрим.
Но для этого давайте посмотрим как.
Ну для этого нам достаточно посмотреть вот на что.
Так.
Ну во-первых, заметим, что сумму на подотреске можно
легко свести, как всегда, к сумме на префексе.
Логично, да?
Вот.
Вот давайте сведем.
Вот давайте скажем, что сумма.
Вот давайте сейчас я честно скажу, мне сейчас будет очень
удобно сказать, что массив у нас в один индексации.
Вот.
Так вот.
Значит сумма от LR, она равна, на самом деле, как известно,
сумма от 1R минус сумма от 1L минус 1.
Ну не минус, а вот.
Поэтому остается только найти сумму на, научиться
искать сумму на префексе.
Но для этого давайте немножко позанимаемся алкеброй.
Что такое сумма на префексе?
Сумма от 1R.
Это что такое?
По определению, это сумма по всем I от 1 до R.
А это я просто написал определение.
А теперь давайте попробуем подменить массив A на префекс
на вот эти вот разности.
Получится примерно следующее.
Чего?
Спокойно.
Ой, Господи.
Спокойно, да.
Как-то знаете, вот у нас на химии был закон.
Не все, да.
Как бы на химии был закон.
Не любая реакция, которую вы напишите на бумажке работы.
Проверьте, значит так.
Не всякое умное словосочетание, которое вы скажете, будет
иметь отношение к делу.
Осторожно.
К сожалению, да.
Ну вот.
То есть на самом деле вот.
То есть вот такую двойную сумму надо на самом деле найти.
А теперь давайте немножко переставимся.
То есть на самом деле.
То есть теперь заметим, что на самом деле мы суммируем
dA gt.
Просто каждое dA я беру в этой сумме сколько-то раз.
Вот.
То есть я могу так и написать, что эта сумма по всем g
от 1 до R dA gt умножить на.
А скажите мне, что?
R минус g плюс 1.
Да, конечно.
Разумеется.
Или даже R плюс 1 минус g.
Ну, впрочем, тут.
Кому как.
Вот.
Да.
R плюс 1 минус g.
Что?
Вопрос?
Если вопрос, лучше задавайте сразу.
Не было.
Ну, вдвоем исполняем.
У меня тут как бы не от этого зависит.
У меня было бы то же самое.
Только у меня тут нет единицы от нуля было.
Так что.
Ничего.
Ну, вот.
Хотя.
Не хотя.
Не-не-не.
R плюс 1.
Ой.
Там ничего бы.
Может даже R плюс 2.
Так что нет.
Тут дело не в этом.
Вот если бы тут сумму делали с полуинтервалами, тогда
да.
Тогда у нас действительно был шанс избавиться от плюс
минус единички.
Но.
Ну, скажем так.
Это уже такое.
То есть, честно скажу.
На мой вкус это скорее уже такое дело привычки.
Вот.
То есть, в конце концов, мы дерево полуинтервалов,
по-моему, деревом полуинтервалов с вами особо не баловались.
Поэтому, собственно, там за это не цепляемся.
Вот.
Впрочем, если вы на экзамене выведете это через полуинтервалы,
в общем-то, никто, естественно, не расстроится.
Собственно, так.
Как вам мог.
Так.
Но давайте.
Тут идея, в общем-то, не в этом.
Идея в том, что давайте это чуть-чуть вот еще можем
переписать.
Это можно переписать в следующем виде.
R плюс 1 на сумму.
Вот такую.
И минус сумма.
Вот такая.
Умножить на dA жид.
Вот такая радость.
Но, в принципе, заметьте, что вот эта сумма это уже
говорит нам о том, что мы могли бы, как и ранее,
в мощного сиве dA забабахать обычного фенвика.
И, собственно, эту сумму легко находить.
Вот.
Но этот просто фенвик нам на халяву не даст возможности
находить вот эту сумму.
Тут же каждый элемент еще надо что-то домножать.
Но тут все достаточно просто.
Мы вводим массив, который будем называть, давайте
сразу это поймем, dA жид.
Ну скажите так, это просто A.
Но другая фишка, идея у нас будет заключаться в том,
что мы же массив А-то не храним...
Да, мы же не хотим его хранить, потому
что А-то такой изменяется слишком сильно.
Поэтому мы хотим хранить массив.
Хотели хранить массив, чтобы он изменялся только
в двух точках.
Но, правда, теперь на для того, чтобы искать этот
сумму мы заведем массив dA ж, где мы просто объявим
официальное определение.
Просто это официальное определение dA ж.
dA жид.
Это просто dA на ж умножить на ж.
Просто вот официальное определение такое.
к чему это нас приводит приводит нас к это то есть вот прям вот в явном виде сейчас эту
прям вот в наглую так и напишу там 6 то есть потом будет минус 8 до ячеечки маленькие какие-то тут
оказывается до 9 минус 4 20 ой ну да как это но великому эмиру быстро на скучило считать он
позвал мудрецов и они стали считать сами соответственно те что тут у нас 40 минус 88
о 9 на 12 сколько будет браво так и так а ну 6 на 13 это уже да так да что-то не так страшно все
оказалось так но в результате но теперь заметим что этого дрожи тоже прятавшийся массив да меняется
в двух точках то и массив дрожи меняется всего лишь в двух точках то здесь правда будет 57 умножить
на 4 там вычислять не буду вот значит так ладно только не на 4 она 5 конечно там 5 6 7 8 9 10 и тут
11 и тут получается минус 57 умножить на 11 вот тоже оказывается очень удобно вот то есть в
принципе то есть давайте вот чтобы совсем красиво еще вот сделаю казалось бы лишнюю строчку то есть
теперь я свел задачу к поиску на префексе на даже минус сумму на префексе да а жи житых вот
такая красота то есть мы просто храним два вот таких массива и храним два массива если но вот
каждому из них забабахиваем фенвико и вот делаем и если нам приходит запрос там сумма
наотрески мы находим просто ну что мы делаем то есть если нам приходит сумма наотреске мы
вызываем две функции поиска суммы на префексе каждый из которых сводится к двум запросам на
префексе по одному в каждый массив видно и того но вот а если нам приходит запрос прибавить на
на отрезке, то тогда мы просто делаем по две операции
изменения в точке, в массиве dA и в массиве dAj.
В общем, оказалось очень удобно, в общем-то ничего
тут такого сильно умного-то и нет.
Вот, но видите, что есть эта технология, что приятно
в этой технологии?
В этой технологии приятно то, что она вообще никак
не зависит от того, как конкретно вы делаете вот
это изменение в точке.
То есть в этом месте можно делать как дерево фенлика,
так и дерево отрезков с изменением в точке, которое
снизу.
Так что если вы там случайно, если случайно оказалось,
что вы забыли, как делается прибавление на подотрезке,
то есть там вот массовые операции, то есть для вас
это какая-то сложная штука или вы там просто надух
не переносите рекурсию, то собственно вот на самом
деле вот такой лайфхак вам вполне себе может быть
актуален.
Вот.
Кажется, это уже не сильно лучше, чем дерево отрезков.
Ну.
Потому что два памяти, два запроса.
Нет, ну, скажем вот.
Нет, ну так, нет, ну как сказать, нет, ну лучше, нет, преимущество
тут конечно будет скорее за счет того, что тут нет
рекурсии разве что.
Да.
То есть, нет, смотрите, нет, преимущества тут такие,
да, что, что, как бы тут нет рекурсии, то есть, скорее
всего, вы по константе выиграете.
Хоть, конечно, недостаток есть в том, что это работает
конкретно для прибавления на отрезки и суммы на отрезки.
То есть, малейшая другая операция, то тут наши полномочия
уже все, соответственно.
Ну, да, да, да, да, да, да, ассоциативная, коммутативная,
обратимая операция, пожалуйста.
Хоть сумма матрицы.
Да.
Нет, а вот с умножением матрицу будет больно.
А, нет, умножение, да, умно, скажи так, умно, формально
скажем, давайте умножение не нулевых чисел тогда.
Или, да, умножение не нулевых остатков по простому модулю,
да.
Или умножение по непростому модулю взаимно простых
с модулем остатков.
Да, пожалуйста, там сколько?
Ладно.
Да, да, да, да, да, с ксором тут красота, конечно.
Да, ну, с ксором, да, ксор вообще приятен тем, что у него
вычастие, вычастие прибавить это одно и то же.
Да, но это уже там, да, совсем другое.
Но, впрочем, у этой штуки есть неожиданно, но, впрочем,
с другой стороны, у этой штуки, у этой идеи есть, на
самом деле, еще одно неожиданное преимущество.
Сейчас мы отправимся в граммире и неожиданно выяснится,
что, забегая вперед, что эта идея там работает,
а отложенной операции нет.
Чего?
В многомерии.
Ну ладно, не сильно многомерия.
Давайте начнем с простого, начнем с двумерии.
Вот.
Да, потому что, действительно, да, потому что давайте это,
значит, мы ликвидируем все это безобразие.
Ну есть тут никаких вопросов нет, конечно.
Ну вроде, ну да, тут вроде, да, для вас уже, то есть,
да, никакой, там, для вас уже никакой сложности нет.
Да, вы уже, все-таки да, вы уже, как это да.
ЕГЭ по математике вы сдали, поэтому там вот это вот вас
пугать не должно.
Не, просто иногда, там просто, когда-то, когда-то, иногда
девятьклассникам это там объясняешь или восьмиклассникам,
то, на самом деле, у кого-то там, вот эти вот абстрактные
записи могут мозг взорвать иногда.
Ну вот, но это нет, все зависит от того, просто, как бы,
насколько вы привыкли к такому абстрактному мышлению
и подобного рода записям.
То есть, как бы, я думаю, да, понятно, что на вашем
уровне, конечно, никаких проблем уже нет.
Вот, впрочем, да, к сожалению, я уже, да, как бы, да, я уже,
я уже забыл спросить, в принципе, кто, в принципе,
это там знал и ранее.
Вот, но не важно.
Так.
И так, смотрите.
Вот так вот, вот так вот.
Все.
И так, на многомере.
Значит, значит так, то есть, хотим порешать задачу
какую-нибудь такое двумерное РСК.
Значит, что это означает?
Это означает, что массив А у нас неожиданно стал двумерным.
Вот давайте я буду...
Ну, то есть, вот давайте...
То есть, тут я обычно...
Ну, тут у меня обычно Х, а тут обычно И.
Вот.
Тоже как всегда.
Тут от одного до Н, тут от одного до М.
Вот.
Тут какие-то у нас чиселки стоят.
Вот.
Ну, чиселки Дашу.
Как это называется?
Принцип действия бенитовой палочки.
Жутко смешное словосочетание.
Но каждого смешит свое слово.
Так.
Ну, вот давайте тут что-нибудь веселое.
Так, 6.
А впрочем...
Ладно, я могу чуть позже прописать,
пока это не сильно принципиально.
Значит, я на таком массиве хочу сделать следующие операции.
Ну, как сказать?
Ну, на самом деле, по-разному.
Разные бывают ограничения.
Ну, в идеале, конечно, хотелось бы Н умножить на М,
не превосходит 10 в какую-нибудь.
Ну, хотя бы в шестой.
Ладно.
Давайте...
Ну, там...
Ну, по ситуации, на самом деле.
Ну, посмотрим.
Давайте, ладно.
Для нас, скажем, для простоты 10 в пятой.
Там бесконечно долго можно думать.
Это там бесконечное число модификаций.
Значит, все вообще хочется делать.
Так.
Ну, вообще, конечно, хочется, как всегда.
То есть, в идеале.
То есть, хочется, конечно же, искать...
...сумму на подпрямоугольнике.
То есть, ну, как так говорят?
На подпрямоугольнике, сумму сторон,
которого параллельно осям координат.
Что важно.
А то именно вот.
Нет, это была бы, конечно, отдельная песня.
Если у вас есть задача, называется дан...
Рандомно повернутый прямоугольник,
пожалуйста, найдите сумму всех чисел,
которые туда попали.
В том или ином смысле.
Да и да.
Не обязательно.
Нет, можно там считать, что на самом деле
это такая...
То есть, на самом деле тут
как бы такая решетка целочисленная.
И там в узлах записаны числа.
Возьмите все целые точки, которые попали в прямоугольник
и числа на них.
Чего?
Вряд ли.
Ну, как сказать?
Нет, скажи так.
Слету не знаю, потому что, честно говоря,
у меня просто ассоциация из головы.
То есть, я это сказал, чтобы подчекнуть,
какую задачу мы решаем, а какую мы не решаем.
Да.
Сейчас вы, конечно, развлекаться можно там
как угодно.
Итак, сумма на подпрямоугольнике.
Как же такую задачу решать?
Ну, на самом деле так.
Вот давайте пока предположим, что мы не меняем ничего.
Тогда...
Ну, если делать это в тупую,
то можно сделать...
То есть, если взять это просто на массиве,
а честно эту сумму искать,
то что у нас получится?
То получится у нас просто тупой поиск суммы
за, в худшем случае, отнм.
Соответственно.
Так, вот давайте...
Ну, ладно, давайте, наверное,
поменьше это нарисуем.
Вот так вот мы,
пожалуй, сделаем.
Ну, как бы, я думаю,
на первый раз нам вот этого хватит
с запасом.
2, 3, 4, 8, 6,
5, 5, 2, 5,
6, 5, 5,
5, 5, 5, 3.
Ну, знаете, телефончик этот, да?
Ну, это классика.
Такси нежданчик, да?
Да, типа да.
Типа, спонсор выступления, такси нежданчик,
такси нежданчик, 8, 8, 8, 8, 3.
Ну, вот это вот.
Ладно, вот.
Вот.
Значит, соответственно.
Итак, вот.
Если бы у нас был массив такой,
и мы бы искали сумму какую-нибудь...
Ну, вот, ладно, допустим.
Если бы у нас...
Ну, ладно, квадратненькую такую сумму бы искали,
допустим.
Ну, вот, то, конечно, бегали бы
прямо честно по площади этого
прямоугольника.
Но что у нас есть?
Ну, вот.
Ну, можно завести
и найти массив.
Ну, вот, то заметим, что в каждом ряду
мы, в принципе, можем завести
префиксные суммы.
То есть это мы будем называть...
Ладно.
По-другому. D, X, A.
Ну, ладно, вру.
P, X, A. Вот так.
Это будем говорить о том, что
что по X
мы взяли префиксные суммы.
Ну, вот. Хотя ладно.
Может быть, там еще придется подумать
на тему того, как это...
Что у нас тут?
Давайте по каждому ряду...
Ну да, по каждому ряду
честно находим префиксные суммы.
Прям вот, предельно, предельно, предельно.
Честно, 25, 29.
Да, там на монтаже, наверное,
можно это промотать под
балалайчику, там, как всегда.
Нет, ну, правда, ладно.
Нет, там просто, знаете...
А кто-нибудь видел видео лекции
Павла Маврина, кстати?
Ну, да.
Да, это прикольно.
На самом деле. Нет, ну, можно там что-нибудь еще
вместо балалайки.
Но, в принципе, шутка прикольная.
Вот.
Ну, вот, соответственно, значит...
Да.
Значит, 5, 10, 15,
там, 20, 25 и
28.
Вот.
Ну, теперь замечаем,
что на самом деле, теперь, чтобы в таком массиве
надо просто пробежаться по всем
значит, рядам по игроку,
значит, которые у нас тут задействованы в прямоугольнике,
и найти
префиксные суммы.
То есть, за от единицы.
Но для этого надо получается, например, вот в этом ряду
прибавить к ответу вот эту величину
и вычислить вот эту. Здесь надо прибавить эту,
вычислить эту, тут надо прибавить эту, вычислить эту.
Получается, что здесь мы уже сумму
ищем за...
Сколько? За получается от...
От... Нет, не за нм, а
просто за отм.
Нет, все еще круче.
Да, может.
Но давайте так,
это в принципе может оказаться даже прикольной идеей.
Поэтому я даже вот так нарисую.
Вот.
Но не совсем. Ну, для конкретной
этой задачи, конечно, это
не обязательно.
Потому что, да, тут первая идея,
которая возникает, то, что мы должны взять
два столбца, и в каждом столбце
мы должны взять 2 столбца,
мы должны взять 2 столбца, и в каждом столбце
найти тоже сумму на подотреске.
И даже следующая идея возникает,
ой, а давайте-ка на каждом
из этих столбцов тоже найдем префиксные
суммы.
А что по собственной? Что по собственной? Нет.
Действительно.
Давайте. Ну вот.
То есть прям
это мы будем называть
PY
PXA.
То есть, как видите, то есть мы
к А применили префиксные суммы PX,
а потом к результату применили PY. Такая
темология. Хотя мистическая
теорема в этом месте
будет звучать так.
PY PXA тождественно
равно PX PY
A.
Утверждаю я.
Ну да, в первую очередь, это
коммутатив. Но правда, да, заметим, что
на самом деле, когда мы работаем с суммой
в прямоугольниках, то нам
вынуждены практически работать с
коммутативными операциями. Почему?
Потому что
в противном случае нам придется
реально заморачиваться с тем, что
в каком порядке суммы искать. Вот в таком,
вот в таком. Вот как-то
непонятно, кто приоритет. Я сначала по их
суптом, потом по игроку или наоборот. Поэтому тут
от коммутативности, я боюсь, мы тут
не уйдем от слова никуда.
То есть могли бы
то есть можно, в принципе, было бы разве что
там можно избавиться от обратимости. Ну про ассоциативность
я вообще молчу. Ну правда, без
ассоциативности, кажется, что работать вообще
практически невозможно.
Вот.
Ну давайте в каждом столбце
на этом массиве честно насчитываем. Ну поехали.
Там 5, 7,
10, там 16, 21.
Так, что там у нас еще?
12, 18,
27.
Значит, соответственно, 38,
48. И соответственно,
16, 25,
ну вот,
36,
там 49.
Так.
Так.
Устный счет.
Если бы опять это
заклинание просто работало.
Ну хотя нет, ну тут сложение, да.
Как это приятно произвести
на кого-то впечатление от того, что вы умеете
перемножить в уме 89
на 21.
Так, ну-ка давайте успеете, пока я досчитаю.
Сколько?
Правильно, да, правильно.
Мы тут на кулькуляторе тоже посчитали.
Право.
Ну да.
В чем когда-то высказывает ощущение,
что если это перемножение двузначных, то там это
проверяющий мог бы, конечно, и посложнее пример
подогнать.
Ну я не знаю, там хотя бы
37 на 46,
я кажется, что умею умножить сильно сложнее.
Ну там 37 на 47 понятно,
там 42 в квадрате минус 25,
там вот это все, да.
Ну вот, не важно.
Что у нас тут появляется?
Чтобы найти вот эти суммы
на подотреске, нужно получается
найти, здесь прибавить, здесь вычесть.
Ну и здесь, правда, вот эту сумму нужно вычесть,
поэтому мы пишем, что здесь минусик,
а здесь плюсик.
В принципе, вот такая идея,
что оказывается, что мы
сначала сокращаем себе жизнь
по рядам.
Ну вот так.
Ну скажем так, так сказать,
активную жизнь, так сказать, когда надо
что-то физическое делать.
Так, активно-техническую жизнь, да.
А потом замечаем,
что нам, оказывается, просто в некоторых столпсах
нужно что-то просто красивое сделать на подотреске,
поэтому мы тут вводим какую-то структуру.
В общем,
то есть на самом деле, в общем-то вот
идеи, мы, в общем-то, никуда и не денемся.
То есть вот получается такая штука.
Что приятно в этой идее, легко сразу замечу,
в принципе, эта идея, в общем-то, и на трехмерии обобщается
спокойно, на четырехмерии и так далее.
Да, то есть, конечно же, да,
то есть, конечно, если у вас камерея,
то, конечно, вам придется тут, то есть
там будет работать от 2 степени К,
это да.
Но обычно К всегда
не сильно большой, поэтому не сильно
страшно.
Но чаще всего К равно 1, конечно.
Но это уже, нет, у всякой бывает,
иногда могут.
Вот, значит, что же у нас
дальше идет? Дальше идет следующее.
Хорошо, но это был статический
РСКУ.
Да, но, во-первых, да, сразу заметим, давайте, да,
почему вообще эта теория, мы верна?
Почему нам безразильцы, как бы, сначала
по Х по игроку или, наоборот, сначала по
игроку, а потом по Х.
Да, потому что, по факту, да, возможно,
вы с этим ранее сталкивались, но в другом
определении. Да, потому что
можно это интерпретировать и
по-другому. То есть, давайте найдем
тоже, то есть, такой аналог
префиксных сумм, то есть, двумерная, это называется
двумерная префиксная сумма.
Что это значит? Это означает, что в каждой клетке
мы хотим найти сумму
на вот этом прямоугольнике.
Причем можно даже,
как их искать? Причем чаще всего я рискую
пред 신� положить, что вам даже не trzeba,
что можно искать вот сначала вот так, потом так,
то есть, ну,
что-то мне подсказывает, что вам, скорее всего,
могли сказать, что, как насчитать такую сумму?
Заметим, что сумма на этом прямоугольнике
что такое? Это вот этот элемент, плюс
сумма на этом прямоугольнике, плюс сумма
на этом прямоугольнике, минус сумма на этом.
Да, в двумере дот.
Ну, рискну а что-то там большинство
из вас, пока в Москве, впервые так и рассказывали.
Или кому-то рассказывали
не так.
Но обычно да, то есть обычно когда вы там первый раз в жизни это видите, действительно чаще всего так расскажут, действительно.
Вот единственное, то есть минус у этой штуки будет заключается в том, что на какой-нибудь трехмерии это уже будет обобщаться немножко с трудом.
Ну то есть там на трехмерии еще нарисовать можно, но вообразить себе четырехмерия, ну тут как бы
сложно. Нет, отдельные математики говорят, что им удается, но это очень больно.
Но тогда форму включили, скорее всего вам придется использовать как просто черный ящик или вот, ну или вы ее может быть даже докажете, но это будет скорее абстракция.
Да, чего я хотел сказать?
Нет, кто-то что-то сказать, пусть перебил.
Потом, когда потом?
Когда потом, когда мы сливаем это обувь, мы обсуждаем.
Ну вот, давайте попробуем апдейтить эту, проапдейтить эту идею.
Теперь давайте себе представим, что мы неожиданно хотим еще и сделать.
Так, ладно, пришло время взять новый маркер.
Какой маркер нам взять? Давайте фиолетовый.
Мы неожиданно хотим.
Так, видно, что он не синий.
Мне тоже так кажется.
Ладно, ну ничего, у нас есть мощный.
У нас есть мощный, да, такой мощный.
О, вот это точно не синий.
А теперь давайте себе представим, что я хочу сделать.
Так, тихо, тихо, тихо, тихо.
Внимание, я хочу сделать изменение в точке.
Вот я хочу неожиданно взять точку иксы как.
И неожиданно в ней элемент изменить на D.
Так, ну заметим, что конечно идея с префиксными суммами тут работает конечно уже не очень.
Ну, так сказать, то есть в принципе можно сказать так, что допустим мы решили изменить какой-нибудь там вот этот элемент.
Тогда заметим, что здесь у нас получается, что за O от N мы ищем сумму, но изменение происходит за O от единицы.
Если мы переходим вот сюда, то здесь получается значит O от M на поиск суммы, но при этом изменять придется целый, что там получается, изменять?
Ну да, целый суффикс ряда, то есть получается за O от N такого.
Здесь соответственно придется изменять прямоугольник.
Вот такой.
И здесь O от N.
Нет, то в принципе заметим, что в общем-то вот этот вариант на худой конец уже тоже может быть неплохой, что-то типа корневухи такое получается, особенность NM.
То есть если NM равны произведения 10 в пятый, то как раз вот корневуха вам и вылезла.
Можно сначала все запросы считать, посмотреть какие бы больше.
Ага, во, во, во, во, во, во.
Во, во, во, во, во.
Нет, знаете, у меня с летом насекает упражнение.
А что делать, если запросы вам дают чисто онлайн?
И тогда есть ощущение, что в онлайне можно тоже поддерживать каких-то операций больше.
Если каких-то операций прям сильно больше стало, то давайте все заодно пересчитаем.
Нет, почему бы и нет в общем-то?
Нет, в принципе может быть очень интересное исследование.
Вот, значит O от M, O от N, в общем такая вот красивая радость.
Вот, но можно конечно пойти и по-другому.
Вот, то есть, но на самом деле теперь следующая идея у нас возникнет в том, что на самом деле в каждом ряду можно забабахивать и что-нибудь более умное, чем префиксные суммы.
Например дерево Фенвика.
Так, ну вот, смотрите, сейчас я начисел, как я это уже показывать не буду.
Да, к сожалению, да.
Хотя да.
Ну вот, значит смотрите, так это вот.
Да, то есть тут я уже что-то показал, да.
Ну да, как-то один, это один, это одно яблоко, а это еще одно яблоко.
Один плюс один равно два.
А теперь введем дерево Фенвика, да.
Так, это мы, эту уже классику мы знаем, да.
Значит, вот тут есть какой-то массивчик, то есть тут есть какой-то массивчик, и тут есть какой-то массивчик.
Ну а теперь идея такая, то есть вместо массива, то есть уже будет не массив П, а мы его будем называть теперь F-X-А, и тут мы его будем называть F-Y-F-X-А.
Вот does it mean?
Ну F means of course Fendrick.
Да, редкий случай, но фамилия Fendrick пишется именно с этой буквы.
Вот, нет, ну я не знаю, у меня просто имя такое, что меня любят не с этой буквы имя писать.
Почему-то.
Ну не почему-то, а просто классическое написание моего имени, почему-то без F пишется, но мое имя пишется с этой буквы, если что.
Вот.
Ну как бы, заранее показывать не буду, но как бы.
Вот.
Значит, соответственно.
Значит, что тут предлагается делать?
А предлагается делать следующее.
Ну вот следующее.
Значит, тут у нас, как всегда, если в тупую искать тут, что-то от суммы изменять, то, как мы сказали, NM и 1.
Ну теперь следующая идея.
А давайте-ка в каждом ряду забабахаем дерево Фенрика.
Вот вместо того, чтобы хранить там честный массив, давайте забабахаем там дерево Фенрика.
Вот.
Вот.
Тогда вот давайте подумаем, что там собственно теперь поменяется.
Ну то есть если брать вот опять прямоугольник, давайте вот рисовать то же самое.
И тут у нас какой-то вот тоже допустим.
Тогда оказывается.
То есть что нам нужно?
Чтобы, ну вот тогда, значит, в каждом ряду нужно найти, ну тогда нужно здесь пробежаться по каждому ряду и найти там сумму в дереве Фенрика.
Это будет работать, получается, теперь за O от M лог N получается.
Вот. А изменение в точке одной, вот какой-нибудь давайте вот тот же самый, там напишем вот этой.
То есть оно будет работать уже не за O от N, а за O от лог N.
Уже неплохо, правда?
Вот.
Ну а теперь следующая идея какая?
Давайте подумаем, что происходит, когда мы ищем сумму.
Когда мы ищем сумму на подотрезке, мы и там, во-первых, ищем сумму на префиксах.
То есть начиная с вот этого элемента, ну ладно там, с какого-то вот этого, мы тут что-то прибавляем, прибавляем, тут вот логарифом плюсиков делаем.
Ну помните, в нашей интерпретации дерево Фенрика мы отсюда начинаем, ну это уже детали.
Вот.
Вот.
Теперь замечаем, что теперь, когда мы идем в следующий ряд, мы прибавляем, а, забыл, еще мы должны тут, конечно, кое-что поучитать.
То есть тут тоже найти сумму на префиксе какую-то.
Может быть даже кого-то поучитать там, взаимоуничтожить.
Теперь заметим, что в следующем ряду мы будем прибавлять и вычитать абсолютно те же самые элементы.
Чего?
Ну, какой массив разности?
Нет, массива разности, нет, массива разности тут нет.
Это просто, просто был честный массив, мы сделали на нем Фенрика, никаких разностей, обратите внимание.
Вот.
И поэтому возникает, ну по крайней мере пока, значит вот возникает такая вот красивая идея.
И тогда получается, ну вот, и тогда здесь уже возникает такое, а давайте на каждом столбце тогда вот этих Фенриков тоже сделаем Фенрика.
То есть это не Фенрик Фенриков, не путать, Фенрик Фенриков, как вы помните в прошлый раз, это немножко другое.
Вот.
И здесь получается вот такое.
Вот.
То есть здесь тогда, то есть когда ищем сумму такую, то вот оказывается, что, то есть надо на самом деле пробежаться по, то есть, ну во-первых, да, то есть сумму мы теперь ищем как бы вот уже, то есть там как бы, то есть можно так сказать.
То есть была у нас вот по горизонтали, теперь на этих суммах сверху мы еще по вертикали что-то рисуем.
И теперь, когда нам приходит, значит, запрос на прямоугольниках, то соответственно нам нужно пробежаться по логарифму, получается, отрезочков по иксу и в каждом из них найти сумму на подотрезке.
Что мы делаем уже с помощью этого наворотчика, уже, значит, уже такого Фенрика поверх Фенрика.
Вот это скорее называется, да, Фенрика поверх Фенрика получается.
Вот. И тогда получается, что у нас тут лог м, лог н получается.
А изменение получается, ну да, то есть здесь заметим, что мы, да, от лог н, потому что элемент здесь у нас там какой-то вот этот вот меняет там, то есть изменяется вот где-то вот в каких-то вот этих вот точках.
Но здесь выясняется, что тут он выясняется, меняется не только вот в этих точках, но еще тут в логарифме точек в каждом месте, в каждом столбце.
Поэтому тут получается тоже лог н, на этот раз на лог м.
Вот. То есть, в принципе, вот так можно изобрести двумерное дерево Фенрика.
Или если, ну вот, хотя, в принципе, заметим, что мы никак не пользуемся тем, что это именно дерево Фенрика.
Двумерное дерево отрезков можно забабахать абсолютно таким же образом.
Вот. То есть вот такая нот, то есть вот такая вот, в общем-то, нехитрая идея.
Вот. Но не буду сейчас писать, какими, думаю, там, водоразночь, какими простыми вложенными циклами в принципе это можно сделать.
Вот. Ну, в принципе, можно делать не вложенными, может и даже будет легче вообще.
Вот. Так что вот такая вот получилась красота.
Да, вот такое-то двумерное дерево отрезков, вот такое двумерное дерево Фенрика.
Вот. Ну, в принципе, да, как видите, трехмерное, в общем-то, делается примерно так же.
Но предположим, что у нас теперь появилась теперь царь-операция.
Царь-операция будет там теперь говорить, что мы теперь хотим прибавлять на под прямоугольники.
Ну, на самом деле, да.
Нет, ну не важно, нет, ну тут, ну скажем так, в конечном счете, нет, вот там, как сказать, ну да, то есть там, конечно, да, у дерево отрезков может быть такое есть выгодное отличие.
Такое, пока я, ну, то есть выгодное отличие действительно заключается в том, что там один логариф, а мы не два.
Вот. Ну, в общем, тут на самом деле, конечно, это тут еще действительно вопрос.
Потому что, конечно, да, то есть заметим, что когда, если у вас там рекурсия глубины ка и ка не константа, то на самом деле делаете в логарифом Н или два логарифа Н, это может оказаться принципиально.
Вот, потому что два в степени ка, это уже не константа.
Вот это, конечно, да. Впрочем, крайне редко такое действительно нужно.
Но действительно, то есть, я знаю, в Фенвике действительно будет проблема, что так как Фенвике у вас сумма это префикс минус префикс, то там, конечно, количество конкретных запросов там, конечно, будет расти именно как два в степени.
Вот.
Чего?
Ну, последняя мысль такая, да, что, как бы, если вы используете дерево Фенвика, то как бы каждую сумму на отрезке вы ищете не за один запрос, а за два.
Поэтому, если у вас там происходит камерия, то, как бы, количество запросов там растет как два в степени ка.
Собственно, только эту мысль я, в общем-то, и сказал.
Больше никаких мыслей я пока не говорил.
В этом месте.
Ну вот, ну теперь есть какая-то вопрос. Как же делать прибавление на под прямоугольники?
Да, ну заметим, что, да, в одномере у нас были там какие-нибудь прибавления, там какие-нибудь замечательные там отложенные операции.
Но здесь у нас, к сожалению, этой древесной структуры нету, как в дереве отрезков.
То есть, не, нельзя там это, то есть, идти сверху вниз и говорить, что ладно, если пойдем ниже, тогда эту операцию протолкнем.
Здесь, к сожалению, такое уже не работает.
Ну вот там, конкретно в двумере, там есть какие-то сложные механизмы, там как-то это можно себе забабахать и даже как-то понять.
Но, на самом деле, необходимости в этом нет.
Потому что наша, собственно, пластиковая бутылка, на самом деле, сейчас прекрасно нас выручит и здесь.
Вот. Ну, знаете, это классический метод, да, типа берем обычную пластиковую бутылку, там и что-нибудь делаем.
Ну вот.
Сложно, да?
Так, вам имя Андрей Бахметьев что-нибудь говорит о передаче «Пока все дома»?
Нет.
Ой.
Ой.
Ну там это очумелые ручки, там вот это все.
Ой.
Ах, молодежь.
Да, да, да, да.
Что-то там Эйби Бэйби слушают какое-то там это.
Ой.
Так вот. Ладно.
Значит, смотрите.
Теперь давайте думать. Мы хотим прибавлять на подотрески и искать сумму на подотрески.
Вот. В принципе, эту операцию, об этой операции мы можем даже забыть.
Ну, потому что она все равно подвит вот этой операции.
Значит, но действительно.
Ну, пока у нас все плохо.
В том плане, что в тупую обе эти операции делаются за ОАТН.
Но давайте попробуем себе техническую жизнь себе сократить.
Ну, как всегда.
Вот.
Как мы сократим?
Ну, как мы помним, в дереве Фенвика в этом месте, ну или в дереве отрезков тоже можно.
Мы себе сделали, то есть в каждом ряду мы делали там, честно, два массива.
Помните, у нас был массив ДА и ДАЖ, помните, да?
Вот.
Ну, так значит, давайте тогда сделаем тоже два массива.
ДХА и ДХАХ.
Ну, то есть, ДХ это означает, что мы в каждом ряду взяли разности соседних.
А в ДХАХ это означает, что мы взяли то же самое, но домножили еще на Х.
То есть, да. То есть, у нас теперь размножаются уже даже массивы.
Вот они.
Ну вот.
Соответственно, да.
Значит, это у нас вот такая вот красота.
Значит, ДХА и ДХАХ.
Но давайте думать, в таком массиве тогда получается, что как бы сумму в каждом ряду мы находим за логарифом и прибавляем на подотрески тоже за логарифом.
Да.
То есть, поэтому где-то здесь у нас тут получается, значит, сумму мы ищем за опять М лог Н.
И изменения мы делаем за сколько? За, так, рыженьким пишем.
Так, ой, коричневое давайте вообще отложу.
Значит, ищем, да, тоже в общем-то за М логом, потому что просто в каждом ряду независимо работаем.
Да.
Ну, может зайдет, может нет.
А это не принципиально, потому что от М мы сейчас тоже избавимся.
Потому что, как вы уже догадываетесь, идея абсолютно та же.
То есть, как бы, то есть в каждом ряду мы в общем-то будем искать там сумму, то есть понятно там нам в ДХА надо найти в каждом ряду сумму каких-то элементов, там вычесть сумму каких-то элементов, но эти элементы одни и те же.
И в массиве ДХА и в массиве ДХАХ.
Поэтому идея такая, так давайте на каждой вертикали каждого из этих массивов забабахаем тоже этого нашего продвинутого Фенлика.
Да.
Вот.
Как бы да. Ну, как говорится, размножение продолжается.
Потому что для того, чтобы сделать это на массиве ДХА, то есть нам придется создать вот уже, значит, целых два массива.
Это будет массив ДЫ-ДХА и ДЫ-ДХАY.
Вот.
Но это мы еще только из массива ДХА такое сделали.
А ведь придется то же самое делать из массива ДХАХ.
Ну, на самом деле да.
Ну, как сказать, там, там, конечно, чем дальше, тем как бы сложнее это использовать, именно как там действительно может быть черный ящик, хотя...
Нет, ну, как сказать, ну, скажем так, ну, там и так, и так.
Просто фишка такая.
То есть в одномерии мы, как бы у нас в структуре мы прибираемся и ищем сумму каких-то элементов.
А теперь в двумерной структуре мы будем модифицировать структуру так, что просто мы...
У нас как бы есть то же одномерная структура, только в каждой точке мы как бы не просто берем чиселку и прибавляем там, вычитаем к ответу, да, а просто лезем в такую же структуру.
И там запускаемся на подотрески. То есть модификация в этом.
То есть в принципе на самом деле так, то есть обобщение может быть только в том, что, знаете, вот, допустим, у вас есть такой экзотический фенвик или деревоотресков, когда вы там говорите, хочу найти сумму на префиксе.
И он вам возвращает вектор, типа, то есть он, типа, нищет вам сумму на префиксе, а говорит, значит, смотри, вот у тебя есть массив.
Значит, вот те числа, один, два, четыре, там, я не знаю, там, девять, двенадцать. Вот возьмите элементы и их сложи.
Вот, а, нет, все, я тебе больше ничего не должен. Вот, а то, типа, у вас много, я один, там, вот это все.
То есть вот такой вот наглый, он выкладывает индексы, в которых надо сложить.
Тогда вот, оказывается, с таким наглым фенвиком обобщать оказывается лучше.
Почему? Потому что в двумерном случае тогда, говорит, берем по иксу, он говорит, значит, смотри, складывай первого, второго, четвертого, там, пятого, десятого, там, пятьдесят седьмого по иксу.
Вот, окей. Ну вот, и дальше вы тогда идете по этим шести столбцам, и в каждом столбце у вас получается есть там своя структура.
Ну, даже не совсем так. То есть вы можете, то есть вы там по иксу сказали в каких рядах, и потом вам говорят, а теперь еще скажите в каких столбцах.
И там, ну, можно так двумя способами. Либо там, в каждом столбце у вас есть действительно внутренняя структура, куда вы действительно уже отправляете черный ящик.
Ну, либо просто говорит, что делаете то же самое, что там, он вам возвращает какие индексы вас интересуют по игроку, и тогда вы уже знаете, что вот вам по иксу, вот вам по игроку, теперь перебираем, перебираем, и там прибавляем там то, что надо.
Вот, в принципе, можно так мыслить. В принципе, такое мышление действительно очень удобно тогда обобщается уже и на трехмерии, и на что угодно.
Вот. Да, ну, значит, я еще не дописал. Да, значит, dxax, это у нас получается dydxax, и, конечно, его величество dydxaxy.
Вот. Ну, так. Ну, по сравнению с названиями каких-нибудь спиртов, я думаю, не так страшно.
Не так страшно, да? Вот. Вот.
Получается, получается, у вас четыре массива, в каждом из них нужно сделать запрос, как в обувь, в двумерном дереве, там, какой-нибудь фенвик или отрезков с изменением в точке, и тогда здесь уже получается действительно все по красоте.
То есть тут log n, log n здесь, и там log n, log n здесь. Правда, с оговоркой, что придется хранить уже не двух фенвиков, а целых четыре.
Ну, а в трехмерии восемь, там, шестнадцать и так далее. То есть у вас уже давите, то есть у вас как два степеника растет уже аж количество фенвиков.
Да, так что вот такая вот красота.
Так что если у вас есть там много работяг, которых надо трудоустроить, тогда всегда решайте задачу коммерного поиска суммы в камере.
Да. И тогда, собственно, как говорится, работяги придут и будут работать.
Вот. Так что вот такая радость. То есть обратите внимание, между прочим.
Чего?
Да?
Не, а что тут?
Так, конечно, говорят.
Нет, ну, индексация тут, по-моему, особо не принципиальна.
Ну, чтобы...
Нет, ну там, на самом деле, там и...
Ничего как для общего случая.
Нет, ну что?
Нет, ну а что, в общем, нот. Нет, ну по большому счету будет, в общем-то, примерно так же, в чем проблема.
Нет, ну вот.
Нет, то есть механизм обращения тоже, то есть у вас тут просто...
То есть тоже будет это, то есть куча массивов DZ, DIG, DX.
Просто они будут домножаться на там все возможные подмножества Иксов и Игоков.
Ну вот.
Почему 4 получилось?
И чего?
Почему у нас 4 матрицы?
Ну, смотри, потому что, когда мы искали одномерную задачу поиска суммы на отрезки и прибавления на отрезки, у нас вместо одного фенвика получилось два.
Позже, мы их назвали DA и DAG.
Ну вот, вот здесь.
Вот, поэтому здесь их уже два.
Когда мы только...
Да.
Но и для этого массивы, и для этого.
Поэтому 4.
Вот.
Вот так ещё можно обобщать.
То есть, ну, на самом деле...
Ну, как сказать, то есть, на самом деле можно действительно обобщить, что сказать, что у вас, что, допустим, при каждом фиксированном Иксе у вас там в толст sauce находится какая-то структура данных.
То есть, то есть, если говорить о том, как на обобщать на большей размерности, то опять же говорю, что вот у вас там, камерный параллле-ипид.
Переберём первую координату.
При каждой фиксированной координате у вас есть 49- es-анимерный параллле-ипид, на котором у нас там, допустим, рекурсивно какая-то структура хранится.
Вот, понятно, да?
Ну, не важно, там давайте изначально для простоты
считать, что у вас весь массив заполнен нулями.
Тогда получается, что запросы будут, то есть везде так.
То есть мы говорим, что мы фиксируем все, кроме первой
координаты, и по, так сказать, ряду нот, и по ряду, допустим,
условно забабахиваем фермика.
Что это значит?
То есть по большому счету это будет означать, что
во всех запросах мы будем по этому х смотреть, какие
х-ы нас вообще интересуют, в каких х-ах мы бы делали
запросы.
И при каждом фиксированном х-е запрашивали, делали
бы что-то рекурсивное на k-минус одномерный случай.
Вот, ну по сути так.
Ну да, может не самый пока, то есть пока не самый щелкающий
способ, конечно, получается.
Ну вот, ну что делать.
Хочется, конечно, че-нибудь пощелкающие, но ладно.
Вот, но темя нот.
Нет, туда, да, опять же, еще раз, мы никак не пользовались
тем, что Дирева Фенвика.
Мы здесь пользовались только одним, что хранится какая,
в каждом ряду хранится какая-то структура данных,
и в этой структуре данных, по каждому там, чтобы найти
сумму на подотреске, допустим, ЭЛЕР, вам нужно найти сумму
каких-то конкретных элементов, которые только от ЭЛЕР
зависят.
То есть это, в общем-то, что Дирева Фенвика, что Дирева
Отресков этому удовлетворяет.
Ну единственное, что в Диреве Фенвика какие-то элементы
надо не только прибавлять, но и вычитать.
Вот, то есть в принципе, кстати, но вот, но так суть
одна, то есть мы не пользовались, что это именно Фенвика, а
не Дирева Отресков, мы не пользовались.
Более того, в принципе, вы могли вообще бы развлечься
и сказать, что здесь вы делаете Дирево Фенвика, тут делаете
Дирева Отресков.
Ну, если у вас там очень большое желание зачем-то
себе, там, усложнить реализацию, уж не знаю зачем, но теоретически
возможно.
Нет, чисто теоретически на этом можно там, если
у вас третье измерение, можете вообще плюнуть и
корневуху забабахать.
Да, а симптотика, конечно, это попортит, но уж как-бы
развлекаться так до конца.
Вот.
Так что вот такое, так что поздравляем, мы действительно
шикарную операцию, с которой у нас не справилось всякие
проталкивания, а именно прибавление на под прямоугольники
и сумма на под прямоугольники.
Обратите внимание, это не прибавление на прямоугольники
и сумма в одной точке, которое тоже делались бы аналогичными
технологиями.
То есть, в принципе, получается достаточно неожиданно мощный
результат, хотя, казалось бы, мы тут вроде никакой сильно
большой магии не делали.
То есть, шаг за шагом, и тут выясняется.
Вот.
Так, есть ли тут какие-то вопросы?
Так.
Ну, в первую очередь, сумму по каким-то конкретным
Сумма каких-то элементов, при условии, что мы в каждом
ряду забабахивали дерево Фенрика.
Вот.
Нет, ну там, да, что там надо, там что-то, но там
понятно будет, сумма на префиксе, минус сумма на префиксе,
каждая сумма на префиксе, это там длина префикса плюс
один умножить на вот эту сумму, там минус сумма
здесь еще.
Если бы это было место Фенрика в дерево отрезков, то как
он не прибавлял бы?
То есть, мы не делали бы все вот эти вот, да и...
Не, абсолютно, что делали бы, в чем проблема?
Мы делали же дополнительная сила, чтобы массовость
добавить, а в дерево отрезков можно массовость через
пушистую.
Ого.
Ну, просто проблема в том, что технологии не особо
вообще там как-то...
Подождите, ну просто...
Нет, это пуши...
Нет, смотри, просто сейчас.
Там, понимаешь, просто какая фишка?
Дело в том, что пуши...
Нет, скажем так, больше...
Ну...
Сейчас даже сложно объяснить, но сейчас по поводу не работает, да.
Не, подожди, в чем проблема?
Да, в каждой строке, в каждой столбце, Фенрика просто.
Фенрика, которую мы делали с маслом и красом.
Почему я не могу до Фенрика, но не до дерева отрезков?
Можешь.
Нет, сам скажи, как-то дерево отрезков, ну просто
дерево отрезков можно, но если ты там пользуешься...
Почему нельзя с пушами?
Нет, просто с пушами, нет, боюсь, тут отложенность
уже, как бы, по идее, сработать не должна.
В дерево отрезков обычном есть такой вариант.
То есть мы дерево...
То есть каждый элемент не точно знает свою сумму,
но мы гарантируем, что все отложенные операции
находятся у него как бы выше, и мы в эту вершину
можем прийти только через предков.
За счет чего мы эти пуши протолкнем.
Вот здесь такой гарантии нету.
Ну, проверим.
Вот в этой технологии мы как бы...
Здесь мы как бы пользуемся в явном виде, что мы должны
перебрать, в каких столбцах мы должны пробежаться.
Если бы мы делали дерево отрезков, то нам бы пришлось
сказать, что мы должны пробежаться еще там по каким-то...
По каким-то всем верхним, на самом деле, вершинам.
Ну, их там, ладно, само по себе логично.
И сделать пуши.
Вот.
То есть сделать пуши.
Ну, вот.
Ну, кстати, хотя...
Ну, вот.
То есть действительно, если так аккуратно делать,
то может, кстати, даже и зайдет.
Ну, вот.
Но там...
Вот.
Ну, вот.
Но это...
Но такая вещь, конечно.
В каждом из тех деревьев, в которых мы делаем запрос,
но можно все пропушить.
Нет, ну, принц.
Нет, ну...
Мы не можем сразу обращаться ко вторым деревьям отрезков.
Ну, вот.
Нет, ну, как сказать.
Нет, у нас сейчас...
Ну, тут вот...
Ну, тут, конечно, вот тут все-таки...
Да.
Нет, тут нет.
Кажется, там можно сделать, но там логкуб вылезет.
Нет, почему логкуб?
Нет, смотри.
Ну, пуши.
Ну, смотри.
В дереве...
Ну, как мы знаем, операция в дереве отрезков работает
То есть, когда мы перебираем не только нужные нам отрезки,
но и все их предки, то их получается тоже от логарифма.
Вот.
Ну, вот.
То есть, в принципе, ВАЗК действительно идея уровня
«А давайте...»
То есть, просчитаем, допустим, у нас тут в каждом ряду
мы делали бы дерево отрезков такое, да?
Тогда надо просто перебрать...
Тогда получается...
Нужно сделать следующее.
То есть, нужно в каждом ряду
перебрать ячейки дерева отрезков,
из которых надо сделать пуш.
И тогда в каждом конкретном ряду...
То есть, получается, надо сделать...
У каких-то операций надо сделать пуш.
То есть, допустим, пуш-пуш-пуш-пуш.
Там пуш-пуш.
Ну, как-то так вот.
Вот.
И... Ну, вот.
То есть, тогда мы гарантируем, что...
То есть, когда мы тут проделали пуш,
то есть, мы начинаем знать, что
там, по крайней мере, все ноты.
Нет. Ну, как сказать?
Ну, вторая нота.
Нет. Ну, в принципе, да.
Нет.
Я боюсь, тут проблема просто будет, что
если мы попытаемся это обобщить...
Ну, да. То есть, похорону...
То есть, кажется, просто
есть такой...
Ну, да.
Если мы, допустим, когда-нибудь захотим потом найти
сумму на маленьком прямом углу, даже вот
на этом ряду, то ей бог быть какие-то
высокоуровневые пуши, до которых мы рискуем
просто не дойти.
Тут какие-то такие риски есть.
Ну, да. Нет.
Сложный, конечно, момент, но
как бы у меня осталось всегда интуитивное
ощущение, что там какая-то подлянка.
Видимо, компенсируется она еще тем, что я никогда
не слышал, чтобы кто-то
решал за логарифом подобным
технологию операцию, скажем, присваивания
на маленьком углу.
То есть, поэтому там вынуждено
сказать, что какие-то подлянки тут есть.
Хотя, конечно, может быть, слет очень
нетривиально на таком уровне понять, а какие
конкретно.
Но они есть.
Ага, желательно еще и доказательно.
Потому что тут
Ну, да, да, да.
Или наоборот.
Знаете, как бывает
в этом?
Казанцы же рассказывали
прикол, что мы там сделали
контест, дали оптом, из Open Cup пришло
предположение, что наша задача G является
полной. Предположение подкреплялось
примером теста, который валит все решения
жюри.
Да, как бы чуть позже автор
разобрался в проблеме, подтвердил, что
действительно наше решение неправильно.
Да, при этом шел пятый час контеста,
кто-то уже
получил акцент, пропихнув жадность,
которую подразумевала жюри.
Ну, бывает, да.
Ну, да.
Ну, бывает.
Не, ну.
Не, ну там подлянка.
Форси как бы такой раунд признают н-рейтингом, естественно.
Нет.
Не, ну при таких вещах
он кэша объявляется н-рейтингом и так далее.
Была статистика, когда
там куча красных
сел кроме С.
Ну, вот да.
Я не правда, я Степаном стал.
Ну, понятно.
Не, ну что, нет, Петя Митричев как бы потом
автор этого теста,
он показал, что задача
НП полная.
Все задачи знали, так теперь думаем.
Так, ну да, нет, задача реально НП полная.
Так, ладно, давайте подумаем, что от нас могло
хотеть жюри.
Так, может быть, вот это, это, ну давайте это.
О, accepted. Ну, значит, шлем Clark, что
ребят, это хрень.
Ну, то есть, в принципе, да.
Но для этого нужно быть Петей Митричевым.
Да, возможно, вы уже не знаете, кто это.
Да, который Петр.
Ну, в свое время это был легенда.
Ну, в чутке, там про его и топ-кодер,
там, знаете, ну, пока стираю, могу рассказать.
Вот, что там,
там какие, какие, какие
там легенды, что там
действительно, что
там, что действительно, в той комнате,
где контест пишет Петя, на самом деле
называется, там системные тесты
не запускаются.
Потому что, на самом деле, просто всех, кого не взломал Петя,
там всем руками выставляется accepted.
Автоматически.
Ну, а, ну реши, да.
А, ну, да, или если контест пишет Петя,
то, в принципе, авторы даже не пишут авторское решение,
просто берут Петина.
Или там, или там
единственная вердикт, кроме
окея, который может получить Петя, это time limit.
Ну, дело в том, что чаще всего
в тестирующих системах время обозначается
беззнаковым, там, беззнаковым целым числом
и минус, минус один воспринимается как
плюс бесконечность.
Там вот оно, ну, и так далее.
Такие, ну, там вот эти, там, можете погуглить там
40 фактов о Петре Митриче.
Да,
то есть...
Ну, кстати, да.
Не, ну, не то, чтобы, я думаю, он там не умеет на C++,
но, как бы, вот он
Джавай, да, давным-давно, когда
Джавайы были, и было их много.
Вот. А тут, как бы, даже
хотя несколько лет назад даже ритмо
упало в этом плане. Это может быть
да. Ладно.
Так.
Так, ну ладно, давайте так, чтобы сейчас
закончить с деревьями отрезков, по крайней мере,
но, конечно, хочется рассмотреть
еще одну маленькую,
неожиданную задачку.
Вот. Ну, сейчас я, правда,
с двумя июля она уже отношений
иметь не будет,
но будет иметь кое-чему
еще.
Так.
Но для этого
нужно принудить. Напомните ко мне, обсуждали
ко мне такую веселую задачу
про, там, покраску забора
на 10-9.
Вот.
Нет, ну просто я в какой-то момент со всеми
это обсуждал, просто
великая задача про тома Сойра, который
неожиданно решается четырьмя разными способами.
А задача такая.
Ну, задача просто про том Сойра.
Задача
формулируется так. Значит,
том Сойр красит забор. На
заборе, редкий случай, 10-9
досок. Да, даже не
10-5, а 10-9.
Он, значит,
а он этот забор красит. Как он его красит?
Ну, у него есть 10-5.
Изначально все доски там бесцветные.
Он красит, он там, у него там есть
10-5 запросов типа покрасить
какой-то подотрезок в заданный цвет.
Прям, L, R, там,
X. Так вот, скажите,
ну понятно, что если красит одно и то же,
красит поверх.
Ну, присваивание, короче. Внимание
вопрос. Для каждого цвета, скажите,
то есть в конце, для каждого цвета
скажите, пожалуйста, сколько
досок в него покрашено?
В общем, юмор такой. Просто почему
прикольная эта задача?
Потому что мне неожиданно оказалось,
что я умею решать эту задачу четырьмя разными
способами.
Причем принципиально разными,
на самом деле. А если вы скажете, причем более
того, два из них с цветом.
Я сейчас скажу, ну как решать цветом, понятно.
Все говорят, понятно. Потом выясняется, что у нас
принципиально разные решения с цветом.
Но давайте подумаем, как вообще можно
решать?
На самом деле есть два решения с цветом,
есть два решения без цвета.
Но с деревом отрезков.
Ну вот, сейчас будем доживать.
Но начнем с не с цветом. Но как
решать это деревом отрезков?
Есть два варианта.
Первый вариант.
Обычно первый вариант,
но самый классический вариант,
который обычно все пишут. Это все-таки явное
ДО, но со сжатием координат.
Да, ну хорошо. Запросы офлайн.
То есть там понятно, что
на самом деле, заметим, что запросы делят у нас
там забор на
два на десять пятый секций, каждый из
которых покрашен целиком в один и тот же цвет,
поэтому можно присваивать прямо на подотрезке.
Просто там, когда вы находите длину,
то ищите не длину отрезка, а взвешенную длину отрезка.
Это понятно.
Вот. Ну как же делать сжатие координат,
мы с вами в прошлый раз обсуждали, поэтому
не будем повторяться. Вот.
Но вторая версия,
это, конечно, знаменитое,
неявное дерево отрезков.
То есть, оказывается, можно забабахать
дерево отрезков на десять девятый.
В чем там идея?
Да, конечно, дерево отрезков
на десять девятый требует, конечно, два на
десять девятой парити.
Но тут у нас, оказывается,
неожиданная идея. У нас есть
отложенная операция. Отложенная операция,
типа...
Здесь уже такой апгрейд. Раньше мы говорили,
что что такое отложенная операция?
Эль говорит, так, дорогой смотритель,
вот тебе информация,
но передай ее детям.
Смотрит, говорит,
и ничего не делает.
Пока не поймет, что вы действительно
хотите к детям. Вы прям хотите навестить
детей? Да нет, ты мне полную сумму скажи.
Вот она. А ну я пошел.
Чего детей дергать?
А если вы хотите к детям,
то он говорит, сейчас,
одну минуточку,
и да, одну минуточку,
и быстро передает информацию детям,
потом говорит, вперед.
Так у нас говорилось классическое дерево отрезков.
Да, кто-то уже догадался.
Что такое неявное дерево отрезков?
Где мы откладываем не просто
передачу, то есть отложенность
является не только передачей информации
детям, а и само создание их.
Ты хочешь к моим детям?
Да.
Мы все еще делаем
это всего от единицы, естественно.
Да.
Но тем не менее.
Правда, более того, некоторые оптимизаторы
ведут еще более страшную вещь.
Потому что конкретно в этой задачи
мы делаем только присваивание.
В принципе, да, вопрос как бы потом,
как восстановить ответ.
В общем, кажется, что восстановить ответ
надо пробежаться по всем девести в девятой доскам
и протолкать все запросы до конца,
но в данном случае делать это
незачем, потому что если вы пришли в вершину,
если вы хотите искать уже ответ,
и вы знаете, что вот пришли в эту вершину,
у нее есть отложенная операция, что тут все вершины
равно 57, но тогда для детей
бегать не надо, просто говорим, что тут все равно 57,
добавляем к ответу.
Это на самом деле
вкупе с желанием сэкономить память,
ну вот, то есть, ну или там, я не знаю,
места в школах,
то есть на самом деле
это очень сильно соблазняет делать
еще одну операцию.
То есть операцию, то есть на самом деле замечаем,
что если мы в вершину пришла
вот такая информация,
то в принципе заметим, что
раз мы можем за вот единицы
создать детей, то в принципе можно их и убить.
То есть то, что у нас там находится ниже,
там можно в принципе ликвидировать.
Нет, ну как сказать, чем отличается
C++ от Java? В C++ вам придется
делать это как-то явно.
Вот, как бы в Java, вот Java,
это как бы, то есть Java
это современный, только цивилизованный,
красивый язык, в котором
как бы никто не убивает детей.
За вас это делает как бы школлектор.
Вот.
То есть он как бы сам, нет, вы просто говорите,
что нет, я считаю, что у меня детей нет,
ну вот, ну а как бы стоящий в углу
школлектор говорит, и в какой-то момент
начинает...
Да, примерно так, да, в C++ все в явном
виде происходит, то есть вы как бы в явном
виде говорите, что как бы детей
надо убить, а он
что такое убить детей? Прям
инструкция, так, так,
что ты хочешь, так, что,
пришел ты меня, пришел убить, да, но так, одну
минуточку, у тебя есть дети, да,
так, дай мне на скилке, ну вот они,
все, спасибо. Так,
и пошел рекурсивно.
Но у нас, ну не совсем так, на самом деле
заметим, что убивать он будет,
заметим, что гарвыч-коллектор, что C++
убьют не больше детей, чем создали.
Да, так что
тут в этом смысле, нет, гарвыч-коллектор, конечно,
он там, конечно, более умный, потому что он думает,
что дети могут там как-то и зациклиться там,
вот это все, поэтому там, он как-то там
аккуратно это все, то есть как-то там аккуратно
это делает, поэтому тут вот вопрос.
А у нас есть модифицизация, да?
Ну, погодите, ладно, так, ну ладно,
как всегда, конечно, да,
получилось немножко черного юмора, но хотя да,
хотя да, когда
вот,
лезли там, хотя страшные люди, программисты,
конечно, им там это, что создать ребенка,
убить ребенка, это все, да,
то есть да, чем отличается
программист от физика,
да, если программисту надо там
это, назвать лишние 57
раз там это, создать ребенка и убить, то, ну,
в принципе, можно и это.
Ну вот, ну ладно, так, все.
Нет, это второй, это
неявное дерево отрезку.
Такое вот.
Ну, на самом деле понятно, что, конечно, для оптимизации,
конечно, лишний раз убивать детей не надо,
то есть как бы
нод.
Нет, но оно сколько будет жрать, ну, скажем так,
каждый запрос в нем будет работать
за О от лог Н вот того
самого большого Н.
Да, то есть и по времени, и по памяти
это будет чуть больше, чем обычные дерево отрезков,
поэтому тут, конечно, всегда есть риски.
Вот, но тем не менее,
вот такой метод тоже есть.
Ну, у нас,
в принципе, у нас массив длины 10-9 был.
Вот, и как бы запрос там будет
за, вот, за лог
именно вот этого 10-9.
Не за 10-5, а 10-9.
Это как бы просто по константе будет
чуть больше.
Вот.
Но, на самом деле, мы можем заметить,
что, на самом деле,
так, а, вот она, господи.
Вот. Ну, есть, оказывается,
два принципа для других метода,
которые вообще не завязаны на
дерево отрезков.
Потому что, ну, тут зависит от того,
вообще, в каком контексте
вы вообще с этой задачей впервые столкнулись.
Потому что многие так скажут, что, на самом деле, задача решается
с конлайном и с сетом.
Нужен.
Потому что идея такая.
Ну, потому что, как мы обычно решаем задачи,
когда у нас есть какие-то отрезки напрямую, да?
Вот, например, у нас есть классическая задача.
Дано n отрезочков.
Найдите, пожалуйста, точку, которая покрыта
наибольшим количеством отрезочков, да?
Как мы такую задачу решаем?
Мы завоем, как бы,
делаем с конлайн.
То есть, делаем событие. То есть, идем, типа,
слева направо и делаем событие.
Типа, отрезок появился,
отрезок исчез, правда? Вот это.
Отсортировали события, да?
Вот. Эта задача тоже так прекрасно
решается.
Только, идея в том, что
только в нашем случае мы все запросы,
которые у нас сейчас актуальны, будем хранить в сете.
С компаратором по времени
этого запроса.
И когда у нас
между любыми двумя соседними,
когда у нас есть между любыми двумя соседними
событиями, мы там прибавляем,
то есть, мы там смотрим, что, так, вот у нас
событие здесь, событие здесь. Так, значит, вот этот
блок покрашен в один цвет. В какой?
Ну, лезем в сет, находим последнюю покраску.
Так вот, сейчас понятно,
или надо как-то подробнее рассказать?
Ну, понятно, что происходит, да?
Хорошо.
Вот.
То есть, получается то же такое решение за внезапное
НЛОГН.
Ну ладно, не за НЛОГН,
ладно, КУ, там сколько там?
КУЛОКУ.
Вот.
КУЛОКУ. Это вот такое
третье решение.
Да.
Да, вот. Но есть их четвертое,
вообще другое решение с сетом.
Идея заключается в том, что
давайте тупо хранить
сет отрезков.
В чем? Это, кстати, даже онлайн
решение, кстати, что интересно.
То есть, идея такая,
в каждый момент времени будем
представлять наш забор
как последовательность
отрезков, покрашенных в один цвет.
Вот.
В каждом отрезке известно там,
типа, что я иду от ЛДР и покрашен
в цвет С.
И давайте эти отрезки я буду
прямо честно в явном виде хранить
в сете с компаратором по, ну, естественно,
Элю.
И тогда у меня, теперь,
как сделать теперь присваивание
на отрезке?
Ну вот, да.
Ну да, давайте вот сейчас,
да, сейчас надо просто внимательно
тут немножко посмотреть, потому что тут, конечно,
есть интересные моменты.
Но если от нас теперь просят
сделать присваивание на вот таком
каком-то, допустим, под отрезке.
Что нам нужно тогда сделать?
Ну, нет.
Не совсем. Начнем со следующего.
Начнем с того, что вот эти вот отрезки
на краю давайте посплитим.
Ну, в принципе, мы даже
не будем от себя требовать, чтобы у нас
любые два соседних отрезка были
покрашены в разные цвета.
Вот. То есть мы просто вот попили.
И получается,
сведем задачу к тому, что наш запрос
покрывает в точности вот
целые отрезки.
Натальич, впереди я такая.
Давайте прогуляемся за о от количества
вот этих отрезков за логорифом,
которые внутрь попали,
и тупо их из сета выпилим.
Там каждый за логорифом.
А вместо них
вставим в этот сет
один новый отрезок, покрашенный
в этот сет.
Это решение, конечно,
амортизированное, потому что каждый
конкретный запрос работает не за логорифом,
а за логорифом умножить
на сколько отрезков
затронута запрос.
Вот.
Но с другой стороны
заметим следующее, что
убиваем на отрезков, как всегда,
не более, чем создаем.
Но обратите внимание,
новых отрезков на каждом запросе
мы создаем не более, чем
ну там сколько.
Ну да, в данном случае один.
Нет, ладно, вру, не совсем так.
Может быть три.
Ну ладно, может быть два.
Потому что есть такой случай,
допустим, у тебя запрос попал внутрь
какого-то отрезка, тогда тебе придется
вместо этого одного отрезка сделать три,
то есть плюс два.
Так что плюс два.
Ну как бы от единицы получается.
В самом начале же так и будет у тебя.
Как инициализировать такой сет?
Понятно, как у вас есть один отрезок
на нулевой цвет.
Вот.
Но получается, тем не менее,
вот такая амортизация. Создаем мы получается
отрезков не более, чем q,
то получается, что
суммарное время работы q log n,
правда она амортизирована, но зато онлайн,
обратите внимание.
Ну то есть не идеальный онлайн,
то есть как бы амортизированный, но прям вот онлайн,
то есть как бы мы здесь вообще никак
заранее не знаем,
какие запросы будут.
То есть вот такая вот, оказывается, тоже
неожиданная технология, что оказывается,
в такой задаче, казалось бы, надо делать присваивание
еще и на 10-9, но выясняется, что
сет вам прекрасно в этом помогает.
Вот.
Так вот, многие из этих технологий,
на самом деле, нам сейчас неожиданно помогут
решить просто весьма
достаточно потрясающую задачу.
То есть задача такая, дан массив,
в чем нам, нам еще даже упрощают
зачем-то задачу,
говорят, что этот массив является перестановкой.
И у вас есть
два запроса. Значит, дан массив,
он перестановка, хотя
на самом деле не так принципиально, но не важно.
И надо делать два типа
запроса, первый тип запроса.
Сумма
на подотреске.
Хотя, сейчас,
надо вспомнить какие там конкретные задачи.
Хотя, нет, там все что угодно,
можно сумму сделать, можно.
Хотя, знаете, как мы сделаем?
Мы сделаем немножко по-другому.
Сумму потом, наверное, тоже накрутим.
Но давайте
будем делать так.
Нет, ладно, давайте сумму.
Так, хорошо.
Давайте сумму на отрезке, но можно сумму,
там, по-моему, вообще был едва ли не дед
от поза, хотя можно и сумму.
Ну ладно, смешнее
другая операция.
Да, возьмите
подотресок и отсортируйте его, пожалуйста.
Чего?
Нет, еще круче. Гед
это, скажи, пожалуйста, что на позиции
пост находится.
Ну, хотя потом
можно и сумму сделать.
Вот такая вот.
То есть, на самом деле,
вот такая вот.
Чего?
Только
нет, смотрите.
Сейчас скажу.
Вот вы сказали, что это интересная
идея. То есть, давайте
хранить отсортированные массивы вот
так. И в каждом
из них там сами элементы
хранить, ну я не знаю, в каком-нибудь там
условном дикарте.
Или там, ну вот.
Или даже просто в сайте.
Потому что когда там
ну вот.
И казалось бы, когда к нам приходит запрос, то давайте
просто несколько отрезков объединим, как в переливайке,
подливая меньше в больше.
Да, это бы прекрасно
работало, если бы не одна мелкая
оговорка.
Потому что, к сожалению,
если бы надо было только сливать сеты,
это, конечно, шикарно бы работало.
Ну вот.
Гед, оно
делается так, значит, сразу
на уровне технологии. То есть, вот эти вот сами
по себе отрезки, то есть, не только сеты храним,
да, последствием сетов, а храним
сами по себе эти отрезки, как отрезки,
в той же самой дикартячке.
То есть, там
храним дикартячки, в каждой отрезке
храним там L, R и там указатель
на саму дикартячку.
Вот. Поэтому, в принципе, после
этого гед-отпоз делается действительно несложно.
Нет, ну почему?
Ну можно даже не две дикартячки,
то есть, есть как бы
ну как бы есть дикартячка поверх,
которая, ну вот, и как бы,
то есть, есть дикартячки, которые хранят элементы,
просто по сути, по сути, ордеры сет
такое, да, то есть, есть ордеры сеты, а есть дикартячка
поверх их.
Чего?
Ну, для того, чтобы вот искать, где
посовый элемент находится.
Каким бинпоискам? Вы же, это же не
массив же, они не фиксированы длинной, он же меняется,
поэтому вам эти отрезки надо в каком-то, где-то еще
хранить. А, ну
хотя ладно, если вы в явном, а, ну да-да-да,
если вы в явном виде или охраните, в общем-то, можно и
в сете хранить, да, не проблема.
Да, отрезки можно и в сете хранить, да-да-да-да-да-да.
Согласен, да,
дикартячка поверх не нужна,
нужна только сет. Вот, да,
это кайфово бы работало, если бы
не одно но.
Но называется, надо, к сожалению, эти
дикартячки не только объединять,
но и
пилить, к сожалению.
Чего? Кого мы будем
удалять?
Можем сказать, что
мы удаляем
этот отрезок и вместо него создаем чуть
меньше. И что?
Нет, ну как бы сами по себе отрезки
мы создадим быстро, это да.
Но проблема в том, что в данном случае
сплит вот этого отрезка
будет подразумевать собой и
сплит в этом,
сплит в вашем дикарте, ну или
вот сплит вот этого сета, где вы там
реальные элементы хранили.
Чего?
Ну, тогда
перестает
работать оценка переливайки.
Так,
ну вот это уже да, но тут есть маленькая
проблема, если не заморачиваться.
Редкий случай, когда дикартово дерево
начинает обызровать дикартячки.
Но когда?
Да, потому что есть
на самом деле две задачи, в которых
как бы без дерева отрезка вы не обойдетесь.
Да, первая задача была
кстати тоже на перестановку.
Там задача была что-то типа
знаете задача,
дана перестановка, и вам нужно делать
в ней свапы. После каждого свапа надо
найти количество инверсий в перестановке.
Вот я не знаю,
как решать эту задачу без дерева отрезков.
Точнее без дерева, ну вот.
А с деревом отрезков, пожалуйста.
Делаем дерево отрезков, где на каждом
подотреске храним дикартячку из всех элементов,
которые там лежат.
И тогда с помощью этой штуки,
когда вы делаете свапы, то вам
по сути надо посмотреть
все элементы между ними свапаемыми
и посмотреть, сколько из них попадают
по значению между ними.
Получается, находите логарифм дикартячек,
в которых вы это все находите.
Как всегда я какие-то вещи
быстро рассказываю,
может быть какие-то вещи надо
просто помедленнее рассказать.
А то нет, понятно, что есть умные люди,
которые уже поняли все, что я скажу
в ближайшие полтора часа.
Но если это к вам не относится,
то лучше меня тормозить немножко.
На какие запросы?
Да, мы храним дерево отрезков,
но как отвечаем на запросы?
Давайте думать.
Вот у нас жили-были
элементы x и y, которые находятся
на позиции LR.
Пока предположим, что x меньше y.
Тогда смотрите,
как меняется количество инверсий.
Давайте подумаем. Заметим так.
Во-первых, появляется плюс одна инверсия
от самих y и x.
Теперь заметим, что что еще меняется?
Заметим, что вот эти элементы
сами по себе на запросы
никак не влияют, потому что
инверсии с ними никак не поменялись.
А что происходит между ними?
Если элемент меньше x и y,
то он создавал инверсию
с x И не создавал
инверсию с y.
Если элемент больше y, то же самое.
А если он по значению меньше
от x до y,
то, получается, он ни с кем
из них не создавал инверсию,
две инверсии создаст. То есть получается количество инверсий увеличится на один
плюс два умножить, насколько на этом подотреске находятся элементы между их
сами игроками. Но как это найти? Но если мы храним дерево отрезков дикартячек, то есть
типа на каждом подотреске храним дикартячек у всех элементов, которые в них есть,
то тогда получается, что мы берем этот подотрезок LR, разбиваем его на логарифом отрезков,
в каждом из этих отрезков лезем в дикартячку и в дикартячке находим сколько элементов
дикартячки находится между их сами игроками. Получается лог квадрат. Здесь вот именно тот
факт, что у нас есть дерево отрезков, это с фиксированной структурой как бы позволяет
нам гарантировать, что это лог квадрат. Внутри, ну можно дикартяч, можно ордерет сет, можно
овель, пожалуйста. Но заметим, что как бы условно говоря, можно хранить дерево отрезков
дикартячей, но хранить дикартяч дикартячей у вас не получится, потому что придется сплитить,
мержить будет не тривиально. Потому что как бы, да, заметим, что как бы элементы здесь,
это элементы отсюда, там объединенные с элементами отсюда. То есть на каждом
спите мерже это делать будет больно. Вот, а с дерево отрезком будет как-то надежнее.
Вот, это вот такое. Значит, это вот такая вот классическая задача, где вот оказывается,
что дерево отрезков помогает. Максим, что тут, да, можно было пытаться сделать дерево
фенвика в дикартчика, кстати. Вот, ну вот, делать то же самое, но на фенвике.
Нет, просто надо поддерживать в онлайне количество инверсий. Здесь мы просто посчитали,
что скажем свапом, анопами. Да, всего, конечно. Нет, всего количество инверсий на подотреске,
конечно, там уже посложнее задача. Так вот, вернемся к задаче про сортировочку.
Когда надо еще делать сортировочку. Там просто фишка такая. То есть идея действительно может
быть такая, что давайте пытаться, ну как бы действительно посплитить дикартовое дерево
действительно несложно. А вот помержить два дерева сложно. Почему сложно? Потому что выясняется,
когда вы мержите дерево, там неверно, что у этого все значения меньше, чем вот этого. И,
то есть, придется их как-то вот там аккуратно пересекать. Но это можно как-то сделать более
или менее там жадно. Как можно такое мерж дикартового дерева написать? Ну, во-первых,
там мерж, и так вот делаем мерж двух дикартовых деревьев, но не гарантируем. Считаем, что элементы
у них перемешаны как угодно. Как тогда это можно делать? Тогда мы говорим так, у кого из них
приоритет меньше, ну допустим, у этого. Тогда оказывается, что тут, вот тогда что надо делать?
Объявляем вот это корнем, и тогда здесь у нас получается мерж двух левых деревьев типа вот
этого и этого. И здесь у нас там мерж двух деревьев вот этого и этого. То есть, действительно,
примерно вот так. Но там соговорка, что в каждый момент времени мы для каждого дерева храним,
на каком диапазоне там изменяются элементы. Потому что, если выяснится, что надо объединить
элементы, ну там просто, если выяснится, что там все элементы тут меньше, чем все элементы тут,
то в принципе их тогда мержить становится сильно проще. Логично, да? Вот. То есть, это мы как-то
учитываем и действительно. Ну и кажется, что действительно можно ввести там какой-то потенциал.
Вот какой-то потенциал, но там утверждается так, что можно действительно ввести какой-то потенциал,
я даже не помню, который вам покажет, что там амортизированная стоимость тогда получает
всех таких операций. Это там то ли лог-квадрат, то ли лог-куп. Ну да. Ну потому что скажет,
но там будет фишка в том, что каждый конкретный мерж на самом деле здесь будет там. Каждый
конкретный мерж будет работать задолго, естественно, да? Ну понятно, что если вы там 1, 3, 5, 7, 9 мержите с 24, 8, 6, 8, 10,
то это по-любому за линию будет. Вот. Но как бы суммарно, вот если там взять, то есть там какой-то
потенциал, там пользующийся тем, что у нас там по количеству отрезков, по элементам в них,
там можно там как-то показать, что там вроде то и лог-квадрат, то и лог-куп, но это будет черная магия.
Дерево отрезков тут неожиданно побеждает. Просто вместо того, чтобы делать там какие-то сливаемые
дикотехи или да, сливаемые красночерные деревья, оказывается, нужно сделать сливаемые неявные ДОшки.
Да, то есть идея, то есть смотрите, то есть, но идея, но вот, то есть, действительно, идея такая,
то есть мы храним прям в явном, то есть в явном виде, то есть каждый отрезок мы храним в виде
просто неявной ДОшки, причем неявной прям от 1 до N. Ну с той лишь разницей, что, конечно,
не нужны отрезки, на этот раз мы реально не храним. Понятно, да? Нет, ну чего, но там просто,
но идея будет в том, что, нет, вообразим себе следующее, что давайте искать, то есть скажем так,
каждый сет чисел от 1 до N можно хранить в виде ДОшки, в которой там числа, которые есть, помещаем
единичкой, остальные ноликом, да, и скажем, и на каждом подотреске храним там, скажем,
сумму на отрезке, да, вот будем этим заниматься, только если на отрезке сумма ноль, мы его в явном
виде не храним. Понятно, да? Чего? Ну почему, ну иногда, но если оно пустое, ну бывает пустое,
бывает, если в нем хранится только одно число, да, тогда там, тогда это неявное дерево будет
выглядеть как там какая-то вот такая вот цепочка, вот, если у вас там в сете одно число хранится,
да, то есть там вот последовательность единичек, да, неявное, что важно, да, да, что важно,
вот, и сейчас, да, то есть наша задача сейчас, то есть в принципе, да, то есть наша задача,
то есть смотрите, то есть да, идея такая, то есть вот этот вот сет от сортированных элементов мы
будем хранить, то есть мы будем хранить в виде вот таких вот деревьев, и тогда получается мы
победим, если нам научиться на этих деревьях делать какие операции, ну отрезки это сеты,
эти сеты мы храним как деревья, ну можно и так сказать, хорошо, ну потому что, если бы это было
явное дерево, по сути, на нижнем уровне был бы в явном виде бицет, вот в этом понимании, да,
так вот, и значит с этими деревьями, что нам нужно сделать, а нужно сделать маленькую простую вещь,
то есть такие два запроса, первое, посплитить какое-нибудь вот это вот дерево по элементу к,
что значит посплитить, ну это означает, ну в классическом понимании, то есть там первые
к элементам должны отправиться в одно дерево, а все остальные в другое, или в принципе, что то
же самое, идентично, то есть можно сплитить по ключу, то есть там дано число х, пожалуйста,
все меньше либо равные х мы отправляем в левое дерево, остальное в правое, да, и второй тип
запроса, это неожиданно мерч, даны два дерева, объедините их, пожалуйста, в одно, то есть ну даны
два, ну да, можно было вместо мержа написать там юнион какой-нибудь, и парадоксально, ну то есть это
может показаться парадоксальным, но мы не будем это делать, то есть на самом деле мы, но мы на самом
деле не будем это делать путем, казалось бы, напрашившимся путем, давайте посмотрим у кого
элементов меньше, давайте и по одному их добавим в больше, нет, мы будем это делать гораздо более
хитрым способом, так, но прежде чем мы к этим способом приступим, нужен ли нам перерыв,
но просто диспозиция такая, после того как мы это обсудим, мы там займемся там всякими деревьями,
нет, на этот раз как граф, а не как деревьями поиск, хотя с другой стороны идея, которая тут
вытекает, особенно ее анализ может оказаться не совсем тривиальной, так что давайте все-таки
перерыв теперь сделаем, как же делать сплит и мерч у деревьев отрезков, да, казалось бы,
что да, зачем сплит и мерч, мы ради этого дикартячки изобретали, чтобы там делать,
а вот выясняется, что нет, значит, ну давайте думать, как вообще сделать сплит пока, так,
ну во-первых, давайте, как мы уже сказали, давайте превратим это в, нет, хотя нет, даже не будем
превращать, даже этого не нужно, значит, как сделать сплит, то есть мы хотим отсплитить там левое
ка элементов, соответственно, от всех остальных, как же это сделать, так, ну давайте так, это я
тоже сотру, потому что как бы тут мы уже, как бы если мы научимся делать это, то мы вроде уже
победили, да, то есть пока у нас просто задача, да, но, то есть давайте так, то есть у нас есть
набор из какого-то количества сытов, да, в который суммарно лежит n элементов, ну там, ну помните
самые числа, то есть у нас там числа от одного до n, пока у нас простой интерпретация, распиханы
по нескольким сытам, и мы с этими сытами хотим делать вот такие операции, да, причем хотим,
чтобы эти сыты хранились в не, там, хотим, чтобы эти сыты хранились в неявных д.о.шках, да, нам это
для чего-то надо, то есть как бы, да, метод, что это мы там делаем, типа не работает уже, вот, и так,
значит, как же мы будем, давайте вот начнем с простого, делать сплит, ну вот тут идея какая, да, да, да,
да exploring. Да-да, значит, смотрите, я все-таки на всех ändах кучу расскажу,
потому что, да, потому что понятно кому-то понятно, а потом... ну да-да нету, ну, spring, во-первых,
с амминией, во-вторых, там потом еще fairy tale, что-то там на самом деле, да, там,
тут-то какое-то он Alexander, там понимаю, что происходит, понимает от силы шесть,
7 человек в аудитории нет это кстати реальные отзывы там в прошлых поколениях такие были поэтому
поэтому поэтому извините но я на всякий случай вот подробно рассказываю потому что тут вот
собственно вот больше действительно эффект такой есть потому что дайте как бы дашу там в
коридоре начинайте начинайте сублимации супергаг очень резистентно и там и кажется что все хора
вокруг да да да хотя этот эффект создается тем что так делают буквально там максимум 4 человека
ну просто они хорошо рассредоточены по всей аудитории вот не надо потом дать歡ятия то есть это
но то есть просто там эффект крикливого меньшинства то есть на самом деле как бы то есть на самом деле
как визит а vaccine что там так иногда может показаться не но там какие то лучшие все
время всем недовольны всем критикуют хотя на самом деле выяснито что просто есть два конкретных
человека который все время소 будет замещается то есть на самом деле да то есть как бы и по
по-хорошему понятно, что их мнение не является прям мнением всего коллектива, но в смысле,
ну я знаю, в смысле, когда очень-то работаешь, да обычно этих людей прекрасно знаешь, да,
нет, ну как сказать, нет, ну как сказать, ну целенаправленные,
нет, нет, нет, нет, нет, нет, дело не в этом, там, собственно, нет, с ними ничего страшно
ни произошло, там, собственно, соответственно, просто я говорил как-то, не потому что,
просто потому что такое иногда бывает психологический эффект, это просто.
Как бы я призываю, поп glorify, мы как бы не бояться, если там вот, вы там пришли в аудиторию,
вам кажется, что все все понимают, а вы не понимаете. То есть помните, на самом деле там понимающих не больше вас, гораздо там на самом деле сильно больше, чем вы думаете.
Вот, поэтому вот. Я, собственно, только к этому. Вот. Так вот, как будем делать сплит? Так, ну идея такая.
Так, вот я хочу, ну вот. Ну, значит, на самом деле, значит, есть у нас вот эта вершина, то есть мы знаем всего сколько элементов.
Ну, во-первых, можно сказать так, что если тут элементов ровно к, ну если меньше, ну мы их считаем шукатными, но если их ровно к, то как сделать сплит?
Да очень просто. Вернуть два дерева. Одно вот это, второе пустое. Все. И больше ничего делать не надо.
По количеству. По количеству.
По количеству. Вот. Дай переча.
Но если тут их оказалось больше, чем к, то тогда какая тут идея неожиданно возникает?
Давай возникает следующая идея. Так, мы отправляемся в ребеночка.
И думаем, вот в левом ребеночке элементов меньше, чем к, или больше, чем к.
Допустим, выяснилось, что тут элементов больше либо равно, чем к.
Тогда идея такая.
Значит, вот это вот мы торжественно сплитим.
То есть у нас тут появляется, вот я даже нарисую в дикартякичном стиле, тут либо там к элементов, тут все остальные.
Правда, единственное только оговарка, что у меня дерево отрезков не на 1н, а на 1н пополам условно, да?
Ну, потому что, ну, в смысле.
Ну, смотри, что такое дерево отрезков для элементов 1н?
Это два дерева, это как бы один корень, который ссылается на два дерева отрезков. Одно для 1н пополам, другое n пополам плюс 1н.
То есть обобщение это дерево отрезков для проотреска lr.
Понятно, да? Ну, если l равно r, то это один элемент.
То есть поэтому давайте тут посплитили, значит, на просто более низком уровне.
То есть мы получили вот это вот дерево 1 и дерево 2.
Ну вот, и допустим, давайте так, это была, допустим, какая-нибудь вершина t, а это была вершина v, это было дерево t.
Тут какое-нибудь висело, да? Тогда какой у нас будет ответ на задачу?
Ответ на задачу будет такой, в левом дереве у нас будет дерево t1 и свежесозданная вершина.
Вот свежесозданная вершина, у которой слева будет висеть вот эти t1, а справа пустота.
Ну, это для того, чтобы сделать дерево именно порядка там вот 1н, да?
Вот. А как будет выглядеть второе дерево?
Второе дерево будет выглядеть так. Это будет прям та же самая вершина v, на которой будет висеть вот это вот дерево там.
То есть вот это вот даже я черненьким нарисую, то же самое дерево t, которое было раньше.
А слева к нему мы теперь подвесим просто вот это вот типа t2.
Вот такой сплит.
Нет, ну здесь нет. Вот здесь новую вершину создали, вот она.
А здесь уже не надо.
Потому что эта вершина продолжает отвечать под отрезок 1н.
Единственное, что в ней кое-что поменяется, это конечно вам придется пересчитать, сколько тут элементов.
Ну и конечно же, да, если тут оказалось 0 элементов, то лучше конечно это, то есть лучше конечно тут повесить крестик.
Ну да, ну да.
Есть и такое подозрение.
Так что вот такая вот красота.
То есть обратите внимание, то есть на самом деле оказывается посплитить неявное ДО оказывается очень просто.
То есть обратите внимание, да, ну я правда рассмотрел только один случай, но я думаю вы же мне наверное поверите, что второй случай рассматривается симметрично.
То есть разница будет в том, что здесь отсплитивать, есть тут меньше, чем k, то есть здесь надо отсплитить не k элементов, а k минус сколько было тут, но это классика.
То есть получается сплитить очень просто.
Обратите внимание, мы это сделали прям за честный логарифм.
И создали, кстати, обратите внимание, не более чем логарифм, даже не от логарифм, а логарифм новых вершин.
Видно, да?
Очень удобно.
Вот такая вот неожиданная у нас красота.
Вот, ну значит сюда, то есть получается сделали логарифм, создали логарифм новых вершин.
А теперь его величество мерч.
Как же сделать мерч?
А?
Как сделать мерч?
В тупую.
В тупую, супер.
А в тупую это как?
Ну берем корни, сливаем.
Детей припустим и сливаем, если они есть.
Да, внимание, вопрос.
Какими способами можно из этого набора слов собрать алгоритм?
57 классно.
179, но я боюсь там и 2007 зайдет.
Да, непонятно.
Ну, значит тут в тупую аккуратно, это не Z функция, где слово в тупую как бы дает автоматический смысл.
Так, ладно, поднимите руки, кто кому рассказывали Z функцию с использованием слова в тупую.
Ну, я не знаю, нет, мне просто, просто мне все время рассказывали Z функцию так.
Ну, там как бы жила была строка S, мы считаем Z функцию.
Мы там дошли до какого-то момента и храним еще отрезок реле, который заканчивается позже всех.
И алгоритм звучит так.
И алгоритм звучит так.
То есть если там R меньше и, там Z в тупую.
То есть насчитываем Z в тупую.
Значит LZ.
Ну, там дальше что-то типа и в Z, и плюс L меньше, чем R минус и, там Z в общем равно R минус и.
Там LZ, значит пишем Z IT равно Z равно R минус и.
Далее в тупую.
Да, далее в тупую.
Мне в свое время там это видимо в каком-то облахматом видимо 2006, там каком-то седьмом, плюс минус один.
Вот объясняли вот именно так.
С кодовым словом в тупую.
Вот.
А ну или я себе это так записал, я не знаю.
Ну вот.
Ну не важно, ладно там у нас хорошие времена были, да.
Ну вот.
Так, ну ладно, до этого мы в следующем году еще дойдем.
Вот где-то как раз через годик, наверное.
Да.
Не, ну не потому что это сложно, а потому что это строчки.
Да, просто у нас блок строчек идет именно там.
Вот.
Ой, геометрия.
Геометрия это интересно.
Нет, это все интересно.
Знаете, неинтересных тем тут особо нет, если честно.
Не, ну как сказать.
Не, ну ладно, это отдельная песня.
Так вот.
Итак, как делаем мерч?
Да, тут слово в тупую как бы однозначного смысла не дает.
Оно говорит нам следующее, смотрите.
Итак, пришло нам желание померзать два дерева.
Т1 и Т2.
Так, ну начнем с простого.
Ну во-первых, давайте скажем так, что если одно дерево оказалось крестиком,
то мы тупо возвращаем второе и не паримся, правда?
Вот.
Но что делать, если они оба оказались не крестиками?
Не крестиками.
Тогда, значит, идея такая.
Так, значит, заметим, что тут висело дерево Т1-1, тут висело дерево Т1-2.
Тут висело дерево Т2-1, тут висело дерево Т2-2.
Тогда возникает неожиданная вещь.
Значит, давайте для симметрии мы скажем так, давайте убьем на этот раз родителей в какой-то веке.
Вот.
А вместо...
Нет, ну ладно, мы добрые, не в смысле прям убьем.
Нет, мы их круче сделаем.
Мы их объединим.
Как бы, то есть у нас был, как бы, как бы, было у нас два дерева, у каждого был родитель.
Мы теперь этих двух родителей объединим.
Такой будет у нас такой супер родитель.
Вот. Слева к нему мы подвесим.
Мы подвесим.
Ладно, вот так вот, подвесим.
Результат объединения деревьев Т1-1 и Т2-1.
Да, ну то есть прям вот рекурсивно запустим мерч от Т1-1, Т2-1.
Ну, естественно, для своего подотреска, да, своего уровня.
А справа мы подвесим результат объединения Т1-2.
И Т2-2 тоже вот рекурсивно.
Ну и, конечно, в корне еще придется пересчитать, сколько элементов.
Правда, мы это могли сразу сделать, кстати, когда объединяли.
Если тут 57 элементов, а тут 179, значит, тут их будет 226.
Нет, ну как, пересекаться, ну как подотрески, да, но в плане, что у нас...
Но я скажу так, смотрите, во-первых, в нашей конкретной задачи у нас гарантируется, что цветы не пересекаются.
То есть у нас система не пересекающихся множеств.
Да, знаете, это система не пересекающихся множеств, но не СММ.
Система не пересекающихся деревьев.
Да, ну, нет, ну, то есть есть множество, другой вопрос, как мы их храним.
Вот.
Ну вот, но на самом деле я утверждаю, что...
Ну так, мы себе подложим на будущее, но я скажу так, я утверждаю, что если бы хранили мультисы три чисел от одного ДН,
ну, как хранить мультисы?
Так же, только в каждом элементе на нижнем уровне мы храним не единичку, а сколько этих элементов там, да?
Вот. И тогда, ну вот.
То есть, ну вот, в принципе, технология от этого принципиально не поменялась.
То есть я утверждаю, что на самом деле это ни на что не повлияет.
Ну, для того, чтобы убедиться, что ни на что не повлияет, я, конечно, должен сейчас провести анализ, почему это работает адекватно.
Вот.
Да, то есть хотя тут, видите, рекурсивные какие-то два мержа надо запускать, там что-то объединять, ну объединять тут за от единицы.
Но на самом деле у нас произошло очень важное событие.
У нас уменьшилось количество вершин.
Видите, было два корня, стал один.
Ну, то есть понятно, что при реализации вы, конечно, можете просто там убить реально только этот корень, а в этот корень, на самом деле, просто уже там прибавить что-то.
И там подвесить вот эти объединения.
Ну, это уже деталь.
Скажите, как называется деталь реализации?
Спрашивается, почему это все работает за какую-то адекватную синтуетику.
Вот я утверждаю, что оно работает за.
Но для этого нужно просто ввести хороший потенциал.
Как уже с самого начала нам и говорилось.
Но какой?
Да, потенциал, внимание, тупо, количество вершин в, да, в деревьях, да, я могу тут добавить слово суммарное.
Я даже напишу не в деревьях, а в деревьях.
Да.
Вот так.
Да, не совсем формально, но как бы, но суть, хотя нет, здесь еще рано, мы еще не говорили о деревьях как графах, поэтому тут как бы слово дерево тут не выдадут непонятки.
Вот.
Вот.
Вот, оказывается, это все.
Но теперь давайте думать.
Как у нас все работает относительно вот такого потенциала?
Так, ну.
Плюс лог.
Ну да.
Ой.
Ну да.
Так, хотя.
Слушай.
Так, ладно.
Потому что для того, чтобы нам просто это красиво делать, я тут понял, что имеет смысл.
Давайте вот так сделаем.
Нет, я пишу то же самое, просто как бы мне удобно будет, если я это пишу другим цветом.
Ну, да.
Ну, да.
Ну да.
Ну да.
Ну да.
Если я это пишу другим цветом.
Вот.
То есть как бы.
Вот.
Так.
Ну понятно, Даша, изначально мы, конечно, тратим N log N времени для того, чтобы создать N сетов в каждом по логарифму вершин.
Вот.
Теперь значит сплит.
Он работает за честный логарифм.
И количество вершин, которое добавляется, тоже плюс логарифм.
Ну, точнее того, получается, как бы логарифм, то есть учетная стоимость относительно этого потенциала тоже логарифм.
Так.
Теперь мерш.
Вот.
Но теперь на самом деле появляется такой неожиданный чит.
Вот.
Чит на самом деле, здесь вот тут как нот.
Но основная идея здесь заключается в том, что, смотрите, что мы здесь делаем?
Мы делаем два рекурсивных мержа.
Вот.
Ну, по сути.
Ну, по сути, два рекурсивных мержа.
И какое-то единичное действие.
Ну, теперь маленькая приятная штука.
За это действие мы уменьшаем потенциал на единичку.
Видно, да?
То есть это означает, что учетная стоимость конкретно этого действия, включая, может быть, накладные расходы на сам запуск двух рекурсий.
Ну, ноль.
Ну, в принципе, на самом деле отсюда уже легко вывести, что на самом деле учетная стоимость этого мержа ноль.
То есть даже не логарифм.
Мы делаем операции от двух вершин в самом деле, но при этом удаляем одну.
Нет, мы делаем О от единицы операции.
Но для того, чтобы нас посмотреть на эти две вершины, удалить из них одну.
Ну, не важно, скажем так, удалим ли мы две, создадим одну, или одну удалим, но факт остается фактом.
Потенциал уменьшится на единицу.
И делать мы тут будем от единицы операции.
Ну, если мы делали уже две операции, то это было бы долгий.
Так, но это называется, как бы вы потенциал, вы за каждую вершину дуете рубль, доллар или евро.
Это называется.
То есть это называется курс валюты.
Естественно, мы будем считать, что, скажем, можно говорить так.
То есть мы будем говорить так.
Давайте на каждой вершине будем хранить монетку.
Монетка будет достаточно жирной, чтобы оплатить все вот эти вот удаления объединения и радости.
Но на самом деле, да.
Поэтому, конечно, говорить, что совсем мы прям все сделаем, совсем за ноль нельзя.
Но мы вынуждены сказать, что это все-таки один.
Почему?
Потому что, как это ни странно, самая жирная в этом смысле операция, оказывается, операция, когда вам предложили объединить два сетта, один из которых пустой.
Там никакой амортизации не происходит.
Это, честно, за вот единиц происходит.
Да, смотрите.
А вот тут смотрите внимательно.
А теперь идея такая, что, действительно, у вас все рекурсивные запуски тогда дальше делятся на как бы тривиальные.
Тривиальные.
Ну, тривиальные, когда вам там передали два сетта, один пустой.
И нетривиальные, то есть все остальные.
Но теперь заметим, что нетривиальный мерш можно на самом деле в вот эту вот единицу более высокого уровня тоже включить.
То есть, можно вообразить себе это так.
Вы тут делаете два рекурсивных запуска, но в каждом запуске, говорите, вот, вообразите, что в коде вы пишете так, что если одно из этих деревьев пустое, то никакого рекурсивного запуска не происходит.
Вешаем то, что есть.
А если там оба они пустые, ну, тогда рекурсивный запуск выпускает.
Вот вообразим себе такое.
Тогда замечаем, что каждый рекурсивный запуск будет уничтожать одну вершину.
Прямо реально.
Вот.
Но тогда, и тогда получается, что мы сделали сколько-то рекурсивных запусков и убили ровно столько же вершин.
Следовательно, получился ноль.
То есть, единственное, когда получается эта единичка, это вот на самом-самом верхнем уровне мы не можем сказать, что как бы у нас там, наш родитель нас оплатит.
Вот так.
То есть, здесь такого нет.
Поэтому мы вынуждены заключить, что учетная стоимость мержа все-таки бывает единицей.
Но как ни странно, видите, с точки зрения анализа получилось так, что вот, когда одно дерево пустое, тогда получается единственный раз в жизни, когда мы реально, когда учетная стоимость реально единица.
Потому что, как бы, если надо объединять два непустых дерева, то вот как раз, ура, радость, учетная стоимость моль.
Ну, не более нуля.
Ну там, ну там, конечно, от конкретного курса зависит.
Понятно, что если курс задрать, можно там и в глубокий минус уйти.
Ну, за счет того, зато здесь будет более жирный логарифм.
Как бы, но это понятно, это уже тот, это уже все такие вещи.
То есть, ну, таким образом, как вы уже поняли, то есть, получается, мы на этих n запросах, то есть, если у нас, как бы, бассейн состоит из n элементов.
То есть, все элементы состоят от одного до n, то тогда получается, суммарное время обработки q запросов на них получается, ну, с учетом того, что мы еще в самом начале что-то сделали, q плюс n на лог.
То есть, никаких, ни квадрат, ни q, оказывается, просто честный логарифм.
Помните, вот, предельно честный тут даже вот.
Чего?
Не, ну, а, ты знаешь, а за счет чего тут, кстати, долго?
Может быть, за счет, разве что, ньюд элитов.
Ну, нет, ну, скажем так, технологии, там, ньюд элит, понятно, что, да, сами по себе ньюшки работают долго, но есть стандартный олимпиадный способ, как от этого избавляться.
Да, способ называется, да, создать глобальный буфер.
Я думаю, там, думаю, на c++ мы уже столкнулись с таким понятием, как колокатор.
Нет? Ну, столкнетесь.
Нет, ну, столкнетесь, потому что, да, он, как бы, базируется на том, что тоже, то есть, по умолчанию, когда нужно создать во всех, там, сетах новые вершины, действительно вызываются ньюд элиты.
Ну, вот, но иногда тоже выясняется, что это не самый оптимальный способ, может быть, там, пользователь умеет создавать память лучше.
Поэтому, там, во все сеты, у всех сетов, на самом деле, есть дополнительный шаблонный параметр alocator.
Ну, фактически, это alocator, это какое-то нечто, что умеет там создавать новую память.
Вот, ну, собственно, вот, ну, это в качестве анонса, потому что, я думаю, там, у миссирина вы почти, наверное, собственно, там свой alocator.
То есть, какой-нибудь шаблон с учетом alocator напишите обязательно.
Ну, вот, и, как бы, действительно, может быть, полезная штука.
То есть, вплоть до того, что, на самом деле, знаете, вот, в яндексовых библиотеках, известно, там, запрещено пользоваться STD.
Ну, ладно, более точная формулевка.
Запрещается пользоваться, прям, вызывать STD, а там, что-то напрямую.
То есть, вместо этого, в яндексовске, там, по крайней мере, в Аркадии, принято использовать там специальные модификации.
Которые называют себя Y-вектор.
Или Y-hashmap.
Или там, что-нибудь еще в этом роде.
Да.
Но, на самом деле, если, если копнуть, как они реализованы, то, по факту, так, ну, вы же уже знаете, что такое наследование, да?
Так вот, по сути, так вот, на самом деле, вы можете обдумать, что там, по сути, окажется, что там Y-вектор.
То есть, там, класс Y-вектор.
Это просто тупо публичный наследник, значит, STD-вектора с правильным, там, или там, вот, ну да, ну да.
То есть, просто публичный наследник бывает там.
Ну, хотя, это Y-вектор не уверен, там, как бы, с векторами.
Хотя, вот, хотя, скорее всего, там будет Y-вектор.
Да, это публичный наследник просто вектора с специальным, с специальным локатором от Яндекса.
Или там, hashmap тоже, на самом деле.
Там anordered map, но там с правильным подсунутым компара, вот именно, локатором.
Вот и нод.
Вот, собственно, и все.
Ну, там, конечно, по-разному бывает, то есть, нод.
Но это так, это вот будет край нод.
То есть, еще один нод с того, что там у вас на курсе по C++ еще будет.
Так что, будет это, это у вас все будет еще в больших подробностях.
Вот.
Вот.
Ну, потому что, ну, T1,1 это что?
Это значит, вот в этом сете какие элементы у нас на отрезке, там, типа, 1DN пополам, типа.
И тут, как бы, какие элементы были от 1DN пополам.
Поэтому объединяем вот именно их.
Нет, по величинам.
По величинам.
Потому что в этом сете должен быть, тут должен быть все элементы от 1DN пополам.
Тут от 1DN пополам плюс 1DN.
Ну, соответственно, поэтому так.
Вот.
Так что, вот, получилось такое вот не очень, как-то вот действительно не очень что-то страшное.
Ну, вот, но работает вот за n log n, хотя вот действительно, то есть, есть модификации там.
То есть, можно попробовать это сделать на дикотячках.
Но, как бы, скажем так, тут я, конечно, сейчас у меня будет информация из тыквы, за что купил, за то продаю.
Но сообщили следующее, что где-то нокут в фольсусах.
Там называется вроде, там есть статья, в которой там доказывается, что если делать это там как-то хорошо на дикотячках, то это будет то ли log квадрат, то ли log куб.
Вот, называлось даже имя Александр Шаховцов.
Вот, да, есть, да, есть у нас такой товарищ.
Вот, так что, при желании, можете там покопать, найти.
Вот.
Да.
Так, ну, если что, да, представитель команды log grand conjecture, если что.
Это одного из наших финалистов.
О, супер.
Ну, вот.
Так же соответственно.
Вот.
Так, ну что, есть тут вопросы?
Да нет, наверное.
Хорошо.
Так что вот, да, действительно, вот такая вот красота.
Здесь могла бы быть, вот тут, да, как видим, вот тут дерево отрезков тут неожиданно побеждает всякие дикотячки.
Все-таки, знаете, вот иногда фиксированная структура иногда лучше, чем нефиксированная, то есть вот какие-то вот свои козыри у нее тоже есть.
И это, и это не только не асимпатическое.
Вот.
Так.
Ну, а теперь, значит, пришло время попробовать усилить все эти, все эти, значит, куда еще можно усилить все эти рискушки и рэмкушки?
Ну, естественно сказать, а давайте, ну вот, ну следующая идея, которая возникает, это, естественно, а давайте делать это на, не на массивах, а на деревьях.
Ну, логично, да?
Ничего?
Ну, там немного другое.
Значит, смотрите.
То есть будут у нас такие, да, деревья.
Вот.
Вот.
Так.
Ну, значит, а, ой, летающие.
Так.
Вот.
Ну, то есть, в принципе, давайте себе представим, что нам дано дерево.
Только вот, начинай с этого момента, начинай путься, потому что как бы говорим, что дерево, то есть это не в смысле вот этого дерева поиска, который у нас было, или там вот это дерево отрезков.
А вот честное, вот это вот графовое, что дерево это такой связанный граф без циклов.
Вот.
То есть какое-то вот дерево.
А, еще есть понятие подвешенное дерево.
Что такое подвешенное дерево?
Это дерево, у которого в явном виде выделено одна вершина, которая называется корнем.
Вот.
И тогда у этого дерева автоматически индуцируется понятие потомки и предки.
Логично, да?
Вот.
Вот.
И вот с этими деревьями иногда хочется как-то поработать.
Вот.
То есть дано какое-то дерево.
Ну, в принципе, с нашей точки зрения, на самом деле, то есть как бы если обобщать задачи РСК и РМК, там как бы можно в разные стороны действительно на эту тему пойти,
то хочется иногда сказать что-нибудь в духе,
ну там, то есть что-нибудь в духе, что давайте на каждом ребре, например, написано какое-то число.
На каждом ребре написано какое-то число, и мы там хотим находить суммы на путях, например.
Или минимумы на путях.
Или там делать какие-нибудь обновления на путях.
Или что-нибудь еще в этом роде.
Вот, понятно, да?
Вот.
Ну, тут действительно много чего тут можно действительно копать.
Вот.
Так.
Но, пожалуй, давайте.
Ну, то есть какие-то такие вот запросы хочется делать.
Но начнем мы, пожалуй, не с этого.
То есть раз уж мы впервые столкнулись с деревом, то есть давайте, может быть.
Хотя...
А, нет.
Ладно, все-таки отложим.
Ладно, все-таки давайте, ладно, сосредоточимся на РСК.
Вот.
Ну, с чего вообще, конечно, хотелось бы начать.
То есть у нас есть какие-то чиселки, да, допустим.
И мы хотим там искать какие-то суммы.
То вообще говоря, естественно, ну вот.
То как бы, как там найти какую-то сумму на вот пути.
Вот, допустим, вот от этой вершины до вот этой вершины.
Ну, как вообще, как устроен любой путь?
Он устроен так.
Мы от вершины идем вверх до какого-то вот предочка.
Да?
А потом же этого предочка не менее неумолимо начинаем спускаться в другое под дерево.
Да?
То есть два пути имеют место от потомка к предку.
К одному и тому же предку.
Ну, единственное так, что один какой-то из этих путей может быть, конечно, нулевой.
Да?
Вот.
Ну и, соответственно, вот.
Вот.
Ну и, соответственно, то есть можно заметить, что действительно этот предок является, так сказать, самым глубоким общим предком вершин УИВ.
Да?
Поэтому, конечно, очень неплохо было бы, конечно, для того, чтобы тут как-то работать с деревом.
Ну, как минимум вести, то есть можно уже тут вести понятие ЛСА.
Вот, в общем-то, уже и мотивировочка.
Да?
Вот появляется понятие ЛСА.
Ну, я думаю, там.
Да.
Вот.
Да.
То есть, как минимум, уже было бы неплохо.
То есть неплохо, как-то его искать.
Ну, доживем.
Ну, как бы, да.
Ну, тем более, что...
Ну, да.
Но тем более, что, как бы, далеко не всегда нам, на самом деле, это вообще, то есть это вот, как бы, ЛСА сам по себе поможет, как человек.
Как черный ящик.
Потому что...
Ну, вот, смотрите, давайте, там, с чего бы нам хотелось начать.
Ну, предположим, пока, по крайней мере.
То есть, естественно, мы там это обсудим.
Но, как бы, предположим, что мы умеем искать для любых двух вершин ЛСА, как черный ящик.
Ну, да.
Может, допустим, даже за единицу.
Тогда предположим, что у нас есть...
Теперь у нас есть задача.
Допустим, у нас есть задача статик РСК.
Значит, смотрите, тут очень внимательно.
Потому что задача, о которой я сегодня буду говорить, по умолчанию, буду боссом стаблазом написать сразу Хавиллайт и не париться.
Но тут это будет называться горе от ума.
Ну, потому что есть Хавиллайт.
Чуть позже мы сегодня поговорим там.
Нет, ну, давайте так, поделите руки, кто знает, что такое Хавиллайт Декомпозицион.
О, какая неожиданность.
Вот.
Так, хорошо, поделите руки, кто хотя бы раз в жизни писал Хавиллайт Декомпозицион.
А, уже нет.
А, уже не все.
А, уже не все.
Вот.
Ну, хорошо.
Ну, ладно.
Так, на всякий случай.
Ну, вот.
Так, ну, теперь, да.
Правда, тут еще возит вопрос.
Давайте так.
За какое симпточку работают операции в Хавиллайте, так сказать?
Ну, на самом деле, так.
Так, да, дефолтная реализация залог квадрат.
Хотя сегодня мы узнаем, как ее написать, чтобы было за логарифом.
Вот.
Да, нет, нет, это не линкат.
Эх, жалко, да.
Хотя надо посмотреть вообще.
Теоретически, в общем, я исходно поправ, я не надеялся, что мы все-таки линкат успеем.
А, может, кстати, успеем.
Почему нет, кстати.
Но, впрочем, смотрите.
Ладно.
Ну, пока не важно.
Но, на самом деле, да.
То есть обычно Хавиллайт...
Ну, вот.
То есть здесь хочется, конечно, всякими Хавиллайтами действительно делать.
Просто все запросы там делать залог квадрата и не париться.
Но, на самом деле, тут как всегда, надо всегда очень...
Ну, как всегда, вы знаете, есть такие темы.
В этом случае как холл-трик еще.
То есть надо внимательно смотреть, какие конкретно запросы вам приходят.
Потому что чем больше вы о них знаете, тем больше шанс, что вы можете отделаться сильно более простыми средствами.
Потому что в данном случае, если от вас просят просто стать икрыску,
то можно вас упасти писать Хавиллайт.
Особенно, если у вас еще и лса за единицу ищет.
Вы же догадались, почему?
Потому что...
Подожди, пора идти так.
Вот не надо этим Элертру-3 сейчас ругаться.
Потому что сейчас даже ими не надо ругаться.
Ну ладно, там в черном ящике придется ругаться.
Да, но давайте...
Но это важно отметить, что тут тоже.
Потому что есть аналог префиксных сумм.
Аналог называется сумма на пути от корня до.
То есть в каждой вершине честно пишем сумму на пути от этой вершины до корня.
Прям честно DFS запускаем.
Там 5, там 8, 9. Не будем делать вид, что мы не знаем, что такое DFS.
Ну и так далее, как всегда.
Вот.
Что уж тут...
То есть совсем уж так выпендриваться не надо.
28, 33, 34.
В общем, вы поняли тут...
Все достаточно...
В общем, тут все достаточно просто.
Вот.
Ну...
Нет, ну это не кое...
Ну пока не...
Ну можно это называть PSSumquay.
Хотя, честно говоря, официально такую обрывиатуру я не встречал.
Хотя назвать, конечно, ее так логично.
Вот. И тогда, смотрите.
Но тогда идея, что если вы такую сумму на пути найдете,
то если вам даны UEV,
то тогда сумма на пути от UDW это что такое?
Это получается сумма на пути от U до корня,
плюс сумма на пути от V до корня,
минус две суммы на пути от LCA до корня.
Да?
Чего?
Ну да, если к сорту вообще кайф.
Но это уже другая история.
LCA не нужен.
Да, LCA не нужен.
Да, это называется, да.
LCA не нужен.
Но тот LCA...
Да, конечно, если был к сорту.
Но, к сожалению, у нас не к сорту.
У нас более продвинутая операция, поэтому сумма.
То есть получается, что у вас все работает за 1,
плюс поиск LCA.
Удобно.
Удобно, правда?
Вот.
Но с другой стороны, конечно, как еще можно усилить?
Можно на самом деле...
Нет, давайте уж...
Нет, ну обычно тут LCA так есть RSQ,
а есть статик RMQ.
А теперь представим себе, что нужно искать, например, минимум на пути.
Тут заметим, что, к сожалению, как бы
минимум на путях нам так в таком виде не поможет.
Вот.
Но тут, смотрите, что...
Но тут действительно такой LCA – это аналог.
То есть смотрите, да.
То есть на самом деле...
Так, тихо, тихо, тихо.
То есть действительно, оказывается, небольшое обобщение.
То есть что мы делали в этом месте в массиве?
Мы...
Вот я смотрю немножко по-другому.
Для каждого элемента хранили минимумы на подотреске,
заканчивая в нем длины 1, 2, 4, там 8 и прочие степени двойки.
То есть вот можно это так.
На этом вот просто вот с такой степенью,
экзотического ракурса посмотреть.
И вот.
И тот возникает практически такая же идея.
А давайте-ка для каждой вершины посчитаем,
во-первых...
То есть посчитаем, во-первых, такую функцию, как, значит...
Ну, так и будем называть, beanup от VL.
То есть просто честно по определению скажем,
что это предок V.
Напоминаю, мы уже это обсуждали, но напомню,
что понятие предок вершины V и понятие родителей вершины V
это разное понятие.
То есть родителю вершины V 1, если она не корень,
а предков много.
Вот.
Значит...
То есть предок V на расстоянии...
На расстоянии...
Стоянии 2 в степени L.
От V.
Вот.
Вот. То есть это вот такая штука.
Заметим, что насчитать ее тоже не очень сложно.
Потому что оказывается, что beanup V0 это что такое?
Да, это тупо родитель вершины V.
А чтобы найти предка на расстоянии 2 в степени L плюс 1,
надо просто найти предка на расстоянии 2 в степени L
от предка на расстоянии 2 в степени L.
Вот.
То есть чтобы скатнуть на 2 в степени PLUS 1,
надо скатнуть на 2 в степени L и еще на два степени L.
В общем, тогда вот...
То есть, более того, в принципе, это даже один из, то есть, в принципе, на этом завязан, даже как мы, видимо, чуть позже быстро обсудим, один из способов нахождения собственной LCA.
Но это нам даже и не важно. Важно другое. Заметим, что вот эта штука, она на самом деле позволяет вам найти не только, то есть, в нашей задаче она бы нам могла позволить найти
еще такую величину, как минап от VL. Это то же самое, но только мы, когда поднимаемся на эти два в степени L, не только саму вершину, еще куда поднимемся, а еще и минимум чиселок, которые мы пройдем мимо.
То есть, это тоже очень легко пересчитывается, правда?
И теперь тогда, если у нас есть, если мы насчитаем такой бинат, то если у нас есть с вами задача подняться из какой-то вершины на заданную высоту h, мы это сделаем за лог h, просто разложив h по степеням двойки.
Но думаю, я тут, но думаю, там сильно писать код тут, думаю, даже не надо, каким фориком мы тут будем пробираться, да?
Вот. Не, рекурсивно не надо. Нет, скажи так, можно, но не очень-то и нужно. То есть, лучше там написать. Ладно, давайте. То есть, смотрите.
Давайте я так-то пишу. Ну, называется это обычно L aq, int v.
Значит, допустим, у вас задача. Это, кстати, тоже отдельная задача, которую будем решать. L aq. Называется level ancestor query.
То есть, это я хочу найти предка вершины v, находящейся на высоте h.
Так вот, с помощью бинапов это делается следующим образом.
То есть, for l равно там max лог от нуля. То есть, перебираем просто все степени двойки и говорим, что, значит, если оказалось, что h больше либо равно 1 х х l, то, значит, что мы делаем?
Тогда из h, то есть, мы поднимаемся на эту высоту, то есть, h уменьшаем и v, то есть, равно binap от vl. Все. И в конце просто сказать, что return l.
В смысле, Ник? Ну, у нас с вами, знаете, на вкусы светломастера разные тогда это называется. По мне это очень красиво.
Нет, предлагается сделать так. Давайте приобрести l от нуля до и пока l меньше, чем h.
Будем проявить, что если h стоит битик l, то будем сдвигать.
Ну, на вкус и цвет. То есть, на вкус и цвет. Можно и так, да, пожалуйста, как угодно, но можно так, можно эдак. Не суть важной.
Вот. В конце концов, можно тут стартовать не от max log, а от вот этой вот логарифма h, который можно, потому что вы с порстейби все равно его насчитываете.
Почему бы его тут не насчитать? Вот. То есть, как угодно. Вот. Так что вот так вот можно, то есть, подняться можно за логарифом.
То есть, соответственно, минимум на этом пути до вот этой h. Ну, то есть, до какой-нибудь задней вершины тоже можно, получается, за логарифом найти.
То есть, получается, теперь это будет работать за логарифом плюс поиск l. То есть, опять же, то есть, видите, никаких хевилайтов писать не надо, только себе в ногу выстрелить.
Вот. Значит, оно, то есть, получается, видите, статические задачи решаются без проблем.
Самое смешное, что на всех этих композициях, на путях, которые там возникают, ты можешь искать там минимум за единицу. Так что да.
Так. Ну, давайте так. На уровне идеи.
А это не важно. Во-первых, он нам будет как черный ящик, во-вторых, мы это все будем очень подробно обсуждать. Так что наберись терпения, как бы мы все, как бы все везде распишем.
В конце, когда вот эту штуку нам тоже надо за единицу как-то делать. А, ну, с этого мы и начнем в свое время.
Ну, да, да, да, да, да. Да, ну, там такой, да. Ой, ну, там посмотрим, там весело будет. Так вот.
Но это мы просто рассмотрели, как решать задачу, если логариф у нас устраивает и без всяких хевилайтов.
Что еще важно отметить? На самом деле, следующую задачу, которую тоже отдельно важно отметить, конечно, чтобы вот тут лишнего не писать.
Это, конечно, эроскоп с изменением в точке. То есть представим себе, что мы хотим решать следующую задачу.
То есть мы хотим делать прибавление на каком-то одном ребре, то есть добавить число икс и найти сумму на пути оттуда ве.
То есть обратите внимание, не прибавление на пути, а прибавление только на одном ребре.
Боже упаси вас тут его писать. Не надо. Нет, ну, хевилай.
Ну, вот. Ну, можно назвать Эллеров обход, хотя Эллеров обход я бы тут тоже не писал, потому что он там слишком нот.
Почему-то его называют так. Ну, я не знаю почему. Ну, вот. Нет, ну, даже когда мы сейчас дойдем, может я даже и расскажу откуда.
Там, в общем-то, понятна интерпретация. Вот. Но в данном случае я бы употребил все-таки немножко другую интуицию.
Тем более, что тут я могу ссылаться на Тарьяна, которая в своей статье 1975 года про ДФС.
Статья так называлась. Depths for Search and its Appliances. Да, 1975 год.
Как вы это, да. Да, для справочки Dx3, алгоритм Dx3 запретен в 59-м. Алгоритм Барувки в 26-м. Вот.
Вот. Да. Но это отдельно для дот. Но вот ДФС, ну, я не уверен.
Ну, я, конечно, не могу, конечно, гарантирую, что прям ДФС запретен в 75-м, но, возможно, как бы интерпретация,
то есть интерпретация, которую дал Тарьян, что Тарьян там начинает с того, что рассказал про ДФС, рассказал про белый, серый, черный цвета.
Там, как минимум, там, по-моему, расписано даже, как искать цикл в графе с помощью такого ДФС. Даже с доказательством.
Раньше ведь не умели. Ну, вот. Ну, скажем так. Но все хорошие, но все хорошие вопросы.
Так нет. Ну, наверное, умели, хотя, может быть, там, для, например, что это как бы делается и ДФСом или как-то еще.
В принципе цикл как бы... Чего?
Делаем все веса минус один. Ну, вот.
Ну, по-разному, да.
Ну, я... Нет, в общем, ладно. Тут, конечно, надо таки.
Но, скажем так, мне неизвестно более... Ну, вот. Нет, на самом деле статья состояла не только из этого.
То есть, конечно, мясо в ней состояло в другом.
Потому что дальше там шло подробное доказательство, как искать компоненты вершинной двусвязности.
Вместе с точками сочленения, естественно.
И более... Ну, вот. Нет, мостов там не было.
А вместо этого там появилось как абсолютно тем же ДФСом найти компоненты сильной связности.
Да, вот. Не этими вашими... Вот это как бы... Обычно, да, в олимпиадной среде компоненты сильной связности ищут двумя ДФСами.
Это называется алгоритм Косараю.
Да, Косараю. Фамилия такая.
Чего?
Косараю, Шарир.
Ну, наверное, да. Но известно как алгоритм Косараю.
Хотя там... Да.
Вот. Но на самом деле есть метод Тарьяна.
Ну, вот. То есть, на самом деле, метод Тарьяна, который позволяет это искать одним ДФСом.
И ровно просто одной той же технологии, как искать мосты точечной сочленения и другие компоненты.
Там он не сортирует их в порядке.
Да ладно. Прекрасно сортирует.
Там... Прекрасно сортирует, учитывая... Да, он их как бы...
Потому что как бы он в каждую компоненту индуитивно входит в какую-то вершину, обходит компонент, потом выходит и ее достает.
И там всех детей он тоже достал, поэтому это тоже топ-сорт.
Так что нет. Прекрасно он все делает.
Просто это как бы олимпиадникам это может не объяснять, потому что это как бы может быть немножко усложненно.
Алгоритм легче два ДФСа написать.
Ну, так нет. Если понимать этот алгоритм ДНДФС, то вы тоже, в общем-то, не постарает там...
То есть, на самом деле, ничего сложного в нем нет.
Но просто, как бы, обычно просто не заморачиваются.
Да. Вот.
Ну, нет. То есть, мы с вами, конечно, видимо, там в следующем семестре, но до этого тоже доживем.
То есть, в общем-то.
Ну, вот. Но судьба была такая. Нет.
Ну, надеюсь, что в этой статье, конечно, ее интересно подсчитать, потому что там, как бы, очень подробные доказательства с огромным количеством лем.
Ну, потому что, как бы, то, что нам с вами там в олимпиадной среде может быть уже очевидно, потому что мы в этом живем,
то есть, видимо, на момент 75-го года как бы было вообще не очевидно.
Поэтому там пришлось Тарьянов, видимо, просто очень подробно прописывать, почему это вообще...
Почему это все вообще правда.
То есть, судя по тому, как он прописывал, это так, это концепция нетрибиальная.
Потому что новая.
то есть принципиально новое вот вот так вот и так ладно веримся тут к делу не
ну погодите нет тут как бы чтоб тут хранить фенвика ну во первых тут просто
идея какая то есть идея такая шесть вы решили ну то есть хочется конечно делать
тоже самое то есть в каждой вершине хранить сумму до корня только маленькая
проблема если на каком-то ребре мы тут добавили 57 то тогда ко всем вот этим
вершинам надо прибавить 57 следует то есть надо научиться каким-то образом ко
всем вершинам под дерево прибавлять 57 так вот я собственно к чему вспомнил
статью тарьяна а вспомнил я это вот к чему потому что в другой статье тарьяна
про дфс называется дерево доминаторов вот но она тоже про дфс но немного
другое почему это статья уже не чисто тарьяна там что-то какой-то там автор
на л запитает ориен на самом деле стоит вот подробности не знаю но там
предлагается сразу ли чао да ладно не не там не на европейская какая-то
фамилия вот и там идея нет улите далее чао да это просто там просто видимо
китайские лепеги придумал лайфхак это называется да вот так вот а там просто
а там тарьян предлагает абсолютно официальный лайфхак и предлагает прям то
в начале статьи так и пишется запустим дфс и переименуем вершины в порядке их
появления входа дфс вершины просто прям вот запустим и честно пишем что вот
вершины теперь у нас будут называться 0 1 2 3 4 5 6 7 вот то есть в нашем случае
это называется в порядке таймына да нет нет нет нет нет нет нет или в обход это
если бы каждый раз когда мы выходим из дфс мы бы еще раз эту вершину
записывали вот это или в обход и он был бы тогда или и вот действительно
похож на или охотно потому что если каждое ребро размножить вот на два
ориентированных две стороны то это получится буквально или обход
действительно этого графа это вот это так вот но это все-таки не совсем это не
совсем он то есть видите это я все-таки это я бы все-таки это
интерпретировал как перенумерацию вершин в порядке в порядке входа дфс а вот
чем вот просто кстати в дереве доминаторов стать статья так и написано
что давайте перенумируем в том после исходя из этого будем всякие леммы
доказывать да это что за статья а интересно нет осуществ такого не видел
но что делать если это было эффективно то почему бы нет но мало понятно
это все еще лучше чем конспекции там просто написан в конспекции самый
худший конспектор я писал своей жизни я не смог понять это он такой написал да
да ну ладно не но философский самый тупой вариант я так скажу может быть
самый тупой вариант это как бы там до учили а если вы учите английский то как
бы зачем до конспекции нужен сзади оригинальную статью тарья源 потому что
редкий ну просто так как будто то есть вот он документ и хорошо пишут на 주
то есть как бы это считает что это одни из самых то есть обычно часто бывает
что там на самый конкретные статьи ученых иногда читать очень сложно
даже не потому что они там как то владеют или не владеют там языком
англиським или еще какие-то там еще в том что понятно что скорее всего если
не придум안 shocked на новое страшное то скорее всего там то есть они как-то
видимо это смотрели на это ну совсем видимо с повернутой точки зрения и пока в эту точку зрения
окончательно этот угол не поняли то скотов скорее всего там будет очень сложно это читать то есть там
то есть ну рейкер еще далеко ходить через статья про софт хип то есть я говорю я в свое время как бы
там пришлось много энергии потратить чтобы вообще это все как бы в курить хотя как бы как вот как
все как мы с вами убедились то есть в общем-то не самые страшные идеи там на самом деле есть но
наверное бывают и пострашнее не знаю вот так вот так что тут так но ну с дерево демидаторов
мы тоже в свое время разберемся там в общем-то тоже не сильно но здесь вот такой вариант на
самом деле ну или есть вариант что там ладно концептав ваши великие предшественники могли
там какой-то конспект там собственно лекции писать так что может там есть конспект может
там понятнее я не знаю ну я не знаю я никаких этих конспектов и с честно не видел поэтому
комментарии дать не могу вот так вот ой да 34 да так вот значит зачем мы это
делали перенумерации но оказывается что если перенумерает вершины так то
оказывается неожиданная вещь оказывается что у любой вершины ее под
дерева это подотрезок то есть скажем у вершины 4 ее под дерево это все вершины
с 4 по 21 вот скажем а вот 26 из 26 по 29 то есть можно этим же дфсом эти отрезки
сохранить и тогда получается что если вы хотите прибавить ко всем вот этим
суммам до корня как бы число 57 то вам нужно это сделать просто на подотрезке и
вам остается только завести дерево отрезков то есть к уже честной дерево
отрезков с прибавлением на отрезки или даже дерево фенрика можно как бы сегодня
убедились то есть одно дерево отрезков то есть боже упаси там какие-то
хевилл это писать не надо да нет ну нет да безусловно шоу как только мы тут
захотим прибавлять на пути то конечно наша полномочия тут все это безусловно
да но хочется просто обращать внимание что есть какие-то более простые задачи
в которых страшных структур писать не надо я говорю как человек который в
течение года на задачу статья крыску писал на автомате дерево отрезков то
есть как бы то есть это и сыгла это работала это там часто получала там свои
100 баллов конечно там ну вот но как бы все-таки или там лишнее время я на это
потратил которая мог бы не потратить вот ну или в более сложных задачах мне
этот логарифа мокрая вот поэтому все равно хочется обращать внимание что как
вот если у вас есть какие-то простые вещи то как бы можно это делать проще
то есть условия чтобы отсортировать колоду карт по мастям вам не надо писать
мерчсорт тут вот да прикиньте чего нет ну а можно в четыре стопочки разложить
нормально подсчетом вот нет ну смотрите нет нет тут нет тот отсылка классической
задачи вот на собеседу и вот когда не будете проходить собеседу не дайте есть
гугловская книжка там про там типа там крейкин за код ревью называется и там вот в одном месте
там есть если там приводит пример если вас на собеседование спрашивают вот смотрите вот как
решать как бы вы решали задачу от сортировки то первое что вы должны делать а что сортируем
это важно потому что он может вам лететь ну например колоду карт и тогда наверно выяснять
что если вы там побежали писать мерчсорт то как бы было бы это не совсем точно потому что это
явно не очень эффективно там забабакивать мерчсорта это того чтобы там от сортировать
колоду как то особенно еще и по мастям например так что в этом смысле просто всегда то есть как
бы не то есть сложно не нужно сложных решений там как бы где их не нужно но вот тем более что как
бы в реальном то есть в реальном коде даже как бы иногда бывает как бы принципиально вы
работаете за 100 миллисекунд или за 10 то есть это не там не как у нас на олимпиадах там по барабану
да там вот может быть критично потому что но знаете эту классику да просто на уровне там половина
зернышка в день это мало женюсь так а сколько это в год 182 с половиной зерна получается не так уж и
мало не не женюсь вот да то есть мало кто знает но крыло как бы вот крот был программистом да так
что нет так ребята кто хотя бы читал сказку про дюймовочку а кто смотрел советский мультик там
вот вот вот я из него сцену пересказал там человека там как рот реально сидел вот он
на счетах считал вот ну вот так вот ну а теперь значит давайте ну значит смотрите то есть вот
такие задачи что прежде чем переходить прям к илайту давайте все-таки быстренько обсудим
потому что все равно пригодится а как нам собственно искать илса но нет на самом деле так вот за
такие бинапы на самом деле то есть они на то есть на самом деле если вы хотите искать илса
вам хватает лагерей потом вот эти бинапы вам могут очень сильно помочь кстати но их можно
за илоген насчитать но правда вам потребуется еще кое-что значит давайте ну как бы это давайте
кратенько обсудим но тут на самом деле разные но сформулируем так но то есть на самом деле по
разному можно делать то есть на самом деле тут есть как бы два способа как с помощью двоих
подъемов найти илса первый спот но тут вот даже интересно какой популярнее но потому что да
потому что есть но на первый способ которым я пока меня когда был школьником всегда писал был
такой значит давайте просто бин поиском найдем до какой высоты нам надо подняться то есть но как бы
но имеется в виду следующее что если я знаю на какой высоте находится илса то я просто из
какой-нибудь вершины до нее поднимусь правда а теперь мы скажем как эту высоту найти а очень
просто даны у меня вершины у и в я могу за логарифом добиться там но если у меня находится ниже давайте
я ее подниму до высоты в но я допустим заранее буду хранить на какой глубине находится у и на
какой глубине находится в и так вот у меня поэтому теперь я предполагаю что у и вы у меня на одной
глубине дает но я сразу про если они совпали то надо просто их и вывести вот теперь как найти
теперь надо найти просто бин поиском на какую минимальную высоту надо подняться чтобы у и вы
попали в одну вершину но можно не заморачиваться сделать бин поиск залог квадрат правда но вы всем
допустим я могу я хочу подняться на высоту аши проверить будет ли там одна вершина я беру
залогарифом аж поднимаюсь из у подымаюсь из в сравнивый результат получается лог квадрат
это если совсем не думать просто вот отключить мозг но если его чуть-чуть включить то оказывается
что бин поиск двоичной подъема прекрасно сочетается потому что идея оказывается следующая вот если у
и вы у меня не совпадают давайте я переберу все высоты вот это вот и опять от max лого до нуля и
скажу что если у меня оказалось что там вот этот вот бинап от уэль не равен бинап от вл то что я
говорю то я говорю что про то я тогда это торта я просто кричу то есть я их тогда под на два
степени или поднимаюсь то есть у равно бинап от уэль в равно бинап от уэль от вл пардон и тогда
в результате этого форика я поднимаюсь куда нет я не поднимаюсь волца я утверждаю что я поднимусь
что я как бы подойду из у и в я подойду вплотную к лца потому что можно доказать инвариант что
после каждой итерации эля расстояние от у до в не превосходит расстояние от у до лца ну и
соответственно от вл до лца не превосходит два степени л но это просто легко это просто легко
доказать по индукции нет ровно может быть потому что концентрано будет два степени ноль но то есть
изначально это так потому что max лог берется достаточно большим да а так дальше у нас два
варианта либо это расстояние меньше и два в степени следующий тогда у нас тут получается равенство
да вот но да но получается тут равенство и мы не поднимаемся либо оно получается чуть больше
и тогда получается мы сокращаем это расстояние на два степени да ну где-то можно и так
интерпретировать да вот да ну и в конце мы пишем конечно return там там так сказать ну я
напишу parent ату хотя понятно берем это будет бина по ту ноль но это уже другое вот то есть
принципе это один способ то есть обратить внимание даже искать эту высоту аши подниматься не
потрясать надо пришлось подняться за логарифом здесь и погиб сюда проявится что в начале
конечно пришлось сказать что там если ашату как всегда там стандартный лайфхак что если ашату
меньше чем ашату это делаем свапату в ну и у равно там л аку от у и там ашату минус ашату
и потом после этого вот это да да да да если у равно в то ретурн ретурн у да то есть вот в
общем-то примерно так полный код и выглядит да но как всегда позже упроси вас тут это какое-то
два случая прям копипасты писать да то есть вот есть вот этот вот стандартный хак да что как бы
вы можете вершины свапать вот то есть это один способ но я вот я всегда писал так но есть
второй то есть ну не то чтобы он вот то есть можно где-то он даже лучше хотя хотя тут сам не
на самом деле они там по эффективности одинаковая но затронет мы затронем мы немножко другое
смотрите альтернатив сейчас вот это уберу так поэтому по этому способа просто есть нет от
вот значит альтернативная версия альтернативная версии я альтернативная версия звучит так
мы заведем внимание значит мы заведем мистич значит опера нам захочется отвечать на такой
запрос как из энцестер тоже полезно обсудить что вот такая штука тоже есть данные две вершины
скажите пожалуйста является ли у предком не родителем а предком в да или нет да а тогда
легко нет как мы уже говорили любая вершина является своим предком и своим потомком но
не является своим родителем ребенка у нас у нас договоренности такие да
спрашивается как решать такую задачу но вот но оказывается решать такую задачу достаточно
но оказывается достаточно просто то есть можно сделать как бы у этой задачи легко сделать
предподсчет за линию и отвечать на запросы за вот единицы классичный вот то есть там
но то есть классический метод звучит так то есть давайте я начито я буду насчитывать время
входа вершину и буду насчитывать время выхода то есть тут у меня будет 0 1 2 и тут же запятая 3 тут
у меня будет 4 5 тот у меня будет там 6 тут там 7 8 тут будет 9 10 11 12 запятая 13
14 запятая 15 тут уже будет запятая 16 тут будет там 17 там ладно забирай вперед 20 потому
что тут будет 18 19 тот будет запятая 21 у принципа поняли да то есть тут не надо подробнее запить
но отрасписать то есть суть оказывается в том что как бы то есть эти отрезок таймин тайм
он обладает таким суть что если вот у этой вершины есть отрезок таймин тайм аут то всего и у всех
их таймин тайм аут вложен в таймин тайм аут этой вершины вот то есть как бы поэтому понять
являет но вот а для всех остальных это не верно потому что как бы для предков это верку у предков
получается надо отрезок такой более широкий а у всех остальных отрезки просто не пересекаются
Поэтому из Ancestor получается, что, то есть здесь как бы код, то есть окажется, то есть там функция bool оказывается просто, там return, return там, time in от u меньше либо равен, time in от v, end, end, time out от v меньше либо равен, time in от u и end.
От u и в общем-то все. То есть классический метод такой, то есть я не знаю, может кто-то там побежал.
Чего? Молодцы, молодцы, так, да, так, конечно, вот, вот, хорошо. Я еще думал тут вою посвапать.
Вот, окей, хорошо. Теперь у нас есть такая мистическая функция, которая потребовала от нас два массива. То, что нам еще делать? То как нам теперь искать LCA?
Ну, теперь оказывается буквально тем же бинпоиском, но можно, оказывается, искать так, то допустим, у меня вот есть u и v.
Допустим, мы выяснили, что u не является предком v. Тогда идея такая, надо из u подняться на такую минимальную высоту, чтобы попасть в предка вершины v, правда?
Но идея заключает в том, что это можно делать абсолютно тем же бинпоиском. То есть там поднимаемся, понятно, код опять же пишется буквально так же.
То есть там звучит так. То есть вот давайте я только напишу int, там допустим, LCA от u, v. Значит, пишем.
Ну, во-первых, так, ну давайте так, отсечем сразу такие тривиальные случаи. Если из ancestor от u, v, то просто сразу выбрасываемся с криком u.
Вот. У-у-у. Да, красиво. Ну а что, так что? На самом деле нет. Вот. Можно, в принципе, если очень хочется сократить, можно то же самое и для v написать, но уже не обязательно.
Дальше звучит так. Пишем опять for L равно там max log 0, if не из ancestor от binup от u, v, то значит тогда пишем u равно этому binup.
То есть ровно по тем же причинам окажется, что в результате этого кода u находится в одном шаге от вожделенного ответа и поэтому пишем, что надо вернуть тупо родителя вершины u.
Все. То есть вот еще такой красивый метод есть. Ну, пожалуй, мне он тоже может чуть-чуть больше нравится, хотя иногда полезно понимать оба.
Нет, но то два варианта. Либо вы тратите два масси. Да нет, либо вы поднимаете tmta, либо вы там больше скачете двоичными подъемами с двух сторон.
Так что да, то есть нет, но более логично это, но это как бы зависит от конкретного вашего способа мышления на самом деле. Нет, нет, я по-своему скажу, что его рассказывают чаще, потому что возможно там как бы новичкам с нуля вот это вот рассказать проще.
Я не знаю, я в последнее время, кстати, новичкам с нуля рассказываю именно это. То есть как бы да, то есть тот нот. То есть я не помню, потому что Волкыша, я не помню, как мне это рассказывали, потому что я помню, что там возник пояс лкца, но там, видимо, там после каких-то пары слов там вот первый метод у меня там в голове сразу возник.
Ну вот, но там, насколько, но правда там этим вот никто не баловался. То есть я там только недавно обратил внимание, что вот так на самом деле можно. Ну то есть просто простая вещь, что просто она мне как-то в жизни вот сама по себе как-то вот ни разу не была нужна.
Ну вот так получилось. Ну вот, но вот, но вот действительно так полезно и на самом деле вот показывать бин поиск иногда будет полезно. Впрочем, на вкус, в общем, опять же на вкус и цвет, как всегда, фломастеры разные.
Вот. И так, то есть вот так вот можно искать лца, если мы его ищем за логорифом. Да, но приятность заключается в том, что когда мы ищем так лца за лгорифами такими вот двоичными подъемами, то выясняется, что мы тут попутно еще какие-то что-то там на отрезке находить можем.
Вот, но, конечно же, лца нам, если наша задача найти лца просто как само по себе лца, то, конечно же, мы его попробуем найти быстрее. Ну желательно это как-то за вот единиц.
Вот, но да, но действительно, как у нас классический способ, но оказывается, что действительно можно пойти в эту же сторону и свести задачу лца к задаче статик РМКУ.
Да, можно сказать даже плюс-минус один. Нет, это классический способ. Не-не-не, это не дальше, это называется, что вы захотите с этим делать, потому что, как вы смотрите, нет, смотрите, давайте не путать сведение к задаче и решение задач.
Потому что, как вы, само по себе сведение задачи на самом деле делается даже не за НЛОГН, как мы говорили раньше, а за линию общей мечты.
Ну, в чем у нас идея? Ну, идея у нас на самом деле такая. Так, давайте этот дерево поменьше нарисую, а то не проиллюстрируешь даже.
Сейчас увидите. Сейчас увидите. Вот. Значит, да, но красивое дерево.
Вот какое-нибудь вот такое. Так, чтобы мы не путались, я сейчас я переименую его вершины. Ну, как их переименовать? Ну, как всегда.
У, фау, в, там, вот это вот. Ну, что, не учили в детстве немецкие разведения? Какой безобразие. Вот, неважно.
Так вот. Нет, ну, на самом деле нет. Почему я, то есть, почему я переименовал их именно буквками?
Ну, потому что нам сейчас, как бы, потому что я тут напишу один ряд буквок и ряд чиселок. И как бы я, как бы, хочется, чтобы мы не путали номера вершин и их глубины.
Чего? Да нет, нормально. Вот. Значит, смотрите. Идея у меня такая. Я вот сейчас я запускаю ДФС и запишу то, что обычно называется эллеров обход дерева.
Запишу я его так. То есть, я буду запущу ДФС, но каждый раз, когда я попадаю в вершину, неважно, сверху или снизу, я буду записывать.
Получится примерно следующее. H, D, значит, иду A, возвращаемся, снова пишем D, потом тут опять R, D, H, дальше F, S, F.
О, и начинается мясо. Так, значит, L, E, M, E, O, E, Q, E, L, C. Так это мы сотрем. L, F, H, B. Что там дальше?
J, K, J, B, G, P, I, P, N, P, G, B, H.
Как легко убедиться, записал я тут всего лишь два N плюс один буковок, два N минус один буковок.
Но я написал первую букву H, а дальше я по каждому ребро прошелся два раза, поэтому их всего два N минус один.
Но теперь у меня идея, а давайте-ка я тут напишу под каждой буковкой, я еще напишу ее глубину.
Получится 0, 1, 2, 1, 2, 1, 0, 1, 2, 1, 2, 3, 4, 3, 4, 3, 4, 3, 2, 2, 3, 2, 1, 0, 1, 2, 3, 2, 1, 2, 3, 4, 3, 2, 1, 0.
Так вот, я написал еще такой массив высот.
Так вот, теперь у меня задача. Я хочу найти, допустим, L у вершины K, какой-нибудь там и вершины P.
Ну, например. Так вот, оказывается, идея очень простая.
Я найду в этом массиве первое вхождение вершины K и первое вхождение вершины P.
Рассмотрю подотрезок между ними и найду минимум по высоте на этом подотрезке.
Утверждение. Это LCA.
Чего? Доказательства? Поехали.
Действительно, да. На экзамене может оказаться не очевидно.
А доказательства при этом не сильно сложные.
Итак, смотрите. Жила была вершина условно K и вершина условно P.
И было, ну, допустим, пока сейчас для простоты, что...
Рассмотрим общий случай, когда K и P редкими потомками друг друга не являются.
И вот жила была LCA. Вот оно, да?
И причем, да, то есть было LCA как минимум два дерева, в одном из которых лежало K, в другом лежало P, а еще там попутно могли еще быть какие-то деревья.
Вот. Так вот. Значит, что произошло?
Шел тут DFS себе, шел, шел, шел, шел. И в какой-то момент пришел вершина LCA.
Конечно, это произошло раньше, чем он пришел в K и P, правда?
Но теперь заметим следующее, что мы тут... Было время, когда мы вошли в LCA, и было время, когда мы вышли из LCA.
Заметим, что все вхождения K и P были между этими двумя моментами времени, правда?
Следовательно, уже из этого можно сделать вывод, что, во-первых, все глубины, то есть все глубины между входом в это и выходом были не меньше, чем вот эта LCA, правда?
То есть следовательно, то, что мы найдем по глубине, будет как бы... будет по глубине не меньше, чем сама LCA.
Да, и будет эта вершина под дерево LCA. Остается только убедить, что это будет самая LCA, а не какой-нибудь под дерево.
Но здесь это... Ну, здесь по-разному можно сформулировать, почему это очевидно, но суть, на самом деле, такая.
Можно заметить следующее, что между любые... Если я возьму тут две вершины любые в любой позиции, то мы заметим, что последовательный вершин между ними – это путь.
Это путь в дереве, правда? Не обязательно простой, но путь.
Но заметим, что мы как бы все пути из K в P вот эту LCA по-любому содержат, правда?
То есть следовательно, где-то между K и P обязательно сама эта вершина возникнет.
Поэтому она будет минимумом по глубине, а других вершин по глубине минимумов нет.
То есть, может быть, там этих минимумов будет несколько, но они будут соответствовать одной и той же вершине.
Вот, собственно, и все доказательство.
Вот.
Чего?
Вот. То есть так вот получается, что теперь у нас задача, дано просто массив, вот просто дано RMQ, то есть просто дан массив, надо на нем найти минимум, и он статический.
Почему это называется RMQ плюс-минус один?
Потому что у этого массива есть еще и дополнительное свойство, что любые два соседних элемента отличаются на плюс-минус один.
Это нам будет помогать когда-нибудь.
Потому что в простой олимпиадной версии, конечно, говорят в этом месте, а давайте мы просто, чтобы искать минимум за О от единицы, давайте тупо насчитаем с парсы.
Ну, господи, что еще делать?
Ну, просто насчитаем с парсы за N лог N и после этого будем искать за О от единицы минимумы, то есть единственная там оговорка, что нужно искать не просто минимум, а его конкретную позицию.
Но это уже как бы детали реализации, ничего сложного в этом нету.
Вот, понятно, да?
Чего?
Каву.
Каву и писать?
А, с СНМчиком?
Да, но это если он в офлайне.
Чаще бывает онлайн, но на самом деле это не важно, у нас есть в фарах Колтон Бендер.
Да.
Вот.
Нет, но я вам так честно скажу, я пока...
Нет.
Чего?
Ну, это другой вопрос, да.
Но правда, но правда честно, сейчас его рассказывать не хочется, потому что на самом деле это является просто применением метода четырех русских.
И вот, понятно, но как бы метод четырех русских...
Чего?
Так, во-первых, нет никакого фара...
Во-первых, зачем с того, что нет никакого фараха?
Есть фарах Колтон.
Это двойная фамилия.
Да, не спрашивайте, почему, там совсем страшно.
Второй Бендер.
Во-вторых, они не линуты, во-вторых, это не русские.
Значит, нет, четыре русских, на которые в том числе они ссылаются, имеют более простые русские фамилии.
Значит, Динец.
Значит, Динец, потом Кронрат, Фараджев, Орлазаров.
Да ладно.
Орлазарова, по-моему, даже...
Нет, по-моему, там был Орлазарова, даже Сергей зовут, насколько я помню.
Ну, вот и так далее.
Нет, я нельзя по...
А, нет, хотя нет, он по-моему...
Хотя нет, я вот недавно тут пересматривал свои документы, обнаружил, что что-то в дипломе об окончании аспирантуры, там написано, предведатель реквизиционной комиссии В.Л. Орлазаров.
Так что есть вероятность, что тот самый, да.
Нет, потому что нет, я был известен примерно несколько лет назад, Орлазаров вполне себе там был в Москве, имел там какое-то прямое отношение, как минимум, к Миссису, так что...
То есть абсолютно...
Так что тут это, то есть это абсолютно реальный человек.
Да.
Нет, знаете, там вообще, когда начинаете там заниматься как-то наукой, иногда магия, потому что обычно, когда вы там читаете там, Пифагор, Каши, да, это какие-то вот стра... умные дяди, которые когда-то жили и умерли, да.
А потом занимаетесь современной наукой, приезжаете на конференцию, представляете, что все эти люди, это абсолютно реально живые и вообще действующие люди, да.
Которые там с вами могут это еще и с удовольствием обсудить.
Ефим Динец живой и работает в Израиле.
Ну а чего бы нет.
Да, Ефим Динец, да, ну вот.
Так что вот так.
Внезапно.
Ну ладно.
Не, ну может я вам скажу поддельно, конечно, доказали, что он там...
Не, ну я не знаю там, хотя это странно, но ладно.
Разберемся отдельно.
Вот.
Не, ну может там не было официально.
Так.
Ладно.
Значит, это мы обсудили, значит, как у нас...
Значит, это мы обсудили, как из Кателса.
Обсудили, значит, какие вот базовые задачи просто вот на тему Риску и Рымку можно решать без всяких Хевилайтов.
Но боюсь, что, видимо, сейчас придется сделать перерыв, после которого Хевилайт придется все-таки ввести.
Итак, Хевилайт.
Значит, смотрите.
Значит, смотрите.
Так что же делать, если нам все-таки хочется изменять что-то на отрезке, в том числе и присваивать,
там суммы всякие искать или минимумы, что-то еще в этом роде.
Мы это умеем с вами делать только на массивах.
Что такое массив?
Ну это бамбук такой, по сути, да?
Хочется разбить дерево как-то на бамбуке так, чтобы как бы было все как-то красиво.
Но как же это сделать?
Но как же это сделать?
Ну на самом деле декомпозиции много.
Как мы с вами, возможно, в следующий раз убедимся там.
Декомпозировать дерево на пути можно инцитю способами.
Чего?
Чего? Ну че, лонгеспресс, ледер, да.
Вот.
Так что как минимум, да.
Вот это вся классика.
Вот. Но сейчас у нас все попроще.
Потому что дело в том, что есть у нас есть подвешенное дерево.
Просто какое-нибудь абсолютно произвольное дерево.
Ну, как вы уже догадываетесь, у каждой вершины можно насчитать такую величину, как СЗ от В.
Что такое СЗ от В?
Ну количество вершин в поддереве.
Считая себя любимую, естественно.
Ну понятно, практически любой задачи на дереве, наверное, без подсчета СЗшки не обойдется.
Ну там, например, в 95% случаев СЗшку вам написать придется в том или ином виде.
Вот.
Тут какая-то вот такая красота, там вот это все, вот это, вот это, вот это.
Допустим.
Допустим.
Вот.
Вот.
Но, значит, соответственно, теперь у нас появляется неожиданное свойство.
Значит, определение.
Значит, пусть у меня У равно parent от В.
Тогда ребро УВ.
Говорим мы внезапно.
Тяжелое.
Прям вот красенький мы будем писать.
Тяжелое.
Если СЗ от В больше либо равно, чем 1 вторая СЗ от У.
Да.
Тяжелое капсом, естественно, пишем, да.
Вот.
Ну вот.
Ну вот.
И, соответственно, легкое.
Иначе.
Вот.
Вот.
Ну, собственно, к чему же это нас приводит.
Так, ну давайте попробуем вот на этом дереве изобразить, какие у нас ребра тяжелые, какие легкие.
Ну, заметим, да, что...
Так, ну вот такое ребро у нас тяжелое явно.
Вот.
Вот это вот, конечно, тяжелое, да.
Потому что тут размер под дерево 6, а тут 3.
Вот.
Вот.
Здесь у нас вот это вот легенькое ребро.
Легенькое, как промышленность.
Вот.
Так, вот.
Так, что оно легонькое.
Вот.
Так.
Так, ну что мы видим.
Так, ну тут по дереве явно меньше элементов.
Да, тут как бы.
Да, вот так вот можно.
Ну и давайте сразу.
Так.
Я знаю, как оптимизировать процесс.
О.
Сейчас краснота будет.
Вот.
Так.
А вот это ребро тяжелое или нет, кстати?
Да.
А, вы уже...
А, вы уже...
Да, вы уже посчитали?
Окей.
Хорошо.
Да.
А прям надо, да?
По картинке видно.
Не, ну не факт.
Нет, ну...
Я бы так сказал.
Смотрите, на самом деле это нужно только для корня,
поэтому нет особого смысла.
Вот.
Вот.
Ну, давайте так.
Давайте вот для простоты скажем шут.
Ну, нет, на самом деле.
Вот это да.
Ну, вот вообще так.
Вот это не факт.
А вот это точно да.
Потому что если у вершины есть только один ребенок,
то это ребро в него тяжелое автоматически.
Вот.
Так.
Так.
Что тут еще?
Так.
Ну, это вроде тяжелее.
Так.
Это у нас вот так вот.
Так.
Что тут у нас еще?
Так еще вот так вот.
И...
А вот тут, конечно, не факт.
Ну, это ладно.
Не важно пока.
Ладно.
Важно пока другое.
Значит, мы давайте вот тут рисуем, рисуем, рисуем, рисуем.
Так.
Что тут больше?
Так.
Три, три.
Ну, тут больше.
Да.
Вы смотрите.
Да.
Тут три, шесть.
А тут раз, два, три, четыре, пять, шесть.
Ура.
Боевая ничь.
Да.
А всего три.
А всего тринадцать.
Следовательно.
Вот так.
Ну, на самом деле да.
Кто-то Хавилайт по-другому пишет.
Да.
Можно.
Но это другое определение.
Вот.
Ну.
Да.
Идейно ничего.
Да.
Ну.
Ну.
Ну.
Да.
Ну.
Ну.
У вас theta и theta.
Да.
Ну.
Ну.
Вот.
Так, тут вот так вот, тут вот так вот.
И теперь вот барабанная дробь.
Кто из них, кто из них тяжелый, если кто-то тяжелый.
Да.
Ну, не знаю.
Вот тут, конечно, вот эти вот мелочи, конечно, пугают.
Поэтому поехали.
Раз, два.
Ну давайте.
Что тут думать-то?
Раз, два, три, четыре, пять, шесть, семь, восемь, девять,
десять, одиннадцать, двенадцать, тринадцать, четырнадцать,
пятьдесят, шестнадцать.
17 18 19 20
Да ну пусть будет 21 хорошо
раз так что у нас тут 1 2 3 4 5 6 7 8 9 10 11
12 13 14 15 16 17 18 12 20 21 22
уху да
ура боевая ничья
хотя если там еще пару вершин повесил быть бы там тяжелым или бы там тяжело
но самое главное что можно заметить
принципе можно это вывести на красивое красное утверждение
что у любой вершины в
то есть у любой вершины в не более одного тяжелого так сказать ребенка
там не округление там просто там может быть это 1 2 дробно они
сейчас
да нет скажем так да тут как бы важно подчеркнуть что сз включает себя любимую то есть сз от
висящей вершины адын
и тогда в этом случае действительно очевидно что это так почему потому что если у тебя два тяжелых ребенка значит в двух этих поддеревьях
вершин не меньше чем во всем под деревья но там их строго меньше потому что там нет меня
вот поэтому соответственно
вот
но но поэтому тут поэтому получается не более одного но тогда заметим что если я возьму все тяжелые ребра то
но то на самом деле тяжелые ребра образуют пути от предка до потомка и
в принципе я могу сказать что если я удалю все легкие ровно стал у все тяжелые то дерево распадется на вот такого рода пути
да некоторые из этих путей будут содержать всего одну вершину
вот вот например корень у нас сейчас
вообще лежит на таком пути
вот так вот но много много вершин у нас много будет путей из одной из одной любимой там себя любимые вершины
вот
вот то есть вот так вот вот так вот так вот и
вот так
вот
то есть получается мы то есть как бы разбили множество вершин на пути
на пути такие, что ребра в них это тяжелые пути, поэтому это и называется тяжелолегкая
декомпания, тяжелолегкое разбиение, да, то есть я не знаю, более адекватного перевода русский язык не
встречал, поэтому обычно так и называют heavy line decomposition, вот как-то гармонично, а у нас как-то,
ну нет, ну не знаю, как-то действительно тяжелое, тяжелое, легкое разбиение, как-то вот по-русски это
надо говорить, но, но я думаю тут как бы, как бы да, думаю так, наверное конкретная русификация тут
излишня, поэтому будем так и называть heavy light, то есть прямо буквально heavy light decomposition,
вправо, бойца,
вот, да, так что вот так и пишет обычно hld, но не то, чтобы буквы прям всегда пишутся тремя цветами,
но значит, но теперь спрашивается, сколько может быть путей в этом heavy light? Ну понятно,
ну по тяжелых, естественно, да, на самом деле, да, абсолютно сколько угодно, потому что если у меня
дерево будет идеальным хипом каким-нибудь, то в принципе там все и оба будут легкие, то есть как бы
да, фишка не в этом, то есть на самом деле, как бы ключевая, ключевая фишка находится в таком
синим утверждение, которое говорит, на пути от произвольной вершины v до корня не более чем
двоичный логарифом n лестих ребер, вот такое вот красивое синее утверждение, ну откуда оно берется?
Ну доказательства его тоже достаточно тривиально, пойдем от вершины v до корня и будем замечать,
что каждый раз, когда мы проходим ребро, созэшка текущей вершины строго увеличивается, да,
само по себе этот факт ничего не значит, но он дает победу в купе с следующим фактом, что когда вы
проходите по тяжелому ребру, он просто увеличивается, а когда вы проходите по легкому, то созэшка
увеличивается хотя бы в два раза, ну обычно даже не хотя бы строго больше, чем в два раза, если
быть точнее, но это уже мелочи, но так как у нас изначально созэ один, а в конце созэ n, то
увеличиваться в два раза мы могли не более чем, вот столько раз, ну собственно доказательства окончено.
Вот чем это нам помогает? А помогает нам это вот чем? То есть идея будет заключаться, то есть идея
декомпозиции всяких структур дан с точки зрения нашей rs кушки будет заключаться в чем? Она будет
заключаться в том, что на каждом пути я буду забабахивать, ну например, какой-нибудь дерево отрезков
свое любимое или авэльку, или дикартач, вполне, и буду говорить, что для любого подотреска, то есть для
любого под пути каждого тяжелого пути я могу находить операцию в них за логарифом, а если я хочу
после этого, вот давайте представим себе, что будем решать классическую задачу rs q. Давайте представим
себе, что в классическом виде, что мы хотим находить сумму на пути и допустим изменять,
ладно, одно ребро изменять плохо, но допустим, мы будем находить не просто сумму, хотя нет,
самый тупой знаете, чтобы обвалить себе старые технологии, можно уже просто искать минимум на
пути и добавлять какой-нибудь д, то есть в принципе, можно тут пытаться думать, можно ли тут выкрутиться
без хевилайтов, но я тут имел в виду, что ребро, уже этого хватает, хотя то, что я сейчас расскажу,
понятно будет на самом деле вам и на пути все добавлять, но потому что смотрите, теперь какая
идея, но идея будет, что начнем с это, это будет работать в худшем случае за, ну он будет работать
либо за синюю единицу, либо за красный логариф, почему, ну потому что у меня будет идея такая,
все ребра, которые у меня попадают в тяжелые пути, я буду хранить в дереве отрезков, а все легкие
ребра я не буду хранить нигде, поэтому изменение легкого ребра будет за единицу, а изменение
тяжелого за логарифом, ну формально за логарифом того пути, где оно находится, там как повезет,
там вот действительно очень сильно повезет и там тоже единица будет, я не знаю, да, вот, ну конечно
мы чуть позже поговорим, как это можно там удобно иногда реализовывать, но как бы идеально мы будем
считать, что да, на каждом пути реализованы свое дерево отрезков, размера от, сколько там
реальный ребер, то есть боже упаси на каждый путь забабахивать дерево отрезков размера n, то есть
боже упаси, не надо так, то есть это будет как бы н квадрат памяти уже, поэтому как бы если у вас там
дерево отрезков длины 5, значит уж будьте добры дерево отрезков за 1 от 5, ну вот, ну чтобы тогда
суммарный размер всех деревьев отрезков будет линию, кстати, да, суммарный размер хавилайта по
памяти это вполне себе линия, да и кстати, более того там, без учета инициализации, кстати, более
того, в общем-то и строится хавилайт сам по себе вполне себе за линию, ну потому что, да, по сути
это 2 dfs и на каждом пути еще д.о.шку построить, но это тоже линия, ну можно, ну там, да, дикар-тач
возможно придется строить дольше, впрочем, как бы в Farah Colton Bender у нас возникнет идея, что там
хавилайта, как бы дикар-тач, дикар-тач иногда все-таки за линию строится, если вам заранее ключи, если
вам заранее сортирован по ключам, конечно, вот, нет, в Farah Colton есть дикар-тач, да, но там как
свести рэмку колца, по сути, по сути построить дикар-тач с неявными ключами, с ключами от 1 до n
и приоритетами в вашем массиве, вот, окажется, что это сведение рэмку колца, а потом мы лца
сведем к рэмку плюс-минус 1, а потом начнется мясо, да, ну ладно, там тоже мясо, конечно, относительное,
но как-то, да, после стов хипа, на самом деле, там мяса у нас нету толком, да, но хотя, да, вот да, ладно,
ну посмотрим, почему, до чего мы доживем, до чего мы такими темпами доживем в итоге, на самом деле,
ладно, значит, смотрите, это был end, тут все просто, а теперь давайте доживем до минимума, но давайте
начнем простой случай, давайте рассмотрим минимум на пути от u до корня, давайте прогуляемся от u до корня,
значит, вот жила была вершина u, значит, заметим, что, в принципе, вершина u лежит на каком-то тяжелом пути,
да, по-любому, любая вершина u лежит на ровно одном тяжелом пути, другое, просто, как бы этот путь
может состоять из одной вершины, но я его условно, тем не менее, буду рисовать вот таким неситым образом,
так вот, значит, идея такая, ну, значит, вот вершина u и мы можем взять от вершины u, дойти до начала
этого пути и, в принципе, там, так сказать, про апдейтить ответ минимум на этом префексе, согласны?
Значит, тут теперь, ну, если это не корень, то тут, значит, есть легкое ребро, и тут мы тоже есть
дальше идем тоже по префексу какого-то тяжелого пути, который тут где-то отваливается. Так, ну, на самом деле,
я даже, знаете, по-другому немножко нарисую, то есть, вот идейно, вот это на самом деле, как-то,
вот так получается. Вот то есть, вершина u была у меня где-то здесь, вот и красненький, красненький,
красненький был у меня вот здесь, вот здесь и вот. Ну, вот то есть, тогда, смотрите, что получается,
то есть когда мы идем до корня то есть мы делаем следующее то есть мы идем то
есть мы получается прям вот идем идем идем идем и в каждом из этих путей
находим вот этот префикс на этом префиксе находим минимум то есть
получается мы находим ответ за логарифом но минимум мы с логарифом деревья
отрезков ищем за логарифом умножить на сколько путей мы встретили но путей
мы встретили как мы уже выяснили по синему утверждению тоже логарифом
следовательно у нас получился лог квадрат вот такая вот вот такой вот
простой версии но правда что делать если у нас у и в оказались не корнем но на
самом деле идея в общем-то примерно та же то есть разница будет в том что если
мы идем от у до корня то мы в какой-то момент случайно наткнемся на лца от у
до в и тогда просто в этом последнем пути надо будет просто взять ответ на
подотрески не на префиксе она только этом подотреске понятно да ну то есть по
сути мы сведем как бы путь от путь от удове то есть к двум путям от у до
какого-то предка и каждый из этих путей обработаем за логарифом
понятно да более того специально искать это лца даже не обязательно то есть
конкретная реализация там может выглядеть примерно в данном случае
следующим образом то есть вот да ну данные там допустим файнд мин от ув
сейчас я псевдокод конечно немножко напишу но там будет история такая то есть
там будем говорить что ваил значит пока не оказалось что там из анцестер от ув
значит будем делать следующее значит значит смотрите значит пока она начнется
там будем говорить так значит у штрих равно давайте вот красненьким я напишу
старт пэс так сказать старта то есть начало пути у вершины у то есть но вершина
уже это тяжелом пути вот пусть у штрих это ее начало я даже здесь красненьким
и тогда получится следующее то есть дальше скажу что если оказалось
значит значит что тут у нас оказалось значит если оказалось что у штрих это предок
предок в то то бряк но в противном случае апдейт анс от пути у штрих у и после этого
написать синим теперь напишу у равно перрент от у штрих вот то есть вот такой вот смотрите то
есть вот такой вот валик вайлик я напишу что сделает этот вайлик но я утверждаю что то есть
там произойдет следующее вот на этой картинке я покажу то есть вот на самом деле несколько вот
этих вот путей до лс ашки он вполне себе обработает в какой-то момент тут вот начнется какой-то вот
путь который доходит до сюда и куда-то еще может быть выше идет да и тогда вершина у окажется
теперь в итоге вот здесь видно да что теперь сделаю ну вот дальше я пишу то же для в абсолютно
то же самое делаю ну понятно относительно пока вы не станет предком значит предком ну в данном
случае это я сейчас только карши формально один случай и доказательство придется сделать чуть
сложнее но мы это сделаем чтобы просто убедиться что это не лажа вот значит тут мы тоже подымаемся
подымать пытаться но если тут выяснилось что тут как бы вот этот тяжелый путь от этой вот от
этой лс ашки идет в сторону то тогда получается что мы в конце получится такая штука у нас в конце
окажется вот этот вот вот это вот ребрышка то есть мы как бы вот это обработаем и прям вот
сюда и придем то есть смотрите то есть я утверждаю что в конце будет так что здесь лца есть вот
этот вот отрезок тяжелого пути да который идет вниз но остается предком хотя бы одного из
ув и тогда ты же что в конце останется только вот это вот ув и в конце останется значит вот
я добавляю после этого надо просто апдейт анс значит от теперь уже теперешних ув и ретурнанс все
да при чем тут мимакс нет но я тут кратко пишу апдейт анс говорит так что у меня есть отрезок
тяжелого пути от этой вершины это я гарантирую что не на одном тяжелом пути но я не знаю в
каком порядке но так-то да ладно хорошо апдейт анс от не значит ну ладно так но от
у штрих запятая у штрих хорошо вот так напишем но в этом плане да да но может еще так случиться что
эти вершины совпадают тогда никакого апдейта не будет происходить от слова вообще но вот я
утверждаю что но как видим вот там вот то есть утверждает что этот код на самом деле сработает
всегда независимо не от каких случаев но давайте в этом убедимся вот мы сейчас рассмотрели случаи
когда вот что когда у нас у и вы не являются предками друг друга но при этом есть какой-то
тяжелый путь который от лца от ув идет в сторону видно да но думаю достаточно очевидно что если
вон шел в сторону в то было бы то же самое то есть нам в общем-то вот эти вот операции у его они
симметричны в принципе да хотя нет они не совсем симметричным что тут у вот куда-то сюда пришла
поэтому ладно давайте вот аккуратненько в этом убедимся давайте вот в этом очень
аккуратненько убедимся так это мы значит убираем значит давайте то есть что-то еще могло произойти
но потому что в принципе если от у выяснилось что у нас есть какой-то тяжелый путь проходит
через лца то как бы вот этот случай мы уже обработали хорошо вот да ну ладно хорошо раз
это так то давайте еще обработаем тогда случай знаете какой когда у нас оказалось неожиданно что
в это предок у если в это предок у то когда мы начинаем с у оказывается и вот допустим где-то
в то тогда как у нас будет пока у не является предком в то есть наоборот да то получается мы
тут идем идем идем идем а потом в какой-то момент наткнулись на вот путь который уже
проходит через вершину в видно да тогда что произойдет у пройдет вот сюда в по своему циклу
никуда не пойдет и нам останется только обработать этот отрезок видно да то есть ровно этот цикл это
сделает но теперь весь кайта просто если мы не угадали порядок то есть если выяснилось что но вот
то есть если выяснилось что путь тут не так устроен но на самом деле что могло еще быть могло
еще конечно быть что действительно мы тут а ту скажем шли шли шли шли шли и тут бабах у неожиданно
пришло прям в родителя то есть было тут у и пришло вот тут вершина у и тут вот она куда-то вот пошла
сюда видно да но тогда у нас принципе два варианта либо у нас этот вот тяжелый то есть этот путь
пошел сюда и тогда вершина в в конечном счете придет то есть вот вот так вот так вот так она просто
вот сюда же и придет и мы обработаем вот этот отрезок ну ладно вот вот вот а нет да вот так
тут даже получится но от вершины в итоге придет сюда либо может вообще оказаться что в принципе
еще бывает такой случай когда у вас тут ув и вот этот вот красный путь на самом деле пришел в
эту вершину и отправился куда-то ниже или вообще никуда не пришел тогда просто у его придут обе
вот сюда и тут ничего не будет вот понятно да то есть получается действительно что видите то есть
в явном виде л ца искать не пришлось я вам даже больше скажу вы можете в этой функции попутную
ца сохранить как более высокую вершину из у его вот просто вот из этих же рассуждений очевидно
что более высокая вершина оттуда в общем-то л цашкой той самой будет понятно да ну кстати
да тут на самом деле еще возникает иногда бывает отдельная песня а как эти деревья отрезков реально
кстати хранить потому что тут есть как бы два пути первый конечно это эти пути хранить прямо
в явном виде и для каждого из этих путей там просто и написать там просто вектор из деревьев отрезков
вот но кто-то рекомендует писать чуть по-другому предлагается так давайте перенумер опять же
перенумеруем вершины а именно запустим дфс и перенумеруем вершины то есть запустим дфс но
с тем расчетом что он будет идти сначала по тяжелому ребро потом по всем остальным то есть
получится тогда следующее вот так вот 6 7 вот там 8 9 10 11 тут самое главное 12 13 14 15 16
17 18 естественно тут получится 19 20 21 но тут получится 22 23 24 25 там ну и так далее
в общем не буду дописывать суть я думаю вы уже ловили суть заключает но что при таком дфс
каждый путь это подотрезок вершин и тогда можно запопахать одно дерево отрезков они
вот кому-то считается даже удобно но потому что да и то есть если вам не удобно то есть если вы
привыкли создавать только в каждой значит только одно статическое дерево отрезков то вот это вот
будет очень удобно но вот другой вопрос что честно скажем что вот такой это конечно очень
удобно реализовывать но это реализация есть глобальный минус минус будет заключаться в том
что то есть что есть решение в таком таком дереве отрезков вы каждый путь будете реально
залогом обрабатывать а так на самом деле у вас был шанс что как бы да у вас может быть там
много путей но эти пути мелкие и пола и многие из этих путей вы обработаете не за логарифом за
единицу ну и пока мере за логарифом того пути который есть вот то есть иногда там бывают на
код фолькс бывали какие-то пополосновения доказать что на самом деле как бы если вот в таком мелком
случае сделать то там вам еще удачи сделать тест на котором это реально лог квадрат работать будет
вот но впрочем там официального доказательства так и не появилось по-моему больше скорее
появились подозрения на то что нет там лог квадрат все-таки выковырить можно хоть константа
у него будет конечно мелкая вот так что тут конечно на вкус азия то есть как бы я тут
конечно предположил все-таки но то есть вот эта реализация красивая безусловно потому что как
бы вам по любому для каждой вершины придется хранить какую-то информацию в духе на каком
пути она находится и где она в ем если вы их так перенумируете то жизнь вам конечно существенно
облегчится но тем не менее хранить там все в одном дереве отрезков я бы вам и советовал вот
хотя в прочем если у вас все операции деревья отрезков снизу то в общем-то кстати по барабану
да то есть кстати да еще одна приятность дерево отрезков снизу если вы обрабатываете если вы там
если сумму на отрезке лр то вы работаете за низоватый логин а за от логарифма длины этого отрезка
вот так что да и тогда может быть кому-то это даже поможет так что еще но впрочем последний
видим о чем и сколько у нас там времени ой хорошо да но там хранить для каждой вершины
для каждого нет ну все можно конечно но нет ну заморочиться конечно всегда можно но не
очень-то и нужно вот но поэтому ладно закончим мы правда неожиданная вещь да но первым заметим
что такая технология она каше чем приятно она приятно тем что на самом деле да я тут сказал
прибавление на ребре но на самом деле конечно же если вы забыли тут поправить что как бы что-то
прибавляем не на пути а на ребре то ничего страшного то есть вот эта технология как бы позволяет
Amg
Вот но теперь в качестве добивки но это пока в официальной версии лог квадрат
ну вот осталось только небольшая финалочка. Я утверждаю, что теперь можно на самом деле
реализовать хавиллайт так, что это будет работать за алгорифм. Так, ну как, кстати,
кто знает как это сделать? О, немного, окей, хорошо, ну ничего, сейчас узнаете все, там ничего сложно.
Вот, значит, идея будет такая, ну слушайте внимательно, потому что подобного рода идеи,
потом в следующий раз начну там, ой как, ой как быть нужны, хотя конкретно сейчас она достаточно
простая. Смотрите, значит, так это мы все убираем, значит смотрите, да нет, ну заметим, ну заметим
следующее, что сам по себе хавиллайт мы спокойно строим за, собственно, за линию, да, ну как набор путей,
то есть да, ну и там, то есть вопрос, то есть на самом деле идея у нас будет в том, в какой
конкретно магическую, какую магическую структуру мы забабахаем на пути, то есть мы просто не
будем забабахивать деревоотресков. Почему мы не будем забабахивать деревоотресков? Потому что у
нас, на ноге, вот откуда у нас, что такое деревоотресков вообще, да? Деревоотресков, ну если на него посмотреть
сверху, то получится что-то такое. Деревоотресков это я думаю, так, я хочу хранить сумму на всем
пути, а после этого я делю как бы массив на две части и запускаюсь рекурсивно, то есть там храню
на всех половинках, потом на всех четвертях и так далее, да, это по сути деревоотресков. А теперь
я думаю, а теперь у меня идея. Ну вот, то есть какая у меня идея? А почему я должен вделить
на пополам именно количество вершин? Ну, в идеале, то есть в деревеотресков я хочу его делить,
почему? Потому что если я, например, ищу минимум на префиксе, допустим, то как я в деревеотресков
уйду? То есть я говорю так, я думаю так, где у меня эта граница этого префикса? В левой половине
или в правой? Если выяснилось, что в левой, я просто иду влево, а на правую половину забиваю. А если,
соответственно, всю левую покрываем, то мы как бы эту левую за 1 прибавляем к ответу и идем в
правом под дереве. То есть получается, за один шаг я как бы уменьшил рассматриваемую часть деревоотресков
в два раза. То есть ровно за счет этого это работает за логарифом. Вот, но тут у меня проблема в том,
что я как бы, то есть тут у меня тоже возникает идея, что почти везде, кроме, может быть, одного,
то есть я иду как бы сверху вниз и рассматриваю несколько префиксов. И в каждом префиксе я,
получается, делаю вот этот спуск за логарифом. Так вот, цель у меня будет такая, что когда я иду,
например, от корня в какую-то вершину и на каждом пути делаю спуск, я хочу, чтобы я суммарно
спускался за логарифом, а не в каждом за логарифом. Да, пока звучит муторно, но сейчас вы видите,
что я имею в виду. Значит, щит у меня будет такой. Значит, вместо деревоотресков я буду хранить в
некотором смысле сбалансированное двоичное дерево поиска. Звучит оно будет так. Смотрите,
рассмотрим какой-нибудь путь тяжелый. Смотрите, заметим, что на каждой вершине что-то висит.
В чем на каждой вершине, кроме последней, висит, конечно, тяжелое ребро, но висит еще
несколько люстих. Вот тут какие-то вот такие. Ну, тут ладно, я тут не буду врать. Тут, конечно,
просто какое-то произвольное под дерево висит. Даже правильнее рисовать даже вот так. Смотрите,
видите, как я нарисую. Правильнее рисовать так. То есть, тут на легком ребре висит какое-то под
дерево, еще на легком ребре какое-то под дерево, ну и так далее. Тут тоже на легком. Тут висит,
висит, висит. Вот тут, а тут ничего не висит. Вот так вот. Ну и тут что-то висит.
Ну вот, они вот-вот, они красные ребра в одном пути. Может быть, но вот это ребро конкретно
сине, а тут внутри могут быть и красные, и синие ребра, поэтому я их истер. Тут они вполне могут
быть. Но нас это просто не волнует. То есть, мы говорим, что на каждом красном пути, по идее вот,
что там, ну как бы вот на этой вершине, в принципе, можно интерпретировать так. На вот
этом красном пути висят какие-то вершины. Ну, суммарный размер, то есть, суммарно,
сколько тут висит, это вот СЗ от этой вершины. Правда? Но теперь я введу, вот у меня было понятие
СЗ от В, а я введу СЗ light от В. Это будет равно 1 плюс сумма СЗ, допустим, СЗ от W,
где я буду говорить так W лёгкий ребёнок В. То есть, обратите внимание, то есть,
фактически я рассматриваю ту же СЗ, только отпиливаю тяжёлые поддели. То есть, я мог бы
тут написать СЗ light равно СЗ от меня минус СЗ от моего тяжёлого ребёнка или минус 0,
если у меня тяжёлых детей нету. То есть, вот такой вот СЗ light. То есть, я такое могу насчитать.
Обратите внимание, что у каждой вершины этот СЗ light тоже как минимум один из себя мы всегда
считаем. Понятно, да? Так вот, смотрите, какую структуру данных я тут на этом вот красном пути
построю. Допустим, этот путь у меня, тут у меня вершины В1, В2, В3 и так далее где-то ВК. Так,
ну во-первых, заметьте маленькое утверждение. Сумма по всем СЗ light от веитов, где и у меня
прибегает от одного до К, и вот веито, да? Оно равно чему? Чему у меня равно сумма СЗ light
от всех веитов? Ну, конечно, но СЗ в нашем случае от В1. Ну, потому что типа будем считать,
что путь от В1 до ВК это типа сверху вниз. Ну, это так просто чисто для понимания происходящего.
Так вот, значит, у меня идея такая. Смотрите, я буду идти по этому пути и суммировать СЗ.
Прям вот находить префикс префикс, и найду первую такую ситуацию. Вот первую такую ситуацию,
даже вот синим я буду рисовать. Когда сумма по И равно от одного до Ж вот этого СЗ light,
вот допустим это вот ВЖ, да? СЗ light от ВЖ больше либо равна, чем СЗ от В1 пополам. То есть,
видите, то есть, получилось, я тоже нахожусь в середину этого пути, но взвешенную, да? Вот,
то есть, нахожусь в первую. Это первая такая. Вот, но очень хочется, чтобы она была больше,
чем... так, вот тут ВИ, конечно, и тут хочется, чтобы она была, то есть, больше либо равна такой
же суммы, но И равна от одного до Ж-1. То есть, тут еще меньше половины, а тут больше либо равно.
Видите, да? Ну, во-первых, начнем с того, что раз тут больше либо равно половины, то и вот тут
больше либо равно половины, а вот тут строго меньше половины, согласны? И теперь у меня идея такая,
значит, я этот путь буду хранить так. Я буду хранить в двоичном дереве поиска по неявному ключу,
где вот эта вершина объявляется корнем, и слева и справа на нее вешаются под деревья,
которые сделаю абсолютно так же рекурсивным образом. Только вместо СЗ от В1 я тут подсуну
сумму СЗ-лайтов от этих вершин. Ну, по сути так, воспринимайте, может, по-другому. У каждой
вершины есть вес, да? Понятно, да? Так вот, я найду такую вершину, что у нее слева от нее сумма весов
меньше половины суммарного веса и справа от нее меньше суммарного веса. Ну ладно, я, кстати,
наврал. Такой вершины может не найти. Но там есть пограничные случаи, когда у вас вот можно,
когда у вас как бы тут четкая половина и тут четкая половина. То есть как бы корректно будет,
чтобы тут меньше либо равно стояло. Вот так. Вот. Вот, но это неважно. То есть такой, да, по сути
это такой взвешенный центроид на самом деле, да. Вот. Да, мы еще не знаем, что такое центроид,
но неважно. Вот. И тогда идея такая. То есть я буду выбирать вершину, объявлять ее корнем,
слева и справа у меня будут такие подпути, на которых я корень выберу тоже тем же способом.
То есть найду тоже взвешенный центроид уже этого подпути, повешу его, ну и так далее. То есть
заметим, что высота такого дерева, ну то есть на этом дереве, это двоичное дерево поиска,
я могу забабахивать на нем абсолютно те же самые всякие присваивания на отрезки, суммы на отрезки
и так далее. Да. Да. И более того, заметим, что каждым таком деревом мы будем работать за от
глубины этого дерева, ну высоты, а высота этого дерева от логарифма суммарного веса. Ну суммарного
веса не более чем n, поэтому получается, что на каждом пути у нас теперь лог n, причем на этот
раз буквально. Ну точнее так, чем глубже дерево, тем меньше этого веса, конечно, да, потому что там
реально лог n будет только у корневого дерева, и то если повезет. А чем глубже, на самом деле,
тем там скорее всего логарифм будет меньше, меньше, меньше. Ну это неважно. То есть получается,
что на каждом таком дереве мы будем работать за логарифм. Понятно, да? Нет, мы же их не пополам
делим. Тут если нам будет не вести с тот вопрос, где эта граница находится, она же не посередине
находится, она находится где угодно, потому что на самом деле там распределение весов может быть
каким угодно, может там вот на самом деле в конце вся бяка висит. Нет, с одной стороны да,
с другой стороны тут да, но можно это оценивать как логарифм суммарного веса. Потому что мы
специально выбираем вершину так, что когда мы переходим в ребенка, то суммарный вес во всех
вершинах соответствующих ребенку, он не более чем половина суммарного веса всего по построению. Да,
мы так выбираем. То есть получается такое, то есть такая взвешенная балансировка, да, то есть иногда
бывает выгодно балансировать не по количеству вершин, а по весу какому-то. Вот, то есть в общем-то
кстати вот в сплее дерева мы в общем-то с чем-то подобным уже сталкивались. Вот, но это ровно
примерно. А теперь, теперь самое мистическое. Теперь я утверждаю, что если вы будете работать,
подсунете такую структуру данных, то тогда все запросы вы будете делать не за лог квадрат,
а за логарифм. Прям буквально. То есть да, то есть у вас все еще будет путь разбиваться на логарифм
под, там на логарифм путей, каждый из которых является под путем какого-то вот этого тяжелого
пути, но вы их обрабатывать будете не то, что каждый за логарифм, а суммарно за логарифм.
Ну, за счет чего и будет победа. То есть понятно, что мы нацелились. Ну, то есть я сейчас попытаюсь
доказать, что если вы вот в каждом дереве забабахаете вот это и будете прям предельно
вот как мы обычно в дереве отрезков сверху делаем, прям забабахивать операции, то я утверждаю,
что это будет суммарно за логарифм работать. То есть не каждая операция, не каждая отдельная
операция с деревом отрезков за логарифм, хотя и это тоже, но и суммарно все, что нам потребуется,
будет работать за логарифм. Значит, смотрите. Ну, начнем с простого. Ну, на самом деле первое,
что мы заметим, это то, что задачу можно, по сути, свести к работе с путем от корня до
произвольной вершины. Ну, там точнее так. Давайте вот сразу общий случай обработаем. Как у нас,
вот мы уже такую картинку рисовали. Вот жил был у произвольный, жил был в. Да, вот тут лца и там
что-то есть. Тогда смотрите. У нас есть вот этот вот путь, который, возможно, нам потребуется. То
есть вот этот вот кусочек надо обработать за логарифм. Помимо него надо обработать какой-то
набор вот такого рода путей и вот набор вот такого рода путей. Чем они объединены? Они объединены тем,
что кроме вот этого пути все вот эти пути это префиксы своих путей. Согласны? То есть,
видите, мы не произвольные, то есть на самом деле мы там делаем запросы не на совсем произвольные
подотрески. То есть мы в основном работаем с префиксами. То есть кроме, может быть,
одного корневого вот этого пути, который мы за логарифмом обработали. Так вот, я утверждаю,
вот рассмотрим. Поэтому теперь без ограничений общества давайте скажем, что мы идем от предка
к потомку и обрабатываем только пути вот эти вот. То есть обрабатываем только пути,
в которых надо искать префикс. Поэтому я и сказал, что мы можем вообще даже оценить это так,
что давайте предположим, что мы обрабатываем только пути от корня до потомка. Вот. И так,
так вот, я утверждаю, то есть я сейчас хочу доказать это, как уже видно будет для нас победа,
это то, что если мы идем от рута до вершины У, то я утверждаю, нет, знаете, нет, не так мы сделаем.
Давайте я все-таки побольше тут картинку буду рисовать, потому что тут как бы хочется,
чтобы это было визуально понятно. То есть это не та вещь, которая хочется. Заметим,
что это логарифм, доказательства. Вот вам там на всю стену выкладки разбираетесь. То есть будет
это из цикла, что доказательства есть, оно вроде правильное, но классическая ситуация.
Вот. А теперь вот У. И вот как будем работать. Раз. Вот. То есть вот как-то вот. Заметишь,
тогда мы просто заметим, что мы работаем с какими-то вот, такими вот префиксами. И теперь смотрите,
давайте предположим, что мы, ну нам от перестановки обстрелить суммы не меняется,
будем считать, что мы идем сверху вниз. Как мы ищем сумму на вот этом пути? Значит,
мы сначала заходим вот это дерево. А визуально, как мы это в дереве отрезков ходили? У нас там
есть корень дерево отрезков, и мы на каждом шаге выбираем, мы идем влево или вправо. Правда?
То есть идем либо влево, либо вправо. Как это работает здесь? Допустим, значит,
здесь у нас на этом отрезке нашлась взвешенная середина. И допустим, она нашлась где-то вот
здесь. Тогда оказывается, что мы вот эту вот штуку выкидываем. И мы рассматриваем вот этот отрезок.
Теперь допустим, у этого под отрезка середина нашлась где-то здесь. Тогда мы прибавляем к
ответу вот эту сумму и рассматриваем вот этот отрезок. А теперь рассмотрим тут середину,
значит, отсекаем, ну и так далее. В какой-то момент мы наконец, за логарифомбирацией,
мы придем вот в эту вершину. Что так дальше произойдет? Потом мы пройдем вот это легкое
ребро, перейдем сюда и сделаем на этом пути абсолютно то же самое. Тоже будем делать
абсолютно те же самые спуски, но, может быть, они тут немножко в другом порядке отсекаться будут.
Там пум-пум, ну и там в какой-то момент сюда придем. И так вот это постепенно сделаем. Так вот,
я утверждаю, что вот этих вот вершин суммарно логарифом. Почему? Смотрите, ведь идейно,
если мы вообразим себе этот путь как вот это вот дерево наше, новоизобретенное дерево,
которое висит на сначала этой вершине, потом этой, потом этой. Понятно, да? То мы будем замечать
следующее, что на каждой вершине в этом дереве висят какие-то вершины, и у них есть какая-то
суммарный СЗЛайт, правда? Именно СЗЛайт. Так вот, заметим следующее, что когда я перехожу от вот
этой вершины к вот этой вершины, то суммарный СЗЛайт под деревя уменьшается в два раза. Логично,
да? Мы так строили. То есть мы тут несколько раз, то есть у нас тут изначально суммарный СЗЛайт был N,
но когда мы тут спускаемся, спускаемся, спускаемся, на каждом шаге СЗЛайт уменьшался в два раза. Теперь
дошли до этой вершины, прошли сюда, СЗЛайт просто уменьшился. Вот, и мы пришли вот в этот путь,
в котором весь вот этот СЗЛайт, то есть СЗ вот этой вершины, да? Ну СЗ вот этой вершины,
эту сумму СЗЛайтов в дереве, там вот этой вершины у нас была. Теперь тоже спускаемся,
он продолжает уменьшаться, уменьшаться, уменьшаться и так далее. То есть получается,
смотрите, то есть мы на каждом шаге внутри тяжелого пути у нас суммарный СЗЛайт как бы уменьшается в
два раза, а когда мы проходим по легкому ребру, получается СЗ, ну там СЗ получается, то есть СЗЛайт
там просто уменьшается. Видно, да? Да, обратите внимание, да, не в два раза, а просто уменьшается,
потому что это СЗЛайт мы тяжелые выкинули, да? Но, то есть получается, что АССИМТОТЬКА это от
логорифм, то есть получается у нас имеет место красный логорифм вот скачков внутри тяжелых
путей и плюс еще количество скачков вот собственно по легким ребрам. Но легких ребер у нас сам по себе
логорифм, поэтому получается, что суммарно у нас получился лого.
Ну я имею ввиду следующее. Ну не на префексе. Нет, ну не совсем так. На самом деле можно это
интерпретировать по-другому. Я имел ввиду, что я тут рассматриваю, я тут в дереве, то есть в этом,
в нашем экзотическом дереве том самом, да, иду по какому-то пути, вот так, да, спускаюсь, и у каждой
вершины есть такая штука, как сумма СЗЛайтов под дереве. Вот, то есть можно интерпретировать по-другому,
знаете как? Я бы интерпретировал так. Раз вот у нас есть путь, изначально он вот такой, и на нем у
него есть суммарность СЗЛайтов, да. Потом я выкинул вот эту половину и суммарность,
я рассматриваю СЗЛайтов вот на этом пути. Потом я выкинул, ну обработал, ну и выкинул вот эту часть,
и тогда сумма СЗЛайтов у меня там снова уменьшилась в два раза. Ну и так далее. Да, но я там еще,
да, я там выкидываю так, что у меня реально уменьшается в два раза. Да, тут даже вот так. То есть
обычно я тут, когда выкидываю, выкидываю вместе с корнем, да. Вот, и так вот я иду-иду-иду-иду,
и тогда в какой-то момент у меня этот путь сжался до вот этой вершинки со своим СЗЛайтом, да. Теперь
я из этого СЗЛайта я беру только СЗЛайты, которые висят вот на этом пути. Ну там еще могли какие-то
ответвления быть, но мы их выкидываем. Теперь я рассматриваю вот этот путь, на нем висят какие-то
СЗЛайты, ну их суммарно меньше, либо там меньше, чем сколько висело тут, и на нем повторяю эту
операцию. Нет, ну не обязательно для листа. Но там просто там фишка такая, что ты в какой-то
момент обрабатываешь вот путь отсюда до сюда, и выяснилось, что там этот взвешенный центроид его
оказался ровно вот эта вершина, вот эта вершина. Тогда там оказалось так, ты как бы получается в
левом поддереве вот этот путь-то его обработал и выкинул, в правом поддереве надо ты обработал
там путь, который нам не нужен, мы его тоже выкидываем. Поэтому получается мы слева отсекли,
справа отсекли, осталось только эта вершина. То есть в любом ином случае, то есть если бы там
центроид этого пути оказался выше, чем мы, например, то оказалось, что мы выкинули этот путь и выкинули
эту вершину. Поэтому получается мы как бы не менее чем половину выкинули. Вот такая красота.
В общем-то даже по реализации кажется не сильно убойно. Ну то есть пописать, конечно, придется.
Ну вот, в общем-то логарифом остается логарифом.
Так нет, мы так построили, что как бы когда вы там, то есть как бы вот был у вас путь,
да, и мы как бы соответствую ему построили вот какое-то вот дерево.
Ну и что? Ну тогда, смотри, тогда это будет интерпретироваться так, что весь вот этот путь
мы выкидываем и самую эту вершину выкидываем на самом деле. Нет, мы их выкидываем в каком плане?
Как бы сумму длинных ребер на этом пути или там сумму вершин не важно. То есть мы просто
за от единицы прибавляем к ответу. То есть тут тоже мы это как бы обрабатываем. То есть как бы есть два
способа обработать за от единицы, понять, что это аут. То есть против деревоотресков было два
способа выброситься за от единицы. Первый, мы попали в отрезок, который не пересекается с запросом,
поэтому возвращаем ноль. И второй, наоборот, мы попали в отрезок, который является под отрезком
запросного, поэтому мы просто берем сумму на нем полностью и тоже выходим. Вот как бы вот два
способа. Вот здесь тоже самое. То есть вот это мы выкидываем, потому что это нам не надо, а это мы как
бы обрабатываем за единицу, потому что это нам надо целиком. Вот и все. Вот собственно и вся не очень-то
хитрая идея. Ну ладно, хитрая, конечно. Ну то есть хитрая, но, как выясняется, как бы да. То есть,
в общем-то, идея нот. То есть тут оказывается, что просто дерево... Идея в том, что оказывается
деревоотресков нот. То есть можно строить взвешенные деревоотрески для какой-то взвеш,
то есть какую-то взвешенную балансировку по конкретным весам. Ну в принципе, в общем-то,
я думаю, скорее всего, когда вы там изучали какую-нибудь там оптимизацию кнута... Ну-ка,
поднимите руки. Кто знает, что такое оптимизация кнута? Это в динамическом программе такая оптимизация.
Вот. Так вот, там была... Ну вот там, собственно, классическая задача. Почему она называется
оптимизация кнута? Потому что кнут, ее, по крайней мере, по легенде, предлагал для такой следующей
задачи. То есть мы... То есть там дано дерево из N-вершин дерева поиска. То есть дано N-вершин,
мы хотим в нем построить дерево поиска. Но фишка в том, что мы про каждую вершину знаем,
с какой частотой ее будут запрашивать. И хочется сделать балансировку так, чтобы,
как бы, суммарное время, там, мотожидание, условно, времени дохода в этом дереве было как
можно меньше. То есть там... Вот это, на самом деле, буквально то же самое. То есть просто желать,
если там очень жирную вершину хочется поближе к корню, а если вершины редкие, то, в принципе,
там, если там раз в сто лет до вершины доберутся, то до нее можно, в общем-то, и за линию добираться.
Вот. Так что ничего страшного. Вот. То есть такая вот легенда была. Вот. Ну вот и... Ну вот. То есть
вот тут мы эту идею применили. Так что в следующий раз мы, видимо, попробуем эту идею
поприменять еще. Ну да, в следующий раз мы, конечно, будем, конечно, бросить себе еще
больше вызов. Это сказать, как говорится, делаем то же самое, но если деревья еще и переподвешиваются.
То есть мало того, что у нас несколько деревьев, которые подвешиваются друг к другу и еще и
отпиливаются друг от друга, так еще и у нас там будут наглая операция. А пусть корень не вот это,
а вот это. Ну, иногда в некоторых задачах, в общем, они формулируются таким образом,
что корня нету, да. Ну, такая тупая задача. Да, но несколько деревьев. И у вас запросы добавить
ребро, ну, гарантируя, что циклов не появилось, удалить ребро и найти какой-нибудь там минимум на пути.
То есть, в общем-то, в этой задаче, в постановке задачи корень не нужен. То есть он нужен нам,
в общем-то, там для какого-то удобства, хотя переподвешивать придется. Вот. Ну,
выяснится, что это тоже, оказывается, можно. Взвешенность и вот взвешенные балансировки
тут опять превращают логарифом квадрат логарифом. Правда, сильно более магическим
способом на этот раз. Вот. Но как конкретно, это мы уже узнаем в следующий раз. А на сегодня все.
