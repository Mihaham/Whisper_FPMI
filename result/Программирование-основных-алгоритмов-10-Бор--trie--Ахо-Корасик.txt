Кто-нибудь помнит, когда у нас лекция по счету? Пускай будет десятая. И будем ее...
Посветим сегодня немножко другое задачу, чем в прошлый раз. Если в прошлый раз у нас было
все про то, как искать точное вхождение одной строки в другую, то есть паттерна в текст,
в этот раз мы будем искать вхождение множества строк в текст. То есть задача наша идейна,
на текущий, наверное, час, данный n-строк, s1, sn. Хотим найти либо факт вхождения,
либо все вхождения. Вот так у нас будет задача. Что вы здесь можете вообще с точки
зрения применимости этой задачи сказать? Например, если у нас есть s и t заданы каким-то
регулярным условием, регулярным выражением, и при этом он там какой-то специфичного вида такой,
что он не может очень много раскрываться раз, то тогда можно по сути собрать все вот эти вот
коротенькие строчки и искать их вхождение. В тексте, например, во все возможные пути. Вот,
это так называемый греб, то что внутри используется. Вот, а пока что мы отступим от этой задачи и
научимся в такой структуре данных, как bore. Определение по-английски 3e, потому что Google
переводчик переводит как boron, и не тот немножко, не тот bore будет. Вот. Так, bore или 3e, или префиксное
дерево его еще называют. Кто это такой? Для строк, то есть у вас есть анстрок, и вы под ним
строите bore. Это такое подвешенное дерево, что на каждой, на каждом ребре написано
буква. Что еще есть? Из одной вершины не может выходить два ребра по одной букве,
нет двух ребер по одной букве. Что еще можно сказать про bore? Окей, то есть корневое дерево,
где на ребрах написаны буквы. Чтение по bore от корня вниз. Вершины, соответствующие с итом,
терминальные. Вот как-то так примерно можно отлить bore. Давайте для примера. Так, ну давайте
какой-нибудь множество строк рассмотрим. Да, просто bore будет ставить. Здесь идеи на никакого смысла нет
терминальности. Какой-нибудь вот такой вот набор строк. Да, тогда у нас есть корневая вершинка, дальше
будут эти переходы по буквам. Ну давайте выпишем сначала первую строку abac. И так как это конец строки,
она будет терминальной. Дальше у нас будет ba, ba. Ну она тоже терминальная. Дальше просто a. Она будет
тоже терминальная, потому что у нас есть строка a в наборе, значит можем ее просто прочесть. Дальше будет
аа. Идем по а, есть переход, отлично переходим по а. Перехода по а нет, строим новый переход,
и вернемся, что это терминал. И ab, переходим из корня по а, по b, считали, пришли вершинку,
ее тоже делаем терминально. Вот такой вот bore. Ну так его назвали. По-английски префиксное дерево,
или 3e. Зачем эта штука нужна? Во-первых, эта штука легко строится, у нее есть просто функция добавь
строку в набор. Называется иди из корня, пока есть переходы. Переходим переходом, когда нет
перехода, выписывай все остальное новыми ветками. Просто ветку рисуй. Все. Если вам сейчас скажут,
ходим в слово b, b, что-то там, вы идете по b, дальше у вас нет перехода по b, вы строите новый и
дописываете до конца ваше слово. Вот это добавление в bore. Соответственно, что еще можно сказать?
Помимо добавления в bore есть, понятное дело, поиск в bore. То есть вам нужно проверить, правда ли,
что есть строка в множестве? Ну вы просто берете, идете по bore и смотрите, правда ли, что вы в конце
концов пришли в терминал и всегда могли идти по веткам, ну по ребрам. Если да, то значит строка
есть в наборе. Например, есть ли в этом наборе строка a-b-a? Вы идете a-b-a, но это не терминал,
поэтому нет в наборе. Аналогично можно спросить, есть ли a-b, а-b в наборе есть, потому что пришли в
терминал. Есть ли b-b? b, а тут нет перехода, не смогли перейти, значит очевидно нет. Вот мы все.
Очень интеллектуальная структура данных позволяет вам, во-первых, добавлять строку за ее длину,
во-вторых, искать строку за ее длину. То есть есть строка в множестве. Что еще можно сказать? Можно
удалять строки из bore. Это чуть менее тривиально и оставим это на семинар, потому что нужно два
случая разобрать целых. Ну нет, там типа вы идете по строке, смотрите, правда ли, что этой вершины
нет больше других детей. Если нет, то поднимаетесь на уровень вверх, смотрите, снова нет ли у нее
детей или не является ли она терминалом. И если с этим там откусываете по ребру или в какой-то
момент вы остановитесь и закончилась удаление. Вот так. Что еще здесь нужно сказать? Ну,
про bore в целом все на самом деле. Что можно сказать? Давайте напишем еще табличку, а именно хранение
переходов или хранение ребер. То есть в каком контейнере мы будем хранить ребра? Потому что
мы можем хранить их в мапе по букве вершинку, в аннорной мапе по букве вершинку и в векторе,
если у нас там аффект какой-то маленький, мы можем четко сказать индекс буквы. Например,
а это нулевая буква, б это первая буква, z это 25-я буква будет. Вот, хранение ребер, память,
поиск. Ну и что еще можно сказать? Ну, в целом, это все, что нужно. То есть вот такие две штуки,
память и поиск. Потому что что поиск, что вставка, что удаление, оно будет за одно и то же время
работать. Так, хранение ребер первое, это вектор. Тогда какая память будет? В каждой вершинке вы
нужно хранить сигма вершины, где сигма это размер алфавита. Так, но зато поиск у вас четко
переход за единичку по одному ребру делается, золотые единицы. Потому что вы знаете, какую вам
букву нужно сейчас добавлять, вы просто смотрите по этому индексу. Ну, какую букву искать точнее.
Поиск строки q. Ну q это слово query будет. Дальше будет мап
из чара в ноду. Ну какая память будет здесь, как вы думаете? Ну да, именно так,
потому что вы ничего лишнего не храните в общем-то. Это вообще ни о чем. Это укладывается в константу.
Вы забыли главную мантуру алгоритмистов. Алгоритмисты это главные лжицы, они все
прячут в константу. Вот так, теперь поиск строки запроса. Ну сколько нам стоит переход по одному
ребру? Да, кулок сигма. Ну последнее, что можно здесь искать, это unordered map. Ну и конечно же,
конечно, бицеп, как всегда, будут отличаться своими лучшими характеристиками, в исключении того,
что она безумно медленная и поэтому примерно никогда не используется, потому что здесь константа
огромная внутри. Ну все-таки писать это будете. Я вам просто заранее говорю, что когда вы будете
писать либо это, либо это использовать, это обычно не проходит таймлимита, потому что очень долгое.
Тем более, у вас обычно a-z, поэтому вектор всегда устраивает всех. Так, и ладно, с Бором
разобрались? Есть вопросы по этой штуке? Ну видимо нет, превосходно. Тогда теперь небольшое
напоминание второму курсу, небольшое введение первому курсу о том, кто такие автоматы и зачем
они нужны. Определение. Недетерминированный. Конечный автомат. Далее НКА. Это картеж
такого вида. Пятерка получается. Где модуль Q меньше бесконечности состояния. Дальше Сигма.
Давайте считать его тоже конечным. Альфавит, потому что бесконечный алфавит это что-то не то.
Дельта. Это вот такая вот интересная штука. Подножство декартового произведения Q на Сигма на Q.
Это переходы. Дальше Q0. Стартовое состояние. Что еще можно сказать? Q0 лежит в Q и
F будет под множеством Q. Конечное состояние или терминальное состояние или принимающее состояние.
Так, все. Это очень страшное определение. Забыли его, поэтому я перемещусь сразу на другую доску.
Теперь как это нужно понимать в голове? У вас есть ориентированный граф, в котором есть вершинки.
Это состояние. Стартовое состояние обычно вот так обозначают. Дальше есть какой-то граф,
где на ребрах написаны буквы. Как раз таки дельта это функция перехода, которая берет Q,
берет состояние откуда вы стартуете, берет Сигму, буковку из алфавита и переходит снова в какой-то
элемент Q, то есть какую-то вершинку. Например, можно построить вот такой вот автомат. Ну и
крестиком помещаем терминальные вершины. Это прекрасный автомат. Он принимает в себя вот такие
строки A, AB, ABB и так далее. То есть A и какое-то куча B. Что? Кто? Значит нельзя принять. Все.
Ну, возможно это так называется, я уже не помню. Короче говоря, нельзя принять просто это слово,
не принимается. Вот мы говорим, что слово принимается автоматом. Там есть огромное
формальное определение. Мы будем говорить на детском научпопском. Если есть путь из стартового
вершины в какой-то терминал по буквам. Все. Там по хорошему определению надо писать не Сигма,
а Сигма со звездой, потому что у вас на ребрах могут быть написаны пустые строки, целые слова,
однако давайте будем считать, что по одной букве везде написано. Эпсимум перехода их можно сжать,
длинные переходы можно раскрыть. Вот. Окей, мы с вами определили, что такое слово принимается
автоматом. Соответственно, язык, который принимает автомат, это все слова, которые принимаются. Вау.
Отлично. Ну давайте простенького утверждения. Правда ли, что если язык принимаем автоматом
бесконечен, то в нем есть цикл? В автомате. В графе автомата цикл. А вернули обратное,
что если в графе автомата есть цикл, то язык бесконечен, который он принимает. Это неверно,
потому что просто у вас из этого цикла могут быть недостижимы терминальные вершины, или наоборот
цикл может быть недостижимый стартовых вершин. По приколу, вот так его нарисовали. Далее мы будем
считать, что у нас вообще язык будет всегда конечен на самом деле, но это не очень важно. Окей,
кто такой детерминированный автомат? Там написано детерминированный конечный автомат. Конечный,
потому что у вас сейчас состояние конечное. А детерминированный, это значит, что у вас из каждой
вершины по каждой букве выходит не более одного ребра. То есть у вас не может быть такого,
что у вас сюда по букве А и сюда по букве А. Потому что тогда просто автомату непонятно в какую
вершину идти, когда он придет сюда и встретит букву А в слое. Вот таких ситуаций мы себе не
позволяем, потому что у нас дельта – это однозначная функция. Если она принимает в себя состояние Q и
букву сигму, то мощность значений, то есть для любой Q из Q, для любой сигма из сигма дельта от Q
сигма, мощность таких не превосходит единичке. То есть может не быть вообще такого, не определено.
Тогда просто у вас автомат сломался, когда вы пытались читать слово. Может быть определено
тогда только одна вершина ему соответствует этому ребру. Если больше у вас получается
многозначная функция, по теории таких приколов вы будете изучать в третьем курсе,
в теории сложностей, когда будете говорить про детермированную машину тюринга.
Вот. Так, окей. Пам-пам-пам. Что здесь? Ну, с автоматами все получается.
Так. Тем, что в боре – это дерево. А тут можем петли себе вообще рисовать. Продолжим. Так,
кто такой автомат Аха Карасик, собственно? Возможно, вы слышали алгоритм Аха Карасик.
Вот вы не поверите, что он делал, потому что это автомат Аха Карасик. Вот. Собственно,
Ахо – это, по-моему, Ульфред или Альфред, я не помню. Ахо и Маргарет Карасик. Поэтому Карасик
не склоняется фамилию. Не автомат Аха Карасика. Вот. Соответственно, можно очень много разных
названий придумать к этой штуке, типа Хахакасарик и так далее. Давайте нормально его обзывать сразу.
Вот. Что мы хотим? Идеи на наши будут, значит, следующие. Помните, как мы с вами искали
вхождение строки в текст с помощью префикс-функции? Мы писали строка, решетка текст, считали префикс-функцию
и побеждали. Сейчас на смысл будет примерно похоже, однако мы хотим теперь построить в некотором
плане префикс-функцию не для одной строки, а для набора строк, а в общенную префикс-функцию. Вот.
Да, сразу скажу, что автомат Аха Карасик для одной строки будет автоматом префикс-функции. Вот. Ну,
потом мы это поймем. Так, давайте определять. Определение. Так, наверное, начнем с такой штуки.
Суфиксная ссылка вершины В. Это такая вершина У, что
слово, прочитанное в Боре, до вершины У, это наибольший по длине
не собственный суфикс такого слова В. Например, давайте рассмотрим опять же для этого Бора. То есть
у нас есть Бор, у нас есть набор строк вообще. Потом мы будем построили Бор. Собственно, суть
автомата Карасик в том, чтобы построить суфиксные ссылки, а потом построить функцию перехода по
автомату. А давайте посмотрим вот здесь вот. Вот для строки АА рассмотрим все ее суффиксы. Не
собственные. Первый суффикс это длина А. Можно ли его прочесть в Боре? Ну да, можно. Вот у вас есть
переход по А. Быть может не в терминал, это не особо важно. Дальше. Давайте вот для этой вершины
посмотрим суффиксную ссылку. Можем ли прочесть суффикс БАЦ в Боре? Нет. АЦ в Боре? Ну тоже нет.
Ц в Боре? Тоже нет. Поэтому только корень, пустое слово мы себя прочесть можем. Так,
давайте теперь для АБА. Суффикс БА. Прочесть можем в Боре? Да, можем. Вот он БА. Дальше. Строка АБ.
Вне суффикс БА. Можем прочесть? Да, можем. Вроде бы для всех нашел. А нет, еще вот сюда суффиксная ссылка будет вести.
Вот теперь для всех вершин нашел суффиксные ссылки. Что?
Который не равен длине строки. Ну ладно. Значит собственную определение надо написать. Который не равен длине строки.
Не равен всей строке. Вот так вот. Потому что понятно, если вы разрешаете быть равными всей строке, вы сами в себя придете.
Просто по определению. Вот. Это понятие суффиксной ссылки. И теперь вводится функция перехода, так называемая,
Дельта из нашего пленни автомата. Она вводится рекурсивным образом. Точнее не так. Из вершинки В по букве Сигма.
Куда она нас должна привести? Давайте определим просто как функцию, рекурсивным.
То есть если в Боре у вас есть переход из вершины В по букве Сигма, вы просто переходите как в Боре.
Очень интеллектуально. Иначе это ту от линк от В. Сигма. Вот так вот. Интересным образом она определяется.
То есть если вы можете пройти по букве в Боре, то идете как в Боре.
Если нет, вы идете в суффиксную ссылку и дальше смотрите, можно ли прыгнуть или нет.
Допустим нет, тогда вы еще раз будете прыгать по суффиксной ссылке.
Итого. То есть допустим нам нужно отсюда перейти по букве В.
Вот эта вот вершинка В, мы хотим посчитать ту от В по букве В.
Смотрим, есть ли переход в Боре? Нет? Хорошо. Тогда раскрывается по второй ветке определение.
Так, суффиксная ссылка вершины В, вот она. Это вершина У.
Смотрим, есть ли из У переход по букве В? Нет. Грустная история.
Значит раскрывается по второй ветке определение.
Ну, суффиксная ссылка У это корень.
Есть ли переход из корня по букве В? Это будет вершина У.
Вот как это нужно понимать, это определение.
Да, вот действительно непонятно, что такое суффиксная ссылка от корня.
Не понятно, как это определить. Это раз.
Два, непонятно, как определять переходы из корня по буквам, которых нет в Боре.
И здесь есть два подхода.
Чуть более формалистский и менее костыльный, есть чуть более костыльный.
Считается, что все переходы, что суффиксная ссылка корня, зацикливаются сама на себе.
Вот.
Ну тогда прямо в том, что вы будете бесконечно по ней петлять.
Поэтому обычно вводят фейковую вершину пред корень,
такую, что из нее переходы есть по всем буквам алфавитов корень,
а суффиксная ссылка корня – это вот эта вершина.
Тогда у вас никогда не встретится вторая ветка из этой вершины,
потому что из нее всегда есть переход по любой букве.
Вот, это самый такой каноничный вариант, как-то можно определить,
чтобы не противоречить никаким определениям.
Вот.
Или можно считать, что если вы пришли в корень и нет перехода по букве,
и дописать туда третью ветку в определении,
что если у вас в это корень и нет перехода, то останься в корне.
Вот. Как делать? Считайте сами, как вам кажется более консистентным.
Ну я там обычно делаю, скорее, что завожу просто фейковую вершину у себя в коде,
и из нее провожу ребра во все в корень, чтобы не петлять бесконечно.
Нет, смотрите, если у меня из корня переход по С,
я раскрою по этой ветке, потому что и нет по букве С перехода.
А линк от корня – это корень. Я вернулся в себя.
Тот же вопрос спрашиваю – то отрут по букве С.
Вот.
Чтобы выйти из рекурса, нужно либо так, либо так определить.
Можно сделать так, чтобы из букв, в которых нет перехода в борь,
из корня ввести правильно в корень.
То есть тут как бы много вариантов, как пофиксить это на самом деле.
И опять же, это просто дописывается вот третьей буквой определения вот сюда.
Третьей веткой.
Потому что если у вас В – это корень, то отрут по С.
Если есть переход, то это переход.
Если нет перехода, то это корень.
Или дописываются ребра туда.
Тут много способов обойти формализм определения.
Однако главное так, чтобы в итоге для конечного пользователя
все это работало и не зацикливалось вечно.
Как именно вы поправите эту коллизию – это уже ваше право абсолютно.
Вот.
Так, ну теперь нам нужно доказать самое интересное утверждение,
на котором будет базироваться построение автомата, собственно.
Я хочу посмотреть, что такое линк.
Отту из вершины С по букве В.
Я хочу показать, что это вот такая вот интересная величина.
Утверждение, упражнение, очевидность.
Вот, это то, что я хочу, собственно.
Если я это делаю, все.
Дальше алгоритм построения автомата – написать BFS.
Окей.
Теперь здесь нам пригодится видимо понять,
что значит это вот определение линка.
Тот ВС – это переход по вершине С.
Вот, и давайте рассмотрим.
Так, сейчас.
Ну давайте попробуем это доказать как-нибудь.
То есть, смотрите, вот это вот у нас вторая ветка определения.
Давайте я хочу доказать равенство просто в обратную сторону.
То есть, я хочу доказать то, что не это равно этому,
а наоборот это равно этому.
Да, перейдем из пустого в порожнее.
Ну в смысле, тут как бы неважно, что чему равно.
Просто у нас здесь есть слева уже вот такая вот штука.
Поэтому я хочу переписать это утверждение,
что у нас была слева эта штука.
Хорошо, давайте определим, что такое тот линк от В по С
или линк от ТОС.
Давайте напишем сначала линк от ТОС в С.
С это что такое?
Наибольший суффикс
тот ВС, который есть в Боре.
Ну просто по определению линк, да?
Который заканчивается на букву С при этом.
Он заканчивается на букву С.
Если его длина хотя бы единичка.
Может, если у вас общий суффикс пустой,
то он, понятно, из корня у вас будет идти.
То есть, случай какой?
Можно рассмотреть длину линка тот ВС,
если она равна...
Так, сейчас, окей, что теперь нужно говорить?
Как устроим суффикс?
Так, давайте...
Здесь нужно рассмотреть две ветки.
Первая ветка, что у нас в Боре есть переход по С.
Это у нас будет В.
Это С.
ВС в Боре.
Тогда, если тот ВС в Боре,
то линк от него, это просто линк от дочерней вершинки.
Вот, хорошо.
Тогда, что у нас здесь есть?
У нас есть какие-то суффиксы.
И вот какой-то из них...
И, по сути, что делают суффиксные ссылки?
Они перебирают все суффиксы, которые есть в Боре.
То есть, суффиксная ссылка сначала берет вот этот максимальный суффикс,
потом его максимальный суффикс какой-нибудь,
этот, который есть в Боре,
и так далее, и так далее, и так далее.
Оно переберет во вложенности все суффиксы, которые есть в Боре.
Аналогично с этой будет строкой.
Тоже все суффиксы переберутся.
И вы возьмете самый первый суффикс,
который можно дописать буквой С.
То есть, вот, допустим, ваш...
линк от В.
Дальше у вас будет еще
линк от линк от В.
Суффиксная ссылка сюда, суффиксная ссылка сюда.
И вы выбираете первую, которую можно буквой С продолжить.
Ну, собственно, это есть определение.
Вот.
Но я утверждаю, что это и есть то, что вам нужно.
То есть, мы берем ту от линка от В и С.
Смотрим, правда ли, что удастся в первый раз продолжить буквой С.
Если нет, значит, такого перехода в Боре нет.
Мы пользуемся второй веткой определения.
Значит, мы спустимся еще раз
и пытаемся продолжить буквой С.
И так далее.
То есть, по этому вроде это случай очевиден,
что это то, что мы именно хотели.
Потому что все остальные суффиксы
продолжить буквой С нельзя было.
Мы перебрали все вот эти кусочки,
которые вообще были в Боре.
И из них выбрали наибольший,
который можно продолжить буквой С.
Потому что остальные буквой С架ть было нельзя.
Вот.
Им перебрали все суффиксы, которые были в Боре.
Поэтому здесь все окей.
А, так, второй случай. Это ту от vc не вборе, но внезапно логика вообще не меняется, вообще, просто все абсолютно то же самое рассуждение у вас будет проходить.
Если у вас ту от vc не вборе, вы сначала посчитаете ту от vc, то есть наибольший суффикс, который можно продолжить буквой c, получите его опять же, но ведь это и есть вот эта вот штука.
То, что вы могли продолжить буквой c. Ну и все. То есть это просто два разных взгляда на одну и ту же вершину.
То есть если вы пришли к ней вот так вот, то что она есть вборе, и поэтому берете от нее кучу раслинг, либо же вы берете от самой v кучу раслинг, пока вы не смогли продолжить c, то есть абсолютно та же логика.
В каких строках мы будем строить?
В задачах, на исытых мы будем строить. То есть на то, на какие запросы у нас будут. У нас будет запрос типа, да он множество строк, мы хотим найти все вхождения этого множества строк в текст.
Будем строить на этом множестве строк и далее прогонять текст по автомату.
Так, давайте теперь, собственно, алгоритм построения автомата. Ваша любимая индукция по длине слова.
База индукции. Это слово длина 0, слова длина 1.
Так, линк. Вот. Вершины v равно root, где v, длина слова соответствующей буквы v, равна единичке.
То есть база индукции, это у нас наш корень, есть какие-то у него дети.
Тогда у него база индукции в том, что все суффиксные ссылки ведут в корень.
Это первое, что нужно определить.
Второе нужно определить, что tun от root по букве c равно по c, если в боре.
А теперь, если не в боре. Если в боре, есть ребро из root в c по букве c.
Если у нас нет этого перехода, ну давайте просто зациклимся на корне, останемся.
То есть база индукции такая, что у нас известны переходы по всем буквам.
То есть у нас построена наша дельта для корня по всем буквам, и есть везде суффиксные ссылки.
Переход.
А стоим в вершине v.
Вот мы стоим в вершине v.
Мы хотим понять следующее.
То есть предположение индукции такое, что к моменту, когда мы рассматриваем вершину v, нам известна ее суффиксная ссылка.
Очень интеллектуальное предположение.
Стоим в вершине v. Ну база индукции, конечно, когда вы стоите здесь, вам известна ее суффиксная ссылка.
Окей, так, стоим в вершине v, что происходит?
Определяем tu v. То есть для всех букв мы определяем tu из вершины v.
Так как если это в боре, то нам известен переход.
А если это не в боре, значит вся суффиксная ссылка куда-то вела.
Причем вершину хотя бы на один уровень выше.
А из этого следует, что из нее уже все переходы по буквам известны.
Потому что она была уже рассмотрена выше.
По длине слова.
У нас грубая индукция по длине слова сейчас происходит.
Просто я формально не выписываю.
Определяем tu от v точки.
Что? Почему индукцию формально не выписываю?
Могу себе позволить.
Ну если очень хотите, здесь не очень сложно провести.
Вы говорите, окей, хорошо, пусть длина рассмотрена, слово равно k, мы закончились в вершине v.
Тогда говорим, что длина линка от v хотя бы k-1.
Из этого следует, что про нее уже все известно.
А значит, можно вот это вот написать.
Доска, к сожалению, не резиновая.
Стирать по ней очень сложно.
Вот, и для поддержания темпа я не пишу вот это все.
Так, определяем tu от v точки.
Окей, определили по всем буквам, мы знаем теперь переходы из вершинки v.
Что дальше нужно сказать?
Ну мы утверждали, что к моменту, когда мы спускаемся в вершину, мы знаем все ссылки от нее.
Давайте их определим просто.
Определяем tu, ой, наоборот, link от tu от v точка, как вот по этому утверждению tu от link от v точка.
Конец, все.
Это шаг индукции.
Это шаг индукции.
То есть, вы для вершины узнали все, что нужно.
То есть, к моменту, когда вы придете дальше рассматривать вот эту вершину, вы суффиксную ссылку ее уже знаете.
Вот, допустим, у вас здесь есть вершинка tu от link от v сигма.
Тогда вы знаете четко, что у вас за этой вершинкой идет вот сюда вот суффиксная ссылка.
То есть, к моменту почтения этой вершинки вы знаете ее суффиксную ссылку.
И все, это все, что вам нужно знать по сути, благодаря вот этому утверждению.
А базовая индукция вам задана на уровне 1, вы знаете суффиксную ссылку вершин.
Ну все, весь алгоритм.
Теперь у нас в слове идет слово c c c c c.
Слово, вот эти c мы можем игнорить.
Это нормальная ситуация.
Потому что мы же ищем вхождение строк в текст.
Вот, поэтому это будет нормально.
Еще раз.
Ну смотрите, вот вы стоите в вершинке, у вас есть какие-то переходы по бору.
Вот у вас переход по букве, который нет в боре.
В смысле нет?
Вот вы спустились в вершину, вы прочитали.
Не знаю, у вас слова есть a b a, a b b.
Вам дали слово a b c.
Вы вот спустились a b и пытаетесь идти по c.
В боре нет перехода по c.
Есть только по a из этой вершины и по b из этой вершины.
Ну блин, страдаем.
У суффиксной ссылки может быть переход по c.
Мы так определили ее.
В боре.
В боре.
Там у каких-то других вершин может быть переход по c.
В смысле, то от v точка определяем вот так вот.
Абсолютно.
Только вместо root пишите v.
По определению.
По определению имеется в виду вот эти вот формулы.
OK.
Ну все, теперь давайте...
Собственно, как этот алгоритм теперь реализовывать?
Какой обход у нас обходит в вершины графа в порядке увеличения достиженности?
BFS?
Не DFS, да.
Ну DFS, он, типа, смотрел вершинку.
Он не рассмотрит сначала все вершины на одном уровне, потом все вершины на втором.
И что?
Нам нужно к моменту, когда мы рассмотрели...
Когда мы рассматриваем эту вершину, рассмотреть все вершины выше.
Потому что у нее есть суффиксная ссылка, которая куда-то там идет.
Понятное дело, что это можно писать просто ленивой рекурсией.
Просто вы хотите посчитать тот vc какой-то, вообще произвольный вершины v по букве c.
Вы просто берете эту вершину и считаете просто рекурсивно.
И это будет работать.
Быть может не эффективно, но будет работать.
А если вы будете запоминать результат, то оно же активно работать будет.
Однако это удобно строить BFS.
То есть вы обозначили базу, вот она.
И дальше у вас BFS просто идет, берет вершинку очередную,
делает форум по букве, определяет tu и линка tu.
Все, то есть алгоритм BFS, и вам нужно эту штуку прописать.
Как вы знаете, BFS определяется с чем?
Правильно, визитором.
Затравочка на успех.
Сейчас я напишу второе определение.
И понятно будет, что нужно будет просто переиспользовать его.
Так, следующее определение.
Сжатая суффиксная ссылка.
Сжатая суффиксная ссылка.
Ну как мы ее обозначим?
Если у нас была линк, давайте Compressed.
Compressed сжатый, поэтому давайте Comp будет от f.
Нет, это долго.
Понятно, что в коде у вас будет Compressed суффикс линк, если что.
Какой линк?
Что?
У меня это Comp будет.
Я уже настроил мозг на Comp.
А, тогда как она определяется?
Comp от v.
Линк от v, если линк от v – терминал, терминал или корень.
И второй вариант.
Иначе.
Кому понятно, как считать Comp от v в этом куске кода?
Нет.
К моменту вычисления Comp от v, вы знаете, кто такой линк от v?
Значит, вы можете знать корень это или терминал.
Если то и то, вы заканчиваете вычисление.
Иначе вы берете Comp от линк от v, но на момент вычисления вот этой штуки она у вас уже известна,
потому что линк от v выше была.
Поэтому у вас не будет второго уровня рекурсии.
Вот, поэтому эта штука тоже быстро считается.
Вот эту?
Так нет, вы уже знаете линк от v.
Этот штуку вы уже знаете на этот момент времени.
Да, мы строим линк для детей.
То есть вы стоите в вершинке, вы для всех сигма перебираете детей,
и когда берете ребенка, считаете его суть на ссылку тут же.
Это делаем к BFS, да?
Да, BFS это делает.
То есть BFS за одну итерацию вот это вот вычисляет.
То есть итерация BFS – это фор по буквам афабита из вершины.
И он считает для каждой буквы эту штуку и эту штуку.
Ну еще потом будет в конце, после всех букв, компот v еще считать.
А нет, для каждой ребенка компот v считать он будет.
Вот, так же как и линк.
Ну, он считается абсолютно так же, как вот это вот.
Потому что либо вы смотрите в линк от v, если это терминал, то все ок.
Если не терминал, значит вы уже знаете, кто такой компот линк от v на этом моменте.
А, ну очевидно, что здесь для вершин уровня 1, для базы индукции,
жар за ссылку на ссылку – это корень.
Просто по определению той штуки подходит.
Давайте определение нарисуем.
У нас будут вот такие вот строки.
То есть у нас будет одна строка C, переход из корня.
И все.
То есть у нас африт, абс, если что.
То есть у нас африт, абс, если что.
Так, тогда у меня что получается.
Есть корень, то есть переход по C такой, отщепенец.
Есть все остальное.
То есть по букве А.
У него есть АБАБ.
Дальше есть БАБАБ.
Да.
Я хочу посчитать ту из этой вершины по букве С.
Давайте просто весь алгоритм вообще проведу, да и все.
Только без сжатых ссылок, иначе просто загромодится рисунок.
Так, дальше. Иду из этой вершины, иду по всем буквам.
Окей, ту из этой буквы по Б.
Так, и по букве А сначала, да.
Из этой вершины хочу по букве А пройти.
Смотрю, правда ли это?
Хорошо, понимаю, что я не могу пройти по букве А.
Иду в суффиксную ссылку, иду по букве А, все ок.
Поэтому суффиксная ссылка отсюда по букве А сам в себя перешел.
И это нормально.
Ну просто по всем определениям схлопывается, что мы можем перейти сами в себя.
Это нормально.
Окей, хорошо, по букве Б перехожу.
Смотрю, Б я могу прочитать в Боре, да?
Чего не так? Я беру сначала суффиксную ссылку.
Потом смотрю, можно ли из нее пройти по Б? Ну да, могу.
А вы сами в себя не рисуете, или вы его по букве А не рисуете?
Это переход по букве А.
Нет, он, короче говоря, его в памяти и в коде у вас будет использоваться как переход по букве А здесь.
Если вы про это.
Переход по букве С отсюда, это кто?
Это суффиксная ссылка.
Потому что там перехода нет по букве С.
Переход по букве С.
Поэтому переход по букве С вообще вот сюда вот.
По сути вы получите полный автомат.
С каждой большинкой по каждой букве перехода.
Б, Д, К, да.
Вот, ну окей.
Ну такое себе.
Такая себе минимальность, если честно.
Потому что здесь не понятно, что такое минимальность.
Ну точнее понятно, что такое минимальность здесь.
И я не уверен, что он минимален.
Ладно.
Можно теперь я не буду рисовать переходы, которые не в Боре.
Потому что они понятно, как вычисляются.
Я просто суффиксные ссылки порисую.
Так.
Из этой вершины мы вычислили для всех детей.
Так, теперь для этой вершины считаем.
Точнее вот для вот этой вершины для всех детей считаем.
А.
Смотрим, кто суффиксная ссылка.
По букве А это сюда.
Суффиксная ссылка этой вершины это вот это вот.
По остальным детям перехода нет.
Однако, если бы я захотел отсюда перейти по букве Б.
Я бы поднялся бы вверх и перешел по букве Б в себя же.
Так.
Ну по букве С я бы перешел бы сюда аналогично.
Так, дальше.
Вот эта вершина.
Кто не суффиксная ссылка?
Это ту.
Из этой вершины по букве А.
Суффиксную ссылку.
По букве А. Переход.
Вот оно.
Ну здесь будет вот так вот сразу скажу.
Здесь будет.
Пам-а-б.
Здесь будет вот сюда вот переход.
Вот они суффиксные ссылки.
Да, как видите, если у вас есть какие-то общие ветки, они будут вот по ним суффиксные ссылки параллельно так идут.
Верно.
А, давайте вот так напишем.
Если не в Боре, то мы просто линк от нее не считаем.
Потому что это бессмысленное занятие.
У нас совершенно нет в целом в Боре.
Если есть в Боре, вы хотите посчитать вот эту вот величину.
Она вам неизвестна.
Так, ладно.
Давайте решим задачу собственно теперь.
Вот такой набор строк у меня очень классный.
А, Б, А, Б, Б, А.
Он специально взят попроще, но при этом он очень неприятный бы с точки зрения анализа сейчас.
Да.
Чтобы разобрать все возможные варианты.
Ну, кроме, естественно, тех, где почему-то приятнее.
Ну, в общем, я не знаю.
Да.
Чтобы разобрать все возможные варианты.
Ну, кроме, естественно, тех, где почему-то приходит не в корень суффиксной ссылки.
Чего?
Это Бор.
Нет.
Здесь все вершины кроме корни терминальные.
Может, еще добавим?
Не.
Кто добавляет Epsilon в язык, тот вообще уже делает совсем какие-то странные вещи.
Надо еще доллары поставить.
Нет, это будет в следующий раз.
Не, ладно, в следующий раз даже долларов не будет на самом деле.
Евро будет?
Нет.
У нас не будет в целом значков валют.
Нам не понадобится.
Так.
Так, давайте сразу проиндексирую слова.
И выпишу сразу возле каждого терминала.
У меня будет стоять индекс, в какой строке он соответствует.
Очевидно, что у меня может быть много строк в наборе одинаковых.
Может быть, много индексов в терминале.
Но я пока что опущу, чтобы просто он один.
Вот это не терминал.
Это не номерация совершенно, это строк, который у нас есть в наборе.
Окей, так, что теперь?
Сразу строим суффиксные ссылки.
Так.
Теперь я хочу прогнать текст.
И хочу найти все вхождения всех строк из набора в этот текст.
Да, сразу скажу, этот пример был специально нарисован, чтобы все терминалы были, кроме корня, чтобы у меня сжатые суффиксные ссылки совпадали с обычными.
Вот это важно.
Здесь будет сейчас.
Потому что, если у меня не было B, например, у меня была сжатая суффиксная ссылка отсюда, я отсюда ввел бы сразу в корень.
Давайте B уберем.
Ну, и буду считать, что сжатая суффиксная ссылка у меня уже посчитана.
Просто их не буду рисовать, иначе рисунок станет совсем огромным.
У меня нет просто второго цвета.
Что?
Как у нас старебра?
Ну, я не очень хочу это делать.
Ну, давайте вот так вот.
Это сжатые суффиксные ссылки.
Да, я убрал B.
Ну да.
Индекс я сдвигать не буду, сразу говорю.
На этот развод вам меня уже не развести на такое.
Окей, теперь я запускаю текст.
Я просто текстом иду по автомату.
И каждый раз, когда я совершаю переход, я прохожусь из вершины по всем сжатым суффиксам вплоть до корня и выписываю ответы.
Как это понимать?
Поехали.
По букве A.
Иду из корня всегда.
Смотрю. По букве A.
Пришел в терминал.
Который соответствует вершине 1.
Выписываю. Вхождение соответствует позиции 1.
Прыгаю по сжатой суффиксной ссылке.
Пришел в корень. Закончили.
Иду дальше. Следующая буква B.
Вижу A, B. Пришел в терминал номер 3.
Говорю, значит, что для третьего появилось...
Дайте я буду читать окончание вхождения. Понятно, как начало посчитать для строки.
Вы должны просто вычесть длину строки.
Два.
То есть вот оно.
1, 2, A, B входят.
Позиция окончания вхождения равна 2.
Прыгаю по сжатой суффиксной ссылке. Это корень.
Все. Дальше нахожусь снова здесь.
Иду по букве C.
Спрашиваю, кто такой ту из этой вершины по букве C?
До этого там пропрыгал по суффиксным ссылкам.
Посмотрел что-нибудь перехода по букве C.
И остался в корне.
Прыжок по букве C завершен в корне.
И пытаюсь пройти из него снова по сжатым ссылкам.
Но их нет.
Поэтому новых вхождений я не добавил.
Я не пришел в терминал.
И ни одна сжатая суффиксная ссылка не привела меня в терминал.
Поэтому новых вхождений, когда добавил букву C, не нашлось.
Как это можно понимать?
Как вы знаете, каждая подстрока это суффикс какого-то префикса.
Когда мы рассмотрели какое-то начало, то есть прошли по автомату им,
мы теперь смотрим, какие есть суффиксы у текущего вхождения, которые добавились.
То есть, помните, у вас на семинаре была задача, где нужно было посчитать число подстрок с помощью префикс-функции.
И там мы рассматривали с вами, что вы сначала берете строку, затем записываете к ней символ.
И что дальше вы делали?
Мы брали и искали суффикс максимальной длины, который все еще входит.
Здесь вы делаете точно так же, так как вы перебираете все суффиксы, которые могут входить как куски этих штук, как суффиксы этих строк.
Просто перебирайте, возможно, все эти строки.
А так как вы прыгаете только по сжатым суффикам ссылкам, вы каждый раз либо увеличиваете ответ на 1, потому что вы прыгаете в терминал,
либо же, что делаете, правильно, прыгаете в корень этой сжатой суффиксной ссылкой.
Пока что это рассуждение мы оставим в воздухе, потом это ружье выстрелит обязательно.
А потом будем читать асимптотику.
А пока мы перешли по букве С.
Вот мы здесь находимся.
Дальше считываем еще одну букву С.
Ту из корня по С снова в корня нас зацикливают.
Снова пропрыгали по терминалу, ничего не нашли.
Но если бы здесь был Эпсилон в наборе, у вас корень был бы терминальным,
и вы бы каждый раз своими суффиксными сжатыми ссылками допрыгивали бы до корня,
и каждый раз должны были бы учитывать Эпсилон в ответе, потому что Эпсилон входит ровно в каждой позиции.
Ну это только для Эпсилон, для остальных еще сложно.
Так, окей, вот мы читали А, Б, Ц, С.
Читаем букву С.
Чуть букву Б, сори.
Так, пришли сюда.
Прыгаем из нее по сжатым суффиксным ссылкам, припрыгали в корень, нет вхождения новых.
Пошли дальше, Б, Б.
Мы находились здесь, идем сюда.
Окей, новое вхождение Б, Б.
У шестого появилось новое вхождение, что это?
1, 2, 3, 4, 5, 6.
То есть, прыгаем по сжатым суффиксным ссылкам, переходим в корень.
Он не терминальный, новых вхождений нет.
Дальше.
Так, па-па-пам.
Буква А.
Кто такой?
Ту из буквы Б по букве А.
Суффиксную ссылку.
Хоба оказались здесь.
Вот вы здесь пытаетесь перейти по букве А, ее нет.
Тогда по формуле вы должны перейти по букве А из нее.
Такой переход в Боре есть.
Потому что в формуле по обычной ссылке переходят.
Сжатая ссылка, она просто нужна для подсчета ответов будет нам.
Больше не для чего.
Она не нужна как конструктив автомату.
Но она нужна для быстрого подсчета ответов.
Так, раз-два.
Пришли.
Смотрим.
Ага, вхождение 4.
У нее новый индекс вхождения.
Это 4, 6, 8, 7.
Это мы одну А прочитали пока что.
У нее 7 вхождения.
Дальше.
Прыгаем по сжатой суффиксной ссылке.
Опа, вхождение еще одно.
У днички добавилось вхождение в 7.
Прыгаем.
Прыгаем по сжатой суффиксной ссылке вновь.
Корень и терминал закончили путешествие.
Окей, находились здесь.
Снова читаем букву А.
Смотрим, кто такой ту отсюда по А.
Хоба.
Запускаем.
Пятое.
Значит, пятое входит в позиции 8.
Дальше.
Прыжок по сжатой суффиксной ссылке.
Первое входит в позиции 8.
Снова прыжок по сжатой суффиксной ссылке.
Закончили.
Переход по букве Б.
Окей.
Хоба.
Пришли снова сюда.
Оказались здесь.
Третье еще входит в позиции 9.
Прыгаем по суффиксной ссылке.
Расчет окончен.
Это ответ.
Других подстрок нет.
Вхождение, точнее вот этих строк в текст.
Нет.
Чтобы быстро проскакивать слои суффиксных ссылок.
Потому что в общем случае суффиксная ссылка может вести не в терминал.
То есть раз не терминал.
Дальше два не терминал, три не терминал.
Это огромные пути суффиксных ссылок могут быть.
Такого не очень хочется.
Все-таки хочется сразу прыгать и учить.
Вот ответ новый.
Поэтому нужно сжатые суффиксные ссылки.
Поэтому время построения.
То есть за сколько мы вообще решаем задачу?
Восьми.
Автомата.
Я сейчас выпущу все составляющие.
Дальше.
Время переходов.
От модуль Т если у вас переход за единичку делается по букве.
Под словами «переход» под называется именно чисто
взятие tu от вершины и буквы, потому что вы все время ходите
по функции tu здесь, именно поэтому она вам была нужна.
Так у вас уже все тушки посчитаны, у вас переход
за единицу делается, поэтому здесь длина текста.
И смотрите, что мы с вами еще делали.
Мы с вами еще прыгали по суффиксным ссылкам.
Зачем?
Чтобы найти все возможные слова, которые заканчиваются
при прочтении текущего префикса.
Потому что у нас могут входить это слово, это слово, это
слово, входить.
И нам нужно их все собрать.
Но прием может быть том, что у нас может ходить, например,
вот такое вот слово, вот такое вот и вот такое вот.
И зачем мне по суффиксным ссылкам тут по одному прыгать?
Ну, допустим, как-то так набор строк устроен, чтобы
я по одному везде прыгать наверх.
Если я могу сразу прыгать по сжатой суффиксной ссылке
и либо увеличивать ответ на единицу, либо прилетать
в корень.
Поэтому время прыжков, я утверждаю, что оно ограничено.
Суммарное число прыжков давайте, число прыжков по
суффиксным ссылкам не превосходит два на суммарное число
входения.
То есть вот анс, где анс – это суммарное число входения.
Вот какой-то алгоритм, который зависит именно от числа
входения.
К сожалению, да, здесь такое есть.
Ну вот, то есть у нас везде линия по сути, здесь линия
от суммарного размера, здесь линия от длины текста
и здесь линия от длины ответа.
Как мы могли решать эту сдачу по-другому?
Просто для каждой строки найти все вхождения в текст
путем алгоритмов с прошлой лекции.
В чем проблема, у вас получается размер множества на длину
текста во симптотике, потому что вам каждый раз придется
заново перестраивать все.
Этот алгоритм этим не страдает.
Боль-то он детерминированный.
То есть с чем суть?
Суть в том, что мы каждый раз при переходе в автомате
выбираем такой путь, который соответствует самому длинному
суффиксу, который можно встретить как кусочек этих
строк.
Как префикс какой-то из этих строк.
В некотором плане это обобщенная префикс-функция.
Почему?
Потому что там у вас было каждый раз супрефиксы вы
прыгали.
А здесь вы прыгаете из вершинки в наибольший префикс,
который существует.
То есть вы берете вот этот кусок пути и ищете суффикс,
который может быть префиксом во всех строках.
И в качестве примера здесь нужно проиллюстрировать
ахакарасик для одной строки и его мощи в префикс-функции.
Так, для строки абатсаба рисуем.
Как вы можете догадаться, вор будет гирляндой.
Абатсаба, вот он.
Может было горизонтально нарисовать, но уже ладно.
Так, суффиксная ссылка для этой понятно сюда.
Суффиксная ссылка для этой штуки.
Смотрим из этой, тупо Б сюда перейдет.
У этой штуки.
Смотрим суффиксную ссылку, переход по А нашли.
Дальше у этой снова в корень прыгаем.
У этой, у этой и у этой какой-то снатах ахакарасику
нет.
Она одна.
Гармония на душе достигнута.
Окей, теперь давайте посчитаем префикс-функцию для этой
штуки.
Я думаю, вы уже догадываетесь к чему это приведет.
Ахакарасик превращается в автомат префикс-функции.
Потому что вы четко знаете, куда из каждой буквы вы
можете пойти.
Аналогично, только теперь вы берете себе максимальный
суффикс, равный префикс не в своей строке, а вообще
во всех строках.
Поэтому это можно назвать обобщенной префикс-функцией.
И это, в общем-то, та идея, которую мы сами реализуем,
этот вот проход текстом по автомату.
По сути, мы же что делаем, когда пишем паттер, решетка,
текст и считаем их общую префикс-функцию?
Вы не поверите, но мы просто ходим текстом по этому
автомату.
Потому что это совсем не очевидно, когда вы это
делаете.
Вот вы решеткой говорите, все, я пошел в корень, то
есть я построил себе автомат, пойду-ка я ходить текстом
по этому автомату каждый раз и все.
И каждый раз выписывать себе, что у меня входит
такая-то вершинка, такая-то, такая-то, прыгнул назад
там, например, что-нибудь такое и так далее.
Вот, итого, осталось утверждение Михаила про ту и линке.
То есть, что утверждается, что если я, мы вроде разобрались,
что если у меня есть переход по букве, то все окей, вроде
бы.
Да, то есть мы сами выписывали определение ту от в по букве
с, это кто такой?
Это то от в по с, если есть из в, с в боре, иначе это
ту от линк от в по с, да, и что мы сами выписали?
Мы сами выписали такое утверждение, что линк от ту от в с, это
ту от линк от в с, и Михаил говорит, окей, вот я хочу
посчитать вот эту штуку.
Вдруг у меня ту от в с отсутствует в боре?
Ту от в с не в боре.
Откуда вот ту от в с?
Так, наверное, плохо видно, значит возьму другой маркер,
возможно этот.
равно по определению ту от линк от в с, да, еще хуже,
сейчас я, понимаете, здесь куча маркеров, и все плохие.
Умеется в виду переход из в по с не в боре.
Так, да, вроде бы это пожелал Михаил, тогда ту от в с равно
ту от линк от в с, просто по определению, тогда что
говоря, давайте поставим это сюда, да, тогда получается
линк, ой, я нашел маркер, равно ту от в с.
Действительно такое может быть, что у вас суффиксная
ссылка вершины ведет самужеб себя, это правда, нет, сейчас
не так, вообще по идее суффиксная ссылка должна вести во
что-то выше, вот, поэтому тогда получается, что это
корень, да, эта вершинка тогда корень, только тогда
это возможно, то есть тогда получается, что ту от линк
от в с это корень, когда это возможно вообще, что ту
от линк от в с это корень, вообще, это ситуация по-хорошему,
когда буквы от с вообще не входят никогда, кроме
как первый раз, точнее, вообще никогда не входят,
то, что мы сейчас снимем на Боре, вроде бы, ладно,
не суть, окей, ту от линк от в с это корень, ту от в
с не в Боре, значит, ту от линк от в по с это корень,
так, мы получали, что из этого следует это, ну, понятно,
что суффиксная ссылка несуществующей машины, она в корень ведет,
скорее всего, нет, еще раз, если ту от в с, то ту от в с
это несуществующая вершина, можно сказать, если у вас
ту от в с это несуществующая вершина, то есть ее нет в
Боре, значит, суффиксная ссылка ведет в корень, ну,
и в целом, можно определить, что из несуществующих вершин
все переходы в корень ведут, для согласованности, в плане
ее нет в Боре, ну да, в Боре его нет, но она в корень
она определена, но для нее уже линк определен, да.
Да, функции не существуют, реброна может не существовать,
да.
Ну, имеется в виду, что, да, ребро, но не из Бора.
Ну, короче говоря, что полностью формально убрать все противоречия,
проще сказать, что вот это утверждение верно, если
из вершины в есть ребро по букве с в Боре, тогда оно
действительно верно, если нет, то действительно
видимо какие-то коллизии получаются, еще что-то неприятное.
Ну, линк от корня это корень, и вроде все работает.
Ну, линк от корня это корень, это правда, можно так определить.
У нас какие-то приколы в правилах, если у нас из вершины
в Боре нет перехода в С, то у нас тогда линк от этой
вершины всегда корень, но это странно.
Ну, я понял, о чем это.
Если мы возьмем вот эту вершину, у нас есть у тебя переход.
Давайте вот эту вершину возьмем, да.
Мы в алгоритме вообще пользуемся тем, что у нас все переходы
приколены?
Да, пользуемся.
Ну, вообще, да, мы пользуемся.
Почему?
Потому что у нас есть переход не по букве сбора.
Вот.
Окей, давайте посмотрим, что такое переход.
Отсюда по С, да?
Куда он приведет вообще?
Сейчас, я скажу так.
Не-не-не.
Понятно, что он приведет сюда.
Я сейчас хочу построить случай, когда это не работает.
Хочу построить вот такой вот случай еще.
Пусть у меня добавилось АС.
Тогда у меня суффиксная ссылка, она ведет вот сюда вот.
Тогда у этой штуки по букве С переход ведет снова сюда.
Потому что вот линк от этой штуки по букве С сюда ведет.
А теперь я хочу почитать от этой штуки тупо С, да.
Я иду по суффиксной ссылке, и у меня уже определен переход по букве С.
Вот я хочу отсюда по букве С посчитать, куда оно ведет.
Ту от этой вершинки В, да.
А, ну окей, я определил как ту от линк от В по С, да.
Окей?
Дальше я смотрю, ну у меня уже ту определен здесь по С.
Именно как функция, не как ребро.
Да, да, мы уже посчитали, когда для этой штуки...
Не, смотрите, еще раз.
Для этой штуки мы ту по С посчитали.
Да, просто корень ссылка.
Для этой.
А, ну теперь да, она появилась, хорошо. Справедливо.
Тогда у этой штуки куда приведет по С?
Оно приведет вот сюда вот.
Да?
Ну будто бы да.
Потому что я возьму суффиксную ссылку сюда и перейду по букве С.
Дальше, я считаю, здесь по букве С переход.
Я беру суффиксную ссылку, и у меня определен переход по букве С.
Уже.
То есть здесь ту имеется в виду не в контексте ребра, а в контексте функции ту.
Да, но у нас в первом.
Ну здесь, мне кажется, да, действительно проблемы в том, как подметили,
что у нас коллизия обозначений, что такое ребро, что такое функция ту.
Но я утверждаю, что к моменту, когда мы рассматриваем вершину В,
для всех вершин выше нее и для всех букв определена функция ту.
А тогда, значит, у нас никаких противоречий с этим нет.
Вот, я предлагаю суетись на этом.
Если все-таки возникнет непонятный момент, то, наверное, проясню в следующий раз.
Хотя в следующий раз у нас там еще более сложная тема.
Вот, а пока что поздравляю вас с тем, что вы это поняли.
Наверное, это самое сложное, что было в этом году.
Все, всем пока.
