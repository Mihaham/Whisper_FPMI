Ну, в принципе, тут можно... Вот мы много чего изучили про mp-полноту.
В принципе, можно дальше в разных направлениях двигаться.
Ну, давайте я буду рассказывать про другие классы задач.
Да, в общем, мы поговорим про полинамиальную иерархию.
Вот. Значит, это некоторое такое обобщение np.
Можно прямо сюда это написать.
Обобщение np.
Вот. Ну и давайте начнем от такого вопроса.
Значит, рассмотрим какую-нибудь точную задачу оптимизации.
Например, чему равно хроматическое число графа?
Ну, соответственно, можно рассмотреть прям такую задачу.
Назовем ее хром-намбер.
Которая есть набор пар из графа и числа таких, что хроматическое число графа g в точности равно k.
И тогда получается следующее.
Если мы напишем здесь меньше либо равно, то это будет классическая np. полная задача.
Она будет np. полной, даже если там k ровно 3.
Ну, в общем, все равно.
И за это она будет np. трудной.
Да, в np она будет, потому что достаточно предъявить раскраску в не более чем k цветов.
Вот. Соответственно, если мы здесь напишем теперь больше либо равно, то это на самом деле будет coin.p полная задача.
Ну, потому что тут наоборот.
Для опровержения достаточно предъявить раскраску в меньше чем k цветов.
А как мы определим coin.p полнота?
Да, конечно, coin.p полнота точно так же, как np. полнота.
И вообще, на самом деле это общее понятие.
Если у вас есть какой-то класс и какое-то понятие сводимости, то возникает понятие полноты относительно этой сводимости.
Ну да, эти я тут припишу.
Значит, coin.p полнота это принадлежность к coin.p, плюс полиномиальная сводимость любой задачи из coin.p к данной.
И в принципе, значит, это у нас будет еще очень много раз встречаться в курсе.
Там будет, например, вот, ну, собственно, с полиномиальной иерархией будут некоторые классы, в них будет полнота.
Вот. Будет там B-space полнота, будет там NL полнота для логографической сводимости.
В общем, это одно из ключевых понятий.
Да, значит, есть понятие сводимости, очень важно, и есть понятие полноты, тоже очень важно.
Вот.
Хорошо. Значит, теперь, что дальше?
Да, значит, смотрите, если меньше, то это NL полное, если больше, то coin полное.
Вот. А если прямо равно, то, вероятно, не принадлежит ни к NL, ни к coin.p.
По крайней мере, неясно, как бы это можно было доказать или опровергнуть.
Да, то есть, как доказать, что в точности k? Ну, вот, непонятно. Можно, конечно, уменьшить либо равно k.
Как опровергнуть, что равно k? Ну, можно, конечно, опровергнуть, предъявив раскраску, меньшее число цветов.
Вот. Но опровергнуть, предъявив большее число цветов, не получится.
Да, значит, поэтому тоже непонятно, что делать.
Вот. Соответственно, можно только сказать, что это пересечение языка из NP и языка из coin.p.
Либо, что то же самое, либо, эквивалентно, разность двух языков из NP.
Значит, поскольку coin.p это множество дополнений к языкам из NP, то, соответственно, пересечение NP и coin.p это то же самое, что пересечение с дополнением.
Но пересечение с дополнением – это и есть разность.
Так. Хорошо. Соответственно, класс таких языков называется DP.
Значит, от слов Difference polynomial. Вот. То есть, получается, что DP – это множество… Ну, давайте через разность напишу.
Множество разностей двух языков, а значит, таких, что a из NP, a b из coin.p.
Вот.
Ой, да, если разность, то a b из NP, правильно.
Вот. Хорошо. Соответственно, здесь действительно более-менее все задачи точной оптимизации лежат в DP.
Ну, что значит все? Те, для которых можно проверить запоминальное время, что значение на данном входе равно тому-то.
Да, но таких задач у нас было довольно много.
Да, например, кроме хроматического числа были там задачи о клике или о члене независимости.
Да, в принципе, там задачи в рюкзаке можно так воспринимать, да, задачи Комико и Жора.
Вот, значит, куча вариантов, которые все вот такие вот.
Ну, и там целочисленно-линийное программирование, оно прям формулируется как задача оптимизации.
Так, хорошо. А теперь давайте посмотрим на вот эти вот языки.
Значит, теперь посмотрим на эти языки с точки зрения записи, ну, логическими формулами первого порядка.
Значит, смотрите, у нас, если А лежало в NP, то у нас получалось так, что х лежит в А тогда и только тогда, когда существует у в от x и у.
Да, значит, и это с обычными оговорками, да, что у там полинамерной длины, в полинамерной отчислимой.
Вот, ну и да, мы все, собственно.
Вот, значит, дальше в NP получалось так, да, значит, что х лежит в Б, х лежит в Б тогда и только тогда, когда получалось для любого у в от x и у.
Что это и из-за чего так получается? Ну, из того, что можно взять, да, Б это, например, дополнение К,
когда можно взять отрицание вот здесь, вот, что х лежит в дополнение К, то есть как раз в Б, а здесь вот отрицание существования.
А отрицание существования это будет для любого отрицания, и получится вот это w, это отрицание w.
Вот, ну а ясно, что если w вычислимо за полинамерное время, то и отрицание w тоже вычислимо за полинамерное время.
Так, значит, теперь что получается с точки зрения DP, да, пусть у нас теперь С лежит в DP, да, и С у нас, так, ну теперь давайте я наоборот напишу через пересечение,
чтобы совпадало вот с этим. Значит, С это пересечение А и B, где А в NP, B в coinP.
Вот, тогда получается следующее. А, давайте я еще здесь изменю у на z, да, чтобы были разные буквы.
Значит, получается, что х лежит в С, тогда и только тогда, когда одновременно существует у такой, что v от x, y, и для любого z w от x, z.
Вот, получается вот такая вот штука. А дальше это можно привести к предваренной нормальной форме, да, помните, мы такое изучали, что можно все кванторы вынести вперед.
И получится, что с одной стороны будет существует у для любого z, что здесь v от x, y, и w от x, z.
А с другой стороны можно и в другом порядке, да, можно писать для любого z, существует у, ну а здесь то же самое, v от x, y, и w от x, z.
Да, значит, помните, мы это обсуждали на логике, что просто так менять порядок кванторов нельзя, только в одну сторону можно, но если формула вот так вот расщепляется на две, тогда можно и в обе стороны менять.
Вот, то есть какой вывод, да, значит вывод такой, что здесь один квантор существования, здесь один квантор всеобщенности, а здесь у меня получается чередование.
Вот, и это соответственно уже задает полинамиальную иерархию, да, то есть вообще теперь можно определять, что такое полинамиальная иерархия.
Так, у нее есть много уровней, уровень 0, это просто P, уровень 0 это P, уровень 1 это NP и CoNP.
Дальше есть уровень 2, ну вот DP будет на уровне 2, но не только.
Да, значит будет, ой, нет, не так, значит будет sigma2 полинамиальная, значит это вот что, это множество таких а, что верно следующее, x лежит в a, тогда и только тогда, когда существует y.
Для любого z, а здесь какой-то v от x, y, z.
Вот, ну и соответственно P2 полинамиальная, значит тут соответственно будет наоборот, для любого y существует z.
Вот, ну и так далее, на самом деле, если вы помните, что такое архиметическая иерархия, то это очень похожая вещь, только вот, ну в общем определение почти точно такое же, только добавлено условия полинамиальности.
Да, значит соответственно получается, что вот все эти y и z должны быть полинамиальны длины от x, и v должно работать в полинамиальное время от x.
Вот, значит, ну а соответственно, дальше так можно продолжать, уровень k, уровень k это будет sigma kt полинамиальная,
значит это соответственно множество таких а, что x лежит в a, тогда и только тогда, когда существует y1, для любого y2 существует y3, и так далее.
Вот, ну и соответственно тут на самом деле в зависимости вот, дайте я вот так напишу, значит в зависимости от четности, значит если нечетное, то будет, существует, если четное, то для любого.
Существует для любого ykt, и дальше будет v, вот x, y1, и так далее ykt.
Вот, значит ну и соответственно pi, точно так же pi kt полинамиальная, здесь первый квантор наоборот.
Вот, выставим все точно так же, вот, значит ну в принципе и так далее, значит и так далее, еще будет просто ph, это объединение всех уровней.
ph от слова полиномиал хаэроши, значит это будет, так, пукат нуля до бесконечности, объединение пукат нуля до бесконечности, соответственно sigma kt полинамиальных,
ну и это в принципе то же самое, что объединение всех пукатах, это сейчас обсудим, почему это то же самое, вот, так хорошо, значит теперь хочется обсудить, как все эти классы друг с другом соотносятся,
да, значит видно на самом деле, что вот уровень 0 и уровень 1 согласован со всем, что дальше, да, потому что np это на самом деле sigma первое, потому что тут существование coin p это p первое, потому что только всеобщность, а p это на самом деле sigma нулевое и p нулевое,
да, здесь ни одного квантора нет, поэтому не важно какой он, да, значит вообще тут как и в случае с арифметической иерархией, то sigma это или p зависит от первого квантора, значит если первый квантор существования, то это sigma, если первый квантор всеобщенности, то это p, вот, ну а запомнить это можно так, что да, где sigma, а где p, ну смотрите, всеобщенность это что-то типа кайфовая,
а конъюнкция, а конъюнкция это что-то типа умножения, вот, а умножение это p, да, p это произведение, вот, ну а дизюнкция, нас, что-то типа дизюнкция, а дизюнкция это конечно не совсем сложение, но все-таки ближе к сложению, чем к умножению, но в общем с этим можно поспорить, но в общем это по исключению получается,
да, что соответственно, сочетание типа дизюнкции, дизюнкции типа сложения, вот, а сложение это сумма обозначается sigma, да, вот так можно запомнить где p, а где sigma, вот, но уж точно, уж точно дизюнкция это сложение, если считать, что ложь это ноль, а истина это любое положительное число, да, значит тогда уж точно конъюнкция это умножение, а дизюнкция это сложение прямо самое настоящее,
вот, ну и кстати, это на самом деле не так, это не просто метафора, это прям будет использоваться на какой-то момент, правда, видимо, в следующем курсе, да, хорошо, значит, ну, соответственно, можно, почему это иерархия, да, значит, вообще иерархии очень важны,
да, значит, для теории сложности, да, что важны не только отдельные классы, но и целые иерархии, да, а иерархии означают, что они как-то друг другу-другу вложены, и, соответственно, что тут так происходит, да, значит, вот есть нулевой уровень,
и это, да, значит, нулевой уровень, это не зависит от того, sigma или pi, и это, соответственно, это p, вот, значит, дальше есть n, p и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q
y и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q,
и q, и q, и q, и q, и q, и q.ía это состояниеnik 1 dimension insurance
написал по вал listened to a
iji
Сигма третья полинамиальная, пи третья полинамиальная, дальше и так далее, да и значит здесь где-то вот еще pH.
Вот, а дальше эта структура вложенности будет вот такой вот.
Это вложено вот так вот, п вложено в NP и также п вложено в CoNP, это мы хорошо знаем.
Вот, а дальше здесь будет вложение вот так вот, как бы и параллельное, и крест-накрест тоже.
Сигма 1 вложено в сигма 2, пи 1 вложено в пи 2.
И также сигма 1 вложено в пи 2 и пи 1 вложено в сигма 2.
Почему это так?
Ну, потому что можно просто добавить второй квантор, можно как бы добавить фиктивную переменную, второй квантор,
и причем его можно добавить как в ту, так и в другую сторону.
Да, то есть, например, если у нас было NP, да, у нас было NP, вот такое вот существование y,
то теперь можно считать, что у нас вот это самое v зависит не только от x и y, но еще от z.
Но при этом на самом деле от z оно не зависит, да, то есть там одни и те же значения для всех z.
Но тогда, соответственно, если от z зависимости нет, вот тогда можно любой квантор тут поставить,
например, все общности, и это ни на что не повлияет.
Так, ну а можно наоборот, можно представить, что вот тот старый y, это теперь у нас z, вот здесь вот,
а мы добавили новый y, от которого ничего не зависит.
И тогда к нему можно квантор в начало поставить,
да, от этого sigma1 будет вложено в pi2, да, здесь sigma2.
Ну и, в общем, это все аналогично.
И дальше вот эта же самая картина, она так и будет дальше продолжаться.
Вот, соответственно, так это будет все вложено, ну, значит, пока не будет вложено все в pH.
И как раз вот эти вложения, они показывают, почему, вот это вот верно, да,
значит, почему в обзине всех сигмакатах, это то же самое, что в обзине всех picat.
Потому что каждый сигмакат вложен в piqa1, и поэтому, соответственно,
в обзине всех сигмакат вложен в пк1, а это то же самое, что в обзине всех picat.
Ну и наоборот, piqa вложен в sigma, ka1, поэтому правая часть вложена в левую.
Вот, значит, вот поэтому это и иерархия.
Так, ну что, значит, здесь давайте чуть-чуть остановимся, может, кините вопросы есть.
Да, вот именно по определениям.
Дальше я хочу несколько примеров привести.
Несколько примеров.
Задач, которые сложнее, чем вот эти первые примеры, да, значит, сложнее, чем просто задача оптимизации.
Вот, но при этом лежат где-то вот на каких-то уровнях.
ПАШ-Полиномиалхоэрши.
Так, ну давайте.
Как это пишется, собственно, Полиномиалхоэрши.
Вот.
Так, ну ладно, значит, давайте.
Вот, вообще, на самом деле
искусственно можно построить примеры, в общем-то, на любом уровне,
но, естественно, это не так легко сделать.
Поэтому естественные примеры обычно на втором уровне, иногда на третьем. Вот.
Более высоко это скорее уже специальные примеры нужно струировать.
Вот, значит,
значит, примеры,
примеры задач
на втором и третьем
уровнях
Полиномиалхоэрши.
Так.
Ну, значит,
например, есть задача
минимальный
DNF,
да, ну, в виде,
или вообще минимальная формуля.
Так, первый пример,
значит,
задача на втором и третьем уровнях
на первом уровнях
на третьем уровне
на третьем уровне
на третьем уровне
например, задача о минимизации dnf, она вот так вот формируется,
minimal equivalent dnf, считается множество пар из формулы
и какого-то числа, что для формулы
для формулы
phi
существует
а
для формулы phi существует dnf длины k
такая, что
ну а просто эквивалент
но в принципе, потому что это именно dnf, это в принципе не очень важно
может быть какая-нибудь другая формула или просто произвольная формула
вот, ну в общем тут нужно написать так
существует psi такая, что для любого, а такая, что во-первых, psi dnf
psi dnf
соответственно длина psi
не больше k и на экваленте phi, а что это значит, это для любого x
для любого набора значений
длина прям больше k или ровно?
а, ну да, давайте не больше k
да, это для любого x
значит это соответственно на любом x значение psi такое же, как у phi
вот, ну соответственно вот это вот для любого можно вынести
ну а то есть можно эквивалентно написать вот так вот
здесь, соответственно, для любого x вот эту брать
вот, и тогда соответственно то, что в скобках будет полиномиально
да, полиномиально проверяемо
вот, и поэтому это получается sigma2
формула из sigma2 полиномиальная
вот, насчет ровно k можно еще заметить следующее, да, значит замечание
значит если потребовать
ну, точнее, если спрашивать
о кратчайшей, значит, о том имеет ли кратчайшее эквивалентное dnf длину k
то получится задача оптимизации
но она уже будет не из dp, а наоборот на этаж выше
будет sigma3 полиномиальная пересечь с pi3 полиномиальная
да, потому что опять же тут как бы нужно рассмотреть разность
разности вот такого языка для k и такого же для k-1
вот, ну а соответственно
аналогично, кстати, это можно будет чуть-чуть попозже обсудить
как в принципе теоретико-множительные операции влияют на уровень в иерархии
да, хорошо, значит, ну вот это вот первый пример
а можно вопрос?
да
мы вот тут пишем какие-то условия для psi и x
правда же вы не могли написать в скобках
что у psi на любом наборе так же как phi
то есть не используя x, потому что тогда бы это потребовало не полиномиальной проверки
ну конечно, да, конечно
мы могли бы не писать этот квантор, но тогда бы потеряли полиномиальность
вот, то есть тут в принципе когда стоит задача о классификации
то надо понимать, да, вот этот ваш квантор, он действительно нужен
и нам просто так удобно записать, а на самом деле можно без него
то есть, например, если какой-то полиномиальный перебор, то там может возникать квантор
но поскольку перегорка полиномиальной, то можно его перебрать
но здесь экспоненциальный перебор получается, да, потому что экспоненциально много разных наборов
так
хорошо
значит теперь можно
значит другой пример
значит другой пример, задача
по ram.save-ости
оооо
ооо
ооо
ооо
ооо
ооо
ооо
ооо
ооо
ну, не знаю, там
об
об
я так напишу, об обобщенной ram.save-ости графа
значит, что имеется ввиду
значит, вообще вы, наверное, изучали, да, Андрей Михайлович рассказывал про тюрем ram.save
про числа ram.save
да, и обычно там
тюрем такая, да, что
ну, для любых двух чисел
найдется
ну, для любых двух чисел
и достаточно
большого числа
вершин
да, и любого графа найдется либо там s
вершин по парносоединенных ребрами, либо t вершин по парносоединенных ребрами
да, вот это классическое тюрем ram.save
как бы это тюрем в полном графе
да, а может быть тюрема
ну, или не тюрема, а там задача у ram.save-ости частичного графа
да, то есть, например, у нас есть не полный граф, а какой-то граф
и он, и вот его только ребра раскрашены в два цвета
и тогда, соответственно, нужно
да, значит, вопрос
есть ли там полный граф на s вершинах одного цвета
или есть полный граф на t вершины другого цвета
а может быть еще больше обобщения
когда мы ищем не полный под граф
а вообще какой-нибудь
и вот это тут и спрашивается
да, значит, соответственно, тут
значит, задан граф
в общем, заданы три графа
f, g и h
и, соответственно, вопрос
да, значит, вопрос
верно ли, что для любой раскраски
ребер графа f в два цвета
найдется либо под граф первого цвета
изоморфный g
либо под граф второго цвета
изоморфный h
вот
вот, значит, вот такая у нас задача
вот, это можно сформулировать
да, то есть это можно сформулировать
как некоторый язык рэмси
тут, соответственно, есть тройки
значит, тройки f, g, h
значит, такие, что
существует некоторая функция раскраски
из ребер графа f
так, а, кстати, тоже sigma, что ли, получится
а, не, для любой, да, значит, для любой
вот, правильно все
для любой раскраски ребер графа f
в два цвета, значит, в 1, 2
существует такой под граф
ну, я не пишу как подношество, да, значит, под граф
под граф f
вот, такой, что либо
значит, либо k
изоморфин g
либо
изоморфин g
изоморфин g
и раскраска
на нем
тождественно равна единице
так, дать, я тут логическую операцию напишу
и
или, соответственно, k
изоморфин h
и раскраска на нем
тождественно, на двойке
вот, ну, вообще, я надеюсь, что обозначение понятное
да, значит, но главное получается, что это
значит, язык из p2 получается
язык из
p2 полюмянь
вопрос, да, значит, можно ли вот для этого графа
проверить вот такое обобщенное рамсаевское свойство
значит, что для любой раскраски найдется такой
или такой
ну, и как бы вот это обобщение
значит, вот это обобщение
нам позволяет избежать
разного рода оговорок
значит, типа того, что если
ну, мы же там, например, знаем, как числа рамсаева растут
да, они растут экспоненциально
вот, поэтому если мы просто рамсаевость будем проверять там для такого-то числа
да, там для полного графа, особенно если он прям явно написан
то это будет какая-то не очень сложная задача
ну, то есть как не сложная
нет, в смысле, она будет сложная, но она будет из CoINP
да, потому что раскрасок будет очень много
но если раскраска есть
то за счет вот этих вот симпатических оценок
можно получать, что
может только маленький может проверять
вот, а вот здесь это уже заведомо им именно P2 получается
так
хорошо
значит, теперь
может, какие-нибудь вопросы есть?
по предыдущему
а, сейчас здесь, заметьте, что здесь уже вроде нет никакого параметра оптимизации
поэтому ничего такого не получится
так, третий вопрос
еще вопрос про граф и раскраски
задача о кликовой раскраске
тоже интересная постановка
да, вполне интересная постановка
ну, я думаю, что тут, в принципе, можно что-нибудь поизучать, если кому интересно
значит, это задача кликовой раскраски
что вообще мы называем кликовой раскраской?
значит, кликовой раскраской
называется такая раскраска вершин графа
значит, что
любая раскраска
любая максимальная
в смысле, не увеличиваемая
то есть, не увеличиваемая
клика
ну, не покрашена в один тот же цвет
да, значит, содержит вершины
хотя бы двух цветов
вот
ну и тогда, например
да, значит, ясно, что
обычная правильная раскраска
обычная правильная раскраска
является кликовой
кликовой
да, значит, но
не наоборот
не в случае, когда граф не пустой
не, ну не только для сущности, когда граф не пустой
в общем случае, наоборот, не ясно
не в том плане, что
это ампликация, которая верна, а верна есть
если у нас в графе есть ребра
а, в смысле, я понял
что вы произолерные
да, что вообще, если у нас есть изолерные вершины, то там
ну, в общем-то, философский вопрос
считать изолерную вершину кликой
вообще, видимо, все-таки надо считать
ну, дайте этот допись как исключение
значит, исключение
изолированной вершины
тогда все-таки это будет верно
да, значит, что изолерную вершину можно в любой цвет красить
вот, в общем, давайте я покажу пример
да, значит, пример
пример, да
граф
это граф такой, такое колесо
да, есть
пятиугольное колесо, в общем
значит, есть центральная
вершина
и есть пять по циклу
вот, ну и, соответственно, нужно соединить
вот так вот
вот, значит, тогда понятно, что здесь
в обычном смысле
в два цвета его нельзя раскрасить
да, потому что вот эти три, треугольник и пятиугольник
вот
но, тем не менее, можно его раскрасить
в два цвета кликова
да, значит, это именно нужно
например, центр покрасить синий
да, например, центр покрасить синий
а дальше иметь
два подряд
так, и дальше, соответственно, чередовать
здесь, смотрите, никакое ребро не является
максимальной кликой
да, потому что любое ребро можно
строить до треугольника
с другой стороны
КАТ-4 тут нет вообще
поэтому все максимальные клики
это треугольники
вот, ну и прям видно, да, что здесь есть
пять треугольников
и в каждом из них хотя бы два цвета
вот, соответственно, это вот мы
покрасили в два цвета
соблюдением правил
кликовой раскраски
но соблюдением правил обычной раскраски
мы так не смогли сделать
так, хорошо
ну, соответственно, может быть, задача
да, обычная задача
у кликовой раскраски
да, значит, получается так
значит
да
у нас КА-2 является кликой
а, что тут
я не дочитал
извините
а, ладно
так
в общем, задача такая
да, это множество
пары из графа и числа
такое, что
соответственно
существует
кликовая раскраска
вершин же
вершин же
в К цветов
вот, и это у нас будет
записываться так, да
значит, существует
такая
соответственно, функция
знаешь, которая
вершины АДЖ
отображает
множество 1 и так далее
К
такая, что для любой
клики
любого С
может В
если С
это не увеличиваемая клика
то тогда
в С
есть разные цвета
вот
и
проблема в том, что
вот этот вот хуантер
нельзя изничтожить
потому что реально
неувеличиваемых клик может быть очень много
да, это упражнение
придумать граф, в котором неувеличиваемых клик
будет
ну,
сверхполиндарное число
какая-нибудь экспонента
поэтому
просто перебрать это всё нельзя
значит, если ребра можно все перебрать
то все неувеличиваемые клики
нельзя все перебрать
за пальмельное время
вот, а отсюда получается
снова
Сигма 2
вот, значит, ну дальше
есть ещё
другая задача
может быть
задача о
наследственной
кликовой раскраске
ну это не раскраска наследственная
давайте я напишу
раскрашиваемости
так, это
хредитари
клик колоринг
тут
соответственно
можно писать так
что это пара из
g и k
таких, что любой
под граф
g
кликово
раскрашивается
к цветов
в частности, вот этот граф, который здесь
нарисован
он не является
наследственно раскрашиваемого в два цвета
потому что если центральную точку убрать
то останется цикл из пяти вершин
и тогда
максимальные клики это будут просто
ребра
и тогда, конечно, цикл из пяти вершин
нельзя покрасить в два цвета
может только в три
вот, поэтому
весь граф раскрашивается в кликовом смысле
в два цвета
а под граф не раскрашивается
а тут мы, соответственно, спрашиваем
что не только сам граф, но и любой под граф
раскрашивается
вот
соответственно, ясно
значит, ясно, что это может быть более сложная задача
но и реально получается так
то есть тут получается, что для любого
h под граф
существует
то же самое, что там
значит
c из вершин
граф h
в один
и так далее
да, я хотел еще сказать, что это отличие от обычной раскрашиваемости
что если у нас
граф в обычном смысле раскрашился в к цветов
то и любой под граф тоже в конце цветов
раскрасятся
а здесь получается, что граф раскрасился
кликово, а под граф не красится
соответственно, это дальше
для любого s
под множество v от h
а здесь получается
то же самое, что было
вот
соответственно, это получается
p
3
пальномиальная
а если мы прям еще
ищем
где может четвертый уровень
возникнуть
значит, если искать
точное значение
наследственного
кликового
хроматического числа
потом понятно, что
это имеется в виду
да, то есть
минимальное число цветов
в которые любой под граф можно кликово раскрасить
вот, то получится
задача из
p4
пальномиальная в пересечение
σ4
пальномиальная
то есть до четвертого уровня
иногда все-таки как-то достреливает
такие содержательные задача
вот, ну и еще последний пример хочу привести
значит, последний пример
это
тоже, я думаю, вам знакомый сюжет
задача
о размерности
вапника-червоненкеса
изучали ведь такое
на вашем новом обучении, да?
или что там где-нибудь
на дискране
на дискране изучали, отлично
так
хорошо, ну соответственно задача
ну, как бы задача ее посчитать
есть
какой-то набор
множеств
значит
s1 и так далее
там sn
и нужно
там
размерность вапника-червоненкеса
да, от этого самого
s
больше либо ровно чем k
ну или ровно k, но ровно k это будет опять же оптимизация
да, больше либо ровно k это
какая-то задача
такая обычная
вот, значит, ну тут стоит вопрос
значит, давайте вспомним, что это такое
напоминание
что вот эта самая размерность
это максимальное число элементов
в x
да, о таком, что
среди
пересечений s и t, x
и x есть все подножства
x
вот, значит, на самом деле
сложная такая задача
существенно зависит от того, как именно
записана
вот эта система
значит, если она
в явном виде записана, то
это будет более простая задача
значит, тут предполагаем
что система
s
записана
в сжатом виде
значит
например
есть
какая-то логическая схема
phi
значит, которая
по индексу
по индексу
и
элементу
x сообщает
лежит ли
x в s и t
вот, ну, про логические схемы
мы еще поговорим подробнее
ну, в общем, это что-то типа логических формул
но там можно
переиспользовать платформулы, например
да, в общем, мы про это поговорим подробнее
если вы там не знаете
то можно просто представить, что есть какое-то
короткое описание
такое, что
в общем, у i есть
некоторая длина
и это будет логарифм n
да, то есть тогда можно
считать
тут я n большое сделаю
да, есть такое соглашение
что n маленькое – это логарифм от n большого
вот, соответственно
может быть так
что
n
будет
экспонента от n малого
да, а
размер phi
это
полинов от n малого
вот, ну, то есть
то есть
экспоненциальное
семейство множеств
задано полиновиальным
описанием
вот, ну и тогда
будет такая формула
тогда формула
будет такой
существует
x большое
что для любого
t
под множество
x большое
существует
и
ну, такой, что
соответственно
s и t
в пересечении с x
равняется t
вот, ну, то есть это
то есть форма будет
sigma 3
sigma 3 полинумеральная
вот, и действительно тут
ничего сократить нельзя
потому что если вот это множество
экспоненциально большое
то тогда и вот это вот
и нельзя
перебором найти
и тогда и под множество x может быть
экспоненциально много
ну, и самих x тем более экспоненциально много
поэтому ни один из этих кванторов
поэтому ни один из этих кванторов сократить нельзя
если нет вот такого вот сжатого описания
да, то есть
вот это n большое там
само полинумеральное, тогда, например
ну, все под множество здесь можно перебирать
и это будет не больше, чем np
то есть sigma 3 получилось именно вот для такой
сжатой записи
вот, ну а как обычно
точно задача оптимизации будет
p4 и sigma 4
да, то есть всегда задача оптимизации
на этаж выше, чем
вопрос для конкретного
числа
наверное стоит добавить, что мощность
x больше или равна k
а, надо, конечно, да
ну ладно, да, в общем, давайте сюда
давай прямо внутрь
а
да, можно было
добавить сюда, но
в общем, мы знаем, что это можно вынести
наружу этих кванторов
вот
так, хорошо
так, значит, вот такие вот примеры
ну, теперь
возникает вопрос
насколько это все
так
что возникает вопрос
вот какой, да, значит, тут у нас вот здесь
иерархия
а насколько она все-таки вот на самом деле
такая иерархия
да, не может ли быть так, что
это мы тут что-то придумали, оно все
на самом деле одинаковое, да, или что-нибудь еще
да, в принципе, это каждый из этих задач
но пока никто
не придумал
что-то чего-то более простого
вот, но может это просто
мы не смогли придумать, да
на самом деле можно
вот, но оказывается, что все-таки есть
некоторые основания полагать
что
они все разные
давайте начнем с такой теоремы
значит, теоремы
на самом деле, если P равно NP
то P равно PH
это называется
это называется коллапсирование
полинамиальной
иерархии
вот, но как
будем доказывать
ну, смотрите там, первое
первое, если P равно NP
то тогда P равно
ICO NP
ну, действительно
значит, если
B лежит
в CoNP
то из этого следует, что
B с чертой
лежит в NP
из этого следует, что
B с чертой лежит в P
если мы предположим, что P равно NP
так, сейчас давайте это
отделю, значит, доказательства
вот, ну а из этого следует,
что и B лежит в P
потому что P за кто-то тинет
дополнение
так, ну хорошо
теперь давайте
так, напишем
что если P равно CoNP
то тогда, например
sigma 2
полинамиальная
sigma 2
полинамиальная
софе просто с NP
так, ну тут, смотрите
значит у нас
там A
лежит, например
sigma 2
лежит, например, sigma 2
полинамиальная
вот, соответственно
у нас случается, что
X лежит в A
тогда и только тогда
когда существует Y
для любого Z
V от
X, Y, Z
вот
но теперь можно рассмотреть
такое множество
множество пар
X, Y
таких, что
для любого Z
V от X, Y, Z
равно 1
что Z лежит в CoNP
значит
этого следует, что
лежит в P
вот
ну а тогда получается, что
X лежит в A
равносильно
равносильно
в существовании Y
ну а дальше
как получается вот это вот
где вот эта штука уже
лежит в P
значит тут
условия
в скобках
лежит в P
так что все вместе
лежит в NP
ну а соответственно
дальше получается по транзитивности
по силогизму
если P равно NP
то тогда получается, что
sigma 2 полинамиальная
равно P
ну и так далее, значит далее аналогично
да, то есть если P равно NP
то последний квантор мы можем вот так
схлопывать
и спускаться на этаж ниже
а дальше еще один схлопывать, еще один и так далее
вот
но это вот такой
такой
жесткий пример
коллапсирования
ну а дальше конечно
после того, как мы доказали, что все уровни
совпадают с P
то pH тоже совпадает с P
то есть тут
значит в итоге
раз все уровни
равны P
то и pH равно P
как объединение
так
ну и дальше есть общая теорема
общая теорема о коллапсировании
значит
следующее три условия
эквивалентные
так, первое
первое, что две сигмы подряд совпали
sigma kt
polynomial
да, значит равняется
sigma k
плюс первому
polynomial
второе, что
на том же уровне sigma
и P совпали
значит sigma kt
равняется Pk
и третье, что
весь pH
равняется
sigma kt
ну вот получается, что
такие условия
эквивалентные
так, ну у нас еще есть время
доказательства
так
ну это конечно
да
так, ну вообще значит
на самом деле ясно, вот из третьего, первого
и второго
следует
автоматически
да, потому что смотрите
то
то есть вообще
на самом деле
тут, да, я вот немножко
не поговорил про
все эти множественные свойства
но по крайней мере
мне конечно должно быть ясно следующее
что A лежит
в sigma kt
тогда и только тогда
когда A с чертой
лежит
в Pk
вот
ну потому что если
вот там добавим отрицание
принесенному через всю цепочку
то все кванторы поменяются
вот, поэтому
соответственно
вот здесь вот во втором достаточно
в одну сторону доказывать вложение
вот
ну а тогда соответственно
например Pk вложено в sigma kt
плюс первое
sigma kt плюс первое в силу вот этого
вот
не так уж просто
не так уж просто
значит вот наверное
из третьего в первое прям очевидно
значит из третьего в первое
очевидно
что слева направо мы уже доказывали
а справа налево
sigma kt плюс первое пленомиальное
вложено
в pH
вложено в
sigma kt
пленомиальное
вот, значит
из третьего в второе
из третьего в второе
тут чуть-чуть сложнее
получается что
Pkt
пленомиальное
вложено
в sigma
kt плюс первое
пленомиальное
это вложено
в pH
и это вложено
в sigma kt
пленомиальное
вот отсюда
ну а дальше за счет
за счет
перехода
к дополнениям
наоборот тоже верно
значит sigma kt
kt пленомиальное
kt пленомиальное
вот, поэтому интересно
в обратную сторону
значит например
из первого третья
значит из первого третья
но это в принципе аналогично
к тому что вот здесь было
а
на самом деле тут
на самом деле тут удобнее делать вот так вот
значит удобнее делать
что первое равносильно второму
а потом уже переходить
из того и другого к третьему
так
ну а в самом деле из
первой и второй
на самом деле аналогично получается
аналогично предыдущему
да
просто аналогично
предыдущему
значит без
pH
по дороге
да, то есть вот это вот первое всегда верно
значит kt всегда вложено в sigma kt
и если они равны, то это ложные
sigma kt
поэтому
интересно в второго, в первое
так
не в второго, в первое
это как раз
похоже на то что здесь
ну значит смотрите у нас
пусть a будет лежать
в sigma k
плюс первым
в альномерном
вот тогда у нас получается что
x лежит в a
тогда и только тогда когда существует
тогда и только тогда когда
существует
давайте я первую выделю
существует
существует y
для любого z1
существует
z2
и так далее
да и в конце там для любого
или существует, для любого
zkt
а дальше какой-то
v
вот x, y
z1
и так далее zkt
ну тогда соответственно
но что таких пар
x, y
что значит верно
то же самое начиная
с второго
да значит вот это вот будет лежать
в pic atom
ну а значит
лежит его
в sigma
к атом
ну потому что мы предположили
что они равны
то есть получается что
вот это вот верно
да значит это будет
равносильно
тому что тут какие-то другие
существует
какой-то t1
для любого
t2
и так далее
существует
tkt
здесь какой-то w от x, y
t1
и так далее
tkt
так
ну тогда получается что в итоге
в итоге x лежит va
тогда и только тогда
когда здесь
существует y
потом все то же самое
ну то есть можно писать так
существует
пара из y
tk и t1
дальше вот это вот
и это уже будет sigma k выражение
sigma kt
полимерное выражение
то есть получается что
значит в итоге
у нас лежит
sigma kt
то есть доказали
ну и осталось
например из первого третья
нет вот из первого третьего еще не доказали
у нас первое второе
и они оба из третьего
так что еще нужно
из первого третьего
ну из первого третьего смотрите
если
в общем у нас довольно легко
если вот эти равны
так если эти равны
то
верный наоборот
то есть и
kt полимерное тоже равно
это как раз то что вы спрашивали
kt плюс 1
вот а раз
мы уже доказали
что отсюда следует
что sigma kt
равняется pi kt
то и
sigma k
плюс 1
равняется pi
k плюс 1
вот отсюда
получаем
что sigma
k плюс 1
будет равно
sigma k
плюс 2
то есть получили что
sigma kt
равняется
sigma k
плюс 2
ну и далее
ну и далее по индукции
далее по индукции
все будет получаться
что еще раз
откуда у нас равенство
kp и pkp
вот это вот такое что
только что доказали что из первого
второго следует
точно
из первого второго следует
то есть тут как бы
мы вот оба этих использовали
вот здесь получилось что
из первого второго отсюда
получилось второе на шаг выше
а отсюда получилось первое
на шаг выше
ну и дальше вот эти равны
вот эти равны
по индукции
понятно что теперь у нас
все более высокие sigma равны kt
значит объединение всех тоже равно kt
вот ну собственно все
значит на этом давайте
видимо закончим
может кинча вопроса есть
но сейчас обычно предполагают
что
иерархия нигде не склопывается
не коллапсируется
да предполагают что несмотря на то что
интересные задачи только на первых двух нижних уровнях
что нигде не склопывается
но на самом деле на каждом уровне есть
полные задачи
которые
они получаются не очень интересные но они есть
в частности все
все предыдущие будут полные
на втором и на третьем уровня
вот ну либо другом они тоже есть вот и да да такая что это все разное вот то есть все как
а следующий уровень выше предыдущего но соответственно пашу выше любого конкретного
так ну ладно тогда на этом все
